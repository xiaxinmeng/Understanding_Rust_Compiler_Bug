{"sha": "c9d70ab181e531bfe069c42aeaa996ec96bca02e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzlkNzBhYjE4MWU1MzFiZmUwNjljNDJhZWFhOTk2ZWM5NmJjYTAyZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-03-02T09:24:38Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-03-02T09:24:38Z"}, "message": "[multiple changes]\n\n2015-03-02  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference, case Input): When\n\texpanding a 'Input attribute reference for a class-wide type,\n\tdo not generate a separate object declaration for the controlling\n\ttag dummy object; instead, generate the expression inline in the\n\tdispatching call. Otherwise, the declaration (which involves a\n\tcall to String'Input, returning a dynamically sized value on the\n\tsecondary stack) will be expanded outside of proper secondary\n\tstack mark/release operations, and will thus cause a secondary\n\tstack leak.\n\n2015-03-02  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* checks.adb (Add_Validity_Check): Change the names of all\n\tformal parameters to better illustrate their purpose. Update\n\tthe subprogram documentation. Update all occurrences of the\n\tformal parameters. Generate a pre/postcondition pragma by\n\tcalling Build_Pre_Post_Condition.\n\t(Build_PPC_Pragma): Removed.\n\t(Build_Pre_Post_Condition): New routine.\n\t* einfo.adb Node8 is no longer used as Postcondition_Proc. Node14\n\tis now used as Postconditions_Proc. Flag240 is now renamed to\n\tHas_Expanded_Contract.\t(First_Formal): The routine can now\n\toperate on generic subprograms.\n\t(First_Formal_With_Extras): The routine can now operate on generic\n\tsubprograms.\n\t(Has_Expanded_Contract): New routine.\n\t(Has_Postconditions): Removed.\n\t(Postcondition_Proc): Removed.\n\t(Postconditions_Proc): New routine.\n\t(Set_Has_Expanded_Contract): New routine.\n\t(Set_Has_Postconditions): Removed.\n\t(Set_Postcondition_Proc): Removed.\n\t(Set_Postconditions_Proc): New routine.\n\t(Write_Entity_Flags): Remove the output of Has_Postconditions. Add\n\tthe output of Has_Expanded_Contract.\n\t(Write_Field8_Name): Remove the output of Postcondition_Proc.\n\t(Write_Field14_Name): Add the output of Postconditions_Proc.\n\t* einfo.ads New attributes Has_Expanded_Contract and\n\tPostconditions_Proc along with occurrences in entities.\n\tRemove attributes Has_Postconditions and Postcondition_Proc\n\talong with occurrences in entities.\n\t(Has_Expanded_Contract): New routine along with pragma Inline.\n\t(Has_Postconditions): Removed along with pragma Inline.\n\t(Postcondition_Proc): Removed along with pragma Inline.\n\t(Postconditions_Proc): New routine along with pragma Inline.\n\t(Set_Has_Expanded_Contract): New routine along with pragma Inline.\n\t(Set_Has_Postconditions): Removed along with pragma Inline.\n\t(Set_Postcondition_Proc): Removed along with pragma Inline.\n\t(Set_Postconditions_Proc): New routine along with pragma Inline.\n\t* exp_ch6.adb (Add_Return): Code cleanup. Update the\n\tgeneration of the call to the _Postconditions routine of\n\tthe procedure.\t(Expand_Non_Function_Return): Reformat the\n\tcomment on usage. Code cleanup.  Update the generation of\n\tthe call to the _Postconditions routine of the procedure or\n\tentry [family].\n\t(Expand_Simple_Function_Return): Update the\n\tgeneration of the _Postconditions routine of the function.\n\t(Expand_Subprogram_Contract): Reimplemented.\n\t* exp_ch6.ads (Expand_Subprogram_Contract): Update the parameter\n\tprofile along the comment on usage.\n\t* exp_ch9.adb (Build_PPC_Wrapper): Code cleanup.\n\t(Expand_N_Task_Type_Declaration): Generate pre/postconditions\n\twrapper when the entry [family] has a contract with\n\tpre/postconditions.\n\t* exp_prag.adb (Expand_Attributes_In_Consequence): New routine.\n\t(Expand_Contract_Cases): This routine and its subsidiaries now\n\tanalyze all generated code.\n\t(Expand_Old_In_Consequence): Removed.\n\t* sem_attr.adb Add with and use clause for Sem_Prag.\n\t(Analyze_Attribute): Reimplment the analysis of attribute 'Result.\n\t(Check_Use_In_Test_Case): Use routine Test_Case_Arg to obtain\n\t\"Ensures\".\n\t* sem_ch3.adb (Analyze_Declarations): Analyze the contract of\n\ta generic subprogram.\n\t(Analyze_Object_Declaration): Do not create a contract node.\n\t(Derive_Subprogram): Do not create a contract node.\n\t* sem_ch6.adb (Analyze_Abstract_Subprogram_Declaration): Do\n\tnot create a contract node.\n\t(Analyze_Completion_Contract): New routine.\n\t(Analyze_Function_Return): Alphabetize.\n\t(Analyze_Generic_Subprogram_Body): Alphabetize. Do not create a\n\tcontract node.\tDo not copy pre/postconditions to the original\n\tgeneric template.\n\t(Analyze_Null_Procedure): Do not create a contract node.\n\t(Analyze_Subprogram_Body_Contract): Reimplemented.\n\t(Analyze_Subprogram_Body_Helper): Do not mark the enclosing scope\n\tas having postconditions. Do not create a contract node. Analyze\n\tthe subprogram body contract of a body that acts as a compilation\n\tunit. Expand the subprogram contract after the declarations have\n\tbeen analyzed.\n\t(Analyze_Subprogram_Contract): Reimplemented.\n\t(Analyze_Subprogram_Specification): Do not create a contract node.\n\t(List_Inherited_Pre_Post_Aspects): Code cleanup.\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Contract): Update the\n\tcomment on usage.\n\t(Analyze_Subprogram_Contract): Update the\n\tparameter profile and the comment on usage.\n\t* sem_ch7.adb (Analyze_Package_Body_Helper): Do not create a\n\tcontract node.\n\t(Analyze_Package_Declaration): Do not create a\n\tcontract node.\n\t(Is_Subp_Or_Const_Ref): Ensure that the prefix has an entity.\n\t* sem_ch8.adb (Analyze_Subprogram_Renaming): Do not create a\n\tcontract node.\n\t* sem_ch9.adb (Analyze_Entry_Declaration): Do not create a\n\tcontract node.\n\t* sem_ch10.adb (Analyze_Compilation_Unit): Move local variables to\n\ttheir proper section and alphabetize them. Analyze the contract of\n\ta [generic] subprogram after all Pragmas_After have been analyzed.\n\t(Analyze_Subprogram_Body_Stub_Contract): Alphabetize.\n\t* sem_ch12.adb (Analyze_Generic_Package_Declaration): Do not\n\tcreate a contract node.\n\t(Analyze_Generic_Subprogram_Declaration):\n\tAlphabetize local variables. Do not create a contract\n\tnode. Do not generate aspects out of pragmas for ASIS.\n\t(Analyze_Subprogram_Instantiation): Instantiate\n\tthe contract of the subprogram.  Do not create a\n\tcontract node.\t(Instantiate_Contract): New routine.\n\t(Instantiate_Subprogram_Body): Alphabetize local variables.\n\t(Save_Global_References_In_Aspects): New routine.\n\t(Save_References): Do not save the global references found within\n\tthe aspects of a generic subprogram.\n\t* sem_ch12.ads (Save_Global_References_In_Aspects): New routine.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Do not use\n\tOriginal_Node for establishing linkages.\n\t(Insert_Pragma): Insertion in a subprogram body takes precedence over\n\tthe case where the subprogram body is also a compilation unit.\n\t* sem_prag.adb (Analyze_Contract_Cases_In_Decl_Part): Use\n\tGet_Argument to obtain the proper expression. Install the generic\n\tformals when the related context is a generic subprogram.\n\t(Analyze_Depends_In_Decl_Part): Use Get_Argument to obtain\n\tthe proper expression. Use Corresponding_Spec_Of to obtain\n\tthe spec. Install the generic formal when the related context\n\tis a generic subprogram.\n\t(Analyze_Global_In_Decl_Part): Use Get_Argument to obtain the proper\n\texpression. Use Corresponding_Spec_Of to obtain the spec. Install the\n\tgeneric formal when the related context is a generic subprogram.\n\t(Analyze_Initial_Condition_In_Decl_Part): Use Get_Argument\n\tto obtain the proper expression. Remove the call to\n\tCheck_SPARK_Aspect_For_ASIS as the analysis is now done\n\tautomatically.\n\t(Analyze_Pragma): Update all occurrences\n\tto Original_Aspect_Name. Pragmas Contract_Cases, Depends,\n\tExtensions_Visible, Global, Postcondition, Precondition and\n\tTest_Case now carry generic templates when the related context\n\tis a generic subprogram. The same pragmas are no longer\n\tforcefully fully analyzed when the context is a subprogram\n\tthat acts as a compilation unit. Pragmas Abstract_State,\n\tInitial_Condition, Initializes and Refined_State have been clean\n\tup. Pragmas Post, Post_Class, Postcondition, Pre, Pre_Class\n\tand Precondition now use the same routine for analysis. Pragma\n\tRefined_Post does not need to check the use of 'Result or\n\tthe lack of a post-state in its expression. Reimplement the\n\tanalysis of pragma Test_Case.\n\t(Analyze_Pre_Post_Condition): New routine.\n\t(Analyze_Pre_Post_Condition_In_Decl_Part):\n\tReimplemented.\n\t(Analyze_Refined_Depends_In_Decl_Part): Use Get_Argument to obtain the\n\tproper expression.\n\t(Analyze_Refined_Global_In_Decl_Part): Use Get_Argument to obtain\n\tthe proper expression.\n\t(Analyze_Test_Case_In_Decl_Part): Reimplemented.\n\t(Check_Pre_Post): Removed.\n\t(Check_Precondition_Postcondition): Removed.\n\t(Check_SPARK_Aspect_For_ASIS): Removed.\n\t(Check_Test_Case): Removed.\n\t(Collect_Subprogram_Inputs_Outputs): Use Get_Argument\n\tto obtain the proper expression. Use Corresponding_Spec_Of to\n\tfind the proper spec.\n\t(Create_Generic_Template): New routine.\n\t(Duplication_Error): New routine.\n\t(Expression_Function_Error): New routine.\n\t(Find_Related_Subprogram_Or_Body): Moved to the spec\n\tof Sem_Prag. Emit precise error messages. Account for cases of\n\trewritten expression functions, generic instantiations, handled\n\tsequence of statements and pragmas from aspects.\n\t(Get_Argument): New routine.\n\t(Make_Aspect_For_PPC_In_Gen_Sub_Decl): Removed.\n\t(Preanalyze_CTC_Args): Removed.\n\t(Process_Class_Wide_Condition): New routine.\n\t* sem_prag.ads (Analyze_Test_Case_In_Decl_Part): Update\n\tthe parameter profile along with the comment on usage.\n\t(Find_Related_Subprogram_Or_Body): Moved from the body of Sem_Prag.\n\t(Make_Aspect_For_PPC_In_Gen_Sub_Decl): Removed.\n\t(Test_Case_Arg): New routine.\n\t* sem_util.adb Add with and use clauses for Sem_Ch6.\n\t(Add_Contract_Item): This routine now creates a contract\n\tnode the first time an item is added. Remove the duplicate\n\taspect/pragma checks.\n\t(Check_Result_And_Post_State): Reimplemented.\n\t(Corresponding_Spec_Of): New routine.\n\t(Get_Ensures_From_CTC_Pragma): Removed.\n\t(Get_Requires_From_CTC_Pragma): Removed.\n\t(Has_Significant_Contract): New routine.\n\t(Inherit_Subprogram_Contract): Inherit only if the source\n\thas a contract.\n\t(Install_Generic_Formals): New routine.\n\t(Original_Aspect_Name): Removed.\n\t(Original_Aspect_Pragma_Name): New routine.\n\t* sem_util.ads (Check_Result_And_Post_State): Reimplemented.\n\t(Corresponding_Spec_Of): New routine.\n\t(Get_Ensures_From_CTC_Pragma): Removed.\n\t(Get_Requires_From_CTC_Pragma): Removed.\n\t(Has_Significant_Contract): New routine.\n\t(Install_Generic_Formals): New routine.\n\t(Original_Aspect_Name): Removed.\n\t(Original_Aspect_Pragma_Name): New routine.\n\t* sem_warn.adb Add with and use clauses for Sem_Prag.\n\t(Within_Postcondition): Use Test_Case_Arg to extract \"Ensures\".\n\nFrom-SVN: r221101", "tree": {"sha": "fef9e066027e89d2a1f80384805126004eb62d4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fef9e066027e89d2a1f80384805126004eb62d4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9d70ab181e531bfe069c42aeaa996ec96bca02e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9d70ab181e531bfe069c42aeaa996ec96bca02e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9d70ab181e531bfe069c42aeaa996ec96bca02e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9d70ab181e531bfe069c42aeaa996ec96bca02e/comments", "author": null, "committer": null, "parents": [{"sha": "95e00a3a825cb27fb9b4db7007a94462aa311561", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95e00a3a825cb27fb9b4db7007a94462aa311561", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95e00a3a825cb27fb9b4db7007a94462aa311561"}], "stats": {"total": 6686, "additions": 3606, "deletions": 3080}, "files": [{"sha": "c5d1f234d08be83d99f35556a4eeb60a828d5f7a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -1,3 +1,215 @@\n+2015-03-02  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_attr.adb (Expand_N_Attribute_Reference, case Input): When\n+\texpanding a 'Input attribute reference for a class-wide type,\n+\tdo not generate a separate object declaration for the controlling\n+\ttag dummy object; instead, generate the expression inline in the\n+\tdispatching call. Otherwise, the declaration (which involves a\n+\tcall to String'Input, returning a dynamically sized value on the\n+\tsecondary stack) will be expanded outside of proper secondary\n+\tstack mark/release operations, and will thus cause a secondary\n+\tstack leak.\n+\n+2015-03-02  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* checks.adb (Add_Validity_Check): Change the names of all\n+\tformal parameters to better illustrate their purpose. Update\n+\tthe subprogram documentation. Update all occurrences of the\n+\tformal parameters. Generate a pre/postcondition pragma by\n+\tcalling Build_Pre_Post_Condition.\n+\t(Build_PPC_Pragma): Removed.\n+\t(Build_Pre_Post_Condition): New routine.\n+\t* einfo.adb Node8 is no longer used as Postcondition_Proc. Node14\n+\tis now used as Postconditions_Proc. Flag240 is now renamed to\n+\tHas_Expanded_Contract.\t(First_Formal): The routine can now\n+\toperate on generic subprograms.\n+\t(First_Formal_With_Extras): The routine can now operate on generic\n+\tsubprograms.\n+\t(Has_Expanded_Contract): New routine.\n+\t(Has_Postconditions): Removed.\n+\t(Postcondition_Proc): Removed.\n+\t(Postconditions_Proc): New routine.\n+\t(Set_Has_Expanded_Contract): New routine.\n+\t(Set_Has_Postconditions): Removed.\n+\t(Set_Postcondition_Proc): Removed.\n+\t(Set_Postconditions_Proc): New routine.\n+\t(Write_Entity_Flags): Remove the output of Has_Postconditions. Add\n+\tthe output of Has_Expanded_Contract.\n+\t(Write_Field8_Name): Remove the output of Postcondition_Proc.\n+\t(Write_Field14_Name): Add the output of Postconditions_Proc.\n+\t* einfo.ads New attributes Has_Expanded_Contract and\n+\tPostconditions_Proc along with occurrences in entities.\n+\tRemove attributes Has_Postconditions and Postcondition_Proc\n+\talong with occurrences in entities.\n+\t(Has_Expanded_Contract): New routine along with pragma Inline.\n+\t(Has_Postconditions): Removed along with pragma Inline.\n+\t(Postcondition_Proc): Removed along with pragma Inline.\n+\t(Postconditions_Proc): New routine along with pragma Inline.\n+\t(Set_Has_Expanded_Contract): New routine along with pragma Inline.\n+\t(Set_Has_Postconditions): Removed along with pragma Inline.\n+\t(Set_Postcondition_Proc): Removed along with pragma Inline.\n+\t(Set_Postconditions_Proc): New routine along with pragma Inline.\n+\t* exp_ch6.adb (Add_Return): Code cleanup. Update the\n+\tgeneration of the call to the _Postconditions routine of\n+\tthe procedure.\t(Expand_Non_Function_Return): Reformat the\n+\tcomment on usage. Code cleanup.  Update the generation of\n+\tthe call to the _Postconditions routine of the procedure or\n+\tentry [family].\n+\t(Expand_Simple_Function_Return): Update the\n+\tgeneration of the _Postconditions routine of the function.\n+\t(Expand_Subprogram_Contract): Reimplemented.\n+\t* exp_ch6.ads (Expand_Subprogram_Contract): Update the parameter\n+\tprofile along the comment on usage.\n+\t* exp_ch9.adb (Build_PPC_Wrapper): Code cleanup.\n+\t(Expand_N_Task_Type_Declaration): Generate pre/postconditions\n+\twrapper when the entry [family] has a contract with\n+\tpre/postconditions.\n+\t* exp_prag.adb (Expand_Attributes_In_Consequence): New routine.\n+\t(Expand_Contract_Cases): This routine and its subsidiaries now\n+\tanalyze all generated code.\n+\t(Expand_Old_In_Consequence): Removed.\n+\t* sem_attr.adb Add with and use clause for Sem_Prag.\n+\t(Analyze_Attribute): Reimplment the analysis of attribute 'Result.\n+\t(Check_Use_In_Test_Case): Use routine Test_Case_Arg to obtain\n+\t\"Ensures\".\n+\t* sem_ch3.adb (Analyze_Declarations): Analyze the contract of\n+\ta generic subprogram.\n+\t(Analyze_Object_Declaration): Do not create a contract node.\n+\t(Derive_Subprogram): Do not create a contract node.\n+\t* sem_ch6.adb (Analyze_Abstract_Subprogram_Declaration): Do\n+\tnot create a contract node.\n+\t(Analyze_Completion_Contract): New routine.\n+\t(Analyze_Function_Return): Alphabetize.\n+\t(Analyze_Generic_Subprogram_Body): Alphabetize. Do not create a\n+\tcontract node.\tDo not copy pre/postconditions to the original\n+\tgeneric template.\n+\t(Analyze_Null_Procedure): Do not create a contract node.\n+\t(Analyze_Subprogram_Body_Contract): Reimplemented.\n+\t(Analyze_Subprogram_Body_Helper): Do not mark the enclosing scope\n+\tas having postconditions. Do not create a contract node. Analyze\n+\tthe subprogram body contract of a body that acts as a compilation\n+\tunit. Expand the subprogram contract after the declarations have\n+\tbeen analyzed.\n+\t(Analyze_Subprogram_Contract): Reimplemented.\n+\t(Analyze_Subprogram_Specification): Do not create a contract node.\n+\t(List_Inherited_Pre_Post_Aspects): Code cleanup.\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Contract): Update the\n+\tcomment on usage.\n+\t(Analyze_Subprogram_Contract): Update the\n+\tparameter profile and the comment on usage.\n+\t* sem_ch7.adb (Analyze_Package_Body_Helper): Do not create a\n+\tcontract node.\n+\t(Analyze_Package_Declaration): Do not create a\n+\tcontract node.\n+\t(Is_Subp_Or_Const_Ref): Ensure that the prefix has an entity.\n+\t* sem_ch8.adb (Analyze_Subprogram_Renaming): Do not create a\n+\tcontract node.\n+\t* sem_ch9.adb (Analyze_Entry_Declaration): Do not create a\n+\tcontract node.\n+\t* sem_ch10.adb (Analyze_Compilation_Unit): Move local variables to\n+\ttheir proper section and alphabetize them. Analyze the contract of\n+\ta [generic] subprogram after all Pragmas_After have been analyzed.\n+\t(Analyze_Subprogram_Body_Stub_Contract): Alphabetize.\n+\t* sem_ch12.adb (Analyze_Generic_Package_Declaration): Do not\n+\tcreate a contract node.\n+\t(Analyze_Generic_Subprogram_Declaration):\n+\tAlphabetize local variables. Do not create a contract\n+\tnode. Do not generate aspects out of pragmas for ASIS.\n+\t(Analyze_Subprogram_Instantiation): Instantiate\n+\tthe contract of the subprogram.  Do not create a\n+\tcontract node.\t(Instantiate_Contract): New routine.\n+\t(Instantiate_Subprogram_Body): Alphabetize local variables.\n+\t(Save_Global_References_In_Aspects): New routine.\n+\t(Save_References): Do not save the global references found within\n+\tthe aspects of a generic subprogram.\n+\t* sem_ch12.ads (Save_Global_References_In_Aspects): New routine.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Do not use\n+\tOriginal_Node for establishing linkages.\n+\t(Insert_Pragma): Insertion in a subprogram body takes precedence over\n+\tthe case where the subprogram body is also a compilation unit.\n+\t* sem_prag.adb (Analyze_Contract_Cases_In_Decl_Part): Use\n+\tGet_Argument to obtain the proper expression. Install the generic\n+\tformals when the related context is a generic subprogram.\n+\t(Analyze_Depends_In_Decl_Part): Use Get_Argument to obtain\n+\tthe proper expression. Use Corresponding_Spec_Of to obtain\n+\tthe spec. Install the generic formal when the related context\n+\tis a generic subprogram.\n+\t(Analyze_Global_In_Decl_Part): Use Get_Argument to obtain the proper\n+\texpression. Use Corresponding_Spec_Of to obtain the spec. Install the\n+\tgeneric formal when the related context is a generic subprogram.\n+\t(Analyze_Initial_Condition_In_Decl_Part): Use Get_Argument\n+\tto obtain the proper expression. Remove the call to\n+\tCheck_SPARK_Aspect_For_ASIS as the analysis is now done\n+\tautomatically.\n+\t(Analyze_Pragma): Update all occurrences\n+\tto Original_Aspect_Name. Pragmas Contract_Cases, Depends,\n+\tExtensions_Visible, Global, Postcondition, Precondition and\n+\tTest_Case now carry generic templates when the related context\n+\tis a generic subprogram. The same pragmas are no longer\n+\tforcefully fully analyzed when the context is a subprogram\n+\tthat acts as a compilation unit. Pragmas Abstract_State,\n+\tInitial_Condition, Initializes and Refined_State have been clean\n+\tup. Pragmas Post, Post_Class, Postcondition, Pre, Pre_Class\n+\tand Precondition now use the same routine for analysis. Pragma\n+\tRefined_Post does not need to check the use of 'Result or\n+\tthe lack of a post-state in its expression. Reimplement the\n+\tanalysis of pragma Test_Case.\n+\t(Analyze_Pre_Post_Condition): New routine.\n+\t(Analyze_Pre_Post_Condition_In_Decl_Part):\n+\tReimplemented.\n+\t(Analyze_Refined_Depends_In_Decl_Part): Use Get_Argument to obtain the\n+\tproper expression.\n+\t(Analyze_Refined_Global_In_Decl_Part): Use Get_Argument to obtain\n+\tthe proper expression.\n+\t(Analyze_Test_Case_In_Decl_Part): Reimplemented.\n+\t(Check_Pre_Post): Removed.\n+\t(Check_Precondition_Postcondition): Removed.\n+\t(Check_SPARK_Aspect_For_ASIS): Removed.\n+\t(Check_Test_Case): Removed.\n+\t(Collect_Subprogram_Inputs_Outputs): Use Get_Argument\n+\tto obtain the proper expression. Use Corresponding_Spec_Of to\n+\tfind the proper spec.\n+\t(Create_Generic_Template): New routine.\n+\t(Duplication_Error): New routine.\n+\t(Expression_Function_Error): New routine.\n+\t(Find_Related_Subprogram_Or_Body): Moved to the spec\n+\tof Sem_Prag. Emit precise error messages. Account for cases of\n+\trewritten expression functions, generic instantiations, handled\n+\tsequence of statements and pragmas from aspects.\n+\t(Get_Argument): New routine.\n+\t(Make_Aspect_For_PPC_In_Gen_Sub_Decl): Removed.\n+\t(Preanalyze_CTC_Args): Removed.\n+\t(Process_Class_Wide_Condition): New routine.\n+\t* sem_prag.ads (Analyze_Test_Case_In_Decl_Part): Update\n+\tthe parameter profile along with the comment on usage.\n+\t(Find_Related_Subprogram_Or_Body): Moved from the body of Sem_Prag.\n+\t(Make_Aspect_For_PPC_In_Gen_Sub_Decl): Removed.\n+\t(Test_Case_Arg): New routine.\n+\t* sem_util.adb Add with and use clauses for Sem_Ch6.\n+\t(Add_Contract_Item): This routine now creates a contract\n+\tnode the first time an item is added. Remove the duplicate\n+\taspect/pragma checks.\n+\t(Check_Result_And_Post_State): Reimplemented.\n+\t(Corresponding_Spec_Of): New routine.\n+\t(Get_Ensures_From_CTC_Pragma): Removed.\n+\t(Get_Requires_From_CTC_Pragma): Removed.\n+\t(Has_Significant_Contract): New routine.\n+\t(Inherit_Subprogram_Contract): Inherit only if the source\n+\thas a contract.\n+\t(Install_Generic_Formals): New routine.\n+\t(Original_Aspect_Name): Removed.\n+\t(Original_Aspect_Pragma_Name): New routine.\n+\t* sem_util.ads (Check_Result_And_Post_State): Reimplemented.\n+\t(Corresponding_Spec_Of): New routine.\n+\t(Get_Ensures_From_CTC_Pragma): Removed.\n+\t(Get_Requires_From_CTC_Pragma): Removed.\n+\t(Has_Significant_Contract): New routine.\n+\t(Install_Generic_Formals): New routine.\n+\t(Original_Aspect_Name): Removed.\n+\t(Original_Aspect_Pragma_Name): New routine.\n+\t* sem_warn.adb Add with and use clauses for Sem_Prag.\n+\t(Within_Postcondition): Use Test_Case_Arg to extract \"Ensures\".\n+\n 2015-03-02  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch8.adb (Available_Subtype): Optimization in"}, {"sha": "a3cfe790e27ab0b33296957cff7d65b3a2773134", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -2417,31 +2417,95 @@ package body Checks is\n       Subp_Decl : Node_Id;\n \n       procedure Add_Validity_Check\n-        (Context    : Entity_Id;\n-         PPC_Nam    : Name_Id;\n+        (Formal     : Entity_Id;\n+         Prag_Nam   : Name_Id;\n          For_Result : Boolean := False);\n       --  Add a single 'Valid[_Scalar] check which verifies the initialization\n-      --  of Context. PPC_Nam denotes the pre or post condition pragma name.\n+      --  of Formal. Prag_Nam denotes the pre or post condition pragma name.\n       --  Set flag For_Result when to verify the result of a function.\n \n-      procedure Build_PPC_Pragma (PPC_Nam : Name_Id; Check : Node_Id);\n-      --  Create a pre or post condition pragma with name PPC_Nam which\n-      --  tests expression Check.\n-\n       ------------------------\n       -- Add_Validity_Check --\n       ------------------------\n \n       procedure Add_Validity_Check\n-        (Context    : Entity_Id;\n-         PPC_Nam    : Name_Id;\n+        (Formal     : Entity_Id;\n+         Prag_Nam   : Name_Id;\n          For_Result : Boolean := False)\n       is\n+         procedure Build_Pre_Post_Condition (Expr : Node_Id);\n+         --  Create a pre/postcondition pragma that tests expression Expr\n+\n+         ------------------------------\n+         -- Build_Pre_Post_Condition --\n+         ------------------------------\n+\n+         procedure Build_Pre_Post_Condition (Expr : Node_Id) is\n+            Loc   : constant Source_Ptr := Sloc (Subp);\n+            Decls : List_Id;\n+            Prag  : Node_Id;\n+\n+         begin\n+            Prag :=\n+              Make_Pragma (Loc,\n+                Pragma_Identifier            =>\n+                  Make_Identifier (Loc, Prag_Nam),\n+                Pragma_Argument_Associations => New_List (\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Chars      => Name_Check,\n+                    Expression => Expr)));\n+\n+            --  Add a message unless exception messages are suppressed\n+\n+            if not Exception_Locations_Suppressed then\n+               Append_To (Pragma_Argument_Associations (Prag),\n+                 Make_Pragma_Argument_Association (Loc,\n+                   Chars      => Name_Message,\n+                   Expression =>\n+                     Make_String_Literal (Loc,\n+                       Strval => \"failed \"\n+                                 & Get_Name_String (Prag_Nam)\n+                                 & \" from \"\n+                                 & Build_Location_String (Loc))));\n+            end if;\n+\n+            --  Insert the pragma in the tree\n+\n+            if Nkind (Parent (Subp_Decl)) = N_Compilation_Unit then\n+               Add_Global_Declaration (Prag);\n+               Analyze (Prag);\n+\n+            --  PPC pragmas associated with subprogram bodies must be inserted\n+            --  in the declarative part of the body.\n+\n+            elsif Nkind (Subp_Decl) = N_Subprogram_Body then\n+               Decls := Declarations (Subp_Decl);\n+\n+               if No (Decls) then\n+                  Decls := New_List;\n+                  Set_Declarations (Subp_Decl, Decls);\n+               end if;\n+\n+               Prepend_To (Decls, Prag);\n+               Analyze (Prag);\n+\n+            --  For subprogram declarations insert the PPC pragma right after\n+            --  the declarative node.\n+\n+            else\n+               Insert_After_And_Analyze (Subp_Decl, Prag);\n+            end if;\n+         end Build_Pre_Post_Condition;\n+\n+         --  Local variables\n+\n          Loc   : constant Source_Ptr := Sloc (Subp);\n-         Typ   : constant Entity_Id  := Etype (Context);\n+         Typ   : constant Entity_Id  := Etype (Formal);\n          Check : Node_Id;\n          Nam   : Name_Id;\n \n+      --  Start of processing for Add_Validity_Check\n+\n       begin\n          --  For scalars, generate 'Valid test\n \n@@ -2462,7 +2526,7 @@ package body Checks is\n          --  Step 1: Create the expression to verify the validity of the\n          --  context.\n \n-         Check := New_Occurrence_Of (Context, Loc);\n+         Check := New_Occurrence_Of (Formal, Loc);\n \n          --  When processing a function result, use 'Result. Generate\n          --    Context'Result\n@@ -2484,73 +2548,9 @@ package body Checks is\n \n          --  Step 2: Create a pre or post condition pragma\n \n-         Build_PPC_Pragma (PPC_Nam, Check);\n+         Build_Pre_Post_Condition (Check);\n       end Add_Validity_Check;\n \n-      ----------------------\n-      -- Build_PPC_Pragma --\n-      ----------------------\n-\n-      procedure Build_PPC_Pragma (PPC_Nam : Name_Id; Check : Node_Id) is\n-         Loc   : constant Source_Ptr := Sloc (Subp);\n-         Decls : List_Id;\n-         Prag  : Node_Id;\n-\n-      begin\n-         Prag :=\n-           Make_Pragma (Loc,\n-             Pragma_Identifier            => Make_Identifier (Loc, PPC_Nam),\n-             Pragma_Argument_Associations => New_List (\n-               Make_Pragma_Argument_Association (Loc,\n-                 Chars      => Name_Check,\n-                 Expression => Check)));\n-\n-         --  Add a message unless exception messages are suppressed\n-\n-         if not Exception_Locations_Suppressed then\n-            Append_To (Pragma_Argument_Associations (Prag),\n-              Make_Pragma_Argument_Association (Loc,\n-                Chars      => Name_Message,\n-                Expression =>\n-                  Make_String_Literal (Loc,\n-                    Strval => \"failed \" & Get_Name_String (PPC_Nam) &\n-                               \" from \" & Build_Location_String (Loc))));\n-         end if;\n-\n-         --  Insert the pragma in the tree\n-\n-         if Nkind (Parent (Subp_Decl)) = N_Compilation_Unit then\n-            Add_Global_Declaration (Prag);\n-            Analyze (Prag);\n-\n-         --  PPC pragmas associated with subprogram bodies must be inserted in\n-         --  the declarative part of the body.\n-\n-         elsif Nkind (Subp_Decl) = N_Subprogram_Body then\n-            Decls := Declarations (Subp_Decl);\n-\n-            if No (Decls) then\n-               Decls := New_List;\n-               Set_Declarations (Subp_Decl, Decls);\n-            end if;\n-\n-            Prepend_To (Decls, Prag);\n-\n-            --  Ensure the proper visibility of the subprogram body and its\n-            --  parameters.\n-\n-            Push_Scope (Subp);\n-            Analyze (Prag);\n-            Pop_Scope;\n-\n-         --  For subprogram declarations insert the PPC pragma right after the\n-         --  declarative node.\n-\n-         else\n-            Insert_After_And_Analyze (Subp_Decl, Prag);\n-         end if;\n-      end Build_PPC_Pragma;\n-\n       --  Local variables\n \n       Formal    : Entity_Id;"}, {"sha": "fd6ae3765913f3dfa0d812040f840575939fa262", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 66, "deletions": 32, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -79,7 +79,6 @@ package body Einfo is\n    --    Hiding_Loop_Variable            Node8\n    --    Mechanism                       Uint8 (but returns Mechanism_Type)\n    --    Normalized_First_Bit            Uint8\n-   --    Postcondition_Proc              Node8\n    --    Refinement_Constituents         Elist8\n    --    Return_Applies_To               Node8\n    --    First_Exit_Statement            Node8\n@@ -116,6 +115,7 @@ package body Einfo is\n \n    --    Alignment                       Uint14\n    --    Normalized_Position             Uint14\n+   --    Postconditions_Proc             Node14\n    --    Shadow_Entities                 List14\n \n    --    Discriminant_Number             Uint15\n@@ -532,7 +532,7 @@ package body Einfo is\n    --    Warnings_Off_Used_Unmodified    Flag237\n    --    Warnings_Off_Used_Unreferenced  Flag238\n    --    OK_To_Reorder_Components        Flag239\n-   --    Has_Postconditions              Flag240\n+   --    Has_Expanded_Contract           Flag240\n \n    --    Optimize_Alignment_Space        Flag241\n    --    Optimize_Alignment_Time         Flag242\n@@ -1456,6 +1456,12 @@ package body Einfo is\n       return Flag47 (Id);\n    end Has_Exit;\n \n+   function Has_Expanded_Contract (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Subprogram (Id));\n+      return Flag240 (Id);\n+   end Has_Expanded_Contract;\n+\n    function Has_Forward_Instantiation (Id : E) return B is\n    begin\n       return Flag175 (Id);\n@@ -1560,12 +1566,6 @@ package body Einfo is\n       return Flag154 (Id);\n    end Has_Per_Object_Constraint;\n \n-   function Has_Postconditions (Id : E) return B is\n-   begin\n-      pragma Assert (Is_Subprogram (Id));\n-      return Flag240 (Id);\n-   end Has_Postconditions;\n-\n    function Has_Pragma_Controlled (Id : E) return B is\n    begin\n       pragma Assert (Is_Access_Type (Id));\n@@ -2750,11 +2750,14 @@ package body Einfo is\n       return Elist15 (Id);\n    end Pending_Access_Types;\n \n-   function Postcondition_Proc (Id : E) return E is\n+   function Postconditions_Proc (Id : E) return E is\n    begin\n-      pragma Assert (Ekind (Id) = E_Procedure);\n-      return Node8 (Id);\n-   end Postcondition_Proc;\n+      pragma Assert (Ekind_In (Id, E_Entry,\n+                                   E_Entry_Family,\n+                                   E_Function,\n+                                   E_Procedure));\n+      return Node14 (Id);\n+   end Postconditions_Proc;\n \n    function PPC_Wrapper (Id : E) return E is\n    begin\n@@ -4276,6 +4279,15 @@ package body Einfo is\n       Set_Flag47 (Id, V);\n    end Set_Has_Exit;\n \n+   procedure Set_Has_Expanded_Contract (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Ekind_In (Id, E_Entry,\n+                                   E_Entry_Family,\n+                                   E_Function,\n+                                   E_Procedure));\n+      Set_Flag240 (Id, V);\n+   end Set_Has_Expanded_Contract;\n+\n    procedure Set_Has_Forward_Instantiation (Id : E; V : B := True) is\n    begin\n       Set_Flag175 (Id, V);\n@@ -4388,12 +4400,6 @@ package body Einfo is\n       Set_Flag154 (Id, V);\n    end Set_Has_Per_Object_Constraint;\n \n-   procedure Set_Has_Postconditions (Id : E; V : B := True) is\n-   begin\n-      pragma Assert (Is_Subprogram (Id));\n-      Set_Flag240 (Id, V);\n-   end Set_Has_Postconditions;\n-\n    procedure Set_Has_Pragma_Controlled (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Access_Type (Id));\n@@ -5649,11 +5655,14 @@ package body Einfo is\n       Set_Elist15 (Id, V);\n    end Set_Pending_Access_Types;\n \n-   procedure Set_Postcondition_Proc (Id : E; V : E) is\n+   procedure Set_Postconditions_Proc (Id : E; V : E) is\n    begin\n-      pragma Assert (Ekind (Id) = E_Procedure);\n-      Set_Node8 (Id, V);\n-   end Set_Postcondition_Proc;\n+      pragma Assert (Ekind_In (Id, E_Entry,\n+                                   E_Entry_Family,\n+                                   E_Function,\n+                                   E_Procedure));\n+      Set_Node14 (Id, V);\n+   end Set_Postconditions_Proc;\n \n    procedure Set_PPC_Wrapper (Id : E; V : E) is\n    begin\n@@ -6685,7 +6694,8 @@ package body Einfo is\n \n    begin\n       pragma Assert\n-        (Is_Overloadable (Id)\n+        (Is_Generic_Subprogram (Id)\n+           or else Is_Overloadable (Id)\n            or else Ekind_In (Id, E_Entry_Family,\n                                  E_Subprogram_Body,\n                                  E_Subprogram_Type));\n@@ -6696,6 +6706,16 @@ package body Einfo is\n       else\n          Formal := First_Entity (Id);\n \n+         --  The first/next entity chain of a generic subprogram contains all\n+         --  generic formal parameters, followed by the formal parameters. Go\n+         --  directly to the paramters by skipping the formal part.\n+\n+         if Is_Generic_Subprogram (Id) then\n+            while Present (Formal) and then not Is_Formal (Formal) loop\n+               Next_Entity (Formal);\n+            end loop;\n+         end if;\n+\n          if Present (Formal) and then Is_Formal (Formal) then\n             return Formal;\n          else\n@@ -6713,7 +6733,8 @@ package body Einfo is\n \n    begin\n       pragma Assert\n-        (Is_Overloadable (Id)\n+        (Is_Generic_Subprogram (Id)\n+           or else Is_Overloadable (Id)\n            or else Ekind_In (Id, E_Entry_Family,\n                                  E_Subprogram_Body,\n                                  E_Subprogram_Type));\n@@ -6724,6 +6745,16 @@ package body Einfo is\n       else\n          Formal := First_Entity (Id);\n \n+         --  The first/next entity chain of a generic subprogram contains all\n+         --  generic formal parameters, followed by the formal parameters. Go\n+         --  directly to the paramters by skipping the formal part.\n+\n+         if Is_Generic_Subprogram (Id) then\n+            while Present (Formal) and then not Is_Formal (Formal) loop\n+               Next_Entity (Formal);\n+            end loop;\n+         end if;\n+\n          if Present (Formal) and then Is_Formal (Formal) then\n             return Formal;\n          else\n@@ -8470,6 +8501,7 @@ package body Einfo is\n       W (\"Has_Dynamic_Predicate_Aspect\",    Flag258 (Id));\n       W (\"Has_Enumeration_Rep_Clause\",      Flag66  (Id));\n       W (\"Has_Exit\",                        Flag47  (Id));\n+      W (\"Has_Expanded_Contract\",           Flag240 (Id));\n       W (\"Has_Forward_Instantiation\",       Flag175 (Id));\n       W (\"Has_Fully_Qualified_Name\",        Flag173 (Id));\n       W (\"Has_Gigi_Rep_Item\",               Flag82  (Id));\n@@ -8489,7 +8521,6 @@ package body Einfo is\n       W (\"Has_Out_Or_In_Out_Parameter\",     Flag110 (Id));\n       W (\"Has_Object_Size_Clause\",          Flag172 (Id));\n       W (\"Has_Per_Object_Constraint\",       Flag154 (Id));\n-      W (\"Has_Postconditions\",              Flag240 (Id));\n       W (\"Has_Pragma_Controlled\",           Flag27  (Id));\n       W (\"Has_Pragma_Elaborate_Body\",       Flag150 (Id));\n       W (\"Has_Pragma_Inline\",               Flag157 (Id));\n@@ -8882,9 +8913,6 @@ package body Einfo is\n               E_Discriminant                               =>\n             Write_Str (\"Normalized_First_Bit\");\n \n-         when E_Procedure                                  =>\n-            Write_Str (\"Postcondition_Proc\");\n-\n          when E_Abstract_State                             =>\n             Write_Str (\"Refinement_Constituents\");\n \n@@ -9083,16 +9111,22 @@ package body Einfo is\n               Formal_Kind                                  |\n               E_Constant                                   |\n               E_Exception                                  |\n-              E_Variable                                   |\n-              E_Loop_Parameter                             =>\n+              E_Loop_Parameter                             |\n+              E_Variable                                   =>\n             Write_Str (\"Alignment\");\n \n          when E_Component                                  |\n               E_Discriminant                               =>\n             Write_Str (\"Normalized_Position\");\n \n-         when E_Package                                    |\n-              E_Generic_Package                            =>\n+         when E_Entry                                      |\n+              E_Entry_Family                               |\n+              E_Function                                   |\n+              E_Procedure                                  =>\n+            Write_Str (\"Postconditions_Proc\");\n+\n+         when E_Generic_Package                            |\n+              E_Package                                    =>\n             Write_Str (\"Shadow_Entities\");\n \n          when others                                       =>"}, {"sha": "129e0d0fade5406be215fa6ad86ba1ed2bc9a6cd", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -1565,6 +1565,12 @@ package Einfo is\n --    Has_Exit (Flag47)\n --       Defined in loop entities. Set if the loop contains an exit statement.\n \n+--    Has_Expanded_Contract (Flag240)\n+--       Defined in functions, procedures, entries, and entry families. Set\n+--       when a subprogram has a N_Contract node that has been expanded. The\n+--       flag prevents double expansion of a contract when a construct is\n+--       rewritten into something else and subsequently reanalyzed/expanded.\n+\n --    Has_Foreign_Convention (synthesized)\n --       Applies to all entities. Determines if the Convention for the\n --       entity is a foreign convention (i.e. is other than Convention_Ada,\n@@ -1734,10 +1740,6 @@ package Einfo is\n --       5. N_Range_Constraint - when the range expression uses the\n --          discriminant of the enclosing type.\n \n---    Has_Postconditions (Flag240)\n---      Defined in subprogram entities. Set if postconditions are active for\n---      the procedure, and a _postconditions procedure has been generated.\n-\n --    Has_Pragma_Controlled (Flag27) [implementation base type only]\n --       Defined in access type entities. It is set if a pragma Controlled\n --       applies to the access type.\n@@ -3591,11 +3593,10 @@ package Einfo is\n --       ensure that the finalization masters of all pending access types are\n --       fully initialized when the full view is frozen.\n \n---    Postcondition_Proc (Node8)\n---       Defined only in procedure entities, saves the entity of the generated\n---       postcondition proc if one is present, otherwise is set to Empty. Used\n---       to generate the call to this procedure in case the expander inserts\n---       implicit return statements.\n+--    Postconditions_Proc (Node14)\n+--       Defined in functions, procedures, entries, and entry families. Refers\n+--       to the entity of the _Postconditions procedure used to check contract\n+--       assertions on exit from a subprogram.\n \n --    PPC_Wrapper (Node25)\n --       Defined in entries and entry families. Set only if pre- or post-\n@@ -5611,6 +5612,7 @@ package Einfo is\n    --  E_Entry_Family\n    --    Protected_Body_Subprogram           (Node11)\n    --    Barrier_Function                    (Node12)\n+   --    Postconditions_Proc                 (Node14)\n    --    Entry_Parameters_Type               (Node15)\n    --    First_Entity                        (Node17)\n    --    Alias                               (Node18)   (for entry only. Empty)\n@@ -5621,11 +5623,12 @@ package Einfo is\n    --    PPC_Wrapper                         (Node25)\n    --    Extra_Formals                       (Node28)\n    --    Contract                            (Node34)\n+   --    Needs_No_Actuals                    (Flag22)\n+   --    Uses_Sec_Stack                      (Flag95)\n    --    Default_Expressions_Processed       (Flag108)\n    --    Entry_Accepted                      (Flag152)\n-   --    Needs_No_Actuals                    (Flag22)\n    --    Sec_Stack_Needed_For_Return         (Flag167)\n-   --    Uses_Sec_Stack                      (Flag95)\n+   --    Has_Expanded_Contract               (Flag240)\n    --    Address_Clause                      (synth)\n    --    Entry_Index_Type                    (synth)\n    --    First_Formal                        (synth)\n@@ -5707,6 +5710,7 @@ package Einfo is\n    --    Protected_Body_Subprogram           (Node11)\n    --    Next_Inlined_Subprogram             (Node12)\n    --    Elaboration_Entity                  (Node13)   (not implicit /=)\n+   --    Postconditions_Proc                 (Node14)   (non-generic case only)\n    --    DT_Position                         (Uint15)\n    --    DTC_Entity                          (Node16)\n    --    First_Entity                        (Node17)\n@@ -5739,12 +5743,12 @@ package Einfo is\n    --    Has_Anonymous_Master                (Flag253)\n    --    Has_Completion                      (Flag26)\n    --    Has_Controlling_Result              (Flag98)\n+   --    Has_Expanded_Contract               (Flag240)  (non-generic case only)\n    --    Has_Invariants                      (Flag232)\n    --    Has_Master_Entity                   (Flag21)\n    --    Has_Missing_Return                  (Flag142)\n    --    Has_Nested_Block_With_Handler       (Flag101)\n    --    Has_Out_Or_In_Out_Parameter         (Flag110)\n-   --    Has_Postconditions                  (Flag240)\n    --    Has_Recursive_Call                  (Flag143)\n    --    Is_Abstract_Subprogram              (Flag19)   (non-generic case only)\n    --    Is_Called                           (Flag102)  (non-generic case only)\n@@ -5892,7 +5896,6 @@ package Einfo is\n    --    Linker_Section_Pragma               (Node33)\n    --    Contract                            (Node34)\n    --    Has_Invariants                      (Flag232)\n-   --    Has_Postconditions                  (Flag240)\n    --    Is_Machine_Code_Subprogram          (Flag137)\n    --    Is_Pure                             (Flag44)\n    --    Is_Intrinsic_Subprogram             (Flag64)\n@@ -6002,12 +6005,12 @@ package Einfo is\n \n    --  E_Procedure\n    --  E_Generic_Procedure\n-   --    Postcondition_Proc                  (Node8)    (non-generic case only)\n    --    Renaming_Map                        (Uint9)\n    --    Handler_Records                     (List10)   (non-generic case only)\n    --    Protected_Body_Subprogram           (Node11)\n    --    Next_Inlined_Subprogram             (Node12)\n    --    Elaboration_Entity                  (Node13)\n+   --    Postconditions_Proc                 (Node14)   (non-generic case only)\n    --    DT_Position                         (Uint15)\n    --    DTC_Entity                          (Node16)\n    --    First_Entity                        (Node17)\n@@ -6039,10 +6042,10 @@ package Einfo is\n    --    Discard_Names                       (Flag88)\n    --    Has_Anonymous_Master                (Flag253)\n    --    Has_Completion                      (Flag26)\n+   --    Has_Expanded_Contract               (Flag240)  (non-generic case only)\n    --    Has_Invariants                      (Flag232)\n    --    Has_Master_Entity                   (Flag21)\n    --    Has_Nested_Block_With_Handler       (Flag101)\n-   --    Has_Postconditions                  (Flag240)\n    --    Is_Abstract_Subprogram              (Flag19)   (non-generic case only)\n    --    Is_Asynchronous                     (Flag81)\n    --    Is_Called                           (Flag102)  (non-generic case only)\n@@ -6656,6 +6659,7 @@ package Einfo is\n    function Has_Dynamic_Predicate_Aspect        (Id : E) return B;\n    function Has_Enumeration_Rep_Clause          (Id : E) return B;\n    function Has_Exit                            (Id : E) return B;\n+   function Has_Expanded_Contract               (Id : E) return B;\n    function Has_Forward_Instantiation           (Id : E) return B;\n    function Has_Fully_Qualified_Name            (Id : E) return B;\n    function Has_Gigi_Rep_Item                   (Id : E) return B;\n@@ -6676,7 +6680,6 @@ package Einfo is\n    function Has_Object_Size_Clause              (Id : E) return B;\n    function Has_Out_Or_In_Out_Parameter         (Id : E) return B;\n    function Has_Per_Object_Constraint           (Id : E) return B;\n-   function Has_Postconditions                  (Id : E) return B;\n    function Has_Pragma_Controlled               (Id : E) return B;\n    function Has_Pragma_Elaborate_Body           (Id : E) return B;\n    function Has_Pragma_Inline                   (Id : E) return B;\n@@ -6885,7 +6888,7 @@ package Einfo is\n    function Part_Of_Constituents                (Id : E) return L;\n    function Partial_View_Has_Unknown_Discr      (Id : E) return B;\n    function Pending_Access_Types                (Id : E) return L;\n-   function Postcondition_Proc                  (Id : E) return E;\n+   function Postconditions_Proc                 (Id : E) return E;\n    function Prival                              (Id : E) return E;\n    function Prival_Link                         (Id : E) return E;\n    function Private_Dependents                  (Id : E) return L;\n@@ -7299,6 +7302,7 @@ package Einfo is\n    procedure Set_Has_Dynamic_Predicate_Aspect    (Id : E; V : B := True);\n    procedure Set_Has_Enumeration_Rep_Clause      (Id : E; V : B := True);\n    procedure Set_Has_Exit                        (Id : E; V : B := True);\n+   procedure Set_Has_Expanded_Contract           (Id : E; V : B := True);\n    procedure Set_Has_Forward_Instantiation       (Id : E; V : B := True);\n    procedure Set_Has_Fully_Qualified_Name        (Id : E; V : B := True);\n    procedure Set_Has_Gigi_Rep_Item               (Id : E; V : B := True);\n@@ -7318,7 +7322,6 @@ package Einfo is\n    procedure Set_Has_Object_Size_Clause          (Id : E; V : B := True);\n    procedure Set_Has_Out_Or_In_Out_Parameter     (Id : E; V : B := True);\n    procedure Set_Has_Per_Object_Constraint       (Id : E; V : B := True);\n-   procedure Set_Has_Postconditions              (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Controlled           (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Elaborate_Body       (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Inline               (Id : E; V : B := True);\n@@ -7533,7 +7536,7 @@ package Einfo is\n    procedure Set_Part_Of_Constituents            (Id : E; V : L);\n    procedure Set_Partial_View_Has_Unknown_Discr  (Id : E; V : B := True);\n    procedure Set_Pending_Access_Types            (Id : E; V : L);\n-   procedure Set_Postcondition_Proc              (Id : E; V : E);\n+   procedure Set_Postconditions_Proc             (Id : E; V : E);\n    procedure Set_Prival                          (Id : E; V : E);\n    procedure Set_Prival_Link                     (Id : E; V : E);\n    procedure Set_Private_Dependents              (Id : E; V : L);\n@@ -8057,6 +8060,7 @@ package Einfo is\n    pragma Inline (Has_Dynamic_Predicate_Aspect);\n    pragma Inline (Has_Enumeration_Rep_Clause);\n    pragma Inline (Has_Exit);\n+   pragma Inline (Has_Expanded_Contract);\n    pragma Inline (Has_Forward_Instantiation);\n    pragma Inline (Has_Fully_Qualified_Name);\n    pragma Inline (Has_Gigi_Rep_Item);\n@@ -8076,7 +8080,6 @@ package Einfo is\n    pragma Inline (Has_Object_Size_Clause);\n    pragma Inline (Has_Out_Or_In_Out_Parameter);\n    pragma Inline (Has_Per_Object_Constraint);\n-   pragma Inline (Has_Postconditions);\n    pragma Inline (Has_Pragma_Controlled);\n    pragma Inline (Has_Pragma_Elaborate_Body);\n    pragma Inline (Has_Pragma_Inline);\n@@ -8333,7 +8336,7 @@ package Einfo is\n    pragma Inline (Part_Of_Constituents);\n    pragma Inline (Partial_View_Has_Unknown_Discr);\n    pragma Inline (Pending_Access_Types);\n-   pragma Inline (Postcondition_Proc);\n+   pragma Inline (Postconditions_Proc);\n    pragma Inline (Prival);\n    pragma Inline (Prival_Link);\n    pragma Inline (Private_Dependents);\n@@ -8547,6 +8550,7 @@ package Einfo is\n    pragma Inline (Set_Has_Dynamic_Predicate_Aspect);\n    pragma Inline (Set_Has_Enumeration_Rep_Clause);\n    pragma Inline (Set_Has_Exit);\n+   pragma Inline (Set_Has_Expanded_Contract);\n    pragma Inline (Set_Has_Forward_Instantiation);\n    pragma Inline (Set_Has_Fully_Qualified_Name);\n    pragma Inline (Set_Has_Gigi_Rep_Item);\n@@ -8566,7 +8570,6 @@ package Einfo is\n    pragma Inline (Set_Has_Object_Size_Clause);\n    pragma Inline (Set_Has_Out_Or_In_Out_Parameter);\n    pragma Inline (Set_Has_Per_Object_Constraint);\n-   pragma Inline (Set_Has_Postconditions);\n    pragma Inline (Set_Has_Pragma_Controlled);\n    pragma Inline (Set_Has_Pragma_Elaborate_Body);\n    pragma Inline (Set_Has_Pragma_Inline);\n@@ -8780,7 +8783,7 @@ package Einfo is\n    pragma Inline (Set_Part_Of_Constituents);\n    pragma Inline (Set_Partial_View_Has_Unknown_Discr);\n    pragma Inline (Set_Pending_Access_Types);\n-   pragma Inline (Set_Postcondition_Proc);\n+   pragma Inline (Set_Postconditions_Proc);\n    pragma Inline (Set_Prival);\n    pragma Inline (Set_Prival_Link);\n    pragma Inline (Set_Private_Dependents);"}, {"sha": "a19b2e19fe636e9287f89d2775be5aed100857ef", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -3630,18 +3630,15 @@ package body Exp_Attr is\n \n                declare\n                   Rtyp : constant Entity_Id := Root_Type (P_Type);\n-                  Dnn  : Entity_Id;\n-                  Decl : Node_Id;\n                   Expr : Node_Id;\n \n                begin\n                   --  Read the internal tag (RM 13.13.2(34)) and use it to\n-                  --  initialize a dummy tag object:\n+                  --  initialize a dummy tag value:\n \n-                  --    Dnn : Ada.Tags.Tag :=\n-                  --            Descendant_Tag (String'Input (Strm), P_Type);\n+                  --     Descendant_Tag (String'Input (Strm), P_Type);\n \n-                  --  This dummy object is used only to provide a controlling\n+                  --  This value is used only to provide a controlling\n                   --  argument for the eventual _Input call. Descendant_Tag is\n                   --  called rather than Internal_Tag to ensure that we have a\n                   --  tag for a type that is descended from the prefix type and\n@@ -3650,6 +3647,11 @@ package body Exp_Attr is\n                   --  required for Ada 2005 because tagged types can be\n                   --  extended in nested scopes (AI-344).\n \n+                  --  Note: we used to generate an explicit declaration of a\n+                  --  constant Ada.Tags.Tag object, and use an occurrence of\n+                  --  this constant in Cntrl, but this caused a secondary stack\n+                  --  leak.\n+\n                   Expr :=\n                     Make_Function_Call (Loc,\n                       Name =>\n@@ -3663,17 +3665,7 @@ package body Exp_Attr is\n                         Make_Attribute_Reference (Loc,\n                           Prefix => New_Occurrence_Of (P_Type, Loc),\n                           Attribute_Name => Name_Tag)));\n-\n-                  Dnn := Make_Temporary (Loc, 'D', Expr);\n-\n-                  Decl :=\n-                    Make_Object_Declaration (Loc,\n-                      Defining_Identifier => Dnn,\n-                      Object_Definition   =>\n-                        New_Occurrence_Of (RTE (RE_Tag), Loc),\n-                      Expression          => Expr);\n-\n-                  Insert_Action (N, Decl);\n+                  Set_Etype (Expr, RTE (RE_Tag));\n \n                   --  Now we need to get the entity for the call, and construct\n                   --  a function call node, where we preset a reference to Dnn\n@@ -3682,9 +3674,7 @@ package body Exp_Attr is\n                   --  tagged object).\n \n                   Fname := Find_Prim_Op (Rtyp, TSS_Stream_Input);\n-                  Cntrl :=\n-                    Unchecked_Convert_To (P_Type,\n-                      New_Occurrence_Of (Dnn, Loc));\n+                  Cntrl := Unchecked_Convert_To (P_Type, Expr);\n                   Set_Etype (Cntrl, P_Type);\n                   Set_Parent (Cntrl, N);\n                end;"}, {"sha": "01130cb186a28566669cfbcdab0e78e521ae9c30", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 498, "deletions": 441, "changes": 939, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -202,10 +202,9 @@ package body Exp_Ch6 is\n    --  secondary stack using 'reference.\n \n    procedure Expand_Non_Function_Return (N : Node_Id);\n-   --  Called by Expand_N_Simple_Return_Statement in case we're returning from\n-   --  a procedure body, entry body, accept statement, or extended return\n-   --  statement. Note that all non-function returns are simple return\n-   --  statements.\n+   --  Expand a simple return statement found in a procedure body, entry body,\n+   --  accept statement, or an extended return statement. Note that all non-\n+   --  function returns are simple return statements.\n \n    function Expand_Protected_Object_Reference\n      (N    : Node_Id;\n@@ -4983,21 +4982,22 @@ package body Exp_Ch6 is\n       ----------------\n \n       procedure Add_Return (S : List_Id) is\n-         Last_Stm : Node_Id;\n-         Loc      : Source_Ptr;\n+         Last_Stmt : Node_Id;\n+         Loc       : Source_Ptr;\n+         Stmt      : Node_Id;\n \n       begin\n          --  Get last statement, ignoring any Pop_xxx_Label nodes, which are\n          --  not relevant in this context since they are not executable.\n \n-         Last_Stm := Last (S);\n-         while Nkind (Last_Stm) in N_Pop_xxx_Label loop\n-            Prev (Last_Stm);\n+         Last_Stmt := Last (S);\n+         while Nkind (Last_Stmt) in N_Pop_xxx_Label loop\n+            Prev (Last_Stmt);\n          end loop;\n \n          --  Now insert return unless last statement is a transfer\n \n-         if not Is_Transfer (Last_Stm) then\n+         if not Is_Transfer (Last_Stmt) then\n \n             --  The source location for the return is the end label of the\n             --  procedure if present. Otherwise use the sloc of the last\n@@ -5009,49 +5009,43 @@ package body Exp_Ch6 is\n             if Nkind (Parent (S)) = N_Exception_Handler\n               and then not Comes_From_Source (Parent (S))\n             then\n-               Loc := Sloc (Last_Stm);\n+               Loc := Sloc (Last_Stmt);\n             elsif Present (End_Label (H)) then\n                Loc := Sloc (End_Label (H));\n             else\n-               Loc := Sloc (Last_Stm);\n+               Loc := Sloc (Last_Stmt);\n             end if;\n \n-            declare\n-               Rtn : constant Node_Id := Make_Simple_Return_Statement (Loc);\n+            --  Append return statement, and set analyzed manually. We can't\n+            --  call Analyze on this return since the scope is wrong.\n \n-            begin\n-               --  Append return statement, and set analyzed manually. We can't\n-               --  call Analyze on this return since the scope is wrong.\n+            --  Note: it almost works to push the scope and then do the Analyze\n+            --  call, but something goes wrong in some weird cases and it is\n+            --  not worth worrying about ???\n \n-               --  Note: it almost works to push the scope and then do the\n-               --  Analyze call, but something goes wrong in some weird cases\n-               --  and it is not worth worrying about ???\n+            Stmt := Make_Simple_Return_Statement (Loc);\n \n-               --  The return statement is handled properly, and the call\n-               --  to the postcondition, inserted below, does not require\n-               --  information from the body either. However, that call is\n-               --  analyzed in the enclosing scope, and an elaboration check\n-               --  might improperly be added to it. A guard in Sem_Elab is\n-               --  needed to prevent that spurious check, see Check_Elab_Call.\n+            --  The return statement is handled properly, and the call to the\n+            --  postcondition, inserted below, does not require information\n+            --  from the body either. However, that call is analyzed in the\n+            --  enclosing scope, and an elaboration check might improperly be\n+            --  added to it. A guard in Sem_Elab is needed to prevent that\n+            --  spurious check, see Check_Elab_Call.\n \n-               Append_To (S, Rtn);\n-               Set_Analyzed (Rtn);\n+            Append_To (S, Stmt);\n+            Set_Analyzed (Stmt);\n \n-               --  Call _Postconditions procedure if appropriate. We need to\n-               --  do this explicitly because we did not analyze the generated\n-               --  return statement above, so the call did not get inserted.\n+            --  Call the _Postconditions procedure if the related subprogram\n+            --  has contract assertions that need to be verified on exit.\n \n-               if Ekind (Spec_Id) = E_Procedure\n-                 and then Has_Postconditions (Spec_Id)\n-               then\n-                  pragma Assert (Present (Postcondition_Proc (Spec_Id)));\n-                  Insert_Action (Rtn,\n-                    Make_Procedure_Call_Statement (Loc,\n-                      Name =>\n-                        New_Occurrence_Of\n-                          (Postcondition_Proc (Spec_Id), Loc)));\n-               end if;\n-            end;\n+            if Ekind (Spec_Id) = E_Procedure\n+              and then Present (Postconditions_Proc (Spec_Id))\n+            then\n+               Insert_Action (Stmt,\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name =>\n+                     New_Occurrence_Of (Postconditions_Proc (Spec_Id), Loc)));\n+            end if;\n          end if;\n       end Add_Return;\n \n@@ -5206,7 +5200,8 @@ package body Exp_Ch6 is\n                   --  the initial value itself (which may well be invalid).\n                   --  Predicate checks are disabled as well (RM 6.4.1 (13/3))\n \n-                  A :=  Make_Assignment_Statement (Loc,\n+                  A :=\n+                    Make_Assignment_Statement (Loc,\n                       Name       => New_Occurrence_Of (F, Loc),\n                       Expression => Get_Simple_Init_Val (Etype (F), N));\n                   Set_Suppress_Assignment_Checks (A);\n@@ -5487,31 +5482,24 @@ package body Exp_Ch6 is\n    procedure Expand_Non_Function_Return (N : Node_Id) is\n       pragma Assert (No (Expression (N)));\n \n-      Loc         : constant Source_Ptr := Sloc (N);\n-      Scope_Id    : Entity_Id :=\n-                      Return_Applies_To (Return_Statement_Entity (N));\n-      Kind        : constant Entity_Kind := Ekind (Scope_Id);\n-      Call        : Node_Id;\n-      Acc_Stat    : Node_Id;\n-      Goto_Stat   : Node_Id;\n-      Lab_Node    : Node_Id;\n+      Loc       : constant Source_Ptr := Sloc (N);\n+      Scope_Id  : Entity_Id := Return_Applies_To (Return_Statement_Entity (N));\n+      Kind      : constant Entity_Kind := Ekind (Scope_Id);\n+      Call      : Node_Id;\n+      Acc_Stat  : Node_Id;\n+      Goto_Stat : Node_Id;\n+      Lab_Node  : Node_Id;\n \n    begin\n-      --  Call _Postconditions procedure if procedure with active\n-      --  postconditions. Here, we use the Postcondition_Proc attribute,\n-      --  which is needed for implicitly-generated returns. Functions\n-      --  never have implicitly-generated returns, and there's no\n-      --  room for Postcondition_Proc in E_Function, so we look up the\n-      --  identifier Name_uPostconditions for function returns (see\n-      --  Expand_Simple_Function_Return).\n-\n-      if Ekind (Scope_Id) = E_Procedure\n-        and then Has_Postconditions (Scope_Id)\n+      --  Call the _Postconditions procedure if the related subprogram has\n+      --  contract assertions that need to be verified on exit.\n+\n+      if Ekind_In (Scope_Id, E_Entry, E_Entry_Family, E_Procedure)\n+        and then Present (Postconditions_Proc (Scope_Id))\n       then\n-         pragma Assert (Present (Postcondition_Proc (Scope_Id)));\n          Insert_Action (N,\n            Make_Procedure_Call_Statement (Loc,\n-             Name => New_Occurrence_Of (Postcondition_Proc (Scope_Id), Loc)));\n+             Name => New_Occurrence_Of (Postconditions_Proc (Scope_Id), Loc)));\n       end if;\n \n       --  If it is a return from a procedure do no extra steps\n@@ -6558,10 +6546,11 @@ package body Exp_Ch6 is\n          end;\n       end if;\n \n-      --  Generate call to postcondition checks if they are present\n+      --  Call the _Postconditions procedure if the related function has\n+      --  contract assertions that need to be verified on exit.\n \n       if Ekind (Scope_Id) = E_Function\n-        and then Has_Postconditions (Scope_Id)\n+        and then Present (Postconditions_Proc (Scope_Id))\n       then\n          --  We are going to reference the returned value twice in this case,\n          --  once in the call to _Postconditions, and once in the actual return\n@@ -6669,11 +6658,12 @@ package body Exp_Ch6 is\n             end;\n          end if;\n \n-         --  Generate call to _postconditions\n+         --  Generate call to _Postconditions\n \n          Insert_Action (Exp,\n            Make_Procedure_Call_Statement (Loc,\n-             Name => Make_Identifier (Loc, Name_uPostconditions),\n+             Name                   =>\n+               New_Occurrence_Of (Postconditions_Proc (Scope_Id), Loc),\n              Parameter_Associations => New_List (Duplicate_Subexpr (Exp))));\n       end if;\n \n@@ -6697,11 +6687,10 @@ package body Exp_Ch6 is\n    -- Expand_Subprogram_Contract --\n    --------------------------------\n \n-   procedure Expand_Subprogram_Contract\n-     (N       : Node_Id;\n-      Spec_Id : Entity_Id;\n-      Body_Id : Entity_Id)\n-   is\n+   procedure Expand_Subprogram_Contract (N : Node_Id) is\n+      Body_Id : constant Entity_Id := Defining_Entity (N);\n+      Spec_Id : constant Entity_Id := Corresponding_Spec (N);\n+\n       procedure Add_Invariant_And_Predicate_Checks\n         (Subp_Id : Entity_Id;\n          Stmts   : in out List_Id;\n@@ -6735,29 +6724,17 @@ package body Exp_Ch6 is\n       --  the routine corrects the references of all formals of Inher_Id to\n       --  point to the formals of Subp_Id.\n \n-      procedure Collect_Body_Postconditions (Stmts : in out List_Id);\n-      --  Process all postconditions found in the declarations of the body. The\n-      --  routine appends the pragma Check equivalents to list Stmts.\n-\n-      procedure Collect_Spec_Postconditions\n-        (Subp_Id : Entity_Id;\n-         Stmts   : in out List_Id);\n-      --  Process all [inherited] postconditions of subprogram spec Subp_Id.\n-      --  The routine appends the pragma Check equivalents to list Stmts.\n+      procedure Process_Contract_Cases (Stmts : in out List_Id);\n+      --  Process pragma Contract_Cases. This routine prepends items to the\n+      --  body declarations and appends items to list Stmts.\n \n-      procedure Collect_Spec_Preconditions (Subp_Id : Entity_Id);\n-      --  Process all [inherited] preconditions of subprogram spec Subp_Id. The\n-      --  routine prepends the pragma Check equivalents to the declarations of\n-      --  the body.\n+      procedure Process_Postconditions (Stmts : in out List_Id);\n+      --  Collect all [inherited] spec and body postconditions and accumulate\n+      --  their pragma Check equivalents in list Stmts.\n \n-      procedure Prepend_To_Declarations (Item : Node_Id);\n-      --  Prepend a single item to the declarations of the subprogram body\n-\n-      procedure Process_Contract_Cases\n-        (Subp_Id : Entity_Id;\n-         Stmts   : in out List_Id);\n-      --  Process pragma Contract_Cases of subprogram spec Subp_Id. The routine\n-      --  appends the expanded code to list Stmts.\n+      procedure Process_Preconditions;\n+      --  Collect all [inherited] spec and body preconditions and prepend their\n+      --  pragma Check equivalents to the declarations of the body.\n \n       ----------------------------------------\n       -- Add_Invariant_And_Predicate_Checks --\n@@ -6954,15 +6931,9 @@ package body Exp_Ch6 is\n       begin\n          Result := Empty;\n \n-         --  Do not generate any checks if no code is being generated\n-\n-         if not Expander_Active then\n-            return;\n-         end if;\n-\n          --  Process the result of a function\n \n-         if Ekind_In (Subp_Id, E_Function, E_Generic_Function) then\n+         if Ekind (Subp_Id) = E_Function then\n             Typ := Etype (Subp_Id);\n \n             --  Generate _Result which is used in procedure _Postconditions to\n@@ -7103,25 +7074,23 @@ package body Exp_Ch6 is\n \n          --  Local variables\n \n-         Loc     : constant Source_Ptr := Sloc (N);\n-         Params  : List_Id := No_List;\n-         Proc_Id : Entity_Id;\n+         Loc      : constant Source_Ptr := Sloc (N);\n+         Params   : List_Id := No_List;\n+         Proc_Bod : Node_Id;\n+         Proc_Id  : Entity_Id;\n \n       --  Start of processing for Build_Postconditions_Procedure\n \n       begin\n-         --  Do not create the routine if no code is being generated\n-\n-         if not Expander_Active then\n-            return;\n-\n          --  Nothing to do if there are no actions to check on exit\n \n-         elsif No (Stmts) then\n+         if No (Stmts) then\n             return;\n          end if;\n \n          Proc_Id := Make_Defining_Identifier (Loc, Name_uPostconditions);\n+         Set_Debug_Info_Needed   (Proc_Id);\n+         Set_Postconditions_Proc (Subp_Id, Proc_Id);\n \n          --  The related subprogram is a function, create the specification of\n          --  parameter _Result.\n@@ -7152,13 +7121,12 @@ package body Exp_Ch6 is\n          --  order reference. The body of _Postconditions must be placed after\n          --  the declaration of Temp to preserve correct visibility.\n \n-         --  Note that we set an explicit End_Label in order to override the\n-         --  sloc of the implicit RETURN statement, and prevent it from\n-         --  inheriting the sloc of one of the postconditions: this would cause\n-         --  confusing debug info to be produced, interfering with coverage\n-         --  analysis tools.\n+         --  Set an explicit End_Lavel to override the sloc of the implicit\n+         --  RETURN statement, and prevent it from inheriting the sloc of one\n+         --  the postconditions: this would cause confusing debug into to be\n+         --  produced, interfering with coverage analysis tools.\n \n-         Insert_Before_First_Source_Declaration (\n+         Proc_Bod :=\n            Make_Subprogram_Body (Loc,\n              Specification              =>\n                Make_Procedure_Specification (Loc,\n@@ -7169,16 +7137,10 @@ package body Exp_Ch6 is\n              Handled_Statement_Sequence =>\n                Make_Handled_Sequence_Of_Statements (Loc,\n                  Statements => Stmts,\n-                 End_Label  => Make_Identifier (Loc, Chars (Proc_Id)))));\n-\n-         --  Set the attributes of the related subprogram to capture the\n-         --  generated procedure.\n-\n-         if Ekind_In (Subp_Id, E_Generic_Procedure, E_Procedure) then\n-            Set_Postcondition_Proc (Subp_Id, Proc_Id);\n-         end if;\n+                 End_Label  => Make_Identifier (Loc, Chars (Proc_Id))));\n \n-         Set_Has_Postconditions (Subp_Id);\n+         Insert_Before_First_Source_Declaration (Proc_Bod);\n+         Analyze (Proc_Bod);\n       end Build_Postconditions_Procedure;\n \n       -----------------------------------\n@@ -7238,14 +7200,6 @@ package body Exp_Ch6 is\n          Set_Comes_From_Source (Check_Prag, False);\n          Set_Analyzed          (Check_Prag, False);\n \n-         --  For a postcondition pragma within a generic, preserve the pragma\n-         --  for later expansion. This is also used when an error was detected,\n-         --  thus setting Expander_Active to False.\n-\n-         if Prag_Nam = Name_Postcondition and then not Expander_Active then\n-            return Check_Prag;\n-         end if;\n-\n          if Present (Corresponding_Aspect (Prag)) then\n             Nam := Chars (Identifier (Corresponding_Aspect (Prag)));\n          else\n@@ -7282,61 +7236,105 @@ package body Exp_Ch6 is\n          return Check_Prag;\n       end Build_Pragma_Check_Equivalent;\n \n-      ---------------------------------\n-      -- Collect_Body_Postconditions --\n-      ---------------------------------\n+      ----------------------------\n+      -- Process_Contract_Cases --\n+      ----------------------------\n+\n+      procedure Process_Contract_Cases (Stmts : in out List_Id) is\n+         procedure Process_Contract_Cases_For (Subp_Id : Entity_Id);\n+         --  Process pragma Contract_Cases for subprogram Subp_Id\n \n-      procedure Collect_Body_Postconditions (Stmts : in out List_Id) is\n-         procedure Collect_Body_Postconditions_Of_Kind (Post_Nam : Name_Id);\n-         --  Process all postconditions of the kind denoted by Post_Nam\n+         --------------------------------\n+         -- Process_Contract_Cases_For --\n+         --------------------------------\n \n-         -----------------------------------------\n-         -- Collect_Body_Postconditions_Of_Kind --\n-         -----------------------------------------\n+         procedure Process_Contract_Cases_For (Subp_Id : Entity_Id) is\n+            Items : constant Node_Id := Contract (Subp_Id);\n+            Prag  : Node_Id;\n \n-         procedure Collect_Body_Postconditions_Of_Kind (Post_Nam : Name_Id) is\n-            procedure Collect_Body_Postconditions_In_Decls\n-              (First_Decl : Node_Id);\n-            --  Process all postconditions found in a declarative list starting\n-            --  with declaration First_Decl.\n+         begin\n+            if Present (Items) then\n+               Prag := Contract_Test_Cases (Items);\n+               while Present (Prag) loop\n+                  if Pragma_Name (Prag) = Name_Contract_Cases then\n+                     Expand_Contract_Cases\n+                       (CCs     => Prag,\n+                        Subp_Id => Subp_Id,\n+                        Decls   => Declarations (N),\n+                        Stmts   => Stmts);\n+                  end if;\n \n-            ------------------------------------------\n-            -- Collect_Body_Postconditions_In_Decls --\n-            ------------------------------------------\n+                  Prag := Next_Pragma (Prag);\n+               end loop;\n+            end if;\n+         end Process_Contract_Cases_For;\n \n-            procedure Collect_Body_Postconditions_In_Decls\n-              (First_Decl : Node_Id)\n-            is\n-               Check_Prag : Node_Id;\n-               Decl       : Node_Id;\n+      --  Start of processing for Process_Contract_Cases\n \n-            begin\n-               --  Inspect the declarative list looking for a pragma that\n-               --  matches the desired name.\n+      begin\n+         Process_Contract_Cases_For (Body_Id);\n \n-               Decl := First_Decl;\n-               while Present (Decl) loop\n+         if Present (Spec_Id) then\n+            Process_Contract_Cases_For (Spec_Id);\n+         end if;\n+      end Process_Contract_Cases;\n \n-                  --  Note that non-matching pragmas are skipped\n+      ----------------------------\n+      -- Process_Postconditions --\n+      ----------------------------\n \n-                  if Nkind (Decl) = N_Pragma then\n-                     if Pragma_Name (Decl) = Post_Nam then\n-                        if not Analyzed (Decl) then\n-                           Analyze (Decl);\n-                        end if;\n+      procedure Process_Postconditions (Stmts : in out List_Id) is\n+         procedure Process_Body_Postconditions (Post_Nam : Name_Id);\n+         --  Collect all [refined] postconditions of a specific kind denoted\n+         --  by Post_Nam that belong to the body and generate pragma Check\n+         --  equivalents in list Stmts.\n+\n+         procedure Process_Spec_Postconditions;\n+         --  Collect all [inherited] postconditions of the spec and generate\n+         --  pragma Check equivalents in list Stmts.\n \n-                        Check_Prag := Build_Pragma_Check_Equivalent (Decl);\n+         ---------------------------------\n+         -- Process_Body_Postconditions --\n+         ---------------------------------\n \n-                        if Expander_Active then\n-                           Append_Enabled_Item\n-                             (Item => Check_Prag,\n-                              List => Stmts);\n+         procedure Process_Body_Postconditions (Post_Nam : Name_Id) is\n+            Items     : constant Node_Id := Contract (Body_Id);\n+            Unit_Decl : constant Node_Id := Parent (N);\n+            Decl      : Node_Id;\n+            Prag      : Node_Id;\n \n-                        --  If analyzing a generic unit, save pragma for later\n+         begin\n+            --  Process the contract\n \n-                        else\n-                           Prepend_To_Declarations (Check_Prag);\n-                        end if;\n+            if Present (Items) then\n+               Prag := Pre_Post_Conditions (Items);\n+               while Present (Prag) loop\n+                  if Pragma_Name (Prag) = Post_Nam then\n+                     Append_Enabled_Item\n+                       (Item => Build_Pragma_Check_Equivalent (Prag),\n+                        List => Stmts);\n+                  end if;\n+\n+                  Prag := Next_Pragma (Prag);\n+               end loop;\n+            end if;\n+\n+            --  The subprogram body being processed is actually the proper body\n+            --  of a stub with a corresponding spec. The subprogram stub may\n+            --  carry a postcondition pragma in which case it must be taken\n+            --  into account. The pragma appears after the stub.\n+\n+            if Present (Spec_Id) and then Nkind (Unit_Decl) = N_Subunit then\n+               Decl := Next (Corresponding_Stub (Unit_Decl));\n+               while Present (Decl) loop\n+\n+                  --  Note that non-matching pragmas are skipped\n+\n+                  if Nkind (Decl) = N_Pragma then\n+                     if Pragma_Name (Decl) = Post_Nam then\n+                        Append_Enabled_Item\n+                          (Item => Build_Pragma_Check_Equivalent (Decl),\n+                           List => Stmts);\n                      end if;\n \n                   --  Skip internally generated code\n@@ -7353,156 +7351,117 @@ package body Exp_Ch6 is\n \n                   Next (Decl);\n                end loop;\n-            end Collect_Body_Postconditions_In_Decls;\n-\n-            --  Local variables\n+            end if;\n+         end Process_Body_Postconditions;\n \n-            Unit_Decl : constant Node_Id := Parent (N);\n+         ---------------------------------\n+         -- Process_Spec_Postconditions --\n+         ---------------------------------\n \n-         --  Start of processing for Collect_Body_Postconditions_Of_Kind\n+         procedure Process_Spec_Postconditions is\n+            Subps   : constant Subprogram_List :=\n+                        Inherited_Subprograms (Spec_Id);\n+            Items   : Node_Id;\n+            Prag    : Node_Id;\n+            Subp_Id : Entity_Id;\n \n          begin\n-            pragma Assert (Nam_In (Post_Nam, Name_Postcondition,\n-                                             Name_Refined_Post));\n+            --  Process the contract\n \n-            --  Inspect the declarations of the subprogram body looking for a\n-            --  pragma that matches the desired name.\n+            Items := Contract (Spec_Id);\n \n-            Collect_Body_Postconditions_In_Decls\n-              (First_Decl => First (Declarations (N)));\n-\n-            --  The subprogram body being processed is actually the proper body\n-            --  of a stub with a corresponding spec. The subprogram stub may\n-            --  carry a postcondition pragma in which case it must be taken\n-            --  into account. The pragma appears after the stub.\n+            if Present (Items) then\n+               Prag := Pre_Post_Conditions (Items);\n+               while Present (Prag) loop\n+                  if Pragma_Name (Prag) = Name_Postcondition then\n+                     Append_Enabled_Item\n+                       (Item => Build_Pragma_Check_Equivalent (Prag),\n+                        List => Stmts);\n+                  end if;\n \n-            if Present (Spec_Id) and then Nkind (Unit_Decl) = N_Subunit then\n-               Collect_Body_Postconditions_In_Decls\n-                 (First_Decl => Next (Corresponding_Stub (Unit_Decl)));\n+                  Prag := Next_Pragma (Prag);\n+               end loop;\n             end if;\n-         end Collect_Body_Postconditions_Of_Kind;\n-\n-      --  Start of processing for Collect_Body_Postconditions\n-\n-      begin\n-         Collect_Body_Postconditions_Of_Kind (Name_Refined_Post);\n-         Collect_Body_Postconditions_Of_Kind (Name_Postcondition);\n-      end Collect_Body_Postconditions;\n-\n-      ---------------------------------\n-      -- Collect_Spec_Postconditions --\n-      ---------------------------------\n-\n-      procedure Collect_Spec_Postconditions\n-        (Subp_Id : Entity_Id;\n-         Stmts   : in out List_Id)\n-      is\n-         Inher_Subps   : constant Subprogram_List :=\n-                           Inherited_Subprograms (Subp_Id);\n-         Check_Prag    : Node_Id;\n-         Prag          : Node_Id;\n-         Inher_Subp_Id : Entity_Id;\n-\n-      begin\n-         --  Process the contract of the spec\n \n-         Prag := Pre_Post_Conditions (Contract (Subp_Id));\n-         while Present (Prag) loop\n-            if Pragma_Name (Prag) = Name_Postcondition then\n-               Check_Prag := Build_Pragma_Check_Equivalent (Prag);\n+            --  Process the contracts of all inherited subprograms, looking for\n+            --  class-wide postconditions.\n \n-               if Expander_Active then\n-                  Append_Enabled_Item\n-                    (Item => Check_Prag,\n-                     List => Stmts);\n+            for Index in Subps'Range loop\n+               Subp_Id := Subps (Index);\n+               Items   := Contract (Subp_Id);\n \n-               --  When analyzing a generic unit, save the pragma for later\n+               if Present (Items) then\n+                  Prag := Pre_Post_Conditions (Items);\n+                  while Present (Prag) loop\n+                     if Pragma_Name (Prag) = Name_Postcondition\n+                       and then Class_Present (Prag)\n+                     then\n+                        Append_Enabled_Item\n+                          (Item =>\n+                             Build_Pragma_Check_Equivalent\n+                               (Prag     => Prag,\n+                                Subp_Id  => Spec_Id,\n+                                Inher_Id => Subp_Id),\n+                           List => Stmts);\n+                     end if;\n \n-               else\n-                  Prepend_To_Declarations (Check_Prag);\n+                     Prag := Next_Pragma (Prag);\n+                  end loop;\n                end if;\n-            end if;\n-\n-            Prag := Next_Pragma (Prag);\n-         end loop;\n-\n-         --  Process the contracts of all inherited subprograms, looking for\n-         --  class-wide postconditions.\n-\n-         for Index in Inher_Subps'Range loop\n-            Inher_Subp_Id := Inher_Subps (Index);\n+            end loop;\n+         end Process_Spec_Postconditions;\n \n-            Prag := Pre_Post_Conditions (Contract (Inher_Subp_Id));\n-            while Present (Prag) loop\n-               if Pragma_Name (Prag) = Name_Postcondition\n-                 and then Class_Present (Prag)\n-               then\n-                  Check_Prag :=\n-                    Build_Pragma_Check_Equivalent\n-                      (Prag     => Prag,\n-                       Subp_Id  => Subp_Id,\n-                       Inher_Id => Inher_Subp_Id);\n+      --  Start of processing for Process_Postconditions\n \n-                  if Expander_Active then\n-                     Append_Enabled_Item\n-                       (Item => Check_Prag,\n-                        List => Stmts);\n+      begin\n+         --  The processing of postconditions is done in reverse order (body\n+         --  first) to ensure the following arrangement:\n \n-                  --  When analyzing a generic unit, save the pragma for later\n+         --    <refined postconditions from body>\n+         --    <postconditions from body>\n+         --    <postconditions from spec>\n+         --    <inherited postconditions>\n \n-                  else\n-                     Prepend_To_Declarations (Check_Prag);\n-                  end if;\n-               end if;\n+         Process_Body_Postconditions (Name_Refined_Post);\n+         Process_Body_Postconditions (Name_Postcondition);\n \n-               Prag := Next_Pragma (Prag);\n-            end loop;\n-         end loop;\n-      end Collect_Spec_Postconditions;\n+         if Present (Spec_Id) then\n+            Process_Spec_Postconditions;\n+         end if;\n+      end Process_Postconditions;\n \n-      --------------------------------\n-      -- Collect_Spec_Preconditions --\n-      --------------------------------\n+      ---------------------------\n+      -- Process_Preconditions --\n+      ---------------------------\n \n-      procedure Collect_Spec_Preconditions (Subp_Id : Entity_Id) is\n+      procedure Process_Preconditions is\n          Class_Pre : Node_Id := Empty;\n-         --  The sole class-wide precondition pragma that applies to the\n-         --  subprogram.\n+         --  The sole [inherited] class-wide precondition pragma that applies\n+         --  to the subprogram.\n \n-         procedure Add_Or_Save_Precondition (Prag : Node_Id);\n-         --  Save a class-wide precondition or add a regulat precondition to\n-         --  the declarative list of the body.\n+         Insert_Node : Node_Id := Empty;\n+         --  The insertion node after which all pragma Check equivalents are\n+         --  inserted.\n \n          procedure Merge_Preconditions (From : Node_Id; Into : Node_Id);\n          --  Merge two class-wide preconditions by \"or else\"-ing them. The\n          --  changes are accumulated in parameter Into. Update the error\n          --  message of Into.\n \n-         ------------------------------\n-         -- Add_Or_Save_Precondition --\n-         ------------------------------\n-\n-         procedure Add_Or_Save_Precondition (Prag : Node_Id) is\n-            Check_Prag : Node_Id;\n-\n-         begin\n-            Check_Prag := Build_Pragma_Check_Equivalent (Prag);\n+         procedure Prepend_To_Decls (Item : Node_Id);\n+         --  Prepend a single item to the declarations of the subprogram body\n \n-            --  Save the sole class-wide precondition (if any) for the next\n-            --  step where it will be merged with inherited preconditions.\n+         procedure Prepend_To_Decls_Or_Save (Prag : Node_Id);\n+         --  Save a class-wide precondition into Class_Pre or prepend a normal\n+         --  precondition ot the declarations of the body and analyze it.\n \n-            if Class_Present (Prag) then\n-               pragma Assert (No (Class_Pre));\n-               Class_Pre := Check_Prag;\n+         procedure Process_Inherited_Preconditions;\n+         --  Collect all inherited class-wide preconditions and merge them into\n+         --  one big precondition to be evaluated as pragma Check.\n \n-            --  Accumulate the corresponding Check pragmas to the top of the\n-            --  declarations. Prepending the items ensures that they will be\n-            --  evaluated in their original order.\n-\n-            else\n-               Prepend_To_Declarations (Check_Prag);\n-            end if;\n-         end Add_Or_Save_Precondition;\n+         procedure Process_Preconditions_For (Subp_Id : Entity_Id);\n+         --  Collect all preconditions of subprogram Subp_Id and prepend their\n+         --  pragma Check equivalents to the declarations of the body.\n \n          -------------------------\n          -- Merge_Preconditions --\n@@ -7576,189 +7535,291 @@ package body Exp_Ch6 is\n             end if;\n          end Merge_Preconditions;\n \n-         --  Local variables\n-\n-         Inher_Subps   : constant Subprogram_List :=\n-                           Inherited_Subprograms (Subp_Id);\n-         Subp_Decl     : constant Node_Id := Parent (Parent (Subp_Id));\n-         Check_Prag    : Node_Id;\n-         Decl          : Node_Id;\n-         Inher_Subp_Id : Entity_Id;\n-         Prag          : Node_Id;\n+         ----------------------\n+         -- Prepend_To_Decls --\n+         ----------------------\n \n-      --  Start of processing for Collect_Spec_Preconditions\n+         procedure Prepend_To_Decls (Item : Node_Id) is\n+            Decls : List_Id := Declarations (N);\n \n-      begin\n-         --  Process the contract of the spec\n+         begin\n+            --  Ensure that the body has a declarative list\n \n-         Prag := Pre_Post_Conditions (Contract (Subp_Id));\n-         while Present (Prag) loop\n-            if Pragma_Name (Prag) = Name_Precondition then\n-               Add_Or_Save_Precondition (Prag);\n+            if No (Decls) then\n+               Decls := New_List;\n+               Set_Declarations (N, Decls);\n             end if;\n \n-            Prag := Next_Pragma (Prag);\n-         end loop;\n+            Prepend_To (Decls, Item);\n+         end Prepend_To_Decls;\n \n-         --  The subprogram declaration being processed is actually a body\n-         --  stub. The stub may carry a precondition pragma in which case it\n-         --  must be taken into account. The pragma appears after the stub.\n+         ------------------------------\n+         -- Prepend_To_Decls_Or_Save --\n+         ------------------------------\n \n-         if Nkind (Subp_Decl) = N_Subprogram_Body_Stub then\n+         procedure Prepend_To_Decls_Or_Save (Prag : Node_Id) is\n+            Check_Prag : Node_Id;\n \n-            --  Inspect the declarations following the body stub\n+         begin\n+            Check_Prag := Build_Pragma_Check_Equivalent (Prag);\n \n-            Decl := Next (Subp_Decl);\n-            while Present (Decl) loop\n+            --  Save the sole class-wide precondition (if any) for the next\n+            --  step where it will be merged with inherited preconditions.\n \n-               --  Note that non-matching pragmas are skipped\n+            if Class_Present (Prag) then\n+               pragma Assert (No (Class_Pre));\n+               Class_Pre := Check_Prag;\n \n-               if Nkind (Decl) = N_Pragma then\n-                  if Pragma_Name (Decl) = Name_Precondition then\n-                     if not Analyzed (Decl) then\n-                        Analyze (Decl);\n-                     end if;\n+            --  Accumulate the corresponding Check pragmas at the top of the\n+            --  declarations. Prepending the items ensures that they will be\n+            --  evaluated in their original order.\n \n-                     Add_Or_Save_Precondition (Decl);\n-                  end if;\n+            else\n+               if Present (Insert_Node) then\n+                  Insert_After (Insert_Node, Check_Prag);\n+               else\n+                  Prepend_To_Decls (Check_Prag);\n+               end if;\n \n-               --  Skip internally generated code\n+               Analyze (Check_Prag);\n+            end if;\n+         end Prepend_To_Decls_Or_Save;\n \n-               elsif not Comes_From_Source (Decl) then\n-                  null;\n+         -------------------------------------\n+         -- Process_Inherited_Preconditions --\n+         -------------------------------------\n \n-               --  Preconditions are usually grouped together. There is no need\n-               --  to inspect the whole declarative list.\n+         procedure Process_Inherited_Preconditions is\n+            Subps      : constant Subprogram_List :=\n+                           Inherited_Subprograms (Spec_Id);\n+            Check_Prag : Node_Id;\n+            Items      : Node_Id;\n+            Prag       : Node_Id;\n+            Subp_Id    : Entity_Id;\n \n-               else\n-                  exit;\n-               end if;\n+         begin\n+            --  Process the contracts of all inherited subprograms, looking for\n+            --  class-wide preconditions.\n+\n+            for Index in Subps'Range loop\n+               Subp_Id := Subps (Index);\n+               Items   := Contract (Subp_Id);\n+\n+               if Present (Items) then\n+                  Prag := Pre_Post_Conditions (Items);\n+                  while Present (Prag) loop\n+                     if Pragma_Name (Prag) = Name_Precondition\n+                       and then Class_Present (Prag)\n+                     then\n+                        Check_Prag :=\n+                          Build_Pragma_Check_Equivalent\n+                            (Prag     => Prag,\n+                             Subp_Id  => Spec_Id,\n+                             Inher_Id => Subp_Id);\n+\n+                        --  The spec or an inherited subprogram already yielded\n+                        --  a class-wide precondition. Merge the existing\n+                        --  precondition with the current one using \"or else\".\n+\n+                        if Present (Class_Pre) then\n+                           Merge_Preconditions (Check_Prag, Class_Pre);\n+                        else\n+                           Class_Pre := Check_Prag;\n+                        end if;\n+                     end if;\n \n-               Next (Decl);\n+                     Prag := Next_Pragma (Prag);\n+                  end loop;\n+               end if;\n             end loop;\n-         end if;\n \n-         --  Process the contracts of all inherited subprograms, looking for\n-         --  class-wide preconditions.\n+            --  Add the merged class-wide preconditions\n \n-         for Index in Inher_Subps'Range loop\n-            Inher_Subp_Id := Inher_Subps (Index);\n+            if Present (Class_Pre) then\n+               Prepend_To_Decls (Class_Pre);\n+               Analyze (Class_Pre);\n+            end if;\n+         end Process_Inherited_Preconditions;\n \n-            Prag := Pre_Post_Conditions (Contract (Inher_Subp_Id));\n-            while Present (Prag) loop\n-               if Pragma_Name (Prag) = Name_Precondition\n-                 and then Class_Present (Prag)\n-               then\n-                  Check_Prag :=\n-                    Build_Pragma_Check_Equivalent\n-                      (Prag     => Prag,\n-                       Subp_Id  => Subp_Id,\n-                       Inher_Id => Inher_Subp_Id);\n+         -------------------------------\n+         -- Process_Preconditions_For --\n+         -------------------------------\n \n-                  --  The spec or an inherited subprogram already yielded a\n-                  --  class-wide precondition. Merge the existing precondition\n-                  --  with the current one using \"or else\".\n+         procedure Process_Preconditions_For (Subp_Id : Entity_Id) is\n+            Items     : constant Node_Id := Contract (Subp_Id);\n+            Decl      : Node_Id;\n+            Prag      : Node_Id;\n+            Subp_Decl : Node_Id;\n \n-                  if Present (Class_Pre) then\n-                     Merge_Preconditions (Check_Prag, Class_Pre);\n+         begin\n+            --  Process the contract\n \n-                  else\n-                     Class_Pre := Check_Prag;\n+            if Present (Items) then\n+               Prag := Pre_Post_Conditions (Items);\n+               while Present (Prag) loop\n+                  if Pragma_Name (Prag) = Name_Precondition then\n+                     Prepend_To_Decls_Or_Save (Prag);\n                   end if;\n-               end if;\n \n-               Prag := Next_Pragma (Prag);\n-            end loop;\n-         end loop;\n+                  Prag := Next_Pragma (Prag);\n+               end loop;\n+            end if;\n \n-         --  Add the merged class-wide preconditions (if any)\n+            --  The subprogram declaration being processed is actually a body\n+            --  stub. The stub may carry a precondition pragma in which case it\n+            --  must be taken into account. The pragma appears after the stub.\n \n-         if Present (Class_Pre) then\n-            Prepend_To_Declarations (Class_Pre);\n-         end if;\n-      end Collect_Spec_Preconditions;\n+            Subp_Decl := Unit_Declaration_Node (Subp_Id);\n \n-      -----------------------------\n-      -- Prepend_To_Declarations --\n-      -----------------------------\n+            if Nkind (Subp_Decl) = N_Subprogram_Body_Stub then\n \n-      procedure Prepend_To_Declarations (Item : Node_Id) is\n-         Decls : List_Id := Declarations (N);\n+               --  Inspect the declarations following the body stub\n \n-      begin\n-         --  Ensure that the body has a declarative list\n+               Decl := Next (Subp_Decl);\n+               while Present (Decl) loop\n \n-         if No (Decls) then\n-            Decls := New_List;\n-            Set_Declarations (N, Decls);\n-         end if;\n+                  --  Note that non-matching pragmas are skipped\n+\n+                  if Nkind (Decl) = N_Pragma then\n+                     if Pragma_Name (Decl) = Name_Precondition then\n+                        Prepend_To_Decls_Or_Save (Decl);\n+                     end if;\n \n-         Prepend_To (Decls, Item);\n-      end Prepend_To_Declarations;\n+                  --  Skip internally generated code\n \n-      ----------------------------\n-      -- Process_Contract_Cases --\n-      ----------------------------\n+                  elsif not Comes_From_Source (Decl) then\n+                     null;\n \n-      procedure Process_Contract_Cases\n-        (Subp_Id : Entity_Id;\n-         Stmts   : in out List_Id)\n-      is\n-         Prag : Node_Id;\n+                  --  Preconditions are usually grouped together. There is no\n+                  --  need to inspect the whole declarative list.\n+\n+                  else\n+                     exit;\n+                  end if;\n+\n+                  Next (Decl);\n+               end loop;\n+            end if;\n+         end Process_Preconditions_For;\n+\n+         --  Local variables\n+\n+         Decls : constant List_Id := Declarations (N);\n+         Decl  : Node_Id;\n+\n+      --  Start of processing for Process_Preconditions\n \n       begin\n-         --  Do not build the Contract_Cases circuitry if no code is being\n-         --  generated.\n+         --  Find the last internally generate declaration starting from the\n+         --  top of the body declarations. This ensures that discriminals and\n+         --  subtypes are properly visible to the pragma Check equivalents.\n \n-         if not Expander_Active then\n-            return;\n+         if Present (Decls) then\n+            Decl := First (Decls);\n+\n+            while Present (Decl) loop\n+               if not Comes_From_Source (Decl) then\n+                  Insert_Node := Decl;\n+                  exit;\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n          end if;\n \n-         Prag := Contract_Test_Cases (Contract (Subp_Id));\n-         while Present (Prag) loop\n-            if Pragma_Name (Prag) = Name_Contract_Cases then\n-               Expand_Contract_Cases\n-                 (CCs     => Prag,\n-                  Subp_Id => Subp_Id,\n-                  Decls   => Declarations (N),\n-                  Stmts   => Stmts);\n-            end if;\n+         --  The processing of preconditions is done in reverse order (body\n+         --  first) because each pragma Check equivalent is inserted at the\n+         --  top of the declarations. This ensures that the final order is\n+         --  consistent with following diagram:\n \n-            Prag := Next_Pragma (Prag);\n-         end loop;\n-      end Process_Contract_Cases;\n+         --    <inherited preconditions>\n+         --    <preconditions from spec>\n+         --    <preconditions from body>\n+\n+         Process_Preconditions_For (Body_Id);\n+\n+         if Present (Spec_Id) then\n+            Process_Preconditions_For (Spec_Id);\n+            Process_Inherited_Preconditions;\n+         end if;\n+      end Process_Preconditions;\n \n       --  Local variables\n \n-      Post_Stmts : List_Id := No_List;\n-      Result     : Entity_Id;\n-      Subp_Id    : Entity_Id;\n+      Restore_Scope : Boolean := False;\n+      Result        : Entity_Id;\n+      Stmts         : List_Id := No_List;\n+      Subp_Id       : Entity_Id;\n \n    --  Start of processing for Expand_Subprogram_Contract\n \n    begin\n+      --  Obtain the entity of the initial declaration\n+\n       if Present (Spec_Id) then\n          Subp_Id := Spec_Id;\n       else\n          Subp_Id := Body_Id;\n       end if;\n \n-      --  Do not process a predicate function as its body will end up with a\n-      --  recursive call to itself and blow up the stack.\n+      --  Do not perform expansion activity when it is not needed\n \n-      if Ekind (Subp_Id) = E_Function\n-        and then Is_Predicate_Function (Subp_Id)\n-      then\n+      if not Expander_Active then\n          return;\n \n-      --  Do not process TSS subprograms\n+      --  ASIS requires an unaltered tree\n \n-      elsif Get_TSS_Name (Subp_Id) /= TSS_Null then\n+      elsif ASIS_Mode then\n+         return;\n+\n+      --  GNATprove does not need the executable semantics of a contract\n+\n+      elsif GNATprove_Mode then\n+         return;\n+\n+      --  The contract of a generic subprogram or one declared in a generic\n+      --  context is not expanded as the corresponding instance will provide\n+      --  the executable semantics of the contract.\n+\n+      elsif Is_Generic_Subprogram (Subp_Id) or else Inside_A_Generic then\n+         return;\n+\n+      --  All subprograms carry a contract, but for some it is not significant\n+      --  and should not be processed. This is a small optimization.\n+\n+      elsif not Has_Significant_Contract (Subp_Id) then\n          return;\n       end if;\n \n-      --  The expansion of a subprogram contract involves the relocation of\n-      --  various contract assertions to the declarations of the body in a\n+      --  Do not re-expand the same contract. This scenario occurs when a\n+      --  construct is rewritten into something else during its analysis\n+      --  (expression functions for instance).\n+\n+      if Has_Expanded_Contract (Subp_Id) then\n+         return;\n+\n+      --  Otherwise mark the subprogram\n+\n+      else\n+         Set_Has_Expanded_Contract (Subp_Id);\n+      end if;\n+\n+      --  Ensure that the formal parameters are visible when expanding all\n+      --  contract items.\n+\n+      if not In_Open_Scopes (Subp_Id) then\n+         Restore_Scope := True;\n+         Push_Scope (Subp_Id);\n+\n+         if Is_Generic_Subprogram (Subp_Id) then\n+            Install_Generic_Formals (Subp_Id);\n+         else\n+            Install_Formals (Subp_Id);\n+         end if;\n+      end if;\n+\n+      --  The expansion of a subprogram contract involves the creation of Check\n+      --  pragmas to verify the contract assertions of the spec and body in a\n       --  particular order. The order is as follows:\n \n       --    function Example (...) return ... is\n@@ -7769,14 +7830,13 @@ package body Exp_Ch6 is\n       --          <postconditions from spec>\n       --          <inherited postconditions>\n       --          <contract case consequences>\n-      --          <invariant check of function result (if applicable)>\n+      --          <invariant check of function result>\n       --          <invariant and predicate checks of parameters>\n       --       end _Postconditions;\n \n       --       <inherited preconditions>\n       --       <preconditions from spec>\n       --       <preconditions from body>\n-      --       <refined preconditions from body>\n       --       <contract case conditions>\n \n       --       <source declarations>\n@@ -7788,41 +7848,38 @@ package body Exp_Ch6 is\n       --    end Example;\n \n       --  Routine _Postconditions holds all contract assertions that must be\n-      --  verified on exit from the related routine.\n+      --  verified on exit from the related subprogram.\n \n-      --  Collect all [inherited] preconditions from the spec, transform them\n-      --  into Check pragmas and add them to the declarations of the body in\n-      --  the order outlined above.\n-\n-      if Present (Spec_Id) then\n-         Collect_Spec_Preconditions (Spec_Id);\n-      end if;\n+      --  Step 1: Handle all preconditions. This action must come before the\n+      --  processing of pragma Contract_Cases because the pragma prepends items\n+      --  to the body declarations.\n \n-      --  Transform all [refined] postconditions of the body into Check\n-      --  pragmas. The resulting pragmas are accumulated in list Post_Stmts.\n+      Process_Preconditions;\n \n-      Collect_Body_Postconditions (Post_Stmts);\n+      --  Step 2: Handle all postconditions. This action must come before the\n+      --  processing of pragma Contract_Cases because the pragma appends items\n+      --  to list Stmts.\n \n-      --  Transform all [inherited] postconditions from the spec into Check\n-      --  pragmas. The resulting pragmas are accumulated in list Post_Stmts.\n+      Process_Postconditions (Stmts);\n \n-      if Present (Spec_Id) then\n-         Collect_Spec_Postconditions (Spec_Id, Post_Stmts);\n+      --  Step 3: Handle pragma Contract_Cases. This action must come before\n+      --  the processing of invariants and predicates because those append\n+      --  items to list Smts.\n \n-         --  Transform pragma Contract_Cases from the spec into its circuitry\n+      Process_Contract_Cases (Stmts);\n \n-         Process_Contract_Cases (Spec_Id, Post_Stmts);\n-      end if;\n+      --  Step 4: Apply invariant and predicate checks on a function result and\n+      --  all formals. The resulting checks are accumulated in list Stmts.\n \n-      --  Apply invariant and predicate checks on the result of a function (if\n-      --  applicable) and all formals. The resulting checks are accumulated in\n-      --  list Post_Stmts.\n+      Add_Invariant_And_Predicate_Checks (Subp_Id, Stmts, Result);\n \n-      Add_Invariant_And_Predicate_Checks (Subp_Id, Post_Stmts, Result);\n+      --  Step 5: Construct procedure _Postconditions\n \n-      --  Construct procedure _Postconditions\n+      Build_Postconditions_Procedure (Subp_Id, Stmts, Result);\n \n-      Build_Postconditions_Procedure (Subp_Id, Post_Stmts, Result);\n+      if Restore_Scope then\n+         End_Scope;\n+      end if;\n    end Expand_Subprogram_Contract;\n \n    --------------------------------"}, {"sha": "48b98e812e9cc4da41cb9ffecdb43f2630209c47", "filename": "gcc/ada/exp_ch6.ads", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fexp_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fexp_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.ads?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,17 +41,11 @@ package Exp_Ch6 is\n    --  This procedure contains common processing for Expand_N_Function_Call,\n    --  Expand_N_Procedure_Statement, and Expand_N_Entry_Call.\n \n-   procedure Expand_Subprogram_Contract\n-     (N       : Node_Id;\n-      Spec_Id : Entity_Id;\n-      Body_Id : Entity_Id);\n+   procedure Expand_Subprogram_Contract (N : Node_Id);\n    --  Expand the contracts of a subprogram body and its correspoding spec (if\n    --  any). This routine processes all [refined] pre- and postconditions as\n-   --  well as Contract_Cases, invariants and predicates. N is the body of the\n-   --  subprogram. Spec_Id denotes the entity of its specification. Body_Id\n-   --  denotes the entity of the subprogram body. This routine is not a \"pure\"\n-   --  expansion mechanism as it is invoked during analysis and may perform\n-   --  actions for generic subprograms or set up contract assertions for ASIS.\n+   --  well as Contract_Cases, invariants and predicates. N denotes the body of\n+   --  the subprogram.\n \n    procedure Freeze_Subprogram (N : Node_Id);\n    --  generate the appropriate expansions related to Subprogram freeze"}, {"sha": "6c1858bd59588185c51f323503e2d597553eb62e", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 41, "deletions": 48, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -1919,68 +1919,59 @@ package body Exp_Ch9 is\n    -----------------------\n \n    procedure Build_PPC_Wrapper (E : Entity_Id; Decl : Node_Id) is\n+      Items      : constant Node_Id    := Contract (E);\n       Loc        : constant Source_Ptr := Sloc (E);\n-      Synch_Type : constant Entity_Id := Scope (E);\n-\n-      Wrapper_Id : constant Entity_Id :=\n-                     Make_Defining_Identifier (Loc,\n-                       Chars => New_External_Name (Chars (E), 'E'));\n-      --  the wrapper procedure name\n-\n-      Wrapper_Body : Node_Id;\n-\n-      Synch_Id : constant Entity_Id :=\n-                   Make_Defining_Identifier (Loc,\n-                     Chars => New_External_Name (Chars (Scope (E)), 'A'));\n-      --  The parameter that designates the synchronized object in the call\n-\n-      Actuals : constant List_Id := New_List;\n-      --  The actuals in the entry call\n-\n-      Decls : constant List_Id := New_List;\n-\n+      Synch_Type : constant Entity_Id  := Scope (E);\n+      Actuals    : List_Id;\n+      Decls      : List_Id;\n       Entry_Call : Node_Id;\n       Entry_Name : Node_Id;\n-\n-      Specs : List_Id;\n-      --  The specification of the wrapper procedure\n+      Params     : List_Id;\n+      Prag       : Node_Id;\n+      Synch_Id   : Entity_Id;\n+      Wrapper_Id : Entity_Id;\n \n    begin\n-\n-      --  Only build the wrapper if entry has pre/postconditions.\n+      --  Only build the wrapper if entry has pre/postconditions\n       --  Should this be done unconditionally instead ???\n \n-      declare\n-         P : Node_Id;\n+      if Present (Items) then\n+         Prag := Pre_Post_Conditions (Items);\n \n-      begin\n-         P := Pre_Post_Conditions (Contract (E));\n-\n-         if No (P) then\n+         if No (Prag) then\n             return;\n          end if;\n \n          --  Transfer ppc pragmas to the declarations of the wrapper\n \n-         while Present (P) loop\n-            if Nam_In (Pragma_Name (P), Name_Precondition,\n-                                        Name_Postcondition)\n+         Decls := New_List;\n+\n+         while Present (Prag) loop\n+            if Nam_In (Pragma_Name (Prag), Name_Precondition,\n+                                           Name_Postcondition)\n             then\n-               Append (Relocate_Node (P), Decls);\n+               Append (Relocate_Node (Prag), Decls);\n                Set_Analyzed (Last (Decls), False);\n             end if;\n \n-            P := Next_Pragma (P);\n+            Prag := Next_Pragma (Prag);\n          end loop;\n-      end;\n+      else\n+         return;\n+      end if;\n+\n+      Actuals  := New_List;\n+      Synch_Id :=\n+        Make_Defining_Identifier (Loc,\n+          Chars => New_External_Name (Chars (Scope (E)), 'A'));\n \n       --  First formal is synchronized object\n \n-      Specs := New_List (\n+      Params := New_List (\n         Make_Parameter_Specification (Loc,\n           Defining_Identifier => Synch_Id,\n-          Out_Present         =>  True,\n-          In_Present          =>  True,\n+          Out_Present         => True,\n+          In_Present          => True,\n           Parameter_Type      => New_Occurrence_Of (Scope (E), Loc)));\n \n       Entry_Name :=\n@@ -1996,7 +1987,7 @@ package body Exp_Ch9 is\n             Index : constant Entity_Id :=\n                       Make_Defining_Identifier (Loc, Name_I);\n          begin\n-            Append_To (Specs,\n+            Append_To (Params,\n               Make_Parameter_Specification (Loc,\n                 Defining_Identifier => Index,\n                 Parameter_Type      =>\n@@ -2033,7 +2024,7 @@ package body Exp_Ch9 is\n                 In_Present          => In_Present  (Parent (Form)),\n                 Parameter_Type      => New_Occurrence_Of (Etype (Form), Loc));\n \n-            Append (Parm_Spec, Specs);\n+            Append (Parm_Spec, Params);\n             Append (New_Occurrence_Of (New_Form, Loc), Actuals);\n             Next_Formal (Form);\n          end loop;\n@@ -2065,21 +2056,22 @@ package body Exp_Ch9 is\n          end;\n       end if;\n \n+      Wrapper_Id :=\n+        Make_Defining_Identifier (Loc, New_External_Name (Chars (E), 'E'));\n       Set_PPC_Wrapper (E, Wrapper_Id);\n-      Wrapper_Body :=\n+\n+      --  The wrapper body is analyzed when the enclosing type is frozen\n+\n+      Append_Freeze_Action (Defining_Entity (Decl),\n         Make_Subprogram_Body (Loc,\n           Specification              =>\n             Make_Procedure_Specification (Loc,\n               Defining_Unit_Name       => Wrapper_Id,\n-              Parameter_Specifications => Specs),\n+              Parameter_Specifications => Params),\n           Declarations               => Decls,\n           Handled_Statement_Sequence =>\n             Make_Handled_Sequence_Of_Statements (Loc,\n-              Statements => New_List (Entry_Call)));\n-\n-      --  The wrapper body is analyzed when the enclosing type is frozen\n-\n-      Append_Freeze_Action (Defining_Entity (Decl), Wrapper_Body);\n+              Statements => New_List (Entry_Call))));\n    end Build_PPC_Wrapper;\n \n    --------------------------\n@@ -12087,6 +12079,7 @@ package body Exp_Ch9 is\n          Ent := First_Entity (Tasktyp);\n          while Present (Ent) loop\n             if Ekind_In (Ent, E_Entry, E_Entry_Family)\n+              and then Present (Contract (Ent))\n               and then Present (Pre_Post_Conditions (Contract (Ent)))\n             then\n                Build_PPC_Wrapper (Ent, N);"}, {"sha": "1edf2bc39efb5cfa212055d73df8914c7f94913e", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 72, "deletions": 36, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -274,18 +274,20 @@ package body Exp_Prag is\n       --  Given the entity Id of a boolean flag, generate:\n       --    Id : Boolean := False;\n \n-      procedure Expand_Old_In_Consequence\n+      procedure Expand_Attributes_In_Consequence\n         (Decls  : List_Id;\n          Evals  : in out Node_Id;\n          Flag   : Entity_Id;\n          Conseq : Node_Id);\n       --  Perform specialized expansion of all attribute 'Old references found\n       --  in consequence Conseq such that at runtime only prefixes coming from\n-      --  the selected consequence are evaluated. Any temporaries generated in\n-      --  the process are added to declarative list Decls. Evals is a complex\n-      --  if statement tasked with the evaluation of all prefixes coming from\n-      --  a selected consequence. Flag is the corresponding case guard flag.\n-      --  Conseq is the consequence expression.\n+      --  the selected consequence are evaluated. Similarly expand attribute\n+      --  'Result references by replacing them with identifier _result which\n+      --  resolves to the sole formal parameter of procedure _Postconditions.\n+      --  Any temporaries generated in the process are added to declarations\n+      --  Decls. Evals is a complex if statement tasked with the evaluation of\n+      --  all prefixes coming from a single selected consequence. Flag is the\n+      --  corresponding case guard flag. Conseq is the consequence expression.\n \n       function Increment (Id : Entity_Id) return Node_Id;\n       --  Given the entity Id of a numerical variable, generate:\n@@ -409,11 +411,11 @@ package body Exp_Prag is\n              Expression          => New_Occurrence_Of (Standard_False, Loc));\n       end Declaration_Of;\n \n-      -------------------------------\n-      -- Expand_Old_In_Consequence --\n-      -------------------------------\n+      --------------------------------------\n+      -- Expand_Attributes_In_Consequence --\n+      --------------------------------------\n \n-      procedure Expand_Old_In_Consequence\n+      procedure Expand_Attributes_In_Consequence\n         (Decls  : List_Id;\n          Evals  : in out Node_Id;\n          Flag   : Entity_Id;\n@@ -423,20 +425,22 @@ package body Exp_Prag is\n          --  The evaluation sequence expressed as assignment statements of all\n          --  prefixes of attribute 'Old found in the current consequence.\n \n-         function Expand_Old (N : Node_Id) return Traverse_Result;\n-         --  Determine whether an arbitrary node denotes attribute 'Old and if\n-         --  it does, perform all expansion-related actions.\n+         function Expand_Attributes (N : Node_Id) return Traverse_Result;\n+         --  Determine whether an arbitrary node denotes attribute 'Old or\n+         --  'Result and if it does, perform all expansion-related actions.\n \n-         ----------------\n-         -- Expand_Old --\n-         ----------------\n+         -----------------------\n+         -- Expand_Attributes --\n+         -----------------------\n \n-         function Expand_Old (N : Node_Id) return Traverse_Result is\n+         function Expand_Attributes (N : Node_Id) return Traverse_Result is\n             Decl : Node_Id;\n             Pref : Node_Id;\n             Temp : Entity_Id;\n \n          begin\n+            --  Attribute 'Old\n+\n             if Nkind (N) = N_Attribute_Reference\n               and then Attribute_Name (N) = Name_Old\n             then\n@@ -458,6 +462,7 @@ package body Exp_Prag is\n                Set_No_Initialization (Decl);\n \n                Prepend_To (Decls, Decl);\n+               Analyze (Decl);\n \n                --  Evaluate the prefix, generate:\n                --    Temp := <Pref>;\n@@ -481,20 +486,32 @@ package body Exp_Prag is\n                --  generated temporary.\n \n                Rewrite (N, New_Occurrence_Of (Temp, Loc));\n+\n+            --  Attribute 'Result\n+\n+            elsif Is_Attribute_Result (N) then\n+               Rewrite (N, Make_Identifier (Loc, Name_uResult));\n             end if;\n \n             return OK;\n-         end Expand_Old;\n+         end Expand_Attributes;\n \n-         procedure Expand_Olds is new Traverse_Proc (Expand_Old);\n+         procedure Expand_Attributes_In is\n+           new Traverse_Proc (Expand_Attributes);\n \n-      --  Start of processing for Expand_Old_In_Consequence\n+      --  Start of processing for Expand_Attributes_In_Consequence\n \n       begin\n-         --  Inspect the consequence and expand any attribute 'Old references\n-         --  found within.\n+         --  Inspect the consequence and expand any attribute 'Old and 'Result\n+         --  references found within.\n+\n+         Expand_Attributes_In (Conseq);\n \n-         Expand_Olds (Conseq);\n+         --  The consequence does not contain any attribute 'Old references\n+\n+         if No (Eval_Stmts) then\n+            return;\n+         end if;\n \n          --  Augment the machinery to trigger the evaluation of all prefixes\n          --  found in the step above. If Eval is empty, then this is the first\n@@ -525,7 +542,7 @@ package body Exp_Prag is\n                 Condition       => New_Occurrence_Of (Flag, Loc),\n                 Then_Statements => Eval_Stmts));\n          end if;\n-      end Expand_Old_In_Consequence;\n+      end Expand_Attributes_In_Consequence;\n \n       ---------------\n       -- Increment --\n@@ -565,11 +582,15 @@ package body Exp_Prag is\n       Conseq        : Node_Id;\n       Conseq_Checks : Node_Id   := Empty;\n       Count         : Entity_Id;\n+      Count_Decl    : Node_Id;\n       Error_Decls   : List_Id;\n       Flag          : Entity_Id;\n+      Flag_Decl     : Node_Id;\n+      If_Stmt       : Node_Id;\n       Msg_Str       : Entity_Id;\n       Multiple_PCs  : Boolean;\n       Old_Evals     : Node_Id   := Empty;\n+      Others_Decl   : Node_Id;\n       Others_Flag   : Entity_Id := Empty;\n       Post_Case     : Node_Id;\n \n@@ -596,12 +617,14 @@ package body Exp_Prag is\n       --    Count : Natural := 0;\n \n       Count := Make_Temporary (Loc, 'C');\n-\n-      Prepend_To (Decls,\n+      Count_Decl :=\n         Make_Object_Declaration (Loc,\n           Defining_Identifier => Count,\n           Object_Definition   => New_Occurrence_Of (Standard_Natural, Loc),\n-          Expression          => Make_Integer_Literal (Loc, 0)));\n+          Expression          => Make_Integer_Literal (Loc, 0));\n+\n+      Prepend_To (Decls, Count_Decl);\n+      Analyze (Count_Decl);\n \n       --  Create the base error message for multiple overlapping case guards\n \n@@ -634,7 +657,10 @@ package body Exp_Prag is\n \n          if Nkind (Case_Guard) = N_Others_Choice then\n             Others_Flag := Make_Temporary (Loc, 'F');\n-            Prepend_To (Decls, Declaration_Of (Others_Flag));\n+            Others_Decl := Declaration_Of (Others_Flag);\n+\n+            Prepend_To (Decls, Others_Decl);\n+            Analyze (Others_Decl);\n \n             --  Check possible overlap between a case guard and \"others\"\n \n@@ -647,9 +673,9 @@ package body Exp_Prag is\n             end if;\n \n             --  Inspect the consequence and perform special expansion of any\n-            --  attribute 'Old references found within.\n+            --  attribute 'Old and 'Result references found within.\n \n-            Expand_Old_In_Consequence\n+            Expand_Attributes_In_Consequence\n               (Decls  => Decls,\n                Evals  => Old_Evals,\n                Flag   => Others_Flag,\n@@ -669,20 +695,26 @@ package body Exp_Prag is\n             --  guard.\n \n             Flag := Make_Temporary (Loc, 'F');\n-            Prepend_To (Decls, Declaration_Of (Flag));\n+            Flag_Decl := Declaration_Of (Flag);\n+\n+            Prepend_To (Decls, Flag_Decl);\n+            Analyze (Flag_Decl);\n \n             --  The flag is set when the case guard is evaluated to True\n             --    if Case_Guard then\n             --       Flag  := True;\n             --       Count := Count + 1;\n             --    end if;\n \n-            Append_To (Decls,\n+            If_Stmt :=\n               Make_Implicit_If_Statement (CCs,\n                 Condition       => Relocate_Node (Case_Guard),\n                 Then_Statements => New_List (\n                   Set (Flag),\n-                  Increment (Count))));\n+                  Increment (Count)));\n+\n+            Append_To (Decls, If_Stmt);\n+            Analyze (If_Stmt);\n \n             --  Check whether this case guard overlaps with another one\n \n@@ -695,9 +727,9 @@ package body Exp_Prag is\n             end if;\n \n             --  Inspect the consequence and perform special expansion of any\n-            --  attribute 'Old references found within.\n+            --  attribute 'Old and 'Result references found within.\n \n-            Expand_Old_In_Consequence\n+            Expand_Attributes_In_Consequence\n               (Decls  => Decls,\n                Evals  => Old_Evals,\n                Flag   => Flag,\n@@ -783,11 +815,15 @@ package body Exp_Prag is\n       end if;\n \n       Append_To (Decls, CG_Checks);\n+      Analyze (CG_Checks);\n \n       --  Once all case guards are evaluated and checked, evaluate any prefixes\n       --  of attribute 'Old founds in the selected consequence.\n \n-      Append_To (Decls, Old_Evals);\n+      if Present (Old_Evals) then\n+         Append_To (Decls, Old_Evals);\n+         Analyze (Old_Evals);\n+      end if;\n \n       --  Raise Assertion_Error when the corresponding consequence of a case\n       --  guard that evaluated to True fails."}, {"sha": "06b90902b44f06aebf84c1e31138434e1901524f", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 296, "deletions": 191, "changes": 487, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -59,6 +59,7 @@ with Sem_Dist; use Sem_Dist;\n with Sem_Elab; use Sem_Elab;\n with Sem_Elim; use Sem_Elim;\n with Sem_Eval; use Sem_Eval;\n+with Sem_Prag; use Sem_Prag;\n with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n@@ -4561,7 +4562,7 @@ package body Sem_Attr is\n          ----------------------------\n \n          procedure Check_Use_In_Test_Case (Prag : Node_Id) is\n-            Ensures : constant Node_Id := Get_Ensures_From_CTC_Pragma (Prag);\n+            Ensures : constant Node_Id := Test_Case_Arg (Prag, Name_Ensures);\n             Expr    : Node_Id;\n \n          begin\n@@ -4984,269 +4985,373 @@ package body Sem_Attr is\n       ------------\n \n       when Attribute_Result => Result : declare\n-         Post_Id : Entity_Id;\n-         --  The entity of the _Postconditions procedure\n+         procedure Check_Placement_In_Check (Prag : Node_Id);\n+         --  Verify that attribute 'Result appears within pragma Check that\n+         --  emulates a postcondition.\n \n-         Prag : Node_Id;\n-         --  During pre-analysis, Prag is the enclosing pragma node if any\n-\n-         Subp_Id : Entity_Id;\n-         --  The entity of the enclosing subprogram\n+         procedure Check_Placement_In_Contract_Cases (Prag : Node_Id);\n+         --  Verify that attribute 'Result appears within a consequence of\n+         --  pragma Contract_Cases.\n \n-      begin\n-         --  Find the proper enclosing scope\n+         procedure Check_Placement_In_Test_Case (Prag : Node_Id);\n+         --  Verify that attribute 'Result appears within the Ensures argument\n+         --  of pragma Test_Case.\n \n-         Post_Id := Current_Scope;\n-         while Present (Post_Id) loop\n+         function Is_Within\n+           (Nod      : Node_Id;\n+            Encl_Nod : Node_Id) return Boolean;\n+         --  Subsidiary to Check_Placemenet_In_XXX_Case. Determine whether\n+         --  arbitrary node Nod is within enclosing node Encl_Nod.\n \n-            --  Skip generated loops\n+         ------------------------------\n+         -- Check_Placement_In_Check --\n+         ------------------------------\n \n-            if Ekind (Post_Id) = E_Loop then\n-               Post_Id := Scope (Post_Id);\n+         procedure Check_Placement_In_Check (Prag : Node_Id) is\n+            Args : constant List_Id := Pragma_Argument_Associations (Prag);\n+            Nam  : constant Name_Id := Chars (Get_Pragma_Arg (First (Args)));\n \n-            --  Skip the special _Parent scope generated to capture references\n-            --  to formals during the process of subprogram inlining.\n+         begin\n+            --  The \"Name\" argument of pragma Check denotes a postcondition\n \n-            elsif Ekind (Post_Id) = E_Function\n-              and then Chars (Post_Id) = Name_uParent\n+            if Nam_In (Nam, Name_Post,\n+                            Name_Postcondition,\n+                            Name_Refined_Post)\n             then\n-               Post_Id := Scope (Post_Id);\n+               null;\n \n-            --  Otherwise this must be _Postconditions\n+            --  Otherwise the placement of attribute 'Result is illegal\n \n             else\n-               exit;\n+               Error_Attr\n+                 (\"% attribute can only appear in postcondition of function\",\n+                  P);\n             end if;\n-         end loop;\n+         end Check_Placement_In_Check;\n \n-         Subp_Id := Scope (Post_Id);\n+         ---------------------------------------\n+         -- Check_Placement_In_Contract_Cases --\n+         ---------------------------------------\n \n-         --  If the enclosing subprogram is always inlined, the enclosing\n-         --  postcondition will not be propagated to the expanded call.\n+         procedure Check_Placement_In_Contract_Cases (Prag : Node_Id) is\n+            Args  : constant List_Id := Pragma_Argument_Associations (Prag);\n+            Cases : constant Node_Id := Get_Pragma_Arg (First (Args));\n+            CCase : Node_Id;\n \n-         if not In_Spec_Expression\n-           and then Has_Pragma_Inline_Always (Subp_Id)\n-           and then Warn_On_Redundant_Constructs\n-         then\n-            Error_Msg_N\n-              (\"postconditions on inlined functions not enforced?r?\", N);\n-         end if;\n+         begin\n+            if Present (Component_Associations (Cases)) then\n+               CCase := First (Component_Associations (Cases));\n+               while Present (CCase) loop\n+\n+                  --  Guard against a malformed contract case. Detect whether\n+                  --  attribute 'Result appears within the consequence of the\n+                  --  current contract case.\n+\n+                  if Nkind (CCase) = N_Component_Association\n+                    and then Is_Within (N, Expression (CCase))\n+                  then\n+                     return;\n+                  end if;\n \n-         --  If we are in the scope of a function and in Spec_Expression mode,\n-         --  this is likely the prescan of the postcondition (or contract case,\n-         --  or test case) pragma, and we just set the proper type. If there is\n-         --  an error it will be caught when the real Analyze call is done.\n+                  Next (CCase);\n+               end loop;\n+            end if;\n \n-         if Ekind (Post_Id) = E_Function and then In_Spec_Expression then\n+            --  Otherwise pragma Contract_Cases is either malformed in some\n+            --  way or attribute 'Result does not appear within a consequence\n+            --  expression.\n \n-            --  Check OK prefix\n+            Error_Attr (\"% attribute misplaced inside contract cases\", P);\n+         end Check_Placement_In_Contract_Cases;\n \n-            if Chars (Post_Id) /= Chars (P) then\n-               Error_Msg_Name_1 := Name_Result;\n-               Error_Msg_NE\n-                 (\"incorrect prefix for % attribute, expected &\", P, Post_Id);\n-               Error_Attr;\n+         ----------------------------------\n+         -- Check_Placement_In_Test_Case --\n+         ----------------------------------\n+\n+         procedure Check_Placement_In_Test_Case (Prag : Node_Id) is\n+         begin\n+            --  Detect whether attribute 'Result appears within the \"Ensures\"\n+            --  expression of pragma Test_Case.\n+\n+            if not Is_Within (N, Test_Case_Arg (Prag, Name_Ensures)) then\n+               Error_Attr (\"% attribute misplaced inside test case\", P);\n             end if;\n+         end Check_Placement_In_Test_Case;\n \n-            --  Check in postcondition, Test_Case or Contract_Cases of function\n+         ---------------\n+         -- Is_Within --\n+         ---------------\n \n-            Prag := N;\n-            while Present (Prag)\n-               and then not Nkind_In (Prag, N_Pragma,\n-                                            N_Function_Specification,\n-                                            N_Aspect_Specification,\n-                                            N_Subprogram_Body)\n-            loop\n-               Prag := Parent (Prag);\n-            end loop;\n+         function Is_Within\n+           (Nod      : Node_Id;\n+            Encl_Nod : Node_Id) return Boolean\n+         is\n+            Par : Node_Id;\n \n-            --  In ASIS mode, the aspect itself is analyzed, in addition to the\n-            --  corresponding pragma. Do not issue errors when analyzing the\n-            --  aspect.\n+         begin\n+            Par := Nod;\n+            while Present (Par) loop\n+               if Par = Encl_Nod then\n+                  return True;\n \n-            if Nkind (Prag) = N_Aspect_Specification then\n-               null;\n+               --  Prevent the search from going too far\n \n-            --  Must have a pragma\n+               elsif Is_Body_Or_Package_Declaration (Par) then\n+                  exit;\n+               end if;\n \n-            elsif Nkind (Prag) /= N_Pragma then\n-               Error_Attr\n-                 (\"% attribute can only appear in postcondition of function\",\n-                  P);\n+               Par := Parent (Par);\n+            end loop;\n \n-            --  Processing depends on which pragma we have\n+            return False;\n+         end Is_Within;\n \n-            else\n-               case Get_Pragma_Id (Prag) is\n-                  when Pragma_Test_Case =>\n-                     declare\n-                        Arg_Ens : constant Node_Id :=\n-                                    Get_Ensures_From_CTC_Pragma (Prag);\n-                        Arg     : Node_Id;\n+         --  Local variables\n \n-                     begin\n-                        Arg := N;\n-                        while Arg /= Prag and then Arg /= Arg_Ens loop\n-                           Arg := Parent (Arg);\n-                        end loop;\n+         In_Post   : Boolean := False;\n+         Prag      : Node_Id;\n+         Prag_Id   : Pragma_Id;\n+         Pref_Id   : Entity_Id;\n+         Spec_Id   : Entity_Id;\n+         Subp_Decl : Node_Id;\n+         Subp_Id   : Entity_Id;\n+         Subp_Spec : Node_Id;\n \n-                        if Arg /= Arg_Ens then\n-                           Error_Attr\n-                             (\"% attribute misplaced inside test case\", P);\n-                        end if;\n-                     end;\n+      --  Start of processing for Result\n \n-                  when Pragma_Contract_Cases =>\n-                     declare\n-                        Aggr : constant Node_Id :=\n-                          Expression (First\n-                                        (Pragma_Argument_Associations (Prag)));\n-                        Arg  : Node_Id;\n+      begin\n+         --  The attribute reference is a primary. If any expressions follow,\n+         --  then the attribute reference is an indexable object. Transform the\n+         --  attribute into an indexed component and analyze it.\n \n-                     begin\n-                        Arg := N;\n-                        while Arg /= Prag\n-                          and then Parent (Parent (Arg)) /= Aggr\n-                        loop\n-                           Arg := Parent (Arg);\n-                        end loop;\n+         if Present (E1) then\n+            Rewrite (N,\n+              Make_Indexed_Component (Loc,\n+                Prefix      =>\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix         => Relocate_Node (P),\n+                    Attribute_Name => Name_Result),\n+                Expressions => Expressions (N)));\n+            Analyze (N);\n+            return;\n+         end if;\n \n-                        --  At this point, Parent (Arg) should be a component\n-                        --  association. Attribute Result is only allowed in\n-                        --  the expression part of this association.\n+         --  Traverse the parent chain to find the aspect or pragma where\n+         --  attribute 'Result resides.\n \n-                        if Nkind (Parent (Arg)) /= N_Component_Association\n-                          or else Arg /= Expression (Parent (Arg))\n-                        then\n-                           Error_Attr\n-                             (\"% attribute misplaced inside contract cases\",\n-                              P);\n-                        end if;\n-                     end;\n+         Prag := N;\n+         while Present (Prag) loop\n+            if Nkind_In (Prag, N_Aspect_Specification, N_Pragma) then\n+               exit;\n \n-                  when Pragma_Postcondition | Pragma_Refined_Post =>\n-                     null;\n+            --  Prevent the search from going too far\n \n-                     when others =>\n-                        Error_Attr\n-                          (\"% attribute can only appear in postcondition \"\n-                           & \"of function\", P);\n-               end case;\n+            elsif Is_Body_Or_Package_Declaration (Prag) then\n+               exit;\n             end if;\n \n-            --  The attribute reference is a primary. If expressions follow,\n-            --  the attribute reference is really an indexable object, so\n-            --  rewrite and analyze as an indexed component.\n+            Prag := Parent (Prag);\n+         end loop;\n \n-            if Present (E1) then\n-               Rewrite (N,\n-                 Make_Indexed_Component (Loc,\n-                   Prefix      =>\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix         => Relocate_Node (Prefix (N)),\n-                       Attribute_Name => Name_Result),\n-                   Expressions => Expressions (N)));\n-               Analyze (N);\n+         --  Do not emit an error when preanalyzing an aspect for ASIS. If the\n+         --  placement of attribute 'Result is illegal, the error is reported\n+         --  when analyzing the corresponding pragma.\n+\n+         if ASIS_Mode and then Nkind (Prag) = N_Aspect_Specification then\n+            null;\n+\n+         --  Attribute 'Result is allowed to appear only in postcondition-like\n+         --  pragmas.\n+\n+         elsif Nkind (Prag) = N_Pragma then\n+            Prag_Id := Get_Pragma_Id (Prag);\n+\n+            if Prag_Id = Pragma_Check then\n+               Check_Placement_In_Check (Prag);\n+\n+            elsif Prag_Id = Pragma_Contract_Cases then\n+               Check_Placement_In_Contract_Cases (Prag);\n+\n+            elsif Prag_Id = Pragma_Postcondition\n+              or else Prag_Id = Pragma_Refined_Post\n+            then\n+               null;\n+\n+            elsif Prag_Id = Pragma_Test_Case then\n+               Check_Placement_In_Test_Case (Prag);\n+\n+            else\n+               Error_Attr\n+                 (\"% attribute can only appear in postcondition of function\",\n+                  P);\n                return;\n             end if;\n \n-            Set_Etype (N, Etype (Post_Id));\n+         --  Otherwise the placement of the attribute is illegal\n \n-            --  If several functions with that name are visible, the intended\n-            --  one is the current scope.\n+         else\n+            Error_Attr\n+              (\"% attribute can only appear in postcondition of function\", P);\n+            return;\n+         end if;\n \n-            if Is_Overloaded (P) then\n-               Set_Entity (P, Post_Id);\n-               Set_Is_Overloaded (P, False);\n-            end if;\n+         --  Attribute 'Result appears within a postcondition-like pragma. Find\n+         --  the related subprogram subject to the pragma.\n \n-         --  Check the legality of attribute 'Result when it appears inside\n-         --  pragma Refined_Post. These specialized checks are required only\n-         --  when code generation is disabled. In the general case pragma\n-         --  Refined_Post is transformed into pragma Check by Process_PPCs\n-         --  which in turn is relocated to procedure _Postconditions. From\n-         --  then on the legality of 'Result is determined as usual.\n+         if Nkind (Prag) = N_Aspect_Specification then\n+            Subp_Decl := Parent (Prag);\n+         else\n+            Subp_Decl := Find_Related_Subprogram_Or_Body (Prag);\n+         end if;\n \n-         elsif not Expander_Active and then In_Refined_Post then\n+         --  The pragma where attribute 'Result appears is associated with a\n+         --  subprogram declaration or a body.\n \n-            --  Routine _Postconditions has not been generated yet, the nearest\n-            --  enclosing subprogram is denoted by the current scope.\n+         if Nkind_In (Subp_Decl, N_Abstract_Subprogram_Declaration,\n+                                 N_Entry_Declaration,\n+                                 N_Generic_Subprogram_Declaration,\n+                                 N_Subprogram_Body,\n+                                 N_Subprogram_Body_Stub,\n+                                 N_Subprogram_Declaration)\n+         then\n+            Subp_Id := Defining_Entity (Subp_Decl);\n \n-            if Ekind (Post_Id) /= E_Procedure\n-              or else Chars (Post_Id) /= Name_uPostconditions\n-            then\n-               Subp_Id := Current_Scope;\n+            --  Attribute 'Result is part of the _Postconditions procedure of\n+            --  the related subprogram. Retrieve the related subprogram.\n+\n+            if Chars (Subp_Id) = Name_uPostconditions then\n+               In_Post   := True;\n+               Subp_Decl := Parent (Subp_Decl);\n+               Subp_Id   := Scope (Subp_Id);\n             end if;\n \n-            --  The prefix denotes the nearest enclosing function\n+            --  Retrieve the entity of the spec (if any)\n \n-            if Is_Entity_Name (P)\n-              and then Ekind (Entity (P)) = E_Function\n-              and then Entity (P) = Subp_Id\n+            if Nkind (Subp_Decl) = N_Subprogram_Body\n+              and then Present (Corresponding_Spec (Subp_Decl))\n             then\n-               null;\n+               Spec_Id := Corresponding_Spec (Subp_Decl);\n \n-            --  Otherwise the use of 'Result is illegal\n+            elsif Nkind (Subp_Decl) = N_Subprogram_Body_Stub\n+              and then Present (Corresponding_Spec_Of_Stub (Subp_Decl))\n+            then\n+               Spec_Id := Corresponding_Spec_Of_Stub (Subp_Decl);\n \n             else\n-               Error_Msg_Name_2 := Chars (Subp_Id);\n-               Error_Attr (\"incorrect prefix for % attribute, expected %\", P);\n+               Spec_Id := Subp_Id;\n             end if;\n \n-            Set_Etype (N, Etype (Subp_Id));\n+            --  When the subprogram is always inlined, the postcondition will\n+            --  not be propagated to the expanded body.\n \n-         --  Body case, where we must be inside a generated _Postconditions\n-         --  procedure, and the prefix must be on the scope stack, or else the\n-         --  attribute use is definitely misplaced. The postcondition itself\n-         --  may have generated transient scopes, and is not necessarily the\n-         --  current one.\n+            if Warn_On_Redundant_Constructs\n+              and then Has_Pragma_Inline_Always (Spec_Id)\n+            then\n+               Error_Msg_N\n+                 (\"postconditions on inlined functions not enforced?r?\", P);\n+            end if;\n \n-         else\n-            while Present (Post_Id)\n-              and then Post_Id /= Standard_Standard\n-            loop\n-               if Chars (Post_Id) = Name_uPostconditions then\n-                  exit;\n-               else\n-                  Post_Id := Scope (Post_Id);\n+            --  Ensure that the prefix of attribute 'Result denotes the related\n+            --  subprogram.\n+\n+            if Is_Entity_Name (P) then\n+               Pref_Id := Entity (P);\n+\n+               --  When a subprogram with contract assertions is imported, it\n+               --  is encapsulated in a wrapper. In this case the scope of the\n+               --  wrapper denotes the original imported subprogram.\n+\n+               if Is_Imported (Pref_Id) then\n+                  Pref_Id := Scope (Pref_Id);\n                end if;\n-            end loop;\n \n-            Subp_Id := Scope (Post_Id);\n+               if Ekind_In (Pref_Id, E_Function, E_Generic_Function) then\n \n-            if Chars (Post_Id) = Name_uPostconditions\n-              and then Ekind (Subp_Id) = E_Function\n-            then\n-               --  Check OK prefix\n+                  --  The prefix of attribute 'Result denotes the entity of\n+                  --  some other unrelated function.\n \n-               if Nkind_In (P, N_Identifier, N_Operator_Symbol)\n-                 and then Chars (P) = Chars (Subp_Id)\n-               then\n-                  null;\n+                  if Pref_Id /= Spec_Id then\n+                     Subp_Spec := Parent (Spec_Id);\n \n-               --  Within an instance, the prefix designates the local renaming\n-               --  of the original generic.\n+                     --  Attribute 'Result appears in a postcondition of a\n+                     --  generic function that acts as a compilation unit:\n \n-               elsif Is_Entity_Name (P)\n-                 and then Ekind (Entity (P)) = E_Function\n-                 and then Present (Alias (Entity (P)))\n-                 and then Chars (Alias (Entity (P))) = Chars (Subp_Id)\n-               then\n-                  null;\n+                     --    generic\n+                     --    function Gen_Func return ...\n+                     --      with Post => Gen_Func'Result ...;\n+\n+                     --  When the function is instantiated, the Chars field of\n+                     --  attribute 'Result's prefix still denotes the generic\n+                     --  function. Note that any preemptive transformation is\n+                     --  impossible without a proper analysis. The structure of\n+                     --  the anonymous wrapper package is as follows:\n+\n+                     --    package Anon_Gen_Pack is\n+                     --       <subtypes and renamings>\n+                     --       function Subp_Decl return ...;\n+                     --       pragma Postcondition (Gen_Func'Result ...);\n+                     --       function Gen_Func ... renames Subp_Decl;\n+                     --    end Anon_Gen_Pack;\n+\n+                     --  Recognize this case and do not flag it as illegal\n+\n+                     if Nkind (Subp_Spec) = N_Function_Specification\n+                       and then Present (Generic_Parent (Subp_Spec))\n+                     then\n+                        if Generic_Parent (Subp_Spec) = Pref_Id then\n+                           null;\n+\n+                        elsif Ekind (Pref_Id) = E_Function\n+                          and then Present (Alias (Pref_Id))\n+                          and then Alias (Pref_Id) = Spec_Id\n+                        then\n+                           null;\n+\n+                        else\n+                           Error_Msg_Name_2 := Chars (Spec_Id);\n+                           Error_Attr\n+                             (\"incorrect prefix for % attribute, expected %\",\n+                              P);\n+                        end if;\n+\n+                     --  Otherwise the context is not a function instantiation\n+                     --  and the prefix is illegal\n+\n+                     else\n+                        Error_Msg_Name_2 := Chars (Spec_Id);\n+                        Error_Attr\n+                          (\"incorrect prefix for % attribute, expected %\", P);\n+                     end if;\n+                  end if;\n+\n+               --  Otherwise the attribute's prefix denotes some other form of\n+               --  a non-function subprogram.\n \n                else\n-                  Error_Msg_Name_2 := Chars (Subp_Id);\n                   Error_Attr\n-                    (\"incorrect prefix for % attribute, expected %\", P);\n+                    (\"% attribute can only appear in postcondition of \"\n+                     & \"function\", P);\n                end if;\n \n-               Rewrite (N, Make_Identifier (Sloc (N), Name_uResult));\n+            --  Otherwise the prefix is illegal\n+\n+            else\n+               Error_Msg_Name_2 := Chars (Spec_Id);\n+               Error_Attr (\"incorrect prefix for % attribute, expected %\", P);\n+            end if;\n+\n+            --  Attribute 'Result is part of the _Postconditions procedure of\n+            --  the related subprogram. Rewrite the attribute as a reference to\n+            --  the _Result formal parameter of _Postconditions.\n+\n+            if In_Post then\n+               Rewrite (N, Make_Identifier (Loc, Name_uResult));\n                Analyze_And_Resolve (N, Etype (Subp_Id));\n \n+            --  Otherwise decorate the attribute\n+\n             else\n-               Error_Attr\n-                 (\"% attribute can only appear in postcondition of function\",\n-                  P);\n+               Set_Etype (N, Etype (Subp_Id));\n             end if;\n          end if;\n       end Result;"}, {"sha": "3289f14ef82d234006ec2478379658bf293d6a2a", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 54, "deletions": 43, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -246,13 +246,6 @@ package body Sem_Ch10 is\n    ------------------------------\n \n    procedure Analyze_Compilation_Unit (N : Node_Id) is\n-      Unit_Node     : constant Node_Id := Unit (N);\n-      Lib_Unit      : Node_Id          := Library_Unit (N);\n-      Spec_Id       : Entity_Id;\n-      Main_Cunit    : constant Node_Id := Cunit (Main_Unit);\n-      Par_Spec_Name : Unit_Name_Type;\n-      Unum          : Unit_Number_Type;\n-\n       procedure Check_Redundant_Withs\n         (Context_Items      : List_Id;\n          Spec_Context_Items : List_Id := No_List);\n@@ -602,6 +595,15 @@ package body Sem_Ch10 is\n          end loop;\n       end Check_Redundant_Withs;\n \n+      --  Local variables\n+\n+      Main_Cunit    : constant Node_Id := Cunit (Main_Unit);\n+      Unit_Node     : constant Node_Id := Unit (N);\n+      Lib_Unit      : Node_Id          := Library_Unit (N);\n+      Par_Spec_Name : Unit_Name_Type;\n+      Spec_Id       : Entity_Id;\n+      Unum          : Unit_Number_Type;\n+\n    --  Start of processing for Analyze_Compilation_Unit\n \n    begin\n@@ -930,6 +932,15 @@ package body Sem_Ch10 is\n          end;\n       end if;\n \n+      --  Analyze the contract of a [generic] subprogram that acts as a\n+      --  compilation unit after all compilation pragmas have been analyzed.\n+\n+      if Nkind_In (Unit_Node, N_Generic_Subprogram_Declaration,\n+                              N_Subprogram_Declaration)\n+      then\n+         Analyze_Subprogram_Contract (Defining_Entity (Unit_Node));\n+      end if;\n+\n       --  Generate distribution stubs if requested and no error\n \n       if N = Main_Cunit\n@@ -1920,39 +1931,6 @@ package body Sem_Ch10 is\n       end if;\n    end Analyze_Protected_Body_Stub;\n \n-   -------------------------------------------\n-   -- Analyze_Subprogram_Body_Stub_Contract --\n-   -------------------------------------------\n-\n-   procedure Analyze_Subprogram_Body_Stub_Contract (Stub_Id : Entity_Id) is\n-      Stub_Decl : constant Node_Id   := Parent (Parent (Stub_Id));\n-      Spec_Id   : constant Entity_Id := Corresponding_Spec_Of_Stub (Stub_Decl);\n-\n-   begin\n-      --  A subprogram body stub may act as its own spec or as the completion\n-      --  of a previous declaration. Depending on the context, the contract of\n-      --  the stub may contain two sets of pragmas.\n-\n-      --  The stub is a completion, the applicable pragmas are:\n-      --    Contract_Cases\n-      --    Depends\n-      --    Global\n-      --    Postcondition\n-      --    Precondition\n-      --    Test_Case\n-\n-      if Present (Spec_Id) then\n-         Analyze_Subprogram_Body_Contract (Stub_Id);\n-\n-      --  The stub acts as its own spec, the applicable pragmas are:\n-      --    Refined_Depends\n-      --    Refined_Global\n-\n-      else\n-         Analyze_Subprogram_Contract (Stub_Id);\n-      end if;\n-   end Analyze_Subprogram_Body_Stub_Contract;\n-\n    ----------------------------------\n    -- Analyze_Subprogram_Body_Stub --\n    ----------------------------------\n@@ -2005,6 +1983,39 @@ package body Sem_Ch10 is\n       Restore_Opt_Config_Switches (Opts);\n    end Analyze_Subprogram_Body_Stub;\n \n+   -------------------------------------------\n+   -- Analyze_Subprogram_Body_Stub_Contract --\n+   -------------------------------------------\n+\n+   procedure Analyze_Subprogram_Body_Stub_Contract (Stub_Id : Entity_Id) is\n+      Stub_Decl : constant Node_Id   := Parent (Parent (Stub_Id));\n+      Spec_Id   : constant Entity_Id := Corresponding_Spec_Of_Stub (Stub_Decl);\n+\n+   begin\n+      --  A subprogram body stub may act as its own spec or as the completion\n+      --  of a previous declaration. Depending on the context, the contract of\n+      --  the stub may contain two sets of pragmas.\n+\n+      --  The stub is a completion, the applicable pragmas are:\n+      --    Refined_Depends\n+      --    Refined_Global\n+\n+      if Present (Spec_Id) then\n+         Analyze_Subprogram_Body_Contract (Stub_Id);\n+\n+      --  The stub acts as its own spec, the applicable pragmas are:\n+      --    Contract_Cases\n+      --    Depends\n+      --    Global\n+      --    Postcondition\n+      --    Precondition\n+      --    Test_Case\n+\n+      else\n+         Analyze_Subprogram_Contract (Stub_Id);\n+      end if;\n+   end Analyze_Subprogram_Body_Stub_Contract;\n+\n    ---------------------\n    -- Analyze_Subunit --\n    ---------------------\n@@ -2831,13 +2842,13 @@ package body Sem_Ch10 is\n          when None =>\n             null;\n \n-            --  If with'ed unit had a detected fatal error, propagate it\n+         --  If with'ed unit had a detected fatal error, propagate it\n \n          when Error_Detected =>\n             Set_Fatal_Error (Current_Sem_Unit, Error_Detected);\n \n-            --  If with'ed unit had an ignored error, then propagate it\n-            --  but do not overide an existring setting.\n+         --  If with'ed unit had an ignored error, then propagate it but do not\n+         --  overide an existring setting.\n \n          when Error_Ignored =>\n             if Fatal_Error (Current_Sem_Unit) = None then"}, {"sha": "424c118bbb95b30fb20f3231a093bb5e7a786b2d", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 127, "deletions": 59, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -59,7 +59,6 @@ with Sem_Disp; use Sem_Disp;\n with Sem_Elab; use Sem_Elab;\n with Sem_Elim; use Sem_Elim;\n with Sem_Eval; use Sem_Eval;\n-with Sem_Prag; use Sem_Prag;\n with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n@@ -3073,9 +3072,8 @@ package body Sem_Ch12 is\n       Start_Generic;\n \n       Enter_Name (Id);\n-      Set_Ekind    (Id, E_Generic_Package);\n-      Set_Etype    (Id, Standard_Void_Type);\n-      Set_Contract (Id, Make_Contract (Sloc (Id)));\n+      Set_Ekind  (Id, E_Generic_Package);\n+      Set_Etype  (Id, Standard_Void_Type);\n \n       --  A generic package declared within a Ghost region is rendered Ghost\n       --  (SPARK RM 6.9(2)).\n@@ -3170,12 +3168,12 @@ package body Sem_Ch12 is\n    --------------------------------------------\n \n    procedure Analyze_Generic_Subprogram_Declaration (N : Node_Id) is\n-      Spec        : Node_Id;\n-      Id          : Entity_Id;\n       Formals     : List_Id;\n+      Id          : Entity_Id;\n       New_N       : Node_Id;\n       Result_Type : Entity_Id;\n       Save_Parent : Node_Id;\n+      Spec        : Node_Id;\n       Typ         : Entity_Id;\n \n    begin\n@@ -3206,7 +3204,6 @@ package body Sem_Ch12 is\n       Spec := Specification (N);\n       Id := Defining_Entity (Spec);\n       Generate_Definition (Id);\n-      Set_Contract (Id, Make_Contract (Sloc (Id)));\n \n       if Nkind (Id) = N_Defining_Operator_Symbol then\n          Error_Msg_N\n@@ -3311,16 +3308,13 @@ package body Sem_Ch12 is\n       Set_Categorization_From_Pragmas (N);\n       Validate_Categorization_Dependency (N, Id);\n \n-      Save_Global_References (Original_Node (N));\n-\n-      --  For ASIS purposes, convert any postcondition, precondition pragmas\n-      --  into aspects, if N is not a compilation unit by itself, in order to\n-      --  enable the analysis of expressions inside the corresponding PPC\n-      --  pragmas.\n+      --  Capture all global references that occur within the profile of the\n+      --  generic subprogram. Aspects are not part of this processing because\n+      --  they must be delayed. If processed now, Save_Global_References will\n+      --  destroy the Associated_Node links and prevent the capture of global\n+      --  references when the contract of the generic subprogram is analyzed.\n \n-      if ASIS_Mode and then Is_List_Member (N) then\n-         Make_Aspect_For_PPC_In_Gen_Sub_Decl (N);\n-      end if;\n+      Save_Global_References (Original_Node (N));\n \n       End_Generic;\n       End_Scope;\n@@ -4626,6 +4620,10 @@ package body Sem_Ch12 is\n       --  aspects that appear in the generic. This renaming declaration is\n       --  inserted after the instance declaration which it renames.\n \n+      procedure Instantiate_Contract (Subp_Id : Entity_Id);\n+      --  Instantiate all source pragmas found in the contract of subprogram\n+      --  Subp_Id. The instantiated pragmas are added to list Renaming_List.\n+\n       ------------------------------------\n       -- Analyze_Instance_And_Renamings --\n       ------------------------------------\n@@ -4658,11 +4656,12 @@ package body Sem_Ch12 is\n                             Suffix_Index => Source_Offset (Sloc (Def_Ent))));\n          end if;\n \n-         Pack_Decl := Make_Package_Declaration (Loc,\n-           Specification => Make_Package_Specification (Loc,\n-             Defining_Unit_Name   => Pack_Id,\n-             Visible_Declarations => Renaming_List,\n-             End_Label            => Empty));\n+         Pack_Decl :=\n+           Make_Package_Declaration (Loc,\n+             Specification => Make_Package_Specification (Loc,\n+               Defining_Unit_Name   => Pack_Id,\n+               Visible_Declarations => Renaming_List,\n+               End_Label            => Empty));\n \n          Set_Instance_Spec (N, Pack_Decl);\n          Set_Is_Generic_Instance (Pack_Id);\n@@ -4826,6 +4825,62 @@ package body Sem_Ch12 is\n          end if;\n       end Build_Subprogram_Renaming;\n \n+      --------------------------\n+      -- Instantiate_Contract --\n+      --------------------------\n+\n+      procedure Instantiate_Contract (Subp_Id : Entity_Id) is\n+         procedure Instantiate_Pragmas (First_Prag : Node_Id);\n+         --  Instantiate all contract-related source pragmas found in the list\n+         --  starting with pragma First_Prag. Each instantiated pragma is added\n+         --  to list Renaming_List.\n+\n+         -------------------------\n+         -- Instantiate_Pragmas --\n+         -------------------------\n+\n+         procedure Instantiate_Pragmas (First_Prag : Node_Id) is\n+            Inst_Prag : Node_Id;\n+            Prag      : Node_Id;\n+\n+         begin\n+            Prag := First_Prag;\n+            while Present (Prag) loop\n+               if Comes_From_Source (Prag)\n+                 and then Nam_In (Pragma_Name (Prag), Name_Contract_Cases,\n+                                                      Name_Depends,\n+                                                      Name_Extensions_Visible,\n+                                                      Name_Global,\n+                                                      Name_Postcondition,\n+                                                      Name_Precondition,\n+                                                      Name_Test_Case)\n+               then\n+                  Inst_Prag :=\n+                    Copy_Generic_Node\n+                      (Original_Node (Prag), Empty, Instantiating => True);\n+\n+                  Set_Analyzed (Inst_Prag, False);\n+                  Append_To (Renaming_List, Inst_Prag);\n+               end if;\n+\n+               Prag := Next_Pragma (Prag);\n+            end loop;\n+         end Instantiate_Pragmas;\n+\n+         --  Local variables\n+\n+         Items : constant Node_Id := Contract (Subp_Id);\n+\n+      --  Start of processing for Instantiate_Contract\n+\n+      begin\n+         if Present (Items) then\n+            Instantiate_Pragmas (Pre_Post_Conditions (Items));\n+            Instantiate_Pragmas (Contract_Test_Cases (Items));\n+            Instantiate_Pragmas (Classifications     (Items));\n+         end if;\n+      end Instantiate_Contract;\n+\n       --  Local variables\n \n       Save_IPSM : constant Boolean := Ignore_Pragma_SPARK_Mode;\n@@ -4991,7 +5046,9 @@ package body Sem_Ch12 is\n          end if;\n \n          Append (Act_Decl, Renaming_List);\n+         Instantiate_Contract (Gen_Unit);\n          Build_Subprogram_Renaming;\n+\n          Analyze_Instance_And_Renamings;\n \n          --  If the generic is marked Import (Intrinsic), then so is the\n@@ -5022,9 +5079,6 @@ package body Sem_Ch12 is\n          end if;\n \n          Generate_Definition (Act_Decl_Id);\n-         --  Set_Contract (Anon_Id, Make_Contract (Sloc (Anon_Id)));\n-         --  ??? needed?\n-         Set_Contract (Act_Decl_Id, Make_Contract (Sloc (Act_Decl_Id)));\n \n          --  Inherit all inlining-related flags which apply to the generic in\n          --  the subprogram and its declaration.\n@@ -10743,29 +10797,29 @@ package body Sem_Ch12 is\n      (Body_Info     : Pending_Body_Info;\n       Body_Optional : Boolean := False)\n    is\n-      Act_Decl      : constant Node_Id    := Body_Info.Act_Decl;\n-      Inst_Node     : constant Node_Id    := Body_Info.Inst_Node;\n-      Loc           : constant Source_Ptr := Sloc (Inst_Node);\n-      Gen_Id        : constant Node_Id    := Name (Inst_Node);\n-      Gen_Unit      : constant Entity_Id  := Get_Generic_Entity (Inst_Node);\n-      Gen_Decl      : constant Node_Id    := Unit_Declaration_Node (Gen_Unit);\n-      Anon_Id       : constant Entity_Id  :=\n-                        Defining_Unit_Name (Specification (Act_Decl));\n-      Pack_Id       : constant Entity_Id  :=\n-                        Defining_Unit_Name (Parent (Act_Decl));\n-      Gen_Body      : Node_Id;\n-      Gen_Body_Id   : Node_Id;\n-      Act_Body      : Node_Id;\n-      Pack_Body     : Node_Id;\n-      Ret_Expr      : Node_Id;\n-\n-      Parent_Installed : Boolean := False;\n+      Act_Decl    : constant Node_Id    := Body_Info.Act_Decl;\n+      Inst_Node   : constant Node_Id    := Body_Info.Inst_Node;\n+      Loc         : constant Source_Ptr := Sloc (Inst_Node);\n+      Gen_Id      : constant Node_Id    := Name (Inst_Node);\n+      Gen_Unit    : constant Entity_Id  := Get_Generic_Entity (Inst_Node);\n+      Gen_Decl    : constant Node_Id    := Unit_Declaration_Node (Gen_Unit);\n+      Anon_Id     : constant Entity_Id  :=\n+                      Defining_Unit_Name (Specification (Act_Decl));\n+      Pack_Id     : constant Entity_Id  :=\n+                      Defining_Unit_Name (Parent (Act_Decl));\n \n       Saved_Style_Check : constant Boolean        := Style_Check;\n       Saved_Warnings    : constant Warning_Record := Save_Warnings;\n \n-      Par_Ent : Entity_Id := Empty;\n-      Par_Vis : Boolean   := False;\n+      Act_Body    : Node_Id;\n+      Gen_Body    : Node_Id;\n+      Gen_Body_Id : Node_Id;\n+      Pack_Body   : Node_Id;\n+      Par_Ent     : Entity_Id := Empty;\n+      Par_Vis     : Boolean   := False;\n+      Ret_Expr    : Node_Id;\n+\n+      Parent_Installed : Boolean := False;\n \n    begin\n       Gen_Body_Id := Corresponding_Body (Gen_Decl);\n@@ -14314,23 +14368,14 @@ package body Sem_Ch12 is\n             end;\n          end if;\n \n-         --  If a node has aspects, references within their expressions must\n-         --  be saved separately, given they are not directly in the tree.\n-\n-         if Has_Aspects (N) then\n-            declare\n-               Aspect : Node_Id;\n-\n-            begin\n-               Aspect := First (Aspect_Specifications (N));\n-               while Present (Aspect) loop\n-                  if Present (Expression (Aspect)) then\n-                     Save_Global_References (Expression (Aspect));\n-                  end if;\n+         --  Save all global references found within the aspects of the related\n+         --  node. This is not done for generic subprograms because the aspects\n+         --  must be delayed and analyzed at the end of the declarative part.\n+         --  Only then can global references be saved. This action is performed\n+         --  by the analysis of the generic subprogram contract.\n \n-                  Next (Aspect);\n-               end loop;\n-            end;\n+         if Nkind (N) /= N_Generic_Subprogram_Declaration then\n+            Save_Global_References_In_Aspects (N);\n          end if;\n       end Save_References;\n \n@@ -14352,6 +14397,29 @@ package body Sem_Ch12 is\n       Save_References (N);\n    end Save_Global_References;\n \n+   ---------------------------------------\n+   -- Save_Global_References_In_Aspects --\n+   ---------------------------------------\n+\n+   procedure Save_Global_References_In_Aspects (N : Node_Id) is\n+      Asp  : Node_Id;\n+      Expr : Node_Id;\n+\n+   begin\n+      if Permits_Aspect_Specifications (N) and then Has_Aspects (N) then\n+         Asp := First (Aspect_Specifications (N));\n+         while Present (Asp) loop\n+            Expr := Expression (Asp);\n+\n+            if Present (Expr) then\n+               Save_Global_References (Expr);\n+            end if;\n+\n+            Next (Asp);\n+         end loop;\n+      end if;\n+   end Save_Global_References_In_Aspects;\n+\n    --------------------------------------\n    -- Set_Copied_Sloc_For_Inlined_Body --\n    --------------------------------------"}, {"sha": "52e5f5ce6c8ef6716a36a870e5d99851a63f83c6", "filename": "gcc/ada/sem_ch12.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_ch12.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_ch12.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.ads?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -152,6 +152,9 @@ package Sem_Ch12 is\n    --  restored in stack-like fashion. Front-end inlining also uses these\n    --  structures for the management of private/full views.\n \n+   procedure Save_Global_References_In_Aspects (N : Node_Id);\n+   --  Save all global references in the aspect specifications of node N\n+\n    procedure Set_Copied_Sloc_For_Inlined_Body (N : Node_Id; E : Entity_Id);\n    --  This procedure is used when a subprogram body is inlined. This process\n    --  shares the same circuitry as the creation of an instantiated copy of"}, {"sha": "629b9ea5f7a6aa58443e80a17ad932bab4697094", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -1257,22 +1257,7 @@ package body Sem_Ch13 is\n          Decl : Node_Id;\n \n       begin\n-         --  When the context is a library unit, the pragma is added to the\n-         --  Pragmas_After list.\n-\n-         if Nkind (Parent (N)) = N_Compilation_Unit then\n-            Aux := Aux_Decls_Node (Parent (N));\n-\n-            if No (Pragmas_After (Aux)) then\n-               Set_Pragmas_After (Aux, New_List);\n-            end if;\n-\n-            Prepend (Prag, Pragmas_After (Aux));\n-\n-         --  Pragmas associated with subprogram bodies are inserted in the\n-         --  declarative part.\n-\n-         elsif Nkind (N) = N_Subprogram_Body then\n+         if Nkind (N) = N_Subprogram_Body then\n             if Present (Declarations (N)) then\n \n                --  Skip other internally generated pragmas from aspects to find\n@@ -1308,6 +1293,18 @@ package body Sem_Ch13 is\n                Set_Declarations (N, New_List (Prag));\n             end if;\n \n+         --  When the context is a library unit, the pragma is added to the\n+         --  Pragmas_After list.\n+\n+         elsif Nkind (Parent (N)) = N_Compilation_Unit then\n+            Aux := Aux_Decls_Node (Parent (N));\n+\n+            if No (Pragmas_After (Aux)) then\n+               Set_Pragmas_After (Aux, New_List);\n+            end if;\n+\n+            Prepend (Prag, Pragmas_After (Aux));\n+\n          --  Default\n \n          else\n@@ -2929,7 +2926,7 @@ package body Sem_Ch13 is\n                   if not Opt.Exception_Locations_Suppressed then\n                      Append_To (Pragma_Argument_Associations (Aitem),\n                        Make_Pragma_Argument_Association (Eloc,\n-                         Chars     => Name_Message,\n+                         Chars      => Name_Message,\n                          Expression =>\n                            Make_String_Literal (Eloc,\n                              Strval => \"failed \"\n@@ -2983,7 +2980,6 @@ package body Sem_Ch13 is\n                   Comp_Expr := First (Expressions (Expr));\n                   while Present (Comp_Expr) loop\n                      New_Expr := Relocate_Node (Comp_Expr);\n-                     Set_Original_Node (New_Expr, Comp_Expr);\n                      Append_To (Args,\n                        Make_Pragma_Argument_Association (Sloc (Comp_Expr),\n                          Expression => New_Expr));\n@@ -3002,12 +2998,11 @@ package body Sem_Ch13 is\n                         goto Continue;\n                      end if;\n \n-                     New_Expr := Relocate_Node (Expression (Comp_Assn));\n-                     Set_Original_Node (New_Expr, Expression (Comp_Assn));\n                      Append_To (Args,\n                        Make_Pragma_Argument_Association (Sloc (Comp_Assn),\n-                       Chars      => Chars (First (Choices (Comp_Assn))),\n-                       Expression => New_Expr));\n+                         Chars      => Chars (First (Choices (Comp_Assn))),\n+                         Expression =>\n+                           Relocate_Node (Expression (Comp_Assn))));\n                      Next (Comp_Assn);\n                   end loop;\n "}, {"sha": "1e4addacae56a848bec9f1da7401652c2855ef40", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -2471,6 +2471,7 @@ package body Sem_Ch3 is\n             Analyze_Object_Contract (Defining_Entity (Decl));\n \n          elsif Nkind_In (Decl, N_Abstract_Subprogram_Declaration,\n+                               N_Generic_Subprogram_Declaration,\n                                N_Subprogram_Declaration)\n          then\n             Analyze_Subprogram_Contract (Defining_Entity (Decl));\n@@ -4116,8 +4117,6 @@ package body Sem_Ch3 is\n          if Present (E) then\n             Set_Has_Initial_Value (Id);\n          end if;\n-\n-         Set_Contract (Id, Make_Contract (Sloc (Id)));\n       end if;\n \n       --  Initialize alignment and size and capture alignment setting\n@@ -14486,7 +14485,6 @@ package body Sem_Ch3 is\n    begin\n       New_Subp := New_Entity (Nkind (Parent_Subp), Sloc (Derived_Type));\n       Set_Ekind (New_Subp, Ekind (Parent_Subp));\n-      Set_Contract (New_Subp, Make_Contract (Sloc (New_Subp)));\n \n       --  Check whether the inherited subprogram is a private operation that\n       --  should be inherited but not yet made visible. Such subprograms can\n@@ -16468,7 +16466,7 @@ package body Sem_Ch3 is\n             Set_Has_Private_Declaration (Prev);\n             Set_Has_Private_Declaration (Id);\n \n-            --  AI12-0133: Indicate whether we have a partial view with\n+            --  AI12-0133: indicate whether we have a partial view with\n             --  unknown discriminants, in which case initialization of objects\n             --  of the type do not receive an invariant check.\n \n@@ -19445,7 +19443,7 @@ package body Sem_Ch3 is\n               and then Limited_Present (Type_Definition (Orig_Decl))\n             then\n                Error_Msg_N\n-                (\"full view of non-limited extension cannot be limited\", N);\n+                 (\"full view of non-limited extension cannot be limited\", N);\n \n             --  Conversely, if the partial view carries the limited keyword,\n             --  the full view must as well, even if it may be redundant.\n@@ -19454,8 +19452,8 @@ package body Sem_Ch3 is\n               and then not Limited_Present (Type_Definition (Orig_Decl))\n             then\n                Error_Msg_N\n-                (\"full view of limited extension must be explicitly limited\",\n-                 N);\n+                 (\"full view of limited extension must be explicitly limited\",\n+                  N);\n             end if;\n          end if;\n       end;"}, {"sha": "9ac8a6ba18b862828fd044c6a7e2a96f78a4b26b", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 267, "deletions": 239, "changes": 506, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -104,6 +104,14 @@ package body Sem_Ch6 is\n    -- Local Subprograms --\n    -----------------------\n \n+   procedure Analyze_Function_Return (N : Node_Id);\n+   --  Subsidiary to Analyze_Return_Statement. Called when the return statement\n+   --  applies to a [generic] function.\n+\n+   procedure Analyze_Generic_Subprogram_Body (N : Node_Id; Gen_Id : Entity_Id);\n+   --  Analyze a generic subprogram body. N is the body to be analyzed, and\n+   --  Gen_Id is the defining entity Id for the corresponding spec.\n+\n    procedure Analyze_Null_Procedure\n      (N             : Node_Id;\n       Is_Completion : out Boolean);\n@@ -112,10 +120,6 @@ package body Sem_Ch6 is\n    procedure Analyze_Return_Statement (N : Node_Id);\n    --  Common processing for simple and extended return statements\n \n-   procedure Analyze_Function_Return (N : Node_Id);\n-   --  Subsidiary to Analyze_Return_Statement. Called when the return statement\n-   --  applies to a [generic] function.\n-\n    procedure Analyze_Return_Type (N : Node_Id);\n    --  Subsidiary to Process_Formals: analyze subtype mark in function\n    --  specification in a context where the formals are visible and hide\n@@ -125,10 +129,6 @@ package body Sem_Ch6 is\n    --  Does all the real work of Analyze_Subprogram_Body. This is split out so\n    --  that we can use RETURN but not skip the debug output at the end.\n \n-   procedure Analyze_Generic_Subprogram_Body (N : Node_Id; Gen_Id : Entity_Id);\n-   --  Analyze a generic subprogram body. N is the body to be analyzed, and\n-   --  Gen_Id is the defining entity Id for the corresponding spec.\n-\n    function Can_Override_Operator (Subp : Entity_Id) return Boolean;\n    --  Returns true if Subp can override a predefined operator.\n \n@@ -223,7 +223,7 @@ package body Sem_Ch6 is\n       Check_SPARK_05_Restriction (\"abstract subprogram is not allowed\", N);\n \n       Generate_Definition (Designator);\n-      Set_Contract (Designator, Make_Contract (Sloc (Designator)));\n+\n       Set_Is_Abstract_Subprogram (Designator);\n       New_Overloaded_Entity (Designator);\n       Check_Delayed_Subprogram (Designator);\n@@ -1266,7 +1266,6 @@ package body Sem_Ch6 is\n          --  Visible generic entity is callable within its own body\n \n          Set_Ekind          (Gen_Id,  Ekind (Body_Id));\n-         Set_Contract       (Body_Id, Make_Contract (Sloc (Body_Id)));\n          Set_Ekind          (Body_Id, E_Subprogram_Body);\n          Set_Convention     (Body_Id, Convention (Gen_Id));\n          Set_Is_Obsolescent (Body_Id, Is_Obsolescent (Gen_Id));\n@@ -1316,45 +1315,6 @@ package body Sem_Ch6 is\n \n          Set_Actual_Subtypes (N, Current_Scope);\n \n-         --  Deal with [refined] preconditions, postconditions, Contract_Cases,\n-         --  invariants and predicates associated with the body and its spec.\n-         --  Note that this is not pure expansion as Expand_Subprogram_Contract\n-         --  prepares the contract assertions for generic subprograms or for\n-         --  ASIS. Do not generate contract checks in SPARK mode.\n-\n-         if not GNATprove_Mode then\n-            Expand_Subprogram_Contract (N, Gen_Id, Body_Id);\n-         end if;\n-\n-         --  If the generic unit carries pre- or post-conditions, copy them\n-         --  to the original generic tree, so that they are properly added\n-         --  to any instantiation.\n-\n-         declare\n-            Orig : constant Node_Id := Original_Node (N);\n-            Cond : Node_Id;\n-\n-         begin\n-            Cond := First (Declarations (N));\n-            while Present (Cond) loop\n-               if Nkind (Cond) = N_Pragma\n-                 and then Pragma_Name (Cond) = Name_Check\n-               then\n-                  Prepend (New_Copy_Tree (Cond), Declarations (Orig));\n-\n-               elsif Nkind (Cond) = N_Pragma\n-                 and then Pragma_Name (Cond) = Name_Postcondition\n-               then\n-                  Set_Ekind (Defining_Entity (Orig), Ekind (Gen_Id));\n-                  Prepend (New_Copy_Tree (Cond), Declarations (Orig));\n-               else\n-                  exit;\n-               end if;\n-\n-               Next (Cond);\n-            end loop;\n-         end;\n-\n          Set_SPARK_Pragma (Body_Id, SPARK_Mode_Pragma);\n          Set_SPARK_Pragma_Inherited (Body_Id, True);\n \n@@ -1446,7 +1406,6 @@ package body Sem_Ch6 is\n       if Present (Prev) and then Is_Generic_Subprogram (Prev) then\n          Insert_Before (N, Null_Body);\n          Set_Ekind (Defining_Entity (N), Ekind (Prev));\n-         Set_Contract (Defining_Entity (N), Make_Contract (Loc));\n \n          Rewrite (N, Make_Null_Statement (Loc));\n          Analyze_Generic_Subprogram_Body (Null_Body, Prev);\n@@ -2191,95 +2150,143 @@ package body Sem_Ch6 is\n    --------------------------------------\n \n    procedure Analyze_Subprogram_Body_Contract (Body_Id : Entity_Id) is\n-      Body_Decl   : constant Node_Id := Parent (Parent (Body_Id));\n-      Mode        : SPARK_Mode_Type;\n-      Prag        : Node_Id;\n-      Ref_Depends : Node_Id := Empty;\n-      Ref_Global  : Node_Id := Empty;\n-      Spec_Id     : Entity_Id;\n+      Body_Decl : constant Node_Id := Unit_Declaration_Node (Body_Id);\n \n-   begin\n-      --  Due to the timing of contract analysis, delayed pragmas may be\n-      --  subject to the wrong SPARK_Mode, usually that of the enclosing\n-      --  context. To remedy this, restore the original SPARK_Mode of the\n-      --  related subprogram body.\n+      procedure Analyze_Completion_Contract (Spec_Id : Entity_Id);\n+      --  Analyze all delayed pragmas chained on the contract of subprogram\n+      --  body Body_Id as if they appeared at the end of a declarative region.\n+      --  Spec_Id denotes the corresponding spec. The aspects in question are:\n+      --    Refined_Depends\n+      --    Refined_Global\n+      --  Note that pragma Refined_Post is analyzed immediately\n \n-      Save_SPARK_Mode_And_Set (Body_Id, Mode);\n+      ---------------------------------\n+      -- Analyze_Completion_Contract --\n+      ---------------------------------\n \n-      --  When a subprogram body declaration is illegal, its defining entity is\n-      --  left unanalyzed. There is nothing left to do in this case because the\n-      --  body lacks a contract, or even a proper Ekind.\n+      procedure Analyze_Completion_Contract (Spec_Id : Entity_Id) is\n+         Items         : constant Node_Id := Contract (Body_Id);\n+         Prag          : Node_Id;\n+         Prag_Nam      : Name_Id;\n+         Ref_Depends   : Node_Id := Empty;\n+         Ref_Global    : Node_Id := Empty;\n \n-      if Ekind (Body_Id) = E_Void then\n-         return;\n-      end if;\n+      begin\n+         --  All subprograms carry a contract, but for some it is not\n+         --  significant and should not be processed.\n \n-      if Nkind (Body_Decl) = N_Subprogram_Body_Stub then\n-         Spec_Id := Corresponding_Spec_Of_Stub (Body_Decl);\n-      else\n-         Spec_Id := Corresponding_Spec (Body_Decl);\n-      end if;\n+         if not Has_Significant_Contract (Spec_Id) then\n+            return;\n+\n+         elsif Present (Items) then\n+\n+            --  Locate and store pragmas Refined_Depends and Refined_Global\n+            --  since their order of analysis matters.\n+\n+            Prag := Classifications (Items);\n+            while Present (Prag) loop\n+               Prag_Nam := Pragma_Name (Prag);\n \n-      --  Locate and store pragmas Refined_Depends and Refined_Global since\n-      --  their order of analysis matters.\n+               if Prag_Nam = Name_Refined_Depends then\n+                  Ref_Depends := Prag;\n \n-      Prag := Classifications (Contract (Body_Id));\n-      while Present (Prag) loop\n-         if Pragma_Name (Prag) = Name_Refined_Depends then\n-            Ref_Depends := Prag;\n-         elsif Pragma_Name (Prag) = Name_Refined_Global then\n-            Ref_Global := Prag;\n+               elsif Prag_Nam = Name_Refined_Global then\n+                  Ref_Global := Prag;\n+               end if;\n+\n+               Prag := Next_Pragma (Prag);\n+            end loop;\n          end if;\n \n-         Prag := Next_Pragma (Prag);\n-      end loop;\n+         --  Analyze Refined_Global first as Refined_Depends may mention items\n+         --  classified in the global refinement.\n \n-      --  Analyze Refined_Global first as Refined_Depends may mention items\n-      --  classified in the global refinement.\n+         if Present (Ref_Global) then\n+            Analyze_Refined_Global_In_Decl_Part (Ref_Global);\n \n-      if Present (Ref_Global) then\n-         Analyze_Refined_Global_In_Decl_Part (Ref_Global);\n+         --  When the corresponding Global pragma references a state with\n+         --  visible refinement, the body requires Refined_Global. Such a\n+         --  refinement is not required when SPARK checks are suppressed.\n \n-      --  When the corresponding Global aspect/pragma references a state with\n-      --  visible refinement, the body requires Refined_Global. Refinement is\n-      --  not required when SPARK checks are suppressed.\n+         else\n+            Prag := Get_Pragma (Spec_Id, Pragma_Global);\n \n-      elsif Present (Spec_Id) then\n-         Prag := Get_Pragma (Spec_Id, Pragma_Global);\n+            if SPARK_Mode /= Off\n+              and then Present (Prag)\n+              and then Contains_Refined_State (Prag)\n+            then\n+               Error_Msg_NE\n+                 (\"body of subprogram& requires global refinement\",\n+                  Body_Decl, Spec_Id);\n+            end if;\n+         end if;\n \n-         if SPARK_Mode /= Off\n-           and then Present (Prag)\n-           and then Contains_Refined_State (Prag)\n-         then\n-            Error_Msg_NE\n-              (\"body of subprogram& requires global refinement\",\n-               Body_Decl, Spec_Id);\n+         --  Refined_Depends must be analyzed after Refined_Global in order to\n+         --  see the modes of all global refinements.\n+\n+         if Present (Ref_Depends) then\n+            Analyze_Refined_Depends_In_Decl_Part (Ref_Depends);\n+\n+         --  When the corresponding Depends pragma references a state with\n+         --  visible refinement, the body requires Refined_Depends. Such a\n+         --  refinement is not required when SPARK checks are suppressed.\n+\n+         else\n+            Prag := Get_Pragma (Spec_Id, Pragma_Depends);\n+\n+            if SPARK_Mode /= Off\n+              and then Present (Prag)\n+              and then Contains_Refined_State (Prag)\n+            then\n+               Error_Msg_NE\n+                 (\"body of subprogram& requires dependance refinement\",\n+                  Body_Decl, Spec_Id);\n+            end if;\n          end if;\n+      end Analyze_Completion_Contract;\n+\n+      --  Local variables\n+\n+      Mode    : SPARK_Mode_Type;\n+      Spec_Id : Entity_Id;\n+\n+   --  Start of processing for Analyze_Subprogram_Body_Contract\n+\n+   begin\n+      --  When a subprogram body declaration is illegal, its defining entity is\n+      --  left unanalyzed. There is nothing left to do in this case because the\n+      --  body lacks a contract, or even a proper Ekind.\n+\n+      if Ekind (Body_Id) = E_Void then\n+         return;\n       end if;\n \n-      --  Refined_Depends must be analyzed after Refined_Global in order to see\n-      --  the modes of all global refinements.\n+      --  Due to the timing of contract analysis, delayed pragmas may be\n+      --  subject to the wrong SPARK_Mode, usually that of the enclosing\n+      --  context. To remedy this, restore the original SPARK_Mode of the\n+      --  related subprogram body.\n \n-      if Present (Ref_Depends) then\n-         Analyze_Refined_Depends_In_Decl_Part (Ref_Depends);\n+      Save_SPARK_Mode_And_Set (Body_Id, Mode);\n \n-      --  When the corresponding Depends aspect/pragma references a state with\n-      --  visible refinement, the body requires Refined_Depends. Refinement is\n-      --  not required when SPARK checks are suppressed.\n+      if Nkind (Body_Decl) = N_Subprogram_Body_Stub then\n+         Spec_Id := Corresponding_Spec_Of_Stub (Body_Decl);\n+      else\n+         Spec_Id := Corresponding_Spec (Body_Decl);\n+      end if;\n \n-      elsif Present (Spec_Id) then\n-         Prag := Get_Pragma (Spec_Id, Pragma_Depends);\n+      --  The subprogram body is a completion, analyze all delayed pragmas that\n+      --  apply. Note that when the body is stand alone, the pragmas are always\n+      --  analyzed on the spot.\n \n-         if SPARK_Mode /= Off\n-           and then Present (Prag)\n-           and then Contains_Refined_State (Prag)\n-         then\n-            Error_Msg_NE\n-              (\"body of subprogram& requires dependance refinement\",\n-               Body_Decl, Spec_Id);\n-         end if;\n+      if Present (Spec_Id) then\n+         Analyze_Completion_Contract (Spec_Id);\n       end if;\n \n+      --  Ensure that the contract cases or postconditions mention 'Result or\n+      --  define a post-state.\n+\n+      Check_Result_And_Post_State (Body_Id);\n+\n       --  Restore the SPARK_Mode of the enclosing context after all delayed\n       --  pragmas have been analyzed.\n \n@@ -3412,15 +3419,6 @@ package body Sem_Ch6 is\n          end if;\n       end if;\n \n-      --  Mark presence of postcondition procedure in current scope and mark\n-      --  the procedure itself as needing debug info. The latter is important\n-      --  when analyzing decision coverage (for example, for MC/DC coverage).\n-\n-      if Chars (Body_Id) = Name_uPostconditions then\n-         Set_Has_Postconditions (Current_Scope);\n-         Set_Debug_Info_Needed (Body_Id);\n-      end if;\n-\n       --  Place subprogram on scope stack, and make formals visible. If there\n       --  is a spec, the visible entity remains that of the spec.\n \n@@ -3591,9 +3589,8 @@ package body Sem_Ch6 is\n          end if;\n \n          Set_Corresponding_Body (Unit_Declaration_Node (Spec_Id), Body_Id);\n-         Set_Contract (Body_Id, Make_Contract (Sloc (Body_Id)));\n-         Set_Scope (Body_Id, Scope (Spec_Id));\n          Set_Is_Obsolescent (Body_Id, Is_Obsolescent (Spec_Id));\n+         Set_Scope          (Body_Id, Scope (Spec_Id));\n \n       --  Case of subprogram body with no previous spec\n \n@@ -3624,7 +3621,6 @@ package body Sem_Ch6 is\n          if Nkind (N) /= N_Subprogram_Body_Stub then\n             Set_Acts_As_Spec (N);\n             Generate_Definition (Body_Id);\n-            Set_Contract (Body_Id, Make_Contract (Sloc (Body_Id)));\n             Generate_Reference\n               (Body_Id, Body_Id, 'b', Set_Ref => False, Force => True);\n             Install_Formals (Body_Id);\n@@ -3903,20 +3899,6 @@ package body Sem_Ch6 is\n          Analyze_Aspects_On_Body_Or_Stub;\n       end if;\n \n-      --  Deal with [refined] preconditions, postconditions, Contract_Cases,\n-      --  invariants and predicates associated with the body and its spec.\n-      --  Note that this is not pure expansion as Expand_Subprogram_Contract\n-      --  prepares the contract assertions for generic subprograms or for ASIS.\n-      --  Do not generate contract checks in SPARK mode.\n-\n-      if not GNATprove_Mode then\n-         Expand_Subprogram_Contract (N, Spec_Id, Body_Id);\n-      end if;\n-\n-      --  Analyze the declarations (this call will analyze the precondition\n-      --  Check pragmas we prepended to the list, as well as the declaration\n-      --  of the _Postconditions procedure).\n-\n       Analyze_Declarations (Declarations (N));\n \n       --  Verify that the SPARK_Mode of the body agrees with that of its spec\n@@ -3946,6 +3928,24 @@ package body Sem_Ch6 is\n          end if;\n       end if;\n \n+      --  When a subprogram body appears inside a package, its contract is\n+      --  analyzed at the end of the package body declarations. This is due\n+      --  to the delay with respect of the package contract upon which the\n+      --  body contract may depend. When the subprogram body is stand alone\n+      --  and acts as a compilation unit, this delay is not necessary.\n+\n+      if Nkind (Parent (N)) = N_Compilation_Unit then\n+         Analyze_Subprogram_Body_Contract (Body_Id);\n+      end if;\n+\n+      --  Deal with preconditions, [refined] postconditions, Contract_Cases,\n+      --  invariants and predicates associated with body and its spec. Since\n+      --  there is no routine Expand_Declarations which would otherwise deal\n+      --  with the contract expansion, generate all necessary mechanisms to\n+      --  verify the contract assertions now.\n+\n+      Expand_Subprogram_Contract (N);\n+\n       --  If SPARK_Mode for body is not On, disable frontend inlining for this\n       --  subprogram in GNATprove mode, as its body should not be analyzed.\n \n@@ -4163,70 +4163,100 @@ package body Sem_Ch6 is\n    -- Analyze_Subprogram_Contract --\n    ---------------------------------\n \n-   procedure Analyze_Subprogram_Contract (Subp : Entity_Id) is\n-      Items        : constant Node_Id := Contract (Subp);\n-      Case_Prag    : Node_Id := Empty;\n-      Depends      : Node_Id := Empty;\n-      Global       : Node_Id := Empty;\n-      Mode         : SPARK_Mode_Type;\n-      Nam          : Name_Id;\n-      Post_Prag    : Node_Id := Empty;\n-      Prag         : Node_Id;\n-      Seen_In_Case : Boolean := False;\n-      Seen_In_Post : Boolean := False;\n+   procedure Analyze_Subprogram_Contract (Subp_Id : Entity_Id) is\n+      procedure Save_Global_References_In_List (First_Prag : Node_Id);\n+      --  Save all global references in contract-related source pragma found in\n+      --  the list starting from pragma First_Prag.\n+\n+      ------------------------------------\n+      -- Save_Global_References_In_List --\n+      ------------------------------------\n+\n+      procedure Save_Global_References_In_List (First_Prag : Node_Id) is\n+         Prag : Node_Id;\n+\n+      begin\n+         Prag := First_Prag;\n+         while Present (Prag) loop\n+            if Comes_From_Source (Prag)\n+              and then Nam_In (Pragma_Name (Prag), Name_Contract_Cases,\n+                                                   Name_Depends,\n+                                                   Name_Extensions_Visible,\n+                                                   Name_Global,\n+                                                   Name_Postcondition,\n+                                                   Name_Precondition,\n+                                                   Name_Test_Case)\n+            then\n+               Save_Global_References (Original_Node (Prag));\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+      end Save_Global_References_In_List;\n+\n+      --  Local variables\n+\n+      Items         : constant Node_Id := Contract (Subp_Id);\n+      Subp_Decl     : constant Node_Id := Unit_Declaration_Node (Subp_Id);\n+      Depends       : Node_Id := Empty;\n+      Global        : Node_Id := Empty;\n+      Mode          : SPARK_Mode_Type;\n+      Prag          : Node_Id;\n+      Prag_Nam      : Name_Id;\n+      Restore_Scope : Boolean := False;\n+\n+   --  Start of processing for Analyze_Subprogram_Contract\n \n    begin\n+      --  All subprograms carry a contract, but for some it is not significant\n+      --  and should not be processed.\n+\n+      if not Has_Significant_Contract (Subp_Id) then\n+         return;\n+      end if;\n+\n       --  Due to the timing of contract analysis, delayed pragmas may be\n       --  subject to the wrong SPARK_Mode, usually that of the enclosing\n       --  context. To remedy this, restore the original SPARK_Mode of the\n       --  related subprogram body.\n \n-      Save_SPARK_Mode_And_Set (Subp, Mode);\n+      Save_SPARK_Mode_And_Set (Subp_Id, Mode);\n+\n+      --  Ensure that the formal parameters are visible when analyzing all\n+      --  contract items.\n+\n+      if not In_Open_Scopes (Subp_Id) then\n+         Restore_Scope := True;\n+         Push_Scope (Subp_Id);\n+\n+         if Is_Generic_Subprogram (Subp_Id) then\n+            Install_Generic_Formals (Subp_Id);\n+         else\n+            Install_Formals (Subp_Id);\n+         end if;\n+      end if;\n \n       if Present (Items) then\n \n          --  Analyze pre- and postconditions\n \n          Prag := Pre_Post_Conditions (Items);\n          while Present (Prag) loop\n-            Analyze_Pre_Post_Condition_In_Decl_Part (Prag, Subp);\n-\n-            --  Verify whether a postcondition mentions attribute 'Result and\n-            --  its expression introduces a post-state.\n-\n-            if Warn_On_Suspicious_Contract\n-              and then Pragma_Name (Prag) = Name_Postcondition\n-            then\n-               Post_Prag := Prag;\n-               Check_Result_And_Post_State (Prag, Seen_In_Post);\n-            end if;\n-\n+            Analyze_Pre_Post_Condition_In_Decl_Part (Prag);\n             Prag := Next_Pragma (Prag);\n          end loop;\n \n          --  Analyze contract-cases and test-cases\n \n          Prag := Contract_Test_Cases (Items);\n          while Present (Prag) loop\n-            Nam := Pragma_Name (Prag);\n+            Prag_Nam := Pragma_Name (Prag);\n \n-            if Nam = Name_Contract_Cases then\n+            if Prag_Nam = Name_Contract_Cases then\n                Analyze_Contract_Cases_In_Decl_Part (Prag);\n-\n-               --  Verify whether contract-cases mention attribute 'Result and\n-               --  its expression introduces a post-state. Perform the check\n-               --  only when the pragma is legal.\n-\n-               if Warn_On_Suspicious_Contract\n-                 and then not Error_Posted (Prag)\n-               then\n-                  Case_Prag := Prag;\n-                  Check_Result_And_Post_State (Prag, Seen_In_Case);\n-               end if;\n-\n             else\n-               pragma Assert (Nam = Name_Test_Case);\n-               Analyze_Test_Case_In_Decl_Part (Prag, Subp);\n+               pragma Assert (Prag_Nam = Name_Test_Case);\n+               Analyze_Test_Case_In_Decl_Part (Prag);\n             end if;\n \n             Prag := Next_Pragma (Prag);\n@@ -4236,12 +4266,12 @@ package body Sem_Ch6 is\n \n          Prag := Classifications (Items);\n          while Present (Prag) loop\n-            Nam := Pragma_Name (Prag);\n+            Prag_Nam := Pragma_Name (Prag);\n \n-            if Nam = Name_Depends then\n+            if Prag_Nam = Name_Depends then\n                Depends := Prag;\n \n-            elsif Nam = Name_Global then\n+            elsif Prag_Nam = Name_Global then\n                Global := Prag;\n \n             --  Note that pragma Extensions_Visible has already been analyzed\n@@ -4264,51 +4294,42 @@ package body Sem_Ch6 is\n          if Present (Depends) then\n             Analyze_Depends_In_Decl_Part (Depends);\n          end if;\n-      end if;\n \n-      --  Emit an error when neither the postconditions nor the contract-cases\n-      --  mention attribute 'Result in the context of a function.\n+         --  Ensure that the contract cases or postconditions mention 'Result\n+         --  or define a post-state.\n \n-      if Warn_On_Suspicious_Contract\n-        and then Ekind_In (Subp, E_Function, E_Generic_Function)\n-      then\n-         if Present (Case_Prag)\n-           and then not Seen_In_Case\n-           and then Present (Post_Prag)\n-           and then not Seen_In_Post\n-         then\n-            Error_Msg_N\n-              (\"neither function postcondition nor contract cases mention \"\n-               & \"result?T?\", Post_Prag);\n+         Check_Result_And_Post_State (Subp_Id);\n+      end if;\n \n-         elsif Present (Case_Prag) and then not Seen_In_Case then\n-            Error_Msg_N\n-              (\"contract cases do not mention result?T?\", Case_Prag);\n+      --  The aspects and contract-related source pragmas associated with a\n+      --  generic subprogram are treated separately from the declaration as\n+      --  they need to be analyzed when the subprogram contract is analyzed.\n+      --  Once this is done, global references can be successfully saved.\n \n-         --  OK if we have at least one IN OUT parameter\n+      if Nkind (Subp_Decl) = N_Generic_Subprogram_Declaration then\n \n-         elsif Present (Post_Prag) and then not Seen_In_Post then\n-            declare\n-               F : Entity_Id;\n-            begin\n-               F := First_Formal (Subp);\n-               while Present (F) loop\n-                  if Ekind (F) = E_In_Out_Parameter then\n-                     return;\n-                  else\n-                     Next_Formal (F);\n-                  end if;\n-               end loop;\n-            end;\n+         --  Save all global references found in the aspect specifications of\n+         --  the parameter profile of the generic subprogram.\n \n-            --  If no in-out parameters and no mention of Result, the contract\n-            --  is certainly suspicious.\n+         Save_Global_References_In_Aspects (Original_Node (Subp_Decl));\n \n-            Error_Msg_N\n-              (\"function postcondition does not mention result?T?\", Post_Prag);\n+         --  Save all global references found in contract-related source\n+         --  pragmas. These pragmas usually appear after the declaration of\n+         --  the generic subprogram, either in the same declarative part or\n+         --  in the Pragmas_After list when the generic subprogram is a\n+         --  compilation unit.\n+\n+         if Present (Items) then\n+            Save_Global_References_In_List (Pre_Post_Conditions (Items));\n+            Save_Global_References_In_List (Contract_Test_Cases (Items));\n+            Save_Global_References_In_List (Classifications     (Items));\n          end if;\n       end if;\n \n+      if Restore_Scope then\n+         End_Scope;\n+      end if;\n+\n       --  Restore the SPARK_Mode of the enclosing context after all delayed\n       --  pragmas have been analyzed.\n \n@@ -4565,8 +4586,6 @@ package body Sem_Ch6 is\n          Generate_Definition (Designator);\n       end if;\n \n-      Set_Contract (Designator, Make_Contract (Sloc (Designator)));\n-\n       if Nkind (N) = N_Function_Specification then\n          Set_Ekind (Designator, E_Function);\n          Set_Mechanism (Designator, Default_Mechanism);\n@@ -8624,27 +8643,36 @@ package body Sem_Ch6 is\n         and then Is_Subprogram_Or_Generic_Subprogram (E)\n       then\n          declare\n-            Inherited : constant Subprogram_List := Inherited_Subprograms (E);\n-            P         : Node_Id;\n+            Subps : constant Subprogram_List := Inherited_Subprograms (E);\n+            Items : Node_Id;\n+            Prag  : Node_Id;\n \n          begin\n-            for J in Inherited'Range loop\n-               P := Pre_Post_Conditions (Contract (Inherited (J)));\n-               while Present (P) loop\n-                  Error_Msg_Sloc := Sloc (P);\n-\n-                  if Class_Present (P) and then not Split_PPC (P) then\n-                     if Pragma_Name (P) = Name_Precondition then\n-                        Error_Msg_N (\"info: & inherits `Pre''Class` aspect \"\n-                                     & \"from #?L?\", E);\n-                     else\n-                        Error_Msg_N (\"info: & inherits `Post''Class` aspect \"\n-                                     & \"from #?L?\", E);\n+            for Index in Subps'Range loop\n+               Items := Contract (Subps (Index));\n+\n+               if Present (Items) then\n+                  Prag := Pre_Post_Conditions (Items);\n+                  while Present (Prag) loop\n+                     Error_Msg_Sloc := Sloc (Prag);\n+\n+                     if Class_Present (Prag)\n+                       and then not Split_PPC (Prag)\n+                     then\n+                        if Pragma_Name (Prag) = Name_Precondition then\n+                           Error_Msg_N\n+                             (\"info: & inherits `Pre''Class` aspect from \"\n+                              & \"#?L?\", E);\n+                        else\n+                           Error_Msg_N\n+                             (\"info: & inherits `Post''Class` aspect from \"\n+                              & \"#?L?\", E);\n+                        end if;\n                      end if;\n-                  end if;\n \n-                  P := Next_Pragma (P);\n-               end loop;\n+                     Prag := Next_Pragma (Prag);\n+                  end loop;\n+               end if;\n             end loop;\n          end;\n       end if;"}, {"sha": "427559e527baa6b195a4d598357070438071a491", "filename": "gcc/ada/sem_ch6.ads", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -47,15 +47,22 @@ package Sem_Ch6 is\n \n    procedure Analyze_Subprogram_Body_Contract (Body_Id : Entity_Id);\n    --  Analyze all delayed aspects chained on the contract of subprogram body\n-   --  Body_Id as if they appeared at the end of a declarative region. The\n-   --  aspects in question are:\n+   --  Body_Id as if they appeared at the end of a declarative region. Aspects\n+   --  in question are:\n+   --    Contract_Cases   (stand alone body)\n+   --    Depends          (stand alone body)\n+   --    Global           (stand alone body)\n+   --    Postcondition    (stand alone body)\n+   --    Precondition     (stand alone body)\n    --    Refined_Depends\n    --    Refined_Global\n+   --    Refined_Post\n+   --    Test_Case        (stand alone body)\n \n-   procedure Analyze_Subprogram_Contract (Subp : Entity_Id);\n-   --  Analyze all delayed aspects chained on the contract of subprogram Subp\n-   --  as if they appeared at the end of a declarative region. The aspects in\n-   --  question are:\n+   procedure Analyze_Subprogram_Contract (Subp_Id : Entity_Id);\n+   --  Analyze all delayed aspects chained on the contract of subprogram\n+   --  Subp_Id as if they appeared at the end of a declarative region. The\n+   --  aspects in question are:\n    --    Contract_Cases\n    --    Depends\n    --    Global"}, {"sha": "4d0bf159b3e662ffec9905b10b5cf4863155c76f", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -297,6 +297,7 @@ package body Sem_Ch7 is\n \n                elsif Nkind (N) = N_Attribute_Reference\n                  and then Is_Entity_Name (Prefix (N))\n+                 and then Present (Entity (Prefix (N)))\n                  and then Is_Subprogram (Entity (Prefix (N)))\n                then\n                   Reference_Seen := True;\n@@ -690,7 +691,6 @@ package body Sem_Ch7 is\n       Set_Ekind (Body_Id, E_Package_Body);\n       Set_Body_Entity (Spec_Id, Body_Id);\n       Set_Spec_Entity (Body_Id, Spec_Id);\n-      Set_Contract    (Body_Id, Make_Contract (Sloc (Body_Id)));\n \n       --  Defining name for the package body is not a visible entity: Only the\n       --  defining name for the declaration is visible.\n@@ -1017,9 +1017,8 @@ package body Sem_Ch7 is\n \n       Generate_Definition (Id);\n       Enter_Name (Id);\n-      Set_Ekind    (Id, E_Package);\n-      Set_Etype    (Id, Standard_Void_Type);\n-      Set_Contract (Id, Make_Contract (Sloc (Id)));\n+      Set_Ekind  (Id, E_Package);\n+      Set_Etype  (Id, Standard_Void_Type);\n \n       --  Set SPARK_Mode from context only for non-generic package\n "}, {"sha": "9f2600fd5709685e18e3f4ddeace726ad8395afa", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -2871,7 +2871,6 @@ package body Sem_Ch8 is\n          --  constructed later at the freeze point, so indicate that the\n          --  completion has not been seen yet.\n \n-         Set_Contract (New_S, Empty);\n          Set_Ekind (New_S, E_Subprogram_Body);\n          New_S := Rename_Spec;\n          Set_Has_Completion (Rename_Spec, False);\n@@ -6459,7 +6458,8 @@ package body Sem_Ch8 is\n       --  is an array type we may already have a usable subtype for it, so we\n       --  can use it rather than generating a new one, because the bounds\n       --  will be the values of the discriminants and not discriminant refs.\n-      --  This simplifies value tracing in GNATProve.\n+      --  This simplifies value tracing in GNATProve. For consistency, both\n+      --  the entity name and the subtype come from the constrained component.\n \n       function Is_Reference_In_Subunit return Boolean;\n       --  In a subunit, the scope depth is not a proper measure of hiding,\n@@ -6474,12 +6474,14 @@ package body Sem_Ch8 is\n \n       function Available_Subtype return Boolean is\n          Comp : Entity_Id;\n+\n       begin\n          Comp := First_Entity (Etype (P));\n          while Present (Comp) loop\n             if Chars (Comp) = Chars (Selector_Name (N)) then\n                Set_Etype (N, Etype (Comp));\n-               Set_Etype (Selector_Name (N), Etype (Comp));\n+               Set_Entity (Selector_Name (N), Comp);\n+               Set_Etype  (Selector_Name (N), Etype (Comp));\n                return True;\n             end if;\n "}, {"sha": "48bee0b938d3e4d7c60d2d22484aaf45c8a44462", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1496,7 +1496,7 @@ package body Sem_Ch9 is\n \n    begin\n       Generate_Definition (Def_Id);\n-      Set_Contract (Def_Id, Make_Contract (Sloc (Def_Id)));\n+\n       Tasking_Used := True;\n \n       --  Case of no discrete subtype definition"}, {"sha": "e81e951e1fb362ec3dcc3f6b3eaaa530063963c3", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 1312, "deletions": 1502, "changes": 2814, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e"}, {"sha": "cf80d52455dbf2618f06261d094debe47028892d", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 41, "deletions": 20, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -103,14 +103,9 @@ package Sem_Prag is\n    procedure Analyze_Initializes_In_Decl_Part (N : Node_Id);\n    --  Perform full analysis of delayed pragma Initializes\n \n-   procedure Analyze_Pre_Post_Condition_In_Decl_Part\n-     (Prag    : Node_Id;\n-      Subp_Id : Entity_Id);\n-   --  Perform preanalysis of a [refined] precondition or postcondition that\n-   --  appears on a subprogram declaration or body [stub]. Prag denotes the\n-   --  pragma, Subp_Id is the entity of the related subprogram. The preanalysis\n-   --  of the expression is done as \"spec expression\" (see section \"Handling\n-   --  of Default and Per-Object Expressions in Sem).\n+   procedure Analyze_Pre_Post_Condition_In_Decl_Part (N : Node_Id);\n+   --  Perform preanalysis of [refined] precondition or postcondition pragma\n+   --  N that appears on a subprogram declaration or body [stub].\n \n    procedure Analyze_Refined_Depends_In_Decl_Part (N : Node_Id);\n    --  Preform full analysis of delayed pragma Refined_Depends. This routine\n@@ -125,12 +120,8 @@ package Sem_Prag is\n    procedure Analyze_Refined_State_In_Decl_Part (N : Node_Id);\n    --  Perform full analysis of delayed pragma Refined_State\n \n-   procedure Analyze_Test_Case_In_Decl_Part (N : Node_Id; S : Entity_Id);\n-   --  Perform preanalysis of pragma Test_Case that applies to a subprogram\n-   --  declaration. Parameter N denotes the pragma, S is the entity of the\n-   --  related subprogram. The preanalysis of the expression is done as \"spec\n-   --  expression\" (see section \"Handling of Default and Per-Object Expressions\n-   --  in Sem).\n+   procedure Analyze_Test_Case_In_Decl_Part (N : Node_Id);\n+   --  Perform preanalysis of pragma Test_Case\n \n    procedure Check_Applicable_Policy (N : Node_Id);\n    --  N is either an N_Aspect or an N_Pragma node. There are two cases. If\n@@ -199,6 +190,23 @@ package Sem_Prag is\n    --  True have their analysis delayed until after the main program is parsed\n    --  and analyzed.\n \n+   function Find_Related_Subprogram_Or_Body\n+     (Prag      : Node_Id;\n+      Do_Checks : Boolean := False) return Node_Id;\n+   --  Subsidiary to the analysis of pragmas Contract_Cases, Depends, Global,\n+   --  Refined_Depends, Refined_Global and Refined_Post and attribute 'Result.\n+   --  Find the declaration of the related subprogram [body or stub] subject\n+   --  to pragma Prag. If flag Do_Checks is set, the routine reports duplicate\n+   --  pragmas and detects improper use of refinement pragmas in stand alone\n+   --  expression functions. The returned value depends on the related pragma\n+   --  as follows:\n+   --    1) Pragmas Contract_Cases, Depends and Global yield the corresponding\n+   --       N_Subprogram_Declaration node or if the pragma applies to a stand\n+   --       alone body, the N_Subprogram_Body node or Empty if illegal.\n+   --    2) Pragmas Refined_Depends, Refined_Global and Refined_Post yield\n+   --       N_Subprogram_Body or N_Subprogram_Body_Stub nodes or Empty if\n+   --       illegal.\n+\n    function Get_SPARK_Mode_From_Pragma (N : Node_Id) return SPARK_Mode_Type;\n    --  Given a pragma SPARK_Mode node, return corresponding mode id\n \n@@ -247,12 +255,6 @@ package Sem_Prag is\n    --  Name_uInvariant, and Name_uType_Invariant (_Pre, _Post, _Invariant,\n    --  and _Type_Invariant).\n \n-   procedure Make_Aspect_For_PPC_In_Gen_Sub_Decl (Decl : Node_Id);\n-   --  This routine makes aspects from precondition or postcondition pragmas\n-   --  that appear within a generic subprogram declaration. Decl is the generic\n-   --  subprogram declaration node. Note that the aspects are attached to the\n-   --  generic copy and also to the orginal tree.\n-\n    procedure Process_Compilation_Unit_Pragmas (N : Node_Id);\n    --  Called at the start of processing compilation unit N to deal with any\n    --  special issues regarding pragmas. In particular, we have to deal with\n@@ -276,4 +278,23 @@ package Sem_Prag is\n    --  the value of the Interface_Name. Otherwise it is encoded as needed by\n    --  particular operating systems. See the body for details of the encoding.\n \n+   function Test_Case_Arg\n+     (Prag        : Node_Id;\n+      Arg_Nam     : Name_Id;\n+      From_Aspect : Boolean := False) return Node_Id;\n+   --  Obtain argument \"Name\", \"Mode\", \"Ensures\" or \"Requires\" from Test_Case\n+   --  pragma Prag as denoted by Arg_Nam. When From_Aspect is set, an attempt\n+   --  is made to retrieve the argument from the corresponding aspect if there\n+   --  is one. The returned argument has several formats:\n+   --\n+   --    N_Pragma_Argument_Association if retrieved directly from the pragma\n+   --\n+   --    N_Component_Association if retrieved from the corresponding aspect and\n+   --    the argument appears in a named association form.\n+   --\n+   --    An arbitrary expression if retrieved from the corresponding aspect and\n+   --    the argument appears in positional form.\n+   --\n+   --    Empty if there is no such argument\n+\n end Sem_Prag;"}, {"sha": "8bde5795efb272bf7945b392f7de8db3f4f1b601", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 419, "deletions": 267, "changes": 686, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -47,6 +47,7 @@ with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Attr; use Sem_Attr;\n+with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Disp; use Sem_Disp;\n@@ -250,7 +251,7 @@ package body Sem_Util is\n    -----------------------\n \n    procedure Add_Contract_Item (Prag : Node_Id; Id : Entity_Id) is\n-      Items : constant Node_Id := Contract (Id);\n+      Items : Node_Id := Contract (Id);\n \n       procedure Add_Classification;\n       --  Prepend Prag to the list of classifications\n@@ -293,19 +294,22 @@ package body Sem_Util is\n \n       --  Local variables\n \n-      Nam : Name_Id;\n-      PPC : Node_Id;\n+      Prag_Nam : Name_Id;\n \n    --  Start of processing for Add_Contract_Item\n \n    begin\n-      --  The related context must have a contract and the item to be added\n-      --  must be a pragma.\n+      --  A contract must contain only pragmas\n \n-      pragma Assert (Present (Items));\n       pragma Assert (Nkind (Prag) = N_Pragma);\n+      Prag_Nam := Pragma_Name (Prag);\n \n-      Nam := Original_Aspect_Name (Prag);\n+      --  Create a new contract when adding the first item\n+\n+      if No (Items) then\n+         Items := Make_Contract (Sloc (Id));\n+         Set_Contract (Id, Items);\n+      end if;\n \n       --  Contract items related to [generic] packages or instantiations. The\n       --  applicable pragmas are:\n@@ -315,15 +319,15 @@ package body Sem_Util is\n       --    Part_Of (instantiation only)\n \n       if Ekind_In (Id, E_Generic_Package, E_Package) then\n-         if Nam_In (Nam, Name_Abstract_State,\n-                         Name_Initial_Condition,\n-                         Name_Initializes)\n+         if Nam_In (Prag_Nam, Name_Abstract_State,\n+                              Name_Initial_Condition,\n+                              Name_Initializes)\n          then\n             Add_Classification;\n \n          --  Indicator Part_Of must be associated with a package instantiation\n \n-         elsif Nam = Name_Part_Of and then Is_Generic_Instance (Id) then\n+         elsif Prag_Nam = Name_Part_Of and then Is_Generic_Instance (Id) then\n             Add_Classification;\n \n          --  The pragma is not a proper contract item\n@@ -336,7 +340,7 @@ package body Sem_Util is\n       --    Refined_States\n \n       elsif Ekind (Id) = E_Package_Body then\n-         if Nam = Name_Refined_State then\n+         if Prag_Nam = Name_Refined_State then\n             Add_Classification;\n \n          --  The pragma is not a proper contract item\n@@ -351,57 +355,23 @@ package body Sem_Util is\n       --    Depends\n       --    Extensions_Visible\n       --    Global\n-      --    Post\n       --    Postcondition\n-      --    Pre\n       --    Precondition\n       --    Test_Case\n \n       elsif Ekind_In (Id, E_Entry, E_Entry_Family)\n         or else Is_Generic_Subprogram (Id)\n         or else Is_Subprogram (Id)\n       then\n-         if Nam_In (Nam, Name_Pre,\n-                         Name_Precondition,\n-                         Name_uPre,\n-                         Name_Post,\n-                         Name_Postcondition,\n-                         Name_uPost)\n-         then\n-            --  Before we add a precondition or postcondition to the list, make\n-            --  sure we do not have a disallowed duplicate, which can happen if\n-            --  we use a pragma for Pre[_Class] or Post[_Class] instead of the\n-            --  corresponding aspect.\n-\n-            if not From_Aspect_Specification (Prag)\n-              and then Nam_In (Nam, Name_Pre,\n-                                    Name_uPre,\n-                                    Name_Post,\n-                                    Name_Post_Class)\n-            then\n-               PPC := Pre_Post_Conditions (Items);\n-               while Present (PPC) loop\n-                  if not Split_PPC (PPC)\n-                    and then Original_Aspect_Name (PPC) = Nam\n-                  then\n-                     Error_Msg_Sloc := Sloc (PPC);\n-                     Error_Msg_NE\n-                       (\"duplication of aspect for & given#\", Prag, Id);\n-                     return;\n-                  end if;\n-\n-                  PPC := Next_Pragma (PPC);\n-               end loop;\n-            end if;\n-\n+         if Nam_In (Prag_Nam, Name_Postcondition, Name_Precondition) then\n             Add_Pre_Post_Condition;\n \n-         elsif Nam_In (Nam, Name_Contract_Cases, Name_Test_Case) then\n+         elsif Nam_In (Prag_Nam, Name_Contract_Cases, Name_Test_Case) then\n             Add_Contract_Test_Case;\n \n-         elsif Nam_In (Nam, Name_Depends,\n-                            Name_Extensions_Visible,\n-                            Name_Global)\n+         elsif Nam_In (Prag_Nam, Name_Depends,\n+                                 Name_Extensions_Visible,\n+                                 Name_Global)\n          then\n             Add_Classification;\n \n@@ -412,15 +382,20 @@ package body Sem_Util is\n          end if;\n \n       --  Contract items related to subprogram bodies. Applicable pragmas are:\n+      --    Postcondition\n+      --    Precondition\n       --    Refined_Depends\n       --    Refined_Global\n       --    Refined_Post\n \n       elsif Ekind (Id) = E_Subprogram_Body then\n-         if Nam_In (Nam, Name_Refined_Depends, Name_Refined_Global) then\n+         if Nam_In (Prag_Nam, Name_Refined_Depends, Name_Refined_Global) then\n             Add_Classification;\n \n-         elsif Nam = Name_Refined_Post then\n+         elsif Nam_In (Prag_Nam, Name_Postcondition,\n+                                 Name_Precondition,\n+                                 Name_Refined_Post)\n+         then\n             Add_Pre_Post_Condition;\n \n          --  The pragma is not a proper contract item\n@@ -437,11 +412,11 @@ package body Sem_Util is\n       --    Part_Of\n \n       elsif Ekind (Id) = E_Variable then\n-         if Nam_In (Nam, Name_Async_Readers,\n-                         Name_Async_Writers,\n-                         Name_Effective_Reads,\n-                         Name_Effective_Writes,\n-                         Name_Part_Of)\n+         if Nam_In (Prag_Nam, Name_Async_Readers,\n+                              Name_Async_Writers,\n+                              Name_Effective_Reads,\n+                              Name_Effective_Writes,\n+                              Name_Part_Of)\n          then\n             Add_Classification;\n \n@@ -3047,168 +3022,325 @@ package body Sem_Util is\n    -- Check_Result_And_Post_State --\n    ---------------------------------\n \n-   procedure Check_Result_And_Post_State\n-     (Prag        : Node_Id;\n-      Result_Seen : in out Boolean)\n-   is\n-      procedure Check_Expression (Expr : Node_Id);\n-      --  Perform the 'Result and post-state checks on a given expression\n+   procedure Check_Result_And_Post_State (Subp_Id : Entity_Id) is\n+      procedure Check_Result_And_Post_State_In_Pragma\n+        (Prag        : Node_Id;\n+         Result_Seen : in out Boolean);\n+      --  Determine whether pragma Prag mentions attribute 'Result and whether\n+      --  the pragma contains an expression that evaluates differently in pre-\n+      --  and post-state. Prag is a [refined] postcondition or a contract-cases\n+      --  pragma. Result_Seen is set when the pragma mentions attribute 'Result\n+\n+      function Has_In_Out_Parameter (Subp_Id : Entity_Id) return Boolean;\n+      --  Determine whether subprogram Subp_Id contains at least one IN OUT\n+      --  formal parameter.\n+\n+      -------------------------------------------\n+      -- Check_Result_And_Post_State_In_Pragma --\n+      -------------------------------------------\n+\n+      procedure Check_Result_And_Post_State_In_Pragma\n+        (Prag        : Node_Id;\n+         Result_Seen : in out Boolean)\n+      is\n+         procedure Check_Expression (Expr : Node_Id);\n+         --  Perform the 'Result and post-state checks on a given expression\n \n-      function Is_Function_Result (N : Node_Id) return Traverse_Result;\n-      --  Attempt to find attribute 'Result in a subtree denoted by N\n+         function Is_Function_Result (N : Node_Id) return Traverse_Result;\n+         --  Attempt to find attribute 'Result in a subtree denoted by N\n \n-      function Is_Trivial_Boolean (N : Node_Id) return Boolean;\n-      --  Determine whether source node N denotes \"True\" or \"False\"\n+         function Is_Trivial_Boolean (N : Node_Id) return Boolean;\n+         --  Determine whether source node N denotes \"True\" or \"False\"\n \n-      function Mentions_Post_State (N : Node_Id) return Boolean;\n-      --  Determine whether a subtree denoted by N mentions any construct that\n-      --  denotes a post-state.\n+         function Mentions_Post_State (N : Node_Id) return Boolean;\n+         --  Determine whether a subtree denoted by N mentions any construct\n+         --  that denotes a post-state.\n \n-      procedure Check_Function_Result is\n-        new Traverse_Proc (Is_Function_Result);\n+         procedure Check_Function_Result is\n+           new Traverse_Proc (Is_Function_Result);\n \n-      ----------------------\n-      -- Check_Expression --\n-      ----------------------\n+         ----------------------\n+         -- Check_Expression --\n+         ----------------------\n \n-      procedure Check_Expression (Expr : Node_Id) is\n-      begin\n-         if not Is_Trivial_Boolean (Expr) then\n-            Check_Function_Result (Expr);\n+         procedure Check_Expression (Expr : Node_Id) is\n+         begin\n+            if not Is_Trivial_Boolean (Expr) then\n+               Check_Function_Result (Expr);\n \n-            if not Mentions_Post_State (Expr) then\n-               if Pragma_Name (Prag) = Name_Contract_Cases then\n-                  Error_Msg_N\n-                    (\"contract case refers only to pre-state?T?\", Expr);\n+               if not Mentions_Post_State (Expr) then\n+                  if Pragma_Name (Prag) = Name_Contract_Cases then\n+                     Error_Msg_NE\n+                       (\"contract case does not check the outcome of calling \"\n+                        & \"&?T?\", Expr, Subp_Id);\n \n-               elsif Pragma_Name (Prag) = Name_Refined_Post then\n-                  Error_Msg_N\n-                    (\"refined postcondition refers only to pre-state?T?\",\n-                     Prag);\n+                  elsif Pragma_Name (Prag) = Name_Refined_Post then\n+                     Error_Msg_NE\n+                       (\"refined postcondition does not check the outcome of \"\n+                        & \"calling &?T?\", Prag, Subp_Id);\n \n-               else\n-                  Error_Msg_N\n-                    (\"postcondition refers only to pre-state?T?\", Prag);\n+                  else\n+                     Error_Msg_NE\n+                       (\"postcondition does not check the outcome of calling \"\n+                        & \"&?T?\", Prag, Subp_Id);\n+                  end if;\n                end if;\n             end if;\n-         end if;\n-      end Check_Expression;\n+         end Check_Expression;\n \n-      ------------------------\n-      -- Is_Function_Result --\n-      ------------------------\n+         ------------------------\n+         -- Is_Function_Result --\n+         ------------------------\n \n-      function Is_Function_Result (N : Node_Id) return Traverse_Result is\n-      begin\n-         if Is_Attribute_Result (N) then\n-            Result_Seen := True;\n-            return Abandon;\n+         function Is_Function_Result (N : Node_Id) return Traverse_Result is\n+         begin\n+            if Is_Attribute_Result (N) then\n+               Result_Seen := True;\n+               return Abandon;\n \n-         --  Continue the traversal\n+            --  Continue the traversal\n \n-         else\n-            return OK;\n-         end if;\n-      end Is_Function_Result;\n+            else\n+               return OK;\n+            end if;\n+         end Is_Function_Result;\n \n-      ------------------------\n-      -- Is_Trivial_Boolean --\n-      ------------------------\n+         ------------------------\n+         -- Is_Trivial_Boolean --\n+         ------------------------\n \n-      function Is_Trivial_Boolean (N : Node_Id) return Boolean is\n-      begin\n-         return\n-           Comes_From_Source (N)\n-             and then Is_Entity_Name (N)\n-             and then (Entity (N) = Standard_True\n-                         or else\n-                       Entity (N) = Standard_False);\n-      end Is_Trivial_Boolean;\n+         function Is_Trivial_Boolean (N : Node_Id) return Boolean is\n+         begin\n+            return\n+              Comes_From_Source (N)\n+                and then Is_Entity_Name (N)\n+                and then (Entity (N) = Standard_True\n+                            or else\n+                          Entity (N) = Standard_False);\n+         end Is_Trivial_Boolean;\n \n-      -------------------------\n-      -- Mentions_Post_State --\n-      -------------------------\n+         -------------------------\n+         -- Mentions_Post_State --\n+         -------------------------\n \n-      function Mentions_Post_State (N : Node_Id) return Boolean is\n-         Post_State_Seen : Boolean := False;\n+         function Mentions_Post_State (N : Node_Id) return Boolean is\n+            Post_State_Seen : Boolean := False;\n \n-         function Is_Post_State (N : Node_Id) return Traverse_Result;\n-         --  Attempt to find a construct that denotes a post-state. If this is\n-         --  the case, set flag Post_State_Seen.\n+            function Is_Post_State (N : Node_Id) return Traverse_Result;\n+            --  Attempt to find a construct that denotes a post-state. If this\n+            --  is the case, set flag Post_State_Seen.\n \n-         -------------------\n-         -- Is_Post_State --\n-         -------------------\n+            -------------------\n+            -- Is_Post_State --\n+            -------------------\n \n-         function Is_Post_State (N : Node_Id) return Traverse_Result is\n-            Ent : Entity_Id;\n+            function Is_Post_State (N : Node_Id) return Traverse_Result is\n+               Ent : Entity_Id;\n \n-         begin\n-            if Nkind_In (N, N_Explicit_Dereference, N_Function_Call) then\n-               Post_State_Seen := True;\n-               return Abandon;\n+            begin\n+               if Nkind_In (N, N_Explicit_Dereference, N_Function_Call) then\n+                  Post_State_Seen := True;\n+                  return Abandon;\n \n-            elsif Nkind_In (N, N_Expanded_Name, N_Identifier) then\n-               Ent := Entity (N);\n+               elsif Nkind_In (N, N_Expanded_Name, N_Identifier) then\n+                  Ent := Entity (N);\n \n-               --  The entity may be modifiable through an implicit dereference\n+                  --  The entity may be modifiable through an implicit\n+                  --  dereference.\n \n-               if No (Ent)\n-                 or else Ekind (Ent) in Assignable_Kind\n-                 or else (Is_Access_Type (Etype (Ent))\n-                           and then Nkind (Parent (N)) = N_Selected_Component)\n-               then\n-                  Post_State_Seen := True;\n-                  return Abandon;\n-               end if;\n+                  if No (Ent)\n+                    or else Ekind (Ent) in Assignable_Kind\n+                    or else (Is_Access_Type (Etype (Ent))\n+                              and then Nkind (Parent (N)) =\n+                                         N_Selected_Component)\n+                  then\n+                     Post_State_Seen := True;\n+                     return Abandon;\n+                  end if;\n \n-            elsif Nkind (N) = N_Attribute_Reference then\n-               if Attribute_Name (N) = Name_Old then\n-                  return Skip;\n+               elsif Nkind (N) = N_Attribute_Reference then\n+                  if Attribute_Name (N) = Name_Old then\n+                     return Skip;\n \n-               elsif Attribute_Name (N) = Name_Result then\n-                  Post_State_Seen := True;\n-                  return Abandon;\n+                  elsif Attribute_Name (N) = Name_Result then\n+                     Post_State_Seen := True;\n+                     return Abandon;\n+                  end if;\n                end if;\n-            end if;\n \n-            return OK;\n-         end Is_Post_State;\n+               return OK;\n+            end Is_Post_State;\n+\n+            procedure Find_Post_State is new Traverse_Proc (Is_Post_State);\n \n-         procedure Find_Post_State is new Traverse_Proc (Is_Post_State);\n+         --  Start of processing for Mentions_Post_State\n \n-      --  Start of processing for Mentions_Post_State\n+         begin\n+            Find_Post_State (N);\n+\n+            return Post_State_Seen;\n+         end Mentions_Post_State;\n+\n+         --  Local variables\n+\n+         Expr  : constant Node_Id :=\n+                   Get_Pragma_Arg\n+                     (First (Pragma_Argument_Associations (Prag)));\n+         Nam   : constant Name_Id := Pragma_Name (Prag);\n+         CCase : Node_Id;\n+\n+      --  Start of processing for Check_Result_And_Post_State_In_Pragma\n \n       begin\n-         Find_Post_State (N);\n+         --  Examine all consequences\n \n-         return Post_State_Seen;\n-      end Mentions_Post_State;\n+         if Nam = Name_Contract_Cases then\n+            CCase := First (Component_Associations (Expr));\n+            while Present (CCase) loop\n+               Check_Expression (Expression (CCase));\n+\n+               Next (CCase);\n+            end loop;\n+\n+         --  Examine the expression of a postcondition\n+\n+         else pragma Assert (Nam_In (Nam, Name_Postcondition,\n+                                          Name_Refined_Post));\n+            Check_Expression (Expr);\n+         end if;\n+      end Check_Result_And_Post_State_In_Pragma;\n+\n+      --------------------------\n+      -- Has_In_Out_Parameter --\n+      --------------------------\n+\n+      function Has_In_Out_Parameter (Subp_Id : Entity_Id) return Boolean is\n+         Formal : Entity_Id;\n+\n+      begin\n+         --  Traverse the formals looking for an IN OUT parameter\n+\n+         Formal := First_Formal (Subp_Id);\n+         while Present (Formal) loop\n+            if Ekind (Formal) = E_In_Out_Parameter then\n+               return True;\n+            end if;\n+\n+            Next_Formal (Formal);\n+         end loop;\n+\n+         return False;\n+      end Has_In_Out_Parameter;\n \n       --  Local variables\n \n-      Expr  : constant Node_Id :=\n-                Get_Pragma_Arg (First (Pragma_Argument_Associations (Prag)));\n-      Nam   : constant Name_Id := Pragma_Name (Prag);\n-      CCase : Node_Id;\n+      Items        : constant Node_Id := Contract (Subp_Id);\n+      Subp_Decl    : constant Node_Id := Unit_Declaration_Node (Subp_Id);\n+      Case_Prag    : Node_Id := Empty;\n+      Post_Prag    : Node_Id := Empty;\n+      Prag         : Node_Id;\n+      Seen_In_Case : Boolean := False;\n+      Seen_In_Post : Boolean := False;\n+      Spec_Id      : Entity_Id;\n \n    --  Start of processing for Check_Result_And_Post_State\n \n    begin\n-      --  Examine all consequences\n+      --  The lack of attribute 'Result or a post-state is classified as a\n+      --  suspicious contract. Do not perform the check if the corresponding\n+      --  swich is not set.\n \n-      if Nam = Name_Contract_Cases then\n-         CCase := First (Component_Associations (Expr));\n-         while Present (CCase) loop\n-            Check_Expression (Expression (CCase));\n+      if not Warn_On_Suspicious_Contract then\n+         return;\n \n-            Next (CCase);\n-         end loop;\n+      --  Nothing to do if there is no contract\n+\n+      elsif No (Items) then\n+         return;\n+      end if;\n+\n+      --  Retrieve the entity of the subprogram spec (if any)\n+\n+      if Nkind (Subp_Decl) = N_Subprogram_Body\n+        and then Present (Corresponding_Spec (Subp_Decl))\n+      then\n+         Spec_Id := Corresponding_Spec (Subp_Decl);\n \n-      --  Examine the expression of a postcondition\n+      elsif Nkind (Subp_Decl) = N_Subprogram_Body_Stub\n+        and then Present (Corresponding_Spec_Of_Stub (Subp_Decl))\n+      then\n+         Spec_Id := Corresponding_Spec_Of_Stub (Subp_Decl);\n \n-      else pragma Assert (Nam_In (Nam, Name_Postcondition, Name_Refined_Post));\n-         Check_Expression (Expr);\n+      else\n+         Spec_Id := Subp_Id;\n+      end if;\n+\n+      --  Examine all postconditions for attribute 'Result and a post-state\n+\n+      Prag := Pre_Post_Conditions (Items);\n+      while Present (Prag) loop\n+         if Nam_In (Pragma_Name (Prag), Name_Postcondition,\n+                                        Name_Refined_Post)\n+           and then not Error_Posted (Prag)\n+         then\n+            Post_Prag := Prag;\n+            Check_Result_And_Post_State_In_Pragma (Prag, Seen_In_Post);\n+         end if;\n+\n+         Prag := Next_Pragma (Prag);\n+      end loop;\n+\n+      --  Examine the contract cases of the subprogram for attribute 'Result\n+      --  and a post-state.\n+\n+      Prag := Contract_Test_Cases (Items);\n+      while Present (Prag) loop\n+         if Pragma_Name (Prag) = Name_Contract_Cases\n+           and then not Error_Posted (Prag)\n+         then\n+            Case_Prag := Prag;\n+            Check_Result_And_Post_State_In_Pragma (Prag, Seen_In_Case);\n+         end if;\n+\n+         Prag := Next_Pragma (Prag);\n+      end loop;\n+\n+      --  Do not emit any errors if the subprogram is not a function\n+\n+      if not Ekind_In (Spec_Id, E_Function, E_Generic_Function) then\n+         null;\n+\n+      --  Regardless of whether the function has postconditions or contract\n+      --  cases, or whether they mention attribute 'Result, an IN OUT formal\n+      --  parameter is always treated as a result.\n+\n+      elsif Has_In_Out_Parameter (Spec_Id) then\n+         null;\n+\n+      --  The function has both a postcondition and contract cases and they do\n+      --  not mention attribute 'Result.\n+\n+      elsif Present (Case_Prag)\n+        and then not Seen_In_Case\n+        and then Present (Post_Prag)\n+        and then not Seen_In_Post\n+      then\n+         Error_Msg_N\n+           (\"neither postcondition nor contract cases mention function \"\n+            & \"result?T?\", Post_Prag);\n+\n+      --  The function has contract cases only and they do not mention\n+      --  attribute 'Result.\n+\n+      elsif Present (Case_Prag) and then not Seen_In_Case then\n+         Error_Msg_N (\"contract cases do not mention result?T?\", Case_Prag);\n+\n+      --  The function has postconditions only and they do not mention\n+      --  attribute 'Result.\n+\n+      elsif Present (Post_Prag) and then not Seen_In_Post then\n+         Error_Msg_N\n+           (\"postcondition does not mention function result?T?\", Post_Prag);\n       end if;\n    end Check_Result_And_Post_State;\n \n@@ -4336,6 +4468,27 @@ package body Sem_Util is\n       end if;\n    end Corresponding_Generic_Type;\n \n+   ---------------------------\n+   -- Corresponding_Spec_Of --\n+   ---------------------------\n+\n+   function Corresponding_Spec_Of (Subp_Decl : Node_Id) return Entity_Id is\n+   begin\n+      if Nkind (Subp_Decl) = N_Subprogram_Body\n+        and then Present (Corresponding_Spec (Subp_Decl))\n+      then\n+         return Corresponding_Spec (Subp_Decl);\n+\n+      elsif Nkind (Subp_Decl) = N_Subprogram_Body_Stub\n+        and then Present (Corresponding_Spec_Of_Stub (Subp_Decl))\n+      then\n+         return Corresponding_Spec_Of_Stub (Subp_Decl);\n+\n+      else\n+         return Defining_Entity (Subp_Decl);\n+      end if;\n+   end Corresponding_Spec_Of;\n+\n    --------------------\n    -- Current_Entity --\n    --------------------\n@@ -7009,32 +7162,6 @@ package body Sem_Util is\n       end if;\n    end Get_Enum_Lit_From_Pos;\n \n-   ---------------------------------\n-   -- Get_Ensures_From_CTC_Pragma --\n-   ---------------------------------\n-\n-   function Get_Ensures_From_CTC_Pragma (N : Node_Id) return Node_Id is\n-      Args : constant List_Id := Pragma_Argument_Associations (N);\n-      Res  : Node_Id;\n-\n-   begin\n-      if List_Length (Args) = 4 then\n-         Res := Pick (Args, 4);\n-\n-      elsif List_Length (Args) = 3 then\n-         Res := Pick (Args, 3);\n-\n-         if Chars (Res) /= Name_Ensures then\n-            Res := Empty;\n-         end if;\n-\n-      else\n-         Res := Empty;\n-      end if;\n-\n-      return Res;\n-   end Get_Ensures_From_CTC_Pragma;\n-\n    ------------------------\n    -- Get_Generic_Entity --\n    ------------------------\n@@ -7294,29 +7421,6 @@ package body Sem_Util is\n       return R;\n    end Get_Renamed_Entity;\n \n-   ----------------------------------\n-   -- Get_Requires_From_CTC_Pragma --\n-   ----------------------------------\n-\n-   function Get_Requires_From_CTC_Pragma (N : Node_Id) return Node_Id is\n-      Args : constant List_Id := Pragma_Argument_Associations (N);\n-      Res  : Node_Id;\n-\n-   begin\n-      if List_Length (Args) >= 3 then\n-         Res := Pick (Args, 3);\n-\n-         if Chars (Res) /= Name_Requires then\n-            Res := Empty;\n-         end if;\n-\n-      else\n-         Res := Empty;\n-      end if;\n-\n-      return Res;\n-   end Get_Requires_From_CTC_Pragma;\n-\n    -------------------------\n    -- Get_Subprogram_Body --\n    -------------------------\n@@ -8804,6 +8908,41 @@ package body Sem_Util is\n       return Is_Floating_Point_Type (E) and then Signed_Zeros_On_Target;\n    end Has_Signed_Zeros;\n \n+   ------------------------------\n+   -- Has_Significant_Contract --\n+   ------------------------------\n+\n+   function Has_Significant_Contract (Subp_Id : Entity_Id) return Boolean is\n+      Subp_Nam : constant Name_Id := Chars (Subp_Id);\n+\n+   begin\n+      --  _Finalizer procedure\n+\n+      if Subp_Nam = Name_uFinalizer then\n+         return False;\n+\n+      --  _Postconditions procedure\n+\n+      elsif Subp_Nam = Name_uPostconditions then\n+         return False;\n+\n+      --  Predicate function\n+\n+      elsif Ekind (Subp_Id) = E_Function\n+        and then Is_Predicate_Function (Subp_Id)\n+      then\n+         return False;\n+\n+      --  TSS subprogram\n+\n+      elsif Get_TSS_Name (Subp_Id) /= TSS_Null then\n+         return False;\n+\n+      else\n+         return True;\n+      end if;\n+   end Has_Significant_Contract;\n+\n    -----------------------------\n    -- Has_Static_Array_Bounds --\n    -----------------------------\n@@ -9576,7 +9715,6 @@ package body Sem_Util is\n \n       if Is_Subprogram_Or_Generic_Subprogram (Subp)\n         and then Is_Subprogram_Or_Generic_Subprogram (From_Subp)\n-        and then Present (Contract (Subp))\n         and then Present (Contract (From_Subp))\n       then\n          Inherit_Pragma (Pragma_Extensions_Visible);\n@@ -9695,6 +9833,23 @@ package body Sem_Util is\n       end loop;\n    end Inspect_Deferred_Constant_Completion;\n \n+   -----------------------------\n+   -- Install_Generic_Formals --\n+   -----------------------------\n+\n+   procedure Install_Generic_Formals (Subp_Id : Entity_Id) is\n+      E : Entity_Id;\n+\n+   begin\n+      pragma Assert (Is_Generic_Subprogram (Subp_Id));\n+\n+      E := First_Entity (Subp_Id);\n+      while Present (E) loop\n+         Install_Entity (E);\n+         Next_Entity (E);\n+      end loop;\n+   end Install_Generic_Formals;\n+\n    -----------------------------\n    -- Is_Actual_Out_Parameter --\n    -----------------------------\n@@ -15344,71 +15499,68 @@ package body Sem_Util is\n       end if;\n    end Object_Access_Level;\n \n-   --------------------------\n-   -- Original_Aspect_Name --\n-   --------------------------\n+   ---------------------------------\n+   -- Original_Aspect_Pragma_Name --\n+   ---------------------------------\n \n-   function Original_Aspect_Name (N : Node_Id) return Name_Id is\n-      Pras : Node_Id;\n-      Name : Name_Id;\n+   function Original_Aspect_Pragma_Name (N : Node_Id) return Name_Id is\n+      Item     : Node_Id;\n+      Item_Nam : Name_Id;\n \n    begin\n       pragma Assert (Nkind_In (N, N_Aspect_Specification, N_Pragma));\n-      Pras := N;\n \n-      if Is_Rewrite_Substitution (Pras)\n-        and then Nkind (Original_Node (Pras)) = N_Pragma\n-      then\n-         Pras := Original_Node (Pras);\n-      end if;\n+      Item := N;\n \n-      --  Case where we came from aspect specication\n+      --  The pragma was generated to emulate an aspect, use the original\n+      --  aspect specification.\n \n-      if Nkind (Pras) = N_Pragma and then From_Aspect_Specification (Pras) then\n-         Pras := Corresponding_Aspect (Pras);\n+      if Nkind (Item) = N_Pragma and then From_Aspect_Specification (Item) then\n+         Item := Corresponding_Aspect (Item);\n       end if;\n \n-      --  Get name from aspect or pragma\n+      --  Retrieve the name of the aspect/pragma. Note that Pre, Pre_Class,\n+      --  Post and Post_Class rewrite their pragma identifier to preserve the\n+      --  original name.\n+      --  ??? this is kludgey\n+\n+      if Nkind (Item) = N_Pragma then\n+         Item_Nam := Chars (Original_Node (Pragma_Identifier (Item)));\n \n-      if Nkind (Pras) = N_Pragma then\n-         Name := Pragma_Name (Pras);\n       else\n-         Name := Chars (Identifier (Pras));\n+         pragma Assert (Nkind (Item) = N_Aspect_Specification);\n+         Item_Nam := Chars (Identifier (Item));\n       end if;\n \n-      --  Deal with 'Class\n-\n-      if Class_Present (Pras) then\n-         case Name is\n+      --  Deal with 'Class by converting the name to its _XXX form\n \n-         --  Names that need converting to special _xxx form\n+      if Class_Present (Item) then\n+         if Item_Nam = Name_Invariant then\n+            Item_Nam := Name_uInvariant;\n \n-            when Name_Pre                  |\n-                 Name_Pre_Class            =>\n-               Name := Name_uPre;\n+         elsif Nam_In (Item_Nam, Name_Post, Name_Post_Class) then\n+            Item_Nam := Name_uPost;\n \n-            when Name_Post                 |\n-                 Name_Post_Class           =>\n-               Name := Name_uPost;\n+         elsif Nam_In (Item_Nam, Name_Pre, Name_Pre_Class) then\n+            Item_Nam := Name_uPre;\n \n-            when Name_Invariant            =>\n-               Name := Name_uInvariant;\n+         elsif Item_Nam = Name_Invariant then\n+            Item_Nam := Name_uInvariant;\n \n-            when Name_Type_Invariant       |\n-                 Name_Type_Invariant_Class =>\n-               Name := Name_uType_Invariant;\n+         elsif Nam_In (Item_Nam, Name_Type_Invariant,\n+                                 Name_Type_Invariant_Class)\n+         then\n+            Item_Nam := Name_uType_Invariant;\n \n-            --  Nothing to do for other cases (e.g. a Check that derived\n-            --  from Pre_Class and has the flag set). Also we do nothing\n-            --  if the name is already in special _xxx form.\n+         --  Nothing to do for other cases (e.g. a Check that derived from\n+         --  Pre_Class and has the flag set). Also we do nothing if the name\n+         --  is already in special _xxx form.\n \n-            when others                    =>\n-               null;\n-         end case;\n+         end if;\n       end if;\n \n-      return Name;\n-   end Original_Aspect_Name;\n+      return Item_Nam;\n+   end Original_Aspect_Pragma_Name;\n \n    --------------------------------------\n    -- Original_Corresponding_Operation --"}, {"sha": "b24f261cfdf786681cd4068603141b90d48a5aea", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -321,13 +321,10 @@ package Sem_Util is\n    --  N is one of the statement forms that is a potentially blocking\n    --  operation. If it appears within a protected action, emit warning.\n \n-   procedure Check_Result_And_Post_State\n-     (Prag        : Node_Id;\n-      Result_Seen : in out Boolean);\n-   --  Determine whether pragma Prag mentions attribute 'Result and whether\n-   --  the pragma contains an expression that evaluates differently in pre-\n-   --  and post-state. Prag is a [refined] postcondition or a contract-cases\n-   --  pragma. Result_Seen is set when the pragma mentions attribute 'Result.\n+   procedure Check_Result_And_Post_State (Subp_Id : Entity_Id);\n+   --  Determine whether the contract of subprogram Subp_Id mentions attribute\n+   --  'Result and it contains an expression that evaluates differently in pre-\n+   --  and post-state.\n \n    procedure Check_Unprotected_Access\n      (Context : Node_Id;\n@@ -419,6 +416,11 @@ package Sem_Util is\n    --  attribute, except in the case of formal private and derived types.\n    --  Possible optimization???\n \n+   function Corresponding_Spec_Of (Subp_Decl : Node_Id) return Entity_Id;\n+   --  Return the corresponding spec of Subp_Decl when it denotes a body [stub]\n+   --  or the defining entity of subprogram declaration Subp_Decl in all other\n+   --  cases.\n+\n    function Current_Entity (N : Node_Id) return Entity_Id;\n    pragma Inline (Current_Entity);\n    --  Find the currently visible definition for a given identifier, that is to\n@@ -819,10 +821,6 @@ package Sem_Util is\n    --  If expression N references a part of an object, return this object.\n    --  Otherwise return Empty. Expression N should have been resolved already.\n \n-   function Get_Ensures_From_CTC_Pragma (N : Node_Id) return Node_Id;\n-   --  Return the Ensures component of Test_Case pragma N, or Empty otherwise\n-   --  Bad name now that this no longer applies to Contract_Case ???\n-\n    function Get_Generic_Entity (N : Node_Id) return Entity_Id;\n    --  Returns the true generic entity in an instantiation. If the name in the\n    --  instantiation is a renaming, the function returns the renamed generic.\n@@ -899,10 +897,6 @@ package Sem_Util is\n    --  not a renamed entity, returns its argument. It is an error to call this\n    --  with any other kind of entity.\n \n-   function Get_Requires_From_CTC_Pragma (N : Node_Id) return Node_Id;\n-   --  Return the Requires component of Test_Case pragma N, or Empty otherwise\n-   --  Bad name now that this no longer applies to Contract_Case ???\n-\n    function Get_Subprogram_Entity (Nod : Node_Id) return Entity_Id;\n    --  Nod is either a procedure call statement, or a function call, or an\n    --  accept statement node. This procedure finds the Entity_Id of the related\n@@ -1011,6 +1005,11 @@ package Sem_Util is\n    --  Determines if the floating-point type E supports signed zeros.\n    --  Returns False if E is not a floating-point type.\n \n+   function Has_Significant_Contract (Subp_Id : Entity_Id) return Boolean;\n+   --  Determine whether subprogram [body] Subp_Id has a significant contract.\n+   --  All subprograms have a N_Contract node, but this does not mean that the\n+   --  contract is useful.\n+\n    function Has_Static_Array_Bounds (Typ : Node_Id) return Boolean;\n    --  Return whether an array type has static bounds\n \n@@ -1128,6 +1127,10 @@ package Sem_Util is\n    --  whether they have been completed by a full constant declaration or an\n    --  Import pragma. Emit the error message if that is not the case.\n \n+   procedure Install_Generic_Formals (Subp_Id : Entity_Id);\n+   --  Install both the generic formal parameters and the formal parameters of\n+   --  generic subprogram Subp_Id into visibility.\n+\n    function Is_Actual_Out_Parameter (N : Node_Id) return Boolean;\n    --  Determines if N is an actual parameter of out mode in a subprogram call\n \n@@ -1673,15 +1676,19 @@ package Sem_Util is\n    --  corresponding operation of S is the original corresponding operation of\n    --  S2. Otherwise, it is S itself.\n \n-   function Original_Aspect_Name (N : Node_Id) return Name_Id;\n-   --  N is a pragma node or aspect specification node. This function returns\n-   --  the name of the pragma or aspect in original source form, taking into\n-   --  account possible rewrites, and also cases where a pragma comes from an\n-   --  aspect (in such cases, the name can be different from the pragma name,\n-   --  e.g. a Pre aspect generates a Precondition pragma). This also deals with\n-   --  the presence of 'Class, which results in one of the special names\n-   --  Name_uPre, Name_uPost, Name_uInvariant, or Name_uType_Invariant being\n-   --  returned to represent the corresponding aspects with x'Class names.\n+   function Original_Aspect_Pragma_Name (N : Node_Id) return Name_Id;\n+   --  Retrieve the name of aspect or pragma N taking into account a possible\n+   --  rewrite and whether the pragma is generated from an aspect as the names\n+   --  may be different. The routine also deals with 'Class in which case it\n+   --  returns the following values:\n+   --\n+   --    Invariant            -> Name_uInvariant\n+   --    Post                 -> Name_uPost\n+   --    Post'Class           -> Name_uPost\n+   --    Pre                  -> Name_uPre\n+   --    Pre'Class            -> Name_uPre\n+   --    Type_Invariant       -> Name_uType_Invariant\n+   --    Type_Invariant'Class -> Name_uType_Invariant\n \n    function Policy_In_Effect (Policy : Name_Id) return Name_Id;\n    --  Given a policy, return the policy identifier associated with it. If no"}, {"sha": "7e1442fde10a1274624633083b1f6b62a9c0ac57", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9d70ab181e531bfe069c42aeaa996ec96bca02e/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=c9d70ab181e531bfe069c42aeaa996ec96bca02e", "patch": "@@ -40,6 +40,7 @@ with Sem;      use Sem;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Eval; use Sem_Eval;\n+with Sem_Prag; use Sem_Prag;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n@@ -1855,7 +1856,7 @@ package body Sem_Warn is\n \n                               if Nkind (P) = N_Pragma\n                                 and then Pragma_Name (P) = Name_Test_Case\n-                                and then Nod = Get_Ensures_From_CTC_Pragma (P)\n+                                and then Nod = Test_Case_Arg (P, Name_Ensures)\n                               then\n                                  return True;\n                               end if;"}]}