{"sha": "e187fa72fb4806da5b93af1d346446b9fc7f0993", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE4N2ZhNzJmYjQ4MDZkYTViOTNhZjFkMzQ2NDQ2YjlmYzdmMDk5Mw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-16T12:51:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-07-16T12:51:41Z"}, "message": "[multiple changes]\n\n2012-07-16  Robert Dewar  <dewar@adacore.com>\n\n\t* freeze.adb, g-debpoo.adb, exp_ch3.adb: Minor reformatting.\n\n2012-07-16  Thomas Quinot  <quinot@adacore.com>\n\n\t* s-oscons-tmplt.c: Add definitions of E2BIG and EILSEQ.\n\n2012-07-16  Tristan Gingold  <gingold@adacore.com>\n\n\t* a-exexpr.adb (Propagate_Continue): New function replacing\n\tRaise_Current_Excep.\n\t(Allocate_Occurrence): New function.\n\t(Propagate_Exception): Add Excep parameter, remove call to Call_Chain.\n\t* a-exexpr-gcc.adb (GNAT_GCC_Exception): Occurrence component\n\tis now aliased.\n\t(To_GCC_Exception): Convert from Address.\n\t(Allocate_Occurrence): Allocate an Unwind exception occurrence.\n\t(Setup_Current_Excep): Fill the machine occurrence in case of\n\tforeign exception.\n\t(Propagate_Exception): Add Excep parameter, remove call to Call_Chain.\n\t* a-except.adb (Set_Exception_C_Msg, Set_Exception_Msg): add\n\tExcep parameter.\n\t(Raise_Exception, Raise_Exception_Always,\n\tRaise_Exception_No_Defer): Adjust calls to the above procedures.\n\t(Raise_From_Signal_Handler, Raise_With_Location_And_Msg)\n\t(Rcheck_PE_Finalize_Raised_Exception): Likewise.\n\t* a-except-2005.adb (Set_Exception_C_Msg, Set_Exception_Msg):\n\tadd Excep parameter.\n\t(Propagate_Exception): Likewise.\n\t(Allocate_Occurrence): New function.\n\t(Raise_Current_Excep): Removed.\n\t(Complete_Occurrence): New function to save the call chain.\n\t(Complete_And_Propagate_Occurrence): New procedure.\n\t(Create_Occurrence_From_Signal_Handler): New function to build an\n\toccurrence without propagating it.\n\t(Create_Machine_Occurrence_From_Signal_Handler): Likewise, but\n\treturn the machine occurrence.\n\t(Raise_From_Signal_Handler): Use Create_Occurrence_From_Signal_Handler.\n\t(Raise_Exception, Raise_Exception_Always, Raise_Exception_No_Defer):\n\tAdjust calls to the above procedures. Allocate the occurrence at\n\tthe beginning.\n\t(Raise_With_Location_And_Msg, Raise_With_Msg)\n\t(Rcheck_PE_Finalize_Raised_Exceptionm Reraise): Likewise.\n\t(Reraise_Occurrence): Use Reraise_Occurrence_Always.\n\t(Reraise_Occurrence_Always): Use Reraise_Occurrence_No_Defer.\n\t(Reraise_Occurrence_No_Defer): Preserve machine occurrence.\n\t(Save_Occurrence): Do not save machine occurrence.\n\t* a-except-2005.ads (Exception_Occurrence): Add Machine_Occurrence\n\tcomponent.\n\t(Null_Occurrence): Consider it.\n\t* a-exexda.adb (Set_Exception_C_Msg, Set_Exception_Msg): add\n\tExcep parameter.\n\n2012-07-16  Tristan Gingold  <gingold@adacore.com>\n\n\t* seh_init.c (__gnat_map_SEH): New function extracted from\n\t__gnat_SEH_error_handler.\n\t* raise-gcc.c: __gnat_personality_seh0: Directly transforms\n\tWindows system exception into GCC one when possible, in order\n\tto save stack room (particularly useful when Storage_Error will\n\tbe propagated).\n\nFrom-SVN: r189530", "tree": {"sha": "519b73a3579b0657a1ff1d6be8e64614831db7cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/519b73a3579b0657a1ff1d6be8e64614831db7cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e187fa72fb4806da5b93af1d346446b9fc7f0993", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e187fa72fb4806da5b93af1d346446b9fc7f0993", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e187fa72fb4806da5b93af1d346446b9fc7f0993", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e187fa72fb4806da5b93af1d346446b9fc7f0993/comments", "author": null, "committer": null, "parents": [{"sha": "59a6c9d56580c806c493a50c8902fd2177074399", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59a6c9d56580c806c493a50c8902fd2177074399", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59a6c9d56580c806c493a50c8902fd2177074399"}], "stats": {"total": 711, "additions": 453, "deletions": 258}, "files": [{"sha": "a0724c0d4c51dec628d1387eb2aaf1eaee458328", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e187fa72fb4806da5b93af1d346446b9fc7f0993", "patch": "@@ -1,3 +1,66 @@\n+2012-07-16  Robert Dewar  <dewar@adacore.com>\n+\n+\t* freeze.adb, g-debpoo.adb, exp_ch3.adb: Minor reformatting.\n+\n+2012-07-16  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* s-oscons-tmplt.c: Add definitions of E2BIG and EILSEQ.\n+\n+2012-07-16  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* a-exexpr.adb (Propagate_Continue): New function replacing\n+\tRaise_Current_Excep.\n+\t(Allocate_Occurrence): New function.\n+\t(Propagate_Exception): Add Excep parameter, remove call to Call_Chain.\n+\t* a-exexpr-gcc.adb (GNAT_GCC_Exception): Occurrence component\n+\tis now aliased.\n+\t(To_GCC_Exception): Convert from Address.\n+\t(Allocate_Occurrence): Allocate an Unwind exception occurrence.\n+\t(Setup_Current_Excep): Fill the machine occurrence in case of\n+\tforeign exception.\n+\t(Propagate_Exception): Add Excep parameter, remove call to Call_Chain.\n+\t* a-except.adb (Set_Exception_C_Msg, Set_Exception_Msg): add\n+\tExcep parameter.\n+\t(Raise_Exception, Raise_Exception_Always,\n+\tRaise_Exception_No_Defer): Adjust calls to the above procedures.\n+\t(Raise_From_Signal_Handler, Raise_With_Location_And_Msg)\n+\t(Rcheck_PE_Finalize_Raised_Exception): Likewise.\n+\t* a-except-2005.adb (Set_Exception_C_Msg, Set_Exception_Msg):\n+\tadd Excep parameter.\n+\t(Propagate_Exception): Likewise.\n+\t(Allocate_Occurrence): New function.\n+\t(Raise_Current_Excep): Removed.\n+\t(Complete_Occurrence): New function to save the call chain.\n+\t(Complete_And_Propagate_Occurrence): New procedure.\n+\t(Create_Occurrence_From_Signal_Handler): New function to build an\n+\toccurrence without propagating it.\n+\t(Create_Machine_Occurrence_From_Signal_Handler): Likewise, but\n+\treturn the machine occurrence.\n+\t(Raise_From_Signal_Handler): Use Create_Occurrence_From_Signal_Handler.\n+\t(Raise_Exception, Raise_Exception_Always, Raise_Exception_No_Defer):\n+\tAdjust calls to the above procedures. Allocate the occurrence at\n+\tthe beginning.\n+\t(Raise_With_Location_And_Msg, Raise_With_Msg)\n+\t(Rcheck_PE_Finalize_Raised_Exceptionm Reraise): Likewise.\n+\t(Reraise_Occurrence): Use Reraise_Occurrence_Always.\n+\t(Reraise_Occurrence_Always): Use Reraise_Occurrence_No_Defer.\n+\t(Reraise_Occurrence_No_Defer): Preserve machine occurrence.\n+\t(Save_Occurrence): Do not save machine occurrence.\n+\t* a-except-2005.ads (Exception_Occurrence): Add Machine_Occurrence\n+\tcomponent.\n+\t(Null_Occurrence): Consider it.\n+\t* a-exexda.adb (Set_Exception_C_Msg, Set_Exception_Msg): add\n+\tExcep parameter.\n+\n+2012-07-16  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* seh_init.c (__gnat_map_SEH): New function extracted from\n+\t__gnat_SEH_error_handler.\n+\t* raise-gcc.c: __gnat_personality_seh0: Directly transforms\n+\tWindows system exception into GCC one when possible, in order\n+\tto save stack room (particularly useful when Storage_Error will\n+\tbe propagated).\n+\n 2012-07-16  Robert Dewar  <dewar@adacore.com>\n \n \t* a-direct.adb, g-dirope.adb: Minor reformatting."}, {"sha": "b7dcb0adc1a0bbe1b34dfbfa9e03ae373c51bc7d", "filename": "gcc/ada/a-except-2005.adb", "status": "modified", "additions": 166, "deletions": 71, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fa-except-2005.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fa-except-2005.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except-2005.adb?ref=e187fa72fb4806da5b93af1d346446b9fc7f0993", "patch": "@@ -116,26 +116,27 @@ package body Ada.Exceptions is\n       ---------------------------------\n \n       procedure Set_Exception_C_Msg\n-        (Id     : Exception_Id;\n+        (Excep  : EOA;\n+         Id     : Exception_Id;\n          Msg1   : System.Address;\n          Line   : Integer        := 0;\n          Column : Integer        := 0;\n          Msg2   : System.Address := System.Null_Address);\n-      --  This routine is called to setup the exception referenced by the\n-      --  Current_Excep field in the TSD to contain the indicated Id value\n-      --  and message. Msg1 is a null terminated string which is generated\n-      --  as the exception message. If line is non-zero, then a colon and\n-      --  the decimal representation of this integer is appended to the\n-      --  message. Ditto for Column. When Msg2 is non-null, a space and this\n-      --  additional null terminated string is added to the message.\n+      --  This routine is called to setup the exception referenced by X\n+      --  to contain the indicated Id value and message. Msg1 is a null\n+      --  terminated string which is generated as the exception message. If\n+      --  line is non-zero, then a colon and the decimal representation of\n+      --  this integer is appended to the message. Ditto for Column. When Msg2\n+      --  is non-null, a space and this additional null terminated string is\n+      --  added to the message.\n \n       procedure Set_Exception_Msg\n-        (Id      : Exception_Id;\n+        (Excep   : EOA;\n+         Id      : Exception_Id;\n          Message : String);\n-      --  This routine is called to setup the exception referenced by the\n-      --  Current_Excep field in the TSD to contain the indicated Id value\n-      --  and message. Message is a string which is generated as the\n-      --  exception message.\n+      --  This routine is called to setup the exception referenced by X\n+      --  to contain the indicated Id value and message. Message is a string\n+      --  which is generated as the exception message.\n \n       --------------------------------------\n       -- Exception information subprogram --\n@@ -232,18 +233,16 @@ package body Ada.Exceptions is\n \n    package Exception_Propagation is\n \n-      use Exception_Traces;\n-      --  Imports Notify_Unhandled_Exception and\n-      --  Unhandled_Exception_Terminate\n-\n       ------------------------------------\n       -- Exception propagation routines --\n       ------------------------------------\n \n-      procedure Propagate_Exception;\n+      function Allocate_Occurrence return EOA;\n+      --  Allocate an exception occurence (as well as the machine occurence)\n+\n+      procedure Propagate_Exception (Excep : EOA);\n       pragma No_Return (Propagate_Exception);\n-      --  This procedure propagates the exception represented by the occurrence\n-      --  referenced by Current_Excep in the TSD for the current task.\n+      --  This procedure propagates the exception represented by Excep\n \n    end Exception_Propagation;\n \n@@ -264,14 +263,30 @@ package body Ada.Exceptions is\n \n    end Stream_Attributes;\n \n-   procedure Raise_Current_Excep (E : Exception_Id);\n-   pragma No_Return (Raise_Current_Excep);\n-   pragma Export (C, Raise_Current_Excep, \"__gnat_raise_nodefer_with_msg\");\n-   --  This is a simple wrapper to Exception_Propagation.Propagate_Exception.\n-   --\n-   --  This external name for Raise_Current_Excep is historical, and probably\n-   --  should be changed but for now we keep it, because gdb and gigi know\n-   --  about it.\n+   procedure Complete_Occurrence (X : EOA);\n+   --  Finish building the occurrence: save the call chain and notify the\n+   --  debugger.\n+\n+   procedure Complete_And_Propagate_Occurrence (X : EOA);\n+   pragma No_Return (Complete_And_Propagate_Occurrence);\n+   --  This is a simple wrapper to Complete_Occurrence and\n+   --  Exception_Propagation.Propagate_Exception.\n+\n+   function Create_Occurrence_From_Signal_Handler\n+     (E : Exception_Id;\n+      M : System.Address)\n+     return EOA;\n+   --  Create and build an exception occurrence using exception id E and\n+   --  nul-terminated message M.\n+\n+   function Create_Machine_Occurrence_From_Signal_Handler\n+     (E : Exception_Id;\n+      M : System.Address)\n+     return System.Address;\n+   pragma Export (C, Create_Machine_Occurrence_From_Signal_Handler,\n+                  \"__gnat_create_machine_occurrence_from_signal_handler\");\n+   --  Create and build an exception occurrence using exception id E and\n+   --  nul-terminated message M. Return the machine occurrence.\n \n    procedure Raise_Exception_No_Defer\n       (E : Exception_Id; Message : String := \"\");\n@@ -372,7 +387,7 @@ package body Ada.Exceptions is\n    --                        |  |  |                  |\n    --                        |  |  |             Set_E_C_Msg(i)\n    --                        |  |  |\n-   --                   Raise_Current_Excep\n+   --            Complete_And_Propagate_Occurrence\n \n    procedure Reraise;\n    pragma No_Return (Reraise);\n@@ -887,14 +902,47 @@ package body Ada.Exceptions is\n    end Raise_Constraint_Error_Msg;\n \n    -------------------------\n-   -- Raise_Current_Excep --\n+   -- Complete_Occurrence --\n    -------------------------\n \n-   procedure Raise_Current_Excep (E : Exception_Id) is\n+   procedure Complete_Occurrence (X : EOA) is\n+   begin\n+      --  Compute the backtrace for this occurrence if the corresponding\n+      --  binder option has been set. Call_Chain takes care of the reraise\n+      --  case.\n+\n+      --  ??? Using Call_Chain here means we are going to walk up the stack\n+      --  once only for backtracing purposes before doing it again for the\n+      --  propagation per se.\n+\n+      --  The first inspection is much lighter, though, as it only requires\n+      --  partial unwinding of each frame. Additionally, although we could use\n+      --  the personality routine to record the addresses while propagating,\n+      --  this method has two drawbacks:\n+\n+      --  1) the trace is incomplete if the exception is handled since we\n+      --  don't walk past the frame with the handler,\n+\n+      --    and\n+\n+      --  2) we would miss the frames for which our personality routine is not\n+      --  called, e.g. if C or C++ calls are on the way.\n+\n+      Call_Chain (X);\n+\n+      --  Notify the debugger\n+      Debug_Raise_Exception (E => SSL.Exception_Data_Ptr (X.Id));\n+   end Complete_Occurrence;\n+\n+   ---------------------------------------\n+   -- Complete_And_Propagate_Occurrence --\n+   ---------------------------------------\n+\n+   procedure Complete_And_Propagate_Occurrence (X : EOA) is\n    begin\n-      Debug_Raise_Exception (E => SSL.Exception_Data_Ptr (E));\n-      Exception_Propagation.Propagate_Exception;\n-   end Raise_Current_Excep;\n+      Complete_Occurrence (X);\n+      Exception_Propagation.Propagate_Exception (X);\n+   end Complete_And_Propagate_Occurrence;\n \n    ---------------------\n    -- Raise_Exception --\n@@ -905,6 +953,7 @@ package body Ada.Exceptions is\n       Message : String := \"\")\n    is\n       EF : Exception_Id := E;\n+      X : constant EOA := Exception_Propagation.Allocate_Occurrence;\n \n    begin\n       --  Raise CE if E = Null_ID (AI-446)\n@@ -915,13 +964,14 @@ package body Ada.Exceptions is\n \n       --  Go ahead and raise appropriate exception\n \n-      Exception_Data.Set_Exception_Msg (EF, Message);\n+      Exception_Data.Set_Exception_Msg (X, EF, Message);\n \n       if not ZCX_By_Default then\n          Abort_Defer.all;\n       end if;\n \n-      Raise_Current_Excep (EF);\n+      Complete_Occurrence (X);\n+      Exception_Propagation.Propagate_Exception (X);\n    end Raise_Exception;\n \n    ----------------------------\n@@ -932,12 +982,13 @@ package body Ada.Exceptions is\n      (E       : Exception_Id;\n       Message : String := \"\")\n    is\n+      X : constant EOA := Exception_Propagation.Allocate_Occurrence;\n    begin\n-      Exception_Data.Set_Exception_Msg (E, Message);\n+      Exception_Data.Set_Exception_Msg (X, E, Message);\n       if not ZCX_By_Default then\n          Abort_Defer.all;\n       end if;\n-      Raise_Current_Excep (E);\n+      Complete_And_Propagate_Occurrence (X);\n    end Raise_Exception_Always;\n \n    ------------------------------\n@@ -948,12 +999,13 @@ package body Ada.Exceptions is\n      (E       : Exception_Id;\n       Message : String := \"\")\n    is\n+      X : constant EOA := Exception_Propagation.Allocate_Occurrence;\n    begin\n-      Exception_Data.Set_Exception_Msg (E, Message);\n+      Exception_Data.Set_Exception_Msg (X, E, Message);\n \n       --  Do not call Abort_Defer.all, as specified by the spec\n \n-      Raise_Current_Excep (E);\n+      Complete_And_Propagate_Occurrence (X);\n    end Raise_Exception_No_Defer;\n \n    -------------------------------------\n@@ -1001,22 +1053,51 @@ package body Ada.Exceptions is\n       end if;\n    end Raise_From_Controlled_Operation;\n \n-   -------------------------------\n-   -- Raise_From_Signal_Handler --\n-   -------------------------------\n+   -------------------------------------------\n+   -- Create_Occurrence_From_Signal_Handler --\n+   -------------------------------------------\n \n-   procedure Raise_From_Signal_Handler\n+   function Create_Occurrence_From_Signal_Handler\n      (E : Exception_Id;\n       M : System.Address)\n+     return EOA\n    is\n+      X : constant EOA := Exception_Propagation.Allocate_Occurrence;\n    begin\n-      Exception_Data.Set_Exception_C_Msg (E, M);\n+      Exception_Data.Set_Exception_C_Msg (X, E, M);\n \n       if not ZCX_By_Default then\n          Abort_Defer.all;\n       end if;\n \n-      Raise_Current_Excep (E);\n+      Complete_Occurrence (X);\n+      return X;\n+   end Create_Occurrence_From_Signal_Handler;\n+\n+   ---------------------------------------------------\n+   -- Create_Machine_Occurrence_From_Signal_Handler --\n+   ---------------------------------------------------\n+\n+   function Create_Machine_Occurrence_From_Signal_Handler\n+     (E : Exception_Id;\n+      M : System.Address)\n+     return System.Address\n+   is\n+   begin\n+      return Create_Occurrence_From_Signal_Handler (E, M).Machine_Occurrence;\n+   end Create_Machine_Occurrence_From_Signal_Handler;\n+\n+   -------------------------------\n+   -- Raise_From_Signal_Handler --\n+   -------------------------------\n+\n+   procedure Raise_From_Signal_Handler\n+     (E : Exception_Id;\n+      M : System.Address)\n+   is\n+   begin\n+      Exception_Propagation.Propagate_Exception\n+        (Create_Occurrence_From_Signal_Handler (E, M));\n    end Raise_From_Signal_Handler;\n \n    -------------------------\n@@ -1082,37 +1163,44 @@ package body Ada.Exceptions is\n       C : Integer := 0;\n       M : System.Address := System.Null_Address)\n    is\n+      X : constant EOA := Exception_Propagation.Allocate_Occurrence;\n    begin\n-      Exception_Data.Set_Exception_C_Msg (E, F, L, C, M);\n+      Exception_Data.Set_Exception_C_Msg (X, E, F, L, C, M);\n \n       if not ZCX_By_Default then\n          Abort_Defer.all;\n       end if;\n \n-      Raise_Current_Excep (E);\n+      Complete_And_Propagate_Occurrence (X);\n    end Raise_With_Location_And_Msg;\n \n    --------------------\n    -- Raise_With_Msg --\n    --------------------\n \n    procedure Raise_With_Msg (E : Exception_Id) is\n-      Excep : constant EOA := Get_Current_Excep.all;\n-\n+      Excep : constant EOA := Exception_Propagation.Allocate_Occurrence;\n+      Ex    : constant Exception_Occurrence_Access := Get_Current_Excep.all;\n    begin\n       Excep.Exception_Raised := False;\n       Excep.Id               := E;\n       Excep.Num_Tracebacks   := 0;\n       Excep.Pid              := Local_Partition_ID;\n \n+      --  Copy the message from the current exception\n+      --  Change the interface to be called with an occurrence ???\n+\n+      Excep.Msg_Length                  := Ex.Msg_Length;\n+      Excep.Msg (1 .. Excep.Msg_Length) := Ex.Msg (1 .. Ex.Msg_Length);\n+\n       --  The following is a common pattern, should be abstracted\n       --  into a procedure call ???\n \n       if not ZCX_By_Default then\n          Abort_Defer.all;\n       end if;\n \n-      Raise_Current_Excep (E);\n+      Complete_And_Propagate_Occurrence (Excep);\n    end Raise_With_Msg;\n \n    --------------------------------------\n@@ -1400,7 +1488,7 @@ package body Ada.Exceptions is\n    procedure Rcheck_PE_Finalize_Raised_Exception\n      (File : System.Address; Line : Integer)\n    is\n-      E : constant Exception_Id := Program_Error_Def'Access;\n+      X : constant EOA := Exception_Propagation.Allocate_Occurrence;\n \n    begin\n       --  This is \"finalize/adjust raised exception\". This subprogram is always\n@@ -1409,21 +1497,25 @@ package body Ada.Exceptions is\n \n       --  This is consistent with Raise_From_Controlled_Operation\n \n-      Exception_Data.Set_Exception_C_Msg (E, File, Line, 0, Rmsg_22'Address);\n-      Raise_Current_Excep (E);\n+      Exception_Data.Set_Exception_C_Msg\n+        (X, Program_Error_Def'Access, File, Line, 0, Rmsg_22'Address);\n+      Complete_And_Propagate_Occurrence (X);\n    end Rcheck_PE_Finalize_Raised_Exception;\n \n    -------------\n    -- Reraise --\n    -------------\n \n    procedure Reraise is\n-      Excep : constant EOA := Get_Current_Excep.all;\n+      Excep    : constant EOA := Exception_Propagation.Allocate_Occurrence;\n+      Saved_MO : constant System.Address := Excep.Machine_Occurrence;\n    begin\n       if not ZCX_By_Default then\n          Abort_Defer.all;\n       end if;\n-      Raise_Current_Excep (Excep.Id);\n+      Save_Occurrence (Excep.all, Get_Current_Excep.all.all);\n+      Excep.Machine_Occurrence := Saved_MO;\n+      Complete_And_Propagate_Occurrence (Excep);\n    end Reraise;\n \n    --------------------------------------\n@@ -1451,14 +1543,11 @@ package body Ada.Exceptions is\n \n    procedure Reraise_Occurrence (X : Exception_Occurrence) is\n    begin\n-      if X.Id /= null then\n-         if not ZCX_By_Default then\n-            Abort_Defer.all;\n-         end if;\n-\n-         Save_Occurrence (Get_Current_Excep.all.all, X);\n-         Raise_Current_Excep (X.Id);\n+      if X.Id = null then\n+         return;\n       end if;\n+\n+      Reraise_Occurrence_Always (X);\n    end Reraise_Occurrence;\n \n    -------------------------------\n@@ -1471,18 +1560,20 @@ package body Ada.Exceptions is\n          Abort_Defer.all;\n       end if;\n \n-      Save_Occurrence (Get_Current_Excep.all.all, X);\n-      Raise_Current_Excep (X.Id);\n+      Reraise_Occurrence_No_Defer (X);\n    end Reraise_Occurrence_Always;\n \n    ---------------------------------\n    -- Reraise_Occurrence_No_Defer --\n    ---------------------------------\n \n    procedure Reraise_Occurrence_No_Defer (X : Exception_Occurrence) is\n+      Excep    : constant EOA := Exception_Propagation.Allocate_Occurrence;\n+      Saved_MO : constant System.Address := Excep.Machine_Occurrence;\n    begin\n-      Save_Occurrence (Get_Current_Excep.all.all, X);\n-      Raise_Current_Excep (X.Id);\n+      Save_Occurrence (Excep.all, X);\n+      Excep.Machine_Occurrence := Saved_MO;\n+      Complete_And_Propagate_Occurrence (Excep);\n    end Reraise_Occurrence_No_Defer;\n \n    ---------------------\n@@ -1494,10 +1585,14 @@ package body Ada.Exceptions is\n       Source : Exception_Occurrence)\n    is\n    begin\n-      Target.Id             := Source.Id;\n-      Target.Msg_Length     := Source.Msg_Length;\n-      Target.Num_Tracebacks := Source.Num_Tracebacks;\n-      Target.Pid            := Source.Pid;\n+      --  As the machine occurrence might be a data that must be finalized\n+      --  (outside any Ada mechanism), do not copy it\n+\n+      Target.Id                 := Source.Id;\n+      Target.Machine_Occurrence := System.Null_Address;\n+      Target.Msg_Length         := Source.Msg_Length;\n+      Target.Num_Tracebacks     := Source.Num_Tracebacks;\n+      Target.Pid                := Source.Pid;\n \n       Target.Msg (1 .. Target.Msg_Length) :=\n         Source.Msg (1 .. Target.Msg_Length);"}, {"sha": "bb597ed09820b826e4f566c3e5c24ab8c253ea48", "filename": "gcc/ada/a-except-2005.ads", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fa-except-2005.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fa-except-2005.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except-2005.ads?ref=e187fa72fb4806da5b93af1d346446b9fc7f0993", "patch": "@@ -302,6 +302,10 @@ private\n       Id : Exception_Id;\n       --  Exception_Identity for this exception occurrence\n \n+      Machine_Occurrence : System.Address;\n+      --  The underlying machine occurrence. For GCC, this corresponds to the\n+      --  _Unwind_Exception structure address.\n+\n       Msg_Length : Natural := 0;\n       --  Length of message (zero = no message)\n \n@@ -339,12 +343,13 @@ private\n    --  Functions for implementing Exception_Occurrence stream attributes\n \n    Null_Occurrence : constant Exception_Occurrence := (\n-     Id               => null,\n-     Msg_Length       => 0,\n-     Msg              => (others => ' '),\n-     Exception_Raised => False,\n-     Pid              => 0,\n-     Num_Tracebacks   => 0,\n-     Tracebacks       => (others => TBE.Null_TB_Entry));\n+     Id                 => null,\n+     Machine_Occurrence => System.Null_Address,\n+     Msg_Length         => 0,\n+     Msg                => (others => ' '),\n+     Exception_Raised   => False,\n+     Pid                => 0,\n+     Num_Tracebacks     => 0,\n+     Tracebacks         => (others => TBE.Null_TB_Entry));\n \n end Ada.Exceptions;"}, {"sha": "1201ab0a443e6fd433815834b550a234f5435212", "filename": "gcc/ada/a-except.adb", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fa-except.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fa-except.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-except.adb?ref=e187fa72fb4806da5b93af1d346446b9fc7f0993", "patch": "@@ -93,7 +93,8 @@ package body Ada.Exceptions is\n       ---------------------------------\n \n       procedure Set_Exception_C_Msg\n-        (Id     : Exception_Id;\n+        (Excep  : EOA;\n+         Id     : Exception_Id;\n          Msg1   : System.Address;\n          Line   : Integer        := 0;\n          Column : Integer        := 0;\n@@ -107,7 +108,8 @@ package body Ada.Exceptions is\n       --  additional null terminated string is added to the message.\n \n       procedure Set_Exception_Msg\n-        (Id      : Exception_Id;\n+        (Excep   : EOA;\n+         Id      : Exception_Id;\n          Message : String);\n       --  This routine is called to setup the exception referenced by the\n       --  Current_Excep field in the TSD to contain the indicated Id value and\n@@ -966,8 +968,8 @@ package body Ada.Exceptions is\n      (E       : Exception_Id;\n       Message : String := \"\")\n    is\n-      EF : Exception_Id := E;\n-\n+      EF    : Exception_Id := E;\n+      Excep : constant EOA := Get_Current_Excep.all;\n    begin\n       --  Raise CE if E = Null_ID (AI-446)\n \n@@ -977,7 +979,7 @@ package body Ada.Exceptions is\n \n       --  Go ahead and raise appropriate exception\n \n-      Exception_Data.Set_Exception_Msg (EF, Message);\n+      Exception_Data.Set_Exception_Msg (Excep, EF, Message);\n       Abort_Defer.all;\n       Raise_Current_Excep (EF);\n    end Raise_Exception;\n@@ -990,8 +992,9 @@ package body Ada.Exceptions is\n      (E       : Exception_Id;\n       Message : String := \"\")\n    is\n+      Excep : constant EOA := Get_Current_Excep.all;\n    begin\n-      Exception_Data.Set_Exception_Msg (E, Message);\n+      Exception_Data.Set_Exception_Msg (Excep, E, Message);\n       Abort_Defer.all;\n       Raise_Current_Excep (E);\n    end Raise_Exception_Always;\n@@ -1004,8 +1007,9 @@ package body Ada.Exceptions is\n      (E       : Exception_Id;\n       Message : String := \"\")\n    is\n+      Excep : constant EOA := Get_Current_Excep.all;\n    begin\n-      Exception_Data.Set_Exception_Msg (E, Message);\n+      Exception_Data.Set_Exception_Msg (Excep, E, Message);\n \n       --  Do not call Abort_Defer.all, as specified by the spec\n \n@@ -1065,8 +1069,9 @@ package body Ada.Exceptions is\n      (E : Exception_Id;\n       M : System.Address)\n    is\n+      Excep : constant EOA := Get_Current_Excep.all;\n    begin\n-      Exception_Data.Set_Exception_C_Msg (E, M);\n+      Exception_Data.Set_Exception_C_Msg (Excep, E, M);\n       Abort_Defer.all;\n       Process_Raise_Exception (E);\n    end Raise_From_Signal_Handler;\n@@ -1135,8 +1140,9 @@ package body Ada.Exceptions is\n       L : Integer;\n       M : System.Address := System.Null_Address)\n    is\n+      Excep : constant EOA := Get_Current_Excep.all;\n    begin\n-      Exception_Data.Set_Exception_C_Msg (E, F, L, Msg2 => M);\n+      Exception_Data.Set_Exception_C_Msg (Excep, E, F, L, Msg2 => M);\n       Abort_Defer.all;\n       Raise_Current_Excep (E);\n    end Raise_With_Location_And_Msg;\n@@ -1402,16 +1408,17 @@ package body Ada.Exceptions is\n    procedure Rcheck_PE_Finalize_Raised_Exception\n      (File : System.Address; Line : Integer)\n    is\n-      E : constant Exception_Id := Program_Error_Def'Access;\n-\n+      E     : constant Exception_Id := Program_Error_Def'Access;\n+      Excep : constant EOA := Get_Current_Excep.all;\n    begin\n       --  This is \"finalize/adjust raised exception\". This subprogram is always\n       --  called with abort deferred, unlike all other Rcheck_* routines, it\n       --  needs to call Raise_Exception_No_Defer.\n \n       --  This is consistent with Raise_From_Controlled_Operation\n \n-      Exception_Data.Set_Exception_C_Msg (E, File, Line, 0, Rmsg_22'Address);\n+      Exception_Data.Set_Exception_C_Msg (Excep, E, File, Line, 0,\n+                                          Rmsg_22'Address);\n       Raise_Current_Excep (E);\n    end Rcheck_PE_Finalize_Raised_Exception;\n "}, {"sha": "aa91cdcfe8fa410a4fa3c2d7981491ec82f662a3", "filename": "gcc/ada/a-exexda.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fa-exexda.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fa-exexda.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexda.adb?ref=e187fa72fb4806da5b93af1d346446b9fc7f0993", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -558,13 +558,13 @@ package body Exception_Data is\n    -------------------------\n \n    procedure Set_Exception_C_Msg\n-     (Id     : Exception_Id;\n+     (Excep  : EOA;\n+      Id     : Exception_Id;\n       Msg1   : System.Address;\n       Line   : Integer        := 0;\n       Column : Integer        := 0;\n       Msg2   : System.Address := System.Null_Address)\n    is\n-      Excep  : constant EOA := Get_Current_Excep.all;\n       Remind : Integer;\n       Ptr    : Natural;\n \n@@ -654,13 +654,13 @@ package body Exception_Data is\n    -----------------------\n \n    procedure Set_Exception_Msg\n-     (Id      : Exception_Id;\n+     (Excep   : EOA;\n+      Id      : Exception_Id;\n       Message : String)\n    is\n       Len   : constant Natural :=\n                 Natural'Min (Message'Length, Exception_Msg_Max_Length);\n       First : constant Integer := Message'First;\n-      Excep : constant EOA     := Get_Current_Excep.all;\n    begin\n       Excep.Exception_Raised := False;\n       Excep.Msg_Length       := Len;"}, {"sha": "10e91bf1e64fdf5e5c4b00e29b9919fe8130c836", "filename": "gcc/ada/a-exexpr-gcc.adb", "status": "modified", "additions": 26, "deletions": 46, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fa-exexpr-gcc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fa-exexpr-gcc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexpr-gcc.adb?ref=e187fa72fb4806da5b93af1d346446b9fc7f0993", "patch": "@@ -39,6 +39,8 @@ with System.Storage_Elements;  use System.Storage_Elements;\n separate (Ada.Exceptions)\n package body Exception_Propagation is\n \n+   use Exception_Traces;\n+\n    ------------------------------------------------\n    -- Entities to interface with the GCC runtime --\n    ------------------------------------------------\n@@ -110,7 +112,7 @@ package body Exception_Propagation is\n       Private2 : Unwind_Word;\n \n       --  Usual exception structure has only two private fields, but the SEH\n-      --  one has six. To avoid makeing this file more complex, we use six\n+      --  one has six. To avoid making this file more complex, we use six\n       --  fields on all platforms, wasting a few bytes on some.\n \n       Private3 : Unwind_Word;\n@@ -151,7 +153,7 @@ package body Exception_Propagation is\n       Header : Unwind_Exception;\n       --  ABI Exception header first\n \n-      Occurrence : Exception_Occurrence;\n+      Occurrence : aliased Exception_Occurrence;\n       --  The Ada occurrence\n    end record;\n \n@@ -177,7 +179,7 @@ package body Exception_Propagation is\n    type GNAT_GCC_Exception_Access is access all GNAT_GCC_Exception;\n \n    function To_GCC_Exception is new\n-     Unchecked_Conversion (GNAT_GCC_Exception_Access, GCC_Exception_Access);\n+     Unchecked_Conversion (System.Address, GCC_Exception_Access);\n \n    function To_GNAT_GCC_Exception is new\n      Unchecked_Conversion (GCC_Exception_Access, GNAT_GCC_Exception_Access);\n@@ -297,6 +299,24 @@ package body Exception_Propagation is\n    --  exceptions on targets which always handle exceptions (such as SEH).\n    --  The handler will simply call Unhandled_Except_Handler.\n \n+   -------------------------\n+   -- Allocate_Occurrence --\n+   -------------------------\n+\n+   function Allocate_Occurrence return EOA is\n+      Res : GNAT_GCC_Exception_Access;\n+   begin\n+      Res :=\n+        new GNAT_GCC_Exception'\n+        (Header     => (Class   => GNAT_Exception_Class,\n+                        Cleanup => GNAT_GCC_Exception_Cleanup'Address,\n+                        others  => 0),\n+         Occurrence => (others => <>));\n+      Res.Occurrence.Machine_Occurrence := Res.all'Address;\n+\n+      return Res.Occurrence'Access;\n+   end Allocate_Occurrence;\n+\n    --------------------------------\n    -- GNAT_GCC_Exception_Cleanup --\n    --------------------------------\n@@ -345,6 +365,7 @@ package body Exception_Propagation is\n          --  A default one\n \n          Excep.Id := Foreign_Exception'Access;\n+         Excep.Machine_Occurrence := GCC_Exception.all'Address;\n          Excep.Msg_Length := 0;\n          Excep.Exception_Raised := True;\n          Excep.Pid := Local_Partition_ID;\n@@ -433,50 +454,9 @@ package body Exception_Propagation is\n    -- Propagate_Exception --\n    -------------------------\n \n-   --  Build an object suitable for the libgcc processing and call\n-   --  Unwind_RaiseException to actually do the raise, taking care of\n-   --  handling the two phase scheme it implements.\n-\n-   procedure Propagate_Exception is\n-      Excep         : constant EOA := Get_Current_Excep.all;\n-      GCC_Exception : GNAT_GCC_Exception_Access;\n-\n+   procedure Propagate_Exception (Excep : EOA) is\n    begin\n-      --  Compute the backtrace for this occurrence if the corresponding\n-      --  binder option has been set. Call_Chain takes care of the reraise\n-      --  case.\n-\n-      --  ??? Using Call_Chain here means we are going to walk up the stack\n-      --  once only for backtracing purposes before doing it again for the\n-      --  propagation per se.\n-\n-      --  The first inspection is much lighter, though, as it only requires\n-      --  partial unwinding of each frame. Additionally, although we could use\n-      --  the personality routine to record the addresses while propagating,\n-      --  this method has two drawbacks:\n-\n-      --  1) the trace is incomplete if the exception is handled since we\n-      --  don't walk past the frame with the handler,\n-\n-      --    and\n-\n-      --  2) we would miss the frames for which our personality routine is not\n-      --  called, e.g. if C or C++ calls are on the way.\n-\n-      Call_Chain (Excep);\n-\n-      --  Allocate the GCC exception\n-\n-      GCC_Exception :=\n-        new GNAT_GCC_Exception'\n-          (Header     => (Class   => GNAT_Exception_Class,\n-                          Cleanup => GNAT_GCC_Exception_Cleanup'Address,\n-                          others  => 0),\n-           Occurrence => Excep.all);\n-\n-      --  Propagate it\n-\n-      Propagate_GCC_Exception (To_GCC_Exception (GCC_Exception));\n+      Propagate_GCC_Exception (To_GCC_Exception (Excep.Machine_Occurrence));\n    end Propagate_Exception;\n \n    ------------------------------"}, {"sha": "ccedcb2d1ef5a1f0ba014ca70c49e323dabd5b82", "filename": "gcc/ada/a-exexpr.adb", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fa-exexpr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fa-exexpr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexpr.adb?ref=e187fa72fb4806da5b93af1d346446b9fc7f0993", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -43,42 +43,29 @@ package body Exception_Propagation is\n    pragma No_Return (builtin_longjmp);\n    pragma Import (Intrinsic, builtin_longjmp, \"__builtin_longjmp\");\n \n+   procedure Propagate_Continue (Excep : EOA);\n+   pragma No_Return (Propagate_Continue);\n+   pragma Export (C, Propagate_Continue, \"__gnat_raise_nodefer_with_msg\");\n+   --  A call to this procedure is inserted automatically by GIGI, in order\n+   --  to continue the propagation when the exception was not handled.\n+   --  The linkage name is historical.\n+\n    -------------------------\n-   -- Propagate_Exception --\n+   -- Allocate_Occurrence --\n    -------------------------\n \n-   procedure Propagate_Exception\n-   is\n-      Jumpbuf_Ptr : constant Address := Get_Jmpbuf_Address.all;\n-      Excep       : constant EOA := Get_Current_Excep.all;\n+   function Allocate_Occurrence return EOA is\n    begin\n-      --  Compute the backtrace for this occurrence if corresponding binder\n-      --  option has been set. Call_Chain takes care of the reraise case.\n-\n-      Call_Chain (Excep);\n-\n-      --  Note on above call to Call_Chain:\n-\n-      --  We used to only do this if From_Signal_Handler was not set,\n-      --  based on the assumption that backtracing from a signal handler\n-      --  would not work due to stack layout oddities. However, since\n-\n-      --   1. The flag is never set in tasking programs (Notify_Exception\n-      --      performs regular raise statements), and\n-\n-      --   2. No problem has shown up in tasking programs around here so\n-      --      far, this turned out to be too strong an assumption.\n-\n-      --  As, in addition, the test was\n-\n-      --   1. preventing the production of backtraces in non-tasking\n-      --      programs, and\n+      return Get_Current_Excep.all;\n+   end Allocate_Occurrence;\n \n-      --   2. introducing a behavior inconsistency between\n-      --      the tasking and non-tasking cases,\n-\n-      --  we have simply removed it\n+   -------------------------\n+   -- Propagate_Exception --\n+   -------------------------\n \n+   procedure Propagate_Exception (Excep : EOA) is\n+      Jumpbuf_Ptr : constant Address := Get_Jmpbuf_Address.all;\n+   begin\n       --  If the jump buffer pointer is non-null, transfer control using\n       --  it. Otherwise announce an unhandled exception (note that this\n       --  means that we have no finalizations to do other than at the outer\n@@ -98,4 +85,13 @@ package body Exception_Propagation is\n       end if;\n    end Propagate_Exception;\n \n+   ------------------------\n+   -- Propagate_Continue --\n+   ------------------------\n+\n+   procedure Propagate_Continue (Excep : EOA) is\n+   begin\n+      Propagate_Exception (Excep);\n+   end Propagate_Continue;\n+\n end Exception_Propagation;"}, {"sha": "e39b10dbb6182c8b5e6637a6b4543d64c01a1a25", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=e187fa72fb4806da5b93af1d346446b9fc7f0993", "patch": "@@ -772,18 +772,19 @@ package body Exp_Ch3 is\n    --------------------------------\n \n    procedure Build_Array_Invariant_Proc (A_Type : Entity_Id; Nod : Node_Id) is\n-      Loc              : constant Source_Ptr := Sloc (Nod);\n-      Object_Name      : constant Name_Id := New_Internal_Name ('I');\n+      Loc : constant Source_Ptr := Sloc (Nod);\n+\n+      Object_Name : constant Name_Id := New_Internal_Name ('I');\n       --  Name for argument of invariant procedure\n \n       Object_Entity : constant Node_Id :=\n                         Make_Defining_Identifier (Loc, Object_Name);\n       --  The procedure declaration entity for the argument\n \n-      Body_Stmts       : List_Id;\n-      Index_List       : List_Id;\n-      Proc_Id          : Entity_Id;\n-      Proc_Body        : Node_Id;\n+      Body_Stmts : List_Id;\n+      Index_List : List_Id;\n+      Proc_Id    : Entity_Id;\n+      Proc_Body  : Node_Id;\n \n       function Build_Component_Invariant_Call return Node_Id;\n       --  Create one statement to verify invariant on one array component,\n@@ -803,19 +804,17 @@ package body Exp_Ch3 is\n \n       function Build_Component_Invariant_Call return Node_Id is\n          Comp : Node_Id;\n-\n       begin\n          Comp :=\n            Make_Indexed_Component (Loc,\n              Prefix      => New_Occurrence_Of (Object_Entity, Loc),\n-                                   Expressions => Index_List);\n+             Expressions => Index_List);\n          return\n            Make_Procedure_Call_Statement (Loc,\n              Name                   =>\n                New_Occurrence_Of\n                  (Invariant_Procedure (Component_Type (A_Type)), Loc),\n              Parameter_Associations => New_List (Comp));\n-\n       end Build_Component_Invariant_Call;\n \n       -------------------------\n@@ -826,8 +825,8 @@ package body Exp_Ch3 is\n          Index : Entity_Id;\n \n       begin\n-         --  If all dimensions dealt with, we simply check invariant of\n-         --  the component\n+         --  If all dimensions dealt with, we simply check invariant of the\n+         --  component.\n \n          if N > Number_Dimensions (A_Type) then\n             return New_List (Build_Component_Invariant_Call);\n@@ -842,19 +841,20 @@ package body Exp_Ch3 is\n \n             return New_List (\n               Make_Implicit_Loop_Statement (Nod,\n-                Identifier => Empty,\n+                Identifier       => Empty,\n                 Iteration_Scheme =>\n                   Make_Iteration_Scheme (Loc,\n                     Loop_Parameter_Specification =>\n                       Make_Loop_Parameter_Specification (Loc,\n-                        Defining_Identifier => Index,\n+                        Defining_Identifier         => Index,\n                         Discrete_Subtype_Definition =>\n                           Make_Attribute_Reference (Loc,\n-                            Prefix => New_Occurrence_Of (Object_Entity, Loc),\n+                            Prefix          =>\n+                              New_Occurrence_Of (Object_Entity, Loc),\n                             Attribute_Name  => Name_Range,\n                             Expressions     => New_List (\n                               Make_Integer_Literal (Loc, N))))),\n-                Statements =>  Check_One_Dimension (N + 1)));\n+                Statements       =>  Check_One_Dimension (N + 1)));\n          end if;\n       end Check_One_Dimension;\n \n@@ -875,13 +875,13 @@ package body Exp_Ch3 is\n         Make_Subprogram_Body (Loc,\n           Specification =>\n             Make_Procedure_Specification (Loc,\n-              Defining_Unit_Name => Proc_Id,\n+              Defining_Unit_Name       => Proc_Id,\n               Parameter_Specifications => New_List (\n                 Make_Parameter_Specification (Loc,\n                   Defining_Identifier => Object_Entity,\n                   Parameter_Type      => New_Occurrence_Of (A_Type, Loc)))),\n \n-          Declarations => New_List,\n+          Declarations               => Empty_List,\n           Handled_Statement_Sequence =>\n             Make_Handled_Sequence_Of_Statements (Loc,\n               Statements => Body_Stmts));"}, {"sha": "3a34fbe6bfd0d24b335d19deeb2e499b7e58af8a", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=e187fa72fb4806da5b93af1d346446b9fc7f0993", "patch": "@@ -3898,15 +3898,13 @@ package body Freeze is\n                end;\n             end if;\n \n-         --  For a record (sub)type, freeze all the component types (RM\n-         --  13.14(15). We test for E_Record_(sub)Type here, rather than using\n-         --  Is_Record_Type, because we don't want to attempt the freeze for\n-         --  the case of a private type with record extension (we will do that\n-         --  later when the full type is frozen).\n-\n-         elsif Ekind (E) = E_Record_Type\n-           or else Ekind (E) = E_Record_Subtype\n-         then\n+         --  For a record type or record subtype, freeze all component types\n+         --  (RM 13.14(15)). We test for E_Record_(sub)Type here, rather than\n+         --  using Is_Record_Type, because we don't want to attempt the freeze\n+         --  for the case of a private type with record extension (we will do\n+         --  that later when the full type is frozen).\n+\n+         elsif Ekind_In (E, E_Record_Type, E_Record_Subtype) then\n             Freeze_Record_Type (E);\n \n          --  For a concurrent type, freeze corresponding record type. This"}, {"sha": "5ee63d9896f140ad64f5e50db37aeca1ac91758d", "filename": "gcc/ada/g-debpoo.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fg-debpoo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fg-debpoo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-debpoo.adb?ref=e187fa72fb4806da5b93af1d346446b9fc7f0993", "patch": "@@ -692,7 +692,9 @@ package body GNAT.Debug_Pools is\n       --  Use standard (i.e. through malloc) allocations. This automatically\n       --  raises Storage_Error if needed. We also try once more to physically\n       --  release memory, so that even marked blocks, in the advanced scanning,\n-      --  are freed.\n+      --  are freed. Note that we do not initialize the storage array since it\n+      --  is not necessary to do so (however this will cause bogus valgrind\n+      --  warnings, which should simply be ignored).\n \n       begin\n          P := new Local_Storage_Array;"}, {"sha": "8aef5b09247310bfb458fc8bb1f164377edfb62b", "filename": "gcc/ada/raise-gcc.c", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fraise-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fraise-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise-gcc.c?ref=e187fa72fb4806da5b93af1d346446b9fc7f0993", "patch": "@@ -1213,9 +1213,23 @@ __gnat_Unwind_ForcedUnwind (_Unwind_Exception *e,\n #ifdef __SEH__\n \n #define STATUS_USER_DEFINED\t\t(1U << 29)\n+\n+/* From unwind-seh.c.  */\n+#define GCC_MAGIC\t\t\t(('G' << 16) | ('C' << 8) | 'C')\n+#define GCC_EXCEPTION(TYPE)\t\t\\\n+       (STATUS_USER_DEFINED | ((TYPE) << 24) | GCC_MAGIC)\n+#define STATUS_GCC_THROW\t\tGCC_EXCEPTION (0)\n+\n EXCEPTION_DISPOSITION __gnat_SEH_error_handler\n  (struct _EXCEPTION_RECORD*, void*, struct _CONTEXT*, void*);\n \n+struct Exception_Data *\n+__gnat_map_SEH (EXCEPTION_RECORD* ExceptionRecord, const char **msg);\n+\n+struct _Unwind_Exception *\n+__gnat_create_machine_occurrence_from_signal_handler (Exception_Id,\n+\t\t\t\t\t\t      const char *);\n+\n /* Unwind opcodes.  */\n #define UWOP_PUSH_NONVOL 0\n #define UWOP_ALLOC_LARGE 1\n@@ -1295,7 +1309,10 @@ __gnat_personality_seh0 (PEXCEPTION_RECORD ms_exc, void *this_frame,\n      exceptions.  */\n   if (!(ms_exc->ExceptionCode & STATUS_USER_DEFINED))\n     {\n+      struct Exception_Data *exception;\n+      const char *msg;\n       ULONG64 excpip = (ULONG64) ms_exc->ExceptionAddress;\n+\n       if (excpip != 0\n \t  && excpip >= (ms_disp->ImageBase\n \t\t\t+ ms_disp->FunctionEntry->BeginAddress)\n@@ -1353,7 +1370,26 @@ __gnat_personality_seh0 (PEXCEPTION_RECORD ms_exc, void *this_frame,\n \t    __gnat_adjust_context\n \t      ((unsigned char *)(mf_imagebase + mf_func->UnwindData), mf_rsp);\n \t}\n-      __gnat_SEH_error_handler (ms_exc, this_frame, ms_orig_context, ms_disp);\n+\n+      exception = __gnat_map_SEH (ms_exc, &msg);\n+      if (exception != NULL)\n+\t{\n+\t  struct _Unwind_Exception *exc;\n+\n+\t  /* Directly convert the system exception to a GCC one.\n+\t     This is really breaking the API, but is necessary for stack size\n+\t     reasons: the normal way is to call Raise_From_Signal_Handler,\n+\t     which build the exception and calls _Unwind_RaiseException, which\n+\t     unwinds the stack and will call this personality routine. But\n+\t     the Windows unwinder needs about 2KB of stack.  */\n+\t  exc = __gnat_create_machine_occurrence_from_signal_handler\n+\t    (exception, msg);\n+\t  memset (exc->private_, 0, sizeof (exc->private_));\n+\t  ms_exc->ExceptionCode = STATUS_GCC_THROW;\n+\t  ms_exc->NumberParameters = 1;\n+\t  ms_exc->ExceptionInformation[0] = (ULONG_PTR)exc;\n+\t}\n+\n     }\n \n   return _GCC_specific_handler (ms_exc, this_frame, ms_orig_context,"}, {"sha": "467a1e4356e8e167e9a194354b89b2529b99168f", "filename": "gcc/ada/s-oscons-tmplt.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fs-oscons-tmplt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fs-oscons-tmplt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-oscons-tmplt.c?ref=e187fa72fb4806da5b93af1d346446b9fc7f0993", "patch": "@@ -589,6 +589,16 @@ CND(ETOOMANYREFS, \"Too many references\")\n #endif\n CND(EWOULDBLOCK, \"Operation would block\")\n \n+#ifndef E2BIG\n+# define E2BIG -1\n+#endif\n+CND(E2BIG, \"Argument list too long\")\n+\n+#ifndef EILSEQ\n+# define EILSEQ -1\n+#endif\n+CND(EILSEQ, \"Illegal byte sequence\")\n+\n /**\n  **  Terminal I/O constants\n  **/"}, {"sha": "2f7fee435cf8733cf3167838f1d3087f02a85729", "filename": "gcc/ada/seh_init.c", "status": "modified", "additions": 61, "deletions": 58, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fseh_init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e187fa72fb4806da5b93af1d346446b9fc7f0993/gcc%2Fada%2Fseh_init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fseh_init.c?ref=e187fa72fb4806da5b93af1d346446b9fc7f0993", "patch": "@@ -68,20 +68,21 @@ extern void Raise_From_Signal_Handler (struct Exception_Data *, const char *);\n #include <windows.h>\n #include <excpt.h>\n \n+/* Prototypes.  */\n extern void _global_unwind2 (void *);\n \n EXCEPTION_DISPOSITION __gnat_SEH_error_handler\n (struct _EXCEPTION_RECORD*, void*, struct _CONTEXT*, void*);\n \n-EXCEPTION_DISPOSITION\n-__gnat_SEH_error_handler (struct _EXCEPTION_RECORD* ExceptionRecord,\n-\t\t\t  void *EstablisherFrame,\n-\t\t\t  struct _CONTEXT* ContextRecord ATTRIBUTE_UNUSED,\n-\t\t\t  void *DispatcherContext ATTRIBUTE_UNUSED)\n-{\n-  struct Exception_Data *exception;\n-  const char *msg;\n+struct Exception_Data *\n+__gnat_map_SEH (EXCEPTION_RECORD* ExceptionRecord, const char **msg);\n \n+/* Convert an SEH exception to an Ada one.  Return the exception ID\n+   and set MSG with the corresponding message.  */\n+\n+struct Exception_Data *\n+__gnat_map_SEH (EXCEPTION_RECORD* ExceptionRecord, const char **msg)\n+{\n   switch (ExceptionRecord->ExceptionCode)\n     {\n     case EXCEPTION_ACCESS_VIOLATION:\n@@ -92,93 +93,95 @@ __gnat_SEH_error_handler (struct _EXCEPTION_RECORD* ExceptionRecord,\n \t  || IsBadCodePtr\n \t  ((void *)(ExceptionRecord->ExceptionInformation[1] + 4096)))\n \t{\n-\t  exception = &program_error;\n-\t  msg = \"EXCEPTION_ACCESS_VIOLATION\";\n+\t  *msg = \"EXCEPTION_ACCESS_VIOLATION\";\n+\t  return &program_error;\n \t}\n       else\n \t{\n \t  /* otherwise it is a stack overflow  */\n-\t  exception = &storage_error;\n-\t  msg = \"stack overflow or erroneous memory access\";\n+\t  *msg = \"stack overflow or erroneous memory access\";\n+\t  return &storage_error;\n \t}\n-      break;\n \n     case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:\n-      exception = &constraint_error;\n-      msg = \"EXCEPTION_ARRAY_BOUNDS_EXCEEDED\";\n-      break;\n+      *msg = \"EXCEPTION_ARRAY_BOUNDS_EXCEEDED\";\n+      return &constraint_error;\n \n     case EXCEPTION_DATATYPE_MISALIGNMENT:\n-      exception = &constraint_error;\n-      msg = \"EXCEPTION_DATATYPE_MISALIGNMENT\";\n-      break;\n+      *msg = \"EXCEPTION_DATATYPE_MISALIGNMENT\";\n+      return &constraint_error;\n \n     case EXCEPTION_FLT_DENORMAL_OPERAND:\n-      exception = &constraint_error;\n-      msg = \"EXCEPTION_FLT_DENORMAL_OPERAND\";\n-      break;\n+      *msg = \"EXCEPTION_FLT_DENORMAL_OPERAND\";\n+      return &constraint_error;\n \n     case EXCEPTION_FLT_DIVIDE_BY_ZERO:\n-      exception = &constraint_error;\n-      msg = \"EXCEPTION_FLT_DENORMAL_OPERAND\";\n-      break;\n+      *msg = \"EXCEPTION_FLT_DENORMAL_OPERAND\";\n+      return &constraint_error;\n \n     case EXCEPTION_FLT_INVALID_OPERATION:\n-      exception = &constraint_error;\n-      msg = \"EXCEPTION_FLT_INVALID_OPERATION\";\n-      break;\n+      *msg = \"EXCEPTION_FLT_INVALID_OPERATION\";\n+      return &constraint_error;\n \n     case EXCEPTION_FLT_OVERFLOW:\n-      exception = &constraint_error;\n-      msg = \"EXCEPTION_FLT_OVERFLOW\";\n-      break;\n+      *msg = \"EXCEPTION_FLT_OVERFLOW\";\n+      return &constraint_error;\n \n     case EXCEPTION_FLT_STACK_CHECK:\n-      exception = &program_error;\n-      msg = \"EXCEPTION_FLT_STACK_CHECK\";\n-      break;\n+      *msg = \"EXCEPTION_FLT_STACK_CHECK\";\n+      return &program_error;\n \n     case EXCEPTION_FLT_UNDERFLOW:\n-      exception = &constraint_error;\n-      msg = \"EXCEPTION_FLT_UNDERFLOW\";\n-      break;\n+      *msg = \"EXCEPTION_FLT_UNDERFLOW\";\n+      return &constraint_error;\n \n     case EXCEPTION_INT_DIVIDE_BY_ZERO:\n-      exception = &constraint_error;\n-      msg = \"EXCEPTION_INT_DIVIDE_BY_ZERO\";\n-      break;\n+      *msg = \"EXCEPTION_INT_DIVIDE_BY_ZERO\";\n+      return &constraint_error;\n \n     case EXCEPTION_INT_OVERFLOW:\n-      exception = &constraint_error;\n-      msg = \"EXCEPTION_INT_OVERFLOW\";\n-      break;\n+      *msg = \"EXCEPTION_INT_OVERFLOW\";\n+      return &constraint_error;\n \n     case EXCEPTION_INVALID_DISPOSITION:\n-      exception = &program_error;\n-      msg = \"EXCEPTION_INVALID_DISPOSITION\";\n-      break;\n+      *msg = \"EXCEPTION_INVALID_DISPOSITION\";\n+      return &program_error;\n \n     case EXCEPTION_NONCONTINUABLE_EXCEPTION:\n-      exception = &program_error;\n-      msg = \"EXCEPTION_NONCONTINUABLE_EXCEPTION\";\n-      break;\n+      *msg = \"EXCEPTION_NONCONTINUABLE_EXCEPTION\";\n+      return &program_error;\n \n     case EXCEPTION_PRIV_INSTRUCTION:\n-      exception = &program_error;\n-      msg = \"EXCEPTION_PRIV_INSTRUCTION\";\n-      break;\n+      *msg = \"EXCEPTION_PRIV_INSTRUCTION\";\n+      return &program_error;\n \n     case EXCEPTION_SINGLE_STEP:\n-      exception = &program_error;\n-      msg = \"EXCEPTION_SINGLE_STEP\";\n-      break;\n+      *msg = \"EXCEPTION_SINGLE_STEP\";\n+      return &program_error;\n \n     case EXCEPTION_STACK_OVERFLOW:\n-      exception = &storage_error;\n-      msg = \"EXCEPTION_STACK_OVERFLOW\";\n-      break;\n+      *msg = \"EXCEPTION_STACK_OVERFLOW\";\n+      return &storage_error;\n \n     default:\n+      *msg = NULL;\n+      return NULL;\n+    }\n+}\n+\n+EXCEPTION_DISPOSITION\n+__gnat_SEH_error_handler (struct _EXCEPTION_RECORD* ExceptionRecord,\n+\t\t\t  void *EstablisherFrame,\n+\t\t\t  struct _CONTEXT* ContextRecord ATTRIBUTE_UNUSED,\n+\t\t\t  void *DispatcherContext ATTRIBUTE_UNUSED)\n+{\n+  struct Exception_Data *exception;\n+  const char *msg;\n+\n+  exception = __gnat_map_SEH (ExceptionRecord, &msg);\n+\n+  if (exception == NULL)\n+    {\n #if defined (_WIN64) && defined (__SEH__)\n       /* On Windows x64, do not transform other exception as they could\n \t be caught by user (when SEH is used to propagate exceptions).  */"}]}