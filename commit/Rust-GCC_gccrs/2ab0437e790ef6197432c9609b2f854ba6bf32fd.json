{"sha": "2ab0437e790ef6197432c9609b2f854ba6bf32fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmFiMDQzN2U3OTBlZjYxOTc0MzJjOTYwOWIyZjg1NGJhNmJmMzJmZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-09-05T15:32:12Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-09-05T15:32:12Z"}, "message": "i386.c (size_cost): New static variable.\n\n\t* i386.c (size_cost): New static variable.\n\t(override_function): Use size_cost when -Os is specified.\n\n\t* i386.c (ix86_expand_prologue): Set use_fast_prologue_epilogue\n\tproperly;  Use current_function_calls_eh_return.\n\t(ix86_expand_epilogue): Avoid dummy optimize_size tests;\n\tuse leave to avoid depdendancy chain.\n\n\t* local-alloc.c (update_equiv_regs): Use CFG to iterate over INSN stream;\n\tget BB loop_depth instead of computing it from LOOP notes.\n\n\t* reg-stack.c (subst_stack_reg_pat): Handle reversal of conditional moves.\n\nFrom-SVN: r45415", "tree": {"sha": "341620536c3a3cfc629ac77fa76be2987cb80273", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/341620536c3a3cfc629ac77fa76be2987cb80273"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ab0437e790ef6197432c9609b2f854ba6bf32fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ab0437e790ef6197432c9609b2f854ba6bf32fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ab0437e790ef6197432c9609b2f854ba6bf32fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ab0437e790ef6197432c9609b2f854ba6bf32fd/comments", "author": null, "committer": null, "parents": [{"sha": "76f81d9581ad1ff765c4d1280df8e4a0d9617080", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76f81d9581ad1ff765c4d1280df8e4a0d9617080", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76f81d9581ad1ff765c4d1280df8e4a0d9617080"}], "stats": {"total": 707, "additions": 381, "deletions": 326}, "files": [{"sha": "a73c916707db623be6f9b60e95bb8aac550eff6a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ab0437e790ef6197432c9609b2f854ba6bf32fd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ab0437e790ef6197432c9609b2f854ba6bf32fd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ab0437e790ef6197432c9609b2f854ba6bf32fd", "patch": "@@ -1,3 +1,18 @@\n+Wed Sep  5 17:28:49 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (size_cost): New static variable.\n+\t(override_function): Use size_cost when -Os is specified.\n+\n+\t* i386.c (ix86_expand_prologue): Set use_fast_prologue_epilogue\n+\tproperly;  Use current_function_calls_eh_return.\n+\t(ix86_expand_epilogue): Avoid dummy optimize_size tests;\n+\tuse leave to avoid depdendancy chain.\n+\n+\t* local-alloc.c (update_equiv_regs): Use CFG to iterate over INSN stream;\n+\tget BB loop_depth instead of computing it from LOOP notes.\n+\n+\t* reg-stack.c (subst_stack_reg_pat): Handle reversal of conditional moves.\n+\n 2001-09-05  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n \n \t* som.h (ASM_PREFERRED_EH_DATA_FORMAT): Define."}, {"sha": "eba47bcb72f5d43df8a766a801981e4fa7725997", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ab0437e790ef6197432c9609b2f854ba6bf32fd/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ab0437e790ef6197432c9609b2f854ba6bf32fd/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2ab0437e790ef6197432c9609b2f854ba6bf32fd", "patch": "@@ -47,6 +47,38 @@ Boston, MA 02111-1307, USA.  */\n #define CHECK_STACK_LIMIT -1\n #endif\n \n+/* Processor costs (relative to an add) */\n+struct processor_costs size_cost = {\t/* costs for tunning for size */\n+  2,\t\t\t\t\t/* cost of an add instruction */\n+  3,\t\t\t\t\t/* cost of a lea instruction */\n+  2,\t\t\t\t\t/* variable shift costs */\n+  3,\t\t\t\t\t/* constant shift costs */\n+  3,\t\t\t\t\t/* cost of starting a multiply */\n+  0,\t\t\t\t\t/* cost of multiply per each bit set */\n+  3,\t\t\t\t\t/* cost of a divide/mod */\n+  0,\t\t\t\t\t/* \"large\" insn */\n+  2,\t\t\t\t\t/* MOVE_RATIO */\n+  2,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  {2, 2, 2},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {2, 2, 2},\t\t\t\t/* cost of storing integer registers */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {2, 2, 2},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode */\n+  {2, 2, 2},\t\t\t\t/* cost of loading integer registers */\n+  3,\t\t\t\t\t/* cost of moving MMX register */\n+  {3, 3},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  {3, 3},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode */\n+  3,\t\t\t\t\t/* cost of moving SSE register */\n+  {3, 3, 3},\t\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  {3, 3, 3},\t\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in SImode, DImode and TImode */\n+  3,\t\t\t\t\t/* MMX or SSE register to integer */\n+};\n /* Processor costs (relative to an add) */\n struct processor_costs i386_cost = {\t/* 386 specific costs */\n   1,\t\t\t\t\t/* cost of an add instruction */\n@@ -798,7 +830,10 @@ override_options ()\n \terror (\"bad value (%s) for -mcpu= switch\", ix86_cpu_string);\n     }\n \n-  ix86_cost = processor_target_table[ix86_cpu].cost;\n+  if (optimize_size)\n+    ix86_cost = &size_cost;\n+  else\n+    ix86_cost = processor_target_table[ix86_cpu].cost;\n   target_flags |= processor_target_table[ix86_cpu].target_enable;\n   target_flags &= ~processor_target_table[ix86_cpu].target_disable;\n \n@@ -2664,11 +2699,12 @@ ix86_expand_prologue ()\n   int use_mov = 0;\n   HOST_WIDE_INT allocate;\n \n-  if (TARGET_PROLOGUE_USING_MOVE && !optimize_size)\n+  if (!optimize_size)\n     {\n       use_fast_prologue_epilogue\n \t = !expensive_function_p (FAST_PROLOGUE_INSN_COUNT);\n-      use_mov = use_fast_prologue_epilogue;\n+      if (TARGET_PROLOGUE_USING_MOVE)\n+        use_mov = use_fast_prologue_epilogue;\n     }\n   ix86_compute_frame_layout (&frame);\n \n@@ -2807,13 +2843,13 @@ ix86_expand_epilogue (style)\n      and there is exactly one register to pop. This heruistic may need some\n      tuning in future.  */\n   if ((!sp_valid && frame.nregs <= 1)\n-      || (TARGET_EPILOGUE_USING_MOVE && !optimize_size\n+      || (TARGET_EPILOGUE_USING_MOVE\n \t  && use_fast_prologue_epilogue\n \t  && (frame.nregs > 1 || frame.to_allocate))\n       || (frame_pointer_needed && !frame.nregs && frame.to_allocate)\n-      || (frame_pointer_needed && TARGET_USE_LEAVE && !optimize_size\n+      || (frame_pointer_needed && TARGET_USE_LEAVE\n \t  && use_fast_prologue_epilogue && frame.nregs == 1)\n-      || style == 2)\n+      || current_function_calls_eh_return)\n     {\n       /* Restore registers.  We can use ebp or esp to address the memory\n \t locations.  If both are available, default to ebp, since offsets\n@@ -2899,7 +2935,11 @@ ix86_expand_epilogue (style)\n \t  }\n       if (frame_pointer_needed)\n \t{\n-\t  if (TARGET_64BIT)\n+\t  /* Leave results in shorter depdendancy chains on CPUs that are\n+\t     able to grok it fast.  */\n+\t  if (TARGET_USE_LEAVE)\n+\t    emit_insn (TARGET_64BIT ? gen_leave_rex64 () : gen_leave ());\n+\t  else if (TARGET_64BIT)\n \t    emit_insn (gen_popdi1 (hard_frame_pointer_rtx));\n \t  else\n \t    emit_insn (gen_popsi1 (hard_frame_pointer_rtx));"}, {"sha": "f0492c44058fd9b1a9d5687b1e0980bbd70decc9", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 284, "deletions": 313, "changes": 597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ab0437e790ef6197432c9609b2f854ba6bf32fd/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ab0437e790ef6197432c9609b2f854ba6bf32fd/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=2ab0437e790ef6197432c9609b2f854ba6bf32fd", "patch": "@@ -821,224 +821,211 @@ update_equiv_regs ()\n   /* Scan the insns and find which registers have equivalences.  Do this\n      in a separate scan of the insns because (due to -fcse-follow-jumps)\n      a register can be set below its use.  */\n-  loop_depth = 0;\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+  for (block = 0; block < n_basic_blocks; block++)\n     {\n-      rtx note;\n-      rtx set;\n-      rtx dest, src;\n-      int regno;\n+      basic_block bb = BASIC_BLOCK (block);\n+      loop_depth = bb->loop_depth;\n \n-      if (GET_CODE (insn) == NOTE)\n+      for (insn = bb->head; insn != NEXT_INSN (bb->end); insn = NEXT_INSN (insn))\n \t{\n-\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\t    ++loop_depth;\n-\t  else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n-\t    {\n-\t      if (! loop_depth)\n-\t\tabort ();\n-\t      --loop_depth;\n-\t    }\n-\t}\n+\t  rtx note;\n+\t  rtx set;\n+\t  rtx dest, src;\n+\t  int regno;\n \n-      if (! INSN_P (insn))\n-\tcontinue;\n-\n-      for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n-\tif (REG_NOTE_KIND (note) == REG_INC)\n-\t  no_equiv (XEXP (note, 0), note, NULL);\n+\t  if (! INSN_P (insn))\n+\t    continue;\n \n-      set = single_set (insn);\n+\t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+\t    if (REG_NOTE_KIND (note) == REG_INC)\n+\t      no_equiv (XEXP (note, 0), note, NULL);\n \n-      /* If this insn contains more (or less) than a single SET,\n-\t only mark all destinations as having no known equivalence.  */\n-      if (set == 0)\n-\t{\n-\t  note_stores (PATTERN (insn), no_equiv, NULL);\n-\t  continue;\n-\t}\n-      else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n-\t{\n-\t  int i;\n+\t  set = single_set (insn);\n \n-\t  for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n+\t  /* If this insn contains more (or less) than a single SET,\n+\t     only mark all destinations as having no known equivalence.  */\n+\t  if (set == 0)\n \t    {\n-\t      rtx part = XVECEXP (PATTERN (insn), 0, i);\n-\t      if (part != set)\n-\t\tnote_stores (part, no_equiv, NULL);\n+\t      note_stores (PATTERN (insn), no_equiv, NULL);\n+\t      continue;\n \t    }\n-\t}\n+\t  else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n+\t    {\n+\t      int i;\n \n-      dest = SET_DEST (set);\n-      src = SET_SRC (set);\n-\n-      /* If this sets a MEM to the contents of a REG that is only used\n-\t in a single basic block, see if the register is always equivalent\n-\t to that memory location and if moving the store from INSN to the\n-\t insn that set REG is safe.  If so, put a REG_EQUIV note on the\n-\t initializing insn.\n-\n-\t Don't add a REG_EQUIV note if the insn already has one.  The existing\n-\t REG_EQUIV is likely more useful than the one we are adding.\n-\n-\t If one of the regs in the address has reg_equiv[REGNO].replace set,\n-\t then we can't add this REG_EQUIV note.  The reg_equiv[REGNO].replace\n-\t optimization may move the set of this register immediately before\n-\t insn, which puts it after reg_equiv[REGNO].init_insns, and hence\n-\t the mention in the REG_EQUIV note would be to an uninitialized\n-\t pseudo.  */\n-      /* ????? This test isn't good enough; we might see a MEM with a use of\n-\t a pseudo register before we see its setting insn that will cause\n-\t reg_equiv[].replace for that pseudo to be set.\n-\t Equivalences to MEMs should be made in another pass, after the\n-\t reg_equiv[].replace information has been gathered.  */\n-\n-      if (GET_CODE (dest) == MEM && GET_CODE (src) == REG\n-\t  && (regno = REGNO (src)) >= FIRST_PSEUDO_REGISTER\n-\t  && REG_BASIC_BLOCK (regno) >= 0\n-\t  && REG_N_SETS (regno) == 1\n-\t  && reg_equiv[regno].init_insns != 0\n-\t  && reg_equiv[regno].init_insns != const0_rtx\n-\t  && ! find_reg_note (XEXP (reg_equiv[regno].init_insns, 0),\n-\t\t\t      REG_EQUIV, NULL_RTX)\n-\t  && ! contains_replace_regs (XEXP (dest, 0)))\n-\t{\n-\t  rtx init_insn = XEXP (reg_equiv[regno].init_insns, 0);\n-\t  if (validate_equiv_mem (init_insn, src, dest)\n-\t      && ! memref_used_between_p (dest, init_insn, insn))\n-\t    REG_NOTES (init_insn)\n-\t      = gen_rtx_EXPR_LIST (REG_EQUIV, dest, REG_NOTES (init_insn));\n-\t}\n+\t      for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n+\t\t{\n+\t\t  rtx part = XVECEXP (PATTERN (insn), 0, i);\n+\t\t  if (part != set)\n+\t\t    note_stores (part, no_equiv, NULL);\n+\t\t}\n+\t    }\n \n-      /* We only handle the case of a pseudo register being set\n-\t once, or always to the same value.  */\n-      /* ??? The mn10200 port breaks if we add equivalences for\n-\t values that need an ADDRESS_REGS register and set them equivalent\n-\t to a MEM of a pseudo.  The actual problem is in the over-conservative\n-\t handling of INPADDR_ADDRESS / INPUT_ADDRESS / INPUT triples in\n-\t calculate_needs, but we traditionally work around this problem\n-\t here by rejecting equivalences when the destination is in a register\n-\t that's likely spilled.  This is fragile, of course, since the\n-\t preferred class of a pseudo depends on all instructions that set\n-\t or use it.  */\n-\n-      if (GET_CODE (dest) != REG\n-\t  || (regno = REGNO (dest)) < FIRST_PSEUDO_REGISTER\n-\t  || reg_equiv[regno].init_insns == const0_rtx\n-\t  || (CLASS_LIKELY_SPILLED_P (reg_preferred_class (regno))\n-\t      && GET_CODE (src) == MEM))\n-\t{\n-\t  /* This might be seting a SUBREG of a pseudo, a pseudo that is\n-\t     also set somewhere else to a constant.  */\n-\t  note_stores (set, no_equiv, NULL);\n-\t  continue;\n-\t}\n+\t  dest = SET_DEST (set);\n+\t  src = SET_SRC (set);\n+\n+\t  /* If this sets a MEM to the contents of a REG that is only used\n+\t     in a single basic block, see if the register is always equivalent\n+\t     to that memory location and if moving the store from INSN to the\n+\t     insn that set REG is safe.  If so, put a REG_EQUIV note on the\n+\t     initializing insn.\n+\n+\t     Don't add a REG_EQUIV note if the insn already has one.  The existing\n+\t     REG_EQUIV is likely more useful than the one we are adding.\n+\n+\t     If one of the regs in the address has reg_equiv[REGNO].replace set,\n+\t     then we can't add this REG_EQUIV note.  The reg_equiv[REGNO].replace\n+\t     optimization may move the set of this register immediately before\n+\t     insn, which puts it after reg_equiv[REGNO].init_insns, and hence\n+\t     the mention in the REG_EQUIV note would be to an uninitialized\n+\t     pseudo.  */\n+\t  /* ????? This test isn't good enough; we might see a MEM with a use of\n+\t     a pseudo register before we see its setting insn that will cause\n+\t     reg_equiv[].replace for that pseudo to be set.\n+\t     Equivalences to MEMs should be made in another pass, after the\n+\t     reg_equiv[].replace information has been gathered.  */\n+\n+\t  if (GET_CODE (dest) == MEM && GET_CODE (src) == REG\n+\t      && (regno = REGNO (src)) >= FIRST_PSEUDO_REGISTER\n+\t      && REG_BASIC_BLOCK (regno) >= 0\n+\t      && REG_N_SETS (regno) == 1\n+\t      && reg_equiv[regno].init_insns != 0\n+\t      && reg_equiv[regno].init_insns != const0_rtx\n+\t      && ! find_reg_note (XEXP (reg_equiv[regno].init_insns, 0),\n+\t\t\t\t  REG_EQUIV, NULL_RTX)\n+\t      && ! contains_replace_regs (XEXP (dest, 0)))\n+\t    {\n+\t      rtx init_insn = XEXP (reg_equiv[regno].init_insns, 0);\n+\t      if (validate_equiv_mem (init_insn, src, dest)\n+\t\t  && ! memref_used_between_p (dest, init_insn, insn))\n+\t\tREG_NOTES (init_insn)\n+\t\t  = gen_rtx_EXPR_LIST (REG_EQUIV, dest, REG_NOTES (init_insn));\n+\t    }\n \n-      note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n-\n-      /* cse sometimes generates function invariants, but doesn't put a\n-\t REG_EQUAL note on the insn.  Since this note would be redundant,\n-         there's no point creating it earlier than here.  */\n-      if (! note && ! rtx_varies_p (src, 0))\n-\tREG_NOTES (insn)\n-\t  = note = gen_rtx_EXPR_LIST (REG_EQUAL, src, REG_NOTES (insn));\n-\n-      /* Don't bother considering a REG_EQUAL note containing an EXPR_LIST\n-\t since it represents a function call */\n-      if (note && GET_CODE (XEXP (note, 0)) == EXPR_LIST)\n-\tnote = NULL_RTX;\n-\n-      if (REG_N_SETS (regno) != 1\n-\t  && (! note\n-\t      || rtx_varies_p (XEXP (note, 0), 0)\n-\t      || (reg_equiv[regno].replacement\n-\t\t  && ! rtx_equal_p (XEXP (note, 0),\n-\t\t\t\t    reg_equiv[regno].replacement))))\n-\t{\n-\t  no_equiv (dest, set, NULL);\n-\t  continue;\n-\t}\n-      /* Record this insn as initializing this register.  */\n-      reg_equiv[regno].init_insns\n-\t= gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv[regno].init_insns);\n-\n-      /* If this register is known to be equal to a constant, record that\n-\t it is always equivalent to the constant.  */\n-      if (note && ! rtx_varies_p (XEXP (note, 0), 0))\n-\tPUT_MODE (note, (enum machine_mode) REG_EQUIV);\n-\n-      /* If this insn introduces a \"constant\" register, decrease the priority\n-\t of that register.  Record this insn if the register is only used once\n-\t more and the equivalence value is the same as our source.\n-\n-\t The latter condition is checked for two reasons:  First, it is an\n-\t indication that it may be more efficient to actually emit the insn\n-\t as written (if no registers are available, reload will substitute\n-\t the equivalence).  Secondly, it avoids problems with any registers\n-\t dying in this insn whose death notes would be missed.\n-\n-\t If we don't have a REG_EQUIV note, see if this insn is loading\n-\t a register used only in one basic block from a MEM.  If so, and the\n-\t MEM remains unchanged for the life of the register, add a REG_EQUIV\n-\t note.  */\n-\n-      note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n-\n-      if (note == 0 && REG_BASIC_BLOCK (regno) >= 0\n-\t  && GET_CODE (SET_SRC (set)) == MEM\n-\t  && validate_equiv_mem (insn, dest, SET_SRC (set)))\n-\tREG_NOTES (insn) = note = gen_rtx_EXPR_LIST (REG_EQUIV, SET_SRC (set),\n-\t\t\t\t\t\t     REG_NOTES (insn));\n-\n-      if (note)\n-\t{\n-\t  int regno = REGNO (dest);\n-\n-\t  /* Record whether or not we created a REG_EQUIV note for a LABEL_REF.\n-\t     We might end up substituting the LABEL_REF for uses of the\n-\t     pseudo here or later.  That kind of transformation may turn an\n-\t     indirect jump into a direct jump, in which case we must rerun the\n-\t     jump optimizer to ensure that the JUMP_LABEL fields are valid.  */\n-\t  if (GET_CODE (XEXP (note, 0)) == LABEL_REF\n-\t      || (GET_CODE (XEXP (note, 0)) == CONST\n-\t\t  && GET_CODE (XEXP (XEXP (note, 0), 0)) == PLUS\n-\t\t  && (GET_CODE (XEXP (XEXP (XEXP (note, 0), 0), 0))\n-\t\t      == LABEL_REF)))\n-\t    recorded_label_ref = 1;\n-\n-\t  reg_equiv[regno].replacement = XEXP (note, 0);\n-\t  reg_equiv[regno].src = src;\n-\t  reg_equiv[regno].loop_depth = loop_depth;\n-\n-\t  /* Don't mess with things live during setjmp.  */\n-\t  if (REG_LIVE_LENGTH (regno) >= 0 && optimize)\n+\t  /* We only handle the case of a pseudo register being set\n+\t     once, or always to the same value.  */\n+\t  /* ??? The mn10200 port breaks if we add equivalences for\n+\t     values that need an ADDRESS_REGS register and set them equivalent\n+\t     to a MEM of a pseudo.  The actual problem is in the over-conservative\n+\t     handling of INPADDR_ADDRESS / INPUT_ADDRESS / INPUT triples in\n+\t     calculate_needs, but we traditionally work around this problem\n+\t     here by rejecting equivalences when the destination is in a register\n+\t     that's likely spilled.  This is fragile, of course, since the\n+\t     preferred class of a pseudo depends on all instructions that set\n+\t     or use it.  */\n+\n+\t  if (GET_CODE (dest) != REG\n+\t      || (regno = REGNO (dest)) < FIRST_PSEUDO_REGISTER\n+\t      || reg_equiv[regno].init_insns == const0_rtx\n+\t      || (CLASS_LIKELY_SPILLED_P (reg_preferred_class (regno))\n+\t\t  && GET_CODE (src) == MEM))\n+\t    {\n+\t      /* This might be seting a SUBREG of a pseudo, a pseudo that is\n+\t\t also set somewhere else to a constant.  */\n+\t      note_stores (set, no_equiv, NULL);\n+\t      continue;\n+\t    }\n+\n+\t  note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n+\n+\t  /* cse sometimes generates function invariants, but doesn't put a\n+\t     REG_EQUAL note on the insn.  Since this note would be redundant,\n+\t     there's no point creating it earlier than here.  */\n+\t  if (! note && ! rtx_varies_p (src, 0))\n+\t    REG_NOTES (insn)\n+\t      = note = gen_rtx_EXPR_LIST (REG_EQUAL, src, REG_NOTES (insn));\n+\n+\t  /* Don't bother considering a REG_EQUAL note containing an EXPR_LIST\n+\t     since it represents a function call */\n+\t  if (note && GET_CODE (XEXP (note, 0)) == EXPR_LIST)\n+\t    note = NULL_RTX;\n+\n+\t  if (REG_N_SETS (regno) != 1\n+\t      && (! note\n+\t\t  || rtx_varies_p (XEXP (note, 0), 0)\n+\t\t  || (reg_equiv[regno].replacement\n+\t\t      && ! rtx_equal_p (XEXP (note, 0),\n+\t\t\t\t\treg_equiv[regno].replacement))))\n \t    {\n-\t      /* Note that the statement below does not affect the priority\n-\t\t in local-alloc!  */\n-\t      REG_LIVE_LENGTH (regno) *= 2;\n-\n-\n-\t      /* If the register is referenced exactly twice, meaning it is\n-\t\t set once and used once, indicate that the reference may be\n-\t\t replaced by the equivalence we computed above.  Do this\n-\t\t even if the register is only used in one block so that\n-\t\t dependencies can be handled where the last register is\n-\t\t used in a different block (i.e. HIGH / LO_SUM sequences)\n-\t\t and to reduce the number of registers alive across calls.\n-\n-\t\t It would be nice to use \"loop_depth * 2\" in the compare\n-\t\t below.  Unfortunately, LOOP_DEPTH need not be constant within\n-\t\t a basic block so this would be too complicated.\n-\n-\t\t This case normally occurs when a parameter is read from\n-\t\t memory and then used exactly once, not in a loop.  */\n-\n-\t\tif (REG_N_REFS (regno) == 2\n-\t\t    && (rtx_equal_p (XEXP (note, 0), src)\n-\t\t\t|| ! equiv_init_varies_p (src))\n-\t\t    && GET_CODE (insn) == INSN\n-\t\t    && equiv_init_movable_p (PATTERN (insn), regno))\n-\t\t  reg_equiv[regno].replace = 1;\n+\t      no_equiv (dest, set, NULL);\n+\t      continue;\n+\t    }\n+\t  /* Record this insn as initializing this register.  */\n+\t  reg_equiv[regno].init_insns\n+\t    = gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv[regno].init_insns);\n+\n+\t  /* If this register is known to be equal to a constant, record that\n+\t     it is always equivalent to the constant.  */\n+\t  if (note && ! rtx_varies_p (XEXP (note, 0), 0))\n+\t    PUT_MODE (note, (enum machine_mode) REG_EQUIV);\n+\n+\t  /* If this insn introduces a \"constant\" register, decrease the priority\n+\t     of that register.  Record this insn if the register is only used once\n+\t     more and the equivalence value is the same as our source.\n+\n+\t     The latter condition is checked for two reasons:  First, it is an\n+\t     indication that it may be more efficient to actually emit the insn\n+\t     as written (if no registers are available, reload will substitute\n+\t     the equivalence).  Secondly, it avoids problems with any registers\n+\t     dying in this insn whose death notes would be missed.\n+\n+\t     If we don't have a REG_EQUIV note, see if this insn is loading\n+\t     a register used only in one basic block from a MEM.  If so, and the\n+\t     MEM remains unchanged for the life of the register, add a REG_EQUIV\n+\t     note.  */\n+\n+\t  note = find_reg_note (insn, REG_EQUIV, NULL_RTX);\n+\n+\t  if (note == 0 && REG_BASIC_BLOCK (regno) >= 0\n+\t      && GET_CODE (SET_SRC (set)) == MEM\n+\t      && validate_equiv_mem (insn, dest, SET_SRC (set)))\n+\t    REG_NOTES (insn) = note = gen_rtx_EXPR_LIST (REG_EQUIV, SET_SRC (set),\n+\t\t\t\t\t\t\t REG_NOTES (insn));\n+\n+\t  if (note)\n+\t    {\n+\t      int regno = REGNO (dest);\n+\n+\t      /* Record whether or not we created a REG_EQUIV note for a LABEL_REF.\n+\t\t We might end up substituting the LABEL_REF for uses of the\n+\t\t pseudo here or later.  That kind of transformation may turn an\n+\t\t indirect jump into a direct jump, in which case we must rerun the\n+\t\t jump optimizer to ensure that the JUMP_LABEL fields are valid.  */\n+\t      if (GET_CODE (XEXP (note, 0)) == LABEL_REF\n+\t\t  || (GET_CODE (XEXP (note, 0)) == CONST\n+\t\t      && GET_CODE (XEXP (XEXP (note, 0), 0)) == PLUS\n+\t\t      && (GET_CODE (XEXP (XEXP (XEXP (note, 0), 0), 0))\n+\t\t\t  == LABEL_REF)))\n+\t\trecorded_label_ref = 1;\n+\n+\t      reg_equiv[regno].replacement = XEXP (note, 0);\n+\t      reg_equiv[regno].src = src;\n+\t      reg_equiv[regno].loop_depth = loop_depth;\n+\n+\t      /* Don't mess with things live during setjmp.  */\n+\t      if (REG_LIVE_LENGTH (regno) >= 0 && optimize)\n+\t\t{\n+\t\t  /* Note that the statement below does not affect the priority\n+\t\t     in local-alloc!  */\n+\t\t  REG_LIVE_LENGTH (regno) *= 2;\n+\n+\n+\t\t  /* If the register is referenced exactly twice, meaning it is\n+\t\t     set once and used once, indicate that the reference may be\n+\t\t     replaced by the equivalence we computed above.  Do this\n+\t\t     even if the register is only used in one block so that\n+\t\t     dependencies can be handled where the last register is\n+\t\t     used in a different block (i.e. HIGH / LO_SUM sequences)\n+\t\t     and to reduce the number of registers alive across\n+\t\t     calls.  */\n+\n+\t\t    if (REG_N_REFS (regno) == 2\n+\t\t\t&& (rtx_equal_p (XEXP (note, 0), src)\n+\t\t\t    || ! equiv_init_varies_p (src))\n+\t\t\t&& GET_CODE (insn) == INSN\n+\t\t\t&& equiv_init_movable_p (PATTERN (insn), regno))\n+\t\t      reg_equiv[regno].replace = 1;\n+\t\t}\n \t    }\n \t}\n     }\n@@ -1050,134 +1037,118 @@ update_equiv_regs ()\n      can't replace the reference, and the initialzing reference is\n      within the same loop (or in an inner loop), then move the register\n      initialization just before the use, so that they are in the same\n-     basic block.\n-\n-     Skip this optimization if loop_depth isn't initially zero since\n-     that indicates a mismatch between loop begin and loop end notes\n-     (i.e. gcc.dg/noncompile/920721-2.c).  */\n-  block = n_basic_blocks - 1;\n-  for (insn = (loop_depth == 0) ? get_last_insn () : NULL_RTX;\n-       insn; insn = PREV_INSN (insn))\n+     basic block.  */\n+  for (block = n_basic_blocks - 1; block >= 0; block--)\n     {\n-      rtx link;\n+      basic_block bb = BASIC_BLOCK (block);\n \n-      if (! INSN_P (insn))\n+      loop_depth = bb->loop_depth;\n+      for (insn = bb->end; insn != PREV_INSN (bb->head); insn = PREV_INSN (insn))\n \t{\n-\t  if (GET_CODE (insn) == NOTE)\n-\t    {\n-\t      if (NOTE_INSN_BASIC_BLOCK_P (insn))\n-\t\tblock = NOTE_BASIC_BLOCK (insn)->index - 1;\n-\t      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\t\t{\n-\t\t  if (! loop_depth)\n-\t\t    abort ();\n-\t\t  --loop_depth;\n-\t\t}\n-\t      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n-\t\t++loop_depth;\n-\t    }\n+\t  rtx link;\n \n-\t  continue;\n-\t}\n+\t  if (! INSN_P (insn))\n+\t    continue;\n \n-      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-\t{\n-\t  if (REG_NOTE_KIND (link) == REG_DEAD\n-\t      /* Make sure this insn still refers to the register.  */\n-\t      && reg_mentioned_p (XEXP (link, 0), PATTERN (insn)))\n+\t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n \t    {\n-\t      int regno = REGNO (XEXP (link, 0));\n-\t      rtx equiv_insn;\n+\t      if (REG_NOTE_KIND (link) == REG_DEAD\n+\t\t  /* Make sure this insn still refers to the register.  */\n+\t\t  && reg_mentioned_p (XEXP (link, 0), PATTERN (insn)))\n+\t\t{\n+\t\t  int regno = REGNO (XEXP (link, 0));\n+\t\t  rtx equiv_insn;\n \n-\t      if (! reg_equiv[regno].replace\n-\t\t  || reg_equiv[regno].loop_depth < loop_depth)\n-\t\tcontinue;\n+\t\t  if (! reg_equiv[regno].replace\n+\t\t      || reg_equiv[regno].loop_depth < loop_depth)\n+\t\t    continue;\n \n-\t      /* reg_equiv[REGNO].replace gets set only when\n-\t\t REG_N_REFS[REGNO] is 2, i.e. the register is set\n-\t\t once and used once.  (If it were only set, but not used,\n-\t\t flow would have deleted the setting insns.)  Hence\n-\t\t there can only be one insn in reg_equiv[REGNO].init_insns.  */\n-\t      if (reg_equiv[regno].init_insns == NULL_RTX\n-\t\t  || XEXP (reg_equiv[regno].init_insns, 1) != NULL_RTX)\n-\t\tabort ();\n-\t      equiv_insn = XEXP (reg_equiv[regno].init_insns, 0);\n-\n-\t      /* We may not move instructions that can throw, since\n-\t\t that changes basic block boundaries and we are not\n-\t\t prepared to adjust the CFG to match.  */\n-\t      if (can_throw_internal (equiv_insn))\n-\t\tcontinue;\n+\t\t  /* reg_equiv[REGNO].replace gets set only when\n+\t\t     REG_N_REFS[REGNO] is 2, i.e. the register is set\n+\t\t     once and used once.  (If it were only set, but not used,\n+\t\t     flow would have deleted the setting insns.)  Hence\n+\t\t     there can only be one insn in reg_equiv[REGNO].init_insns.  */\n+\t\t  if (reg_equiv[regno].init_insns == NULL_RTX\n+\t\t      || XEXP (reg_equiv[regno].init_insns, 1) != NULL_RTX)\n+\t\t    abort ();\n+\t\t  equiv_insn = XEXP (reg_equiv[regno].init_insns, 0);\n \n-\t      if (asm_noperands (PATTERN (equiv_insn)) < 0\n-\t\t  && validate_replace_rtx (regno_reg_rtx[regno],\n-\t\t\t\t\t   reg_equiv[regno].src, insn))\n-\t\t{\n-\t\t  rtx equiv_link;\n-\t\t  rtx last_link;\n-\t\t  rtx note;\n-\n-\t\t  /* Find the last note.  */\n-\t\t  for (last_link = link; XEXP (last_link, 1);\n-\t\t       last_link = XEXP (last_link, 1))\n-\t\t    ;\n-\n-\t\t  /* Append the REG_DEAD notes from equiv_insn.  */\n-\t\t  equiv_link = REG_NOTES (equiv_insn);\n-\t\t  while (equiv_link)\n+\t\t  /* We may not move instructions that can throw, since\n+\t\t     that changes basic block boundaries and we are not\n+\t\t     prepared to adjust the CFG to match.  */\n+\t\t  if (can_throw_internal (equiv_insn))\n+\t\t    continue;\n+\n+\t\t  if (asm_noperands (PATTERN (equiv_insn)) < 0\n+\t\t      && validate_replace_rtx (regno_reg_rtx[regno],\n+\t\t\t\t\t       reg_equiv[regno].src, insn))\n \t\t    {\n-\t\t      note = equiv_link;\n-\t\t      equiv_link = XEXP (equiv_link, 1);\n-\t\t      if (REG_NOTE_KIND (note) == REG_DEAD)\n+\t\t      rtx equiv_link;\n+\t\t      rtx last_link;\n+\t\t      rtx note;\n+\n+\t\t      /* Find the last note.  */\n+\t\t      for (last_link = link; XEXP (last_link, 1);\n+\t\t\t   last_link = XEXP (last_link, 1))\n+\t\t\t;\n+\n+\t\t      /* Append the REG_DEAD notes from equiv_insn.  */\n+\t\t      equiv_link = REG_NOTES (equiv_insn);\n+\t\t      while (equiv_link)\n \t\t\t{\n-\t\t\t  remove_note (equiv_insn, note);\n-\t\t\t  XEXP (last_link, 1) = note;\n-\t\t\t  XEXP (note, 1) = NULL_RTX;\n-\t\t\t  last_link = note;\n+\t\t\t  note = equiv_link;\n+\t\t\t  equiv_link = XEXP (equiv_link, 1);\n+\t\t\t  if (REG_NOTE_KIND (note) == REG_DEAD)\n+\t\t\t    {\n+\t\t\t      remove_note (equiv_insn, note);\n+\t\t\t      XEXP (last_link, 1) = note;\n+\t\t\t      XEXP (note, 1) = NULL_RTX;\n+\t\t\t      last_link = note;\n+\t\t\t    }\n \t\t\t}\n-\t\t    }\n \n-\t\t  remove_death (regno, insn);\n-\t\t  REG_N_REFS (regno) = 0;\n-\t\t  REG_FREQ (regno) = 0;\n-\t\t  PUT_CODE (equiv_insn, NOTE);\n-\t\t  NOTE_LINE_NUMBER (equiv_insn) = NOTE_INSN_DELETED;\n-\t\t  NOTE_SOURCE_FILE (equiv_insn) = 0;\n-\t\t  \n-\t\t  reg_equiv[regno].init_insns\n-\t\t    = XEXP (reg_equiv[regno].init_insns, 1);\n-\t\t}\n-\t      /* Move the initialization of the register to just before\n-\t\t INSN.  Update the flow information.  */\n-\t      else if (PREV_INSN (insn) != equiv_insn)\n-\t\t{\n-\t\t  rtx new_insn;\n+\t\t      remove_death (regno, insn);\n+\t\t      REG_N_REFS (regno) = 0;\n+\t\t      REG_FREQ (regno) = 0;\n+\t\t      PUT_CODE (equiv_insn, NOTE);\n+\t\t      NOTE_LINE_NUMBER (equiv_insn) = NOTE_INSN_DELETED;\n+\t\t      NOTE_SOURCE_FILE (equiv_insn) = 0;\n+\t\t      \n+\t\t      reg_equiv[regno].init_insns\n+\t\t\t= XEXP (reg_equiv[regno].init_insns, 1);\n+\t\t    }\n+\t\t  /* Move the initialization of the register to just before\n+\t\t     INSN.  Update the flow information.  */\n+\t\t  else if (PREV_INSN (insn) != equiv_insn)\n+\t\t    {\n+\t\t      rtx new_insn;\n \n-\t\t  new_insn = emit_insn_before (PATTERN (equiv_insn), insn);\n-\t\t  REG_NOTES (new_insn) = REG_NOTES (equiv_insn);\n-\t\t  REG_NOTES (equiv_insn) = 0;\n+\t\t      new_insn = emit_insn_before (PATTERN (equiv_insn), insn);\n+\t\t      REG_NOTES (new_insn) = REG_NOTES (equiv_insn);\n+\t\t      REG_NOTES (equiv_insn) = 0;\n \n-\t\t  /* Make sure this insn is recognized before reload begins,\n-\t\t     otherwise eliminate_regs_in_insn will abort.  */\n-\t\t  INSN_CODE (new_insn) = INSN_CODE (equiv_insn);\n+\t\t      /* Make sure this insn is recognized before reload begins,\n+\t\t\t otherwise eliminate_regs_in_insn will abort.  */\n+\t\t      INSN_CODE (new_insn) = INSN_CODE (equiv_insn);\n \n-\t\t  PUT_CODE (equiv_insn, NOTE);\n-\t\t  NOTE_LINE_NUMBER (equiv_insn) = NOTE_INSN_DELETED;\n-\t\t  NOTE_SOURCE_FILE (equiv_insn) = 0;\n+\t\t      PUT_CODE (equiv_insn, NOTE);\n+\t\t      NOTE_LINE_NUMBER (equiv_insn) = NOTE_INSN_DELETED;\n+\t\t      NOTE_SOURCE_FILE (equiv_insn) = 0;\n \n-\t\t  XEXP (reg_equiv[regno].init_insns, 0) = new_insn;\n+\t\t      XEXP (reg_equiv[regno].init_insns, 0) = new_insn;\n \n-\t\t  REG_BASIC_BLOCK (regno) = block >= 0 ? block : 0;\n-\t\t  REG_N_CALLS_CROSSED (regno) = 0;\n-\t\t  REG_LIVE_LENGTH (regno) = 2;\n+\t\t      REG_BASIC_BLOCK (regno) = block >= 0 ? block : 0;\n+\t\t      REG_N_CALLS_CROSSED (regno) = 0;\n+\t\t      REG_LIVE_LENGTH (regno) = 2;\n \n-\t\t  if (block >= 0 && insn == BLOCK_HEAD (block))\n-\t\t    BLOCK_HEAD (block) = PREV_INSN (insn);\n+\t\t      if (block >= 0 && insn == BLOCK_HEAD (block))\n+\t\t\tBLOCK_HEAD (block) = PREV_INSN (insn);\n \n-\t\t  /* Remember to clear REGNO from all basic block's live\n-\t\t     info.  */\n-\t\t  SET_REGNO_REG_SET (&cleared_regs, regno);\n-\t\t  clear_regnos++;\n+\t\t      /* Remember to clear REGNO from all basic block's live\n+\t\t\t info.  */\n+\t\t      SET_REGNO_REG_SET (&cleared_regs, regno);\n+\t\t      clear_regnos++;\n+\t\t    }\n \t\t}\n \t    }\n \t}"}, {"sha": "d011021ce1576bc0b833f0426640ab6f647d0a87", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ab0437e790ef6197432c9609b2f854ba6bf32fd/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ab0437e790ef6197432c9609b2f854ba6bf32fd/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=2ab0437e790ef6197432c9609b2f854ba6bf32fd", "patch": "@@ -530,6 +530,7 @@ branch_prob ()\n   total_num_times_called++;\n \n   flow_call_edges_add (NULL);\n+  add_noreturn_fake_exit_edges ();\n \n   /* We can't handle cyclic regions constructed using abnormal edges.\n      To avoid these we replace every source of abnormal edge by a fake"}, {"sha": "79aabfa95b745d60418d1ae70d25d082433260e5", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ab0437e790ef6197432c9609b2f854ba6bf32fd/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ab0437e790ef6197432c9609b2f854ba6bf32fd/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=2ab0437e790ef6197432c9609b2f854ba6bf32fd", "patch": "@@ -1775,20 +1775,48 @@ subst_stack_regs_pat (insn, regstack, pat)\n \t  case IF_THEN_ELSE:\n \t    /* This insn requires the top of stack to be the destination.  */\n \n+\t    src1 = get_true_reg (&XEXP (pat_src, 1));\n+\t    src2 = get_true_reg (&XEXP (pat_src, 2));\n+\n+\t    src1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n+\t    src2_note = find_regno_note (insn, REG_DEAD, REGNO (*src2));\n+\n \t    /* If the comparison operator is an FP comparison operator,\n \t       it is handled correctly by compare_for_stack_reg () who\n \t       will move the destination to the top of stack. But if the\n \t       comparison operator is not an FP comparison operator, we\n \t       have to handle it here.  */\n \t    if (get_hard_regnum (regstack, *dest) >= FIRST_STACK_REG\n \t\t&& REGNO (*dest) != regstack->reg[regstack->top])\n-\t      emit_swap_insn (insn, regstack, *dest);\t\n-\n-\t    src1 = get_true_reg (&XEXP (pat_src, 1));\n-\t    src2 = get_true_reg (&XEXP (pat_src, 2));\n+\t      {\n+\t\t/* In case one of operands is the top of stack and the operands\n+\t\t   dies, it is safe to make it the destination operand by reversing\n+\t\t   the direction of cmove and avoid fxch.  */\n+\t\tif ((REGNO (*src1) == regstack->reg[regstack->top]\n+\t\t     && src1_note)\n+\t\t    || (REGNO (*src2) == regstack->reg[regstack->top]\n+\t\t\t&& src2_note))\n+\t\t  {\n \n-\t    src1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n-\t    src2_note = find_regno_note (insn, REG_DEAD, REGNO (*src2));\n+\t\t    /* We know that both sources \"dies\", as one dies and other\n+\t\t       is overwriten by the destination.  Claim both sources\n+\t\t       to be dead, as the code bellow will properly pop the\n+\t\t       non-top-of-stack note and replace top-of-stack by the\n+\t\t       result by popping source first and then pushing result. */\n+\t\t    if (!src1_note)\n+\t\t      src1_note = REG_NOTES (insn)\n+\t\t\t= gen_rtx_EXPR_LIST (REG_DEAD, *src1, REG_NOTES (insn));\n+\t\t    if (!src2_note)\n+\t\t      src2_note = REG_NOTES (insn)\n+\t\t\t= gen_rtx_EXPR_LIST (REG_DEAD, *src2, REG_NOTES (insn));\n+\n+\t\t    /* i386 do have comparison always reversible.  */\n+\t\t    PUT_CODE (XEXP (pat_src, 0),\n+\t\t\t      reversed_comparison_code (XEXP (pat_src, 0), insn));\n+\t\t  }\n+\t\telse\n+\t          emit_swap_insn (insn, regstack, *dest);\t\n+\t      }\n \n \t    {\n \t      rtx src_note [3];"}]}