{"sha": "8d3abf42d5c2ccd5c5e879088fdf6e071c3d1b9e", "node_id": "C_kwDOANBUbNoAKDhkM2FiZjQyZDVjMmNjZDVjNWU4NzkwODhmZGY2ZTA3MWMzZDFiOWU", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-11T15:06:48Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-11-11T15:07:47Z"}, "message": "Fix some side cases of side effects discovery\n\nI wrote script comparing modref pure/const discovery with ipa-pure-const\nand found mistakes on both ends.  This plugs the modref differences in handling\nlooping pure consts which were previously missed due to early exits on\nECF_CONST | ECF_PURE.  Those early exists are bit anoying and I think as\na cleanup I may just drop some of them as premature optimizations coming from\ntime modref was very simplistic on what it propagates.\n\ngcc/ChangeLog:\n\n2021-11-11  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* ipa-modref.c (modref_summary::useful_p): Check also for side-effects\n\twith looping const/pure.\n\t(modref_summary_lto::useful_p): Likewise.\n\t(merge_call_side_effects): Merge side effects before early exit\n\tfor pure/const.\n\t(process_fnspec): Also handle pure functions.\n\t(analyze_call): Do not early exit on looping pure const.\n\t(propagate_unknown_call): Also handle nontrivial SCC as side-effect.\n\t(modref_propagate_in_scc): Update.", "tree": {"sha": "13251c4e2b5b00ad45b96c51eb6ca3a8f2ea6ae9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/13251c4e2b5b00ad45b96c51eb6ca3a8f2ea6ae9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d3abf42d5c2ccd5c5e879088fdf6e071c3d1b9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d3abf42d5c2ccd5c5e879088fdf6e071c3d1b9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d3abf42d5c2ccd5c5e879088fdf6e071c3d1b9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d3abf42d5c2ccd5c5e879088fdf6e071c3d1b9e/comments", "author": null, "committer": null, "parents": [{"sha": "fac4c4bdab1735bd8a87e37c519f0260e4769f2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fac4c4bdab1735bd8a87e37c519f0260e4769f2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fac4c4bdab1735bd8a87e37c519f0260e4769f2a"}], "stats": {"total": 100, "additions": 61, "deletions": 39}, "files": [{"sha": "45b391a565ef3de5df5ac2eaacb4523074a631e6", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 61, "deletions": 39, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d3abf42d5c2ccd5c5e879088fdf6e071c3d1b9e/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d3abf42d5c2ccd5c5e879088fdf6e071c3d1b9e/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=8d3abf42d5c2ccd5c5e879088fdf6e071c3d1b9e", "patch": "@@ -331,11 +331,11 @@ modref_summary::useful_p (int ecf_flags, bool check_flags)\n       && remove_useless_eaf_flags (static_chain_flags, ecf_flags, false))\n     return true;\n   if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n-    return false;\n+    return (!side_effects && (ecf_flags & ECF_LOOPING_CONST_OR_PURE));\n   if (loads && !loads->every_base)\n     return true;\n   if (ecf_flags & ECF_PURE)\n-    return false;\n+    return (!side_effects && (ecf_flags & ECF_LOOPING_CONST_OR_PURE));\n   return stores && !stores->every_base;\n }\n \n@@ -416,11 +416,11 @@ modref_summary_lto::useful_p (int ecf_flags, bool check_flags)\n       && remove_useless_eaf_flags (static_chain_flags, ecf_flags, false))\n     return true;\n   if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n-    return false;\n+    return (!side_effects && (ecf_flags & ECF_LOOPING_CONST_OR_PURE));\n   if (loads && !loads->every_base)\n     return true;\n   if (ecf_flags & ECF_PURE)\n-    return false;\n+    return (!side_effects && (ecf_flags & ECF_LOOPING_CONST_OR_PURE));\n   return stores && !stores->every_base;\n }\n \n@@ -925,6 +925,18 @@ merge_call_side_effects (modref_summary *cur_summary,\n   auto_vec <modref_parm_map, 32> parm_map;\n   modref_parm_map chain_map;\n   bool changed = false;\n+  int flags = gimple_call_flags (stmt);\n+\n+  if (!cur_summary->side_effects && callee_summary->side_effects)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \" - merging side effects.\\n\");\n+      cur_summary->side_effects = true;\n+      changed = true;\n+    }\n+\n+  if (flags & (ECF_CONST | ECF_NOVOPS))\n+    return changed;\n \n   /* We can not safely optimize based on summary of callee if it does\n      not always bind to current def: it is possible that memory load\n@@ -988,12 +1000,6 @@ merge_call_side_effects (modref_summary *cur_summary,\n \t  changed = true;\n \t}\n     }\n-  if (!cur_summary->side_effects\n-      && callee_summary->side_effects)\n-    {\n-      cur_summary->side_effects = true;\n-      changed = true;\n-    }\n   return changed;\n }\n \n@@ -1091,7 +1097,7 @@ process_fnspec (modref_summary *cur_summary,\n   attr_fnspec fnspec = gimple_call_fnspec (call);\n   int flags = gimple_call_flags (call);\n \n-  if (!(flags & (ECF_CONST | ECF_NOVOPS))\n+  if (!(flags & (ECF_CONST | ECF_NOVOPS | ECF_PURE))\n       || (flags & ECF_LOOPING_CONST_OR_PURE)\n       || (cfun->can_throw_non_call_exceptions\n \t  && stmt_could_throw_p (cfun, call)))\n@@ -1101,6 +1107,8 @@ process_fnspec (modref_summary *cur_summary,\n       if (cur_summary_lto)\n \tcur_summary_lto->side_effects = true;\n     }\n+  if (flags & (ECF_CONST | ECF_NOVOPS))\n+    return true;\n   if (!fnspec.known_p ())\n     {\n       if (dump_file && gimple_call_builtin_p (call, BUILT_IN_NORMAL))\n@@ -1203,7 +1211,8 @@ analyze_call (modref_summary *cur_summary, modref_summary_lto *cur_summary_lto,\n   /* Check flags on the function call.  In certain cases, analysis can be\n      simplified.  */\n   int flags = gimple_call_flags (stmt);\n-  if (flags & (ECF_CONST | ECF_NOVOPS))\n+  if ((flags & (ECF_CONST | ECF_NOVOPS))\n+      && !(flags & ECF_LOOPING_CONST_OR_PURE))\n     {\n       if (dump_file)\n \tfprintf (dump_file,\n@@ -3963,7 +3972,8 @@ static bool\n propagate_unknown_call (cgraph_node *node,\n \t\t\tcgraph_edge *e, int ecf_flags,\n \t\t\tmodref_summary *cur_summary,\n-\t\t\tmodref_summary_lto *cur_summary_lto)\n+\t\t\tmodref_summary_lto *cur_summary_lto,\n+\t\t\tbool nontrivial_scc)\n {\n   bool changed = false;\n   class fnspec_summary *fnspec_sum = fnspec_summaries->get (e);\n@@ -3973,21 +3983,22 @@ propagate_unknown_call (cgraph_node *node,\n   if (e->callee\n       && builtin_safe_for_const_function_p (&looping, e->callee->decl))\n     {\n-      if (cur_summary && !cur_summary->side_effects)\n+      if (looping && cur_summary && !cur_summary->side_effects)\n \t{\n \t  cur_summary->side_effects = true;\n \t  changed = true;\n \t}\n-      if (cur_summary_lto && !cur_summary_lto->side_effects)\n+      if (looping && cur_summary_lto && !cur_summary_lto->side_effects)\n \t{\n \t  cur_summary_lto->side_effects = true;\n \t  changed = true;\n \t}\n       return changed;\n     }\n \n-  if (!(ecf_flags & (ECF_CONST | ECF_NOVOPS))\n-      || (ecf_flags & ECF_LOOPING_CONST_OR_PURE))\n+  if (!(ecf_flags & (ECF_CONST | ECF_NOVOPS | ECF_PURE))\n+      || (ecf_flags & ECF_LOOPING_CONST_OR_PURE)\n+      || nontrivial_scc)\n     {\n       if (cur_summary && !cur_summary->side_effects)\n \t{\n@@ -4000,6 +4011,8 @@ propagate_unknown_call (cgraph_node *node,\n \t  changed = true;\n \t}\n     }\n+  if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n+    return changed;\n \n   if (fnspec_sum\n       && compute_parm_map (e, &parm_map))\n@@ -4126,6 +4139,8 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \n   while (changed)\n     {\n+      bool nontrivial_scc\n+\t\t = ((struct ipa_dfs_info *) component_node->aux)->next_cycle;\n       changed = false;\n       for (struct cgraph_node *cur = component_node; cur;\n \t   cur = ((struct ipa_dfs_info *) cur->aux)->next_cycle)\n@@ -4151,14 +4166,12 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \n \t  for (cgraph_edge *e = cur->indirect_calls; e; e = e->next_callee)\n \t    {\n-\t      if (e->indirect_info->ecf_flags & (ECF_CONST | ECF_NOVOPS))\n-\t\tcontinue;\n \t      if (dump_file)\n-\t\tfprintf (dump_file, \"    Indirect call\"\n-\t\t\t \"collapsing loads\\n\");\n+\t\tfprintf (dump_file, \"    Indirect call\\n\");\n \t      if (propagate_unknown_call\n \t\t\t   (node, e, e->indirect_info->ecf_flags,\n-\t\t\t    cur_summary, cur_summary_lto))\n+\t\t\t    cur_summary, cur_summary_lto,\n+\t\t\t    nontrivial_scc))\n \t\t{\n \t\t  changed = true;\n \t\t  remove_useless_summaries (node, &cur_summary,\n@@ -4180,8 +4193,9 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t      modref_summary_lto *callee_summary_lto = NULL;\n \t      struct cgraph_node *callee;\n \n-\t      if (flags & (ECF_CONST | ECF_NOVOPS)\n-\t\t  || !callee_edge->inline_failed)\n+\t      if (!callee_edge->inline_failed\n+\t\t || ((flags & (ECF_CONST | ECF_NOVOPS))\n+\t\t     && !(flags & ECF_LOOPING_CONST_OR_PURE)))\n \t\tcontinue;\n \n \t      /* Get the callee and its summary.  */\n@@ -4210,7 +4224,8 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t\t\t     \" or not available\\n\");\n \t\t  changed |= propagate_unknown_call\n \t\t\t       (node, callee_edge, flags,\n-\t\t\t\tcur_summary, cur_summary_lto);\n+\t\t\t\tcur_summary, cur_summary_lto,\n+\t\t\t\tnontrivial_scc);\n \t\t  if (!cur_summary && !cur_summary_lto)\n \t\t    break;\n \t\t  continue;\n@@ -4226,7 +4241,8 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t\t    fprintf (dump_file, \"      No call target summary\\n\");\n \t\t  changed |= propagate_unknown_call\n \t\t\t       (node, callee_edge, flags,\n-\t\t\t\tcur_summary, NULL);\n+\t\t\t\tcur_summary, NULL,\n+\t\t\t\tnontrivial_scc);\n \t\t}\n \t      if (cur_summary_lto\n \t\t  && !(callee_summary_lto = summaries_lto->get (callee)))\n@@ -4235,9 +4251,27 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t\t    fprintf (dump_file, \"      No call target summary\\n\");\n \t\t  changed |= propagate_unknown_call\n \t\t\t       (node, callee_edge, flags,\n-\t\t\t\tNULL, cur_summary_lto);\n+\t\t\t\tNULL, cur_summary_lto,\n+\t\t\t\tnontrivial_scc);\n \t\t}\n \n+\t      if (callee_summary && !cur_summary->side_effects\n+\t\t  && (callee_summary->side_effects\n+\t\t      || callee_edge->recursive_p ()))\n+\t\t{\n+\t\t  cur_summary->side_effects = true;\n+\t\t  changed = true;\n+\t\t}\n+\t      if (callee_summary_lto && !cur_summary_lto->side_effects\n+\t\t  && (callee_summary_lto->side_effects\n+\t\t      || callee_edge->recursive_p ()))\n+\t\t{\n+\t\t  cur_summary_lto->side_effects = true;\n+\t\t  changed = true;\n+\t\t}\n+\t      if (flags & (ECF_CONST | ECF_NOVOPS))\n+\t\tcontinue;\n+\n \t      /* We can not safely optimize based on summary of callee if it\n \t\t does not always bind to current def: it is possible that\n \t\t memory load was optimized out earlier which may not happen in\n@@ -4265,12 +4299,6 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t\t  changed |= cur_summary->loads->merge\n \t\t\t\t  (callee_summary->loads, &parm_map,\n \t\t\t\t   &chain_map, !first);\n-\t\t  if (!cur_summary->side_effects\n-\t\t      && callee_summary->side_effects)\n-\t\t    {\n-\t\t      cur_summary->side_effects = true;\n-\t\t      changed = true;\n-\t\t    }\n \t\t  if (!ignore_stores)\n \t\t    {\n \t\t      changed |= cur_summary->stores->merge\n@@ -4289,12 +4317,6 @@ modref_propagate_in_scc (cgraph_node *component_node)\n \t\t  changed |= cur_summary_lto->loads->merge\n \t\t\t\t  (callee_summary_lto->loads, &parm_map,\n \t\t\t\t   &chain_map, !first);\n-\t\t  if (!cur_summary_lto->side_effects\n-\t\t      && callee_summary_lto->side_effects)\n-\t\t    {\n-\t\t      cur_summary_lto->side_effects = true;\n-\t\t      changed = true;\n-\t\t    }\n \t\t  if (!ignore_stores)\n \t\t    {\n \t\t      changed |= cur_summary_lto->stores->merge"}]}