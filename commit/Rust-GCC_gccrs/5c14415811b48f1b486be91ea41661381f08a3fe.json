{"sha": "5c14415811b48f1b486be91ea41661381f08a3fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWMxNDQxNTgxMWI0OGYxYjQ4NmJlOTFlYTQxNjYxMzgxZjA4YTNmZQ==", "commit": {"author": {"name": "Mohan Embar", "email": "gnustuff@thisiscool.com", "date": "2003-08-29T04:21:01Z"}, "committer": {"name": "Mohan Embar", "email": "membar@gcc.gnu.org", "date": "2003-08-29T04:21:01Z"}, "message": "win32.cc: fixed tab...\n\n\t* win32.cc: fixed tab, indentation and whitespace\n\tinconsistencies\n\tremoved jvm.h include\n\tadded includes java/lang/UnsupportedOperationException.h,\n\tjava/io/IOException.h, java/net/SocketException.h\n\t(WSAEventWrapper): class implementation\n\t(_Jv_WinStrError): implemented both overloads\n\t(_Jv_ThrowIOException): implemented both overloads\n\t(_Jv_ThrowSocketException): implemented both overloads\n\t(_Jv_select): implemented\n\t* include/win32.h: fixed tab, indentation and whitespace\n\tinconsistencies\n\twrapped <windows.h> include with  #define WIN32_LEAN_AND_MEAN\n\tadded jvm.h include\n\t(WSAEventWrapper): added class declaration\n\t(_Jv_WinStrError): added both overload declarations\n\t(_Jv_ThrowIOException): added both overload declarations\n\t(_Jv_ThrowSocketException): added both overload declarations\n\tremoved ENOTCONN, ECONNRESET and ENOPROTOOPT defines\n\t(_Jv_select): added declaration\n\t(_Jv_socket): removed\n\t(_Jv_connect): removed\n\t(_Jv_close): removed\n\t(_Jv_bind): removed\n\t(_Jv_accept): removed\n\t(_Jv_listen): removed\n\t(_Jv_write): removed\n\t(_Jv_read): removed\n\t* java/io/natFileDescriptorWin32.cc: fixed tab, indentation and\n\twhitespace inconsistencies\n\treplaced <windows.h> #include with <platform.h>\n\tremoved jvm.h include\n\t(testCanUseGetHandleInfo): new function which tests whether Win32\n\tGetHandleInformation() call can be used with console buffer handles\n\t(only supported on >=WinNT 5.0)\n\t(winerr): removed (superseded by _Jv_WinStrError in include/win32.h)\n\t(valid): rewrote implementation using GetHandleInformation()\n\t(sync): \tchanged exception throwing to use error string and exception\n\thelper methods declared in include/win32.h\n\t(open): likewise\n\t(write): likewise\n\t(setLength): likewise\n\t(close): likewise\n\t(seek): likewise\n\t(getFilePointer): likewise\n\t(read): likewise\n\t* java/io/natFileWin32.cc: fixed tab, indentation and\n\twhitespace inconsistencies\n\treplaced <windows.h> #include with <platform.h>\n\tremoved jvm.h include\n\t(_access): use JV_TEMP_UTF_STRING\n\t(_stat): likewise\n\t(performMkDir): use JV_TEMP_UTF_STRING\n\t(performRenameTo): likewise\n\t(performDelete): likewise\n\t(performCreate): likewise\n\t(performSetReadOnly): likewise\n\t(performSetLastModified): likewise\n\t* java/lang/natWin32Process.cc: fixed tab, indentation and\n\twhitespace inconsistencies\n\treplaced <windows.h> #include with <platform.h>\n\tremoved includes gcj/cni.h, jvm.h\n\t(new_string): removed\n\t(startProcess): use JV_TEMP_UTF_STRING,\n\tchanged exception throwing to use error string and exception\n\thelper methods declared in include/win32.h\n\t* java/net/natInetAddressWin32.cc: fixed tab, indentation and\n\twhitespace inconsistencies\n\treplaced <windows.h> #include with <platform.h>\n\tremoved jvm.h include\n\tremoved DISABLE_JAVA_NET conditional code\n\tremoved POSIX conditional code not relevant to Win32\n\t(aton): use JV_TEMP_UTF_STRING\n\tremoved POSIX conditional code not relevant to Win32\n\t(lookup): likewise\n\t(getLocalHostName): likewise\n\t* java/net/natNetworkInterfaceWin32.cc: fixed tab, indentation and\n\twhitespace inconsistencies\n\tremoved unnecessary windows.h, winsock.h and gcj/cni.h includes\n\tremoved DISABLE_JAVA_NET conditional code\n\tremoved POSIX conditional code not relevant to Win32\n\t(winsock2GetRealNetworkInterfaces): new function to compute network\n\tinterfaces via Winsock2 API\n\t(determineGetRealNetworkInterfacesFN): new function for returning\n\ta function pointer to the function used to compute network interfaces.\n\t(getRealNetworkInterfaces): implemented\n\t* java/net/natPlainDatagramSocketImplWin32.cc: fixed tab, indentation and\n\twhitespace inconsistencies\n\tremoved gcj/cni.h include\n\tremoved DISABLE_JAVA_NET conditional code\n\tremoved POSIX conditional code not relevant to Win32\n\tchanged net POSIXisms to Win32isms\n\treplaced _Jv socket-related calls with their real Win32 equivalents\n\tchanged exception throwing to use error string and exception\n\thelper methods declared in include/win32.h\n\t(peekData): implemented timeout support\n\t(receive): likewise\n\t* java/net/natPlainSocketImplWin32.cc: fixed tab, indentation and\n\twhitespace inconsistencies\n\tremoved gcj/cni.h and gcj/javaprims.h includes\n\tremoved DISABLE_JAVA_NET conditional code\n\tremoved POSIX conditional code not relevant to Win32\n\tchanged net POSIXisms to Win32isms\n\treplaced _Jv socket-related calls with their real Win32\n\tequivalents\n\tchanged exception throwing to use error string and exception\n\thelper methods declared in include/win32.h\n\t(throwConnectException): helper function for connect()\n\t(connect): implemented timeout support\n\t(accept): likewise\n\t(doRead): new helper function common to both read() method overloads,\n\tincludes timeout support\n\t(read): implemented both overloads in terms of doRead()\n\t(available): implemented using ioctlsocket()\n\nFrom-SVN: r70904", "tree": {"sha": "236d99541a3b4c358a6a326abd76276ce8557c33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/236d99541a3b4c358a6a326abd76276ce8557c33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c14415811b48f1b486be91ea41661381f08a3fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c14415811b48f1b486be91ea41661381f08a3fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c14415811b48f1b486be91ea41661381f08a3fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c14415811b48f1b486be91ea41661381f08a3fe/comments", "author": null, "committer": null, "parents": [{"sha": "a1d6cdc2d7a48f9b584e2323b173176055adc53a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1d6cdc2d7a48f9b584e2323b173176055adc53a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1d6cdc2d7a48f9b584e2323b173176055adc53a"}], "stats": {"total": 2391, "additions": 978, "deletions": 1413}, "files": [{"sha": "d0c28f8ad0f48ff00663bafde62822139d202472", "filename": "libjava/ChangeLog", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c14415811b48f1b486be91ea41661381f08a3fe/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c14415811b48f1b486be91ea41661381f08a3fe/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=5c14415811b48f1b486be91ea41661381f08a3fe", "patch": "@@ -1,3 +1,120 @@\n+2003-08-28  Mohan Embar  <gnustuff@thisiscool.com>\n+\n+\t* win32.cc: fixed tab, indentation and whitespace\n+\tinconsistencies\n+\tremoved jvm.h include\n+\tadded includes java/lang/UnsupportedOperationException.h,\n+\tjava/io/IOException.h, java/net/SocketException.h\n+\t(WSAEventWrapper): class implementation\n+\t(_Jv_WinStrError): implemented both overloads\n+\t(_Jv_ThrowIOException): implemented both overloads\n+\t(_Jv_ThrowSocketException): implemented both overloads\n+\t(_Jv_select): implemented\n+\t* include/win32.h: fixed tab, indentation and whitespace\n+\tinconsistencies\n+\twrapped <windows.h> include with  #define WIN32_LEAN_AND_MEAN\n+\tadded jvm.h include\n+\t(WSAEventWrapper): added class declaration\n+\t(_Jv_WinStrError): added both overload declarations\n+\t(_Jv_ThrowIOException): added both overload declarations\n+\t(_Jv_ThrowSocketException): added both overload declarations\n+\tremoved ENOTCONN, ECONNRESET and ENOPROTOOPT defines\n+\t(_Jv_select): added declaration\n+\t(_Jv_socket): removed\n+\t(_Jv_connect): removed\n+\t(_Jv_close): removed\n+\t(_Jv_bind): removed\n+\t(_Jv_accept): removed\n+\t(_Jv_listen): removed\n+\t(_Jv_write): removed\n+\t(_Jv_read): removed\n+\t* java/io/natFileDescriptorWin32.cc: fixed tab, indentation and\n+\twhitespace inconsistencies\n+\treplaced <windows.h> #include with <platform.h>\n+\tremoved jvm.h include\n+\t(testCanUseGetHandleInfo): new function which tests whether Win32\n+\tGetHandleInformation() call can be used with console buffer handles\n+\t(only supported on >=WinNT 5.0)\n+\t(winerr): removed (superseded by _Jv_WinStrError in include/win32.h)\n+\t(valid): rewrote implementation using GetHandleInformation()\n+\t(sync): \tchanged exception throwing to use error string and exception\n+\thelper methods declared in include/win32.h\n+\t(open): likewise\n+\t(write): likewise\n+\t(setLength): likewise\n+\t(close): likewise\n+\t(seek): likewise\n+\t(getFilePointer): likewise\n+\t(read): likewise\n+\t* java/io/natFileWin32.cc: fixed tab, indentation and\n+\twhitespace inconsistencies\n+\treplaced <windows.h> #include with <platform.h>\n+\tremoved jvm.h include\n+\t(_access): use JV_TEMP_UTF_STRING\n+\t(_stat): likewise\n+\t(performMkDir): use JV_TEMP_UTF_STRING\n+\t(performRenameTo): likewise\n+\t(performDelete): likewise\n+\t(performCreate): likewise\n+\t(performSetReadOnly): likewise\n+\t(performSetLastModified): likewise\n+\t* java/lang/natWin32Process.cc: fixed tab, indentation and\n+\twhitespace inconsistencies\n+\treplaced <windows.h> #include with <platform.h>\n+\tremoved includes gcj/cni.h, jvm.h\n+\t(new_string): removed\n+\t(startProcess): use JV_TEMP_UTF_STRING,\n+\tchanged exception throwing to use error string and exception\n+\thelper methods declared in include/win32.h\n+\t* java/net/natInetAddressWin32.cc: fixed tab, indentation and\n+\twhitespace inconsistencies\n+\treplaced <windows.h> #include with <platform.h>\n+\tremoved jvm.h include\n+\tremoved DISABLE_JAVA_NET conditional code\n+\tremoved POSIX conditional code not relevant to Win32\n+\t(aton): use JV_TEMP_UTF_STRING\n+\tremoved POSIX conditional code not relevant to Win32\n+\t(lookup): likewise\n+\t(getLocalHostName): likewise\n+\t* java/net/natNetworkInterfaceWin32.cc: fixed tab, indentation and\n+\twhitespace inconsistencies\n+\tremoved unnecessary windows.h, winsock.h and gcj/cni.h includes\n+\tremoved DISABLE_JAVA_NET conditional code\n+\tremoved POSIX conditional code not relevant to Win32\n+\t(winsock2GetRealNetworkInterfaces): new function to compute network\n+\tinterfaces via Winsock2 API\n+\t(determineGetRealNetworkInterfacesFN): new function for returning\n+\ta function pointer to the function used to compute network interfaces.\n+\t(getRealNetworkInterfaces): implemented\n+\t* java/net/natPlainDatagramSocketImplWin32.cc: fixed tab, indentation and\n+\twhitespace inconsistencies\n+\tremoved gcj/cni.h include\n+\tremoved DISABLE_JAVA_NET conditional code\n+\tremoved POSIX conditional code not relevant to Win32\n+\tchanged net POSIXisms to Win32isms\n+\treplaced _Jv socket-related calls with their real Win32 equivalents\n+\tchanged exception throwing to use error string and exception\n+\thelper methods declared in include/win32.h\n+\t(peekData): implemented timeout support\n+\t(receive): likewise\n+\t* java/net/natPlainSocketImplWin32.cc: fixed tab, indentation and\n+\twhitespace inconsistencies\n+\tremoved gcj/cni.h and gcj/javaprims.h includes\n+\tremoved DISABLE_JAVA_NET conditional code\n+\tremoved POSIX conditional code not relevant to Win32\n+\tchanged net POSIXisms to Win32isms\n+\treplaced _Jv socket-related calls with their real Win32\n+\tequivalents\n+\tchanged exception throwing to use error string and exception\n+\thelper methods declared in include/win32.h\n+\t(throwConnectException): helper function for connect()\n+\t(connect): implemented timeout support\n+\t(accept): likewise\n+\t(doRead): new helper function common to both read() method overloads,\n+\tincludes timeout support\n+\t(read): implemented both overloads in terms of doRead()\n+\t(available): implemented using ioctlsocket()\n+\n 2003-08-28  Mohan Embar  <gnustuff@thisiscool.com>\n \n \t* java/net/natInetAddressWin32.cc,"}, {"sha": "6da0eafaa9a286de9925b7d99df4d3502bac3bde", "filename": "libjava/include/win32.h", "status": "modified", "additions": 48, "deletions": 60, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c14415811b48f1b486be91ea41661381f08a3fe/libjava%2Finclude%2Fwin32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c14415811b48f1b486be91ea41661381f08a3fe/libjava%2Finclude%2Fwin32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fwin32.h?ref=5c14415811b48f1b486be91ea41661381f08a3fe", "patch": "@@ -11,11 +11,14 @@ details.  */\n #ifndef __JV_WIN32_H__\n #define __JV_WIN32_H__\n \n+#define WIN32_LEAN_AND_MEAN\n #include <windows.h>\n+#undef WIN32_LEAN_AND_MEAN\n #undef STRICT\n \n #include <ws2tcpip.h>\n #include <gcj/cni.h>\n+#include <jvm.h>\n #include <java/util/Properties.h>\n \n #include <io.h>\n@@ -40,21 +43,58 @@ details.  */\n // with the JNICALL definition in jni.h\n #define _Jv_platform_ffi_abi FFI_STDCALL\n \n-#ifndef DISABLE_JAVA_NET\n+/* Useful helper classes and methods. */\n \n-// these errors cannot occur on Win32\n-#define ENOTCONN 0\n-#define ECONNRESET 0\n+/* A C++ wrapper around a WSAEVENT which closes the event\n+\t in its destructor. If dwSelFlags is non-zero, we also\n+\t issue an WSAEventSelect on the socket descriptor with\n+\t the given flags; this is undone by a corresponding call\n+\t to WSAEventSelect(fd, 0, 0) in our destructor. */\n+class WSAEventWrapper\n+{\n+public:\n+\tWSAEventWrapper(int fd, DWORD dwSelFlags);\n+\t~WSAEventWrapper();\n+\n+\tWSAEVENT getEventHandle()\n+\t{\n+\t\treturn m_hEvent;\n+\t}\n+\n+private:\n+\tWSAEVENT m_hEvent;\n+\tint m_fd;\n+\tDWORD m_dwSelFlags;\n+};\n+\n+// Error string text. The int argument is compatible\n+// with both int WSAGetLastError() and DWORD GetLastError()\n+// I tried avoiding having to pass the error explicitly, but\n+// it didn't work this was invoked with say\n+// throw new SomeException(_Jv_WinStrError()).\n+extern jstring\n+_Jv_WinStrError (LPCTSTR lpszPrologue, int nErrorCode);\n+\n+extern jstring\n+_Jv_WinStrError (int nErrorCode);\n \n-#ifndef ENOPROTOOPT\n-#define ENOPROTOOPT 109\n-#endif\n+extern void\n+_Jv_ThrowIOException (DWORD dwErrorCode);\n \n-#endif // DISABLE_JAVA_NET\n+extern void\n+_Jv_ThrowIOException ();\n \n+extern void\n+_Jv_ThrowSocketException (DWORD dwErrorCode);\n+\n+extern void\n+_Jv_ThrowSocketException ();\n+\n+// Platform implementation\n extern void _Jv_platform_initialize (void);\n extern void _Jv_platform_initProperties (java::util::Properties*);\n extern jlong _Jv_platform_gettimeofday ();\n+extern int _Jv_select (int n, fd_set *, fd_set *, fd_set *, struct timeval *);\n \n inline void\n _Jv_platform_close_on_exec (jint)\n@@ -77,58 +117,6 @@ _Jv_platform_usleep (unsigned long usecs)\n }\n #endif /* JV_HASH_SYNCHRONIZATION */\n \n-#ifndef DISABLE_JAVA_NET\n-\n-static inline int\n-_Jv_socket (int domain, int type, int protocol)\n-{\n-  return ::socket (domain, type, protocol);\n-}\n-\n-inline int\n-_Jv_connect (jint fd, sockaddr *ptr, int len)\n-{\n-  return ::connect (fd, ptr, len);\n-}\n-\n-inline int\n-_Jv_close (jint fd)\n-{\n-  return ::closesocket (fd);\n-}\n-\n-inline int\n-_Jv_bind (int fd, struct sockaddr *addr, int addrlen)\n-{\n-  return ::bind (fd, addr, addrlen);\n-}\n-\n-inline int\n-_Jv_accept (int fd, struct sockaddr *addr, socklen_t *addrlen)\n-{\n-  return ::accept (fd, addr, addrlen);\n-}\n-\n-inline int\n-_Jv_listen (int fd, int backlog)\n-{\n-  return ::listen (fd, backlog);\n-}\n-\n-inline int\n-_Jv_write(int s, void *buf, int len)\n-{\n-  return ::send (s, (char*) buf, len, 0);\n-}\n-\n-inline int\n-_Jv_read(int s, void *buf, int len)\n-{\n-  return ::recv (s, (char*) buf, len, 0);\n-}\n-\n-#endif /* DISABLE_JAVA_NET */\n-\n /* Store up to SIZE return address of the current program state in\n    ARRAY and return the exact number of values stored.  */\n extern int backtrace (void **__array, int __size);"}, {"sha": "1891bf78e4222acf1496fd7c37e7b5169aa8f738", "filename": "libjava/java/io/natFileDescriptorWin32.cc", "status": "modified", "additions": 70, "deletions": 71, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c14415811b48f1b486be91ea41661381f08a3fe/libjava%2Fjava%2Fio%2FnatFileDescriptorWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c14415811b48f1b486be91ea41661381f08a3fe/libjava%2Fjava%2Fio%2FnatFileDescriptorWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatFileDescriptorWin32.cc?ref=5c14415811b48f1b486be91ea41661381f08a3fe", "patch": "@@ -13,15 +13,13 @@ details.  */\n // need to change to use the windows asynchronous IO functions\n \n #include <config.h>\n+#include <platform.h>\n \n #include <stdio.h>\n #include <string.h>\n \n-#include <windows.h>\n #undef STRICT\n \n-#include <gcj/cni.h>\n-#include <jvm.h>\n #include <java/io/FileDescriptor.h>\n #include <java/io/SyncFailedException.h>\n #include <java/io/IOException.h>\n@@ -33,6 +31,16 @@ details.  */\n #include <java/lang/Thread.h>\n #include <java/io/FileNotFoundException.h>\n \n+static bool testCanUseGetHandleInfo()\n+{\n+  /* Test to see whether GetHandleInformation can be used\n+     for console input or screen buffers. This is better\n+     a kludgy OS version check. */\n+  DWORD dwFlags;\n+  return GetHandleInformation (GetStdHandle (STD_INPUT_HANDLE),\n+    &dwFlags) != 0;\n+}\n+\n // FIXME: casting a FILE (pointer) to a jint will not work on Win64 --\n //        we should be using gnu.gcj.RawData's.\n \n@@ -44,41 +52,32 @@ java::io::FileDescriptor::init(void)\n   err = new java::io::FileDescriptor((jint)(GetStdHandle (STD_ERROR_HANDLE)));\n }\n \n-static char *\n-winerr (void)\n-{\n-  static LPVOID last = NULL;\n-  LPVOID old = NULL;\n-\n-  if (last)\n-    old = last;\n-\n-  FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER |\n-    FORMAT_MESSAGE_FROM_SYSTEM |\n-    FORMAT_MESSAGE_IGNORE_INSERTS,\n-    NULL,\n-    GetLastError(),\n-    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n-    (LPTSTR) &last,\n-    0,\n-    NULL);\n-\n-  if (old)\n-    LocalFree (old);\n-\n-  return (char *)last;\n-}\n-\n jboolean\n java::io::FileDescriptor::valid (void) {\n-  BY_HANDLE_FILE_INFORMATION info;\n-  return GetFileInformationByHandle ((HANDLE)fd, &info) != 0;\n+  static bool bCanUseGetHandleInfo = testCanUseGetHandleInfo();\n+  if (bCanUseGetHandleInfo)\n+  {\n+    /* As with UNIX, a \"file\" descriptor can be one of\n+       a gazillion possible underlying things like a pipe\n+       or socket, so we can't get too fancy here. */\n+    DWORD dwFlags;\n+    HANDLE h = (HANDLE) fd;\n+    return GetHandleInformation (h, &dwFlags) != 0;\n+  }\n+  else\n+  {\n+    /* Can't use GetHandleInformation() for console handles on < WinNT 5. */\n+    return true;\n+  }\n }\n \n void\n java::io::FileDescriptor::sync (void) {\n   if (! FlushFileBuffers ((HANDLE)fd))\n-    throw new SyncFailedException (JvNewStringLatin1 (winerr ()));\n+  {\n+    DWORD dwErrorCode = GetLastError ();\n+    throw new SyncFailedException (_Jv_WinStrError (dwErrorCode));\n+  }\n }\n \n jint\n@@ -87,20 +86,18 @@ java::io::FileDescriptor::open (jstring path, jint jflags) {\n   HANDLE handle = NULL;\n   DWORD access = 0;\n   DWORD create = OPEN_EXISTING;\n-  char buf[MAX_PATH] = \"\";\n-\n-  jsize total = JvGetStringUTFRegion(path, 0, path->length(), buf);\n-  buf[total] = '\\0';\n+  \n+  JV_TEMP_UTF_STRING(cpath, path)\n \n   JvAssert((jflags & READ) || (jflags & WRITE));\n \n   if ((jflags & READ) && (jflags & WRITE))\n     {\n       access = GENERIC_READ | GENERIC_WRITE;\n       if (jflags & EXCL)\n-\tcreate = CREATE_NEW; // this will raise error if file exists.\n+        create = CREATE_NEW; // this will raise error if file exists.\n       else\n-\tcreate = OPEN_ALWAYS; // equivalent to O_CREAT\n+        create = OPEN_ALWAYS; // equivalent to O_CREAT\n     }\n   else if (jflags & READ)\n     {\n@@ -111,28 +108,30 @@ java::io::FileDescriptor::open (jstring path, jint jflags) {\n     { \n       access = GENERIC_WRITE;\n       if (jflags & EXCL)\n-\tcreate = CREATE_NEW;\n+        create = CREATE_NEW;\n       else if (jflags & APPEND)\n-\tcreate = OPEN_ALWAYS;\n+        create = OPEN_ALWAYS;\n       else\n-\tcreate = CREATE_ALWAYS;\n+        create = CREATE_ALWAYS;\n     }\n \n-  handle = CreateFile(buf, access, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, create, 0, NULL);\n+  handle = CreateFile(cpath, access, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, create, 0, NULL);\n \n   if (handle == INVALID_HANDLE_VALUE)\n     {\n-      char msg[MAX_PATH + 1000];\n-      sprintf (msg, \"%s: %s\", buf, winerr ());\n-      throw new FileNotFoundException (JvNewStringLatin1 (msg));\n+       DWORD dwErrorCode = GetLastError ();\n+       throw new FileNotFoundException (_Jv_WinStrError (cpath, dwErrorCode));\n     }\n \n   // For APPEND mode, move the file pointer to the end of the file.\n   if (jflags & APPEND)\n     {\n       DWORD low = SetFilePointer (handle, 0, NULL, FILE_END);\n       if ((low == 0xffffffff) && (GetLastError () != NO_ERROR)) \n-        throw new FileNotFoundException (JvNewStringLatin1 (winerr ()));\n+      {\n+        DWORD dwErrorCode = GetLastError ();\n+        throw new FileNotFoundException (_Jv_WinStrError (cpath, dwErrorCode));\n+      }\n     }\n   return (jint)handle;\n }\n@@ -149,13 +148,13 @@ java::io::FileDescriptor::write (jint b)\n         {\n           InterruptedIOException *iioe = new InterruptedIOException (JvNewStringLatin1 (\"write interrupted\"));\n           iioe->bytesTransferred = bytesWritten;\n-\t  throw iioe;\n+    throw iioe;\n         }\n       if (bytesWritten != 1)\n-\tthrow new IOException (JvNewStringLatin1 (winerr ()));\n+        _Jv_ThrowIOException ();\n     }\n   else\n-    throw new IOException (JvNewStringLatin1 (winerr ()));\n+    _Jv_ThrowIOException ();\n   // FIXME: loop until bytesWritten == 1\n }\n \n@@ -175,11 +174,11 @@ java::io::FileDescriptor::write(jbyteArray b, jint offset, jint len)\n         {\n           InterruptedIOException *iioe = new InterruptedIOException (JvNewStringLatin1 (\"write interrupted\"));\n           iioe->bytesTransferred = bytesWritten;\n-\t  throw iioe;\n+    throw iioe;\n         }\n     }\n   else\n-    throw new IOException (JvNewStringLatin1 (winerr ()));\n+    _Jv_ThrowIOException ();\n   // FIXME: loop until bytesWritten == len\n }\n \n@@ -189,7 +188,7 @@ java::io::FileDescriptor::close (void)\n   HANDLE save = (HANDLE)fd;\n   fd = (jint)INVALID_HANDLE_VALUE;\n   if (! CloseHandle (save))\n-    throw new IOException (JvNewStringLatin1 (winerr ()));\n+    _Jv_ThrowIOException ();\n }\n \n void\n@@ -201,46 +200,46 @@ java::io::FileDescriptor::setLength(jlong pos)\n \n   // Get the original file pointer.\n   if (SetFilePointer((HANDLE) fd, (LONG) 0, &liOrigFilePointer,\n-\t\t     FILE_CURRENT) != (BOOL) 0\n+         FILE_CURRENT) != (BOOL) 0\n       && (GetLastError() != NO_ERROR))\n-    throw new IOException (JvNewStringLatin1 (winerr ()));\n+    _Jv_ThrowIOException ();\n \n   // Get the length of the file.\n   if (SetFilePointer((HANDLE) fd, (LONG) 0, &liEndFilePointer,\n-\t\t     FILE_END) != (BOOL) 0\n+         FILE_END) != (BOOL) 0\n       && (GetLastError() != NO_ERROR))\n-    throw new IOException (JvNewStringLatin1 (winerr ()));\n+    _Jv_ThrowIOException ();\n \n   if ((jlong)liEndFilePointer == pos)\n     {\n       // Restore the file pointer.\n       if (liOrigFilePointer != liEndFilePointer)\n-\t{\n-\t  if (SetFilePointer((HANDLE) fd, liOrigFilePointer, &liNewFilePointer,\n-\t\t\t     FILE_BEGIN) != (BOOL) 0\n-\t      && (GetLastError() != NO_ERROR))\n-\t    throw new IOException (JvNewStringLatin1 (winerr ()));\n-\t}\n+  {\n+    if (SetFilePointer((HANDLE) fd, liOrigFilePointer, &liNewFilePointer,\n+           FILE_BEGIN) != (BOOL) 0\n+        && (GetLastError() != NO_ERROR))\n+      _Jv_ThrowIOException ();\n+  }\n       return;\n     }\n \n   // Seek to the new end of file.\n   if (SetFilePointer((HANDLE) fd, (LONG) pos, &liNewFilePointer,\n-\t\t     FILE_BEGIN) != (BOOL) 0\n+         FILE_BEGIN) != (BOOL) 0\n       && (GetLastError() != NO_ERROR))\n-    throw new IOException (JvNewStringLatin1 (winerr ()));\n+    _Jv_ThrowIOException ();\n \n   // Truncate the file at this point.\n   if (SetEndOfFile((HANDLE) fd) != (BOOL) 0 && (GetLastError() != NO_ERROR))\n-    throw new IOException (JvNewStringLatin1 (winerr ()));\n+    _Jv_ThrowIOException ();\n \n   if (liOrigFilePointer < liNewFilePointer)\n     {\n       // Restore the file pointer.\n       if (SetFilePointer((HANDLE) fd, liOrigFilePointer, &liNewFilePointer,\n-\t\t\t FILE_BEGIN) != (BOOL) 0\n-\t  && (GetLastError() != NO_ERROR))\n-\tthrow new IOException (JvNewStringLatin1 (winerr ()));\n+        FILE_BEGIN) != (BOOL) 0\n+        && (GetLastError() != NO_ERROR))\n+        _Jv_ThrowIOException ();\n     }\n }\n \n@@ -262,7 +261,7 @@ java::io::FileDescriptor::seek (jlong pos, jint whence, jboolean eof_trunc)\n   LONG high = pos >> 32;\n   DWORD low = SetFilePointer ((HANDLE)fd, (DWORD)(0xffffffff & pos), &high, whence == SET ? FILE_BEGIN : FILE_CURRENT);\n   if ((low == 0xffffffff) && (GetLastError () != NO_ERROR))\n-    throw new IOException (JvNewStringLatin1 (winerr ()));\n+    _Jv_ThrowIOException ();\n   return low;\n }\n \n@@ -272,7 +271,7 @@ java::io::FileDescriptor::getFilePointer(void)\n   LONG high = 0;\n   DWORD low = SetFilePointer ((HANDLE)fd, 0, &high, FILE_CURRENT);\n   if ((low == 0xffffffff) && (GetLastError() != NO_ERROR))\n-    throw new IOException (JvNewStringLatin1 (winerr ()));\n+    _Jv_ThrowIOException ();\n   return (((jlong)high) << 32L) | (jlong)low;\n }\n \n@@ -298,7 +297,7 @@ java::io::FileDescriptor::read(void)\n       if (GetLastError () == ERROR_BROKEN_PIPE)\n         return -1;\n       else\n-        throw new IOException (JvNewStringLatin1 (winerr ()));\n+        _Jv_ThrowIOException ();\n     }\n \n   if (! read)\n@@ -329,7 +328,7 @@ java::io::FileDescriptor::read(jbyteArray buffer, jint offset, jint count)\n       if (GetLastError () == ERROR_BROKEN_PIPE)\n         return -1;\n       else\n-        throw new IOException (JvNewStringLatin1 (winerr ()));\n+        _Jv_ThrowIOException ();\n     }\n \n   if (read == 0) return -1;"}, {"sha": "cee6b00ae1f760efa2ea96f6aa70e7765680bd1c", "filename": "libjava/java/io/natFileWin32.cc", "status": "modified", "additions": 46, "deletions": 72, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c14415811b48f1b486be91ea41661381f08a3fe/libjava%2Fjava%2Fio%2FnatFileWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c14415811b48f1b486be91ea41661381f08a3fe/libjava%2Fjava%2Fio%2FnatFileWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FnatFileWin32.cc?ref=5c14415811b48f1b486be91ea41661381f08a3fe", "patch": "@@ -9,15 +9,13 @@ Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n details.  */\n \n #include <config.h>\n+#include <platform.h>\n \n #include <stdio.h>\n #include <string.h>\n \n-#include <windows.h>\n #undef STRICT\n \n-#include <gcj/cni.h>\n-#include <jvm.h>\n #include <java/io/File.h>\n #include <java/io/IOException.h>\n #include <java/util/Vector.h>\n@@ -42,20 +40,17 @@ details.  */\n jboolean\n java::io::File::_access (jint query)\n {\n-  jstring canon = getCanonicalPath();\n-  if (! canon)\n+  JV_TEMP_UTF_STRING (canon, getCanonicalPath());\n+  if (!canon)\n     return false;\n-  char *buf = (char *) __builtin_alloca (JvGetStringUTFLength (canon) + 1);\n-  jsize total = JvGetStringUTFRegion (canon, 0, canon->length(), buf);\n-  buf[total] = '\\0';\n \n   JvAssert (query == READ || query == WRITE || query == EXISTS);\n \n   // FIXME: Is it possible to differentiate between existing and reading?\n   // If the file exists but cannot be read because of the secuirty attributes\n   // on an NTFS disk this wont work (it reports it can be read but cant)\n   // Could we use something from the security API?\n-  DWORD attributes = GetFileAttributes (buf);\n+  DWORD attributes = GetFileAttributes (canon);\n   if ((query == EXISTS) || (query == READ))\n     return (attributes == 0xffffffff) ? false : true;\n   else\n@@ -65,16 +60,13 @@ java::io::File::_access (jint query)\n jboolean\n java::io::File::_stat (jint query)\n {\n-  jstring canon = getCanonicalPath();\n-  if (! canon)\n+  JV_TEMP_UTF_STRING (canon, getCanonicalPath());\n+  if (!canon)\n     return false;\n-  char *buf = (char *) __builtin_alloca (JvGetStringUTFLength (canon) + 1);\n-  jsize total = JvGetStringUTFRegion (canon, 0, canon->length(), buf);\n-  buf[total] = '\\0';\n \n   JvAssert (query == DIRECTORY || query == ISFILE);\n \n-  DWORD attributes = GetFileAttributes (buf);\n+  DWORD attributes = GetFileAttributes (canon);\n   if (attributes == 0xffffffff)\n     return false;\n \n@@ -87,18 +79,15 @@ java::io::File::_stat (jint query)\n jlong\n java::io::File::attr (jint query)\n {\n-  jstring canon = getCanonicalPath();\n-  if (! canon)\n+  JV_TEMP_UTF_STRING (canon, getCanonicalPath());\n+  if (!canon)\n     return false;\n-  char *buf = (char *) __builtin_alloca (JvGetStringUTFLength (canon) + 1);\n-  jsize total = JvGetStringUTFRegion (canon, 0, canon->length(), buf);\n-  buf[total] = '\\0';\n \n   JvAssert (query == MODIFIED || query == LENGTH);\n \n   WIN32_FIND_DATA info;\n   HANDLE sHandle;\n-  if ( ( sHandle = FindFirstFile( buf, &info)) == INVALID_HANDLE_VALUE)\n+  if ( ( sHandle = FindFirstFile( canon, &info)) == INVALID_HANDLE_VALUE)\n     return 0;\n   \n   FindClose( sHandle);\n@@ -119,13 +108,11 @@ java::io::File::attr (jint query)\n jstring\n java::io::File::getCanonicalPath (void)\n {\n-  char *buf = (char *) __builtin_alloca (JvGetStringUTFLength (path) + 1);\n-  jsize total = JvGetStringUTFRegion (path, 0, path->length(), buf);\n-  buf[total] = '\\0';\n+  JV_TEMP_UTF_STRING (cpath, path);\n \n   LPTSTR unused;\n   char buf2[MAX_PATH];\n-  if(!GetFullPathName(buf, MAX_PATH, buf2, &unused))\n+  if(!GetFullPathName(cpath, MAX_PATH, buf2, &unused))\n     throw new IOException (JvNewStringLatin1 (\"GetFullPathName failed\"));\n \n   // FIXME: what encoding to assume for file names?  This affects many\n@@ -152,7 +139,7 @@ java::io::File::isAbsolute (void)\n       && (path->charAt(0) < 'A' || path->charAt(0) > 'Z'))\n     return false;\n   return (path->charAt(1) == ':'\n-\t  && (path->charAt(2) == '/' || path->charAt(2) == '\\\\'));\n+    && (path->charAt(2) == '/' || path->charAt(2) == '\\\\'));\n }\n \n void java::io::File::init_native () \n@@ -163,8 +150,8 @@ void java::io::File::init_native ()\n \n jobjectArray\n java::io::File::performList (java::io::FilenameFilter *filter, \n-\t\t\t     java::io::FileFilter *fileFilter, \n-\t\t\t     java::lang::Class *clazz)\n+           java::io::FileFilter *fileFilter, \n+           java::lang::Class *clazz)\n {\n   jstring canon = getCanonicalPath();\n   if (! canon)\n@@ -190,16 +177,16 @@ java::io::File::performList (java::io::FilenameFilter *filter,\n           jstring name = JvNewStringUTF (data.cFileName);\n \n           if (filter && !filter->accept(this, name))\n-\t    continue;\n+      continue;\n           if (clazz == &java::io::File::class$)\n-\t    {\n+      {\n               java::io::File *file = new java::io::File (this, name);\n               if (fileFilter && !fileFilter->accept(file))\n-\t\tcontinue;\n-\t      vec->addElement (file);\n-\t    }\n-\t  else\n-\t    vec->addElement (name);\n+    continue;\n+        vec->addElement (file);\n+      }\n+    else\n+      vec->addElement (name);\n         }\n     }\n   while (FindNextFile (handle, &data));\n@@ -217,53 +204,42 @@ java::io::File::performList (java::io::FilenameFilter *filter,\n jboolean\n java::io::File::performMkdir (void)\n {\n-  char *buf = (char *) __builtin_alloca (JvGetStringUTFLength (path) + 1);\n-  jsize total = JvGetStringUTFRegion(path, 0, path->length(), buf);\n-  buf[total] = '\\0';\n-\n-  return (CreateDirectory(buf, NULL)) ? true : false;\n+  JV_TEMP_UTF_STRING (cpath, path);\n+  return (CreateDirectory(cpath, NULL)) ? true : false;\n }\n \n jboolean\n java::io::File::performRenameTo (File *dest)\n {\n-  char *buf = (char *) __builtin_alloca (JvGetStringUTFLength (path) + 1);\n-  jsize total = JvGetStringUTFRegion(path, 0, path->length(), buf);\n-  buf[total] = '\\0';\n-  char *buf2 = (char *) __builtin_alloca (JvGetStringUTFLength (dest->path)\n-\t\t\t\t\t  + 1);\n-  total = JvGetStringUTFRegion(dest->path, 0, dest->path->length(), buf2);\n-  buf2[total] = '\\0';\n-\n-  return (MoveFile(buf, buf2)) ? true : false;\n+  JV_TEMP_UTF_STRING (pathFrom, path);\n+  JV_TEMP_UTF_STRING (pathTo, dest->path);\n+  return (MoveFile(pathFrom, pathTo)) ? true : false;\n }\n \n jboolean\n java::io::File::performDelete ()\n {\n-  jstring canon = getCanonicalPath();\n-  char *buf = (char *) __builtin_alloca (JvGetStringUTFLength (canon) + 1);\n-  jsize total = JvGetStringUTFRegion(canon, 0, canon->length(), buf);\n-  buf[total] = '\\0';\n+  JV_TEMP_UTF_STRING (canon, getCanonicalPath());\n+  if (!canon)\n+    return false;\n \n-  DWORD attributes = GetFileAttributes (buf);\n+  DWORD attributes = GetFileAttributes (canon);\n   if (attributes == 0xffffffff)\n     return false;\n \n   if (attributes & FILE_ATTRIBUTE_DIRECTORY)\n-    return (RemoveDirectory (buf)) ? true : false;\n+    return (RemoveDirectory (canon)) ? true : false;\n   else\n-    return (DeleteFile (buf)) ? true : false;\n+    return (DeleteFile (canon)) ? true : false;\n }\n \n jboolean java::io::File::performCreate (void) \n {\n-  jstring canon = getCanonicalPath ();\n-  char *buf = (char *) __builtin_alloca (JvGetStringUTFLength (canon) + 1);\n-  jsize total = JvGetStringUTFRegion (canon, 0, canon->length (), buf);\n-  buf[total] = '\\0';\n+  JV_TEMP_UTF_STRING (canon, getCanonicalPath());\n+  if (!canon)\n+    return false;\n \n-  HANDLE h = CreateFile (buf, 0, 0, NULL, CREATE_NEW, \n+  HANDLE h = CreateFile (canon, 0, 0, NULL, CREATE_NEW, \n                          FILE_ATTRIBUTE_NORMAL, NULL);\n   if (h != INVALID_HANDLE_VALUE)\n     {\n@@ -281,15 +257,14 @@ jboolean java::io::File::performCreate (void)\n \n jboolean java::io::File::performSetReadOnly ()\n {\n-  jstring canon = getCanonicalPath ();\n-  char *buf = (char *) __builtin_alloca (JvGetStringUTFLength (canon) + 1);\n-  jsize total = JvGetStringUTFRegion (canon, 0, canon->length (), buf);\n-  buf[total] = '\\0';\n+  JV_TEMP_UTF_STRING (canon, getCanonicalPath());\n+  if (!canon)\n+    return false;\n \n-  DWORD attrs = GetFileAttributes (buf);\n+  DWORD attrs = GetFileAttributes (canon);\n   if (attrs != INVALID_FILE_ATTRIBUTES)\n     {\n-      if (SetFileAttributes (buf, attrs | FILE_ATTRIBUTE_READONLY) != 0)\n+      if (SetFileAttributes (canon, attrs | FILE_ATTRIBUTE_READONLY) != 0)\n         return true;\n       else\n         return false;\n@@ -300,10 +275,9 @@ jboolean java::io::File::performSetReadOnly ()\n \n jboolean java::io::File::performSetLastModified (jlong time)\n {\n-  jstring canon = getCanonicalPath ();\n-  char *buf = (char *) __builtin_alloca (JvGetStringUTFLength (canon) + 1);\n-  jsize total = JvGetStringUTFRegion (canon, 0, canon->length (), buf);\n-  buf[total] = '\\0';\n+  JV_TEMP_UTF_STRING (canon, getCanonicalPath());\n+  if (!canon)\n+    return false;\n \n   FILETIME modTime;\n   long long mTime100ns = ((long long) time        /* Ha! */\n@@ -313,7 +287,7 @@ jboolean java::io::File::performSetLastModified (jlong time)\n   modTime.dwHighDateTime = (DWORD) (mTime100ns >> 32);\n \n   jboolean retVal = false;\n-  HANDLE h = CreateFile (buf, FILE_WRITE_ATTRIBUTES, \n+  HANDLE h = CreateFile (canon, FILE_WRITE_ATTRIBUTES, \n                          FILE_SHARE_READ | FILE_SHARE_WRITE, \n                          NULL, OPEN_EXISTING, 0, NULL);\n "}, {"sha": "86fd5b3d25398d818af2323c3b7a6b6de04059dd", "filename": "libjava/java/lang/natWin32Process.cc", "status": "modified", "additions": 14, "deletions": 40, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c14415811b48f1b486be91ea41661381f08a3fe/libjava%2Fjava%2Flang%2FnatWin32Process.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c14415811b48f1b486be91ea41661381f08a3fe/libjava%2Fjava%2Flang%2FnatWin32Process.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatWin32Process.cc?ref=5c14415811b48f1b486be91ea41661381f08a3fe", "patch": "@@ -9,18 +9,11 @@ Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n details.  */\n \n #include <config.h>\n-\n-#include <stdio.h>\n-\n-#define WIN32_LEAN_AND_MEAN\n-#include <windows.h>\n+#include <platform.h>\n \n // Conflicts with the definition in \"java/lang/reflect/Modifier.h\"\n #undef STRICT\n \n-#include <gcj/cni.h>\n-#include <jvm.h>\n-\n #include <java/lang/ConcreteProcess.h>\n #include <java/lang/IllegalThreadStateException.h>\n #include <java/lang/InterruptedException.h>\n@@ -111,16 +104,6 @@ java::lang::ConcreteProcess::waitFor (void)\n   return exitCode;\n }\n \n-static char *\n-new_string (jstring string)\n-{\n-  jsize s = _Jv_GetStringUTFLength (string);\n-  char *buf = (char *) _Jv_Malloc (s + 1);\n-  _Jv_GetStringUTFRegion (string, 0, s, buf);\n-  buf[s] = '\\0';\n-  return buf;\n-}\n-\n void\n java::lang::ConcreteProcess::startProcess (jstringArray progarray,\n                                            jstringArray envp,\n@@ -177,9 +160,7 @@ java::lang::ConcreteProcess::startProcess (jstringArray progarray,\n     }\n \n   // Get the working directory path, if specified.\n-  char *wdir = NULL;\n-  if (dir != NULL)\n-    wdir = new_string (dir->getPath ());\n+  JV_TEMP_UTF_STRING (wdir, dir ? dir->getPath () : 0);\n \n   errorStream = NULL;\n   inputStream = NULL;\n@@ -204,29 +185,25 @@ java::lang::ConcreteProcess::startProcess (jstringArray progarray,\n       sAttrs.lpSecurityDescriptor = NULL;\n \n \n-      char tmpBuff[64];\n       if (CreatePipe (&cldStdInRd, &cldStdInWr, &sAttrs, 0) == 0)\n         {\n-          sprintf (tmpBuff,\n-                   \"Error creating stdin pipe (Win32 Error Code: %lu)\",\n-                   GetLastError ());\n-          throw new IOException (JvNewStringLatin1 (tmpBuff));\n+          DWORD dwErrorCode = GetLastError ();\n+          throw new IOException (_Jv_WinStrError (\"Error creating stdin pipe\",\n+            dwErrorCode));\n         }\n \n       if (CreatePipe (&cldStdOutRd, &cldStdOutWr, &sAttrs, 0) == 0)\n         {\n-          sprintf (tmpBuff,\n-                   \"Error creating stdout pipe (Win32 Error Code: %lu)\",\n-                   GetLastError ());\n-          throw new IOException (JvNewStringLatin1 (tmpBuff));\n+          DWORD dwErrorCode = GetLastError ();\n+          throw new IOException (_Jv_WinStrError (\"Error creating stdout pipe\",\n+            dwErrorCode));\n         }\n \n       if (CreatePipe (&cldStdErrRd, &cldStdErrWr, &sAttrs, 0) == 0)\n         {\n-          sprintf (tmpBuff,\n-                   \"Error creating stderr pipe (Win32 Error Code: %lu)\",\n-                   GetLastError ());\n-          throw new IOException (JvNewStringLatin1 (tmpBuff));\n+          DWORD dwErrorCode = GetLastError ();\n+          throw new IOException (_Jv_WinStrError (\"Error creating stderr pipe\",\n+            dwErrorCode));\n         }\n \n       outputStream = new FileOutputStream\n@@ -263,10 +240,9 @@ java::lang::ConcreteProcess::startProcess (jstringArray progarray,\n                          &si,\n                          &pi) == 0)\n         {\n-          sprintf (tmpBuff,\n-                   \"Error creating child process (Win32 Error Code: %lu)\",\n-                   GetLastError ());\n-          throw new IOException (JvNewStringLatin1 (tmpBuff));\n+          DWORD dwErrorCode = GetLastError ();\n+          throw new IOException (\n+            _Jv_WinStrError (\"Error creating child process\", dwErrorCode));\n         }\n \n       procHandle = (jint ) pi.hProcess;\n@@ -279,8 +255,6 @@ java::lang::ConcreteProcess::startProcess (jstringArray progarray,\n       _Jv_Free (cmdLine);\n       if (env != NULL)\n         _Jv_Free (env);\n-      if (wdir != NULL)\n-        _Jv_Free (wdir);\n     }\n   catch (java::lang::Throwable *thrown)\n     {"}, {"sha": "42c7d7db9e81c4b8ec086f4cd19bf191a2eede56", "filename": "libjava/java/net/natInetAddressWin32.cc", "status": "modified", "additions": 39, "deletions": 226, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c14415811b48f1b486be91ea41661381f08a3fe/libjava%2Fjava%2Fnet%2FnatInetAddressWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c14415811b48f1b486be91ea41661381f08a3fe/libjava%2Fjava%2Fnet%2FnatInetAddressWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatInetAddressWin32.cc?ref=5c14415811b48f1b486be91ea41661381f08a3fe", "patch": "@@ -7,124 +7,26 @@ Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n details.  */\n \n #include <config.h>\n+#include <platform.h>\n \n-#ifdef WIN32\n-\n-#include <windows.h>\n-#include <winsock.h>\n #undef STRICT\n \n-#ifndef MAXHOSTNAMELEN\n-#define MAXHOSTNAMELEN\t64\n-#endif /* MAXHOSTNAMELEN */\n-\n-#else /* WIN32 */\n-\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#endif\n-#include <string.h>\n-#include <errno.h>\n-\n-#include <sys/param.h>\n-#include <sys/types.h>\n-#ifdef HAVE_SYS_SOCKET_H\n-#include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#include <netinet/in.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#include <arpa/inet.h>\n-#endif\n-#ifdef HAVE_NETDB_H\n-#include <netdb.h>\n-#endif\n-\n-#endif /* WIN32 */\n-\n-#include <gcj/cni.h>\n-#include <jvm.h>\n #include <java/net/InetAddress.h>\n #include <java/net/UnknownHostException.h>\n #include <java/lang/SecurityException.h>\n \n-#if defined(HAVE_UNAME) && ! defined(HAVE_GETHOSTNAME)\n-#include <sys/utsname.h>\n-#endif\n-\n-#ifndef HAVE_GETHOSTNAME_DECL\n-extern \"C\" int gethostname (char *name, int namelen);\n-#endif\n-\n-#ifdef DISABLE_JAVA_NET\n-\n-jbyteArray\n-java::net::InetAddress::aton (jstring)\n-{\n-  return NULL;\n-}\n-\n-jint\n-java::net::InetAddress::getFamily (jbyteArray bytes)\n-{\n-  return 0;\n-}\n-\n-JArray<java::net::InetAddress*> *\n-java::net::InetAddress::lookup (jstring, java::net::InetAddress *, jboolean)\n-{\n-  return NULL;\n-}\n-\n-jstring\n-java::net::InetAddress::getLocalHostname ()\n-{\n-  return NULL;\n-}\n-\n-#else /* DISABLE_JAVA_NET */\n-\n jbyteArray\n java::net::InetAddress::aton (jstring host)\n {\n-  char *hostname;\n-  char buf[100];\n-  int len = JvGetStringUTFLength(host);\n-  if (len < 100)\n-    hostname = buf;\n-  else\n-    hostname = (char*) _Jv_AllocBytes (len+1);\n-  JvGetStringUTFRegion (host, 0, host->length(), hostname);\n-  buf[len] = '\\0';\n+  JV_TEMP_UTF_STRING (hostname, host);\n   char* bytes = NULL;\n   int blen = 0;\n-#ifdef HAVE_INET_ATON\n-  struct in_addr laddr;\n-  if (inet_aton (hostname, &laddr))\n+  unsigned long laddr = inet_addr (hostname);\n+  if (laddr != INADDR_NONE)\n     {\n       bytes = (char*) &laddr;\n       blen = 4;\n     }\n-#elif defined(HAVE_INET_ADDR)\n-#if ! HAVE_IN_ADDR_T\n-  typedef jint in_addr_t;\n-#endif\n-  in_addr_t laddr = inet_addr (hostname);\n-  if (laddr != (in_addr_t)(-1))\n-    {\n-      bytes = (char*) &laddr;\n-      blen = 4;\n-    }\n-#endif\n-#if defined (HAVE_INET_PTON) && defined (HAVE_INET6)\n-  char inet6_addr[16];\n-  if (len != 0 && inet_pton (AF_INET6, hostname, inet6_addr) > 0)\n-    {\n-      bytes = inet6_addr;\n-      blen = 16;\n-    }\n-#endif\n   if (blen == 0)\n     return NULL;\n   jbyteArray result = JvNewByteArray (blen);\n@@ -149,69 +51,17 @@ java::net::InetAddress::getFamily (jbyteArray bytes)\n \n JArray<java::net::InetAddress*> *\n java::net::InetAddress::lookup (jstring host, java::net::InetAddress* iaddr,\n-\t\t\t\tjboolean all)\n+        jboolean all)\n {\n   struct hostent *hptr = NULL;\n-#if defined (HAVE_GETHOSTBYNAME_R) || defined (HAVE_GETHOSTBYADDR_R)\n-  struct hostent hent_r;\n-#if HAVE_STRUCT_HOSTENT_DATA\n-  struct hostent_data fixed_buffer, *buffer_r = &fixed_buffer;\n-#else\n-#if defined (__GLIBC__) \n-  // FIXME: in glibc, gethostbyname_r returns NETDB_INTERNAL to herr and\n-  // ERANGE to errno if the buffer size is too small, rather than what is \n-  // expected here. We work around this by setting a bigger buffer size and \n-  // hoping that it is big enough.\n-  char fixed_buffer[1024];\n-#else\n-  char fixed_buffer[200];\n-#endif\n-  char *buffer_r = fixed_buffer;\n-  int size_r = sizeof (fixed_buffer);\n-#endif\n-#endif\n-\n   if (host != NULL)\n     {\n-      char *hostname;\n-      char buf[100];\n-      int len = JvGetStringUTFLength(host);\n-      if (len < 100)\n-\thostname = buf;\n-      else\n-\thostname = (char*) _Jv_AllocBytes (len+1);\n-      JvGetStringUTFRegion (host, 0, host->length(), hostname);\n-      buf[len] = '\\0';\n-#ifdef HAVE_GETHOSTBYNAME_R\n-      while (true)\n-\t{\n-\t  int ok;\n-#if HAVE_STRUCT_HOSTENT_DATA\n-\t  ok = ! gethostbyname_r (hostname, &hent_r, buffer_r);\n-#else\n-\t  int herr = 0;\n-#ifdef GETHOSTBYNAME_R_RETURNS_INT\n-\t  ok = ! gethostbyname_r (hostname, &hent_r, buffer_r, size_r,\n-\t\t\t\t  &hptr, &herr);\n-#else\n-\t  hptr = gethostbyname_r (hostname, &hent_r, buffer_r, size_r, &herr);\n-\t  ok = hptr != NULL;\n-#endif /* GETHOSTNAME_R_RETURNS_INT */\n-\t  if (! ok && herr == ERANGE)\n-\t    {\n-\t      size_r *= 2;\n-\t      buffer_r = (char *) _Jv_AllocBytes (size_r);\n-\t    }\n-\t  else\n-#endif /* HAVE_STRUCT_HOSTENT_DATA */\n-\t    break;\n-\t}\n-#else\n+      JV_TEMP_UTF_STRING (hostname, host);\n+\n       // FIXME: this is insufficient if some other piece of code calls\n       // this gethostbyname.\n       JvSynchronize sync (java::net::InetAddress::localhostAddress);\n       hptr = gethostbyname (hostname);\n-#endif /* HAVE_GETHOSTBYNAME_R */\n     }\n   else\n     {\n@@ -221,74 +71,48 @@ java::net::InetAddress::lookup (jstring host, java::net::InetAddress* iaddr,\n       int type;\n       char *val;\n       if (len == 4)\n-\t{\n-\t  val = chars;\n-\t  type = iaddr->family = AF_INET;\n-\t}\n+        {\n+          val = chars;\n+          type = iaddr->family = AF_INET;\n+        }\n #ifdef HAVE_INET6\n       else if (len == 16)\n-\t{\n-\t  val = (char *) &chars;\n-\t  type = iaddr->family = AF_INET6;\n-\t}\n+      {\n+        val = (char *) &chars;\n+        type = iaddr->family = AF_INET6;\n+      }\n #endif /* HAVE_INET6 */\n       else\n-\tJvFail (\"unrecognized size\");\n+        JvFail (\"unrecognized size\");\n \n-#ifdef HAVE_GETHOSTBYADDR_R\n-      while (true)\n-\t{\n-\t  int ok;\n-#if HAVE_STRUCT_HOSTENT_DATA\n-\t  ok = ! gethostbyaddr_r (val, len, type, &hent_r, buffer_r);\n-#else\n-\t  int herr = 0;\n-#ifdef GETHOSTBYADDR_R_RETURNS_INT\n-\t  ok = ! gethostbyaddr_r (val, len, type, &hent_r,\n-\t\t\t\t  buffer_r, size_r, &hptr, &herr);\n-#else\n-\t  hptr = gethostbyaddr_r (val, len, type, &hent_r,\n-\t\t\t\t  buffer_r, size_r, &herr);\n-\t  ok = hptr != NULL;\n-#endif /* GETHOSTBYADDR_R_RETURNS_INT */\n-\t  if (! ok && herr == ERANGE)\n-\t    {\n-\t      size_r *= 2;\n-\t      buffer_r = (char *) _Jv_AllocBytes (size_r);\n-\t    }\n-\t  else \n-#endif /* HAVE_STRUCT_HOSTENT_DATA */\n-\t    break;\n-\t}\n-#else /* HAVE_GETHOSTBYADDR_R */\n       // FIXME: this is insufficient if some other piece of code calls\n       // this gethostbyaddr.\n       JvSynchronize sync (java::net::InetAddress::localhostAddress);\n       hptr = gethostbyaddr (val, len, type);\n-#endif /* HAVE_GETHOSTBYADDR_R */\n     }\n   if (hptr != NULL)\n     {\n       if (!all)\n         host = JvNewStringUTF (hptr->h_name);\n       java::lang::SecurityException *ex = checkConnect (host);\n       if (ex != NULL)\n-\t{\n-\t  if (iaddr == NULL || iaddr->addr == NULL)\n-\t    throw ex;\n-\t  hptr = NULL;\n-\t}\n+        {\n+          if (iaddr == NULL || iaddr->addr == NULL)\n+            throw ex;\n+          hptr = NULL;\n+        }\n     }\n   if (hptr == NULL)\n     {\n       if (iaddr != NULL && iaddr->addr != NULL)\n-\t{\n-\t  iaddr->hostName = iaddr->getHostAddress();\n-\t  return NULL;\n-\t}\n+        {\n+          iaddr->hostName = iaddr->getHostAddress();\n+          return NULL;\n+        }\n       else\n-\tthrow new java::net::UnknownHostException(host);\n+        throw new java::net::UnknownHostException(host);\n     }\n+\n   int count;\n   if (all)\n     {\n@@ -298,6 +122,7 @@ java::net::InetAddress::lookup (jstring host, java::net::InetAddress* iaddr,\n     }\n   else\n     count = 1;\n+\n   JArray<java::net::InetAddress*> *result;\n   java::net::InetAddress** iaddrs;\n   if (all)\n@@ -314,42 +139,30 @@ java::net::InetAddress::lookup (jstring host, java::net::InetAddress* iaddr,\n   for (int i = 0;  i < count;  i++)\n     {\n       if (iaddrs[i] == NULL)\n-\tiaddrs[i] = new java::net::InetAddress (NULL, NULL);\n+        iaddrs[i] = new java::net::InetAddress (NULL, NULL);\n       if (iaddrs[i]->hostName == NULL)\n         iaddrs[i]->hostName = host;\n       if (iaddrs[i]->addr == NULL)\n-\t{\n-\t  char *bytes = hptr->h_addr_list[i];\n-\t  iaddrs[i]->addr = JvNewByteArray (hptr->h_length);\n-\t  iaddrs[i]->family = getFamily (iaddrs[i]->addr);\n-\t  memcpy (elements (iaddrs[i]->addr), bytes, hptr->h_length);\n-\t}\n+        {\n+          char *bytes = hptr->h_addr_list[i];\n+          iaddrs[i]->addr = JvNewByteArray (hptr->h_length);\n+          iaddrs[i]->family = getFamily (iaddrs[i]->addr);\n+          memcpy (elements (iaddrs[i]->addr), bytes, hptr->h_length);\n+        }\n     }\n+    \n   return result;\n }\n \n jstring\n java::net::InetAddress::getLocalHostname ()\n {\n-  char *chars;\n-#ifdef HAVE_GETHOSTNAME\n-  char buffer[MAXHOSTNAMELEN];\n-  if (gethostname (buffer, MAXHOSTNAMELEN))\n+  char buffer[400];\n+  if (gethostname (buffer, sizeof(buffer)))\n     return NULL;\n-  chars = buffer;\n-#elif HAVE_UNAME\n-  struct utsname stuff;\n-  if (uname (&stuff) != 0)\n-    return NULL;\n-  chars = stuff.nodename;\n-#else\n-  return NULL;\n-#endif\n   // It is admittedly non-optimal to convert the hostname to Unicode\n   // only to convert it back in getByName, but simplicity wins.  Note\n   // that unless there is a SecurityManager, we only get called once\n   // anyway, thanks to the InetAddress.localhost cache.\n-  return JvNewStringUTF (chars);\n+  return JvNewStringUTF (buffer);\n }\n-\n-#endif /* DISABLE_JAVA_NET */"}, {"sha": "20c9a9b596729bd056923ac77b641423776e6969", "filename": "libjava/java/net/natNetworkInterfaceWin32.cc", "status": "modified", "additions": 101, "deletions": 109, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c14415811b48f1b486be91ea41661381f08a3fe/libjava%2Fjava%2Fnet%2FnatNetworkInterfaceWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c14415811b48f1b486be91ea41661381f08a3fe/libjava%2Fjava%2Fnet%2FnatNetworkInterfaceWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatNetworkInterfaceWin32.cc?ref=5c14415811b48f1b486be91ea41661381f08a3fe", "patch": "@@ -9,134 +9,126 @@ details.  */\n #include <config.h>\n #include <platform.h>\n \n-#ifdef WIN32\n-\n-#include <windows.h>\n-#include <winsock.h>\n #undef STRICT\n \n-#else /* WIN32 */\n-\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#endif\n-#include <string.h>\n-#include <errno.h>\n-#include <stdlib.h>\n-\n-#include <sys/param.h>\n-#include <sys/types.h>\n-#ifdef HAVE_NETINET_IN_H\n-#include <netinet/in.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#include <arpa/inet.h>\n-#endif\n-#ifdef HAVE_NETDB_H\n-#include <netdb.h>\n-#endif\n-#ifdef HAVE_SYS_IOCTL_H\n-#define BSD_COMP /* Get FIONREAD on Solaris2. */\n-#include <sys/ioctl.h>\n-#endif\n-#ifdef HAVE_NET_IF_H\n-#include <net/if.h>\n-#endif\n-\n-#endif /* WIN32 */\n-\n-#include <gcj/cni.h>\n-#include <jvm.h>\n #include <java/net/NetworkInterface.h>\n #include <java/net/Inet4Address.h>\n #include <java/net/SocketException.h>\n #include <java/util/Vector.h>\n \n-#ifdef DISABLE_JAVA_NET\n+/* As of this writing, NetworkInterface.java has\n+   getName() == getDisplayName() and only one IP address\n+   per interface. If this changes, we'll need to use\n+   iphlpapi (not supported on Win95) to retrieve richer\n+   adapter information via GetAdaptersInfo(). In this\n+   module, we provide the necessary hooks to detect the\n+   presence of iphlpapi and use it if necessary, but\n+   comment things out for now to avoid compiler warnings. */\n \n-::java::util::Vector*\n-java::net::NetworkInterface::getRealNetworkInterfaces ()\n-{\n-  ::java::util::Vector* ht = new ::java::util::Vector();\n-  return ht;\n-}\n+enum {MAX_INTERFACES = 50};\n \n-#else /* DISABLE_JAVA_NET */\n+typedef int\n+(*PfnGetRealNetworkInterfaces) (jstring* pjstrName,\n+  java::net::InetAddress** ppAddress);\n \n-::java::util::Vector*\n-java::net::NetworkInterface::getRealNetworkInterfaces ()\n+static int\n+winsock2GetRealNetworkInterfaces (jstring* pjstrName,\n+  java::net::InetAddress** ppAddress)\n {\n-#ifdef WIN32\n-  throw new ::java::net::SocketException;\n-#else\n-  int fd;\n-  int num_interfaces = 0;\n-  struct ifconf if_data;\n-  struct ifreq* if_record;\n-  ::java::util::Vector* ht = new ::java::util::Vector ();\n-\n-  if_data.ifc_len = 0;\n-  if_data.ifc_buf = NULL;\n-\n-  // Open a (random) socket to have a file descriptor for the ioctl calls.\n-  fd = _Jv_socket (PF_INET, SOCK_DGRAM, htons (IPPROTO_IP));\n-\n-  if (fd < 0)\n-    throw new ::java::net::SocketException;\n-\n-  // Get all interfaces. If not enough buffers are available try it\n-  // with a bigger buffer size.\n-  do\n-    {\n-      num_interfaces += 16;\n-      \n-      if_data.ifc_len = sizeof (struct ifreq) * num_interfaces;\n-      if_data.ifc_buf =\n-        (char*) _Jv_Realloc (if_data.ifc_buf, if_data.ifc_len);\n-\n-      // Try to get all local interfaces.\n-      if (::ioctl (fd, SIOCGIFCONF, &if_data) < 0)\n-        throw new java::net::SocketException;\n-    }\n-  while (if_data.ifc_len >= (sizeof (struct ifreq) * num_interfaces));\n-\n+  // FIXME: Add IPv6 support.\n+  \n+  INTERFACE_INFO arInterfaceInfo[MAX_INTERFACES];\n+\n+  // Open a (random) socket to have a file descriptor for the WSAIoctl call.\n+  SOCKET skt = ::socket (AF_INET, SOCK_DGRAM, 0);\n+  if (skt == INVALID_SOCKET) \n+    _Jv_ThrowSocketException ();\n+    \n+  DWORD dwOutBufSize;\n+  int nRetCode = ::WSAIoctl (skt, SIO_GET_INTERFACE_LIST,\n+    NULL, 0, &arInterfaceInfo, sizeof(arInterfaceInfo),\n+    &dwOutBufSize, NULL, NULL);\n+    \n+  if (nRetCode == SOCKET_ERROR)\n+  {\n+    DWORD dwLastErrorCode = WSAGetLastError ();\n+    ::closesocket (skt);\n+    _Jv_ThrowSocketException (dwLastErrorCode);\n+  }\n+  \n   // Get addresses of all interfaces.\n-  if_record = if_data.ifc_req;\n-\n-  for (int n = 0; n < if_data.ifc_len; n += sizeof (struct ifreq))\n+  int nNbInterfaces = dwOutBufSize / sizeof(INTERFACE_INFO);\n+  int nCurETHInterface = 0;\n+  for (int i=0; i < nNbInterfaces; ++i) \n     {\n-      struct ifreq ifr;\n-      \n-      memset (&ifr, 0, sizeof (ifr));\n-      strcpy (ifr.ifr_name, if_record->ifr_name);\n-\n-      // Try to get the IPv4-address of the local interface\n-      if (::ioctl (fd, SIOCGIFADDR, &ifr) < 0)\n-        throw new java::net::SocketException;\n-\n       int len = 4;\n-      struct sockaddr_in sa = *((sockaddr_in*) &(ifr.ifr_addr));\n-\n       jbyteArray baddr = JvNewByteArray (len);\n-      memcpy (elements (baddr), &(sa.sin_addr), len);\n-      jstring if_name = JvNewStringLatin1 (if_record->ifr_name);\n-      Inet4Address* address =\n+      SOCKADDR_IN* pAddr = (SOCKADDR_IN*) &arInterfaceInfo[i].iiAddress;\n+      memcpy (elements (baddr), &(pAddr->sin_addr), len);\n+\n+      // Concoct a name for this interface. Since we don't\n+      // have access to the real name under Winsock 2, we use\n+      // \"lo\" for the loopback interface and ethX for the\n+      // real ones.\n+      char szName[30];\n+      u_long lFlags = arInterfaceInfo[i].iiFlags;\n+\n+      if (lFlags & IFF_LOOPBACK)\n+        strcpy (szName, \"lo\");\n+      else\n+        {\n+          strcpy (szName, \"eth\");\n+          wsprintf(szName+3, \"%d\", nCurETHInterface++);\n+        }\n+\n+      jstring if_name = JvNewStringLatin1 (szName);\n+      java::net::Inet4Address* address =\n         new java::net::Inet4Address (baddr, JvNewStringLatin1 (\"\"));\n-      ht->add (new NetworkInterface (if_name, address));\n-      if_record++;\n+      pjstrName[i] = if_name;\n+      ppAddress[i] = address;\n     }\n \n-#ifdef HAVE_INET6\n-      // FIXME: read /proc/net/if_inet6 (on Linux 2.4)\n-#endif\n-\n-  _Jv_Free (if_data.ifc_buf);\n+  ::closesocket (skt);\n   \n-  if (fd >= 0)\n-    _Jv_close (fd);\n+  return nNbInterfaces;\n+}\n+\n+/*\n+static int\n+iphlpapiGetRealNetworkInterfaces (jstring* pjstrName,\n+  java::net::InetAddress** ppAddress)\n+{\n+  return 0;\n+}\n+*/\n+\n+static PfnGetRealNetworkInterfaces\n+determineGetRealNetworkInterfacesFN ()\n+{\n+  /* FIXME: Try to dynamically load iphlpapi.dll and\n+     detect the presence of GetAdaptersInfo() using\n+     GetProcAddress(). If successful, return\n+     iphlpapiGetRealNetworkInterfaces; if not,\n+     return winsock2GetRealNetworkInterfaces */\n+  return &winsock2GetRealNetworkInterfaces;\n+}\n+\n+::java::util::Vector*\n+java::net::NetworkInterface::getRealNetworkInterfaces ()\n+{\n+  static PfnGetRealNetworkInterfaces pfn =\n+    determineGetRealNetworkInterfacesFN ();\n+    \n+  jstring arIFName[MAX_INTERFACES];\n+  InetAddress* arpInetAddress[MAX_INTERFACES];\n+  ::java::util::Vector* ht = new ::java::util::Vector ();\n   \n+  int nNbInterfaces = (*pfn) (arIFName, arpInetAddress);\n+  for (int i=0; i < nNbInterfaces; ++i) \n+    {\n+      ht->add (new java::net::NetworkInterface (arIFName[i],\n+        arpInetAddress[i]));\n+    }\n+    \n   return ht;\n-#endif /* WIN32 */\n }\n-\n-#endif // DISABLE_JAVA_NET //"}, {"sha": "53927deda3ba1ef5ec96e54380f0289b127ba8bd", "filename": "libjava/java/net/natPlainDatagramSocketImplWin32.cc", "status": "modified", "additions": 184, "deletions": 352, "changes": 536, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c14415811b48f1b486be91ea41661381f08a3fe/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImplWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c14415811b48f1b486be91ea41661381f08a3fe/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImplWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainDatagramSocketImplWin32.cc?ref=5c14415811b48f1b486be91ea41661381f08a3fe", "patch": "@@ -8,31 +8,13 @@ details.  */\n \n #include <config.h>\n #include <platform.h>\n-\n-#ifdef WIN32\n-\n-#include <errno.h>\n #include <string.h>\n \n-#else /* WIN32 */\n-\n-#ifdef HAVE_NETINET_IN_H\n-#include <netinet/in.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#include <arpa/inet.h>\n-#endif\n-#include <errno.h>\n-#include <string.h>\n-\n-#endif /* WIN32 */\n-\n #if HAVE_BSTRING_H\n-// Needed for bzero, implicitly used by FD_ZERO on IRIX 5.2 \n+// Needed for bzero, implicitly used by FD_ZERO on IRIX 5.2\n #include <bstring.h>\n #endif\n \n-#include <gcj/cni.h>\n #include <java/io/IOException.h>\n #include <java/io/InterruptedIOException.h>\n #include <java/net/BindException.h>\n@@ -42,116 +24,12 @@ details.  */\n #include <java/net/NetworkInterface.h>\n #include <java/net/DatagramPacket.h>\n #include <java/net/PortUnreachableException.h>\n+#include <java/net/SocketTimeoutException.h>\n #include <java/lang/InternalError.h>\n #include <java/lang/Object.h>\n #include <java/lang/Boolean.h>\n #include <java/lang/Integer.h>\n \n-#ifdef DISABLE_JAVA_NET\n-\n-void\n-java::net::PlainDatagramSocketImpl::create ()\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.create: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::bind (jint, java::net::InetAddress *)\n-{\n-  throw new BindException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.bind: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::connect (java::net::InetAddress *, jint)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.connect: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::disconnect ()\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.disconnect: unimplemented\"));\n-}\n-\n-jint\n-java::net::PlainDatagramSocketImpl::peek (java::net::InetAddress *)\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.peek: unimplemented\"));\n-}\n-\n-jint\n-java::net::PlainDatagramSocketImpl::peekData(java::net::DatagramPacket *)\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.peekData: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::close ()\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.close: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::send (java::net::DatagramPacket *)\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.send: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::receive (java::net::DatagramPacket *)\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.receive: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::setTimeToLive (jint)\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.setTimeToLive: unimplemented\"));\n-}\n-\n-jint\n-java::net::PlainDatagramSocketImpl::getTimeToLive ()\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.getTimeToLive: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::mcastGrp (java::net::InetAddress *,\n-                                              java::net::NetworkInterface *,\n-\t\t\t\t\t      jboolean)\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.mcastGrp: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainDatagramSocketImpl::setOption (jint, java::lang::Object *)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.setOption: unimplemented\"));\n-}\n-\n-java::lang::Object *\n-java::net::PlainDatagramSocketImpl::getOption (jint)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"DatagramSocketImpl.getOption: unimplemented\"));\n-}\n-\n-#else /* DISABLE_JAVA_NET */\n-\n-\n union SockAddr\n {\n   struct sockaddr_in address;\n@@ -178,31 +56,29 @@ union InAddr\n #endif\n };\n \n-\n // FIXME: routines here and/or in natPlainSocketImpl.cc could throw\n // NoRouteToHostException; also consider UnknownHostException, ConnectException.\n \n void\n java::net::PlainDatagramSocketImpl::create ()\n {\n-  int sock = _Jv_socket (AF_INET, SOCK_DGRAM, 0);\n+  SOCKET sock = ::socket (AF_INET, SOCK_DGRAM, 0);\n \n-  if (sock < 0)\n+  if (sock == INVALID_SOCKET)\n     {\n-      char* strerr = strerror (errno);\n-      throw new java::net::SocketException (JvNewStringUTF (strerr));\n+      _Jv_ThrowSocketException ();\n     }\n \n   _Jv_platform_close_on_exec (sock);\n \n   // We use fnum in place of fd here.  From leaving fd null we avoid\n   // the double close problem in FileDescriptor.finalize.\n-  fnum = sock;\n+  fnum = (int) sock;\n }\n \n void\n java::net::PlainDatagramSocketImpl::bind (jint lport,\n-\t\t\t\t\t  java::net::InetAddress *host)\n+            java::net::InetAddress *host)\n {\n   union SockAddr u;\n   struct sockaddr *ptr = (struct sockaddr *) &u.address;\n@@ -235,7 +111,7 @@ java::net::PlainDatagramSocketImpl::bind (jint lport,\n   else\n     throw new java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n \n-  if (_Jv_bind (fnum, ptr, len) == 0)\n+  if (::bind (fnum, ptr, len) == 0)\n     {\n       socklen_t addrlen = sizeof(u);\n \n@@ -248,30 +124,30 @@ java::net::PlainDatagramSocketImpl::bind (jint lport,\n \n       /* Allow broadcast by default. */\n       int broadcast = 1;\n-      if (::setsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &broadcast, \n+      if (::setsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &broadcast,\n                         sizeof (broadcast)) != 0)\n         goto error;\n \n       return;\n     }\n \n- error:\n-  char* strerr = strerror (errno);\n-  throw new java::net::BindException (JvNewStringUTF (strerr));\n+error:\n+  DWORD dwErrorCode = WSAGetLastError ();\n+  throw new java::net::BindException (_Jv_WinStrError (dwErrorCode));\n }\n \n void\n java::net::PlainDatagramSocketImpl::connect (java::net::InetAddress *, jint)\n-{ \n+{\n   throw new ::java::lang::InternalError (JvNewStringLatin1 (\n-\t    \"PlainDatagramSocketImpl::connect: not implemented yet\"));\n+      \"PlainDatagramSocketImpl::connect: not implemented yet\"));\n }\n \n void\n java::net::PlainDatagramSocketImpl::disconnect ()\n {\n   throw new ::java::lang::InternalError (JvNewStringLatin1 (\n-\t    \"PlainDatagramSocketImpl::disconnect: not implemented yet\"));\n+      \"PlainDatagramSocketImpl::disconnect: not implemented yet\"));\n }\n \n jint\n@@ -307,13 +183,14 @@ java::net::PlainDatagramSocketImpl::peek (java::net::InetAddress *i)\n \n   i->addr = raddr;\n   return rport;\n- error:\n-  char* strerr = strerror (errno);\n-\n-  if (errno == ECONNREFUSED)\n-    throw new PortUnreachableException (JvNewStringUTF (strerr));\n-\n-  throw new java::io::IOException (JvNewStringUTF (strerr));\n+error:\n+  DWORD dwErrorCode = WSAGetLastError ();\n+  if (dwErrorCode == WSAECONNRESET)\n+    throw new PortUnreachableException (_Jv_WinStrError (dwErrorCode));\n+\n+  _Jv_ThrowIOException ();\n+  return -1;\n+    // we should never get here\n }\n \n jint\n@@ -325,29 +202,18 @@ java::net::PlainDatagramSocketImpl::peekData(java::net::DatagramPacket *p)\n   jbyte *dbytes = elements (p->getData());\n   ssize_t retlen = 0;\n \n-// FIXME: implement timeout support for Win32\n-#ifndef WIN32\n-  // Do timeouts via select since SO_RCVTIMEO is not always available.\n-  if (timeout > 0 && fnum >= 0 && fnum < FD_SETSIZE)\n+  if (timeout > 0)\n     {\n-      fd_set rset;\n-      struct timeval tv;\n-      FD_ZERO(&rset);\n-      FD_SET(fnum, &rset);\n-      tv.tv_sec = timeout / 1000;\n-      tv.tv_usec = (timeout % 1000) * 1000;\n-      int retval;\n-      if ((retval = _Jv_select (fnum + 1, &rset, NULL, NULL, &tv)) < 0)\n+      int nRet= ::setsockopt(fnum, SOL_SOCKET, SO_RCVTIMEO,\n+        (char*)&timeout, sizeof(timeout));\n+      if (nRet != NO_ERROR)\n         goto error;\n-      else if (retval == 0)\n-        throw new java::io::InterruptedIOException ();\n     }\n-#endif /* WIN32 */\n \n   retlen =\n     ::recvfrom (fnum, (char *) dbytes, p->getLength(), MSG_PEEK, (sockaddr*) &u,\n       &addrlen);\n-  if (retlen < 0)\n+  if (retlen == SOCKET_ERROR)\n     goto error;\n   // FIXME: Deal with Multicast addressing and if the socket is connected.\n   jbyteArray raddr;\n@@ -374,13 +240,17 @@ java::net::PlainDatagramSocketImpl::peekData(java::net::DatagramPacket *p)\n   p->setLength ((jint) retlen);\n   return rport;\n \n- error:\n-  char* strerr = strerror (errno);\n-\n-  if (errno == ECONNREFUSED)\n-    throw new PortUnreachableException (JvNewStringUTF (strerr));\n+error:\n+  DWORD dwErrorCode = WSAGetLastError ();\n+  if (dwErrorCode == WSAECONNRESET)\n+    throw new PortUnreachableException (_Jv_WinStrError (dwErrorCode));\n+  else if (dwErrorCode == WSAETIMEDOUT)\n+    throw new java::net::SocketTimeoutException (_Jv_WinStrError (dwErrorCode));\n+  else\n+    _Jv_ThrowIOException ();\n \n-  throw new java::io::IOException (JvNewStringUTF (strerr));\n+  return -1;\n+    // we should never get here\n }\n \n // Close(shutdown) the socket.\n@@ -392,7 +262,7 @@ java::net::PlainDatagramSocketImpl::close ()\n \n   // The method isn't declared to throw anything, so we disregard\n   // the return value.\n-  _Jv_close (fnum);\n+  ::closesocket (fnum);\n   fnum = -1;\n   timeout = 0;\n }\n@@ -430,12 +300,11 @@ java::net::PlainDatagramSocketImpl::send (java::net::DatagramPacket *p)\n   if (::sendto (fnum, (char *) dbytes, p->getLength(), 0, ptr, len) >= 0)\n     return;\n \n-  char* strerr = strerror (errno);\n-\n-  if (errno == ECONNREFUSED)\n-    throw new PortUnreachableException (JvNewStringUTF (strerr));\n+  DWORD dwErrorCode = WSAGetLastError ();\n+  if (dwErrorCode == WSAECONNRESET)\n+    throw new PortUnreachableException (_Jv_WinStrError (dwErrorCode));\n \n-  throw new java::io::IOException (JvNewStringUTF (strerr));\n+  _Jv_ThrowIOException ();\n }\n \n void\n@@ -447,24 +316,16 @@ java::net::PlainDatagramSocketImpl::receive (java::net::DatagramPacket *p)\n   jbyte *dbytes = elements (p->getData());\n   ssize_t retlen = 0;\n \n-// FIXME: implement timeout support for Win32\n-#ifndef WIN32\n-  // Do timeouts via select since SO_RCVTIMEO is not always available.\n-  if (timeout > 0 && fnum >= 0 && fnum < FD_SETSIZE)\n+  if (timeout > 0)\n     {\n-      fd_set rset;\n-      struct timeval tv;\n-      FD_ZERO(&rset);\n-      FD_SET(fnum, &rset);\n-      tv.tv_sec = timeout / 1000;\n-      tv.tv_usec = (timeout % 1000) * 1000;\n-      int retval;\n-      if ((retval = _Jv_select (fnum + 1, &rset, NULL, NULL, &tv)) < 0)\n+      // This implementation doesn't allow specifying an infinite\n+      // timeout after specifying a finite one, but Sun's JDK 1.4.1\n+      // didn't seem to allow this either....\n+      int nRet= ::setsockopt(fnum, SOL_SOCKET, SO_RCVTIMEO,\n+        (char*)&timeout, sizeof(timeout));\n+      if (nRet != NO_ERROR)\n         goto error;\n-      else if (retval == 0)\n-        throw new java::io::InterruptedIOException ();\n     }\n-#endif /* WIN32 */\n \n   retlen =\n     ::recvfrom (fnum, (char *) dbytes, p->getLength(), 0, (sockaddr*) &u,\n@@ -497,12 +358,13 @@ java::net::PlainDatagramSocketImpl::receive (java::net::DatagramPacket *p)\n   return;\n \n  error:\n-  char* strerr = strerror (errno);\n-\n-  if (errno == ECONNREFUSED)\n-    throw new PortUnreachableException (JvNewStringUTF (strerr));\n-\n-  throw new java::io::IOException (JvNewStringUTF (strerr));\n+  DWORD dwErrorCode = WSAGetLastError();\n+  if (dwErrorCode == WSAECONNRESET)\n+    throw new PortUnreachableException (_Jv_WinStrError (dwErrorCode));\n+  else if (dwErrorCode == WSAETIMEDOUT)\n+    throw new java::net::SocketTimeoutException (_Jv_WinStrError (dwErrorCode));\n+  else\n+    throw new java::io::IOException (_Jv_WinStrError (dwErrorCode));\n }\n \n void\n@@ -515,8 +377,7 @@ java::net::PlainDatagramSocketImpl::setTimeToLive (jint ttl)\n   if (::setsockopt (fnum, IPPROTO_IP, IP_MULTICAST_TTL, &val, val_len) == 0)\n     return;\n \n-  char* strerr = strerror (errno);\n-  throw new java::io::IOException (JvNewStringUTF (strerr));\n+  _Jv_ThrowIOException ();\n }\n \n jint\n@@ -529,20 +390,19 @@ java::net::PlainDatagramSocketImpl::getTimeToLive ()\n   if (::getsockopt (fnum, IPPROTO_IP, IP_MULTICAST_TTL, &val, &val_len) == 0)\n     return ((int) val) & 0xFF;\n \n-  char* strerr = strerror (errno);\n-  throw new java::io::IOException (JvNewStringUTF (strerr));\n+  _Jv_ThrowIOException ();\n+\n+  return -1;\n+    // we should never get here\n }\n \n void\n java::net::PlainDatagramSocketImpl::mcastGrp (java::net::InetAddress *inetaddr,\n                                               java::net::NetworkInterface *,\n-\t\t\t\t\t      jboolean join)\n+                jboolean)\n {\n   // FIXME: implement use of NetworkInterface\n-\n-  union McastReq u;\n   jbyteArray haddress = inetaddr->addr;\n-  jbyte *bytes = elements (haddress);\n   int len = haddress->length;\n   int level, opname;\n   const char *ptr;\n@@ -556,7 +416,7 @@ java::net::PlainDatagramSocketImpl::mcastGrp (java::net::InetAddress *inetaddr,\n       memcpy (&u.mreq.imr_multiaddr, bytes, len);\n       // FIXME:  If a non-default interface is set, use it; see Stevens p. 501.\n       // Maybe not, see note in last paragraph at bottom of Stevens p. 497.\n-      u.mreq.imr_interface.s_addr = htonl (INADDR_ANY); \n+      u.mreq.imr_interface.s_addr = htonl (INADDR_ANY);\n       len = sizeof (struct ip_mreq);\n       ptr = (const char *) &u.mreq;\n     }\n@@ -589,13 +449,12 @@ java::net::PlainDatagramSocketImpl::mcastGrp (java::net::InetAddress *inetaddr,\n   if (::setsockopt (fnum, level, opname, ptr, len) == 0)\n     return;\n \n-  char* strerr = strerror (errno);\n-  throw new java::io::IOException (JvNewStringUTF (strerr));\n+  _Jv_ThrowIOException ();\n }\n \n void\n java::net::PlainDatagramSocketImpl::setOption (jint optID,\n-\t\t\t\t\t       java::lang::Object *value)\n+                 java::lang::Object *value)\n {\n   int val;\n   socklen_t val_len = sizeof (val);\n@@ -605,19 +464,19 @@ java::net::PlainDatagramSocketImpl::setOption (jint optID,\n \n   if (_Jv_IsInstanceOf (value, &java::lang::Boolean::class$))\n     {\n-      java::lang::Boolean *boolobj = \n+      java::lang::Boolean *boolobj =\n         static_cast<java::lang::Boolean *> (value);\n       val = boolobj->booleanValue() ? 1 : 0;\n     }\n   else if (_Jv_IsInstanceOf (value, &java::lang::Integer::class$))\n     {\n-      java::lang::Integer *intobj = \n-        static_cast<java::lang::Integer *> (value);          \n+      java::lang::Integer *intobj =\n+        static_cast<java::lang::Integer *> (value);\n       val = (int) intobj->intValue();\n     }\n   // Else assume value to be an InetAddress for use with IP_MULTICAST_IF.\n \n-  switch (optID) \n+  switch (optID)\n     {\n       case _Jv_TCP_NODELAY_ :\n         throw new java::net::SocketException (\n@@ -636,103 +495,92 @@ java::net::PlainDatagramSocketImpl::setOption (jint optID,\n         if (::setsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n                           val_len) != 0)\n           goto error;\n-\tbreak;\n-\t\n+  break;\n+\n       case _Jv_SO_OOBINLINE_ :\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"SO_OOBINLINE: not valid for UDP\"));\n         break;\n-\t\n+\n       case _Jv_SO_SNDBUF_ :\n       case _Jv_SO_RCVBUF_ :\n-#if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n         int opt;\n         optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n         if (::setsockopt (fnum, SOL_SOCKET, opt, (char *) &val, val_len) != 0)\n-\t  goto error;    \n-#else\n-        throw new java::lang::InternalError (\n-          JvNewStringUTF (\"SO_RCVBUF/SO_SNDBUF not supported\"));\n-#endif \n+    goto error;\n         return;\n       case _Jv_SO_REUSEADDR_ :\n-#if defined(SO_REUSEADDR)\n-\tif (::setsockopt (fnum, SOL_SOCKET, SO_REUSEADDR, (char *) &val,\n-\t    val_len) != 0)\n-\t  goto error;\n-#else\n-        throw new java::lang::InternalError (\n-          JvNewStringUTF (\"SO_REUSEADDR not supported\"));\n-#endif \n-\treturn;\n+  if (::setsockopt (fnum, SOL_SOCKET, SO_REUSEADDR, (char *) &val,\n+      val_len) != 0)\n+    goto error;\n+  return;\n       case _Jv_SO_BINDADDR_ :\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"SO_BINDADDR: read only option\"));\n         return;\n       case _Jv_IP_MULTICAST_IF_ :\n-\tunion InAddr u;\n+  union InAddr u;\n         jbyteArray haddress;\n-\tjbyte *bytes;\n-\tint len;\n-\tint level, opname;\n-\tconst char *ptr;\n-\n-\thaddress = ((java::net::InetAddress *) value)->addr;\n-\tbytes = elements (haddress);\n-\tlen = haddress->length;\n-\tif (len == 4)\n-\t  {\n-\t    level = IPPROTO_IP;\n-\t    opname = IP_MULTICAST_IF;\n-\t    memcpy (&u.addr, bytes, len);\n-\t    len = sizeof (struct in_addr);\n-\t    ptr = (const char *) &u.addr;\n-\t  }\n+  jbyte *bytes;\n+  int len;\n+  int level, opname;\n+  const char *ptr;\n+\n+  haddress = ((java::net::InetAddress *) value)->addr;\n+  bytes = elements (haddress);\n+  len = haddress->length;\n+  if (len == 4)\n+    {\n+      level = IPPROTO_IP;\n+      opname = IP_MULTICAST_IF;\n+      memcpy (&u.addr, bytes, len);\n+      len = sizeof (struct in_addr);\n+      ptr = (const char *) &u.addr;\n+    }\n // Tru64 UNIX V5.0 has struct sockaddr_in6, but no IPV6_MULTICAST_IF\n #if defined (HAVE_INET6) && defined (IPV6_MULTICAST_IF)\n-\telse if (len == 16)\n-\t  {\n-\t    level = IPPROTO_IPV6;\n-\t    opname = IPV6_MULTICAST_IF;\n-\t    memcpy (&u.addr6, bytes, len);\n-\t    len = sizeof (struct in6_addr);\n-\t    ptr = (const char *) &u.addr6;\n-\t  }\n+  else if (len == 16)\n+    {\n+      level = IPPROTO_IPV6;\n+      opname = IPV6_MULTICAST_IF;\n+      memcpy (&u.addr6, bytes, len);\n+      len = sizeof (struct in6_addr);\n+      ptr = (const char *) &u.addr6;\n+    }\n #endif\n-\telse\n-\t  throw\n-\t    new java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n+  else\n+    throw\n+      new java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n \n-\tif (::setsockopt (fnum, level, opname, ptr, len) != 0)\n-\t  goto error;\n+  if (::setsockopt (fnum, level, opname, ptr, len) != 0)\n+    goto error;\n         return;\n-\t\n+\n       case _Jv_IP_MULTICAST_IF2_ :\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"IP_MULTICAST_IF2: not yet implemented\"));\n         break;\n-\t\n+\n       case _Jv_IP_MULTICAST_LOOP_ :\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"IP_MULTICAST_LOOP: not yet implemented\"));\n         break;\n-\t\n+\n       case _Jv_IP_TOS_ :\n         if (::setsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n-\t   val_len) != 0)\n-\t  goto error;    \n-\treturn;\n-\t\n+     val_len) != 0)\n+    goto error;\n+  return;\n+\n       case _Jv_SO_TIMEOUT_ :\n-\ttimeout = val;\n+  timeout = val;\n         return;\n       default :\n-        errno = ENOPROTOOPT;\n+        WSASetLastError (WSAENOPROTOOPT);\n     }\n \n  error:\n-  char* strerr = strerror (errno);\n-  throw new java::net::SocketException (JvNewStringUTF (strerr));\n+  _Jv_ThrowSocketException ();\n }\n \n java::lang::Object *\n@@ -752,121 +600,105 @@ java::net::PlainDatagramSocketImpl::getOption (jint optID)\n       case _Jv_SO_LINGER_ :\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"SO_LINGER not valid for UDP\"));\n-        break;    \n+        break;\n       case _Jv_SO_KEEPALIVE_ :\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"SO_KEEPALIVE not valid for UDP\"));\n         break;\n-\t\n+\n       case _Jv_SO_BROADCAST_ :\n-\tif (::getsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n-\t    &val_len) != 0)\n-\t  goto error;\n-\treturn new java::lang::Boolean (val != 0);\n-\t\n+  if (::getsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n+      &val_len) != 0)\n+    goto error;\n+  return new java::lang::Boolean (val != 0);\n+\n       case _Jv_SO_OOBINLINE_ :\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"SO_OOBINLINE not valid for UDP\"));\n         break;\n-      \n+\n       case _Jv_SO_RCVBUF_ :\n       case _Jv_SO_SNDBUF_ :\n-#if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n         int opt;\n         optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n         if (::getsockopt (fnum, SOL_SOCKET, opt, (char *) &val, &val_len) != 0)\n-\t  goto error;    \n+    goto error;\n         else\n-\t  return new java::lang::Integer (val);\n-#else\n-        throw new java::lang::InternalError (\n-          JvNewStringUTF (\"SO_RCVBUF/SO_SNDBUF not supported\"));\n-#endif    \n-\tbreak;\n+    return new java::lang::Integer (val);\n+  break;\n       case _Jv_SO_BINDADDR_:\n-\t// cache the local address\n-\tif (localAddress == NULL)\n-\t  {\t\n-\t    jbyteArray laddr;\n-\t    if (::getsockname (fnum, (sockaddr*) &u, &addrlen) != 0)\n-\t      goto error;\n-\t    if (u.address.sin_family == AF_INET)\n-\t      {\n-\t\tladdr = JvNewByteArray (4);\n-\t\tmemcpy (elements (laddr), &u.address.sin_addr, 4);\n-\t      }\n+  // cache the local address\n+  if (localAddress == NULL)\n+    {\n+      jbyteArray laddr;\n+      if (::getsockname (fnum, (sockaddr*) &u, &addrlen) != 0)\n+        goto error;\n+      if (u.address.sin_family == AF_INET)\n+        {\n+    laddr = JvNewByteArray (4);\n+    memcpy (elements (laddr), &u.address.sin_addr, 4);\n+        }\n #ifdef HAVE_INET6\n             else if (u.address.sin_family == AF_INET6)\n-\t      {\n-\t\tladdr = JvNewByteArray (16);\n-\t\tmemcpy (elements (laddr), &u.address6.sin6_addr, 16);\n-\t      }\n+        {\n+    laddr = JvNewByteArray (16);\n+    memcpy (elements (laddr), &u.address6.sin6_addr, 16);\n+        }\n #endif\n-\t    else\n-\t      throw new java::net::SocketException (\n-\t\t\t      JvNewStringUTF (\"invalid family\"));\n-\t    localAddress = new java::net::InetAddress (laddr, NULL);\n-\t  }\n-\treturn localAddress;  \n-\tbreak;\n+      else\n+        throw new java::net::SocketException (\n+            JvNewStringUTF (\"invalid family\"));\n+      localAddress = new java::net::InetAddress (laddr, NULL);\n+    }\n+  return localAddress;\n+  break;\n       case _Jv_SO_REUSEADDR_ :\n-#if defined(SO_REUSEADDR)\n-\tif (::getsockopt (fnum, SOL_SOCKET, SO_REUSEADDR, (char *) &val,\n-\t    &val_len) != 0)\n-\t  goto error;\n-\treturn new java::lang::Boolean (val != 0);\n-#else\n-        throw new java::lang::InternalError (\n-          JvNewStringUTF (\"SO_REUSEADDR not supported\"));\n-#endif \n-\tbreak;\n+  if (::getsockopt (fnum, SOL_SOCKET, SO_REUSEADDR, (char *) &val,\n+      &val_len) != 0)\n+    goto error;\n+  return new java::lang::Boolean (val != 0);\n+  break;\n       case _Jv_IP_MULTICAST_IF_ :\n-#ifdef HAVE_INET_NTOA\n-\tstruct in_addr inaddr;\n-  \tsocklen_t inaddr_len;\n-\tchar *bytes;\n-\n-  \tinaddr_len = sizeof(inaddr);\n-\tif (::getsockopt (fnum, IPPROTO_IP, IP_MULTICAST_IF, (char *) &inaddr,\n-\t    &inaddr_len) != 0)\n-\t  goto error;\n-\n-\tbytes = inet_ntoa (inaddr);\n-\n-\treturn java::net::InetAddress::getByName (JvNewStringLatin1 (bytes));\n-#else\n-\tthrow new java::net::SocketException (\n-\t  JvNewStringUTF (\"IP_MULTICAST_IF: not available - no inet_ntoa()\"));\n-#endif\n-\tbreak;\n+  struct in_addr inaddr;\n+    socklen_t inaddr_len;\n+  char *bytes;\n+\n+    inaddr_len = sizeof(inaddr);\n+  if (::getsockopt (fnum, IPPROTO_IP, IP_MULTICAST_IF, (char *) &inaddr,\n+      &inaddr_len) != 0)\n+    goto error;\n+\n+  bytes = inet_ntoa (inaddr);\n+\n+  return java::net::InetAddress::getByName (JvNewStringLatin1 (bytes));\n+  break;\n       case _Jv_SO_TIMEOUT_ :\n-\treturn new java::lang::Integer (timeout);\n-\tbreak;\n-\t\n+  return new java::lang::Integer (timeout);\n+  break;\n+\n       case _Jv_IP_MULTICAST_IF2_ :\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"IP_MULTICAST_IF2: not yet implemented\"));\n         break;\n-\t\n+\n       case _Jv_IP_MULTICAST_LOOP_ :\n-\tif (::getsockopt (fnum, SOL_SOCKET, IP_MULTICAST_LOOP, (char *) &val,\n-\t    &val_len) != 0)\n-\t  goto error;\n-\treturn new java::lang::Boolean (val != 0);\n-\t\n+  if (::getsockopt (fnum, SOL_SOCKET, IP_MULTICAST_LOOP, (char *) &val,\n+      &val_len) != 0)\n+    goto error;\n+  return new java::lang::Boolean (val != 0);\n+\n       case _Jv_IP_TOS_ :\n         if (::getsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n            &val_len) != 0)\n           goto error;\n         return new java::lang::Integer (val);\n-\t\n+\n       default :\n-\terrno = ENOPROTOOPT;\n+        WSASetLastError (WSAENOPROTOOPT);\n     }\n \n- error:\n-  char* strerr = strerror (errno);\n-  throw new java::net::SocketException (JvNewStringUTF (strerr));\n+error:\n+  _Jv_ThrowSocketException ();\n+  return 0;\n+    // we should never get here\n }\n-\n-#endif /* DISABLE_JAVA_NET */"}, {"sha": "d43ad238b9fdba041ea2409517355c27661a762a", "filename": "libjava/java/net/natPlainSocketImplWin32.cc", "status": "modified", "additions": 236, "deletions": 471, "changes": 707, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c14415811b48f1b486be91ea41661381f08a3fe/libjava%2Fjava%2Fnet%2FnatPlainSocketImplWin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c14415811b48f1b486be91ea41661381f08a3fe/libjava%2Fjava%2Fnet%2FnatPlainSocketImplWin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FnatPlainSocketImplWin32.cc?ref=5c14415811b48f1b486be91ea41661381f08a3fe", "patch": "@@ -9,61 +9,10 @@ details.  */\n #include <config.h>\n #include <platform.h>\n \n-#ifndef DISABLE_JAVA_NET\n-\n-#ifdef WIN32\n-\n-#include <windows.h>\n-#include <winsock.h>\n-#include <errno.h>\n-#include <string.h>\n #undef STRICT\n #undef MAX_PRIORITY\n #undef MIN_PRIORITY\n-#undef FIONREAD\n-\n-// These functions make the Win32 socket API look more POSIXy\n-static inline int\n-write(int s, void *buf, int len)\n-{\n-  return send(s, (char*)buf, len, 0);\n-}\n-\n-static inline int\n-read(int s, void *buf, int len)\n-{\n-  return recv(s, (char*)buf, len, 0);\n-}\n-\n-// these errors cannot occur on Win32\n-#else /* WIN32 */\n-\n-#ifdef HAVE_SYS_IOCTL_H\n-#define BSD_COMP /* Get FIONREAD on Solaris2. */\n-#include <sys/ioctl.h>\n-#endif\n-\n-// Pick up FIONREAD on Solaris 2.5.\n-#ifdef HAVE_SYS_FILIO_H\n-#include <sys/filio.h>\n-#endif\n-\n-#include <netinet/in.h>\n-#include <netinet/tcp.h>\n-#include <errno.h>\n-#include <string.h>\n \n-#endif /* WIN32 */\n-#endif /* DISABLE_JAVA_NET */\n-\n-#if HAVE_BSTRING_H\n-// Needed for bzero, implicitly used by FD_ZERO on IRIX 5.2 \n-#include <bstring.h>\n-#endif\n-\n-\n-#include <gcj/cni.h>\n-#include <gcj/javaprims.h>\n #include <java/io/IOException.h>\n #include <java/io/InterruptedIOException.h>\n #include <java/net/BindException.h>\n@@ -83,122 +32,6 @@ read(int s, void *buf, int len)\n #include <java/lang/ArrayIndexOutOfBoundsException.h>\n #include <java/lang/IllegalArgumentException.h>\n \n-#ifdef DISABLE_JAVA_NET\n-\n-void\n-java::net::PlainSocketImpl::create (jboolean)\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"SocketImpl.create: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::bind (java::net::InetAddress *, jint)\n-{\n-  throw new BindException (\n-    JvNewStringLatin1 (\"SocketImpl.bind: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::connect (java::net::SocketAddress *, jint)\n-{\n-  throw new ConnectException (\n-    JvNewStringLatin1 (\"SocketImpl.connect: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::listen (jint)\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"SocketImpl.listen: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::accept (java::net::PlainSocketImpl *)\n-{\n-  throw new java::io::IOException (\n-    JvNewStringLatin1 (\"SocketImpl.accept: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::setOption (jint, java::lang::Object *)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.setOption: unimplemented\"));\n-}\n-\n-java::lang::Object *\n-java::net::PlainSocketImpl::getOption (jint)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.getOption: unimplemented\"));\n-}\n-\n-jint\n-java::net::PlainSocketImpl::read(void)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.read: unimplemented\"));\n-}\n-\n-jint\n-java::net::PlainSocketImpl::read(jbyteArray buffer, jint offset, jint count)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.read: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::write(jint b)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.write: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::write(jbyteArray b, jint offset, jint len)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.write: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::sendUrgentData(jint data)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.sendUrgentData: unimplemented\"));\n-}\n-\n-jint\n-java::net::PlainSocketImpl::available(void)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.available: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::close(void)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.close: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::shutdownInput (void)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.shutdownInput: unimplemented\"));\n-}\n-\n-void\n-java::net::PlainSocketImpl::shutdownOutput (void)\n-{\n-  throw new SocketException (\n-    JvNewStringLatin1 (\"SocketImpl.shutdownOutput: unimplemented\"));\n-}\n-\n-#else /* DISABLE_JAVA_NET */\n-\n union SockAddr\n {\n   struct sockaddr_in address;\n@@ -210,12 +43,11 @@ union SockAddr\n void\n java::net::PlainSocketImpl::create (jboolean stream)\n {\n-  int sock = _Jv_socket (AF_INET, stream ? SOCK_STREAM : SOCK_DGRAM, 0);\n+  int sock = ::socket (AF_INET, stream ? SOCK_STREAM : SOCK_DGRAM, 0);\n \n-  if (sock < 0)\n+  if (sock == int(INVALID_SOCKET))\n     {\n-      char* strerr = strerror (errno);\n-      throw new java::io::IOException (JvNewStringUTF (strerr));\n+      _Jv_ThrowIOException ();\n     }\n \n   _Jv_platform_close_on_exec (sock);\n@@ -261,25 +93,37 @@ java::net::PlainSocketImpl::bind (java::net::InetAddress *host, jint lport)\n \n   // Enable SO_REUSEADDR, so that servers can reuse ports left in TIME_WAIT.\n   ::setsockopt(fnum, SOL_SOCKET, SO_REUSEADDR, (char *) &i, sizeof(i));\n-  \n-  if (_Jv_bind (fnum, ptr, len) == 0)\n+\n+  if (::bind (fnum, ptr, len) != SOCKET_ERROR)\n     {\n       address = host;\n       socklen_t addrlen = sizeof(u);\n \n       if (lport != 0)\n         localport = lport;\n-      else if (::getsockname (fnum, (sockaddr*) &u, &addrlen) == 0)\n+      else if (::getsockname (fnum, (sockaddr*) &u, &addrlen) != SOCKET_ERROR)\n         localport = ntohs (u.address.sin_port);\n       else\n         goto error;\n \n       return;\n     }\n \n- error:\n-  char* strerr = strerror (errno);\n-  throw new java::net::BindException (JvNewStringUTF (strerr));\n+error:\n+  DWORD dwErrorCode = WSAGetLastError ();\n+  throw new java::net::BindException (_Jv_WinStrError (dwErrorCode));\n+}\n+\n+static void\n+throwConnectException (DWORD dwErrorCode)\n+{\n+  throw new java::net::ConnectException (_Jv_WinStrError (dwErrorCode));\n+}\n+\n+static void\n+throwConnectException ()\n+{\n+  throwConnectException (WSAGetLastError ());\n }\n \n void\n@@ -289,13 +133,14 @@ java::net::PlainSocketImpl::connect (java::net::SocketAddress *addr,\n   java::net::InetSocketAddress *tmp = (java::net::InetSocketAddress*) addr;\n   java::net::InetAddress *host = tmp->getAddress();\n   jint rport = tmp->getPort();\n-\t\n+\n   union SockAddr u;\n   socklen_t addrlen = sizeof(u);\n   jbyteArray haddress = host->addr;\n   jbyte *bytes = elements (haddress);\n   int len = haddress->length;\n   struct sockaddr *ptr = (struct sockaddr *) &u.address;\n+  \n   if (len == 4)\n     {\n       u.address.sin_family = AF_INET;\n@@ -315,35 +160,49 @@ java::net::PlainSocketImpl::connect (java::net::SocketAddress *addr,\n   else\n     throw new java::net::SocketException (JvNewStringUTF (\"invalid length\"));\n \n-// FIXME: implement timeout support for Win32\n-#ifndef WIN32\n   if (timeout > 0)\n     {\n-      int flags = ::fcntl (fnum, F_GETFL);\n-      ::fcntl (fnum, F_SETFL, flags | O_NONBLOCK);\n-      \n-      if ((_Jv_connect (fnum, ptr, len) != 0) && (errno != EINPROGRESS))\n-        goto error;\n+      // FIXME: we're creating a fresh WSAEVENT for each connect().\n+      WSAEventWrapper aWSAEventWrapper(fnum, FD_CONNECT);\n+      WSAEVENT hEvent = aWSAEventWrapper.getEventHandle ();\n \n-      fd_set rset;\n-      struct timeval tv;\n-      FD_ZERO(&rset);\n-      FD_SET(fnum, &rset);\n-      tv.tv_sec = timeout / 1000;\n-      tv.tv_usec = (timeout % 1000) * 1000;\n-      int retval;\n-      \n-      if ((retval = _Jv_select (fnum + 1, &rset, NULL, NULL, &tv)) < 0)\n-        goto error;\n-      else if (retval == 0)\n-        throw new java::net::SocketTimeoutException\n-          (JvNewStringUTF (\"Connect timed out\"));\n+      if (::connect (fnum, ptr, len) == SOCKET_ERROR)\n+      {\n+        if (WSAGetLastError () != WSAEWOULDBLOCK)\n+          throwConnectException ();\n+\n+        DWORD dwRet =\n+          WSAWaitForMultipleEvents (1, &hEvent, true, timeout, false);\n+            // use true, false instead of TRUE, FALSE because the\n+            // MS constants got undefined\n+\n+        if (dwRet == WSA_WAIT_FAILED)\n+          throwConnectException ();\n+        \n+        else if (dwRet == WSA_WAIT_TIMEOUT)\n+          throw new java::net::SocketTimeoutException\n+            (JvNewStringUTF (\"connect timed out\"));\n+            \n+        // If we get here, we still need to check whether the actual\n+        // connect() succeeded. Use any socket-specific error code\n+        // instead of the thread-based one.\n+        int nErrCode; int nErrLen=sizeof(nErrCode);\n+        if (::getsockopt(fnum, SOL_SOCKET, SO_ERROR, (char*) &nErrCode,\n+          &nErrLen) == SOCKET_ERROR)\n+          {\n+            throwConnectException ();\n+          }\n+        \n+        if (nErrCode != NO_ERROR)\n+          {\n+            throwConnectException (nErrCode);\n+          }\n+      }\n     }\n   else\n-#endif\n     {\n-      if (_Jv_connect (fnum, ptr, len) != 0)\n-        goto error;\n+      if (::connect (fnum, ptr, len) == SOCKET_ERROR)\n+        throwConnectException();\n     }\n \n   address = host;\n@@ -352,26 +211,19 @@ java::net::PlainSocketImpl::connect (java::net::SocketAddress *addr,\n   // A bind may not have been done on this socket; if so, set localport now.\n   if (localport == 0)\n     {\n-      if (::getsockname (fnum, (sockaddr*) &u, &addrlen) == 0)\n+      if (::getsockname (fnum, (sockaddr*) &u, &addrlen) != SOCKET_ERROR)\n         localport = ntohs (u.address.sin_port);\n       else\n-        goto error;\n+        throwConnectException();\n     }\n-\n-  return;  \n-\n- error:\n-  char* strerr = strerror (errno);\n-  throw new java::net::ConnectException (JvNewStringUTF (strerr));\n }\n \n void\n java::net::PlainSocketImpl::listen (jint backlog)\n {\n-  if (::listen (fnum, backlog) != 0)\n+  if (::listen (fnum, backlog) == SOCKET_ERROR)\n     {\n-      char* strerr = strerror (errno);\n-      throw new java::io::IOException (JvNewStringUTF (strerr));\n+      _Jv_ThrowIOException ();\n     }\n }\n \n@@ -380,31 +232,61 @@ java::net::PlainSocketImpl::accept (java::net::PlainSocketImpl *s)\n {\n   union SockAddr u;\n   socklen_t addrlen = sizeof(u);\n-  int new_socket = 0; \n+  int new_socket = 0;\n \n-// FIXME: implement timeout support for Win32\n-#ifndef WIN32\n-  // Do timeouts via select since SO_RCVTIMEO is not always available.\n-  if (timeout > 0 && fnum >= 0 && fnum < FD_SETSIZE)\n+  if (timeout > 0)\n     {\n-      fd_set rset;\n-      struct timeval tv;\n-      FD_ZERO(&rset);\n-      FD_SET(fnum, &rset);\n-      tv.tv_sec = timeout / 1000;\n-      tv.tv_usec = (timeout % 1000) * 1000;\n-      int retval;\n-      if ((retval = _Jv_select (fnum + 1, &rset, NULL, NULL, &tv)) < 0)\n-        goto error;\n-      else if (retval == 0)\n-        throw new java::io::InterruptedIOException (\n-\t                                  JvNewStringUTF(\"Accept timed out\"));\n-    }\n-#endif /* WIN32 */\n+      // FIXME: we're creating a fresh WSAEVENT for each accept().\n+      // One possible alternative would be that fnum really points\n+      // to an extended structure consisting of the SOCKET, its\n+      // associated WSAEVENT, etc.\n+      WSAEventWrapper aWSAEventWrapper(fnum, FD_ACCEPT);\n+      WSAEVENT hEvent = aWSAEventWrapper.getEventHandle ();\n+\n+      for (;;)\n+      {\n+        new_socket = ::accept (fnum, (sockaddr*) &u, &addrlen);\n+\n+        if (new_socket != int(INVALID_SOCKET))\n+        {\n+          // This new child socket is nonblocking because the parent\n+          // socket became nonblocking via the WSAEventSelect() call,\n+          // so we set its mode back to blocking.\n+          WSAEventSelect (new_socket, hEvent, 0);\n+            // undo the hEvent <-> FD_ACCEPT association inherited\n+            // inherited from our parent socket\n+\n+          unsigned long lSockOpt = 0L;\n+            // blocking mode\n+          if (ioctlsocket(new_socket, FIONBIO, &lSockOpt) == SOCKET_ERROR)\n+          {\n+            goto error;\n+          }\n+          break;\n+        }\n+        else if (WSAGetLastError () != WSAEWOULDBLOCK)\n+          {\n+            goto error;\n+          }\n \n-  new_socket = _Jv_accept (fnum, (sockaddr*) &u, &addrlen);\n+        DWORD dwRet =\n+          WSAWaitForMultipleEvents (1, &hEvent, true, timeout, false);\n+            // use true, false instead of TRUE, FALSE because the\n+            // MS constants got undefined\n+\n+        if (dwRet == WSA_WAIT_FAILED)\n+          goto error;\n+        else if (dwRet == WSA_WAIT_TIMEOUT)\n+          throw new java::net::SocketTimeoutException\n+            (JvNewStringUTF (\"accept timed out\"));\n+      }\n+    }\n+  else\n+    {\n+      new_socket = ::accept (fnum, (sockaddr*) &u, &addrlen);\n+    }\n \n-  if (new_socket < 0)\n+  if (new_socket == int(INVALID_SOCKET))\n     goto error;\n \n   _Jv_platform_close_on_exec (new_socket);\n@@ -435,8 +317,7 @@ java::net::PlainSocketImpl::accept (java::net::PlainSocketImpl *s)\n   return;\n \n  error:\n-  char* strerr = strerror (errno);\n-  throw new java::io::IOException (JvNewStringUTF (strerr));\n+  _Jv_ThrowIOException ();\n }\n \n // Close(shutdown) the socket.\n@@ -447,14 +328,16 @@ java::net::PlainSocketImpl::close()\n   JvSynchronize sync (this);\n \n   // should we use shutdown here? how would that effect so_linger?\n-  int res = _Jv_close (fnum);\n+  int res = ::closesocket (fnum);\n \n   if (res == -1)\n     {\n       // These three errors are not errors according to tests performed\n       // on the reference implementation.\n-      if (errno != ENOTCONN && errno != ECONNRESET && errno != EBADF)\n-        throw new java::io::IOException  (JvNewStringUTF (strerror (errno)));\n+      DWORD dwErr = WSAGetLastError();\n+      if (dwErr != WSAENOTCONN && dwErr != WSAECONNRESET\n+        && dwErr != WSAENOTSOCK)\n+        _Jv_ThrowIOException ();\n     }\n   // Safe place to reset the file pointer.\n   fnum = -1;\n@@ -470,20 +353,22 @@ java::net::PlainSocketImpl::write(jint b)\n \n   while (r != 1)\n     {\n-      r = _Jv_write (fnum, &d, 1);\n+      r = ::send (fnum, (char*) &d, 1, 0);\n       if (r == -1)\n         {\n+          DWORD dwErr = WSAGetLastError();\n           if (java::lang::Thread::interrupted())\n             {\n               java::io::InterruptedIOException *iioe\n-                = new java::io::InterruptedIOException \n-                (JvNewStringLatin1 (strerror (errno)));\n+                = new java::io::InterruptedIOException\n+                (_Jv_WinStrError (dwErr));\n               iioe->bytesTransferred = 0;\n               throw iioe;\n             }\n           // Some errors should not cause exceptions.\n-          if (errno != ENOTCONN && errno != ECONNRESET && errno != EBADF)\n-            throw new java::io::IOException (JvNewStringUTF (strerror (errno)));\n+          if (dwErr != WSAENOTCONN && dwErr != WSAECONNRESET\n+            && dwErr != WSAENOTSOCK)\n+            _Jv_ThrowIOException ();\n           break;\n         }\n     }\n@@ -500,24 +385,25 @@ java::net::PlainSocketImpl::write(jbyteArray b, jint offset, jint len)\n \n   jbyte *bytes = elements (b) + offset;\n   int written = 0;\n-\n   while (len > 0)\n     {\n-      int r = _Jv_write (fnum, bytes, len);\n+      int r = ::send (fnum, (char*) bytes, len, 0);\n \n       if (r == -1)\n         {\n+          DWORD dwErr = WSAGetLastError();\n           if (java::lang::Thread::interrupted())\n             {\n               java::io::InterruptedIOException *iioe\n                 = new java::io::InterruptedIOException\n-                (JvNewStringLatin1 (strerror (errno)));\n+                (_Jv_WinStrError (dwErr));\n               iioe->bytesTransferred = written;\n               throw iioe;\n             }\n           // Some errors should not cause exceptions.\n-          if (errno != ENOTCONN && errno != ECONNRESET && errno != EBADF)\n-            throw new java::io::IOException (JvNewStringUTF (strerror (errno)));\n+          if (dwErr != WSAENOTCONN && dwErr != WSAECONNRESET\n+            && dwErr != WSAENOTSOCK)\n+            _Jv_ThrowIOException ();\n           break;\n         }\n \n@@ -534,43 +420,37 @@ java::net::PlainSocketImpl::sendUrgentData (jint)\n     \"PlainSocketImpl: sending of urgent data not supported by this socket\"));\n }\n \n-// Read a single byte from the socket.\n-jint\n-java::net::PlainSocketImpl::read(void)\n+// read() helper\n+static jint\n+doRead(int fnum, void* buf, int count, int timeout)\n {\n-  jbyte b;\n-\n-// FIXME: implement timeout support for Win32\n-#ifndef WIN32\n-  // Do timeouts via select.\n-  if (timeout > 0 && fnum >= 0 && fnum < FD_SETSIZE)\n-    {\n-      // Create the file descriptor set.\n-      fd_set read_fds;\n-      FD_ZERO (&read_fds);\n-      FD_SET (fnum,&read_fds);\n-      // Create the timeout struct based on our internal timeout value.\n-      struct timeval timeout_value;\n-      timeout_value.tv_sec = timeout / 1000;\n-      timeout_value.tv_usec = (timeout % 1000) * 1000;\n-      // Select on the fds.\n-      int sel_retval =\n-        _Jv_select (fnum + 1, &read_fds, NULL, NULL, &timeout_value);\n-      // If select returns 0 we've waited without getting data...\n-      // that means we've timed out.\n-      if (sel_retval == 0)\n-        throw new java::io::InterruptedIOException\n-          (JvNewStringUTF (\"read timed out\") );\n-      // If select returns ok we know we either got signalled or read some data...\n-      // either way we need to try to read.\n-    }\n-#endif /* WIN32 */\n-\n-  int r = _Jv_read (fnum, &b, 1);\n+  int r = 0;\n+  DWORD dwErrorCode = 0;\n+    // we are forced to declare this here because\n+    // a call to Thread::interrupted() blanks out\n+    // WSAGetLastError().\n+\n+  // FIXME: we unconditionally set SO_RCVTIMEO here\n+  // because we can't detect whether someone has\n+  // gone from a non-zero to zero timeout. What we'd\n+  // really need is a member state variable in addition\n+  // to timeout\n+  int nRet= ::setsockopt(fnum, SOL_SOCKET, SO_RCVTIMEO,\n+    (char*)&timeout, sizeof(timeout));\n+  if (nRet != NO_ERROR)\n+  {\n+    dwErrorCode = WSAGetLastError ();\n+    goto error;\n+  }\n+  \n+  r = ::recv (fnum, (char*) buf, count, 0);\n \n   if (r == 0)\n     return -1;\n \n+  dwErrorCode = WSAGetLastError ();\n+    // save WSAGetLastError() before calling Thread.interrupted()\n+  \n   if (java::lang::Thread::interrupted())\n     {\n       java::io::InterruptedIOException *iioe =\n@@ -581,14 +461,28 @@ java::net::PlainSocketImpl::read(void)\n     }\n   else if (r == -1)\n     {\n+error:\n       // Some errors cause us to return end of stream...\n-      if (errno == ENOTCONN)\n+      if (dwErrorCode == WSAENOTCONN)\n         return -1;\n \n       // Other errors need to be signalled.\n-      throw new java::io::IOException (JvNewStringUTF (strerror (errno)));\n+      if (dwErrorCode == WSAETIMEDOUT)\n+        throw new java::net::SocketTimeoutException\n+          (JvNewStringUTF (\"read timed out\") );\n+      else\n+        _Jv_ThrowIOException (dwErrorCode);\n     }\n+    \n+   return r;\n+}\n \n+// Read a single byte from the socket.\n+jint\n+java::net::PlainSocketImpl::read(void)\n+{\n+  jbyte b;\n+  doRead(fnum, &b, 1, timeout);\n   return b & 0xFF;\n }\n \n@@ -606,120 +500,20 @@ java::net::PlainSocketImpl::read(jbyteArray buffer, jint offset, jint count)\n \n   jbyte *bytes = elements (buffer) + offset;\n \n-// FIXME: implement timeout support for Win32\n-#ifndef WIN32\n-  // Do timeouts via select.\n-  if (timeout > 0 && fnum >= 0 && fnum < FD_SETSIZE)\n-    {\n-      // Create the file descriptor set.\n-      fd_set read_fds;\n-      FD_ZERO (&read_fds);\n-      FD_SET (fnum, &read_fds);\n-      // Create the timeout struct based on our internal timeout value.\n-      struct timeval timeout_value;\n-      timeout_value.tv_sec = timeout / 1000;\n-      timeout_value.tv_usec =(timeout % 1000) * 1000;\n-      // Select on the fds.\n-      int sel_retval =\n-        _Jv_select (fnum + 1, &read_fds, NULL, NULL, &timeout_value);\n-      // We're only interested in the 0 return.\n-      // error returns still require us to try to read \n-      // the socket to see what happened.\n-      if (sel_retval == 0)\n-        {\n-          java::io::InterruptedIOException *iioe =\n-            new java::io::InterruptedIOException\n-            (JvNewStringUTF (\"read interrupted\"));\n-          iioe->bytesTransferred = 0;\n-          throw iioe;\n-        }\n-    }\n-#endif\n-\n   // Read the socket.\n-  int r = ::recv (fnum, (char *) bytes, count, 0);\n-\n-  if (r == 0)\n-    return -1;\n-\n-  if (java::lang::Thread::interrupted())\n-    {\n-      java::io::InterruptedIOException *iioe =\n-        new java::io::InterruptedIOException\n-        (JvNewStringUTF (\"read interrupted\"));\n-      iioe->bytesTransferred = r == -1 ? 0 : r;\n-      throw iioe;\n-    }\n-  else if (r == -1)\n-    {\n-      // Some errors cause us to return end of stream...\n-      if (errno == ENOTCONN)\n-        return -1;\n-\n-      // Other errors need to be signalled.\n-      throw new java::io::IOException (JvNewStringUTF (strerror (errno)));\n-    }\n-\n-  return r;\n+  return doRead(fnum, bytes, count, timeout);\n }\n \n // How many bytes are available?\n jint\n java::net::PlainSocketImpl::available(void)\n {\n-#if defined(FIONREAD) || defined(HAVE_SELECT)\n-  long num = 0;\n-  int r = 0;\n-  bool num_set = false;\n-\n-#if defined(FIONREAD)\n-  r = ::ioctl (fnum, FIONREAD, &num);\n-\n-  if (r == -1 && errno == ENOTTY)\n-    {\n-      // If the ioctl doesn't work, we don't care.\n-      r = 0;\n-      num = 0;\n-    }\n-  else\n-    num_set = true;\n-#elif defined(HAVE_SELECT)\n-  if (fnum < 0)\n-    {\n-      errno = EBADF;\n-      r = -1;\n-    }\n-#endif\n+  unsigned long num = 0;\n \n-  if (r == -1)\n-    {\n-    posix_error:\n-      throw new java::io::IOException(JvNewStringUTF(strerror(errno)));\n-    }\n-\n-  // If we didn't get anything we can use select.\n-\n-#if defined(HAVE_SELECT)\n-  if (! num_set)\n-    if (! num_set && fnum >= 0 && fnum < FD_SETSIZE)\n-      {\n-        fd_set rd;\n-        FD_ZERO (&rd);\n-        FD_SET (fnum, &rd);\n-        struct timeval tv;\n-        tv.tv_sec = 0;\n-        tv.tv_usec = 0;\n-        r = _Jv_select (fnum + 1, &rd, NULL, NULL, &tv);\n-        if(r == -1)\n-          goto posix_error;\n-        num = r == 0 ? 0 : 1;\n-      }\n-#endif /* HAVE_SELECT */\n+  if (::ioctlsocket (fnum, FIONREAD, &num) == SOCKET_ERROR)\n+    _Jv_ThrowIOException ();\n \n   return (jint) num;\n-#else\n-  throw new java::io::IOException (JvNewStringUTF (\"unimplemented\"));\n-#endif\n }\n \n void\n@@ -733,11 +527,11 @@ java::net::PlainSocketImpl::setOption (jint optID, java::lang::Object *value)\n \n   if (_Jv_IsInstanceOf (value, &java::lang::Boolean::class$))\n     {\n-      java::lang::Boolean *boolobj = \n+      java::lang::Boolean *boolobj =\n         static_cast<java::lang::Boolean *> (value);\n       if (boolobj->booleanValue())\n-        val = 1; \n-      else \n+        val = 1;\n+      else\n         {\n           if (optID == _Jv_SO_LINGER_)\n             val = -1;\n@@ -747,8 +541,8 @@ java::net::PlainSocketImpl::setOption (jint optID, java::lang::Object *value)\n     }\n   else if (_Jv_IsInstanceOf (value, &java::lang::Integer::class$))\n     {\n-      java::lang::Integer *intobj = \n-        static_cast<java::lang::Integer *> (value);          \n+      java::lang::Integer *intobj =\n+        static_cast<java::lang::Integer *> (value);\n       val = (int) intobj->intValue();\n     }\n   else\n@@ -757,62 +551,48 @@ java::net::PlainSocketImpl::setOption (jint optID, java::lang::Object *value)\n         JvNewStringLatin1 (\"`value' must be Boolean or Integer\"));\n     }\n \n-  switch (optID) \n+  switch (optID)\n     {\n       case _Jv_TCP_NODELAY_ :\n-#ifdef TCP_NODELAY\n         if (::setsockopt (fnum, IPPROTO_TCP, TCP_NODELAY, (char *) &val,\n-                          val_len) != 0)\n+                          val_len) == SOCKET_ERROR)\n           goto error;\n-#else\n-        throw new java::lang::InternalError\n-          (JvNewStringUTF (\"TCP_NODELAY not supported\"));\n-#endif /* TCP_NODELAY */\n         return;\n \n       case _Jv_SO_KEEPALIVE_ :\n         if (::setsockopt (fnum, SOL_SOCKET, SO_KEEPALIVE, (char *) &val,\n-                          val_len) != 0)\n+                          val_len) == SOCKET_ERROR)\n           goto error;\n         break;\n-      \n+\n       case _Jv_SO_BROADCAST_ :\n         throw new java::net::SocketException\n           (JvNewStringUTF (\"SO_BROADCAST not valid for TCP\"));\n         break;\n-\t\n+\n       case _Jv_SO_OOBINLINE_ :\n         if (::setsockopt (fnum, SOL_SOCKET, SO_OOBINLINE, (char *) &val,\n-                          val_len) != 0)\n+                          val_len) == SOCKET_ERROR)\n           goto error;\n         break;\n \n       case _Jv_SO_LINGER_ :\n-#ifdef SO_LINGER\n         struct linger l_val;\n         l_val.l_onoff = (val != -1);\n         l_val.l_linger = val;\n \n         if (::setsockopt (fnum, SOL_SOCKET, SO_LINGER, (char *) &l_val,\n-                          sizeof(l_val)) != 0)\n-          goto error;    \n-#else\n-        throw new java::lang::InternalError (\n-          JvNewStringUTF (\"SO_LINGER not supported\"));\n-#endif /* SO_LINGER */\n+                          sizeof(l_val)) == SOCKET_ERROR)\n+          goto error;\n         return;\n \n       case _Jv_SO_SNDBUF_ :\n       case _Jv_SO_RCVBUF_ :\n-#if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n         int opt;\n         optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n-        if (::setsockopt (fnum, SOL_SOCKET, opt, (char *) &val, val_len) != 0)\n-          goto error;    \n-#else\n-        throw new java::lang::InternalError (\n-          JvNewStringUTF (\"SO_RCVBUF/SO_SNDBUF not supported\"));\n-#endif \n+        if (::setsockopt (fnum, SOL_SOCKET, opt, (char *) &val,\n+                          val_len) == SOCKET_ERROR)\n+          goto error;\n         return;\n \n       case _Jv_SO_BINDADDR_ :\n@@ -824,23 +604,23 @@ java::net::PlainSocketImpl::setOption (jint optID, java::lang::Object *value)\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"IP_MULTICAST_IF: not valid for TCP\"));\n         return;\n-\t\n+\n       case _Jv_IP_MULTICAST_IF2_ :\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"IP_MULTICAST_IF2: not valid for TCP\"));\n         break;\n-\t\n+\n       case _Jv_IP_MULTICAST_LOOP_ :\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"IP_MULTICAST_LOOP: not valid for TCP\"));\n         break;\n-\t\n+\n       case _Jv_IP_TOS_ :\n         if (::setsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n-                          val_len) != 0)\n-          goto error;    \n+                          val_len) == SOCKET_ERROR)\n+          goto error;\n         break;\n-\t\n+\n       case _Jv_SO_REUSEADDR_ :\n         throw new java::net::SocketException (\n           JvNewStringUTF (\"SO_REUSEADDR: not valid for TCP\"));\n@@ -851,12 +631,11 @@ java::net::PlainSocketImpl::setOption (jint optID, java::lang::Object *value)\n         return;\n \n       default :\n-        errno = ENOPROTOOPT;\n+        WSASetLastError (WSAENOPROTOOPT);\n     }\n \n- error:\n-  char* strerr = strerror (errno);\n-  throw new java::net::SocketException (JvNewStringUTF (strerr));\n+error:\n+  _Jv_ThrowSocketException ();\n }\n \n java::lang::Object *\n@@ -871,75 +650,62 @@ java::net::PlainSocketImpl::getOption (jint optID)\n \n   switch (optID)\n     {\n-#ifdef TCP_NODELAY\n     case _Jv_TCP_NODELAY_ :\n       if (::getsockopt (fnum, IPPROTO_TCP, TCP_NODELAY, (char *) &val,\n-                        &val_len) != 0)\n+                        &val_len) == SOCKET_ERROR)\n         goto error;\n       else\n         return new java::lang::Boolean (val != 0);\n-#else\n-      throw new java::lang::InternalError\n-        (JvNewStringUTF (\"TCP_NODELAY not supported\"));\n-#endif       \n       break;\n-      \n+\n     case _Jv_SO_LINGER_ :\n-#ifdef SO_LINGER\n       if (::getsockopt (fnum, SOL_SOCKET, SO_LINGER, (char *) &l_val,\n-                        &l_val_len) != 0)\n-        goto error;    \n- \n+                        &l_val_len) == SOCKET_ERROR)\n+        goto error;\n+\n       if (l_val.l_onoff)\n         return new java::lang::Integer (l_val.l_linger);\n       else\n         return new java::lang::Boolean ((jboolean)false);\n-#else\n-      throw new java::lang::InternalError\n-        (JvNewStringUTF (\"SO_LINGER not supported\"));\n-#endif\n-      break;    \n+      break;\n \n     case _Jv_SO_KEEPALIVE_ :\n       if (::getsockopt (fnum, SOL_SOCKET, SO_KEEPALIVE, (char *) &val,\n-                        &val_len) != 0)\n+                        &val_len) == SOCKET_ERROR)\n         goto error;\n       else\n         return new java::lang::Boolean (val != 0);\n \n     case _Jv_SO_BROADCAST_ :\n       if (::getsockopt (fnum, SOL_SOCKET, SO_BROADCAST, (char *) &val,\n-                        &val_len) != 0)\n-        goto error;    \n+                        &val_len) == SOCKET_ERROR)\n+        goto error;\n       return new java::lang::Boolean ((jboolean)val);\n-\t\n+\n     case _Jv_SO_OOBINLINE_ :\n       if (::getsockopt (fnum, SOL_SOCKET, SO_OOBINLINE, (char *) &val,\n-                        &val_len) != 0)\n-        goto error;    \n+                        &val_len) == SOCKET_ERROR)\n+        goto error;\n       return new java::lang::Boolean ((jboolean)val);\n-\t\n+\n     case _Jv_SO_RCVBUF_ :\n     case _Jv_SO_SNDBUF_ :\n-#if defined(SO_SNDBUF) && defined(SO_RCVBUF)\n       int opt;\n       optID == _Jv_SO_SNDBUF_ ? opt = SO_SNDBUF : opt = SO_RCVBUF;\n-      if (::getsockopt (fnum, SOL_SOCKET, opt, (char *) &val, &val_len) != 0)\n-        goto error;    \n+      if (::getsockopt (fnum, SOL_SOCKET, opt, (char *) &val,\n+                        &val_len) == SOCKET_ERROR)\n+        goto error;\n       else\n         return new java::lang::Integer (val);\n-#else\n-      throw new java::lang::InternalError\n-        (JvNewStringUTF (\"SO_RCVBUF/SO_SNDBUF not supported\"));\n-#endif    \n       break;\n     case _Jv_SO_BINDADDR_:\n-      // cache the local address \n+      // cache the local address\n       if (localAddress == NULL)\n         {\n           jbyteArray laddr;\n \n-          if (::getsockname (fnum, (sockaddr*) &u, &addrlen) != 0)\n+          if (::getsockname (fnum, (sockaddr*) &u,\n+                             &addrlen) == SOCKET_ERROR)\n             goto error;\n \n           if (u.address.sin_family == AF_INET)\n@@ -966,24 +732,24 @@ java::net::PlainSocketImpl::getOption (jint optID)\n       throw new java::net::SocketException\n         (JvNewStringUTF (\"IP_MULTICAST_IF: not valid for TCP\"));\n       break;\n-\t\n+\n     case _Jv_IP_MULTICAST_IF2_ :\n       throw new java::net::SocketException\n         (JvNewStringUTF (\"IP_MULTICAST_IF2: not valid for TCP\"));\n       break;\n-\t\n+\n     case _Jv_IP_MULTICAST_LOOP_ :\n       throw new java::net::SocketException\n         (JvNewStringUTF (\"IP_MULTICAST_LOOP: not valid for TCP\"));\n       break;\n-\t\n+\n     case _Jv_IP_TOS_ :\n       if (::getsockopt (fnum, SOL_SOCKET, IP_TOS, (char *) &val,\n-                        &val_len) != 0)\n+                        &val_len) == SOCKET_ERROR)\n         goto error;\n       return new java::lang::Integer (val);\n       break;\n-\t\n+\n     case _Jv_SO_REUSEADDR_ :\n       throw new java::net::SocketException\n         (JvNewStringUTF (\"SO_REUSEADDR: not valid for TCP\"));\n@@ -994,26 +760,25 @@ java::net::PlainSocketImpl::getOption (jint optID)\n       break;\n \n     default :\n-      errno = ENOPROTOOPT;\n+      WSASetLastError (WSAENOPROTOOPT);\n     }\n \n- error:\n-  char* strerr = strerror (errno);\n-  throw new java::net::SocketException (JvNewStringUTF (strerr));\n+error:\n+  _Jv_ThrowSocketException ();\n+  return 0;\n+    // we should never get here\n }\n \n void\n java::net::PlainSocketImpl::shutdownInput (void)\n {\n   if (::shutdown (fnum, 0))\n-    throw new SocketException (JvNewStringUTF (strerror (errno)));\n+    _Jv_ThrowSocketException ();\n }\n \n void\n java::net::PlainSocketImpl::shutdownOutput (void)\n {\n   if (::shutdown (fnum, 1))\n-    throw new SocketException (JvNewStringUTF (strerror (errno)));\n+    _Jv_ThrowSocketException ();\n }\n-\n-#endif /* DISABLE_JAVA_NET */"}, {"sha": "abe768ae5bd25550b9944c2affe3a4c1a33bec13", "filename": "libjava/win32.cc", "status": "modified", "additions": 123, "deletions": 12, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c14415811b48f1b486be91ea41661381f08a3fe/libjava%2Fwin32.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c14415811b48f1b486be91ea41661381f08a3fe/libjava%2Fwin32.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fwin32.cc?ref=5c14415811b48f1b486be91ea41661381f08a3fe", "patch": "@@ -10,11 +10,13 @@ details.  */\n \n #include <config.h>\n #include <platform.h>\n-#include <jvm.h>\n #include <sys/timeb.h>\n #include <stdlib.h>\n \n #include <java/lang/ArithmeticException.h>\n+#include <java/lang/UnsupportedOperationException.h>\n+#include <java/io/IOException.h>\n+#include <java/net/SocketException.h>\n #include <java/util/Properties.h>\n \n static LONG CALLBACK\n@@ -37,6 +39,102 @@ const char *_Jv_ThisExecutable (void)\n   return exec_name;\n }\n \n+// Helper classes and methods implementation\n+  \n+// class WSAEventWrapper\n+WSAEventWrapper::WSAEventWrapper (int fd, DWORD dwSelFlags):\n+  m_hEvent(0),\n+  m_fd(fd),\n+  m_dwSelFlags(dwSelFlags)\n+{\n+  m_hEvent = WSACreateEvent ();\n+  if (dwSelFlags)\n+    WSAEventSelect(fd, m_hEvent, dwSelFlags);\n+}\n+\n+WSAEventWrapper::~WSAEventWrapper ()\n+{\n+  if (m_dwSelFlags)\n+  {\n+    WSAEventSelect(m_fd, m_hEvent, 0);\n+    if (m_dwSelFlags & (FD_ACCEPT | FD_CONNECT))\n+    {\n+      // Set the socket back to non-blocking mode.\n+      // Ignore any error since we're in a destructor.\n+      unsigned long lSockOpt = 0L;\n+        // blocking mode\n+      ::ioctlsocket (m_fd, FIONBIO, &lSockOpt);\n+    }\n+  }\n+  WSACloseEvent (m_hEvent);\n+}\n+\n+// Error string text.\n+jstring\n+_Jv_WinStrError (LPCTSTR lpszPrologue, int nErrorCode)\n+{\n+  LPTSTR lpMsgBuf = 0;\n+\n+  DWORD dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER |\n+    FORMAT_MESSAGE_FROM_SYSTEM |\n+    FORMAT_MESSAGE_IGNORE_INSERTS;\n+\n+  FormatMessage (dwFlags,\n+    NULL,\n+    (DWORD) nErrorCode,\n+    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n+    (LPTSTR) &lpMsgBuf,\n+    0,\n+    NULL);\n+\n+  jstring ret;\n+  if (lpszPrologue)\n+    {\n+      LPTSTR lpszTemp =\n+        (LPTSTR) _Jv_Malloc (strlen (lpszPrologue) +\n+          strlen (lpMsgBuf) + 3);\n+      strcpy (lpszTemp, lpszPrologue);\n+      strcat (lpszTemp, \": \");\n+      strcat (lpszTemp, lpMsgBuf);\n+      ret = JvNewStringLatin1 (lpszTemp);\n+    } \n+  else\n+    {\n+      ret = JvNewStringLatin1 (lpMsgBuf);\n+    }\n+\n+  LocalFree(lpMsgBuf);\n+  return ret;\n+}\n+\n+jstring\n+_Jv_WinStrError (int nErrorCode)\n+{\n+  return _Jv_WinStrError (0, nErrorCode);\n+}\n+\n+void _Jv_ThrowIOException (DWORD dwErrorCode)\n+{\n+  throw new java::io::IOException (_Jv_WinStrError (dwErrorCode));\n+}\n+\n+void _Jv_ThrowIOException()\n+{\n+  DWORD dwErrorCode = WSAGetLastError ();\n+  _Jv_ThrowIOException (dwErrorCode);\n+}\n+\n+void _Jv_ThrowSocketException (DWORD dwErrorCode)\n+{\n+  throw new java::net::SocketException (_Jv_WinStrError (dwErrorCode));\n+}\n+\n+void _Jv_ThrowSocketException()\n+{\n+  DWORD dwErrorCode = WSAGetLastError ();\n+  _Jv_ThrowSocketException (dwErrorCode);\n+}\n+\n // Platform-specific VM initialization.\n void\n _Jv_platform_initialize (void)\n@@ -45,11 +143,11 @@ _Jv_platform_initialize (void)\n   WSADATA data;\n   if (WSAStartup (MAKEWORD (1, 1), &data))\n     MessageBox (NULL, \"Error initialising winsock library.\", \"Error\",\n-\t\tMB_OK | MB_ICONEXCLAMATION);\n-  \n+    MB_OK | MB_ICONEXCLAMATION);\n+\n   // Install exception handler\n   SetUnhandledExceptionFilter (win32_exception_handler);\n-  \n+\n   // Initialize our executable name\n   GetModuleFileName(NULL, exec_name, sizeof(exec_name));\n }\n@@ -96,14 +194,14 @@ _Jv_platform_initProperties (java::util::Properties* newprops)\n   if (buffer != NULL)\n     {\n       if (GetCurrentDirectory (buflen, buffer))\n-\tSET (\"user.dir\", buffer);\n+  SET (\"user.dir\", buffer);\n \n       if (GetTempPath (buflen, buffer))\n-\tSET (\"java.io.tmpdir\", buffer);\n+  SET (\"java.io.tmpdir\", buffer);\n \n       _Jv_Free (buffer);\n     }\n-  \n+\n   // Use GetUserName to set 'user.name'.\n   buflen = 257;  // UNLEN + 1\n   buffer = (char *) _Jv_MallocUnchecked (buflen);\n@@ -114,8 +212,8 @@ _Jv_platform_initProperties (java::util::Properties* newprops)\n       _Jv_Free (buffer);\n     }\n \n-  // According to the api documentation for 'GetWindowsDirectory()', the \n-  // environmental variable HOMEPATH always specifies the user's home \n+  // According to the api documentation for 'GetWindowsDirectory()', the\n+  // environmental variable HOMEPATH always specifies the user's home\n   // directory or a default directory.  On the 3 windows machines I checked\n   // only 1 had it set.  If it's not set, JDK1.3.1 seems to set it to\n   // the windows directory, so we'll do the same.\n@@ -130,7 +228,7 @@ _Jv_platform_initProperties (java::util::Properties* newprops)\n           if (winHome != NULL)\n             {\n               if (GetWindowsDirectory (winHome, MAX_PATH))\n-\t\tSET (\"user.home\", winHome);\n+        SET (\"user.home\", winHome);\n               _Jv_Free (winHome);\n             }\n         }\n@@ -148,7 +246,7 @@ _Jv_platform_initProperties (java::util::Properties* newprops)\n       if (buffer != NULL)\n         {\n           sprintf (buffer, \"%d.%d\", (int) osvi.dwMajorVersion,\n-\t\t   (int) osvi.dwMinorVersion);\n+           (int) osvi.dwMinorVersion);\n           SET (\"os.version\", buffer);\n           _Jv_Free (buffer);\n         }\n@@ -163,7 +261,7 @@ _Jv_platform_initProperties (java::util::Properties* newprops)\n             else if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 90)\n               SET (\"os.name\", \"Windows Me\");\n             else\n-              SET (\"os.name\", \"Windows ??\"); \n+              SET (\"os.name\", \"Windows ??\");\n             break;\n \n           case VER_PLATFORM_WIN32_NT:\n@@ -231,3 +329,16 @@ backtrace (void **__array, int __size)\n   }\n   return i;\n }\n+\n+int\n+_Jv_select (int n, fd_set *readfds, fd_set  *writefds,\n+      fd_set *exceptfds, struct timeval *timeout)\n+{\n+  int r = ::select (n, readfds, writefds, exceptfds, timeout);\n+  if (r == SOCKET_ERROR)\n+    {\n+      DWORD dwErrorCode = WSAGetLastError ();\n+      throw new java::io::IOException (_Jv_WinStrError (dwErrorCode));\n+    }\n+  return r;      \n+}"}]}