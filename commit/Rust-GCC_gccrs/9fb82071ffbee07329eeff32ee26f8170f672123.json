{"sha": "9fb82071ffbee07329eeff32ee26f8170f672123", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZiODIwNzFmZmJlZTA3MzI5ZWVmZjMyZWUyNmY4MTcwZjY3MjEyMw==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@cygnus.com", "date": "1997-12-02T20:57:41Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1997-12-02T20:57:41Z"}, "message": "Better fix for loop unrolling problem.\n\n\t* unroll.c (find_splittable_givs):  Remove last change.  Handle givs\n\twith a dest_reg that was created by loop.\n\nFrom-SVN: r16893", "tree": {"sha": "1b388c79ef08b1f652b1c735f0f366692e6c9c2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b388c79ef08b1f652b1c735f0f366692e6c9c2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fb82071ffbee07329eeff32ee26f8170f672123", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb82071ffbee07329eeff32ee26f8170f672123", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fb82071ffbee07329eeff32ee26f8170f672123", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb82071ffbee07329eeff32ee26f8170f672123/comments", "author": null, "committer": null, "parents": [{"sha": "898f531b0bb06dfb175c959bd3d3e8aa8eb4f033", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/898f531b0bb06dfb175c959bd3d3e8aa8eb4f033", "html_url": "https://github.com/Rust-GCC/gccrs/commit/898f531b0bb06dfb175c959bd3d3e8aa8eb4f033"}], "stats": {"total": 29, "additions": 16, "deletions": 13}, "files": [{"sha": "aea5be07b1140082757c10086e8e63a2231a4385", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb82071ffbee07329eeff32ee26f8170f672123/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb82071ffbee07329eeff32ee26f8170f672123/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9fb82071ffbee07329eeff32ee26f8170f672123", "patch": "@@ -1,3 +1,8 @@\n+Tue Dec  2 12:54:33 1997  Jim Wilson  <wilson@cygnus.com>\n+\n+\t* unroll.c (find_splittable_givs):  Remove last change.  Handle givs\n+\twith a dest_reg that was created by loop.\n+\n Fri Nov 28 10:00:27 1997  Jeffrey A Law  (law@cygnus.com)\n \n \t* configure.in: Fix NCR entries."}, {"sha": "688ee648da4b7f0744c7f5de72b114fa65bfd776", "filename": "gcc/unroll.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb82071ffbee07329eeff32ee26f8170f672123/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb82071ffbee07329eeff32ee26f8170f672123/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=9fb82071ffbee07329eeff32ee26f8170f672123", "patch": "@@ -2668,12 +2668,6 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n     {\n       rtx giv_inc, value;\n \n-      \n-      /* If this is a new register, can't handle it since it does not have\n-\t an entry in reg_n_info.  */\n-      if (REGNO (v->dest_reg) >= max_reg_before_loop)\n-\tcontinue;\n-\n       /* Only split the giv if it has already been reduced, or if the loop is\n \t being completely unrolled.  */\n       if (unroll_type != UNROLL_COMPLETELY && v->ignore)\n@@ -2711,13 +2705,17 @@ find_splittable_givs (bl, unroll_type, loop_start, loop_end, increment,\n \t  && (loop_number_exit_count[uid_loop_num[INSN_UID (loop_start)]]\n \t      || unroll_type == UNROLL_NAIVE)\n \t  && v->giv_type != DEST_ADDR\n-\t  && ((REGNO_FIRST_UID (REGNO (v->dest_reg)) != INSN_UID (v->insn)\n-\t       /* Check for the case where the pseudo is set by a shift/add\n-\t\t  sequence, in which case the first insn setting the pseudo\n-\t\t  is the first insn of the shift/add sequence.  */\n-\t       && (! (tem = find_reg_note (v->insn, REG_RETVAL, NULL_RTX))\n-\t\t   || (REGNO_FIRST_UID (REGNO (v->dest_reg))\n-\t\t       != INSN_UID (XEXP (tem, 0)))))\n+\t  /* The next part is true if the pseudo is used outside the loop.\n+\t     We assume that this is true for any pseudo created after loop\n+\t     starts, because we don't have a reg_n_info entry for them.  */\n+\t  && (REGNO (v->dest_reg) >= max_reg_before_loop\n+\t      || (REGNO_FIRST_UID (REGNO (v->dest_reg)) != INSN_UID (v->insn)\n+\t\t  /* Check for the case where the pseudo is set by a shift/add\n+\t\t     sequence, in which case the first insn setting the pseudo\n+\t\t     is the first insn of the shift/add sequence.  */\n+\t\t  && (! (tem = find_reg_note (v->insn, REG_RETVAL, NULL_RTX))\n+\t\t      || (REGNO_FIRST_UID (REGNO (v->dest_reg))\n+\t\t\t  != INSN_UID (XEXP (tem, 0)))))\n \t      /* Line above always fails if INSN was moved by loop opt.  */\n \t      || (uid_luid[REGNO_LAST_UID (REGNO (v->dest_reg))]\n \t\t  >= INSN_LUID (loop_end)))"}]}