{"sha": "ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJiOWY4YjAzYjU1M2E3ODE4ODc5YmVjMWZmNTQyZTRlZGU0ZmQ0Mw==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2011-03-22T19:58:18Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2011-03-22T19:58:18Z"}, "message": "MAINTAINERS (crx port, [...]): Remove.\n\n\t* MAINTAINERS (crx port, m68hc11 port): Remove.  Move maintainers\n\tto Write After Approval.\n\t* config-ml.in: Don't handle arc-*-elf*.\n\t* configure.ac (arc-*-*, crx-*-*, i[[3456789]]86-*-pe,\n\tm68hc11-*-*|m6811-*-*|m68hc12-*-*|m6812-*-*, mcore-*-pe*): Don't\n\thandle GCC libraries.\n\t* configure: Regenerate.\n\ncontrib:\n\t* compare-all-tests (all_targets): Remove crx and m68hc11.\n\nfixincludes:\n\t* mkfixinc.sh: Don't handle i?86-moss-msdos* or i?86-*-pe.\n\ngcc:\n\t* config/alpha/gnu.h: Remove.\n\t* config/arc: Remove directory.\n\t* config/arm/netbsd.h: Remove.\n\t* config/arm/t-pe: Remove.\n\t* config/crx: Remove directory.\n\t* config/i386/netbsd.h: Remove.\n\t* config/m68hc11: Remove directory.\n\t* config/m68k/uclinux-oldabi.h: Remove.\n\t* config/mcore/mcore-pe.h: Remove.\n\t* config/mcore/t-mcore-pe: Remove.\n\t* config/netbsd-aout.h: Remove.\n\t* config/rs6000/gnu.h: Remove.\n\t* config/sh/sh-symbian.h: Remove.\n\t* config/sh/symbian-base.c: Remove.\n\t* config/sh/symbian-c.c: Remove.\n\t* config/sh/symbian-cxx.c: Remove.\n\t* config/sh/symbian-post.h: Remove.\n\t* config/sh/symbian-pre.h: Remove.\n\t* config/sh/t-symbian: Remove.\n\t* config/svr3.h: Remove.\n\t* config/vax/netbsd.h: Remove.\n\t* config.build: Don't handle i[34567]86-*-pe.\n\t* config.gcc: Remove handling of deprecations for most deprecated\n\ttargets.\n\t(m68k-*-uclinuxoldabi*): Add to second deprecated list.\n\t(alpha*-*-gnu*, arc-*-elf*, arm*-*-netbsd*, arm-*-pe*, crx-*-elf,\n\ti[34567]86-*-netbsd*, i[34567]86-*-pe, m68hc11-*-*|m6811-*-*,\n\tm68hc12-*-*|m6812-*-*, m68k-*-uclinuxoldabi*, mcore-*-pe*,\n\tpowerpc64-*-gnu*, powerpc-*-gnu-gnualtivec*, powerpc-*-gnu*,\n\tsh-*-symbianelf* | sh[12346l]*-*-symbianelf*, vax-*-netbsd*):\n\tRemove cases.\n\t* config.host: Don't handle i[34567]86-*-pe.\n\t* config/rs6000/linux64.h (LINK_OS_GNU_SPEC): Remove.\n\t(ASM_SPEC32): Don't handle -mcall-gnu.\n\t* config/rs6000/sysv4.h (SUBTARGET_OVERRIDE_OPTIONS): Don't handle\n\t-mcall-gnu.\n\t(ASM_SPEC, CC1_SPEC, LINK_START_SPEC, LINK_OS_SPEC, CPP_SPEC,\n\tSTARTFILE_SPEC, LIB_SPEC, ENDFILE_SPEC): Don't handle -mcall-gnu.\n\t(LIB_GNU_SPEC, STARTFILE_GNU_SPEC, ENDFILE_GNU_SPEC,\n\tLINK_START_GNU_SPEC, LINK_OS_GNU_SPEC, CPP_OS_GNU_SPEC): Remove.\n\t(SUBTARGET_EXTRA_SPECS): Remove *_gnu specs.\n\t* config/sh/sh-protos.h, config/sh/sh.c: Remove all code\n\tconditional on SYMBIAN.\n\t* configure.ac: Don't handle powerpc*-*-gnu*.\n\t* configure: Regenerate.\n\t* doc/extend.texi (interrupt attribute): Don't mention CRX.\n\t* doc/install-old.texi (m6811, m6812): Don't mention.\n\t* doc/install.texi (arc-*-elf*): Don't document multilib option.\n\t(arc-*-elf, CRX, m6811-elf, m6812-elf): Remove.\n\t(m68k-uclinuxoldabi): Don't mention.\n\t* doc/invoke.texi (ARC Options, CRX Options, M68hc1x Options):\n\tRemove.\n\t(-mcall-gnu): Remove.\n\t* doc/md.texi (CRX Architecture, Motorola 68HC11 & 68HC12\n\tfamilies): Remove constraint documentation.\n\ngcc/testsuite:\n\t* gcc.c-torture/execute/920501-8.x: Remove.\n\t* gcc.c-torture/execute/930513-1.x: Remove.\n\t* gcc.c-torture/execute/960312-1.x: Remove.\n\t* gcc.c-torture/compile/20000804-1.c,\n\tgcc.c-torture/compile/20001205-1.c,\n\tgcc.c-torture/compile/20001226-1.c,\n\tgcc.c-torture/compile/20010518-2.c,\n\tgcc.c-torture/compile/20020312-1.c,\n\tgcc.c-torture/compile/20020604-1.c,\n\tgcc.c-torture/compile/920501-12.c,\n\tgcc.c-torture/compile/920501-4.c,\n\tgcc.c-torture/compile/920520-1.c,\n\tgcc.c-torture/compile/980506-1.c,\n\tgcc.c-torture/execute/980709-1.x,\n\tgcc.c-torture/execute/990826-0.x: Don't XFAIL or use special\n\toptions for m68hc11.\n\t* gcc.dg/cpp/assert4.c: Don't handle ARC.\n\t* gcc.dg/sibcall-3.c, gcc.dg/sibcall-4.c: Don't XFAIL for arc or\n\tm68hc11.\n\nlibgcc:\n\t* config.host (alpha*-*-gnu*, arc-*-elf*, arm*-*-netbsd*,\n\tarm-*-pe*, crx-*-elf, i[34567]86-*-netbsd*, i[34567]86-*-pe,\n\tm68hc11-*-*|m6811-*-*, m68hc12-*-*|m6812-*-*, mcore-*-pe*,\n\tpowerpc64-*-gnu*, powerpc-*-gnu-gnualtivec*, powerpc-*-gnu*,\n\tsh-*-symbianelf* | sh[12346l]*-*-symbianelf*, vax-*-netbsd*):\n\tRemove cases.\n\nlibstdc++-v3:\n\t* configure.ac: Don't handle powerpc*-*-gnu*.\n\t* configure: Regenerate.\n\nFrom-SVN: r171302", "tree": {"sha": "7a705196fcad24a1f78dbe66d931764447a4198f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a705196fcad24a1f78dbe66d931764447a4198f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "999a7d80b587700fc74639d0da5849c4f2eb31db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/999a7d80b587700fc74639d0da5849c4f2eb31db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/999a7d80b587700fc74639d0da5849c4f2eb31db"}], "stats": {"total": 28103, "additions": 144, "deletions": 27959}, "files": [{"sha": "364465c3dca68ae367ad692faaec46d4015263b6", "filename": "ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,3 +1,13 @@\n+2011-03-22  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* MAINTAINERS (crx port, m68hc11 port): Remove.  Move maintainers\n+\tto Write After Approval.\n+\t* config-ml.in: Don't handle arc-*-elf*.\n+\t* configure.ac (arc-*-*, crx-*-*, i[[3456789]]86-*-pe,\n+\tm68hc11-*-*|m6811-*-*|m68hc12-*-*|m6812-*-*, mcore-*-pe*): Don't\n+\thandle GCC libraries.\n+\t* configure: Regenerate.\n+\n 2011-03-21  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR bootstrap/48120:"}, {"sha": "5d5a96aaf40bdc8d4d1d0e745ee847caae67f3af", "filename": "MAINTAINERS", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -51,7 +51,6 @@ avr port\t\tEric Weddington\t\teric.weddington@atmel.com\n bfin port\t\tBernd Schmidt\t\tbernds@codesourcery.com\n bfin port\t\tJie Zhang\t\tjie@codesourcery.com\n cris port\t\tHans-Peter Nilsson\thp@axis.com\n-crx port\t\tPompapathi V Gadad \tPompapathi.V.Gadad@nsc.com\n fr30 port\t\tNick Clifton\t\tnickc@redhat.com\n frv port\t\tNick Clifton\t\tnickc@redhat.com\n frv port\t\tAlexandre Oliva\t\taoliva@redhat.com\n@@ -68,7 +67,6 @@ iq2000 port\t\tNick Clifton\t\tnickc@redhat.com\n lm32 port\t\tSebastien Bourdeauducq\tsebastien@milkymist.org\n m32c port\t\tDJ Delorie\t\tdj@redhat.com\n m32r port\t\tNick Clifton\t\tnickc@redhat.com\n-m68hc11 port\t\tStephane Carrez\t\tstcarrez@nerim.fr\n m68k port (?)\t\tJeff Law\t\tlaw@redhat.com\n m68k port\t\tAndreas Schwab\t\tschwab@linux-m68k.org\n m68k-motorola-sysv port\tPhilippe De Muyter\tphdm@macqel.be\n@@ -326,6 +324,7 @@ Julian Brown\t\t\t\t\tjulian@codesourcery.com\n Christian Bruel\t\t\t\t\tchristian.bruel@st.com\n Kevin Buettner\t\t\t\t\tkevinb@redhat.com\n Andrew Cagney\t\t\t\t\tcagney@redhat.com\n+Stephane Carrez\t\t\t\t\tstcarrez@nerim.fr\n Chandra Chavva\t\t\t\t\tcchavva@redhat.com\n Fabien Ch\ufffdne\t\t\t\t\tfabien@gcc.gnu.org\n William Cohen\t\t\t\t\twcohen@redhat.com\n@@ -357,6 +356,7 @@ John Freeman\t\t\t\t\tjfreeman08@gmail.com\n Nathan Froyd\t\t\t\t\tfroydnj@codesourcery.com\n Chao-ying Fu\t\t\t\t\tfu@mips.com\n Gary Funck\t\t\t\t\tgary@intrepid.com\n+Pompapathi V Gadad \t\t\t\tPompapathi.V.Gadad@nsc.com\n Kaveh Ghazi\t\t\t\t\tghazi@gcc.gnu.org\n Matthew Gingell\t\t\t\t\tgingell@gnat.com\n Tristan Gingold\t\t\t\t\tgingold@adacore.com"}, {"sha": "11983461c28625b58678bbbc95cfaf41a67298d8", "filename": "config-ml.in", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/config-ml.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/config-ml.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config-ml.in?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -2,7 +2,7 @@\n # wanting multilib support.\n #\n # Copyright (C) 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-# 2005, 2006, 2007, 2008, 2010  Free Software Foundation, Inc.\n+# 2005, 2006, 2007, 2008, 2010, 2011  Free Software Foundation, Inc.\n #\n # This file is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -224,19 +224,6 @@ done\n # $host here, not $target.\n \n case \"${host}\" in\n-arc-*-elf*)\n-\tif [ x$enable_biendian != xyes ]\n-\tthen\n-\t  old_multidirs=${multidirs}\n-\t  multidirs=\"\"\n-\t  for x in ${old_multidirs}; do\n-\t    case \"${x}\" in\n-\t      *be*) : ;;\n-\t      *) multidirs=\"${multidirs} ${x}\" ;;\n-\t    esac\n-\t  done\n-\tfi\n-\t;;\n arm-*-*)\n \tif [ x\"$enable_fpu\" = xno ]\n \tthen"}, {"sha": "520471c3316d43e896075d766c08e0413f70be65", "filename": "configure", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -3224,7 +3224,7 @@ case \"${target}\" in\n     libgloss_dir=wince\n     ;;\n   arc-*-*)\n-    noconfigdirs=\"$noconfigdirs target-libgloss ${libgcj}\"\n+    noconfigdirs=\"$noconfigdirs target-libgloss\"\n     ;;\n   arm-semi-aof )\n     ;;\n@@ -3298,7 +3298,6 @@ case \"${target}\" in\n     libgloss_dir=cris\n     ;;\n   crx-*-*)\n-    noconfigdirs=\"$noconfigdirs target-libstdc++-v3 target-mudflap ${libgcj}\"\n     ;;\n   d10v-*-*)\n     noconfigdirs=\"$noconfigdirs target-libstdc++-v3 target-libgloss ${libgcj}\"\n@@ -3416,7 +3415,7 @@ case \"${target}\" in\n   i[3456789]86-*-uwin* | i[3456789]86-*-interix* )\n     ;;\n   i[3456789]86-*-pe)\n-    noconfigdirs=\"$noconfigdirs target-libstdc++-v3 target-libgloss ${libgcj}\"\n+    noconfigdirs=\"$noconfigdirs target-libgloss\"\n     ;;\n   i[3456789]86-*-sco3.2v5*)\n     # The linker does not yet know about weak symbols in COFF,\n@@ -3442,7 +3441,7 @@ case \"${target}\" in\n     noconfigdirs=\"$noconfigdirs ${libgcj}\"\n     ;;\n   m68hc11-*-*|m6811-*-*|m68hc12-*-*|m6812-*-*)\n-    noconfigdirs=\"$noconfigdirs target-libiberty target-libstdc++-v3 ${libgcj}\"\n+    noconfigdirs=\"$noconfigdirs target-libiberty\"\n     libgloss_dir=m68hc11\n     ;;\n   m68k-*-elf*)\n@@ -3455,9 +3454,6 @@ case \"${target}\" in\n     libgloss_dir=m68k\n     ;;\n   mcore-*-pe*)\n-  # The EPOC C++ environment does not support exceptions or rtti,\n-  # and so building libstdc++-v3 tends not to always work.\n-    noconfigdirs=\"$noconfigdirs target-libstdc++-v3\"\n     ;;\n   mmix-*-*)\n     noconfigdirs=\"$noconfigdirs target-libffi target-boehm-gc gdb libgloss\""}, {"sha": "977db12ccaa422c4d57b8bc64342ebcca0db0030", "filename": "configure.ac", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -670,7 +670,7 @@ case \"${target}\" in\n     libgloss_dir=wince\n     ;;\n   arc-*-*)\n-    noconfigdirs=\"$noconfigdirs target-libgloss ${libgcj}\"\n+    noconfigdirs=\"$noconfigdirs target-libgloss\"\n     ;;\n   arm-semi-aof )\n     ;;\n@@ -744,7 +744,6 @@ case \"${target}\" in\n     libgloss_dir=cris\n     ;;\n   crx-*-*)\n-    noconfigdirs=\"$noconfigdirs target-libstdc++-v3 target-mudflap ${libgcj}\"\n     ;;\n   d10v-*-*)\n     noconfigdirs=\"$noconfigdirs target-libstdc++-v3 target-libgloss ${libgcj}\"\n@@ -862,7 +861,7 @@ case \"${target}\" in\n   i[[3456789]]86-*-uwin* | i[[3456789]]86-*-interix* )\n     ;;\n   i[[3456789]]86-*-pe)\n-    noconfigdirs=\"$noconfigdirs target-libstdc++-v3 target-libgloss ${libgcj}\"\n+    noconfigdirs=\"$noconfigdirs target-libgloss\"\n     ;;\n   i[[3456789]]86-*-sco3.2v5*)\n     # The linker does not yet know about weak symbols in COFF,\n@@ -888,7 +887,7 @@ case \"${target}\" in\n     noconfigdirs=\"$noconfigdirs ${libgcj}\"\n     ;;\n   m68hc11-*-*|m6811-*-*|m68hc12-*-*|m6812-*-*)\n-    noconfigdirs=\"$noconfigdirs target-libiberty target-libstdc++-v3 ${libgcj}\"\n+    noconfigdirs=\"$noconfigdirs target-libiberty\"\n     libgloss_dir=m68hc11\n     ;;\n   m68k-*-elf*)\n@@ -901,9 +900,6 @@ case \"${target}\" in\n     libgloss_dir=m68k\n     ;;\n   mcore-*-pe*)\n-  # The EPOC C++ environment does not support exceptions or rtti,\n-  # and so building libstdc++-v3 tends not to always work.\n-    noconfigdirs=\"$noconfigdirs target-libstdc++-v3\"\n     ;;\n   mmix-*-*)\n     noconfigdirs=\"$noconfigdirs target-libffi target-boehm-gc gdb libgloss\""}, {"sha": "2ece1b7068974f7ed9aee94dc70a50bd46b75a4f", "filename": "contrib/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,3 +1,7 @@\n+2011-03-22  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* compare-all-tests (all_targets): Remove crx and m68hc11.\n+\n 2011-03-21  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR bootstrap/48135"}, {"sha": "cf3d88b34fc41de17604e1d8b64340d95891e716", "filename": "contrib/compare-all-tests", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/contrib%2Fcompare-all-tests", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/contrib%2Fcompare-all-tests", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fcompare-all-tests?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,7 +1,7 @@\n #! /bin/bash\n \n # Compare the assembly language output for all the gcc tests.\n-# Copyright (C) 2009 Free Software Foundation, Inc.\n+# Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n # Contributed by Paolo Bonzini.\n #\n # Invoke it as \"bash compare-all-tests target1 target2 ... targetN\".\n@@ -36,7 +36,7 @@ sh64_opts='-m5-32media -m5-32media-nofpu -m5-64media -m5-64media-nofpu -m5-compa\n sh_opts='-m3 -m3e -m4 -m4a -m4al -m4/-mieee -m1 -m1/-mno-cbranchdi -m2a -m2a/-mieee -m2e -m2e/-mieee'\n sparc_opts='-mcpu=v8/-m32 -mcpu=v9/-m32 -m64'\n \n-all_targets='alpha arm avr bfin cris crx fr30 frv h8300 ia64 iq2000 m32c m32r m68hc11 m68k mcore mips mmix mn10300 pa pdp11 picochip ppc score sh sh64 sparc spu v850 vax xstormy16 xtensa' # e500 \n+all_targets='alpha arm avr bfin cris fr30 frv h8300 ia64 iq2000 m32c m32r m68k mcore mips mmix mn10300 pa pdp11 picochip ppc score sh sh64 sparc spu v850 vax xstormy16 xtensa' # e500 \n \n test_one_file ()\n {"}, {"sha": "57ac148b338cbe1a4c9533e6b0ac1fe4c61ee714", "filename": "fixincludes/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/fixincludes%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/fixincludes%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2FChangeLog?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,3 +1,7 @@\n+2011-03-22  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* mkfixinc.sh: Don't handle i?86-moss-msdos* or i?86-*-pe.\n+\n 2010-11-20  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \tPR other/46202"}, {"sha": "bd8d37a321fef18bf0fd9dd6efe6b06f4ad57096", "filename": "fixincludes/mkfixinc.sh", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/fixincludes%2Fmkfixinc.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/fixincludes%2Fmkfixinc.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/fixincludes%2Fmkfixinc.sh?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -12,8 +12,6 @@ target=fixinc.sh\n # Check for special fix rules for particular targets\n case $machine in\n     alpha*-dec-*vms* | \\\n-    i?86-moss-msdos* | \\\n-    i?86-*-pe | \\\n     i?86-*-cygwin* | \\\n     i?86-*-mingw32* | \\\n     x86_64-*-mingw32* | \\"}, {"sha": "efe5aa10e4e76d85eae9cbbb51c9596490a62cf7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,3 +1,61 @@\n+2011-03-22  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* config/alpha/gnu.h: Remove.\n+\t* config/arc: Remove directory.\n+\t* config/arm/netbsd.h: Remove.\n+\t* config/arm/t-pe: Remove.\n+\t* config/crx: Remove directory.\n+\t* config/i386/netbsd.h: Remove.\n+\t* config/m68hc11: Remove directory.\n+\t* config/m68k/uclinux-oldabi.h: Remove.\n+\t* config/mcore/mcore-pe.h: Remove.\n+\t* config/mcore/t-mcore-pe: Remove.\n+\t* config/netbsd-aout.h: Remove.\n+\t* config/rs6000/gnu.h: Remove.\n+\t* config/sh/sh-symbian.h: Remove.\n+\t* config/sh/symbian-base.c: Remove.\n+\t* config/sh/symbian-c.c: Remove.\n+\t* config/sh/symbian-cxx.c: Remove.\n+\t* config/sh/symbian-post.h: Remove.\n+\t* config/sh/symbian-pre.h: Remove.\n+\t* config/sh/t-symbian: Remove.\n+\t* config/svr3.h: Remove.\n+\t* config/vax/netbsd.h: Remove.\n+\t* config.build: Don't handle i[34567]86-*-pe.\n+\t* config.gcc: Remove handling of deprecations for most deprecated\n+\ttargets.\n+\t(m68k-*-uclinuxoldabi*): Add to second deprecated list.\n+\t(alpha*-*-gnu*, arc-*-elf*, arm*-*-netbsd*, arm-*-pe*, crx-*-elf,\n+\ti[34567]86-*-netbsd*, i[34567]86-*-pe, m68hc11-*-*|m6811-*-*,\n+\tm68hc12-*-*|m6812-*-*, m68k-*-uclinuxoldabi*, mcore-*-pe*,\n+\tpowerpc64-*-gnu*, powerpc-*-gnu-gnualtivec*, powerpc-*-gnu*,\n+\tsh-*-symbianelf* | sh[12346l]*-*-symbianelf*, vax-*-netbsd*):\n+\tRemove cases.\n+\t* config.host: Don't handle i[34567]86-*-pe.\n+\t* config/rs6000/linux64.h (LINK_OS_GNU_SPEC): Remove.\n+\t(ASM_SPEC32): Don't handle -mcall-gnu.\n+\t* config/rs6000/sysv4.h (SUBTARGET_OVERRIDE_OPTIONS): Don't handle\n+\t-mcall-gnu.\n+\t(ASM_SPEC, CC1_SPEC, LINK_START_SPEC, LINK_OS_SPEC, CPP_SPEC,\n+\tSTARTFILE_SPEC, LIB_SPEC, ENDFILE_SPEC): Don't handle -mcall-gnu.\n+\t(LIB_GNU_SPEC, STARTFILE_GNU_SPEC, ENDFILE_GNU_SPEC,\n+\tLINK_START_GNU_SPEC, LINK_OS_GNU_SPEC, CPP_OS_GNU_SPEC): Remove.\n+\t(SUBTARGET_EXTRA_SPECS): Remove *_gnu specs.\n+\t* config/sh/sh-protos.h, config/sh/sh.c: Remove all code\n+\tconditional on SYMBIAN.\n+\t* configure.ac: Don't handle powerpc*-*-gnu*.\n+\t* configure: Regenerate.\n+\t* doc/extend.texi (interrupt attribute): Don't mention CRX.\n+\t* doc/install-old.texi (m6811, m6812): Don't mention.\n+\t* doc/install.texi (arc-*-elf*): Don't document multilib option.\n+\t(arc-*-elf, CRX, m6811-elf, m6812-elf): Remove.\n+\t(m68k-uclinuxoldabi): Don't mention.\n+\t* doc/invoke.texi (ARC Options, CRX Options, M68hc1x Options):\n+\tRemove.\n+\t(-mcall-gnu): Remove.\n+\t* doc/md.texi (CRX Architecture, Motorola 68HC11 & 68HC12\n+\tfamilies): Remove constraint documentation.\n+\n 2011-03-22  Marius Strobl  <marius@FreeBSD.org>\n \n \t* config/sparc/freebsd.h (CPP_CPU64_DEFAULT_SPEC): Replace with..."}, {"sha": "abb27d7f6c1199771b56d40edd67ad8d6cbea72d", "filename": "gcc/config.build", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fconfig.build", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fconfig.build", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.build?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,5 +1,6 @@\n # GCC build-specific configuration file.\n-# Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2007, 2008, 2009, 2010\n+# Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2007, 2008, 2009, 2010,\n+# 2011\n # Free Software Foundation, Inc.\n \n #This file is part of GCC.\n@@ -75,7 +76,7 @@ case $build in\n     # IBM 360/370/390 Architecture\n     build_xm_defines='FATAL_EXIT_CODE=12'\n     ;;\n-  i[34567]86-*-cygwin* | i[34567]86-*-pe )\n+  i[34567]86-*-cygwin* )\n     build_xm_file=i386/xm-cygwin.h\n     build_exeext=.exe\n     ;;"}, {"sha": "bec9279b3af383a50063d52f33687d9bc75fdab4", "filename": "gcc/config.gcc", "status": "modified", "additions": 3, "deletions": 130, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -226,32 +226,9 @@ md_file=\n \n # Obsolete configurations.\n case ${target} in\n-# Avoid cases below matching.\n-   alpha*-*-linux*\t\t\t\\\n- | arm*-wince-pe*\t\t\t\\\n- | arm*-*-netbsdelf*\t\t\t\\\n- | i[34567]86-*-netbsdelf*\t\t\\\n- | powerpc*-*-linux*\t\t\t\\\n- | vax-*-netbsdelf*) ;;\n-   arc-*\t\t\t\t\\\n- | alpha*-*-gnu*\t\t\t\\\n- | arm*-*-netbsd*\t\t\t\\\n- | arm-*-pe*\t\t\t\t\\\n- | crx-*\t\t\t\t\\\n- | i[34567]86-*-interix3*\t\t\\\n- | i[34567]86-*-netbsd*\t\t\t\\\n- | i[34567]86-*-pe\t\t\t\\\n- | m68hc11-*-*\t\t\t\t\\\n- | m6811-*-*\t\t\t\t\\\n- | m68hc12-*-*\t\t\t\t\\\n- | m6812-*-*\t\t\t\t\\\n- | m68k-*-uclinuxoldabi*\t\t\\\n- | mcore-*-pe*\t\t\t\t\\\n- | powerpc*-*-gnu*\t\t\t\\\n+   i[34567]86-*-interix3*\t\t\\\n  | score-*\t\t\t\t\\\n- | sh*-*-symbianelf*\t\t\t\\\n  | *-*-solaris2.8*\t\t\t\\\n- | vax-*-netbsd*\t\t\t\\\n  )\n     if test \"x$enable_obsolete\" != xyes; then\n       echo \"*** Configuration ${target} is obsolete.\" >&2\n@@ -268,6 +245,7 @@ esac\n case ${target} in\n    i[34567]86-go32-*\t\t\t\\\n  | i[34567]86-*-go32*\t\t\t\\\n+ | m68k-*-uclinuxoldabi*\t\t\\\n  | mips64orion*-*-rtems*\t\t\\\n  | pdp11-*-bsd\t\t\t\t\\\n  | sparc-hal-solaris2*\t\t\t\\\n@@ -720,12 +698,6 @@ alpha*-*-linux*)\n \ttarget_cpu_default=\"MASK_GAS\"\n \ttmake_file=\"${tmake_file} alpha/t-crtfm alpha/t-alpha alpha/t-ieee alpha/t-linux\"\n \t;;\n-alpha*-*-gnu*)\n-\ttm_file=\"$tm_file alpha/elf.h alpha/linux.h alpha/linux-elf.h gnu.h glibc-stdint.h alpha/gnu.h\"\n-\textra_options=\"${extra_options} alpha/elf.opt\"\n-\ttarget_cpu_default=\"MASK_GAS\"\n-\ttmake_file=\"${tmake_file} alpha/t-crtfm alpha/t-alpha alpha/t-ieee\"\n-\t;;\n alpha*-*-freebsd*)\n \ttm_file=\"${tm_file} ${fbsd_tm_file} alpha/elf.h alpha/freebsd.h\"\n \textra_options=\"${extra_options} alpha/elf.opt\"\n@@ -789,10 +761,6 @@ alpha*-dec-*vms*)\n \tinstall_headers_dir=install-headers-cp\n \textra_options=\"${extra_options} vms/vms.opt\"\n \t;;\n-arc-*-elf*)\n-\ttm_file=\"dbxelf.h elfos.h newlib-stdint.h ${tm_file}\"\n-\textra_parts=\"crtinit.o crtfini.o\"\n-\t;;\n arm-wrs-vxworks)\n \ttm_file=\"elfos.h arm/elf.h arm/aout.h ${tm_file} vx-common.h vxworks.h arm/vxworks.h\"\n \textra_options=\"${extra_options} arm/vxworks.opt\"\n@@ -807,13 +775,6 @@ arm*-*-netbsdelf*)\n \textra_options=\"${extra_options} netbsd.opt netbsd-elf.opt\"\n \ttmake_file=\"${tmake_file} arm/t-arm arm/t-netbsd\"\n \t;;\n-arm*-*-netbsd*)\n-\ttm_file=\"arm/aout.h arm/arm.h netbsd.h netbsd-aout.h arm/netbsd.h\"\n-\textra_options=\"${extra_options} netbsd.opt\"\n-\ttmake_file=\"t-netbsd arm/t-arm arm/t-netbsd\"\n-\textra_parts=\"\"\n-\tuse_collect2=yes\n-\t;;\n arm*-*-linux*)\t\t\t# ARM GNU/Linux with ELF\n \ttm_file=\"dbxelf.h elfos.h gnu-user.h linux.h linux-android.h glibc-stdint.h arm/elf.h arm/linux-gas.h arm/linux-elf.h\"\n \tcase $target in\n@@ -911,13 +872,6 @@ arm*-wince-pe*)\n \textra_options=\"${extra_options} arm/pe.opt\"\n \textra_objs=\"pe.o\"\n \t;;\n-arm-*-pe*)\n-\ttm_file=\"arm/semi.h arm/aout.h arm/arm.h arm/coff.h dbxcoff.h arm/pe.h newlib-stdint.h\"\n-\ttmake_file=\"arm/t-arm arm/t-pe\"\n-\tuse_gcc_stdint=wrap\n-\textra_options=\"${extra_options} arm/pe.opt\"\n-\textra_objs=\"pe.o\"\n-\t;;\n avr-*-rtems*)\n \ttm_file=\"avr/avr.h dbxelf.h avr/rtems.h rtems.h newlib-stdint.h\"\n \ttmake_file=\"avr/t-avr t-rtems avr/t-rtems\"\n@@ -985,11 +939,6 @@ crisv32-*-linux* | cris-*-linux*)\n \t\t;;\n \tesac\n \t;;\n-crx-*-elf)\n-\ttm_file=\"elfos.h newlib-stdint.h ${tm_file}\"\n-\textra_parts=\"crtbegin.o crtend.o\"\n-\tuse_collect2=no\n-\t;;\n fr30-*-elf)\n \ttm_file=\"dbxelf.h elfos.h newlib-stdint.h ${tm_file}\"\n \ttmake_file=fr30/t-fr30\n@@ -1222,13 +1171,6 @@ i[34567]86-*-netbsdelf*)\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h netbsd.h netbsd-elf.h i386/netbsd-elf.h\"\n \textra_options=\"${extra_options} netbsd.opt netbsd-elf.opt\"\n \t;;\n-i[34567]86-*-netbsd*)\n-\ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h netbsd.h netbsd-aout.h i386/netbsd.h\"\n-\textra_options=\"${extra_options} netbsd.opt\"\n-\ttmake_file=\"${tmake_file} t-netbsd\"\n-\textra_parts=\"\"\n-\tuse_collect2=yes\n-\t;;\n x86_64-*-netbsd*)\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h netbsd.h netbsd-elf.h i386/x86-64.h i386/netbsd64.h\"\n \textra_options=\"${extra_options} netbsd.opt netbsd-elf.opt\"\n@@ -1441,7 +1383,7 @@ i[4567]86-wrs-vxworks|i[4567]86-wrs-vxworksae)\n \t    ;;\n \tesac\n \t;;\n-i[34567]86-*-pe | i[34567]86-*-cygwin*)\n+i[34567]86-*-cygwin*)\n \ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/cygming.h i386/cygwin.h i386/cygwin-stdint.h\"\n \txm_file=i386/xm-cygwin.h\n \t# This has to match the logic for DWARF2_UNWIND_INFO in gcc/config/i386/cygming.h\n@@ -1686,24 +1628,6 @@ m32rle-*-linux*)\n \t\tthread_file='posix'\n \tfi\n \t;;\n-# m68hc11 and m68hc12 share the same machine description.\n-m68hc11-*-*|m6811-*-*)\n-\ttm_file=\"dbxelf.h elfos.h usegas.h newlib-stdint.h m68hc11/m68hc11.h\"\n-\ttm_p_file=\"m68hc11/m68hc11-protos.h\"\n-\tmd_file=\"m68hc11/m68hc11.md\"\n-\tout_file=\"m68hc11/m68hc11.c\"\n-\ttmake_file=\"m68hc11/t-m68hc11\"\n-\tuse_gcc_stdint=wrap\n-        ;;\n-m68hc12-*-*|m6812-*-*)\n-\ttm_file=\"m68hc11/m68hc12.h dbxelf.h elfos.h usegas.h newlib-stdint.h m68hc11/m68hc11.h\"\n-\ttm_p_file=\"m68hc11/m68hc11-protos.h\"\n-\tmd_file=\"m68hc11/m68hc11.md\"\n-\tout_file=\"m68hc11/m68hc11.c\"\n-\ttmake_file=\"m68hc11/t-m68hc11\"\n-\textra_options=\"${extra_options} m68hc11/m68hc11.opt\"\n-\tuse_gcc_stdint=wrap\n-        ;;\n m68k-*-elf* | fido-*-elf*)\n \tcase ${target} in\n \tfido-*-elf*)\n@@ -1754,15 +1678,6 @@ m68k*-*-openbsd*)\n \t# we need collect2 until our bug is fixed...\n \tuse_collect2=yes\n \t;;\n-m68k-*-uclinuxoldabi*)\t\t# Motorola m68k/ColdFire running uClinux\n-\t\t\t\t# with uClibc, using the original\n-\t\t\t\t# m68k-elf-based ABI\n-\tdefault_m68k_cpu=68020\n-\tdefault_cf_cpu=5206\n-\ttm_file=\"${tm_file} m68k/m68k-none.h m68k/m68kelf.h dbxelf.h elfos.h m68k/uclinux-oldabi.h glibc-stdint.h\"\n- \ttm_defines=\"${tm_defines} MOTOROLA=1\"\n-\ttmake_file=\"m68k/t-floatlib m68k/t-uclinux\"\n-\t;;\n m68k-*-uclinux*)\t\t# Motorola m68k/ColdFire running uClinux\n \t\t\t\t# with uClibc, using the new GNU/Linux-style\n \t\t\t\t# ABI.\n@@ -1802,12 +1717,6 @@ mcore-*-elf)\n \ttmake_file=mcore/t-mcore\n \tinhibit_libc=true\n \t;;\n-mcore-*-pe*)\n-\ttm_file=\"svr3.h dbxcoff.h newlib-stdint.h ${tm_file} mcore/mcore-pe.h\"\n-\ttmake_file=mcore/t-mcore-pe\n-\tinhibit_libc=true\n-\tuse_gcc_stdint=wrap\n-\t;;\n mep-*-*)\n \ttm_file=\"dbxelf.h elfos.h ${tm_file}\"\n \ttmake_file=mep/t-mep\n@@ -2171,27 +2080,6 @@ powerpc-*-linux* | powerpc64-*-linux*)\n \t\ttm_file=\"rs6000/secureplt.h ${tm_file}\"\n \tfi\n \t;;\n-powerpc64-*-gnu*)\n-\ttm_file=\"${tm_file} elfos.h freebsd-spec.h gnu.h rs6000/sysv4.h rs6000/default64.h rs6000/linux64.h rs6000/gnu.h glibc-stdint.h\"\n-\textra_options=\"${extra_options} rs6000/sysv4.opt rs6000/linux64.opt\"\n-\ttmake_file=\"t-slibgcc-elf-ver t-slibgcc-libgcc t-gnu\"\n-\t;;\n-powerpc-*-gnu-gnualtivec*)\n-\ttm_file=\"${cpu_type}/${cpu_type}.h elfos.h freebsd-spec.h gnu.h rs6000/sysv4.h rs6000/linux.h rs6000/linuxaltivec.h rs6000/gnu.h glibc-stdint.h\"\n-\textra_options=\"${extra_options} rs6000/sysv4.opt\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcos t-slibgcc-elf-ver t-slibgcc-libgcc t-gnu rs6000/t-ppccomm\"\n-\tif test x$enable_threads = xyes; then\n-\t\tthread_file='posix'\n-\tfi\n-\t;;\n-powerpc-*-gnu*)\n-\ttm_file=\"${cpu_type}/${cpu_type}.h elfos.h freebsd-spec.h gnu.h rs6000/sysv4.h rs6000/linux.h rs6000/gnu.h glibc-stdint.h\"\n-\ttmake_file=\"rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppcos t-slibgcc-elf-ver t-slibgcc-libgcc t-gnu rs6000/t-ppccomm\"\n-\textra_options=\"${extra_options} rs6000/sysv4.opt\"\n-\tif test x$enable_threads = xyes; then\n-\t\tthread_file='posix'\n-\tfi\n-\t;;\n powerpc-wrs-vxworks|powerpc-wrs-vxworksae)\n \ttm_file=\"${tm_file} elfos.h freebsd-spec.h rs6000/sysv4.h\"\n \ttmake_file=\"${tmake_file} rs6000/t-fprules rs6000/t-fprules-fpbit rs6000/t-ppccomm rs6000/t-vxworks\"\n@@ -2313,7 +2201,6 @@ score-*-elf)\n         extra_objs=\"score7.o\"\n         ;;\n sh-*-elf* | sh[12346l]*-*-elf* | \\\n-sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \\\n   sh-*-linux* | sh[2346lbe]*-*-linux* | \\\n   sh-*-netbsdelf* | shl*-*-netbsdelf* | sh5-*-netbsd* | sh5l*-*-netbsd* | \\\n    sh64-*-netbsd* | sh64l*-*-netbsd*)\n@@ -2390,13 +2277,6 @@ sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \\\n \t\tfi\n \t\textra_headers=\"shmedia.h ushmedia.h sshmedia.h\"\n \t\t;;\n-\t*-*-symbianelf*)\n-\t\ttmake_file=\"sh/t-symbian\"\n-\t\ttm_file=\"sh/symbian-pre.h sh/little.h ${tm_file} sh/symbian-post.h\"\n-\t\tc_target_objs=\"symbian-base.o symbian-c.o\"\n-\t\tcxx_target_objs=\"symbian-base.o symbian-cxx.o\"\n-\t\textra_parts=\"crt1.o crti.o crtn.o crtbegin.o crtend.o crtbeginS.o crtendS.o\"\n-\t\t;;\n \t*-*-elf*)\n \t\ttm_file=\"${tm_file} newlib-stdint.h\"\n \t\t;;\n@@ -2714,13 +2594,6 @@ vax-*-netbsdelf*)\n \ttm_file=\"${tm_file} elfos.h netbsd.h netbsd-elf.h vax/elf.h vax/netbsd-elf.h\"\n \textra_options=\"${extra_options} netbsd.opt netbsd-elf.opt vax/elf.opt\"\n \t;;\n-vax-*-netbsd*)\n-\ttm_file=\"${tm_file} netbsd.h netbsd-aout.h vax/netbsd.h\"\n-\textra_options=\"${extra_options} netbsd.opt\"\n-\ttmake_file=t-netbsd\n-\textra_parts=\"\"\n-\tuse_collect2=yes\n-\t;;\n vax-*-openbsd*)\n \ttm_file=\"vax/vax.h vax/openbsd1.h openbsd.h openbsd-stdint.h openbsd-pthread.h vax/openbsd.h\"\n \textra_options=\"${extra_options} openbsd.opt\""}, {"sha": "a2bde4434c59e110d77e5a810d060d1f0bcf5ae4", "filename": "gcc/config.host", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.host?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -211,7 +211,7 @@ case ${host} in\n         ;;\n     esac\n     ;;\n-  i[34567]86-*-pe | i[34567]86-*-cygwin*)\n+  i[34567]86-*-cygwin*)\n     host_xm_file=i386/xm-cygwin.h\n     out_host_hook_obj=host-cygwin.o\n     host_xmake_file=\"${host_xmake_file} i386/x-cygwin\""}, {"sha": "ca71980390615032db81c1861f441fdcf033152a", "filename": "gcc/config/alpha/gnu.h", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Falpha%2Fgnu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Falpha%2Fgnu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fgnu.h?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,49 +0,0 @@\n-/* Configuration for an Alpha running GNU with ELF as the target machine.\n-\n-Copyright (C) 2002, 2003, 2004, 2010 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#undef TARGET_VERSION\n-#define TARGET_VERSION fprintf (stderr, \" (Alpha GNU)\");\n-\n-#undef TARGET_OS_CPP_BUILTINS /* config.gcc includes alpha/linux.h.  */\n-#define TARGET_OS_CPP_BUILTINS()\t\t\\\n-    do {\t\t\t\t\t\\\n-\tLINUX_TARGET_OS_CPP_BUILTINS();\t\t\\\n-\tbuiltin_define (\"_LONGLONG\");\t\t\\\n-    } while (0)\n-\n-#undef ELF_DYNAMIC_LINKER\n-#define ELF_DYNAMIC_LINKER\t\"/lib/ld.so\"\n-\n-#undef\tSTARTFILE_SPEC\n-#define STARTFILE_SPEC \\\n-  \"%{!shared: \\\n-     %{!static: \\\n-       %{pg:gcrt1.o%s} %{!pg:%{p:gcrt1.o%s} %{!p:crt1.o%s}}} \\\n-     %{static:crt0.o%s}} \\\n-   crti.o%s \\\n-   %{!static:%{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}}\"\n-\n-/* FIXME: Is a Hurd-specific fallback mechanism necessary?  */\n-#undef MD_UNWIND_SUPPORT"}, {"sha": "c2d2ceaf82f5461a52ae5ff04a4475612ede2d75", "filename": "gcc/config/arc/arc-modes.def", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farc%2Farc-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farc%2Farc-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-modes.def?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,24 +0,0 @@\n-/* Definitions of target machine for GNU compiler, Argonaut ARC cpu.\n-   Copyright (C) 2002, 2007 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* Some insns set all condition code flags, some only set the ZNC flags, and\n-   some only set the ZN flags.  */\n-\n-CC_MODE (CCZNC);\n-CC_MODE (CCZN);"}, {"sha": "5550ebfbe2cdc5554c505d2bb7f868fd5a79015f", "filename": "gcc/config/arc/arc-protos.h", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farc%2Farc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farc%2Farc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc-protos.h?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,63 +0,0 @@\n-/* Definitions of target machine for GNU compiler, Argonaut ARC cpu.\n-   Copyright (C) 2000, 2004, 2007, 2010 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifdef RTX_CODE\n-extern enum machine_mode arc_select_cc_mode (enum rtx_code, rtx, rtx);\n-\n-/* Define the function that build the compare insn for scc and bcc.  */\n-extern struct rtx_def *gen_compare_reg (enum rtx_code, rtx, rtx);\n-#endif\n-\n-/* Declarations for various fns used in the .md file.  */\n-extern const char *output_shift (rtx *);\n-\n-extern int symbolic_operand (rtx, enum machine_mode);\n-extern int arc_double_limm_p (rtx);\n-extern int arc_eligible_for_epilogue_delay (rtx, int);\n-extern void arc_initialize_trampoline (rtx, rtx, rtx);\n-extern void arc_print_operand (FILE *, rtx, int);\n-extern void arc_print_operand_address (FILE *, rtx);\n-extern void arc_final_prescan_insn (rtx, rtx *, int);\n-extern int call_address_operand (rtx, enum machine_mode);\n-extern int call_operand (rtx, enum machine_mode);\n-extern int symbolic_memory_operand (rtx, enum machine_mode);\n-extern int short_immediate_operand (rtx, enum machine_mode);\n-extern int long_immediate_operand (rtx, enum machine_mode);\n-extern int long_immediate_loadstore_operand (rtx, enum machine_mode);\n-extern int move_src_operand (rtx, enum machine_mode);\n-extern int move_double_src_operand (rtx, enum machine_mode);\n-extern int move_dest_operand (rtx, enum machine_mode);\n-extern int load_update_operand (rtx, enum machine_mode);\n-extern int store_update_operand (rtx, enum machine_mode);\n-extern int nonvol_nonimm_operand (rtx, enum machine_mode);\n-extern int const_sint32_operand (rtx, enum machine_mode);\n-extern int const_uint32_operand (rtx, enum machine_mode);\n-extern int proper_comparison_operator (rtx, enum machine_mode);\n-extern int shift_operator (rtx, enum machine_mode);\n-\n-extern enum arc_function_type arc_compute_function_type (tree);\n-\n-\n-extern unsigned int arc_compute_frame_size (int);\n-extern void arc_save_restore (FILE *, const char *, unsigned int,\n-\t\t\t      unsigned int, const char *);\n-extern int arc_delay_slots_for_epilogue (void);\n-extern void arc_ccfsm_at_label (const char *, int);\n-extern int arc_ccfsm_branch_deleted_p (void);\n-extern void arc_ccfsm_record_branch_deleted (void);"}, {"sha": "fa92ccf7479b2a3e0979856d3bda6d271e2ebc8d", "filename": "gcc/config/arc/arc.c", "status": "removed", "additions": 0, "deletions": 2493, "changes": 2493, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,2493 +0,0 @@\n-/* Subroutines used for code generation on the Argonaut ARC cpu.\n-   Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003,\n-   2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* ??? This is an old port, and is undoubtedly suffering from bit rot.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"output.h\"\n-#include \"insn-attr.h\"\n-#include \"flags.h\"\n-#include \"function.h\"\n-#include \"expr.h\"\n-#include \"recog.h\"\n-#include \"diagnostic-core.h\"\n-#include \"df.h\"\n-#include \"tm_p.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-\n-/* Which cpu we're compiling for.  */\n-int arc_cpu_type;\n-\n-/* Name of mangle string to add to symbols to separate code compiled for each\n-   cpu (or NULL).  */\n-const char *arc_mangle_cpu;\n-\n-/* Name of text, data, and rodata sections used in varasm.c.  */\n-const char *arc_text_section;\n-const char *arc_data_section;\n-const char *arc_rodata_section;\n-\n-/* Array of valid operand punctuation characters.  */\n-char arc_punct_chars[256];\n-\n-/* Variables used by arc_final_prescan_insn to implement conditional\n-   execution.  */\n-static int arc_ccfsm_state;\n-static int arc_ccfsm_current_cc;\n-static rtx arc_ccfsm_target_insn;\n-static int arc_ccfsm_target_label;\n-\n-/* The maximum number of insns skipped which will be conditionalised if\n-   possible.  */\n-#define MAX_INSNS_SKIPPED 3\n-\n-/* A nop is needed between a 4 byte insn that sets the condition codes and\n-   a branch that uses them (the same isn't true for an 8 byte insn that sets\n-   the condition codes).  Set by arc_final_prescan_insn.  Used by\n-   arc_print_operand.  */\n-static int last_insn_set_cc_p;\n-static int current_insn_set_cc_p;\n-static bool arc_handle_option (size_t, const char *, int);\n-static void record_cc_ref (rtx);\n-static void arc_init_reg_tables (void);\n-static int get_arc_condition_code (rtx);\n-static tree arc_handle_interrupt_attribute (tree *, tree, tree, int, bool *);\n-static bool arc_assemble_integer (rtx, unsigned int, int);\n-static void arc_output_function_prologue (FILE *, HOST_WIDE_INT);\n-static void arc_output_function_epilogue (FILE *, HOST_WIDE_INT);\n-static void arc_file_start (void);\n-static void arc_internal_label (FILE *, const char *, unsigned long);\n-static void arc_va_start (tree, rtx);\n-static void arc_setup_incoming_varargs (CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t\t\ttree, int *, int);\n-static bool arc_rtx_costs (rtx, int, int, int *, bool);\n-static int arc_address_cost (rtx, bool);\n-static void arc_external_libcall (rtx);\n-static bool arc_return_in_memory (const_tree, const_tree);\n-static bool arc_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t\t   const_tree, bool);\n-static rtx arc_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t     const_tree, bool);\n-static void arc_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t\t      const_tree, bool);\n-static unsigned int arc_function_arg_boundary (enum machine_mode, const_tree);\n-static void arc_trampoline_init (rtx, tree, rtx);\n-static void arc_option_override (void);\n-static void arc_conditional_register_usage (void);\n-\n-\f\n-/* ARC specific attributs.  */\n-\n-static const struct attribute_spec arc_attribute_table[] =\n-{\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,\n-       affects_type_identity } */\n-  { \"interrupt\", 1, 1, true,  false, false, arc_handle_interrupt_attribute,\n-    false },\n-  { NULL,        0, 0, false, false, false, NULL, false }\n-};\n-\f\n-/* Initialize the GCC target structure.  */\n-#undef TARGET_ASM_ALIGNED_HI_OP\n-#define TARGET_ASM_ALIGNED_HI_OP \"\\t.hword\\t\"\n-#undef TARGET_ASM_ALIGNED_SI_OP\n-#define TARGET_ASM_ALIGNED_SI_OP \"\\t.word\\t\"\n-#undef TARGET_ASM_INTEGER\n-#define TARGET_ASM_INTEGER arc_assemble_integer\n-\n-#undef TARGET_ASM_FUNCTION_PROLOGUE\n-#define TARGET_ASM_FUNCTION_PROLOGUE arc_output_function_prologue\n-#undef TARGET_ASM_FUNCTION_EPILOGUE\n-#define TARGET_ASM_FUNCTION_EPILOGUE arc_output_function_epilogue\n-#undef TARGET_ASM_FILE_START\n-#define TARGET_ASM_FILE_START arc_file_start\n-#undef TARGET_ATTRIBUTE_TABLE\n-#define TARGET_ATTRIBUTE_TABLE arc_attribute_table\n-#undef TARGET_ASM_INTERNAL_LABEL\n-#define TARGET_ASM_INTERNAL_LABEL arc_internal_label\n-#undef TARGET_ASM_EXTERNAL_LIBCALL\n-#define TARGET_ASM_EXTERNAL_LIBCALL arc_external_libcall\n-\n-#undef TARGET_HANDLE_OPTION\n-#define TARGET_HANDLE_OPTION arc_handle_option\n-\n-#undef TARGET_OPTION_OVERRIDE\n-#define TARGET_OPTION_OVERRIDE arc_option_override\n-\n-#undef TARGET_RTX_COSTS\n-#define TARGET_RTX_COSTS arc_rtx_costs\n-#undef TARGET_ADDRESS_COST\n-#define TARGET_ADDRESS_COST arc_address_cost\n-\n-#undef TARGET_PROMOTE_FUNCTION_MODE\n-#define TARGET_PROMOTE_FUNCTION_MODE default_promote_function_mode_always_promote\n-#undef TARGET_PROMOTE_PROTOTYPES\n-#define TARGET_PROMOTE_PROTOTYPES hook_bool_const_tree_true\n-\n-#undef TARGET_RETURN_IN_MEMORY\n-#define TARGET_RETURN_IN_MEMORY arc_return_in_memory\n-#undef TARGET_PASS_BY_REFERENCE\n-#define TARGET_PASS_BY_REFERENCE arc_pass_by_reference\n-#undef TARGET_FUNCTION_ARG\n-#define TARGET_FUNCTION_ARG arc_function_arg\n-#undef TARGET_FUNCTION_ARG_ADVANCE\n-#define TARGET_FUNCTION_ARG_ADVANCE arc_function_arg_advance\n-#undef TARGET_FUNCTION_ARG_BOUNDARY\n-#define TARGET_FUNCTION_ARG_BOUNDARY arc_function_arg_boundary\n-#undef TARGET_CALLEE_COPIES\n-#define TARGET_CALLEE_COPIES hook_bool_CUMULATIVE_ARGS_mode_tree_bool_true\n-\n-#undef TARGET_SETUP_INCOMING_VARARGS\n-#define TARGET_SETUP_INCOMING_VARARGS arc_setup_incoming_varargs\n-\n-#undef TARGET_EXPAND_BUILTIN_VA_START\n-#define TARGET_EXPAND_BUILTIN_VA_START arc_va_start\n-\n-#undef TARGET_TRAMPOLINE_INIT\n-#define TARGET_TRAMPOLINE_INIT arc_trampoline_init\n-\n-#undef TARGET_CONDITIONAL_REGISTER_USAGE\n-#define TARGET_CONDITIONAL_REGISTER_USAGE arc_conditional_register_usage\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;\n-\f\n-/* Implement TARGET_HANDLE_OPTION.  */\n-\n-static bool\n-arc_handle_option (size_t code, const char *arg, int value ATTRIBUTE_UNUSED)\n-{\n-  switch (code)\n-    {\n-    case OPT_mcpu_:\n-      return strcmp (arg, \"base\") == 0 || ARC_EXTENSION_CPU (arg);\n-\n-    default:\n-      return true;\n-    }\n-}\n-\n-/* Implement TARGET_OPTION_OVERRIDE.\n-   These need to be done at start up.  It's convenient to do them here.  */\n-\n-static void\n-arc_option_override (void)\n-{\n-  char *tmp;\n-  \n-  /* Set the pseudo-ops for the various standard sections.  */\n-  arc_text_section = tmp = XNEWVEC (char, strlen (arc_text_string) + sizeof (ARC_SECTION_FORMAT) + 1);\n-  sprintf (tmp, ARC_SECTION_FORMAT, arc_text_string);\n-  arc_data_section = tmp = XNEWVEC (char, strlen (arc_data_string) + sizeof (ARC_SECTION_FORMAT) + 1);\n-  sprintf (tmp, ARC_SECTION_FORMAT, arc_data_string);\n-  arc_rodata_section = tmp = XNEWVEC (char, strlen (arc_rodata_string) + sizeof (ARC_SECTION_FORMAT) + 1);\n-  sprintf (tmp, ARC_SECTION_FORMAT, arc_rodata_string);\n-\n-  arc_init_reg_tables ();\n-\n-  /* Initialize array for PRINT_OPERAND_PUNCT_VALID_P.  */\n-  memset (arc_punct_chars, 0, sizeof (arc_punct_chars));\n-  arc_punct_chars['#'] = 1;\n-  arc_punct_chars['*'] = 1;\n-  arc_punct_chars['?'] = 1;\n-  arc_punct_chars['!'] = 1;\n-  arc_punct_chars['~'] = 1;\n-}\n-\f\n-/* The condition codes of the ARC, and the inverse function.  */\n-static const char *const arc_condition_codes[] =\n-{\n-  \"al\", 0, \"eq\", \"ne\", \"p\", \"n\", \"c\", \"nc\", \"v\", \"nv\",\n-  \"gt\", \"le\", \"ge\", \"lt\", \"hi\", \"ls\", \"pnz\", 0\n-};\n-\n-#define ARC_INVERSE_CONDITION_CODE(X)  ((X) ^ 1)\n-\n-/* Returns the index of the ARC condition code string in\n-   `arc_condition_codes'.  COMPARISON should be an rtx like\n-   `(eq (...) (...))'.  */\n-\n-static int\n-get_arc_condition_code (rtx comparison)\n-{\n-  switch (GET_CODE (comparison))\n-    {\n-    case EQ : return 2;\n-    case NE : return 3;\n-    case GT : return 10;\n-    case LE : return 11;\n-    case GE : return 12;\n-    case LT : return 13;\n-    case GTU : return 14;\n-    case LEU : return 15;\n-    case LTU : return 6;\n-    case GEU : return 7;\n-    default : gcc_unreachable ();\n-    }\n-  /*NOTREACHED*/\n-  return (42);\n-}\n-\n-/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n-   return the mode to be used for the comparison.  */\n-\n-enum machine_mode\n-arc_select_cc_mode (enum rtx_code op,\n-\t            rtx x ATTRIBUTE_UNUSED,\n-                    rtx y ATTRIBUTE_UNUSED)\n-{\n-  switch (op)\n-    {\n-    case EQ :\n-    case NE :\n-      return CCZNmode;\n-    default :\n-      switch (GET_CODE (x))\n-\t{\n-\tcase AND :\n-\tcase IOR :\n-\tcase XOR :\n-\tcase SIGN_EXTEND :\n-\tcase ZERO_EXTEND :\n-\t  return CCZNmode;\n-\tcase ASHIFT :\n-\tcase ASHIFTRT :\n-\tcase LSHIFTRT :\n-\t  return CCZNCmode;\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-  return CCmode;\n-}\n-\f\n-/* Vectors to keep interesting information about registers where it can easily\n-   be got.  We use to use the actual mode value as the bit number, but there\n-   is (or may be) more than 32 modes now.  Instead we use two tables: one\n-   indexed by hard register number, and one indexed by mode.  */\n-\n-/* The purpose of arc_mode_class is to shrink the range of modes so that\n-   they all fit (as bit numbers) in a 32-bit word (again).  Each real mode is\n-   mapped into one arc_mode_class mode.  */\n-\n-enum arc_mode_class {\n-  C_MODE,\n-  S_MODE, D_MODE, T_MODE, O_MODE,\n-  SF_MODE, DF_MODE, TF_MODE, OF_MODE\n-};\n-\n-/* Modes for condition codes.  */\n-#define C_MODES (1 << (int) C_MODE)\n-\n-/* Modes for single-word and smaller quantities.  */\n-#define S_MODES ((1 << (int) S_MODE) | (1 << (int) SF_MODE))\n-\n-/* Modes for double-word and smaller quantities.  */\n-#define D_MODES (S_MODES | (1 << (int) D_MODE) | (1 << DF_MODE))\n-\n-/* Modes for quad-word and smaller quantities.  */\n-#define T_MODES (D_MODES | (1 << (int) T_MODE) | (1 << (int) TF_MODE))\n-\n-/* Value is 1 if register/mode pair is acceptable on arc.  */\n-\n-const unsigned int arc_hard_regno_mode_ok[] = {\n-  T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES,\n-  T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES,\n-  T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, T_MODES, D_MODES,\n-  D_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES,\n-\n-  /* ??? Leave these as S_MODES for now.  */\n-  S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES,\n-  S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES,\n-  S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, S_MODES,\n-  S_MODES, S_MODES, S_MODES, S_MODES, S_MODES, C_MODES\n-};\n-\n-unsigned int arc_mode_class [NUM_MACHINE_MODES];\n-\n-enum reg_class arc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n-\n-static void\n-arc_init_reg_tables (void)\n-{\n-  int i;\n-\n-  for (i = 0; i < NUM_MACHINE_MODES; i++)\n-    {\n-      switch (GET_MODE_CLASS (i))\n-\t{\n-\tcase MODE_INT:\n-\tcase MODE_PARTIAL_INT:\n-\tcase MODE_COMPLEX_INT:\n-\t  if (GET_MODE_SIZE (i) <= 4)\n-\t    arc_mode_class[i] = 1 << (int) S_MODE;\n-\t  else if (GET_MODE_SIZE (i) == 8)\n-\t    arc_mode_class[i] = 1 << (int) D_MODE;\n-\t  else if (GET_MODE_SIZE (i) == 16)\n-\t    arc_mode_class[i] = 1 << (int) T_MODE;\n-\t  else if (GET_MODE_SIZE (i) == 32)\n-\t    arc_mode_class[i] = 1 << (int) O_MODE;\n-\t  else \n-\t    arc_mode_class[i] = 0;\n-\t  break;\n-\tcase MODE_FLOAT:\n-\tcase MODE_COMPLEX_FLOAT:\n-\t  if (GET_MODE_SIZE (i) <= 4)\n-\t    arc_mode_class[i] = 1 << (int) SF_MODE;\n-\t  else if (GET_MODE_SIZE (i) == 8)\n-\t    arc_mode_class[i] = 1 << (int) DF_MODE;\n-\t  else if (GET_MODE_SIZE (i) == 16)\n-\t    arc_mode_class[i] = 1 << (int) TF_MODE;\n-\t  else if (GET_MODE_SIZE (i) == 32)\n-\t    arc_mode_class[i] = 1 << (int) OF_MODE;\n-\t  else \n-\t    arc_mode_class[i] = 0;\n-\t  break;\n-\tcase MODE_CC:\n-\t  arc_mode_class[i] = 1 << (int) C_MODE;\n-\t  break;\n-\tdefault:\n-\t  arc_mode_class[i] = 0;\n-\t  break;\n-\t}\n-    }\n-\n-  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    {\n-      if (i < 60)\n-\tarc_regno_reg_class[i] = GENERAL_REGS;\n-      else if (i == 60)\n-\tarc_regno_reg_class[i] = LPCOUNT_REG;\n-      else if (i == 61)\n-\tarc_regno_reg_class[i] = NO_REGS /* CC_REG: must be NO_REGS */;\n-      else\n-\tarc_regno_reg_class[i] = NO_REGS;\n-    }\n-}\n-\f\n-/* ARC specific attribute support.\n-\n-   The ARC has these attributes:\n-   interrupt - for interrupt functions\n-*/\n-\n-/* Handle an \"interrupt\" attribute; arguments as in\n-   struct attribute_spec.handler.  */\n-static tree\n-arc_handle_interrupt_attribute (tree *node ATTRIBUTE_UNUSED,\n-                                tree name,\n-                                tree args,\n-                                int flags ATTRIBUTE_UNUSED,\n-                                bool *no_add_attrs)\n-{\n-  tree value = TREE_VALUE (args);\n-\n-  if (TREE_CODE (value) != STRING_CST)\n-    {\n-      warning (OPT_Wattributes,\n-\t       \"argument of %qE attribute is not a string constant\",\n-\t       name);\n-      *no_add_attrs = true;\n-    }\n-  else if (strcmp (TREE_STRING_POINTER (value), \"ilink1\")\n-\t   && strcmp (TREE_STRING_POINTER (value), \"ilink2\"))\n-    {\n-      warning (OPT_Wattributes,\n-\t       \"argument of %qE attribute is not \\\"ilink1\\\" or \\\"ilink2\\\"\",\n-\t       name);\n-      *no_add_attrs = true;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-\f\n-/* Acceptable arguments to the call insn.  */\n-\n-int\n-call_address_operand (rtx op, enum machine_mode mode)\n-{\n-  return (symbolic_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT && LEGITIMATE_CONSTANT_P (op))\n-\t  || (GET_CODE (op) == REG));\n-}\n-\n-int\n-call_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-  op = XEXP (op, 0);\n-  return call_address_operand (op, mode);\n-}\n-\n-/* Returns 1 if OP is a symbol reference.  */\n-\n-int\n-symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-    case CONST :\n-      return 1;\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* Return truth value of statement that OP is a symbolic memory\n-   operand of mode MODE.  */\n-\n-int\n-symbolic_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-  op = XEXP (op, 0);\n-  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == CONST\n-\t  || GET_CODE (op) == LABEL_REF);\n-}\n-\n-/* Return true if OP is a short immediate (shimm) value.  */\n-\n-int\n-short_immediate_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-  return SMALL_INT (INTVAL (op));\n-}\n-\n-/* Return true if OP will require a long immediate (limm) value.\n-   This is currently only used when calculating length attributes.  */\n-\n-int\n-long_immediate_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case SYMBOL_REF :\n-    case LABEL_REF :\n-    case CONST :\n-      return 1;\n-    case CONST_INT :\n-      return !SMALL_INT (INTVAL (op));\n-    case CONST_DOUBLE :\n-      /* These can happen because large unsigned 32-bit constants are\n-\t represented this way (the multiplication patterns can cause these\n-\t to be generated).  They also occur for SFmode values.  */\n-      return 1;\n-    default:\n-      break;\n-    }\n-  return 0;\n-}\n-\n-/* Return true if OP is a MEM that when used as a load or store address will\n-   require an 8 byte insn.\n-   Load and store instructions don't allow the same possibilities but they're\n-   similar enough that this one function will do.\n-   This is currently only used when calculating length attributes.  */\n-\n-int\n-long_immediate_loadstore_operand (rtx op,\n-                                  enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != MEM)\n-    return 0;\n-\n-  op = XEXP (op, 0);\n-  switch (GET_CODE (op))\n-    {\n-    case SYMBOL_REF :\n-    case LABEL_REF :\n-    case CONST :\n-      return 1;\n-    case CONST_INT :\n-      /* This must be handled as \"st c,[limm]\".  Ditto for load.\n-\t Technically, the assembler could translate some possibilities to\n-\t \"st c,[limm/2 + limm/2]\" if limm/2 will fit in a shimm, but we don't\n-\t assume that it does.  */\n-      return 1;\n-    case CONST_DOUBLE :\n-      /* These can happen because large unsigned 32-bit constants are\n-\t represented this way (the multiplication patterns can cause these\n-\t to be generated).  They also occur for SFmode values.  */\n-      return 1;\n-    case REG :\n-      return 0;\n-    case PLUS :\n-      if (GET_CODE (XEXP (op, 1)) == CONST_INT\n-\t  && !SMALL_INT (INTVAL (XEXP (op, 1))))\n-\treturn 1;\n-      return 0;\n-    default:\n-      break;\n-    }\n-  return 0;\n-}\n-\n-/* Return true if OP is an acceptable argument for a single word\n-   move source.  */\n-\n-int\n-move_src_operand (rtx op, enum machine_mode mode)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case SYMBOL_REF :\n-    case LABEL_REF :\n-    case CONST :\n-      return 1;\n-    case CONST_INT :\n-      return (LARGE_INT (INTVAL (op)));\n-    case CONST_DOUBLE :\n-      /* We can handle DImode integer constants in SImode if the value\n-\t (signed or unsigned) will fit in 32 bits.  This is needed because\n-\t large unsigned 32-bit constants are represented as CONST_DOUBLEs.  */\n-      if (mode == SImode)\n-\treturn arc_double_limm_p (op);\n-      /* We can handle 32-bit floating point constants.  */\n-      if (mode == SFmode)\n-\treturn GET_MODE (op) == SFmode;\n-      return 0;\n-    case REG :\n-      return register_operand (op, mode);\n-    case SUBREG :\n-      /* (subreg (mem ...) ...) can occur here if the inner part was once a\n-\t pseudo-reg and is now a stack slot.  */\n-      if (GET_CODE (SUBREG_REG (op)) == MEM)\n-\treturn address_operand (XEXP (SUBREG_REG (op), 0), mode);\n-      else\n-\treturn register_operand (op, mode);\n-    case MEM :\n-      return address_operand (XEXP (op, 0), mode);\n-    default :\n-      return 0;\n-    }\n-}\n-\n-/* Return true if OP is an acceptable argument for a double word\n-   move source.  */\n-\n-int\n-move_double_src_operand (rtx op, enum machine_mode mode)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case REG :\n-      return register_operand (op, mode);\n-    case SUBREG :\n-      /* (subreg (mem ...) ...) can occur here if the inner part was once a\n-\t pseudo-reg and is now a stack slot.  */\n-      if (GET_CODE (SUBREG_REG (op)) == MEM)\n-\treturn move_double_src_operand (SUBREG_REG (op), mode);\n-      else\n-\treturn register_operand (op, mode);\n-    case MEM :\n-      /* Disallow auto inc/dec for now.  */\n-      if (GET_CODE (XEXP (op, 0)) == PRE_DEC\n-\t  || GET_CODE (XEXP (op, 0)) == PRE_INC)\n-\treturn 0;\n-      return address_operand (XEXP (op, 0), mode);\n-    case CONST_INT :\n-    case CONST_DOUBLE :\n-      return 1;\n-    default :\n-      return 0;\n-    }\n-}\n-\n-/* Return true if OP is an acceptable argument for a move destination.  */\n-\n-int\n-move_dest_operand (rtx op, enum machine_mode mode)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case REG :\n-      return register_operand (op, mode);\n-    case SUBREG :\n-      /* (subreg (mem ...) ...) can occur here if the inner part was once a\n-\t pseudo-reg and is now a stack slot.  */\n-      if (GET_CODE (SUBREG_REG (op)) == MEM)\n-\treturn address_operand (XEXP (SUBREG_REG (op), 0), mode);\n-      else\n-\treturn register_operand (op, mode);\n-    case MEM :\n-      return address_operand (XEXP (op, 0), mode);\n-    default :\n-      return 0;\n-    }\n-}\n-\n-/* Return true if OP is valid load with update operand.  */\n-\n-int\n-load_update_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) != MEM\n-      || GET_MODE (op) != mode)\n-    return 0;\n-  op = XEXP (op, 0);\n-  if (GET_CODE (op) != PLUS\n-      || GET_MODE (op) != Pmode\n-      || !register_operand (XEXP (op, 0), Pmode)\n-      || !nonmemory_operand (XEXP (op, 1), Pmode))\n-    return 0;\n-  return 1;\n-}\n-\n-/* Return true if OP is valid store with update operand.  */\n-\n-int\n-store_update_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) != MEM\n-      || GET_MODE (op) != mode)\n-    return 0;\n-  op = XEXP (op, 0);\n-  if (GET_CODE (op) != PLUS\n-      || GET_MODE (op) != Pmode\n-      || !register_operand (XEXP (op, 0), Pmode)\n-      || !(GET_CODE (XEXP (op, 1)) == CONST_INT\n-\t   && SMALL_INT (INTVAL (XEXP (op, 1)))))\n-    return 0;\n-  return 1;\n-}\n-\n-/* Return true if OP is a non-volatile non-immediate operand.\n-   Volatile memory refs require a special \"cache-bypass\" instruction\n-   and only the standard movXX patterns are set up to handle them.  */\n-\n-int\n-nonvol_nonimm_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == MEM && MEM_VOLATILE_P (op))\n-    return 0;\n-  return nonimmediate_operand (op, mode);\n-}\n-\n-/* Accept integer operands in the range -0x80000000..0x7fffffff.  We have\n-   to check the range carefully since this predicate is used in DImode\n-   contexts.  */\n-\n-int\n-const_sint32_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  /* All allowed constants will fit a CONST_INT.  */\n-  return (GET_CODE (op) == CONST_INT\n-\t  && (INTVAL (op) >= (-0x7fffffff - 1) && INTVAL (op) <= 0x7fffffff));\n-}\n-\n-/* Accept integer operands in the range 0..0xffffffff.  We have to check the\n-   range carefully since this predicate is used in DImode contexts.  Also, we\n-   need some extra crud to make it work when hosted on 64-bit machines.  */\n-\n-int\n-const_uint32_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-#if HOST_BITS_PER_WIDE_INT > 32\n-  /* All allowed constants will fit a CONST_INT.  */\n-  return (GET_CODE (op) == CONST_INT\n-\t  && (INTVAL (op) >= 0 && INTVAL (op) <= 0xffffffffL));\n-#else\n-  return ((GET_CODE (op) == CONST_INT && INTVAL (op) >= 0)\n-\t  || (GET_CODE (op) == CONST_DOUBLE && CONST_DOUBLE_HIGH (op) == 0));\n-#endif\n-}\n-\n-/* Return 1 if OP is a comparison operator valid for the mode of CC.\n-   This allows the use of MATCH_OPERATOR to recognize all the branch insns.\n-\n-   Some insns only set a few bits in the condition code.  So only allow those\n-   comparisons that use the bits that are valid.  */\n-\n-int\n-proper_comparison_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  enum rtx_code code;\n-  if (!COMPARISON_P (op))\n-    return 0;\n-\n-  code = GET_CODE (op);\n-  if (GET_MODE (XEXP (op, 0)) == CCZNmode)\n-    return (code == EQ || code == NE);\n-  if (GET_MODE (XEXP (op, 0)) == CCZNCmode)\n-    return (code == EQ || code == NE\n-\t    || code == LTU || code == GEU || code == GTU || code == LEU);\n-  return 1;\n-}\n-\f\n-/* Misc. utilities.  */\n-\n-/* X and Y are two things to compare using CODE.  Return the rtx\n-   for the cc reg in the proper mode.  */\n-\n-rtx\n-gen_compare_reg (enum rtx_code code, rtx x, rtx y)\n-{\n-  enum machine_mode mode = SELECT_CC_MODE (code, x, y);\n-  return gen_rtx_REG (mode, 61);\n-}\n-\n-/* Return 1 if VALUE, a const_double, will fit in a limm (4 byte number).\n-   We assume the value can be either signed or unsigned.  */\n-\n-int\n-arc_double_limm_p (rtx value)\n-{\n-  HOST_WIDE_INT low, high;\n-\n-  gcc_assert (GET_CODE (value) == CONST_DOUBLE);\n-\n-  low = CONST_DOUBLE_LOW (value);\n-  high = CONST_DOUBLE_HIGH (value);\n-\n-  if (low & 0x80000000)\n-    {\n-      return (((unsigned HOST_WIDE_INT) low <= 0xffffffff && high == 0)\n-\t      || (((low & - (unsigned HOST_WIDE_INT) 0x80000000)\n-\t\t   == - (unsigned HOST_WIDE_INT) 0x80000000)\n-\t\t  && high == -1));\n-    }\n-  else\n-    {\n-      return (unsigned HOST_WIDE_INT) low <= 0x7fffffff && high == 0;\n-    }\n-}\n-\f\n-/* Do any needed setup for a variadic function.  For the ARC, we must\n-   create a register parameter block, and then copy any anonymous arguments\n-   in registers to memory.\n-\n-   CUM has not been updated for the last named argument which has type TYPE\n-   and mode MODE, and we rely on this fact.\n-\n-   We do things a little weird here.  We're supposed to only allocate space\n-   for the anonymous arguments.  However we need to keep the stack eight byte\n-   aligned.  So we round the space up if necessary, and leave it to va_start\n-   to compensate.  */\n-\n-static void\n-arc_setup_incoming_varargs (CUMULATIVE_ARGS *cum,\n-                            enum machine_mode mode,\n-                            tree type ATTRIBUTE_UNUSED,\n-                            int *pretend_size,\n-                            int no_rtl)\n-{\n-  int first_anon_arg;\n-\n-  /* All BLKmode values are passed by reference.  */\n-  gcc_assert (mode != BLKmode);\n-\n-  first_anon_arg = *cum + ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1)\n-\t\t\t   / UNITS_PER_WORD);\n-\n-  if (first_anon_arg < MAX_ARC_PARM_REGS && !no_rtl)\n-    {\n-      /* Note that first_reg_offset < MAX_ARC_PARM_REGS.  */\n-      int first_reg_offset = first_anon_arg;\n-      /* Size in words to \"pretend\" allocate.  */\n-      int size = MAX_ARC_PARM_REGS - first_reg_offset;\n-      /* Extra slop to keep stack eight byte aligned.  */\n-      int align_slop = size & 1;\n-      rtx regblock;\n-\n-      regblock = gen_rtx_MEM (BLKmode,\n-\t\t\t      plus_constant (arg_pointer_rtx,\n-\t\t\t\t\t     FIRST_PARM_OFFSET (0)\n-\t\t\t\t\t     + align_slop * UNITS_PER_WORD));\n-      set_mem_alias_set (regblock, get_varargs_alias_set ());\n-      set_mem_align (regblock, BITS_PER_WORD);\n-      move_block_from_reg (first_reg_offset, regblock,\n-\t\t\t   MAX_ARC_PARM_REGS - first_reg_offset);\n-\n-      *pretend_size = ((MAX_ARC_PARM_REGS - first_reg_offset + align_slop)\n-\t\t       * UNITS_PER_WORD);\n-    }\n-}\n-\f\n-/* Cost functions.  */\n-\n-/* Compute a (partial) cost for rtx X.  Return true if the complete\n-   cost has been computed, and false if subexpressions should be\n-   scanned.  In either case, *TOTAL contains the cost result.  */\n-\n-static bool\n-arc_rtx_costs (rtx x, int code, int outer_code ATTRIBUTE_UNUSED, int *total,\n-\t       bool speed ATTRIBUTE_UNUSED)\n-{\n-  switch (code)\n-    {\n-      /* Small integers are as cheap as registers.  4 byte values can\n-\t be fetched as immediate constants - let's give that the cost\n-\t of an extra insn.  */\n-    case CONST_INT:\n-      if (SMALL_INT (INTVAL (x)))\n-\t{\n-\t  *total = 0;\n-\t  return true;\n-\t}\n-      /* FALLTHRU */\n-\n-    case CONST:\n-    case LABEL_REF:\n-    case SYMBOL_REF:\n-      *total = COSTS_N_INSNS (1);\n-      return true;\n-\n-    case CONST_DOUBLE:\n-      {\n-        rtx high, low;\n-        split_double (x, &high, &low);\n-\t*total = COSTS_N_INSNS (!SMALL_INT (INTVAL (high))\n-\t\t\t\t+ !SMALL_INT (INTVAL (low)));\n-\treturn true;\n-      }\n-\n-    /* Encourage synth_mult to find a synthetic multiply when reasonable.\n-       If we need more than 12 insns to do a multiply, then go out-of-line,\n-       since the call overhead will be < 10% of the cost of the multiply.  */\n-    case ASHIFT:\n-    case ASHIFTRT:\n-    case LSHIFTRT:\n-      if (TARGET_SHIFTER)\n-        *total = COSTS_N_INSNS (1);\n-      else if (GET_CODE (XEXP (x, 1)) != CONST_INT)\n-        *total = COSTS_N_INSNS (16);\n-      else\n-        *total = COSTS_N_INSNS (INTVAL (XEXP ((x), 1)));\n-      return false;\n-\n-    default:\n-      return false;\n-    }\n-}\n-\n-\n-/* Provide the costs of an addressing mode that contains ADDR.\n-   If ADDR is not a valid address, its cost is irrelevant.  */\n-\n-static int\n-arc_address_cost (rtx addr, bool speed ATTRIBUTE_UNUSED)\n-{\n-  switch (GET_CODE (addr))\n-    {\n-    case REG :\n-      return 1;\n-\n-    case LABEL_REF :\n-    case SYMBOL_REF :\n-    case CONST :\n-      return 2;\n-\n-    case PLUS :\n-      {\n-\tregister rtx plus0 = XEXP (addr, 0);\n-\tregister rtx plus1 = XEXP (addr, 1);\n-\n-\tif (GET_CODE (plus0) != REG)\n-\t  break;\n-\n-\tswitch (GET_CODE (plus1))\n-\t  {\n-\t  case CONST_INT :\n-\t    return SMALL_INT (INTVAL (plus1)) ? 1 : 2;\n-\t  case CONST :\n-\t  case SYMBOL_REF :\n-\t  case LABEL_REF :\n-\t    return 2;\n-\t  default:\n-\t    break;\n-\t  }\n-\tbreak;\n-      }\n-    default:\n-      break;\n-    }\n-\n-  return 4;\n-}\n-\f\n-/* Function prologue/epilogue handlers.  */\n-\n-/* ARC stack frames look like:\n-\n-             Before call                       After call\n-        +-----------------------+       +-----------------------+\n-        |                       |       |                       |\n-   high |  local variables,     |       |  local variables,     |\n-   mem  |  reg save area, etc.  |       |  reg save area, etc.  |\n-        |                       |       |                       |\n-        +-----------------------+       +-----------------------+\n-        |                       |       |                       |\n-        |  arguments on stack.  |       |  arguments on stack.  |\n-        |                       |       |                       |\n- SP+16->+-----------------------+FP+48->+-----------------------+\n-        | 4 word save area for  |       |  reg parm save area,  |\n-        | return addr, prev %fp |       |  only created for     |    \n-  SP+0->+-----------------------+       |  variable argument    |    \n-                                        |  functions            |    \n-                                 FP+16->+-----------------------+    \n-                                        | 4 word save area for  |    \n-                                        | return addr, prev %fp |    \n-                                  FP+0->+-----------------------+    \n-                                        |                       |    \n-                                        |  local variables      |    \n-                                        |                       |    \n-                                        +-----------------------+    \n-                                        |                       |    \n-                                        |  register save area   |    \n-                                        |                       |    \n-                                        +-----------------------+    \n-                                        |                       |    \n-                                        |  alloca allocations   |    \n-                                        |                       |    \n-                                        +-----------------------+    \n-                                        |                       |    \n-                                        |  arguments on stack   |    \n-                                        |                       |    \n-                                 SP+16->+-----------------------+\n-   low                                  | 4 word save area for  |    \n-   memory                               | return addr, prev %fp |    \n-                                  SP+0->+-----------------------+    \n-\n-Notes:\n-1) The \"reg parm save area\" does not exist for non variable argument fns.\n-   The \"reg parm save area\" can be eliminated completely if we created our\n-   own va-arc.h, but that has tradeoffs as well (so it's not done).  */\n-\n-/* Structure to be filled in by arc_compute_frame_size with register\n-   save masks, and offsets for the current function.  */\n-struct arc_frame_info\n-{\n-  unsigned int total_size;\t/* # bytes that the entire frame takes up.  */\n-  unsigned int extra_size;\t/* # bytes of extra stuff.  */\n-  unsigned int pretend_size;\t/* # bytes we push and pretend caller did.  */\n-  unsigned int args_size;\t/* # bytes that outgoing arguments take up.  */\n-  unsigned int reg_size;\t/* # bytes needed to store regs.  */\n-  unsigned int var_size;\t/* # bytes that variables take up.  */\n-  unsigned int reg_offset;\t/* Offset from new sp to store regs.  */\n-  unsigned int gmask;\t\t/* Mask of saved gp registers.  */\n-  int          initialized;\t/* Nonzero if frame size already calculated.  */\n-};\n-\n-/* Current frame information calculated by arc_compute_frame_size.  */\n-static struct arc_frame_info current_frame_info;\n-\n-/* Zero structure to initialize current_frame_info.  */\n-static struct arc_frame_info zero_frame_info;\n-\n-/* Type of function DECL.\n-\n-   The result is cached.  To reset the cache at the end of a function,\n-   call with DECL = NULL_TREE.  */\n-\n-enum arc_function_type\n-arc_compute_function_type (tree decl)\n-{\n-  tree a;\n-  /* Cached value.  */\n-  static enum arc_function_type fn_type = ARC_FUNCTION_UNKNOWN;\n-  /* Last function we were called for.  */\n-  static tree last_fn = NULL_TREE;\n-\n-  /* Resetting the cached value?  */\n-  if (decl == NULL_TREE)\n-    {\n-      fn_type = ARC_FUNCTION_UNKNOWN;\n-      last_fn = NULL_TREE;\n-      return fn_type;\n-    }\n-\n-  if (decl == last_fn && fn_type != ARC_FUNCTION_UNKNOWN)\n-    return fn_type;\n-\n-  /* Assume we have a normal function (not an interrupt handler).  */\n-  fn_type = ARC_FUNCTION_NORMAL;\n-\n-  /* Now see if this is an interrupt handler.  */\n-  for (a = DECL_ATTRIBUTES (current_function_decl);\n-       a;\n-       a = TREE_CHAIN (a))\n-    {\n-      tree name = TREE_PURPOSE (a), args = TREE_VALUE (a);\n-\n-      if (name == get_identifier (\"__interrupt__\")\n-\t  && list_length (args) == 1\n-\t  && TREE_CODE (TREE_VALUE (args)) == STRING_CST)\n-\t{\n-\t  tree value = TREE_VALUE (args);\n-\n-\t  if (!strcmp (TREE_STRING_POINTER (value), \"ilink1\"))\n-\t    fn_type = ARC_FUNCTION_ILINK1;\n-\t  else if (!strcmp (TREE_STRING_POINTER (value), \"ilink2\"))\n-\t    fn_type = ARC_FUNCTION_ILINK2;\n-\t  else\n-\t    gcc_unreachable ();\n-\t  break;\n-\t}\n-    }\n-\n-  last_fn = decl;\n-  return fn_type;\n-}\n-\n-#define ILINK1_REGNUM 29\n-#define ILINK2_REGNUM 30\n-#define RETURN_ADDR_REGNUM 31\n-#define FRAME_POINTER_MASK (1 << (FRAME_POINTER_REGNUM))\n-#define RETURN_ADDR_MASK (1 << (RETURN_ADDR_REGNUM))\n-\n-/* Tell prologue and epilogue if register REGNO should be saved / restored.\n-   The return address and frame pointer are treated separately.\n-   Don't consider them here.  */\n-#define MUST_SAVE_REGISTER(regno, interrupt_p) \\\n-((regno) != RETURN_ADDR_REGNUM && (regno) != FRAME_POINTER_REGNUM \\\n- && (df_regs_ever_live_p (regno) && (!call_used_regs[regno] || interrupt_p)))\n-\n-#define MUST_SAVE_RETURN_ADDR (df_regs_ever_live_p (RETURN_ADDR_REGNUM))\n-\n-/* Return the bytes needed to compute the frame pointer from the current\n-   stack pointer.\n-\n-   SIZE is the size needed for local variables.  */\n-\n-unsigned int\n-arc_compute_frame_size (int size /* # of var. bytes allocated.  */)\n-{\n-  int regno;\n-  unsigned int total_size, var_size, args_size, pretend_size, extra_size;\n-  unsigned int reg_size, reg_offset;\n-  unsigned int gmask;\n-  enum arc_function_type fn_type;\n-  int interrupt_p;\n-\n-  var_size\t= size;\n-  args_size\t= crtl->outgoing_args_size;\n-  pretend_size\t= crtl->args.pretend_args_size;\n-  extra_size\t= FIRST_PARM_OFFSET (0);\n-  total_size\t= extra_size + pretend_size + args_size + var_size;\n-  reg_offset\t= FIRST_PARM_OFFSET(0) + crtl->outgoing_args_size;\n-  reg_size\t= 0;\n-  gmask\t\t= 0;\n-\n-  /* See if this is an interrupt handler.  Call used registers must be saved\n-     for them too.  */\n-  fn_type = arc_compute_function_type (current_function_decl);\n-  interrupt_p = ARC_INTERRUPT_P (fn_type);\n-\n-  /* Calculate space needed for registers.\n-     ??? We ignore the extension registers for now.  */\n-\n-  for (regno = 0; regno <= 31; regno++)\n-    {\n-      if (MUST_SAVE_REGISTER (regno, interrupt_p))\n-\t{\n-\t  reg_size += UNITS_PER_WORD;\n-\t  gmask |= 1 << regno;\n-\t}\n-    }\n-\n-  total_size += reg_size;\n-\n-  /* If the only space to allocate is the fp/blink save area this is an\n-     empty frame.  However, if we'll be making a function call we need to\n-     allocate a stack frame for our callee's fp/blink save area.  */\n-  if (total_size == extra_size\n-      && !MUST_SAVE_RETURN_ADDR)\n-    total_size = extra_size = 0;\n-\n-  total_size = ARC_STACK_ALIGN (total_size);\n-\n-  /* Save computed information.  */\n-  current_frame_info.total_size   = total_size;\n-  current_frame_info.extra_size   = extra_size;\n-  current_frame_info.pretend_size = pretend_size;\n-  current_frame_info.var_size     = var_size;\n-  current_frame_info.args_size    = args_size;\n-  current_frame_info.reg_size\t  = reg_size;\n-  current_frame_info.reg_offset\t  = reg_offset;\n-  current_frame_info.gmask\t  = gmask;\n-  current_frame_info.initialized  = reload_completed;\n-\n-  /* Ok, we're done.  */\n-  return total_size;\n-}\n-\f\n-/* Common code to save/restore registers.  */\n-\n-void\n-arc_save_restore (FILE *file,\n-                  const char *base_reg,\n-                  unsigned int offset,\n-                  unsigned int gmask,\n-                  const char *op)\n-{\n-  int regno;\n-\n-  if (gmask == 0)\n-    return;\n-\n-  for (regno = 0; regno <= 31; regno++)\n-    {\n-      if ((gmask & (1L << regno)) != 0)\n-\t{\n-\t  fprintf (file, \"\\t%s %s,[%s,%d]\\n\",\n-\t\t     op, reg_names[regno], base_reg, offset);\n-\t  offset += UNITS_PER_WORD;\n-\t}\n-    }\n-}\n-\f\n-/* Target hook to assemble an integer object.  The ARC version needs to\n-   emit a special directive for references to labels and function\n-   symbols.  */\n-\n-static bool\n-arc_assemble_integer (rtx x, unsigned int size, int aligned_p)\n-{\n-  if (size == UNITS_PER_WORD && aligned_p\n-      && ((GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_FUNCTION_P (x))\n-\t  || GET_CODE (x) == LABEL_REF))\n-    {\n-      fputs (\"\\t.word\\t%st(\", asm_out_file);\n-      output_addr_const (asm_out_file, x);\n-      fputs (\")\\n\", asm_out_file);\n-      return true;\n-    }\n-  return default_assemble_integer (x, size, aligned_p);\n-}\n-\f\n-/* Set up the stack and frame pointer (if desired) for the function.  */\n-\n-static void\n-arc_output_function_prologue (FILE *file, HOST_WIDE_INT size)\n-{\n-  const char *sp_str = reg_names[STACK_POINTER_REGNUM];\n-  const char *fp_str = reg_names[FRAME_POINTER_REGNUM];\n-  unsigned int gmask = current_frame_info.gmask;\n-  enum arc_function_type fn_type = arc_compute_function_type (current_function_decl);\n-\n-  /* If this is an interrupt handler, set up our stack frame.\n-     ??? Optimize later.  */\n-  if (ARC_INTERRUPT_P (fn_type))\n-    {\n-      fprintf (file, \"\\t%s interrupt handler\\n\",\n-\t       ASM_COMMENT_START);\n-      fprintf (file, \"\\tsub %s,%s,16\\n\", sp_str, sp_str);\n-    }\n-\n-  /* This is only for the human reader.  */\n-  fprintf (file, \"\\t%s BEGIN PROLOGUE %s vars= %d, regs= %d, args= %d, extra= %d\\n\",\n-\t   ASM_COMMENT_START, ASM_COMMENT_START,\n-\t   current_frame_info.var_size,\n-\t   current_frame_info.reg_size / 4,\n-\t   current_frame_info.args_size,\n-\t   current_frame_info.extra_size);\n-\n-  size = ARC_STACK_ALIGN (size);\n-  size = (! current_frame_info.initialized\n-\t   ? arc_compute_frame_size (size)\n-\t   : current_frame_info.total_size);\n-\n-  /* These cases shouldn't happen.  Catch them now.  */\n-  gcc_assert (size || !gmask);\n-\n-  /* Allocate space for register arguments if this is a variadic function.  */\n-  if (current_frame_info.pretend_size != 0)\n-    fprintf (file, \"\\tsub %s,%s,%d\\n\",\n-\t     sp_str, sp_str, current_frame_info.pretend_size);\n-\n-  /* The home-grown ABI says link register is saved first.  */\n-  if (MUST_SAVE_RETURN_ADDR)\n-    fprintf (file, \"\\tst %s,[%s,%d]\\n\",\n-\t     reg_names[RETURN_ADDR_REGNUM], sp_str, UNITS_PER_WORD);\n-\n-  /* Set up the previous frame pointer next (if we need to).  */\n-  if (frame_pointer_needed)\n-    {\n-      fprintf (file, \"\\tst %s,[%s]\\n\", fp_str, sp_str);\n-      fprintf (file, \"\\tmov %s,%s\\n\", fp_str, sp_str);\n-    }\n-\n-  /* ??? We don't handle the case where the saved regs are more than 252\n-     bytes away from sp.  This can be handled by decrementing sp once, saving\n-     the regs, and then decrementing it again.  The epilogue doesn't have this\n-     problem as the `ld' insn takes reg+limm values (though it would be more\n-     efficient to avoid reg+limm).  */\n-\n-  /* Allocate the stack frame.  */\n-  if (size - current_frame_info.pretend_size > 0)\n-    fprintf (file, \"\\tsub %s,%s,\" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-\t     sp_str, sp_str, size - current_frame_info.pretend_size);\n-\n-  /* Save any needed call-saved regs (and call-used if this is an\n-     interrupt handler).  */\n-  arc_save_restore (file, sp_str, current_frame_info.reg_offset,\n-\t\t    /* The zeroing of these two bits is unnecessary,\n-\t\t       but leave this in for clarity.  */\n-\t\t    gmask & ~(FRAME_POINTER_MASK | RETURN_ADDR_MASK),\n-\t\t    \"st\");\n-\n-  fprintf (file, \"\\t%s END PROLOGUE\\n\", ASM_COMMENT_START);\n-}\n-\f\n-/* Do any necessary cleanup after a function to restore stack, frame,\n-   and regs.  */\n-\n-static void\n-arc_output_function_epilogue (FILE *file, HOST_WIDE_INT size)\n-{\n-  rtx epilogue_delay = crtl->epilogue_delay_list;\n-  int noepilogue = FALSE;\n-  enum arc_function_type fn_type = arc_compute_function_type (current_function_decl);\n-\n-  /* This is only for the human reader.  */\n-  fprintf (file, \"\\t%s EPILOGUE\\n\", ASM_COMMENT_START);\n-\n-  size = ARC_STACK_ALIGN (size);\n-  size = (!current_frame_info.initialized\n-\t   ? arc_compute_frame_size (size)\n-\t   : current_frame_info.total_size);\n-\n-  if (size == 0 && epilogue_delay == 0)\n-    {\n-      rtx insn = get_last_insn ();\n-\n-      /* If the last insn was a BARRIER, we don't have to write any code\n-\t because a jump (aka return) was put there.  */\n-      if (GET_CODE (insn) == NOTE)\n-\tinsn = prev_nonnote_insn (insn);\n-      if (insn && GET_CODE (insn) == BARRIER)\n-\tnoepilogue = TRUE;\n-    }\n-\n-  if (!noepilogue)\n-    {\n-      unsigned int pretend_size = current_frame_info.pretend_size;\n-      unsigned int frame_size = size - pretend_size;\n-      int restored, fp_restored_p;\n-      int can_trust_sp_p = !cfun->calls_alloca;\n-      const char *sp_str = reg_names[STACK_POINTER_REGNUM];\n-      const char *fp_str = reg_names[FRAME_POINTER_REGNUM];\n-\n-      /* ??? There are lots of optimizations that can be done here.\n-\t EG: Use fp to restore regs if it's closer.\n-\t Maybe in time we'll do them all.  For now, always restore regs from\n-\t sp, but don't restore sp if we don't have to.  */\n-\n-      if (!can_trust_sp_p)\n-\t{\n-\t  gcc_assert (frame_pointer_needed);\n-\t  fprintf (file,\"\\tsub %s,%s,%d\\t\\t%s sp not trusted here\\n\",\n-\t\t   sp_str, fp_str, frame_size, ASM_COMMENT_START);\n-\t}\n-\n-      /* Restore any saved registers.  */\n-      arc_save_restore (file, sp_str, current_frame_info.reg_offset,\n-\t\t\t/* The zeroing of these two bits is unnecessary,\n-\t\t\t   but leave this in for clarity.  */\n-\t\t\tcurrent_frame_info.gmask & ~(FRAME_POINTER_MASK | RETURN_ADDR_MASK),\n-\t\t\t\"ld\");\n-\n-      if (MUST_SAVE_RETURN_ADDR)\n-\tfprintf (file, \"\\tld %s,[%s,%d]\\n\",\n-\t\t reg_names[RETURN_ADDR_REGNUM],\n-\t\t frame_pointer_needed ? fp_str : sp_str,\n-\t\t UNITS_PER_WORD + (frame_pointer_needed ? 0 : frame_size));\n-\n-      /* Keep track of how much of the stack pointer we've restored.\n-\t It makes the following a lot more readable.  */\n-      restored = 0;\n-      fp_restored_p = 0;\n-\n-      /* We try to emit the epilogue delay slot insn right after the load\n-\t of the return address register so that it can execute with the\n-\t stack intact.  Secondly, loads are delayed.  */\n-      /* ??? If stack intactness is important, always emit now.  */\n-      if (MUST_SAVE_RETURN_ADDR && epilogue_delay != NULL_RTX)\n-\t{\n-\t  final_scan_insn (XEXP (epilogue_delay, 0), file, 1, 1, NULL);\n-\t  epilogue_delay = NULL_RTX;\n-\t}\n-\n-      if (frame_pointer_needed)\n-\t{\n-\t  /* Try to restore the frame pointer in the delay slot.  We can't,\n-\t     however, if any of these is true.  */\n-\t  if (epilogue_delay != NULL_RTX\n-\t      || !SMALL_INT (frame_size)\n-\t      || pretend_size\n-\t      || ARC_INTERRUPT_P (fn_type))\n-\t    {\n-\t      /* Note that we restore fp and sp here!  */\n-\t      fprintf (file, \"\\tld.a %s,[%s,%d]\\n\", fp_str, sp_str, frame_size);\n-\t      restored += frame_size;\n-\t      fp_restored_p = 1;\n-\t    }\n-\t}\n-      else if (!SMALL_INT (size /* frame_size + pretend_size */)\n-\t       || ARC_INTERRUPT_P (fn_type))\n-\t{\n-\t  fprintf (file, \"\\tadd %s,%s,%d\\n\", sp_str, sp_str, frame_size);\n-\t  restored += frame_size;\n-\t}\n-\n-      /* These must be done before the return insn because the delay slot\n-\t does the final stack restore.  */\n-      if (ARC_INTERRUPT_P (fn_type))\n-\t{\n-\t  if (epilogue_delay)\n-\t    {\n-\t      final_scan_insn (XEXP (epilogue_delay, 0), file, 1, 1, NULL);\n-\t    }\n-\t}\n-\n-      /* Emit the return instruction.  */\n-      {\n-\tstatic const int regs[4] = {\n-\t  0, RETURN_ADDR_REGNUM, ILINK1_REGNUM, ILINK2_REGNUM\n-\t};\n-\n-\t/* Update the flags, if returning from an interrupt handler. */\n-\tif (ARC_INTERRUPT_P (fn_type))\n-\t  fprintf (file, \"\\tj.d.f %s\\n\", reg_names[regs[fn_type]]);\n-\telse\n-\t  fprintf (file, \"\\tj.d %s\\n\", reg_names[regs[fn_type]]);\n-\t}\n-\n-      /* If the only register saved is the return address, we need a\n-\t nop, unless we have an instruction to put into it.  Otherwise\n-\t we don't since reloading multiple registers doesn't reference\n-\t the register being loaded.  */\n-\n-      if (ARC_INTERRUPT_P (fn_type))\n-\tfprintf (file, \"\\tadd %s,%s,16\\n\", sp_str, sp_str);\n-      else if (epilogue_delay != NULL_RTX)\n-\t{\n-\t  gcc_assert (!frame_pointer_needed || fp_restored_p);\n-\t  gcc_assert (restored >= size);\n-\t  final_scan_insn (XEXP (epilogue_delay, 0), file, 1, 1, NULL);\n-\t}\n-      else if (frame_pointer_needed && !fp_restored_p)\n-\t{\n-\t  gcc_assert (SMALL_INT (frame_size));\n-\t  /* Note that we restore fp and sp here!  */\n-\t  fprintf (file, \"\\tld.a %s,[%s,%d]\\n\", fp_str, sp_str, frame_size);\n-\t}\n-      else if (restored < size)\n-\t{\n-\t  gcc_assert (SMALL_INT (size - restored));\n-\t  fprintf (file, \"\\tadd %s,%s,\" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n-\t\t   sp_str, sp_str, size - restored);\n-\t}\n-      else\n-\tfprintf (file, \"\\tnop\\n\");\n-    }\n-\n-  /* Reset state info for each function.  */\n-  current_frame_info = zero_frame_info;\n-  arc_compute_function_type (NULL_TREE);\n-}\n-\f\n-/* Define the number of delay slots needed for the function epilogue.\n-\n-   Interrupt handlers can't have any epilogue delay slots (it's always needed\n-   for something else, I think).  For normal functions, we have to worry about\n-   using call-saved regs as they'll be restored before the delay slot insn.\n-   Functions with non-empty frames already have enough choices for the epilogue\n-   delay slot so for now we only consider functions with empty frames.  */\n-\n-int\n-arc_delay_slots_for_epilogue (void)\n-{\n-  if (arc_compute_function_type (current_function_decl) != ARC_FUNCTION_NORMAL)\n-    return 0;\n-  if (!current_frame_info.initialized)\n-    (void) arc_compute_frame_size (get_frame_size ());\n-  if (current_frame_info.total_size == 0)\n-    return 1;\n-  return 0;\n-}\n-\n-/* Return true if TRIAL is a valid insn for the epilogue delay slot.\n-   Any single length instruction which doesn't reference the stack or frame\n-   pointer or any call-saved register is OK.  SLOT will always be 0.  */\n-\n-int\n-arc_eligible_for_epilogue_delay (rtx trial, int slot)\n-{\n-  gcc_assert (!slot);\n-\n-  if (get_attr_length (trial) == 1\n-      /* If registers where saved, presumably there's more than enough\n-\t possibilities for the delay slot.  The alternative is something\n-\t more complicated (of course, if we expanded the epilogue as rtl\n-\t this problem would go away).  */\n-      /* ??? Note that this will always be true since only functions with\n-\t empty frames have epilogue delay slots.  See\n-\t arc_delay_slots_for_epilogue.  */\n-      && current_frame_info.gmask == 0\n-      && ! reg_mentioned_p (stack_pointer_rtx, PATTERN (trial))\n-      && ! reg_mentioned_p (frame_pointer_rtx, PATTERN (trial)))\n-    return 1;\n-  return 0;\n-}\n-\f\n-/* Return true if OP is a shift operator.  */\n-\n-int\n-shift_operator (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case ASHIFTRT:\n-    case LSHIFTRT:\n-    case ASHIFT:\n-      return 1;\n-    default:\n-      return 0;\n-    }\n-}\n-\n-/* Output the assembler code for doing a shift.\n-   We go to a bit of trouble to generate efficient code as the ARC only has\n-   single bit shifts.  This is taken from the h8300 port.  We only have one\n-   mode of shifting and can't access individual bytes like the h8300 can, so\n-   this is greatly simplified (at the expense of not generating hyper-\n-   efficient code).\n-\n-   This function is not used if the variable shift insns are present.  */\n-\n-/* ??? We assume the output operand is the same as operand 1.\n-   This can be optimized (deleted) in the case of 1 bit shifts.  */\n-/* ??? We use the loop register here.  We don't use it elsewhere (yet) and\n-   using it here will give us a chance to play with it.  */\n-\n-const char *\n-output_shift (rtx *operands)\n-{\n-  rtx shift = operands[3];\n-  enum machine_mode mode = GET_MODE (shift);\n-  enum rtx_code code = GET_CODE (shift);\n-  const char *shift_one;\n-\n-  gcc_assert (mode == SImode);\n-\n-  switch (code)\n-    {\n-    case ASHIFT:   shift_one = \"asl %0,%0\"; break;\n-    case ASHIFTRT: shift_one = \"asr %0,%0\"; break;\n-    case LSHIFTRT: shift_one = \"lsr %0,%0\"; break;\n-    default:       gcc_unreachable ();\n-    }\n-\n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    {\n-      if (optimize)\n-\t{\n-\t  output_asm_insn (\"sub.f 0,%2,0\", operands);\n-      \t  output_asm_insn (\"mov lp_count,%2\", operands);\n-\t  output_asm_insn (\"bz 2f\", operands);\n-\t}\n-      else\n-\toutput_asm_insn (\"mov %4,%2\", operands);\n-      goto shiftloop;\n-    }\n-  else\n-    {\n-      int n;\n-\n-      /* If the count is negative, make it 0.  */\n-      n = INTVAL (operands[2]);\n-      if (n < 0)\n-\tn = 0;\n-      /* If the count is too big, truncate it.\n-         ANSI says shifts of GET_MODE_BITSIZE are undefined - we choose to\n-\t do the intuitive thing.  */\n-      else if (n > GET_MODE_BITSIZE (mode))\n-\tn = GET_MODE_BITSIZE (mode);\n-\n-      /* First see if we can do them inline.  */\n-      if (n <= 8)\n-\t{\n-\t  while (--n >= 0)\n-\t    output_asm_insn (shift_one, operands);\n-\t}\n-      /* See if we can use a rotate/and.  */\n-      else if (n == BITS_PER_WORD - 1)\n-\t{\n-\t  switch (code)\n-\t    {\n-\t    case ASHIFT :\n-\t      output_asm_insn (\"and %0,%0,1\\n\\tror %0,%0\", operands);\n-\t      break;\n-\t    case ASHIFTRT :\n-\t      /* The ARC doesn't have a rol insn.  Use something else.  */\n-\t      output_asm_insn (\"asl.f 0,%0\\n\\tsbc %0,0,0\", operands);\n-\t      break;\n-\t    case LSHIFTRT :\n-\t      /* The ARC doesn't have a rol insn.  Use something else.  */\n-\t      output_asm_insn (\"asl.f 0,%0\\n\\tadc %0,0,0\", operands);\n-\t      break;\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-      /* Must loop.  */\n-      else\n-\t{\n-\t  char buf[100];\n-\n-\t  if (optimize)\n-\t    output_asm_insn (\"mov lp_count,%c2\", operands);\n-\t  else\n-\t    output_asm_insn (\"mov %4,%c2\", operands);\n-\tshiftloop:\n-\t  if (optimize)\n-\t    {\n-\t      if (flag_pic)\n-\t\tsprintf (buf, \"lr %%4,[status]\\n\\tadd %%4,%%4,6\\t%s single insn loop start\",\n-\t\t\t ASM_COMMENT_START);\n-\t      else\n-\t\tsprintf (buf, \"mov %%4,%%%%st(1f)\\t%s (single insn loop start) >> 2\",\n-\t\t\t ASM_COMMENT_START);\n-\t      output_asm_insn (buf, operands);\n-\t      output_asm_insn (\"sr %4,[lp_start]\", operands);\n-\t      output_asm_insn (\"add %4,%4,1\", operands);\n-\t      output_asm_insn (\"sr %4,[lp_end]\", operands);\n-\t      output_asm_insn (\"nop\\n\\tnop\", operands);\n-\t      if (flag_pic)\n-\t\tfprintf (asm_out_file, \"\\t%s single insn loop\\n\",\n-\t\t\t ASM_COMMENT_START);\n-\t      else\n-\t\tfprintf (asm_out_file, \"1:\\t%s single insn loop\\n\",\n-\t\t\t ASM_COMMENT_START);\n-\t      output_asm_insn (shift_one, operands);\n-\t      fprintf (asm_out_file, \"2:\\t%s end single insn loop\\n\",\n-\t\t       ASM_COMMENT_START);\n-\t    }\n-\t  else \n-\t    {\n-\t      fprintf (asm_out_file, \"1:\\t%s begin shift loop\\n\",\n-\t\t       ASM_COMMENT_START);\n-\t      output_asm_insn (\"sub.f %4,%4,1\", operands);\n-\t      output_asm_insn (\"nop\", operands);\n-\t      output_asm_insn (\"bn.nd 2f\", operands);\n-\t      output_asm_insn (shift_one, operands);\n-\t      output_asm_insn (\"b.nd 1b\", operands);\n-\t      fprintf (asm_out_file, \"2:\\t%s end shift loop\\n\",\n-\t\t       ASM_COMMENT_START);\n-\t    }\n-\t}\n-    }\n-\n-  return \"\";\n-}\n-\f\n-/* Nested function support.  */\n-\n-/* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.  */\n-\n-void\n-arc_initialize_trampoline (rtx tramp ATTRIBUTE_UNUSED,\n-                           rtx fnaddr ATTRIBUTE_UNUSED,\n-                           rtx cxt ATTRIBUTE_UNUSED)\n-{\n-}\n-\f\n-/* Set the cpu type and print out other fancy things,\n-   at the top of the file.  */\n-\n-static void\n-arc_file_start (void)\n-{\n-  default_file_start ();\n-  fprintf (asm_out_file, \"\\t.cpu %s\\n\", arc_cpu_string);\n-}\n-\f\n-/* Print operand X (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n-\n-void\n-arc_print_operand (FILE *file, rtx x, int code)\n-{\n-  switch (code)\n-    {\n-    case '#' :\n-      /* Conditional branches.  For now these are equivalent.  */\n-    case '*' :\n-      /* Unconditional branches.  Output the appropriate delay slot suffix.  */\n-      if (!final_sequence || XVECLEN (final_sequence, 0) == 1)\n-\t{\n-\t  /* There's nothing in the delay slot.  */\n-\t  fputs (\".nd\", file);\n-\t}\n-      else\n-\t{\n-\t  rtx jump = XVECEXP (final_sequence, 0, 0);\n-\t  rtx delay = XVECEXP (final_sequence, 0, 1);\n-\t  if (INSN_ANNULLED_BRANCH_P (jump))\n-\t    fputs (INSN_FROM_TARGET_P (delay) ? \".jd\" : \".nd\", file);\n-\t  else\n-\t    fputs (\".d\", file);\n-\t}\n-      return;\n-    case '?' : /* with leading \".\" */\n-    case '!' : /* without leading \".\" */\n-      /* This insn can be conditionally executed.  See if the ccfsm machinery\n-\t says it should be conditionalized.  */\n-      if (arc_ccfsm_state == 3 || arc_ccfsm_state == 4)\n-\t{\n-\t  /* Is this insn in a delay slot?  */\n-\t  if (final_sequence && XVECLEN (final_sequence, 0) == 2)\n-\t    {\n-\t      rtx insn = XVECEXP (final_sequence, 0, 1);\n-\n-\t      /* If the insn is annulled and is from the target path, we need\n-\t\t to inverse the condition test.  */\n-\t      if (INSN_ANNULLED_BRANCH_P (insn))\n-\t\t{\n-\t\t  if (INSN_FROM_TARGET_P (insn))\n-\t\t    fprintf (file, \"%s%s\",\n-\t\t\t     code == '?' ? \".\" : \"\",\n-\t\t\t     arc_condition_codes[ARC_INVERSE_CONDITION_CODE (arc_ccfsm_current_cc)]);\n-\t\t  else\n-\t\t    fprintf (file, \"%s%s\",\n-\t\t\t     code == '?' ? \".\" : \"\",\n-\t\t\t     arc_condition_codes[arc_ccfsm_current_cc]);\n-\t\t}\n-\t      else\n-\t        {\n-\t\t  /* This insn is executed for either path, so don't\n-\t\t     conditionalize it at all.  */\n-\t\t  ; /* nothing to do */\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      /* This insn isn't in a delay slot.  */\n-\t      fprintf (file, \"%s%s\",\n-\t\t       code == '?' ? \".\" : \"\",\n-\t\t       arc_condition_codes[arc_ccfsm_current_cc]);\n-\t    }\n-\t}\n-      return;\n-    case '~' :\n-      /* Output a nop if we're between a set of the condition codes,\n-\t and a conditional branch.  */\n-      if (last_insn_set_cc_p)\n-\tfputs (\"nop\\n\\t\", file);\n-      return;\n-    case 'd' :\n-      fputs (arc_condition_codes[get_arc_condition_code (x)], file);\n-      return;\n-    case 'D' :\n-      fputs (arc_condition_codes[ARC_INVERSE_CONDITION_CODE\n-\t\t\t\t (get_arc_condition_code (x))],\n-\t     file);\n-      return;\n-    case 'R' :\n-      /* Write second word of DImode or DFmode reference,\n-\t register or memory.  */\n-      if (GET_CODE (x) == REG)\n-\tfputs (reg_names[REGNO (x)+1], file);\n-      else if (GET_CODE (x) == MEM)\n-\t{\n-\t  fputc ('[', file);\n-\t  /* Handle possible auto-increment.  Since it is pre-increment and\n-\t     we have already done it, we can just use an offset of four.  */\n-\t  /* ??? This is taken from rs6000.c I think.  I don't think it is\n-\t     currently necessary, but keep it around.  */\n-\t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n-\t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n-\t    output_address (plus_constant (XEXP (XEXP (x, 0), 0), 4));\n-\t  else\n-\t    output_address (plus_constant (XEXP (x, 0), 4));\n-\t  fputc (']', file);\n-\t}\n-      else\n-\toutput_operand_lossage (\"invalid operand to %%R code\");\n-      return;\n-    case 'S' :\n-      if ((GET_CODE (x) == SYMBOL_REF && SYMBOL_REF_FUNCTION_P (x))\n-\t  || GET_CODE (x) == LABEL_REF)\n-\t{\n-\t  fprintf (file, \"%%st(\");\n-\t  output_addr_const (file, x);\n-\t  fprintf (file, \")\");\n-\t  return;\n-\t}\n-      break;\n-    case 'H' :\n-    case 'L' :\n-      if (GET_CODE (x) == REG)\n-\t{\n-\t  /* L = least significant word, H = most significant word */\n-\t  if ((TARGET_BIG_ENDIAN != 0) ^ (code == 'L'))\n-\t    fputs (reg_names[REGNO (x)], file);\n-\t  else\n-\t    fputs (reg_names[REGNO (x)+1], file);\n-\t}\n-      else if (GET_CODE (x) == CONST_INT\n-\t       || GET_CODE (x) == CONST_DOUBLE)\n-\t{\n-\t  rtx first, second;\n-\n-\t  split_double (x, &first, &second);\n-\t  fprintf (file, \"0x%08lx\",\n-\t\t   (long)(code == 'L' ? INTVAL (first) : INTVAL (second)));\n-\t}\n-      else\n-\toutput_operand_lossage (\"invalid operand to %%H/%%L code\");\n-      return;\n-    case 'A' :\n-      {\n-\tchar str[30];\n-\n-\tgcc_assert (GET_CODE (x) == CONST_DOUBLE\n-\t\t    && GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT);\n-\n-\treal_to_decimal (str, CONST_DOUBLE_REAL_VALUE (x), sizeof (str), 0, 1);\n-\tfprintf (file, \"%s\", str);\n-\treturn;\n-      }\n-    case 'U' :\n-      /* Output a load/store with update indicator if appropriate.  */\n-      if (GET_CODE (x) == MEM)\n-\t{\n-\t  if (GET_CODE (XEXP (x, 0)) == PRE_INC\n-\t      || GET_CODE (XEXP (x, 0)) == PRE_DEC)\n-\t    fputs (\".a\", file);\n-\t}\n-      else\n-\toutput_operand_lossage (\"invalid operand to %%U code\");\n-      return;\n-    case 'V' :\n-      /* Output cache bypass indicator for a load/store insn.  Volatile memory\n-\t refs are defined to use the cache bypass mechanism.  */\n-      if (GET_CODE (x) == MEM)\n-\t{\n-\t  if (MEM_VOLATILE_P (x))\n-\t    fputs (\".di\", file);\n-\t}\n-      else\n-\toutput_operand_lossage (\"invalid operand to %%V code\");\n-      return;\n-    case 0 :\n-      /* Do nothing special.  */\n-      break;\n-    default :\n-      /* Unknown flag.  */\n-      output_operand_lossage (\"invalid operand output code\");\n-    }\n-\n-  switch (GET_CODE (x))\n-    {\n-    case REG :\n-      fputs (reg_names[REGNO (x)], file);\n-      break;\n-    case MEM :\n-      fputc ('[', file);\n-      if (GET_CODE (XEXP (x, 0)) == PRE_INC)\n-\toutput_address (plus_constant (XEXP (XEXP (x, 0), 0),\n-\t\t\t\t       GET_MODE_SIZE (GET_MODE (x))));\n-      else if (GET_CODE (XEXP (x, 0)) == PRE_DEC)\n-\toutput_address (plus_constant (XEXP (XEXP (x, 0), 0),\n-\t\t\t\t       - GET_MODE_SIZE (GET_MODE (x))));\n-      else\n-\toutput_address (XEXP (x, 0));\n-      fputc (']', file);\n-      break;\n-    case CONST_DOUBLE :\n-      /* We handle SFmode constants here as output_addr_const doesn't.  */\n-      if (GET_MODE (x) == SFmode)\n-\t{\n-\t  REAL_VALUE_TYPE d;\n-\t  long l;\n-\n-\t  REAL_VALUE_FROM_CONST_DOUBLE (d, x);\n-\t  REAL_VALUE_TO_TARGET_SINGLE (d, l);\n-\t  fprintf (file, \"0x%08lx\", l);\n-\t  break;\n-\t}\n-      /* Fall through.  Let output_addr_const deal with it.  */\n-    default :\n-      output_addr_const (file, x);\n-      break;\n-    }\n-}\n-\n-/* Print a memory address as an operand to reference that memory location.  */\n-\n-void\n-arc_print_operand_address (FILE *file, rtx addr)\n-{\n-  register rtx base, index = 0;\n-  int offset = 0;\n-\n-  switch (GET_CODE (addr))\n-    {\n-    case REG :\n-      fputs (reg_names[REGNO (addr)], file);\n-      break;\n-    case SYMBOL_REF :\n-      if (/*???*/ 0 && SYMBOL_REF_FUNCTION_P (addr))\n-\t{\n-\t  fprintf (file, \"%%st(\");\n-\t  output_addr_const (file, addr);\n-\t  fprintf (file, \")\");\n-\t}\n-      else\n-\toutput_addr_const (file, addr);\n-      break;\n-    case PLUS :\n-      if (GET_CODE (XEXP (addr, 0)) == CONST_INT)\n-\toffset = INTVAL (XEXP (addr, 0)), base = XEXP (addr, 1);\n-      else if (GET_CODE (XEXP (addr, 1)) == CONST_INT)\n-\toffset = INTVAL (XEXP (addr, 1)), base = XEXP (addr, 0);\n-      else\n-\tbase = XEXP (addr, 0), index = XEXP (addr, 1);\n-      gcc_assert (GET_CODE (base) == REG);\n-      fputs (reg_names[REGNO (base)], file);\n-      if (index == 0)\n-\t{\n-\t  if (offset != 0)\n-\t    fprintf (file, \",%d\", offset);\n-\t}\n-      else\n-\t{\n-\t  switch (GET_CODE (index))\n-\t    {\n-\t    case REG:\n-\t      fprintf (file, \",%s\", reg_names[REGNO (index)]);\n-\t      break;\n-\t    case SYMBOL_REF:\n-\t      fputc (',', file), output_addr_const (file, index);\n-\t      break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t}\n-      break;\n-    case PRE_INC :\n-    case PRE_DEC :\n-      /* We shouldn't get here as we've lost the mode of the memory object\n-\t (which says how much to inc/dec by.  */\n-      gcc_unreachable ();\n-      break;\n-    default :\n-      output_addr_const (file, addr);\n-      break;\n-    }\n-}\n-\n-/* Update compare/branch separation marker.  */\n-\n-static void\n-record_cc_ref (rtx insn)\n-{\n-  last_insn_set_cc_p = current_insn_set_cc_p;\n-\n-  switch (get_attr_cond (insn))\n-    {\n-    case COND_SET :\n-    case COND_SET_ZN :\n-    case COND_SET_ZNC :\n-      if (get_attr_length (insn) == 1)\n-\tcurrent_insn_set_cc_p = 1;\n-      else\n-\tcurrent_insn_set_cc_p = 0;\n-      break;\n-    default :\n-      current_insn_set_cc_p = 0;\n-      break;\n-    }\n-}\n-\f\n-/* Conditional execution support.\n-\n-   This is based on the ARM port but for now is much simpler.\n-\n-   A finite state machine takes care of noticing whether or not instructions\n-   can be conditionally executed, and thus decrease execution time and code\n-   size by deleting branch instructions.  The fsm is controlled by\n-   final_prescan_insn, and controls the actions of PRINT_OPERAND.  The patterns\n-   in the .md file for the branch insns also have a hand in this.  */\n-\n-/* The state of the fsm controlling condition codes are:\n-   0: normal, do nothing special\n-   1: don't output this insn\n-   2: don't output this insn\n-   3: make insns conditional\n-   4: make insns conditional\n-\n-   State transitions (state->state by whom, under what condition):\n-   0 -> 1 final_prescan_insn, if insn is conditional branch\n-   0 -> 2 final_prescan_insn, if the `target' is an unconditional branch\n-   1 -> 3 branch patterns, after having not output the conditional branch\n-   2 -> 4 branch patterns, after having not output the conditional branch\n-   3 -> 0 (*targetm.asm_out.internal_label), if the `target' label is reached\n-          (the target label has CODE_LABEL_NUMBER equal to\n-\t  arc_ccfsm_target_label).\n-   4 -> 0 final_prescan_insn, if `target' unconditional branch is reached\n-\n-   If the jump clobbers the conditions then we use states 2 and 4.\n-\n-   A similar thing can be done with conditional return insns.\n-\n-   We also handle separating branches from sets of the condition code.\n-   This is done here because knowledge of the ccfsm state is required,\n-   we may not be outputting the branch.  */\n-\n-void\n-arc_final_prescan_insn (rtx insn,\n-                        rtx *opvec ATTRIBUTE_UNUSED,\n-                        int noperands ATTRIBUTE_UNUSED)\n-{\n-  /* BODY will hold the body of INSN.  */\n-  register rtx body = PATTERN (insn);\n-\n-  /* This will be 1 if trying to repeat the trick (i.e.: do the `else' part of\n-     an if/then/else), and things need to be reversed.  */\n-  int reverse = 0;\n-\n-  /* If we start with a return insn, we only succeed if we find another one.  */\n-  int seeking_return = 0;\n-  \n-  /* START_INSN will hold the insn from where we start looking.  This is the\n-     first insn after the following code_label if REVERSE is true.  */\n-  rtx start_insn = insn;\n-\n-  /* Update compare/branch separation marker.  */\n-  record_cc_ref (insn);\n-\n-  /* Allow -mdebug-ccfsm to turn this off so we can see how well it does.\n-     We can't do this in macro FINAL_PRESCAN_INSN because its called from\n-     final_scan_insn which has `optimize' as a local.  */\n-  if (optimize < 2 || TARGET_NO_COND_EXEC)\n-    return;\n-\n-  /* If in state 4, check if the target branch is reached, in order to\n-     change back to state 0.  */\n-  if (arc_ccfsm_state == 4)\n-    {\n-      if (insn == arc_ccfsm_target_insn)\n-\t{\n-\t  arc_ccfsm_target_insn = NULL;\n-\t  arc_ccfsm_state = 0;\n-\t}\n-      return;\n-    }\n-\n-  /* If in state 3, it is possible to repeat the trick, if this insn is an\n-     unconditional branch to a label, and immediately following this branch\n-     is the previous target label which is only used once, and the label this\n-     branch jumps to is not too far off.  Or in other words \"we've done the\n-     `then' part, see if we can do the `else' part.\"  */\n-  if (arc_ccfsm_state == 3)\n-    {\n-      if (simplejump_p (insn))\n-\t{\n-\t  start_insn = next_nonnote_insn (start_insn);\n-\t  if (GET_CODE (start_insn) == BARRIER)\n-\t    {\n-\t      /* ??? Isn't this always a barrier?  */\n-\t      start_insn = next_nonnote_insn (start_insn);\n-\t    }\n-\t  if (GET_CODE (start_insn) == CODE_LABEL\n-\t      && CODE_LABEL_NUMBER (start_insn) == arc_ccfsm_target_label\n-\t      && LABEL_NUSES (start_insn) == 1)\n-\t    reverse = TRUE;\n-\t  else\n-\t    return;\n-\t}\n-      else if (GET_CODE (body) == RETURN)\n-        {\n-\t  start_insn = next_nonnote_insn (start_insn);\n-\t  if (GET_CODE (start_insn) == BARRIER)\n-\t    start_insn = next_nonnote_insn (start_insn);\n-\t  if (GET_CODE (start_insn) == CODE_LABEL\n-\t      && CODE_LABEL_NUMBER (start_insn) == arc_ccfsm_target_label\n-\t      && LABEL_NUSES (start_insn) == 1)\n-\t    {\n-\t      reverse = TRUE;\n-\t      seeking_return = 1;\n-\t    }\n-\t  else\n-\t    return;\n-        }\n-      else\n-\treturn;\n-    }\n-\n-  if (GET_CODE (insn) != JUMP_INSN)\n-    return;\n-\n-  /* This jump might be paralleled with a clobber of the condition codes,\n-     the jump should always come first.  */\n-  if (GET_CODE (body) == PARALLEL && XVECLEN (body, 0) > 0)\n-    body = XVECEXP (body, 0, 0);\n-\n-  if (reverse\n-      || (GET_CODE (body) == SET && GET_CODE (SET_DEST (body)) == PC\n-\t  && GET_CODE (SET_SRC (body)) == IF_THEN_ELSE))\n-    {\n-      int insns_skipped = 0, fail = FALSE, succeed = FALSE;\n-      /* Flag which part of the IF_THEN_ELSE is the LABEL_REF.  */\n-      int then_not_else = TRUE;\n-      /* Nonzero if next insn must be the target label.  */\n-      int next_must_be_target_label_p;\n-      rtx this_insn = start_insn, label = 0;\n-\n-      /* Register the insn jumped to.  */\n-      if (reverse)\n-        {\n-\t  if (!seeking_return)\n-\t    label = XEXP (SET_SRC (body), 0);\n-        }\n-      else if (GET_CODE (XEXP (SET_SRC (body), 1)) == LABEL_REF)\n-\tlabel = XEXP (XEXP (SET_SRC (body), 1), 0);\n-      else if (GET_CODE (XEXP (SET_SRC (body), 2)) == LABEL_REF)\n-\t{\n-\t  label = XEXP (XEXP (SET_SRC (body), 2), 0);\n-\t  then_not_else = FALSE;\n-\t}\n-      else if (GET_CODE (XEXP (SET_SRC (body), 1)) == RETURN)\n-\tseeking_return = 1;\n-      else if (GET_CODE (XEXP (SET_SRC (body), 2)) == RETURN)\n-        {\n-\t  seeking_return = 1;\n-\t  then_not_else = FALSE;\n-        }\n-      else\n-\tgcc_unreachable ();\n-\n-      /* See how many insns this branch skips, and what kind of insns.  If all\n-\t insns are okay, and the label or unconditional branch to the same\n-\t label is not too far away, succeed.  */\n-      for (insns_skipped = 0, next_must_be_target_label_p = FALSE;\n-\t   !fail && !succeed && insns_skipped < MAX_INSNS_SKIPPED;\n-\t   insns_skipped++)\n-\t{\n-\t  rtx scanbody;\n-\n-\t  this_insn = next_nonnote_insn (this_insn);\n-\t  if (!this_insn)\n-\t    break;\n-\n-\t  if (next_must_be_target_label_p)\n-\t    {\n-\t      if (GET_CODE (this_insn) == BARRIER)\n-\t\tcontinue;\n-\t      if (GET_CODE (this_insn) == CODE_LABEL\n-\t\t  && this_insn == label)\n-\t\t{\n-\t\t  arc_ccfsm_state = 1;\n-\t\t  succeed = TRUE;\n-\t\t}\n-\t      else\n-\t\tfail = TRUE;\n-\t      break;\n-\t    }\n-\n-\t  scanbody = PATTERN (this_insn);\n-\n-\t  switch (GET_CODE (this_insn))\n-\t    {\n-\t    case CODE_LABEL:\n-\t      /* Succeed if it is the target label, otherwise fail since\n-\t\t control falls in from somewhere else.  */\n-\t      if (this_insn == label)\n-\t\t{\n-\t\t  arc_ccfsm_state = 1;\n-\t\t  succeed = TRUE;\n-\t\t}\n-\t      else\n-\t\tfail = TRUE;\n-\t      break;\n-\n-\t    case BARRIER:\n-\t      /* Succeed if the following insn is the target label.\n-\t\t Otherwise fail.  \n-\t\t If return insns are used then the last insn in a function \n-\t\t will be a barrier.  */\n-\t      next_must_be_target_label_p = TRUE;\n-\t      break;\n-\n-\t    case CALL_INSN:\n-\t      /* Can handle a call insn if there are no insns after it.\n-\t\t IE: The next \"insn\" is the target label.  We don't have to\n-\t\t worry about delay slots as such insns are SEQUENCE's inside\n-\t\t INSN's.  ??? It is possible to handle such insns though.  */\n-\t      if (get_attr_cond (this_insn) == COND_CANUSE)\n-\t\tnext_must_be_target_label_p = TRUE;\n-\t      else\n-\t\tfail = TRUE;\n-\t      break;\n-\n-\t    case JUMP_INSN:\n-      \t      /* If this is an unconditional branch to the same label, succeed.\n-\t\t If it is to another label, do nothing.  If it is conditional,\n-\t\t fail.  */\n-\t      /* ??? Probably, the test for the SET and the PC are unnecessary.  */\n-\n-\t      if (GET_CODE (scanbody) == SET\n-\t\t  && GET_CODE (SET_DEST (scanbody)) == PC)\n-\t\t{\n-\t\t  if (GET_CODE (SET_SRC (scanbody)) == LABEL_REF\n-\t\t      && XEXP (SET_SRC (scanbody), 0) == label && !reverse)\n-\t\t    {\n-\t\t      arc_ccfsm_state = 2;\n-\t\t      succeed = TRUE;\n-\t\t    }\n-\t\t  else if (GET_CODE (SET_SRC (scanbody)) == IF_THEN_ELSE)\n-\t\t    fail = TRUE;\n-\t\t}\n-\t      else if (GET_CODE (scanbody) == RETURN\n-\t\t       && seeking_return)\n-\t        {\n-\t\t  arc_ccfsm_state = 2;\n-\t\t  succeed = TRUE;\n-\t        }\n-\t      else if (GET_CODE (scanbody) == PARALLEL)\n-\t        {\n-\t\t  if (get_attr_cond (this_insn) != COND_CANUSE)\n-\t\t    fail = TRUE;\n-\t\t}\n-\t      break;\n-\n-\t    case INSN:\n-\t      /* We can only do this with insns that can use the condition\n-\t\t codes (and don't set them).  */\n-\t      if (GET_CODE (scanbody) == SET\n-\t\t  || GET_CODE (scanbody) == PARALLEL)\n-\t\t{\n-\t\t  if (get_attr_cond (this_insn) != COND_CANUSE)\n-\t\t    fail = TRUE;\n-\t\t}\n-\t      /* We can't handle other insns like sequences.  */\n-\t      else\n-\t\tfail = TRUE;\n-\t      break;\n-\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-\n-      if (succeed)\n-\t{\n-\t  if ((!seeking_return) && (arc_ccfsm_state == 1 || reverse))\n-\t    arc_ccfsm_target_label = CODE_LABEL_NUMBER (label);\n-\t  else\n-\t    {\n-\t      gcc_assert (seeking_return || arc_ccfsm_state == 2);\n-\t      while (this_insn && GET_CODE (PATTERN (this_insn)) == USE)\n-\t        {\n-\t\t  this_insn = next_nonnote_insn (this_insn);\n-\t\t  gcc_assert (!this_insn\n-\t\t\t      || (GET_CODE (this_insn) != BARRIER\n-\t\t\t\t  && GET_CODE (this_insn) != CODE_LABEL));\n-\t        }\n-\t      if (!this_insn)\n-\t        {\n-\t\t  /* Oh dear! we ran off the end, give up.  */\n-\t\t  extract_insn_cached (insn);\n-\t\t  arc_ccfsm_state = 0;\n-\t\t  arc_ccfsm_target_insn = NULL;\n-\t\t  return;\n-\t        }\n-\t      arc_ccfsm_target_insn = this_insn;\n-\t    }\n-\n-\t  /* If REVERSE is true, ARM_CURRENT_CC needs to be inverted from\n-\t     what it was.  */\n-\t  if (!reverse)\n-\t    arc_ccfsm_current_cc = get_arc_condition_code (XEXP (SET_SRC (body),\n-\t\t\t\t\t\t\t\t 0));\n-\n-\t  if (reverse || then_not_else)\n-\t    arc_ccfsm_current_cc = ARC_INVERSE_CONDITION_CODE (arc_ccfsm_current_cc);\n-\t}\n-\n-      /* Restore recog_data.  Getting the attributes of other insns can\n-\t destroy this array, but final.c assumes that it remains intact\n-\t across this call.  */\n-      extract_insn_cached (insn);\n-    }\n-}\n-\n-/* Record that we are currently outputting label NUM with prefix PREFIX.\n-   It it's the label we're looking for, reset the ccfsm machinery.\n-\n-   Called from (*targetm.asm_out.internal_label).  */\n-\n-void\n-arc_ccfsm_at_label (const char *prefix, int num)\n-{\n-  if (arc_ccfsm_state == 3 && arc_ccfsm_target_label == num\n-      && !strcmp (prefix, \"L\"))\n-    {\n-      arc_ccfsm_state = 0;\n-      arc_ccfsm_target_insn = NULL_RTX;\n-    }\n-}\n-\n-/* See if the current insn, which is a conditional branch, is to be\n-   deleted.  */\n-\n-int\n-arc_ccfsm_branch_deleted_p (void)\n-{\n-  if (arc_ccfsm_state == 1 || arc_ccfsm_state == 2)\n-    return 1;\n-  return 0;\n-}\n-\n-/* Record a branch isn't output because subsequent insns can be\n-   conditionalized.  */\n-\n-void\n-arc_ccfsm_record_branch_deleted (void)\n-{\n-  /* Indicate we're conditionalizing insns now.  */\n-  arc_ccfsm_state += 2;\n-\n-  /* If the next insn is a subroutine call, we still need a nop between the\n-     cc setter and user.  We need to undo the effect of calling record_cc_ref\n-     for the just deleted branch.  */\n-  current_insn_set_cc_p = last_insn_set_cc_p;\n-}\n-\f\n-static void\n-arc_va_start (tree valist, rtx nextarg)\n-{\n-  /* See arc_setup_incoming_varargs for reasons for this oddity.  */\n-  if (crtl->args.info < 8\n-      && (crtl->args.info & 1))\n-    nextarg = plus_constant (nextarg, UNITS_PER_WORD);\n-\n-  std_expand_builtin_va_start (valist, nextarg);\n-}\n-\n-/* This is how to output a definition of an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.  */\n-\n-static void\n-arc_internal_label (FILE *stream, const char *prefix, unsigned long labelno)\n-{\n-  arc_ccfsm_at_label (prefix, labelno);\n-  default_internal_label (stream, prefix, labelno);\n-}\n-\n-/* Worker function for TARGET_ASM_EXTERNAL_LIBCALL.  */\n-\n-static void\n-arc_external_libcall (rtx fun ATTRIBUTE_UNUSED)\n-{\n-#if 0\n-/* On the ARC we want to have libgcc's for multiple cpus in one binary.\n-   We can't use `assemble_name' here as that will call ASM_OUTPUT_LABELREF\n-   and we'll get another suffix added on if -mmangle-cpu.  */\n-  if (TARGET_MANGLE_CPU_LIBGCC)\n-    {\n-      fprintf (FILE, \"\\t.rename\\t_%s, _%s%s\\n\",\n-\t       XSTR (SYMREF, 0), XSTR (SYMREF, 0),\n-\t       arc_mangle_suffix);\n-    }\n-#endif\n-}\n-\n-/* Worker function for TARGET_RETURN_IN_MEMORY.  */\n-\n-static bool\n-arc_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n-{\n-  if (AGGREGATE_TYPE_P (type))\n-    return true;\n-  else\n-    {\n-      HOST_WIDE_INT size = int_size_in_bytes (type);\n-      return (size == -1 || size > 8);\n-    }\n-}\n-\n-/* For ARC, All aggregates and arguments greater than 8 bytes are\n-   passed by reference.  */\n-\n-static bool\n-arc_pass_by_reference (CUMULATIVE_ARGS *ca ATTRIBUTE_UNUSED,\n-\t\t       enum machine_mode mode, const_tree type,\n-\t\t       bool named ATTRIBUTE_UNUSED)\n-{\n-  unsigned HOST_WIDE_INT size;\n-\n-  if (type)\n-    {\n-      if (AGGREGATE_TYPE_P (type))\n-\treturn true;\n-      size = int_size_in_bytes (type);\n-    }\n-  else\n-    size = GET_MODE_SIZE (mode);\n-\n-  return size > 8;\n-}\n-\n-/* Round SIZE up to a word boundary.  */\n-#define ROUND_ADVANCE(SIZE) \\\n-(((SIZE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* Round arg MODE/TYPE up to the next word boundary.  */\n-#define ROUND_ADVANCE_ARG(MODE, TYPE) \\\n-((MODE) == BLKmode\t\t\t\t\\\n- ? ROUND_ADVANCE (int_size_in_bytes (TYPE))\t\\\n- : ROUND_ADVANCE (GET_MODE_SIZE (MODE)))\n-\n-/* Round CUM up to the necessary point for argument MODE/TYPE.  */\n-#define ROUND_ADVANCE_CUM(CUM, MODE, TYPE) \\\n-((((MODE) == BLKmode ? TYPE_ALIGN (TYPE) : GET_MODE_BITSIZE (MODE)) \\\n-  > BITS_PER_WORD)\t\\\n- ? (((CUM) + 1) & ~1)\t\\\n- : (CUM))\n-\n-/* Return boolean indicating arg of type TYPE and mode MODE will be passed in\n-   a reg.  This includes arguments that have to be passed by reference as the\n-   pointer to them is passed in a reg if one is available (and that is what\n-   we're given).  */\n-#define PASS_IN_REG_P(CUM, MODE, TYPE) \\\n-((CUM) < MAX_ARC_PARM_REGS\t\t\t\t\t\t\\\n- && ((ROUND_ADVANCE_CUM ((CUM), (MODE), (TYPE))\t\t\t\t\\\n-      + ROUND_ADVANCE_ARG ((MODE), (TYPE))\t\t\t\t\\\n-      <= MAX_ARC_PARM_REGS)))\n-\n-/* Determine where to put an argument to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n-/* On the ARC the first MAX_ARC_PARM_REGS args are normally in registers\n-   and the rest are pushed.  */\n-\n-static rtx\n-arc_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-\t\t  const_tree type, bool named ATTRIBUTE_UNUSED)\n-{\n-  return (PASS_IN_REG_P (*cum, mode, type)\n-\t  ? gen_rtx_REG (mode, ROUND_ADVANCE_CUM (*cum, mode, type))\n-\t  : NULL_RTX);\n-}\n-\n-/* Worker function for TARGET_FUNCTION_ARG_ADVANCE.  */\n-\n-static void\n-arc_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n-\t\t\t  const_tree type, bool named ATTRIBUTE_UNUSED)\n-{\n-  *cum = (ROUND_ADVANCE_CUM (*cum, mode, type)\n-\t  + ROUND_ADVANCE_ARG (mode, type));\n-}\n-\n-/* Worker function for TARGET_FUNCTION_ARG_BOUNDARY.  */\n-\n-static unsigned int\n-arc_function_arg_boundary (enum machine_mode mode, const_tree type)\n-{\n-  return (type != NULL_TREE\n-\t  ? TYPE_ALIGN (type)\n-\t  : (GET_MODE_BITSIZE (mode) <= PARM_BOUNDARY\n-\t     ? PARM_BOUNDARY\n-\t     : 2 * PARM_BOUNDARY));\n-}\n-\n-/* Trampolines.  */\n-/* ??? This doesn't work yet because GCC will use as the address of a nested\n-   function the address of the trampoline.  We need to use that address\n-   right shifted by 2.  It looks like we'll need PSImode after all. :-( \n-\n-   ??? The above comment sounds like it's doable via\n-   TARGET_TRAMPOLINE_ADJUST_ADDRESS; no PSImode needed.\n-\n-   On the ARC, the trampoline is quite simple as we have 32-bit immediate\n-   constants.\n-\n-\tmov r24,STATIC\n-\tj.nd FUNCTION\n-*/\n-\n-static void\n-arc_trampoline_init (rtx m_tramp, tree fndecl, rtx chain_value)\n-{\n-  rtx fnaddr = XEXP (DECL_RTL (fndecl), 0);\n-  rtx mem;\n-\n-  mem = adjust_address (m_tramp, SImode, 0);\n-  emit_move_insn (mem, GEN_INT (0x631f7c00));\n-\n-  mem = adjust_address (m_tramp, SImode, 4);\n-  emit_move_insn (mem, chain_value);\n-\n-  mem = adjust_address (m_tramp, SImode, 8);\n-  emit_move_insn (mem, GEN_INT (0x381f0000));\n-\n-  mem = adjust_address (m_tramp, SImode, 12);\n-  emit_move_insn (mem, fnaddr);\n-\n-  emit_insn (gen_flush_icache (m_tramp));\n-}\n-\n-/* Worker function for TARGET_CONDITIONAL_REGISTER_USAGE.  */\n-\n-static void\n-arc_conditional_register_usage (void)\n-{\n-  if (PIC_OFFSET_TABLE_REGNUM != INVALID_REGNUM)\n-    {\n-      fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\n-      call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\n-    }\n-}\n-"}, {"sha": "0f2b99c199c2eeeb5aa5f434abc25bfe9b9dd212", "filename": "gcc/config/arc/arc.h", "status": "removed", "additions": 0, "deletions": 935, "changes": 935, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,935 +0,0 @@\n-/* Definitions of target machine for GNU compiler, Argonaut ARC cpu.\n-   Copyright (C) 1994, 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2004, 2005,\n-   2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* ??? This is an old port, and is undoubtedly suffering from bit rot.  */\n-\n-/* Things to do:\n-\n-   - incscc, decscc?\n-   - print active compiler options in assembler output\n-*/\n-\n-\n-#undef ASM_SPEC\n-#undef LINK_SPEC\n-#undef LIB_SPEC\n-#undef STARTFILE_SPEC\n-#undef ENDFILE_SPEC\n-#undef SIZE_TYPE\n-#undef PTRDIFF_TYPE\n-#undef WCHAR_TYPE\n-#undef WCHAR_TYPE_SIZE\n-#undef ASM_OUTPUT_LABELREF\n-\f\n-/* Print subsidiary information on the compiler version in use.  */\n-#define TARGET_VERSION fprintf (stderr, \" (arc)\")\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-#define TARGET_CPU_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-\tbuiltin_define (\"__arc__\");\t\t\\\n-\tif (TARGET_BIG_ENDIAN)\t\t\t\\\n-\t  builtin_define (\"__big_endian__\");\t\\\n-\tif (arc_cpu_type == 0)\t\t\t\\\n-\t  builtin_define (\"__base__\");\t\t\\\n-\tbuiltin_assert (\"cpu=arc\");\t\t\\\n-\tbuiltin_assert (\"machine=arc\");\t\t\\\n-    } while (0)\n-\n-/* Pass -mmangle-cpu if we get -mcpu=*.\n-   Doing it this way lets one have it on as default with -mcpu=*,\n-   but also lets one turn it off with -mno-mangle-cpu.  */\n-#define CC1_SPEC \"\\\n-%{mcpu=*:-mmangle-cpu} \\\n-%{EB:%{EL:%emay not use both -EB and -EL}} \\\n-%{EB:-mbig-endian} %{EL:-mlittle-endian} \\\n-\"\n-\n-#define ASM_SPEC \"%{EB} %{EL}\"\n-\n-#define LINK_SPEC \"%{v} %{EB} %{EL}\"\n-\n-#define LIB_SPEC \"-lc\"\n-\n-#define STARTFILE_SPEC \"%{!shared:crt0.o%s} crtinit.o%s\"\n-\n-#define ENDFILE_SPEC \"crtfini.o%s\"\n-\f\n-/* Instruction set characteristics.\n-   These are internal macros, set by the appropriate -mcpu= option.  */\n-\n-/* Nonzero means the cpu has a barrel shifter.  */\n-#define TARGET_SHIFTER 0\n-\n-/* Which cpu we're compiling for.  */\n-extern int arc_cpu_type;\n-\n-/* Check if CPU is an extension and set `arc_cpu_type' and `arc_mangle_cpu'\n-   appropriately.  The result should be nonzero if the cpu is recognized,\n-   otherwise zero.  This is intended to be redefined in a cover file.\n-   This is used by arc_handle_option.  */\n-#define ARC_EXTENSION_CPU(cpu) 0\n-\n-\f\n-/* Target machine storage layout.  */\n-\n-/* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields.  */\n-#define BITS_BIG_ENDIAN 1\n-\n-/* Define this if most significant byte of a word is the lowest numbered.  */\n-#define BYTES_BIG_ENDIAN (TARGET_BIG_ENDIAN)\n-\n-/* Define this if most significant word of a multiword number is the lowest\n-   numbered.  */\n-#define WORDS_BIG_ENDIAN (TARGET_BIG_ENDIAN)\n-\n-/* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD 4\n-\n-/* Define this macro if it is advisable to hold scalars in registers\n-   in a wider mode than that declared by the program.  In such cases, \n-   the value is constrained to be within the bounds of the declared\n-   type, but kept valid in the wider mode.  The signedness of the\n-   extension may differ from that of the type.  */\n-#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE) \\\n-if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n-    && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\t\\\n-{\t\t\t\t\t\t\\\n-  (MODE) = SImode;\t\t\t\t\\\n-}\n-\n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY 32\n-\n-/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY 64\n-\n-/* ALIGN FRAMES on word boundaries */\n-#define ARC_STACK_ALIGN(LOC) (((LOC)+7) & ~7)\n-\n-/* Allocation boundary (in *bits*) for the code of a function.  */\n-#define FUNCTION_BOUNDARY 32\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY 32\n-\n-/* Every structure's size must be a multiple of this.  */\n-#define STRUCTURE_SIZE_BOUNDARY 8\n-\n-/* A bit-field declared as `int' forces `int' alignment for the struct.  */\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-\n-/* No data type wants to be aligned rounder than this.  */\n-/* This is bigger than currently necessary for the ARC.  If 8 byte floats are\n-   ever added it's not clear whether they'll need such alignment or not.  For\n-   now we assume they will.  We can always relax it if necessary but the\n-   reverse isn't true.  */\n-#define BIGGEST_ALIGNMENT 64\n-\n-/* The best alignment to use in cases where we have a choice.  */\n-#define FASTEST_ALIGNMENT 32\n-\n-/* Make strings word-aligned so strcpy from constants will be faster.  */\n-#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n-  ((TREE_CODE (EXP) == STRING_CST\t\\\n-    && (ALIGN) < FASTEST_ALIGNMENT)\t\\\n-   ? FASTEST_ALIGNMENT : (ALIGN))\n-\n-/* Make arrays of chars word-aligned for the same reasons.  */\n-#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n-  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n-   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n-   && (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))\n-\n-/* Set this nonzero if move instructions will actually fail to work\n-   when given unaligned data.  */\n-/* On the ARC the lower address bits are masked to 0 as necessary.  The chip\n-   won't croak when given an unaligned address, but the insn will still fail\n-   to produce the correct result.  */\n-#define STRICT_ALIGNMENT 1\n-\f\n-/* Layout of source language data types.  */\n-\n-#define SHORT_TYPE_SIZE\t\t16\n-#define INT_TYPE_SIZE\t\t32\n-#define LONG_TYPE_SIZE\t\t32\n-#define LONG_LONG_TYPE_SIZE\t64\n-#define FLOAT_TYPE_SIZE\t\t32\n-#define DOUBLE_TYPE_SIZE\t64\n-#define LONG_DOUBLE_TYPE_SIZE\t64\n-\n-/* Define this as 1 if `char' should by default be signed; else as 0.  */\n-#define DEFAULT_SIGNED_CHAR 1\n-\n-#define SIZE_TYPE \"long unsigned int\"\n-#define PTRDIFF_TYPE \"long int\"\n-#define WCHAR_TYPE \"short unsigned int\"\n-#define WCHAR_TYPE_SIZE 16\n-\f\n-/* Standard register usage.  */\n-\n-/* Number of actual hardware registers.\n-   The hardware registers are assigned numbers for the compiler\n-   from 0 to just below FIRST_PSEUDO_REGISTER.\n-   All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.  */\n-/* Registers 61, 62, and 63 are not really registers and we needn't treat\n-   them as such.  We still need a register for the condition code.  */\n-#define FIRST_PSEUDO_REGISTER 62\n-\n-/* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator.\n-\n-   0-28  - general purpose registers\n-   29    - ilink1 (interrupt link register)\n-   30    - ilink2 (interrupt link register)\n-   31    - blink (branch link register)\n-   32-59 - reserved for extensions\n-   60    - LP_COUNT\n-   61    - condition code\n-\n-   For doc purposes:\n-   61    - short immediate data indicator (setting flags)\n-   62    - long immediate data indicator\n-   63    - short immediate data indicator (not setting flags).\n-\n-   The general purpose registers are further broken down into:\n-   0-7   - arguments/results\n-   8-15  - call used\n-   16-23 - call saved\n-   24    - call used, static chain pointer\n-   25    - call used, gptmp\n-   26    - global pointer\n-   27    - frame pointer\n-   28    - stack pointer\n-\n-   By default, the extension registers are not available.  */\n-\n-#define FIXED_REGISTERS \\\n-{ 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  0, 0, 0, 1, 1, 1, 1, 0,\t\\\n-\t\t\t\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1 }\n-\n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like.  */\n-\n-#define CALL_USED_REGISTERS \\\n-{ 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-\t\t\t\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1 }\n-\n-/* If defined, an initializer for a vector of integers, containing the\n-   numbers of hard registers in the order in which GCC should\n-   prefer to use them (from most preferred to least).  */\n-#define REG_ALLOC_ORDER \\\n-{ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1,\t\t\t\\\n-  16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 31,\t\t\t\\\n-  32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\t\\\n-  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,\t\t\\\n-  27, 28, 29, 30 }\n-\n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE) \\\n-((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n-extern const unsigned int arc_hard_regno_mode_ok[];\n-extern unsigned int arc_mode_class[];\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-((arc_hard_regno_mode_ok[REGNO] & arc_mode_class[MODE]) != 0)\n-\n-/* A C expression that is nonzero if it is desirable to choose\n-   register allocation so as to avoid move instructions between a\n-   value of mode MODE1 and a value of mode MODE2.\n-\n-   If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R,\n-   MODE2)' are ever different for any R, then `MODES_TIEABLE_P (MODE1,\n-   MODE2)' must be zero.  */\n-\n-/* Tie QI/HI/SI modes together.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n-(GET_MODE_CLASS (MODE1) == MODE_INT\t\t\\\n- && GET_MODE_CLASS (MODE2) == MODE_INT\t\t\\\n- && GET_MODE_SIZE (MODE1) <= UNITS_PER_WORD\t\\\n- && GET_MODE_SIZE (MODE2) <= UNITS_PER_WORD)\n-\f\n-/* Register classes and constants.  */\n-\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.\n-\n-   It is important that any condition codes have class NO_REGS.\n-   See `register_operand'.  */\n-\n-enum reg_class {\n-  NO_REGS, LPCOUNT_REG, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n-};\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Give names of register classes as strings for dump file.  */\n-#define REG_CLASS_NAMES \\\n-{ \"NO_REGS\", \"LPCOUNT_REG\", \"GENERAL_REGS\", \"ALL_REGS\" }\n-\n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES.  */\n-\n-#define REG_CLASS_CONTENTS \\\n-{ {0, 0}, {0, 0x10000000}, {0xffffffff, 0xfffffff}, \\\n-  {0xffffffff, 0x1fffffff} }\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-extern enum reg_class arc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n-#define REGNO_REG_CLASS(REGNO) \\\n-(arc_regno_reg_class[REGNO])\n-\n-/* The class value for index registers, and the one for base regs.  */\n-#define INDEX_REG_CLASS GENERAL_REGS\n-#define BASE_REG_CLASS GENERAL_REGS\n-\n-/* Get reg_class from a letter such as appears in the machine description.  */\n-#define REG_CLASS_FROM_LETTER(C) \\\n-((C) == 'l' ? LPCOUNT_REG /* ??? needed? */ \\\n- : NO_REGS)\n-\n-/* These assume that REGNO is a hard or pseudo reg number.\n-   They give nonzero only if REGNO is a hard reg of the suitable class\n-   or a pseudo reg currently allocated to a suitable hard reg.\n-   Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n-#define REGNO_OK_FOR_BASE_P(REGNO) \\\n-((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32)\n-#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n-((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32)\n-\n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE) \\\n-((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* The letters I, J, K, L, M, N, O, P in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.  */\n-/* 'I' is used for short immediates (always signed).\n-   'J' is used for long immediates.\n-   'K' is used for any constant up to 64 bits (for 64x32 situations?).  */\n-\n-/* local to this file */\n-#define SMALL_INT(X) ((unsigned) ((X) + 0x100) < 0x200)\n-/* local to this file */\n-#define LARGE_INT(X) \\\n-((X) >= (-(HOST_WIDE_INT) 0x7fffffff - 1) \\\n- && (unsigned HOST_WIDE_INT)(X) <= (unsigned HOST_WIDE_INT) 0xffffffff)\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C) \\\n-((C) == 'I' ? SMALL_INT (VALUE)\t\t\\\n- : (C) == 'J' ? LARGE_INT (VALUE)\t\\\n- : (C) == 'K' ? 1\t\t\t\\\n- : 0)\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.  */\n-/* 'G' is used for integer values for the multiplication insns where the\n-   operands are extended from 4 bytes to 8 bytes.\n-   'H' is used when any 64-bit constant is allowed.  */\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n-((C) == 'G' ? arc_double_limm_p (VALUE) \\\n- : (C) == 'H' ? 1 \\\n- : 0)\n-\n-/* A C expression that defines the optional machine-dependent constraint\n-   letters that can be used to segregate specific types of operands,\n-   usually memory references, for the target machine.  It should return 1 if\n-   VALUE corresponds to the operand type represented by the constraint letter\n-   C.  If C is not defined as an extra constraint, the value returned should\n-   be 0 regardless of VALUE.  */\n-/* ??? This currently isn't used.  Waiting for PIC.  */\n-#if 0\n-#define EXTRA_CONSTRAINT(VALUE, C) \\\n-((C) == 'R' ? (SYMBOL_REF_FUNCTION_P (VALUE) || GET_CODE (VALUE) == LABEL_REF) \\\n- : 0)\n-#endif\n-\f\n-/* Stack layout and stack pointer usage.  */\n-\n-/* Define this macro if pushing a word onto the stack moves the stack\n-   pointer to a smaller address.  */\n-#define STACK_GROWS_DOWNWARD\n-\n-/* Define this to nonzero if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset in the frame.  */\n-#define FRAME_GROWS_DOWNWARD 1\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.  */\n-#define STARTING_FRAME_OFFSET 0\n-\n-/* Offset from the stack pointer register to the first location at which\n-   outgoing arguments are placed.  */\n-#define STACK_POINTER_OFFSET FIRST_PARM_OFFSET (0)\n-\n-/* Offset of first parameter from the argument pointer register value.  */\n-/* 4 bytes for each of previous fp, return address, and previous gp.\n-   4 byte reserved area for future considerations.  */\n-#define FIRST_PARM_OFFSET(FNDECL) 16\n-\n-/* A C expression whose value is RTL representing the address in a\n-   stack frame where the pointer to the caller's frame is stored.\n-   Assume that FRAMEADDR is an RTL expression for the address of the\n-   stack frame itself.\n-\n-   If you don't define this macro, the default is to return the value\n-   of FRAMEADDR--that is, the stack frame address is also the address\n-   of the stack word that points to the previous frame.  */\n-/* ??? unfinished */\n-/*define DYNAMIC_CHAIN_ADDRESS (FRAMEADDR)*/\n-\n-/* A C expression whose value is RTL representing the value of the\n-   return address for the frame COUNT steps up from the current frame.\n-   FRAMEADDR is the frame pointer of the COUNT frame, or the frame\n-   pointer of the COUNT - 1 frame if `RETURN_ADDR_IN_PREVIOUS_FRAME'\n-   is defined.  */\n-/* The current return address is in r31.  The return address of anything\n-   farther back is at [%fp,4].  */\n-#if 0 /* The default value should work.  */\n-#define RETURN_ADDR_RTX(COUNT, FRAME) \\\n-(((COUNT) == -1)\t\t\t\t\t\t\t\\\n- ? gen_rtx_REG (Pmode, 31)\t\t\t\t\t\t\\\n- : copy_to_reg (gen_rtx_MEM (Pmode,\t\t\t\t\t\\\n-\t\t\t     memory_address (Pmode,\t\t\t\\\n-\t\t\t\t\t     plus_constant ((FRAME),\t\\\n-\t\t\t\t\t\t\t    UNITS_PER_WORD)))))\n-#endif\n-\n-/* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM 28\n-\n-/* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM 27\n-\n-/* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM FRAME_POINTER_REGNUM\n-\n-/* Register in which static-chain is passed to a function.  This must\n-   not be a register used by the prologue.  */\n-#define STATIC_CHAIN_REGNUM 24\n-\n-/* C statement to store the difference between the frame pointer\n-   and the stack pointer values immediately after the function prologue.  */\n-#define INITIAL_FRAME_POINTER_OFFSET(VAR) \\\n-((VAR) = arc_compute_frame_size (get_frame_size ()))\n-\f\n-/* Function argument passing.  */\n-\n-/* If defined, the maximum amount of space required for outgoing\n-   arguments will be computed and placed into the variable\n-   `crtl->outgoing_args_size'.  No space will be pushed\n-   onto the stack for each call; instead, the function prologue should\n-   increase the stack frame size by this amount.  */\n-#define ACCUMULATE_OUTGOING_ARGS 1\n-\n-/* Define a data type for recording info about an argument list\n-   during the scan of that argument list.  This data type should\n-   hold all necessary information about the function itself\n-   and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.  */\n-#define CUMULATIVE_ARGS int\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS\n-   for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.  */\n-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n-((CUM) = 0)\n-\n-/* The number of registers used for parameter passing.  Local to this file.  */\n-#define MAX_ARC_PARM_REGS 8\n-\n-/* 1 if N is a possible register number for function argument passing.  */\n-#define FUNCTION_ARG_REGNO_P(N) \\\n-((unsigned) (N) < MAX_ARC_PARM_REGS)\n-\n-\f\n-/* Function results.  */\n-\n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.  */\n-#define FUNCTION_VALUE(VALTYPE, FUNC) gen_rtx_REG (TYPE_MODE (VALTYPE), 0)\n-\n-/* Define how to find the value returned by a library function\n-   assuming the value has mode MODE.  */\n-#define LIBCALL_VALUE(MODE) gen_rtx_REG (MODE, 0)\n-\n-/* 1 if N is a possible register number for a function value\n-   as seen by the caller.  */\n-/* ??? What about r1 in DI/DF values.  */\n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)\n-\n-/* Tell GCC to use TARGET_RETURN_IN_MEMORY.  */\n-#define DEFAULT_PCC_STRUCT_RETURN 0\n-\f\n-/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n-   the stack pointer does not matter.  The value is tested only in\n-   functions that have frame pointers.\n-   No definition is equivalent to always zero.  */\n-#define EXIT_IGNORE_STACK 0\n-\n-/* Epilogue delay slots.  */\n-#define DELAY_SLOTS_FOR_EPILOGUE arc_delay_slots_for_epilogue ()\n-\n-#define ELIGIBLE_FOR_EPILOGUE_DELAY(TRIAL, SLOTS_FILLED) \\\n-arc_eligible_for_epilogue_delay (TRIAL, SLOTS_FILLED)\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-#define FUNCTION_PROFILER(FILE, LABELNO)\n-\f\n-#define TRAMPOLINE_ALIGNMENT 32\n-#define TRAMPOLINE_SIZE 16\n-\f\n-/* Addressing modes, and classification of registers for them.  */\n-\n-/* Maximum number of registers that can appear in a valid memory address.  */\n-/* The `ld' insn allows 2, but the `st' insn only allows 1.  */\n-#define MAX_REGS_PER_ADDRESS 1\n-\n-/* We have pre inc/dec (load/store with update).  */\n-#define HAVE_PRE_INCREMENT 1\n-#define HAVE_PRE_DECREMENT 1\n-\n-/* Recognize any constant value that is a valid address.  */\n-#define CONSTANT_ADDRESS_P(X) \\\n-(GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\\\n- || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST)\n-\n-/* Nonzero if the constant value X is a legitimate general operand.\n-   We can handle any 32- or 64-bit constant.  */\n-/* \"1\" should work since the largest constant should be a 64 bit critter.  */\n-/* ??? Not sure what to do for 64x32 compiler.  */\n-#define LEGITIMATE_CONSTANT_P(X) 1\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X) \\\n-((unsigned) REGNO (X) - 32 >= FIRST_PSEUDO_REGISTER - 32)\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) \\\n-((unsigned) REGNO (X) - 32 >= FIRST_PSEUDO_REGISTER - 32)\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#endif\n-\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.  */\n-/* The `ld' insn allows [reg],[reg+shimm],[reg+limm],[reg+reg],[limm]\n-   but the `st' insn only allows [reg],[reg+shimm],[limm].\n-   The only thing we can do is only allow the most strict case `st' and hope\n-   other parts optimize out the restrictions for `ld'.  */\n-\n-/* local to this file */\n-#define RTX_OK_FOR_BASE_P(X) \\\n-(REG_P (X) && REG_OK_FOR_BASE_P (X))\n-\n-/* local to this file */\n-#define RTX_OK_FOR_INDEX_P(X) \\\n-(0 && /*???*/ REG_P (X) && REG_OK_FOR_INDEX_P (X))\n-\n-/* local to this file */\n-/* ??? Loads can handle any constant, stores can only handle small ones.  */\n-#define RTX_OK_FOR_OFFSET_P(X) \\\n-(GET_CODE (X) == CONST_INT && SMALL_INT (INTVAL (X)))\n-\n-#define LEGITIMATE_OFFSET_ADDRESS_P(MODE, X) \\\n-(GET_CODE (X) == PLUS\t\t\t\t\\\n- && RTX_OK_FOR_BASE_P (XEXP (X, 0))\t\t\\\n- && (RTX_OK_FOR_INDEX_P (XEXP (X, 1))\t\t\\\n-     || RTX_OK_FOR_OFFSET_P (XEXP (X, 1))))\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\\\n-{ if (RTX_OK_FOR_BASE_P (X))\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-  if (LEGITIMATE_OFFSET_ADDRESS_P ((MODE), (X)))\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == CONST_INT && LARGE_INT (INTVAL (X))) \\\n-    goto ADDR;\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == SYMBOL_REF\t\t\t\\\n-\t   || GET_CODE (X) == LABEL_REF\t\t\t\\\n-\t   || GET_CODE (X) == CONST)\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-  if ((GET_CODE (X) == PRE_DEC || GET_CODE (X) == PRE_INC) \\\n-      /* We're restricted here by the `st' insn.  */\t\\\n-      && RTX_OK_FOR_BASE_P (XEXP ((X), 0)))\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\\\n-}\n-\f\n-/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n-   return the mode to be used for the comparison.  */\n-#define SELECT_CC_MODE(OP, X, Y) \\\n-arc_select_cc_mode (OP, X, Y)\n-\n-/* Return nonzero if SELECT_CC_MODE will never return MODE for a\n-   floating point inequality comparison.  */\n-#define REVERSIBLE_CC_MODE(MODE) 1 /*???*/\n-\f\n-/* Costs.  */\n-\n-/* Compute extra cost of moving data between one register class\n-   and another.  */\n-#define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2) 2\n-\n-/* Compute the cost of moving data between registers and memory.  */\n-/* Memory is 3 times as expensive as registers.\n-   ??? Is that the right way to look at it?  */\n-#define MEMORY_MOVE_COST(MODE,CLASS,IN) \\\n-(GET_MODE_SIZE (MODE) <= UNITS_PER_WORD ? 6 : 12)\n-\n-/* The cost of a branch insn.  */\n-/* ??? What's the right value here?  Branches are certainly more\n-   expensive than reg->reg moves.  */\n-#define BRANCH_COST(speed_p, predictable_p) 2\n-\n-/* Nonzero if access to memory by bytes is slow and undesirable.\n-   For RISC chips, it means that access to memory by bytes is no\n-   better than access by words when possible, so grab a whole word\n-   and maybe make use of that.  */\n-#define SLOW_BYTE_ACCESS 1\n-\n-/* Define this macro if it is as good or better to call a constant\n-   function address than to call an address kept in a register.  */\n-/* On the ARC, calling through registers is slow.  */\n-#define NO_FUNCTION_CSE\n-\f\n-/* Section selection.  */\n-/* WARNING: These section names also appear in dwarfout.c.  */\n-\n-/* The names of the text, data, and readonly-data sections are runtime\n-   selectable.  */\n-\n-#define ARC_SECTION_FORMAT\t\t\"\\t.section %s\"\n-#define ARC_DEFAULT_TEXT_SECTION\t\".text\"\n-#define ARC_DEFAULT_DATA_SECTION\t\".data\"\n-#define ARC_DEFAULT_RODATA_SECTION\t\".rodata\"\n-\n-extern const char *arc_text_section, *arc_data_section, *arc_rodata_section;\n-\n-/* initfini.c uses this in an asm.  */\n-#if defined (CRT_INIT) || defined (CRT_FINI)\n-#define TEXT_SECTION_ASM_OP\t\"\\t.section .text\"\n-#else\n-#define TEXT_SECTION_ASM_OP\tarc_text_section\n-#endif\n-#define DATA_SECTION_ASM_OP\tarc_data_section\n-\n-#undef  READONLY_DATA_SECTION_ASM_OP\n-#define READONLY_DATA_SECTION_ASM_OP\tarc_rodata_section\n-\n-#define BSS_SECTION_ASM_OP\t\"\\t.section .bss\"\n-\n-/* Define this macro if jump tables (for tablejump insns) should be\n-   output in the text section, along with the assembler instructions.\n-   Otherwise, the readonly data section is used.\n-   This macro is irrelevant if there is no separate readonly data section.  */\n-/*#define JUMP_TABLES_IN_TEXT_SECTION*/\n-\n-/* For DWARF.  Marginally different than default so output is \"prettier\"\n-   (and consistent with above).  */\n-#define PUSHSECTION_ASM_OP \"\\t.section \"\n-\n-/* Tell crtstuff.c we're using ELF.  */\n-#define OBJECT_FORMAT_ELF\n-\f\n-/* PIC */\n-\n-/* The register number of the register used to address a table of static\n-   data addresses in memory.  In some cases this register is defined by a\n-   processor's ``application binary interface'' (ABI).  When this macro\n-   is defined, RTL is generated for this register once, as with the stack\n-   pointer and frame pointer registers.  If this macro is not defined, it\n-   is up to the machine-dependent files to allocate such a register (if\n-   necessary).  */\n-#define PIC_OFFSET_TABLE_REGNUM  (flag_pic ? 26 : INVALID_REGNUM)\n-\n-/* Define this macro if the register defined by PIC_OFFSET_TABLE_REGNUM is\n-   clobbered by calls.  Do not define this macro if PIC_OFFSET_TABLE_REGNUM\n-   is not defined.  */\n-/* This register is call-saved on the ARC.  */\n-/*#define PIC_OFFSET_TABLE_REG_CALL_CLOBBERED*/\n-\n-/* A C expression that is nonzero if X is a legitimate immediate\n-   operand on the target machine when generating position independent code.\n-   You can assume that X satisfies CONSTANT_P, so you need not\n-   check this.  You can also assume `flag_pic' is true, so you need not\n-   check it either.  You need not define this macro if all constants\n-   (including SYMBOL_REF) can be immediate operands when generating\n-   position independent code.  */\n-/*#define LEGITIMATE_PIC_OPERAND_P(X)*/\n-\f\n-/* Control the assembler format that we output.  */\n-\n-/* A C string constant describing how to begin a comment in the target\n-   assembler language.  The compiler assumes that the comment will\n-   end at the end of the line.  */\n-#define ASM_COMMENT_START \";\"\n-\n-/* Output to assembler file text saying following lines\n-   may contain character constants, extra white space, comments, etc.  */\n-#define ASM_APP_ON \"\"\n-\n-/* Output to assembler file text saying following lines\n-   no longer contain unusual constructs.  */\n-#define ASM_APP_OFF \"\"\n-\n-/* Globalizing directive for a label.  */\n-#define GLOBAL_ASM_OP \"\\t.global\\t\"\n-\n-/* This is how to output a reference to a user-level label named NAME.\n-   `assemble_name' uses this.  */\n-/* We mangle all user labels to provide protection from linking code\n-   compiled for different cpus.  */\n-/* We work around a dwarfout.c deficiency by watching for labels from it and\n-   not adding the '_' prefix nor the cpu suffix.  There is a comment in\n-   dwarfout.c that says it should be using (*targetm.asm_out.internal_label).  */\n-extern const char *arc_mangle_cpu;\n-#define ASM_OUTPUT_LABELREF(FILE, NAME) \\\n-do {\t\t\t\t\t\t\t\\\n-  if ((NAME)[0] == '.' && (NAME)[1] == 'L')\t\t\\\n-    fprintf (FILE, \"%s\", NAME);\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      fputc ('_', FILE);\t\t\t\t\\\n-      if (TARGET_MANGLE_CPU && arc_mangle_cpu != NULL)\t\\\n-\tfprintf (FILE, \"%s_\", arc_mangle_cpu);\t\t\\\n-      fprintf (FILE, \"%s\", NAME);\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-/* Assembler pseudo-op to equate one value with another.  */\n-/* ??? This is needed because dwarfout.c provides a default definition too\n-   late for defaults.h (which contains the default definition of ASM_OUTPUT_DEF\n-   that we use).  */\n-#define SET_ASM_OP \"\\t.set\\t\"\n-\n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number (see above).  */\n-#define REGISTER_NAMES \\\n-{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",\t\t\\\n- \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\t\\\n- \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",\t\\\n- \"r24\", \"r25\", \"r26\", \"fp\", \"sp\", \"ilink1\", \"ilink2\", \"blink\",\t\\\n- \"r32\", \"r33\", \"r34\", \"r35\", \"r36\", \"r37\", \"r38\", \"r39\",\t\\\n- \"r40\", \"r41\", \"r42\", \"r43\", \"r44\", \"r45\", \"r46\", \"r47\",\t\\\n- \"r48\", \"r49\", \"r50\", \"r51\", \"r52\", \"r53\", \"r54\", \"r55\",\t\\\n- \"r56\", \"r57\", \"r58\", \"r59\", \"lp_count\", \"cc\"}\n-\n-/* Entry to the insn conditionalizer.  */\n-#define FINAL_PRESCAN_INSN(INSN, OPVEC, NOPERANDS) \\\n-arc_final_prescan_insn (INSN, OPVEC, NOPERANDS)\n-\n-/* A C expression which evaluates to true if CODE is a valid\n-   punctuation character for use in the `PRINT_OPERAND' macro.  */\n-extern char arc_punct_chars[256];\n-#define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \\\n-arc_punct_chars[(unsigned char) (CHAR)]\n-\n-/* Print operand X (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n-#define PRINT_OPERAND(FILE, X, CODE) \\\n-arc_print_operand (FILE, X, CODE)\n-\n-/* A C compound statement to output to stdio stream STREAM the\n-   assembler syntax for an instruction operand that is a memory\n-   reference whose address is ADDR.  ADDR is an RTL expression.  */\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR) \\\n-arc_print_operand_address (FILE, ADDR)\n-\n-/* This is how to output an element of a case-vector that is absolute.  */\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-do {\t\t\t\t\t\t\t\\\n-  char label[30];\t\t\t\t\t\\\n-  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\\\n-  fprintf (FILE, \"\\t.word %%st(\");\t\t\t\\\n-  assemble_name (FILE, label);\t\t\t\t\\\n-  fprintf (FILE, \")\\n\");\t\t\t\t\\\n-} while (0)\n-\n-/* This is how to output an element of a case-vector that is relative.  */\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n-do {\t\t\t\t\t\t\t\\\n-  char label[30];\t\t\t\t\t\\\n-  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", VALUE);\t\\\n-  fprintf (FILE, \"\\t.word %%st(\");\t\t\t\\\n-  assemble_name (FILE, label);\t\t\t\t\\\n-  fprintf (FILE, \"-\");\t\t\t\t\t\\\n-  ASM_GENERATE_INTERNAL_LABEL (label, \"L\", REL);\t\\\n-  assemble_name (FILE, label);\t\t\t\t\\\n-  fprintf (FILE, \")\\n\");\t\t\t\t\\\n-} while (0)\n-\n-/* The desired alignment for the location counter at the beginning\n-   of a loop.  */\n-/* On the ARC, align loops to 32 byte boundaries (cache line size)\n-   if -malign-loops.  */\n-#define LOOP_ALIGN(LABEL) (TARGET_ALIGN_LOOPS ? 5 : 0)\n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter\n-   to a multiple of 2**LOG bytes.  */\n-#define ASM_OUTPUT_ALIGN(FILE,LOG) \\\n-do { if ((LOG) != 0) fprintf (FILE, \"\\t.align %d\\n\", 1 << (LOG)); } while (0)\n-\f\n-/* Debugging information.  */\n-\n-/* Generate DBX and DWARF debugging information.  */\n-#define DBX_DEBUGGING_INFO 1\n-\n-/* Prefer STABS (for now).  */\n-#undef PREFERRED_DEBUGGING_TYPE\n-#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n-\n-/* Turn off splitting of long stabs.  */\n-#define DBX_CONTIN_LENGTH 0\n-\f\n-/* Miscellaneous.  */\n-\n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE Pmode\n-\n-/* Define if operations between registers always perform the operation\n-   on the full register even if a narrower mode is specified.  */\n-#define WORD_REGISTER_OPERATIONS\n-\n-/* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n-   will either zero-extend or sign-extend.  The value of this macro should\n-   be the code that says which one of the two operations is implicitly\n-   done, UNKNOWN if none.  */\n-#define LOAD_EXTEND_OP(MODE) ZERO_EXTEND\n-\n-/* Max number of bytes we can move from memory to memory\n-   in one reasonably fast instruction.  */\n-#define MOVE_MAX 4\n-\n-/* Define this to be nonzero if shift instructions ignore all but the low-order\n-   few bits.  */\n-#define SHIFT_COUNT_TRUNCATED 1\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-/* Specify the machine mode that pointers have.\n-   After generation of rtl, the compiler makes no further distinction\n-   between pointers and any other objects of this machine mode.  */\n-/* ??? The arc doesn't have full 32-bit pointers, but making this PSImode has\n-   its own problems (you have to add extendpsisi2 and trucnsipsi2 but how does\n-   one do it without getting excess code?).  Try to avoid it.  */\n-#define Pmode SImode\n-\n-/* A function address in a call instruction.  */\n-#define FUNCTION_MODE SImode\n-\n-/* alloca should avoid clobbering the old register save area.  */\n-/* ??? Not defined in tm.texi.  */\n-#define SETJMP_VIA_SAVE_AREA\n-\f\n-/* ARC function types.  */\n-enum arc_function_type {\n-  ARC_FUNCTION_UNKNOWN, ARC_FUNCTION_NORMAL,\n-  /* These are interrupt handlers.  The name corresponds to the register\n-     name that contains the return address.  */\n-  ARC_FUNCTION_ILINK1, ARC_FUNCTION_ILINK2\n-};\n-#define ARC_INTERRUPT_P(TYPE) \\\n-((TYPE) == ARC_FUNCTION_ILINK1 || (TYPE) == ARC_FUNCTION_ILINK2)\n-/* Compute the type of a function from its DECL.  */"}, {"sha": "09e47daf1d1e67f5cf1516cd9f9e4941a7adf242", "filename": "gcc/config/arc/arc.md", "status": "removed", "additions": 0, "deletions": 1376, "changes": 1376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,1376 +0,0 @@\n-;; Machine description of the Argonaut ARC cpu for GNU C compiler\n-;; Copyright (C) 1994, 1997, 1998, 1999, 2000, 2004, 2005, 2007, 2008\n-;; Free Software Foundation, Inc.\n-\n-;; This file is part of GCC.\n-\n-;; GCC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 3, or (at your option)\n-;; any later version.\n-\n-;; GCC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.\n-\n-;; See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n-\n-;; ??? This is an old port, and is undoubtedly suffering from bit rot.\n-\f\n-;; Insn type.  Used to default other attribute values.\n-\n-(define_attr \"type\"\n-  \"move,load,store,cmove,unary,binary,compare,shift,mul,uncond_branch,branch,call,call_no_delay_slot,multi,misc\"\n-  (const_string \"binary\"))\n-\n-;; Length (in # of insns, long immediate constants counted too).\n-;; ??? There's a nasty interaction between the conditional execution fsm\n-;; and insn lengths: insns with shimm values cannot be conditionally executed.\n-(define_attr \"length\" \"\"\n-  (cond [(eq_attr \"type\" \"load\")\n-\t (if_then_else (match_operand 1 \"long_immediate_loadstore_operand\" \"\")\n-\t\t       (const_int 2) (const_int 1))\n-\n-\t (eq_attr \"type\" \"store\")\n-\t (if_then_else (match_operand 0 \"long_immediate_loadstore_operand\" \"\")\n-\t\t       (const_int 2) (const_int 1))\n-\n-\t (eq_attr \"type\" \"move,unary,compare\")\n-\t (if_then_else (match_operand 1 \"long_immediate_operand\" \"\")\n-\t\t       (const_int 2) (const_int 1))\n-\n-\t (eq_attr \"type\" \"binary,mul\")\n-\t (if_then_else (match_operand 2 \"long_immediate_operand\" \"\")\n-\t\t       (const_int 2) (const_int 1))\n-\n-\t (eq_attr \"type\" \"cmove\")\n-\t (if_then_else (match_operand 2 \"register_operand\" \"\")\n-\t\t       (const_int 1) (const_int 2))\n-\n-\t (eq_attr \"type\" \"multi\") (const_int 2)\n-\t]\n-\n-\t(const_int 1)))\n-\n-;; The length here is the length of a single asm.  Unfortunately it might be\n-;; 1 or 2 so we must allow for 2.  That's ok though.  How often will users\n-;; lament asm's not being put in delay slots?\n-(define_asm_attributes\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"type\" \"multi\")])\n-\n-;; Condition codes: this one is used by final_prescan_insn to speed up\n-;; conditionalizing instructions.  It saves having to scan the rtl to see if\n-;; it uses or alters the condition codes.\n-\n-;; USE: This insn uses the condition codes (e.g.: a conditional branch).\n-;; CANUSE: This insn can use the condition codes (for conditional execution).\n-;; SET: All condition codes are set by this insn.\n-;; SET_ZN: the Z and N flags are set by this insn.\n-;; SET_ZNC: the Z, N, and C flags are set by this insn.\n-;; CLOB: The condition codes are set to unknown values by this insn.\n-;; NOCOND: This insn can't use and doesn't affect the condition codes.\n-\n-(define_attr \"cond\" \"use,canuse,set,set_zn,set_znc,clob,nocond\"\n-  (cond [(and (eq_attr \"type\" \"unary,binary,move\")\n-\t      (eq_attr \"length\" \"1\"))\n-\t (const_string \"canuse\")\n-\n-\t (eq_attr \"type\" \"compare\")\n-\t (const_string \"set\")\n-\n-\t (eq_attr \"type\" \"cmove,branch\")\n-\t (const_string \"use\")\n-\n-\t (eq_attr \"type\" \"multi,misc\")\n-\t (const_string \"clob\")\n-\t ]\n-\n-\t (const_string \"nocond\")))\n-\f\n-;; Delay slots.\n-\n-(define_attr \"in_delay_slot\" \"false,true\"\n-  (cond [(eq_attr \"type\" \"uncond_branch,branch,call,call_no_delay_slot,multi\")\n-\t (const_string \"false\")\n-\t ]\n-\n-\t (if_then_else (eq_attr \"length\" \"1\")\n-\t\t       (const_string \"true\")\n-\t\t       (const_string \"false\"))))\n-\n-(define_delay (eq_attr \"type\" \"call\")\n-  [(eq_attr \"in_delay_slot\" \"true\")\n-   (eq_attr \"in_delay_slot\" \"true\")\n-   (eq_attr \"in_delay_slot\" \"true\")])\n-\n-(define_delay (eq_attr \"type\" \"branch,uncond_branch\")\n-  [(eq_attr \"in_delay_slot\" \"true\")\n-   (eq_attr \"in_delay_slot\" \"true\")\n-   (eq_attr \"in_delay_slot\" \"true\")])\n-\f   \n-;; Scheduling description for the ARC\n-\n-(define_cpu_unit \"branch\")\n-\n-(define_insn_reservation \"any_insn\" 1 (eq_attr \"type\" \"!load,compare,branch\")\n-\t\t\t \"nothing\")\n-\n-;; 1) A conditional jump cannot immediately follow the insn setting the flags.\n-;; This isn't a complete solution as it doesn't come with guarantees.  That\n-;; is done in the branch patterns and in arc_print_operand.  This exists to\n-;; avoid inserting a nop when we can.\n-\n-(define_insn_reservation \"compare\" 1 (eq_attr \"type\" \"compare\")\n-\t\t         \"nothing,branch\")\n-\n-(define_insn_reservation \"branch\" 1 (eq_attr \"type\" \"branch\")\n-\t\t         \"branch\")\n-\n-;; 2) References to loaded registers should wait a cycle.\n-\n-;; Memory with load-delay of 1 (i.e., 2 cycle load).\n-\n-(define_insn_reservation \"memory\" 2 (eq_attr \"type\" \"load\")\n-\t\t\t \"nothing\")\n-\f\n-;; Move instructions.\n-\n-(define_expand \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n-\t(match_operand:QI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  /* Everything except mem = const or mem = mem can be done easily.  */\n-\n-  if (GET_CODE (operands[0]) == MEM)\n-    operands[1] = force_reg (QImode, operands[1]);\n-}\")\n-\n-(define_insn \"*movqi_insn\"\n-  [(set (match_operand:QI 0 \"move_dest_operand\" \"=r,r,r,m\")\n-\t(match_operand:QI 1 \"move_src_operand\" \"rI,Ji,m,r\"))]\n-;; ??? Needed?\n-  \"register_operand (operands[0], QImode)\n-   || register_operand (operands[1], QImode)\"\n-  \"@\n-   mov%? %0,%1\n-   mov%? %0,%1\n-   ldb%U1%V1 %0,%1\n-   stb%U0%V0 %1,%0\"\n-  [(set_attr \"type\" \"move,move,load,store\")])\n-\n-;; ??? This may never match since there's no cmpqi insn.\n-\n-(define_insn \"*movqi_set_cc_insn\"\n-  [(set (reg:CCZN 61) (compare:CCZN\n-\t\t       (sign_extend:SI (match_operand:QI 1 \"move_src_operand\" \"rIJi\"))\n-\t\t       (const_int 0)))\n-   (set (match_operand:QI 0 \"move_dest_operand\" \"=r\")\n-\t(match_dup 1))]\n-  \"\"\n-  \"mov%?.f %0,%1\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"cond\" \"set_zn\")])\n-\n-(define_expand \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"\")\n-\t(match_operand:HI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  /* Everything except mem = const or mem = mem can be done easily.  */\n-\n-  if (GET_CODE (operands[0]) == MEM)\n-    operands[1] = force_reg (HImode, operands[1]);\n-}\")\n-\n-(define_insn \"*movhi_insn\"\n-  [(set (match_operand:HI 0 \"move_dest_operand\" \"=r,r,r,m\")\n-\t(match_operand:HI 1 \"move_src_operand\" \"rI,Ji,m,r\"))]\n-  \"register_operand (operands[0], HImode)\n-   || register_operand (operands[1], HImode)\"\n-  \"@\n-   mov%? %0,%1\n-   mov%? %0,%1\n-   ldw%U1%V1 %0,%1\n-   stw%U0%V0 %1,%0\"\n-  [(set_attr \"type\" \"move,move,load,store\")])\n-\n-;; ??? Will this ever match?\n-\n-(define_insn \"*movhi_set_cc_insn\"\n-  [(set (reg:CCZN 61) (compare:CCZN\n-\t\t       (sign_extend:SI (match_operand:HI 1 \"move_src_operand\" \"rIJi\"))\n-\t\t       (const_int 0)))\n-   (set (match_operand:HI 0 \"move_dest_operand\" \"=r\")\n-\t(match_dup 1))]\n-;; ??? Needed?\n-  \"register_operand (operands[0], HImode)\n-   || register_operand (operands[1], HImode)\"\n-  \"mov%?.f %0,%1\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"cond\" \"set_zn\")])\n-\n-(define_expand \"movsi\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"\")\n-\t(match_operand:SI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  /* Everything except mem = const or mem = mem can be done easily.  */\n-\n-  if (GET_CODE (operands[0]) == MEM)\n-    operands[1] = force_reg (SImode, operands[1]);\n-}\")\n-\n-(define_insn \"*movsi_insn\"\n-  [(set (match_operand:SI 0 \"move_dest_operand\" \"=r,r,r,m\")\n-\t(match_operand:SI 1 \"move_src_operand\" \"rI,GJi,m,r\"))]\n-  \"register_operand (operands[0], SImode)\n-   || register_operand (operands[1], SImode)\"\n-  \"@\n-   mov%? %0,%1\n-   mov%? %0,%S1\n-   ld%U1%V1 %0,%1\n-   st%U0%V0 %1,%0\"\n-  [(set_attr \"type\" \"move,move,load,store\")])\n-\n-(define_insn \"*movsi_set_cc_insn\"\n-  [(set (reg:CCZN 61) (compare:CCZN\n-\t\t       (match_operand:SI 1 \"move_src_operand\" \"rIJi\")\n-\t\t       (const_int 0)))\n-   (set (match_operand:SI 0 \"move_dest_operand\" \"=r\")\n-\t(match_dup 1))]\n-  \"register_operand (operands[0], SImode)\n-   || register_operand (operands[1], SImode)\"\n-  \"mov%?.f %0,%S1\"\n-  [(set_attr \"type\" \"move\")\n-   (set_attr \"cond\" \"set_zn\")])\n-\n-(define_expand \"movdi\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"\")\n-\t(match_operand:DI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  /* Everything except mem = const or mem = mem can be done easily.  */\n-\n-  if (GET_CODE (operands[0]) == MEM)\n-    operands[1] = force_reg (DImode, operands[1]);\n-}\")\n-\n-(define_insn \"*movdi_insn\"\n-  [(set (match_operand:DI 0 \"move_dest_operand\" \"=r,r,r,m\")\n-\t(match_operand:DI 1 \"move_double_src_operand\" \"r,HK,m,r\"))]\n-  \"register_operand (operands[0], DImode)\n-   || register_operand (operands[1], DImode)\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0 :\n-      /* We normally copy the low-numbered register first.  However, if\n-\t the first register operand 0 is the same as the second register of\n-\t operand 1, we must copy in the opposite order.  */\n-      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n-\treturn \\\"mov %R0,%R1\\;mov %0,%1\\\";\n-      else\n-\treturn \\\"mov %0,%1\\;mov %R0,%R1\\\";\n-    case 1 :\n-      return \\\"mov %0,%L1\\;mov %R0,%H1\\\";\n-    case 2 :\n-      /* If the low-address word is used in the address, we must load it\n-\t last.  Otherwise, load it first.  Note that we cannot have\n-\t auto-increment in that case since the address register is known to be\n-\t dead.  */\n-      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n-\t\t\t     operands [1], 0))\n-\t  return \\\"ld%V1 %R0,%R1\\;ld%V1 %0,%1\\\";\n-      else\n-\t  return \\\"ld%V1 %0,%1\\;ld%V1 %R0,%R1\\\";\n-    case 3 :\n-      return \\\"st%V0 %1,%0\\;st%V0 %R1,%R0\\\";\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,move,load,store\")\n-   ;; ??? The ld/st values could be 4 if it's [reg,bignum].\n-   (set_attr \"length\" \"2,4,2,2\")])\n-\n-;(define_expand \"movdi\"\n-;  [(set (match_operand:DI 0 \"general_operand\" \"\")\n-;\t(match_operand:DI 1 \"general_operand\" \"\"))]\n-;  \"\"\n-;  \"\n-;{\n-;  /* Flow doesn't understand that this is effectively a DFmode move.\n-;     It doesn't know that all of `operands[0]' is set.  */\n-;  emit_clobber (operands[0]);\n-;\n-;  /* Emit insns that movsi_insn can handle.  */\n-;  emit_insn (gen_movsi (operand_subword (operands[0], 0, 0, DImode),\n-;\t\t\toperand_subword (operands[1], 0, 0, DImode)));\n-;  emit_insn (gen_movsi (operand_subword (operands[0], 1, 0, DImode),\n-;\t\t\toperand_subword (operands[1], 1, 0, DImode)));\n-;  DONE;\n-;}\")\n-\f\n-;; Floating point move insns.\n-\n-(define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"\")\n-\t(match_operand:SF 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  /* Everything except mem = const or mem = mem can be done easily.  */\n-  if (GET_CODE (operands[0]) == MEM)\n-    operands[1] = force_reg (SFmode, operands[1]);\n-}\")\n-\n-(define_insn \"*movsf_insn\"\n-  [(set (match_operand:SF 0 \"move_dest_operand\" \"=r,r,r,m\")\n-\t(match_operand:SF 1 \"move_src_operand\" \"r,E,m,r\"))]\n-  \"register_operand (operands[0], SFmode)\n-   || register_operand (operands[1], SFmode)\"\n-  \"@\n-   mov%? %0,%1\n-   mov%? %0,%1 ; %A1\n-   ld%U1%V1 %0,%1\n-   st%U0%V0 %1,%0\"\n-  [(set_attr \"type\" \"move,move,load,store\")])\n-\n-(define_expand \"movdf\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"\")\n-\t(match_operand:DF 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  /* Everything except mem = const or mem = mem can be done easily.  */\n-  if (GET_CODE (operands[0]) == MEM)\n-    operands[1] = force_reg (DFmode, operands[1]);\n-}\")\n-\n-(define_insn \"*movdf_insn\"\n-  [(set (match_operand:DF 0 \"move_dest_operand\" \"=r,r,r,m\")\n-\t(match_operand:DF 1 \"move_double_src_operand\" \"r,E,m,r\"))]\n-  \"register_operand (operands[0], DFmode)\n-   || register_operand (operands[1], DFmode)\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0 :\n-      /* We normally copy the low-numbered register first.  However, if\n-\t the first register operand 0 is the same as the second register of\n-\t operand 1, we must copy in the opposite order.  */\n-      if (REGNO (operands[0]) == REGNO (operands[1]) + 1)\n-\treturn \\\"mov %R0,%R1\\;mov %0,%1\\\";\n-      else\n-\treturn \\\"mov %0,%1\\;mov %R0,%R1\\\";\n-    case 1 :\n-      return \\\"mov %0,%L1\\;mov %R0,%H1 ; %A1\\\";\n-    case 2 :\n-      /* If the low-address word is used in the address, we must load it\n-\t last.  Otherwise, load it first.  Note that we cannot have\n-\t auto-increment in that case since the address register is known to be\n-\t dead.  */\n-      if (refers_to_regno_p (REGNO (operands[0]), REGNO (operands[0]) + 1,\n-\t\t\t     operands [1], 0))\n-\treturn \\\"ld%V1 %R0,%R1\\;ld%V1 %0,%1\\\";\n-      else\n-\treturn \\\"ld%V1 %0,%1\\;ld%V1 %R0,%R1\\\";\n-    case 3 :\n-      return \\\"st%V0 %1,%0\\;st%V0 %R1,%R0\\\";\n-    default:\n-      gcc_unreachable ();\n-    }\n-}\"\n-  [(set_attr \"type\" \"move,move,load,store\")\n-   ;; ??? The ld/st values could be 4 if it's [reg,bignum].\n-   (set_attr \"length\" \"2,4,2,2\")])\n-\n-;(define_expand \"movdf\"\n-;  [(set (match_operand:DF 0 \"general_operand\" \"\")\n-;\t(match_operand:DF 1 \"general_operand\" \"\"))]\n-;  \"\"\n-;  \"\n-;{\n-;  /* Flow doesn't understand that this is effectively a DFmode move.\n-;     It doesn't know that all of `operands[0]' is set.  */\n-;  emit_clobber (operands[0]);\n-;\n-;  /* Emit insns that movsi_insn can handle.  */\n-;  emit_insn (gen_movsi (operand_subword (operands[0], 0, 0, DFmode),\n-;\t\t\toperand_subword (operands[1], 0, 0, DFmode)));\n-;  emit_insn (gen_movsi (operand_subword (operands[0], 1, 0, DFmode),\n-;\t\t\toperand_subword (operands[1], 1, 0, DFmode)));\n-;  DONE;\n-;}\")\n-\f\n-;; Load/Store with update instructions.\n-;;\n-;; Some of these we can get by using pre-decrement or pre-increment, but the\n-;; hardware can also do cases where the increment is not the size of the\n-;; object.\n-;;\n-;; In all these cases, we use operands 0 and 1 for the register being\n-;; incremented because those are the operands that local-alloc will\n-;; tie and these are the pair most likely to be tieable (and the ones\n-;; that will benefit the most).\n-;;\n-;; We use match_operator here because we need to know whether the memory\n-;; object is volatile or not.\n-\n-(define_insn \"*loadqi_update\"\n-  [(set (match_operand:QI 3 \"register_operand\" \"=r,r\")\n-\t(match_operator:QI 4 \"load_update_operand\"\n-\t [(match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t  (match_operand:SI 2 \"nonmemory_operand\" \"rI,J\")]))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"ldb.a%V4 %3,[%0,%2]\"\n-  [(set_attr \"type\" \"load,load\")\n-   (set_attr \"length\" \"1,2\")])\n-\n-(define_insn \"*load_zeroextendqisi_update\"\n-  [(set (match_operand:SI 3 \"register_operand\" \"=r,r\")\n-\t(zero_extend:SI (match_operator:QI 4 \"load_update_operand\"\n-\t\t\t [(match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"rI,J\")])))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"ldb.a%V4 %3,[%0,%2]\"\n-  [(set_attr \"type\" \"load,load\")\n-   (set_attr \"length\" \"1,2\")])\n-\n-(define_insn \"*load_signextendqisi_update\"\n-  [(set (match_operand:SI 3 \"register_operand\" \"=r,r\")\n-\t(sign_extend:SI (match_operator:QI 4 \"load_update_operand\"\n-\t\t\t [(match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"rI,J\")])))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"ldb.x.a%V4 %3,[%0,%2]\"\n-  [(set_attr \"type\" \"load,load\")\n-   (set_attr \"length\" \"1,2\")])\n-\n-(define_insn \"*storeqi_update\"\n-  [(set (match_operator:QI 4 \"store_update_operand\"\n-\t [(match_operand:SI 1 \"register_operand\" \"0\")\n-\t  (match_operand:SI 2 \"short_immediate_operand\" \"I\")])\n-\t(match_operand:QI 3 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"stb.a%V4 %3,[%0,%2]\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"length\" \"1\")])\n-\n-(define_insn \"*loadhi_update\"\n-  [(set (match_operand:HI 3 \"register_operand\" \"=r,r\")\n-\t(match_operator:HI 4 \"load_update_operand\"\n-\t [(match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t  (match_operand:SI 2 \"nonmemory_operand\" \"rI,J\")]))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"ldw.a%V4 %3,[%0,%2]\"\n-  [(set_attr \"type\" \"load,load\")\n-   (set_attr \"length\" \"1,2\")])\n-\n-(define_insn \"*load_zeroextendhisi_update\"\n-  [(set (match_operand:SI 3 \"register_operand\" \"=r,r\")\n-\t(zero_extend:SI (match_operator:HI 4 \"load_update_operand\"\n-\t\t\t [(match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"rI,J\")])))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"ldw.a%V4 %3,[%0,%2]\"\n-  [(set_attr \"type\" \"load,load\")\n-   (set_attr \"length\" \"1,2\")])\n-\n-(define_insn \"*load_signextendhisi_update\"\n-  [(set (match_operand:SI 3 \"register_operand\" \"=r,r\")\n-\t(sign_extend:SI (match_operator:HI 4 \"load_update_operand\"\n-\t\t\t [(match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"rI,J\")])))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"ldw.x.a%V4 %3,[%0,%2]\"\n-  [(set_attr \"type\" \"load,load\")\n-   (set_attr \"length\" \"1,2\")])\n-\n-(define_insn \"*storehi_update\"\n-  [(set (match_operator:HI 4 \"store_update_operand\"\n-\t [(match_operand:SI 1 \"register_operand\" \"0\")\n-\t  (match_operand:SI 2 \"short_immediate_operand\" \"I\")])\n-\t(match_operand:HI 3 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"stw.a%V4 %3,[%0,%2]\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"length\" \"1\")])\n-\n-(define_insn \"*loadsi_update\"\n-  [(set (match_operand:SI 3 \"register_operand\" \"=r,r\")\n-\t(match_operator:SI 4 \"load_update_operand\"\n-\t [(match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t  (match_operand:SI 2 \"nonmemory_operand\" \"rI,J\")]))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"ld.a%V4 %3,[%0,%2]\"\n-  [(set_attr \"type\" \"load,load\")\n-   (set_attr \"length\" \"1,2\")])\n-\n-(define_insn \"*storesi_update\"\n-  [(set (match_operator:SI 4 \"store_update_operand\"\n-\t [(match_operand:SI 1 \"register_operand\" \"0\")\n-\t  (match_operand:SI 2 \"short_immediate_operand\" \"I\")])\n-\t(match_operand:SI 3 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"st.a%V4 %3,[%0,%2]\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"length\" \"1\")])\n-\n-(define_insn \"*loadsf_update\"\n-  [(set (match_operand:SF 3 \"register_operand\" \"=r,r\")\n-\t(match_operator:SF 4 \"load_update_operand\"\n-\t [(match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t  (match_operand:SI 2 \"nonmemory_operand\" \"rI,J\")]))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"ld.a%V4 %3,[%0,%2]\"\n-  [(set_attr \"type\" \"load,load\")\n-   (set_attr \"length\" \"1,2\")])\n-\n-(define_insn \"*storesf_update\"\n-  [(set (match_operator:SF 4 \"store_update_operand\"\n-\t [(match_operand:SI 1 \"register_operand\" \"0\")\n-\t  (match_operand:SI 2 \"short_immediate_operand\" \"I\")])\n-\t(match_operand:SF 3 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"st.a%V4 %3,[%0,%2]\"\n-  [(set_attr \"type\" \"store\")\n-   (set_attr \"length\" \"1\")])\n-\f\n-;; Conditional move instructions.\n-\n-(define_expand \"movsicc\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(if_then_else:SI (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:SI 2 \"nonmemory_operand\" \"\")\n-\t\t\t (match_operand:SI 3 \"register_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  enum rtx_code code = GET_CODE (operands[1]);\n-  rtx cc_reg = gen_compare_reg (code, XEXP (operands[1], 0),\n-\t\t\t\tXEXP (operands[1], 1));\n-  operands[1] = gen_rtx_fmt_ee (code, VOIDmode, cc_reg, const0_rtx);\n-}\")\n-\n-(define_expand \"movsfcc\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t(if_then_else:SF (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:SF 2 \"nonmemory_operand\" \"\")\n-\t\t\t (match_operand:SF 3 \"register_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  enum rtx_code code = GET_CODE (operands[1]);\n-  rtx cc_reg = gen_compare_reg (code, XEXP (operands[1], 0),\n-\t\t\t\tXEXP (operands[1], 1));\n-  operands[1] = gen_rtx_fmt_ee (code, VOIDmode, cc_reg, const0_rtx);\n-}\")\n-\n-(define_insn \"*movsicc_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(if_then_else:SI (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rJi\")\n-\t\t\t (match_operand:SI 3 \"register_operand\" \"0\")))]\n-  \"\"\n-  \"mov.%d1 %0,%S2\"\n-  [(set_attr \"type\" \"cmove\")])\n-\n-(define_insn \"*movsfcc_insn\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r,r\")\n-\t(if_then_else:SF (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:SF 2 \"nonmemory_operand\" \"r,E\")\n-\t\t\t (match_operand:SF 3 \"register_operand\" \"0,0\")))]\n-  \"\"\n-  \"@\n-   mov.%d1 %0,%2\n-   mov.%d1 %0,%2 ; %A2\"\n-  [(set_attr \"type\" \"cmove,cmove\")])\n-\n-\f\n-;; Zero extension instructions.\n-;; ??? We don't support volatile memrefs here, but I'm not sure why.\n-\n-(define_insn \"zero_extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(zero_extend:HI (match_operand:QI 1 \"nonvol_nonimm_operand\" \"r,m\")))]\n-  \"\"\n-  \"@\n-   extb%? %0,%1\n-   ldb%U1 %0,%1\"\n-  [(set_attr \"type\" \"unary,load\")])\n-\n-(define_insn \"*zero_extendqihi2_set_cc_insn\"\n-  [(set (reg:CCZN 61) (compare:CCZN\n-\t\t       (zero_extend:SI (match_operand:QI 1 \"register_operand\" \"r\"))\n-\t\t       (const_int 0)))\n-   (set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:HI (match_dup 1)))]\n-  \"\"\n-  \"extb%?.f %0,%1\"\n-  [(set_attr \"type\" \"unary\")\n-   (set_attr \"cond\" \"set_zn\")])\n-\n-(define_insn \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(zero_extend:SI (match_operand:QI 1 \"nonvol_nonimm_operand\" \"r,m\")))]\n-  \"\"\n-  \"@\n-   extb%? %0,%1\n-   ldb%U1 %0,%1\"\n-  [(set_attr \"type\" \"unary,load\")])\n-\n-(define_insn \"*zero_extendqisi2_set_cc_insn\"\n-  [(set (reg:CCZN 61) (compare:CCZN\n-\t\t       (zero_extend:SI (match_operand:QI 1 \"register_operand\" \"r\"))\n-\t\t       (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:SI (match_dup 1)))]\n-  \"\"\n-  \"extb%?.f %0,%1\"\n-  [(set_attr \"type\" \"unary\")\n-   (set_attr \"cond\" \"set_zn\")])\n-\n-(define_insn \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(zero_extend:SI (match_operand:HI 1 \"nonvol_nonimm_operand\" \"r,m\")))]\n-  \"\"\n-  \"@\n-   extw%? %0,%1\n-   ldw%U1 %0,%1\"\n-  [(set_attr \"type\" \"unary,load\")])\n-\n-(define_insn \"*zero_extendhisi2_set_cc_insn\"\n-  [(set (reg:CCZN 61) (compare:CCZN\n-\t\t       (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"r\"))\n-\t\t       (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:SI (match_dup 1)))]\n-  \"\"\n-  \"extw%?.f %0,%1\"\n-  [(set_attr \"type\" \"unary\")\n-   (set_attr \"cond\" \"set_zn\")])\n-\f\n-;; Sign extension instructions.\n-\n-(define_insn \"extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r,r\")\n-\t(sign_extend:HI (match_operand:QI 1 \"nonvol_nonimm_operand\" \"r,m\")))]\n-  \"\"\n-  \"@\n-   sexb%? %0,%1\n-   ldb.x%U1 %0,%1\"\n-  [(set_attr \"type\" \"unary,load\")])\n-\n-(define_insn \"*extendqihi2_set_cc_insn\"\n-  [(set (reg:CCZN 61) (compare:CCZN\n-\t\t       (sign_extend:SI (match_operand:QI 1 \"register_operand\" \"r\"))\n-\t\t       (const_int 0)))\n-   (set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:HI (match_dup 1)))]\n-  \"\"\n-  \"sexb%?.f %0,%1\"\n-  [(set_attr \"type\" \"unary\")\n-   (set_attr \"cond\" \"set_zn\")])\n-\n-(define_insn \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(sign_extend:SI (match_operand:QI 1 \"nonvol_nonimm_operand\" \"r,m\")))]\n-  \"\"\n-  \"@\n-   sexb%? %0,%1\n-   ldb.x%U1 %0,%1\"\n-  [(set_attr \"type\" \"unary,load\")])\n-\n-(define_insn \"*extendqisi2_set_cc_insn\"\n-  [(set (reg:CCZN 61) (compare:CCZN\n-\t\t       (sign_extend:SI (match_operand:QI 1 \"register_operand\" \"r\"))\n-\t\t       (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:SI (match_dup 1)))]\n-  \"\"\n-  \"sexb%?.f %0,%1\"\n-  [(set_attr \"type\" \"unary\")\n-   (set_attr \"cond\" \"set_zn\")])\n-\n-(define_insn \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(sign_extend:SI (match_operand:HI 1 \"nonvol_nonimm_operand\" \"r,m\")))]\n-  \"\"\n-  \"@\n-   sexw%? %0,%1\n-   ldw.x%U1 %0,%1\"\n-  [(set_attr \"type\" \"unary,load\")])\n-\n-(define_insn \"*extendhisi2_set_cc_insn\"\n-  [(set (reg:CCZN 61) (compare:CCZN\n-\t\t       (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"r\"))\n-\t\t       (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:SI (match_dup 1)))]\n-  \"\"\n-  \"sexw%?.f %0,%1\"\n-  [(set_attr \"type\" \"unary\")\n-   (set_attr \"cond\" \"set_zn\")])\n-\f\n-;; Arithmetic instructions.\n-\n-(define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rIJ\")))]\n-  \"\"\n-  \"add%? %0,%1,%2\")\n-\n-(define_insn \"*addsi3_set_cc_insn\"\n-  [(set (reg:CC 61) (compare:CC\n-\t\t     (plus:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n-\t\t\t      (match_operand:SI 2 \"nonmemory_operand\" \"rIJ\"))\n-\t\t     (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_dup 1)\n-\t\t (match_dup 2)))]\n-  \"\"\n-  \"add%?.f %0,%1,%2\"\n-  [(set_attr \"cond\" \"set\")])\n-\n-(define_insn \"adddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(plus:DI (match_operand:DI 1 \"nonmemory_operand\" \"%r\")\n-\t\t (match_operand:DI 2 \"nonmemory_operand\" \"ri\")))\n-   (clobber (reg:CC 61))]\n-  \"\"\n-  \"*\n-{\n-  rtx op2 = operands[2];\n-\n-  if (GET_CODE (op2) == CONST_INT)\n-    {\n-      int sign = INTVAL (op2);\n-      if (sign < 0)\n-\treturn \\\"add.f %L0,%L1,%2\\;adc %H0,%H1,-1\\\";\n-      else\n-\treturn \\\"add.f %L0,%L1,%2\\;adc %H0,%H1,0\\\";\n-    }\n-  else\n-    return \\\"add.f %L0,%L1,%L2\\;adc %H0,%H1,%H2\\\";\n-}\"\n-  [(set_attr \"length\" \"2\")])\n-\n-(define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"rIJ\")))]\n-  \"\"\n-  \"sub%? %0,%1,%2\")\n-\n-(define_insn \"*subsi3_set_cc_insn\"\n-  [(set (reg:CC 61) (compare:CC\n-\t\t     (minus:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n-\t\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"rIJ\"))\n-\t\t     (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(minus:SI (match_dup 1)\n-\t\t  (match_dup 2)))]\n-  \"\"\n-  \"sub%?.f %0,%1,%2\"\n-  [(set_attr \"cond\" \"set\")])\n-\n-(define_insn \"subdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(minus:DI (match_operand:DI 1 \"nonmemory_operand\" \"r\")\n-\t\t  (match_operand:DI 2 \"nonmemory_operand\" \"ri\")))\n-   (clobber (reg:CC 61))]\n-  \"\"\n-  \"*\n-{\n-  rtx op2 = operands[2];\n-\n-  if (GET_CODE (op2) == CONST_INT)\n-    {\n-      int sign = INTVAL (op2);\n-      if (sign < 0)\n-\treturn \\\"sub.f %L0,%L1,%2\\;sbc %H0,%H1,-1\\\";\n-      else\n-\treturn \\\"sub.f %L0,%L1,%2\\;sbc %H0,%H1,0\\\";\n-    }\n-  else\n-    return \\\"sub.f %L0,%L1,%L2\\;sbc %H0,%H1,%H2\\\";\n-}\"\n-  [(set_attr \"length\" \"2\")])\n-\f\n-;; Boolean instructions.\n-;;\n-;; We don't define the DImode versions as expand_binop does a good enough job.\n-\n-(define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rIJ\")))]\n-  \"\"\n-  \"and%? %0,%1,%2\")\n-\n-(define_insn \"*andsi3_set_cc_insn\"\n-  [(set (reg:CCZN 61) (compare:CCZN\n-\t\t       (and:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n-\t\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"rIJ\"))\n-\t\t       (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(and:SI (match_dup 1)\n-\t\t(match_dup 2)))]\n-  \"\"\n-  \"and%?.f %0,%1,%2\"\n-  [(set_attr \"cond\" \"set_zn\")])\n-\n-(define_insn \"*bicsi3_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n-\t(and:SI (match_operand:SI 1 \"nonmemory_operand\" \"r,r,I,J\")\n-\t\t(not:SI (match_operand:SI 2 \"nonmemory_operand\" \"rI,J,r,r\"))))]\n-  \"\"\n-  \"bic%? %0,%1,%2\"\n-  [(set_attr \"length\" \"1,2,1,2\")])\n-\n-(define_insn \"*bicsi3_set_cc_insn\"\n-  [(set (reg:CCZN 61) (compare:CCZN\n-\t\t       (and:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n-\t\t\t       (not:SI (match_operand:SI 2 \"nonmemory_operand\" \"rIJ\")))\n-\t\t       (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(and:SI (match_dup 1)\n-\t\t(not:SI (match_dup 2))))]\n-  \"\"\n-  \"bic%?.f %0,%1,%2\"\n-  [(set_attr \"cond\" \"set_zn\")])\n-\n-(define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rIJ\")))]\n-  \"\"\n-  \"or%? %0,%1,%2\")\n-\n-(define_insn \"*iorsi3_set_cc_insn\"\n-  [(set (reg:CCZN 61) (compare:CCZN\n-\t\t       (ior:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n-\t\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"rIJ\"))\n-\t\t       (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ior:SI (match_dup 1)\n-\t\t(match_dup 2)))]\n-  \"\"\n-  \"or%?.f %0,%1,%2\"\n-  [(set_attr \"cond\" \"set_zn\")])\n-\n-(define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rIJ\")))]\n-  \"\"\n-  \"xor%? %0,%1,%2\")\n-\n-(define_insn \"*xorsi3_set_cc_insn\"\n-  [(set (reg:CCZN 61) (compare:CCZN\n-\t\t       (xor:SI (match_operand:SI 1 \"register_operand\" \"%r\")\n-\t\t\t       (match_operand:SI 2 \"nonmemory_operand\" \"rIJ\"))\n-\t\t       (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(xor:SI (match_dup 1)\n-\t\t(match_dup 2)))]\n-  \"\"\n-  \"xor%?.f %0,%1,%2\"\n-  [(set_attr \"cond\" \"set_zn\")])\n-\n-(define_insn \"negsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(neg:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"sub%? %0,0,%1\"\n-  [(set_attr \"type\" \"unary\")])\n-\n-(define_insn \"*negsi2_set_cc_insn\"\n-  [(set (reg:CC 61) (compare:CC\n-\t\t     (neg:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t\t     (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(neg:SI (match_dup 1)))]\n-  \"\"\n-  \"sub%?.f %0,0,%1\"\n-  [(set_attr \"type\" \"unary\")\n-   (set_attr \"cond\" \"set\")])\n-\n-(define_insn \"negdi2\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(neg:DI (match_operand:DI 1 \"register_operand\" \"r\")))\n-   (clobber (reg:SI 61))]\n-  \"\"\n-  \"sub.f %L0,0,%L1\\;sbc %H0,0,%H1\"\n-  [(set_attr \"type\" \"unary\")\n-   (set_attr \"length\" \"2\")])\n-\n-(define_insn \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"xor%? %0,%1,-1\"\n-  [(set_attr \"type\" \"unary\")])\n-\n-(define_insn \"*one_cmplsi2_set_cc_insn\"\n-  [(set (reg:CCZN 61) (compare:CCZN\n-\t\t       (not:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t\t       (const_int 0)))\n-   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(not:SI (match_dup 1)))]\n-  \"\"\n-  \"xor%?.f %0,%1,-1\"\n-  [(set_attr \"type\" \"unary\")\n-   (set_attr \"cond\" \"set_zn\")])\n-\f\n-;; Shift instructions.\n-\n-(define_expand \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (! TARGET_SHIFTER)\n-    {\n-      emit_insn (gen_rtx_PARALLEL\n-\t\t (VOIDmode,\n-\t\t  gen_rtvec (2,\n-\t\t\t     gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t\t\t  gen_rtx_ASHIFT (SImode, operands[1],\n-\t\t\t\t\t\t\t  operands[2])),\n-\t\t\t     gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t      gen_rtx_SCRATCH (SImode)))));\n-      DONE;\n-    }\n-}\")\n-\n-(define_expand \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (! TARGET_SHIFTER)\n-    {\n-      emit_insn (gen_rtx_PARALLEL\n-\t\t (VOIDmode,\n-\t\t  gen_rtvec (2,\n-\t\t\t     gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t\t\t  gen_rtx_ASHIFTRT (SImode,\n-\t\t\t\t\t\t\t    operands[1],\n-\t\t\t\t\t\t\t    operands[2])),\n-\t\t\t     gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t      gen_rtx_SCRATCH (SImode)))));\n-      DONE;\n-    }\n-}\")\n-\n-(define_expand \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (! TARGET_SHIFTER)\n-    {\n-      emit_insn (gen_rtx_PARALLEL\n-\t\t (VOIDmode,\n-\t\t  gen_rtvec (2,\n-\t\t\t     gen_rtx_SET (VOIDmode, operands[0],\n-\t\t\t\t\t  gen_rtx_LSHIFTRT (SImode,\n-\t\t\t\t\t\t\t    operands[1],\n-\t\t\t\t\t\t\t    operands[2])),\n-\t\t\t     gen_rtx_CLOBBER (VOIDmode,\n-\t\t\t\t\t      gen_rtx_SCRATCH (SImode)))));\n-      DONE;\n-    }\n-}\")\n-\n-(define_insn \"*ashlsi3_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n-\t(ashift:SI (match_operand:SI 1 \"nonmemory_operand\" \"r,r,I,J\")\n-\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"rI,J,r,r\")))]\n-  \"TARGET_SHIFTER\"\n-  \"asl%? %0,%1,%2\"\n-  [(set_attr \"type\" \"shift\")\n-   (set_attr \"length\" \"1,2,1,2\")])\n-\n-(define_insn \"*ashrsi3_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"nonmemory_operand\" \"r,r,I,J\")\n-\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"rI,J,r,r\")))]\n-  \"TARGET_SHIFTER\"\n-  \"asr%? %0,%1,%2\"\n-  [(set_attr \"type\" \"shift\")\n-   (set_attr \"length\" \"1,2,1,2\")])\n-\n-(define_insn \"*lshrsi3_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"nonmemory_operand\" \"r,r,I,J\")\n-\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"rI,J,r,r\")))]\n-  \"TARGET_SHIFTER\"\n-  \"lsr%? %0,%1,%2\"\n-  [(set_attr \"type\" \"shift\")\n-   (set_attr \"length\" \"1,2,1,2\")])\n-\n-(define_insn \"*shift_si3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operator:SI 3 \"shift_operator\"\n-\t\t\t   [(match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t\t    (match_operand:SI 2 \"nonmemory_operand\" \"rIJ\")]))\n-   (clobber (match_scratch:SI 4 \"=&r\"))]\n-  \"! TARGET_SHIFTER\"\n-  \"* return output_shift (operands);\"\n-  [(set_attr \"type\" \"shift\")\n-   (set_attr \"length\" \"8\")])\n-\f\n-;; Compare instructions.\n-;; This controls RTL generation and register allocation.\n-\n-;; ??? We may be able to relax this a bit by adding a new constant 'K' for 0.\n-;; This assumes sub.f 0,symbol,0 is a valid insn.\n-;; Note that \"sub.f 0,r0,1\" is an 8 byte insn.  To avoid unnecessarily\n-;; creating 8 byte insns we duplicate %1 in the destination reg of the insn\n-;; if it's a small constant.\n-\n-(define_insn \"*cmpsi_cc_insn\"\n-  [(set (reg:CC 61)\n-\t(compare:CC (match_operand:SI 0 \"register_operand\" \"r,r,r\")\n-\t\t    (match_operand:SI 1 \"nonmemory_operand\" \"r,I,J\")))]\n-  \"\"\n-  \"@\n-   sub.f 0,%0,%1\n-   sub.f %1,%0,%1\n-   sub.f 0,%0,%1\"\n-  [(set_attr \"type\" \"compare,compare,compare\")])\n-\n-(define_insn \"*cmpsi_cczn_insn\"\n-  [(set (reg:CCZN 61)\n-\t(compare:CCZN (match_operand:SI 0 \"register_operand\" \"r,r,r\")\n-\t\t      (match_operand:SI 1 \"nonmemory_operand\" \"r,I,J\")))]\n-  \"\"\n-  \"@\n-   sub.f 0,%0,%1\n-   sub.f %1,%0,%1\n-   sub.f 0,%0,%1\"\n-  [(set_attr \"type\" \"compare,compare,compare\")])\n-\n-(define_insn \"*cmpsi_ccznc_insn\"\n-  [(set (reg:CCZNC 61)\n-\t(compare:CCZNC (match_operand:SI 0 \"register_operand\" \"r,r,r\")\n-\t\t       (match_operand:SI 1 \"nonmemory_operand\" \"r,I,J\")))]\n-  \"\"\n-  \"@\n-   sub.f 0,%0,%1\n-   sub.f %1,%0,%1\n-   sub.f 0,%0,%1\"\n-  [(set_attr \"type\" \"compare,compare,compare\")])\n-\n-;; Next come the scc insn and its expander.\n-\n-(define_expand \"cstoresi4\"\n-  [(set (match_dup 4)\n-        (match_op_dup 5\n-         [(match_operand:SI 2 \"register_operand\" \"\")\n-          (match_operand:SI 3 \"nonmemory_operand\" \"\")]))\n-   (set (match_operand:SI 0 \"register_operand\")\n-        (match_operator:SI 1 \"ordered_comparison_operator\"\n-\t [(match_dup 4)\n-\t  (const_int 0)]))]\n-  \"\"\n-  \"\n-{\n-  operands[4] = gen_compare_reg (GET_CODE (operands[1]),\n-\t\t\t\t operands[2], operands[3]);\n-  operands[5] = gen_rtx_fmt_ee (COMPARE,\n-\t\t\t\tGET_MODE (operands[4]),\n-\t\t\t\toperands[2], operands[3]);\n-}\")\n-\n-(define_insn \"*scc_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operator:SI 1 \"comparison_operator\" [(reg 61) (const_int 0)]))]\n-  \"\"\n-  \"mov %0,1\\;sub.%D1 %0,%0,%0\"\n-  [(set_attr \"type\" \"unary\")\n-   (set_attr \"length\" \"2\")])\n-\n-;; ??? Look up negscc insn.  See pa.md for example.\n-(define_insn \"*neg_scc_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(neg:SI (match_operator:SI 1 \"comparison_operator\"\n-\t\t [(reg 61) (const_int 0)])))]\n-  \"\"\n-  \"mov %0,-1\\;sub.%D1 %0,%0,%0\"\n-  [(set_attr \"type\" \"unary\")\n-   (set_attr \"length\" \"2\")])\n-\n-(define_insn \"*not_scc_insn\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(not:SI (match_operator:SI 1 \"comparison_operator\"\n-\t\t [(reg 61) (const_int 0)])))]\n-  \"\"\n-  \"mov %0,1\\;sub.%d1 %0,%0,%0\"\n-  [(set_attr \"type\" \"unary\")\n-   (set_attr \"length\" \"2\")])\n-\f\n-;; These control RTL generation for conditional jump insns\n-\n-(define_expand \"cbranchsi4\"\n-  [(set (match_dup 4)\n-        (match_op_dup 5\n-\t [(match_operand:SI 1 \"register_operand\" \"\")\n-          (match_operand:SI 2 \"nonmemory_operand\" \"\")]))\n-   (set (pc)\n-        (if_then_else\n-              (match_operator 0 \"ordered_comparison_operator\"\n-\t       [(match_dup 4)\n-\t\t(const_int 0)])\n-              (label_ref (match_operand 3 \"\" \"\"))\n-              (pc)))]\n-  \"\"\n-  \"\n-{\n-  operands[4] = gen_compare_reg (GET_CODE (operands[0]),\n-\t\t\t\t operands[1], operands[2]);\n-  operands[5] = gen_rtx_fmt_ee (COMPARE,\n-\t\t\t\tGET_MODE (operands[4]),\n-\t\t\t\toperands[1], operands[2]);\n-}\")\n-\n-;; Now match both normal and inverted jump.\n-\n-(define_insn \"*branch_insn\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 1 \"proper_comparison_operator\"\n-\t\t\t\t      [(reg 61) (const_int 0)])\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-{\n-  if (arc_ccfsm_branch_deleted_p ())\n-    {\n-      arc_ccfsm_record_branch_deleted ();\n-      return \\\"; branch deleted, next insns conditionalized\\\";\n-    }\n-  else\n-    return \\\"%~b%d1%# %l0\\\";\n-}\"\n-  [(set_attr \"type\" \"branch\")])\n-\n-(define_insn \"*rev_branch_insn\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 1 \"proper_comparison_operator\"\n-\t\t\t\t      [(reg 61) (const_int 0)])\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"REVERSIBLE_CC_MODE (GET_MODE (XEXP (operands[1], 0)))\"\n-  \"*\n-{\n-  if (arc_ccfsm_branch_deleted_p ())\n-    {\n-      arc_ccfsm_record_branch_deleted ();\n-      return \\\"; branch deleted, next insns conditionalized\\\";\n-    }\n-  else\n-    return \\\"%~b%D1%# %l0\\\";\n-}\"\n-  [(set_attr \"type\" \"branch\")])\n-\f\n-;; Unconditional and other jump instructions.\n-\n-(define_insn \"jump\"\n-  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n-  \"\"\n-  \"b%* %l0\"\n-  [(set_attr \"type\" \"uncond_branch\")])\n-\n-(define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))]\n-  \"\"\n-  \"j%* %a0\"\n-  [(set_attr \"type\" \"uncond_branch\")])\n- \n-;; Implement a switch statement.\n-;; This wouldn't be necessary in the non-pic case if we could distinguish\n-;; label refs of the jump table from other label refs.  The problem is that\n-;; label refs are output as \"%st(.LL42)\" but we don't want the %st - we want\n-;; the real address since it's the address of the table.\n-\n-(define_expand \"casesi\"\n-  [(set (match_dup 5)\n-\t(minus:SI (match_operand:SI 0 \"register_operand\" \"\")\n-\t\t  (match_operand:SI 1 \"nonmemory_operand\" \"\")))\n-   (set (reg:CC 61)\n-\t(compare:CC (match_dup 5)\n-\t\t    (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n-   (set (pc)\n-\t(if_then_else (gtu (reg:CC 61)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 4 \"\" \"\"))\n-\t\t      (pc)))\n-   (parallel\n-    [(set (pc)\n-\t  (mem:SI (plus:SI (mult:SI (match_dup 5)\n-\t\t\t\t    (const_int 4))\n-\t\t\t   (label_ref (match_operand 3 \"\" \"\")))))\n-     (clobber (match_scratch:SI 6 \"\"))\n-     (clobber (match_scratch:SI 7 \"\"))])]\n-  \"\"\n-  \"\n-{\n-  operands[5] = gen_reg_rtx (SImode);\n-}\")\n-\n-(define_insn \"*casesi_insn\"\n-  [(set (pc)\n-\t(mem:SI (plus:SI (mult:SI (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t\t  (const_int 4))\n-\t\t\t (label_ref (match_operand 1 \"\" \"\")))))\n-   (clobber (match_scratch:SI 2 \"=r\"))\n-   (clobber (match_scratch:SI 3 \"=r\"))]\n-  \"\"\n-  \"*\n-{\n-  output_asm_insn (\\\"mov %2,%1\\\", operands);\n-  if (TARGET_SHIFTER)\n-    output_asm_insn (\\\"asl %3,%0,2\\\", operands);\n-  else\n-    output_asm_insn (\\\"asl %3,%0\\;asl %3,%3\\\", operands);\n-  output_asm_insn (\\\"ld %2,[%2,%3]\\\", operands);\n-  output_asm_insn (\\\"j.nd %a2\\\", operands);\n-  return \\\"\\\";\n-}\"\n-  [(set_attr \"type\" \"uncond_branch\")\n-   (set_attr \"length\" \"6\")])\n-\n-(define_insn \"tablejump\"\n-  [(set (pc) (match_operand:SI 0 \"address_operand\" \"p\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"0 /* disabled -> using casesi now */\"\n-  \"j%* %a0\"\n-  [(set_attr \"type\" \"uncond_branch\")])\n-\n-(define_expand \"call\"\n-  ;; operands[1] is stack_size_rtx\n-  ;; operands[2] is next_arg_register\n-  [(parallel [(call (match_operand:SI 0 \"call_operand\" \"\")\n-\t\t    (match_operand 1 \"\" \"\"))\n-\t     (clobber (reg:SI 31))])]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*call_via_reg\"\n-  [(call (mem:SI (match_operand:SI 0 \"register_operand\" \"r\"))\n-\t (match_operand 1 \"\" \"\"))\n-   (clobber (reg:SI 31))]\n-  \"\"\n-  \"lr blink,[status]\\;j.d %0\\;add blink,blink,2\"\n-  [(set_attr \"type\" \"call_no_delay_slot\")\n-   (set_attr \"length\" \"3\")])\n-\n-(define_insn \"*call_via_label\"\n-  [(call (mem:SI (match_operand:SI 0 \"call_address_operand\" \"\"))\n-\t (match_operand 1 \"\" \"\"))\n-   (clobber (reg:SI 31))]\n-  \"\"\n-  ; The %~ is necessary in case this insn gets conditionalized and the previous\n-  ; insn is the cc setter.\n-  \"%~bl%!%* %0\"\n-  [(set_attr \"type\" \"call\")\n-   (set_attr \"cond\" \"canuse\")])\n-\n-(define_expand \"call_value\"\n-  ;; operand 2 is stack_size_rtx\n-  ;; operand 3 is next_arg_register\n-  [(parallel [(set (match_operand 0 \"register_operand\" \"=r\")\n-\t\t   (call (match_operand:SI 1 \"call_operand\" \"\")\n-\t\t\t (match_operand 2 \"\" \"\")))\n-\t     (clobber (reg:SI 31))])]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"*call_value_via_reg\"\n-  [(set (match_operand 0 \"register_operand\" \"=r\")\n-\t(call (mem:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t      (match_operand 2 \"\" \"\")))\n-   (clobber (reg:SI 31))]\n-  \"\"\n-  \"lr blink,[status]\\;j.d %1\\;add blink,blink,2\"\n-  [(set_attr \"type\" \"call_no_delay_slot\")\n-   (set_attr \"length\" \"3\")])\n-\n-(define_insn \"*call_value_via_label\"\n-  [(set (match_operand 0 \"register_operand\" \"=r\")\n-\t(call (mem:SI (match_operand:SI 1 \"call_address_operand\" \"\"))\n-\t      (match_operand 2 \"\" \"\")))\n-   (clobber (reg:SI 31))]\n-  \"\"\n-  ; The %~ is necessary in case this insn gets conditionalized and the previous\n-  ; insn is the cc setter.\n-  \"%~bl%!%* %1\"\n-  [(set_attr \"type\" \"call\")\n-   (set_attr \"cond\" \"canuse\")])\n-\f\n-(define_insn \"nop\"\n-  [(const_int 0)]\n-  \"\"\n-  \"nop\"\n-  [(set_attr \"type\" \"misc\")])\n-\n-;; Special pattern to flush the icache.\n-;; ??? Not sure what to do here.  Some ARC's are known to support this.\n-\n-(define_insn \"flush_icache\"\n-  [(unspec_volatile [(match_operand 0 \"memory_operand\" \"m\")] 0)]\n-  \"\"\n-  \"* return \\\"\\\";\"\n-  [(set_attr \"type\" \"misc\")])\n-\f\n-;; Split up troublesome insns for better scheduling.\n-\f\n-;; Peepholes go at the end."}, {"sha": "e5381f95afc7983182625e788010ba5bfd07b9b0", "filename": "gcc/config/arc/arc.opt", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farc%2Farc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farc%2Farc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.opt?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,60 +0,0 @@\n-; Options for the Argonaut ARC port of the compiler\n-;\n-; Copyright (C) 2005, 2007, 2011 Free Software Foundation, Inc.\n-;\n-; This file is part of GCC.\n-;\n-; GCC is free software; you can redistribute it and/or modify it under\n-; the terms of the GNU General Public License as published by the Free\n-; Software Foundation; either version 3, or (at your option) any later\n-; version.\n-;\n-; GCC is distributed in the hope that it will be useful, but WITHOUT\n-; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-; License for more details.\n-;\n-; You should have received a copy of the GNU General Public License\n-; along with GCC; see the file COPYING3.  If not see\n-; <http://www.gnu.org/licenses/>.\n-\n-EB\n-Driver\n-\n-EL\n-Driver\n-\n-malign-loops\n-Target Undocumented Report Mask(ALIGN_LOOPS)\n-\n-mbig-endian\n-Target Undocumented Report RejectNegative Mask(BIG_ENDIAN)\n-\n-mlittle-endian\n-Target Undocumented Report RejectNegative InverseMask(BIG_ENDIAN)\n-\n-mmangle-cpu\n-Target Report Mask(MANGLE_CPU)\n-Prepend the name of the cpu to all public symbol names\n-\n-; mmangle-cpu-libgcc\n-; Target Undocumented Mask(MANGLE_CPU_LIBGC)\n-\n-mno-cond-exec\n-Target Undocumented Report RejectNegative Mask(NO_COND_EXEC)\n-\n-mcpu=\n-Target RejectNegative Joined Var(arc_cpu_string) Init(\"base\")\n--mcpu=CPU\tCompile code for ARC variant CPU\n-\n-mtext=\n-Target RejectNegative Joined Var(arc_text_string) Init(ARC_DEFAULT_TEXT_SECTION)\n--mtext=SECTION\tPut functions in SECTION\n-\n-mdata=\n-Target RejectNegative Joined Var(arc_data_string) Init(ARC_DEFAULT_DATA_SECTION)\n--mdata=SECTION\tPut data in SECTION\n-\n-mrodata=\n-Target RejectNegative Joined Var(arc_rodata_string) Init(ARC_DEFAULT_RODATA_SECTION)\n--mrodata=SECTION\tPut read-only data in SECTION"}, {"sha": "d7514133a36d3253137754df0f156dfc58e3dddc", "filename": "gcc/config/arc/initfini.c", "status": "removed", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farc%2Finitfini.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farc%2Finitfini.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Finitfini.c?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,155 +0,0 @@\n-/* .init/.fini section handling + C++ global constructor/destructor handling.\n-   This file is based on crtstuff.c, sol2-crti.asm, sol2-crtn.asm.\n-\n-Copyright (C) 1995, 1997, 1998, 2009 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/*  Declare a pointer to void function type.  */\n-typedef void (*func_ptr) (void);\n-\n-#ifdef CRT_INIT\n-\n-/* NOTE:  In order to be able to support SVR4 shared libraries, we arrange\n-   to have one set of symbols { __CTOR_LIST__, __DTOR_LIST__, __CTOR_END__,\n-   __DTOR_END__ } per root executable and also one set of these symbols\n-   per shared library.  So in any given whole process image, we may have\n-   multiple definitions of each of these symbols.  In order to prevent\n-   these definitions from conflicting with one another, and in order to\n-   ensure that the proper lists are used for the initialization/finalization\n-   of each individual shared library (respectively), we give these symbols\n-   only internal (i.e. `static') linkage, and we also make it a point to\n-   refer to only the __CTOR_END__ symbol in crtfini.o and the __DTOR_LIST__\n-   symbol in crtinit.o, where they are defined.  */\n-\n-static func_ptr __CTOR_LIST__[1] __attribute__ ((section (\".ctors\")))\n-     = { (func_ptr) (-1) };\n-\n-static func_ptr __DTOR_LIST__[1] __attribute__ ((section (\".dtors\")))\n-     = { (func_ptr) (-1) };\n-\n-/* Run all the global destructors on exit from the program.  */\n- \n-/* Some systems place the number of pointers in the first word of the\n-   table.  On SVR4 however, that word is -1.  In all cases, the table is\n-   null-terminated.  On SVR4, we start from the beginning of the list and\n-   invoke each per-compilation-unit destructor routine in order\n-   until we find that null.\n-\n-   Note that this function MUST be static.  There will be one of these\n-   functions in each root executable and one in each shared library, but\n-   although they all have the same code, each one is unique in that it\n-   refers to one particular associated `__DTOR_LIST__' which belongs to the\n-   same particular root executable or shared library file.  */\n-\n-static void __do_global_dtors (void)\n-asm (\"__do_global_dtors\") __attribute__ ((section (\".text\")));\n-\n-static void\n-__do_global_dtors (void)\n-{\n-  func_ptr *p;\n-  for (p = __DTOR_LIST__ + 1; *p; p++)\n-    (*p) ();\n-}\n-\n-/* .init section start.\n-   This must appear at the start of the .init section.  */\n-\n-asm (\"\\n\\\n-\t.section .init\\n\\\n-\t.global init\\n\\\n-\t.word 0\\n\\\n-init:\\n\\\n-\tst blink,[sp,4]\\n\\\n-\tst fp,[sp]\\n\\\n-\tmov fp,sp\\n\\\n-\tsub sp,sp,16\\n\\\n-\");\n-\n-/* .fini section start.\n-   This must appear at the start of the .init section.  */\n-\n-asm (\"\\n\\\n-\t.section .fini\\n\\\n-\t.global fini\\n\\\n-\t.word 0\\n\\\n-fini:\\n\\\n-\tst blink,[sp,4]\\n\\\n-\tst fp,[sp]\\n\\\n-\tmov fp,sp\\n\\\n-\tsub sp,sp,16\\n\\\n-\tbl.nd __do_global_dtors\\n\\\n-\");\n-\n-#endif /* CRT_INIT */\n-\n-#ifdef CRT_FINI\n-\n-/* Put a word containing zero at the end of each of our two lists of function\n-   addresses.  Note that the words defined here go into the .ctors and .dtors\n-   sections of the crtend.o file, and since that file is always linked in\n-   last, these words naturally end up at the very ends of the two lists\n-   contained in these two sections.  */\n-\n-static func_ptr __CTOR_END__[1] __attribute__ ((section (\".ctors\")))\n-     = { (func_ptr) 0 };\n-\n-static func_ptr __DTOR_END__[1] __attribute__ ((section (\".dtors\")))\n-     = { (func_ptr) 0 };\n-\n-/* Run all global constructors for the program.\n-   Note that they are run in reverse order.  */\n-\n-static void __do_global_ctors (void)\n-asm (\"__do_global_ctors\") __attribute__ ((section (\".text\")));\n-\n-static void\n-__do_global_ctors (void)\n-{\n-  func_ptr *p;\n-  for (p = __CTOR_END__ - 1; *p != (func_ptr) -1; p--)\n-    (*p) ();\n-}\n-\n-/* .init section end.\n-   This must live at the end of the .init section.  */\n-\n-asm (\"\\n\\\n-\t.section .init\\n\\\n-\tbl.nd __do_global_ctors\\n\\\n-\tld blink,[fp,4]\\n\\\n-\tj.d blink\\n\\\n-\tld.a fp,[sp,16]\\n\\\n-\");\n-\n-/* .fini section end.\n-   This must live at the end of the .fini section.  */\n-\n-asm (\"\\n\\\n-\t.section .fini\\n\\\n-\tld blink,[fp,4]\\n\\\n-\tj.d blink\\n\\\n-\tld.a fp,[sp,16]\\n\\\n-\");\n-\n-#endif /* CRT_FINI */"}, {"sha": "c61f39a5ca701eb679bc3ab2a413c6ee939e1ec2", "filename": "gcc/config/arc/lib1funcs.asm", "status": "removed", "additions": 0, "deletions": 266, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farc%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farc%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Flib1funcs.asm?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,266 +0,0 @@\n-; libgcc routines for ARC cpu.\n-\n-/* Copyright (C) 1995, 1997,2004, 2009 Free Software Foundation, Inc.\n-\n-This file is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 3, or (at your option) any\n-later version.\n-\n-This file is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifdef  L_mulsi3\n-\t.section .text\n-\t.align 4\n-\n-#ifdef __base__\n-\t.cpu base\n-\t.global ___mulsi3\n-___mulsi3:\n-\n-/* This the simple version.\n-\n-  while (a) \n-    {\n-      if (a & 1)\n-        r += b;\n-      a >>= 1;\n-      b <<= 1;\n-    }\n-*/\n-\tmov r2,0\t\t; Accumulate result here.\n-.Lloop:\n-\tsub.f 0,r0,0\t\t; while (a)\n-\tnop\n-\tbeq.nd .Ldone\n-\tand.f 0,r0,1\t\t; if (a & 1)\n-\tadd.nz r2,r2,r1\t\t; r += b\n-\tlsr r0,r0\t\t; a >>= 1\n-\tb.d .Lloop\n-\tlsl r1,r1\t\t; b <<= 1\n-.Ldone:\n-\tj.d blink\n-\tmov r0,r2\n-#endif\n-\n-#endif /* L_mulsi3 */\n-\n-#ifdef  L_umulsidi3\n-\t.section .text\n-\t.align 4\n-\n-#ifdef __base__\n-\t.cpu base\n-\t.global ___umulsidi3\n-___umulsidi3:\n-\n-/* This the simple version.\n-\n-  while (a) \n-    {\n-      if (a & 1)\n-        r += b;\n-      a >>= 1;\n-      b <<= 1;\n-    }\n-*/\n-\tmov r2,0\t\t; Top part of b.\n-\tmov r3,0\t\t; Accumulate result here.\n-\tmov r4,0\n-.Lloop:\n-\tsub.f 0,r0,0\t\t; while (a)\n-\tnop\n-\tbeq.nd .Ldone\n-\tand.f 0,r0,1\t\t; if (a & 1)\n-\tsub.f 0,r0,0\n-\tnop\n-\tbeq .Ldontadd\n-\tadd.f r4,r4,r1\t\t; r += b\n-\tadc   r3,r3,r2\n-.Ldontadd:\n-\tlsr r0,r0\t\t; a >>= 1\n-\tlsl.f r1,r1\t\t; b <<= 1\n-\tb.d .Lloop\n-\trlc r2,r2\n-.Ldone:\n-#ifdef __big_endian__\n-\tmov r1,r4\n-\tj.d blink\n-\tmov r0,r3\n-#else\n-\tmov r0,r4\n-\tj.d blink\n-\tmov r1,r3\n-#endif\n-#endif\n-\n-#endif /* L_umulsidi3 */\n-\n-#ifdef L_divmod_tools\n-\n-; Utilities used by all routines.\n-\n-\t.section .text\n-\t.align 4\n-\n-; inputs: r0 = numerator, r1 = denominator\n-; outputs: positive r0/r1,\n-;          r6.bit1 = sign of numerator, r6.bit0 = sign of result\n-\n-\t.global ___divnorm\n-___divnorm:\n-\tmov r6,0\t\t; keep sign in r6\n-\tsub.f 0,r0,0\t\t; is numerator -ve?\n-\tsub.lt r0,0,r0\t\t; negate numerator\n-\tmov.lt r6,3\t\t; sign is -ve\n-\tsub.f 0,r1,0\t\t; is denominator -ve?\n-\tsub.lt r1,0,r1\t\t; negate denominator\n-\txor.lt r6,r6,1\t\t; toggle sign\n-\tj.nd blink\n-\n-/*\n-unsigned long\n-udivmodsi4(int modwanted, unsigned long num, unsigned long den)\n-{\n-  unsigned long bit = 1;\n-  unsigned long res = 0;\n-\n-  while (den < num && bit && !(den & (1L<<31)))\n-    {\n-      den <<=1;\n-      bit <<=1;\n-    }\n-  while (bit)\n-    {\n-      if (num >= den)\n-\t{\n-\t  num -= den;\n-\t  res |= bit;\n-\t}\n-      bit >>=1;\n-      den >>=1;\n-    }\n-  if (modwanted) return num;\n-  return res;\n-}\n-*/\n-\n-; inputs: r0 = numerator, r1 = denominator\n-; outputs: r0 = quotient, r1 = remainder, r2/r3 trashed\n-\n-\t.global ___udivmodsi4\n-___udivmodsi4:\n-\tmov r2,1\t\t; bit = 1\n-\tmov r3,0\t\t; res = 0\n-.Lloop1:\n-\tsub.f 0,r1,r0\t\t; while (den < num\n-\tnop\n-\tbnc.nd .Lloop2\n-\tsub.f 0,r2,0\t\t; && bit\n-\tnop\n-\tbz.nd .Lloop2\n-\tlsl.f 0,r1\t\t; && !(den & (1<<31))\n-\tnop\n-\tbc.nd .Lloop2\n-\tlsl r1,r1\t\t; den <<= 1\n-\tb.d .Lloop1\n-\tlsl r2,r2\t\t; bit <<= 1\n-.Lloop2:\n-\tsub.f 0,r2,0\t\t; while (bit)\n-\tnop\n-\tbz.nd .Ldivmodend\n-\tsub.f 0,r0,r1\t\t; if (num >= den)\n-\tnop\n-\tbc.nd .Lshiftdown\n-\tsub r0,r0,r1\t\t; num -= den\n-\tor r3,r3,r2\t\t; res |= bit\n-.Lshiftdown:\n-\tlsr r2,r2\t\t; bit >>= 1\n-\tb.d .Lloop2\n-\tlsr r1,r1\t\t; den >>= 1\n-.Ldivmodend:\n-\tmov r1,r0\t\t; r1 = mod\n-\tj.d blink\n-\tmov r0,r3\t\t; r0 = res\n-\n-#endif\n-\n-#ifdef  L_udivsi3\n-\t.section .text\n-\t.align 4\n-\n-#ifdef __base__\n-\t.cpu base\n-\t.global ___udivsi3\n-___udivsi3:\n-\tmov r7,blink\n-\tbl.nd ___udivmodsi4\n-\tj.nd r7\n-#endif\n-\n-#endif /* L_udivsi3 */\n-\n-#ifdef  L_divsi3\n-\t.section .text\n-\t.align 4\n-\n-#ifdef __base__\n-\t.cpu base\n-\t.global ___divsi3\n-___divsi3:\n-\tmov r7,blink\n-\tbl.nd ___divnorm\n-\tbl.nd ___udivmodsi4\n-\tand.f 0,r6,1\n-\tsub.nz r0,0,r0\t\t; cannot go in delay slot, has limm value\n-\tj.nd r7\n-#endif\n-\n-#endif /* L_divsi3 */\n-\n-#ifdef  L_umodsi3\n-\t.section .text\n-\t.align 4\n-\n-#ifdef __base__\n-\t.cpu base\n-\t.global ___umodsi3\n-___umodsi3:\n-\tmov r7,blink\n-\tbl.nd ___udivmodsi4\n-\tj.d r7\n-\tmov r0,r1\n-#endif\n-\n-#endif /* L_umodsi3 */\n-\n-#ifdef  L_modsi3\n-\t.section .text\n-\t.align 4\n-\n-#ifdef __base__\n-\t.cpu base\n-\t.global ___modsi3\n-___modsi3:\n-\tmov r7,blink\n-\tbl.nd ___divnorm\n-\tbl.nd ___udivmodsi4\n-\tand.f 0,r6,2\n-\tsub.nz r1,0,r1\n-\tj.d r7\n-\tmov r0,r1\n-#endif\n-\n-#endif /* L_modsi3 */"}, {"sha": "a923479ca09646121a13f55bc6ed91787db40abe", "filename": "gcc/config/arc/t-arc", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farc%2Ft-arc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farc%2Ft-arc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Ft-arc?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,60 +0,0 @@\n-# Copyright (C) 1997, 1998, 1999, 2001, 2002, 2003,\n-# 2004 Free Software Foundation, Inc.\n-#\n-# This file is part of GCC.\n-#\n-# GCC is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3, or (at your option)\n-# any later version.\n-#\n-# GCC is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with GCC; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-LIB1ASMSRC = arc/lib1funcs.asm\n-LIB1ASMFUNCS = _mulsi3 _umulsidi3 _udivsi3 _divsi3 _umodsi3 _modsi3 _divmod_tools\n-\n-# We need libgcc routines to be mangled according to which cpu they\n-# were compiled for.\n-# ??? -mmangle-cpu passed by default for now.\n-#LIBGCC2_CFLAGS = -g1 -O2 $(LIBGCC2_INCLUDES) $(GCC_CFLAGS) -mmangle-cpu\n-\n-# We want fine grained libraries, so use the new code to build the\n-# floating point emulation libraries.\n-FPBIT = fp-bit.c\n-DPBIT = dp-bit.c\n-\n-dp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#ifndef __big_endian__' > dp-bit.c\n-\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> dp-bit.c\n-\techo '#endif' >> dp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define FLOAT' > fp-bit.c\n-\techo '#ifndef __big_endian__' >> fp-bit.c\n-\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c\n-\techo '#endif' >> fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n-\n-# .init/.fini section routines\n-\n-$(T)crtinit.o: $(srcdir)/config/arc/initfini.c $(GCC_PASSES) $(CONFIG_H)\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(CRTSTUFF_T_CFLAGS) \\\n-\t $(MULTILIB_CFLAGS) -DCRT_INIT -finhibit-size-directive -fno-inline-functions \\\n-\t -g0 -c $(srcdir)/config/arc/initfini.c -o $(T)crtinit.o\n-\n-$(T)crtfini.o: $(srcdir)/config/arc/initfini.c $(GCC_PASSES) $(CONFIG_H)\n-\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) $(CRTSTUFF_T_CFLAGS) \\\n-\t -DCRT_FINI $(MULTILIB_CFLAGS) -finhibit-size-directive -fno-inline-functions \\\n-\t -g0 -c $(srcdir)/config/arc/initfini.c -o $(T)crtfini.o\n-\n-MULTILIB_OPTIONS = EB\n-MULTILIB_DIRNAMES = be\n-EXTRA_MULTILIB_PARTS = crtinit.o crtfini.o"}, {"sha": "4a1adbae9915c85ac5c5d303e1891af61faa4e77", "filename": "gcc/config/arm/netbsd.h", "status": "removed", "additions": 0, "deletions": 150, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farm%2Fnetbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farm%2Fnetbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fnetbsd.h?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,150 +0,0 @@\n-/* NetBSD/arm a.out version.\n-   Copyright (C) 1993, 1994, 1997, 1998, 2003, 2004, 2005, 2007, 2008, 2010\n-   Free Software Foundation, Inc.\n-   Contributed by Mark Brinicombe (amb@physig.ph.kcl.ac.uk)\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* Run-time Target Specification.  */\n-#undef  TARGET_VERSION\n-#define TARGET_VERSION fputs (\" (ARM/NetBSD)\", stderr);\n-\n-/* Unsigned chars produces much better code than signed.  */\n-#define DEFAULT_SIGNED_CHAR  0\n-\n-/* Since we always use GAS as our assembler we support stabs.  */\n-#define DBX_DEBUGGING_INFO 1\n-\n-/*#undef ASM_DECLARE_FUNCTION_NAME*/\n-\n-/* ARM6 family default cpu.  */\n-#define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm6\n-\n-#undef TARGET_DEFAULT\n-#define TARGET_DEFAULT (MASK_APCS_FRAME)\n-\n-/* Some defines for CPP.\n-   arm32 is the NetBSD port name, so we always define arm32 and __arm32__.  */\n-#define TARGET_OS_CPP_BUILTINS()\t\t\\\n-    do {\t\t\t\t\t\\\n-\tNETBSD_OS_CPP_BUILTINS_AOUT();\t\t\\\n-\tbuiltin_define_std (\"arm32\");\t\t\\\n-\tbuiltin_define_std (\"unix\");\t\t\\\n-\tbuiltin_define_std (\"riscbsd\");\t\t\\\n-    } while (0)\n-\n-#undef SUBTARGET_EXTRA_SPECS\n-#define SUBTARGET_EXTRA_SPECS \\\n-  { \"netbsd_cpp_spec\",  NETBSD_CPP_SPEC }, \\\n-  { \"netbsd_link_spec\", NETBSD_LINK_SPEC_AOUT },\n-\n-#undef CPP_SPEC\n-#define CPP_SPEC \"\\\n-%(cpp_cpu_arch) %(cpp_float) %(cpp_endian) %(netbsd_cpp_spec) \\\n-\"\n-\n-/* Because TARGET_DEFAULT sets MASK_SOFT_FLOAT */\n-#undef CPP_FLOAT_DEFAULT_SPEC\n-#define CPP_FLOAT_DEFAULT_SPEC \"-D__SOFTFP__\"\n-\n-/* Pass -X to the linker so that it will strip symbols starting with 'L' */\n-#undef LINK_SPEC\n-#define LINK_SPEC \"-X %(netbsd_link_spec)\"\n-\n-#undef SIZE_TYPE\n-#define SIZE_TYPE \"unsigned int\"\n-\n-#undef PTRDIFF_TYPE\n-#define PTRDIFF_TYPE \"int\"\n-\n-/* We don't have any limit on the length as out debugger is GDB.  */\n-#undef DBX_CONTIN_LENGTH\n-\n-/* NetBSD does its profiling differently to the Acorn compiler. We\n-   don't need a word following the mcount call; and to skip it\n-   requires either an assembly stub or use of fomit-frame-pointer when\n-   compiling the profiling functions.  Since we break Acorn CC\n-   compatibility below a little more won't hurt.  */\n-\n-#undef  ARM_FUNCTION_PROFILER\n-#define ARM_FUNCTION_PROFILER(STREAM,LABELNO)  \t\t\t\t    \\\n-{\t\t\t\t\t\t\t\t\t    \\\n-  fprintf(STREAM, \"\\tmov\\t%sip, %slr\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n-  fprintf(STREAM, \"\\tbl\\tmcount\\n\");\t\t\t\t\t    \\\n-}\n-\n-/* On the ARM `@' introduces a comment, so we must use something else\n-   for .type directives.  */\n-#undef TYPE_OPERAND_FMT\n-#define TYPE_OPERAND_FMT \"%%%s\"\n-\n-/* NetBSD uses the old PCC style aggregate returning conventions.  */\n-#undef DEFAULT_PCC_STRUCT_RETURN\n-#define DEFAULT_PCC_STRUCT_RETURN 1\n-\n-/* Although not normally relevant (since by default, all aggregates\n-   are returned in memory) compiling some parts of libc requires\n-   non-APCS style struct returns.  */\n-#undef TARGET_RETURN_IN_MEMORY\n-\n-/* VERY BIG NOTE : Change of structure alignment for RiscBSD.\n-   There are consequences you should be aware of...\n-\n-   Normally GCC/arm uses a structure alignment of 32 for compatibility\n-   with armcc.  This means that structures are padded to a word\n-   boundary.  However this causes problems with bugged NetBSD kernel\n-   code (possibly userland code as well - I have not checked every\n-   binary).  The nature of this bugged code is to rely on sizeof()\n-   returning the correct size of various structures rounded to the\n-   nearest byte (SCSI and ether code are two examples, the vm system\n-   is another).  This code breaks when the structure alignment is 32\n-   as sizeof() will report a word=rounded size.  By changing the\n-   structure alignment to 8. GCC will conform to what is expected by\n-   NetBSD.\n-\n-   This has several side effects that should be considered.\n-   1. Structures will only be aligned to the size of the largest member.\n-      i.e. structures containing only bytes will be byte aligned.\n-           structures containing shorts will be half word aligned.\n-           structures containing ints will be word aligned.\n-\n-      This means structures should be padded to a word boundary if\n-      alignment of 32 is required for byte structures etc.\n-      \n-   2. A potential performance penalty may exist if strings are no longer\n-      word aligned.  GCC will not be able to use word load/stores to copy\n-      short strings.\n-      \n-   This modification is not encouraged but with the present state of the\n-   NetBSD source tree it is currently the only solution that meets the\n-   requirements.  */\n-#undef  DEFAULT_STRUCTURE_SIZE_BOUNDARY\n-#define DEFAULT_STRUCTURE_SIZE_BOUNDARY 8\n-\n-/* Clear the instruction cache from `BEG' to `END'.  This makes a\n-   call to the ARM32_SYNC_ICACHE architecture specific syscall.  */\n-#define CLEAR_INSN_CACHE(BEG, END)                                     \\\n-{                                                                      \\\n-  extern int sysarch(int number, void *args);                          \\\n-  struct {                                                             \\\n-    unsigned int  addr;                                                \\\n-    int           len;                                                 \\\n-  } s;                                                                 \\\n-  s.addr = (unsigned int)(BEG);                                        \\\n-  s.len = (END) - (BEG);                                               \\\n-  (void)sysarch(0, &s);                                                \\\n-}"}, {"sha": "626b1d29a1250187a62f90fca0b3853857ac2b13", "filename": "gcc/config/arm/t-pe", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farm%2Ft-pe", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Farm%2Ft-pe", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-pe?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,52 +0,0 @@\n-# Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006, 2008, 2009,\n-# 2010\n-# Free Software Foundation, Inc.\n-#\n-# This file is part of GCC.\n-#\n-# GCC is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3, or (at your option)\n-# any later version.\n-#\n-# GCC is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with GCC; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-LIB1ASMFUNCS += _udivsi3 _divsi3 _umodsi3 _modsi3 _dvmd_tls _call_via_rX _interwork_call_via_rX _clzsi2 _clzdi2\n-\n-# We want fine grained libraries, so use the new code to build the\n-# floating point emulation libraries.\n-FPBIT = fp-bit.c\n-DPBIT = dp-bit.c\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define FLOAT' > fp-bit.c\n-\techo '#ifndef __ARMEB__' >> fp-bit.c\n-\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> fp-bit.c\n-\techo '#endif' >> fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n-\n-dp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#ifndef __ARMEB__' > dp-bit.c\n-\techo '#define FLOAT_BIT_ORDER_MISMATCH' >> dp-bit.c\n-\techo '#define FLOAT_WORD_ORDER_MISMATCH' >> dp-bit.c\n-\techo '#endif' >> dp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n-\n-pe.o: $(srcdir)/config/arm/pe.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-  $(RTL_H) output.h flags.h $(TREE_H) expr.h $(TM_P_H)\n-\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n-\t\t$(srcdir)/config/arm/pe.c\n-\n-MULTILIB_OPTIONS = mhard-float mthumb\n-MULTILIB_DIRNAMES = fpu thumb\n-\n-LIBGCC = stmp-multilib\n-INSTALL_LIBGCC = install-multilib\n-TARGET_LIBGCC2_CFLAGS = "}, {"sha": "aeb4bdd594a339fba5fe812ee466dec94ca43ff4", "filename": "gcc/config/crx/crx-protos.h", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fcrx%2Fcrx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fcrx%2Fcrx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx-protos.h?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,79 +0,0 @@\n-/* Prototypes for exported functions defined in crx.c\n-   Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n-   2002, 2003, 2004, 2007, 2010 Free Software Foundation, Inc.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_CRX_PROTOS_H\n-#define GCC_CRX_PROTOS_H\n-\n-\n-/* Register usage. */\n-extern enum reg_class crx_regno_reg_class (int);\n-extern int crx_hard_regno_mode_ok (int regno, enum machine_mode);\n-#ifdef RTX_CODE\n-extern enum reg_class crx_secondary_reload_class (enum reg_class, enum machine_mode, rtx);\n-#endif /* RTX_CODE */\n-\n-/* Passing function arguments.  */\n-extern int crx_function_arg_regno_p (int);\n-#ifdef TREE_CODE\n-#ifdef RTX_CODE\n-extern void crx_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx);\n-#endif /* RTX_CODE */\n-#endif /* TREE_CODE */\n-\n-#ifdef RTX_CODE\n-/* Addressing Modes.  */\n-struct crx_address\n-{\n-  rtx base, index, disp, side_effect;\n-  int scale;\n-};\n-\n-enum crx_addrtype\n-{\n-  CRX_INVALID, CRX_REG_REL, CRX_POST_INC, CRX_SCALED_INDX, CRX_ABSOLUTE\n-};\n-\n-extern enum crx_addrtype crx_decompose_address (rtx addr, struct crx_address *out);\n-\n-extern int crx_const_double_ok (rtx op);\n-\n-/* Instruction output.  */\n-extern void crx_print_operand (FILE *, rtx, int);\n-extern void crx_print_operand_address (FILE *, rtx);\n-\n-/* Misc functions called from crx.md.  */\n-extern void crx_expand_movmem_single (rtx, rtx, rtx, rtx, rtx, unsigned HOST_WIDE_INT *);\n-extern int crx_expand_movmem (rtx, rtx, rtx, rtx);\n-#endif /* RTX_CODE */\n-\n-/* Routines to compute costs.  */\n-extern int crx_memory_move_cost (enum machine_mode, enum reg_class, int);\n-\n-/* Prologue/Epilogue functions.  */\n-extern int crx_initial_elimination_offset (int, int);\n-extern char *crx_prepare_push_pop_string (int);\n-extern void crx_expand_prologue (void);\n-extern void crx_expand_epilogue (void);\n-\n-\n-/* Handling the \"interrupt\" attribute */\n-extern int crx_interrupt_function_p (void);\n-\n-#endif /* GCC_CRX_PROTOS_H */"}, {"sha": "8f635d5a171e1516727d1f5c9155835c39dd0c7d", "filename": "gcc/config/crx/crx.c", "status": "removed", "additions": 0, "deletions": 1466, "changes": 1466, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fcrx%2Fcrx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fcrx%2Fcrx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.c?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,1466 +0,0 @@\n-/* Output routines for GCC for CRX.\n-   Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,\n-   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n-   Free Software Foundation, Inc.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/*****************************************************************************/\n-/* HEADER INCLUDES\t\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"tree.h\"\n-#include \"tm_p.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"output.h\"\n-#include \"insn-codes.h\"\n-#include \"insn-attr.h\"\n-#include \"flags.h\"\n-#include \"except.h\"\n-#include \"function.h\"\n-#include \"recog.h\"\n-#include \"expr.h\"\n-#include \"optabs.h\"\n-#include \"diagnostic-core.h\"\n-#include \"basic-block.h\"\n-#include \"df.h\"\n-#include \"target.h\"\n-#include \"target-def.h\"\n-\n-/*****************************************************************************/\n-/* DEFINITIONS\t\t\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-/* Maximum number of register used for passing parameters.  */\n-#define MAX_REG_FOR_PASSING_ARGS 6\n-\n-/* Minimum number register used for passing parameters.  */\n-#define MIN_REG_FOR_PASSING_ARGS 2\n-\n-/* The maximum count of words supported in the assembly of the architecture in\n- * a push/pop instruction.  */\n-#define MAX_COUNT\t\t8\n-\n-/* Predicate is true if the current function is a 'noreturn' function, i.e. it\n- * is qualified as volatile.  */\n-#define FUNC_IS_NORETURN_P(decl) (TREE_THIS_VOLATILE (decl))\n-\n-/* The following macros are used in crx_decompose_address () */\n-\n-/* Returns the factor of a scaled index address or -1 if invalid. */\n-#define SCALE_FOR_INDEX_P(X)\t\\\n- (GET_CODE (X) == CONST_INT ?\t\\\n-  (INTVAL (X) == 1 ? 1 :\t\\\n-   INTVAL (X) == 2 ? 2 :\t\\\n-   INTVAL (X) == 4 ? 4 :\t\\\n-   INTVAL (X) == 8 ? 8 :\t\\\n-   -1) :\t\t\t\\\n-  -1)\n-\n-/* Nonzero if the rtx X is a signed const int of n bits */\n-#define RTX_SIGNED_INT_FITS_N_BITS(X,n)\t\t\t\\\n- ((GET_CODE (X) == CONST_INT\t\t\t\t\\\n-   && SIGNED_INT_FITS_N_BITS (INTVAL (X), n)) ? 1 : 0)\n-\n-/* Nonzero if the rtx X is an unsigned const int of n bits.  */\n-#define RTX_UNSIGNED_INT_FITS_N_BITS(X, n)\t\t\\\n- ((GET_CODE (X) == CONST_INT\t\t\t\t\\\n-   && UNSIGNED_INT_FITS_N_BITS (INTVAL (X), n)) ? 1 : 0)\n-\n-/*****************************************************************************/\n-/* STATIC VARIABLES\t\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-/* Nonzero if the last param processed is passed in a register.  */\n-static int last_parm_in_reg;\n-\n-/* Will hold the number of the last register the prologue saves, -1 if no\n- * register is saved. */\n-static int last_reg_to_save;\n-\n-/* Each object in the array is a register number. Mark 1 for registers that\n- * need to be saved.  */\n-static int save_regs[FIRST_PSEUDO_REGISTER];\n-\n-/* Number of bytes saved on the stack for non-scratch registers */\n-static int sum_regs = 0;\n-\n-/* Number of bytes saved on the stack for local variables. */\n-static int local_vars_size;\n-\n-/* The sum of 2 sizes: locals vars and padding byte for saving the registers.\n- * Used in expand_prologue () and expand_epilogue ().  */\n-static int size_for_adjusting_sp;\n-\n-/* In case of a POST_INC or POST_DEC memory reference, we must report the mode\n- * of the memory reference from PRINT_OPERAND to PRINT_OPERAND_ADDRESS. */\n-static enum machine_mode output_memory_reference_mode;\n-\n-/*****************************************************************************/\n-/* TARGETM FUNCTION PROTOTYPES\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-static bool crx_fixed_condition_code_regs (unsigned int *, unsigned int *);\n-static rtx crx_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED,\n-\t\t\t\t int incoming ATTRIBUTE_UNUSED);\n-static bool crx_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED);\n-static int crx_address_cost (rtx, bool);\n-static bool crx_legitimate_address_p (enum machine_mode, rtx, bool);\n-static bool crx_can_eliminate (const int, const int);\n-static rtx crx_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t     const_tree, bool);\n-static void crx_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n-\t\t\t\t      const_tree, bool);\n-\n-/*****************************************************************************/\n-/* RTL VALIDITY\t\t\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#undef TARGET_LEGITIMATE_ADDRESS_P\n-#define TARGET_LEGITIMATE_ADDRESS_P\tcrx_legitimate_address_p\n-\n-#undef TARGET_CAN_ELIMINATE\n-#define TARGET_CAN_ELIMINATE\t\tcrx_can_eliminate\n-\n-/*****************************************************************************/\n-/* STACK LAYOUT AND CALLING CONVENTIONS\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#undef\tTARGET_FIXED_CONDITION_CODE_REGS\n-#define\tTARGET_FIXED_CONDITION_CODE_REGS crx_fixed_condition_code_regs\n-\n-#undef\tTARGET_STRUCT_VALUE_RTX\n-#define\tTARGET_STRUCT_VALUE_RTX\t\tcrx_struct_value_rtx\n-\n-#undef\tTARGET_RETURN_IN_MEMORY\n-#define\tTARGET_RETURN_IN_MEMORY\t\tcrx_return_in_memory\n-\n-/*****************************************************************************/\n-/* PASSING FUNCTION ARGUMENTS\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#undef  TARGET_FUNCTION_ARG\n-#define TARGET_FUNCTION_ARG\t\tcrx_function_arg\n-\n-#undef  TARGET_FUNCTION_ARG_ADVANCE\n-#define TARGET_FUNCTION_ARG_ADVANCE\tcrx_function_arg_advance\n-\n-/*****************************************************************************/\n-/* RELATIVE COSTS OF OPERATIONS\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#undef\tTARGET_ADDRESS_COST\n-#define\tTARGET_ADDRESS_COST\t\tcrx_address_cost\n-\n-/*****************************************************************************/\n-/* TARGET-SPECIFIC USES OF `__attribute__'\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#undef  TARGET_ATTRIBUTE_TABLE\n-#define TARGET_ATTRIBUTE_TABLE\t\tcrx_attribute_table\n-\n-static const struct attribute_spec crx_attribute_table[] = {\n-  /* ISRs have special prologue and epilogue requirements. */\n-  {\"interrupt\", 0, 0, false, true, true, NULL, false},\n-  {NULL, 0, 0, false, false, false, NULL, false}\n-};\n-\n-/* Option handling.  */\n-\n-#undef\tTARGET_OPTION_OPTIMIZATION_TABLE\n-#define\tTARGET_OPTION_OPTIMIZATION_TABLE\tcrx_option_optimization_table\n-\n-static const struct default_options crx_option_optimization_table[] =\n-  {\n-    /* Put each function in its own section so that PAGE-instruction\n-       relaxation can do its best.  */\n-    { OPT_LEVELS_1_PLUS, OPT_ffunction_sections, NULL, 1 },\n-    { OPT_LEVELS_1_PLUS, OPT_fomit_frame_pointer, NULL, 1 },\n-    { OPT_LEVELS_NONE, 0, NULL, 0 }\n-  };\n-\n-/* Initialize 'targetm' variable which contains pointers to functions and data\n- * relating to the target machine.  */\n-\n-struct gcc_target targetm = TARGET_INITIALIZER;\n-\n-\n-/*****************************************************************************/\n-/* TARGET HOOK IMPLEMENTATIONS\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-/* Return the fixed registers used for condition codes.  */\n-\n-static bool\n-crx_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n-{\n-    *p1 = CC_REGNUM;\n-    *p2 = INVALID_REGNUM;\n-    return true;\n-}\n-\n-/* Implements hook TARGET_STRUCT_VALUE_RTX.  */\n-\n-static rtx\n-crx_struct_value_rtx (tree fntype ATTRIBUTE_UNUSED,\n-\t\t      int incoming ATTRIBUTE_UNUSED)\n-{\n-  return gen_rtx_REG (Pmode, CRX_STRUCT_VALUE_REGNUM);\n-}\n-\n-/* Implements hook TARGET_RETURN_IN_MEMORY.  */\n-\n-static bool\n-crx_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n-{\n-  if (TYPE_MODE (type) == BLKmode)\n-    {\n-      HOST_WIDE_INT size = int_size_in_bytes (type);\n-      return (size == -1 || size > 8);\n-    }\n-  else\n-    return false;\n-}\n-\n-\n-/*****************************************************************************/\n-/* MACRO IMPLEMENTATIONS\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-/* STACK LAYOUT AND CALLING CONVENTIONS ROUTINES */\n-/* --------------------------------------------- */\n-\n-/* Return nonzero if the current function being compiled is an interrupt\n- * function as specified by the \"interrupt\" attribute.  */\n-\n-int\n-crx_interrupt_function_p (void)\n-{\n-  tree attributes;\n-\n-  attributes = TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl));\n-  return lookup_attribute (\"interrupt\", attributes) != NULL_TREE;\n-}\n-\n-/* Compute values for the array save_regs and the variable sum_regs.  The index\n- * of save_regs is numbers of register, each will get 1 if we need to save it\n- * in the current function, 0 if not. sum_regs is the total sum of the\n- * registers being saved. */\n-\n-static void\n-crx_compute_save_regs (void)\n-{\n-  unsigned int regno;\n-\n-  /* initialize here so in case the function is no-return it will be -1. */\n-  last_reg_to_save = -1;\n-\n-  /* No need to save any registers if the function never returns.  */\n-  if (FUNC_IS_NORETURN_P (current_function_decl))\n-    return;\n-\n-  /* Initialize the number of bytes to be saved. */\n-  sum_regs = 0;\n-\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    {\n-      if (fixed_regs[regno])\n-\t{\n-\t  save_regs[regno] = 0;\n-\t  continue;\n-\t}\n-\n-      /* If this reg is used and not call-used (except RA), save it. */\n-      if (crx_interrupt_function_p ())\n-\t{\n-\t  if (!current_function_is_leaf && call_used_regs[regno])\n-\t    /* this is a volatile reg in a non-leaf interrupt routine - save it\n-\t     * for the sake of its sons.  */\n-\t    save_regs[regno] = 1;\n-\n-\t  else if (df_regs_ever_live_p (regno))\n-\t    /* This reg is used - save it.  */\n-\t    save_regs[regno] = 1;\n-\t  else\n-\t    /* This reg is not used, and is not a volatile - don't save. */\n-      \t    save_regs[regno] = 0;\n-\t}\n-      else\n-\t{\n-\t  /* If this reg is used and not call-used (except RA), save it. */\n-\t  if (df_regs_ever_live_p (regno)\n-\t      && (!call_used_regs[regno] || regno == RETURN_ADDRESS_REGNUM))\n-\t    save_regs[regno] = 1;\n-\t  else\n-\t    save_regs[regno] = 0;\n-\t}\n-    }\n-\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n-    if (save_regs[regno] == 1)\n-      {\n-\tlast_reg_to_save = regno;\n-\tsum_regs += UNITS_PER_WORD;\n-      }\n-}\n-\n-/* Compute the size of the local area and the size to be adjusted by the\n- * prologue and epilogue. */\n-\n-static void\n-crx_compute_frame (void)\n-{\n-  /* For aligning the local variables. */\n-  int stack_alignment = STACK_BOUNDARY / BITS_PER_UNIT;\n-  int padding_locals;\n-\n-  /* Padding needed for each element of the frame.  */\n-  local_vars_size = get_frame_size ();\n-\n-  /* Align to the stack alignment. */\n-  padding_locals = local_vars_size % stack_alignment;\n-  if (padding_locals)\n-    padding_locals = stack_alignment - padding_locals;\n-\n-  local_vars_size += padding_locals;\n-\n-  size_for_adjusting_sp = local_vars_size + (ACCUMULATE_OUTGOING_ARGS ?\n-\t\t\t\t     crtl->outgoing_args_size : 0);\n-}\n-\n-/* Worker function for TARGET_CAN_ELIMINATE.  */\n-\n-bool\n-crx_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)\n-{\n-  return (to == STACK_POINTER_REGNUM ? ! frame_pointer_needed : true);\n-}\n-\n-/* Implements the macro INITIAL_ELIMINATION_OFFSET, return the OFFSET. */\n-\n-int\n-crx_initial_elimination_offset (int from, int to)\n-{\n-  /* Compute this since we need to use sum_regs.  */\n-  crx_compute_save_regs ();\n-\n-  /* Compute this since we need to use local_vars_size.  */\n-  crx_compute_frame ();\n-\n-  if ((from) == FRAME_POINTER_REGNUM && (to) == STACK_POINTER_REGNUM)\n-    return (ACCUMULATE_OUTGOING_ARGS ?\n-\t    crtl->outgoing_args_size : 0);\n-  else if ((from) == ARG_POINTER_REGNUM && (to) == FRAME_POINTER_REGNUM)\n-    return (sum_regs + local_vars_size);\n-  else if ((from) == ARG_POINTER_REGNUM && (to) == STACK_POINTER_REGNUM)\n-    return (sum_regs + local_vars_size +\n-\t    (ACCUMULATE_OUTGOING_ARGS ?\n-\t     crtl->outgoing_args_size : 0));\n-  else\n-    abort ();\n-}\n-\n-/* REGISTER USAGE */\n-/* -------------- */\n-\n-/* Return the class number of the smallest class containing reg number REGNO.\n- * This could be a conditional expression or could index an array. */\n-\n-enum reg_class\n-crx_regno_reg_class (int regno)\n-{\n-  if (regno >= 0 && regno < SP_REGNUM)\n-    return NOSP_REGS;\n-\n-  if (regno == SP_REGNUM)\n-    return GENERAL_REGS;\n-\n-  if (regno == LO_REGNUM)\n-    return LO_REGS;\n-  if (regno == HI_REGNUM)\n-    return HI_REGS;\n-\n-  return NO_REGS;\n-}\n-\n-/* Transfer between HILO_REGS and memory via secondary reloading. */\n-\n-enum reg_class\n-crx_secondary_reload_class (enum reg_class rclass,\n-\t\t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t    rtx x ATTRIBUTE_UNUSED)\n-{\n-  if (reg_classes_intersect_p (rclass, HILO_REGS)\n-      && true_regnum (x) == -1)\n-    return GENERAL_REGS;\n-\n-  return NO_REGS;\n-}\n-\n-/* Return 1 if hard register REGNO can hold a value of machine-mode MODE. */\n-\n-int\n-crx_hard_regno_mode_ok (int regno, enum machine_mode mode)\n-{\n-  /* CC can only hold CCmode values.  */\n-  if (regno == CC_REGNUM)\n-    return GET_MODE_CLASS (mode) == MODE_CC;\n-  if (GET_MODE_CLASS (mode) == MODE_CC)\n-    return 0;\n-  /* HILO registers can only hold SImode and DImode */\n-  if (HILO_REGNO_P (regno))\n-    return mode == SImode || mode == DImode;\n-  return 1;\n-}\n-\n-/* PASSING FUNCTION ARGUMENTS */\n-/* -------------------------- */\n-\n-/* If enough param regs are available for passing the param of type TYPE return\n- * the number of registers needed else 0.  */\n-\n-static int\n-enough_regs_for_param (CUMULATIVE_ARGS * cum, const_tree type,\n-\t\t       enum machine_mode mode)\n-{\n-  int type_size;\n-  int remaining_size;\n-\n-  if (mode != BLKmode)\n-    type_size = GET_MODE_BITSIZE (mode);\n-  else\n-    type_size = int_size_in_bytes (type) * BITS_PER_UNIT;\n-\n-  remaining_size =\n-    BITS_PER_WORD * (MAX_REG_FOR_PASSING_ARGS -\n-    (MIN_REG_FOR_PASSING_ARGS + cum->ints) + 1);\n-\n-  /* Any variable which is too big to pass in two registers, will pass on\n-   * stack. */\n-  if ((remaining_size >= type_size) && (type_size <= 2 * BITS_PER_WORD))\n-    return (type_size + BITS_PER_WORD - 1) / BITS_PER_WORD;\n-\n-  return 0;\n-}\n-\n-/* Implements TARGET_FUNCTION_ARG.  */\n-\n-static rtx\n-crx_function_arg (CUMULATIVE_ARGS * cum, enum machine_mode mode,\n-\t\t  const_tree type, bool named ATTRIBUTE_UNUSED)\n-{\n-  last_parm_in_reg = 0;\n-\n-  /* Function_arg () is called with this type just after all the args have had\n-   * their registers assigned. The rtx that function_arg returns from this type\n-   * is supposed to pass to 'gen_call' but currently it is not implemented (see\n-   * macro GEN_CALL).  */\n-  if (type == void_type_node)\n-    return NULL_RTX;\n-\n-  if (targetm.calls.must_pass_in_stack (mode, type) || (cum->ints < 0))\n-    return NULL_RTX;\n-\n-  if (mode == BLKmode)\n-    {\n-      /* Enable structures that need padding bytes at the end to pass to a\n-       * function in registers. */\n-      if (enough_regs_for_param (cum, type, mode) != 0)\n-\t{\n-\t  last_parm_in_reg = 1;\n-\t  return gen_rtx_REG (mode, MIN_REG_FOR_PASSING_ARGS + cum->ints);\n-\t}\n-    }\n-\n-  if (MIN_REG_FOR_PASSING_ARGS + cum->ints > MAX_REG_FOR_PASSING_ARGS)\n-    return NULL_RTX;\n-  else\n-    {\n-      if (enough_regs_for_param (cum, type, mode) != 0)\n-\t{\n-\t  last_parm_in_reg = 1;\n-\t  return gen_rtx_REG (mode, MIN_REG_FOR_PASSING_ARGS + cum->ints);\n-\t}\n-    }\n-\n-  return NULL_RTX;\n-}\n-\n-/* Implements the macro INIT_CUMULATIVE_ARGS defined in crx.h.  */\n-\n-void\n-crx_init_cumulative_args (CUMULATIVE_ARGS * cum, tree fntype,\n-\t\t      rtx libfunc ATTRIBUTE_UNUSED)\n-{\n-  tree param, next_param;\n-\n-  cum->ints = 0;\n-\n-  /* Determine if this function has variable arguments.  This is indicated by\n-   * the last argument being 'void_type_mode' if there are no variable\n-   * arguments.  Change here for a different vararg.  */\n-  for (param = (fntype) ? TYPE_ARG_TYPES (fntype) : 0;\n-       param != (tree) 0; param = next_param)\n-    {\n-      next_param = TREE_CHAIN (param);\n-      if (next_param == (tree) 0 && TREE_VALUE (param) != void_type_node)\n-\t{\n-\t  cum->ints = -1;\n-\t  return;\n-\t}\n-    }\n-}\n-\n-/* Implements TARGET_FUNCTION_ARG_ADVANCE.  */\n-\n-static void\n-crx_function_arg_advance (CUMULATIVE_ARGS * cum, enum machine_mode mode,\n-\t\t\t  const_tree type, bool named ATTRIBUTE_UNUSED)\n-{\n-  /* l holds the number of registers required */\n-  int l = GET_MODE_BITSIZE (mode) / BITS_PER_WORD;\n-\n-  /* If the parameter isn't passed on a register don't advance cum.  */\n-  if (!last_parm_in_reg)\n-    return;\n-\n-  if (targetm.calls.must_pass_in_stack (mode, type) || (cum->ints < 0))\n-    return;\n-\n-  if (mode == SImode || mode == HImode || mode == QImode || mode == DImode)\n-    {\n-      if (l <= 1)\n-\tcum->ints += 1;\n-      else\n-\tcum->ints += l;\n-    }\n-  else if (mode == SFmode || mode == DFmode)\n-    cum->ints += l;\n-  else if ((mode) == BLKmode)\n-    {\n-      if ((l = enough_regs_for_param (cum, type, mode)) != 0)\n-\tcum->ints += l;\n-    }\n-\n-}\n-\n-/* Implements the macro FUNCTION_ARG_REGNO_P defined in crx.h.  Return nonzero\n- * if N is a register used for passing parameters.  */\n-\n-int\n-crx_function_arg_regno_p (int n)\n-{\n-  return (n <= MAX_REG_FOR_PASSING_ARGS && n >= MIN_REG_FOR_PASSING_ARGS);\n-}\n-\n-/* ADDRESSING MODES */\n-/* ---------------- */\n-\n-/* Implements the hook for TARGET_LEGITIMATE_ADDRESS_P defined in crx.h.\n- * The following addressing modes are supported on CRX:\n- *\n- * Relocations\t\t--> const | symbol_ref | label_ref\n- * Absolute address\t--> 32-bit absolute\n- * Post increment\t--> reg + 12-bit disp.\n- * Post modify\t\t--> reg + 12-bit disp.\n- * Register relative\t--> reg | 32-bit disp. + reg | 4 bit + reg\n- * Scaled index\t\t--> reg + reg | 22-bit disp. + reg + reg |\n- *\t\t\t    22-disp. + reg + reg + (2 | 4 | 8) */\n-\n-static rtx\n-crx_addr_reg (rtx addr_reg)\n-{\n-  if (GET_MODE (addr_reg) != Pmode)\n-    return NULL_RTX;\n-\n-  if (REG_P (addr_reg))\n-    return addr_reg;\n-  else if (GET_CODE (addr_reg) == SUBREG\n-\t   && REG_P (SUBREG_REG (addr_reg))\n-\t   && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (addr_reg)))\n-\t       <= UNITS_PER_WORD))\n-    return SUBREG_REG (addr_reg);\n-  else\n-    return NULL_RTX;\n-}\n-\n-enum crx_addrtype\n-crx_decompose_address (rtx addr, struct crx_address *out)\n-{\n-  rtx base = NULL_RTX, index = NULL_RTX, disp = NULL_RTX;\n-  rtx scale_rtx = NULL_RTX, side_effect = NULL_RTX;\n-  int scale = -1;\n-  \n-  enum crx_addrtype retval = CRX_INVALID;\n-\n-  switch (GET_CODE (addr))\n-    {\n-    case CONST_INT:\n-      /* Absolute address (known at compile time) */\n-      retval = CRX_ABSOLUTE;\n-      disp = addr;\n-      if (!UNSIGNED_INT_FITS_N_BITS (INTVAL (disp), GET_MODE_BITSIZE (Pmode)))\n-\treturn CRX_INVALID;\n-      break;\n-      \n-    case CONST:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      /* Absolute address (known at link time) */\n-      retval = CRX_ABSOLUTE;\n-      disp = addr;\n-      break;\n-\n-    case REG:\n-    case SUBREG:\n-      /* Register relative address */\n-      retval = CRX_REG_REL;\n-      base = addr;\n-      break;\n-\n-    case PLUS:\n-      switch (GET_CODE (XEXP (addr, 0)))\n-\t{\n-\tcase REG:\n-\tcase SUBREG:\n-\t  if (REG_P (XEXP (addr, 1)))\n-\t    {\n-\t      /* Scaled index with scale = 1 and disp. = 0 */\n-\t      retval = CRX_SCALED_INDX;\n-\t      base = XEXP (addr, 1);\n-\t      index = XEXP (addr, 0); \n-\t      scale = 1;\n-\t    }\n-\t  else if (RTX_SIGNED_INT_FITS_N_BITS (XEXP (addr, 1), 28))\n-\t    {\n-\t      /* Register relative address and <= 28-bit disp. */\n-\t      retval = CRX_REG_REL;\n-\t      base = XEXP (addr, 0);\n-\t      disp = XEXP (addr, 1);\n-\t    }\n-\t  else\n-\t    return CRX_INVALID;\n-\t  break;\n-\n-\tcase PLUS:\n-\t  /* Scaled index and <= 22-bit disp. */\n-\t  retval = CRX_SCALED_INDX;\n-\t  base = XEXP (XEXP (addr, 0), 1); \n-\t  disp = XEXP (addr, 1);\n-\t  if (!RTX_SIGNED_INT_FITS_N_BITS (disp, 22))\n-\t    return CRX_INVALID;\n-\t  switch (GET_CODE (XEXP (XEXP (addr, 0), 0)))\n-\t    {\n-\t    case REG:\n-\t      /* Scaled index with scale = 0 and <= 22-bit disp. */\n-\t      index = XEXP (XEXP (addr, 0), 0); \n-\t      scale = 1;\n-\t      break;\n-\t      \n-\t    case MULT:\n-\t      /* Scaled index with scale >= 0 and <= 22-bit disp. */\n-\t      index = XEXP (XEXP (XEXP (addr, 0), 0), 0); \n-\t      scale_rtx = XEXP (XEXP (XEXP (addr, 0), 0), 1); \n-\t      if ((scale = SCALE_FOR_INDEX_P (scale_rtx)) == -1)\n-\t\treturn CRX_INVALID;\n-\t      break;\n-\n-\t    default:\n-\t      return CRX_INVALID;\n-\t    }\n-\t  break;\n-\t  \n-\tcase MULT:\n-\t  /* Scaled index with scale >= 0 */\n-\t  retval = CRX_SCALED_INDX;\n-\t  base = XEXP (addr, 1); \n-\t  index = XEXP (XEXP (addr, 0), 0); \n-\t  scale_rtx = XEXP (XEXP (addr, 0), 1); \n-\t  /* Scaled index with scale >= 0 and <= 22-bit disp. */\n-\t  if ((scale = SCALE_FOR_INDEX_P (scale_rtx)) == -1)\n-\t    return CRX_INVALID;\n-\t  break;\n-\n-\tdefault:\n-\t  return CRX_INVALID;\n-\t}\n-      break;\n-\n-    case POST_INC:\n-    case POST_DEC:\n-      /* Simple post-increment */\n-      retval = CRX_POST_INC;\n-      base = XEXP (addr, 0);\n-      side_effect = addr;\n-      break;\n-\n-    case POST_MODIFY:\n-      /* Generic post-increment with <= 12-bit disp. */\n-      retval = CRX_POST_INC;\n-      base = XEXP (addr, 0);\n-      side_effect = XEXP (addr, 1);\n-      if (base != XEXP (side_effect, 0))\n-\treturn CRX_INVALID;\n-      switch (GET_CODE (side_effect))\n-\t{\n-\tcase PLUS:\n-\tcase MINUS:\n-\t  disp = XEXP (side_effect, 1);\n-\t  if (!RTX_SIGNED_INT_FITS_N_BITS (disp, 12))\n-\t    return CRX_INVALID;\n-\t  break;\n-\n-\tdefault:\n-\t  /* CRX only supports PLUS and MINUS */\n-\t  return CRX_INVALID;\n-\t}\n-      break;\n-\n-    default:\n-      return CRX_INVALID;\n-    }\n-\n-  if (base)\n-    {\n-      base = crx_addr_reg (base);\n-      if (!base)\n-\treturn CRX_INVALID;\n-    }\n-  if (index)\n-    {\n-      index = crx_addr_reg (index);\n-      if (!index)\n-\treturn CRX_INVALID;\n-    }\n-  \n-  out->base = base;\n-  out->index = index;\n-  out->disp = disp;\n-  out->scale = scale;\n-  out->side_effect = side_effect;\n-\n-  return retval;\n-}\n-\n-bool\n-crx_legitimate_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t\t  rtx addr, bool strict)\n-{\n-  enum crx_addrtype addrtype;\n-  struct crx_address address;\n-\t\t\t\t\t\t \n-  if (TARGET_DEBUG_ADDR)\n-    {\n-      fprintf (stderr,\n-               \"\\n======\\nGO_IF_LEGITIMATE_ADDRESS, mode = %s, strict = %d\\n\",\n-               GET_MODE_NAME (mode), strict);\n-      debug_rtx (addr);\n-    }\n-  \n-  addrtype = crx_decompose_address (addr, &address);\n-\n-  if (addrtype == CRX_POST_INC && GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n-    return FALSE;\n-\n-  if (TARGET_DEBUG_ADDR)\n-    {\n-      const char *typestr;\n-      switch (addrtype)\n-\t{\n-\tcase CRX_INVALID:\n-\t  typestr = \"Invalid\";\n-\t  break;\n-\tcase CRX_REG_REL:\n-\t  typestr = \"Register relative\";\n-\t  break;\n-\tcase CRX_POST_INC:\n-\t  typestr = \"Post-increment\";\n-\t  break;\n-\tcase CRX_SCALED_INDX:\n-\t  typestr = \"Scaled index\";\n-\t  break;\n-\tcase CRX_ABSOLUTE:\n-\t  typestr = \"Absolute\";\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-      fprintf (stderr, \"CRX Address type: %s\\n\", typestr);\n-    }\n-  \n-  if (addrtype == CRX_INVALID)\n-    return FALSE;\n-\n-  if (strict)\n-    {\n-      if (address.base && !REGNO_OK_FOR_BASE_P (REGNO (address.base)))\n-\t{\n-\t  if (TARGET_DEBUG_ADDR)\n-\t    fprintf (stderr, \"Base register not strict\\n\");\n-\t  return FALSE;\n-\t}\n-      if (address.index && !REGNO_OK_FOR_INDEX_P (REGNO (address.index)))\n-\t{\n-\t  if (TARGET_DEBUG_ADDR)\n-\t    fprintf (stderr, \"Index register not strict\\n\");\n-\t  return FALSE;\n-\t}\n-    }\n-\n-  return TRUE;\n-}\n-\n-/* ROUTINES TO COMPUTE COSTS */\n-/* ------------------------- */\n-\n-/* Return cost of the memory address x. */\n-\n-static int\n-crx_address_cost (rtx addr, bool speed ATTRIBUTE_UNUSED)\n-{\n-  enum crx_addrtype addrtype;\n-  struct crx_address address;\n-\t\t\t\t\t\t \n-  int cost = 2;\n-  \n-  addrtype = crx_decompose_address (addr, &address);\n-  \n-  gcc_assert (addrtype != CRX_INVALID);\n-\n-  /* An absolute address causes a 3-word instruction */\n-  if (addrtype == CRX_ABSOLUTE)\n-    cost+=2;\n-  \n-  /* Post-modifying addresses are more powerful.  */\n-  if (addrtype == CRX_POST_INC)\n-    cost-=2;\n-\n-  /* Attempt to minimize number of registers in the address. */\n-  if (address.base)\n-    cost++;\n-  \n-  if (address.index && address.scale == 1)\n-    cost+=5;\n-\n-  if (address.disp && !INT_CST4 (INTVAL (address.disp)))\n-    cost+=2;\n-\n-  if (TARGET_DEBUG_ADDR)\n-    {\n-      fprintf (stderr, \"\\n======\\nTARGET_ADDRESS_COST = %d\\n\", cost);\n-      debug_rtx (addr);\n-    }\n-  \n-  return cost;\n-}\n-\n-/* Return the cost of moving data of mode MODE between a register of class\n- * RCLASS and memory; IN is zero if the value is to be written to memory,\n- * nonzero if it is to be read in. This cost is relative to those in\n- * REGISTER_MOVE_COST.  */\n-\n-int\n-crx_memory_move_cost (enum machine_mode mode,\n-\t\t  enum reg_class rclass ATTRIBUTE_UNUSED,\n-\t\t  int in ATTRIBUTE_UNUSED)\n-{\n-  /* One LD or ST takes twice the time of a simple reg-reg move */\n-  if (reg_classes_intersect_p (rclass, GENERAL_REGS))\n-    {\n-      /* printf (\"GENERAL_REGS LD/ST = %d\\n\", 4 * HARD_REGNO_NREGS (0, mode));*/\n-      return 4 * HARD_REGNO_NREGS (0, mode);\n-    }\t\n-  else if (reg_classes_intersect_p (rclass, HILO_REGS))\n-    {\n-      /* HILO to memory and vice versa */\n-      /* printf (\"HILO_REGS %s = %d\\n\", in ? \"LD\" : \"ST\",\n-\t     (REGISTER_MOVE_COST (mode,\n-\t\t\t\t in ? GENERAL_REGS : HILO_REGS,\n-\t\t\t\t in ? HILO_REGS : GENERAL_REGS) + 4)\n-\t* HARD_REGNO_NREGS (0, mode)); */\n-      return (REGISTER_MOVE_COST (mode,\n-\t\t\t\t in ? GENERAL_REGS : HILO_REGS,\n-\t\t\t\t in ? HILO_REGS : GENERAL_REGS) + 4)\n-\t* HARD_REGNO_NREGS (0, mode);\n-    }\n-  else /* default (like in i386) */\n-    {\n-      /* printf (\"ANYREGS = 100\\n\"); */\n-      return 100;\n-    }\n-}\n-\n-/* INSTRUCTION OUTPUT */\n-/* ------------------ */\n-\n-/* Check if a const_double is ok for crx store-immediate instructions */\n-\n-int\n-crx_const_double_ok (rtx op)\n-{\n-  if (GET_MODE (op) == DFmode)\n-  {\n-    REAL_VALUE_TYPE r;\n-    long l[2];\n-    REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n-    REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n-    return (UNSIGNED_INT_FITS_N_BITS (l[0], 4) &&\n-\t    UNSIGNED_INT_FITS_N_BITS (l[1], 4)) ? 1 : 0;\n-  }\n-\n-  if (GET_MODE (op) == SFmode)\n-  {\n-    REAL_VALUE_TYPE r;\n-    long l;\n-    REAL_VALUE_FROM_CONST_DOUBLE (r, op);\n-    REAL_VALUE_TO_TARGET_SINGLE (r, l);\n-    return UNSIGNED_INT_FITS_N_BITS (l, 4) ? 1 : 0;\n-  }\n-\n-  return (UNSIGNED_INT_FITS_N_BITS (CONST_DOUBLE_LOW (op), 4) &&\n-\t  UNSIGNED_INT_FITS_N_BITS (CONST_DOUBLE_HIGH (op), 4)) ? 1 : 0;\n-}\n-\n-/* Implements the macro PRINT_OPERAND defined in crx.h.  */\n-\n-void\n-crx_print_operand (FILE * file, rtx x, int code)\n-{\n-  switch (code)\n-    {\n-    case 'p' :\n-      if (GET_CODE (x) == REG) {\n-\tif (GET_MODE (x) == DImode || GET_MODE (x) == DFmode)\n-\t  {\n-\t    int regno = REGNO (x);\n-\t    if (regno + 1 >= SP_REGNUM) abort ();\n-\t    fprintf (file, \"{%s, %s}\", reg_names[regno], reg_names[regno + 1]);\n-\t    return;\n-\t  }\n-\telse\n-\t  {\n-\t    if (REGNO (x) >= SP_REGNUM) abort ();\n-\t    fprintf (file, \"%s\", reg_names[REGNO (x)]);\n-\t    return;\n-\t  }\n-      }\n-\n-    case 'd' :\n-\t{\n-\t  const char *crx_cmp_str;\n-\t  switch (GET_CODE (x))\n-\t    { /* MD: compare (reg, reg or imm) but CRX: cmp (reg or imm, reg)\n-\t       * -> swap all non symmetric ops */\n-\t    case EQ  : crx_cmp_str = \"eq\"; break;\n-\t    case NE  : crx_cmp_str = \"ne\"; break;\n-\t    case GT  : crx_cmp_str = \"lt\"; break;\n-\t    case GTU : crx_cmp_str = \"lo\"; break;\n-\t    case LT  : crx_cmp_str = \"gt\"; break;\n-\t    case LTU : crx_cmp_str = \"hi\"; break;\n-\t    case GE  : crx_cmp_str = \"le\"; break;\n-\t    case GEU : crx_cmp_str = \"ls\"; break;\n-\t    case LE  : crx_cmp_str = \"ge\"; break;\n-\t    case LEU : crx_cmp_str = \"hs\"; break;\n-\t    default : abort ();\n-\t    }\n-\t  fprintf (file, \"%s\", crx_cmp_str);\n-\t  return;\n-\t}\n-\n-    case 'H':\n-      /* Print high part of a double precision value. */\n-      switch (GET_CODE (x))\n-\t{\n-\tcase CONST_DOUBLE:\n-\t  if (GET_MODE (x) == SFmode) abort ();\n-\t  if (GET_MODE (x) == DFmode)\n-\t    {\n-\t      /* High part of a DF const. */\n-\t      REAL_VALUE_TYPE r;\n-\t      long l[2];\n-\n-\t      REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n-\t      REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n-\n-\t      fprintf (file, \"$0x%lx\", l[1]);\n-\t      return;\n-\t    }\n-\n-\t  /* -- Fallthrough to handle DI consts -- */\n-\n-\tcase CONST_INT:\n-\t    {\n-\t      rtx high, low;\n-\t      split_double (x, &low, &high);\n-\t      putc ('$', file);\n-\t      output_addr_const (file, high);\n-\t      return;\n-\t    }\n-\n-\tcase REG:\n-\t  if (REGNO (x) + 1 >= FIRST_PSEUDO_REGISTER) abort ();\n-\t  fprintf (file, \"%s\", reg_names[REGNO (x) + 1]);\n-\t  return;\n-\n-\tcase MEM:\n-\t  /* Adjust memory address to high part.  */\n-\t    {\n-\t      rtx adj_mem = x;\n-\t      adj_mem = adjust_address (adj_mem, GET_MODE (adj_mem), 4);\n-\n-\t      output_memory_reference_mode = GET_MODE (adj_mem);\n-\t      output_address (XEXP (adj_mem, 0));\n-\t      return;\n-\t    }\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n-\n-    case 'L':\n-      /* Print low part of a double precision value. */\n-      switch (GET_CODE (x))\n-\t{\n-\tcase CONST_DOUBLE:\n-\t  if (GET_MODE (x) == SFmode) abort ();\n-\t  if (GET_MODE (x) == DFmode)\n-\t    {\n-\t      /* High part of a DF const. */\n-\t      REAL_VALUE_TYPE r;\n-\t      long l[2];\n-\n-\t      REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n-\t      REAL_VALUE_TO_TARGET_DOUBLE (r, l);\n-\n-\t      fprintf (file, \"$0x%lx\", l[0]);\n-\t      return;\n-\t    }\n-\n-\t  /* -- Fallthrough to handle DI consts -- */\n-\n-\tcase CONST_INT:\n-\t    {\n-\t      rtx high, low;\n-\t      split_double (x, &low, &high);\n-\t      putc ('$', file);\n-\t      output_addr_const (file, low);\n-\t      return;\n-\t    }\n-\n-\tcase REG:\n-\t  fprintf (file, \"%s\", reg_names[REGNO (x)]);\n-\t  return;\n-\n-\tcase MEM:\n-\t  output_memory_reference_mode = GET_MODE (x);\n-\t  output_address (XEXP (x, 0));\n-\t  return;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n-\n-    case 0 : /* default */\n-      switch (GET_CODE (x))\n-\t{\n-\tcase REG:\n-\t  fprintf (file, \"%s\", reg_names[REGNO (x)]);\n-\t  return;\n-\n-\tcase MEM:\n-\t  output_memory_reference_mode = GET_MODE (x);\n-\t  output_address (XEXP (x, 0));\n-\t  return;\n-\n-\tcase CONST_DOUBLE:\n-\t    {\n-\t      REAL_VALUE_TYPE r;\n-\t      long l;\n-\n-\t      /* Always use H and L for double precision - see above */\n-\t      gcc_assert (GET_MODE (x) == SFmode);\n-\n-\t      REAL_VALUE_FROM_CONST_DOUBLE (r, x);\n-\t      REAL_VALUE_TO_TARGET_SINGLE (r, l);\n-\n-\t      fprintf (file, \"$0x%lx\", l);\n-\t      return;\n-\t    }\n-\n-\tdefault:\n-\t  putc ('$', file);\n-\t  output_addr_const (file, x);\n-\t  return;\n-\t}\n-\n-    default:\n-      output_operand_lossage (\"invalid %%xn code\");\n-    }\n-\n-  abort ();\n-}\n-\n-/* Implements the macro PRINT_OPERAND_ADDRESS defined in crx.h.  */\n-\n-void\n-crx_print_operand_address (FILE * file, rtx addr)\n-{\n-  enum crx_addrtype addrtype;\n-  struct crx_address address;\n-\n-  int offset;\n-  \n-  addrtype = crx_decompose_address (addr, &address);\n-  \n-  if (address.disp)\n-    offset = INTVAL (address.disp);\n-  else\n-    offset = 0;\n-\n-  switch (addrtype)\n-    {\n-    case CRX_REG_REL:\n-      fprintf (file, \"%d(%s)\", offset, reg_names[REGNO (address.base)]);\n-      return;\n-      \n-    case CRX_POST_INC:\n-      switch (GET_CODE (address.side_effect))\n-\t{\n-\tcase PLUS:\n-\t  break;\n-\tcase MINUS:\n-\t  offset = -offset;\n-\t  break;\n-\tcase POST_INC:\n-\t  offset = GET_MODE_SIZE (output_memory_reference_mode);\n-\t  break;\n-\tcase POST_DEC:\n-\t  offset = -GET_MODE_SIZE (output_memory_reference_mode);\n-\t  break;\n-\tdefault:\n-\t  abort ();\n-\t}\n-\tfprintf (file, \"%d(%s)+\", offset, reg_names[REGNO (address.base)]);\n-      return;\n-      \n-    case CRX_SCALED_INDX:\n-      fprintf (file, \"%d(%s, %s, %d)\", offset, reg_names[REGNO (address.base)],\n-\t       reg_names[REGNO (address.index)], address.scale);\n-      return;\n-      \n-    case CRX_ABSOLUTE:\n-      output_addr_const (file, address.disp);\n-      return;\n-      \n-    default:\n-      abort ();\n-    }\n-}\n-\n-\n-/*****************************************************************************/\n-/* MACHINE DESCRIPTION HELPER-FUNCTIONS\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-void crx_expand_movmem_single (rtx src, rtx srcbase, rtx dst, rtx dstbase,\n-\t\t\t       rtx tmp_reg, unsigned HOST_WIDE_INT *offset_p)\n-{\n-  rtx addr, mem;\n-  unsigned HOST_WIDE_INT offset = *offset_p;\n-\n-  /* Load */\n-  addr = plus_constant (src, offset);\n-  mem = adjust_automodify_address (srcbase, SImode, addr, offset);\n-  emit_move_insn (tmp_reg, mem);\n-\n-  /* Store */\n-  addr = plus_constant (dst, offset);\n-  mem = adjust_automodify_address (dstbase, SImode, addr, offset);\n-  emit_move_insn (mem, tmp_reg);\n-\n-  *offset_p = offset + 4;\n-}\n-\n-int\n-crx_expand_movmem (rtx dstbase, rtx srcbase, rtx count_exp, rtx align_exp)\n-{\n-  unsigned HOST_WIDE_INT count = 0, offset, si_moves, i;\n-  HOST_WIDE_INT align = 0;\n-\n-  rtx src, dst;\n-  rtx tmp_reg;\n-\n-  if (GET_CODE (align_exp) == CONST_INT)\n-    { /* Only if aligned */\n-      align = INTVAL (align_exp);\n-      if (align & 3)\n-\treturn 0;\n-    }\n-\n-  if (GET_CODE (count_exp) == CONST_INT)\n-    { /* No more than 16 SImode moves */\n-      count = INTVAL (count_exp);\n-      if (count > 64)\n-\treturn 0;\n-    }\n-\n-  tmp_reg = gen_reg_rtx (SImode);\n-\n-  /* Create psrs for the src and dest pointers */\n-  dst = copy_to_mode_reg (Pmode, XEXP (dstbase, 0));\n-  if (dst != XEXP (dstbase, 0))\n-    dstbase = replace_equiv_address_nv (dstbase, dst);\n-  src = copy_to_mode_reg (Pmode, XEXP (srcbase, 0));\n-  if (src != XEXP (srcbase, 0))\n-    srcbase = replace_equiv_address_nv (srcbase, src);\n-\n-  offset = 0;\n-\n-  /* Emit SImode moves */\n-  si_moves = count >> 2;\n-  for (i = 0; i < si_moves; i++)\n-    crx_expand_movmem_single (src, srcbase, dst, dstbase, tmp_reg, &offset);\n-\n-  /* Special cases */\n-  if (count & 3)\n-    {\n-      offset = count - 4;\n-      crx_expand_movmem_single (src, srcbase, dst, dstbase, tmp_reg, &offset);\n-    }\n-\n-  gcc_assert (offset == count);\n-\n-  return 1;\n-}\n-\n-static void\n-mpushpop_str (char *stringbuffer, const char *mnemonic, char *mask)\n-{\n-  if (strlen (mask) > 2 || crx_interrupt_function_p ()) /* needs 2-word instr. */\n-    sprintf (stringbuffer, \"\\n\\t%s\\tsp, {%s}\", mnemonic, mask);\n-  else /* single word instruction */\n-    sprintf (stringbuffer, \"\\n\\t%s\\t%s\", mnemonic, mask);\n-}\n-\n-/* Called from crx.md. The return value depends on the parameter push_or_pop:\n- * When push_or_pop is zero -> string for push instructions of prologue.\n- * When push_or_pop is nonzero -> string for pop/popret/retx in epilogue.\n- * Relies on the assumptions:\n- * 1. RA is the last register to be saved.\n- * 2. The maximal value of the counter is MAX_COUNT. */\n-\n-char *\n-crx_prepare_push_pop_string (int push_or_pop)\n-{\n-  /* j is the number of registers being saved, takes care that there won't be\n-   * more than 8 in one push/pop instruction */\n-\n-  /* For the register mask string */\n-  static char mask_str[50];\n-\n-  /* i is the index of save_regs[], going from 0 until last_reg_to_save */\n-  int i = 0;\n-\n-  int ra_in_bitmask = 0;\n-\n-  char *return_str;\n-\n-  /* For reversing on the push instructions if there are more than one. */\n-  char *temp_str;\n-\n-  return_str = (char *) xmalloc (120);\n-  temp_str = (char *) xmalloc (120);\n-\n-  /* Initialize */\n-  memset (return_str, 0, 3);\n-\n-  while (i <= last_reg_to_save)\n-    {\n-      /* Prepare mask for one instruction. */\n-      mask_str[0] = 0;\n-\n-      if (i <= SP_REGNUM)\n-\t{ /* Add regs unit full or SP register reached */\n-\t  int j = 0;\n-\t  while (j < MAX_COUNT && i <= SP_REGNUM)\n-\t    {\n-\t      if (save_regs[i])\n-\t\t{\n-\t\t  /* TODO to use ra_in_bitmask for detecting last pop is not\n-\t\t   * smart it prevents things like:  popret r5 */\n-\t\t  if (i == RETURN_ADDRESS_REGNUM) ra_in_bitmask = 1;\n-\t\t  if (j > 0) strcat (mask_str, \", \");\n-\t\t  strcat (mask_str, reg_names[i]);\n-\t\t  ++j;\n-\t\t}\n-\t      ++i;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* Handle hi/lo savings */\n-\t  while (i <= last_reg_to_save)\n-\t    {\n-\t      if (save_regs[i])\n-\t\t{\n-\t\t  strcat (mask_str, \"lo, hi\");\n-\t\t  i = last_reg_to_save + 1;\n-\t\t  break;\n-\t\t}\n-\t      ++i;\n-\t    }\n-\t}\n-\n-      if (strlen (mask_str) == 0) continue;\n-       \t\n-      if (push_or_pop == 1)\n-\t{\n-\t  if (crx_interrupt_function_p ())\n-\t    mpushpop_str (temp_str, \"popx\", mask_str);\n-\t  else\n-\t    {\n-\t      if (ra_in_bitmask)\n-\t\t{\n-\t\t  mpushpop_str (temp_str, \"popret\", mask_str);\n-\t\t  ra_in_bitmask = 0;\n-\t\t}\n-\t      else mpushpop_str (temp_str, \"pop\", mask_str);\n-\t    }\n-\n-\t  strcat (return_str, temp_str);\n-\t}\n-      else\n-\t{\n-\t  /* push - We need to reverse the order of the instructions if there\n-\t   * are more than one. (since the pop will not be reversed in the\n-\t   * epilogue */\n-      \t  if (crx_interrupt_function_p ())\n-\t    mpushpop_str (temp_str, \"pushx\", mask_str);\n-\t  else\n-\t    mpushpop_str (temp_str, \"push\", mask_str);\n-\t  strcat (temp_str, return_str);\n-\t  strcpy (strcat (return_str, \"\\t\"), temp_str);\n-\t}\n-\n-    }\n-\n-  if (push_or_pop == 1)\n-    {\n-      /* pop */\n-      if (crx_interrupt_function_p ())\n-\tstrcat (return_str, \"\\n\\tretx\\n\");\n-\n-      else if (!FUNC_IS_NORETURN_P (current_function_decl)\n-\t       && !save_regs[RETURN_ADDRESS_REGNUM])\n-\tstrcat (return_str, \"\\n\\tjump\\tra\\n\");\n-    }\n-\n-  /* Skip the newline and the tab in the start of return_str. */\n-  return_str += 2;\n-  return return_str;\n-}\n-\n-/*  CompactRISC CRX Architecture stack layout:\n-\n-     0 +---------------------\n-\t|\n-\t.\n-\t.\n-\t|\n-\t+==================== Sp(x)=Ap(x+1)\n-      A | Args for functions\n-      | | called by X and      Dynamically\n-      | | Dynamic allocations  allocated and\n-      | | (alloca, variable    deallocated\n-  Stack | length arrays).\n-  grows +-------------------- Fp(x)\n-  down| | Local variables of X\n-  ward| +--------------------\n-      | | Regs saved for X-1\n-      | +==================== Sp(x-1)=Ap(x)\n-\t| Args for func X\n-\t| pushed by X-1\n-\t+-------------------- Fp(x-1)\n-\t|\n-\t|\n-\tV\n-\n-*/\n-\n-void\n-crx_expand_prologue (void)\n-{\n-  crx_compute_frame ();\n-  crx_compute_save_regs ();\n-\n-  /* If there is no need in push and adjustment to sp, return. */\n-  if (size_for_adjusting_sp + sum_regs == 0)\n-    return;\n-\n-  if (last_reg_to_save != -1)\n-    /* If there are registers to push.  */\n-    emit_insn (gen_push_for_prologue (GEN_INT (sum_regs)));\n-\n-  if (size_for_adjusting_sp > 0)\n-    emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t   GEN_INT (-size_for_adjusting_sp)));\n-\n-  if (frame_pointer_needed)\n-    /* Initialize the frame pointer with the value of the stack pointer\n-     * pointing now to the locals. */\n-    emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n-}\n-\n-/* Generate insn that updates the stack for local variables and padding for\n- * registers we save. - Generate the appropriate return insn. */\n-\n-void\n-crx_expand_epilogue (void)\n-{\n-  /* Nonzero if we need to return and pop only RA. This will generate a\n-   * different insn. This differentiate is for the peepholes for call as last\n-   * statement in function. */\n-  int only_popret_RA = (save_regs[RETURN_ADDRESS_REGNUM]\n-\t\t\t&& (sum_regs == UNITS_PER_WORD));\n-\n-  if (frame_pointer_needed)\n-    /* Restore the stack pointer with the frame pointers value */\n-    emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n-\n-  if (size_for_adjusting_sp > 0)\n-    emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t   GEN_INT (size_for_adjusting_sp)));\n-\n-  if (crx_interrupt_function_p ())\n-    emit_jump_insn (gen_interrupt_return ());\n-  else if (last_reg_to_save == -1)\n-    /* Nothing to pop */\n-    /* Don't output jump for interrupt routine, only retx.  */\n-    emit_jump_insn (gen_indirect_jump_return ());\n-  else if (only_popret_RA)\n-    emit_jump_insn (gen_popret_RA_return ());\n-  else\n-    emit_jump_insn (gen_pop_and_popret_return (GEN_INT (sum_regs)));\n-}"}, {"sha": "da6e263ca52fbbf9515a77e588dff2fcbccda212", "filename": "gcc/config/crx/crx.h", "status": "removed", "additions": 0, "deletions": 478, "changes": 478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fcrx%2Fcrx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fcrx%2Fcrx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.h?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,478 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for CRX.\n-   Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n-   Free Software Foundation, Inc.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GCC_CRX_H\n-#define GCC_CRX_H\n-\n-/*****************************************************************************/\n-/* CONTROLLING THE DRIVER\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#define CC1PLUS_SPEC \"%{!frtti:-fno-rtti} \\\n-    %{!fenforce-eh-specs:-fno-enforce-eh-specs} \\\n-    %{!fexceptions:-fno-exceptions} \\\n-    %{!fthreadsafe-statics:-fno-threadsafe-statics}\"\n-\n-#undef  STARTFILE_SPEC\n-#define STARTFILE_SPEC \"crti.o%s crtbegin.o%s\"\n-\n-#undef  ENDFILE_SPEC\n-#define ENDFILE_SPEC \"crtend.o%s crtn.o%s\"\n-\n-#undef MATH_LIBRARY\n-#define MATH_LIBRARY \"\"\n-\n-/*****************************************************************************/\n-/* RUN-TIME TARGET SPECIFICATION\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#ifndef TARGET_CPU_CPP_BUILTINS\n-#define TARGET_CPU_CPP_BUILTINS()\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\\\n-     builtin_define(\"__CRX__\");\t\t\t\t\t\\\n-     builtin_define(\"__CR__\");\t\t  \t\t\t\\\n-} while (0)\n-#endif\n-\n-#define TARGET_VERSION fputs (\" (CRX/ELF)\", stderr);\n-\n-/*****************************************************************************/\n-/* STORAGE LAYOUT\t\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#define BITS_BIG_ENDIAN  0\n-\n-#define BYTES_BIG_ENDIAN 0\n-\n-#define WORDS_BIG_ENDIAN 0\n-\n-#define UNITS_PER_WORD 4\n-\n-#define POINTER_SIZE 32\n-\n-#define PARM_BOUNDARY 32\n-\n-#define STACK_BOUNDARY 32\n-\n-#define FUNCTION_BOUNDARY 32\n-\n-#define STRUCTURE_SIZE_BOUNDARY 32\n-\n-#define BIGGEST_ALIGNMENT 32\n-\n-/* In CRX arrays of chars are word-aligned, so strcpy() will be faster.  */\n-#define DATA_ALIGNMENT(TYPE, ALIGN) \\\n-  (TREE_CODE (TYPE) == ARRAY_TYPE && TYPE_MODE (TREE_TYPE (TYPE)) == QImode \\\n-   && (ALIGN) < BITS_PER_WORD \\\n-   ? (BITS_PER_WORD) : (ALIGN))\n-\n-/* In CRX strings are word-aligned so strcpy from constants will be faster. */\n-#define CONSTANT_ALIGNMENT(CONSTANT, ALIGN) \\\n-  (TREE_CODE (CONSTANT) == STRING_CST && (ALIGN) < BITS_PER_WORD \\\n-   ? (BITS_PER_WORD) : (ALIGN))\n-\n-#define STRICT_ALIGNMENT 0\n-\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-\n-/*****************************************************************************/\n-/* LAYOUT OF SOURCE LANGUAGE DATA TYPES\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#define INT_TYPE_SIZE\t\t32\n-\n-#define SHORT_TYPE_SIZE\t\t16\n-\n-#define LONG_TYPE_SIZE\t\t32\n-\n-#define LONG_LONG_TYPE_SIZE\t64\n-\n-#define FLOAT_TYPE_SIZE \t32\n-\n-#define DOUBLE_TYPE_SIZE \t64\n-\n-#define LONG_DOUBLE_TYPE_SIZE   64\n-\n-#define DEFAULT_SIGNED_CHAR\t1\n-\n-#define SIZE_TYPE\t\t\"unsigned int\"\n-\n-#define PTRDIFF_TYPE\t\t\"int\"\n-\n-/*****************************************************************************/\n-/* REGISTER USAGE.\t\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#define FIRST_PSEUDO_REGISTER\t19\n-\n-/* On the CRX, only the stack pointer (r15) is such. */\n-#define FIXED_REGISTERS \\\n-  { \\\n- /* r0  r1  r2  r3  r4  r5  r6  r7  r8  r9  r10 */  \\\n-    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\t    \\\n- /* r11 r12 r13 ra  sp  r16 r17 cc */\t\t    \\\n-    0,  0,  0,  0,  1,  0,  0,  1\t\t    \\\n-  }\n-\n-/* On the CRX, calls clobbers r0-r6 (scratch registers), ra (the return address)\n- * and sp - (the stack pointer which is fixed). */\n-#define CALL_USED_REGISTERS \\\n-  { \\\n- /* r0  r1  r2  r3  r4  r5  r6  r7  r8  r9  r10 */  \\\n-    1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,\t    \\\n- /* r11 r12 r13 ra  sp  r16 r17 cc */\t\t    \\\n-    0,  0,  0,  1,  1,  1,  1,  1\t\t    \\\n-  }\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE) \\\n-    ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* On the CRX architecture, HILO regs can only hold SI mode. */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) crx_hard_regno_mode_ok(REGNO, MODE)\n-\n-/* So far no patterns for moving CCMODE data are available */\n-#define AVOID_CCMODE_COPIES\n-\n-/* Interrupt functions can only use registers that have already been saved by\n- * the prologue, even if they would normally be call-clobbered. */\n-#define HARD_REGNO_RENAME_OK(SRC, DEST)\t\\\n-  (!crx_interrupt_function_p () || df_regs_ever_live_p (DEST))\n-\n-#define MODES_TIEABLE_P(MODE1, MODE2)  1\n-\n-enum reg_class\n-{\n-  NO_REGS,\n-  LO_REGS,\n-  HI_REGS,\n-  HILO_REGS,\n-  NOSP_REGS,\n-  GENERAL_REGS,\n-  ALL_REGS,\n-  LIM_REG_CLASSES\n-};\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* The following macro defines cover classes for Integrated Register\n-   Allocator.  Cover classes is a set of non-intersected register\n-   classes covering all hard registers used for register allocation\n-   purpose.  Any move between two registers of a cover class should be\n-   cheaper than load or store of the registers.  The macro value is\n-   array of register classes with LIM_REG_CLASSES used as the end\n-   marker.  */\n-\n-#define IRA_COVER_CLASSES         \\\n-{                                 \\\n-   GENERAL_REGS, LIM_REG_CLASSES  \\\n-} \n-\n-#define REG_CLASS_NAMES \\\n-  {\t\t\t\\\n-    \"NO_REGS\",\t\t\\\n-    \"LO_REGS\",\t\t\\\n-    \"HI_REGS\",\t\t\\\n-    \"HILO_REGS\",\t\\\n-    \"NOSP_REGS\",\t\\\n-    \"GENERAL_REGS\",\t\\\n-    \"ALL_REGS\"\t\t\\\n-  }\n-\n-#define REG_CLASS_CONTENTS\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\\\n-    {0x00000000}, /* NO_REGS\t\t\t*/\t\\\n-    {0x00010000}, /* LO_REGS :\t\t16 \t*/\t\\\n-    {0x00020000}, /* HI_REGS :\t\t17\t*/\t\\\n-    {0x00030000}, /* HILO_REGS :\t16, 17\t*/\t\\\n-    {0x00007fff}, /* NOSP_REGS : \t0 - 14\t*/\t\\\n-    {0x0000ffff}, /* GENERAL_REGS : \t0 - 15\t*/\t\\\n-    {0x0007ffff}  /* ALL_REGS : \t0 - 18\t*/\t\\\n-  }\n-\n-#define REGNO_REG_CLASS(REGNO)  crx_regno_reg_class(REGNO)\n-\n-#define BASE_REG_CLASS\t\tGENERAL_REGS\n-\n-#define INDEX_REG_CLASS\t\tGENERAL_REGS\n-\n-#define REG_CLASS_FROM_LETTER(C)\t\\\n-  ((C) == 'b' ? NOSP_REGS :\t\t\\\n-   (C) == 'l' ? LO_REGS : \t\t\\\n-   (C) == 'h' ? HI_REGS :\t\t\\\n-   (C) == 'k' ? HILO_REGS :\t\t\\\n-  NO_REGS)\n-\n-#define REGNO_OK_FOR_BASE_P(REGNO) \\\n-  ((REGNO) < 16 \\\n-   || (reg_renumber && (unsigned)reg_renumber[REGNO] < 16))\n-\n-#define REGNO_OK_FOR_INDEX_P(REGNO)\t   REGNO_OK_FOR_BASE_P(REGNO)\n-\n-#define SECONDARY_RELOAD_CLASS(CLASS, MODE, X) \\\n-  crx_secondary_reload_class (CLASS, MODE, X)\n-\n-#define CLASS_MAX_NREGS(CLASS, MODE) \\\n-    (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD\n-\n-#define SIGNED_INT_FITS_N_BITS(imm, N) \\\n-  ((((imm) < ((long long)1<<((N)-1))) && ((imm) >= -((long long)1<<((N)-1)))) ? 1 : 0)\n-\n-#define UNSIGNED_INT_FITS_N_BITS(imm, N) \\\n-  (((imm) < ((long long)1<<(N)) && (imm) >= (long long)0) ? 1 : 0)\n-\n-#define HILO_REGNO_P(regno) \\\n-  (reg_classes_intersect_p(REGNO_REG_CLASS(regno), HILO_REGS))\n-\n-#define INT_CST4(VALUE) \\\n-  (((VALUE) >= -1 && (VALUE) <= 4) || (VALUE) == -4 \\\n-  || (VALUE) == 7 || (VALUE) == 8 || (VALUE) == 16 || (VALUE) == 32 \\\n-  || (VALUE) == 20 || (VALUE) == 12 || (VALUE) == 48)\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n-  /* Legal const for store immediate instructions */\t\t\\\n-  ((C) == 'I' ? UNSIGNED_INT_FITS_N_BITS(VALUE, 3) :\t\t\\\n-   (C) == 'J' ? UNSIGNED_INT_FITS_N_BITS(VALUE, 4) :\t\t\\\n-   (C) == 'K' ? UNSIGNED_INT_FITS_N_BITS(VALUE, 5) :\t\t\\\n-   (C) == 'L' ? INT_CST4(VALUE) :\t\t\t\t\\\n-  0)\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\\\n-  ((C) == 'G' ? crx_const_double_ok (VALUE) :\t\\\n-  0)\n-\n-/*****************************************************************************/\n-/* STACK LAYOUT AND CALLING CONVENTIONS.\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#define STACK_GROWS_DOWNWARD\n-\n-#define STARTING_FRAME_OFFSET  0\n-\n-#define\tSTACK_POINTER_REGNUM\t15\n-\n-#define\tFRAME_POINTER_REGNUM\t13\n-\n-#define\tARG_POINTER_REGNUM\t12\n-\n-#define STATIC_CHAIN_REGNUM\t1\n-\n-#define\tRETURN_ADDRESS_REGNUM\t14\n-\n-#define FIRST_PARM_OFFSET(FNDECL)  0\n-\n-#define ELIMINABLE_REGS \\\n-  { \\\n-    { ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM}, \\\n-    { ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM}, \\\n-    { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}  \\\n-  }\n-\n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    (OFFSET) = crx_initial_elimination_offset ((FROM), (TO));\t\t\\\n-  } while (0)\n-\n-/*****************************************************************************/\n-/* PASSING FUNCTION ARGUMENTS\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#define ACCUMULATE_OUTGOING_ARGS (TARGET_NO_PUSH_ARGS)\n-\n-#define PUSH_ARGS (!TARGET_NO_PUSH_ARGS)\n-\n-#define PUSH_ROUNDING(BYTES) (((BYTES) + 3) & ~3)\n-\n-#ifndef CUMULATIVE_ARGS\n-struct cumulative_args\n-{\n-  int ints;\n-};\n-\n-#define CUMULATIVE_ARGS struct cumulative_args\n-#endif\n-\n-/* On the CRX architecture, Varargs routines should receive their parameters on\n- * the stack.  */\n-\n-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, FNDECL, N_NAMED_ARGS) \\\n-  crx_init_cumulative_args(&(CUM), (FNTYPE), (LIBNAME))\n-\n-#define FUNCTION_ARG_REGNO_P(REGNO)  crx_function_arg_regno_p(REGNO)\n-\n-/*****************************************************************************/\n-/* RETURNING FUNCTION VALUE\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-/* On the CRX, the return value is in R0 */\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-\tgen_rtx_REG(TYPE_MODE (VALTYPE), 0)\n-\n-#define LIBCALL_VALUE(MODE)\tgen_rtx_REG (MODE, 0)\n-\n-#define FUNCTION_VALUE_REGNO_P(N)\t((N) == 0)\n-\n-#define CRX_STRUCT_VALUE_REGNUM  0\n-\n-/*****************************************************************************/\n-/* GENERATING CODE FOR PROFILING - NOT IMPLEMENTED\t\t\t     */\n-/*****************************************************************************/\n-\n-#undef  FUNCTION_PROFILER\n-#define FUNCTION_PROFILER(STREAM, LABELNO)\t\\\n-{\t\t\t\t\t\t\\\n-    sorry (\"profiler support for CRX\");\t\t\\\n-}\n-\t\n-/*****************************************************************************/\n-/* TRAMPOLINES FOR NESTED FUNCTIONS - NOT SUPPORTED      \t\t     */\n-/*****************************************************************************/\n-\n-#define TRAMPOLINE_SIZE\t32\n-\n-/*****************************************************************************/\n-/* ADDRESSING MODES\t\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#define CONSTANT_ADDRESS_P(X)\t\t\t\t\t\t\\\n-  (GET_CODE (X) == LABEL_REF\t\t\t\t\t\t\\\n-   || GET_CODE (X) == SYMBOL_REF\t\t\t\t\t\\\n-   || GET_CODE (X) == CONST\t\t\t\t\t\t\\\n-   || GET_CODE (X) == CONST_INT)\n-\n-#define MAX_REGS_PER_ADDRESS 2\n-\n-#define HAVE_POST_INCREMENT  1\n-#define HAVE_POST_DECREMENT  1\n-#define HAVE_POST_MODIFY_DISP 1\n-#define HAVE_POST_MODIFY_REG 0\n-\n-#ifdef REG_OK_STRICT\n-#define REG_OK_FOR_BASE_P(X)\tREGNO_OK_FOR_BASE_P (REGNO (X))\n-#define REG_OK_FOR_INDEX_P(X)\tREGNO_OK_FOR_INDEX_P (REGNO (X))\n-#else\n-#define REG_OK_FOR_BASE_P(X)\t1\n-#define REG_OK_FOR_INDEX_P(X)\t1\n-#endif /* REG_OK_STRICT */\n-\n-#define LEGITIMATE_CONSTANT_P(X)  1\n-\n-/*****************************************************************************/\n-/* CONDITION CODE STATUS\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-/*****************************************************************************/\n-/* RELATIVE COSTS OF OPERATIONS\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#define MEMORY_MOVE_COST(MODE, CLASS, IN) crx_memory_move_cost(MODE, CLASS, IN)\n-/* Moving to processor register flushes pipeline - thus asymmetric */\n-#define REGISTER_MOVE_COST(MODE, FROM, TO) ((TO != GENERAL_REGS) ? 8 : 2)\n-/* Assume best case (branch predicted) */\n-#define BRANCH_COST(speed_p, predictable_p) 2\n-\n-#define SLOW_BYTE_ACCESS  1\n-\n-/*****************************************************************************/\n-/* DIVIDING THE OUTPUT INTO SECTIONS\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#define TEXT_SECTION_ASM_OP\t\"\\t.section\\t.text\"\n-\n-#define DATA_SECTION_ASM_OP\t\"\\t.section\\t.data\"\n-\n-#define BSS_SECTION_ASM_OP\t\"\\t.section\\t.bss\"\n-\n-/*****************************************************************************/\n-/* POSITION INDEPENDENT CODE\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#define PIC_OFFSET_TABLE_REGNUM  12\n-\n-#define LEGITIMATE_PIC_OPERAND_P(X)  1\n-\n-/*****************************************************************************/\n-/* ASSEMBLER FORMAT\t\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#define GLOBAL_ASM_OP \"\\t.globl\\t\"\n-\n-#undef\tUSER_LABEL_PREFIX\n-#define\tUSER_LABEL_PREFIX \"_\"\n-\n-#undef\tASM_OUTPUT_LABELREF\n-#define ASM_OUTPUT_LABELREF(STREAM, NAME) \\\n-  asm_fprintf (STREAM, \"%U%s\", (*targetm.strip_name_encoding) (NAME));\n-\n-#undef\tASM_APP_ON\n-#define ASM_APP_ON   \"#APP\\n\"\n-\n-#undef\tASM_APP_OFF\n-#define ASM_APP_OFF  \"#NO_APP\\n\"\n-\n-/*****************************************************************************/\n-/* INSTRUCTION OUTPUT\t\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#define REGISTER_NAMES \\\n-  { \\\n-    \"r0\",  \"r1\",  \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\", \\\n-    \"r8\",  \"r9\",  \"r10\", \"r11\", \"r12\", \"r13\", \"ra\",  \"sp\", \\\n-    \"lo\",  \"hi\",  \"cc\" \\\n-  }\n-\n-#define PRINT_OPERAND(STREAM, X, CODE) \\\n-  crx_print_operand(STREAM, X, CODE)\n-\n-#define PRINT_OPERAND_ADDRESS(STREAM, ADDR) \\\n-  crx_print_operand_address(STREAM, ADDR)\n-\n-/*****************************************************************************/\n-/* OUTPUT OF DISPATCH TABLES\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM, VALUE) \\\n-  asm_fprintf ((STREAM), \"\\t.long\\t.L%d\\n\", (VALUE))\n-\n-/*****************************************************************************/\n-/* ALIGNMENT IN ASSEMBLER FILE\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#define ASM_OUTPUT_ALIGN(STREAM, POWER) \\\n-  asm_fprintf ((STREAM), \"\\t.align\\t%d\\n\", 1 << (POWER))\n-\n-/*****************************************************************************/\n-/* MISCELLANEOUS PARAMETERS\t\t\t\t\t\t     */\n-/*****************************************************************************/\n-\n-#define CASE_VECTOR_MODE  Pmode\n-\n-#define MOVE_MAX 4\n-\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)  1\n-\n-#define STORE_FLAG_VALUE  1\n-\n-#define Pmode\t\tSImode\n-\n-#define FUNCTION_MODE\tQImode\n-\n-#endif /* ! GCC_CRX_H */"}, {"sha": "229e345d32fcf89d2be06feeaac8dd8033f4b8da", "filename": "gcc/config/crx/crx.md", "status": "removed", "additions": 0, "deletions": 899, "changes": 899, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fcrx%2Fcrx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fcrx%2Fcrx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.md?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,899 +0,0 @@\n-;; GCC machine description for CRX.\n-;; Copyright (C) 1988, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-;; 2001, 2002, 2003, 2004, 2007\n-;; Free Software Foundation, Inc.\n-;;\n-;; This file is part of GCC.\n-;;\n-;; GCC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 3, or (at your option)\n-;; any later version.\n-;;\n-;; GCC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-;;\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.  */\n-\n-;;  Register numbers\n-\n-(define_constants\n-  [(SP_REGNUM 15)\t; Stack pointer\n-   (RA_REGNUM 14)\t; Return address\n-   (LO_REGNUM 16)\t; LO register\n-   (HI_REGNUM 17)\t; HI register\n-   (CC_REGNUM 18)\t; Condition code register\n-  ]\n-)\n-\n-(define_attr \"length\" \"\" ( const_int 6 ))\n-\n-(define_asm_attributes\n-  [(set_attr \"length\" \"6\")]\n-)\n-\n-;;  Predicates\n-\n-(define_predicate \"u4bits_operand\"\n-  (match_code \"const_int,const_double\")\n-  {\n-    if (GET_CODE (op) == CONST_DOUBLE)\n-      return crx_const_double_ok (op);\n-    return (UNSIGNED_INT_FITS_N_BITS(INTVAL(op), 4)) ? 1 : 0;\n-  }\n-)\n-\n-(define_predicate \"cst4_operand\"\n-  (and (match_code \"const_int\")\n-       (match_test \"INT_CST4(INTVAL(op))\")))\n-\n-(define_predicate \"reg_or_u4bits_operand\"\n-  (ior (match_operand 0 \"u4bits_operand\")\n-       (match_operand 0 \"register_operand\")))\n-\n-(define_predicate \"reg_or_cst4_operand\"\n-  (ior (match_operand 0 \"cst4_operand\")\n-       (match_operand 0 \"register_operand\")))\n-\n-(define_predicate \"reg_or_sym_operand\"\n-  (ior (match_code \"symbol_ref\")\n-       (match_operand 0 \"register_operand\")))\n-\n-(define_predicate \"cc_reg_operand\"\n-  (and (match_code \"reg\")\n-       (match_test \"REGNO (op) == CC_REGNUM\")))\n-\n-(define_predicate \"nosp_reg_operand\"\n-  (and (match_operand 0 \"register_operand\")\n-       (match_test \"REGNO (op) != SP_REGNUM\")))\n-\n-(define_predicate \"store_operand\"\n-  (and (match_operand 0 \"memory_operand\")\n-       (not (match_operand 0 \"push_operand\"))))\n-\n-;;  Mode Macro Definitions\n-\n-(define_mode_iterator ALLMT [QI HI SI SF DI DF])\n-(define_mode_iterator CRXMM [QI HI SI SF])\n-(define_mode_iterator CRXIM [QI HI SI])\n-(define_mode_iterator DIDFM [DI DF])\n-(define_mode_iterator SISFM [SI SF])\n-(define_mode_iterator SHORT [QI HI])\n-\n-(define_mode_attr tIsa [(QI \"b\") (HI \"w\") (SI \"d\") (SF \"d\")])\n-(define_mode_attr lImmArith [(QI \"4\") (HI \"4\") (SI \"6\")])\n-(define_mode_attr lImmRotl [(QI \"2\") (HI \"2\") (SI \"4\")])\n-(define_mode_attr IJK [(QI \"I\") (HI \"J\") (SI \"K\")])\n-(define_mode_attr iF [(QI \"i\") (HI \"i\") (SI \"i\") (DI \"i\") (SF \"F\") (DF \"F\")])\n-(define_mode_attr JG [(QI \"J\") (HI \"J\") (SI \"J\") (DI \"J\") (SF \"G\") (DF \"G\")])\n-;   In HI or QI mode we push 4 bytes.\n-(define_mode_attr pushCnstr [(QI \"X\") (HI \"X\") (SI \"<\") (SF \"<\") (DI \"<\") (DF \"<\")])\n-(define_mode_attr tpush [(QI \"\") (HI \"\") (SI \"\") (SF \"\") (DI \"sp, \") (DF \"sp, \")])\n-(define_mode_attr lpush [(QI \"2\") (HI \"2\") (SI \"2\") (SF \"2\") (DI \"4\") (DF \"4\")])\n-\n-\n-;;  Code Macro Definitions\n-\n-(define_code_iterator sz_xtnd [sign_extend zero_extend])\n-(define_code_attr sIsa [(sign_extend \"\") (zero_extend \"u\")])\n-(define_code_attr sPat [(sign_extend \"s\") (zero_extend \"u\")])\n-(define_code_attr szPat [(sign_extend \"\") (zero_extend \"zero_\")])\n-(define_code_attr szIsa [(sign_extend \"s\") (zero_extend \"z\")])\n-\n-(define_code_iterator sh_oprnd [ashift ashiftrt lshiftrt])\n-(define_code_attr shIsa [(ashift \"ll\") (ashiftrt \"ra\") (lshiftrt \"rl\")])\n-(define_code_attr shPat [(ashift \"ashl\") (ashiftrt \"ashr\") (lshiftrt \"lshr\")])\n-\n-(define_code_iterator mima_oprnd [smax umax smin umin])\n-(define_code_attr mimaIsa [(smax \"maxs\") (umax \"maxu\") (smin \"mins\") (umin \"minu\")])\n-\n-;;  Addition Instructions\n-\n-(define_insn \"adddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n-\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0,0\")\n-\t\t (match_operand:DI 2 \"nonmemory_operand\" \"r,i\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"addd\\t%L2, %L1\\;addcd\\t%H2, %H1\"\n-  [(set_attr \"length\" \"4,12\")]\n-)\n-\n-(define_insn \"add<mode>3\"\n-  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r,r\")\n-\t(plus:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"%0,0\")\n-\t\t    (match_operand:CRXIM 2 \"nonmemory_operand\" \"r,i\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"add<tIsa>\\t%2, %0\"\n-  [(set_attr \"length\" \"2,<lImmArith>\")]\n-)\n-\n-;;  Subtract Instructions\n-\n-(define_insn \"subdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n-\t(minus:DI (match_operand:DI 1 \"register_operand\" \"0,0\")\n-\t\t  (match_operand:DI 2 \"nonmemory_operand\" \"r,i\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"subd\\t%L2, %L1\\;subcd\\t%H2, %H1\"\n-  [(set_attr \"length\" \"4,12\")]\n-)\n-\n-(define_insn \"sub<mode>3\"\n-  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r,r\")\n-\t(minus:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"0,0\")\n-\t\t     (match_operand:CRXIM 2 \"nonmemory_operand\" \"r,i\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"sub<tIsa>\\t%2, %0\"\n-  [(set_attr \"length\" \"2,<lImmArith>\")]\n-)\n-\n-;;  Multiply Instructions\n-\n-(define_insn \"mul<mode>3\"\n-  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r,r\")\n-\t(mult:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"%0,0\")\n-\t\t    (match_operand:CRXIM 2 \"nonmemory_operand\" \"r,i\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"mul<tIsa>\\t%2, %0\"\n-  [(set_attr \"length\" \"2,<lImmArith>\")]\n-)\n-\n-;;  Widening-multiplication Instructions\n-\n-(define_insn \"<sIsa>mulsidi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=k\")\n-\t(mult:DI (sz_xtnd:DI (match_operand:SI 1 \"register_operand\" \"%r\"))\n-\t\t (sz_xtnd:DI (match_operand:SI 2 \"register_operand\" \"r\"))))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"mull<sPat>d\\t%2, %1\"\n-  [(set_attr \"length\" \"4\")]\n-)\n-\n-(define_insn \"<sIsa>mulhisi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(mult:SI (sz_xtnd:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n-\t\t (sz_xtnd:SI (match_operand:HI 2 \"register_operand\" \"r\"))))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"mul<sPat>wd\\t%2, %0\"\n-  [(set_attr \"length\" \"4\")]\n-)\n-\n-(define_insn \"<sIsa>mulqihi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(mult:HI (sz_xtnd:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n-\t\t (sz_xtnd:HI (match_operand:QI 2 \"register_operand\" \"r\"))))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"mul<sPat>bw\\t%2, %0\"\n-  [(set_attr \"length\" \"4\")]\n-)\n-\n-;;  Logical Instructions - and\n-\n-(define_insn \"and<mode>3\"\n-  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r,r\")\n-\t(and:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"%0,0\")\n-\t\t   (match_operand:CRXIM 2 \"nonmemory_operand\" \"r,i\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"and<tIsa>\\t%2, %0\"\n-  [(set_attr \"length\" \"2,<lImmArith>\")]\n-)\n-\n-;;  Logical Instructions - or\n-\n-(define_insn \"ior<mode>3\"\n-  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r,r\")\n-\t(ior:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"%0,0\")\n-\t\t   (match_operand:CRXIM 2 \"nonmemory_operand\" \"r,i\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"or<tIsa>\\t%2, %0\"\n-  [(set_attr \"length\" \"2,<lImmArith>\")]\n-)\n-\n-;;  Logical Instructions - xor\n-\n-(define_insn \"xor<mode>3\"\n-  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r,r\")\n-\t(xor:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"%0,0\")\n-\t\t   (match_operand:CRXIM 2 \"nonmemory_operand\" \"r,i\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"xor<tIsa>\\t%2, %0\"\n-  [(set_attr \"length\" \"2,<lImmArith>\")]\n-)\n-\n-;;  Sign and Zero Extend Instructions\n-\n-(define_insn \"<szPat>extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(sz_xtnd:SI (match_operand:HI 1 \"register_operand\" \"r\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"<szIsa>extwd\\t%1, %0\"\n-  [(set_attr \"length\" \"4\")]\n-)\n-\n-(define_insn \"<szPat>extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(sz_xtnd:SI (match_operand:QI 1 \"register_operand\" \"r\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"<szIsa>extbd\\t%1, %0\"\n-  [(set_attr \"length\" \"4\")]\n-)\n-\n-(define_insn \"<szPat>extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(sz_xtnd:HI (match_operand:QI 1 \"register_operand\" \"r\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"<szIsa>extbw\\t%1, %0\"\n-  [(set_attr \"length\" \"4\")]\n-)\n-\n-;;  Negation Instructions\n-\n-(define_insn \"neg<mode>2\"\n-  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r\")\n-\t(neg:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"r\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"neg<tIsa>\\t%1, %0\"\n-  [(set_attr \"length\" \"4\")]\n-)\n-\n-;;  Absolute Instructions\n-\n-(define_insn \"abs<mode>2\"\n-  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r\")\n-\t(abs:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"r\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"abs<tIsa>\\t%1, %0\"\n-  [(set_attr \"length\" \"4\")]\n-)\n-\n-;;  Max and Min Instructions\n-\n-(define_insn \"<code><mode>3\"\n-  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r\")\n-\t(mima_oprnd:CRXIM (match_operand:CRXIM 1 \"register_operand\"  \"%0\")\n-\t\t\t  (match_operand:CRXIM 2 \"register_operand\"  \"r\")))]\n-  \"\"\n-  \"<mimaIsa><tIsa>\\t%2, %0\"\n-  [(set_attr \"length\" \"4\")]\n-)\n-\n-;;  One's Complement\n-\n-(define_insn \"one_cmpl<mode>2\"\n-  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r\")\n-\t(not:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"0\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"xor<tIsa>\\t$-1, %0\"\n-  [(set_attr \"length\" \"2\")]\n-)\n-\n-;;  Rotate Instructions\n-\n-(define_insn \"rotl<mode>3\"\n-  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r,r\")\n-\t(rotate:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"0,0\")\n-\t\t      (match_operand:CRXIM 2 \"nonmemory_operand\" \"r,<IJK>\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"@\n-  rotl<tIsa>\\t%2, %0\n-  rot<tIsa>\\t%2, %0\"\n-  [(set_attr \"length\" \"4,<lImmRotl>\")]\n-)\n-\n-(define_insn \"rotr<mode>3\"\n-  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r\")\n-\t(rotatert:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"0\")\n-\t\t\t(match_operand:CRXIM 2 \"register_operand\" \"r\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"rotr<tIsa>\\t%2, %0\"\n-  [(set_attr \"length\" \"4\")]\n-)\n-\n-;;  Arithmetic Left and Right Shift Instructions\n-\n-(define_insn \"<shPat><mode>3\"\n-  [(set (match_operand:CRXIM 0 \"register_operand\" \"=r,r\")\n-\t(sh_oprnd:CRXIM (match_operand:CRXIM 1 \"register_operand\" \"0,0\")\n-\t\t\t(match_operand:QI 2 \"nonmemory_operand\" \"r,<IJK>\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"s<shIsa><tIsa>\\t%2, %0\"\n-  [(set_attr \"length\" \"2,2\")]\n-)\n-\n-;;  Bit Set Instructions\n-\n-(define_insn \"extv\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")\n-\t\t\t (match_operand:SI 3 \"const_int_operand\" \"n\")))]\n-  \"\"\n-  {\n-    static char buf[100];\n-    int strpntr;\n-    int size = INTVAL (operands[2]);\n-    int pos = INTVAL (operands[3]);\n-    strpntr = sprintf (buf, \"ram\\t$%d, $31, $%d, %%1, %%0\\;\",\n-\t      BITS_PER_WORD - (size + pos), BITS_PER_WORD - size);\n-    sprintf (buf + strpntr, \"srad\\t$%d, %%0\", BITS_PER_WORD - size);\n-    return buf;\n-  }\n-  [(set_attr \"length\" \"6\")]\n-)\n-\n-(define_insn \"extzv\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")\n-\t\t\t (match_operand:SI 3 \"const_int_operand\" \"n\")))]\n-  \"\"\n-  {\n-    static char buf[40];\n-    int size = INTVAL (operands[2]);\n-    int pos = INTVAL (operands[3]);\n-    sprintf (buf, \"ram\\t$%d, $%d, $0, %%1, %%0\",\n-\t   (BITS_PER_WORD - pos) % BITS_PER_WORD, size - 1);\n-    return buf;\n-  }\n-  [(set_attr \"length\" \"4\")]\n-)\n-\n-(define_insn \"insv\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n-\t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\")\n-\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\"))\n-\t(match_operand:SI 3 \"register_operand\" \"r\"))]\n-  \"\"\n-  {\n-    static char buf[40];\n-    int size = INTVAL (operands[1]);\n-    int pos = INTVAL (operands[2]);\n-    sprintf (buf, \"rim\\t$%d, $%d, $%d, %%3, %%0\",\n-\t    pos, size + pos - 1, pos);\n-    return buf;\n-  }\n-  [(set_attr \"length\" \"4\")]\n-)\n-\n-;;  Move Instructions\n-\n-(define_expand \"mov<mode>\"\n-  [(set (match_operand:ALLMT 0 \"nonimmediate_operand\" \"\")\n-\t(match_operand:ALLMT 1 \"general_operand\" \"\"))]\n-  \"\"\n-  {\n-    if (!(reload_in_progress || reload_completed))\n-      {\n-\tif (!register_operand (operands[0], <MODE>mode))\n-\t  {\n-\t    if (push_operand (operands[0], <MODE>mode) ?\n-\t\t!nosp_reg_operand (operands[1], <MODE>mode) :\n-\t\t!reg_or_u4bits_operand (operands[1], <MODE>mode))\n-\t      {\n-\t\toperands[1] = copy_to_mode_reg (<MODE>mode, operands[1]);\n-\t      }\n-\t  }\n-      }\n-  }\n-)\n-\n-(define_insn \"push<mode>_internal\"\n-  [(set (match_operand:ALLMT 0 \"push_operand\" \"=<pushCnstr>\")\n-\t(match_operand:ALLMT 1 \"nosp_reg_operand\" \"b\"))]\n-  \"\"\n-  \"push\\t<tpush>%p1\"\n-  [(set_attr \"length\" \"<lpush>\")]\n-)\n-\n-(define_insn \"mov<mode>_regs\"\n-  [(set (match_operand:SISFM 0 \"register_operand\" \"=r, r, r, k\")\n-\t(match_operand:SISFM 1 \"nonmemory_operand\" \"r, <iF>, k, r\"))]\n-  \"\"\n-  \"@\n-  movd\\t%1, %0\n-  movd\\t%1, %0\n-  mfpr\\t%1, %0\n-  mtpr\\t%1, %0\"\n-  [(set_attr \"length\" \"2,6,4,4\")]\n-)\n-\n-(define_insn \"mov<mode>_regs\"\n-  [(set (match_operand:DIDFM 0 \"register_operand\" \"=r, r, r, k\")\n-\t(match_operand:DIDFM 1 \"nonmemory_operand\" \"r, <iF>, k, r\"))]\n-  \"\"\n-  {\n-    switch (which_alternative)\n-      {\n-      case 0: if (REGNO (operands[0]) > REGNO (operands[1]))\n-\t        return \"movd\\t%H1, %H0\\;movd\\t%L1, %L0\";\n-\t      else\n-\t        return \"movd\\t%L1, %L0\\;movd\\t%H1, %H0\";\n-      case 1: return \"movd\\t%H1, %H0\\;movd\\t%L1, %L0\";\n-      case 2: return \"mfpr\\t%H1, %H0\\;mfpr\\t%L1, %L0\";\n-      case 3: return \"mtpr\\t%H1, %H0\\;mtpr\\t%L1, %L0\";\n-      default: gcc_unreachable ();\n-      }\n-  }\n-  [(set_attr \"length\" \"4,12,8,8\")]\n-)\n-\n-(define_insn \"mov<mode>_regs\" ; no HI/QI mode in HILO regs\n-  [(set (match_operand:SHORT 0 \"register_operand\" \"=r, r\")\n-\t(match_operand:SHORT 1 \"nonmemory_operand\" \"r, i\"))]\n-  \"\"\n-  \"mov<tIsa>\\t%1, %0\"\n-  [(set_attr \"length\" \"2,<lImmArith>\")]\n-)\n-\n-(define_insn \"mov<mode>_load\"\n-  [(set (match_operand:CRXMM 0 \"register_operand\" \"=r\")\n-\t(match_operand:CRXMM 1 \"memory_operand\" \"m\"))]\n-  \"\"\n-  \"load<tIsa>\\t%1, %0\"\n-  [(set_attr \"length\" \"6\")]\n-)\n-\n-(define_insn \"mov<mode>_load\"\n-  [(set (match_operand:DIDFM 0 \"register_operand\" \"=r\")\n-\t(match_operand:DIDFM 1 \"memory_operand\" \"m\"))]\n-  \"\"\n-  {\n-    rtx first_dest_reg = gen_rtx_REG (SImode, REGNO (operands[0]));\n-    if (reg_overlap_mentioned_p (first_dest_reg, operands[1]))\n-      return \"loadd\\t%H1, %H0\\;loadd\\t%L1, %L0\";\n-    return \"loadd\\t%L1, %L0\\;loadd\\t%H1, %H0\";\n-  }\n-  [(set_attr \"length\" \"12\")]\n-)\n-\n-(define_insn \"mov<mode>_store\"\n-  [(set (match_operand:CRXMM 0 \"store_operand\" \"=m, m\")\n-\t(match_operand:CRXMM 1 \"reg_or_u4bits_operand\" \"r, <JG>\"))]\n-  \"\"\n-  \"stor<tIsa>\\t%1, %0\"\n-  [(set_attr \"length\" \"6\")]\n-)\n-\n-(define_insn \"mov<mode>_store\"\n-  [(set (match_operand:DIDFM 0 \"store_operand\" \"=m, m\")\n-\t(match_operand:DIDFM 1 \"reg_or_u4bits_operand\" \"r, <JG>\"))]\n-  \"\"\n-  \"stord\\t%H1, %H0\\;stord\\t%L1, %L0\"\n-  [(set_attr \"length\" \"12\")]\n-)\n-\n-;;  Movmem Instruction\n-\n-(define_expand \"movmemsi\"\n-  [(use (match_operand:BLK 0 \"memory_operand\" \"\"))\n-   (use (match_operand:BLK 1 \"memory_operand\" \"\"))\n-   (use (match_operand:SI 2 \"nonmemory_operand\" \"\"))\n-   (use (match_operand:SI 3 \"const_int_operand\" \"\"))]\n-  \"\"\n-  {\n-    if (crx_expand_movmem (operands[0], operands[1], operands[2], operands[3]))\n-      DONE;\n-    else\n-      FAIL;\n-  }\n-)\n-\n-;;  Compare and Branch Instructions\n-\n-(define_insn \"cbranchcc4\"\n-  [(set (pc)\n-       (if_then_else (match_operator 0 \"ordered_comparison_operator\"\n-\t\t       [(match_operand:CC 1 \"cc_reg_operand\" \"r\")\n-\t\t\t(match_operand 2 \"cst4_operand\" \"L\")])\n-                     (label_ref (match_operand 3 \"\"))\n-                     (pc)))]\n-  \"\"\n-  \"b%d0\\t%l3\"\n-  [(set_attr \"length\" \"6\")]\n-)\n-\n-(define_insn \"cbranch<mode>4\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"ordered_comparison_operator\"\n-\t\t\t[(match_operand:CRXIM 1 \"register_operand\" \"r\")\n-\t\t\t (match_operand:CRXIM 2 \"reg_or_cst4_operand\" \"rL\")])\n-\t\t      (label_ref (match_operand 3 \"\" \"\"))\n-\t\t      (pc)))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"cmpb%d0<tIsa>\\t%2, %1, %l3\"\n-  [(set_attr \"length\" \"6\")]\n-)\n-\n-\n-;;  Scond Instructions\n-\n-(define_expand \"cstore<mode>4\"\n-  [(set (reg:CC CC_REGNUM)\n-\t(compare:CC (match_operand:CRXIM 2 \"register_operand\" \"\")\n-\t\t    (match_operand:CRXIM 3 \"nonmemory_operand\" \"\")))\n-   (set (match_operand:SI 0 \"register_operand\")\n-\t(match_operator:SI 1 \"ordered_comparison_operator\"\n-\t[(reg:CC CC_REGNUM) (const_int 0)]))]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"cmp<mode>_internal\"\n-  [(set (reg:CC CC_REGNUM)\n-\t(compare:CC (match_operand:CRXIM 0 \"register_operand\" \"r,r\")\n-\t\t    (match_operand:CRXIM 1 \"nonmemory_operand\" \"r,i\")))]\n-  \"\"\n-  \"cmp<tIsa>\\t%1, %0\"\n-  [(set_attr \"length\" \"2,<lImmArith>\")]\n-)\n-\n-(define_insn \"sCOND_internal\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operator:SI 1 \"ordered_comparison_operator\"\n-\t  [(reg:CC CC_REGNUM) (const_int 0)]))]\n-  \"\"\n-  \"s%d1\\t%0\"\n-  [(set_attr \"length\" \"2\")]\n-)\n-\n-;;  Jumps and Branches\n-\n-(define_insn \"indirect_jump_return\"\n-  [(parallel\n-    [(set (pc)\n-\t  (reg:SI RA_REGNUM))\n-     (return)])\n-  ]\n-  \"reload_completed\"\n-  \"jump\\tra\"\n-  [(set_attr \"length\" \"2\")]\n-)\n-\n-(define_insn \"indirect_jump\"\n-  [(set (pc)\n-\t(match_operand:SI 0 \"reg_or_sym_operand\" \"r,i\"))]\n-  \"\"\n-  \"@\n-  jump\\t%0\n-  br\\t%a0\"\n-  [(set_attr \"length\" \"2,6\")]\n-)\n-\n-(define_insn \"interrupt_return\"\n-  [(parallel\n-    [(unspec_volatile [(const_int 0)] 0)\n-     (return)])]\n-  \"\"\n-  {\n-    return crx_prepare_push_pop_string (1);\n-  }\n-  [(set_attr \"length\" \"14\")]\n-)\n-\n-(define_insn \"jump_to_imm\"\n-  [(set (pc)\n-\t(match_operand 0 \"immediate_operand\" \"i\"))]\n-  \"\"\n-  \"br\\t%c0\"\n-  [(set_attr \"length\" \"6\")]\n-)\n-\n-(define_insn \"jump\"\n-  [(set (pc)\n-\t(label_ref (match_operand 0 \"\" \"\")))]\n-  \"\"\n-  \"br\\t%l0\"\n-  [(set_attr \"length\" \"6\")]\n-)\n-\n-;;  Function Prologue and Epilogue\n-\n-(define_expand \"prologue\"\n-  [(const_int 0)]\n-  \"\"\n-  {\n-    crx_expand_prologue ();\n-    DONE;\n-  }\n-)\n-\n-(define_insn \"push_for_prologue\"\n-  [(parallel\n-    [(set (reg:SI SP_REGNUM)\n-\t  (minus:SI (reg:SI SP_REGNUM)\n-\t\t    (match_operand:SI 0 \"immediate_operand\" \"i\")))])]\n-  \"reload_completed\"\n-  {\n-    return crx_prepare_push_pop_string (0);\n-  }\n-  [(set_attr \"length\" \"4\")]\n-)\n-\n-(define_expand \"epilogue\"\n-  [(return)]\n-  \"\"\n-  {\n-    crx_expand_epilogue ();\n-    DONE;\n-  }\n-)\n-\n-(define_insn \"pop_and_popret_return\"\n-  [(parallel\n-    [(set (reg:SI SP_REGNUM)\n-\t  (plus:SI (reg:SI SP_REGNUM)\n-\t\t   (match_operand:SI 0 \"immediate_operand\" \"i\")))\n-     (use (reg:SI RA_REGNUM))\n-     (return)])\n-  ]\n-  \"reload_completed\"\n-  {\n-    return crx_prepare_push_pop_string (1);\n-  }\n-  [(set_attr \"length\" \"4\")]\n-)\n-\n-(define_insn \"popret_RA_return\"\n-  [(parallel\n-    [(use (reg:SI RA_REGNUM))\n-     (return)])\n-  ]\n-  \"reload_completed\"\n-  \"popret\\tra\"\n-  [(set_attr \"length\" \"2\")]\n-)\n-\n-;;  Table Jump\n-\n-(define_insn \"tablejump\"\n-  [(set (pc)\n-\t(match_operand:SI 0 \"register_operand\" \"r\"))\n-\t(use (label_ref:SI (match_operand 1 \"\" \"\" )))]\n-  \"\"\n-  \"jump\\t%0\"\n-  [(set_attr \"length\" \"2\")]\n-)\n-\n-;;  Call Instructions\n-\n-(define_expand \"call\"\n-  [(call (match_operand:QI 0 \"memory_operand\" \"\")\n-\t (match_operand 1 \"\" \"\"))]\n-  \"\"\n-  {\n-    emit_call_insn (gen_crx_call (operands[0], operands[1]));\n-    DONE;\n-  }\n-)\n-\n-(define_expand \"crx_call\"\n-  [(parallel\n-    [(call (match_operand:QI 0 \"memory_operand\" \"\")\n-\t   (match_operand 1 \"\" \"\"))\n-     (clobber (reg:SI RA_REGNUM))])]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"crx_call_insn_branch\"\n-  [(call (mem:QI (match_operand:SI 0 \"immediate_operand\" \"i\"))\n-\t (match_operand 1 \"\" \"\"))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"+r\"))]\n-  \"\"\n-  \"bal\\tra, %a0\"\n-  [(set_attr \"length\" \"6\")]\n-)\n-\n-(define_insn \"crx_call_insn_jump\"\n-  [(call (mem:QI (match_operand:SI 0 \"register_operand\" \"r\"))\n-\t (match_operand 1 \"\" \"\"))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"+r\"))]\n-  \"\"\n-  \"jal\\t%0\"\n-  [(set_attr \"length\" \"2\")]\n-)\n-\n-(define_insn \"crx_call_insn_jalid\"\n-  [(call (mem:QI (mem:SI (plus:SI\n-\t\t\t   (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t   (match_operand:SI 1 \"register_operand\" \"r\"))))\n-\t (match_operand 2 \"\" \"\"))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"+r\"))]\n-  \"\"\n-  \"jalid\\t%0, %1\"\n-  [(set_attr \"length\" \"4\")]\n-)\n-\n-;;  Call Value Instructions\n-\n-(define_expand \"call_value\"\n-  [(set (match_operand 0 \"general_operand\" \"\")\n-\t(call (match_operand:QI 1 \"memory_operand\" \"\")\n-\t      (match_operand 2 \"\" \"\")))]\n-  \"\"\n-  {\n-    emit_call_insn (gen_crx_call_value (operands[0], operands[1], operands[2]));\n-    DONE;\n-  }\n-)\n-\n-(define_expand \"crx_call_value\"\n-  [(parallel\n-    [(set (match_operand 0 \"general_operand\" \"\")\n-\t  (call (match_operand 1 \"memory_operand\" \"\")\n-\t\t(match_operand 2 \"\" \"\")))\n-     (clobber (reg:SI RA_REGNUM))])]\n-  \"\"\n-  \"\"\n-)\n-\n-(define_insn \"crx_call_value_insn_branch\"\n-  [(set (match_operand 0 \"\" \"=g\")\n-\t(call (mem:QI (match_operand:SI 1 \"immediate_operand\" \"i\"))\n-\t      (match_operand 2 \"\" \"\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"+r\"))]\n-  \"\"\n-  \"bal\\tra, %a1\"\n-  [(set_attr \"length\" \"6\")]\n-)\n-\n-(define_insn \"crx_call_value_insn_jump\"\n-  [(set (match_operand 0 \"\" \"=g\")\n-\t(call (mem:QI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t      (match_operand 2 \"\" \"\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"+r\"))]\n-  \"\"\n-  \"jal\\t%1\"\n-  [(set_attr \"length\" \"2\")]\n-)\n-\n-(define_insn \"crx_call_value_insn_jalid\"\n-  [(set (match_operand 0 \"\" \"=g\")\n-\t(call (mem:QI (mem:SI (plus:SI\n-\t\t\t\t(match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t\t(match_operand:SI 2 \"register_operand\" \"r\"))))\n-\t      (match_operand 3 \"\" \"\")))\n-   (clobber (match_operand:SI 4 \"register_operand\" \"+r\"))]\n-  \"\"\n-  \"jalid\\t%0, %1\"\n-  [(set_attr \"length\" \"4\")]\n-)\n-\n-;;  Nop\n-\n-(define_insn \"nop\"\n-  [(const_int 0)]\n-  \"\"\n-  \"\"\n-)\n-\n-;;  Multiply and Accumulate Instructions\n-\n-(define_insn \"<sPat>madsidi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"+k\")\n-\t(plus:DI\n-\t  (mult:DI (sz_xtnd:DI (match_operand:SI 1 \"register_operand\" \"%r\"))\n-\t\t   (sz_xtnd:DI (match_operand:SI 2 \"register_operand\" \"r\")))\n-\t  (match_dup 0)))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_MAC\"\n-  \"mac<sPat>d\\t%2, %1\"\n-  [(set_attr \"length\" \"4\")]\n-)\n-\n-(define_insn \"<sPat>madhisi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"+l\")\n-\t(plus:SI\n-\t  (mult:SI (sz_xtnd:SI (match_operand:HI 1 \"register_operand\" \"%r\"))\n-\t\t   (sz_xtnd:SI (match_operand:HI 2 \"register_operand\" \"r\")))\n-\t  (match_dup 0)))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_MAC\"\n-  \"mac<sPat>w\\t%2, %1\"\n-  [(set_attr \"length\" \"4\")]\n-)\n-\n-(define_insn \"<sPat>madqihi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"+l\")\n-\t(plus:HI\n-\t  (mult:HI (sz_xtnd:HI (match_operand:QI 1 \"register_operand\" \"%r\"))\n-\t\t   (sz_xtnd:HI (match_operand:QI 2 \"register_operand\" \"r\")))\n-\t  (match_dup 0)))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_MAC\"\n-  \"mac<sPat>b\\t%2, %1\"\n-  [(set_attr \"length\" \"4\")]\n-)\n-\n-;;  Loop Instructions\n-\n-(define_expand \"doloop_end\"\n-  [(use (match_operand 0 \"\" \"\"))\t; loop pseudo\n-   (use (match_operand 1 \"\" \"\"))\t; iterations; zero if unknown\n-   (use (match_operand 2 \"\" \"\"))\t; max iterations\n-   (use (match_operand 3 \"\" \"\"))\t; loop level\n-   (use (match_operand 4 \"\" \"\"))]       ; label\n-  \"\"\n-  {\n-    if (INTVAL (operands[3]) > crx_loop_nesting)\n-      FAIL;\n-    switch (GET_MODE (operands[0]))\n-      {\n-      case SImode:\n-\temit_jump_insn (gen_doloop_end_si (operands[4], operands[0]));\n-\tbreak;\n-      case HImode:\n-\temit_jump_insn (gen_doloop_end_hi (operands[4], operands[0]));\n-\tbreak;\n-      case QImode:\n-\temit_jump_insn (gen_doloop_end_qi (operands[4], operands[0]));\n-\tbreak;\n-      default:\n-\tFAIL;\n-      }\n-    DONE;\n-  }\n-)\n-\n-;   CRX dbnz[bwd] used explicitly (see above) but also by the combiner.\n-\n-(define_insn \"doloop_end_<mode>\"\n-  [(set (pc)\n-\t(if_then_else (ne (match_operand:CRXIM 1 \"register_operand\" \"+r,!m\")\n-\t\t\t  (const_int 1))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))\n-   (set (match_dup 1) (plus:CRXIM (match_dup 1) (const_int -1)))\n-   (clobber (match_scratch:CRXIM 2 \"=X,r\"))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"\"\n-  \"@\n-  dbnz<tIsa>\\t%1, %l0\n-  load<tIsa>\\t%1, %2\\;add<tIsa>\\t$-1, %2\\;stor<tIsa>\\t%2, %1\\;bne\\t%l0\"\n-  [(set_attr \"length\" \"6, 12\")]\n-)"}, {"sha": "7ff0be0e3a9234f5e93631368766eeeef5488983", "filename": "gcc/config/crx/crx.opt", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fcrx%2Fcrx.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fcrx%2Fcrx.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Fcrx.opt?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,34 +0,0 @@\n-; Options for the National Semiconductor CRX port of the compiler.\n-\n-; Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n-;\n-; This file is part of GCC.\n-;\n-; GCC is free software; you can redistribute it and/or modify it under\n-; the terms of the GNU General Public License as published by the Free\n-; Software Foundation; either version 3, or (at your option) any later\n-; version.\n-;\n-; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-; for more details.\n-;\n-; You should have received a copy of the GNU General Public License\n-; along with GCC; see the file COPYING3.  If not see\n-; <http://www.gnu.org/licenses/>.\n-\n-mmac\n-Target Report Mask(MAC)\n-Support multiply accumulate instructions\n-\n-mno-push-args\n-Target Report RejectNegative Mask(NO_PUSH_ARGS)\n-Do not use push to store function arguments\n-\n-mloop-nesting=\n-Common RejectNegative Joined UInteger Var(crx_loop_nesting) Init(12)\n-Restrict doloop to the given nesting level\n-\n-mdebug-addr\n-Target RejectNegative Var(TARGET_DEBUG_ADDR) Undocumented"}, {"sha": "8bb62c6525f3fdbae4f831ae52809a8e39666d99", "filename": "gcc/config/crx/t-crx", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fcrx%2Ft-crx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fcrx%2Ft-crx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcrx%2Ft-crx?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,37 +0,0 @@\n-# CRX Target Makefile\n-#\n-# Copyright (C) 2005 Free Software Foundation, Inc.\n-#\n-# This file is part of GCC.\n-#\n-# GCC is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3, or (at your option)\n-# any later version.\n-#\n-# GCC is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with GCC; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-# Mingw specific compilation fixes\n-USE_COLLECT2 =\n-STMP_FIXINC =\n-\n-# Software emulation for integer div and mod\n-LIB2FUNCS_EXTRA = $(srcdir)/config/udivmodsi4.c $(srcdir)/config/udivmod.c $(srcdir)/config/divmod.c\n-\n-# Build the floating point emulation libraries.\n-FPBIT = fp-bit.c\n-DPBIT = dp-bit.c\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define FLOAT' > fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n-\n-dp-bit.c: $(srcdir)/config/fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c > dp-bit.c"}, {"sha": "318951a770ad3b0bb0d1b840d781df6d5fe5de35", "filename": "gcc/config/i386/netbsd.h", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fi386%2Fnetbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fi386%2Fnetbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fnetbsd.h?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,96 +0,0 @@\n-/* Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-   2004 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#define TARGET_OS_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      NETBSD_OS_CPP_BUILTINS_AOUT();\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-#define TARGET_VERSION fprintf (stderr, \" (NetBSD/i386 a.out)\");\n-\n-/* This goes away when the math-emulator is fixed */\n-#undef TARGET_SUBTARGET_DEFAULT\n-#define TARGET_SUBTARGET_DEFAULT \\\n-  (MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS | MASK_NO_FANCY_MATH_387)\n-\n-#undef SUBTARGET_EXTRA_SPECS\n-#define SUBTARGET_EXTRA_SPECS\t\t\t\\\n-  { \"netbsd_cpp_spec\", NETBSD_CPP_SPEC },\n-\n-#undef CPP_SPEC\n-#define CPP_SPEC \"%(netbsd_cpp_spec)\"\n-\n-\f\n-#undef SIZE_TYPE\n-#define SIZE_TYPE \"unsigned int\"\n-\n-#undef PTRDIFF_TYPE\n-#define PTRDIFF_TYPE \"int\"\n-\n-#undef ASM_APP_ON\n-#define ASM_APP_ON \"#APP\\n\"\n-\n-#undef ASM_APP_OFF\n-#define ASM_APP_OFF \"#NO_APP\\n\"\n-\n-/* Don't default to pcc-struct-return, because gcc is the only compiler, and\n-   we want to retain compatibility with older gcc versions.  */\n-#define DEFAULT_PCC_STRUCT_RETURN 0\n-\f\n-/* i386 netbsd still uses old binutils that don't insert nops by default\n-   when the .align directive demands to insert extra space in the text\n-   segment.  */\n-#undef ASM_OUTPUT_ALIGN\n-#define ASM_OUTPUT_ALIGN(FILE,LOG) \\\n-  if ((LOG)!=0) fprintf ((FILE), \"\\t.align %d,0x90\\n\", (LOG))\n-\f\n-/* Profiling routines, partially copied from i386/osfrose.h.  */\n-\n-/* Redefine this to use %eax instead of %edx.  */\n-#undef FUNCTION_PROFILER\n-#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (flag_pic)\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tcall mcount@PLT\\n\");\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tcall mcount\\n\");\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* Until they use ELF or something that handles dwarf2 unwinds\n-   and initialization stuff better.  */\n-#define DWARF2_UNWIND_INFO 0\n-\n-/* Redefine this so that it becomes \"_GLOBAL_OFFSET_TABLE_\" when the label\n-   prefix is added.  */\n-#undef GOT_SYMBOL_NAME\n-#define GOT_SYMBOL_NAME \"GLOBAL_OFFSET_TABLE_\"\n-\n-/* Attempt to enable execute permissions on the stack.  */\n-#define ENABLE_EXECUTE_STACK NETBSD_ENABLE_EXECUTE_STACK"}, {"sha": "09f946cbf9087ab4e5a8b9432a05bc2c3da06272", "filename": "gcc/config/m68hc11/larith.asm", "status": "removed", "additions": 0, "deletions": 1333, "changes": 1333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68hc11%2Flarith.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68hc11%2Flarith.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Flarith.asm?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,1333 +0,0 @@\n-/* libgcc routines for M68HC11 & M68HC12.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2008, 2009\n-   Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 3, or (at your option) any\n-later version.\n-\n-This file is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifdef __HAVE_SHORT_INT__\n-\t.mode mshort\n-#else\n-\t.mode mlong\n-#endif\n-\n-\t.macro declare_near name\n-\t.globl \\name\n-\t.type  \\name,@function\n-\t.size  \\name,.Lend-\\name\n-\\name:\n-\t.endm\n-\n-#if defined(__USE_RTC__)\n-# define ARG(N) N+1\n-\n-\t.macro ret\n-#if defined(mc68hc12)\n-\trtc\n-#else\n-\tjmp __return_32\n-#endif\n-\t.endm\n-\n-\t.macro declare name\n-\t.globl \\name\n-\t.type  \\name,@function\n-\t.size  \\name,.Lend-\\name\n-\t.far   \\name\n-\\name:\n-\t.endm\n-\n-\t.macro farsym name\n-\t.far NAME\n-\t.endm\n-\n-#else\n-# define ARG(N) N\n-\n-\t.macro ret\n-\trts\n-\t.endm\n-\n-\t.macro farsym name\n-\t.endm\n-\n-\t.macro declare name\n-\t.globl \\name\n-\t.type  \\name,@function\n-\t.size  \\name,.Lend-\\name\n-\\name:\n-\t.endm\n-\n-#endif\n-\n-\t.sect .text\n-\t\n-\n-#define REG(NAME)\t\t\t\\\n-NAME:\t.dc.w\t1;\t\t\t\\\n-\t.type NAME,@object ;\t\t\\\n-\t.size NAME,2\n-\n-#ifdef L_regs_min\n-/* Pseudo hard registers used by gcc.\n-   They should be located in page0.  */\n-\n-\t.sect .softregs\n-\t.globl _.tmp\n-\t.globl _.z,_.xy\n-REG(_.tmp)\n-REG(_.z)\n-REG(_.xy)\n-\n-#endif\n-\n-#ifdef L_regs_frame\n-\t.sect .softregs\n-\t.globl _.frame\n-REG(_.frame)\n-#endif\n-\n-#ifdef L_regs_d1_2\n-\t.sect .softregs\n-\t.globl _.d1,_.d2\n-REG(_.d1)\n-REG(_.d2)\n-#endif\n-\n-#ifdef L_regs_d3_4\n-\t.sect .softregs\n-\t.globl _.d3,_.d4\n-REG(_.d3)\n-REG(_.d4)\n-#endif\n-\n-#ifdef L_regs_d5_6\n-\t.sect .softregs\n-\t.globl _.d5,_.d6\n-REG(_.d5)\n-REG(_.d6)\n-#endif\n-\n-#ifdef L_regs_d7_8\n-\t.sect .softregs\n-\t.globl _.d7,_.d8\n-REG(_.d7)\n-REG(_.d8)\n-#endif\n-\n-#ifdef L_regs_d9_16\n-/* Pseudo hard registers used by gcc.\n-   They should be located in page0.  */\n-\t.sect .softregs\n-\t.globl _.d9,_.d10,_.d11,_.d12,_.d13,_.d14\n-\t.globl _.d15,_.d16\n-REG(_.d9)\n-REG(_.d10)\n-REG(_.d11)\n-REG(_.d12)\n-REG(_.d13)\n-REG(_.d14)\n-REG(_.d15)\n-REG(_.d16)\n-\n-#endif\n-\n-#ifdef L_regs_d17_32\n-/* Pseudo hard registers used by gcc.\n-   They should be located in page0.  */\n-\t.sect .softregs\n-\t.globl _.d17,_.d18,_.d19,_.d20,_.d21,_.d22\n-\t.globl _.d23,_.d24,_.d25,_.d26,_.d27,_.d28\n-\t.globl _.d29,_.d30,_.d31,_.d32\n-REG(_.d17)\n-REG(_.d18)\n-REG(_.d19)\n-REG(_.d20)\n-REG(_.d21)\n-REG(_.d22)\n-REG(_.d23)\n-REG(_.d24)\n-REG(_.d25)\n-REG(_.d26)\n-REG(_.d27)\n-REG(_.d28)\n-REG(_.d29)\n-REG(_.d30)\n-REG(_.d31)\n-REG(_.d32)\n-#endif\n-\n-#ifdef L_premain\n-;;\n-;; Specific initialization for 68hc11 before the main.\n-;; Nothing special for a generic routine; Just enable interrupts.\n-;;\n-\tdeclare_near\t__premain\n-\tclra\n-\ttap\t; Clear both I and X.\n-\trts\n-#endif\n-\n-#ifdef L__exit\n-;;\n-;; Exit operation.  Just loop forever and wait for interrupts.\n-;; (no other place to go)\n-;; This operation is split in several pieces collected together by\n-;; the linker script.  This allows to support destructors at the\n-;; exit stage while not impacting program sizes when there is no\n-;; destructors.\n-;;\n-;; _exit:\n-;;    *(.fini0)\t\t/* Beginning of finish code (_exit symbol).  */\n-;;    *(.fini1)\t\t/* Place holder for applications.  */\n-;;    *(.fini2)\t\t/* C++ destructors.  */\n-;;    *(.fini3)\t\t/* Place holder for applications.  */\n-;;    *(.fini4)\t\t/* Runtime exit.  */\n-;;\n-\t.sect .fini0,\"ax\",@progbits\n-\t.globl _exit\n-\t.globl exit\n-\t.weak  exit\n-\tfarsym  exit\n-\tfarsym  _exit\n-exit:\n-_exit:\n-\n-\t.sect .fini4,\"ax\",@progbits\n-fatal:\n-\tcli\n-\twai\n-\tbra fatal\n-#endif\n-\n-#ifdef L_abort\n-;;\n-;; Abort operation.  This is defined for the GCC testsuite.\n-;;\n-\tdeclare\tabort\n-\n-\tldd\t#255\t\t; \n-#ifdef mc68hc12\n-\ttrap\t#0x30\n-#else\n-\t.byte 0xCD\t\t; Generate an illegal instruction trap\n-\t.byte 0x03\t\t; The simulator catches this and stops.\n-#endif\n-\tjmp _exit\n-#endif\n-\t\n-#ifdef L_cleanup\n-;;\n-;; Cleanup operation used by exit().\n-;;\n-\tdeclare\t_cleanup\n-\n-\tret\n-#endif\n-\n-;-----------------------------------------\n-; required gcclib code\n-;-----------------------------------------\n-#ifdef L_memcpy\n-       declare\tmemcpy\n-       declare\t__memcpy\n-\n-\t.weak memcpy\n-;;;\n-;;; void* memcpy(void*, const void*, size_t)\n-;;; \n-;;; D    = dst\tPmode\n-;;; 2,sp = src\tPmode\n-;;; 4,sp = size\tHImode (size_t)\n-;;; \n-#ifdef mc68hc12\n-\tldx\tARG(2),sp\n-\tldy\tARG(4),sp\n-\tpshd\n-\txgdy\n-\tlsrd\n-\tbcc\tStart\n-\tmovb\t1,x+,1,y+\n-Start:\n-\tbeq\tDone\n-Loop:\n-\tmovw\t2,x+,2,y+\n-\tdbne\td,Loop\n-Done:\n-\tpuld\n-\tret\n-#else\n-\txgdy\n-\ttsx\n-\tldd\tARG(4),x\n-\tldx\tARG(2),x\t; SRC = X, DST = Y\n-\tcpd\t#0\n-\tbeq\tEnd\n-\tpshy\n-\tinca\t\t\t; Correction for the deca below\n-L0:\n-\tpsha\t\t\t; Save high-counter part\n-L1:\n-\tldaa\t0,x\t\t; Copy up to 256 bytes\n-\tstaa\t0,y\n-\tinx\n-\tiny\n-\tdecb\n-\tbne\tL1\n-\tpula\n-\tdeca\n-\tbne\tL0\n-\tpuly\t\t\t; Restore Y to return the DST\n-End:\n-\txgdy\n-\tret\n-#endif\n-#endif\n-\n-#ifdef L_memset\n-       declare\tmemset\n-       declare\t__memset\n-;;;\n-;;; void* memset(void*, int value, size_t)\n-;;; \n-#ifndef __HAVE_SHORT_INT__\n-;;; D    = dst\tPmode\n-;;; 2,sp = src\tSImode\n-;;; 6,sp = size\tHImode (size_t)\n-\tval  = ARG(5)\n-\tsize = ARG(6)\n-#else\n-;;; D    = dst\tPmode\n-;;; 2,sp = src\tSImode\n-;;; 6,sp = size\tHImode (size_t)\n-\tval  = ARG(3)\n-\tsize = ARG(4)\n-#endif\n-#ifdef mc68hc12\n-\txgdx\n-\tldab\tval,sp\n-\tldy\tsize,sp\n-\tpshx\n-\tbeq\tEnd\n-Loop:\n-\tstab\t1,x+\n-\tdbne\ty,Loop\n-End:\n-\tpuld\n-\tret\n-#else\n-\txgdx\n-\ttsy\n-\tldab\tval,y\n-\tldy\tsize,y\t\t; DST = X, CNT = Y\n-\tbeq\tEnd\n-\tpshx\n-L0:\n-\tstab\t0,x\t\t; Fill up to 256 bytes\n-\tinx\n-\tdey\n-\tbne\tL0\n-\tpulx\t\t\t; Restore X to return the DST\n-End:\n-\txgdx\n-\tret\n-#endif\n-#endif\n-\n-#ifdef L_adddi3\n-\tdeclare\t___adddi3\n-\n-\ttsx\n-\txgdy\n-\tldd\tARG(8),x\t\t; Add LSB\n-\taddd\tARG(16),x\n-\tstd\t6,y\t\t; Save (carry preserved)\n-\n-\tldd\tARG(6),x\n-\tadcb\tARG(15),x\n-\tadca\tARG(14),x\n-\tstd\t4,y\n-\n-\tldd\tARG(4),x\n-\tadcb\tARG(13),x\n-\tadca\tARG(12),x\n-\tstd\t2,y\n-\t\n-\tldd\tARG(2),x\n-\tadcb\tARG(11),x\t\t; Add MSB\n-\tadca\tARG(10),x\n-\tstd\t0,y\n-\n-\txgdy\n-\tret\n-#endif\n-\n-#ifdef L_subdi3\n-\tdeclare\t___subdi3\n-\n-\ttsx\n-\txgdy\n-\tldd\tARG(8),x\t\t; Subtract LSB\n-\tsubd\tARG(16),x\n-\tstd\t6,y\t\t\t; Save, borrow preserved\n-\n-\tldd\tARG(6),x\n-\tsbcb\tARG(15),x\n-\tsbca\tARG(14),x\n-\tstd\t4,y\n-\n-\tldd\tARG(4),x\n-\tsbcb\tARG(13),x\n-\tsbca\tARG(12),x\n-\tstd\t2,y\n-\t\n-\tldd\tARG(2),x\t\t; Subtract MSB\n-\tsbcb\tARG(11),x\n-\tsbca\tARG(10),x\n-\tstd\t0,y\n-\n-\txgdy\t\t\t;\n-\tret\n-#endif\n-\t\n-#ifdef L_notdi2\n-\tdeclare\t___notdi2\n-\n-\ttsy\n-\txgdx\n-\tldd\tARG(8),y\n-\tcoma\n-\tcomb\n-\tstd\t6,x\n-\t\n-\tldd\tARG(6),y\n-\tcoma\n-\tcomb\n-\tstd\t4,x\n-\n-\tldd\tARG(4),y\n-\tcoma\n-\tcomb\n-\tstd\t2,x\n-\n-\tldd\tARG(2),y\n-\tcoma\n-\tcomb\n-\tstd\t0,x\n-\txgdx\n-\tret\n-#endif\n-\t\n-#ifdef L_negsi2\n-\tdeclare_near ___negsi2\n-\n-\tcomb\n-\tcoma\n-\txgdx\n-\tcomb\n-\tcoma\n-\tinx\n-\txgdx\n-\tbne\tdone\n-\tinx\n-done:\n-\trts\n-#endif\n-\n-#ifdef L_one_cmplsi2\n-\tdeclare_near ___one_cmplsi2\n-\n-\tcomb\n-\tcoma\n-\txgdx\n-\tcomb\n-\tcoma\n-\txgdx\n-\trts\n-#endif\n-\t\n-#ifdef L_ashlsi3\n-\tdeclare_near ___ashlsi3\n-\n-\txgdy\n-\tclra\n-\tandb\t#0x1f\n-\txgdy\n-\tbeq\tReturn\n-Loop:\n-\tlsld\n-\txgdx\n-\trolb\n-\trola\n-\txgdx\n-\tdey\n-\tbne\tLoop\n-Return:\n-\trts\n-#endif\n-\n-#ifdef L_ashrsi3\n-\tdeclare_near ___ashrsi3\n-\n-\txgdy\n-\tclra\n-\tandb\t#0x1f\n-\txgdy\n-\tbeq\tReturn\n-Loop:\n-\txgdx\n-\tasra\n-\trorb\n-\txgdx\n-\trora\n-\trorb\n-\tdey\n-\tbne\tLoop\n-Return:\n-\trts\n-#endif\n-\n-#ifdef L_lshrsi3\n-\tdeclare_near ___lshrsi3\n-\n-\txgdy\n-\tclra\n-\tandb\t#0x1f\n-\txgdy\n-\tbeq\tReturn\n-Loop:\n-\txgdx\n-\tlsrd\n-\txgdx\n-\trora\n-\trorb\n-\tdey\n-\tbne\tLoop\n-Return:\n-\trts\n-#endif\n-\n-#ifdef L_lshrhi3\n-\tdeclare_near ___lshrhi3\n-\n-\tcpx\t#16\n-\tbge\tReturn_zero\n-\tcpx\t#0\n-\tbeq\tReturn\n-Loop:\n-\tlsrd\n-\tdex\n-\tbne\tLoop\n-Return:\n-\trts\n-Return_zero:\n-\tclra\n-\tclrb\n-\trts\n-#endif\n-\t\n-#ifdef L_lshlhi3\n-\tdeclare_near ___lshlhi3\n-\n-\tcpx\t#16\n-\tbge\tReturn_zero\n-\tcpx\t#0\n-\tbeq\tReturn\n-Loop:\n-\tlsld\n-\tdex\n-\tbne\tLoop\n-Return:\n-\trts\n-Return_zero:\n-\tclra\n-\tclrb\n-\trts\n-#endif\n-\n-#ifdef L_rotrhi3\n-\tdeclare_near ___rotrhi3\n-\n-___rotrhi3:\n-\txgdx\n-\tclra\n-\tandb\t#0x0f\n-\txgdx\n-\tbeq\tReturn\n-Loop:\n-\ttap\n-\trorb\n-\trora\n-\tdex\n-\tbne\tLoop\n-Return:\n-\trts\n-#endif\n-\n-#ifdef L_rotlhi3\n-\tdeclare_near ___rotlhi3\n-\n-___rotlhi3:\n-\txgdx\n-\tclra\n-\tandb\t#0x0f\n-\txgdx\n-\tbeq\tReturn\n-Loop:\n-\tasrb\n-\trolb\n-\trola\n-\trolb\n-\tdex\n-\tbne\tLoop\n-Return:\n-\trts\n-#endif\n-\n-#ifdef L_ashrhi3\n-\tdeclare_near ___ashrhi3\n-\n-\tcpx\t#16\n-\tbge\tReturn_minus_1_or_zero\n-\tcpx\t#0\n-\tbeq\tReturn\n-Loop:\n-\tasra\n-\trorb\n-\tdex\n-\tbne\tLoop\n-Return:\n-\trts\n-Return_minus_1_or_zero:\n-\tclrb\n-\ttsta\n-\tbpl\tReturn_zero\n-\tcomb\n-Return_zero:\n-\ttba\n-\trts\n-#endif\n-\t\n-#ifdef L_ashrqi3\n-\tdeclare_near ___ashrqi3\n-\n-\tcmpa\t#8\n-\tbge\tReturn_minus_1_or_zero\n-\ttsta\n-\tbeq\tReturn\n-Loop:\n-\tasrb\n-\tdeca\n-\tbne\tLoop\n-Return:\n-\trts\n-Return_minus_1_or_zero:\n-\tclrb\n-\ttstb\n-\tbpl\tReturn_zero\n-\tcoma\n-Return_zero:\n-\ttab\n-\trts\n-#endif\n-\n-#ifdef L_lshlqi3\n-\tdeclare_near ___lshlqi3\n-\n-\tcmpa\t#8\n-\tbge\tReturn_zero\n-\ttsta\n-\tbeq\tReturn\n-Loop:\n-\tlslb\n-\tdeca\n-\tbne\tLoop\n-Return:\n-\trts\n-Return_zero:\n-\tclrb\n-\trts\n-#endif\n-\n-#ifdef L_divmodhi4\n-#ifndef mc68hc12\n-/* 68HC12 signed divisions are generated inline (idivs).  */\n-\n-\tdeclare_near __divmodhi4\n-\n-;\n-;; D = numerator\n-;; X = denominator\n-;;\n-;; Result:\tD = D / X\n-;;\t\tX = D % X\n-;; \n-\ttsta\n-\tbpl\tNumerator_pos\n-\tcomb\t\t\t; D = -D <=> D = (~D) + 1\n-\tcoma\n-\txgdx\n-\tinx\n-\ttsta\n-\tbpl\tNumerator_neg_denominator_pos\n-Numerator_neg_denominator_neg:\n-\tcomb\t\t\t; X = -X\n-\tcoma\n-\taddd\t#1\n-\txgdx\n-\tidiv\n-\tcoma\n-\tcomb\n-\txgdx\t\t\t; Remainder <= 0 and result >= 0\n-\tinx\n-\trts\n-\n-Numerator_pos_denominator_pos:\n-\txgdx\n-\tidiv\n-\txgdx\t\t\t; Both values are >= 0\n-\trts\n-\t\n-Numerator_pos:\n-\txgdx\n-\ttsta\n-\tbpl\tNumerator_pos_denominator_pos\n-Numerator_pos_denominator_neg:\n-\tcoma\t\t\t; X = -X\n-\tcomb\n-\txgdx\n-\tinx\n-\tidiv\n-\txgdx\t\t\t; Remainder >= 0 but result <= 0\n-\tcoma\n-\tcomb\n-\taddd\t#1\n-\trts\n-\t\n-Numerator_neg_denominator_pos:\n-\txgdx\n-\tidiv\n-\tcoma\t\t\t; One value is > 0 and the other < 0\n-\tcomb\t\t\t; Change the sign of result and remainder\n-\txgdx\n-\tinx\n-\tcoma\n-\tcomb\n-\taddd\t#1\n-\trts\n-#endif /* !mc68hc12 */\n-#endif\n-\n-#ifdef L_mulqi3\n-\tdeclare_near ___mulqi3\n-\n-;\n-; short __mulqi3(signed char a, signed char b);\n-;\n-;\tsigned char a\t-> register A\n-;\tsigned char b\t-> register B\n-;\n-; returns the signed result of A * B in register D.\n-;\n-\ttsta\n-\tbmi\tA_neg\n-\ttstb\n-\tbmi\tB_neg\n-\tmul\n-\trts\n-B_neg:\n-\tnegb\n-\tbra\tA_or_B_neg\n-A_neg:\n-\tnega\n-\ttstb\n-\tbmi\tAB_neg\n-A_or_B_neg:\n-\tmul\n-\tcoma\n-\tcomb\n-\taddd\t#1\n-\trts\n-AB_neg:\n-\tnegb\n-\tmul\n-\trts\n-#endif\n-\t\n-#ifdef L_mulhi3\n-\tdeclare_near ___mulhi3\n-\n-;\n-;\n-;  unsigned short ___mulhi3(unsigned short a, unsigned short b)\n-;\n-;\ta = register D\n-;\tb = register X\n-;\n-#ifdef mc68hc12\n-\tpshx\t\t\t; Preserve X\n-\texg\tx,y\n-\temul\n-\texg\tx,y\n-\tpulx\n-\trts\n-#else\n-#ifdef NO_TMP\n-\t;\n-\t; 16-bit multiplication without temp memory location.\n-\t; (smaller but slower)\n-\t;\n-\tpshx\t\t\t; (4)\n-\tins\t\t\t; (3)\n-\tpshb\t\t\t; (3)\n-\tpsha\t\t\t; (3)\n-\tpshx\t\t\t; (4)\n-\tpula\t\t\t; (4)\n-\tpulx\t\t\t; (5)\n-\tmul\t\t\t; (10) B.high * A.low\n-\txgdx\t\t\t; (3)\n-\tmul\t\t\t; (10) B.low * A.high\n-\tabx\t\t\t; (3)\n-\tpula\t\t\t; (4)\n-\tpulb\t\t\t; (4)\n-\tmul\t\t\t; (10) B.low * A.low\n-\tpshx\t\t\t; (4) \n-\ttsx\t\t\t; (3)\n-\tadda\t1,x\t\t; (4)\n-\tpulx\t\t\t; (5)\n-\trts\t\t\t; (5) 20 bytes\n-\t\t\t\t; ---\n-\t\t\t\t; 91 cycles\n-#else\n-\tstx\t*_.tmp\t\t; (4)\n-\tpshb\t\t\t; (3)\n-\tldab\t*_.tmp+1\t; (3)\n-\tmul\t\t\t; (10) A.high * B.low\n-\tldaa\t*_.tmp\t\t; (3)\n-\tstab\t*_.tmp\t\t; (3)\n-\tpulb\t\t\t; (4)\n-\tpshb\t\t\t; (4)\n-\tmul\t\t\t; (10) A.low * B.high\n-\taddb\t*_.tmp\t\t; (4)\n-\tstab\t*_.tmp\t\t; (3)\n-\tldaa\t*_.tmp+1\t; (3)\n-\tpulb\t\t\t; (4)\n-\tmul\t\t\t; (10) A.low * B.low\n-\tadda\t*_.tmp\t\t; (4)\n-\trts\t\t\t; (5) 24/32 bytes\n-\t\t\t\t; 77/85 cycles\n-#endif\n-#endif\n-#endif\n-\n-#ifdef L_mulhi32\n-\n-;\n-;\n-;  unsigned long __mulhi32(unsigned short a, unsigned short b)\n-;\n-;\ta = register D\n-;\tb = value on stack\n-;\n-;\t+---------------+\n-;       |  B low\t| <- 7,x\n-;\t+---------------+\n-;       |  B high\t| <- 6,x\n-;\t+---------------+\n-;       |  PC low\t|  \n-;\t+---------------+\n-;       |  PC high\t|  \n-;\t+---------------+\n-;\t|  Tmp low\t|\n-;\t+---------------+\n-;\t|  Tmp high     |\n-;\t+---------------+\n-;\t|  A low\t|\n-;\t+---------------+\n-;\t|  A high\t|\n-;\t+---------------+  <- 0,x\n-;\n-;\n-;      <B-low>    5,x\n-;      <B-high>   4,x\n-;      <ret>      2,x\n-;      <A-low>    1,x\n-;      <A-high>   0,x\n-;\n-\tdeclare_near\t__mulhi32\n-\n-#ifdef mc68hc12\n-\tldy\t2,sp\n-\temul\n-\texg\tx,y\n-\trts\n-#else\n-\tpshx\t\t\t; Room for temp value\n-\tpshb\n-\tpsha\n-\ttsx\n-\tldab\t6,x\n-\tmul\n-\txgdy\t\t\t; A.high * B.high\n-\tldab\t7,x\n-\tpula\n-\tmul\t\t\t; A.high * B.low\n-\tstd\t2,x\n-\tldaa\t1,x\n-\tldab\t6,x\n-\tmul\t\t\t; A.low * B.high\n-\taddd\t2,x\n-\tstab\t2,x\n-\ttab\n-\taby\n-\tbcc\tN\n-\tldab\t#0xff\n-\taby\n-\tiny\n-N:\n-\tldab\t7,x\n-\tpula\n-\tmul\t\t\t; A.low * B.low\n-\tadda\t2,x\n-\tpulx\t\t\t; Drop temp location\n-\tpshy\t\t\t; Put high part in X\n-\tpulx\n-\tbcc\tRet\n-\tinx\n-Ret:\n-\trts\n-#endif\t\n-#endif\n-\n-#ifdef L_mulsi3\n-\n-;\n-;      <B-low>    8,y\n-;      <B-high>   6,y\n-;      <ret>      4,y\n-;\t<tmp>\t  2,y\n-;      <A-low>    0,y\n-;\n-; D,X   -> A\n-; Stack -> B\n-;\n-; The result is:\n-;\n-;\t(((A.low * B.high) + (A.high * B.low)) << 16) + (A.low * B.low)\n-;\n-;\n-;\n-\n-\tdeclare\t__mulsi3\n-\n-#ifdef mc68hc12\n-\tpshd\t\t\t\t; Save A.low\n-\tldy\tARG(4),sp\n-\temul\t\t\t\t; A.low * B.high\n-\tldy\tARG(6),sp\n-\texg\tx,d\n-\temul\t\t\t\t; A.high * B.low\n-\tleax\td,x\n-\tldy\tARG(6),sp\n-\tpuld\n-\temul\t\t\t\t; A.low * B.low\n-\texg\td,y\n-\tleax\td,x\n-\texg\td,y\n-\tret\n-#else\n-B_low\t=\tARG(8)\n-B_high\t=\tARG(6)\n-A_low\t=\t0\n-A_high\t=\t2\n-\tpshx\n-\tpshb\n-\tpsha\n-\ttsy\n-;\n-; If B.low is 0, optimize into: (A.low * B.high) << 16\n-;\n-\tldd\tB_low,y\n-\tbeq\tB_low_zero\n-;\n-; If A.high is 0, optimize into: (A.low * B.high) << 16 + (A.low * B.low)\n-;\n-\tcpx\t#0\n-\tbeq\tA_high_zero\n-\tbsr\t___mulhi3\t\t; A.high * B.low\n-;\n-; If A.low is 0, optimize into: (A.high * B.low) << 16\n-;\n-\tldx\tA_low,y\n-\tbeq\tA_low_zero\t\t; X = 0, D = A.high * B.low\n-\tstd\t2,y\n-;\n-; If B.high is 0, we can avoid the (A.low * B.high) << 16 term.\n-;\n-\tldd\tB_high,y\n-\tbeq\tB_high_zero\n-\tbsr\t___mulhi3\t\t; A.low * B.high\n-\taddd\t2,y\n-\tstd\t2,y\n-;\n-; Here, we know that A.low and B.low are not 0.\n-;\n-B_high_zero:\n-\tldd\tB_low,y\t\t\t; A.low is on the stack\n-\tbsr\t__mulhi32\t\t; A.low * B.low\n-\txgdx\n-\ttsy\t\t\t\t; Y was clobbered, get it back\n-\taddd\t2,y\n-A_low_zero:\t\t\t\t; See A_low_zero_non_optimized below\n-\txgdx\n-Return:\n-\tins\n-\tins\n-\tins\n-\tins\n-\tret\n-;\n-; \n-; A_low_zero_non_optimized:\n-;\n-; At this step, X = 0 and D = (A.high * B.low)\n-; Optimize into: (A.high * B.low) << 16\n-;\n-;\txgdx\n-;\tclra\t\t\t; Since X was 0, clearing D is superfuous.\n-;\tclrb\n-;\tbra\tReturn\n-; ----------------\n-; B.low == 0, the result is:\t(A.low * B.high) << 16\n-;\n-; At this step:\n-;   D = B.low\t\t\t\t= 0 \n-;   X = A.high\t\t\t\t?\n-;       A.low is at A_low,y\t\t?\n-;       B.low is at B_low,y\t\t?\n-;\n-B_low_zero:\n-\tldd\tA_low,y\n-\tbeq\tZero1\n-\tldx\tB_high,y\n-\tbeq\tZero2\n-\tbsr\t___mulhi3\n-Zero1:\n-\txgdx\n-Zero2:\n-\tclra\n-\tclrb\n-\tbra\tReturn\n-; ----------------\n-; A.high is 0, optimize into: (A.low * B.high) << 16 + (A.low * B.low)\n-;\n-; At this step:\n-;   D = B.low\t\t\t\t!= 0 \n-;   X = A.high\t\t\t\t= 0\n-;       A.low is at A_low,y\t\t?\n-;       B.low is at B_low,y\t\t?\n-;\n-A_high_zero:\n-\tldd\tA_low,y\t\t; A.low\n-\tbeq\tZero1\n-\tldx\tB_high,y\t; B.high\n-\tbeq\tA_low_B_low\n-\tbsr\t___mulhi3\n-\tstd\t2,y\n-\tbra\tB_high_zero\t; Do the (A.low * B.low) and the add.\n-\n-; ----------------\n-; A.high and B.high are 0 optimize into: (A.low * B.low)\n-;\n-; At this step:\n-;   D = B.high\t\t\t\t= 0 \n-;   X = A.low\t\t\t\t!= 0\n-;       A.low is at A_low,y\t\t!= 0\n-;       B.high is at B_high,y\t\t= 0\n-;\n-A_low_B_low:\n-\tldd\tB_low,y\t\t\t; A.low is on the stack\n-\tbsr\t__mulhi32\n-\tbra\tReturn\n-#endif\n-#endif\n-\n-#ifdef L_map_data\n-\n-\t.sect\t.install2,\"ax\",@progbits\n-\t.globl\t__map_data_section\n-\t.globl __data_image\n-#ifdef mc68hc12\n-\t.globl __data_section_size\n-#endif\n-__map_data_section:\n-#ifdef mc68hc12\n-\tldx\t#__data_image\n-\tldy\t#__data_section_start\n-\tldd\t#__data_section_size\n-\tbeq\tDone\n-Loop:\n-\tmovb\t1,x+,1,y+\n-\tdbne\td,Loop\n-#else\n-\tldx\t#__data_image\n-\tldy\t#__data_section_start\n-\tbra\tStart_map\n-Loop:\n-\tldaa\t0,x\n-\tstaa\t0,y\n-\tinx\n-\tiny\n-Start_map:\n-\tcpx\t#__data_image_end\n-\tblo\tLoop\n-#endif\n-Done:\n-\n-#endif\n-\n-#ifdef L_init_bss\n-\n-\t.sect\t.install2,\"ax\",@progbits\n-\t.globl\t__init_bss_section\n-\n-__init_bss_section:\n-\tldd\t#__bss_size\n-\tbeq\tDone\n-\tldx\t#__bss_start\n-Loop:\n-#ifdef mc68hc12\n-\tclr\t1,x+\n-\tdbne\td,Loop\n-#else\n-\tclr\t0,x\n-\tinx\n-\tsubd\t#1\n-\tbne\tLoop\n-#endif\n-Done:\n-\n-#endif\n-\n-#ifdef L_ctor\n-\n-; End of constructor table\n-\t.sect\t.install3,\"ax\",@progbits\n-\t.globl\t__do_global_ctors\n-\n-__do_global_ctors:\n-\t; Start from the end - sizeof(void*)\n-\tldx\t#__CTOR_END__-2\n-ctors_loop:\n-\tcpx\t#__CTOR_LIST__\n-\tblo\tctors_done\n-\tpshx\n-\tldx\t0,x\n-\tjsr\t0,x\n-\tpulx\n-\tdex\n-\tdex\n-\tbra\tctors_loop\n-ctors_done:\n-\n-#endif\n-\n-#ifdef L_dtor\n-\n-\t.sect\t.fini3,\"ax\",@progbits\n-\t.globl\t__do_global_dtors\n-\n-;;\n-;; This piece of code is inserted in the _exit() code by the linker.\n-;;\n-__do_global_dtors:\n-\tpshb\t; Save exit code\n-\tpsha\n-\tldx\t#__DTOR_LIST__\n-dtors_loop:\n-\tcpx\t#__DTOR_END__\n-\tbhs\tdtors_done\n-\tpshx\n-\tldx\t0,x\n-\tjsr\t0,x\n-\tpulx\n-\tinx\n-\tinx\n-\tbra\tdtors_loop\n-dtors_done:\n-\tpula\t; Restore exit code\n-\tpulb\n-\n-#endif\n-\n-#ifdef L_far_tramp\n-#ifdef mc68hc12\n-\t.sect\t.tramp,\"ax\",@progbits\n-\t.globl\t__far_trampoline\n-\n-;; This is a trampoline used by the linker to invoke a function\n-;; using rtc to return and being called with jsr/bsr.\n-;; The trampoline generated is:\n-;;\n-;;\tfoo_tramp:\n-;;\t\tldy\t#foo\n-;;\t\tcall\t__far_trampoline,page(foo)\n-;;\n-;; The linker transforms:\n-;;\n-;;\t\tjsr\tfoo\n-;;\n-;; into\n-;;\t\tjsr\tfoo_tramp\n-;;\n-;; The linker generated trampoline and _far_trampoline must be in \n-;; non-banked memory.\n-;;\n-__far_trampoline:\n-\tmovb\t0,sp, 2,sp\t; Copy page register below the caller's return\n-\tleas\t2,sp\t\t; address.\n-\tjmp\t0,y\t\t; We have a 'call/rtc' stack layout now\n-\t\t\t\t; and can jump to the far handler\n-\t\t\t\t; (whose memory bank is mapped due to the\n-\t\t\t\t; call to the trampoline).\n-#endif\n-\n-#ifdef mc68hc11\n-\t.sect\t.tramp,\"ax\",@progbits\n-\t.globl __far_trampoline\n-\n-;; Trampoline generated by gcc for 68HC11:\n-;;\n-;;\tpshb\n-;;\tldab\t#%page(func)\n-;;\tldy\t#%addr(func)\n-;;\tjmp\t__far_trampoline\n-;;\n-__far_trampoline:\n-\tpsha\t\t\t\t; (2) Save function parameter (high)\n-\t;; <Read current page in A>\n-\tpsha\t\t\t\t; (2)\n-\t;; <Set currenge page from B>\n-\tpshx\t\t\t\t; (4)\n-\ttsx\t\t\t\t; (3)\n-\tldab\t4,x\t\t\t; (4) Restore function parameter (low)\n-\tldaa\t2,x\t\t\t; (4) Get saved page number\n-\tstaa\t4,x\t\t\t; (4) Save it below return PC\n-\tpulx\t\t\t\t; (5)\n-\tpula\t\t\t\t; (3)\n-\tpula\t\t\t\t; (3) Restore function parameter (high)\n-\tjmp\t0,y\t\t\t; (4)\n-#endif\n-#endif\n-\n-#ifdef L_call_far\n-#ifdef mc68hc11\n-\t.sect\t.tramp,\"ax\",@progbits\n-\t.globl __call_a16\n-\t.globl __call_a32\n-;;\n-;; The call methods are used for 68HC11 to support memory bank switching.\n-;; Every far call is redirected to these call methods.  Its purpose is to:\n-;;\n-;;  1/ Save the current page on the stack (1 byte to follow 68HC12 call frame)\n-;;  2/ Install the new page\n-;;  3/ Jump to the real function\n-;;\n-;; The page switching (get/save) is board dependent.  The default provided\n-;; here does nothing (just create the appropriate call frame).\n-;;\n-;; Call sequence (10 bytes, 13 cycles):\n-;;\n-;;\tldx #page\t\t\t; (3)\n-;;\tldy #func\t\t\t; (4)\n-;;\tjsr __call_a16\t\t\t; (6)\n-;;\n-;; Call trampoline (11 bytes, 19 cycles):\n-;;\n-__call_a16:\n-\t;; xgdx\t\t\t\t; (3)\n-\t;; <Read current page in A>\t; (3) ldaa _current_page\n-\tpsha\t\t\t\t; (2)\n-\t;; <Set current page from B>\t; (4) staa _current_page\n-\t;; xgdx\t\t\t\t; (3)\n-\tjmp 0,y\t\t\t\t; (4)\n-\n-;;\n-;; Call sequence (10 bytes, 14 cycles):\n-;;\n-;;\tpshb\t\t\t\t; (2)\n-;;\tldab #page\t\t\t; (2)\n-;;\tldy  #func\t\t\t; (4)\n-;;\tjsr __call_a32\t\t\t; (6)\n-;;\n-;; Call trampoline (87 bytes, 57 cycles):\n-;;\n-__call_a32:\n-\tpshx\t\t\t\t; (4)\n-\tpsha\t\t\t\t; (2)\n-\t;; <Read current page in A>\t; (3) ldaa _current_page\n-\tpsha\t\t\t\t; (2)\n-\t;; <Set current page from B>\t; (4) staa _current_page\n-\ttsx\t\t\t\t; (3)\n-\tldab\t6,x\t\t\t; (4) Restore function parameter\n-\tldaa\t5,x\t\t\t; (4) Move PC return at good place\n-\tstaa\t6,x\t\t\t; (4)\n-\tldaa\t4,x\t\t\t; (4)\n-\tstaa\t5,x\t\t\t; (4)\n-\tpula\t\t\t\t; (3)\n-\tstaa\t4,x\t\t\t; (4)\n-\tpula\t\t\t\t; (3)\n-\tpulx\t\t\t\t; (5)\n-\tjmp\t0,y\t\t\t; (4)\n-#endif\n-#endif\n-\n-#ifdef L_return_far\n-#ifdef mc68hc11\n-\t.sect\t.tramp,\"ax\",@progbits\n-       .globl __return_void\n-       .globl __return_16\n-       .globl __return_32\n-\n-__return_void:\n-\t;; pulb\n-\t;; <Set current page from B> (Board specific)\n-\t;; rts\n-__return_16:\n-\t;; xgdx\n-\t;; pulb\n-\t;; <Set current page from B> (Board specific)\n-\t;; xgdx\n-\t;; rts\n-__return_32:\n-\t;; xgdy\n-\t;; pulb\n-\t;; <Set current page from B> (Board specific)\n-\t;; xgdy\n-\t;; rts\n-\tins\n-\trts\n-#endif\n-#endif\n-.Lend:\n-;-----------------------------------------\n-; end required gcclib code\n-;-----------------------------------------"}, {"sha": "429ab0f270dc2d4fe401df03c2c36c5acda2c23c", "filename": "gcc/config/m68hc11/m68hc11-crt0.S", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-crt0.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-crt0.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-crt0.S?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,86 +0,0 @@\n-/* Startup code for M68HC11.\n-   Copyright (C) 1999, 2000, 2002, 2008, 2009 Free Software Foundation, Inc.\n-\n-This file is free software; you can redistribute it and/or modify it\n-under the terms of the GNU General Public License as published by the\n-Free Software Foundation; either version 3, or (at your option) any\n-later version.\n-\n-This file is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\t\n-;-----------------------------------------\n-; startup code\n-;-----------------------------------------\n-\n-#ifdef __HAVE_SHORT_INT__\n-\t.mode mshort\n-#else\n-\t.mode mlong\n-#endif\n-\n-#if defined(__USE_RTC__) && defined(mc68hc12)\n-\t.macro jsr name\n-\tcall\t\\name\n-\t.endm\n-#endif\n-;; \n-;; \n-;; The linker concatenate the .install* sections in the following order:\n-;; \n-;; .install0\tSetup the stack pointer\n-;; .install1\tPlace holder for applications\n-;; .install2\tOptional installation of data section in memory\n-;; .install3\tPlace holder for applications\n-;; .install4\tInvokes the main\n-;; \n-\t.sect   .install0,\"ax\",@progbits\n-\t.globl _start\n-\n-_start:\n-;;\n-;; At this step, the stack is not initialized and interrupts are masked.\n-;; Applications only have 64 cycles to initialize some registers.\n-;;\n-;; To have a generic/configurable startup, initialize the stack to\n-;; the end of some memory region.  The _stack symbol is defined by\n-;; the linker.\n-;;\n-\tlds\t#_stack\n-\t\n-\t.sect\t.install2,\"ax\",@progbits\n-;;\n-;; Call a specific initialization operation.  The default is empty.\n-;; It can be overridden by applications.  It is intended to initialize\n-;; the 68hc11 registers.  Function prototype is:\n-;; \n-;;\tint __premain(void);\n-;; \n-\tjsr\t__premain\n-\t\n-;;\n-;; \n-;;\n-\t.sect\t.install4,\"ax\",@progbits\n-\tjsr     main\n-fatal:\n-\tjsr\texit\n-\tbra fatal\n-\n-;-----------------------------------------\n-; end startup code\n-;-----------------------------------------\n-;; Force loading of data section mapping and bss clear\n-\t.2byte\t__map_data_section\n-\t.2byte  __init_bss_section"}, {"sha": "76b6659379e094c5265d17c965cc0d67737555eb", "filename": "gcc/config/m68hc11/m68hc11-protos.h", "status": "removed", "additions": 0, "deletions": 109, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11-protos.h?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,109 +0,0 @@\n-/* Prototypes for exported functions defined in m68hc11.c\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009, 2010\n-   Free Software Foundation, Inc.\n-   Contributed by Stephane Carrez (stcarrez@nerim.fr)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-extern int hard_regno_mode_ok (int, enum machine_mode);\n-extern int m68hc11_hard_regno_rename_ok (int, int);\n-\n-extern int m68hc11_total_frame_size (void);\n-extern int m68hc11_initial_frame_pointer_offset (void);\n-extern int m68hc11_initial_elimination_offset (int, int);\n-\n-extern void expand_prologue (void);\n-extern void expand_epilogue (void);\n-\n-#ifdef RTX_CODE\n-extern int m68hc11_auto_inc_p (rtx);\n-\n-extern rtx m68hc11_expand_compare_and_branch (enum rtx_code, rtx, rtx, rtx);\n-extern enum reg_class preferred_reload_class (rtx, enum reg_class);\n-\n-extern void m68hc11_notice_update_cc (rtx, rtx);\n-extern void m68hc11_notice_keep_cc (rtx);\n-\n-extern void m68hc11_gen_movqi (rtx, rtx*);\n-extern void m68hc11_gen_movhi (rtx, rtx*);\n-extern void m68hc11_gen_rotate (enum rtx_code, rtx, rtx*);\n-\n-extern void m68hc11_output_swap (rtx, rtx*);\n-\n-extern int next_insn_test_reg (rtx, rtx);\n-\n-extern int m68hc11_reload_operands (rtx*);\n-\n-extern int dead_register_here (rtx, rtx);\n-\n-extern int push_pop_operand_p (rtx);\n-extern void m68hc11_split_move (rtx, rtx, rtx);\n-extern void m68hc11_split_compare_and_branch (enum rtx_code,\n-                                              rtx, rtx, rtx);\n-\n-extern rtx m68hc11_gen_lowpart (enum machine_mode, rtx);\n-extern rtx m68hc11_gen_highpart (enum machine_mode, rtx);\n-\n-#ifdef HAVE_MACHINE_MODES\n-extern int m68hc11_memory_move_cost (enum machine_mode, enum reg_class, int);\n-extern int m68hc11_register_move_cost (enum machine_mode,\n-                                       enum reg_class, enum reg_class);\n-\n-extern void m68hc11_emit_libcall (const char*, enum rtx_code,\n-                                  enum machine_mode, enum machine_mode,\n-                                  int, rtx*);\n-extern int m68hc11_small_indexed_indirect_p (rtx, enum machine_mode);\n-extern int m68hc11_symbolic_p (rtx, enum machine_mode);\n-extern int m68hc11_indirect_p (rtx, enum machine_mode);\n-extern int go_if_legitimate_address2 (rtx, enum machine_mode, int);\n-\n-extern int reg_or_indexed_operand (rtx,enum machine_mode);\n-extern int memory_indexed_operand (rtx, enum machine_mode);\n-\n-#ifdef RTX_CODE\n-extern void m68hc11_split_logical (enum machine_mode, enum rtx_code, rtx*);\n-#endif\n-\n-extern int m68hc11_register_indirect_p (rtx, enum machine_mode);\n-extern int m68hc11_valid_addressing_p (rtx, enum machine_mode, int);\n-\n-extern int symbolic_memory_operand (rtx, enum machine_mode);\n-\n-extern int memory_reload_operand (rtx, enum machine_mode);\n-extern int arith_src_operand (rtx, enum machine_mode);\n-extern int soft_reg_operand (rtx, enum machine_mode);\n-\n-extern void m68hc11_init_cumulative_args (CUMULATIVE_ARGS*, tree, rtx);\n-\n-#ifdef ARGS_SIZE_RTX\n-extern enum direction m68hc11_function_arg_padding (enum machine_mode,\n-\t\t\t\t\t\t    const_tree);\n-#endif\n-\n-extern void m68hc11_function_epilogue (FILE*,int);\n-\n-extern int m68hc11_is_far_symbol (rtx);\n-extern int m68hc11_is_trap_symbol (rtx);\n-extern int m68hc11_page0_symbol_p (rtx x);\n-\n-extern HOST_WIDE_INT m68hc11_min_offset;\n-extern HOST_WIDE_INT m68hc11_max_offset;\n-extern int m68hc11_addr_mode;\n-\n-#endif /* HAVE_MACHINE_MODES */\n-#endif /* RTX_CODE */"}, {"sha": "1e414102c3f1fed985e4fb8db7954342e965190b", "filename": "gcc/config/m68hc11/m68hc11.c", "status": "removed", "additions": 0, "deletions": 5588, "changes": 5588, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.c?ref=999a7d80b587700fc74639d0da5849c4f2eb31db"}, {"sha": "8f6d06867ee2c7ff98da113c375856f92dca82cd", "filename": "gcc/config/m68hc11/m68hc11.h", "status": "removed", "additions": 0, "deletions": 1382, "changes": 1382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.h?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,1382 +0,0 @@\n-/* Definitions of target machine for GNU compiler.\n-   Motorola 68HC11 and 68HC12.\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010\n-   Free Software Foundation, Inc.\n-   Contributed by Stephane Carrez (stcarrez@nerim.fr)\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.\n-\n-Note:\n-   A first 68HC11 port was made by Otto Lind (otto@coactive.com)\n-   on gcc 2.6.3.  I have used it as a starting point for this port.\n-   However, this new port is a complete re-write.  Its internal\n-   design is completely different.  The generated code is not\n-   compatible with the gcc 2.6.3 port.\n-\n-   The gcc 2.6.3 port is available at:\n-\n-   ftp.unina.it/pub/electronics/motorola/68hc11/gcc/gcc-6811-fsf.tar.gz\n-\n-*/\n-\n-/*****************************************************************************\n-**\n-** Controlling the Compilation Driver, `gcc'\n-**\n-*****************************************************************************/\n-\n-#undef ENDFILE_SPEC\n-\n-/* Compile and assemble for a 68hc11 unless there is a -m68hc12 option.  */\n-#ifndef ASM_SPEC\n-#define ASM_SPEC                                                \\\n-\"%{m68hc12:-m68hc12}\"                                           \\\n-\"%{m68hcs12:-m68hcs12}\"                                         \\\n-\"%{!m68hc12:%{!m68hcs12:-m68hc11}} \"                            \\\n-\"%{mshort:-mshort}%{!mshort:-mlong} \"                           \\\n-\"%{fshort-double:-mshort-double}%{!fshort-double:-mlong-double}\"\n-#endif\n-\n-/* We need to tell the linker the target elf format.  Just pass an\n-   emulation option.  This can be overridden by -Wl option of gcc.  */\n-#ifndef LINK_SPEC\n-#define LINK_SPEC                                               \\\n-\"%{m68hc12:-m m68hc12elf}\"                                      \\\n-\"%{m68hcs12:-m m68hc12elf}\"                                     \\\n-\"%{!m68hc12:%{!m68hcs12:-m m68hc11elf}} \"                       \\\n-\"%{!mnorelax:%{!m68hc12:%{!m68hcs12:-relax}}}\"\n-#endif\n-\n-#ifndef LIB_SPEC\n-#define LIB_SPEC       \"\"\n-#endif\n-\n-#ifndef CC1_SPEC\n-#define CC1_SPEC       \"\"\n-#endif\n-\n-#ifndef CPP_SPEC\n-#define CPP_SPEC  \\\n-\"%{mshort:-D__HAVE_SHORT_INT__ -D__INT__=16}\\\n- %{!mshort:-D__INT__=32}\\\n- %{m68hc12:-Dmc6812 -DMC6812 -Dmc68hc12}\\\n- %{m68hcs12:-Dmc6812 -DMC6812 -Dmc68hcs12}\\\n- %{!m68hc12:%{!m68hcs12:-Dmc6811 -DMC6811 -Dmc68hc11}}\\\n- %{fshort-double:-D__HAVE_SHORT_DOUBLE__}\\\n- %{mlong-calls:-D__USE_RTC__}\"\n-#endif\n-\n-#undef STARTFILE_SPEC\n-#define STARTFILE_SPEC \"crt1%O%s\"\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-#define TARGET_CPU_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      builtin_define_std (\"mc68hc1x\");\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* As an embedded target, we have no libc.  */\n-#ifndef inhibit_libc\n-#  define inhibit_libc\n-#endif\n-\n-/* Forward type declaration for prototypes definitions.\n-   rtx_ptr is equivalent to rtx. Can't use the same name.  */\n-struct rtx_def;\n-typedef struct rtx_def *rtx_ptr;\n-\n-union tree_node;\n-typedef union tree_node *tree_ptr;\n-\n-/* We can't declare enum machine_mode forward nor include 'machmode.h' here.\n-   Prototypes defined here will use an int instead. It's better than no\n-   prototype at all.  */\n-typedef int enum_machine_mode;\n-\n-/*****************************************************************************\n-**\n-** Run-time Target Specification\n-**\n-*****************************************************************************/\n-\n-/* Run-time compilation parameters selecting different hardware subsets.  */\n-\n-extern short *reg_renumber;\t/* def in local_alloc.c */\n-\n-#define TARGET_OP_TIME\t\t(optimize && optimize_size == 0)\n-#define TARGET_RELAX            (TARGET_NO_DIRECT_MODE)\n-\n-/* Default target_flags if no switches specified.  */\n-#ifndef TARGET_DEFAULT\n-# define TARGET_DEFAULT\t\t0\n-#endif\n-\n-/* Define this macro as a C expression for the initializer of an\n-   array of string to tell the driver program which options are\n-   defaults for this target and thus do not need to be handled\n-   specially when using `MULTILIB_OPTIONS'.  */\n-#ifndef MULTILIB_DEFAULTS\n-# if TARGET_DEFAULT & MASK_M6811\n-#  define MULTILIB_DEFAULTS { \"m68hc11\" }\n-# else\n-#  define MULTILIB_DEFAULTS { \"m68hc12\" }\n-# endif\n-#endif\n-\n-/* Print subsidiary information on the compiler version in use.  */\n-#define TARGET_VERSION\tfprintf (stderr, \" (MC68HC11/MC68HC12/MC68HCS12)\")\n-\n-\f\n-/* Define cost parameters for a given processor variant.  */\n-struct processor_costs {\n-  const int add;\t\t/* cost of an add instruction */\n-  const int logical;          /* cost of a logical instruction */\n-  const int shift_var;\n-  const int shiftQI_const[8];\n-  const int shiftHI_const[16];\n-  const int multQI;\n-  const int multHI;\n-  const int multSI;\n-  const int divQI;\n-  const int divHI;\n-  const int divSI;\n-};\n-\n-/* Costs for the current processor.  */\n-extern const struct processor_costs *m68hc11_cost;\n-\f\n-\n-/* target machine storage layout */\n-\n-/* Define this if most significant byte of a word is the lowest numbered.  */\n-#define BYTES_BIG_ENDIAN \t1\n-\n-/* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields.  */\n-#define BITS_BIG_ENDIAN         0\n-\n-/* Define this if most significant word of a multiword number is numbered.  */\n-#define WORDS_BIG_ENDIAN \t1\n-\n-/* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD\t\t2\n-\n-/* Definition of size_t.  This is really an unsigned short as the\n-   68hc11 only handles a 64K address space.  */\n-#define SIZE_TYPE               \"short unsigned int\"\n-\n-/* A C expression for a string describing the name of the data type\n-   to use for the result of subtracting two pointers.  The typedef\n-   name `ptrdiff_t' is defined using the contents of the string.\n-   The 68hc11 only has a 64K address space.  */\n-#define PTRDIFF_TYPE            \"short int\"\n-\n-/* Allocation boundary (bits) for storing pointers in memory.  */\n-#define POINTER_BOUNDARY\t8\n-\n-/* Normal alignment required for function parameters on the stack, in bits.\n-   This can't be less than BITS_PER_WORD */\n-#define PARM_BOUNDARY\t\t(BITS_PER_WORD)\n-\n-/* Boundary (bits) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY\t\t8\n-\n-/* Allocation boundary (bits) for the code of a function.  */\n-#define FUNCTION_BOUNDARY\t8\n-\n-#define BIGGEST_ALIGNMENT\t8\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY\t8\n-\n-/* Every structure's size must be a multiple of this.  */\n-#define STRUCTURE_SIZE_BOUNDARY 8\n-\n-/* Define this if instructions will fail to work if given data not\n-   on the nominal alignment.  If instructions will merely go slower\n-   in that case, do not define this macro.  */\n-#define STRICT_ALIGNMENT\t0\n-\n-/* An integer expression for the size in bits of the largest integer\n-   machine mode that should actually be used.  All integer machine modes of\n-   this size or smaller can be used for structures and unions with the\n-   appropriate sizes.  */\n-#define MAX_FIXED_MODE_SIZE\t64\n-\f\n-/* target machine storage layout */\n-\n-/* Size (bits) of the type \"int\" on target machine\n-   (If undefined, default is BITS_PER_WORD).  */\n-#define INT_TYPE_SIZE           (TARGET_SHORT ? 16 : 32)\n-\n-/* Size (bits) of the type \"short\" on target machine */\n-#define SHORT_TYPE_SIZE\t\t16\n-\n-/* Size (bits) of the type \"long\" on target machine */\n-#define LONG_TYPE_SIZE\t\t32\n-\n-/* Size (bits) of the type \"long long\" on target machine */\n-#define LONG_LONG_TYPE_SIZE     64\n-\n-/* A C expression for the size in bits of the type `float' on the\n-   target machine. If you don't define this, the default is one word.\n-   Don't use default: a word is only 16.  */\n-#define FLOAT_TYPE_SIZE         32\n-\n-/* A C expression for the size in bits of the type double on the target\n-   machine. If you don't define this, the default is two words.\n-   Be IEEE compliant.  */\n-#define DOUBLE_TYPE_SIZE        64\n-\n-#define LONG_DOUBLE_TYPE_SIZE   64\n-\n-/* Define this as 1 if `char' should by default be signed; else as 0.  */\n-#define DEFAULT_SIGNED_CHAR\t0\n-\n-/* Define these to avoid dependence on meaning of `int'.\n-   Note that WCHAR_TYPE_SIZE is used in cexp.y,\n-   where TARGET_SHORT is not available.  */\n-#define WCHAR_TYPE              \"short int\"\n-#define WCHAR_TYPE_SIZE         16\n-\f\n-\n-/* Standard register usage.  */\n-\n-#define HARD_REG_SIZE           (UNITS_PER_WORD)\n-\n-/* Assign names to real MC68HC11 registers.\n-   A and B registers are not really used (A+B = D)\n-   X register is first so that GCC allocates X+D for 32-bit integers and\n-   the lowpart of that integer will be D.  Having the lower part in D is\n-   better for 32<->16bit conversions and for many arithmetic operations.  */\n-#define HARD_X_REGNUM\t\t0\n-#define HARD_D_REGNUM\t\t1\n-#define HARD_Y_REGNUM\t\t2\n-#define HARD_SP_REGNUM\t\t3\n-#define HARD_PC_REGNUM\t\t4\n-#define HARD_A_REGNUM\t\t5\n-#define HARD_B_REGNUM\t\t6\n-#define HARD_CCR_REGNUM\t\t7\n-\n-/* The Z register does not really exist in the 68HC11.  This a fake register\n-   for GCC.  It is treated exactly as an index register (X or Y).  It is only\n-   in the A_REGS class, which is the BASE_REG_CLASS for GCC.  Defining this\n-   register helps the reload pass of GCC.  Otherwise, the reload often dies\n-   with register spill failures.\n-\n-   The Z register is replaced by either X or Y during the machine specific\n-   reorg (m68hc11_reorg).  It is saved in the SOFT_Z_REGNUM soft-register\n-   when this is necessary.\n-\n-   It's possible to tell GCC not to use this register with -ffixed-z.  */\n-#define HARD_Z_REGNUM           8\n-\n-/* The frame pointer is a soft-register.  It's treated as such by GCC:\n-   it is not and must not be part of the BASE_REG_CLASS.  */\n-#define DEFAULT_HARD_FP_REGNUM  (9)\n-#define HARD_FP_REGNUM\t\t(9)\n-#define HARD_AP_REGNUM\t\t(HARD_FP_REGNUM)\n-\n-/* Temporary soft-register used in some cases when an operand came\n-   up into a bad register class (D, X, Y, SP) and gcc failed to\n-   recognize this. This register is never allocated by GCC.  */\n-#define SOFT_TMP_REGNUM          10\n-\n-/* The soft-register which is used to save the Z register\n-   (see Z register replacement notes in m68hc11.c).  */\n-#define SOFT_Z_REGNUM            11\n-\n-/* The soft-register which is used to save either X or Y.  */\n-#define SOFT_SAVED_XY_REGNUM     12\n-\n-/* A fake clobber register for 68HC12 patterns.  */\n-#define FAKE_CLOBBER_REGNUM     (13)\n-\n-/* Define 32 soft-registers of 16-bit each.  By default,\n-   only 12 of them are enabled and can be used by GCC.  The\n-   -msoft-reg-count=<n> option allows to control the number of valid\n-   soft-registers. GCC can put 32-bit values in them\n-   by allocating consecutive registers.  The first 3 soft-registers\n-   are never allocated by GCC.  They are used in case the insn template needs\n-   a temporary register, or for the Z register replacement.  */\n-\n-#define MAX_SOFT_REG_COUNT      (32)\n-#define SOFT_REG_FIXED          0, 0, 0, 0, 0, 0, 0, 0, \\\n-\t\t\t\t0, 0, 0, 0, 1, 1, 1, 1, \\\n-\t\t\t\t1, 1, 1, 1, 1, 1, 1, 1, \\\n-\t\t\t\t1, 1, 1, 1, 1, 1, 1, 1\n-#define SOFT_REG_USED           0, 0, 0, 0, 0, 0, 0, 0, \\\n-\t\t\t\t0, 0, 0, 0, 1, 1, 1, 1, \\\n-\t\t\t\t1, 1, 1, 1, 1, 1, 1, 1, \\\n-\t\t\t\t1, 1, 1, 1, 1, 1, 1, 1\n-#define SOFT_REG_ORDER\t\t\\\n-SOFT_REG_FIRST, SOFT_REG_FIRST+1,SOFT_REG_FIRST+2,SOFT_REG_FIRST+3,\\\n-SOFT_REG_FIRST+4, SOFT_REG_FIRST+5,SOFT_REG_FIRST+6,SOFT_REG_FIRST+7,\\\n-SOFT_REG_FIRST+8, SOFT_REG_FIRST+9,SOFT_REG_FIRST+10,SOFT_REG_FIRST+11,\\\n-SOFT_REG_FIRST+12, SOFT_REG_FIRST+13,SOFT_REG_FIRST+14,SOFT_REG_FIRST+15,\\\n-SOFT_REG_FIRST+16, SOFT_REG_FIRST+17,SOFT_REG_FIRST+18,SOFT_REG_FIRST+19,\\\n-SOFT_REG_FIRST+20, SOFT_REG_FIRST+21,SOFT_REG_FIRST+22,SOFT_REG_FIRST+23,\\\n-SOFT_REG_FIRST+24, SOFT_REG_FIRST+25,SOFT_REG_FIRST+26,SOFT_REG_FIRST+27,\\\n-SOFT_REG_FIRST+28, SOFT_REG_FIRST+29,SOFT_REG_FIRST+30,SOFT_REG_FIRST+31\n-\n-#define SOFT_REG_NAMES\t\t\t\t\t\t\t\\\n-\"*_.d1\",  \"*_.d2\",  \"*_.d3\",  \"*_.d4\", \\\n-\"*_.d5\",  \"*_.d6\",  \"*_.d7\",  \"*_.d8\",\t\\\n-\"*_.d9\",  \"*_.d10\", \"*_.d11\", \"*_.d12\", \\\n-\"*_.d13\", \"*_.d14\", \"*_.d15\", \"*_.d16\",\t\\\n-\"*_.d17\", \"*_.d18\", \"*_.d19\", \"*_.d20\", \\\n-\"*_.d21\", \"*_.d22\", \"*_.d23\", \"*_.d24\", \\\n-\"*_.d25\", \"*_.d26\", \"*_.d27\", \"*_.d28\", \\\n-\"*_.d29\", \"*_.d30\", \"*_.d31\", \"*_.d32\"\n-\n-/* First available soft-register for GCC.  */\n-#define SOFT_REG_FIRST          (SOFT_SAVED_XY_REGNUM+2)\n-\n-/* Last available soft-register for GCC.  */\n-#define SOFT_REG_LAST           (SOFT_REG_FIRST+MAX_SOFT_REG_COUNT)\n-#define SOFT_FP_REGNUM\t\t(SOFT_REG_LAST)\n-#define SOFT_AP_REGNUM\t\t(SOFT_FP_REGNUM+1)\n-\n-/* Number of actual hardware registers. The hardware registers are assigned\n-   numbers for the compiler from 0 to just below FIRST_PSEUDO_REGISTER. \n-   All registers that the compiler knows about must be given numbers, even\n-   those that are not normally considered general registers.  */\n-#define FIRST_PSEUDO_REGISTER\t(SOFT_REG_LAST+2)\n-\n-/* 1 for registers that have pervasive standard uses and are not available\n-   for the register allocator.  */\n-#define FIXED_REGISTERS \\\n-  {0, 0, 0, 1, 1, 1, 1, 1,   0, 1,  1,   1,1, 1, SOFT_REG_FIXED, 1, 1}\n-/* X, D, Y, SP,PC,A, B, CCR, Z, FP,ZTMP,ZR,XYR, FK, D1 - D32, SOFT-FP, AP */\n-\n-/* 1 for registers not available across function calls. For our pseudo\n-   registers, all are available.  */\n-#define CALL_USED_REGISTERS \\\n-  {1, 1, 1, 1, 1, 1, 1, 1,   1, 1,  1,   1,1, 1, SOFT_REG_USED, 1, 1}\n-/* X, D, Y, SP,PC,A, B, CCR, Z, FP, ZTMP,ZR,XYR, D1 - 32,     SOFT-FP, AP */\n-\n-\n-/* List the order in which to allocate registers.  Each register must be\n-   listed once, even those in FIXED_REGISTERS.  */\n-#define REG_ALLOC_ORDER\t\t\t\t\t\t\t\\\n-{ HARD_D_REGNUM, HARD_X_REGNUM, HARD_Y_REGNUM,\t\t\t\t\\\n-  SOFT_REG_ORDER, HARD_Z_REGNUM, HARD_PC_REGNUM, HARD_A_REGNUM,\t\t\\\n-  HARD_B_REGNUM, HARD_CCR_REGNUM, HARD_FP_REGNUM, SOFT_FP_REGNUM,\t\\\n-  HARD_SP_REGNUM, SOFT_TMP_REGNUM, SOFT_Z_REGNUM, SOFT_SAVED_XY_REGNUM, \\\n-  SOFT_AP_REGNUM, FAKE_CLOBBER_REGNUM  }\n-\n-/* A C expression for the number of consecutive hard registers,\n-   starting at register number REGNO, required to hold a value of\n-   mode MODE.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE) \\\n-((Q_REGNO_P (REGNO)) ? (GET_MODE_SIZE (MODE)) : \\\n-   ((GET_MODE_SIZE (MODE) + HARD_REG_SIZE - 1) / HARD_REG_SIZE))\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-    - 8-bit values are stored anywhere (except the SP register).\n-    - 16-bit values can be stored in any register whose mode is 16\n-    - 32-bit values can be stored in D, X registers or in a soft register\n-      (except the last one because we need 2 soft registers)\n-    - Values whose size is > 32 bit are not stored in real hard\n-      registers.  They may be stored in soft registers if there are\n-      enough of them.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-     hard_regno_mode_ok (REGNO,MODE)\n-\n-/* Value is 1 if it is a good idea to tie two pseudo registers when one has\n-   mode MODE1 and one has mode MODE2.  If HARD_REGNO_MODE_OK could produce\n-   different values for MODE1 and MODE2, for any hard reg, then this must be\n-   0 for correct output.\n-\n-   All modes are tieable except QImode.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2)                   \\\n-     (((MODE1) == (MODE2))                              \\\n-      || ((MODE1) != QImode && (MODE2) != QImode))\n-\f\n-\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-\n-/* The M68hc11 has so few registers that it's not possible for GCC to\n-   do any register allocation without breaking. We extend the processor\n-   registers by having soft registers. These registers are treated as\n-   hard registers by GCC but they are located in memory and accessed by page0\n-   accesses (IND mode).  */\n-enum reg_class\n-{\n-  NO_REGS,\n-  D_REGS,\t\t\t/* 16-bit data register */\n-  X_REGS,\t\t\t/* 16-bit X register */\n-  Y_REGS,\t\t\t/* 16-bit Y register */\n-  SP_REGS,\t\t\t/* 16-bit stack pointer */\n-  DA_REGS,\t\t\t/* 8-bit A reg.  */\n-  DB_REGS,\t\t\t/* 8-bit B reg.  */\n-  Z_REGS,\t\t\t/* 16-bit fake Z register */\n-  D8_REGS,\t\t\t/* 8-bit A or B reg.  */\n-  Q_REGS,\t\t\t/* 8-bit (byte (QI)) data (A, B or D) */\n-  D_OR_X_REGS,\t\t\t/* D or X register */\n-  D_OR_Y_REGS,\t\t\t/* D or Y register */\n-  D_OR_SP_REGS,\t\t\t/* D or SP register */\n-  X_OR_Y_REGS,\t\t\t/* IX or Y register */\n-  A_REGS,\t\t\t/* 16-bit address register (X, Y, Z) */\n-  X_OR_SP_REGS,\t\t\t/* X or SP register */\n-  Y_OR_SP_REGS,\t\t\t/* Y or SP register */\n-  X_OR_Y_OR_D_REGS,\t\t/* X, Y or D */\n-  A_OR_D_REGS,\t\t\t/* X, Y, Z or D */\n-  A_OR_SP_REGS,\t\t\t/* X, Y, Z or SP */\n-  H_REGS,\t\t\t/* 16-bit hard register (D, X, Y, Z, SP) */\n-  S_REGS,\t\t\t/* 16-bit soft register */\n-  D_OR_S_REGS,\t\t\t/* 16-bit soft register or D register */\n-  X_OR_S_REGS,\t\t\t/* 16-bit soft register or X register */\n-  Y_OR_S_REGS,\t\t\t/* 16-bit soft register or Y register */\n-  Z_OR_S_REGS,\t\t\t/* 16-bit soft register or Z register */\n-  SP_OR_S_REGS,\t\t\t/* 16-bit soft register or SP register */\n-  D_OR_X_OR_S_REGS,\t\t/* 16-bit soft register or D or X register */\n-  D_OR_Y_OR_S_REGS,\t\t/* 16-bit soft register or D or Y register */\n-  D_OR_SP_OR_S_REGS,\t\t/* 16-bit soft register or D or SP register */\n-  A_OR_S_REGS,\t\t\t/* 16-bit soft register or X, Y registers */\n-  D_OR_A_OR_S_REGS,\t\t/* 16-bit soft register or D, X, Y registers */\n-  TMP_REGS,\t\t\t/* 16-bit fake scratch register */\n-  D_OR_A_OR_TMP_REGS,\t\t/* General scratch register */\n-  G_REGS,\t\t\t/* 16-bit general register\n-                                   (H_REGS + soft registers) */\n-  ALL_REGS,\n-  LIM_REG_CLASSES\n-};\n-\n-/* alias GENERAL_REGS to G_REGS.  */\n-#define GENERAL_REGS\tG_REGS\n-\n-#define N_REG_CLASSES\t(int) LIM_REG_CLASSES\n-\n-/* Give names of register classes as strings for dump file.  */\n-#define REG_CLASS_NAMES \\\n-{ \"NO_REGS\",                                    \\\n-      \"D_REGS\",                                 \\\n-      \"X_REGS\",                                 \\\n-      \"Y_REGS\",                                 \\\n-      \"SP_REGS\",                                \\\n-      \"DA_REGS\",                                \\\n-      \"DB_REGS\",                                \\\n-      \"D8_REGS\",                                \\\n-      \"Z_REGS\",                                 \\\n-      \"Q_REGS\",                                 \\\n-      \"D_OR_X_REGS\",                            \\\n-      \"D_OR_Y_REGS\",                            \\\n-      \"D_OR_SP_REGS\",                           \\\n-      \"X_OR_Y_REGS\",                            \\\n-      \"A_REGS\",                                 \\\n-      \"X_OR_SP_REGS\",                           \\\n-      \"Y_OR_SP_REGS\",                           \\\n-      \"X_OR_Y_OR_D_REGS\",                       \\\n-      \"A_OR_D_REGS\",                            \\\n-      \"A_OR_SP_REGS\",                           \\\n-      \"H_REGS\",                                 \\\n-      \"S_REGS\",                                 \\\n-      \"D_OR_S_REGS\",                            \\\n-      \"X_OR_S_REGS\",                            \\\n-      \"Y_OR_S_REGS\",                            \\\n-      \"Z_OR_S_REGS\",                            \\\n-      \"SP_OR_S_REGS\",                           \\\n-      \"D_OR_X_OR_S_REGS\",                       \\\n-      \"D_OR_Y_OR_S_REGS\",                       \\\n-      \"D_OR_SP_OR_S_REGS\",                      \\\n-      \"A_OR_S_REGS\",                            \\\n-      \"D_OR_A_OR_S_REGS\",                       \\\n-      \"TMP_REGS\",\t\t\t\t\\\n-      \"D_OR_A_OR_TMP_REGS\",\t\t\t\\\n-      \"G_REGS\",                                 \\\n-      \"ALL_REGS\" }\n-\n-/* An initializer containing the contents of the register classes,\n-   as integers which are bit masks.  The Nth integer specifies the\n-   contents of class N.  The way the integer MASK is interpreted is\n-   that register R is in the class if `MASK & (1 << R)' is 1.  */\n-\n-/*--------------------------------------------------------------\n-   X\t\t0x00000001\n-   D\t\t0x00000002\n-   Y\t\t0x00000004\n-   SP\t\t0x00000008\n-   PC\t\t0x00000010\n-   A\t\t0x00000020\n-   B\t\t0x00000040\n-   CCR\t\t0x00000080\n-   Z\t\t0x00000100\n-   FRAME        0x00000200\n-   ZTMP\t\t0x00000400\n-   ZREG\t\t0x00000800\n-   XYREG\t0x00001000\n-   FAKE         0x00002000\n-   Di\t\t0xFFFFc000, 0x03FFF\n-   SFRAME       0x00000000, 0x04000\n-   AP           0x00000000, 0x08000\n-\n-   D_OR_X_REGS represents D+X. It is used for 32-bits numbers.\n-   A_REGS      represents a valid base register for indexing. It represents\n-\t       X,Y and the Z register.\n-   S_REGS      represents the soft-registers. This includes the hard frame\n-\t       and soft frame registers.\n---------------------------------------------------------------*/\n-\n-#define REG_CLASS_CONTENTS \\\n-/* NO_REGS */\t\t{{ 0x00000000, 0x00000000 },\t\t\t\\\n-/* D_REGS  */\t\t { 0x00000002, 0x00000000 }, /* D */            \\\n-/* X_REGS  */\t\t { 0x00000001, 0x00000000 }, /* X */            \\\n-/* Y_REGS  */\t\t { 0x00000004, 0x00000000 }, /* Y */            \\\n-/* SP_REGS */\t\t { 0x00000008, 0x00000000 }, /* SP */           \\\n-/* DA_REGS */\t\t { 0x00000020, 0x00000000 }, /* A */            \\\n-/* DB_REGS */\t\t { 0x00000040, 0x00000000 }, /* B */            \\\n-/* Z_REGS  */\t\t { 0x00000100, 0x00000000 }, /* Z */            \\\n-/* D8_REGS */\t\t { 0x00000060, 0x00000000 }, /* A B */          \\\n-/* Q_REGS  */\t\t { 0x00000062, 0x00000000 }, /* A B D */        \\\n-/* D_OR_X_REGS */        { 0x00000003, 0x00000000 }, /* D X */          \\\n-/* D_OR_Y_REGS */        { 0x00000006, 0x00000000 }, /* D Y */          \\\n-/* D_OR_SP_REGS */       { 0x0000000A, 0x00000000 }, /* D SP */         \\\n-/* X_OR_Y_REGS  */\t { 0x00000005, 0x00000000 }, /* X Y */          \\\n-/* A_REGS  */\t\t { 0x00000105, 0x00000000 }, /* X Y Z */        \\\n-/* X_OR_SP_REGS */       { 0x00000009, 0x00000000 }, /* X SP */         \\\n-/* Y_OR_SP_REGS */       { 0x0000000C, 0x00000000 }, /* Y SP */         \\\n-/* X_OR_Y_OR_D_REGS */   { 0x00000007, 0x00000000 }, /* D X Y */        \\\n-/* A_OR_D_REGS  */       { 0x00000107, 0x00000000 }, /* D X Y Z */      \\\n-/* A_OR_SP_REGS */       { 0x0000010D, 0x00000000 }, /* X Y SP */       \\\n-/* H_REGS  */\t\t { 0x0000010F, 0x00000000 }, /* D X Y SP */     \\\n-/* S_REGS  */\t\t { 0xFFFFDE00, 0x00007FFF }, /* _.D,..,FP,Z*  */  \\\n-/* D_OR_S_REGS */\t { 0xFFFFDE02, 0x00007FFF }, /* D _.D */        \\\n-/* X_OR_S_REGS */\t { 0xFFFFDE01, 0x00007FFF }, /* X _.D */        \\\n-/* Y_OR_S_REGS */\t { 0xFFFFDE04, 0x00007FFF }, /* Y _.D */        \\\n-/* Z_OR_S_REGS */\t { 0xFFFFDF00, 0x00007FFF }, /* Z _.D */        \\\n-/* SP_OR_S_REGS */\t { 0xFFFFDE08, 0x00007FFF }, /* SP _.D */\t\\\n-/* D_OR_X_OR_S_REGS */\t { 0xFFFFDE03, 0x00007FFF }, /* D X _.D */      \\\n-/* D_OR_Y_OR_S_REGS */\t { 0xFFFFDE06, 0x00007FFF }, /* D Y _.D */      \\\n-/* D_OR_SP_OR_S_REGS */\t { 0xFFFFDE0A, 0x00007FFF }, /* D SP _.D */     \\\n-/* A_OR_S_REGS */\t { 0xFFFFDF05, 0x00007FFF }, /* X Y _.D */      \\\n-/* D_OR_A_OR_S_REGS */\t { 0xFFFFDF07, 0x00007FFF }, /* D X Y _.D */    \\\n-/* TMP_REGS  */\t         { 0x00002000, 0x00000000 }, /* FAKE */\t\t\\\n-/* D_OR_A_OR_TMP_REGS*/  { 0x00002107, 0x00000000 }, /* D X Y Z Fake */  \\\n-/* G_REGS  */\t\t { 0xFFFFFF1F, 0x00007FFF }, /* ? _.D D X Y */   \\\n-/* ALL_REGS*/\t\t { 0xFFFFFFFF, 0x00007FFF }}\n-\n-\n-/* set up a C expression whose value is a register class containing hard\n-   register REGNO */\n-#define Q_REGNO_P(REGNO)\t((REGNO) == HARD_A_REGNUM \\\n-\t\t\t\t || (REGNO) == HARD_B_REGNUM)\n-#define Q_REG_P(X)              (REG_P (X) && Q_REGNO_P (REGNO (X)))\n-\n-#define D_REGNO_P(REGNO)        ((REGNO) == HARD_D_REGNUM)\n-#define D_REG_P(X)              (REG_P (X) && D_REGNO_P (REGNO (X)))\n-\n-#define DB_REGNO_P(REGNO)       ((REGNO) == HARD_B_REGNUM)\n-#define DB_REG_P(X)             (REG_P (X) && DB_REGNO_P (REGNO (X)))\n-#define DA_REGNO_P(REGNO)       ((REGNO) == HARD_A_REGNUM)\n-#define DA_REG_P(X)             (REG_P (X) && DA_REGNO_P (REGNO (X)))\n-\n-#define X_REGNO_P(REGNO)        ((REGNO) == HARD_X_REGNUM)\n-#define X_REG_P(X)              (REG_P (X) && X_REGNO_P (REGNO (X)))\n-\n-#define Y_REGNO_P(REGNO)        ((REGNO) == HARD_Y_REGNUM)\n-#define Y_REG_P(X)              (REG_P (X) && Y_REGNO_P (REGNO (X)))\n-\n-#define Z_REGNO_P(REGNO)        ((REGNO) == HARD_Z_REGNUM)\n-#define Z_REG_P(X)              (REG_P (X) && Z_REGNO_P (REGNO (X)))\n-\n-#define SP_REGNO_P(REGNO)       ((REGNO) == HARD_SP_REGNUM)\n-#define SP_REG_P(X)             (REG_P (X) && SP_REGNO_P (REGNO (X)))\n-\n-/* Address register.  */\n-#define A_REGNO_P(REGNO)        ((REGNO) == HARD_X_REGNUM \\\n-                                 || (REGNO) == HARD_Y_REGNUM \\\n-                                 || (REGNO) == HARD_Z_REGNUM)\n-#define A_REG_P(X)              (REG_P (X) && A_REGNO_P (REGNO (X)))\n-\n-/* M68hc11 hard registers.  */\n-#define H_REGNO_P(REGNO)        (D_REGNO_P (REGNO) || A_REGNO_P (REGNO) \\\n-\t\t\t\t || SP_REGNO_P (REGNO) || Q_REGNO_P (REGNO))\n-#define H_REG_P(X)              (REG_P (X) && H_REGNO_P (REGNO (X)))\n-\n-#define FAKE_REGNO_P(REGNO)     ((REGNO) == FAKE_CLOBBER_REGNUM)\n-#define FAKE_REG_P(X)           (REG_P (X) && FAKE_REGNO_P (REGNO (X)))\n-\n-/* Soft registers (or register emulation for gcc).  The temporary register\n-   used by insn template must be part of the S_REGS class so that it\n-   matches the 'u' constraint.  */\n-#define S_REGNO_P(REGNO)        ((REGNO) >= SOFT_TMP_REGNUM \\\n-                                 && (REGNO) <= SOFT_REG_LAST \\\n-                                 && (REGNO) != FAKE_CLOBBER_REGNUM)\n-#define S_REG_P(X)              (REG_P (X) && S_REGNO_P (REGNO (X)))\n-\n-#define Z_REGNO_P(REGNO)        ((REGNO) == HARD_Z_REGNUM)\n-#define Z_REG_P(X)              (REG_P (X) && Z_REGNO_P (REGNO (X)))\n-\n-/* General register.  */\n-#define G_REGNO_P(REGNO)        (H_REGNO_P (REGNO) || S_REGNO_P (REGNO) \\\n-                                 || ((REGNO) == HARD_PC_REGNUM) \\\n-\t\t\t\t || ((REGNO) == HARD_FP_REGNUM) \\\n-\t\t\t\t || ((REGNO) == SOFT_FP_REGNUM) \\\n-\t\t\t\t || ((REGNO) == FAKE_CLOBBER_REGNUM) \\\n-\t\t\t\t || ((REGNO) == SOFT_AP_REGNUM))\n-\n-#define G_REG_P(X)              (REG_P (X) && G_REGNO_P (REGNO (X)))\n-\n-#define REGNO_REG_CLASS(REGNO) \\\n-  (D_REGNO_P (REGNO) ? D_REGS : \\\n-   (X_REGNO_P (REGNO) ? X_REGS : \\\n-    (Y_REGNO_P (REGNO) ? Y_REGS : \\\n-     (SP_REGNO_P (REGNO) ? SP_REGS : \\\n-      (Z_REGNO_P (REGNO) ? Z_REGS : \\\n-       (H_REGNO_P (REGNO) ? H_REGS : \\\n-        (FAKE_REGNO_P (REGNO) ? TMP_REGS : \\\n-\t (S_REGNO_P (REGNO) ? S_REGS : \\\n-\t  (DA_REGNO_P (REGNO) ? DA_REGS: \\\n-\t   (DB_REGNO_P (REGNO) ? DB_REGS: \\\n-            (G_REGNO_P (REGNO) ? G_REGS : ALL_REGS)))))))))))\n-\n-\n-/* Get reg_class from a letter in the machine description.  */\n-\n-extern enum reg_class m68hc11_tmp_regs_class;\n-#define REG_CLASS_FROM_LETTER(C) \\\n-   ((C) == 'a' ? DA_REGS : \\\n-    (C) == 'A' ? A_REGS : \\\n-    (C) == 'b' ? DB_REGS : \\\n-    (C) == 'B' ? X_OR_Y_REGS : \\\n-    (C) == 'd' ? D_REGS : \\\n-    (C) == 'D' ? D_OR_X_REGS : \\\n-    (C) == 'q' ? Q_REGS : \\\n-    (C) == 'h' ? H_REGS : \\\n-    (C) == 't' ? TMP_REGS : \\\n-    (C) == 'u' ? S_REGS : \\\n-    (C) == 'v' ? m68hc11_tmp_regs_class : \\\n-    (C) == 'w' ? SP_REGS : \\\n-    (C) == 'x' ? X_REGS : \\\n-    (C) == 'y' ? Y_REGS : \\\n-    (C) == 'z' ? Z_REGS : NO_REGS)\n-\n-#define PREFERRED_RELOAD_CLASS(X,CLASS)\tpreferred_reload_class(X,CLASS)\n-\n-#define TARGET_SMALL_REGISTER_CLASSES_FOR_MODE_P hook_bool_mode_true\n-\n-/* A C expression that is nonzero if hard register number REGNO2 can be\n-   considered for use as a rename register for REGNO1 */\n-\n-#define HARD_REGNO_RENAME_OK(REGNO1,REGNO2) \\\n-  m68hc11_hard_regno_rename_ok ((REGNO1), (REGNO2))\n-\n-/* Return the maximum number of consecutive registers needed to represent\n-   mode MODE in a register of class CLASS.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\\\n-(((CLASS) == DA_REGS || (CLASS) == DB_REGS \\\n-   || (CLASS) == D8_REGS || (CLASS) == Q_REGS) ? GET_MODE_SIZE (MODE) \\\n- : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\n-/* The letters I, J, K, L and M in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.\n-\n-   `K' is for 0.\n-   `L' is for range -65536 to 65536\n-   `M' is for values whose 16-bit low part is 0\n-   'N' is for +1 or -1.\n-   'O' is for 16 (for rotate using swap).\n-   'P' is for range -8 to 2 (used by addhi_sp)\n-\n-   'I', 'J' are not used.  */\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C) \\\n-  ((C) == 'K' ? (VALUE) == 0 : \\\n-   (C) == 'L' ? ((VALUE) >= -65536 && (VALUE) <= 65535) : \\\n-   (C) == 'M' ? ((VALUE) & 0x0ffffL) == 0 : \\\n-   (C) == 'N' ? ((VALUE) == 1 || (VALUE) == -1) : \\\n-   (C) == 'I' ? ((VALUE) >= -2 && (VALUE) <= 2) : \\\n-   (C) == 'O' ? (VALUE) == 16 : \\\n-   (C) == 'P' ? ((VALUE) <= 2 && (VALUE) >= -8) : 0)\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-\n-   `G' is for 0.0.  */\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n-  ((C) == 'G' ? (GET_MODE_CLASS (GET_MODE (VALUE)) == MODE_FLOAT \\\n-\t\t && VALUE == CONST0_RTX (GET_MODE (VALUE))) : 0) \n-\n-/* 'U' represents certain kind of memory indexed operand for 68HC12.\n-   and any memory operand for 68HC11.\n-   'R' represents indexed addressing mode or access to page0 for 68HC11.\n-   For 68HC12, it represents any memory operand.  */\n-#define EXTRA_CONSTRAINT(OP, C)                         \\\n-((C) == 'U' ? m68hc11_small_indexed_indirect_p (OP, GET_MODE (OP)) \\\n- : (C) == 'Q' ? m68hc11_symbolic_p (OP, GET_MODE (OP)) \\\n- : (C) == 'R' ? m68hc11_indirect_p (OP, GET_MODE (OP)) \\\n- : (C) == 'S' ? (memory_operand (OP, GET_MODE (OP)) \\\n-\t\t && non_push_operand (OP, GET_MODE (OP))) : 0)\n-\n-\f\n-/* Stack layout; function entry, exit and calling.  */\n-\n-/* Define this if pushing a word on the stack\n-   makes the stack pointer a smaller address.  */\n-#define STACK_GROWS_DOWNWARD\n-\n-/* Define this to nonzero if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset in the frame.\n-\n-   Define to 0 for 68HC11, the frame pointer is the bottom\n-   of local variables.  */\n-#define FRAME_GROWS_DOWNWARD\t\t0\n-\n-/* Define this if successive arguments to a function occupy decreasing \n-   addresses in the stack.  */\n-/* #define ARGS_GROW_DOWNWARD */\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.  */\n-#define STARTING_FRAME_OFFSET\t\t0\n-\n-/* Offset of first parameter from the argument pointer register value.  */\n-\n-#define FIRST_PARM_OFFSET(FNDECL)\t2\n-\n-/* After the prologue, RA is at 0(AP) in the current frame.  */\n-#define RETURN_ADDR_RTX(COUNT, FRAME)\t\t\t\t\t\\\n-  ((COUNT) == 0\t\t\t\t\t\t\t\t\\\n-   ? gen_rtx_MEM (Pmode, arg_pointer_rtx)                               \\\n-   : 0)\n-\n-/* Before the prologue, the top of the frame is at 2(sp).  */\n-#define INCOMING_FRAME_SP_OFFSET        2\n-\n-/* Define this if functions should assume that stack space has been\n-   allocated for arguments even when their values are passed in\n-   registers.\n-  \n-   The value of this macro is the size, in bytes, of the area reserved for\n-   arguments passed in registers.\n-  \n-   This space can either be allocated by the caller or be a part of the\n-   machine-dependent stack frame: `OUTGOING_REG_PARM_STACK_SPACE'\n-   says which.  */\n-/* #define REG_PARM_STACK_SPACE(FNDECL)\t2 */\n-\n-/* Define this macro if REG_PARM_STACK_SPACE is defined but stack\n-   parameters don't skip the area specified by REG_PARM_STACK_SPACE.\n-   Normally, when a parameter is not passed in registers, it is placed on\n-   the stack beyond the REG_PARM_STACK_SPACE area.  Defining this macro  \n-   suppresses this behavior and causes the parameter to be passed on the\n-   stack in its natural location.  */\n-/* #define STACK_PARMS_IN_REG_PARM_AREA */\n-\n-/* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM\t\tHARD_SP_REGNUM\n-\n-/* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM\t\tSOFT_FP_REGNUM\n-\n-#define HARD_FRAME_POINTER_REGNUM\tHARD_FP_REGNUM\n-\n-/* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM\t\tSOFT_AP_REGNUM\n-\n-/* Register in which static-chain is passed to a function.  */\n-#define STATIC_CHAIN_REGNUM\t        SOFT_Z_REGNUM\n-\n-\f\n-/* Definitions for register eliminations.\n-\n-   This is an array of structures.  Each structure initializes one pair\n-   of eliminable registers.  The \"from\" register number is given first,\n-   followed by \"to\".  Eliminations of the same \"from\" register are listed\n-   in order of preference.\n-\n-   We have two registers that are eliminated on the 6811. The pseudo arg\n-   pointer and pseudo frame pointer registers can always be eliminated;\n-   they are replaced with either the stack or the real frame pointer.  */\n-\n-#define ELIMINABLE_REGS\t\t\t\t\t\\\n-{{ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM},\t\t\\\n- {ARG_POINTER_REGNUM,   HARD_FRAME_POINTER_REGNUM},\t\\\n- {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\t\\\n- {FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM}}\n-\n-/* Define the offset between two registers, one to be eliminated, and the other\n-   its replacement, at the start of a routine.  */\n-\n-#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n-    { OFFSET = m68hc11_initial_elimination_offset (FROM, TO); }\n-\n-\f\n-/* Passing Function Arguments on the Stack.  */\n-\n-/* If we generate an insn to push BYTES bytes, this says how many the\n-   stack pointer really advances by. No rounding or alignment needed\n-   for MC6811.  */\n-#define PUSH_ROUNDING(BYTES)\t(BYTES)\n-\f\n-/* Passing Arguments in Registers.  */\n-\n-/* Define a data type for recording info about an argument list\n-   during the scan of that argument list.  This data type should\n-   hold all necessary information about the function itself\n-   and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.  */\n-\n-typedef struct m68hc11_args\n-{\n-  int words;\n-  int nregs;\n-} CUMULATIVE_ARGS;\n-\n-/* If defined, a C expression which determines whether, and in which direction,\n-   to pad out an argument with extra space.  The value should be of type\n-   `enum direction': either `upward' to pad above the argument,\n-   `downward' to pad below, or `none' to inhibit padding.\n-\n-   Structures are stored left shifted in their argument slot.  */\n-#define FUNCTION_ARG_PADDING(MODE, TYPE) \\\n-  m68hc11_function_arg_padding ((MODE), (TYPE))\n-\n-#undef PAD_VARARGS_DOWN\n-#define PAD_VARARGS_DOWN \\\n-  (m68hc11_function_arg_padding (TYPE_MODE (type), type) == downward)\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS for a call to a\n-   function whose data type is FNTYPE. For a library call, FNTYPE is 0.  */\n-#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n-    (m68hc11_init_cumulative_args (&CUM, FNTYPE, LIBNAME))\n-\n-/* Define the profitability of saving registers around calls.\n-\n-   Disable this because the saving instructions generated by\n-   caller-save need a reload and the way it is implemented,\n-   it forbids all spill registers at that point.  Enabling\n-   caller saving results in spill failure.  */\n-#define CALLER_SAVE_PROFITABLE(REFS,CALLS) 0\n-\n-/* 1 if N is a possible register number for function argument passing.\n-   D is for 16-bit values, X is for 32-bit (X+D).  */\n-#define FUNCTION_ARG_REGNO_P(N)\t\\\n-     (((N) == HARD_D_REGNUM) || ((N) == HARD_X_REGNUM))\n-\n-/* All return values are in the D or X+D registers:\n-    - 8 and 16-bit values are returned in D.\n-      BLKmode are passed in D as pointer.\n-    - 32-bit values are returned in X + D.\n-      The high part is passed in X and the low part in D.\n-      For GCC, the register number must be HARD_X_REGNUM.  */\n-#define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\t\t\t\\\n-     gen_rtx_REG (TYPE_MODE (VALTYPE),\t\t\t\t\t\\\n-              ((TYPE_MODE (VALTYPE) == BLKmode\t\t\t\t\\\n-\t        || GET_MODE_SIZE (TYPE_MODE (VALTYPE)) <= 2)\t\t\\\n-\t\t   ? HARD_D_REGNUM : HARD_X_REGNUM))\n-\n-#define LIBCALL_VALUE(MODE)\t\t\t\t\t\t\\\n-     gen_rtx_REG (MODE,\t\t\t\t\t\t\\\n-              (((MODE) == BLKmode || GET_MODE_SIZE (MODE) <= 2)\t\t\\\n-                   ? HARD_D_REGNUM : HARD_X_REGNUM))\n-\n-/* 1 if N is a possible register number for a function value.  */\n-#define FUNCTION_VALUE_REGNO_P(N) \\\n-     ((N) == HARD_D_REGNUM || (N) == HARD_X_REGNUM)\n-\n-/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n-   the stack pointer does not matter.  The value is tested only in functions\n-   that have frame pointers. No definition is equivalent to always zero.  */\n-#define EXIT_IGNORE_STACK\t0\n-\n-\f\n-/* Generating Code for Profiling.  */\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-#define FUNCTION_PROFILER(FILE, LABELNO)\t\t\\\n-    fprintf (FILE, \"\\tldy\\t.LP%d\\n\\tjsr mcount\\n\", (LABELNO))\n-\n-/* Length in units of the trampoline for entering a nested function.  */\n-#define TRAMPOLINE_SIZE\t\t(TARGET_M6811 ? 11 : 9)\n-\n-\f\n-/* Addressing modes, and classification of registers for them.  */\n-\n-#define ADDR_STRICT       0x01  /* Accept only registers in class A_REGS  */\n-#define ADDR_INCDEC       0x02  /* Post/Pre inc/dec */\n-#define ADDR_INDEXED      0x04  /* D-reg index */\n-#define ADDR_OFFSET       0x08\n-#define ADDR_INDIRECT     0x10  /* Accept (mem (mem ...)) for [n,X] */\n-#define ADDR_CONST        0x20  /* Accept const and symbol_ref  */\n-\n-/* The 68HC12 has all the post/pre increment/decrement modes.  */\n-#define HAVE_POST_INCREMENT (TARGET_M6812 && TARGET_AUTO_INC_DEC)\n-#define HAVE_PRE_INCREMENT  (TARGET_M6812 && TARGET_AUTO_INC_DEC)\n-#define HAVE_POST_DECREMENT (TARGET_M6812 && TARGET_AUTO_INC_DEC)\n-#define HAVE_PRE_DECREMENT  (TARGET_M6812 && TARGET_AUTO_INC_DEC)\n-\n-/* The class value for base registers.  This depends on the target:\n-   A_REGS for 68HC11 and A_OR_SP_REGS for 68HC12.  The class value\n-   is stored at init time.  */\n-extern enum reg_class m68hc11_base_reg_class;\n-#define BASE_REG_CLASS\t\tm68hc11_base_reg_class\n-\n-/* The class value for index registers.  This is NO_REGS for 68HC11.  */\n-\n-extern enum reg_class m68hc11_index_reg_class;\n-#define INDEX_REG_CLASS\t        m68hc11_index_reg_class\n-\n-/* These assume that REGNO is a hard or pseudo reg number. They give nonzero\n-   only if REGNO is a hard reg of the suitable class or a pseudo reg currently\n-   allocated to a suitable hard reg.  Since they use reg_renumber, they are\n-   safe only once reg_renumber has been allocated, which happens in\n-   local-alloc.c.  */\n-\n-\n-extern unsigned char m68hc11_reg_valid_for_base[FIRST_PSEUDO_REGISTER];\n-#define REG_VALID_FOR_BASE_P(REGNO) \\\n-    ((REGNO) < FIRST_PSEUDO_REGISTER \\\n-     && m68hc11_reg_valid_for_base[REGNO])\n-\n-/* Internal macro, return 1 if REGNO is a valid index register.  */\n-extern unsigned char m68hc11_reg_valid_for_index[FIRST_PSEUDO_REGISTER];\n-#define REG_VALID_FOR_INDEX_P(REGNO) \\\n-    ((REGNO) < FIRST_PSEUDO_REGISTER \\\n-     && m68hc11_reg_valid_for_index[REGNO])\n-\n-/* Internal macro, the nonstrict definition for REGNO_OK_FOR_BASE_P.  */\n-#define REGNO_OK_FOR_BASE_NONSTRICT_P(REGNO) \\\n-    ((REGNO) >= FIRST_PSEUDO_REGISTER \\\n-     || REG_VALID_FOR_BASE_P (REGNO) \\\n-     || (REGNO) == FRAME_POINTER_REGNUM \\\n-     || (REGNO) == HARD_FRAME_POINTER_REGNUM \\\n-     || (REGNO) == ARG_POINTER_REGNUM \\\n-     || (reg_renumber && REG_VALID_FOR_BASE_P (reg_renumber[REGNO])))\n-\n-/* Internal macro, the nonstrict definition for REGNO_OK_FOR_INDEX_P.  */\n-#define REGNO_OK_FOR_INDEX_NONSTRICT_P(REGNO) \\\n-    (TARGET_M6812 \\\n-     && ((REGNO) >= FIRST_PSEUDO_REGISTER \\\n-         || REG_VALID_FOR_INDEX_P (REGNO) \\\n-         || (reg_renumber && REG_VALID_FOR_INDEX_P (reg_renumber[REGNO]))))\n-\n-/* Internal macro, the strict definition for REGNO_OK_FOR_BASE_P.  */\n-#define REGNO_OK_FOR_BASE_STRICT_P(REGNO) \\\n-    ((REGNO) < FIRST_PSEUDO_REGISTER ? REG_VALID_FOR_BASE_P (REGNO) \\\n-     : (reg_renumber && REG_VALID_FOR_BASE_P (reg_renumber[REGNO])))\n-\n-/* Internal macro, the strict definition for REGNO_OK_FOR_INDEX_P.  */\n-#define REGNO_OK_FOR_INDEX_STRICT_P(REGNO) \\\n-    (TARGET_M6812 \\\n-     && ((REGNO) < FIRST_PSEUDO_REGISTER ? REG_VALID_FOR_INDEX_P (REGNO) \\\n-         : (reg_renumber && REG_VALID_FOR_INDEX_P (reg_renumber[REGNO]))))\n-\n-#define REGNO_OK_FOR_BASE_P2(REGNO,STRICT) \\\n-    ((STRICT) ? (REGNO_OK_FOR_BASE_STRICT_P (REGNO)) \\\n-              : (REGNO_OK_FOR_BASE_NONSTRICT_P (REGNO)))\n-\n-#define REGNO_OK_FOR_INDEX_P2(REGNO,STRICT) \\\n-    ((STRICT) ? (REGNO_OK_FOR_INDEX_STRICT_P (REGNO)) \\\n-              : (REGNO_OK_FOR_INDEX_NONSTRICT_P (REGNO)))\n-\n-#define REGNO_OK_FOR_BASE_P(REGNO) REGNO_OK_FOR_BASE_STRICT_P (REGNO)\n-#define REGNO_OK_FOR_INDEX_P(REGNO) REGNO_OK_FOR_INDEX_STRICT_P (REGNO)\n-\n-#define REG_OK_FOR_BASE_STRICT_P(X)     REGNO_OK_FOR_BASE_STRICT_P (REGNO (X))\n-#define REG_OK_FOR_BASE_NONSTRICT_P(X)  REGNO_OK_FOR_BASE_NONSTRICT_P (REGNO (X))\n-#define REG_OK_FOR_INDEX_STRICT_P(X)    REGNO_OK_FOR_INDEX_STRICT_P (REGNO (X))\n-#define REG_OK_FOR_INDEX_NONSTRICT_P(X) REGNO_OK_FOR_INDEX_NONSTRICT_P (REGNO (X))\n-\n-/* see PUSH_POP_ADDRESS_P() below for an explanation of this.  */\n-#define IS_STACK_PUSH(operand) \\\n-    ((GET_CODE (operand) == MEM) \\\n-     && (GET_CODE (XEXP (operand, 0)) == PRE_DEC) \\\n-     && (SP_REG_P (XEXP (XEXP (operand, 0), 0))))\n-\n-#define IS_STACK_POP(operand) \\\n-    ((GET_CODE (operand) == MEM) \\\n-     && (GET_CODE (XEXP (operand, 0)) == POST_INC) \\\n-     && (SP_REG_P (XEXP (XEXP (operand, 0), 0))))\n-\n-/* Maximum number of registers that can appear in a valid memory address */\n-#define MAX_REGS_PER_ADDRESS\t2\n-\n-/* TARGET_LEGITIMATE_ADDRESS_P recognizes an RTL expression that is a\n-   valid memory address for an instruction. The MODE argument is the\n-   machine mode for the MEM expression that wants to use this address.  */\n-\n-/*--------------------------------------------------------------\n-   Valid addresses are either direct or indirect (MEM) versions\n-   of the following forms:\n-\tconstant\t\tN\n-\tregister\t\t,X\n-\tindexed\t\t\tN,X\n---------------------------------------------------------------*/\n-\n-/* The range of index that is allowed by indirect addressing.  */\n-\n-#define VALID_MIN_OFFSET m68hc11_min_offset\n-#define VALID_MAX_OFFSET m68hc11_max_offset\n-\n-/* The offset values which are allowed by the n,x and n,y addressing modes.\n-   Take into account the size of the mode because we may have to add\n-   a mode offset to access the lowest part of the data.\n-   (For example, for an SImode, the last valid offset is 252.) */\n-#define VALID_CONSTANT_OFFSET_P(X,MODE)\t\t\\\n-(((GET_CODE (X) == CONST_INT) &&\t\t\t\\\n-  ((INTVAL (X) >= VALID_MIN_OFFSET)\t\t\\\n-     && ((INTVAL (X) <= VALID_MAX_OFFSET\t\t\\\n-\t\t- (HOST_WIDE_INT) (GET_MODE_SIZE (MODE) + 1))))) \\\n-|| (TARGET_M6812 \\\n-    && ((GET_CODE (X) == SYMBOL_REF) \\\n-        || GET_CODE (X) == LABEL_REF \\\n-        || GET_CODE (X) == CONST)))\n-\n-/* This is included to allow stack push/pop operations. Special hacks in the\n-   md and m6811.c files exist to support this.  */\n-#define PUSH_POP_ADDRESS_P(X) \\\n-  (((GET_CODE (X) == PRE_DEC) || (GET_CODE (X) == POST_INC)) \\\n-\t&& SP_REG_P (XEXP (X, 0)))\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx and check its\n-   validity for a certain class.  We have two alternate definitions for each\n-   of them.  The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.  The symbol\n-   REG_OK_STRICT causes the latter definition to be used.\n-  \n-   Most source files want to accept pseudo regs in the hope that they will\n-   get allocated to the class that the insn wants them to be in. Source files\n-   for reload pass need to be strict. After reload, it makes no difference,\n-   since pseudo regs have been eliminated by then.  */\n-\n-#ifndef REG_OK_STRICT\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_NONSTRICT_P(X)\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X)  REG_OK_FOR_INDEX_NONSTRICT_P(X)\n-#else\n-#define REG_OK_FOR_BASE_P(X)   REG_OK_FOR_BASE_STRICT_P(X)\n-#define REG_OK_FOR_INDEX_P(X)  REG_OK_FOR_INDEX_STRICT_P(X)\n-#endif\n-\n-\n-/* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n-\n-#define LEGITIMATE_CONSTANT_P(X)\t1\n-\n-\f\n-/* Tell final.c how to eliminate redundant test instructions.  */\n-\n-#define NOTICE_UPDATE_CC(EXP, INSN) \\\n-\tm68hc11_notice_update_cc ((EXP), (INSN))\n-\n-/* Move costs between classes of registers */\n-#define REGISTER_MOVE_COST(MODE, CLASS1, CLASS2)\t\\\n-    (m68hc11_register_move_cost (MODE, CLASS1, CLASS2))\n-\n-/* Move cost between register and memory.\n-    - Move to a 16-bit register is reasonable,\n-    - Move to a soft register can be expensive.  */\n-#define MEMORY_MOVE_COST(MODE,CLASS,IN)\t\t\\\n-    m68hc11_memory_move_cost ((MODE),(CLASS),(IN))\n-\n-/* A C expression for the cost of a branch instruction.  A value of 1\n-   is the default; other values are interpreted relative to that.\n-\n-   Pretend branches are cheap because GCC generates sub-optimal code\n-   for the default value.  */\n-#define BRANCH_COST(speed_p, predictable_p) 0\n-\n-/* Nonzero if access to memory by bytes is slow and undesirable.  */\n-#define SLOW_BYTE_ACCESS\t0\n-\n-/* It is as good to call a constant function address as to call an address\n-   kept in a register.  */\n-#define NO_FUNCTION_CSE\n-\n-/* Try a machine-dependent way of reloading an illegitimate address\n-   operand.  If we find one, push the reload and jump to WIN.  This\n-   macro is used in only one place: `find_reloads_address' in reload.c.\n-\n-   For M68HC11, we handle large displacements of a base register\n-   by splitting the addend across an addhi3 insn.\n-\n-   For M68HC12, the 64K offset range is available.\n-   */\n-\n-#define LEGITIMIZE_RELOAD_ADDRESS(X,MODE,OPNUM,TYPE,IND_LEVELS,WIN)     \\\n-do {                                                                    \\\n-  /* We must recognize output that we have already generated ourselves.  */ \\\n-  if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-      && GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\t\t\\\n-      && GET_CODE (XEXP (XEXP (X, 0), 0)) == REG\t\t\t\\\n-      && GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\t\t\\\n-      && GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL,           \\\n-                   BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,        \\\n-                   OPNUM, TYPE);                                        \\\n-      goto WIN;                                                         \\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS                                              \\\n-      && GET_CODE (XEXP (X, 0)) == REG                                  \\\n-      && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n-      && !VALID_CONSTANT_OFFSET_P (XEXP (X, 1), MODE))                  \\\n-    {                                                                   \\\n-      HOST_WIDE_INT val = INTVAL (XEXP (X, 1));                         \\\n-      HOST_WIDE_INT low, high;                                          \\\n-      high = val & (~0x0FF);                                            \\\n-      low  = val & 0x00FF;                                              \\\n-      if (low >= 256-15) { high += 16; low -= 16; }                     \\\n-      /* Reload the high part into a base reg; leave the low part       \\\n-         in the mem directly.  */                                       \\\n-                                                                        \\\n-      X = gen_rtx_PLUS (Pmode,\t\t\t\t\t\t\\\n-                        gen_rtx_PLUS (Pmode, XEXP (X, 0),\t\t\\\n-                                      GEN_INT (high)),                  \\\n-                        GEN_INT (low));                                 \\\n-                                                                        \\\n-      push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL,           \\\n-                   BASE_REG_CLASS, GET_MODE (X), VOIDmode, 0, 0,        \\\n-                   OPNUM, TYPE);                                        \\\n-      goto WIN;                                                         \\\n-    }                                                                   \\\n-} while (0)\n-\n-\f\n-/* Defining the Output Assembler Language.  */\n-\n-/* A default list of other sections which we might be \"in\" at any given\n-   time.  For targets that use additional sections (e.g. .tdesc) you\n-   should override this definition in the target-specific file which\n-   includes this file.  */\n-\n-/* Output before read-only data.  */\n-#define TEXT_SECTION_ASM_OP\t(\"\\t.sect\\t.text\")\n-\n-/* Output before writable data.  */\n-#define DATA_SECTION_ASM_OP\t(\"\\t.sect\\t.data\")\n-\n-/* Output before uninitialized data.  */\n-#define BSS_SECTION_ASM_OP \t(\"\\t.sect\\t.bss\")\n-\n-/* Define the pseudo-ops used to switch to the .ctors and .dtors sections.\n-\n-   Same as config/elfos.h but don't mark these section SHF_WRITE since\n-   there is no shared library problem.  */\n-#undef CTORS_SECTION_ASM_OP\n-#define CTORS_SECTION_ASM_OP\t\"\\t.section\\t.ctors,\\\"a\\\"\"\n-\n-#undef DTORS_SECTION_ASM_OP\n-#define DTORS_SECTION_ASM_OP\t\"\\t.section\\t.dtors,\\\"a\\\"\"\n-\n-#define TARGET_ASM_CONSTRUCTOR  m68hc11_asm_out_constructor\n-#define TARGET_ASM_DESTRUCTOR   m68hc11_asm_out_destructor\n-\n-/* Comment character */\n-#define ASM_COMMENT_START\t\";\"\n-\n-/* Output to assembler file text saying following lines\n-   may contain character constants, extra white space, comments, etc.  */\n-#define ASM_APP_ON \t\t\"; Begin inline assembler code\\n#APP\\n\"\n-\n-/* Output to assembler file text saying following lines\n-   no longer contain unusual constructs.  */\n-#define ASM_APP_OFF \t\t\"; End of inline assembler code\\n#NO_APP\\n\"\n-\n-/* Write the extra assembler code needed to declare a function properly.\n-   Some svr4 assemblers need to also have something extra said about the\n-   function's return value.  We allow for that here.\n-\n-   For 68HC12 we mark functions that return with 'rtc'.  The linker\n-   will ensure that a 'call' is really made (instead of 'jsr').\n-   The debugger needs this information to correctly compute the stack frame.\n-\n-   For 68HC11/68HC12 we also mark interrupt handlers for gdb to\n-   compute the correct stack frame.  */\n-\n-#undef ASM_DECLARE_FUNCTION_NAME\n-#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"%s\", TYPE_ASM_OP);\t\t\\\n-      assemble_name (FILE, NAME);\t\t\t\\\n-      putc (',', FILE);\t\t\t\t\t\\\n-      fprintf (FILE, TYPE_OPERAND_FMT, \"function\");\t\\\n-      putc ('\\n', FILE);\t\t\t\t\\\n-      \t\t\t\t\t\t\t\\\n-      if (current_function_far)                         \\\n-        {\t\t\t\t\t\t\\\n-          fprintf (FILE, \"\\t.far\\t\");\t\t\t\\\n-\t  assemble_name (FILE, NAME);\t\t\t\\\n-\t  putc ('\\n', FILE);\t\t\t\t\\\n-\t}\t\t\t\t\t\t\\\n-      else if (current_function_interrupt\t\t\\\n-\t       || current_function_trap)\t\t\\\n-        {\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"\\t.interrupt\\t\");\t\t\\\n-\t  assemble_name (FILE, NAME);\t\t\t\\\n-\t  putc ('\\n', FILE);\t\t\t\t\\\n-\t}\t\t\t\t\t\t\\\n-      ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\\\n-      ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Output #ident as a .ident.  */\n-\n-/* output external reference */\n-#undef ASM_OUTPUT_EXTERNAL\n-#define ASM_OUTPUT_EXTERNAL(FILE,DECL,NAME) \\\n-  {fputs (\"\\t; extern\\t\", FILE); \\\n-  assemble_name (FILE, NAME); \\\n-  fputs (\"\\n\", FILE);}\n-\n-/* How to refer to registers in assembler output.  This sequence is indexed\n-   by compiler's hard-register-number (see above).  */\n-#define REGISTER_NAMES\t\t\t\t\t\t\\\n-{ \"x\", \"d\", \"y\", \"sp\", \"pc\", \"a\", \"b\", \"ccr\", \"z\",\t\t\\\n-  \"*_.frame\", \"*_.tmp\", \"*_.z\", \"*_.xy\", \"*fake clobber\",\t\\\n-  SOFT_REG_NAMES, \"*sframe\", \"*ap\"}\n-\n-/* This is how to output an insn to push/pop a register on the stack.\n-   It need not be very fast code.  \n-\n-   Don't define because we don't know how to handle that with\n-   the STATIC_CHAIN_REGNUM (soft register).  Saving the static\n-   chain must be made inside FUNCTION_PROFILER.  */\n-\n-#undef ASM_OUTPUT_REG_PUSH\n-#undef ASM_OUTPUT_REG_POP\n-\n-/* This is how to output an element of a case-vector that is relative.  */\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n-  fprintf (FILE, \"\\t%s\\tL%d-L%d\\n\", integer_asm_op (2, TRUE), VALUE, REL)\n-\n-/* This is how to output an element of a case-vector that is absolute.  */\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\\n-  fprintf (FILE, \"\\t%s\\t.L%d\\n\", integer_asm_op (2, TRUE), VALUE)\n-\n-/* This is how to output an assembler line that says to advance the\n-   location counter to a multiple of 2**LOG bytes.  */\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\t\t\\\n-  do {                                                  \\\n-      if ((LOG) > 1)                                    \\\n-          fprintf ((FILE), \"%s\\n\", ALIGN_ASM_OP); \\\n-  } while (0)\n-\n-\f\n-/* Assembler Commands for Exception Regions.  */\n-\n-/* Default values provided by GCC should be ok. Assuming that DWARF-2\n-   frame unwind info is ok for this platform.  */\n-\n-#undef PREFERRED_DEBUGGING_TYPE\n-#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n-\n-/* For the support of memory banks we need addresses that indicate\n-   the page number.  */\n-#define DWARF2_ADDR_SIZE 4\n-\n-/* SCz 2003-07-08: Don't use as dwarf2 .file/.loc directives because\n-   the linker is doing relaxation and it does not adjust the debug_line\n-   sections when it shrinks the code.  This results in invalid addresses\n-   when debugging.  This does not bless too much the HC11/HC12 as most\n-   applications are embedded and small, hence a reasonable debug info.\n-   This problem is known for binutils 2.13, 2.14 and mainline.  */\n-#undef HAVE_AS_DWARF2_DEBUG_LINE\n-\n-/* The prefix for local labels.  You should be able to define this as\n-   an empty string, or any arbitrary string (such as \".\", \".L%\", etc)\n-   without having to make any other changes to account for the specific\n-   definition.  Note it is a string literal, not interpreted by printf\n-   and friends.  */\n-#define LOCAL_LABEL_PREFIX \".\"\n-\n-/* The prefix for immediate operands.  */\n-#define IMMEDIATE_PREFIX \"#\"\n-#define GLOBAL_ASM_OP   \"\\t.globl\\t\"\n-\n-\f\n-/* Miscellaneous Parameters.  */\n-\n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE\tPmode\n-\n-/* This flag, if defined, says the same insns that convert to a signed fixnum\n-   also convert validly to an unsigned one.  */\n-#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n-\n-/* Max number of bytes we can move from memory to memory in one\n-   reasonably fast instruction.  */\n-#define MOVE_MAX \t\t2\n-\n-/* MOVE_RATIO is the number of move instructions that is better than a\n-   block move.  Make this small on 6811, since the code size grows very\n-   large with each move.  */\n-#define MOVE_RATIO(speed)\t3\n-\n-/* Define if shifts truncate the shift count which implies one can omit\n-   a sign-extension or zero-extension of a shift count.  */\n-#define SHIFT_COUNT_TRUNCATED\t1\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)\t1\n-\n-/* Specify the machine mode that pointers have. After generation of rtl, the\n-   compiler makes no further distinction between pointers and any other\n-   objects of this machine mode.  */\n-#define Pmode\t\t\tHImode\n-\n-/* A function address in a call instruction is a byte address (for indexing\n-   purposes) so give the MEM rtx a byte's mode.  */\n-#define FUNCTION_MODE\t\tQImode\n-\n-extern int debug_m6811;\n-extern int z_replacement_completed;\n-extern int current_function_interrupt;\n-extern int current_function_trap;\n-extern int current_function_far;\n-\n-extern GTY(()) rtx m68hc11_soft_tmp_reg;\n-extern GTY(()) rtx ix_reg;\n-extern GTY(()) rtx iy_reg;\n-extern GTY(()) rtx d_reg;"}, {"sha": "f4ff3ebbb4c5783cfea8e5b708d0878a8d831e6c", "filename": "gcc/config/m68hc11/m68hc11.md", "status": "removed", "additions": 0, "deletions": 7579, "changes": 7579, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.md?ref=999a7d80b587700fc74639d0da5849c4f2eb31db"}, {"sha": "f0f29f2a7a1c0ebe678ad763ed1484397d485424", "filename": "gcc/config/m68hc11/m68hc11.opt", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc11.opt?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,94 +0,0 @@\n-; Options for the Motorola 68HC11 and 68HC12 port of the compiler.\n-\n-; Copyright (C) 2005, 2007 Free Software Foundation, Inc.\n-;\n-; This file is part of GCC.\n-;\n-; GCC is free software; you can redistribute it and/or modify it under\n-; the terms of the GNU General Public License as published by the Free\n-; Software Foundation; either version 3, or (at your option) any later\n-; version.\n-;\n-; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-; for more details.\n-;\n-; You should have received a copy of the GNU General Public License\n-; along with GCC; see the file COPYING3.  If not see\n-; <http://www.gnu.org/licenses/>.\n-\n-m6811\n-Target RejectNegative InverseMask(M6812, M6811)\n-Compile for a 68HC11\n-\n-m6812\n-Target RejectNegative Mask(M6812)\n-Compile for a 68HC12\n-\n-m68hc11\n-Target RejectNegative InverseMask(M6812)\n-Compile for a 68HC11\n-\n-m68hc12\n-Target RejectNegative Mask(M6812) MaskExists\n-Compile for a 68HC12\n-\n-; At the moment, there is no difference between the code generated\n-; for -m68hc12 and -m68hcs12.\n-m68hcs12\n-Target RejectNegative Mask(M6812) MaskExists\n-Compile for a 68HCS12\n-\n-m68s12\n-Target RejectNegative Mask(M6812) MaskExists\n-Compile for a 68HCS12\n-\n-mauto-incdec\n-Target RejectNegative Report Mask(AUTO_INC_DEC)\n-Auto pre/post decrement increment allowed\n-\n-minmax\n-Target RejectNegative Report Mask(MIN_MAX)\n-Min/max instructions allowed\n-\n-mlong-calls\n-Target RejectNegative Report Mask(LONG_CALLS)\n-Use call and rtc for function calls and returns\n-\n-mnoauto-incdec\n-Target RejectNegative Report InverseMask(AUTO_INC_DEC)\n-Auto pre/post decrement increment not allowed\n-\n-mnolong-calls\n-Target RejectNegative Report InverseMask(LONG_CALLS)\n-Use jsr and rts for function calls and returns\n-\n-mnominmax\n-Target RejectNegative Report InverseMask(MIN_MAX)\n-Min/max instructions not allowed\n-\n-mnorelax\n-Target RejectNegative Report InverseMask(NO_DIRECT_MODE)\n-Use direct addressing mode for soft registers\n-\n-mnoshort\n-Target RejectNegative Report InverseMask(SHORT)\n-Compile with 32-bit integer mode\n-\n-; Currently ignored.\n-mreg-alloc=\n-Target RejectNegative Joined\n-Specify the register allocation order\n-\n-mrelax\n-Target RejectNegative Report Mask(NO_DIRECT_MODE)\n-Do not use direct addressing mode for soft registers\n-\n-mshort\n-Target RejectNegative Report Mask(SHORT)\n-Compile with 16-bit integer mode\n-\n-msoft-reg-count=\n-Target RejectNegative Joined UInteger Var(m68hc11_soft_reg_count) Init(-1)\n-Indicate the number of soft registers available"}, {"sha": "22bdc008c5722bd2aec77392a9168d8eaf1c8c2d", "filename": "gcc/config/m68hc11/m68hc12.h", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68hc11%2Fm68hc12.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68hc11%2Fm68hc12.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fm68hc12.h?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,45 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for m68hc12.\n-   Copyright (C) 1999, 2000, 2001, 2003, 2007 Free Software Foundation, Inc.\n-   Contributed by Stephane Carrez (stcarrez@nerim.fr).\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* Compile and assemble for a 68hc12 unless there is a -m68hc11 option.  */\n-#define ASM_SPEC                                                \\\n-\"%{m68hc11:-m68hc11}\"                                           \\\n-\"%{m68hcs12:-m68hcs12}\"                                         \\\n-\"%{!m68hc11:%{!m68hcs12:-m68hc12}}\"\n-#define LIB_SPEC       \"\"\n-#define CC1_SPEC       \"\"\n-\n-/* We need to tell the linker the target elf format.  Just pass an\n-   emulation option.  This can be overridden by -Wl option of gcc.  */\n-#define LINK_SPEC                                               \\\n-\"%{m68hc11:-m m68hc11elf}\"                                      \\\n-\"%{m68hcs12:-m m68hc12elf}\"                                     \\\n-\"%{!m68hc11:%{!m68hcs12:-m m68hc11elf}} %{mrelax:-relax}\"\n-\n-#define CPP_SPEC  \\\n-\"%{mshort:-D__HAVE_SHORT_INT__ -D__INT__=16}\\\n- %{!mshort:-D__INT__=32}\\\n- %{m68hc11:-Dmc6811 -DMC6811 -Dmc68hc11}\\\n- %{!m68hc11:%{!m68hc12:-Dmc6812 -DMC6812 -Dmc68hc12}}\\\n- %{m68hcs12:-Dmc6812 -DMC6812 -Dmc68hcs12}\\\n- %{fshort-double:-D__HAVE_SHORT_DOUBLE__}\"\n-\n-/* Default target_flags if no switches specified.  */\n-#define TARGET_DEFAULT\t\t(MASK_M6812)"}, {"sha": "77a524a0e1e02730fec39e8dee5c4c88d9b1db5f", "filename": "gcc/config/m68hc11/predicates.md", "status": "removed", "additions": 0, "deletions": 228, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68hc11%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68hc11%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Fpredicates.md?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,228 +0,0 @@\n-;; Predicate definitions for Motorola 68HC11 and 68HC12.\n-;; Copyright (C) 2005, 2007, 2009 Free Software Foundation, Inc.\n-;;\n-;; This file is part of GCC.\n-;;\n-;; GCC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 3, or (at your option)\n-;; any later version.\n-;;\n-;; GCC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-;;\n-;; You should have received a copy of the GNU General Public License\n-;; along with GCC; see the file COPYING3.  If not see\n-;; <http://www.gnu.org/licenses/>.\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"stack_register_operand\"\n-  (match_code \"subreg,reg\")\n-{\n-  return SP_REG_P (op);\n-})\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"d_register_operand\"\n-  (match_code \"subreg,reg\")\n-{\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return 0;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = XEXP (op, 0);\n-\n-  return GET_CODE (op) == REG\n-    && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t|| REGNO (op) == HARD_D_REGNUM\n-        || (mode == QImode && REGNO (op) == HARD_B_REGNUM));\n-})\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"hard_addr_reg_operand\"\n-  (match_code \"subreg,reg\")\n-{\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return 0;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = XEXP (op, 0);\n-\n-  return GET_CODE (op) == REG\n-    && (REGNO (op) == HARD_X_REGNUM\n-\t|| REGNO (op) == HARD_Y_REGNUM\n-\t|| REGNO (op) == HARD_Z_REGNUM);\n-})\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"hard_reg_operand\"\n-  (match_code \"subreg,reg\")\n-{\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return 0;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = XEXP (op, 0);\n-\n-  return GET_CODE (op) == REG\n-    && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t|| H_REGNO_P (REGNO (op)));\n-})\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"m68hc11_logical_operator\"\n-  (match_code \"and,ior,xor\")\n-{\n-  return GET_CODE (op) == AND || GET_CODE (op) == IOR || GET_CODE (op) == XOR;\n-})\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"m68hc11_arith_operator\"\n-  (match_code \"and,ior,xor,plus,minus,ashift,ashiftrt,lshiftrt,rotate,rotatert\")\n-{\n-  return GET_CODE (op) == AND || GET_CODE (op) == IOR || GET_CODE (op) == XOR\n-    || GET_CODE (op) == PLUS || GET_CODE (op) == MINUS\n-    || GET_CODE (op) == ASHIFT || GET_CODE (op) == ASHIFTRT\n-    || GET_CODE (op) == LSHIFTRT || GET_CODE (op) == ROTATE\n-    || GET_CODE (op) == ROTATERT;\n-})\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"m68hc11_non_shift_operator\"\n-  (match_code \"and,ior,xor,plus,minus\")\n-{\n-  return GET_CODE (op) == AND || GET_CODE (op) == IOR || GET_CODE (op) == XOR\n-    || GET_CODE (op) == PLUS || GET_CODE (op) == MINUS;\n-})\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"m68hc11_unary_operator\"\n-  (match_code \"neg,not,sign_extend,zero_extend\")\n-{\n-  return GET_CODE (op) == NEG || GET_CODE (op) == NOT\n-    || GET_CODE (op) == SIGN_EXTEND || GET_CODE (op) == ZERO_EXTEND;\n-})\n-\n-;; Return true if op is a shift operator.\n-\n-(define_predicate \"m68hc11_shift_operator\"\n-  (match_code \"ashift,ashiftrt,lshiftrt,rotate,rotatert\")\n-{\n-  return GET_CODE (op) == ROTATE || GET_CODE (op) == ROTATERT\n-    || GET_CODE (op) == LSHIFTRT || GET_CODE (op) == ASHIFT\n-    || GET_CODE (op) == ASHIFTRT;\n-})\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"m68hc11_eq_compare_operator\"\n-  (match_code \"eq,ne\")\n-{\n-  return GET_CODE (op) == EQ || GET_CODE (op) == NE;\n-})\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"non_push_operand\"\n-  (match_code \"subreg,reg,mem\")\n-{\n-  if (general_operand (op, mode) == 0)\n-    return 0;\n-\n-  if (push_operand (op, mode) == 1)\n-    return 0;\n-  return 1;\n-})\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"splitable_operand\"\n-  (match_code \"subreg,reg,mem,symbol_ref,label_ref,const_int,const_double\")\n-{\n-  if (general_operand (op, mode) == 0)\n-    return 0;\n-\n-  if (push_operand (op, mode) == 1)\n-    return 0;\n-\n-  /* Reject a (MEM (MEM X)) because the patterns that use non_push_operand\n-     need to split such addresses to access the low and high part but it\n-     is not possible to express a valid address for the low part.  */\n-  if (mode != QImode && GET_CODE (op) == MEM\n-      && GET_CODE (XEXP (op, 0)) == MEM)\n-    return 0;\n-  return 1;\n-})\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"reg_or_some_mem_operand\"\n-  (match_code \"subreg,reg,mem\")\n-{\n-  if (GET_CODE (op) == MEM)\n-    {\n-      rtx op0 = XEXP (op, 0);\n-      int addr_mode;\n-\n-      if (symbolic_memory_operand (op0, mode))\n-\treturn 1;\n-\n-      if (IS_STACK_PUSH (op))\n-\treturn 1;\n-\n-      if (GET_CODE (op) == REG && reload_in_progress\n-          && REGNO (op) >= FIRST_PSEUDO_REGISTER\n-          && reg_equiv_memory_loc[REGNO (op)])\n-         {\n-            op = reg_equiv_memory_loc[REGNO (op)];\n-            op = eliminate_regs (op, VOIDmode, NULL_RTX);\n-         }\n-      if (GET_CODE (op) != MEM)\n-         return 0;\n-\n-      op0 = XEXP (op, 0);\n-      addr_mode = m68hc11_addr_mode | (reload_completed ? ADDR_STRICT : 0);\n-      addr_mode &= ~ADDR_INDIRECT;\n-      return m68hc11_valid_addressing_p (op0, mode, addr_mode);\n-    }\n-\n-  return register_operand (op, mode);\n-})\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"tst_operand\"\n-  (match_code \"subreg,reg,mem\")\n-{\n-  if (GET_CODE (op) == MEM && reload_completed == 0)\n-    {\n-      rtx addr = XEXP (op, 0);\n-      if (m68hc11_auto_inc_p (addr))\n-\treturn 0;\n-    }\n-  return nonimmediate_operand (op, mode);\n-})\n-\n-;; TODO: Add a comment here.\n-\n-(define_predicate \"cmp_operand\"\n-  (match_code \"subreg,reg,mem,symbol_ref,label_ref,const_int,const_double\")\n-{\n-  if (GET_CODE (op) == MEM)\n-    {\n-      rtx addr = XEXP (op, 0);\n-      if (m68hc11_auto_inc_p (addr))\n-\treturn 0;\n-    }\n-  return general_operand (op, mode);\n-})"}, {"sha": "5a8e6ade47698ac866e686db3da8a448a7f9c9c7", "filename": "gcc/config/m68hc11/t-m68hc11", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68hc11%2Ft-m68hc11", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68hc11%2Ft-m68hc11", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68hc11%2Ft-m68hc11?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,96 +0,0 @@\n-# Copyright (C) 2000, 2001, 2002, 2003, 2005,\n-# 2008 Free Software Foundation, Inc.\n-#\n-# This file is part of GCC.\n-#\n-# GCC is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3, or (at your option)\n-# any later version.\n-#\n-# GCC is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with GCC; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-RANLIB_FOR_TARGET = ` \\\n-  if [ -f $(objdir)/../binutils/ranlib ] ; then \\\n-    echo $(objdir)/../binutils/ranlib ; \\\n-  else \\\n-    if [ \"$(host)\" = \"$(target)\" ] ; then \\\n-      echo ranlib; \\\n-    else \\\n-       if [ -f $(bindir)/$(target_noncanonical)-ranlib ] ; then \\\n-\t  echo $(bindir)/$(target_noncanonical)-ranlib ; \\\n-       else \\\n-          t='$(program_transform_cross_name)'; echo ranlib | sed -e $$t ; \\\n-       fi; \\\n-    fi; \\\n-  fi`\n-\n-LIB1ASMSRC = m68hc11/larith.asm\n-LIB1ASMFUNCS = _mulsi3 \\\n-\t_mulqi3 _ashlsi3 _ashrsi3 _lshrsi3 \\\n-\t_divmodhi4 _mulhi3 _mulhi32 \\\n-\t_memcpy _memset _negsi2 _one_cmplsi2 \\\n-\t_regs_min _regs_frame _regs_d1_2 \\\n-\t_regs_d3_4 _regs_d5_6 _regs_d7_8 _regs_d9_16 _regs_d17_32 \\\n-\t_premain __exit _abort _cleanup \\\n-\t_adddi3 _subdi3 _notdi2 _rotlhi3 _rotrhi3 \\\n-\t_ashrhi3 _lshrhi3 _lshlhi3 _ashrqi3 _lshlqi3 _map_data _init_bss \\\n-\t_ctor _dtor _far_tramp _call_far _return_far\n-\n-TARGET_LIBGCC2_CFLAGS = -DUSE_GAS -DIN_GCC -Dinhibit_libc\n-\n-# C implementation of 32-bit div/mod.\n-LIB2FUNCS_EXTRA = $(srcdir)/config/udivmodsi4.c \\\n-\t$(srcdir)/config/divmod.c $(srcdir)/config/udivmod.c\n-\n-# Don't compile with -g1 this reduces the size of some sections (.eh_frame).\n-LIBGCC2_DEBUG_CFLAGS =-g\n-LIBGCC2_CFLAGS = -Os -mrelax $(LIBGCC2_INCLUDES) $(TARGET_LIBGCC2_CFLAGS) $(LIBGCC2_DEBUG_CFLAGS) $(GTHREAD_FLAGS) -DIN_LIBGCC2\n-\n-MULTILIB_OPTIONS  = m68hc11/m68hc12 mshort fshort-double\n-MULTILIB_DIRNAMES =\n-MULTILIB_MATCHES  = m68hc11=m6811 m68hc12=m6812 m68hc12=m68hcs12\n-MULTILIB_EXCEPTIONS = -mnoshort -mno68hc11\n-\n-LIBGCC = stmp-multilib\n-INSTALL_LIBGCC = install-multilib\n-\n-# We want fine grained libraries, so use the new code to build the\n-# floating point emulation libraries.\n-FPBIT = fp-bit.c\n-DPBIT = dp-bit.c\n-\n-dp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define SMALL_MACHINE' >> dp-bit.c\n-\techo '#define CMPtype HItype' >> dp-bit.c\n-\techo '#ifdef __LITTLE_ENDIAN__' >> dp-bit.c\n-\techo '#define FLOAT_BIT_ORDER_MISMATCH' >>dp-bit.c\n-\techo '#endif' \t\t>> dp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define FLOAT' > fp-bit.c\n-\techo '#define CMPtype HItype' >> fp-bit.c\n-\techo '#define SMALL_MACHINE' >> fp-bit.c\n-\techo '#ifdef __LITTLE_ENDIAN__' >> fp-bit.c\n-\techo '#define FLOAT_BIT_ORDER_MISMATCH' >>fp-bit.c\n-\techo '#endif' \t\t>> fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n-\n-CRT0_S = $(srcdir)/config/m68hc11/m68hc11-crt0.S\n-MCRT0_S= $(srcdir)/config/m68hc11/m68hc11-crt0.S\n-\n-CRT0STUFF_T_CFLAGS =\n-\n-# Assemble startup files.\n-$(T)crt1.o: $(CRT0_S) $(GCC_PASSES)\n-\t$(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) -c -o $(T)crt1.o -x assembler-with-cpp $(CRT0_S)\n-\n-EXTRA_MULTILIB_PARTS = crt1.o"}, {"sha": "7ef202efbacac90c391901bdf24d64ef5b2b6b87", "filename": "gcc/config/m68k/uclinux-oldabi.h", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68k%2Fuclinux-oldabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fm68k%2Fuclinux-oldabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fuclinux-oldabi.h?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,70 +0,0 @@\n-/* Definitions of target machine for GCC.  m68k/ColdFire based uClinux system\n-   using ELF objects with special linker post-processing to produce FLAT\n-   executables.\n-\n-   Copyright (C) 2003, 2007 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-/* The old uClinux ABI used 80-byte \"long double\"s for ColdFire too.  */\n-#undef LONG_DOUBLE_TYPE_SIZE\n-#define LONG_DOUBLE_TYPE_SIZE 80\n-#undef LIBGCC2_LONG_DOUBLE_TYPE_SIZE\n-#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE 80\n-\n-/* Undo the definition of STARTFILE_SPEC from m68kelf.h so we'll\n-   pick the default from gcc.c (just link crt0.o from multilib dir).  */\n-#undef\tSTARTFILE_SPEC\n-\n-/* Override the default LIB_SPEC from gcc.c.  We don't currently support\n-   profiling, or libg.a.  */\n-#undef LIB_SPEC\n-#define LIB_SPEC \"\\\n-%{mid-shared-library:-R libc.gdb%s -elf2flt -shared-lib-id 0} -lc \\\n-\"\n-\n-/* we don't want a .eh_frame section.  */\n-#define EH_FRAME_IN_DATA_SECTION\n-\n-/* ??? Quick hack to get constructors working.  Make this look more like a\n-   COFF target, so the existing dejagnu/libgloss support works.  A better\n-   solution would be to make the necessary dejagnu and libgloss changes so\n-   that we can use normal the ELF constructor mechanism.  */\n-#undef INIT_SECTION_ASM_OP\n-#undef FINI_SECTION_ASM_OP\n-#undef ENDFILE_SPEC\n-#define ENDFILE_SPEC \"\"\n- \n-/* Bring in standard linux defines */\n-#undef TARGET_OS_CPP_BUILTINS\n-#define TARGET_OS_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-\tbuiltin_define_std (\"mc68000\");\t\t\\\n-\tbuiltin_define (\"__uClinux__\");\t\t\\\n-\tbuiltin_define_std (\"linux\");\t\t\\\n-\tbuiltin_define_std (\"unix\");\t\t\\\n-\tbuiltin_define (\"__gnu_linux__\");\t\\\n-\tbuiltin_assert (\"system=linux\");\t\\\n-\tbuiltin_assert (\"system=unix\");\t\t\\\n-\tbuiltin_assert (\"system=posix\");\t\\\n-\tif (TARGET_ID_SHARED_LIBRARY)\t\t\\\n-\t  builtin_define (\"__ID_SHARED_LIBRARY__\"); \\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-"}, {"sha": "ccd34e9c70de2bb71b16769232a06361984b7a20", "filename": "gcc/config/mcore/mcore-pe.h", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fmcore%2Fmcore-pe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fmcore%2Fmcore-pe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Fmcore-pe.h?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,102 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for MCore using COFF/PE.\n-   Copyright (C) 1994, 1999, 2000, 2002, 2003, 2004, 2007\n-   Free Software Foundation, Inc.\n-   Contributed by Michael Tiemann (tiemann@cygnus.com).\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* Run-time Target Specification.  */\n-#define TARGET_VERSION fputs (\" (MCORE/pe)\", stderr)\n-\n-#define TARGET_OS_CPP_BUILTINS()\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      builtin_define (\"__pe__\");\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* The MCore ABI says that bitfields are unsigned by default.  */\n-/* The EPOC C++ environment does not support exceptions.  */\n-#undef CC1_SPEC\n-#define CC1_SPEC \"-funsigned-bitfields %{!DIN_GCC:-fno-rtti} %{!DIN_GCC:-fno-exceptions}\"\n-\n-#undef  SDB_DEBUGGING_INFO\n-#define DBX_DEBUGGING_INFO 1\n-\n-/* Computed in toplev.c.  */\n-#undef  PREFERRED_DEBUGGING_TYPE\n-\n-#define READONLY_DATA_SECTION_ASM_OP\t\"\\t.section .rdata\"\n-\n-#define MCORE_EXPORT_NAME(STREAM, NAME)\t\t\t\\\n-  do\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      fprintf (STREAM, \"\\t.section .drectve\\n\");\t\\\n-      fprintf (STREAM, \"\\t.ascii \\\" -export:%s\\\"\\n\",\t\\\n-\t       (* targetm.strip_name_encoding) (NAME));\t\\\n-      in_section = NULL;\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  while (0);\n-\n-/* Output the label for an initialized variable.  */\n-#undef  ASM_DECLARE_OBJECT_NAME\n-#define ASM_DECLARE_OBJECT_NAME(STREAM, NAME, DECL)\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (mcore_dllexport_name_p (NAME))\t\t\t\\\n-        {\t\t\t\t\t\t\t\\\n-\t  section *save_section = in_section;\t\t\t\\\n-\t  MCORE_EXPORT_NAME (STREAM, NAME);\t\t\t\\\n-\t  switch_to_section (save_section);\t\t\t\\\n-        }\t\t\t\t\t\t\t\\\n-      ASM_OUTPUT_LABEL ((STREAM), (NAME));\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Output a function label definition.  */\n-#define ASM_DECLARE_FUNCTION_NAME(STREAM, NAME, DECL)\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (mcore_dllexport_name_p (NAME))\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-          MCORE_EXPORT_NAME (STREAM, NAME);\t\t\t\\\n-\t  switch_to_section (function_section (DECL));\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-      ASM_OUTPUT_LABEL ((STREAM), (NAME));\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0);\n-\n-#define TARGET_ASM_FILE_START_FILE_DIRECTIVE true\n-\n-#define DBX_LINES_FUNCTION_RELATIVE 1\n-\n-#define STARTFILE_SPEC \"crt0.o%s\"\n-#define ENDFILE_SPEC  \"%{!mno-lsim:-lsim}\"\n-\n-/* __CTOR_LIST__ and __DTOR_LIST__ must be defined by the linker script.  */\n-#define CTOR_LISTS_DEFINED_EXTERNALLY\n-\n-#undef DO_GLOBAL_CTORS_BODY\n-#undef DO_GLOBAL_DTORS_BODY\n-#undef INIT_SECTION_ASM_OP\n-#undef DTORS_SECTION_ASM_OP\n-\n-#define SUPPORTS_ONE_ONLY 1\n-\n-/* Switch into a generic section.  */\n-#undef TARGET_ASM_NAMED_SECTION\n-#define TARGET_ASM_NAMED_SECTION  default_pe_asm_named_section"}, {"sha": "37ad3b6f947e32b69b028c088cbbeb4ae3dfee25", "filename": "gcc/config/mcore/t-mcore-pe", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fmcore%2Ft-mcore-pe", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fmcore%2Ft-mcore-pe", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmcore%2Ft-mcore-pe?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,56 +0,0 @@\n-# Copyright (C) 2000, 2001, 2002, 2008 Free Software Foundation, Inc.\n-#\n-# This file is part of GCC.\n-#\n-# GCC is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3, or (at your option)\n-# any later version.\n-#\n-# GCC is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with GCC; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-LIB1ASMSRC    = mcore/lib1.asm\n-LIB1ASMFUNCS  = _divsi3 _udivsi3 _modsi3 _umodsi3\n-\n-# We want fine grained libraries, so use the new code to build the\n-# floating point emulation libraries.\n-FPBIT = fp-bit.c\n-DPBIT = dp-bit.c\n-\n-dp-bit.c: $(srcdir)/config/fp-bit.c $(srcdir)/config/mcore/t-mcore\n-\trm -f dp-bit.c\n-\techo '' > dp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c $(srcdir)/config/mcore/t-mcore\n-\trm -f fp-bit.c\n-\techo '' > fp-bit.c\n-\techo '#define FLOAT' > fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n-\n-# could use -msifilter to be safe from interrupt/jmp interactions and others.\n-TARGET_LIBGCC2_CFLAGS=-O3 -DNO_FLOATLIB_FIXUNSDFSI #-msifilter\n-\n-# We have values for float.h.\n-CROSS_FLOAT_H = $(srcdir)/config/mcore/gfloat.h\n-\n-MULTILIB_OPTIONS     = mbig-endian/mlittle-endian m210/m340\n-MULTILIB_DIRNAMES    = big little m210 m340\n-MULTILIB_MATCHES     = \n-MULTILIB_EXTRA_OPTS  = \n-MULTILIB_EXCEPTIONS  =\n-\n-# EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o\n-LIBGCC               = stmp-multilib\n-INSTALL_LIBGCC       = install-multilib\n-\n-# If EXTRA_MULTILIB_PARTS is not defined above then define EXTRA_PARTS here\n-# EXTRA_PARTS = crtbegin.o crtend.o \n-"}, {"sha": "7306c156e68c5534dc52cb5343749ccbc123f73d", "filename": "gcc/config/netbsd-aout.h", "status": "removed", "additions": 0, "deletions": 196, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fnetbsd-aout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fnetbsd-aout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnetbsd-aout.h?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,196 +0,0 @@\n-/* Common configuration file for NetBSD a.out targets.\n-   Copyright (C) 2002, 2007, 2010 Free Software Foundation, Inc.\n-   Contributed by Wasabi Systems, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* TARGET_OS_CPP_BUILTINS() common to all NetBSD a.out targets.  */\n-#define NETBSD_OS_CPP_BUILTINS_AOUT()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      NETBSD_OS_CPP_BUILTINS_COMMON();\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-\n-/* Provide an ASM_SPEC appropriate for NetBSD.  Currently we only deal\n-   with the options for generating PIC code.  */\n-\n-#undef ASM_SPEC\n-#define ASM_SPEC \"%{fpic|fpie:-k} %{fPIC|fPIE:-k -K}\"\n-\n-#define AS_NEEDS_DASH_FOR_PIPED_INPUT\n-\n-\n-/* Provide a STARTFILE_SPEC appropriate for NetBSD a.out.  Here we\n-   provide support for the special GCC option -static.  */\n-\n-#undef STARTFILE_SPEC\n-#define STARTFILE_SPEC\t\t\t\\\n-  \"%{!shared:\t\t\t\t\\\n-     %{pg:gcrt0%O%s}\t\t\t\\\n-     %{!pg:\t\t\t\t\\\n-       %{p:mcrt0%O%s}\t\t\t\\\n-       %{!p:\t\t\t\t\\\n-\t %{!static:crt0%O%s}\t\t\\\n-\t %{static:scrt0%O%s}}}}\"\n-\n-/* Provide a LINK_SPEC appropriate for NetBSD a.out.  Here we provide\n-   support for the special GCC options -static, -assert, and -nostdlib.  */\n-\n-#undef NETBSD_LINK_SPEC_AOUT\n-#define NETBSD_LINK_SPEC_AOUT\t\t\\\n-  \"%{nostdlib:-nostdlib}\t\t\\\n-   %{!shared:\t\t\t\t\\\n-     %{!nostdlib:\t\t\t\\\n-       %{!r:\t\t\t\t\\\n-\t %{!e*:-e start}}}\t\t\\\n-     -dc -dp\t\t\t\t\\\n-     %{static:-Bstatic}}\t\t\\\n-   %{shared:-Bshareable}\t\t\\\n-   %{R*}\t\t\t\t\\\n-   %{assert*}\"\n-\n-/* Default LINK_SPEC.  */\n-#undef LINK_SPEC\n-#define LINK_SPEC NETBSD_LINK_SPEC_AOUT\n-\n-/* Define the strings used for the .type, .size, and .set directives.\n-   These strings generally do not vary from one system running NetBSD\n-   to another, but if a given system needs to use different pseudo-op\n-   names for these, they may be overridden in the file included after\n-   this one.  */\n-\n-#undef TYPE_ASM_OP\n-#undef SIZE_ASM_OP\n-#undef SET_ASM_OP                \n-#define TYPE_ASM_OP\t\"\\t.type\\t\"\n-#define SIZE_ASM_OP\t\"\\t.size\\t\"\n-#define SET_ASM_OP\t\"\\t.set\\t\"\n-\n-\n-/* This is how we tell the assembler that a symbol is weak.  */\n-\n-#undef ASM_WEAKEN_LABEL\n-#define ASM_WEAKEN_LABEL(FILE,NAME)\t\t\t\t\t\\\n-  do \t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fputs (\"\\t.globl\\t\", FILE); assemble_name (FILE, NAME);\t\t\\\n-      fputc ('\\n', FILE);\t\t\t\t\t\t\\\n-      fputs (\"\\t.weak\\t\", FILE); assemble_name (FILE, NAME);\t\t\\\n-      fputc ('\\n', FILE);\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-\n-/* The following macro defines the format used to output the second\n-   operand of the .type assembler directive.  Different svr4 assemblers\n-   expect various different forms of this operand.  The one given here\n-   is just a default.  You may need to override it in your machine-\n-   specific tm.h file (depending on the particulars of your assembler).  */\n-\n-#undef TYPE_OPERAND_FMT\n-#define TYPE_OPERAND_FMT\t\"@%s\"\n-\n-\n-/* Write the extra assembler code needed to declare a function's result.\n-   Most svr4 assemblers don't require any special declaration of the\n-   result value, but there are exceptions.  */\n-\n-#ifndef ASM_DECLARE_RESULT\n-#define ASM_DECLARE_RESULT(FILE, RESULT)\n-#endif\n-\n-\n-/* These macros generate the special .type and .size directives which\n-   are used to set the corresponding fields of the linker symbol table\n-   entries in an ELF object file under SVR4 (and a.out on NetBSD).\n-   These macros also output the starting labels for the relevant\n-   functions/objects.  */\n-\n-/* Write the extra assembler code needed to declare a function properly.\n-   Some svr4 assemblers need to also have something extra said about the\n-   function's return value.  We allow for that here.  */\n-\n-#undef ASM_DECLARE_FUNCTION_NAME\n-#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, \"function\");\t\t\\\n-      ASM_DECLARE_RESULT (FILE, DECL_RESULT (DECL));\t\t\t\\\n-      ASM_OUTPUT_FUNCTION_LABEL (FILE, NAME, DECL);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-\n-/* Write the extra assembler code needed to declare an object properly.  */\n-\n-#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      HOST_WIDE_INT size;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      ASM_OUTPUT_TYPE_DIRECTIVE (FILE, NAME, \"object\");\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      size_directive_output = 0;\t\t\t\t\\\n-      if (!flag_inhibit_size_directive\t\t\t\t\\\n-\t  && (DECL) && DECL_SIZE (DECL))\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  size_directive_output = 1;\t\t\t\t\\\n-\t  size = int_size_in_bytes (TREE_TYPE (DECL));\t\t\\\n-\t  ASM_OUTPUT_SIZE_DIRECTIVE (FILE, NAME, size);\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Output the size directive for a decl in rest_of_decl_compilation\n-   in the case where we did not do so before the initializer.\n-   Once we find the error_mark_node, we know that the value of\n-   size_directive_output was set\n-   by ASM_DECLARE_OBJECT_NAME when it was run for the same decl.  */\n-\n-#undef ASM_FINISH_DECLARE_OBJECT\n-#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      const char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\t\\\n-      HOST_WIDE_INT size;\t\t\t\t\t\t\\\n-      if (!flag_inhibit_size_directive && DECL_SIZE (DECL)\t\t\\\n-\t  && ! AT_END && TOP_LEVEL\t\t\t\t\t\\\n-\t  && DECL_INITIAL (DECL) == error_mark_node\t\t\t\\\n-\t  && !size_directive_output)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  size_directive_output = 1;\t\t\t\t\t\\\n-\t  size = int_size_in_bytes (TREE_TYPE (DECL));\t\t\t\\\n-\t  ASM_OUTPUT_SIZE_DIRECTIVE (FILE, name, size);\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-\n-/* This is how to declare the size of a function.  */\n-\n-#undef ASM_DECLARE_FUNCTION_SIZE\n-#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (!flag_inhibit_size_directive)\t\t\t\t\t\\\n-\tASM_OUTPUT_MEASURED_SIZE (FILE, FNAME);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  while (0)"}, {"sha": "0f329e53f1025c00140a1326982fa9efe8ed6304", "filename": "gcc/config/rs6000/gnu.h", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Frs6000%2Fgnu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Frs6000%2Fgnu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fgnu.h?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,37 +0,0 @@\n-/* Definitions of target machine for GNU compiler,\n-   for PowerPC machines running GNU.\n-   Copyright (C) 2001, 2003, 2007 Free Software Foundation, Inc.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#undef\tCPP_OS_DEFAULT_SPEC\n-#define CPP_OS_DEFAULT_SPEC \"%(cpp_os_gnu)\"\n-\n-#undef\tSTARTFILE_DEFAULT_SPEC\n-#define STARTFILE_DEFAULT_SPEC \"%(startfile_gnu)\"\n-\n-#undef\tENDFILE_DEFAULT_SPEC\n-#define ENDFILE_DEFAULT_SPEC \"%(endfile_gnu)\"\n-\n-#undef\tLINK_START_DEFAULT_SPEC\n-#define LINK_START_DEFAULT_SPEC \"%(link_start_gnu)\"\n-\n-#undef\tLINK_OS_DEFAULT_SPEC\n-#define LINK_OS_DEFAULT_SPEC \"%(link_os_gnu)\"\n-\n-#undef  TARGET_VERSION\n-#define TARGET_VERSION fprintf (stderr, \" (PowerPC GNU)\");"}, {"sha": "04913f29df4e7fc3d3961b3719dd6564c824d2fc", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -172,10 +172,6 @@ extern int dot_symbols;\n #undef\tASM_SPEC\n #undef\tLINK_OS_LINUX_SPEC\n \n-/* FIXME: This will quite possibly choose the wrong dynamic linker.  */\n-#undef\tLINK_OS_GNU_SPEC\n-#define\tLINK_OS_GNU_SPEC LINK_OS_LINUX_SPEC\n-\n #ifndef\tRS6000_BI_ARCH\n #define\tASM_DEFAULT_SPEC \"-mppc64\"\n #define\tASM_SPEC\t \"%(asm_spec64) %(asm_spec_common)\"\n@@ -199,7 +195,6 @@ extern int dot_symbols;\n     %{mcall-freebsd: -mbig} \\\n     %{mcall-i960-old: -mlittle} \\\n     %{mcall-linux: -mbig} \\\n-    %{mcall-gnu: -mbig} \\\n     %{mcall-netbsd: -mbig} \\\n }}}}\"\n "}, {"sha": "5ba1253fd2c1a2a2992cd9d605301014496a51a8", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 2, "deletions": 44, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -98,8 +98,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n \trs6000_current_abi = ABI_V4;\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n-  else if (!strcmp (rs6000_abi_name, \"gnu\"))\t\t\t\t\\\n-    rs6000_current_abi = ABI_V4;\t\t\t\t\t\\\n   else if (!strcmp (rs6000_abi_name, \"netbsd\"))\t\t\t\t\\\n     rs6000_current_abi = ABI_V4;\t\t\t\t\t\\\n   else if (!strcmp (rs6000_abi_name, \"openbsd\"))\t\t\t\\\n@@ -556,8 +554,7 @@ extern int fixuplabelno;\n   mcall-freebsd |\t\t   \\\n   mcall-netbsd  |\t\t   \\\n   mcall-openbsd |\t\t   \\\n-  mcall-linux   |\t\t   \\\n-  mcall-gnu             :-mbig;    \\\n+  mcall-linux           :-mbig;    \\\n   mcall-i960-old        :-mlittle}\"\n \n #define\tCC1_ENDIAN_BIG_SPEC \"\"\n@@ -583,8 +580,7 @@ extern int fixuplabelno;\n   mcall-freebsd |\t\t\t\t\t  \\\n   mcall-netbsd  |\t\t\t\t\t  \\\n   mcall-openbsd |\t\t\t\t\t  \\\n-  mcall-linux   |\t\t\t\t\t  \\\n-  mcall-gnu             : -mbig %(cc1_endian_big);        \\\n+  mcall-linux           : -mbig %(cc1_endian_big);        \\\n   mcall-i960-old        : -mlittle %(cc1_endian_little);  \\\n                         : %(cc1_endian_default)}          \\\n %{meabi: %{!mcall-*: -mcall-sysv }} \\\n@@ -593,7 +589,6 @@ extern int fixuplabelno;\n     %{mcall-freebsd: -mno-eabi } \\\n     %{mcall-i960-old: -meabi } \\\n     %{mcall-linux: -mno-eabi } \\\n-    %{mcall-gnu: -mno-eabi } \\\n     %{mcall-netbsd: -mno-eabi } \\\n     %{mcall-openbsd: -mno-eabi }}} \\\n %{msdata: -msdata=default} \\\n@@ -609,7 +604,6 @@ extern int fixuplabelno;\n   msim         : %(link_start_sim)         ; \\\n   mcall-freebsd: %(link_start_freebsd)     ; \\\n   mcall-linux  : %(link_start_linux)       ; \\\n-  mcall-gnu    : %(link_start_gnu)         ; \\\n   mcall-netbsd : %(link_start_netbsd)      ; \\\n   mcall-openbsd: %(link_start_openbsd)     ; \\\n                : %(link_start_default)     }\"\n@@ -647,7 +641,6 @@ extern int fixuplabelno;\n   msim         : %(link_os_sim)         ; \\\n   mcall-freebsd: %(link_os_freebsd)     ; \\\n   mcall-linux  : %(link_os_linux)       ; \\\n-  mcall-gnu    : %(link_os_gnu)         ; \\\n   mcall-netbsd : %(link_os_netbsd)      ; \\\n   mcall-openbsd: %(link_os_openbsd)     ; \\\n                : %(link_os_default)     }\"\n@@ -666,7 +659,6 @@ extern int fixuplabelno;\n   msim         : %(cpp_os_sim)         ; \\\n   mcall-freebsd: %(cpp_os_freebsd)     ; \\\n   mcall-linux  : %(cpp_os_linux)       ; \\\n-  mcall-gnu    : %(cpp_os_gnu)         ; \\\n   mcall-netbsd : %(cpp_os_netbsd)      ; \\\n   mcall-openbsd: %(cpp_os_openbsd)     ; \\\n                : %(cpp_os_default)     }\"\n@@ -681,7 +673,6 @@ extern int fixuplabelno;\n   msim         : %(startfile_sim)         ; \\\n   mcall-freebsd: %(startfile_freebsd)     ; \\\n   mcall-linux  : %(startfile_linux)       ; \\\n-  mcall-gnu    : %(startfile_gnu)         ; \\\n   mcall-netbsd : %(startfile_netbsd)      ; \\\n   mcall-openbsd: %(startfile_openbsd)     ; \\\n                : %(startfile_default)     }\"\n@@ -696,7 +687,6 @@ extern int fixuplabelno;\n   msim         : %(lib_sim)         ; \\\n   mcall-freebsd: %(lib_freebsd)     ; \\\n   mcall-linux  : %(lib_linux)       ; \\\n-  mcall-gnu    : %(lib_gnu)         ; \\\n   mcall-netbsd : %(lib_netbsd)      ; \\\n   mcall-openbsd: %(lib_openbsd)     ; \\\n                : %(lib_default)     }\"\n@@ -711,7 +701,6 @@ extern int fixuplabelno;\n   msim         : %(endfile_sim)         ; \\\n   mcall-freebsd: %(endfile_freebsd)     ; \\\n   mcall-linux  : %(endfile_linux)       ; \\\n-  mcall-gnu    : %(endfile_gnu)         ; \\\n   mcall-netbsd : %(endfile_netbsd)      ; \\\n   mcall-openbsd: %(endfile_openbsd)     ; \\\n                : %(crtsavres_default) %(endfile_default)     }\"\n@@ -845,31 +834,6 @@ extern int fixuplabelno;\n     %{std=gnu*:-Dunix -D__unix -Dlinux -D__linux}}}\t\t  \\\n -Asystem=linux -Asystem=unix -Asystem=posix %{pthread:-D_REENTRANT}\"\n \n-/* GNU/Hurd support.  */\n-#define LIB_GNU_SPEC \"%{mnewlib: --start-group -lgnu -lc --end-group } \\\n-%{!mnewlib: %{shared:-lc} %{!shared: %{pthread:-lpthread } \\\n-%{profile:-lc_p} %{!profile:-lc}}}\"\n-\n-#define\tSTARTFILE_GNU_SPEC \"\\\n-%{!shared: %{!static: %{pg:gcrt1.o%s} %{!pg:%{p:gcrt1.o%s} %{!p:crt1.o%s}}}} \\\n-%{static: %{pg:gcrt0.o%s} %{!pg:%{p:gcrt0.o%s} %{!p:crt0.o%s}}} \\\n-%{mnewlib: ecrti.o%s} %{!mnewlib: crti.o%s} \\\n-%{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}\"\n-\n-#define\tENDFILE_GNU_SPEC \"%{!shared:crtend.o%s} %{shared:crtendS.o%s} \\\n-%{mnewlib: ecrtn.o%s} %{!mnewlib: crtn.o%s}\"\n-\n-#define LINK_START_GNU_SPEC \"\"\n-\n-#define LINK_OS_GNU_SPEC \"-m elf32ppclinux %{!shared: %{!static: \\\n-  %{rdynamic:-export-dynamic} \\\n-  -dynamic-linker /lib/ld.so.1}}\"\n-\n-#define CPP_OS_GNU_SPEC \"-D__unix__ -D__gnu_hurd__ -D__GNU__\t\\\n-%{!undef:\t\t\t\t\t                \\\n-  %{!ansi: -Dunix -D__unix}}\t\t\t                \\\n--Asystem=gnu -Asystem=unix -Asystem=posix %{pthread:-D_REENTRANT}\"\n-\n /* NetBSD support.  */\n #define LIB_NETBSD_SPEC \"\\\n -lc\"\n@@ -931,7 +895,6 @@ ncrtn.o%s\"\n   { \"lib_mvme\",\t\t\tLIB_MVME_SPEC },\t\t\t\\\n   { \"lib_sim\",\t\t\tLIB_SIM_SPEC },\t\t\t\t\\\n   { \"lib_freebsd\",\t\tLIB_FREEBSD_SPEC },\t\t\t\\\n-  { \"lib_gnu\",\t\t\tLIB_GNU_SPEC },\t\t\t\t\\\n   { \"lib_linux\",\t\tLIB_LINUX_SPEC },\t\t\t\\\n   { \"lib_netbsd\",\t\tLIB_NETBSD_SPEC },\t\t\t\\\n   { \"lib_openbsd\",\t\tLIB_OPENBSD_SPEC },\t\t\t\\\n@@ -941,7 +904,6 @@ ncrtn.o%s\"\n   { \"startfile_mvme\",\t\tSTARTFILE_MVME_SPEC },\t\t\t\\\n   { \"startfile_sim\",\t\tSTARTFILE_SIM_SPEC },\t\t\t\\\n   { \"startfile_freebsd\",\tSTARTFILE_FREEBSD_SPEC },\t\t\\\n-  { \"startfile_gnu\",\t\tSTARTFILE_GNU_SPEC },\t\t\t\\\n   { \"startfile_linux\",\t\tSTARTFILE_LINUX_SPEC },\t\t\t\\\n   { \"startfile_netbsd\",\t\tSTARTFILE_NETBSD_SPEC },\t\t\\\n   { \"startfile_openbsd\",\tSTARTFILE_OPENBSD_SPEC },\t\t\\\n@@ -951,7 +913,6 @@ ncrtn.o%s\"\n   { \"endfile_mvme\",\t\tENDFILE_MVME_SPEC },\t\t\t\\\n   { \"endfile_sim\",\t\tENDFILE_SIM_SPEC },\t\t\t\\\n   { \"endfile_freebsd\",\t\tENDFILE_FREEBSD_SPEC },\t\t\t\\\n-  { \"endfile_gnu\",\t\tENDFILE_GNU_SPEC },\t\t\t\\\n   { \"endfile_linux\",\t\tENDFILE_LINUX_SPEC },\t\t\t\\\n   { \"endfile_netbsd\",\t\tENDFILE_NETBSD_SPEC },\t\t\t\\\n   { \"endfile_openbsd\",\t\tENDFILE_OPENBSD_SPEC },\t\t\t\\\n@@ -964,7 +925,6 @@ ncrtn.o%s\"\n   { \"link_start_mvme\",\t\tLINK_START_MVME_SPEC },\t\t\t\\\n   { \"link_start_sim\",\t\tLINK_START_SIM_SPEC },\t\t\t\\\n   { \"link_start_freebsd\",\tLINK_START_FREEBSD_SPEC },\t\t\\\n-  { \"link_start_gnu\",\t\tLINK_START_GNU_SPEC },\t\t\t\\\n   { \"link_start_linux\",\t\tLINK_START_LINUX_SPEC },\t\t\\\n   { \"link_start_netbsd\",\tLINK_START_NETBSD_SPEC },\t\t\\\n   { \"link_start_openbsd\",\tLINK_START_OPENBSD_SPEC },\t\t\\\n@@ -976,7 +936,6 @@ ncrtn.o%s\"\n   { \"link_os_sim\",\t\tLINK_OS_SIM_SPEC },\t\t\t\\\n   { \"link_os_freebsd\",\t\tLINK_OS_FREEBSD_SPEC },\t\t\t\\\n   { \"link_os_linux\",\t\tLINK_OS_LINUX_SPEC },\t\t\t\\\n-  { \"link_os_gnu\",\t\tLINK_OS_GNU_SPEC },\t\t\t\\\n   { \"link_os_netbsd\",\t\tLINK_OS_NETBSD_SPEC },\t\t\t\\\n   { \"link_os_openbsd\",\t\tLINK_OS_OPENBSD_SPEC },\t\t\t\\\n   { \"link_os_default\",\t\tLINK_OS_DEFAULT_SPEC },\t\t\t\\\n@@ -989,7 +948,6 @@ ncrtn.o%s\"\n   { \"cpp_os_mvme\",\t\tCPP_OS_MVME_SPEC },\t\t\t\\\n   { \"cpp_os_sim\",\t\tCPP_OS_SIM_SPEC },\t\t\t\\\n   { \"cpp_os_freebsd\",\t\tCPP_OS_FREEBSD_SPEC },\t\t\t\\\n-  { \"cpp_os_gnu\",\t\tCPP_OS_GNU_SPEC },\t\t\t\\\n   { \"cpp_os_linux\",\t\tCPP_OS_LINUX_SPEC },\t\t\t\\\n   { \"cpp_os_netbsd\",\t\tCPP_OS_NETBSD_SPEC },\t\t\t\\\n   { \"cpp_os_openbsd\",\t\tCPP_OS_OPENBSD_SPEC },\t\t\t\\"}, {"sha": "947ec04281fcf62326d7d958e00228b898376c4b", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler for Renesas / SuperH SH.\n    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2003,\n-   2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Steve Chamberlain (sac@cygnus.com).\n    Improved by Jim Wilson (wilson@cygnus.com).\n@@ -170,17 +170,3 @@ extern int sh2a_is_function_vector_call (rtx);\n extern void sh_fix_range (const char *);\n extern bool sh_hard_regno_mode_ok (unsigned int, enum machine_mode);\n #endif /* ! GCC_SH_PROTOS_H */\n-\n-#ifdef SYMBIAN\n-extern const char * sh_symbian_strip_name_encoding    (const char *);\n-extern bool         sh_symbian_is_dllexported_name    (const char *);\n-#ifdef TREE_CODE\n-extern bool         sh_symbian_is_dllexported         (tree);\n-extern int          sh_symbian_import_export_class    (tree, int);\n-extern tree         sh_symbian_handle_dll_attribute   (tree *, tree, tree, int, bool *);\n-#ifdef RTX_CODE\n-extern void         sh_symbian_encode_section_info    (tree, rtx, int);\n-#endif\n-#endif\n-#endif /* SYMBIAN */\n-"}, {"sha": "2e37d2bbcac5807743b4d5caaf9d30b562d7d03e", "filename": "gcc/config/sh/sh-symbian.h", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fsh%2Fsh-symbian.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fsh%2Fsh-symbian.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-symbian.h?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,42 +0,0 @@\n-/* header file for GCC for a Symbian OS targeted SH backend.\n-   Copyright (C) 2004, 2005, 2007, 2009 Free Software Foundation, Inc.\n-   Contributed by RedHat.\n-   Most of this code is stolen from i386/winnt.c.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* A unique character to encode declspec encoded objects.  */\n-#define SH_SYMBIAN_FLAG_CHAR \"$\"\n-\n-/* Unique strings to prefix exported and imported objects.  */\n-#define DLL_IMPORT_PREFIX SH_SYMBIAN_FLAG_CHAR \"i.\"\n-#define DLL_EXPORT_PREFIX SH_SYMBIAN_FLAG_CHAR \"e.\"\n-\n-/* Select the level of debugging information to display.\n-   0 for no debugging.\n-   1 for informative messages about decisions to add attributes\n-   2 for verbose information about what is being done.  */\n-#define SYMBIAN_DEBUG 0\n-/* #define SYMBIAN_DEBUG 1 */\n-/* #define SYMBIAN_DEBUG 2 */\n-\n-/* Functions exported from symbian-base.c.  */\n-extern tree sh_symbian_associated_type (tree);\n-\n-/* Functions exported from symbian-[c|c++].c.  */\n-extern bool sh_symbian_is_dllimported (tree);\n-"}, {"sha": "70bff999fc75e2f267cceda3390433cb672389da", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -324,19 +324,6 @@ static const struct attribute_spec sh_attribute_table[] =\n     sh_handle_resbank_handler_attribute, false },\n   { \"function_vector\",   1, 1, true,  false, false,\n     sh2a_handle_function_vector_handler_attribute, false },\n-#ifdef SYMBIAN\n-  /* Symbian support adds three new attributes:\n-     dllexport - for exporting a function/variable that will live in a dll\n-     dllimport - for importing a function/variable from a dll\n-\n-     Microsoft allows multiple declspecs in one __declspec, separating\n-     them with spaces.  We do NOT support this.  Instead, use __declspec\n-     multiple times.  */\n-  { \"dllimport\",         0, 0, true,  false, false,\n-    sh_symbian_handle_dll_attribute, false },\n-  { \"dllexport\",         0, 0, true,  false, false,\n-    sh_symbian_handle_dll_attribute, false },\n-#endif\n   { NULL,                0, 0, false, false, false, NULL, false }\n };\n \n@@ -592,17 +579,6 @@ static const struct default_options sh_option_optimization_table[] =\n #undef  TARGET_ENCODE_SECTION_INFO\n #define TARGET_ENCODE_SECTION_INFO\tsh_encode_section_info\n \n-#ifdef SYMBIAN\n-\n-#undef  TARGET_ENCODE_SECTION_INFO\n-#define TARGET_ENCODE_SECTION_INFO\tsh_symbian_encode_section_info\n-#undef  TARGET_STRIP_NAME_ENCODING\n-#define TARGET_STRIP_NAME_ENCODING\tsh_symbian_strip_name_encoding\n-#undef  TARGET_CXX_IMPORT_EXPORT_CLASS\n-#define TARGET_CXX_IMPORT_EXPORT_CLASS  sh_symbian_import_export_class\n-\n-#endif /* SYMBIAN */\n-\n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD sh_secondary_reload\n \n@@ -2823,12 +2799,6 @@ sh_file_start (void)\n {\n   default_file_start ();\n \n-#ifdef SYMBIAN\n-  /* Declare the .directive section before it is used.  */\n-  fputs (\"\\t.section .directive, \\\"SM\\\", @progbits, 1\\n\", asm_out_file);\n-  fputs (\"\\t.asciz \\\"#<SYMEDIT>#\\\\n\\\"\\n\", asm_out_file);\n-#endif\n-\n   if (TARGET_ELF)\n     /* We need to show the text section with the proper\n        attributes as in TEXT_SECTION_ASM_OP, before dwarf2out"}, {"sha": "f8e678be3d2401465f5f62c50844b124df73cdfa", "filename": "gcc/config/sh/symbian-base.c", "status": "removed", "additions": 0, "deletions": 244, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fsh%2Fsymbian-base.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fsh%2Fsymbian-base.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsymbian-base.c?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,244 +0,0 @@\n-/* Routines for GCC for a Symbian OS targeted SH backend, shared by\n-   both the C and C++ compilers.\n-   Copyright (C) 2004, 2005, 2007, 2009, 2010 Free Software Foundation, Inc.\n-   Contributed by RedHat.\n-   Most of this code is stolen from i386/winnt.c.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"output.h\"\n-#include \"flags.h\"\n-#include \"tree.h\"\n-#include \"expr.h\"\n-#include \"tm_p.h\"\n-#include \"diagnostic-core.h\"\n-#include \"sh-symbian.h\"\n-\n-/* Return nonzero if SYMBOL is marked as being dllexport'd.  */\n-\n-bool\n-sh_symbian_is_dllexported_name (const char *symbol)\n-{\n-  return strncmp (DLL_EXPORT_PREFIX, symbol,\n-\t\t  strlen (DLL_EXPORT_PREFIX)) == 0;\n-}\n-\n-/* Return nonzero if SYMBOL is marked as being dllimport'd.  */\n-\n-static bool\n-sh_symbian_is_dllimported_name (const char *symbol)\n-{\n-  return strncmp (DLL_IMPORT_PREFIX, symbol,\n-\t\t  strlen (DLL_IMPORT_PREFIX)) == 0;\n-}\n-\n-/* Return nonzero if DECL is a dllexport'd object.  */\n-\n-bool\n-sh_symbian_is_dllexported (tree decl)\n-{\n-  tree exp;\n-\n-  if (   TREE_CODE (decl) != VAR_DECL\n-      && TREE_CODE (decl) != FUNCTION_DECL)\n-    return false;\n-\n-  exp = lookup_attribute (\"dllexport\", DECL_ATTRIBUTES (decl));\n-\n-  /* Class members get the dllexport status of their class.  */\n-  if (exp == NULL)\n-    {\n-      tree class = sh_symbian_associated_type (decl);\n-\n-      if (class)\n-\texp = lookup_attribute (\"dllexport\", TYPE_ATTRIBUTES (class));\n-    }\n-#if SYMBIAN_DEBUG\n-  if (exp)\n-    {\n-      print_node_brief (stderr, \"dllexport:\", decl, 0);\n-      fprintf (stderr, \"\\n\");\n-    }\n-  else\n-#if SYMBIAN_DEBUG < 2\n-    if (TREE_CODE (decl) != FUNCTION_DECL)\n-#endif\n-    {\n-      print_node_brief (stderr, \"no dllexport:\", decl, 0);\n-      fprintf (stderr, \"\\n\");\n-    }\n-#endif\n-  return exp ? true : false;\n-}\n-\n-/* Mark a DECL as being dllimport'd.  */\n-\n-static void\n-sh_symbian_mark_dllimport (tree decl)\n-{\n-  const char *oldname;\n-  char *newname;\n-  tree idp;\n-  rtx rtlname;\n-  rtx newrtl;\n-\n-  rtlname = XEXP (DECL_RTL (decl), 0);\n-  if (MEM_P (rtlname))\n-    rtlname = XEXP (rtlname, 0);\n-  gcc_assert (GET_CODE (rtlname) == SYMBOL_REF);\n-  oldname = XSTR (rtlname, 0);\n-\n-  if (sh_symbian_is_dllexported_name (oldname))\n-    {\n-      error (\"%qE declared as both exported to and imported from a DLL\",\n-             DECL_NAME (decl));\n-    }\n-  else if (sh_symbian_is_dllimported_name (oldname))\n-    {\n-      /* Already done, but do a sanity check to prevent assembler errors.  */\n-      if (!DECL_EXTERNAL (decl) || !TREE_PUBLIC (decl))\n-\terror (\"failure in redeclaration of %q+D: dllimport%'d symbol lacks external linkage\",\n-\t       decl);\n-    }\n-  else\n-    {\n-      newname = (char *) alloca (strlen (DLL_IMPORT_PREFIX) + strlen (oldname) + 1);\n-      sprintf (newname, \"%s%s\", DLL_IMPORT_PREFIX, oldname);\n-\n-      /* We pass newname through get_identifier to ensure it has a unique\n-\t address.  RTL processing can sometimes peek inside the symbol ref\n-\t and compare the string's addresses to see if two symbols are\n-\t identical.  */\n-      idp = get_identifier (newname);\n-      newrtl = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n-      XEXP (DECL_RTL (decl), 0) = newrtl;\n-    }\n-}\n-\n-/* Mark a DECL as being dllexport'd.\n-   Note that we override the previous setting (e.g.: dllimport).  */\n-\n-static void\n-sh_symbian_mark_dllexport (tree decl)\n-{\n-  const char *oldname;\n-  char *newname;\n-  rtx rtlname;\n-  tree idp;\n-\n-  rtlname = XEXP (DECL_RTL (decl), 0);\n-  if (MEM_P (rtlname))\n-    rtlname = XEXP (rtlname, 0);\n-  gcc_assert (GET_CODE (rtlname) == SYMBOL_REF);\n-  oldname = XSTR (rtlname, 0);\n-\n-  if (sh_symbian_is_dllimported_name (oldname))\n-    {\n-     /* Remove DLL_IMPORT_PREFIX.\n-\tNote - we do not issue a warning here.  In Symbian's environment it\n-\tis legitimate for a prototype to be marked as dllimport and the\n-\tcorresponding definition to be marked as dllexport.  The prototypes\n-\tare in headers used everywhere and the definition is in a translation\n-\tunit which has included the header in order to ensure argument\n-\tcorrectness.  */\n-      oldname += strlen (DLL_IMPORT_PREFIX);\n-      DECL_DLLIMPORT_P (decl) = 0;\n-    }\n-  else if (sh_symbian_is_dllexported_name (oldname))\n-    return; /* Already done.  */\n-\n-  newname = (char *) alloca (strlen (DLL_EXPORT_PREFIX) + strlen (oldname) + 1);\n-  sprintf (newname, \"%s%s\", DLL_EXPORT_PREFIX, oldname);\n-\n-  /* We pass newname through get_identifier to ensure it has a unique\n-     address.  RTL processing can sometimes peek inside the symbol ref\n-     and compare the string's addresses to see if two symbols are\n-     identical.  */\n-  idp = get_identifier (newname);\n-\n-  XEXP (DECL_RTL (decl), 0) =\n-    gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n-}\n-\n-void\n-sh_symbian_encode_section_info (tree decl, rtx rtl, int first)\n-{\n-  default_encode_section_info (decl, rtl, first);\n-\n-  /* Mark the decl so we can tell from the rtl whether\n-     the object is dllexport'd or dllimport'd.  */\n-  if (sh_symbian_is_dllexported (decl))\n-    sh_symbian_mark_dllexport (decl);\n-  else if (sh_symbian_is_dllimported (decl))\n-    sh_symbian_mark_dllimport (decl);\n-  /* It might be that DECL has already been marked as dllimport, but a\n-     subsequent definition nullified that.  The attribute is gone but\n-     DECL_RTL still has (DLL_IMPORT_PREFIX) prefixed. We need to remove\n-     that. Ditto for the DECL_DLLIMPORT_P flag.  */\n-  else if (  (TREE_CODE (decl) == FUNCTION_DECL\n-\t   || TREE_CODE (decl) == VAR_DECL)\n-\t   && DECL_RTL (decl) != NULL_RTX\n-\t   && MEM_P (DECL_RTL (decl))\n-\t   && MEM_P (XEXP (DECL_RTL (decl), 0))\n-\t   && GET_CODE (XEXP (XEXP (DECL_RTL (decl), 0), 0)) == SYMBOL_REF\n-\t   && sh_symbian_is_dllimported_name (XSTR (XEXP (XEXP (DECL_RTL (decl), 0), 0), 0)))\n-    {\n-      const char * oldname = XSTR (XEXP (XEXP (DECL_RTL (decl), 0), 0), 0);\n-      /* Remove DLL_IMPORT_PREFIX.  */\n-      tree idp = get_identifier (oldname + strlen (DLL_IMPORT_PREFIX));\n-      rtx newrtl = gen_rtx_SYMBOL_REF (Pmode, IDENTIFIER_POINTER (idp));\n-\n-      warning (0, \"%s %q+D %s after being referenced with dllimport linkage\",\n-\t       TREE_CODE (decl) == VAR_DECL ? \"variable\" : \"function\",\n-\t       decl, (DECL_INITIAL (decl) || !DECL_EXTERNAL (decl))\n-\t       ? \"defined locally\" : \"redeclared without dllimport attribute\");\n-\n-      XEXP (DECL_RTL (decl), 0) = newrtl;\n-\n-      DECL_DLLIMPORT_P (decl) = 0;\n-    }\n-}\n-\n-/* Return the length of a function name prefix\n-    that starts with the character 'c'.  */\n-\n-static int\n-sh_symbian_get_strip_length (int c)\n-{\n-  /* XXX Assumes strlen (DLL_EXPORT_PREFIX) == strlen (DLL_IMPORT_PREFIX).  */\n-  return (c == SH_SYMBIAN_FLAG_CHAR[0]) ? strlen (DLL_EXPORT_PREFIX) : 0;\n-}\n-\n-/* Return a pointer to a function's name with any\n-   and all prefix encodings stripped from it.  */\n-\n-const char *\n-sh_symbian_strip_name_encoding (const char *name)\n-{\n-  int skip;\n-\n-  while ((skip = sh_symbian_get_strip_length (*name)))\n-    name += skip;\n-\n-  return name;\n-}\n-"}, {"sha": "c93922a39110d7084a9f923d74ae1a18bc6f0cb4", "filename": "gcc/config/sh/symbian-c.c", "status": "removed", "additions": 0, "deletions": 181, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fsh%2Fsymbian-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fsh%2Fsymbian-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsymbian-c.c?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,181 +0,0 @@\n-/* Routines for C compiler part of GCC for a Symbian OS targeted SH backend.\n-   Copyright (C) 2004, 2005, 2007, 2009, 2010 Free Software Foundation, Inc.\n-   Contributed by RedHat.\n-   Most of this code is stolen from i386/winnt.c.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"output.h\"\n-#include \"flags.h\"\n-#include \"tree.h\"\n-#include \"expr.h\"\n-#include \"tm_p.h\"\n-#include \"diagnostic-core.h\"\n-#include \"sh-symbian.h\"\n-\n-\f\n-/* Return the type that we should use to determine if DECL is\n-   imported or exported.  */\n-\n-tree\n-sh_symbian_associated_type (tree decl)\n-{\n-  tree t = NULL_TREE;\n-\n-  /* We can just take the DECL_CONTEXT as normal.  */\n-  if (DECL_CONTEXT (decl) && TYPE_P (DECL_CONTEXT (decl)))\n-    t = DECL_CONTEXT (decl);\n-\n-  return t;\n-}\n-\n-/* Return nonzero if DECL is a dllimport'd object.  */\n-\n-bool\n-sh_symbian_is_dllimported (tree decl)\n-{\n-  tree imp;\n-\n-  if (   TREE_CODE (decl) != VAR_DECL\n-      && TREE_CODE (decl) != FUNCTION_DECL)\n-    return false;\n-\n-  imp = lookup_attribute (\"dllimport\", DECL_ATTRIBUTES (decl));\n-  if (imp)\n-    return true;\n-\n-  /* Class members get the dllimport status of their class.  */\n-  imp = sh_symbian_associated_type (decl);\n-  if (! imp)\n-    return false;\n-\n-  imp = lookup_attribute (\"dllimport\", TYPE_ATTRIBUTES (imp));\n-  if (!imp)\n-    return false;\n-\n-  /* Don't mark defined functions as dllimport.  If the definition itself\n-     was marked with dllimport, then sh_symbian_handle_dll_attribute reports\n-     an error. This handles the case when the definition overrides an\n-     earlier declaration.  */\n-  if (TREE_CODE (decl) ==  FUNCTION_DECL\n-      && DECL_INITIAL (decl)\n-      && ! DECL_DECLARED_INLINE_P (decl))\n-    {\n-      warning (OPT_Wattributes, \"function %q+D is defined after prior \"\n-\t       \"declaration as dllimport: attribute ignored\",\n-\t       decl);\n-      return false;\n-    }\n-\n-  /*  Don't allow definitions of static data members in dllimport\n-      class.  Just ignore the attribute for vtable data.  */\n-  else if (TREE_CODE (decl) == VAR_DECL\n-\t   && TREE_STATIC (decl)\n-\t   && TREE_PUBLIC (decl)\n-\t   && !DECL_EXTERNAL (decl))\n-    {\n-      error (\"definition of static data member %q+D of dllimport%'d class\",\n-\t     decl);\n-      return false;\n-    }\n-\n-  return true;\n-}\n-\n-/* Handle a \"dllimport\" or \"dllexport\" attribute;\n-   arguments as in struct attribute_spec.handler.  */\n-\n-tree\n-sh_symbian_handle_dll_attribute (tree *pnode, tree name, tree args,\n-\t\t\t\t int flags, bool *no_add_attrs)\n-{\n-  tree node = *pnode;\n-  const char *attr = IDENTIFIER_POINTER (name);\n-\n-  /* These attributes may apply to structure and union types being\n-     created, but otherwise should pass to the declaration involved.  */\n-  if (!DECL_P (node))\n-    {\n-      if (flags & ((int) ATTR_FLAG_DECL_NEXT\n-\t\t   | (int) ATTR_FLAG_FUNCTION_NEXT\n-\t\t   | (int) ATTR_FLAG_ARRAY_NEXT))\n-\t{\n-\t  warning (OPT_Wattributes, \"%qs attribute ignored\", attr);\n-\t  *no_add_attrs = true;\n-\t  return tree_cons (name, args, NULL_TREE);\n-\t}\n-\n-      if (TREE_CODE (node) != RECORD_TYPE && TREE_CODE (node) != UNION_TYPE)\n-\t{\n-\t  warning (OPT_Wattributes, \"%qs attribute ignored\", attr);\n-\t  *no_add_attrs = true;\n-\t}\n-\n-      return NULL_TREE;\n-    }\n-\n-  /* Report error on dllimport ambiguities\n-     seen now before they cause any damage.  */\n-  else if (is_attribute_p (\"dllimport\", name))\n-    {\n-      if (TREE_CODE (node) == VAR_DECL)\n-\t{\n-\t  if (DECL_INITIAL (node))\n-\t    {\n-\t      error (\"variable %q+D definition is marked dllimport\",\n-\t\t     node);\n-\t      *no_add_attrs = true;\n-\t    }\n-\n-\t  /* `extern' needn't be specified with dllimport.\n-\t     Specify `extern' now and hope for the best.  Sigh.  */\n-\t  DECL_EXTERNAL (node) = 1;\n-\t  /* Also, implicitly give dllimport'd variables declared within\n-\t     a function global scope, unless declared static.  */\n-\t  if (current_function_decl != NULL_TREE && ! TREE_STATIC (node))\n-  \t    TREE_PUBLIC (node) = 1;\n-\t}\n-    }\n-\n-  /*  Report error if symbol is not accessible at global scope.  */\n-  if (!TREE_PUBLIC (node)\n-      && (   TREE_CODE (node) == VAR_DECL\n-\t  || TREE_CODE (node) == FUNCTION_DECL))\n-    {\n-      error (\"external linkage required for symbol %q+D because of %qE attribute\",\n-\t     node, name);\n-      *no_add_attrs = true;\n-    }\n-\n-#if SYMBIAN_DEBUG\n-  print_node_brief (stderr, \"mark node\", node, 0);\n-  fprintf (stderr, \" as %s\\n\", attr);\n-#endif\n-\n-  return NULL_TREE;\n-}\n-\n-int\n-sh_symbian_import_export_class (tree ctype ATTRIBUTE_UNUSED, int import_export)\n-{\n-  return import_export;\n-}"}, {"sha": "c0f8b71f6266c3b5a847605b506eef83d8c0ed8f", "filename": "gcc/config/sh/symbian-cxx.c", "status": "removed", "additions": 0, "deletions": 662, "changes": 662, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fsh%2Fsymbian-cxx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fsh%2Fsymbian-cxx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsymbian-cxx.c?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,662 +0,0 @@\n-/* Routines for C++ support for GCC for a Symbian OS targeted SH backend.\n-   Copyright (C) 2004, 2005, 2007, 2009, 2010 Free Software Foundation, Inc.\n-   Contributed by RedHat.\n-   Most of this code is stolen from i386/winnt.c.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"output.h\"\n-#include \"flags.h\"\n-#include \"tree.h\"\n-#include \"expr.h\"\n-#include \"tm_p.h\"\n-#include \"cp/cp-tree.h\"\t/* We need access to the OVL_... macros.  */\n-#include \"diagnostic-core.h\"\n-#include \"sh-symbian.h\"\n-\n-\f\n-/* Return the type that we should use to determine if DECL is\n-   imported or exported.  */\n-\n-tree\n-sh_symbian_associated_type (tree decl)\n-{\n-  tree t = NULL_TREE;\n-\n-  if (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)\n-  /* Methods now inherit their dllimport/dllexport attributes correctly\n-     so there is no need to check their class.  In fact it is wrong to\n-     check their class since a method can remain unexported from an\n-     exported class.  */\n-    return t;\n-\n-  /* Otherwise we can just take the DECL_CONTEXT as normal.  */\n-  if (DECL_CONTEXT (decl) && TYPE_P (DECL_CONTEXT (decl)))\n-    t = DECL_CONTEXT (decl);\n-\n-  return t;\n-}\n-\n-\f\n-/* Return nonzero if DECL is a dllimport'd object.  */\n-\n-bool\n-sh_symbian_is_dllimported (tree decl)\n-{\n-  tree imp;\n-\n-  if (   TREE_CODE (decl) != VAR_DECL\n-      && TREE_CODE (decl) != FUNCTION_DECL)\n-    return false;\n-\n-  imp = lookup_attribute (\"dllimport\", DECL_ATTRIBUTES (decl));\n-  if (imp)\n-    return true;\n-\n-  /* Class members get the dllimport status of their class.  */\n-  imp = sh_symbian_associated_type (decl);\n-  if (! imp)\n-    return false;\n-\n-  imp = lookup_attribute (\"dllimport\", TYPE_ATTRIBUTES (imp));\n-  if (!imp)\n-    return false;\n-\n-  /* Don't mark defined functions as dllimport.  If the definition itself\n-     was marked with dllimport, then sh_symbian_handle_dll_attribute reports\n-     an error. This handles the case when the definition overrides an\n-     earlier declaration.  */\n-  if (TREE_CODE (decl) ==  FUNCTION_DECL\n-      && DECL_INITIAL (decl)\n-      && ! DECL_DECLARED_INLINE_P (decl))\n-    {\n-      /* Don't warn about artificial methods.  */\n-      if (!DECL_ARTIFICIAL (decl))\n-\twarning (OPT_Wattributes, \"function %q+D is defined after prior \"\n-\t\t \"declaration as dllimport: attribute ignored\",\n-\t\t decl);\n-      return false;\n-    }\n-\n-  /* We ignore the dllimport attribute for inline member functions.\n-     This differs from MSVC behavior which treats it like GNUC\n-     'extern inline' extension.   */\n-  else if (TREE_CODE (decl) == FUNCTION_DECL && DECL_DECLARED_INLINE_P (decl))\n-    {\n-      if (extra_warnings)\n-\twarning (OPT_Wattributes, \"inline function %q+D is declared as \"\n-\t\t \"dllimport: attribute ignored\",\n-\t\t decl);\n-      return false;\n-    }\n-\n-  /*  Don't allow definitions of static data members in dllimport\n-      class.  Just ignore the attribute for vtable data.  */\n-  else if (TREE_CODE (decl) == VAR_DECL\n-\t   && TREE_STATIC (decl)\n-\t   && TREE_PUBLIC (decl)\n-\t   && !DECL_EXTERNAL (decl))\n-    {\n-      if (!DECL_VIRTUAL_P (decl))\n-\terror (\"definition of static data member %q+D of dllimport%'d class\",\n-\t       decl);\n-      return false;\n-    }\n-\n-  /* Since we can't treat a pointer to a dllimport'd symbol as a\n-     constant address, we turn off the attribute on C++ virtual\n-     methods to allow creation of vtables using thunks.  Don't mark\n-     artificial methods either (in sh_symbian_associated_type, only\n-     COMDAT artificial method get import status from class context).  */\n-  else if (TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE\n-\t   && (DECL_VIRTUAL_P (decl) || DECL_ARTIFICIAL (decl)))\n-    return false;\n-\n-  return true;\n-}\n-\n-\f\n-/* This code implements a specification for exporting the vtable and rtti of\n-   classes that have members with the dllexport or dllexport attributes.\n-   This specification is defined here:\n-\n-     http://www.armdevzone.com/EABI/exported_class.txt\n-\n-   Basically it says that a class's vtable and rtti should be exported if\n-   the following rules apply:\n-\n-   - If it has any non-inline non-pure virtual functions,\n-     at least one of these need to be declared dllimport\n-     OR any of the constructors is declared dllimport.\n-\n-   AND\n-\n-   - The class has an inline constructor/destructor and\n-     a key-function (placement of vtable uniquely defined) that\n-     is defined in this translation unit.\n-\n-   The specification also says that for classes which will have their\n-   vtables and rtti exported that their base class(es) might also need a\n-   similar exporting if:\n-\n-   - Every base class needs to have its vtable & rtti exported\n-     as well, if the following the conditions hold true:\n-     + The base class has a non-inline declared non-pure virtual function\n-     + The base class is polymorphic (has or inherits any virtual functions)\n-       or the base class has any virtual base classes.  */\n-\n-/* Decide if a base class of a class should\n-   also have its vtable and rtti exported.  */\n-\n-static void\n-sh_symbian_possibly_export_base_class (tree base_class)\n-{\n-  VEC(tree,gc) *method_vec;\n-  int len;\n-\n-  if (! (TYPE_CONTAINS_VPTR_P (base_class)))\n-    return;\n-\n-  method_vec = CLASSTYPE_METHOD_VEC (base_class);\n-  len = method_vec ? VEC_length (tree, method_vec) : 0;\n-\n-  for (;len --;)\n-    {\n-      tree member = VEC_index (tree, method_vec, len);\n-\n-      if (! member)\n-\tcontinue;\n-\n-      for (member = OVL_CURRENT (member); member; member = OVL_NEXT (member))\n-\t{\n-\t  if (TREE_CODE (member) != FUNCTION_DECL)\n-\t    continue;\n-\n-\t  if (DECL_CONSTRUCTOR_P (member) || DECL_DESTRUCTOR_P (member))\n-\t    continue;\n-\n-\t  if (! DECL_VIRTUAL_P (member))\n-\t    continue;\n-\n-\t  if (DECL_PURE_VIRTUAL_P (member))\n-\t    continue;\n-\n-\t  if (DECL_DECLARED_INLINE_P (member))\n-\t    continue;\n-\n-\t  break;\n-\t}\n-\n-      if (member)\n-\tbreak;\n-    }\n-\n-  if (len < 0)\n-    return;\n-\n-  /* FIXME: According to the spec this base class should be exported, but\n-     a) how do we do this ? and\n-     b) it does not appear to be necessary for compliance with the Symbian\n-        OS which so far is the only consumer of this code.  */\n-#if SYMBIAN_DEBUG\n-  print_node_brief (stderr, \"\", base_class, 0);\n-  fprintf (stderr, \" EXPORTed [base class of exported class]\\n\");\n-#endif\n-}\n-\n-/* Add the named attribute to the given node.  Copes with both DECLs and\n-   TYPEs.  Will only add the attribute if it is not already present.  */\n-\n-static void\n-sh_symbian_add_attribute (tree node, const char *attr_name)\n-{\n-  tree attrs;\n-  tree attr;\n-\n-  attrs = DECL_P (node) ? DECL_ATTRIBUTES (node) : TYPE_ATTRIBUTES (node);\n-\n-  if (lookup_attribute (attr_name, attrs) != NULL_TREE)\n-    return;\n-\n-  attr = get_identifier (attr_name);\n-\n-  if (DECL_P (node))\n-    DECL_ATTRIBUTES (node) = tree_cons (attr, NULL_TREE, attrs);\n-  else\n-    TYPE_ATTRIBUTES (node) = tree_cons (attr, NULL_TREE, attrs);\n-\n-#if SYMBIAN_DEBUG\n-  fprintf (stderr, \"propagate %s attribute\", attr_name);\n-  print_node_brief (stderr, \" to\", node, 0);\n-  fprintf (stderr, \"\\n\");\n-#endif\n-}\n-\n-/* Add the named attribute to a class and its vtable and rtti.  */\n-\n-static void\n-sh_symbian_add_attribute_to_class_vtable_and_rtti (tree ctype, const char *attr_name)\n-{\n-  sh_symbian_add_attribute (ctype, attr_name);\n-\n-  /* If the vtable exists then they need annotating as well.  */\n-  if (CLASSTYPE_VTABLES (ctype))\n-    /* XXX - Do we need to annotate any vtables other than the primary ?  */\n-    sh_symbian_add_attribute (CLASSTYPE_VTABLES (ctype), attr_name);\n-\n-  /* If the rtti exists then it needs annotating as well.  */\n-  if (TYPE_MAIN_VARIANT (ctype)\n-      && CLASSTYPE_TYPEINFO_VAR (TYPE_MAIN_VARIANT (ctype)))\n-    sh_symbian_add_attribute (CLASSTYPE_TYPEINFO_VAR (TYPE_MAIN_VARIANT (ctype)),\n-\t\t\t      attr_name);\n-}\n-\n-/* Decide if a class needs to have an attribute because\n-   one of its member functions has the attribute.  */\n-\n-static bool\n-sh_symbian_class_needs_attribute (tree ctype, const char *attribute_name)\n-{\n-  VEC(tree,gc) *method_vec;\n-\n-  method_vec = CLASSTYPE_METHOD_VEC (ctype);\n-\n-  /* If the key function has the attribute then the class needs it too.  */\n-  if (TYPE_POLYMORPHIC_P (ctype)\n-      && method_vec\n-      && tree_contains_struct [TREE_CODE (ctype), TS_DECL_COMMON] == 1\n-      && lookup_attribute (attribute_name,\n-\t\t\t   DECL_ATTRIBUTES (VEC_index (tree, method_vec, 0))))\n-    return true;\n-\n-  /* Check the class's member functions.  */\n-  if (TREE_CODE (ctype) == RECORD_TYPE)\n-    {\n-      unsigned int len;\n-\n-      len = method_vec ? VEC_length (tree, method_vec) : 0;\n-\n-      for (;len --;)\n-\t{\n-\t  tree member = VEC_index (tree, method_vec, len);\n-\n-\t  if (! member)\n-\t    continue;\n-\n-\t  for (member = OVL_CURRENT (member);\n-\t       member;\n-\t       member = OVL_NEXT (member))\n-\t    {\n-\t      if (TREE_CODE (member) != FUNCTION_DECL)\n-\t\tcontinue;\n-\n-\t      if (DECL_PURE_VIRTUAL_P (member))\n-\t\tcontinue;\n-\n-\t      if (! DECL_VIRTUAL_P (member))\n-\t\tcontinue;\n-\n-\t      if (lookup_attribute (attribute_name, DECL_ATTRIBUTES (member)))\n-\t\t{\n-#if SYMBIAN_DEBUG\n-\t\t  print_node_brief (stderr, \"\", ctype, 0);\n-\t\t  fprintf (stderr, \" inherits %s because\", attribute_name);\n-\t\t  print_node_brief (stderr, \"\", member, 0);\n-\t\t  fprintf (stderr, \" has it.\\n\");\n-#endif\n-\t\t  return true;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-#if SYMBIAN_DEBUG\n-  print_node_brief (stderr, \"\", ctype, 0);\n-  fprintf (stderr, \" does not inherit %s\\n\", attribute_name);\n-#endif\n-  return false;\n-}\n-\n-/* Decide if a class needs its vtable and rtti exporting.  */\n-\n-static bool\n-symbian_export_vtable_and_rtti_p (tree ctype)\n-{\n-  bool inline_ctor_dtor;\n-  bool dllimport_ctor_dtor;\n-  bool dllimport_member;\n-  tree binfo, base_binfo;\n-  VEC(tree,gc) *method_vec;\n-  tree key;\n-  int i;\n-  int len;\n-\n-  /* Make sure that we are examining a class...  */\n-  if (TREE_CODE (ctype) != RECORD_TYPE)\n-    {\n-#if SYMBIAN_DEBUG\n-      print_node_brief (stderr, \"\", ctype, 0);\n-      fprintf (stderr, \" does NOT need to be EXPORTed [not a class]\\n\");\n-#endif\n-      return false;\n-    }\n-\n-  /* If the class does not have a key function it\n-     does not need to have its vtable exported.  */\n-  if ((key = CLASSTYPE_KEY_METHOD (ctype)) == NULL_TREE)\n-    {\n-#if SYMBIAN_DEBUG\n-      print_node_brief (stderr, \"\", ctype, 0);\n-      fprintf (stderr, \" does NOT need to be EXPORTed [no key function]\\n\");\n-#endif\n-      return false;\n-    }\n-\n-  /* If the key fn has not been defined\n-     then the class should not be exported.  */\n-  if (! TREE_ASM_WRITTEN (key))\n-    {\n-#if SYMBIAN_DEBUG\n-      print_node_brief (stderr, \"\", ctype, 0);\n-      fprintf (stderr, \" does NOT need to be EXPORTed [key function not defined]\\n\");\n-#endif\n-      return false;\n-    }\n-\n-  /* Check the class's member functions.  */\n-  inline_ctor_dtor = false;\n-  dllimport_ctor_dtor = false;\n-  dllimport_member = false;\n-\n-  method_vec = CLASSTYPE_METHOD_VEC (ctype);\n-  len = method_vec ? VEC_length (tree, method_vec) : 0;\n-\n-  for (;len --;)\n-    {\n-      tree member = VEC_index (tree, method_vec, len);\n-\n-      if (! member)\n-\tcontinue;\n-\n-      for (member = OVL_CURRENT (member); member; member = OVL_NEXT (member))\n-\t{\n-\t  if (TREE_CODE (member) != FUNCTION_DECL)\n-\t    continue;\n-\n-\t  if (DECL_CONSTRUCTOR_P (member) || DECL_DESTRUCTOR_P (member))\n-\t    {\n-\t      if (DECL_DECLARED_INLINE_P (member)\n-\t\t  /* Ignore C++ backend created inline ctors/dtors.  */\n-\t\t  && (   DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (member)\n-\t\t      || DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (member)))\n-\t\tinline_ctor_dtor = true;\n-\n-\t      if (lookup_attribute (\"dllimport\", DECL_ATTRIBUTES (member)))\n-\t\tdllimport_ctor_dtor = true;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (DECL_PURE_VIRTUAL_P (member))\n-\t\tcontinue;\n-\n-\t      if (! DECL_VIRTUAL_P (member))\n-\t\tcontinue;\n-\n-\t      if (DECL_DECLARED_INLINE_P (member))\n-\t\tcontinue;\n-\n-\t      if (lookup_attribute (\"dllimport\", DECL_ATTRIBUTES (member)))\n-\t\tdllimport_member = true;\n-\t    }\n-\t}\n-    }\n-\n-  if (! dllimport_member && ! dllimport_ctor_dtor)\n-    {\n-#if SYMBIAN_DEBUG\n-      print_node_brief (stderr, \"\", ctype, 0);\n-      fprintf (stderr,\n-\t       \" does NOT need to be EXPORTed [no non-pure virtuals or ctors/dtors with dllimport]\\n\");\n-#endif\n-      return false;\n-    }\n-\n-  if (! inline_ctor_dtor)\n-    {\n-#if SYMBIAN_DEBUG\n-      print_node_brief (stderr, \"\", ctype, 0);\n-      fprintf (stderr,\n-\t       \" does NOT need to be EXPORTed [no inline ctor/dtor]\\n\");\n-#endif\n-      return false;\n-    }\n-\n-#if SYMBIAN_DEBUG\n-  print_node_brief (stderr, \"\", ctype, 0);\n-  fprintf (stderr, \" DOES need to be EXPORTed\\n\");\n-#endif\n-\n-  /* Now we must check and possibly export the base classes.  */\n-  for (i = 0, binfo = TYPE_BINFO (ctype);\n-       BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n-    sh_symbian_possibly_export_base_class (BINFO_TYPE (base_binfo));\n-\n-  return true;\n-}\n-\n-/* Possibly override the decision to export class TYPE.  Upon entry\n-   IMPORT_EXPORT will contain 1 if the class is going to be exported,\n-   -1 if it is going to be imported and 0 otherwise.  This function\n-   should return the modified value and perform any other actions\n-   necessary to support the backend's targeted operating system.  */\n-\n-int\n-sh_symbian_import_export_class (tree ctype, int import_export)\n-{\n-  const char *attr_name = NULL;\n-\n-  /* If we are exporting the class but it does not have the dllexport\n-     attribute then we may need to add it.  Similarly imported classes\n-     may need the dllimport attribute.  */\n-  switch (import_export)\n-    {\n-    case  1: attr_name = \"dllexport\"; break;\n-    case -1: attr_name = \"dllimport\"; break;\n-    default: break;\n-    }\n-\n-  if (attr_name\n-      && ! lookup_attribute (attr_name, TYPE_ATTRIBUTES (ctype)))\n-    {\n-      if (sh_symbian_class_needs_attribute (ctype, attr_name))\n-\tsh_symbian_add_attribute_to_class_vtable_and_rtti (ctype, attr_name);\n-\n-      /* Classes can be forced to export their\n-\t vtable and rtti under certain conditions.  */\n-      if (symbian_export_vtable_and_rtti_p (ctype))\n-\t{\n-\t  sh_symbian_add_attribute_to_class_vtable_and_rtti (ctype, \"dllexport\");\n-\n-\t  /* Make sure that the class and its vtable are exported.  */\n-\t  import_export = 1;\n-\n-\t  if (CLASSTYPE_VTABLES (ctype))\n-\t    DECL_EXTERNAL (CLASSTYPE_VTABLES (ctype)) = 1;\n-\n-\t  /* Check to make sure that if the class has a key method that\n-\t     it is now on the list of keyed classes.  That way its vtable\n-\t     will be emitted.  */\n-\t  if (CLASSTYPE_KEY_METHOD (ctype))\n-\t    {\n-\t      tree class;\n-\n-\t      for (class = keyed_classes; class; class = TREE_CHAIN (class))\n-\t\tif (class == ctype)\n-\t\t  break;\n-\n-\t      if (class == NULL_TREE)\n-\t\t{\n-#if SYMBIAN_DEBUG\n-\t\t  print_node_brief (stderr, \"Add node\", ctype, 0);\n-\t\t  fprintf (stderr, \" to the keyed classes list\\n\");\n-#endif\n-\t\t  keyed_classes = tree_cons (NULL_TREE, ctype, keyed_classes);\n-\t\t}\n-\t    }\n-\n-\t  /* Make sure that the typeinfo will be emitted as well.  */\n-\t  if (CLASS_TYPE_P (ctype))\n-\t    TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (CLASSTYPE_TYPEINFO_VAR (TYPE_MAIN_VARIANT (ctype)))) = 1;\n-\t}\n-    }\n-\n-  return import_export;\n-}\n-\n-/* Handle a \"dllimport\" or \"dllexport\" attribute;\n-   arguments as in struct attribute_spec.handler.  */\n-\n-tree\n-sh_symbian_handle_dll_attribute (tree *pnode, tree name, tree args,\n-\t\t\t\t int flags, bool *no_add_attrs)\n-{\n-  tree thunk;\n-  tree node = *pnode;\n-  const char *attr = IDENTIFIER_POINTER (name);\n-\n-  /* These attributes may apply to structure and union types being\n-     created, but otherwise should pass to the declaration involved.  */\n-  if (!DECL_P (node))\n-    {\n-      if (flags & ((int) ATTR_FLAG_DECL_NEXT\n-\t\t   | (int) ATTR_FLAG_FUNCTION_NEXT\n-\t\t   | (int) ATTR_FLAG_ARRAY_NEXT))\n-\t{\n-\t  warning (OPT_Wattributes, \"%qs attribute ignored\", attr);\n-\t  *no_add_attrs = true;\n-\t  return tree_cons (name, args, NULL_TREE);\n-\t}\n-\n-      if (TREE_CODE (node) != RECORD_TYPE && TREE_CODE (node) != UNION_TYPE)\n-\t{\n-\t  warning (OPT_Wattributes, \"%qs attribute ignored\", attr);\n-\t  *no_add_attrs = true;\n-\t}\n-\n-      return NULL_TREE;\n-    }\n-\n-  /* Report error on dllimport ambiguities\n-     seen now before they cause any damage.  */\n-  else if (is_attribute_p (\"dllimport\", name))\n-    {\n-      if (TREE_CODE (node) == VAR_DECL)\n-\t{\n-\t  if (DECL_INITIAL (node))\n-\t    {\n-\t      error (\"variable %q+D definition is marked dllimport\",\n-\t\t     node);\n-\t      *no_add_attrs = true;\n-\t    }\n-\n-\t  /* `extern' needn't be specified with dllimport.\n-\t     Specify `extern' now and hope for the best.  Sigh.  */\n-\t  DECL_EXTERNAL (node) = 1;\n-\t  /* Also, implicitly give dllimport'd variables declared within\n-\t     a function global scope, unless declared static.  */\n-\t  if (current_function_decl != NULL_TREE && ! TREE_STATIC (node))\n-  \t    TREE_PUBLIC (node) = 1;\n-\t}\n-    }\n-\n-  /* If the node is an overloaded constructor or destructor, then we must\n-     make sure that the attribute is propagated along the overload chain,\n-     as it is these overloaded functions which will be emitted, rather than\n-     the user declared constructor itself.  */\n-  if (TREE_CODE (TREE_TYPE (node)) == METHOD_TYPE\n-      && (DECL_CONSTRUCTOR_P (node) || DECL_DESTRUCTOR_P (node)))\n-    {\n-      tree overload;\n-\n-      for (overload = OVL_CHAIN (node); overload; overload = OVL_CHAIN (overload))\n-\t{\n-\t  tree node_args;\n-\t  tree func_args;\n-\t  tree function = OVL_CURRENT (overload);\n-\n-\t  if (! function\n-\t      || ! DECL_P (function)\n-\t      || (DECL_CONSTRUCTOR_P (node) && ! DECL_CONSTRUCTOR_P (function))\n-\t      || (DECL_DESTRUCTOR_P (node)  && ! DECL_DESTRUCTOR_P (function)))\n-\t    continue;\n-\n-\t  /* The arguments must match as well.  */\n-\t  for (node_args = DECL_ARGUMENTS (node), func_args = DECL_ARGUMENTS (function);\n-\t       node_args && func_args;\n-\t       node_args = TREE_CHAIN (node_args), func_args = TREE_CHAIN (func_args))\n-\t    if (TREE_TYPE (node_args) != TREE_TYPE (func_args))\n-\t      break;\n-\n-\t  if (node_args || func_args)\n-\t    {\n-\t      /* We can ignore an extraneous __in_chrg arguments in the node.\n-\t\t GCC generated destructors, for example, will have this.  */\n-\t      if ((node_args == NULL_TREE\n-\t\t   || func_args != NULL_TREE)\n-\t\t  && strcmp (IDENTIFIER_POINTER (DECL_NAME (node)), \"__in_chrg\") != 0)\n-\t\tcontinue;\n-\t    }\n-\n-\t  sh_symbian_add_attribute (function, attr);\n-\n-\t  /* Propagate the attribute to any function thunks as well.  */\n-\t  for (thunk = DECL_THUNKS (function); thunk; thunk = DECL_CHAIN (thunk))\n-\t    if (TREE_CODE (thunk) == FUNCTION_DECL)\n-\t      sh_symbian_add_attribute (thunk, attr);\n-\t}\n-    }\n-\n-  if (TREE_CODE (node) == FUNCTION_DECL && DECL_VIRTUAL_P (node))\n-    {\n-      /* Propagate the attribute to any thunks of this function.  */\n-      for (thunk = DECL_THUNKS (node); thunk; thunk = DECL_CHAIN (thunk))\n-\tif (TREE_CODE (thunk) == FUNCTION_DECL)\n-\t  sh_symbian_add_attribute (thunk, attr);\n-    }\n-\n-  /*  Report error if symbol is not accessible at global scope.  */\n-  if (!TREE_PUBLIC (node)\n-      && (   TREE_CODE (node) == VAR_DECL\n-\t  || TREE_CODE (node) == FUNCTION_DECL))\n-    {\n-      error (\"external linkage required for symbol %q+D because of %qE attribute\",\n-\t     node, name);\n-      *no_add_attrs = true;\n-    }\n-\n-#if SYMBIAN_DEBUG\n-  print_node_brief (stderr, \"mark node\", node, 0);\n-  fprintf (stderr, \" as %s\\n\", attr);\n-#endif\n-\n-  return NULL_TREE;\n-}"}, {"sha": "a4497b96994bf38a0fa8915e72e461367e3687a5", "filename": "gcc/config/sh/symbian-post.h", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fsh%2Fsymbian-post.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fsh%2Fsymbian-post.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsymbian-post.h?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,88 +0,0 @@\n-/* Definitions for the Symbian OS running on an SH part.\n-   This file is included after all the other target specific headers.\n-\n-   Copyright (C) 2004, 2007 Free Software Foundation, Inc.\n-   Contributed by Red Hat.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-#undef  TARGET_VERSION\n-#define TARGET_VERSION \\\n-  fputs (\" (Renesas SH for Symbian OS)\", stderr);\n-\n-#undef  LINK_EMUL_PREFIX\n-#define LINK_EMUL_PREFIX \"shlsymbian\"\n-\n-\n-#define SYMBIAN_EXPORT_NAME(NAME,FILE,DECL)\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if ((DECL && sh_symbian_is_dllexported (DECL))\t\t\\\n-         || sh_symbian_is_dllexported_name (NAME))\t\t\\\n-        {\t\t\t\t\t\t\t\\\n-          fprintf ((FILE), \"\\t.pushsection .directive\\n\");\t\\\n-          fprintf ((FILE), \"\\t.asciz \\\"EXPORT %s\\\\n\\\"\\n\",\t\\\n-\t           sh_symbian_strip_name_encoding (NAME));\t\\\n-          fprintf ((FILE), \"\\t.popsection\\n\");\t\t\t\\\n-       }\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Output a function definition label.  */\n-#undef  ASM_DECLARE_FUNCTION_NAME\n-#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      SYMBIAN_EXPORT_NAME ((NAME), (FILE), (DECL));\t\t\\\n-      ASM_OUTPUT_TYPE_DIRECTIVE ((FILE), (NAME), \"function\");\t\\\n-      ASM_DECLARE_RESULT ((FILE), DECL_RESULT (DECL));\t\t\\\n-      ASM_OUTPUT_LABEL ((FILE), (NAME));\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-/* Output the label for an initialized variable.  */\n-#undef  ASM_DECLARE_OBJECT_NAME\n-#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      HOST_WIDE_INT size;\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      SYMBIAN_EXPORT_NAME ((NAME), (FILE), (DECL));\t\t\\\n-      ASM_OUTPUT_TYPE_DIRECTIVE ((FILE), (NAME), \"object\");\t\\\n-\t\t\t\t\t\t\t\t\\\n-      size_directive_output = 0;\t\t\t\t\\\n-      if (!flag_inhibit_size_directive\t\t\t\t\\\n-\t  && (DECL)\t\t\t\t\t\t\\\n-          && DECL_SIZE (DECL))\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  size_directive_output = 1;\t\t\t\t\\\n-\t  size = int_size_in_bytes (TREE_TYPE (DECL));\t\t\\\n-\t  ASM_OUTPUT_SIZE_DIRECTIVE ((FILE), (NAME), size);\t\\\n-\t}\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-      ASM_OUTPUT_LABEL ((FILE), (NAME));\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)\n-\n-#undef  ASM_OUTPUT_LABELREF\n-#define ASM_OUTPUT_LABELREF(FILE, NAME)\t\t\t\t\\\n-  do\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      asm_fprintf ((FILE), \"%U%s\",\t\t\t\t\\\n-\t\t   sh_symbian_strip_name_encoding (NAME));\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  while (0)"}, {"sha": "d2229e071f2621746ce0f4e5336f5460a720a575", "filename": "gcc/config/sh/symbian-pre.h", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fsh%2Fsymbian-pre.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fsh%2Fsymbian-pre.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsymbian-pre.h?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,40 +0,0 @@\n-/* Definitions for the Symbian OS running on an SH part.\n-   This file is included before any other target specific headers.\n-\n-   Copyright (C) 2004, 2005, 2007 Free Software Foundation, Inc.\n-   Contributed by Red Hat.\n-\n-   This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published\n-   by the Free Software Foundation; either version 3, or (at your\n-   option) any later version.\n-\n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.  */\n-\n-/* Enable Symbian specific code.  */\n-#define SYMBIAN\t\t1\n-\n-/* Default to using the Renesas ABI.  */\n-#define TARGET_ABI_DEFAULT\tMASK_HITACHI\n-\n-#define SUBTARGET_CPP_SPEC \"\"\n-\n-/* Get tree.c to declare merge_dllimport_decl_attributes().  */\n-#define TARGET_DLLIMPORT_DECL_ATTRIBUTES 1\n-\n-/* The Symbian OS currently does not support exception handling.  */\n-#define SUBTARGET_CC1PLUS_SPEC \"-fno-exceptions\"\n-\n-/* Create constructor/destructor sections without the writable flag.\n-   Symbian puts them into the text segment and munges them later on.  */\n-#define CTORS_SECTION_ASM_OP\t\"\\t.section\\t.ctors,\\\"ax\\\",@progbits\"\n-#define DTORS_SECTION_ASM_OP\t\"\\t.section\\t.dtors,\\\"ax\\\",@progbits\""}, {"sha": "f0b7dabd4e539f4ea37f7ab6c0d2f295608f3298", "filename": "gcc/config/sh/t-symbian", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fsh%2Ft-symbian", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fsh%2Ft-symbian", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-symbian?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,81 +0,0 @@\n-# Copyright (C) 2004, 2006, 2008, 2009 Free Software Foundation, Inc.\n-#\n-# This file is part of GCC.\n-#\n-# GCC is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3, or (at your option)\n-# any later version.\n-#\n-# GCC is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-#\n-# You should have received a copy of the GNU General Public License\n-# along with GCC; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-sh-c.o: $(srcdir)/config/sh/sh-c.c \\\n-  $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TM_H) $(TM_P_H) coretypes.h\n-\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n-\t\t$(srcdir)/config/sh/sh-c.c\n-\n-symbian-cxx.o: \\\n-  $(srcdir)/config/sh/symbian-cxx.c \\\n-  $(srcdir)/config/sh/sh-symbian.h \\\n-  $(CONFIG_H) $(SYSTEM_H) $(TM_H) $(TREE_H) $(RTL_H) \\\n-  toplev.h output.h coretypes.h flags.h expr.h\n-\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n-\n-symbian-c.o: \\\n-  $(srcdir)/config/sh/symbian-c.c \\\n-  $(srcdir)/config/sh/sh-symbian.h \\\n-  $(CONFIG_H) $(SYSTEM_H) $(TM_H) $(TREE_H) $(RTL_H) \\\n-  toplev.h output.h coretypes.h flags.h expr.h\n-\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n-\n-symbian-base.o: \\\n-  $(srcdir)/config/sh/symbian-base.c \\\n-  $(srcdir)/config/sh/sh-symbian.h \\\n-  $(CONFIG_H) $(SYSTEM_H) $(TM_H) $(TREE_H) $(RTL_H) \\\n-  toplev.h output.h coretypes.h flags.h expr.h\n-\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $<\n-\n-\n-LIB1ASMSRC = sh/lib1funcs.asm\n-LIB1ASMFUNCS = _ashiftrt _ashiftrt_n _ashiftlt _lshiftrt _movstr \\\n-  _movstr_i4 _mulsi3 _sdivsi3 _sdivsi3_i4 _udivsi3 _udivsi3_i4 _set_fpscr \\\n-  $(LIB1ASMFUNCS_CACHE)\n-\n-# We want fine grained libraries, so use the new code to build the\n-# floating point emulation libraries.\n-FPBIT = fp-bit.c\n-DPBIT = dp-bit.c\n-\n-dp-bit.c: $(srcdir)/config/fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> dp-bit.c\n-\n-fp-bit.c: $(srcdir)/config/fp-bit.c\n-\techo '#define FLOAT' > fp-bit.c\n-\tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n-\n-$(T)crt1.o: $(srcdir)/config/sh/crt1.asm $(GCC_PASSES)\n-\t$(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) -c -o $(T)crt1.o -x assembler-with-cpp $(srcdir)/config/sh/crt1.asm\n-$(T)crti.o: $(srcdir)/config/sh/crti.asm $(GCC_PASSES)\n-\t$(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) -c -o $(T)crti.o -x assembler-with-cpp $(srcdir)/config/sh/crti.asm\n-$(T)crtn.o: $(srcdir)/config/sh/crtn.asm $(GCC_PASSES)\n-\t$(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) -c -o $(T)crtn.o -x assembler-with-cpp $(srcdir)/config/sh/crtn.asm\n-\n-$(out_object_file): gt-sh.h\n-gt-sh.h : s-gtype ; @true\n-\n-symbian.o: $(srcdir)/config/sh/symbian.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-  $(RTL_H) output.h flags.h $(TREE_H) expr.h toplev.h $(TM_P_H)\n-\t$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \\\n-\t\t$(srcdir)/config/sh/symbian.c\n-\n-\n-# Local Variables:\n-# mode: Makefile\n-# End:"}, {"sha": "243206245a62d412e3fd5226e3446a3773150058", "filename": "gcc/config/svr3.h", "status": "removed", "additions": 0, "deletions": 146, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fsvr3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fsvr3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsvr3.h?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,146 +0,0 @@\n-/* Operating system specific defines to be used when targeting GCC for\n-   generic System V Release 3 system.\n-   Copyright (C) 1991, 1996, 2000, 2002, 2004, 2007, 2010\n-   Free Software Foundation, Inc.\n-   Contributed by Ron Guilmette (rfg@monkeys.com).\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>. */\n-\n-/* Define a symbol indicating that we are using svr3.h.  */\n-#define USING_SVR3_H\n-\n-/* Define a symbol so that libgcc* can know what sort of operating\n-   environment and assembler syntax we are targeting for.  */\n-#define SVR3_target\n-\n-/* Assembler, linker, library, and startfile spec's.  */\n-\n-/* The .file command should always begin the output.  */\n-#define TARGET_ASM_FILE_START_FILE_DIRECTIVE true\n-\n-/* This says how to output an assembler line\n-   to define a global common symbol.  */\n-/* We don't use ROUNDED because the standard compiler doesn't,\n-   and the linker gives error messages if a common symbol\n-   has more than one length value.  */\n-\n-#undef ASM_OUTPUT_COMMON\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".comm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%lu\\n\", (unsigned long)(SIZE)))\n-\n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n-\n-/* Note that using bss_section here caused errors\n-   in building shared libraries on system V.3.  */\n-#undef ASM_OUTPUT_LOCAL\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)\t\\\n-  do {\t\t\t\t\t\t\t\\\n-    int align = exact_log2 (ROUNDED);\t\t\t\\\n-    if (align > 2) align = 2;\t\t\t\t\\\n-    switch_to_section (data_section);\t\t\t\\\n-    ASM_OUTPUT_ALIGN ((FILE), align == -1 ? 2 : align);\t\\\n-    ASM_OUTPUT_LABEL ((FILE), (NAME));\t\t\t\\\n-    fprintf ((FILE), \"\\t.set .,.+%u\\n\", (int)(ROUNDED));\t\\\n-  } while (0)\n-\n-/* Output #ident as a .ident.  */\n-\n-#undef  ASM_OUTPUT_IDENT\n-#define ASM_OUTPUT_IDENT(FILE, NAME) \\\n-  fprintf (FILE, \"\\t.ident \\\"%s\\\"\\n\", NAME);\n-\n-/* Use periods rather than dollar signs in special g++ assembler names.  */\n-\n-#define NO_DOLLAR_IN_LABEL\n-\n-/* System V Release 3 uses COFF debugging info.  */\n-\n-#define SDB_DEBUGGING_INFO 1\n-\n-/* We don't want to output DBX debugging information.  */\n-\n-#undef DBX_DEBUGGING_INFO\n-\n-/* The prefix to add to user-visible assembler symbols.\n-\n-   For System V Release 3 the convention is to prepend a leading\n-   underscore onto user-level symbol names.  */\n-\n-#undef USER_LABEL_PREFIX\n-#define USER_LABEL_PREFIX \"_\"\n-\n-/* This is how to store into the string LABEL\n-   the symbol_ref name of an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.\n-   This is suitable for output with `assemble_name'.\n-\n-   For most svr3 systems, the convention is that any symbol which begins\n-   with a period is not put into the linker symbol table by the assembler.  */\n-\n-#undef ASM_GENERATE_INTERNAL_LABEL\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n-  sprintf (LABEL, \"*%s%s%ld\", LOCAL_LABEL_PREFIX, PREFIX, (long)(NUM))\n-\n-/* We want local labels to start with period if made with asm_fprintf.  */\n-#undef LOCAL_LABEL_PREFIX\n-#define LOCAL_LABEL_PREFIX \".\"\n-\n-/* Support const sections and the ctors and dtors sections for g++.  */\n-\n-/* Define a few machine-specific details of the implementation of\n-   constructors.\n-\n-   The __CTORS_LIST__ goes in the .init section.  Define CTOR_LIST_BEGIN\n-   and CTOR_LIST_END to contribute to the .init section an instruction to\n-   push a word containing 0 (or some equivalent of that).\n-\n-   Define TARGET_ASM_CONSTRUCTOR to push the address of the constructor.  */\n-\n-#define INIT_SECTION_ASM_OP     \"\\t.section\\t.init\"\n-#define FINI_SECTION_ASM_OP     \"\\t.section .fini,\\\"x\\\"\"\n-#define DTORS_SECTION_ASM_OP    FINI_SECTION_ASM_OP\n-\n-/* CTOR_LIST_BEGIN and CTOR_LIST_END are machine-dependent\n-   because they push on the stack.  */\n-\n-#ifndef STACK_GROWS_DOWNWARD\n-\n-/* Constructor list on stack is in reverse order.  Go to the end of the\n-   list and go backwards to call constructors in the right order.  */\n-#define DO_GLOBAL_CTORS_BODY\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\\\n-  func_ptr *p, *beg = alloca (0);\t\t\t\t\\\n-  for (p = beg; *p; p++)\t\t\t\t\t\\\n-    ;\t\t\t\t\t\t\t\t\\\n-  while (p != beg)\t\t\t\t\t\t\\\n-    (*--p) ();\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-#else\n-\n-/* Constructor list on stack is in correct order.  Just call them.  */\n-#define DO_GLOBAL_CTORS_BODY\t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\\\n-  func_ptr *p, *beg = alloca (0);\t\t\t\t\\\n-  for (p = beg; *p; )\t\t\t\t\t\t\\\n-    (*p++) ();\t\t\t\t\t\t\t\\\n-} while (0)\n-\n-#endif /* STACK_GROWS_DOWNWARD */"}, {"sha": "51c32f7346eb0242778d2802080ec48c9e78dd00", "filename": "gcc/config/vax/netbsd.h", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fvax%2Fnetbsd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Fconfig%2Fvax%2Fnetbsd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fnetbsd.h?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,47 +0,0 @@\n-/* Definitions of target machine for GNU compiler.\n-   NetBSD/vax a.out version.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2007\n-   Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#define TARGET_OS_CPP_BUILTINS()\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      NETBSD_OS_CPP_BUILTINS_AOUT();\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-#undef CPP_SPEC\n-#define CPP_SPEC NETBSD_CPP_SPEC\n-\n-/* Make gcc agree with <machine/ansi.h> */\n-\n-#undef SIZE_TYPE\n-#define SIZE_TYPE \"unsigned int\"\n-\n-#undef PTRDIFF_TYPE\n-#define PTRDIFF_TYPE \"int\"\n-\n-/* Until they use ELF or something that handles dwarf2 unwinds\n-   and initialization stuff better.  Use sjlj exceptions.  */\n-#undef DWARF2_UNWIND_INFO\n-\n-/* We use gas, not the UNIX assembler.  */\n-#undef TARGET_DEFAULT\n-#define TARGET_DEFAULT 0"}, {"sha": "1ea08e2bf71295482750ed3fa1b1ec142510e2d6", "filename": "gcc/configure", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -25837,7 +25837,6 @@ $as_echo \"$have_sys_sdt_h\" >&6; }\n # and later they can use TFmode.\n case \"$target\" in\n   powerpc*-*-linux* | \\\n-  powerpc*-*-gnu* | \\\n   sparc*-*-linux* | \\\n   s390*-*-linux* | \\\n   alpha*-*-linux*)"}, {"sha": "8b2eae56452ee6a354f271b93fb7cf1f100e079a", "filename": "gcc/configure.ac", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -4421,7 +4421,6 @@ AC_MSG_RESULT($have_sys_sdt_h)\n # and later they can use TFmode.\n case \"$target\" in\n   powerpc*-*-linux* | \\\n-  powerpc*-*-gnu* | \\\n   sparc*-*-linux* | \\\n   s390*-*-linux* | \\\n   alpha*-*-linux*)"}, {"sha": "7f6d96eeafe6f4108bf04820b139a5f09b0cd027", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -2551,7 +2551,7 @@ This attribute is ignored for R8C target.\n \n @item interrupt\n @cindex interrupt handler functions\n-Use this attribute on the ARM, AVR, CRX, M32C, M32R/D, m68k, MeP, MIPS,\n+Use this attribute on the ARM, AVR, M32C, M32R/D, m68k, MeP, MIPS,\n RX and Xstormy16 ports to indicate that the specified function is an\n interrupt handler.  The compiler will generate function entry and exit\n sequences suitable for use in an interrupt handler when this attribute"}, {"sha": "e349c63b45fb9e93430a03d7e821b33ca9daed78", "filename": "gcc/doc/install-old.texi", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fdoc%2Finstall-old.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fdoc%2Finstall-old.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall-old.texi?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,4 +1,5 @@\n-@c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+@c Copyright (C) 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+@c 1999, 2000, 2001, 2002, 2003, 2011 Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file install.texi.\n \n@@ -102,7 +103,7 @@ Here are the possible CPU types:\n @c gmicro, fx80, spur and tahoe omitted since they don't work.\n 1750a, a29k, alpha, arm, avr, c@var{n}, clipper, dsp16xx, elxsi, fr30, h8300,\n hppa1.0, hppa1.1, i370, i386, i486, i586, i686, i786, i860, i960, ip2k, m32r,\n-m68000, m68k, m6811, m6812, m88k, mcore, mips, mipsel, mips64, mips64el,\n+m68000, m68k, m88k, mcore, mips, mipsel, mips64, mips64el,\n mn10200, mn10300, ns32k, pdp11, powerpc, powerpcle, romp, rs6000, sh, sparc,\n sparclite, sparc64, v850, vax, we32k.\n @end quotation"}, {"sha": "d8a6a59d7ef254877e65dd0d9436d55025b0ca1b", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 1, "deletions": 62, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1012,9 +1012,6 @@ predefined set of them.\n Some targets provide finer-grained control over which multilibs are built\n (e.g., @option{--disable-softfloat}):\n @table @code\n-@item arc-*-elf*\n-biendian.\n-\n @item arm-*-*\n fpu, 26bit, underscore, interwork, biendian, nofmult.\n \n@@ -2940,8 +2937,6 @@ information are.\n @item\n @uref{#alpha-dec-osf51,,alpha*-dec-osf5.1}\n @item\n-@uref{#arc-x-elf,,arc-*-elf}\n-@item\n @uref{#arm-x-elf,,arm-*-elf}\n @item\n @uref{#avr,,avr}\n@@ -2984,10 +2979,6 @@ information are.\n @item\n @uref{#m32r-x-elf,,m32r-*-elf}\n @item\n-@uref{#m6811-elf,,m6811-elf}\n-@item\n-@uref{#m6812-elf,,m6812-elf}\n-@item\n @uref{#m68k-x-x,,m68k-*-*}\n @item\n @uref{#m68k-uclinux,,m68k-uclinux}\n@@ -3137,13 +3128,6 @@ provide a fix shortly.\n \n @c FIXME: still applicable?\n \n-@html\n-<hr />\n-@end html\n-@heading @anchor{arc-x-elf}arc-*-elf\n-Argonaut ARC processor.\n-This configuration is intended for embedded systems.\n-\n @html\n <hr />\n @end html\n@@ -3242,35 +3226,6 @@ Pre-packaged tools can be obtained from\n information about this platform is available at\n @uref{http://developer.axis.com/}.\n \n-@html\n-<hr />\n-@end html\n-@heading @anchor{crx}CRX\n-\n-The CRX CompactRISC architecture is a low-power 32-bit architecture with\n-fast context switching and architectural extensibility features.\n-\n-@ifnothtml\n-@xref{CRX Options,, CRX Options, gcc, Using and Porting the GNU Compiler\n-Collection (GCC)},\n-@end ifnothtml\n-\n-@ifhtml\n-See ``CRX Options'' in the main manual for a list of CRX-specific options.\n-@end ifhtml\n-\n-Use @samp{configure --target=crx-elf --enable-languages=c,c++} to configure\n-GCC@ for building a CRX cross-compiler. The option @samp{--target=crx-elf}\n-is also used to build the @samp{newlib} C library for CRX.\n-\n-It is also possible to build libstdc++-v3 for the CRX architecture. This\n-needs to be done in a separate step with the following configure settings:\n-\n-@smallexample\n-gcc/libstdc++-v3/configure --host=crx-elf --with-newlib \\\n-    --enable-sjlj-exceptions --enable-cxx-flags='-fexceptions -frtti'\n-@end smallexample\n-\n @html\n <hr />\n @end html\n@@ -3792,20 +3747,6 @@ This configuration is intended for embedded systems.\n Renesas M32R processor.\n This configuration is intended for embedded systems.\n \n-@html\n-<hr />\n-@end html\n-@heading @anchor{m6811-elf}m6811-elf\n-Motorola 68HC11 family micro controllers.  These are used in embedded\n-applications.  There are no standard Unix configurations.\n-\n-@html\n-<hr />\n-@end html\n-@heading @anchor{m6812-elf}m6812-elf\n-Motorola 68HC12 family micro controllers.  These are used in embedded\n-applications.  There are no standard Unix configurations.\n-\n @html\n <hr />\n @end html\n@@ -3839,9 +3780,7 @@ be a @option{-mcpu} argument or one of the following values:\n GCC 4.3 changed the uClinux configuration so that it uses the\n @samp{m68k-linux-gnu} ABI rather than the @samp{m68k-elf} ABI.\n It also added improved support for C++ and flat shared libraries,\n-both of which were ABI changes.  However, you can still use the\n-original ABI by configuring for @samp{m68k-uclinuxoldabi} or\n-@samp{m68k-@var{vendor}-uclinuxoldabi}.\n+both of which were ABI changes.\n \n \n @html"}, {"sha": "6390b81958bb9192e07b56def128e0ae0c6c16a5", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 1, "deletions": 145, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -445,11 +445,6 @@ Objective-C and Objective-C++ Dialects}.\n @c Try and put the significant identifier (CPU or system) first,\n @c so users have a clue at guessing where the ones they want will be.\n \n-@emph{ARC Options}\n-@gccoptlist{-EB  -EL @gol\n--mmangle-cpu  -mcpu=@var{cpu}  -mtext=@var{text-section} @gol\n--mdata=@var{data-section}  -mrodata=@var{readonly-data-section}}\n-\n @emph{ARM Options}\n @gccoptlist{-mapcs-frame  -mno-apcs-frame @gol\n -mabi=@var{name} @gol\n@@ -501,9 +496,6 @@ Objective-C and Objective-C++ Dialects}.\n -melf  -maout  -melinux  -mlinux  -sim  -sim2 @gol\n -mmul-bug-workaround  -mno-mul-bug-workaround}\n \n-@emph{CRX Options}\n-@gccoptlist{-mmac -mpush-args}\n-\n @emph{Darwin Options}\n @gccoptlist{-all_load  -allowable_client  -arch  -arch_errors_fatal @gol\n -arch_only  -bind_at_load  -bundle  -bundle_loader @gol\n@@ -668,11 +660,6 @@ Objective-C and Objective-C++ Dialects}.\n -mshared-library-id=n  -mid-shared-library  -mno-id-shared-library @gol\n -mxgot -mno-xgot}\n \n-@emph{M68hc1x Options}\n-@gccoptlist{-m6811  -m6812  -m68hc11  -m68hc12   -m68hcs12 @gol\n--mauto-incdec  -minmax  -mlong-calls  -mshort @gol\n--msoft-reg-count=@var{count}}\n-\n @emph{MCore Options}\n @gccoptlist{-mhardlit  -mno-hardlit  -mdiv  -mno-div  -mrelax-immediates @gol\n -mno-relax-immediates  -mwide-bitfields  -mno-wide-bitfields @gol\n@@ -9962,12 +9949,10 @@ platform.\n @c in Machine Dependent Options\n \n @menu\n-* ARC Options::\n * ARM Options::\n * AVR Options::\n * Blackfin Options::\n * CRIS Options::\n-* CRX Options::\n * Darwin Options::\n * DEC Alpha Options::\n * DEC Alpha/VMS Options::\n@@ -9984,7 +9969,6 @@ platform.\n * M32C Options::\n * M32R/D Options::\n * M680x0 Options::\n-* M68hc1x Options::\n * MCore Options::\n * MeP Options::\n * MicroBlaze Options::\n@@ -10012,49 +9996,6 @@ platform.\n * zSeries Options::\n @end menu\n \n-@node ARC Options\n-@subsection ARC Options\n-@cindex ARC Options\n-\n-These options are defined for ARC implementations:\n-\n-@table @gcctabopt\n-@item -EL\n-@opindex EL\n-Compile code for little endian mode.  This is the default.\n-\n-@item -EB\n-@opindex EB\n-Compile code for big endian mode.\n-\n-@item -mmangle-cpu\n-@opindex mmangle-cpu\n-Prepend the name of the CPU to all public symbol names.\n-In multiple-processor systems, there are many ARC variants with different\n-instruction and register set characteristics.  This flag prevents code\n-compiled for one CPU to be linked with code compiled for another.\n-No facility exists for handling variants that are ``almost identical''.\n-This is an all or nothing option.\n-\n-@item -mcpu=@var{cpu}\n-@opindex mcpu\n-Compile code for ARC variant @var{cpu}.\n-Which variants are supported depend on the configuration.\n-All variants support @option{-mcpu=base}, this is the default.\n-\n-@item -mtext=@var{text-section}\n-@itemx -mdata=@var{data-section}\n-@itemx -mrodata=@var{readonly-data-section}\n-@opindex mtext\n-@opindex mdata\n-@opindex mrodata\n-Put functions, data, and readonly data in @var{text-section},\n-@var{data-section}, and @var{readonly-data-section} respectively\n-by default.  This can be overridden with the @code{section} attribute.\n-@xref{Variable Attributes}.\n-\n-@end table\n-\n @node ARM Options\n @subsection ARM Options\n @cindex ARM options\n@@ -10795,24 +10736,6 @@ Like @option{-sim}, but pass linker options to locate initialized data at\n 0x40000000 and zero-initialized data at 0x80000000.\n @end table\n \n-@node CRX Options\n-@subsection CRX Options\n-@cindex CRX Options\n-\n-These options are defined specifically for the CRX ports.\n-\n-@table @gcctabopt\n-\n-@item -mmac\n-@opindex mmac\n-Enable the use of multiply-accumulate instructions. Disabled by default.\n-\n-@item -mpush-args\n-@opindex mpush-args\n-Push instructions will be used to pass outgoing arguments when functions\n-are called. Enabled by default.\n-@end table\n-\n @node Darwin Options\n @subsection Darwin Options\n @cindex Darwin options\n@@ -13685,68 +13608,6 @@ position-independent code.\n \n @end table\n \n-@node M68hc1x Options\n-@subsection M68hc1x Options\n-@cindex M68hc1x options\n-\n-These are the @samp{-m} options defined for the 68hc11 and 68hc12\n-microcontrollers.  The default values for these options depends on\n-which style of microcontroller was selected when the compiler was configured;\n-the defaults for the most common choices are given below.\n-\n-@table @gcctabopt\n-@item -m6811\n-@itemx -m68hc11\n-@opindex m6811\n-@opindex m68hc11\n-Generate output for a 68HC11.  This is the default\n-when the compiler is configured for 68HC11-based systems.\n-\n-@item -m6812\n-@itemx -m68hc12\n-@opindex m6812\n-@opindex m68hc12\n-Generate output for a 68HC12.  This is the default\n-when the compiler is configured for 68HC12-based systems.\n-\n-@item -m68S12\n-@itemx -m68hcs12\n-@opindex m68S12\n-@opindex m68hcs12\n-Generate output for a 68HCS12.\n-\n-@item -mauto-incdec\n-@opindex mauto-incdec\n-Enable the use of 68HC12 pre and post auto-increment and auto-decrement\n-addressing modes.\n-\n-@item -minmax\n-@itemx -mnominmax\n-@opindex minmax\n-@opindex mnominmax\n-Enable the use of 68HC12 min and max instructions.\n-\n-@item -mlong-calls\n-@itemx -mno-long-calls\n-@opindex mlong-calls\n-@opindex mno-long-calls\n-Treat all calls as being far away (near).  If calls are assumed to be\n-far away, the compiler will use the @code{call} instruction to\n-call a function and the @code{rtc} instruction for returning.\n-\n-@item -mshort\n-@opindex mshort\n-Consider type @code{int} to be 16 bits wide, like @code{short int}.\n-\n-@item -msoft-reg-count=@var{count}\n-@opindex msoft-reg-count\n-Specify the number of pseudo-soft registers which are used for the\n-code generation.  The maximum number is 32.  Using more pseudo-soft\n-register may or may not result in better code depending on the program.\n-The default is 4 for 68HC11 and 2 for 68HC12.\n-\n-@end table\n-\n @node MCore Options\n @subsection MCore Options\n @cindex MCore options\n@@ -15910,11 +15771,6 @@ operating system.\n On System V.4 and embedded PowerPC systems compile code for the\n Linux-based GNU system.\n \n-@item -mcall-gnu\n-@opindex mcall-gnu\n-On System V.4 and embedded PowerPC systems compile code for the\n-Hurd-based GNU system.\n-\n @item -mcall-freebsd\n @opindex mcall-freebsd\n On System V.4 and embedded PowerPC systems compile code for the\n@@ -16748,7 +16604,7 @@ Comply with the calling conventions defined by Renesas.\n @opindex mhitachi\n Comply with the calling conventions defined for GCC before the Renesas\n conventions were available.  This option is the default for all\n-targets of the SH toolchain except for @samp{sh-symbianelf}.\n+targets of the SH toolchain.\n \n @item -mnomacsave\n @opindex mnomacsave"}, {"sha": "df99ad4d6261d079a90b4da5879c369ab2acc898", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1775,37 +1775,6 @@ Integer constant in the range @minus{}6 @dots{} 5.\n A memory address based on Y or Z pointer with displacement.\n @end table\n \n-@item CRX Architecture---@file{config/crx/crx.h}\n-@table @code\n-\n-@item b\n-Registers from r0 to r14 (registers without stack pointer)\n-\n-@item l\n-Register r16 (64-bit accumulator lo register)\n-\n-@item h\n-Register r17 (64-bit accumulator hi register)\n-\n-@item k\n-Register pair r16-r17. (64-bit accumulator lo-hi pair)\n-\n-@item I\n-Constant that fits in 3 bits\n-\n-@item J\n-Constant that fits in 4 bits\n-\n-@item K\n-Constant that fits in 5 bits\n-\n-@item L\n-Constant that is one of @minus{}1, 4, @minus{}4, 7, 8, 12, 16, 20, 32, 48\n-\n-@item G\n-Floating point constant that is legal for store immediate\n-@end table\n-\n @item Hewlett-Packard PA-RISC---@file{config/pa/pa.h}\n @table @code\n @item a\n@@ -2868,64 +2837,6 @@ Non-register operands allowed in clr\n \n @end table\n \n-@item Motorola 68HC11 & 68HC12 families---@file{config/m68hc11/m68hc11.h}\n-@table @code\n-@item a\n-Register `a'\n-\n-@item b\n-Register `b'\n-\n-@item d\n-Register `d'\n-\n-@item q\n-An 8-bit register\n-\n-@item t\n-Temporary soft register _.tmp\n-\n-@item u\n-A soft register _.d1 to _.d31\n-\n-@item w\n-Stack pointer register\n-\n-@item x\n-Register `x'\n-\n-@item y\n-Register `y'\n-\n-@item z\n-Pseudo register `z' (replaced by `x' or `y' at the end)\n-\n-@item A\n-An address register: x, y or z\n-\n-@item B\n-An address register: x or y\n-\n-@item D\n-Register pair (x:d) to form a 32-bit value\n-\n-@item L\n-Constants in the range @minus{}65536 to 65535\n-\n-@item M\n-Constants whose 16-bit low part is zero\n-\n-@item N\n-Constant integer 1 or @minus{}1\n-\n-@item O\n-Constant integer 16\n-\n-@item P\n-Constants in the range @minus{}8 to 2\n-\n-@end table\n-\n @item Moxie---@file{config/moxie/constraints.md}\n @table @code\n @item A"}, {"sha": "bd44c6c9ab8c6014dc4a1435c46ee5bbdb7d2776", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,3 +1,25 @@\n+2011-03-22  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* gcc.c-torture/execute/920501-8.x: Remove.\n+\t* gcc.c-torture/execute/930513-1.x: Remove.\n+\t* gcc.c-torture/execute/960312-1.x: Remove.\n+\t* gcc.c-torture/compile/20000804-1.c,\n+\tgcc.c-torture/compile/20001205-1.c,\n+\tgcc.c-torture/compile/20001226-1.c,\n+\tgcc.c-torture/compile/20010518-2.c,\n+\tgcc.c-torture/compile/20020312-1.c,\n+\tgcc.c-torture/compile/20020604-1.c,\n+\tgcc.c-torture/compile/920501-12.c,\n+\tgcc.c-torture/compile/920501-4.c,\n+\tgcc.c-torture/compile/920520-1.c,\n+\tgcc.c-torture/compile/980506-1.c,\n+\tgcc.c-torture/execute/980709-1.x,\n+\tgcc.c-torture/execute/990826-0.x: Don't XFAIL or use special\n+\toptions for m68hc11.\n+\t* gcc.dg/cpp/assert4.c: Don't handle ARC.\n+\t* gcc.dg/sibcall-3.c, gcc.dg/sibcall-4.c: Don't XFAIL for arc or\n+\tm68hc11.\n+\n 2011-03-22  Nick Clifton  <nickc@redhat.com>\n \n \t* lib/target-supports.exp (check_profiling_available): Add MN10300"}, {"sha": "6916951bb72363f0fa217db9e9f2fda4fa9a16ce", "filename": "gcc/testsuite/gcc.c-torture/compile/20000804-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20000804-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20000804-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20000804-1.c?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,10 +1,10 @@\n-/* This does not work on m68hc11 or h8300 due to the use of an asm\n+/* This does not work on h8300 due to the use of an asm\n    statement to force a 'long long' (64-bits) to go in a register.  */\n /* { dg-do assemble } */\n /* { dg-skip-if \"\" { { i?86-*-* x86_64-*-* } && { ilp32 && { ! nonpic } } } { \"*\" } { \"\" } } */\n /* { dg-skip-if \"No 64-bit registers\" { m32c-*-* } { \"*\" } { \"\" } } */\n /* { dg-skip-if \"Not enough 64-bit registers\" { pdp11-*-* } { \"-O0\" } { \"\" } } */\n-/* { dg-xfail-if \"\" { m6811-*-* m6812-*-* h8300-*-* } { \"*\" } { \"\" } } */\n+/* { dg-xfail-if \"\" { h8300-*-* } { \"*\" } { \"\" } } */\n \n /* Copyright (C) 2000, 2003 Free Software Foundation */\n __complex__ long long f ()"}, {"sha": "d25d2f0f10256d70361d867313e8678e1778f619", "filename": "gcc/testsuite/gcc.c-torture/compile/20001205-1.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20001205-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20001205-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20001205-1.c?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,7 +1,4 @@\n-/* This does not work on m68hc11 due to the asm statement which forces\n-   two 'long' (32-bits) variables to go in registers.  */\n /* { dg-do assemble } */\n-/* { dg-xfail-if \"\" { m6811-*-* m6812-*-* } { \"*\" } { \"\" } } */\n \n static inline unsigned long rdfpcr(void)\n {"}, {"sha": "127c4daec45a6fceaa90b11c6de3959d8c5fc1eb", "filename": "gcc/testsuite/gcc.c-torture/compile/20001226-1.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20001226-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20001226-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20001226-1.c?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,7 +1,4 @@\n-/* This does not assemble on m68hc11 because the function is larger\n-   than 64K.  */\n /* { dg-do assemble } */\n-/* { dg-xfail-if \"function larger than 64K\" { m6811-*-* } { \"*\" } { \"\" } } */\n /* { dg-skip-if \"too much code for avr\" { \"avr-*-*\" } { \"*\" } { \"\" } } */\n /* { dg-skip-if \"too much code for pdp11\" { \"pdp11-*-*\" } { \"*\" } { \"\" } } */\n /* { dg-xfail-if \"jump beyond 128K not supported\" { xtensa*-*-* } { \"-O0\" } { \"\" } } */"}, {"sha": "9ff50474223acf7337ef3963f9888cd95da65eba", "filename": "gcc/testsuite/gcc.c-torture/compile/20010518-2.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20010518-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20010518-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20010518-2.c?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,10 +1,5 @@\n /* { dg-do compile } */\n \n-/* This test fails on HC11/HC12 when it is compiled without -mshort because \n-   the array is too large (INT_MAX/2 > 64K).  Force to use 16-bit ints\n-   for it.  */\n-/* { dg-options \"-w -mshort\" { target m6811-*-* m6812-*-* } } */\n-\n /* Large static storage.  */\n \n #include <limits.h>"}, {"sha": "bac5c6a53c137020db9eaf5b69bc54096767e76f", "filename": "gcc/testsuite/gcc.c-torture/compile/20020312-1.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20020312-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20020312-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20020312-1.c?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,7 +1,4 @@\n-/* This does not compile on HC11/HC12 due to the asm which requires\n-   two 32-bit registers.  */\n /* { dg-do assemble } */\n-/* { dg-xfail-if \"\" { m6811-*-* m6812-*-* } { \"*\" } { \"\" } } */\n /* { dg-skip-if \"\" { pdp11-*-* } { \"-O0\" } { \"\" } } */\n \n /* PR optimization/5892 */"}, {"sha": "9486583e973e024310b7bdd7a26e80a70185c66d", "filename": "gcc/testsuite/gcc.c-torture/compile/20020604-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20020604-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20020604-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20020604-1.c?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,5 +1,4 @@\n /* { dg-do assemble } */\n-/* { dg-xfail-if \"The array is too big\" { \"m6811-*-* m6812-*-*\" } { \"*\" } { \"\" } } */\n /* { dg-skip-if \"The array is too big\" { \"avr-*-*\" \"pdp11-*-*\" } { \"*\" } { \"\" } } */ \n /* { dg-xfail-if \"The array too big\" { \"h8300-*-*\" } { \"-mno-h\" \"-mn\" } { \"\" } } */\n /* { dg-skip-if \"\" { m32c-*-* } { } { } } */"}, {"sha": "383c7182df26da539c8c4e40f5f848b686db70fc", "filename": "gcc/testsuite/gcc.c-torture/compile/920501-12.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F920501-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F920501-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F920501-12.c?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,7 +1,4 @@\n-/* This test fails on HC11/HC12 when it is compiled without -mshort because \n-   the stack arrays are too large.  Force to use 16-bit ints for it.  */\n /* { dg-do assemble } */\n-/* { dg-xfail-if \"\" { m6811-*-* m6812-*-* } { \"*\" } { \"-mshort\" } } */\n \n x(x){            return 3 + x;}\n a(x){int y[994]; return 3 + x;}"}, {"sha": "48314cc78987980af2ea79b322530124dba9f6ca", "filename": "gcc/testsuite/gcc.c-torture/compile/920501-4.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F920501-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F920501-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F920501-4.c?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,7 +1,4 @@\n-/* This test fails on HC11/HC12 when it is compiled without -mshort because \n-   the 'r0' array is too large.  Force to use 16-bit ints for it.  */\n /* { dg-do assemble } */\n-/* { dg-xfail-if \"\" { m6811-*-* m6812-*-* } { \"*\" } { \"-mshort\" } } */\n \n foo ()\n {"}, {"sha": "7dce4118519a3f5a9baa79b89f4d2f18032e531e", "filename": "gcc/testsuite/gcc.c-torture/compile/920520-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F920520-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F920520-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F920520-1.c?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,5 +1,4 @@\n /* { dg-do compile } */\n-/* { dg-xfail-if \"\" { m6811-*-* m6812-*-* } { \"*\" } { \"\" } } */\n /* { dg-skip-if \"\" { pdp11-*-* } { \"*\" } { \"\" } } */\n \n f(){asm(\"%0\"::\"r\"(1.5F));}g(){asm(\"%0\"::\"r\"(1.5));}"}, {"sha": "0f46e17e5cbbbc7a4b8b6eea86934e2118263597", "filename": "gcc/testsuite/gcc.c-torture/compile/980506-1.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F980506-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F980506-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F980506-1.c?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,7 +1,6 @@\n /* The arrays are too large for the xstormy16 - won't fit in 16 bits. */\n /* { dg-do assemble } */\n /* { dg-require-effective-target size32plus } */\n-/* { dg-xfail-if \"The array too big\" { m6811-*-* m6812-*-* } { \"*\" } { \"\" } } /*\n /* { dg-skip-if \"Array too big\" { \"avr-*-*\" } { \"*\" } { \"\" } } */ \n /* { dg-xfail-if \"The array too big\" { h8300-*-* } { \"-mno-h\" \"-mn\" } { \"\" } } */\n "}, {"sha": "f675fb66d132c5d43538f338922c030cfcdb85bb", "filename": "gcc/testsuite/gcc.c-torture/execute/920501-8.x", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F920501-8.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F920501-8.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F920501-8.x?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,5 +0,0 @@\n-# sprintf() does not support %f on m6811/m6812 target.\n-if { [istarget \"m6811-*-*\"] || [istarget \"m6812-*-*\"]} {\n-\treturn 1\n-}\n-return 0"}, {"sha": "f675fb66d132c5d43538f338922c030cfcdb85bb", "filename": "gcc/testsuite/gcc.c-torture/execute/930513-1.x", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F930513-1.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F930513-1.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F930513-1.x?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,5 +0,0 @@\n-# sprintf() does not support %f on m6811/m6812 target.\n-if { [istarget \"m6811-*-*\"] || [istarget \"m6812-*-*\"]} {\n-\treturn 1\n-}\n-return 0"}, {"sha": "ed4bac4106621c177e35004c41f5dfe7e6de99c0", "filename": "gcc/testsuite/gcc.c-torture/execute/960312-1.x", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F960312-1.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/999a7d80b587700fc74639d0da5849c4f2eb31db/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F960312-1.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F960312-1.x?ref=999a7d80b587700fc74639d0da5849c4f2eb31db", "patch": "@@ -1,7 +0,0 @@\n-# This test fails on HC11/HC12 when it is compiled without -mshort because \n-# is uses an asm that requires two 32-bit registers (int).  It passes\n-# when using -mshort because there are enough registers;  force -mshort.\n-if { [istarget \"m6811-*-*\"] || [istarget \"m6812-*-*\"] } {\n-\tset options \"-mshort\"\n-}\n-return 0"}, {"sha": "937215ba507b0829b8fe925a81a2e0bbbaaad109", "filename": "gcc/testsuite/gcc.c-torture/execute/980709-1.x", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F980709-1.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F980709-1.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F980709-1.x?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,7 +1,3 @@\n-# pow() is not available on m6811/m6812 target, this test will not link.\n-if { [istarget \"m6811-*-*\"] || [istarget \"m6812-*-*\"]} {\n-\treturn 1\n-}\n # XFAIL this test for AIX using -msoft-float.\n # This test calls the system libm.a function pow.\n # A false failure is reported if -msoft-float is used."}, {"sha": "1785309a7b0c7216e5c7ca5aa33c149c1f64f953", "filename": "gcc/testsuite/gcc.c-torture/execute/990826-0.x", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F990826-0.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F990826-0.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F990826-0.x?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,7 +1,3 @@\n-# floor() is not available on m6811/m6812 target, this test will not link.\n-if { [istarget \"m6811-*-*\"] || [istarget \"m6812-*-*\"]} {\n-\treturn 1\n-}\n # XFAIL this test for AIX using -msoft-float.\n # This test calls the system libm.a function floor.\n # A false failure is reported if -msoft-float is used."}, {"sha": "ff53946c6ce689a1e710c542a0bf50aca2ec799c", "filename": "gcc/testsuite/gcc.dg/cpp/assert4.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fassert4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fassert4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fassert4.c?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -139,14 +139,6 @@\n \n /* Check for #cpu and #machine assertions.  */\n \n-#if defined __arc__\n-# if !#cpu(arc) || !#machine(arc)\n-#  error\n-# endif\n-#elif #cpu(arc) || #machine(arc)\n-# error\n-#endif\n-\n #if defined __alpha__\n # if !#cpu(alpha) || !#machine(alpha) \\\n \t|| (defined __alpha_cix__ && !#cpu(cix)) \\"}, {"sha": "a844aade95ffac03ec2256e7b4881d29ecfdadc5", "filename": "gcc/testsuite/gcc.dg/sibcall-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-3.c?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -5,7 +5,7 @@\n    Copyright (C) 2002 Free Software Foundation Inc.\n    Contributed by Hans-Peter Nilsson  <hp@bitrange.com>  */\n \n-/* { dg-do run { xfail { { arc-*-* avr-*-* cris-*-* crisv32-*-* h8300-*-* hppa*64*-*-* m32r-*-* m68hc1?-*-* mcore-*-* mn10300-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa*-*-* } || { arm*-*-* && { ! arm32 } } } } } */\n+/* { dg-do run { xfail { { avr-*-* cris-*-* crisv32-*-* h8300-*-* hppa*64*-*-* m32r-*-* mcore-*-* mn10300-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa*-*-* } || { arm*-*-* && { ! arm32 } } } } } */\n /* -mlongcall disables sibcall patterns.  */\n /* { dg-skip-if \"\" { powerpc*-*-* } { \"-mlongcall\" } { \"\" } } */\n /* { dg-options \"-O2 -foptimize-sibling-calls\" } */"}, {"sha": "20adecccf95c008c15543155a12be567af6faad2", "filename": "gcc/testsuite/gcc.dg/sibcall-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsibcall-4.c?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -5,7 +5,7 @@\n    Copyright (C) 2002 Free Software Foundation Inc.\n    Contributed by Hans-Peter Nilsson  <hp@bitrange.com>  */\n \n-/* { dg-do run { xfail { { arc-*-* avr-*-* cris-*-* crisv32-*-* h8300-*-* hppa*64*-*-* m32r-*-* m68hc1?-*-* mcore-*-* mn10300-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa*-*-* } || { arm*-*-* && { ! arm32 } } } } } */\n+/* { dg-do run { xfail { { avr-*-* cris-*-* crisv32-*-* h8300-*-* hppa*64*-*-* m32r-*-* mcore-*-* mn10300-*-* xstormy16-*-* v850*-*-* vax-*-* xtensa*-*-* } || { arm*-*-* && { ! arm32 } } } } } */\n /* -mlongcall disables sibcall patterns.  */\n /* { dg-skip-if \"\" { powerpc*-*-* } { \"-mlongcall\" } { \"\" } } */\n /* { dg-options \"-O2 -foptimize-sibling-calls\" } */"}, {"sha": "0892085c05f24fd452cdbd9164625b91ca3f6190", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,3 +1,12 @@\n+2011-03-22  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* config.host (alpha*-*-gnu*, arc-*-elf*, arm*-*-netbsd*,\n+\tarm-*-pe*, crx-*-elf, i[34567]86-*-netbsd*, i[34567]86-*-pe,\n+\tm68hc11-*-*|m6811-*-*, m68hc12-*-*|m6812-*-*, mcore-*-pe*,\n+\tpowerpc64-*-gnu*, powerpc-*-gnu-gnualtivec*, powerpc-*-gnu*,\n+\tsh-*-symbianelf* | sh[12346l]*-*-symbianelf*, vax-*-netbsd*):\n+\tRemove cases.\n+\n 2011-03-14  Andreas Tobler  <andreast@fgznet.ch>\n \n \t* config.host (cpu_type): Add FreeBSD PowerPC specific parts."}, {"sha": "e3c48bb7f46c00973fd67d569251681a6376c564", "filename": "libgcc/config.host", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -182,7 +182,7 @@ case ${host} in\n \tthen tmake_file=${cpu_type}/t-$rest\n \tfi\n \t;;\n-alpha*-*-linux* | alpha*-*-gnu*)\n+alpha*-*-linux*)\n \ttmake_file=\"${tmake_file} alpha/t-crtfm\"\n \textra_parts=\"$extra_parts crtfastmath.o\"\n \t;;\n@@ -200,16 +200,12 @@ alpha64-dec-*vms*)\n alpha*-dec-*vms*)\n \ttmake_file=\"vms/t-vms alpha/t-vms\"\n \t;;\n-arc-*-elf*)\n-\t;;\n arm-wrs-vxworks)\n \t;;\n arm*-*-freebsd*)\n \t;;\n arm*-*-netbsdelf*)\n \t;;\n-arm*-*-netbsd*)\n-\t;;\n arm*-*-linux*)\t\t\t# ARM GNU/Linux with ELF\n \t;;\n arm*-*-uclinux*)\t\t# ARM ucLinux\n@@ -224,8 +220,6 @@ arm*-*-elf)\n \t;;\n arm*-wince-pe*)\n \t;;\n-arm-*-pe*)\n-\t;;\n avr-*-rtems*)\n \t;;\n avr-*-*)\n@@ -248,8 +242,6 @@ crisv32-*-elf | crisv32-*-none | cris-*-elf | cris-*-none)\n \t;;\n cris-*-linux* | crisv32-*-linux*)\n \t;;\n-crx-*-elf)\n-\t;;\n fido-*-elf)\n \t;;\n fr30-*-elf)\n@@ -289,8 +281,6 @@ x86_64-*-freebsd*)\n \t;;\n i[34567]86-*-netbsdelf*)\n \t;;\n-i[34567]86-*-netbsd*)\n-\t;;\n x86_64-*-netbsd*)\n \t;;\n i[34567]86-*-openbsd2.*|i[34567]86-*openbsd3.[0123])\n@@ -335,8 +325,6 @@ i[34567]86-*-solaris2*)\n \t;;\n i[4567]86-wrs-vxworks|i[4567]86-wrs-vxworksae)\n \t;;\n-i[34567]86-*-pe)\n-\t;;\n i[34567]86-*-cygwin* | i[34567]86-*-mingw*)\n \textra_parts=\"crtbegin.o crtend.o crtfastmath.o\"\n \ttmake_file=\"i386/t-cygming i386/t-crtfm\"\n@@ -380,10 +368,6 @@ m32r-*-linux*)\n  \t;;\n m32rle-*-linux*)\n \t;;\n-m68hc11-*-*|m6811-*-*)\n-        ;;\n-m68hc12-*-*|m6812-*-*)\n-        ;;\n m68k-*-elf*)\n \t;;\n m68k*-*-netbsdelf*)\n@@ -400,8 +384,6 @@ m68k-*-rtems*)\n \t;;\n mcore-*-elf)\n \t;;\n-mcore-*-pe*)\n-\t;;\n microblaze*-*-*)\n         tmake_file=\"microblaze/t-microblaze\"\n \t;;\n@@ -487,15 +469,6 @@ powerpc-*-rtems*)\n powerpc-*-linux* | powerpc64-*-linux*)\n \ttmake_file=\"${tmake_file} rs6000/t-ppccomm rs6000/t-ldbl128 t-softfp\"\n \t;;\n-powerpc64-*-gnu*)\n-\ttmake_file=\"${tmake_file} rs6000/t-ldbl128 t-softfp\"\n-\t;;\n-powerpc-*-gnu-gnualtivec*)\n-\ttmake_file=\"${tmake_file} rs6000/t-ldbl128\"\n-\t;;\n-powerpc-*-gnu*)\n-\ttmake_file=\"${tmake_file} rs6000/t-ldbl128\"\n-\t;;\n powerpc-wrs-vxworks|powerpc-wrs-vxworksae)\n \t;;\n powerpc-*-lynxos*)\n@@ -528,7 +501,6 @@ s390x-ibm-tpf*)\n score-*-elf)\n         ;;\n sh-*-elf* | sh[12346l]*-*-elf* | \\\n-sh-*-symbianelf* | sh[12346l]*-*-symbianelf* | \\\n   sh-*-linux* | sh[2346lbe]*-*-linux* | \\\n   sh-*-netbsdelf* | shl*-*-netbsdelf* | sh5-*-netbsd* | sh5l*-*-netbsd* | \\\n    sh64-*-netbsd* | sh64l*-*-netbsd*)\n@@ -582,8 +554,6 @@ vax-*-linux*)\n \t;;\n vax-*-netbsdelf*)\n \t;;\n-vax-*-netbsd*)\n-\t;;\n vax-*-openbsd*)\n \t;;\n xstormy16-*-elf)"}, {"sha": "a60f6ff38940be54abb6abdb2a19b3abd0eb84d9", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -1,3 +1,8 @@\n+2011-03-22  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* configure.ac: Don't handle powerpc*-*-gnu*.\n+\t* configure: Regenerate.\n+\n 2011-03-22  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* testsuite/21_strings/basic_string/cons/char/moveable2.cc: Tweak"}, {"sha": "fa6a1a5ccf7e619445ecf40b7d30ab990813a334", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -64486,7 +64486,6 @@ $as_echo \"$as_me: visibility supported: $enable_visibility\" >&6;}\n ac_ldbl_compat=no\n case \"$target\" in\n   powerpc*-*-linux* | \\\n-  powerpc*-*-gnu* | \\\n   sparc*-*-linux* | \\\n   s390*-*-linux* | \\\n   alpha*-*-linux*)"}, {"sha": "1a1964e0ff10519a8c62cb0792d6261aa661297e", "filename": "libstdc++-v3/configure.ac", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/libstdc%2B%2B-v3%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebb9f8b03b553a7818879bec1ff542e4ede4fd43/libstdc%2B%2B-v3%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure.ac?ref=ebb9f8b03b553a7818879bec1ff542e4ede4fd43", "patch": "@@ -308,7 +308,6 @@ GLIBCXX_ENABLE_VISIBILITY([yes])\n ac_ldbl_compat=no\n case \"$target\" in\n   powerpc*-*-linux* | \\\n-  powerpc*-*-gnu* | \\\n   sparc*-*-linux* | \\\n   s390*-*-linux* | \\\n   alpha*-*-linux*)"}]}