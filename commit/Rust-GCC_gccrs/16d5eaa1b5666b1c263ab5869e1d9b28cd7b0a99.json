{"sha": "16d5eaa1b5666b1c263ab5869e1d9b28cd7b0a99", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZkNWVhYTFiNTY2NmIxYzI2M2FiNTg2OWUxZDliMjhjZDdiMGE5OQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2014-11-24T19:27:29Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2014-11-24T19:27:29Z"}, "message": "re PR target/63965 (ICE: in extract_constrain_insn, at recog.c:2230 on ppc64)\n\n2014-11-24  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/63965\n\t* config/rs6000/rs6000.c (rs6000_setup_reg_addr_masks): Do not set\n\tAltivec & -16 mask if the type is not valid for Altivec registers.\n\t(rs6000_secondary_reload_memory): Add support for ((reg + const) +\n\treg) that occurs during push_reload processing.\n\n\t* config/rs6000/altivec.md (altivec_mov<mode>): Add instruction\n\talternative for moving constant vectors which are easy altivec\n\tconstants to GPRs.  Set the length attribute each of the\n\talternatives.\n\nFrom-SVN: r218028", "tree": {"sha": "384cef1786a5d77f6b717004f291f36372ad041c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/384cef1786a5d77f6b717004f291f36372ad041c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16d5eaa1b5666b1c263ab5869e1d9b28cd7b0a99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16d5eaa1b5666b1c263ab5869e1d9b28cd7b0a99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16d5eaa1b5666b1c263ab5869e1d9b28cd7b0a99", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16d5eaa1b5666b1c263ab5869e1d9b28cd7b0a99/comments", "author": null, "committer": null, "parents": [{"sha": "22186565977181492c37750e44571a54363d2624", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22186565977181492c37750e44571a54363d2624", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22186565977181492c37750e44571a54363d2624"}], "stats": {"total": 32, "additions": 28, "deletions": 4}, "files": [{"sha": "5db7497608b12f80a6059bb202cd54f0df3ff949", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d5eaa1b5666b1c263ab5869e1d9b28cd7b0a99/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d5eaa1b5666b1c263ab5869e1d9b28cd7b0a99/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=16d5eaa1b5666b1c263ab5869e1d9b28cd7b0a99", "patch": "@@ -1,6 +1,16 @@\n 2014-11-24  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/63965\n+\t* config/rs6000/rs6000.c (rs6000_setup_reg_addr_masks): Do not set\n+\tAltivec & -16 mask if the type is not valid for Altivec registers.\n+\t(rs6000_secondary_reload_memory): Add support for ((reg + const) +\n+\treg) that occurs during push_reload processing.\n+\n+\t* config/rs6000/altivec.md (altivec_mov<mode>): Add instruction\n+\talternative for moving constant vectors which are easy altivec\n+\tconstants to GPRs.  Set the length attribute each of the\n+\talternatives.\n+\n \t* config/rs6000/rs6000-cpus.def: Undo November 21st changes, a\n \twork in progress patch was committed instead of the fixes for\n \t63965."}, {"sha": "3f52ca0c585e8b4b8de89c643a74f97d3182022a", "filename": "gcc/config/rs6000/altivec.md", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d5eaa1b5666b1c263ab5869e1d9b28cd7b0a99/gcc%2Fconfig%2Frs6000%2Faltivec.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d5eaa1b5666b1c263ab5869e1d9b28cd7b0a99/gcc%2Fconfig%2Frs6000%2Faltivec.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.md?ref=16d5eaa1b5666b1c263ab5869e1d9b28cd7b0a99", "patch": "@@ -189,8 +189,8 @@\n \n ;; Vector move instructions.\n (define_insn \"*altivec_mov<mode>\"\n-  [(set (match_operand:VM2 0 \"nonimmediate_operand\" \"=Z,v,v,*Y,*r,*r,v,v\")\n-\t(match_operand:VM2 1 \"input_operand\" \"v,Z,v,r,Y,r,j,W\"))]\n+  [(set (match_operand:VM2 0 \"nonimmediate_operand\" \"=Z,v,v,*Y,*r,*r,v,v,*r\")\n+\t(match_operand:VM2 1 \"input_operand\" \"v,Z,v,r,Y,r,j,W,W\"))]\n   \"VECTOR_MEM_ALTIVEC_P (<MODE>mode)\n    && (register_operand (operands[0], <MODE>mode) \n        || register_operand (operands[1], <MODE>mode))\"\n@@ -205,10 +205,12 @@\n     case 5: return \"#\";\n     case 6: return \"vxor %0,%0,%0\";\n     case 7: return output_vec_const_move (operands);\n+    case 8: return \"#\";\n     default: gcc_unreachable ();\n     }\n }\n-  [(set_attr \"type\" \"vecstore,vecload,vecsimple,store,load,*,vecsimple,*\")])\n+  [(set_attr \"type\" \"vecstore,vecload,vecsimple,store,load,*,vecsimple,*,*\")\n+   (set_attr \"length\" \"4,4,4,20,20,20,4,8,32\")])\n \n ;; Unlike other altivec moves, allow the GPRs, since a normal use of TImode\n ;; is for unions.  However for plain data movement, slightly favor the vector"}, {"sha": "a87e762e56de583d703134e8cfc4404d6ae70d70", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d5eaa1b5666b1c263ab5869e1d9b28cd7b0a99/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d5eaa1b5666b1c263ab5869e1d9b28cd7b0a99/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=16d5eaa1b5666b1c263ab5869e1d9b28cd7b0a99", "patch": "@@ -2505,7 +2505,8 @@ rs6000_setup_reg_addr_masks (void)\n \n \t  /* VMX registers can do (REG & -16) and ((REG+REG) & -16)\n \t     addressing on 128-bit types.  */\n-\t  if (rc == RELOAD_REG_VMX && GET_MODE_SIZE (m2) == 16)\n+\t  if (rc == RELOAD_REG_VMX && GET_MODE_SIZE (m2) == 16\n+\t      && (addr_mask & RELOAD_REG_VALID) != 0)\n \t    addr_mask |= RELOAD_REG_AND_M16;\n \n \t  reg_addr[m].addr_mask[rc] = addr_mask;\n@@ -16652,6 +16653,17 @@ rs6000_secondary_reload_memory (rtx addr,\n \t    }\n \t}\n \n+      /* (plus (plus (reg) (constant)) (reg)) is also generated during\n+\t push_reload processing, so handle it now.  */\n+      else if (GET_CODE (plus_arg0) == PLUS && REG_P (plus_arg1))\n+\t{\n+\t  if ((addr_mask & RELOAD_REG_INDEXED) == 0)\n+\t    {\n+\t      extra_cost = 1;\n+\t      type = \"indexed #2\";\n+\t    }\n+\t}\n+\n       else if (!base_reg_operand (plus_arg0, GET_MODE (plus_arg0)))\n \t{\n \t  fail_msg = \"no base register #2\";"}]}