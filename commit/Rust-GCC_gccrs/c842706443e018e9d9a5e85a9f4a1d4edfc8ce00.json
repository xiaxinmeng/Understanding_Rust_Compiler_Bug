{"sha": "c842706443e018e9d9a5e85a9f4a1d4edfc8ce00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg0MjcwNjQ0M2UwMThlOWQ5YTVlODVhOWY0YTFkNGVkZmM4Y2UwMA==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2009-12-07T14:28:22Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2009-12-07T14:28:22Z"}, "message": "i386.md (any_or): New code iterator.\n\n\t* config/i386/i386.md (any_or): New code iterator.\n\t(any_logic): Rename from plogic code iterator.\n\t(logicprefix): Rename from plogicprefix code attribute.\n\t(<code><mode>3): Macroize expander from {ior,xor}<mode>3 using\n\tany_or code iterator.\n\t(*<code><mode>_1): Macroize insn from *{ior,xor}<mode>_1 using\n\tany_or code iterator.\n\t(*<code><mode>_2): Ditto from *{ior,xor}<mode>_2.\n\t(*<code><mode>_3): Ditto from *{ior,xor}<mode>_3.\n\t(ior and xor splitters): Ditto.\n\t* config/i386/mmx.md: Updated for rename.\n\t* config/i386/sse.md: Ditto.\n\nFrom-SVN: r155037", "tree": {"sha": "b080416b680cb2cbe6de0110f43bdf9c7cac4083", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b080416b680cb2cbe6de0110f43bdf9c7cac4083"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c842706443e018e9d9a5e85a9f4a1d4edfc8ce00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c842706443e018e9d9a5e85a9f4a1d4edfc8ce00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c842706443e018e9d9a5e85a9f4a1d4edfc8ce00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c842706443e018e9d9a5e85a9f4a1d4edfc8ce00/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "53567bbdcabd98fa6776b3ed2e5b5b19b35a417d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53567bbdcabd98fa6776b3ed2e5b5b19b35a417d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53567bbdcabd98fa6776b3ed2e5b5b19b35a417d"}], "stats": {"total": 493, "additions": 130, "deletions": 363}, "files": [{"sha": "abc64a75c0344bdb4f83b009bbb9514c01dbce20", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c842706443e018e9d9a5e85a9f4a1d4edfc8ce00/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c842706443e018e9d9a5e85a9f4a1d4edfc8ce00/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c842706443e018e9d9a5e85a9f4a1d4edfc8ce00", "patch": "@@ -1,3 +1,18 @@\n+2009-12-07  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* config/i386/i386.md (any_or): New code iterator.\n+\t(any_logic): Rename from plogic code iterator.\n+\t(logicprefix): Rename from plogicprefix code attribute.\n+\t(<code><mode>3): Macroize expander from {ior,xor}<mode>3 using\n+\tany_or code iterator.\n+\t(*<code><mode>_1): Macroize insn from *{ior,xor}<mode>_1 using\n+\tany_or code iterator.\n+\t(*<code><mode>_2): Ditto from *{ior,xor}<mode>_2.\n+\t(*<code><mode>_3): Ditto from *{ior,xor}<mode>_3.\n+\t(ior and xor splitters): Ditto.\n+\t* config/i386/mmx.md: Updated for rename.\n+\t* config/i386/sse.md: Ditto.\n+\n 2009-12-07  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (float<SSEMODEI24:mode><X87MODEF:mode>2):\n@@ -15,7 +30,7 @@\n \n 2009-12-06  Uros Bizjak  <ubizjak@gmail.com>\n \n-\t* config/i386/i386-md (g): Add HImode and QImode.\n+\t* config/i386/i386.md (g): Add HImode and QImode.\n \t(general_szext_operand): New mode attribute.\n \t(*test<mode>_1): Macroize insn from *test{qi,hi,si}_1 using\n \tSWI124 mode iterator."}, {"sha": "a4e688a8d1423a432a47b73784663a5cb9aaa539", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 89, "deletions": 337, "changes": 426, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c842706443e018e9d9a5e85a9f4a1d4edfc8ce00/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c842706443e018e9d9a5e85a9f4a1d4edfc8ce00/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=c842706443e018e9d9a5e85a9f4a1d4edfc8ce00", "patch": "@@ -677,11 +677,11 @@\n    (set_attr \"type\" \"multi\")])\n \n ;; All integer comparison codes.\n-(define_code_iterator int_cond [ne eq ge gt le lt geu gtu leu ltu ])\n+(define_code_iterator int_cond [ne eq ge gt le lt geu gtu leu ltu])\n \n ;; All floating-point comparison codes.\n (define_code_iterator fp_cond [unordered ordered\n-\t\t\t       uneq unge ungt unle unlt ltgt ])\n+\t\t\t       uneq unge ungt unle unlt ltgt])\n \n (define_code_iterator plusminus [plus minus])\n \n@@ -718,10 +718,13 @@\n (define_code_attr maxminfprefix [(smax \"max\") (smin \"min\")])\n \n ;; Mapping of parallel logic operators\n-(define_code_iterator plogic [and ior xor])\n+(define_code_iterator any_logic [and ior xor])\n+\n+;; Mapping of parallel logic operators\n+(define_code_iterator any_or [ior xor])\n \n ;; Base name for insn mnemonic.\n-(define_code_attr plogicprefix [(and \"and\") (ior \"or\") (xor \"xor\")])\n+(define_code_attr logicprefix [(and \"and\") (ior \"or\") (xor \"xor\")])\n \n ;; Mapping of abs neg operators\n (define_code_iterator absneg [abs neg])\n@@ -732,14 +735,14 @@\n ;; Used in signed and unsigned widening multiplications.\n (define_code_iterator any_extend [sign_extend zero_extend])\n \n-;; Used in signed and unsigned divisions.\n-(define_code_iterator any_div [div udiv])\n-\n ;; Various insn prefixes for signed and unsigned operations.\n (define_code_attr u [(sign_extend \"\") (zero_extend \"u\")\n \t\t     (div \"\") (udiv \"u\")])\n (define_code_attr s [(sign_extend \"s\") (zero_extend \"u\")])\n \n+;; Used in signed and unsigned divisions.\n+(define_code_iterator any_div [div udiv])\n+\n ;; Instruction prefix for signed and unsigned operations.\n (define_code_attr sgnprefix [(sign_extend \"i\") (zero_extend \"\")\n \t\t\t     (div \"i\") (udiv \"\")])\n@@ -8859,168 +8862,170 @@\n    operands[1] = gen_lowpart (QImode, operands[1]);\n    operands[2] = gen_lowpart (QImode, operands[2]);\")\n \f\n-;; Logical inclusive OR instructions\n+;; Logical inclusive and exclusive OR instructions\n \n ;; %%% This used to optimize known byte-wide and operations to memory.\n ;; If this is considered useful, it should be done with splitters.\n \n-(define_expand \"ior<mode>3\"\n+(define_expand \"<code><mode>3\"\n   [(set (match_operand:SWIM 0 \"nonimmediate_operand\" \"\")\n-\t(ior:SWIM (match_operand:SWIM 1 \"nonimmediate_operand\" \"\")\n-\t\t  (match_operand:SWIM 2 \"<general_operand>\" \"\")))]\n+\t(any_or:SWIM (match_operand:SWIM 1 \"nonimmediate_operand\" \"\")\n+\t\t     (match_operand:SWIM 2 \"<general_operand>\" \"\")))]\n   \"\"\n-  \"ix86_expand_binary_operator (IOR, <MODE>mode, operands); DONE;\")\n+  \"ix86_expand_binary_operator (<CODE>, <MODE>mode, operands); DONE;\")\n \n-(define_insn \"*ior<mode>_1\"\n+(define_insn \"*<code><mode>_1\"\n   [(set (match_operand:SWI248 0 \"nonimmediate_operand\" \"=r,rm\")\n-\t(ior:SWI248 (match_operand:SWI248 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t    (match_operand:SWI248 2 \"<general_operand>\" \"<g>,r<i>\")))\n+\t(any_or:SWI248\n+\t (match_operand:SWI248 1 \"nonimmediate_operand\" \"%0,0\")\n+\t (match_operand:SWI248 2 \"<general_operand>\" \"<g>,r<i>\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (IOR, <MODE>mode, operands)\"\n-  \"or{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+  \"ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n+  \"<logicprefix>{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n ;; %%% Potential partial reg stall on alternative 2.  What to do?\n-(define_insn \"*iorqi_1\"\n+(define_insn \"*<code>qi_1\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,m,r\")\n-\t(ior:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"qmn,qn,rn\")))\n+\t(any_or:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n+\t\t   (match_operand:QI 2 \"general_operand\" \"qmn,qn,rn\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (IOR, QImode, operands)\"\n+  \"ix86_binary_operator_ok (<CODE>, QImode, operands)\"\n   \"@\n-   or{b}\\t{%2, %0|%0, %2}\n-   or{b}\\t{%2, %0|%0, %2}\n-   or{l}\\t{%k2, %k0|%k0, %k2}\"\n+   <logicprefix>{b}\\t{%2, %0|%0, %2}\n+   <logicprefix>{b}\\t{%2, %0|%0, %2}\n+   <logicprefix>{l}\\t{%k2, %k0|%k0, %k2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"QI,QI,SI\")])\n \n ;; See comment for addsi_1_zext why we do use nonimmediate_operand\n-(define_insn \"*iorsi_1_zext\"\n+(define_insn \"*<code>si_1_zext\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extend:DI\n-\t  (ior:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t  (match_operand:SI 2 \"general_operand\" \"g\"))))\n+\t (any_or:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t    (match_operand:SI 2 \"general_operand\" \"g\"))))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && ix86_binary_operator_ok (IOR, SImode, operands)\"\n-  \"or{l}\\t{%2, %k0|%k0, %2}\"\n+  \"TARGET_64BIT && ix86_binary_operator_ok (<CODE>, SImode, operands)\"\n+  \"<logicprefix>{l}\\t{%2, %k0|%k0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*iorsi_1_zext_imm\"\n+(define_insn \"*<code>si_1_zext_imm\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(ior:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%0\"))\n-\t\t(match_operand:DI 2 \"x86_64_zext_immediate_operand\" \"Z\")))\n+\t(any_or:DI\n+\t (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%0\"))\n+\t (match_operand:DI 2 \"x86_64_zext_immediate_operand\" \"Z\")))\n    (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && ix86_binary_operator_ok (IOR, SImode, operands)\"\n-  \"or{l}\\t{%2, %k0|%k0, %2}\"\n+  \"TARGET_64BIT && ix86_binary_operator_ok (<CODE>, SImode, operands)\"\n+  \"<logicprefix>{l}\\t{%2, %k0|%k0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*iorqi_1_slp\"\n+(define_insn \"*<code>qi_1_slp\"\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+q,m\"))\n-\t(ior:QI (match_dup 0)\n-\t\t(match_operand:QI 1 \"general_operand\" \"qmn,qn\")))\n+\t(any_or:QI (match_dup 0)\n+\t\t   (match_operand:QI 1 \"general_operand\" \"qmn,qn\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n    && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"or{b}\\t{%1, %0|%0, %1}\"\n+  \"<logicprefix>{b}\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"alu1\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"*ior<mode>_2\"\n+(define_insn \"*<code><mode>_2\"\n   [(set (reg FLAGS_REG)\n-\t(compare (ior:SWI\n+\t(compare (any_or:SWI\n \t\t  (match_operand:SWI 1 \"nonimmediate_operand\" \"%0,0\")\n \t\t  (match_operand:SWI 2 \"<general_operand>\" \"<g>,<r><i>\"))\n \t\t (const_int 0)))\n    (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>,<r>m\")\n-\t(ior:SWI (match_dup 1) (match_dup 2)))]\n+\t(any_or:SWI (match_dup 1) (match_dup 2)))]\n   \"ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (IOR, <MODE>mode, operands)\"\n-  \"or{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+   && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n+  \"<logicprefix>{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n ;; See comment for addsi_1_zext why we do use nonimmediate_operand\n ;; ??? Special case for immediate operand is missing - it is tricky.\n-(define_insn \"*iorsi_2_zext\"\n+(define_insn \"*<code>si_2_zext\"\n   [(set (reg FLAGS_REG)\n-\t(compare (ior:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"g\"))\n+\t(compare (any_or:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n+\t\t\t    (match_operand:SI 2 \"general_operand\" \"g\"))\n \t\t (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI (ior:SI (match_dup 1) (match_dup 2))))]\n+\t(zero_extend:DI (any_or:SI (match_dup 1) (match_dup 2))))]\n   \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (IOR, SImode, operands)\"\n-  \"or{l}\\t{%2, %k0|%k0, %2}\"\n+   && ix86_binary_operator_ok (<CODE>, SImode, operands)\"\n+  \"<logicprefix>{l}\\t{%2, %k0|%k0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*iorsi_2_zext_imm\"\n+(define_insn \"*<code>si_2_zext_imm\"\n   [(set (reg FLAGS_REG)\n-\t(compare (ior:SI\n+\t(compare (any_or:SI\n \t\t  (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n \t\t  (match_operand:SI 2 \"x86_64_zext_immediate_operand\" \"Z\"))\n \t\t (const_int 0)))\n    (set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(ior:DI (zero_extend:DI (match_dup 1)) (match_dup 2)))]\n+\t(any_or:DI (zero_extend:DI (match_dup 1)) (match_dup 2)))]\n   \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (IOR, SImode, operands)\"\n-  \"or{l}\\t{%2, %k0|%k0, %2}\"\n+   && ix86_binary_operator_ok (<CODE>, SImode, operands)\"\n+  \"<logicprefix>{l}\\t{%2, %k0|%k0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"SI\")])\n \n-(define_insn \"*iorqi_2_slp\"\n+(define_insn \"*<code>qi_2_slp\"\n   [(set (reg FLAGS_REG)\n-\t(compare (ior:QI (match_operand:QI 0 \"nonimmediate_operand\" \"+q,qm\")\n-\t\t\t (match_operand:QI 1 \"general_operand\" \"qmn,qn\"))\n+\t(compare (any_or:QI (match_operand:QI 0 \"nonimmediate_operand\" \"+q,qm\")\n+\t\t\t    (match_operand:QI 1 \"general_operand\" \"qmn,qn\"))\n \t\t (const_int 0)))\n    (set (strict_low_part (match_dup 0))\n-\t(ior:QI (match_dup 0) (match_dup 1)))]\n+\t(any_or:QI (match_dup 0) (match_dup 1)))]\n   \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n    && ix86_match_ccmode (insn, CCNOmode)\n    && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"or{b}\\t{%1, %0|%0, %1}\"\n+  \"<logicprefix>{b}\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"alu1\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"*ior<mode>_3\"\n+(define_insn \"*<code><mode>_3\"\n   [(set (reg FLAGS_REG)\n-\t(compare (ior:SWI\n+\t(compare (any_or:SWI\n \t\t  (match_operand:SWI 1 \"nonimmediate_operand\" \"%0\")\n \t\t  (match_operand:SWI 2 \"<general_operand>\" \"<g>\"))\n \t\t (const_int 0)))\n    (clobber (match_scratch:SWI 0 \"=<r>\"))]\n   \"ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (IOR, <MODE>mode, operands)\"\n-  \"or{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n+   && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n+  \"<logicprefix>{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-(define_insn \"*iorqi_ext_0\"\n+(define_insn \"*<code>qi_ext_0\"\n   [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n-\t(ior:SI\n+\t(any_or:SI\n \t  (zero_extract:SI\n \t    (match_operand 1 \"ext_register_operand\" \"0\")\n \t    (const_int 8)\n \t    (const_int 8))\n \t  (match_operand 2 \"const_int_operand\" \"n\")))\n    (clobber (reg:CC FLAGS_REG))]\n   \"!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun)\"\n-  \"or{b}\\t{%2, %h0|%h0, %2}\"\n+  \"<logicprefix>{b}\\t{%2, %h0|%h0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"length_immediate\" \"1\")\n    (set_attr \"modrm\" \"1\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"*iorqi_ext_1_rex64\"\n+(define_insn \"*<code>qi_ext_1_rex64\"\n   [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n-\t(ior:SI\n+\t(any_or:SI\n \t  (zero_extract:SI\n \t    (match_operand 1 \"ext_register_operand\" \"0\")\n \t    (const_int 8)\n@@ -9030,16 +9035,16 @@\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT\n    && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\"\n-  \"or{b}\\t{%2, %h0|%h0, %2}\"\n+  \"<logicprefix>{b}\\t{%2, %h0|%h0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"length_immediate\" \"0\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"*iorqi_ext_1\"\n+(define_insn \"*<code>qi_ext_1\"\n   [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n-\t(ior:SI\n+\t(any_or:SI\n \t  (zero_extract:SI\n \t    (match_operand 1 \"ext_register_operand\" \"0\")\n \t    (const_int 8)\n@@ -9049,16 +9054,16 @@\n    (clobber (reg:CC FLAGS_REG))]\n   \"!TARGET_64BIT\n    && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\"\n-  \"or{b}\\t{%2, %h0|%h0, %2}\"\n+  \"<logicprefix>{b}\\t{%2, %h0|%h0, %2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"length_immediate\" \"0\")\n    (set_attr \"mode\" \"QI\")])\n \n-(define_insn \"*iorqi_ext_2\"\n+(define_insn \"*<code>qi_ext_2\"\n   [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n \t\t\t (const_int 8)\n \t\t\t (const_int 8))\n-\t(ior:SI\n+\t(any_or:SI\n \t  (zero_extract:SI (match_operand 1 \"ext_register_operand\" \"0\")\n \t  \t\t   (const_int 8)\n \t\t\t   (const_int 8))\n@@ -9067,25 +9072,25 @@\n \t\t\t   (const_int 8))))\n    (clobber (reg:CC FLAGS_REG))]\n   \"!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun)\"\n-  \"ior{b}\\t{%h2, %h0|%h0, %h2}\"\n+  \"<logicprefix>{b}\\t{%h2, %h0|%h0, %h2}\"\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"length_immediate\" \"0\")\n    (set_attr \"mode\" \"QI\")])\n \n (define_split\n   [(set (match_operand 0 \"register_operand\" \"\")\n-\t(ior (match_operand 1 \"register_operand\" \"\")\n-\t     (match_operand 2 \"const_int_operand\" \"\")))\n+\t(any_or (match_operand 1 \"register_operand\" \"\")\n+\t\t(match_operand 2 \"const_int_operand\" \"\")))\n    (clobber (reg:CC FLAGS_REG))]\n    \"reload_completed\n     && QI_REG_P (operands[0])\n     && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n     && !(INTVAL (operands[2]) & ~(255 << 8))\n     && GET_MODE (operands[0]) != QImode\"\n   [(parallel [(set (zero_extract:SI (match_dup 0) (const_int 8) (const_int 8))\n-\t\t   (ior:SI (zero_extract:SI (match_dup 1)\n-\t\t\t\t\t    (const_int 8) (const_int 8))\n-\t\t\t   (match_dup 2)))\n+\t\t   (any_or:SI (zero_extract:SI (match_dup 1)\n+\t\t\t\t\t       (const_int 8) (const_int 8))\n+\t\t\t      (match_dup 2)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"operands[0] = gen_lowpart (SImode, operands[0]);\n    operands[1] = gen_lowpart (SImode, operands[1]);\n@@ -9095,8 +9100,8 @@\n ;; profitable when 7th bit is set.\n (define_split\n   [(set (match_operand 0 \"register_operand\" \"\")\n-\t(ior (match_operand 1 \"general_operand\" \"\")\n-\t     (match_operand 2 \"const_int_operand\" \"\")))\n+\t(any_or (match_operand 1 \"general_operand\" \"\")\n+\t\t(match_operand 2 \"const_int_operand\" \"\")))\n    (clobber (reg:CC FLAGS_REG))]\n    \"reload_completed\n     && ANY_QI_REG_P (operands[0])\n@@ -9105,225 +9110,12 @@\n     && (INTVAL (operands[2]) & 128)\n     && GET_MODE (operands[0]) != QImode\"\n   [(parallel [(set (strict_low_part (match_dup 0))\n-\t\t   (ior:QI (match_dup 1)\n-\t\t\t   (match_dup 2)))\n+\t\t   (any_or:QI (match_dup 1)\n+\t\t\t      (match_dup 2)))\n \t      (clobber (reg:CC FLAGS_REG))])]\n   \"operands[0] = gen_lowpart (QImode, operands[0]);\n    operands[1] = gen_lowpart (QImode, operands[1]);\n    operands[2] = gen_lowpart (QImode, operands[2]);\")\n-\f\n-;; Logical XOR instructions\n-\n-;; %%% This used to optimize known byte-wide and operations to memory.\n-;; If this is considered useful, it should be done with splitters.\n-\n-(define_expand \"xor<mode>3\"\n-  [(set (match_operand:SWIM 0 \"nonimmediate_operand\" \"\")\n-\t(xor:SWIM (match_operand:SWIM 1 \"nonimmediate_operand\" \"\")\n-\t\t  (match_operand:SWIM 2 \"<general_operand>\" \"\")))]\n-  \"\"\n-  \"ix86_expand_binary_operator (XOR, <MODE>mode, operands); DONE;\")\n-\n-(define_insn \"*xor<mode>_1\"\n-  [(set (match_operand:SWI248 0 \"nonimmediate_operand\" \"=r,rm\")\n-\t(xor:SWI248 (match_operand:SWI248 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t    (match_operand:SWI248 2 \"<general_operand>\" \"<g>,r<i>\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (XOR, <MODE>mode, operands)\"\n-  \"xor{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n-;; %%% Potential partial reg stall on alternative 2.  What to do?\n-(define_insn \"*xorqi_1\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=q,m,r\")\n-\t(xor:QI (match_operand:QI 1 \"nonimmediate_operand\" \"%0,0,0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"qmn,qn,rn\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"ix86_binary_operator_ok (XOR, QImode, operands)\"\n-  \"@\n-   xor{b}\\t{%2, %0|%0, %2}\n-   xor{b}\\t{%2, %0|%0, %2}\n-   xor{l}\\t{%k2, %k0|%k0, %k2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"QI,QI,SI\")])\n-\n-;; See comment for addsi_1_zext why we do use nonimmediate_operand\n-;; Add speccase for immediates\n-(define_insn \"*xorsi_1_zext\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI\n-\t  (xor:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t  (match_operand:SI 2 \"general_operand\" \"g\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && ix86_binary_operator_ok (XOR, SImode, operands)\"\n-  \"xor{l}\\t{%2, %k0|%k0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*xorsi_1_zext_imm\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(xor:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%0\"))\n-\t\t(match_operand:DI 2 \"x86_64_zext_immediate_operand\" \"Z\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT && ix86_binary_operator_ok (XOR, SImode, operands)\"\n-  \"xor{l}\\t{%2, %k0|%k0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*xorqi_1_slp\"\n-  [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+qm,q\"))\n-\t(xor:QI (match_dup 0)\n-\t\t(match_operand:QI 1 \"general_operand\" \"qn,qmn\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"(! TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"xor{b}\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"alu1\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*xor<mode>_2\"\n-  [(set (reg FLAGS_REG)\n-\t(compare (xor:SWI\n-\t\t  (match_operand:SWI 1 \"nonimmediate_operand\" \"%0,0\")\n-\t\t  (match_operand:SWI 2 \"<general_operand>\" \"<g>,<r><i>\"))\n-\t\t (const_int 0)))\n-   (set (match_operand:SWI 0 \"nonimmediate_operand\" \"=<r>,<r>m\")\n-\t(xor:SWI (match_dup 1) (match_dup 2)))]\n-  \"ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (XOR, <MODE>mode, operands)\"\n-  \"xor{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n-;; See comment for addsi_1_zext why we do use nonimmediate_operand\n-;; ??? Special case for immediate operand is missing - it is tricky.\n-(define_insn \"*xorsi_2_zext\"\n-  [(set (reg FLAGS_REG)\n-\t(compare (xor:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"g\"))\n-\t\t (const_int 0)))\n-   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:DI (xor:SI (match_dup 1) (match_dup 2))))]\n-  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (XOR, SImode, operands)\"\n-  \"xor{l}\\t{%2, %k0|%k0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*xorsi_2_zext_imm\"\n-  [(set (reg FLAGS_REG)\n-\t(compare (xor:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t\t (match_operand 2 \"x86_64_zext_immediate_operand\" \"Z\"))\n-\t\t (const_int 0)))\n-   (set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(xor:DI (zero_extend:DI (match_dup 1)) (match_dup 2)))]\n-  \"TARGET_64BIT && ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (XOR, SImode, operands)\"\n-  \"xor{l}\\t{%2, %k0|%k0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"SI\")])\n-\n-(define_insn \"*xorqi_2_slp\"\n-  [(set (reg FLAGS_REG)\n-\t(compare (xor:QI (match_operand:QI 0 \"nonimmediate_operand\" \"+q,qm\")\n-\t\t\t (match_operand:QI 1 \"general_operand\" \"qmn,qn\"))\n-\t\t (const_int 0)))\n-   (set (strict_low_part (match_dup 0))\n-\t(xor:QI (match_dup 0) (match_dup 1)))]\n-  \"(!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-   && ix86_match_ccmode (insn, CCNOmode)\n-   && !(MEM_P (operands[0]) && MEM_P (operands[1]))\"\n-  \"xor{b}\\t{%1, %0|%0, %1}\"\n-  [(set_attr \"type\" \"alu1\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*xor<mode>_3\"\n-  [(set (reg FLAGS_REG)\n-\t(compare (xor:SWI\n-\t\t  (match_operand:SWI 1 \"nonimmediate_operand\" \"%0\")\n-\t\t  (match_operand:SWI 2 \"<general_operand>\" \"<g>\"))\n-\t\t (const_int 0)))\n-   (clobber (match_scratch:SWI 0 \"=<r>\"))]\n-  \"ix86_match_ccmode (insn, CCNOmode)\n-   && ix86_binary_operator_ok (XOR, <MODE>mode, operands)\"\n-  \"xor{<imodesuffix>}\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"mode\" \"<MODE>\")])\n-\n-(define_insn \"*xorqi_ext_0\"\n-  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n-\t\t\t (const_int 8)\n-\t\t\t (const_int 8))\n-\t(xor:SI\n-\t  (zero_extract:SI\n-\t    (match_operand 1 \"ext_register_operand\" \"0\")\n-\t    (const_int 8)\n-\t    (const_int 8))\n-\t  (match_operand 2 \"const_int_operand\" \"n\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun)\"\n-  \"xor{b}\\t{%2, %h0|%h0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"length_immediate\" \"1\")\n-   (set_attr \"modrm\" \"1\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*xorqi_ext_1_rex64\"\n-  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n-\t\t\t (const_int 8)\n-\t\t\t (const_int 8))\n-\t(xor:SI\n-\t  (zero_extract:SI\n-\t    (match_operand 1 \"ext_register_operand\" \"0\")\n-\t    (const_int 8)\n-\t    (const_int 8))\n-\t  (zero_extend:SI\n-\t    (match_operand 2 \"ext_register_operand\" \"Q\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"TARGET_64BIT\n-   && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\"\n-  \"xor{b}\\t{%2, %h0|%h0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*xorqi_ext_1\"\n-  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n-\t\t\t (const_int 8)\n-\t\t\t (const_int 8))\n-\t(xor:SI\n-\t  (zero_extract:SI\n-\t    (match_operand 1 \"ext_register_operand\" \"0\")\n-\t    (const_int 8)\n-\t    (const_int 8))\n-\t  (zero_extend:SI\n-\t    (match_operand:QI 2 \"general_operand\" \"Qm\"))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_64BIT\n-   && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\"\n-  \"xor{b}\\t{%2, %h0|%h0, %2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"QI\")])\n-\n-(define_insn \"*xorqi_ext_2\"\n-  [(set (zero_extract:SI (match_operand 0 \"ext_register_operand\" \"=Q\")\n-\t\t\t (const_int 8)\n-\t\t\t (const_int 8))\n-\t(xor:SI\n-\t  (zero_extract:SI (match_operand 1 \"ext_register_operand\" \"0\")\n-\t  \t\t   (const_int 8)\n-\t\t\t   (const_int 8))\n-\t  (zero_extract:SI (match_operand 2 \"ext_register_operand\" \"Q\")\n-\t  \t\t   (const_int 8)\n-\t\t\t   (const_int 8))))\n-   (clobber (reg:CC FLAGS_REG))]\n-  \"!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun)\"\n-  \"xor{b}\\t{%h2, %h0|%h0, %h2}\"\n-  [(set_attr \"type\" \"alu\")\n-   (set_attr \"length_immediate\" \"0\")\n-   (set_attr \"mode\" \"QI\")])\n \n (define_expand \"xorqi_cc_ext_1\"\n   [(parallel [\n@@ -9397,46 +9189,6 @@\n   [(set_attr \"type\" \"alu\")\n    (set_attr \"modrm\" \"1\")\n    (set_attr \"mode\" \"QI\")])\n-\n-(define_split\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-\t(xor (match_operand 1 \"register_operand\" \"\")\n-\t     (match_operand 2 \"const_int_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-   \"reload_completed\n-    && QI_REG_P (operands[0])\n-    && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-    && !(INTVAL (operands[2]) & ~(255 << 8))\n-    && GET_MODE (operands[0]) != QImode\"\n-  [(parallel [(set (zero_extract:SI (match_dup 0) (const_int 8) (const_int 8))\n-\t\t   (xor:SI (zero_extract:SI (match_dup 1)\n-\t\t\t\t\t    (const_int 8) (const_int 8))\n-\t\t\t   (match_dup 2)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[0] = gen_lowpart (SImode, operands[0]);\n-   operands[1] = gen_lowpart (SImode, operands[1]);\n-   operands[2] = gen_int_mode ((INTVAL (operands[2]) >> 8) & 0xff, SImode);\")\n-\n-;; Since XOR can be encoded with sign extended immediate, this is only\n-;; profitable when 7th bit is set.\n-(define_split\n-  [(set (match_operand 0 \"register_operand\" \"\")\n-\t(xor (match_operand 1 \"general_operand\" \"\")\n-\t     (match_operand 2 \"const_int_operand\" \"\")))\n-   (clobber (reg:CC FLAGS_REG))]\n-   \"reload_completed\n-    && ANY_QI_REG_P (operands[0])\n-    && (!TARGET_PARTIAL_REG_STALL || optimize_function_for_size_p (cfun))\n-    && !(INTVAL (operands[2]) & ~255)\n-    && (INTVAL (operands[2]) & 128)\n-    && GET_MODE (operands[0]) != QImode\"\n-  [(parallel [(set (strict_low_part (match_dup 0))\n-\t\t   (xor:QI (match_dup 1)\n-\t\t\t   (match_dup 2)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"operands[0] = gen_lowpart (QImode, operands[0]);\n-   operands[1] = gen_lowpart (QImode, operands[1]);\n-   operands[2] = gen_lowpart (QImode, operands[2]);\")\n \f\n ;; Negation instructions\n "}, {"sha": "c9aab21e9582c5003f643e8311e86aec7edb2867", "filename": "gcc/config/i386/mmx.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c842706443e018e9d9a5e85a9f4a1d4edfc8ce00/gcc%2Fconfig%2Fi386%2Fmmx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c842706443e018e9d9a5e85a9f4a1d4edfc8ce00/gcc%2Fconfig%2Fi386%2Fmmx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmmx.md?ref=c842706443e018e9d9a5e85a9f4a1d4edfc8ce00", "patch": "@@ -1087,19 +1087,19 @@\n \n (define_expand \"mmx_<code><mode>3\"\n   [(set (match_operand:MMXMODEI 0 \"register_operand\" \"\")\n-\t(plogic:MMXMODEI\n+\t(any_logic:MMXMODEI\n \t  (match_operand:MMXMODEI 1 \"nonimmediate_operand\" \"\")\n \t  (match_operand:MMXMODEI 2 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_MMX\"\n   \"ix86_fixup_binary_operands_no_copy (<CODE>, <MODE>mode, operands);\")\n \n (define_insn \"*mmx_<code><mode>3\"\n   [(set (match_operand:MMXMODEI 0 \"register_operand\" \"=y\")\n-        (plogic:MMXMODEI\n+        (any_logic:MMXMODEI\n \t  (match_operand:MMXMODEI 1 \"nonimmediate_operand\" \"%0\")\n \t  (match_operand:MMXMODEI 2 \"nonimmediate_operand\" \"ym\")))]\n   \"TARGET_MMX && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n-  \"p<plogicprefix>\\t{%2, %0|%0, %2}\"\n+  \"p<logicprefix>\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"mmxadd\")\n    (set_attr \"mode\" \"DI\")])\n "}, {"sha": "3a3e563718bd4d84644584e8d56cb8fa7e2c450e", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c842706443e018e9d9a5e85a9f4a1d4edfc8ce00/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c842706443e018e9d9a5e85a9f4a1d4edfc8ce00/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=c842706443e018e9d9a5e85a9f4a1d4edfc8ce00", "patch": "@@ -1580,40 +1580,40 @@\n \n (define_expand \"<code><mode>3\"\n   [(set (match_operand:AVX256MODEF2P 0 \"register_operand\" \"\")\n-\t(plogic:AVX256MODEF2P\n+\t(any_logic:AVX256MODEF2P\n \t  (match_operand:AVX256MODEF2P 1 \"nonimmediate_operand\" \"\")\n \t  (match_operand:AVX256MODEF2P 2 \"nonimmediate_operand\" \"\")))]\n   \"AVX256_VEC_FLOAT_MODE_P (<MODE>mode)\"\n   \"ix86_fixup_binary_operands_no_copy (<CODE>, <MODE>mode, operands);\")\n \n (define_insn \"*avx_<code><mode>3\"\n   [(set (match_operand:AVXMODEF2P 0 \"register_operand\" \"=x\")\n-\t(plogic:AVXMODEF2P\n+\t(any_logic:AVXMODEF2P\n \t  (match_operand:AVXMODEF2P 1 \"nonimmediate_operand\" \"%x\")\n \t  (match_operand:AVXMODEF2P 2 \"nonimmediate_operand\" \"xm\")))]\n   \"AVX_VEC_FLOAT_MODE_P (<MODE>mode)\n    && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n-  \"v<plogicprefix>p<avxmodesuffixf2c>\\t{%2, %1, %0|%0, %1, %2}\"\n+  \"v<logicprefix>p<avxmodesuffixf2c>\\t{%2, %1, %0|%0, %1, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"prefix\" \"vex\")\n    (set_attr \"mode\" \"<avxvecmode>\")])\n \n (define_expand \"<code><mode>3\"\n   [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"\")\n-\t(plogic:SSEMODEF2P\n+\t(any_logic:SSEMODEF2P\n \t  (match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"\")\n \t  (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"\")))]\n   \"SSE_VEC_FLOAT_MODE_P (<MODE>mode)\"\n   \"ix86_fixup_binary_operands_no_copy (<CODE>, <MODE>mode, operands);\")\n \n (define_insn \"*<code><mode>3\"\n   [(set (match_operand:SSEMODEF2P 0 \"register_operand\" \"=x\")\n-\t(plogic:SSEMODEF2P\n+\t(any_logic:SSEMODEF2P\n \t  (match_operand:SSEMODEF2P 1 \"nonimmediate_operand\" \"%0\")\n \t  (match_operand:SSEMODEF2P 2 \"nonimmediate_operand\" \"xm\")))]\n   \"SSE_VEC_FLOAT_MODE_P (<MODE>mode)\n    && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n-  \"<plogicprefix>p<ssemodesuffixf2c>\\t{%2, %0|%0, %2}\"\n+  \"<logicprefix>p<ssemodesuffixf2c>\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n@@ -1665,22 +1665,22 @@\n \n (define_insn \"*avx_<code><mode>3\"\n   [(set (match_operand:MODEF 0 \"register_operand\" \"=x\")\n-\t(plogic:MODEF\n+\t(any_logic:MODEF\n \t  (match_operand:MODEF 1 \"register_operand\" \"x\")\n \t  (match_operand:MODEF 2 \"register_operand\" \"x\")))]\n   \"AVX_FLOAT_MODE_P (<MODE>mode)\"\n-  \"v<plogicprefix>p<ssemodefsuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n+  \"v<logicprefix>p<ssemodefsuffix>\\t{%2, %1, %0|%0, %1, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"prefix\" \"vex\")\n    (set_attr \"mode\" \"<ssevecmode>\")])\n \n (define_insn \"*<code><mode>3\"\n   [(set (match_operand:MODEF 0 \"register_operand\" \"=x\")\n-\t(plogic:MODEF\n+\t(any_logic:MODEF\n \t  (match_operand:MODEF 1 \"register_operand\" \"0\")\n \t  (match_operand:MODEF 2 \"register_operand\" \"x\")))]\n   \"SSE_FLOAT_MODE_P (<MODE>mode)\"\n-  \"<plogicprefix>p<ssemodefsuffix>\\t{%2, %0|%0, %2}\"\n+  \"<logicprefix>p<ssemodefsuffix>\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"<ssevecmode>\")])\n \n@@ -6564,73 +6564,73 @@\n \n (define_expand \"<code><mode>3\"\n   [(set (match_operand:SSEMODEI 0 \"register_operand\" \"\")\n-\t(plogic:SSEMODEI\n+\t(any_logic:SSEMODEI\n \t  (match_operand:SSEMODEI 1 \"nonimmediate_operand\" \"\")\n \t  (match_operand:SSEMODEI 2 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_SSE\"\n   \"ix86_fixup_binary_operands_no_copy (<CODE>, <MODE>mode, operands);\")\n \n (define_insn \"*avx_<code><mode>3\"\n   [(set (match_operand:AVX256MODEI 0 \"register_operand\" \"=x\")\n-        (plogic:AVX256MODEI\n+        (any_logic:AVX256MODEI\n           (match_operand:AVX256MODEI 1 \"nonimmediate_operand\" \"%x\")\n           (match_operand:AVX256MODEI 2 \"nonimmediate_operand\" \"xm\")))]\n   \"TARGET_AVX\n    && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n-  \"v<plogicprefix>ps\\t{%2, %1, %0|%0, %1, %2}\"\n+  \"v<logicprefix>ps\\t{%2, %1, %0|%0, %1, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"prefix\" \"vex\")\n    (set_attr \"mode\" \"<avxvecpsmode>\")])\n \n (define_insn \"*sse_<code><mode>3\"\n   [(set (match_operand:SSEMODEI 0 \"register_operand\" \"=x\")\n-        (plogic:SSEMODEI\n+        (any_logic:SSEMODEI\n           (match_operand:SSEMODEI 1 \"nonimmediate_operand\" \"%0\")\n           (match_operand:SSEMODEI 2 \"nonimmediate_operand\" \"xm\")))]\n   \"(TARGET_SSE && !TARGET_SSE2)\n    && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n-  \"<plogicprefix>ps\\t{%2, %0|%0, %2}\"\n+  \"<logicprefix>ps\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"V4SF\")])\n \n (define_insn \"*avx_<code><mode>3\"\n   [(set (match_operand:SSEMODEI 0 \"register_operand\" \"=x\")\n-        (plogic:SSEMODEI\n+        (any_logic:SSEMODEI\n           (match_operand:SSEMODEI 1 \"nonimmediate_operand\" \"%x\")\n           (match_operand:SSEMODEI 2 \"nonimmediate_operand\" \"xm\")))]\n   \"TARGET_AVX\n    && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n-  \"vp<plogicprefix>\\t{%2, %1, %0|%0, %1, %2}\"\n+  \"vp<logicprefix>\\t{%2, %1, %0|%0, %1, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"prefix\" \"vex\")\n    (set_attr \"mode\" \"TI\")])\n \n (define_insn \"*sse2_<code><mode>3\"\n   [(set (match_operand:SSEMODEI 0 \"register_operand\" \"=x\")\n-\t(plogic:SSEMODEI\n+\t(any_logic:SSEMODEI\n \t  (match_operand:SSEMODEI 1 \"nonimmediate_operand\" \"%0\")\n \t  (match_operand:SSEMODEI 2 \"nonimmediate_operand\" \"xm\")))]\n   \"TARGET_SSE2 && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)\"\n-  \"p<plogicprefix>\\t{%2, %0|%0, %2}\"\n+  \"p<logicprefix>\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"prefix_data16\" \"1\")\n    (set_attr \"mode\" \"TI\")])\n \n (define_expand \"<code>tf3\"\n   [(set (match_operand:TF 0 \"register_operand\" \"\")\n-\t(plogic:TF\n+\t(any_logic:TF\n \t  (match_operand:TF 1 \"nonimmediate_operand\" \"\")\n \t  (match_operand:TF 2 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_SSE2\"\n   \"ix86_fixup_binary_operands_no_copy (<CODE>, TFmode, operands);\")\n \n (define_insn \"*<code>tf3\"\n   [(set (match_operand:TF 0 \"register_operand\" \"=x\")\n-\t(plogic:TF\n+\t(any_logic:TF\n \t  (match_operand:TF 1 \"nonimmediate_operand\" \"%0\")\n \t  (match_operand:TF 2 \"nonimmediate_operand\" \"xm\")))]\n   \"TARGET_SSE2 && ix86_binary_operator_ok (<CODE>, TFmode, operands)\"\n-  \"p<plogicprefix>\\t{%2, %0|%0, %2}\"\n+  \"p<logicprefix>\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"prefix_data16\" \"1\")\n    (set_attr \"mode\" \"TI\")])"}]}