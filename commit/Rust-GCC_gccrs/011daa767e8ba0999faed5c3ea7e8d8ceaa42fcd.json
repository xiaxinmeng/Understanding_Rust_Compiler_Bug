{"sha": "011daa767e8ba0999faed5c3ea7e8d8ceaa42fcd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDExZGFhNzY3ZThiYTA5OTlmYWVkNWMzZWE3ZThkOGNlYWE0MmZjZA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-03-02T00:24:45Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-03-02T00:24:45Z"}, "message": "trans-stmt.c (generate_loop_for_temp_to_lhs): Add an additional INVERT argument to invert the sense of the WHEREMASK argument.\n\n\n\t* trans-stmt.c (generate_loop_for_temp_to_lhs): Add an additional\n\tINVERT argument to invert the sense of the WHEREMASK argument.\n\tRemove unneeded code to AND together a list of masks.\n\t(generate_loop_for_rhs_to_temp): Likewise.\n\t(gfc_trans_assign_need_temp): Likewise.\n\t(gfc_trans_forall_1): Likewise.\n\t(gfc_evaluate_where_mask): Likewise, add a new INVERT argument\n\tto specify the sense of the MASK argument.\n\t(gfc_trans_where_assign): Likewise.\n\t(gfc_trans_where_2): Likewise.  Restructure code that decides\n\twhether we need to allocate zero, one or two temporary masks.\n\tIf this is a top-level WHERE (i.e. the incoming MAKS is NULL),\n\twe only need to allocate at most one temporary mask, and can\n\tinvert it's sense to provide the complementary pending execution\n\tmask.  Only calculate the size of the required temporary arrays\n\tif we need any.\n\t(gfc_trans_where): Update call to gfc_trans_where_2.\n\nFrom-SVN: r111630", "tree": {"sha": "77ab08403d503a642c7080aa2b98249c9e417e9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77ab08403d503a642c7080aa2b98249c9e417e9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/011daa767e8ba0999faed5c3ea7e8d8ceaa42fcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/011daa767e8ba0999faed5c3ea7e8d8ceaa42fcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/011daa767e8ba0999faed5c3ea7e8d8ceaa42fcd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/011daa767e8ba0999faed5c3ea7e8d8ceaa42fcd/comments", "author": null, "committer": null, "parents": [{"sha": "7362e4524fa75780ab7c203b0e37e43fdd6b1af3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7362e4524fa75780ab7c203b0e37e43fdd6b1af3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7362e4524fa75780ab7c203b0e37e43fdd6b1af3"}], "stats": {"total": 242, "additions": 161, "deletions": 81}, "files": [{"sha": "4e1c223b7e883f3088f94cfa57e3e2ce4493f103", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/011daa767e8ba0999faed5c3ea7e8d8ceaa42fcd/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/011daa767e8ba0999faed5c3ea7e8d8ceaa42fcd/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=011daa767e8ba0999faed5c3ea7e8d8ceaa42fcd", "patch": "@@ -1,3 +1,23 @@\n+2006-03-01  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* trans-stmt.c (generate_loop_for_temp_to_lhs): Add an additional\n+\tINVERT argument to invert the sense of the WHEREMASK argument.\n+\tRemove unneeded code to AND together a list of masks.\n+\t(generate_loop_for_rhs_to_temp): Likewise.\n+\t(gfc_trans_assign_need_temp): Likewise.\n+\t(gfc_trans_forall_1): Likewise.\n+\t(gfc_evaluate_where_mask): Likewise, add a new INVERT argument\n+\tto specify the sense of the MASK argument.\n+\t(gfc_trans_where_assign): Likewise.\n+\t(gfc_trans_where_2): Likewise.  Restructure code that decides\n+\twhether we need to allocate zero, one or two temporary masks.\n+\tIf this is a top-level WHERE (i.e. the incoming MAKS is NULL),\n+\twe only need to allocate at most one temporary mask, and can\n+\tinvert it's sense to provide the complementary pending execution\n+\tmask.  Only calculate the size of the required temporary arrays\n+\tif we need any.\n+\t(gfc_trans_where): Update call to gfc_trans_where_2.\n+\n 2006-03-01  Paul Thomas  <pault@gcc.gnu.org>\n \n \t* iresolve.c (gfc_resolve_dot_product):  Remove any difference in"}, {"sha": "1c792d228ccc0442b48b9d02e6e5dda6dea6cae8", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 141, "deletions": 81, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/011daa767e8ba0999faed5c3ea7e8d8ceaa42fcd/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/011daa767e8ba0999faed5c3ea7e8d8ceaa42fcd/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=011daa767e8ba0999faed5c3ea7e8d8ceaa42fcd", "patch": "@@ -62,7 +62,8 @@ typedef struct forall_info\n }\n forall_info;\n \n-static void gfc_trans_where_2 (gfc_code *, tree, forall_info *, stmtblock_t *);\n+static void gfc_trans_where_2 (gfc_code *, tree, bool,\n+\t\t\t       forall_info *, stmtblock_t *);\n \n /* Translate a F95 label number to a LABEL_EXPR.  */\n \n@@ -1602,13 +1603,13 @@ gfc_do_allocate (tree bytesize, tree size, tree * pdata, stmtblock_t * pblock,\n \n static tree\n generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree count3,\n-\t\t\t       tree count1, tree wheremask)\n+\t\t\t       tree count1, tree wheremask, bool invert)\n {\n   gfc_ss *lss;\n   gfc_se lse, rse;\n   stmtblock_t block, body;\n   gfc_loopinfo loop1;\n-  tree tmp, tmp2;\n+  tree tmp;\n   tree wheremaskexpr;\n \n   /* Walk the lhs.  */\n@@ -1672,20 +1673,16 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree count3,\n       /* Use the scalar assignment.  */\n       tmp = gfc_trans_scalar_assign (&lse, &rse, expr->ts.type);\n \n-     /* Form the mask expression according to the mask tree list.  */\n-     if (wheremask)\n-       {\n-\t wheremaskexpr = gfc_build_array_ref (wheremask, count3);\n-\t tmp2 = TREE_CHAIN (wheremask);\n-\t while (tmp2)\n-\t   {\n-\t     tmp1 = gfc_build_array_ref (tmp2, count3);\n-\t     wheremaskexpr = fold_build2 (TRUTH_AND_EXPR, TREE_TYPE (tmp1),\n-\t\t\t\t\t  wheremaskexpr, tmp1);\n-\t     tmp2 = TREE_CHAIN (tmp2);\n-\t   }\n-\t tmp = fold_build3 (COND_EXPR, void_type_node,\n-\t\t\t    wheremaskexpr, tmp, build_empty_stmt ());\n+      /* Form the mask expression according to the mask tree list.  */\n+      if (wheremask)\n+\t{\n+\t  wheremaskexpr = gfc_build_array_ref (wheremask, count3);\n+\t  if (invert)\n+\t    wheremaskexpr = fold_build1 (TRUTH_NOT_EXPR,\n+\t\t\t\t\t TREE_TYPE (wheremaskexpr),\n+\t\t\t\t\t wheremaskexpr);\n+\t  tmp = fold_build3 (COND_EXPR, void_type_node,\n+\t\t\t     wheremaskexpr, tmp, build_empty_stmt ());\n        }\n \n       gfc_add_expr_to_block (&body, tmp);\n@@ -1715,20 +1712,21 @@ generate_loop_for_temp_to_lhs (gfc_expr *expr, tree tmp1, tree count3,\n }\n \n \n-/* Generate codes to copy rhs to the temporary. TMP1 is the address of temporary\n-   LSS and RSS are formed in function compute_inner_temp_size(), and should\n-   not be freed.  */\n+/* Generate codes to copy rhs to the temporary. TMP1 is the address of\n+   temporary, LSS and RSS are formed in function compute_inner_temp_size(),\n+   and should not be freed.  WHEREMASK is the conditional execution mask\n+   whose sense may be inverted by INVERT.  */\n \n static tree\n generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree count3,\n \t\t\t       tree count1, gfc_ss *lss, gfc_ss *rss,\n-\t\t\t       tree wheremask)\n+\t\t\t       tree wheremask, bool invert)\n {\n   stmtblock_t block, body1;\n   gfc_loopinfo loop;\n   gfc_se lse;\n   gfc_se rse;\n-  tree tmp, tmp2;\n+  tree tmp;\n   tree wheremaskexpr;\n \n   gfc_start_block (&block);\n@@ -1774,14 +1772,10 @@ generate_loop_for_rhs_to_temp (gfc_expr *expr2, tree tmp1, tree count3,\n   if (wheremask)\n     {\n       wheremaskexpr = gfc_build_array_ref (wheremask, count3);\n-      tmp2 = TREE_CHAIN (wheremask);\n-      while (tmp2)\n-\t{\n-\t  tmp1 = gfc_build_array_ref (tmp2, count3);\n-\t  wheremaskexpr = fold_build2 (TRUTH_AND_EXPR, TREE_TYPE (tmp1),\n-\t\t\t\t       wheremaskexpr, tmp1);\n-\t  tmp2 = TREE_CHAIN (tmp2);\n-\t}\n+      if (invert)\n+\twheremaskexpr = fold_build1 (TRUTH_NOT_EXPR,\n+\t\t\t\t     TREE_TYPE (wheremaskexpr),\n+\t\t\t\t     wheremaskexpr);\n       tmp = fold_build3 (COND_EXPR, void_type_node,\n \t\t\t wheremaskexpr, tmp, build_empty_stmt ());\n     }\n@@ -2007,7 +2001,8 @@ allocate_temp_for_forall_nest (forall_info * nested_forall_info, tree type,\n     DEALLOCATE (tmp)\n   */\n static void\n-gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2, tree wheremask,\n+gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n+\t\t\t    tree wheremask, bool invert,\n                             forall_info * nested_forall_info,\n                             stmtblock_t * block)\n {\n@@ -2051,7 +2046,7 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2, tree wheremask,\n \n   /* Generate codes to copy rhs to the temporary .  */\n   tmp = generate_loop_for_rhs_to_temp (expr2, tmp1, count, count1, lss, rss,\n-\t\t\t\t       wheremask);\n+\t\t\t\t       wheremask, invert);\n \n   /* Generate body and loops according to the information in\n      nested_forall_info.  */\n@@ -2066,7 +2061,8 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2, tree wheremask,\n     gfc_add_modify_expr (block, count, gfc_index_zero_node);\n \n   /* Generate codes to copy the temporary to lhs.  */\n-  tmp = generate_loop_for_temp_to_lhs (expr1, tmp1, count, count1, wheremask);\n+  tmp = generate_loop_for_temp_to_lhs (expr1, tmp1, count, count1,\n+\t\t\t\t       wheremask, invert);\n \n   /* Generate body and loops according to the information in\n      nested_forall_info.  */\n@@ -2499,7 +2495,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n           /* Temporaries due to array assignment data dependencies introduce\n              no end of problems.  */\n \t  if (need_temp)\n-            gfc_trans_assign_need_temp (c->expr, c->expr2, NULL,\n+            gfc_trans_assign_need_temp (c->expr, c->expr2, NULL, false,\n                                         nested_forall_info, &block);\n           else\n             {\n@@ -2515,7 +2511,7 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n \n         case EXEC_WHERE:\n \t  /* Translate WHERE or WHERE construct nested in FORALL.  */\n-\t  gfc_trans_where_2 (c, NULL, nested_forall_info, &block);\n+\t  gfc_trans_where_2 (c, NULL, false, nested_forall_info, &block);\n \t  break;\n \n         /* Pointer assignment inside FORALL.  */\n@@ -2595,14 +2591,15 @@ tree gfc_trans_forall (gfc_code * code)\n    needed by the WHERE mask expression multiplied by the iterator number of\n    the nested forall.\n    ME is the WHERE mask expression.\n-   MASK is the current execution mask upon input.\n+   MASK is the current execution mask upon input, whose sense may or may\n+   not be inverted as specified by the INVERT argument.\n    CMASK is the updated execution mask on output, or NULL if not required.\n    PMASK is the pending execution mask on output, or NULL if not required.\n    BLOCK is the block in which to place the condition evaluation loops.  */\n \n static void\n gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n-                         tree mask, tree cmask, tree pmask,\n+                         tree mask, bool invert, tree cmask, tree pmask,\n                          tree mask_type, stmtblock_t * block)\n {\n   tree tmp, tmp1;\n@@ -2667,6 +2664,8 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n   if (mask && (cmask || pmask))\n     {\n       tmp = gfc_build_array_ref (mask, count);\n+      if (invert)\n+\ttmp = fold_build1 (TRUTH_NOT_EXPR, mask_type, tmp);\n       gfc_add_modify_expr (&body1, mtmp, tmp);\n     }\n \n@@ -2724,10 +2723,12 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n \n /* Translate an assignment statement in a WHERE statement or construct\n    statement. The MASK expression is used to control which elements\n-   of EXPR1 shall be assigned.  */\n+   of EXPR1 shall be assigned.  The sense of MASK is specified by\n+   INVERT.  */\n \n static tree\n-gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2, tree mask,\n+gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2,\n+\t\t\ttree mask, bool invert,\n                         tree count1, tree count2)\n {\n   gfc_se lse;\n@@ -2838,6 +2839,8 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2, tree mask,\n   /* Form the mask expression according to the mask.  */\n   index = count1;\n   maskexpr = gfc_build_array_ref (mask, index);\n+  if (invert)\n+    maskexpr = fold_build1 (TRUTH_NOT_EXPR, TREE_TYPE (maskexpr), maskexpr);\n \n   /* Use the scalar assignment as is.  */\n   tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts.type);\n@@ -2888,6 +2891,9 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2, tree mask,\n           /* Form the mask expression according to the mask tree list.  */\n           index = count2;\n           maskexpr = gfc_build_array_ref (mask, index);\n+\t  if (invert)\n+\t    maskexpr = fold_build1 (TRUTH_NOT_EXPR, TREE_TYPE (maskexpr),\n+\t\t\t\t    maskexpr);\n \n           /* Use the scalar assignment as is.  */\n           tmp = gfc_trans_scalar_assign (&lse, &rse, expr1->ts.type);\n@@ -2926,7 +2932,7 @@ gfc_trans_where_assign (gfc_expr *expr1, gfc_expr *expr2, tree mask,\n    MASK is the control mask.  */\n \n static void\n-gfc_trans_where_2 (gfc_code * code, tree mask,\n+gfc_trans_where_2 (gfc_code * code, tree mask, bool invert,\n \t\t   forall_info * nested_forall_info, stmtblock_t * block)\n {\n   stmtblock_t inner_size_body;\n@@ -2939,6 +2945,8 @@ gfc_trans_where_2 (gfc_code * code, tree mask,\n   gfc_code *cnext;\n   tree tmp;\n   tree count1, count2;\n+  bool need_cmask;\n+  bool need_pmask;\n   int need_temp;\n   tree pcmask = NULL_TREE;\n   tree ppmask = NULL_TREE;\n@@ -2948,51 +2956,75 @@ gfc_trans_where_2 (gfc_code * code, tree mask,\n   /* the WHERE statement or the WHERE construct statement.  */\n   cblock = code->block;\n \n-  /* Calculate the size of temporary needed by the mask-expr.  */\n-  gfc_init_block (&inner_size_body);\n-  inner_size = compute_inner_temp_size (cblock->expr, cblock->expr,\n-\t\t\t\t\t&inner_size_body, &lss, &rss);\n-\n-  /* Calculate the total size of temporary needed.  */\n-  size = compute_overall_iter_number (nested_forall_info, inner_size,\n-\t\t\t\t      &inner_size_body, block);\n-\n   /* As the mask array can be very big, prefer compact boolean types.  */\n   mask_type = gfc_get_logical_type (gfc_logical_kinds[0].kind);\n \n-  /* Allocate temporary for WHERE mask.  We only need a \"cmask\" if\n-     there are statements to be executed.  The following test only\n-     checks the first ELSEWHERE to catch the F90 cases.  */\n-  if (cblock->next\n-      || (cblock->block && cblock->block->next && cblock->block->expr)\n-      || (cblock->block && cblock->block->block))\n+  /* Determine which temporary masks are needed.  */\n+  if (!cblock->block)\n     {\n-      cmask = allocate_temp_for_forall_nest_1 (mask_type, size, block,\n-\t\t\t\t\t       &pcmask);\n+      /* One clause: No ELSEWHEREs.  */\n+      need_cmask = (cblock->next != 0);\n+      need_pmask = false;\n     }\n-  else\n+  else if (cblock->block->block)\n     {\n-      pcmask = NULL_TREE;\n-      cmask = NULL_TREE;\n+      /* Three or more clauses: Conditional ELSEWHEREs.  */\n+      need_cmask = true;\n+      need_pmask = true;\n     }\n-\n-  /* Allocate temporary for !mask.  We only need a \"pmask\" if there \n-     is an ELSEWHERE clause containing executable statements.  Again\n-     we only lookahead a single ELSEWHERE to catch the F90 cases.  */\n-  if ((cblock->block && cblock->block->next)\n-      || (cblock->block && cblock->block->block))\n+  else if (cblock->next)\n+    {\n+      /* Two clauses, the first non-empty.  */\n+      need_cmask = true;\n+      need_pmask = (mask != NULL_TREE\n+\t\t    && cblock->block->next != 0);\n+    }\n+  else if (!cblock->block->next)\n     {\n-      pmask = allocate_temp_for_forall_nest_1 (mask_type, size, block,\n-\t\t\t\t\t       &ppmask);\n+      /* Two clauses, both empty.  */\n+      need_cmask = false;\n+      need_pmask = false;\n+    }\n+  /* Two clauses, the first empty, the second non-empty.  */\n+  else if (mask)\n+    {\n+      need_cmask = (cblock->block->expr != 0);\n+      need_pmask = true;\n     }\n   else\n     {\n-      ppmask = NULL_TREE;\n-      pmask = NULL_TREE;\n+      need_cmask = true;\n+      need_pmask = false;\n+    }\n+\n+  if (need_cmask || need_pmask)\n+    {\n+      /* Calculate the size of temporary needed by the mask-expr.  */\n+      gfc_init_block (&inner_size_body);\n+      inner_size = compute_inner_temp_size (cblock->expr, cblock->expr,\n+\t\t\t\t\t    &inner_size_body, &lss, &rss);\n+\n+      /* Calculate the total size of temporary needed.  */\n+      size = compute_overall_iter_number (nested_forall_info, inner_size,\n+\t\t\t\t\t  &inner_size_body, block);\n+\n+      /* Allocate temporary for WHERE mask if needed.  */\n+      if (need_cmask)\n+\tcmask = allocate_temp_for_forall_nest_1 (mask_type, size, block,\n+\t\t\t\t\t\t &pcmask);\n+\n+      /* Allocate temporary for !mask if needed.  */\n+      if (need_pmask)\n+\tpmask = allocate_temp_for_forall_nest_1 (mask_type, size, block,\n+\t\t\t\t\t\t &ppmask);\n     }\n \n   while (cblock)\n     {\n+      /* Each time around this loop, the where clause is conditional\n+\t on the value of mask and invert, which are updated at the\n+\t bottom of the loop.  */\n+\n       /* Has mask-expr.  */\n       if (cblock->expr)\n         {\n@@ -3001,16 +3033,28 @@ gfc_trans_where_2 (gfc_code * code, tree mask,\n \t     then we don't need to update the control mask (cmask).\n \t     If this is the last clause of the WHERE construct, then\n \t     we don't need to update the pending control mask (pmask).  */\n-          gfc_evaluate_where_mask (cblock->expr, nested_forall_info, mask,\n-\t\t\t\t   cblock->next ? cmask : NULL_TREE,\n-\t\t\t\t   cblock->block ? pmask : NULL_TREE,\n-\t\t\t\t   mask_type, block);\n+\t  if (mask)\n+\t    gfc_evaluate_where_mask (cblock->expr, nested_forall_info,\n+\t\t\t\t     mask, invert,\n+\t\t\t\t     cblock->next  ? cmask : NULL_TREE,\n+\t\t\t\t     cblock->block ? pmask : NULL_TREE,\n+\t\t\t\t     mask_type, block);\n+\t  else\n+\t    gfc_evaluate_where_mask (cblock->expr, nested_forall_info,\n+\t\t\t\t     NULL_TREE, false,\n+\t\t\t\t     (cblock->next || cblock->block)\n+\t\t\t\t     ? cmask : NULL_TREE,\n+\t\t\t\t     NULL_TREE, mask_type, block);\n \n+\t  invert = false;\n         }\n       /* It's a final elsewhere-stmt. No mask-expr is present.  */\n       else\n         cmask = mask;\n \n+      /* The body of this where clause are controlled by cmask with\n+\t sense specified by invert.  */\n+\n       /* Get the assignment statement of a WHERE statement, or the first\n          statement in where-body-construct of a WHERE construct.  */\n       cnext = cblock->next;\n@@ -3026,7 +3070,8 @@ gfc_trans_where_2 (gfc_code * code, tree mask,\n                 {\n                   need_temp = gfc_check_dependency (expr1, expr2, 0);\n                   if (need_temp)\n-                    gfc_trans_assign_need_temp (expr1, expr2, cmask,\n+                    gfc_trans_assign_need_temp (expr1, expr2,\n+\t\t\t\t\t\tcmask, invert,\n                                                 nested_forall_info, block);\n                   else\n                     {\n@@ -3036,7 +3081,8 @@ gfc_trans_where_2 (gfc_code * code, tree mask,\n                       gfc_add_modify_expr (block, count1, gfc_index_zero_node);\n                       gfc_add_modify_expr (block, count2, gfc_index_zero_node);\n \n-                      tmp = gfc_trans_where_assign (expr1, expr2, cmask,\n+                      tmp = gfc_trans_where_assign (expr1, expr2,\n+\t\t\t\t\t\t    cmask, invert,\n \t\t\t\t\t\t    count1, count2);\n \n                       tmp = gfc_trans_nested_forall_loop (nested_forall_info,\n@@ -3052,7 +3098,8 @@ gfc_trans_where_2 (gfc_code * code, tree mask,\n                   gfc_add_modify_expr (block, count1, gfc_index_zero_node);\n                   gfc_add_modify_expr (block, count2, gfc_index_zero_node);\n \n-                  tmp = gfc_trans_where_assign (expr1, expr2, cmask,\n+                  tmp = gfc_trans_where_assign (expr1, expr2,\n+\t\t\t\t\t\tcmask, invert,\n \t\t\t\t\t\tcount1, count2);\n                   gfc_add_expr_to_block (block, tmp);\n \n@@ -3061,8 +3108,8 @@ gfc_trans_where_2 (gfc_code * code, tree mask,\n \n             /* WHERE or WHERE construct is part of a where-body-construct.  */\n             case EXEC_WHERE:\n-\t      /* Ensure that MASK is not modified by next gfc_trans_where_2.  */\n-\t      gfc_trans_where_2 (cnext, cmask, nested_forall_info, block);\n+\t      gfc_trans_where_2 (cnext, cmask, invert,\n+\t\t\t\t nested_forall_info, block);\n \t      break;\n \n             default:\n@@ -3074,7 +3121,20 @@ gfc_trans_where_2 (gfc_code * code, tree mask,\n        }\n     /* The next masked-elsewhere-stmt, elsewhere-stmt, or end-where-stmt.  */\n     cblock = cblock->block;\n-    mask = pmask;\n+    if (mask == NULL_TREE)\n+      {\n+        /* If we're the initial WHERE, we can simply invert the sense\n+\t   of the current mask to obtain the \"mask\" for the remaining\n+\t   ELSEWHEREs.  */\n+\tinvert = true;\n+\tmask = cmask;\n+      }\n+    else\n+      {\n+\t/* Otherwise, for nested WHERE's we need to use the pending mask.  */\n+        invert = false;\n+        mask = pmask;\n+      }\n   }\n \n   /* If we allocated a pending mask array, deallocate it now.  */\n@@ -3283,7 +3343,7 @@ gfc_trans_where (gfc_code * code)\n \n   gfc_start_block (&block);\n \n-  gfc_trans_where_2 (code, NULL, NULL, &block);\n+  gfc_trans_where_2 (code, NULL, false, NULL, &block);\n \n   return gfc_finish_block (&block);\n }"}]}