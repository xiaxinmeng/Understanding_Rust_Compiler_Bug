{"sha": "c13032e55c0bd39557c6366729e4afca3890c6c1", "node_id": "C_kwDOANBUbNoAKGMxMzAzMmU1NWMwYmQzOTU1N2M2MzY2NzI5ZTRhZmNhMzg5MGM2YzE", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-04-20T15:56:46Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2023-04-28T10:16:43Z"}, "message": "gccrs: Extract helper lookup_associated_impl_block\n\nThis will look for a specified predicate that is associated with it so we\nmight have the predicate Foo<u16, i32> which would refer to:\n\n  impl Foo<i32> for u16 {}\n\nThis is a general helper which can be used in several places.\n\ngcc/rust/ChangeLog:\n\n\t* typecheck/rust-hir-trait-reference.cc (AssociatedImplTrait::AssociatedImplTrait):\n\tbind the predicate\n\t(AssociatedImplTrait::get_trait): remove\n\t(AssociatedImplTrait::get_predicate): new getter\n\t* typecheck/rust-hir-trait-reference.h: bind predicate\n\t* typecheck/rust-hir-type-check-item.cc: update ctor\n\t* typecheck/rust-type-util.cc (lookup_associated_impl_block): new function\n\t* typecheck/rust-type-util.h (class BaseType): remove unused forward decl\n\t(lookup_associated_impl_block): new helper\n\t* typecheck/rust-tyty-bounds.cc (TypeBoundPredicate::is_equal): new\n\t* typecheck/rust-tyty-subst.cc (SubstitutionRef::lookup_associated_impl): use new helper\n\t(SubstitutionRef::monomorphize): update usage/error handling\n\t* typecheck/rust-tyty-subst.h: remove old prototype\n\t* typecheck/rust-tyty.h: add is_equal decl\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>", "tree": {"sha": "75c70c9bbc0225d37d9938ced80fbeab8f20cab0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75c70c9bbc0225d37d9938ced80fbeab8f20cab0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c13032e55c0bd39557c6366729e4afca3890c6c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c13032e55c0bd39557c6366729e4afca3890c6c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c13032e55c0bd39557c6366729e4afca3890c6c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c13032e55c0bd39557c6366729e4afca3890c6c1/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48510f443fa1623a3863206536cac0dfa381246f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48510f443fa1623a3863206536cac0dfa381246f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48510f443fa1623a3863206536cac0dfa381246f"}], "stats": {"total": 332, "additions": 183, "deletions": 149}, "files": [{"sha": "f4593ce00fb86891281378a3e9caee57d01f7df3", "filename": "gcc/rust/typecheck/rust-hir-trait-reference.cc", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13032e55c0bd39557c6366729e4afca3890c6c1/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13032e55c0bd39557c6366729e4afca3890c6c1/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.cc?ref=c13032e55c0bd39557c6366729e4afca3890c6c1", "patch": "@@ -442,16 +442,18 @@ TraitReference::satisfies_bound (const TraitReference &reference) const\n }\n \n AssociatedImplTrait::AssociatedImplTrait (TraitReference *trait,\n+\t\t\t\t\t  TyTy::TypeBoundPredicate predicate,\n \t\t\t\t\t  HIR::ImplBlock *impl,\n \t\t\t\t\t  TyTy::BaseType *self,\n \t\t\t\t\t  Resolver::TypeCheckContext *context)\n-  : trait (trait), impl (impl), self (self), context (context)\n+  : trait (trait), predicate (predicate), impl (impl), self (self),\n+    context (context)\n {}\n \n-TraitReference *\n-AssociatedImplTrait::get_trait ()\n+TyTy::TypeBoundPredicate &\n+AssociatedImplTrait::get_predicate ()\n {\n-  return trait;\n+  return predicate;\n }\n \n HIR::ImplBlock *\n@@ -465,6 +467,7 @@ AssociatedImplTrait::get_self ()\n {\n   return self;\n }\n+\n const TyTy::BaseType *\n AssociatedImplTrait::get_self () const\n {"}, {"sha": "2179d09403fd0516c04b23e25afc11381babae2d", "filename": "gcc/rust/typecheck/rust-hir-trait-reference.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13032e55c0bd39557c6366729e4afca3890c6c1/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13032e55c0bd39557c6366729e4afca3890c6c1/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-reference.h?ref=c13032e55c0bd39557c6366729e4afca3890c6c1", "patch": "@@ -238,11 +238,12 @@ class TraitReference\n class AssociatedImplTrait\n {\n public:\n-  AssociatedImplTrait (TraitReference *trait, HIR::ImplBlock *impl,\n+  AssociatedImplTrait (TraitReference *trait,\n+\t\t       TyTy::TypeBoundPredicate predicate, HIR::ImplBlock *impl,\n \t\t       TyTy::BaseType *self,\n \t\t       Resolver::TypeCheckContext *context);\n \n-  TraitReference *get_trait ();\n+  TyTy::TypeBoundPredicate &get_predicate ();\n \n   HIR::ImplBlock *get_impl_block ();\n \n@@ -257,6 +258,7 @@ class AssociatedImplTrait\n \n private:\n   TraitReference *trait;\n+  TyTy::TypeBoundPredicate predicate;\n   HIR::ImplBlock *impl;\n   TyTy::BaseType *self;\n   Resolver::TypeCheckContext *context;"}, {"sha": "4b9f9bce2eaf925c4b2b81da3bedf31fd64dd4c3", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13032e55c0bd39557c6366729e4afca3890c6c1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13032e55c0bd39557c6366729e4afca3890c6c1/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.cc?ref=c13032e55c0bd39557c6366729e4afca3890c6c1", "patch": "@@ -607,8 +607,8 @@ TypeCheckItem::validate_trait_impl_block (\n     {\n       trait_reference->clear_associated_types ();\n \n-      AssociatedImplTrait associated (trait_reference, &impl_block, self,\n-\t\t\t\t      context);\n+      AssociatedImplTrait associated (trait_reference, specified_bound,\n+\t\t\t\t      &impl_block, self, context);\n       context->insert_associated_trait_impl (\n \timpl_block.get_mappings ().get_hirid (), std::move (associated));\n       context->insert_associated_impl_mapping ("}, {"sha": "d77175eedc01a208d557d7751f8d80d4e6e9b0d3", "filename": "gcc/rust/typecheck/rust-type-util.cc", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13032e55c0bd39557c6366729e4afca3890c6c1/gcc%2Frust%2Ftypecheck%2Frust-type-util.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13032e55c0bd39557c6366729e4afca3890c6c1/gcc%2Frust%2Ftypecheck%2Frust-type-util.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-type-util.cc?ref=c13032e55c0bd39557c6366729e4afca3890c6c1", "patch": "@@ -25,6 +25,7 @@\n #include \"rust-casts.h\"\n #include \"rust-unify.h\"\n #include \"rust-coercion.h\"\n+#include \"rust-hir-type-bounds.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -254,5 +255,112 @@ cast_site (HirId id, TyTy::TyWithLocation from, TyTy::TyWithLocation to,\n   return casted;\n }\n \n+AssociatedImplTrait *\n+lookup_associated_impl_block (const TyTy::TypeBoundPredicate &bound,\n+\t\t\t      const TyTy::BaseType *binding, bool *ambigious)\n+{\n+  auto context = TypeCheckContext::get ();\n+\n+  // setup any associated type mappings for the specified bonds and this\n+  // type\n+  auto candidates = TypeBoundsProbe::Probe (binding);\n+  std::vector<AssociatedImplTrait *> associated_impl_traits;\n+  for (auto &probed_bound : candidates)\n+    {\n+      HIR::ImplBlock *associated_impl = probed_bound.second;\n+\n+      HirId impl_block_id = associated_impl->get_mappings ().get_hirid ();\n+      AssociatedImplTrait *associated = nullptr;\n+      bool found_impl_trait\n+\t= context->lookup_associated_trait_impl (impl_block_id, &associated);\n+      if (found_impl_trait)\n+\t{\n+\t  // compare the bounds from here i think is what we can do:\n+\t  if (bound.is_equal (associated->get_predicate ()))\n+\t    {\n+\t      associated_impl_traits.push_back (associated);\n+\t    }\n+\t}\n+    }\n+\n+  if (associated_impl_traits.empty ())\n+    return nullptr;\n+\n+  // This code is important when you look at slices for example when\n+  // you have a slice such as:\n+  //\n+  // let slice = &array[1..3]\n+  //\n+  // the higher ranked bounds will end up having an Index trait\n+  // implementation for Range<usize> so we need this code to resolve\n+  // that we have an integer inference variable that needs to become\n+  // a usize\n+  //\n+  // The other complicated issue is that we might have an intrinsic\n+  // which requires the :Clone or Copy bound but the libcore adds\n+  // implementations for all the integral types so when there are\n+  // multiple candidates we need to resolve to the default\n+  // implementation for that type otherwise its an error for\n+  // ambiguous type bounds\n+\n+  // if we have a non-general inference variable we need to be\n+  // careful about the selection here\n+  bool is_infer_var = binding->get_kind () == TyTy::TypeKind::INFER;\n+  bool is_integer_infervar\n+    = is_infer_var\n+      && static_cast<const TyTy::InferType *> (binding)->get_infer_kind ()\n+\t   == TyTy::InferType::InferTypeKind::INTEGRAL;\n+  bool is_float_infervar\n+    = is_infer_var\n+      && static_cast<const TyTy::InferType *> (binding)->get_infer_kind ()\n+\t   == TyTy::InferType::InferTypeKind::FLOAT;\n+\n+  AssociatedImplTrait *associate_impl_trait = nullptr;\n+  if (associated_impl_traits.size () == 1)\n+    {\n+      // just go for it\n+      associate_impl_trait = associated_impl_traits.at (0);\n+    }\n+  else if (is_integer_infervar)\n+    {\n+      TyTy::BaseType *type = nullptr;\n+      bool ok = context->lookup_builtin (\"i32\", &type);\n+      rust_assert (ok);\n+\n+      for (auto &impl : associated_impl_traits)\n+\t{\n+\t  bool found = impl->get_self ()->is_equal (*type);\n+\t  if (found)\n+\t    {\n+\t      associate_impl_trait = impl;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  else if (is_float_infervar)\n+    {\n+      TyTy::BaseType *type = nullptr;\n+      bool ok = context->lookup_builtin (\"f64\", &type);\n+      rust_assert (ok);\n+\n+      for (auto &impl : associated_impl_traits)\n+\t{\n+\t  bool found = impl->get_self ()->is_equal (*type);\n+\t  if (found)\n+\t    {\n+\t      associate_impl_trait = impl;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  if (associate_impl_trait == nullptr && ambigious != nullptr)\n+    {\n+      *ambigious = true;\n+    }\n+\n+  return associate_impl_trait;\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "89e4a185a50e3eeee0177f7c49bb6f8490ec627d", "filename": "gcc/rust/typecheck/rust-type-util.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13032e55c0bd39557c6366729e4afca3890c6c1/gcc%2Frust%2Ftypecheck%2Frust-type-util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13032e55c0bd39557c6366729e4afca3890c6c1/gcc%2Frust%2Ftypecheck%2Frust-type-util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-type-util.h?ref=c13032e55c0bd39557c6366729e4afca3890c6c1", "patch": "@@ -23,11 +23,6 @@\n #include \"rust-tyty.h\"\n \n namespace Rust {\n-\n-namespace TyTy {\n-class BaseType;\n-}\n-\n namespace Resolver {\n \n bool\n@@ -50,6 +45,11 @@ TyTy::BaseType *\n cast_site (HirId id, TyTy::TyWithLocation from, TyTy::TyWithLocation to,\n \t   Location cast_locus);\n \n+AssociatedImplTrait *\n+lookup_associated_impl_block (const TyTy::TypeBoundPredicate &bound,\n+\t\t\t      const TyTy::BaseType *binding,\n+\t\t\t      bool *ambigious = nullptr);\n+\n } // namespace Resolver\n } // namespace Rust\n "}, {"sha": "67aa4f8fa86b56233de82ad9674f448e616422ee", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13032e55c0bd39557c6366729e4afca3890c6c1/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13032e55c0bd39557c6366729e4afca3890c6c1/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=c13032e55c0bd39557c6366729e4afca3890c6c1", "patch": "@@ -680,6 +680,40 @@ TypeBoundPredicate::get_associated_type_items ()\n   return items;\n }\n \n+bool\n+TypeBoundPredicate::is_equal (const TypeBoundPredicate &other) const\n+{\n+  // check they match the same trait reference\n+  if (reference != other.reference)\n+    return false;\n+\n+  // check that the generics match\n+  if (get_num_substitutions () != other.get_num_substitutions ())\n+    return false;\n+\n+  // then match the generics applied\n+  for (size_t i = 0; i < get_num_substitutions (); i++)\n+    {\n+      const SubstitutionParamMapping &a = substitutions.at (i);\n+      const SubstitutionParamMapping &b = other.substitutions.at (i);\n+\n+      const ParamType *ap = a.get_param_ty ();\n+      const ParamType *bp = b.get_param_ty ();\n+\n+      const BaseType *apd = ap->destructure ();\n+      const BaseType *bpd = bp->destructure ();\n+\n+      // FIXME use the unify_and infer inteface or try coerce\n+      if (!apd->can_eq (bpd, false /*emit_errors*/))\n+\t{\n+\t  if (!bpd->can_eq (apd, false /*emit_errors*/))\n+\t    return false;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n // trait item reference\n \n const Resolver::TraitItemReference *"}, {"sha": "7d7ab7ca79ad2b0092094e43df369a9ae68ffb4b", "filename": "gcc/rust/typecheck/rust-tyty-subst.cc", "status": "modified", "additions": 21, "deletions": 132, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13032e55c0bd39557c6366729e4afca3890c6c1/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13032e55c0bd39557c6366729e4afca3890c6c1/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.cc?ref=c13032e55c0bd39557c6366729e4afca3890c6c1", "patch": "@@ -21,7 +21,7 @@\n #include \"rust-hir-type-check.h\"\n #include \"rust-substitution-mapper.h\"\n #include \"rust-hir-type-check-type.h\"\n-#include \"rust-hir-type-bounds.h\"\n+#include \"rust-type-util.h\"\n \n namespace Rust {\n namespace TyTy {\n@@ -831,132 +831,6 @@ SubstitutionRef::solve_mappings_from_receiver_for_self (\n \t\t\t\t       mappings.get_locus ());\n }\n \n-Resolver::AssociatedImplTrait *\n-SubstitutionRef::lookup_associated_impl (const SubstitutionParamMapping &subst,\n-\t\t\t\t\t const TypeBoundPredicate &bound,\n-\t\t\t\t\t const TyTy::BaseType *binding,\n-\t\t\t\t\t bool *error_flag) const\n-{\n-  auto context = Resolver::TypeCheckContext::get ();\n-  const Resolver::TraitReference *specified_bound_ref = bound.get ();\n-\n-  // setup any associated type mappings for the specified bonds and this\n-  // type\n-  auto candidates = Resolver::TypeBoundsProbe::Probe (binding);\n-  std::vector<Resolver::AssociatedImplTrait *> associated_impl_traits;\n-  for (auto &probed_bound : candidates)\n-    {\n-      const Resolver::TraitReference *bound_trait_ref = probed_bound.first;\n-      const HIR::ImplBlock *associated_impl = probed_bound.second;\n-\n-      HirId impl_block_id = associated_impl->get_mappings ().get_hirid ();\n-      Resolver::AssociatedImplTrait *associated = nullptr;\n-      bool found_impl_trait\n-\t= context->lookup_associated_trait_impl (impl_block_id, &associated);\n-      if (found_impl_trait)\n-\t{\n-\t  bool found_trait = specified_bound_ref->is_equal (*bound_trait_ref);\n-\t  bool found_self = associated->get_self ()->can_eq (binding, false);\n-\t  if (found_trait && found_self)\n-\t    {\n-\t      associated_impl_traits.push_back (associated);\n-\t    }\n-\t}\n-    }\n-\n-  if (associated_impl_traits.empty ())\n-    return nullptr;\n-\n-  // This code is important when you look at slices for example when\n-  // you have a slice such as:\n-  //\n-  // let slice = &array[1..3]\n-  //\n-  // the higher ranked bounds will end up having an Index trait\n-  // implementation for Range<usize> so we need this code to resolve\n-  // that we have an integer inference variable that needs to become\n-  // a usize\n-  //\n-  // The other complicated issue is that we might have an intrinsic\n-  // which requires the :Clone or Copy bound but the libcore adds\n-  // implementations for all the integral types so when there are\n-  // multiple candidates we need to resolve to the default\n-  // implementation for that type otherwise its an error for\n-  // ambiguous type bounds\n-\n-  // if we have a non-general inference variable we need to be\n-  // careful about the selection here\n-  bool is_infer_var = binding->get_kind () == TyTy::TypeKind::INFER;\n-  bool is_integer_infervar\n-    = is_infer_var\n-      && static_cast<const TyTy::InferType *> (binding)->get_infer_kind ()\n-\t   == TyTy::InferType::InferTypeKind::INTEGRAL;\n-  bool is_float_infervar\n-    = is_infer_var\n-      && static_cast<const TyTy::InferType *> (binding)->get_infer_kind ()\n-\t   == TyTy::InferType::InferTypeKind::FLOAT;\n-\n-  Resolver::AssociatedImplTrait *associate_impl_trait = nullptr;\n-  if (associated_impl_traits.size () == 1)\n-    {\n-      // just go for it\n-      associate_impl_trait = associated_impl_traits.at (0);\n-    }\n-  else if (is_integer_infervar)\n-    {\n-      TyTy::BaseType *type = nullptr;\n-      bool ok = context->lookup_builtin (\"i32\", &type);\n-      rust_assert (ok);\n-\n-      for (auto &impl : associated_impl_traits)\n-\t{\n-\t  bool found = impl->get_self ()->is_equal (*type);\n-\t  if (found)\n-\t    {\n-\t      associate_impl_trait = impl;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  else if (is_float_infervar)\n-    {\n-      TyTy::BaseType *type = nullptr;\n-      bool ok = context->lookup_builtin (\"f64\", &type);\n-      rust_assert (ok);\n-\n-      for (auto &impl : associated_impl_traits)\n-\t{\n-\t  bool found = impl->get_self ()->is_equal (*type);\n-\t  if (found)\n-\t    {\n-\t      associate_impl_trait = impl;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  if (associate_impl_trait == nullptr)\n-    {\n-      // go for the first one? or error out?\n-      auto &mappings = *Analysis::Mappings::get ();\n-      const auto &type_param = subst.get_generic_param ();\n-      const auto *trait_ref = bound.get ();\n-\n-      RichLocation r (type_param.get_locus ());\n-      r.add_range (bound.get_locus ());\n-      r.add_range (mappings.lookup_location (binding->get_ref ()));\n-\n-      rust_error_at (r, \"ambiguous type bound for trait %s and type %s\",\n-\t\t     trait_ref->get_name ().c_str (),\n-\t\t     binding->get_name ().c_str ());\n-\n-      *error_flag = true;\n-      return nullptr;\n-    }\n-\n-  return associate_impl_trait;\n-}\n-\n void\n SubstitutionRef::prepare_higher_ranked_bounds ()\n {\n@@ -987,16 +861,31 @@ SubstitutionRef::monomorphize ()\n \n       for (const auto &bound : pty->get_specified_bounds ())\n \t{\n-\t  bool error_flag = false;\n+\t  bool ambigious = false;\n \t  auto associated\n-\t    = lookup_associated_impl (subst, bound, binding, &error_flag);\n+\t    = Resolver::lookup_associated_impl_block (bound, binding,\n+\t\t\t\t\t\t      &ambigious);\n+\t  if (associated == nullptr && ambigious)\n+\t    {\n+\t      // go for the first one? or error out?\n+\t      auto &mappings = *Analysis::Mappings::get ();\n+\t      const auto &type_param = subst.get_generic_param ();\n+\t      const auto *trait_ref = bound.get ();\n+\n+\t      RichLocation r (type_param.get_locus ());\n+\t      r.add_range (bound.get_locus ());\n+\t      r.add_range (mappings.lookup_location (binding->get_ref ()));\n+\n+\t      rust_error_at (r, \"ambiguous type bound for trait %s and type %s\",\n+\t\t\t     trait_ref->get_name ().c_str (),\n+\t\t\t     binding->get_name ().c_str ());\n+\t      return false;\n+\t    }\n+\n \t  if (associated != nullptr)\n \t    {\n \t      associated->setup_associated_types (binding, bound);\n \t    }\n-\n-\t  if (error_flag)\n-\t    return false;\n \t}\n     }\n "}, {"sha": "0bbb164b8d56aa379f83908cac2db478220375ee", "filename": "gcc/rust/typecheck/rust-tyty-subst.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13032e55c0bd39557c6366729e4afca3890c6c1/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13032e55c0bd39557c6366729e4afca3890c6c1/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-subst.h?ref=c13032e55c0bd39557c6366729e4afca3890c6c1", "patch": "@@ -318,10 +318,6 @@ class SubstitutionRef\n   SubstitutionArgumentMappings get_used_arguments () const;\n \n protected:\n-  Resolver::AssociatedImplTrait *lookup_associated_impl (\n-    const SubstitutionParamMapping &subst, const TypeBoundPredicate &bound,\n-    const TyTy::BaseType *binding, bool *error_flag) const;\n-\n   std::vector<SubstitutionParamMapping> substitutions;\n   SubstitutionArgumentMappings used_arguments;\n };"}, {"sha": "5daf1ca40c5e44a500acf33f089b3b5234fadeb5", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c13032e55c0bd39557c6366729e4afca3890c6c1/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c13032e55c0bd39557c6366729e4afca3890c6c1/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=c13032e55c0bd39557c6366729e4afca3890c6c1", "patch": "@@ -438,6 +438,8 @@ class TypeBoundPredicate : public SubstitutionRef\n   TypeBoundPredicateItem\n   lookup_associated_type (const std::string &search) override final;\n \n+  bool is_equal (const TypeBoundPredicate &other) const;\n+\n private:\n   DefId reference;\n   Location locus;"}]}