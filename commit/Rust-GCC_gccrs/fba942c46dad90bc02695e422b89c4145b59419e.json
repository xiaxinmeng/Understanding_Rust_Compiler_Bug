{"sha": "fba942c46dad90bc02695e422b89c4145b59419e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJhOTQyYzQ2ZGFkOTBiYzAyNjk1ZTQyMmI4OWM0MTQ1YjU5NDE5ZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-10-13T23:07:05Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-10-13T23:07:05Z"}, "message": "Now includes reload.h.\n\n(spec_reg_operand): Validate mode and know that some regs support\nMODE_PARTIAL_INT and some MODE_INT.\n(call_operand, reload_memory_operand, a29k_get_reloaded_address)\n New functions.\n(in_operand): Allow constants with MODE_PARTIAL_INT.\n(out_operand): Allow special registers with any mode.\nAny MEM a word or wider is valid.\n(extend_operator): Deleted.\n(secondary_reload_class): A pseudo is the same as memory; we need\nBP_REGS for multi-word memory or for bytes and halfword if -mndw.\n(print_operand): Delete %X; add %m.\n(print_operand, case 'F'): Check for SYMBOL_REF.\n\nFrom-SVN: r2443", "tree": {"sha": "9c4690ca7f216ad34e4002f7401431b85fae914c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c4690ca7f216ad34e4002f7401431b85fae914c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fba942c46dad90bc02695e422b89c4145b59419e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fba942c46dad90bc02695e422b89c4145b59419e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fba942c46dad90bc02695e422b89c4145b59419e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fba942c46dad90bc02695e422b89c4145b59419e/comments", "author": null, "committer": null, "parents": [{"sha": "be71bebdc0ea12148940dbb8d7dc8c9ac4f20c67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be71bebdc0ea12148940dbb8d7dc8c9ac4f20c67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be71bebdc0ea12148940dbb8d7dc8c9ac4f20c67"}], "stats": {"total": 127, "additions": 102, "deletions": 25}, "files": [{"sha": "ad1a62035ecf5dedf89fb23333bd4f29c239efa8", "filename": "gcc/config/a29k/a29k.c", "status": "modified", "additions": 102, "deletions": 25, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fba942c46dad90bc02695e422b89c4145b59419e/gcc%2Fconfig%2Fa29k%2Fa29k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fba942c46dad90bc02695e422b89c4145b59419e/gcc%2Fconfig%2Fa29k%2Fa29k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fa29k%2Fa29k.c?ref=fba942c46dad90bc02695e422b89c4145b59419e", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used for code generation on AMD Am29000.\n-   Copyright (C) 1987, 1988, 1990, 1991 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1990, 1991, 1992 Free Software Foundation, Inc.\n    Contributed by Richard Kenner (kenner@nyu.edu)\n \n This file is part of GNU CC.\n@@ -34,6 +34,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"expr.h\"\n #include \"obstack.h\"\n #include \"tree.h\"\n+#include \"reload.h\"\n \n #define min(A,B)\t((A) < (B) ? (A) : (B))\n \n@@ -99,7 +100,7 @@ cint_16_operand (op, mode)\n   return GET_CODE (op) == CONST_INT && (INTVAL (op) & 0xffff0000) == 0;\n }\n \n-/* Returns 1 if OP cannot be moved in a single insn.  */\n+/* Returns 1 if OP is a constant that cannot be moved in a single insn.  */\n \n int\n long_const_operand (op, mode)\n@@ -210,8 +211,18 @@ spec_reg_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  return GET_MODE (op) == SImode && GET_CODE (op) == REG\n-\t && REGNO (op) >= R_BP && REGNO (op) <= R_EXO;\n+  if (GET_CODE (op) != REG || GET_MODE (op) != mode)\n+    return 0;\n+\n+  switch (GET_MODE_CLASS (mode))\n+    {\n+    case MODE_PARTIAL_INT:\n+      return REGNO (op) >= R_BP && REGNO (op) <= R_CR;\n+    case MODE_INT:\n+      return REGNO (op) >= R_Q && REGNO (op) <= R_EXO;\n+    detault:\n+      return 0;\n+    }\n }\n \n /* Returns 1 if OP is an accumulator register.  */\n@@ -307,6 +318,29 @@ add_operand (op, mode)\n \t  || (GET_CODE (op) == CONST_INT\n \t      && ((unsigned) ((- INTVAL (op)) & GET_MODE_MASK (mode)) < 256)));\n }\n+\n+/* Return 1 if OP is a valid address in a CALL_INSN.  These are a SYMBOL_REF\n+   to the current function, all SYMBOL_REFs if TARGET_SMALL_MEMORY, or\n+   a sufficiently-small constant.  */\n+\n+int\n+call_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF:\n+      return (TARGET_SMALL_MEMORY\n+\t      || ! strcmp (XSTR (op, 0), current_function_name));\n+\n+    case CONST_INT:\n+      return (unsigned HOST_WIDE_INT) INTVAL (op) < 0x40000;\n+\n+    default:\n+      return 0;\n+    }\n+}\n \f\n /* Return 1 if OP can be used as the input operand for a move insn.  */\n \n@@ -332,7 +366,8 @@ in_operand (op, mode)\n       return (GET_MODE_SIZE (mode) >= UNITS_PER_WORD || TARGET_DW_ENABLE);\n \n     case CONST_INT:\n-      if (GET_MODE_CLASS (mode) != MODE_INT)\n+      if (GET_MODE_CLASS (mode) != MODE_INT\n+\t  && GET_MODE_CLASS (mode) != MODE_PARTIAL_INT)\n \treturn 0;\n \n       return 1;\n@@ -370,26 +405,51 @@ out_operand (op, mode)\n     op = SUBREG_REG (op);\n \n   if (GET_CODE (op) == REG)\n-    return (mode == SImode || gpc_reg_operand (orig_op, mode)\n+    return (gpc_reg_operand (orig_op, mode)\n+\t    || spec_reg_operand (orig_op, mode)\n \t    || (GET_MODE_CLASS (mode) == MODE_FLOAT\n \t\t&& accum_reg_operand (orig_op, mode)));\n \n   else if (GET_CODE (op) == MEM)\n-    return mode == SImode || mode == SFmode || TARGET_DW_ENABLE;\n-\n+    return (GET_MODE_SIZE (mode) >= UNITS_PER_WORD || TARGET_DW_ENABLE);\n   else\n     return 0;\n }\n \n-/* Return 1 if OP is some extension operator.  */\n+/* Return 1 if OP is an item in memory, given that we are in reload.  */\n \n int\n-extend_operator (op, mode)\n+reload_memory_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  return ((mode == VOIDmode || GET_MODE (op) == mode)\n-\t  && (GET_CODE (op) == ZERO_EXTEND || GET_CODE (op) == SIGN_EXTEND));\n+  int regno = true_regnum (op);\n+\n+  return (! CONSTANT_P (op)\n+\t  && (regno == -1\n+\t      || (GET_CODE (op) == REG\n+\t\t  && REGNO (op) >= FIRST_PSEUDO_REGISTER)));\n+}\n+\n+/* Given an object for which reload_memory_operand is true, return the address\n+   of the operand, taking into account anything that reload may do.  */\n+\n+rtx\n+a29k_get_reloaded_address (op)\n+     rtx op;\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    {\n+      if (SUBREG_WORD (op) != 0)\n+\tabort ();\n+\n+      op = SUBREG_REG (op);\n+    }\n+\n+  if (GET_CODE (op) == REG)\n+    op = reg_equiv_mem[REGNO (op)];\n+\n+  return find_replacement (&XEXP (op, 0));\n }\n \n /* Return 1 if OP is a comparison operator that we have in floating-point.  */\n@@ -591,19 +651,34 @@ secondary_reload_class (class, mode, in)\n      rtx in;\n {\n   int regno = -1;\n+  enum rtx_code code = GET_CODE (in);\n+\n+  if (! CONSTANT_P (in))\n+    {\n+      regno = true_regnum (in);\n \n-  if (GET_CODE (in) == REG || GET_CODE (in) == SUBREG)\n-    regno = true_regnum (in);\n+      /* A pseudo is the same as memory.  */\n+      if (regno == -1 || regno >= FIRST_PSEUDO_REGISTER)\n+\tcode = MEM;\n+    }\n+\n+  /* If we are transferring between memory and a multi-word mode or between\n+     memory and a mode smaller than a word without DW being enabled, we need\n+     BP.  */\n+\n+  if (code == MEM\n+      && (GET_MODE_SIZE (mode) > UNITS_PER_WORD\n+\t  || (! TARGET_DW_ENABLE && GET_MODE_SIZE (mode) < UNITS_PER_WORD)))\n+    return BP_REGS;\n \n-  /* We can place anything into GENERAL_REGS and can put GENERAL_REGS\n-     into anything.  */\n+  /* Otherwise, we can place anything into GENERAL_REGS and can put\n+     GENERAL_REGS into anything.  */\n   if (class == GENERAL_REGS || (regno != -1 && regno < R_BP))\n     return NO_REGS;\n \n   /* We can place 16-bit constants into a special register.  */\n-  if (GET_CODE (in) == CONST_INT\n-      && (GET_MODE_BITSIZE (mode) <= 16\n-\t  || (unsigned) INTVAL (in) <= 65535)\n+  if (code == CONST_INT\n+      && (GET_MODE_BITSIZE (mode) <= 16 || (unsigned) INTVAL (in) <= 65535)\n       && (class == BP_REGS || class == Q_REGS || class == SPECIAL_REGS))\n     return NO_REGS;\n \n@@ -739,8 +814,8 @@ null_epilogue ()\n \t%N means write the low-order 8 bits of the negative of the constant\n \t%Q means write a QImode operand (truncate constants to 8 bits)\n \t%M means write the low-order 16 bits of the constant\n+\t%m means write the low-order 16 bits shifted left 16 bits\n \t%C means write the low-order 8 bits of the complement of the constant\n-\t%X means write the cntl values for LOAD with operand an extension op\n \t%b means write `f' is this is a reversed condition, `t' otherwise\n \t%B means write `t' is this is a reversed condition, `f' otherwise\n \t%J means write the 29k opcode part for a comparison operation\n@@ -807,11 +882,12 @@ print_operand (file, x, code)\n       fprintf (file, \"%d\", INT_LOWPART (x) & 0xffff);\n       return;\n \n-    case 'X':\n-      fprintf (file, \"%d\", ((GET_MODE (XEXP (x, 0)) == QImode ? 1 : 2)\n-\t\t\t    + (GET_CODE (x) == SIGN_EXTEND ? 16 : 0)));\n+    case 'm':\n+      if (! INT_P (x))\n+\toutput_operand_lossage (\"invalid %%m value\");\n+      fprintf (file, \"%d\", (INT_LOWPART (x) & 0xffff) << 16);\n       return;\n-  \n+\n     case 'b':\n       if (GET_CODE (x) == GE)\n \tfprintf (file, \"f\");\n@@ -878,7 +954,8 @@ print_operand (file, x, code)\n       output_addr_const (file, x);\n       if (dbr_sequence_length () == 0)\n \t{\n-\t  if (! strcmp (XSTR (x, 0), current_function_name))\n+\t  if (GET_CODE (x) == SYMBOL_REF\n+\t      && ! strcmp (XSTR (x, 0), current_function_name))\n \t    fprintf (file, \"+4\\n\\t%s,%d\",\n \t\t     a29k_regstack_size >= 64 ? \"const gr121\" : \"sub gr1,gr1\",\n \t\t     a29k_regstack_size * 4);"}]}