{"sha": "5412ef6bba5b252ccb88f778025e6c21cc075883", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTQxMmVmNmJiYTViMjUyY2NiODhmNzc4MDI1ZTZjMjFjYzA3NTg4Mw==", "commit": {"author": {"name": "Per Bothner", "email": "per@bothner.com", "date": "2001-12-06T23:12:55Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "2001-12-06T23:12:55Z"}, "message": "Restore support for static class initialization optimization.\n\nFrom-SVN: r47735", "tree": {"sha": "0329e48c15d6e4c56f175ddff6166ec1395400e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0329e48c15d6e4c56f175ddff6166ec1395400e4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5412ef6bba5b252ccb88f778025e6c21cc075883", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5412ef6bba5b252ccb88f778025e6c21cc075883", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5412ef6bba5b252ccb88f778025e6c21cc075883", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5412ef6bba5b252ccb88f778025e6c21cc075883/comments", "author": {"login": "PerBothner", "id": 10293361, "node_id": "MDQ6VXNlcjEwMjkzMzYx", "avatar_url": "https://avatars.githubusercontent.com/u/10293361?v=4", "gravatar_id": "", "url": "https://api.github.com/users/PerBothner", "html_url": "https://github.com/PerBothner", "followers_url": "https://api.github.com/users/PerBothner/followers", "following_url": "https://api.github.com/users/PerBothner/following{/other_user}", "gists_url": "https://api.github.com/users/PerBothner/gists{/gist_id}", "starred_url": "https://api.github.com/users/PerBothner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/PerBothner/subscriptions", "organizations_url": "https://api.github.com/users/PerBothner/orgs", "repos_url": "https://api.github.com/users/PerBothner/repos", "events_url": "https://api.github.com/users/PerBothner/events{/privacy}", "received_events_url": "https://api.github.com/users/PerBothner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c1bf99a2ab955f1b5945ceb0f62a4e1652fe0c02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1bf99a2ab955f1b5945ceb0f62a4e1652fe0c02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1bf99a2ab955f1b5945ceb0f62a4e1652fe0c02"}], "stats": {"total": 164, "additions": 93, "deletions": 71}, "files": [{"sha": "e2d32fc1fb4a9d9f299644ff5628da372d0b8926", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5412ef6bba5b252ccb88f778025e6c21cc075883/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5412ef6bba5b252ccb88f778025e6c21cc075883/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=5412ef6bba5b252ccb88f778025e6c21cc075883", "patch": "@@ -1,3 +1,30 @@\n+2001-12-05  Per Bothner  <per@bothner.com>\n+\n+\tRestore support for static class initialization optimization.\n+\t* java-tree.h (STATIC_CLASS_INIT_OPT_P): Re-enable.\n+\t* check-init.c (check_int):  At end of BLOCK handle initialization\n+\tblocks, which used to be done in java_complete_expand_method but did\n+\tnot handle the case where check_for_initialization might allocate\n+\tmore than a word of bits.\n+\t* decl.c (lang_make_tree):  The smic field is now a tree.\n+\t* expr.c (build_class_init):  Set DECL_FUNCTION_INIT_TEST_CLASS field.\n+\t* java-tree.h (DECL_FUNCTION_INIT_TEST_TABLE):  New macro.\n+\n+\t* parse.y (emit_test_initialization):  Combine hash_lookup calls.\n+\n+\t* java-tree.h (DECL_FUNCTION_STATIC_METHOD_INVOCATION_COMPOUND):\n+\tChange from a hash table to a list.\n+\t(struct_lang_decl):  Change field 'smic' to match.\n+\t* class.c (add_method_1):  Initialize\n+\tDECL_FUNCTION_STATIC_METHOD_INVOCATION_COMPOUND to null list.\n+\t* parse.y (adjust_init_test_initialization):  Removed - inlined into -\n+\t(java_expand_method_bodies): -here, since 'smic' is now a list.\n+\t(patch_invoke):  Add to 'smic' list, instead of hash_lookup.\n+\n+\t* check-init.c (WORD_SIZE):  Use BITS_PER_UNIT.\n+\n+\t* class.c (java_hash_compare_tree_node):  Fix casts.\n+\n 2001-12-04  Per Bothner  <per@bothner.com>\n \n \t* check-init.c:   Handle definite unassignment to finals in addition"}, {"sha": "1db19b96dd9e029e79f105dc62b4416587200da6", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5412ef6bba5b252ccb88f778025e6c21cc075883/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5412ef6bba5b252ccb88f778025e6c21cc075883/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=5412ef6bba5b252ccb88f778025e6c21cc075883", "patch": "@@ -96,7 +96,7 @@ static tree wfl;\n #define INTERSECT(DST, SRC1, SRC2) \\\n   INTERSECTN (DST, SRC1, SRC2, num_current_words)\n \n-#define WORD_SIZE  ((unsigned int)(sizeof(word) * 8))\n+#define WORD_SIZE  ((unsigned int)(sizeof(word) * BITS_PER_UNIT))\n \n static void check_bool_init PARAMS ((tree, words, words, words));\n static void check_init PARAMS ((tree, words));\n@@ -595,6 +595,24 @@ check_init (exp, before)\n \t      SET_UNASSIGNED (tmp, i);\n \t    }\n \t  check_init (BLOCK_EXPR_BODY (exp), tmp);\n+\n+\t  /* Re-set DECL_BIT_INDEX since it is also DECL_POINTER_ALIAS_SET. */\n+\t  for (decl = BLOCK_EXPR_DECLS (exp);\n+\t       decl != NULL_TREE;  decl = TREE_CHAIN (decl))\n+\t    {\n+\t      if (LOCAL_CLASS_INITIALIZATION_FLAG_P (decl))\n+\t\t{\n+\t\t  int index = DECL_BIT_INDEX (decl);\n+\t\t  tree fndecl = DECL_CONTEXT (decl);\n+\t\t  if (fndecl && METHOD_STATIC (fndecl)\n+\t\t      && (DECL_INITIAL (decl) == boolean_true_node\n+\t\t\t  || (index >= 0 && ASSIGNED_P (tmp, index))))\n+\t\t    hash_lookup (&DECL_FUNCTION_INITIALIZED_CLASS_TABLE (fndecl),\n+\t\t\t\t DECL_FUNCTION_INIT_TEST_CLASS(decl), TRUE, NULL);  \n+\t\t}\n+\t      DECL_BIT_INDEX (decl) = -1;\n+\t    }\n+\n \t  num_current_locals = start_current_locals;\n \t  start_current_locals = save_start_current_locals;\n \t  if (tmp != before)\n@@ -603,13 +621,6 @@ check_init (exp, before)\n \t      COPY (before, tmp);\n \t      FREE_WORDS (tmp);\n \t    }\n-\n-\t  /* Re-set DECL_BIT_INDEX since it is also DECL_POINTER_ALIAS_SET. */\n-\t  for (decl = BLOCK_EXPR_DECLS (exp);\n-\t       decl != NULL_TREE;  decl = TREE_CHAIN (decl))\n-\t    {\n-\t      DECL_BIT_INDEX (decl) = -1;\n-\t    }\n \t}\n       break;\n     case LOOP_EXPR:"}, {"sha": "3d691bc9d583087638d540af8b07e0c6380a3866", "filename": "gcc/java/class.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5412ef6bba5b252ccb88f778025e6c21cc075883/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5412ef6bba5b252ccb88f778025e6c21cc075883/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=5412ef6bba5b252ccb88f778025e6c21cc075883", "patch": "@@ -656,7 +656,7 @@ java_hash_compare_tree_node (k1, k2)\n      hash_table_key k1;\n      hash_table_key k2;\n {\n-  return ((char*) k1 == (char*) k2);\n+  return ((tree) k1 == (tree) k2);\n }\n \n tree\n@@ -688,11 +688,8 @@ add_method_1 (handle_class, access_flags, name, function_type)\n \t\t     init_test_hash_newfunc, java_hash_hash_tree_node,\n \t\t     java_hash_compare_tree_node);\n \n-  /* Initialize the static method invocation compound table */\n-  if (STATIC_CLASS_INIT_OPT_P ())\n-    hash_table_init (&DECL_FUNCTION_STATIC_METHOD_INVOCATION_COMPOUND (fndecl),\n-\t\t     init_test_hash_newfunc, java_hash_hash_tree_node,\n-\t\t     java_hash_compare_tree_node);\n+  /* Initialize the static method invocation compound list */\n+  DECL_FUNCTION_STATIC_METHOD_INVOCATION_COMPOUND (fndecl) = NULL_TREE;\n \n   TREE_CHAIN (fndecl) = TYPE_METHODS (handle_class);\n   TYPE_METHODS (handle_class) = fndecl;"}, {"sha": "0b1e0164116c331e25e8560877aaedd8c36904ec", "filename": "gcc/java/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5412ef6bba5b252ccb88f778025e6c21cc075883/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5412ef6bba5b252ccb88f778025e6c21cc075883/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=5412ef6bba5b252ccb88f778025e6c21cc075883", "patch": "@@ -1847,7 +1847,7 @@ lang_mark_tree (t)\n \t  ggc_mark_tree (ld->inner_access);\n \t  ggc_mark_tree_hash_table (&ld->init_test_table);\n \t  ggc_mark_tree_hash_table (&ld->ict);\n-\t  ggc_mark_tree_hash_table (&ld->smic);\n+\t  ggc_mark_tree (ld->smic);\n \t}\n     }\n   else if (TYPE_P (t))"}, {"sha": "f865d95800894d857189a6cd587202065f6d2645", "filename": "gcc/java/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5412ef6bba5b252ccb88f778025e6c21cc075883/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5412ef6bba5b252ccb88f778025e6c21cc075883/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=5412ef6bba5b252ccb88f778025e6c21cc075883", "patch": "@@ -1729,7 +1729,7 @@ build_class_init (clas, expr)\n \t  MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (ite->init_test_decl);\n \t  LOCAL_CLASS_INITIALIZATION_FLAG (ite->init_test_decl) = 1;\n \t  DECL_CONTEXT (ite->init_test_decl) = current_function_decl;\n-\n+\t  DECL_FUNCTION_INIT_TEST_CLASS (ite->init_test_decl) = clas;\n \t  /* Tell the check-init code to ignore this decl when not\n              optimizing class initialization. */\n \t  if (!STATIC_CLASS_INIT_OPT_P ())"}, {"sha": "f28696384720a4efc95f084bc41eb4155a9f79b1", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5412ef6bba5b252ccb88f778025e6c21cc075883/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5412ef6bba5b252ccb88f778025e6c21cc075883/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=5412ef6bba5b252ccb88f778025e6c21cc075883", "patch": "@@ -726,14 +726,17 @@ struct lang_identifier\n    class has been initialized in this function, and FALSE otherwise.  */\n #define DECL_FUNCTION_INIT_TEST_TABLE(DECL) \\\n   (DECL_LANG_SPECIFIC(DECL)->init_test_table)\n+/* If LOCAL_CLASS_INITIALIZATION_FLAG_P(decl), give class it initializes. */\n+#define DECL_FUNCTION_INIT_TEST_CLASS(DECL) \\\n+  (((struct lang_decl_var*)DECL_LANG_SPECIFIC(DECL))->slot_chain)\n /* For each static function decl, itc contains a hash table whose\n    entries are keyed on class named that are definitively initialized\n    in DECL.  */\n #define DECL_FUNCTION_INITIALIZED_CLASS_TABLE(DECL) \\\n   (DECL_LANG_SPECIFIC(DECL)->ict)\n-/* For each static function call, smic contains contains a hash table\n-   whose entries are keyed on the compound statement that encapsulate\n-   the invocation.  */\n+/* A list of all the static method calls in the method DECL (if optimizing).\n+   Actually each TREE_VALUE points to a COMPONT_EXPR that wraps the\n+   invoation so we can later patch it. */\n #define DECL_FUNCTION_STATIC_METHOD_INVOCATION_COMPOUND(DECL) \\\n   (DECL_LANG_SPECIFIC(DECL)->smic)\n /* The Number of Artificial Parameters (NAP) DECL contains. this$<n>\n@@ -888,7 +891,7 @@ struct lang_decl\n   struct hash_table init_test_table;\n \t\t\t\t/* Class initialization test variables  */\n   struct hash_table ict;\t/* Initialized (static) Class Table */\n-  struct hash_table smic;\t/* Static method invocation compound */\n+  tree smic;\t\t\t/* Static method invocation compound */\n   tree inner_access;\t\t/* The identifier of the access method\n \t\t\t\t   used for invocation from inner classes */\n   int nap;\t\t\t/* Number of artificial parameters */\n@@ -1604,8 +1607,7 @@ extern tree *type_map;\n \n /* True when we can perform static class initialization optimization */\n #define STATIC_CLASS_INIT_OPT_P() \\\n-  0 /* ??? Temporarily turn off this optimization -PB */\n-/*  (flag_optimize_sci && (optimize >= 2) && ! flag_emit_class_files)*/\n+  (flag_optimize_sci && (optimize >= 2) && ! flag_emit_class_files)\n \n extern int java_error_count;\n "}, {"sha": "80c60fd570c95b775d118b5031904f85daa86b06", "filename": "gcc/java/parse.y", "status": "modified", "additions": 34, "deletions": 49, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5412ef6bba5b252ccb88f778025e6c21cc075883/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5412ef6bba5b252ccb88f778025e6c21cc075883/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=5412ef6bba5b252ccb88f778025e6c21cc075883", "patch": "@@ -335,8 +335,6 @@ static tree maybe_build_class_init_for_field PARAMS ((tree, tree));\n \n static bool attach_init_test_initialization_flags PARAMS ((struct hash_entry *,\n \t\t\t\t\t\t\t  PTR));\n-static bool adjust_init_test_initialization PARAMS ((struct hash_entry *,\n-\t\t\t\t\t\t     PTR));\n static bool emit_test_initialization PARAMS ((struct hash_entry *, PTR));\n \n /* Number of error found so far. */\n@@ -8017,21 +8015,16 @@ java_complete_expand_method (mdecl)\n \t     static variables and see whether they're definitively\n \t     assigned, in which case the type is remembered as\n \t     definitively initialized in MDECL. */\n-\t  /* FIXME this doesn't work state is too short.\n \t  if (STATIC_CLASS_INIT_OPT_P ())\n \t    {\n-\t      hash_traverse (&DECL_FUNCTION_INIT_TEST_TABLE (mdecl),\n-\t\t\t     attach_initialized_static_class, (PTR)&state);\n-\n-\t      / * Always register the context as properly initialized in\n+\t      /* Always register the context as properly initialized in\n \t\t MDECL. This used with caution helps removing extra\n-\t\t initialization of self. * /\n+\t\t initialization of self. */\n \t      if (METHOD_STATIC (mdecl))\n \t\thash_lookup (&DECL_FUNCTION_INITIALIZED_CLASS_TABLE (mdecl),\n \t\t\t     (hash_table_key) DECL_CONTEXT (mdecl),\n \t\t\t     TRUE, NULL);\n \t    }\n-\t  */\n \t}\n       ctxp->explicit_constructor_p = 0;\n     }\n@@ -8081,8 +8074,32 @@ java_expand_method_bodies (class)\n \t initialization based on which classes invoked static methods\n \t are definitely initializing. This should be flagged. */\n       if (STATIC_CLASS_INIT_OPT_P ())\n-\thash_traverse (&DECL_FUNCTION_STATIC_METHOD_INVOCATION_COMPOUND (decl),\n-\t\t       adjust_init_test_initialization, NULL);\n+\t{\n+\t  tree list = DECL_FUNCTION_STATIC_METHOD_INVOCATION_COMPOUND (decl);\n+\t  for (; list != NULL_TREE;  list = TREE_CHAIN (list))\n+\t    {\n+\t      /* Executed for each statement calling a static function.\n+\t\t LIST is a TREE_LIST whose PURPOSE is the called function\n+\t\t and VALUE is a compound whose second operand can be patched\n+\t\t with static class initialization flag assignments.  */\n+\n+\t      tree called_method = TREE_PURPOSE (list);\n+\t      tree compound = TREE_VALUE (list);\n+\t      tree assignment_compound_list\n+\t\t= build_tree_list (called_method, NULL);\n+\n+\t      /* For each class definitely initialized in\n+\t\t CALLED_METHOD, fill ASSIGNMENT_COMPOUND with\n+\t\t assignment to the class initialization flag. */\n+\t      hash_traverse (&DECL_FUNCTION_INITIALIZED_CLASS_TABLE (called_method),\n+\t\t\t     emit_test_initialization,\n+\t\t\t     assignment_compound_list);\n+\n+\t      if (TREE_VALUE (assignment_compound_list))\n+\t\tTREE_OPERAND (compound, 1)\n+\t\t  = TREE_VALUE (assignment_compound_list);\n+\t    }\n+\t}\n \n       /* Prepare the function for RTL expansion */  \n       start_complete_expand_method (decl);\n@@ -10691,10 +10708,10 @@ patch_invoke (patch, method, args)\n       tree type = TREE_TYPE (patch);\n \n       patch = build (COMPOUND_EXPR, type, save, empty_stmt_node);\n-      list = build_tree_list (method, patch);\n+      list = tree_cons (method, patch,\n+\t\t\tDECL_FUNCTION_STATIC_METHOD_INVOCATION_COMPOUND (fndecl));\n \n-      hash_lookup (&DECL_FUNCTION_STATIC_METHOD_INVOCATION_COMPOUND (fndecl),\n-\t\t   (const hash_table_key) list, TRUE, NULL);\n+      DECL_FUNCTION_STATIC_METHOD_INVOCATION_COMPOUND (fndecl) = list;\n \n       patch = build (COMPOUND_EXPR, type, patch, save);\n     }\n@@ -15974,32 +15991,6 @@ attach_init_test_initialization_flags (entry, ptr)\n   return true;\n }\n \n-/* This function is called for each statement calling a static\n-   function.  ENTRY is a TREE_LIST whose PURPOSE is the called\n-   function and VALUE is a compound whose second operand can be\n-   patched with static class initialization flag assignments.  */\n-\n-static bool\n-adjust_init_test_initialization (entry, info)\n-     struct hash_entry *entry;\n-     PTR info ATTRIBUTE_UNUSED;\n-{\n-  tree list = (tree)(entry->key);\n-  tree called_method = TREE_PURPOSE (list);\n-  tree compound = TREE_VALUE (list);\n-  tree assignment_compound_list = build_tree_list (called_method, NULL);\n-\n-  /* For each class definitely initialized in CALLED_METHOD, fill\n-     ASSIGNMENT_COMPOUND with assignment to the class initialization flag. */\n-  hash_traverse (&DECL_FUNCTION_INITIALIZED_CLASS_TABLE (called_method),\n-\t\t emit_test_initialization, assignment_compound_list);\n-\n-  if (TREE_VALUE (assignment_compound_list))\n-    TREE_OPERAND (compound, 1) = TREE_VALUE (assignment_compound_list);\n-\n-  return true;\n-}\n-\n /* This function is called for each classes that is known definitely\n    assigned when a given static method was called. This function\n    augments a compound expression (INFO) storing all assignment to\n@@ -16016,21 +16007,15 @@ emit_test_initialization (entry, info)\n \n   struct init_test_hash_entry *ite = (struct init_test_hash_entry *)\n     hash_lookup (&DECL_FUNCTION_INIT_TEST_TABLE (current_function_decl),\n-\t\t entry->key, FALSE, NULL);\n+\t\t entry->key,\n+\t\t current_function_decl != TREE_PURPOSE (l), NULL);\n \n   /* If we haven't found a flag and we're dealing with self registered\n      with current_function_decl, then don't do anything. Self is\n      always added as definitely initialized but this information is\n      valid only if used outside the current function. */\n   if (! ite)\n-    {\n-      if (current_function_decl != TREE_PURPOSE (l))\n-\tite = (struct init_test_hash_entry *)\n-\t  hash_lookup (&DECL_FUNCTION_INIT_TEST_TABLE (current_function_decl),\n-\t\t       entry->key, TRUE, NULL);\n-      else\n-\treturn true;\n-    }\n+    return true;\n \n   /* If we don't have a variable, create one and install it. */\n   if (! ite->init_test_decl)"}]}