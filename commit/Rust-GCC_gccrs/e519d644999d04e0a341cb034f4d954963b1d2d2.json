{"sha": "e519d644999d04e0a341cb034f4d954963b1d2d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTUxOWQ2NDQ5OTlkMDRlMGEzNDFjYjAzNGY0ZDk1NDk2M2IxZDJkMg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2020-03-24T14:45:50Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2020-03-26T10:59:34Z"}, "message": "arm: unified syntax for libgcc when built with -Os [PR94220]\n\nThe recent patch to convert all thumb1 code in libgcc to unified syntax\nommitted the conditional code that is used only when building the library\nfor minimal size.  This patch fixes this case.\n\nI've also fixed the COND macro so that a single definition is always used\nthat is for unified syntax.  This eliminates a warning that is now being\nseen from the assembler when compiling the ieee fp support code.\n\n\tPR target/94220\n\t* config/arm/lib1funcs.asm (COND): Use a single definition for\n\tunified syntax.\n\t(aeabi_uidivmod): Unified syntax when optimizing Thumb for size.\n\t(aeabi_idivmod): Likewise.\n\t(divsi3_skip_div0_test): Likewise.", "tree": {"sha": "5bbe0a2a3222befaa74d229212d89eab5876ddba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bbe0a2a3222befaa74d229212d89eab5876ddba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e519d644999d04e0a341cb034f4d954963b1d2d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e519d644999d04e0a341cb034f4d954963b1d2d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e519d644999d04e0a341cb034f4d954963b1d2d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e519d644999d04e0a341cb034f4d954963b1d2d2/comments", "author": null, "committer": null, "parents": [{"sha": "40cdcddf274e3944205ef2d03528bd14e48a9c76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40cdcddf274e3944205ef2d03528bd14e48a9c76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40cdcddf274e3944205ef2d03528bd14e48a9c76"}], "stats": {"total": 42, "additions": 26, "deletions": 16}, "files": [{"sha": "e81e876bc007375a77cf37744f74d593125792a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e519d644999d04e0a341cb034f4d954963b1d2d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e519d644999d04e0a341cb034f4d954963b1d2d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e519d644999d04e0a341cb034f4d954963b1d2d2", "patch": "@@ -1,3 +1,12 @@\n+2020-03-26  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tPR target/94220\n+\t* config/arm/lib1funcs.asm (COND): Use a single definition for\n+\tunified syntax.\n+\t(aeabi_uidivmod): Unified syntax when optimizing Thumb for size.\n+\t(aeabi_idivmod): Likewise.\n+\t(divsi3_skip_div0_test): Likewise.\n+\n 2020-03-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/94323"}, {"sha": "a094417e786029639db04e2da5fa4bc7fdbd7efb", "filename": "libgcc/config/arm/lib1funcs.S", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e519d644999d04e0a341cb034f4d954963b1d2d2/libgcc%2Fconfig%2Farm%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e519d644999d04e0a341cb034f4d954963b1d2d2/libgcc%2Fconfig%2Farm%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Farm%2Flib1funcs.S?ref=e519d644999d04e0a341cb034f4d954963b1d2d2", "patch": "@@ -226,7 +226,6 @@ LSYM(Lend_fde):\n .endm\n #define do_push\tpush\n #define do_pop\tpop\n-#define COND(op1, op2, cond) op1 ## op2 ## cond\n /* Perform an arithmetic operation with a variable shift operand.  This\n    requires two instructions and a scratch register on Thumb-2.  */\n .macro shiftop name, dest, src1, src2, shiftop, shiftreg, tmp\n@@ -241,12 +240,13 @@ LSYM(Lend_fde):\n .endm\n #define do_push\tstmfd sp!,\n #define do_pop\tldmfd sp!,\n-#define COND(op1, op2, cond) op1 ## cond ## op2\n .macro shiftop name, dest, src1, src2, shiftop, shiftreg, tmp\n \t\\name \\dest, \\src1, \\src2, \\shiftop \\shiftreg\n .endm\n #endif\n \n+#define COND(op1, op2, cond) op1 ## op2 ## cond\n+\n #ifdef __ARM_EABI__\n .macro ARM_LDIV0 name signed\n \tcmp\tr0, #0\n@@ -494,7 +494,8 @@ pc\t\t.req\tr15\n \n /* ------------------------------------------------------------------------ */\n /*\t\tBodies of the division and modulo routines.\t\t    */\n-/* ------------------------------------------------------------------------ */\t\n+/* ------------------------------------------------------------------------ */\n+\n .macro ARM_DIV_BODY dividend, divisor, result, curbit\n \n #if defined (__ARM_FEATURE_CLZ) && ! defined (__OPTIMIZE_SIZE__)\n@@ -1136,8 +1137,8 @@ FUNC_START aeabi_uidivmod\n \tpush\t{r0, r1, lr}\n \tbl\tLSYM(udivsi3_skip_div0_test)\n \tPOP\t{r1, r2, r3}\n-\tmul\tr2, r0\n-\tsub\tr1, r1, r2\n+\tmuls\tr2, r0\n+\tsubs\tr1, r1, r2\n \tbx\tr3\n # else\n \t/* Both the quotient and remainder are calculated simultaneously\n@@ -1151,7 +1152,7 @@ FUNC_START aeabi_uidivmod\n ARM_FUNC_START aeabi_uidivmod\n \tcmp\tr1, #0\n \tbeq\tLSYM(Ldiv0)\n-\tmov     r2, r0 \n+\tmov     r2, r0\n \tudiv\tr0, r0, r1\n \tmls     r1, r0, r1, r2\n \tRET\n@@ -1235,29 +1236,29 @@ LSYM(Lover10):\n \tbeq\tLSYM(Ldiv0)\n LSYM(divsi3_skip_div0_test):\n \tpush\t{ work }\n-\tmov\twork, dividend\n-\teor\twork, divisor\t\t@ Save the sign of the result.\n+\tmovs\twork, dividend\n+\teors\twork, divisor\t\t@ Save the sign of the result.\n \tmov\tip, work\n-\tmov\tcurbit, #1\n-\tmov\tresult, #0\n+\tmovs\tcurbit, #1\n+\tmovs\tresult, #0\n \tcmp\tdivisor, #0\n \tbpl\tLSYM(Lover10)\n-\tneg\tdivisor, divisor\t@ Loops below use unsigned.\n+\tnegs\tdivisor, divisor\t@ Loops below use unsigned.\n LSYM(Lover10):\n \tcmp\tdividend, #0\n \tbpl\tLSYM(Lover11)\n-\tneg\tdividend, dividend\n+\tnegs\tdividend, dividend\n LSYM(Lover11):\n \tcmp\tdividend, divisor\n \tblo\tLSYM(Lgot_result)\n \n \tTHUMB_DIV_MOD_BODY 0\n \n-\tmov\tr0, result\n+\tmovs\tr0, result\n \tmov\twork, ip\n \tcmp\twork, #0\n \tbpl\tLSYM(Lover12)\n-\tneg\tr0, r0\n+\tnegs\tr0, r0\n LSYM(Lover12):\n \tpop\t{ work }\n \tRET\n@@ -1348,8 +1349,8 @@ FUNC_START aeabi_idivmod\n \tpush\t{r0, r1, lr}\n \tbl\tLSYM(divsi3_skip_div0_test)\n \tPOP\t{r1, r2, r3}\n-\tmul\tr2, r0\n-\tsub\tr1, r1, r2\n+\tmuls\tr2, r0\n+\tsubs\tr1, r1, r2\n \tbx\tr3\n # else\n \t/* Both the quotient and remainder are calculated simultaneously"}]}