{"sha": "b0f4a35f73d421cac856149de1756a51d833adb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjBmNGEzNWY3M2Q0MjFjYWM4NTYxNDlkZTE3NTZhNTFkODMzYWRiMw==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-07-18T08:49:55Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-07-18T08:49:55Z"}, "message": "tree.h (get_object_or_type_alignment): Remove.\n\n2012-07-18  Richard Guenther  <rguenther@suse.de>\n\n\t* tree.h (get_object_or_type_alignment): Remove.\n\t* builtins.c (get_object_alignment_2): New function copied from\n\tget_object_alignment_1.  Take extra argument to indicate whether\n\twe take the address of EXP.  Rework to use type alignment information\n\tif not, and return whether the result is an approximation or not.\n\t(get_object_alignment_1): Wrap around get_object_alignment_2.\n\t(get_pointer_alignment_1): Call get_object_alignment_2 indicating\n\twe take the address.\n\t(get_object_or_type_alignment): Remove.\n\t* expr.c (expand_assignment): Call get_object_alignment.\n\t(expand_expr_real_1): Likewise.\n\nFrom-SVN: r189607", "tree": {"sha": "49094ac8cd688ab1fd9e8a0126ce952929b0706b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49094ac8cd688ab1fd9e8a0126ce952929b0706b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0f4a35f73d421cac856149de1756a51d833adb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0f4a35f73d421cac856149de1756a51d833adb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0f4a35f73d421cac856149de1756a51d833adb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0f4a35f73d421cac856149de1756a51d833adb3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dad57b685cc668f11a70649b83e6317edd22194a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dad57b685cc668f11a70649b83e6317edd22194a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dad57b685cc668f11a70649b83e6317edd22194a"}], "stats": {"total": 228, "additions": 104, "deletions": 124}, "files": [{"sha": "ff479659b3580bcf29e66f73d6839aa99eabc3c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f4a35f73d421cac856149de1756a51d833adb3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f4a35f73d421cac856149de1756a51d833adb3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b0f4a35f73d421cac856149de1756a51d833adb3", "patch": "@@ -1,3 +1,17 @@\n+2012-07-18  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree.h (get_object_or_type_alignment): Remove.\n+\t* builtins.c (get_object_alignment_2): New function copied from\n+\tget_object_alignment_1.  Take extra argument to indicate whether\n+\twe take the address of EXP.  Rework to use type alignment information\n+\tif not, and return whether the result is an approximation or not.\n+\t(get_object_alignment_1): Wrap around get_object_alignment_2.\n+\t(get_pointer_alignment_1): Call get_object_alignment_2 indicating\n+\twe take the address.\n+\t(get_object_or_type_alignment): Remove.\n+\t* expr.c (expand_assignment): Call get_object_alignment.\n+\t(expand_expr_real_1): Likewise.\n+\n 2012-07-18  Nick Clifton  <nickc@redhat.com>\n \n \t* doc/invoke.texi (ARM Options): Document -munaligned-access."}, {"sha": "4fb3d53aa585213591c258d28881b1b5f9d7539b", "filename": "gcc/builtins.c", "status": "modified", "additions": 86, "deletions": 119, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f4a35f73d421cac856149de1756a51d833adb3/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f4a35f73d421cac856149de1756a51d833adb3/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=b0f4a35f73d421cac856149de1756a51d833adb3", "patch": "@@ -273,11 +273,14 @@ called_as_built_in (tree node)\n    on the address at which an object is actually located.  These two\n    addresses are not always the same.  For example, on ARM targets,\n    the address &foo of a Thumb function foo() has the lowest bit set,\n-   whereas foo() itself starts on an even address.  */\n+   whereas foo() itself starts on an even address.\n \n-bool\n-get_object_alignment_1 (tree exp, unsigned int *alignp,\n-\t\t\tunsigned HOST_WIDE_INT *bitposp)\n+   If ADDR_P is true we are taking the address of the memory reference EXP\n+   and thus cannot rely on the access taking place.  */\n+\n+static bool\n+get_object_alignment_2 (tree exp, unsigned int *alignp,\n+\t\t\tunsigned HOST_WIDE_INT *bitposp, bool addr_p)\n {\n   HOST_WIDE_INT bitsize, bitpos;\n   tree offset;\n@@ -293,48 +296,40 @@ get_object_alignment_1 (tree exp, unsigned int *alignp,\n \n   /* Extract alignment information from the innermost object and\n      possibly adjust bitpos and offset.  */\n-  if (TREE_CODE (exp) == CONST_DECL)\n-    exp = DECL_INITIAL (exp);\n-  if (DECL_P (exp)\n-      && TREE_CODE (exp) != LABEL_DECL)\n-    {\n-      if (TREE_CODE (exp) == FUNCTION_DECL)\n-\t{\n-\t  /* Function addresses can encode extra information besides their\n-\t     alignment.  However, if TARGET_PTRMEMFUNC_VBIT_LOCATION\n-\t     allows the low bit to be used as a virtual bit, we know\n-\t     that the address itself must be 2-byte aligned.  */\n-\t  if (TARGET_PTRMEMFUNC_VBIT_LOCATION == ptrmemfunc_vbit_in_pfn)\n-\t    {\n-\t      known_alignment = true;\n-\t      align = 2 * BITS_PER_UNIT;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  known_alignment = true;\n-\t  align = DECL_ALIGN (exp);\n-\t}\n+  if (TREE_CODE (exp) == FUNCTION_DECL)\n+    {\n+      /* Function addresses can encode extra information besides their\n+\t alignment.  However, if TARGET_PTRMEMFUNC_VBIT_LOCATION\n+\t allows the low bit to be used as a virtual bit, we know\n+\t that the address itself must be at least 2-byte aligned.  */\n+      if (TARGET_PTRMEMFUNC_VBIT_LOCATION == ptrmemfunc_vbit_in_pfn)\n+\talign = 2 * BITS_PER_UNIT;\n     }\n-  else if (CONSTANT_CLASS_P (exp))\n+  else if (TREE_CODE (exp) == LABEL_DECL)\n+    ;\n+  else if (TREE_CODE (exp) == CONST_DECL)\n     {\n-      known_alignment = true;\n+      /* The alignment of a CONST_DECL is determined by its initializer.  */\n+      exp = DECL_INITIAL (exp);\n       align = TYPE_ALIGN (TREE_TYPE (exp));\n #ifdef CONSTANT_ALIGNMENT\n-      align = (unsigned)CONSTANT_ALIGNMENT (exp, align);\n+      if (CONSTANT_CLASS_P (exp))\n+\talign = (unsigned) CONSTANT_ALIGNMENT (exp, align);\n #endif\n+      known_alignment = true;\n     }\n-  else if (TREE_CODE (exp) == VIEW_CONVERT_EXPR)\n+  else if (DECL_P (exp))\n     {\n+      align = DECL_ALIGN (exp);\n       known_alignment = true;\n-      align = TYPE_ALIGN (TREE_TYPE (exp));\n     }\n-  else if (TREE_CODE (exp) == INDIRECT_REF)\n+  else if (TREE_CODE (exp) == VIEW_CONVERT_EXPR)\n     {\n-      known_alignment = true;\n       align = TYPE_ALIGN (TREE_TYPE (exp));\n     }\n-  else if (TREE_CODE (exp) == MEM_REF)\n+  else if (TREE_CODE (exp) == INDIRECT_REF\n+\t   || TREE_CODE (exp) == MEM_REF\n+\t   || TREE_CODE (exp) == TARGET_MEM_REF)\n     {\n       tree addr = TREE_OPERAND (exp, 0);\n       unsigned ptr_align;\n@@ -343,58 +338,51 @@ get_object_alignment_1 (tree exp, unsigned int *alignp,\n       if (TREE_CODE (addr) == BIT_AND_EXPR\n \t  && TREE_CODE (TREE_OPERAND (addr, 1)) == INTEGER_CST)\n \t{\n-\t  known_alignment = true;\n \t  align = (TREE_INT_CST_LOW (TREE_OPERAND (addr, 1))\n \t\t    & -TREE_INT_CST_LOW (TREE_OPERAND (addr, 1)));\n \t  align *= BITS_PER_UNIT;\n \t  addr = TREE_OPERAND (addr, 0);\n \t}\n \n-      if (get_pointer_alignment_1 (addr, &ptr_align, &ptr_bitpos))\n+      known_alignment\n+\t= get_pointer_alignment_1 (addr, &ptr_align, &ptr_bitpos);\n+      bitpos += ptr_bitpos;\n+      align = MAX (ptr_align, align);\n+\n+      if (TREE_CODE (exp) == MEM_REF\n+\t  || TREE_CODE (exp) == TARGET_MEM_REF)\n+\tbitpos += mem_ref_offset (exp).low * BITS_PER_UNIT;\n+      if (TREE_CODE (exp) == TARGET_MEM_REF)\n \t{\n-\t  known_alignment = true;\n-\t  bitpos += ptr_bitpos & ~(align - 1);\n-\t  align = MAX (ptr_align, align);\n+\t  if (TMR_INDEX (exp))\n+\t    {\n+\t      unsigned HOST_WIDE_INT step = 1;\n+\t      if (TMR_STEP (exp))\n+\t\tstep = TREE_INT_CST_LOW (TMR_STEP (exp));\n+\t      align = MIN (align, (step & -step) * BITS_PER_UNIT);\n+\t    }\n+\t  if (TMR_INDEX2 (exp))\n+\t    align = BITS_PER_UNIT;\n+\t  known_alignment = false;\n \t}\n \n-      bitpos += mem_ref_offset (exp).low * BITS_PER_UNIT;\n+      /* When EXP is an actual memory reference then we can use\n+\t TYPE_ALIGN of a pointer indirection to derive alignment.\n+\t Do so only if get_pointer_alignment_1 did not reveal absolute\n+\t alignment knowledge.  */\n+      if (!addr_p && !known_alignment)\n+\talign = MAX (TYPE_ALIGN (TREE_TYPE (exp)), align);\n     }\n-  else if (TREE_CODE (exp) == TARGET_MEM_REF)\n+  else if (TREE_CODE (exp) == STRING_CST)\n     {\n-      unsigned ptr_align;\n-      unsigned HOST_WIDE_INT ptr_bitpos;\n-      tree addr = TMR_BASE (exp);\n-\n-      if (TREE_CODE (addr) == BIT_AND_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (addr, 1)) == INTEGER_CST)\n-\t{\n-\t  known_alignment = true;\n-\t  align = (TREE_INT_CST_LOW (TREE_OPERAND (addr, 1))\n-\t\t   & -TREE_INT_CST_LOW (TREE_OPERAND (addr, 1)));\n-\t  align *= BITS_PER_UNIT;\n-\t  addr = TREE_OPERAND (addr, 0);\n-\t}\n-\n-      if (get_pointer_alignment_1 (addr, &ptr_align, &ptr_bitpos))\n-\t{\n-\t  known_alignment = true;\n-\t  bitpos += ptr_bitpos & ~(align - 1);\n-\t  align = MAX (ptr_align, align);\n-\t}\n-\n-      if (TMR_OFFSET (exp))\n-\tbitpos += TREE_INT_CST_LOW (TMR_OFFSET (exp)) * BITS_PER_UNIT;\n-      if (TMR_INDEX (exp) && TMR_STEP (exp))\n-\t{\n-\t  unsigned HOST_WIDE_INT step = TREE_INT_CST_LOW (TMR_STEP (exp));\n-\t  align = MIN (align, (step & -step) * BITS_PER_UNIT);\n-\t  known_alignment = true;\n-\t}\n-      else if (TMR_INDEX (exp))\n-\tknown_alignment = false;\n-\n-      if (TMR_INDEX2 (exp))\n-\tknown_alignment = false;\n+      /* STRING_CST are the only constant objects we allow to be not\n+         wrapped inside a CONST_DECL.  */\n+      align = TYPE_ALIGN (TREE_TYPE (exp));\n+#ifdef CONSTANT_ALIGNMENT\n+      if (CONSTANT_CLASS_P (exp))\n+\talign = (unsigned) CONSTANT_ALIGNMENT (exp, align);\n+#endif\n+      known_alignment = true;\n     }\n \n   /* If there is a non-constant offset part extract the maximum\n@@ -435,29 +423,32 @@ get_object_alignment_1 (tree exp, unsigned int *alignp,\n \t}\n       else\n \t{\n-\t  known_alignment = false;\n+\t  inner = MIN (inner, BITS_PER_UNIT);\n \t  break;\n \t}\n       offset = next_offset;\n     }\n+  /* Alignment is innermost object alignment adjusted by the constant\n+     and non-constant offset parts.  */\n+  align = MIN (align, inner);\n \n-  if (known_alignment)\n-    {\n-      /* Alignment is innermost object alignment adjusted by the constant\n-\t and non-constant offset parts.  */\n-      align = MIN (align, inner);\n-      bitpos = bitpos & (align - 1);\n-      *alignp = align;\n-    }\n-  else\n-    {\n-      bitpos = bitpos & (BITS_PER_UNIT - 1);\n-      *alignp = BITS_PER_UNIT;\n-    }\n-  *bitposp = bitpos;\n+  *alignp = align;\n+  *bitposp = bitpos & (*alignp - 1);\n   return known_alignment;\n }\n \n+/* For a memory reference expression EXP compute values M and N such that M\n+   divides (&EXP - N) and such that N < M.  If these numbers can be determined,\n+   store M in alignp and N in *BITPOSP and return true.  Otherwise return false\n+   and store BITS_PER_UNIT to *alignp and any bit-offset to *bitposp.  */\n+\n+bool\n+get_object_alignment_1 (tree exp, unsigned int *alignp,\n+\t\t\tunsigned HOST_WIDE_INT *bitposp)\n+{\n+  return get_object_alignment_2 (exp, alignp, bitposp, false);\n+}\n+\n /* Return the alignment in bits of EXP, an object.  */\n \n unsigned int\n@@ -476,36 +467,10 @@ get_object_alignment (tree exp)\n   return align;\n }\n \n-/* Return the alignment of object EXP, also considering its type when we do\n-   not know of explicit misalignment.  Only handle MEM_REF and TARGET_MEM_REF.\n-\n-   ??? Note that, in the general case, the type of an expression is not kept\n-   consistent with misalignment information by the front-end, for example when\n-   taking the address of a member of a packed structure.  However, in most of\n-   the cases, expressions have the alignment of their type so we optimistically\n-   fall back to this alignment when we cannot compute a misalignment.  */\n-\n-unsigned int\n-get_object_or_type_alignment (tree exp)\n-{\n-  unsigned HOST_WIDE_INT misalign;\n-  unsigned int align;\n-  bool known_alignment;\n-\n-  gcc_assert (TREE_CODE (exp) == MEM_REF || TREE_CODE (exp) == TARGET_MEM_REF);\n-  known_alignment = get_object_alignment_1 (exp, &align, &misalign);\n-  if (misalign != 0)\n-    align = (misalign & -misalign);\n-  else if (!known_alignment)\n-    align = TYPE_ALIGN (TREE_TYPE (exp));\n-\n-  return align;\n-}\n-\n /* For a pointer valued expression EXP compute values M and N such that M\n    divides (EXP - N) and such that N < M.  If these numbers can be determined,\n-   store M in alignp and N in *BITPOSP and return true.  Otherwise return false\n-   and store BITS_PER_UNIT to *alignp and any bit-offset to *bitposp.\n+   store M in alignp and N in *BITPOSP and return true.  Return false if\n+   the results are just a conservative approximation.\n \n    If EXP is not a pointer, false is returned too.  */\n \n@@ -516,7 +481,8 @@ get_pointer_alignment_1 (tree exp, unsigned int *alignp,\n   STRIP_NOPS (exp);\n \n   if (TREE_CODE (exp) == ADDR_EXPR)\n-    return get_object_alignment_1 (TREE_OPERAND (exp, 0), alignp, bitposp);\n+    return get_object_alignment_2 (TREE_OPERAND (exp, 0),\n+\t\t\t\t   alignp, bitposp, true);\n   else if (TREE_CODE (exp) == SSA_NAME\n \t   && POINTER_TYPE_P (TREE_TYPE (exp)))\n     {\n@@ -527,6 +493,7 @@ get_pointer_alignment_1 (tree exp, unsigned int *alignp,\n \t{\n \t  *bitposp = ptr_misalign * BITS_PER_UNIT;\n \t  *alignp = ptr_align * BITS_PER_UNIT;\n+\t  /* We cannot really tell whether this result is an approximation.  */\n \t  return true;\n \t}\n       else"}, {"sha": "880e1bcab5a68294aaff3ef091dac8f9f5a4ab11", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f4a35f73d421cac856149de1756a51d833adb3/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f4a35f73d421cac856149de1756a51d833adb3/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b0f4a35f73d421cac856149de1756a51d833adb3", "patch": "@@ -4590,7 +4590,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n        || TREE_CODE (to) == TARGET_MEM_REF)\n       && mode != BLKmode\n       && !mem_ref_refers_to_non_mem_p (to)\n-      && ((align = get_object_or_type_alignment (to))\n+      && ((align = get_object_alignment (to))\n \t  < GET_MODE_ALIGNMENT (mode))\n       && (((icode = optab_handler (movmisalign_optab, mode))\n \t   != CODE_FOR_nothing)\n@@ -4652,7 +4652,7 @@ expand_assignment (tree to, tree from, bool nontemporal)\n       mode = TYPE_MODE (TREE_TYPE (tem));\n       if (TREE_CODE (tem) == MEM_REF\n \t  && mode != BLKmode\n-\t  && ((align = get_object_or_type_alignment (tem))\n+\t  && ((align = get_object_alignment (tem))\n \t      < GET_MODE_ALIGNMENT (mode))\n \t  && ((icode = optab_handler (movmisalign_optab, mode))\n \t      != CODE_FOR_nothing))\n@@ -9496,7 +9496,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \ttemp = gen_rtx_MEM (mode, op0);\n \tset_mem_attributes (temp, exp, 0);\n \tset_mem_addr_space (temp, as);\n-\talign = get_object_or_type_alignment (exp);\n+\talign = get_object_alignment (exp);\n \tif (modifier != EXPAND_WRITE\n \t    && mode != BLKmode\n \t    && align < GET_MODE_ALIGNMENT (mode)\n@@ -9570,7 +9570,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t\t   gimple_assign_rhs1 (def_stmt), mask);\n \t    TREE_OPERAND (exp, 0) = base;\n \t  }\n-\talign = get_object_or_type_alignment (exp);\n+\talign = get_object_alignment (exp);\n \top0 = expand_expr (base, NULL_RTX, VOIDmode, EXPAND_SUM);\n \top0 = memory_address_addr_space (address_mode, op0, as);\n \tif (!integer_zerop (TREE_OPERAND (exp, 1)))"}, {"sha": "2261f2d089c0bdc11a97d2268cc8b246d18d1ea5", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0f4a35f73d421cac856149de1756a51d833adb3/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0f4a35f73d421cac856149de1756a51d833adb3/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b0f4a35f73d421cac856149de1756a51d833adb3", "patch": "@@ -5485,7 +5485,6 @@ extern bool is_builtin_fn (tree);\n extern bool get_object_alignment_1 (tree, unsigned int *,\n \t\t\t\t    unsigned HOST_WIDE_INT *);\n extern unsigned int get_object_alignment (tree);\n-extern unsigned int get_object_or_type_alignment (tree);\n extern bool get_pointer_alignment_1 (tree, unsigned int *,\n \t\t\t\t     unsigned HOST_WIDE_INT *);\n extern unsigned int get_pointer_alignment (tree);"}]}