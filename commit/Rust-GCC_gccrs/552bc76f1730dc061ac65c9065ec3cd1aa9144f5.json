{"sha": "552bc76f1730dc061ac65c9065ec3cd1aa9144f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTUyYmM3NmYxNzMwZGMwNjFhYzY1YzkwNjVlYzNjZDFhYTkxNDRmNQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-26T08:59:15Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-26T08:59:15Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1089", "tree": {"sha": "1309a7908b2e70d63e12b8546e85ba1842294c35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1309a7908b2e70d63e12b8546e85ba1842294c35"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/552bc76f1730dc061ac65c9065ec3cd1aa9144f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/552bc76f1730dc061ac65c9065ec3cd1aa9144f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/552bc76f1730dc061ac65c9065ec3cd1aa9144f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/552bc76f1730dc061ac65c9065ec3cd1aa9144f5/comments", "author": null, "committer": null, "parents": [{"sha": "168c4006b176a6376021ff17bf025ca50fe16b69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/168c4006b176a6376021ff17bf025ca50fe16b69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/168c4006b176a6376021ff17bf025ca50fe16b69"}], "stats": {"total": 19, "additions": 16, "deletions": 3}, "files": [{"sha": "24dff2d834b2dcca3850972a17fe0b601f0694df", "filename": "gcc/loop.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/552bc76f1730dc061ac65c9065ec3cd1aa9144f5/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/552bc76f1730dc061ac65c9065ec3cd1aa9144f5/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=552bc76f1730dc061ac65c9065ec3cd1aa9144f5", "patch": "@@ -109,6 +109,11 @@ unsigned long loop_n_iterations;\n \n static int loop_has_call;\n \n+/* Nonzero if there is a volatile memory reference in the current\n+   loop.  */\n+\n+static int loop_has_volatile;\n+\n /* Added loop_continue which is the NOTE_INSN_LOOP_CONT of the\n    current loop.  A continue statement will generate a branch to\n    NEXT_INSN (loop_continue).  */\n@@ -155,7 +160,7 @@ static rtx loop_store_mems[NUM_STORES];\n static int loop_store_mems_idx;\n \n /* Nonzero if we don't know what MEMs were changed in the current loop.\n-   This happens if the loop contains a call (in which call `loop_has_call'\n+   This happens if the loop contains a call (in which case `loop_has_call'\n    will also be set) or if we store into more than NUM_STORES MEMs.  */\n \n static int unknown_address_altered;\n@@ -2089,7 +2094,8 @@ constant_high_bytes (p, loop_start)\n #endif\n \f\n /* Scan a loop setting the variables `unknown_address_altered',\n-   `num_mem_sets', `loop_continue', loops_enclosed' and `loop_has_call'.\n+   `num_mem_sets', `loop_continue', loops_enclosed', `loop_has_call',\n+   and `loop_has_volatile'.\n    Also, fill in the array `loop_store_mems'.  */\n \n static void\n@@ -2101,6 +2107,7 @@ prescan_loop (start, end)\n \n   unknown_address_altered = 0;\n   loop_has_call = 0;\n+  loop_has_volatile = 0;\n   loop_store_mems_idx = 0;\n \n   num_mem_sets = 0;\n@@ -2141,7 +2148,12 @@ prescan_loop (start, end)\n       else\n \t{\n \t  if (GET_CODE (insn) == INSN || GET_CODE (insn) == JUMP_INSN)\n-\t    note_stores (PATTERN (insn), note_addr_stored);\n+\t    {\n+\t      if (volatile_refs_p (PATTERN (insn)))\n+\t\tloop_has_volatile = 1;\n+\n+\t      note_stores (PATTERN (insn), note_addr_stored);\n+\t    }\n \t}\n     }\n }\n@@ -5578,6 +5590,7 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n \n       if (num_nonfixed_reads <= 1\n \t  && !loop_has_call\n+\t  && !loop_has_volatile\n \t  && (no_use_except_counting\n \t      || (bl->giv_count + bl->biv_count + num_mem_sets\n \t\t  + num_movables + 2 == insn_count)))"}]}