{"sha": "9bb86f4147d6827f4fb1c70a4fda7c118e527471", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJiODZmNDE0N2Q2ODI3ZjRmYjFjNzBhNGZkYTdjMTE4ZTUyNzQ3MQ==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2004-10-05T14:06:25Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-10-05T14:06:25Z"}, "message": "s390.c (s390_dump_pool): Remove return value.\n\n\t* config/s390/s390.c (s390_dump_pool): Remove return value.\n\tUse gen_pool_align, gen_pool_section_start/end instead of\n\tgen_pool_start/end_31/64.\n\t* config/s390/s390.md (UNSPECV_POOL_START, UNSPECV_POOL_END): Remove.\n\t(UNSPECV_POOL_SECTION, UNSPECV_POOL_ALIGN): New constants.\n\t(\"pool_start_31\", \"pool_end_31\"): Remove.\n\t(\"pool_start_64\", \"pool_end_64\"): Likewise.\n\t(\"pool_align\", \"pool_section_start\", \"pool_section_end\": New insns.\n\n\t* config/s390/s390.c (s390_cannot_copy_insn_p): New function.\n\t(TARGET_CANNOT_COPY_INSN_P): Define.\n\t(s390_cannot_force_const_mem): Handle UNSPEC_INSN.\n\t(struct constant_pool): New member 'execute'.\n\t(s390_add_execute, s390_find_execute): New functions.\n\t(s390_execute_label, s390_execute_target): Likewise.\n\t(s390_dump_pool): Output in-pool execute target templates.\n\t(s390_dump_execute): New function.\n\t(s390_alloc_pool, s390_free_pool): Handle execute templates.\n\t(s390_mainpool_start, s390_mainpool_finish): Likewise.\n\t(s390_chunkify_start, s390_chunkify_finish): Likewise.\n\t* config/s390/s390.md (UNSPEC_INSN, UNSPEC_EXECUTE): New constants.\n\t(\"*execute\"): New insn pattern.\n\t(\"movmem_short\", \"*movmem_short\"): Use splitters to generate\n\texplicit execute pattern, remove embedded execute.\n\t(\"clrmem_short\", \"*clrmem_short\"): Likewise.\n\t(\"cmpmem_short\", \"*cmpmem_short\"): Likewise.\n\nFrom-SVN: r88555", "tree": {"sha": "84f9b8f8b8c3088fe73f9fe8a8a2c9d737d54ca2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84f9b8f8b8c3088fe73f9fe8a8a2c9d737d54ca2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bb86f4147d6827f4fb1c70a4fda7c118e527471", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bb86f4147d6827f4fb1c70a4fda7c118e527471", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bb86f4147d6827f4fb1c70a4fda7c118e527471", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bb86f4147d6827f4fb1c70a4fda7c118e527471/comments", "author": null, "committer": null, "parents": [{"sha": "af16db699d865a4324173656b33fa1abd27c8aa0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af16db699d865a4324173656b33fa1abd27c8aa0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af16db699d865a4324173656b33fa1abd27c8aa0"}], "stats": {"total": 578, "additions": 460, "deletions": 118}, "files": [{"sha": "82a9ad6f9ad69be1cae4126ef52038c3b7a19315", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb86f4147d6827f4fb1c70a4fda7c118e527471/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb86f4147d6827f4fb1c70a4fda7c118e527471/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9bb86f4147d6827f4fb1c70a4fda7c118e527471", "patch": "@@ -1,3 +1,32 @@\n+2004-10-05  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390.c (s390_dump_pool): Remove return value.\n+\tUse gen_pool_align, gen_pool_section_start/end instead of\n+\tgen_pool_start/end_31/64.\n+\t* config/s390/s390.md (UNSPECV_POOL_START, UNSPECV_POOL_END): Remove.\n+\t(UNSPECV_POOL_SECTION, UNSPECV_POOL_ALIGN): New constants.\n+\t(\"pool_start_31\", \"pool_end_31\"): Remove.\n+\t(\"pool_start_64\", \"pool_end_64\"): Likewise.\n+\t(\"pool_align\", \"pool_section_start\", \"pool_section_end\": New insns.\n+\n+\t* config/s390/s390.c (s390_cannot_copy_insn_p): New function.\n+\t(TARGET_CANNOT_COPY_INSN_P): Define.\n+\t(s390_cannot_force_const_mem): Handle UNSPEC_INSN.\n+\t(struct constant_pool): New member 'execute'.\n+\t(s390_add_execute, s390_find_execute): New functions.\n+\t(s390_execute_label, s390_execute_target): Likewise.\n+\t(s390_dump_pool): Output in-pool execute target templates.\n+\t(s390_dump_execute): New function.\n+\t(s390_alloc_pool, s390_free_pool): Handle execute templates.\n+\t(s390_mainpool_start, s390_mainpool_finish): Likewise.\n+\t(s390_chunkify_start, s390_chunkify_finish): Likewise.\n+\t* config/s390/s390.md (UNSPEC_INSN, UNSPEC_EXECUTE): New constants.\n+\t(\"*execute\"): New insn pattern.\n+\t(\"movmem_short\", \"*movmem_short\"): Use splitters to generate\n+\texplicit execute pattern, remove embedded execute.\n+\t(\"clrmem_short\", \"*clrmem_short\"): Likewise.\n+\t(\"cmpmem_short\", \"*cmpmem_short\"): Likewise.\n+\n 2004-10-05  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* tree-ssa.c (verify_ssa): Verify phi arguments only"}, {"sha": "c1414cf48f3d3c102620a230b5bb647598ddb923", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 214, "deletions": 27, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb86f4147d6827f4fb1c70a4fda7c118e527471/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb86f4147d6827f4fb1c70a4fda7c118e527471/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=9bb86f4147d6827f4fb1c70a4fda7c118e527471", "patch": "@@ -70,6 +70,7 @@ static enum attr_type s390_safe_attr_type (rtx);\n static int s390_adjust_priority (rtx, int);\n static int s390_issue_rate (void);\n static int s390_first_cycle_multipass_dfa_lookahead (void);\n+static bool s390_cannot_copy_insn_p (rtx);\n static bool s390_rtx_costs (rtx, int, int, int *);\n static int s390_address_cost (rtx);\n static void s390_reorg (void);\n@@ -127,6 +128,8 @@ static bool s390_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode mode,\n #undef TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD\n #define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DFA_LOOKAHEAD s390_first_cycle_multipass_dfa_lookahead\n \n+#undef TARGET_CANNOT_COPY_INSN_P\n+#define TARGET_CANNOT_COPY_INSN_P s390_cannot_copy_insn_p\n #undef TARGET_RTX_COSTS\n #define TARGET_RTX_COSTS s390_rtx_costs\n #undef TARGET_ADDRESS_COST\n@@ -2123,6 +2126,11 @@ s390_cannot_force_const_mem (rtx x)\n \tcase UNSPEC_INDNTPOFF:\n \t  return false;\n \n+\t/* If the literal pool shares the code section, be put\n+\t   execute template placeholders into the pool as well.  */\n+\tcase UNSPEC_INSN:\n+\t  return TARGET_CPU_ZARCH;\n+\n \tdefault:\n \t  return true;\n \t}\n@@ -4720,6 +4728,7 @@ struct constant_pool\n   bitmap insns;\n \n   struct constant *constants[NR_C_MODES];\n+  struct constant *execute;\n   rtx label;\n   int size;\n };\n@@ -4738,7 +4747,12 @@ static void s390_add_pool_insn (struct constant_pool *, rtx);\n static struct constant_pool *s390_find_pool (struct constant_pool *, rtx);\n static void s390_add_constant (struct constant_pool *, rtx, enum machine_mode);\n static rtx s390_find_constant (struct constant_pool *, rtx, enum machine_mode);\n-static rtx s390_dump_pool (struct constant_pool *, bool);\n+static void s390_add_execute (struct constant_pool *, rtx);\n+static rtx s390_find_execute (struct constant_pool *, rtx);\n+static rtx s390_execute_label (rtx);\n+static rtx s390_execute_target (rtx);\n+static void s390_dump_pool (struct constant_pool *, bool);\n+static void s390_dump_execute (struct constant_pool *);\n static struct constant_pool *s390_alloc_pool (void);\n static void s390_free_pool (struct constant_pool *);\n \n@@ -4857,24 +4871,130 @@ s390_find_constant (struct constant_pool *pool, rtx val,\n   return offset;\n }\n \n+/* Add execute target for INSN to the constant pool POOL.  */\n+\n+static void\n+s390_add_execute (struct constant_pool *pool, rtx insn)\n+{\n+  struct constant *c;\n+\n+  for (c = pool->execute; c != NULL; c = c->next)\n+    if (INSN_UID (insn) == INSN_UID (c->value))\n+      break;\n+\n+  if (c == NULL)\n+    {\n+      rtx label = s390_execute_label (insn);\n+      gcc_assert (label);\n+\n+      c = (struct constant *) xmalloc (sizeof *c);\n+      c->value = insn;\n+      c->label = label == const0_rtx ? gen_label_rtx () : XEXP (label, 0);\n+      c->next = pool->execute;\n+      pool->execute = c;\n+      pool->size += label == const0_rtx ? 6 : 0;\n+    }\n+}\n+\n+/* Find execute target for INSN in the constant pool POOL.\n+   Return an RTX describing the distance from the start of\n+   the pool to the location of the execute target.  */\n+\n+static rtx\n+s390_find_execute (struct constant_pool *pool, rtx insn)\n+{\n+  struct constant *c;\n+  rtx offset;\n+\n+  for (c = pool->execute; c != NULL; c = c->next)\n+    if (INSN_UID (insn) == INSN_UID (c->value))\n+      break;\n+\n+  if (c == NULL)\n+    abort ();\n+\n+  offset = gen_rtx_MINUS (Pmode, gen_rtx_LABEL_REF (Pmode, c->label),\n+\t\t\t\t gen_rtx_LABEL_REF (Pmode, pool->label));\n+  offset = gen_rtx_CONST (Pmode, offset);\n+  return offset;\n+}\n+\n+/* Check whether INSN is an execute.  Return the label_ref to its\n+   execute target template if so, NULL_RTX otherwise.  */\n+\n+static rtx\n+s390_execute_label (rtx insn)\n+{\n+  if (GET_CODE (insn) == INSN\n+      && GET_CODE (PATTERN (insn)) == PARALLEL\n+      && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == UNSPEC\n+      && XINT (XVECEXP (PATTERN (insn), 0, 0), 1) == UNSPEC_EXECUTE)\n+    return XVECEXP (XVECEXP (PATTERN (insn), 0, 0), 0, 2);\n+\n+  return NULL_RTX;\n+}\n+\n+/* For an execute INSN, extract the execute target template.  */\n+\n+static rtx\n+s390_execute_target (rtx insn)\n+{\n+  rtx pattern = PATTERN (insn);\n+  gcc_assert (s390_execute_label (insn));\n+\n+  if (XVECLEN (pattern, 0) == 2)\n+    {\n+      pattern = copy_rtx (XVECEXP (pattern, 0, 1));\n+    }\n+  else\n+    {\n+      rtvec vec = rtvec_alloc (XVECLEN (pattern, 0) - 1);\n+      int i;\n+\n+      for (i = 0; i < XVECLEN (pattern, 0) - 1; i++)\n+\tRTVEC_ELT (vec, i) = copy_rtx (XVECEXP (pattern, 0, i + 1));\n+\n+      pattern = gen_rtx_PARALLEL (VOIDmode, vec);\n+    }\n+\n+  return pattern;\n+}\n+\n+/* Indicate that INSN cannot be duplicated.  This is the case for\n+   execute insns that carry a unique label.  */\n+\n+static bool\n+s390_cannot_copy_insn_p (rtx insn)\n+{\n+  rtx label = s390_execute_label (insn);\n+  return label && label != const0_rtx;\n+}\n+\n /* Dump out the constants in POOL.  If REMOTE_LABEL is true,\n    do not emit the pool base label.  */\n \n-static rtx\n+static void\n s390_dump_pool (struct constant_pool *pool, bool remote_label)\n {\n   struct constant *c;\n-  rtx insn;\n+  rtx insn = pool->pool_insn;\n   int i;\n \n-  /* Pool start insn switches to proper section\n-     and guarantees necessary alignment.  */\n+  /* Switch to rodata section.  */\n   if (TARGET_CPU_ZARCH)\n-    insn = emit_insn_after (gen_pool_start_64 (), pool->pool_insn);\n+    {\n+      insn = emit_insn_after (gen_pool_section_start (), insn);\n+      INSN_ADDRESSES_NEW (insn, -1);\n+    }\n+\n+  /* Ensure minimum pool alignment.  */\n+  if (TARGET_CPU_ZARCH)\n+    insn = emit_insn_after (gen_pool_align (GEN_INT (8)), insn);\n   else\n-    insn = emit_insn_after (gen_pool_start_31 (), pool->pool_insn);\n+    insn = emit_insn_after (gen_pool_align (GEN_INT (4)), insn);\n   INSN_ADDRESSES_NEW (insn, -1);\n \n+  /* Emit pool base label.  */\n   if (!remote_label)\n     {\n       insn = emit_label_after (pool->label, insn);\n@@ -4908,21 +5028,60 @@ s390_dump_pool (struct constant_pool *pool, bool remote_label)\n \tINSN_ADDRESSES_NEW (insn, -1);\n       }\n \n-  /* Pool end insn switches back to previous section\n-     and guarantees necessary alignment.  */\n-  if (TARGET_CPU_ZARCH)\n-    insn = emit_insn_after (gen_pool_end_64 (), insn);\n-  else\n-    insn = emit_insn_after (gen_pool_end_31 (), insn);\n+  /* Ensure minimum alignment for instructions.  */\n+  insn = emit_insn_after (gen_pool_align (GEN_INT (2)), insn);\n   INSN_ADDRESSES_NEW (insn, -1);\n \n+  /* Output in-pool execute template insns.  */\n+  for (c = pool->execute; c; c = c->next)\n+    {\n+      if (s390_execute_label (c->value) != const0_rtx)\n+\tcontinue;\n+\n+      insn = emit_label_after (c->label, insn);\n+      INSN_ADDRESSES_NEW (insn, -1);\n+\n+      insn = emit_insn_after (s390_execute_target (c->value), insn);\n+      INSN_ADDRESSES_NEW (insn, -1);\n+    }\n+\n+  /* Switch back to previous section.  */\n+  if (TARGET_CPU_ZARCH)\n+    {\n+      insn = emit_insn_after (gen_pool_section_end (), insn);\n+      INSN_ADDRESSES_NEW (insn, -1);\n+    }\n+\n   insn = emit_barrier_after (insn);\n   INSN_ADDRESSES_NEW (insn, -1);\n \n   /* Remove placeholder insn.  */\n   remove_insn (pool->pool_insn);\n \n-  return insn;\n+  /* Output out-of-pool execute template isns.  */\n+  s390_dump_execute (pool);\n+}\n+\n+/* Dump out the out-of-pool execute template insns in POOL\n+   at the end of the instruction stream.  */\n+\n+static void\n+s390_dump_execute (struct constant_pool *pool)\n+{\n+  struct constant *c;\n+  rtx insn;\n+\n+  for (c = pool->execute; c; c = c->next)\n+    {\n+      if (s390_execute_label (c->value) == const0_rtx)\n+\tcontinue;\n+\n+      insn = emit_label (c->label);\n+      INSN_ADDRESSES_NEW (insn, -1);\n+\n+      insn = emit_insn (s390_execute_target (c->value));\n+      INSN_ADDRESSES_NEW (insn, -1);\n+    }\n }\n \n /* Allocate new constant_pool structure.  */\n@@ -4938,6 +5097,7 @@ s390_alloc_pool (void)\n   for (i = 0; i < NR_C_MODES; i++)\n     pool->constants[i] = NULL;\n \n+  pool->execute = NULL;\n   pool->label = gen_label_rtx ();\n   pool->first_insn = NULL_RTX;\n   pool->pool_insn = NULL_RTX;\n@@ -4952,17 +5112,20 @@ s390_alloc_pool (void)\n static void\n s390_free_pool (struct constant_pool *pool)\n {\n+  struct constant *c, *next;\n   int i;\n \n   for (i = 0; i < NR_C_MODES; i++)\n+    for (c = pool->constants[i]; c; c = next)\n+      {\n+\tnext = c->next;\n+\tfree (c);\n+      }\n+\n+  for (c = pool->execute; c; c = next)\n     {\n-      struct constant *c = pool->constants[i];\n-      while (c != NULL)\n-\t{\n-\t  struct constant *next = c->next;\n-\t  free (c);\n-\t  c = next;\n-\t}\n+      next = c->next;\n+      free (c);\n     }\n \n   BITMAP_XFREE (pool->insns);\n@@ -4992,7 +5155,11 @@ s390_mainpool_start (void)\n \t  pool->pool_insn = insn;\n \t}\n \n-      if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN)\n+      if (s390_execute_label (insn))\n+\t{\n+\t  s390_add_execute (pool, insn);\n+\t}\n+      else if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN)\n \t{\n \t  rtx pool_ref = NULL_RTX;\n \t  find_constant_pool_ref (PATTERN (insn), &pool_ref);\n@@ -5034,6 +5201,9 @@ s390_mainpool_finish (struct constant_pool *pool)\n   /* If the pool is empty, we're done.  */\n   if (pool->size == 0)\n     {\n+      /* However, we may have out-of-pool execute templates.  */\n+      s390_dump_execute (pool);\n+\n       /* We don't actually need a base register after all.  */\n       cfun->machine->base_reg = NULL_RTX;\n \n@@ -5120,8 +5290,12 @@ s390_mainpool_finish (struct constant_pool *pool)\n           find_constant_pool_ref (PATTERN (insn), &pool_ref);\n           if (pool_ref)\n             {\n-              addr = s390_find_constant (pool, get_pool_constant (pool_ref),\n-                                               get_pool_mode (pool_ref));\n+\t      if (s390_execute_label (insn))\n+\t\taddr = s390_find_execute (pool, insn);\n+\t      else\n+\t\taddr = s390_find_constant (pool, get_pool_constant (pool_ref),\n+\t\t\t\t\t\t get_pool_mode (pool_ref));\n+\n               replace_constant_pool_ref (&PATTERN (insn), pool_ref, addr);\n               INSN_CODE (insn) = -1;\n             }\n@@ -5184,7 +5358,15 @@ s390_chunkify_start (void)\n \t    }\n \t}\n \n-      if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN)\n+      if (s390_execute_label (insn))\n+\t{\n+\t  if (!curr_pool)\n+\t    curr_pool = s390_start_pool (&pool_list, insn);\n+\n+\t  s390_add_execute (curr_pool, insn);\n+\t  s390_add_pool_insn (curr_pool, insn);\n+\t}\n+      else if (GET_CODE (insn) == INSN || GET_CODE (insn) == CALL_INSN)\n \t{\n \t  rtx pool_ref = NULL_RTX;\n \t  find_constant_pool_ref (PATTERN (insn), &pool_ref);\n@@ -5439,8 +5621,13 @@ s390_chunkify_finish (struct constant_pool *pool_list)\n           find_constant_pool_ref (PATTERN (insn), &pool_ref);\n           if (pool_ref)\n             {\n-              addr = s390_find_constant (curr_pool, get_pool_constant (pool_ref),\n-                                                    get_pool_mode (pool_ref));\n+\t      if (s390_execute_label (insn))\n+\t\taddr = s390_find_execute (curr_pool, insn);\n+\t      else\n+\t\taddr = s390_find_constant (curr_pool,\n+\t\t\t\t\t   get_pool_constant (pool_ref),\n+\t\t\t\t\t   get_pool_mode (pool_ref));\n+\n               replace_constant_pool_ref (&PATTERN (insn), pool_ref, addr);\n               INSN_CODE (insn) = -1;\n             }"}, {"sha": "5a6499323297ea0cd408011b8f052d65b7188468", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 217, "deletions": 91, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb86f4147d6827f4fb1c70a4fda7c118e527471/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb86f4147d6827f4fb1c70a4fda7c118e527471/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=9bb86f4147d6827f4fb1c70a4fda7c118e527471", "patch": "@@ -94,6 +94,8 @@\n    (UNSPEC_RELOAD_BASE\t\t210)\n    (UNSPEC_MAIN_BASE\t\t211)\n    (UNSPEC_LTREF\t\t212)\n+   (UNSPEC_INSN\t\t\t213)\n+   (UNSPEC_EXECUTE\t\t214)\n \n    ; TLS relocation specifiers\n    (UNSPEC_TLSGD\t\t500)\n@@ -126,8 +128,8 @@\n \n    ; Literal pool\n    (UNSPECV_POOL\t\t200)\n-   (UNSPECV_POOL_START\t\t201)\n-   (UNSPECV_POOL_END\t\t202)\n+   (UNSPECV_POOL_SECTION\t201)\n+   (UNSPECV_POOL_ALIGN\t\t202)\n    (UNSPECV_POOL_ENTRY\t\t203)\n    (UNSPECV_MAIN_POOL\t\t300)\n \n@@ -1594,6 +1596,17 @@\n ;; String instructions.\n ;;\n \n+(define_insn \"*execute\"\n+  [(match_parallel 0 \"\"\n+    [(unspec [(match_operand 1 \"register_operand\" \"a\")\n+              (match_operand:BLK 2 \"memory_operand\" \"R\")\n+              (match_operand 3 \"\" \"\")] UNSPEC_EXECUTE)])]\n+  \"GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_INT\n+   && GET_MODE_SIZE (GET_MODE (operands[1])) <= UNITS_PER_WORD\"\n+  \"ex\\t%1,%2\"\n+  [(set_attr \"op_type\" \"RX\")])\n+\n+\n ;\n ; strlenM instruction pattern(s).\n ;\n@@ -1698,36 +1711,72 @@\n     [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n           (match_operand:BLK 1 \"memory_operand\" \"\"))\n      (use (match_operand 2 \"nonmemory_operand\" \"\"))\n+     (use (const:BLK (unspec:BLK [(const_int 0)] UNSPEC_INSN)))\n      (clobber (match_dup 3))])]\n   \"\"\n   \"operands[3] = gen_rtx_SCRATCH (Pmode);\")\n \n (define_insn \"*movmem_short\"\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q,Q\")\n-        (match_operand:BLK 1 \"memory_operand\" \"Q,Q\"))\n-   (use (match_operand 2 \"nonmemory_operand\" \"n,a\"))\n-   (clobber (match_scratch 3 \"=X,&a\"))]\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q,Q,Q\")\n+        (match_operand:BLK 1 \"memory_operand\" \"Q,Q,Q\"))\n+   (use (match_operand 2 \"nonmemory_operand\" \"n,a,a\"))\n+   (use (match_operand 3 \"immediate_operand\" \"X,R,X\"))\n+   (clobber (match_scratch 4 \"=X,X,&a\"))]\n   \"(GET_MODE (operands[2]) == Pmode || GET_MODE (operands[2]) == VOIDmode)\n-   && GET_MODE (operands[3]) == Pmode\"\n-{\n-  switch (which_alternative)\n-    {\n-      case 0:\n-\treturn \"mvc\\t%O0(%b2+1,%R0),%1\";\n+   && GET_MODE (operands[4]) == Pmode\"\n+  \"#\"\n+  [(set_attr \"op_type\" \"SS,RX,RX\")\n+   (set_attr \"type\"    \"cs\")])\n \n-      case 1:\n-\toutput_asm_insn (\"bras\\t%3,.+10\", operands);\n-\toutput_asm_insn (\"mvc\\t%O0(1,%R0),%1\", operands);\n-\treturn \"ex\\t%2,0(%3)\";\n+(define_split\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+        (match_operand:BLK 1 \"memory_operand\" \"\"))\n+   (use (match_operand 2 \"const_int_operand\" \"\"))\n+   (use (match_operand 3 \"immediate_operand\" \"\"))\n+   (clobber (scratch))]\n+  \"reload_completed\"\n+  [(parallel\n+    [(set (match_dup 0) (match_dup 1))\n+     (use (match_dup 2))])]\n+  \"operands[2] = GEN_INT ((INTVAL (operands[2]) & 0xff) + 1);\")\n \n-      default:\n-        abort ();\n-    }\n-}\n-  [(set_attr \"op_type\" \"SS,NN\")\n-   (set_attr \"type\"    \"cs,cs\")\n-   (set_attr \"atype\"   \"*,agen\")\n-   (set_attr \"length\"  \"*,14\")])\n+(define_split\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+        (match_operand:BLK 1 \"memory_operand\" \"\"))\n+   (use (match_operand 2 \"register_operand\" \"\"))\n+   (use (match_operand 3 \"memory_operand\" \"\"))\n+   (clobber (scratch))]\n+  \"reload_completed\"\n+  [(parallel\n+    [(unspec [(match_dup 2) (match_dup 3)\n+              (const_int 0)] UNSPEC_EXECUTE)\n+     (set (match_dup 0) (match_dup 1))\n+     (use (const_int 1))])]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+        (match_operand:BLK 1 \"memory_operand\" \"\"))\n+   (use (match_operand 2 \"register_operand\" \"\"))\n+   (use (const:BLK (unspec:BLK [(const_int 0)] UNSPEC_INSN)))\n+   (clobber (match_operand 3 \"register_operand\" \"\"))]\n+  \"reload_completed && TARGET_CPU_ZARCH\"\n+  [(set (match_dup 3) (label_ref (match_dup 4)))\n+   (parallel\n+    [(unspec [(match_dup 2) (mem:BLK (match_dup 3)) \n+              (label_ref (match_dup 4))] UNSPEC_EXECUTE)\n+     (set (match_dup 0) (match_dup 1))\n+     (use (const_int 1))])]\n+  \"operands[4] = gen_label_rtx ();\")\n+\n+(define_insn \"*mvc\"\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q\")\n+        (match_operand:BLK 1 \"memory_operand\" \"Q\"))\n+   (use (match_operand 2 \"const_int_operand\" \"n\"))]\n+  \"\"\n+  \"mvc\\t%O0(%2,%R0),%1\"\n+  [(set_attr \"op_type\" \"SS\")\n+   (set_attr \"type\"    \"cs\")])\n \n ; Move a block of arbitrary length.\n \n@@ -1820,38 +1869,81 @@\n     [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n           (const_int 0))\n      (use (match_operand 1 \"nonmemory_operand\" \"\"))\n+     (use (const:BLK (unspec:BLK [(const_int 0)] UNSPEC_INSN)))\n      (clobber (match_dup 2))\n      (clobber (reg:CC 33))])]\n   \"\"\n   \"operands[2] = gen_rtx_SCRATCH (Pmode);\")\n \n (define_insn \"*clrmem_short\"\n-  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q,Q\")\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q,Q,Q\")\n         (const_int 0))\n-   (use (match_operand 1 \"nonmemory_operand\" \"n,a\"))\n-   (clobber (match_scratch 2 \"=X,&a\"))\n+   (use (match_operand 1 \"nonmemory_operand\" \"n,a,a\"))\n+   (use (match_operand 2 \"immediate_operand\" \"X,R,X\"))\n+   (clobber (match_scratch 3 \"=X,X,&a\"))\n    (clobber (reg:CC 33))]\n   \"(GET_MODE (operands[1]) == Pmode || GET_MODE (operands[1]) == VOIDmode)\n-   && GET_MODE (operands[2]) == Pmode\"\n-{\n-  switch (which_alternative)\n-    {\n-      case 0:\n-\treturn \"xc\\t%O0(%b1+1,%R0),%0\";\n+   && GET_MODE (operands[3]) == Pmode\"\n+  \"#\"\n+  [(set_attr \"op_type\" \"SS,RX,RX\")\n+   (set_attr \"type\"    \"cs\")])\n \n-      case 1:\n-\toutput_asm_insn (\"bras\\t%2,.+10\", operands);\n-\toutput_asm_insn (\"xc\\t%O0(1,%R0),%0\", operands);\n-\treturn \"ex\\t%1,0(%2)\";\n+(define_split\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+        (const_int 0))\n+   (use (match_operand 1 \"const_int_operand\" \"\"))\n+   (use (match_operand 2 \"immediate_operand\" \"\"))\n+   (clobber (scratch))\n+   (clobber (reg:CC 33))]\n+  \"reload_completed\"\n+  [(parallel\n+    [(set (match_dup 0) (const_int 0))\n+     (use (match_dup 1))\n+     (clobber (reg:CC 33))])]\n+  \"operands[1] = GEN_INT ((INTVAL (operands[1]) & 0xff) + 1);\")\n \n-      default:\n-        abort ();\n-    }\n-}\n-  [(set_attr \"op_type\" \"SS,NN\")\n-   (set_attr \"type\"    \"cs,cs\")\n-   (set_attr \"atype\"   \"*,agen\")\n-   (set_attr \"length\"  \"*,14\")])\n+(define_split\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+        (const_int 0))\n+   (use (match_operand 1 \"register_operand\" \"\"))\n+   (use (match_operand 2 \"memory_operand\" \"\"))\n+   (clobber (scratch))\n+   (clobber (reg:CC 33))]\n+  \"reload_completed\"\n+  [(parallel\n+    [(unspec [(match_dup 1) (match_dup 2)\n+              (const_int 0)] UNSPEC_EXECUTE)\n+     (set (match_dup 0) (const_int 0))\n+     (use (const_int 1))\n+     (clobber (reg:CC 33))])]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+        (const_int 0))\n+   (use (match_operand 1 \"register_operand\" \"\"))\n+   (use (const:BLK (unspec:BLK [(const_int 0)] UNSPEC_INSN)))\n+   (clobber (match_operand 2 \"register_operand\" \"\"))\n+   (clobber (reg:CC 33))]\n+  \"reload_completed && TARGET_CPU_ZARCH\"\n+  [(set (match_dup 2) (label_ref (match_dup 3)))\n+   (parallel\n+    [(unspec [(match_dup 1) (mem:BLK (match_dup 2)) \n+              (label_ref (match_dup 3))] UNSPEC_EXECUTE)\n+     (set (match_dup 0) (const_int 0))\n+     (use (const_int 1))\n+     (clobber (reg:CC 33))])]\n+  \"operands[3] = gen_label_rtx ();\")\n+\n+(define_insn \"*xc_zero\"\n+  [(set (match_operand:BLK 0 \"memory_operand\" \"=Q\")\n+        (const_int 0))\n+   (use (match_operand 1 \"const_int_operand\" \"n\"))\n+   (clobber (reg:CC 33))]\n+  \"\"\n+  \"xc\\t%O0(%1,%R0),%0\"\n+  [(set_attr \"op_type\" \"SS\")\n+   (set_attr \"type\"    \"cs\")])\n \n ; Clear a block of arbitrary length.\n \n@@ -1931,37 +2023,77 @@\n           (compare:CCU (match_operand:BLK 0 \"memory_operand\" \"\")\n                        (match_operand:BLK 1 \"memory_operand\" \"\")))\n      (use (match_operand 2 \"nonmemory_operand\" \"\"))\n+     (use (const:BLK (unspec:BLK [(const_int 0)] UNSPEC_INSN)))\n      (clobber (match_dup 3))])]\n   \"\"\n   \"operands[3] = gen_rtx_SCRATCH (Pmode);\")\n \n (define_insn \"*cmpmem_short\"\n   [(set (reg:CCU 33)\n-        (compare:CCU (match_operand:BLK 0 \"memory_operand\" \"=Q,Q\")\n-                     (match_operand:BLK 1 \"memory_operand\" \"Q,Q\")))\n-   (use (match_operand 2 \"nonmemory_operand\" \"n,a\"))\n-   (clobber (match_scratch 3 \"=X,&a\"))]\n+        (compare:CCU (match_operand:BLK 0 \"memory_operand\" \"=Q,Q,Q\")\n+                     (match_operand:BLK 1 \"memory_operand\" \"Q,Q,Q\")))\n+   (use (match_operand 2 \"nonmemory_operand\" \"n,a,a\"))\n+   (use (match_operand 3 \"immediate_operand\" \"X,R,X\"))\n+   (clobber (match_scratch 4 \"=X,X,&a\"))]\n   \"(GET_MODE (operands[2]) == Pmode || GET_MODE (operands[2]) == VOIDmode)\n-   && GET_MODE (operands[3]) == Pmode\"\n-{\n-  switch (which_alternative)\n-    {\n-      case 0:\n-\treturn \"clc\\t%O0(%b2+1,%R0),%1\";\n+   && GET_MODE (operands[4]) == Pmode\"\n+  \"#\"\n+  [(set_attr \"op_type\" \"SS,RX,RX\")\n+   (set_attr \"type\"    \"cs\")])\n \n-      case 1:\n-\toutput_asm_insn (\"bras\\t%3,.+10\", operands);\n-\toutput_asm_insn (\"clc\\t%O0(1,%R0),%1\", operands);\n-\treturn \"ex\\t%2,0(%3)\";\n+(define_split\n+  [(set (reg:CCU 33)\n+        (compare:CCU (match_operand:BLK 0 \"memory_operand\" \"\")\n+                     (match_operand:BLK 1 \"memory_operand\" \"\")))\n+   (use (match_operand 2 \"const_int_operand\" \"\"))\n+   (use (match_operand 3 \"immediate_operand\" \"\"))\n+   (clobber (scratch))]\n+  \"reload_completed\"\n+  [(parallel\n+    [(set (reg:CCU 33) (compare:CCU (match_dup 0) (match_dup 1)))\n+     (use (match_dup 2))])]\n+  \"operands[2] = GEN_INT ((INTVAL (operands[2]) & 0xff) + 1);\")\n \n-      default:\n-        abort ();\n-    }\n-}\n-  [(set_attr \"op_type\" \"SS,NN\")\n-   (set_attr \"type\"    \"cs,cs\")\n-   (set_attr \"atype\"   \"*,agen\")\n-   (set_attr \"length\"  \"*,14\")])\n+(define_split\n+  [(set (reg:CCU 33)\n+        (compare:CCU (match_operand:BLK 0 \"memory_operand\" \"\")\n+                     (match_operand:BLK 1 \"memory_operand\" \"\")))\n+   (use (match_operand 2 \"register_operand\" \"\"))\n+   (use (match_operand 3 \"memory_operand\" \"\"))\n+   (clobber (scratch))]\n+  \"reload_completed\"\n+  [(parallel\n+    [(unspec [(match_dup 2) (match_dup 3)\n+              (const_int 0)] UNSPEC_EXECUTE)\n+     (set (reg:CCU 33) (compare:CCU (match_dup 0) (match_dup 1)))\n+     (use (const_int 1))])]\n+  \"\")\n+\n+(define_split\n+  [(set (reg:CCU 33)\n+        (compare:CCU (match_operand:BLK 0 \"memory_operand\" \"\")\n+                     (match_operand:BLK 1 \"memory_operand\" \"\")))\n+   (use (match_operand 2 \"register_operand\" \"\"))\n+   (use (const:BLK (unspec:BLK [(const_int 0)] UNSPEC_INSN)))\n+   (clobber (match_operand 3 \"register_operand\" \"\"))]\n+  \"reload_completed && TARGET_CPU_ZARCH\"\n+  [(set (match_dup 3) (label_ref (match_dup 4)))\n+   (parallel\n+    [(unspec [(match_dup 2) (mem:BLK (match_dup 3)) \n+              (label_ref (match_dup 4))] UNSPEC_EXECUTE)\n+     (set (reg:CCU 33) (compare:CCU (match_dup 0) (match_dup 1)))\n+     (use (const_int 1))])]\n+  \"operands[4] = gen_label_rtx ();\")\n+\n+(define_insn \"*clc\"\n+  [(set (reg:CCU 33)\n+        (compare:CCU (match_operand:BLK 0 \"memory_operand\" \"=Q\")\n+                     (match_operand:BLK 1 \"memory_operand\" \"Q\")))\n+   (use (match_operand 2 \"const_int_operand\" \"n\"))]\n+  \"\"\n+  \"clc\\t%O0(%2,%R0),%1\"\n+  [(set_attr \"op_type\" \"SS\")\n+   (set_attr \"type\"    \"cs\")])\n \n ; Compare a block of arbitrary length.\n \n@@ -7170,33 +7302,27 @@\n    (set (attr \"length\")\n         (symbol_ref \"GET_MODE_SIZE (GET_MODE (PATTERN (insn)))\"))])\n \n-(define_insn \"pool_start_31\"\n-  [(unspec_volatile [(const_int 0)] UNSPECV_POOL_START)]\n-  \"!TARGET_CPU_ZARCH\"\n-  \".align\\t4\"\n-  [(set_attr \"op_type\"  \"NN\")\n-   (set_attr \"length\"   \"2\")])\n-\n-(define_insn \"pool_end_31\"\n-  [(unspec_volatile [(const_int 0)] UNSPECV_POOL_END)]\n-  \"!TARGET_CPU_ZARCH\"\n-  \".align\\t2\"\n-  [(set_attr \"op_type\"  \"NN\")\n-   (set_attr \"length\"   \"2\")])\n+(define_insn \"pool_align\"\n+  [(unspec_volatile [(match_operand 0 \"const_int_operand\" \"n\")]\n+                    UNSPECV_POOL_ALIGN)]\n+  \"\"\n+  \".align\\t%0\"\n+  [(set_attr \"op_type\" \"NN\")\n+   (set (attr \"length\") (symbol_ref \"INTVAL (operands[0])\"))])\n \n-(define_insn \"pool_start_64\"\n-  [(unspec_volatile [(const_int 0)] UNSPECV_POOL_START)]\n-  \"TARGET_CPU_ZARCH\"\n-  \".section\\t.rodata\\;.align\\t8\"\n-  [(set_attr \"op_type\"  \"NN\")\n-   (set_attr \"length\"   \"0\")])\n+(define_insn \"pool_section_start\"\n+  [(unspec_volatile [(const_int 1)] UNSPECV_POOL_SECTION)]\n+  \"\"\n+  \".section\\t.rodata\"\n+  [(set_attr \"op_type\" \"NN\")\n+   (set_attr \"length\"  \"0\")])\n \n-(define_insn \"pool_end_64\"\n-  [(unspec_volatile [(const_int 0)] UNSPECV_POOL_END)]\n-  \"TARGET_CPU_ZARCH\"\n+(define_insn \"pool_section_end\"\n+  [(unspec_volatile [(const_int 0)] UNSPECV_POOL_SECTION)]\n+  \"\"\n   \".previous\"\n-  [(set_attr \"op_type\"  \"NN\")\n-   (set_attr \"length\"   \"0\")])\n+  [(set_attr \"op_type\" \"NN\")\n+   (set_attr \"length\"  \"0\")])\n \n (define_insn \"main_base_31_small\"\n   [(set (match_operand 0 \"register_operand\" \"=a\")"}]}