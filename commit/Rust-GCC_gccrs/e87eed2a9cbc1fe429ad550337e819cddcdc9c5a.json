{"sha": "e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg3ZWVkMmE5Y2JjMWZlNDI5YWQ1NTAzMzdlODE5Y2RkY2RjOWM1YQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2015-12-04T18:09:54Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2015-12-04T18:09:54Z"}, "message": "C++ FE: expression ranges\n\ngcc/ChangeLog:\n\t* convert.c (convert_to_real_1): When converting from a\n\tREAL_TYPE, preserve the location of EXPR in the result.\n\t* tree.c (get_pure_location): Make non-static.\n\t(set_source_range): Return the resulting location_t.\n\t(make_location): New function.\n\t* tree.h (get_pure_location): New decl.\n\t(get_finish): New inline function.\n\t(set_source_range): Convert return type from void to location_t.\n\t(make_location): New decl.\n\ngcc/cp/ChangeLog:\n\t* cp-tree.h (class cp_expr): New class.\n\t(finish_parenthesized_expr): Convert return type and param to\n\tcp_expr.\n\t(perform_koenig_lookup): Convert return type and param from tree\n\tto cp_expr.\n\t(finish_increment_expr): Likewise.\n\t(finish_unary_op_expr): Likewise.\n\t(finish_id_expression): Likewise for return type.\n\t(build_class_member_access_expr): Likewise for param.\n\t(finish_class_member_access_expr): Likewise.\n\t(build_x_unary_op): Likewise.\n\t(build_c_cast): New decl.\n\t(build_x_modify_expr): Convert return type from tree to cp_expr.\n\t* cvt.c (cp_convert_and_check): When warning about conversions,\n\tattempt to use the location of \"expr\" if available, otherwise\n\tfalling back to the old behavior of using input_location.\n\t* name-lookup.c (lookup_arg_dependent_1): Convert return type from\n\ttree to cp_expr.\n\t(lookup_arg_dependent): Likewise; also for local \"ret\".\n\t* name-lookup.h (lookup_arg_dependent): Likewise for return type.\n\t* parser.c (cp_lexer_previous_token): Skip past purged tokens.\n\t(struct cp_parser_expression_stack_entry): Convert field \"lhs\" to\n\tcp_expr.\n\t(cp_parser_identifier): Likewise for return type.  Use cp_expr\n\tctor to preserve the token's location.\n\t(cp_parser_string_literal): Likewise, building up a meaningful\n\tlocation for the case where a compound string literal is built by\n\tconcatentation.\n\t(cp_parser_userdef_char_literal): Likewise for return type.\n\t(cp_parser_userdef_numeric_literal): Likewise.\n\t(cp_parser_statement_expr): Convert return type to cp_expr.\n\tGenerate a suitable location for the expr and return it via the\n\tcp_expr ctor.\n\t(cp_parser_fold_expression): Convert return type to cp_expr.\n\t(cp_parser_primary_expression): Likewise, and for locals \"expr\",\n\t\"lam\", \"id_expression\", \"decl\".\n\tUse cp_expr ctor when parsing literals, to preserve the spelling\n\tlocation of the token.  Preserve the locations of parentheses.\n\tPreserve location when calling objc_lookup_ivar.\n\tPreserve the location for \"this\" tokens.  Generate suitable\n\tlocations for \"__builtin_va_arg\" constructs and for\n\tObjective C 2.0 dot-syntax.  Set the location for the result of\n\tfinish_id_expression.\n\t(cp_parser_primary_expression): Convert return type from tree to\n\tcp_expr.\n\t(cp_parser_id_expression): Likewise.\n\t(cp_parser_unqualified_id): Likewise.  Also for local \"id\".\n\t(cp_parser_postfix_expression): Likewise, also for local\n\t\"postfix_expression\".  Generate suitable locations for\n\tC++-style casts, \"_Cilk_spawn\" constructs.  Convert local\n\t\"initializer\" to cp_expr and use it to preserve the location of\n\tcompound literals.  Capture the location of the closing\n\tparenthesis of a call site via\n\tcp_parser_parenthesized_expression_list, and use it to build\n\ta source range for a call.  Use cp_expr in ternary expression.\n\t(cp_parser_postfix_dot_deref_expression): Convert param from tree to\n\tcp_expr.  Generate and set a location.\n\t(cp_parser_parenthesized_expression_list): Add \"close_paren_loc\"\n\tout-param, and write back to it.\n\t(cp_parser_unary_expression): Convert return type from tree to\n\tcp_expr.  Also for locals \"cast_expression\" and \"expression\".\n\tGenerate and use suitable locations for addresses of\n\tlabels and for cast expressions.  Call cp_expr::set_location where\n\tnecessary.  Preserve the locations of negated numeric literals.\n\t(cp_parser_new_expression): Generate meaningful locations/ranges.\n\t(cp_parser_cast_expression): Convert return type from tree to\n\tcp_expr; also for local \"expr\".  Use the paren location to generate a\n\tmeaningful range for the expression.\n\t(cp_parser_binary_expression): Convert return type from tree to\n\tcp_expr; also for local \"rhs\".  Generate a meaningful location\n\tfor the expression, and use it.  Replace call to\n\tprotected_set_expr_location by converting a build2 to a build2_loc\n\tand using the location in the call to build_x_binary_op, adding a\n\tcp_expr::set_location to the latter case.\n\t(cp_parser_question_colon_clause): Convert param from tree to\n\tcp_expr; also for local \"assignment_expr\".  Set the spelling range\n\tof the expression.\n\t(cp_parser_assignment_expression): Likewise for return type and\n\tlocals \"expr\" and \"rhs\".  Build a meaningful spelling range for\n\tthe expression.  Remove saving of input_location in favor of a\n\tcall to cp_expr::set_location.\n\t(cp_parser_expression): Convert return type and locals\n\t\"expression\" and \"assignment_expression\" to cp_expr.  Build a\n\tmeaningful spelling range for assignment expressions.\n\t(cp_parser_constant_expression): Likewise for return type and\n\tlocal \"expression\".\n\t(cp_parser_builtin_offsetof): Convert return type and local \"expr\"\n\tto cp_expr.  Generate suitable locations.\n\t(cp_parser_lambda_expression): Convert return return type to\n\tcp_expr.\n\t(cp_parser_operator_function_id): Likewise.\n\t(cp_parser_operator): Likewise.  Generate a meaningful range,\n\tusing cp_expr's ctor to return it.\n\t(cp_parser_template_id): When converting a token to\n\tCPP_TEMPLATE_ID, update the location.\n\t(cp_parser_initializer_clause): Convert return type and local\n\t\"initializer\" to cp_expr.\n\t(cp_parser_braced_list): Likewise for return type.  Generate\n\tsuitable locations.\n\t(cp_parser_lookup_name): Likewise for return type.  Use cp_expr's\n\tctor to preserve the location_t of the name.\n\t(cp_parser_simple_cast_expression): Likewise for return type.\n\t(cp_parser_functional_cast): Convert return type and local \"cast\"\n\tto cp_expr.  Generate suitable locations.\n\t(cp_parser_objc_expression): Convert return type to cp_expr.k  Generate\n\t(cp_parser_objc_message_expression): Generate suitable locations.\n\t(cp_parser_objc_encode_expression): Convert return type to\n\tcp_expr.  Generate suitable locations.\n\t(cp_parser_objc_protocol_expression): Generate suitable locations.\n\t(cp_parser_objc_selector_expression): Generate suitable locations.\n\t(cp_parser_omp_for_cond): Attempt to use the location\n\tof \"cond\" for the binary op.\n\t(cp_parser_transaction_expression): Issue the tm-not-enabled error\n\tat the location of the __transaction_foo token, rather than at\n\tinput_location.\n\t* semantics.c (finish_parenthesized_expr): Convert return type and\n\tparam to cp_expr.  Preserve location.\n\t(perform_koenig_lookup): Likewise for return type\n\tand param.\n\t(finish_increment_expr): Likewise.  Generate suitable locations.\n\t(finish_unary_op_expr): Likewise for return type and local \"result\".\n\tGenerate suitable locations.\n\t(finish_id_expression): Convert return type to cp_expr and use\n\tcp_expr ctor to preserve location information.\n\t* typeck.c (build_class_member_access_expr): Convert param to\n\tcp_expr.\n\t(finish_class_member_access_expr): Likewise.\n\t(cp_build_binary_op): Convert a build2 to a build2_loc.\n\t(build_x_unary_op): Convert param from tree to cp_expr.\n\t(build_nop): Preserve the location of EXPR.\n\t(build_c_cast): Provide an overloaded variant that takes a cp_expr\n\tand returns a cp_expr.\n\t(build_x_modify_expr): Convert return type from tree to cp_expr.\n\ngcc/testsuite/ChangeLog:\n\t* g++.dg/cpp0x/nsdmi-template14.C: Move dg-error directive.\n\t* g++.dg/gomp/loop-1.C: Update dg-error locations.\n\t* g++.dg/plugin/diagnostic-test-expressions-1.C: New file, adapted\n\tfrom gcc.dg/plugin/diagnostic-test-expressions-1.c.\n\t* g++.dg/plugin/plugin.exp (plugin_test_list): Add the above.\n\t* g++.dg/template/crash55.C: Update dg-error directives.\n\t* g++.dg/template/pseudodtor3.C: Update column numbers in dg-error\n\tdirectives.\n\t* g++.dg/template/pr64100.C: Update location of dg-error\n\tdirective.\n\t* g++.dg/template/ref3.C: Add XFAIL (PR c++/68699).\n\t* g++.dg/ubsan/pr63956.C: Update dg directives to reflect\n\timproved location information.\n\t* g++.dg/warn/pr35635.C (func3): Update location of a\n\tdg-warning.\n\t* g++.dg/warn/Wconversion-real-integer2.C: Update location of\n\tdg-warning; add a dg-message.\n\t* obj-c++.dg/plugin/diagnostic-test-expressions-1.mm: New file,\n\tbased on objc.dg/plugin/diagnostic-test-expressions-1.m.\n\t* obj-c++.dg/plugin/plugin.exp: New file, based on\n\tobjc.dg/plugin/plugin.exp.\n\nFrom-SVN: r231293", "tree": {"sha": "7f2a3f020f12a35212f7815a094bdc273c1afce8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f2a3f020f12a35212f7815a094bdc273c1afce8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b3d5bc621f9c7da0bbac965c610ae2a4044e1a68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3d5bc621f9c7da0bbac965c610ae2a4044e1a68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3d5bc621f9c7da0bbac965c610ae2a4044e1a68"}], "stats": {"total": 2064, "additions": 1822, "deletions": 242}, "files": [{"sha": "9aba352870c1c983a78f8d584c99521647433128", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -1,3 +1,15 @@\n+2015-12-04  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* convert.c (convert_to_real_1): When converting from a\n+\tREAL_TYPE, preserve the location of EXPR in the result.\n+\t* tree.c (get_pure_location): Make non-static.\n+\t(set_source_range): Return the resulting location_t.\n+\t(make_location): New function.\n+\t* tree.h (get_pure_location): New decl.\n+\t(get_finish): New inline function.\n+\t(set_source_range): Convert return type from void to location_t.\n+\t(make_location): New decl.\n+\n 2015-12-04  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/68656"}, {"sha": "8fb86240189103b3d51415bd5b3f274ce77db967", "filename": "gcc/convert.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -362,10 +362,11 @@ convert_to_real_1 (tree type, tree expr, bool fold_p)\n     case REAL_TYPE:\n       /* Ignore the conversion if we don't need to store intermediate\n \t results and neither type is a decimal float.  */\n-      return build1 ((flag_float_store\n-\t\t     || DECIMAL_FLOAT_TYPE_P (type)\n-\t\t     || DECIMAL_FLOAT_TYPE_P (itype))\n-\t\t     ? CONVERT_EXPR : NOP_EXPR, type, expr);\n+      return build1_loc (loc,\n+\t\t\t (flag_float_store\n+\t\t\t  || DECIMAL_FLOAT_TYPE_P (type)\n+\t\t\t  || DECIMAL_FLOAT_TYPE_P (itype))\n+\t\t\t ? CONVERT_EXPR : NOP_EXPR, type, expr);\n \n     case INTEGER_TYPE:\n     case ENUMERAL_TYPE:"}, {"sha": "dd56155b3499662ba5ec30c289724e3b3ebdf251", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -1,3 +1,139 @@\n+2015-12-04  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* cp-tree.h (class cp_expr): New class.\n+\t(finish_parenthesized_expr): Convert return type and param to\n+\tcp_expr.\n+\t(perform_koenig_lookup): Convert return type and param from tree\n+\tto cp_expr.\n+\t(finish_increment_expr): Likewise.\n+\t(finish_unary_op_expr): Likewise.\n+\t(finish_id_expression): Likewise for return type.\n+\t(build_class_member_access_expr): Likewise for param.\n+\t(finish_class_member_access_expr): Likewise.\n+\t(build_x_unary_op): Likewise.\n+\t(build_c_cast): New decl.\n+\t(build_x_modify_expr): Convert return type from tree to cp_expr.\n+\t* cvt.c (cp_convert_and_check): When warning about conversions,\n+\tattempt to use the location of \"expr\" if available, otherwise\n+\tfalling back to the old behavior of using input_location.\n+\t* name-lookup.c (lookup_arg_dependent_1): Convert return type from\n+\ttree to cp_expr.\n+\t(lookup_arg_dependent): Likewise; also for local \"ret\".\n+\t* name-lookup.h (lookup_arg_dependent): Likewise for return type.\n+\t* parser.c (cp_lexer_previous_token): Skip past purged tokens.\n+\t(struct cp_parser_expression_stack_entry): Convert field \"lhs\" to\n+\tcp_expr.\n+\t(cp_parser_identifier): Likewise for return type.  Use cp_expr\n+\tctor to preserve the token's location.\n+\t(cp_parser_string_literal): Likewise, building up a meaningful\n+\tlocation for the case where a compound string literal is built by\n+\tconcatentation.\n+\t(cp_parser_userdef_char_literal): Likewise for return type.\n+\t(cp_parser_userdef_numeric_literal): Likewise.\n+\t(cp_parser_statement_expr): Convert return type to cp_expr.\n+\tGenerate a suitable location for the expr and return it via the\n+\tcp_expr ctor.\n+\t(cp_parser_fold_expression): Convert return type to cp_expr.\n+\t(cp_parser_primary_expression): Likewise, and for locals \"expr\",\n+\t\"lam\", \"id_expression\", \"decl\".\n+\tUse cp_expr ctor when parsing literals, to preserve the spelling\n+\tlocation of the token.  Preserve the locations of parentheses.\n+\tPreserve location when calling objc_lookup_ivar.\n+\tPreserve the location for \"this\" tokens.  Generate suitable\n+\tlocations for \"__builtin_va_arg\" constructs and for\n+\tObjective C 2.0 dot-syntax.  Set the location for the result of\n+\tfinish_id_expression.\n+\t(cp_parser_primary_expression): Convert return type from tree to\n+\tcp_expr.\n+\t(cp_parser_id_expression): Likewise.\n+\t(cp_parser_unqualified_id): Likewise.  Also for local \"id\".\n+\t(cp_parser_postfix_expression): Likewise, also for local\n+\t\"postfix_expression\".  Generate suitable locations for\n+\tC++-style casts, \"_Cilk_spawn\" constructs.  Convert local\n+\t\"initializer\" to cp_expr and use it to preserve the location of\n+\tcompound literals.  Capture the location of the closing\n+\tparenthesis of a call site via\n+\tcp_parser_parenthesized_expression_list, and use it to build\n+\ta source range for a call.  Use cp_expr in ternary expression.\n+\t(cp_parser_postfix_dot_deref_expression): Convert param from tree to\n+\tcp_expr.  Generate and set a location.\n+\t(cp_parser_parenthesized_expression_list): Add \"close_paren_loc\"\n+\tout-param, and write back to it.\n+\t(cp_parser_unary_expression): Convert return type from tree to\n+\tcp_expr.  Also for locals \"cast_expression\" and \"expression\".\n+\tGenerate and use suitable locations for addresses of\n+\tlabels and for cast expressions.  Call cp_expr::set_location where\n+\tnecessary.  Preserve the locations of negated numeric literals.\n+\t(cp_parser_new_expression): Generate meaningful locations/ranges.\n+\t(cp_parser_cast_expression): Convert return type from tree to\n+\tcp_expr; also for local \"expr\".  Use the paren location to generate a\n+\tmeaningful range for the expression.\n+\t(cp_parser_binary_expression): Convert return type from tree to\n+\tcp_expr; also for local \"rhs\".  Generate a meaningful location\n+\tfor the expression, and use it.  Replace call to\n+\tprotected_set_expr_location by converting a build2 to a build2_loc\n+\tand using the location in the call to build_x_binary_op, adding a\n+\tcp_expr::set_location to the latter case.\n+\t(cp_parser_question_colon_clause): Convert param from tree to\n+\tcp_expr; also for local \"assignment_expr\".  Set the spelling range\n+\tof the expression.\n+\t(cp_parser_assignment_expression): Likewise for return type and\n+\tlocals \"expr\" and \"rhs\".  Build a meaningful spelling range for\n+\tthe expression.  Remove saving of input_location in favor of a\n+\tcall to cp_expr::set_location.\n+\t(cp_parser_expression): Convert return type and locals\n+\t\"expression\" and \"assignment_expression\" to cp_expr.  Build a\n+\tmeaningful spelling range for assignment expressions.\n+\t(cp_parser_constant_expression): Likewise for return type and\n+\tlocal \"expression\".\n+\t(cp_parser_builtin_offsetof): Convert return type and local \"expr\"\n+\tto cp_expr.  Generate suitable locations.\n+\t(cp_parser_lambda_expression): Convert return return type to\n+\tcp_expr.\n+\t(cp_parser_operator_function_id): Likewise.\n+\t(cp_parser_operator): Likewise.  Generate a meaningful range,\n+\tusing cp_expr's ctor to return it.\n+\t(cp_parser_template_id): When converting a token to\n+\tCPP_TEMPLATE_ID, update the location.\n+\t(cp_parser_initializer_clause): Convert return type and local\n+\t\"initializer\" to cp_expr.\n+\t(cp_parser_braced_list): Likewise for return type.  Generate\n+\tsuitable locations.\n+\t(cp_parser_lookup_name): Likewise for return type.  Use cp_expr's\n+\tctor to preserve the location_t of the name.\n+\t(cp_parser_simple_cast_expression): Likewise for return type.\n+\t(cp_parser_functional_cast): Convert return type and local \"cast\"\n+\tto cp_expr.  Generate suitable locations.\n+\t(cp_parser_objc_expression): Convert return type to cp_expr.k  Generate\n+\t(cp_parser_objc_message_expression): Generate suitable locations.\n+\t(cp_parser_objc_encode_expression): Convert return type to\n+\tcp_expr.  Generate suitable locations.\n+\t(cp_parser_objc_protocol_expression): Generate suitable locations.\n+\t(cp_parser_objc_selector_expression): Generate suitable locations.\n+\t(cp_parser_omp_for_cond): Attempt to use the location\n+\tof \"cond\" for the binary op.\n+\t(cp_parser_transaction_expression): Issue the tm-not-enabled error\n+\tat the location of the __transaction_foo token, rather than at\n+\tinput_location.\n+\t* semantics.c (finish_parenthesized_expr): Convert return type and\n+\tparam to cp_expr.  Preserve location.\n+\t(perform_koenig_lookup): Likewise for return type\n+\tand param.\n+\t(finish_increment_expr): Likewise.  Generate suitable locations.\n+\t(finish_unary_op_expr): Likewise for return type and local \"result\".\n+\tGenerate suitable locations.\n+\t(finish_id_expression): Convert return type to cp_expr and use\n+\tcp_expr ctor to preserve location information.\n+\t* typeck.c (build_class_member_access_expr): Convert param to\n+\tcp_expr.\n+\t(finish_class_member_access_expr): Likewise.\n+\t(cp_build_binary_op): Convert a build2 to a build2_loc.\n+\t(build_x_unary_op): Convert param from tree to cp_expr.\n+\t(build_nop): Preserve the location of EXPR.\n+\t(build_c_cast): Provide an overloaded variant that takes a cp_expr\n+\tand returns a cp_expr.\n+\t(build_x_modify_expr): Convert return type from tree to cp_expr.\n+\n 2015-12-03  Cesar Philippidis  <cesar@codesourcery.com>\n \n \t* parser.c (cp_ensure_no_oacc_routine): Update error message."}, {"sha": "6ddab8a57cf9d2d59d1541187fed61bf9ede6421", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 73, "deletions": 9, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -40,6 +40,68 @@ c-common.h, not after.\n #include \"c-family/c-common.h\"\n #include \"diagnostic.h\"\n \n+/* A tree node, together with a location, so that we can track locations\n+   (and ranges) during parsing.\n+\n+   The location is redundant for node kinds that have locations,\n+   but not all node kinds do (e.g. constants, and references to\n+   params, locals, etc), so we stash a copy here.  */\n+\n+class cp_expr\n+{\n+public:\n+  cp_expr () :\n+    m_value (NULL), m_loc (UNKNOWN_LOCATION) {}\n+\n+  cp_expr (tree value) :\n+    m_value (value), m_loc (EXPR_LOCATION (m_value)) {}\n+\n+  cp_expr (tree value, location_t loc):\n+    m_value (value), m_loc (loc) {}\n+\n+  cp_expr (const cp_expr &other) :\n+    m_value (other.m_value), m_loc (other.m_loc) {}\n+\n+  /* Implicit conversions to tree.  */\n+  operator tree () const { return m_value; }\n+  tree & operator* () { return m_value; }\n+  tree & operator-> () { return m_value; }\n+\n+  tree get_value () const { return m_value; }\n+  location_t get_location () const { return m_loc; }\n+  location_t get_start () const\n+  {\n+    source_range src_range = get_range_from_loc (line_table, m_loc);\n+    return src_range.m_start;\n+  }\n+  location_t get_finish () const\n+  {\n+    source_range src_range = get_range_from_loc (line_table, m_loc);\n+    return src_range.m_finish;\n+  }\n+\n+  void set_location (location_t loc)\n+  {\n+    protected_set_expr_location (m_value, loc);\n+    m_loc = loc;\n+  }\n+\n+  void set_range (location_t start, location_t finish)\n+  {\n+    set_location (make_location (m_loc, start, finish));\n+  }\n+\n+ private:\n+  tree m_value;\n+  location_t m_loc;\n+};\n+\n+inline bool\n+operator == (const cp_expr &lhs, tree rhs)\n+{\n+  return lhs.get_value () == rhs;\n+}\n+\n #include \"name-lookup.h\"\n \n /* Usage of TREE_LANG_FLAG_?:\n@@ -6291,23 +6353,23 @@ extern tree finish_asm_stmt\t\t\t(int, tree, tree, tree, tree,\n \t\t\t\t\t\t tree);\n extern tree finish_label_stmt\t\t\t(tree);\n extern void finish_label_decl\t\t\t(tree);\n-extern tree finish_parenthesized_expr\t\t(tree);\n+extern cp_expr finish_parenthesized_expr\t(cp_expr);\n extern tree force_paren_expr\t\t\t(tree);\n extern tree finish_non_static_data_member       (tree, tree, tree);\n extern tree begin_stmt_expr\t\t\t(void);\n extern tree finish_stmt_expr_expr\t\t(tree, tree);\n extern tree finish_stmt_expr\t\t\t(tree, bool);\n extern tree stmt_expr_value_expr\t\t(tree);\n bool empty_expr_stmt_p\t\t\t\t(tree);\n-extern tree perform_koenig_lookup\t\t(tree, vec<tree, va_gc> *,\n+extern cp_expr perform_koenig_lookup\t\t(cp_expr, vec<tree, va_gc> *,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree finish_call_expr\t\t\t(tree, vec<tree, va_gc> **, bool,\n \t\t\t\t\t\t bool, tsubst_flags_t);\n extern tree finish_template_variable\t\t(tree, tsubst_flags_t = tf_warning_or_error);\n-extern tree finish_increment_expr\t\t(tree, enum tree_code);\n+extern cp_expr finish_increment_expr\t\t(cp_expr, enum tree_code);\n extern tree finish_this_expr\t\t\t(void);\n extern tree finish_pseudo_destructor_expr       (tree, tree, tree, location_t);\n-extern tree finish_unary_op_expr\t\t(location_t, enum tree_code, tree,\n+extern cp_expr finish_unary_op_expr\t\t(location_t, enum tree_code, cp_expr,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree finish_compound_literal\t\t(tree, tree, tsubst_flags_t);\n extern tree finish_fname\t\t\t(tree);\n@@ -6321,7 +6383,7 @@ extern tree finish_base_specifier\t\t(tree, tree, bool);\n extern void finish_member_declaration\t\t(tree);\n extern bool outer_automatic_var_p\t\t(tree);\n extern tree process_outer_var_ref\t\t(tree, tsubst_flags_t);\n-extern tree finish_id_expression\t\t(tree, tree, tree,\n+extern cp_expr finish_id_expression\t\t(tree, tree, tree,\n \t\t\t\t\t\t cp_id_kind *,\n \t\t\t\t\t\t bool, bool, bool *,\n \t\t\t\t\t\t bool, bool, bool, bool,\n@@ -6564,9 +6626,9 @@ extern tree unlowered_expr_type                 (const_tree);\n extern tree decay_conversion\t\t\t(tree,\n                                                  tsubst_flags_t,\n                                                  bool = true);\n-extern tree build_class_member_access_expr      (tree, tree, tree, bool,\n+extern tree build_class_member_access_expr      (cp_expr, tree, tree, bool,\n \t\t\t\t\t\t tsubst_flags_t);\n-extern tree finish_class_member_access_expr     (tree, tree, bool, \n+extern tree finish_class_member_access_expr     (cp_expr, tree, bool,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_x_indirect_ref\t\t(location_t, tree,\n \t\t\t\t\t\t ref_operator, tsubst_flags_t);\n@@ -6588,7 +6650,7 @@ extern tree build_x_binary_op\t\t\t(location_t,\n extern tree build_x_array_ref\t\t\t(location_t, tree, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_x_unary_op\t\t\t(location_t,\n-\t\t\t\t\t\t enum tree_code, tree,\n+\t\t\t\t\t\t enum tree_code, cp_expr,\n                                                  tsubst_flags_t);\n extern tree cp_build_addr_expr\t\t\t(tree, tsubst_flags_t);\n extern tree cp_build_unary_op                   (enum tree_code, tree, int, \n@@ -6608,8 +6670,10 @@ extern tree build_static_cast\t\t\t(tree, tree, tsubst_flags_t);\n extern tree build_reinterpret_cast\t\t(tree, tree, tsubst_flags_t);\n extern tree build_const_cast\t\t\t(tree, tree, tsubst_flags_t);\n extern tree build_c_cast\t\t\t(location_t, tree, tree);\n+extern cp_expr build_c_cast\t\t\t(location_t loc, tree type,\n+\t\t\t\t\t\t cp_expr expr);\n extern tree cp_build_c_cast\t\t\t(tree, tree, tsubst_flags_t);\n-extern tree build_x_modify_expr\t\t\t(location_t, tree,\n+extern cp_expr build_x_modify_expr\t\t(location_t, tree,\n \t\t\t\t\t\t enum tree_code, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree cp_build_modify_expr\t\t(tree, enum tree_code, tree,"}, {"sha": "f24f28059ba44505f937527e1f275e186495edbd", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -650,8 +650,8 @@ cp_convert_and_check (tree type, tree expr, tsubst_flags_t complain)\n       folded_result = fold_simple (folded_result);\n       if (!TREE_OVERFLOW_P (folded)\n \t  && folded_result != error_mark_node)\n-\twarnings_for_convert_and_check (input_location, type, folded,\n-\t\t\t\t\tfolded_result);\n+\twarnings_for_convert_and_check (EXPR_LOC_OR_LOC (expr, input_location),\n+\t\t\t\t\ttype, folded, folded_result);\n     }\n \n   return result;"}, {"sha": "86c07ef02b2ff2ca855b8374d12ade5685e5aa6f", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -5659,7 +5659,7 @@ arg_assoc (struct arg_lookup *k, tree n)\n /* Performs Koenig lookup depending on arguments, where fns\n    are the functions found in normal lookup.  */\n \n-static tree\n+static cp_expr\n lookup_arg_dependent_1 (tree name, tree fns, vec<tree, va_gc> *args)\n {\n   struct arg_lookup k;\n@@ -5720,10 +5720,10 @@ lookup_arg_dependent_1 (tree name, tree fns, vec<tree, va_gc> *args)\n \n /* Wrapper for lookup_arg_dependent_1.  */\n \n-tree\n+cp_expr\n lookup_arg_dependent (tree name, tree fns, vec<tree, va_gc> *args)\n {\n-  tree ret;\n+  cp_expr ret;\n   bool subtime;\n   subtime = timevar_cond_start (TV_NAME_LOOKUP);\n   ret = lookup_arg_dependent_1 (name, fns, args);"}, {"sha": "d2453e95ec504338691990da324a0cd45f8b410b", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -347,7 +347,7 @@ extern void do_toplevel_using_decl (tree, tree, tree);\n extern void do_local_using_decl (tree, tree, tree);\n extern tree do_class_using_decl (tree, tree);\n extern void do_using_directive (tree);\n-extern tree lookup_arg_dependent (tree, tree, vec<tree, va_gc> *);\n+extern cp_expr lookup_arg_dependent (tree, tree, vec<tree, va_gc> *);\n extern bool is_associated_namespace (tree, tree);\n extern void parse_using_directive (tree, tree);\n extern tree innermost_non_namespace_value (tree);"}, {"sha": "17dba0d0dc66c97a6a13aa8172eaffe9717d784e", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 446, "deletions": 145, "changes": 591, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -733,6 +733,13 @@ cp_lexer_previous_token (cp_lexer *lexer)\n {\n   cp_token_position tp = cp_lexer_previous_token_position (lexer);\n \n+  /* Skip past purged tokens.  */\n+  while (tp->purged_p)\n+    {\n+      gcc_assert (tp != lexer->buffer->address ());\n+      tp--;\n+    }\n+\n   return cp_lexer_token_at (lexer, tp);\n }\n \n@@ -1793,7 +1800,7 @@ struct cp_parser_expression_stack_entry\n {\n   /* Left hand side of the binary operation we are currently\n      parsing.  */\n-  tree lhs;\n+  cp_expr lhs;\n   /* Original tree code for left hand side, if it was a binary\n      expression itself (used for -Wparentheses).  */\n   enum tree_code lhs_type;\n@@ -1947,15 +1954,15 @@ static cp_parser *cp_parser_new\n \n /* Lexical conventions [gram.lex]  */\n \n-static tree cp_parser_identifier\n+static cp_expr cp_parser_identifier\n   (cp_parser *);\n-static tree cp_parser_string_literal\n+static cp_expr cp_parser_string_literal\n   (cp_parser *, bool, bool, bool);\n-static tree cp_parser_userdef_char_literal\n+static cp_expr cp_parser_userdef_char_literal\n   (cp_parser *);\n static tree cp_parser_userdef_string_literal\n   (tree);\n-static tree cp_parser_userdef_numeric_literal\n+static cp_expr cp_parser_userdef_numeric_literal\n   (cp_parser *);\n \n /* Basic concepts [gram.basic]  */\n@@ -1965,31 +1972,31 @@ static bool cp_parser_translation_unit\n \n /* Expressions [gram.expr]  */\n \n-static tree cp_parser_primary_expression\n+static cp_expr cp_parser_primary_expression\n   (cp_parser *, bool, bool, bool, cp_id_kind *);\n-static tree cp_parser_id_expression\n+static cp_expr cp_parser_id_expression\n   (cp_parser *, bool, bool, bool *, bool, bool);\n-static tree cp_parser_unqualified_id\n+static cp_expr cp_parser_unqualified_id\n   (cp_parser *, bool, bool, bool, bool);\n static tree cp_parser_nested_name_specifier_opt\n   (cp_parser *, bool, bool, bool, bool);\n static tree cp_parser_nested_name_specifier\n   (cp_parser *, bool, bool, bool, bool);\n static tree cp_parser_qualifying_entity\n   (cp_parser *, bool, bool, bool, bool, bool);\n-static tree cp_parser_postfix_expression\n+static cp_expr cp_parser_postfix_expression\n   (cp_parser *, bool, bool, bool, bool, cp_id_kind *);\n static tree cp_parser_postfix_open_square_expression\n   (cp_parser *, tree, bool, bool);\n static tree cp_parser_postfix_dot_deref_expression\n-  (cp_parser *, enum cpp_ttype, tree, bool, cp_id_kind *, location_t);\n+  (cp_parser *, enum cpp_ttype, cp_expr, bool, cp_id_kind *, location_t);\n static vec<tree, va_gc> *cp_parser_parenthesized_expression_list\n-  (cp_parser *, int, bool, bool, bool *);\n+  (cp_parser *, int, bool, bool, bool *, location_t * = NULL);\n /* Values for the second parameter of cp_parser_parenthesized_expression_list.  */\n enum { non_attr = 0, normal_attr = 1, id_attr = 2 };\n static void cp_parser_pseudo_destructor_name\n   (cp_parser *, tree, tree *, tree *);\n-static tree cp_parser_unary_expression\n+static cp_expr cp_parser_unary_expression\n   (cp_parser *, cp_id_kind * = NULL, bool = false, bool = false, bool = false);\n static enum tree_code cp_parser_unary_operator\n   (cp_token *);\n@@ -2007,23 +2014,23 @@ static vec<tree, va_gc> *cp_parser_new_initializer\n   (cp_parser *);\n static tree cp_parser_delete_expression\n   (cp_parser *);\n-static tree cp_parser_cast_expression\n+static cp_expr cp_parser_cast_expression\n   (cp_parser *, bool, bool, bool, cp_id_kind *);\n-static tree cp_parser_binary_expression\n+static cp_expr cp_parser_binary_expression\n   (cp_parser *, bool, bool, enum cp_parser_prec, cp_id_kind *);\n static tree cp_parser_question_colon_clause\n-  (cp_parser *, tree);\n-static tree cp_parser_assignment_expression\n+  (cp_parser *, cp_expr);\n+static cp_expr cp_parser_assignment_expression\n   (cp_parser *, cp_id_kind * = NULL, bool = false, bool = false);\n static enum tree_code cp_parser_assignment_operator_opt\n   (cp_parser *);\n-static tree cp_parser_expression\n+static cp_expr cp_parser_expression\n   (cp_parser *, cp_id_kind * = NULL, bool = false, bool = false);\n-static tree cp_parser_constant_expression\n+static cp_expr cp_parser_constant_expression\n   (cp_parser *, bool = false, bool * = NULL);\n-static tree cp_parser_builtin_offsetof\n+static cp_expr cp_parser_builtin_offsetof\n   (cp_parser *);\n-static tree cp_parser_lambda_expression\n+static cp_expr cp_parser_lambda_expression\n   (cp_parser *);\n static void cp_parser_lambda_introducer\n   (cp_parser *, tree);\n@@ -2178,9 +2185,9 @@ static void cp_parser_function_body\n   (cp_parser *, bool);\n static tree cp_parser_initializer\n   (cp_parser *, bool *, bool *);\n-static tree cp_parser_initializer_clause\n+static cp_expr cp_parser_initializer_clause\n   (cp_parser *, bool *);\n-static tree cp_parser_braced_list\n+static cp_expr cp_parser_braced_list\n   (cp_parser*, bool*);\n static vec<constructor_elt, va_gc> *cp_parser_initializer_list\n   (cp_parser *, bool *);\n@@ -2249,9 +2256,9 @@ static tree cp_parser_mem_initializer_id\n \n /* Overloading [gram.over] */\n \n-static tree cp_parser_operator_function_id\n+static cp_expr cp_parser_operator_function_id\n   (cp_parser *);\n-static tree cp_parser_operator\n+static cp_expr cp_parser_operator\n   (cp_parser *);\n \n /* Templates [gram.temp] */\n@@ -2389,15 +2396,15 @@ static tree cp_parser_objc_message_args\n   (cp_parser *);\n static tree cp_parser_objc_message_expression\n   (cp_parser *);\n-static tree cp_parser_objc_encode_expression\n+static cp_expr cp_parser_objc_encode_expression\n   (cp_parser *);\n static tree cp_parser_objc_defs_expression\n   (cp_parser *);\n static tree cp_parser_objc_protocol_expression\n   (cp_parser *);\n static tree cp_parser_objc_selector_expression\n   (cp_parser *);\n-static tree cp_parser_objc_expression\n+static cp_expr cp_parser_objc_expression\n   (cp_parser *);\n static bool cp_parser_objc_selector_p\n   (enum cpp_ttype);\n@@ -2422,7 +2429,7 @@ static tree cp_parser_objc_struct_declaration\n \n /* Utility Routines */\n \n-static tree cp_parser_lookup_name\n+static cp_expr cp_parser_lookup_name\n   (cp_parser *, tree, enum tag_types, bool, bool, bool, tree *, location_t);\n static tree cp_parser_lookup_name_simple\n   (cp_parser *, tree, location_t);\n@@ -2432,7 +2439,7 @@ static bool cp_parser_check_declarator_template_parameters\n   (cp_parser *, cp_declarator *, location_t);\n static bool cp_parser_check_template_parameters\n   (cp_parser *, unsigned, location_t, cp_declarator *);\n-static tree cp_parser_simple_cast_expression\n+static cp_expr cp_parser_simple_cast_expression\n   (cp_parser *);\n static tree cp_parser_global_scope_opt\n   (cp_parser *, bool);\n@@ -2448,7 +2455,7 @@ static void cp_parser_perform_template_parameter_access_checks\n   (vec<deferred_access_check, va_gc> *);\n static tree cp_parser_single_declaration\n   (cp_parser *, vec<deferred_access_check, va_gc> *, bool, bool, bool *);\n-static tree cp_parser_functional_cast\n+static cp_expr cp_parser_functional_cast\n   (cp_parser *, tree);\n static tree cp_parser_save_member_function_body\n   (cp_parser *, cp_decl_specifier_seq *, cp_declarator *, tree);\n@@ -3681,15 +3688,18 @@ cp_parser_pop_lexer (cp_parser *parser)\n /* Parse an identifier.  Returns an IDENTIFIER_NODE representing the\n    identifier.  */\n \n-static tree\n+static cp_expr\n cp_parser_identifier (cp_parser* parser)\n {\n   cp_token *token;\n \n   /* Look for the identifier.  */\n   token = cp_parser_require (parser, CPP_NAME, RT_NAME);\n   /* Return the value.  */\n-  return token ? token->u.value : error_mark_node;\n+  if (token)\n+    return cp_expr (token->u.value, token->location);\n+  else\n+    return error_mark_node;\n }\n \n /* Parse a sequence of adjacent string constants.  Returns a\n@@ -3706,7 +3716,7 @@ cp_parser_identifier (cp_parser* parser)\n    This code is largely lifted from lex_string() in c-lex.c.\n \n    FUTURE: ObjC++ will need to handle @-strings here.  */\n-static tree\n+static cp_expr\n cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok,\n \t\t\t  bool lookup_udlit = true)\n {\n@@ -3728,6 +3738,8 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok,\n       return error_mark_node;\n     }\n \n+  location_t loc = tok->location;\n+\n   if (cpp_userdef_string_p (tok->type))\n     {\n       string_tree = USERDEF_LITERAL_VALUE (tok->u.value);\n@@ -3765,11 +3777,13 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok,\n     }\n   else\n     {\n+      location_t last_tok_loc;\n       gcc_obstack_init (&str_ob);\n       count = 0;\n \n       do\n \t{\n+\t  last_tok_loc = tok->location;\n \t  cp_lexer_consume_token (parser->lexer);\n \t  count++;\n \t  str.text = (const unsigned char *)TREE_STRING_POINTER (string_tree);\n@@ -3824,6 +3838,11 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok,\n \t}\n       while (cp_parser_is_string_literal (tok));\n \n+      /* A string literal built by concatenation has its caret=start at\n+\t the start of the initial string, and its finish at the finish of\n+\t the final string literal.  */\n+      loc = make_location (loc, loc, get_finish (last_tok_loc));\n+\n       strs = (cpp_string *) obstack_finish (&str_ob);\n     }\n \n@@ -3876,7 +3895,7 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok,\n   if (count > 1)\n     obstack_free (&str_ob, 0);\n \n-  return value;\n+  return cp_expr (value, loc);\n }\n \n /* Look up a literal operator with the name and the exact arguments.  */\n@@ -3927,7 +3946,7 @@ lookup_literal_operator (tree name, vec<tree, va_gc> *args)\n /* Parse a user-defined char constant.  Returns a call to a user-defined\n    literal operator taking the character as an argument.  */\n \n-static tree\n+static cp_expr\n cp_parser_userdef_char_literal (cp_parser *parser)\n {\n   cp_token *token = cp_lexer_consume_token (parser->lexer);\n@@ -4019,7 +4038,7 @@ make_string_pack (tree value)\n /* Parse a user-defined numeric constant.  returns a call to a user-defined\n    literal operator.  */\n \n-static tree\n+static cp_expr\n cp_parser_userdef_numeric_literal (cp_parser *parser)\n {\n   cp_token *token = cp_lexer_consume_token (parser->lexer);\n@@ -4272,12 +4291,13 @@ cp_parser_end_tentative_firewall (cp_parser *parser, cp_token_position start,\n /* Parse a GNU statement-expression, i.e. ({ stmts }), except for the\n    enclosing parentheses.  */\n \n-static tree\n+static cp_expr\n cp_parser_statement_expr (cp_parser *parser)\n {\n   cp_token_position start = cp_parser_start_tentative_firewall (parser);\n \n   /* Consume the '('.  */\n+  location_t start_loc = cp_lexer_peek_token (parser->lexer)->location;\n   cp_lexer_consume_token (parser->lexer);\n   /* Start the statement-expression.  */\n   tree expr = begin_stmt_expr ();\n@@ -4286,11 +4306,13 @@ cp_parser_statement_expr (cp_parser *parser)\n   /* Finish up.  */\n   expr = finish_stmt_expr (expr, false);\n   /* Consume the ')'.  */\n+  location_t finish_loc = cp_lexer_peek_token (parser->lexer)->location;\n   if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n     cp_parser_skip_to_end_of_statement (parser);\n \n   cp_parser_end_tentative_firewall (parser, start, expr);\n-  return expr;\n+  location_t combined_loc = make_location (start_loc, start_loc, finish_loc);\n+  return cp_expr (expr, combined_loc);\n }\n \n /* Expressions [gram.expr] */\n@@ -4420,7 +4442,7 @@ cp_parser_fold_operator (cp_parser *parser)\n \n    Note that the '(' and ')' are matched in primary expression. */\n \n-static tree\n+static cp_expr\n cp_parser_fold_expression (cp_parser *parser, tree expr1)\n {\n   cp_id_kind pidk;\n@@ -4540,7 +4562,7 @@ cp_parser_fold_expression (cp_parser *parser, tree expr1)\n    Returns a representation of the expression.  Upon return, *IDK\n    indicates what kind of id-expression (if any) was present.  */\n \n-static tree\n+static cp_expr\n cp_parser_primary_expression (cp_parser *parser,\n \t\t\t      bool address_p,\n \t\t\t      bool cast_p,\n@@ -4625,7 +4647,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t  if (!cast_p)\n \t    cp_parser_non_integral_constant_expression (parser, NIC_FLOAT);\n \t}\n-      return token->u.value;\n+      return cp_expr (token->u.value, token->location);\n \n     case CPP_CHAR_USERDEF:\n     case CPP_CHAR16_USERDEF:\n@@ -4683,9 +4705,11 @@ cp_parser_primary_expression (cp_parser *parser,\n \t}\n       /* Otherwise it's a normal parenthesized expression.  */\n       {\n-\ttree expr;\n+\tcp_expr expr;\n \tbool saved_greater_than_is_operator_p;\n \n+\tlocation_t open_paren_loc = token->location;\n+\n \t/* Consume the `('.  */\n \tcp_lexer_consume_token (parser->lexer);\n \t/* Within a parenthesized expression, a `>' token is always\n@@ -4730,7 +4754,11 @@ cp_parser_primary_expression (cp_parser *parser,\n \t   template-parameter-list now.  */\n \tparser->greater_than_is_operator_p\n \t  = saved_greater_than_is_operator_p;\n+\n \t/* Consume the `)'.  */\n+\ttoken = cp_lexer_peek_token (parser->lexer);\n+\tlocation_t close_paren_loc = token->location;\n+\texpr.set_range (open_paren_loc, close_paren_loc);\n \tif (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN)\n \t    && !cp_parser_uncommitted_to_tentative_parse_p (parser))\n \t  cp_parser_skip_to_end_of_statement (parser);\n@@ -4750,7 +4778,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t      return msg;\n \t    /* ... else, fall though to see if it's a lambda.  */\n \t  }\n-\ttree lam = cp_parser_lambda_expression (parser);\n+\tcp_expr lam = cp_parser_lambda_expression (parser);\n \t/* Don't warn about a failed tentative parse.  */\n \tif (cp_parser_error_occurred (parser))\n \t  return error_mark_node;\n@@ -4771,20 +4799,20 @@ cp_parser_primary_expression (cp_parser *parser,\n \t  /* These two are the boolean literals.  */\n \tcase RID_TRUE:\n \t  cp_lexer_consume_token (parser->lexer);\n-\t  return boolean_true_node;\n+\t  return cp_expr (boolean_true_node, token->location);\n \tcase RID_FALSE:\n \t  cp_lexer_consume_token (parser->lexer);\n-\t  return boolean_false_node;\n+\t  return cp_expr (boolean_false_node, token->location);\n \n \t  /* The `__null' literal.  */\n \tcase RID_NULL:\n \t  cp_lexer_consume_token (parser->lexer);\n-\t  return null_node;\n+\t  return cp_expr (null_node, token->location);\n \n \t  /* The `nullptr' literal.  */\n \tcase RID_NULLPTR:\n \t  cp_lexer_consume_token (parser->lexer);\n-\t  return nullptr_node;\n+\t  return cp_expr (nullptr_node, token->location);\n \n \t  /* Recognize the `this' keyword.  */\n \tcase RID_THIS:\n@@ -4798,7 +4826,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t  /* Pointers cannot appear in constant-expressions.  */\n \t  if (cp_parser_non_integral_constant_expression (parser, NIC_THIS))\n \t    return error_mark_node;\n-\t  return finish_this_expr ();\n+\t  return cp_expr (finish_this_expr (), token->location);\n \n \t  /* The `operator' keyword can be the beginning of an\n \t     id-expression.  */\n@@ -4847,7 +4875,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    tree expression;\n \t    tree type;\n \t    source_location type_location;\n-\n+\t    location_t start_loc\n+\t      = cp_lexer_peek_token (parser->lexer)->location;\n \t    /* The `__builtin_va_arg' construct is used to handle\n \t       `va_arg'.  Consume the `__builtin_va_arg' token.  */\n \t    cp_lexer_consume_token (parser->lexer);\n@@ -4861,13 +4890,22 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    /* Parse the type-id.  */\n \t    type = cp_parser_type_id (parser);\n \t    /* Look for the closing `)'.  */\n+\t    location_t finish_loc\n+\t      = cp_lexer_peek_token (parser->lexer)->location;\n \t    cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \t    /* Using `va_arg' in a constant-expression is not\n \t       allowed.  */\n \t    if (cp_parser_non_integral_constant_expression (parser,\n \t\t\t\t\t\t\t    NIC_VA_ARG))\n \t      return error_mark_node;\n-\t    return build_x_va_arg (type_location, expression, type);\n+\t    /* Construct a location of the form:\n+\t\t __builtin_va_arg (v, int)\n+\t\t ~~~~~~~~~~~~~~~~~~~~~^~~~\n+\t       with the caret at the type, ranging from the start of the\n+\t       \"__builtin_va_arg\" token to the close paren.  */\n+\t    location_t combined_loc\n+\t      = make_location (type_location, start_loc, finish_loc);\n+\t    return build_x_va_arg (combined_loc, expression, type);\n \t  }\n \n \tcase RID_OFFSETOF:\n@@ -4932,14 +4970,14 @@ cp_parser_primary_expression (cp_parser *parser,\n     case CPP_TEMPLATE_ID:\n     case CPP_NESTED_NAME_SPECIFIER:\n       {\n-\ttree id_expression;\n-\ttree decl;\n+      id_expression:\n+\tcp_expr id_expression;\n+\tcp_expr decl;\n \tconst char *error_msg;\n \tbool template_p;\n \tbool done;\n \tcp_token *id_expr_token;\n \n-      id_expression:\n \t/* Parse the id-expression.  */\n \tid_expression\n \t  = cp_parser_id_expression (parser,\n@@ -5004,12 +5042,36 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\tif (component == error_mark_node)\n \t\t  return error_mark_node;\n \n-\t\treturn objc_build_class_component_ref (id_expression, component);\n+\t\ttree result = objc_build_class_component_ref (id_expression,\n+\t\t\t\t\t\t\t      component);\n+\t\t/* Build a location of the form:\n+\t\t     expr.component\n+\t\t     ~~~~~^~~~~~~~~\n+\t\t   with caret at the start of the component name (at\n+\t\t   input_location), ranging from the start of the id_expression\n+\t\t   to the end of the component name.  */\n+\t\tlocation_t combined_loc\n+\t\t  = make_location (input_location, id_expression.get_start (),\n+\t\t\t\t   get_finish (input_location));\n+\t\tprotected_set_expr_location (result, combined_loc);\n+\t\treturn result;\n \t      }\n \n \t    /* In Objective-C++, an instance variable (ivar) may be preferred\n-\t       to whatever cp_parser_lookup_name() found.  */\n-\t    decl = objc_lookup_ivar (decl, id_expression);\n+\t       to whatever cp_parser_lookup_name() found.\n+\t       Call objc_lookup_ivar.  To avoid exposing cp_expr to the\n+\t       rest of c-family, we have to do a little extra work to preserve\n+\t       any location information in cp_expr \"decl\".  Given that\n+\t       objc_lookup_ivar is implemented in \"c-family\" and \"objc\", we\n+\t       have a trip through the pure \"tree\" type, rather than cp_expr.\n+\t       Naively copying it back to \"decl\" would implicitly give the\n+\t       new cp_expr value an UNKNOWN_LOCATION for nodes that don't\n+\t       store an EXPR_LOCATION.  Hence we only update \"decl\" (and\n+\t       hence its location_t) if we get back a different tree node.  */\n+\t    tree decl_tree = objc_lookup_ivar (decl.get_value (),\n+\t\t\t\t\t       id_expression);\n+\t    if (decl_tree != decl.get_value ())\n+\t      decl = cp_expr (decl_tree);\n \n \t    /* If name lookup gives us a SCOPE_REF, then the\n \t       qualifying scope was dependent.  */\n@@ -5050,7 +5112,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t  {\n \t\t    error_at (id_expr_token->location,\n \t\t\t      \"local variable %qD may not appear in this context\",\n-\t\t\t      decl);\n+\t\t\t      decl.get_value ());\n \t\t    return error_mark_node;\n \t\t  }\n \t      }\n@@ -5068,6 +5130,7 @@ cp_parser_primary_expression (cp_parser *parser,\n                  id_expr_token->location));\n \tif (error_msg)\n \t  cp_parser_error (parser, error_msg);\n+\tdecl.set_location (id_expr_token->location);\n \treturn decl;\n       }\n \n@@ -5078,7 +5141,7 @@ cp_parser_primary_expression (cp_parser *parser,\n     }\n }\n \n-static inline tree\n+static inline cp_expr\n cp_parser_primary_expression (cp_parser *parser,\n \t\t\t      bool address_p,\n \t\t\t      bool cast_p,\n@@ -5123,7 +5186,7 @@ cp_parser_primary_expression (cp_parser *parser,\n    If DECLARATOR_P is true, the id-expression is appearing as part of\n    a declarator, rather than as part of an expression.  */\n \n-static tree\n+static cp_expr\n cp_parser_id_expression (cp_parser *parser,\n \t\t\t bool template_keyword_p,\n \t\t\t bool check_dependency_p,\n@@ -5258,7 +5321,7 @@ cp_parser_id_expression (cp_parser *parser,\n    is true, the unqualified-id is appearing as part of a declarator,\n    rather than as part of an expression.  */\n \n-static tree\n+static cp_expr\n cp_parser_unqualified_id (cp_parser* parser,\n \t\t\t  bool template_keyword_p,\n \t\t\t  bool check_dependency_p,\n@@ -5521,7 +5584,7 @@ cp_parser_unqualified_id (cp_parser* parser,\n     case CPP_KEYWORD:\n       if (token->keyword == RID_OPERATOR)\n \t{\n-\t  tree id;\n+\t  cp_expr id;\n \n \t  /* This could be a template-id, so we try that first.  */\n \t  cp_parser_parse_tentatively (parser);\n@@ -6111,7 +6174,7 @@ cp_parser_compound_literal_p (cp_parser *parser)\n \n    Returns a representation of the expression.  */\n \n-static tree\n+static cp_expr\n cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n                               bool member_access_only_p, bool decltype_p,\n \t\t\t      cp_id_kind * pidk_return)\n@@ -6120,13 +6183,15 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n   location_t loc;\n   enum rid keyword;\n   cp_id_kind idk = CP_ID_KIND_NONE;\n-  tree postfix_expression = NULL_TREE;\n+  cp_expr postfix_expression = NULL_TREE;\n   bool is_member_access = false;\n   int saved_in_statement = -1;\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n   loc = token->location;\n+  location_t start_loc = get_range_from_loc (line_table, loc).m_start;\n+\n   /* Some of the productions are determined by keywords.  */\n   keyword = token->keyword;\n   switch (keyword)\n@@ -6137,7 +6202,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n     case RID_CONSTCAST:\n       {\n \ttree type;\n-\ttree expression;\n+\tcp_expr expression;\n \tconst char *saved_message;\n \tbool saved_in_type_id_in_expr_p;\n \n@@ -6170,7 +6235,10 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t/* And the expression which is being cast.  */\n \tcp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n \texpression = cp_parser_expression (parser, & idk, /*cast_p=*/true);\n-\tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\tcp_token *close_paren = cp_parser_require (parser, CPP_CLOSE_PAREN,\n+\t\t\t\t\t\t   RT_CLOSE_PAREN);\n+\tlocation_t end_loc = close_paren ?\n+\t  close_paren->location : UNKNOWN_LOCATION;\n \n \tparser->greater_than_is_operator_p\n \t  = saved_greater_than_is_operator_p;\n@@ -6203,6 +6271,14 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t  default:\n \t    gcc_unreachable ();\n \t  }\n+\n+\t/* Construct a location e.g. :\n+\t     reinterpret_cast <int *> (expr)\n+\t     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\t   ranging from the start of the \"*_cast\" token to the final closing\n+\t   paren, with the caret at the start.  */\n+\tlocation_t cp_cast_loc = make_location (start_loc, start_loc, end_loc);\n+\tpostfix_expression.set_location (cp_cast_loc);\n       }\n       break;\n \n@@ -6271,6 +6347,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \n     case RID_CILK_SPAWN:\n       {\n+\tlocation_t cilk_spawn_loc\n+\t  = cp_lexer_peek_token (parser->lexer)->location;\n \tcp_lexer_consume_token (parser->lexer);\n \ttoken = cp_lexer_peek_token (parser->lexer);\n \tif (token->type == CPP_SEMICOLON)\n@@ -6312,8 +6390,17 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t  }\n \telse\n \t  {\n+\t    location_t loc = postfix_expression.get_location ();\n \t    postfix_expression = build_cilk_spawn (token->location, \n \t\t\t\t\t\t   postfix_expression);\n+\t    /* Build a location of the form:\n+\t\t _Cilk_spawn expr\n+\t\t ~~~~~~~~~~~~^~~~\n+\t       with caret at the expr, ranging from the start of the\n+\t       _Cilk_spawn token to the end of the expression.  */\n+\t    location_t combined_loc =\n+\t      make_location (loc, cilk_spawn_loc, get_finish (loc));\n+\t    postfix_expression.set_location (combined_loc);\n \t    if (postfix_expression != error_mark_node) \n \t      SET_EXPR_LOCATION (postfix_expression, input_location);\n \t    parser->in_statement = parser->in_statement & ~IN_CILK_SPAWN;\n@@ -6380,7 +6467,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \tif (cp_parser_allow_gnu_extensions_p (parser)\n \t    && cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n \t  {\n-\t    tree initializer = NULL_TREE;\n+\t    cp_expr initializer = NULL_TREE;\n \n \t    cp_parser_parse_tentatively (parser);\n \n@@ -6435,6 +6522,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\tpostfix_expression\n \t\t  = finish_compound_literal (type, initializer,\n \t\t\t\t\t     tf_warning_or_error);\n+\t\tpostfix_expression.set_location (initializer.get_location ());\n \t\tbreak;\n \t      }\n \t  }\n@@ -6482,6 +6570,9 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t\t\t\t\t\tpostfix_expression,\n \t\t\t\t\t\t\tfalse,\n \t\t\t\t\t\t\tdecltype_p);\n+\t  postfix_expression.set_range (start_loc,\n+\t\t\t\t\tpostfix_expression.get_location ());\n+\n \t  idk = CP_ID_KIND_NONE;\n           is_member_access = false;\n \t  break;\n@@ -6495,6 +6586,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    bool saved_non_integral_constant_expression_p = false;\n \t    tsubst_flags_t complain = complain_flags (decltype_p);\n \t    vec<tree, va_gc> *args;\n+\t    location_t close_paren_loc;\n \n             is_member_access = false;\n \n@@ -6513,7 +6605,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    args = (cp_parser_parenthesized_expression_list\n \t\t    (parser, non_attr,\n \t\t     /*cast_p=*/false, /*allow_expansion_p=*/true,\n-\t\t     /*non_constant_p=*/NULL));\n+\t\t     /*non_constant_p=*/NULL,\n+\t\t     /*close_paren_loc=*/&close_paren_loc));\n \t    if (is_builtin_constant_p)\n \t      {\n \t\tparser->integral_constant_expression_p\n@@ -6655,7 +6748,10 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t\t\t    koenig_p,\n \t\t\t\t    complain);\n \n-\t    protected_set_expr_location (postfix_expression, token->location);\n+\t    location_t combined_loc = make_location (token->location,\n+\t\t\t\t\t\t     start_loc,\n+\t\t\t\t\t\t     close_paren_loc);\n+\t    postfix_expression.set_location (combined_loc);\n \n \t    /* The POSTFIX_EXPRESSION is certainly no longer an id.  */\n \t    idk = CP_ID_KIND_NONE;\n@@ -6716,7 +6812,9 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t  if (pidk_return != NULL)\n \t    * pidk_return = idk;\n           if (member_access_only_p)\n-            return is_member_access? postfix_expression : error_mark_node;\n+            return is_member_access\n+              ? postfix_expression\n+              : cp_expr (error_mark_node);\n           else\n             return postfix_expression;\n \t}\n@@ -6916,14 +7014,15 @@ cp_parser_postfix_open_square_expression (cp_parser *parser,\n static tree\n cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \t\t\t\t\tenum cpp_ttype token_type,\n-\t\t\t\t\ttree postfix_expression,\n+\t\t\t\t\tcp_expr postfix_expression,\n \t\t\t\t\tbool for_offsetof, cp_id_kind *idk,\n \t\t\t\t\tlocation_t location)\n {\n   tree name;\n   bool dependent_p;\n   bool pseudo_destructor_p;\n   tree scope = NULL_TREE;\n+  location_t start_loc = postfix_expression.get_start ();\n \n   /* If this is a `->' operator, dereference the pointer.  */\n   if (token_type == CPP_DEREF)\n@@ -6953,7 +7052,7 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n       if (scope == unknown_type_node)\n \t{\n \t  error_at (location, \"%qE does not have class type\",\n-\t\t    postfix_expression);\n+\t\t    postfix_expression.get_value ());\n \t  scope = NULL_TREE;\n \t}\n       /* Unlike the object expression in other contexts, *this is not\n@@ -7070,6 +7169,16 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \t    = finish_class_member_access_expr (postfix_expression, name,\n \t\t\t\t\t       template_p, \n \t\t\t\t\t       tf_warning_or_error);\n+\t  /* Build a location e.g.:\n+\t       ptr->access_expr\n+\t       ~~~^~~~~~~~~~~~~\n+\t     where the caret is at the deref token, ranging from\n+\t     the start of postfix_expression to the end of the access expr.  */\n+\t  location_t end_loc\n+\t    = get_finish (cp_lexer_previous_token (parser->lexer)->location);\n+\t  location_t combined_loc\n+\t    = make_location (input_location, start_loc, end_loc);\n+\t  protected_set_expr_location (postfix_expression, combined_loc);\n \t}\n     }\n \n@@ -7118,7 +7227,8 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \t\t\t\t\t int is_attribute_list,\n \t\t\t\t\t bool cast_p,\n                                          bool allow_expansion_p,\n-\t\t\t\t\t bool *non_constant_p)\n+\t\t\t\t\t bool *non_constant_p,\n+\t\t\t\t\t location_t *close_paren_loc)\n {\n   vec<tree, va_gc> *expression_list;\n   bool fold_expr_p = is_attribute_list != non_attr;\n@@ -7222,6 +7332,9 @@ cp_parser_parenthesized_expression_list (cp_parser* parser,\n \tcp_lexer_consume_token (parser->lexer);\n       }\n \n+  if (close_paren_loc)\n+    *close_paren_loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n   if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n     {\n       int ending;\n@@ -7391,7 +7504,7 @@ cp_parser_pseudo_destructor_name (cp_parser* parser,\n \n    Returns a representation of the expression.  */\n \n-static tree\n+static cp_expr\n cp_parser_unary_expression (cp_parser *parser, cp_id_kind * pidk,\n \t\t\t    bool address_p, bool cast_p, bool decltype_p)\n {\n@@ -7589,14 +7702,22 @@ cp_parser_unary_expression (cp_parser *parser, cp_id_kind * pidk,\n \t{\n \t  tree identifier;\n \t  tree expression;\n-\t  location_t loc = token->location;\n+\t  location_t start_loc = token->location;\n \n \t  /* Consume the '&&' token.  */\n \t  cp_lexer_consume_token (parser->lexer);\n \t  /* Look for the identifier.  */\n+\t  location_t finish_loc\n+\t    = get_finish (cp_lexer_peek_token (parser->lexer)->location);\n \t  identifier = cp_parser_identifier (parser);\n+\t  /* Construct a location of the form:\n+\t       &&label\n+\t       ^~~~~~~\n+\t     with caret==start at the \"&&\", finish at the end of the label.  */\n+\t  location_t combined_loc\n+\t    = make_location (start_loc, start_loc, finish_loc);\n \t  /* Create an expression representing the address.  */\n-\t  expression = finish_label_address_expr (identifier, loc);\n+\t  expression = finish_label_address_expr (identifier, combined_loc);\n \t  if (cp_parser_non_integral_constant_expression (parser,\n \t\t\t\t\t\t\t  NIC_ADDR_LABEL))\n \t    expression = error_mark_node;\n@@ -7605,8 +7726,8 @@ cp_parser_unary_expression (cp_parser *parser, cp_id_kind * pidk,\n     }\n   if (unary_operator != ERROR_MARK)\n     {\n-      tree cast_expression;\n-      tree expression = error_mark_node;\n+      cp_expr cast_expression;\n+      cp_expr expression = error_mark_node;\n       non_integral_constant non_constant_p = NIC_NONE;\n       location_t loc = token->location;\n       tsubst_flags_t complain = complain_flags (decltype_p);\n@@ -7622,6 +7743,14 @@ cp_parser_unary_expression (cp_parser *parser, cp_id_kind * pidk,\n \t\t\t\t     /*cast_p=*/false,\n \t\t\t\t     /*decltype*/false,\n \t\t\t\t     pidk);\n+\n+      /* Make a location:\n+\t    OP_TOKEN  CAST_EXPRESSION\n+\t    ^~~~~~~~~~~~~~~~~~~~~~~~~\n+\t with start==caret at the operator token, and\n+\t extending to the end of the cast_expression.  */\n+      loc = make_location (loc, loc, cast_expression.get_finish ());\n+\n       /* Now, build an appropriate representation.  */\n       switch (unary_operator)\n \t{\n@@ -7630,6 +7759,9 @@ cp_parser_unary_expression (cp_parser *parser, cp_id_kind * pidk,\n \t  expression = build_x_indirect_ref (loc, cast_expression,\n \t\t\t\t\t     RO_UNARY_STAR,\n                                              complain);\n+          /* TODO: build_x_indirect_ref does not always honor the\n+             location, so ensure it is set.  */\n+          expression.set_location (loc);\n \t  break;\n \n \tcase ADDR_EXPR:\n@@ -7639,6 +7771,9 @@ cp_parser_unary_expression (cp_parser *parser, cp_id_kind * pidk,\n \t  expression = build_x_unary_op (loc, unary_operator,\n \t\t\t\t\t cast_expression,\n                                          complain);\n+          /* TODO: build_x_unary_op does not always honor the location,\n+             so ensure it is set.  */\n+          expression.set_location (loc);\n \t  break;\n \n \tcase PREINCREMENT_EXPR:\n@@ -7659,7 +7794,7 @@ cp_parser_unary_expression (cp_parser *parser, cp_id_kind * pidk,\n \t\t\t\t\t cast_expression);\n \t      if (CONSTANT_CLASS_P (folded) && !TREE_OVERFLOW (folded))\n \t\t{\n-\t\t  expression = folded;\n+\t\t  expression = cp_expr (folded, loc);\n \t\t  break;\n \t\t}\n \t    }\n@@ -7737,6 +7872,8 @@ cp_parser_new_expression (cp_parser* parser)\n   tree nelts = NULL_TREE;\n   tree ret;\n \n+  location_t start_loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n   /* Look for the optional `::' operator.  */\n   global_scope_p\n     = (cp_parser_global_scope_opt (parser,\n@@ -7821,9 +7958,19 @@ cp_parser_new_expression (cp_parser* parser)\n     }\n   else\n     {\n+      /* Construct a location e.g.:\n+           ptr = new int[100]\n+                 ^~~~~~~~~~~~\n+         with caret == start at the start of the \"new\" token, and the end\n+         at the end of the final token we consumed.  */\n+      cp_token *end_tok = cp_lexer_previous_token (parser->lexer);\n+      location_t end_loc = get_finish (end_tok->location);\n+      location_t combined_loc = make_location (start_loc, start_loc, end_loc);\n+\n       /* Create a representation of the new-expression.  */\n       ret = build_new (&placement, type, nelts, &initializer, global_scope_p,\n \t\t       tf_warning_or_error);\n+      protected_set_expr_location (ret, combined_loc);\n     }\n \n   if (placement != NULL)\n@@ -8203,15 +8350,15 @@ cp_parser_tokens_start_cast_expression (cp_parser *parser)\n \n    Returns a representation of the expression.  */\n \n-static tree\n+static cp_expr\n cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t\t   bool decltype_p, cp_id_kind * pidk)\n {\n   /* If it's a `(', then we might be looking at a cast.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n     {\n       tree type = NULL_TREE;\n-      tree expr = NULL_TREE;\n+      cp_expr expr (NULL_TREE);\n       int cast_expression = 0;\n       const char *saved_message;\n \n@@ -8224,7 +8371,9 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n       parser->type_definition_forbidden_message\n \t= G_(\"types may not be defined in casts\");\n       /* Consume the `('.  */\n-      cp_lexer_consume_token (parser->lexer);\n+      cp_token *open_paren = cp_lexer_consume_token (parser->lexer);\n+      location_t open_paren_loc = open_paren->location;\n+\n       /* A very tricky bit is that `(struct S) { 3 }' is a\n \t compound-literal (which we permit in C++ as an extension).\n \t But, that construct is not a cast-expression -- it is a\n@@ -8326,7 +8475,15 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\treturn error_mark_node;\n \n \t      /* Perform the cast.  */\n-\t      expr = build_c_cast (input_location, type, expr);\n+\t      /* Make a location:\n+\t\t   (TYPE) EXPR\n+\t\t   ^~~~~~~~~~~\n+\t\t with start==caret at the open paren, extending to the\n+\t\t end of \"expr\".  */\n+\t      location_t cast_loc = make_location (open_paren_loc,\n+\t\t\t\t\t\t   open_paren_loc,\n+\t\t\t\t\t\t   expr.get_finish ());\n+\t      expr = build_c_cast (cast_loc, type, expr);\n \t      return expr;\n \t    }\n \t}\n@@ -8419,7 +8576,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p,\n  ? PREC_NOT_OPERATOR\t\t\t\t\t     \\\n  : binops_by_token[token->type].prec)\n \n-static tree\n+static cp_expr\n cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \t\t\t     bool no_toplevel_fold_p,\n \t\t\t     bool decltype_p,\n@@ -8429,7 +8586,7 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n   cp_parser_expression_stack stack;\n   cp_parser_expression_stack_entry *sp = &stack[0];\n   cp_parser_expression_stack_entry current;\n-  tree rhs;\n+  cp_expr rhs;\n   cp_token *token;\n   enum tree_code rhs_type;\n   enum cp_parser_prec new_prec, lookahead_prec;\n@@ -8569,6 +8726,11 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \t\t\t\t      maybe_constant_value (rhs));\n \n       overload = NULL;\n+\n+      location_t combined_loc = make_location (current.loc,\n+\t\t\t\t\t       current.lhs.get_start (),\n+\t\t\t\t\t       rhs.get_finish ());\n+\n       /* ??? Currently we pass lhs_type == ERROR_MARK and rhs_type ==\n \t ERROR_MARK for everything that is not a binary expression.\n \t This makes warn_about_parentheses miss some warnings that\n@@ -8579,18 +8741,22 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n       if (no_toplevel_fold_p\n \t  && lookahead_prec <= current.prec\n \t  && sp == stack)\n-\tcurrent.lhs = build2 (current.tree_type,\n-\t\t\t      TREE_CODE_CLASS (current.tree_type)\n-\t\t\t      == tcc_comparison\n-\t\t\t      ? boolean_type_node : TREE_TYPE (current.lhs),\n-\t\t\t      current.lhs, rhs);\n+\tcurrent.lhs = build2_loc (combined_loc,\n+\t\t\t\t  current.tree_type,\n+\t\t\t\t  TREE_CODE_CLASS (current.tree_type)\n+\t\t\t\t  == tcc_comparison\n+\t\t\t\t  ? boolean_type_node : TREE_TYPE (current.lhs),\n+\t\t\t\t  current.lhs, rhs);\n       else\n-\tcurrent.lhs = build_x_binary_op (current.loc, current.tree_type,\n-\t\t\t\t\t current.lhs, current.lhs_type,\n-\t\t\t\t\t rhs, rhs_type, &overload,\n-\t\t\t\t\t complain_flags (decltype_p));\n+        {\n+          current.lhs = build_x_binary_op (combined_loc, current.tree_type,\n+                                           current.lhs, current.lhs_type,\n+                                           rhs, rhs_type, &overload,\n+                                           complain_flags (decltype_p));\n+          /* TODO: build_x_binary_op doesn't always honor the location.  */\n+          current.lhs.set_location (combined_loc);\n+        }\n       current.lhs_type = current.tree_type;\n-      protected_set_expr_location (current.lhs, current.loc);\n \n       /* If the binary operator required the use of an overloaded operator,\n \t then this expression cannot be an integral constant-expression.\n@@ -8607,7 +8773,7 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n   return current.lhs;\n }\n \n-static tree\n+static cp_expr\n cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \t\t\t     bool no_toplevel_fold_p,\n \t\t\t     enum cp_parser_prec prec,\n@@ -8631,10 +8797,10 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n      ? : assignment-expression */\n \n static tree\n-cp_parser_question_colon_clause (cp_parser* parser, tree logical_or_expr)\n+cp_parser_question_colon_clause (cp_parser* parser, cp_expr logical_or_expr)\n {\n   tree expr, folded_logical_or_expr = cp_fully_fold (logical_or_expr);\n-  tree assignment_expr;\n+  cp_expr assignment_expr;\n   struct cp_token *token;\n   location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n \n@@ -8673,6 +8839,15 @@ cp_parser_question_colon_clause (cp_parser* parser, tree logical_or_expr)\n   c_inhibit_evaluation_warnings -=\n     folded_logical_or_expr == truthvalue_true_node;\n \n+  /* Make a location:\n+       LOGICAL_OR_EXPR ? EXPR : ASSIGNMENT_EXPR\n+       ~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~\n+     with the caret at the \"?\", ranging from the start of\n+     the logical_or_expr to the end of the assignment_expr.  */\n+  loc = make_location (loc,\n+\t\t       logical_or_expr.get_start (),\n+\t\t       assignment_expr.get_finish ());\n+\n   /* Build the conditional-expression.  */\n   return build_x_conditional_expr (loc, logical_or_expr,\n \t\t\t\t   expr,\n@@ -8692,11 +8867,11 @@ cp_parser_question_colon_clause (cp_parser* parser, tree logical_or_expr)\n \n    Returns a representation for the expression.  */\n \n-static tree\n+static cp_expr\n cp_parser_assignment_expression (cp_parser* parser, cp_id_kind * pidk,\n \t\t\t\t bool cast_p, bool decltype_p)\n {\n-  tree expr;\n+  cp_expr expr;\n \n   /* If the next token is the `throw' keyword, then we're looking at\n      a throw-expression.  */\n@@ -8725,10 +8900,10 @@ cp_parser_assignment_expression (cp_parser* parser, cp_id_kind * pidk,\n \t  if (assignment_operator != ERROR_MARK)\n \t    {\n \t      bool non_constant_p;\n-\t      location_t saved_input_location;\n \n \t      /* Parse the right-hand side of the assignment.  */\n-\t      tree rhs = cp_parser_initializer_clause (parser, &non_constant_p);\n+\t      cp_expr rhs = cp_parser_initializer_clause (parser,\n+\t\t\t\t\t\t\t  &non_constant_p);\n \n \t      if (BRACE_ENCLOSED_INITIALIZER_P (rhs))\n \t\tmaybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);\n@@ -8739,14 +8914,22 @@ cp_parser_assignment_expression (cp_parser* parser, cp_id_kind * pidk,\n \t\t\t\t\t\t\t      NIC_ASSIGNMENT))\n \t\treturn error_mark_node;\n \t      /* Build the assignment expression.  Its default\n-\t\t location is the location of the '=' token.  */\n-\t      saved_input_location = input_location;\n-\t      input_location = loc;\n+\t\t location:\n+\t\t   LHS = RHS\n+\t\t   ~~~~^~~~~\n+\t\t is the location of the '=' token as the\n+\t\t caret, ranging from the start of the lhs to the\n+\t\t end of the rhs.  */\n+\t      loc = make_location (loc,\n+\t\t\t\t   expr.get_start (),\n+\t\t\t\t   rhs.get_finish ());\n \t      expr = build_x_modify_expr (loc, expr,\n \t\t\t\t\t  assignment_operator,\n \t\t\t\t\t  rhs,\n \t\t\t\t\t  complain_flags (decltype_p));\n-\t      input_location = saved_input_location;\n+              /* TODO: build_x_modify_expr doesn't honor the location,\n+                 so we must set it here.  */\n+              expr.set_location (loc);\n \t    }\n \t}\n     }\n@@ -8855,16 +9038,16 @@ cp_parser_assignment_operator_opt (cp_parser* parser)\n \n    Returns a representation of the expression.  */\n \n-static tree\n+static cp_expr\n cp_parser_expression (cp_parser* parser, cp_id_kind * pidk,\n \t\t      bool cast_p, bool decltype_p)\n {\n-  tree expression = NULL_TREE;\n+  cp_expr expression = NULL_TREE;\n   location_t loc = UNKNOWN_LOCATION;\n \n   while (true)\n     {\n-      tree assignment_expression;\n+      cp_expr assignment_expression;\n \n       /* Parse the next assignment-expression.  */\n       assignment_expression\n@@ -8886,9 +9069,17 @@ cp_parser_expression (cp_parser* parser, cp_id_kind * pidk,\n       if (!expression)\n \texpression = assignment_expression;\n       else\n-\texpression = build_x_compound_expr (loc, expression,\n-\t\t\t\t\t    assignment_expression,\n-\t\t\t\t\t    complain_flags (decltype_p));\n+\t{\n+\t  /* Create a location with caret at the comma, ranging\n+\t     from the start of the LHS to the end of the RHS.  */\n+\t  loc = make_location (loc,\n+\t\t\t       expression.get_start (),\n+\t\t\t       assignment_expression.get_finish ());\n+\t  expression = build_x_compound_expr (loc, expression,\n+\t\t\t\t\t      assignment_expression,\n+\t\t\t\t\t      complain_flags (decltype_p));\n+\t  expression.set_location (loc);\n+\t}\n       /* If the next token is not a comma, or we're in a fold-expression, then\n \t we are done with the expression.  */\n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA)\n@@ -8915,15 +9106,15 @@ cp_parser_expression (cp_parser* parser, cp_id_kind * pidk,\n   constant, *NON_CONSTANT_P is set to TRUE.  If ALLOW_NON_CONSTANT_P\n   is false, NON_CONSTANT_P should be NULL.  */\n \n-static tree\n+static cp_expr\n cp_parser_constant_expression (cp_parser* parser,\n \t\t\t       bool allow_non_constant_p,\n \t\t\t       bool *non_constant_p)\n {\n   bool saved_integral_constant_expression_p;\n   bool saved_allow_non_integral_constant_expression_p;\n   bool saved_non_integral_constant_expression_p;\n-  tree expression;\n+  cp_expr expression;\n \n   /* It might seem that we could simply parse the\n      conditional-expression, and then check to see if it were\n@@ -8996,20 +9187,24 @@ cp_parser_constant_expression (cp_parser* parser,\n      | offsetof-member-designator \"[\" expression \"]\"\n      | offsetof-member-designator \"->\" id-expression  */\n \n-static tree\n+static cp_expr\n cp_parser_builtin_offsetof (cp_parser *parser)\n {\n   int save_ice_p, save_non_ice_p;\n-  tree type, expr;\n+  tree type;\n+  cp_expr expr;\n   cp_id_kind dummy;\n   cp_token *token;\n+  location_t finish_loc;\n \n   /* We're about to accept non-integral-constant things, but will\n      definitely yield an integral constant expression.  Save and\n      restore these values around our local parsing.  */\n   save_ice_p = parser->integral_constant_expression_p;\n   save_non_ice_p = parser->non_integral_constant_expression_p;\n \n+  location_t start_loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n   /* Consume the \"__builtin_offsetof\" token.  */\n   cp_lexer_consume_token (parser->lexer);\n   /* Consume the opening `('.  */\n@@ -9055,6 +9250,7 @@ cp_parser_builtin_offsetof (cp_parser *parser)\n \n \tcase CPP_CLOSE_PAREN:\n \t  /* Consume the \")\" token.  */\n+\t  finish_loc = cp_lexer_peek_token (parser->lexer)->location;\n \t  cp_lexer_consume_token (parser->lexer);\n \t  goto success;\n \n@@ -9069,7 +9265,15 @@ cp_parser_builtin_offsetof (cp_parser *parser)\n     }\n \n  success:\n-  expr = finish_offsetof (expr, loc);\n+  /* Make a location of the form:\n+       __builtin_offsetof (struct s, f)\n+       ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n+     with caret at the type-id, ranging from the start of the\n+     \"_builtin_offsetof\" token to the close paren.  */\n+  loc = make_location (loc, start_loc, finish_loc);\n+  /* The result will be an INTEGER_CST, so we need to explicitly\n+     preserve the location.  */\n+  expr = cp_expr (finish_offsetof (expr, loc), loc);\n \n  failure:\n   parser->integral_constant_expression_p = save_ice_p;\n@@ -9293,7 +9497,7 @@ finish_lambda_scope (void)\n \n    Returns a representation of the expression.  */\n \n-static tree\n+static cp_expr\n cp_parser_lambda_expression (cp_parser* parser)\n {\n   tree lambda_expr = build_lambda_expr ();\n@@ -13290,7 +13494,7 @@ cp_parser_mem_initializer_id (cp_parser* parser)\n    Returns an IDENTIFIER_NODE for the operator which is a\n    human-readable spelling of the identifier, e.g., `operator +'.  */\n \n-static tree\n+static cp_expr\n cp_parser_operator_function_id (cp_parser* parser)\n {\n   /* Look for the `operator' keyword.  */\n@@ -13330,7 +13534,7 @@ cp_literal_operator_id (const char* name)\n    Returns an IDENTIFIER_NODE for the operator which is a\n    human-readable spelling of the identifier, e.g., `operator +'.  */\n \n-static tree\n+static cp_expr\n cp_parser_operator (cp_parser* parser)\n {\n   tree id = NULL_TREE;\n@@ -13339,6 +13543,9 @@ cp_parser_operator (cp_parser* parser)\n \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n+\n+  location_t start_loc = token->location;\n+\n   /* Figure out which operator we have.  */\n   switch (token->type)\n     {\n@@ -13355,7 +13562,7 @@ cp_parser_operator (cp_parser* parser)\n \t  break;\n \n \t/* Consume the `new' or `delete' token.  */\n-\tcp_lexer_consume_token (parser->lexer);\n+\tlocation_t end_loc = cp_lexer_consume_token (parser->lexer)->location;\n \n \t/* Peek at the next token.  */\n \ttoken = cp_lexer_peek_token (parser->lexer);\n@@ -13366,15 +13573,18 @@ cp_parser_operator (cp_parser* parser)\n \t    /* Consume the `[' token.  */\n \t    cp_lexer_consume_token (parser->lexer);\n \t    /* Look for the `]' token.  */\n-\t    cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n+\t    end_loc = cp_parser_require (parser, CPP_CLOSE_SQUARE,\n+                                         RT_CLOSE_SQUARE)->location;\n \t    id = ansi_opname (op == NEW_EXPR\n \t\t\t      ? VEC_NEW_EXPR : VEC_DELETE_EXPR);\n \t  }\n \t/* Otherwise, we have the non-array variant.  */\n \telse\n \t  id = ansi_opname (op);\n \n-\treturn id;\n+\tlocation_t loc = make_location (start_loc, start_loc, end_loc);\n+\n+\treturn cp_expr (id, loc);\n       }\n \n     case CPP_PLUS:\n@@ -13620,7 +13830,7 @@ cp_parser_operator (cp_parser* parser)\n       id = error_mark_node;\n     }\n \n-  return id;\n+  return cp_expr (id, start_loc);\n }\n \n /* Parse a template-declaration.\n@@ -14530,6 +14740,18 @@ cp_parser_template_id (cp_parser *parser,\n \n       /* Reset the contents of the START_OF_ID token.  */\n       token->type = CPP_TEMPLATE_ID;\n+\n+      /* Update the location to be of the form:\n+\t   template-name < template-argument-list [opt] >\n+\t   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\t with caret == start at the start of the template-name,\n+\t ranging until the closing '>'.  */\n+      location_t finish_loc\n+\t= get_finish (cp_lexer_previous_token (parser->lexer)->location);\n+      location_t combined_loc\n+\t= make_location (token->location, token->location, finish_loc);\n+      token->location = combined_loc;\n+\n       /* Retrieve any deferred checks.  Do not pop this access checks yet\n \t so the memory will not be reclaimed during token replacing below.  */\n       token->u.tree_check_value = ggc_cleared_alloc<struct tree_check> ();\n@@ -20316,10 +20538,10 @@ cp_parser_initializer (cp_parser* parser, bool* is_direct_init,\n \n    Otherwise, calls cp_parser_braced_list.  */\n \n-static tree\n+static cp_expr\n cp_parser_initializer_clause (cp_parser* parser, bool* non_constant_p)\n {\n-  tree initializer;\n+  cp_expr initializer;\n \n   /* Assume the expression is constant.  */\n   *non_constant_p = false;\n@@ -20352,10 +20574,11 @@ cp_parser_initializer_clause (cp_parser* parser, bool* non_constant_p)\n    trailing `,' was provided.  NON_CONSTANT_P is as for\n    cp_parser_initializer.  */     \n \n-static tree\n+static cp_expr\n cp_parser_braced_list (cp_parser* parser, bool* non_constant_p)\n {\n   tree initializer;\n+  location_t start_loc = cp_lexer_peek_token (parser->lexer)->location;\n \n   /* Consume the `{' token.  */\n   cp_lexer_consume_token (parser->lexer);\n@@ -20374,9 +20597,18 @@ cp_parser_braced_list (cp_parser* parser, bool* non_constant_p)\n   else\n     *non_constant_p = false;\n   /* Now, there should be a trailing `}'.  */\n+  location_t finish_loc = cp_lexer_peek_token (parser->lexer)->location;\n   cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n   TREE_TYPE (initializer) = init_list_type_node;\n-  return initializer;\n+\n+  cp_expr result (initializer);\n+  /* Build a location of the form:\n+       { ... }\n+       ^~~~~~~\n+     with caret==start at the open brace, finish at the close brace.  */\n+  location_t combined_loc = make_location (start_loc, start_loc, finish_loc);\n+  result.set_location (combined_loc);\n+  return result;\n }\n \n /* Consume tokens up to, and including, the next non-nested closing `]'.\n@@ -24077,7 +24309,7 @@ cp_parser_nested_requirement (cp_parser *parser)\n    TREE_LIST of candidates if name-lookup results in an ambiguity, and\n    NULL_TREE otherwise.  */\n \n-static tree\n+static cp_expr\n cp_parser_lookup_name (cp_parser *parser, tree name,\n \t\t       enum tag_types tag_type,\n \t\t       bool is_template,\n@@ -24319,7 +24551,7 @@ cp_parser_lookup_name (cp_parser *parser, tree name,\n \n   maybe_record_typedef_use (decl);\n \n-  return decl;\n+  return cp_expr (decl, name_location);\n }\n \n /* Like cp_parser_lookup_name, but for use in the typical case where\n@@ -25323,7 +25555,7 @@ cp_parser_single_declaration (cp_parser* parser,\n \n /* Parse a cast-expression that is not the operand of a unary \"&\".  */\n \n-static tree\n+static cp_expr\n cp_parser_simple_cast_expression (cp_parser *parser)\n {\n   return cp_parser_cast_expression (parser, /*address_p=*/false,\n@@ -25333,14 +25565,16 @@ cp_parser_simple_cast_expression (cp_parser *parser)\n /* Parse a functional cast to TYPE.  Returns an expression\n    representing the cast.  */\n \n-static tree\n+static cp_expr\n cp_parser_functional_cast (cp_parser* parser, tree type)\n {\n   vec<tree, va_gc> *vec;\n   tree expression_list;\n-  tree cast;\n+  cp_expr cast;\n   bool nonconst_p;\n \n+  location_t start_loc = input_location;\n+\n   if (!type)\n     type = error_mark_node;\n \n@@ -25352,9 +25586,21 @@ cp_parser_functional_cast (cp_parser* parser, tree type)\n       CONSTRUCTOR_IS_DIRECT_INIT (expression_list) = 1;\n       if (TREE_CODE (type) == TYPE_DECL)\n \ttype = TREE_TYPE (type);\n-      return finish_compound_literal (type, expression_list,\n+\n+      cast = finish_compound_literal (type, expression_list,\n \t\t\t\t      tf_warning_or_error);\n-    }\n+      /* Create a location of the form:\n+\t    type_name{i, f}\n+\t    ^~~~~~~~~~~~~~~\n+\t with caret == start at the start of the type name,\n+\t finishing at the closing brace.  */\n+      location_t finish_loc\n+\t= get_finish (cp_lexer_previous_token (parser->lexer)->location);\n+      location_t combined_loc = make_location (start_loc, start_loc,\n+\t\t\t\t\t       finish_loc);\n+      cast.set_location (combined_loc);\n+      return cast;\n+   }\n \n \n   vec = cp_parser_parenthesized_expression_list (parser, non_attr,\n@@ -25380,6 +25626,16 @@ cp_parser_functional_cast (cp_parser* parser, tree type)\n       && cp_parser_non_integral_constant_expression (parser,\n \t\t\t\t\t\t     NIC_CONSTRUCTOR))\n     return error_mark_node;\n+\n+  /* Create a location of the form:\n+       float(i)\n+       ^~~~~~~~\n+     with caret == start at the start of the type name,\n+     finishing at the closing paren.  */\n+  location_t finish_loc\n+    = get_finish (cp_lexer_previous_token (parser->lexer)->location);\n+  location_t combined_loc = make_location (start_loc, start_loc, finish_loc);\n+  cast.set_location (combined_loc);\n   return cast;\n }\n \n@@ -27133,7 +27389,7 @@ cp_parser_allow_gnu_extensions_p (cp_parser* parser)\n \n   Returns a tree representation of the expression.  */\n \n-static tree\n+static cp_expr\n cp_parser_objc_expression (cp_parser* parser)\n {\n   /* Try to figure out what kind of declaration is present.  */\n@@ -27185,12 +27441,23 @@ cp_parser_objc_message_expression (cp_parser* parser)\n {\n   tree receiver, messageargs;\n \n+  location_t start_loc = cp_lexer_peek_token (parser->lexer)->location;\n   cp_lexer_consume_token (parser->lexer);  /* Eat '['.  */\n   receiver = cp_parser_objc_message_receiver (parser);\n   messageargs = cp_parser_objc_message_args (parser);\n+  location_t end_loc = cp_lexer_peek_token (parser->lexer)->location;\n   cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n \n-  return objc_build_message_expr (receiver, messageargs);\n+  tree result = objc_build_message_expr (receiver, messageargs);\n+\n+  /* Construct a location e.g.\n+       [self func1:5]\n+       ^~~~~~~~~~~~~~\n+     ranging from the '[' to the ']', with the caret at the start.  */\n+  location_t combined_loc = make_location (start_loc, start_loc, end_loc);\n+  protected_set_expr_location (result, combined_loc);\n+\n+  return result;\n }\n \n /* Parse an objc-message-receiver.\n@@ -27307,11 +27574,12 @@ cp_parser_objc_message_args (cp_parser* parser)\n \n    Returns an encoded representation of the type argument.  */\n \n-static tree\n+static cp_expr\n cp_parser_objc_encode_expression (cp_parser* parser)\n {\n   tree type;\n   cp_token *token;\n+  location_t start_loc = cp_lexer_peek_token (parser->lexer)->location;\n \n   cp_lexer_consume_token (parser->lexer);  /* Eat '@encode'.  */\n   cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n@@ -27339,7 +27607,16 @@ cp_parser_objc_encode_expression (cp_parser* parser)\n       return value;\n     }\n \n-  return objc_build_encode_expr (type);\n+\n+  /* Build a location of the form:\n+       @encode(int)\n+       ^~~~~~~~~~~~\n+     with caret==start at the @ token, finishing at the close paren.  */\n+  location_t combined_loc\n+    = make_location (start_loc, start_loc,\n+                     cp_lexer_previous_token (parser->lexer)->location);\n+\n+  return cp_expr (objc_build_encode_expr (type), combined_loc);\n }\n \n /* Parse an Objective-C @defs expression.  */\n@@ -27368,13 +27645,23 @@ static tree\n cp_parser_objc_protocol_expression (cp_parser* parser)\n {\n   tree proto;\n+  location_t start_loc = cp_lexer_peek_token (parser->lexer)->location;\n \n   cp_lexer_consume_token (parser->lexer);  /* Eat '@protocol'.  */\n   cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n   proto = cp_parser_identifier (parser);\n   cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \n-  return objc_build_protocol_expr (proto);\n+  /* Build a location of the form:\n+       @protocol(prot)\n+       ^~~~~~~~~~~~~~~\n+     with caret==start at the @ token, finishing at the close paren.  */\n+  location_t combined_loc\n+    = make_location (start_loc, start_loc,\n+                     cp_lexer_previous_token (parser->lexer)->location);\n+  tree result = objc_build_protocol_expr (proto);\n+  protected_set_expr_location (result, combined_loc);\n+  return result;\n }\n \n /* Parse an Objective-C selector expression.\n@@ -27450,7 +27737,18 @@ cp_parser_objc_selector_expression (cp_parser* parser)\n  finish_selector:\n   cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n \n-  return objc_build_selector_expr (loc, sel_seq);\n+\n+  /* Build a location of the form:\n+       @selector(func)\n+       ^~~~~~~~~~~~~~~\n+     with caret==start at the @ token, finishing at the close paren.  */\n+  location_t combined_loc\n+    = make_location (loc, loc,\n+                     cp_lexer_previous_token (parser->lexer)->location);\n+  tree result = objc_build_selector_expr (combined_loc, sel_seq);\n+  /* TODO: objc_build_selector_expr doesn't always honor the location.  */\n+  protected_set_expr_location (result, combined_loc);\n+  return result;\n }\n \n /* Parse a list of identifiers.\n@@ -32560,7 +32858,8 @@ cp_parser_omp_for_cond (cp_parser *parser, tree decl, enum tree_code code)\n \t  || CLASS_TYPE_P (TREE_TYPE (decl))))\n     return cond;\n \n-  return build_x_binary_op (input_location, TREE_CODE (cond),\n+  return build_x_binary_op (EXPR_LOC_OR_LOC (cond, input_location),\n+\t\t\t    TREE_CODE (cond),\n \t\t\t    TREE_OPERAND (cond, 0), ERROR_MARK,\n \t\t\t    TREE_OPERAND (cond, 1), ERROR_MARK,\n \t\t\t    /*overload=*/NULL, tf_warning_or_error);\n@@ -36287,16 +36586,18 @@ cp_parser_transaction_expression (cp_parser *parser, enum rid keyword)\n   cp_token *token;\n   tree expr, noex;\n   bool noex_expr;\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n \n   gcc_assert (keyword == RID_TRANSACTION_ATOMIC\n       || keyword == RID_TRANSACTION_RELAXED);\n \n   if (!flag_tm)\n-    error (keyword == RID_TRANSACTION_RELAXED\n-\t   ? G_(\"%<__transaction_relaxed%> without transactional memory \"\n-\t\t\"support enabled\")\n-\t   : G_(\"%<__transaction_atomic%> without transactional memory \"\n-\t\t\"support enabled\"));\n+    error_at (loc,\n+\t      keyword == RID_TRANSACTION_RELAXED\n+\t      ? G_(\"%<__transaction_relaxed%> without transactional memory \"\n+\t\t  \"support enabled\")\n+\t      : G_(\"%<__transaction_atomic%> without transactional memory \"\n+\t\t   \"support enabled\"));\n \n   token = cp_parser_require_keyword (parser, keyword,\n       (keyword == RID_TRANSACTION_ATOMIC ? RT_TRANSACTION_ATOMIC"}, {"sha": "82f7d3a2c5ed8ea5ca10319604ade1025d81b106", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -1672,8 +1672,8 @@ force_paren_expr (tree expr)\n \n /* Finish a parenthesized expression EXPR.  */\n \n-tree\n-finish_parenthesized_expr (tree expr)\n+cp_expr\n+finish_parenthesized_expr (cp_expr expr)\n {\n   if (EXPR_P (expr))\n     /* This inhibits warnings in c_common_truthvalue_conversion.  */\n@@ -1688,7 +1688,7 @@ finish_parenthesized_expr (tree expr)\n   if (TREE_CODE (expr) == STRING_CST)\n     PAREN_STRING_LITERAL_P (expr) = 1;\n \n-  expr = force_paren_expr (expr);\n+  expr = cp_expr (force_paren_expr (expr), expr.get_location ());\n \n   return expr;\n }\n@@ -2164,8 +2164,8 @@ empty_expr_stmt_p (tree expr_stmt)\n    the function (or functions) to call; ARGS are the arguments to the\n    call.  Returns the functions to be considered by overload resolution.  */\n \n-tree\n-perform_koenig_lookup (tree fn, vec<tree, va_gc> *args,\n+cp_expr\n+perform_koenig_lookup (cp_expr fn, vec<tree, va_gc> *args,\n \t\t       tsubst_flags_t complain)\n {\n   tree identifier = NULL_TREE;\n@@ -2460,10 +2460,23 @@ finish_call_expr (tree fn, vec<tree, va_gc> **args, bool disallow_virtual,\n    is indicated by CODE, which should be POSTINCREMENT_EXPR or\n    POSTDECREMENT_EXPR.)  */\n \n-tree\n-finish_increment_expr (tree expr, enum tree_code code)\n-{\n-  return build_x_unary_op (input_location, code, expr, tf_warning_or_error);\n+cp_expr\n+finish_increment_expr (cp_expr expr, enum tree_code code)\n+{\n+  /* input_location holds the location of the trailing operator token.\n+     Build a location of the form:\n+       expr++\n+       ~~~~^~\n+     with the caret at the operator token, ranging from the start\n+     of EXPR to the end of the operator token.  */\n+  location_t combined_loc = make_location (input_location,\n+\t\t\t\t\t   expr.get_start (),\n+\t\t\t\t\t   get_finish (input_location));\n+  cp_expr result = build_x_unary_op (combined_loc, code, expr,\n+\t\t\t\t     tf_warning_or_error);\n+  /* TODO: build_x_unary_op doesn't honor the location, so set it here.  */\n+  result.set_location (combined_loc);\n+  return result;\n }\n \n /* Finish a use of `this'.  Returns an expression for `this'.  */\n@@ -2557,11 +2570,21 @@ finish_pseudo_destructor_expr (tree object, tree scope, tree destructor,\n \n /* Finish an expression of the form CODE EXPR.  */\n \n-tree\n-finish_unary_op_expr (location_t loc, enum tree_code code, tree expr,\n+cp_expr\n+finish_unary_op_expr (location_t op_loc, enum tree_code code, cp_expr expr,\n \t\t      tsubst_flags_t complain)\n {\n-  tree result = build_x_unary_op (loc, code, expr, complain);\n+  /* Build a location of the form:\n+       ++expr\n+       ^~~~~~\n+     with the caret at the operator token, ranging from the start\n+     of the operator token to the end of EXPR.  */\n+  location_t combined_loc = make_location (op_loc,\n+\t\t\t\t\t   op_loc, expr.get_finish ());\n+  cp_expr result = build_x_unary_op (combined_loc, code, expr, complain);\n+  /* TODO: build_x_unary_op doesn't always honor the location.  */\n+  result.set_location (combined_loc);\n+\n   tree result_ovl, expr_ovl;\n \n   if (!(complain & tf_warning))\n@@ -2581,7 +2604,7 @@ finish_unary_op_expr (location_t loc, enum tree_code code, tree expr,\n     result_ovl = cp_fully_fold (result_ovl);\n \n   if (CONSTANT_CLASS_P (result_ovl) && TREE_OVERFLOW_P (result_ovl))\n-    overflow_warning (input_location, result_ovl);\n+    overflow_warning (combined_loc, result_ovl);\n \n   return result;\n }\n@@ -3324,7 +3347,7 @@ process_outer_var_ref (tree decl, tsubst_flags_t complain)\n    the use of \"this\" explicit.\n \n    Upon return, *IDK will be filled in appropriately.  */\n-tree\n+cp_expr\n finish_id_expression (tree id_expression,\n \t\t      tree decl,\n \t\t      tree scope,\n@@ -3669,7 +3692,7 @@ finish_id_expression (tree id_expression,\n \t}\n     }\n \n-  return decl;\n+  return cp_expr (decl, location);\n }\n \n /* Implement the __typeof keyword: Return the type of EXPR, suitable for"}, {"sha": "0a1e446c95cc001323194ef2be9709fe7f09ed36", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -2261,7 +2261,7 @@ lookup_anon_field (tree t, tree type)\n    functions indicated by MEMBER.  */\n \n tree\n-build_class_member_access_expr (tree object, tree member,\n+build_class_member_access_expr (cp_expr object, tree member,\n \t\t\t\ttree access_path, bool preserve_reference,\n \t\t\t\ttsubst_flags_t complain)\n {\n@@ -2291,10 +2291,10 @@ build_class_member_access_expr (tree object, tree member,\n \t      && CLASS_TYPE_P (TREE_TYPE (object_type)))\n \t    error (\"request for member %qD in %qE, which is of pointer \"\n \t\t   \"type %qT (maybe you meant to use %<->%> ?)\",\n-\t\t   member, object, object_type);\n+\t\t   member, object.get_value (), object_type);\n \t  else\n \t    error (\"request for member %qD in %qE, which is of non-class \"\n-\t\t   \"type %qT\", member, object, object_type);\n+\t\t   \"type %qT\", member, object.get_value (), object_type);\n \t}\n       return error_mark_node;\n     }\n@@ -2624,7 +2624,7 @@ check_template_keyword (tree decl)\n    be a template via the use of the \"A::template B\" syntax.  */\n \n tree\n-finish_class_member_access_expr (tree object, tree name, bool template_p,\n+finish_class_member_access_expr (cp_expr object, tree name, bool template_p,\n \t\t\t\t tsubst_flags_t complain)\n {\n   tree expr;\n@@ -2658,7 +2658,7 @@ finish_class_member_access_expr (tree object, tree name, bool template_p,\n \t      && TYPE_P (TREE_OPERAND (name, 0))\n \t      && dependent_type_p (TREE_OPERAND (name, 0))))\n \treturn build_min_nt_loc (UNKNOWN_LOCATION, COMPONENT_REF,\n-\t\t\t\t object, name, NULL_TREE);\n+\t\t\t\t object.get_value (), name, NULL_TREE);\n       object = build_non_dependent_expr (object);\n     }\n   else if (c_dialect_objc ()\n@@ -2681,10 +2681,10 @@ finish_class_member_access_expr (tree object, tree name, bool template_p,\n \t      && CLASS_TYPE_P (TREE_TYPE (object_type)))\n \t    error (\"request for member %qD in %qE, which is of pointer \"\n \t\t   \"type %qT (maybe you meant to use %<->%> ?)\",\n-\t\t   name, object, object_type);\n+\t\t   name, object.get_value (), object_type);\n \t  else\n \t    error (\"request for member %qD in %qE, which is of non-class \"\n-\t\t   \"type %qT\", name, object, object_type);\n+\t\t   \"type %qT\", name, object.get_value (), object_type);\n \t}\n       return error_mark_node;\n     }\n@@ -5111,7 +5111,7 @@ cp_build_binary_op (location_t location,\n \tinstrument_expr = ubsan_instrument_shift (location, code, op0, op1);\n     }\n \n-  result = build2 (resultcode, build_type, op0, op1);\n+  result = build2_loc (location, resultcode, build_type, op0, op1);\n   if (final_type != 0)\n     result = cp_convert (final_type, result, complain);\n \n@@ -5269,7 +5269,7 @@ pointer_diff (tree op0, tree op1, tree ptrtype, tsubst_flags_t complain)\n    and XARG is the operand.  */\n \n tree\n-build_x_unary_op (location_t loc, enum tree_code code, tree xarg,\n+build_x_unary_op (location_t loc, enum tree_code code, cp_expr xarg,\n \t\t  tsubst_flags_t complain)\n {\n   tree orig_expr = xarg;\n@@ -5279,7 +5279,7 @@ build_x_unary_op (location_t loc, enum tree_code code, tree xarg,\n   if (processing_template_decl)\n     {\n       if (type_dependent_expression_p (xarg))\n-\treturn build_min_nt_loc (loc, code, xarg, NULL_TREE);\n+\treturn build_min_nt_loc (loc, code, xarg.get_value (), NULL_TREE);\n \n       xarg = build_non_dependent_expr (xarg);\n     }\n@@ -5314,7 +5314,7 @@ build_x_unary_op (location_t loc, enum tree_code code, tree xarg,\n \t\terror (DECL_CONSTRUCTOR_P (fn)\n \t\t       ? G_(\"taking address of constructor %qE\")\n \t\t       : G_(\"taking address of destructor %qE\"),\n-\t\t       xarg);\n+\t\t       xarg.get_value ());\n \t      return error_mark_node;\n \t    }\n \t}\n@@ -5330,7 +5330,7 @@ build_x_unary_op (location_t loc, enum tree_code code, tree xarg,\n \t      if (complain & tf_error)\n \t\t{\n \t\t  error (\"invalid use of %qE to form a \"\n-\t\t\t \"pointer-to-member-function\", xarg);\n+\t\t\t \"pointer-to-member-function\", xarg.get_value ());\n \t\t  if (TREE_CODE (xarg) != OFFSET_REF)\n \t\t    inform (input_location, \"  a qualified-id is required\");\n \t\t}\n@@ -5341,7 +5341,7 @@ build_x_unary_op (location_t loc, enum tree_code code, tree xarg,\n \t      if (complain & tf_error)\n \t\terror (\"parentheses around %qE cannot be used to form a\"\n \t\t       \" pointer-to-member-function\",\n-\t\t       xarg);\n+\t\t       xarg.get_value ());\n \t      else\n \t\treturn error_mark_node;\n \t      PTRMEM_OK_P (xarg) = 1;\n@@ -5438,7 +5438,7 @@ build_nop (tree type, tree expr)\n {\n   if (type == error_mark_node || error_operand_p (expr))\n     return expr;\n-  return build1 (NOP_EXPR, type, expr);\n+  return build1_loc (EXPR_LOCATION (expr), NOP_EXPR, type, expr);\n }\n \n /* Take the address of ARG, whatever that means under C++ semantics.\n@@ -7270,6 +7270,18 @@ build_c_cast (location_t /*loc*/, tree type, tree expr)\n   return cp_build_c_cast (type, expr, tf_warning_or_error);\n }\n \n+/* Like the \"build_c_cast\" used for c-common, but using cp_expr to\n+   preserve location information even for tree nodes that don't\n+   support it.  */\n+\n+cp_expr\n+build_c_cast (location_t loc, tree type, cp_expr expr)\n+{\n+  cp_expr result = cp_build_c_cast (type, expr, tf_warning_or_error);\n+  result.set_location (loc);\n+  return result;\n+}\n+\n /* Build an expression representing an explicit C-style cast to type\n    TYPE of expression EXPR.  */\n \n@@ -7775,7 +7787,7 @@ cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n   return result;\n }\n \n-tree\n+cp_expr\n build_x_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n \t\t     tree rhs, tsubst_flags_t complain)\n {"}, {"sha": "352c0fa372497d717630cbe262a42f2a2e92e24f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -1,3 +1,27 @@\n+2015-12-04  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* g++.dg/cpp0x/nsdmi-template14.C: Move dg-error directive.\n+\t* g++.dg/gomp/loop-1.C: Update dg-error locations.\n+\t* g++.dg/plugin/diagnostic-test-expressions-1.C: New file, adapted\n+\tfrom gcc.dg/plugin/diagnostic-test-expressions-1.c.\n+\t* g++.dg/plugin/plugin.exp (plugin_test_list): Add the above.\n+\t* g++.dg/template/crash55.C: Update dg-error directives.\n+\t* g++.dg/template/pseudodtor3.C: Update column numbers in dg-error\n+\tdirectives.\n+\t* g++.dg/template/pr64100.C: Update location of dg-error\n+\tdirective.\n+\t* g++.dg/template/ref3.C: Add XFAIL (PR c++/68699).\n+\t* g++.dg/ubsan/pr63956.C: Update dg directives to reflect\n+\timproved location information.\n+\t* g++.dg/warn/pr35635.C (func3): Update location of a\n+\tdg-warning.\n+\t* g++.dg/warn/Wconversion-real-integer2.C: Update location of\n+\tdg-warning; add a dg-message.\n+\t* obj-c++.dg/plugin/diagnostic-test-expressions-1.mm: New file,\n+\tbased on objc.dg/plugin/diagnostic-test-expressions-1.m.\n+\t* obj-c++.dg/plugin/plugin.exp: New file, based on\n+\tobjc.dg/plugin/plugin.exp.\n+\n 2015-12-04  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c/68656"}, {"sha": "47f5b631bf9fd2bacb94066dbb19da66cdfbe3e1", "filename": "gcc/testsuite/g++.dg/cpp0x/nsdmi-template14.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-template14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-template14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fnsdmi-template14.C?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -8,10 +8,10 @@ template<int> struct A // { dg-error \"has been parsed\" }\n \n template<int N> struct B\n {\n-  B* p = new B<N>;\n+  B* p = new B<N>; // { dg-error \"recursive instantiation of non-static data\" }\n };\n \n-B<1> x; // { dg-error \"recursive instantiation of non-static data\" }\n+B<1> x;\n \n struct C\n {"}, {"sha": "de08eb3271d85cc1a848cf172f495ac6774c3db6", "filename": "gcc/testsuite/g++.dg/gomp/loop-1.C", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Floop-1.C?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -86,16 +86,16 @@ f1 (int x)\n     for (j = baz (&i); j < 16; j += 2)\n       ;\n   #pragma omp for collapse(2)\n-  for (i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n-    for (j = 16; j > (i & x); j--)\n+  for (i = 0; i < 16; i++)\n+    for (j = 16; j > (i & x); j--) /* { dg-error \"condition expression refers to iteration variable\" } */\n       ;\n   #pragma omp for collapse(2)\n-  for (i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n-    for (j = 0; j < i; j++)\n+  for (i = 0; i < 16; i++)\n+    for (j = 0; j < i; j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n       ;\n   #pragma omp for collapse(2)\n-  for (i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n-    for (j = 0; j < i + 4; j++)\n+  for (i = 0; i < 16; i++)\n+    for (j = 0; j < i + 4; j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n       ;\n   #pragma omp for collapse(2)\n   for (i = 0; i < j + 4; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n@@ -110,8 +110,8 @@ f1 (int x)\n     for (j = 0; j < 16; j++)\n       ;\n   #pragma omp for collapse(2)\n-  for (i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n-    for (j = 0; j < baz (&i); j++)\n+  for (i = 0; i < 16; i++)\n+    for (j = 0; j < baz (&i); j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n       ;\n   #pragma omp for collapse(2)\n   for (i = 0; i < 16; i += j) /* { dg-error \"increment expression refers to iteration variable\" } */\n@@ -219,20 +219,20 @@ f2 (int x)\n     for (int j = baz (&i); j < 16; j += 2)\n       ;\n   #pragma omp for collapse(2)\n-  for (int i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n-    for (int j = 16; j > (i & x); j--)\n+  for (int i = 0; i < 16; i++)\n+    for (int j = 16; j > (i & x); j--) /* { dg-error \"condition expression refers to iteration variable\" } */\n       ;\n   #pragma omp for collapse(2)\n-  for (int i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n-    for (int j = 0; j < i; j++)\n+  for (int i = 0; i < 16; i++)\n+    for (int j = 0; j < i; j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n       ;\n   #pragma omp for collapse(2)\n-  for (int i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n-    for (int j = 0; j < i + 4; j++)\n+  for (int i = 0; i < 16; i++)\n+    for (int j = 0; j < i + 4; j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n       ;\n   #pragma omp for collapse(2)\n-  for (int i = 0; i < 16; i++) /* { dg-error \"condition expression refers to iteration variable\" } */\n-    for (int j = 0; j < baz (&i); j++)\n+  for (int i = 0; i < 16; i++)\n+    for (int j = 0; j < baz (&i); j++) /* { dg-error \"condition expression refers to iteration variable\" } */\n       ;\n   #pragma omp for collapse(2)\n   for (int i = 0; i < 16; i++) /* { dg-error \"increment expression refers to iteration variable\" } */"}, {"sha": "4d3b07cbc5fe6f697c6f1cabf2330584191e2c8b", "filename": "gcc/testsuite/g++.dg/plugin/diagnostic-test-expressions-1.C", "status": "added", "additions": 784, "deletions": 0, "changes": 784, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdiagnostic-test-expressions-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdiagnostic-test-expressions-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fdiagnostic-test-expressions-1.C?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -0,0 +1,784 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdiagnostics-show-caret -fpermissive\" } */\n+\n+/* This is a collection of unittests to verify that we're correctly\n+   capturing the source code ranges of various kinds of expression.\n+\n+   It uses the various \"diagnostic_test_*_expression_range_plugin\"\n+   plugins which handles \"__emit_expression_range\" by generating a warning\n+   at the given source range of the input argument.  Each of the\n+   different plugins do this at a different phase of the internal\n+   representation (tree, gimple, etc), so we can verify that the\n+   source code range information is valid at each phase.\n+\n+   We want to accept an expression of any type.  We use variadic arguments.\n+   For compatibility with the C tests we have a dummy argument, since\n+   C requires at least one argument before the ellipsis.  */\n+\n+extern void __emit_expression_range (int dummy, ...);\n+\n+int global;\n+\n+void test_parentheses (int a, int b)\n+{\n+  __emit_expression_range (0, (a + b) ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, (a + b) );\n+                               ~~~^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, (a + b) * (a - b) ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, (a + b) * (a - b) );\n+                               ~~~~~~~~^~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, !(a && b) ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, !(a && b) );\n+                               ^~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Postfix expressions.  ************************************************/\n+\n+void test_array_reference (int *arr)\n+{\n+  __emit_expression_range (0, arr[100] ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, arr[100] );\n+                               ~~~~~~~^\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+int test_function_call (int p, int q, int r)\n+{\n+  __emit_expression_range (0, test_function_call (p, q, r) ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, test_function_call (p, q, r) );\n+                               ~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+  return 0;\n+}\n+\n+struct test_struct\n+{\n+  int field;\n+};\n+\n+int test_structure_references (struct test_struct *ptr)\n+{\n+  struct test_struct local;\n+  local.field = 42;\n+\n+  __emit_expression_range (0, local.field ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, local.field );\n+                               ~~~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, ptr->field ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, ptr->field );\n+                               ~~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+int test_postfix_incdec (int i)\n+{\n+  __emit_expression_range (0, i++ ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, i++ );\n+                               ~^~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, i-- ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, i-- );\n+                               ~^~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Unary operators.  ****************************************************/\n+\n+int test_prefix_incdec (int i)\n+{\n+  __emit_expression_range (0, ++i ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, ++i );\n+                               ^~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, --i ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, --i );\n+                               ^~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_address_operator (void)\n+{\n+  __emit_expression_range (0, &global ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, &global );\n+                               ^~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_indirection (int *ptr)\n+{\n+  __emit_expression_range (0, *ptr ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, *ptr );\n+                               ^~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_unary_minus (int i)\n+{\n+  __emit_expression_range (0, -i ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, -i );\n+                               ^~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_ones_complement (int i)\n+{\n+  __emit_expression_range (0, ~i ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, ~i );\n+                               ^~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_logical_negation (int flag)\n+{\n+  __emit_expression_range (0, !flag ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, !flag );\n+                               ^~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Casts.  ****************************************************/\n+\n+void test_cast (void *ptr)\n+{\n+  __emit_expression_range (0, (int *)ptr ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, (int *)ptr );\n+                               ^~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, *(int *)0xdeadbeef ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, *(int *)0xdeadbeef );\n+                               ^~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+}\n+\n+/* Binary operators.  *******************************************/\n+\n+void test_multiplicative_operators (int lhs, int rhs)\n+{\n+  __emit_expression_range (0, lhs * rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs * rhs );\n+                               ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs / rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs / rhs );\n+                               ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs % rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs % rhs );\n+                               ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_additive_operators (int lhs, int rhs)\n+{\n+  __emit_expression_range (0, lhs + rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs + rhs );\n+                               ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs - rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs - rhs );\n+                               ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_shift_operators (int lhs, int rhs)\n+{\n+  __emit_expression_range (0, lhs << rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs << rhs );\n+                               ~~~~^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs >> rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs >> rhs );\n+                               ~~~~^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_relational_operators (int lhs, int rhs)\n+{\n+  __emit_expression_range (0, lhs < rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs < rhs );\n+                               ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs > rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs > rhs );\n+                               ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs <= rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs <= rhs );\n+                               ~~~~^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs >= rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs >= rhs );\n+                               ~~~~^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_equality_operators (int lhs, int rhs)\n+{\n+  __emit_expression_range (0, lhs == rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs == rhs );\n+                               ~~~~^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs != rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs != rhs );\n+                               ~~~~^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_bitwise_binary_operators (int lhs, int rhs)\n+{\n+  __emit_expression_range (0, lhs & rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs & rhs );\n+                               ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs ^ rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs ^ rhs );\n+                               ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs | rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs | rhs );\n+                               ~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_logical_operators (int lhs, int rhs)\n+{\n+  __emit_expression_range (0, lhs && rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs && rhs );\n+                               ~~~~^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, lhs || rhs ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, lhs || rhs );\n+                               ~~~~^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Conditional operator.  *******************************************/\n+\n+void test_conditional_operators (int flag, int on_true, int on_false)\n+{\n+  __emit_expression_range (0, flag ? on_true : on_false ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, flag ? on_true : on_false );\n+                               ~~~~~^~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Assignment expressions.  *******************************************/\n+\n+void test_assignment_expressions (int dest, int other)\n+{\n+  __emit_expression_range (0, dest = other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest = other );\n+                               ~~~~~^~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, dest *= other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest *= other );\n+                               ~~~~~^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, dest /= other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest /= other );\n+                               ~~~~~^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, dest %= other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest %= other );\n+                               ~~~~~^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, dest += other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest += other );\n+                               ~~~~~^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, dest -= other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest -= other );\n+                               ~~~~~^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, dest <<= other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest <<= other );\n+                               ~~~~~^~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, dest >>= other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest >>= other );\n+                               ~~~~~^~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, dest &= other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest &= other );\n+                               ~~~~~^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, dest ^= other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest ^= other );\n+                               ~~~~~^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, dest |= other ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dest |= other );\n+                               ~~~~~^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Comma operator.  *******************************************/\n+\n+void test_comma_operator (int a, int b)\n+{\n+  __emit_expression_range (0, (a++, a + b) ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, (a++, a + b) );\n+                               ~~~~^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Literals.  **************************************************/\n+\n+/* We can't test the ranges of literals directly, since the underlying\n+   tree nodes don't retain a location.  However, we can test that they\n+   have ranges during parsing by building compound expressions using\n+   them, and verifying the ranges of the compound expressions.  */\n+\n+void test_string_literals (int i)\n+{\n+  __emit_expression_range (0, \"foo\"[i] ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, \"foo\"[i] );\n+                               ~~~~~~~^\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, &\"foo\" \"bar\" ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, &\"foo\" \"bar\" );\n+                               ^~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_numeric_literals (int i)\n+{\n+  __emit_expression_range (0, 42 + i ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, 42 + i );\n+                               ~~~^~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, i + 42 ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, i + 42 );\n+                               ~~^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  /* Verify locations of negative literals (via folding of\n+     unary negation).  */\n+\n+  __emit_expression_range (0, -42 + i ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, -42 + i );\n+                               ~~~~^~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, i + -42 ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, i + -42 );\n+                               ~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, i ? 0 : -1 ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, i ? 0 : -1 );\n+                               ~~^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Braced initializers.  ***************************************/\n+\n+/* We can't test the ranges of these directly, since the underlying\n+   tree nodes don't retain a location.  However, we can test that they\n+   have ranges during parsing by building compound expressions using\n+   them, and verifying the ranges of the compound expressions.  */\n+\n+#define vector(elcount, type)  \\\n+__attribute__((vector_size((elcount)*sizeof(type)))) type\n+\n+void test_braced_init (void)\n+{\n+  /* Verify start of range.  */\n+  __emit_expression_range (0, (vector(4, float)){2., 2., 2., 2.} + 1); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, (vector(4, float)){2., 2., 2., 2.} + 1);\n+                                                 ~~~~~~~~~~~~~~~~~^~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  /* Verify end of range.  */\n+  __emit_expression_range (0, 1 + (vector(4, float)){2., 2., 2., 2.}); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, 1 + (vector(4, float)){2., 2., 2., 2.});\n+                               ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Statement expressions.  ***************************************/\n+\n+void test_statement_expression (void)\n+{\n+  __emit_expression_range (0, ({ static int a; a; }) + 1);  /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, ({ static int a; a; }) + 1);\n+                               ~~~~~~~~~~~~~~~~~~~~~~~^~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, 1 + ({ static int a; a; }) );  /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, 1 + ({ static int a; a; }) );\n+                               ~~^~~~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Other expressions.  */\n+\n+void test_address_of_label (void)\n+{\n+ label:\n+  __emit_expression_range (0, &&label );  /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, &&label );\n+                               ^~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_transaction_expressions (void)\n+{\n+  int i;\n+  i = __transaction_atomic (42); /* { dg-error \"without transactional memory support enabled\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   i = __transaction_atomic (42);\n+       ^~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+  i = __transaction_relaxed (42); /* { dg-error \"without transactional memory support enabled\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   i = __transaction_relaxed (42);\n+       ^~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_keywords (int i)\n+{\n+  __emit_expression_range (0, __FUNCTION__[i] );  /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, __FUNCTION__[i] );\n+                               ~~~~~~~~~~~~~~^\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, __PRETTY_FUNCTION__[i] );  /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, __PRETTY_FUNCTION__[i] );\n+                               ~~~~~~~~~~~~~~~~~~~~~^\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, __func__[i] );  /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, __func__[i] );\n+                               ~~~~~~~~~~^\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_builtin_va_arg (__builtin_va_list v)\n+{\n+  __emit_expression_range (0,  __builtin_va_arg (v, int) );  /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0,  __builtin_va_arg (v, int) );\n+                                ~~~~~~~~~~~~~~~~~~~~~^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0,  __builtin_va_arg (v, int) + 1 );  /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0,  __builtin_va_arg (v, int) + 1 );\n+                                ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+struct s { int i; float f; };\n+\n+void test_builtin_offsetof (int i)\n+{\n+  __emit_expression_range (0,  i + __builtin_offsetof (struct s, f) );  /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0,  i + __builtin_offsetof (struct s, f) );\n+                                ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0,  __builtin_offsetof (struct s, f) + i );  /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0,  __builtin_offsetof (struct s, f) + i );\n+                                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* Examples of non-trivial expressions.  ****************************/\n+\n+extern double sqrt (double x);\n+\n+void test_quadratic (double a, double b, double c)\n+{\n+  __emit_expression_range (0, b * b - 4 * a * c ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, b * b - 4 * a * c );\n+                               ~~~~~~^~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0,\n+     (-b + sqrt (b * b - 4 * a * c))\n+     / (2 * a)); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+      (-b + sqrt (b * b - 4 * a * c))\n+      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+      / (2 * a));\n+      ^~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+}\n+\n+int bar (int);\n+void test_combinations (int a)\n+{\n+  __emit_expression_range (0, bar (a) > a ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, bar (a) > a );\n+                               ~~~~~~~~^~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+/* C++-specific expresssions. ****************************************/\n+\n+void test_cp_literal_keywords (int a, int b)\n+{\n+  this; /* { dg-error \"invalid use of 'this' in non-member function\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   this;\n+   ^~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+}\n+\n+class base {\n+ public:\n+  base ();\n+  base (int i);\n+  virtual ~base ();\n+  int pub ();\n+private:\n+  int priv ();\n+};\n+class derived : public base { ~derived (); };\n+\n+void test_cp_casts (base *ptr)\n+{\n+  __emit_expression_range (0, dynamic_cast <derived *> (ptr)); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, dynamic_cast <derived *> (ptr));\n+                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, static_cast <derived *> (ptr)); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, static_cast <derived *> (ptr));\n+                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, reinterpret_cast <int *> (ptr)); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, reinterpret_cast <int *> (ptr));\n+                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, const_cast <base *> (ptr)); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, const_cast <base *> (ptr));\n+                               ^~~~~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_functional_casts (int i, float f)\n+{\n+  __emit_expression_range (0, float(i)); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, float(i));\n+                               ^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, int(f)); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, int(f));\n+                               ^~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, s{i, f}); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, s{i, f});\n+                               ^~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+template <typename TYPENAME>\n+class example_template\n+{\n+public:\n+  example_template (TYPENAME v);\n+};\n+\n+void test_template_id (void)\n+{\n+  example_template <int>; /* { dg-warning \"declaration does not declare anything\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   example_template <int>;\n+   ^~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_new (void)\n+{\n+  __emit_expression_range (0, ::new base); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, ::new base);\n+                               ^~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, new base); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, new base);\n+                               ^~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, new (base)); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, new (base));\n+                               ^~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, new base (42)); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, new base (42));\n+                               ^~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  __emit_expression_range (0, new (base) (42)); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, new (base) (42));\n+                               ^~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  /* TODO: placement new.  */\n+\n+  __emit_expression_range (0, new example_template<int> (42)); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, new example_template<int> (42));\n+                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_methods ()\n+{\n+  __emit_expression_range (0, ((base *)1)->pub () ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, ((base *)1)->pub () );\n+                               ~~~~~~~~~~~~~~~~~^~\n+   { dg-end-multiline-output \"\" } */\n+\n+  ((base *)1)->priv (); // { dg-error \" is private \" }\n+/* { dg-begin-multiline-output \"\" }\n+   ((base *)1)->priv ();\n+                      ^\n+   { dg-end-multiline-output \"\" }\n+   { dg-begin-multiline-output \"\" }\n+   int priv ();\n+       ^~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+\n+class tests\n+{\n+public:\n+  void test_method_calls ();\n+  int some_method () const;\n+};\n+\n+void\n+tests::test_method_calls ()\n+{\n+  __emit_expression_range (0, this->some_method () ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range (0, this->some_method () );\n+                               ~~~~~~~~~~~~~~~~~~^~\n+   { dg-end-multiline-output \"\" } */\n+}"}, {"sha": "3be89a0f4e82a34c4d9501262b81030f7ef293ea", "filename": "gcc/testsuite/g++.dg/plugin/plugin.exp", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fplugin.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fplugin.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fplugin.exp?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -62,7 +62,10 @@ set plugin_test_list [list \\\n     { dumb_plugin.c dumb-plugin-test-1.C } \\\n     { header_plugin.c header-plugin-test.C } \\\n     { decl_plugin.c decl-plugin-test.C } \\\n-    { def_plugin.c def-plugin-test.C } ]\n+    { def_plugin.c def-plugin-test.C } \\\n+    { ../../gcc.dg/plugin/diagnostic_plugin_test_tree_expression_range.c \\\n+\t  diagnostic-test-expressions-1.C } \\\n+]\n \n foreach plugin_test $plugin_test_list {\n     # Replace each source file with its full-path name"}, {"sha": "b9b29f7fc8d7dff597a2120b1c723bba553e8648", "filename": "gcc/testsuite/g++.dg/template/crash55.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash55.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash55.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash55.C?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -1,6 +1,7 @@\n //PR c++/27668\n \n template<typename class T, T = T()> // { dg-error \"nested-name-specifier|two or more|valid type\" }\n+// { dg-error \"cast\" \"\" { target c++98_only } 3 }\n struct A {};\n \n-template<int> void foo(A<int>);\t// { dg-error \"cast|argument\" \"\" { target c++98_only } }\n+template<int> void foo(A<int>);\t// { dg-error \"template argument 2\" \"\" { target c++98_only } }"}, {"sha": "051800cbca0b2ad75edf3995cc3b4e91bc07190d", "filename": "gcc/testsuite/g++.dg/template/pr64100.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr64100.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr64100.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr64100.C?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -1,8 +1,8 @@\n // { dg-do compile { target c++11 } }\n \n template<typename> struct foo // { dg-message \"note\" }\n-{ // { dg-error \"incomplete type\" }\n-    static_assert(noexcept(((foo *)1)->~foo()), \"\");\n+{\n+    static_assert(noexcept(((foo *)1)->~foo()), \"\"); // { dg-error \"incomplete type\" }\n }; \n \n template class foo<int>;"}, {"sha": "8700bb95252cb500360a36d02e1aa785886200c7", "filename": "gcc/testsuite/g++.dg/template/pseudodtor3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpseudodtor3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpseudodtor3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpseudodtor3.C?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -11,15 +11,15 @@ struct A\n template <typename T> struct B\n {\n   T &foo ();\n-  B () { foo.~T (); }\t// { dg-error \"10:invalid use of member\" }\n+  B () { foo.~T (); }\t// { dg-error \"15:invalid use of member\" }\n };\n \n B<int> b;\n \n template <typename T, typename S> struct C\n {\n   T t;\n-  C () { t.~S (); }\t// { dg-error \"10:is not of type\" }\n+  C () { t.~S (); }\t// { dg-error \"13:is not of type\" }\n };\n \n C<int, long int> c;"}, {"sha": "91e3c93a35d9e275ec68061f153b75d40719242b", "filename": "gcc/testsuite/g++.dg/template/ref3.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fref3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fref3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fref3.C?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -5,7 +5,8 @@ template<const int&> struct A {};\n template<typename T> struct B\n {\n   A<(T)0> b; // { dg-error \"constant|not a valid\" }\n-  A<T(0)> a; // { dg-error \"constant|not a valid\" }\n+  A<T(0)> a; // { dg-error \"constant|not a valid\" \"\" { xfail c++98_only } }\n+                                                       // PR c++/68699\n };\n \n B<const int&> b;"}, {"sha": "b2656313b33e3695e2c088a0fa1e0f409c3885c0", "filename": "gcc/testsuite/g++.dg/ubsan/pr63956.C", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fpr63956.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fpr63956.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fpr63956.C?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -10,15 +10,18 @@ fn1 (int a, int b)\n {\n   if (b != 2)\n     a <<= b;\n+    // { dg-error \"5 << -2.. is negative\" \"\" { target *-*-* } 12 }\n+    // { dg-error \"is >= than the precision of the left operand\" \"\" { target *-*-* } 12 }\n+    // { dg-error \"-2 << 4.. is negative\" \"\" { target *-*-* } 12 }\n   return a;\n }\n \n constexpr int i1 = fn1 (5, 3);\n-constexpr int i2 = fn1 (5, -2); // { dg-error \"is negative\" }\n-constexpr int i3 = fn1 (5, sizeof (int) * __CHAR_BIT__); // { dg-error \"is >= than the precision of the left operand\" }\n-constexpr int i4 = fn1 (5, 256); // { dg-error \"is >= than the precision of the left operand\" }\n+constexpr int i2 = fn1 (5, -2); // { dg-message \"in constexpr expansion\" }\n+constexpr int i3 = fn1 (5, sizeof (int) * __CHAR_BIT__); // { dg-message \"in constexpr expansion\" }\n+constexpr int i4 = fn1 (5, 256); // { dg-message \"in constexpr expansion\" }\n constexpr int i5 = fn1 (5, 2);\n-constexpr int i6 = fn1 (-2, 4); // { dg-error \"is negative\" }\n+constexpr int i6 = fn1 (-2, 4); // { dg-message \"in constexpr expansion\" }\n constexpr int i7 = fn1 (0, 2);\n \n SA (i1 == 40);\n@@ -30,13 +33,16 @@ fn2 (int a, int b)\n {\n   if (b != 2)\n     a >>= b;\n+    // { dg-error \"4 >> -1.. is negative\" \"\" { target *-*-* } 35 }\n+    // { dg-error \"is >= than the precision of the left operand\" \"\" { target *-*-* } 35 }\n+\n   return a;\n }\n \n constexpr int j1 = fn2 (4, 1);\n-constexpr int j2 = fn2 (4, -1); // { dg-error \"is negative\" }\n-constexpr int j3 = fn2 (10, sizeof (int) * __CHAR_BIT__); // { dg-error \"is >= than the precision of the left operand\" }\n-constexpr int j4 = fn2 (1, 256); // { dg-error \"is >= than the precision of the left operand\" }\n+constexpr int j2 = fn2 (4, -1); // { dg-message \"in constexpr expansion\" }\n+constexpr int j3 = fn2 (10, sizeof (int) * __CHAR_BIT__); // { dg-message \"in constexpr expansion\" }\n+constexpr int j4 = fn2 (1, 256); // { dg-message \"in constexpr expansion\" }\n constexpr int j5 = fn2 (5, 2);\n constexpr int j6 = fn2 (-2, 4);\n constexpr int j7 = fn2 (0, 4);\n@@ -49,12 +55,12 @@ constexpr int\n fn3 (int a, int b)\n {\n   if (b != 2)\n-    a = a / b;\n+    a = a / b; // { dg-error \"..7 / 0.. is not a constant expression\" }\n   return a;\n }\n \n constexpr int k1 = fn3 (8, 4);\n-constexpr int k2 = fn3 (7, 0); // { dg-error \"is not a constant expression\" }\n+constexpr int k2 = fn3 (7, 0); // { dg-message \"in constexpr expansion\" }\n constexpr int k3 = fn3 (INT_MIN, -1); // { dg-error \"overflow in constant expression\" }\n \n SA (k1 == 2);\n@@ -63,12 +69,12 @@ constexpr float\n fn4 (float a, float b)\n {\n   if (b != 2.0)\n-    a = a / b;\n+    a = a / b; // { dg-error \"is not a constant expression\" }\n   return a;\n }\n \n constexpr float l1 = fn4 (5.0, 3.0);\n-constexpr float l2 = fn4 (7.0, 0.0); // { dg-error \"is not a constant expression\" }\n+constexpr float l2 = fn4 (7.0, 0.0); // { dg-message \"in constexpr expansion\" }\n \n constexpr int\n fn5 (const int *a, int b)"}, {"sha": "7e39d5fa747e262eb969b6309094b2d9b4eabb5a", "filename": "gcc/testsuite/g++.dg/warn/Wconversion-real-integer2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWconversion-real-integer2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWconversion-real-integer2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWconversion-real-integer2.C?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -23,11 +23,11 @@\n //\n // That is more useful.\n \n-#define INT_MAX __INT_MAX__ \n+#define INT_MAX __INT_MAX__ // { dg-warning \"17: conversion to .float. alters .int. constant value\" }\n \n float  vfloat;\n \n void h (void)\n {\n-    vfloat = INT_MAX; // { dg-warning \"conversion to .float. alters .int. constant value\" }\n+    vfloat = INT_MAX; // { dg-message \"14: in expansion of macro .INT_MAX.\" }\n }"}, {"sha": "19345c51162ed5f43b6a127477b4d266ed9e4873", "filename": "gcc/testsuite/g++.dg/warn/pr35635.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr35635.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr35635.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fpr35635.C?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -62,9 +62,9 @@ void func3()\n   /* At least one branch of ? does not fit in the destination, thus\n      warn.  */\n   uchar_x = bar != 0 ? 2.1 : 10; /* { dg-warning \"conversion\" } */\n-  uchar_x = bar != 0  /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n-    ? (unsigned char) 1024 \n-    : -1; \n+  uchar_x = bar != 0\n+    ? (unsigned char) 1024 /* { dg-warning \"negative integer implicitly converted to unsigned type\" } */\n+    : -1;\n }\n \n void func4()"}, {"sha": "609fe3d0f93fe2405e36f7c5a83182a60b885e10", "filename": "gcc/testsuite/obj-c++.dg/plugin/diagnostic-test-expressions-1.mm", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fplugin%2Fdiagnostic-test-expressions-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fplugin%2Fdiagnostic-test-expressions-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fplugin%2Fdiagnostic-test-expressions-1.mm?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -0,0 +1,94 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdiagnostics-show-caret\" } */\n+\n+/* This file is similar to diagnostic-test-expressions-1.c\n+   (see the notes in that file); this file adds test\n+   coverage for various Objective C constructs. */\n+\n+extern void __emit_expression_range (int dummy, ...);\n+\n+@protocol prot\n+@end\n+\n+@interface tests <prot>\n+- (int) func0;\n+- (int) func1:(int)i;\n++ (int) func2;\n+- (void) test_sending_messages;\n++ (void) test_class_dot_name;\n+- (void) test_at_selector;\n+- (void) test_at_protocol;\n+- (void) test_at_encode:(int)i;\n+@end\n+\n+@implementation tests\n+- (int) func0\n+{\n+  return 42;\n+}\n+- (int) func1:(int)i\n+{\n+  return i * i;\n+}\n++ (int) func2\n+{\n+  return 0;\n+}\n+- (void) test_sending_messages\n+{\n+  __emit_expression_range ( 0, [self func0] ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range ( 0, [self func0] );\n+                                ^~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+  __emit_expression_range ( 0, [self func1:5] ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range ( 0, [self func1:5] );\n+                                ^~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n++ (void) test_class_dot_name\n+{\n+  __emit_expression_range ( 0, tests.func2 ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range ( 0, tests.func2 );\n+                                ~~~~~~^~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+- (void) test_at_selector\n+{\n+  __emit_expression_range ( 0, @selector(func0) ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range ( 0, @selector(func0) );\n+                                ^~~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+- (void) test_at_protocol\n+{\n+  __emit_expression_range ( 0, @protocol(prot) ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range ( 0, @protocol(prot) );\n+                                ^~~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+- (void) test_at_encode:(int)i\n+{\n+  /* @encode() generates a STRING_CST which doesn't retain a location\n+     after parsing, so we need to access it via compound expressions\n+     that can't be folded away.  */\n+\n+  /* Verify start.  */\n+  __emit_expression_range ( 0, @encode(int) + i ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range ( 0, @encode(int) + i );\n+                                ~~~~~~~~~~~~~^~~\n+   { dg-end-multiline-output \"\" } */\n+\n+  /* Verify finish.  */\n+  __emit_expression_range ( 0, i + @encode(int) ); /* { dg-warning \"range\" } */\n+/* { dg-begin-multiline-output \"\" }\n+   __emit_expression_range ( 0, i + @encode(int) );\n+                                ~~^~~~~~~~~~~~~~\n+   { dg-end-multiline-output \"\" } */\n+}\n+@end"}, {"sha": "d0d400bb602bf6a3d1c207da6e93e8c6765303d1", "filename": "gcc/testsuite/obj-c++.dg/plugin/plugin.exp", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fplugin%2Fplugin.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fplugin%2Fplugin.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fplugin%2Fplugin.exp?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -0,0 +1,90 @@\n+#   Copyright (C) 2009-2015 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Test the functionality of the GCC plugin support\n+\n+load_lib target-supports.exp\n+load_lib obj-c++-dg.exp\n+\n+global TESTING_IN_BUILD_TREE\n+global ENABLE_PLUGIN\n+\n+# The plugin testcases currently only work when the build tree is available.\n+# Also check whether the host supports plugins.\n+if { ![info exists TESTING_IN_BUILD_TREE] || ![info exists ENABLE_PLUGIN] } {\n+    return\n+}\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \" -ansi -pedantic-errors\"\n+}\n+\n+# The procedures in plugin-support.exp need these parameters.\n+set default_flags $DEFAULT_CFLAGS\n+\n+if $tracelevel then {\n+    strace $tracelevel\n+}\n+\n+# Load support procs.\n+load_lib plugin-support.exp\n+\n+# These tests don't run runtest_file_p consistently if it\n+# doesn't return the same values, so disable parallelization\n+# of this *.exp file.  The first parallel runtest to reach\n+# this will run all the tests serially.\n+if ![gcc_parallel_test_run_p plugin] {\n+    return\n+}\n+gcc_parallel_test_enable 0\n+\n+# Specify the plugin source file and the associated test files in a list.\n+# plugin_test_list={ {plugin1 test1 test2 ...} {plugin2 test1 ...} ... }\n+set plugin_test_list [list \\\n+    { ../../gcc.dg/plugin/diagnostic_plugin_test_tree_expression_range.c \\\n+\t  diagnostic-test-expressions-1.mm } \\\n+]\n+\n+foreach plugin_test $plugin_test_list {\n+    # Replace each source file with its full-path name\n+    for {set i 0} {$i < [llength $plugin_test]} {incr i} {\n+\tset basename [lindex $plugin_test $i]\n+\tset plugin_test [lreplace $plugin_test $i $i $srcdir/$subdir/$basename]\n+    }\n+    set plugin_src [lindex $plugin_test 0]\n+    # If we're only testing specific files and this isn't one of them, skip it.\n+    if ![runtest_file_p $runtests $plugin_src] then {\n+        continue\n+    }\n+    set plugin_input_tests [lreplace $plugin_test 0 0]\n+    plugin-test-execute $plugin_src $plugin_input_tests\n+}\n+\n+# run the plugindir tests\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/plugindir*.mm]] \\\n+\t\"\" $DEFAULT_CFLAGS\n+\n+# All done.\n+dg-finish\n+\n+gcc_parallel_test_enable 1"}, {"sha": "c8b3ab8531cc19788352623a5c2b6b08c7dcfe17", "filename": "gcc/tree.c", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -13905,7 +13905,7 @@ nonnull_arg_p (const_tree arg)\n /* Given location LOC, strip away any packed range information\n    or ad-hoc information.  */\n \n-static location_t\n+location_t\n get_pure_location (location_t loc)\n {\n   if (IS_ADHOC_LOC (loc))\n@@ -13935,27 +13935,42 @@ set_block (location_t loc, tree block)\n   return COMBINE_LOCATION_DATA (line_table, pure_loc, src_range, block);\n }\n \n-void\n+location_t\n set_source_range (tree expr, location_t start, location_t finish)\n {\n   source_range src_range;\n   src_range.m_start = start;\n   src_range.m_finish = finish;\n-  set_source_range (expr, src_range);\n+  return set_source_range (expr, src_range);\n }\n \n-void\n+location_t\n set_source_range (tree expr, source_range src_range)\n {\n   if (!EXPR_P (expr))\n-    return;\n+    return UNKNOWN_LOCATION;\n \n   location_t pure_loc = get_pure_location (EXPR_LOCATION (expr));\n   location_t adhoc = COMBINE_LOCATION_DATA (line_table,\n \t\t\t\t\t    pure_loc,\n \t\t\t\t\t    src_range,\n \t\t\t\t\t    NULL);\n   SET_EXPR_LOCATION (expr, adhoc);\n+  return adhoc;\n+}\n+\n+location_t\n+make_location (location_t caret, location_t start, location_t finish)\n+{\n+  location_t pure_loc = get_pure_location (caret);\n+  source_range src_range;\n+  src_range.m_start = start;\n+  src_range.m_finish = finish;\n+  location_t combined_loc = COMBINE_LOCATION_DATA (line_table,\n+\t\t\t\t\t\t   pure_loc,\n+\t\t\t\t\t\t   src_range,\n+\t\t\t\t\t\t   NULL);\n+  return combined_loc;\n }\n \n /* Return the name of combined function FN, for debugging purposes.  */"}, {"sha": "aef825d092f450100369dc40681b65faad9a7b11", "filename": "gcc/tree.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e87eed2a9cbc1fe429ad550337e819cddcdc9c5a/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e87eed2a9cbc1fe429ad550337e819cddcdc9c5a", "patch": "@@ -5369,6 +5369,16 @@ type_with_alias_set_p (const_tree t)\n   return false;\n }\n \n+extern location_t get_pure_location (location_t loc);\n+\n+/* Get the endpoint of any range encoded within location LOC.  */\n+\n+static inline location_t\n+get_finish (location_t loc)\n+{\n+  return get_range_from_loc (line_table, loc).m_finish;\n+}\n+\n extern location_t set_block (location_t loc, tree block);\n \n extern void gt_ggc_mx (tree &);\n@@ -5377,10 +5387,10 @@ extern void gt_pch_nx (tree &, gt_pointer_operator, void *);\n \n extern bool nonnull_arg_p (const_tree);\n \n-extern void\n+extern location_t\n set_source_range (tree expr, location_t start, location_t finish);\n \n-extern void\n+extern location_t\n set_source_range (tree expr, source_range src_range);\n \n static inline source_range\n@@ -5390,6 +5400,9 @@ get_decl_source_range (tree decl)\n   return get_range_from_loc (line_table, loc);\n }\n \n+extern location_t\n+make_location (location_t caret, location_t start, location_t finish);\n+\n /* Return true if it makes sense to promote/demote from_type to to_type. */\n inline bool\n desired_pro_or_demotion_p (const_tree to_type, const_tree from_type)"}]}