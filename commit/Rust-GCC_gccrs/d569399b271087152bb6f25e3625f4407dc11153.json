{"sha": "d569399b271087152bb6f25e3625f4407dc11153", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDU2OTM5OWIyNzEwODcxNTJiYjZmMjVlMzYyNWY0NDA3ZGMxMTE1Mw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mitchell@dumbledore.codesourcery.com", "date": "2000-01-11T02:43:00Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-01-11T02:43:00Z"}, "message": "cp-tree.h (expand_direct_vtbls_init): Remove declaration.\n\n\t* cp-tree.h (expand_direct_vtbls_init): Remove declaration.\n\t(initialize_vtbl_ptrs): New function.\n\t(expand_indirect_vtbls_init): Change prototype.\n\t(convert_pointer_to_vbase): Declare.\n\t* init.c (expand_direct_vtbls_init): Remove.\n\t(dfs_initialize_vtbl_ptrs): New function.\n\t(initialize_vtbl_ptrs): Likewise.\n\t(emit_base_init): Use initialize_vtbl_ptrs.\n\t* search.c (convert_pointer_to_vbase): Make it global.\n\t(expand_indirect_vtbls_init): Remove vtable initialization code.\n\t* semantics.c (setup_vtbl_ptr): Use initialize_vtbl_ptrs.\n\nFrom-SVN: r31314", "tree": {"sha": "867f0f8d0dfaa509d6c40bfd9e0272e2b590fe34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/867f0f8d0dfaa509d6c40bfd9e0272e2b590fe34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d569399b271087152bb6f25e3625f4407dc11153", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d569399b271087152bb6f25e3625f4407dc11153", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d569399b271087152bb6f25e3625f4407dc11153", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d569399b271087152bb6f25e3625f4407dc11153/comments", "author": null, "committer": null, "parents": [{"sha": "4a314e0c77f06189ef52888d417faa7e5759c116", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a314e0c77f06189ef52888d417faa7e5759c116", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a314e0c77f06189ef52888d417faa7e5759c116"}], "stats": {"total": 155, "additions": 68, "deletions": 87}, "files": [{"sha": "5d38a576847870e45a30d8ec3316948aada091f2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d569399b271087152bb6f25e3625f4407dc11153/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d569399b271087152bb6f25e3625f4407dc11153/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d569399b271087152bb6f25e3625f4407dc11153", "patch": "@@ -1,5 +1,17 @@\n 2000-01-10  Mark Mitchell  <mitchell@dumbledore.codesourcery.com>\n \n+\t* cp-tree.h (expand_direct_vtbls_init): Remove declaration.\n+\t(initialize_vtbl_ptrs): New function.\n+\t(expand_indirect_vtbls_init): Change prototype.\n+\t(convert_pointer_to_vbase): Declare.\n+\t* init.c (expand_direct_vtbls_init): Remove.\n+\t(dfs_initialize_vtbl_ptrs): New function.\n+\t(initialize_vtbl_ptrs): Likewise.\n+\t(emit_base_init): Use initialize_vtbl_ptrs.\n+\t* search.c (convert_pointer_to_vbase): Make it global.\n+\t(expand_indirect_vtbls_init): Remove vtable initialization code.\n+\t* semantics.c (setup_vtbl_ptr): Use initialize_vtbl_ptrs.\n+\t\n \t* class.c (dfs_finish_vtbls): New function.\n \t(finish_vtbls): Use it.\n \t(dump_class_hierarchy): New function."}, {"sha": "beaa4168338d33eb19c26abe09124bef18e265a9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d569399b271087152bb6f25e3625f4407dc11153/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d569399b271087152bb6f25e3625f4407dc11153/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d569399b271087152bb6f25e3625f4407dc11153", "patch": "@@ -3734,7 +3734,6 @@ extern tree do_friend\t\t\t\tPROTO((tree, tree, tree, tree, tree, enum overload_flag\n \n /* in init.c */\n extern void init_init_processing\t\tPROTO((void));\n-extern void expand_direct_vtbls_init\t\tPROTO((tree, tree, int, int, tree));\n extern tree emit_base_init\t\t\tPROTO((tree));\n extern void check_base_init\t\t\tPROTO((tree));\n extern void expand_member_init\t\t\tPROTO((tree, tree, tree));\n@@ -3757,6 +3756,7 @@ extern tree build_vec_delete\t\t\tPROTO((tree, tree, tree, int));\n extern tree create_temporary_var                PROTO((tree));\n extern void begin_init_stmts                    PROTO((tree *, tree *));\n extern tree finish_init_stmts                   PROTO((tree, tree));\n+extern void initialize_vtbl_ptrs                PROTO((tree, tree));\n \n /* in input.c */\n \n@@ -3926,7 +3926,7 @@ extern tree lookup_nested_tag\t\t\tPROTO((tree, tree));\n extern tree get_matching_virtual\t\tPROTO((tree, tree, int));\n extern void get_pure_virtuals\t\t        PROTO((tree));\n extern tree init_vbase_pointers\t\t\tPROTO((tree, tree));\n-extern void expand_indirect_vtbls_init\t\tPROTO((tree, tree, tree));\n+extern void expand_indirect_vtbls_init\t\tPROTO((tree, tree));\n extern void clear_search_slots\t\t\tPROTO((tree));\n extern void get_vbase_types\t\t\tPROTO((tree));\n extern void maybe_suppress_debug_info\t\tPROTO((tree));\n@@ -3955,6 +3955,7 @@ extern tree dfs_skip_nonprimary_vbases_markedp  PROTO((tree, void *));\n extern tree dfs_unmarked_real_bases_queue_p     PROTO((tree, void *));\n extern tree dfs_marked_real_bases_queue_p       PROTO((tree, void *));\n extern void mark_primary_bases                  PROTO((tree));\n+extern tree convert_pointer_to_vbase            PROTO((tree, tree));\n \n /* in semantics.c */\n extern void finish_expr_stmt                    PROTO((tree));"}, {"sha": "ed2a3d70a1649861568ea468e5880efbb4268e35", "filename": "gcc/cp/init.c", "status": "modified", "additions": 45, "deletions": 54, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d569399b271087152bb6f25e3625f4407dc11153/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d569399b271087152bb6f25e3625f4407dc11153/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=d569399b271087152bb6f25e3625f4407dc11153", "patch": "@@ -1,5 +1,5 @@\n /* Handle initialization things in C++.\n-   Copyright (C) 1987, 89, 92-98, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 89, 92-98, 1999, 2000 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n This file is part of GNU CC.\n@@ -48,6 +48,7 @@ static tree initializing_context PROTO((tree));\n static tree build_java_class_ref PROTO((tree));\n static void expand_cleanup_for_base PROTO((tree, tree));\n static tree get_temp_regvar PROTO((tree, tree));\n+static tree dfs_initialize_vtbl_ptrs PROTO((tree, void *));\n \n /* Set up local variable for this file.  MUST BE CALLED AFTER\n    INIT_DECL_PROCESSING.  */\n@@ -77,59 +78,55 @@ void init_init_processing ()\n   ggc_add_tree_root (&BI_header_size, 1);\n }\n \n-/* Subroutine of emit_base_init.  For BINFO, initialize all the\n-   virtual function table pointers, except those that come from\n-   virtual base classes.  Initialize binfo's vtable pointer, if\n-   INIT_SELF is true.  CAN_ELIDE is true when we know that all virtual\n-   function table pointers in all bases have been initialized already,\n-   probably because their constructors have just be run.  ADDR is the\n-   pointer to the object whos vtables we are going to initialize.\n+/* Called from initialize_vtbl_ptrs via dfs_walk.  */\n \n-   REAL_BINFO is usually the same as BINFO, except when addr is not of\n-   pointer to the type of the real derived type that we want to\n-   initialize for.  This is the case when addr is a pointer to a sub\n-   object of a complete object, and we only want to do part of the\n-   complete object's initialization of vtable pointers.  This is done\n-   for all virtual table pointers in virtual base classes.  REAL_BINFO\n-   is used to find the BINFO_VTABLE that we initialize with.  BINFO is\n-   used for conversions of addr to subobjects.\n+static tree\n+dfs_initialize_vtbl_ptrs (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  if (!BINFO_PRIMARY_MARKED_P (binfo) \n+      && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo)))\n+    {\n+      tree base_ptr = TREE_VALUE ((tree) data);\n \n-   BINFO_TYPE (real_binfo) must be BINFO_TYPE (binfo).\n+      if (TREE_VIA_VIRTUAL (binfo))\n+\tbase_ptr = convert_pointer_to_vbase (BINFO_TYPE (binfo),\n+\t\t\t\t\t     base_ptr);\n+      else\n+\tbase_ptr \n+\t  = build_vbase_path (PLUS_EXPR, \n+\t\t\t      build_pointer_type (BINFO_TYPE (binfo)),\n+\t\t\t      base_ptr,\n+\t\t\t      binfo,\n+\t\t\t      /*nonnull=*/1);\n+\n+      expand_virtual_init (binfo, base_ptr);\n+    }\n \n-   Relies upon binfo being inside TYPE_BINFO (TREE_TYPE (TREE_TYPE\n-   (addr))).  */\n+  SET_BINFO_MARKED (binfo);\n+\n+  return NULL_TREE;\n+}\n+\n+/* Initialize all the vtable pointers for the hierarchy dominated by\n+   TYPE. */\n \n void\n-expand_direct_vtbls_init (real_binfo, binfo, init_self, can_elide, addr)\n-     tree real_binfo, binfo, addr;\n-     int init_self, can_elide;\n+initialize_vtbl_ptrs (type, addr)\n+     tree type;\n+     tree addr;\n {\n-  tree real_binfos = BINFO_BASETYPES (real_binfo);\n-  tree binfos = BINFO_BASETYPES (binfo);\n-  int i, n_baselinks = real_binfos ? TREE_VEC_LENGTH (real_binfos) : 0;\n+  tree list = build_tree_list (type, addr);\n \n-  for (i = 0; i < n_baselinks; i++)\n-    {\n-      tree real_base_binfo = TREE_VEC_ELT (real_binfos, i);\n-      tree base_binfo = TREE_VEC_ELT (binfos, i);\n-      int is_not_base_vtable\n-\t= i != CLASSTYPE_VFIELD_PARENT (BINFO_TYPE (real_binfo));\n-      if (! TREE_VIA_VIRTUAL (real_base_binfo))\n-\texpand_direct_vtbls_init (real_base_binfo, base_binfo,\n-\t\t\t\t  is_not_base_vtable, can_elide, addr);\n-    }\n-#if 0\n-  /* Before turning this on, make sure it is correct.  */\n-  if (can_elide && ! BINFO_MODIFIED (binfo))\n-    return;\n-#endif\n-  /* Should we use something besides CLASSTYPE_VFIELDS? */\n-  if (init_self && CLASSTYPE_VFIELDS (BINFO_TYPE (real_binfo)))\n-    {\n-      tree base_ptr = convert_pointer_to_real (binfo, addr);\n-      expand_virtual_init (real_binfo, base_ptr);\n-    }\n+  dfs_walk (TYPE_BINFO (type), dfs_initialize_vtbl_ptrs, \n+\t    dfs_unmarked_real_bases_queue_p, list);\n+  dfs_walk (TYPE_BINFO (type), dfs_unmark,\n+\t    dfs_marked_real_bases_queue_p, type);\n+  if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n+    expand_indirect_vtbls_init (TYPE_BINFO (type), addr);\n }\n+\n \f\n /* 348 - 351 */\n /* Subroutine of emit_base_init.  */\n@@ -547,14 +544,8 @@ emit_base_init (t)\n       rbase_init_list = TREE_CHAIN (rbase_init_list);\n     }\n \n-  /* Initialize all the virtual function table fields that\n-     do come from virtual base classes.  */\n-  if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n-    expand_indirect_vtbls_init (t_binfo, current_class_ref, current_class_ptr);\n-\n-  /* Initialize all the virtual function table fields that\n-     do not come from virtual base classes.  */\n-  expand_direct_vtbls_init (t_binfo, t_binfo, 1, 1, current_class_ptr);\n+  /* Initialize the vtable pointers for the class.  */\n+  initialize_vtbl_ptrs (t, current_class_ptr);\n \n   for (member = TYPE_FIELDS (t); member; member = TREE_CHAIN (member))\n     {"}, {"sha": "335a183fc5b14995c43da8c3856ff5b2fd60b13e", "filename": "gcc/cp/search.c", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d569399b271087152bb6f25e3625f4407dc11153/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d569399b271087152bb6f25e3625f4407dc11153/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=d569399b271087152bb6f25e3625f4407dc11153", "patch": "@@ -77,7 +77,6 @@ static struct search_level *search_stack;\n \n static tree next_baselink PROTO((tree));\n static tree get_vbase_1 PROTO((tree, tree, unsigned int *));\n-static tree convert_pointer_to_vbase PROTO((tree, tree));\n static tree lookup_field_1 PROTO((tree, tree));\n static tree convert_pointer_to_single_level PROTO((tree, tree));\n static int lookup_fnfields_here PROTO((tree, tree));\n@@ -249,7 +248,7 @@ get_vbase (parent, binfo)\n    EXPR is a non-null POINTER_TYPE to RECORD_TYPE.  We also know that\n    the type of what expr points to has a virtual base of type TYPE.  */\n \n-static tree\n+tree\n convert_pointer_to_vbase (type, expr)\n      tree type;\n      tree expr;\n@@ -3004,9 +3003,9 @@ fixup_all_virtual_upcast_offsets (type, decl_ptr)\n    sub-object we are initializing.  */\n \n void\n-expand_indirect_vtbls_init (binfo, true_exp, decl_ptr)\n+expand_indirect_vtbls_init (binfo, decl_ptr)\n      tree binfo;\n-     tree true_exp, decl_ptr;\n+     tree decl_ptr;\n {\n   tree type = BINFO_TYPE (binfo);\n \n@@ -3025,29 +3024,11 @@ expand_indirect_vtbls_init (binfo, true_exp, decl_ptr)\n     {\n       tree vbases = CLASSTYPE_VBASECLASSES (type);\n       struct vbase_info vi;\n-      vi.decl_ptr = (true_exp ? build_unary_op (ADDR_EXPR, true_exp, 0) \n-\t\t     : decl_ptr);\n+      vi.decl_ptr = decl_ptr;\n       vi.vbase_types = vbases;\n \n       dfs_walk (binfo, dfs_find_vbases, unmarked_new_vtablep, &vi);\n-\n-      /* Initialized with vtables of type TYPE.  */\n-      for (; vbases; vbases = TREE_CHAIN (vbases))\n-\t{\n-\t  tree addr;\n-\n-\t  addr = convert_pointer_to_vbase (TREE_TYPE (vbases), vi.decl_ptr);\n-\n-\t  /* Do all vtables from this virtual base.  */\n-\t  /* This assumes that virtual bases can never serve as parent\n-\t     binfos.  (in the CLASSTYPE_VFIELD_PARENT sense)  */\n-\t  expand_direct_vtbls_init (vbases, TYPE_BINFO (BINFO_TYPE (vbases)),\n-\t\t\t\t    1, 0, addr);\n-\t}\n-\n-      fixup_all_virtual_upcast_offsets (type,\n-\t\t\t\t\tvi.decl_ptr);\n-\n+      fixup_all_virtual_upcast_offsets (type, vi.decl_ptr);\n       dfs_walk (binfo, dfs_clear_vbase_slots, marked_new_vtablep, 0);\n     }\n }"}, {"sha": "41928ba21ab1a3241f49beda367705f9e86512bf", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d569399b271087152bb6f25e3625f4407dc11153/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d569399b271087152bb6f25e3625f4407dc11153/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d569399b271087152bb6f25e3625f4407dc11153", "patch": "@@ -3,7 +3,7 @@\n    building RTL.  These routines are used both during actual parsing\n    and during the instantiation of template functions. \n \n-   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n    Written by Mark Mitchell (mmitchell@usa.net) based on code found\n    formerly in parse.y and pt.c.  \n \n@@ -1245,7 +1245,6 @@ setup_vtbl_ptr ()\n   else if (DECL_DESTRUCTOR_P (current_function_decl)\n \t   && !processing_template_decl)\n     {\n-      tree binfo = TYPE_BINFO (current_class_type);\n       tree if_stmt;\n       tree compound_stmt;\n       int saved_cfnd;\n@@ -1279,11 +1278,8 @@ setup_vtbl_ptr ()\n       /* Make all virtual function table pointers in non-virtual base\n \t classes point to CURRENT_CLASS_TYPE's virtual function\n \t tables.  */\n-      expand_direct_vtbls_init (binfo, binfo, 1, 0, current_class_ptr);\n-\n-      if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n-\texpand_indirect_vtbls_init (binfo, current_class_ref, \n-\t\t\t\t    current_class_ptr);\n+      initialize_vtbl_ptrs (current_class_type,\n+\t\t\t    current_class_ptr);\n \n       finish_compound_stmt (/*has_no_scope=*/0, compound_stmt);\n       finish_then_clause (if_stmt);"}]}