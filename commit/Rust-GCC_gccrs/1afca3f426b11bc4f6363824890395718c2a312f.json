{"sha": "1afca3f426b11bc4f6363824890395718c2a312f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFmY2EzZjQyNmIxMWJjNGY2MzYzODI0ODkwMzk1NzE4YzJhMzEyZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2018-10-25T14:33:27Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-10-25T14:33:27Z"}, "message": "ipa-devirt.c (main_odr_variant): Remove.\n\n\n\t* ipa-devirt.c (main_odr_variant): Remove.\n\t(hash_odr_name, types_same_for_odr, types_odr_comparable,\n\todr_name_hasher::equal, odr_subtypes_equivalent_p):\n\tDrop use of main_odr_variant.\n\t(add_type_duplicate): Silence confused warnings on integer types.\n\t(get_odr_type): Always look for main variant.\n\t(register_odr_type): Simplify.\n\nFrom-SVN: r265492", "tree": {"sha": "22c8eee72875106f13d963ae5d46e4d20510f556", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22c8eee72875106f13d963ae5d46e4d20510f556"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1afca3f426b11bc4f6363824890395718c2a312f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1afca3f426b11bc4f6363824890395718c2a312f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1afca3f426b11bc4f6363824890395718c2a312f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1afca3f426b11bc4f6363824890395718c2a312f/comments", "author": null, "committer": null, "parents": [{"sha": "303d8f779266535269e443f2fa65a3170a742ff4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/303d8f779266535269e443f2fa65a3170a742ff4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/303d8f779266535269e443f2fa65a3170a742ff4"}], "stats": {"total": 73, "additions": 27, "deletions": 46}, "files": [{"sha": "f921ceb3f6500be5d709ac3e0748e7e2b6c75168", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1afca3f426b11bc4f6363824890395718c2a312f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1afca3f426b11bc4f6363824890395718c2a312f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1afca3f426b11bc4f6363824890395718c2a312f", "patch": "@@ -1,3 +1,13 @@\n+2018-10-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-devirt.c (main_odr_variant): Remove.\n+\t(hash_odr_name, types_same_for_odr, types_odr_comparable,\n+\todr_name_hasher::equal, odr_subtypes_equivalent_p):\n+\tDrop use of main_odr_variant.\n+\t(add_type_duplicate): Silence confused warnings on integer types.\n+\t(get_odr_type): Always look for main variant.\n+\t(register_odr_type): Simplify.\n+\n 2018-10-25  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vect-data-refs.c (vect_analyze_data_ref_accesses):"}, {"sha": "0c6e76a65fe42da6d887ccc0df518c2784f077db", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 17, "deletions": 46, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1afca3f426b11bc4f6363824890395718c2a312f/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1afca3f426b11bc4f6363824890395718c2a312f/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=1afca3f426b11bc4f6363824890395718c2a312f", "patch": "@@ -292,19 +292,6 @@ struct odr_vtable_hasher:odr_name_hasher\n   static inline bool equal (const odr_type_d *, const tree_node *);\n };\n \n-/* Return type that was declared with T's name so that T is an\n-   qualified variant of it.  */\n-\n-static inline tree\n-main_odr_variant (const_tree t)\n-{\n-  if (TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL)\n-    return TREE_TYPE (TYPE_NAME (t));\n-  /* Unnamed types and non-C++ produced types can be compared by variants.  */\n-  else\n-    return TYPE_MAIN_VARIANT (t);\n-}\n-\n static bool\n can_be_name_hashed_p (tree t)\n {\n@@ -316,7 +303,7 @@ can_be_name_hashed_p (tree t)\n static hashval_t\n hash_odr_name (const_tree t)\n {\n-  gcc_checking_assert (main_odr_variant (t) == t);\n+  gcc_checking_assert (TYPE_MAIN_VARIANT (t) == t);\n \n   /* If not in LTO, all main variants are unique, so we can do\n      pointer hash.  */\n@@ -365,7 +352,7 @@ hash_odr_vtable (const_tree t)\n   gcc_checking_assert (!type_in_anonymous_namespace_p (t));\n   gcc_checking_assert (TREE_CODE (t) == RECORD_TYPE\n \t\t       && TYPE_BINFO (t) && BINFO_VTABLE (TYPE_BINFO (t)));\n-  gcc_checking_assert (main_odr_variant (t) == t);\n+  gcc_checking_assert (TYPE_MAIN_VARIANT (t) == t);\n \n   if (TREE_CODE (v) == POINTER_PLUS_EXPR)\n     {\n@@ -405,8 +392,6 @@ types_same_for_odr (const_tree type1, const_tree type2, bool strict)\n {\n   gcc_checking_assert (TYPE_P (type1) && TYPE_P (type2));\n \n-  type1 = main_odr_variant (type1);\n-  type2 = main_odr_variant (type2);\n   if (!strict)\n     {\n       type1 = TYPE_MAIN_VARIANT (type1);\n@@ -419,8 +404,7 @@ types_same_for_odr (const_tree type1, const_tree type2, bool strict)\n   if (!in_lto_p)\n     return false;\n \n-  /* Check for anonymous namespaces. Those have !TREE_PUBLIC\n-     on the corresponding TYPE_STUB_DECL.  */\n+  /* Anonymous namespace types are never duplicated.  */\n   if ((type_with_linkage_p (type1) && type_in_anonymous_namespace_p (type1))\n       || (type_with_linkage_p (type2) && type_in_anonymous_namespace_p (type2)))\n     return false;\n@@ -494,9 +478,8 @@ bool\n types_odr_comparable (tree t1, tree t2, bool strict)\n {\n   return (!in_lto_p\n-\t  || (strict ? (main_odr_variant (t1) == main_odr_variant (t2)\n-\t\t\t&& main_odr_variant (t1))\n-\t      : TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n+\t  || t1 == t2\n+\t  || (!strict && TYPE_MAIN_VARIANT (t1) == TYPE_MAIN_VARIANT (t2))\n \t  || (odr_type_p (t1) && odr_type_p (t2))\n \t  || (TREE_CODE (t1) == RECORD_TYPE && TREE_CODE (t2) == RECORD_TYPE\n \t      && TYPE_BINFO (t1) && TYPE_BINFO (t2)\n@@ -577,8 +560,8 @@ odr_name_hasher::equal (const odr_type_d *o1, const tree_node *t2)\n {\n   tree t1 = o1->type;\n \n-  gcc_checking_assert (main_odr_variant (t2) == t2);\n-  gcc_checking_assert (main_odr_variant (t1) == t1);\n+  gcc_checking_assert (TYPE_MAIN_VARIANT (t2) == t2);\n+  gcc_checking_assert (TYPE_MAIN_VARIANT (t1) == t1);\n   if (t1 == t2)\n     return true;\n   if (!in_lto_p)\n@@ -602,8 +585,8 @@ odr_vtable_hasher::equal (const odr_type_d *o1, const tree_node *t2)\n {\n   tree t1 = o1->type;\n \n-  gcc_checking_assert (main_odr_variant (t2) == t2);\n-  gcc_checking_assert (main_odr_variant (t1) == t1);\n+  gcc_checking_assert (TYPE_MAIN_VARIANT (t2) == t2);\n+  gcc_checking_assert (TYPE_MAIN_VARIANT (t1) == t1);\n   gcc_checking_assert (in_lto_p);\n   t1 = TYPE_MAIN_VARIANT (t1);\n   t2 = TYPE_MAIN_VARIANT (t2);\n@@ -667,8 +650,6 @@ odr_subtypes_equivalent_p (tree t1, tree t2,\n   /* This can happen in incomplete types that should be handled earlier.  */\n   gcc_assert (t1 && t2);\n \n-  t1 = main_odr_variant (t1);\n-  t2 = main_odr_variant (t2);\n   if (t1 == t2)\n     return true;\n \n@@ -1265,13 +1246,6 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n   /* Check first for the obvious case of pointer identity.  */\n   if (t1 == t2)\n     return true;\n-  if ((type_with_linkage_p (t1) && type_in_anonymous_namespace_p (t1))\n-      != (type_with_linkage_p (t2) && type_in_anonymous_namespace_p (t2)))\n-    {\n-      warn_odr (t1, t2, NULL, NULL, warn, warned,\n-\t        G_(\"one of types is in anonymous namespace while other is not\"));\n-      return false;\n-    }\n   gcc_assert (!type_with_linkage_p (t1) || !type_in_anonymous_namespace_p (t1));\n   gcc_assert (!type_with_linkage_p (t2) || !type_in_anonymous_namespace_p (t2));\n \n@@ -1873,7 +1847,12 @@ add_type_duplicate (odr_type val, tree type)\n      before we can pass them to odr_types_equivalent_p (PR lto/83121).  */\n   if (lto_location_cache::current_cache)\n     lto_location_cache::current_cache->apply_location_cache ();\n-  if (!odr_types_equivalent_p (val->type, type,\n+  /* As a special case we stream mangles names of integer types so we can see\n+     if they are believed to be same even though they have different\n+     representation.  Avoid bogus warning on mismatches in these.  */\n+  if (TREE_CODE (type) != INTEGER_TYPE\n+      && TREE_CODE (val->type) != INTEGER_TYPE\n+      && !odr_types_equivalent_p (val->type, type,\n \t\t\t       !flag_ltrans && !val->odr_violated && !warned,\n \t\t\t       &warned, &visited,\n \t\t\t       DECL_SOURCE_LOCATION (TYPE_NAME (val->type)),\n@@ -1992,7 +1971,7 @@ get_odr_type (tree type, bool insert)\n   bool insert_to_odr_array = false;\n   int base_id = -1;\n \n-  type = main_odr_variant (type);\n+  type = TYPE_MAIN_VARIANT (type);\n \n   gcc_checking_assert (can_be_name_hashed_p (type)\n \t\t       || can_be_vtable_hashed_p (type));\n@@ -2129,15 +2108,7 @@ register_odr_type (tree type)\n       if (in_lto_p)\n         odr_vtable_hash = new odr_vtable_hash_type (23);\n     }\n-  /* Arrange things to be nicer and insert main variants first.\n-     ??? fundamental prerecorded types do not have mangled names; this\n-     makes it possible that non-ODR type is main_odr_variant of ODR type.\n-     Things may get smoother if LTO FE set mangled name of those types same\n-     way as C++ FE does.  */\n-  if (odr_type_p (main_odr_variant (TYPE_MAIN_VARIANT (type)))\n-      && odr_type_p (TYPE_MAIN_VARIANT (type)))\n-    get_odr_type (TYPE_MAIN_VARIANT (type), true);\n-  if (TYPE_MAIN_VARIANT (type) != type && odr_type_p (main_odr_variant (type)))\n+  if (type == TYPE_MAIN_VARIANT (type))\n     get_odr_type (type, true);\n }\n "}]}