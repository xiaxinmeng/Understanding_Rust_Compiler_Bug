{"sha": "800da97743ec985d0de0215afcf6bb44b7cd23c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAwZGE5Nzc0M2VjOTg1ZDBkZTAyMTVhZmNmNmJiNDRiN2NkMjNjOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-20T15:13:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-01-20T15:13:01Z"}, "message": "[multiple changes]\n\n2014-01-20  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat1drv.adb: Minor comment update.\n\n2014-01-20  Tristan Gingold  <gingold@adacore.com>\n\n\t* raise-gcc.c (PERSONALITY_FUNCTION/arm): Remove unused\n\tvariables, comment out unused code.\n\t* a-exexpr-gcc.adb: Move declarations to s-excmac-gcc.ads\n\t* s-excmac-gcc.ads: New file, extracted from a-exexpr-gcc.adb\n\t* s-excmac-arm.ads: New file.\n\n2014-01-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Slice): Remove constant D and variables\n\tDrange and Index_Typ. Remove the circuitry which creates a\n\trange check to compare the index type of the array against the\n\tdiscrete_range.\n\t* sem_res.adb (Resolve_Slice): Add local variable Dexpr. Update\n\tthe circuitry which creates a range check to handle a\n\tdiscrete_range denoted by a subtype indication.\n\n2014-01-20  Pierre-Marie Derodat  <derodat@adacore.com>\n\n\t* sinput.adb, sinput.ads (Sloc_Range): Traverse the tree of original\n\tnodes to get the original sloc range.\n\n2014-01-20  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_prag.adb (Analyze_Pragma): Use Defining_Entity to obtain the\n\tentity of a [library level] package.\n\nFrom-SVN: r206817", "tree": {"sha": "df7366eae3b5b18cdc84769c44cb7da59b48e15a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df7366eae3b5b18cdc84769c44cb7da59b48e15a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/800da97743ec985d0de0215afcf6bb44b7cd23c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/800da97743ec985d0de0215afcf6bb44b7cd23c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/800da97743ec985d0de0215afcf6bb44b7cd23c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/800da97743ec985d0de0215afcf6bb44b7cd23c8/comments", "author": null, "committer": null, "parents": [{"sha": "51b0e05ae4a0c5a4ef37e52f8e1702b02e6d8f72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51b0e05ae4a0c5a4ef37e52f8e1702b02e6d8f72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51b0e05ae4a0c5a4ef37e52f8e1702b02e6d8f72"}], "stats": {"total": 753, "additions": 525, "deletions": 228}, "files": [{"sha": "760a627e9667fe98bf0c69eeebca48f1a8011a81", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=800da97743ec985d0de0215afcf6bb44b7cd23c8", "patch": "@@ -1,3 +1,35 @@\n+2014-01-20  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat1drv.adb: Minor comment update.\n+\n+2014-01-20  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* raise-gcc.c (PERSONALITY_FUNCTION/arm): Remove unused\n+\tvariables, comment out unused code.\n+\t* a-exexpr-gcc.adb: Move declarations to s-excmac-gcc.ads\n+\t* s-excmac-gcc.ads: New file, extracted from a-exexpr-gcc.adb\n+\t* s-excmac-arm.ads: New file.\n+\n+2014-01-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Slice): Remove constant D and variables\n+\tDrange and Index_Typ. Remove the circuitry which creates a\n+\trange check to compare the index type of the array against the\n+\tdiscrete_range.\n+\t* sem_res.adb (Resolve_Slice): Add local variable Dexpr. Update\n+\tthe circuitry which creates a range check to handle a\n+\tdiscrete_range denoted by a subtype indication.\n+\n+2014-01-20  Pierre-Marie Derodat  <derodat@adacore.com>\n+\n+\t* sinput.adb, sinput.ads (Sloc_Range): Traverse the tree of original\n+\tnodes to get the original sloc range.\n+\n+2014-01-20  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma): Use Defining_Entity to obtain the\n+\tentity of a [library level] package.\n+\n 2014-01-20  Tristan Gingold  <gingold@adacore.com>\n \n \t* raise-gcc.c (exception_class_eq): New function."}, {"sha": "fa8e9db87844a4cb96c55a50c16ae2d68a0135c2", "filename": "gcc/ada/a-exexpr-gcc.adb", "status": "modified", "additions": 3, "deletions": 139, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fa-exexpr-gcc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fa-exexpr-gcc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-exexpr-gcc.adb?ref=800da97743ec985d0de0215afcf6bb44b7cd23c8", "patch": "@@ -35,107 +35,13 @@ with Ada.Unchecked_Conversion;\n with Ada.Unchecked_Deallocation;\n \n with System.Storage_Elements;  use System.Storage_Elements;\n+with System.Exceptions.Machine; use System.Exceptions.Machine;\n \n separate (Ada.Exceptions)\n package body Exception_Propagation is\n \n    use Exception_Traces;\n \n-   ------------------------------------------------\n-   -- Entities to interface with the GCC runtime --\n-   ------------------------------------------------\n-\n-   --  These come from \"C++ ABI for Itanium: Exception handling\", which is the\n-   --  reference for GCC.\n-\n-   --  Return codes from GCC runtime functions used to propagate an exception\n-\n-   type Unwind_Reason_Code is\n-     (URC_NO_REASON,\n-      URC_FOREIGN_EXCEPTION_CAUGHT,\n-      URC_PHASE2_ERROR,\n-      URC_PHASE1_ERROR,\n-      URC_NORMAL_STOP,\n-      URC_END_OF_STACK,\n-      URC_HANDLER_FOUND,\n-      URC_INSTALL_CONTEXT,\n-      URC_CONTINUE_UNWIND);\n-\n-   pragma Unreferenced\n-     (URC_NO_REASON,\n-      URC_FOREIGN_EXCEPTION_CAUGHT,\n-      URC_PHASE2_ERROR,\n-      URC_PHASE1_ERROR,\n-      URC_NORMAL_STOP,\n-      URC_END_OF_STACK,\n-      URC_HANDLER_FOUND,\n-      URC_INSTALL_CONTEXT,\n-      URC_CONTINUE_UNWIND);\n-\n-   pragma Convention (C, Unwind_Reason_Code);\n-\n-   --  Phase identifiers\n-\n-   type Unwind_Action is new Integer;\n-   pragma Convention (C, Unwind_Action);\n-\n-   UA_SEARCH_PHASE  : constant Unwind_Action := 1;\n-   UA_CLEANUP_PHASE : constant Unwind_Action := 2;\n-   UA_HANDLER_FRAME : constant Unwind_Action := 4;\n-   UA_FORCE_UNWIND  : constant Unwind_Action := 8;\n-   UA_END_OF_STACK  : constant Unwind_Action := 16;  --  GCC extension\n-\n-   pragma Unreferenced\n-     (UA_SEARCH_PHASE,\n-      UA_CLEANUP_PHASE,\n-      UA_HANDLER_FRAME,\n-      UA_FORCE_UNWIND,\n-      UA_END_OF_STACK);\n-\n-   --  Mandatory common header for any exception object handled by the\n-   --  GCC unwinding runtime.\n-\n-   type Exception_Class is mod 2 ** 64;\n-\n-   GNAT_Exception_Class : constant Exception_Class := 16#474e552d41646100#;\n-   --  \"GNU-Ada\\0\"\n-\n-   type Unwind_Word is mod 2 ** System.Word_Size;\n-   for Unwind_Word'Size use System.Word_Size;\n-   --  Map the corresponding C type used in Unwind_Exception below\n-\n-   type Unwind_Exception is record\n-      Class    : Exception_Class;\n-      Cleanup  : System.Address;\n-      Private1 : Unwind_Word;\n-      Private2 : Unwind_Word;\n-\n-      --  Usual exception structure has only two private fields, but the SEH\n-      --  one has six. To avoid making this file more complex, we use six\n-      --  fields on all platforms, wasting a few bytes on some.\n-\n-      Private3 : Unwind_Word;\n-      Private4 : Unwind_Word;\n-      Private5 : Unwind_Word;\n-      Private6 : Unwind_Word;\n-   end record;\n-   pragma Convention (C, Unwind_Exception);\n-   --  Map the GCC struct used for exception handling\n-\n-   for Unwind_Exception'Alignment use Standard'Maximum_Alignment;\n-   --  The C++ ABI mandates the common exception header to be at least\n-   --  doubleword aligned, and the libGCC implementation actually makes it\n-   --  maximally aligned (see unwind.h). See additional comments on the\n-   --  alignment below.\n-\n-   type GCC_Exception_Access is access all Unwind_Exception;\n-   --  Pointer to a GCC exception. Do not use convention C as on VMS this\n-   --  would imply the use of 32-bits pointers.\n-\n-   procedure Unwind_DeleteException (Excp : not null GCC_Exception_Access);\n-   pragma Import (C, Unwind_DeleteException, \"_Unwind_DeleteException\");\n-   --  Procedure to free any GCC exception\n-\n    Foreign_Exception : aliased System.Standard_Library.Exception_Data;\n    pragma Import (Ada, Foreign_Exception,\n                   \"system__exceptions__foreign_exception\");\n@@ -145,44 +51,6 @@ package body Exception_Propagation is\n    -- GNAT Specific Entities To Deal With The GCC EH Circuitry --\n    --------------------------------------------------------------\n \n-   --  A GNAT exception object to be dealt with by the personality routine\n-   --  called by the GCC unwinding runtime.\n-\n-   type GNAT_GCC_Exception is record\n-      Header : Unwind_Exception;\n-      --  ABI Exception header first\n-\n-      Occurrence : aliased Exception_Occurrence;\n-      --  The Ada occurrence\n-   end record;\n-\n-   pragma Convention (C, GNAT_GCC_Exception);\n-\n-   --  There is a subtle issue with the common header alignment, since the C\n-   --  version is aligned on BIGGEST_ALIGNMENT, the Ada version is aligned on\n-   --  Standard'Maximum_Alignment, and those two values don't quite represent\n-   --  the same concepts and so may be decoupled someday. One typical reason\n-   --  is that BIGGEST_ALIGNMENT may be larger than what the underlying system\n-   --  allocator guarantees, and there are extra costs involved in allocating\n-   --  objects aligned to such factors.\n-\n-   --  To deal with the potential alignment differences between the C and Ada\n-   --  representations, the Ada part of the whole structure is only accessed\n-   --  by the personality routine through the accessors declared below.  Ada\n-   --  specific fields are thus always accessed through consistent layout, and\n-   --  we expect the actual alignment to always be large enough to avoid traps\n-   --  from the C accesses to the common header. Besides, accessors alleviate\n-   --  the need for a C struct whole counterpart, both painful and error-prone\n-   --  to maintain anyway.\n-\n-   type GNAT_GCC_Exception_Access is access all GNAT_GCC_Exception;\n-\n-   function To_GCC_Exception is new\n-     Unchecked_Conversion (System.Address, GCC_Exception_Access);\n-\n-   function To_GNAT_GCC_Exception is new\n-     Unchecked_Conversion (GCC_Exception_Access, GNAT_GCC_Exception_Access);\n-\n    procedure GNAT_GCC_Exception_Cleanup\n      (Reason : Unwind_Reason_Code;\n       Excep  : not null GNAT_GCC_Exception_Access);\n@@ -317,12 +185,8 @@ package body Exception_Propagation is\n       Res : GNAT_GCC_Exception_Access;\n \n    begin\n-      Res :=\n-        new GNAT_GCC_Exception'\n-        (Header     => (Class   => GNAT_Exception_Class,\n-                        Cleanup => GNAT_GCC_Exception_Cleanup'Address,\n-                        others  => 0),\n-         Occurrence => (others => <>));\n+      Res := New_Occurrence;\n+      Res.Header.Cleanup := GNAT_GCC_Exception_Cleanup'Address;\n       Res.Occurrence.Machine_Occurrence := Res.all'Address;\n \n       return Res.Occurrence'Access;"}, {"sha": "f47406054af9d243f1db80270de89284dc944cde", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 2, "deletions": 40, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=800da97743ec985d0de0215afcf6bb44b7cd23c8", "patch": "@@ -9411,11 +9411,8 @@ package body Exp_Ch4 is\n \n       --  Local variables\n \n-      D         : constant Node_Id := Discrete_Range (N);\n-      Pref      : constant Node_Id := Prefix (N);\n-      Pref_Typ  : Entity_Id        := Etype (Pref);\n-      Drange    : Node_Id;\n-      Index_Typ : Entity_Id;\n+      Pref     : constant Node_Id := Prefix (N);\n+      Pref_Typ : Entity_Id        := Etype (Pref);\n \n    --  Start of processing for Expand_N_Slice\n \n@@ -9441,41 +9438,6 @@ package body Exp_Ch4 is\n          Make_Build_In_Place_Call_In_Anonymous_Context (Pref);\n       end if;\n \n-      --  Find the range of the discrete_range. For ranges that do not appear\n-      --  in the slice itself, we make a shallow copy and inherit the source\n-      --  location and the parent field from the discrete_range. This ensures\n-      --  that the range check is inserted relative to the slice and that the\n-      --  runtime exception poins to the proper construct.\n-\n-      if Nkind (D) = N_Range then\n-         Drange := D;\n-\n-      elsif Nkind_In (D, N_Expanded_Name, N_Identifier) then\n-         Drange := New_Copy (Scalar_Range (Entity (D)));\n-         Set_Etype  (Drange, Entity (D));\n-         Set_Parent (Drange, Parent (D));\n-         Set_Sloc   (Drange, Sloc   (D));\n-\n-      else pragma Assert (Nkind (D) = N_Subtype_Indication);\n-         Drange := New_Copy (Range_Expression (Constraint (D)));\n-         Set_Etype  (Drange, Etype  (D));\n-         Set_Parent (Drange, Parent (D));\n-         Set_Sloc   (Drange, Sloc   (D));\n-      end if;\n-\n-      --  Find the type of the array index\n-\n-      if Ekind (Pref_Typ) = E_String_Literal_Subtype then\n-         Index_Typ := Etype (String_Literal_Low_Bound (Pref_Typ));\n-      else\n-         Index_Typ := Etype (First_Index (Pref_Typ));\n-      end if;\n-\n-      --  Add a runtime check to test the compatibility between the array range\n-      --  and the discrete_range.\n-\n-      Apply_Range_Check (Drange, Index_Typ);\n-\n       --  The remaining case to be handled is packed slices. We can leave\n       --  packed slices as they are in the following situations:\n "}, {"sha": "9e808b54a600b2dca7ad91add2fdb5d0eae2ede4", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=800da97743ec985d0de0215afcf6bb44b7cd23c8", "patch": "@@ -637,10 +637,15 @@ ifeq ($(strip $(filter-out powerpc% wrs vxworksae,$(target_cpu) $(target_vendor)\n   s-vxwext.adb<s-vxwext-noints.adb \\\n   s-vxwext.ads<s-vxwext-vthreads.ads \\\n   s-vxwork.ads<s-vxwork-ppc.ads \\\n-  system.ads<system-vxworks-ppc-vthread.ads \\\n   $(ATOMICS_TARGET_PAIRS) \\\n   $(ATOMICS_BUILTINS_TARGET_PAIRS)\n \n+  ifeq ($(strip $(filter-out e500%, $(arch))),)\n+    LIBGNAT_TARGET_PAIRS += system.ads<system-vxworks-e500-vthread.ads\n+  else\n+    LIBGNAT_TARGET_PAIRS += system.ads<system-vxworks-ppc-vthread.ads\n+  endif\n+\n   TOOLS_TARGET_PAIRS=\\\n   mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb \\\n   indepsw.adb<indepsw-gnu.adb\n@@ -947,17 +952,47 @@ ifeq ($(strip $(filter-out arm% coff wrs vx%,$(target_cpu) $(target_vendor) $(ta\n   s-taprop.adb<s-taprop-vxworks.adb \\\n   s-tasinf.ads<s-tasinf-vxworks.ads \\\n   s-taspri.ads<s-taspri-vxworks.ads \\\n-  s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n   s-vxwork.ads<s-vxwork-arm.ads \\\n   g-socthi.ads<g-socthi-vxworks.ads \\\n   g-socthi.adb<g-socthi-vxworks.adb \\\n-  g-stsifd.adb<g-stsifd-sockets.adb \\\n-  system.ads<system-vxworks-arm.ads\n+  g-stsifd.adb<g-stsifd-sockets.adb\n \n   TOOLS_TARGET_PAIRS=\\\n   mlib-tgt-specific.adb<mlib-tgt-specific-vxworks.adb \\\n   indepsw.adb<indepsw-gnu.adb\n \n+  ifeq ($(strip $(filter-out rtp-smp,$(THREAD_KIND))),)\n+    LIBGNAT_TARGET_PAIRS += \\\n+    s-mudido.adb<s-mudido-affinity.adb \\\n+    s-vxwext.ads<s-vxwext-rtp.ads \\\n+    s-vxwext.adb<s-vxwext-rtp-smp.adb \\\n+    s-tpopsp.adb<s-tpopsp-vxworks-tls.adb \\\n+    system.ads<system-vxworks-arm-rtp.ads\n+\n+    EXTRA_LIBGNAT_OBJS+=affinity.o\n+  else\n+    ifeq ($(strip $(filter-out kernel-smp,$(THREAD_KIND))),)\n+      LIBGNAT_TARGET_PAIRS += \\\n+      s-mudido.adb<s-mudido-affinity.adb \\\n+      s-tpopsp.adb<s-tpopsp-vxworks-tls.adb \\\n+      s-vxwext.ads<s-vxwext-kernel.ads \\\n+      s-vxwext.adb<s-vxwext-kernel-smp.adb \\\n+      system.ads<system-vxworks-arm.ads\n+\n+      EXTRA_LIBGNAT_OBJS+=affinity.o\n+    else\n+      LIBGNAT_TARGET_PAIRS += \\\n+      s-tpopsp.adb<s-tpopsp-vxworks.adb \\\n+      system.ads<system-vxworks-arm.ads\n+\n+      ifeq ($(strip $(filter-out kernel,$(THREAD_KIND))),)\n+        LIBGNAT_TARGET_PAIRS += \\\n+        s-vxwext.ads<s-vxwext-kernel.ads \\\n+        s-vxwext.adb<s-vxwext-kernel.adb\n+      endif\n+    endif\n+  endif\n+\n   EXTRA_GNATRTL_NONTASKING_OBJS=i-vxwork.o i-vxwoio.o\n   EXTRA_GNATRTL_TASKING_OBJS=s-vxwork.o s-vxwext.o\n \n@@ -2317,9 +2352,11 @@ ifeq ($(strip $(filter-out arm nucleus%,$(target_cpu) $(target_os))),)\n endif\n \n ifeq ($(EH_MECHANISM),-gcc)\n-  LIBGNAT_TARGET_PAIRS += a-exexpr.adb<a-exexpr-gcc.adb\n+  LIBGNAT_TARGET_PAIRS += \\\n+    a-exexpr.adb<a-exexpr-gcc.adb \\\n+    s-excmac.ads<s-excmac-gcc.ads\n   EXTRA_LIBGNAT_OBJS+=raise-gcc.o\n-  EXTRA_GNATRTL_NONTASKING_OBJS+=g-cppexc.o\n+  EXTRA_GNATRTL_NONTASKING_OBJS+=g-cppexc.o s-excmac.o\n endif\n \n # Use the Ada 2005 version of Ada.Exceptions by default, unless specified"}, {"sha": "19df9fd7694a5c0e32563688e001e7044d644d1a", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=800da97743ec985d0de0215afcf6bb44b7cd23c8", "patch": "@@ -289,6 +289,9 @@ procedure Gnat1drv is\n          Relaxed_RM_Semantics := True;\n       end if;\n \n+      --  Enable some individual switches that are implied by relaxed RM\n+      --  semantics mode.\n+\n       if Relaxed_RM_Semantics then\n          Overriding_Renamings := True;\n          Treat_Categorization_Errors_As_Warnings := True;"}, {"sha": "fda51cc6032868da9a1d4da36599cd780c25dc70", "filename": "gcc/ada/raise-gcc.c", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fraise-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fraise-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise-gcc.c?ref=800da97743ec985d0de0215afcf6bb44b7cd23c8", "patch": "@@ -878,6 +878,8 @@ exception_class_eq (const _GNAT_Exception *except, unsigned long long ec)\n #endif\n }\n \n+/* Return how CHOICE matches PROPAGATED_EXCEPTION.  */\n+\n static enum action_kind\n is_handled_by (_Unwind_Ptr choice, _GNAT_Exception *propagated_exception)\n {\n@@ -937,7 +939,8 @@ is_handled_by (_Unwind_Ptr choice, _GNAT_Exception *propagated_exception)\n       void *choice_typeinfo = Foreign_Data_For (choice);\n       void *except_typeinfo =\n \t(((struct __cxa_exception *)\n-\t  ((_Unwind_Exception *)propagated_exception + 1)) - 1)->exceptionType;\n+\t  ((_Unwind_Exception *)propagated_exception + 1)) - 1)\n+\t->exceptionType;\n \n       /* Typeinfo are directly compared, which might not be correct if they\n \t aren't merged.  ??? We should call the == operator if this module is\n@@ -995,7 +998,6 @@ get_action_description_for (_Unwind_Ptr ip,\n   else\n     {\n       const unsigned char * p = action->table_entry;\n-\n       _sleb128_t ar_filter, ar_disp;\n \n       action->kind = nothing;\n@@ -1028,7 +1030,8 @@ get_action_description_for (_Unwind_Ptr ip,\n \n                   /* See if the filter we have is for an exception which\n                      matches the one we are propagating.  */\n-                  _Unwind_Ptr choice = get_ttype_entry_for (region, ar_filter);\n+                  _Unwind_Ptr choice =\n+\t\t    get_ttype_entry_for (region, ar_filter);\n \n \t\t  act = is_handled_by (choice, gnat_exception);\n                   if (act != nothing)\n@@ -1105,7 +1108,7 @@ extern void __gnat_notify_unhandled_exception (struct Exception_Occurrence *);\n #endif\n \n /* Code executed to continue unwinding.  With the ARM unwinder, the\n-   personality routine must unwind one frame.  */\n+   personality routine must unwind one frame (per EHABI 7.3 4.).  */\n \n static _Unwind_Reason_Code\n continue_unwind (struct _Unwind_Exception* ue_header,\n@@ -1294,9 +1297,6 @@ PERSONALITY_FUNCTION (_Unwind_State state,\n \t\t      struct _Unwind_Context* uw_context)\n {\n   _Unwind_Action uw_phases;\n-  region_descriptor region;\n-  action_descriptor action;\n-  _Unwind_Ptr ip;\n \n   switch (state & _US_ACTION_MASK)\n     {\n@@ -1306,14 +1306,21 @@ PERSONALITY_FUNCTION (_Unwind_State state,\n       break;\n \n     case _US_UNWIND_FRAME_STARTING:\n+      /* Phase 2, to call a cleanup.  */\n       uw_phases = _UA_CLEANUP_PHASE;\n+#if 0\n+      /* ??? We don't use UA_HANDLER_FRAME (except to debug).  Futhermore,\n+\t barrier_cache.sp isn't yet set.  */\n       if (!(state & _US_FORCE_UNWIND)\n \t  && (uw_exception->barrier_cache.sp\n \t      == _Unwind_GetGR (uw_context, UNWIND_STACK_REG)))\n \tuw_phases |= _UA_HANDLER_FRAME;\n+#endif\n       break;\n \n     case _US_UNWIND_FRAME_RESUME:\n+      /* Phase 2, called at the return of a cleanup.  In the GNU\n+\t implementation, there is nothing left to do, so we simply go on.  */\n       return continue_unwind (uw_exception, uw_context);\n \n     default:"}, {"sha": "44997e4c3421868f4f6c33bc179ea68994428764", "filename": "gcc/ada/s-excmac-arm.ads", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fs-excmac-arm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fs-excmac-arm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-excmac-arm.ads?ref=800da97743ec985d0de0215afcf6bb44b7cd23c8", "patch": "@@ -0,0 +1,181 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--              S Y S T E M . E X C E P T I O N S . M A C H I N E           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2013, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the version using the ARM EHABI mechanism\n+\n+with Ada.Unchecked_Conversion;\n+with Ada.Exceptions;\n+\n+package System.Exceptions.Machine is\n+   pragma Preelaborate;\n+\n+   ------------------------------------------------\n+   -- Entities to interface with the GCC runtime --\n+   ------------------------------------------------\n+\n+   --  Return codes from GCC runtime functions used to propagate an exception\n+\n+   type Unwind_Reason_Code is\n+     (URC_OK,\n+      URC_FOREIGN_EXCEPTION_CAUGHT,\n+      URC_Unused2,\n+      URC_Unused3,\n+      URC_Unused4,\n+      URC_Unused5,\n+      URC_HANDLER_FOUND,\n+      URC_INSTALL_CONTEXT,\n+      URC_CONTINUE_UNWIND,\n+      URC_FAILURE);\n+\n+   pragma Unreferenced\n+     (URC_OK,\n+      URC_FOREIGN_EXCEPTION_CAUGHT,\n+      URC_Unused2,\n+      URC_Unused3,\n+      URC_Unused4,\n+      URC_Unused5,\n+      URC_HANDLER_FOUND,\n+      URC_INSTALL_CONTEXT,\n+      URC_CONTINUE_UNWIND,\n+      URC_FAILURE);\n+\n+   pragma Convention (C, Unwind_Reason_Code);\n+   subtype Unwind_Action is Unwind_Reason_Code;\n+   --  Phase identifiers\n+\n+   type uint32_t is mod 2**32;\n+   pragma Convention (C, uint32_t);\n+\n+   type uint32_t_array is array (Natural range <>) of uint32_t;\n+   pragma Convention (C, uint32_t_array);\n+\n+   type Unwind_State is new uint32_t;\n+   pragma Convention (C, Unwind_State);\n+\n+   US_VIRTUAL_UNWIND_FRAME  : constant Unwind_State := 0;\n+   US_UNWIND_FRAME_STARTING : constant Unwind_State := 1;\n+   US_UNWIND_FRAME_RESUME   : constant Unwind_State := 2;\n+\n+   pragma Unreferenced\n+     (US_VIRTUAL_UNWIND_FRAME,\n+      US_UNWIND_FRAME_STARTING,\n+      US_UNWIND_FRAME_RESUME);\n+\n+   --  Mandatory common header for any exception object handled by the\n+   --  GCC unwinding runtime.\n+\n+   type Exception_Class is array (0 .. 7) of Character;\n+\n+   GNAT_Exception_Class : constant Exception_Class := \"GNU-Ada\" & ASCII.NUL;\n+   --  \"GNU-Ada\\0\"\n+\n+   type Unwinder_Cache_Type is record\n+      Reserved1 : uint32_t;\n+      Reserved2 : uint32_t;\n+      Reserved3 : uint32_t;\n+      Reserved4 : uint32_t;\n+      Reserved5 : uint32_t;\n+   end record;\n+\n+   type Barrier_Cache_Type is record\n+      Sp          : uint32_t;\n+      Bitpattern  : uint32_t_array (0 .. 4);\n+   end record;\n+\n+   type Cleanup_Cache_Type is record\n+     Bitpattern : uint32_t_array (0 .. 3);\n+   end record;\n+\n+   type Pr_Cache_Type is record\n+      Fnstart    : uint32_t;\n+      Ehtp       : System.Address;\n+      Additional : uint32_t;\n+      Reserved1  : uint32_t;\n+   end record;\n+\n+   type Unwind_Control_Block is record\n+      Class    : Exception_Class;\n+      Cleanup  : System.Address;\n+\n+      --  Caches\n+      Unwinder_Cache : Unwinder_Cache_Type;\n+      Barrier_Cache  : Barrier_Cache_Type;\n+      Cleanup_Cache  : Cleanup_Cache_Type;\n+      Pr_Cache       : Pr_Cache_Type;\n+   end record;\n+   pragma Convention (C, Unwind_Control_Block);\n+   for Unwind_Control_Block'Alignment use 8;\n+   --  Map the GCC struct used for exception handling\n+\n+   type Unwind_Control_Block_Access is access all Unwind_Control_Block;\n+   subtype GCC_Exception_Access is Unwind_Control_Block_Access;\n+   --  Pointer to a UCB\n+\n+   procedure Unwind_DeleteException\n+     (Ucbp : not null Unwind_Control_Block_Access);\n+   pragma Import (C, Unwind_DeleteException, \"_Unwind_DeleteException\");\n+   --  Procedure to free any GCC exception\n+\n+   --------------------------------------------------------------\n+   -- GNAT Specific Entities To Deal With The GCC EH Circuitry --\n+   --------------------------------------------------------------\n+\n+   --  A GNAT exception object to be dealt with by the personality routine\n+   --  called by the GCC unwinding runtime.\n+\n+   type GNAT_GCC_Exception is record\n+      Header : Unwind_Control_Block;\n+      --  ABI Exception header first\n+\n+      Occurrence : aliased Ada.Exceptions.Exception_Occurrence;\n+      --  The Ada occurrence\n+   end record;\n+\n+   pragma Convention (C, GNAT_GCC_Exception);\n+\n+   type GNAT_GCC_Exception_Access is access all GNAT_GCC_Exception;\n+\n+   function To_GCC_Exception is new\n+     Ada.Unchecked_Conversion (System.Address, GCC_Exception_Access);\n+\n+   function To_GNAT_GCC_Exception is new\n+     Ada.Unchecked_Conversion\n+     (GCC_Exception_Access, GNAT_GCC_Exception_Access);\n+\n+   function New_Occurrence return GNAT_GCC_Exception_Access is\n+      (new GNAT_GCC_Exception'\n+         (Header     => (Class   => GNAT_Exception_Class,\n+                         Unwinder_Cache => (Reserved1 => 0,\n+                                            others => <>),\n+                         others => <>),\n+          Occurrence => <>));\n+   --  Allocate and initialize a machine occurrence\n+end System.Exceptions.Machine;"}, {"sha": "80e4cef3f918d0ec2f5907a225e1d37071984a5c", "filename": "gcc/ada/s-excmac-gcc.ads", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fs-excmac-gcc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fs-excmac-gcc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-excmac-gcc.ads?ref=800da97743ec985d0de0215afcf6bb44b7cd23c8", "patch": "@@ -0,0 +1,186 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--              S Y S T E M . E X C E P T I O N S . M A C H I N E           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2013, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the version using the GCC EH mechanism\n+\n+with Ada.Unchecked_Conversion;\n+with Ada.Exceptions;\n+\n+package System.Exceptions.Machine is\n+   pragma Preelaborate;\n+\n+   ------------------------------------------------\n+   -- Entities to interface with the GCC runtime --\n+   ------------------------------------------------\n+\n+   --  These come from \"C++ ABI for Itanium: Exception handling\", which is\n+   --  the reference for GCC.\n+\n+   --  Return codes from the GCC runtime functions used to propagate\n+   --  an exception.\n+\n+   type Unwind_Reason_Code is\n+     (URC_NO_REASON,\n+      URC_FOREIGN_EXCEPTION_CAUGHT,\n+      URC_PHASE2_ERROR,\n+      URC_PHASE1_ERROR,\n+      URC_NORMAL_STOP,\n+      URC_END_OF_STACK,\n+      URC_HANDLER_FOUND,\n+      URC_INSTALL_CONTEXT,\n+      URC_CONTINUE_UNWIND);\n+\n+   pragma Unreferenced\n+     (URC_NO_REASON,\n+      URC_FOREIGN_EXCEPTION_CAUGHT,\n+      URC_PHASE2_ERROR,\n+      URC_PHASE1_ERROR,\n+      URC_NORMAL_STOP,\n+      URC_END_OF_STACK,\n+      URC_HANDLER_FOUND,\n+      URC_INSTALL_CONTEXT,\n+      URC_CONTINUE_UNWIND);\n+\n+   pragma Convention (C, Unwind_Reason_Code);\n+\n+   --  Phase identifiers\n+\n+   type Unwind_Action is new Integer;\n+   pragma Convention (C, Unwind_Action);\n+\n+   UA_SEARCH_PHASE  : constant Unwind_Action := 1;\n+   UA_CLEANUP_PHASE : constant Unwind_Action := 2;\n+   UA_HANDLER_FRAME : constant Unwind_Action := 4;\n+   UA_FORCE_UNWIND  : constant Unwind_Action := 8;\n+   UA_END_OF_STACK  : constant Unwind_Action := 16;  --  GCC extension\n+\n+   pragma Unreferenced\n+     (UA_SEARCH_PHASE,\n+      UA_CLEANUP_PHASE,\n+      UA_HANDLER_FRAME,\n+      UA_FORCE_UNWIND,\n+      UA_END_OF_STACK);\n+\n+   --  Mandatory common header for any exception object handled by the\n+   --  GCC unwinding runtime.\n+\n+   type Exception_Class is mod 2 ** 64;\n+\n+   GNAT_Exception_Class : constant Exception_Class := 16#474e552d41646100#;\n+   --  \"GNU-Ada\\0\"\n+\n+   type Unwind_Word is mod 2 ** System.Word_Size;\n+   for Unwind_Word'Size use System.Word_Size;\n+   --  Map the corresponding C type used in Unwind_Exception below\n+\n+   type Unwind_Exception is record\n+      Class    : Exception_Class;\n+      Cleanup  : System.Address;\n+      Private1 : Unwind_Word;\n+      Private2 : Unwind_Word;\n+\n+      --  Usual exception structure has only two private fields, but the SEH\n+      --  one has six. To avoid making this file more complex, we use six\n+      --  fields on all platforms, wasting a few bytes on some.\n+\n+      Private3 : Unwind_Word;\n+      Private4 : Unwind_Word;\n+      Private5 : Unwind_Word;\n+      Private6 : Unwind_Word;\n+   end record;\n+   pragma Convention (C, Unwind_Exception);\n+   --  Map the GCC struct used for exception handling\n+\n+   for Unwind_Exception'Alignment use Standard'Maximum_Alignment;\n+   --  The C++ ABI mandates the common exception header to be at least\n+   --  doubleword aligned, and the libGCC implementation actually makes it\n+   --  maximally aligned (see unwind.h). See additional comments on the\n+   --  alignment below.\n+\n+   --  There is a subtle issue with the common header alignment, since the C\n+   --  version is aligned on BIGGEST_ALIGNMENT, the Ada version is aligned on\n+   --  Standard'Maximum_Alignment, and those two values don't quite represent\n+   --  the same concepts and so may be decoupled someday. One typical reason\n+   --  is that BIGGEST_ALIGNMENT may be larger than what the underlying system\n+   --  allocator guarantees, and there are extra costs involved in allocating\n+   --  objects aligned to such factors.\n+\n+   --  To deal with the potential alignment differences between the C and Ada\n+   --  representations, the Ada part of the whole structure is only accessed\n+   --  by the personality routine through accessors. Ada specific fields are\n+   --  thus always accessed through consistent layout, and we expect the\n+   --  actual alignment to always be large enough to avoid traps from the C\n+   --  accesses to the common header. Besides, accessors alleviate the need\n+   --  for a C struct whole counterpart, both painful and error-prone to\n+   --  maintain anyway.\n+\n+   type GCC_Exception_Access is access all Unwind_Exception;\n+   --  Pointer to a GCC exception. Do not use convention C as on VMS this\n+   --  would imply the use of 32-bits pointers.\n+\n+   procedure Unwind_DeleteException (Excp : not null GCC_Exception_Access);\n+   pragma Import (C, Unwind_DeleteException, \"_Unwind_DeleteException\");\n+   --  Procedure to free any GCC exception\n+\n+   --------------------------------------------------------------\n+   -- GNAT Specific Entities To Deal With The GCC EH Circuitry --\n+   --------------------------------------------------------------\n+\n+   --  A GNAT exception object to be dealt with by the personality routine\n+   --  called by the GCC unwinding runtime.\n+\n+   type GNAT_GCC_Exception is record\n+      Header : Unwind_Exception;\n+      --  ABI Exception header first\n+\n+      Occurrence : aliased Ada.Exceptions.Exception_Occurrence;\n+      --  The Ada occurrence\n+   end record;\n+\n+   pragma Convention (C, GNAT_GCC_Exception);\n+\n+   type GNAT_GCC_Exception_Access is access all GNAT_GCC_Exception;\n+\n+   function To_GCC_Exception is new\n+     Ada.Unchecked_Conversion (System.Address, GCC_Exception_Access);\n+\n+   function To_GNAT_GCC_Exception is new\n+     Ada.Unchecked_Conversion\n+       (GCC_Exception_Access, GNAT_GCC_Exception_Access);\n+\n+   function New_Occurrence return GNAT_GCC_Exception_Access is\n+      (new GNAT_GCC_Exception'\n+        (Header     => (Class   => GNAT_Exception_Class,\n+                        Cleanup => Null_Address,\n+                        others  => 0),\n+         Occurrence => <>));\n+   --  Allocate and initialize a machine occurrence\n+end System.Exceptions.Machine;"}, {"sha": "c021143332612b944459744b749a773f73c8018d", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=800da97743ec985d0de0215afcf6bb44b7cd23c8", "patch": "@@ -18142,7 +18142,7 @@ package body Sem_Prag is\n                      Context := Specification (Context);\n                   end if;\n \n-                  Body_Id := Defining_Unit_Name (Context);\n+                  Body_Id := Defining_Entity (Context);\n \n                   Chain_Pragma (Body_Id, N);\n "}, {"sha": "d99d94f76afaa3654f7848472f080a33eacc5ce4", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 45, "deletions": 27, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=800da97743ec985d0de0215afcf6bb44b7cd23c8", "patch": "@@ -9155,6 +9155,7 @@ package body Sem_Res is\n       Drange     : constant Node_Id := Discrete_Range (N);\n       Name       : constant Node_Id := Prefix (N);\n       Array_Type : Entity_Id        := Empty;\n+      Dexpr      : Node_Id          := Empty;\n       Index_Type : Entity_Id;\n \n    begin\n@@ -9267,47 +9268,64 @@ package body Sem_Res is\n          Array_Type := Etype (Name);\n       end if;\n \n+      --  Obtain the type of the array index\n+\n+      if Ekind (Array_Type) = E_String_Literal_Subtype then\n+         Index_Type := Etype (String_Literal_Low_Bound (Array_Type));\n+      else\n+         Index_Type := Etype (First_Index (Array_Type));\n+      end if;\n+\n       --  If name was overloaded, set slice type correctly now\n \n       Set_Etype (N, Array_Type);\n \n-      --  If the range is specified by a subtype mark, no resolution is\n-      --  necessary. Else resolve the bounds, and apply needed checks.\n+      --  Handle the generation of a range check that compares the array index\n+      --  against the discrete_range. The check is not applied to internally\n+      --  built nodes associated with the expansion of dispatch tables. Check\n+      --  that Ada.Tags has already been loaded to avoid extra dependencies on\n+      --  the unit.\n+\n+      if Tagged_Type_Expansion\n+        and then RTU_Loaded (Ada_Tags)\n+        and then Nkind (Prefix (N)) = N_Selected_Component\n+        and then Present (Entity (Selector_Name (Prefix (N))))\n+        and then Entity (Selector_Name (Prefix (N))) =\n+                   RTE_Record_Component (RE_Prims_Ptr)\n+      then\n+         null;\n \n-      if not Is_Entity_Name (Drange) then\n-         if Ekind (Array_Type) = E_String_Literal_Subtype then\n-            Index_Type := Etype (String_Literal_Low_Bound (Array_Type));\n-         else\n-            Index_Type := Etype (First_Index (Array_Type));\n-         end if;\n+      --  The discrete_range is specified by a subtype indication. Create a\n+      --  shallow copy and inherit the type, parent and source location from\n+      --  the discrete_range. This ensures that the range check is inserted\n+      --  relative to the slice and that the runtime exception points to the\n+      --  proper construct.\n \n-         Resolve (Drange, Base_Type (Index_Type));\n+      elsif Is_Entity_Name (Drange) then\n+         Dexpr := New_Copy (Scalar_Range (Entity (Drange)));\n \n-         if Nkind (Drange) = N_Range then\n+         Set_Etype  (Dexpr, Etype  (Drange));\n+         Set_Parent (Dexpr, Parent (Drange));\n+         Set_Sloc   (Dexpr, Sloc   (Drange));\n \n-            --  Ensure that side effects in the bounds are properly handled\n+      --  The discrete_range is a regular range. Resolve the bounds and remove\n+      --  their side effects.\n \n-            Force_Evaluation (Low_Bound (Drange));\n+      else\n+         Resolve (Drange, Base_Type (Index_Type));\n+\n+         if Nkind (Drange) = N_Range then\n+            Force_Evaluation (Low_Bound  (Drange));\n             Force_Evaluation (High_Bound (Drange));\n \n-            --  Do not apply the range check to nodes associated with the\n-            --  frontend expansion of the dispatch table. We first check\n-            --  if Ada.Tags is already loaded to avoid the addition of an\n-            --  undesired dependence on such run-time unit.\n-\n-            if not Tagged_Type_Expansion\n-              or else not\n-                (RTU_Loaded (Ada_Tags)\n-                  and then Nkind (Prefix (N)) = N_Selected_Component\n-                  and then Present (Entity (Selector_Name (Prefix (N))))\n-                  and then Entity (Selector_Name (Prefix (N))) =\n-                                         RTE_Record_Component (RE_Prims_Ptr))\n-            then\n-               Apply_Range_Check (Drange, Index_Type);\n-            end if;\n+            Dexpr := Drange;\n          end if;\n       end if;\n \n+      if Present (Dexpr) then\n+         Apply_Range_Check (Dexpr, Index_Type);\n+      end if;\n+\n       Set_Slice_Subtype (N);\n \n       --  Check bad use of type with predicates"}, {"sha": "78920da804c3d377c34bc4c8bd50e56e570f1217", "filename": "gcc/ada/sinput.adb", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fsinput.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fsinput.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.adb?ref=800da97743ec985d0de0215afcf6bb44b7cd23c8", "patch": "@@ -770,18 +770,20 @@ package body Sinput is\n       -------------\n \n       function Process (N : Node_Id) return Traverse_Result is\n+         Orig : constant Node_Id := Original_Node (N);\n       begin\n-         if Sloc (N) < Min then\n-            if Sloc (N) > No_Location then\n-               Min := Sloc (N);\n+         if Sloc (Orig) < Min then\n+            if Sloc (Orig) > No_Location then\n+               Min := Sloc (Orig);\n             end if;\n-         elsif Sloc (N) > Max then\n-            if Sloc (N) > No_Location then\n-               Max := Sloc (N);\n+\n+         elsif Sloc (Orig) > Max then\n+            if Sloc (Orig) > No_Location then\n+               Max := Sloc (Orig);\n             end if;\n          end if;\n \n-         return OK;\n+         return OK_Orig;\n       end Process;\n \n    --  Start of processing for Sloc_Range"}, {"sha": "899bead7339e6c2e6601a4e89450d67701ccf1a5", "filename": "gcc/ada/sinput.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fsinput.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/800da97743ec985d0de0215afcf6bb44b7cd23c8/gcc%2Fada%2Fsinput.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.ads?ref=800da97743ec985d0de0215afcf6bb44b7cd23c8", "patch": "@@ -693,8 +693,13 @@ package Sinput is\n    --  as the locations of the first and last token in the node construct\n    --  because parentheses at the outer level do not have a recorded Sloc.\n    --\n+   --  Note: At each step of the tree traversal, we make sure to go back to\n+   --  the Original_Node, since this function is concerned about original\n+   --  (source) locations.\n+   --\n    --  Note: if the tree for the expression contains no \"real\" Sloc values,\n-   --  i.e. values > No_Location, then both Min and Max are set to Sloc (Expr).\n+   --  i.e. values > No_Location, then both Min and Max are set to\n+   --  Sloc (Original_Node (N)).\n \n    function Source_Offset (S : Source_Ptr) return Nat;\n    --  Returns the zero-origin offset of the given source location from the"}]}