{"sha": "ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWMwNzJjYjJmNGRkODg0ZDQ4ZmI3NTI3Y2FkZjJhYTBiMWE2NTZkMA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T10:47:17Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-30T10:47:17Z"}, "message": "[multiple changes]\n\n2014-07-30  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch4.adb (Analyze_If_Expression): Resolve condition before\n\tanalyzing branches.\n\t* sem_eval.adb (Out_Of_Range): Check for statically unevaluated\n\texpression case.\n\n2014-07-30  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch13.adb (Analyze_Aspect, predicate cases): Diagnose use\n\tof predicate aspect on entity other than a type.\n\n2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Body_Has_Contract): New predicate to determine\n\twhen a subprogram body without a previous spec cannot be inlined\n\tin GNATprove mode, because it includes aspects or pragmas that\n\tgenerate a SPARK contract clause.\n\t* inline.adb (Can_Be_Inlined_In_GNATprove_Mode): A subprogram\n\tinstance cannot be inlined.\n\nFrom-SVN: r213247", "tree": {"sha": "18f7a061ea1bffce8cef6c5638af132a9dcb3ded", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18f7a061ea1bffce8cef6c5638af132a9dcb3ded"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0/comments", "author": null, "committer": null, "parents": [{"sha": "cc6f5d75edd7727c9453cdfab4f03ae84b099b0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc6f5d75edd7727c9453cdfab4f03ae84b099b0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc6f5d75edd7727c9453cdfab4f03ae84b099b0a"}], "stats": {"total": 135, "additions": 128, "deletions": 7}, "files": [{"sha": "dea492c7be4c5c5f397de3aa65b9b352e6b2d265", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0", "patch": "@@ -1,3 +1,24 @@\n+2014-07-30  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch4.adb (Analyze_If_Expression): Resolve condition before\n+\tanalyzing branches.\n+\t* sem_eval.adb (Out_Of_Range): Check for statically unevaluated\n+\texpression case.\n+\n+2014-07-30  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch13.adb (Analyze_Aspect, predicate cases): Diagnose use\n+\tof predicate aspect on entity other than a type.\n+\n+2014-07-30  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Body_Has_Contract): New predicate to determine\n+\twhen a subprogram body without a previous spec cannot be inlined\n+\tin GNATprove mode, because it includes aspects or pragmas that\n+\tgenerate a SPARK contract clause.\n+\t* inline.adb (Can_Be_Inlined_In_GNATprove_Mode): A subprogram\n+\tinstance cannot be inlined.\n+\n 2014-07-30  Robert Dewar  <dewar@adacore.com>\n \n \t* debug.adb: Document that d7 suppresses compilation time output."}, {"sha": "c2ee80783b3ba9f4b67d467148b0c68ddc22622a", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0", "patch": "@@ -1490,13 +1490,12 @@ package body Inline is\n \n       function Has_Some_Contract (Id : Entity_Id) return Boolean is\n          Items : constant Node_Id := Contract (Id);\n+\n       begin\n          return Present (Items)\n            and then (Present (Pre_Post_Conditions (Items))\n-                       or else\n-                     Present (Contract_Test_Cases (Items))\n-                       or else\n-                     Present (Classifications (Items)));\n+                      or else Present (Contract_Test_Cases (Items))\n+                      or else Present (Classifications (Items)));\n       end Has_Some_Contract;\n \n       --------------------------\n@@ -1589,6 +1588,9 @@ package body Inline is\n       then\n          return False;\n \n+      elsif Is_Generic_Instance (Spec_Id) then\n+         return False;\n+\n       --  Only inline subprograms whose body is marked SPARK_Mode On\n \n       elsif No (SPARK_Pragma (Body_Id))"}, {"sha": "f6a8707c1698abecb94441d0569e79d6f70f1c20", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0", "patch": "@@ -1778,6 +1778,15 @@ package body Sem_Ch13 is\n                     Aspect_Predicate         |\n                     Aspect_Static_Predicate  =>\n \n+                  --  These aspects apply only to subtypes\n+\n+                  if not Is_Type (E) then\n+                     Error_Msg_N\n+                       (\"predicate can only be specified for a subtype\",\n+                        Aspect);\n+                     goto Continue;\n+                  end if;\n+\n                   --  Construct the pragma (always a pragma Predicate, with\n                   --  flags recording whether it is static/dynamic). We also\n                   --  set flags recording this in the type itself."}, {"sha": "f7d6aa895b64e1fa306e916bb23b30277cc1c253", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0", "patch": "@@ -2046,7 +2046,18 @@ package body Sem_Ch4 is\n          Check_Compiler_Unit (\"if expression\", N);\n       end if;\n \n+      --  Analyze and resolve the condition. We need to resolve this now so\n+      --  that it gets folded to True/False if possible, before we analyze\n+      --  the THEN/ELSE branches, because when analyzing these branches, we\n+      --  may call Is_Statically_Unevaluated, which expects the condition of\n+      --  an enclosing IF to have been analyze/resolved/evaluated.\n+\n       Analyze_Expression (Condition);\n+      Resolve (Condition, Any_Boolean);\n+\n+      --  Analyze THEN expression and (if present) ELSE expression. For those\n+      --  we delay resolution in the normal manner, because of overloading etc.\n+\n       Analyze_Expression (Then_Expr);\n \n       if Present (Else_Expr) then"}, {"sha": "e2b267bb96870d536e0d36cae32a6c2941c0ac8b", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0", "patch": "@@ -2167,6 +2167,10 @@ package body Sem_Ch6 is\n       --  Analyze the aspect specifications of a subprogram body [stub]. It is\n       --  assumed that N has aspects.\n \n+      function Body_Has_Contract return Boolean;\n+      --  Check whether unanalyzed body has an aspect or pragma that may\n+      --  generate a SPARK contrac.\n+\n       procedure Check_Anonymous_Return;\n       --  Ada 2005: if a function returns an access type that denotes a task,\n       --  or a type that contains tasks, we must create a master entity for\n@@ -2339,6 +2343,68 @@ package body Sem_Ch6 is\n          end if;\n       end Analyze_Aspects_On_Body_Or_Stub;\n \n+      -----------------------\n+      -- Body_Has_Contract --\n+      -----------------------\n+\n+      function Body_Has_Contract return Boolean is\n+         Decls  : constant List_Id := Declarations (N);\n+         A_Spec : Node_Id;\n+         A      : Aspect_Id;\n+         Decl   : Node_Id;\n+         P_Id   : Pragma_Id;\n+\n+      begin\n+         --  Check for unanalyzed aspects in the body that will\n+         --  generate a contract.\n+\n+         if Present (Aspect_Specifications (N)) then\n+            A_Spec := First (Aspect_Specifications (N));\n+            while Present (A_Spec) loop\n+               A := Get_Aspect_Id (Chars (Identifier (A_Spec)));\n+\n+               if A = Aspect_Contract_Cases\n+                 or else A = Aspect_Depends\n+                 or else A = Aspect_Global\n+                 or else A = Aspect_Pre\n+                 or else A = Aspect_Precondition\n+                 or else A = Aspect_Post\n+                 or else A = Aspect_Postcondition\n+               then\n+                  return True;\n+               end if;\n+\n+               Next (A_Spec);\n+            end loop;\n+         end if;\n+\n+         --  Check for pragmas that may generate a contract.\n+\n+         if Present (Decls) then\n+            Decl := First (Decls);\n+            while Present (Decl) loop\n+               if Nkind (Decl) = N_Pragma then\n+                  P_Id := Get_Pragma_Id (Pragma_Name (Decl));\n+\n+                  if P_Id = Pragma_Contract_Cases\n+                    or else P_Id = Pragma_Depends\n+                    or else P_Id = Pragma_Global\n+                    or else P_Id = Pragma_Pre\n+                    or else P_Id = Pragma_Precondition\n+                    or else P_Id = Pragma_Post\n+                    or else P_Id = Pragma_Postcondition\n+                  then\n+                     return True;\n+                  end if;\n+               end if;\n+\n+               Next (Decl);\n+            end loop;\n+         end if;\n+\n+         return False;\n+      end Body_Has_Contract;\n+\n       ----------------------------\n       -- Check_Anonymous_Return --\n       ----------------------------\n@@ -2969,6 +3035,7 @@ package body Sem_Ch6 is\n                  and then Full_Analysis\n                  and then Comes_From_Source (Body_Id)\n                  and then Is_List_Member (N)\n+                 and then not Body_Has_Contract\n                then\n                   declare\n                      Body_Spec : constant Node_Id :=\n@@ -3410,6 +3477,7 @@ package body Sem_Ch6 is\n            and then\n              Nkind (Parent (Parent (Spec_Id))) = N_Subprogram_Declaration\n            and then Can_Be_Inlined_In_GNATprove_Mode (Spec_Id, Body_Id)\n+           and then not Body_Has_Contract\n          then\n             Build_Body_To_Inline (N, Spec_Id);\n          end if;\n@@ -3437,6 +3505,7 @@ package body Sem_Ch6 is\n         and then Present (Spec_Id)\n         and then Nkind (Parent (Parent (Spec_Id))) = N_Subprogram_Declaration\n         and then Can_Be_Inlined_In_GNATprove_Mode (Spec_Id, Body_Id)\n+        and then not Body_Has_Contract\n       then\n          Check_And_Build_Body_To_Inline (N, Spec_Id, Body_Id);\n       end if;"}, {"sha": "6c41a4e5290d19f5c678f40a7d34b8e28a446fe5", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=ac072cb2f4dd884d48fb7527cadf2aa0b1a656d0", "patch": "@@ -5280,15 +5280,22 @@ package body Sem_Eval is\n       --  If we have the static expression case, then this is an illegality\n       --  in Ada 95 mode, except that in an instance, we never generate an\n       --  error (if the error is legitimate, it was already diagnosed in the\n-      --  template). The expression to compute the length of a packed array is\n-      --  attached to the array type itself, and deserves a separate message.\n+      --  template).\n \n       if Is_Static_Expression (N)\n         and then not In_Instance\n         and then not In_Inlined_Body\n         and then Ada_Version >= Ada_95\n       then\n-         if Nkind (Parent (N)) = N_Defining_Identifier\n+         --  No message if we are staticallly unevaluated\n+\n+         if Is_Statically_Unevaluated (N) then\n+            null;\n+\n+         --  The expression to compute the length of a packed array is attached\n+         --  to the array type itself, and deserves a separate message.\n+\n+         elsif Nkind (Parent (N)) = N_Defining_Identifier\n            and then Is_Array_Type (Parent (N))\n            and then Present (Packed_Array_Impl_Type (Parent (N)))\n            and then Present (First_Rep_Item (Parent (N)))\n@@ -5298,6 +5305,8 @@ package body Sem_Eval is\n               First_Rep_Item (Parent (N)));\n             Rewrite (N, Make_Integer_Literal (Sloc (N), Uint_1));\n \n+         --  All cases except the special array case\n+\n          else\n             Apply_Compile_Time_Constraint_Error\n               (N, \"value not in range of}\", CE_Range_Check_Failed);"}]}