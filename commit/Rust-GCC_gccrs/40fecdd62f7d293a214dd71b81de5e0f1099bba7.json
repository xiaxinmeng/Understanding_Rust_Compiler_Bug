{"sha": "40fecdd62f7d293a214dd71b81de5e0f1099bba7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBmZWNkZDYyZjdkMjkzYTIxNGRkNzFiODFkZTVlMGYxMDk5YmJhNw==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2015-01-30T16:15:00Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2015-01-30T16:15:00Z"}, "message": "Always pass explicit location to fatal_error.\n\nThe patch <https://gcc.gnu.org/ml/gcc-patches/2014-11/msg00698.html>\nadding an overload for fatal_error that passes an explicit location\nbroke gcc.pot regeneration because xgettext cannot handle function\noverloads with the diagnostic string argument in different positions.\n\nAs the desired direction is for all diagnostics to have explicit\nlocations, this patch addresses the regression by removing the version\nof fatal_error that does not pass a location, passing explicit\ninput_location everywhere (in the hope that those will incrementally\nbe changed to other locations, much as with the addition of a location\nargument to pedwarn some time ago - a lot of cases aren't meaningfully\nassociated with a source file so UNKNOWN_LOCATION may be better).\n\nNote that this patch does not attempt to fix any existing issues with\nthese diagnostics (such as wrongly starting with capital letters or\nending with '.' or '\\n'); it just adds the input_location argument.\n\nBootstrapped with no regressions for x86_64-unknown-linux-gnu (Go\nexcluded).\n\ngcc:\n\t* diagnostic.c (fatal_error (const char *, ...)): Remove function.\n\t* diagnostic-core.h (fatal_error (const char *, ...)): Remove\n\tprototype.\n\t* toplev.h (init_asm_output): Update comment on use of\n\tUNKNOWN_LOCATION with fatal_error.\n\t* cgraph.c, collect-utils.c, collect2.c, config/arc/arc.c,\n\tconfig/arc/arc.md, config/avr/avr.c, config/c6x/c6x.h,\n\tconfig/darwin.c, config/host-darwin.c, config/i386/host-cygwin.c,\n\tconfig/i386/intelmic-mkoffload.c, config/nios2/nios2.c,\n\tconfig/nvptx/mkoffload.c, config/nvptx/nvptx.h,\n\tconfig/rs6000/host-darwin.c, config/rs6000/rs6000.c,\n\tconfig/s390/s390.c, gcc.c, gcov-io.h, gcov-tool.c, ggc-common.c,\n\tggc-page.c, graph.c, ipa-inline-analysis.c, ipa-reference.c,\n\tlto-cgraph.c, lto-section-in.c, lto-streamer-in.c, lto-streamer.c,\n\tlto-wrapper.c, objc/objc-act.c, opts.c, passes.c, plugin.c,\n\ttlink.c, toplev.c, tree-streamer-in.c, varpool.c: All callers of\n\tfatal_error changed to pass input_location as first argument.\n\ngcc/c-family:\n\t* c-opts.c, c-pch.c, cppspec.c: All callers of fatal_error changed\n\tto pass input_location as first argument.\n\ngcc/cp:\n\t* class.c, except.c, parser.c, pt.c: All callers of fatal_error\n\tchanged to pass input_location as first argument.\n\ngcc/fortran:\n\t* f95-lang.c, gfortranspec.c, trans-const.c, trans-expr.c: All\n\tcallers of fatal_error changed to pass input_location as first\n\targument.\n\ngcc/java:\n\t* class.c, expr.c, jcf-parse.c, jvspec.c: All callers of\n\tfatal_error changed to pass input_location as first argument.\n\ngcc/lto:\n\t* lto-object.c, lto-symtab.c, lto.c: All callers of fatal_error\n\tchanged to pass input_location as first argument.\n\nlibcc1:\n\t* plugin.cc: All callers of fatal_error changed to pass\n\tinput_location as first argument.\n\nFrom-SVN: r220293", "tree": {"sha": "205b68f7ca81a40e0ec33999911c7cd124be49b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/205b68f7ca81a40e0ec33999911c7cd124be49b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40fecdd62f7d293a214dd71b81de5e0f1099bba7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40fecdd62f7d293a214dd71b81de5e0f1099bba7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40fecdd62f7d293a214dd71b81de5e0f1099bba7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40fecdd62f7d293a214dd71b81de5e0f1099bba7/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4811c44ee01bba9fd09fe5e2b6b9fc9be66b33c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4811c44ee01bba9fd09fe5e2b6b9fc9be66b33c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4811c44ee01bba9fd09fe5e2b6b9fc9be66b33c9"}], "stats": {"total": 753, "additions": 446, "deletions": 307}, "files": [{"sha": "f7f058d55c3f789ec2d6f9a167d1489481c77c10", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -1,3 +1,23 @@\n+2015-01-30  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* diagnostic.c (fatal_error (const char *, ...)): Remove function.\n+\t* diagnostic-core.h (fatal_error (const char *, ...)): Remove\n+\tprototype.\n+\t* toplev.h (init_asm_output): Update comment on use of\n+\tUNKNOWN_LOCATION with fatal_error.\n+\t* cgraph.c, collect-utils.c, collect2.c, config/arc/arc.c,\n+\tconfig/arc/arc.md, config/avr/avr.c, config/c6x/c6x.h,\n+\tconfig/darwin.c, config/host-darwin.c, config/i386/host-cygwin.c,\n+\tconfig/i386/intelmic-mkoffload.c, config/nios2/nios2.c,\n+\tconfig/nvptx/mkoffload.c, config/nvptx/nvptx.h,\n+\tconfig/rs6000/host-darwin.c, config/rs6000/rs6000.c,\n+\tconfig/s390/s390.c, gcc.c, gcov-io.h, gcov-tool.c, ggc-common.c,\n+\tggc-page.c, graph.c, ipa-inline-analysis.c, ipa-reference.c,\n+\tlto-cgraph.c, lto-section-in.c, lto-streamer-in.c, lto-streamer.c,\n+\tlto-wrapper.c, objc/objc-act.c, opts.c, passes.c, plugin.c,\n+\ttlink.c, toplev.c, tree-streamer-in.c, varpool.c: All callers of\n+\tfatal_error changed to pass input_location as first argument.\n+\n 2015-01-30  Martin Liska  <mliska@suse.cz>\n \n \t* tree.h: Change GCC_VERSION >= 4004 to GCC_VERSION >= 4006"}, {"sha": "9764b7c144aee2762cc4fe283e332dc4fa57642f", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -1,3 +1,8 @@\n+2015-01-30  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-opts.c, c-pch.c, cppspec.c: All callers of fatal_error changed\n+\tto pass input_location as first argument.\n+\n 2015-01-23  Tom de Vries  <tom@codesourcery.com>\n \n \tPR libgomp/64672"}, {"sha": "d10e5bd8daaeeeac3ad52e6b2bb6bdadaeebd91e", "filename": "gcc/c-family/c-opts.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fc-family%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fc-family%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-opts.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -928,7 +928,7 @@ c_common_post_options (const char **pfilename)\n \n       if (out_stream == NULL)\n \t{\n-\t  fatal_error (\"opening output file %s: %m\", out_fname);\n+\t  fatal_error (input_location, \"opening output file %s: %m\", out_fname);\n \t  return false;\n \t}\n \n@@ -1111,7 +1111,8 @@ c_common_finish (void)\n \t{\n \t  deps_stream = fopen (deps_file, deps_append ? \"a\": \"w\");\n \t  if (!deps_stream)\n-\t    fatal_error (\"opening dependency file %s: %m\", deps_file);\n+\t    fatal_error (input_location, \"opening dependency file %s: %m\",\n+\t\t\t deps_file);\n \t}\n     }\n \n@@ -1121,10 +1122,10 @@ c_common_finish (void)\n \n   if (deps_stream && deps_stream != out_stream\n       && (ferror (deps_stream) || fclose (deps_stream)))\n-    fatal_error (\"closing dependency file %s: %m\", deps_file);\n+    fatal_error (input_location, \"closing dependency file %s: %m\", deps_file);\n \n   if (out_stream && (ferror (out_stream) || fclose (out_stream)))\n-    fatal_error (\"when writing output to %s: %m\", out_fname);\n+    fatal_error (input_location, \"when writing output to %s: %m\", out_fname);\n }\n \n /* Either of two environment variables can specify output of"}, {"sha": "0ede92ab7ccf9856f4e45cff8053d30e17e65948", "filename": "gcc/c-family/c-pch.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fc-family%2Fc-pch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fc-family%2Fc-pch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pch.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -122,7 +122,8 @@ pch_init (void)\n \n   f = fopen (pch_file, \"w+b\");\n   if (f == NULL)\n-    fatal_error (\"can%'t create precompiled header %s: %m\", pch_file);\n+    fatal_error (input_location, \"can%'t create precompiled header %s: %m\",\n+\t\t pch_file);\n   pch_outfile = f;\n \n   gcc_assert (memcmp (executable_checksum, no_checksum, 16) != 0);\n@@ -144,7 +145,7 @@ pch_init (void)\n       || fwrite (executable_checksum, 16, 1, f) != 1\n       || fwrite (&v, sizeof (v), 1, f) != 1\n       || fwrite (target_validity, v.target_data_length, 1, f) != 1)\n-    fatal_error (\"can%'t write to %s: %m\", pch_file);\n+    fatal_error (input_location, \"can%'t write to %s: %m\", pch_file);\n \n   /* Let the debugging format deal with the PCHness.  */\n   (*debug_hooks->handle_pch) (0);\n@@ -202,7 +203,7 @@ c_common_write_pch (void)\n \n   if (fseek (pch_outfile, 0, SEEK_SET) != 0\n       || fwrite (get_ident (), IDENT_LENGTH, 1, pch_outfile) != 1)\n-    fatal_error (\"can%'t write %s: %m\", pch_file);\n+    fatal_error (input_location, \"can%'t write %s: %m\", pch_file);\n \n   fclose (pch_outfile);\n \n@@ -230,7 +231,7 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n \n   sizeread = read (fd, ident, IDENT_LENGTH + 16);\n   if (sizeread == -1)\n-    fatal_error (\"can%'t read %s: %m\", name);\n+    fatal_error (input_location, \"can%'t read %s: %m\", name);\n   else if (sizeread != IDENT_LENGTH + 16)\n     {\n       if (cpp_get_options (pfile)->warn_invalid_pch)\n@@ -271,7 +272,7 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n      executable, so it ought to be long enough that we can read a\n      c_pch_validity structure.  */\n   if (read (fd, &v, sizeof (v)) != sizeof (v))\n-    fatal_error (\"can%'t read %s: %m\", name);\n+    fatal_error (input_location, \"can%'t read %s: %m\", name);\n \n   /* The allowable debug info combinations are that either the PCH file\n      was built with the same as is being used now, or the PCH file was\n@@ -322,7 +323,7 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n \n     if ((size_t) read (fd, this_file_data, v.target_data_length)\n \t!= v.target_data_length)\n-      fatal_error (\"can%'t read %s: %m\", name);\n+      fatal_error (input_location, \"can%'t read %s: %m\", name);\n     msg = targetm.pch_valid_p (this_file_data, v.target_data_length);\n     free (this_file_data);\n     if (msg != NULL)\n@@ -435,13 +436,13 @@ c_common_pch_pragma (cpp_reader *pfile, const char *name)\n \n   fd = open (name, O_RDONLY | O_BINARY, 0666);\n   if (fd == -1)\n-    fatal_error (\"%s: couldn%'t open PCH file: %m\", name);\n+    fatal_error (input_location, \"%s: couldn%'t open PCH file: %m\", name);\n \n   if (c_common_valid_pch (pfile, name, fd) != 1)\n     {\n       if (!cpp_get_options (pfile)->warn_invalid_pch)\n \tinform (input_location, \"use -Winvalid-pch for more information\");\n-      fatal_error (\"%s: PCH file was invalid\", name);\n+      fatal_error (input_location, \"%s: PCH file was invalid\", name);\n     }\n \n   c_common_read_pch (pfile, name, fd, name);"}, {"sha": "55e368b24e6568b33edfb9b310253857e816629b", "filename": "gcc/c-family/cppspec.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fc-family%2Fcppspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fc-family%2Fcppspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fcppspec.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -89,7 +89,8 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n \n \tcase OPT_S:\n \tcase OPT_c:\n-\t  fatal_error (\"%qs is not a valid option to the preprocessor\",\n+\t  fatal_error (input_location,\n+\t\t       \"%qs is not a valid option to the preprocessor\",\n \t\t       decoded_options[i].orig_option_with_args_text);\n \t  return;\n \n@@ -108,7 +109,7 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n \t\tseen_input++;\n \t\tif (seen_input == 3)\n \t\t  {\n-\t\t    fatal_error (\"too many input files\");\n+\t\t    fatal_error (input_location, \"too many input files\");\n \t\t    return;\n \t\t  }\n \t\telse if (seen_input == 2)"}, {"sha": "89d0d2feb9fdfa823f13b5a1a7fbae23c87499cd", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -3188,7 +3188,7 @@ cgraph_node::get_untransformed_body (void)\n   data = lto_get_section_data (file_data, LTO_section_function_body,\n \t\t\t       name, &len);\n   if (!data)\n-    fatal_error (\"%s: section %s is missing\",\n+    fatal_error (input_location, \"%s: section %s is missing\",\n \t\t file_data->file_name,\n \t\t name);\n "}, {"sha": "6bbe9eb86980e3f033e4b29f48e457e5c27e1439", "filename": "gcc/collect-utils.c", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fcollect-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fcollect-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect-utils.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -65,15 +65,15 @@ collect_wait (const char *prog, struct pex_obj *pex)\n   int status;\n \n   if (!pex_get_status (pex, 1, &status))\n-    fatal_error (\"can't get program status: %m\");\n+    fatal_error (input_location, \"can't get program status: %m\");\n   pex_free (pex);\n \n   if (status)\n     {\n       if (WIFSIGNALED (status))\n \t{\n \t  int sig = WTERMSIG (status);\n-\t  fatal_error (\"%s terminated with signal %d [%s]%s\",\n+\t  fatal_error (input_location, \"%s terminated with signal %d [%s]%s\",\n \t\t       prog, sig, strsignal (sig),\n \t\t       WCOREDUMP (status) ? \", core dumped\" : \"\");\n \t}\n@@ -89,7 +89,7 @@ do_wait (const char *prog, struct pex_obj *pex)\n {\n   int ret = collect_wait (prog, pex);\n   if (ret != 0)\n-    fatal_error (\"%s returned %d exit status\", prog, ret);\n+    fatal_error (input_location, \"%s returned %d exit status\", prog, ret);\n \n   if (response_file && !save_temps)\n     {\n@@ -130,17 +130,20 @@ collect_execute (const char *prog, char **argv, const char *outname,\n       f = fopen (response_file, \"w\");\n \n       if (f == NULL)\n-        fatal_error (\"could not open response file %s\", response_file);\n+        fatal_error (input_location, \"could not open response file %s\",\n+\t\t     response_file);\n \n       status = writeargv (current_argv, f);\n \n       if (status)\n-        fatal_error (\"could not write to response file %s\", response_file);\n+        fatal_error (input_location, \"could not write to response file %s\",\n+\t\t     response_file);\n \n       status = fclose (f);\n \n       if (EOF == status)\n-        fatal_error (\"could not close response file %s\", response_file);\n+        fatal_error (input_location, \"could not close response file %s\",\n+\t\t     response_file);\n \n       response_arg = concat (\"@\", response_file, NULL);\n       response_argv[0] = argv0;\n@@ -173,11 +176,11 @@ collect_execute (const char *prog, char **argv, const char *outname,\n      since we might not end up needing something that we could not find.  */\n \n   if (argv[0] == 0)\n-    fatal_error (\"cannot find '%s'\", prog);\n+    fatal_error (input_location, \"cannot find '%s'\", prog);\n \n   pex = pex_init (0, \"collect2\", NULL);\n   if (pex == NULL)\n-    fatal_error (\"pex_init failed: %m\");\n+    fatal_error (input_location, \"pex_init failed: %m\");\n \n   errmsg = pex_run (pex, flags, argv[0], argv, outname,\n \t\t    errname, &err);\n@@ -186,10 +189,10 @@ collect_execute (const char *prog, char **argv, const char *outname,\n       if (err != 0)\n \t{\n \t  errno = err;\n-\t  fatal_error (\"%s: %m\", _(errmsg));\n+\t  fatal_error (input_location, \"%s: %m\", _(errmsg));\n \t}\n       else\n-\tfatal_error (errmsg);\n+\tfatal_error (input_location, errmsg);\n     }\n \n   free (response_arg);"}, {"sha": "b53e15189df6d2550f266b539a2d0c26a05dd771", "filename": "gcc/collect2.c", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -699,7 +699,7 @@ maybe_run_lto_and_relink (char **lto_ld_argv, char **object_lst,\n       size_t num_files;\n \n       if (!lto_wrapper)\n-\tfatal_error (\"COLLECT_LTO_WRAPPER must be set\");\n+\tfatal_error (input_location, \"COLLECT_LTO_WRAPPER must be set\");\n \n       num_lto_c_args++;\n \n@@ -963,7 +963,7 @@ main (int argc, char **argv)\n   diagnostic_initialize (global_dc, 0);\n \n   if (atexit (collect_atexit) != 0)\n-    fatal_error (\"atexit failed\");\n+    fatal_error (input_location, \"atexit failed\");\n \n   /* Do not invoke xcalloc before this point, since locale needs to be\n      set first, in case a diagnostic is issued.  */\n@@ -1061,7 +1061,7 @@ main (int argc, char **argv)\n   c_ptr = CONST_CAST2 (const char **, char **, c_argv);\n \n   if (argc < 2)\n-    fatal_error (\"no arguments\");\n+    fatal_error (input_location, \"no arguments\");\n \n #ifdef SIGQUIT\n   if (signal (SIGQUIT, SIG_IGN) != SIG_IGN)\n@@ -1341,7 +1341,8 @@ main (int argc, char **argv)\n \n \t\t  stream = fopen (list_filename, \"r\");\n \t\t  if (stream == NULL)\n-\t\t    fatal_error (\"can't open %s: %m\", list_filename);\n+\t\t    fatal_error (input_location, \"can't open %s: %m\",\n+\t\t\t\t list_filename);\n \n \t\t  while (fgets (buf, sizeof buf, stream) != NULL)\n \t\t    {\n@@ -1542,10 +1543,10 @@ main (int argc, char **argv)\n \n       exportf = fopen (export_file, \"w\");\n       if (exportf == (FILE *) 0)\n-\tfatal_error (\"fopen %s: %m\", export_file);\n+\tfatal_error (input_location, \"fopen %s: %m\", export_file);\n       write_aix_file (exportf, exports.first);\n       if (fclose (exportf))\n-\tfatal_error (\"fclose %s: %m\", export_file);\n+\tfatal_error (input_location, \"fclose %s: %m\", export_file);\n     }\n #endif\n \n@@ -1725,12 +1726,12 @@ main (int argc, char **argv)\n   maybe_unlink (output_file);\n   outf = fopen (c_file, \"w\");\n   if (outf == (FILE *) 0)\n-    fatal_error (\"fopen %s: %m\", c_file);\n+    fatal_error (input_location, \"fopen %s: %m\", c_file);\n \n   write_c_file (outf, c_file);\n \n   if (fclose (outf))\n-    fatal_error (\"fclose %s: %m\", c_file);\n+    fatal_error (input_location, \"fclose %s: %m\", c_file);\n \n   /* Tell the linker that we have initializer and finalizer functions.  */\n #ifdef LD_INIT_SWITCH\n@@ -1765,10 +1766,10 @@ main (int argc, char **argv)\n #endif\n       exportf = fopen (export_file, \"w\");\n       if (exportf == (FILE *) 0)\n-\tfatal_error (\"fopen %s: %m\", export_file);\n+\tfatal_error (input_location, \"fopen %s: %m\", export_file);\n       write_aix_file (exportf, exports.first);\n       if (fclose (exportf))\n-\tfatal_error (\"fclose %s: %m\", export_file);\n+\tfatal_error (input_location, \"fclose %s: %m\", export_file);\n     }\n #endif\n \n@@ -2320,7 +2321,7 @@ scan_prog_file (const char *prog_name, scanpass which_pass,\n \n   /* If we do not have an `nm', complain.  */\n   if (nm_file_name == 0)\n-    fatal_error (\"cannot find 'nm'\");\n+    fatal_error (input_location, \"cannot find 'nm'\");\n \n   nm_argv[argc++] = nm_file_name;\n   if (NM_FLAGS[0] != '\\0')\n@@ -2346,7 +2347,7 @@ scan_prog_file (const char *prog_name, scanpass which_pass,\n \n   pex = pex_init (PEX_USE_PIPES, \"collect2\", NULL);\n   if (pex == NULL)\n-    fatal_error (\"pex_init failed: %m\");\n+    fatal_error (input_location, \"pex_init failed: %m\");\n \n   errmsg = pex_run (pex, 0, nm_file_name, real_nm_argv, NULL, HOST_BIT_BUCKET,\n \t\t    &err);\n@@ -2355,10 +2356,10 @@ scan_prog_file (const char *prog_name, scanpass which_pass,\n       if (err != 0)\n \t{\n \t  errno = err;\n-\t  fatal_error (\"%s: %m\", _(errmsg));\n+\t  fatal_error (input_location, \"%s: %m\", _(errmsg));\n \t}\n       else\n-\tfatal_error (errmsg);\n+\tfatal_error (input_location, errmsg);\n     }\n \n   int_handler  = (void (*) (int)) signal (SIGINT,  SIG_IGN);\n@@ -2368,7 +2369,7 @@ scan_prog_file (const char *prog_name, scanpass which_pass,\n \n   inf = pex_read_output (pex, 0);\n   if (inf == NULL)\n-    fatal_error (\"can't open nm output: %m\");\n+    fatal_error (input_location, \"can't open nm output: %m\");\n \n   if (debug)\n     {\n@@ -2452,7 +2453,8 @@ scan_prog_file (const char *prog_name, scanpass which_pass,\n \t  if (! (filter & SCAN_INIT))\n \t    break;\n \t  if (which_pass != PASS_LIB)\n-\t    fatal_error (\"init function found in object %s\", prog_name);\n+\t    fatal_error (input_location, \"init function found in object %s\",\n+\t\t\t prog_name);\n #ifndef LD_INIT_SWITCH\n \t  add_to_list (&constructors, name);\n #endif\n@@ -2462,7 +2464,8 @@ scan_prog_file (const char *prog_name, scanpass which_pass,\n \t  if (! (filter & SCAN_FINI))\n \t    break;\n \t  if (which_pass != PASS_LIB)\n-\t    fatal_error (\"fini function found in object %s\", prog_name);\n+\t    fatal_error (input_location, \"fini function found in object %s\",\n+\t\t\t prog_name);\n #ifndef LD_FINI_SWITCH\n \t  add_to_list (&destructors, name);\n #endif\n@@ -2543,18 +2546,18 @@ scan_libraries (const char *prog_name)\n \n   pex = pex_init (PEX_USE_PIPES, \"collect2\", NULL);\n   if (pex == NULL)\n-    fatal_error (\"pex_init failed: %m\");\n+    fatal_error (input_location, \"pex_init failed: %m\");\n \n   errmsg = pex_run (pex, 0, ldd_file_name, real_ldd_argv, NULL, NULL, &err);\n   if (errmsg != NULL)\n     {\n       if (err != 0)\n \t{\n \t  errno = err;\n-\t  fatal_error (\"%s: %m\", _(errmsg));\n+\t  fatal_error (input_location, \"%s: %m\", _(errmsg));\n \t}\n       else\n-\tfatal_error (errmsg);\n+\tfatal_error (input_location, errmsg);\n     }\n \n   int_handler  = (void (*) (int)) signal (SIGINT,  SIG_IGN);\n@@ -2564,7 +2567,7 @@ scan_libraries (const char *prog_name)\n \n   inf = pex_read_output (pex, 0);\n   if (inf == NULL)\n-    fatal_error (\"can't open ldd output: %m\");\n+    fatal_error (input_location, \"can't open ldd output: %m\");\n \n   if (debug)\n     notice (\"\\nldd output with constructors/destructors.\\n\");\n@@ -2582,7 +2585,7 @@ scan_libraries (const char *prog_name)\n \n       name = p;\n       if (strncmp (name, \"not found\", sizeof (\"not found\") - 1) == 0)\n-\tfatal_error (\"dynamic dependency %s not found\", buf);\n+\tfatal_error (input_location, \"dynamic dependency %s not found\", buf);\n \n       /* Find the end of the symbol name.  */\n       for (end = p;\n@@ -2594,7 +2597,8 @@ scan_libraries (const char *prog_name)\n       if (access (name, R_OK) == 0)\n \tadd_to_list (&libraries, name);\n       else\n-\tfatal_error (\"unable to open dynamic dependency '%s'\", buf);\n+\tfatal_error (input_location, \"unable to open dynamic dependency '%s'\",\n+\t\t     buf);\n \n       if (debug)\n \tfprintf (stderr, \"\\t%s\\n\", buf);\n@@ -2757,7 +2761,7 @@ scan_prog_file (const char *prog_name, scanpass which_pass,\n       if ((ldptr = ldopen (CONST_CAST (char *, prog_name), ldptr)) != NULL)\n \t{\n \t  if (! MY_ISCOFF (HEADER (ldptr).f_magic))\n-\t    fatal_error (\"%s: not a COFF file\", prog_name);\n+\t    fatal_error (input_location, \"%s: not a COFF file\", prog_name);\n \n \t  if (GCC_CHECK_HDR (ldptr))\n \t    {\n@@ -2906,7 +2910,8 @@ scan_prog_file (const char *prog_name, scanpass which_pass,\n \t}\n       else\n \t{\n-\t  fatal_error (\"%s: cannot open as COFF file\", prog_name);\n+\t  fatal_error (input_location, \"%s: cannot open as COFF file\",\n+\t\t       prog_name);\n \t}\n #ifdef COLLECT_EXPORT_LIST\n       /* On AIX loop continues while there are more members in archive.  */\n@@ -2964,7 +2969,7 @@ resolve_lib_name (const char *name)\n   if (debug)\n     fprintf (stderr, \"not found\\n\");\n   else\n-    fatal_error (\"library lib%s not found\", name);\n+    fatal_error (input_location, \"library lib%s not found\", name);\n   return (NULL);\n }\n #endif /* COLLECT_EXPORT_LIST */"}, {"sha": "74089e8f413c2bfb51d877b133da673ec1344923", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -5492,7 +5492,8 @@ check_if_valid_sleep_operand (rtx *operands, int opno)\n \tif( UNSIGNED_INT6 (INTVAL (operands[opno])))\n \t    return true;\n     default:\n-\tfatal_error(\"operand for sleep instruction must be an unsigned 6 bit compile-time constant\");\n+\tfatal_error (input_location,\n+\t\t     \"operand for sleep instruction must be an unsigned 6 bit compile-time constant\");\n \tbreak;\n     }\n   return false;\n@@ -6044,7 +6045,7 @@ arc_reorg (void)\n       cfun->machine->ccfsm_current_insn = NULL_RTX;\n \n       if (!INSN_ADDRESSES_SET_P())\n-\t  fatal_error (\"Insn addresses not set after shorten_branches\");\n+\t  fatal_error (input_location, \"Insn addresses not set after shorten_branches\");\n \n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \t{\n@@ -6248,7 +6249,7 @@ arc_reorg (void)\n     } while (changed);\n \n   if (INSN_ADDRESSES_SET_P())\n-    fatal_error (\"insn addresses not freed\");\n+    fatal_error (input_location, \"insn addresses not freed\");\n \n   arc_reorg_in_progress = 0;\n }"}, {"sha": "d66441f326b150dbdd3c028e1a72f9a413ac30f3", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -4292,7 +4292,8 @@\n \n   /* Keep this message in sync with the one in arc.c:arc_expand_builtin,\n      because *.md files do not get scanned by exgettext.  */\n-  fatal_error (\\\"operand to trap_s should be an unsigned 6-bit value\\\");\n+  fatal_error (input_location,\n+\t       \\\"operand to trap_s should be an unsigned 6-bit value\\\");\n }\n   [(set_attr \"length\" \"2\")\n   (set_attr \"type\" \"misc\")])"}, {"sha": "f69ba38616b6485e929ba5bec7d65b5c0a860460", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -381,7 +381,7 @@ avr_option_override (void)\n   for (avr_current_device = avr_mcu_types; ; avr_current_device++)\n     {\n       if (!avr_current_device->name)\n-        fatal_error (\"mcu not found\");\n+        fatal_error (input_location, \"mcu not found\");\n       if (!avr_current_device->macro\n           && avr_current_device->arch == avr_arch_index)\n         break;"}, {"sha": "58a7ac63a8983e687dd0c1773c4811f7b151e64b", "filename": "gcc/config/c6x/c6x.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Fc6x%2Fc6x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Fc6x%2Fc6x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.h?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -359,7 +359,8 @@ struct c6x_args {\n #define DEFAULT_PCC_STRUCT_RETURN 0\n \n #define FUNCTION_PROFILER(file, labelno) \\\n-  fatal_error (\"profiling is not yet implemented for this architecture\")\n+  fatal_error (input_location, \\\n+\t       \"profiling is not yet implemented for this architecture\")\n \n \n /* Trampolines.  */"}, {"sha": "40804b8d11af6bd124ed884e595bed3781795515", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -1949,7 +1949,8 @@ darwin_asm_lto_start (void)\n     lto_asm_out_name = make_temp_file (\".lto.s\");\n   lto_asm_out_file = fopen (lto_asm_out_name, \"a\");\n   if (lto_asm_out_file == NULL)\n-    fatal_error (\"failed to open temporary file %s for LTO output\",\n+    fatal_error (input_location,\n+\t\t \"failed to open temporary file %s for LTO output\",\n \t\t lto_asm_out_name);\n   asm_out_file = lto_asm_out_file;\n }\n@@ -2942,7 +2943,8 @@ darwin_file_end (void)\n \n       lto_asm_out_file = fopen (lto_asm_out_name, \"r\");\n       if (lto_asm_out_file == NULL)\n-\tfatal_error (\"failed to open temporary file %s with LTO output\",\n+\tfatal_error (input_location,\n+\t\t     \"failed to open temporary file %s with LTO output\",\n \t\t     lto_asm_out_name);\n       fseek (lto_asm_out_file, 0, SEEK_END);\n       n = ftell (lto_asm_out_file);"}, {"sha": "0919867526f85c84660ebb1f7927a063cf9befe8", "filename": "gcc/config/host-darwin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Fhost-darwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Fhost-darwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fhost-darwin.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -58,7 +58,7 @@ darwin_gt_pch_use_address (void *addr, size_t sz, int fd, size_t off)\n   sz = (sz + pagesize - 1) / pagesize * pagesize;\n \n   if (munmap (pch_address_space + sz, sizeof (pch_address_space) - sz) != 0)\n-    fatal_error (\"couldn%'t unmap pch_address_space: %m\");\n+    fatal_error (input_location, \"couldn%'t unmap pch_address_space: %m\");\n \n   if (ret)\n     {"}, {"sha": "71ce41bb5a3c934fda63d63c900565f4b647aefb", "filename": "gcc/config/i386/host-cygwin.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Fi386%2Fhost-cygwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Fi386%2Fhost-cygwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fhost-cygwin.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -52,14 +52,14 @@ cygwin_gt_pch_get_address (size_t sz, int fd)\n   off_t p = lseek(fd, 0, SEEK_CUR);\n \n   if (p == (off_t) -1)\n-    fatal_error (\"can%'t get position in PCH file: %m\");\n+    fatal_error (input_location, \"can%'t get position in PCH file: %m\");\n \n    /* Cygwin requires that the underlying file be at least\n       as large as the requested mapping.  */\n   if ((size_t) p < sz)\n   { \n     if ( ftruncate (fd, sz) == -1 )\n-      fatal_error (\"can%'t extend PCH file: %m\");\n+      fatal_error (input_location, \"can%'t extend PCH file: %m\");\n   }\n \n   base = mmap (NULL, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);\n@@ -70,7 +70,7 @@ cygwin_gt_pch_get_address (size_t sz, int fd)\n     munmap (base, sz);\n \n   if (lseek (fd, p, SEEK_SET) == (off_t) -1 )\n-    fatal_error (\"can%'t set position in PCH file: %m\");\n+    fatal_error (input_location, \"can%'t set position in PCH file: %m\");\n \n   return base;\n }"}, {"sha": "e6394e9a549e2144df6f0a545116843ee0bb6a4b", "filename": "gcc/config/i386/intelmic-mkoffload.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Fi386%2Fintelmic-mkoffload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Fi386%2Fintelmic-mkoffload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fintelmic-mkoffload.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -227,7 +227,7 @@ generate_target_descr_file (const char *target_compiler)\n   FILE *src_file = fopen (src_filename, \"w\");\n \n   if (!src_file)\n-    fatal_error (\"cannot open '%s'\", src_filename);\n+    fatal_error (input_location, \"cannot open '%s'\", src_filename);\n \n   fprintf (src_file,\n \t   \"extern void *__offload_funcs_end[];\\n\"\n@@ -287,7 +287,7 @@ generate_target_offloadend_file (const char *target_compiler)\n   FILE *src_file = fopen (src_filename, \"w\");\n \n   if (!src_file)\n-    fatal_error (\"cannot open '%s'\", src_filename);\n+    fatal_error (input_location, \"cannot open '%s'\", src_filename);\n \n   fprintf (src_file,\n \t   \"void *__offload_funcs_end[0]\\n\"\n@@ -324,7 +324,7 @@ generate_host_descr_file (const char *host_compiler)\n   FILE *src_file = fopen (src_filename, \"w\");\n \n   if (!src_file)\n-    fatal_error (\"cannot open '%s'\", src_filename);\n+    fatal_error (input_location, \"cannot open '%s'\", src_filename);\n \n   fprintf (src_file,\n \t   \"extern void *__OFFLOAD_TABLE__;\\n\"\n@@ -401,7 +401,7 @@ prepare_target_image (const char *target_compiler, int argc, char **argv)\n \tobstack_ptr_grow (&argv_obstack, argv[i]);\n     }\n   if (!out_obj_filename)\n-    fatal_error (\"output file not specified\");\n+    fatal_error (input_location, \"output file not specified\");\n   obstack_ptr_grow (&argv_obstack, opt2);\n   obstack_ptr_grow (&argv_obstack, \"-o\");\n   obstack_ptr_grow (&argv_obstack, target_so_filename);\n@@ -477,17 +477,18 @@ main (int argc, char **argv)\n   diagnostic_initialize (global_dc, 0);\n \n   if (atexit (mkoffload_atexit) != 0)\n-    fatal_error (\"atexit failed\");\n+    fatal_error (input_location, \"atexit failed\");\n \n   const char *host_compiler = getenv (\"COLLECT_GCC\");\n   if (!host_compiler)\n-    fatal_error (\"COLLECT_GCC must be set\");\n+    fatal_error (input_location, \"COLLECT_GCC must be set\");\n \n   const char *target_driver_name\n     = DEFAULT_REAL_TARGET_MACHINE \"-accel-\" DEFAULT_TARGET_MACHINE \"-gcc\";\n   char *target_compiler = find_target_compiler (target_driver_name);\n   if (target_compiler == NULL)\n-    fatal_error (\"offload compiler %s not found\", target_driver_name);\n+    fatal_error (input_location, \"offload compiler %s not found\",\n+\t\t target_driver_name);\n \n   /* We may be called with all the arguments stored in some file and\n      passed with @file.  Expand them into argv before processing.  */\n@@ -500,7 +501,8 @@ main (int argc, char **argv)\n \tif (strstr (argv[i], \"ilp32\"))\n \t  target_ilp32 = true;\n \telse if (!strstr (argv[i], \"lp64\"))\n-\t  fatal_error (\"unrecognizable argument of option -foffload-abi\");\n+\t  fatal_error (input_location,\n+\t\t       \"unrecognizable argument of option -foffload-abi\");\n \tbreak;\n       }\n "}, {"sha": "df33077947c00b6bb687cca62585c8f8b349dc66", "filename": "gcc/config/nios2/nios2.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Fnios2%2Fnios2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Fnios2%2Fnios2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnios2%2Fnios2.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -885,7 +885,8 @@ nios2_custom_check_insns (void)\n \t\t \"-fno-math-errno is specified\", N2FPU_NAME (i));\n \n   if (errors || custom_code_conflict)\n-    fatal_error (\"conflicting use of -mcustom switches, target attributes, \"\n+    fatal_error (input_location,\n+\t\t \"conflicting use of -mcustom switches, target attributes, \"\n \t\t \"and/or __builtin_custom_ functions\");\n }\n \n@@ -2562,7 +2563,8 @@ nios2_expand_fpu_builtin (tree exp, unsigned int code, rtx target)\n   bool has_target_p = (dst_mode != VOIDmode);\n \n   if (N2FPU_N (code) < 0)\n-    fatal_error (\"Cannot call %<__builtin_custom_%s%> without specifying switch\"\n+    fatal_error (input_location,\n+\t\t \"Cannot call %<__builtin_custom_%s%> without specifying switch\"\n \t\t \" %<-mcustom-%s%>\", N2FPU_NAME (code), N2FPU_NAME (code));\n   if (has_target_p)\n     create_output_operand (&ops[opno++], target, dst_mode);"}, {"sha": "38ccdba5de612ffd51de4cf187b5f7c0e5ba12ac", "filename": "gcc/config/nvptx/mkoffload.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Fnvptx%2Fmkoffload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Fnvptx%2Fmkoffload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fmkoffload.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -136,7 +136,7 @@ maybe_unlink (const char *file)\n     {\n       if (unlink_if_ordinary (file)\n \t  && errno != ENOENT)\n-\tfatal_error (\"deleting file %s: %m\", file);\n+\tfatal_error (input_location, \"deleting file %s: %m\", file);\n     }\n   else\n     fprintf (stderr, \"[Leaving %s]\\n\", file);\n@@ -163,7 +163,7 @@ record_id (const char *p1, id_map ***where)\n {\n   const char *end = strchr (p1, '\\n');\n   if (!end)\n-    fatal_error (\"malformed ptx file\");\n+    fatal_error (input_location, \"malformed ptx file\");\n \n   id_map *v = XNEW (id_map);\n   size_t len = end - p1;\n@@ -803,7 +803,8 @@ compile_native (const char *infile, const char *outfile, const char *compiler)\n {\n   const char *collect_gcc_options = getenv (\"COLLECT_GCC_OPTIONS\");\n   if (!collect_gcc_options)\n-    fatal_error (\"environment variable COLLECT_GCC_OPTIONS must be set\");\n+    fatal_error (input_location,\n+\t\t \"environment variable COLLECT_GCC_OPTIONS must be set\");\n \n   struct obstack argv_obstack;\n   obstack_init (&argv_obstack);\n@@ -828,7 +829,7 @@ main (int argc, char **argv)\n \n   char *collect_gcc = getenv (\"COLLECT_GCC\");\n   if (collect_gcc == NULL)\n-    fatal_error (\"COLLECT_GCC must be set.\");\n+    fatal_error (input_location, \"COLLECT_GCC must be set.\");\n   const char *gcc_path = dirname (ASTRDUP (collect_gcc));\n   const char *gcc_exec = basename (ASTRDUP (collect_gcc));\n \n@@ -888,13 +889,13 @@ main (int argc, char **argv)\n \n   in = fopen (ptx_name, \"r\");\n   if (!in)\n-    fatal_error (\"cannot open intermediate ptx file\");\n+    fatal_error (input_location, \"cannot open intermediate ptx file\");\n \n   ptx_cfile_name = make_temp_file (\".c\");\n \n   out = fopen (ptx_cfile_name, \"w\");\n   if (!out)\n-    fatal_error (\"cannot open '%s'\", ptx_cfile_name);\n+    fatal_error (input_location, \"cannot open '%s'\", ptx_cfile_name);\n \n   process (in, out);\n   fclose (out);"}, {"sha": "9a9954bfed8adb617d86d75090d11916065361ac", "filename": "gcc/config/nvptx/nvptx.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Fnvptx%2Fnvptx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.h?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -185,7 +185,8 @@ struct nvptx_args {\n #define DEFAULT_PCC_STRUCT_RETURN 0\n \n #define FUNCTION_PROFILER(file, labelno) \\\n-  fatal_error (\"profiling is not yet implemented for this architecture\")\n+  fatal_error (input_location, \\\n+\t       \"profiling is not yet implemented for this architecture\")\n \n #define TRAMPOLINE_SIZE 32\n #define TRAMPOLINE_ALIGNMENT 256"}, {"sha": "6361f5c23d772c37d1a323c74ca3554879bfcfe4", "filename": "gcc/config/rs6000/host-darwin.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Frs6000%2Fhost-darwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Frs6000%2Fhost-darwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fhost-darwin.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -140,13 +140,13 @@ darwin_rs6000_extra_signals (void)\n   sigstk.ss_size = SIGSTKSZ;\n   sigstk.ss_flags = 0;\n   if (sigaltstack (&sigstk, NULL) < 0)\n-    fatal_error (\"While setting up signal stack: %m\");\n+    fatal_error (input_location, \"While setting up signal stack: %m\");\n \n   sigemptyset(&sact.sa_mask);\n   sact.sa_flags = SA_ONSTACK | SA_SIGINFO;\n   sact.sa_sigaction = segv_handler;\n   if (sigaction (SIGSEGV, &sact, 0) < 0) \n-    fatal_error (\"While setting up signal handler: %m\");\n+    fatal_error (input_location, \"While setting up signal handler: %m\");\n }\n \f\n "}, {"sha": "9bccf727fd22d1391edad4c2fc038801ef99bbce", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -11570,7 +11570,8 @@ def_builtin (const char *name, tree type, enum rs6000_builtins code)\n   gcc_assert (IN_RANGE ((int)code, 0, (int)RS6000_BUILTIN_COUNT));\n \n   if (rs6000_builtin_decls[(int)code])\n-    fatal_error (\"internal error: builtin function %s already processed\", name);\n+    fatal_error (input_location,\n+\t\t \"internal error: builtin function %s already processed\", name);\n \n   rs6000_builtin_decls[(int)code] = t =\n     add_builtin_function (name, type, (int)code, BUILT_IN_MD, NULL, NULL_TREE);\n@@ -15468,14 +15469,16 @@ builtin_function_type (machine_mode mode_ret, machine_mode mode_arg0,\n     num_args--;\n \n   if (num_args == 0)\n-    fatal_error (\"internal error: builtin function %s had no type\", name);\n+    fatal_error (input_location,\n+\t\t \"internal error: builtin function %s had no type\", name);\n \n   ret_type = builtin_mode_to_type[h.mode[0]][h.uns_p[0]];\n   if (!ret_type && h.uns_p[0])\n     ret_type = builtin_mode_to_type[h.mode[0]][0];\n \n   if (!ret_type)\n-    fatal_error (\"internal error: builtin function %s had an unexpected \"\n+    fatal_error (input_location,\n+\t\t \"internal error: builtin function %s had an unexpected \"\n \t\t \"return type %s\", name, GET_MODE_NAME (h.mode[0]));\n \n   for (i = 0; i < (int) ARRAY_SIZE (arg_type); i++)\n@@ -15491,7 +15494,8 @@ builtin_function_type (machine_mode mode_ret, machine_mode mode_arg0,\n \targ_type[i] = builtin_mode_to_type[m][0];\n \n       if (!arg_type[i])\n-\tfatal_error (\"internal error: builtin function %s, argument %d \"\n+\tfatal_error (input_location,\n+\t\t     \"internal error: builtin function %s, argument %d \"\n \t\t     \"had unexpected argument type %s\", name, i,\n \t\t     GET_MODE_NAME (m));\n     }"}, {"sha": "bc6223ecb4b94bae173079e96d268d38bb48ddbe", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -7810,7 +7810,8 @@ s390_frame_info (void)\n \n   cfun_frame_layout.frame_size = get_frame_size ();\n   if (!TARGET_64BIT && cfun_frame_layout.frame_size > 0x7fff0000)\n-    fatal_error (\"total size of local variables exceeds architecture limit\");\n+    fatal_error (input_location,\n+\t\t \"total size of local variables exceeds architecture limit\");\n \n   if (!TARGET_PACKED_STACK)\n     {"}, {"sha": "6cbb3f3730f157c95d5628bce6b0d2bad4a43bec", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -1,3 +1,8 @@\n+2015-01-30  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* class.c, except.c, parser.c, pt.c: All callers of fatal_error\n+\tchanged to pass input_location as first argument.\n+\n 2015-01-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/64717"}, {"sha": "8612163711cf3e0708c702eb4f4c7a1e851c38b6", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -6792,7 +6792,8 @@ finish_struct (tree t, tree attributes)\n \t    }\n \t}\n       if (!ok)\n-\tfatal_error (\"definition of std::initializer_list does not match \"\n+\tfatal_error (input_location,\n+\t\t     \"definition of std::initializer_list does not match \"\n \t\t     \"#include <initializer_list>\");\n     }\n "}, {"sha": "6aff7b594391431382c332058f350516211ed2f2", "filename": "gcc/cp/except.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -304,7 +304,8 @@ decl_is_java_type (tree decl, int err)\n \n \t  if (jthrow_node == NULL_TREE)\n \t    fatal_error\n-\t      (\"call to Java %<catch%> or %<throw%> with %<jthrowable%> undefined\");\n+\t      (input_location,\n+\t       \"call to Java %<catch%> or %<throw%> with %<jthrowable%> undefined\");\n \n \t  jthrow_node = TREE_TYPE (TREE_TYPE (jthrow_node));\n "}, {"sha": "7168aba358cfc62ec9e172305e2154bcf0d6691e", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -33165,7 +33165,8 @@ c_parse_file (void)\n   static bool already_called = false;\n \n   if (already_called)\n-    fatal_error (\"inter-module optimizations not implemented for C++\");\n+    fatal_error (input_location,\n+\t\t \"inter-module optimizations not implemented for C++\");\n   already_called = true;\n \n   the_parser = cp_parser_new ();"}, {"sha": "3317dad35d79d6cfba5fb90df6f5cc7fa895252c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -8482,7 +8482,8 @@ push_tinst_level_loc (tree d, location_t loc)\n \n   if (tinst_depth >= max_tinst_depth)\n     {\n-      fatal_error (\"template instantiation depth exceeds maximum of %d\"\n+      fatal_error (input_location,\n+\t\t   \"template instantiation depth exceeds maximum of %d\"\n                    \" (use -ftemplate-depth= to increase the maximum)\",\n                    max_tinst_depth);\n       return false;\n@@ -20455,7 +20456,8 @@ instantiate_pending_templates (int retries)\n     {\n       tree decl = pending_templates->tinst->decl;\n \n-      fatal_error (\"template instantiation depth exceeds maximum of %d\"\n+      fatal_error (input_location,\n+\t\t   \"template instantiation depth exceeds maximum of %d\"\n                    \" instantiating %q+D, possibly from virtual table generation\"\n                    \" (use -ftemplate-depth= to increase the maximum)\",\n                    max_tinst_depth, decl);"}, {"sha": "09a6867c28a06d91b551c51bfe5a76afce5fd7d1", "filename": "gcc/diagnostic-core.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fdiagnostic-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fdiagnostic-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-core.h?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -68,8 +68,6 @@ extern void error (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2);\n extern void error_n (location_t, int, const char *, const char *, ...)\n     ATTRIBUTE_GCC_DIAG(3,5) ATTRIBUTE_GCC_DIAG(4,5);\n extern void error_at (location_t, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3);\n-extern void fatal_error (const char *, ...) ATTRIBUTE_GCC_DIAG(1,2)\n-     ATTRIBUTE_NORETURN;\n extern void fatal_error (location_t, const char *, ...) ATTRIBUTE_GCC_DIAG(2,3)\n      ATTRIBUTE_NORETURN;\n /* Pass one of the OPT_W* from options.h as the second parameter.  */"}, {"sha": "2196406f8814f6ff950c41c2610e0445a44a8e00", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -1191,23 +1191,6 @@ seen_error (void)\n   return errorcount || sorrycount;\n }\n \n-/* An error which is severe enough that we make no attempt to\n-   continue.  Do not use this for internal consistency checks; that's\n-   internal_error.  Use of this function should be rare.  */\n-void\n-fatal_error (const char *gmsgid, ...)\n-{\n-  diagnostic_info diagnostic;\n-  va_list ap;\n-\n-  va_start (ap, gmsgid);\n-  diagnostic_set_info (&diagnostic, gmsgid, &ap, input_location, DK_FATAL);\n-  report_diagnostic (&diagnostic);\n-  va_end (ap);\n-\n-  gcc_unreachable ();\n-}\n-\n /* An error which is severe enough that we make no attempt to\n    continue.  Do not use this for internal consistency checks; that's\n    internal_error.  Use of this function should be rare.  */"}, {"sha": "01462d2e312e2d0a27940cb6c290fdf858ce3d38", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -1,3 +1,9 @@\n+2015-01-30  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* f95-lang.c, gfortranspec.c, trans-const.c, trans-expr.c: All\n+\tcallers of fatal_error changed to pass input_location as first\n+\targument.\n+\n 2015-01-28  Tobias Burnus  <burnus@net-b.de>\n \n \t* intrinsic.texi (CO_BROADCAST): Correct argument description."}, {"sha": "94f7479a22f0417c1a2c1b8dc2a6c260f08026f9", "filename": "gcc/fortran/f95-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -265,7 +265,7 @@ gfc_init (void)\n   gfc_init_1 ();\n \n   if (!gfc_new_file ())\n-    fatal_error (\"can't open input file: %s\", gfc_source_file);\n+    fatal_error (input_location, \"can't open input file: %s\", gfc_source_file);\n \n   if (flag_preprocess_only)\n     return false;"}, {"sha": "8af4c768035c5e7dc3b6ede846576723eed10aa7", "filename": "gcc/fortran/gfortranspec.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Ffortran%2Fgfortranspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Ffortran%2Fgfortranspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortranspec.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -142,7 +142,7 @@ append_arg (const struct cl_decoded_option *arg)\n     }\n \n   if (g77_newargc == newargsize)\n-    fatal_error (\"overflowed output arg list for %qs\",\n+    fatal_error (input_location, \"overflowed output arg list for %qs\",\n \t\t arg->orig_option_with_args_text);\n \n   g77_new_decoded_options[g77_newargc++] = *arg;\n@@ -296,7 +296,8 @@ For more information about these matters, see the file named COPYING\\n\\n\"));\n     }\n \n   if ((n_outfiles != 0) && (n_infiles == 0))\n-    fatal_error (\"no input files; unwilling to write output files\");\n+    fatal_error (input_location,\n+\t\t \"no input files; unwilling to write output files\");\n \n   /* If there are no input files, no need for the library.  */\n   if (n_infiles == 0)"}, {"sha": "eb447a5d761314a09715c9fa552685c94cba9d38", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -368,7 +368,8 @@ gfc_conv_constant_to_tree (gfc_expr * expr)\n \t\t\t\t     expr->representation.string);\n \n     default:\n-      fatal_error (\"gfc_conv_constant_to_tree(): invalid type: %s\",\n+      fatal_error (input_location,\n+\t\t   \"gfc_conv_constant_to_tree(): invalid type: %s\",\n \t\t   gfc_typename (&expr->ts));\n     }\n }"}, {"sha": "70da287dae47f721a4863815715460a9f798defd", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -2859,7 +2859,7 @@ gfc_conv_expr_op (gfc_se * se, gfc_expr * expr)\n       gcc_unreachable ();\n \n     default:\n-      fatal_error (\"Unknown intrinsic op\");\n+      fatal_error (input_location, \"Unknown intrinsic op\");\n       return;\n     }\n "}, {"sha": "186f0aef91b9d7a58f5a793f564cf085cde7eddd", "filename": "gcc/gcc.c", "status": "modified", "additions": 91, "deletions": 61, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -1896,7 +1896,8 @@ read_specs (const char *filename, bool main_p, bool user_p)\n \t\tp1++;\n \n \t      if (*p1++ != '<' || p[-2] != '>')\n-\t\tfatal_error (\"specs %%include syntax malformed after \"\n+\t\tfatal_error (input_location,\n+\t\t\t     \"specs %%include syntax malformed after \"\n \t\t\t     \"%ld characters\",\n \t\t\t     (long) (p1 - buffer + 1));\n \n@@ -1916,7 +1917,8 @@ read_specs (const char *filename, bool main_p, bool user_p)\n \t\tp1++;\n \n \t      if (*p1++ != '<' || p[-2] != '>')\n-\t\tfatal_error (\"specs %%include syntax malformed after \"\n+\t\tfatal_error (input_location,\n+\t\t\t     \"specs %%include syntax malformed after \"\n \t\t\t     \"%ld characters\",\n \t\t\t     (long) (p1 - buffer + 1));\n \n@@ -1942,7 +1944,8 @@ read_specs (const char *filename, bool main_p, bool user_p)\n \t\tp1++;\n \n \t      if (! ISALPHA ((unsigned char) *p1))\n-\t\tfatal_error (\"specs %%rename syntax malformed after \"\n+\t\tfatal_error (input_location,\n+\t\t\t     \"specs %%rename syntax malformed after \"\n \t\t\t     \"%ld characters\",\n \t\t\t     (long) (p1 - buffer));\n \n@@ -1951,7 +1954,8 @@ read_specs (const char *filename, bool main_p, bool user_p)\n \t\tp2++;\n \n \t      if (*p2 != ' ' && *p2 != '\\t')\n-\t\tfatal_error (\"specs %%rename syntax malformed after \"\n+\t\tfatal_error (input_location,\n+\t\t\t     \"specs %%rename syntax malformed after \"\n \t\t\t     \"%ld characters\",\n \t\t\t     (long) (p2 - buffer));\n \n@@ -1961,7 +1965,8 @@ read_specs (const char *filename, bool main_p, bool user_p)\n \t\tp2++;\n \n \t      if (! ISALPHA ((unsigned char) *p2))\n-\t\tfatal_error (\"specs %%rename syntax malformed after \"\n+\t\tfatal_error (input_location,\n+\t\t\t     \"specs %%rename syntax malformed after \"\n \t\t\t     \"%ld characters\",\n \t\t\t     (long) (p2 - buffer));\n \n@@ -1971,7 +1976,8 @@ read_specs (const char *filename, bool main_p, bool user_p)\n \t\tp3++;\n \n \t      if (p3 != p - 1)\n-\t\tfatal_error (\"specs %%rename syntax malformed after \"\n+\t\tfatal_error (input_location,\n+\t\t\t     \"specs %%rename syntax malformed after \"\n \t\t\t     \"%ld characters\",\n \t\t\t     (long) (p3 - buffer));\n \t      *p3 = '\\0';\n@@ -1981,14 +1987,16 @@ read_specs (const char *filename, bool main_p, bool user_p)\n \t\t  break;\n \n \t      if (!sl)\n-\t\tfatal_error (\"specs %s spec was not found to be renamed\", p1);\n+\t\tfatal_error (input_location,\n+\t\t\t     \"specs %s spec was not found to be renamed\", p1);\n \n \t      if (strcmp (p1, p2) == 0)\n \t\tcontinue;\n \n \t      for (newsl = specs; newsl; newsl = newsl->next)\n \t\tif (strcmp (newsl->name, p2) == 0)\n-\t\t  fatal_error (\"%s: attempt to rename spec %qs to \"\n+\t\t  fatal_error (input_location,\n+\t\t\t       \"%s: attempt to rename spec %qs to \"\n \t\t\t       \"already defined spec %qs\",\n \t\t    filename, p1, p2);\n \n@@ -2009,7 +2017,8 @@ read_specs (const char *filename, bool main_p, bool user_p)\n \t      continue;\n \t    }\n \t  else\n-\t    fatal_error (\"specs unknown %% command after %ld characters\",\n+\t    fatal_error (input_location,\n+\t\t\t \"specs unknown %% command after %ld characters\",\n \t\t\t (long) (p1 - buffer));\n \t}\n \n@@ -2020,7 +2029,8 @@ read_specs (const char *filename, bool main_p, bool user_p)\n \n       /* The colon shouldn't be missing.  */\n       if (*p1 != ':')\n-\tfatal_error (\"specs file malformed after %ld characters\",\n+\tfatal_error (input_location,\n+\t\t     \"specs file malformed after %ld characters\",\n \t\t     (long) (p1 - buffer));\n \n       /* Skip back over trailing whitespace.  */\n@@ -2033,7 +2043,8 @@ read_specs (const char *filename, bool main_p, bool user_p)\n       /* Find the next line.  */\n       p = skip_whitespace (p1 + 1);\n       if (p[1] == 0)\n-\tfatal_error (\"specs file malformed after %ld characters\",\n+\tfatal_error (input_location,\n+\t\t     \"specs file malformed after %ld characters\",\n \t\t     (long) (p - buffer));\n \n       p1 = p;\n@@ -2085,7 +2096,7 @@ read_specs (const char *filename, bool main_p, bool user_p)\n     }\n \n   if (link_command_spec == 0)\n-    fatal_error (\"spec file has no spec for linking\");\n+    fatal_error (input_location, \"spec file has no spec for linking\");\n }\n \f\n /* Record the names of temporary files we tell compilers to write,\n@@ -2630,7 +2641,7 @@ add_sysrooted_prefix (struct path_prefix *pprefix, const char *prefix,\n \t\t      int require_machine_suffix, int os_multilib)\n {\n   if (!IS_ABSOLUTE_PATH (prefix))\n-    fatal_error (\"system path %qs is not absolute\", prefix);\n+    fatal_error (input_location, \"system path %qs is not absolute\", prefix);\n \n   if (target_system_root)\n     {\n@@ -2718,7 +2729,7 @@ execute (void)\n     if (arg && strcmp (arg, \"|\") == 0)\n       {\t\t\t\t/* each command.  */\n #if defined (__MSDOS__) || defined (OS2) || defined (VMS)\n-\tfatal_error (\"-pipe not supported\");\n+\tfatal_error (input_location, \"-pipe not supported\");\n #endif\n \targbuf[i] = 0; /* Termination of\n \t\t\t\t\t\t     command args.  */\n@@ -2841,7 +2852,7 @@ execute (void)\n \t\t\t\t   ? PEX_RECORD_TIMES : 0),\n \t\t  progname, temp_filename);\n   if (pex == NULL)\n-    fatal_error (\"pex_init failed: %m\");\n+    fatal_error (input_location, \"pex_init failed: %m\");\n \n   for (i = 0; i < n_commands; i++)\n     {\n@@ -2857,7 +2868,7 @@ execute (void)\n       if (errmsg != NULL)\n \t{\n \t  if (err == 0)\n-\t    fatal_error (errmsg);\n+\t    fatal_error (input_location, errmsg);\n \t  else\n \t    {\n \t      errno = err;\n@@ -2880,13 +2891,13 @@ execute (void)\n \n     statuses = (int *) alloca (n_commands * sizeof (int));\n     if (!pex_get_status (pex, n_commands, statuses))\n-      fatal_error (\"failed to get exit status: %m\");\n+      fatal_error (input_location, \"failed to get exit status: %m\");\n \n     if (report_times || report_times_to_file)\n       {\n \ttimes = (struct pex_time *) alloca (n_commands * sizeof (struct pex_time));\n \tif (!pex_get_times (pex, n_commands, times))\n-\t  fatal_error (\"failed to get process times: %m\");\n+\t  fatal_error (input_location, \"failed to get process times: %m\");\n       }\n \n     pex_free (pex);\n@@ -3420,7 +3431,8 @@ handle_foffload_option (const char *arg)\n \t}\n \n       if (!c)\n-\tfatal_error (\"GCC is not configured to support %s as offload target\",\n+\tfatal_error (input_location,\n+\t\t     \"GCC is not configured to support %s as offload target\",\n \t\t     target);\n \n       if (!offload_targets)\n@@ -3719,7 +3731,7 @@ driver_handle_option (struct gcc_options *opts,\n \t       || strcmp (arg, \"object\") == 0)\n \tsave_temps_flag = SAVE_TEMPS_OBJ;\n       else\n-\tfatal_error (\"%qs is an unknown -save-temps option\",\n+\tfatal_error (input_location, \"%qs is an unknown -save-temps option\",\n \t\t     decoded->orig_option_with_args_text);\n       break;\n \n@@ -4174,7 +4186,8 @@ process_command (unsigned int decoded_options_count,\n       for (i = 0; i < n_infiles; i++)\n \tif ((!infiles[i].language || infiles[i].language[0] != '*')\n \t    && canonical_filename_eq (infiles[i].name, output_file))\n-\t  fatal_error (\"input file %qs is the same as output file\",\n+\t  fatal_error (input_location,\n+\t\t       \"input file %qs is the same as output file\",\n \t\t       output_file);\n     }\n \n@@ -4655,10 +4668,12 @@ do_self_spec (const char *spec)\n \t      /* Specs should only generate options, not input\n \t\t files.  */\n \t      if (strcmp (decoded_options[j].arg, \"-\") != 0)\n-\t\tfatal_error (\"switch %qs does not start with %<-%>\",\n+\t\tfatal_error (input_location,\n+\t\t\t     \"switch %qs does not start with %<-%>\",\n \t\t\t     decoded_options[j].arg);\n \t      else\n-\t\tfatal_error (\"spec-generated switch is just %<-%>\");\n+\t\tfatal_error (input_location,\n+\t\t\t     \"spec-generated switch is just %<-%>\");\n \t      break;\n \n \t    case OPT_fcompare_debug_second:\n@@ -4749,19 +4764,20 @@ create_at_file (char **argv)\n   int status;\n \n   if (f == NULL)\n-    fatal_error (\"could not open temporary response file %s\",\n+    fatal_error (input_location, \"could not open temporary response file %s\",\n \t\t temp_file);\n \n   status = writeargv (argv, f);\n \n   if (status)\n-    fatal_error (\"could not write to temporary response file %s\",\n+    fatal_error (input_location,\n+\t\t \"could not write to temporary response file %s\",\n \t\t temp_file);\n \n   status = fclose (f);\n \n   if (EOF == status)\n-    fatal_error (\"could not close temporary response file %s\",\n+    fatal_error (input_location, \"could not close temporary response file %s\",\n \t\t temp_file);\n \n   store_arg (at_argument, 0, 0);\n@@ -4884,7 +4900,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \tswitch (c = *p++)\n \t  {\n \t  case 0:\n-\t    fatal_error (\"spec %qs invalid\", spec);\n+\t    fatal_error (input_location, \"spec %qs invalid\", spec);\n \n \t  case 'b':\n \t    if (save_temps_length)\n@@ -5033,7 +5049,8 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t\t    p += 2;\n \t\t    /* We don't support extra suffix characters after %O.  */\n \t\t    if (*p == '.' || ISALNUM ((unsigned char) *p))\n-\t\t      fatal_error (\"spec %qs has invalid %<%%0%c%>\", spec, *p);\n+\t\t      fatal_error (input_location,\n+\t\t\t\t   \"spec %qs has invalid %<%%0%c%>\", spec, *p);\n \t\t    if (suffix_length == 0)\n \t\t      suffix = TARGET_OBJECT_SUFFIX;\n \t\t    else\n@@ -5352,7 +5369,8 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t      unsigned int cur_index = argbuf.length ();\n \t      /* Handle the {...} following the %W.  */\n \t      if (*p != '{')\n-\t\tfatal_error (\"spec %qs has invalid %<%%W%c%>\", spec, *p);\n+\t\tfatal_error (input_location,\n+\t\t\t     \"spec %qs has invalid %<%%W%c%>\", spec, *p);\n \t      p = handle_braces (p + 1);\n \t      if (p == 0)\n \t\treturn -1;\n@@ -5374,7 +5392,8 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \n \t      /* Skip past the option value and make a copy.  */\n \t      if (*p != '{')\n-\t\tfatal_error (\"spec %qs has invalid %<%%x%c%>\", spec, *p);\n+\t\tfatal_error (input_location,\n+\t\t\t     \"spec %qs has invalid %<%%x%c%>\", spec, *p);\n \t      while (*p++ != '}')\n \t\t;\n \t      string = save_string (p1 + 1, p - p1 - 2);\n@@ -5690,7 +5709,7 @@ eval_spec_function (const char *func, const char *args)\n \n   sf = lookup_spec_function (func);\n   if (sf == NULL)\n-    fatal_error (\"unknown spec function %qs\", func);\n+    fatal_error (input_location, \"unknown spec function %qs\", func);\n \n   /* Push the spec processing context.  */\n   save_argbuf = argbuf;\n@@ -5720,7 +5739,7 @@ eval_spec_function (const char *func, const char *args)\n \n   alloc_args ();\n   if (do_spec_2 (args) < 0)\n-    fatal_error (\"error in args to spec function %qs\", func);\n+    fatal_error (input_location, \"error in args to spec function %qs\", func);\n \n   /* argbuf_index is an index for the next argument to be inserted, and\n      so contains the count of the args already inserted.  */\n@@ -5774,10 +5793,10 @@ handle_spec_function (const char *p, bool *retval_nonnull)\n         break;\n       /* Only allow [A-Za-z0-9], -, and _ in function names.  */\n       if (!ISALNUM (*endp) && !(*endp == '-' || *endp == '_'))\n-\tfatal_error (\"malformed spec function name\");\n+\tfatal_error (input_location, \"malformed spec function name\");\n     }\n   if (*endp != '(')\t\t/* ) */\n-    fatal_error (\"no arguments for spec function\");\n+    fatal_error (input_location, \"no arguments for spec function\");\n   func = save_string (p, endp - p);\n   p = ++endp;\n \n@@ -5796,7 +5815,7 @@ handle_spec_function (const char *p, bool *retval_nonnull)\n     }\n   /* ( */\n   if (*endp != ')')\n-    fatal_error (\"malformed spec function arguments\");\n+    fatal_error (input_location, \"malformed spec function arguments\");\n   args = save_string (p, endp - p);\n   p = ++endp;\n \n@@ -6070,7 +6089,7 @@ handle_braces (const char *p)\n   return p;\n \n  invalid:\n-  fatal_error (\"braced spec %qs is invalid at %qc\", orig, *p);\n+  fatal_error (input_location, \"braced spec %qs is invalid at %qc\", orig, *p);\n \n #undef SKIP_WHITE\n }\n@@ -6158,7 +6177,7 @@ process_brace_body (const char *p, const char *atom, const char *end_atom,\n   return p;\n \n  invalid:\n-  fatal_error (\"braced spec body %qs is invalid\", body);\n+  fatal_error (input_location, \"braced spec body %qs is invalid\", body);\n }\n \f\n /* Return 0 iff switch number SWITCHNUM is obsoleted by a later switch\n@@ -6454,15 +6473,15 @@ run_attempt (const char **new_argv, const char *out_temp,\n \n   pex = pex_init (PEX_USE_PIPES, new_argv[0], NULL);\n   if (!pex)\n-    fatal_error (\"pex_init failed: %m\");\n+    fatal_error (input_location, \"pex_init failed: %m\");\n \n   errmsg = pex_run (pex, pex_flags, new_argv[0],\n \t\t    CONST_CAST2 (char *const *, const char **, &new_argv[1]), out_temp,\n \t\t    err_temp, &err);\n   if (errmsg != NULL)\n     {\n       if (err == 0)\n-\tfatal_error (errmsg);\n+\tfatal_error (input_location, errmsg);\n       else\n \t{\n \t  errno = err;\n@@ -7003,7 +7022,7 @@ driver::global_initializations ()\n #endif\n \n   if (atexit (delete_temp_files) != 0)\n-    fatal_error (\"atexit failed\");\n+    fatal_error (input_location, \"atexit failed\");\n \n   if (signal (SIGINT, SIG_IGN) != SIG_IGN)\n     signal (SIGINT, fatal_signal);\n@@ -7527,7 +7546,8 @@ driver::maybe_print_and_exit () const\n       else\n \t/* The error status indicates that only one set of fixed\n \t   headers should be built.  */\n-\tfatal_error (\"not configured with sysroot headers suffix\");\n+\tfatal_error (input_location,\n+\t\t     \"not configured with sysroot headers suffix\");\n     }\n \n   if (print_help_list)\n@@ -7588,7 +7608,7 @@ driver::prepare_infiles ()\n   int lang_n_infiles = 0;\n \n   if (n_infiles == added_libraries)\n-    fatal_error (\"no input files\");\n+    fatal_error (input_location, \"no input files\");\n \n   if (seen_error ())\n     /* Early exit needed from main.  */\n@@ -7638,7 +7658,8 @@ driver::prepare_infiles ()\n     }\n \n   if (!combine_inputs && have_c && have_o && lang_n_infiles > 1)\n-    fatal_error (\"cannot specify -o with -c, -S or -E with multiple files\");\n+    fatal_error (input_location,\n+\t\t \"cannot specify -o with -c, -S or -E with multiple files\");\n \n   /* No early exit needed from main; we can continue.  */\n   return false;\n@@ -7844,7 +7865,8 @@ driver::maybe_run_linker (const char *argv0) const\n \t\t\t\t\t     LTOPLUGINSONAME, R_OK,\n \t\t\t\t\t     false);\n \t      if (!temp_spec)\n-\t\tfatal_error (\"-fuse-linker-plugin, but %s not found\",\n+\t\tfatal_error (input_location,\n+\t\t\t     \"-fuse-linker-plugin, but %s not found\",\n \t\t\t     LTOPLUGINSONAME);\n \t      linker_plugin_file_spec = convert_white_space (temp_spec);\n \t    }\n@@ -8156,7 +8178,7 @@ used_arg (const char *p, int len)\n \t      if (*q == '\\0')\n \t\t{\n \t\tinvalid_matches:\n-\t\t  fatal_error (\"multilib spec %qs is invalid\",\n+\t\t  fatal_error (input_location, \"multilib spec %qs is invalid\",\n \t\t\t       multilib_matches);\n \t\t}\n \t      q++;\n@@ -8350,7 +8372,7 @@ set_multilib_dir (void)\n \t  if (*p == '\\0')\n \t    {\n \t    invalid_exclusions:\n-\t      fatal_error (\"multilib exclusions %qs is invalid\",\n+\t      fatal_error (input_location, \"multilib exclusions %qs is invalid\",\n \t\t\t   multilib_exclusions);\n \t    }\n \n@@ -8414,7 +8436,7 @@ set_multilib_dir (void)\n \t  if (*p == '\\0')\n \t    {\n \t    invalid_select:\n-\t      fatal_error (\"multilib select %qs %qs is invalid\",\n+\t      fatal_error (input_location, \"multilib select %qs %qs is invalid\",\n \t\t\t   multilib_select, multilib_reuse);\n \t    }\n \t  ++p;\n@@ -8575,7 +8597,8 @@ print_multilib_info (void)\n \t  if (*p == '\\0')\n \t    {\n \t    invalid_select:\n-\t      fatal_error (\"multilib select %qs is invalid\", multilib_select);\n+\t      fatal_error (input_location,\n+\t\t\t   \"multilib select %qs is invalid\", multilib_select);\n \t    }\n \n \t  ++p;\n@@ -8614,7 +8637,8 @@ print_multilib_info (void)\n \t\tif (*e == '\\0')\n \t\t  {\n \t\t  invalid_exclusion:\n-\t\t    fatal_error (\"multilib exclusion %qs is invalid\",\n+\t\t    fatal_error (input_location,\n+\t\t\t\t \"multilib exclusion %qs is invalid\",\n \t\t\t\t multilib_exclusions);\n \t\t  }\n \n@@ -8820,7 +8844,8 @@ getenv_spec_function (int argc, const char **argv)\n \n   value = getenv (argv[0]);\n   if (!value)\n-    fatal_error (\"environment variable %qs not defined\", argv[0]);\n+    fatal_error (input_location,\n+\t\t \"environment variable %qs not defined\", argv[0]);\n \n   /* We have to escape every character of the environment variable so\n      they are not interpreted as active spec characters.  A\n@@ -8959,12 +8984,12 @@ compare_version_strings (const char *v1, const char *v2)\n     abort ();\n   rresult = regexec (&r, v1, 0, NULL, 0);\n   if (rresult == REG_NOMATCH)\n-    fatal_error (\"invalid version number %qs\", v1);\n+    fatal_error (input_location, \"invalid version number %qs\", v1);\n   else if (rresult != 0)\n     abort ();\n   rresult = regexec (&r, v2, 0, NULL, 0);\n   if (rresult == REG_NOMATCH)\n-    fatal_error (\"invalid version number %qs\", v2);\n+    fatal_error (input_location, \"invalid version number %qs\", v2);\n   else if (rresult != 0)\n     abort ();\n \n@@ -9007,13 +9032,13 @@ version_compare_spec_function (int argc, const char **argv)\n   bool result;\n \n   if (argc < 3)\n-    fatal_error (\"too few arguments to %%:version-compare\");\n+    fatal_error (input_location, \"too few arguments to %%:version-compare\");\n   if (argv[0][0] == '\\0')\n     abort ();\n   if ((argv[0][1] == '<' || argv[0][1] == '>') && argv[0][0] != '!')\n     nargs = 2;\n   if (argc != nargs + 3)\n-    fatal_error (\"too many arguments to %%:version-compare\");\n+    fatal_error (input_location, \"too many arguments to %%:version-compare\");\n \n   switch_len = strlen (argv[nargs + 1]);\n   for (i = 0; i < n_switches; i++)\n@@ -9054,7 +9079,8 @@ version_compare_spec_function (int argc, const char **argv)\n       break;\n \n     default:\n-      fatal_error (\"unknown operator %qs in %%:version-compare\", argv[0]);\n+      fatal_error (input_location,\n+\t\t   \"unknown operator %qs in %%:version-compare\", argv[0]);\n     }\n   if (! result)\n     return NULL;\n@@ -9177,7 +9203,8 @@ compare_debug_dump_opt_spec_function (int arg,\n   static char random_seed[HOST_BITS_PER_WIDE_INT / 4 + 3];\n \n   if (arg != 0)\n-    fatal_error (\"too many arguments to %%:compare-debug-dump-opt\");\n+    fatal_error (input_location,\n+\t\t \"too many arguments to %%:compare-debug-dump-opt\");\n \n   do_spec_2 (\"%{fdump-final-insns=*:%*}\");\n   do_spec_1 (\" \", 0, NULL);\n@@ -9249,7 +9276,8 @@ compare_debug_self_opt_spec_function (int arg,\n \t\t\t\t      const char **argv ATTRIBUTE_UNUSED)\n {\n   if (arg != 0)\n-    fatal_error (\"too many arguments to %%:compare-debug-self-opt\");\n+    fatal_error (input_location,\n+\t\t \"too many arguments to %%:compare-debug-self-opt\");\n \n   if (compare_debug >= 0)\n     return NULL;\n@@ -9284,17 +9312,19 @@ compare_debug_auxbase_opt_spec_function (int arg,\n   int len;\n \n   if (arg == 0)\n-    fatal_error (\"too few arguments to %%:compare-debug-auxbase-opt\");\n+    fatal_error (input_location,\n+\t\t \"too few arguments to %%:compare-debug-auxbase-opt\");\n \n   if (arg != 1)\n-    fatal_error (\"too many arguments to %%:compare-debug-auxbase-opt\");\n+    fatal_error (input_location,\n+\t\t \"too many arguments to %%:compare-debug-auxbase-opt\");\n \n   if (compare_debug >= 0)\n     return NULL;\n \n   len = strlen (argv[0]);\n   if (len < 3 || strcmp (argv[0] + len - 3, \".gk\") != 0)\n-    fatal_error (\"argument to %%:compare-debug-auxbase-opt \"\n+    fatal_error (input_location, \"argument to %%:compare-debug-auxbase-opt \"\n \t\t \"does not end in .gk\");\n \n   if (debug_auxbase_opt)\n@@ -9368,7 +9398,7 @@ replace_extension_spec_func (int argc, const char **argv)\n   int i;\n \n   if (argc != 2)\n-    fatal_error (\"too few arguments to %%:replace-extension\");\n+    fatal_error (input_location, \"too few arguments to %%:replace-extension\");\n \n   name = xstrdup (argv[0]);\n "}, {"sha": "dcb29441f61e85e23005c1ef2808a0a86de3dfaf", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -199,7 +199,7 @@ typedef uint64_t gcov_type_unsigned;\n #define gcov_nonruntime_assert(EXPR) ((void)(0 && (EXPR)))\n #else\n #define gcov_nonruntime_assert(EXPR) gcc_assert (EXPR)\n-#define gcov_error(...) fatal_error (__VA_ARGS__)\n+#define gcov_error(...) fatal_error (input_location, __VA_ARGS__)\n #endif\n \n /* File suffixes.  */"}, {"sha": "0f97b532d7f34234d1295ef984a873611b5c4498", "filename": "gcc/gcov-tool.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fgcov-tool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fgcov-tool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-tool.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -65,7 +65,7 @@ unlink_gcda_file (const char *name,\n     ret = remove (name);\n \n   if (ret)\n-    fatal_error (\"error in removing %s\\n\", name);\n+    fatal_error (input_location, \"error in removing %s\\n\", name);\n \n   return ret;\n }\n@@ -95,25 +95,25 @@ gcov_output_files (const char *out, struct gcov_info *profile)\n #else\n       if (mkdir (out) == -1 && errno != EEXIST)\n #endif\n-        fatal_error (\"Cannot make directory %s\", out);\n+        fatal_error (input_location, \"Cannot make directory %s\", out);\n     } else\n       unlink_profile_dir (out);\n \n   /* Output new profile.  */\n   pwd = getcwd (NULL, 0);\n \n   if (pwd == NULL)\n-    fatal_error (\"Cannot get current directory name\");\n+    fatal_error (input_location, \"Cannot get current directory name\");\n \n   ret = chdir (out);\n   if (ret)\n-    fatal_error (\"Cannot change directory to %s\", out);\n+    fatal_error (input_location, \"Cannot change directory to %s\", out);\n \n   gcov_do_dump (profile, 0);\n \n   ret = chdir (pwd);\n   if (ret)\n-    fatal_error (\"Cannot change directory to %s\", pwd);\n+    fatal_error (input_location, \"Cannot change directory to %s\", pwd);\n \n   free (pwd);\n }\n@@ -207,7 +207,7 @@ do_merge (int argc, char **argv)\n         case 'w':\n           sscanf (optarg, \"%d,%d\", &w1, &w2);\n           if (w1 < 0 || w2 < 0)\n-            fatal_error (\"weights need to be non-negative\\n\");\n+            fatal_error (input_location, \"weights need to be non-negative\\n\");\n           break;\n         default:\n           merge_usage ();\n@@ -350,7 +350,7 @@ do_rewrite (int argc, char **argv)\n             }\n \n           if (scale < 0.0)\n-            fatal_error (\"scale needs to be non-negative\\n\");\n+            fatal_error (input_location, \"scale needs to be non-negative\\n\");\n \n           if (normalize_val != 0)\n             {"}, {"sha": "03fbe7d80cf3ec8db3033cd12560862711c93e8d", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -395,15 +395,15 @@ write_pch_globals (const struct ggc_root_tab * const *tab,\n \t    {\n \t      if (fwrite (&ptr, sizeof (void *), 1, state->f)\n \t\t  != 1)\n-\t\tfatal_error (\"can%'t write PCH file: %m\");\n+\t\tfatal_error (input_location, \"can%'t write PCH file: %m\");\n \t    }\n \t  else\n \t    {\n \t      new_ptr = (struct ptr_data *)\n \t\tsaving_htab->find_with_hash (ptr, POINTER_HASH (ptr));\n \t      if (fwrite (&new_ptr->new_addr, sizeof (void *), 1, state->f)\n \t\t  != 1)\n-\t\tfatal_error (\"can%'t write PCH file: %m\");\n+\t\tfatal_error (input_location, \"can%'t write PCH file: %m\");\n \t    }\n \t}\n }\n@@ -472,7 +472,7 @@ gt_pch_save (FILE *f)\n   for (rt = gt_pch_scalar_rtab; *rt; rt++)\n     for (rti = *rt; rti->base != NULL; rti++)\n       if (fwrite (rti->base, rti->stride, 1, f) != 1)\n-\tfatal_error (\"can%'t write PCH file: %m\");\n+\tfatal_error (input_location, \"can%'t write PCH file: %m\");\n \n   /* Write out all the global pointers, after translation.  */\n   write_pch_globals (gt_ggc_rtab, &state);\n@@ -483,17 +483,17 @@ gt_pch_save (FILE *f)\n     long o;\n     o = ftell (state.f) + sizeof (mmi);\n     if (o == -1)\n-      fatal_error (\"can%'t get position in PCH file: %m\");\n+      fatal_error (input_location, \"can%'t get position in PCH file: %m\");\n     mmi.offset = mmap_offset_alignment - o % mmap_offset_alignment;\n     if (mmi.offset == mmap_offset_alignment)\n       mmi.offset = 0;\n     mmi.offset += o;\n   }\n   if (fwrite (&mmi, sizeof (mmi), 1, state.f) != 1)\n-    fatal_error (\"can%'t write PCH file: %m\");\n+    fatal_error (input_location, \"can%'t write PCH file: %m\");\n   if (mmi.offset != 0\n       && fseek (state.f, mmi.offset, SEEK_SET) != 0)\n-    fatal_error (\"can%'t write padding to PCH file: %m\");\n+    fatal_error (input_location, \"can%'t write padding to PCH file: %m\");\n \n   ggc_pch_prepare_write (state.d, state.f);\n \n@@ -615,31 +615,31 @@ gt_pch_restore (FILE *f)\n   for (rt = gt_pch_scalar_rtab; *rt; rt++)\n     for (rti = *rt; rti->base != NULL; rti++)\n       if (fread (rti->base, rti->stride, 1, f) != 1)\n-\tfatal_error (\"can%'t read PCH file: %m\");\n+\tfatal_error (input_location, \"can%'t read PCH file: %m\");\n \n   /* Read in all the global pointers, in 6 easy loops.  */\n   for (rt = gt_ggc_rtab; *rt; rt++)\n     for (rti = *rt; rti->base != NULL; rti++)\n       for (i = 0; i < rti->nelt; i++)\n \tif (fread ((char *)rti->base + rti->stride * i,\n \t\t   sizeof (void *), 1, f) != 1)\n-\t  fatal_error (\"can%'t read PCH file: %m\");\n+\t  fatal_error (input_location, \"can%'t read PCH file: %m\");\n \n   if (fread (&mmi, sizeof (mmi), 1, f) != 1)\n-    fatal_error (\"can%'t read PCH file: %m\");\n+    fatal_error (input_location, \"can%'t read PCH file: %m\");\n \n   result = host_hooks.gt_pch_use_address (mmi.preferred_base, mmi.size,\n \t\t\t\t\t  fileno (f), mmi.offset);\n   if (result < 0)\n-    fatal_error (\"had to relocate PCH\");\n+    fatal_error (input_location, \"had to relocate PCH\");\n   if (result == 0)\n     {\n       if (fseek (f, mmi.offset, SEEK_SET) != 0\n \t  || fread (mmi.preferred_base, mmi.size, 1, f) != 1)\n-\tfatal_error (\"can%'t read PCH file: %m\");\n+\tfatal_error (input_location, \"can%'t read PCH file: %m\");\n     }\n   else if (fseek (f, mmi.offset + mmi.size, SEEK_SET) != 0)\n-    fatal_error (\"can%'t read PCH file: %m\");\n+    fatal_error (input_location, \"can%'t read PCH file: %m\");\n \n   ggc_pch_read (f, mmi.preferred_base);\n "}, {"sha": "158156a37b5368cfc4a037b05dc8a10693628519", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -2449,7 +2449,7 @@ ggc_pch_write_object (struct ggc_pch_data *d,\n     }\n \n   if (fwrite (x, size, 1, f) != 1)\n-    fatal_error (\"can%'t write PCH file: %m\");\n+    fatal_error (input_location, \"can%'t write PCH file: %m\");\n \n   /* If SIZE is not the same as OBJECT_SIZE(order), then we need to pad the\n      object out to OBJECT_SIZE(order).  This happens for strings.  */\n@@ -2465,13 +2465,13 @@ ggc_pch_write_object (struct ggc_pch_data *d,\n       if (padding <= sizeof (emptyBytes))\n         {\n           if (fwrite (emptyBytes, 1, padding, f) != padding)\n-            fatal_error (\"can%'t write PCH file\");\n+            fatal_error (input_location, \"can%'t write PCH file\");\n         }\n       else\n         {\n           /* Larger than our buffer?  Just default to fseek.  */\n           if (fseek (f, padding, SEEK_CUR) != 0)\n-            fatal_error (\"can%'t write PCH file\");\n+            fatal_error (input_location, \"can%'t write PCH file\");\n         }\n     }\n \n@@ -2480,14 +2480,14 @@ ggc_pch_write_object (struct ggc_pch_data *d,\n       && fseek (f, ROUND_UP_VALUE (d->d.totals[order] * OBJECT_SIZE (order),\n \t\t\t\t   G.pagesize),\n \t\tSEEK_CUR) != 0)\n-    fatal_error (\"can%'t write PCH file: %m\");\n+    fatal_error (input_location, \"can%'t write PCH file: %m\");\n }\n \n void\n ggc_pch_finish (struct ggc_pch_data *d, FILE *f)\n {\n   if (fwrite (&d->d, sizeof (d->d), 1, f) != 1)\n-    fatal_error (\"can%'t write PCH file: %m\");\n+    fatal_error (input_location, \"can%'t write PCH file: %m\");\n   free (d);\n }\n \n@@ -2577,7 +2577,7 @@ ggc_pch_read (FILE *f, void *addr)\n   /* Allocate the appropriate page-table entries for the pages read from\n      the PCH file.  */\n   if (fread (&d, sizeof (d), 1, f) != 1)\n-    fatal_error (\"can%'t read PCH file: %m\");\n+    fatal_error (input_location, \"can%'t read PCH file: %m\");\n \n   for (i = 0; i < NUM_ORDERS; i++)\n     {"}, {"sha": "a1eb24c49ccb99faba3201a9068cd3dceaf9d194", "filename": "gcc/graph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -63,7 +63,7 @@ open_graph_file (const char *base, const char *mode)\n \n   fp = fopen (buf, mode);\n   if (fp == NULL)\n-    fatal_error (\"can%'t open %s: %m\", buf);\n+    fatal_error (input_location, \"can%'t open %s: %m\", buf);\n \n   return fp;\n }"}, {"sha": "ffa559c0c5f22b74a7f179fb53af7aabe2ada8bb", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -4251,7 +4251,8 @@ inline_read_summary (void)\n \t/* Fatal error here.  We do not want to support compiling ltrans units\n \t   with different version of compiler or different flags than the WPA\n \t   unit, so this should never happen.  */\n-\tfatal_error (\"ipa inline summary is missing in input file\");\n+\tfatal_error (input_location,\n+\t\t     \"ipa inline summary is missing in input file\");\n     }\n   if (optimize)\n     {"}, {"sha": "219a9b3828d09ace1b760016176370412f74585f", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -1172,7 +1172,8 @@ ipa_reference_read_optimization_summary (void)\n \t/* Fatal error here.  We do not want to support compiling ltrans units with\n \t   different version of compiler or different flags than the WPA unit, so\n \t   this should never happen.  */\n-\tfatal_error (\"ipa reference summary is missing in ltrans unit\");\n+\tfatal_error (input_location,\n+\t\t     \"ipa reference summary is missing in ltrans unit\");\n     }\n }\n "}, {"sha": "0437f731f5b1968719b2b17b14bc55e29e6a8185", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -1,3 +1,8 @@\n+2015-01-30  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* class.c, expr.c, jcf-parse.c, jvspec.c: All callers of\n+\tfatal_error changed to pass input_location as first argument.\n+\n 2015-10-15  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n \t\n \t* builtins.c: Include calls.h dojump.h emit-rtl.h explow.h expmed.h"}, {"sha": "d1adb581524bbf3d06d9fa9c805373d2094a4346", "filename": "gcc/java/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -850,7 +850,7 @@ add_method (tree this_class, int access_flags, tree name, tree method_sig)\n     = (const unsigned char *) IDENTIFIER_POINTER (method_sig);\n \n   if (sig[0] != '(')\n-    fatal_error (\"bad method signature\");\n+    fatal_error (input_location, \"bad method signature\");\n \n   function_type = get_type_from_signature (method_sig);\n   fndecl = add_method_1 (this_class, access_flags, name, function_type);"}, {"sha": "9af9e751275d878b7f74a670a4eba1e56723039e", "filename": "gcc/java/expr.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -2253,7 +2253,7 @@ build_known_method_ref (tree method, tree method_type ATTRIBUTE_UNUSED,\n \t  if (method == meth)\n \t    break;\n \t  if (meth == NULL_TREE)\n-\t    fatal_error (\"method '%s' not found in class\",\n+\t    fatal_error (input_location, \"method '%s' not found in class\",\n \t\t\t IDENTIFIER_POINTER (DECL_NAME (method)));\n \t  method_index++;\n \t}\n@@ -2445,7 +2445,7 @@ expand_invoke (int opcode, int method_ref_index, int nargs ATTRIBUTE_UNUSED)\n       load_class (self_type, 1);\n       safe_layout_class (self_type);\n       if (TREE_CODE (TYPE_SIZE (self_type)) == ERROR_MARK)\n-\tfatal_error (\"failed to find class '%s'\", self_name);\n+\tfatal_error (input_location, \"failed to find class '%s'\", self_name);\n     }\n   layout_class_methods (self_type);\n "}, {"sha": "e609331ae6aadb8297439e0a8f1d58b729f7dbb5", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -1114,7 +1114,7 @@ get_constant (JCF *jcf, int index)\n \t  {\n \t    int char_len = UT8_CHAR_LENGTH (*utf8);\n \t    if (char_len < 0 || char_len > 3 || char_len > i)\n- \t      fatal_error (\"bad string constant\");\n+ \t      fatal_error (input_location, \"bad string constant\");\n \n \t    utf8 += char_len;\n \t    i -= char_len;\n@@ -1132,7 +1132,7 @@ get_constant (JCF *jcf, int index)\n   jcf->cpool.data[index].t = value;\n   return value;\n  bad:\n-  fatal_error (\"bad value constant type %d, index %d\", \n+  fatal_error (input_location, \"bad value constant type %d, index %d\", \n \t       JPOOL_TAG (jcf, index), index);\n }\n \n@@ -1443,13 +1443,13 @@ jcf_parse (JCF* jcf)\n   bitmap_clear (field_offsets);\n \n   if (jcf_parse_preamble (jcf) != 0)\n-    fatal_error (\"not a valid Java .class file\");\n+    fatal_error (input_location, \"not a valid Java .class file\");\n   code = jcf_parse_constant_pool (jcf);\n   if (code != 0)\n-    fatal_error (\"error while parsing constant pool\");\n+    fatal_error (input_location, \"error while parsing constant pool\");\n   code = verify_constant_pool (jcf);\n   if (code > 0)\n-    fatal_error (\"error in constant pool entry #%d\\n\", code);\n+    fatal_error (input_location, \"error in constant pool entry #%d\\n\", code);\n \n   jcf_parse_class (jcf);\n   if (main_class == NULL_TREE)\n@@ -1461,7 +1461,8 @@ jcf_parse (JCF* jcf)\n   if (CLASS_PARSED_P (current_class))\n     {\n       /* FIXME - where was first time */\n-      fatal_error (\"reading class %s for the second time from %s\",\n+      fatal_error (input_location,\n+\t\t   \"reading class %s for the second time from %s\",\n \t\t   IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))),\n \t\t   jcf->filename);\n     }\n@@ -1479,13 +1480,13 @@ jcf_parse (JCF* jcf)\n   \n   code = jcf_parse_fields (jcf);\n   if (code != 0)\n-    fatal_error (\"error while parsing fields\");\n+    fatal_error (input_location, \"error while parsing fields\");\n   code = jcf_parse_methods (jcf);\n   if (code != 0)\n-    fatal_error (\"error while parsing methods\");\n+    fatal_error (input_location, \"error while parsing methods\");\n   code = jcf_parse_final_attributes (jcf);\n   if (code != 0)\n-    fatal_error (\"error while parsing final attributes\");\n+    fatal_error (input_location, \"error while parsing final attributes\");\n \n   if (TYPE_REFLECTION_DATA (current_class))\n     annotation_write_byte (JV_DONE_ATTR);\n@@ -1769,7 +1770,8 @@ java_parse_file (void)\n       int avail = 2000;\n       finput = fopen (main_input_filename, \"r\");\n       if (finput == NULL)\n-\tfatal_error (\"can%'t open %s: %m\", LOCATION_FILE (input_location));\n+\tfatal_error (input_location,\n+\t\t     \"can%'t open %s: %m\", LOCATION_FILE (input_location));\n       list = XNEWVEC (char, avail);\n       next = list;\n       for (;;)\n@@ -1788,7 +1790,7 @@ java_parse_file (void)\n \t  if (count == 0)\n \t    {\n \t      if (! feof (finput))\n-\t\tfatal_error (\"error closing %s: %m\",\n+\t\tfatal_error (input_location, \"error closing %s: %m\",\n \t\t\t     LOCATION_FILE (input_location));\n \t      *next = '\\0';\n \t      break;\n@@ -1903,11 +1905,12 @@ java_parse_file (void)\n \n       /* Close previous descriptor, if any */\n       if (finput && fclose (finput))\n-\tfatal_error (\"can%'t close input file %s: %m\", main_input_filename);\n+\tfatal_error (input_location,\n+\t\t     \"can%'t close input file %s: %m\", main_input_filename);\n       \n       finput = fopen (filename, \"rb\");\n       if (finput == NULL)\n-\tfatal_error (\"can%'t open %s: %m\", filename);\n+\tfatal_error (input_location, \"can%'t open %s: %m\", filename);\n \n #ifdef IO_BUFFER_SIZE\n       setvbuf (finput, xmalloc (IO_BUFFER_SIZE),\n@@ -1946,7 +1949,7 @@ java_parse_file (void)\n \t  linemap_add (line_table, LC_ENTER, false, filename, 0);\n \t  input_location = linemap_line_start (line_table, 0, 1);\n \t  if (open_in_zip (main_jcf, filename, NULL, 0) <  0)\n-\t    fatal_error (\"bad zip/jar file %s\", filename);\n+\t    fatal_error (input_location, \"bad zip/jar file %s\", filename);\n \t  localToFile = SeenZipFiles;\n \t  /* Register all the classes defined there.  */\n \t  process_zip_dir ((FILE *) main_jcf->read_state);\n@@ -2148,7 +2151,8 @@ parse_zip_file_entries (void)\n \t    jcf->zipd        = zdir;\n \n \t    if (read_zip_member (jcf, zdir, localToFile) < 0)\n-\t      fatal_error (\"error while reading %s from zip file\", file_name);\n+\t      fatal_error (input_location,\n+\t\t\t   \"error while reading %s from zip file\", file_name);\n \n \t    buffer = XNEWVEC (char, zdir->filename_length + 1 +\n \t\t\t    (jcf->buffer_end - jcf->buffer));"}, {"sha": "d4efb7377a0abdeb25e7d0e204206a487a9bf878", "filename": "gcc/java/jvspec.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fjava%2Fjvspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fjava%2Fjvspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjvspec.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -392,16 +392,17 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n     }\n \n   if (saw_D && ! main_class_name)\n-    fatal_error (\"can%'t specify %<-D%> without %<--main%>\");\n+    fatal_error (input_location, \"can%'t specify %<-D%> without %<--main%>\");\n \n   if (main_class_name && ! verify_class_name (main_class_name))\n-    fatal_error (\"%qs is not a valid class name\", main_class_name);\n+    fatal_error (input_location,\n+\t\t \"%qs is not a valid class name\", main_class_name);\n \n   num_args = argc + added;\n   if (saw_resource)\n     {\n       if (! saw_o)\n-\tfatal_error (\"--resource requires -o\");\n+\tfatal_error (input_location, \"--resource requires -o\");\n     }\n   if (saw_C)\n     {\n@@ -415,7 +416,7 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n \t}\n       num_args += 2;  /* For -o NONE. */\n       if (saw_o)\n-\tfatal_error (\"cannot specify both -C and -o\");\n+\tfatal_error (input_location, \"cannot specify both -C and -o\");\n     }\n   if ((saw_o && java_files_count + class_files_count + zip_files_count > 1)\n       || (saw_C && java_files_count > 1)\n@@ -427,7 +428,7 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n     {\n       filelist_filename = make_temp_file (\"jx\");\n       if (filelist_filename == NULL)\n-\tfatal_error (\"cannot create temporary file\");\n+\tfatal_error (input_location, \"cannot create temporary file\");\n       record_temp_file (filelist_filename, ! saw_save_temps, 0);\n       filelist_file = fopen (filelist_filename, \"w\");\n       if (filelist_file == NULL)\n@@ -449,7 +450,8 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n   if (combine_inputs || indirect_files_count > 0)\n     num_args += 1; /* for \"-ffilelist-file\" */\n   if (combine_inputs && indirect_files_count > 0)\n-    fatal_error (\"using both @FILE with multiple files not implemented\");\n+    fatal_error (input_location,\n+\t\t \"using both @FILE with multiple files not implemented\");\n \n   /* There's no point adding -shared-libgcc if we don't have a shared\n      libgcc.  */\n@@ -533,7 +535,8 @@ lang_specific_driver (struct cl_decoded_option **in_decoded_options,\n \n \tcase OPT_fmain_:\n \t  if (! will_link)\n-\t    fatal_error (\"cannot specify %<main%> class when not linking\");\n+\t    fatal_error (input_location,\n+\t\t\t \"cannot specify %<main%> class when not linking\");\n \t  --j;\n \t  continue;\n \t}"}, {"sha": "ab9524b3b73fd4272ee4992e3bd124db337d0dea", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -1805,7 +1805,7 @@ merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n                       node->lto_file_data->profile_info.runs);\n \tnode->count_materialization_scale = scale;\n \tif (scale < 0)\n-\t  fatal_error (\"Profile information in %s corrupted\",\n+\t  fatal_error (input_location, \"Profile information in %s corrupted\",\n \t\t       file_data->file_name);\n \n \tif (scale == REG_BR_PROB_BASE)\n@@ -1837,7 +1837,8 @@ input_symtab (void)\n       ib = lto_create_simple_input_block (file_data, LTO_section_symtab_nodes,\n \t\t\t\t\t  &data, &len);\n       if (!ib) \n-\tfatal_error (\"cannot find LTO cgraph in %s\", file_data->file_name);\n+\tfatal_error (input_location,\n+\t\t     \"cannot find LTO cgraph in %s\", file_data->file_name);\n       input_profile_summary (ib, file_data);\n       file_data->symtab_node_encoder = lto_symtab_encoder_new (true);\n       nodes = input_cgraph_1 (file_data, ib);\n@@ -1847,7 +1848,7 @@ input_symtab (void)\n       ib = lto_create_simple_input_block (file_data, LTO_section_refs,\n \t\t\t\t\t  &data, &len);\n       if (!ib)\n-\tfatal_error (\"cannot find LTO section refs in %s\",\n+\tfatal_error (input_location, \"cannot find LTO section refs in %s\",\n \t\t     file_data->file_name);\n       input_refs (ib, nodes);\n       lto_destroy_simple_input_block (file_data, LTO_section_refs,\n@@ -1914,7 +1915,8 @@ input_offload_tables (void)\n \t      vec_safe_push (offload_vars, var_decl);\n \t    }\n \t  else\n-\t    fatal_error (\"invalid offload table in %s\", file_data->file_name);\n+\t    fatal_error (input_location,\n+\t\t\t \"invalid offload table in %s\", file_data->file_name);\n \n \t  tag = streamer_read_enum (ib, LTO_symtab_tags, LTO_symtab_last_tag);\n \t}"}, {"sha": "20eded67fbac117d54d927256c1634220bf7e810", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -457,7 +457,7 @@ lto_free_function_in_decl_state_for_node (symtab_node *node)\n void\n lto_section_overrun (struct lto_input_block *ib)\n {\n-  fatal_error (\"bytecode stream: trying to read %d bytes \"\n+  fatal_error (input_location, \"bytecode stream: trying to read %d bytes \"\n \t       \"after the end of the input buffer\", ib->p - ib->len);\n }\n \n@@ -467,6 +467,7 @@ void\n lto_value_range_error (const char *purpose, HOST_WIDE_INT val,\n \t\t       HOST_WIDE_INT min, HOST_WIDE_INT max)\n {\n-  fatal_error (\"%s out of range: Range is %i to %i, value is %i\",\n+  fatal_error (input_location,\n+\t       \"%s out of range: Range is %i to %i, value is %i\",\n \t       purpose, (int)min, (int)max, (int)val);\n }"}, {"sha": "e12d00ac8137fe60bf67344ca504a4599d2eeb16", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -815,27 +815,31 @@ fixup_call_stmt_edges_1 (struct cgraph_node *node, gimple *stmts,\n   for (cedge = node->callees; cedge; cedge = cedge->next_callee)\n     {\n       if (gimple_stmt_max_uid (fn) < cedge->lto_stmt_uid)\n-        fatal_error (\"Cgraph edge statement index out of range\");\n+        fatal_error (input_location,\n+\t\t     \"Cgraph edge statement index out of range\");\n       cedge->call_stmt = as_a <gcall *> (stmts[cedge->lto_stmt_uid - 1]);\n       if (!cedge->call_stmt)\n-        fatal_error (\"Cgraph edge statement index not found\");\n+        fatal_error (input_location,\n+\t\t     \"Cgraph edge statement index not found\");\n     }\n   for (cedge = node->indirect_calls; cedge; cedge = cedge->next_callee)\n     {\n       if (gimple_stmt_max_uid (fn) < cedge->lto_stmt_uid)\n-        fatal_error (\"Cgraph edge statement index out of range\");\n+        fatal_error (input_location,\n+\t\t     \"Cgraph edge statement index out of range\");\n       cedge->call_stmt = as_a <gcall *> (stmts[cedge->lto_stmt_uid - 1]);\n       if (!cedge->call_stmt)\n-        fatal_error (\"Cgraph edge statement index not found\");\n+        fatal_error (input_location, \"Cgraph edge statement index not found\");\n     }\n   for (i = 0; node->iterate_reference (i, ref); i++)\n     if (ref->lto_stmt_uid)\n       {\n \tif (gimple_stmt_max_uid (fn) < ref->lto_stmt_uid)\n-\t  fatal_error (\"Reference statement index out of range\");\n+\t  fatal_error (input_location,\n+\t\t       \"Reference statement index out of range\");\n \tref->stmt = stmts[ref->lto_stmt_uid - 1];\n \tif (!ref->stmt)\n-\t  fatal_error (\"Reference statement index not found\");\n+\t  fatal_error (input_location, \"Reference statement index not found\");\n       }\n }\n "}, {"sha": "836dce98d9f95c2965b0c5ef52d84718d950e512", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -406,7 +406,8 @@ void\n lto_check_version (int major, int minor)\n {\n   if (major != LTO_major_version || minor != LTO_minor_version)\n-    fatal_error (\"bytecode stream generated with LTO version %d.%d instead \"\n+    fatal_error (input_location,\n+\t\t \"bytecode stream generated with LTO version %d.%d instead \"\n \t         \"of the expected %d.%d\",\n \t\t major, minor,\n \t\t LTO_major_version, LTO_minor_version);"}, {"sha": "404cb68e0d1f800628ff69b7672385b88450a3d5", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -109,7 +109,7 @@ maybe_unlink (const char *file)\n     {\n       if (unlink_if_ordinary (file)\n \t  && errno != ENOENT)\n-\tfatal_error (\"deleting LTRANS file %s: %m\", file);\n+\tfatal_error (input_location, \"deleting LTRANS file %s: %m\", file);\n     }\n   else if (verbose)\n     fprintf (stderr, \"[Leaving LTRANS %s]\\n\", file);\n@@ -146,7 +146,7 @@ get_options_from_collect_gcc_options (const char *collect_gcc,\n \t  do\n \t    {\n \t      if (argv_storage[j] == '\\0')\n-\t\tfatal_error (\"malformed COLLECT_GCC_OPTIONS\");\n+\t\tfatal_error (input_location, \"malformed COLLECT_GCC_OPTIONS\");\n \t      else if (strncmp (&argv_storage[j], \"'\\\\''\", 4) == 0)\n \t\t{\n \t\t  argv_storage[k++] = '\\'';\n@@ -294,7 +294,8 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n \t    if ((*decoded_options)[j].opt_index == foption->opt_index)\n \t      break;\n \t  if (j == *decoded_options_count)\n-\t    fatal_error (\"Option %s not used consistently in all LTO input\"\n+\t    fatal_error (input_location,\n+\t\t\t \"Option %s not used consistently in all LTO input\"\n \t\t\t \" files\", foption->orig_option_with_args_text);\n \t  break;\n \n@@ -305,7 +306,8 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n \t    if (j == *decoded_options_count)\n \t      append_option (decoded_options, decoded_options_count, foption);\n \t    else if (foption->value != (*decoded_options)[j].value)\n-\t      fatal_error (\"Option %s not used consistently in all LTO input\"\n+\t      fatal_error (input_location,\n+\t\t\t   \"Option %s not used consistently in all LTO input\"\n \t\t\t   \" files\", foption->orig_option_with_args_text);\n \t    break;\n \n@@ -730,7 +732,8 @@ compile_images_for_offload_targets (unsigned in_argc, char *in_argv[],\n \t\t\t\t compiler_opts, compiler_opt_count,\n \t\t\t\t linker_opts, linker_opt_count);\n       if (!offload_names[i])\n-\tfatal_error (\"problem with building target image for %s\\n\", names[i]);\n+\tfatal_error (input_location,\n+\t\t     \"problem with building target image for %s\\n\", names[i]);\n     }\n \n  out:\n@@ -749,12 +752,12 @@ copy_file (const char *dest, const char *src)\n     {\n       size_t len = fread (buffer, 1, 512, s);\n       if (ferror (s) != 0)\n-\tfatal_error (\"reading input file\");\n+\tfatal_error (input_location, \"reading input file\");\n       if (len > 0)\n \t{\n \t  fwrite (buffer, 1, len, d);\n \t  if (ferror (d) != 0)\n-\t    fatal_error (\"writing output file\");\n+\t    fatal_error (input_location, \"writing output file\");\n \t}\n     }\n }\n@@ -779,7 +782,8 @@ find_offloadbeginend (void)\n \tchar *tmp = xstrdup (paths[i]);\n \tstrcpy (paths[i] + len - strlen (\"begin.o\"), \"end.o\");\n \tif (access_check (paths[i], R_OK) != 0)\n-\t  fatal_error (\"installation error, can't find crtoffloadend.o\");\n+\t  fatal_error (input_location,\n+\t\t       \"installation error, can't find crtoffloadend.o\");\n \t/* The linker will delete the filenames we give it, so make\n \t   copies.  */\n \toffloadbegin = make_temp_file (\".o\");\n@@ -790,7 +794,8 @@ find_offloadbeginend (void)\n \tbreak;\n       }\n   if (i == n_paths)\n-    fatal_error (\"installation error, can't find crtoffloadbegin.o\");\n+    fatal_error (input_location,\n+\t\t \"installation error, can't find crtoffloadbegin.o\");\n \n   free_array_of_ptrs ((void **) paths, n_paths);\n }\n@@ -893,10 +898,12 @@ run_gcc (unsigned argc, char *argv[])\n   /* Get the driver and options.  */\n   collect_gcc = getenv (\"COLLECT_GCC\");\n   if (!collect_gcc)\n-    fatal_error (\"environment variable COLLECT_GCC must be set\");\n+    fatal_error (input_location,\n+\t\t \"environment variable COLLECT_GCC must be set\");\n   collect_gcc_options = getenv (\"COLLECT_GCC_OPTIONS\");\n   if (!collect_gcc_options)\n-    fatal_error (\"environment variable COLLECT_GCC_OPTIONS must be set\");\n+    fatal_error (input_location,\n+\t\t \"environment variable COLLECT_GCC_OPTIONS must be set\");\n   get_options_from_collect_gcc_options (collect_gcc, collect_gcc_options,\n \t\t\t\t\tCL_LANG_ALL,\n \t\t\t\t\t&decoded_options,\n@@ -1162,7 +1169,7 @@ run_gcc (unsigned argc, char *argv[])\n       struct obstack env_obstack;\n \n       if (!stream)\n-\tfatal_error (\"fopen: %s: %m\", ltrans_output_file);\n+\tfatal_error (input_location, \"fopen: %s: %m\", ltrans_output_file);\n \n       /* Parse the list of LTRANS inputs from the WPA stage.  */\n       obstack_init (&env_obstack);\n@@ -1344,7 +1351,7 @@ main (int argc, char *argv[])\n   diagnostic_initialize (global_dc, 0);\n \n   if (atexit (lto_wrapper_cleanup) != 0)\n-    fatal_error (\"atexit failed\");\n+    fatal_error (input_location, \"atexit failed\");\n \n   if (signal (SIGINT, SIG_IGN) != SIG_IGN)\n     signal (SIGINT, fatal_signal);"}, {"sha": "c77e6ccae40ecd5b2a161ecff0db95cb13385945", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -1,3 +1,8 @@\n+2015-01-30  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* lto-object.c, lto-symtab.c, lto.c: All callers of fatal_error\n+\tchanged to pass input_location as first argument.\n+\n 2014-12-11  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto-symtab.c (lto_varpool_replace_node): Merge TLS models."}, {"sha": "34dafb10dd28044eccc5367605e4a6abd52ddd8f", "filename": "gcc/lto/lto-object.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Flto%2Flto-object.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Flto%2Flto-object.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-object.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -208,9 +208,9 @@ lto_obj_file_close (lto_file *file)\n       if (errmsg != NULL)\n \t{\n \t  if (err == 0)\n-\t    fatal_error (\"%s\", errmsg);\n+\t    fatal_error (input_location, \"%s\", errmsg);\n \t  else\n-\t    fatal_error (\"%s: %s\", errmsg, xstrerror (err));\n+\t    fatal_error (input_location, \"%s: %s\", errmsg, xstrerror (err));\n \t}\n \n       simple_object_release_write (lo->sobj_w);\n@@ -219,7 +219,7 @@ lto_obj_file_close (lto_file *file)\n   if (lo->fd != -1)\n     {\n       if (close (lo->fd) < 0)\n-\tfatal_error (\"close: %s\", xstrerror (errno));\n+\tfatal_error (input_location, \"close: %s\", xstrerror (errno));\n     }\n }\n \n@@ -362,9 +362,9 @@ lto_obj_begin_section (const char *name)\n   if (lo->section == NULL)\n     {\n       if (err == 0)\n-\tfatal_error (\"%s\", errmsg);\n+\tfatal_error (input_location, \"%s\", errmsg);\n       else\n-\tfatal_error (\"%s: %s\", errmsg, xstrerror (errno));\n+\tfatal_error (input_location, \"%s: %s\", errmsg, xstrerror (errno));\n     }\n }\n \n@@ -386,9 +386,9 @@ lto_obj_append_data (const void *data, size_t len, void *)\n   if (errmsg != NULL)\n     {\n       if (err == 0)\n-\tfatal_error (\"%s\", errmsg);\n+\tfatal_error (input_location, \"%s\", errmsg);\n       else\n-\tfatal_error (\"%s: %s\", errmsg, xstrerror (errno));\n+\tfatal_error (input_location, \"%s: %s\", errmsg, xstrerror (errno));\n     }\n }\n "}, {"sha": "39c9257edc08379d76cd55d37ac20b3d76650be9", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -382,7 +382,7 @@ lto_symtab_resolve_symbols (symtab_node *first)\n \t    && (e->resolution == LDPR_PREVAILING_DEF_IRONLY\n \t\t|| e->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP\n \t\t|| e->resolution == LDPR_PREVAILING_DEF))\n-\t  fatal_error (\"multiple prevailing defs for %qE\",\n+\t  fatal_error (input_location, \"multiple prevailing defs for %qE\",\n \t\t       DECL_NAME (prevailing->decl));\n       return prevailing;\n     }"}, {"sha": "c86f8358f3592e88bcf19d763e4a9b28360b9252", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -2328,7 +2328,7 @@ lto_read_section_data (struct lto_file_decl_data *file_data,\n       fd = open (file_data->file_name, O_RDONLY|O_BINARY);\n       if (fd == -1)\n         {\n-\t  fatal_error (\"Cannot open %s\", file_data->file_name);\n+\t  fatal_error (input_location, \"Cannot open %s\", file_data->file_name);\n \t  return NULL;\n         }\n       fd_name = xstrdup (file_data->file_name);\n@@ -2349,7 +2349,7 @@ lto_read_section_data (struct lto_file_decl_data *file_data,\n \t\t\t  fd, computed_offset);\n   if (result == MAP_FAILED)\n     {\n-      fatal_error (\"Cannot map %s\", file_data->file_name);\n+      fatal_error (input_location, \"Cannot map %s\", file_data->file_name);\n       return NULL;\n     }\n \n@@ -2360,7 +2360,7 @@ lto_read_section_data (struct lto_file_decl_data *file_data,\n       || read (fd, result, len) != (ssize_t) len)\n     {\n       free (result);\n-      fatal_error (\"Cannot read %s\", file_data->file_name);\n+      fatal_error (input_location, \"Cannot read %s\", file_data->file_name);\n       result = NULL;\n     }\n #ifdef __MINGW32__\n@@ -2474,7 +2474,7 @@ do_stream_out (char *temp_filename, lto_symtab_encoder_t encoder)\n {\n   lto_file *file = lto_obj_file_open (temp_filename, true);\n   if (!file)\n-    fatal_error (\"lto_obj_file_open() failed\");\n+    fatal_error (input_location, \"lto_obj_file_open() failed\");\n   lto_set_current_out_file (file);\n \n   ipa_write_optimization_summaries (encoder);\n@@ -2497,12 +2497,13 @@ wait_for_child ()\n #endif\n       int w = waitpid (0, &status, WUNTRACED | WCONTINUED);\n       if (w == -1)\n-\tfatal_error (\"waitpid failed\");\n+\tfatal_error (input_location, \"waitpid failed\");\n \n       if (WIFEXITED (status) && WEXITSTATUS (status))\n-\tfatal_error (\"streaming subprocess failed\");\n+\tfatal_error (input_location, \"streaming subprocess failed\");\n       else if (WIFSIGNALED (status))\n-\tfatal_error (\"streaming subprocess was killed by signal\");\n+\tfatal_error (input_location,\n+\t\t     \"streaming subprocess was killed by signal\");\n     }\n   while (!WIFEXITED (status) && !WIFSIGNALED (status));\n }\n@@ -2578,7 +2579,7 @@ lto_wpa_write_files (void)\n \n   /* Open the LTRANS output list.  */\n   if (!ltrans_output_list)\n-    fatal_error (\"no LTRANS output list filename provided\");\n+    fatal_error (input_location, \"no LTRANS output list filename provided\");\n \n   timevar_push (TV_WHOPR_WPA);\n \n@@ -2665,13 +2666,14 @@ lto_wpa_write_files (void)\n     }\n   ltrans_output_list_stream = fopen (ltrans_output_list, \"w\");\n   if (ltrans_output_list_stream == NULL)\n-    fatal_error (\"opening LTRANS output list %s: %m\", ltrans_output_list);\n+    fatal_error (input_location,\n+\t\t \"opening LTRANS output list %s: %m\", ltrans_output_list);\n   for (i = 0; i < n_sets; i++)\n     {\n       unsigned int len = strlen (temp_filenames[i]);\n       if (fwrite (temp_filenames[i], 1, len, ltrans_output_list_stream) < len\n \t  || fwrite (\"\\n\", 1, 1, ltrans_output_list_stream) < 1)\n-\tfatal_error (\"writing to LTRANS output list %s: %m\",\n+\tfatal_error (input_location, \"writing to LTRANS output list %s: %m\",\n \t\t     ltrans_output_list);\n      free (temp_filenames[i]);\n     }\n@@ -2681,7 +2683,8 @@ lto_wpa_write_files (void)\n \n   /* Close the LTRANS output list.  */\n   if (fclose (ltrans_output_list_stream))\n-    fatal_error (\"closing LTRANS output list %s: %m\", ltrans_output_list);\n+    fatal_error (input_location,\n+\t\t \"closing LTRANS output list %s: %m\", ltrans_output_list);\n \n   free_ltrans_partitions();\n   free (temp_filename);\n@@ -2927,7 +2930,8 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n \n       resolution = fopen (resolution_file_name, \"r\");\n       if (resolution == NULL)\n-\tfatal_error (\"could not open symbol resolution file: %m\");\n+\tfatal_error (input_location,\n+\t\t     \"could not open symbol resolution file: %m\");\n \n       t = fscanf (resolution, \"%u\", &num_objects);\n       gcc_assert (t == 1);\n@@ -3067,7 +3071,8 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n       /* If there were errors during symbol merging bail out, we have no\n \t good way to recover here.  */\n       if (seen_error ())\n-\tfatal_error (\"errors during merging of translation units\");\n+\tfatal_error (input_location,\n+\t\t     \"errors during merging of translation units\");\n \n       /* Fixup all decls.  */\n       lto_fixup_decls (all_file_decl_data);"}, {"sha": "6bd4dcc29e125321a65e626ba8bf59229bdbcb38", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -485,7 +485,7 @@ objc_write_global_declarations (void)\n \t  char * const dumpname = concat (dump_base_name, \".decl\", NULL);\n \t  gen_declaration_file = fopen (dumpname, \"w\");\n \t  if (gen_declaration_file == 0)\n-\t    fatal_error (\"can%'t open %s: %m\", dumpname);\n+\t    fatal_error (input_location, \"can%'t open %s: %m\", dumpname);\n \t  free (dumpname);\n \t}\n \n@@ -2038,7 +2038,8 @@ objc_add_method_declaration (bool is_class_method, tree decl, tree attributes)\n \t impossible to get here.  But it's good to have the check in\n \t case the parser changes.\n       */\n-      fatal_error (\"method declaration not in @interface context\");\n+      fatal_error (input_location,\n+\t\t   \"method declaration not in @interface context\");\n     }\n \n   if (flag_objc1_only && attributes)\n@@ -2863,7 +2864,7 @@ check_protocol_recursively (tree proto, tree list)\n \t\t\t      /* definition_required */ false);\n \n       if (pp == proto)\n-\tfatal_error (\"protocol %qE has circular dependency\",\n+\tfatal_error (input_location, \"protocol %qE has circular dependency\",\n \t\t     PROTOCOL_NAME (pp));\n       if (pp)\n \tcheck_protocol_recursively (proto, PROTOCOL_LIST (pp));"}, {"sha": "84627c4e379107444a35af2287785f3986aaf427", "filename": "gcc/opts.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -2264,10 +2264,11 @@ setup_core_dumping (diagnostic_context *dc)\n   {\n     struct rlimit rlim;\n     if (getrlimit (RLIMIT_CORE, &rlim) != 0)\n-      fatal_error (\"getting core file size maximum limit: %m\");\n+      fatal_error (input_location, \"getting core file size maximum limit: %m\");\n     rlim.rlim_cur = rlim.rlim_max;\n     if (setrlimit (RLIMIT_CORE, &rlim) != 0)\n-      fatal_error (\"setting core file size limit to maximum: %m\");\n+      fatal_error (input_location,\n+\t\t   \"setting core file size limit to maximum: %m\");\n   }\n #endif\n   diagnostic_abort_on_error (dc);"}, {"sha": "dff70e5bbe9cf74d4eba5e12d22a95634d415ee8", "filename": "gcc/passes.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -1455,14 +1455,15 @@ pass_manager::register_pass (struct register_pass_info *pass_info)\n      passes should never fail these checks, so we mention plugin in\n      the messages.  */\n   if (!pass_info->pass)\n-      fatal_error (\"plugin cannot register a missing pass\");\n+      fatal_error (input_location, \"plugin cannot register a missing pass\");\n \n   if (!pass_info->pass->name)\n-      fatal_error (\"plugin cannot register an unnamed pass\");\n+      fatal_error (input_location, \"plugin cannot register an unnamed pass\");\n \n   if (!pass_info->reference_pass_name)\n       fatal_error\n-\t(\"plugin cannot register pass %qs without reference pass name\",\n+\t(input_location,\n+\t \"plugin cannot register pass %qs without reference pass name\",\n \t pass_info->pass->name);\n \n   /* Try to insert the new pass to the pass lists.  We need to check\n@@ -1480,7 +1481,8 @@ pass_manager::register_pass (struct register_pass_info *pass_info)\n     success |= position_pass (pass_info, &all_passes);\n   if (!success)\n     fatal_error\n-      (\"pass %qs not found but is referenced by new pass %qs\",\n+      (input_location,\n+       \"pass %qs not found but is referenced by new pass %qs\",\n        pass_info->reference_pass_name, pass_info->pass->name);\n \n   /* OK, we have successfully inserted the new pass. We need to register"}, {"sha": "d924438c9404912d4124325220b287416050c8b5", "filename": "gcc/plugin.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fplugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fplugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -187,7 +187,8 @@ add_new_plugin (const char* plugin_name)\n \t\t\t    plugin_name, \".so\", NULL);\n       if (access (plugin_name, R_OK))\n \tfatal_error\n-\t  (\"inaccessible plugin file %s expanded from short plugin name %s: %m\",\n+\t  (input_location,\n+\t   \"inaccessible plugin file %s expanded from short plugin name %s: %m\",\n \t   plugin_name, base_name);\n     }\n   else\n@@ -595,7 +596,8 @@ try_init_one_plugin (struct plugin_name_args *plugin)\n \n   /* Check the plugin license.  */\n   if (dlsym (dl_handle, str_license) == NULL)\n-    fatal_error (\"plugin %s is not licensed under a GPL-compatible license\\n\"\n+    fatal_error (input_location,\n+\t\t \"plugin %s is not licensed under a GPL-compatible license\\n\"\n \t\t \"%s\", plugin->full_name, dlerror ());\n \n   PTR_UNION_AS_VOID_PTR (plugin_init_union) =\n@@ -893,6 +895,7 @@ const char*\n default_plugin_dir_name (void)\n {\n   if (!plugindir_string)\n-    fatal_error (\"-iplugindir <dir> option not passed from the gcc driver\");\n+    fatal_error (input_location,\n+\t\t \"-iplugindir <dir> option not passed from the gcc driver\");\n   return plugindir_string;\n }"}, {"sha": "ec2f9f42c9de3668c9b35f61e2ba95f483b865fd", "filename": "gcc/tlink.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Ftlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Ftlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftlink.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -486,9 +486,9 @@ recompile_files (void)\n \t the new file name already exists.  Therefore, we explicitly\n \t remove the old file first.  */\n       if (remove (f->key) == -1)\n-\tfatal_error (\"removing .rpo file: %m\");\n+\tfatal_error (input_location, \"removing .rpo file: %m\");\n       if (rename (outname, f->key) == -1)\n-\tfatal_error (\"renaming .rpo file: %m\");\n+\tfatal_error (input_location, \"renaming .rpo file: %m\");\n \n       if (!f->args)\n \t{"}, {"sha": "c4bc74b6e79753df0c4e01dd5b260d2afc32907f", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -986,8 +986,8 @@ init_asm_output (const char *name)\n \t       || !strcmp (asm_file_name, HOST_BIT_BUCKET))\n \tasm_out_file = fopen (asm_file_name, \"w\");\n       else\n-\t/* Use fatal_error (UNKOWN_LOCATION) instead of just fatal_error to\n-\t   prevent gcc from printing the first line in the current file. */\n+\t/* Use UNKOWN_LOCATION to prevent gcc from printing the first\n+\t   line in the current file. */\n \tfatal_error (UNKNOWN_LOCATION,\n \t\t     \"input file %qs is the same as output file\",\n \t\t     asm_file_name);\n@@ -1155,7 +1155,7 @@ open_auxiliary_file (const char *ext)\n   filename = concat (aux_base_name, \".\", ext, NULL);\n   file = fopen (filename, \"w\");\n   if (!file)\n-    fatal_error (\"can%'t open %s for writing: %m\", filename);\n+    fatal_error (input_location, \"can%'t open %s for writing: %m\", filename);\n   free (filename);\n   return file;\n }\n@@ -1576,7 +1576,7 @@ process_options (void)\n     {\n       aux_info_file = fopen (aux_info_file_name, \"w\");\n       if (aux_info_file == 0)\n-\tfatal_error (\"can%'t open %s: %m\", aux_info_file_name);\n+\tfatal_error (input_location, \"can%'t open %s: %m\", aux_info_file_name);\n     }\n \n   if (!targetm_common.have_named_sections)\n@@ -1970,9 +1970,9 @@ finalize (bool no_backend)\n   if (asm_out_file)\n     {\n       if (ferror (asm_out_file) != 0)\n-\tfatal_error (\"error writing to %s: %m\", asm_file_name);\n+\tfatal_error (input_location, \"error writing to %s: %m\", asm_file_name);\n       if (fclose (asm_out_file) != 0)\n-\tfatal_error (\"error closing %s: %m\", asm_file_name);\n+\tfatal_error (input_location, \"error closing %s: %m\", asm_file_name);\n     }\n \n   if (stack_usage_file)"}, {"sha": "96f4adacedeb0decd426272771a17d15ec8eafc9", "filename": "gcc/tree-streamer-in.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Ftree-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Ftree-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-streamer-in.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -347,12 +347,14 @@ unpack_ts_function_decl_value_fields (struct bitpack_d *bp, tree expr)\n \t                                                                    12);\n       if (DECL_BUILT_IN_CLASS (expr) == BUILT_IN_NORMAL\n \t  && DECL_FUNCTION_CODE (expr) >= END_BUILTINS)\n-\tfatal_error (\"machine independent builtin code out of range\");\n+\tfatal_error (input_location,\n+\t\t     \"machine independent builtin code out of range\");\n       else if (DECL_BUILT_IN_CLASS (expr) == BUILT_IN_MD)\n \t{\n           tree result = targetm.builtin_decl (DECL_FUNCTION_CODE (expr), true);\n \t  if (!result || result == error_mark_node)\n-\t    fatal_error (\"target specific builtin not available\");\n+\t    fatal_error (input_location,\n+\t\t\t \"target specific builtin not available\");\n \t}\n     }\n }\n@@ -1138,7 +1140,8 @@ streamer_get_builtin_tree (struct lto_input_block *ib, struct data_in *data_in)\n   if (fclass == BUILT_IN_NORMAL)\n     {\n       if (fcode >= END_BUILTINS)\n-\tfatal_error (\"machine independent builtin code out of range\");\n+\tfatal_error (input_location,\n+\t\t     \"machine independent builtin code out of range\");\n       result = builtin_decl_explicit (fcode);\n       if (!result\n \t  && fcode > BEGIN_CHKP_BUILTINS\n@@ -1154,7 +1157,7 @@ streamer_get_builtin_tree (struct lto_input_block *ib, struct data_in *data_in)\n     {\n       result = targetm.builtin_decl (fcode, true);\n       if (!result || result == error_mark_node)\n-\tfatal_error (\"target specific builtin not available\");\n+\tfatal_error (input_location, \"target specific builtin not available\");\n     }\n   else\n     gcc_unreachable ();"}, {"sha": "3bd6eb41b7a679ecf4e793b383039a3bd659e91d", "filename": "gcc/varpool.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -316,7 +316,7 @@ varpool_node::get_constructor (void)\n   data = lto_get_section_data (file_data, LTO_section_function_body,\n \t\t\t       name, &len);\n   if (!data)\n-    fatal_error (\"%s: section %s is missing\",\n+    fatal_error (input_location, \"%s: section %s is missing\",\n \t\t file_data->file_name,\n \t\t name);\n "}, {"sha": "09e75a7138007d689d0f47632d1b9c3128b53ccd", "filename": "libcc1/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/libcc1%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/libcc1%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2FChangeLog?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -1,3 +1,8 @@\n+2015-01-30  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* plugin.cc: All callers of fatal_error changed to pass\n+\tinput_location as first argument.\n+\n 2015-01-09  Michael Collison  <michael.collison@linaro.org>\n \n \t* plugin.cc: Include hash-set.h, machmode.h, vec.h, double-int.h,"}, {"sha": "c4caf05907b57ff4fb33d952d9af0225a3b526a8", "filename": "libcc1/plugin.cc", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40fecdd62f7d293a214dd71b81de5e0f1099bba7/libcc1%2Fplugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40fecdd62f7d293a214dd71b81de5e0f1099bba7/libcc1%2Fplugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Fplugin.cc?ref=40fecdd62f7d293a214dd71b81de5e0f1099bba7", "patch": "@@ -836,13 +836,15 @@ plugin_init (struct plugin_name_args *plugin_info,\n \t  errno = 0;\n \t  fd = strtol (plugin_info->argv[i].value, &tail, 0);\n \t  if (*tail != '\\0' || errno != 0)\n-\t    fatal_error (\"%s: invalid file descriptor argument to plugin\",\n+\t    fatal_error (input_location,\n+\t\t\t \"%s: invalid file descriptor argument to plugin\",\n \t\t\t plugin_info->base_name);\n \t  break;\n \t}\n     }\n   if (fd == -1)\n-    fatal_error (\"%s: required plugin argument %<fd%> is missing\",\n+    fatal_error (input_location,\n+\t\t \"%s: required plugin argument %<fd%> is missing\",\n \t\t plugin_info->base_name);\n \n   current_context = new plugin_context (fd);\n@@ -851,9 +853,11 @@ plugin_init (struct plugin_name_args *plugin_info,\n   cc1_plugin::protocol_int version;\n   if (!current_context->require ('H')\n       || ! ::cc1_plugin::unmarshall (current_context, &version))\n-    fatal_error (\"%s: handshake failed\", plugin_info->base_name);\n+    fatal_error (input_location,\n+\t\t \"%s: handshake failed\", plugin_info->base_name);\n   if (version != GCC_C_FE_VERSION_0)\n-    fatal_error (\"%s: unknown version in handshake\", plugin_info->base_name);\n+    fatal_error (input_location,\n+\t\t \"%s: unknown version in handshake\", plugin_info->base_name);\n \n   register_callback (plugin_info->base_name, PLUGIN_PRAGMAS,\n \t\t     plugin_init_extra_pragmas, NULL);"}]}