{"sha": "2bd1333d629dababe7b7d18c46d59c0489929e8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJkMTMzM2Q2MjlkYWJhYmU3YjdkMThjNDZkNTljMDQ4OTkyOWU4Yg==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2010-04-14T22:05:32Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2010-04-14T22:05:32Z"}, "message": "double-int.h (HOST_BITS_PER_DOUBLE_INT): Define.\n\n\t* double-int.h (HOST_BITS_PER_DOUBLE_INT): Define.\n\t(double_int_not, double_int_lshift, double_int_rshift): Declare.\n\t(double_int_negative_p): Convert to static inline function.\n\t* double-int.c (double_int_lshift, double_int_lshift): Add new function.\n\t(double_int_negative_p): Remove.\n\t* tree.h (lshift_double, rshift_double): \n\t* tree.c (build_low_bits_mask): Clean up, use double_int_* functions.\n\t* fold-const.c (fold_convert_const_int_from_real,\n\tfold_convert_const_int_from_fixed, div_if_zero_remainder): (Ditto.).\n\t(lshift_double): Change type of arith argument to bool.\n\t(rshift_double): Change type of arith argument to bool. Correct\n\tcomment.\n\t* expmed.c (mask_rtx, lshift_value): (Ditto.).\n\nFrom-SVN: r158360", "tree": {"sha": "9138061992a73bba986379151a1a1c756a746bf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9138061992a73bba986379151a1a1c756a746bf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bd1333d629dababe7b7d18c46d59c0489929e8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bd1333d629dababe7b7d18c46d59c0489929e8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bd1333d629dababe7b7d18c46d59c0489929e8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bd1333d629dababe7b7d18c46d59c0489929e8b/comments", "author": null, "committer": null, "parents": [{"sha": "8b9b8e930562b7cf5598dc5b564fa71d989ebb3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b9b8e930562b7cf5598dc5b564fa71d989ebb3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b9b8e930562b7cf5598dc5b564fa71d989ebb3c"}], "stats": {"total": 235, "additions": 112, "deletions": 123}, "files": [{"sha": "35a1633303860683dce0f7e13b31917448abb5b5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bd1333d629dababe7b7d18c46d59c0489929e8b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bd1333d629dababe7b7d18c46d59c0489929e8b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2bd1333d629dababe7b7d18c46d59c0489929e8b", "patch": "@@ -1,3 +1,19 @@\n+2010-04-15  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* double-int.h (HOST_BITS_PER_DOUBLE_INT): Define.\n+\t(double_int_not, double_int_lshift, double_int_rshift): Declare.\n+\t(double_int_negative_p): Convert to static inline function.\n+\t* double-int.c (double_int_lshift, double_int_lshift): Add new function.\n+\t(double_int_negative_p): Remove.\n+\t* tree.h (lshift_double, rshift_double): \n+\t* tree.c (build_low_bits_mask): Clean up, use double_int_* functions.\n+\t* fold-const.c (fold_convert_const_int_from_real,\n+\tfold_convert_const_int_from_fixed, div_if_zero_remainder): (Ditto.).\n+\t(lshift_double): Change type of arith argument to bool.\n+\t(rshift_double): Change type of arith argument to bool. Correct\n+\tcomment.\n+\t* expmed.c (mask_rtx, lshift_value): (Ditto.).\n+\n 2010-04-14  Bernd Schmidt  <bernd.schmidt@codesourcery.com>\n \t\n \tPR target/21803"}, {"sha": "1a746814598a16f6e81d07c3444e881445f8fb91", "filename": "gcc/double-int.c", "status": "modified", "additions": 25, "deletions": 10, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bd1333d629dababe7b7d18c46d59c0489929e8b/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bd1333d629dababe7b7d18c46d59c0489929e8b/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=2bd1333d629dababe7b7d18c46d59c0489929e8b", "patch": "@@ -1,5 +1,5 @@\n /* Operations with long integers.\n-   Copyright (C) 2006, 2007, 2009 Free Software Foundation, Inc.\n+   Copyright (C) 2006, 2007, 2009, 2010 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -290,6 +290,30 @@ double_int_umod (double_int a, double_int b, unsigned code)\n   return double_int_mod (a, b, true, code);\n }\n \n+/* Shift A left by COUNT places keeping only PREC bits of result.  Shift\n+   right if COUNT is negative.  ARITH true specifies arithmetic shifting;\n+   otherwise use logical shift.  */\n+\n+double_int\n+double_int_lshift (double_int a, HOST_WIDE_INT count, unsigned int prec, bool arith)\n+{\n+  double_int ret;\n+  lshift_double (a.low, a.high, count, prec, &ret.low, &ret.high, arith);\n+  return ret;\n+}\n+\n+/* Shift A rigth by COUNT places keeping only PREC bits of result.  Shift\n+   left if COUNT is negative.  ARITH true specifies arithmetic shifting;\n+   otherwise use logical shift.  */\n+\n+double_int\n+double_int_rshift (double_int a, HOST_WIDE_INT count, unsigned int prec, bool arith)\n+{\n+  double_int ret;\n+  rshift_double (a.low, a.high, count, prec, &ret.low, &ret.high, arith);\n+  return ret;\n+}\n+\n /* Constructs tree in type TYPE from with value given by CST.  Signedness of CST\n    is assumed to be the same as the signedness of TYPE.  */\n \n@@ -314,15 +338,6 @@ double_int_fits_to_tree_p (const_tree type, double_int cst)\n   return double_int_equal_p (cst, ext);\n }\n \n-/* Returns true if CST is negative.  Of course, CST is considered to\n-   be signed.  */\n-\n-bool\n-double_int_negative_p (double_int cst)\n-{\n-  return cst.high < 0;\n-}\n-\n /* Returns -1 if A < B, 0 if A == B and 1 if A > B.  Signedness of the\n    comparison is given by UNS.  */\n "}, {"sha": "30e32fcde1397815cb3dd12485ba76b9c1c885cc", "filename": "gcc/double-int.h", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bd1333d629dababe7b7d18c46d59c0489929e8b/gcc%2Fdouble-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bd1333d629dababe7b7d18c46d59c0489929e8b/gcc%2Fdouble-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.h?ref=2bd1333d629dababe7b7d18c46d59c0489929e8b", "patch": "@@ -1,5 +1,5 @@\n /* Operations with long integers.\n-   Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.\n+   Copyright (C) 2006, 2007, 2008, 2010 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -57,6 +57,8 @@ typedef struct\n   HOST_WIDE_INT high;\n } double_int;\n \n+#define HOST_BITS_PER_DOUBLE_INT (2 * HOST_BITS_PER_WIDE_INT)\n+\n union tree_node;\n \n /* Constructors and conversions.  */\n@@ -127,7 +129,29 @@ double_int double_int_umod (double_int, double_int, unsigned);\n double_int double_int_divmod (double_int, double_int, bool, unsigned, double_int *);\n double_int double_int_sdivmod (double_int, double_int, unsigned, double_int *);\n double_int double_int_udivmod (double_int, double_int, unsigned, double_int *);\n-bool double_int_negative_p (double_int);\n+\n+/* Logical operations.  */\n+static inline double_int\n+double_int_not (double_int a)\n+{\n+  a.low = ~a.low;\n+  a.high = ~ a.high;\n+  return a;\n+}\n+\n+/* Shift operations.  */\n+double_int double_int_lshift (double_int, HOST_WIDE_INT, unsigned int, bool);\n+double_int double_int_rshift (double_int, HOST_WIDE_INT, unsigned int, bool);\n+\n+/* Returns true if CST is negative.  Of course, CST is considered to\n+   be signed.  */\n+\n+static inline bool\n+double_int_negative_p (double_int cst)\n+{\n+  return cst.high < 0;\n+}\n+\n int double_int_cmp (double_int, double_int, bool);\n int double_int_scmp (double_int, double_int);\n int double_int_ucmp (double_int, double_int);"}, {"sha": "44de4a6512e30c68816c5d3014c3da33fc9d7e09", "filename": "gcc/expmed.c", "status": "modified", "additions": 10, "deletions": 46, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bd1333d629dababe7b7d18c46d59c0489929e8b/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bd1333d629dababe7b7d18c46d59c0489929e8b/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=2bd1333d629dababe7b7d18c46d59c0489929e8b", "patch": "@@ -1839,39 +1839,15 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n static rtx\n mask_rtx (enum machine_mode mode, int bitpos, int bitsize, int complement)\n {\n-  HOST_WIDE_INT masklow, maskhigh;\n+  double_int mask;\n \n-  if (bitsize == 0)\n-    masklow = 0;\n-  else if (bitpos < HOST_BITS_PER_WIDE_INT)\n-    masklow = (HOST_WIDE_INT) -1 << bitpos;\n-  else\n-    masklow = 0;\n-\n-  if (bitpos + bitsize < HOST_BITS_PER_WIDE_INT)\n-    masklow &= ((unsigned HOST_WIDE_INT) -1\n-\t\t>> (HOST_BITS_PER_WIDE_INT - bitpos - bitsize));\n-\n-  if (bitpos <= HOST_BITS_PER_WIDE_INT)\n-    maskhigh = -1;\n-  else\n-    maskhigh = (HOST_WIDE_INT) -1 << (bitpos - HOST_BITS_PER_WIDE_INT);\n-\n-  if (bitsize == 0)\n-    maskhigh = 0;\n-  else if (bitpos + bitsize > HOST_BITS_PER_WIDE_INT)\n-    maskhigh &= ((unsigned HOST_WIDE_INT) -1\n-\t\t >> (2 * HOST_BITS_PER_WIDE_INT - bitpos - bitsize));\n-  else\n-    maskhigh = 0;\n+  mask = double_int_mask (bitsize);\n+  mask = double_int_lshift (mask, bitpos, HOST_BITS_PER_DOUBLE_INT, false);\n \n   if (complement)\n-    {\n-      maskhigh = ~maskhigh;\n-      masklow = ~masklow;\n-    }\n+    mask = double_int_not (mask);\n \n-  return immed_double_const (masklow, maskhigh, mode);\n+  return immed_double_const (mask.low, mask.high, mode);\n }\n \n /* Return a constant integer (CONST_INT or CONST_DOUBLE) rtx with the value\n@@ -1880,24 +1856,12 @@ mask_rtx (enum machine_mode mode, int bitpos, int bitsize, int complement)\n static rtx\n lshift_value (enum machine_mode mode, rtx value, int bitpos, int bitsize)\n {\n-  unsigned HOST_WIDE_INT v = INTVAL (value);\n-  HOST_WIDE_INT low, high;\n-\n-  if (bitsize < HOST_BITS_PER_WIDE_INT)\n-    v &= ~((HOST_WIDE_INT) -1 << bitsize);\n-\n-  if (bitpos < HOST_BITS_PER_WIDE_INT)\n-    {\n-      low = v << bitpos;\n-      high = (bitpos > 0 ? (v >> (HOST_BITS_PER_WIDE_INT - bitpos)) : 0);\n-    }\n-  else\n-    {\n-      low = 0;\n-      high = v << (bitpos - HOST_BITS_PER_WIDE_INT);\n-    }\n+  double_int val;\n+  \n+  val = double_int_zext (uhwi_to_double_int (INTVAL (value)), bitsize);\n+  val = double_int_lshift (val, bitpos, HOST_BITS_PER_DOUBLE_INT, false);\n \n-  return immed_double_const (low, high, mode);\n+  return immed_double_const (val.low, val.high, mode);\n }\n \f\n /* Extract a bit field that is split across two words"}, {"sha": "c3fcaa58c9623fe494431d84c22eb52959c57380", "filename": "gcc/fold-const.c", "status": "modified", "additions": 28, "deletions": 44, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bd1333d629dababe7b7d18c46d59c0489929e8b/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bd1333d629dababe7b7d18c46d59c0489929e8b/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=2bd1333d629dababe7b7d18c46d59c0489929e8b", "patch": "@@ -436,7 +436,7 @@ mul_double_with_sign (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n void\n lshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n \t       HOST_WIDE_INT count, unsigned int prec,\n-\t       unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv, int arith)\n+\t       unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv, bool arith)\n {\n   unsigned HOST_WIDE_INT signmask;\n \n@@ -491,15 +491,15 @@ lshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n }\n \n /* Shift the doubleword integer in L1, H1 right by COUNT places\n-   keeping only PREC bits of result.  COUNT must be positive.\n+   keeping only PREC bits of result.  Shift left if COUNT is negative.\n    ARITH nonzero specifies arithmetic shifting; otherwise use logical shift.\n    Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n \n void\n rshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n \t       HOST_WIDE_INT count, unsigned int prec,\n \t       unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv,\n-\t       int arith)\n+\t       bool arith)\n {\n   unsigned HOST_WIDE_INT signmask;\n \n@@ -881,10 +881,7 @@ div_and_round_double (enum tree_code code, int uns,\n tree\n div_if_zero_remainder (enum tree_code code, const_tree arg1, const_tree arg2)\n {\n-  unsigned HOST_WIDE_INT int1l, int2l;\n-  HOST_WIDE_INT int1h, int2h;\n-  unsigned HOST_WIDE_INT quol, reml;\n-  HOST_WIDE_INT quoh, remh;\n+  double_int quo, rem;\n   int uns;\n \n   /* The sign of the division is according to operand two, that\n@@ -895,17 +892,14 @@ div_if_zero_remainder (enum tree_code code, const_tree arg1, const_tree arg2)\n       && TYPE_IS_SIZETYPE (TREE_TYPE (arg2)))\n     uns = false;\n \n-  int1l = TREE_INT_CST_LOW (arg1);\n-  int1h = TREE_INT_CST_HIGH (arg1);\n-  int2l = TREE_INT_CST_LOW (arg2);\n-  int2h = TREE_INT_CST_HIGH (arg2);\n+  quo = double_int_divmod (tree_to_double_int (arg1),\n+\t\t\t   tree_to_double_int (arg2),\n+\t\t\t   uns, code, &rem);\n \n-  div_and_round_double (code, uns, int1l, int1h, int2l, int2h,\n-\t\t  \t&quol, &quoh, &reml, &remh);\n-  if (remh != 0 || reml != 0)\n-    return NULL_TREE;\n+  if (double_int_zero_p (rem))\n+    return build_int_cst_wide (TREE_TYPE (arg1), quo.low, quo.high);\n \n-  return build_int_cst_wide (TREE_TYPE (arg1), quol, quoh);\n+  return NULL_TREE; \n }\n \f\n /* This is nonzero if we should defer warnings about undefined\n@@ -2279,7 +2273,7 @@ fold_convert_const_int_from_real (enum tree_code code, tree type, const_tree arg\n      C and C++ standards that simply state that the behavior of\n      FP-to-integer conversion is unspecified upon overflow.  */\n \n-  HOST_WIDE_INT high, low;\n+  double_int val;\n   REAL_VALUE_TYPE r;\n   REAL_VALUE_TYPE x = TREE_REAL_CST (arg1);\n \n@@ -2297,8 +2291,7 @@ fold_convert_const_int_from_real (enum tree_code code, tree type, const_tree arg\n   if (REAL_VALUE_ISNAN (r))\n     {\n       overflow = 1;\n-      high = 0;\n-      low = 0;\n+      val = double_int_zero;\n     }\n \n   /* See if R is less than the lower bound or greater than the\n@@ -2311,8 +2304,7 @@ fold_convert_const_int_from_real (enum tree_code code, tree type, const_tree arg\n       if (REAL_VALUES_LESS (r, l))\n \t{\n \t  overflow = 1;\n-\t  high = TREE_INT_CST_HIGH (lt);\n-\t  low = TREE_INT_CST_LOW (lt);\n+\t  val = tree_to_double_int (lt);\n \t}\n     }\n \n@@ -2325,16 +2317,15 @@ fold_convert_const_int_from_real (enum tree_code code, tree type, const_tree arg\n \t  if (REAL_VALUES_LESS (u, r))\n \t    {\n \t      overflow = 1;\n-\t      high = TREE_INT_CST_HIGH (ut);\n-\t      low = TREE_INT_CST_LOW (ut);\n+\t      val = tree_to_double_int (ut);\n \t    }\n \t}\n     }\n \n   if (! overflow)\n-    REAL_VALUE_TO_INT (&low, &high, r);\n+    real_to_integer2 ((HOST_WIDE_INT *) &val.low, &val.high, &r);\n \n-  t = force_fit_type_double (type, low, high, -1,\n+  t = force_fit_type_double (type, val.low, val.high, -1,\n \t\t\t     overflow | TREE_OVERFLOW (arg1));\n   return t;\n }\n@@ -2354,39 +2345,32 @@ fold_convert_const_int_from_fixed (tree type, const_tree arg1)\n   mode = TREE_FIXED_CST (arg1).mode;\n   if (GET_MODE_FBIT (mode) < 2 * HOST_BITS_PER_WIDE_INT)\n     {\n-      lshift_double (temp.low, temp.high,\n-\t\t     - GET_MODE_FBIT (mode), 2 * HOST_BITS_PER_WIDE_INT,\n-\t\t     &temp.low, &temp.high, SIGNED_FIXED_POINT_MODE_P (mode));\n+      temp = double_int_rshift (temp, GET_MODE_FBIT (mode),\n+\t\t\t        HOST_BITS_PER_DOUBLE_INT,\n+\t\t\t        SIGNED_FIXED_POINT_MODE_P (mode));\n \n       /* Left shift temp to temp_trunc by fbit.  */\n-      lshift_double (temp.low, temp.high,\n-\t\t     GET_MODE_FBIT (mode), 2 * HOST_BITS_PER_WIDE_INT,\n-\t\t     &temp_trunc.low, &temp_trunc.high,\n-\t\t     SIGNED_FIXED_POINT_MODE_P (mode));\n+      temp_trunc = double_int_lshift (temp, GET_MODE_FBIT (mode),\n+\t\t\t\t      HOST_BITS_PER_DOUBLE_INT,\n+\t\t\t\t      SIGNED_FIXED_POINT_MODE_P (mode));\n     }\n   else\n     {\n-      temp.low = 0;\n-      temp.high = 0;\n-      temp_trunc.low = 0;\n-      temp_trunc.high = 0;\n+      temp = double_int_zero;\n+      temp_trunc = double_int_zero;\n     }\n \n   /* If FIXED_CST is negative, we need to round the value toward 0.\n      By checking if the fractional bits are not zero to add 1 to temp.  */\n-  if (SIGNED_FIXED_POINT_MODE_P (mode) && temp_trunc.high < 0\n+  if (SIGNED_FIXED_POINT_MODE_P (mode)\n+      && double_int_negative_p (temp_trunc)\n       && !double_int_equal_p (TREE_FIXED_CST (arg1).data, temp_trunc))\n-    {\n-      double_int one;\n-      one.low = 1;\n-      one.high = 0;\n-      temp = double_int_add (temp, one);\n-    }\n+    temp = double_int_add (temp, double_int_one);\n \n   /* Given a fixed-point constant, make new constant with new type,\n      appropriately sign-extended or truncated.  */\n   t = force_fit_type_double (type, temp.low, temp.high, -1,\n-\t\t\t     (temp.high < 0\n+\t\t\t     (double_int_negative_p (temp)\n \t\t \t      && (TYPE_UNSIGNED (type)\n \t\t\t\t  < TYPE_UNSIGNED (TREE_TYPE (arg1))))\n \t\t\t     | TREE_OVERFLOW (arg1));"}, {"sha": "83f1237fd85d84c00005ec9ee77b7a9241f48d40", "filename": "gcc/tree.c", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bd1333d629dababe7b7d18c46d59c0489929e8b/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bd1333d629dababe7b7d18c46d59c0489929e8b/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=2bd1333d629dababe7b7d18c46d59c0489929e8b", "patch": "@@ -1221,32 +1221,18 @@ build_int_cst_wide (tree type, unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n tree\n build_low_bits_mask (tree type, unsigned bits)\n {\n-  unsigned HOST_WIDE_INT low;\n-  HOST_WIDE_INT high;\n-  unsigned HOST_WIDE_INT all_ones = ~(unsigned HOST_WIDE_INT) 0;\n+  double_int mask;\n \n   gcc_assert (bits <= TYPE_PRECISION (type));\n \n   if (bits == TYPE_PRECISION (type)\n       && !TYPE_UNSIGNED (type))\n-    {\n-      /* Sign extended all-ones mask.  */\n-      low = all_ones;\n-      high = -1;\n-    }\n-  else if (bits <= HOST_BITS_PER_WIDE_INT)\n-    {\n-      low = all_ones >> (HOST_BITS_PER_WIDE_INT - bits);\n-      high = 0;\n-    }\n+    /* Sign extended all-ones mask.  */\n+    mask = double_int_minus_one;\n   else\n-    {\n-      bits -= HOST_BITS_PER_WIDE_INT;\n-      low = all_ones;\n-      high = all_ones >> (HOST_BITS_PER_WIDE_INT - bits);\n-    }\n+    mask = double_int_mask (bits);\n \n-  return build_int_cst_wide (type, low, high);\n+  return build_int_cst_wide (type, mask.low, mask.high);\n }\n \n /* Checks that X is integer constant that can be expressed in (unsigned)"}, {"sha": "e30981ef0ddabf1587dcd05f915612908397fc36", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bd1333d629dababe7b7d18c46d59c0489929e8b/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bd1333d629dababe7b7d18c46d59c0489929e8b/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=2bd1333d629dababe7b7d18c46d59c0489929e8b", "patch": "@@ -4841,10 +4841,10 @@ extern int mul_double_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n   mul_double_with_sign (l1, h1, l2, h2, lv, hv, false)\n extern void lshift_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t   HOST_WIDE_INT, unsigned int,\n-\t\t\t   unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, int);\n+\t\t\t   unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, bool);\n extern void rshift_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t   HOST_WIDE_INT, unsigned int,\n-\t\t\t   unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, int);\n+\t\t\t   unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, bool);\n extern void lrotate_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t    HOST_WIDE_INT, unsigned int,\n \t\t\t    unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);"}]}