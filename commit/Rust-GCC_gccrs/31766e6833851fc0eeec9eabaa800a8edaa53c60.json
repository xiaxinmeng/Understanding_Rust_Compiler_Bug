{"sha": "31766e6833851fc0eeec9eabaa800a8edaa53c60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE3NjZlNjgzMzg1MWZjMGVlZWM5ZWFiYWE4MDBhOGVkYWE1M2M2MA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-02-02T13:44:41Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-02-02T13:44:41Z"}, "message": "compiler: don't incorrectly evaluate range variable\n    \n    The language spec says that in `for i = range x`, in which there is no\n    second iteration variable, if len(x) is constant, then x is not\n    evaluated.  This only matters when x is an expression that panics but\n    whose type is an array type; in such a case, we should not evaluate x,\n    since len of any array type is a constant.\n    \n    Fixes golang/go#22313\n    \n    Reviewed-on: https://go-review.googlesource.com/91555\n\nFrom-SVN: r257330", "tree": {"sha": "5f72113b0c35cb7b1853573e3576880530b3dca3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f72113b0c35cb7b1853573e3576880530b3dca3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31766e6833851fc0eeec9eabaa800a8edaa53c60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31766e6833851fc0eeec9eabaa800a8edaa53c60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31766e6833851fc0eeec9eabaa800a8edaa53c60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31766e6833851fc0eeec9eabaa800a8edaa53c60/comments", "author": null, "committer": null, "parents": [{"sha": "eece7fe533e3741706d960d7cf0bae7fd0fc2755", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eece7fe533e3741706d960d7cf0bae7fd0fc2755", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eece7fe533e3741706d960d7cf0bae7fd0fc2755"}], "stats": {"total": 50, "additions": 37, "deletions": 13}, "files": [{"sha": "34d0e520fdffc784083c47a560af7571d74a7022", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31766e6833851fc0eeec9eabaa800a8edaa53c60/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31766e6833851fc0eeec9eabaa800a8edaa53c60/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=31766e6833851fc0eeec9eabaa800a8edaa53c60", "patch": "@@ -1,4 +1,4 @@\n-b332ba2f0d0302eeb01a228c217928296cec56f6\n+981e6621bcd48670d0b58e51e9eeffe549725378\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "0b1d7220b5e42d78bc6e495ae8a1aa52898eecdf", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31766e6833851fc0eeec9eabaa800a8edaa53c60/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31766e6833851fc0eeec9eabaa800a8edaa53c60/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=31766e6833851fc0eeec9eabaa800a8edaa53c60", "patch": "@@ -5307,19 +5307,33 @@ For_range_statement::do_lower(Gogo* gogo, Named_object*, Block* enclosing,\n       return Statement::make_error_statement(this->location());\n     }\n \n+  // If there is only one iteration variable, and len(this->range_) is\n+  // constant, then we do not evaluate the range variable.  len(x) is\n+  // a contant if x is a string constant or if x is an array.  If x is\n+  // a constant then evaluating it won't make any difference, so the\n+  // only case to consider is when x is an array.\n+  bool eval = true;\n+  if (this->value_var_ == NULL\n+      && range_type->array_type() != NULL\n+      && !range_type->is_slice_type())\n+    eval = false;\n+\n   Location loc = this->location();\n   Block* temp_block = new Block(enclosing, loc);\n \n   Named_object* range_object = NULL;\n   Temporary_statement* range_temp = NULL;\n-  Var_expression* ve = this->range_->var_expression();\n-  if (ve != NULL)\n-    range_object = ve->named_object();\n-  else\n+  if (eval)\n     {\n-      range_temp = Statement::make_temporary(NULL, this->range_, loc);\n-      temp_block->add_statement(range_temp);\n-      this->range_ = NULL;\n+      Var_expression* ve = this->range_->var_expression();\n+      if (ve != NULL)\n+\trange_object = ve->named_object();\n+      else\n+\t{\n+\t  range_temp = Statement::make_temporary(NULL, this->range_, loc);\n+\t  temp_block->add_statement(range_temp);\n+\t  this->range_ = NULL;\n+\t}\n     }\n \n   Temporary_statement* index_temp = Statement::make_temporary(index_type,\n@@ -5474,12 +5488,22 @@ For_range_statement::lower_range_array(Gogo* gogo,\n \n   Block* init = new Block(enclosing, loc);\n \n-  Expression* ref = this->make_range_ref(range_object, range_temp, loc);\n-  range_temp = Statement::make_temporary(NULL, ref, loc);\n-  Expression* len_call = this->call_builtin(gogo, \"len\", ref, loc);\n+  Expression* len_arg;\n+  if (range_object == NULL && range_temp == NULL)\n+    {\n+      // Don't evaluate this->range_, just get its length.\n+      len_arg = this->range_;\n+    }\n+  else\n+    {\n+      Expression* ref = this->make_range_ref(range_object, range_temp, loc);\n+      range_temp = Statement::make_temporary(NULL, ref, loc);\n+      init->add_statement(range_temp);\n+      len_arg = ref;\n+    }\n+  Expression* len_call = this->call_builtin(gogo, \"len\", len_arg, loc);\n   Temporary_statement* len_temp = Statement::make_temporary(index_temp->type(),\n \t\t\t\t\t\t\t    len_call, loc);\n-  init->add_statement(range_temp);\n   init->add_statement(len_temp);\n \n   Expression* zexpr = Expression::make_integer_ul(0, NULL, loc);\n@@ -5495,7 +5519,7 @@ For_range_statement::lower_range_array(Gogo* gogo,\n   // Set *PCOND to\n   //   index_temp < len_temp\n \n-  ref = Expression::make_temporary_reference(index_temp, loc);\n+  Expression* ref = Expression::make_temporary_reference(index_temp, loc);\n   Expression* ref2 = Expression::make_temporary_reference(len_temp, loc);\n   Expression* lt = Expression::make_binary(OPERATOR_LT, ref, ref2, loc);\n "}]}