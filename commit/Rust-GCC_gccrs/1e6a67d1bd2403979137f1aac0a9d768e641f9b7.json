{"sha": "1e6a67d1bd2403979137f1aac0a9d768e641f9b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU2YTY3ZDFiZDI0MDM5NzkxMzdmMWFhYzBhOWQ3NjhlNjQxZjliNw==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-07-07T07:13:13Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-07-07T07:13:13Z"}, "message": "avr.md (*reload_insi): Change predicate #1 to const_int_operand.\n\n\t\n\t* config/avr/avr.md (*reload_insi): Change predicate #1 to\n\tconst_int_operand.  Ditto for peep2 producing this insn.\n\tAdd argument to output_reload_insisf call.\n\t(*movsi,*movsf): Add argument to output_movsisf call.\n\t(*reload_insf): New insn and new peep2 to produce it.\n\t* config/avr/avr-protos.h (output_movsisf): Change prototype.\n\t(output_reload_insisf): Change prototype.\n\t* config/avr/avr.c (avr_asm_len): New function.\n\t(output_reload_insisf): Rewrite.\n\t(output_movsisf): Change prototype.  output_reload_insisf for\n\tall CONST_INT and CONST_DOUBLE.  ALlow moving 0.0f to memory.\n\t(adjust_insn_length): Add argument to output_movsisf and\n\toutput_reload_insisf call.\n\nFrom-SVN: r175956", "tree": {"sha": "510d61699c33365438dbce6a67e595a914c0436c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/510d61699c33365438dbce6a67e595a914c0436c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e6a67d1bd2403979137f1aac0a9d768e641f9b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e6a67d1bd2403979137f1aac0a9d768e641f9b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e6a67d1bd2403979137f1aac0a9d768e641f9b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e6a67d1bd2403979137f1aac0a9d768e641f9b7/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffca9d534c9e8cca5aa1eee5ce28d9960b6d1179", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffca9d534c9e8cca5aa1eee5ce28d9960b6d1179", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffca9d534c9e8cca5aa1eee5ce28d9960b6d1179"}], "stats": {"total": 387, "additions": 274, "deletions": 113}, "files": [{"sha": "8429d5c6064ce00308c6a18cca777ec38aa9c501", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a67d1bd2403979137f1aac0a9d768e641f9b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a67d1bd2403979137f1aac0a9d768e641f9b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e6a67d1bd2403979137f1aac0a9d768e641f9b7", "patch": "@@ -1,3 +1,19 @@\n+2011-07-07  Georg-Johann Lay  <avr@gjlay.de>\n+\t\n+\t* config/avr/avr.md (*reload_insi): Change predicate #1 to\n+\tconst_int_operand.  Ditto for peep2 producing this insn.\n+\tAdd argument to output_reload_insisf call.\n+\t(*movsi,*movsf): Add argument to output_movsisf call.\n+\t(*reload_insf): New insn and new peep2 to produce it.\n+\t* config/avr/avr-protos.h (output_movsisf): Change prototype.\n+\t(output_reload_insisf): Change prototype.\n+\t* config/avr/avr.c (avr_asm_len): New function.\n+\t(output_reload_insisf): Rewrite.\n+\t(output_movsisf): Change prototype.  output_reload_insisf for\n+\tall CONST_INT and CONST_DOUBLE.  ALlow moving 0.0f to memory.\n+\t(adjust_insn_length): Add argument to output_movsisf and\n+\toutput_reload_insisf call.\n+\n 2011-07-07  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* emit-rtl.c (paradoxical_subreg_p): New function."}, {"sha": "718aa420c741a9eb8574f749cf48237626d15df7", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a67d1bd2403979137f1aac0a9d768e641f9b7/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a67d1bd2403979137f1aac0a9d768e641f9b7/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=1e6a67d1bd2403979137f1aac0a9d768e641f9b7", "patch": "@@ -56,7 +56,7 @@ extern const char *out_movhi_r_mr (rtx insn, rtx op[], int *l);\n extern const char *out_movhi_mr_r (rtx insn, rtx op[], int *l);\n extern const char *out_movsi_r_mr (rtx insn, rtx op[], int *l);\n extern const char *out_movsi_mr_r (rtx insn, rtx op[], int *l);\n-extern const char *output_movsisf (rtx insn, rtx operands[], int *l);\n+extern const char *output_movsisf (rtx insn, rtx operands[], rtx clobber, int *l);\n extern const char *out_tstsi (rtx insn, rtx src, int *l);\n extern const char *out_tsthi (rtx insn, rtx src, int *l);\n extern const char *ret_cond_branch (rtx x, int len, int reverse);\n@@ -85,7 +85,7 @@ extern const char *avr_out_sbxx_branch (rtx insn, rtx operands[]);\n extern int extra_constraint_Q (rtx x);\n extern int adjust_insn_length (rtx insn, int len);\n extern const char *output_reload_inhi (rtx insn, rtx *operands, int *len);\n-extern const char *output_reload_insisf (rtx insn, rtx *operands, int *len);\n+extern const char *output_reload_insisf (rtx insn, rtx *operands, rtx clobber, int *len);\n extern enum reg_class secondary_input_reload_class (enum reg_class,\n \t\t\t\t\t\t    enum machine_mode,\n \t\t\t\t\t\t    rtx);"}, {"sha": "17020ce5ced48023702cbb657d299e86efbdeb3b", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 215, "deletions": 100, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a67d1bd2403979137f1aac0a9d768e641f9b7/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a67d1bd2403979137f1aac0a9d768e641f9b7/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=1e6a67d1bd2403979137f1aac0a9d768e641f9b7", "patch": "@@ -1184,6 +1184,32 @@ avr_legitimize_address (rtx x, rtx oldx, enum machine_mode mode)\n }\n \n \n+/* Helper function to print assembler resp. track instruction\n+   sequence lengths.\n+   \n+   If PLEN == NULL:\n+       Output assembler code from template TPL with operands supplied\n+       by OPERANDS.  This is just forwarding to output_asm_insn.\n+   \n+   If PLEN != NULL:\n+       Add N_WORDS to *PLEN.\n+       Don't output anything.\n+*/\n+\n+static void\n+avr_asm_len (const char* tpl, rtx* operands, int* plen, int n_words)\n+{\n+  if (NULL == plen)\n+    {\n+      output_asm_insn (tpl, operands);\n+    }\n+  else\n+    {\n+      *plen += n_words;\n+    }\n+}\n+\n+\n /* Return a pointer register name as a string.  */\n \n static const char *\n@@ -2600,7 +2626,7 @@ out_movsi_mr_r (rtx insn, rtx op[], int *l)\n }\n \n const char *\n-output_movsisf(rtx insn, rtx operands[], int *l)\n+output_movsisf (rtx insn, rtx operands[], rtx clobber_reg, int *l)\n {\n   int dummy;\n   rtx dest = operands[0];\n@@ -2643,6 +2669,11 @@ output_movsisf(rtx insn, rtx operands[], int *l)\n \t\t      AS2 (mov,%D0,%D1));\n \t    }\n \t}\n+      else if (CONST_INT_P (src)\n+               || CONST_DOUBLE_P (src))\n+        {\n+          return output_reload_insisf (insn, operands, clobber_reg, real_l);\n+        }\n       else if (CONSTANT_P (src))\n \t{\n \t  if (test_hard_reg_class (LD_REGS, dest)) /* ldi d,i */\n@@ -2653,68 +2684,6 @@ output_movsisf(rtx insn, rtx operands[], int *l)\n \t\t      AS2 (ldi,%C0,hlo8(%1)) CR_TAB\n \t\t      AS2 (ldi,%D0,hhi8(%1)));\n \t    }\n-\t  \n-\t  if (GET_CODE (src) == CONST_INT)\n-\t    {\n-\t      const char *const clr_op0 =\n-\t\tAVR_HAVE_MOVW ? (AS1 (clr,%A0) CR_TAB\n-\t\t\t\tAS1 (clr,%B0) CR_TAB\n-\t\t\t\tAS2 (movw,%C0,%A0))\n-\t\t\t     : (AS1 (clr,%A0) CR_TAB\n-\t\t\t\tAS1 (clr,%B0) CR_TAB\n-\t\t\t\tAS1 (clr,%C0) CR_TAB\n-\t\t\t\tAS1 (clr,%D0));\n-\n-\t      if (src == const0_rtx) /* mov r,L */\n-\t\t{\n-\t\t  *l = AVR_HAVE_MOVW ? 3 : 4;\n-\t\t  return clr_op0;\n-\t\t}\n-\t      else if (src == const1_rtx)\n-\t\t{\n-\t\t  if (!real_l)\n-\t\t    output_asm_insn (clr_op0, operands);\n-\t\t  *l = AVR_HAVE_MOVW ? 4 : 5;\n-\t\t  return AS1 (inc,%A0);\n-\t\t}\n-\t      else if (src == constm1_rtx)\n-\t\t{\n-\t\t  /* Immediate constants -1 to any register */\n-\t\t  if (AVR_HAVE_MOVW)\n-\t\t    {\n-\t\t      *l = 4;\n-\t\t      return (AS1 (clr,%A0)     CR_TAB\n-\t\t\t      AS1 (dec,%A0)     CR_TAB\n-\t\t\t      AS2 (mov,%B0,%A0) CR_TAB\n-\t\t\t      AS2 (movw,%C0,%A0));\n-\t\t    }\n-\t\t  *l = 5;\n-\t\t  return (AS1 (clr,%A0)     CR_TAB\n-\t\t\t  AS1 (dec,%A0)     CR_TAB\n-\t\t\t  AS2 (mov,%B0,%A0) CR_TAB\n-\t\t\t  AS2 (mov,%C0,%A0) CR_TAB\n-\t\t\t  AS2 (mov,%D0,%A0));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  int bit_nr = exact_log2 (INTVAL (src));\n-\n-\t\t  if (bit_nr >= 0)\n-\t\t    {\n-\t\t      *l = AVR_HAVE_MOVW ? 5 : 6;\n-\t\t      if (!real_l)\n-\t\t\t{\n-\t\t\t  output_asm_insn (clr_op0, operands);\n-\t\t\t  output_asm_insn (\"set\", operands);\n-\t\t\t}\n-\t\t      if (!real_l)\n-\t\t\tavr_output_bld (operands, bit_nr);\n-\n-\t\t      return \"\";\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  \n \t  /* Last resort, better than loading from memory.  */\n \t  *l = 10;\n \t  return (AS2 (mov,__tmp_reg__,r31) CR_TAB\n@@ -2735,7 +2704,7 @@ output_movsisf(rtx insn, rtx operands[], int *l)\n     {\n       const char *templ;\n \n-      if (src == const0_rtx)\n+      if (src == CONST0_RTX (GET_MODE (dest)))\n \t  operands[1] = zero_reg_rtx;\n \n       templ = out_movsi_mr_r (insn, operands, real_l);\n@@ -4612,7 +4581,7 @@ adjust_insn_length (rtx insn, int len)\n \t      break;\n \t    case SImode:\n \t    case SFmode:\n-\t      output_movsisf (insn, op, &len);\n+\t      output_movsisf (insn, op, NULL_RTX, &len);\n \t      break;\n \t    default:\n \t      break;\n@@ -4683,7 +4652,7 @@ adjust_insn_length (rtx insn, int len)\n \t      break;\n \t    case SImode:\n \t    case SFmode:\n-\t      output_reload_insisf (insn, op, &len);\n+\t      output_reload_insisf (insn, op, XEXP (op[2], 0), &len);\n \t      break;\n \t    default:\n \t      break;\n@@ -6212,53 +6181,199 @@ output_reload_inhi (rtx insn ATTRIBUTE_UNUSED, rtx *operands, int *len)\n }\n \n \n+/* Reload a SI or SF compile time constant (OP[1]) into a GPR (OP[0]).\n+   CLOBBER_REG is a QI clobber reg needed to move vast majority of consts\n+   into a NO_LD_REGS.  If CLOBBER_REG is NULL_RTX we either don't need a\n+   clobber reg or have to cook one up.\n+\n+   LEN == NULL: Output instructions.\n+   \n+   LEN != NULL: Output nothing.  Increment *LEN by number of words occupied\n+                by the insns printed.\n+\n+   Return \"\".  */\n+\n const char *\n-output_reload_insisf (rtx insn ATTRIBUTE_UNUSED, rtx *operands, int *len)\n+output_reload_insisf (rtx insn ATTRIBUTE_UNUSED,\n+                      rtx *op, rtx clobber_reg, int *len)\n {\n-  rtx src = operands[1];\n-  int cnst = (GET_CODE (src) == CONST_INT);\n+  rtx src = op[1];\n+  rtx dest = op[0];\n+  rtx xval, xdest[4];\n+  int ival[4];\n+  int clobber_val = 1234;\n+  bool cooked_clobber_p = false;\n+  bool set_p = false;\n+  unsigned int n;\n+  enum machine_mode mode = GET_MODE (dest);\n+  \n+  gcc_assert (REG_P (dest));\n \n   if (len)\n+    *len = 0;\n+  \n+  /* (REG:SI 14) is special: It's neither in LD_REGS nor in NO_LD_REGS\n+     but has some subregs that are in LD_REGS.  Use the MSB (REG:QI 17).  */\n+  \n+  if (14 == REGNO (dest))\n     {\n-      if (cnst)\n-\t*len = 4 + ((INTVAL (src) & 0xff) != 0)\n-\t\t+ ((INTVAL (src) & 0xff00) != 0)\n-\t\t+ ((INTVAL (src) & 0xff0000) != 0)\n-\t\t+ ((INTVAL (src) & 0xff000000) != 0);\n-      else\n-\t*len = 8;\n-\n-      return \"\";\n+      clobber_reg = gen_rtx_REG (QImode, 17);\n     }\n \n-  if (cnst && ((INTVAL (src) & 0xff) == 0))\n-    output_asm_insn (AS2 (mov, %A0, __zero_reg__), operands);\n-  else\n-    {\n-      output_asm_insn (AS2 (ldi, %2, lo8(%1)), operands);\n-      output_asm_insn (AS2 (mov, %A0, %2), operands);\n-    }\n-  if (cnst && ((INTVAL (src) & 0xff00) == 0))\n-    output_asm_insn (AS2 (mov, %B0, __zero_reg__), operands);\n-  else\n+  /* We might need a clobber reg but don't have one.  Look at the value\n+     to be loaded more closely.  A clobber is only needed if it contains\n+     a byte that is neither 0, -1 or a power of 2.  */\n+  \n+  if (NULL_RTX == clobber_reg\n+      && !test_hard_reg_class (LD_REGS, dest))\n     {\n-      output_asm_insn (AS2 (ldi, %2, hi8(%1)), operands);\n-      output_asm_insn (AS2 (mov, %B0, %2), operands);\n+      for (n = 0; n < GET_MODE_SIZE (mode); n++)\n+        {\n+          xval = simplify_gen_subreg (QImode, src, mode, n);\n+\n+          if (!(const0_rtx == xval\n+                || constm1_rtx == xval\n+                || single_one_operand (xval, QImode)))\n+            {\n+              /* We have no clobber reg but need one.  Cook one up.\n+                 That's cheaper than loading from constant pool.  */\n+              \n+              cooked_clobber_p = true;\n+              clobber_reg = gen_rtx_REG (QImode, 31);\n+              avr_asm_len (\"mov __tmp_reg__,%0\", &clobber_reg, len, 1);\n+              break;\n+            }\n+        }\n     }\n-  if (cnst && ((INTVAL (src) & 0xff0000) == 0))\n-    output_asm_insn (AS2 (mov, %C0, __zero_reg__), operands);\n-  else\n+\n+  /* Now start filling DEST from LSB to MSB.  */\n+  \n+  for (n = 0; n < GET_MODE_SIZE (mode); n++)\n     {\n-      output_asm_insn (AS2 (ldi, %2, hlo8(%1)), operands);\n-      output_asm_insn (AS2 (mov, %C0, %2), operands);\n+      bool done_byte = false;\n+      unsigned int j;\n+      rtx xop[3];\n+\n+      /* Crop the n-th sub-byte.  */\n+      \n+      xval = simplify_gen_subreg (QImode, src, mode, n);\n+      xdest[n] = simplify_gen_subreg (QImode, dest, mode, n);\n+      ival[n] = INTVAL (xval);\n+\n+      /* Look if we can reuse the low word by means of MOVW.  */\n+      \n+      if (n == 2\n+          && AVR_HAVE_MOVW)\n+        {\n+          rtx lo16 = simplify_gen_subreg (HImode, src, mode, 0);\n+          rtx hi16 = simplify_gen_subreg (HImode, src, mode, 2);\n+\n+          if (INTVAL (lo16) == INTVAL (hi16))\n+            {\n+              avr_asm_len (\"movw %C0,%A0\", &op[0], len, 1);\n+              break;\n+            }\n+        }\n+\n+      /* Use CLR to zero a value so that cc0 is set as expected\n+         for zero.  */\n+      \n+      if (ival[n] == 0)\n+        {\n+          avr_asm_len (\"clr %0\", &xdest[n], len, 1);\n+          continue;\n+        }\n+\n+      if (clobber_val == ival[n]\n+          && REGNO (clobber_reg) == REGNO (xdest[n]))\n+        {\n+          continue;\n+        }\n+\n+      /* LD_REGS can use LDI to move a constant value */\n+      \n+      if (test_hard_reg_class (LD_REGS, xdest[n]))\n+        {\n+          xop[0] = xdest[n];\n+          xop[1] = xval;\n+          avr_asm_len (\"ldi %0,lo8(%1)\", xop, len, 1);\n+          continue;\n+        }\n+\n+      /* Try to reuse value already loaded in some lower byte. */\n+      \n+      for (j = 0; j < n; j++)\n+        if (ival[j] == ival[n])\n+          {\n+            xop[0] = xdest[n];\n+            xop[1] = xdest[j];\n+            \n+            avr_asm_len (\"mov %0,%1\", xop, len, 1);\n+            done_byte = true;\n+            break;\n+          }\n+\n+      if (done_byte)\n+        continue;\n+\n+      /* Need no clobber reg for -1: Use CLR/DEC */\n+      \n+      if (-1 == ival[n])\n+        {\n+          avr_asm_len (\"clr %0\" CR_TAB\n+                       \"dec %0\", &xdest[n], len, 2);\n+          continue;\n+        }\n+\n+      /* Use T flag or INC to manage powers of 2 if we have\n+         no clobber reg.  */\n+\n+      if (NULL_RTX == clobber_reg\n+          && single_one_operand (xval, QImode))\n+        {\n+          if (1 == ival[n])\n+            {\n+              avr_asm_len (\"clr %0\" CR_TAB\n+                           \"inc %0\", &xdest[n], len, 2);\n+              continue;\n+            }\n+          \n+          xop[0] = xdest[n];\n+          xop[1] = GEN_INT (exact_log2 (ival[n] & GET_MODE_MASK (QImode)));\n+\n+          gcc_assert (constm1_rtx != xop[1]);\n+\n+          if (!set_p)\n+            {\n+              set_p = true;\n+              avr_asm_len (\"set\", xop, len, 1);\n+            }\n+\n+          avr_asm_len (\"clr %0\" CR_TAB\n+                       \"bld %0,%1\", xop, len, 2);\n+          continue;\n+        }\n+\n+      /* We actually need the LD_REGS clobber reg.  */\n+\n+      gcc_assert (NULL_RTX != clobber_reg);\n+        \n+      xop[0] = xdest[n];\n+      xop[1] = xval;\n+      xop[2] = clobber_reg;\n+      clobber_val = ival[n];\n+        \n+      avr_asm_len (\"ldi %2,lo8(%1)\" CR_TAB\n+                   \"mov %0,%2\", xop, len, 2);\n     }\n-  if (cnst && ((INTVAL (src) & 0xff000000) == 0))\n-    output_asm_insn (AS2 (mov, %D0, __zero_reg__), operands);\n-  else\n+  \n+  /* If we cooked up a clobber reg above, restore it.  */\n+  \n+  if (cooked_clobber_p)\n     {\n-      output_asm_insn (AS2 (ldi, %2, hhi8(%1)), operands);\n-      output_asm_insn (AS2 (mov, %D0, %2), operands);\n+      avr_asm_len (\"mov %0,__tmp_reg__\", &clobber_reg, len, 1);\n     }\n+  \n   return \"\";\n }\n "}, {"sha": "4637abf7d0894afaead32974581bd84c192ba80e", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 41, "deletions": 11, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e6a67d1bd2403979137f1aac0a9d768e641f9b7/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e6a67d1bd2403979137f1aac0a9d768e641f9b7/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=1e6a67d1bd2403979137f1aac0a9d768e641f9b7", "patch": "@@ -402,10 +402,10 @@\n \n \n \n-(define_peephole2 ; movsi_lreg_const\n+(define_peephole2 ; *reload_insi\n   [(match_scratch:QI 2 \"d\")\n    (set (match_operand:SI 0 \"l_register_operand\" \"\")\n-        (match_operand:SI 1 \"immediate_operand\" \"\"))\n+        (match_operand:SI 1 \"const_int_operand\" \"\"))\n    (match_dup 2)]\n   \"(operands[1] != const0_rtx\n     && operands[1] != constm1_rtx)\"\n@@ -416,22 +416,26 @@\n ;; '*' because it is not used in rtl generation.\n (define_insn \"*reload_insi\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-        (match_operand:SI 1 \"immediate_operand\" \"i\"))\n+        (match_operand:SI 1 \"const_int_operand\" \"n\"))\n    (clobber (match_operand:QI 2 \"register_operand\" \"=&d\"))]\n   \"reload_completed\"\n-  \"* return output_reload_insisf (insn, operands, NULL);\"\n+  {\n+    return output_reload_insisf (insn, operands, operands[2], NULL);\n+  }\n   [(set_attr \"length\" \"8\")\n-   (set_attr \"cc\" \"none\")])\n+   (set_attr \"cc\" \"clobber\")])\n \n \n (define_insn \"*movsi\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,Qm,!d,r\")\n         (match_operand:SI 1 \"general_operand\"       \"r,L,Qm,rL,i,i\"))]\n   \"(register_operand (operands[0],SImode)\n     || register_operand (operands[1],SImode) || const0_rtx == operands[1])\"\n-  \"* return output_movsisf (insn, operands, NULL);\"\n+  {\n+    return output_movsisf (insn, operands, NULL_RTX, NULL);\n+  }\n   [(set_attr \"length\" \"4,4,8,9,4,10\")\n-   (set_attr \"cc\" \"none,set_zn,clobber,clobber,none,clobber\")])\n+   (set_attr \"cc\" \"none,set_zn,clobber,clobber,clobber,clobber\")])\n \n ;; fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n ;; move floating point numbers (32 bit)\n@@ -452,12 +456,38 @@\n \n (define_insn \"*movsf\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,r,Qm,!d,r\")\n-        (match_operand:SF 1 \"general_operand\"       \"r,G,Qm,r,F,F\"))]\n+        (match_operand:SF 1 \"general_operand\"       \"r,G,Qm,rG,F,F\"))]\n   \"register_operand (operands[0], SFmode)\n-   || register_operand (operands[1], SFmode)\"\n-  \"* return output_movsisf (insn, operands, NULL);\"\n+   || register_operand (operands[1], SFmode)\n+   || operands[1] == CONST0_RTX (SFmode)\"\n+  {\n+    return output_movsisf (insn, operands, NULL_RTX, NULL);\n+  }\n   [(set_attr \"length\" \"4,4,8,9,4,10\")\n-   (set_attr \"cc\" \"none,set_zn,clobber,clobber,none,clobber\")])\n+   (set_attr \"cc\" \"none,set_zn,clobber,clobber,clobber,clobber\")])\n+\n+(define_peephole2 ; *reload_insf\n+  [(match_scratch:QI 2 \"d\")\n+   (set (match_operand:SF 0 \"l_register_operand\" \"\")\n+        (match_operand:SF 1 \"const_double_operand\" \"\"))\n+   (match_dup 2)]\n+  \"operands[1] != CONST0_RTX (SFmode)\"\n+  [(parallel [(set (match_dup 0) \n+                   (match_dup 1))\n+              (clobber (match_dup 2))])]\n+  \"\")\n+\n+;; '*' because it is not used in rtl generation.\n+(define_insn \"*reload_insf\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+        (match_operand:SF 1 \"const_double_operand\" \"F\"))\n+   (clobber (match_operand:QI 2 \"register_operand\" \"=&d\"))]\n+  \"reload_completed\"\n+  {\n+    return output_reload_insisf (insn, operands, operands[2], NULL);\n+  }\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"cc\" \"clobber\")])\n \n ;;=========================================================================\n ;; move string (like memcpy)"}]}