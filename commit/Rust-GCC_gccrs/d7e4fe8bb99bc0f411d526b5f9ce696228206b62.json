{"sha": "d7e4fe8bb99bc0f411d526b5f9ce696228206b62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdlNGZlOGJiOTliYzBmNDExZDUyNmI1ZjljZTY5NjIyODIwNmI2Mg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-11T22:35:04Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-11T22:35:04Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r298", "tree": {"sha": "b954eccd3c9415d4b2d64c13612f0fd31c2a1c23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b954eccd3c9415d4b2d64c13612f0fd31c2a1c23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7e4fe8bb99bc0f411d526b5f9ce696228206b62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7e4fe8bb99bc0f411d526b5f9ce696228206b62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7e4fe8bb99bc0f411d526b5f9ce696228206b62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7e4fe8bb99bc0f411d526b5f9ce696228206b62/comments", "author": null, "committer": null, "parents": [{"sha": "e75b25e7bdfce32e03aedf7a7f6a3f91e8f5c237", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e75b25e7bdfce32e03aedf7a7f6a3f91e8f5c237", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e75b25e7bdfce32e03aedf7a7f6a3f91e8f5c237"}], "stats": {"total": 87, "additions": 70, "deletions": 17}, "files": [{"sha": "7a1ec3ccfeeda01e4d9d15b49a6510deebac00eb", "filename": "gcc/flow.c", "status": "modified", "additions": 70, "deletions": 17, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e4fe8bb99bc0f411d526b5f9ce696228206b62/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e4fe8bb99bc0f411d526b5f9ce696228206b62/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=d7e4fe8bb99bc0f411d526b5f9ce696228206b62", "patch": "@@ -309,6 +309,7 @@ flow_analysis (f, nregs, file)\n {\n   register rtx insn;\n   register int i;\n+  rtx nonlocal_label_list = nonlocal_label_rtx_list ();\n \n #ifdef ELIMINABLE_REGS\n   static struct {int from, to; } eliminables[] = ELIMINABLE_REGS;\n@@ -340,9 +341,11 @@ flow_analysis (f, nregs, file)\n \tif (INSN_UID (insn) > max_uid_for_flow)\n \t  max_uid_for_flow = INSN_UID (insn);\n \tif (code == CODE_LABEL\n-\t    || (prev_code != INSN && prev_code != CALL_INSN\n-\t\t&& prev_code != CODE_LABEL\n-\t\t&& GET_RTX_CLASS (code) == 'i'))\n+\t    || (GET_RTX_CLASS (code) == 'i'\n+\t\t&& (prev_code == JUMP_INSN\n+\t\t    || (prev_code == CALL_INSN\n+\t\t\t&& nonlocal_label_list != 0)\n+\t\t    || prev_code == BARRIER)))\n \t  i++;\n \tif (code != NOTE)\n \t  prev_code = code;\n@@ -368,7 +371,7 @@ flow_analysis (f, nregs, file)\n   uid_volatile = (char *) alloca (max_uid_for_flow + 1);\n   bzero (uid_volatile, max_uid_for_flow + 1);\n \n-  find_basic_blocks (f);\n+  find_basic_blocks (f, nonlocal_label_list);\n   life_analysis (f, nregs);\n   if (file)\n     dump_flow_info (file);\n@@ -381,11 +384,13 @@ flow_analysis (f, nregs, file)\n /* Find all basic blocks of the function whose first insn is F.\n    Store the correct data in the tables that describe the basic blocks,\n    set up the chains of references for each CODE_LABEL, and\n-   delete any entire basic blocks that cannot be reached.  */\n+   delete any entire basic blocks that cannot be reached.\n+\n+   NONLOCAL_LABEL_LIST is the same local variable from flow_analysis.  */\n \n static void\n-find_basic_blocks (f)\n-     rtx f;\n+find_basic_blocks (f, nonlocal_label_list)\n+     rtx f, nonlocal_label_list;\n {\n   register rtx insn;\n   register int i;\n@@ -424,10 +429,13 @@ find_basic_blocks (f)\n \t    else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n \t      depth--;\n \t  }\n+\t/* A basic block starts at label, or after something that can jump.  */\n \telse if (code == CODE_LABEL\n-\t\t || (prev_code != INSN && prev_code != CALL_INSN\n-\t\t     && prev_code != CODE_LABEL\n-\t\t     && GET_RTX_CLASS (code) == 'i'))\n+\t\t || (GET_RTX_CLASS (code) == 'i'\n+\t\t     && (prev_code == JUMP_INSN\n+\t\t\t || (prev_code == CALL_INSN\n+\t\t\t     && nonlocal_label_list != 0)\n+\t\t\t || prev_code == BARRIER)))\n \t  {\n \t    basic_block_head[++i] = insn;\n \t    basic_block_end[i] = insn;\n@@ -457,13 +465,27 @@ find_basic_blocks (f)\n \t  }\n \n \tBLOCK_NUM (insn) = i;\n-\tif (code != NOTE)\n+\n+\t/* Don't separare a CALL_INSN from following CLOBBER insns.  This is\n+\t   a kludge that will go away when each CALL_INSN records its\n+\t   USE and CLOBBERs.  */\n+\n+\tif (code != NOTE\n+\t    && ! (prev_code == CALL_INSN && code == INSN\n+\t\t  && GET_CODE (PATTERN (insn)) == CLOBBER))\n \t  prev_code = code;\n       }\n     if (i + 1 != n_basic_blocks)\n       abort ();\n   }\n \n+  /* Don't delete the labels that are referenced by non-jump instructions.  */\n+  {\n+    register rtx x;\n+    for (x = label_value_list; x; x = XEXP (x, 1))\n+      block_live[BLOCK_NUM (XEXP (x, 0))] = 1;\n+  }\n+\n   /* Record which basic blocks control can drop in to.  */\n \n   {\n@@ -508,6 +530,27 @@ find_basic_blocks (f)\n \t\t\t      insn, 0);\n \t  }\n \n+      /* Find all call insns and mark them as possibly jumping\n+\t to all the nonlocal goto handler labels.  */\n+\n+      for (insn = f; insn; insn = NEXT_INSN (insn))\n+\tif (GET_CODE (insn) == CALL_INSN)\n+\t  {\n+\t    rtx x;\n+\t    for (x = nonlocal_label_list; x; x = XEXP (x, 1))\n+\t      mark_label_ref (gen_rtx (LABEL_REF, VOIDmode, XEXP (x, 0)),\n+\t\t\t      insn, 0);\n+\t    /* ??? This could be made smarter:\n+\t       in some cases it's possible to tell that certain\n+\t       calls will not do a nonlocal goto.\n+\n+\t       For example, if the nested functions that do the\n+\t       nonlocal gotos do not have their addresses taken, then\n+\t       only calls to those functions or to other nested\n+\t       functions that use them could possibly do nonlocal\n+\t       gotos.  */\n+\t  }\n+\n       /* Pass over all blocks, marking each block that is reachable\n \t and has not yet been marked.\n \t Keep doing this until, in one pass, no blocks have been marked.\n@@ -1472,8 +1515,12 @@ insn_dead_p (x, needed, call_ok)\n \t  if ((regno < FIRST_PSEUDO_REGISTER && global_regs[regno])\n \t      /* Make sure insns to set frame pointer aren't deleted.  */\n \t      || regno == FRAME_POINTER_REGNUM\n-\t      /* Make sure insns to set arg pointer are never deleted.  */\n-\t      || regno == ARG_POINTER_REGNUM\n+#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n+\t      /* Make sure insns to set arg pointer are never deleted\n+\t\t (if the arg pointer isn't fixed, there will be a USE for\n+\t\t it, so we can treat it normally). */\n+\t      || (regno == ARG_POINTER_REGNUM && fixed_regs[regno])\n+#endif\n \t      || (needed[offset] & bit) != 0)\n \t    return 0;\n \n@@ -1692,7 +1739,9 @@ mark_set_1 (needed, dead, x, insn, significant)\n \n   if (GET_CODE (reg) == REG\n       && (regno = REGNO (reg), regno != FRAME_POINTER_REGNUM)\n-      && regno != ARG_POINTER_REGNUM\n+#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n+      && ! (regno == ARG_POINTER_REGNUM && fixed_regs[regno])\n+#endif\n       && ! (regno < FIRST_PSEUDO_REGISTER && global_regs[regno]))\n     /* && regno != STACK_POINTER_REGNUM) -- let's try without this.  */\n     {\n@@ -2077,10 +2126,12 @@ mark_used_regs (needed, live, x, final, insn)\n \t  {\n \t    int n;\n \n-\t    /* For stack ptr or arg pointer,\n+\t    /* For stack ptr or fixed arg pointer,\n \t       nothing below can be necessary, so waste no more time.  */\n \t    if (regno == STACK_POINTER_REGNUM\n-\t\t|| regno == ARG_POINTER_REGNUM\n+#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n+\t\t|| (regno == ARG_POINTER_REGNUM && fixed_regs[regno])\n+#endif\n \t\t|| regno == FRAME_POINTER_REGNUM)\n \t      {\n \t\t/* If this is a register we are going to try to eliminate,\n@@ -2235,7 +2286,9 @@ mark_used_regs (needed, live, x, final, insn)\n \n \tif (GET_CODE (testreg) == REG\n \t    && (regno = REGNO (testreg), regno != FRAME_POINTER_REGNUM)\n-\t    && regno != ARG_POINTER_REGNUM\n+#if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n+\t    && ! (regno == ARG_POINTER_REGNUM && fixed_regs[regno])\n+#endif\n \t    && ! (regno < FIRST_PSEUDO_REGISTER && global_regs[regno]))\n \t  {\n \t    mark_used_regs (needed, live, SET_SRC (x), final, insn);"}]}