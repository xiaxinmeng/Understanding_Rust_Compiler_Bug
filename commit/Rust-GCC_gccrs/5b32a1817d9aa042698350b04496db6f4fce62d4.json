{"sha": "5b32a1817d9aa042698350b04496db6f4fce62d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWIzMmExODE3ZDlhYTA0MjY5ODM1MGIwNDQ5NmRiNmY0ZmNlNjJkNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-03-15T10:36:52Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-03-15T10:36:52Z"}, "message": "znver3 tuning part 1\n\n2021-03-15  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* config/i386/i386-options.c (processor_cost_table): Add znver3_cost.\n\t* config/i386/x86-tune-costs.h (znver3_cost): New gobal variable; copy\n\tof znver2_cost.", "tree": {"sha": "2dec370709304cdcf4589e05e5d229eae1e68e4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2dec370709304cdcf4589e05e5d229eae1e68e4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b32a1817d9aa042698350b04496db6f4fce62d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b32a1817d9aa042698350b04496db6f4fce62d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b32a1817d9aa042698350b04496db6f4fce62d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b32a1817d9aa042698350b04496db6f4fce62d4/comments", "author": null, "committer": null, "parents": [{"sha": "52654036a544389fb66855bf3972f2a8013bec59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52654036a544389fb66855bf3972f2a8013bec59", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52654036a544389fb66855bf3972f2a8013bec59"}], "stats": {"total": 136, "additions": 135, "deletions": 1}, "files": [{"sha": "7865bc110a35a95526b37db12e00357ae3c67774", "filename": "gcc/config/i386/i386-options.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b32a1817d9aa042698350b04496db6f4fce62d4/gcc%2Fconfig%2Fi386%2Fi386-options.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b32a1817d9aa042698350b04496db6f4fce62d4/gcc%2Fconfig%2Fi386%2Fi386-options.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-options.c?ref=5b32a1817d9aa042698350b04496db6f4fce62d4", "patch": "@@ -743,7 +743,7 @@ static const struct processor_costs *processor_cost_table[] =\n   &btver2_cost,\n   &znver1_cost,\n   &znver2_cost,\n-  &znver2_cost\n+  &znver3_cost\n };\n \n /* Guarantee that the array is aligned with enum processor_type.  */"}, {"sha": "e655e668c7a34db10853a068fa422722b9c9b457", "filename": "gcc/config/i386/x86-tune-costs.h", "status": "modified", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b32a1817d9aa042698350b04496db6f4fce62d4/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b32a1817d9aa042698350b04496db6f4fce62d4/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h?ref=5b32a1817d9aa042698350b04496db6f4fce62d4", "patch": "@@ -1688,6 +1688,140 @@ struct processor_costs znver2_cost = {\n   \"16\",\t\t\t\t\t/* Func alignment.  */\n };\n \n+struct processor_costs znver3_cost = {\n+  {\n+  /* Start of register allocator costs.  integer->integer move cost is 2. */\n+\n+  /* reg-reg moves are done by renaming and thus they are even cheaper than\n+     1 cycle.  Because reg-reg move cost is 2 and following tables correspond\n+     to doubles of latencies, we do not model this correctly.  It does not\n+     seem to make practical difference to bump prices up even more.  */\n+  6,\t\t\t\t\t/* cost for loading QImode using\n+\t\t\t\t\t   movzbl.  */\n+  {6, 6, 6},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {8, 8, 8},\t\t\t\t/* cost of storing integer\n+\t\t\t\t\t   registers.  */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst.  */\n+  {6, 6, 16},\t\t\t\t/* cost of loading fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode.  */\n+  {8, 8, 16},\t\t\t\t/* cost of storing fp registers\n+\t\t\t\t\t   in SFmode, DFmode and XFmode.  */\n+  2,\t\t\t\t\t/* cost of moving MMX register.  */\n+  {6, 6},\t\t\t\t/* cost of loading MMX registers\n+\t\t\t\t\t   in SImode and DImode.  */\n+  {8, 8},\t\t\t\t/* cost of storing MMX registers\n+\t\t\t\t\t   in SImode and DImode.  */\n+  2, 2, 3,\t\t\t\t/* cost of moving XMM,YMM,ZMM\n+\t\t\t\t\t   register.  */\n+  {6, 6, 6, 6, 12},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit.  */\n+  {8, 8, 8, 8, 16},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit.  */\n+  6, 6,\t\t\t\t\t/* SSE->integer and integer->SSE\n+\t\t\t\t\t   moves.  */\n+  8, 8,\t\t\t\t/* mask->integer and integer->mask moves */\n+  {6, 6, 6},\t\t\t\t/* cost of loading mask register\n+\t\t\t\t\t   in QImode, HImode, SImode.  */\n+  {8, 8, 8},\t\t\t\t/* cost if storing mask register\n+\t\t\t\t\t   in QImode, HImode, SImode.  */\n+  2,\t\t\t\t\t/* cost of moving mask register.  */\n+  /* End of register allocator costs.  */\n+  },\n+\n+  COSTS_N_INSNS (1),\t\t\t/* cost of an add instruction.  */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of a lea instruction.  */\n+  COSTS_N_INSNS (1),\t\t\t/* variable shift costs.  */\n+  COSTS_N_INSNS (1),\t\t\t/* constant shift costs.  */\n+  {COSTS_N_INSNS (3),\t\t\t/* cost of starting multiply for QI.  */\n+   COSTS_N_INSNS (3),\t\t\t/* \t\t\t\t HI.  */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t SI.  */\n+   COSTS_N_INSNS (3),\t\t\t/*\t\t\t\t DI.  */\n+   COSTS_N_INSNS (3)},\t\t\t/*\t\t\tother.  */\n+  0,\t\t\t\t\t/* cost of multiply per each bit\n+\t\t\t\t\t   set.  */\n+   /* Depending on parameters, idiv can get faster on ryzen.  This is upper\n+      bound.  */\n+  {COSTS_N_INSNS (16),\t\t\t/* cost of a divide/mod for QI.  */\n+   COSTS_N_INSNS (22),\t\t\t/* \t\t\t    HI.  */\n+   COSTS_N_INSNS (30),\t\t\t/*\t\t\t    SI.  */\n+   COSTS_N_INSNS (45),\t\t\t/*\t\t\t    DI.  */\n+   COSTS_N_INSNS (45)},\t\t\t/*\t\t\t    other.  */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movsx.  */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of movzx.  */\n+  8,\t\t\t\t\t/* \"large\" insn.  */\n+  9,\t\t\t\t\t/* MOVE_RATIO.  */\n+  6,\t\t\t\t\t/* CLEAR_RATIO */\n+  {6, 6, 6},\t\t\t\t/* cost of loading integer registers\n+\t\t\t\t\t   in QImode, HImode and SImode.\n+\t\t\t\t\t   Relative to reg-reg move (2).  */\n+  {8, 8, 8},\t\t\t\t/* cost of storing integer\n+\t\t\t\t\t   registers.  */\n+  {6, 6, 6, 6, 12},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {8, 8, 8, 8, 16},\t\t\t/* cost of storing SSE register\n+\t\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  {6, 6, 6, 6, 12},\t\t\t/* cost of unaligned loads.  */\n+  {8, 8, 8, 8, 16},\t\t\t/* cost of unaligned stores.  */\n+  2, 2, 3,\t\t\t\t/* cost of moving XMM,YMM,ZMM\n+\t\t\t\t\t   register.  */\n+  6,\t\t\t\t\t/* cost of moving SSE register to integer.  */\n+  /* VGATHERDPD is 23 uops and throughput is 9, VGATHERDPD is 35 uops,\n+     throughput 12.  Approx 9 uops do not depend on vector size and every load\n+     is 7 uops.  */\n+  18, 8,\t\t\t\t/* Gather load static, per_elt.  */\n+  18, 10,\t\t\t\t/* Gather store static, per_elt.  */\n+  32,\t\t\t\t\t/* size of l1 cache.  */\n+  512,\t\t\t\t\t/* size of l2 cache.  */\n+  64,\t\t\t\t\t/* size of prefetch block.  */\n+  /* New AMD processors never drop prefetches; if they cannot be performed\n+     immediately, they are queued.  We set number of simultaneous prefetches\n+     to a large constant to reflect this (it probably is not a good idea not\n+     to limit number of prefetches at all, as their execution also takes some\n+     time).  */\n+  100,\t\t\t\t\t/* number of parallel prefetches.  */\n+  3,\t\t\t\t\t/* Branch cost.  */\n+  COSTS_N_INSNS (5),\t\t\t/* cost of FADD and FSUB insns.  */\n+  COSTS_N_INSNS (5),\t\t\t/* cost of FMUL instruction.  */\n+  /* Latency of fdiv is 8-15.  */\n+  COSTS_N_INSNS (15),\t\t\t/* cost of FDIV instruction.  */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of FABS instruction.  */\n+  COSTS_N_INSNS (1),\t\t\t/* cost of FCHS instruction.  */\n+  /* Latency of fsqrt is 4-10.  */\n+  COSTS_N_INSNS (10),\t\t\t/* cost of FSQRT instruction.  */\n+\n+  COSTS_N_INSNS (1),\t\t\t/* cost of cheap SSE instruction.  */\n+  COSTS_N_INSNS (3),\t\t\t/* cost of ADDSS/SD SUBSS/SD insns.  */\n+  COSTS_N_INSNS (3),\t\t\t/* cost of MULSS instruction.  */\n+  COSTS_N_INSNS (3),\t\t\t/* cost of MULSD instruction.  */\n+  COSTS_N_INSNS (5),\t\t\t/* cost of FMA SS instruction.  */\n+  COSTS_N_INSNS (5),\t\t\t/* cost of FMA SD instruction.  */\n+  COSTS_N_INSNS (10),\t\t\t/* cost of DIVSS instruction.  */\n+  /* 9-13.  */\n+  COSTS_N_INSNS (13),\t\t\t/* cost of DIVSD instruction.  */\n+  COSTS_N_INSNS (10),\t\t\t/* cost of SQRTSS instruction.  */\n+  COSTS_N_INSNS (15),\t\t\t/* cost of SQRTSD instruction.  */\n+  /* Zen can execute 4 integer operations per cycle.  FP operations\n+     take 3 cycles and it can execute 2 integer additions and 2\n+     multiplications thus reassociation may make sense up to with of 6.\n+     SPEC2k6 bencharks suggests\n+     that 4 works better than 6 probably due to register pressure.\n+\n+     Integer vector operations are taken by FP unit and execute 3 vector\n+     plus/minus operations per cycle but only one multiply.  This is adjusted\n+     in ix86_reassociation_width.  */\n+  4, 4, 3, 6,\t\t\t\t/* reassoc int, fp, vec_int, vec_fp.  */\n+  znver2_memcpy,\n+  znver2_memset,\n+  COSTS_N_INSNS (4),\t\t\t/* cond_taken_branch_cost.  */\n+  COSTS_N_INSNS (2),\t\t\t/* cond_not_taken_branch_cost.  */\n+  \"16\",\t\t\t\t\t/* Loop alignment.  */\n+  \"16\",\t\t\t\t\t/* Jump alignment.  */\n+  \"0:0:8\",\t\t\t\t/* Label alignment.  */\n+  \"16\",\t\t\t\t\t/* Func alignment.  */\n+};\n+\n /* skylake_cost should produce code tuned for Skylake familly of CPUs.  */\n static stringop_algs skylake_memcpy[2] =   {\n   {libcall, {{1024, rep_prefix_4_byte, true}, {-1, libcall, false}}},"}]}