{"sha": "2361ec2a842b6e7048a9e0498bb56795c063142a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM2MWVjMmE4NDJiNmU3MDQ4YTllMDQ5OGJiNTY3OTVjMDYzMTQyYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-06-07T23:22:01Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-06-07T23:22:01Z"}, "message": "Initial revision\n\nFrom-SVN: r12220", "tree": {"sha": "c4d4f50b4753d12f0ecd54c4be2f8e8df6595a6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4d4f50b4753d12f0ecd54c4be2f8e8df6595a6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2361ec2a842b6e7048a9e0498bb56795c063142a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2361ec2a842b6e7048a9e0498bb56795c063142a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2361ec2a842b6e7048a9e0498bb56795c063142a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2361ec2a842b6e7048a9e0498bb56795c063142a/comments", "author": null, "committer": null, "parents": [{"sha": "7cc5b18f7b70ed7458cd1451cd177b01ed3e5529", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cc5b18f7b70ed7458cd1451cd177b01ed3e5529", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cc5b18f7b70ed7458cd1451cd177b01ed3e5529"}], "stats": {"total": 313, "additions": 313, "deletions": 0}, "files": [{"sha": "27ecbb6369047ff78c50faae6937a5e6f714bd12", "filename": "gcc/objc/thr-pthreads.c", "status": "added", "additions": 313, "deletions": 0, "changes": 313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2361ec2a842b6e7048a9e0498bb56795c063142a/gcc%2Fobjc%2Fthr-pthreads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2361ec2a842b6e7048a9e0498bb56795c063142a/gcc%2Fobjc%2Fthr-pthreads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fthr-pthreads.c?ref=2361ec2a842b6e7048a9e0498bb56795c063142a", "patch": "@@ -0,0 +1,313 @@\n+/* GNU Objective C Runtime Thread Implementation for PCThreads under Linux.\n+   Copyright (C) 1996 Free Software Foundation, Inc.\n+   Contributed by Scott Christley <scottc@net-community.com>\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 2, or (at your option) any later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License. This exception does not\n+   however invalidate any other reasons why the executable file might be\n+   covered by the GNU General Public License.  */\n+\n+#include <pthreads/pthread.h>\n+#include <objc/thr.h>\n+#include \"runtime.h\"\n+\n+/* Key structure for maintiain thread specific storage */\n+static pthread_key_t _objc_thread_storage;\n+\n+/********\n+ *  This structure represents a single mutual exclusion lock.  Lock semantics\n+ *  are detailed with the subsequent functions.  We use whatever lock is\n+ *  provided by the system.  We augment it with depth and current owner id\n+ *  fields to implement and re-entrant lock.\n+ */\n+struct _objc_mutex \n+{\n+  volatile _objc_thread_t     owner;          /* Id of thread that owns.  */\n+  volatile int                depth;          /* # of acquires.           */\n+  pthread_mutex_t             mutex;          /* PCThread mutex           */\n+};\n+\n+/********\n+ *  Initialize the threads subsystem.  Returns 0 if successful, or -1 if no\n+ *  thread support is available.\n+ */\n+int\n+__objc_init_thread_system(void)\n+{\n+  /* Initialize the thread storage key */\n+  return pthread_key_create(&_objc_thread_storage, NULL);\n+}\n+\n+/********\n+ *  Finalize the threads subsystem.  Returns 0 if successful, or -1 if not\n+ */\n+int\n+__objc_fini_thread_system(void)\n+{\n+  /* Destroy the thread storage key */\n+  /* Not implemented yet */\n+  /* return pthread_key_delete(&_objc_thread_storage); */\n+  return 0;\n+}\n+\n+/********\n+ *  Create a new thread of execution and return its id.  Return NULL if fails.\n+ *  The new thread starts in \"func\" with the given argument.\n+ */\n+_objc_thread_t\n+objc_thread_create(void (*func)(void *arg), void *arg)\n+{\n+  _objc_thread_t thread_id;\n+  pthread_t new_thread_handle;\n+\n+  objc_mutex_lock(__objc_runtime_mutex);\n+  \n+  if ( !(pthread_create(&new_thread_handle, NULL, (void *)func, arg)) )\n+    {\n+      thread_id = *(_objc_thread_t *)&new_thread_handle;\n+      __objc_runtime_threads_alive++;\n+    }\n+  else\n+    thread_id = NULL;\n+  \n+  objc_mutex_unlock(__objc_runtime_mutex);\n+  \n+  return thread_id;\n+}\n+\n+/********\n+ *  Set the current thread's priority.\n+ */\n+int\n+objc_thread_set_priority(int priority)\n+{\n+  /* Not implemented yet */\n+  return -1;                                   \t/* Failed.    */\n+}\n+\n+/********\n+ *  Return the current thread's priority.\n+ */\n+int\n+objc_thread_get_priority(void)\n+{\n+  /* Not implemented yet */\n+  return OBJC_THREAD_INTERACTIVE_PRIORITY;      /* Highest priority.   */\n+}\n+\n+/********\n+ *  Yield our process time to another thread.  Any BUSY waiting that is done\n+ *  by a thread should use this function to make sure that other threads can\n+ *  make progress even on a lazy uniprocessor system.\n+ */\n+void\n+objc_thread_yield(void)\n+{\n+  pthread_yield(NULL);\n+}\n+\n+/********\n+ *  Terminate the current tread.  Doesn't return anything.  Doesn't return.\n+ *  Actually, if it failed returns -1.\n+ */\n+int\n+objc_thread_exit(void)\n+{\n+  objc_mutex_lock(__objc_runtime_mutex);\n+  __objc_runtime_threads_alive--;\n+  objc_mutex_unlock(__objc_runtime_mutex);\n+      \n+  pthread_exit(&__objc_thread_exit_status);     /* Terminate thread.  */\n+  return -1;\n+}\n+\n+/********\n+ *  Returns an integer value which uniquely describes a thread.  Must not be\n+ *  NULL which is reserved as a marker for \"no thread\".\n+ */\n+_objc_thread_t\n+objc_thread_id(void)\n+{\n+  pthread_t self = pthread_self();\n+\n+  return *(_objc_thread_t *)&self;            /* Return thread handle.    */\n+}\n+\n+/********\n+ *  Sets the thread's local storage pointer.  Returns 0 if successful or -1\n+ *  if failed.\n+ */\n+int\n+objc_thread_set_data(void *value)\n+{\n+  return pthread_setspecific(_objc_thread_storage, value);\n+}\n+\n+/********\n+ *  Returns the thread's local storage pointer.  Returns NULL on failure.\n+ */\n+void *\n+objc_thread_get_data(void)\n+{\n+  void *value = NULL;\n+\n+  if ( !(pthread_getspecific(_objc_thread_storage, &value)) )\n+    return value;\n+\n+  return NULL;\n+}\n+\n+/********\n+ *  Allocate a mutex.  Return the mutex pointer if successful or NULL if the\n+ *  allocation failed for any reason.\n+ */\n+_objc_mutex_t\n+objc_mutex_allocate(void)\n+{\n+  _objc_mutex_t mutex;\n+    \n+  if (!(mutex = (_objc_mutex_t)__objc_xmalloc(sizeof(struct _objc_mutex))))\n+    return NULL;                            /* Abort if malloc failed.  */\n+\n+  /* Create PCThread mutex */\n+  if ( pthread_mutex_init(&(mutex->mutex), NULL) )\n+    {\n+      /* Failed */\n+      free(mutex);\n+      return NULL;\n+    }\n+\n+  mutex->owner = NULL;                        /* No owner.                */\n+  mutex->depth = 0;                           /* No locks.                */\n+  return mutex;                               /* Return mutex handle.     */\n+}\n+\n+/********\n+ *  Deallocate a mutex.  Note that this includes an implicit mutex_lock to\n+ *  insure that no one else is using the lock.  It is legal to deallocate\n+ *  a lock if we have a lock on it, but illegal to deallocate a lock held\n+ *  by anyone else.\n+ *  Returns the number of locks on the thread.  (1 for deallocate).\n+ */\n+int\n+objc_mutex_deallocate(_objc_mutex_t mutex)\n+{\n+  int         depth;                          /* # of locks on mutex.     */\n+\n+  if (!mutex)                                 /* Is argument bad?         */\n+    return -1;                              /* Yes, abort.              */\n+  depth = objc_mutex_lock(mutex);             /* Must have lock.          */\n+\n+  /* Destroy PCThread mutex */\n+  pthread_mutex_destroy(&(mutex->mutex));\n+\n+  free(mutex);                                /* Free memory.             */\n+  return depth;                               /* Return last depth.       */\n+}\n+\n+/********\n+ *  Grab a lock on a mutex.  If this thread already has a lock on this mutex\n+ *  then we increment the lock count.  If another thread has a lock on the \n+ *  mutex we block and wait for the thread to release the lock.\n+ *  Returns the lock count on the mutex held by this thread.\n+ */\n+int\n+objc_mutex_lock(_objc_mutex_t mutex)\n+{\n+  _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+  int status;\n+\n+  if (!mutex)                                 /* Is argument bad?         */\n+    return -1;                              /* Yes, abort.              */\n+  thread_id = objc_thread_id();               /* Get this thread's id.    */\n+  if (mutex->owner == thread_id)              /* Already own lock?        */\n+    {\n+      return ++mutex->depth;                  /* Yes, increment depth.    */\n+    }\n+\n+  /* Lock the PCThread mutex */\n+  status = pthread_mutex_lock(&(mutex->mutex));\n+  if (status)\n+    {\n+      return status;                            /* Failed */\n+    }\n+\n+  mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+  return mutex->depth = 1;                    /* Increment depth to end.  */\n+}\n+\n+/********\n+ *  Try to grab a lock on a mutex.  If this thread already has a lock on\n+ *  this mutex then we increment the lock count and return it.  If another\n+ *  thread has a lock on the mutex returns -1.\n+ */\n+int\n+objc_mutex_trylock(_objc_mutex_t mutex)\n+{\n+  _objc_thread_t      thread_id;              /* Cache our thread id.     */\n+  int status;\n+\n+  if (!mutex)                                 /* Is argument bad?         */\n+    return -1;                              /* Yes, abort.              */\n+  thread_id = objc_thread_id();               /* Get this thread's id.    */\n+  if (mutex->owner == thread_id)              /* Already own lock?        */\n+    return ++mutex->depth;                  /* Yes, increment depth.    */\n+    \n+  /* Lock the PCThread mutex */\n+  status = pthread_mutex_trylock(&(mutex->mutex));\n+  if (status)\n+    return status;                            /* Failed */\n+\n+  mutex->owner = thread_id;                   /* Mark thread as owner.    */\n+  return mutex->depth = 1;                    /* Increment depth to end.  */\n+}\n+\n+/********\n+ * Decrements the lock count on this mutex by one.  If the lock count reaches\n+ * zero, release the lock on the mutex.  Returns the lock count on the mutex.\n+ * It is an error to attempt to unlock a mutex which this thread doesn't hold\n+ * in which case return -1 and the mutex is unaffected.\n+ * Will also return -1 if the mutex free fails.\n+ */\n+int\n+objc_mutex_unlock(_objc_mutex_t mutex)\n+{\n+  _objc_thread_t thread_id;                   /* Cache our thread id.     */\n+  int status;\n+    \n+  if (!mutex)                                 /* Is argument bad?         */\n+    return -1;                              /* Yes, abort.              */\n+  thread_id = objc_thread_id();               /* Get this thread's id.    */\n+  if (mutex->owner != thread_id)              /* Does some else own lock? */\n+    return -1;                              /* Yes, abort.              */\n+  if (mutex->depth > 1)                       /* Released last lock?      */\n+    return --mutex->depth;                  /* No, Decrement depth, end.*/\n+  mutex->depth = 0;                           /* Yes, reset depth to 0.   */\n+  mutex->owner = NULL;                        /* Set owner to \"no thread\".*/\n+\n+  /* Unlock the PCThread mutex */\n+  status = pthread_mutex_unlock(&(mutex->mutex));\n+  if (status)\n+    return status;                            /* Failed */\n+\n+  return 0;                                   /* No, return success.      */\n+}\n+\n+/* End of File */"}]}