{"sha": "03e1048e9f243d391d9e852d21dad610a3f0a23c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNlMTA0OGU5ZjI0M2QzOTFkOWU4NTJkMjFkYWQ2MTBhM2YwYTIzYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-20T11:44:38Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-11-20T11:44:38Z"}, "message": "[multiple changes]\n\n2011-11-20  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch6.adb, exp_util.adb: Minor reformatting\n\n2011-11-20  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* sinfo.ads (Reference): Document that it is OK to set\n\tIs_Known_Non_Null on a temporary initialized to a N_Reference\n\tnode.\n\n2011-11-20  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-cbdlli.adb, a-cfdlli.adb (Move): Set Last component to 0\n\tfor Source list.\n\nFrom-SVN: r181530", "tree": {"sha": "d06e519d8c8b9d58bb516dcf9e6b61bd73b2ca37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d06e519d8c8b9d58bb516dcf9e6b61bd73b2ca37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03e1048e9f243d391d9e852d21dad610a3f0a23c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03e1048e9f243d391d9e852d21dad610a3f0a23c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03e1048e9f243d391d9e852d21dad610a3f0a23c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03e1048e9f243d391d9e852d21dad610a3f0a23c/comments", "author": null, "committer": null, "parents": [{"sha": "74cab21a4ba7605ea5ebf1910eba4db2852cd75a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74cab21a4ba7605ea5ebf1910eba4db2852cd75a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74cab21a4ba7605ea5ebf1910eba4db2852cd75a"}], "stats": {"total": 134, "additions": 129, "deletions": 5}, "files": [{"sha": "22f5712ceeea5fe53690e93d4329a1dd39fda2ba", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03e1048e9f243d391d9e852d21dad610a3f0a23c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03e1048e9f243d391d9e852d21dad610a3f0a23c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=03e1048e9f243d391d9e852d21dad610a3f0a23c", "patch": "@@ -1,3 +1,18 @@\n+2011-11-20  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch6.adb, exp_util.adb: Minor reformatting\n+\n+2011-11-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* sinfo.ads (Reference): Document that it is OK to set\n+\tIs_Known_Non_Null on a temporary initialized to a N_Reference\n+\tnode.\n+\n+2011-11-20  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-cbdlli.adb, a-cfdlli.adb (Move): Set Last component to 0\n+\tfor Source list.\n+\n 2011-11-20  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* exp_ch6.adb (Make_Build_In_Place_Call_In_Assignment):"}, {"sha": "9e4007159407a937ffd0b9377fcb0b0a2ef9d8e9", "filename": "gcc/ada/a-cbdlli.adb", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03e1048e9f243d391d9e852d21dad610a3f0a23c/gcc%2Fada%2Fa-cbdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03e1048e9f243d391d9e852d21dad610a3f0a23c/gcc%2Fada%2Fa-cbdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbdlli.adb?ref=03e1048e9f243d391d9e852d21dad610a3f0a23c", "patch": "@@ -1164,18 +1164,67 @@ package body Ada.Containers.Bounded_Doubly_Linked_Lists is\n            \"attempt to tamper with cursors of Source (list is busy)\";\n       end if;\n \n-      Clear (Target);\n+      Clear (Target);  -- checks busy bit of Target\n+\n+      while Source.Length > 1 loop\n+\n+         pragma Assert (Source.First in 1 .. Source.Capacity);\n+         pragma Assert (Source.Last /= Source.First);\n+         pragma Assert (N (Source.First).Prev = 0);\n+         pragma Assert (N (Source.Last).Next = 0);\n+\n+         --  Copy first element from Source to Target\n \n-      while Source.Length > 0 loop\n          X := Source.First;\n          Append (Target, N (X).Element);\n \n+         --  Unlink first node of Source\n+\n          Source.First := N (X).Next;\n          N (Source.First).Prev := 0;\n \n          Source.Length := Source.Length - 1;\n+\n+         --  The representation invariants for Source have been restored. It is\n+         --  now safe to free the unlinked node, without fear of corrupting the\n+         --  active links of Source.\n+\n+         --  Note that the algorithm we use here models similar algorithms used\n+         --  in the unbounded form of the doubly-linked list container. In that\n+         --  case, Free is an instantation of Unchecked_Deallocation, which can\n+         --  fail (because PE will be raised if controlled Finalize fails), so\n+         --  we must defer the call until the very last step. Here in the\n+         --  bounded form, Free merely links the node we have just\n+         --  \"deallocated\" onto a list of inactive nodes, so technically Free\n+         --  cannot fail. However, for consistency, we handle Free the same way\n+         --  here as we do for the unbounded form, with the pessimistic\n+         --  assumption that it can fail.\n+\n          Free (Source, X);\n       end loop;\n+\n+      if Source.Length = 1 then\n+\n+         pragma Assert (Source.First in 1 .. Source.Capacity);\n+         pragma Assert (Source.Last = Source.First);\n+         pragma Assert (N (Source.First).Prev = 0);\n+         pragma Assert (N (Source.Last).Next = 0);\n+\n+         --  Copy element from Source to Target\n+\n+         X := Source.First;\n+         Append (Target, N (X).Element);\n+\n+         --  Unlink node of Source\n+\n+         Source.First := 0;\n+         Source.Last := 0;\n+         Source.Length := 0;\n+\n+         --  Return the unlinked node to the free store\n+\n+         Free (Source, X);\n+      end if;\n    end Move;\n \n    ----------"}, {"sha": "d1bd218972d502d68883c0494de53355b7842f65", "filename": "gcc/ada/a-cfdlli.adb", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03e1048e9f243d391d9e852d21dad610a3f0a23c/gcc%2Fada%2Fa-cfdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03e1048e9f243d391d9e852d21dad610a3f0a23c/gcc%2Fada%2Fa-cfdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfdlli.adb?ref=03e1048e9f243d391d9e852d21dad610a3f0a23c", "patch": "@@ -1007,16 +1007,65 @@ package body Ada.Containers.Formal_Doubly_Linked_Lists is\n \n       Clear (Target);\n \n-      while Source.Length > 0 loop\n+      while Source.Length > 1 loop\n+\n+         pragma Assert (Source.First in 1 .. Source.Capacity);\n+         pragma Assert (Source.Last /= Source.First);\n+         pragma Assert (N (Source.First).Prev = 0);\n+         pragma Assert (N (Source.Last).Next = 0);\n+\n+         --  Copy first element from Source to Target\n+\n          X := Source.First;\n          Append (Target, N (X).Element);  -- optimize away???\n \n+         --  Unlink first node of Source\n+\n          Source.First := N (X).Next;\n          N (Source.First).Prev := 0;\n \n          Source.Length := Source.Length - 1;\n+\n+         --  The representation invariants for Source have been restored. It is\n+         --  now safe to free the unlinked node, without fear of corrupting the\n+         --  active links of Source.\n+\n+         --  Note that the algorithm we use here models similar algorithms used\n+         --  in the unbounded form of the doubly-linked list container. In that\n+         --  case, Free is an instantation of Unchecked_Deallocation, which can\n+         --  fail (because PE will be raised if controlled Finalize fails), so\n+         --  we must defer the call until the very last step. Here in the\n+         --  bounded form, Free merely links the node we have just\n+         --  \"deallocated\" onto a list of inactive nodes, so technically Free\n+         --  cannot fail. However, for consistency, we handle Free the same way\n+         --  here as we do for the unbounded form, with the pessimistic\n+         --  assumption that it can fail.\n+\n          Free (Source, X);\n       end loop;\n+\n+      if Source.Length = 1 then\n+\n+         pragma Assert (Source.First in 1 .. Source.Capacity);\n+         pragma Assert (Source.Last = Source.First);\n+         pragma Assert (N (Source.First).Prev = 0);\n+         pragma Assert (N (Source.Last).Next = 0);\n+\n+         --  Copy element from Source to Target\n+\n+         X := Source.First;\n+         Append (Target, N (X).Element);\n+\n+         --  Unlink node of Source\n+\n+         Source.First := 0;\n+         Source.Last := 0;\n+         Source.Length := 0;\n+\n+         --  Return the unlinked node to the free store\n+\n+         Free (Source, X);\n+      end if;\n    end Move;\n \n    ----------"}, {"sha": "227f72921befcf34d759a3e3d4a8816a40f3a129", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03e1048e9f243d391d9e852d21dad610a3f0a23c/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03e1048e9f243d391d9e852d21dad610a3f0a23c/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=03e1048e9f243d391d9e852d21dad610a3f0a23c", "patch": "@@ -8034,7 +8034,8 @@ package body Exp_Ch6 is\n       Insert_After_And_Analyze (Assign, Ptr_Typ_Decl);\n \n       --  Finally, create an access object initialized to a reference to the\n-      --  function call.\n+      --  function call. We know this access value is non-null, so mark the\n+      --  entity accordingly to suppress junk access checks.\n \n       New_Expr := Make_Reference (Loc, Relocate_Node (Func_Call));\n \n@@ -8299,7 +8300,8 @@ package body Exp_Ch6 is\n       end if;\n \n       --  Finally, create an access object initialized to a reference to the\n-      --  function call.\n+      --  function call. We know this access value cannot be null, so mark the\n+      --  entity accordingly to suppress the access check.\n \n       New_Expr := Make_Reference (Loc, Relocate_Node (Func_Call));\n "}, {"sha": "37a1be0e47876899987cc1360a08443ab838f4df", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03e1048e9f243d391d9e852d21dad610a3f0a23c/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03e1048e9f243d391d9e852d21dad610a3f0a23c/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=03e1048e9f243d391d9e852d21dad610a3f0a23c", "patch": "@@ -6710,6 +6710,10 @@ package body Exp_Util is\n \n             if Alfa_Mode then\n                New_Exp := E;\n+\n+            --  Otherwise generate reference, marking the value as non-null\n+            --  since we know it cannot be null and we don't want a check.\n+\n             else\n                New_Exp := Make_Reference (Loc, E);\n                Set_Is_Known_Non_Null (Def_Id);"}, {"sha": "3379faef0385096c46457f875d393917d28dd11f", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03e1048e9f243d391d9e852d21dad610a3f0a23c/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03e1048e9f243d391d9e852d21dad610a3f0a23c/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=03e1048e9f243d391d9e852d21dad610a3f0a23c", "patch": "@@ -7310,6 +7310,11 @@ package Sinfo is\n       --  more sense to call it an Expression field, but then we would have to\n       --  special case the treatment of the N_Reference node.\n \n+      --  Note: evaluating a N_Reference node is guaranteed to yield a non-null\n+      --  value at run time. Therefore, it is valid to set Is_Known_Non_Null on\n+      --  a temporary initialized to a N_Reference node in order to eliminate\n+      --  superfluous access checks.\n+\n       --  Sprint syntax: prefix'reference\n \n       --  N_Reference"}]}