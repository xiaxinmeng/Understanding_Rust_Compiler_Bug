{"sha": "4a2095ebace8534038ce2adf4ae94bfc854066c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGEyMDk1ZWJhY2U4NTM0MDM4Y2UyYWRmNGFlOTRiZmM4NTQwNjZjNA==", "commit": {"author": {"name": "Richard Henderson", "email": "richard.henderson@linaro.org", "date": "2019-09-19T14:36:29Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2019-09-19T14:36:29Z"}, "message": "aarch64: Implement TImode compare-and-swap\n\nThis pattern will only be used with the __sync functions, because\nwe do not yet have a bare TImode atomic load.\n\n\t* config/aarch64/aarch64.c (aarch64_gen_compare_reg): Add support\n\tfor NE comparison of TImode values.\n\t(aarch64_emit_load_exclusive): Add support for TImode.\n\t(aarch64_emit_store_exclusive): Likewise.\n\t(aarch64_split_compare_and_swap): Disable strong_zero_p for TImode.\n\t* config/aarch64/atomics.md (@atomic_compare_and_swap<ALLI_TI>):\n\tChange iterator from ALLI to ALLI_TI.\n\t(@atomic_compare_and_swap<JUST_TI>): New.\n\t(@atomic_compare_and_swap<JUST_TI>_lse): New.\n\t(aarch64_load_exclusive_pair): New.\n\t(aarch64_store_exclusive_pair): New.\n\t* config/aarch64/iterators.md (JUST_TI): New.\n\nFrom-SVN: r275965", "tree": {"sha": "982fd22424e7f0412c5d5081af3ef4498c98fc9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/982fd22424e7f0412c5d5081af3ef4498c98fc9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a2095ebace8534038ce2adf4ae94bfc854066c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a2095ebace8534038ce2adf4ae94bfc854066c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a2095ebace8534038ce2adf4ae94bfc854066c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a2095ebace8534038ce2adf4ae94bfc854066c4/comments", "author": {"login": "rth7680", "id": 2529319, "node_id": "MDQ6VXNlcjI1MjkzMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2529319?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rth7680", "html_url": "https://github.com/rth7680", "followers_url": "https://api.github.com/users/rth7680/followers", "following_url": "https://api.github.com/users/rth7680/following{/other_user}", "gists_url": "https://api.github.com/users/rth7680/gists{/gist_id}", "starred_url": "https://api.github.com/users/rth7680/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rth7680/subscriptions", "organizations_url": "https://api.github.com/users/rth7680/orgs", "repos_url": "https://api.github.com/users/rth7680/repos", "events_url": "https://api.github.com/users/rth7680/events{/privacy}", "received_events_url": "https://api.github.com/users/rth7680/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e3f15286d1129de2cceee6acd5d5584cb5422db6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3f15286d1129de2cceee6acd5d5584cb5422db6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3f15286d1129de2cceee6acd5d5584cb5422db6"}], "stats": {"total": 157, "additions": 144, "deletions": 13}, "files": [{"sha": "d8749b9b2e08a4192d671ebedd4bf0ad64253ad9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2095ebace8534038ce2adf4ae94bfc854066c4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2095ebace8534038ce2adf4ae94bfc854066c4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a2095ebace8534038ce2adf4ae94bfc854066c4", "patch": "@@ -3,6 +3,19 @@\n \t* config/aarch64/aarch64.c (aarch64_print_operand): Allow integer\n \tregisters with %R.\n \n+\t* config/aarch64/aarch64.c (aarch64_gen_compare_reg): Add support\n+\tfor NE comparison of TImode values.\n+\t(aarch64_emit_load_exclusive): Add support for TImode.\n+\t(aarch64_emit_store_exclusive): Likewise.\n+\t(aarch64_split_compare_and_swap): Disable strong_zero_p for TImode.\n+\t* config/aarch64/atomics.md (@atomic_compare_and_swap<ALLI_TI>):\n+\tChange iterator from ALLI to ALLI_TI.\n+\t(@atomic_compare_and_swap<JUST_TI>): New.\n+\t(@atomic_compare_and_swap<JUST_TI>_lse): New.\n+\t(aarch64_load_exclusive_pair): New.\n+\t(aarch64_store_exclusive_pair): New.\n+\t* config/aarch64/iterators.md (JUST_TI): New.\n+\n 2019-09-19  Feng Xue  <fxue@os.amperecomputing.com>\n \n \t* ipa-fnsummary.c (set_cond_stmt_execution_predicate): Do not compute"}, {"sha": "a5c4f55627d0e1efec5dbc50fda2da15ea3f5e74", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2095ebace8534038ce2adf4ae94bfc854066c4/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2095ebace8534038ce2adf4ae94bfc854066c4/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=4a2095ebace8534038ce2adf4ae94bfc854066c4", "patch": "@@ -2039,10 +2039,33 @@ emit_set_insn (rtx x, rtx y)\n rtx\n aarch64_gen_compare_reg (RTX_CODE code, rtx x, rtx y)\n {\n-  machine_mode mode = SELECT_CC_MODE (code, x, y);\n-  rtx cc_reg = gen_rtx_REG (mode, CC_REGNUM);\n+  machine_mode cmp_mode = GET_MODE (x);\n+  machine_mode cc_mode;\n+  rtx cc_reg;\n \n-  emit_set_insn (cc_reg, gen_rtx_COMPARE (mode, x, y));\n+  if (cmp_mode == TImode)\n+    {\n+      gcc_assert (code == NE);\n+\n+      cc_mode = CCmode;\n+      cc_reg = gen_rtx_REG (cc_mode, CC_REGNUM);\n+\n+      rtx x_lo = operand_subword (x, 0, 0, TImode);\n+      rtx y_lo = operand_subword (y, 0, 0, TImode);\n+      emit_set_insn (cc_reg, gen_rtx_COMPARE (cc_mode, x_lo, y_lo));\n+\n+      rtx x_hi = operand_subword (x, 1, 0, TImode);\n+      rtx y_hi = operand_subword (y, 1, 0, TImode);\n+      emit_insn (gen_ccmpdi (cc_reg, cc_reg, x_hi, y_hi,\n+\t\t\t     gen_rtx_EQ (cc_mode, cc_reg, const0_rtx),\n+\t\t\t     GEN_INT (AARCH64_EQ)));\n+    }\n+  else\n+    {\n+      cc_mode = SELECT_CC_MODE (code, x, y);\n+      cc_reg = gen_rtx_REG (cc_mode, CC_REGNUM);\n+      emit_set_insn (cc_reg, gen_rtx_COMPARE (cc_mode, x, y));\n+    }\n   return cc_reg;\n }\n \n@@ -2593,7 +2616,6 @@ aarch64_zero_extend_const_eq (machine_mode xmode, rtx x,\n   gcc_assert (r != NULL);\n   return rtx_equal_p (x, r);\n }\n-\t\t\t      \n \n /* Return TARGET if it is nonnull and a register of mode MODE.\n    Otherwise, return a fresh register of mode MODE if we can,\n@@ -16814,16 +16836,26 @@ static void\n aarch64_emit_load_exclusive (machine_mode mode, rtx rval,\n \t\t\t     rtx mem, rtx model_rtx)\n {\n-  emit_insn (gen_aarch64_load_exclusive (mode, rval, mem, model_rtx));\n+  if (mode == TImode)\n+    emit_insn (gen_aarch64_load_exclusive_pair (gen_lowpart (DImode, rval),\n+\t\t\t\t\t\tgen_highpart (DImode, rval),\n+\t\t\t\t\t\tmem, model_rtx));\n+  else\n+    emit_insn (gen_aarch64_load_exclusive (mode, rval, mem, model_rtx));\n }\n \n /* Emit store exclusive.  */\n \n static void\n aarch64_emit_store_exclusive (machine_mode mode, rtx bval,\n-\t\t\t      rtx rval, rtx mem, rtx model_rtx)\n+\t\t\t      rtx mem, rtx rval, rtx model_rtx)\n {\n-  emit_insn (gen_aarch64_store_exclusive (mode, bval, rval, mem, model_rtx));\n+  if (mode == TImode)\n+    emit_insn (gen_aarch64_store_exclusive_pair\n+\t       (bval, mem, operand_subword (rval, 0, 0, TImode),\n+\t\toperand_subword (rval, 1, 0, TImode), model_rtx));\n+  else\n+    emit_insn (gen_aarch64_store_exclusive (mode, bval, mem, rval, model_rtx));\n }\n \n /* Mark the previous jump instruction as unlikely.  */\n@@ -16950,7 +16982,7 @@ aarch64_split_compare_and_swap (rtx operands[])\n \tCBNZ\tscratch, .label1\n     .label2:\n \tCMP\trval, 0.  */\n-  bool strong_zero_p = !is_weak && oldval == const0_rtx;\n+  bool strong_zero_p = !is_weak && oldval == const0_rtx && mode != TImode;\n \n   label1 = NULL;\n   if (!is_weak)"}, {"sha": "f8bdd048b37c5ba7fa5c779fc6e06746b35f7307", "filename": "gcc/config/aarch64/atomics.md", "status": "modified", "additions": 88, "deletions": 5, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2095ebace8534038ce2adf4ae94bfc854066c4/gcc%2Fconfig%2Faarch64%2Fatomics.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2095ebace8534038ce2adf4ae94bfc854066c4/gcc%2Fconfig%2Faarch64%2Fatomics.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fatomics.md?ref=4a2095ebace8534038ce2adf4ae94bfc854066c4", "patch": "@@ -21,11 +21,11 @@\n ;; Instruction patterns.\n \n (define_expand \"@atomic_compare_and_swap<mode>\"\n-  [(match_operand:SI 0 \"register_operand\")\t\t\t;; bool out\n-   (match_operand:ALLI 1 \"register_operand\")\t\t\t;; val out\n-   (match_operand:ALLI 2 \"aarch64_sync_memory_operand\")\t\t;; memory\n-   (match_operand:ALLI 3 \"nonmemory_operand\")\t\t\t;; expected\n-   (match_operand:ALLI 4 \"aarch64_reg_or_zero\")\t\t\t;; desired\n+  [(match_operand:SI 0 \"register_operand\" \"\")\t\t\t;; bool out\n+   (match_operand:ALLI_TI 1 \"register_operand\" \"\")\t\t;; val out\n+   (match_operand:ALLI_TI 2 \"aarch64_sync_memory_operand\" \"\")\t;; memory\n+   (match_operand:ALLI_TI 3 \"nonmemory_operand\" \"\")\t\t;; expected\n+   (match_operand:ALLI_TI 4 \"aarch64_reg_or_zero\" \"\")\t\t;; desired\n    (match_operand:SI 5 \"const_int_operand\")\t\t\t;; is_weak\n    (match_operand:SI 6 \"const_int_operand\")\t\t\t;; mod_s\n    (match_operand:SI 7 \"const_int_operand\")]\t\t\t;; mod_f\n@@ -88,6 +88,30 @@\n   }\n )\n \n+(define_insn_and_split \"@aarch64_compare_and_swap<mode>\"\n+  [(set (reg:CC CC_REGNUM)\t\t\t\t\t;; bool out\n+    (unspec_volatile:CC [(const_int 0)] UNSPECV_ATOMIC_CMPSW))\n+   (set (match_operand:JUST_TI 0 \"register_operand\" \"=&r\")\t;; val out\n+    (match_operand:JUST_TI 1 \"aarch64_sync_memory_operand\" \"+Q\")) ;; memory\n+   (set (match_dup 1)\n+    (unspec_volatile:JUST_TI\n+      [(match_operand:JUST_TI 2 \"aarch64_reg_or_zero\" \"rZ\")\t;; expect\n+       (match_operand:JUST_TI 3 \"aarch64_reg_or_zero\" \"rZ\")\t;; desired\n+       (match_operand:SI 4 \"const_int_operand\")\t\t\t;; is_weak\n+       (match_operand:SI 5 \"const_int_operand\")\t\t\t;; mod_s\n+       (match_operand:SI 6 \"const_int_operand\")]\t\t;; mod_f\n+      UNSPECV_ATOMIC_CMPSW))\n+   (clobber (match_scratch:SI 7 \"=&r\"))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+  {\n+    aarch64_split_compare_and_swap (operands);\n+    DONE;\n+  }\n+)\n+\n (define_insn \"@aarch64_compare_and_swap<mode>_lse\"\n   [(set (match_operand:SI 0 \"register_operand\" \"+r\")\t\t;; val out\n     (zero_extend:SI\n@@ -133,6 +157,28 @@\n     return \"casal<atomic_sfx>\\t%<w>0, %<w>2, %1\";\n })\n \n+(define_insn \"@aarch64_compare_and_swap<mode>_lse\"\n+  [(set (match_operand:JUST_TI 0 \"register_operand\" \"+r\")\t;; val out\n+    (match_operand:JUST_TI 1 \"aarch64_sync_memory_operand\" \"+Q\")) ;; memory\n+   (set (match_dup 1)\n+    (unspec_volatile:JUST_TI\n+      [(match_dup 0)\t\t\t\t\t\t;; expect\n+       (match_operand:JUST_TI 2 \"register_operand\" \"r\")\t\t;; desired\n+       (match_operand:SI 3 \"const_int_operand\")]\t\t;; mod_s\n+      UNSPECV_ATOMIC_CMPSW))]\n+  \"TARGET_LSE\"\n+{\n+  enum memmodel model = memmodel_from_int (INTVAL (operands[3]));\n+  if (is_mm_relaxed (model))\n+    return \"casp\\t%0, %R0, %2, %R2, %1\";\n+  else if (is_mm_acquire (model) || is_mm_consume (model))\n+    return \"caspa\\t%0, %R0, %2, %R2, %1\";\n+  else if (is_mm_release (model))\n+    return \"caspl\\t%0, %R0, %2, %R2, %1\";\n+  else\n+    return \"caspal\\t%0, %R0, %2, %R2, %1\";\n+})\n+\n (define_expand \"atomic_exchange<mode>\"\n  [(match_operand:ALLI 0 \"register_operand\")\n   (match_operand:ALLI 1 \"aarch64_sync_memory_operand\")\n@@ -581,6 +627,24 @@\n   }\n )\n \n+(define_insn \"aarch64_load_exclusive_pair\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec_volatile:DI\n+\t  [(match_operand:TI 2 \"aarch64_sync_memory_operand\" \"Q\")\n+\t   (match_operand:SI 3 \"const_int_operand\")]\n+\t  UNSPECV_LX))\n+   (set (match_operand:DI 1 \"register_operand\" \"=r\")\n+\t(unspec_volatile:DI [(match_dup 2) (match_dup 3)] UNSPECV_LX))]\n+  \"\"\n+  {\n+    enum memmodel model = memmodel_from_int (INTVAL (operands[3]));\n+    if (is_mm_relaxed (model) || is_mm_consume (model) || is_mm_release (model))\n+      return \"ldxp\\t%0, %1, %2\";\n+    else\n+      return \"ldaxp\\t%0, %1, %2\";\n+  }\n+)\n+\n (define_insn \"@aarch64_store_exclusive<mode>\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n     (unspec_volatile:SI [(const_int 0)] UNSPECV_SX))\n@@ -599,6 +663,25 @@\n   }\n )\n \n+(define_insn \"aarch64_store_exclusive_pair\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(unspec_volatile:SI [(const_int 0)] UNSPECV_SX))\n+   (set (match_operand:TI 1 \"aarch64_sync_memory_operand\" \"=Q\")\n+\t(unspec_volatile:TI\n+\t  [(match_operand:DI 2 \"aarch64_reg_or_zero\" \"rZ\")\n+\t   (match_operand:DI 3 \"aarch64_reg_or_zero\" \"rZ\")\n+\t   (match_operand:SI 4 \"const_int_operand\")]\n+\t  UNSPECV_SX))]\n+  \"\"\n+  {\n+    enum memmodel model = memmodel_from_int (INTVAL (operands[3]));\n+    if (is_mm_relaxed (model) || is_mm_consume (model) || is_mm_acquire (model))\n+      return \"stxp\\t%w0, %x2, %x3, %1\";\n+    else\n+      return \"stlxp\\t%w0, %x2, %x3, %1\";\n+  }\n+)\n+\n (define_expand \"mem_thread_fence\"\n   [(match_operand:SI 0 \"const_int_operand\")]\n   \"\""}, {"sha": "03b3ce363021a71578803e07b3548d3dd9c9de32", "filename": "gcc/config/aarch64/iterators.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2095ebace8534038ce2adf4ae94bfc854066c4/gcc%2Fconfig%2Faarch64%2Fiterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2095ebace8534038ce2adf4ae94bfc854066c4/gcc%2Fconfig%2Faarch64%2Fiterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fiterators.md?ref=4a2095ebace8534038ce2adf4ae94bfc854066c4", "patch": "@@ -29,6 +29,9 @@\n ;; Iterator for HI, SI, DI, some instructions can only work on these modes.\n (define_mode_iterator GPI_I16 [(HI \"AARCH64_ISA_F16\") SI DI])\n \n+;; \"Iterator\" for just TI -- features like @pattern only work with iterators.\n+(define_mode_iterator JUST_TI [TI])\n+\n ;; Iterator for QI and HI modes\n (define_mode_iterator SHORT [QI HI])\n "}]}