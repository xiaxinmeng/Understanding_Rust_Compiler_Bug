{"sha": "96be6998336d305447f3963eb2c9d902eae516a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZiZTY5OTgzMzZkMzA1NDQ3ZjM5NjNlYjJjOWQ5MDJlYWU1MTZhNw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-07-18T23:25:06Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-07-18T23:25:06Z"}, "message": "cpplib.h (TTYPE_TABLE): Rearrange to use only two per-entry macros, not five.\n\n\t* cpplib.h (TTYPE_TABLE): Rearrange to use only two per-entry\n          macros, not five.\n\n\t* cpphash.h (TOKEN_NAME): New macro.\n\t(_cpp_spell_operator): Deleted.\n\t(token_spellings): Now _cpp_token_spellings.\n\n\t* cppexp.c: Use TOKEN_NAME or TYPE_NAME, not _cpp_spell_operator.\n\t* cpplex.c: Use OP and TK macros when expanding the\n\tTTYPE_TABLE.  Eliminate token_names.  For non-OPERATOR tokens,\n\tstore the stringification of the enumeration name (CPP_CHAR,\n\tetc.) in the name slot of token_spellings.\n\tUse TOKEN_NAME and/or TOKEN_SPELL, do not reference\n\ttoken_spellings directly.\n\t* cpplib.c: Use TOKEN_SPELL.\n\n\t* cpplex.c (_cpp_push_token): If the token being pushed back\n\tis the previous token in this context, just subtract one from\n\tcontext->posn.\n\t* cppmacro.c (save_expansion): Clear aux field when storing a\n\tplacemarker.\n\n\t* gcc.dg/cpp/paste5.c: New test.\n\t* gcc.dg/cpp/vararg1.c: New test.\n\nFrom-SVN: r35124", "tree": {"sha": "be6672085587ff8d9d75f630009b64878dc2aec5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be6672085587ff8d9d75f630009b64878dc2aec5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96be6998336d305447f3963eb2c9d902eae516a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96be6998336d305447f3963eb2c9d902eae516a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96be6998336d305447f3963eb2c9d902eae516a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96be6998336d305447f3963eb2c9d902eae516a7/comments", "author": null, "committer": null, "parents": [{"sha": "d0089985e7e6ec8fd020e40eb59667a88d0282de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0089985e7e6ec8fd020e40eb59667a88d0282de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0089985e7e6ec8fd020e40eb59667a88d0282de"}], "stats": {"total": 341, "additions": 198, "deletions": 143}, "files": [{"sha": "b6d3f22767fb0618c8a81826d39f6a12a37962b9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96be6998336d305447f3963eb2c9d902eae516a7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96be6998336d305447f3963eb2c9d902eae516a7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=96be6998336d305447f3963eb2c9d902eae516a7", "patch": "@@ -1,3 +1,27 @@\n+2000-07-18  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpplib.h (TTYPE_TABLE): Rearrange to use only two per-entry\n+          macros, not five.\n+\n+\t* cpphash.h (TOKEN_NAME): New macro.\n+\t(_cpp_spell_operator): Deleted.\n+\t(token_spellings): Now _cpp_token_spellings.\n+\n+\t* cppexp.c: Use TOKEN_NAME or TYPE_NAME, not _cpp_spell_operator.\n+\t* cpplex.c: Use OP and TK macros when expanding the\n+\tTTYPE_TABLE.  Eliminate token_names.  For non-OPERATOR tokens,\n+\tstore the stringification of the enumeration name (CPP_CHAR,\n+\tetc.) in the name slot of token_spellings.\n+\tUse TOKEN_NAME and/or TOKEN_SPELL, do not reference\n+\ttoken_spellings directly.\n+\t* cpplib.c: Use TOKEN_SPELL.\n+\t\n+\t* cpplex.c (_cpp_push_token): If the token being pushed back\n+\tis the previous token in this context, just subtract one from\n+\tcontext->posn.\n+\t* cppmacro.c (save_expansion): Clear aux field when storing a\n+\tplacemarker.\n+\n 2000-07-18  Jakub Jelinek  <jakub@redhat.com>\n \n \t* cpplex.c (cpp_scan_buffer): Output line command even at the stop"}, {"sha": "deb5ffb2d49bdc36c2a9063d57fdad6d5544a0ab", "filename": "gcc/cppexp.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96be6998336d305447f3963eb2c9d902eae516a7/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96be6998336d305447f3963eb2c9d902eae516a7/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=96be6998336d305447f3963eb2c9d902eae516a7", "patch": "@@ -397,7 +397,6 @@ lex (pfile, skip_evaluation)\n   switch (tok->type)\n     {\n     case CPP_PLACEMARKER:\n-      /* XXX These shouldn't be visible outside cpplex.c.  */\n       goto retry;\n \n     case CPP_INT:\n@@ -443,8 +442,7 @@ lex (pfile, skip_evaluation)\n \t  return op;\n \t}\n \n-      SYNTAX_ERROR2(\"'%s' is not valid in #if expressions\",\n-\t\t    _cpp_spell_operator (tok->type));\n+      SYNTAX_ERROR2(\"'%s' is not valid in #if expressions\", TOKEN_NAME (tok));\n   }\n \n  syntax_error:\n@@ -718,6 +716,8 @@ op_to_prio[] =\n /* Parse and evaluate a C expression, reading from PFILE.\n    Returns the truth value of the expression.  */\n \n+#define TYPE_NAME(t) _cpp_token_spellings[t].name\n+\n int\n _cpp_parse_expr (pfile)\n      cpp_reader *pfile;\n@@ -804,7 +804,7 @@ _cpp_parse_expr (pfile)\n \t\tSYNTAX_ERROR (\"void expression between '(' and ')'\");\n \t      else\n \t\tSYNTAX_ERROR2 (\"operator '%s' has no right operand\",\n-\t\t\t       _cpp_spell_operator (top->op));\n+\t\t\t       TYPE_NAME (top->op));\n \t    }\n \n \t  unsigned2 = top->unsignedp, v2 = top->value;\n@@ -815,8 +815,7 @@ _cpp_parse_expr (pfile)\n \t  switch (top[1].op)\n \t    {\n \t    default:\n-\t      cpp_ice (pfile, \"impossible operator type %s\",\n-\t\t       _cpp_spell_operator (op.op));\n+\t      cpp_ice (pfile, \"impossible operator type %s\", TYPE_NAME (op.op));\n \t      goto syntax_error;\n \n \t    case CPP_NOT:\t UNARY(!);\tbreak;\n@@ -969,13 +968,13 @@ _cpp_parse_expr (pfile)\n \t{\n \t  if (top->flags & HAVE_VALUE)\n \t    SYNTAX_ERROR2 (\"missing binary operator before '%s'\",\n-\t\t\t   _cpp_spell_operator (op.op));\n+\t\t\t   TYPE_NAME (op.op));\n \t}\n       else\n \t{\n \t  if (!(top->flags & HAVE_VALUE))\n \t    SYNTAX_ERROR2 (\"operator '%s' has no left operand\",\n-\t\t\t   _cpp_spell_operator (op.op));\n+\t\t\t   TYPE_NAME (op.op));\n \t}\n \n       /* Check for and handle stack overflow.  */"}, {"sha": "51f7787e454e4206f36010b611bc49579489aa1e", "filename": "gcc/cpphash.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96be6998336d305447f3963eb2c9d902eae516a7/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96be6998336d305447f3963eb2c9d902eae516a7/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=96be6998336d305447f3963eb2c9d902eae516a7", "patch": "@@ -38,12 +38,13 @@ enum spell_type\n \n struct token_spelling\n {\n-  ENUM_BITFIELD(spell_type) type : CHAR_BIT;\n-  const U_CHAR *spelling;\n+  enum spell_type category;\n+  const U_CHAR *name;\n };\n \n-extern const struct token_spelling token_spellings[];\n-#define TOKEN_SPELL(token) (token_spellings[(token)->type].type)\n+extern const struct token_spelling _cpp_token_spellings[];\n+#define TOKEN_SPELL(token) (_cpp_token_spellings[(token)->type].category)\n+#define TOKEN_NAME(token) (_cpp_token_spellings[(token)->type].name)\n \n /* Chained list of answers to an assertion.  */\n struct answer\n@@ -267,7 +268,6 @@ extern const cpp_token *_cpp_get_token PARAMS ((cpp_reader *));\n extern const cpp_token *_cpp_get_raw_token PARAMS ((cpp_reader *));\n extern void _cpp_push_token PARAMS ((cpp_reader *, const cpp_token*));\n extern const cpp_token *_cpp_glue_header_name PARAMS ((cpp_reader *));\n-extern const U_CHAR *_cpp_spell_operator PARAMS ((enum cpp_ttype));\n \n /* In cpplib.c */\n extern const struct directive *_cpp_check_directive"}, {"sha": "d0d76f9feeb30e5c2f9882ecbeb2646e796f649d", "filename": "gcc/cpplex.c", "status": "modified", "additions": 33, "deletions": 49, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96be6998336d305447f3963eb2c9d902eae516a7/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96be6998336d305447f3963eb2c9d902eae516a7/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=96be6998336d305447f3963eb2c9d902eae516a7", "patch": "@@ -209,35 +209,14 @@ static void process_directive PARAMS ((cpp_reader *, const cpp_token *));\n       if ((f) & BOL) {(d)->col = (s)->col; (d)->line = (s)->line;} \\\n   } while (0)\n \n-#define T(e, s) {SPELL_OPERATOR, (const U_CHAR *) s},\n-#define I(e, s) {SPELL_IDENT, s},\n-#define S(e, s) {SPELL_STRING, s},\n-#define C(e, s) {SPELL_CHAR, s},\n-#define N(e, s) {SPELL_NONE, s},\n+#define OP(e, s) { SPELL_OPERATOR, U s           },\n+#define TK(e, s) { s,              U STRINGX (e) },\n \n const struct token_spelling\n-token_spellings [N_TTYPES + 1] = {TTYPE_TABLE {0, 0} };\n+_cpp_token_spellings [N_TTYPES] = {TTYPE_TABLE };\n \n-#undef T\n-#undef I\n-#undef S\n-#undef C\n-#undef N\n-\n-/* For debugging: the internal names of the tokens.  */\n-#define T(e, s) U STRINGX(e),\n-#define I(e, s) U STRINGX(e),\n-#define S(e, s) U STRINGX(e),\n-#define C(e, s) U STRINGX(e),\n-#define N(e, s) U STRINGX(e),\n-\n-const U_CHAR *const token_names[N_TTYPES] = { TTYPE_TABLE };\n-\n-#undef T\n-#undef I\n-#undef S\n-#undef C\n-#undef N\n+#undef OP\n+#undef TK\n \n /* The following table is used by trigraph_ok/trigraph_replace.  If we\n    have designated initializers, it can be constant data; otherwise,\n@@ -579,7 +558,7 @@ _cpp_expand_name_space (list, len)\n       unsigned int i;\n \n       for (i = 0; i < list->tokens_used; i++)\n-\tif (token_spellings[list->tokens[i].type].type == SPELL_STRING)\n+\tif (TOKEN_SPELL (&list->tokens[i]) == SPELL_STRING)\n \t  list->tokens[i].val.str.text += (list->namebuf - old_namebuf);\n     }\n }\n@@ -684,7 +663,7 @@ _cpp_equiv_tokens (a, b)\n      const cpp_token *a, *b;\n {\n   if (a->type == b->type && a->flags == b->flags)\n-    switch (token_spellings[a->type].type)\n+    switch (TOKEN_SPELL (a))\n       {\n       default:\t\t\t/* Keep compiler happy.  */\n       case SPELL_OPERATOR:\n@@ -1966,7 +1945,7 @@ spell_token (pfile, token, buffer)\n      const cpp_token *token;\n      unsigned char *buffer;\n {\n-  switch (token_spellings[token->type].type)\n+  switch (TOKEN_SPELL (token))\n     {\n     case SPELL_OPERATOR:\n       {\n@@ -1976,7 +1955,7 @@ spell_token (pfile, token, buffer)\n \tif (token->flags & DIGRAPH)\n \t  spelling = digraph_spellings[token->type - CPP_FIRST_DIGRAPH];\n \telse\n-\t  spelling = token_spellings[token->type].spelling;\n+\t  spelling = TOKEN_NAME (token);\n \t\n \twhile ((c = *spelling++) != '\\0')\n \t  *buffer++ = c;\n@@ -2013,26 +1992,13 @@ spell_token (pfile, token, buffer)\n       break;\n \n     case SPELL_NONE:\n-      cpp_ice (pfile, \"Unspellable token %s\", token_names[token->type]);\n+      cpp_ice (pfile, \"Unspellable token %s\", TOKEN_NAME (token));\n       break;\n     }\n \n   return buffer;\n }\n \n-/* Return the spelling of a token known to be an operator.\n-   Does not distinguish digraphs from their counterparts.  */\n-const unsigned char *\n-_cpp_spell_operator (type)\n-     enum cpp_ttype type;\n-{\n-  if (token_spellings[type].type == SPELL_OPERATOR)\n-    return token_spellings[type].spelling;\n-  else\n-    return token_names[type];\n-}\n-\n-\n /* Macro expansion algorithm.\n \n Macro expansion is implemented by a single-pass algorithm; there are\n@@ -2554,7 +2520,7 @@ release_temp_tokens (pfile)\n     {\n       cpp_token *token = pfile->temp_tokens[--pfile->temp_used];\n \n-      if (token_spellings[token->type].type == SPELL_STRING)\n+      if (TOKEN_SPELL (token) == SPELL_STRING)\n \t{\n \t  free ((char *) token->val.str.text);\n \t  token->val.str.text = 0;\n@@ -2595,7 +2561,7 @@ duplicate_token (pfile, token)\n   cpp_token *result = get_temp_token (pfile);\n \n   *result = *token;\n-  if (token_spellings[token->type].type == SPELL_STRING)\n+  if (TOKEN_SPELL (token) == SPELL_STRING)\n     {\n       U_CHAR *buff = (U_CHAR *) xmalloc (token->val.str.len);\n       memcpy (buff, token->val.str.text, token->val.str.len);\n@@ -2837,6 +2803,9 @@ stringify_arg (pfile, token)\n       unsigned char *buf;\n       unsigned int len = TOKEN_LEN (token);\n \n+      if (token->type == CPP_PLACEMARKER)\n+\tcontinue;\n+\n       escape = (token->type == CPP_STRING || token->type == CPP_WSTRING\n \t\t|| token->type == CPP_CHAR || token->type == CPP_WCHAR);\n       if (escape)\n@@ -3008,6 +2977,22 @@ _cpp_push_token (pfile, token)\n      const cpp_token *token;\n {\n   cpp_context *context = CURRENT_CONTEXT (pfile);\n+\n+  if (context->posn > 0)\n+    {\n+      const cpp_token *prev;\n+      if (IS_ARG_CONTEXT (context))\n+\tprev = context->u.arg[context->posn - 1];\n+      else\n+\tprev = &context->u.list->tokens[context->posn - 1];\n+\n+      if (prev == token)\n+\t{\n+\t  context->posn--;\n+\t  return;\n+\t}\n+    }\n+\n   if (context->pushed_token)\n     cpp_ice (pfile, \"two tokens pushed in a row\");\n   if (token->type != CPP_EOF)\n@@ -3031,8 +3016,7 @@ process_directive (pfile, token)\n   if (token[1].type == CPP_NAME)\n     _cpp_get_raw_token (pfile);\n   else if (token[1].type != CPP_NUMBER)\n-    cpp_ice (pfile, \"directive begins with %s?!\",\n-\t     token_names[token[1].type]);\n+    cpp_ice (pfile, \"directive begins with %s?!\", TOKEN_NAME (token));\n \n   /* Flush pending tokens at this point, in case the directive produces\n      output.  XXX Directive output won't be visible to a direct caller of\n@@ -3491,7 +3475,7 @@ _cpp_dump_list (pfile, list, token, flush)\n \t    CPP_PUTC (pfile, '#');\n \t  dump_param_spelling (pfile, list, token->val.aux);\n \t}\n-      else\n+      else if (token->type != CPP_PLACEMARKER)\n \toutput_token (pfile, token, prev);\n       if (token->flags & PASTE_LEFT)\n \tCPP_PUTS (pfile, \" ##\", 3);"}, {"sha": "520821ab8d9a4b1a29984d0473e63e916506519d", "filename": "gcc/cpplib.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96be6998336d305447f3963eb2c9d902eae516a7/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96be6998336d305447f3963eb2c9d902eae516a7/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=96be6998336d305447f3963eb2c9d902eae516a7", "patch": "@@ -1252,7 +1252,7 @@ _cpp_parse_assertion (pfile, answerp)\n       dest = &list->tokens[list->tokens_used++];\n       *dest = *token;\n \n-      if (token_spellings[token->type].type == SPELL_STRING)\n+      if (TOKEN_SPELL (token) == SPELL_STRING)\n \t{\n \t  _cpp_expand_name_space (list, token->val.str.len);\n \t  dest->val.str.text = list->namebuf + list->name_used;"}, {"sha": "b8da90aa61e345bd093726938806c8c11766aaee", "filename": "gcc/cpplib.h", "status": "modified", "additions": 76, "deletions": 80, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96be6998336d305447f3963eb2c9d902eae516a7/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96be6998336d305447f3963eb2c9d902eae516a7/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=96be6998336d305447f3963eb2c9d902eae516a7", "patch": "@@ -50,96 +50,92 @@ typedef struct cpp_hashnode cpp_hashnode;\n #define CPP_FIRST_DIGRAPH CPP_HASH\n \n #define TTYPE_TABLE\t\t\t\t\\\n-  T(CPP_EQ = 0,\t\t\"=\")\t\t\t\\\n-  T(CPP_NOT,\t\t\"!\")\t\t\t\\\n-  T(CPP_GREATER,\t\">\")\t/* compare */\t\\\n-  T(CPP_LESS,\t\t\"<\")\t\t\t\\\n-  T(CPP_PLUS,\t\t\"+\")\t/* math */\t\\\n-  T(CPP_MINUS,\t\t\"-\")\t\t\t\\\n-  T(CPP_MULT,\t\t\"*\")\t\t\t\\\n-  T(CPP_DIV,\t\t\"/\")\t\t\t\\\n-  T(CPP_MOD,\t\t\"%\")\t\t\t\\\n-  T(CPP_AND,\t\t\"&\")\t/* bit ops */\t\\\n-  T(CPP_OR,\t\t\"|\")\t\t\t\\\n-  T(CPP_XOR,\t\t\"^\")\t\t\t\\\n-  T(CPP_RSHIFT,\t\t\">>\")\t\t\t\\\n-  T(CPP_LSHIFT,\t\t\"<<\")\t\t\t\\\n+  OP(CPP_EQ = 0,\t\"=\")\t\t\t\\\n+  OP(CPP_NOT,\t\t\"!\")\t\t\t\\\n+  OP(CPP_GREATER,\t\">\")\t/* compare */\t\\\n+  OP(CPP_LESS,\t\t\"<\")\t\t\t\\\n+  OP(CPP_PLUS,\t\t\"+\")\t/* math */\t\\\n+  OP(CPP_MINUS,\t\t\"-\")\t\t\t\\\n+  OP(CPP_MULT,\t\t\"*\")\t\t\t\\\n+  OP(CPP_DIV,\t\t\"/\")\t\t\t\\\n+  OP(CPP_MOD,\t\t\"%\")\t\t\t\\\n+  OP(CPP_AND,\t\t\"&\")\t/* bit ops */\t\\\n+  OP(CPP_OR,\t\t\"|\")\t\t\t\\\n+  OP(CPP_XOR,\t\t\"^\")\t\t\t\\\n+  OP(CPP_RSHIFT,\t\">>\")\t\t\t\\\n+  OP(CPP_LSHIFT,\t\"<<\")\t\t\t\\\n \\\n-  T(CPP_COMPL,\t\t\"~\")\t\t\t\\\n-  T(CPP_AND_AND,\t\"&&\")\t/* logical */\t\\\n-  T(CPP_OR_OR,\t\t\"||\")\t\t\t\\\n-  T(CPP_QUERY,\t\t\"?\")\t\t\t\\\n-  T(CPP_COLON,\t\t\":\")\t\t\t\\\n-  T(CPP_COMMA,\t\t\",\")\t/* grouping */\t\\\n-  T(CPP_OPEN_PAREN,\t\"(\")\t\t\t\\\n-  T(CPP_CLOSE_PAREN,\t\")\")\t\t\t\\\n-  T(CPP_EQ_EQ,\t\t\"==\")\t/* compare */\t\\\n-  T(CPP_NOT_EQ,\t\t\"!=\")\t\t\t\\\n-  T(CPP_GREATER_EQ,\t\">=\")\t\t\t\\\n-  T(CPP_LESS_EQ,\t\"<=\")\t\t\t\\\n+  OP(CPP_COMPL,\t\t\"~\")\t\t\t\\\n+  OP(CPP_AND_AND,\t\"&&\")\t/* logical */\t\\\n+  OP(CPP_OR_OR,\t\t\"||\")\t\t\t\\\n+  OP(CPP_QUERY,\t\t\"?\")\t\t\t\\\n+  OP(CPP_COLON,\t\t\":\")\t\t\t\\\n+  OP(CPP_COMMA,\t\t\",\")\t/* grouping */\t\\\n+  OP(CPP_OPEN_PAREN,\t\"(\")\t\t\t\\\n+  OP(CPP_CLOSE_PAREN,\t\")\")\t\t\t\\\n+  OP(CPP_EQ_EQ,\t\t\"==\")\t/* compare */\t\\\n+  OP(CPP_NOT_EQ,\t\"!=\")\t\t\t\\\n+  OP(CPP_GREATER_EQ,\t\">=\")\t\t\t\\\n+  OP(CPP_LESS_EQ,\t\"<=\")\t\t\t\\\n \\\n-  T(CPP_PLUS_EQ,\t\"+=\")\t/* math */\t\\\n-  T(CPP_MINUS_EQ,\t\"-=\")\t\t\t\\\n-  T(CPP_MULT_EQ,\t\"*=\")\t\t\t\\\n-  T(CPP_DIV_EQ,\t\t\"/=\")\t\t\t\\\n-  T(CPP_MOD_EQ,\t\t\"%=\")\t\t\t\\\n-  T(CPP_AND_EQ,\t\t\"&=\")\t/* bit ops */\t\\\n-  T(CPP_OR_EQ,\t\t\"|=\")\t\t\t\\\n-  T(CPP_XOR_EQ,\t\t\"^=\")\t\t\t\\\n-  T(CPP_RSHIFT_EQ,\t\">>=\")\t\t\t\\\n-  T(CPP_LSHIFT_EQ,\t\"<<=\")\t\t\t\\\n+  OP(CPP_PLUS_EQ,\t\"+=\")\t/* math */\t\\\n+  OP(CPP_MINUS_EQ,\t\"-=\")\t\t\t\\\n+  OP(CPP_MULT_EQ,\t\"*=\")\t\t\t\\\n+  OP(CPP_DIV_EQ,\t\"/=\")\t\t\t\\\n+  OP(CPP_MOD_EQ,\t\"%=\")\t\t\t\\\n+  OP(CPP_AND_EQ,\t\"&=\")\t/* bit ops */\t\\\n+  OP(CPP_OR_EQ,\t\t\"|=\")\t\t\t\\\n+  OP(CPP_XOR_EQ,\t\"^=\")\t\t\t\\\n+  OP(CPP_RSHIFT_EQ,\t\">>=\")\t\t\t\\\n+  OP(CPP_LSHIFT_EQ,\t\"<<=\")\t\t\t\\\n   /* Digraphs together, beginning with CPP_FIRST_DIGRAPH.  */\t\\\n-  T(CPP_HASH,\t\t\"#\")\t/* digraphs */\t\\\n-  T(CPP_PASTE,\t\t\"##\")\t\t\t\\\n-  T(CPP_OPEN_SQUARE,\t\"[\")\t\t\t\\\n-  T(CPP_CLOSE_SQUARE,\t\"]\")\t\t\t\\\n-  T(CPP_OPEN_BRACE,\t\"{\")\t\t\t\\\n-  T(CPP_CLOSE_BRACE,\t\"}\")\t\t\t\\\n-  /* The remainder of the punctuation.  Order is not significant. */\t\\\n-  T(CPP_SEMICOLON,\t\";\")\t/* structure */\t\\\n-  T(CPP_ELLIPSIS,\t\"...\")\t\t\t\\\n-  T(CPP_BACKSLASH,\t\"\\\\\")\t\t\t\\\n-  T(CPP_PLUS_PLUS,\t\"++\")\t/* increment */\t\\\n-  T(CPP_MINUS_MINUS,\t\"--\")\t\t\t\\\n-  T(CPP_DEREF,\t\t\"->\")\t/* accessors */\t\\\n-  T(CPP_DOT,\t\t\".\")\t\t\t\\\n-  T(CPP_SCOPE,\t\t\"::\")\t\t\t\\\n-  T(CPP_DEREF_STAR,\t\"->*\")\t\t\t\\\n-  T(CPP_DOT_STAR,\t\".*\")\t\t\t\\\n-  T(CPP_MIN,\t\t\"<?\")\t/* extension */\t\\\n-  T(CPP_MAX,\t\t\">?\")\t\t\t\\\n-  T(CPP_PLACEMARKER,\t\"\")\t/* Placemarker token.  */  \\\n-  C(CPP_OTHER,\t\t0)\t/* stray punctuation */    \\\n+  OP(CPP_HASH,\t\t\"#\")\t/* digraphs */\t\\\n+  OP(CPP_PASTE,\t\t\"##\")\t\t\t\\\n+  OP(CPP_OPEN_SQUARE,\t\"[\")\t\t\t\\\n+  OP(CPP_CLOSE_SQUARE,\t\"]\")\t\t\t\\\n+  OP(CPP_OPEN_BRACE,\t\"{\")\t\t\t\\\n+  OP(CPP_CLOSE_BRACE,\t\"}\")\t\t\t\\\n+  /* The remainder of the punctuation.  Order is not significant.  */\t\\\n+  OP(CPP_SEMICOLON,\t\";\")\t/* structure */\t\\\n+  OP(CPP_ELLIPSIS,\t\"...\")\t\t\t\\\n+  OP(CPP_BACKSLASH,\t\"\\\\\")\t\t\t\\\n+  OP(CPP_PLUS_PLUS,\t\"++\")\t/* increment */\t\\\n+  OP(CPP_MINUS_MINUS,\t\"--\")\t\t\t\\\n+  OP(CPP_DEREF,\t\t\"->\")\t/* accessors */\t\\\n+  OP(CPP_DOT,\t\t\".\")\t\t\t\\\n+  OP(CPP_SCOPE,\t\t\"::\")\t\t\t\\\n+  OP(CPP_DEREF_STAR,\t\"->*\")\t\t\t\\\n+  OP(CPP_DOT_STAR,\t\".*\")\t\t\t\\\n+  OP(CPP_MIN,\t\t\"<?\")\t/* extension */\t\\\n+  OP(CPP_MAX,\t\t\">?\")\t\t\t\\\n \\\n-  I(CPP_NAME,\t\t0)\t/* word */\t\\\n-  S(CPP_INT,\t\t0)\t/* 23 */\t\\\n-  S(CPP_FLOAT,\t\t0)\t/* 3.14159 */\t\\\n-  S(CPP_NUMBER,\t\t0)\t/* 34_be+ta  */\t\\\n-  S(CPP_CHAR,\t\t0)\t/* 'char' */\t\\\n-  S(CPP_WCHAR,\t\t0)\t/* L'char' */\t\\\n-  S(CPP_STRING,\t\t0)\t/* \"string\" */\t\\\n-  S(CPP_WSTRING,\t0)\t/* L\"string\" */\t\\\n+  TK(CPP_NAME,\t\tSPELL_IDENT)\t/* word */\t\t\t\\\n+  TK(CPP_INT,\t\tSPELL_STRING)\t/* 23 */\t\t\t\\\n+  TK(CPP_FLOAT,\t\tSPELL_STRING)\t/* 3.14159 */\t\t\t\\\n+  TK(CPP_NUMBER,\tSPELL_STRING)\t/* 34_be+ta  */\t\t\t\\\n \\\n-  S(CPP_COMMENT,\t0)\t/* Only if output comments.  */ \\\n-  N(CPP_MACRO_ARG,      0)\t/* Macro argument.  */          \\\n-  N(CPP_EOF,\t\t0)\t/* End of file.  */\t\t\\\n-  S(CPP_HEADER_NAME,\t0)\t/* <stdio.h> in #include */\n-\n-#define T(e, s) e,\n-#define I(e, s) e,\n-#define S(e, s) e,\n-#define C(e, s) e,\n-#define N(e, s) e,\n+  TK(CPP_CHAR,\t\tSPELL_STRING)\t/* 'char' */\t\t\t\\\n+  TK(CPP_WCHAR,\t\tSPELL_STRING)\t/* L'char' */\t\t\t\\\n+  TK(CPP_OTHER,\t\tSPELL_CHAR)\t/* stray punctuation */\t\t\\\n+\\\n+  TK(CPP_STRING,\tSPELL_STRING)\t/* \"string\" */\t\t\t\\\n+  TK(CPP_WSTRING,\tSPELL_STRING)\t/* L\"string\" */\t\t\t\\\n+  TK(CPP_HEADER_NAME,\tSPELL_STRING)\t/* <stdio.h> in #include */\t\\\n+\\\n+  TK(CPP_COMMENT,\tSPELL_STRING)\t/* Only if output comments.  */ \\\n+  TK(CPP_MACRO_ARG,\tSPELL_NONE)\t/* Macro argument.  */\t\t\\\n+  TK(CPP_PLACEMARKER,\tSPELL_NONE)\t/* Placemarker token.  */\t\\\n+  TK(CPP_EOF,\t\tSPELL_NONE)\t/* End of file.\t */\n+\n+#define OP(e, s) e,\n+#define TK(e, s) e,\n enum cpp_ttype\n {\n   TTYPE_TABLE\n   N_TTYPES\n };\n-#undef T\n-#undef I\n-#undef S\n-#undef C\n-#undef N\n+#undef OP\n+#undef TK\n \n /* Payload of a NUMBER, FLOAT, STRING, or COMMENT token.  */\n struct cpp_string"}, {"sha": "3dc973f3b831b89c44198765a5789b584a63c647", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96be6998336d305447f3963eb2c9d902eae516a7/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96be6998336d305447f3963eb2c9d902eae516a7/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=96be6998336d305447f3963eb2c9d902eae516a7", "patch": "@@ -495,6 +495,7 @@ save_expansion (pfile, info)\n     {\n       dest->type = CPP_PLACEMARKER;\n       dest->flags = 0;\n+      dest->val.aux = 0;\n     }\n \n   return list;"}, {"sha": "2ed6ef11b4c2cbbedcaf61ca5e98da5ee6b3fd20", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96be6998336d305447f3963eb2c9d902eae516a7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96be6998336d305447f3963eb2c9d902eae516a7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=96be6998336d305447f3963eb2c9d902eae516a7", "patch": "@@ -1,3 +1,11 @@\n+2000-07-18  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpplex.c (_cpp_push_token): If the token being pushed back\n+\tis the previous token in this context, just subtract one from\n+\tcontext->posn.\n+\t* cppmacro.c (save_expansion): Clear aux field when storing a\n+\tplacemarker.\n+\n 2000-07-18  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* gcc.dg/noncompile/redecl-1.c: New test."}, {"sha": "2a763f58e19416bb67eb2075de7a51e4892a4ee9", "filename": "gcc/testsuite/gcc.dg/cpp/paste5.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96be6998336d305447f3963eb2c9d902eae516a7/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96be6998336d305447f3963eb2c9d902eae516a7/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fpaste5.c?ref=96be6998336d305447f3963eb2c9d902eae516a7", "patch": "@@ -0,0 +1,24 @@\n+/* Regression test for bug in convoluted situation involving token paste\n+   plus function-like macros used outside function context.  It may be\n+   easier to understand if you mentally replace 'struct' with 'A'\n+   throughout this file; 'struct' is used only to get the code to compile\n+   when preprocessed correctly.\n+\n+   The original problem was seen in the Linux kernel and reported by\n+   Jakub Jelinek <jakub@redhat.com>; this test is synthetic.  */\n+\n+/* { dg-do compile } */\n+\n+#define glue(a,b) a##b\n+#define struct(x) B(x)\n+#define E(x) struct x\n+#define FG (22)\n+\n+extern void B(int);\n+\n+void foo(void)\n+{\n+  E(glue(F,*)) dummy;  /* { dg-warning \"valid preprocessing token\" } */\n+\n+  E(glue(F,G)) ;\n+}"}, {"sha": "aa8ed797318e52cbe550d8fdd0c5c770dcdb51e9", "filename": "gcc/testsuite/gcc.dg/cpp/vararg1.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96be6998336d305447f3963eb2c9d902eae516a7/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fvararg1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96be6998336d305447f3963eb2c9d902eae516a7/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fvararg1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fvararg1.c?ref=96be6998336d305447f3963eb2c9d902eae516a7", "patch": "@@ -0,0 +1,19 @@\n+/* Test for changed behavior of the GNU varargs extension.\n+   ##args, where args is a rest argument which received zero tokens,\n+   used to delete the previous sequence of nonwhitespace characters.\n+   Now it deletes the previous token.  */\n+\n+/* { dg-do run } */\n+/* { dg-options -w } */\n+\n+#include <string.h>\n+\n+#define S(str, args...) \"  \" str \"\\n\", ##args\n+\n+int\n+main()\n+{\n+  const char *s = S(\"foo\");\n+  return strchr (s, '\\n') == NULL;\n+}\n+"}]}