{"sha": "21d279972261484650109d662caf32b73a91bf1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjFkMjc5OTcyMjYxNDg0NjUwMTA5ZDY2MmNhZjMyYjczYTkxYmYxZA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2008-04-08T06:45:25Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-04-08T06:45:25Z"}, "message": "alloc.ads: Add entries for Obsolescent_Warnings table\n\n2008-04-08  Robert Dewar  <dewar@adacore.com>\n\t    Bob Duff  <duff@adacore.com>\n\t    Gary Dismukes  <dismukes@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* alloc.ads: Add entries for Obsolescent_Warnings table\n\n\t* einfo.ads, einfo.adb: Minor reformatting.\n\t(Is_Discriminal): New subprogram.\n\t(Is_Prival): New subprogram.\n\t(Is_Protected_Component): New subprogram.\n\t(Is_Protected_Private): Removed.\n\t(Object_Ref, Set_Object_Ref): Removed.\n\t(Prival, Set_Prival): Change assertion.\n\t(Privals_Chain, Set_Privals_Chain): Removed.\n\t(Prival_Link, Set_Prival_Link): New subprogram.\n\t(Protected_Operation, Set_Protected_Operation): Removed.\n\t(Protection_Object, Set_Protection_Object): New subprogram.\n\t(Write_Field17_Name): Remove case for Object_Ref.\n\t(Write_Field20_Name): Add case for Prival_Link.\n\t(Write_Field22_Name): Remove case for Protected_Operation,\n\tPrivals_Chain.\n\tAdd case for Protection_Object.\n\t(Can_Use_Internal_Rep): Make this into a [base type only] attribute,\n\tso clients\n\t(Overlays_Constant): New flag\n\t(Is_Constant_Object): New predicate\n\t(Is_Standard_Character_Type): New predicate\n\t(Optimize_Alignment_Space): New flag\n\t(Optimize_Alignment_Time): New flag\n\t(Has_Postconditions): New flag\n\t(Obsolescent_Warrning): Field removed\n\t(Spec_PPC_List): New field\n\t(Relative_Deadline_Variable, Set_Relative_Deadline_Variable): Add\n\tsubprograms to get and set the relative deadline associated to a task.\n\n\t* exp_attr.adb (May_Be_External_Call): Account for the case where the\n\tAccess attribute is part of a named parameter association.\n\t(Expand_Access_To_Protected_Op): Test for the attribute occurring\n\twithin an init proc and use that directly as the scope rather than\n\ttraversing up to the protected operation's enclosing scope. Only apply\n\tassertion on Is_Open_Scopes in the case the scope traversal is done.\n\tFor the init proc case use the address of the first formal (_init) as\n\tthe protected object reference.\n\tImplement Invalid_Value attribute\n\t(Expand_N_Attribute_Reference): Case Attribute_Unrestricted_Access.\n\tcontents of the dispatch table there is no need to duplicate the\n\titypes associated with record types (i.e. the implicit full view\n\tof private types).\n\tImplement Enum_Val attribute\n\t(Expand_N_Attribute_Reference, case Old): Properly handle appearence\n\twithin _Postconditions procedure\n\t(Expand_N_Attribute_Reference, case Result): Implement new attribute\n\n\t* exp_ch5.adb (Expand_N_Simple_Return_Statement): Handle case in which\n\ta return statement calls a function that is not available in\n\tconfigurable runtime.\n\t(Analyze_If_Statement): don't optimize simple True/False cases in -O0\n\t(Expand_Non_Function_Return): Generate call to _Postconditions proc\n\t(Expand_Simple_Function_Return): Ditto\n\n\t* frontend.adb: Add call to Sem_Aux.Initialize\n\n\t* sem_aux.ads, sem_aux.adb: New file.\n\n\t* par-prag.adb: Add entries for pragmas Precondition/Postcondition\n\tAdd new Pragma_Relative_Deadline.\n\tAdd support for pragmas Check and Check_Policy\n\n\t* sem_attr.ads, sem_attr.adb (Check_Not_CPP_Type): New subprogram.\n\t(Check_Stream_Attribute): Add missing check (not allowed in CPP types)\n\t(Analyze_Attribute): In case of attributes 'Alignment and 'size add\n\tmissing check because they are not allowed in CPP tagged types.\n\tAdd Sure parameter to Note_Possible_Modification calls\n\tAdd implementation of Invalid_Value attribute\n\tImplement new attribute Has_Tagged_Values\n\tImplement Enum_Val attribute\n\t(Analyze_Attribute, case Range): Set Name_Req True for prefix of\n\tgenerated attributes.\n\t(Analyze_Attribute, case Result): If prefix of the attribute is\n\toverloaded, it always resolves to the enclosing function.\n\t(Analyze_Attribute, case Result): Properly deal with analysis when\n\tPostconditions are not active.\n\t(Resolve_Attribute, case Result): Properly deal with appearence during\n\tpreanalysis in spec.\n\tAdd processing for attribute Result\n\n\t* sem_ch6.ads, sem_ch6.adb (Check_Overriding_Indicator): Code cleanup\n\tfor operators.\n\t(Analyze_Subprogram_Body): Install private_with_clauses when the body\n\tacts as a spec.\n\t(Check_Inline_Pragma): recognize an inline pragma that appears within\n\tthe subprogram body to which it applies.\n\t(Analyze_Function_Return): Check that type of the expression of a return\n\tstatement in a function with a class-wide result is not declared at a\n\tdeeper level than the function.\n\t(Process_PPCs): Deal with enabling/disabling, using PPC_Enabled flag\n\t(Verify_Overriding_Indicator): Handle properly subprogram bodies for\n\tuser- defined operators.\n\t(Install_Formals): Moved to spec to allow use from Sem_Prag for\n\tanalysis of precondition/postcondition pragmas.\n\t(Analyze_Subprogram_Body.Last_Real_Spec_Entity): New name for\n\tLast_Formal, along with lots of comments on what this is about\n\t(Analyze_Subprogram_Body): Fix case where we move entities from the\n\tspec to the body when there are no body entities (now possible with\n\tprecondition and postcondition pragmas).\n\t(Process_PPCs): New procedure\n\t(Analyze_Subprogram_Body): Add call to Process_PPCs\n\n\t* sem_ch8.adb (Use_One_Type): refine warning on a redundant use_type\n\tclause.\n\t(Pop_Scope): Restore Check_Policy_List on scope exit\n\t(Push_Scope): Save Check_Policy_List on scope entry\n\tChange name In_Default_Expression      => In_Spec_Expression\n\tChange name Analyze_Per_Use_Expression => Preanalyze_Spec_Expression\n\tChange name Pre_Analyze_And_Resolve    => Preanalyze_And_Resolve\n\t(Analyze_Object_Renaming): Allow 'Reference as object\n\t(Analyze_Pragma, case Restriction_Warnings): Call GNAT_Pragma\n\t(Process_Restrictions_Or_Restriction_Warnings): Check for bad spelling\n\tof restriction identifier.\n\tAdd Sure parameter to Note_Possible_Modication calls\n\n\t* sem_prag.ads, sem_prag.adb (Analyze_Pragma, case Stream_Convert):\n\tDon't check for primitive operations when calling Rep_Item_Too_Late.\n\t(Process_Import_Or_Interface): Do not place flag on formal\n\tsubprograms.\n\t(Analyze_Pragma, case Export): If the entity is a deferred constant,\n\tpropagate information to full view, which is the one elaborated by the\n\tback-end.\n\t(Make_Inline): the pragma is effective if it applies to an internally\n\tgenerated subprogram declaration for a body that carries the pragma.\n\t(Analyze_Pragma, case Optimize_Alignment): Set new flag\n\tOptimize_Alignment_Local.\n\t(Analyze_PPC_In_Decl_Part): New procedure\n\t(Get_Pragma_Arg): Moved to outer level\n\t(Check_Precondition_Postcondition): Change to allow new visibility\n\trules for package spec\n\t(Analyze_Pragma, case Check_Policy): Change placement rules to be\n\tsame as pragma Suppress/Unsuppress.\n\tChange name In_Default_Expression      => In_Spec_Expression\n\tChange name Analyze_Per_Use_Expression => Preanalyze_Spec_Expression\n\tChange name Pre_Analyze_And_Resolve    => Preanalyze_And_Resolve\n\t(Check_Precondition_Postcondition): Do proper visibility preanalysis\n\tfor the case of these pragmas appearing in the spec.\n\t(Check_Enabled): New function\n\t(Initialize): New procedure\n\t(Tree_Read): New procedure\n\t(Tree_Write): New procedure\n\t(Check_Precondition_Postcondition): New procedure\n\tImplement pragmas Check and Check_Policy\n\tMerge Assert processing with Check\n\n\t* sem_warn.adb (Warn_On_Known_Condition): Handle pragma Check\n\tNew warning flag -gnatw.e\n\n\t* sinfo.ads, sinfo.adb (Has_Relative_Deadline_Pragma): New function\n\treturning whether a task (or main procedure) has a pragma\n\tRelative_Deadline.\n\t(Set_Has_Relative_Deadline_Pragma): Procedure to indicate that a task\n\t(or main procedure) has a pragma Relative_Deadline.\n\tAdd Next_Pragma field to N_Pragma node\n\t(PPC_Enabled): New flag\n\t(Next_Pragma): Now used for Pre/Postcondition processing\n\n\t* snames.h, snames.ads, snames.adb: New standard name\n\tInherit_Source_Path\n\tAdd entry for 'Invalid_Value attribute\n\tAdd entry for new attribute Has_Tagged_Values\n\tAdd entry for Enum_Val attribute\n\tAdd new standard names Aggregate, Configuration and Library.\n\tAdd _Postconditions\n\tAdd _Result\n\tAdd Pragma_Precondition\n\tAdd Pragma_Postcondition\n\tAdd Attribute_Result\n\tNew standard name Archive_Builder_Append_Option\n\t(Preset_Names): Add _relative_deadline and relative_deadline definitions\n\tThere was also a missing non_preemptive_within_priorities.\n\t(Get_Pragma_Id, Is_Pragma_Name): Add support for pragma\n\tRelative_Deadline.\n\tAdd support for pragmas Check and Check_Policy\n\n\t* tree_gen.adb: Call Sem_Aux.Tree_Write\n\n\t* tree_in.adb: Call Sem_Aux.Tree_Read\n\n\t* exp_ch11.adb (Expand_N_Raise_Statement): New Build_Location calling\n\tsequence\n\n\t* exp_intr.adb (Expand_Source_Info): New Build_Location calling\n\tsequence\n\n\t* exp_prag.adb (Expand_Pragma_Relative_Deadline): New procedure.\n\t(Expand_N_Pragma): Call the appropriate procedure for expanding pragma\n\tRelative_Deadline.\n\t(Expand_Pragma_Check): New procedure\n\n\t* sinput.ads, sinput.adb (Build_Location_String): Now appends to name\n\tbuffer.\n\n\t* sinfo.adb (PPC_Enabled): New flag\n\nFrom-SVN: r134010", "tree": {"sha": "e4cc7613e520d7e95dfe0fcf3b07c6eab2b5d99c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e4cc7613e520d7e95dfe0fcf3b07c6eab2b5d99c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21d279972261484650109d662caf32b73a91bf1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21d279972261484650109d662caf32b73a91bf1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21d279972261484650109d662caf32b73a91bf1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21d279972261484650109d662caf32b73a91bf1d/comments", "author": null, "committer": null, "parents": [{"sha": "1ed69f611a49303c68258905e067c1c5888b9248", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ed69f611a49303c68258905e067c1c5888b9248", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ed69f611a49303c68258905e067c1c5888b9248"}], "stats": {"total": 6644, "additions": 4326, "deletions": 2318}, "files": [{"sha": "7bfe9aa816291f2e4b99d2edfddb6046fb6f9398", "filename": "gcc/ada/alloc.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Falloc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Falloc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Falloc.ads?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -99,6 +99,9 @@ package Alloc is\n    Nodes_Initial                    : constant := 50_000;  -- Atree\n    Nodes_Increment                  : constant := 100;\n \n+   Obsolescent_Warnings_Initial     : constant := 50;      -- Sem_Prag\n+   Obsolescent_Warnings_Increment   : constant := 200;\n+\n    Orig_Nodes_Initial               : constant := 50_000;  -- Atree\n    Orig_Nodes_Increment             : constant := 100;\n "}, {"sha": "7374a7e41ae90a952f266a37b383a7d330476e54", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 308, "deletions": 172, "changes": 480, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -70,7 +70,6 @@ package body Einfo is\n    --    Homonym                         Node4\n    --    First_Rep_Item                  Node6\n    --    Freeze_Node                     Node7\n-   --    Obsolescent_Warning             Node24\n \n    --  The usage of other fields (and the entity kinds to which it applies)\n    --  depends on the particular field (see Einfo spec for details).\n@@ -147,7 +146,6 @@ package body Einfo is\n    --    Master_Id                       Node17\n    --    Modulus                         Uint17\n    --    Non_Limited_View                Node17\n-   --    Object_Ref                      Node17\n    --    Prival                          Node17\n \n    --    Alias                           Node18\n@@ -175,6 +173,7 @@ package body Einfo is\n    --    Discriminant_Checking_Func      Node20\n    --    Discriminant_Default_Value      Node20\n    --    Last_Entity                     Node20\n+   --    Prival_Link                     Node20\n    --    Register_Exception_Call         Node20\n    --    Scalar_Range                    Node20\n \n@@ -198,22 +197,20 @@ package body Einfo is\n \n    --    Associated_Final_Chain          Node23\n    --    CR_Discriminant                 Node23\n-   --    Stored_Constraint               Elist23\n    --    Entry_Cancel_Parameter          Node23\n+   --    Enum_Pos_To_Rep                 Node23\n    --    Extra_Constrained               Node23\n    --    Generic_Renamings               Elist23\n    --    Inner_Instances                 Elist23\n-   --    Enum_Pos_To_Rep                 Node23\n-   --    Packed_Array_Type               Node23\n    --    Limited_View                    Node23\n-   --    Privals_Chain                   Elist23\n-   --    Protected_Operation             Node23\n+   --    Packed_Array_Type               Node23\n+   --    Protection_Object               Node23\n+   --    Stored_Constraint               Elist23\n \n-   --    Obsolescent_Warning             Node24\n+   --    Spec_PPC_List                   Node24\n \n    --    Abstract_Interface_Alias        Node25\n    --    Abstract_Interfaces             Elist25\n-   --    Current_Use_Clause              Node25\n    --    Debug_Renaming_Link             Node25\n    --    DT_Offset_To_Top_Func           Node25\n    --    Task_Body_Procedure             Node25\n@@ -223,8 +220,10 @@ package body Einfo is\n    --    Overridden_Operation            Node26\n    --    Package_Instantiation           Node26\n    --    Related_Type                    Node26\n+   --    Relative_Deadline_Variable      Node26\n    --    Static_Initialization           Node26\n \n+   --    Current_Use_Clause              Node27\n    --    Wrapped_Entity                  Node27\n \n    --    Extra_Formals                   Node28\n@@ -495,17 +494,18 @@ package body Einfo is\n    --    Renamed_In_Spec                 Flag231\n    --    Implemented_By_Entry            Flag232\n    --    Has_Pragma_Unmodified           Flag233\n-   --    Is_Static_Dispatch_Table_Entity Flag234\n+   --    Is_Dispatch_Table_Entity        Flag234\n    --    Is_Trivial_Subprogram           Flag235\n    --    Warnings_Off_Used               Flag236\n    --    Warnings_Off_Used_Unmodified    Flag237\n    --    Warnings_Off_Used_Unreferenced  Flag238\n    --    OK_To_Reorder_Components        Flag239\n+   --    Has_Postconditions              Flag240\n+\n+   --    Optimize_Alignment_Space        Flag241\n+   --    Optimize_Alignment_Time         Flag242\n+   --    Overlays_Constant               Flag243\n \n-   --    (unused)                        Flag240\n-   --    (unused)                        Flag241\n-   --    (unused)                        Flag242\n-   --    (unused)                        Flag243\n    --    (unused)                        Flag244\n    --    (unused)                        Flag245\n    --    (unused)                        Flag246\n@@ -741,8 +741,8 @@ package body Einfo is\n \n    function Current_Use_Clause (Id : E) return E is\n    begin\n-      pragma Assert (Ekind (Id) = E_Package);\n-      return Node25 (Id);\n+      pragma Assert (Ekind (Id) = E_Package or else Is_Type (Id));\n+      return Node27 (Id);\n    end Current_Use_Clause;\n \n    function Current_Value (Id : E) return N is\n@@ -1043,8 +1043,8 @@ package body Einfo is\n \n    function Can_Use_Internal_Rep (Id : E) return B is\n    begin\n-      pragma Assert (Is_Access_Subprogram_Type (Id));\n-      return Flag229 (Id);\n+      pragma Assert (Is_Access_Subprogram_Type (Base_Type (Id)));\n+      return Flag229 (Base_Type (Id));\n    end Can_Use_Internal_Rep;\n \n    function Finalization_Chain_Entity (Id : E) return E is\n@@ -1319,6 +1319,12 @@ package body Einfo is\n       return Flag188 (Id);\n    end Has_Persistent_BSS;\n \n+   function Has_Postconditions (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Subprogram (Id));\n+      return Flag240 (Id);\n+   end Has_Postconditions;\n+\n    function Has_Pragma_Controlled (Id : E) return B is\n    begin\n       pragma Assert (Is_Access_Type (Id));\n@@ -1687,16 +1693,21 @@ package body Einfo is\n       return Flag74 (Id);\n    end Is_CPP_Class;\n \n+   function Is_Descendent_Of_Address (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Flag223 (Id);\n+   end Is_Descendent_Of_Address;\n+\n    function Is_Discrim_SO_Function (Id : E) return B is\n    begin\n       return Flag176 (Id);\n    end Is_Discrim_SO_Function;\n \n-   function Is_Descendent_Of_Address (Id : E) return B is\n+   function Is_Dispatch_Table_Entity (Id : E) return B is\n    begin\n-      pragma Assert (Is_Type (Id));\n-      return Flag223 (Id);\n-   end Is_Descendent_Of_Address;\n+      return Flag234 (Id);\n+   end Is_Dispatch_Table_Entity;\n \n    function Is_Dispatching_Operation (Id : E) return B is\n    begin\n@@ -2000,11 +2011,6 @@ package body Einfo is\n       return Flag28 (Id);\n    end Is_Statically_Allocated;\n \n-   function Is_Static_Dispatch_Table_Entity (Id : E) return B is\n-   begin\n-      return Flag234 (Id);\n-   end Is_Static_Dispatch_Table_Entity;\n-\n    function Is_Synchronized_Interface (Id : E) return B is\n    begin\n       pragma Assert (Is_Interface (Id));\n@@ -2270,23 +2276,30 @@ package body Einfo is\n       return Uint10 (Id);\n    end Normalized_Position_Max;\n \n-   function Object_Ref (Id : E) return E is\n-   begin\n-      pragma Assert (Ekind (Id) = E_Protected_Body);\n-      return Node17 (Id);\n-   end Object_Ref;\n-\n-   function Obsolescent_Warning (Id : E) return N is\n-   begin\n-      return Node24 (Id);\n-   end Obsolescent_Warning;\n-\n    function OK_To_Reorder_Components (Id : E) return B is\n    begin\n       pragma Assert (Is_Record_Type (Id));\n       return Flag239 (Base_Type (Id));\n    end OK_To_Reorder_Components;\n \n+   function Optimize_Alignment_Space (Id : E) return B is\n+   begin\n+      pragma Assert\n+        (Is_Type (Id)\n+           or else Ekind (Id) = E_Constant\n+           or else Ekind (Id) = E_Variable);\n+      return Flag241 (Id);\n+   end Optimize_Alignment_Space;\n+\n+   function Optimize_Alignment_Time (Id : E) return B is\n+   begin\n+      pragma Assert\n+        (Is_Type (Id)\n+           or else Ekind (Id) = E_Constant\n+           or else Ekind (Id) = E_Variable);\n+      return Flag242 (Id);\n+   end Optimize_Alignment_Time;\n+\n    function Original_Array_Type (Id : E) return E is\n    begin\n       pragma Assert (Is_Array_Type (Id) or else Is_Modular_Integer_Type (Id));\n@@ -2302,6 +2315,11 @@ package body Einfo is\n       return Node22 (Id);\n    end Original_Record_Component;\n \n+   function Overlays_Constant (Id : E) return B is\n+   begin\n+      return Flag243 (Id);\n+   end Overlays_Constant;\n+\n    function Overridden_Operation (Id : E) return E is\n    begin\n       return Node26 (Id);\n@@ -2336,16 +2354,16 @@ package body Einfo is\n \n    function Prival (Id : E) return E is\n    begin\n-      pragma Assert (Is_Protected_Private (Id));\n+      pragma Assert (Is_Protected_Component (Id));\n       return Node17 (Id);\n    end Prival;\n \n-   function Privals_Chain (Id : E) return L is\n+   function Prival_Link (Id : E) return E is\n    begin\n-      pragma Assert (Is_Overloadable (Id)\n-        or else Ekind (Id) = E_Entry_Family);\n-      return Elist23 (Id);\n-   end Privals_Chain;\n+      pragma Assert (Ekind (Id) = E_Constant\n+        or else Ekind (Id) = E_Variable);\n+      return Node20 (Id);\n+   end Prival_Link;\n \n    function Private_Dependents (Id : E) return L is\n    begin\n@@ -2371,11 +2389,14 @@ package body Einfo is\n       return Node22 (Id);\n    end Protected_Formal;\n \n-   function Protected_Operation (Id : E) return N is\n+   function Protection_Object (Id : E) return E is\n    begin\n-      pragma Assert (Is_Protected_Private (Id));\n+      pragma Assert (Ekind (Id) = E_Entry\n+        or else Ekind (Id) = E_Entry_Family\n+        or else Ekind (Id) = E_Function\n+        or else Ekind (Id) = E_Procedure);\n       return Node23 (Id);\n-   end Protected_Operation;\n+   end Protection_Object;\n \n    function Reachable (Id : E) return B is\n    begin\n@@ -2429,6 +2450,12 @@ package body Einfo is\n       return Node26 (Id);\n    end Related_Type;\n \n+   function Relative_Deadline_Variable (Id : E) return E is\n+   begin\n+      pragma Assert (Is_Task_Type (Id));\n+      return Node26 (Implementation_Base_Type (Id));\n+   end Relative_Deadline_Variable;\n+\n    function Renamed_Entity (Id : E) return N is\n    begin\n       return Node18 (Id);\n@@ -2551,6 +2578,12 @@ package body Einfo is\n       return Node19 (Id);\n    end Spec_Entity;\n \n+   function Spec_PPC_List (Id : E) return N is\n+   begin\n+      pragma Assert (Is_Subprogram (Id));\n+      return Node24 (Id);\n+   end Spec_PPC_List;\n+\n    function Storage_Size_Variable (Id : E) return E is\n    begin\n       pragma Assert (Is_Access_Type (Id) or else Is_Task_Type (Id));\n@@ -3109,8 +3142,8 @@ package body Einfo is\n \n    procedure Set_Current_Use_Clause (Id : E; V : E) is\n    begin\n-      pragma Assert (Ekind (Id) = E_Package);\n-      Set_Node25 (Id, V);\n+      pragma Assert (Ekind (Id) = E_Package or else Is_Type (Id));\n+      Set_Node27 (Id, V);\n    end Set_Current_Use_Clause;\n \n    procedure Set_Current_Value (Id : E; V : N) is\n@@ -3415,7 +3448,9 @@ package body Einfo is\n \n    procedure Set_Can_Use_Internal_Rep (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Is_Access_Subprogram_Type (Id));\n+      pragma Assert\n+        (Is_Access_Subprogram_Type (Id)\n+          and then Id = Base_Type (Id));\n       Set_Flag229 (Id, V);\n    end Set_Can_Use_Internal_Rep;\n \n@@ -3510,7 +3545,7 @@ package body Einfo is\n \n    procedure Set_Has_Aliased_Components (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Base_Type (Id) = Id);\n+      pragma Assert (Id = Base_Type (Id));\n       Set_Flag135 (Id, V);\n    end Set_Has_Aliased_Components;\n \n@@ -3531,14 +3566,14 @@ package body Einfo is\n \n    procedure Set_Has_Atomic_Components (Id : E; V : B := True) is\n    begin\n-      pragma Assert (not Is_Type (Id) or else Base_Type (Id) = Id);\n+      pragma Assert (not Is_Type (Id) or else Id = Base_Type (Id));\n       Set_Flag86 (Id, V);\n    end Set_Has_Atomic_Components;\n \n    procedure Set_Has_Biased_Representation (Id : E; V : B := True) is\n    begin\n       pragma Assert\n-        ((V = False) or else (Is_Discrete_Type (Id) or Is_Object (Id)));\n+        ((V = False) or else (Is_Discrete_Type (Id) or else Is_Object (Id)));\n       Set_Flag139 (Id, V);\n    end Set_Has_Biased_Representation;\n \n@@ -3578,7 +3613,7 @@ package body Einfo is\n \n    procedure Set_Has_Controlled_Component (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Base_Type (Id) = Id);\n+      pragma Assert (Id = Base_Type (Id));\n       Set_Flag43 (Id, V);\n    end Set_Has_Controlled_Component;\n \n@@ -3689,7 +3724,7 @@ package body Einfo is\n \n    procedure Set_Has_Non_Standard_Rep (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Base_Type (Id) = Id);\n+      pragma Assert (Id = Base_Type (Id));\n       Set_Flag75 (Id, V);\n    end Set_Has_Non_Standard_Rep;\n \n@@ -3709,6 +3744,12 @@ package body Einfo is\n       Set_Flag188 (Id, V);\n    end Set_Has_Persistent_BSS;\n \n+   procedure Set_Has_Postconditions (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Subprogram (Id));\n+      Set_Flag240 (Id, V);\n+   end Set_Has_Postconditions;\n+\n    procedure Set_Has_Pragma_Controlled (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Access_Type (Id));\n@@ -3850,7 +3891,7 @@ package body Einfo is\n    procedure Set_Has_Storage_Size_Clause (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Access_Type (Id) or else Is_Task_Type (Id));\n-      pragma Assert (Base_Type (Id) = Id);\n+      pragma Assert (Id = Base_Type (Id));\n       Set_Flag23 (Id, V);\n    end Set_Has_Storage_Size_Clause;\n \n@@ -3867,7 +3908,7 @@ package body Einfo is\n \n    procedure Set_Has_Task (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Base_Type (Id) = Id);\n+      pragma Assert (Id = Base_Type (Id));\n       Set_Flag30 (Id, V);\n    end Set_Has_Task;\n \n@@ -3880,7 +3921,7 @@ package body Einfo is\n \n    procedure Set_Has_Unchecked_Union (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Base_Type (Id) = Id);\n+      pragma Assert (Id = Base_Type (Id));\n       Set_Flag123 (Id, V);\n    end Set_Has_Unchecked_Union;\n \n@@ -3892,7 +3933,7 @@ package body Einfo is\n \n    procedure Set_Has_Volatile_Components (Id : E; V : B := True) is\n    begin\n-      pragma Assert (not Is_Type (Id) or else Base_Type (Id) = Id);\n+      pragma Assert (not Is_Type (Id) or else Id = Base_Type (Id));\n       Set_Flag87 (Id, V);\n    end Set_Has_Volatile_Components;\n \n@@ -4095,6 +4136,11 @@ package body Einfo is\n       Set_Flag176 (Id, V);\n    end Set_Is_Discrim_SO_Function;\n \n+   procedure Set_Is_Dispatch_Table_Entity (Id : E; V : B := True) is\n+   begin\n+      Set_Flag234 (Id, V);\n+   end Set_Is_Dispatch_Table_Entity;\n+\n    procedure Set_Is_Dispatching_Operation (Id : E; V : B := True) is\n    begin\n       pragma Assert\n@@ -4309,7 +4355,7 @@ package body Einfo is\n \n    procedure Set_Is_Packed (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Base_Type (Id) = Id);\n+      pragma Assert (Id = Base_Type (Id));\n       Set_Flag51 (Id, V);\n    end Set_Is_Packed;\n \n@@ -4420,11 +4466,6 @@ package body Einfo is\n       Set_Flag28 (Id, V);\n    end Set_Is_Statically_Allocated;\n \n-   procedure Set_Is_Static_Dispatch_Table_Entity (Id : E; V : B := True) is\n-   begin\n-      Set_Flag234 (Id, V);\n-   end Set_Is_Static_Dispatch_Table_Entity;\n-\n    procedure Set_Is_Synchronized_Interface (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Interface (Id));\n@@ -4467,7 +4508,7 @@ package body Einfo is\n \n    procedure Set_Is_Unchecked_Union (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Base_Type (Id) = Id);\n+      pragma Assert (Id = Base_Type (Id));\n       Set_Flag117 (Id, V);\n    end Set_Is_Unchecked_Union;\n \n@@ -4635,7 +4676,7 @@ package body Einfo is\n \n    procedure Set_No_Pool_Assigned (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Is_Access_Type (Id) and then Base_Type (Id) = Id);\n+      pragma Assert (Is_Access_Type (Id) and then Id = Base_Type (Id));\n       Set_Flag131 (Id, V);\n    end Set_No_Pool_Assigned;\n \n@@ -4650,7 +4691,7 @@ package body Einfo is\n \n    procedure Set_No_Strict_Aliasing (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Is_Access_Type (Id) and then Base_Type (Id) = Id);\n+      pragma Assert (Is_Access_Type (Id) and then Id = Base_Type (Id));\n       Set_Flag136 (Id, V);\n    end Set_No_Strict_Aliasing;\n \n@@ -4695,24 +4736,31 @@ package body Einfo is\n       Set_Uint10 (Id, V);\n    end Set_Normalized_Position_Max;\n \n-   procedure Set_Object_Ref (Id : E; V : E) is\n-   begin\n-      pragma Assert (Ekind (Id) = E_Protected_Body);\n-      Set_Node17 (Id, V);\n-   end Set_Object_Ref;\n-\n-   procedure Set_Obsolescent_Warning (Id : E; V : N) is\n-   begin\n-      Set_Node24 (Id, V);\n-   end Set_Obsolescent_Warning;\n-\n    procedure Set_OK_To_Reorder_Components (Id : E; V : B := True) is\n    begin\n       pragma Assert\n         (Is_Record_Type (Id) and then Id = Base_Type (Id));\n       Set_Flag239 (Id, V);\n    end Set_OK_To_Reorder_Components;\n \n+   procedure Set_Optimize_Alignment_Space (Id : E; V : B := True) is\n+   begin\n+      pragma Assert\n+        (Is_Type (Id)\n+           or else Ekind (Id) = E_Constant\n+           or else Ekind (Id) = E_Variable);\n+      Set_Flag241 (Id, V);\n+   end Set_Optimize_Alignment_Space;\n+\n+   procedure Set_Optimize_Alignment_Time (Id : E; V : B := True) is\n+   begin\n+      pragma Assert\n+        (Is_Type (Id)\n+           or else Ekind (Id) = E_Constant\n+           or else Ekind (Id) = E_Variable);\n+      Set_Flag242 (Id, V);\n+   end Set_Optimize_Alignment_Time;\n+\n    procedure Set_Original_Array_Type (Id : E; V : E) is\n    begin\n       pragma Assert (Is_Array_Type (Id) or else Is_Modular_Integer_Type (Id));\n@@ -4728,6 +4776,11 @@ package body Einfo is\n       Set_Node22 (Id, V);\n    end Set_Original_Record_Component;\n \n+   procedure Set_Overlays_Constant (Id : E; V : B := True) is\n+   begin\n+      Set_Flag243 (Id, V);\n+   end Set_Overlays_Constant;\n+\n    procedure Set_Overridden_Operation (Id : E; V : E) is\n    begin\n       Set_Node26 (Id, V);\n@@ -4762,16 +4815,16 @@ package body Einfo is\n \n    procedure Set_Prival (Id : E; V : E) is\n    begin\n-      pragma Assert (Is_Protected_Private (Id));\n+      pragma Assert (Is_Protected_Component (Id));\n       Set_Node17 (Id, V);\n    end Set_Prival;\n \n-   procedure Set_Privals_Chain (Id : E; V : L) is\n+   procedure Set_Prival_Link (Id : E; V : E) is\n    begin\n-      pragma Assert (Is_Overloadable (Id)\n-        or else Ekind (Id) = E_Entry_Family);\n-      Set_Elist23 (Id, V);\n-   end Set_Privals_Chain;\n+      pragma Assert (Ekind (Id) = E_Constant\n+        or else Ekind (Id) = E_Variable);\n+      Set_Node20 (Id, V);\n+   end Set_Prival_Link;\n \n    procedure Set_Private_Dependents (Id : E; V : L) is\n    begin\n@@ -4797,11 +4850,14 @@ package body Einfo is\n       Set_Node22 (Id, V);\n    end Set_Protected_Formal;\n \n-   procedure Set_Protected_Operation (Id : E; V : N) is\n+   procedure Set_Protection_Object (Id : E; V : E) is\n    begin\n-      pragma Assert (Is_Protected_Private (Id));\n+      pragma Assert (Ekind (Id) = E_Entry\n+        or else Ekind (Id) = E_Entry_Family\n+        or else Ekind (Id) = E_Function\n+        or else Ekind (Id) = E_Procedure);\n       Set_Node23 (Id, V);\n-   end Set_Protected_Operation;\n+   end Set_Protection_Object;\n \n    procedure Set_Reachable (Id : E; V : B := True) is\n    begin\n@@ -4855,6 +4911,12 @@ package body Einfo is\n       Set_Node26 (Id, V);\n    end Set_Related_Type;\n \n+   procedure Set_Relative_Deadline_Variable (Id : E; V : E) is\n+   begin\n+      pragma Assert (Is_Task_Type (Id) and then Id = Base_Type (Id));\n+      Set_Node26 (Id, V);\n+   end Set_Relative_Deadline_Variable;\n+\n    procedure Set_Renamed_Entity (Id : E; V : N) is\n    begin\n       Set_Node18 (Id, V);\n@@ -4978,10 +5040,16 @@ package body Einfo is\n       Set_Node19 (Id, V);\n    end Set_Spec_Entity;\n \n+   procedure Set_Spec_PPC_List (Id : E; V : N) is\n+   begin\n+      pragma Assert (Is_Subprogram (Id));\n+      Set_Node24 (Id, V);\n+   end Set_Spec_PPC_List;\n+\n    procedure Set_Storage_Size_Variable (Id : E; V : E) is\n    begin\n       pragma Assert (Is_Access_Type (Id) or else Is_Task_Type (Id));\n-      pragma Assert (Base_Type (Id) = Id);\n+      pragma Assert (Id = Base_Type (Id));\n       Set_Node15 (Id, V);\n    end Set_Storage_Size_Variable;\n \n@@ -5006,7 +5074,7 @@ package body Einfo is\n \n    procedure Set_Strict_Alignment (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Base_Type (Id) = Id);\n+      pragma Assert (Id = Base_Type (Id));\n       Set_Flag145 (Id, V);\n    end Set_Strict_Alignment;\n \n@@ -5062,7 +5130,7 @@ package body Einfo is\n \n    procedure Set_Universal_Aliasing (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Is_Type (Id) and then Base_Type (Id) = Id);\n+      pragma Assert (Is_Type (Id) and then Id = Base_Type (Id));\n       Set_Flag216 (Id, V);\n    end Set_Universal_Aliasing;\n \n@@ -5445,14 +5513,14 @@ package body Einfo is\n    procedure Append_Entity (Id : Entity_Id; V : Entity_Id) is\n    begin\n       if Last_Entity (V) = Empty then\n-         Set_First_Entity (V, Id);\n+         Set_First_Entity (Id => V, V => Id);\n       else\n          Set_Next_Entity (Last_Entity (V), Id);\n       end if;\n \n       Set_Next_Entity (Id, Empty);\n       Set_Scope (Id, V);\n-      Set_Last_Entity (V, Id);\n+      Set_Last_Entity (Id => V, V => Id);\n    end Append_Entity;\n \n    --------------------\n@@ -5703,8 +5771,6 @@ package body Einfo is\n             S := Scope (S);\n          end if;\n       end loop;\n-\n-      return S;\n    end Enclosing_Dynamic_Scope;\n \n    ----------------------\n@@ -6347,6 +6413,17 @@ package body Einfo is\n       end if;\n    end Is_By_Reference_Type;\n \n+   ------------------------\n+   -- Is_Constant_Object --\n+   ------------------------\n+\n+   function Is_Constant_Object (Id : E) return B is\n+      K : constant Entity_Kind := Ekind (Id);\n+   begin\n+      return\n+        K = E_Constant or else K = E_In_Parameter or else K = E_Loop_Parameter;\n+   end Is_Constant_Object;\n+\n    ---------------------\n    -- Is_Derived_Type --\n    ---------------------\n@@ -6367,15 +6444,27 @@ package body Einfo is\n \n             return Present (Par)\n               and then Nkind (Par) = N_Full_Type_Declaration\n-              and then Nkind (Type_Definition (Par))\n-                = N_Derived_Type_Definition;\n+              and then Nkind (Type_Definition (Par)) =\n+                         N_Derived_Type_Definition;\n          end if;\n \n       else\n          return False;\n       end if;\n    end Is_Derived_Type;\n \n+   --------------------\n+   -- Is_Discriminal --\n+   --------------------\n+\n+   function Is_Discriminal (Id : E) return B is\n+   begin\n+      return\n+        (Ekind (Id) = E_Constant\n+           or else Ekind (Id) = E_In_Parameter)\n+         and then Present (Discriminal_Link (Id));\n+   end Is_Discriminal;\n+\n    ----------------------\n    -- Is_Dynamic_Scope --\n    ----------------------\n@@ -6454,6 +6543,64 @@ package body Einfo is\n       end if;\n    end Is_Indefinite_Subtype;\n \n+   --------------------------------\n+   -- Is_Inherently_Limited_Type --\n+   --------------------------------\n+\n+   function Is_Inherently_Limited_Type (Id : E) return B is\n+      Btype : constant Entity_Id := Base_Type (Id);\n+\n+   begin\n+      if Is_Private_Type (Btype) then\n+         declare\n+            Utyp : constant Entity_Id := Underlying_Type (Btype);\n+         begin\n+            if No (Utyp) then\n+               return False;\n+            else\n+               return Is_Inherently_Limited_Type (Utyp);\n+            end if;\n+         end;\n+\n+      elsif Is_Concurrent_Type (Btype) then\n+         return True;\n+\n+      elsif Is_Record_Type (Btype) then\n+         if Is_Limited_Record (Btype) then\n+            return not Is_Interface (Btype)\n+              or else Is_Protected_Interface (Btype)\n+              or else Is_Synchronized_Interface (Btype)\n+              or else Is_Task_Interface (Btype);\n+\n+         elsif Is_Class_Wide_Type (Btype) then\n+            return Is_Inherently_Limited_Type (Root_Type (Btype));\n+\n+         else\n+            declare\n+               C : Entity_Id;\n+\n+            begin\n+               C := First_Component (Btype);\n+               while Present (C) loop\n+                  if Is_Inherently_Limited_Type (Etype (C)) then\n+                     return True;\n+                  end if;\n+\n+                  C := Next_Component (C);\n+               end loop;\n+            end;\n+\n+            return False;\n+         end if;\n+\n+      elsif Is_Array_Type (Btype) then\n+         return Is_Inherently_Limited_Type (Component_Type (Btype));\n+\n+      else\n+         return False;\n+      end if;\n+   end Is_Inherently_Limited_Type;\n+\n    ---------------------\n    -- Is_Limited_Type --\n    ---------------------\n@@ -6546,15 +6693,27 @@ package body Einfo is\n         Ekind (Id) = E_Generic_Package;\n    end Is_Package_Or_Generic_Package;\n \n-   --------------------------\n-   -- Is_Protected_Private --\n-   --------------------------\n+   ---------------\n+   -- Is_Prival --\n+   ---------------\n \n-   function Is_Protected_Private (Id : E) return B is\n+   function Is_Prival (Id : E) return B is\n    begin\n-      pragma Assert (Ekind (Id) = E_Component);\n-      return Is_Protected_Type (Scope (Id));\n-   end Is_Protected_Private;\n+      return\n+        (Ekind (Id) = E_Constant\n+           or else Ekind (Id) = E_Variable)\n+         and then Present (Prival_Link (Id));\n+   end Is_Prival;\n+\n+   ----------------------------\n+   -- Is_Protected_Component --\n+   ----------------------------\n+\n+   function Is_Protected_Component (Id : E) return B is\n+   begin\n+      return Ekind (Id) = E_Component\n+        and then Is_Protected_Type (Scope (Id));\n+   end Is_Protected_Component;\n \n    ------------------------------\n    -- Is_Protected_Record_Type --\n@@ -6568,62 +6727,27 @@ package body Einfo is\n    end Is_Protected_Record_Type;\n \n    --------------------------------\n-   -- Is_Inherently_Limited_Type --\n+   -- Is_Standard_Character_Type --\n    --------------------------------\n \n-   function Is_Inherently_Limited_Type (Id : E) return B is\n-      Btype : constant Entity_Id := Base_Type (Id);\n-\n+   function Is_Standard_Character_Type (Id : E) return B is\n    begin\n-      if Is_Private_Type (Btype) then\n+      if Is_Type (Id) then\n          declare\n-            Utyp : constant Entity_Id := Underlying_Type (Btype);\n+            R : constant Entity_Id := Root_Type (Id);\n          begin\n-            if No (Utyp) then\n-               return False;\n-            else\n-               return Is_Inherently_Limited_Type (Utyp);\n-            end if;\n+            return\n+              R = Standard_Character\n+                or else\n+              R = Standard_Wide_Character\n+                or else\n+              R = Standard_Wide_Wide_Character;\n          end;\n \n-      elsif Is_Concurrent_Type (Btype) then\n-         return True;\n-\n-      elsif Is_Record_Type (Btype) then\n-         if Is_Limited_Record (Btype) then\n-            return not Is_Interface (Btype)\n-              or else Is_Protected_Interface (Btype)\n-              or else Is_Synchronized_Interface (Btype)\n-              or else Is_Task_Interface (Btype);\n-\n-         elsif Is_Class_Wide_Type (Btype) then\n-            return Is_Inherently_Limited_Type (Root_Type (Btype));\n-\n-         else\n-            declare\n-               C : Entity_Id;\n-\n-            begin\n-               C := First_Component (Btype);\n-               while Present (C) loop\n-                  if Is_Inherently_Limited_Type (Etype (C)) then\n-                     return True;\n-                  end if;\n-\n-                  C := Next_Component (C);\n-               end loop;\n-            end;\n-\n-            return False;\n-         end if;\n-\n-      elsif Is_Array_Type (Btype) then\n-         return Is_Inherently_Limited_Type (Component_Type (Btype));\n-\n       else\n          return False;\n       end if;\n-   end Is_Inherently_Limited_Type;\n+   end Is_Standard_Character_Type;\n \n    --------------------\n    -- Is_String_Type --\n@@ -6957,17 +7081,15 @@ package body Einfo is\n \n             T := Etyp;\n \n-            --  Return if there is a circularity in the inheritance chain.\n-            --  This happens in some error situations and we do not want\n-            --  to get stuck in this loop.\n+            --  Return if there is a circularity in the inheritance chain. This\n+            --  happens in some error situations and we do not want to get\n+            --  stuck in this loop.\n \n             if T = Base_Type (Id) then\n                return T;\n             end if;\n          end loop;\n       end if;\n-\n-      raise Program_Error;\n    end Root_Type;\n \n    -----------------\n@@ -7313,7 +7435,7 @@ package body Einfo is\n \n    begin\n       if (Is_Array_Type (Id) or else Is_Record_Type (Id))\n-        and then Base_Type (Id) = Id\n+        and then Id = Base_Type (Id)\n       then\n          Write_Str (Prefix);\n          Write_Str (\"Component_Alignment = \");\n@@ -7385,6 +7507,7 @@ package body Einfo is\n       W (\"Has_Object_Size_Clause\",          Flag172 (Id));\n       W (\"Has_Per_Object_Constraint\",       Flag154 (Id));\n       W (\"Has_Persistent_BSS\",              Flag188 (Id));\n+      W (\"Has_Postconditions\",              Flag240 (Id));\n       W (\"Has_Pragma_Controlled\",           Flag27  (Id));\n       W (\"Has_Pragma_Elaborate_Body\",       Flag150 (Id));\n       W (\"Has_Pragma_Inline\",               Flag157 (Id));\n@@ -7450,6 +7573,7 @@ package body Einfo is\n       W (\"Is_Controlling_Formal\",           Flag97  (Id));\n       W (\"Is_Descendent_Of_Address\",        Flag223 (Id));\n       W (\"Is_Discrim_SO_Function\",          Flag176 (Id));\n+      W (\"Is_Dispatch_Table_Entity\",        Flag234 (Id));\n       W (\"Is_Dispatching_Operation\",        Flag6   (Id));\n       W (\"Is_Eliminated\",                   Flag124 (Id));\n       W (\"Is_Entry_Formal\",                 Flag52  (Id));\n@@ -7504,7 +7628,6 @@ package body Einfo is\n       W (\"Is_Return_Object\",                Flag209 (Id));\n       W (\"Is_Shared_Passive\",               Flag60  (Id));\n       W (\"Is_Synchronized_Interface\",       Flag199 (Id));\n-      W (\"Is_Static_Dispatch_Table_Entity\", Flag234 (Id));\n       W (\"Is_Statically_Allocated\",         Flag28  (Id));\n       W (\"Is_Tag\",                          Flag78  (Id));\n       W (\"Is_Tagged_Type\",                  Flag55  (Id));\n@@ -7538,6 +7661,9 @@ package body Einfo is\n       W (\"Non_Binary_Modulus\",              Flag58  (Id));\n       W (\"Nonzero_Is_True\",                 Flag162 (Id));\n       W (\"OK_To_Reorder_Components\",        Flag239 (Id));\n+      W (\"Optimize_Alignment_Space\",        Flag241 (Id));\n+      W (\"Optimize_Alignment_Time\",         Flag242 (Id));\n+      W (\"Overlays_Constant\",               Flag243 (Id));\n       W (\"Reachable\",                       Flag49  (Id));\n       W (\"Referenced\",                      Flag156 (Id));\n       W (\"Referenced_As_LHS\",               Flag36  (Id));\n@@ -8096,9 +8222,6 @@ package body Einfo is\n          when Array_Kind                                   =>\n             Write_Str (\"First_Index\");\n \n-         when E_Protected_Body                             =>\n-            Write_Str (\"Object_Ref\");\n-\n          when Enumeration_Kind                             =>\n             Write_Str (\"First_Literal\");\n \n@@ -8246,6 +8369,10 @@ package body Einfo is\n          when E_Component                                  =>\n             Write_Str (\"Discriminant_Checking_Func\");\n \n+         when E_Constant                                   |\n+              E_Variable                                   =>\n+            Write_Str (\"Prival_Link\");\n+\n          when E_Discriminant                               =>\n             Write_Str (\"Discriminant_Default_Value\");\n \n@@ -8402,9 +8529,6 @@ package body Einfo is\n          when E_Block                                      =>\n             Write_Str (\"Entry_Cancel_Parameter\");\n \n-         when E_Component                                  =>\n-            Write_Str (\"Protected_Operation\");\n-\n          when E_Discriminant                               =>\n             Write_Str (\"CR_Discriminant\");\n \n@@ -8429,7 +8553,13 @@ package body Einfo is\n \n          when E_Function                                   |\n               E_Procedure                                  =>\n-            Write_Str (\"Generic_Renamings\");\n+            if Present (Scope (Id))\n+              and then Is_Protected_Type (Scope (Id))\n+            then\n+               Write_Str (\"Protection_Object\");\n+            else\n+               Write_Str (\"Generic_Renamings\");\n+            end if;\n \n          when E_Package                                    =>\n             if Is_Generic_Instance (Id) then\n@@ -8438,10 +8568,8 @@ package body Einfo is\n                Write_Str (\"Limited_View\");\n             end if;\n \n-         --  What about Privals_Chain for protected operations ???\n-\n          when Entry_Kind                                   =>\n-            Write_Str (\"Privals_Chain\");\n+            Write_Str (\"Protection_Object\");\n \n          when others                                       =>\n             Write_Str (\"Field23??\");\n@@ -8453,9 +8581,14 @@ package body Einfo is\n    ------------------------\n \n    procedure Write_Field24_Name (Id : Entity_Id) is\n-      pragma Warnings (Off, Id);\n    begin\n-      Write_Str (\"Obsolescent_Warning\");\n+      case Ekind (Id) is\n+         when Subprogram_Kind                              =>\n+            Write_Str (\"Spec_PPC_List\");\n+\n+         when others                                       =>\n+            Write_Str (\"???\");\n+      end case;\n    end Write_Field24_Name;\n \n    ------------------------\n@@ -8472,9 +8605,6 @@ package body Einfo is\n               E_Function                                   =>\n             Write_Str (\"Abstract_Interface_Alias\");\n \n-         when E_Package                                    =>\n-            Write_Str (\"Current_Use_Clause\");\n-\n          when E_Record_Type                                |\n               E_Record_Subtype                             |\n               E_Record_Type_With_Private                   |\n@@ -8525,6 +8655,9 @@ package body Einfo is\n               E_Variable                                   =>\n             Write_Str (\"Last_Assignment\");\n \n+         when Task_Kind                                    =>\n+            Write_Str (\"Relative_Deadline_Variable\");\n+\n          when others                                       =>\n             Write_Str (\"Field26??\");\n       end case;\n@@ -8540,6 +8673,9 @@ package body Einfo is\n          when E_Procedure                                  =>\n             Write_Str (\"Wrapped_Entity\");\n \n+         when E_Package | Type_Kind                        =>\n+            Write_Str (\"Current_Use_Clause\");\n+\n          when others                                       =>\n             Write_Str (\"Field27??\");\n       end case;"}, {"sha": "10d7deb7aa18dd671b199e5f10ea90a4407e6c86", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 246, "deletions": 183, "changes": 429, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -284,13 +284,13 @@ package Einfo is\n --  attribute on other than the base type, and if assertions are enabled,\n --  an attempt to set the attribute on a subtype will raise an assert error.\n \n---  Other attributes are noted as applying the implementation base type only.\n---  These are representation attributes which must always apply to a full\n---  non-private type, and where the attributes are always on the full type.\n---  The attribute can be referenced on a subtype (and automatically retries\n---  the value from the implementation base type). However, it is an error\n---  to try to set the attribute on other than the implementation base type,\n---  and if assertions are enabled, an attempt to set the attribute on a\n+--  Other attributes are noted as applying to the [implementation base type\n+--  only].  These are representation attributes which must always apply to a\n+--  full non-private type, and where the attributes are always on the full\n+--  type.  The attribute can be referenced on a subtype (and automatically\n+--  retries the value from the implementation base type). However, it is an\n+--  error to try to set the attribute on other than the implementation base\n+--  type, and if assertions are enabled, an attempt to set the attribute on a\n --  subtype will raise an assert error.\n \n --    Abstract_Interfaces (Elist25)\n@@ -638,10 +638,12 @@ package Einfo is\n --       created at the same time as the discriminal, and used to replace\n --       occurrences of the discriminant within the type declaration.\n \n---    Current_Use_Clause (Node25)\n---       Present in packages. Indicates the use clause currently in scope\n---       that makes the package use_visible. Used to detect redundant use\n---       clauses for the same package.\n+--    Current_Use_Clause (Node27)\n+--       Present in packages and in types. For packages, denotes the use\n+--       package clause currently in scope that makes the package use_visible.\n+--       For types, it denotes the use_type clause that makes the operators of\n+--       the type visible. Used for more precise warning messages on redundant\n+--       use clauses.\n \n --    Current_Value (Node9)\n --       Present in all object entities. Set in E_Variable, E_Constant, formal\n@@ -992,12 +994,12 @@ package Einfo is\n \n --    Equivalent_Type (Node18)\n --       Present in class wide types and subtypes, access to protected\n---       subprogram types, and in exception_types. For a classwide type, it\n+--       subprogram types, and in exception types. For a classwide type, it\n --       is always Empty. For a class wide subtype, it points to an entity\n --       created by the expander which gives Gigi an easily understandable\n --       equivalent of the class subtype with a known size (given by an\n --       initial value). See Exp_Util.Expand_Class_Wide_Subtype for further\n---       details. For E_exception_type, this points to the record containing\n+--       details. For E_Exception_Type, this points to the record containing\n --       the data necessary to represent exceptions (for further details, see\n --       System.Standard_Library. For access_to_protected subprograms, it\n --       denotes a record that holds pointers to the operation and to the\n@@ -1078,7 +1080,7 @@ package Einfo is\n --       must be retrieved through the entity designed by this field instead of\n --       being computed.\n \n---    Can_Use_Internal_Rep (Flag229)\n+--    Can_Use_Internal_Rep (Flag229) [base type only]\n --       Present in Access_Subprogram_Kind nodes. This flag is set by the\n --       front end and used by the back end. False means that the back end\n --       must represent the type in the same way as Convention-C types (and\n@@ -1536,11 +1538,11 @@ package Einfo is\n --       error exeption is correctly raised in this case at runtime.\n \n --    Has_Up_Level_Access (Flag215)\n---      Present in E_Variable and E_Constant entities. Set if the entity is\n---      declared in a local procedure p and is accessed in a procedure nested\n---      inside p. Only set when VM_Target /= No_VM currently.\n---      Why only set it under those conditions, sounds reasonable to always\n---      set this flag when appropriate ???\n+--      Present in E_Variable and E_Constant entities. Set if the entity\n+--      is a local variable declared in a subprogram p and is accessed in\n+--      a subprogram nested inside p. Currently this flag is only set when\n+--      VM_Target /= No_VM, for efficiency, since only the .NET back-end\n+--      makes use of it to generate proper code for up-level references.\n \n --    Has_Nested_Block_With_Handler (Flag101)\n --       Present in scope entities. Set if there is a nested block within the\n@@ -1587,6 +1589,10 @@ package Einfo is\n --       to which the pragma applies, as well as the unit entity itself, for\n --       convenience in propagating the flag to contained entities.\n \n+--    Has_Postconditions (Flag240)\n+--      Present in subprogram entities. Set if postconditions are active for\n+--      the procedure, and a _postconditions procedure has been generated.\n+\n --    Has_Pragma_Controlled (Flag27) [implementation base type only]\n --       Present in access type entities. It is set if a pragma Controlled\n --       applies to the access type.\n@@ -2002,6 +2008,10 @@ package Einfo is\n --       Applies to all entities, true for task types and subtypes and for\n --       protected types and subtypes.\n \n+--    Is_Constant_Object (synthesized)\n+--       Applies to all entities, true for E_Constant, E_Loop_Parameter, and\n+--       E_In_Parameter entities.\n+\n --    Is_Constrained (Flag12)\n --       Present in types or subtypes which may have index, discriminant\n --       or range constraint (i.e. array types and subtypes, record types\n@@ -2061,6 +2071,14 @@ package Einfo is\n --       Present in all entities. Set only in E_Function entities that Layout\n --       creates to compute discriminant-dependent dynamic size/offset values.\n \n+--    Is_Discriminal (synthesized)\n+--       Applies to all entities, true for renamings of discriminants. Such\n+--       entities appear as constants or in parameters.\n+\n+--    Is_Dispatch_Table_Entity (Flag234)\n+--       Applies to all entities. Set to indicate to the backend that this\n+--       entity is associated with a dispatch table.\n+\n --    Is_Dispatching_Operation (Flag6)\n --       Present in all entities. Set true for procedures, functions,\n --       generic procedures and generic functions if the corresponding\n@@ -2506,6 +2524,10 @@ package Einfo is\n --       primitive wrappers. which are generated by the expander to wrap\n --       entries of protected or task types implementing a limited interface.\n \n+--    Is_Prival (synthesized)\n+--       Applies to all entities, true for renamings of private protected\n+--       components. Such entities appear as constants or variables.\n+\n --    Is_Private_Composite (Flag107)\n --       Present in composite types that have a private component. Used to\n --       enforce the rule that operations on the composite type that depend\n@@ -2522,6 +2544,10 @@ package Einfo is\n --       Applies to all entities, true for private types and subtypes,\n --       as well as for record with private types as subtypes\n \n+--    Is_Protected_Component (synthesized)\n+--       Applicable to all entities, true if the entity denotes a private\n+--       component of a protected type.\n+\n --    Is_Protected_Interface (Flag198)\n --       Present in types that are interfaces. True if interface is declared\n --       protected, or is derived from protected interfaces.\n@@ -2536,10 +2562,6 @@ package Einfo is\n --       example in the case of a variable name, then Gigi will generate an\n --       appropriate external name for use by the linker.\n \n---    Is_Protected_Private (synthesized)\n---       Applies to a record component. Returns true if this component\n---       is used to represent a private declaration of a protected type.\n-\n --    Is_Protected_Record_Type (synthesized)\n --       Applies to all entities, true if Is_Concurrent_Record_Type\n --       Corresponding_Concurrent_Type is a protected type.\n@@ -2560,8 +2582,8 @@ package Einfo is\n --       freeze time if the access type has a storage pool.\n \n --    Is_Raised (Flag224)\n---       Present in entities which denote exceptions. Set if the exception is\n---       thrown by a raise statement.\n+--       Present in exception entities. Set if the entity is referenced by a\n+--       a raise statement.\n \n --    Is_Real_Type (synthesized)\n --       Applies to all entities, true for real types and subtypes\n@@ -2607,6 +2629,11 @@ package Einfo is\n --       entities to which a pragma Shared_Passive is applied, and also in\n --       all entities within such packages.\n \n+--    Is_Standard_Character_Type (synthesized)\n+--       Applies to all entities, true for types and subtypes whose root type\n+--       is one of the standard character types (Character, Wide_Character,\n+--       Wide_Wide_Character).\n+\n --    Is_Statically_Allocated (Flag28)\n --       Present in all entities. This can only be set True for exception,\n --       variable, constant, and type/subtype entities. If the flag is set,\n@@ -2623,37 +2650,33 @@ package Einfo is\n --       flag set (since to allocate the object statically, its type must\n --       also be elaborated globally).\n \n---    Is_Static_Dispatch_Table_Entity (Flag234)\n---       Applies to all entities. Set to indicate to the backend that this\n---       entity is associated with an statically allocated dispatch table.\n-\n---    Is_Subprogram (synthesized)\n---       Applies to all entities, true for function, procedure and operator\n---       entities.\n-\n --    Is_String_Type (synthesized)\n --       Applies to all type entities. Determines if the given type is a\n --       string type, i.e. it is directly a string type or string subtype,\n --       or a string slice type, or an array type with one dimension and a\n --       component type that is a character type.\n \n+--    Is_Subprogram (synthesized)\n+--       Applies to all entities, true for function, procedure and operator\n+--       entities.\n+\n --    Is_Synchronized_Interface (Flag199)\n --       Present in types that are interfaces. True if interface is declared\n --       synchronized, task, or protected, or is derived from a synchronized\n --       interface.\n \n --    Is_Tag (Flag78)\n --       Present in E_Component and E_Constant entities. For regular tagged\n---       type this flag is set on the tag component (whose name is Name_uTag)\n---       and for CPP_Class tagged types, this flag marks the pointer to the\n---       main vtable (i.e. the one to be extended by derivation).\n+--       type this flag is set on the tag component (whose name is Name_uTag).\n+--       For CPP_Class tagged types, this flag marks the pointer to the main\n+--       vtable (i.e. the one to be extended by derivation).\n \n --    Is_Tagged_Type (Flag55)\n --       Present in all entities. Set for an entity for a tagged type.\n \n --    Is_Task_Interface (Flag200)\n---       Present in types that are interfaces. True is interface is declared\n---       as such, or if it is derived from task interfaces.\n+--       Present in types that are interfaces. True if interface is declared as\n+--       a task interface, or if it is derived from task interfaces.\n \n --    Is_Task_Record_Type (synthesized)\n --       Applies to all entities. True if Is_Concurrent_Record_Type\n@@ -3094,11 +3117,21 @@ package Einfo is\n --       Applies to subprograms and subprogram types. Yields the number of\n --       formals as a value of type Pos.\n \n---    Obsolescent_Warning (Node24)\n---       Present in all entities. Set non-empty only if a pragma Obsolescent\n---       applying to the entity had a string argument, in which case it records\n---       the contents of the corresponding string literal node. This field is\n---       only accessed if the flag Is_Obsolescent is set.\n+--    Optimize_Alignment_Space (Flag241)\n+--       A flag present in type, subtype, variable, and constant entities. This\n+--       flag records that the type or object is to be layed out in a manner\n+--       consistent with Optimize_Alignment (Space) mode. The compiler and\n+--       binder ensure a consistent view of any given type or object. If pragma\n+--       Optimize_Alignment (Off) mode applies to the type/object, then neither\n+--       of the flags Optimize_Alignment_Space/Optimize_Alignment_Time is set.\n+\n+--    Optimize_Alignment_Time (Flag242)\n+--       A flag present in type, subtype, variable, and constant entities. This\n+--       flag records that the type or object is to be layed out in a manner\n+--       consistent with Optimize_Alignment (Time) mode. The compiler and\n+--       binder ensure a consistent view of any given type or object. If pragma\n+--       Optimize_Alignment (Off) mode applies to the type/object, then neither\n+--       of the flags Optimize_Alignment_Space/Optimize_Alignment_Time is set.\n \n --    Original_Array_Type (Node21)\n --       Present in modular types and array types and subtypes. Set only\n@@ -3107,11 +3140,6 @@ package Einfo is\n --       points to the original array type for which this is the packed\n --       array implementation type.\n \n---    Object_Ref (Node17)\n---       Present in protected bodies. This is an implicit prival for the\n---       Protection object associated with a protected object. See Prival\n---       for further details on the use of privals.\n-\n --    OK_To_Reorder_Components (Flag239) [base type only]\n --       Present in record types. Set if the back end is permitted to reorder\n --       the components. If not set, the record must be layed out in the order\n@@ -3138,6 +3166,10 @@ package Einfo is\n --       In subtypes (tagged and untagged):\n --         Points to the component in the base type.\n \n+--    Overlays_Constant (Flag243)\n+--       Present in all entities. Set only for a variable for which there is\n+--       an address clause which causes the variable to overlay a constant.\n+\n --    Overridden_Operation (Node26)\n --       Present in subprograms. For overriding operations, points to the\n --       user-defined parent subprogram that is being overridden.\n@@ -3182,6 +3214,15 @@ package Einfo is\n --       is an error to reference the primitive operations field of a type\n --       that is not tagged).\n \n+--    Prival (Node17)\n+--       Present in private components of protected types. Refers to the entity\n+--       of the component renaming declaration generated inside protected\n+--       subprograms, entries or barrier functions.\n+\n+--    Prival_Link (Node20)\n+--       Present in constants and variables which rename private components of\n+--       protected types. Set to the original private component.\n+\n --    Private_Dependents (Elist18)\n --       Present in private (sub)types. Records the subtypes of the\n --       private type, derivations from it, and records and arrays\n@@ -3202,20 +3243,6 @@ package Einfo is\n --       declaration of the type is seen. Subprograms that have such an\n --       access parameter are also placed in the list of private_dependents.\n \n---    Prival (Node17)\n---       Present in components. Used for representing private declarations\n---       of protected objects (private formal: by analogy to Discriminal_Link).\n---       Empty unless the synthesized Is_Protected_Private attribute is\n---       true. The entity used as a formal parameter that corresponds to\n---       the to the private declaration in protected operations. See\n---       \"Private data in protected objects\" for details.\n-\n---    Privals_Chain (Elist23)\n---       Present in protected operations (subprograms and entries). Links\n---       all occurrences of the Privals in the body of the operation, in\n---       order to patch their types at the end of their expansion. See\n---       \"Private data in protected objects\" for details.\n-\n --    Private_View (Node22)\n --       For each private type, three entities are allocated, the private view,\n --       the full view, and the shadow entity. The shadow entity contains a\n@@ -3237,16 +3264,10 @@ package Einfo is\n --       Present in protected operations. References the entity for the\n --       subprogram which implements the body of the operation.\n \n---    Protected_Operation (Node23)\n---       Present in components. Used for representing private declarations\n---       of protected objects. Empty unless the synthesized attribute\n---       Is_Protected_Private is True. This is the entity corresponding\n---       to the body of the protected operation currently being analyzed,\n---       and which will eventually use the current Prival associated with\n---       this component to refer to the renaming of a private object\n---       component. As soon as the expander generates this renaming, this\n---       attribute is changed to refer to the next protected subprogram.\n---       See \"Private data in protected objects\" for details.\n+--    Protection_Object (Node23)\n+--       Applies to protected entries, entry families and subprograms. Denotes\n+--       the entity which is used to rename the _object component of protected\n+--       types.\n \n --    Reachable (Flag49)\n --       Present in labels. The flag is set over the range of statements in\n@@ -3304,6 +3325,12 @@ package Einfo is\n --       Set to point to the entity of the associated tagged type or interface\n --       type.\n \n+--    Relative_Deadline_Variable (Node26) [implementation base type only]\n+--       Present in task type entities. This flag is set if a valid and\n+--       effective pragma Relative_Deadline applies to the base type. Points\n+--       to the entity for a variable that is created to hold the value given\n+--       in a Relative_Deadline pragma for a task type.\n+\n --    Renamed_Entity (Node18)\n --       Present in exceptions, packages, subprograms and generic units. Set\n --       for entities that are defined by a renaming declaration. Denotes the\n@@ -3487,7 +3514,7 @@ package Einfo is\n --       size of objects of the type is known at compile time. This flag is\n --       used to optimize some generated code sequences, and also to enable\n --       some error checks (e.g. disallowing component clauses on variable\n---       length objects. It is set conservatively (i.e. if it is True, the\n+--       length objects). It is set conservatively (i.e. if it is True, the\n --       size is certainly known at compile time, if it is False, then the\n --       size may or may not be known at compile time, but the code will\n --       assume that it is not known).\n@@ -3503,6 +3530,12 @@ package Einfo is\n --       case where there is a separate spec, where this field references\n --       the corresponding parameter entities in the spec.\n \n+--    Spec_PPC_List (Node24)\n+--       Present in subprogram entities. Points to a list of Precondition\n+--       and Postcondition N_Pragma nodes for preconditions and postconditions\n+--       declared in the spec. The last pragma encountered is at the head of\n+--       this list, so it is in reverse order of textual appearence.\n+\n --    Storage_Size_Variable (Node15) [implementation base type only]\n --       Present in access types and task type entities. This flag is set\n --       if a valid and effective pragma Storage_Size applies to the base\n@@ -3595,6 +3628,10 @@ package Einfo is\n --       checks associated with declared volatile variables, but if the test\n --       is for the purposes of suppressing optimizations, then the front\n --       end should test Treat_As_Volatile rather than Is_Volatile.\n+--\n+--       Note: before testing Treat_As_Volatile, consider whether it would\n+--       be more appropriate to use Exp_Util.Is_Volatile_Reference instead,\n+--       which catches more cases of volatile references.\n \n --    Type_High_Bound (synthesized)\n --       Applies to scalar types. Returns the tree node (Node_Id) that contains\n@@ -4509,7 +4546,6 @@ package Einfo is\n    --    Etype                               (Node5)\n    --    First_Rep_Item                      (Node6)\n    --    Freeze_Node                         (Node7)\n-   --    Obsolescent_Warning                 (Node24)\n \n    --    Address_Taken                       (Flag104)\n    --    Can_Never_Be_Null                   (Flag38)\n@@ -4544,6 +4580,7 @@ package Einfo is\n    --    Is_Compilation_Unit                 (Flag149)\n    --    Is_Completely_Hidden                (Flag103)\n    --    Is_Discrim_SO_Function              (Flag176)\n+   --    Is_Dispatch_Table_Entity            (Flag234)\n    --    Is_Dispatching_Operation            (Flag6)\n    --    Is_Entry_Formal                     (Flag52)\n    --    Is_Exported                         (Flag99)\n@@ -4574,7 +4611,6 @@ package Einfo is\n    --    Is_Remote_Types                     (Flag61)\n    --    Is_Renaming_Of_Object               (Flag112)\n    --    Is_Shared_Passive                   (Flag60)\n-   --    Is_Static_Dispatch_Table_Entity     (Flag234)\n    --    Is_Statically_Allocated             (Flag28)\n    --    Is_Tagged_Type                      (Flag55)\n    --    Is_Trivial_Subprogram               (Flag235)\n@@ -4589,6 +4625,7 @@ package Einfo is\n    --    Needs_Debug_Info                    (Flag147)\n    --    Never_Set_In_Source                 (Flag115)\n    --    No_Return                           (Flag113)\n+   --    Overlays_Constant                   (Flag243)\n    --    Referenced                          (Flag156)\n    --    Referenced_As_LHS                   (Flag36)\n    --    Referenced_As_Out_Parameter         (Flag227)\n@@ -4608,6 +4645,7 @@ package Einfo is\n    --    Is_Derived_Type                     (synth)\n    --    Is_Dynamic_Scope                    (synth)\n    --    Is_Limited_Type                     (synth)\n+   --    Is_Standard_Character_Type          (synth)\n    --    Underlying_Type                     (synth)\n    --    all classification attributes       (synth)\n \n@@ -4671,6 +4709,8 @@ package Einfo is\n    --    Known_To_Have_Preelab_Init          (Flag207)\n    --    Must_Be_On_Byte_Boundary            (Flag183)\n    --    Must_Have_Preelab_Init              (Flag208)\n+   --    Optimize_Alignment_Space            (Flag241)\n+   --    Optimize_Alignment_Time             (Flag242)\n    --    Size_Depends_On_Discriminant        (Flag177)\n    --    Size_Known_At_Compile_Time          (Flag92)\n    --    Strict_Alignment                    (Flag145)  (base type only)\n@@ -4700,14 +4740,14 @@ package Einfo is\n    --    Directly_Designated_Type            (Node20)\n    --    Needs_No_Actuals                    (Flag22)\n    --    Can_Use_Internal_Rep                (Flag229)\n-   --        (plus type attributes)\n+   --    (plus type attributes)\n \n    --  E_Access_Subprogram_Type\n    --    Equivalent_Type                     (Node18)   (remote types only)\n    --    Directly_Designated_Type            (Node20)\n    --    Needs_No_Actuals                    (Flag22)\n    --    Can_Use_Internal_Rep                (Flag229)\n-   --        (plus type attributes)\n+   --    (plus type attributes)\n \n    --  E_Access_Type\n    --  E_Access_Subtype\n@@ -4802,7 +4842,6 @@ package Einfo is\n    --    Discriminant_Checking_Func          (Node20)\n    --    Interface_Name                      (Node21)   (JGNAT usage only)\n    --    Original_Record_Component           (Node22)\n-   --    Protected_Operation                 (Node23)\n    --    DT_Offset_To_Top_Func               (Node25)\n    --    Related_Type                        (Node26)\n    --    Has_Biased_Representation           (Flag139)\n@@ -4812,7 +4851,6 @@ package Einfo is\n    --    Is_Volatile                         (Flag16)\n    --    Treat_As_Volatile                   (Flag41)\n    --    Is_Return_Object                    (Flag209)\n-   --    Is_Protected_Private                (synth)\n    --    Next_Component                      (synth)\n    --    Next_Component_Or_Discriminant      (synth)\n    --    Next_Tag_Component                  (synth)\n@@ -4827,6 +4865,7 @@ package Einfo is\n    --    Actual_Subtype                      (Node17)\n    --    Renamed_Object                      (Node18)\n    --    Size_Check_Code                     (Node19)   (constants only)\n+   --    Prival_Link                         (Node20)   (privals only)\n    --    Interface_Name                      (Node21)\n    --    Related_Type                        (Node26)   (constants only)\n    --    Has_Alignment_Clause                (Flag46)\n@@ -4839,10 +4878,12 @@ package Einfo is\n    --    Has_Volatile_Components             (Flag87)\n    --    Is_Atomic                           (Flag85)\n    --    Is_Eliminated                       (Flag124)\n+   --    Is_Return_Object                    (Flag209)\n    --    Is_True_Constant                    (Flag163)\n    --    Is_Volatile                         (Flag16)\n+   --    Optimize_Alignment_Space            (Flag241)  (constants only)\n+   --    Optimize_Alignment_Time             (Flag242)  (constants only)\n    --    Treat_As_Volatile                   (Flag41)\n-   --    Is_Return_Object                    (Flag209)\n    --    Address_Clause                      (synth)\n    --    Alignment_Clause                    (synth)\n    --    Constant_Value                      (synth)\n@@ -4893,7 +4934,7 @@ package Einfo is\n    --    Last_Entity                         (Node20)\n    --    Accept_Address                      (Elist21)\n    --    Scope_Depth_Value                   (Uint22)\n-   --    Privals_Chain                       (Elist23)  (for a protected entry)\n+   --    Protection_Object                   (Node23)   (protected kind)\n    --    Default_Expressions_Processed       (Flag108)\n    --    Entry_Accepted                      (Flag152)\n    --    Is_AST_Entry                        (Flag132)  (for entry only)\n@@ -4976,7 +5017,7 @@ package Einfo is\n    --    Scope_Depth_Value                   (Uint22)\n    --    Generic_Renamings                   (Elist23)  (for an instance)\n    --    Inner_Instances                     (Elist23)  (generic function only)\n-   --    Privals_Chain                       (Elist23)  (protected func only)\n+   --    Protection_Object                   (Node23)   (for concurrent kind)\n    --    Abstract_Interface_Alias            (Node25)\n    --    Overridden_Operation                (Node26)\n    --    Extra_Formals                       (Node28)\n@@ -4992,6 +5033,7 @@ package Einfo is\n    --    Has_Master_Entity                   (Flag21)\n    --    Has_Missing_Return                  (Flag142)\n    --    Has_Nested_Block_With_Handler       (Flag101)\n+   --    Has_Postconditions                  (Flag240)\n    --    Has_Recursive_Call                  (Flag143)\n    --    Has_Subprogram_Descriptor           (Flag93)\n    --    Implemented_By_Entry                (Flag232)  (non-generic case only)\n@@ -5064,7 +5106,6 @@ package Einfo is\n    --    Extra_Formal                        (Node15)\n    --    Unset_Reference                     (Node16)\n    --    Actual_Subtype                      (Node17)\n-\n    --    Renamed_Object                      (Node18)\n    --    Spec_Entity                         (Node19)\n    --    Default_Value                       (Node20)\n@@ -5124,13 +5165,16 @@ package Einfo is\n    --    First_Entity                        (Node17)\n    --    Alias                               (Node18)\n    --    Last_Entity                         (Node20)\n+   --    Has_Postconditions                  (Flag240)\n    --    Is_Machine_Code_Subprogram          (Flag137)\n    --    Is_Pure                             (Flag44)\n    --    Is_Intrinsic_Subprogram             (Flag64)\n    --    Is_Overriding_Operation             (Flag39)\n    --    Is_Primitive                        (Flag218)\n    --    Is_Thunk                            (Flag225)\n    --    Default_Expressions_Processed       (Flag108)\n+   --    Aren't there more flags and fields? seems like this list should be\n+   --    more similar to the E_Function list, which is much longer ???\n \n    --  E_Ordinary_Fixed_Point_Type\n    --  E_Ordinary_Fixed_Point_Subtype\n@@ -5162,7 +5206,7 @@ package Einfo is\n    --    Generic_Renamings                   (Elist23)  (for an instance)\n    --    Inner_Instances                     (Elist23)  (generic case only)\n    --    Limited_View                        (Node23)   (non-generic/instance)\n-   --    Current_Use_Clause                  (Node25)\n+   --    Current_Use_Clause                  (Node27)\n    --    Package_Instantiation               (Node26)\n    --    Delay_Subprogram_Descriptors        (Flag50)\n    --    Body_Needed_For_SAL                 (Flag40)\n@@ -5233,7 +5277,8 @@ package Einfo is\n    --    Scope_Depth_Value                   (Uint22)\n    --    Generic_Renamings                   (Elist23)  (for instance)\n    --    Inner_Instances                     (Elist23)  (for generic proc)\n-   --    Privals_Chain                       (Elist23)  (for protected proc)\n+   --    Protection_Object                   (Node23)   (for concurrent kind)\n+   --    Spec_PPC_List                       (Node24)   (non-generic case only)\n    --    Abstract_Interface_Alias            (Node25)\n    --    Static_Initialization               (Node26)   (init_proc only)\n    --    Overridden_Operation                (Node26)\n@@ -5251,6 +5296,7 @@ package Einfo is\n    --    Has_Completion                      (Flag26)\n    --    Has_Master_Entity                   (Flag21)\n    --    Has_Nested_Block_With_Handler       (Flag101)\n+   --    Has_Postconditions                  (Flag240)\n    --    Has_Subprogram_Descriptor           (Flag93)\n    --    Implemented_By_Entry                (Flag232)  (non-generic case only)\n    --    Is_Visible_Child_Unit               (Flag116)\n@@ -5280,11 +5326,8 @@ package Einfo is\n    --    First_Formal                        (synth)\n    --    First_Formal_With_Extras            (synth)\n    --    Number_Formals                      (synth)\n-   --    Delay_Cleanups                      (Flag114)\n-   --    Discard_Names                       (Flag88)\n \n    --  E_Protected_Body\n-   --    Object_Ref                          (Node17)\n    --    (any others??? First/Last Entity, Scope_Depth???)\n \n    --  E_Protected_Object\n@@ -5438,6 +5481,7 @@ package Einfo is\n    --    Sec_Stack_Needed_For_Return         (Flag167)  ???\n    --    Has_Entries                         (synth)\n    --    Number_Entries                      (synth)\n+   --    Relative_Deadline_Variable          (Node26)   (base type only)\n    --    (plus type attributes)\n \n    --  E_Variable\n@@ -5451,6 +5495,7 @@ package Einfo is\n    --    Actual_Subtype                      (Node17)\n    --    Renamed_Object                      (Node18)\n    --    Size_Check_Code                     (Node19)\n+   --    Prival_Link                         (Node20)\n    --    Interface_Name                      (Node21)\n    --    Shared_Var_Assign_Proc              (Node22)\n    --    Extra_Constrained                   (Node23)\n@@ -5461,15 +5506,17 @@ package Einfo is\n    --    Has_Biased_Representation           (Flag139)\n    --    Has_Initial_Value                   (Flag219)\n    --    Has_Size_Clause                     (Flag29)\n+   --    Has_Up_Level_Access                 (Flag215)\n    --    Has_Volatile_Components             (Flag87)\n    --    Is_Atomic                           (Flag85)\n    --    Is_Eliminated                       (Flag124)\n    --    Is_Shared_Passive                   (Flag60)\n    --    Is_True_Constant                    (Flag163)\n    --    Is_Volatile                         (Flag16)\n-   --    Treat_As_Volatile                   (Flag41)\n    --    Is_Return_Object                    (Flag209)\n-   --    Has_Up_Level_Access                 (Flag215)\n+   --    Optimize_Alignment_Space            (Flag241)\n+   --    Optimize_Alignment_Time             (Flag242)\n+   --    Treat_As_Volatile                   (Flag41)\n    --    Address_Clause                      (synth)\n    --    Alignment_Clause                    (synth)\n    --    Constant_Value                      (synth)\n@@ -5562,9 +5609,10 @@ package Einfo is\n    --  general manner, like any other variables:\n \n    --     In initialization expressions for records. Note that the expressions\n-   --     used in Priority, Storage_Size, and Task_Info pragmas are effectively\n-   --     in this category, since these pragmas are converted to initialized\n-   --     record fields in the Corresponding_Record_Type.\n+   --     used in Priority, Storage_Size, Task_Info and Relative_Deadline\n+   --     pragmas are effectively in this category, since these pragmas are\n+   --     converted to initialized record fields in the Corresponding_Record_\n+   --     Type.\n \n    --     In task and protected bodies, where the discriminant values may be\n    --     referenced freely within these bodies. Discriminants can also appear\n@@ -5574,12 +5622,12 @@ package Einfo is\n    --  objects. The following approach is used to simplify and minimize the\n    --  special processing that is required.\n \n-   --  When a record type with discriminants is processed, the semantic\n-   --  processing creates the entities for the discriminants. It also creates\n-   --  an additional set of entities, called discriminals, one for each of\n-   --  the discriminants, and the Discriminal field of the discriminant entity\n-   --  points to this additional entity, which is initially created as an\n-   --  uninitialized (E_Void) entity.\n+   --  When a record type with discriminants is analyzed, semantic processing\n+   --  creates the entities for the discriminants. It also creates additional\n+   --  sets of entities called discriminals, one for each of the discriminants,\n+   --  and the Discriminal field of the discriminant entity points to this\n+   --  additional entity, which is initially created as an uninitialized\n+   --  (E_Void) entity.\n \n    --  During expansion of expressions, any discriminant reference is replaced\n    --  by a reference to the corresponding discriminal. When the initialization\n@@ -5590,17 +5638,17 @@ package Einfo is\n    --  have already been replaced by references to these discriminals, which\n    --  are now the formal parameters corresponding to the required objects.\n \n-   --  In the case of a task or protected body, the semantics similarly\n-   --  creates a set of discriminals for the discriminants of the task or\n-   --  protected type. When the procedure is created for the task body,\n-   --  the parameter passed in is a reference to the task value type, which\n-   --  contains the required discriminant values. The expander creates a\n-   --  set of declarations of the form:\n+   --  In the case of a task or protected body, the semantics similarly creates\n+   --  a set of discriminals for the discriminants of the task or protected\n+   --  type. When the procedure is created for the task body, the parameter\n+   --  passed in is a reference to the task value type, which contains the\n+   --  required discriminant values. The expander creates a set of declarations\n+   --  of the form:\n \n-   --      discriminal : constant dtype renames _Task.discriminant;\n+   --      discr_nameD : constant disrc_type renames _task.discr_name;\n \n-   --  where discriminal is the discriminal entity referenced by the task\n-   --  discriminant, and _Task is the task value passed in as the parameter.\n+   --  where discr_nameD is the discriminal entity referenced by the task\n+   --  discriminant, and _task is the task value passed in as the parameter.\n    --  Again, any references to discriminants in the task body have been\n    --  replaced by the discriminal reference, which is now an object that\n    --  contains the required value.\n@@ -5613,15 +5661,15 @@ package Einfo is\n    --  The one bit of trickiness arises in making sure that the right set of\n    --  discriminals is used at the right time. First the task definition is\n    --  processed. Any references to discriminants here are replaced by the\n-   --  the corresponding *task* discriminals (the record type doesn't even\n-   --  exist yet, since it is constructed as part of the expansion of the\n-   --  task declaration, which happens after the semantic processing of the\n-   --  task definition). The discriminants to be used for the corresponding\n-   --  record are created at the same time as the other discriminals, and\n-   --  held in the CR_Discriminant field of the discriminant. A use of the\n-   --  discriminant in a bound for an entry family is replaced with the CR_\n-   --  discriminant because it controls the bound of the entry queue array\n-   --  which is a component of the corresponding record.\n+   --  corresponding *task* discriminals (the record type doesn't even exist\n+   --  yet, since it is constructed as part of the expansion of the task\n+   --  declaration, which happens after the semantic processing of the task\n+   --  definition). The discriminants to be used for the corresponding record\n+   --  are created at the same time as the other discriminals, and held in the\n+   --  CR_Discriminant field of the discriminant. A use of the discriminant in\n+   --  a bound for an entry family is replaced with the CR_Discriminant because\n+   --  it controls the bound of the entry queue array which is a component of\n+   --  the corresponding record.\n \n    --  Just before the record initialization routine is constructed, the\n    --  expander exchanges the task and record discriminals. This has two\n@@ -5634,57 +5682,52 @@ package Einfo is\n    --  task body, and also for the discriminal declarations at the start of\n    --  the task body.\n \n-   ---------------------------------------\n-   -- Private data in protected objects --\n-   ---------------------------------------\n-\n-   --  Private object declarations in protected types pose problems\n-   --  similar to those of discriminants. They are expanded to components\n-   --  of a record which is passed as the parameter \"_object\" to expanded\n-   --  forms of all protected operations. As with discriminants, timing\n-   --  of this expansion is a problem. The sequence of statements for a\n-   --  protected operation is expanded before the operation itself, so the\n-   --  formal parameter for the record object containing the private data\n-   --  does not exist when the references to that data are expanded.\n-\n-   --  For this reason, private data is handled in the same way as\n-   --  discriminants, expanding references to private data in protected\n-   --  operations (which appear as components) to placeholders which will\n-   --  eventually become renamings of the private selected components\n-   --  of the \"_object\" formal parameter. These placeholders are called\n-   --  \"privals\", by analogy to the \"discriminals\" used to implement\n-   --  discriminants. They are attached to the component declaration nodes\n-   --  representing the private object declarations of the protected type.\n-\n-   --  As with discriminals, each protected subprogram needs a unique set\n-   --  of privals, since they must refer to renamings of components of a\n-   --  formal parameter of that operation. Entry bodies need another set,\n-   --  which they all share and which is associated with renamings in the\n-   --  Service_Entries procedure for the protected type (this is not yet\n-   --  implemented???). This means that we must associate a new set of\n-   --  privals (and discriminals) with the private declarations after\n-   --  the body of a protected subprogram is processed.\n-\n-   --  The last complication is the presence of discriminants and discriminated\n-   --  components. In the corresponding record, the components are constrained\n-   --  by the discriminants of the record, but within each protected operation\n-   --  they are constrained by the discriminants of the actual. The actual\n-   --  subtypes of those components are constructed as for other unconstrained\n-   --  formals, but the privals are created before the formal object is added\n-   --  to the parameter list of the protected operation, so they carry the\n-   --  nominal subtype of the original component. After the protected operation\n-   --  is actually created (in  the expansion of the protected body) we must\n-   --  patch the types of each prival occurrence with the proper actual subtype\n-   --  which is by now set. The Privals_Chain is used for this patching.\n+   ---------------------------------------------------\n+   -- Handling of private data in protected objects --\n+   ---------------------------------------------------\n+\n+   --  Private components in protected types pose problems similar to those\n+   --  of discriminants. Private data is visible and can be directly referenced\n+   --  from protected bodies. However, when protected entries and subprograms\n+   --  are expanded into corresponding bodies and barrier functions, private\n+   --  components lose their original context and visibility.\n+\n+   --  To remedy this side effect of expansion, private components are expanded\n+   --  into renamings called \"privals\", by analogy with \"discriminals\".\n+\n+   --     private_comp : comp_type renames _object.private_comp;\n+\n+   --  Prival declarations are inserted during the analysis of subprogram and\n+   --  entry bodies to ensure proper visibility for any subsequent expansion.\n+   --  _Object is the formal parameter of the generated corresponding body or\n+   --  a local renaming which denotes the protected object obtained from entry\n+   --  parameter _O. Privals receive minimal decoration upon creation and are\n+   --  categorized as either E_Variable for the general case or E_Constant when\n+   --  they appear in functions.\n+\n+   --  Along with the local declarations, each private component carries a\n+   --  placeholder which references the prival entity in the current body. This\n+   --  form of indirection is used to resolve name clashes of privals and other\n+   --  locally visible entities such as parameters, local objects, entry family\n+   --  indexes or identifiers used in the barrier condition.\n+\n+   --  When analyzing the statements of a protected subprogram or entry, any\n+   --  reference to a private component must resolve to the locally declared\n+   --  prival through normal visibility. In case of name conflicts (the cases\n+   --  above), the prival is marked as hidden and acts as a weakly declared\n+   --  entity. As a result, the reference points to the correct entity. When a\n+   --  private component is denoted by an expanded name (prot_type.comp for\n+   --  example), the expansion mechanism uses the placeholder of the component\n+   --  to correct the Entity and Etype of the reference.\n \n    -------------------\n    -- Type Synonyms --\n    -------------------\n \n    --  The following type synonyms are used to tidy up the function and\n-   --  procedure declarations that follow, and also to make it possible\n-   --  to meet the requirement for the XEINFO utility that all function\n-   --  specs must fit on a single source line.\n+   --  procedure declarations that follow, and also to make it possible to meet\n+   --  the requirement for the XEINFO utility that all function specs must fit\n+   --  on a single source line.\n \n    subtype B is Boolean;\n    subtype C is Component_Alignment_Kind;\n@@ -5837,6 +5880,7 @@ package Einfo is\n    function Has_Object_Size_Clause              (Id : E) return B;\n    function Has_Per_Object_Constraint           (Id : E) return B;\n    function Has_Persistent_BSS                  (Id : E) return B;\n+   function Has_Postconditions                  (Id : E) return B;\n    function Has_Pragma_Controlled               (Id : E) return B;\n    function Has_Pragma_Elaborate_Body           (Id : E) return B;\n    function Has_Pragma_Inline                   (Id : E) return B;\n@@ -5901,6 +5945,7 @@ package Einfo is\n    function Is_Controlled                       (Id : E) return B;\n    function Is_Controlling_Formal               (Id : E) return B;\n    function Is_Discrim_SO_Function              (Id : E) return B;\n+   function Is_Dispatch_Table_Entity            (Id : E) return B;\n    function Is_Dispatching_Operation            (Id : E) return B;\n    function Is_Eliminated                       (Id : E) return B;\n    function Is_Entry_Formal                     (Id : E) return B;\n@@ -5951,7 +5996,6 @@ package Einfo is\n    function Is_Renaming_Of_Object               (Id : E) return B;\n    function Is_Return_Object                    (Id : E) return B;\n    function Is_Shared_Passive                   (Id : E) return B;\n-   function Is_Static_Dispatch_Table_Entity     (Id : E) return B;\n    function Is_Statically_Allocated             (Id : E) return B;\n    function Is_Synchronized_Interface           (Id : E) return B;\n    function Is_Tag                              (Id : E) return B;\n@@ -5998,23 +6042,24 @@ package Einfo is\n    function Normalized_First_Bit                (Id : E) return U;\n    function Normalized_Position                 (Id : E) return U;\n    function Normalized_Position_Max             (Id : E) return U;\n-   function Object_Ref                          (Id : E) return E;\n-   function Obsolescent_Warning                 (Id : E) return N;\n    function OK_To_Reorder_Components            (Id : E) return B;\n+   function Optimize_Alignment_Space            (Id : E) return B;\n+   function Optimize_Alignment_Time             (Id : E) return B;\n    function Original_Array_Type                 (Id : E) return E;\n    function Original_Record_Component           (Id : E) return E;\n+   function Overlays_Constant                   (Id : E) return B;\n    function Overridden_Operation                (Id : E) return E;\n    function Package_Instantiation               (Id : E) return N;\n    function Packed_Array_Type                   (Id : E) return E;\n    function Parent_Subtype                      (Id : E) return E;\n    function Primitive_Operations                (Id : E) return L;\n    function Prival                              (Id : E) return E;\n-   function Privals_Chain                       (Id : E) return L;\n+   function Prival_Link                         (Id : E) return E;\n    function Private_Dependents                  (Id : E) return L;\n    function Private_View                        (Id : E) return N;\n    function Protected_Body_Subprogram           (Id : E) return E;\n    function Protected_Formal                    (Id : E) return E;\n-   function Protected_Operation                 (Id : E) return E;\n+   function Protection_Object                   (Id : E) return E;\n    function RM_Size                             (Id : E) return U;\n    function Reachable                           (Id : E) return B;\n    function Referenced                          (Id : E) return B;\n@@ -6025,6 +6070,7 @@ package Einfo is\n    function Related_Array_Object                (Id : E) return E;\n    function Related_Instance                    (Id : E) return E;\n    function Related_Type                        (Id : E) return E;\n+   function Relative_Deadline_Variable          (Id : E) return E;\n    function Renamed_Entity                      (Id : E) return N;\n    function Renamed_In_Spec                     (Id : E) return B;\n    function Renamed_Object                      (Id : E) return N;\n@@ -6046,6 +6092,7 @@ package Einfo is\n    function Size_Depends_On_Discriminant        (Id : E) return B;\n    function Small_Value                         (Id : E) return R;\n    function Spec_Entity                         (Id : E) return E;\n+   function Spec_PPC_List                       (Id : E) return N;\n    function Storage_Size_Variable               (Id : E) return E;\n    function Static_Elaboration_Desired          (Id : E) return B;\n    function Static_Initialization               (Id : E) return N;\n@@ -6162,14 +6209,18 @@ package Einfo is\n    function Is_Boolean_Type                     (Id : E) return B;\n    function Is_By_Copy_Type                     (Id : E) return B;\n    function Is_By_Reference_Type                (Id : E) return B;\n+   function Is_Constant_Object                  (Id : E) return B;\n    function Is_Derived_Type                     (Id : E) return B;\n+   function Is_Discriminal                      (Id : E) return B;\n    function Is_Dynamic_Scope                    (Id : E) return B;\n    function Is_Indefinite_Subtype               (Id : E) return B;\n    function Is_Limited_Type                     (Id : E) return B;\n    function Is_Package_Or_Generic_Package       (Id : E) return B;\n-   function Is_Protected_Private                (Id : E) return B;\n+   function Is_Prival                           (Id : E) return B;\n+   function Is_Protected_Component              (Id : E) return B;\n    function Is_Protected_Record_Type            (Id : E) return B;\n    function Is_Inherently_Limited_Type          (Id : E) return B;\n+   function Is_Standard_Character_Type          (Id : E) return B;\n    function Is_String_Type                      (Id : E) return B;\n    function Is_Task_Record_Type                 (Id : E) return B;\n    function Is_Wrapper_Package                  (Id : E) return B;\n@@ -6386,6 +6437,7 @@ package Einfo is\n    procedure Set_Has_Object_Size_Clause          (Id : E; V : B := True);\n    procedure Set_Has_Per_Object_Constraint       (Id : E; V : B := True);\n    procedure Set_Has_Persistent_BSS              (Id : E; V : B := True);\n+   procedure Set_Has_Postconditions              (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Controlled           (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Elaborate_Body       (Id : E; V : B := True);\n    procedure Set_Has_Pragma_Inline               (Id : E; V : B := True);\n@@ -6453,6 +6505,7 @@ package Einfo is\n    procedure Set_Is_Controlling_Formal           (Id : E; V : B := True);\n    procedure Set_Is_Descendent_Of_Address        (Id : E; V : B := True);\n    procedure Set_Is_Discrim_SO_Function          (Id : E; V : B := True);\n+   procedure Set_Is_Dispatch_Table_Entity        (Id : E; V : B := True);\n    procedure Set_Is_Dispatching_Operation        (Id : E; V : B := True);\n    procedure Set_Is_Eliminated                   (Id : E; V : B := True);\n    procedure Set_Is_Entry_Formal                 (Id : E; V : B := True);\n@@ -6508,7 +6561,6 @@ package Einfo is\n    procedure Set_Is_Renaming_Of_Object           (Id : E; V : B := True);\n    procedure Set_Is_Return_Object                (Id : E; V : B := True);\n    procedure Set_Is_Shared_Passive               (Id : E; V : B := True);\n-   procedure Set_Is_Static_Dispatch_Table_Entity (Id : E; V : B := True);\n    procedure Set_Is_Statically_Allocated         (Id : E; V : B := True);\n    procedure Set_Is_Synchronized_Interface       (Id : E; V : B := True);\n    procedure Set_Is_Tag                          (Id : E; V : B := True);\n@@ -6555,23 +6607,24 @@ package Einfo is\n    procedure Set_Normalized_First_Bit            (Id : E; V : U);\n    procedure Set_Normalized_Position             (Id : E; V : U);\n    procedure Set_Normalized_Position_Max         (Id : E; V : U);\n-   procedure Set_Object_Ref                      (Id : E; V : E);\n-   procedure Set_Obsolescent_Warning             (Id : E; V : N);\n    procedure Set_OK_To_Reorder_Components        (Id : E; V : B := True);\n+   procedure Set_Optimize_Alignment_Space        (Id : E; V : B := True);\n+   procedure Set_Optimize_Alignment_Time         (Id : E; V : B := True);\n    procedure Set_Original_Array_Type             (Id : E; V : E);\n    procedure Set_Original_Record_Component       (Id : E; V : E);\n+   procedure Set_Overlays_Constant               (Id : E; V : B := True);\n    procedure Set_Overridden_Operation            (Id : E; V : E);\n    procedure Set_Package_Instantiation           (Id : E; V : N);\n    procedure Set_Packed_Array_Type               (Id : E; V : E);\n    procedure Set_Parent_Subtype                  (Id : E; V : E);\n    procedure Set_Primitive_Operations            (Id : E; V : L);\n    procedure Set_Prival                          (Id : E; V : E);\n-   procedure Set_Privals_Chain                   (Id : E; V : L);\n+   procedure Set_Prival_Link                     (Id : E; V : E);\n    procedure Set_Private_Dependents              (Id : E; V : L);\n    procedure Set_Private_View                    (Id : E; V : N);\n    procedure Set_Protected_Body_Subprogram       (Id : E; V : E);\n    procedure Set_Protected_Formal                (Id : E; V : E);\n-   procedure Set_Protected_Operation             (Id : E; V : N);\n+   procedure Set_Protection_Object               (Id : E; V : E);\n    procedure Set_RM_Size                         (Id : E; V : U);\n    procedure Set_Reachable                       (Id : E; V : B := True);\n    procedure Set_Referenced                      (Id : E; V : B := True);\n@@ -6582,6 +6635,7 @@ package Einfo is\n    procedure Set_Related_Array_Object            (Id : E; V : E);\n    procedure Set_Related_Instance                (Id : E; V : E);\n    procedure Set_Related_Type                    (Id : E; V : E);\n+   procedure Set_Relative_Deadline_Variable      (Id : E; V : E);\n    procedure Set_Renamed_Entity                  (Id : E; V : N);\n    procedure Set_Renamed_In_Spec                 (Id : E; V : B := True);\n    procedure Set_Renamed_Object                  (Id : E; V : N);\n@@ -6603,6 +6657,7 @@ package Einfo is\n    procedure Set_Size_Known_At_Compile_Time      (Id : E; V : B := True);\n    procedure Set_Small_Value                     (Id : E; V : R);\n    procedure Set_Spec_Entity                     (Id : E; V : E);\n+   procedure Set_Spec_PPC_List                   (Id : E; V : N);\n    procedure Set_Storage_Size_Variable           (Id : E; V : E);\n    procedure Set_Static_Elaboration_Desired      (Id : E; V : B);\n    procedure Set_Static_Initialization           (Id : E; V : N);\n@@ -7029,6 +7084,7 @@ package Einfo is\n    pragma Inline (Has_Object_Size_Clause);\n    pragma Inline (Has_Per_Object_Constraint);\n    pragma Inline (Has_Persistent_BSS);\n+   pragma Inline (Has_Postconditions);\n    pragma Inline (Has_Pragma_Controlled);\n    pragma Inline (Has_Pragma_Elaborate_Body);\n    pragma Inline (Has_Pragma_Inline);\n@@ -7110,6 +7166,7 @@ package Einfo is\n    pragma Inline (Is_Descendent_Of_Address);\n    pragma Inline (Is_Discrete_Or_Fixed_Point_Type);\n    pragma Inline (Is_Discrete_Type);\n+   pragma Inline (Is_Dispatch_Table_Entity);\n    pragma Inline (Is_Dispatching_Operation);\n    pragma Inline (Is_Elementary_Type);\n    pragma Inline (Is_Eliminated);\n@@ -7189,7 +7246,6 @@ package Einfo is\n    pragma Inline (Is_Scalar_Type);\n    pragma Inline (Is_Shared_Passive);\n    pragma Inline (Is_Signed_Integer_Type);\n-   pragma Inline (Is_Static_Dispatch_Table_Entity);\n    pragma Inline (Is_Statically_Allocated);\n    pragma Inline (Is_Subprogram);\n    pragma Inline (Is_Synchronized_Interface);\n@@ -7240,24 +7296,25 @@ package Einfo is\n    pragma Inline (Normalized_First_Bit);\n    pragma Inline (Normalized_Position);\n    pragma Inline (Normalized_Position_Max);\n-   pragma Inline (Object_Ref);\n-   pragma Inline (Obsolescent_Warning);\n    pragma Inline (OK_To_Reorder_Components);\n+   pragma Inline (Optimize_Alignment_Space);\n+   pragma Inline (Optimize_Alignment_Time);\n    pragma Inline (Original_Array_Type);\n    pragma Inline (Original_Record_Component);\n+   pragma Inline (Overlays_Constant);\n    pragma Inline (Overridden_Operation);\n    pragma Inline (Package_Instantiation);\n    pragma Inline (Packed_Array_Type);\n    pragma Inline (Parameter_Mode);\n    pragma Inline (Parent_Subtype);\n    pragma Inline (Primitive_Operations);\n    pragma Inline (Prival);\n-   pragma Inline (Privals_Chain);\n+   pragma Inline (Prival_Link);\n    pragma Inline (Private_Dependents);\n    pragma Inline (Private_View);\n    pragma Inline (Protected_Body_Subprogram);\n    pragma Inline (Protected_Formal);\n-   pragma Inline (Protected_Operation);\n+   pragma Inline (Protection_Object);\n    pragma Inline (RM_Size);\n    pragma Inline (Reachable);\n    pragma Inline (Referenced);\n@@ -7268,6 +7325,7 @@ package Einfo is\n    pragma Inline (Related_Array_Object);\n    pragma Inline (Related_Instance);\n    pragma Inline (Related_Type);\n+   pragma Inline (Relative_Deadline_Variable);\n    pragma Inline (Renamed_Entity);\n    pragma Inline (Renamed_In_Spec);\n    pragma Inline (Renamed_Object);\n@@ -7289,6 +7347,7 @@ package Einfo is\n    pragma Inline (Size_Known_At_Compile_Time);\n    pragma Inline (Small_Value);\n    pragma Inline (Spec_Entity);\n+   pragma Inline (Spec_PPC_List);\n    pragma Inline (Storage_Size_Variable);\n    pragma Inline (Static_Elaboration_Desired);\n    pragma Inline (Static_Initialization);\n@@ -7362,6 +7421,7 @@ package Einfo is\n    pragma Inline (Set_DT_Entry_Count);\n    pragma Inline (Set_DT_Offset_To_Top_Func);\n    pragma Inline (Set_DT_Position);\n+   pragma Inline (Set_Relative_Deadline_Variable);\n    pragma Inline (Set_Default_Expr_Function);\n    pragma Inline (Set_Default_Expressions_Processed);\n    pragma Inline (Set_Default_Value);\n@@ -7449,6 +7509,7 @@ package Einfo is\n    pragma Inline (Set_Has_Object_Size_Clause);\n    pragma Inline (Set_Has_Per_Object_Constraint);\n    pragma Inline (Set_Has_Persistent_BSS);\n+   pragma Inline (Set_Has_Postconditions);\n    pragma Inline (Set_Has_Pragma_Controlled);\n    pragma Inline (Set_Has_Pragma_Elaborate_Body);\n    pragma Inline (Set_Has_Pragma_Inline);\n@@ -7517,6 +7578,7 @@ package Einfo is\n    pragma Inline (Set_Is_Controlling_Formal);\n    pragma Inline (Set_Is_Descendent_Of_Address);\n    pragma Inline (Set_Is_Discrim_SO_Function);\n+   pragma Inline (Set_Is_Dispatch_Table_Entity);\n    pragma Inline (Set_Is_Dispatching_Operation);\n    pragma Inline (Set_Is_Eliminated);\n    pragma Inline (Set_Is_Entry_Formal);\n@@ -7572,7 +7634,6 @@ package Einfo is\n    pragma Inline (Set_Is_Renaming_Of_Object);\n    pragma Inline (Set_Is_Return_Object);\n    pragma Inline (Set_Is_Shared_Passive);\n-   pragma Inline (Set_Is_Static_Dispatch_Table_Entity);\n    pragma Inline (Set_Is_Statically_Allocated);\n    pragma Inline (Set_Is_Synchronized_Interface);\n    pragma Inline (Set_Is_Tag);\n@@ -7619,23 +7680,24 @@ package Einfo is\n    pragma Inline (Set_Normalized_First_Bit);\n    pragma Inline (Set_Normalized_Position);\n    pragma Inline (Set_Normalized_Position_Max);\n-   pragma Inline (Set_Object_Ref);\n-   pragma Inline (Set_Obsolescent_Warning);\n    pragma Inline (Set_OK_To_Reorder_Components);\n+   pragma Inline (Set_Optimize_Alignment_Space);\n+   pragma Inline (Set_Optimize_Alignment_Time);\n    pragma Inline (Set_Original_Array_Type);\n    pragma Inline (Set_Original_Record_Component);\n+   pragma Inline (Set_Overlays_Constant);\n    pragma Inline (Set_Overridden_Operation);\n    pragma Inline (Set_Package_Instantiation);\n    pragma Inline (Set_Packed_Array_Type);\n    pragma Inline (Set_Parent_Subtype);\n    pragma Inline (Set_Primitive_Operations);\n    pragma Inline (Set_Prival);\n-   pragma Inline (Set_Privals_Chain);\n+   pragma Inline (Set_Prival_Link);\n    pragma Inline (Set_Private_Dependents);\n    pragma Inline (Set_Private_View);\n    pragma Inline (Set_Protected_Body_Subprogram);\n    pragma Inline (Set_Protected_Formal);\n-   pragma Inline (Set_Protected_Operation);\n+   pragma Inline (Set_Protection_Object);\n    pragma Inline (Set_RM_Size);\n    pragma Inline (Set_Reachable);\n    pragma Inline (Set_Referenced);\n@@ -7667,6 +7729,7 @@ package Einfo is\n    pragma Inline (Set_Size_Known_At_Compile_Time);\n    pragma Inline (Set_Small_Value);\n    pragma Inline (Set_Spec_Entity);\n+   pragma Inline (Set_Spec_PPC_List);\n    pragma Inline (Set_Storage_Size_Variable);\n    pragma Inline (Set_Static_Elaboration_Desired);\n    pragma Inline (Set_Static_Initialization);"}, {"sha": "b6d4ae8d6e3a5501c355d6e262b958f6155fe611", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 413, "deletions": 304, "changes": 717, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -30,13 +30,16 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Exp_Atag; use Exp_Atag;\n with Exp_Ch2;  use Exp_Ch2;\n+with Exp_Ch3;  use Exp_Ch3;\n+with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch9;  use Exp_Ch9;\n with Exp_Imgv; use Exp_Imgv;\n with Exp_Pakd; use Exp_Pakd;\n with Exp_Strm; use Exp_Strm;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Exp_VFpt; use Exp_VFpt;\n+with Fname;    use Fname;\n with Freeze;   use Freeze;\n with Gnatvsn;  use Gnatvsn;\n with Itypes;   use Itypes;\n@@ -251,12 +254,20 @@ package body Exp_Attr is\n \n       function May_Be_External_Call return Boolean is\n          Subp : Entity_Id;\n+         Par  : Node_Id := Parent (N);\n+\n       begin\n-         if (Nkind (Parent (N)) = N_Procedure_Call_Statement\n-              or else Nkind (Parent (N)) = N_Function_Call)\n-            and then Is_Entity_Name (Name (Parent (N)))\n+         --  Account for the case where the Access attribute is part of a\n+         --  named parameter association.\n+\n+         if Nkind (Par) = N_Parameter_Association then\n+            Par := Parent (Par);\n+         end if;\n+\n+         if Nkind_In (Par, N_Procedure_Call_Statement, N_Function_Call)\n+            and then Is_Entity_Name (Name (Par))\n          then\n-            Subp := Entity (Name (Parent (N)));\n+            Subp := Entity (Name (Par));\n             return not In_Open_Scopes (Scope (Subp));\n          else\n             return False;\n@@ -272,8 +283,6 @@ package body Exp_Attr is\n       --  current enclosing operation.\n \n       if Is_Entity_Name (Pref) then\n-         pragma Assert (In_Open_Scopes (Scope (Entity (Pref))));\n-\n          if May_Be_External_Call then\n             Sub :=\n               New_Occurrence_Of\n@@ -284,10 +293,18 @@ package body Exp_Attr is\n                 (Protected_Body_Subprogram (Entity (Pref)), Loc);\n          end if;\n \n+         --  Don't traverse the scopes when the attribute occurs within an init\n+         --  proc, because we directly use the _init formal of the init proc in\n+         --  that case.\n+\n          Curr := Current_Scope;\n-         while Scope (Curr) /= Scope (Entity (Pref)) loop\n-            Curr := Scope (Curr);\n-         end loop;\n+         if not Is_Init_Proc (Curr) then\n+            pragma Assert (In_Open_Scopes (Scope (Entity (Pref))));\n+\n+            while Scope (Curr) /= Scope (Entity (Pref)) loop\n+               Curr := Scope (Curr);\n+            end loop;\n+         end if;\n \n          --  In case of protected entries the first formal of its Protected_\n          --  Body_Subprogram is the address of the object.\n@@ -298,6 +315,15 @@ package body Exp_Attr is\n                  (First_Formal\n                    (Protected_Body_Subprogram (Curr)), Loc);\n \n+         --  If the current scope is an init proc, then use the address of the\n+         --  _init formal as the object reference.\n+\n+         elsif Is_Init_Proc (Curr) then\n+            Obj_Ref :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix         => New_Occurrence_Of (First_Formal (Curr), Loc),\n+                Attribute_Name => Name_Address);\n+\n          --  In case of protected subprograms the first formal of its\n          --  Protected_Body_Subprogram is the object and we get its address.\n \n@@ -464,6 +490,7 @@ package body Exp_Attr is\n       Typ   : constant Entity_Id    := Etype (N);\n       Btyp  : constant Entity_Id    := Base_Type (Typ);\n       Pref  : constant Node_Id      := Prefix (N);\n+      Ptyp  : constant Entity_Id    := Etype (Pref);\n       Exprs : constant List_Id      := Expressions (N);\n       Id    : constant Attribute_Id := Get_Attribute_Id (Attribute_Name (N));\n \n@@ -595,6 +622,19 @@ package body Exp_Attr is\n          end;\n       end if;\n \n+      --  Ada 2005 (AI-318-02): If attribute prefix is a call to a build-in-\n+      --  place function, then a temporary return object needs to be created\n+      --  and access to it must be passed to the function. Currently we limit\n+      --  such functions to those with inherently limited result subtypes, but\n+      --  eventually we plan to expand the functions that are treated as\n+      --  build-in-place to include other composite result types.\n+\n+      if Ada_Version >= Ada_05\n+        and then Is_Build_In_Place_Function_Call (Pref)\n+      then\n+         Make_Build_In_Place_Call_In_Anonymous_Context (Pref);\n+      end if;\n+\n       --  Remaining processing depends on specific attribute\n \n       case Id is\n@@ -620,111 +660,79 @@ package body Exp_Attr is\n             if Id = Attribute_Unrestricted_Access\n               and then Is_Subprogram (Directly_Designated_Type (Typ))\n             then\n-               --  The following assertion ensures that this special management\n+               --  The following conditions ensure that this special management\n                --  is done only for \"Address!(Prim'Unrestricted_Access)\" nodes.\n                --  At this stage other cases in which the designated type is\n                --  still a subprogram (instead of an E_Subprogram_Type) are\n                --  wrong because the semantics must have overridden the type of\n                --  the node with the type imposed by the context.\n \n-               pragma Assert (Nkind (Parent (N)) = N_Unchecked_Type_Conversion\n-                 and then Etype (Parent (N)) = RTE (RE_Address));\n-\n-               declare\n-                  Subp : constant Entity_Id := Directly_Designated_Type (Typ);\n-\n-                  Extra      : Entity_Id := Empty;\n-                  New_Formal : Entity_Id;\n-                  Old_Formal : Entity_Id := First_Formal (Subp);\n-                  Subp_Typ   : Entity_Id;\n+               if Nkind (Parent (N)) = N_Unchecked_Type_Conversion\n+                 and then Etype (Parent (N)) = RTE (RE_Prim_Ptr)\n+               then\n+                  Set_Etype (N, RTE (RE_Prim_Ptr));\n \n-               begin\n-                  Subp_Typ := Create_Itype (E_Subprogram_Type, N);\n-                  Set_Etype (Subp_Typ, Etype (Subp));\n-                  Set_Returns_By_Ref (Subp_Typ, Returns_By_Ref (Subp));\n+               else\n+                  declare\n+                     Subp       : constant Entity_Id :=\n+                                    Directly_Designated_Type (Typ);\n+                     Etyp       : Entity_Id;\n+                     Extra      : Entity_Id := Empty;\n+                     New_Formal : Entity_Id;\n+                     Old_Formal : Entity_Id := First_Formal (Subp);\n+                     Subp_Typ   : Entity_Id;\n \n-                  if Present (Old_Formal) then\n-                     New_Formal := New_Copy (Old_Formal);\n-                     Set_First_Entity (Subp_Typ, New_Formal);\n+                  begin\n+                     Subp_Typ := Create_Itype (E_Subprogram_Type, N);\n+                     Set_Etype (Subp_Typ, Etype (Subp));\n+                     Set_Returns_By_Ref (Subp_Typ, Returns_By_Ref (Subp));\n \n-                     loop\n-                        Set_Scope (New_Formal, Subp_Typ);\n+                     if Present (Old_Formal) then\n+                        New_Formal := New_Copy (Old_Formal);\n+                        Set_First_Entity (Subp_Typ, New_Formal);\n \n-                        --  Handle itypes\n+                        loop\n+                           Set_Scope (New_Formal, Subp_Typ);\n+                           Etyp := Etype (New_Formal);\n \n-                        if Is_Itype (Etype (New_Formal)) then\n-                           Extra := New_Copy (Etype (New_Formal));\n+                           --  Handle itypes. There is no need to duplicate\n+                           --  here the itypes associated with record types\n+                           --  (i.e the implicit full view of private types).\n \n-                           if Ekind (Extra) = E_Record_Subtype\n-                             or else Ekind (Extra) = E_Class_Wide_Subtype\n+                           if Is_Itype (Etyp)\n+                             and then Ekind (Base_Type (Etyp)) /= E_Record_Type\n                            then\n-                              Set_Cloned_Subtype (Extra,\n-                                Etype (New_Formal));\n+                              Extra := New_Copy (Etyp);\n+                              Set_Parent (Extra, New_Formal);\n+                              Set_Etype (New_Formal, Extra);\n+                              Set_Scope (Extra, Subp_Typ);\n                            end if;\n \n-                           Set_Etype (New_Formal, Extra);\n-                           Set_Scope (Etype (New_Formal), Subp_Typ);\n-                        end if;\n-\n-                        Extra := New_Formal;\n-                        Next_Formal (Old_Formal);\n-                        exit when No (Old_Formal);\n-\n-                        Set_Next_Entity (New_Formal,\n-                          New_Copy (Old_Formal));\n-                        Next_Entity (New_Formal);\n-                     end loop;\n+                           Extra := New_Formal;\n+                           Next_Formal (Old_Formal);\n+                           exit when No (Old_Formal);\n \n-                     Set_Next_Entity (New_Formal, Empty);\n-                     Set_Last_Entity (Subp_Typ, Extra);\n-                  end if;\n-\n-                  --  Now that the explicit formals have been duplicated,\n-                  --  any extra formals needed by the subprogram must be\n-                  --  created.\n-\n-                  if Present (Extra) then\n-                     Set_Extra_Formal (Extra, Empty);\n-                  end if;\n+                           Set_Next_Entity (New_Formal,\n+                             New_Copy (Old_Formal));\n+                           Next_Entity (New_Formal);\n+                        end loop;\n \n-                  Create_Extra_Formals (Subp_Typ);\n-                  Set_Directly_Designated_Type (Typ, Subp_Typ);\n+                        Set_Next_Entity (New_Formal, Empty);\n+                        Set_Last_Entity (Subp_Typ, Extra);\n+                     end if;\n \n-                  --  Complete decoration of access-to-subprogram itype to\n-                  --  indicate to the backend that this itype corresponds to\n-                  --  a statically allocated dispatch table.\n+                     --  Now that the explicit formals have been duplicated,\n+                     --  any extra formals needed by the subprogram must be\n+                     --  created.\n \n-                  --  ??? more comments on structure here, three level parent\n-                  --  references are worrisome!\n+                     if Present (Extra) then\n+                        Set_Extra_Formal (Extra, Empty);\n+                     end if;\n \n-                  if Nkind (Ref_Object) in N_Has_Entity\n-                    and then Is_Dispatching_Operation (Entity (Ref_Object))\n-                    and then Present (Parent (Parent (N)))\n-                    and then Nkind (Parent (Parent (N))) = N_Aggregate\n-                    and then Present (Parent (Parent (Parent (N))))\n-                  then\n-                     declare\n-                        P    : constant Node_Id :=\n-                                 Parent (Parent (Parent (N)));\n-                        Prim : constant Entity_Id := Entity (Ref_Object);\n-\n-                     begin\n-                        Set_Is_Static_Dispatch_Table_Entity (Typ,\n-                           (Is_Predefined_Dispatching_Operation (Prim)\n-                              and then Nkind (P) = N_Object_Declaration\n-                              and then Is_Static_Dispatch_Table_Entity\n-                                         (Defining_Identifier (P)))\n-                          or else\n-                           (not Is_Predefined_Dispatching_Operation (Prim)\n-                              and then Nkind (P) = N_Aggregate\n-                              and then Present (Parent (P))\n-                              and then Nkind (Parent (P))\n-                                         = N_Object_Declaration\n-                              and then Is_Static_Dispatch_Table_Entity\n-                                         (Defining_Identifier (Parent (P)))));\n-                     end;\n-                  end if;\n-               end;\n+                     Create_Extra_Formals (Subp_Typ);\n+                     Set_Directly_Designated_Type (Typ, Subp_Typ);\n+                  end;\n+               end if;\n             end if;\n \n             if Is_Access_Protected_Subprogram_Type (Btyp) then\n@@ -897,12 +905,12 @@ package body Exp_Attr is\n          if Is_Entity_Name (Pref)\n            and then Is_Task_Type (Entity (Pref))\n          then\n-            Task_Proc := Next_Entity (Root_Type (Etype (Pref)));\n+            Task_Proc := Next_Entity (Root_Type (Ptyp));\n \n             while Present (Task_Proc) loop\n                exit when Ekind (Task_Proc) = E_Procedure\n                  and then Etype (First_Formal (Task_Proc)) =\n-                                  Corresponding_Record_Type (Etype (Pref));\n+                                  Corresponding_Record_Type (Ptyp);\n                Next_Entity (Task_Proc);\n             end loop;\n \n@@ -924,8 +932,8 @@ package body Exp_Attr is\n                 External_Subprogram (Entity (Selector_Name (Pref))), Loc));\n \n          elsif Nkind (Pref) = N_Explicit_Dereference\n-           and then Ekind (Etype (Pref)) = E_Subprogram_Type\n-           and then Convention (Etype (Pref)) = Convention_Protected\n+           and then Ekind (Ptyp) = E_Subprogram_Type\n+           and then Convention (Ptyp) = Convention_Protected\n          then\n             --  The prefix is be a dereference of an access_to_protected_\n             --  subprogram. The desired address is the second component of\n@@ -957,8 +965,8 @@ package body Exp_Attr is\n          --  This processing is not needed in the VM case, where dispatching\n          --  issues are taken care of by the virtual machine.\n \n-         elsif Is_Class_Wide_Type (Etype (Pref))\n-           and then Is_Interface (Etype (Pref))\n+         elsif Is_Class_Wide_Type (Ptyp)\n+           and then Is_Interface (Ptyp)\n            and then VM_Target = No_VM\n            and then not (Nkind (Pref) in N_Has_Entity\n                           and then Is_Subprogram (Entity (Pref)))\n@@ -972,7 +980,8 @@ package body Exp_Attr is\n             return;\n          end if;\n \n-         --  Deal with packed array reference, other cases are handled by gigi\n+         --  Deal with packed array reference, other cases are handled by\n+         --  the back end.\n \n          if Involves_Packed_Array_Reference (Pref) then\n             Expand_Packed_Address_Reference (N);\n@@ -984,7 +993,6 @@ package body Exp_Attr is\n       ---------------\n \n       when Attribute_Alignment => Alignment : declare\n-         Ptyp     : constant Entity_Id := Etype (Pref);\n          New_Node : Node_Id;\n \n       begin\n@@ -1109,9 +1117,9 @@ package body Exp_Attr is\n       -- Bit_Position --\n       ------------------\n \n-      --  We compute this if a component clause was present, otherwise\n-      --  we leave the computation up to Gigi, since we don't know what\n-      --  layout will be chosen.\n+      --  We compute this if a component clause was present, otherwise we leave\n+      --  the computation up to the back end, since we don't know what layout\n+      --  will be chosen.\n \n       --  Note that the attribute can apply to a naked record component\n       --  in generated code (i.e. the prefix is an identifier that\n@@ -1278,9 +1286,9 @@ package body Exp_Attr is\n          --    callable (Task_Id (Pref._disp_get_task_id));\n \n          if Ada_Version >= Ada_05\n-           and then Ekind (Etype (Pref)) = E_Class_Wide_Type\n-           and then Is_Interface (Etype (Pref))\n-           and then Is_Task_Interface (Etype (Pref))\n+           and then Ekind (Ptyp) = E_Class_Wide_Type\n+           and then Is_Interface (Ptyp)\n+           and then Is_Task_Interface (Ptyp)\n          then\n             Rewrite (N,\n               Make_Function_Call (Loc,\n@@ -1343,10 +1351,9 @@ package body Exp_Attr is\n               Unchecked_Convert_To (Id_Kind,\n                 Make_Function_Call (Loc,\n                   Name => Name,\n-                  Parameter_Associations => New_List\n-                    (New_Reference_To (\n-                      Object_Ref\n-                        (Corresponding_Body (Parent (Conctype))), Loc)))));\n+                  Parameter_Associations => New_List (\n+                    New_Reference_To\n+                      (Find_Protection_Object (Current_Scope), Loc)))));\n \n          --  Task case\n \n@@ -1376,8 +1383,8 @@ package body Exp_Attr is\n             Rewrite (N,\n               Unchecked_Convert_To (Id_Kind,\n                 Make_Function_Call (Loc,\n-                  Name => New_Reference_To (\n-                    RTE (RE_Task_Entry_Caller), Loc),\n+                  Name =>\n+                    New_Reference_To (RTE (RE_Task_Entry_Caller), Loc),\n                   Parameter_Associations => New_List (\n                     Make_Integer_Literal (Loc,\n                       Intval => Int (Nest_Depth))))));\n@@ -1408,7 +1415,6 @@ package body Exp_Attr is\n \n       when Attribute_Constrained => Constrained : declare\n          Formal_Ent : constant Entity_Id := Param_Entity (Pref);\n-         Typ        : constant Entity_Id := Etype (Pref);\n \n          function Is_Constrained_Aliased_View (Obj : Node_Id) return Boolean;\n          --  Ada 2005 (AI-363): Returns True if the object name Obj denotes a\n@@ -1427,7 +1433,6 @@ package body Exp_Attr is\n \n                if Present (Renamed_Object (E)) then\n                   return Is_Constrained_Aliased_View (Renamed_Object (E));\n-\n                else\n                   return Is_Aliased (E) and then Is_Constrained (Etype (E));\n                end if;\n@@ -1503,8 +1508,8 @@ package body Exp_Attr is\n                   end if;\n \n                --  If the prefix is not a variable or is aliased, then\n-               --  definitely true; if it's a formal parameter without\n-               --  an associated extra formal, then treat it as constrained.\n+               --  definitely true; if it's a formal parameter without an\n+               --  associated extra formal, then treat it as constrained.\n \n                --  Ada 2005 (AI-363): An aliased prefix must be known to be\n                --  constrained in order to set the attribute to True.\n@@ -1518,10 +1523,9 @@ package body Exp_Attr is\n                then\n                   Res := True;\n \n-               --  Variable case, just look at type to see if it is\n-               --  constrained. Note that the one case where this is\n-               --  not accurate (the procedure formal case), has been\n-               --  handled above.\n+               --  Variable case, look at type to see if it is constrained.\n+               --  Note that the one case where this is not accurate (the\n+               --  procedure formal case), has been handled above.\n \n                --  We use the Underlying_Type here (and below) in case the\n                --  type is private without discriminants, but the full type\n@@ -1536,11 +1540,10 @@ package body Exp_Attr is\n                  New_Reference_To (Boolean_Literals (Res), Loc));\n             end;\n \n-         --  Prefix is not an entity name. These are also cases where\n-         --  we can always tell at compile time by looking at the form\n-         --  and type of the prefix. If an explicit dereference of an\n-         --  object with constrained partial view, this is unconstrained\n-         --  (Ada 2005 AI-363).\n+         --  Prefix is not an entity name. These are also cases where we can\n+         --  always tell at compile time by looking at the form and type of the\n+         --  prefix. If an explicit dereference of an object with constrained\n+         --  partial view, this is unconstrained (Ada 2005 AI-363).\n \n          else\n             Rewrite (N,\n@@ -1550,8 +1553,8 @@ package body Exp_Attr is\n                     or else\n                      (Nkind (Pref) = N_Explicit_Dereference\n                         and then\n-                          not Has_Constrained_Partial_View (Base_Type (Typ)))\n-                    or else Is_Constrained (Underlying_Type (Typ))),\n+                          not Has_Constrained_Partial_View (Base_Type (Ptyp)))\n+                    or else Is_Constrained (Underlying_Type (Ptyp))),\n                 Loc));\n          end if;\n \n@@ -1574,13 +1577,13 @@ package body Exp_Attr is\n \n       --  Transforms 'Count attribute into a call to the Count function\n \n-      when Attribute_Count => Count :\n-      declare\n-         Entnam  : Node_Id;\n-         Index   : Node_Id;\n-         Name    : Node_Id;\n-         Call    : Node_Id;\n-         Conctyp : Entity_Id;\n+      when Attribute_Count => Count : declare\n+         Call     : Node_Id;\n+         Conctyp  : Entity_Id;\n+         Entnam   : Node_Id;\n+         Entry_Id : Entity_Id;\n+         Index    : Node_Id;\n+         Name     : Node_Id;\n \n       begin\n          --  If the prefix is a member of an entry family, retrieve both\n@@ -1594,6 +1597,8 @@ package body Exp_Attr is\n             Index := Empty;\n          end if;\n \n+         Entry_Id := Entity (Entnam);\n+\n          --  Find the concurrent type in which this attribute is referenced\n          --  (there had better be one).\n \n@@ -1605,7 +1610,6 @@ package body Exp_Attr is\n          --  Protected case\n \n          if Is_Protected_Type (Conctyp) then\n-\n             case Corresponding_Runtime_Package (Conctyp) is\n                when System_Tasking_Protected_Objects_Entries =>\n                   Name := New_Reference_To (RTE (RE_Protected_Count), Loc);\n@@ -1614,26 +1618,24 @@ package body Exp_Attr is\n                     Make_Function_Call (Loc,\n                       Name => Name,\n                       Parameter_Associations => New_List (\n-                        New_Reference_To (\n-                          Object_Ref (\n-                            Corresponding_Body (Parent (Conctyp))), Loc),\n-                        Entry_Index_Expression (Loc,\n-                          Entity (Entnam), Index, Scope (Entity (Entnam)))));\n+                        New_Reference_To\n+                          (Find_Protection_Object (Current_Scope), Loc),\n+                        Entry_Index_Expression\n+                          (Loc, Entry_Id, Index, Scope (Entry_Id))));\n \n                when System_Tasking_Protected_Objects_Single_Entry =>\n-                  Name := New_Reference_To\n-                           (RTE (RE_Protected_Count_Entry), Loc);\n+                  Name :=\n+                    New_Reference_To (RTE (RE_Protected_Count_Entry), Loc);\n \n                   Call :=\n                     Make_Function_Call (Loc,\n                       Name => Name,\n                       Parameter_Associations => New_List (\n-                        New_Reference_To (\n-                          Object_Ref (\n-                            Corresponding_Body (Parent (Conctyp))), Loc)));\n+                        New_Reference_To\n+                          (Find_Protection_Object (Current_Scope), Loc)));\n+\n                when others =>\n                   raise Program_Error;\n-\n             end case;\n \n          --  Task case\n@@ -1643,8 +1645,8 @@ package body Exp_Attr is\n               Make_Function_Call (Loc,\n                 Name => New_Reference_To (RTE (RE_Task_Count), Loc),\n                 Parameter_Associations => New_List (\n-                  Entry_Index_Expression\n-                    (Loc, Entity (Entnam), Index, Scope (Entity (Entnam)))));\n+                  Entry_Index_Expression (Loc,\n+                    Entry_Id, Index, Scope (Entry_Id))));\n          end if;\n \n          --  The call returns type Natural but the context is universal integer\n@@ -1774,11 +1776,11 @@ package body Exp_Attr is\n       -- Elaborated --\n       ----------------\n \n-      --  Elaborated is always True for preelaborated units, predefined\n-      --  units, pure units and units which have Elaborate_Body pragmas.\n-      --  These units have no elaboration entity.\n+      --  Elaborated is always True for preelaborated units, predefined units,\n+      --  pure units and units which have Elaborate_Body pragmas. These units\n+      --  have no elaboration entity.\n \n-      --  Note: The Elaborated attribute is never passed through to Gigi\n+      --  Note: The Elaborated attribute is never passed to the back end\n \n       when Attribute_Elaborated => Elaborated : declare\n          Ent : constant Entity_Id := Entity (Pref);\n@@ -1802,12 +1804,12 @@ package body Exp_Attr is\n \n          --    target-type (Y)\n \n-         --  This is simply a direct conversion from the enumeration type\n-         --  to the target integer type, which is treated by Gigi as a normal\n-         --  integer conversion, treating the enumeration type as an integer,\n-         --  which is exactly what we want! We set Conversion_OK to make sure\n-         --  that the analyzer does not complain about what otherwise might\n-         --  be an illegal conversion.\n+         --  This is simply a direct conversion from the enumeration type to\n+         --  the target integer type, which is treated by the back end as a\n+         --  normal integer conversion, treating the enumeration type as an\n+         --  integer, which is exactly what we want! We set Conversion_OK to\n+         --  make sure that the analyzer does not complain about what otherwise\n+         --  might be an illegal conversion.\n \n          if Is_Non_Empty_List (Exprs) then\n             Rewrite (N,\n@@ -1843,9 +1845,43 @@ package body Exp_Attr is\n \n          Set_Etype (N, Typ);\n          Analyze_And_Resolve (N, Typ);\n-\n       end Enum_Rep;\n \n+      --------------\n+      -- Enum_Val --\n+      --------------\n+\n+      when Attribute_Enum_Val => Enum_Val : declare\n+         Expr : Node_Id;\n+         Btyp : constant Entity_Id  := Base_Type (Ptyp);\n+\n+      begin\n+         --  X'Enum_Val (Y) expands to\n+\n+         --    [constraint_error when _rep_to_pos (Y, False) = -1, msg]\n+         --    X!(Y);\n+\n+         Expr := Unchecked_Convert_To (Ptyp, First (Exprs));\n+\n+         Insert_Action (N,\n+           Make_Raise_Constraint_Error (Loc,\n+             Condition =>\n+               Make_Op_Eq (Loc,\n+                 Left_Opnd =>\n+                   Make_Function_Call (Loc,\n+                     Name =>\n+                       New_Reference_To (TSS (Btyp, TSS_Rep_To_Pos), Loc),\n+                     Parameter_Associations => New_List (\n+                       Relocate_Node (Duplicate_Subexpr (Expr)),\n+                         New_Occurrence_Of (Standard_False, Loc))),\n+\n+                 Right_Opnd => Make_Integer_Literal (Loc, -1)),\n+             Reason => CE_Range_Check_Failed));\n+\n+         Rewrite (N, Expr);\n+         Analyze_And_Resolve (N, Ptyp);\n+      end Enum_Val;\n+\n       --------------\n       -- Exponent --\n       --------------\n@@ -1879,15 +1915,13 @@ package body Exp_Attr is\n       -- First --\n       -----------\n \n-      when Attribute_First => declare\n-         Ptyp : constant Entity_Id := Etype (Pref);\n+      when Attribute_First =>\n \n-      begin\n          --  If the prefix type is a constrained packed array type which\n          --  already has a Packed_Array_Type representation defined, then\n          --  replace this attribute with a direct reference to 'First of the\n-         --  appropriate index subtype (since otherwise Gigi will try to give\n-         --  us the value of 'First for this implementation type).\n+         --  appropriate index subtype (since otherwise the back end will try\n+         --  to give us the value of 'First for this implementation type).\n \n          if Is_Constrained_Packed_Array (Ptyp) then\n             Rewrite (N,\n@@ -1899,18 +1933,16 @@ package body Exp_Attr is\n          elsif Is_Access_Type (Ptyp) then\n             Apply_Access_Check (N);\n          end if;\n-      end;\n \n       ---------------\n       -- First_Bit --\n       ---------------\n \n-      --  We compute this if a component clause was present, otherwise\n-      --  we leave the computation up to Gigi, since we don't know what\n+      --  Compute this if component clause was present, otherwise we leave the\n+      --  computation to be completed in the back-end, since we don't know what\n       --  layout will be chosen.\n \n-      when Attribute_First_Bit => First_Bit :\n-      declare\n+      when Attribute_First_Bit => First_Bit : declare\n          CE : constant Entity_Id := Entity (Selector_Name (Pref));\n \n       begin\n@@ -1938,10 +1970,10 @@ package body Exp_Attr is\n \n       --     fixtype(integer-value)\n \n-      --  we do all the required analysis of the conversion here, because\n-      --  we do not want this to go through the fixed-point conversion\n-      --  circuits. Note that gigi always treats fixed-point as equivalent\n-      --  to the corresponding integer type anyway.\n+      --  We do all the required analysis of the conversion here, because we do\n+      --  not want this to go through the fixed-point conversion circuits. Note\n+      --  that the back end always treats fixed-point as equivalent to the\n+      --  corresponding integer type anyway.\n \n       when Attribute_Fixed_Value => Fixed_Value :\n       begin\n@@ -1985,11 +2017,7 @@ package body Exp_Attr is\n       --  Note that we know that the type is a non-static subtype, or Fore\n       --  would have itself been computed dynamically in Eval_Attribute.\n \n-      when Attribute_Fore => Fore :\n-      declare\n-         Ptyp : constant Entity_Id := Etype (Pref);\n-\n-      begin\n+      when Attribute_Fore => Fore : begin\n          Rewrite (N,\n            Convert_To (Typ,\n              Make_Function_Call (Loc,\n@@ -2037,7 +2065,7 @@ package body Exp_Attr is\n          Id_Kind : Entity_Id;\n \n       begin\n-         if Etype (Pref) = Standard_Exception_Type then\n+         if Ptyp = Standard_Exception_Type then\n             Id_Kind := RTE (RE_Exception_Id);\n \n             if Present (Renamed_Object (Entity (Pref))) then\n@@ -2054,9 +2082,9 @@ package body Exp_Attr is\n             --  attributes applied to interfaces.\n \n             if Ada_Version >= Ada_05\n-              and then Ekind (Etype (Pref)) = E_Class_Wide_Type\n-              and then Is_Interface (Etype (Pref))\n-              and then Is_Task_Interface (Etype (Pref))\n+              and then Ekind (Ptyp) = E_Class_Wide_Type\n+              and then Is_Interface (Ptyp)\n+              and then Is_Task_Interface (Ptyp)\n             then\n                Rewrite (N,\n                  Unchecked_Convert_To (Id_Kind,\n@@ -2094,7 +2122,7 @@ package body Exp_Attr is\n       begin\n          Rewrite (N,\n            Make_Attribute_Reference (Loc,\n-             Prefix => New_Reference_To (Etype (Pref), Loc),\n+             Prefix => New_Reference_To (Ptyp, Loc),\n              Attribute_Name => Name_Image,\n              Expressions => New_List (Relocate_Node (Pref))));\n \n@@ -2184,10 +2212,9 @@ package body Exp_Attr is\n \n             --     sourcetyp (streamread (strmtyp'Input (stream)));\n \n-            --  where stmrearead is the given Read function that converts\n-            --  an argument of type strmtyp to type sourcetyp or a type\n-            --  from which it is derived. The extra conversion is required\n-            --  for the derived case.\n+            --  where stmrearead is the given Read function that converts an\n+            --  argument of type strmtyp to type sourcetyp or a type from which\n+            --  it is derived (extra conversion required for the derived case).\n \n             Prag := Get_Stream_Convert_Pragma (P_Type);\n \n@@ -2322,10 +2349,9 @@ package body Exp_Attr is\n                pragma Assert\n                  (Is_Record_Type (U_Type) or else Is_Protected_Type (U_Type));\n \n-               --  Ada 2005 (AI-216): Program_Error is raised when executing\n-               --  the default implementation of the Input attribute of an\n-               --  unchecked union type if the type lacks default discriminant\n-               --  values.\n+               --  Ada 2005 (AI-216): Program_Error is raised executing default\n+               --  implementation of the Input attribute of an unchecked union\n+               --  type if the type lacks default discriminant values.\n \n                if Is_Unchecked_Union (Base_Type (U_Type))\n                  and then No (Discriminant_Constraint (U_Type))\n@@ -2400,10 +2426,10 @@ package body Exp_Attr is\n \n       --    inttype(integer-value))\n \n-      --  we do all the required analysis of the conversion here, because\n-      --  we do not want this to go through the fixed-point conversion\n-      --  circuits. Note that gigi always treats fixed-point as equivalent\n-      --  to the corresponding integer type anyway.\n+      --  we do all the required analysis of the conversion here, because we do\n+      --  not want this to go through the fixed-point conversion circuits. Note\n+      --  that the back end always treats fixed-point as equivalent to the\n+      --  corresponding integer type anyway.\n \n       when Attribute_Integer_Value => Integer_Value :\n       begin\n@@ -2421,19 +2447,24 @@ package body Exp_Attr is\n          Apply_Type_Conversion_Checks (N);\n       end Integer_Value;\n \n+      -------------------\n+      -- Invalid_Value --\n+      -------------------\n+\n+      when Attribute_Invalid_Value =>\n+         Rewrite (N, Get_Simple_Init_Val (Ptyp, N));\n+\n       ----------\n       -- Last --\n       ----------\n \n-      when Attribute_Last => declare\n-         Ptyp : constant Entity_Id := Etype (Pref);\n+      when Attribute_Last =>\n \n-      begin\n          --  If the prefix type is a constrained packed array type which\n          --  already has a Packed_Array_Type representation defined, then\n          --  replace this attribute with a direct reference to 'Last of the\n-         --  appropriate index subtype (since otherwise Gigi will try to give\n-         --  us the value of 'Last for this implementation type).\n+         --  appropriate index subtype (since otherwise the back end will try\n+         --  to give us the value of 'Last for this implementation type).\n \n          if Is_Constrained_Packed_Array (Ptyp) then\n             Rewrite (N,\n@@ -2445,18 +2476,16 @@ package body Exp_Attr is\n          elsif Is_Access_Type (Ptyp) then\n             Apply_Access_Check (N);\n          end if;\n-      end;\n \n       --------------\n       -- Last_Bit --\n       --------------\n \n-      --  We compute this if a component clause was present, otherwise\n-      --  we leave the computation up to Gigi, since we don't know what\n-      --  layout will be chosen.\n+      --  We compute this if a component clause was present, otherwise we leave\n+      --  the computation up to the back end, since we don't know what layout\n+      --  will be chosen.\n \n-      when Attribute_Last_Bit => Last_Bit :\n-      declare\n+      when Attribute_Last_Bit => Last_Bit : declare\n          CE : constant Entity_Id := Entity (Selector_Name (Pref));\n \n       begin\n@@ -2482,7 +2511,7 @@ package body Exp_Attr is\n       --  Transforms 'Leading_Part into a call to the floating-point attribute\n       --  function Leading_Part in Fat_xxx (where xxx is the root type)\n \n-      --  Note: strictly, we should have special case code to deal with\n+      --  Note: strictly, we should generate special case code to deal with\n       --  absurdly large positive arguments (greater than Integer'Last), which\n       --  result in returning the first argument unchanged, but it hardly seems\n       --  worth the effort. We raise constraint error for absurdly negative\n@@ -2496,7 +2525,6 @@ package body Exp_Attr is\n       ------------\n \n       when Attribute_Length => declare\n-         Ptyp : constant Entity_Id := Etype (Pref);\n          Ityp : Entity_Id;\n          Xnum : Uint;\n \n@@ -2506,15 +2534,15 @@ package body Exp_Attr is\n          if Is_Array_Type (Ptyp) and then Is_Packed (Ptyp) then\n             Ityp := Get_Index_Subtype (N);\n \n-            --  If the index type, Ityp, is an enumeration type with\n-            --  holes, then we calculate X'Length explicitly using\n+            --  If the index type, Ityp, is an enumeration type with holes,\n+            --  then we calculate X'Length explicitly using\n \n             --     Typ'Max\n             --       (0, Ityp'Pos (X'Last  (N)) -\n             --           Ityp'Pos (X'First (N)) + 1);\n \n-            --  Since the bounds in the template are the representation\n-            --  values and gigi would get the wrong value.\n+            --  Since the bounds in the template are the representation values\n+            --  and the back end would get the wrong value.\n \n             if Is_Enumeration_Type (Ityp)\n               and then Present (Enum_Pos_To_Rep (Base_Type (Ityp)))\n@@ -2568,8 +2596,9 @@ package body Exp_Attr is\n             --  If the prefix type is a constrained packed array type which\n             --  already has a Packed_Array_Type representation defined, then\n             --  replace this attribute with a direct reference to 'Range_Length\n-            --  of the appropriate index subtype (since otherwise Gigi will try\n-            --  to give us the value of 'Length for this implementation type).\n+            --  of the appropriate index subtype (since otherwise the back end\n+            --  will try to give us the value of 'Length for this\n+            --  implementation type).\n \n             elsif Is_Constrained (Ptyp) then\n                Rewrite (N,\n@@ -2579,23 +2608,21 @@ package body Exp_Attr is\n                Analyze_And_Resolve (N, Typ);\n             end if;\n \n-         --  If we have a packed array that is not bit packed, which was\n-\n          --  Access type case\n \n          elsif Is_Access_Type (Ptyp) then\n             Apply_Access_Check (N);\n \n-            --  If the designated type is a packed array type, then we\n-            --  convert the reference to:\n+            --  If the designated type is a packed array type, then we convert\n+            --  the reference to:\n \n             --    typ'Max (0, 1 +\n             --                xtyp'Pos (Pref'Last (Expr)) -\n             --                xtyp'Pos (Pref'First (Expr)));\n \n-            --  This is a bit complex, but it is the easiest thing to do\n-            --  that works in all cases including enum types with holes\n-            --  xtyp here is the appropriate index type.\n+            --  This is a bit complex, but it is the easiest thing to do that\n+            --  works in all cases including enum types with holes xtyp here\n+            --  is the appropriate index type.\n \n             declare\n                Dtyp : constant Entity_Id := Designated_Type (Ptyp);\n@@ -2642,7 +2669,7 @@ package body Exp_Attr is\n                end if;\n             end;\n \n-         --  Otherwise leave it to gigi\n+         --  Otherwise leave it to the back end\n \n          else\n             Apply_Universal_Integer_Attribute_Checks (N);\n@@ -2678,7 +2705,7 @@ package body Exp_Attr is\n       ------------------\n \n       --  Machine_Size is equivalent to Object_Size, so transform it into\n-      --  Object_Size and that way Gigi never sees Machine_Size.\n+      --  Object_Size and that way the back end never sees Machine_Size.\n \n       when Attribute_Machine_Size =>\n          Rewrite (N,\n@@ -2693,8 +2720,8 @@ package body Exp_Attr is\n       --------------\n \n       --  The only case that can get this far is the dynamic case of the old\n-      --  Ada 83 Mantissa attribute for the fixed-point case. For this case, we\n-      --  expand:\n+      --  Ada 83 Mantissa attribute for the fixed-point case. For this case,\n+      --  we expand:\n \n       --    typ'Mantissa\n \n@@ -2704,10 +2731,7 @@ package body Exp_Attr is\n       --           (Integer'Integer_Value (typ'First),\n       --            Integer'Integer_Value (typ'Last)));\n \n-      when Attribute_Mantissa => Mantissa : declare\n-         Ptyp : constant Entity_Id := Etype (Pref);\n-\n-      begin\n+      when Attribute_Mantissa => Mantissa : begin\n          Rewrite (N,\n            Convert_To (Typ,\n              Make_Function_Call (Loc,\n@@ -2860,12 +2884,17 @@ package body Exp_Attr is\n          Asn_Stm : Node_Id;\n \n       begin\n+         --  Find the nearest subprogram body, ignoring _Preconditions\n+\n          Subp := N;\n          loop\n             Subp := Parent (Subp);\n-            exit when Nkind (Subp) = N_Subprogram_Body;\n+            exit when Nkind (Subp) = N_Subprogram_Body\n+              and then Chars (Defining_Entity (Subp)) /= Name_uPostconditions;\n          end loop;\n \n+         --  Insert the assignment at the start of the declarations\n+\n          Asn_Stm :=\n            Make_Object_Declaration (Loc,\n              Defining_Identifier => Tnn,\n@@ -3098,7 +3127,7 @@ package body Exp_Attr is\n       ---------\n \n       --  For enumeration types with a standard representation, Pos is\n-      --  handled by Gigi.\n+      --  handled by the back end.\n \n       --  For enumeration types, with a non-standard representation we\n       --  generate a call to the _Rep_To_Pos function created when the\n@@ -3162,9 +3191,9 @@ package body Exp_Attr is\n       -- Position --\n       --------------\n \n-      --  We compute this if a component clause was present, otherwise\n-      --  we leave the computation up to Gigi, since we don't know what\n-      --  layout will be chosen.\n+      --  We compute this if a component clause was present, otherwise we leave\n+      --  the computation up to the back end, since we don't know what layout\n+      --  will be chosen.\n \n       when Attribute_Position => Position :\n       declare\n@@ -3192,21 +3221,25 @@ package body Exp_Attr is\n \n       when Attribute_Pred => Pred :\n       declare\n-         Ptyp : constant Entity_Id := Base_Type (Etype (Pref));\n+         Etyp : constant Entity_Id := Base_Type (Ptyp);\n \n       begin\n+\n          --  For enumeration types with non-standard representations, we\n          --  expand typ'Pred (x) into\n \n          --    Pos_To_Rep (Rep_To_Pos (x) - 1)\n \n          --    If the representation is contiguous, we compute instead\n          --    Lit1 + Rep_to_Pos (x -1), to catch invalid representations.\n+         --    The conversion function Enum_Pos_To_Rep is defined on the\n+         --    base type, not the subtype, so we have to use the base type\n+         --    explicitly for this and other enumeration attributes.\n \n          if Is_Enumeration_Type (Ptyp)\n-           and then Present (Enum_Pos_To_Rep (Ptyp))\n+           and then Present (Enum_Pos_To_Rep (Etyp))\n          then\n-            if Has_Contiguous_Rep (Ptyp) then\n+            if Has_Contiguous_Rep (Etyp) then\n                Rewrite (N,\n                   Unchecked_Convert_To (Ptyp,\n                      Make_Op_Add (Loc,\n@@ -3217,7 +3250,7 @@ package body Exp_Attr is\n                           Make_Function_Call (Loc,\n                             Name =>\n                               New_Reference_To\n-                               (TSS (Ptyp, TSS_Rep_To_Pos), Loc),\n+                               (TSS (Etyp, TSS_Rep_To_Pos), Loc),\n \n                             Parameter_Associations =>\n                               New_List (\n@@ -3238,13 +3271,16 @@ package body Exp_Attr is\n                Append_To (Exprs, Rep_To_Pos_Flag (Ptyp, Loc));\n                Rewrite (N,\n                  Make_Indexed_Component (Loc,\n-                   Prefix => New_Reference_To (Enum_Pos_To_Rep (Ptyp), Loc),\n+                   Prefix =>\n+                     New_Reference_To\n+                       (Enum_Pos_To_Rep (Etyp), Loc),\n                    Expressions => New_List (\n                      Make_Op_Subtract (Loc,\n                     Left_Opnd =>\n                       Make_Function_Call (Loc,\n                         Name =>\n-                          New_Reference_To (TSS (Ptyp, TSS_Rep_To_Pos), Loc),\n+                          New_Reference_To\n+                            (TSS (Etyp, TSS_Rep_To_Pos), Loc),\n                           Parameter_Associations => Exprs),\n                     Right_Opnd => Make_Integer_Literal (Loc, 1)))));\n             end if;\n@@ -3333,8 +3369,6 @@ package body Exp_Attr is\n \n                   New_Itype := Create_Itype (E_Access_Type, N);\n                   Set_Etype (New_Itype, New_Itype);\n-                  Init_Esize (New_Itype);\n-                  Init_Size_Align (New_Itype);\n                   Set_Directly_Designated_Type (New_Itype,\n                     Corresponding_Record_Type (Conctyp));\n                   Freeze_Itype (New_Itype, N);\n@@ -3400,10 +3434,7 @@ package body Exp_Attr is\n       -- Range_Length --\n       ------------------\n \n-      when Attribute_Range_Length => Range_Length : declare\n-         P_Type : constant Entity_Id := Etype (Pref);\n-\n-      begin\n+      when Attribute_Range_Length => Range_Length : begin\n          --  The only special processing required is for the case where\n          --  Range_Length is applied to an enumeration type with holes.\n          --  In this case we transform\n@@ -3417,8 +3448,8 @@ package body Exp_Attr is\n          --  So that the result reflects the proper Pos values instead\n          --  of the underlying representations.\n \n-         if Is_Enumeration_Type (P_Type)\n-           and then Has_Non_Standard_Rep (P_Type)\n+         if Is_Enumeration_Type (Ptyp)\n+           and then Has_Non_Standard_Rep (Ptyp)\n          then\n             Rewrite (N,\n               Make_Op_Add (Loc,\n@@ -3427,28 +3458,29 @@ package body Exp_Attr is\n                     Left_Opnd =>\n                       Make_Attribute_Reference (Loc,\n                         Attribute_Name => Name_Pos,\n-                        Prefix => New_Occurrence_Of (P_Type, Loc),\n+                        Prefix => New_Occurrence_Of (Ptyp, Loc),\n                         Expressions => New_List (\n                           Make_Attribute_Reference (Loc,\n                             Attribute_Name => Name_Last,\n-                            Prefix => New_Occurrence_Of (P_Type, Loc)))),\n+                            Prefix => New_Occurrence_Of (Ptyp, Loc)))),\n \n                     Right_Opnd =>\n                       Make_Attribute_Reference (Loc,\n                         Attribute_Name => Name_Pos,\n-                        Prefix => New_Occurrence_Of (P_Type, Loc),\n+                        Prefix => New_Occurrence_Of (Ptyp, Loc),\n                         Expressions => New_List (\n                           Make_Attribute_Reference (Loc,\n                             Attribute_Name => Name_First,\n-                            Prefix => New_Occurrence_Of (P_Type, Loc))))),\n+                            Prefix => New_Occurrence_Of (Ptyp, Loc))))),\n \n                 Right_Opnd =>\n                   Make_Integer_Literal (Loc, 1)));\n \n             Analyze_And_Resolve (N, Typ);\n \n-         --  For all other cases, attribute is handled by Gigi, but we need\n-         --  to deal with the case of the range check on a universal integer.\n+         --  For all other cases, the attribute is handled by the back end, but\n+         --  we need to deal with the case of the range check on a universal\n+         --  integer.\n \n          else\n             Apply_Universal_Integer_Attribute_Checks (N);\n@@ -3631,6 +3663,20 @@ package body Exp_Attr is\n       when Attribute_Remainder =>\n          Expand_Fpt_Attribute_RR (N);\n \n+      ------------\n+      -- Result --\n+      ------------\n+\n+      --  Transform 'Result into reference to _Result formal. At the point\n+      --  where a legal 'Result attribute is expanded, we know that we are in\n+      --  the context of a _Postcondition function with a _Result parameter.\n+\n+      when Attribute_Result =>\n+         Rewrite (N,\n+           Make_Identifier (Loc,\n+            Chars => Name_uResult));\n+         Analyze_And_Resolve (N, Typ);\n+\n       -----------\n       -- Round --\n       -----------\n@@ -3705,7 +3751,6 @@ package body Exp_Attr is\n            Attribute_VADS_Size   => Size :\n \n       declare\n-         Ptyp     : constant Entity_Id := Etype (Pref);\n          Siz      : Uint;\n          New_Node : Node_Id;\n \n@@ -3751,19 +3796,16 @@ package body Exp_Attr is\n             else\n                if (not Is_Entity_Name (Pref)\n                     or else not Is_Type (Entity (Pref)))\n-                 and then (Is_Scalar_Type (Etype (Pref))\n-                            or else Is_Constrained (Etype (Pref)))\n+                 and then (Is_Scalar_Type (Ptyp) or else Is_Constrained (Ptyp))\n                then\n-                  Rewrite (Pref, New_Occurrence_Of (Etype (Pref), Loc));\n+                  Rewrite (Pref, New_Occurrence_Of (Ptyp, Loc));\n                end if;\n \n                --  For a scalar type for which no size was explicitly given,\n                --  VADS_Size means Object_Size. This is the other respect in\n                --  which VADS_Size differs from Size.\n \n-               if Is_Scalar_Type (Etype (Pref))\n-                 and then No (Size_Clause (Etype (Pref)))\n-               then\n+               if Is_Scalar_Type (Ptyp) and then No (Size_Clause (Ptyp)) then\n                   Set_Attribute_Name (N, Name_Object_Size);\n \n                --  In all other cases, Size and VADS_Size are the sane\n@@ -3774,9 +3816,9 @@ package body Exp_Attr is\n             end if;\n          end if;\n \n-         --  For class-wide types,  X'Class'Size is transformed into a\n-         --  direct reference to the Size of the class type, so that gigi\n-         --  does not have to deal with the X'Class'Size reference.\n+         --  For class-wide types, X'Class'Size is transformed into a direct\n+         --  reference to the Size of the class type, so that the back end does\n+         --  not have to deal with the X'Class'Size reference.\n \n          if Is_Entity_Name (Pref)\n            and then Is_Class_Wide_Type (Entity (Pref))\n@@ -3873,7 +3915,7 @@ package body Exp_Attr is\n                end if;\n             end;\n \n-         --  All other cases are handled by Gigi\n+         --  All other cases are handled by the back end\n \n          else\n             Apply_Universal_Integer_Attribute_Checks (N);\n@@ -3883,8 +3925,8 @@ package body Exp_Attr is\n \n             if Is_Entity_Name (Pref)\n               and then Is_Formal (Entity (Pref))\n-              and then Is_Array_Type (Etype (Pref))\n-              and then Is_Packed (Etype (Pref))\n+              and then Is_Array_Type (Ptyp)\n+              and then Is_Packed (Ptyp)\n             then\n                Rewrite (N,\n                  Make_Attribute_Reference (Loc,\n@@ -3895,13 +3937,13 @@ package body Exp_Attr is\n             end if;\n \n             --  If Size applies to a dereference of an access to unconstrained\n-            --  packed array, GIGI needs to see its unconstrained nominal type,\n-            --  but also a hint to the actual constrained type.\n+            --  packed array, the back end needs to see its unconstrained\n+            --  nominal type, but also a hint to the actual constrained type.\n \n             if Nkind (Pref) = N_Explicit_Dereference\n-              and then Is_Array_Type (Etype (Pref))\n-              and then not Is_Constrained (Etype (Pref))\n-              and then Is_Packed (Etype (Pref))\n+              and then Is_Array_Type (Ptyp)\n+              and then not Is_Constrained (Ptyp)\n+              and then Is_Packed (Ptyp)\n             then\n                Set_Actual_Designated_Subtype (Pref,\n                  Get_Actual_Subtype (Pref));\n@@ -3954,11 +3996,8 @@ package body Exp_Attr is\n       -- Storage_Size --\n       ------------------\n \n-      when Attribute_Storage_Size => Storage_Size :\n-      declare\n-         Ptyp : constant Entity_Id := Etype (Pref);\n+      when Attribute_Storage_Size => Storage_Size : begin\n \n-      begin\n          --  Access type case, always go to the root type\n \n          --  The case of access types results in a value of zero for the case\n@@ -4086,7 +4125,6 @@ package body Exp_Attr is\n       -----------------\n \n       when Attribute_Stream_Size => Stream_Size : declare\n-         Ptyp : constant Entity_Id := Etype (Pref);\n          Size : Int;\n \n       begin\n@@ -4115,9 +4153,10 @@ package body Exp_Attr is\n \n       when Attribute_Succ => Succ :\n       declare\n-         Ptyp : constant Entity_Id := Base_Type (Etype (Pref));\n+         Etyp : constant Entity_Id := Base_Type (Ptyp);\n \n       begin\n+\n          --  For enumeration types with non-standard representations, we\n          --  expand typ'Succ (x) into\n \n@@ -4127,9 +4166,9 @@ package body Exp_Attr is\n          --    Lit1 + Rep_to_Pos (x+1), to catch invalid representations.\n \n          if Is_Enumeration_Type (Ptyp)\n-           and then Present (Enum_Pos_To_Rep (Ptyp))\n+           and then Present (Enum_Pos_To_Rep (Etyp))\n          then\n-            if Has_Contiguous_Rep (Ptyp) then\n+            if Has_Contiguous_Rep (Etyp) then\n                Rewrite (N,\n                   Unchecked_Convert_To (Ptyp,\n                      Make_Op_Add (Loc,\n@@ -4140,7 +4179,7 @@ package body Exp_Attr is\n                           Make_Function_Call (Loc,\n                             Name =>\n                               New_Reference_To\n-                               (TSS (Ptyp, TSS_Rep_To_Pos), Loc),\n+                               (TSS (Etyp, TSS_Rep_To_Pos), Loc),\n \n                             Parameter_Associations =>\n                               New_List (\n@@ -4160,14 +4199,16 @@ package body Exp_Attr is\n                Append_To (Exprs, Rep_To_Pos_Flag (Ptyp, Loc));\n                Rewrite (N,\n                  Make_Indexed_Component (Loc,\n-                   Prefix => New_Reference_To (Enum_Pos_To_Rep (Ptyp), Loc),\n+                   Prefix =>\n+                     New_Reference_To\n+                       (Enum_Pos_To_Rep (Etyp), Loc),\n                    Expressions => New_List (\n                      Make_Op_Add (Loc,\n                        Left_Opnd =>\n                          Make_Function_Call (Loc,\n                            Name =>\n                              New_Reference_To\n-                               (TSS (Ptyp, TSS_Rep_To_Pos), Loc),\n+                               (TSS (Etyp, TSS_Rep_To_Pos), Loc),\n                            Parameter_Associations => Exprs),\n                        Right_Opnd => Make_Integer_Literal (Loc, 1)))));\n             end if;\n@@ -4210,7 +4251,7 @@ package body Exp_Attr is\n             Ttyp := Entity (Pref);\n             Prefix_Is_Type := True;\n          else\n-            Ttyp := Etype (Pref);\n+            Ttyp := Ptyp;\n             Prefix_Is_Type := False;\n          end if;\n \n@@ -4284,9 +4325,9 @@ package body Exp_Attr is\n          --    terminated (Task_Id (Pref._disp_get_task_id));\n \n          if Ada_Version >= Ada_05\n-           and then Ekind (Etype (Pref)) = E_Class_Wide_Type\n-           and then Is_Interface (Etype (Pref))\n-           and then Is_Task_Interface (Etype (Pref))\n+           and then Ekind (Ptyp) = E_Class_Wide_Type\n+           and then Is_Interface (Ptyp)\n+           and then Is_Task_Interface (Ptyp)\n          then\n             Rewrite (N,\n               Make_Function_Call (Loc,\n@@ -4410,8 +4451,8 @@ package body Exp_Attr is\n       ---------\n \n       --  For enumeration types with a standard representation, and for all\n-      --  other types, Val is handled by Gigi. For enumeration types with\n-      --  a non-standard representation we use the _Pos_To_Rep array that\n+      --  other types, Val is handled by the back end. For enumeration types\n+      --  with a non-standard representation we use the _Pos_To_Rep array that\n       --  was created when the type was frozen.\n \n       when Attribute_Val => Val :\n@@ -4473,8 +4514,7 @@ package body Exp_Attr is\n \n       when Attribute_Valid => Valid :\n       declare\n-         Ptyp : constant Entity_Id  := Etype (Pref);\n-         Btyp : Entity_Id           := Base_Type (Ptyp);\n+         Btyp : Entity_Id := Base_Type (Ptyp);\n          Tst  : Node_Id;\n \n          Save_Validity_Checks_On : constant Boolean := Validity_Checks_On;\n@@ -4555,7 +4595,7 @@ package body Exp_Attr is\n                --  Non VAX float case\n \n                else\n-                  Find_Fat_Info (Etype (Pref), Ftp, Pkg);\n+                  Find_Fat_Info (Ptyp, Ftp, Pkg);\n \n                   --  If the floating-point object might be unaligned, we need\n                   --  to call the special routine Unaligned_Valid, which makes\n@@ -5029,11 +5069,11 @@ package body Exp_Attr is\n          Rewrite_Stream_Proc_Call (Pname);\n       end Write;\n \n-      --  Component_Size is handled by Gigi, unless the component size is known\n-      --  at compile time, which is always true in the packed array case. It is\n-      --  important that the packed array case is handled in the front end (see\n-      --  Eval_Attribute) since Gigi would otherwise get confused by the\n-      --  equivalent packed array type.\n+      --  Component_Size is handled by the back end, unless the component size\n+      --  is known at compile time, which is always true in the packed array\n+      --  case. It is important that the packed array case is handled in the\n+      --  front end (see Eval_Attribute) since the back end would otherwise get\n+      --  confused by the equivalent packed array type.\n \n       when Attribute_Component_Size =>\n          null;\n@@ -5053,7 +5093,7 @@ package body Exp_Attr is\n       --  static cases have already been evaluated during semantic processing,\n       --  but in any case the back end should not count on this).\n \n-      --  Gigi also handles the non-class-wide cases of Size\n+      --  The back end also handles the non-class-wide cases of Size\n \n       when Attribute_Bit_Order                    |\n            Attribute_Code_Address                 |\n@@ -5063,8 +5103,8 @@ package body Exp_Attr is\n            Attribute_Pool_Address                 =>\n          null;\n \n-      --  The following attributes are also handled by Gigi, but return a\n-      --  universal integer result, so may need a conversion for checking\n+      --  The following attributes are also handled by the back end, but return\n+      --  a universal integer result, so may need a conversion for checking\n       --  that the result is in range.\n \n       when Attribute_Aft                          |\n@@ -5091,6 +5131,7 @@ package body Exp_Attr is\n            Attribute_Fast_Math                    |\n            Attribute_Has_Access_Values            |\n            Attribute_Has_Discriminants            |\n+           Attribute_Has_Tagged_Values            |\n            Attribute_Large                        |\n            Attribute_Machine_Emax                 |\n            Attribute_Machine_Emin                 |\n@@ -5126,8 +5167,8 @@ package body Exp_Attr is\n          raise Program_Error;\n \n       --  The Asm_Input and Asm_Output attributes are not expanded at this\n-      --  stage, but will be eliminated in the expansion of the Asm call,\n-      --  see Exp_Intr for details. So Gigi will never see these either.\n+      --  stage, but will be eliminated in the expansion of the Asm call, see\n+      --  Exp_Intr for details. So the back end will never see these either.\n \n       when Attribute_Asm_Input                    |\n            Attribute_Asm_Output                   =>\n@@ -5274,11 +5315,79 @@ package body Exp_Attr is\n       Nam : TSS_Name_Type) return Entity_Id\n    is\n       Ent : constant Entity_Id := TSS (Typ, Nam);\n+\n    begin\n       if Present (Ent) then\n          return Ent;\n       end if;\n \n+      --  Stream attributes for strings are expanded into library calls. The\n+      --  following checks are disabled when the run-time is not available or\n+      --  when compiling predefined types due to bootstrap issues. As a result,\n+      --  the compiler will generate in-place stream routines for string types\n+      --  that appear in GNAT's library, but will generate calls via rtsfind\n+      --  to library routines for user code.\n+      --  ??? For now, disable this code for JVM, since this generates a\n+      --  VerifyError exception at run-time on e.g. c330001.\n+      --  This is disabled for AAMP, to avoid making dependences on files not\n+      --  supported in the AAMP library (such as s-fileio.adb).\n+\n+      if VM_Target /= JVM_Target\n+        and then not AAMP_On_Target\n+        and then\n+          not Is_Predefined_File_Name (Unit_File_Name (Current_Sem_Unit))\n+      then\n+\n+         --  String as defined in package Ada\n+\n+         if Typ = Standard_String then\n+            if Nam = TSS_Stream_Input then\n+               return RTE (RE_String_Input);\n+\n+            elsif Nam = TSS_Stream_Output then\n+               return RTE (RE_String_Output);\n+\n+            elsif Nam = TSS_Stream_Read then\n+               return RTE (RE_String_Read);\n+\n+            else pragma Assert (Nam = TSS_Stream_Write);\n+               return RTE (RE_String_Write);\n+            end if;\n+\n+         --  Wide_String as defined in package Ada\n+\n+         elsif Typ = Standard_Wide_String then\n+            if Nam = TSS_Stream_Input then\n+               return RTE (RE_Wide_String_Input);\n+\n+            elsif Nam = TSS_Stream_Output then\n+               return RTE (RE_Wide_String_Output);\n+\n+            elsif Nam = TSS_Stream_Read then\n+               return RTE (RE_Wide_String_Read);\n+\n+            else pragma Assert (Nam = TSS_Stream_Write);\n+               return RTE (RE_Wide_String_Write);\n+            end if;\n+\n+         --  Wide_Wide_String as defined in package Ada\n+\n+         elsif Typ = Standard_Wide_Wide_String then\n+            if Nam = TSS_Stream_Input then\n+               return RTE (RE_Wide_Wide_String_Input);\n+\n+            elsif Nam = TSS_Stream_Output then\n+               return RTE (RE_Wide_Wide_String_Output);\n+\n+            elsif Nam = TSS_Stream_Read then\n+               return RTE (RE_Wide_Wide_String_Read);\n+\n+            else pragma Assert (Nam = TSS_Stream_Write);\n+               return RTE (RE_Wide_Wide_String_Write);\n+            end if;\n+         end if;\n+      end if;\n+\n       if Is_Tagged_Type (Typ)\n         and then Is_Derived_Type (Typ)\n       then"}, {"sha": "ac3590179e427e8eccd57e8241c972f2266e4117", "filename": "gcc/ada/exp_ch11.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fexp_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fexp_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch11.adb?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1463,6 +1463,7 @@ package body Exp_Ch11 is\n             Id : Entity_Id := Entity (Name (N));\n \n          begin\n+            Name_Len := 0;\n             Build_Location_String (Loc);\n \n             --  If the exception is a renaming, use the exception that it"}, {"sha": "68965c71493d93b065382a5f568729e9feb9f6ad", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 198, "deletions": 67, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -109,9 +109,8 @@ package body Exp_Ch5 is\n    --  statements.\n \n    procedure Expand_Simple_Function_Return (N : Node_Id);\n-   --  Expand simple return from function. Called by\n-   --  Expand_N_Simple_Return_Statement in case we're returning from a function\n-   --  body.\n+   --  Expand simple return from function. In the case where we are returning\n+   --  from a function body this is called by Expand_N_Simple_Return_Statement.\n \n    function Make_Tag_Ctrl_Assignment (N : Node_Id) return List_Id;\n    --  Generate the necessary code for controlled and tagged assignment,\n@@ -3207,54 +3206,59 @@ package body Exp_Ch5 is\n \n       --     return not (expression);\n \n-      if Nkind (N) = N_If_Statement\n-         and then No (Elsif_Parts (N))\n-         and then Present (Else_Statements (N))\n-         and then List_Length (Then_Statements (N)) = 1\n-         and then List_Length (Else_Statements (N)) = 1\n-      then\n-         declare\n-            Then_Stm : constant Node_Id := First (Then_Statements (N));\n-            Else_Stm : constant Node_Id := First (Else_Statements (N));\n+      --  Only do these optimizations if we are at least at -O1 level\n \n-         begin\n-            if Nkind (Then_Stm) = N_Simple_Return_Statement\n-                 and then\n-               Nkind (Else_Stm) = N_Simple_Return_Statement\n-            then\n-               declare\n-                  Then_Expr : constant Node_Id := Expression (Then_Stm);\n-                  Else_Expr : constant Node_Id := Expression (Else_Stm);\n+      if Optimization_Level > 0 then\n+         if Nkind (N) = N_If_Statement\n+           and then No (Elsif_Parts (N))\n+           and then Present (Else_Statements (N))\n+           and then List_Length (Then_Statements (N)) = 1\n+           and then List_Length (Else_Statements (N)) = 1\n+         then\n+            declare\n+               Then_Stm : constant Node_Id := First (Then_Statements (N));\n+               Else_Stm : constant Node_Id := First (Else_Statements (N));\n \n-               begin\n-                  if Nkind (Then_Expr) = N_Identifier\n-                       and then\n-                     Nkind (Else_Expr) = N_Identifier\n-                  then\n-                     if Entity (Then_Expr) = Standard_True\n-                       and then Entity (Else_Expr) = Standard_False\n-                     then\n-                        Rewrite (N,\n-                          Make_Simple_Return_Statement (Loc,\n-                            Expression => Relocate_Node (Condition (N))));\n-                        Analyze (N);\n-                        return;\n-\n-                     elsif Entity (Then_Expr) = Standard_False\n-                       and then Entity (Else_Expr) = Standard_True\n+            begin\n+               if Nkind (Then_Stm) = N_Simple_Return_Statement\n+                    and then\n+                  Nkind (Else_Stm) = N_Simple_Return_Statement\n+               then\n+                  declare\n+                     Then_Expr : constant Node_Id := Expression (Then_Stm);\n+                     Else_Expr : constant Node_Id := Expression (Else_Stm);\n+\n+                  begin\n+                     if Nkind (Then_Expr) = N_Identifier\n+                          and then\n+                        Nkind (Else_Expr) = N_Identifier\n                      then\n-                        Rewrite (N,\n-                          Make_Simple_Return_Statement (Loc,\n-                            Expression =>\n-                              Make_Op_Not (Loc,\n-                                Right_Opnd => Relocate_Node (Condition (N)))));\n-                        Analyze (N);\n-                        return;\n+                        if Entity (Then_Expr) = Standard_True\n+                          and then Entity (Else_Expr) = Standard_False\n+                        then\n+                           Rewrite (N,\n+                             Make_Simple_Return_Statement (Loc,\n+                               Expression => Relocate_Node (Condition (N))));\n+                           Analyze (N);\n+                           return;\n+\n+                        elsif Entity (Then_Expr) = Standard_False\n+                          and then Entity (Else_Expr) = Standard_True\n+                        then\n+                           Rewrite (N,\n+                             Make_Simple_Return_Statement (Loc,\n+                               Expression =>\n+                                 Make_Op_Not (Loc,\n+                                   Right_Opnd =>\n+                                     Relocate_Node (Condition (N)))));\n+                           Analyze (N);\n+                           return;\n+                        end if;\n                      end if;\n-                  end if;\n-               end;\n-            end if;\n-         end;\n+                  end;\n+               end if;\n+            end;\n+         end if;\n       end if;\n    end Expand_N_If_Statement;\n \n@@ -3463,6 +3467,15 @@ package body Exp_Ch5 is\n \n    procedure Expand_N_Simple_Return_Statement (N : Node_Id) is\n    begin\n+      --  Defend agains previous errors (ie. the return statement calls a\n+      --  function that is not available in configurable runtime).\n+\n+      if Present (Expression (N))\n+        and then Nkind (Expression (N)) = N_Empty\n+      then\n+         return;\n+      end if;\n+\n       --  Distinguish the function and non-function cases:\n \n       case Ekind (Return_Applies_To (Return_Statement_Entity (N))) is\n@@ -3504,6 +3517,16 @@ package body Exp_Ch5 is\n       Lab_Node    : Node_Id;\n \n    begin\n+      --  Call postconditions procedure if procedure with active postconditions\n+\n+      if Ekind (Scope_Id) = E_Procedure\n+        and then Has_Postconditions (Scope_Id)\n+      then\n+         Insert_Action (N,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => Make_Identifier (Loc, Name_uPostconditions)));\n+      end if;\n+\n       --  If it is a return from a procedure do no extra steps\n \n       if Kind = E_Procedure or else Kind = E_Generic_Procedure then\n@@ -3572,16 +3595,15 @@ package body Exp_Ch5 is\n       elsif Is_Protected_Type (Scope_Id) then\n          Call :=\n            Make_Procedure_Call_Statement (Loc,\n-             Name => New_Reference_To\n-               (RTE (RE_Complete_Entry_Body), Loc),\n-             Parameter_Associations => New_List\n-               (Make_Attribute_Reference (Loc,\n+             Name =>\n+               New_Reference_To (RTE (RE_Complete_Entry_Body), Loc),\n+             Parameter_Associations => New_List (\n+               Make_Attribute_Reference (Loc,\n                  Prefix =>\n                    New_Reference_To\n-                     (Object_Ref\n-                        (Corresponding_Body (Parent (Scope_Id))),\n-                     Loc),\n-                 Attribute_Name => Name_Unchecked_Access)));\n+                     (Find_Protection_Object (Current_Scope), Loc),\n+                 Attribute_Name =>\n+                   Name_Unchecked_Access)));\n \n          Insert_Before (N, Call);\n          Analyze (Call);\n@@ -3614,28 +3636,30 @@ package body Exp_Ch5 is\n       --  The type of the expression (not necessarily the same as R_Type)\n \n    begin\n-      --  We rewrite \"return <expression>;\" to be:\n+      --  For the case of a simple return that does not come from an extended\n+      --  return, in the case of Ada 2005 where we are returning a limited\n+      --  type, we rewrite \"return <expression>;\" to be:\n \n       --    return _anon_ : <return_subtype> := <expression>\n \n       --  The expansion produced by Expand_N_Extended_Return_Statement will\n       --  contain simple return statements (for example, a block containing\n       --  simple return of the return object), which brings us back here with\n-      --  Comes_From_Extended_Return_Statement set. To avoid infinite\n-      --  recursion, we do not transform into an extended return if\n-      --  Comes_From_Extended_Return_Statement is True.\n+      --  Comes_From_Extended_Return_Statement set. The reason for the barrier\n+      --  checking for a simple return that does not come from an extended\n+      --  return is to avoid this infinite recursion.\n \n       --  The reason for this design is that for Ada 2005 limited returns, we\n       --  need to reify the return object, so we can build it \"in place\", and\n       --  we need a block statement to hang finalization and tasking stuff.\n \n       --  ??? In order to avoid disruption, we avoid translating to extended\n-      --  return except in the cases where we really need to (Ada 2005\n-      --  inherently limited). We would prefer eventually to do this\n-      --  translation in all cases except perhaps for the case of Ada 95\n-      --  inherently limited, in order to fully exercise the code in\n-      --  Expand_N_Extended_Return_Statement, and in order to do\n-      --  build-in-place for efficiency when it is not required.\n+      --  return except in the cases where we really need to (Ada 2005 for\n+      --  inherently limited). We might prefer to do this translation in all\n+      --  cases (except perhaps for the case of Ada 95 inherently limited),\n+      --  in order to fully exercise the Expand_N_Extended_Return_Statement\n+      --  code. This would also allow us to to the build-in-place optimization\n+      --  for efficiency even in cases where it is semantically not required.\n \n       --  As before, we check the type of the return expression rather than the\n       --  return type of the function, because the latter may be a limited\n@@ -3644,7 +3668,7 @@ package body Exp_Ch5 is\n \n       if not Comes_From_Extended_Return_Statement (N)\n         and then Is_Inherently_Limited_Type (Etype (Expression (N)))\n-        and then Ada_Version >= Ada_05 --  ???\n+        and then Ada_Version >= Ada_05\n         and then not Debug_Flag_Dot_L\n       then\n          declare\n@@ -3845,7 +3869,7 @@ package body Exp_Ch5 is\n          --  secondary stack.\n \n          else\n-            Set_Storage_Pool      (N, RTE (RE_SS_Pool));\n+            Set_Storage_Pool (N, RTE (RE_SS_Pool));\n \n             --  If we are generating code for the VM do not use\n             --  SS_Allocate since everything is heap-allocated anyway.\n@@ -3987,6 +4011,113 @@ package body Exp_Ch5 is\n                 Reason => PE_Accessibility_Check_Failed));\n          end;\n       end if;\n+\n+      --  Generate call to postcondition checks if they are present\n+\n+      if Ekind (Scope_Id) = E_Function\n+        and then Has_Postconditions (Scope_Id)\n+      then\n+         --  We are going to reference the returned value twice in this case,\n+         --  once in the call to _Postconditions, and once in the actual return\n+         --  statement, but we can't have side effects happening twice, and in\n+         --  any case for efficiency we don't want to do the computation twice.\n+\n+         --  If the returned expression is an entity name, we don't need to\n+         --  worry since it is efficient and safe to reference it twice, that's\n+         --  also true for literals other than string literals, and for the\n+         --  case of X.all where X is an entity name.\n+\n+         if Is_Entity_Name (Exp)\n+           or else Nkind_In (Exp, N_Character_Literal,\n+                                  N_Integer_Literal,\n+                                  N_Real_Literal)\n+           or else (Nkind (Exp) = N_Explicit_Dereference\n+                      and then Is_Entity_Name (Prefix (Exp)))\n+         then\n+            null;\n+\n+         --  Otherwise we are going to need a temporary to capture the value\n+\n+         else\n+            declare\n+               Tnn : constant Entity_Id :=\n+                       Make_Defining_Identifier (Loc,\n+                         New_Internal_Name ('T'));\n+\n+            begin\n+               --  For a complex expression of an elementary type, capture\n+               --  value in the temporary and use it as the reference.\n+\n+               if Is_Elementary_Type (R_Type) then\n+                  Insert_Action (Exp,\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Tnn,\n+                      Constant_Present    => True,\n+                      Object_Definition   => New_Occurrence_Of (R_Type, Loc),\n+                      Expression          => Relocate_Node (Exp)),\n+                    Suppress => All_Checks);\n+\n+                  Rewrite (Exp, New_Occurrence_Of (Tnn, Loc));\n+\n+               --  If we have something we can rename, generate a renaming of\n+               --  the object and replace the expression with a reference\n+\n+               elsif Is_Object_Reference (Exp) then\n+                  Insert_Action (Exp,\n+                    Make_Object_Renaming_Declaration (Loc,\n+                      Defining_Identifier => Tnn,\n+                      Subtype_Mark        => New_Occurrence_Of (R_Type, Loc),\n+                      Name                => Relocate_Node (Exp)),\n+                    Suppress => All_Checks);\n+\n+                  Rewrite (Exp, New_Occurrence_Of (Tnn, Loc));\n+\n+               --  Otherwise we have something like a string literal or an\n+               --  aggregate. We could copy the value, but that would be\n+               --  inefficient. Instead we make a reference to the value and\n+               --  capture this reference with a renaming, the expression is\n+               --  then replaced by a dereference of this renaming.\n+\n+               else\n+                  --  For now, copy the value, since the code below does not\n+                  --  seem to work correctly ???\n+\n+                  Insert_Action (Exp,\n+                    Make_Object_Declaration (Loc,\n+                      Defining_Identifier => Tnn,\n+                      Constant_Present    => True,\n+                      Object_Definition   => New_Occurrence_Of (R_Type, Loc),\n+                      Expression          => Relocate_Node (Exp)),\n+                    Suppress => All_Checks);\n+\n+                  Rewrite (Exp, New_Occurrence_Of (Tnn, Loc));\n+\n+                  --  Insert_Action (Exp,\n+                  --    Make_Object_Renaming_Declaration (Loc,\n+                  --      Defining_Identifier => Tnn,\n+                  --      Access_Definition =>\n+                  --        Make_Access_Definition (Loc,\n+                  --          All_Present  => True,\n+                  --          Subtype_Mark => New_Occurrence_Of (R_Type, Loc)),\n+                  --      Name =>\n+                  --        Make_Reference (Loc,\n+                  --          Prefix => Relocate_Node (Exp))),\n+                  --    Suppress => All_Checks);\n+\n+                  --  Rewrite (Exp,\n+                  --    Make_Explicit_Dereference (Loc,\n+                  --      Prefix => New_Occurrence_Of (Tnn, Loc)));\n+               end if;\n+            end;\n+         end if;\n+\n+         --  Generate call to _postconditions\n+\n+         Insert_Action (Exp,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => Make_Identifier (Loc, Name_uPostconditions),\n+             Parameter_Associations => New_List (Duplicate_Subexpr (Exp))));\n+      end if;\n    end Expand_Simple_Function_Return;\n \n    ------------------------------"}, {"sha": "6f29b37b3ba15071a07b8a9f8fbcfaea3165841b", "filename": "gcc/ada/exp_intr.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fexp_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fexp_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_intr.adb?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -659,6 +659,8 @@ package body Exp_Intr is\n       --  String cases\n \n       else\n+         Name_Len := 0;\n+\n          case Nam is\n             when Name_File =>\n                Get_Decoded_Name_String\n@@ -668,12 +670,10 @@ package body Exp_Intr is\n                Build_Location_String (Loc);\n \n             when Name_Enclosing_Entity =>\n-               Name_Len := 0;\n-\n-               Ent := Current_Scope;\n \n                --  Skip enclosing blocks to reach enclosing unit\n \n+               Ent := Current_Scope;\n                while Present (Ent) loop\n                   exit when Ekind (Ent) /= E_Block\n                     and then Ekind (Ent) /= E_Loop;\n@@ -682,15 +682,15 @@ package body Exp_Intr is\n \n                --  Ent now points to the relevant defining entity\n \n-               Name_Len := 0;\n                Write_Entity_Name (Ent);\n \n             when others =>\n                raise Program_Error;\n          end case;\n \n          Rewrite (N,\n-           Make_String_Literal (Loc, Strval => String_From_Name_Buffer));\n+           Make_String_Literal (Loc,\n+             Strval => String_From_Name_Buffer));\n          Analyze_And_Resolve (N, Standard_String);\n       end if;\n "}, {"sha": "3cb421b4bd3f40473cdd07d6d172857a7480ad0b", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 117, "deletions": 24, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -40,7 +40,6 @@ with Restrict; use Restrict;\n with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n-with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n@@ -60,16 +59,18 @@ package body Exp_Prag is\n \n    function Arg1 (N : Node_Id) return Node_Id;\n    function Arg2 (N : Node_Id) return Node_Id;\n+   function Arg3 (N : Node_Id) return Node_Id;\n    --  Obtain specified pragma argument expression\n \n    procedure Expand_Pragma_Abort_Defer             (N : Node_Id);\n-   procedure Expand_Pragma_Assert                  (N : Node_Id);\n+   procedure Expand_Pragma_Check                   (N : Node_Id);\n    procedure Expand_Pragma_Common_Object           (N : Node_Id);\n    procedure Expand_Pragma_Import_Or_Interface     (N : Node_Id);\n    procedure Expand_Pragma_Import_Export_Exception (N : Node_Id);\n    procedure Expand_Pragma_Inspection_Point        (N : Node_Id);\n    procedure Expand_Pragma_Interrupt_Priority      (N : Node_Id);\n    procedure Expand_Pragma_Psect_Object            (N : Node_Id);\n+   procedure Expand_Pragma_Relative_Deadline       (N : Node_Id);\n \n    ----------\n    -- Arg1 --\n@@ -93,9 +94,11 @@ package body Exp_Prag is\n \n    function Arg2 (N : Node_Id) return Node_Id is\n       Arg1 : constant Node_Id := First (Pragma_Argument_Associations (N));\n+\n    begin\n       if No (Arg1) then\n          return Empty;\n+\n       else\n          declare\n             Arg : constant Node_Id := Next (Arg1);\n@@ -111,6 +114,39 @@ package body Exp_Prag is\n       end if;\n    end Arg2;\n \n+   ----------\n+   -- Arg3 --\n+   ----------\n+\n+   function Arg3 (N : Node_Id) return Node_Id is\n+      Arg1 : constant Node_Id := First (Pragma_Argument_Associations (N));\n+\n+   begin\n+      if No (Arg1) then\n+         return Empty;\n+\n+      else\n+         declare\n+            Arg : Node_Id := Next (Arg1);\n+         begin\n+            if No (Arg) then\n+               return Empty;\n+\n+            else\n+               Next (Arg);\n+\n+               if Present (Arg)\n+                 and then Nkind (Arg) = N_Pragma_Argument_Association\n+               then\n+                  return Expression (Arg);\n+               else\n+                  return Arg;\n+               end if;\n+            end if;\n+         end;\n+      end if;\n+   end Arg3;\n+\n    ---------------------\n    -- Expand_N_Pragma --\n    ---------------------\n@@ -130,8 +166,8 @@ package body Exp_Prag is\n             when Pragma_Abort_Defer =>\n                Expand_Pragma_Abort_Defer (N);\n \n-            when Pragma_Assert =>\n-               Expand_Pragma_Assert (N);\n+            when Pragma_Check =>\n+               Expand_Pragma_Check (N);\n \n             when Pragma_Common_Object =>\n                Expand_Pragma_Common_Object (N);\n@@ -157,6 +193,9 @@ package body Exp_Prag is\n             when Pragma_Psect_Object =>\n                Expand_Pragma_Psect_Object (N);\n \n+            when Pragma_Relative_Deadline =>\n+               Expand_Pragma_Relative_Deadline (N);\n+\n             --  All other pragmas need no expander action\n \n             when others => null;\n@@ -227,25 +266,25 @@ package body Exp_Prag is\n    end Expand_Pragma_Abort_Defer;\n \n    --------------------------\n-   -- Expand_Pragma_Assert --\n+   -- Expand_Pragma_Check --\n    --------------------------\n \n-   procedure Expand_Pragma_Assert (N : Node_Id) is\n+   procedure Expand_Pragma_Check (N : Node_Id) is\n       Loc  : constant Source_Ptr := Sloc (N);\n-      Cond : constant Node_Id    := Arg1 (N);\n-      Msg  : String_Id;\n+      Cond : constant Node_Id    := Arg2 (N);\n+      Nam  : constant Name_Id    := Chars (Arg1 (N));\n+      Msg  : Node_Id;\n \n    begin\n-      --  We already know that assertions are enabled, because otherwise\n-      --  the semantic pass dealt with rewriting the assertion (see Sem_Prag)\n-\n-      pragma Assert (Assertions_Enabled);\n+      --  We already know that this check is enabled, because otherwise the\n+      --  semantic pass dealt with rewriting the assertion (see Sem_Prag)\n \n-      --  Since assertions are on, we rewrite the pragma with its\n+      --  Since this check is enabled, we rewrite the pragma into a\n       --  corresponding if statement, and then analyze the statement\n+\n       --  The normal case expansion transforms:\n \n-      --    pragma Assert (condition [,message]);\n+      --    pragma Check (name, condition [,message]);\n \n       --  into\n \n@@ -254,7 +293,9 @@ package body Exp_Prag is\n       --    end if;\n \n       --  where Str is the message if one is present, or the default of\n-      --  file:line if no message is given.\n+      --  name failed at file:line if no message is given (the \"name failed\n+      --  at\" is omitted for name = Assertion, since it is redundant, given\n+      --  that the name of the exception is Assert_Failure.\n \n       --  An alternative expansion is used when the No_Exception_Propagation\n       --  restriction is active and there is a local Assert_Failure handler.\n@@ -281,7 +322,7 @@ package body Exp_Prag is\n       --  Case where we generate a direct raise\n \n       if (Debug_Flag_Dot_G\n-          or else Restriction_Active (No_Exception_Propagation))\n+           or else Restriction_Active (No_Exception_Propagation))\n         and then Present (Find_Local_Handler (RTE (RE_Assert_Failure), N))\n       then\n          Rewrite (N,\n@@ -297,13 +338,29 @@ package body Exp_Prag is\n       --  Case where we call the procedure\n \n       else\n-         --  First, we need to prepare the string literal\n+         --  First, we need to prepare the string argument\n+\n+         --  If we have a message given, use it\n+\n+         if Present (Arg3 (N)) then\n+            Msg := Arg3 (N);\n+\n+         --  Otherwise string is \"name failed at location\" except in the case\n+         --  of Assertion where \"name failed at\" is omitted.\n \n-         if Present (Arg2 (N)) then\n-            Msg := Strval (Expr_Value_S (Arg2 (N)));\n          else\n+            if Nam = Name_Assertion then\n+               Name_Len := 0;\n+            else\n+               Get_Name_String (Nam);\n+               Set_Casing (Identifier_Casing (Current_Source_File));\n+               Add_Str_To_Name_Buffer (\" failed at \");\n+            end if;\n+\n             Build_Location_String (Loc);\n-            Msg := String_From_Name_Buffer;\n+            Msg :=\n+              Make_String_Literal (Loc,\n+                Strval => String_From_Name_Buffer);\n          end if;\n \n          --  Now rewrite as an if statement\n@@ -317,8 +374,7 @@ package body Exp_Prag is\n                Make_Procedure_Call_Statement (Loc,\n                  Name =>\n                    New_Reference_To (RTE (RE_Raise_Assert_Failure), Loc),\n-                 Parameter_Associations => New_List (\n-                   Make_String_Literal (Loc, Msg))))));\n+                 Parameter_Associations => New_List (Msg)))));\n       end if;\n \n       Analyze (N);\n@@ -336,11 +392,13 @@ package body Exp_Prag is\n            and then Entity (Original_Node (Cond)) = Standard_False\n          then\n             return;\n-         else\n+         elsif Nam = Name_Assertion then\n             Error_Msg_N (\"?assertion will fail at run-time\", N);\n+         else\n+            Error_Msg_N (\"?check will fail at run time\", N);\n          end if;\n       end if;\n-   end Expand_Pragma_Assert;\n+   end Expand_Pragma_Check;\n \n    ---------------------------------\n    -- Expand_Pragma_Common_Object --\n@@ -737,4 +795,39 @@ package body Exp_Prag is\n    procedure Expand_Pragma_Psect_Object (N : Node_Id)\n      renames Expand_Pragma_Common_Object;\n \n+   -------------------------------------\n+   -- Expand_Pragma_Relative_Deadline --\n+   -------------------------------------\n+\n+   procedure Expand_Pragma_Relative_Deadline (N : Node_Id) is\n+      P    : constant Node_Id    := Parent (N);\n+      Loc  : constant Source_Ptr := Sloc (N);\n+\n+   begin\n+      --  Expand the pragma only in the case of the main subprogram. For tasks\n+      --  the expansion is done in exp_ch9. Generate a call to Set_Deadline\n+      --  at Clock plus the relative deadline specified in the pragma. Time\n+      --  values are translated into Duration to allow for non-private\n+      --  addition operation.\n+\n+      if Nkind (P) = N_Subprogram_Body then\n+         Rewrite\n+           (N,\n+            Make_Procedure_Call_Statement (Loc,\n+              Name => New_Reference_To (RTE (RE_Set_Deadline), Loc),\n+              Parameter_Associations => New_List (\n+                Unchecked_Convert_To (RTE (RO_RT_Time),\n+                  Make_Op_Add (Loc,\n+                    Left_Opnd  =>\n+                      Make_Function_Call (Loc,\n+                        New_Reference_To (RTE (RO_RT_To_Duration), Loc),\n+                        New_List (Make_Function_Call (Loc,\n+                          New_Reference_To (RTE (RE_Clock), Loc)))),\n+                    Right_Opnd  =>\n+                      Unchecked_Convert_To (Standard_Duration, Arg1 (N)))))));\n+\n+         Analyze (N);\n+      end if;\n+   end Expand_Pragma_Relative_Deadline;\n+\n end Exp_Prag;"}, {"sha": "c01e8ef76b3b80bb9038fb223d78e2c168abaf63", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -47,6 +47,7 @@ with Rtsfind;\n with Sprint;\n with Scn;      use Scn;\n with Sem;      use Sem;\n+with Sem_Aux;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Elab; use Sem_Elab;\n with Sem_Prag; use Sem_Prag;\n@@ -75,7 +76,9 @@ begin\n    Nlists.Initialize;\n    Elists.Initialize;\n    Lib.Load.Initialize;\n+   Sem_Aux.Initialize;\n    Sem_Ch8.Initialize;\n+   Sem_Prag.Initialize;\n    Fname.UF.Initialize;\n    Checks.Initialize;\n    Sem_Warn.Initialize;"}, {"sha": "5067f029c92afbf364de2fd49724deb98058cd60", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -1053,7 +1053,9 @@ begin\n            Pragma_Atomic                        |\n            Pragma_Atomic_Components             |\n            Pragma_Attach_Handler                |\n+           Pragma_Check                         |\n            Pragma_Check_Name                    |\n+           Pragma_Check_Policy                  |\n            Pragma_CIL_Constructor               |\n            Pragma_Compile_Time_Error            |\n            Pragma_Compile_Time_Warning          |\n@@ -1141,6 +1143,8 @@ begin\n            Pragma_Preelaborable_Initialization  |\n            Pragma_Polling                       |\n            Pragma_Persistent_BSS                |\n+           Pragma_Postcondition                 |\n+           Pragma_Precondition                  |\n            Pragma_Preelaborate                  |\n            Pragma_Preelaborate_05               |\n            Pragma_Priority                      |\n@@ -1153,6 +1157,7 @@ begin\n            Pragma_Pure_05                       |\n            Pragma_Pure_Function                 |\n            Pragma_Queuing_Policy                |\n+           Pragma_Relative_Deadline             |\n            Pragma_Remote_Call_Interface         |\n            Pragma_Remote_Types                  |\n            Pragma_Restricted_Run_Time           |"}, {"sha": "ae84ffbc086cb6aeb862eb83ee3e2327ad9f7bd7", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 255, "deletions": 94, "changes": 349, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -250,7 +250,7 @@ package body Sem_Attr is\n       procedure Check_Enum_Image;\n       --  If the prefix type is an enumeration type, set all its literals\n       --  as referenced, since the image function could possibly end up\n-      --  referencing any of the literals indirectly.\n+      --  referencing any of the literals indirectly. Same for Enum_Val.\n \n       procedure Check_Fixed_Point_Type;\n       --  Verify that prefix of attribute N is a fixed type\n@@ -275,8 +275,8 @@ package body Sem_Attr is\n       --  two attribute expressions are present\n \n       procedure Legal_Formal_Attribute;\n-      --  Common processing for attributes Definite, Has_Access_Values,\n-      --  and Has_Discriminants\n+      --  Common processing for attributes Definite and Has_Discriminants.\n+      --  Checks that prefix is generic indefinite formal type.\n \n       procedure Check_Integer_Type;\n       --  Verify that prefix of attribute N is an integer type\n@@ -287,6 +287,10 @@ package body Sem_Attr is\n       procedure Check_Modular_Integer_Type;\n       --  Verify that prefix of attribute N is a modular integer type\n \n+      procedure Check_Not_CPP_Type;\n+      --  Check that P (the prefix of the attribute) is not an CPP type\n+      --  for which no Ada predefined primitive is available.\n+\n       procedure Check_Not_Incomplete_Type;\n       --  Check that P (the prefix of the attribute) is not an incomplete\n       --  type or a private type for which no full view has been given.\n@@ -371,9 +375,9 @@ package body Sem_Attr is\n          --  type that is constructed is returned as the result.\n \n          procedure Build_Access_Subprogram_Type (P : Node_Id);\n-         --  Build an access to subprogram whose designated type is\n-         --  the type of the prefix. If prefix is overloaded, so it the\n-         --  node itself. The result is stored in Acc_Type.\n+         --  Build an access to subprogram whose designated type is the type of\n+         --  the prefix. If prefix is overloaded, so is the node itself. The\n+         --  result is stored in Acc_Type.\n \n          function OK_Self_Reference return Boolean;\n          --  An access reference whose prefix is a type can legally appear\n@@ -392,7 +396,6 @@ package body Sem_Attr is\n                       (E_Access_Attribute_Type, Current_Scope, Loc, 'A');\n          begin\n             Set_Etype                     (Typ, Typ);\n-            Init_Size_Align               (Typ);\n             Set_Is_Itype                  (Typ);\n             Set_Associated_Node_For_Itype (Typ, N);\n             Set_Directly_Designated_Type  (Typ, DT);\n@@ -577,14 +580,16 @@ package body Sem_Attr is\n             if Aname = Name_Unrestricted_Access then\n \n                --  Do not kill values on nodes initializing dispatch tables\n-               --  slots. The construct Address!(Prim'Unrestricted_Access)\n+               --  slots. The construct Prim_Ptr!(Prim'Unrestricted_Access)\n                --  is currently generated by the expander only for this\n                --  purpose. Done to keep the quality of warnings currently\n                --  generated by the compiler (otherwise any declaration of\n                --  a tagged type cleans constant indications from its scope).\n \n                if Nkind (Parent (N)) = N_Unchecked_Type_Conversion\n-                 and then Etype (Parent (N)) = RTE (RE_Address)\n+                 and then (Etype (Parent (N)) = RTE (RE_Prim_Ptr)\n+                             or else\n+                           Etype (Parent (N)) = RTE (RE_Size_Ptr))\n                  and then Is_Dispatching_Operation\n                             (Directly_Designated_Type (Etype (N)))\n                then\n@@ -658,12 +663,12 @@ package body Sem_Attr is\n                        (\"current instance prefix must be a direct name\", P);\n                   end if;\n \n-                  --  If a current instance attribute appears within a\n-                  --  a component constraint it must appear alone; other\n-                  --  contexts (default expressions, within a task body)\n-                  --  are not subject to this restriction.\n+                  --  If a current instance attribute appears in a component\n+                  --  constraint it must appear alone; other contexts (spec-\n+                  --  expressions, within a task body) are not subject to this\n+                  --  restriction.\n \n-                  if not In_Default_Expression\n+                  if not In_Spec_Expression\n                     and then not Has_Completion (Scop)\n                     and then not\n                       Nkind_In (Parent (N), N_Discriminant_Association,\n@@ -1263,6 +1268,20 @@ package body Sem_Attr is\n          end if;\n       end Check_Modular_Integer_Type;\n \n+      ------------------------\n+      -- Check_Not_CPP_Type --\n+      ------------------------\n+\n+      procedure Check_Not_CPP_Type is\n+      begin\n+         if Is_Tagged_Type (Etype (P))\n+           and then Convention (Etype (P)) = Convention_CPP\n+           and then Is_CPP_Class (Root_Type (Etype (P)))\n+         then\n+            Error_Attr_P (\"invalid use of % attribute with CPP tagged type\");\n+         end if;\n+      end Check_Not_CPP_Type;\n+\n       -------------------------------\n       -- Check_Not_Incomplete_Type --\n       -------------------------------\n@@ -1323,7 +1342,7 @@ package body Sem_Attr is\n \n          if not Is_Entity_Name (P)\n            or else not Is_Type (Entity (P))\n-           or else In_Default_Expression\n+           or else In_Spec_Expression\n          then\n             return;\n          else\n@@ -1531,6 +1550,8 @@ package body Sem_Attr is\n \n             Resolve (E2, P_Type);\n          end if;\n+\n+         Check_Not_CPP_Type;\n       end Check_Stream_Attribute;\n \n       -----------------------\n@@ -1865,6 +1886,7 @@ package body Sem_Attr is\n         and then Aname /= Name_Access\n         and then Aname /= Name_Address\n         and then Aname /= Name_Code_Address\n+        and then Aname /= Name_Result\n         and then Aname /= Name_Unchecked_Access\n       then\n          --  Ada 2005 (AI-345): Since protected and task types have primitive\n@@ -2055,6 +2077,7 @@ package body Sem_Attr is\n \n          Check_E0;\n          Check_Not_Incomplete_Type;\n+         Check_Not_CPP_Type;\n          Set_Etype (N, Universal_Integer);\n \n       ---------------\n@@ -2082,7 +2105,7 @@ package body Sem_Attr is\n             end if;\n          end if;\n \n-         Note_Possible_Modification (E2);\n+         Note_Possible_Modification (E2, Sure => True);\n          Set_Etype (N, RTE (RE_Asm_Output_Operand));\n \n       ---------------\n@@ -2109,11 +2132,19 @@ package body Sem_Attr is\n          --  is set True for the entry family case). In the True case,\n          --  makes sure that Is_AST_Entry is set on the entry.\n \n+         -------------------\n+         -- Bad_AST_Entry --\n+         -------------------\n+\n          procedure Bad_AST_Entry is\n          begin\n             Error_Attr_P (\"prefix for % attribute must be task entry\");\n          end Bad_AST_Entry;\n \n+         --------------\n+         -- OK_Entry --\n+         --------------\n+\n          function OK_Entry (E : Entity_Id) return Boolean is\n             Result : Boolean;\n \n@@ -2796,6 +2827,38 @@ package body Sem_Attr is\n          Set_Etype (N, Universal_Integer);\n       end Enum_Rep;\n \n+      --------------\n+      -- Enum_Val --\n+      --------------\n+\n+      when Attribute_Enum_Val => Enum_Val : begin\n+         Check_E1;\n+         Check_Type;\n+\n+         if not Is_Enumeration_Type (P_Type) then\n+            Error_Attr_P (\"prefix of % attribute must be enumeration type\");\n+         end if;\n+\n+         --  If the enumeration type has a standard representation, the effect\n+         --  is the same as 'Val, so rewrite the attribute as a 'Val.\n+\n+         if not Has_Non_Standard_Rep (P_Base_Type) then\n+            Rewrite (N,\n+              Make_Attribute_Reference (Loc,\n+                Prefix         => Relocate_Node (Prefix (N)),\n+                Attribute_Name => Name_Val,\n+                Expressions    => New_List (Relocate_Node (E1))));\n+            Analyze_And_Resolve (N, P_Base_Type);\n+\n+         --  Non-standard representation case (enumeration with holes)\n+\n+         else\n+            Check_Enum_Image;\n+            Resolve (E1, Any_Integer);\n+            Set_Etype (N, P_Base_Type);\n+         end if;\n+      end Enum_Val;\n+\n       -------------\n       -- Epsilon --\n       -------------\n@@ -2900,6 +2963,15 @@ package body Sem_Attr is\n          Check_E0;\n          Set_Etype (N, Standard_Boolean);\n \n+      -----------------------\n+      -- Has_Tagged_Values --\n+      -----------------------\n+\n+      when Attribute_Has_Tagged_Values =>\n+         Check_Type;\n+         Check_E0;\n+         Set_Etype (N, Standard_Boolean);\n+\n       -----------------------\n       -- Has_Discriminants --\n       -----------------------\n@@ -3017,6 +3089,16 @@ package body Sem_Attr is\n \n          Set_Etype (N, P_Base_Type);\n \n+      -------------------\n+      -- Invalid_Value --\n+      -------------------\n+\n+      when Attribute_Invalid_Value =>\n+         Check_E0;\n+         Check_Scalar_Type;\n+         Set_Etype (N, P_Base_Type);\n+         Invalid_Value_Used := True;\n+\n       -----------\n       -- Large --\n       -----------\n@@ -3560,6 +3642,69 @@ package body Sem_Attr is\n               (\"(Ada 83) % attribute not allowed for scalar type\", P);\n          end if;\n \n+      ------------\n+      -- Result --\n+      ------------\n+\n+      when Attribute_Result => Result : declare\n+         CS : constant Entity_Id := Current_Scope;\n+         PS : constant Entity_Id := Scope (CS);\n+\n+      begin\n+         --  If we are in the scope of a function and in Spec_Expression mode,\n+         --  this is likely the prescan of the postcondition pragma, and we\n+         --  just set the proper type. If there is an error it will be caught\n+         --  when the real Analyze call is done.\n+\n+         if Ekind (CS) = E_Function\n+           and then In_Spec_Expression\n+         then\n+            --  Check OK prefix\n+\n+            if Chars (CS) /= Chars (P) then\n+               Error_Msg_NE\n+                 (\"incorrect prefix for % attribute, expected &\", P, CS);\n+               Error_Attr;\n+            end if;\n+\n+            Set_Etype (N, Etype (CS));\n+\n+            --  If several functions with that name are visible,\n+            --  the intended one is the current scope.\n+\n+            if Is_Overloaded (P) then\n+               Set_Entity (P, CS);\n+               Set_Is_Overloaded (P, False);\n+            end if;\n+\n+         --  Body case, where we must be inside a generated _Postcondition\n+         --  procedure, or the attribute use is definitely misplaced.\n+\n+         elsif Chars (CS) = Name_uPostconditions\n+           and then Ekind (PS) = E_Function\n+         then\n+            --  Check OK prefix\n+\n+            if Nkind (P) /= N_Identifier\n+              or else Chars (P) /= Chars (PS)\n+            then\n+               Error_Msg_NE\n+                 (\"incorrect prefix for % attribute, expected &\", P, PS);\n+               Error_Attr;\n+            end if;\n+\n+            Rewrite (N,\n+              Make_Identifier (Sloc (N),\n+                Chars => Name_uResult));\n+            Analyze_And_Resolve (N, Etype (PS));\n+\n+         else\n+            Error_Attr\n+              (\"% attribute can only appear in function Postcondition pragma\",\n+               P);\n+         end if;\n+      end Result;\n+\n       ------------------\n       -- Range_Length --\n       ------------------\n@@ -3578,7 +3723,7 @@ package body Sem_Attr is\n          Check_Stream_Attribute (TSS_Stream_Read);\n          Set_Etype (N, Standard_Void_Type);\n          Resolve (N, Standard_Void_Type);\n-         Note_Possible_Modification (E2);\n+         Note_Possible_Modification (E2, Sure => True);\n \n       ---------------\n       -- Remainder --\n@@ -3737,6 +3882,7 @@ package body Sem_Attr is\n          end if;\n \n          Check_Not_Incomplete_Type;\n+         Check_Not_CPP_Type;\n          Set_Etype (N, Universal_Integer);\n       end Size;\n \n@@ -5020,14 +5166,16 @@ package body Sem_Attr is\n       --  Definite must be folded if the prefix is not a generic type,\n       --  that is to say if we are within an instantiation. Same processing\n       --  applies to the GNAT attributes Has_Discriminants, Type_Class,\n-      --  and Unconstrained_Array.\n+      --  Has_Tagged_Value, and Unconstrained_Array.\n \n       elsif (Id = Attribute_Definite\n                or else\n              Id = Attribute_Has_Access_Values\n                or else\n              Id = Attribute_Has_Discriminants\n                or else\n+             Id = Attribute_Has_Tagged_Values\n+               or else\n              Id = Attribute_Type_Class\n                or else\n              Id = Attribute_Unconstrained_Array)\n@@ -5130,9 +5278,9 @@ package body Sem_Attr is\n       --  since we can't do anything with unconstrained arrays. In addition,\n       --  only the First, Last and Length attributes are possibly static.\n \n-      --  Definite, Has_Access_Values, Has_Discriminants, Type_Class, and\n-      --  Unconstrained_Array are again exceptions, because they apply as\n-      --  well to unconstrained types.\n+      --  Definite, Has_Access_Values, Has_Discriminants, Has_Tagged_Values,\n+      --  Type_Class, and Unconstrained_Array are again exceptions, because\n+      --  they apply as well to unconstrained types.\n \n       --  In addition Component_Size is an exception since it is possibly\n       --  foldable, even though it is never static, and it does apply to\n@@ -5145,6 +5293,8 @@ package body Sem_Attr is\n               or else\n             Id = Attribute_Has_Discriminants\n               or else\n+            Id = Attribute_Has_Tagged_Values\n+              or else\n             Id = Attribute_Type_Class\n               or else\n             Id = Attribute_Unconstrained_Array\n@@ -5477,6 +5627,36 @@ package body Sem_Attr is\n             Fold_Uint (N, Expr_Value (E1), Static);\n          end if;\n \n+      --------------\n+      -- Enum_Val --\n+      --------------\n+\n+      when Attribute_Enum_Val => Enum_Val : declare\n+         Lit : Node_Id;\n+\n+      begin\n+         --  We have something like Enum_Type'Enum_Val (23), so search for a\n+         --  corresponding value in the list of Enum_Rep values for the type.\n+\n+         Lit := First_Literal (P_Base_Type);\n+         loop\n+            if Enumeration_Rep (Lit) = Expr_Value (E1) then\n+               Fold_Uint (N, Enumeration_Pos (Lit), Static);\n+               exit;\n+            end if;\n+\n+            Next_Literal (Lit);\n+\n+            if No (Lit) then\n+               Apply_Compile_Time_Constraint_Error\n+                 (N, \"no representation value matches\",\n+                  CE_Range_Check_Failed,\n+                  Warn => not Static);\n+               exit;\n+            end if;\n+         end loop;\n+      end Enum_Val;\n+\n       -------------\n       -- Epsilon --\n       -------------\n@@ -5564,6 +5744,15 @@ package body Sem_Attr is\n            Boolean_Literals (Has_Discriminants (P_Entity)), Loc));\n          Analyze_And_Resolve (N, Standard_Boolean);\n \n+      -----------------------\n+      -- Has_Tagged_Values --\n+      -----------------------\n+\n+      when Attribute_Has_Tagged_Values =>\n+         Rewrite (N, New_Occurrence_Of\n+           (Boolean_Literals (Has_Tagged_Component (P_Root_Type)), Loc));\n+         Analyze_And_Resolve (N, Standard_Boolean);\n+\n       --------------\n       -- Identity --\n       --------------\n@@ -5615,9 +5804,21 @@ package body Sem_Attr is\n       -- Integer_Value --\n       -------------------\n \n+      --  We never try to fold Integer_Value (though perhaps we could???)\n+\n       when Attribute_Integer_Value =>\n          null;\n \n+      -------------------\n+      -- Invalid_Value --\n+      -------------------\n+\n+      --  Invalid_Value is a scalar attribute that is never static, because\n+      --  the value is by design out of range.\n+\n+      when Attribute_Invalid_Value =>\n+         null;\n+\n       -----------\n       -- Large --\n       -----------\n@@ -6785,10 +6986,8 @@ package body Sem_Attr is\n             else\n                declare\n                   R  : constant Entity_Id := Root_Type (P_Type);\n-                  Lo : constant Uint :=\n-                         Expr_Value (Type_Low_Bound (P_Type));\n-                  Hi : constant Uint :=\n-                         Expr_Value (Type_High_Bound (P_Type));\n+                  Lo : constant Uint := Expr_Value (Type_Low_Bound (P_Type));\n+                  Hi : constant Uint := Expr_Value (Type_High_Bound (P_Type));\n                   W  : Nat;\n                   Wt : Nat;\n                   T  : Uint;\n@@ -6804,10 +7003,7 @@ package body Sem_Attr is\n                   --  Width for types derived from Standard.Character\n                   --  and Standard.Wide_[Wide_]Character.\n \n-                  elsif R = Standard_Character\n-                     or else R = Standard_Wide_Character\n-                     or else R = Standard_Wide_Wide_Character\n-                  then\n+                  elsif Is_Standard_Character_Type (P_Type) then\n                      W := 0;\n \n                      --  Set W larger if needed\n@@ -6978,6 +7174,7 @@ package body Sem_Attr is\n            Attribute_Position                 |\n            Attribute_Priority                 |\n            Attribute_Read                     |\n+           Attribute_Result                   |\n            Attribute_Storage_Pool             |\n            Attribute_Storage_Size             |\n            Attribute_Storage_Unit             |\n@@ -7172,7 +7369,7 @@ package body Sem_Attr is\n          Access_Attribute :\n          begin\n             if Is_Variable (P) then\n-               Note_Possible_Modification (P);\n+               Note_Possible_Modification (P, Sure => False);\n             end if;\n \n             if Is_Entity_Name (P) then\n@@ -7202,7 +7399,10 @@ package body Sem_Attr is\n                --    If it is an object, complete its resolution.\n \n                elsif Is_Overloadable (Entity (P)) then\n-                  if not In_Default_Expression then\n+\n+                  --  Avoid insertion of freeze actions in spec expression mode\n+\n+                  if not In_Spec_Expression then\n                      Insert_Actions (N, Freeze_Entity (Entity (P), Loc));\n                   end if;\n \n@@ -7760,7 +7960,7 @@ package body Sem_Attr is\n             --  it may be modified via this address, so note modification.\n \n             if Is_Variable (P) then\n-               Note_Possible_Modification (P);\n+               Note_Possible_Modification (P, Sure => False);\n             end if;\n \n             if Nkind (P) in N_Subexpr\n@@ -7927,75 +8127,25 @@ package body Sem_Attr is\n                LB   : Node_Id;\n                HB   : Node_Id;\n \n-               function Check_Discriminated_Prival\n-                 (N    : Node_Id)\n-                  return Node_Id;\n-               --  The range of a private component constrained by a\n-               --  discriminant is rewritten to make the discriminant\n-               --  explicit. This solves some complex visibility problems\n-               --  related to the use of privals.\n-\n-               --------------------------------\n-               -- Check_Discriminated_Prival --\n-               --------------------------------\n-\n-               function Check_Discriminated_Prival\n-                 (N    : Node_Id)\n-                  return Node_Id\n-               is\n-               begin\n-                  if Is_Entity_Name (N)\n-                    and then Ekind (Entity (N)) = E_In_Parameter\n-                    and then not Within_Init_Proc\n-                  then\n-                     return Make_Identifier (Sloc (N), Chars (Entity (N)));\n-                  else\n-                     return Duplicate_Subexpr (N);\n-                  end if;\n-               end Check_Discriminated_Prival;\n-\n-            --  Start of processing for Range_Attribute\n-\n             begin\n                if not Is_Entity_Name (P)\n                  or else not Is_Type (Entity (P))\n                then\n                   Resolve (P);\n                end if;\n \n-               --  Check whether prefix is (renaming of) private component\n-               --  of protected type.\n+               HB :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         =>\n+                     Duplicate_Subexpr (P, Name_Req => True),\n+                   Attribute_Name => Name_Last,\n+                   Expressions    => Expressions (N));\n \n-               if Is_Entity_Name (P)\n-                 and then Comes_From_Source (N)\n-                 and then Is_Array_Type (Etype (P))\n-                 and then Number_Dimensions (Etype (P)) = 1\n-                 and then (Ekind (Scope (Entity (P))) = E_Protected_Type\n-                            or else\n-                           Ekind (Scope (Scope (Entity (P)))) =\n-                                                        E_Protected_Type)\n-               then\n-                  LB :=\n-                    Check_Discriminated_Prival\n-                      (Type_Low_Bound (Etype (First_Index (Etype (P)))));\n-\n-                  HB :=\n-                    Check_Discriminated_Prival\n-                      (Type_High_Bound (Etype (First_Index (Etype (P)))));\n-\n-               else\n-                  HB :=\n-                    Make_Attribute_Reference (Loc,\n-                      Prefix         => Duplicate_Subexpr (P),\n-                      Attribute_Name => Name_Last,\n-                      Expressions    => Expressions (N));\n-\n-                  LB :=\n-                    Make_Attribute_Reference (Loc,\n-                      Prefix         => P,\n-                      Attribute_Name => Name_First,\n-                      Expressions    => Expressions (N));\n-               end if;\n+               LB :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         => P,\n+                   Attribute_Name => Name_First,\n+                   Expressions    => Expressions (N));\n \n                --  If the original was marked as Must_Not_Freeze (see code\n                --  in Sem_Ch3.Make_Index), then make sure the rewriting\n@@ -8031,6 +8181,17 @@ package body Sem_Attr is\n                return;\n             end Range_Attribute;\n \n+         ------------\n+         -- Result --\n+         ------------\n+\n+         --  We will only come here during the prescan of a spec expression\n+         --  containing a Result attribute. In that case the proper Etype has\n+         --  already been set, and nothing more needs to be done here.\n+\n+         when Attribute_Result =>\n+            null;\n+\n          -----------------\n          -- UET_Address --\n          -----------------"}, {"sha": "d0b74f5c9807e26d7d006a8ddff7d8055508c311", "filename": "gcc/ada/sem_attr.ads", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsem_attr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsem_attr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.ads?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -210,6 +210,21 @@ package Sem_Attr is\n       --  absence of an enumeration representation clause. This is a static\n       --  attribute (i.e. the result is static if the argument is static).\n \n+      --------------\n+      -- Enum_Val --\n+      --------------\n+\n+      Attribute_Enum_Val => True,\n+      --  For every enumeration subtype S, S'Enum_Val denotes a function\n+      --  with the following specification:\n+      --\n+      --    function S'Enum_Val (Arg : universal_integer) return S'Base;\n+      --\n+      --  This function performs the inverse transformation to Enum_Rep. Given\n+      --  a representation value for the type, it returns the corresponding\n+      --  enumeration value. Constraint_Error is raised if no value of the\n+      --  enumeration type corresponds to the given integer value.\n+\n       -----------------\n       -- Fixed_Value --\n       -----------------\n@@ -276,6 +291,16 @@ package Sem_Attr is\n       --  attribute is primarily intended for use in implementation of the\n       --  standard input-output functions for fixed-point values.\n \n+      Attribute_Invalid_Value => True,\n+      --  For every scalar type, S'Invalid_Value designates an undefined value\n+      --  of the type. If possible this value is an invalid value, and in fact\n+      --  is identical to the value that would be set if Initialize_Scalars\n+      --  mode were in effect (including the behavior of its value on\n+      --  environment variables or binder switches). The intended use is\n+      --  to set a value where intialization is required (e.g. as a result of\n+      --  the coding standards in use), but logically no initialization is\n+      --  needed, and the value should never be accessed.\n+\n       ------------------\n       -- Machine_Size --\n       ------------------"}, {"sha": "58b5b5c0da709cbe859a82b7a340758dd845daad", "filename": "gcc/ada/sem_aux.adb", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -0,0 +1,62 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              S E M _ A U X                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body Sem_Aux is\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+   begin\n+      Obsolescent_Warnings.Init;\n+   end Initialize;\n+\n+   ---------------\n+   -- Tree_Read --\n+   ---------------\n+\n+   procedure Tree_Read is\n+   begin\n+      Obsolescent_Warnings.Tree_Read;\n+   end Tree_Read;\n+\n+   ----------------\n+   -- Tree_Write --\n+   ----------------\n+\n+   procedure Tree_Write is\n+   begin\n+      Obsolescent_Warnings.Tree_Write;\n+   end Tree_Write;\n+\n+end Sem_Aux;"}, {"sha": "d9d74821ff15a792b2db645ea6c055301080896c", "filename": "gcc/ada/sem_aux.ads", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsem_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsem_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.ads?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -0,0 +1,86 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              S E M _ A U X                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- As a special exception,  if other files  instantiate  generics from this --\n+-- unit, or you link  this unit with other files  to produce an executable, --\n+-- this  unit  does not  by itself cause  the resulting  executable  to  be --\n+-- covered  by the  GNU  General  Public  License.  This exception does not --\n+-- however invalidate  any other reasons why  the executable file  might be --\n+-- covered by the  GNU Public License.                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Package containing utility procedures used throughout the compiler,\n+--  and also by ASIS so dependencies are limited to ASIS included packages.\n+\n+--  Note: contents are minimal for now, the intent is to move stuff from\n+--  Sem_Util that meets the ASIS dependency requirements, and also stuff\n+--  from Einfo, where Einfo had excessive semantic knowledge of the tree.\n+\n+with Alloc;   use Alloc;\n+with Table;\n+with Types;   use Types;\n+\n+package Sem_Aux is\n+\n+   --------------------------------\n+   -- Obsolescent Warnings Table --\n+   --------------------------------\n+\n+   --  This table records entities for which a pragma Obsolescent with a\n+   --  message argument has been processed.\n+\n+   type OWT_Record is record\n+      Ent : Entity_Id;\n+      --  The entity to which the pragma applies\n+\n+      Msg : String_Id;\n+      --  The string containing the message\n+   end record;\n+\n+   package Obsolescent_Warnings is new Table.Table (\n+     Table_Component_Type => OWT_Record,\n+     Table_Index_Type     => Int,\n+     Table_Low_Bound      => 0,\n+     Table_Initial        => Alloc.Obsolescent_Warnings_Initial,\n+     Table_Increment      => Alloc.Obsolescent_Warnings_Increment,\n+     Table_Name           => \"Obsolescent_Warnings\");\n+\n+   -----------------\n+   -- Subprograms --\n+   -----------------\n+\n+   procedure Initialize;\n+   --  Called at the start of compilation of each new main source file to\n+   --  initialize the allocation of the Obsolescent_Warnings table. Note that\n+   --  Initialize must not be called if Tree_Read is used.\n+\n+   procedure Tree_Read;\n+   --  Initializes internal tables from current tree file using the relevant\n+   --  Table.Tree_Read routines.\n+\n+   procedure Tree_Write;\n+   --  Writes out internal tables to current tree file using the relevant\n+   --  Table.Tree_Write routines.\n+\n+end Sem_Aux;"}, {"sha": "759607e7246c438370d7b7d2624d98b645f3541d", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 419, "deletions": 125, "changes": 544, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -32,6 +32,7 @@ with Errout;   use Errout;\n with Expander; use Expander;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch7;  use Exp_Ch7;\n+with Exp_Ch9;  use Exp_Ch9;\n with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n@@ -138,16 +139,6 @@ package body Sem_Ch6 is\n    --  against a formal access-to-subprogram type so Get_Instance_Of must\n    --  be called.\n \n-   procedure Check_Overriding_Indicator\n-     (Subp            : Entity_Id;\n-      Overridden_Subp : Entity_Id;\n-      Is_Primitive    : Boolean);\n-   --  Verify the consistency of an overriding_indicator given for subprogram\n-   --  declaration, body, renaming, or instantiation.  Overridden_Subp is set\n-   --  if the scope where we are introducing the subprogram contains a\n-   --  type-conformant subprogram that becomes hidden by the new subprogram.\n-   --  Is_Primitive indicates whether the subprogram is primitive.\n-\n    procedure Check_Subprogram_Order (N : Node_Id);\n    --  N is the N_Subprogram_Body node for a subprogram. This routine applies\n    --  the alpha ordering rule for N if this ordering requirement applicable.\n@@ -174,11 +165,6 @@ package body Sem_Ch6 is\n    procedure Install_Entity (E : Entity_Id);\n    --  Make single entity visible. Used for generic formals as well\n \n-   procedure Install_Formals (Id : Entity_Id);\n-   --  On entry to a subprogram body, make the formals visible. Note that\n-   --  simply placing the subprogram on the scope stack is not sufficient:\n-   --  the formals must become the current entities for their names.\n-\n    function Is_Non_Overriding_Operation\n      (Prev_E : Entity_Id;\n       New_E  : Entity_Id) return Boolean;\n@@ -196,6 +182,16 @@ package body Sem_Ch6 is\n    --  Flag functions that can be called without parameters, i.e. those that\n    --  have no parameters, or those for which defaults exist for all parameters\n \n+   procedure Process_PPCs\n+     (N       : Node_Id;\n+      Spec_Id : Entity_Id;\n+      Body_Id : Entity_Id);\n+   --  Called from Analyze_Body to deal with scanning post conditions for the\n+   --  body and assembling and inserting the _postconditions procedure. N is\n+   --  the node for the subprogram body and Body_Id/Spec_Id are the entities\n+   --  for the body and separate spec (if there is no separate spec, Spec_Id\n+   --  is Empty).\n+\n    procedure Set_Formal_Validity (Formal_Id : Entity_Id);\n    --  Formal_Id is an formal parameter entity. This procedure deals with\n    --  setting the proper validity status for this entity, which depends\n@@ -562,9 +558,22 @@ package body Sem_Ch6 is\n             end if;\n \n          --  Subtype_indication case; check that the types are the same, and\n-         --  statically match if appropriate:\n+         --  statically match if appropriate. A null exclusion may be present\n+         --  on the return type, on the function specification, on the object\n+         --  declaration or on the subtype itself.\n \n          elsif Base_Type (R_Stm_Type) = Base_Type (R_Type) then\n+            if Is_Access_Type (R_Type)\n+              and then\n+               (Can_Never_Be_Null (R_Type)\n+                 or else Null_Exclusion_Present (Parent (Scope_Id))) /=\n+                                              Can_Never_Be_Null (R_Stm_Type)\n+            then\n+               Error_Msg_N\n+                 (\"subtype must statically match function result subtype\",\n+                  Subtype_Ind);\n+            end if;\n+\n             if Is_Constrained (R_Type) then\n                if not Subtypes_Statically_Match (R_Stm_Type, R_Type) then\n                   Error_Msg_N\n@@ -653,9 +662,13 @@ package body Sem_Ch6 is\n          end;\n       end if;\n \n-      --  Case of Expr present (Etype check defends against previous errors)\n+      --  Case of Expr present\n \n       if Present (Expr)\n+\n+         --  Defend against previous errors\n+\n+        and then Nkind (Expr) /= N_Empty\n         and then Present (Etype (Expr))\n       then\n          --  Apply constraint check. Note that this is done before the implicit\n@@ -676,6 +689,22 @@ package body Sem_Ch6 is\n             Analyze_And_Resolve (Expr, R_Type);\n          end if;\n \n+         --  If the result type is class-wide, then check that the return\n+         --  expression's type is not declared at a deeper level than the\n+         --  function (RM05-6.5(5.6/2)).\n+\n+         if Ada_Version >= Ada_05\n+           and then Is_Class_Wide_Type (R_Type)\n+         then\n+            if Type_Access_Level (Etype (Expr)) >\n+                 Subprogram_Access_Level (Scope_Id)\n+            then\n+               Error_Msg_N\n+                 (\"level of return expression type is deeper than \" &\n+                  \"class-wide function!\", Expr);\n+            end if;\n+         end if;\n+\n          if (Is_Class_Wide_Type (Etype (Expr))\n               or else Is_Dynamically_Tagged (Expr))\n            and then not Is_Class_Wide_Type (R_Type)\n@@ -1232,14 +1261,33 @@ package body Sem_Ch6 is\n       Body_Id      : Entity_Id           := Defining_Entity (Body_Spec);\n       Prev_Id      : constant Entity_Id  := Current_Entity_In_Scope (Body_Id);\n       Body_Deleted : constant Boolean    := False;\n-\n-      HSS          : Node_Id;\n-      Spec_Id      : Entity_Id;\n-      Spec_Decl    : Node_Id   := Empty;\n-      Last_Formal  : Entity_Id := Empty;\n       Conformant   : Boolean;\n+      HSS          : Node_Id;\n       Missing_Ret  : Boolean;\n       P_Ent        : Entity_Id;\n+      Prot_Typ     : Entity_Id := Empty;\n+      Spec_Id      : Entity_Id;\n+      Spec_Decl    : Node_Id   := Empty;\n+\n+      Last_Real_Spec_Entity : Entity_Id := Empty;\n+      --  When we analyze a separate spec, the entity chain ends up containing\n+      --  the formals, as well as any itypes generated during analysis of the\n+      --  default expressions for parameters, or the arguments of associated\n+      --  precondition/postcondition pragmas (which are analyzed in the context\n+      --  of the spec since they have visibility on formals).\n+      --\n+      --  These entities belong with the spec and not the body. However we do\n+      --  the analysis of the body in the context of the spec (again to obtain\n+      --  visibility to the formals), and all the entities generated during\n+      --  this analysis end up also chained to the entity chain of the spec.\n+      --  But they really belong to the body, and there is circuitry to move\n+      --  them from the spec to the body.\n+      --\n+      --  However, when we do this move, we don't want to move the real spec\n+      --  entities (first para above) to the body. The Last_Real_Spec_Entity\n+      --  variable points to the last real spec entity, so we only move those\n+      --  chained beyond that point. It is initialized to Empty to deal with\n+      --  the case where there is no separate spec.\n \n       procedure Check_Anonymous_Return;\n       --  (Ada 2005): if a function returns an access type that denotes a task,\n@@ -1254,11 +1302,8 @@ package body Sem_Ch6 is\n       --  unconditionally, otherwise only if Front_End_Inlining is requested.\n       --  If the body acts as a spec, and inlining is required, we create a\n       --  subprogram declaration for it, in order to attach the body to inline.\n-\n-      procedure Copy_Parameter_List (Plist : List_Id);\n-      --  Utility to create a parameter profile for a new subprogram spec,\n-      --  when the subprogram has a body that acts as spec. This is done for\n-      --  some cases of inlining, and for private protected ops.\n+      --  If pragma does not appear after the body, check whether there is\n+      --  an inline pragma before any local declarations.\n \n       procedure Set_Trivial_Subprogram (N : Node_Id);\n       --  Sets the Is_Trivial_Subprogram flag in both spec and body of the\n@@ -1323,32 +1368,47 @@ package body Sem_Ch6 is\n          Prag  : Node_Id;\n          Plist : List_Id;\n \n+         function Is_Inline_Pragma (N : Node_Id) return Boolean;\n+         --  Simple predicate, used twice.\n+\n+         -----------------------\n+         --  Is_Inline_Pragma --\n+         -----------------------\n+\n+         function Is_Inline_Pragma (N : Node_Id) return Boolean is\n+         begin\n+            return\n+              Nkind (N) = N_Pragma\n+                and then\n+                   (Pragma_Name (N) = Name_Inline_Always\n+                     or else\n+                      (Front_End_Inlining\n+                        and then Pragma_Name (N) = Name_Inline))\n+                and then\n+                   Chars\n+                     (Expression (First (Pragma_Argument_Associations (N))))\n+                        = Chars (Body_Id);\n+         end Is_Inline_Pragma;\n+\n+      --  Start of processing for Check_Inline_Pragma\n+\n       begin\n          if not Expander_Active then\n             return;\n          end if;\n \n          if Is_List_Member (N)\n            and then Present (Next (N))\n-           and then Nkind (Next (N)) = N_Pragma\n+           and then Is_Inline_Pragma (Next (N))\n          then\n             Prag := Next (N);\n \n-            if Nkind (Prag) = N_Pragma\n-              and then\n-                 (Pragma_Name (Prag) = Name_Inline_Always\n-                   or else\n-                    (Front_End_Inlining\n-                      and then Pragma_Name (Prag) = Name_Inline))\n-              and then\n-                 Chars\n-                   (Expression (First (Pragma_Argument_Associations (Prag))))\n-                      = Chars (Body_Id)\n-            then\n-               Prag := Next (N);\n-            else\n-               Prag := Empty;\n-            end if;\n+         elsif Nkind (N) /= N_Subprogram_Body_Stub\n+           and then Present (Declarations (N))\n+           and then Is_Inline_Pragma (First (Declarations (N)))\n+         then\n+            Prag := First (Declarations (N));\n+\n          else\n             Prag := Empty;\n          end if;\n@@ -1374,8 +1434,7 @@ package body Sem_Ch6 is\n                   Set_Defining_Unit_Name (Specification (Decl), Subp);\n \n                   if Present (First_Formal (Body_Id)) then\n-                     Plist := New_List;\n-                     Copy_Parameter_List (Plist);\n+                     Plist := Copy_Parameter_List (Body_Id);\n                      Set_Parameter_Specifications\n                        (Specification (Decl), Plist);\n                   end if;\n@@ -1387,8 +1446,7 @@ package body Sem_Ch6 is\n \n                   if Pragma_Name (Prag) = Name_Inline_Always then\n                      Set_Is_Inlined (Subp);\n-                     Set_Next_Rep_Item (Prag, First_Rep_Item (Subp));\n-                     Set_First_Rep_Item (Subp, Prag);\n+                     Set_Has_Pragma_Inline_Always (Subp);\n                   end if;\n \n                   Spec := Subp;\n@@ -1397,34 +1455,6 @@ package body Sem_Ch6 is\n          end if;\n       end Check_Inline_Pragma;\n \n-      -------------------------\n-      -- Copy_Parameter_List --\n-      -------------------------\n-\n-      procedure Copy_Parameter_List (Plist : List_Id) is\n-         Formal : Entity_Id;\n-\n-      begin\n-         Formal := First_Formal (Body_Id);\n-\n-         while Present (Formal) loop\n-            Append\n-              (Make_Parameter_Specification (Loc,\n-                Defining_Identifier =>\n-                  Make_Defining_Identifier (Sloc (Formal),\n-                    Chars => Chars (Formal)),\n-                In_Present  => In_Present (Parent (Formal)),\n-                Out_Present => Out_Present (Parent (Formal)),\n-             Parameter_Type =>\n-                  New_Reference_To (Etype (Formal), Loc),\n-                Expression =>\n-                  New_Copy_Tree (Expression (Parent (Formal)))),\n-              Plist);\n-\n-            Next_Formal (Formal);\n-         end loop;\n-      end Copy_Parameter_List;\n-\n       ----------------------------\n       -- Set_Trivial_Subprogram --\n       ----------------------------\n@@ -1455,18 +1485,30 @@ package body Sem_Ch6 is\n \n       procedure Verify_Overriding_Indicator is\n       begin\n-         if Must_Override (Body_Spec)\n-           and then not Is_Overriding_Operation (Spec_Id)\n-         then\n-            Error_Msg_NE\n-              (\"subprogram& is not overriding\", Body_Spec, Spec_Id);\n+         if Must_Override (Body_Spec) then\n+            if Nkind (Spec_Id) = N_Defining_Operator_Symbol\n+              and then  Operator_Matches_Spec (Spec_Id, Spec_Id)\n+            then\n+               null;\n+\n+            elsif not Is_Overriding_Operation (Spec_Id) then\n+               Error_Msg_NE\n+                 (\"subprogram& is not overriding\", Body_Spec, Spec_Id);\n+            end if;\n \n          elsif Must_Not_Override (Body_Spec) then\n             if Is_Overriding_Operation (Spec_Id) then\n                Error_Msg_NE\n                  (\"subprogram& overrides inherited operation\",\n                   Body_Spec, Spec_Id);\n \n+            elsif Nkind (Spec_Id) = N_Defining_Operator_Symbol\n+              and then  Operator_Matches_Spec (Spec_Id, Spec_Id)\n+            then\n+               Error_Msg_NE\n+                 (\"subprogram & overrides predefined operator \",\n+                    Body_Spec, Spec_Id);\n+\n             --  If this is not a primitive operation the overriding indicator\n             --  is altogether illegal.\n \n@@ -1625,14 +1667,11 @@ package body Sem_Ch6 is\n             if Present (Formal)\n               or else Expander_Active\n             then\n-               Plist := New_List;\n-\n+               Plist := Copy_Parameter_List (Body_Id);\n             else\n                Plist := No_List;\n             end if;\n \n-            Copy_Parameter_List (Plist);\n-\n             if Nkind (Body_Spec) = N_Procedure_Specification then\n                New_Spec :=\n                  Make_Procedure_Specification (Loc,\n@@ -1715,12 +1754,13 @@ package body Sem_Ch6 is\n          if Is_Abstract_Subprogram (Spec_Id) then\n             Error_Msg_N (\"an abstract subprogram cannot have a body\", N);\n             return;\n+\n          else\n             Set_Convention (Body_Id, Convention (Spec_Id));\n             Set_Has_Completion (Spec_Id);\n \n             if Is_Protected_Type (Scope (Spec_Id)) then\n-               Set_Privals_Chain (Spec_Id, New_Elmt_List);\n+               Prot_Typ := Scope (Spec_Id);\n             end if;\n \n             --  If this is a body generated for a renaming, do not check for\n@@ -1789,8 +1829,8 @@ package body Sem_Ch6 is\n                 Present (Abstract_Interfaces (Etype (First_Entity (Spec_Id))))\n               and then\n                 Present\n-                 (Corresponding_Concurrent_Type\n-                   (Etype (First_Entity (Spec_Id))))\n+                  (Corresponding_Concurrent_Type\n+                     (Etype (First_Entity (Spec_Id))))\n             then\n                declare\n                   Typ  : constant Entity_Id := Etype (First_Entity (Spec_Id));\n@@ -1808,10 +1848,12 @@ package body Sem_Ch6 is\n                end;\n             end if;\n \n-            --  Make the formals visible, and place subprogram on scope stack\n+            --  Make the formals visible, and place subprogram on scope stack.\n+            --  This is also the point at which we set Last_Real_Spec_Entity\n+            --  to mark the entities which will not be moved to the body.\n \n             Install_Formals (Spec_Id);\n-            Last_Formal := Last_Entity (Spec_Id);\n+            Last_Real_Spec_Entity := Last_Entity (Spec_Id);\n             Push_Scope (Spec_Id);\n \n             --  Make sure that the subprogram is immediately visible. For\n@@ -1931,9 +1973,10 @@ package body Sem_Ch6 is\n \n       --  Ada 2005 (AI-262): In library subprogram bodies, after the analysis\n       --  if its specification we have to install the private withed units.\n+      --  This holds for child units as well.\n \n       if Is_Compilation_Unit (Body_Id)\n-        and then Scope (Body_Id) = Standard_Standard\n+        or else Nkind (Parent (N)) = N_Compilation_Unit\n       then\n          Install_Private_With_Clauses (Body_Id);\n       end if;\n@@ -1961,9 +2004,7 @@ package body Sem_Ch6 is\n          begin\n             while Present (Prot_Ext_Formal) loop\n                pragma Assert (Present (Impl_Ext_Formal));\n-\n                Set_Protected_Formal (Prot_Ext_Formal, Impl_Ext_Formal);\n-\n                Next_Formal_With_Extras (Prot_Ext_Formal);\n                Next_Formal_With_Extras (Impl_Ext_Formal);\n             end loop;\n@@ -1974,9 +2015,40 @@ package body Sem_Ch6 is\n \n       HSS := Handled_Statement_Sequence (N);\n       Set_Actual_Subtypes (N, Current_Scope);\n+\n+      --  Deal with preconditions and postconditions\n+\n+      Process_PPCs (N, Spec_Id, Body_Id);\n+\n+      --  Add a declaration for the Protection objcect, renaming declarations\n+      --  for discriminals and privals and finally a declaration for the entry\n+      --  family index (if applicable). This form of early expansion is done\n+      --  when the Expander is active because Install_Private_Data_Declarations\n+      --  references entities which were created during regular expansion.\n+\n+      if Expander_Active\n+        and then Comes_From_Source (N)\n+        and then Present (Prot_Typ)\n+        and then Present (Spec_Id)\n+        and then not Is_Eliminated (Spec_Id)\n+      then\n+         Install_Private_Data_Declarations\n+           (Sloc (N), Spec_Id, Prot_Typ, N, Declarations (N));\n+      end if;\n+\n+      --  Analyze the declarations (this call will analyze the precondition\n+      --  Check pragmas we prepended to the list, as well as the declaration\n+      --  of the _Postconditions procedure).\n+\n       Analyze_Declarations (Declarations (N));\n+\n+      --  Check completion, and analyze the statements\n+\n       Check_Completion;\n       Analyze (HSS);\n+\n+      --  Deal with end of scope processing for the body\n+\n       Process_End_Label (HSS, 't', Current_Scope);\n       End_Scope;\n       Check_Subprogram_Order (N);\n@@ -2000,14 +2072,35 @@ package body Sem_Ch6 is\n               (Unit_Declaration_Node (Spec_Id), Spec_Id);\n          end if;\n \n-         if Present (Last_Formal) then\n-            Set_Next_Entity\n-              (Last_Entity (Body_Id), Next_Entity (Last_Formal));\n-            Set_Next_Entity (Last_Formal, Empty);\n+         --  Here is where we move entities from the spec to the body\n+\n+         --  Case where there are entities that stay with the spec\n+\n+         if Present (Last_Real_Spec_Entity) then\n+\n+            --  No body entities (happens when the only real spec entities\n+            --  come from precondition and postcondition pragmas)\n+\n+            if No (Last_Entity (Body_Id)) then\n+               Set_First_Entity\n+                 (Body_Id, Next_Entity (Last_Real_Spec_Entity));\n+\n+            --  Body entities present (formals), so chain stuff past them\n+\n+            else\n+               Set_Next_Entity\n+                 (Last_Entity (Body_Id), Next_Entity (Last_Real_Spec_Entity));\n+            end if;\n+\n+            Set_Next_Entity (Last_Real_Spec_Entity, Empty);\n             Set_Last_Entity (Body_Id, Last_Entity (Spec_Id));\n-            Set_Last_Entity (Spec_Id, Last_Formal);\n+            Set_Last_Entity (Spec_Id, Last_Real_Spec_Entity);\n+\n+         --  Case where there are no spec entities, in this case there can\n+         --  be no body entities either, so just move everything.\n \n          else\n+            pragma Assert (No (Last_Entity (Body_Id)));\n             Set_First_Entity (Body_Id, First_Entity (Spec_Id));\n             Set_Last_Entity  (Body_Id, Last_Entity (Spec_Id));\n             Set_First_Entity (Spec_Id, Empty);\n@@ -2337,9 +2430,9 @@ package body Sem_Ch6 is\n \n    function Analyze_Subprogram_Specification (N : Node_Id) return Entity_Id is\n       Designator : constant Entity_Id := Defining_Entity (N);\n+      Formals    : constant List_Id   := Parameter_Specifications (N);\n       Formal     : Entity_Id;\n       Formal_Typ : Entity_Id;\n-      Formals    : constant List_Id   := Parameter_Specifications (N);\n \n    --  Start of processing for Analyze_Subprogram_Specification\n \n@@ -2406,13 +2499,14 @@ package body Sem_Ch6 is\n \n          if Is_Abstract_Type (Etype (Designator))\n            and then not Is_Interface (Etype (Designator))\n-           and then Nkind (Parent (N))\n-                      /= N_Abstract_Subprogram_Declaration\n-           and then (Nkind (Parent (N)))\n-                      /= N_Formal_Abstract_Subprogram_Declaration\n-           and then (Nkind (Parent (N)) /= N_Subprogram_Renaming_Declaration\n-                      or else not Is_Entity_Name (Name (Parent (N)))\n-                      or else not Is_Abstract_Subprogram\n+           and then Nkind (Parent (N)) /=\n+                      N_Abstract_Subprogram_Declaration\n+           and then\n+             (Nkind (Parent (N))) /= N_Formal_Abstract_Subprogram_Declaration\n+                and then\n+                  (Nkind (Parent (N)) /= N_Subprogram_Renaming_Declaration\n+                     or else not Is_Entity_Name (Name (Parent (N)))\n+                     or else not Is_Abstract_Subprogram\n                                     (Entity (Name (Parent (N)))))\n          then\n             Error_Msg_N\n@@ -3315,7 +3409,7 @@ package body Sem_Ch6 is\n \n                      if NewD then\n                         Push_Scope (New_Id);\n-                        Analyze_Per_Use_Expression\n+                        Preanalyze_Spec_Expression\n                           (Default_Value (New_Formal), Etype (New_Formal));\n                         End_Scope;\n                      end if;\n@@ -3709,7 +3803,7 @@ package body Sem_Ch6 is\n                --  expanded, so expand now to check conformance.\n \n                if NewD then\n-                  Analyze_Per_Use_Expression\n+                  Preanalyze_Spec_Expression\n                     (Expression (New_Discr), New_Discr_Type);\n                end if;\n \n@@ -3852,6 +3946,9 @@ package body Sem_Ch6 is\n                Error_Msg_NE\n                  (\"subprogram & overrides inherited operation #\", Spec, Subp);\n             end if;\n+\n+         elsif Is_Subprogram (Subp) then\n+            Set_Is_Overriding_Operation (Subp);\n          end if;\n \n       --  If Subp is an operator, it may override a predefined operation.\n@@ -3860,26 +3957,38 @@ package body Sem_Ch6 is\n       --  signature of Subp matches that of a predefined operator. Note that\n       --  first argument provides the name of the operator, and the second\n       --  argument the signature that may match that of a standard operation.\n+      --  If the indicator is overriding, then the operator must match a\n+      --  predefined signature, because we know already that there is no\n+      --  explicit overridden operation.\n \n-      elsif Nkind (Subp) = N_Defining_Operator_Symbol\n-        and then Must_Not_Override (Spec)\n-      then\n-         if Operator_Matches_Spec (Subp, Subp) then\n-            Error_Msg_NE\n-              (\"subprogram & overrides predefined operator \",\n-                 Spec, Subp);\n-         end if;\n+      elsif Nkind (Subp) = N_Defining_Operator_Symbol then\n \n-      elsif Must_Override (Spec) then\n-         if Ekind (Subp) = E_Entry then\n-            Error_Msg_NE (\"entry & is not overriding\", Spec, Subp);\n+         if Must_Not_Override (Spec) then\n+            if not Is_Primitive then\n+               Error_Msg_N\n+                 (\"overriding indicator only allowed \"\n+                    & \"if subprogram is primitive\", Subp);\n \n-         elsif Nkind (Subp) = N_Defining_Operator_Symbol then\n-            if not Operator_Matches_Spec (Subp, Subp) then\n+            elsif Operator_Matches_Spec (Subp, Subp) then\n                Error_Msg_NE\n-                 (\"subprogram & is not overriding\", Spec, Subp);\n+                 (\"subprogram & overrides predefined operator \", Spec, Subp);\n             end if;\n \n+         elsif Is_Overriding_Operation (Subp) then\n+            null;\n+\n+         elsif Must_Override (Spec) then\n+            if not Operator_Matches_Spec (Subp, Subp) then\n+               Error_Msg_NE (\"subprogram & is not overriding\", Spec, Subp);\n+\n+            else\n+               Set_Is_Overriding_Operation (Subp);\n+            end if;\n+         end if;\n+\n+      elsif Must_Override (Spec) then\n+         if Ekind (Subp) = E_Entry then\n+            Error_Msg_NE (\"entry & is not overriding\", Spec, Subp);\n          else\n             Error_Msg_NE (\"subprogram & is not overriding\", Spec, Subp);\n          end if;\n@@ -3897,7 +4006,6 @@ package body Sem_Ch6 is\n          Error_Msg_N\n            (\"overriding indicator only allowed if subprogram is primitive\",\n             Subp);\n-\n          return;\n       end if;\n    end Check_Overriding_Indicator;\n@@ -4964,7 +5072,6 @@ package body Sem_Ch6 is\n             begin\n                Set_Directly_Designated_Type (Formal_Type, Result_Subt);\n                Set_Etype (Formal_Type, Formal_Type);\n-               Init_Size_Align (Formal_Type);\n                Set_Depends_On_Private\n                  (Formal_Type, Has_Private_Component (Formal_Type));\n                Set_Is_Public (Formal_Type, Is_Public (Scope (Formal_Type)));\n@@ -6838,9 +6945,9 @@ package body Sem_Ch6 is\n       Default     : Node_Id;\n       Ptype       : Entity_Id;\n \n-      --  The following are used for setting Is_Only_Out_\n       Num_Out_Params  : Nat       := 0;\n       First_Out_Param : Entity_Id := Empty;\n+      --  Used for setting Is_Only_Out_Parameter\n \n       function Is_Class_Wide_Default (D : Node_Id) return Boolean;\n       --  Check whether the default has a class-wide type. After analysis the\n@@ -7000,7 +7107,7 @@ package body Sem_Ch6 is\n             --  Do the special preanalysis of the expression (see section on\n             --  \"Handling of Default Expressions\" in the spec of package Sem).\n \n-            Analyze_Per_Use_Expression (Default, Formal_Type);\n+            Preanalyze_Spec_Expression (Default, Formal_Type);\n \n             --  An access to constant cannot be the default for\n             --  an access parameter that is an access to variable.\n@@ -7098,6 +7205,193 @@ package body Sem_Ch6 is\n       end if;\n    end Process_Formals;\n \n+   ------------------\n+   -- Process_PPCs --\n+   ------------------\n+\n+   procedure Process_PPCs\n+     (N       : Node_Id;\n+      Spec_Id : Entity_Id;\n+      Body_Id : Entity_Id)\n+   is\n+      Loc   : constant Source_Ptr := Sloc (N);\n+      Prag  : Node_Id;\n+      Plist : List_Id := No_List;\n+      Subp  : Entity_Id;\n+      Parms : List_Id;\n+\n+      function Grab_PPC (Nam : Name_Id) return Node_Id;\n+      --  Prag contains an analyzed precondition or postcondition pragma.\n+      --  This function copies the pragma, changes it to the corresponding\n+      --  Check pragma and returns the Check pragma as the result. The\n+      --  argument Nam is either Name_Precondition or Name_Postcondition.\n+\n+      --------------\n+      -- Grab_PPC --\n+      --------------\n+\n+      function Grab_PPC (Nam : Name_Id) return Node_Id is\n+         CP : constant Node_Id := New_Copy_Tree (Prag);\n+\n+      begin\n+         --  Set Analyzed to false, since we want to reanalyze the check\n+         --  procedure. Note that it is only at the outer level that we\n+         --  do this fiddling, for the spec cases, the already preanalyzed\n+         --  parameters are not affected.\n+\n+         Set_Analyzed (CP, False);\n+\n+         --  Change pragma into corresponding pragma Check\n+\n+         Prepend_To (Pragma_Argument_Associations (CP),\n+           Make_Pragma_Argument_Association (Sloc (Prag),\n+             Expression =>\n+               Make_Identifier (Loc,\n+                 Chars => Nam)));\n+         Set_Pragma_Identifier (CP,\n+           Make_Identifier (Sloc (Prag),\n+             Chars => Name_Check));\n+\n+         return CP;\n+      end Grab_PPC;\n+\n+   --  Start of processing for Process_PPCs\n+\n+   begin\n+      --  Grab preconditions from spec\n+\n+      if Present (Spec_Id) then\n+\n+         --  Loop through PPC pragmas from spec. Note that preconditions from\n+         --  the body will be analyzed and converted when we scan the body\n+         --  declarations below.\n+\n+         Prag := Spec_PPC_List (Spec_Id);\n+         while Present (Prag) loop\n+            if Pragma_Name (Prag) = Name_Precondition\n+              and then PPC_Enabled (Prag)\n+            then\n+               --  Add pragma Check at the start of the declarations of N.\n+               --  Note that this processing reverses the order of the list,\n+               --  which is what we want since new entries were chained to\n+               --  the head of the list.\n+\n+               Prepend (Grab_PPC (Name_Precondition), Declarations (N));\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+      end if;\n+\n+      --  Build postconditions procedure if needed and prepend the following\n+      --  declaration to the start of the declarations for the subprogram.\n+\n+      --     procedure _postconditions [(_Result : resulttype)] is\n+      --     begin\n+      --        pragma Check (Postcondition, condition [,message]);\n+      --        pragma Check (Postcondition, condition [,message]);\n+      --        ...\n+      --     end;\n+\n+      --  First we deal with the postconditions in the body\n+\n+      if Is_Non_Empty_List (Declarations (N)) then\n+\n+         --  Loop through declarations\n+\n+         Prag := First (Declarations (N));\n+         while Present (Prag) loop\n+            if Nkind (Prag) = N_Pragma then\n+\n+               --  If pragma, capture if enabled postcondition, else ignore\n+\n+               if Pragma_Name (Prag) = Name_Postcondition\n+                 and then Check_Enabled (Name_Postcondition)\n+               then\n+                  if Plist = No_List then\n+                     Plist := Empty_List;\n+                  end if;\n+\n+                  Analyze (Prag);\n+                  Append (Grab_PPC (Name_Postcondition), Plist);\n+               end if;\n+\n+               Next (Prag);\n+\n+               --  Not a pragma, if comes from source, then end scan\n+\n+            elsif Comes_From_Source (Prag) then\n+               exit;\n+\n+               --  Skip stuff not coming from source\n+\n+            else\n+               Next (Prag);\n+            end if;\n+         end loop;\n+      end if;\n+\n+      --  Now deal with any postconditions from the spec\n+\n+      if Present (Spec_Id) then\n+\n+         --  Loop through PPC pragmas from spec\n+\n+         Prag := Spec_PPC_List (Spec_Id);\n+         while Present (Prag) loop\n+            if Pragma_Name (Prag) = Name_Postcondition\n+              and then PPC_Enabled (Prag)\n+            then\n+               if Plist = No_List then\n+                  Plist := Empty_List;\n+               end if;\n+\n+               Append (Grab_PPC (Name_Postcondition), Plist);\n+            end if;\n+\n+            Prag := Next_Pragma (Prag);\n+         end loop;\n+      end if;\n+\n+      --  If we had any postconditions, build the procedure\n+\n+      if Present (Plist) then\n+         Subp := Defining_Entity (N);\n+\n+         if Etype (Subp) /= Standard_Void_Type then\n+            Parms := New_List (\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier (Loc,\n+                    Chars => Name_uResult),\n+                Parameter_Type => New_Occurrence_Of (Etype (Subp), Loc)));\n+         else\n+            Parms := No_List;\n+         end if;\n+\n+         Prepend_To (Declarations (N),\n+           Make_Subprogram_Body (Loc,\n+             Specification =>\n+               Make_Procedure_Specification (Loc,\n+                 Defining_Unit_Name =>\n+                   Make_Defining_Identifier (Loc,\n+                     Chars => Name_uPostconditions),\n+                 Parameter_Specifications => Parms),\n+\n+             Declarations => Empty_List,\n+\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => Plist)));\n+\n+         if Present (Spec_Id) then\n+            Set_Has_Postconditions (Spec_Id);\n+         else\n+            Set_Has_Postconditions (Body_Id);\n+         end if;\n+      end if;\n+   end Process_PPCs;\n+\n    ----------------------------\n    -- Reference_Body_Formals --\n    ----------------------------"}, {"sha": "a195945fbc45d91d598e62d72d65bc5a663bc9bd", "filename": "gcc/ada/sem_ch6.ads", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsem_ch6.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsem_ch6.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.ads?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -100,6 +100,16 @@ package Sem_Ch6 is\n    --  formal access-to-subprogram type, indicating that mapping of types\n    --  is needed.\n \n+   procedure Check_Overriding_Indicator\n+     (Subp            : Entity_Id;\n+      Overridden_Subp : Entity_Id;\n+      Is_Primitive    : Boolean);\n+   --  Verify the consistency of an overriding_indicator given for subprogram\n+   --  declaration, body, renaming, or instantiation.  Overridden_Subp is set\n+   --  if the scope where we are introducing the subprogram contains a\n+   --  type-conformant subprogram that becomes hidden by the new subprogram.\n+   --  Is_Primitive indicates whether the subprogram is primitive.\n+\n    procedure Check_Subtype_Conformant\n      (New_Id  : Entity_Id;\n       Old_Id  : Entity_Id;\n@@ -146,18 +156,23 @@ package Sem_Ch6 is\n \n    function Fully_Conformant_Expressions\n      (Given_E1 : Node_Id;\n-      Given_E2 : Node_Id)\n-      return     Boolean;\n+      Given_E2 : Node_Id) return Boolean;\n    --  Determines if two (non-empty) expressions are fully conformant\n    --  as defined by (RM 6.3.1(18-21))\n \n    function Fully_Conformant_Discrete_Subtypes\n       (Given_S1 : Node_Id;\n-       Given_S2 : Node_Id)\n-       return Boolean;\n+       Given_S2 : Node_Id) return Boolean;\n    --  Determines if two subtype definitions are fully conformant. Used\n    --  for entry family conformance checks (RM 6.3.1 (24)).\n \n+   procedure Install_Formals (Id : Entity_Id);\n+   --  On entry to a subprogram body, make the formals visible. Note that\n+   --  simply placing the subprogram on the scope stack is not sufficient:\n+   --  the formals must become the current entities for their names. This\n+   --  procedure is also used to get visibility to the formals when analyzing\n+   --  preconditions and postconditions appearing in the spec.\n+\n    function Mode_Conformant (New_Id, Old_Id : Entity_Id) return Boolean;\n    --  Determine whether two callable entities (subprograms, entries,\n    --  literals) are mode conformant (RM 6.3.1(15))"}, {"sha": "ad03cdb5beaff6f77cffbc8b52300be23dee38aa", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 102, "deletions": 40, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -848,10 +848,8 @@ package body Sem_Ch8 is\n         and then Nkind (Nam) in N_Has_Entity\n       then\n          declare\n-            Error_Node  : Node_Id;\n             Nam_Decl    : Node_Id;\n             Nam_Ent     : Entity_Id;\n-            Subtyp_Decl : Node_Id;\n \n          begin\n             if Nkind (Nam) = N_Attribute_Reference then\n@@ -861,7 +859,6 @@ package body Sem_Ch8 is\n             end if;\n \n             Nam_Decl    := Parent (Nam_Ent);\n-            Subtyp_Decl := Parent (Etype (Nam_Ent));\n \n             if Has_Null_Exclusion (N)\n               and then not Has_Null_Exclusion (Nam_Decl)\n@@ -876,32 +873,17 @@ package body Sem_Ch8 is\n                if Is_Formal_Object (Nam_Ent)\n                  and then In_Generic_Scope (Id)\n                then\n-                  if Present (Subtype_Mark (Nam_Decl)) then\n-                     Error_Node := Subtype_Mark (Nam_Decl);\n-                  else\n-                     pragma Assert\n-                       (Ada_Version >= Ada_05\n-                          and then Present (Access_Definition (Nam_Decl)));\n-\n-                     Error_Node := Access_Definition (Nam_Decl);\n-                  end if;\n-\n-                  Error_Msg_N\n-                    (\"`NOT NULL` required in formal object declaration\",\n-                     Error_Node);\n-                  Error_Msg_Sloc := Sloc (N);\n                   Error_Msg_N\n-                    (\"\\because of renaming # (RM 8.5.4(4))\", Error_Node);\n+                    (\"renamed formal does not exclude `NULL` \"\n+                     & \"(RM 8.5.1(4.6/2))\", N);\n \n                --  Ada 2005 (AI-423): Otherwise, the subtype of the object name\n                --  shall exclude null.\n \n-               elsif Nkind (Subtyp_Decl) = N_Subtype_Declaration\n-                 and then not Has_Null_Exclusion (Subtyp_Decl)\n-               then\n+               elsif not Can_Never_Be_Null (Etype (Nam_Ent)) then\n                   Error_Msg_N\n-                    (\"`NOT NULL` required for subtype & (RM 8.5.1(4.6/2))\",\n-                     Defining_Identifier (Subtyp_Decl));\n+                    (\"renamed object does not exclude `NULL` \"\n+                     & \"(RM 8.5.1(4.6/2))\", N);\n                end if;\n             end if;\n          end;\n@@ -964,6 +946,11 @@ package body Sem_Ch8 is\n       then\n          null;\n \n+      --  Allow internally generated x'Reference expression\n+\n+      elsif Nkind (Nam) = N_Reference then\n+         null;\n+\n       else\n          Error_Msg_N (\"expect object name in renaming\", Nam);\n       end if;\n@@ -3205,6 +3192,8 @@ package body Sem_Ch8 is\n          elsif not Redundant_Use (Id) then\n             Set_In_Use (T, False);\n             Set_In_Use (Base_Type (T), False);\n+            Set_Current_Use_Clause (T, Empty);\n+            Set_Current_Use_Clause (Base_Type (T), Empty);\n             Op_List := Collect_Primitive_Operations (T);\n \n             Elmt := First_Elmt (Op_List);\n@@ -3582,15 +3571,12 @@ package body Sem_Ch8 is\n             declare\n                Case_Stm : constant Node_Id   := Parent (Parent (N));\n                Case_Typ : constant Entity_Id := Etype (Expression (Case_Stm));\n-               Case_Rtp : constant Entity_Id := Root_Type (Case_Typ);\n \n                Lit : Node_Id;\n \n             begin\n                if Is_Enumeration_Type (Case_Typ)\n-                 and then Case_Rtp /= Standard_Character\n-                 and then Case_Rtp /= Standard_Wide_Character\n-                 and then Case_Rtp /= Standard_Wide_Wide_Character\n+                 and then not Is_Standard_Character_Type (Case_Typ)\n                then\n                   Lit := First_Literal (Case_Typ);\n                   Get_Name_String (Chars (Lit));\n@@ -4121,6 +4107,17 @@ package body Sem_Ch8 is\n             if Is_Object (E) and then Present (Renamed_Object (E)) then\n                Generate_Reference (E, N);\n \n+               --  If the renamed entity is a private protected component,\n+               --  reference the original component as well. This needs to be\n+               --  done because the private renamings are installed before any\n+               --  analysis has occured. Reference to a private component will\n+               --  resolve to the renaming and the original component will be\n+               --  left unreferenced, hence the following.\n+\n+               if Is_Prival (E) then\n+                  Generate_Reference (Prival_Link (E), N);\n+               end if;\n+\n             --  One odd case is that we do not want to set the Referenced flag\n             --  if the entity is a label, and the identifier is the label in\n             --  the source, since this is not a reference from the point of\n@@ -4149,8 +4146,8 @@ package body Sem_Ch8 is\n             --    (because implicit derefences cannot be identified prior to\n             --    full type resolution).\n             --\n-            --  ??? The Is_Actual_Parameter routine takes care of one of these\n-            --    cases but there are others probably\n+            --    The Is_Actual_Parameter routine takes care of one of these\n+            --    cases but there are others probably ???\n \n             else\n                if not Is_Actual_Parameter then\n@@ -4170,7 +4167,10 @@ package body Sem_Ch8 is\n             --  processing a generic spec or body, because the discriminal\n             --  has not been not generated in this case.\n \n-            if not In_Default_Expression\n+            --  The replacement is also skipped if we are in special\n+            --  spec-expression mode. Why is this skipped in this case ???\n+\n+            if not In_Spec_Expression\n               or else Ekind (E) /= E_Discriminant\n               or else Inside_A_Generic\n             then\n@@ -4531,7 +4531,7 @@ package body Sem_Ch8 is\n          else\n             Error_Msg_N\n               (\"limited withed package can only be used to access \"\n-               & \" incomplete types\",\n+               & \"incomplete types\",\n                 N);\n          end if;\n       end if;\n@@ -5535,14 +5535,10 @@ package body Sem_Ch8 is\n       end if;\n \n       Id := First_Entity (P);\n-\n       while Present (Id)\n         and then Id /= Priv_Id\n       loop\n-         if Is_Character_Type (Id)\n-           and then (Root_Type (Id) = Standard_Character\n-                       or else Root_Type (Id) = Standard_Wide_Character\n-                       or else Root_Type (Id) = Standard_Wide_Wide_Character)\n+         if Is_Standard_Character_Type (Id)\n            and then Id = Base_Type (Id)\n          then\n             --  We replace the node with the literal itself, resolve as a\n@@ -6163,8 +6159,9 @@ package body Sem_Ch8 is\n          Write_Info;\n       end if;\n \n-      Scope_Suppress := SST.Save_Scope_Suppress;\n+      Scope_Suppress           := SST.Save_Scope_Suppress;\n       Local_Suppress_Stack_Top := SST.Save_Local_Suppress_Stack_Top;\n+      Check_Policy_List        := SST.Save_Check_Policy_List;\n \n       if Debug_Flag_W then\n          Write_Str (\"--> exiting scope: \");\n@@ -6236,6 +6233,7 @@ package body Sem_Ch8 is\n          SST.Entity                        := S;\n          SST.Save_Scope_Suppress           := Scope_Suppress;\n          SST.Save_Local_Suppress_Stack_Top := Local_Suppress_Stack_Top;\n+         SST.Save_Check_Policy_List        := Check_Policy_List;\n \n          if Scope_Stack.Last > Scope_Stack.First then\n             SST.Component_Alignment_Default := Scope_Stack.Table\n@@ -6965,6 +6963,7 @@ package body Sem_Ch8 is\n \n       elsif not Redundant_Use (Id) then\n          Set_In_Use (T);\n+         Set_Current_Use_Clause (T, Parent (Id));\n          Op_List := Collect_Primitive_Operations (T);\n \n          Elmt := First_Elmt (Op_List);\n@@ -7000,9 +6999,72 @@ package body Sem_Ch8 is\n          --  The type already has a use clause\n \n          if In_Use (T) then\n-            Error_Msg_NE\n-              (\"& is already use-visible through previous use type clause?\",\n-               Id, Id);\n+            if Present (Current_Use_Clause (T)) then\n+               declare\n+                  Clause1 : constant Node_Id := Parent (Id);\n+                  Clause2 : constant Node_Id := Current_Use_Clause (T);\n+                  Err_No  : Node_Id;\n+                  Unit1   : Node_Id;\n+                  Unit2   : Node_Id;\n+\n+               begin\n+                  if Nkind (Parent (Clause1)) = N_Compilation_Unit\n+                    and then Nkind (Parent (Clause2)) = N_Compilation_Unit\n+                  then\n+                     --  There is a redundant use type clause in a child unit.\n+                     --  Determine which of the units is more deeply nested.\n+\n+                     Unit1 := Defining_Entity (Unit (Parent (Clause1)));\n+                     Unit2 := Defining_Entity (Unit (Parent (Clause2)));\n+\n+                     if Scope (Unit2) = Standard_Standard  then\n+                        Error_Msg_Sloc := Sloc (Current_Use_Clause (T));\n+                        Err_No := Clause1;\n+\n+                     elsif Scope (Unit1) = Standard_Standard then\n+                        Error_Msg_Sloc := Sloc (Id);\n+                        Err_No := Clause2;\n+\n+                     else\n+                        --  Determine which is the descendant unit\n+\n+                        declare\n+                           S1, S2 : Entity_Id;\n+\n+                        begin\n+                           S1 := Scope (Unit1);\n+                           S2 := Scope (Unit2);\n+                           while S1 /= Standard_Standard\n+                             and then S2 /= Standard_Standard\n+                           loop\n+                              S1 := Scope (S1);\n+                              S2 := Scope (S2);\n+                           end loop;\n+\n+                           if S1 = Standard_Standard then\n+                              Error_Msg_Sloc := Sloc (Id);\n+                              Err_No := Clause2;\n+                           else\n+                              Error_Msg_Sloc := Sloc (Current_Use_Clause (T));\n+                              Err_No := Clause1;\n+                           end if;\n+                        end;\n+                     end if;\n+\n+                     Error_Msg_NE\n+                       (\"& is already use-visible through previous \"\n+                        & \"use_type_clause #?\", Err_No, Id);\n+                  else\n+                     Error_Msg_NE\n+                       (\"& is already use-visible through previous use type \"\n+                        & \"clause?\", Id, Id);\n+                  end if;\n+               end;\n+            else\n+               Error_Msg_NE\n+                 (\"& is already use-visible through previous use type \"\n+                  & \"clause?\", Id, Id);\n+            end if;\n \n          --  The package where T is declared is already used\n "}, {"sha": "4dba98da769a53eb2bca3a9a0340db0ec924a795", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 701, "deletions": 161, "changes": 862, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -40,7 +40,6 @@ with Exp_Dist; use Exp_Dist;\n with Lib;      use Lib;\n with Lib.Writ; use Lib.Writ;\n with Lib.Xref; use Lib.Xref;\n-with Namet;    use Namet;\n with Namet.Sp; use Namet.Sp;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -50,7 +49,9 @@ with Restrict; use Restrict;\n with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n+with Sem_Aux;  use Sem_Aux;\n with Sem_Ch3;  use Sem_Ch3;\n+with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Dist; use Sem_Dist;\n@@ -173,6 +174,14 @@ package body Sem_Prag is\n    --  (the original one, following the renaming chain) is returned.\n    --  Otherwise the entity is returned unchanged. Should be in Einfo???\n \n+   function Get_Pragma_Arg (Arg : Node_Id) return Node_Id;\n+   --  All the routines that check pragma arguments take either a pragma\n+   --  argument association (in which case the expression of the argument\n+   --  association is checked), or the expression directly. The function\n+   --  Get_Pragma_Arg is a utility used to deal with these two cases. If Arg\n+   --  is a pragma argument association node, then its expression is returned,\n+   --  otherwise Arg is returned unchanged.\n+\n    procedure rv;\n    --  This is a dummy function called by the processing for pragma Reviewable.\n    --  It is there for assisting front end debugging. By placing a Reviewable\n@@ -230,6 +239,41 @@ package body Sem_Prag is\n       end if;\n    end Adjust_External_Name_Case;\n \n+   ------------------------------\n+   -- Analyze_PPC_In_Decl_Part --\n+   ------------------------------\n+\n+   procedure Analyze_PPC_In_Decl_Part (N : Node_Id; S : Entity_Id) is\n+      Arg1 : constant Node_Id :=\n+               First (Pragma_Argument_Associations (N));\n+      Arg2 : constant Node_Id := Next (Arg1);\n+\n+   begin\n+      --  Install formals and push subprogram spec onto scope stack\n+      --  so that we can see the formals from the pragma.\n+\n+      Install_Formals (S);\n+      Push_Scope (S);\n+\n+      --  Preanalyze the boolean expression, we treat this as a\n+      --  spec expression (i.e. similar to a default expression).\n+\n+      Preanalyze_Spec_Expression\n+        (Get_Pragma_Arg (Arg1), Standard_Boolean);\n+\n+      --  If there is a message argument, analyze it the same way\n+\n+      if Present (Arg2) then\n+         Preanalyze_Spec_Expression\n+           (Get_Pragma_Arg (Arg2), Standard_String);\n+      end if;\n+\n+      --  Remove the subprogram from the scope stack now that the\n+      --  pre-analysis of the precondition/postcondition is done.\n+\n+      End_Scope;\n+   end Analyze_PPC_In_Decl_Part;\n+\n    --------------------\n    -- Analyze_Pragma --\n    --------------------\n@@ -312,6 +356,7 @@ package body Sem_Prag is\n \n       procedure Check_Arg_Is_One_Of (Arg : Node_Id; N1, N2 : Name_Id);\n       procedure Check_Arg_Is_One_Of (Arg : Node_Id; N1, N2, N3 : Name_Id);\n+      procedure Check_Arg_Is_One_Of (Arg : Node_Id; N1, N2, N3, N4 : Name_Id);\n       --  Check the specified argument Arg to make sure that it is an\n       --  identifier whose name matches either N1 or N2 (or N3 if present).\n       --  If not then give error and raise Pragma_Exit.\n@@ -364,7 +409,7 @@ package body Sem_Prag is\n \n       procedure Check_In_Main_Program;\n       --  Common checks for pragmas that appear within a main program\n-      --  (Priority, Main_Storage, Time_Slice).\n+      --  (Priority, Main_Storage, Time_Slice, Relative_Deadline).\n \n       procedure Check_Interrupt_Or_Attach_Handler;\n       --  Common processing for first argument of pragma Interrupt_Handler\n@@ -397,6 +442,30 @@ package body Sem_Prag is\n       --  In this version of the procedure, the identifier name is given as\n       --  a string with lower case letters.\n \n+      procedure Check_Precondition_Postcondition (In_Body : out Boolean);\n+      --  Called to process a precondition or postcondition pragma. There are\n+      --  three cases:\n+      --\n+      --    The pragma appears after a subprogram spec\n+      --\n+      --      If the corresponding check is not enabled, the pragma is analyzed\n+      --      but otherwise ignored and control returns with In_Body set False.\n+      --\n+      --      If the check is enabled, then the first step is to analyze the\n+      --      pragma, but this is skipped if the subprogram spec appears within\n+      --      a package specification (because this is the case where we delay\n+      --      analysis till the end of the spec). Then (whether or not it was\n+      --      analyzed), the pragma is chained to the subprogram in question\n+      --      (using Spec_PPC_List and Next_Pragma) and control returns to the\n+      --      caller with In_Body set False.\n+      --\n+      --    The pragma appears at the start of subprogram body declarations\n+      --\n+      --      In this case an immediate return to the caller is made with\n+      --      In_Body set True, and the pragma is NOT analyzed.\n+      --\n+      --    In all other cases, an error message for bad placement is given\n+\n       procedure Check_Static_Constraint (Constr : Node_Id);\n       --  Constr is a constraint from an N_Subtype_Indication node from a\n       --  component constraint in an Unchecked_Union type. This routine checks\n@@ -484,14 +553,6 @@ package body Sem_Prag is\n       --  optional identifiers when it returns). An entry in Args is Empty\n       --  on return if the corresponding argument is not present.\n \n-      function Get_Pragma_Arg (Arg : Node_Id) return Node_Id;\n-      --  All the routines that check pragma arguments take either a pragma\n-      --  argument association (in which case the expression of the argument\n-      --  association is checked), or the expression directly. The function\n-      --  Get_Pragma_Arg is a utility used to deal with these two cases. If\n-      --  Arg is a pragma argument association node, then its expression is\n-      --  returned, otherwise Arg is returned unchanged.\n-\n       procedure GNAT_Pragma;\n       --  Called for all GNAT defined pragmas to check the relevant restriction\n       --  (No_Implementation_Pragmas).\n@@ -856,6 +917,24 @@ package body Sem_Prag is\n          end if;\n       end Check_Arg_Is_One_Of;\n \n+      procedure Check_Arg_Is_One_Of\n+        (Arg            : Node_Id;\n+         N1, N2, N3, N4 : Name_Id)\n+      is\n+         Argx : constant Node_Id := Get_Pragma_Arg (Arg);\n+\n+      begin\n+         Check_Arg_Is_Identifier (Argx);\n+\n+         if Chars (Argx) /= N1\n+           and then Chars (Argx) /= N2\n+           and then Chars (Argx) /= N3\n+           and then Chars (Argx) /= N4\n+         then\n+            Error_Pragma_Arg (\"invalid argument for pragma%\", Argx);\n+         end if;\n+      end Check_Arg_Is_One_Of;\n+\n       ---------------------------------\n       -- Check_Arg_Is_Queuing_Policy --\n       ---------------------------------\n@@ -1256,6 +1335,91 @@ package body Sem_Prag is\n          Check_Optional_Identifier (Arg, Name_Find);\n       end Check_Optional_Identifier;\n \n+      --------------------------------------\n+      -- Check_Precondition_Postcondition --\n+      --------------------------------------\n+\n+      procedure Check_Precondition_Postcondition (In_Body : out Boolean) is\n+         P  : Node_Id;\n+         S  : Entity_Id;\n+         PO : Node_Id;\n+\n+      begin\n+         if not Is_List_Member (N) then\n+            Pragma_Misplaced;\n+         end if;\n+\n+         --  Record whether pragma is enabled\n+\n+         Set_PPC_Enabled (N, Check_Enabled (Pname));\n+\n+         --  Search prior declarations\n+\n+         P := N;\n+         while Present (Prev (P)) loop\n+            P := Prev (P);\n+            PO := Original_Node (P);\n+\n+            --  Skip past prior pragma\n+\n+            if Nkind (PO) = N_Pragma then\n+               null;\n+\n+            --  Skip stuff not coming from source\n+\n+            elsif not Comes_From_Source (PO) then\n+               null;\n+\n+            --  Here if we hit a subprogram declaration\n+\n+            elsif Nkind (PO) = N_Subprogram_Declaration then\n+               S := Defining_Unit_Name (Specification (PO));\n+\n+               --  Analyze the pragma unless it appears within a package spec,\n+               --  which is the case where we delay the analysis of the PPC\n+               --  until the end of the package declarations (for details,\n+               --  see Analyze_Package_Specification.Analyze_PPCs).\n+\n+               if Ekind (Scope (S)) /= E_Package\n+                    and then\n+                  Ekind (Scope (S)) /= E_Generic_Package\n+               then\n+                  Analyze_PPC_In_Decl_Part (N, S);\n+               end if;\n+\n+               --  Chain spec PPC pragma to list for subprogram\n+\n+               Set_Next_Pragma (N, Spec_PPC_List (S));\n+               Set_Spec_PPC_List (S, N);\n+\n+               --  Return indicating spec case\n+\n+               In_Body := False;\n+               return;\n+\n+            --  If we encounter any other declaration moving back, misplaced\n+\n+            else\n+               Pragma_Misplaced;\n+            end if;\n+         end loop;\n+\n+         --  If we fall through loop, pragma is at start of list, so see if\n+         --  it is at the start of declarations of a subprogram body.\n+\n+         if Nkind (Parent (N)) = N_Subprogram_Body\n+           and then List_Containing (N) = Declarations (Parent (N))\n+         then\n+            In_Body := True;\n+            return;\n+\n+         --  If not, it was misplaced\n+\n+         else\n+            Pragma_Misplaced;\n+         end if;\n+      end Check_Precondition_Postcondition;\n+\n       -----------------------------\n       -- Check_Static_Constraint --\n       -----------------------------\n@@ -1267,13 +1431,13 @@ package body Sem_Prag is\n \n       procedure Check_Static_Constraint (Constr : Node_Id) is\n \n+         procedure Require_Static (E : Node_Id);\n+         --  Require given expression to be static expression\n+\n          --------------------\n          -- Require_Static --\n          --------------------\n \n-         procedure Require_Static (E : Node_Id);\n-         --  Require given expression to be static expression\n-\n          procedure Require_Static (E : Node_Id) is\n          begin\n             if not Is_OK_Static_Expression (E) then\n@@ -1743,19 +1907,6 @@ package body Sem_Prag is\n          end loop;\n       end Gather_Associations;\n \n-      --------------------\n-      -- Get_Pragma_Arg --\n-      --------------------\n-\n-      function Get_Pragma_Arg (Arg : Node_Id) return Node_Id is\n-      begin\n-         if Nkind (Arg) = N_Pragma_Argument_Association then\n-            return Expression (Arg);\n-         else\n-            return Arg;\n-         end if;\n-      end Get_Pragma_Arg;\n-\n       -----------------\n       -- GNAT_Pragma --\n       -----------------\n@@ -1895,10 +2046,10 @@ package body Sem_Prag is\n          Utyp : Entity_Id;\n \n          procedure Set_Atomic (E : Entity_Id);\n-         --  Set given type as atomic, and if no explicit alignment was\n-         --  given, set alignment to unknown, since back end knows what\n-         --  the alignment requirements are for atomic arrays. Note that\n-         --  this step is necessary for derived types.\n+         --  Set given type as atomic, and if no explicit alignment was given,\n+         --  set alignment to unknown, since back end knows what the alignment\n+         --  requirements are for atomic arrays. Note: this step is necessary\n+         --  for derived types.\n \n          ----------------\n          -- Set_Atomic --\n@@ -1946,9 +2097,8 @@ package body Sem_Prag is\n                Set_Atomic (Base_Type (E));\n             end if;\n \n-            --  Attribute belongs on the base type. If the\n-            --  view of the type is currently private, it also\n-            --  belongs on the underlying type.\n+            --  Attribute belongs on the base type. If the view of the type is\n+            --  currently private, it also belongs on the underlying type.\n \n             Set_Is_Volatile (Base_Type (E));\n             Set_Is_Volatile (Underlying_Type (E));\n@@ -1967,10 +2117,9 @@ package body Sem_Prag is\n             if Prag_Id /= Pragma_Volatile then\n                Set_Is_Atomic (E);\n \n-               --  If the object declaration has an explicit\n-               --  initialization, a temporary may have to be\n-               --  created to hold the expression, to insure\n-               --  that access to the object remain atomic.\n+               --  If the object declaration has an explicit initialization, a\n+               --  temporary may have to be created to hold the expression, to\n+               --  ensure that access to the object remain atomic.\n \n                if Nkind (Parent (E)) = N_Object_Declaration\n                  and then Present (Expression (Parent (E)))\n@@ -2389,8 +2538,12 @@ package body Sem_Prag is\n                E1 := Homonym (E1);\n                exit when No (E1) or else Scope (E1) /= Current_Scope;\n \n+               --  Do not set the pragma on inherited operations or on\n+               --  formal subprograms.\n+\n                if Comes_From_Source (E1)\n                  and then Comp_Unit = Get_Source_Unit (E1)\n+                 and then not Is_Formal_Subprogram (E1)\n                  and then Nkind (Original_Node (Parent (E1))) /=\n                    N_Full_Type_Declaration\n                then\n@@ -2617,7 +2770,7 @@ package body Sem_Prag is\n                   \"\\no initialization allowed for & declared#\", Arg1);\n             else\n                Set_Imported (Def_Id);\n-               Note_Possible_Modification (Arg_Internal);\n+               Note_Possible_Modification (Arg_Internal, Sure => False);\n             end if;\n          end if;\n       end Process_Extended_Import_Export_Object_Pragma;\n@@ -3126,7 +3279,7 @@ package body Sem_Prag is\n       begin\n          Process_Convention (C, Def_Id);\n          Kill_Size_Check_Code (Def_Id);\n-         Note_Possible_Modification (Expression (Arg2));\n+         Note_Possible_Modification (Expression (Arg2), Sure => False);\n \n          if Ekind (Def_Id) = E_Variable\n               or else\n@@ -3470,29 +3623,36 @@ package body Sem_Prag is\n                return;\n \n             --  Here we have a candidate for inlining, but we must exclude\n-            --  derived operations. Otherwise we will end up trying to\n-            --  inline a phantom declaration, and the result would be to\n-            --  drag in a body which has no direct inlining associated with\n-            --  it. That would not only be inefficient but would also result\n-            --  in the backend doing cross-unit inlining in cases where it\n-            --  was definitely inappropriate to do so.\n-\n-            --  However, a simple Comes_From_Source test is insufficient,\n-            --  since we do want to allow inlining of generic instances,\n-            --  which also do not come from source. Predefined operators do\n-            --  not come from source but are not inlineable either.\n+            --  derived operations. Otherwise we would end up trying to inline\n+            --  a phantom declaration, and the result would be to drag in a\n+            --  body which has no direct inlining associated with it. That\n+            --  would not only be inefficient but would also result in the\n+            --  backend doing cross-unit inlining in cases where it was\n+            --  definitely inappropriate to do so.\n+\n+            --  However, a simple Comes_From_Source test is insufficient, since\n+            --  we do want to allow inlining of generic instances which also do\n+            --  not come from source. We also need to recognize specs\n+            --  generated by the front-end for bodies that carry the pragma.\n+            --  Finally, predefined operators do not come from source but are\n+            --  not inlineable either.\n+\n+            elsif Is_Generic_Instance (Subp)\n+              or else Nkind (Parent (Parent (Subp))) = N_Subprogram_Declaration\n+            then\n+               null;\n \n             elsif not Comes_From_Source (Subp)\n-              and then not Is_Generic_Instance (Subp)\n               and then Scope (Subp) /= Standard_Standard\n             then\n                Applies := True;\n                return;\n+            end if;\n \n             --  The referenced entity must either be the enclosing entity,\n             --  or an entity declared within the current open scope.\n \n-            elsif Present (Scope (Subp))\n+            if Present (Scope (Subp))\n               and then Scope (Subp) /= Current_Scope\n               and then Subp /= Current_Scope\n             then\n@@ -3884,13 +4044,40 @@ package body Sem_Prag is\n                    (Process_Restriction_Synonyms (Expr));\n \n                if R_Id not in All_Boolean_Restrictions then\n-                  Error_Pragma_Arg\n-                    (\"invalid restriction identifier\", Arg);\n+                  Error_Msg_Name_1 := Pname;\n+                  Error_Msg_N\n+                    (\"invalid restriction identifier&\", Get_Pragma_Arg (Arg));\n+\n+                  --  Check for possible misspelling\n+\n+                  for J in Restriction_Id loop\n+                     declare\n+                        Rnm : constant String := Restriction_Id'Image (J);\n+\n+                     begin\n+                        Name_Buffer (1 .. Rnm'Length) := Rnm;\n+                        Name_Len := Rnm'Length;\n+                        Set_Casing (All_Lower_Case);\n+\n+                        if Is_Bad_Spelling_Of (Chars (Expr), Name_Enter) then\n+                           Set_Casing\n+                             (Identifier_Casing (Current_Source_File));\n+                           Error_Msg_String (1 .. Rnm'Length) :=\n+                             Name_Buffer (1 .. Name_Len);\n+                           Error_Msg_Strlen := Rnm'Length;\n+                           Error_Msg_N\n+                             (\"\\possible misspelling of \"\"~\"\"\",\n+                              Get_Pragma_Arg (Arg));\n+                           exit;\n+                        end if;\n+                     end;\n+                  end loop;\n+\n+                  raise Pragma_Exit;\n                end if;\n \n                if Implementation_Restriction (R_Id) then\n-                  Check_Restriction\n-                    (No_Implementation_Restrictions, Arg);\n+                  Check_Restriction (No_Implementation_Restrictions, Arg);\n                end if;\n \n                --  If this is a warning, then set the warning unless we already\n@@ -4840,7 +5027,7 @@ package body Sem_Prag is\n \n          when Pragma_Assert => Assert : declare\n             Expr : Node_Id;\n-            Eloc : Source_Ptr;\n+            Newa : List_Id;\n \n          begin\n             Ada_2005_Pragma;\n@@ -4849,71 +5036,33 @@ package body Sem_Prag is\n             Check_Arg_Order ((Name_Check, Name_Message));\n             Check_Optional_Identifier (Arg1, Name_Check);\n \n-            if Arg_Count > 1 then\n-               Check_Optional_Identifier (Arg2, Name_Message);\n-               Check_Arg_Is_Static_Expression (Arg2, Standard_String);\n-            end if;\n-\n-            --  If expansion is active and assertions are inactive, then\n-            --  we rewrite the Assertion as:\n+            --  We treat pragma Assert as equivalent to:\n \n-            --    if False and then condition then\n-            --       null;\n-            --    end if;\n+            --    pragma Check (Assertion, condition [, msg]);\n \n-            --  The reason we do this rewriting during semantic analysis rather\n-            --  than as part of normal expansion is that we cannot analyze and\n-            --  expand the code for the boolean expression directly, or it may\n-            --  cause insertion of actions that would escape the attempt to\n-            --  suppress the assertion code.\n+            --  So rewrite pragma in this manner, and analyze the result\n \n-            --  Note that the Sloc for the if statement corresponds to the\n-            --  argument condition, not the pragma itself. The reason for this\n-            --  is that we may generate a warning if the condition is False at\n-            --  compile time, and we do not want to delete this warning when we\n-            --  delete the if statement.\n+            Expr := Get_Pragma_Arg (Arg1);\n+            Newa := New_List (\n+              Make_Pragma_Argument_Association (Loc,\n+                Expression =>\n+                  Make_Identifier (Loc,\n+                    Chars => Name_Assertion)),\n \n-            Expr := Expression (Arg1);\n-            Eloc := Sloc (Expr);\n+              Make_Pragma_Argument_Association (Sloc (Expr),\n+                Expression => Expr));\n \n-            if Expander_Active and not Assertions_Enabled then\n-               Rewrite (N,\n-                 Make_If_Statement (Eloc,\n-                   Condition =>\n-                     Make_And_Then (Eloc,\n-                       Left_Opnd  => New_Occurrence_Of (Standard_False, Eloc),\n-                       Right_Opnd => Expr),\n-                   Then_Statements => New_List (\n-                     Make_Null_Statement (Eloc))));\n-\n-               Analyze (N);\n-\n-            --  Otherwise (if assertions are enabled, or if we are not\n-            --  operating with expansion active), then we just analyze\n-            --  and resolve the expression.\n-\n-            else\n-               Analyze_And_Resolve (Expr, Any_Boolean);\n+            if Arg_Count > 1 then\n+               Check_Optional_Identifier (Arg2, Name_Message);\n+               Analyze_And_Resolve (Get_Pragma_Arg (Arg2), Standard_String);\n+               Append_To (Newa, Relocate_Node (Arg2));\n             end if;\n \n-            --  If assertion is of the form (X'First = literal), where X is\n-            --  formal parameter, then set Low_Bound_Known flag on this formal.\n-\n-            if Nkind (Expr) = N_Op_Eq then\n-               declare\n-                  Right : constant Node_Id := Right_Opnd (Expr);\n-                  Left  : constant Node_Id := Left_Opnd  (Expr);\n-               begin\n-                  if Nkind (Left) = N_Attribute_Reference\n-                    and then Attribute_Name (Left) = Name_First\n-                    and then Is_Entity_Name (Prefix (Left))\n-                    and then Is_Formal (Entity (Prefix (Left)))\n-                    and then Nkind (Right) = N_Integer_Literal\n-                  then\n-                     Set_Low_Bound_Known (Entity (Prefix (Left)));\n-                  end if;\n-               end;\n-            end if;\n+            Rewrite (N,\n+              Make_Pragma (Loc,\n+                Chars => Name_Check,\n+                Pragma_Argument_Associations => Newa));\n+            Analyze (N);\n          end Assert;\n \n          ----------------------\n@@ -4922,11 +5071,44 @@ package body Sem_Prag is\n \n          --  pragma Assertion_Policy (Check | Ignore)\n \n-         when Pragma_Assertion_Policy =>\n+         when Pragma_Assertion_Policy => Assertion_Policy : declare\n+            Policy : Node_Id;\n+\n+         begin\n             Ada_2005_Pragma;\n+            Check_Valid_Configuration_Pragma;\n             Check_Arg_Count (1);\n+            Check_No_Identifiers;\n             Check_Arg_Is_One_Of (Arg1, Name_Check, Name_Ignore);\n-            Assertions_Enabled := Chars (Expression (Arg1)) = Name_Check;\n+\n+            --  We treat pragma Assertion_Policy as equivalent to:\n+\n+            --    pragma Check_Policy (Assertion, policy)\n+\n+            --  So rewrite the pragma in that manner and link on to the chain\n+            --  of Check_Policy pragmas, marking the pragma as analyzed.\n+\n+            Policy := Get_Pragma_Arg (Arg1);\n+\n+            Rewrite (N,\n+              Make_Pragma (Loc,\n+                Chars => Name_Check_Policy,\n+\n+                Pragma_Argument_Associations => New_List (\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Expression =>\n+                      Make_Identifier (Loc,\n+                        Chars => Name_Assertion)),\n+\n+                  Make_Pragma_Argument_Association (Loc,\n+                    Expression =>\n+                      Make_Identifier (Sloc (Policy),\n+                        Chars => Chars (Policy))))));\n+\n+            Set_Analyzed (N);\n+            Set_Next_Pragma (N, Opt.Check_Policy_List);\n+            Opt.Check_Policy_List := N;\n+         end Assertion_Policy;\n \n          ---------------\n          -- AST_Entry --\n@@ -5237,7 +5419,7 @@ package body Sem_Prag is\n                               New_Copy_Tree (Expression (Arg2));\n                   begin\n                      Set_Parent (Temp, N);\n-                     Pre_Analyze_And_Resolve (Temp, RTE (RE_Interrupt_ID));\n+                     Preanalyze_And_Resolve (Temp, RTE (RE_Interrupt_ID));\n                   end;\n \n                else\n@@ -5285,6 +5467,97 @@ package body Sem_Prag is\n             end if;\n          end C_Pass_By_Copy;\n \n+         -----------\n+         -- Check --\n+         -----------\n+\n+         --  pragma Check ([Name    =>] Identifier,\n+         --                [Check   =>] Boolean_Expression\n+         --              [,[Message =>] String_Expression]);\n+\n+         when Pragma_Check => Check : declare\n+            Expr : Node_Id;\n+            Eloc : Source_Ptr;\n+\n+            Check_On : Boolean;\n+            --  Set True if category of assertions referenced by Name enabled\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_At_Least_N_Arguments (2);\n+            Check_At_Most_N_Arguments (3);\n+            Check_Optional_Identifier (Arg1, Name_Name);\n+            Check_Optional_Identifier (Arg2, Name_Check);\n+\n+            if Arg_Count = 3 then\n+               Check_Optional_Identifier (Arg3, Name_Message);\n+               Analyze_And_Resolve (Get_Pragma_Arg (Arg3), Standard_String);\n+            end if;\n+\n+            Check_Arg_Is_Identifier (Arg1);\n+            Check_On := Check_Enabled (Chars (Get_Pragma_Arg (Arg1)));\n+\n+            --  If expansion is active and the check is not enabled then we\n+            --  rewrite the Check as:\n+\n+            --    if False and then condition then\n+            --       null;\n+            --    end if;\n+\n+            --  The reason we do this rewriting during semantic analysis rather\n+            --  than as part of normal expansion is that we cannot analyze and\n+            --  expand the code for the boolean expression directly, or it may\n+            --  cause insertion of actions that would escape the attempt to\n+            --  suppress the check code.\n+\n+            --  Note that the Sloc for the if statement corresponds to the\n+            --  argument condition, not the pragma itself. The reason for this\n+            --  is that we may generate a warning if the condition is False at\n+            --  compile time, and we do not want to delete this warning when we\n+            --  delete the if statement.\n+\n+            Expr := Expression (Arg2);\n+\n+            if Expander_Active and then not Check_On then\n+               Eloc := Sloc (Expr);\n+\n+               Rewrite (N,\n+                 Make_If_Statement (Eloc,\n+                   Condition =>\n+                     Make_And_Then (Eloc,\n+                       Left_Opnd  => New_Occurrence_Of (Standard_False, Eloc),\n+                       Right_Opnd => Expr),\n+                   Then_Statements => New_List (\n+                     Make_Null_Statement (Eloc))));\n+\n+               Analyze (N);\n+\n+            --  Check is active\n+\n+            else\n+               Analyze_And_Resolve (Expr, Any_Boolean);\n+            end if;\n+\n+            --  If assertion is of the form (X'First = literal), where X is\n+            --  a formal, then set Low_Bound_Known flag on this formal.\n+\n+            if Nkind (Expr) = N_Op_Eq then\n+               declare\n+                  Right : constant Node_Id := Right_Opnd (Expr);\n+                  Left  : constant Node_Id := Left_Opnd  (Expr);\n+               begin\n+                  if Nkind (Left) = N_Attribute_Reference\n+                    and then Attribute_Name (Left) = Name_First\n+                    and then Is_Entity_Name (Prefix (Left))\n+                    and then Is_Formal (Entity (Prefix (Left)))\n+                    and then Nkind (Right) = N_Integer_Literal\n+                  then\n+                     Set_Low_Bound_Known (Entity (Prefix (Left)));\n+                  end if;\n+               end;\n+            end if;\n+         end Check;\n+\n          ----------------\n          -- Check_Name --\n          ----------------\n@@ -5311,6 +5584,38 @@ package body Sem_Prag is\n                Check_Names.Append (Nam);\n             end;\n \n+         ------------------\n+         -- Check_Policy --\n+         ------------------\n+\n+         --  pragma Check_Policy ([Name =>] IDENTIFIER,\n+         --                       POLICY_IDENTIFIER;\n+\n+         --  POLICY_IDENTIFIER ::= ON | OFF | CHECK | IGNORE\n+\n+         --  Note: this is a configuration pragma, but it is allowed to\n+         --  appear anywhere else.\n+\n+         when Pragma_Check_Policy =>\n+            GNAT_Pragma;\n+            Check_Arg_Count (2);\n+            Check_No_Identifier (Arg2);\n+            Check_Optional_Identifier (Arg1, Name_Name);\n+            Check_Arg_Is_One_Of\n+              (Arg2, Name_On, Name_Off, Name_Check, Name_Ignore);\n+\n+            --  A Check_Policy pragma can appear either as a configuration\n+            --  pragma, or in a declarative part or a package spec (see RM\n+            --  11.5(5) for rules for Suppress/Unsuppress which are also\n+            --  followed for Check_Policy).\n+\n+            if not Is_Configuration_Pragma then\n+               Check_Is_In_Decl_Part_Or_Package_Spec;\n+            end if;\n+\n+            Set_Next_Pragma (N, Opt.Check_Policy_List);\n+            Opt.Check_Policy_List := N;\n+\n          ---------------------\n          -- CIL_Constructor --\n          ---------------------\n@@ -6219,11 +6524,27 @@ package body Sem_Prag is\n             Process_Convention (C, Def_Id);\n \n             if Ekind (Def_Id) /= E_Constant then\n-               Note_Possible_Modification (Expression (Arg2));\n+               Note_Possible_Modification (Expression (Arg2), Sure => False);\n             end if;\n \n             Process_Interface_Name (Def_Id, Arg3, Arg4);\n             Set_Exported (Def_Id, Arg2);\n+\n+            --  If the entity is a deferred constant, propagate the\n+            --  information to the full view, because gigi elaborates\n+            --  the full view only.\n+\n+            if Ekind (Def_Id) = E_Constant\n+              and then Present (Full_View (Def_Id))\n+            then\n+               declare\n+                  Id2 : constant Entity_Id := Full_View (Def_Id);\n+               begin\n+                  Set_Is_Exported    (Id2, Is_Exported          (Def_Id));\n+                  Set_First_Rep_Item (Id2, First_Rep_Item       (Def_Id));\n+                  Set_Interface_Name (Id2, Einfo.Interface_Name (Def_Id));\n+               end;\n+            end if;\n          end Export;\n \n          ----------------------\n@@ -6611,7 +6932,7 @@ package body Sem_Prag is\n             Check_At_Least_N_Arguments (2);\n             Check_At_Most_N_Arguments  (4);\n             Process_Convention (C, Def_Id);\n-            Note_Possible_Modification (Expression (Arg2));\n+            Note_Possible_Modification (Expression (Arg2), Sure => False);\n             Process_Interface_Name (Def_Id, Arg3, Arg4);\n             Set_Exported (Def_Id, Arg2);\n          end External;\n@@ -7431,12 +7752,12 @@ package body Sem_Prag is\n                Def_Id := Entity (Id);\n             end if;\n \n-            --  Special DEC-compatible processing for the object case,\n-            --  forces object to be imported.\n+            --  Special DEC-compatible processing for the object case, forces\n+            --  object to be imported.\n \n             if Ekind (Def_Id) = E_Variable then\n                Kill_Size_Check_Code (Def_Id);\n-               Note_Possible_Modification (Id);\n+               Note_Possible_Modification (Id, Sure => False);\n \n                --  Initialization is not allowed for imported variable\n \n@@ -7543,7 +7864,7 @@ package body Sem_Prag is\n                --  described in \"Handling of Default and Per-Object\n                --  Expressions\" in sem.ads.\n \n-               Analyze_Per_Use_Expression (Arg, RTE (RE_Interrupt_Priority));\n+               Preanalyze_Spec_Expression (Arg, RTE (RE_Interrupt_Priority));\n             end if;\n \n             if Nkind (P) /= N_Task_Definition\n@@ -8065,22 +8386,20 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_Arg_Count (1);\n             Check_Is_In_Decl_Part_Or_Package_Spec;\n+            Check_Arg_Is_Static_Expression (Arg1, Standard_String);\n+            Start_String (Strval (Expr_Value_S (Expression (Arg1))));\n+\n+            Arg := Arg2;\n+            while Present (Arg) loop\n+               Check_Arg_Is_Static_Expression (Arg, Standard_String);\n+               Store_String_Char (ASCII.NUL);\n+               Store_String_Chars (Strval (Expr_Value_S (Expression (Arg))));\n+               Arg := Next (Arg);\n+            end loop;\n \n             if Operating_Mode = Generate_Code\n               and then In_Extended_Main_Source_Unit (N)\n             then\n-               Check_Arg_Is_Static_Expression (Arg1, Standard_String);\n-               Start_String (Strval (Expr_Value_S (Expression (Arg1))));\n-\n-               Arg := Arg2;\n-               while Present (Arg) loop\n-                  Check_Arg_Is_Static_Expression (Arg, Standard_String);\n-                  Store_String_Char (ASCII.NUL);\n-                  Store_String_Chars\n-                    (Strval (Expr_Value_S (Expression (Arg))));\n-                  Arg := Next (Arg);\n-               end loop;\n-\n                Store_Linker_Option_String (End_String);\n             end if;\n          end Linker_Options;\n@@ -8372,7 +8691,7 @@ package body Sem_Prag is\n          --  it was misplaced.\n \n          when Pragma_No_Body =>\n-            Error_Pragma (\"misplaced pragma %\");\n+            Pragma_Misplaced;\n \n          ---------------\n          -- No_Return --\n@@ -8549,7 +8868,8 @@ package body Sem_Prag is\n                      end if;\n                   end loop;\n \n-                  Set_Obsolescent_Warning (Ent, Expression (Arg1));\n+                  Obsolescent_Warnings.Append\n+                    ((Ent => Ent, Msg => Strval (Expression (Arg1))));\n \n                   --  Check for Ada_05 parameter\n \n@@ -8760,6 +9080,12 @@ package body Sem_Prag is\n                end case;\n             end;\n \n+            --  Set indication that mode is set locally. If we are in fact in a\n+            --  configuration pragma file, this setting is harmless since the\n+            --  switch will get reset anyway at the start of each unit.\n+\n+            Optimize_Alignment_Local := True;\n+\n          ----------\n          -- Pack --\n          ----------\n@@ -9019,6 +9345,82 @@ package body Sem_Prag is\n             end if;\n          end Persistent_BSS;\n \n+         -------------------\n+         -- Postcondition --\n+         -------------------\n+\n+         --  pragma Postcondition ([Check   =>] Boolean_Expression\n+         --                      [,[Message =>] String_Expression]);\n+\n+         when Pragma_Postcondition => Postcondition : declare\n+            In_Body : Boolean;\n+            pragma Warnings (Off, In_Body);\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_At_Least_N_Arguments (1);\n+            Check_At_Most_N_Arguments (2);\n+            Check_Optional_Identifier (Arg1, Name_Check);\n+\n+            --  All we need to do here is call the common check procedure,\n+            --  the remainder of the processing is found in Sem_Ch6/Sem_Ch7.\n+\n+            Check_Precondition_Postcondition (In_Body);\n+         end Postcondition;\n+\n+         ------------------\n+         -- Precondition --\n+         ------------------\n+\n+         --  pragma Precondition ([Check   =>] Boolean_Expression\n+         --                     [,[Message =>] String_Expression]);\n+\n+         when Pragma_Precondition => Precondition : declare\n+            In_Body : Boolean;\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_At_Least_N_Arguments (1);\n+            Check_At_Most_N_Arguments (2);\n+            Check_Optional_Identifier (Arg1, Name_Check);\n+\n+            Check_Precondition_Postcondition (In_Body);\n+\n+            --  If in spec, nothing to do. If in body, then we convert the\n+            --  pragma to pragma Check (Precondition, cond [, msg]). Note we\n+            --  do this whether or not precondition checks are enabled. That\n+            --  works fine since pragma Check will do this check.\n+\n+            if In_Body then\n+               if Arg_Count = 2 then\n+                  Check_Optional_Identifier (Arg3, Name_Message);\n+                  Analyze_And_Resolve (Get_Pragma_Arg (Arg2), Standard_String);\n+               end if;\n+\n+               Analyze_And_Resolve (Get_Pragma_Arg (Arg1), Standard_Boolean);\n+\n+               Rewrite (N,\n+                 Make_Pragma (Loc,\n+                   Chars => Name_Check,\n+                   Pragma_Argument_Associations => New_List (\n+                     Make_Pragma_Argument_Association (Loc,\n+                       Expression =>\n+                         Make_Identifier (Loc,\n+                           Chars => Name_Precondition)),\n+\n+                     Make_Pragma_Argument_Association (Sloc (Arg1),\n+                       Expression => Relocate_Node (Get_Pragma_Arg (Arg1))))));\n+\n+               if Arg_Count = 2 then\n+                  Append_To (Pragma_Argument_Associations (N),\n+                    Make_Pragma_Argument_Association (Sloc (Arg2),\n+                      Expression => Relocate_Node (Get_Pragma_Arg (Arg2))));\n+               end if;\n+\n+               Analyze (N);\n+            end if;\n+         end Precondition;\n+\n          ------------------\n          -- Preelaborate --\n          ------------------\n@@ -9172,7 +9574,7 @@ package body Sem_Prag is\n                --  described in \"Handling of Default and Per-Object\n                --  Expressions\" in sem.ads.\n \n-               Analyze_Per_Use_Expression (Arg, Standard_Integer);\n+               Preanalyze_Spec_Expression (Arg, Standard_Integer);\n \n                if not Is_Static_Expression (Arg) then\n                   Check_Restriction (Static_Priorities, Arg);\n@@ -9339,7 +9741,7 @@ package body Sem_Prag is\n \n          --  pragma Profile (profile_IDENTIFIER);\n \n-         --  profile_IDENTIFIER => Protected | Ravenscar\n+         --  profile_IDENTIFIER => Restricted | Ravenscar\n \n          when Pragma_Profile =>\n             Ada_2005_Pragma;\n@@ -9365,7 +9767,7 @@ package body Sem_Prag is\n \n          --  pragma Profile_Warnings (profile_IDENTIFIER);\n \n-         --  profile_IDENTIFIER => Protected | Ravenscar\n+         --  profile_IDENTIFIER => Restricted | Ravenscar\n \n          when Pragma_Profile_Warnings =>\n             GNAT_Pragma;\n@@ -9699,6 +10101,55 @@ package body Sem_Prag is\n             end if;\n          end;\n \n+         -----------------------\n+         -- Relative_Deadline --\n+         -----------------------\n+\n+         --  pragma Relative_Deadline (time_span_EXPRESSION);\n+\n+         when Pragma_Relative_Deadline => Relative_Deadline : declare\n+            P   : constant Node_Id := Parent (N);\n+            Arg : Node_Id;\n+\n+         begin\n+            Ada_2005_Pragma;\n+            Check_No_Identifiers;\n+            Check_Arg_Count (1);\n+\n+            Arg := Expression (Arg1);\n+\n+            --  The expression must be analyzed in the special manner described\n+            --  in \"Handling of Default and Per-Object Expressions\" in sem.ads.\n+\n+            Preanalyze_Spec_Expression (Arg, RTE (RE_Time_Span));\n+\n+            --  Subprogram case\n+\n+            if Nkind (P) = N_Subprogram_Body then\n+               Check_In_Main_Program;\n+\n+            --  Tasks\n+\n+            elsif Nkind (P) = N_Task_Definition then\n+               null;\n+\n+            --  Anything else is incorrect\n+\n+            else\n+               Pragma_Misplaced;\n+            end if;\n+\n+            if Has_Relative_Deadline_Pragma (P) then\n+               Error_Pragma (\"duplicate pragma% not allowed\");\n+            else\n+               Set_Has_Relative_Deadline_Pragma (P, True);\n+\n+               if Nkind (P) = N_Task_Definition then\n+                  Record_Rep_Item (Defining_Identifier (Parent (P)), N);\n+               end if;\n+            end if;\n+         end Relative_Deadline;\n+\n          ---------------------------\n          -- Remote_Call_Interface --\n          ---------------------------\n@@ -9832,6 +10283,7 @@ package body Sem_Prag is\n          --  | restriction_parameter_IDENTIFIER => EXPRESSION\n \n          when Pragma_Restriction_Warnings =>\n+            GNAT_Pragma;\n             Process_Restrictions_Or_Restriction_Warnings (Warn => True);\n \n          ----------------\n@@ -10025,13 +10477,11 @@ package body Sem_Prag is\n             Check_No_Identifiers;\n             Check_Arg_Count (1);\n \n-            --  The expression must be analyzed in the special manner\n-            --  described in \"Handling of Default Expressions\" in sem.ads.\n-\n-            --  Set In_Default_Expression for per-object case ???\n+            --  The expression must be analyzed in the special manner described\n+            --  in \"Handling of Default Expressions\" in sem.ads.\n \n             Arg := Expression (Arg1);\n-            Analyze_Per_Use_Expression (Arg, Any_Integer);\n+            Preanalyze_Spec_Expression (Arg, Any_Integer);\n \n             if not Is_Static_Expression (Arg) then\n                Check_Restriction (Static_Storage_Size, Arg);\n@@ -10137,24 +10587,35 @@ package body Sem_Prag is\n                Write : constant Entity_Id := Entity (Expression (Arg3));\n \n             begin\n-               if Etype (Typ) = Any_Type\n-                    or else\n-                  Etype (Read) = Any_Type\n+               Check_First_Subtype (Arg1);\n+\n+               --  Check for too early or too late. Note that we don't enforce\n+               --  the rule about primitive operations in this case, since, as\n+               --  is the case for explicit stream attributes themselves, these\n+               --  restrictions are not appropriate. Note that the chaining of\n+               --  the pragma by Rep_Item_Too_Late is actually the critical\n+               --  processing done for this pragma.\n+\n+               if Rep_Item_Too_Early (Typ, N)\n                     or else\n-                  Etype (Write) = Any_Type\n+                  Rep_Item_Too_Late (Typ, N, FOnly => True)\n                then\n                   return;\n                end if;\n \n-               Check_First_Subtype (Arg1);\n+               --  Return if previous error\n \n-               if Rep_Item_Too_Early (Typ, N)\n+               if Etype (Typ) = Any_Type\n+                    or else\n+                  Etype (Read) = Any_Type\n                     or else\n-                  Rep_Item_Too_Late (Typ, N)\n+                  Etype (Write) = Any_Type\n                then\n                   return;\n                end if;\n \n+               --  Error checks\n+\n                if Underlying_Type (Etype (Read)) /= Typ then\n                   Error_Pragma_Arg\n                     (\"incorrect return type for function&\", Arg2);\n@@ -10477,8 +10938,6 @@ package body Sem_Prag is\n          --  pragma Task_Name (string_EXPRESSION);\n \n          when Pragma_Task_Name => Task_Name : declare\n-         --  pragma Priority (EXPRESSION);\n-\n             P   : constant Node_Id := Parent (N);\n             Arg : Node_Id;\n \n@@ -11361,6 +11820,39 @@ package body Sem_Prag is\n       when Pragma_Exit => null;\n    end Analyze_Pragma;\n \n+   -------------------\n+   -- Check_Enabled --\n+   -------------------\n+\n+   function Check_Enabled (Nam : Name_Id) return Boolean is\n+      PP : Node_Id;\n+\n+   begin\n+      PP := Opt.Check_Policy_List;\n+      loop\n+         if No (PP) then\n+            return Assertions_Enabled;\n+\n+         elsif\n+           Nam = Chars (Expression (First (Pragma_Argument_Associations (PP))))\n+         then\n+            case\n+              Chars (Expression (Last (Pragma_Argument_Associations (PP))))\n+            is\n+            when Name_On | Name_Check =>\n+               return True;\n+            when Name_Off | Name_Ignore =>\n+               return False;\n+            when others =>\n+               raise Program_Error;\n+            end case;\n+\n+         else\n+            PP := Next_Pragma (PP);\n+         end if;\n+      end loop;\n+   end Check_Enabled;\n+\n    ---------------------------------\n    -- Delay_Config_Pragma_Analyze --\n    ---------------------------------\n@@ -11396,6 +11888,28 @@ package body Sem_Prag is\n       return Result;\n    end Get_Base_Subprogram;\n \n+   --------------------\n+   -- Get_Pragma_Arg --\n+   --------------------\n+\n+   function Get_Pragma_Arg (Arg : Node_Id) return Node_Id is\n+   begin\n+      if Nkind (Arg) = N_Pragma_Argument_Association then\n+         return Expression (Arg);\n+      else\n+         return Arg;\n+      end if;\n+   end Get_Pragma_Arg;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+   begin\n+      Externals.Init;\n+   end Initialize;\n+\n    -----------------------------\n    -- Is_Config_Static_String --\n    -----------------------------\n@@ -11466,8 +11980,11 @@ package body Sem_Prag is\n    --  than appearence as any argument is insignificant, a positive value\n    --  indicates that appearence in that parameter position is significant.\n \n-   Sig_Flags : constant array (Pragma_Id) of Int :=\n+   --  A value of 99 flags a special case requiring a special check (this is\n+   --  used for cases not covered by this standard encoding, e.g. pragma Check\n+   --  where the first argument is not significant, but the others are).\n \n+   Sig_Flags : constant array (Pragma_Id) of Int :=\n      (Pragma_AST_Entry                     => -1,\n       Pragma_Abort_Defer                   => -1,\n       Pragma_Ada_83                        => -1,\n@@ -11482,7 +11999,9 @@ package body Sem_Prag is\n       Pragma_Atomic                        =>  0,\n       Pragma_Atomic_Components             =>  0,\n       Pragma_Attach_Handler                => -1,\n+      Pragma_Check                         => 99,\n       Pragma_Check_Name                    =>  0,\n+      Pragma_Check_Policy                  =>  0,\n       Pragma_CIL_Constructor               => -1,\n       Pragma_CPP_Class                     =>  0,\n       Pragma_CPP_Constructor               =>  0,\n@@ -11574,6 +12093,8 @@ package body Sem_Prag is\n       Pragma_Preelaborable_Initialization  => -1,\n       Pragma_Polling                       => -1,\n       Pragma_Persistent_BSS                =>  0,\n+      Pragma_Postcondition                 => -1,\n+      Pragma_Precondition                  => -1,\n       Pragma_Preelaborate                  => -1,\n       Pragma_Preelaborate_05               => -1,\n       Pragma_Priority                      => -1,\n@@ -11587,6 +12108,7 @@ package body Sem_Prag is\n       Pragma_Pure_Function                 => -1,\n       Pragma_Queuing_Policy                => -1,\n       Pragma_Ravenscar                     => -1,\n+      Pragma_Relative_Deadline             => -1,\n       Pragma_Remote_Call_Interface         => -1,\n       Pragma_Remote_Types                  => -1,\n       Pragma_Restricted_Run_Time           => -1,\n@@ -11636,9 +12158,10 @@ package body Sem_Prag is\n       Unknown_Pragma                       =>  0);\n \n    function Is_Non_Significant_Pragma_Reference (N : Node_Id) return Boolean is\n-      P : Node_Id;\n-      C : Int;\n-      A : Node_Id;\n+      Id : Pragma_Id;\n+      P  : Node_Id;\n+      C  : Int;\n+      A  : Node_Id;\n \n    begin\n       P := Parent (N);\n@@ -11647,7 +12170,8 @@ package body Sem_Prag is\n          return False;\n \n       else\n-         C := Sig_Flags (Get_Pragma_Id (Parent (P)));\n+         Id := Get_Pragma_Id (Parent (P));\n+         C := Sig_Flags (Id);\n \n          case C is\n             when -1 =>\n@@ -11656,6 +12180,21 @@ package body Sem_Prag is\n             when 0 =>\n                return True;\n \n+            when 99 =>\n+               case Id is\n+\n+                  --  For pragma Check, the first argument is not significant,\n+                  --  the second and the third (if present) arguments are\n+                  --  significant.\n+\n+                  when Pragma_Check =>\n+                     return\n+                       P = First (Pragma_Argument_Associations (Parent (P)));\n+\n+                  when others =>\n+                     raise Program_Error;\n+               end case;\n+\n             when others =>\n                A := First (Pragma_Argument_Associations (Parent (P)));\n                for J in 1 .. C - 1 loop\n@@ -11666,7 +12205,7 @@ package body Sem_Prag is\n                   Next (A);\n                end loop;\n \n-               return A = P;\n+               return A = P; -- is this wrong way round ???\n          end case;\n       end if;\n    end Is_Non_Significant_Pragma_Reference;\n@@ -11920,4 +12459,5 @@ package body Sem_Prag is\n          Set_Entity (Pref, Scop);\n       end if;\n    end Set_Unit_Name;\n+\n end Sem_Prag;"}, {"sha": "7218ff61f7ca104ddfc117b19798117e556e41fa", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -26,13 +26,36 @@\n --  Pragma handling is isolated in a separate package\n --  (logically this processing belongs in chapter 4)\n \n+with Namet; use Namet;\n with Types; use Types;\n \n package Sem_Prag is\n \n+   -----------------\n+   -- Subprograms --\n+   -----------------\n+\n+   procedure Analyze_PPC_In_Decl_Part (N : Node_Id; S : Entity_Id);\n+   --  Special analyze routine for precondition/postcondition pragma that\n+   --  appears within a declarative part where the pragma is associated\n+   --  with a subprogram specification. N is the pragma node, and S is the\n+   --  entity for the related subprogram. This procedure does a preanalysis\n+   --  of the expressions in the pragma as \"spec expressions\" (see section\n+   --  in Sem \"Handling of Default and Per-Object Expressions...\").\n+\n    procedure Analyze_Pragma (N : Node_Id);\n    --  Analyze procedure for pragma reference node N\n \n+   function Check_Enabled (Nam : Name_Id) return Boolean;\n+   --  This function is used in connection with pragmas Assertion, Check,\n+   --  Precondition, and Postcondition to determine if Check pragmas (or\n+   --  corresponding Assert, Precondition, or Postcondition pragmas) are\n+   --  currently active, as determined by the presence of -gnata on the\n+   --  command line (which sets the default), and the appearence of pragmas\n+   --  Check_Policy and Assertion_Policy as configuration pragmas either in\n+   --  a configuration pragma file, or at the start of the current unit.\n+   --  True is returned if the specified check is enabled.\n+\n    function Delay_Config_Pragma_Analyze (N : Node_Id) return Boolean;\n    --  N is a pragma appearing in a configuration pragma file. Most such\n    --  pragmas are analyzed when the file is read, before parsing and analyzing\n@@ -43,6 +66,10 @@ package Sem_Prag is\n    --  True have their analysis delayed until after the main program is parsed\n    --  and analyzed.\n \n+   procedure Initialize;\n+   --  Initializes data structures used for pragma processing. Must be called\n+   --  before analyzing each new main source program.\n+\n    function Is_Non_Significant_Pragma_Reference (N : Node_Id) return Boolean;\n    --  The node N is a node for an entity and the issue is whether the\n    --  occurrence is a reference for the purposes of giving warnings about"}, {"sha": "b9b81ab40acccb8822a228bbafd47fdd0338e532", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 55, "deletions": 28, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -36,6 +36,7 @@ with Opt;      use Opt;\n with Rtsfind;  use Rtsfind;\n with Sem;      use Sem;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Aux;  use Sem_Aux;\n with Sem_Eval; use Sem_Eval;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n@@ -2680,31 +2681,15 @@ package body Sem_Warn is\n \n       --  Output additional warning if present\n \n-      declare\n-         W : constant Node_Id := Obsolescent_Warning (E);\n-\n-      begin\n-         if Present (W) then\n-\n-            --  This is a warning continuation to start on a new line\n-            Name_Buffer (1) := '\\';\n-            Name_Buffer (2) := '\\';\n-            Name_Buffer (3) := '?';\n-            Name_Len := 3;\n-\n-            --  Add characters to message, and output message. Note that\n-            --  we quote every character of the message since we don't\n-            --  want to process any insertions.\n-\n-            for J in 1 .. String_Length (Strval (W)) loop\n-               Add_Char_To_Name_Buffer (''');\n-               Add_Char_To_Name_Buffer\n-                 (Get_Character (Get_String_Char (Strval (W), J)));\n-            end loop;\n-\n-            Error_Msg_N (Name_Buffer (1 .. Name_Len), N);\n+      for J in Obsolescent_Warnings.First .. Obsolescent_Warnings.Last loop\n+         if Obsolescent_Warnings.Table (J).Ent = E then\n+            String_To_Name_Buffer (Obsolescent_Warnings.Table (J).Msg);\n+            Error_Msg_Strlen := Name_Len;\n+            Error_Msg_String (1 .. Name_Len) := Name_Buffer (1 .. Name_Len);\n+            Error_Msg_N (\"\\\\?~\", N);\n+            exit;\n          end if;\n-      end;\n+      end loop;\n    end Output_Obsolescent_Entity_Warnings;\n \n    ----------------------------------\n@@ -2838,12 +2823,50 @@ package body Sem_Warn is\n          when 'C' =>\n             Warn_On_Unrepped_Components         := False;\n \n+         when 'e' =>\n+            Address_Clause_Overlay_Warnings     := True;\n+            Check_Unreferenced                  := True;\n+            Check_Unreferenced_Formals          := True;\n+            Check_Withs                         := True;\n+            Constant_Condition_Warnings         := True;\n+            Elab_Warnings                       := True;\n+            Implementation_Unit_Warnings        := True;\n+            Ineffective_Inline_Warnings         := True;\n+            Warn_On_Ada_2005_Compatibility      := True;\n+            Warn_On_All_Unread_Out_Parameters   := True;\n+            Warn_On_Assertion_Failure           := True;\n+            Warn_On_Assumed_Low_Bound           := True;\n+            Warn_On_Bad_Fixed_Value             := True;\n+            Warn_On_Constant                    := True;\n+            Warn_On_Deleted_Code                := True;\n+            Warn_On_Dereference                 := True;\n+            Warn_On_Export_Import               := True;\n+            Warn_On_Hiding                      := True;\n+            Ineffective_Inline_Warnings         := True;\n+            Warn_On_Modified_Unread             := True;\n+            Warn_On_No_Value_Assigned           := True;\n+            Warn_On_Non_Local_Exception         := True;\n+            Warn_On_Object_Renames_Function     := True;\n+            Warn_On_Obsolescent_Feature         := True;\n+            Warn_On_Questionable_Missing_Parens := True;\n+            Warn_On_Redundant_Constructs        := True;\n+            Warn_On_Unchecked_Conversion        := True;\n+            Warn_On_Unrecognized_Pragma         := True;\n+            Warn_On_Unrepped_Components         := True;\n+            Warn_On_Warnings_Off                := True;\n+\n          when 'o' =>\n             Warn_On_All_Unread_Out_Parameters   := True;\n \n          when 'O' =>\n             Warn_On_All_Unread_Out_Parameters   := False;\n \n+         when 'p' =>\n+            Warn_On_Parameter_Order             := True;\n+\n+         when 'P' =>\n+            Warn_On_Parameter_Order             := False;\n+\n          when 'r' =>\n             Warn_On_Object_Renames_Function     := True;\n \n@@ -2892,10 +2915,11 @@ package body Sem_Warn is\n             Warn_On_Modified_Unread             := True;\n             Warn_On_No_Value_Assigned           := True;\n             Warn_On_Non_Local_Exception         := True;\n+            Warn_On_Object_Renames_Function     := True;\n             Warn_On_Obsolescent_Feature         := True;\n+            Warn_On_Parameter_Order             := True;\n             Warn_On_Questionable_Missing_Parens := True;\n             Warn_On_Redundant_Constructs        := True;\n-            Warn_On_Object_Renames_Function     := True;\n             Warn_On_Unchecked_Conversion        := True;\n             Warn_On_Unrecognized_Pragma         := True;\n             Warn_On_Unrepped_Components         := True;\n@@ -2922,6 +2946,7 @@ package body Sem_Warn is\n             Warn_On_Non_Local_Exception         := False;\n             Warn_On_Obsolescent_Feature         := False;\n             Warn_On_All_Unread_Out_Parameters   := False;\n+            Warn_On_Parameter_Order             := False;\n             Warn_On_Questionable_Missing_Parens := False;\n             Warn_On_Redundant_Constructs        := False;\n             Warn_On_Object_Renames_Function     := False;\n@@ -3174,13 +3199,15 @@ package body Sem_Warn is\n             then\n                return;\n \n-            --  Don't warn in assert pragma, since presumably tests in such\n-            --  a context are very definitely intended, and might well be\n+            --  Don't warn in assert or check pragma, since presumably tests in\n+            --  such a context are very definitely intended, and might well be\n             --  known at compile time. Note that we have to test the original\n             --  node, since assert pragmas get rewritten at analysis time.\n \n             elsif Nkind (Original_Node (P)) = N_Pragma\n-              and then Pragma_Name (Original_Node (P)) = Name_Assert\n+              and then (Pragma_Name (Original_Node (P)) = Name_Assert\n+                          or else\n+                        Pragma_Name (Original_Node (P)) = Name_Check)\n             then\n                return;\n             end if;"}, {"sha": "534023f1cabde42cfc80e81335f0e05500e6132b", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -1415,6 +1415,15 @@ package body Sinfo is\n       return Flag11 (N);\n    end Has_Private_View;\n \n+   function Has_Relative_Deadline_Pragma\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Subprogram_Body\n+        or else NT (N).Nkind = N_Task_Definition);\n+      return Flag9 (N);\n+   end Has_Relative_Deadline_Pragma;\n+\n    function Has_Self_Reference\n       (N : Node_Id) return Boolean is\n    begin\n@@ -1980,6 +1989,14 @@ package body Sinfo is\n       return Node4 (N);\n    end Next_Named_Actual;\n \n+   function Next_Pragma\n+      (N : Node_Id) return Node_Id is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Pragma);\n+      return Node1 (N);\n+   end Next_Pragma;\n+\n    function Next_Rep_Item\n       (N : Node_Id) return Node_Id is\n    begin\n@@ -2184,6 +2201,14 @@ package body Sinfo is\n       return Node4 (N);\n    end Parent_Spec;\n \n+   function PPC_Enabled\n+     (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Pragma);\n+      return Flag5 (N);\n+   end PPC_Enabled;\n+\n    function Position\n       (N : Node_Id) return Node_Id is\n    begin\n@@ -4154,6 +4179,15 @@ package body Sinfo is\n       Set_Flag11 (N, Val);\n    end Set_Has_Private_View;\n \n+   procedure Set_Has_Relative_Deadline_Pragma\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Subprogram_Body\n+        or else NT (N).Nkind = N_Task_Definition);\n+      Set_Flag9 (N, Val);\n+   end Set_Has_Relative_Deadline_Pragma;\n+\n    procedure Set_Has_Self_Reference\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -4719,6 +4753,14 @@ package body Sinfo is\n       Set_Node4 (N, Val); -- semantic field, no parent set\n    end Set_Next_Named_Actual;\n \n+   procedure Set_Next_Pragma\n+      (N : Node_Id; Val : Node_Id) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Pragma);\n+      Set_Node1 (N, Val); -- semantic field, no parent set\n+   end Set_Next_Pragma;\n+\n    procedure Set_Next_Rep_Item\n       (N : Node_Id; Val : Node_Id) is\n    begin\n@@ -4923,6 +4965,14 @@ package body Sinfo is\n       Set_Node4 (N, Val); -- semantic field, no parent set\n    end Set_Parent_Spec;\n \n+   procedure Set_PPC_Enabled\n+     (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Pragma);\n+      Set_Flag5 (N, Val);\n+   end Set_PPC_Enabled;\n+\n    procedure Set_Position\n       (N : Node_Id; Val : Node_Id) is\n    begin"}, {"sha": "edbd4814a0f3831ad0958a65f7c037ade1c1f228", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 110, "deletions": 63, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -581,11 +581,11 @@ package Sinfo is\n    --    elements.\n \n    --  All_Others (Flag11-Sem)\n-   --    Present in an N_Others_Choice node. This flag is set in the case of an\n-   --    others exception where all exceptions are to be caught, even those\n-   --    that are not normally handled (in particular the tasking abort\n-   --    signal). This is used for translation of the at end handler into a\n-   --    normal exception handler.\n+   --    Present in an N_Others_Choice node. This flag is set for an others\n+   --    exception where all exceptions are to be caught, even those that are\n+   --    not normally handled (in particular the tasking abort signal). This\n+   --    is used for translation of the at end handler into a normal exception\n+   --    handler.\n \n    --  Assignment_OK (Flag15-Sem)\n    --    This flag is set in a subexpression node for an object, indicating\n@@ -596,32 +596,32 @@ package Sinfo is\n    --    limited type objects (such as tasks), setting discriminant fields,\n    --    setting tag values, etc. N_Object_Declaration nodes also have this\n    --    flag defined. Here it is used to indicate that an initialization\n-   --    expression is valid, even where it would normally not be allowed (e.g.\n-   --    where the type involved is limited).\n+   --    expression is valid, even where it would normally not be allowed\n+   --    (e.g. where the type involved is limited).\n \n    --  Associated_Node (Node4-Sem)\n    --    Present in nodes that can denote an entity: identifiers, character\n    --    literals, operator symbols, expanded names, operator nodes, and\n-   --    attribute reference nodes (all these nodes have an Entity field). This\n-   --    field is also present in N_Aggregate, N_Selected_Component, and\n+   --    attribute reference nodes (all these nodes have an Entity field).\n+   --    This field is also present in N_Aggregate, N_Selected_Component, and\n    --    N_Extension_Aggregate nodes. This field is used in generic processing\n-   --    to create links between the generic template and the generic copy. See\n-   --    Sem_Ch12.Get_Associated_Node for full details. Note that this field\n-   --    overlaps Entity, which is fine, since, as explained in Sem_Ch12, the\n-   --    normal function of Entity is not required at the point where the\n+   --    to create links between the generic template and the generic copy.\n+   --    See Sem_Ch12.Get_Associated_Node for full details. Note that this\n+   --    field overlaps Entity, which is fine, since, as explained in Sem_Ch12,\n+   --    the normal function of Entity is not required at the point where the\n    --    Associated_Node is set. Note also, that in generic templates, this\n    --    means that the Entity field does not necessarily point to an Entity.\n    --    Since the back end is expected to ignore generic templates, this is\n    --    harmless.\n \n    --  At_End_Proc (Node1)\n-   --    This field is present in an N_Handled_Sequence_Of_Statements node. It\n-   --    contains an identifier reference for the cleanup procedure to be\n+   --    This field is present in an N_Handled_Sequence_Of_Statements node.\n+   --    It contains an identifier reference for the cleanup procedure to be\n    --    called. See description of this node for further details.\n \n    --  Backwards_OK (Flag6-Sem)\n-   --    A flag present in the N_Assignment_Statement node. It is used only if\n-   --    the type being assigned is an array type, and is set if analysis\n+   --    A flag present in the N_Assignment_Statement node. It is used only\n+   --    if the type being assigned is an array type, and is set if analysis\n    --    determines that it is definitely safe to do the copy backwards, i.e.\n    --    starting at the highest addressed element. Note that if neither of the\n    --    flags Forwards_OK or Backwards_OK is set, it means that the front end\n@@ -637,8 +637,8 @@ package Sinfo is\n    --    which is used directly in later calls to the original subprogram.\n \n    --  Body_Required (Flag13-Sem)\n-   --    A flag that appears in the N_Compilation_Unit node indicating that the\n-   --    corresponding unit requires a body. For the package case, this\n+   --    A flag that appears in the N_Compilation_Unit node indicating that\n+   --    the corresponding unit requires a body. For the package case, this\n    --    indicates that a completion is required. In Ada 95, if the flag is not\n    --    set for the package case, then a body may not be present. In Ada 83,\n    --    if the flag is not set for the package case, then body is optional.\n@@ -647,10 +647,9 @@ package Sinfo is\n    --    permitted (in Ada 83 or Ada 95).\n \n    --  By_Ref (Flag5-Sem)\n-   --    A flag present in N_Simple_Return_Statement and\n-   --    N_Extended_Return_Statement.\n-   --    It is set when the returned expression is already allocated on the\n-   --    secondary stack and thus the result is passed by reference rather\n+   --    Present in N_Simple_Return_Statement and N_Extended_Return_Statement,\n+   --    this flag is set when the returned expression is already allocated on\n+   --    the secondary stack and thus the result is passed by reference rather\n    --    than copied another time.\n \n    --  Check_Address_Alignment (Flag11-Sem)\n@@ -668,8 +667,8 @@ package Sinfo is\n \n    --  Comes_From_Extended_Return_Statement (Flag18-Sem)\n    --    Present in N_Simple_Return_Statement nodes. True if this node was\n-   --    constructed as part of the expansion of an\n-   --    N_Extended_Return_Statement.\n+   --    constructed as part of the N_Extended_Return_Statement expansion.\n+   --    .\n \n    --  Compile_Time_Known_Aggregate (Flag18-Sem)\n    --    Present in N_Aggregate nodes. Set for aggregates which can be fully\n@@ -681,28 +680,28 @@ package Sinfo is\n    --  Condition_Actions (List3-Sem)\n    --    This field appears in else-if nodes and in the iteration scheme node\n    --    for while loops. This field is only used during semantic processing to\n-   --    temporarily hold actions inserted into the tree. In the tree passed to\n-   --    gigi, the condition actions field is always set to No_List. For\n+   --    temporarily hold actions inserted into the tree. In the tree passed\n+   --    to gigi, the condition actions field is always set to No_List. For\n    --    details on how this field is used, see the routine Insert_Actions in\n    --    package Exp_Util, and also the expansion routines for the relevant\n    --    nodes.\n \n    --  Controlling_Argument (Node1-Sem)\n-   --    This field is set in procedure and function call nodes if the call is\n-   --    a dispatching call (it is Empty for a non-dispatching call). It\n+   --    This field is set in procedure and function call nodes if the call\n+   --    is a dispatching call (it is Empty for a non-dispatching call). It\n    --    indicates the source of the call's controlling tag. For procedure\n    --    calls, the Controlling_Argument is one of the actuals. For function\n    --    that has a dispatching result, it is an entity in the context of the\n-   --    call that can provide a tag, or else it is the tag of the root type of\n-   --    the class. It can also specify a tag directly rather than being a\n+   --    call that can provide a tag, or else it is the tag of the root type\n+   --    of the class. It can also specify a tag directly rather than being a\n    --    tagged object. The latter is needed by the implementations of AI-239\n    --    and AI-260.\n \n    --  Conversion_OK (Flag14-Sem)\n-   --    A flag set on type conversion nodes to indicate that the conversion is\n-   --    to be considered as being valid, even though it is the case that the\n-   --    conversion is not valid Ada. This is used for Enum_Rep, Fixed_Value\n-   --    and Integer_Value attributes, for internal conversions done for\n+   --    A flag set on type conversion nodes to indicate that the conversion\n+   --    is to be considered as being valid, even though it is the case that\n+   --    the conversion is not valid Ada. This is used for attributes Enum_Rep,\n+   --    Fixed_Value and Integer_Value, for internal conversions done for\n    --    fixed-point operations, and for certain conversions for calls to\n    --    initialization procedures. If Conversion_OK is set, then Etype must be\n    --    set (the analyzer assumes that Etype has been set). For the case of\n@@ -740,11 +739,11 @@ package Sinfo is\n    --  Corresponding_Spec (Node5-Sem)\n    --    This field is set in subprogram, package, task, and protected body\n    --    nodes, where it points to the defining entity in the corresponding\n-   --    spec. The attribute is also set in N_With_Clause nodes, where it\n-   --    points to the defining entity for the with'ed spec, and in a\n-   --    subprogram renaming declaration when it is a Renaming_As_Body. The\n-   --    field is Empty if there is no corresponding spec, as in the case of a\n-   --    subprogram body that serves as its own spec.\n+   --    spec. The attribute is also set in N_With_Clause nodes where it points\n+   --    to the defining entity for the with'ed spec, and in a subprogram\n+   --    renaming declaration when it is a Renaming_As_Body. The field is Empty\n+   --    if there is no corresponding spec, as in the case of a subprogram body\n+   --    that serves as its own spec.\n \n    --  Corresponding_Stub (Node3-Sem)\n    --    This field is present in an N_Subunit node. It holds the node in\n@@ -812,10 +811,9 @@ package Sinfo is\n    --    range.\n \n    --  Do_Range_Check (Flag9-Sem)\n-   --    This flag is set on an expression which appears in a context where\n-   --    a range check is required. The target type is clear from the\n-   --    context. The contexts in which this flag can appear are limited to\n-   --    the following.\n+   --    This flag is set on an expression which appears in a context where a\n+   --    range check is required. The target type is clear from the context.\n+   --    The contexts in which this flag can appear are the following:\n \n    --      Right side of an assignment. In this case the target type is\n    --      taken from the left side of the assignment, which is referenced\n@@ -885,11 +883,11 @@ package Sinfo is\n    --    desirable for correct elaboration for this unit.\n \n    --  Elaboration_Boolean (Node2-Sem)\n-   --    This field is present in function and procedure specification\n-   --    nodes. If set, it points to the entity for a Boolean flag that\n-   --    must be tested for certain calls to check for access before\n-   --    elaboration. See body of Sem_Elab for further details. This\n-   --    field is Empty if no elaboration boolean is required.\n+   --    This field is present in function and procedure specification nodes.\n+   --    If set, it points to the entity for a Boolean flag that must be tested\n+   --    for certain calls to check for access before elaboration. See body of\n+   --    Sem_Elab for further details. This field is Empty if no elaboration\n+   --    boolean is required.\n \n    --  Else_Actions (List3-Sem)\n    --    This field is present in conditional expression nodes. During code\n@@ -903,10 +901,10 @@ package Sinfo is\n    --    always set to No_List.\n \n    --  Enclosing_Variant (Node2-Sem)\n-   --    This field is present in the N_Variant node and identifies the\n-   --    Node_Id corresponding to the immediately enclosing variant when\n-   --    the variant is nested, and N_Empty otherwise. Set during semantic\n-   --    processing of the variant part of a record type.\n+   --    This field is present in the N_Variant node and identifies the Node_Id\n+   --    corresponding to the immediately enclosing variant when the variant is\n+   --    nested, and N_Empty otherwise. Set during semantic processing of the\n+   --    variant part of a record type.\n \n    --  Entity (Node4-Sem)\n    --    Appears in all direct names (identifiers, character literals, and\n@@ -989,11 +987,11 @@ package Sinfo is\n    --    left-hand side of individual assignment to each sub-component.\n \n    --  First_Inlined_Subprogram (Node3-Sem)\n-   --    Present in the N_Compilation_Unit node for the main program. Points to\n-   --    a chain of entities for subprograms that are to be inlined. The\n+   --    Present in the N_Compilation_Unit node for the main program. Points\n+   --    to a chain of entities for subprograms that are to be inlined. The\n    --    Next_Inlined_Subprogram field of these entities is used as a link\n-   --    pointer with Empty marking the end of the list. This field is Empty if\n-   --    there are no inlined subprograms or inlining is not active.\n+   --    pointer with Empty marking the end of the list. This field is Empty\n+   --    if there are no inlined subprograms or inlining is not active.\n \n    --  First_Named_Actual (Node4-Sem)\n    --    Present in procedure call statement and function call nodes, and also\n@@ -1014,8 +1012,8 @@ package Sinfo is\n \n    --  First_Subtype_Link (Node5-Sem)\n    --    Present in N_Freeze_Entity node for an anonymous base type that is\n-   --    implicitly created by the declaration of a first subtype. It points to\n-   --    the entity for the first subtype.\n+   --    implicitly created by the declaration of a first subtype. It points\n+   --    to the entity for the first subtype.\n \n    --  Float_Truncate (Flag11-Sem)\n    --    A flag present in type conversion nodes. This is used for float to\n@@ -1024,8 +1022,8 @@ package Sinfo is\n    --    with rounding (see Expand_N_Type_Conversion).\n \n    --  Forwards_OK (Flag5-Sem)\n-   --    A flag present in the N_Assignment_Statement node. It is used only if\n-   --    the type being assigned is an array type, and is set if analysis\n+   --    A flag present in the N_Assignment_Statement node. It is used only\n+   --    if the type being assigned is an array type, and is set if analysis\n    --    determines that it is definitely safe to do the copy forwards, i.e.\n    --    starting at the lowest addressed element. Note that if neither of the\n    --    flags Forwards_OK or Backwards_OK is set, it means that the front end\n@@ -1103,6 +1101,10 @@ package Sinfo is\n    --    declarations if the visibility at instantiation is different from the\n    --    visibility at generic definition.\n \n+   --  Has_Relative_Deadline_Pragma (Flag9-Sem)\n+   --    A flag present in N_Subprogram_Body and N_Task_Definition nodes to\n+   --    flag the presence of a pragma Relative_Deadline.\n+\n    --  Has_Self_Reference (Flag13-Sem)\n    --    Present in N_Aggregate and N_Extension_Aggregate. Indicates that one\n    --    of the expressions contains an access attribute reference to the\n@@ -1365,6 +1367,17 @@ package Sinfo is\n    --    points to the explicit actual parameter itself, not to the\n    --    N_Parameter_Association node (its parent).\n \n+   --  Next_Pragma (Node1-Sem)\n+   --    Present in N_Pragma nodes. Used to create a linked list of pragma\n+   --    nodes. Curently used for two purposes:\n+   --\n+   --      Create a list of linked Check_Policy pragmas. The head of this list\n+   --      is stored in Opt.Check_Policy_List (which has further details).\n+   --\n+   --      Used by processing for Pre/Postcondition pragmas to store a list of\n+   --      pragmas associated with the spec of a subprogram (see Sem_Prag for\n+   --      details).\n+\n    --  Next_Rep_Item (Node5-Sem)\n    --    Present in pragma nodes and attribute definition nodes. Used to link\n    --    representation items that apply to an entity. See description of\n@@ -1467,6 +1480,11 @@ package Sinfo is\n    --    package specification. This field is Empty for library bodies (the\n    --    parent spec in this case can be found from the corresponding spec).\n \n+   --  PPC_Enabled (Flag5-Sem)\n+   --    Present in N_Pragma nodes. This flag is relevant only for precondition\n+   --    and postcondition nodes. It is true if the check corresponding to the\n+   --    pragma type is enabled at the point where the pragma appears.\n+\n    --  Present_Expr (Uint3-Sem)\n    --    Present in an N_Variant node. This has a meaningful value only after\n    --    Gigi has back annotated the tree with representation information. At\n@@ -1883,10 +1901,12 @@ package Sinfo is\n \n       --  N_Pragma\n       --  Sloc points to pragma identifier\n+      --  Next_Pragma (Node1-Sem)\n       --  Pragma_Argument_Associations (List2) (set to No_List if none)\n       --  Debug_Statement (Node3) (set to Empty if not Debug, Assert)\n       --  Pragma_Identifier (Node4)\n       --  Next_Rep_Item (Node5-Sem)\n+      --  PPC_Enabled (Flag5-Sem)\n \n       --  Note: we should have a section on what pragmas are passed on to\n       --  the back end to be processed. This section should note that pragma\n@@ -4274,6 +4294,7 @@ package Sinfo is\n       --  Is_Entry_Barrier_Function (Flag8-Sem)\n       --  Is_Task_Master (Flag5-Sem)\n       --  Was_Originally_Stub (Flag13-Sem)\n+      --  Has_Relative_Deadline_Pragma (Flag9-Sem)\n \n       -----------------------------------\n       -- 6.4  Procedure Call Statement --\n@@ -4730,6 +4751,7 @@ package Sinfo is\n       --  Has_Storage_Size_Pragma (Flag5-Sem)\n       --  Has_Task_Info_Pragma (Flag7-Sem)\n       --  Has_Task_Name_Pragma (Flag8-Sem)\n+      --  Has_Relative_Deadline_Pragma (Flag9-Sem)\n \n       --------------------\n       -- 9.1  Task Item --\n@@ -7130,7 +7152,7 @@ package Sinfo is\n       N_Null_Statement,\n       N_Raise_Statement,\n       N_Requeue_Statement,\n-      N_Return_Statement, -- renamed as N_Simple_Return_Statement in Sem_Util\n+      N_Return_Statement, -- renamed as N_Simple_Return_Statement below\n       N_Extended_Return_Statement,\n       N_Selective_Accept,\n       N_Timed_Entry_Call,\n@@ -7848,6 +7870,9 @@ package Sinfo is\n    function Has_Private_View\n      (N : Node_Id) return Boolean;    -- Flag11\n \n+   function Has_Relative_Deadline_Pragma\n+     (N : Node_Id) return Boolean;    -- Flag9\n+\n    function Has_Self_Reference\n      (N : Node_Id) return Boolean;    -- Flag13\n \n@@ -8028,6 +8053,9 @@ package Sinfo is\n    function Next_Named_Actual\n      (N : Node_Id) return Node_Id;    -- Node4\n \n+   function Next_Pragma\n+     (N : Node_Id) return Node_Id;    -- Node1\n+\n    function Next_Rep_Item\n      (N : Node_Id) return Node_Id;    -- Node5\n \n@@ -8088,6 +8116,9 @@ package Sinfo is\n    function Parent_Spec\n      (N : Node_Id) return Node_Id;    -- Node4\n \n+   function PPC_Enabled\n+     (N : Node_Id) return Boolean;    -- Flag5\n+\n    function Position\n      (N : Node_Id) return Node_Id;    -- Node2\n \n@@ -8718,6 +8749,9 @@ package Sinfo is\n    procedure Set_Has_Private_View\n      (N : Node_Id; Val : Boolean := True);    -- Flag11\n \n+   procedure Set_Has_Relative_Deadline_Pragma\n+     (N : Node_Id; Val : Boolean := True);    -- Flag9\n+\n    procedure Set_Has_Self_Reference\n      (N : Node_Id; Val : Boolean := True);    -- Flag13\n \n@@ -8898,6 +8932,9 @@ package Sinfo is\n    procedure Set_Next_Named_Actual\n      (N : Node_Id; Val : Node_Id);            -- Node4\n \n+   procedure Set_Next_Pragma\n+     (N : Node_Id; Val : Node_Id);            -- Node1\n+\n    procedure Set_Next_Rep_Item\n      (N : Node_Id; Val : Node_Id);            -- Node5\n \n@@ -8958,6 +8995,9 @@ package Sinfo is\n    procedure Set_Parent_Spec\n      (N : Node_Id; Val : Node_Id);            -- Node4\n \n+   procedure Set_PPC_Enabled\n+     (N : Node_Id; Val : Boolean := True);    -- Flag5\n+\n    procedure Set_Position\n      (N : Node_Id; Val : Node_Id);            -- Node2\n \n@@ -9304,7 +9344,7 @@ package Sinfo is\n         5 => False),  --  Etype (Node5-Sem)\n \n      N_Pragma =>\n-       (1 => True,    --  Chars (Name1)\n+       (1 => False,   --  Next_Pragma (Node1-Sem)\n         2 => True,    --  Pragma_Argument_Associations (List2)\n         3 => True,    --  Debug_Statement (Node3)\n         4 => True,    --  Pragma_Identifier (Node4)\n@@ -10941,6 +10981,7 @@ package Sinfo is\n    pragma Inline (Has_No_Elaboration_Code);\n    pragma Inline (Has_Priority_Pragma);\n    pragma Inline (Has_Private_View);\n+   pragma Inline (Has_Relative_Deadline_Pragma);\n    pragma Inline (Has_Storage_Size_Pragma);\n    pragma Inline (Has_Task_Info_Pragma);\n    pragma Inline (Has_Task_Name_Pragma);\n@@ -11000,6 +11041,7 @@ package Sinfo is\n    pragma Inline (Names);\n    pragma Inline (Next_Entity);\n    pragma Inline (Next_Named_Actual);\n+   pragma Inline (Next_Pragma);\n    pragma Inline (Next_Rep_Item);\n    pragma Inline (Next_Use_Clause);\n    pragma Inline (No_Ctrl_Actions);\n@@ -11020,6 +11062,7 @@ package Sinfo is\n    pragma Inline (Parameter_List_Truncated);\n    pragma Inline (Parameter_Type);\n    pragma Inline (Parent_Spec);\n+   pragma Inline (PPC_Enabled);\n    pragma Inline (Position);\n    pragma Inline (Pragma_Argument_Associations);\n    pragma Inline (Pragma_Identifier);\n@@ -11227,6 +11270,7 @@ package Sinfo is\n    pragma Inline (Set_Has_No_Elaboration_Code);\n    pragma Inline (Set_Has_Priority_Pragma);\n    pragma Inline (Set_Has_Private_View);\n+   pragma Inline (Set_Has_Relative_Deadline_Pragma);\n    pragma Inline (Set_Has_Storage_Size_Pragma);\n    pragma Inline (Set_Has_Task_Info_Pragma);\n    pragma Inline (Set_Has_Task_Name_Pragma);\n@@ -11287,6 +11331,8 @@ package Sinfo is\n    pragma Inline (Set_Names);\n    pragma Inline (Set_Next_Entity);\n    pragma Inline (Set_Next_Named_Actual);\n+   pragma Inline (Set_Next_Pragma);\n+   pragma Inline (Set_Next_Rep_Item);\n    pragma Inline (Set_Next_Use_Clause);\n    pragma Inline (Set_No_Ctrl_Actions);\n    pragma Inline (Set_No_Elaboration_Check);\n@@ -11306,6 +11352,7 @@ package Sinfo is\n    pragma Inline (Set_Parameter_List_Truncated);\n    pragma Inline (Set_Parameter_Type);\n    pragma Inline (Set_Parent_Spec);\n+   pragma Inline (Set_PPC_Enabled);\n    pragma Inline (Set_Position);\n    pragma Inline (Set_Pragma_Argument_Associations);\n    pragma Inline (Set_Pragma_Identifier);"}, {"sha": "957dfae2625b41a5be4e939e810b74e2c03a7af7", "filename": "gcc/ada/sinput.adb", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsinput.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsinput.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.adb?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -221,8 +221,6 @@ package body Sinput is\n       Ptr : Source_Ptr;\n \n    begin\n-      Name_Len := 0;\n-\n       --  Loop through instantiations\n \n       Ptr := Loc;\n@@ -765,17 +763,20 @@ package body Sinput is\n                   null;\n \n                else\n+                  --  Free the buffer, we use Free here, because we used malloc\n+                  --  or realloc directly to allocate the tables. That is\n+                  --  because we were playing the big array trick. We need to\n+                  --  suppress the warning for freeing from an empty pool!\n+\n                   --  We have to recreate a proper pointer to the actual array\n                   --  from the zero origin pointer stored in the source table.\n \n                   Tmp1 :=\n                     To_Source_Buffer_Ptr\n                       (S.Source_Text (S.Source_First)'Address);\n+                  pragma Warnings (Off);\n                   Free_Ptr (Tmp1);\n-\n-                  --  Note: we are using free here, because we used malloc\n-                  --  or realloc directly to allocate the tables. That is\n-                  --  because we were playing the big array trick.\n+                  pragma Warnings (On);\n \n                   if S.Lines_Table /= null then\n                      Memory.Free (To_Address (S.Lines_Table));"}, {"sha": "90c54f5efb75c915aa1968edeb7b89d98fd0ef69", "filename": "gcc/ada/sinput.ads", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsinput.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsinput.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput.ads?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -465,13 +465,13 @@ package Sinput is\n    --  that there definitely is a previous line in the source buffer.\n \n    procedure Build_Location_String (Loc : Source_Ptr);\n-   --  This function builds a string literal of the form \"name:line\",\n-   --  where name is the file name corresponding to Loc, and line is\n-   --  the line number. In the event that instantiations are involved,\n-   --  additional suffixes of the same form are appended after the\n-   --  separating string \" instantiated at \". The returned string is\n-   --  stored in Name_Buffer, terminated by ASCII.Nul, with Name_Length\n-   --  indicating the length not including the terminating Nul.\n+   --  This function builds a string literal of the form \"name:line\", where\n+   --  name is the file name corresponding to Loc, and line is the line number.\n+   --  In the event that instantiations are involved, additional suffixes of\n+   --  the same form are appended after the separating string \" instantiated at\n+   --  \". The returned string is appended to the Name_Buffer, terminated by\n+   --  ASCII.NUL, with Name_Length indicating the length not including the\n+   --  terminating Nul.\n \n    function Get_Column_Number (P : Source_Ptr) return Column_Number;\n    --  The ones-origin column number of the specified Source_Ptr value is"}, {"sha": "3132f23ebde7543327ca214dd762efe9fa0a2eb8", "filename": "gcc/ada/snames.adb", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsnames.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsnames.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -78,8 +78,11 @@ package body Snames is\n      \"_local_final_list#\" &\n      \"_master#\" &\n      \"_object#\" &\n+     \"_postconditions#\" &\n      \"_priority#\" &\n      \"_process_atsd#\" &\n+     \"_relative_deadline#\" &\n+     \"_result#\" &\n      \"_secondary_stack#\" &\n      \"_service#\" &\n      \"_size#\" &\n@@ -145,7 +148,6 @@ package body Snames is\n      \"_call#\" &\n      \"rci_name#\" &\n      \"receiver#\" &\n-     \"result#\" &\n      \"rpc#\" &\n      \"subp_id#\" &\n      \"operation#\" &\n@@ -182,6 +184,7 @@ package body Snames is\n      \"assertion_policy#\" &\n      \"c_pass_by_copy#\" &\n      \"check_name#\" &\n+     \"check_policy#\" &\n      \"compile_time_error#\" &\n      \"compile_time_warning#\" &\n      \"compiler_unit#\" &\n@@ -207,8 +210,8 @@ package body Snames is\n      \"no_strict_aliasing#\" &\n      \"normalize_scalars#\" &\n      \"optimize_alignment#\" &\n-     \"polling#\" &\n      \"persistent_bss#\" &\n+     \"polling#\" &\n      \"priority_specific_dispatching#\" &\n      \"profile#\" &\n      \"profile_warnings#\" &\n@@ -239,6 +242,7 @@ package body Snames is\n      \"atomic#\" &\n      \"atomic_components#\" &\n      \"attach_handler#\" &\n+     \"check#\" &\n      \"cil_constructor#\" &\n      \"comment#\" &\n      \"common_object#\" &\n@@ -299,13 +303,16 @@ package body Snames is\n      \"pack#\" &\n      \"page#\" &\n      \"passive#\" &\n+     \"postcondition#\" &\n+     \"precondition#\" &\n      \"preelaborable_initialization#\" &\n      \"preelaborate#\" &\n      \"preelaborate_05#\" &\n      \"psect_object#\" &\n      \"pure#\" &\n      \"pure_05#\" &\n      \"pure_function#\" &\n+     \"relative_deadline#\" &\n      \"remote_call_interface#\" &\n      \"remote_types#\" &\n      \"share_generic#\" &\n@@ -351,10 +358,10 @@ package body Snames is\n      \"dll#\" &\n      \"win32#\" &\n      \"as_is#\" &\n+     \"assertion#\" &\n      \"attribute_name#\" &\n      \"body_file_name#\" &\n      \"boolean_entry_barriers#\" &\n-     \"check#\" &\n      \"casing#\" &\n      \"code#\" &\n      \"component#\" &\n@@ -458,6 +465,7 @@ package body Snames is\n      \"emax#\" &\n      \"enabled#\" &\n      \"enum_rep#\" &\n+     \"enum_val#\" &\n      \"epsilon#\" &\n      \"exponent#\" &\n      \"external_tag#\" &\n@@ -468,9 +476,11 @@ package body Snames is\n      \"fore#\" &\n      \"has_access_values#\" &\n      \"has_discriminants#\" &\n+     \"has_tagged_values#\" &\n      \"identity#\" &\n      \"img#\" &\n      \"integer_value#\" &\n+     \"invalid_value#\" &\n      \"large#\" &\n      \"last#\" &\n      \"last_bit#\" &\n@@ -505,6 +515,7 @@ package body Snames is\n      \"priority#\" &\n      \"range#\" &\n      \"range_length#\" &\n+     \"result#\" &\n      \"round#\" &\n      \"safe_emax#\" &\n      \"safe_first#\" &\n@@ -576,6 +587,7 @@ package body Snames is\n      \"priority_queuing#\" &\n      \"edf_across_priorities#\" &\n      \"fifo_within_priorities#\" &\n+     \"non_preemptive_within_priorities#\" &\n      \"round_robin_within_priorities#\" &\n      \"access_check#\" &\n      \"accessibility_check#\" &\n@@ -679,7 +691,9 @@ package body Snames is\n      \"tagged#\" &\n      \"raise_exception#\" &\n      \"ada_roots#\" &\n+     \"aggregate#\" &\n      \"archive_builder#\" &\n+     \"archive_builder_append_option#\" &\n      \"archive_indexer#\" &\n      \"archive_suffix#\" &\n      \"binder#\" &\n@@ -695,6 +709,7 @@ package body Snames is\n      \"config_file_unique#\" &\n      \"config_spec_file_name#\" &\n      \"config_spec_file_name_pattern#\" &\n+     \"configuration#\" &\n      \"cross_reference#\" &\n      \"default_language#\" &\n      \"default_switches#\" &\n@@ -720,9 +735,11 @@ package body Snames is\n      \"include_switches#\" &\n      \"include_path#\" &\n      \"include_path_file#\" &\n+     \"inherit_source_path#\" &\n      \"language_kind#\" &\n      \"language_processing#\" &\n      \"languages#\" &\n+     \"library#\" &\n      \"library_ali_dir#\" &\n      \"library_auto_init#\" &\n      \"library_auto_init_supported#\" &\n@@ -941,6 +958,8 @@ package body Snames is\n          return Pragma_Interface;\n       elsif N = Name_Priority then\n          return Pragma_Priority;\n+      elsif N = Name_Relative_Deadline then\n+         return Pragma_Relative_Deadline;\n       elsif N = Name_Storage_Size then\n          return Pragma_Storage_Size;\n       elsif N = Name_Storage_Unit then\n@@ -1130,6 +1149,7 @@ package body Snames is\n         or else N = Name_AST_Entry\n         or else N = Name_Fast_Math\n         or else N = Name_Interface\n+        or else N = Name_Relative_Deadline\n         or else N = Name_Priority\n         or else N = Name_Storage_Size\n         or else N = Name_Storage_Unit;"}, {"sha": "696603a14292f2104cbc8408b6eda3c56ca70640", "filename": "gcc/ada/snames.ads", "status": "modified", "additions": 779, "deletions": 751, "changes": 1530, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsnames.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsnames.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads?ref=21d279972261484650109d662caf32b73a91bf1d"}, {"sha": "80ed0392a30ce00401017732426496d00371814b", "filename": "gcc/ada/snames.h", "status": "modified", "additions": 280, "deletions": 271, "changes": 551, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsnames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Fsnames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.h?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2007, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -73,118 +73,122 @@ extern unsigned char Get_Attribute_Id (int);\n #define  Attr_Emax                          26\n #define  Attr_Enabled                       27\n #define  Attr_Enum_Rep                      28\n-#define  Attr_Epsilon                       29\n-#define  Attr_Exponent                      30\n-#define  Attr_External_Tag                  31\n-#define  Attr_Fast_Math                     32\n-#define  Attr_First                         33\n-#define  Attr_First_Bit                     34\n-#define  Attr_Fixed_Value                   35\n-#define  Attr_Fore                          36\n-#define  Attr_Has_Access_Values             37\n-#define  Attr_Has_Discriminants             38\n-#define  Attr_Identity                      39\n-#define  Attr_Img                           40\n-#define  Attr_Integer_Value                 41\n-#define  Attr_Large                         42\n-#define  Attr_Last                          43\n-#define  Attr_Last_Bit                      44\n-#define  Attr_Leading_Part                  45\n-#define  Attr_Length                        46\n-#define  Attr_Machine_Emax                  47\n-#define  Attr_Machine_Emin                  48\n-#define  Attr_Machine_Mantissa              49\n-#define  Attr_Machine_Overflows             50\n-#define  Attr_Machine_Radix                 51\n-#define  Attr_Machine_Rounding              52\n-#define  Attr_Machine_Rounds                53\n-#define  Attr_Machine_Size                  54\n-#define  Attr_Mantissa                      55\n-#define  Attr_Max_Size_In_Storage_Elements  56\n-#define  Attr_Maximum_Alignment             57\n-#define  Attr_Mechanism_Code                58\n-#define  Attr_Mod                           59\n-#define  Attr_Model_Emin                    60\n-#define  Attr_Model_Epsilon                 61\n-#define  Attr_Model_Mantissa                62\n-#define  Attr_Model_Small                   63\n-#define  Attr_Modulus                       64\n-#define  Attr_Null_Parameter                65\n-#define  Attr_Object_Size                   66\n-#define  Attr_Old                           67\n-#define  Attr_Partition_ID                  68\n-#define  Attr_Passed_By_Reference           69\n-#define  Attr_Pool_Address                  70\n-#define  Attr_Pos                           71\n-#define  Attr_Position                      72\n-#define  Attr_Priority                      73\n-#define  Attr_Range                         74\n-#define  Attr_Range_Length                  75\n-#define  Attr_Round                         76\n-#define  Attr_Safe_Emax                     77\n-#define  Attr_Safe_First                    78\n-#define  Attr_Safe_Large                    79\n-#define  Attr_Safe_Last                     80\n-#define  Attr_Safe_Small                    81\n-#define  Attr_Scale                         82\n-#define  Attr_Scaling                       83\n-#define  Attr_Signed_Zeros                  84\n-#define  Attr_Size                          85\n-#define  Attr_Small                         86\n-#define  Attr_Storage_Size                  87\n-#define  Attr_Storage_Unit                  88\n-#define  Attr_Stream_Size                   89\n-#define  Attr_Tag                           90\n-#define  Attr_Target_Name                   91\n-#define  Attr_Terminated                    92\n-#define  Attr_To_Address                    93\n-#define  Attr_Type_Class                    94\n-#define  Attr_UET_Address                   95\n-#define  Attr_Unbiased_Rounding             96\n-#define  Attr_Unchecked_Access              97\n-#define  Attr_Unconstrained_Array           98\n-#define  Attr_Universal_Literal_String      99\n-#define  Attr_Unrestricted_Access           100\n-#define  Attr_VADS_Size                     101\n-#define  Attr_Val                           102\n-#define  Attr_Valid                         103\n-#define  Attr_Value_Size                    104\n-#define  Attr_Version                       105\n-#define  Attr_Wchar_T_Size                  106\n-#define  Attr_Wide_Wide_Width               107\n-#define  Attr_Wide_Width                    108\n-#define  Attr_Width                         109\n-#define  Attr_Word_Size                     110\n-#define  Attr_Adjacent                      111\n-#define  Attr_Ceiling                       112\n-#define  Attr_Copy_Sign                     113\n-#define  Attr_Floor                         114\n-#define  Attr_Fraction                      115\n-#define  Attr_Image                         116\n-#define  Attr_Input                         117\n-#define  Attr_Machine                       118\n-#define  Attr_Max                           119\n-#define  Attr_Min                           120\n-#define  Attr_Model                         121\n-#define  Attr_Pred                          122\n-#define  Attr_Remainder                     123\n-#define  Attr_Rounding                      124\n-#define  Attr_Succ                          125\n-#define  Attr_Truncation                    126\n-#define  Attr_Value                         127\n-#define  Attr_Wide_Image                    128\n-#define  Attr_Wide_Wide_Image               129\n-#define  Attr_Wide_Value                    130\n-#define  Attr_Wide_Wide_Value               131\n-#define  Attr_Output                        132\n-#define  Attr_Read                          133\n-#define  Attr_Write                         134\n-#define  Attr_Elab_Body                     135\n-#define  Attr_Elab_Spec                     136\n-#define  Attr_Storage_Pool                  137\n-#define  Attr_Base                          138\n-#define  Attr_Class                         139\n-#define  Attr_Stub_Type                     140\n+#define  Attr_Enum_Val                      29\n+#define  Attr_Epsilon                       30\n+#define  Attr_Exponent                      31\n+#define  Attr_External_Tag                  32\n+#define  Attr_Fast_Math                     33\n+#define  Attr_First                         34\n+#define  Attr_First_Bit                     35\n+#define  Attr_Fixed_Value                   36\n+#define  Attr_Fore                          37\n+#define  Attr_Has_Access_Values             38\n+#define  Attr_Has_Discriminants             39\n+#define  Attr_Has_Tagged_Values             40\n+#define  Attr_Identity                      41\n+#define  Attr_Img                           42\n+#define  Attr_Integer_Value                 43\n+#define  Attr_Invalid_Value                 44\n+#define  Attr_Large                         45\n+#define  Attr_Last                          46\n+#define  Attr_Last_Bit                      47\n+#define  Attr_Leading_Part                  48\n+#define  Attr_Length                        49\n+#define  Attr_Machine_Emax                  50\n+#define  Attr_Machine_Emin                  51\n+#define  Attr_Machine_Mantissa              52\n+#define  Attr_Machine_Overflows             53\n+#define  Attr_Machine_Radix                 54\n+#define  Attr_Machine_Rounding              55\n+#define  Attr_Machine_Rounds                56\n+#define  Attr_Machine_Size                  57\n+#define  Attr_Mantissa                      58\n+#define  Attr_Max_Size_In_Storage_Elements  59\n+#define  Attr_Maximum_Alignment             60\n+#define  Attr_Mechanism_Code                61\n+#define  Attr_Mod                           62\n+#define  Attr_Model_Emin                    63\n+#define  Attr_Model_Epsilon                 64\n+#define  Attr_Model_Mantissa                65\n+#define  Attr_Model_Small                   66\n+#define  Attr_Modulus                       67\n+#define  Attr_Null_Parameter                68\n+#define  Attr_Object_Size                   69\n+#define  Attr_Old                           70\n+#define  Attr_Partition_ID                  71\n+#define  Attr_Passed_By_Reference           72\n+#define  Attr_Pool_Address                  73\n+#define  Attr_Pos                           74\n+#define  Attr_Position                      75\n+#define  Attr_Priority                      76\n+#define  Attr_Range                         77\n+#define  Attr_Range_Length                  78\n+#define  Attr_Result                        79\n+#define  Attr_Round                         80\n+#define  Attr_Safe_Emax                     81\n+#define  Attr_Safe_First                    82\n+#define  Attr_Safe_Large                    83\n+#define  Attr_Safe_Last                     84\n+#define  Attr_Safe_Small                    85\n+#define  Attr_Scale                         86\n+#define  Attr_Scaling                       87\n+#define  Attr_Signed_Zeros                  88\n+#define  Attr_Size                          89\n+#define  Attr_Small                         90\n+#define  Attr_Storage_Size                  91\n+#define  Attr_Storage_Unit                  92\n+#define  Attr_Stream_Size                   93\n+#define  Attr_Tag                           94\n+#define  Attr_Target_Name                   95\n+#define  Attr_Terminated                    96\n+#define  Attr_To_Address                    97\n+#define  Attr_Type_Class                    98\n+#define  Attr_UET_Address                   99\n+#define  Attr_Unbiased_Rounding             100\n+#define  Attr_Unchecked_Access              101\n+#define  Attr_Unconstrained_Array           102\n+#define  Attr_Universal_Literal_String      103\n+#define  Attr_Unrestricted_Access           104\n+#define  Attr_VADS_Size                     105\n+#define  Attr_Val                           106\n+#define  Attr_Valid                         107\n+#define  Attr_Value_Size                    108\n+#define  Attr_Version                       109\n+#define  Attr_Wchar_T_Size                  110\n+#define  Attr_Wide_Wide_Width               111\n+#define  Attr_Wide_Width                    112\n+#define  Attr_Width                         113\n+#define  Attr_Word_Size                     114\n+#define  Attr_Adjacent                      115\n+#define  Attr_Ceiling                       116\n+#define  Attr_Copy_Sign                     117\n+#define  Attr_Floor                         118\n+#define  Attr_Fraction                      119\n+#define  Attr_Image                         120\n+#define  Attr_Input                         121\n+#define  Attr_Machine                       122\n+#define  Attr_Max                           123\n+#define  Attr_Min                           124\n+#define  Attr_Model                         125\n+#define  Attr_Pred                          126\n+#define  Attr_Remainder                     127\n+#define  Attr_Rounding                      128\n+#define  Attr_Succ                          129\n+#define  Attr_Truncation                    130\n+#define  Attr_Value                         131\n+#define  Attr_Wide_Image                    132\n+#define  Attr_Wide_Wide_Image               133\n+#define  Attr_Wide_Value                    134\n+#define  Attr_Wide_Wide_Value               135\n+#define  Attr_Output                        136\n+#define  Attr_Read                          137\n+#define  Attr_Write                         138\n+#define  Attr_Elab_Body                     139\n+#define  Attr_Elab_Spec                     140\n+#define  Attr_Storage_Pool                  141\n+#define  Attr_Base                          142\n+#define  Attr_Class                         143\n+#define  Attr_Stub_Type                     144\n \n /* Define the numeric values for the conventions.  */\n \n@@ -224,163 +228,168 @@ extern unsigned char Get_Pragma_Id (int);\n #define  Pragma_Assertion_Policy              4\n #define  Pragma_C_Pass_By_Copy                5\n #define  Pragma_Check_Name                    6\n-#define  Pragma_Compile_Time_Error            7\n-#define  Pragma_Compile_Time_Warning          8\n-#define  Pragma_Compiler_Unit                 9\n-#define  Pragma_Component_Alignment           10\n-#define  Pragma_Convention_Identifier         11\n-#define  Pragma_Debug_Policy                  12\n-#define  Pragma_Detect_Blocking               13\n-#define  Pragma_Discard_Names                 14\n-#define  Pragma_Elaboration_Checks            15\n-#define  Pragma_Eliminate                     16\n-#define  Pragma_Extend_System                 17\n-#define  Pragma_Extensions_Allowed            18\n-#define  Pragma_External_Name_Casing          19\n-#define  Pragma_Favor_Top_Level               20\n-#define  Pragma_Float_Representation          21\n-#define  Pragma_Implicit_Packing              22\n-#define  Pragma_Initialize_Scalars            23\n-#define  Pragma_Interrupt_State               24\n-#define  Pragma_License                       25\n-#define  Pragma_Locking_Policy                26\n-#define  Pragma_Long_Float                    27\n-#define  Pragma_No_Run_Time                   28\n-#define  Pragma_No_Strict_Aliasing            29\n-#define  Pragma_Normalize_Scalars             30\n-#define  Pragma_Optimize_Alignment            31\n-#define  Pragma_Polling                       32\n-#define  Pragma_Persistent_BSS                33\n-#define  Pragma_Priority_Specific_Dispatching 34\n-#define  Pragma_Profile                       35\n-#define  Pragma_Profile_Warnings              36\n-#define  Pragma_Propagate_Exceptions          37\n-#define  Pragma_Queuing_Policy                38\n-#define  Pragma_Ravenscar                     39\n-#define  Pragma_Restricted_Run_Time           40\n-#define  Pragma_Restrictions                  41\n-#define  Pragma_Restriction_Warnings          42\n-#define  Pragma_Reviewable                    43\n-#define  Pragma_Source_File_Name              44\n-#define  Pragma_Source_File_Name_Project      45\n-#define  Pragma_Style_Checks                  46\n-#define  Pragma_Suppress                      47\n-#define  Pragma_Suppress_Exception_Locations  48\n-#define  Pragma_Task_Dispatching_Policy       49\n-#define  Pragma_Universal_Data                50\n-#define  Pragma_Unsuppress                    51\n-#define  Pragma_Use_VADS_Size                 52\n-#define  Pragma_Validity_Checks               53\n-#define  Pragma_Warnings                      54\n-#define  Pragma_Wide_Character_Encoding       55\n-#define  Pragma_Abort_Defer                   56\n-#define  Pragma_All_Calls_Remote              57\n-#define  Pragma_Annotate                      58\n-#define  Pragma_Assert                        59\n-#define  Pragma_Asynchronous                  60\n-#define  Pragma_Atomic                        61\n-#define  Pragma_Atomic_Components             62\n-#define  Pragma_Attach_Handler                63\n-#define  Pragma_CIL_Constructor               64\n-#define  Pragma_Comment                       65\n-#define  Pragma_Common_Object                 66\n-#define  Pragma_Complete_Representation       67\n-#define  Pragma_Complex_Representation        68\n-#define  Pragma_Controlled                    69\n-#define  Pragma_Convention                    70\n-#define  Pragma_CPP_Class                     71\n-#define  Pragma_CPP_Constructor               72\n-#define  Pragma_CPP_Virtual                   73\n-#define  Pragma_CPP_Vtable                    74\n-#define  Pragma_Debug                         75\n-#define  Pragma_Elaborate                     76\n-#define  Pragma_Elaborate_All                 77\n-#define  Pragma_Elaborate_Body                78\n-#define  Pragma_Export                        79\n-#define  Pragma_Export_Exception              80\n-#define  Pragma_Export_Function               81\n-#define  Pragma_Export_Object                 82\n-#define  Pragma_Export_Procedure              83\n-#define  Pragma_Export_Value                  84\n-#define  Pragma_Export_Valued_Procedure       85\n-#define  Pragma_External                      86\n-#define  Pragma_Finalize_Storage_Only         87\n-#define  Pragma_Ident                         88\n-#define  Pragma_Implemented_By_Entry          89\n-#define  Pragma_Import                        90\n-#define  Pragma_Import_Exception              91\n-#define  Pragma_Import_Function               92\n-#define  Pragma_Import_Object                 93\n-#define  Pragma_Import_Procedure              94\n-#define  Pragma_Import_Valued_Procedure       95\n-#define  Pragma_Inline                        96\n-#define  Pragma_Inline_Always                 97\n-#define  Pragma_Inline_Generic                98\n-#define  Pragma_Inspection_Point              99\n-#define  Pragma_Interface_Name                100\n-#define  Pragma_Interrupt_Handler             101\n-#define  Pragma_Interrupt_Priority            102\n-#define  Pragma_Java_Constructor              103\n-#define  Pragma_Java_Interface                104\n-#define  Pragma_Keep_Names                    105\n-#define  Pragma_Link_With                     106\n-#define  Pragma_Linker_Alias                  107\n-#define  Pragma_Linker_Constructor            108\n-#define  Pragma_Linker_Destructor             109\n-#define  Pragma_Linker_Options                110\n-#define  Pragma_Linker_Section                111\n-#define  Pragma_List                          112\n-#define  Pragma_Machine_Attribute             113\n-#define  Pragma_Main                          114\n-#define  Pragma_Main_Storage                  115\n-#define  Pragma_Memory_Size                   116\n-#define  Pragma_No_Body                       117\n-#define  Pragma_No_Return                     118\n-#define  Pragma_Obsolescent                   119\n-#define  Pragma_Optimize                      120\n-#define  Pragma_Pack                          121\n-#define  Pragma_Page                          122\n-#define  Pragma_Passive                       123\n-#define  Pragma_Preelaborable_Initialization  124\n-#define  Pragma_Preelaborate                  125\n-#define  Pragma_Preelaborate_05               126\n-#define  Pragma_Psect_Object                  127\n-#define  Pragma_Pure                          128\n-#define  Pragma_Pure_05                       129\n-#define  Pragma_Pure_Function                 130\n-#define  Pragma_Remote_Call_Interface         131\n-#define  Pragma_Remote_Types                  132\n-#define  Pragma_Share_Generic                 133\n-#define  Pragma_Shared                        134\n-#define  Pragma_Shared_Passive                135\n-#define  Pragma_Source_Reference              136\n-#define  Pragma_Static_Elaboration_Desired    137\n-#define  Pragma_Stream_Convert                138\n-#define  Pragma_Subtitle                      139\n-#define  Pragma_Suppress_All                  140\n-#define  Pragma_Suppress_Debug_Info           141\n-#define  Pragma_Suppress_Initialization       142\n-#define  Pragma_System_Name                   143\n-#define  Pragma_Task_Info                     144\n-#define  Pragma_Task_Name                     145\n-#define  Pragma_Task_Storage                  146\n-#define  Pragma_Time_Slice                    147\n-#define  Pragma_Title                         148\n-#define  Pragma_Unchecked_Union               149\n-#define  Pragma_Unimplemented_Unit            150\n-#define  Pragma_Universal_Aliasing            151\n-#define  Pragma_Unmodified                    152\n-#define  Pragma_Unreferenced                  153\n-#define  Pragma_Unreferenced_Objects          154\n-#define  Pragma_Unreserve_All_Interrupts      155\n-#define  Pragma_Volatile                      156\n-#define  Pragma_Volatile_Components           157\n-#define  Pragma_Weak_External                 158\n-#define  Pragma_AST_Entry                     159\n-#define  Pragma_Fast_Math                     160\n-#define  Pragma_Interface                     161\n-#define  Pragma_Priority                      162\n-#define  Pragma_Storage_Size                  163\n-#define  Pragma_Storage_Unit                  164\n+#define  Pragma_Check_Policy                  7\n+#define  Pragma_Compile_Time_Error            8\n+#define  Pragma_Compile_Time_Warning          9\n+#define  Pragma_Compiler_Unit                 10\n+#define  Pragma_Component_Alignment           11\n+#define  Pragma_Convention_Identifier         12\n+#define  Pragma_Debug_Policy                  13\n+#define  Pragma_Detect_Blocking               14\n+#define  Pragma_Discard_Names                 15\n+#define  Pragma_Elaboration_Checks            16\n+#define  Pragma_Eliminate                     17\n+#define  Pragma_Extend_System                 18\n+#define  Pragma_Extensions_Allowed            19\n+#define  Pragma_External_Name_Casing          20\n+#define  Pragma_Favor_Top_Level               21\n+#define  Pragma_Float_Representation          22\n+#define  Pragma_Implicit_Packing              23\n+#define  Pragma_Initialize_Scalars            24\n+#define  Pragma_Interrupt_State               25\n+#define  Pragma_License                       26\n+#define  Pragma_Locking_Policy                27\n+#define  Pragma_Long_Float                    28\n+#define  Pragma_No_Run_Time                   29\n+#define  Pragma_No_Strict_Aliasing            30\n+#define  Pragma_Normalize_Scalars             31\n+#define  Pragma_Optimize_Alignment            32\n+#define  Pragma_Polling                       33\n+#define  Pragma_Persistent_BSS                34\n+#define  Pragma_Priority_Specific_Dispatching 35\n+#define  Pragma_Profile                       36\n+#define  Pragma_Profile_Warnings              37\n+#define  Pragma_Propagate_Exceptions          38\n+#define  Pragma_Queuing_Policy                39\n+#define  Pragma_Ravenscar                     40\n+#define  Pragma_Restricted_Run_Time           41\n+#define  Pragma_Restrictions                  42\n+#define  Pragma_Restriction_Warnings          43\n+#define  Pragma_Reviewable                    44\n+#define  Pragma_Source_File_Name              45\n+#define  Pragma_Source_File_Name_Project      46\n+#define  Pragma_Style_Checks                  47\n+#define  Pragma_Suppress                      48\n+#define  Pragma_Suppress_Exception_Locations  49\n+#define  Pragma_Task_Dispatching_Policy       50\n+#define  Pragma_Universal_Data                51\n+#define  Pragma_Unsuppress                    52\n+#define  Pragma_Use_VADS_Size                 53\n+#define  Pragma_Validity_Checks               54\n+#define  Pragma_Warnings                      55\n+#define  Pragma_Wide_Character_Encoding       56\n+#define  Pragma_Abort_Defer                   57\n+#define  Pragma_All_Calls_Remote              58\n+#define  Pragma_Annotate                      59\n+#define  Pragma_Assert                        60\n+#define  Pragma_Asynchronous                  61\n+#define  Pragma_Atomic                        62\n+#define  Pragma_Atomic_Components             63\n+#define  Pragma_Attach_Handler                64\n+#define  Pragma_Check                         65\n+#define  Pragma_CIL_Constructor               66\n+#define  Pragma_Comment                       67\n+#define  Pragma_Common_Object                 68\n+#define  Pragma_Complete_Representation       69\n+#define  Pragma_Complex_Representation        70\n+#define  Pragma_Controlled                    71\n+#define  Pragma_Convention                    72\n+#define  Pragma_CPP_Class                     73\n+#define  Pragma_CPP_Constructor               74\n+#define  Pragma_CPP_Virtual                   75\n+#define  Pragma_CPP_Vtable                    76\n+#define  Pragma_Debug                         77\n+#define  Pragma_Elaborate                     78\n+#define  Pragma_Elaborate_All                 79\n+#define  Pragma_Elaborate_Body                80\n+#define  Pragma_Export                        81\n+#define  Pragma_Export_Exception              82\n+#define  Pragma_Export_Function               83\n+#define  Pragma_Export_Object                 84\n+#define  Pragma_Export_Procedure              85\n+#define  Pragma_Export_Value                  86\n+#define  Pragma_Export_Valued_Procedure       87\n+#define  Pragma_External                      88\n+#define  Pragma_Finalize_Storage_Only         89\n+#define  Pragma_Ident                         90\n+#define  Pragma_Implemented_By_Entry          91\n+#define  Pragma_Import                        92\n+#define  Pragma_Import_Exception              93\n+#define  Pragma_Import_Function               94\n+#define  Pragma_Import_Object                 95\n+#define  Pragma_Import_Procedure              96\n+#define  Pragma_Import_Valued_Procedure       97\n+#define  Pragma_Inline                        98\n+#define  Pragma_Inline_Always                 99\n+#define  Pragma_Inline_Generic                100\n+#define  Pragma_Inspection_Point              101\n+#define  Pragma_Interface_Name                102\n+#define  Pragma_Interrupt_Handler             103\n+#define  Pragma_Interrupt_Priority            104\n+#define  Pragma_Java_Constructor              105\n+#define  Pragma_Java_Interface                106\n+#define  Pragma_Keep_Names                    107\n+#define  Pragma_Link_With                     108\n+#define  Pragma_Linker_Alias                  109\n+#define  Pragma_Linker_Constructor            110\n+#define  Pragma_Linker_Destructor             111\n+#define  Pragma_Linker_Options                112\n+#define  Pragma_Linker_Section                113\n+#define  Pragma_List                          114\n+#define  Pragma_Machine_Attribute             115\n+#define  Pragma_Main                          116\n+#define  Pragma_Main_Storage                  117\n+#define  Pragma_Memory_Size                   118\n+#define  Pragma_No_Body                       119\n+#define  Pragma_No_Return                     120\n+#define  Pragma_Obsolescent                   121\n+#define  Pragma_Optimize                      122\n+#define  Pragma_Pack                          123\n+#define  Pragma_Page                          124\n+#define  Pragma_Passive                       125\n+#define  Pragma_Postcondition                 126\n+#define  Pragma_Precondition                  127\n+#define  Pragma_Preelaborable_Initialization  128\n+#define  Pragma_Preelaborate                  129\n+#define  Pragma_Preelaborate_05               130\n+#define  Pragma_Psect_Object                  131\n+#define  Pragma_Pure                          132\n+#define  Pragma_Pure_05                       133\n+#define  Pragma_Pure_Function                 134\n+#define  Pragma_Relative_Deadline             135\n+#define  Pragma_Remote_Call_Interface         136\n+#define  Pragma_Remote_Types                  137\n+#define  Pragma_Share_Generic                 138\n+#define  Pragma_Shared                        139\n+#define  Pragma_Shared_Passive                140\n+#define  Pragma_Source_Reference              141\n+#define  Pragma_Static_Elaboration_Desired    142\n+#define  Pragma_Stream_Convert                143\n+#define  Pragma_Subtitle                      144\n+#define  Pragma_Suppress_All                  145\n+#define  Pragma_Suppress_Debug_Info           146\n+#define  Pragma_Suppress_Initialization       147\n+#define  Pragma_System_Name                   148\n+#define  Pragma_Task_Info                     149\n+#define  Pragma_Task_Name                     150\n+#define  Pragma_Task_Storage                  151\n+#define  Pragma_Time_Slice                    152\n+#define  Pragma_Title                         153\n+#define  Pragma_Unchecked_Union               154\n+#define  Pragma_Unimplemented_Unit            155\n+#define  Pragma_Universal_Aliasing            156\n+#define  Pragma_Unmodified                    157\n+#define  Pragma_Unreferenced                  158\n+#define  Pragma_Unreferenced_Objects          159\n+#define  Pragma_Unreserve_All_Interrupts      160\n+#define  Pragma_Volatile                      161\n+#define  Pragma_Volatile_Components           162\n+#define  Pragma_Weak_External                 163\n+#define  Pragma_AST_Entry                     164\n+#define  Pragma_Fast_Math                     165\n+#define  Pragma_Interface                     166\n+#define  Pragma_Priority                      167\n+#define  Pragma_Storage_Size                  168\n+#define  Pragma_Storage_Unit                  169\n \n /* End of snames.h (C version of Snames package spec) */"}, {"sha": "901d373b300cb38539662200015626714c86eba8", "filename": "gcc/ada/tree_gen.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Ftree_gen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Ftree_gen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftree_gen.adb?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2007, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -32,12 +32,19 @@ with Nlists;\n with Opt;\n with Osint.C;\n with Repinfo;\n+with Sem_Aux;\n with Sinput;\n with Stand;\n with Stringt;\n with Uintp;\n with Urealp;\n \n+with Tree_In;\n+pragma Warnings (Off, Tree_In);\n+--  We do not use Tree_In in the compiler, but it is small, and worth including\n+--  so that we get the proper license check for Tree_In when the compiler is\n+--  built. This will avoid adding bad dependencies to Tree_In and blowing ASIS.\n+\n procedure Tree_Gen is\n begin\n    if Opt.Tree_Output then\n@@ -49,6 +56,7 @@ begin\n       Lib.Tree_Write;\n       Namet.Tree_Write;\n       Nlists.Tree_Write;\n+      Sem_Aux.Tree_Write;\n       Sinput.Tree_Write;\n       Stand.Tree_Write;\n       Stringt.Tree_Write;"}, {"sha": "605c6b182aa290158cf231040321ae2caaf658ca", "filename": "gcc/ada/tree_in.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Ftree_in.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21d279972261484650109d662caf32b73a91bf1d/gcc%2Fada%2Ftree_in.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftree_in.adb?ref=21d279972261484650109d662caf32b73a91bf1d", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-1999, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -40,6 +40,7 @@ with Namet;\n with Nlists;\n with Opt;\n with Repinfo;\n+with Sem_Aux;\n with Sinput;\n with Stand;\n with Stringt;\n@@ -57,6 +58,7 @@ begin\n    Lib.Tree_Read;\n    Namet.Tree_Read;\n    Nlists.Tree_Read;\n+   Sem_Aux.Tree_Read;\n    Sinput.Tree_Read;\n    Stand.Tree_Read;\n    Stringt.Tree_Read;"}]}