{"sha": "5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWEyNzFhN2YzYTI5ODNlMTUyOWVhNWM3Zjk4ZDZlYTVkNmIxMTNjZg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2015-03-02T11:03:29Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-03-02T11:03:29Z"}, "message": "debug.adb: Document new debug flag -gnatd.1.\n\n2015-03-02  Robert Dewar  <dewar@adacore.com>\n\n\t* debug.adb: Document new debug flag -gnatd.1.\n\t* einfo.ads, einfo.adb (Has_Nested_Subprogram): New flag.\n\t(Has_Uplevel_Reference): New flag (Is_Static_Type): New flag.\n\t(Uplevel_Reference_Noted):New flag (Uplevel_References): New field.\n\t* elists.ads elists.adb (List_Length): New function.\n\t* exp_ch6.adb (Expand_N_Subprogram_Body): Call Unnest_Subprogram\n\twhen appropriate (Process_Preconditions): Minor code\n\treorganization and reformatting\n\t* exp_unst.ads, exp_unst.adb: New files.\n\t* gnat1drv.adb (Adjust_Global_Switches): Set\n\tUnnest_Subprogram_Mode if -gnatd.1\n\t* namet.ads, namet.adb (Name_Find_Str): New version of Name_Find with\n\tstring argument.\n\t* opt.ads (Unnest_Subprogram_Mode): New flag.\n\t* par-ch3.adb (P_Identifier_Declarations): Fixes to -gnatd.2 handling.\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Set\n\tHas_Nested_Subprogram flag.\n\t* sem_ch8.adb (Find_Direct_Name): New calling sequence for\n\tCheck_Nested_Access.\n\t(Find_Selected_Component): Minor comment addition.\n\t* sem_util.adb (Check_Nested_Access): New version for use with Exp_Unst.\n\t(Note_Possible_Modification): New calling sequence for\n\tCheck_Nested_Access.\n\t* sem_util.ads (Check_Nested_Access): New version for use with Exp_Unst.\n\t* gcc-interface/Make-lang.in (GNAT1_OBJS): Add exp_unst.o\n\nFrom-SVN: r221109", "tree": {"sha": "de54e6e3eb711dc460a5257554759c053564c7c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de54e6e3eb711dc460a5257554759c053564c7c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/comments", "author": null, "committer": null, "parents": [{"sha": "aef308d0d6a4d64fb220d88d0e7b736d70fd88da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aef308d0d6a4d64fb220d88d0e7b736d70fd88da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aef308d0d6a4d64fb220d88d0e7b736d70fd88da"}], "stats": {"total": 1512, "additions": 1454, "deletions": 58}, "files": [{"sha": "0a4d3f9bf12b6632131bb203b37af3d49f950ef7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "patch": "@@ -1,3 +1,31 @@\n+2015-03-02  Robert Dewar  <dewar@adacore.com>\n+\n+\t* debug.adb: Document new debug flag -gnatd.1.\n+\t* einfo.ads, einfo.adb (Has_Nested_Subprogram): New flag.\n+\t(Has_Uplevel_Reference): New flag (Is_Static_Type): New flag.\n+\t(Uplevel_Reference_Noted):New flag (Uplevel_References): New field.\n+\t* elists.ads elists.adb (List_Length): New function.\n+\t* exp_ch6.adb (Expand_N_Subprogram_Body): Call Unnest_Subprogram\n+\twhen appropriate (Process_Preconditions): Minor code\n+\treorganization and reformatting\n+\t* exp_unst.ads, exp_unst.adb: New files.\n+\t* gnat1drv.adb (Adjust_Global_Switches): Set\n+\tUnnest_Subprogram_Mode if -gnatd.1\n+\t* namet.ads, namet.adb (Name_Find_Str): New version of Name_Find with\n+\tstring argument.\n+\t* opt.ads (Unnest_Subprogram_Mode): New flag.\n+\t* par-ch3.adb (P_Identifier_Declarations): Fixes to -gnatd.2 handling.\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Set\n+\tHas_Nested_Subprogram flag.\n+\t* sem_ch8.adb (Find_Direct_Name): New calling sequence for\n+\tCheck_Nested_Access.\n+\t(Find_Selected_Component): Minor comment addition.\n+\t* sem_util.adb (Check_Nested_Access): New version for use with Exp_Unst.\n+\t(Note_Possible_Modification): New calling sequence for\n+\tCheck_Nested_Access.\n+\t* sem_util.ads (Check_Nested_Access): New version for use with Exp_Unst.\n+\t* gcc-interface/Make-lang.in (GNAT1_OBJS): Add exp_unst.o\n+\n 2015-03-02  Pierre-Marie de Rodat  <derodat@adacore.com>\n \n \t* gcc-interface/utils.c (gnat_pushdecl): For non-artificial pointer"}, {"sha": "e04b5b55856e7811e0fc95b46ed066637bc58c83", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "patch": "@@ -746,9 +746,10 @@ package body Debug is\n    --  d9   This allows lock free implementation for protected objects\n    --       (see Exp_Ch9).\n \n-   --  d.1  Enable unnesting of nested procedures. This special pass does not\n-   --       actually unnest things, but it ensures that a nested procedure\n-   --       does not contain any uplevel references.\n+   --  d.1  Sets Opt.Unnest_Subprogram_Mode to enable unnesting of subprograms.\n+   --       This special pass does not actually unnest things, but it ensures\n+   --       that a nested procedure does not contain any uplevel references.\n+   --       See spec of Exp_Unst for full details.\n \n    --  d.2  Allow statements within declarative parts. This is not usually\n    --       allowed, but in some debugging contexts (e.g. testing the circuit"}, {"sha": "c3067b825b0a0dcd814ffc211e5a396e57fc66d5", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 65, "deletions": 12, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "patch": "@@ -213,6 +213,7 @@ package body Einfo is\n    --    Stored_Constraint               Elist23\n \n    --    Related_Expression              Node24\n+   --    Uplevel_References              Elist24\n \n    --    Interface_Alias                 Node25\n    --    Interfaces                      Elist25\n@@ -505,7 +506,7 @@ package body Einfo is\n    --    Has_Pragma_Unreferenced_Objects Flag212\n    --    Requires_Overriding             Flag213\n    --    Has_RACW                        Flag214\n-   --    Has_Up_Level_Access             Flag215\n+   --    Has_Uplevel_Reference           Flag215\n    --    Universal_Aliasing              Flag216\n    --    Suppress_Value_Tracking_On_Call Flag217\n    --    Is_Primitive                    Flag218\n@@ -578,9 +579,10 @@ package body Einfo is\n    --    Contains_Ignored_Ghost_Code     Flag279\n    --    Partial_View_Has_Unknown_Discr  Flag280\n \n-   --    (unused)                        Flag281\n-   --    (unused)                        Flag282\n-   --    (unused)                        Flag283\n+   --    Is_Static_Type                  Flag281\n+   --    Has_Nested_Subprogram           Flag282\n+   --    Uplevel_Reference_Noted         Flag283\n+\n    --    (unused)                        Flag284\n    --    (unused)                        Flag285\n    --    (unused)                        Flag286\n@@ -1544,6 +1546,12 @@ package body Einfo is\n       return Flag101 (Id);\n    end Has_Nested_Block_With_Handler;\n \n+   function Has_Nested_Subprogram (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Subprogram (Id));\n+      return Flag282 (Id);\n+   end Has_Nested_Subprogram;\n+\n    function Has_Non_Standard_Rep (Id : E) return B is\n    begin\n       return Flag75 (Implementation_Base_Type (Id));\n@@ -1786,12 +1794,10 @@ package body Einfo is\n       return Flag72 (Id);\n    end Has_Unknown_Discriminants;\n \n-   function Has_Up_Level_Access (Id : E) return B is\n+   function Has_Uplevel_Reference (Id : E) return B is\n    begin\n-      pragma Assert\n-        (Ekind_In (Id, E_Variable, E_Constant, E_Loop_Parameter));\n       return Flag215 (Id);\n-   end Has_Up_Level_Access;\n+   end Has_Uplevel_Reference;\n \n    function Has_Visible_Refinement (Id : E) return B is\n    begin\n@@ -2376,6 +2382,12 @@ package body Einfo is\n       return Flag60 (Id);\n    end Is_Shared_Passive;\n \n+   function Is_Static_Type (Id : E) return B is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      return Flag281 (Id);\n+   end Is_Static_Type;\n+\n    function Is_Statically_Allocated (Id : E) return B is\n    begin\n       return Flag28 (Id);\n@@ -3188,6 +3200,17 @@ package body Einfo is\n       return Node16 (Id);\n    end Unset_Reference;\n \n+   function Uplevel_Reference_Noted (Id : E) return B is\n+   begin\n+      return Flag283 (Id);\n+   end Uplevel_Reference_Noted;\n+\n+   function Uplevel_References (Id : E) return L is\n+   begin\n+      pragma Assert (Is_Subprogram (Id));\n+      return Elist24 (Id);\n+   end Uplevel_References;\n+\n    function Used_As_Generic_Actual (Id : E) return B is\n    begin\n       return Flag222 (Id);\n@@ -4371,11 +4394,16 @@ package body Einfo is\n       Set_Flag101 (Id, V);\n    end Set_Has_Nested_Block_With_Handler;\n \n-   procedure Set_Has_Up_Level_Access (Id : E; V : B := True) is\n+   procedure Set_Has_Nested_Subprogram (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Subprogram (Id));\n+      Set_Flag282 (Id, V);\n+   end Set_Has_Nested_Subprogram;\n+\n+   procedure Set_Has_Uplevel_Reference (Id : E; V : B := True) is\n    begin\n-      pragma Assert (Ekind_In (Id, E_Variable, E_Constant, E_Loop_Parameter));\n       Set_Flag215 (Id, V);\n-   end Set_Has_Up_Level_Access;\n+   end Set_Has_Uplevel_Reference;\n \n    procedure Set_Has_Non_Standard_Rep (Id : E; V : B := True) is\n    begin\n@@ -5270,6 +5298,12 @@ package body Einfo is\n       Set_Flag60 (Id, V);\n    end Set_Is_Shared_Passive;\n \n+   procedure Set_Is_Static_Type (Id : E; V : B := True) is\n+   begin\n+      pragma Assert (Is_Type (Id));\n+      Set_Flag281 (Id, V);\n+   end Set_Is_Static_Type;\n+\n    procedure Set_Is_Statically_Allocated (Id : E; V : B := True) is\n    begin\n       pragma Assert\n@@ -6119,6 +6153,17 @@ package body Einfo is\n       Set_Node16 (Id, V);\n    end Set_Unset_Reference;\n \n+   procedure Set_Uplevel_Reference_Noted (Id : E; V : B := True) is\n+   begin\n+      Set_Flag283 (Id, V);\n+   end Set_Uplevel_Reference_Noted;\n+\n+   procedure Set_Uplevel_References (Id : E; V : L) is\n+   begin\n+      pragma Assert (Is_Subprogram (Id));\n+      Set_Elist24 (Id, V);\n+   end Set_Uplevel_References;\n+\n    procedure Set_Used_As_Generic_Actual (Id : E; V : B := True) is\n    begin\n       Set_Flag222 (Id, V);\n@@ -8517,6 +8562,7 @@ package body Einfo is\n       W (\"Has_Master_Entity\",               Flag21  (Id));\n       W (\"Has_Missing_Return\",              Flag142 (Id));\n       W (\"Has_Nested_Block_With_Handler\",   Flag101 (Id));\n+      W (\"Has_Nested_Subprogram\",           Flag282 (Id));\n       W (\"Has_Non_Standard_Rep\",            Flag75  (Id));\n       W (\"Has_Out_Or_In_Out_Parameter\",     Flag110 (Id));\n       W (\"Has_Object_Size_Clause\",          Flag172 (Id));\n@@ -8561,7 +8607,7 @@ package body Einfo is\n       W (\"Has_Thunks\",                      Flag228 (Id));\n       W (\"Has_Unchecked_Union\",             Flag123 (Id));\n       W (\"Has_Unknown_Discriminants\",       Flag72  (Id));\n-      W (\"Has_Up_Level_Access\",             Flag215 (Id));\n+      W (\"Has_Uplevel_Reference\",           Flag215 (Id));\n       W (\"Has_Visible_Refinement\",          Flag263 (Id));\n       W (\"Has_Volatile_Components\",         Flag87  (Id));\n       W (\"Has_Xref_Entry\",                  Flag182 (Id));\n@@ -8662,6 +8708,7 @@ package body Einfo is\n       W (\"Is_Return_Object\",                Flag209 (Id));\n       W (\"Is_Safe_To_Reevaluate\",           Flag249 (Id));\n       W (\"Is_Shared_Passive\",               Flag60  (Id));\n+      W (\"Is_Static_Type\",                  Flag281 (Id));\n       W (\"Is_Statically_Allocated\",         Flag28  (Id));\n       W (\"Is_Tag\",                          Flag78  (Id));\n       W (\"Is_Tagged_Type\",                  Flag55  (Id));\n@@ -8728,6 +8775,7 @@ package body Einfo is\n       W (\"Suppress_Value_Tracking_On_Call\", Flag217 (Id));\n       W (\"Treat_As_Volatile\",               Flag41  (Id));\n       W (\"Universal_Aliasing\",              Flag216 (Id));\n+      W (\"Uplevel_Reference_Noted\",         Flag283 (Id));\n       W (\"Used_As_Generic_Actual\",          Flag222 (Id));\n       W (\"Uses_Sec_Stack\",                  Flag95  (Id));\n       W (\"Warnings_Off\",                    Flag96  (Id));\n@@ -9638,6 +9686,11 @@ package body Einfo is\n               Type_Kind                                    =>\n             Write_Str (\"Related_Expression\");\n \n+         when E_Function                                   |\n+              E_Operator                                   |\n+              E_Procedure                                  =>\n+            Write_Str (\"Uplevel_References\");\n+\n          when others                                       =>\n             Write_Str (\"Field24???\");\n       end case;"}, {"sha": "08b5319ece6214947f5d62b12eb37329ecc11843", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 66, "deletions": 13, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "patch": "@@ -1693,7 +1693,11 @@ package Einfo is\n --       optimizations to ensure that they are consistent with exceptions.\n --       See documentation in backend for further details.\n \n---    Has_Non_Null_Refinement (synth)\n+--    Has_Nested_Subprogram (Flag282)\n+--      Defined in subprogram entities. Set for a subprogram which contains at\n+--      least one nested subprogram.\n+\n+   --    Has_Non_Null_Refinement (synth)\n --       Defined in E_Abstract_State entities. True if the state has at least\n --       one variable or state constituent in aspect/pragma Refined_State.\n \n@@ -1987,12 +1991,15 @@ package Einfo is\n --       on the partial view, to insure that discriminants are properly\n --       inherited in certain contexts.\n \n---    Has_Up_Level_Access (Flag215)\n---       Defined in E_Variable and E_Constant entities. Set if the entity\n---       is a local variable declared in a subprogram p and is accessed in\n---       a subprogram nested inside p. Currently this flag is only set when\n---       VM_Target /= No_VM, for efficiency, since only the .NET back-end\n---       makes use of it to generate proper code for up-level references.\n+--    Has_Uplevel_Reference (Flag215)\n+--       Defined in all entities. Indicates that the entity is locally defined\n+--       within a subprogram P, and there is a reference to the entity within\n+--       a subprogram nested within P (at any depth). Set only for the VM case\n+--       (where it is set for variables, constants and loop parameters), and in\n+--       the case where we are unnesting nested subprograms (in which case it\n+--       is also set for types and subtypes which are not static types, and\n+--       that are referenced uplevel, as well as for subprograms that contain\n+--       uplevel references or call other subprogram, see Exp_unst for details.\n \n --    Has_Visible_Refinement (Flag263)\n --       Defined in E_Abstract_State entities. Set when a state has at least\n@@ -2966,6 +2973,16 @@ package Einfo is\n --       type is one of the standard string types (String, Wide_String, or\n --       Wide_Wide_String).\n \n+--    Is_Static_Type (Flag281)\n+--       Defined in all type and subtype entities. If set, indicates that the\n+--       type is known to be a static type (defined as a discrete type with\n+--       static bounds, a record all of whose component types are static types,\n+--       or an array, all of whose bounds are of a static type, and also have\n+--       a component type that is a static type. See Set_Uplevel_Type for more\n+--       information on how this flag is used. Note that if Is_Static_Type is\n+--       True, then it is never the case that the Has_Uplevel_Reference flag is\n+--       set for the same type.\n+\n --    Is_Statically_Allocated (Flag28)\n --       Defined in all entities. This can only be set for exception,\n --       variable, constant, and type/subtype entities. If the flag is set,\n@@ -4237,6 +4254,17 @@ package Einfo is\n --       is identified. This field is used to generate a warning message if\n --       necessary (see Sem_Warn.Check_Unset_Reference).\n \n+--    Uplevel_Reference_Noted (Flag283)\n+--       Defined in all entities, used in Exp_Unst processing to note that an\n+--       uplevel reference to the entity has been noted (to avoid processing a\n+--       given entity more than once).\n+\n+--    Uplevel_References (Elist24)\n+--       Defined in subprogram entities. Set only if Has_Uplevel_Reference is\n+--       set and if we are Unnest_Subprogram_Mode, otherwise undefined. Points\n+--       to a list of explicit uplevel references to entities declared in\n+--       the subprogram which need rewriting. See spec of Exp_Unst for details.\n+\n --    Used_As_Generic_Actual (Flag222)\n --       Defined in all entities, set if the entity is used as an argument to\n --       a generic instantiation. Used to tune certain warning messages.\n@@ -5269,6 +5297,7 @@ package Einfo is\n    --    Suppress_Elaboration_Warnings       (Flag148)\n    --    Suppress_Style_Checks               (Flag165)\n    --    Suppress_Value_Tracking_On_Call     (Flag217)\n+   --    Uplevel_Reference_Noted             (Flag283)\n    --    Used_As_Generic_Actual              (Flag222)\n    --    Warnings_Off                        (Flag96)\n    --    Warnings_Off_Used                   (Flag236)\n@@ -5339,6 +5368,7 @@ package Einfo is\n    --    Has_Static_Predicate_Aspect         (Flag259)\n    --    Has_Task                            (Flag30)   (base type only)\n    --    Has_Unchecked_Union                 (Flag123)  (base type only)\n+   --    Has_Uplevel_Reference               (Flag215)\n    --    Has_Volatile_Components             (Flag87)   (base type only)\n    --    In_Use                              (Flag8)\n    --    Is_Abstract_Type                    (Flag146)\n@@ -5355,6 +5385,7 @@ package Einfo is\n    --    Is_Non_Static_Subtype               (Flag109)\n    --    Is_Packed                           (Flag51)   (base type only)\n    --    Is_Private_Composite                (Flag107)\n+   --    Is_Static_Type                      (Flag281)\n    --    Is_Unsigned_Type                    (Flag144)\n    --    Is_Volatile                         (Flag16)\n    --    Itype_Printed                       (Flag202)  (itypes only)\n@@ -5555,7 +5586,7 @@ package Einfo is\n    --    Has_Independent_Components          (Flag34)\n    --    Has_Size_Clause                     (Flag29)\n    --    Has_Thunks                          (Flag228)  (constants only)\n-   --    Has_Up_Level_Access                 (Flag215)\n+   --    Has_Uplevel_Reference               (Flag215)\n    --    Has_Volatile_Components             (Flag87)\n    --    Is_Atomic                           (Flag85)\n    --    Is_Eliminated                       (Flag124)\n@@ -5723,6 +5754,7 @@ package Einfo is\n    --    Generic_Renamings                   (Elist23)  (for an instance)\n    --    Inner_Instances                     (Elist23)  (generic case only)\n    --    Protection_Object                   (Node23)   (for concurrent kind)\n+   --    Uplevel_References                  (Elist24)  (non-generic case only)\n    --    Interface_Alias                     (Node25)\n    --    Overridden_Operation                (Node26)\n    --    Wrapped_Entity                      (Node27)   (non-generic case only)\n@@ -5748,6 +5780,7 @@ package Einfo is\n    --    Has_Master_Entity                   (Flag21)\n    --    Has_Missing_Return                  (Flag142)\n    --    Has_Nested_Block_With_Handler       (Flag101)\n+   --    Has_Nested_Subprogram               (Flag282)\n    --    Has_Out_Or_In_Out_Parameter         (Flag110)\n    --    Has_Recursive_Call                  (Flag143)\n    --    Is_Abstract_Subprogram              (Flag19)   (non-generic case only)\n@@ -5891,6 +5924,8 @@ package Einfo is\n    --    Alias                               (Node18)\n    --    Extra_Accessibility_Of_Result       (Node19)\n    --    Last_Entity                         (Node20)\n+   --    Has_Nested_Subprogram               (Flag282)\n+   --    Uplevel_References                  (Elist24)\n    --    Overridden_Operation                (Node26)\n    --    Subprograms_For_Type                (Node29)\n    --    Linker_Section_Pragma               (Node33)\n@@ -6022,6 +6057,7 @@ package Einfo is\n    --    Generic_Renamings                   (Elist23)  (for an instance)\n    --    Inner_Instances                     (Elist23)  (generic case only)\n    --    Protection_Object                   (Node23)   (for concurrent kind)\n+   --    Uplevel_References                  (Elist24)  (non-generic case only)\n    --    Interface_Alias                     (Node25)\n    --    Overridden_Operation                (Node26)   (never for init proc)\n    --    Wrapped_Entity                      (Node27)   (non-generic case only)\n@@ -6046,6 +6082,7 @@ package Einfo is\n    --    Has_Invariants                      (Flag232)\n    --    Has_Master_Entity                   (Flag21)\n    --    Has_Nested_Block_With_Handler       (Flag101)\n+   --    Has_Nested_Subprogram               (Flag282)\n    --    Is_Abstract_Subprogram              (Flag19)   (non-generic case only)\n    --    Is_Asynchronous                     (Flag81)\n    --    Is_Called                           (Flag102)  (non-generic case only)\n@@ -6274,7 +6311,7 @@ package Einfo is\n    --    Has_Independent_Components          (Flag34)\n    --    Has_Initial_Value                   (Flag219)\n    --    Has_Size_Clause                     (Flag29)\n-   --    Has_Up_Level_Access                 (Flag215)\n+   --    Has_Uplevel_Reference               (Flag215)\n    --    Has_Volatile_Components             (Flag87)\n    --    Is_Atomic                           (Flag85)\n    --    Is_Eliminated                       (Flag124)\n@@ -6676,6 +6713,7 @@ package Einfo is\n    function Has_Master_Entity                   (Id : E) return B;\n    function Has_Missing_Return                  (Id : E) return B;\n    function Has_Nested_Block_With_Handler       (Id : E) return B;\n+   function Has_Nested_Subprogram               (Id : E) return B;\n    function Has_Non_Standard_Rep                (Id : E) return B;\n    function Has_Object_Size_Clause              (Id : E) return B;\n    function Has_Out_Or_In_Out_Parameter         (Id : E) return B;\n@@ -6720,7 +6758,7 @@ package Einfo is\n    function Has_Thunks                          (Id : E) return B;\n    function Has_Unchecked_Union                 (Id : E) return B;\n    function Has_Unknown_Discriminants           (Id : E) return B;\n-   function Has_Up_Level_Access                 (Id : E) return B;\n+   function Has_Uplevel_Reference               (Id : E) return B;\n    function Has_Visible_Refinement              (Id : E) return B;\n    function Has_Volatile_Components             (Id : E) return B;\n    function Has_Xref_Entry                      (Id : E) return B;\n@@ -6823,6 +6861,7 @@ package Einfo is\n    function Is_Return_Object                    (Id : E) return B;\n    function Is_Safe_To_Reevaluate               (Id : E) return B;\n    function Is_Shared_Passive                   (Id : E) return B;\n+   function Is_Static_Type                      (Id : E) return B;\n    function Is_Statically_Allocated             (Id : E) return B;\n    function Is_Tag                              (Id : E) return B;\n    function Is_Tagged_Type                      (Id : E) return B;\n@@ -6959,6 +6998,8 @@ package Einfo is\n    function Underlying_Record_View              (Id : E) return E;\n    function Universal_Aliasing                  (Id : E) return B;\n    function Unset_Reference                     (Id : E) return N;\n+   function Uplevel_Reference_Noted             (Id : E) return B;\n+   function Uplevel_References                  (Id : E) return L;\n    function Used_As_Generic_Actual              (Id : E) return B;\n    function Uses_Lock_Free                      (Id : E) return B;\n    function Uses_Sec_Stack                      (Id : E) return B;\n@@ -7318,6 +7359,7 @@ package Einfo is\n    procedure Set_Has_Master_Entity               (Id : E; V : B := True);\n    procedure Set_Has_Missing_Return              (Id : E; V : B := True);\n    procedure Set_Has_Nested_Block_With_Handler   (Id : E; V : B := True);\n+   procedure Set_Has_Nested_Subprogram           (Id : E; V : B := True);\n    procedure Set_Has_Non_Standard_Rep            (Id : E; V : B := True);\n    procedure Set_Has_Object_Size_Clause          (Id : E; V : B := True);\n    procedure Set_Has_Out_Or_In_Out_Parameter     (Id : E; V : B := True);\n@@ -7362,7 +7404,7 @@ package Einfo is\n    procedure Set_Has_Thunks                      (Id : E; V : B := True);\n    procedure Set_Has_Unchecked_Union             (Id : E; V : B := True);\n    procedure Set_Has_Unknown_Discriminants       (Id : E; V : B := True);\n-   procedure Set_Has_Up_Level_Access             (Id : E; V : B := True);\n+   procedure Set_Has_Uplevel_Reference           (Id : E; V : B := True);\n    procedure Set_Has_Visible_Refinement          (Id : E; V : B := True);\n    procedure Set_Has_Volatile_Components         (Id : E; V : B := True);\n    procedure Set_Has_Xref_Entry                  (Id : E; V : B := True);\n@@ -7471,6 +7513,7 @@ package Einfo is\n    procedure Set_Is_Return_Object                (Id : E; V : B := True);\n    procedure Set_Is_Safe_To_Reevaluate           (Id : E; V : B := True);\n    procedure Set_Is_Shared_Passive               (Id : E; V : B := True);\n+   procedure Set_Is_Static_Type                  (Id : E; V : B := True);\n    procedure Set_Is_Statically_Allocated         (Id : E; V : B := True);\n    procedure Set_Is_Tag                          (Id : E; V : B := True);\n    procedure Set_Is_Tagged_Type                  (Id : E; V : B := True);\n@@ -7607,6 +7650,8 @@ package Einfo is\n    procedure Set_Underlying_Record_View          (Id : E; V : E);\n    procedure Set_Universal_Aliasing              (Id : E; V : B := True);\n    procedure Set_Unset_Reference                 (Id : E; V : N);\n+   procedure Set_Uplevel_Reference_Noted         (Id : E; V : B := True);\n+   procedure Set_Uplevel_References              (Id : E; V : L);\n    procedure Set_Used_As_Generic_Actual          (Id : E; V : B := True);\n    procedure Set_Uses_Lock_Free                  (Id : E; V : B := True);\n    procedure Set_Uses_Sec_Stack                  (Id : E; V : B := True);\n@@ -8076,6 +8121,7 @@ package Einfo is\n    pragma Inline (Has_Master_Entity);\n    pragma Inline (Has_Missing_Return);\n    pragma Inline (Has_Nested_Block_With_Handler);\n+   pragma Inline (Has_Nested_Subprogram);\n    pragma Inline (Has_Non_Standard_Rep);\n    pragma Inline (Has_Object_Size_Clause);\n    pragma Inline (Has_Out_Or_In_Out_Parameter);\n@@ -8120,7 +8166,7 @@ package Einfo is\n    pragma Inline (Has_Thunks);\n    pragma Inline (Has_Unchecked_Union);\n    pragma Inline (Has_Unknown_Discriminants);\n-   pragma Inline (Has_Up_Level_Access);\n+   pragma Inline (Has_Uplevel_Reference);\n    pragma Inline (Has_Visible_Refinement);\n    pragma Inline (Has_Volatile_Components);\n    pragma Inline (Has_Xref_Entry);\n@@ -8266,6 +8312,7 @@ package Einfo is\n    pragma Inline (Is_Scalar_Type);\n    pragma Inline (Is_Shared_Passive);\n    pragma Inline (Is_Signed_Integer_Type);\n+   pragma Inline (Is_Static_Type);\n    pragma Inline (Is_Statically_Allocated);\n    pragma Inline (Is_Subprogram);\n    pragma Inline (Is_Tag);\n@@ -8407,6 +8454,8 @@ package Einfo is\n    pragma Inline (Underlying_Record_View);\n    pragma Inline (Universal_Aliasing);\n    pragma Inline (Unset_Reference);\n+   pragma Inline (Uplevel_Reference_Noted);\n+   pragma Inline (Uplevel_References);\n    pragma Inline (Used_As_Generic_Actual);\n    pragma Inline (Uses_Lock_Free);\n    pragma Inline (Uses_Sec_Stack);\n@@ -8566,6 +8615,7 @@ package Einfo is\n    pragma Inline (Set_Has_Master_Entity);\n    pragma Inline (Set_Has_Missing_Return);\n    pragma Inline (Set_Has_Nested_Block_With_Handler);\n+   pragma Inline (Set_Has_Nested_Subprogram);\n    pragma Inline (Set_Has_Non_Standard_Rep);\n    pragma Inline (Set_Has_Object_Size_Clause);\n    pragma Inline (Set_Has_Out_Or_In_Out_Parameter);\n@@ -8610,7 +8660,7 @@ package Einfo is\n    pragma Inline (Set_Has_Thunks);\n    pragma Inline (Set_Has_Unchecked_Union);\n    pragma Inline (Set_Has_Unknown_Discriminants);\n-   pragma Inline (Set_Has_Up_Level_Access);\n+   pragma Inline (Set_Has_Uplevel_Reference);\n    pragma Inline (Set_Has_Visible_Refinement);\n    pragma Inline (Set_Has_Volatile_Components);\n    pragma Inline (Set_Has_Xref_Entry);\n@@ -8718,6 +8768,7 @@ package Einfo is\n    pragma Inline (Set_Is_Return_Object);\n    pragma Inline (Set_Is_Safe_To_Reevaluate);\n    pragma Inline (Set_Is_Shared_Passive);\n+   pragma Inline (Set_Is_Static_Type);\n    pragma Inline (Set_Is_Statically_Allocated);\n    pragma Inline (Set_Is_Tag);\n    pragma Inline (Set_Is_Tagged_Type);\n@@ -8853,6 +8904,8 @@ package Einfo is\n    pragma Inline (Set_Underlying_Full_View);\n    pragma Inline (Set_Underlying_Record_View);\n    pragma Inline (Set_Universal_Aliasing);\n+   pragma Inline (Set_Uplevel_Reference_Noted);\n+   pragma Inline (Set_Uplevel_References);\n    pragma Inline (Set_Unset_Reference);\n    pragma Inline (Set_Used_As_Generic_Actual);\n    pragma Inline (Set_Uses_Lock_Free);"}, {"sha": "4d332644b74a83dfcf556603c3aabe8a202431b8", "filename": "gcc/ada/elists.adb", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Felists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Felists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Felists.adb?ref=5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -288,6 +288,25 @@ package body Elists is\n       return Elmts.Last;\n    end Last_Elmt_Id;\n \n+   -----------------\n+   -- List_Length --\n+   -----------------\n+\n+   function List_Length (List : Elist_Id) return Nat is\n+      Elmt : Elmt_Id;\n+      N    : Nat;\n+   begin\n+      N := 0;\n+      Elmt := First_Elmt (List);\n+      loop\n+         if No (Elmt) then\n+            return N;\n+         else\n+            Next_Elmt (Elmt);\n+         end if;\n+      end loop;\n+   end List_Length;\n+\n    ----------\n    -- Lock --\n    ----------"}, {"sha": "3daefc07862315e6bb2db0079e841abcb048ff80", "filename": "gcc/ada/elists.ads", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Felists.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Felists.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Felists.ads?ref=5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -107,6 +107,9 @@ package Elists is\n    --  Obtains the last element of the given element list or, if the list has\n    --  no items, then No_Elmt is returned.\n \n+   function List_Length (List : Elist_Id) return Nat;\n+   --  Returns number of elements in given List\n+\n    function Next_Elmt (Elmt : Elmt_Id) return Elmt_Id;\n    pragma Inline (Next_Elmt);\n    --  This function returns the next element on an element list. The argument"}, {"sha": "370f3e20d44f60ff0e9bff439ea13248c3eccd62", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "patch": "@@ -42,6 +42,7 @@ with Exp_Intr; use Exp_Intr;\n with Exp_Pakd; use Exp_Pakd;\n with Exp_Prag; use Exp_Prag;\n with Exp_Tss;  use Exp_Tss;\n+with Exp_Unst; use Exp_Unst;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n with Inline;   use Inline;\n@@ -5339,6 +5340,16 @@ package body Exp_Ch6 is\n       --  Set to encode entity names in package body before gigi is called\n \n       Qualify_Entity_Names (N);\n+\n+      --  If we are unnesting procedures, and this is an outer level procedure\n+      --  with nested subprograms, do the unnesting operation now.\n+\n+      if Opt.Unnest_Subprogram_Mode\n+        and then Is_Library_Level_Entity (Spec_Id)\n+        and then Has_Nested_Subprogram (Spec_Id)\n+      then\n+         Unnest_Subprogram (Spec_Id, N);\n+      end if;\n    end Expand_N_Subprogram_Body;\n \n    -----------------------------------\n@@ -7716,14 +7727,9 @@ package body Exp_Ch6 is\n \n          if Present (Decls) then\n             Decl := First (Decls);\n-\n             while Present (Decl) loop\n-               if Comes_From_Source (Decl) then\n-                  exit;\n-               else\n-                  Insert_Node := Decl;\n-               end if;\n-\n+               exit when Comes_From_Source (Decl);\n+               Insert_Node := Decl;\n                Next (Decl);\n             end loop;\n          end if;"}, {"sha": "fd15cc18926542f60f48370c1da3c7411d6e1ac4", "filename": "gcc/ada/exp_unst.adb", "status": "added", "additions": 574, "deletions": 0, "changes": 574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "patch": "@@ -0,0 +1,574 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             E X P _ U N S T                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2015, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Atree;    use Atree;\n+with Einfo;    use Einfo;\n+with Elists;   use Elists;\n+with Namet;    use Namet;\n+with Nlists;   use Nlists;\n+with Nmake;    use Nmake;\n+with Rtsfind;  use Rtsfind;\n+with Sem_Aux;  use Sem_Aux;\n+with Sem_Util; use Sem_Util;\n+with Sinfo;    use Sinfo;\n+with Snames;   use Snames;\n+with Table;\n+with Tbuild;   use Tbuild;\n+\n+package body Exp_Unst is\n+\n+   -------------------------------------\n+   -- Check_Uplevel_Reference_To_Type --\n+   -------------------------------------\n+\n+   procedure Check_Uplevel_Reference_To_Type (Typ : Entity_Id) is\n+      function Check_Dynamic_Type (T : Entity_Id) return Boolean;\n+      --  This is an internal recursive routine that checks if T or any of\n+      --  its subsdidiary types are dynamic. If so, then the original Typ is\n+      --  marked as having an uplevel reference, as is the subsidiary type in\n+      --  question, and any referenced dynamic bounds are also marked as having\n+      --  an uplevel reference, and True is returned. If the type is a static\n+      --  type, then False is returned;\n+\n+      ------------------------\n+      -- Check_Dynamic_Type --\n+      ------------------------\n+\n+      function Check_Dynamic_Type (T : Entity_Id) return Boolean is\n+         DT : Boolean := False;\n+\n+      begin\n+         --  If it's a static type, nothing to do\n+\n+         if Is_Static_Type (T) then\n+            return False;\n+\n+         --  If the type is uplevel referenced, then it must be dynamic\n+\n+         elsif Has_Uplevel_Reference (T) then\n+            Set_Has_Uplevel_Reference (Typ);\n+            return True;\n+\n+         --  Otherwise we need to figure out what the story is with this type\n+\n+         else\n+            DT := False;\n+\n+         --  For a scalar type, check bounds\n+\n+            if Is_Scalar_Type (T) then\n+\n+               --  If both bounds static, then this is a static type\n+\n+               declare\n+                  LB : constant Node_Id := Type_Low_Bound (T);\n+                  UB : constant Node_Id := Type_High_Bound (T);\n+\n+               begin\n+                  if not Is_Static_Expression (LB) then\n+                     Set_Has_Uplevel_Reference (Entity (LB));\n+                     DT := True;\n+                  end if;\n+\n+                  if not Is_Static_Expression (UB) then\n+                     Set_Has_Uplevel_Reference (Entity (UB));\n+                     DT := True;\n+                  end if;\n+               end;\n+\n+            --  For record type, check all components\n+\n+            elsif Is_Record_Type (T) then\n+               declare\n+                  C : Entity_Id;\n+\n+               begin\n+                  C := First_Component_Or_Discriminant (T);\n+                  while Present (T) loop\n+                     if Check_Dynamic_Type (C) then\n+                        DT := True;\n+                     end if;\n+\n+                     Next_Component_Or_Discriminant (C);\n+                  end loop;\n+               end;\n+\n+            --  For array type, check index types and component type\n+\n+            elsif Is_Array_Type (T) then\n+               declare\n+                  IX : Node_Id;\n+\n+               begin\n+                  if Check_Dynamic_Type (Component_Type (T)) then\n+                     DT := True;\n+                  end if;\n+\n+                  IX := First_Index (T);\n+                  while Present (IX) loop\n+                     if Check_Dynamic_Type (Etype (IX)) then\n+                        DT := True;\n+                     end if;\n+\n+                     Next_Index (IX);\n+                  end loop;\n+               end;\n+\n+            --  For now, ignore other types\n+\n+            else\n+               return False;\n+            end if;\n+\n+            --  See if we marked that type as dynamic\n+\n+            if DT then\n+               Set_Has_Uplevel_Reference (T);\n+               Set_Has_Uplevel_Reference (Typ);\n+               return True;\n+\n+            --  If not mark it as static\n+\n+            else\n+               Set_Is_Static_Type (T);\n+               return False;\n+            end if;\n+         end if;\n+      end Check_Dynamic_Type;\n+\n+   --  Start of processing for Check_Uplevel_Reference_To_Type\n+\n+   begin\n+      --  Nothing to do if we know this is a static type\n+\n+      if Is_Static_Type (Typ) then\n+         return;\n+\n+      --  Nothing to do if already marked as uplevel referenced\n+\n+      elsif Has_Uplevel_Reference (Typ) then\n+         return;\n+\n+      --  Otherwise check if we have a dynamic type\n+\n+      else\n+         if Check_Dynamic_Type (Typ) then\n+            Set_Has_Uplevel_Reference (Typ);\n+         end if;\n+      end if;\n+\n+      null;\n+   end Check_Uplevel_Reference_To_Type;\n+\n+   ----------------------------\n+   -- Note_Uplevel_Reference --\n+   ----------------------------\n+\n+   procedure Note_Uplevel_Reference (N : Node_Id; Subp : Entity_Id) is\n+   begin\n+      --  Establish list if first call for Uplevel_References\n+\n+      if No (Uplevel_References (Subp)) then\n+         Set_Uplevel_References (Subp, New_Elmt_List);\n+      end if;\n+\n+      --  Add new element to Uplevel_References\n+\n+      Append_Elmt (N, Uplevel_References (Subp));\n+      Set_Has_Uplevel_Reference (Entity (N));\n+   end Note_Uplevel_Reference;\n+\n+   -----------------------\n+   -- Unnest_Subprogram --\n+   -----------------------\n+\n+   --  Tables used by Unnest_Subprogram\n+\n+   type Subp_Entry is record\n+      Ent : Entity_Id;\n+      --  Entity of the subprogram\n+\n+      Bod : Node_Id;\n+      --  Subprogram_Body node for this subprogram\n+\n+      Lev : Nat;\n+      --  Subprogram level (1 = outer subprogram (Subp argument), 2 = nested\n+      --  immediately within this outer subprogram etc.)\n+   end record;\n+\n+   package Subps is new Table.Table (\n+     Table_Component_Type => Subp_Entry,\n+     Table_Index_Type     => Nat,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 100,\n+     Table_Increment      => 200,\n+     Table_Name           => \"Subps\");\n+   --  Records the subprograms in the nest whose outer subprogram is Subp\n+\n+   type Call_Entry is record\n+      N   : Node_Id;\n+      --  The actual call\n+\n+      From : Entity_Id;\n+      --  Entity of the subprogram containing the call\n+\n+      To : Entity_Id;\n+      --  Entity of the subprogram called\n+   end record;\n+\n+   package Calls is new Table.Table (\n+     Table_Component_Type => Call_Entry,\n+     Table_Index_Type     => Nat,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 100,\n+     Table_Increment      => 200,\n+     Table_Name           => \"Calls\");\n+   --  Records each call within the outer subprogram and all nested subprograms\n+   --  that are to other subprograms nested within the outer subprogram. These\n+   --  are the calls that may need an additional parameter.\n+\n+   procedure Unnest_Subprogram (Subp : Entity_Id; Subp_Body : Node_Id) is\n+\n+      function Get_AREC_String (Lev : Pos) return String;\n+      --  Given a level value, 1, 2, ... returns the string AREC, AREC2, ...\n+\n+      function Get_Level (Sub : Entity_Id) return Nat;\n+      --  Sub is either Subp itself, or a subprogram nested within Subp. This\n+      --  function returns the level of nesting (Subp = 1, subprograms that\n+      --  are immediately nested within Subp = 2, etc).\n+\n+      ---------------------\n+      -- Get_AREC_String --\n+      ---------------------\n+\n+      function Get_AREC_String (Lev : Pos) return String is\n+      begin\n+         if Lev > 9 then\n+            return\n+              Get_AREC_String (Lev / 10) & Character'Val (Lev mod 10 + 48);\n+         else\n+            return\n+              \"AREC\" & Character'Val (Lev + 48);\n+         end if;\n+      end Get_AREC_String;\n+\n+      ---------------\n+      -- Get_Level --\n+      ---------------\n+\n+      function Get_Level (Sub : Entity_Id) return Nat is\n+         Lev : Nat;\n+         S   : Entity_Id;\n+      begin\n+         Lev := 1;\n+         S   := Sub;\n+         loop\n+            if S = Subp then\n+               return Lev;\n+            else\n+               S := Enclosing_Dynamic_Scope (S);\n+               Lev := Lev + 1;\n+            end if;\n+         end loop;\n+      end Get_Level;\n+\n+   --  Start of processing for Unnest_Subprogram\n+\n+   begin\n+      --  First step, we must mark all nested subprograms that require a static\n+      --  link (activation record) because either they contain explicit uplevel\n+      --  references (as indicated by Has_Uplevel_Reference being set at this\n+      --  point), or they make calls to other subprograms in the same nest that\n+      --  require a static link (in which case we set this flag).\n+\n+      --  This is a recursive definition, and to implement this, we have to\n+      --  build a call graph for the set of nested subprograms, and then go\n+      --  over this graph to implement recursively the invariant that if a\n+      --  subprogram has a call to a subprogram requiring a static link, then\n+      --  the calling subprogram requires a static link.\n+\n+      --  First step, populate the above tables\n+\n+      Subps.Init;\n+      Calls.Init;\n+\n+      Build_Tables : declare\n+         function Visit_Node (N : Node_Id) return Traverse_Result;\n+         --  Visit a single node in Subp\n+\n+         ----------------\n+         -- Visit_Node --\n+         ----------------\n+\n+         function Visit_Node (N : Node_Id) return Traverse_Result is\n+            Ent : Entity_Id;\n+\n+            function Find_Current_Subprogram return Entity_Id;\n+            --  Finds the current subprogram containing the call N\n+\n+            -----------------------------\n+            -- Find_Current_Subprogram --\n+            -----------------------------\n+\n+            function Find_Current_Subprogram return Entity_Id is\n+               Nod : Node_Id;\n+\n+            begin\n+               Nod := N;\n+               loop\n+                  Nod := Parent (Nod);\n+\n+                  if Nkind (Nod) = N_Subprogram_Body then\n+                     if Acts_As_Spec (Nod) then\n+                        return Defining_Unit_Name (Specification (Nod));\n+                     else\n+                        return Corresponding_Spec (Nod);\n+                     end if;\n+                  end if;\n+               end loop;\n+            end Find_Current_Subprogram;\n+\n+         --  Start of processing for Visit_Node\n+\n+         begin\n+            if Nkind_In (N, N_Procedure_Call_Statement, N_Function_Call) then\n+               Ent := Entity (Name (N));\n+\n+               if not Is_Library_Level_Entity (Ent) then\n+                  Calls.Append ((N, Find_Current_Subprogram, Ent));\n+               end if;\n+\n+            elsif Nkind (N) = N_Subprogram_Body and then Acts_As_Spec (N) then\n+               Ent := Defining_Unit_Name (Specification (N));\n+               Subps.Append\n+                 ((Ent => Ent,\n+                   Bod => N,\n+                   Lev => Get_Level (Ent)));\n+\n+            elsif Nkind (N) = N_Subprogram_Declaration then\n+               Ent := Defining_Unit_Name (Specification (N));\n+               Subps.Append\n+                 ((Ent => Ent,\n+                   Bod => Corresponding_Body (N),\n+                   Lev => Get_Level (Ent)));\n+            end if;\n+\n+            return OK;\n+         end Visit_Node;\n+\n+         -----------\n+         -- Visit --\n+         -----------\n+\n+         procedure Visit is new Traverse_Proc (Visit_Node);\n+         --  Used to traverse the body of Subp, populating the tables\n+\n+      begin\n+         Visit (Subp_Body);\n+      end Build_Tables;\n+\n+      --  Second step is to do the transitive closure, if any subprogram has\n+      --  a call to a subprogram for which Has_Uplevel_Reference is set, then\n+      --  we set Has_Uplevel_Reference for the calling routine.\n+\n+      Closure : declare\n+         Modified : Boolean;\n+\n+      begin\n+         --  We use a simple minded algorithm as follows (obviously this can\n+         --  be done more efficiently, using one of the standard algorithms\n+         --  for efficient transitive closure computation, but this is simple\n+         --  and most likely fast enough that its speed does not matter).\n+\n+         --  Repeatedly scan the list of calls. Any time we find a call from\n+         --  A to B, where A does not have Has_Uplevel_Reference, and B does\n+         --  have this flag set, then set the flag for A, and note that we\n+         --  have made a change by setting Modified True. We repeat this until\n+         --  we make a pass with no modifications.\n+\n+         Outer : loop\n+            Modified := False;\n+            Inner : for J in Calls.First .. Calls.Last loop\n+               if not Has_Uplevel_Reference (Calls.Table (J).From)\n+                 and then Has_Uplevel_Reference (Calls.Table (J).To)\n+               then\n+                  Set_Has_Uplevel_Reference (Calls.Table (J).From);\n+                  Modified := True;\n+               end if;\n+            end loop Inner;\n+\n+            exit Outer when not Modified;\n+         end loop Outer;\n+      end Closure;\n+\n+      --  Next step, process each subprogram in turn, inserting necessary\n+      --  declarations for ARECxx types and variables for any subprogram\n+      --  that has nested subprograms, and is uplevel referenced.\n+\n+      Arec_Decls : declare\n+         Addr : constant Entity_Id := RTE (RE_Address);\n+\n+      begin\n+         for J in Subps.First .. Subps.Last loop\n+            declare\n+               STJ : Subp_Entry renames Subps.Table (J);\n+\n+            begin\n+               --  We add AREC declarations for any subprogram that has at\n+               --  least one nested subprogram, and has uplevel references.\n+\n+               if Has_Nested_Subprogram (STJ.Ent)\n+                 and then Has_Uplevel_Reference (STJ.Ent)\n+               then\n+                  Add_AREC_Declarations : declare\n+                     Loc   : constant Source_Ptr := Sloc (STJ.Bod);\n+                     ARS   : constant String     := Get_AREC_String (STJ.Lev);\n+                     Urefs : constant Elist_Id   :=\n+                               Uplevel_References (STJ.Ent);\n+                     Elmt  : Elmt_Id;\n+                     Ent   : Entity_Id;\n+                     Clist : List_Id;\n+\n+                     Uplevel_Entities :\n+                       array (1 .. List_Length (Urefs)) of Entity_Id;\n+                     Num_Uplevel_Entities : Nat;\n+                     --  Uplevel_Entities (1 .. Num_Uplevel_Entities) contains\n+                     --  a list (with no duplicates) of the entities for this\n+                     --  subprogram that are referenced uplevel. The maximum\n+                     --  number of entries cannot exceed the total number of\n+                     --  uplevel references.\n+\n+                  begin\n+                     --  Populate the Uplevel_Entities array, using the flag\n+                     --  Uplevel_Reference_Noted to avoid duplicates.\n+\n+                     Num_Uplevel_Entities := 0;\n+                     Elmt := First_Elmt (Urefs);\n+                     while Present (Elmt) loop\n+                        Ent := Entity (Node (Elmt));\n+\n+                        if not Uplevel_Reference_Noted (Ent) then\n+                           Set_Uplevel_Reference_Noted (Ent, True);\n+                           Num_Uplevel_Entities := Num_Uplevel_Entities + 1;\n+                           Uplevel_Entities (Num_Uplevel_Entities) := Ent;\n+                        end if;\n+\n+                        Next_Elmt (Elmt);\n+                     end loop;\n+\n+                     --  Build list of component declarations for ARECnT\n+\n+                     Clist := Empty_List;\n+\n+                     --  If not top level, include ARECn : ARECnPT := ARECnP\n+\n+                     if STJ.Lev > 1 then\n+                        Append_To (Clist,\n+                          Make_Component_Declaration (Loc,\n+                            Defining_Identifier =>\n+                              Make_Defining_Identifier (Loc,\n+                                Chars => Name_Find_Str (ARS)),\n+                            Component_Definition =>\n+                              Make_Component_Definition (Loc,\n+                                Subtype_Indication =>\n+                                  Make_Identifier (Loc,\n+                                    Chars => Name_Find_Str (ARS & \"PT\"))),\n+                            Expression =>\n+                              Make_Identifier (Loc,\n+                                Chars => Name_Find_Str (ARS & \"P\"))));\n+                     end if;\n+\n+                     --  Add components for uplevel referenced entities\n+\n+                     for J in 1 .. Num_Uplevel_Entities loop\n+                        Append_To (Clist,\n+                          Make_Component_Declaration (Loc,\n+                            Defining_Identifier =>\n+                              Make_Defining_Identifier (Loc,\n+                                Chars => Chars (Uplevel_Entities (J))),\n+                            Component_Definition =>\n+                              Make_Component_Definition (Loc,\n+                                Subtype_Indication =>\n+                                  New_Occurrence_Of (Addr, Loc))));\n+                     end loop;\n+\n+                     --  Now we can insert the AREC declarations into the body\n+\n+                     Prepend_List_To (Declarations (STJ.Bod),\n+                       New_List (\n+\n+                         --  type ARECT is record .. end record;\n+\n+                         Make_Full_Type_Declaration (Loc,\n+                           Defining_Identifier =>\n+                             Make_Defining_Identifier (Loc,\n+                               Chars => Name_Find_Str (ARS & \"T\")),\n+                           Type_Definition     =>\n+                             Make_Record_Definition (Loc,\n+                               Component_List =>\n+                                 Make_Component_List (Loc,\n+                                   Component_Items => Clist))),\n+\n+                         --  type ARECPT is access all ARECT;\n+\n+                         Make_Full_Type_Declaration (Loc,\n+                           Defining_Identifier =>\n+                             Make_Defining_Identifier (Loc,\n+                               Chars => Name_Find_Str (ARS & \"PT\")),\n+                             Type_Definition   =>\n+                                Make_Access_To_Object_Definition (Loc,\n+                                  All_Present        => True,\n+                                  Subtype_Indication =>\n+                                    Make_Identifier (Loc,\n+                                      Chars => Name_Find_Str (ARS & \"T\")))),\n+\n+                        --  ARECP : constant ARECPT := AREC'Access;\n+\n+                        Make_Object_Declaration (Loc,\n+                          Defining_Identifier =>\n+                            Make_Defining_Identifier (Loc,\n+                              Chars => Name_Find_Str (ARS & \"P\")),\n+                          Constant_Present    => True,\n+                          Object_Definition   =>\n+                            Make_Identifier (Loc, Name_Find_Str (ARS & \"PT\")),\n+                          Expression          =>\n+                            Make_Attribute_Reference (Loc,\n+                              Prefix         =>\n+                                Make_Identifier (Loc, Name_Find_Str (ARS)),\n+                                  Attribute_Name => Name_Access))));\n+                  end Add_AREC_Declarations;\n+               end if;\n+            end;\n+         end loop;\n+      end Arec_Decls;\n+\n+      --  Next step, for each uplevel referenced entity, add assignment\n+      --  operations to set the corresponding AREC fields, and define\n+      --  the PTR types.\n+\n+      return;\n+   end Unnest_Subprogram;\n+\n+end Exp_Unst;"}, {"sha": "9e48a66d57f747c14e8d129d9015d9660053012a", "filename": "gcc/ada/exp_unst.ads", "status": "added", "additions": 561, "deletions": 0, "changes": 561, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fexp_unst.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fexp_unst.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.ads?ref=5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "patch": "@@ -0,0 +1,561 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             E X P _ U N S T                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2015, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Expand routines for unnesting subprograms\n+\n+with Types; use Types;\n+\n+package Exp_Unst is\n+\n+   --  -----------------\n+   --  -- The Problem --\n+   --  -----------------\n+\n+   --  Normally, nested subprograms in the source result in corresponding\n+   --  nested subprograms in the resulting tree. We then expect the back end\n+   --  to handle such nested subprograms, including all cases of uplevel\n+   --  references. For example, the GCC back end can do this relatively easily\n+   --  since GNU C (as an extension) allows nested functions with uplevel\n+   --  references, and implements an appropriate static chain approach to\n+   --  dealing with such uplevel references.\n+\n+   --  However, we also want to be able to interface with back ends that do\n+   --  not easily handle such uplevel references. One example is the back end\n+   --  that translates the tree into standard C source code. In the future,\n+   --  other back ends might need the same capability (e.g. a back end that\n+   --  generated LLVM intermediate code).\n+\n+   --  We could imagine simply handling such references in the appropriate\n+   --  back end. For example the back end that generates C could recognize\n+   --  nested subprograms and rig up some way of translating them, e.g. by\n+   --  making a static-link source level visible.\n+\n+   --  Rather than take that approach, we prefer to do a semantics-preserving\n+   --  transformation on the GNAT tree, that eliminates the problem before we\n+   --  hand the tree over to the back end. There are two reasons for preferring\n+   --  this approach:\n+\n+   --     First: the work needs only to be done once for all affected back ends\n+   --     and we can remain within the semantics of the tree. The front end is\n+   --     full of tree transformations, so we have all the infrastructure for\n+   --     doing transformations of this type.\n+\n+   --     Second: given that the transformation will be semantics-preserving,\n+   --     we can still used the standard GCC back end to build code from it.\n+   --     This means we can easily run our full test suite to verify that the\n+   --     transformations are indeed semantics preserving. It is a lot more\n+   --     work to thoroughly test the output of specialized back ends.\n+\n+   --  Looking at the problem, we have three situations to deal with. Note\n+   --  that in these examples, we use all lower case, since that is the way\n+   --  the internal tree is cased.\n+\n+   --     First, cases where there are no uplevel references, for example\n+\n+   --       procedure case1 is\n+   --          function max (m, n : Integer) return integer is\n+   --          begin\n+   --             return integer'max (m, n);\n+   --          end max;\n+   --          ...\n+   --       end case1;\n+\n+   --     Second, cases where there are explicit uplevel references.\n+\n+   --       procedure case2 (b : integer) is\n+   --          procedure Inner (bb : integer);\n+   --\n+   --          procedure inner2 is\n+   --          begin\n+   --            inner(5);\n+   --          end;\n+   --\n+   --          x  : integer := 77;\n+   --          y  : constant integer := 15 * 16;\n+   --          rv : integer := 10;\n+   --\n+   --          procedure inner (bb : integer) is\n+   --          begin\n+   --             x := rv + y + bb + b;\n+   --          end;\n+   --\n+   --       begin\n+   --          inner2;\n+   --       end case2;\n+\n+   --     In this second example, B, X, RV are uplevel referenced. Y is not\n+   --     considered as an uplevel reference since it is a static constant\n+   --     where references are replaced by the value at compile time.\n+\n+   --   Third, cases where there are implicit uplevel references via types\n+   --   whose bounds depend on locally declared constants or variables:\n+\n+   --       function case3 (x, y : integer) return boolean is\n+   --          subtype dynam is integer range x .. y + 3;\n+   --          subtype static is integer range 42 .. 73;\n+   --          xx : dynam := y;\n+   --\n+   --          type darr is array (dynam) of Integer;\n+   --          type darec is record\n+   --             A : darr;\n+   --             B : integer;\n+   --          end record;\n+   --          darecv : darec;\n+   --\n+   --          function inner (b : integer) return boolean is\n+   --          begin\n+   --            return b in dynam and then darecv.b in static;\n+   --          end inner;\n+   --\n+   --       begin\n+   --         return inner (42) and then inner (xx * 3 - y * 2);\n+   --       end case3;\n+   --\n+   --     In this third example, the membership test implicitly references the\n+   --     the bounds of Dynam, which both involve uplevel references.\n+\n+   --  ------------------\n+   --  -- The Solution --\n+   --  ------------------\n+\n+   --  Looking at the three cases above, the first case poses no problem at\n+   --  all. Indeed the subprogram could have been declared at the outer level\n+   --  (perhaps changing the name). But this style is quite common as a way\n+   --  of limiting the scope of a local procedure called only within the outer\n+   --  procedure. We could move it to the outer level (with a name change if\n+   --  needed), but we don't bother. We leave it nested, and the back end just\n+   --  translates it as though it were not nested.\n+\n+   --  In general we leave nested procedures nested, rather than trying to move\n+   --  them to the outer level (the back end may do that, e.g. as part of the\n+   --  translation to C, but we don't do it in the tree itself). This saves a\n+   --  LOT of trouble in terms of visibility and semantics.\n+\n+   --  But of course we have to deal with the uplevel references. The idea is\n+   --  to rewrite these nested subprograms so that they no longer have any such\n+   --  uplevel references, so by the time they reach the back end, they all are\n+   --  case 1 (no uplevel references) and thus easily handled.\n+\n+   --  To deal with explicit uplevel references (case 2 above), we proceed with\n+   --  the following steps:\n+\n+   --    All entities marked as being uplevel referenced are marked as aliased\n+   --    since they will be accessed indirectly via an activation record as\n+   --    described below.\n+\n+   --    For each such entity xxx we create an access type xxxPTR (forced to\n+   --    single length in the unconstrained case).\n+\n+   --    An activation record is created containing system address values\n+   --    for each uplevel referenced entity in a given scope. In the example\n+   --    given before, we would have:\n+\n+   --      type AREC1T is record\n+   --         b  : Address;\n+   --         x  : Address;\n+   --         rv : Address;\n+   --      end record;\n+   --      type AREC1P is access all AREC1T;\n+   --      AREC1 : AREC1T;\n+\n+   --   The fields of AREC1 are set at the point the corresponding entity\n+   --   is declared (immediately for parameters).\n+\n+   --   Note: the 1 in all these names represents the fact that we are at the\n+   --   outer level of nesting. As we will see later, deeper levels of nesting\n+   --   will use AREC2, AREC3, ...\n+\n+   --   For all subprograms nested immediately within the corresponding scope,\n+   --   a parameter AREC1P is passed, and all calls to these routines have\n+   --   AREC1 added as an additional formal.\n+\n+   --   Now within the nested procedures, any reference to an uplevel entity\n+   --   xxx is replaced by Tnn!(AREC1.xxx).all (where ! represents a call\n+   --   to unchecked conversion to convert the address to the access type\n+   --   and Tnn is a locally declared type that is \"access all t\", where t\n+   --   is the type of the reference.\n+\n+   --   Note: the reason that we use Address as the component type in the\n+   --   declaration of AREC1T is that we may create this type before we see\n+   --   the declaration of this type.\n+\n+   --   The following shows example 2 above after this translation:\n+\n+   --       procedure case2x (b : aliased Integer) is\n+   --          type AREC1T is record\n+   --             b  : Address;\n+   --             x  : Address;\n+   --             rv : Address;\n+   --          end record;\n+   --\n+   --          AREC1 : aliased AREC1T;\n+   --          type AREC1PT is access all AREC1T;\n+   --          AREC1P : constant AREC1PT := AREC1'Access;\n+   --\n+   --          AREC1.b := b'Address;\n+   --\n+   --          procedure inner (bb : integer; AREC1P : AREC1PT);\n+   --\n+   --          procedure inner2 (AREC1P : AREC1PT) is\n+   --          begin\n+   --            inner(5, AREC1P);\n+   --          end;\n+   --\n+   --          x  : aliased integer := 77;\n+   --          AREC1.x := X'Address;\n+   --\n+   --          y  : constant Integer := 15 * 16;\n+   --\n+   --          rv : aliased Integer;\n+   --          AREC1.rv := rv'Address;\n+   --\n+   --          procedure inner (bb : integer; AREC1P : AREC1PT) is\n+   --          begin\n+   --             type Tnn1 is access all Integer;\n+   --             type Tnn2 is access all Integer;\n+   --             type Tnn3 is access all Integer;\n+   --             Tnn1!(AREC1P.x).all :=\n+   --               Tnn2!(AREC1P.rv).all + y + b + Tnn3!(AREC1P.b).all;\n+   --          end;\n+   --\n+   --       begin\n+   --          inner2 (AREC1P);\n+   --       end case2x;\n+\n+   --  And now the inner procedures INNER2 and INNER have no uplevel references\n+   --  so they have been reduced to case 1, which is the case easily handled by\n+   --  the back end. Note that the generated code is not strictly legal Ada\n+   --  because of the assignments to AREC1 in the declarative sequence, but the\n+   --  GNAT tree always allows such mixing of declarations and statements, so\n+   --  the back end must be prepared to handle this in any case.\n+\n+   --  Case 3 where we have uplevel references to types is a bit more complex.\n+   --  That would especially be the case if we did a full transformation that\n+   --  completely eliminated such uplevel references as we did for case 2. But\n+   --  instead of trying to do that, we rewrite the subprogram so that the code\n+   --  generator can easily detect and deal with these uplevel type references.\n+\n+   --  First we distinguish two cases\n+\n+   --    Static types are one of the two following cases:\n+\n+   --      Discrete types whose bounds are known at compile time. This is not\n+   --      quite the same as what is tested by Is_OK_Static_Subtype, in that\n+   --      it allows compile time known values that are not static expressions.\n+\n+   --      Composite types, whose components are (recursively) static types.\n+\n+   --    Dynamic types are one of the two following cases:\n+\n+   --      Discrete types with at least one bound not known at compile time.\n+\n+   --      Composite types with at least one component that is (recursively)\n+   --      a dynamic type.\n+\n+   --    Uplevel references to static types are not a problem, the front end\n+   --    or the code generator fetches the bounds as required, and since they\n+   --    are compile time known values, this value can just be extracted and\n+   --    no actual uplevel reference is required.\n+\n+   --    Uplevel references to dynamic types are a potential problem, since\n+   --    such references may involve an implicit access to a dynamic bound,\n+   --    and this reference is an implicit uplevel access.\n+\n+   --    To fully unnest such references would be messy, since we would have\n+   --    to create local copies of the dynamic types involved, so that the\n+   --    front end or code generator could generate an explicit uplevel\n+   --    reference to the bound involved. Rather than do that, we set things\n+   --    up so that this situation can be easily detected and dealt with when\n+   --    there is an implicit reference to the bounds.\n+\n+   --    What we do is to always generate a local constant for any dynamic\n+   --    bound in a dynamic subtype xx with name xx_FIRST or xx_LAST. The one\n+   --    case where we can skip this is where the bound is For\n+   --    example in the third example above, subtype dynam is expanded as\n+\n+   --      dynam_LAST  : constant Integer := y + 3;\n+   --      subtype dynam is integer range x .. dynam_LAST;\n+\n+   --    Now if type dynam is uplevel referenced (as it is this case), then\n+   --    the bounds x and dynam_LAST are marked as uplevel references\n+   --    so that appropriate entries are made in the activation record. Any\n+   --    explicit reference to such a bound in the front end generated code\n+   --    will be handled by the normal uplevel reference mechanism which we\n+   --    described above for case 2. For implicit references by a back end\n+   --    that needs to unnest things, any such implicit reference to one of\n+   --    these bounds can be replaced by an appropriate reference to the entry\n+   --    in the activation record for xx_FIRST or xx_LAST. Thus the back end\n+   --    can eliminate the problematical uplevel reference without the need to\n+   --    do the heavy tree modification to do that at the code expansion level\n+\n+   --  Looking at case 3 again, here is the normal -gnatG expanded code\n+\n+     --  function case3 (x : integer; y : integer) return boolean is\n+     --     dynam_LAST : constant integer := y {+} 3;\n+     --     subtype dynam is integer range x .. dynam_LAST;\n+     --     subtype static is integer range 42 .. 73;\n+     --\n+     --     [constraint_error when\n+     --       not (y in x .. dynam_LAST)\n+     --       \"range check failed\"]\n+     --\n+     --     xx : dynam := y;\n+     --\n+     --     type darr is array (x .. dynam_LAST) of integer;\n+     --     type darec is record\n+     --        a : darr;\n+     --        b : integer;\n+     --     end record;\n+     --     [type TdarrB is array (x .. dynam_LAST range <>) of integer]\n+     --     freeze TdarrB []\n+     --     darecv : darec;\n+     --\n+     --     function inner (b : integer) return boolean is\n+     --     begin\n+     --        return b in x .. dynam_LAST and then darecv.b in 42 .. 73;\n+     --     end inner;\n+     --  begin\n+     --     return inner (42) and then inner (xx {*} 3 {-} y {*} 2);\n+     --  end case3;\n+\n+   --  Note: the actual expanded code has fully qualified names so for\n+   --  example function inner is actually function case3__inner. For now\n+   --  we ignore that detail to clarify the examples.\n+\n+   --  Here we see that some of the bounds references are expanded by the\n+   --  front end, so that we get explicit references to y or dynamLast. These\n+   --  cases are handled by the normal uplevel reference mechanism described\n+   --  above for case 2. This is the case for the constraint check for the\n+   --  initialization of xx, and the range check in function inner.\n+\n+   --  But the reference darecv.b in the return statement of function\n+   --  inner has an implicit reference to the bounds of dynam, since to\n+   --  compute the location of b in the record, we need the length of a.\n+\n+   --  Here is the full translation of the third example:\n+\n+   --       function case3x (x, y : integer) return boolean is\n+   --          type AREC1T is record\n+   --             x          : Address;\n+   --             dynam_LAST : Address;\n+   --          end record;\n+   --\n+   --          AREC1 : aliased AREC1T;\n+   --          type AREC1PT is access all AREC1T;\n+   --          AREC1P : constant AREC1PT := AREC1'Access;\n+   --\n+   --          AREC1.x := x'Address;\n+   --\n+   --          dynam_LAST : constant integer := y {+} 3;\n+   --          AREC1.dynam_LAST := dynam_LAST'Address;\n+   --          subtype dynam is integer range x .. dynam_LAST;\n+   --          xx : dynam := y;\n+   --\n+   --          [constraint_error when\n+   --            not (y in x .. dynam_LAST)\n+   --            \"range check failed\"]\n+   --\n+   --          subtype static is integer range 42 .. 73;\n+   --\n+   --          type darr is array (x .. dynam_LAST) of Integer;\n+   --          type darec is record\n+   --             A : darr;\n+   --             B : integer;\n+   --          end record;\n+   --          darecv : darec;\n+   --\n+   --          function inner (b : integer; AREC1P : AREC1PT) return boolean is\n+   --          begin\n+   --             type Tnn is access all Integer\n+   --             return b in x .. Tnn!(AREC1P.dynam_LAST).all\n+   --               and then darecv.b in 42 .. 73;\n+   --          end inner;\n+   --\n+   --       begin\n+   --         return inner (42, AREC1P) and then inner (xx * 3, AREC1P);\n+   --       end case3x;\n+\n+   --  And now the back end when it processes darecv.b will access the bounds\n+   --  of darecv.a by referencing the d and dynam_LAST fields of AREC1P.\n+\n+   -----------------------------\n+   -- Multiple Nesting Levels --\n+   -----------------------------\n+\n+   --  In our examples so far, we have only nested to a single level, but the\n+   --  scheme generalizes to multiple levels of nesting and in this section we\n+   --  discuss how this generalization works.\n+\n+   --  Consider this example with two nesting levels\n+\n+   --  To deal with elimination of uplevel references, we follow the same basic\n+   --  approach described above for case 2, except that we need an activation\n+   --  record at each nested level. Basically the rule is that any procedure\n+   --  that has nested procedures needs an activation record. When we do this,\n+   --  the inner activation records have a pointer to the immediately enclosing\n+   --  activation record, the normal arrangement of static links. The following\n+   --  shows the full translation of this fourth case.\n+\n+   --     function case4x (x : integer) return integer is\n+   --        type AREC1T is record\n+   --           v1 : Address;\n+   --        end record;\n+   --\n+   --        AREC1 : aliased AREC1T;\n+   --        type AREC1PT is access all AREC1T;\n+   --        AREC1P : constant AREC1PT := AREC1'Access;\n+   --\n+   --        v1 : integer := x;\n+   --        AREC1.v1 := v1'Address;\n+   --\n+   --        function inner1 (y : integer; AREC1P : ARECPT) return integer is\n+   --           type AREC2T is record\n+   --              AREC1 : AREC1PT := AREC1P;\n+   --              v2    : Address;\n+   --           end record;\n+   --\n+   --           AREC2 : aliased AREC2T;\n+   --           type AREC2PT is access all AREC2T;\n+   --           AREC2P : constant AREC2PT := AREC2'Access;\n+   --\n+   --           type Tnn1 is access all Integer;\n+   --           v2 : integer := Tnn1!(AREC1P.v1).all {+} 1;\n+   --           AREC2.v2 := v2'Address;\n+   --\n+   --           function inner2\n+   --              (z : integer; AREC2P : AREC2PT) return integer\n+   --           is\n+   --           begin\n+   --              type Tnn1 is access all Integer;\n+   --              type Tnn2 is access all Integer;\n+   --              return integer(z {+}\n+   --                             Tnn1!(AREC2P.AREC1.v1).all {+}\n+   --                             Tnn2!(AREC2P.v2).all);\n+   --           end inner2;\n+   --        begin\n+   --           type Tnn is access all Integer;\n+   --           return integer(y {+} inner2 (Tnn!(AREC1P.v1).all, AREC2P));\n+   --        end inner1;\n+   --     begin\n+   --        return inner1 (x, AREC1P);\n+   --     end case4x;\n+\n+   --  As can be seen in this example, the level number following AREC in the\n+   --  names avoids any confusion between AREC names at different levels.\n+\n+   -------------------------\n+   -- Name Disambiguation --\n+   -------------------------\n+\n+   --  As described above, the translation scheme would raise issues when the\n+   --  code generator did the actual unnesting if identically named nested\n+   --  subprograms exist. Similarly overloading would cause a naming issue.\n+\n+   --  In fact, the expanded code includes qualified names which eliminate this\n+   --  problem. We omitted the qualification from the exapnded examples above\n+   --  for simplicity. But to see this in action, consider this example:\n+\n+   --    function Mnames return Boolean is\n+   --       procedure Inner is\n+   --          procedure Inner is\n+   --          begin\n+   --             null;\n+   --          end;\n+   --       begin\n+   --          Inner;\n+   --       end;\n+   --       function F (A : Boolean) return Boolean is\n+   --       begin\n+   --          return not A;\n+   --       end;\n+   --       function F (A : Integer) return Boolean is\n+   --       begin\n+   --          return A > 42;\n+   --       end;\n+   --    begin\n+   --       Inner;\n+   --       return F (42) or F (True);\n+   --    end;\n+\n+   --  The expanded code actually looks like:\n+\n+   --    function mnames return boolean is\n+   --       procedure mnames__inner is\n+   --          procedure mnames__inner__inner is\n+   --          begin\n+   --             null;\n+   --             return;\n+   --          end mnames__inner__inner;\n+   --       begin\n+   --          mnames__inner__inner;\n+   --          return;\n+   --       end mnames__inner;\n+   --       function mnames__f (a : boolean) return boolean is\n+   --       begin\n+   --          return not a;\n+   --       end mnames__f;\n+   --       function mnames__f__2 (a : integer) return boolean is\n+   --       begin\n+   --          return a > 42;\n+   --       end mnames__f__2;\n+   --    begin\n+   --       mnames__inner;\n+   --       return mnames__f__2 (42) or mnames__f (true);\n+   --    end mnames;\n+\n+   --  As can be seen from studying this example, the qualification deals both\n+   --  with the issue of clashing names (mnames__inner, mnames__inner__inner),\n+   --  and with overloading (mnames__f, mnames__f__2).\n+\n+   -----------------\n+   -- Subprograms --\n+   -----------------\n+\n+   procedure Check_Uplevel_Reference_To_Type (Typ : Entity_Id);\n+   --  This procedure is called if Sem_Util.Check_Nested_Access detects an\n+   --  uplevel reference to a type or subtype entity Typ. On return there are\n+   --  two cases, if Typ is a static type (defined as a discrete type with\n+   --  static bounds, or a record all of whose components are of a static type,\n+   --  or an array whose index and component types are all static types), then\n+   --  the flag Is_Static_Type (Typ) will be set True, and in this case the\n+   --  flag Has_Uplevel_Reference is not set since we don't need to worry about\n+   --  uplevel references to static types. If on the other hand Typ is not a\n+   --  static type, then the flag Has_Uplevel_Reference will be set, and any\n+   --  non-static bounds referenced by the type will also be marked as having\n+   --  uplevel references (by setting Has_Uplevel_Reference for these bounds).\n+\n+   procedure Note_Uplevel_Reference (N : Node_Id; Subp : Entity_Id);\n+   --  Called in Unnest_Subprogram_Mode when we detect an explicit uplevel\n+   --  reference (node N) to an enclosing subprogram Subp.\n+\n+   procedure Unnest_Subprogram (Subp : Entity_Id; Subp_Body : Node_Id);\n+   --  Subp is a library level subprogram which has nested subprograms, and\n+   --  Subp_Body is the corresponding N_Subprogram_Body node. This procedure\n+   --  declares the AREC types and objects, adds assignments to the AREC record\n+   --  as required, defines the xxxPTR types for uplevel referenced objects,\n+   --  adds the ARECP parameter to all nested subprograms which need it, and\n+   --  modifies all uplevel references appropriately.\n+\n+end Exp_Unst;"}, {"sha": "80d0a4e7b1fe7dc763c8d1598595784a33d37cc8", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "patch": "@@ -282,6 +282,7 @@ GNAT_ADA_OBJS =\t\\\n  ada/exp_smem.o\t\\\n  ada/exp_strm.o\t\\\n  ada/exp_tss.o\t\\\n+ ada/exp_unst.o \\\n  ada/exp_util.o\t\\\n  ada/expander.o\t\\\n  ada/fmap.o\t\\"}, {"sha": "83979d7d058684949a4a15449ff58d9d9b7f8973", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "patch": "@@ -130,6 +130,12 @@ procedure Gnat1drv is\n          Relaxed_RM_Semantics := True;\n       end if;\n \n+      --  -gnatd.1 enables unnesting of subprograms\n+\n+      if Debug_Flag_Dot_1 then\n+         Unnest_Subprogram_Mode := True;\n+      end if;\n+\n       --  -gnatd.V or -gnatd.u enables special C expansion mode\n \n       if Debug_Flag_Dot_VV or Debug_Flag_Dot_U then"}, {"sha": "6def9f273b7f9a0bece545975e6817cc1a5a6032", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "patch": "@@ -1104,6 +1104,17 @@ package body Namet is\n       end if;\n    end Name_Find;\n \n+   -------------------\n+   -- Name_Find_Str --\n+   -------------------\n+\n+   function Name_Find_Str (S : String) return Name_Id is\n+   begin\n+      Name_Len := S'Length;\n+      Name_Buffer (1 .. Name_Len) := S;\n+      return Name_Find;\n+   end Name_Find_Str;\n+\n    -------------\n    -- Nam_In --\n    -------------"}, {"sha": "2e2e95daa956f1ff5d281b2eeba0b60a644ecf83", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -422,6 +422,11 @@ package Namet is\n    --  not modified by this call. Note that it is permissible for Name_Len to\n    --  be set to zero to lookup the null name string.\n \n+   function Name_Find_Str (S : String) return Name_Id;\n+   --  Similar to Name_Find, except that the string is provided as an argument.\n+   --  This call destroys the contents of Name_Buffer and Name_Len (by storing\n+   --  the given string there.\n+\n    function Name_Enter return Name_Id;\n    --  Name_Enter has the same calling interface as Name_Find. The difference\n    --  is that it does not search the table for an existing match, and also"}, {"sha": "7fd019a86f8f5c674b49055fad7d7452cfb7d308", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "patch": "@@ -1533,6 +1533,10 @@ package Opt is\n    --  Indicates if error messages are to be prefixed by the string error:\n    --  Initialized from Tag_Errors, can be forced on with the -gnatU switch.\n \n+   Unnest_Subprogram_Mode : Boolean := False;\n+   --  If true, activates the circuitry for unnesting subprograms (see the spec\n+   --  of Exp_Unst for full details). Currently set only by use of -gnatd.1.\n+\n    Universal_Addressing_On_AAMP : Boolean := False;\n    --  GNAAMP\n    --  Indicates if library-level objects should be accessed and updated using"}, {"sha": "0be121775134b5d475fda30b36601327a82215e2", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "patch": "@@ -1514,14 +1514,34 @@ package body Ch3 is\n             return;\n \n          --  Otherwise we definitely have an ordinary identifier with a junk\n-         --  token after it. Just complain that we expect a declaration, and\n-         --  skip to a semicolon\n+         --  token after it.\n \n          else\n-            Set_Declaration_Expected;\n-            Resync_Past_Semicolon;\n-            Done := False;\n-            return;\n+            --  If in -gnatd.2 mode, try for statements\n+\n+            if Debug_Flag_Dot_2 then\n+               Restore_Scan_State (Scan_State);\n+\n+               --  Reset Token_Node, because it already got changed from an\n+               --  Identifier to a Defining_Identifier, and we don't want that\n+               --  for a statement!\n+\n+               Token_Node :=\n+                 Make_Identifier (Sloc (Token_Node), Chars (Token_Node));\n+\n+               --  And now scan out one or more statements\n+\n+               Statement_When_Declaration_Expected (Decls, Done, In_Spec);\n+               return;\n+\n+            --  Normal case, just complain and skip to semicolon\n+\n+            else\n+               Set_Declaration_Expected;\n+               Resync_Past_Semicolon;\n+               Done := False;\n+               return;\n+            end if;\n          end if;\n       end if;\n "}, {"sha": "dccecc34be09920363bac79bc154691a5d0d0dcb", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "patch": "@@ -3223,8 +3223,7 @@ package body Sem_Ch6 is\n                --  We make two copies of the given spec, one for the new\n                --  declaration, and one for the body.\n \n-               if No (Spec_Id)\n-                 and then GNATprove_Mode\n+               if No (Spec_Id) and then GNATprove_Mode\n \n                  --  Inlining does not apply during pre-analysis of code\n \n@@ -4157,6 +4156,28 @@ package body Sem_Ch6 is\n \n          Check_References (Body_Id);\n       end;\n+\n+      --  Check for nested subprogram, and mark outer level subprogram if so\n+\n+      declare\n+         Ent : Entity_Id;\n+\n+      begin\n+         if Present (Spec_Id) then\n+            Ent := Spec_Id;\n+         else\n+            Ent := Body_Id;\n+         end if;\n+\n+         loop\n+            Ent := Enclosing_Subprogram (Ent);\n+            exit when No (Ent) or else Is_Subprogram (Ent);\n+         end loop;\n+\n+         if Present (Ent) then\n+            Set_Has_Nested_Subprogram (Ent);\n+         end if;\n+      end;\n    end Analyze_Subprogram_Body_Helper;\n \n    ---------------------------------"}, {"sha": "5695033171d77632ce8be0dcdc71ca62995a4d6f", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "patch": "@@ -5623,7 +5623,7 @@ package body Sem_Ch8 is\n                   end if;\n                end if;\n \n-               Check_Nested_Access (E);\n+               Check_Nested_Access (N, E);\n             end if;\n \n             Set_Entity_Or_Discriminal (N, E);\n@@ -6593,6 +6593,8 @@ package body Sem_Ch8 is\n                  and then (not Is_Entity_Name (P)\n                             or else Chars (Entity (P)) /= Name_uInit)\n                then\n+                  --  Check if we already have an available subtype we can use\n+\n                   if Ekind (Etype (P)) = E_Record_Subtype\n                     and then Nkind (Parent (Etype (P))) = N_Subtype_Declaration\n                     and then Is_Array_Type (Etype (Selector))"}, {"sha": "ee5db0017610cbe5048d39ae253ae3d5522e3153", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 34, "deletions": 8, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "patch": "@@ -32,6 +32,7 @@ with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Ch11; use Exp_Ch11;\n with Exp_Disp; use Exp_Disp;\n+with Exp_Unst; use Exp_Unst;\n with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n with Freeze;   use Freeze;\n@@ -2863,23 +2864,37 @@ package body Sem_Util is\n    -- Check_Nested_Access --\n    -------------------------\n \n-   procedure Check_Nested_Access (Ent : Entity_Id) is\n+   procedure Check_Nested_Access (N : Node_Id; Ent : Entity_Id) is\n       Scop         : constant Entity_Id := Current_Scope;\n       Current_Subp : Entity_Id;\n       Enclosing    : Entity_Id;\n \n    begin\n       --  Currently only enabled for VM back-ends for efficiency, should we\n-      --  enable it more systematically ???\n+      --  enable it more systematically? Probably not unless someone actually\n+      --  needs it. It will be needed for C generation and is activated if the\n+      --  Opt.Unnest_Subprogram_Mode flag is set True.\n \n-      --  Check for Is_Imported needs commenting below ???\n-\n-      if VM_Target /= No_VM\n-        and then Ekind_In (Ent, E_Variable, E_Constant, E_Loop_Parameter)\n+      if (VM_Target /= No_VM or else Unnest_Subprogram_Mode)\n         and then Scope (Ent) /= Empty\n         and then not Is_Library_Level_Entity (Ent)\n+\n+        --  Comment the exclusion of imported entities ???\n+\n         and then not Is_Imported (Ent)\n       then\n+         --  For VM case, we are only interested in variables, constants,\n+         --  and loop parameters. For general nested procedure usage, we\n+         --  allow types as well.\n+\n+         if Ekind_In (Ent, E_Variable, E_Constant, E_Loop_Parameter) then\n+            null;\n+         elsif not (Unnest_Subprogram_Mode and then Is_Type (Ent)) then\n+            return;\n+         end if;\n+\n+         --  Get current subprogram that is relevant\n+\n          if Is_Subprogram (Scop)\n            or else Is_Generic_Subprogram (Scop)\n            or else Is_Entry (Scop)\n@@ -2891,8 +2906,19 @@ package body Sem_Util is\n \n          Enclosing := Enclosing_Subprogram (Ent);\n \n+         --  Set flag if uplevel reference\n+\n          if Enclosing /= Empty and then Enclosing /= Current_Subp then\n-            Set_Has_Up_Level_Access (Ent, True);\n+            if Is_Type (Ent) then\n+               Check_Uplevel_Reference_To_Type (Ent);\n+            else\n+               Set_Has_Uplevel_Reference (Ent, True);\n+\n+               if Unnest_Subprogram_Mode then\n+                  Set_Has_Uplevel_Reference (Current_Subp, True);\n+                  Note_Uplevel_Reference (N, Enclosing);\n+               end if;\n+            end if;\n          end if;\n       end if;\n    end Check_Nested_Access;\n@@ -15168,7 +15194,7 @@ package body Sem_Util is\n                   end if;\n                end if;\n \n-               Check_Nested_Access (Ent);\n+               Check_Nested_Access (N, Ent);\n             end if;\n \n             Kill_Checks (Ent);"}, {"sha": "ca31b297e0e00f06ee28088dbf403db415f18303", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=5a271a7f3a2983e1529ea5c7f98d6ea5d6b113cf", "patch": "@@ -308,10 +308,12 @@ package Sem_Util is\n    --  remains in the Examiner (JB01-005). Note that the Examiner does not\n    --  count package declarations in later declarative items.\n \n-   procedure Check_Nested_Access (Ent : Entity_Id);\n+   procedure Check_Nested_Access (N : Node_Id; Ent : Entity_Id);\n    --  Check whether Ent denotes an entity declared in an uplevel scope, which\n-   --  is accessed inside a nested procedure, and set Has_Up_Level_Access flag\n-   --  accordingly. This is currently only enabled for VM_Target /= No_VM.\n+   --  is accessed inside a nested procedure, and set the Has_Uplevel_Reference\n+   --  flag accordingly. This is currently only enabled for if on a VM target,\n+   --  or if Opt.Unnest_Subprogram_Mode is active. N is the node for the\n+   --  possible uplevel reference.\n \n    procedure Check_No_Hidden_State (Id : Entity_Id);\n    --  Determine whether object or state Id introduces a hidden state. If this"}]}