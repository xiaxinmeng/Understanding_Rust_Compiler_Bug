{"sha": "52af380439eab2770ad65af495e2c1a281e4b097", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJhZjM4MDQzOWVhYjI3NzBhZDY1YWY0OTVlMmMxYTI4MWU0YjA5Nw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2017-11-22T21:43:22Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2017-11-22T21:43:22Z"}, "message": "re PR rtl-optimization/83030 (ICE in create_pseudo_cfg, at dwarf2cfi.c:2840)\n\n\tPR rtl-optimization/83030\n\t* doc/rtl.texi (Flags in an RTL Expression): Alphabetize, add entry\n\tfor CROSSING_JUMP_P and mention usage of 'jump' for JUMP_INSNs.\n\t(Insns): Delete entry for REG_CROSSING_JUMP in register notes.\n\t* bb-reorder.c (update_crossing_jump_flags): Do not test whether the\n\tCROSSING_JUMP_P flag is already set before setting it.\n\t* cfgrtl.c (fixup_partition_crossing): Likewise.\n\t* reorg.c (relax_delay_slots): Do not consider a CROSSING_JUMP_P insn\n\tas useless.\n\nFrom-SVN: r255083", "tree": {"sha": "84f166c7af461ae05a057927e604c5da0e1e58bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84f166c7af461ae05a057927e604c5da0e1e58bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52af380439eab2770ad65af495e2c1a281e4b097", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52af380439eab2770ad65af495e2c1a281e4b097", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52af380439eab2770ad65af495e2c1a281e4b097", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52af380439eab2770ad65af495e2c1a281e4b097/comments", "author": null, "committer": null, "parents": [{"sha": "d54387158acafe1272e7877a16149ae53d3b5a3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d54387158acafe1272e7877a16149ae53d3b5a3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d54387158acafe1272e7877a16149ae53d3b5a3b"}], "stats": {"total": 157, "additions": 84, "deletions": 73}, "files": [{"sha": "ac96304935a13d21609c2496d694fdb4320fcd71", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52af380439eab2770ad65af495e2c1a281e4b097/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52af380439eab2770ad65af495e2c1a281e4b097/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52af380439eab2770ad65af495e2c1a281e4b097", "patch": "@@ -1,3 +1,15 @@\n+2017-11-22  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR rtl-optimization/83030\n+\t* doc/rtl.texi (Flags in an RTL Expression): Alphabetize, add entry\n+\tfor CROSSING_JUMP_P and mention usage of 'jump' for JUMP_INSNs.\n+\t(Insns): Delete entry for REG_CROSSING_JUMP in register notes.\n+\t* bb-reorder.c (update_crossing_jump_flags): Do not test whether the\n+\tCROSSING_JUMP_P flag is already set before setting it.\n+\t* cfgrtl.c (fixup_partition_crossing): Likewise.\n+\t* reorg.c (relax_delay_slots): Do not consider a CROSSING_JUMP_P\n+\tinsn as useless.\n+\n 2017-11-22  Jakub Jelinek  <jakub@redhat.com>\n \n \t* simplify-rtx.c (simplify_binary_operation_1) <case VEC_SERIES>:"}, {"sha": "794283cd7cf014fa1891d8e89b1d38035962b624", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52af380439eab2770ad65af495e2c1a281e4b097/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52af380439eab2770ad65af495e2c1a281e4b097/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=52af380439eab2770ad65af495e2c1a281e4b097", "patch": "@@ -2239,10 +2239,7 @@ update_crossing_jump_flags (void)\n     FOR_EACH_EDGE (e, ei, bb->succs)\n       if (e->flags & EDGE_CROSSING)\n \t{\n-\t  if (JUMP_P (BB_END (bb))\n-\t      /* Some flags were added during fix_up_fall_thru_edges, via\n-\t\t force_nonfallthru_and_redirect.  */\n-\t      && !CROSSING_JUMP_P (BB_END (bb)))\n+\t  if (JUMP_P (BB_END (bb)))\n \t    CROSSING_JUMP_P (BB_END (bb)) = 1;\n \t  break;\n \t}"}, {"sha": "a2ad075db85f63c0dfca71b4f42b7aaf88f6e2f2", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52af380439eab2770ad65af495e2c1a281e4b097/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52af380439eab2770ad65af495e2c1a281e4b097/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=52af380439eab2770ad65af495e2c1a281e4b097", "patch": "@@ -1333,8 +1333,7 @@ fixup_partition_crossing (edge e)\n   if (BB_PARTITION (e->src) != BB_PARTITION (e->dest))\n     {\n       e->flags |= EDGE_CROSSING;\n-      if (JUMP_P (BB_END (e->src))\n-\t  && !CROSSING_JUMP_P (BB_END (e->src)))\n+      if (JUMP_P (BB_END (e->src)))\n \tCROSSING_JUMP_P (BB_END (e->src)) = 1;\n     }\n   else if (BB_PARTITION (e->src) == BB_PARTITION (e->dest))"}, {"sha": "a58eedc4aa16907859ecb51a830b5303ceefc613", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 66, "deletions": 64, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52af380439eab2770ad65af495e2c1a281e4b097/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52af380439eab2770ad65af495e2c1a281e4b097/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=52af380439eab2770ad65af495e2c1a281e4b097", "patch": "@@ -565,6 +565,16 @@ that are used in certain types of expression.  Most often they\n are accessed with the following macros, which expand into lvalues.\n \n @table @code\n+@findex CROSSING_JUMP_P\n+@cindex @code{jump_insn} and @samp{/j}\n+@item CROSSING_JUMP_P (@var{x})\n+Nonzero in a @code{jump_insn} if it crosses between hot and cold sections,\n+which could potentially be very far apart in the executable.  The presence\n+of this flag indicates to other optimizations that this branching instruction\n+should not be ``collapsed'' into a simpler branching construct.  It is used\n+when the optimization to partition basic blocks into hot and cold sections\n+is turned on.\n+\n @findex CONSTANT_POOL_ADDRESS_P\n @cindex @code{symbol_ref} and @samp{/u}\n @cindex @code{unchanging}, in @code{symbol_ref}\n@@ -577,37 +587,6 @@ In either case GCC assumes these addresses can be addressed directly,\n perhaps with the help of base registers.\n Stored in the @code{unchanging} field and printed as @samp{/u}.\n \n-@findex RTL_CONST_CALL_P\n-@cindex @code{call_insn} and @samp{/u}\n-@cindex @code{unchanging}, in @code{call_insn}\n-@item RTL_CONST_CALL_P (@var{x})\n-In a @code{call_insn} indicates that the insn represents a call to a\n-const function.  Stored in the @code{unchanging} field and printed as\n-@samp{/u}.\n-\n-@findex RTL_PURE_CALL_P\n-@cindex @code{call_insn} and @samp{/i}\n-@cindex @code{return_val}, in @code{call_insn}\n-@item RTL_PURE_CALL_P (@var{x})\n-In a @code{call_insn} indicates that the insn represents a call to a\n-pure function.  Stored in the @code{return_val} field and printed as\n-@samp{/i}.\n-\n-@findex RTL_CONST_OR_PURE_CALL_P\n-@cindex @code{call_insn} and @samp{/u} or @samp{/i}\n-@item RTL_CONST_OR_PURE_CALL_P (@var{x})\n-In a @code{call_insn}, true if @code{RTL_CONST_CALL_P} or\n-@code{RTL_PURE_CALL_P} is true.\n-\n-@findex RTL_LOOPING_CONST_OR_PURE_CALL_P\n-@cindex @code{call_insn} and @samp{/c}\n-@cindex @code{call}, in @code{call_insn}\n-@item RTL_LOOPING_CONST_OR_PURE_CALL_P (@var{x})\n-In a @code{call_insn} indicates that the insn represents a possibly\n-infinite looping call to a const or pure function.  Stored in the\n-@code{call} field and printed as @samp{/c}.  Only true if one of\n-@code{RTL_CONST_CALL_P} or @code{RTL_PURE_CALL_P} is true.\n-\n @findex INSN_ANNULLED_BRANCH_P\n @cindex @code{jump_insn} and @samp{/u}\n @cindex @code{call_insn} and @samp{/u}\n@@ -702,6 +681,29 @@ Stored in the @code{call} field and printed as @samp{/c}.\n Nonzero in a @code{mem} if the memory reference holds a pointer.\n Stored in the @code{frame_related} field and printed as @samp{/f}.\n \n+@findex MEM_READONLY_P\n+@cindex @code{mem} and @samp{/u}\n+@cindex @code{unchanging}, in @code{mem}\n+@item MEM_READONLY_P (@var{x})\n+Nonzero in a @code{mem}, if the memory is statically allocated and read-only.\n+\n+Read-only in this context means never modified during the lifetime of the\n+program, not necessarily in ROM or in write-disabled pages.  A common\n+example of the later is a shared library's global offset table.  This\n+table is initialized by the runtime loader, so the memory is technically\n+writable, but after control is transferred from the runtime loader to the\n+application, this memory will never be subsequently modified.\n+\n+Stored in the @code{unchanging} field and printed as @samp{/u}.\n+\n+@findex PREFETCH_SCHEDULE_BARRIER_P\n+@cindex @code{prefetch} and @samp{/v}\n+@cindex @code{volatile}, in @code{prefetch}\n+@item PREFETCH_SCHEDULE_BARRIER_P (@var{x})\n+In a @code{prefetch}, indicates that the prefetch is a scheduling barrier.\n+No other INSNs will be moved over it.\n+Stored in the @code{volatil} field and printed as @samp{/v}.\n+\n @findex REG_FUNCTION_VALUE_P\n @cindex @code{reg} and @samp{/i}\n @cindex @code{return_val}, in @code{reg}\n@@ -731,6 +733,37 @@ The same hard register may be used also for collecting the values of\n functions called by this one, but @code{REG_FUNCTION_VALUE_P} is zero\n in this kind of use.\n \n+@findex RTL_CONST_CALL_P\n+@cindex @code{call_insn} and @samp{/u}\n+@cindex @code{unchanging}, in @code{call_insn}\n+@item RTL_CONST_CALL_P (@var{x})\n+In a @code{call_insn} indicates that the insn represents a call to a\n+const function.  Stored in the @code{unchanging} field and printed as\n+@samp{/u}.\n+\n+@findex RTL_PURE_CALL_P\n+@cindex @code{call_insn} and @samp{/i}\n+@cindex @code{return_val}, in @code{call_insn}\n+@item RTL_PURE_CALL_P (@var{x})\n+In a @code{call_insn} indicates that the insn represents a call to a\n+pure function.  Stored in the @code{return_val} field and printed as\n+@samp{/i}.\n+\n+@findex RTL_CONST_OR_PURE_CALL_P\n+@cindex @code{call_insn} and @samp{/u} or @samp{/i}\n+@item RTL_CONST_OR_PURE_CALL_P (@var{x})\n+In a @code{call_insn}, true if @code{RTL_CONST_CALL_P} or\n+@code{RTL_PURE_CALL_P} is true.\n+\n+@findex RTL_LOOPING_CONST_OR_PURE_CALL_P\n+@cindex @code{call_insn} and @samp{/c}\n+@cindex @code{call}, in @code{call_insn}\n+@item RTL_LOOPING_CONST_OR_PURE_CALL_P (@var{x})\n+In a @code{call_insn} indicates that the insn represents a possibly\n+infinite looping call to a const or pure function.  Stored in the\n+@code{call} field and printed as @samp{/c}.  Only true if one of\n+@code{RTL_CONST_CALL_P} or @code{RTL_PURE_CALL_P} is true.\n+\n @findex RTX_FRAME_RELATED_P\n @cindex @code{insn} and @samp{/f}\n @cindex @code{call_insn} and @samp{/f}\n@@ -765,21 +798,6 @@ computation performed by this instruction, i.e., one that\n This flag is required for exception handling support on targets with RTL\n prologues.\n \n-@findex MEM_READONLY_P\n-@cindex @code{mem} and @samp{/u}\n-@cindex @code{unchanging}, in @code{mem}\n-@item MEM_READONLY_P (@var{x})\n-Nonzero in a @code{mem}, if the memory is statically allocated and read-only.\n-\n-Read-only in this context means never modified during the lifetime of the\n-program, not necessarily in ROM or in write-disabled pages.  A common\n-example of the later is a shared library's global offset table.  This\n-table is initialized by the runtime loader, so the memory is technically\n-writable, but after control is transferred from the runtime loader to the\n-application, this memory will never be subsequently modified.\n-\n-Stored in the @code{unchanging} field and printed as @samp{/u}.\n-\n @findex SCHED_GROUP_P\n @cindex @code{insn} and @samp{/s}\n @cindex @code{call_insn} and @samp{/s}\n@@ -879,14 +897,6 @@ Stored in the @code{volatil} field and printed as @samp{/v}.\n Most uses of @code{SYMBOL_REF_FLAG} are historic and may be subsumed\n by @code{SYMBOL_REF_FLAGS}.  Certainly use of @code{SYMBOL_REF_FLAGS}\n is mandatory if the target requires more than one bit of storage.\n-\n-@findex PREFETCH_SCHEDULE_BARRIER_P\n-@cindex @code{prefetch} and @samp{/v}\n-@cindex @code{volatile}, in @code{prefetch}\n-@item PREFETCH_SCHEDULE_BARRIER_P (@var{x})\n-In a @code{prefetch}, indicates that the prefetch is a scheduling barrier.\n-No other INSNs will be moved over it.\n-Stored in the @code{volatil} field and printed as @samp{/v}.\n @end table\n \n These are the fields to which the above macros refer:\n@@ -974,6 +984,8 @@ In a @code{set}, 1 means it is for a return.\n \n In a @code{call_insn}, 1 means it is a sibling call.\n \n+In a @code{jump_insn}, 1 means it is a crossing jump.\n+\n In an RTL dump, this flag is represented as @samp{/j}.\n \n @findex unchanging\n@@ -3910,16 +3922,6 @@ multiple targets; the last label in the insn (in the highest numbered\n insn-field) goes into the @code{JUMP_LABEL} field and does not have a\n @code{REG_LABEL_TARGET} note.  @xref{Insns, JUMP_LABEL}.\n \n-@findex REG_CROSSING_JUMP\n-@item REG_CROSSING_JUMP\n-This insn is a branching instruction (either an unconditional jump or\n-an indirect jump) which crosses between hot and cold sections, which\n-could potentially be very far apart in the executable.  The presence\n-of this note indicates to other optimizations that this branching\n-instruction should not be ``collapsed'' into a simpler branching\n-construct.  It is used when the optimization to partition basic blocks\n-into hot and cold sections is turned on.\n-\n @findex REG_SETJMP\n @item REG_SETJMP\n Appears attached to each @code{CALL_INSN} to @code{setjmp} or a"}, {"sha": "77f3fe7cf43066ed1572e154dac10fdfd8aeec02", "filename": "gcc/reorg.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52af380439eab2770ad65af495e2c1a281e4b097/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52af380439eab2770ad65af495e2c1a281e4b097/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=52af380439eab2770ad65af495e2c1a281e4b097", "patch": "@@ -3361,10 +3361,11 @@ relax_delay_slots (rtx_insn *first)\n \t}\n \n       /* See if we have a simple (conditional) jump that is useless.  */\n-      if (! INSN_ANNULLED_BRANCH_P (delay_jump_insn)\n-\t  && ! condjump_in_parallel_p (delay_jump_insn)\n+      if (!CROSSING_JUMP_P (delay_jump_insn)\n+\t  && !INSN_ANNULLED_BRANCH_P (delay_jump_insn)\n+\t  && !condjump_in_parallel_p (delay_jump_insn)\n \t  && prev_active_insn (as_a<rtx_insn *> (target_label)) == insn\n-\t  && ! BARRIER_P (prev_nonnote_insn (as_a<rtx_insn *> (target_label)))\n+\t  && !BARRIER_P (prev_nonnote_insn (as_a<rtx_insn *> (target_label)))\n \t  /* If the last insn in the delay slot sets CC0 for some insn,\n \t     various code assumes that it is in a delay slot.  We could\n \t     put it back where it belonged and delete the register notes,"}]}