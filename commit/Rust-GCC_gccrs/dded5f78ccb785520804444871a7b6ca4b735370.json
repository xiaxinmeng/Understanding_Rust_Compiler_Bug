{"sha": "dded5f78ccb785520804444871a7b6ca4b735370", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRlZDVmNzhjY2I3ODU1MjA4MDQ0NDQ4NzFhN2I2Y2E0YjczNTM3MA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-08T18:38:10Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-12-08T18:41:15Z"}, "message": "c++: template and clone fns for modules\n\nWe need to expose build_cdtor_clones, it fortunately has the desired\nAPI -- gosh, how did that happen? :) The template machinery will need\nto cache path-of-instantiation information, so add two more fields to\nthe tinst_level struct.  I also had to adjust the\nmatch_mergeable_specialization API since adding it, so including that\nchange too.\n\n\tgcc/cp/\n\t* cp-tree.h (struct tinst_level): Add path & visible fields.\n\t(build_cdtor_clones): Declare.\n\t(match_mergeable_specialization): Use a spec_entry, add insert parm.\n\t* class.c (build_cdtor_clones): Externalize.\n\t* pt.c (push_tinst_level_loc): Clear new fields.\n\t(match_mergeable_specialization): Adjust API.", "tree": {"sha": "ce07f49d461a256bf322fa2e9be7ad3bf439905b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce07f49d461a256bf322fa2e9be7ad3bf439905b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dded5f78ccb785520804444871a7b6ca4b735370", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dded5f78ccb785520804444871a7b6ca4b735370", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dded5f78ccb785520804444871a7b6ca4b735370", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dded5f78ccb785520804444871a7b6ca4b735370/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5312fa0fd95aab112abe40f2a5cdb70a76e89fbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5312fa0fd95aab112abe40f2a5cdb70a76e89fbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5312fa0fd95aab112abe40f2a5cdb70a76e89fbf"}], "stats": {"total": 48, "additions": 28, "deletions": 20}, "files": [{"sha": "2ab123d6ccfb4a68fae8650d7334c2996b667a2c", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dded5f78ccb785520804444871a7b6ca4b735370/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dded5f78ccb785520804444871a7b6ca4b735370/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=dded5f78ccb785520804444871a7b6ca4b735370", "patch": "@@ -4920,7 +4920,7 @@ build_clone (tree fn, tree name, bool need_vtt_parm_p,\n /* Build the clones of FN, return the number of clones built.  These\n    will be inserted onto DECL_CHAIN of FN.  */\n \n-static void\n+void\n build_cdtor_clones (tree fn, bool needs_vtt_p, bool base_omits_inherited_p,\n \t\t    bool update_methods)\n {"}, {"sha": "66ad114567d64262edd9ac9ad0ab1156d2ac6380", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dded5f78ccb785520804444871a7b6ca4b735370/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dded5f78ccb785520804444871a7b6ca4b735370/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=dded5f78ccb785520804444871a7b6ca4b735370", "patch": "@@ -6196,6 +6196,13 @@ struct GTY((chain_next (\"%h.next\"))) tinst_level {\n      arguments.  */\n   tree tldcl, targs;\n \n+  /* For modules we need to know (a) the modules on the path of\n+     instantiation and (b) the transitive imports along that path.\n+     Note that these two bitmaps may be inherited from NEXT, if this\n+     decl is in the same module as NEXT (or has no new information).  */\n+  bitmap path;\n+  bitmap visible;\n+\n  private:\n   /* Return TRUE iff the original node is a split list.  */\n   bool split_list_p () const { return targs; }\n@@ -6497,6 +6504,7 @@ extern void check_abi_tags\t\t\t(tree);\n extern tree missing_abi_tags\t\t\t(tree);\n extern void fixup_type_variants\t\t\t(tree);\n extern void fixup_attribute_variants\t\t(tree);\n+extern void build_cdtor_clones \t\t\t(tree, bool, bool, bool);\n extern void clone_cdtor\t\t\t\t(tree, bool);\n extern tree copy_operator_fn\t\t\t(tree, tree_code code);\n extern void adjust_clone_args\t\t\t(tree);\n@@ -7189,8 +7197,8 @@ extern void walk_specializations\t\t(bool,\n \t\t\t\t\t\t void (*)(bool, spec_entry *,\n \t\t\t\t\t\t\t  void *),\n \t\t\t\t\t\t void *);\n-extern tree match_mergeable_specialization\t(bool is_decl, tree tmpl,\n-\t\t\t\t\t\t tree args, tree spec);\n+extern tree match_mergeable_specialization\t(bool is_decl, spec_entry *,\n+\t\t\t\t\t\t bool insert = true);\n extern unsigned get_mergeable_specialization_flags (tree tmpl, tree spec);\n extern void add_mergeable_specialization        (tree tmpl, tree args,\n \t\t\t\t\t\t tree spec, unsigned);"}, {"sha": "56d7b56022919013a511bac00ae21e4d49841187", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dded5f78ccb785520804444871a7b6ca4b735370/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dded5f78ccb785520804444871a7b6ca4b735370/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=dded5f78ccb785520804444871a7b6ca4b735370", "patch": "@@ -1704,10 +1704,11 @@ register_specialization (tree spec, tree tmpl, tree args, bool is_friend,\n   return spec;\n }\n \n-/* Returns true iff two spec_entry nodes are equivalent.  */\n-\n+/* Restricts tree and type comparisons.  */\n int comparing_specializations;\n \n+/* Returns true iff two spec_entry nodes are equivalent.  */\n+\n bool\n spec_hasher::equal (spec_entry *e1, spec_entry *e2)\n {\n@@ -10909,6 +10910,7 @@ push_tinst_level_loc (tree tldcl, tree targs, location_t loc)\n   new_level->errors = errorcount + sorrycount;\n   new_level->next = NULL;\n   new_level->refcount = 0;\n+  new_level->path = new_level->visible = nullptr;\n   set_refcount_ptr (new_level->next, current_tinst_level);\n   set_refcount_ptr (current_tinst_level, new_level);\n \n@@ -29668,29 +29670,27 @@ walk_specializations (bool decls_p,\n     fn (decls_p, *iter, data);\n }\n \n-/* Lookup the specialization of TMPL, ARGS in the decl or type\n-   specialization table.  Return what's there, or if SPEC is non-null,\n-   add it and return NULL.  */\n+/* Lookup the specialization of *ELT, in the decl or type\n+   specialization table.  Return the SPEC that's already there (NULL if\n+   nothing).  If INSERT is true, and there was nothing, add the new\n+   spec.  */\n \n tree\n-match_mergeable_specialization (bool decl_p, tree tmpl, tree args, tree spec)\n+match_mergeable_specialization (bool decl_p, spec_entry *elt, bool insert)\n {\n-  spec_entry elt = {tmpl, args, spec};\n   hash_table<spec_hasher> *specializations\n     = decl_p ? decl_specializations : type_specializations;\n-  hashval_t hash = spec_hasher::hash (&elt);\n+  hashval_t hash = spec_hasher::hash (elt);\n   spec_entry **slot\n-    = specializations->find_slot_with_hash (&elt, hash,\n-\t\t\t\t\t    spec ? INSERT : NO_INSERT);\n-  spec_entry *entry = slot ? *slot: NULL;\n-  \n-  if (entry)\n-    return entry->spec;\n+    = specializations->find_slot_with_hash (elt, hash,\n+\t\t\t\t\t    insert ? INSERT : NO_INSERT);\n+  if (slot && *slot)\n+    return (*slot)->spec;\n \n-  if (spec)\n+  if (insert)\n     {\n-      entry = ggc_alloc<spec_entry> ();\n-      *entry = elt;\n+      auto entry = ggc_alloc<spec_entry> ();\n+      *entry = *elt;\n       *slot = entry;\n     }\n "}]}