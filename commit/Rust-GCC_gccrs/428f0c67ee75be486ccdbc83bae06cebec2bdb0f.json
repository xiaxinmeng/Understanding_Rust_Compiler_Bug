{"sha": "428f0c67ee75be486ccdbc83bae06cebec2bdb0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI4ZjBjNjdlZTc1YmU0ODZjY2RiYzgzYmFlMDZjZWJlYzJiZGIwZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-03-08T23:12:25Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-03-08T23:12:25Z"}, "message": "re PR ipa/65334 (r221099 caused: FAIL: gfortran.fortran-torture/execute/in-pack.f90 execution, -O2 -ftree-vectorize -msse2)\n\n\n\tPR ipa/65334\n\t* cgraph.h (symtab_node): Add definition_alignment,\n\tcan_increase_alignment_p and increase_alignment.\n\t* symtab.c (symtab_node::can_increase_alignment_p,\n\tincrease_alignment_1, symtab_node::increase_alignment,\n\tsymtab_node::definition_alignment): New.\n\t* tree-vect-data-refs.c (vect_can_force_dr_alignment_p): Use\n\tcan_increase_alignment_p.\n\t* tree-vectorizer.c (increase_alignment): Use increase_alignment.\n\t* tree-vect-stmts.c (ensure_base_align): Likewise.\n\nFrom-SVN: r221268", "tree": {"sha": "1677cdff3ac9a985557890e7fa6db0a63fb9c44c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1677cdff3ac9a985557890e7fa6db0a63fb9c44c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/428f0c67ee75be486ccdbc83bae06cebec2bdb0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/428f0c67ee75be486ccdbc83bae06cebec2bdb0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/428f0c67ee75be486ccdbc83bae06cebec2bdb0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/428f0c67ee75be486ccdbc83bae06cebec2bdb0f/comments", "author": null, "committer": null, "parents": [{"sha": "fb460c3da0b3de006ae596e32826ef63a65c8f2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb460c3da0b3de006ae596e32826ef63a65c8f2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb460c3da0b3de006ae596e32826ef63a65c8f2b"}], "stats": {"total": 191, "additions": 131, "deletions": 60}, "files": [{"sha": "db1f1868b6b1bf7e6124aaddca16b262c8e6d2b4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/428f0c67ee75be486ccdbc83bae06cebec2bdb0f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/428f0c67ee75be486ccdbc83bae06cebec2bdb0f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=428f0c67ee75be486ccdbc83bae06cebec2bdb0f", "patch": "@@ -1,3 +1,16 @@\n+2015-03-05  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/65334\n+\t* cgraph.h (symtab_node): Add definition_alignment,\n+\tcan_increase_alignment_p and increase_alignment.\n+\t* symtab.c (symtab_node::can_increase_alignment_p,\n+\tincrease_alignment_1, symtab_node::increase_alignment,\n+\tsymtab_node::definition_alignment): New.\n+\t* tree-vect-data-refs.c (vect_can_force_dr_alignment_p): Use\n+\tcan_increase_alignment_p.\n+\t* tree-vectorizer.c (increase_alignment): Use increase_alignment.\n+\t* tree-vect-stmts.c (ensure_base_align): Likewise.\n+\n 2015-03-05  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/65316"}, {"sha": "dcf383bf35adba6f6e0d2dca957df1ab8cc1dbab", "filename": "gcc/cgraph.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/428f0c67ee75be486ccdbc83bae06cebec2bdb0f/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/428f0c67ee75be486ccdbc83bae06cebec2bdb0f/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=428f0c67ee75be486ccdbc83bae06cebec2bdb0f", "patch": "@@ -289,6 +289,18 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Make DECL local.  */\n   void make_decl_local (void);\n \n+  /* Return desired alignment of the definition.  This is NOT alignment useful\n+     to access THIS, because THIS may be interposable and DECL_ALIGN should\n+     be used instead.  It however must be guaranteed when output definition\n+     of THIS.  */\n+  unsigned int definition_alignment ();\n+\n+  /* Return true if alignment can be increased.  */\n+  bool can_increase_alignment_p ();\n+\n+  /* Increase alignment of symbol to ALIGN.  */\n+  void increase_alignment (unsigned int align);\n+\n   /* Return true if list contains an alias.  */\n   bool has_aliases_p (void);\n "}, {"sha": "38337349d15959dcef18d42a0a739a5005b0980a", "filename": "gcc/symtab.c", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/428f0c67ee75be486ccdbc83bae06cebec2bdb0f/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/428f0c67ee75be486ccdbc83bae06cebec2bdb0f/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=428f0c67ee75be486ccdbc83bae06cebec2bdb0f", "patch": "@@ -1908,3 +1908,99 @@ symtab_node::address_matters_p ()\n   gcc_assert (!alias);\n   return call_for_symbol_and_aliases (address_matters_1, NULL, true);\n }\n+\n+/* Return ture if symbol's alignment may be increased.  */\n+\n+bool\n+symtab_node::can_increase_alignment_p (void)\n+{\n+  symtab_node *target = ultimate_alias_target ();\n+\n+  /* For now support only variables.  */\n+  if (TREE_CODE (decl) != VAR_DECL)\n+    return false;\n+\n+  /* With -fno-toplevel-reorder we may have already output the constant.  */\n+  if (TREE_ASM_WRITTEN (target->decl))\n+    return false;\n+\n+  /* Constant pool entries may be shared.  */\n+  if (DECL_IN_CONSTANT_POOL (target->decl))\n+    return false;\n+\n+  /* We cannot change alignment of symbols that may bind to symbols\n+     in other translation unit that may contain a definition with lower\n+     alignment.  */\n+  if (!decl_binds_to_current_def_p (decl))\n+    return false;\n+\n+  /* When compiling partition, be sure the symbol is not output by other\n+     partition.  */\n+  if (flag_ltrans\n+      && (target->in_other_partition\n+\t  || target->get_partitioning_class () == SYMBOL_DUPLICATE))\n+    return false;\n+\n+  /* Do not override the alignment as specified by the ABI when the used\n+     attribute is set.  */\n+  if (DECL_PRESERVE_P (decl) || DECL_PRESERVE_P (target->decl))\n+    return false;\n+\n+  /* Do not override explicit alignment set by the user when an explicit\n+     section name is also used.  This is a common idiom used by many\n+     software projects.  */\n+  if (DECL_SECTION_NAME (target->decl) != NULL && !target->implicit_section)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Worker for symtab_node::increase_alignment.  */\n+\n+static bool\n+increase_alignment_1 (symtab_node *n, void *v)\n+{\n+  unsigned int align = (size_t)v;\n+  if (DECL_ALIGN (n->decl) < align\n+      && n->can_increase_alignment_p ())\n+    {\n+      DECL_ALIGN (n->decl) = align;\n+      DECL_USER_ALIGN (n->decl) = 1;\n+    }\n+  return false;\n+}\n+\n+/* Increase alignment of THIS to ALIGN.  */\n+\n+void\n+symtab_node::increase_alignment (unsigned int align)\n+{\n+  gcc_assert (can_increase_alignment_p () && align < MAX_OFILE_ALIGNMENT);\n+  ultimate_alias_target()->call_for_symbol_and_aliases (increase_alignment_1,\n+\t\t\t\t\t\t        (void *)(size_t) align,\n+\t\t\t\t\t\t        true);\n+  gcc_assert (DECL_ALIGN (decl) >= align);\n+}\n+\n+/* Helper for symtab_node::definition_alignment.  */\n+\n+static bool\n+get_alignment_1 (symtab_node *n, void *v)\n+{\n+  *((unsigned int *)v) = MAX (*((unsigned int *)v), DECL_ALIGN (n->decl));\n+  return false;\n+}\n+\n+/* Return desired alignment of the definition.  This is NOT alignment useful\n+   to access THIS, because THIS may be interposable and DECL_ALIGN should\n+   be used instead.  It however must be guaranteed when output definition\n+   of THIS.  */\n+\n+unsigned int\n+symtab_node::definition_alignment ()\n+{\n+  unsigned int align = 0;\n+  gcc_assert (!alias);\n+  call_for_symbol_and_aliases (get_alignment_1, &align, true);\n+  return align;\n+}"}, {"sha": "5ff6307e1ac9ebb374b18a13473e5d5314d1d096", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 2, "deletions": 50, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/428f0c67ee75be486ccdbc83bae06cebec2bdb0f/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/428f0c67ee75be486ccdbc83bae06cebec2bdb0f/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=428f0c67ee75be486ccdbc83bae06cebec2bdb0f", "patch": "@@ -5703,58 +5703,10 @@ vect_can_force_dr_alignment_p (const_tree decl, unsigned int alignment)\n   if (TREE_CODE (decl) != VAR_DECL)\n     return false;\n \n-  /* With -fno-toplevel-reorder we may have already output the constant.  */\n-  if (TREE_ASM_WRITTEN (decl))\n+  if (decl_in_symtab_p (decl)\n+      && !symtab_node::get (decl)->can_increase_alignment_p ())\n     return false;\n \n-  /* Constant pool entries may be shared and not properly merged by LTO.  */\n-  if (DECL_IN_CONSTANT_POOL (decl))\n-    return false;\n-\n-  if (TREE_PUBLIC (decl) || DECL_EXTERNAL (decl))\n-    {\n-      symtab_node *snode;\n-\n-      /* We cannot change alignment of symbols that may bind to symbols\n-\t in other translation unit that may contain a definition with lower\n-\t alignment.  */\n-      if (!decl_binds_to_current_def_p (decl))\n-\treturn false;\n-\n-      /* When compiling partition, be sure the symbol is not output by other\n-\t partition.  */\n-      snode = symtab_node::get (decl);\n-      if (flag_ltrans\n-\t  && (snode->in_other_partition\n-\t      || snode->get_partitioning_class () == SYMBOL_DUPLICATE))\n-\treturn false;\n-    }\n-\n-  /* Do not override the alignment as specified by the ABI when the used\n-     attribute is set.  */\n-  if (DECL_PRESERVE_P (decl))\n-    return false;\n-\n-  /* Do not override explicit alignment set by the user when an explicit\n-     section name is also used.  This is a common idiom used by many\n-     software projects.  */\n-  if (TREE_STATIC (decl) \n-      && DECL_SECTION_NAME (decl) != NULL\n-      && !symtab_node::get (decl)->implicit_section)\n-    return false;\n-\n-  /* If symbol is an alias, we need to check that target is OK.  */\n-  if (TREE_STATIC (decl))\n-    {\n-      tree target = symtab_node::get (decl)->ultimate_alias_target ()->decl;\n-      if (target != decl)\n-\t{\n-\t  if (DECL_PRESERVE_P (target))\n-\t    return false;\n-\t  decl = target;\n-\t}\n-    }\n-\n   if (TREE_STATIC (decl))\n     return (alignment <= MAX_OFILE_ALIGNMENT);\n   else"}, {"sha": "41ff80245e559869a405d9ad867694e91a27a555", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/428f0c67ee75be486ccdbc83bae06cebec2bdb0f/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/428f0c67ee75be486ccdbc83bae06cebec2bdb0f/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=428f0c67ee75be486ccdbc83bae06cebec2bdb0f", "patch": "@@ -4956,8 +4956,13 @@ ensure_base_align (stmt_vec_info stmt_info, struct data_reference *dr)\n       tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n       tree base_decl = ((dataref_aux *)dr->aux)->base_decl;\n \n-      DECL_ALIGN (base_decl) = TYPE_ALIGN (vectype);\n-      DECL_USER_ALIGN (base_decl) = 1;\n+      if (decl_in_symtab_p (base_decl))\n+\tsymtab_node::get (base_decl)->increase_alignment (TYPE_ALIGN (vectype));\n+      else\n+\t{\n+          DECL_ALIGN (base_decl) = TYPE_ALIGN (vectype);\n+          DECL_USER_ALIGN (base_decl) = 1;\n+\t}\n       ((dataref_aux *)dr->aux)->base_misaligned = false;\n     }\n }"}, {"sha": "415bffa14d52329d5edcf153eb069c94e1aec037", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/428f0c67ee75be486ccdbc83bae06cebec2bdb0f/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/428f0c67ee75be486ccdbc83bae06cebec2bdb0f/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=428f0c67ee75be486ccdbc83bae06cebec2bdb0f", "patch": "@@ -719,14 +719,7 @@ increase_alignment (void)\n \n       if (vect_can_force_dr_alignment_p (decl, alignment))\n         {\n-          DECL_ALIGN (decl) = TYPE_ALIGN (vectype);\n-          DECL_USER_ALIGN (decl) = 1;\n-\t  if (TREE_STATIC (decl))\n-\t    {\n-\t      tree target = symtab_node::get (decl)->ultimate_alias_target ()->decl;\n-              DECL_ALIGN (target) = TYPE_ALIGN (vectype);\n-              DECL_USER_ALIGN (target) = 1;\n-\t    }\n+\t  vnode->increase_alignment (TYPE_ALIGN (vectype));\n           dump_printf (MSG_NOTE, \"Increasing alignment of decl: \");\n           dump_generic_expr (MSG_NOTE, TDF_SLIM, decl);\n           dump_printf (MSG_NOTE, \"\\n\");"}]}