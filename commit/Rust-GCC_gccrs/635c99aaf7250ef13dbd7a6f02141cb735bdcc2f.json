{"sha": "635c99aaf7250ef13dbd7a6f02141cb735bdcc2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM1Yzk5YWFmNzI1MGVmMTNkYmQ3YTZmMDIxNDFjYjczNWJkY2MyZg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2017-09-11T09:09:26Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2017-09-11T09:09:26Z"}, "message": "Make HSA resilient to side-effects of split_edge\n\n2017-09-11  Martin Jambor  <mjambor@suse.cz>\n\n\tPR hsa/82119\n\t* hsa-gen.c (gen_hsa_phi_from_gimple_phi): Process ADDR_EXPRs in\n\targuments in advance.\n\t* hsa-regalloc.c (naive_process_phi): New parameter predecessors,\n\tuse it to find predecessor edges.\n\t(naive_outof_ssa): Collect vector of predecessors.\n\nFrom-SVN: r251964", "tree": {"sha": "b534647fe8cf86ea3c75931fae8433de321d57e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b534647fe8cf86ea3c75931fae8433de321d57e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/635c99aaf7250ef13dbd7a6f02141cb735bdcc2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/635c99aaf7250ef13dbd7a6f02141cb735bdcc2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/635c99aaf7250ef13dbd7a6f02141cb735bdcc2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/635c99aaf7250ef13dbd7a6f02141cb735bdcc2f/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "15bac1919aab8a4fcbd0150e30f1bc53ae2b271f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15bac1919aab8a4fcbd0150e30f1bc53ae2b271f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15bac1919aab8a4fcbd0150e30f1bc53ae2b271f"}], "stats": {"total": 74, "additions": 58, "deletions": 16}, "files": [{"sha": "9388cabc870de1011942d740c8307f3e27dd7c35", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635c99aaf7250ef13dbd7a6f02141cb735bdcc2f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635c99aaf7250ef13dbd7a6f02141cb735bdcc2f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=635c99aaf7250ef13dbd7a6f02141cb735bdcc2f", "patch": "@@ -1,3 +1,12 @@\n+2017-09-11  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR hsa/82119\n+\t* hsa-gen.c (gen_hsa_phi_from_gimple_phi): Process ADDR_EXPRs in\n+\targuments in advance.\n+\t* hsa-regalloc.c (naive_process_phi): New parameter predecessors,\n+\tuse it to find predecessor edges.\n+\t(naive_outof_ssa): Collect vector of predecessors.\n+\n 2017-09-08  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/70029 - ICE with ref-qualifier and -flto"}, {"sha": "6e054c0ce82f57d02e6f8c114df78fd6ab130103", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635c99aaf7250ef13dbd7a6f02141cb735bdcc2f/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635c99aaf7250ef13dbd7a6f02141cb735bdcc2f/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=635c99aaf7250ef13dbd7a6f02141cb735bdcc2f", "patch": "@@ -5657,8 +5657,37 @@ gen_hsa_phi_from_gimple_phi (gimple *phi_stmt, hsa_bb *hbb)\n   hphi = new hsa_insn_phi (count, dest);\n   hphi->m_bb = hbb->m_bb;\n \n-  tree lhs = gimple_phi_result (phi_stmt);\n+  auto_vec <tree, 8> aexprs;\n+  auto_vec <hsa_op_reg *, 8> aregs;\n+\n+  /* Calling split_edge when processing a PHI node messes up with the order of\n+     gimple phi node arguments (it moves the one associated with the edge to\n+     the end).  We need to keep the order of edges and arguments of HSA phi\n+     node arguments consistent, so we do all required splitting as the first\n+     step, and in reverse order as to not be affected by the re-orderings.  */\n+  for (unsigned j = count; j != 0; j--)\n+    {\n+      unsigned i = j - 1;\n+      tree op = gimple_phi_arg_def (phi_stmt, i);\n+      if (TREE_CODE (op) != ADDR_EXPR)\n+\tcontinue;\n \n+      edge e = gimple_phi_arg_edge (as_a <gphi *> (phi_stmt), i);\n+      hsa_bb *hbb_src = hsa_init_new_bb (split_edge (e));\n+      hsa_op_address *addr = gen_hsa_addr (TREE_OPERAND (op, 0),\n+\t\t\t\t\t   hbb_src);\n+\n+      hsa_op_reg *dest\n+\t= new hsa_op_reg (hsa_get_segment_addr_type (BRIG_SEGMENT_FLAT));\n+      hsa_insn_basic *insn\n+\t= new hsa_insn_basic (2, BRIG_OPCODE_LDA, BRIG_TYPE_U64,\n+\t\t\t      dest, addr);\n+      hbb_src->append_insn (insn);\n+      aexprs.safe_push (op);\n+      aregs.safe_push (dest);\n+    }\n+\n+  tree lhs = gimple_phi_result (phi_stmt);\n   for (unsigned i = 0; i < count; i++)\n     {\n       tree op = gimple_phi_arg_def (phi_stmt, i);\n@@ -5684,18 +5713,14 @@ gen_hsa_phi_from_gimple_phi (gimple *phi_stmt, hsa_bb *hbb)\n \t    }\n \t  else if (TREE_CODE (op) == ADDR_EXPR)\n \t    {\n-\t      edge e = gimple_phi_arg_edge (as_a <gphi *> (phi_stmt), i);\n-\t      hsa_bb *hbb_src = hsa_init_new_bb (split_edge (e));\n-\t      hsa_op_address *addr = gen_hsa_addr (TREE_OPERAND (op, 0),\n-\t\t\t\t\t\t   hbb_src);\n-\n-\t      hsa_op_reg *dest\n-\t\t= new hsa_op_reg (hsa_get_segment_addr_type (BRIG_SEGMENT_FLAT));\n-\t      hsa_insn_basic *insn\n-\t\t= new hsa_insn_basic (2, BRIG_OPCODE_LDA, BRIG_TYPE_U64,\n-\t\t\t\t      dest, addr);\n-\t      hbb_src->append_insn (insn);\n-\n+\t      hsa_op_reg *dest = NULL;\n+\t      for (unsigned a_idx = 0; a_idx < aexprs.length (); a_idx++)\n+\t\tif (aexprs[a_idx] == op)\n+\t\t  {\n+\t\t    dest = aregs[a_idx];\n+\t\t    break;\n+\t\t  }\n+\t      gcc_assert (dest);\n \t      hphi->set_op (i, dest);\n \t    }\n \t  else"}, {"sha": "7fc3a8afa3d0b8b26449f10f36a599bde6020be0", "filename": "gcc/hsa-regalloc.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/635c99aaf7250ef13dbd7a6f02141cb735bdcc2f/gcc%2Fhsa-regalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/635c99aaf7250ef13dbd7a6f02141cb735bdcc2f/gcc%2Fhsa-regalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-regalloc.c?ref=635c99aaf7250ef13dbd7a6f02141cb735bdcc2f", "patch": "@@ -42,7 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Process a PHI node PHI of basic block BB as a part of naive out-f-ssa.  */\n \n static void\n-naive_process_phi (hsa_insn_phi *phi)\n+naive_process_phi (hsa_insn_phi *phi, const vec<edge> &predecessors)\n {\n   unsigned count = phi->operand_count ();\n   for (unsigned i = 0; i < count; i++)\n@@ -55,7 +55,7 @@ naive_process_phi (hsa_insn_phi *phi)\n       if (!op)\n \tbreak;\n \n-      e = EDGE_PRED (phi->m_bb, i);\n+      e = predecessors[i];\n       if (single_succ_p (e->src))\n \thbb = hsa_bb_for_bb (e->src);\n       else\n@@ -89,10 +89,18 @@ naive_outof_ssa (void)\n     hsa_bb *hbb = hsa_bb_for_bb (bb);\n     hsa_insn_phi *phi;\n \n+    /* naive_process_phi can call split_edge on an incoming edge which order if\n+       the incoming edges to the basic block and thus make it inconsistent with\n+       the ordering of PHI arguments, so we collect them in advance.  */\n+    auto_vec<edge, 8> predecessors;\n+    unsigned pred_count = EDGE_COUNT (bb->preds);\n+    for (unsigned i = 0; i < pred_count; i++)\n+      predecessors.safe_push (EDGE_PRED (bb, i));\n+\n     for (phi = hbb->m_first_phi;\n \t phi;\n \t phi = phi->m_next ? as_a <hsa_insn_phi *> (phi->m_next) : NULL)\n-      naive_process_phi (phi);\n+      naive_process_phi (phi, predecessors);\n \n     /* Zap PHI nodes, they will be deallocated when everything else will.  */\n     hbb->m_first_phi = NULL;"}]}