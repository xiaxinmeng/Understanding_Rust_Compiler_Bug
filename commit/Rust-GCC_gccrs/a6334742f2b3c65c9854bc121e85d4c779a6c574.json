{"sha": "a6334742f2b3c65c9854bc121e85d4c779a6c574", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTYzMzQ3NDJmMmIzYzY1Yzk4NTRiYzEyMWU4NWQ0Yzc3OWE2YzU3NA==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargls@comcast.net", "date": "2005-05-07T20:37:20Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2005-05-07T20:37:20Z"}, "message": "intrinsic.texi: Document ASSOCIATED and ATAN2.\n\n* intrinsic.texi:  Document ASSOCIATED and ATAN2.  Update Bessel function\n  descriptions to include info about scalar arguments.\n\nFrom-SVN: r99365", "tree": {"sha": "ea68c1232ced74a1e1d3bc01c14ebfcd3fa12525", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea68c1232ced74a1e1d3bc01c14ebfcd3fa12525"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6334742f2b3c65c9854bc121e85d4c779a6c574", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6334742f2b3c65c9854bc121e85d4c779a6c574", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6334742f2b3c65c9854bc121e85d4c779a6c574", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6334742f2b3c65c9854bc121e85d4c779a6c574/comments", "author": null, "committer": null, "parents": [{"sha": "758cdc11236776e041052596fe0580edd0081e40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/758cdc11236776e041052596fe0580edd0081e40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/758cdc11236776e041052596fe0580edd0081e40"}], "stats": {"total": 191, "additions": 160, "deletions": 31}, "files": [{"sha": "69180f92dbc8f1346238d1a8c86bd367bbb37421", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6334742f2b3c65c9854bc121e85d4c779a6c574/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6334742f2b3c65c9854bc121e85d4c779a6c574/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a6334742f2b3c65c9854bc121e85d4c779a6c574", "patch": "@@ -1,3 +1,8 @@\n+2005-05-07  Steven G. Kargl  <kargls@comcast.net>\n+\n+\t* intrinsic.texi:  Document ASSOCIATED and ATAN2.  Update Bessel function\n+\tdescription to include information about scalar arguments.\n+\n 2005-05-03  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* Make-lang.in, dump-parse-tree.c, invoke.texi, lang.opt,"}, {"sha": "9eb32413d50b61a9a2bf5e54b9c627bb4dad21f4", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 155, "deletions": 31, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6334742f2b3c65c9854bc121e85d4c779a6c574/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6334742f2b3c65c9854bc121e85d4c779a6c574/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=a6334742f2b3c65c9854bc121e85d4c779a6c574", "patch": "@@ -46,7 +46,9 @@ and editing.  All contributions and corrections are strongly encouraged.\n * @code{ANINT}:     ANINT,     Nearest whole number\n * @code{ANY}:       ANY,       Determine if any values are true\n * @code{ASIN}:      ASIN,      Arcsine function\n-* @code{ATAN}:      ATAN,      Arctangent function\n+* @code{ASSOCIATED}: ASSOCIATED, Status of a pointer or pointer/target pair\n+* @code{ATAN}:       ATAN,      Arctangent function\n+* @code{ATAN2}:      ATAN2,      Arctangent function\n * @code{BESJ0}:     BESJ0,     Bessel function of the first kind of order 0\n * @code{BESJ1}:     BESJ1,     Bessel function of the first kind of order 1\n * @code{BESJN}:     BESJN,     Bessel function of the first kind\n@@ -472,7 +474,7 @@ end program test_aint\n \n @node ALL\n @section @code{ALL} --- All values in @var{MASK} along @var{DIM} are true \n-  @findex @code{ALL} intrinsic\n+@findex @code{ALL} intrinsic\n @cindex true values\n \n @table @asis\n@@ -536,6 +538,7 @@ end program test_all\n @end table\n \n \n+\n @node ALLOCATED\n @section @code{ALLOCATED} --- Status of an allocatable entity\n @findex @code{ALLOCATED} intrinsic\n@@ -631,7 +634,7 @@ end program test_anint\n \n @node ANY\n @section @code{ANY} --- Any value in @var{MASK} along @var{DIM} is true \n-  @findex @code{ANY} intrinsic\n+@findex @code{ANY} intrinsic\n @cindex true values\n \n @table @asis\n@@ -722,7 +725,7 @@ less than one.\n \n @item @emph{Return value}:\n The return value is of type @code{REAL(*)} and it lies in the\n-range @math{ \\pi / 2 \\leq \\arccos (x) \\leq \\pi / 2}.  The kind type\n+range @math{-\\pi / 2 \\leq \\arccos (x) \\leq \\pi / 2}.  The kind type\n parameter is the same as @var{X}.\n \n @item @emph{Example}:\n@@ -741,6 +744,78 @@ end program test_asin\n @end table\n \n \n+@node ASSOCIATED\n+@section @code{ASSOCIATED} --- Status of a pointer or pointer/target pair \n+@findex @code{ASSOCIATED} intrinsic\n+@cindex pointer status\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{ASSOCIATED(PTR [, TGT])} determines the status of the pointer @var{PTR}\n+or if @var{PTR} is associated with the target @var{TGT}.\n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Type}:\n+inquiry function\n+\n+@item @emph{Syntax}:\n+@code{L = ASSOCIATED(PTR)} @*\n+@code{L = ASSOCIATED(PTR [, TGT])}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{PTR} @tab @var{PTR} shall have the @code{POINTER} attribute and\n+it can be of any type.\n+@item @var{TGT} @tab (Optional) @var{TGT} shall be a @code{POINTER} or\n+a @code{TARGET}.  It must have the same type, kind type parameter, and\n+array rank as @var{PTR}.\n+@end multitable\n+The status of neither @var{PTR} nor @var{TGT} can be undefined.\n+\n+@item @emph{Return value}:\n+@code{ASSOCIATED(PTR)} returns a scalar value of type @code{LOGICAL(4)}.\n+There are several cases:\n+@table @asis\n+@item (A) If the optional @var{TGT} is not present, then @code{ASSOCIATED(PTR)}\n+is true if @var{PTR} is associated with a target; otherwise, it returns false.\n+@item (B) If @var{TGT} is present and a scalar target, the result is true if\n+@var{TGT}\n+is not a 0 sized storage sequence and the target associated with @var{PTR}\n+occupies the same storage units.  If @var{PTR} is disassociated, then the \n+result is false.\n+@item (C) If @var{TGT} is present and an array target, the result is true if\n+@var{TGT} and @var{PTR} have the same shape, are not 0 sized arrays, are\n+arrays whose elements are not 0 sized storage sequences, and @var{TGT} and\n+@var{PTR} occupy the same storage units in array element order.\n+As in case(B), the result is false, if @var{PTR} is disassociated.\n+@item (D) If @var{TGT} is present and an scalar pointer, the result is true if\n+target associated with @var{PTR} and the target associated with @var{TGT}\n+are not 0 sized storage sequences and occupy the same storage units.\n+The result is false, if either @var{TGT} or @var{PTR} is disassociated.\n+@item (E) If @var{TGT} is present and an array pointer, the result is true if\n+target assoicated with @var{PTR} and the target associated with @var{TGT}\n+have the same shape, are not 0 sized arrays, are arrays whose elements are\n+not 0 sized storage sequences, and @var{TGT} and @var{PTR} occupy the same\n+storage units in array element order.\n+The result is false, if either @var{TGT} or @var{PTR} is disassociated.\n+@end table\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_associated\n+   implicit none\n+   real, target  :: tgt(2) = (/1., 2./)\n+   real, pointer :: ptr(:)\n+   ptr => tgt\n+   if (associated(ptr)     .eqv. .false.) call abort\n+   if (associated(ptr,tgt) .eqv. .false.) call abort\n+end program test_associated\n+@end smallexample\n+@end table\n+\n+\n @node ATAN\n @section @code{ATAN} --- Arctangent function \n @findex @code{ATAN} intrinsic\n@@ -785,6 +860,56 @@ end program test_atan\n @end table\n \n \n+@node ATAN2\n+@section @code{ATAN2} --- Arctangent function \n+@findex @code{ATAN2} intrinsic\n+@findex @code{DATAN2} intrinsic\n+@cindex arctangent\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{ATAN2(Y,X)} computes the arctangent of the complex number @math{X + i Y}.\n+\n+@item @emph{Option}:\n+f95, gnu\n+\n+@item @emph{Type}:\n+elemental function\n+\n+@item @emph{Syntax}:\n+@code{X = ATAN2(Y,X)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .80\n+@item @var{Y} @tab The type shall be @code{REAL(*)}.\n+@item @var{X} @tab The type and kind type paremeter shall be the same as @var{Y}.\n+If @var{Y} is zero, then @var{X} must be nonzero.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value has the same type and kind type paremeter as @var{Y}.\n+It is the principle value of the complex number @math{X + i Y}.  If\n+@var{X} is nonzero, then it lies in the range @math{-\\pi \\le \\arccos (x) \\leq \\pi}.\n+The sign is positive if @var{Y} is positive.  If @var{Y} is zero, then\n+the return value is zero if @var{X} is positive and @math{\\pi} if @var{X}\n+is negative.  Finally, if @var{X} is zero, then the magnitude of the result\n+is @math{\\pi/2}.\n+\n+@item @emph{Example}:\n+@smallexample\n+program test_atan2\n+  real(4) :: x = 1.e0_4, y = 0.5e0_4\n+  x = atan2(y,x)\n+end program test_atan2\n+@end smallexample\n+\n+@item @emph{Specific names}:\n+@multitable @columnfractions .24 .24 .24 .24\n+@item Name            @tab Argument          @tab Return type    @tab Option\n+@item @code{DATAN2(X)} @tab @code{REAL(8) X} @tab @code{REAL(8)} @tab f95, gnu\n+@end multitable\n+@end table\n+\n \n @node BESJ0\n @section @code{BESJ0} --- Bessel function of the first kind of order 0\n@@ -808,7 +933,7 @@ elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)}.\n+@item @var{X} @tab The type shall be an @code{REAL(*)}, and it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n@@ -854,7 +979,7 @@ elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)}.\n+@item @var{X} @tab The type shall be an @code{REAL(*)}, and it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n@@ -900,12 +1025,12 @@ elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{N} @tab The type shall be an @code{INTEGER(*)}.\n-@item @var{X} @tab The type shall be an @code{REAL(*)}.\n+@item @var{N} @tab The type shall be an @code{INTEGER(*)}, and it shall be scalar.\n+@item @var{X} @tab The type shall be an @code{REAL(*)}, and it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL(*)}.\n+The return value is a scalar of type @code{REAL(*)}.\n \n @item @emph{Example}:\n @smallexample\n@@ -917,8 +1042,9 @@ end program test_besjn\n \n @item @emph{Specific names}:\n @multitable @columnfractions .24 .24 .24 .24\n-@item Name            @tab Argument          @tab Return type       @tab Option\n-@item @code{DBESJN(X)}@tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab gnu\n+@item Name             @tab Argument            @tab Return type       @tab Option\n+@item @code{DBESJN(X)} @tab @code{INTEGER(*) N} @tab @code{REAL(8)}    @tab gnu\n+@item                  @tab @code{REAL(8) X}    @tab                   @tab\n @end multitable\n @end table\n \n@@ -946,11 +1072,11 @@ elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)}.\n+@item @var{X} @tab The type shall be an @code{REAL(*)}, and it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL(*)}.\n+The return value is a scalar of type @code{REAL(*)}.\n \n @item @emph{Example}:\n @smallexample\n@@ -991,11 +1117,11 @@ elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)}.\n+@item @var{X} @tab The type shall be an @code{REAL(*)}, and it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL(*)}.\n+The return value is a scalar of type @code{REAL(*)}.\n \n @item @emph{Example}:\n @smallexample\n@@ -1036,12 +1162,12 @@ elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{N} @tab The type shall be an @code{INTEGER(*)}.\n-@item @var{X} @tab The type shall be an @code{REAL(*)}.\n+@item @var{N} @tab The type shall be an @code{INTEGER(*)}, and it shall be scalar.\n+@item @var{X} @tab The type shall be an @code{REAL(*)}, and it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL(*)}.\n+The return value is a scalar of type @code{REAL(*)}.\n \n @item @emph{Example}:\n @smallexample\n@@ -1053,8 +1179,9 @@ end program test_besyn\n \n @item @emph{Specific names}:\n @multitable @columnfractions .24 .24 .24 .24\n-@item Name            @tab Argument          @tab Return type       @tab Option\n-@item @code{DBESYN(X)}@tab @code{REAL(8) X}  @tab @code{REAL(8)}    @tab gnu\n+@item Name               @tab Argument            @tab Return type     @tab Option\n+@item @code{DBESYN(N,X)} @tab @code{INTEGER(*) N} @tab @code{REAL(8)}  @tab gnu\n+@item                    @tab @code{REAL(8)    X} @tab                 @tab \n @end multitable\n @end table\n \n@@ -1155,7 +1282,7 @@ end program test_cosh\n @node ERF\n @section @code{ERF} --- Error function \n @findex @code{ERF} intrinsic\n-@cindex error\n+@cindex error function\n \n @table @asis\n @item @emph{Description}:\n@@ -1172,11 +1299,11 @@ elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)}.\n+@item @var{X} @tab The type shall be an @code{REAL(*)}, and it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL(*)} and it is positive\n+The return value is a scalar of type @code{REAL(*)} and it is positive\n (@math{ - 1 \\leq erf (x) \\leq 1 }.\n \n @item @emph{Example}:\n@@ -1199,7 +1326,7 @@ end program test_erf\n @node ERFC\n @section @code{ERFC} --- Error function \n @findex @code{ERFC} intrinsic\n-@cindex error\n+@cindex error function\n \n @table @asis\n @item @emph{Description}:\n@@ -1216,11 +1343,11 @@ elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .80\n-@item @var{X} @tab The type shall be an @code{REAL(*)}.\n+@item @var{X} @tab The type shall be an @code{REAL(*)}, and it shall be scalar.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL(*)} and it is positive\n+The return value is a scalar of type @code{REAL(*)} and it is positive\n (@math{ 0 \\leq erfc (x) \\leq 2 }.\n \n @item @emph{Example}:\n@@ -1631,11 +1758,8 @@ end program test_tanh\n \n \n \n-@comment gen   associated\n-@comment \n-@comment gen   atan2\n-@comment       datan2\n-@comment \n+\n+\n @comment gen   bit_size \n @comment \n @comment gen   btest"}]}