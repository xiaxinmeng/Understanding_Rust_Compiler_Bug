{"sha": "7efcb746dac871864e4f193ea3abda75ab2b7f5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2VmY2I3NDZkYWM4NzE4NjRlNGYxOTNlYTNhYmRhNzVhYjJiN2Y1Yw==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2004-08-09T07:14:17Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-08-09T07:14:17Z"}, "message": "Makefile.in (GTFILES): Remove stmt.c\n\n2004-08-09  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* Makefile.in (GTFILES): Remove stmt.c\n\t(stmt.o): Do not depend on gt-stmt.h.\n\t* emit-rtl.c (emit_line_note): Do not call\n\tset_file_and_line_for_stmt.\n\t* expr.c (expand_expr_real_1) <SWITCH_EXPR>: Let expand_case\n\tdo everything.\n\t* function.c (free_after_parsing): Do not free STMT field.\n\t(allocate_struct_function): Do not call init_stmt_for_function.\n\t(assign_stack_temp_for_type): Do not accept values of keep\n\tother than 0 or 1.\n\t(init_temp_slots): Do not initialize removed variables.\n\t* function.h (struct function): Remove STMT, X_TARGET_TEMP_SLOT_LEVEL\n\tand X_VAR_TEMP_SLOT_LEVEL fields.\n\t* rtl.h (set_file_and_line_for_stmt): Remove.\n\t* stmt.c (struct nesting, ALLOC_NESTING, POPSTACK,\n\tstruct stmt_status, cond_stack, case_stack, nesting_stack,\n\tnesting_depth, emit_locus, set_file_and_line_for_stmt,\n\tsame_case_target_p, init_stmt_for_function, emit_nop,\n\texpand_start_cond, expand_start_elseif, expand_start_else,\n\texpand_elseif, expand_end_cond): Remove.\n\t(preserve_subexpressions_p): Remove references to CFUN->STMT.\n\t(expand_start_case, expand_end_case_type): Remove, merge into...\n\t(expand_case): ... this one, including other bits from\n\texpand_expr_real_1.  Inline same_case_target_p.  Turn members\n\tof CASE_STACK into local variables.\n\t(emit_case_bit_tests): Inline same_case_target_p.\n\t(add_case_node): Add HEAD argument, return new head of the list,\n\tdo not handle default label here.\n\t* tree.h (expand_start_cond, expand_end_cond, expand_start_else,\n\texpand_start_elseif, current_nesting_level, expand_start_case,\n\texpand_end_case_type, expand_end_case, add_case_node,\n\tinit_stmt_for_function, expand_elseif): Remove prototypes.\n\t(expand_case): Add prototype.\n\nFrom-SVN: r85712", "tree": {"sha": "f50cb79c83ac56867cb419564c6d1993a024a882", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f50cb79c83ac56867cb419564c6d1993a024a882"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7efcb746dac871864e4f193ea3abda75ab2b7f5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7efcb746dac871864e4f193ea3abda75ab2b7f5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7efcb746dac871864e4f193ea3abda75ab2b7f5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7efcb746dac871864e4f193ea3abda75ab2b7f5c/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c4d70ce3b976c161188e2aac6a4e0a1d5c05cb79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4d70ce3b976c161188e2aac6a4e0a1d5c05cb79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4d70ce3b976c161188e2aac6a4e0a1d5c05cb79"}], "stats": {"total": 560, "additions": 120, "deletions": 440}, "files": [{"sha": "06dfe4fb0a53c916e32ae2a7be737e5e5a18f1d5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7efcb746dac871864e4f193ea3abda75ab2b7f5c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7efcb746dac871864e4f193ea3abda75ab2b7f5c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7efcb746dac871864e4f193ea3abda75ab2b7f5c", "patch": "@@ -1,3 +1,39 @@\n+2004-08-09  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* Makefile.in (GTFILES): Remove stmt.c\n+\t(stmt.o): Do not depend on gt-stmt.h.\n+\t* emit-rtl.c (emit_line_note): Do not call\n+\tset_file_and_line_for_stmt.\n+\t* expr.c (expand_expr_real_1) <SWITCH_EXPR>: Let expand_case\n+\tdo everything.\n+\t* function.c (free_after_parsing): Do not free STMT field.\n+\t(allocate_struct_function): Do not call init_stmt_for_function.\n+\t(assign_stack_temp_for_type): Do not accept values of keep\n+\tother than 0 or 1.\n+\t(init_temp_slots): Do not initialize removed variables.\n+\t* function.h (struct function): Remove STMT, X_TARGET_TEMP_SLOT_LEVEL\n+\tand X_VAR_TEMP_SLOT_LEVEL fields.\n+\t* rtl.h (set_file_and_line_for_stmt): Remove.\n+\t* stmt.c (struct nesting, ALLOC_NESTING, POPSTACK,\n+\tstruct stmt_status, cond_stack, case_stack, nesting_stack,\n+\tnesting_depth, emit_locus, set_file_and_line_for_stmt,\n+\tsame_case_target_p, init_stmt_for_function, emit_nop,\n+\texpand_start_cond, expand_start_elseif, expand_start_else,\n+\texpand_elseif, expand_end_cond): Remove.\n+\t(preserve_subexpressions_p): Remove references to CFUN->STMT.\n+\t(expand_start_case, expand_end_case_type): Remove, merge into...\n+\t(expand_case): ... this one, including other bits from\n+\texpand_expr_real_1.  Inline same_case_target_p.  Turn members\n+\tof CASE_STACK into local variables.\n+\t(emit_case_bit_tests): Inline same_case_target_p.\n+\t(add_case_node): Add HEAD argument, return new head of the list,\n+\tdo not handle default label here.\n+\t* tree.h (expand_start_cond, expand_end_cond, expand_start_else,\n+\texpand_start_elseif, current_nesting_level, expand_start_case,\n+\texpand_end_case_type, expand_end_case, add_case_node,\n+\tinit_stmt_for_function, expand_elseif): Remove prototypes.\n+\t(expand_case): Add prototype.\n+\n 2004-08-09  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* expr.c (expand_expr_real_1): Use optab_for_tree_code."}, {"sha": "2bcfee4f13af83b90c9da1acdbf3a32d9cc73b20", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7efcb746dac871864e4f193ea3abda75ab2b7f5c/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7efcb746dac871864e4f193ea3abda75ab2b7f5c/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=7efcb746dac871864e4f193ea3abda75ab2b7f5c", "patch": "@@ -1809,7 +1809,7 @@ function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) \\\n    function.h insn-config.h hard-reg-set.h $(EXPR_H) libfuncs.h except.h \\\n    $(LOOP_H) $(RECOG_H) toplev.h output.h varray.h $(GGC_H) $(TM_P_H) \\\n-   langhooks.h $(PREDICT_H) gt-stmt.h $(OPTABS_H) $(TARGET_H)\n+   langhooks.h $(PREDICT_H) $(OPTABS_H) $(TARGET_H)\n except.o : except.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(FLAGS_H) except.h function.h $(EXPR_H) libfuncs.h $(INTEGRATE_H) \\\n    langhooks.h insn-config.h hard-reg-set.h $(BASIC_BLOCK_H) output.h \\\n@@ -2358,7 +2358,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/gcse.c $(srcdir)/integrate.c $(srcdir)/lists.c $(srcdir)/optabs.c \\\n   $(srcdir)/profile.c $(srcdir)/ra-build.c $(srcdir)/regclass.c \\\n   $(srcdir)/reg-stack.c $(srcdir)/cfglayout.c \\\n-  $(srcdir)/sdbout.c $(srcdir)/stmt.c $(srcdir)/stor-layout.c \\\n+  $(srcdir)/sdbout.c $(srcdir)/stor-layout.c \\\n   $(srcdir)/stringpool.c $(srcdir)/tree.c $(srcdir)/varasm.c \\\n   $(srcdir)/tree-mudflap.c $(srcdir)/tree-flow.h \\\n   $(srcdir)/c-objc-common.c $(srcdir)/c-common.c $(srcdir)/c-parse.in \\"}, {"sha": "b49ccb2f530d149a00f079e8df4de60022e498ea", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7efcb746dac871864e4f193ea3abda75ab2b7f5c/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7efcb746dac871864e4f193ea3abda75ab2b7f5c/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=7efcb746dac871864e4f193ea3abda75ab2b7f5c", "patch": "@@ -4626,8 +4626,6 @@ emit_line_note (location_t location)\n {\n   rtx note;\n   \n-  set_file_and_line_for_stmt (location);\n-  \n #ifdef USE_MAPPED_LOCATION\n   if (location == last_location)\n     return NULL_RTX;"}, {"sha": "7334c59ca39a75e172d7578668bffa4aa53fb7cc", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7efcb746dac871864e4f193ea3abda75ab2b7f5c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7efcb746dac871864e4f193ea3abda75ab2b7f5c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=7efcb746dac871864e4f193ea3abda75ab2b7f5c", "patch": "@@ -7697,7 +7697,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       goto binop;\n \n     case TRUTH_OR_EXPR:\n-      code = BIT_OR_EXPR;\n+      code = BIT_IOR_EXPR;\n     case BIT_IOR_EXPR:\n       goto binop;\n \n@@ -8144,27 +8144,7 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       abort ();\n \n     case SWITCH_EXPR:\n-      expand_start_case (SWITCH_COND (exp));\n-      /* The switch body is lowered in gimplify.c, we should never have\n-\t switches with a non-NULL SWITCH_BODY here.  */\n-      if (SWITCH_BODY (exp))\n-        abort ();\n-      if (SWITCH_LABELS (exp))\n-\t{\n-\t  tree vec = SWITCH_LABELS (exp);\n-\t  size_t i = TREE_VEC_LENGTH (vec);\n-\n-\t  do\n-\t    {\n-\t      tree elt = TREE_VEC_ELT (vec, --i);\n-\t      add_case_node (CASE_LOW (elt), CASE_HIGH (elt),\n-\t\t\t     CASE_LABEL (elt));\n-\t    }\n-\t  while (i);\n-\t}\n-      else\n-\tabort ();\n-      expand_end_case_type (SWITCH_COND (exp), TREE_TYPE (exp));\n+      expand_case (exp);\n       return const0_rtx;\n \n     case LABEL_EXPR:"}, {"sha": "ed7821b4f7b4846546646d6cc081bdcc5c6672bb", "filename": "gcc/function.c", "status": "modified", "additions": 9, "deletions": 24, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7efcb746dac871864e4f193ea3abda75ab2b7f5c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7efcb746dac871864e4f193ea3abda75ab2b7f5c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=7efcb746dac871864e4f193ea3abda75ab2b7f5c", "patch": "@@ -315,7 +315,6 @@ free_after_parsing (struct function *f)\n   /* f->eh->eh_return_stub_label is used by code generation.  */\n \n   lang_hooks.function.final (f);\n-  f->stmt = NULL;\n }\n \n /* Clear out all parts of the state in F that can safely be discarded\n@@ -589,10 +588,9 @@ make_slot_available (struct temp_slot *temp)\n \n    KEEP is 1 if this slot is to be retained after a call to\n    free_temp_slots.  Automatic variables for a block are allocated\n-   with this flag.  KEEP is 2 if we allocate a longer term temporary,\n-   whose lifetime is controlled by CLEANUP_POINT_EXPRs.  KEEP is 3\n-   if we are to allocate something at an inner level to be treated as\n-   a variable in the block (e.g., a SAVE_EXPR).\n+   with this flag.  KEEP values of 2 or 3 were needed respectively\n+   for variables whose lifetime is controlled by CLEANUP_POINT_EXPRs\n+   or for SAVE_EXPRs, but they are now unused and will abort.\n \n    TYPE is the type that will be used for the stack slot.  */\n \n@@ -609,6 +607,10 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size, int keep\n   if (size == -1)\n     abort ();\n \n+  /* These are now unused.  */\n+  if (keep > 1)\n+    abort ();\n+\n   if (mode == BLKmode)\n     align = BIGGEST_ALIGNMENT;\n   else\n@@ -733,22 +735,8 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size, int keep\n   p->in_use = 1;\n   p->addr_taken = 0;\n   p->type = type;\n-\n-  if (keep == 2)\n-    {\n-      p->level = target_temp_slot_level;\n-      p->keep = 1;\n-    }\n-  else if (keep == 3)\n-    {\n-      p->level = var_temp_slot_level;\n-      p->keep = 0;\n-    }\n-  else\n-    {\n-      p->level = temp_slot_level;\n-      p->keep = keep;\n-    }\n+  p->level = temp_slot_level;\n+  p->keep = keep;\n \n   pp = temp_slots_at_level (p->level);\n   insert_slot_to_list (p, pp);\n@@ -1190,8 +1178,6 @@ init_temp_slots (void)\n   avail_temp_slots = 0;\n   used_temp_slots = 0;\n   temp_slot_level = 0;\n-  var_temp_slot_level = 0;\n-  target_temp_slot_level = 0;\n }\n \f\n /* These routines are responsible for converting virtual register references\n@@ -3784,7 +3770,6 @@ allocate_struct_function (tree fndecl)\n \n   cfun->function_frequency = FUNCTION_FREQUENCY_NORMAL;\n \n-  init_stmt_for_function ();\n   init_eh_for_function ();\n \n   lang_hooks.function.init (cfun);"}, {"sha": "0c1ca1aba5f351045dd53eca0aa08a7d74997076", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7efcb746dac871864e4f193ea3abda75ab2b7f5c/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7efcb746dac871864e4f193ea3abda75ab2b7f5c/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=7efcb746dac871864e4f193ea3abda75ab2b7f5c", "patch": "@@ -162,7 +162,6 @@ struct expr_status GTY(())\n struct function GTY(())\n {\n   struct eh_status *eh;\n-  struct stmt_status *stmt;\n   struct expr_status *expr;\n   struct emit_status *emit;\n   struct varasm_status *varasm;\n@@ -276,15 +275,6 @@ struct function GTY(())\n   /* Current nesting level for temporaries.  */\n   int x_temp_slot_level;\n \n-  /* Current nesting level for variables in a block.  */\n-  int x_var_temp_slot_level;\n-\n-  /* When temporaries are created by TARGET_EXPRs, they are created at\n-     this level of temp_slot_level, so that they can remain allocated\n-     until no longer needed.  CLEANUP_POINT_EXPRs define the lifetime\n-     of TARGET_EXPRs.  */\n-  int x_target_temp_slot_level;\n-\n   /* This slot is initialized as 0 and is added to\n      during the nested function.  */\n   struct var_refs_queue *fixup_var_refs_queue;\n@@ -492,8 +482,6 @@ extern int trampolines_created;\n #define used_temp_slots (cfun->x_used_temp_slots)\n #define avail_temp_slots (cfun->x_avail_temp_slots)\n #define temp_slot_level (cfun->x_temp_slot_level)\n-#define target_temp_slot_level (cfun->x_target_temp_slot_level)\n-#define var_temp_slot_level (cfun->x_var_temp_slot_level)\n #define nonlocal_labels (cfun->x_nonlocal_labels)\n #define nonlocal_goto_handler_labels (cfun->x_nonlocal_goto_handler_labels)\n "}, {"sha": "fdff2f65b36263fdc32d0a5af9e9d7183138b403", "filename": "gcc/rtl.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7efcb746dac871864e4f193ea3abda75ab2b7f5c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7efcb746dac871864e4f193ea3abda75ab2b7f5c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=7efcb746dac871864e4f193ea3abda75ab2b7f5c", "patch": "@@ -2236,7 +2236,6 @@ extern void mark_temp_addr_taken (rtx);\n extern void update_temp_slot_address (rtx, rtx);\n \n /* In stmt.c */\n-extern void set_file_and_line_for_stmt (location_t);\n extern void expand_null_return (void);\n extern void expand_naked_return (void);\n extern void emit_jump (rtx);"}, {"sha": "8164c2d269f53b2d3010bed20710efbd4fe14aaf", "filename": "gcc/stmt.c", "status": "modified", "additions": 70, "deletions": 364, "changes": 434, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7efcb746dac871864e4f193ea3abda75ab2b7f5c/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7efcb746dac871864e4f193ea3abda75ab2b7f5c/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=7efcb746dac871864e4f193ea3abda75ab2b7f5c", "patch": "@@ -21,17 +21,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* This file handles the generation of rtl code from tree structure\n    above the level of expressions, using subroutines in exp*.c and emit-rtl.c.\n-   It also creates the rtl expressions for parameters and auto variables\n-   and has full responsibility for allocating stack slots.\n-\n    The functions whose names start with `expand_' are called by the\n-   parser to generate RTL instructions for various kinds of constructs.\n-\n-   Some control and binding constructs require calling several such\n-   functions at different times.  For example, a simple if-then\n-   is expanded by calling `expand_start_cond' (with the condition-expression\n-   as argument) before parsing the then-clause and calling `expand_end_cond'\n-   after parsing the then-clause.  */\n+   expander to generate RTL instructions for various kinds of constructs.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -113,123 +104,6 @@ static int cost_table_initialized;\n    is unsigned.  */\n #define COST_TABLE(I)  cost_table_[(unsigned HOST_WIDE_INT) ((I) + 1)]\n \f\n-/* Stack of control and binding constructs we are currently inside.\n-\n-   These constructs begin when you call `expand_start_WHATEVER'\n-   and end when you call `expand_end_WHATEVER'.  This stack records\n-   info about how the construct began that tells the end-function\n-   what to do.  It also may provide information about the construct\n-   to alter the behavior of other constructs within the body.\n-   For example, they may affect the behavior of C `break' and `continue'.\n-\n-   Each construct gets one `struct nesting' object.\n-   All of these objects are chained through the `all' field.\n-   `nesting_stack' points to the first object (innermost construct).\n-   The position of an entry on `nesting_stack' is in its `depth' field.\n-\n-   Each type of construct has its own individual stack.\n-   For example, loops have `cond_stack'.  Each object points to the\n-   next object of the same type through the `next' field.\n-\n-   Some constructs are visible to `break' exit-statements and others\n-   are not.  Which constructs are visible depends on the language.\n-   Therefore, the data structure allows each construct to be visible\n-   or not, according to the args given when the construct is started.\n-   The construct is visible if the `exit_label' field is non-null.\n-   In that case, the value should be a CODE_LABEL rtx.  */\n-\n-struct nesting GTY(())\n-{\n-  struct nesting *all;\n-  struct nesting *next;\n-  int depth;\n-  rtx exit_label;\n-  enum nesting_desc {\n-    COND_NESTING,\n-    BLOCK_NESTING,\n-    CASE_NESTING\n-  } desc;\n-  union nesting_u\n-    {\n-      /* For conds (if-then and if-then-else statements).  */\n-      struct nesting_cond\n-\t{\n-\t  /* Label for the end of the if construct.\n-\t     There is none if EXITFLAG was not set\n-\t     and no `else' has been seen yet.  */\n-\t  rtx endif_label;\n-\t  /* Label for the end of this alternative.\n-\t     This may be the end of the if or the next else/elseif.  */\n-\t  rtx next_label;\n-\t} GTY ((tag (\"COND_NESTING\"))) cond;\n-      /* For switch (C) or case (Pascal) statements.  */\n-      struct nesting_case\n-\t{\n-\t  /* The insn after which the case dispatch should finally\n-\t     be emitted.  Zero for a dummy.  */\n-\t  rtx start;\n-\t  /* A list of case labels; it is first built as an AVL tree.\n-\t     During expand_end_case, this is converted to a list, and may be\n-\t     rearranged into a nearly balanced binary tree.  */\n-\t  struct case_node *case_list;\n-\t  /* Label to jump to if no case matches.  */\n-\t  tree default_label;\n-\t  /* The expression to be dispatched on.  */\n-\t  tree index_expr;\n-\t} GTY ((tag (\"CASE_NESTING\"))) case_stmt;\n-    } GTY ((desc (\"%1.desc\"))) data;\n-};\n-\n-/* Allocate and return a new `struct nesting'.  */\n-\n-#define ALLOC_NESTING() ggc_alloc (sizeof (struct nesting))\n-\n-/* Pop the nesting stack element by element until we pop off\n-   the element which is at the top of STACK.\n-   Update all the other stacks, popping off elements from them\n-   as we pop them from nesting_stack.  */\n-\n-#define POPSTACK(STACK)\t\t\t\t\t\\\n-do { struct nesting *target = STACK;\t\t\t\\\n-     struct nesting *this;\t\t\t\t\\\n-     do { this = nesting_stack;\t\t\t\t\\\n-\t  if (cond_stack == this)\t\t\t\\\n-\t    cond_stack = cond_stack->next;\t\t\\\n-\t  if (case_stack == this)\t\t\t\\\n-\t    case_stack = case_stack->next;\t\t\\\n-\t  nesting_depth = nesting_stack->depth - 1;\t\\\n-\t  nesting_stack = this->all; }\t\t\t\\\n-     while (this != target); } while (0)\n-\f\n-\n-struct stmt_status GTY(())\n-{\n-  /* If any new stacks are added here, add them to POPSTACKS too.  */\n-\n-  /* Chain of all pending conditional statements.  */\n-  struct nesting * x_cond_stack;\n-\n-  /* Chain of all pending case or switch statements.  */\n-  struct nesting * x_case_stack;\n-\n-  /* Separate chain including all of the above,\n-     chained through the `all' field.  */\n-  struct nesting * x_nesting_stack;\n-\n-  /* Number of entries on nesting_stack now.  */\n-  int x_nesting_depth;\n-\n-  /* Location of last line-number note, whether we actually\n-     emitted it or not.  */\n-  location_t x_emit_locus;\n-};\n-\n-#define cond_stack (cfun->stmt->x_cond_stack)\n-#define case_stack (cfun->stmt->x_case_stack)\n-#define nesting_stack (cfun->stmt->x_nesting_stack)\n-#define nesting_depth (cfun->stmt->x_nesting_depth)\n-#define emit_locus (cfun->stmt->x_emit_locus)\n-\n static int n_occurrences (int, const char *);\n static bool decl_conflicts_with_clobbers_p (tree, const HARD_REG_SET);\n static void expand_nl_goto_receiver (void);\n@@ -241,7 +115,6 @@ static rtx shift_return_value (rtx);\n static void expand_value_return (rtx);\n static void do_jump_if_equal (rtx, rtx, rtx, int);\n static int estimate_case_costs (case_node_ptr);\n-static bool same_case_target_p (rtx, rtx);\n static bool lshift_cheap_p (void);\n static int case_bit_test_cmp (const void *, const void *);\n static void emit_case_bit_tests (tree, tree, tree, tree, case_node_ptr, rtx);\n@@ -250,39 +123,8 @@ static int node_has_low_bound (case_node_ptr, tree);\n static int node_has_high_bound (case_node_ptr, tree);\n static int node_is_bounded (case_node_ptr, tree);\n static void emit_case_nodes (rtx, case_node_ptr, rtx, tree);\n-\f\n-void\n-init_stmt_for_function (void)\n-{\n-  cfun->stmt = ggc_alloc_cleared (sizeof (struct stmt_status));\n-}\n-\f\n-/* Record the current file and line.  Called from emit_line_note.  */\n+static struct case_node *add_case_node (struct case_node *, tree, tree, tree);\n \n-void\n-set_file_and_line_for_stmt (location_t location)\n-{\n-  /* If we're outputting an inline function, and we add a line note,\n-     there may be no CFUN->STMT information.  So, there's no need to\n-     update it.  */\n-  if (cfun->stmt)\n-    emit_locus = location;\n-}\n-\n-/* Emit a no-op instruction.  */\n-\n-void\n-emit_nop (void)\n-{\n-  rtx last_insn;\n-\n-  last_insn = get_last_insn ();\n-  if (!optimize\n-      && (LABEL_P (last_insn)\n-\t  || (NOTE_P (last_insn)\n-\t      && prev_real_insn (last_insn) == 0)))\n-    emit_insn (gen_nop ());\n-}\n \f\n /* Return the rtx-label that corresponds to a LABEL_DECL,\n    creating it if necessary.  */\n@@ -1650,104 +1492,14 @@ warn_if_unused_value (tree exp, location_t locus)\n     }\n }\n \f\n-/* Generate RTL for the start of an if-then.  COND is the expression\n-   whose truth should be tested.\n-\n-   If EXITFLAG is nonzero, this conditional is visible to\n-   `exit_something'.  */\n-\n-void\n-expand_start_cond (tree cond, int exitflag)\n-{\n-  struct nesting *thiscond = ALLOC_NESTING ();\n-\n-  /* Make an entry on cond_stack for the cond we are entering.  */\n-\n-  thiscond->desc = COND_NESTING;\n-  thiscond->next = cond_stack;\n-  thiscond->all = nesting_stack;\n-  thiscond->depth = ++nesting_depth;\n-  thiscond->data.cond.next_label = gen_label_rtx ();\n-  /* Before we encounter an `else', we don't need a separate exit label\n-     unless there are supposed to be exit statements\n-     to exit this conditional.  */\n-  thiscond->exit_label = exitflag ? gen_label_rtx () : 0;\n-  thiscond->data.cond.endif_label = thiscond->exit_label;\n-  cond_stack = thiscond;\n-  nesting_stack = thiscond;\n-\n-  do_jump (cond, thiscond->data.cond.next_label, NULL_RTX);\n-}\n-\n-/* Generate RTL between then-clause and the elseif-clause\n-   of an if-then-elseif-....  */\n-\n-void\n-expand_start_elseif (tree cond)\n-{\n-  if (cond_stack->data.cond.endif_label == 0)\n-    cond_stack->data.cond.endif_label = gen_label_rtx ();\n-  emit_jump (cond_stack->data.cond.endif_label);\n-  emit_label (cond_stack->data.cond.next_label);\n-  cond_stack->data.cond.next_label = gen_label_rtx ();\n-  do_jump (cond, cond_stack->data.cond.next_label, NULL_RTX);\n-}\n-\n-/* Generate RTL between the then-clause and the else-clause\n-   of an if-then-else.  */\n-\n-void\n-expand_start_else (void)\n-{\n-  if (cond_stack->data.cond.endif_label == 0)\n-    cond_stack->data.cond.endif_label = gen_label_rtx ();\n-\n-  emit_jump (cond_stack->data.cond.endif_label);\n-  emit_label (cond_stack->data.cond.next_label);\n-  cond_stack->data.cond.next_label = 0;  /* No more _else or _elseif calls.  */\n-}\n-\n-/* After calling expand_start_else, turn this \"else\" into an \"else if\"\n-   by providing another condition.  */\n-\n-void\n-expand_elseif (tree cond)\n-{\n-  cond_stack->data.cond.next_label = gen_label_rtx ();\n-  do_jump (cond, cond_stack->data.cond.next_label, NULL_RTX);\n-}\n-\n-/* Generate RTL for the end of an if-then.\n-   Pop the record for it off of cond_stack.  */\n-\n-void\n-expand_end_cond (void)\n-{\n-  struct nesting *thiscond = cond_stack;\n-\n-  do_pending_stack_adjust ();\n-  if (thiscond->data.cond.next_label)\n-    emit_label (thiscond->data.cond.next_label);\n-  if (thiscond->data.cond.endif_label)\n-    emit_label (thiscond->data.cond.endif_label);\n-\n-  POPSTACK (cond_stack);\n-}\n-\f\n /* Return nonzero if we should preserve sub-expressions as separate\n    pseudos.  We never do so if we aren't optimizing.  We always do so\n    if -fexpensive-optimizations.  */\n \n int\n preserve_subexpressions_p (void)\n {\n-  if (flag_expensive_optimizations)\n-    return 1;\n-\n-  if (optimize == 0 || cfun == 0 || cfun->stmt == 0)\n-    return 0;\n-\n-  return 1;\n+  return optimize && (cfun || flag_expensive_optimizations);\n }\n \n \f\n@@ -2451,54 +2203,13 @@ expand_anon_union_decl (tree decl, tree cleanup ATTRIBUTE_UNUSED,\n     }\n }\n \f\n-/* Enter a case (Pascal) or switch (C) statement.\n-   Push a block onto case_stack and nesting_stack\n-   to accumulate the case-labels that are seen\n-   and to record the labels generated for the statement.\n-\n-   EXIT_FLAG is nonzero if `exit_something' should exit this case stmt.\n-   Otherwise, this construct is transparent for `exit_something'.\n-\n-   EXPR is the index-expression to be dispatched on.\n-   TYPE is its nominal type.  We could simply convert EXPR to this type,\n-   but instead we take short cuts.  */\n-\n-void\n-expand_start_case (tree index_expr)\n-{\n-  struct nesting *thiscase = ALLOC_NESTING ();\n-\n-  /* Make an entry on case_stack for the case we are entering.  */\n-\n-  thiscase->desc = CASE_NESTING;\n-  thiscase->next = case_stack;\n-  thiscase->all = nesting_stack;\n-  thiscase->depth = ++nesting_depth;\n-  thiscase->exit_label = 0;\n-  thiscase->data.case_stmt.case_list = 0;\n-  thiscase->data.case_stmt.index_expr = index_expr;\n-  thiscase->data.case_stmt.default_label = 0;\n-  case_stack = thiscase;\n-  nesting_stack = thiscase;\n-\n-  do_pending_stack_adjust ();\n-\n-  /* Make sure case_stmt.start points to something that won't\n-     need any transformation before expand_end_case.  */\n-  if (!NOTE_P (get_last_insn ()))\n-    emit_note (NOTE_INSN_DELETED);\n-\n-  thiscase->data.case_stmt.start = get_last_insn ();\n-}\n-\n-/* Do the insertion of a case label into\n-   case_stack->data.case_stmt.case_list.  The labels are fed to us\n-   in descending order from the sorted vector of case labels used\n+/* Do the insertion of a case label into case_list.  The labels are\n+   fed to us in descending order from the sorted vector of case labels used\n    in the tree part of the middle end.  So the list we construct is\n    sorted in ascending order.  */\n \n-void\n-add_case_node (tree low, tree high, tree label)\n+struct case_node *\n+add_case_node (struct case_node *head, tree low, tree high, tree label)\n {\n   struct case_node *r;\n \n@@ -2509,25 +2220,14 @@ add_case_node (tree low, tree high, tree label)\n   if (!high || tree_int_cst_equal (low, high))\n     high = low;\n \n-  /* Handle default labels specially.  */\n-  if (!high && !low)\n-    {\n-#ifdef ENABLE_CHECKING\n-      if (case_stack->data.case_stmt.default_label != 0)\n-\tabort ();\n-#endif\n-      case_stack->data.case_stmt.default_label = label;\n-      return;\n-    }\n-\n   /* Add this label to the chain.  */\n   r = ggc_alloc (sizeof (struct case_node));\n   r->low = low;\n   r->high = high;\n   r->code_label = label;\n   r->parent = r->left = NULL;\n-  r->right = case_stack->data.case_stmt.case_list;\n-  case_stack->data.case_stmt.case_list = r;\n+  r->right = head;\n+  return r;\n }\n \f\n /* Maximum number of case bit tests.  */\n@@ -2618,7 +2318,7 @@ emit_case_bit_tests (tree index_type, tree index_expr, tree minval,\n     {\n       label = label_rtx (n->code_label);\n       for (i = 0; i < count; i++)\n-\tif (same_case_target_p (label, test[i].label))\n+\tif (label == test[i].label)\n \t  break;\n \n       if (i == count)\n@@ -2689,7 +2389,7 @@ emit_case_bit_tests (tree index_type, tree index_expr, tree minval,\n    Generate the code to test it and jump to the right place.  */\n \n void\n-expand_end_case_type (tree orig_index, tree orig_type)\n+expand_case (tree exp)\n {\n   tree minval = NULL_TREE, maxval = NULL_TREE, range = NULL_TREE;\n   rtx default_label = 0;\n@@ -2701,42 +2401,68 @@ expand_end_case_type (tree orig_index, tree orig_type)\n   rtx *labelvec;\n   int i;\n   rtx before_case, end, lab;\n-  struct nesting *thiscase = case_stack;\n-  tree index_expr, index_type;\n-  bool exit_done = false;\n-  int unsignedp;\n \n-  /* Don't crash due to previous errors.  */\n-  if (thiscase == NULL)\n-    return;\n+  tree vec = SWITCH_LABELS (exp);\n+  tree orig_type = TREE_TYPE (exp);\n+  tree index_expr = SWITCH_COND (exp);\n+  tree index_type = TREE_TYPE (index_expr);\n+  int unsignedp = TYPE_UNSIGNED (index_type);\n+\n+  /* The insn after which the case dispatch should finally\n+     be emitted.  Zero for a dummy.  */\n+  rtx start;\n+\n+  /* A list of case labels; it is first built as a list and it may then\n+     be rearranged into a nearly balanced binary tree.  */\n+  struct case_node *case_list = 0;\n+\n+  /* Label to jump to if no case matches.  */\n+  tree default_label_decl = 0;\n+\n+  /* The switch body is lowered in gimplify.c, we should never have\n+     switches with a non-NULL SWITCH_BODY here.  */\n+  if (SWITCH_BODY (exp) || !SWITCH_LABELS (exp))\n+    abort ();\n \n-  index_expr = thiscase->data.case_stmt.index_expr;\n-  index_type = TREE_TYPE (index_expr);\n-  unsignedp = TYPE_UNSIGNED (index_type);\n-  if (orig_type == NULL)\n-    orig_type = TREE_TYPE (orig_index);\n+  for (i = TREE_VEC_LENGTH (vec); --i >= 0; )\n+    {\n+      tree elt = TREE_VEC_ELT (vec, i);\n+\n+      /* Handle default labels specially.  */\n+      if (!CASE_HIGH (elt) && !CASE_LOW (elt))\n+\t{\n+#ifdef ENABLE_CHECKING\n+          if (default_label_decl != 0)\n+            abort ();\n+#endif\n+          default_label_decl = CASE_LABEL (elt);\n+        }\n+      else\n+        case_list = add_case_node (case_list, CASE_LOW (elt), CASE_HIGH (elt),\n+\t\t                   CASE_LABEL (elt));\n+    }\n \n   do_pending_stack_adjust ();\n \n+  /* Make sure start points to something that won't need any transformation\n+     before the end of this function.  */\n+  if (!NOTE_P (get_last_insn ()))\n+    emit_note (NOTE_INSN_DELETED);\n+\n+  start = get_last_insn ();\n+\n   /* An ERROR_MARK occurs for various reasons including invalid data type.  */\n   if (index_type != error_mark_node)\n     {\n       /* If we don't have a default-label, create one here,\n \t after the body of the switch.  */\n-      if (thiscase->data.case_stmt.default_label == 0)\n+      if (default_label_decl == 0)\n \t{\n-\t  thiscase->data.case_stmt.default_label\n+\t  default_label_decl\n \t    = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-\t  /* Share the exit label if possible.  */\n-          if (thiscase->exit_label)\n-\t    {\n-\t      SET_DECL_RTL (thiscase->data.case_stmt.default_label,\n-\t\t\t    thiscase->exit_label);\n-\t      exit_done = true;\n-\t    }\n-\t  expand_label (thiscase->data.case_stmt.default_label);\n+\t  expand_label (default_label_decl);\n \t}\n-      default_label = label_rtx (thiscase->data.case_stmt.default_label);\n+      default_label = label_rtx (default_label_decl);\n \n       before_case = get_last_insn ();\n \n@@ -2745,7 +2471,7 @@ expand_end_case_type (tree orig_index, tree orig_type)\n \n       uniq = 0;\n       count = 0;\n-      for (n = thiscase->data.case_stmt.case_list; n; n = n->right)\n+      for (n = case_list; n; n = n->right)\n \t{\n \t  /* Check low and high label values are integers.  */\n \t  if (TREE_CODE (n->low) != INTEGER_CST)\n@@ -2777,8 +2503,8 @@ expand_end_case_type (tree orig_index, tree orig_type)\n \t  /* Count the number of unique case node targets.  */\n           uniq++;\n \t  lab = label_rtx (n->code_label);\n-          for (m = thiscase->data.case_stmt.case_list; m != n; m = m->right)\n-            if (same_case_target_p (label_rtx (m->code_label), lab))\n+          for (m = case_list; m != n; m = m->right)\n+            if (label_rtx (m->code_label) == lab)\n               {\n                 uniq--;\n                 break;\n@@ -2817,8 +2543,7 @@ expand_end_case_type (tree orig_index, tree orig_type)\n \t      range = maxval;\n \t    }\n \t  emit_case_bit_tests (index_type, index_expr, minval, range,\n-\t\t\t       thiscase->data.case_stmt.case_list,\n-\t\t\t       default_label);\n+\t\t\t       case_list, default_label);\n \t}\n \n       /* If range of values is much bigger than number of values,\n@@ -2882,7 +2607,7 @@ expand_end_case_type (tree orig_index, tree orig_type)\n \t\t target code.  The job of removing any unreachable\n \t\t code is left to the optimization phase if the\n \t\t \"-O\" option is specified.  */\n-\t      for (n = thiscase->data.case_stmt.case_list; n; n = n->right)\n+\t      for (n = case_list; n; n = n->right)\n \t\tif (! tree_int_cst_lt (index_expr, n->low)\n \t\t    && ! tree_int_cst_lt (n->high, index_expr))\n \t\t  break;\n@@ -2910,10 +2635,9 @@ expand_end_case_type (tree orig_index, tree orig_type)\n \n \t      use_cost_table\n \t\t= (TREE_CODE (orig_type) != ENUMERAL_TYPE\n-\t\t   && estimate_case_costs (thiscase->data.case_stmt.case_list));\n-\t      balance_case_nodes (&thiscase->data.case_stmt.case_list, NULL);\n-\t      emit_case_nodes (index, thiscase->data.case_stmt.case_list,\n-\t\t\t       default_label, index_type);\n+\t\t   && estimate_case_costs (case_list));\n+\t      balance_case_nodes (&case_list, NULL);\n+\t      emit_case_nodes (index, case_list, default_label, index_type);\n \t      emit_jump (default_label);\n \t    }\n \t}\n@@ -2946,7 +2670,7 @@ expand_end_case_type (tree orig_index, tree orig_type)\n \t  labelvec = alloca (ncases * sizeof (rtx));\n \t  memset (labelvec, 0, ncases * sizeof (rtx));\n \n-\t  for (n = thiscase->data.case_stmt.case_list; n; n = n->right)\n+\t  for (n = case_list; n; n = n->right)\n \t    {\n \t      /* Compute the low and high bounds relative to the minimum\n \t\t value since that should fit in a HOST_WIDE_INT while the\n@@ -2995,15 +2719,9 @@ expand_end_case_type (tree orig_index, tree orig_type)\n       end = get_last_insn ();\n       if (squeeze_notes (&before_case, &end))\n \tabort ();\n-      reorder_insns (before_case, end,\n-\t\t     thiscase->data.case_stmt.start);\n+      reorder_insns (before_case, end, start);\n     }\n \n-  if (thiscase->exit_label && !exit_done)\n-    emit_label (thiscase->exit_label);\n-\n-  POPSTACK (case_stack);\n-\n   free_temp_slots ();\n }\n \n@@ -3103,16 +2821,6 @@ estimate_case_costs (case_node_ptr node)\n   return 1;\n }\n \n-/* Determine whether two case labels branch to the same target.\n-   Since we now do tree optimizations, just comparing labels is\n-   good enough.  */\n-\n-static bool\n-same_case_target_p (rtx l1, rtx l2)\n-{\n-  return l1 == l2;\n-}\n-\n /* Take an ordered list of case nodes\n    and transform them into a near optimal binary tree,\n    on the assumption that any target code selection value is as\n@@ -3745,5 +3453,3 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t}\n     }\n }\n-\n-#include \"gt-stmt.h\""}, {"sha": "2b71b3930651dab536d8c31e940d46a9b82a1cc1", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7efcb746dac871864e4f193ea3abda75ab2b7f5c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7efcb746dac871864e4f193ea3abda75ab2b7f5c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=7efcb746dac871864e4f193ea3abda75ab2b7f5c", "patch": "@@ -3352,23 +3352,13 @@ extern void expand_decl_init (tree);\n extern void expand_label (tree);\n extern void expand_goto (tree);\n extern void expand_asm (tree, int);\n-extern void expand_start_cond (tree, int);\n-extern void expand_end_cond (void);\n-extern void expand_start_else (void);\n-extern void expand_start_elseif (tree);\n \n extern void expand_stack_alloc (tree, tree);\n extern rtx expand_stack_save (void);\n extern void expand_stack_restore (tree);\n extern void expand_return (tree);\n extern int is_body_block (tree);\n \n-extern struct nesting * current_nesting_level (void);\n-extern void expand_start_case (tree);\n-extern void expand_end_case_type (tree, tree);\n-#define expand_end_case(cond) expand_end_case_type (cond, NULL)\n-extern void add_case_node (tree, tree, tree);\n-\n /* In tree-eh.c */\n extern void using_eh_for_cleanups (void);\n \n@@ -3619,7 +3609,6 @@ extern void notice_global_symbol (tree);\n extern void set_user_assembler_name (tree, const char *);\n \n /* In stmt.c */\n-extern void emit_nop (void);\n extern void expand_computed_goto (tree);\n extern bool parse_output_constraint (const char **, int, int, int,\n \t\t\t\t     bool *, bool *, bool *);\n@@ -3629,8 +3618,7 @@ extern void expand_asm_operands (tree, tree, tree, tree, int, location_t);\n extern void expand_asm_expr (tree);\n extern bool asm_op_is_mem_input (tree, tree);\n extern tree resolve_asm_operand_names (tree, tree, tree);\n-extern void init_stmt_for_function (void);\n-extern void expand_elseif (tree);\n+extern void expand_case (tree);\n extern void expand_decl (tree);\n extern void expand_anon_union_decl (tree, tree, tree);\n "}]}