{"sha": "a187edd2b437fc9571d57f771a624963fcce08f8", "node_id": "C_kwDOANBUbNoAKGExODdlZGQyYjQzN2ZjOTU3MWQ1N2Y3NzFhNjI0OTYzZmNjZTA4Zjg", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-12-10T08:58:52Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-12-28T10:05:28Z"}, "message": "driver: Improve option diagnostics [PR103465]\n\nIt happens that options are parsed and various diagnostics happen\nin finish_options. That's a proper place as the function is also called\nfor optimize/target attributes (pragmas). However, it is possible that\ntarget overwrites an option from command line and so the diagnostics\ndoes not happen. That's fixed in the patch.\n\n- options are parsed and finish_options is called:\n\n  if (opts->x_flag_unwind_tables\n      && !targetm_common.unwind_tables_default\n      && opts->x_flag_reorder_blocks_and_partition\n      && (ui_except == UI_SJLJ || ui_except >= UI_TARGET))\n    {\n      if (opts_set->x_flag_reorder_blocks_and_partition)\n        inform (loc,\n\t\t\"%<-freorder-blocks-and-partition%> does not support \"\n\t\t\"unwind info on this architecture\");\n      opts->x_flag_reorder_blocks_and_partition = 0;\n      opts->x_flag_reorder_blocks = 1;\n    }\n\nIt's not triggered because of opts->x_flag_unwind_tables is false by default, but\nthe option is overwritten in target:\n\n...\n  if (TARGET_64BIT_P (opts->x_ix86_isa_flags))\n    {\n      if (opts->x_optimize >= 1)\n\tSET_OPTION_IF_UNSET (opts, opts_set, flag_omit_frame_pointer,\n\t\t\t     !USE_IX86_FRAME_POINTER);\n      if (opts->x_flag_asynchronous_unwind_tables\n\t  && TARGET_64BIT_MS_ABI)\n\tSET_OPTION_IF_UNSET (opts, opts_set, flag_unwind_tables, 1);\n...\n\n\tPR driver/103465\n\ngcc/ChangeLog:\n\n\t* opts.c (finish_options): More part of diagnostics to ...\n\t(diagnose_options): ... here. Call the function from both\n\tfinish_options and process_options.\n\t* opts.h (diagnose_options): Declare.\n\t* toplev.c (process_options): Call diagnose_options.", "tree": {"sha": "83c77c68b2e65bf43d69b0c319bef974636d14fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83c77c68b2e65bf43d69b0c319bef974636d14fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a187edd2b437fc9571d57f771a624963fcce08f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a187edd2b437fc9571d57f771a624963fcce08f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a187edd2b437fc9571d57f771a624963fcce08f8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a187edd2b437fc9571d57f771a624963fcce08f8/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "786973ce33dfbbd1fe64e16654dbe5881c9b1ebf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/786973ce33dfbbd1fe64e16654dbe5881c9b1ebf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/786973ce33dfbbd1fe64e16654dbe5881c9b1ebf"}], "stats": {"total": 129, "additions": 72, "deletions": 57}, "files": [{"sha": "e4e47ff77b3d7144ab15aca05ab7457a7d435539", "filename": "gcc/opts.c", "status": "modified", "additions": 68, "deletions": 57, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a187edd2b437fc9571d57f771a624963fcce08f8/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a187edd2b437fc9571d57f771a624963fcce08f8/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=a187edd2b437fc9571d57f771a624963fcce08f8", "patch": "@@ -1014,8 +1014,6 @@ void\n finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n \t\tlocation_t loc)\n {\n-  enum unwind_info_type ui_except;\n-\n   if (opts->x_dump_base_name\n       && ! opts->x_dump_base_name_prefixed)\n     {\n@@ -1116,61 +1114,6 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n       opts->x_flag_no_inline = 1;\n     }\n \n-  /* The optimization to partition hot and cold basic blocks into separate\n-     sections of the .o and executable files does not work (currently)\n-     with exception handling.  This is because there is no support for\n-     generating unwind info.  If opts->x_flag_exceptions is turned on\n-     we need to turn off the partitioning optimization.  */\n-\n-  ui_except = targetm_common.except_unwind_info (opts);\n-\n-  if (opts->x_flag_exceptions\n-      && opts->x_flag_reorder_blocks_and_partition\n-      && (ui_except == UI_SJLJ || ui_except >= UI_TARGET))\n-    {\n-      if (opts_set->x_flag_reorder_blocks_and_partition)\n-        inform (loc,\n-\t\t\"%<-freorder-blocks-and-partition%> does not work \"\n-\t\t\"with exceptions on this architecture\");\n-      opts->x_flag_reorder_blocks_and_partition = 0;\n-      opts->x_flag_reorder_blocks = 1;\n-    }\n-\n-  /* If user requested unwind info, then turn off the partitioning\n-     optimization.  */\n-\n-  if (opts->x_flag_unwind_tables\n-      && !targetm_common.unwind_tables_default\n-      && opts->x_flag_reorder_blocks_and_partition\n-      && (ui_except == UI_SJLJ || ui_except >= UI_TARGET))\n-    {\n-      if (opts_set->x_flag_reorder_blocks_and_partition)\n-        inform (loc,\n-\t\t\"%<-freorder-blocks-and-partition%> does not support \"\n-\t\t\"unwind info on this architecture\");\n-      opts->x_flag_reorder_blocks_and_partition = 0;\n-      opts->x_flag_reorder_blocks = 1;\n-    }\n-\n-  /* If the target requested unwind info, then turn off the partitioning\n-     optimization with a different message.  Likewise, if the target does not\n-     support named sections.  */\n-\n-  if (opts->x_flag_reorder_blocks_and_partition\n-      && (!targetm_common.have_named_sections\n-\t  || (opts->x_flag_unwind_tables\n-\t      && targetm_common.unwind_tables_default\n-\t      && (ui_except == UI_SJLJ || ui_except >= UI_TARGET))))\n-    {\n-      if (opts_set->x_flag_reorder_blocks_and_partition)\n-        inform (loc,\n-\t\t\"%<-freorder-blocks-and-partition%> does not work \"\n-\t\t\"on this architecture\");\n-      opts->x_flag_reorder_blocks_and_partition = 0;\n-      opts->x_flag_reorder_blocks = 1;\n-    }\n-\n-\n   /* Pipelining of outer loops is only possible when general pipelining\n      capabilities are requested.  */\n   if (!opts->x_flag_sel_sched_pipelining)\n@@ -1406,6 +1349,74 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n \t && debug_info_level >= DINFO_LEVEL_NORMAL\n \t && dwarf_debuginfo_p ()\n \t && !(flag_selective_scheduling || flag_selective_scheduling2));\n+\n+  diagnose_options (opts, opts_set, loc);\n+}\n+\n+/* The function diagnoses incompatible combinations for provided options\n+   (OPTS and OPTS_SET) at a given LOCation.  The function is called both\n+   when command line is parsed (after the target optimization hook) and\n+   when an optimize/target attribute (or pragma) is used.  */\n+\n+void diagnose_options (gcc_options *opts, gcc_options *opts_set,\n+\t\t       location_t loc)\n+{\n+  /* The optimization to partition hot and cold basic blocks into separate\n+     sections of the .o and executable files does not work (currently)\n+     with exception handling.  This is because there is no support for\n+     generating unwind info.  If opts->x_flag_exceptions is turned on\n+     we need to turn off the partitioning optimization.  */\n+\n+  enum unwind_info_type ui_except\n+    = targetm_common.except_unwind_info (opts);\n+\n+  if (opts->x_flag_exceptions\n+      && opts->x_flag_reorder_blocks_and_partition\n+      && (ui_except == UI_SJLJ || ui_except >= UI_TARGET))\n+    {\n+      if (opts_set->x_flag_reorder_blocks_and_partition)\n+\tinform (loc,\n+\t\t\"%<-freorder-blocks-and-partition%> does not work \"\n+\t\t\"with exceptions on this architecture\");\n+      opts->x_flag_reorder_blocks_and_partition = 0;\n+      opts->x_flag_reorder_blocks = 1;\n+    }\n+\n+  /* If user requested unwind info, then turn off the partitioning\n+     optimization.  */\n+\n+  if (opts->x_flag_unwind_tables\n+      && !targetm_common.unwind_tables_default\n+      && opts->x_flag_reorder_blocks_and_partition\n+      && (ui_except == UI_SJLJ || ui_except >= UI_TARGET))\n+    {\n+      if (opts_set->x_flag_reorder_blocks_and_partition)\n+\tinform (loc,\n+\t\t\"%<-freorder-blocks-and-partition%> does not support \"\n+\t\t\"unwind info on this architecture\");\n+      opts->x_flag_reorder_blocks_and_partition = 0;\n+      opts->x_flag_reorder_blocks = 1;\n+    }\n+\n+  /* If the target requested unwind info, then turn off the partitioning\n+     optimization with a different message.  Likewise, if the target does not\n+     support named sections.  */\n+\n+  if (opts->x_flag_reorder_blocks_and_partition\n+      && (!targetm_common.have_named_sections\n+\t  || (opts->x_flag_unwind_tables\n+\t      && targetm_common.unwind_tables_default\n+\t      && (ui_except == UI_SJLJ || ui_except >= UI_TARGET))))\n+    {\n+      if (opts_set->x_flag_reorder_blocks_and_partition)\n+\tinform (loc,\n+\t\t\"%<-freorder-blocks-and-partition%> does not work \"\n+\t\t\"on this architecture\");\n+      opts->x_flag_reorder_blocks_and_partition = 0;\n+      opts->x_flag_reorder_blocks = 1;\n+    }\n+\n+\n }\n \n #define LEFT_COLUMN\t27"}, {"sha": "8003d26bda6e039677807ba58dc996db1abe5a14", "filename": "gcc/opts.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a187edd2b437fc9571d57f771a624963fcce08f8/gcc%2Fopts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a187edd2b437fc9571d57f771a624963fcce08f8/gcc%2Fopts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.h?ref=a187edd2b437fc9571d57f771a624963fcce08f8", "patch": "@@ -428,6 +428,8 @@ extern bool target_handle_option (struct gcc_options *opts,\n extern void finish_options (struct gcc_options *opts,\n \t\t\t    struct gcc_options *opts_set,\n \t\t\t    location_t loc);\n+extern void diagnose_options (gcc_options *opts, gcc_options *opts_set,\n+\t\t\t      location_t loc);\n extern void print_help (struct gcc_options *opts, unsigned int lang_mask, const\n \t\t\tchar *help_option_argument);\n extern void default_options_optimization (struct gcc_options *opts,"}, {"sha": "6727c9f314f625fe243fb080d513d0cfef88f05f", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a187edd2b437fc9571d57f771a624963fcce08f8/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a187edd2b437fc9571d57f771a624963fcce08f8/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=a187edd2b437fc9571d57f771a624963fcce08f8", "patch": "@@ -1718,6 +1718,8 @@ process_options (bool no_backend)\n   if (flag_large_source_files)\n     line_table->default_range_bits = 0;\n \n+  diagnose_options (&global_options, &global_options_set, UNKNOWN_LOCATION);\n+\n   /* Please don't change global_options after this point, those changes won't\n      be reflected in optimization_{default,current}_node.  */\n }"}]}