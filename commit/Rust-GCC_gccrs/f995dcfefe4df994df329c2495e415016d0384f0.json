{"sha": "f995dcfefe4df994df329c2495e415016d0384f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjk5NWRjZmVmZTRkZjk5NGRmMzI5YzI0OTVlNDE1MDE2ZDAzODRmMA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2005-06-04T14:02:35Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-06-04T14:02:35Z"}, "message": "function.c (prologue, [...]): Change their types to VEC(int,heap)*.\n\n\t* function.c (prologue, epilogue, sibcall_epilogue): Change\n\ttheir types to VEC(int,heap)*.\n\t(free_after_compilation): Free the three vectors above.\n\t(init_function_for_compilation, record_insns, contains,\n\tprologue_epilogue_contains, sibcall_epilogue_contains,\n\treposition_prologue_and_epilogue_notes): Use VEC instead of\n\tVARRAY.  (init_function_once): Remove.\n\t* function.h: Remove the prototype for init_function_once.\n\t* toplev.c (backend_init): Don't call init_function_once.\n\nFrom-SVN: r100588", "tree": {"sha": "51a0199072df111b73ed7078485a4b6bec220510", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51a0199072df111b73ed7078485a4b6bec220510"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f995dcfefe4df994df329c2495e415016d0384f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f995dcfefe4df994df329c2495e415016d0384f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f995dcfefe4df994df329c2495e415016d0384f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f995dcfefe4df994df329c2495e415016d0384f0/comments", "author": null, "committer": null, "parents": [{"sha": "4226398ba733768dcf297f03c9bb7631fc6367cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4226398ba733768dcf297f03c9bb7631fc6367cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4226398ba733768dcf297f03c9bb7631fc6367cd"}], "stats": {"total": 99, "additions": 45, "deletions": 54}, "files": [{"sha": "a335deb1b53afbc3a5f3b57cb1aa9591eb364c0d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f995dcfefe4df994df329c2495e415016d0384f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f995dcfefe4df994df329c2495e415016d0384f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f995dcfefe4df994df329c2495e415016d0384f0", "patch": "@@ -1,3 +1,15 @@\n+2005-06-04  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* function.c (prologue, epilogue, sibcall_epilogue): Change\n+\ttheir types to VEC(int,heap)*.\n+\t(free_after_compilation): Free the three vectors above.\n+\t(init_function_for_compilation, record_insns, contains,\n+\tprologue_epilogue_contains, sibcall_epilogue_contains,\n+\treposition_prologue_and_epilogue_notes): Use VEC instead of\n+\tVARRAY.  (init_function_once): Remove.\n+\t* function.h: Remove the prototype for init_function_once.\n+\t* toplev.c (backend_init): Don't call init_function_once.\n+\n 2005-06-04  Jan Hubicka  <jh@suse.cz>\n \n \t* predict.c (tree_predict_edge): Do not predict entry edge and"}, {"sha": "6496e4cd95425021f98d9269366b39ba7b2ef380", "filename": "gcc/function.c", "status": "modified", "additions": 33, "deletions": 50, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f995dcfefe4df994df329c2495e415016d0384f0/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f995dcfefe4df994df329c2495e415016d0384f0/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=f995dcfefe4df994df329c2495e415016d0384f0", "patch": "@@ -121,13 +121,16 @@ struct machine_function * (*init_machine_status) (void);\n /* The currently compiled function.  */\n struct function *cfun = 0;\n \n+DEF_VEC_I(int);\n+DEF_VEC_ALLOC_I(int,heap);\n+\n /* These arrays record the INSN_UIDs of the prologue and epilogue insns.  */\n-static GTY(()) varray_type prologue;\n-static GTY(()) varray_type epilogue;\n+static VEC(int,heap) *prologue;\n+static VEC(int,heap) *epilogue;\n \n /* Array of INSN_UIDs to hold the INSN_UIDs for each sibcall epilogue\n    in this function.  */\n-static GTY(()) varray_type sibcall_epilogue;\n+static VEC(int,heap) *sibcall_epilogue;\n \f\n /* In order to evaluate some expressions, such as function calls returning\n    structures in memory, we need to temporarily allocate stack locations.\n@@ -198,8 +201,8 @@ static tree *get_block_vector (tree, int *);\n extern tree debug_find_var_in_block_tree (tree, tree);\n /* We always define `record_insns' even if it's not used so that we\n    can always export `prologue_epilogue_contains'.  */\n-static void record_insns (rtx, varray_type *) ATTRIBUTE_UNUSED;\n-static int contains (rtx, varray_type);\n+static void record_insns (rtx, VEC(int,heap) **) ATTRIBUTE_UNUSED;\n+static int contains (rtx, VEC(int,heap) **);\n #ifdef HAVE_return\n static void emit_return_into_block (basic_block, rtx);\n #endif\n@@ -306,6 +309,10 @@ free_after_parsing (struct function *f)\n void\n free_after_compilation (struct function *f)\n {\n+  VEC_free (int, heap, prologue);\n+  VEC_free (int, heap, epilogue);\n+  VEC_free (int, heap, sibcall_epilogue);\n+\n   f->eh = NULL;\n   f->expr = NULL;\n   f->emit = NULL;\n@@ -3861,10 +3868,11 @@ init_function_for_compilation (void)\n {\n   reg_renumber = 0;\n \n-  /* No prologue/epilogue insns yet.  */\n-  VARRAY_GROW (prologue, 0);\n-  VARRAY_GROW (epilogue, 0);\n-  VARRAY_GROW (sibcall_epilogue, 0);\n+  /* No prologue/epilogue insns yet.  Make sure that these vectors are\n+     empty.  */\n+  gcc_assert (VEC_length (int, prologue) == 0);\n+  gcc_assert (VEC_length (int, epilogue) == 0);\n+  gcc_assert (VEC_length (int, sibcall_epilogue) == 0);\n }\n \n void\n@@ -4446,28 +4454,12 @@ get_arg_pointer_save_area (struct function *f)\n    (a list of one or more insns).  */\n \n static void\n-record_insns (rtx insns, varray_type *vecp)\n+record_insns (rtx insns, VEC(int,heap) **vecp)\n {\n-  int i, len;\n   rtx tmp;\n \n-  tmp = insns;\n-  len = 0;\n-  while (tmp != NULL_RTX)\n-    {\n-      len++;\n-      tmp = NEXT_INSN (tmp);\n-    }\n-\n-  i = VARRAY_SIZE (*vecp);\n-  VARRAY_GROW (*vecp, i + len);\n-  tmp = insns;\n-  while (tmp != NULL_RTX)\n-    {\n-      VARRAY_INT (*vecp, i) = INSN_UID (tmp);\n-      i++;\n-      tmp = NEXT_INSN (tmp);\n-    }\n+  for (tmp = insns; tmp != NULL_RTX; tmp = NEXT_INSN (tmp))\n+    VEC_safe_push (int, heap, *vecp, INSN_UID (tmp));\n }\n \n /* Set the locator of the insn chain starting at INSN to LOC.  */\n@@ -4486,7 +4478,7 @@ set_insn_locators (rtx insn, int loc)\n    be running after reorg, SEQUENCE rtl is possible.  */\n \n static int\n-contains (rtx insn, varray_type vec)\n+contains (rtx insn, VEC(int,heap) **vec)\n {\n   int i, j;\n \n@@ -4495,15 +4487,16 @@ contains (rtx insn, varray_type vec)\n     {\n       int count = 0;\n       for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n-\tfor (j = VARRAY_SIZE (vec) - 1; j >= 0; --j)\n-\t  if (INSN_UID (XVECEXP (PATTERN (insn), 0, i)) == VARRAY_INT (vec, j))\n+\tfor (j = VEC_length (int, *vec) - 1; j >= 0; --j)\n+\t  if (INSN_UID (XVECEXP (PATTERN (insn), 0, i))\n+\t      == VEC_index (int, *vec, j))\n \t    count++;\n       return count;\n     }\n   else\n     {\n-      for (j = VARRAY_SIZE (vec) - 1; j >= 0; --j)\n-\tif (INSN_UID (insn) == VARRAY_INT (vec, j))\n+      for (j = VEC_length (int, *vec) - 1; j >= 0; --j)\n+\tif (INSN_UID (insn) == VEC_index (int, *vec, j))\n \t  return 1;\n     }\n   return 0;\n@@ -4512,9 +4505,9 @@ contains (rtx insn, varray_type vec)\n int\n prologue_epilogue_contains (rtx insn)\n {\n-  if (contains (insn, prologue))\n+  if (contains (insn, &prologue))\n     return 1;\n-  if (contains (insn, epilogue))\n+  if (contains (insn, &epilogue))\n     return 1;\n   return 0;\n }\n@@ -4523,7 +4516,7 @@ int\n sibcall_epilogue_contains (rtx insn)\n {\n   if (sibcall_epilogue)\n-    return contains (insn, sibcall_epilogue);\n+    return contains (insn, &sibcall_epilogue);\n   return 0;\n }\n \n@@ -5262,7 +5255,7 @@ reposition_prologue_and_epilogue_notes (rtx f ATTRIBUTE_UNUSED)\n   rtx insn, last, note;\n   int len;\n \n-  if ((len = VARRAY_SIZE (prologue)) > 0)\n+  if ((len = VEC_length (int, prologue)) > 0)\n     {\n       last = 0, note = 0;\n \n@@ -5276,7 +5269,7 @@ reposition_prologue_and_epilogue_notes (rtx f ATTRIBUTE_UNUSED)\n \t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_PROLOGUE_END)\n \t\tnote = insn;\n \t    }\n-\t  else if (contains (insn, prologue))\n+\t  else if (contains (insn, &prologue))\n \t    {\n \t      last = insn;\n \t      if (--len == 0)\n@@ -5303,7 +5296,7 @@ reposition_prologue_and_epilogue_notes (rtx f ATTRIBUTE_UNUSED)\n \t}\n     }\n \n-  if ((len = VARRAY_SIZE (epilogue)) > 0)\n+  if ((len = VEC_length (int, epilogue)) > 0)\n     {\n       last = 0, note = 0;\n \n@@ -5317,7 +5310,7 @@ reposition_prologue_and_epilogue_notes (rtx f ATTRIBUTE_UNUSED)\n \t      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EPILOGUE_BEG)\n \t\tnote = insn;\n \t    }\n-\t  else if (contains (insn, epilogue))\n+\t  else if (contains (insn, &epilogue))\n \t    {\n \t      last = insn;\n \t      if (--len == 0)\n@@ -5344,16 +5337,6 @@ reposition_prologue_and_epilogue_notes (rtx f ATTRIBUTE_UNUSED)\n #endif /* HAVE_prologue or HAVE_epilogue */\n }\n \n-/* Called once, at initialization, to initialize function.c.  */\n-\n-void\n-init_function_once (void)\n-{\n-  VARRAY_INT_INIT (prologue, 0, \"prologue\");\n-  VARRAY_INT_INIT (epilogue, 0, \"epilogue\");\n-  VARRAY_INT_INIT (sibcall_epilogue, 0, \"sibcall_epilogue\");\n-}\n-\n /* Resets insn_block_boundaries array.  */\n \n void"}, {"sha": "cdacf09431aa4d0370414b1cf631866e1bbd9c52", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f995dcfefe4df994df329c2495e415016d0384f0/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f995dcfefe4df994df329c2495e415016d0384f0/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=f995dcfefe4df994df329c2495e415016d0384f0", "patch": "@@ -556,9 +556,6 @@ extern void instantiate_virtual_regs (void);\n /* Returns the name of the current function.  */\n extern const char *current_function_name (void);\n \n-/* Called once, at initialization, to initialize function.c.  */\n-extern void init_function_once (void);\n-\n extern void do_warn_unused_parameter (tree);\n \n extern bool pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,"}, {"sha": "0d3090927022e4d83fadc8d266cf780efbe481be", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f995dcfefe4df994df329c2495e415016d0384f0/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f995dcfefe4df994df329c2495e415016d0384f0/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=f995dcfefe4df994df329c2495e415016d0384f0", "patch": "@@ -1767,7 +1767,6 @@ backend_init (void)\n   init_alias_once ();\n   init_loop ();\n   init_reload ();\n-  init_function_once ();\n   init_varasm_once ();\n \n   /* The following initialization functions need to generate rtl, so"}]}