{"sha": "d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFlYjhhODJiMjg1MWFiYTljYzM1Y2M2OThiZTdkYmY0ZjgwZWM5YQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T09:22:43Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-04-25T09:22:43Z"}, "message": "[multiple changes]\n\n2017-04-25  Arnaud Charlet  <charlet@adacore.com>\n\n\t* a-cfinve.ads, a-cofove.ads (Empty_Vector): add Global contract.\n\n2017-04-25  Justin Squirek  <squirek@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Declarations): Minor\n\tcorrection to comments, move out large conditional and scope\n\ttraversal into a predicate.\n\t(Uses_Unseen_Lib_Unit_Priv): Predicate function made from extracted\n\tlogic.\n\n2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Analyze_Selected_Component): Refine analysis\n\tof prefix whose type is a current instance of a synchronized\n\ttype. If the prefix is an object this is an external call (or\n\trequeue) that can only access public operations of the object. The\n\tprevious predicate was too restrictive, and did not allow public\n\tprotected operations, only task entries.\n\n2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch5.adb, fname.adb: Minor reformatting.\n\n2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.adb (Is_Anonymous_Access_Type): New routine.\n\t* einfo.ads Update the placement of\n\tE_Anonymous_Access_Subprogram_Type along with all subtypes that\n\tmention the ekind.\n\t(Is_Anonymous_Access_Type): New routine.\n\t* exp_ch7.adb (Allows_Finalization_Master): Do not generate a\n\tmaster for an access type subject to pragma No_Heap_Finalization.\n\t* exp_util.adb (Build_Allocate_Deallocate_Proc): An object being\n\tallocated or deallocated does not finalization actions if the\n\tassociated access type is subject to pragma No_Heap_Finalization.\n\t* opt.ads Add new global variable No_Heap_Finalization_Pragma.\n\t* par-prag.adb Pragma No_Heap_Finalization does not need special\n\tprocessing from the parser.\n\t* sem_ch6.adb (Check_Return_Subtype_Indication): Remove ancient\n\t??? comments. Use the new predicate Is_Anonymous_Access_Type.\n\t* sem_prag.adb Add an entry in table Sig_Flags for pragma\n\tNo_Heap_Finalization.\n\t(Analyze_Pragma): Add processing for\n\tpragma No_Heap_Finalization. Update various error messages to\n\tuse Duplication_Error.\n\t* sem_util.ads, sem_util.adb (No_Heap_Finalization): New routine.\n\t* snames.ads-tmpl: Add new predefined name No_Heap_Finalization\n\tand corresponding pragma id.\n\nFrom-SVN: r247156", "tree": {"sha": "ee06f578fdeb57e95b0f30957eee580d9a2cb477", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee06f578fdeb57e95b0f30957eee580d9a2cb477"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/comments", "author": null, "committer": null, "parents": [{"sha": "820f11620e17579c411c3eb31d73a772a2174f85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/820f11620e17579c411c3eb31d73a772a2174f85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/820f11620e17579c411c3eb31d73a772a2174f85"}], "stats": {"total": 587, "additions": 418, "deletions": 169}, "files": [{"sha": "50e45b69d33ba0b112deef692aaf80c9705c4504", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "patch": "@@ -1,3 +1,54 @@\n+2017-04-25  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* a-cfinve.ads, a-cofove.ads (Empty_Vector): add Global contract.\n+\n+2017-04-25  Justin Squirek  <squirek@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Declarations): Minor\n+\tcorrection to comments, move out large conditional and scope\n+\ttraversal into a predicate.\n+\t(Uses_Unseen_Lib_Unit_Priv): Predicate function made from extracted\n+\tlogic.\n+\n+2017-04-25  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Analyze_Selected_Component): Refine analysis\n+\tof prefix whose type is a current instance of a synchronized\n+\ttype. If the prefix is an object this is an external call (or\n+\trequeue) that can only access public operations of the object. The\n+\tprevious predicate was too restrictive, and did not allow public\n+\tprotected operations, only task entries.\n+\n+2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch5.adb, fname.adb: Minor reformatting.\n+\n+2017-04-25  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.adb (Is_Anonymous_Access_Type): New routine.\n+\t* einfo.ads Update the placement of\n+\tE_Anonymous_Access_Subprogram_Type along with all subtypes that\n+\tmention the ekind.\n+\t(Is_Anonymous_Access_Type): New routine.\n+\t* exp_ch7.adb (Allows_Finalization_Master): Do not generate a\n+\tmaster for an access type subject to pragma No_Heap_Finalization.\n+\t* exp_util.adb (Build_Allocate_Deallocate_Proc): An object being\n+\tallocated or deallocated does not finalization actions if the\n+\tassociated access type is subject to pragma No_Heap_Finalization.\n+\t* opt.ads Add new global variable No_Heap_Finalization_Pragma.\n+\t* par-prag.adb Pragma No_Heap_Finalization does not need special\n+\tprocessing from the parser.\n+\t* sem_ch6.adb (Check_Return_Subtype_Indication): Remove ancient\n+\t??? comments. Use the new predicate Is_Anonymous_Access_Type.\n+\t* sem_prag.adb Add an entry in table Sig_Flags for pragma\n+\tNo_Heap_Finalization.\n+\t(Analyze_Pragma): Add processing for\n+\tpragma No_Heap_Finalization. Update various error messages to\n+\tuse Duplication_Error.\n+\t* sem_util.ads, sem_util.adb (No_Heap_Finalization): New routine.\n+\t* snames.ads-tmpl: Add new predefined name No_Heap_Finalization\n+\tand corresponding pragma id.\n+\n 2017-04-25  Bob Duff  <duff@adacore.com>\n \n \t* freeze.adb (Freeze_Record_Type): Use the"}, {"sha": "34abfbbbcff57fd2c964c284cfe0c70374e29ab3", "filename": "gcc/ada/a-cfinve.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fa-cfinve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fa-cfinve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cfinve.ads?ref=d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2014-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2014-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -73,7 +73,8 @@ is\n    type Vector (Capacity : Capacity_Range) is limited private with\n      Default_Initial_Condition;\n \n-   function Empty_Vector return Vector;\n+   function Empty_Vector return Vector with\n+     Global => null;\n \n    function \"=\" (Left, Right : Vector) return Boolean with\n      Global => null;"}, {"sha": "a97d2d8c10b8c86cc1c3e583320ea54db48f43e1", "filename": "gcc/ada/a-cofove.ads", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cofove.ads?ref=d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2004-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2004-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- This specification is derived from the Ada Reference Manual for use with --\n -- GNAT. The copyright notice above, and the license provisions that follow --\n@@ -73,7 +73,8 @@ is\n    --  unbounded case; you can't assign from one object to another if the\n    --  Capacity is different.\n \n-   function Empty_Vector return Vector;\n+   function Empty_Vector return Vector with\n+     Global => null;\n \n    function \"=\" (Left, Right : Vector) return Boolean with\n      Global => null;"}, {"sha": "441d3096264af93fe2a5ca3a797920326aa3b9d6", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "patch": "@@ -3533,6 +3533,11 @@ package body Einfo is\n       return Ekind (Id) in Aggregate_Kind;\n    end Is_Aggregate_Type;\n \n+   function Is_Anonymous_Access_Type            (Id : E) return B is\n+   begin\n+      return Ekind (Id) in Anonymous_Access_Kind;\n+   end Is_Anonymous_Access_Type;\n+\n    function Is_Array_Type                       (Id : E) return B is\n    begin\n       return Ekind (Id) in Array_Kind;"}, {"sha": "9a0530d8da7905f83b8fece21abb4d4a774944a3", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "patch": "@@ -4845,12 +4845,6 @@ package Einfo is\n       --  An access to subprogram type, created by an access to subprogram\n       --  declaration.\n \n-      E_Anonymous_Access_Subprogram_Type,\n-      --  An anonymous access to subprogram type, created by an access to\n-      --  subprogram declaration, or generated for a current instance of\n-      --  a type name appearing within a component definition that has an\n-      --  anonymous access to subprogram type.\n-\n       E_Access_Protected_Subprogram_Type,\n       --  An access to a protected subprogram, created by the corresponding\n       --  declaration. Values of such a type denote both a protected object\n@@ -4861,6 +4855,12 @@ package Einfo is\n       --  An anonymous access to protected subprogram type, created by an\n       --  access to subprogram declaration.\n \n+      E_Anonymous_Access_Subprogram_Type,\n+      --  An anonymous access to subprogram type, created by an access to\n+      --  subprogram declaration, or generated for a current instance of\n+      --  a type name appearing within a component definition that has an\n+      --  anonymous access to subprogram type.\n+\n       E_Anonymous_Access_Type,\n       --  An anonymous access type created by an access parameter or access\n       --  discriminant.\n@@ -5090,16 +5090,16 @@ package Einfo is\n    --  E_Allocator_Type\n    --  E_General_Access_Type\n    --  E_Access_Subprogram_Type\n-   --  E_Anonymous_Access_Subprogram_Type\n    --  E_Access_Protected_Subprogram_Type\n    --  E_Anonymous_Access_Protected_Subprogram_Type\n+   --  E_Anonymous_Access_Subprogram_Type\n        E_Anonymous_Access_Type;\n \n    subtype Access_Subprogram_Kind      is Entity_Kind range\n        E_Access_Subprogram_Type ..\n-   --  E_Anonymous_Access_Subprogram_Type\n    --  E_Access_Protected_Subprogram_Type\n-       E_Anonymous_Access_Protected_Subprogram_Type;\n+   --  E_Anonymous_Access_Protected_Subprogram_Type\n+       E_Anonymous_Access_Subprogram_Type;\n \n    subtype Access_Protected_Kind       is Entity_Kind range\n       E_Access_Protected_Subprogram_Type ..\n@@ -5114,6 +5114,11 @@ package Einfo is\n    --  E_Record_Type\n        E_Record_Subtype;\n \n+   subtype Anonymous_Access_Kind       is Entity_Kind range\n+       E_Anonymous_Access_Protected_Subprogram_Type ..\n+   --  E_Anonymous_Subprogram_Type\n+       E_Anonymous_Access_Type;\n+\n    subtype Array_Kind                  is Entity_Kind range\n        E_Array_Type ..\n    --  E_Array_Subtype\n@@ -5209,8 +5214,8 @@ package Einfo is\n    --  E_General_Access_Type\n    --  E_Access_Subprogram_Type\n    --  E_Access_Protected_Subprogram_Type\n-   --  E_Anonymous_Access_Subprogram_Type\n    --  E_Anonymous_Access_Protected_Subprogram_Type\n+   --  E_Anonymous_Access_Subprogram_Type\n        E_Anonymous_Access_Type;\n \n    subtype Enumeration_Kind            is Entity_Kind range\n@@ -5388,8 +5393,8 @@ package Einfo is\n    --  E_General_Access_Type\n    --  E_Access_Subprogram_Type,\n    --  E_Access_Protected_Subprogram_Type\n-   --  E_Anonymous_Access_Subprogram_Type\n    --  E_Anonymous_Access_Protected_Subprogram_Type\n+   --  E_Anonymous_Access_Subprogram_Type\n    --  E_Anonymous_Access_Type\n    --  E_Array_Type\n    --  E_Array_Subtype\n@@ -7359,6 +7364,7 @@ package Einfo is\n    function Is_Access_Protected_Subprogram_Type (Id : E) return B;\n    function Is_Access_Subprogram_Type           (Id : E) return B;\n    function Is_Aggregate_Type                   (Id : E) return B;\n+   function Is_Anonymous_Access_Type            (Id : E) return B;\n    function Is_Array_Type                       (Id : E) return B;\n    function Is_Assignable                       (Id : E) return B;\n    function Is_Class_Wide_Type                  (Id : E) return B;"}, {"sha": "852ae44403352bf3027a32da65c9e7a33e3272b0", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "patch": "@@ -486,34 +486,41 @@ package body Exp_Ch7 is\n       then\n          return False;\n \n-      --  Do not consider types that return on the secondary stack\n+      --  Do not consider an access type which return on the secondary stack\n \n       elsif Present (Associated_Storage_Pool (Ptr_Typ))\n         and then Is_RTE (Associated_Storage_Pool (Ptr_Typ), RE_SS_Pool)\n       then\n          return False;\n \n-      --  Do not consider types which may never allocate an object\n+      --  Do not consider an access type which may never allocate an object\n \n       elsif No_Pool_Assigned (Ptr_Typ) then\n          return False;\n \n-      --  Do not consider access types coming from Ada.Unchecked_Deallocation\n-      --  instances. Even though the designated type may be controlled, the\n-      --  access type will never participate in allocation.\n+      --  Do not consider an access type coming from an Unchecked_Deallocation\n+      --  instance. Even though the designated type may be controlled, the\n+      --  access type will never participate in any allocations.\n \n       elsif In_Deallocation_Instance (Ptr_Typ) then\n          return False;\n \n-      --  Do not consider non-library access types when restriction\n-      --  No_Nested_Finalization is in effect since masters are controlled\n-      --  objects.\n+      --  Do not consider a non-library access type when No_Nested_Finalization\n+      --  is in effect since finalization masters are controlled objects and if\n+      --  created will violate the restriction.\n \n       elsif Restriction_Active (No_Nested_Finalization)\n         and then not Is_Library_Level_Entity (Ptr_Typ)\n       then\n          return False;\n \n+      --  Do not consider an access type subject to pragma No_Heap_Finalization\n+      --  because objects allocated through such a type are not to be finalized\n+      --  when the access type goes out of scope.\n+\n+      elsif No_Heap_Finalization (Ptr_Typ) then\n+         return False;\n+\n       --  Do not create finalization masters in GNATprove mode because this\n       --  causes unwanted extra expansion. A compilation in this mode must\n       --  keep the tree as close as possible to the original sources."}, {"sha": "034df56907f6d999224b7f2396bdf1edc6ae08a0", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 31, "deletions": 18, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "patch": "@@ -481,12 +481,6 @@ package body Exp_Util is\n      (N           : Node_Id;\n       Is_Allocate : Boolean)\n    is\n-      Desig_Typ    : Entity_Id;\n-      Expr         : Node_Id;\n-      Pool_Id      : Entity_Id;\n-      Proc_To_Call : Node_Id := Empty;\n-      Ptr_Typ      : Entity_Id;\n-\n       function Find_Object (E : Node_Id) return Node_Id;\n       --  Given an arbitrary expression of an allocator, try to find an object\n       --  reference in it, otherwise return the original expression.\n@@ -576,6 +570,15 @@ package body Exp_Util is\n          return False;\n       end Is_Allocate_Deallocate_Proc;\n \n+      --  Local variables\n+\n+      Desig_Typ    : Entity_Id;\n+      Expr         : Node_Id;\n+      Needs_Fin    : Boolean;\n+      Pool_Id      : Entity_Id;\n+      Proc_To_Call : Node_Id := Empty;\n+      Ptr_Typ      : Entity_Id;\n+\n    --  Start of processing for Build_Allocate_Deallocate_Proc\n \n    begin\n@@ -667,7 +670,15 @@ package body Exp_Util is\n          return;\n       end if;\n \n-      if Needs_Finalization (Desig_Typ) then\n+      --  Finalization actions are required when the object to be allocated or\n+      --  deallocated needs these actions and the associated access type is not\n+      --  subject to pragma No_Heap_Finalization.\n+\n+      Needs_Fin :=\n+        Needs_Finalization (Desig_Typ)\n+          and then not No_Heap_Finalization (Ptr_Typ);\n+\n+      if Needs_Fin then\n \n          --  Certain run-time configurations and targets do not provide support\n          --  for controlled types.\n@@ -737,7 +748,7 @@ package body Exp_Util is\n \n             --  c) Finalization master\n \n-            if Needs_Finalization (Desig_Typ) then\n+            if Needs_Fin then\n                Fin_Mas_Id  := Finalization_Master (Ptr_Typ);\n                Fin_Mas_Act := New_Occurrence_Of (Fin_Mas_Id, Loc);\n \n@@ -761,7 +772,7 @@ package body Exp_Util is\n             --  Primitive Finalize_Address is never generated in CodePeer mode\n             --  since it contains an Unchecked_Conversion.\n \n-            if Needs_Finalization (Desig_Typ) and then not CodePeer_Mode then\n+            if Needs_Fin and then not CodePeer_Mode then\n                Fin_Addr_Id := Finalize_Address (Desig_Typ);\n                pragma Assert (Present (Fin_Addr_Id));\n \n@@ -807,8 +818,8 @@ package body Exp_Util is\n \n          --  h) Is_Controlled\n \n-         if Needs_Finalization (Desig_Typ) then\n-            declare\n+         if Needs_Fin then\n+            Is_Controlled : declare\n                Flag_Id   : constant Entity_Id := Make_Temporary (Loc, 'F');\n                Flag_Expr : Node_Id;\n                Param     : Node_Id;\n@@ -904,7 +915,7 @@ package body Exp_Util is\n                     Expression          => Flag_Expr));\n \n                Append_To (Actuals, New_Occurrence_Of (Flag_Id, Loc));\n-            end;\n+            end Is_Controlled;\n \n          --  The object is not controlled\n \n@@ -935,19 +946,19 @@ package body Exp_Util is\n \n          Insert_Action (N,\n            Make_Subprogram_Body (Loc,\n-             Specification =>\n+             Specification              =>\n \n                --  procedure Pnn\n \n                Make_Procedure_Specification (Loc,\n-                 Defining_Unit_Name => Proc_Id,\n+                 Defining_Unit_Name       => Proc_Id,\n                  Parameter_Specifications => New_List (\n \n                   --  P : Root_Storage_Pool\n \n                    Make_Parameter_Specification (Loc,\n                      Defining_Identifier => Make_Temporary (Loc, 'P'),\n-                     Parameter_Type =>\n+                     Parameter_Type      =>\n                        New_Occurrence_Of (RTE (RE_Root_Storage_Pool), Loc)),\n \n                   --  A : [out] Address\n@@ -972,13 +983,14 @@ package body Exp_Util is\n                      Parameter_Type      =>\n                        New_Occurrence_Of (RTE (RE_Storage_Count), Loc)))),\n \n-             Declarations => No_List,\n+             Declarations               => No_List,\n \n              Handled_Statement_Sequence =>\n                Make_Handled_Sequence_Of_Statements (Loc,\n                  Statements => New_List (\n                    Make_Procedure_Call_Statement (Loc,\n-                     Name => New_Occurrence_Of (Proc_To_Call, Loc),\n+                     Name                   =>\n+                       New_Occurrence_Of (Proc_To_Call, Loc),\n                      Parameter_Associations => Actuals)))));\n \n          --  The newly generated Allocate / Deallocate becomes the default\n@@ -10252,7 +10264,8 @@ package body Exp_Util is\n          --  Class-wide types are treated as controlled because derivations\n          --  from the root type can introduce controlled components.\n \n-         return Is_Class_Wide_Type (T)\n+         return\n+           Is_Class_Wide_Type (T)\n              or else Is_Controlled (T)\n              or else Has_Some_Controlled_Component (T)\n              or else"}, {"sha": "0024eec4e2d8a3e6e77557befd48d2c06cc82aa9", "filename": "gcc/ada/fname.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Ffname.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Ffname.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname.adb?ref=d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "patch": "@@ -230,8 +230,8 @@ package body Fname is\n       Renamings_Included : Boolean := True) return Boolean\n    is\n       Result : constant Boolean :=\n-        Is_Predefined_File_Name\n-          (Get_Name_String (Fname), Renamings_Included);\n+                 Is_Predefined_File_Name\n+                   (Get_Name_String (Fname), Renamings_Included);\n    begin\n       return Result;\n    end Is_Predefined_File_Name;"}, {"sha": "94fdd8a065c318c5a369a8a630e5e1dd4ffa026d", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "patch": "@@ -1115,6 +1115,11 @@ package Opt is\n    --  in the spec of the extended main unit. Used to determine if we need to\n    --  do special tests for violation of this aspect.\n \n+   No_Heap_Finalization_Pragma : Node_Id := Empty;\n+   --  GNAT\n+   --  Set to point to a No_Heap_Finalization pragma defined in a configuration\n+   --  file.\n+\n    No_Main_Subprogram : Boolean := False;\n    --  GNATMAKE, GNATBIND\n    --  Set to True if compilation/binding of a program without main"}, {"sha": "02223c8c68691dd678e6ff1bd3b7c4238055fe46", "filename": "gcc/ada/par-prag.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fpar-prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fpar-prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-prag.adb?ref=d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "patch": "@@ -1410,6 +1410,7 @@ begin\n          | Pragma_Memory_Size\n          | Pragma_No_Body\n          | Pragma_No_Elaboration_Code_All\n+         | Pragma_No_Heap_Finalization\n          | Pragma_No_Inline\n          | Pragma_No_Return\n          | Pragma_No_Run_Time"}, {"sha": "6b8a453531383768a8cc3385332afcdc99454ef7", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 82, "deletions": 80, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "patch": "@@ -2195,6 +2195,10 @@ package body Sem_Ch3 is\n       --  Utility to resolve the expressions of aspects at the end of a list of\n       --  declarations.\n \n+      function Uses_Unseen_Lib_Unit_Priv (Pkg : Entity_Id) return Boolean;\n+      --  Check if an inner package has entities within it that rely on library\n+      --  level private types where the full view has not been seen.\n+\n       -----------------\n       -- Adjust_Decl --\n       -----------------\n@@ -2480,6 +2484,40 @@ package body Sem_Ch3 is\n          end loop;\n       end Resolve_Aspects;\n \n+      -------------------------------\n+      -- Uses_Unseen_Lib_Unit_Priv --\n+      -------------------------------\n+\n+      function Uses_Unseen_Lib_Unit_Priv (Pkg : Entity_Id) return Boolean is\n+         Curr : Entity_Id;\n+\n+      begin\n+         --  Avoid looking through scopes that do not meet the precondition of\n+         --  Pkg not being within a library unit spec.\n+\n+         if not Is_Compilation_Unit (Pkg)\n+           and then not Is_Generic_Instance (Pkg)\n+           and then not In_Package_Body (Enclosing_Lib_Unit_Entity (Pkg))\n+         then\n+            --  Loop through all entities in the current scope to identify\n+            --  an entity that depends on a private type.\n+\n+            Curr := First_Entity (Pkg);\n+            loop\n+               if Nkind (Curr) in N_Entity\n+                 and then Depends_On_Private (Curr)\n+               then\n+                  return True;\n+               end if;\n+\n+               exit when Last_Entity (Current_Scope) = Curr;\n+               Curr := Next_Entity (Curr);\n+            end loop;\n+         end if;\n+\n+         return False;\n+      end Uses_Unseen_Lib_Unit_Priv;\n+\n       --  Local variables\n \n       Context     : Node_Id   := Empty;\n@@ -2489,10 +2527,6 @@ package body Sem_Ch3 is\n       Body_Seen : Boolean := False;\n       --  Flag set when the first body [stub] is encountered\n \n-      Ignore_Freezing : Boolean;\n-      --  Flag set when deciding to freeze an expression function in the\n-      --  current scope.\n-\n    --  Start of processing for Analyze_Declarations\n \n    begin\n@@ -2631,89 +2665,57 @@ package body Sem_Ch3 is\n          --  care to attach the bodies at a proper place in the tree so as to\n          --  not cause unwanted freezing at that point.\n \n-         elsif not Analyzed (Next_Decl) and then Is_Body (Next_Decl) then\n-\n-            --  Check for an edge case that may cause premature freezing of\n-            --  a private type. If there is a type which depends on another\n-            --  private type from an enclosing package that is in the same\n-            --  scope as a non-completing expression function then we cannot\n-            --  freeze here.\n+         --  It is also necessary to check for a case where both an expression\n+         --  function is used and the current scope depends on an unseen\n+         --  private type from a library unit, otherwise premature freezing of\n+         --  the private type will occur.\n \n-            Ignore_Freezing := False;\n-\n-            if Nkind (Next_Decl) = N_Subprogram_Body\n-              and then Was_Expression_Function (Next_Decl)\n-              and then not Is_Compilation_Unit (Current_Scope)\n-              and then not Is_Generic_Instance (Current_Scope)\n-              and then not In_Package_Body\n-                             (Enclosing_Lib_Unit_Entity (Current_Scope))\n+         elsif not Analyzed (Next_Decl) and then Is_Body (Next_Decl)\n+           and then ((Nkind (Next_Decl) /= N_Subprogram_Body\n+                      or else not Was_Expression_Function (Next_Decl))\n+                     or else not Uses_Unseen_Lib_Unit_Priv (Current_Scope))\n+         then\n+            --  When a controlled type is frozen, the expander generates stream\n+            --  and controlled-type support routines. If the freeze is caused\n+            --  by the stand-alone body of Initialize, Adjust, or Finalize, the\n+            --  expander will end up using the wrong version of these routines,\n+            --  as the body has not been processed yet. To remedy this, detect\n+            --  a late controlled primitive and create a proper spec for it.\n+            --  This ensures that the primitive will override its inherited\n+            --  counterpart before the freeze takes place.\n+\n+            --  If the declaration we just processed is a body, do not attempt\n+            --  to examine Next_Decl as the late primitive idiom can only apply\n+            --  to the first encountered body.\n+\n+            --  The spec of the late primitive is not generated in ASIS mode to\n+            --  ensure a consistent list of primitives that indicates the true\n+            --  semantic structure of the program (which is not relevant when\n+            --  generating executable code).\n+\n+            --  ??? A cleaner approach may be possible and/or this solution\n+            --  could be extended to general-purpose late primitives, TBD.\n+\n+            if not ASIS_Mode\n+              and then not Body_Seen\n+              and then not Is_Body (Decl)\n             then\n-               --  Loop through all entities in the current scope to identify\n-               --  an instance of the edge case outlined above and ignore\n-               --  freezing if it is detected.\n-\n-               declare\n-                  Curr : Entity_Id := First_Entity (Current_Scope);\n-               begin\n-                  loop\n-                     if Nkind (Curr) in N_Entity\n-                       and then Depends_On_Private (Curr)\n-                     then\n-                        Ignore_Freezing := True;\n-                        exit;\n-                     end if;\n-\n-                     exit when Last_Entity (Current_Scope) = Curr;\n-                     Curr := Next_Entity (Curr);\n-                  end loop;\n-               end;\n-            end if;\n-\n-            if not Ignore_Freezing then\n-\n-               --  When a controlled type is frozen, the expander generates\n-               --  stream and controlled-type support routines. If the freeze\n-               --  is caused by the stand-alone body of Initialize, Adjust, or\n-               --  Finalize, the expander will end up using the wrong version\n-               --  of these routines, as the body has not been processed yet.\n-               --  To remedy this, detect a late controlled primitive and\n-               --  create a proper spec for it. This ensures that the primitive\n-               --  will override its inherited counterpart before the freeze\n-               --  takes place.\n-\n-               --  If the declaration we just processed is a body, do not\n-               --  attempt to examine Next_Decl as the late primitive idiom can\n-               --  only apply to the first encountered body.\n-\n-               --  The spec of the late primitive is not generated in ASIS mode\n-               --  to ensure a consistent list of primitives that indicates the\n-               --  true semantic structure of the program (which is not\n-               --  relevant when generating executable code).\n-\n-               --  ??? A cleaner approach may be possible and/or this solution\n-               --  could be extended to general-purpose late primitives, TBD.\n-\n-               if not ASIS_Mode\n-                 and then not Body_Seen\n-                 and then not Is_Body (Decl)\n-               then\n-                  Body_Seen := True;\n+               Body_Seen := True;\n \n-                  if Nkind (Next_Decl) = N_Subprogram_Body then\n-                     Handle_Late_Controlled_Primitive (Next_Decl);\n-                  end if;\n+               if Nkind (Next_Decl) = N_Subprogram_Body then\n+                  Handle_Late_Controlled_Primitive (Next_Decl);\n                end if;\n+            end if;\n \n-               Adjust_Decl;\n+            Adjust_Decl;\n \n-               --  The generated body of an expression function does not\n-               --  freeze, unless it is a completion, in which case only the\n-               --  expression itself freezes. This is handled when the body\n-               --  itself is analyzed (see Freeze_Expr_Types, sem_ch6.adb).\n+            --  The generated body of an expression function does not freeze,\n+            --  unless it is a completion, in which case only the expression\n+            --  itself freezes. This is handled when the body itself is\n+            --  analyzed (see Freeze_Expr_Types, sem_ch6.adb).\n \n-               Freeze_All (Freeze_From, Decl);\n-               Freeze_From := Last_Entity (Current_Scope);\n-            end if;\n+            Freeze_All (Freeze_From, Decl);\n+            Freeze_From := Last_Entity (Current_Scope);\n          end if;\n \n          Decl := Next_Decl;"}, {"sha": "ddb70384394f29b95a42e3702764954e304fd963", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "patch": "@@ -4295,6 +4295,7 @@ package body Sem_Ch4 is\n       Comp          : Entity_Id;\n       Has_Candidate : Boolean := False;\n       In_Scope      : Boolean;\n+      Is_Private_Op : Boolean;\n       Parent_N      : Node_Id;\n       Pent          : Entity_Id := Empty;\n       Prefix_Type   : Entity_Id;\n@@ -4825,14 +4826,15 @@ package body Sem_Ch4 is\n \n          --  Find visible operation with given name. For a protected type,\n          --  the possible candidates are discriminants, entries or protected\n-         --  procedures. For a task type, the set can only include entries or\n+         --  subprograms. For a task type, the set can only include entries or\n          --  discriminants if the task type is not an enclosing scope. If it\n          --  is an enclosing scope (e.g. in an inner task) then all entities\n          --  are visible, but the prefix must denote the enclosing scope, i.e.\n          --  can only be a direct name or an expanded name.\n \n          Set_Etype (Sel, Any_Type);\n          In_Scope := In_Open_Scopes (Prefix_Type);\n+         Is_Private_Op := False;\n \n          while Present (Comp) loop\n \n@@ -4845,6 +4847,9 @@ package body Sem_Ch4 is\n                             or else Comp /= First_Private_Entity (Type_To_Use))\n                then\n                   Add_One_Interp (Sel, Comp, Etype (Comp));\n+                  if Comp = First_Private_Entity (Type_To_Use) then\n+                     Is_Private_Op := True;\n+                  end if;\n \n                   --  If the prefix is tagged, the correct interpretation may\n                   --  lie in the primitive or class-wide operations of the\n@@ -4924,6 +4929,12 @@ package body Sem_Ch4 is\n             then\n                null;\n \n+            elsif Is_Protected_Type (Prefix_Type)\n+              and then Is_Overloadable (Entity (Sel))\n+              and then not Is_Private_Op\n+            then\n+               null;\n+\n             else\n                Error_Msg_NE\n                  (\"invalid reference to internal operation of some object of \""}, {"sha": "33282a0a698b89acd73d728cda71ea48a931c5cd", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "patch": "@@ -3857,8 +3857,7 @@ package body Sem_Ch5 is\n                         Set_Etype (R_Copy, It.Typ);\n \n                      else\n-                        Error_Msg_N\n-                          (\"ambiguous domain of iteration\", R_Copy);\n+                        Error_Msg_N (\"ambiguous domain of iteration\", R_Copy);\n                      end if;\n                   end if;\n                end if;"}, {"sha": "41f1e530f955997a5496a4101f01b0116b18217d", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 15, "deletions": 32, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "patch": "@@ -734,21 +734,6 @@ package body Sem_Ch6 is\n          Subtype_Ind : constant Node_Id :=\n                          Object_Definition (Original_Node (Obj_Decl));\n \n-         R_Type_Is_Anon_Access : constant Boolean :=\n-             Ekind_In (R_Type,\n-                       E_Anonymous_Access_Subprogram_Type,\n-                       E_Anonymous_Access_Protected_Subprogram_Type,\n-                       E_Anonymous_Access_Type);\n-         --  True if return type of the function is an anonymous access type\n-         --  Can't we make Is_Anonymous_Access_Type in einfo ???\n-\n-         R_Stm_Type_Is_Anon_Access : constant Boolean :=\n-             Ekind_In (R_Stm_Type,\n-                       E_Anonymous_Access_Subprogram_Type,\n-                       E_Anonymous_Access_Protected_Subprogram_Type,\n-                       E_Anonymous_Access_Type);\n-         --  True if type of the return object is an anonymous access type\n-\n          procedure Error_No_Match (N : Node_Id);\n          --  Output error messages for case where types do not statically\n          --  match. N is the location for the messages.\n@@ -783,10 +768,9 @@ package body Sem_Ch6 is\n          --  \"access T\", and that the subtypes statically match:\n          --   if this is an access to subprogram the signatures must match.\n \n-         if R_Type_Is_Anon_Access then\n-            if R_Stm_Type_Is_Anon_Access then\n-               if\n-                 Ekind (Designated_Type (R_Stm_Type)) /= E_Subprogram_Type\n+         if Is_Anonymous_Access_Type (R_Type) then\n+            if Is_Anonymous_Access_Type (R_Stm_Type) then\n+               if Ekind (Designated_Type (R_Stm_Type)) /= E_Subprogram_Type\n                then\n                   if Base_Type (Designated_Type (R_Stm_Type)) /=\n                      Base_Type (Designated_Type (R_Type))\n@@ -796,11 +780,11 @@ package body Sem_Ch6 is\n                   end if;\n \n                else\n-                  --  For two anonymous access to subprogram types, the\n-                  --  types themselves must be type conformant.\n+                  --  For two anonymous access to subprogram types, the types\n+                  --  themselves must be type conformant.\n \n                   if not Conforming_Types\n-                    (R_Stm_Type, R_Type, Fully_Conformant)\n+                           (R_Stm_Type, R_Type, Fully_Conformant)\n                   then\n                      Error_No_Match (Subtype_Ind);\n                   end if;\n@@ -813,10 +797,11 @@ package body Sem_Ch6 is\n          --  If the return object is of an anonymous access type, then report\n          --  an error if the function's result type is not also anonymous.\n \n-         elsif R_Stm_Type_Is_Anon_Access then\n-            pragma Assert (not R_Type_Is_Anon_Access);\n-            Error_Msg_N (\"anonymous access not allowed for function with \"\n-                         & \"named access result\", Subtype_Ind);\n+         elsif Is_Anonymous_Access_Type (R_Stm_Type) then\n+            pragma Assert (not Is_Anonymous_Access_Type (R_Type));\n+            Error_Msg_N\n+              (\"anonymous access not allowed for function with named access \"\n+               & \"result\", Subtype_Ind);\n \n          --  Subtype indication case: check that the return object's type is\n          --  covered by the result type, and that the subtypes statically match\n@@ -838,18 +823,16 @@ package body Sem_Ch6 is\n \n             if Is_Access_Type (R_Type)\n               and then\n-               (Can_Never_Be_Null (R_Type)\n-                 or else Null_Exclusion_Present (Parent (Scope_Id))) /=\n-                                              Can_Never_Be_Null (R_Stm_Type)\n+                (Can_Never_Be_Null (R_Type)\n+                  or else Null_Exclusion_Present (Parent (Scope_Id))) /=\n+                            Can_Never_Be_Null (R_Stm_Type)\n             then\n                Error_No_Match (Subtype_Ind);\n             end if;\n \n             --  AI05-103: for elementary types, subtypes must statically match\n \n-            if Is_Constrained (R_Type)\n-              or else Is_Access_Type (R_Type)\n-            then\n+            if Is_Constrained (R_Type) or else Is_Access_Type (R_Type) then\n                if not Subtypes_Statically_Match (R_Stm_Type, R_Type) then\n                   Error_No_Match (Subtype_Ind);\n                end if;"}, {"sha": "0029c6a80a80bbcd545fa55a40bb4b98539130bf", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 143, "deletions": 11, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "patch": "@@ -13815,9 +13815,10 @@ package body Sem_Prag is\n \n                if Nkind (Stmt) = N_Pragma then\n                   if Pragma_Name (Stmt) = Pname then\n-                     Error_Msg_Name_1 := Pname;\n-                     Error_Msg_Sloc   := Sloc (Stmt);\n-                     Error_Msg_N (\"pragma % duplicates pragma declared#\", N);\n+                     Duplication_Error\n+                       (Prag => N,\n+                        Prev => Stmt);\n+                     raise Pragma_Exit;\n                   end if;\n \n                --  Skip internally generated code. Note that derived type\n@@ -15321,9 +15322,10 @@ package body Sem_Prag is\n \n                if Nkind (Stmt) = N_Pragma then\n                   if Pragma_Name (Stmt) = Pname then\n-                     Error_Msg_Name_1 := Pname;\n-                     Error_Msg_Sloc   := Sloc (Stmt);\n-                     Error_Msg_N (\"pragma % duplicates pragma declared#\", N);\n+                     Duplication_Error\n+                       (Prag => N,\n+                        Prev => Stmt);\n+                     raise Pragma_Exit;\n                   end if;\n \n                --  Task unit declared without a definition cannot be subject to\n@@ -17828,6 +17830,134 @@ package body Sem_Prag is\n                Opt.No_Elab_Code_All_Pragma := N;\n             end if;\n \n+         --------------------------\n+         -- No_Heap_Finalization --\n+         --------------------------\n+\n+         --  pragma No_Heap_Finalization [ (first_subtype_LOCAL_NAME) ];\n+\n+         when Pragma_No_Heap_Finalization => No_Heap_Finalization : declare\n+            Context : constant Node_Id := Parent (N);\n+            Typ_Arg : constant Node_Id := Get_Pragma_Arg (Arg1);\n+            Prev    : Node_Id;\n+            Typ     : Entity_Id;\n+\n+         begin\n+            GNAT_Pragma;\n+            Check_No_Identifiers;\n+\n+            --  The pragma appears in a configuration file\n+\n+            if No (Context) then\n+               Check_Arg_Count (0);\n+               Check_Valid_Configuration_Pragma;\n+\n+               --  Detect a duplicate pragma\n+\n+               if Present (No_Heap_Finalization_Pragma) then\n+                  Duplication_Error\n+                    (Prag => N,\n+                     Prev => No_Heap_Finalization_Pragma);\n+                  raise Pragma_Exit;\n+               end if;\n+\n+               No_Heap_Finalization_Pragma := N;\n+\n+            --  Otherwise the pragma should be associated with a library-level\n+            --  named access-to-object type.\n+\n+            else\n+               Check_Arg_Count (1);\n+               Check_Arg_Is_Local_Name (Arg1);\n+\n+               Find_Type (Typ_Arg);\n+               Typ := Entity (Typ_Arg);\n+\n+               --  The type being subjected to the pragma is erroneous\n+\n+               if Typ = Any_Type then\n+                  Error_Pragma (\"cannot find type referenced by pragma %\");\n+\n+               --  The pragma is applied to an incomplete or generic formal\n+               --  type way too early.\n+\n+               elsif Rep_Item_Too_Early (Typ, N) then\n+                  return;\n+\n+               else\n+                  Typ := Underlying_Type (Typ);\n+               end if;\n+\n+               --  The pragma must apply to an access-to-object type\n+\n+               if Ekind_In (Typ, E_Access_Type, E_General_Access_Type) then\n+                  null;\n+\n+               --  Give a detailed error message on all other access type kinds\n+\n+               elsif Ekind (Typ) = E_Access_Protected_Subprogram_Type then\n+                  Error_Pragma\n+                    (\"pragma % cannot apply to access protected subprogram \"\n+                     & \"type\");\n+\n+               elsif Ekind (Typ) = E_Access_Subprogram_Type then\n+                  Error_Pragma\n+                    (\"pragma % cannot apply to access subprogram type\");\n+\n+               elsif Is_Anonymous_Access_Type (Typ) then\n+                  Error_Pragma\n+                    (\"pragma % cannot apply to anonymous access type\");\n+\n+               --  Give a general error message in case the pragma applies to a\n+               --  non-access type.\n+\n+               else\n+                  Error_Pragma\n+                    (\"pragma % must apply to library level access type\");\n+               end if;\n+\n+               --  At this point the argument denotes an access-to-object type.\n+               --  Ensure that the type is declared at the library level.\n+\n+               if Is_Library_Level_Entity (Typ) then\n+                  null;\n+\n+               --  Qietly ignore an access-to-object type originally declared\n+               --  at the library level within a generic, but instantiated at\n+               --  a non-library level. As a result the access-to-object type\n+               --  \"loses\" its No_Heap_Finalization property.\n+\n+               elsif In_Instance then\n+                  raise Pragma_Exit;\n+\n+               else\n+                  Error_Pragma\n+                    (\"pragma % must apply to library level access type\");\n+               end if;\n+\n+               --  Detect a duplicate pragma\n+\n+               if Present (No_Heap_Finalization_Pragma) then\n+                  Duplication_Error\n+                    (Prag => N,\n+                     Prev => No_Heap_Finalization_Pragma);\n+                  raise Pragma_Exit;\n+\n+               else\n+                  Prev := Get_Pragma (Typ, Pragma_No_Heap_Finalization);\n+\n+                  if Present (Prev) then\n+                     Duplication_Error\n+                       (Prag => N,\n+                        Prev => Prev);\n+                     raise Pragma_Exit;\n+                  end if;\n+               end if;\n+\n+               Record_Rep_Item (Typ, N);\n+            end if;\n+         end No_Heap_Finalization;\n+\n          ---------------\n          -- No_Inline --\n          ---------------\n@@ -21402,8 +21532,9 @@ package body Sem_Prag is\n                Check_Valid_Configuration_Pragma;\n \n                if Present (SPARK_Mode_Pragma) then\n-                  Error_Msg_Sloc := Sloc (SPARK_Mode_Pragma);\n-                  Error_Msg_N (\"pragma% duplicates pragma declared#\", N);\n+                  Duplication_Error\n+                    (Prag => N,\n+                     Prev => SPARK_Mode_Pragma);\n                   raise Pragma_Exit;\n                end if;\n \n@@ -21433,9 +21564,9 @@ package body Sem_Prag is\n \n                   if Nkind (Stmt) = N_Pragma then\n                      if Pragma_Name (Stmt) = Pname then\n-                        Error_Msg_Name_1 := Pname;\n-                        Error_Msg_Sloc   := Sloc (Stmt);\n-                        Error_Msg_N (\"pragma% duplicates pragma declared#\", N);\n+                        Duplication_Error\n+                          (Prag => N,\n+                           Prev => Stmt);\n                         raise Pragma_Exit;\n                      end if;\n \n@@ -28867,6 +28998,7 @@ package body Sem_Prag is\n       Pragma_No_Return                      =>  0,\n       Pragma_No_Body                        =>  0,\n       Pragma_No_Elaboration_Code_All        =>  0,\n+      Pragma_No_Heap_Finalization           =>  0,\n       Pragma_No_Inline                      =>  0,\n       Pragma_No_Run_Time                    => -1,\n       Pragma_No_Strict_Aliasing             => -1,"}, {"sha": "8b78008c573ba8c08db331eca21cc32f9d8bc780", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "patch": "@@ -12846,6 +12846,7 @@ package body Sem_Util is\n       S : constant Ureal := Small_Value (T);\n       M : Urealp.Save_Mark;\n       R : Boolean;\n+\n    begin\n       M := Urealp.Mark;\n       R := (U = UR_Trunc (U / S) * S);\n@@ -17491,6 +17492,32 @@ package body Sem_Util is\n       end if;\n    end New_Requires_Transient_Scope;\n \n+   --------------------------\n+   -- No_Heap_Finalization --\n+   --------------------------\n+\n+   function No_Heap_Finalization (Typ : Entity_Id) return Boolean is\n+   begin\n+      if Ekind_In (Typ, E_Access_Type, E_General_Access_Type)\n+        and then Is_Library_Level_Entity (Typ)\n+      then\n+         --  A global No_Heap_Finalization pragma applies to all library-level\n+         --  named access-to-object types.\n+\n+         if Present (No_Heap_Finalization_Pragma) then\n+            return True;\n+\n+         --  The library-level named access-to-object type itself is subject to\n+         --  pragma No_Heap_Finalization.\n+\n+         elsif Present (Get_Pragma (Typ, Pragma_No_Heap_Finalization)) then\n+            return True;\n+         end if;\n+      end if;\n+\n+      return False;\n+   end No_Heap_Finalization;\n+\n    -----------------------\n    -- Normalize_Actuals --\n    -----------------------"}, {"sha": "7c0affc9ba8d3cc09b77f64093a25d8a04c2cf45", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "patch": "@@ -1983,6 +1983,9 @@ package Sem_Util is\n    --  Note that the result produced is always an expression, not a parameter\n    --  association node, even if named notation was used.\n \n+   function No_Heap_Finalization (Typ : Entity_Id) return Boolean;\n+   --  Determine whether type Typ is subject to pragma No_Heap_Finalization\n+\n    procedure Normalize_Actuals\n      (N       : Node_Id;\n       S       : Entity_Id;"}, {"sha": "33ba6a57c412914f8b38f678f64f0cdcfe3908c7", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=d1eb8a82b2851aba9cc35cc698be7dbf4f80ec9a", "patch": "@@ -433,6 +433,7 @@ package Snames is\n    Name_License                        : constant Name_Id := N + $; -- GNAT\n    Name_Locking_Policy                 : constant Name_Id := N + $;\n    Name_Loop_Optimize                  : constant Name_Id := N + $; -- GNAT\n+   Name_No_Heap_Finalization           : constant Name_Id := N + $; -- GNAT\n    Name_No_Run_Time                    : constant Name_Id := N + $; -- GNAT\n    Name_No_Strict_Aliasing             : constant Name_Id := N + $; -- GNAT\n    Name_No_Tagged_Streams              : constant Name_Id := N + $; -- GNAT\n@@ -1797,6 +1798,7 @@ package Snames is\n       Pragma_License,\n       Pragma_Locking_Policy,\n       Pragma_Loop_Optimize,\n+      Pragma_No_Heap_Finalization,\n       Pragma_No_Run_Time,\n       Pragma_No_Strict_Aliasing,\n       Pragma_No_Tagged_Streams,"}]}