{"sha": "fae545fb033970348210c52597a246445efe4160", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFlNTQ1ZmIwMzM5NzAzNDgyMTBjNTI1OTdhMjQ2NDQ1ZWZlNDE2MA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-03-25T13:41:51Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-05-05T13:46:06Z"}, "message": "rewrite hybrid SLP detection\n\nThis rewrites hybrid SLP detection to be simpler and cope with\ngroup size changes in the SLP graph.  In particular detection\nworks starting from non-SLP stmts following use->def chains\nrather than walking the SLP graph and following def->use chains.\n\nIt's all temporary of course since non-SLP and thus hybrid SLP\nwill go away.\n\n2020-05-05  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-slp.c (struct vdhs_data): New.\n\t(vect_detect_hybrid_slp): New walker.\n\t(vect_detect_hybrid_slp): Rewrite.", "tree": {"sha": "5288ad4cadc1df65788165a571c9e2e339e1f2fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5288ad4cadc1df65788165a571c9e2e339e1f2fc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fae545fb033970348210c52597a246445efe4160", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fae545fb033970348210c52597a246445efe4160", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fae545fb033970348210c52597a246445efe4160", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fae545fb033970348210c52597a246445efe4160/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fbf43b9bc060e2904abe64e870868b9a4bfce13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fbf43b9bc060e2904abe64e870868b9a4bfce13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fbf43b9bc060e2904abe64e870868b9a4bfce13"}], "stats": {"total": 193, "additions": 62, "deletions": 131}, "files": [{"sha": "e39ede9077f624b8a0f43234d543dbc6d9b70177", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae545fb033970348210c52597a246445efe4160/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae545fb033970348210c52597a246445efe4160/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fae545fb033970348210c52597a246445efe4160", "patch": "@@ -1,3 +1,9 @@\n+2020-05-05  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-slp.c (struct vdhs_data): New.\n+\t(vect_detect_hybrid_slp): New walker.\n+\t(vect_detect_hybrid_slp): Rewrite.\n+\n 2020-05-05  Richard Biener  <rguenther@suse.de>\n \n \tPR ipa/94947"}, {"sha": "f83b568dcc11f19e0e357da3965a3194614b8e0d", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 56, "deletions": 131, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae545fb033970348210c52597a246445efe4160/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae545fb033970348210c52597a246445efe4160/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=fae545fb033970348210c52597a246445efe4160", "patch": "@@ -2566,178 +2566,103 @@ vect_make_slp_decision (loop_vec_info loop_vinfo)\n   return (decided_to_slp > 0);\n }\n \n-\n-/* Find stmts that must be both vectorized and SLPed (since they feed stmts that\n-   can't be SLPed) in the tree rooted at NODE.  Mark such stmts as HYBRID.  */\n-\n-static void\n-vect_detect_hybrid_slp_stmts (loop_vec_info loop_vinfo, slp_tree node,\n-\t\t\t      unsigned i, slp_vect_type stype,\n-\t\t\t      hash_map<slp_tree, unsigned> &visited)\n+/* Private data for vect_detect_hybrid_slp.  */\n+struct vdhs_data\n {\n-  stmt_vec_info stmt_vinfo = SLP_TREE_SCALAR_STMTS (node)[i];\n-  imm_use_iterator imm_iter;\n-  gimple *use_stmt;\n-  stmt_vec_info use_vinfo;\n-  slp_tree child;\n-  int j;\n-\n-  /* We need to union stype over the incoming graph edges but we still\n-     want to limit recursion to stay O(N+E).  */\n-  unsigned visited_cnt = ++visited.get_or_insert (node);\n-  gcc_assert (visited_cnt <= node->refcnt);\n-  bool only_edge = (visited_cnt != node->refcnt);\n-\n-  /* Propagate hybrid down the SLP tree.  */\n-  if (stype == hybrid)\n-    ;\n-  else if (HYBRID_SLP_STMT (stmt_vinfo))\n-    stype = hybrid;\n-  else if (!only_edge)\n-    {\n-      /* Check if a pure SLP stmt has uses in non-SLP stmts.  */\n-      gcc_checking_assert (PURE_SLP_STMT (stmt_vinfo));\n-      /* If we get a pattern stmt here we have to use the LHS of the\n-         original stmt for immediate uses.  */\n-      gimple *stmt = vect_orig_stmt (stmt_vinfo)->stmt;\n-      tree def;\n-      if (gimple_code (stmt) == GIMPLE_PHI)\n-\tdef = gimple_phi_result (stmt);\n-      else\n-\tdef = SINGLE_SSA_TREE_OPERAND (stmt, SSA_OP_DEF);\n-      if (def)\n-\tFOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)\n-\t  {\n-\t    use_vinfo = loop_vinfo->lookup_stmt (use_stmt);\n-\t    if (!use_vinfo)\n-\t      continue;\n-\t    use_vinfo = vect_stmt_to_vectorize (use_vinfo);\n-\t    if (!STMT_SLP_TYPE (use_vinfo)\n-\t\t&& (STMT_VINFO_RELEVANT (use_vinfo)\n-\t\t    || VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (use_vinfo)))\n-\t\t&& !(gimple_code (use_stmt) == GIMPLE_PHI\n-\t\t     && STMT_VINFO_DEF_TYPE (use_vinfo) == vect_reduction_def))\n-\t      {\n-\t\tif (dump_enabled_p ())\n-\t\t  dump_printf_loc (MSG_NOTE, vect_location, \"use of SLP \"\n-\t\t\t\t   \"def in non-SLP stmt: %G\", use_stmt);\n-\t\tstype = hybrid;\n-\t      }\n-\t  }\n-    }\n-\n-  if (stype == hybrid\n-      && !HYBRID_SLP_STMT (stmt_vinfo))\n-    {\n-      if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, vect_location, \"marking hybrid: %G\",\n-\t\t\t stmt_vinfo->stmt);\n-      STMT_SLP_TYPE (stmt_vinfo) = hybrid;\n-    }\n-\n-  if (!only_edge)\n-    FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), j, child)\n-      if (SLP_TREE_DEF_TYPE (child) != vect_external_def\n-\t  && SLP_TREE_DEF_TYPE (child) != vect_constant_def)\n-\tvect_detect_hybrid_slp_stmts (loop_vinfo, child, i, stype, visited);\n-}\n+  loop_vec_info loop_vinfo;\n+  vec<stmt_vec_info> *worklist;\n+};\n \n-/* Helpers for vect_detect_hybrid_slp walking pattern stmt uses.  */\n+/* Walker for walk_gimple_op.  */\n \n static tree\n-vect_detect_hybrid_slp_1 (tree *tp, int *, void *data)\n+vect_detect_hybrid_slp (tree *tp, int *, void *data)\n {\n   walk_stmt_info *wi = (walk_stmt_info *)data;\n-  loop_vec_info loop_vinfo = (loop_vec_info) wi->info;\n+  vdhs_data *dat = (vdhs_data *)wi->info;\n \n   if (wi->is_lhs)\n     return NULL_TREE;\n \n-  stmt_vec_info def_stmt_info = loop_vinfo->lookup_def (*tp);\n-  if (def_stmt_info && PURE_SLP_STMT (def_stmt_info))\n+  stmt_vec_info def_stmt_info = dat->loop_vinfo->lookup_def (*tp);\n+  if (!def_stmt_info)\n+    return NULL_TREE;\n+  def_stmt_info = vect_stmt_to_vectorize (def_stmt_info);\n+  if (PURE_SLP_STMT (def_stmt_info))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location, \"marking hybrid: %G\",\n \t\t\t def_stmt_info->stmt);\n       STMT_SLP_TYPE (def_stmt_info) = hybrid;\n+      dat->worklist->safe_push (def_stmt_info);\n     }\n \n   return NULL_TREE;\n }\n \n-static tree\n-vect_detect_hybrid_slp_2 (gimple_stmt_iterator *gsi, bool *handled,\n-\t\t\t  walk_stmt_info *wi)\n-{\n-  loop_vec_info loop_vinfo = (loop_vec_info) wi->info;\n-  stmt_vec_info use_vinfo = loop_vinfo->lookup_stmt (gsi_stmt (*gsi));\n-  /* If the stmt is in a SLP instance then this isn't a reason\n-     to mark use definitions in other SLP instances as hybrid.  */\n-  if (! STMT_SLP_TYPE (use_vinfo)\n-      && (STMT_VINFO_RELEVANT (use_vinfo)\n-\t  || VECTORIZABLE_CYCLE_DEF (STMT_VINFO_DEF_TYPE (use_vinfo)))\n-      && ! (gimple_code (gsi_stmt (*gsi)) == GIMPLE_PHI\n-\t    && STMT_VINFO_DEF_TYPE (use_vinfo) == vect_reduction_def))\n-    ;\n-  else\n-    *handled = true;\n-  return NULL_TREE;\n-}\n-\n /* Find stmts that must be both vectorized and SLPed.  */\n \n void\n vect_detect_hybrid_slp (loop_vec_info loop_vinfo)\n {\n-  unsigned int i;\n-  vec<slp_instance> slp_instances = LOOP_VINFO_SLP_INSTANCES (loop_vinfo);\n-  slp_instance instance;\n-\n   DUMP_VECT_SCOPE (\"vect_detect_hybrid_slp\");\n \n-  /* First walk all pattern stmt in the loop and mark defs of uses as\n-     hybrid because immediate uses in them are not recorded.  */\n-  for (i = 0; i < LOOP_VINFO_LOOP (loop_vinfo)->num_nodes; ++i)\n+  /* All stmts participating in SLP are marked pure_slp, all other\n+     stmts are loop_vect.\n+     First collect all loop_vect stmts into a worklist.  */\n+  auto_vec<stmt_vec_info> worklist;\n+  for (unsigned i = 0; i < LOOP_VINFO_LOOP (loop_vinfo)->num_nodes; ++i)\n     {\n       basic_block bb = LOOP_VINFO_BBS (loop_vinfo)[i];\n+      for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\t{\n+\t  gphi *phi = gsi.phi ();\n+\t  stmt_vec_info stmt_info = loop_vinfo->lookup_stmt (phi);\n+\t  if (!STMT_SLP_TYPE (stmt_info) && STMT_VINFO_RELEVANT (stmt_info))\n+\t    worklist.safe_push (stmt_info);\n+\t}\n       for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n \t   gsi_next (&gsi))\n \t{\n \t  gimple *stmt = gsi_stmt (gsi);\n \t  stmt_vec_info stmt_info = loop_vinfo->lookup_stmt (stmt);\n \t  if (STMT_VINFO_IN_PATTERN_P (stmt_info))\n \t    {\n-\t      walk_stmt_info wi;\n-\t      memset (&wi, 0, sizeof (wi));\n-\t      wi.info = loop_vinfo;\n-\t      gimple_stmt_iterator gsi2\n-\t\t= gsi_for_stmt (STMT_VINFO_RELATED_STMT (stmt_info)->stmt);\n-\t      walk_gimple_stmt (&gsi2, vect_detect_hybrid_slp_2,\n-\t\t\t\tvect_detect_hybrid_slp_1, &wi);\n-\t      walk_gimple_seq (STMT_VINFO_PATTERN_DEF_SEQ (stmt_info),\n-\t\t\t       vect_detect_hybrid_slp_2,\n-\t\t\t       vect_detect_hybrid_slp_1, &wi);\n+\t      for (gimple_stmt_iterator gsi2\n+\t\t     = gsi_start (STMT_VINFO_PATTERN_DEF_SEQ (stmt_info));\n+\t\t   !gsi_end_p (gsi2); gsi_next (&gsi2))\n+\t\t{\n+\t\t  stmt_vec_info patt_info\n+\t\t    = loop_vinfo->lookup_stmt (gsi_stmt (gsi2));\n+\t\t  if (!STMT_SLP_TYPE (patt_info)\n+\t\t      && STMT_VINFO_RELEVANT (patt_info))\n+\t\t    worklist.safe_push (patt_info);\n+\t\t}\n+\t      stmt_info = STMT_VINFO_RELATED_STMT (stmt_info);\n \t    }\n+\t  if (!STMT_SLP_TYPE (stmt_info) && STMT_VINFO_RELEVANT (stmt_info))\n+\t    worklist.safe_push (stmt_info);\n \t}\n     }\n \n-  /* Then walk the SLP instance trees marking stmts with uses in\n-     non-SLP stmts as hybrid, also propagating hybrid down the\n-     SLP tree, collecting the above info on-the-fly.  */\n-  for (unsigned j = 0;; ++j)\n+  /* Now we have a worklist of non-SLP stmts, follow use->def chains and\n+     mark any SLP vectorized stmt as hybrid.\n+     ???  We're visiting def stmts N times (once for each non-SLP and\n+     once for each hybrid-SLP use).  */\n+  walk_stmt_info wi;\n+  vdhs_data dat;\n+  dat.worklist = &worklist;\n+  dat.loop_vinfo = loop_vinfo;\n+  memset (&wi, 0, sizeof (wi));\n+  wi.info = (void *)&dat;\n+  while (!worklist.is_empty ())\n     {\n-      hash_map<slp_tree, unsigned> visited;\n-      bool any = false;\n-      FOR_EACH_VEC_ELT (slp_instances, i, instance)\n-\tif (j < SLP_INSTANCE_GROUP_SIZE (instance))\n-\t  {\n-\t    any = true;\n-\t    vect_detect_hybrid_slp_stmts (loop_vinfo,\n-\t\t\t\t\t  SLP_INSTANCE_TREE (instance),\n-\t\t\t\t\t  j, pure_slp, visited);\n-\t  }\n-      if (!any)\n-\tbreak;\n+      stmt_vec_info stmt_info = worklist.pop ();\n+      /* Since SSA operands are not set up for pattern stmts we need\n+\t to use walk_gimple_op.  */\n+      wi.is_lhs = 0;\n+      walk_gimple_op (stmt_info->stmt, vect_detect_hybrid_slp, &wi);\n     }\n }\n "}]}