{"sha": "7e1957a40d722beba8d9d002c7d15b01a18e7736", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2UxOTU3YTQwZDcyMmJlYmE4ZDlkMDAyYzdkMTViMDFhMThlNzczNg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2005-03-18T11:47:18Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-03-18T11:47:18Z"}, "message": "ada-tree.h: (DECL_RENAMING_GLOBAL_P): New predicate.\n\n2005-03-17  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* ada-tree.h: (DECL_RENAMING_GLOBAL_P): New predicate.\n\t(DECL_RENAMED_OBJECT): New accessor macro.\n\t(SET_DECL_RENAMED_OBJECT): New setter macro.\n\n\t* decl.c (gnat_to_gnu_entity) <E_Variable>: Stabilize the renamed\n\tobject in all cases.  Attach the renamed object to the VAR_DECL.\n\t(gnat_to_gnu_field): Do not lift the record wrapper if the size of the\n\tfield is not prescribed.\n\n\t* misc.c (gnat_handle_option): Handle -gnatO separately.\n\t(gnat_print_decl) <VAR_DECL>: New case.\n\tPrint the DECL_RENAMED_OBJECT node.\n\n\t* lang.opt:  Declare separate -gnatO option.\n\n\t* trans.c (tree_transform) <N_Identifier>: If the object is a renaming\n\tpointer, replace it with the renamed object.\n\t<N_Validate_Unchecked_Conversion>: Warn for a conversion to a fat\n\tpointer type if the source is not a fat pointer type whose underlying\n\tarray has the same non-zero alias set as that of the destination array.\n\nFrom-SVN: r96660", "tree": {"sha": "65b5f248d06750565cc817641650223fd0f8922a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/65b5f248d06750565cc817641650223fd0f8922a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e1957a40d722beba8d9d002c7d15b01a18e7736", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e1957a40d722beba8d9d002c7d15b01a18e7736", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e1957a40d722beba8d9d002c7d15b01a18e7736", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e1957a40d722beba8d9d002c7d15b01a18e7736/comments", "author": null, "committer": null, "parents": [{"sha": "e602394c38b7ad5053769e2ff03550fd5b5d412a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e602394c38b7ad5053769e2ff03550fd5b5d412a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e602394c38b7ad5053769e2ff03550fd5b5d412a"}], "stats": {"total": 145, "additions": 75, "deletions": 70}, "files": [{"sha": "4ea4b27a914433ae1d7743971db3003205af9bea", "filename": "gcc/ada/ada-tree.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e1957a40d722beba8d9d002c7d15b01a18e7736/gcc%2Fada%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e1957a40d722beba8d9d002c7d15b01a18e7736/gcc%2Fada%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fada-tree.h?ref=7e1957a40d722beba8d9d002c7d15b01a18e7736", "patch": "@@ -260,6 +260,9 @@ struct lang_type GTY(()) {tree t; };\n /* Nonzero in a PARM_DECL if we are to pass by descriptor.  */\n #define DECL_BY_DESCRIPTOR_P(NODE) DECL_LANG_FLAG_5 (PARM_DECL_CHECK (NODE))\n \n+/* Nonzero in a VAR_DECL if it is a pointer renaming a global object.  */\n+#define DECL_RENAMING_GLOBAL_P(NODE) DECL_LANG_FLAG_5 (VAR_DECL_CHECK (NODE))\n+\n /* In a CONST_DECL, points to a VAR_DECL that is allocatable to\n    memory.  Used when a scalar constant is aliased or has its\n    address taken.  */\n@@ -275,6 +278,14 @@ struct lang_type GTY(()) {tree t; };\n #define SET_DECL_ORIGINAL_FIELD(NODE, X) \\\n   SET_DECL_LANG_SPECIFIC (FIELD_DECL_CHECK (NODE), X)\n \n+/* In a VAR_DECL, points to the object being renamed if the VAR_DECL is a\n+   renaming pointer, otherwise 0.  Note that this object is guaranteed to\n+   be protected against multiple evaluations.  */\n+#define DECL_RENAMED_OBJECT(NODE) \\\n+  GET_DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE))\n+#define SET_DECL_RENAMED_OBJECT(NODE, X) \\\n+  SET_DECL_LANG_SPECIFIC (VAR_DECL_CHECK (NODE), X)\n+\n /* In a FIELD_DECL corresponding to a discriminant, contains the\n    discriminant number.  */\n #define DECL_DISCRIMINANT_NUMBER(NODE) DECL_INITIAL (FIELD_DECL_CHECK (NODE))"}, {"sha": "db806209f70c86320790eb16249a4648722d860f", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 14, "deletions": 27, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e1957a40d722beba8d9d002c7d15b01a18e7736/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e1957a40d722beba8d9d002c7d15b01a18e7736/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=7e1957a40d722beba8d9d002c7d15b01a18e7736", "patch": "@@ -498,6 +498,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tbool inner_const_flag = const_flag;\n \tbool static_p = Is_Statically_Allocated (gnat_entity);\n \ttree gnu_ext_name = NULL_TREE;\n+\ttree renamed_obj = NULL_TREE;\n \n \tif (Present (Renamed_Object (gnat_entity)) && !definition)\n \t  {\n@@ -777,30 +778,22 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    /* Otherwise, make this into a constant pointer to the object we\n \t       are to rename.\n \n-\t       Stabilize it if we are not at the global level since in this\n-\t       case the renaming evaluation may directly dereference the\n-\t       initial value we make here instead of the pointer we will\n-\t       assign it to.  We don't want variables in the expression to be\n-\t       evaluated every time the renaming is used, since the value of\n-\t       these variables may change in between.\n-\n-\t       If we are at the global level and the value is not constant,\n-\t       create_var_decl generates a mere elaboration assignment and\n-\t       does not attach the initial expression to the declaration.\n-\t       There is no possible direct initial-value dereference then.  */\n+\t       Stabilize it since in this case the renaming evaluation may\n+\t       directly dereference the initial value we make here instead\n+\t       of the pointer we will assign it to.  We don't want variables\n+\t       in the expression to be evaluated every time the renaming is\n+\t       used, since their value may change in between.  */\n \t    else\n \t      {\n+\t\tbool has_side_effects = TREE_SIDE_EFFECTS (gnu_expr);\n \t\tinner_const_flag = TREE_READONLY (gnu_expr);\n \t\tconst_flag = true;\n \t\tgnu_type = build_reference_type (gnu_type);\n-\t\tgnu_expr = build_unary_op (ADDR_EXPR, gnu_type, gnu_expr);\n+\t\trenamed_obj = gnat_stabilize_reference (gnu_expr, true);\n+\t\tgnu_expr = build_unary_op (ADDR_EXPR, gnu_type, renamed_obj);\n \n \t\tif (!global_bindings_p ())\n \t\t  {\n-\t\t    bool has_side_effects = TREE_SIDE_EFFECTS (gnu_expr);\n-\n-\t\t    gnu_expr = gnat_stabilize_reference (gnu_expr, true);\n-\n \t\t    /* If the original expression had side effects, put a\n \t\t       SAVE_EXPR around this whole thing.  */\n \t\t    if (has_side_effects)\n@@ -1063,6 +1056,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t    static_p, attr_list, gnat_entity);\n \tDECL_BY_REF_P (gnu_decl) = used_by_ref;\n \tDECL_POINTS_TO_READONLY_P (gnu_decl) = used_by_ref && inner_const_flag;\n+\tif (TREE_CODE (gnu_decl) == VAR_DECL && renamed_obj)\n+\t  {\n+\t    SET_DECL_RENAMED_OBJECT (gnu_decl, renamed_obj);\n+\t    DECL_RENAMING_GLOBAL_P (gnu_decl) = global_bindings_p ();\n+\t  }\n \n \t/* If we have an address clause and we've made this indirect, it's\n \t   not enough to merely mark the type as volatile since volatile\n@@ -5140,17 +5138,6 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n     gnu_size = validate_size (Esize (gnat_field), gnu_field_type,\n \t\t\t      gnat_field, FIELD_DECL, false, true);\n \n-  /* If the field's type is justified modular and the size of the packed\n-     array it wraps is the same as that of the field, we can make the field\n-     the type of the inner object.  Note that we may need to do so if the\n-     record is packed or the field has a component clause, but these cases\n-     are handled later.  */\n-  if (TREE_CODE (gnu_field_type) == RECORD_TYPE\n-      && TYPE_JUSTIFIED_MODULAR_P (gnu_field_type)\n-      && tree_int_cst_equal (TYPE_SIZE (gnu_field_type),\n-\t\t\t     TYPE_ADA_SIZE (gnu_field_type)))\n-    gnu_field_type = TREE_TYPE (TYPE_FIELDS (gnu_field_type));\n-\n   /* If we are packing this record, have a specified size that's smaller than\n      that of the field type, or a position is specified, and the field type\n      is also a record that's BLKmode and with a small constant size, see if"}, {"sha": "4f60bf96587a661fded5c01f4c9d3fa021a8d4fa", "filename": "gcc/ada/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e1957a40d722beba8d9d002c7d15b01a18e7736/gcc%2Fada%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e1957a40d722beba8d9d002c7d15b01a18e7736/gcc%2Fada%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flang.opt?ref=7e1957a40d722beba8d9d002c7d15b01a18e7736", "patch": "@@ -65,6 +65,10 @@ gant\n Ada Joined Undocumented\n ; Catches typos\n \n+gnatO\n+Ada Separate\n+; Sets name of output ALI file (internal switch)\n+\n gnat\n Ada Joined\n -gnat<options>\tSpecify options to GNAT"}, {"sha": "03b156c25a3caea87a19ff1c9bc426d452ac1fc2", "filename": "gcc/ada/misc.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e1957a40d722beba8d9d002c7d15b01a18e7736/gcc%2Fada%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e1957a40d722beba8d9d002c7d15b01a18e7736/gcc%2Fada%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmisc.c?ref=7e1957a40d722beba8d9d002c7d15b01a18e7736", "patch": "@@ -259,7 +259,6 @@ gnat_handle_option (size_t scode, const char *arg, int value ATTRIBUTE_UNUSED)\n   const struct cl_option *option = &cl_options[scode];\n   enum opt_code code = (enum opt_code) scode;\n   char *q;\n-  unsigned int i;\n \n   if (arg == NULL && (option->flags & (CL_JOINED | CL_SEPARATE)))\n     {\n@@ -314,17 +313,13 @@ gnat_handle_option (size_t scode, const char *arg, int value ATTRIBUTE_UNUSED)\n       gnat_argv[gnat_argc][0] = '-';\n       strcpy (gnat_argv[gnat_argc] + 1, arg);\n       gnat_argc++;\n+      break;\n \n-      if (arg[0] == 'O')\n-\tfor (i = 1; i < save_argc - 1; i++)\n-\t  if (!strncmp (save_argv[i], \"-gnatO\", 6))\n-\t    if (save_argv[++i][0] != '-')\n-\t      {\n-\t\t/* Preserve output filename as GCC doesn't save it for GNAT. */\n-\t\tgnat_argv[gnat_argc] = xstrdup (save_argv[i]);\n-\t\tgnat_argc++;\n-\t\tbreak;\n-\t      }\n+    case OPT_gnatO:\n+      gnat_argv[gnat_argc] = xstrdup (\"-O\");\n+      gnat_argc++;\n+      gnat_argv[gnat_argc] = xstrdup (arg);\n+      gnat_argc++;\n       break;\n     }\n \n@@ -506,7 +501,12 @@ gnat_print_decl (FILE *file, tree node, int indent)\n       break;\n \n     case FIELD_DECL:\n-      print_node (file, \"original field\", DECL_ORIGINAL_FIELD (node),\n+      print_node (file, \"original_field\", DECL_ORIGINAL_FIELD (node),\n+\t\t  indent + 4);\n+      break;\n+\n+    case VAR_DECL:\n+      print_node (file, \"renamed_object\", DECL_RENAMED_OBJECT (node),\n \t\t  indent + 4);\n       break;\n "}, {"sha": "10955e352316d47a8317f56bb5d2829d93344247", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e1957a40d722beba8d9d002c7d15b01a18e7736/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e1957a40d722beba8d9d002c7d15b01a18e7736/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=7e1957a40d722beba8d9d002c7d15b01a18e7736", "patch": "@@ -393,7 +393,7 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t      && DECL_BY_COMPONENT_PTR_P (gnu_result))))\n     {\n       bool ro = DECL_POINTS_TO_READONLY_P (gnu_result);\n-      tree initial;\n+      tree renamed_obj;\n \n       if (TREE_CODE (gnu_result) == PARM_DECL\n \t  && DECL_BY_COMPONENT_PTR_P (gnu_result))\n@@ -402,34 +402,17 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t\t\t    convert (build_pointer_type (gnu_result_type),\n \t\t\t\t     gnu_result));\n \n-      /* If the object is constant, we try to do the dereference directly\n-\t through the DECL_INITIAL.  This is actually required in order to get\n-\t correct aliasing information for renamed objects that are components\n-\t of non-aliased aggregates, because the type of the renamed object and\n-\t that of the aggregate don't alias.\n-\n-\t Note that we expect the initial value to have been stabilized.\n-\t If it contains e.g. a variable reference, we certainly don't want\n-\t to re-evaluate the variable each time the renaming is used.\n-\n-\t Stabilization is currently not performed at the global level but\n-\t create_var_decl avoids setting DECL_INITIAL if the value is not\n-\t constant then, and we get to the pointer dereference below.\n-\n-\t ??? Couldn't the aliasing issue show up again in this case ?\n-\t There is no obvious reason why not.  */\n-      else if (TREE_READONLY (gnu_result)\n-\t       && DECL_INITIAL (gnu_result)\n-\t       /* Strip possible conversion to reference type.  */\n-\t       && ((initial = TREE_CODE (DECL_INITIAL (gnu_result))\n-\t\t    == NOP_EXPR\n-\t\t    ? TREE_OPERAND (DECL_INITIAL (gnu_result), 0)\n-\t\t    : DECL_INITIAL (gnu_result), 1))\n-\t       && TREE_CODE (initial) == ADDR_EXPR\n-\t       && (TREE_CODE (TREE_OPERAND (initial, 0)) == ARRAY_REF\n-\t\t   || (TREE_CODE (TREE_OPERAND (initial, 0))\n-\t\t       == COMPONENT_REF)))\n-\tgnu_result = TREE_OPERAND (initial, 0);\n+      /* If it's a renaming pointer and we are at the right binding level,\n+\t we can reference the renamed object directly, since the renamed\n+\t expression has been protected against multiple evaluations.  */\n+      else if (TREE_CODE (gnu_result) == VAR_DECL\n+\t       && (renamed_obj = DECL_RENAMED_OBJECT (gnu_result)) != 0\n+\t       && (! DECL_RENAMING_GLOBAL_P (gnu_result)\n+\t\t   || global_bindings_p ())\n+\t       /* Make sure it's an lvalue like INDIRECT_REF.  */\n+\t       && (TREE_CODE_CLASS (TREE_CODE (renamed_obj)) == 'd'\n+\t\t   || TREE_CODE_CLASS (TREE_CODE (renamed_obj)) == 'r'))\n+\tgnu_result = renamed_obj;\n       else\n \tgnu_result = build_unary_op (INDIRECT_REF, NULL_TREE,\n \t\t\t\t     fold (gnu_result));\n@@ -746,8 +729,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n       if (CONTAINS_PLACEHOLDER_P (gnu_result))\n \t{\n \t  if (TREE_CODE (gnu_prefix) != TYPE_DECL)\n-\t    gnu_result = substitute_placeholder_in_expr (gnu_result,\n-\t\t\t\t\t\t\t gnu_expr);\n+\t    gnu_result = substitute_placeholder_in_expr (gnu_result, gnu_expr);\n \t  else\n \t    gnu_result = max_size (gnu_result, true);\n \t}\n@@ -4012,6 +3994,27 @@ gnat_to_gnu (Node_Id gnat_node)\n               (\"\\\\?or use `pragma No_Strict_Aliasing (&);`\",\n                gnat_node, Target_Type (gnat_node));\n \t  }\n+\n+\t/* The No_Strict_Aliasing flag is not propagated to the back-end for\n+\t   fat pointers so unconditionally warn in problematic cases.  */\n+\telse if (TYPE_FAT_POINTER_P (gnu_target_type))\n+\t  {\n+\t    tree array_type\n+\t      = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (gnu_target_type)));\n+\n+\t    if (get_alias_set (array_type) != 0\n+\t\t&& (!TYPE_FAT_POINTER_P (gnu_source_type)\n+\t\t    || (get_alias_set (TREE_TYPE (TREE_TYPE (TYPE_FIELDS (gnu_source_type))))\n+\t\t\t!= get_alias_set (array_type))))\n+\t      {\n+\t\tpost_error_ne\n+\t\t  (\"?possible aliasing problem for type&\",\n+\t\t   gnat_node, Target_Type (gnat_node));\n+\t\tpost_error\n+\t\t  (\"\\\\?use -fno-strict-aliasing switch for references\",\n+\t\t   gnat_node);\n+\t      }\n+\t  }\n       }\n       gnu_result = alloc_stmt_list ();\n       break;"}]}