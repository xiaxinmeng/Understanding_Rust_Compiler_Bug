{"sha": "8aec446b9825afac7364819ffa8ea00307fbaaff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFlYzQ0NmI5ODI1YWZhYzczNjQ4MTlmZmE4ZWEwMDMwN2ZiYWFmZg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-15T10:26:33Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-15T10:26:33Z"}, "message": "[multiple changes]\n\n2009-04-15  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* a-calend.adb: Add new constant Nanos_In_Four_Years.\n\t(Formatting_Operations.Time_Of): Change the way four year chunks of\n\tnanoseconds are added to the intermediate result.\n\n2009-04-15  Nicolas Setton  <setton@adacore.com>\n\n\t* sysdep.c: Add __APPLE__ in the list of systems where get_immediate\n\tdoes not need to wait for a carriage return.\n\n2009-04-15  Tristan Gingold  <gingold@adacore.com>\n\n\t* bindgen.adb: Do not generate adafinal if No_Finalization restriction\n\tis set.\n\n2009-04-15  Ed Schonberg  <schonberg@adacore.com>\n\n\t* freeze.adb (Freeze_Entity): improve error message for improper use of\n\tincomplete types.\n\tDiagnose additional illegal uses of incomplete types in formal parts.\n\tappearing in formal parts.\n\n\t* sem_ch6.adb (Process_Formals, Analyze_Return_Type): ditto.\n\n2009-04-15  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Allocator): Install test for object too large.\n\nFrom-SVN: r146098", "tree": {"sha": "447369126eb4e677e186ff36876e121c754064be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/447369126eb4e677e186ff36876e121c754064be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8aec446b9825afac7364819ffa8ea00307fbaaff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aec446b9825afac7364819ffa8ea00307fbaaff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aec446b9825afac7364819ffa8ea00307fbaaff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aec446b9825afac7364819ffa8ea00307fbaaff/comments", "author": null, "committer": null, "parents": [{"sha": "442dd5fb23f716aaabf465ead17b4dfb63421699", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/442dd5fb23f716aaabf465ead17b4dfb63421699", "html_url": "https://github.com/Rust-GCC/gccrs/commit/442dd5fb23f716aaabf465ead17b4dfb63421699"}], "stats": {"total": 221, "additions": 187, "deletions": 34}, "files": [{"sha": "cb212e69e0591921b4fc7f5a4c5972d227ddf41d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aec446b9825afac7364819ffa8ea00307fbaaff/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aec446b9825afac7364819ffa8ea00307fbaaff/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8aec446b9825afac7364819ffa8ea00307fbaaff", "patch": "@@ -1,3 +1,32 @@\n+2009-04-15  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* a-calend.adb: Add new constant Nanos_In_Four_Years.\n+\t(Formatting_Operations.Time_Of): Change the way four year chunks of\n+\tnanoseconds are added to the intermediate result.\n+\n+2009-04-15  Nicolas Setton  <setton@adacore.com>\n+\n+\t* sysdep.c: Add __APPLE__ in the list of systems where get_immediate\n+\tdoes not need to wait for a carriage return.\n+\n+2009-04-15  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* bindgen.adb: Do not generate adafinal if No_Finalization restriction\n+\tis set.\n+\n+2009-04-15  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* freeze.adb (Freeze_Entity): improve error message for improper use of\n+\tincomplete types.\n+\tDiagnose additional illegal uses of incomplete types in formal parts.\n+\tappearing in formal parts.\n+\n+\t* sem_ch6.adb (Process_Formals, Analyze_Return_Type): ditto.\n+\n+2009-04-15  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Allocator): Install test for object too large.\n+\n 2009-04-15  Nicolas Roche  <roche@adacore.com>\n \n \t* adaint.c: Add function __gnat_lwp_self that retrieves the LWP of the"}, {"sha": "7e785116f027e1b77b453a1d4291e3da36768e9b", "filename": "gcc/ada/a-calend.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aec446b9825afac7364819ffa8ea00307fbaaff/gcc%2Fada%2Fa-calend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aec446b9825afac7364819ffa8ea00307fbaaff/gcc%2Fada%2Fa-calend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-calend.adb?ref=8aec446b9825afac7364819ffa8ea00307fbaaff", "patch": "@@ -148,6 +148,7 @@ package body Ada.Calendar is\n    Ada_Min_Year          : constant Year_Number := Year_Number'First;\n    Secs_In_Four_Years    : constant := (3 * 365 + 366) * Secs_In_Day;\n    Secs_In_Non_Leap_Year : constant := 365 * Secs_In_Day;\n+   Nanos_In_Four_Years   : constant := Secs_In_Four_Years * Nano;\n \n    --  Lower and upper bound of Ada time. The zero (0) value of type Time is\n    --  positioned at year 2150. Note that the lower and upper bound account\n@@ -1317,7 +1318,9 @@ package body Ada.Calendar is\n          --  the input date.\n \n          Count := (Year - Year_Number'First) / 4;\n-         Res_N := Res_N + Time_Rep (Count) * Secs_In_Four_Years * Nano;\n+         for Four_Year_Segments in 1 .. Count loop\n+            Res_N := Res_N + Nanos_In_Four_Years;\n+         end loop;\n \n          --  Note that non-leap centennial years are automatically considered\n          --  leap in the operation above. An adjustment of several days is"}, {"sha": "cc4c6ddfa5dff9cd2db44e01968d13d0be2a77a2", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aec446b9825afac7364819ffa8ea00307fbaaff/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aec446b9825afac7364819ffa8ea00307fbaaff/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=8aec446b9825afac7364819ffa8ea00307fbaaff", "patch": "@@ -2332,10 +2332,13 @@ package body Bindgen is\n             \"\"\"__gnat_ada_main_program_name\"\");\");\n       end if;\n \n-      WBI (\"\");\n-      WBI (\"   procedure \" & Ada_Final_Name.all & \";\");\n-      WBI (\"   pragma Export (C, \" & Ada_Final_Name.all & \", \"\"\" &\n-           Ada_Final_Name.all & \"\"\");\");\n+      if not Cumulative_Restrictions.Set (No_Finalization) then\n+         WBI (\"\");\n+         WBI (\"   procedure \" & Ada_Final_Name.all & \";\");\n+         WBI (\"   pragma Export (C, \" & Ada_Final_Name.all & \", \"\"\" &\n+              Ada_Final_Name.all & \"\"\");\");\n+      end if;\n+\n       WBI (\"\");\n       WBI (\"   procedure \" & Ada_Init_Name.all & \";\");\n       WBI (\"   pragma Export (C, \" & Ada_Init_Name.all & \", \"\"\" &\n@@ -2507,7 +2510,11 @@ package body Bindgen is\n \n       Gen_Adainit_Ada;\n \n-      Gen_Adafinal_Ada;\n+      --  Generate the adafinal routine unless there is no finalization to do.\n+\n+      if not Cumulative_Restrictions.Set (No_Finalization) then\n+         Gen_Adafinal_Ada;\n+      end if;\n \n       if Bind_Main_Program and then VM_Target = No_VM then\n "}, {"sha": "978225e4b947b44b1b243fdfe9dfc544fcbaa484", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 107, "deletions": 2, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aec446b9825afac7364819ffa8ea00307fbaaff/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aec446b9825afac7364819ffa8ea00307fbaaff/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=8aec446b9825afac7364819ffa8ea00307fbaaff", "patch": "@@ -2935,6 +2935,11 @@ package body Exp_Ch4 is\n       --  constrain. Such occurrences can be rewritten as aliased objects\n       --  and their unrestricted access used instead of the coextension.\n \n+      function Size_In_Storage_Elements (E : Entity_Id) return Node_Id;\n+      --  Given a type E, returns a node representing the code to compute the\n+      --  size in storage elements for the given type. This is not as trivial\n+      --  as one might expect, as explained in the body.\n+\n       ---------------------------------------\n       -- Complete_Coextension_Finalization --\n       ---------------------------------------\n@@ -3031,8 +3036,10 @@ package body Exp_Ch4 is\n \n                      --  Retrieve the declaration of the body\n \n-                     Decl := Parent (Parent (\n-                               Corresponding_Body (Parent (Parent (S)))));\n+                     Decl :=\n+                       Parent\n+                         (Parent\n+                            (Corresponding_Body (Parent (Parent (S)))));\n                      exit;\n                   end if;\n \n@@ -3161,6 +3168,74 @@ package body Exp_Ch4 is\n          Analyze_And_Resolve (N, PtrT);\n       end Rewrite_Coextension;\n \n+      ------------------------------\n+      -- Size_In_Storage_Elements --\n+      ------------------------------\n+\n+      function Size_In_Storage_Elements (E : Entity_Id) return Node_Id is\n+      begin\n+         --  Logically this just returns E'Max_Size_In_Storage_Elements.\n+         --  However, the reason for the existence of this function is\n+         --  to construct a test for sizes too large, which means near the\n+         --  32-bit limit on a 32-bit machine, and precisely the trouble\n+         --  is that we get overflows when sizes are greater than 2**31.\n+\n+         --  So what we end up doing is using this expression for non-array\n+         --  types, where it is not quite right, but should be good enough\n+         --  most of the time. But for non-packed arrays, instead we compute\n+         --  the expression:\n+\n+         --    number-of-elements * component_type'Max_Size_In_Storage_Elements\n+\n+         --  which avoids this problem. All this is a big bogus, but it does\n+         --  mean we catch common cases of trying to allocate arrays that\n+         --  are too large, and which in the absence of a check results in\n+         --  undetected chaos ???\n+\n+         if Is_Array_Type (E) and then Is_Constrained (E) then\n+            declare\n+               Len : Node_Id;\n+               Res : Node_Id;\n+\n+            begin\n+               for J in 1 .. Number_Dimensions (E) loop\n+                  Len :=\n+                    Make_Attribute_Reference (Loc,\n+                      Prefix         => New_Occurrence_Of (E, Loc),\n+                      Attribute_Name => Name_Length,\n+                      Expressions    => New_List (\n+                        Make_Integer_Literal (Loc, J)));\n+\n+                  if J = 1 then\n+                     Res := Len;\n+\n+                  else\n+                     Res :=\n+                       Make_Op_Multiply (Loc,\n+                         Left_Opnd  => Res,\n+                         Right_Opnd => Len);\n+                  end if;\n+               end loop;\n+\n+               return\n+                 Make_Op_Multiply (Loc,\n+                   Left_Opnd  => Len,\n+                   Right_Opnd =>\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix => New_Occurrence_Of (Component_Type (E), Loc),\n+                       Attribute_Name => Name_Max_Size_In_Storage_Elements));\n+            end;\n+\n+            --  Here for other than non-bit-packed array\n+\n+         else\n+            return\n+              Make_Attribute_Reference (Loc,\n+                Prefix         => New_Occurrence_Of (E, Loc),\n+                Attribute_Name => Name_Max_Size_In_Storage_Elements);\n+         end if;\n+      end Size_In_Storage_Elements;\n+\n    --  Start of processing for Expand_N_Allocator\n \n    begin\n@@ -3272,6 +3347,36 @@ package body Exp_Ch4 is\n          Complete_Coextension_Finalization;\n       end if;\n \n+      --  Check for size too large, we do this because the back end misses\n+      --  proper checks here and can generate rubbish allocation calls when\n+      --  we are near the limit. We only do this for the 32-bit address case\n+      --  since that is from a practical point of view where we see a problem.\n+\n+      if System_Address_Size = 32\n+        and then not Storage_Checks_Suppressed (PtrT)\n+        and then not Storage_Checks_Suppressed (Dtyp)\n+        and then not Storage_Checks_Suppressed (Etyp)\n+      then\n+         --  The check we want to generate should look like\n+\n+         --  if Etyp'Max_Size_In_Storage_Elements > 3.5 gigabytes then\n+         --    raise Storage_Error;\n+         --  end if;\n+\n+         --  where 3.5 gigabytes is a constant large enough to accomodate\n+         --  any reasonable request for\n+\n+         Insert_Action (N,\n+           Make_Raise_Storage_Error (Loc,\n+             Condition =>\n+               Make_Op_Gt (Loc,\n+                 Left_Opnd => Size_In_Storage_Elements (Etyp),\n+                 Right_Opnd =>\n+                   Make_Integer_Literal (Loc,\n+                     Intval => Uint_7 * (Uint_2 ** 29))),\n+             Reason    => SE_Object_Too_Large));\n+      end if;\n+\n       --  Handle case of qualified expression (other than optimization above)\n \n       if Nkind (Expression (N)) = N_Qualified_Expression then"}, {"sha": "88ea26929cc0e8c68019ca1a719101bebd0c9959", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aec446b9825afac7364819ffa8ea00307fbaaff/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aec446b9825afac7364819ffa8ea00307fbaaff/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=8aec446b9825afac7364819ffa8ea00307fbaaff", "patch": "@@ -2606,24 +2606,22 @@ package body Freeze is\n                           (\"?foreign convention function& should not \" &\n                            \"return unconstrained array!\", E);\n \n-                     --  Ada 2005 (AI-326): Check wrong use of tagged\n+                     --  Ada 2005 (AI-326): Check wrong use of\n                      --  incomplete type\n \n-                     --    type T is tagged;\n+                     --    type T;   --  tagged or just incomplete.\n                      --    function F (X : Boolean) return T; -- ERROR\n \n                      --  The type must be declared in the current scope for the\n                      --  use to be legal, and the full view must be available\n                      --  when the construct that mentions it is frozen.\n \n                      elsif Ekind (Etype (E)) = E_Incomplete_Type\n-                       and then Is_Tagged_Type (Etype (E))\n                        and then No (Full_View (Etype (E)))\n                        and then not Is_Value_Type (Etype (E))\n                      then\n-                        Error_Msg_N\n-                          (\"(Ada 2005): invalid use of tagged incomplete type\",\n-                            E);\n+                        Error_Msg_NE\n+                          (\"invalid use of incomplete type&\", E, Etype (E));\n                      end if;\n                   end if;\n                end;\n@@ -3510,10 +3508,25 @@ package body Freeze is\n \n          --  For access subprogram, freeze types of all formals, the return\n          --  type was already frozen, since it is the Etype of the function.\n+         --  Formal types can be tagged Taft amendment types, but otherwise\n+         --  they cannot be incomplete;\n \n          elsif Ekind (E) = E_Subprogram_Type then\n             Formal := First_Formal (E);\n+\n             while Present (Formal) loop\n+               if Ekind (Etype (Formal)) = E_Incomplete_Type\n+                 and then No (Full_View (Etype (Formal)))\n+                 and then not Is_Value_Type (Etype (Formal))\n+               then\n+                  if Is_Tagged_Type (Etype (Formal)) then\n+                     null;\n+                  else\n+                     Error_Msg_NE\n+                       (\"invalid use of incomplete type&\", E, Etype (Formal));\n+                  end if;\n+               end if;\n+\n                Freeze_And_Append (Etype (Formal), Loc, Result);\n                Next_Formal (Formal);\n             end loop;\n@@ -3522,16 +3535,15 @@ package body Freeze is\n \n             --  Ada 2005 (AI-326): Check wrong use of tag incomplete type\n \n-            --    type T is tagged;\n+            --    type T;  --   tagged or untagged, may be from limited view;\n             --    type Acc is access function (X : T) return T; -- ERROR\n \n             if Ekind (Etype (E)) = E_Incomplete_Type\n-              and then Is_Tagged_Type (Etype (E))\n               and then No (Full_View (Etype (E)))\n               and then not Is_Value_Type (Etype (E))\n             then\n-               Error_Msg_N\n-                 (\"(Ada 2005): invalid use of tagged incomplete type\", E);\n+               Error_Msg_NE\n+                 (\"invalid use of incomplete type&\", E, Etype (E));\n             end if;\n \n          --  For access to a protected subprogram, freeze the equivalent type\n@@ -3557,12 +3569,11 @@ package body Freeze is\n                end if;\n \n                if Ekind (Etyp) = E_Incomplete_Type\n-                 and then Is_Tagged_Type (Etyp)\n                  and then No (Full_View (Etyp))\n                  and then not Is_Value_Type (Etype (E))\n                then\n-                  Error_Msg_N\n-                    (\"(Ada 2005): invalid use of tagged incomplete type\", E);\n+                  Error_Msg_NE\n+                    (\"invalid use of incomplete type&\", E, Etyp);\n                end if;\n             end;\n "}, {"sha": "23ed091c2749bc8172f821b4fb68c7c192bce9fb", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aec446b9825afac7364819ffa8ea00307fbaaff/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aec446b9825afac7364819ffa8ea00307fbaaff/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=8aec446b9825afac7364819ffa8ea00307fbaaff", "patch": "@@ -1326,8 +1326,8 @@ package body Sem_Ch6 is\n                          and then\n                            Ekind (Root_Type (Typ)) = E_Incomplete_Type)\n             then\n-               Error_Msg_N\n-                 (\"invalid use of incomplete type\", Result_Definition (N));\n+               Error_Msg_NE\n+                 (\"invalid use of incomplete type&\", Designator, Typ);\n             end if;\n          end if;\n \n@@ -7719,15 +7719,13 @@ package body Sem_Ch6 is\n                elsif not Nkind_In (Parent (T), N_Access_Function_Definition,\n                                                N_Access_Procedure_Definition)\n                then\n-                  Error_Msg_N (\"invalid use of incomplete type\", Param_Spec);\n-\n-               --  An incomplete type that is not tagged is allowed in an\n-               --  access-to-subprogram type only if it is a local declaration\n-               --  with a forthcoming completion (3.10.1 (9.2/2)).\n+                  Error_Msg_NE\n+                    (\"invalid use of incomplete type&\",\n+                       Param_Spec, Formal_Type);\n \n-               elsif Scope (Formal_Type) /= Scope (Current_Scope) then\n-                  Error_Msg_N\n-                    (\"invalid use of limited view of type\", Param_Spec);\n+                  --  Further checks on the legality of incomplete types\n+                  --  in formal parts must be delayed until the freeze point\n+                  --  of the enclosing subprogram or access to subprogram.\n                end if;\n \n             elsif Ekind (Formal_Type) = E_Void then"}, {"sha": "56f3ebd3b0f519eb3a9120cc58265cbb9a1c171f", "filename": "gcc/ada/sysdep.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8aec446b9825afac7364819ffa8ea00307fbaaff/gcc%2Fada%2Fsysdep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8aec446b9825afac7364819ffa8ea00307fbaaff/gcc%2Fada%2Fsysdep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsysdep.c?ref=8aec446b9825afac7364819ffa8ea00307fbaaff", "patch": "@@ -348,7 +348,7 @@ __gnat_ttyname (int filedes)\n   || defined (__MACHTEN__) || defined (__hpux__) || defined (_AIX) \\\n   || (defined (__svr4__) && defined (i386)) || defined (__Lynx__) \\\n   || defined (__CYGWIN__) || defined (__FreeBSD__) || defined (__OpenBSD__) \\\n-  || defined (__GLIBC__)\n+  || defined (__GLIBC__) || defined (__APPLE__)\n \n #ifdef __MINGW32__\n #if OLD_MINGW\n@@ -406,7 +406,7 @@ getc_immediate_common (FILE *stream,\n     || defined (__CYGWIN32__) || defined (__MACHTEN__) || defined (__hpux__) \\\n     || defined (_AIX) || (defined (__svr4__) && defined (i386)) \\\n     || defined (__Lynx__) || defined (__FreeBSD__) || defined (__OpenBSD__) \\\n-    || defined (__GLIBC__)\n+    || defined (__GLIBC__) || defined (__APPLE__)\n   char c;\n   int nread;\n   int good_one = 0;\n@@ -426,7 +426,7 @@ getc_immediate_common (FILE *stream,\n     || defined (__osf__) || defined (__MACHTEN__) || defined (__hpux__) \\\n     || defined (_AIX) || (defined (__svr4__) && defined (i386)) \\\n     || defined (__Lynx__) || defined (__FreeBSD__) || defined (__OpenBSD__) \\\n-    || defined (__GLIBC__)\n+    || defined (__GLIBC__) || defined (__APPLE__)\n       eof_ch = termios_rec.c_cc[VEOF];\n \n       /* If waiting (i.e. Get_Immediate (Char)), set MIN = 1 and wait for"}]}