{"sha": "3825692d47b1b5d3552e22c22166bad26075ccb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzgyNTY5MmQ0N2IxYjVkMzU1MmUyMmMyMjE2NmJhZDI2MDc1Y2NiOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2012-03-30T18:00:37Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2012-03-30T18:00:37Z"}, "message": "re PR debug/52727 (internal compiler error at dwarf2cfi.c2:685)\n\nPR debug/52727\n        * combine-stack-adj.c (prev_active_insn_bb): New.\n        (next_active_insn_bb): New.\n        (force_move_args_size_note): New.\n        (combine_stack_adjustments_for_block): Use it.\n\nFrom-SVN: r186018", "tree": {"sha": "6565fec3e19306b2a4c5fe58beb4057a7bf17950", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6565fec3e19306b2a4c5fe58beb4057a7bf17950"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3825692d47b1b5d3552e22c22166bad26075ccb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3825692d47b1b5d3552e22c22166bad26075ccb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3825692d47b1b5d3552e22c22166bad26075ccb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3825692d47b1b5d3552e22c22166bad26075ccb9/comments", "author": null, "committer": null, "parents": [{"sha": "e025da0c317a01aa5341850d2943c68bf9604a19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e025da0c317a01aa5341850d2943c68bf9604a19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e025da0c317a01aa5341850d2943c68bf9604a19"}], "stats": {"total": 143, "additions": 135, "deletions": 8}, "files": [{"sha": "294ccaa22e6486f8fb0a86de2397082bb03ea7fa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3825692d47b1b5d3552e22c22166bad26075ccb9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3825692d47b1b5d3552e22c22166bad26075ccb9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3825692d47b1b5d3552e22c22166bad26075ccb9", "patch": "@@ -1,3 +1,11 @@\n+2012-03-30  Richard Henderson  <rth@redhat.com>\n+\n+\tPR debug/52727\n+\t* combine-stack-adj.c (prev_active_insn_bb): New.\n+\t(next_active_insn_bb): New.\n+\t(force_move_args_size_note): New.\n+\t(combine_stack_adjustments_for_block): Use it.\n+\n 2012-03-30  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386.c (struct expand_vec_perm_d): Add one_operand_p."}, {"sha": "6b6f74b4b251c14e345e42b93ac440d95d8a1ebd", "filename": "gcc/combine-stack-adj.c", "status": "modified", "additions": 127, "deletions": 8, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3825692d47b1b5d3552e22c22166bad26075ccb9/gcc%2Fcombine-stack-adj.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3825692d47b1b5d3552e22c22166bad26075ccb9/gcc%2Fcombine-stack-adj.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine-stack-adj.c?ref=3825692d47b1b5d3552e22c22166bad26075ccb9", "patch": "@@ -320,13 +320,115 @@ maybe_move_args_size_note (rtx last, rtx insn, bool after)\n     add_reg_note (last, REG_ARGS_SIZE, XEXP (note, 0));\n }\n \n+/* Return the next (or previous) active insn within BB.  */\n+\n+static rtx\n+prev_active_insn_bb (basic_block bb, rtx insn)\n+{\n+  for (insn = PREV_INSN (insn);\n+       insn != PREV_INSN (BB_HEAD (bb));\n+       insn = PREV_INSN (insn))\n+    if (active_insn_p (insn))\n+      return insn;\n+  return NULL_RTX;\n+}\n+\n+static rtx\n+next_active_insn_bb (basic_block bb, rtx insn)\n+{\n+  for (insn = NEXT_INSN (insn);\n+       insn != NEXT_INSN (BB_END (bb));\n+       insn = NEXT_INSN (insn))\n+    if (active_insn_p (insn))\n+      return insn;\n+  return NULL_RTX;\n+}\n+\n+/* If INSN has a REG_ARGS_SIZE note, if possible move it to PREV.  Otherwise\n+   search for a nearby candidate within BB where we can stick the note.  */\n+\n+static void\n+force_move_args_size_note (basic_block bb, rtx prev, rtx insn)\n+{\n+  rtx note, test, next_candidate, prev_candidate;\n+\n+  /* If PREV exists, tail-call to the logic in the other function.  */\n+  if (prev)\n+    {\n+      maybe_move_args_size_note (prev, insn, false);\n+      return;\n+    }\n+\n+  /* First, make sure there's anything that needs doing.  */\n+  note = find_reg_note (insn, REG_ARGS_SIZE, NULL_RTX);\n+  if (note == NULL)\n+    return;\n+\n+  /* We need to find a spot between the previous and next exception points\n+     where we can place the note and \"properly\" deallocate the arguments.  */\n+  next_candidate = prev_candidate = NULL;\n+\n+  /* It is often the case that we have insns in the order:\n+\tcall\n+\tadd sp (previous deallocation)\n+\tsub sp (align for next arglist)\n+\tpush arg\n+     and the add/sub cancel.  Therefore we begin by searching forward.  */\n+\n+  test = insn;\n+  while ((test = next_active_insn_bb (bb, test)) != NULL)\n+    {\n+      /* Found an existing note: nothing to do.  */\n+      if (find_reg_note (test, REG_ARGS_SIZE, NULL_RTX))\n+        return;\n+      /* Found something that affects unwinding.  Stop searching.  */\n+      if (CALL_P (test) || !insn_nothrow_p (test))\n+\tbreak;\n+      if (next_candidate == NULL)\n+\tnext_candidate = test;\n+    }\n+\n+  test = insn;\n+  while ((test = prev_active_insn_bb (bb, test)) != NULL)\n+    {\n+      rtx tnote;\n+      /* Found a place that seems logical to adjust the stack.  */\n+      tnote = find_reg_note (test, REG_ARGS_SIZE, NULL_RTX);\n+      if (tnote)\n+\t{\n+\t  XEXP (tnote, 0) = XEXP (note, 0);\n+\t  return;\n+\t}\n+      if (prev_candidate == NULL)\n+\tprev_candidate = test;\n+      /* Found something that affects unwinding.  Stop searching.  */\n+      if (CALL_P (test) || !insn_nothrow_p (test))\n+\tbreak;\n+    }\n+\n+  if (prev_candidate)\n+    test = prev_candidate;\n+  else if (next_candidate)\n+    test = next_candidate;\n+  else\n+    {\n+      /* ??? We *must* have a place, lest we ICE on the lost adjustment.\n+\t Options are: dummy clobber insn, nop, or prevent the removal of\n+\t the sp += 0 insn.  Defer that decision until we can prove this\n+\t can actually happen.  */\n+      gcc_unreachable ();\n+    }\n+  add_reg_note (test, REG_ARGS_SIZE, XEXP (note, 0));\n+}\n+\n /* Subroutine of combine_stack_adjustments, called for each basic block.  */\n \n static void\n combine_stack_adjustments_for_block (basic_block bb)\n {\n   HOST_WIDE_INT last_sp_adjust = 0;\n   rtx last_sp_set = NULL_RTX;\n+  rtx last2_sp_set = NULL_RTX;\n   struct csa_reflist *reflist = NULL;\n   rtx insn, next, set;\n   struct record_stack_refs_data data;\n@@ -391,9 +493,8 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t\t\t\t\t\t  last_sp_adjust + this_adjust,\n \t\t\t\t\t\t  this_adjust))\n \t\t    {\n-\t\t      maybe_move_args_size_note (last_sp_set, insn, false);\n-\n \t\t      /* It worked!  */\n+\t\t      maybe_move_args_size_note (last_sp_set, insn, false);\n \t\t      delete_insn (insn);\n \t\t      last_sp_adjust += this_adjust;\n \t\t      continue;\n@@ -409,9 +510,8 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t\t\t\t\t\t  last_sp_adjust + this_adjust,\n \t\t\t\t\t\t  -last_sp_adjust))\n \t\t    {\n-\t\t      maybe_move_args_size_note (insn, last_sp_set, true);\n-\n \t\t      /* It worked!  */\n+\t\t      maybe_move_args_size_note (insn, last_sp_set, true);\n \t\t      delete_insn (last_sp_set);\n \t\t      last_sp_set = insn;\n \t\t      last_sp_adjust += this_adjust;\n@@ -424,8 +524,16 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t      /* Combination failed.  Restart processing from here.  If\n \t\t deallocation+allocation conspired to cancel, we can\n \t\t delete the old deallocation insn.  */\n-\t      if (last_sp_set && last_sp_adjust == 0)\n-\t\tdelete_insn (last_sp_set);\n+\t      if (last_sp_set)\n+\t\t{\n+\t\t  if (last_sp_adjust == 0)\n+\t\t    {\n+\t\t      maybe_move_args_size_note (insn, last_sp_set, true);\n+\t\t      delete_insn (last_sp_set);\n+\t\t    }\n+\t\t  else\n+\t\t    last2_sp_set = last_sp_set;\n+\t\t}\n \t      free_csa_reflist (reflist);\n \t      reflist = NULL;\n \t      last_sp_set = insn;\n@@ -461,6 +569,10 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t      && try_apply_stack_adjustment (insn, reflist, 0,\n \t\t\t\t\t     -last_sp_adjust))\n \t    {\n+\t      if (last2_sp_set)\n+\t\tmaybe_move_args_size_note (last2_sp_set, last_sp_set, false);\n+\t      else\n+\t        maybe_move_args_size_note (insn, last_sp_set, true);\n \t      delete_insn (last_sp_set);\n \t      free_csa_reflist (reflist);\n \t      reflist = NULL;\n@@ -487,16 +599,23 @@ combine_stack_adjustments_for_block (basic_block bb)\n \t      || reg_mentioned_p (stack_pointer_rtx, PATTERN (insn))))\n \t{\n \t  if (last_sp_set && last_sp_adjust == 0)\n-\t    delete_insn (last_sp_set);\n+\t    {\n+\t      force_move_args_size_note (bb, last2_sp_set, last_sp_set);\n+\t      delete_insn (last_sp_set);\n+\t    }\n \t  free_csa_reflist (reflist);\n \t  reflist = NULL;\n+\t  last2_sp_set = NULL_RTX;\n \t  last_sp_set = NULL_RTX;\n \t  last_sp_adjust = 0;\n \t}\n     }\n \n   if (last_sp_set && last_sp_adjust == 0)\n-    delete_insn (last_sp_set);\n+    {\n+      force_move_args_size_note (bb, last2_sp_set, last_sp_set);\n+      delete_insn (last_sp_set);\n+    }\n \n   if (reflist)\n     free_csa_reflist (reflist);"}]}