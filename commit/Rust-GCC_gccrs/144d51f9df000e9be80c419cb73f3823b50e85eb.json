{"sha": "144d51f9df000e9be80c419cb73f3823b50e85eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ0ZDUxZjlkZjAwMGU5YmU4MGM0MTljYjczZjM4MjNiNTBlODVlYg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-04-22T13:22:31Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-04-22T13:22:31Z"}, "message": "pa.c (legitimize_pic_address): Use gcc_assert and gcc_unreachable as appropriate.\n\n\t* config/pa/pa.c (legitimize_pic_address): Use gcc_assert and\n\tgcc_unreachable as appropriate.\n\t(force_mode, emit_move_sequence, singlemove_string,\n\toutput_move_double, output_fp_move_double, find_addr_reg,\n\toutput_block_move, output_block_clear, output_and,\n\toutput_64bit_and, output_ior, output_64bit_ior, store_reg_modify,\n\tpa_adjust_cost, pa_issue_rate, print_operand,\n\toutput_global_address, output_arg_descriptor, output_cbranch,\n\toutput_lbranch, output_bb, output_bvb, output_dbra, output_movb,\n\toutput_call): Likewise.\n\t* config/pa/pa.md (call, call_value, sibcall, sibcall_value,\n\tprefetch, prefetch_cc, prefetch_nocc): Likewise.\n\nFrom-SVN: r98559", "tree": {"sha": "58f1fba0752632988bbacd44d2d495ef9e625c0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58f1fba0752632988bbacd44d2d495ef9e625c0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/144d51f9df000e9be80c419cb73f3823b50e85eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/144d51f9df000e9be80c419cb73f3823b50e85eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/144d51f9df000e9be80c419cb73f3823b50e85eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/144d51f9df000e9be80c419cb73f3823b50e85eb/comments", "author": null, "committer": null, "parents": [{"sha": "9885da8e1b3b22d00cd59c167ede990d97a4322b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9885da8e1b3b22d00cd59c167ede990d97a4322b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9885da8e1b3b22d00cd59c167ede990d97a4322b"}], "stats": {"total": 391, "additions": 187, "deletions": 204}, "files": [{"sha": "cede561e12a2323ed9ea424846bf3be108e950c5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/144d51f9df000e9be80c419cb73f3823b50e85eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/144d51f9df000e9be80c419cb73f3823b50e85eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=144d51f9df000e9be80c419cb73f3823b50e85eb", "patch": "@@ -1,3 +1,18 @@\n+2005-04-22  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/pa/pa.c (legitimize_pic_address): Use gcc_assert and\n+\tgcc_unreachable as appropriate.\n+\t(force_mode, emit_move_sequence, singlemove_string,\n+\toutput_move_double, output_fp_move_double, find_addr_reg,\n+\toutput_block_move, output_block_clear, output_and,\n+\toutput_64bit_and, output_ior, output_64bit_ior, store_reg_modify,\n+\tpa_adjust_cost, pa_issue_rate, print_operand,\n+\toutput_global_address, output_arg_descriptor, output_cbranch,\n+\toutput_lbranch, output_bb, output_bvb, output_dbra, output_movb,\n+\toutput_call): Likewise.\n+\t* config/pa/pa.md (call, call_value, sibcall, sibcall_value,\n+\tprefetch, prefetch_cc, prefetch_nocc): Likewise.\n+\n 2005-04-22  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* Makefile.in (LIBGCOV): Add _gcov_interval_profiler,"}, {"sha": "e77a6ed5d458346b070d5ba779e01ffe066f2008", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 151, "deletions": 178, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/144d51f9df000e9be80c419cb73f3823b50e85eb/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/144d51f9df000e9be80c419cb73f3823b50e85eb/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=144d51f9df000e9be80c419cb73f3823b50e85eb", "patch": "@@ -652,8 +652,7 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n     {\n       rtx insn, tmp_reg;\n \n-      if (reg == 0)\n-\tabort ();\n+      gcc_assert (reg);\n \n       /* Before reload, allocate a temporary register for the intermediate\n \t result.  This allows the sequence to be deleted when the final\n@@ -688,17 +687,12 @@ legitimize_pic_address (rtx orig, enum machine_mode mode, rtx reg)\n \t  && XEXP (XEXP (orig, 0), 0) == pic_offset_table_rtx)\n \treturn orig;\n \n-      if (reg == 0)\n-\tabort ();\n-\n-      if (GET_CODE (XEXP (orig, 0)) == PLUS)\n-\t{\n-\t  base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg);\n-\t  orig = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n-\t\t\t\t\t base == reg ? 0 : reg);\n-\t}\n-      else\n-\tabort ();\n+      gcc_assert (reg);\n+      gcc_assert (GET_CODE (XEXP (orig, 0)) == PLUS);\n+      \n+      base = legitimize_pic_address (XEXP (XEXP (orig, 0), 0), Pmode, reg);\n+      orig = legitimize_pic_address (XEXP (XEXP (orig, 0), 1), Pmode,\n+\t\t\t\t     base == reg ? 0 : reg);\n \n       if (GET_CODE (orig) == CONST_INT)\n \t{\n@@ -1227,8 +1221,7 @@ force_mode (enum machine_mode mode, rtx orig)\n   if (mode == GET_MODE (orig))\n     return orig;\n \n-  if (REGNO (orig) >= FIRST_PSEUDO_REGISTER)\n-    abort ();\n+  gcc_assert (REGNO (orig) < FIRST_PSEUDO_REGISTER);\n \n   return gen_rtx_REG (mode, REGNO (orig));\n }\n@@ -1256,8 +1249,7 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n   if (GET_CODE (operand0) == MEM && IS_INDEX_ADDR_P (XEXP (operand0, 0)))\n     {\n       /* This is only safe up to the beginning of life analysis.  */\n-      if (no_new_pseudos)\n-\tabort ();\n+      gcc_assert (!no_new_pseudos);\n \n       tem = copy_to_mode_reg (Pmode, XEXP (operand0, 0));\n       operand0 = replace_equiv_address (operand0, tem);\n@@ -1631,8 +1623,7 @@ emit_move_sequence (rtx *operands, enum machine_mode mode, rtx scratch_reg)\n \t\t{\n \t\t  /* Save away the constant part of the expression.  */\n \t\t  const_part = XEXP (XEXP (operand1, 0), 1);\n-\t\t  if (GET_CODE (const_part) != CONST_INT)\n-\t\t    abort ();\n+\t\t  gcc_assert (GET_CODE (const_part) == CONST_INT);\n \n \t\t  /* Force the function label into memory.  */\n \t\t  temp = force_const_mem (mode, XEXP (XEXP (operand1, 0), 0));\n@@ -1974,8 +1965,7 @@ singlemove_string (rtx *operands)\n       long i;\n       REAL_VALUE_TYPE d;\n \n-      if (GET_MODE (operands[1]) != SFmode)\n-\tabort ();\n+      gcc_assert (GET_MODE (operands[1]) == SFmode);\n \n       /* Translate the CONST_DOUBLE to a CONST_INT with the same target\n \t bit pattern.  */\n@@ -2110,11 +2100,8 @@ output_move_double (rtx *operands)\n     optype1 = RNDOP;\n \n   /* Check for the cases that the operand constraints are not\n-     supposed to allow to happen.  Abort if we get one,\n-     because generating code for these cases is painful.  */\n-\n-  if (optype0 != REGOP && optype1 != REGOP)\n-    abort ();\n+     supposed to allow to happen.  */\n+  gcc_assert (optype0 == REGOP || optype1 == REGOP);\n \n    /* Handle auto decrementing and incrementing loads and stores\n      specifically, since the structure of the function doesn't work\n@@ -2133,40 +2120,33 @@ output_move_double (rtx *operands)\n \t  rtx high_reg = gen_rtx_SUBREG (SImode, operands[1], 0);\n \n \t  operands[0] = XEXP (addr, 0);\n-\t  if (GET_CODE (operands[1]) != REG || GET_CODE (operands[0]) != REG)\n-\t    abort ();\n+\t  gcc_assert (GET_CODE (operands[1]) == REG\n+\t\t      && GET_CODE (operands[0]) == REG);\n \n-\t  if (!reg_overlap_mentioned_p (high_reg, addr))\n-\t    {\n-\t      /* No overlap between high target register and address\n-\t\t register.  (We do this in a non-obvious way to\n-\t\t save a register file writeback)  */\n-\t      if (GET_CODE (addr) == POST_INC)\n-\t\treturn \"{stws|stw},ma %1,8(%0)\\n\\tstw %R1,-4(%0)\";\n-\t      return \"{stws|stw},ma %1,-8(%0)\\n\\tstw %R1,12(%0)\";\n-\t    }\n-\t  else\n-\t    abort ();\n+\t  gcc_assert (!reg_overlap_mentioned_p (high_reg, addr));\n+\t  \n+\t  /* No overlap between high target register and address\n+\t     register.  (We do this in a non-obvious way to\n+\t     save a register file writeback)  */\n+\t  if (GET_CODE (addr) == POST_INC)\n+\t    return \"{stws|stw},ma %1,8(%0)\\n\\tstw %R1,-4(%0)\";\n+\t  return \"{stws|stw},ma %1,-8(%0)\\n\\tstw %R1,12(%0)\";\n \t}\n       else if (GET_CODE (addr) == PRE_INC || GET_CODE (addr) == PRE_DEC)\n \t{\n \t  rtx high_reg = gen_rtx_SUBREG (SImode, operands[1], 0);\n \n \t  operands[0] = XEXP (addr, 0);\n-\t  if (GET_CODE (operands[1]) != REG || GET_CODE (operands[0]) != REG)\n-\t    abort ();\n-\n-\t  if (!reg_overlap_mentioned_p (high_reg, addr))\n-\t    {\n-\t      /* No overlap between high target register and address\n-\t\t register.  (We do this in a non-obvious way to\n-\t\t save a register file writeback)  */\n-\t      if (GET_CODE (addr) == PRE_INC)\n-\t\treturn \"{stws|stw},mb %1,8(%0)\\n\\tstw %R1,4(%0)\";\n-\t      return \"{stws|stw},mb %1,-8(%0)\\n\\tstw %R1,4(%0)\";\n-\t    }\n-\t  else\n-\t    abort ();\n+\t  gcc_assert (GET_CODE (operands[1]) == REG\n+\t\t      && GET_CODE (operands[0]) == REG);\n+\t  \n+\t  gcc_assert (!reg_overlap_mentioned_p (high_reg, addr));\n+\t  /* No overlap between high target register and address\n+\t     register.  (We do this in a non-obvious way to save a\n+\t     register file writeback)  */\n+\t  if (GET_CODE (addr) == PRE_INC)\n+\t    return \"{stws|stw},mb %1,8(%0)\\n\\tstw %R1,4(%0)\";\n+\t  return \"{stws|stw},mb %1,-8(%0)\\n\\tstw %R1,4(%0)\";\n \t}\n     }\n   if (optype1 == MEMOP)\n@@ -2180,8 +2160,8 @@ output_move_double (rtx *operands)\n \t  rtx high_reg = gen_rtx_SUBREG (SImode, operands[0], 0);\n \n \t  operands[1] = XEXP (addr, 0);\n-\t  if (GET_CODE (operands[0]) != REG || GET_CODE (operands[1]) != REG)\n-\t    abort ();\n+\t  gcc_assert (GET_CODE (operands[0]) == REG\n+\t\t      && GET_CODE (operands[1]) == REG);\n \n \t  if (!reg_overlap_mentioned_p (high_reg, addr))\n \t    {\n@@ -2207,8 +2187,8 @@ output_move_double (rtx *operands)\n \t  rtx high_reg = gen_rtx_SUBREG (SImode, operands[0], 0);\n \n \t  operands[1] = XEXP (addr, 0);\n-\t  if (GET_CODE (operands[0]) != REG || GET_CODE (operands[1]) != REG)\n-\t    abort ();\n+\t  gcc_assert (GET_CODE (operands[0]) == REG\n+\t\t      && GET_CODE (operands[1]) == REG);\n \n \t  if (!reg_overlap_mentioned_p (high_reg, addr))\n \t    {\n@@ -2370,23 +2350,22 @@ output_fp_move_double (rtx *operands)\n     {\n       output_asm_insn (\"fstd%F0 %1,%0\", operands);\n     }\n-  else if (operands[1] == CONST0_RTX (GET_MODE (operands[0])))\n+  else\n     {\n-      if (GET_CODE (operands[0]) == REG)\n-\t{\n-\t  rtx xoperands[2];\n-\t  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-\t  xoperands[0] = operands[0];\n-\t  output_asm_insn (\"copy %%r0,%0\\n\\tcopy %%r0,%1\", xoperands);\n-\t}\n+      rtx xoperands[2];\n+      \n+      gcc_assert (operands[1] == CONST0_RTX (GET_MODE (operands[0])));\n+      \n       /* This is a pain.  You have to be prepared to deal with an\n \t arbitrary address here including pre/post increment/decrement.\n \n \t so avoid this in the MD.  */\n-      else\n-\tabort ();\n+      gcc_assert (GET_CODE (operands[0]) == REG);\n+      \n+      xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n+      xoperands[0] = operands[0];\n+      output_asm_insn (\"copy %%r0,%0\\n\\tcopy %%r0,%1\", xoperands);\n     }\n-  else abort ();\n   return \"\";\n }\n \f\n@@ -2407,11 +2386,10 @@ find_addr_reg (rtx addr)\n       else if (CONSTANT_P (XEXP (addr, 1)))\n \taddr = XEXP (addr, 0);\n       else\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n-  if (GET_CODE (addr) == REG)\n-    return addr;\n-  abort ();\n+  gcc_assert (GET_CODE (addr) == REG);\n+  return addr;\n }\n \n /* Emit code to perform a block move.\n@@ -2542,7 +2520,7 @@ output_block_move (rtx *operands, int size_is_constant ATTRIBUTE_UNUSED)\n \treturn \"\";\n \n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n }\n \n@@ -2684,7 +2662,7 @@ output_block_clear (rtx *operands, int size_is_constant ATTRIBUTE_UNUSED)\n \treturn \"\";\n \n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n }\n \n@@ -2744,15 +2722,13 @@ output_and (rtx *operands)\n \tif ((mask & (1 << ms0)) == 0)\n \t  break;\n \n-      if (ms0 != 32)\n-\tabort ();\n+      gcc_assert (ms0 == 32);\n \n       if (ls1 == 32)\n \t{\n \t  len = ls0;\n \n-\t  if (len == 0)\n-\t    abort ();\n+\t  gcc_assert (len);\n \n \t  operands[2] = GEN_INT (len);\n \t  return \"{extru|extrw,u} %1,31,%2,%0\";\n@@ -2796,15 +2772,13 @@ output_64bit_and (rtx *operands)\n \tif ((mask & ((unsigned HOST_WIDE_INT) 1 << ms0)) == 0)\n \t  break;\n \n-      if (ms0 != HOST_BITS_PER_WIDE_INT)\n-\tabort ();\n+      gcc_assert (ms0 == HOST_BITS_PER_WIDE_INT);\n \n       if (ls1 == HOST_BITS_PER_WIDE_INT)\n \t{\n \t  len = ls0;\n \n-\t  if (len == 0)\n-\t    abort ();\n+\t  gcc_assert (len);\n \n \t  operands[2] = GEN_INT (len);\n \t  return \"extrd,u %1,63,%2,%0\";\n@@ -2843,8 +2817,7 @@ output_ior (rtx *operands)\n     if ((mask & (1 << bs1)) == 0)\n       break;\n \n-  if (bs1 != 32 && ((unsigned HOST_WIDE_INT) 1 << bs1) <= mask)\n-    abort ();\n+  gcc_assert (bs1 == 32 || ((unsigned HOST_WIDE_INT) 1 << bs1) > mask);\n \n   p = 31 - bs0;\n   len = bs1 - bs0;\n@@ -2873,9 +2846,8 @@ output_64bit_ior (rtx *operands)\n     if ((mask & ((unsigned HOST_WIDE_INT) 1 << bs1)) == 0)\n       break;\n \n-  if (bs1 != HOST_BITS_PER_WIDE_INT\n-      && ((unsigned HOST_WIDE_INT) 1 << bs1) <= mask)\n-    abort ();\n+  gcc_assert (bs1 == HOST_BITS_PER_WIDE_INT\n+\t      || ((unsigned HOST_WIDE_INT) 1 << bs1) > mask);\n \n   p = 63 - bs0;\n   len = bs1 - bs0;\n@@ -3250,8 +3222,7 @@ store_reg_modify (int base, int reg, HOST_WIDE_INT mod)\n {\n   rtx insn, basereg, srcreg, delta;\n \n-  if (!VAL_14_BITS_P (mod))\n-    abort ();\n+  gcc_assert (VAL_14_BITS_P (mod));\n \n   basereg = gen_rtx_REG (Pmode, base);\n   srcreg = gen_rtx_REG (word_mode, reg);\n@@ -4305,8 +4276,9 @@ pa_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n \n   attr_type = get_attr_type (insn);\n \n-  if (REG_NOTE_KIND (link) == REG_DEP_ANTI)\n+  switch (REG_NOTE_KIND (link))\n     {\n+    case REG_DEP_ANTI:\n       /* Anti dependency; DEP_INSN reads a register that INSN writes some\n \t cycles later.  */\n \n@@ -4386,9 +4358,8 @@ pa_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n \n       /* For other anti dependencies, the cost is 0.  */\n       return 0;\n-    }\n-  else if (REG_NOTE_KIND (link) == REG_DEP_OUTPUT)\n-    {\n+\n+    case REG_DEP_OUTPUT:\n       /* Output dependency; DEP_INSN writes a register that INSN writes some\n \t cycles later.  */\n       if (attr_type == TYPE_FPLOAD)\n@@ -4471,9 +4442,10 @@ pa_adjust_cost (rtx insn, rtx link, rtx dep_insn, int cost)\n \n       /* For other output dependencies, the cost is 0.  */\n       return 0;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n-  else\n-    abort ();\n }\n \n /* Adjust scheduling priorities.  We use this to try and keep addil\n@@ -4523,7 +4495,7 @@ pa_issue_rate (void)\n     case PROCESSOR_8000:\treturn 4;\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n }\n \n@@ -4686,7 +4658,7 @@ print_operand (FILE *file, rtx x, int code)\n \tcase LTU:\n \t  fputs (\"<<\", file);  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       return;\n     case 'N':\t\t\t/* Condition, (N)egated */\n@@ -4713,7 +4685,7 @@ print_operand (FILE *file, rtx x, int code)\n \tcase LTU:\n \t  fputs (\">>=\", file);  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       return;\n     /* For floating point comparisons.  Note that the output\n@@ -4753,7 +4725,7 @@ print_operand (FILE *file, rtx x, int code)\n \tcase ORDERED:\n \t  fputs (\"?\", file);  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       return;\n     case 'S':\t\t\t/* Condition, operands are (S)wapped.  */\n@@ -4780,7 +4752,7 @@ print_operand (FILE *file, rtx x, int code)\n \tcase LTU:\n \t  fputs (\">>\", file);  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       return;\n     case 'B':\t\t\t/* Condition, (B)oth swapped and negate.  */\n@@ -4807,51 +4779,33 @@ print_operand (FILE *file, rtx x, int code)\n \tcase LTU:\n \t  fputs (\"<<=\", file);  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       return;\n     case 'k':\n-      if (GET_CODE (x) == CONST_INT)\n-\t{\n-\t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, ~INTVAL (x));\n-\t  return;\n-\t}\n-      abort ();\n+      gcc_assert (GET_CODE (x) == CONST_INT);\n+      fprintf (file, HOST_WIDE_INT_PRINT_DEC, ~INTVAL (x));\n+      return;\n     case 'Q':\n-      if (GET_CODE (x) == CONST_INT)\n-\t{\n-\t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, 64 - (INTVAL (x) & 63));\n-\t  return;\n-\t}\n-      abort ();\n+      gcc_assert (GET_CODE (x) == CONST_INT);\n+      fprintf (file, HOST_WIDE_INT_PRINT_DEC, 64 - (INTVAL (x) & 63));\n+      return;\n     case 'L':\n-      if (GET_CODE (x) == CONST_INT)\n-\t{\n-\t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, 32 - (INTVAL (x) & 31));\n-\t  return;\n-\t}\n-      abort ();\n+      gcc_assert (GET_CODE (x) == CONST_INT);\n+      fprintf (file, HOST_WIDE_INT_PRINT_DEC, 32 - (INTVAL (x) & 31));\n+      return;\n     case 'O':\n-      if (GET_CODE (x) == CONST_INT && exact_log2 (INTVAL (x)) >= 0)\n-\t{\n-\t  fprintf (file, \"%d\", exact_log2 (INTVAL (x)));\n-\t  return;\n-\t}\n-      abort ();\n+      gcc_assert (GET_CODE (x) == CONST_INT && exact_log2 (INTVAL (x)) >= 0);\n+      fprintf (file, \"%d\", exact_log2 (INTVAL (x)));\n+      return;\n     case 'p':\n-      if (GET_CODE (x) == CONST_INT)\n-\t{\n-\t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, 63 - (INTVAL (x) & 63));\n-\t  return;\n-\t}\n-      abort ();\n+      gcc_assert (GET_CODE (x) == CONST_INT);\n+      fprintf (file, HOST_WIDE_INT_PRINT_DEC, 63 - (INTVAL (x) & 63));\n+      return;\n     case 'P':\n-      if (GET_CODE (x) == CONST_INT)\n-\t{\n-\t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, 31 - (INTVAL (x) & 31));\n-\t  return;\n-\t}\n-      abort ();\n+      gcc_assert (GET_CODE (x) == CONST_INT);\n+      fprintf (file, HOST_WIDE_INT_PRINT_DEC, 31 - (INTVAL (x) & 31));\n+      return;\n     case 'I':\n       if (GET_CODE (x) == CONST_INT)\n \tfputs (\"i\", file);\n@@ -4926,7 +4880,7 @@ print_operand (FILE *file, rtx x, int code)\n \t addresses.  */\n       break;\n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   if (GET_CODE (x) == REG)\n     {\n@@ -5013,23 +4967,31 @@ output_global_address (FILE *file, rtx x, int round_constant)\n       int offset = 0;\t\t/* assembler wants -$global$ at end */\n       rtx base = NULL_RTX;\n \n-      if (GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF)\n+      switch (GET_CODE (XEXP (XEXP (x, 0), 0)))\n \t{\n+\tcase SYMBOL_REF:\n \t  base = XEXP (XEXP (x, 0), 0);\n \t  output_addr_const (file, base);\n+\t  break;\n+\tcase CONST_INT:\n+\t  offset = INTVAL (XEXP (XEXP (x, 0), 0));\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else if (GET_CODE (XEXP (XEXP (x, 0), 0)) == CONST_INT)\n-\toffset = INTVAL (XEXP (XEXP (x, 0), 0));\n-      else abort ();\n \n-      if (GET_CODE (XEXP (XEXP (x, 0), 1)) == SYMBOL_REF)\n+      switch (GET_CODE (XEXP (XEXP (x, 0), 1)))\n \t{\n+\tcase SYMBOL_REF:\n \t  base = XEXP (XEXP (x, 0), 1);\n \t  output_addr_const (file, base);\n+\t  break;\n+\tcase CONST_INT:\n+\t  offset = INTVAL (XEXP (XEXP (x, 0), 1));\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else if (GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)\n-\toffset = INTVAL (XEXP (XEXP (x, 0), 1));\n-      else abort ();\n \n       /* How bogus.  The compiler is apparently responsible for\n \t rounding the constant if it uses an LR field selector.\n@@ -5043,21 +5005,27 @@ output_global_address (FILE *file, rtx x, int round_constant)\n       if (round_constant)\n \toffset = ((offset + 0x1000) & ~0x1fff);\n \n-      if (GET_CODE (XEXP (x, 0)) == PLUS)\n+      switch (GET_CODE (XEXP (x, 0)))\n \t{\n+\tcase PLUS:\n \t  if (offset < 0)\n \t    {\n \t      offset = -offset;\n \t      sep = \"-\";\n \t    }\n \t  else\n \t    sep = \"+\";\n-\t}\n-      else if (GET_CODE (XEXP (x, 0)) == MINUS\n-\t       && (GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF))\n-\tsep = \"-\";\n-      else abort ();\n+\t  break;\n+\n+\tcase MINUS:\n+\t  gcc_assert (GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF);\n+\t  sep = \"-\";\n+\t  break;\n \n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      \n       if (!read_only_operand (base, VOIDmode) && !flag_pic)\n \tfputs (\"-$global$\", file);\n       if (offset)\n@@ -5441,9 +5409,9 @@ output_arg_descriptor (rtx call_insn)\n       return;\n     }\n \n-  if (GET_CODE (call_insn) != CALL_INSN)\n-    abort ();\n-  for (link = CALL_INSN_FUNCTION_USAGE (call_insn); link; link = XEXP (link, 1))\n+  gcc_assert (GET_CODE (call_insn) == CALL_INSN);\n+  for (link = CALL_INSN_FUNCTION_USAGE (call_insn);\n+       link; link = XEXP (link, 1))\n     {\n       rtx use = XEXP (link, 0);\n \n@@ -6021,7 +5989,7 @@ output_cbranch (rtx *operands, int nullify, int length, int negated, rtx insn)\n \treturn output_lbranch (operands[0], insn);\n \n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n   return buf;\n }\n@@ -6040,8 +6008,7 @@ output_lbranch (rtx dest, rtx insn)\n   if (dbr_sequence_length () != 0)\n     {\n       /* We can't handle a jump in the delay slot.  */\n-      if (GET_CODE (NEXT_INSN (insn)) == JUMP_INSN)\n-\tabort ();\n+      gcc_assert (GET_CODE (NEXT_INSN (insn)) != JUMP_INSN);\n \n       final_scan_insn (NEXT_INSN (insn), asm_out_file,\n \t\t       optimize, 0, NULL);\n@@ -6281,7 +6248,7 @@ output_bb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,\n \tbreak;\n \n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n   return buf;\n }\n@@ -6426,7 +6393,7 @@ output_bvb (rtx *operands ATTRIBUTE_UNUSED, int nullify, int length,\n \tbreak;\n \n       default:\n-\tabort ();\n+\tgcc_unreachable ();\n     }\n   return buf;\n }\n@@ -6475,13 +6442,15 @@ output_dbra (rtx *operands, rtx insn, int which_alternative)\n       if (! nullify && length == 4 && dbr_sequence_length () == 0)\n \tnullify = forward_branch_p (insn);\n \n-      /* Handle short versions first.  */\n-      if (length == 4 && nullify)\n-\treturn \"addib,%C2,n %1,%0,%3\";\n-      else if (length == 4 && ! nullify)\n-\treturn \"addib,%C2 %1,%0,%3\";\n-      else if (length == 8)\n+      switch (length)\n \t{\n+\tcase 4:\n+\t  if (nullify)\n+\t    return \"addib,%C2,n %1,%0,%3\";\n+\t  else\n+\t    return \"addib,%C2 %1,%0,%3\";\n+      \n+\tcase 8:\n \t  /* Handle weird backwards branch with a fulled delay slot\n \t     which is nullified.  */\n \t  if (dbr_sequence_length () != 0\n@@ -6503,9 +6472,11 @@ output_dbra (rtx *operands, rtx insn, int which_alternative)\n \t    return \"addi,%N2 %1,%0,%0\\n\\tb,n %3\";\n \t  else\n \t    return \"addi,%N2 %1,%0,%0\\n\\tb %3\";\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else\n-\tabort ();\n+      \n     }\n   /* Deal with gross reload from FP register case.  */\n   else if (which_alternative == 1)\n@@ -6580,13 +6551,15 @@ output_movb (rtx *operands, rtx insn, int which_alternative,\n       if (! nullify && length == 4 && dbr_sequence_length () == 0)\n \tnullify = forward_branch_p (insn);\n \n-      /* Handle short versions first.  */\n-      if (length == 4 && nullify)\n-\treturn \"movb,%C2,n %1,%0,%3\";\n-      else if (length == 4 && ! nullify)\n-\treturn \"movb,%C2 %1,%0,%3\";\n-      else if (length == 8)\n+      switch (length)\n \t{\n+\tcase 4:\n+\t  if (nullify)\n+\t    return \"movb,%C2,n %1,%0,%3\";\n+\t  else\n+\t    return \"movb,%C2 %1,%0,%3\";\n+\n+\tcase 8:\n \t  /* Handle weird backwards branch with a filled delay slot\n \t     which is nullified.  */\n \t  if (dbr_sequence_length () != 0\n@@ -6608,9 +6581,10 @@ output_movb (rtx *operands, rtx insn, int which_alternative,\n \t    return \"or,%N2 %1,%%r0,%0\\n\\tb,n %3\";\n \t  else\n \t    return \"or,%N2 %1,%%r0,%0\\n\\tb %3\";\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n-      else\n-\tabort ();\n     }\n   /* Deal with gross reload from FP register case.  */\n   else if (which_alternative == 1)\n@@ -7261,8 +7235,7 @@ output_call (rtx insn, rtx call_dest, int sibcall)\n     return \"\";\n \n   /* A sibcall should never have a branch in the delay slot.  */\n-  if (sibcall)\n-    abort ();\n+  gcc_assert (!sibcall);\n \n   /* This call has an unconditional jump in its delay slot.  */\n   xoperands[0] = XEXP (PATTERN (NEXT_INSN (insn)), 1);"}, {"sha": "5e4faadf335f8160cd120e18c9086a980771add4", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/144d51f9df000e9be80c419cb73f3823b50e85eb/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/144d51f9df000e9be80c419cb73f3823b50e85eb/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=144d51f9df000e9be80c419cb73f3823b50e85eb", "patch": "@@ -2814,9 +2814,9 @@\n   \"!is_function_label_plus_const (operands[2])\"\n   \"*\n {\n-  if (flag_pic && symbolic_operand (operands[2], Pmode))\n-    abort ();\n-  else if (symbolic_operand (operands[2], Pmode))\n+  gcc_assert (!flag_pic || !symbolic_operand (operands[2], Pmode));\n+  \n+  if (symbolic_operand (operands[2], Pmode))\n     return \\\"ldo RR'%G2(%1),%0\\\";\n   else\n     return \\\"ldo R'%G2(%1),%0\\\";\n@@ -4070,8 +4070,9 @@\n   rtx op0 = operands[0];\n   rtx op1 = operands[1];\n \n-  if (GET_CODE (op1) == CONST_INT)\n+  switch (GET_CODE (op1))\n     {\n+    case CONST_INT:\n       operands[0] = operand_subword (op0, 1, 0, DImode);\n       output_asm_insn (\\\"ldil L'%1,%0\\\", operands);\n \n@@ -4080,21 +4081,22 @@\n \toutput_asm_insn (\\\"ldi -1,%0\\\", operands);\n       else\n \toutput_asm_insn (\\\"ldi 0,%0\\\", operands);\n-      return \\\"\\\";\n-    }\n-  else if (GET_CODE (op1) == CONST_DOUBLE)\n-    {\n+      break;\n+\n+    case CONST_DOUBLE:\n       operands[0] = operand_subword (op0, 1, 0, DImode);\n       operands[1] = GEN_INT (CONST_DOUBLE_LOW (op1));\n       output_asm_insn (\\\"ldil L'%1,%0\\\", operands);\n \n       operands[0] = operand_subword (op0, 0, 0, DImode);\n       operands[1] = GEN_INT (CONST_DOUBLE_HIGH (op1));\n       output_asm_insn (singlemove_string (operands), operands);\n-      return \\\"\\\";\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n     }\n-  else\n-    abort ();\n+  return \\\"\\\";\n }\"\n   [(set_attr \"type\" \"move\")\n    (set_attr \"length\" \"8\")])\n@@ -7070,8 +7072,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t     the only method that we have for doing DImode multiplication\n \t     is with a libcall.  This could be trouble if we haven't\n \t     allocated enough space for the outgoing arguments.  */\n-\t  if (INTVAL (nb) > current_function_outgoing_args_size)\n-\t    abort ();\n+\t  gcc_assert (INTVAL (nb) <= current_function_outgoing_args_size);\n \n \t  emit_move_insn (arg_pointer_rtx,\n \t\t\t  gen_rtx_PLUS (word_mode, stack_pointer_rtx,\n@@ -7570,8 +7571,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t     the only method that we have for doing DImode multiplication\n \t     is with a libcall.  This could be trouble if we haven't\n \t     allocated enough space for the outgoing arguments.  */\n-\t  if (INTVAL (nb) > current_function_outgoing_args_size)\n-\t    abort ();\n+\t  gcc_assert (INTVAL (nb) <= current_function_outgoing_args_size);\n \n \t  emit_move_insn (arg_pointer_rtx,\n \t\t\t  gen_rtx_PLUS (word_mode, stack_pointer_rtx,\n@@ -8089,8 +8089,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t     the only method that we have for doing DImode multiplication\n \t     is with a libcall.  This could be trouble if we haven't\n \t     allocated enough space for the outgoing arguments.  */\n-\t  if (INTVAL (nb) > current_function_outgoing_args_size)\n-\t    abort ();\n+\t  gcc_assert (INTVAL (nb) <= current_function_outgoing_args_size);\n \n \t  emit_move_insn (arg_pointer_rtx,\n \t\t\t  gen_rtx_PLUS (word_mode, stack_pointer_rtx,\n@@ -8171,8 +8170,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \t     the only method that we have for doing DImode multiplication\n \t     is with a libcall.  This could be trouble if we haven't\n \t     allocated enough space for the outgoing arguments.  */\n-\t  if (INTVAL (nb) > current_function_outgoing_args_size)\n-\t    abort ();\n+\t  gcc_assert (INTVAL (nb) <= current_function_outgoing_args_size);\n \n \t  emit_move_insn (arg_pointer_rtx,\n \t\t\t  gen_rtx_PLUS (word_mode, stack_pointer_rtx,\n@@ -9263,8 +9261,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n {\n   int locality = INTVAL (operands[2]);\n \n-  if (locality < 0 || locality > 3)\n-    abort ();\n+  gcc_assert (locality >= 0 && locality <= 3);\n \n   /* Change operand[0] to a MEM as we don't have the infrastructure\n      to output all the supported address modes for ldw/ldd when we use\n@@ -9309,8 +9306,7 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   };\n   int read_or_write = INTVAL (operands[1]);\n \n-  if (read_or_write < 0 || read_or_write > 1)\n-    abort ();\n+  gcc_assert (read_or_write >= 0 && read_or_write <= 1);\n \n   return instr [read_or_write];\n }\n@@ -9338,9 +9334,8 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n   };\n   int read_or_write = INTVAL (operands[1]);\n \n-  if ((which_alternative != 0 && which_alternative != 1)\n-      || (read_or_write < 0 || read_or_write > 1))\n-    abort ();\n+  gcc_assert (which_alternative == 0 || which_alternative == 1);\n+  gcc_assert (read_or_write >= 0 && read_or_write <= 1);\n \n   return instr [which_alternative][read_or_write];\n }"}]}