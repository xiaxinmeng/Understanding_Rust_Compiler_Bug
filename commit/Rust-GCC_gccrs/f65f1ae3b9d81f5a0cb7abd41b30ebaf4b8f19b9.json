{"sha": "f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY1ZjFhZTNiOWQ4MWY1YTBjYjdhYmQ0MWIzMGViYWY0YjhmMTliOQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2017-01-23T13:01:31Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2017-01-23T13:01:31Z"}, "message": "[PR 79108] Put ipa_node_params to GC memory\n\n2017-01-23  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/79108\n\t* ipa-prop.h (ipa_param_descriptor): Anotate with with GTY(()).\n\t(ipa_node_params): Annotate with GTY((for_user)).  Make descriptors\n\tfield a pointer to garbage collected vector, mark lattices and\n\tipcp_orig_node with GTY((skip)).\n\t(ipa_get_param_count): Adjust to descriptors being a pointer.\n\t(ipa_get_param): Likewise.\n\t(ipa_get_type): Likewise.\n\t(ipa_get_param_move_cost): Likewise.\n\t(ipa_set_param_used): Likewise.\n\t(ipa_get_controlled_uses): Likewise.\n\t(ipa_set_controlled_uses): Likewise.\n\t(ipa_is_param_used): Likewise.\n\t(ipa_node_params_t): Move into garbage collector.  New methods insert\n\tand remove.\n\t(ipa_node_params_sum): Annotate wth GTY(()).\n\t(ipa_check_create_node_params): Adjust to ipa_node_params_sum being\n\tgarbage collected.\n\t(ipa_load_from_parm_agg): Adjust declaration.\n\t* ipa-icf.c (param_used_p): Adjust to descriptors being a pointer.\n\t* ipa-profile.c (ipa_profile): Likewise.\n\t* ipa-prop.c (ipa_get_param_decl_index_1): Likewise.\n\t(ipa_populate_param_decls): Make descriptors parameter garbage\n\tcollected.\n\t(ipa_dump_param): Adjust to descriptors being a pointer.\n\t(ipa_alloc_node_params): Likewise.\n\t(ipa_initialize_node_params): Likewise.\n\t(load_from_param_1): Make descriptors parameter garbage collected.\n\t(load_from_unmodified_param): Likewise.\n\t(load_from_param): Likewise.\n\t(ipa_load_from_parm_agg): Likewise.\n\t(ipa_node_params::~ipa_node_params): Removed.\n\t(ipa_free_all_node_params): Remove call to delete operator.\n\t(ipa_node_params_t::insert): New.\n\t(ipa_node_params_t::remove): Likewise.\n\t(ipa_node_params_t::duplicate): Adjust to descriptors being a pointer,\n\tcopy known_csts and known_contexts vectors.\n\t(ipa_read_node_info): Adjust to descriptors being a pointer.\n\t(ipcp_modif_dom_walker): Make m_descriptors field garbage\n\tcollected.\n\t(ipcp_transform_function): Make descriptors variable garbage\n\tcollected.\n\ntestsuite/\n\t* gfortran.dg/lto/pr79108_0.f90: New test.\n\nFrom-SVN: r244802", "tree": {"sha": "8da3470da277bad3168bcc84f6aff5dc0316be78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8da3470da277bad3168bcc84f6aff5dc0316be78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dea061117ae1f09ace7a417ab57ba738699c8712", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dea061117ae1f09ace7a417ab57ba738699c8712", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dea061117ae1f09ace7a417ab57ba738699c8712"}], "stats": {"total": 235, "additions": 161, "deletions": 74}, "files": [{"sha": "f370075e1fd93baebd2ecb23303deefc10cc0a38", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9", "patch": "@@ -1,3 +1,48 @@\n+2017-01-23  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/79108\n+\t* ipa-prop.h (ipa_param_descriptor): Anotate with with GTY(()).\n+\t(ipa_node_params): Annotate with GTY((for_user)).  Make descriptors\n+\tfield a pointer to garbage collected vector, mark lattices and\n+\tipcp_orig_node with GTY((skip)).\n+\t(ipa_get_param_count): Adjust to descriptors being a pointer.\n+\t(ipa_get_param): Likewise.\n+\t(ipa_get_type): Likewise.\n+\t(ipa_get_param_move_cost): Likewise.\n+\t(ipa_set_param_used): Likewise.\n+\t(ipa_get_controlled_uses): Likewise.\n+\t(ipa_set_controlled_uses): Likewise.\n+\t(ipa_is_param_used): Likewise.\n+\t(ipa_node_params_t): Move into garbage collector.  New methods insert\n+\tand remove.\n+\t(ipa_node_params_sum): Annotate wth GTY(()).\n+\t(ipa_check_create_node_params): Adjust to ipa_node_params_sum being\n+\tgarbage collected.\n+\t(ipa_load_from_parm_agg): Adjust declaration.\n+\t* ipa-icf.c (param_used_p): Adjust to descriptors being a pointer.\n+\t* ipa-profile.c (ipa_profile): Likewise.\n+\t* ipa-prop.c (ipa_get_param_decl_index_1): Likewise.\n+\t(ipa_populate_param_decls): Make descriptors parameter garbage\n+\tcollected.\n+\t(ipa_dump_param): Adjust to descriptors being a pointer.\n+\t(ipa_alloc_node_params): Likewise.\n+\t(ipa_initialize_node_params): Likewise.\n+\t(load_from_param_1): Make descriptors parameter garbage collected.\n+\t(load_from_unmodified_param): Likewise.\n+\t(load_from_param): Likewise.\n+\t(ipa_load_from_parm_agg): Likewise.\n+\t(ipa_node_params::~ipa_node_params): Removed.\n+\t(ipa_free_all_node_params): Remove call to delete operator.\n+\t(ipa_node_params_t::insert): New.\n+\t(ipa_node_params_t::remove): Likewise.\n+\t(ipa_node_params_t::duplicate): Adjust to descriptors being a pointer,\n+\tcopy known_csts and known_contexts vectors.\n+\t(ipa_read_node_info): Adjust to descriptors being a pointer.\n+\t(ipcp_modif_dom_walker): Make m_descriptors field garbage\n+\tcollected.\n+\t(ipcp_transform_function): Make descriptors variable garbage\n+\tcollected.\n+\n 2017-01-23  Andrew Senkevich  <andrew.senkevich@intel.com>\n \n \t* config/i386/avx512bwintrin.h: Add k-mask test, kortest intrinsics."}, {"sha": "b9a5b4f2546fbbccceeab33efe612c2cf75350b6", "filename": "gcc/ipa-icf.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9/gcc%2Fipa-icf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9/gcc%2Fipa-icf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf.c?ref=f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9", "patch": "@@ -539,9 +539,8 @@ sem_function::param_used_p (unsigned int i)\n \n   struct ipa_node_params *parms_info = IPA_NODE_REF (get_node ());\n \n-  if (parms_info->descriptors.is_empty ()\n-      || parms_info->descriptors.length () <= i)\n-     return true;\n+  if (vec_safe_length (parms_info->descriptors) <= i)\n+    return true;\n \n   return ipa_is_param_used (IPA_NODE_REF (get_node ()), i);\n }"}, {"sha": "ae1ca2f37625102a08883542506aac8a0ae635a5", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9", "patch": "@@ -621,7 +621,8 @@ ipa_profile (void)\n \t\t\t\t \"and can be discarded.\\n\");\n \t\t    }\n \t\t  else if (ipa_node_params_sum && ipa_edge_args_vector\n-\t\t\t   && !IPA_NODE_REF (n2)->descriptors.is_empty ()\n+\t\t\t   && (!vec_safe_is_empty\n+\t\t\t       (IPA_NODE_REF (n2)->descriptors))\n \t\t\t   && ipa_get_param_count (IPA_NODE_REF (n2))\n \t\t\t      != ipa_get_cs_argument_count (IPA_EDGE_REF (e))\n \t\t\t    && (ipa_get_param_count (IPA_NODE_REF (n2))"}, {"sha": "4d77c9b25ef772316e525872f0597d4bb6954d65", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 56, "deletions": 45, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9", "patch": "@@ -99,13 +99,14 @@ ipa_func_spec_opts_forbid_analysis_p (struct cgraph_node *node)\n    to INFO.  */\n \n static int\n-ipa_get_param_decl_index_1 (vec<ipa_param_descriptor> descriptors, tree ptree)\n+ipa_get_param_decl_index_1 (vec<ipa_param_descriptor, va_gc> *descriptors,\n+\t\t\t    tree ptree)\n {\n   int i, count;\n \n-  count = descriptors.length ();\n+  count = vec_safe_length (descriptors);\n   for (i = 0; i < count; i++)\n-    if (descriptors[i].decl_or_type == ptree)\n+    if ((*descriptors)[i].decl_or_type == ptree)\n       return i;\n \n   return -1;\n@@ -125,7 +126,7 @@ ipa_get_param_decl_index (struct ipa_node_params *info, tree ptree)\n \n static void\n ipa_populate_param_decls (struct cgraph_node *node,\n-\t\t\t  vec<ipa_param_descriptor> &descriptors)\n+\t\t\t  vec<ipa_param_descriptor, va_gc> &descriptors)\n {\n   tree fndecl;\n   tree fnargs;\n@@ -168,10 +169,10 @@ void\n ipa_dump_param (FILE *file, struct ipa_node_params *info, int i)\n {\n   fprintf (file, \"param #%i\", i);\n-  if (info->descriptors[i].decl_or_type)\n+  if ((*info->descriptors)[i].decl_or_type)\n     {\n       fprintf (file, \" \");\n-      print_generic_expr (file, info->descriptors[i].decl_or_type, 0);\n+      print_generic_expr (file, (*info->descriptors)[i].decl_or_type, 0);\n     }\n }\n \n@@ -183,8 +184,8 @@ ipa_alloc_node_params (struct cgraph_node *node, int param_count)\n {\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n \n-  if (!info->descriptors.exists () && param_count)\n-    info->descriptors.safe_grow_cleared (param_count);\n+  if (!info->descriptors && param_count)\n+    vec_safe_grow_cleared (info->descriptors, param_count);\n }\n \n /* Initialize the ipa_node_params structure associated with NODE by counting\n@@ -196,10 +197,10 @@ ipa_initialize_node_params (struct cgraph_node *node)\n {\n   struct ipa_node_params *info = IPA_NODE_REF (node);\n \n-  if (!info->descriptors.exists ())\n+  if (!info->descriptors)\n     {\n       ipa_alloc_node_params (node, count_formal_params (node->decl));\n-      ipa_populate_param_decls (node, info->descriptors);\n+      ipa_populate_param_decls (node, *info->descriptors);\n     }\n }\n \n@@ -867,7 +868,7 @@ parm_preserved_before_stmt_p (struct ipa_func_body_info *fbi, int index,\n \n static int\n load_from_param_1 (struct ipa_func_body_info *fbi,\n-\t\t   vec<ipa_param_descriptor> descriptors,\n+\t\t   vec<ipa_param_descriptor, va_gc> *descriptors,\n \t\t   gimple *stmt)\n {\n   int index;\n@@ -892,7 +893,7 @@ load_from_param_1 (struct ipa_func_body_info *fbi,\n \n static int\n load_from_unmodified_param (struct ipa_func_body_info *fbi,\n-\t\t\t    vec<ipa_param_descriptor> descriptors,\n+\t\t\t    vec<ipa_param_descriptor, va_gc> *descriptors,\n \t\t\t    gimple *stmt)\n {\n   if (!gimple_assign_single_p (stmt))\n@@ -906,7 +907,7 @@ load_from_unmodified_param (struct ipa_func_body_info *fbi,\n \n static int\n load_from_param (struct ipa_func_body_info *fbi,\n-\t\t vec<ipa_param_descriptor> descriptors,\n+\t\t vec<ipa_param_descriptor, va_gc> *descriptors,\n \t\t gimple *stmt)\n {\n   if (!is_gimple_assign (stmt))\n@@ -1010,7 +1011,7 @@ parm_ref_data_pass_through_p (struct ipa_func_body_info *fbi, int index,\n \n bool\n ipa_load_from_parm_agg (struct ipa_func_body_info *fbi,\n-\t\t\tvec<ipa_param_descriptor> descriptors,\n+\t\t\tvec<ipa_param_descriptor, va_gc> *descriptors,\n \t\t\tgimple *stmt, tree op, int *index_p,\n \t\t\tHOST_WIDE_INT *offset_p, HOST_WIDE_INT *size_p,\n \t\t\tbool *by_ref_p, bool *guaranteed_unmodified)\n@@ -3604,33 +3605,11 @@ ipa_free_all_edge_args (void)\n   vec_free (ipa_edge_args_vector);\n }\n \n-/* Frees all dynamically allocated structures that the param info points\n-   to.  */\n-\n-ipa_node_params::~ipa_node_params ()\n-{\n-  descriptors.release ();\n-  free (lattices);\n-  /* Lattice values and their sources are deallocated with their alocation\n-     pool.  */\n-  known_csts.release ();\n-  known_contexts.release ();\n-\n-  lattices = NULL;\n-  ipcp_orig_node = NULL;\n-  analysis_done = 0;\n-  node_enqueued = 0;\n-  do_clone_for_all_contexts = 0;\n-  is_all_contexts_clone = 0;\n-  node_dead = 0;\n-}\n-\n /* Free all ipa_node_params structures.  */\n \n void\n ipa_free_all_node_params (void)\n {\n-  delete ipa_node_params_sum;\n   ipa_node_params_sum = NULL;\n }\n \n@@ -3792,6 +3771,36 @@ ipa_add_new_function (cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n     ipa_analyze_node (node);\n }\n \n+/* Initialize a newly created param info.  */\n+\n+void\n+ipa_node_params_t::insert (cgraph_node *, ipa_node_params *info)\n+{\n+  info->lattices = NULL;\n+  info->ipcp_orig_node = NULL;\n+  info->analysis_done = 0;\n+  info->node_enqueued = 0;\n+  info->do_clone_for_all_contexts = 0;\n+  info->is_all_contexts_clone = 0;\n+  info->node_dead = 0;\n+  info->node_within_scc = 0;\n+  info->node_calling_single_call = 0;\n+  info->versionable = 0;\n+}\n+\n+/* Frees all dynamically allocated structures that the param info points\n+   to.  */\n+\n+void\n+ipa_node_params_t::remove (cgraph_node *, ipa_node_params *info)\n+{\n+  free (info->lattices);\n+  /* Lattice values and their sources are deallocated with their alocation\n+     pool.  */\n+  info->known_csts.release ();\n+  info->known_contexts.release ();\n+}\n+\n /* Hook that is called by summary when a node is duplicated.  */\n \n void\n@@ -3801,9 +3810,11 @@ ipa_node_params_t::duplicate(cgraph_node *src, cgraph_node *dst,\n {\n   ipa_agg_replacement_value *old_av, *new_av;\n \n-  new_info->descriptors = old_info->descriptors.copy ();\n+  new_info->descriptors = vec_safe_copy (old_info->descriptors);\n   new_info->lattices = NULL;\n   new_info->ipcp_orig_node = old_info->ipcp_orig_node;\n+  new_info->known_csts = old_info->known_csts.copy ();\n+  new_info->known_contexts = old_info->known_contexts.copy ();\n \n   new_info->analysis_done = old_info->analysis_done;\n   new_info->node_enqueued = old_info->node_enqueued;\n@@ -5022,7 +5033,7 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n   ipa_alloc_node_params (node, streamer_read_uhwi (ib));\n \n   for (k = 0; k < ipa_get_param_count (info); k++)\n-    info->descriptors[k].move_cost = streamer_read_uhwi (ib);\n+    (*info->descriptors)[k].move_cost = streamer_read_uhwi (ib);\n \n   bp = streamer_read_bitpack (ib);\n   if (ipa_get_param_count (info) != 0)\n@@ -5033,7 +5044,7 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n   for (k = 0; k < ipa_get_param_count (info); k++)\n     {\n       ipa_set_controlled_uses (info, k, streamer_read_hwi (ib));\n-      info->descriptors[k].decl_or_type = stream_read_tree (ib, data_in);\n+      (*info->descriptors)[k].decl_or_type = stream_read_tree (ib, data_in);\n     }\n   for (e = node->callees; e; e = e->next_callee)\n     {\n@@ -5483,7 +5494,7 @@ class ipcp_modif_dom_walker : public dom_walker\n {\n public:\n   ipcp_modif_dom_walker (struct ipa_func_body_info *fbi,\n-\t\t\t vec<ipa_param_descriptor> descs,\n+\t\t\t vec<ipa_param_descriptor, va_gc> *descs,\n \t\t\t struct ipa_agg_replacement_value *av,\n \t\t\t bool *sc, bool *cc)\n     : dom_walker (CDI_DOMINATORS), m_fbi (fbi), m_descriptors (descs),\n@@ -5493,7 +5504,7 @@ class ipcp_modif_dom_walker : public dom_walker\n \n private:\n   struct ipa_func_body_info *m_fbi;\n-  vec<ipa_param_descriptor> m_descriptors;\n+  vec<ipa_param_descriptor, va_gc> *m_descriptors;\n   struct ipa_agg_replacement_value *m_aggval;\n   bool *m_something_changed, *m_cfg_changed;\n };\n@@ -5751,7 +5762,7 @@ ipcp_update_vr (struct cgraph_node *node)\n unsigned int\n ipcp_transform_function (struct cgraph_node *node)\n {\n-  vec<ipa_param_descriptor> descriptors = vNULL;\n+  vec<ipa_param_descriptor, va_gc> *descriptors = NULL;\n   struct ipa_func_body_info fbi;\n   struct ipa_agg_replacement_value *aggval;\n   int param_count;\n@@ -5783,8 +5794,8 @@ ipcp_transform_function (struct cgraph_node *node)\n   fbi.param_count = param_count;\n   fbi.aa_walked = 0;\n \n-  descriptors.safe_grow_cleared (param_count);\n-  ipa_populate_param_decls (node, descriptors);\n+  vec_safe_grow_cleared (descriptors, param_count);\n+  ipa_populate_param_decls (node, *descriptors);\n   calculate_dominance_info (CDI_DOMINATORS);\n   ipcp_modif_dom_walker (&fbi, descriptors, aggval, &something_changed,\n \t\t\t &cfg_changed).walk (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n@@ -5799,7 +5810,7 @@ ipcp_transform_function (struct cgraph_node *node)\n   (*ipcp_transformations)[node->uid].bits = NULL;\n   (*ipcp_transformations)[node->uid].m_vr = NULL;\n \n-  descriptors.release ();\n+  vec_free (descriptors);\n \n   if (!something_changed)\n     return 0;"}, {"sha": "93a2390c321674ff370d49357e20d45140950d96", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9", "patch": "@@ -298,7 +298,7 @@ ipa_get_jf_ancestor_type_preserved (struct ipa_jump_func *jfunc)\n \n /* Summary describing a single formal parameter.  */\n \n-struct ipa_param_descriptor\n+struct GTY(()) ipa_param_descriptor\n {\n   /* In analysis and modification phase, this is the PARAM_DECL of this\n      parameter, in IPA LTO phase, this is the type of the the described\n@@ -318,25 +318,23 @@ struct ipa_param_descriptor\n    and some other information for interprocedural passes that operate on\n    parameters (such as ipa-cp).  */\n \n-struct ipa_node_params\n+struct GTY((for_user)) ipa_node_params\n {\n-  ~ipa_node_params ();\n-\n   /* Information about individual formal parameters that are gathered when\n      summaries are generated. */\n-  vec<ipa_param_descriptor> descriptors;\n+  vec<ipa_param_descriptor, va_gc> *descriptors;\n   /* Pointer to an array of structures describing individual formal\n      parameters.  */\n-  struct ipcp_param_lattices *lattices;\n+  struct ipcp_param_lattices * GTY((skip)) lattices;\n   /* Only for versioned nodes this field would not be NULL,\n      it points to the node that IPA cp cloned from.  */\n-  struct cgraph_node *ipcp_orig_node;\n+  struct cgraph_node * GTY((skip)) ipcp_orig_node;\n   /* If this node is an ipa-cp clone, these are the known constants that\n      describe what it has been specialized for.  */\n-  vec<tree> known_csts;\n+  vec<tree> GTY((skip)) known_csts;\n   /* If this node is an ipa-cp clone, these are the known polymorphic contexts\n      that describe what it has been specialized for.  */\n-  vec<ipa_polymorphic_call_context> known_contexts;\n+  vec<ipa_polymorphic_call_context> GTY((skip)) known_contexts;\n   /* Whether the param uses analysis and jump function computation has already\n      been performed.  */\n   unsigned analysis_done : 1;\n@@ -417,7 +415,7 @@ struct ipa_func_body_info\n static inline int\n ipa_get_param_count (struct ipa_node_params *info)\n {\n-  return info->descriptors.length ();\n+  return vec_safe_length (info->descriptors);\n }\n \n /* Return the declaration of Ith formal parameter of the function corresponding\n@@ -428,8 +426,9 @@ ipa_get_param_count (struct ipa_node_params *info)\n static inline tree\n ipa_get_param (struct ipa_node_params *info, int i)\n {\n+  gcc_checking_assert (info->descriptors);\n   gcc_checking_assert (!flag_wpa);\n-  tree t = info->descriptors[i].decl_or_type;\n+  tree t = (*info->descriptors)[i].decl_or_type;\n   gcc_checking_assert (TREE_CODE (t) == PARM_DECL);\n   return t;\n }\n@@ -440,7 +439,8 @@ ipa_get_param (struct ipa_node_params *info, int i)\n static inline tree\n ipa_get_type (struct ipa_node_params *info, int i)\n {\n-  tree t = info->descriptors[i].decl_or_type;\n+  gcc_checking_assert (info->descriptors);\n+  tree t = (*info->descriptors)[i].decl_or_type;\n   if (!t)\n     return NULL;\n   if (TYPE_P (t))\n@@ -455,7 +455,8 @@ ipa_get_type (struct ipa_node_params *info, int i)\n static inline int\n ipa_get_param_move_cost (struct ipa_node_params *info, int i)\n {\n-  return info->descriptors[i].move_cost;\n+  gcc_checking_assert (info->descriptors);\n+  return (*info->descriptors)[i].move_cost;\n }\n \n /* Set the used flag corresponding to the Ith formal parameter of the function\n@@ -464,7 +465,8 @@ ipa_get_param_move_cost (struct ipa_node_params *info, int i)\n static inline void\n ipa_set_param_used (struct ipa_node_params *info, int i, bool val)\n {\n-  info->descriptors[i].used = val;\n+  gcc_checking_assert (info->descriptors);\n+  (*info->descriptors)[i].used = val;\n }\n \n /* Return how many uses described by ipa-prop a parameter has or\n@@ -473,9 +475,9 @@ ipa_set_param_used (struct ipa_node_params *info, int i, bool val)\n static inline int\n ipa_get_controlled_uses (struct ipa_node_params *info, int i)\n {\n-  /* FIXME: introducing speuclation causes out of bounds access here.  */\n-  if (info->descriptors.length () > (unsigned)i)\n-    return info->descriptors[i].controlled_uses;\n+  /* FIXME: introducing speculation causes out of bounds access here.  */\n+  if (vec_safe_length (info->descriptors) > (unsigned)i)\n+    return (*info->descriptors)[i].controlled_uses;\n   return IPA_UNDESCRIBED_USE;\n }\n \n@@ -484,7 +486,8 @@ ipa_get_controlled_uses (struct ipa_node_params *info, int i)\n static inline void\n ipa_set_controlled_uses (struct ipa_node_params *info, int i, int val)\n {\n-  info->descriptors[i].controlled_uses = val;\n+  gcc_checking_assert (info->descriptors);\n+  (*info->descriptors)[i].controlled_uses = val;\n }\n \n /* Return the used flag corresponding to the Ith formal parameter of the\n@@ -493,7 +496,8 @@ ipa_set_controlled_uses (struct ipa_node_params *info, int i, int val)\n static inline bool\n ipa_is_param_used (struct ipa_node_params *info, int i)\n {\n-  return info->descriptors[i].used;\n+  gcc_checking_assert (info->descriptors);\n+  return (*info->descriptors)[i].used;\n }\n \n /* Information about replacements done in aggregates for a given node (each\n@@ -569,12 +573,16 @@ ipa_get_ith_polymorhic_call_context (struct ipa_edge_args *args, int i)\n }\n \n /* Function summary for ipa_node_params.  */\n-class ipa_node_params_t: public function_summary <ipa_node_params *>\n+class GTY((user)) ipa_node_params_t: public function_summary <ipa_node_params *>\n {\n public:\n-  ipa_node_params_t (symbol_table *table):\n-    function_summary<ipa_node_params *> (table) { }\n+  ipa_node_params_t (symbol_table *table, bool ggc):\n+    function_summary<ipa_node_params *> (table, ggc) { }\n \n+  /* Hook that is called by summary when a node is deleted.  */\n+  virtual void insert (cgraph_node *, ipa_node_params *info);\n+  /* Hook that is called by summary when a node is deleted.  */\n+  virtual void remove (cgraph_node *, ipa_node_params *info);\n   /* Hook that is called by summary when a node is duplicated.  */\n   virtual void duplicate (cgraph_node *node,\n \t\t\t  cgraph_node *node2,\n@@ -583,12 +591,14 @@ class ipa_node_params_t: public function_summary <ipa_node_params *>\n };\n \n /* Function summary where the parameter infos are actually stored. */\n-extern ipa_node_params_t *ipa_node_params_sum;\n+extern GTY(()) ipa_node_params_t * ipa_node_params_sum;\n+\n /* Vector of IPA-CP transformation data for each clone.  */\n extern GTY(()) vec<ipcp_transformation_summary, va_gc> *ipcp_transformations;\n /* Vector where the parameter infos are actually stored. */\n extern GTY(()) vec<ipa_edge_args, va_gc> *ipa_edge_args_vector;\n \n+\n /* Return the associated parameter/argument info corresponding to the given\n    node/edge.  */\n #define IPA_NODE_REF(NODE) (ipa_node_params_sum->get (NODE))\n@@ -616,7 +626,9 @@ static inline void\n ipa_check_create_node_params (void)\n {\n   if (!ipa_node_params_sum)\n-    ipa_node_params_sum = new ipa_node_params_t (symtab);\n+    ipa_node_params_sum\n+      = (new (ggc_cleared_alloc <ipa_node_params_t> ())\n+\t ipa_node_params_t (symtab, true));\n }\n \n /* This function ensures the array of edge arguments infos is big enough to\n@@ -680,7 +692,7 @@ tree ipa_find_agg_cst_for_param (struct ipa_agg_jump_function *agg, tree scalar,\n \t\t\t\t HOST_WIDE_INT offset, bool by_ref,\n \t\t\t\t bool *from_global_constant = NULL);\n bool ipa_load_from_parm_agg (struct ipa_func_body_info *fbi,\n-\t\t\t     vec<ipa_param_descriptor> descriptors,\n+\t\t\t     vec<ipa_param_descriptor, va_gc> *descriptors,\n \t\t\t     gimple *stmt, tree op, int *index_p,\n \t\t\t     HOST_WIDE_INT *offset_p, HOST_WIDE_INT *size_p,\n \t\t\t     bool *by_ref, bool *guaranteed_unmodified = NULL);"}, {"sha": "2ac5e2371fc1c29c335c36411cb364f24514498a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9", "patch": "@@ -1,3 +1,8 @@\n+2017-01-23  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR ipa/79108\n+\t* gfortran.dg/lto/pr79108_0.f90: New test.\n+\n 2017-01-23  Andrew Senkevich  <andrew.senkevich@intel.com>\n \n \t* gcc.target/i386/avx512bw-ktestd-1.c: New test."}, {"sha": "58412afc3c82a99bd26ed5c6b5eed4c4b750bd4a", "filename": "gcc/testsuite/gfortran.dg/lto/pr79108_0.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr79108_0.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr79108_0.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Flto%2Fpr79108_0.f90?ref=f65f1ae3b9d81f5a0cb7abd41b30ebaf4b8f19b9", "patch": "@@ -0,0 +1,14 @@\n+! { dg-lto-do link }\n+! { dg-lto-options {{ -Ofast -flto --param ggc-min-expand=0 --param ggc-min-heapsize=0 }} }\n+! { dg-extra-ld-options \"-r -nostdlib\" }\n+\n+MODULE Errorcheck_mod\n+CONTAINS\n+SUBROUTINE Check_open(ios, outputstr, errortype)\n+character(len=*), intent(in) :: outputstr\n+if (ios > 0 .AND. errortype == FATAL) then\n+  write(*,*) 'The value of ios was:', ios\n+end if\n+END SUBROUTINE Check_open\n+END MODULE Errorcheck_mod\n+"}]}