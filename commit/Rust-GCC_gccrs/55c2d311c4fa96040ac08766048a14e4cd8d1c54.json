{"sha": "55c2d311c4fa96040ac08766048a14e4cd8d1c54", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTVjMmQzMTFjNGZhOTYwNDBhYzA4NzY2MDQ4YTE0ZTRjZDhkMWM1NA==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1994-06-29T00:23:02Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1994-06-29T00:23:02Z"}, "message": "(expand_mult): Generalize to call synth_mult also for OP1 - 1.\n\n(ceil_log2): New function.\n(choose_multiplier): New function.\n(invert_mod2n): New function.\n(expand_mult_highpart_adjust): New function.\n(expand_mult_highpart): New function.\n(EXACT_POWER_OF_2_OR_ZERO_P): New macro.\n(expand_divmod): Almost completely rewritten.\n(expand_shift): Don't truncate immediate shift count, it doesn't work\nfor types smaller than int.\n\nFrom-SVN: r7598", "tree": {"sha": "f5e1c65b7384427b6ac16559fdf1aff8627e0af9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5e1c65b7384427b6ac16559fdf1aff8627e0af9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55c2d311c4fa96040ac08766048a14e4cd8d1c54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55c2d311c4fa96040ac08766048a14e4cd8d1c54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55c2d311c4fa96040ac08766048a14e4cd8d1c54", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55c2d311c4fa96040ac08766048a14e4cd8d1c54/comments", "author": null, "committer": null, "parents": [{"sha": "f02d60632fba813e03fedf69fc1cd47f5cf4b712", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f02d60632fba813e03fedf69fc1cd47f5cf4b712", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f02d60632fba813e03fedf69fc1cd47f5cf4b712"}], "stats": {"total": 1313, "additions": 1024, "deletions": 289}, "files": [{"sha": "ee16ed4544edb665f8483c432f3a289b3772b301", "filename": "gcc/expmed.c", "status": "modified", "additions": 1024, "deletions": 289, "changes": 1313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55c2d311c4fa96040ac08766048a14e4cd8d1c54/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55c2d311c4fa96040ac08766048a14e4cd8d1c54/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=55c2d311c4fa96040ac08766048a14e4cd8d1c54", "patch": "@@ -1645,7 +1645,7 @@ expand_shift (code, mode, shifted, amount, target, unsignedp)\n \n   op1 = expand_expr (amount, NULL_RTX, VOIDmode, 0);\n \n-#if SHIFT_COUNT_TRUNCATED\n+#if 0 && SHIFT_COUNT_TRUNCATED\n   if (SHIFT_COUNT_TRUNCATED\n       && GET_CODE (op1) == CONST_INT\n       && (unsigned HOST_WIDE_INT) INTVAL (op1) >= GET_MODE_BITSIZE (mode))\n@@ -2068,29 +2068,30 @@ expand_mult (mode, op0, op1, target, unsignedp)\n   if (GET_CODE (const_op1) == CONST_INT)\n     {\n       struct algorithm alg;\n-      struct algorithm neg_alg;\n-      int negate = 0;\n+      struct algorithm alg2;\n       HOST_WIDE_INT val = INTVAL (op1);\n       HOST_WIDE_INT val_so_far;\n       rtx insn;\n       int mult_cost;\n+      enum {basic_variant, negate_variant, add_variant} variant = basic_variant;\n \n-      /* Try to do the computation two ways: multiply by the negative of OP1\n-\t and then negate, or do the multiplication directly.  The latter is\n-\t usually faster for positive numbers and the former for negative\n-\t numbers, but the opposite can be faster if the original value\n-\t has a factor of 2**m +/- 1, while the negated value does not or\n-\t vice versa.  */\n+      /* Try to do the computation three ways: multiply by the negative of OP1\n+\t and then negate, do the multiplication directly, or do multiplication\n+\t by OP1 - 1.  */\n \n       mult_cost = rtx_cost (gen_rtx (MULT, mode, op0, op1), SET);\n       mult_cost = MIN (12 * add_cost, mult_cost);\n \n       synth_mult (&alg, val, mult_cost);\n-      synth_mult (&neg_alg, - val,\n+      synth_mult (&alg2, - val,\n \t\t  (alg.cost < mult_cost ? alg.cost : mult_cost) - negate_cost);\n+      if (alg2.cost + negate_cost < alg.cost)\n+\talg = alg2, variant = negate_variant;\n \n-      if (neg_alg.cost + negate_cost < alg.cost)\n-\talg = neg_alg, negate = 1;\n+      /* This proves very useful for division-by-constant.  */\n+      synth_mult (&alg2, val - 1, (alg.cost < mult_cost ? alg.cost : mult_cost) - add_cost);\n+      if (alg2.cost + add_cost < alg.cost)\n+\talg = alg2, variant = add_variant;\n \n       if (alg.cost < mult_cost)\n \t{\n@@ -2202,11 +2203,16 @@ expand_mult (mode, op0, op1, target, unsignedp)\n \t\t\t   REG_NOTES (insn));\n \t    }\n \n-\t  if (negate)\n+\t  if (variant == negate_variant)\n \t    {\n \t      val_so_far = - val_so_far;\n \t      accum = expand_unop (mode, neg_optab, accum, target, 0);\n \t    }\n+\t  else if (variant == add_variant)\n+\t    {\n+\t      val_so_far = val_so_far + 1;\n+\t      accum = force_operand (gen_rtx (PLUS, mode, accum, op0), target);\n+\t    }\n \n \t  if (val != val_so_far)\n \t    abort ();\n@@ -2224,6 +2230,299 @@ expand_mult (mode, op0, op1, target, unsignedp)\n   return op0;\n }\n \f\n+/* Return the smallest n such that 2**n >= X.  */\n+\n+int\n+ceil_log2 (x)\n+     unsigned HOST_WIDE_INT x;\n+{\n+  return floor_log2 (x - 1) + 1;\n+}\n+\n+/* Choose a minimal N + 1 bit approximation to 1/D that can be used to\n+   replace division by D, and put the least significant N bits of the result\n+   in *MULTIPLIER_PTR and return the most significant bit.\n+\n+   The width of operations is N (should be <= HOST_BITS_PER_WIDE_INT), the\n+   needed precision is in PRECISION (should be <= N).\n+\n+   PRECISION should be as small as possible so this function can choose\n+   multiplier more freely.\n+\n+   The rounded-up logarithm of D is placed in *lgup_ptr.  A shift count that\n+   is to be used for a final right shift is placed in *POST_SHIFT_PTR.\n+\n+   Using this function, x/D will be equal to (x * m) >> (*POST_SHIFT_PTR),\n+   where m is the full HOST_BITS_PER_WIDE_INT + 1 bit multiplier.  */\n+\n+static\n+unsigned HOST_WIDE_INT\n+choose_multiplier (d, n, precision, multiplier_ptr, post_shift_ptr, lgup_ptr)\n+     unsigned HOST_WIDE_INT d;\n+     int n;\n+     int precision;\n+     unsigned HOST_WIDE_INT *multiplier_ptr;\n+     int *post_shift_ptr;\n+     int *lgup_ptr;\n+{\n+  unsigned HOST_WIDE_INT mhigh_hi, mhigh_lo;\n+  unsigned HOST_WIDE_INT mlow_hi, mlow_lo;\n+  int lgup, post_shift;\n+  int pow, pow2;\n+  unsigned HOST_WIDE_INT nh, nl, dummy1, dummy2;\n+\n+  /* lgup = ceil(log2(divisor)); */\n+  lgup = ceil_log2 (d);\n+\n+  if (lgup > n)\n+    abort ();\n+\n+  pow = n + lgup;\n+  pow2 = n + lgup - precision;\n+\n+  if (pow == 2 * HOST_BITS_PER_WIDE_INT)\n+    {\n+      /* We could handle this with some effort, but this case is much better\n+\t handled directly with a scc insn, so rely on caller using that.  */\n+      abort ();\n+    }\n+\n+  /* mlow = 2^(N + lgup)/d */\n+ if (pow >= HOST_BITS_PER_WIDE_INT)\n+    {\n+      nh = (unsigned HOST_WIDE_INT) 1 << (pow - HOST_BITS_PER_WIDE_INT);\n+      nl = 0;\n+    }\n+  else\n+    {\n+      nh = 0;\n+      nl = (unsigned HOST_WIDE_INT) 1 << pow;\n+    }\n+  div_and_round_double (TRUNC_DIV_EXPR, 1, nl, nh, d, (HOST_WIDE_INT) 0,\n+\t\t\t&mlow_lo, &mlow_hi, &dummy1, &dummy2);\n+\n+  /* mhigh = (2^(N + lgup) + 2^N + lgup - precision)/d */\n+  if (pow2 >= HOST_BITS_PER_WIDE_INT)\n+    nh |= (unsigned HOST_WIDE_INT) 1 << (pow2 - HOST_BITS_PER_WIDE_INT);\n+  else\n+    nl |= (unsigned HOST_WIDE_INT) 1 << pow2;\n+  div_and_round_double (TRUNC_DIV_EXPR, 1, nl, nh, d, (HOST_WIDE_INT) 0,\n+\t\t\t&mhigh_lo, &mhigh_hi, &dummy1, &dummy2);\n+\n+  if (mhigh_hi && nh - d >= d)\n+    abort ();\n+  if (mhigh_hi > 1 || mlow_hi > 1)\n+    abort ();\n+  /* assert that mlow < mhigh.  */\n+  if (! (mlow_hi < mhigh_hi || (mlow_hi == mhigh_hi && mlow_lo < mhigh_lo)))\n+    abort();\n+\n+  /* If precision == N, then mlow, mhigh exceed 2^N\n+     (but they do not exceed 2^(N+1)).  */\n+\n+  /* Reduce to lowest terms */\n+  for (post_shift = lgup; post_shift > 0; post_shift--)\n+    {\n+      unsigned HOST_WIDE_INT ml_lo = (mlow_hi << (HOST_BITS_PER_WIDE_INT - 1)) | (mlow_lo >> 1);\n+      unsigned HOST_WIDE_INT mh_lo = (mhigh_hi << (HOST_BITS_PER_WIDE_INT - 1)) | (mhigh_lo >> 1);\n+      if (ml_lo >= mh_lo)\n+\tbreak;\n+\n+      mlow_hi = 0;\n+      mlow_lo = ml_lo;\n+      mhigh_hi = 0;\n+      mhigh_lo = mh_lo;\n+    }\n+\n+  *post_shift_ptr = post_shift;\n+  *lgup_ptr = lgup;\n+  if (n < HOST_BITS_PER_WIDE_INT)\n+    {\n+      unsigned HOST_WIDE_INT mask = ((unsigned HOST_WIDE_INT) 1 << n) - 1;\n+      *multiplier_ptr = mhigh_lo & mask;\n+      return mhigh_lo >= mask;\n+    }\n+  else\n+    {\n+      *multiplier_ptr = mhigh_lo;\n+      return mhigh_hi;\n+    }\n+}\n+\n+/* Compute the inverse of X mod 2**n, i.e., find Y such that X * Y is\n+   congruent to 1 (mod 2**N).  */\n+\n+static unsigned HOST_WIDE_INT\n+invert_mod2n (x, n)\n+     unsigned HOST_WIDE_INT x;\n+     int n;\n+{\n+  /* Solve x*y == 1 (mod 2^n), where x is odd.  Return y. */\n+\n+  /* The algorithm notes that the choice y = x satisfies\n+     x*y == 1 mod 2^3, since x is assumed odd.\n+     Each iteration doubles the number of bits of significance in y.  */\n+\n+  unsigned HOST_WIDE_INT mask;\n+  unsigned HOST_WIDE_INT y = x;\n+  int nbit = 3;\n+\n+  mask = (n == HOST_BITS_PER_WIDE_INT\n+\t  ? ~(unsigned HOST_WIDE_INT) 0\n+\t  : ((unsigned HOST_WIDE_INT) 1 << n) - 1);\n+\n+  while (nbit < n)\n+    {\n+      y = y * (2 - x*y) & mask;\t\t/* Modulo 2^N */\n+      nbit *= 2;\n+    }\n+  return y;\n+}\n+\n+/* Emit code to adjust ADJ_OPERAND after multiplication of wrong signedness\n+   flavor of OP0 and OP1.  ADJ_OPERAND is already the high half of the\n+   product OP0 x OP1.  If UNSIGNEDP is nonzero, adjust the signed product\n+   to become unsigned, if UNSIGNEDP is zero, adjust the unsigned product to\n+   become signed.\n+\n+   The result is put in TARGET if that is convenient.\n+\n+   MODE is the mode of operation.  */\n+\n+rtx\n+expand_mult_highpart_adjust (mode, adj_operand, op0, op1, target, unsignedp)\n+     enum machine_mode mode;\n+     register rtx adj_operand, op0, op1, target;\n+     int unsignedp;\n+{\n+  rtx tem;\n+  enum rtx_code adj_code = unsignedp ? PLUS : MINUS;\n+\n+  tem = expand_shift (RSHIFT_EXPR, mode, op0,\n+\t\t      build_int_2 (GET_MODE_BITSIZE (mode) - 1, 0),\n+\t\t      NULL_RTX, 0);\n+  tem = expand_and (tem, op1, NULL_RTX);\n+  adj_operand = force_operand (gen_rtx (adj_code, mode, adj_operand, tem),\n+\t\t\t       adj_operand);\n+\n+  tem = expand_shift (RSHIFT_EXPR, mode, op1,\n+\t\t      build_int_2 (GET_MODE_BITSIZE (mode) - 1, 0),\n+\t\t      NULL_RTX, 0);\n+  tem = expand_and (tem, op0, NULL_RTX);\n+  target = force_operand (gen_rtx (adj_code, mode, adj_operand, tem), target);\n+\n+  return target;\n+}\n+\n+/* Emit code to multiply OP0 and CNST1, putting the high half of the result\n+   in TARGET if that is convenient, and return where the result is.  If the\n+   operation can not be performed, 0 is returned.\n+\n+   MODE is the mode of operation and result.\n+\n+   UNSIGNEDP nonzero means unsigned multiply.  */\n+\n+rtx\n+expand_mult_highpart (mode, op0, cnst1, target, unsignedp)\n+     enum machine_mode mode;\n+     register rtx op0, target;\n+     unsigned HOST_WIDE_INT cnst1;\n+     int unsignedp;\n+{\n+  enum machine_mode wider_mode = GET_MODE_WIDER_MODE (mode);\n+  optab mul_highpart_optab;\n+  optab moptab;\n+  rtx tem;\n+  int size = GET_MODE_BITSIZE (mode);\n+  rtx op1;\n+\n+  op1 = immed_double_const (cnst1,\n+\t\t\t    (unsignedp\n+\t\t\t     ? (HOST_WIDE_INT) 0\n+\t\t\t     : -(cnst1 >> (HOST_BITS_PER_WIDE_INT - 1))),\n+\t\t\t    wider_mode);\n+\n+  /* expand_mult handles constant multiplication of word_mode\n+     or narrower.  It does a poor job for large modes.  */\n+  if (size < BITS_PER_WORD)\n+    {\n+      /* We have to do this, since expand_binop doesn't do conversion for\n+\t multiply.  Maybe change expand_binop to handle widening multiply?  */\n+      op0 = convert_to_mode (wider_mode, op0, unsignedp);\n+\n+      tem = expand_mult (wider_mode, op0, op1, NULL_RTX, unsignedp);\n+      tem = expand_shift (RSHIFT_EXPR, wider_mode, tem,\n+\t\t\t  build_int_2 (size, 0), NULL_RTX, 1);\n+      return gen_lowpart (mode, tem);\n+    }\n+\n+  if (target == 0)\n+    target = gen_reg_rtx (mode);\n+\n+  /* Firstly, try using a multiplication insn that only generates the needed\n+     high part of the product, and in the sign flavor of unsignedp.  */\n+  mul_highpart_optab = unsignedp ? umul_highpart_optab : smul_highpart_optab;\n+  target = expand_binop (mode, mul_highpart_optab,\n+\t\t\t op0, op1, target, unsignedp, OPTAB_DIRECT);\n+  if (target)\n+    return target;\n+\n+  /* Secondly, same as above, but use sign flavor opposite of unsignedp.\n+     Need to adjust the result after the multiplication.  */\n+  mul_highpart_optab = unsignedp ? smul_highpart_optab : umul_highpart_optab;\n+  target = expand_binop (mode, mul_highpart_optab,\n+\t\t\t op0, op1, target, unsignedp, OPTAB_DIRECT);\n+  if (target)\n+    /* We used the wrong signedness.  Adjust the result.  */\n+    return expand_mult_highpart_adjust (mode, target, op0,\n+\t\t\t\t\tGEN_INT (cnst1), target, unsignedp);\n+\n+  /* Thirdly, we try to use a widening multiplication, or a wider mode\n+     multiplication.  */\n+\n+  moptab = unsignedp ? umul_widen_optab : smul_widen_optab;\n+  if (moptab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing)\n+    ;\n+  else if (smul_optab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing)\n+    moptab = smul_optab;\n+  else\n+    {\n+      /* Try widening multiplication of opposite signedness, and adjust.  */\n+      moptab = unsignedp ? smul_widen_optab : umul_widen_optab;\n+      if (moptab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing)\n+\t{\n+\t  tem = expand_binop (wider_mode, moptab, op0, op1,\n+\t\t\t      NULL_RTX, ! unsignedp, OPTAB_WIDEN);\n+\t  if (tem != 0)\n+\t    {\n+\t      /* Extract the high half of the just generated product.  */\n+\t      tem = expand_shift (RSHIFT_EXPR, wider_mode, tem,\n+\t\t\t\t  build_int_2 (size, 0), NULL_RTX, 1);\n+\t      tem = gen_lowpart (mode, tem);\n+\t      /* We used the wrong signedness.  Adjust the result.  */\n+\t      return expand_mult_highpart_adjust (mode, tem, op0,\n+\t\t\t\t\t\t  GEN_INT (cnst1),\n+\t\t\t\t\t\t  target, unsignedp);\n+\t    }\n+\t}\n+\n+      /* As a last resort, try widening the mode and perform a\n+\t non-widening multiplication.  */\n+      moptab = smul_optab;\n+    }\n+\n+  /* Pass NULL_RTX as target since TARGET has wrong mode.  */\n+  tem = expand_binop (wider_mode, moptab, op0, op1,\n+\t\t      NULL_RTX, unsignedp, OPTAB_WIDEN);\n+  if (tem == 0)\n+    return 0;\n+\n+  /* Extract the high half of the just generated product.  */\n+  tem = expand_shift (RSHIFT_EXPR, wider_mode, tem,\n+\t\t      build_int_2 (size, 0), NULL_RTX, 1);\n+  return gen_lowpart (mode, tem);\n+}\n+\f\n /* Emit the code to divide OP0 by OP1, putting the result in TARGET\n    if that is convenient, and returning where the result is.\n    You may request either the quotient or the remainder as the result;\n@@ -2241,6 +2540,8 @@ expand_mult (mode, op0, op1, target, unsignedp)\n    But C doesn't use these operations, so their optimizations are\n    left for later.  */\n \n+#define EXACT_POWER_OF_2_OR_ZERO_P(x) (((x) & ((x) - 1)) == 0)\n+\n rtx\n expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n      int rem_flag;\n@@ -2249,16 +2550,49 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n      register rtx op0, op1, target;\n      int unsignedp;\n {\n-  register rtx result = 0;\n   enum machine_mode compute_mode;\n-  int log = -1;\n+  register rtx tquotient;\n+  rtx quotient = 0, remainder = 0;\n+  rtx last;\n   int size;\n-  int can_clobber_op0;\n-  int mod_insn_no_good = 0;\n-  rtx adjusted_op0 = op0;\n+  rtx insn;\n   optab optab1, optab2;\n+  int op1_is_constant, op1_is_pow2;\n+\n+  op1_is_constant = GET_CODE (op1) == CONST_INT;\n+  op1_is_pow2 = (EXACT_POWER_OF_2_OR_ZERO_P (INTVAL (op1))\n+\t\t || EXACT_POWER_OF_2_OR_ZERO_P (-INTVAL (op1)));\n+\n+  /*\n+     This is the structure of expand_divmod:\n+\n+     First comes code to fix up the operands so we can perform the operations\n+     correctly and efficiently.\n+\n+     Second comes a switch statement with code specific for each rounding mode.\n+     For some special operands this code emits all RTL for the desired\n+     operation, for other cases, it generates a quotient and stores it in\n+     QUOTIENT.  The case for trunc division/remainder might leave quotient = 0,\n+     to indicate that it has not done anything.\n+\n+     Last comes code that finishes the operation.  If QUOTIENT is set an\n+     REM_FLAG, the remainder is computed as OP0 - QUOTIENT * OP1.  If QUOTIENT\n+     is not set, it is computed using trunc rounding.\n+\n+     We try to generate special code for division and remainder when OP1 is a\n+     constant.  If |OP1| = 2**n we can use shifts and some other fast\n+     operations.  For other values of OP1, we compute a carefully selected\n+     fixed-point approximation m = 1/OP1, and generate code that multiplies OP0\n+     by m.\n+\n+     In all cases but EXACT_DIV_EXPR, this multiplication requires the upper\n+     half of the product.  Different strategies for generating the product are\n+     implemented in expand_mult_highpart.\n \n-  /* We shouldn't be called with op1 == const1_rtx, but some of the\n+     If what we actually want is the remainder, we generate that by another\n+     by-constant multiplication and a subtraction.  */\n+\n+  /* We shouldn't be called with OP1 == const1_rtx, but some of the\n      code below will malfunction if we are, so check here and handle\n      the special case if so.  */\n   if (op1 == const1_rtx)\n@@ -2277,37 +2611,6 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t  || (GET_CODE (op1) == MEM && GET_CODE (target) == MEM)))\n     target = 0;\n \n-  /* See if we are dividing by 2**log, and hence will do it by shifting,\n-     which is really floor-division, or if we will really do a divide,\n-     and we assume that is trunc-division.\n-\n-     We must correct the dividend by adding or subtracting something\n-     based on the divisor, in order to do the kind of rounding specified\n-     by CODE.  The correction depends on what kind of rounding is actually\n-     available, and that depends on whether we will shift or divide.\n-\n-     In many of these cases it is possible to perform the operation by a\n-     clever series of logical operations (shifts and/or exclusive-ors).\n-     Although avoiding the jump has the advantage that it extends the basic\n-     block and allows further optimization, the branch-free code is normally\n-     at least one instruction longer in the (most common) case where the\n-     dividend is non-negative.  Performance measurements of the two\n-     alternatives show that the branch-free code is slightly faster on the\n-     IBM ROMP but slower on CISC processors (significantly slower on the\n-     VAX).  Accordingly, the jump code has been retained when BRANCH_COST\n-     is small.\n-\n-     On machines where the jump code is slower, the cost of a DIV or MOD\n-     operation can be set small (less than twice that of an addition); in \n-     that case, we pretend that we don't have a power of two and perform\n-     a normal division or modulus operation.  */\n-\n-  if (GET_CODE (op1) == CONST_INT\n-      && ! ((code == TRUNC_MOD_EXPR || code == TRUNC_DIV_EXPR)\n-\t    && ! unsignedp\n-\t    && (rem_flag ? smod_pow2_cheap : sdiv_pow2_cheap)))\n-    log = exact_log2 (INTVAL (op1));\n-\n   /* Get the mode in which to perform this computation.  Normally it will\n      be MODE, but sometimes we can't do the desired operation in MODE.\n      If so, pick a wider mode in which we can do the operation.  Convert\n@@ -2323,9 +2626,14 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n      (either a division, modulus, or shift).  Finally, check for the smallest\n      mode for which we can do the operation with a library call.  */\n \n-  optab1 = (log >= 0 ? (unsignedp ? lshr_optab : ashr_optab)\n+  /* We might want to refine this now that we have division-by-constant\n+     optimization.  Since expand_mult_highpart tries so many variants, it is\n+     not straightforward to generalize this.  Maybe we should make an array\n+     of possible modes in init_expmed?  Save this for GCC 2.7.  */\n+\n+  optab1 = (op1_is_pow2 ? (unsignedp ? lshr_optab : ashr_optab)\n \t    : (unsignedp ? udiv_optab : sdiv_optab));\n-  optab2 = (log >= 0 ? optab1 : (unsignedp ? udivmod_optab : sdivmod_optab));\n+  optab2 = (op1_is_pow2 ? optab1 : (unsignedp ? udivmod_optab : sdivmod_optab));\n \n   for (compute_mode = mode; compute_mode != VOIDmode;\n        compute_mode = GET_MODE_WIDER_MODE (compute_mode))\n@@ -2345,294 +2653,721 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n   if (compute_mode == VOIDmode)\n     compute_mode = mode;\n \n-  size = GET_MODE_BITSIZE (compute_mode);\n+  if (target && GET_MODE (target) == compute_mode)\n+    tquotient = target;\n+  else\n+    tquotient = gen_reg_rtx (compute_mode);\n \n-  /* If OP0 is a register that is used as the target, we can modify\n-     it in place; otherwise, we have to ensure we copy OP0 before\n-     modifying it.  */\n-  can_clobber_op0 = (GET_CODE (op0) == REG && op0 == target);\n+  size = GET_MODE_BITSIZE (compute_mode);\n+#if 0\n+  /* It should be possible to restrict the precision to GET_MODE_BITSIZE\n+     (mode), and thereby get better code when OP1 is a constant.  Do that for\n+     GCC 2.7.  It will require going over all usages of SIZE below.  */\n+  size = GET_MODE_BITSIZE (mode);\n+#endif\n \n-  /* Now convert to the best mode to use.  Normally show we made a copy of OP0\n-     and hence we can clobber it (we cannot use a SUBREG to widen\n-     something), but check that the conversion wasn't a no-op due to\n-     promotion.  */\n+  /* Now convert to the best mode to use.  */\n   if (compute_mode != mode)\n     {\n-      adjusted_op0 = convert_modes (compute_mode, mode, op0, unsignedp);\n-      can_clobber_op0 = ! (GET_CODE (op0) == SUBREG \n-\t\t\t   && SUBREG_REG (op0) == adjusted_op0);\n-      op0 = adjusted_op0;\n+      op0 = convert_modes (compute_mode, mode, op0, unsignedp);\n       op1 = convert_modes (compute_mode, mode, op1, unsignedp);\n     }\n \n-  /* If we are computing the remainder and one of the operands is a volatile\n-     MEM, copy it into a register.  */\n+  /* If one of the operands is a volatile MEM, copy it into a register.  */\n \n-  if (rem_flag && GET_CODE (op0) == MEM && MEM_VOLATILE_P (op0))\n-    adjusted_op0 = op0 = force_reg (compute_mode, op0), can_clobber_op0 = 1;\n-  if (rem_flag && GET_CODE (op1) == MEM && MEM_VOLATILE_P (op1))\n+  if (GET_CODE (op0) == MEM && MEM_VOLATILE_P (op0))\n+    op0 = force_reg (compute_mode, op0);\n+  if (GET_CODE (op1) == MEM && MEM_VOLATILE_P (op1))\n     op1 = force_reg (compute_mode, op1);\n \n-  /* If we are computing the remainder, op0 will be needed later to calculate\n-     X - Y * (X / Y), therefore cannot be clobbered. */\n-  if (rem_flag)\n-    can_clobber_op0 = 0;\n-\n-  /* See if we will need to modify ADJUSTED_OP0.  Note that this code\n-     must agree with that in the switch below.  */\n-  if (((code == TRUNC_MOD_EXPR || code == TRUNC_DIV_EXPR)\n-       && log >= 0 && ! unsignedp)\n-      || ((code == FLOOR_MOD_EXPR || code == FLOOR_DIV_EXPR)\n-\t  && log < 0 && ! unsignedp)\n-      || code == CEIL_MOD_EXPR || code == CEIL_DIV_EXPR\n-      || code == ROUND_MOD_EXPR || code == ROUND_DIV_EXPR)\n-    {\n-      /* If we want the remainder, we may need to use OP0, so make sure\n-\t it and ADJUSTED_OP0 are in different registers.  We force OP0\n-\t to a register in case it has any queued subexpressions, because\n-\t emit_cmp_insn will call emit_queue.\n-\n-\t If we don't want the remainder, we aren't going to use OP0 anymore.\n-\t However, if we cannot clobber OP0 (and hence ADJUSTED_OP0), we must\n-\t make a copy of it, hopefully to TARGET.\n-\n-\t This code is somewhat tricky.  Note that if REM_FLAG is nonzero,\n-\t CAN_CLOBBER_OP0 will be zero and we know that OP0 cannot\n-\t equal TARGET.  */\n-\n-      if (rem_flag)\n-\top0 = force_reg (compute_mode, op0);\n-\n-      if (! can_clobber_op0)\n-\t{\n-\t  if (target && GET_MODE (target) == compute_mode)\n-\t    adjusted_op0 = target;\n-\t  else\n-\t    adjusted_op0 = 0;\n-\t  adjusted_op0 = copy_to_suggested_reg (op0, adjusted_op0,\n-\t\t\t\t\t\tcompute_mode);\n-\t}\n-    }\n+#if 0\n+  op0 = force_reg (mode, op0);\n+#endif\n \n-  /* Adjust ADJUSTED_OP0 as described above.  Unless CAN_CLOBBER_OP0\n-     is now non-zero, OP0 will retain it's original value.  */\n+  last = get_last_insn ();\n \n-  switch (code)\n+  /* Promote floor rouding to trunc rounding for unsigned operations.  */\n+  if (unsignedp)\n     {\n-    case TRUNC_MOD_EXPR:\n-    case TRUNC_DIV_EXPR:\n-      if (log >= 0 && ! unsignedp)\n-\t{\n-\t  /* Here we need to add OP1-1 if OP0 is negative, 0 otherwise.\n-\t     This can be computed without jumps by arithmetically shifting\n-\t     OP0 right LOG-1 places and then shifting right logically\n-\t     SIZE-LOG bits.  The resulting value is unconditionally added\n-\t     to OP0.\n-\n-\t     If OP0 cannot be modified in place, copy it, possibly to\n-\t     TARGET.  Note that we will have previously only allowed\n-\t     it to be modified in place if it is a register, so that\n-\t     after this `if', ADJUSTED_OP0 is known to be a\n-\t     register.  */\n-\t  if (log == 1 || BRANCH_COST >= 3)\n-\t    {\n-\t      rtx temp;\n-\n-\t      temp = expand_shift (RSHIFT_EXPR, compute_mode, adjusted_op0,\n-\t\t\t\t   build_int_2 (log - 1, 0), NULL_RTX, 0);\n-\n-\t      /* We cannot allow TEMP to be ADJUSTED_OP0 here.  */\n-\t      temp = expand_shift (RSHIFT_EXPR, compute_mode, temp,\n-\t\t\t\t   build_int_2 (size - log, 0),\n-\t\t\t\t   temp != adjusted_op0 ? temp : NULL_RTX, 1);\n+      if (code == FLOOR_DIV_EXPR)\n+\tcode = TRUNC_DIV_EXPR;\n+      if (code == FLOOR_MOD_EXPR)\n+\tcode = TRUNC_MOD_EXPR;\n+    }\n \n-\t      adjusted_op0 = expand_binop (compute_mode, add_optab,\n-\t\t\t\t\t   adjusted_op0, temp, adjusted_op0,\n-\t\t\t\t\t   0, OPTAB_LIB_WIDEN);\n-\t    }\n-\t  else\n-\t    {\n-\t      rtx label = gen_label_rtx ();\n+  if (op1 != const0_rtx)\n+    switch (code)\n+      {\n+      case TRUNC_MOD_EXPR:\n+      case TRUNC_DIV_EXPR:\n+\tif (op1_is_constant && HOST_BITS_PER_WIDE_INT >= size)\n+\t  {\n+\t    if (unsignedp)\n+\t      {\n+\t\tunsigned HOST_WIDE_INT mh, ml;\n+\t\tint pre_shift, post_shift;\n+\t\tint dummy;\n+\t\tunsigned HOST_WIDE_INT d = INTVAL (op1);\n+\n+\t\tif (EXACT_POWER_OF_2_OR_ZERO_P (d))\n+\t\t  {\n+\t\t    pre_shift = floor_log2 (d);\n+\t\t    if (rem_flag)\n+\t\t      {\n+\t\t\tremainder = expand_binop (compute_mode, and_optab, op0,\n+\t\t\t\t\t\t  GEN_INT (((HOST_WIDE_INT) 1 << pre_shift) - 1),\n+\t\t\t\t\t\t  remainder, 1,\n+\t\t\t\t\t\t  OPTAB_LIB_WIDEN);\n+\t\t\tif (remainder)\n+\t\t\t  return remainder;\n+\t\t      }\n+\t\t    quotient = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n+\t\t\t\t\t     build_int_2 (pre_shift, 0),\n+\t\t\t\t\t     tquotient, 1);\n+\t\t  }\n+\t\telse if (d >= ((unsigned HOST_WIDE_INT) 1 << (size - 1)))\n+\t\t  {\n+\t\t    /* Most significant bit of divisor is set, emit a scc insn.\n+\t\t       emit_store_flag needs to be passed a place for the\n+\t\t       result.  */\n+\t\t    quotient = emit_store_flag (tquotient, GEU, op0, op1,\n+\t\t\t\t\t\tcompute_mode, 1, 1);\n+\t\t    /* Can emit_store_flag have failed? */\n+\t\t    if (quotient == 0)\n+\t\t      goto fail1;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    /* Find a suitable multiplier and right shift count instead\n+\t\t       of multiplying with D.  */\n+\n+\t\t    mh = choose_multiplier (d, size, size,\n+\t\t\t\t\t    &ml, &post_shift, &dummy);\n+\n+\t\t    /* If the suggested multiplier is more than SIZE bits, we\n+\t\t       can do better for even divisors, using an initial right\n+\t\t       shift.  */\n+\t\t    if (mh != 0 && (d & 1) == 0)\n+\t\t      {\n+\t\t\tpre_shift = floor_log2 (d & -d);\n+\t\t\tmh = choose_multiplier (d >> pre_shift, size,\n+\t\t\t\t\t\tsize - pre_shift,\n+\t\t\t\t\t\t&ml, &post_shift, &dummy);\n+\t\t\tif (mh)\n+\t\t\t  abort ();\n+\t\t      }\n+\t\t    else\n+\t\t      pre_shift = 0;\n+\n+\t\t    if (mh != 0)\n+\t\t      {\n+\t\t\trtx t1, t2, t3, t4;\n+\n+\t\t\tt1 = expand_mult_highpart (compute_mode, op0, ml,\n+\t\t\t\t\t\t   NULL_RTX, 1);\n+\t\t\tif (t1 == 0)\n+\t\t\t  goto fail1;\n+\t\t\tt2 = force_operand (gen_rtx (MINUS, compute_mode,\n+\t\t\t\t\t\t     op0, t1),\n+\t\t\t\t\t    NULL_RTX);\n+\t\t\tt3 = expand_shift (RSHIFT_EXPR, compute_mode, t2,\n+\t\t\t\t\t   build_int_2 (1, 0), NULL_RTX, 1);\n+\t\t\tt4 = force_operand (gen_rtx (PLUS, compute_mode,\n+\t\t\t\t\t\t     t1, t3),\n+\t\t\t\t\t    NULL_RTX);\n+\t\t\tquotient = expand_shift (RSHIFT_EXPR, compute_mode, t4,\n+\t\t\t\t\t\t build_int_2 (post_shift - 1,\n+\t\t\t\t\t\t\t      0),\n+\t\t\t\t\t\t tquotient, 1);\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\trtx t1, t2;\n+\n+\t\t\tt1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n+\t\t\t\t\t   build_int_2 (pre_shift, 0),\n+\t\t\t\t\t   NULL_RTX, 1);\n+\t\t\tt2 = expand_mult_highpart (compute_mode, t1, ml,\n+\t\t\t\t\t\t   NULL_RTX, 1);\n+\t\t\tif (t2 == 0)\n+\t\t\t  goto fail1;\n+\t\t\tquotient = expand_shift (RSHIFT_EXPR, compute_mode, t2,\n+\t\t\t\t\t\t build_int_2 (post_shift, 0),\n+\t\t\t\t\t\t tquotient, 1);\n+\t\t      }\n+\t\t  }\n+\n+\t\tinsn = get_last_insn ();\n+\t\tREG_NOTES (insn)\n+\t\t  = gen_rtx (EXPR_LIST, REG_EQUAL,\n+\t\t\t     gen_rtx (UDIV, compute_mode, op0, op1),\n+\t\t\t     REG_NOTES (insn));\n+\t      }\n+\t    else\t\t/* TRUNC_DIV, signed */\n+\t      {\n+\t\tunsigned HOST_WIDE_INT ml;\n+\t\tint lgup, post_shift;\n+\t\tHOST_WIDE_INT d = INTVAL (op1);\n+\t\tunsigned HOST_WIDE_INT abs_d = d >= 0 ? d : -d;\n+\n+\t\t/* n rem d = n rem -d */\n+\t\tif (rem_flag && d < 0)\n+\t\t  {\n+\t\t    d = abs_d;\n+\t\t    op1 = GEN_INT (abs_d);\n+\t\t  }\n+\n+\t\tif (d == 1)\n+\t\t  quotient = op0;\n+\t\telse if (d == -1)\n+\t\t  quotient = expand_unop (compute_mode, neg_optab, op0,\n+\t\t\t\t\t  tquotient, 0);\n+\t\telse if (EXACT_POWER_OF_2_OR_ZERO_P (d)\n+\t\t\t && (rem_flag ? smod_pow2_cheap : sdiv_pow2_cheap))\n+\t\t  ;\n+\t\telse if (EXACT_POWER_OF_2_OR_ZERO_P (abs_d))\n+\t\t  {\n+\t\t    lgup = floor_log2 (abs_d);\n+\t\t    if (abs_d != 2 && BRANCH_COST < 3)\n+\t\t      {\n+\t\t\trtx label = gen_label_rtx ();\n+\t\t\trtx t1;\n+\n+\t\t\tt1 = copy_to_mode_reg (compute_mode, op0);\n+\t\t\temit_cmp_insn (t1, const0_rtx, GE, \n+\t\t\t\t       NULL_RTX, compute_mode, 0, 0);\n+\t\t\temit_jump_insn (gen_bge (label));\n+\t\t\texpand_inc (t1, GEN_INT (abs_d - 1));\n+\t\t\temit_label (label);\n+\t\t\tquotient = expand_shift (RSHIFT_EXPR, compute_mode, t1,\n+\t\t\t\t\t\t build_int_2 (lgup, 0),\n+\t\t\t\t\t\t tquotient, 0);\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\trtx t1, t2, t3;\n+\t\t\tt1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n+\t\t\t\t\t   build_int_2 (size - 1, 0),\n+\t\t\t\t\t   NULL_RTX, 0);\n+\t\t\tt2 = expand_shift (RSHIFT_EXPR, compute_mode, t1,\n+\t\t\t\t\t   build_int_2 (size - lgup, 0),\n+\t\t\t\t\t   NULL_RTX, 1);\n+\t\t\tt3 = force_operand (gen_rtx (PLUS, compute_mode,\n+\t\t\t\t\t\t     op0, t2),\n+\t\t\t\t\t    NULL_RTX);\n+\t\t\tquotient = expand_shift (RSHIFT_EXPR, compute_mode, t3,\n+\t\t\t\t\t\t build_int_2 (lgup, 0),\n+\t\t\t\t\t\t tquotient, 0);\n+\t\t      }\n+\n+\t\t    if (d < 0)\n+\t\t      {\n+\t\t\tinsn = get_last_insn ();\n+\t\t\tREG_NOTES (insn)\n+\t\t\t  = gen_rtx (EXPR_LIST, REG_EQUAL,\n+\t\t\t\t     gen_rtx (DIV, compute_mode, op0,\n+\t\t\t\t\t      GEN_INT (abs_d)),\n+\t\t\t\t     REG_NOTES (insn));\n+\n+\t\t\tquotient = expand_unop (compute_mode, neg_optab,\n+\t\t\t\t\t\tquotient, quotient, 0);\n+\t\t      }\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    choose_multiplier (abs_d, size, size - 1,\n+\t\t\t\t       &ml, &post_shift, &lgup);\n+\t\t    if (ml < (unsigned HOST_WIDE_INT) 1 << (size - 1))\n+\t\t      {\n+\t\t\trtx t1, t2, t3;\n+\n+\t\t\tt1 = expand_mult_highpart (compute_mode, op0, ml,\n+\t\t\t\t\t\t   NULL_RTX, 0);\n+\t\t\tif (t1 == 0)\n+\t\t\t  goto fail1;\n+\t\t\tt2 = expand_shift (RSHIFT_EXPR, compute_mode, t1,\n+\t\t\t\t\t   build_int_2 (post_shift, 0), NULL_RTX, 0);\n+\t\t\tt3 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n+\t\t\t\t\t   build_int_2 (size - 1, 0), NULL_RTX, 0);\n+\t\t\tif (d < 0)\n+\t\t\t  quotient = force_operand (gen_rtx (MINUS, compute_mode, t3, t2),\n+\t\t\t\t\t\t    tquotient);\n+\t\t\telse\n+\t\t\t  quotient = force_operand (gen_rtx (MINUS, compute_mode, t2, t3),\n+\t\t\t\t\t\t    tquotient);\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\trtx t1, t2, t3, t4;\n+\n+\t\t\tml |= (~(unsigned HOST_WIDE_INT) 0) << (size - 1);\n+\t\t\tt1 = expand_mult_highpart (compute_mode, op0, ml,\n+\t\t\t\t\t\t   NULL_RTX, 0);\n+\t\t\tif (t1 == 0)\n+\t\t\t  goto fail1;\n+\t\t\tt2 = force_operand (gen_rtx (PLUS, compute_mode, t1, op0),\n+\t\t\t\t\t    NULL_RTX);\n+\t\t\tt3 = expand_shift (RSHIFT_EXPR, compute_mode, t2,\n+\t\t\t\t\t   build_int_2 (post_shift, 0), NULL_RTX, 0);\n+\t\t\tt4 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n+\t\t\t\t\t   build_int_2 (size - 1, 0), NULL_RTX, 0);\n+\t\t\tif (d < 0)\n+\t\t\t  quotient = force_operand (gen_rtx (MINUS, compute_mode, t4, t3),\n+\t\t\t\t\t\t    tquotient);\n+\t\t\telse\n+\t\t\t  quotient = force_operand (gen_rtx (MINUS, compute_mode, t3, t4),\n+\t\t\t\t\t\t    tquotient);\n+\t\t      }\n+\t\t  }\n+\n+\t\tinsn = get_last_insn ();\n+\t\tREG_NOTES (insn)\n+\t\t  = gen_rtx (EXPR_LIST, REG_EQUAL,\n+\t\t\t     gen_rtx (DIV, compute_mode, op0, op1),\n+\t\t\t     REG_NOTES (insn));\n+\t      }\n+\t    break;\n+\t  }\n+      fail1:\n+\tdelete_insns_since (last);\n+\tbreak;\n \n-\t      emit_cmp_insn (adjusted_op0, const0_rtx, GE, \n-\t\t\t     NULL_RTX, compute_mode, 0, 0);\n-\t      emit_jump_insn (gen_bge (label));\n-\t      expand_inc (adjusted_op0, plus_constant (op1, -1));\n-\t      emit_label (label);\n-\t    }\n-\t  mod_insn_no_good = 1;\n-\t}\n-      break;\n+      case FLOOR_DIV_EXPR:\n+      case FLOOR_MOD_EXPR:\n+      /* We will come here only for signed operations.  */\n+\tif (op1_is_constant && HOST_BITS_PER_WIDE_INT >= size)\n+\t  {\n+\t    unsigned HOST_WIDE_INT mh, ml;\n+\t    int pre_shift, lgup, post_shift;\n+\t    HOST_WIDE_INT d = INTVAL (op1);\n+\n+\t    if (d > 0)\n+\t      {\n+\t\t/* We could just as easily deal with negative constants here,\n+\t\t   but it does not seem worth the trouble for GCC 2.6.  */\n+\t\tif (EXACT_POWER_OF_2_OR_ZERO_P (d))\n+\t\t  {\n+\t\t    pre_shift = floor_log2 (d);\n+\t\t    if (rem_flag)\n+\t\t      {\n+\t\t\tremainder = expand_binop (compute_mode, and_optab, op0,\n+\t\t\t\t\t\t  GEN_INT (((HOST_WIDE_INT) 1 << pre_shift) - 1),\n+\t\t\t\t\t\t  remainder, 0, OPTAB_LIB_WIDEN);\n+\t\t\tif (remainder)\n+\t\t\t  return remainder;\n+\t\t      }\n+\t\t    quotient = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n+\t\t\t\t\t     build_int_2 (pre_shift, 0),\n+\t\t\t\t\t     tquotient, 0);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    rtx t1, t2, t3, t4;\n+\n+\t\t    mh = choose_multiplier (d, size, size - 1,\n+\t\t\t\t\t    &ml, &post_shift, &lgup);\n+\t\t    if (mh)\n+\t\t      abort ();\n+\n+\t\t    t1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n+\t\t\t\t       build_int_2 (size - 1, 0), NULL_RTX, 0);\n+\t\t    t2 = expand_binop (compute_mode, xor_optab, op0, t1,\n+\t\t\t\t       NULL_RTX, 0, OPTAB_WIDEN);\n+\t\t    t3 = expand_mult_highpart (compute_mode, t2, ml,\n+\t\t\t\t\t       NULL_RTX, 1);\n+\t\t    if (t3 != 0)\n+\t\t      {\n+\t\t\tt4 = expand_shift (RSHIFT_EXPR, compute_mode, t3,\n+\t\t\t\t\t   build_int_2 (post_shift, 0),\n+\t\t\t\t\t   NULL_RTX, 1);\n+\t\t\tquotient = expand_binop (compute_mode, xor_optab,\n+\t\t\t\t\t\t t4, t1, tquotient, 0,\n+\t\t\t\t\t\t OPTAB_WIDEN);\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\trtx nsign, t1, t2, t3, t4;\n+\t\tt1 = force_operand (gen_rtx (PLUS, compute_mode,\n+\t\t\t\t\t     op0, constm1_rtx), NULL_RTX);\n+\t\tt2 = expand_binop (compute_mode, ior_optab, op0, t1, NULL_RTX,\n+\t\t\t\t   0, OPTAB_WIDEN);\n+\t\tnsign = expand_shift (RSHIFT_EXPR, compute_mode, t2,\n+\t\t\t\t      build_int_2 (size - 1, 0), NULL_RTX, 0);\n+\t\tt3 = force_operand (gen_rtx (MINUS, compute_mode, t1, nsign),\n+\t\t\t\t    NULL_RTX);\n+\t\tt4 = expand_divmod (0, TRUNC_DIV_EXPR, compute_mode, t3, op1,\n+\t\t\t\t    NULL_RTX, 0);\n+\t\tif (t4)\n+\t\t  {\n+\t\t    rtx t5;\n+\t\t    t5 = expand_unop (compute_mode, one_cmpl_optab, nsign,\n+\t\t\t\t      NULL_RTX, 0);\n+\t\t    quotient = force_operand (gen_rtx (PLUS, compute_mode,\n+\t\t\t\t\t\t       t4, t5),\n+\t\t\t\t\t      tquotient);\n+\t\t  }\n+\t      }\n+\t  }\n+\n+\tif (quotient != 0)\n+\t  break;\n+\tdelete_insns_since (last);\n \n-    case FLOOR_DIV_EXPR:\n-    case FLOOR_MOD_EXPR:\n-      if (log < 0 && ! unsignedp)\n+\t/* Try using an instruction that produces both the quotient and\n+\t   remainder, using truncation.  We can easily compensate the quotient\n+\t   or remainder to get floor rounding, once we have the remainder.\n+\t   Notice that we compute also the final remainder value here,\n+\t   and return the result right away.  */\n+\tif (target == 0)\n+\t  target = gen_reg_rtx (compute_mode);\n+\tif (rem_flag)\n+\t  {\n+\t    remainder = target;\n+\t    quotient = gen_reg_rtx (compute_mode);\n+\t  }\n+\telse\n+\t  {\n+\t    quotient = target;\n+\t    remainder = gen_reg_rtx (compute_mode);\n+\t  }\n+\n+\tif (expand_twoval_binop (sdivmod_optab, op0, op1,\n+\t\t\t\t quotient, remainder, 0))\n+\t  {\n+\t    /* This could be computed with a branch-less sequence.\n+\t       Save that for later.  */\n+\t    rtx tem;\n+\t    rtx label = gen_label_rtx ();\n+\t    emit_cmp_insn (remainder, const0_rtx, EQ, NULL_RTX,\n+\t\t\t   compute_mode, 0, 0);\n+\t    emit_jump_insn (gen_beq (label));\n+\t    tem = expand_binop (compute_mode, xor_optab, op0, op1,\n+\t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n+\t    emit_cmp_insn (tem, const0_rtx, GE, NULL_RTX, compute_mode, 0, 0);\n+\t    emit_jump_insn (gen_bge (label));\n+\t    expand_dec (quotient, const1_rtx);\n+\t    expand_inc (remainder, op1);\n+\t    emit_label (label);\n+\t    if (rem_flag)\n+\t      return remainder;\n+\t    else\n+\t      return quotient;\n+\t  }\n+\n+\t/* No luck with division elimination or divmod.  Have to do it\n+\t   by conditionally adjusting op0 *and* the result.  */\n \t{\n-\t  rtx label = gen_label_rtx ();\n-\n-\t  emit_cmp_insn (adjusted_op0, const0_rtx, GE, \n-\t\t\t NULL_RTX, compute_mode, 0, 0);\n-\t  emit_jump_insn (gen_bge (label));\n-\t  expand_dec (adjusted_op0, op1);\n+\t  rtx label1, label2, label3, label4, label5;\n+\t  rtx adjusted_op0;\n+\t  rtx tem;\n+\n+\t  quotient = gen_reg_rtx (compute_mode);\n+\t  adjusted_op0 = copy_to_mode_reg (compute_mode, op0);\n+\t  label1 = gen_label_rtx ();\n+\t  label2 = gen_label_rtx ();\n+\t  label3 = gen_label_rtx ();\n+\t  label4 = gen_label_rtx ();\n+\t  label5 = gen_label_rtx ();\n+\t  emit_cmp_insn (op1, const0_rtx, LT, NULL_RTX, compute_mode, 0, 0);\n+\t  emit_jump_insn (gen_blt (label2));\n+\t  emit_cmp_insn (adjusted_op0, const0_rtx, LT, NULL_RTX,\n+\t\t\t compute_mode, 0, 0);\n+\t  emit_jump_insn (gen_blt (label1));\n+\t  tem = expand_binop (compute_mode, sdiv_optab, adjusted_op0, op1,\n+\t\t\t      quotient, 0, OPTAB_LIB_WIDEN);\n+\t  if (tem != quotient)\n+\t    emit_move_insn (quotient, tem);\n+\t  emit_jump_insn (gen_jump (label5));\n+\t  emit_barrier ();\n+\t  emit_label (label1);\n \t  expand_inc (adjusted_op0, const1_rtx);\n-\t  emit_label (label);\n-\t  mod_insn_no_good = 1;\n+\t  emit_jump_insn (gen_jump (label4));\n+\t  emit_barrier ();\n+\t  emit_label (label2);\n+\t  emit_cmp_insn (adjusted_op0, const0_rtx, GT, NULL_RTX,\n+\t\t\t compute_mode, 0, 0);\n+\t  emit_jump_insn (gen_bgt (label3));\n+\t  tem = expand_binop (compute_mode, sdiv_optab, adjusted_op0, op1,\n+\t\t\t      quotient, 0, OPTAB_LIB_WIDEN);\n+\t  if (tem != quotient)\n+\t    emit_move_insn (quotient, tem);\n+\t  emit_jump_insn (gen_jump (label5));\n+\t  emit_barrier ();\n+\t  emit_label (label3);\n+\t  expand_dec (adjusted_op0, const1_rtx);\n+\t  emit_label (label4);\n+\t  tem = expand_binop (compute_mode, sdiv_optab, adjusted_op0, op1,\n+\t\t\t      quotient, 0, OPTAB_LIB_WIDEN);\n+\t  if (tem != quotient)\n+\t    emit_move_insn (quotient, tem);\n+\t  expand_dec (quotient, const1_rtx);\n+\t  emit_label (label5);\n \t}\n-      break;\n+\tbreak;\n \n-    case CEIL_DIV_EXPR:\n-    case CEIL_MOD_EXPR:\n-      if (log < 0)\n-\t{\n-\t  rtx label = 0;\n-\t  if (! unsignedp)\n+      case CEIL_DIV_EXPR:\n+      case CEIL_MOD_EXPR:\n+\tif (unsignedp)\n+\t  {\n+\n+\t    /* Try using an instruction that produces both the quotient and\n+\t       remainder, using truncation.  We can easily compensate the\n+\t       quotient or remainder to get ceiling rounding, once we have the\n+\t       remainder.  Notice that we compute also the final remainder\n+\t       value here, and return the result right away.  */\n+\t    if (target == 0)\n+\t      target = gen_reg_rtx (compute_mode);\n+\t    if (rem_flag)\n+\t      {\n+\t\tremainder = target;\n+\t\tquotient = gen_reg_rtx (compute_mode);\n+\t      }\n+\t    else\n+\t      {\n+\t\tquotient = target;\n+\t\tremainder = gen_reg_rtx (compute_mode);\n+\t      }\n+\n+\t    if (expand_twoval_binop (udivmod_optab, op0, op1, quotient,\n+\t\t\t\t     remainder, 1))\n+\t      {\n+\t\t/* This could be computed with a branch-less sequence.\n+\t\t   Save that for later.  */\n+\t\trtx label = gen_label_rtx ();\n+\t\temit_cmp_insn (remainder, const0_rtx, EQ, NULL_RTX,\n+\t\t\t       compute_mode, 0, 0);\n+\t\temit_jump_insn (gen_beq (label));\n+\t\texpand_inc (quotient, const1_rtx);\n+\t\texpand_dec (remainder, op1);\n+\t\temit_label (label);\n+\t\treturn rem_flag ? remainder : quotient;\n+\t      }\n+\n+\t    /* No luck with division elimination or divmod.  Have to do it\n+\t       by conditionally adjusting op0 *and* the result.  */\n \t    {\n-\t      label = gen_label_rtx ();\n-\t      emit_cmp_insn (adjusted_op0, const0_rtx, LE, \n-\t\t\t     NULL_RTX, compute_mode, 0, 0);\n-\t      emit_jump_insn (gen_ble (label));\n+\t      rtx label1, label2;\n+\t      rtx adjusted_op0, tem;\n+\n+\t      quotient = gen_reg_rtx (compute_mode);\n+\t      adjusted_op0 = copy_to_mode_reg (compute_mode, op0);\n+\t      label1 = gen_label_rtx ();\n+\t      label2 = gen_label_rtx ();\n+\t      emit_cmp_insn (adjusted_op0, const0_rtx, NE, NULL_RTX,\n+\t\t\t     compute_mode, 0, 0);\n+\t      emit_jump_insn (gen_bne (label1));\n+\t      emit_move_insn  (quotient, const0_rtx);\n+\t      emit_jump_insn (gen_jump (label2));\n+\t      emit_barrier ();\n+\t      emit_label (label1);\n+\t      expand_dec (adjusted_op0, const1_rtx);\n+\t      tem = expand_binop (compute_mode, udiv_optab, adjusted_op0, op1,\n+\t\t\t\t  quotient, 1, OPTAB_LIB_WIDEN);\n+\t      if (tem != quotient)\n+\t\temit_move_insn (quotient, tem);\n+\t      expand_inc (quotient, const1_rtx);\n+\t      emit_label (label2);\n \t    }\n-\t  expand_inc (adjusted_op0, op1);\n-\t  expand_dec (adjusted_op0, const1_rtx);\n-\t  if (! unsignedp)\n-\t    emit_label (label);\n-\t}\n-      else\n-\tadjusted_op0 = expand_binop (compute_mode, add_optab,\n-\t\t\t\t     adjusted_op0, plus_constant (op1, -1),\n-\t\t\t\t     adjusted_op0, 0, OPTAB_LIB_WIDEN);\n-\n-      mod_insn_no_good = 1;\n-      break;\n-\n-    case ROUND_DIV_EXPR:\n-    case ROUND_MOD_EXPR:\n-      if (log < 0)\n-\t{\n-\t  op1 = expand_shift (RSHIFT_EXPR, compute_mode, op1,\n-\t\t\t      integer_one_node, NULL_RTX, 0);\n-\t  if (! unsignedp)\n+\t  }\n+\telse /* signed */\n+\t  {\n+\t    /* Try using an instruction that produces both the quotient and\n+\t       remainder, using truncation.  We can easily compensate the\n+\t       quotient or remainder to get ceiling rounding, once we have the\n+\t       remainder.  Notice that we compute also the final remainder\n+\t       value here, and return the result right away.  */\n+\t    if (target == 0)\n+\t      target = gen_reg_rtx (compute_mode);\n+\t    if (rem_flag)\n+\t      {\n+\t\tremainder = target;\n+\t\tquotient = gen_reg_rtx (compute_mode);\n+\t      }\n+\t    else\n+\t      {\n+\t\tquotient = target;\n+\t\tremainder = gen_reg_rtx (compute_mode);\n+\t      }\n+\n+\t    if (expand_twoval_binop (sdivmod_optab, op0, op1, quotient,\n+\t\t\t\t     remainder, 0))\n+\t      {\n+\t\t/* This could be computed with a branch-less sequence.\n+\t\t   Save that for later.  */\n+\t\trtx tem;\n+\t\trtx label = gen_label_rtx ();\n+\t\temit_cmp_insn (remainder, const0_rtx, EQ, NULL_RTX,\n+\t\t\t       compute_mode, 0, 0);\n+\t\temit_jump_insn (gen_beq (label));\n+\t\ttem = expand_binop (compute_mode, xor_optab, op0, op1,\n+\t\t\t\t    NULL_RTX, 0, OPTAB_WIDEN);\n+\t\temit_cmp_insn (tem, const0_rtx, LT, NULL_RTX,\n+\t\t\t       compute_mode, 0, 0);\n+\t\temit_jump_insn (gen_blt (label));\n+\t\texpand_inc (quotient, const1_rtx);\n+\t\texpand_dec (remainder, op1);\n+\t\temit_label (label);\n+\t\treturn rem_flag ? remainder : quotient;\n+\t      }\n+\n+\t    /* No luck with division elimination or divmod.  Have to do it\n+\t       by conditionally adjusting op0 *and* the result.  */\n \t    {\n-\t      if (BRANCH_COST >= 2)\n-\t\t{\n-\t\t  /* Negate OP1 if OP0 < 0.  Do this by computing a temporary\n-\t\t     that has all bits equal to the sign bit and exclusive\n-\t\t     or-ing it with OP1.  */\n-\t\t  rtx temp = expand_shift (RSHIFT_EXPR, compute_mode,\n-\t\t\t\t\t   adjusted_op0,\n-\t\t\t\t\t   build_int_2 (size - 1, 0),\n-\t\t\t\t\t   NULL_RTX, 0);\n-\t\t  op1 = expand_binop (compute_mode, xor_optab, op1, temp, op1,\n-\t\t\t\t      unsignedp, OPTAB_LIB_WIDEN);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  rtx label = gen_label_rtx ();\n-\t\t  emit_cmp_insn (adjusted_op0, const0_rtx, GE, NULL_RTX,\n-\t\t\t\t compute_mode, 0, 0);\n-\t\t  emit_jump_insn (gen_bge (label));\n-\t\t  expand_unop (compute_mode, neg_optab, op1, op1, 0);\n-\t\t  emit_label (label);\n-\t\t}\n+\t      rtx label1, label2, label3, label4, label5;\n+\t      rtx adjusted_op0;\n+\t      rtx tem;\n+\n+\t      quotient = gen_reg_rtx (compute_mode);\n+\t      adjusted_op0 = copy_to_mode_reg (compute_mode, op0);\n+\t      label1 = gen_label_rtx ();\n+\t      label2 = gen_label_rtx ();\n+\t      label3 = gen_label_rtx ();\n+\t      label4 = gen_label_rtx ();\n+\t      label5 = gen_label_rtx ();\n+\t      emit_cmp_insn (op1, const0_rtx, LT, NULL_RTX,\n+\t\t\t     compute_mode, 0, 0);\n+\t      emit_jump_insn (gen_blt (label2));\n+\t      emit_cmp_insn (adjusted_op0, const0_rtx, GT, NULL_RTX,\n+\t\t\t     compute_mode, 0, 0);\n+\t      emit_jump_insn (gen_bgt (label1));\n+\t      tem = expand_binop (compute_mode, sdiv_optab, adjusted_op0, op1,\n+\t\t\t\t  quotient, 0, OPTAB_LIB_WIDEN);\n+\t      if (tem != quotient)\n+\t\temit_move_insn (quotient, tem);\n+\t      emit_jump_insn (gen_jump (label5));\n+\t      emit_barrier ();\n+\t      emit_label (label1);\n+\t      expand_dec (adjusted_op0, const1_rtx);\n+\t      emit_jump_insn (gen_jump (label4));\n+\t      emit_barrier ();\n+\t      emit_label (label2);\n+\t      emit_cmp_insn (adjusted_op0, const0_rtx, LT, NULL_RTX,\n+\t\t\t     compute_mode, 0, 0);\n+\t      emit_jump_insn (gen_blt (label3));\n+\t      tem = expand_binop (compute_mode, sdiv_optab, adjusted_op0, op1,\n+\t\t\t\t  quotient, 0, OPTAB_LIB_WIDEN);\n+\t      if (tem != quotient)\n+\t\temit_move_insn (quotient, tem);\n+\t      emit_jump_insn (gen_jump (label5));\n+\t      emit_barrier ();\n+\t      emit_label (label3);\n+\t      expand_inc (adjusted_op0, const1_rtx);\n+\t      emit_label (label4);\n+\t      tem = expand_binop (compute_mode, sdiv_optab, adjusted_op0, op1,\n+\t\t\t\t  quotient, 0, OPTAB_LIB_WIDEN);\n+\t      if (tem != quotient)\n+\t\temit_move_insn (quotient, tem);\n+\t      expand_inc (quotient, const1_rtx);\n+\t      emit_label (label5);\n \t    }\n-\t  expand_inc (adjusted_op0, op1);\n-\t}\n-      else\n-\texpand_inc (adjusted_op0, GEN_INT (((HOST_WIDE_INT) 1 << log) / 2));\n+\t  }\n+\tbreak;\n \n-      mod_insn_no_good = 1;\n-      break;\n-    }\n+      case EXACT_DIV_EXPR:\n+\tif (op1_is_constant && HOST_BITS_PER_WIDE_INT >= size)\n+\t  {\n+\t    HOST_WIDE_INT d = INTVAL (op1);\n+\t    unsigned HOST_WIDE_INT ml;\n+\t    int post_shift;\n+\t    rtx t1;\n+\n+\t    post_shift = floor_log2 (d & -d);\n+\t    ml = invert_mod2n (d >> post_shift, size);\n+\t    t1 = expand_mult (compute_mode, op0, GEN_INT (ml), NULL_RTX,\n+\t\t\t      unsignedp);\n+\t    quotient = expand_shift (RSHIFT_EXPR, compute_mode, t1,\n+\t\t\t\t     build_int_2 (post_shift, 0),\n+\t\t\t\t     NULL_RTX, unsignedp);\n+\n+\t    insn = get_last_insn ();\n+\t    REG_NOTES (insn)\n+\t      = gen_rtx (EXPR_LIST, REG_EQUAL,\n+\t\t\t gen_rtx (unsignedp ? UDIV : DIV, compute_mode,\n+\t\t\t\t  op0, op1),\n+\t\t\t REG_NOTES (insn));\n+\t  }\n+\tbreak;\n+\n+      case ROUND_DIV_EXPR:\n+      case ROUND_MOD_EXPR:\n+\t/* The code that used to be here was wrong, and nothing really\n+\t   depends on it.  */\n+\tabort ();\n+\tbreak;\n+      }\n \n-  if (rem_flag && !mod_insn_no_good)\n+  if (quotient == 0)\n     {\n-      /* Try to produce the remainder directly */\n-      if (log >= 0)\n-\tresult = expand_binop (compute_mode, and_optab, adjusted_op0,\n-\t\t\t       GEN_INT (((HOST_WIDE_INT) 1 << log) - 1),\n-\t\t\t       target, 1, OPTAB_LIB_WIDEN);\n-      else\n+      if (rem_flag)\n \t{\n-\t  /* See if we can do remainder without a library call.  */\n-\t  result = sign_expand_binop (mode, umod_optab, smod_optab,\n-\t\t\t\t      adjusted_op0, op1, target,\n-\t\t\t\t      unsignedp, OPTAB_WIDEN);\n-\t  if (result == 0)\n+\t  /* Try to produce the remainder directly without a library call.  */\n+\t  remainder = sign_expand_binop (compute_mode, umod_optab, smod_optab,\n+\t\t\t\t\t op0, op1, target,\n+\t\t\t\t\t unsignedp, OPTAB_WIDEN);\n+\t  if (remainder == 0)\n \t    {\n \t      /* No luck there.  Can we do remainder and divide at once\n \t\t without a library call?  */\n-\t      result = gen_reg_rtx (compute_mode);\n-\t      if (! expand_twoval_binop (unsignedp\n-\t\t\t\t\t ? udivmod_optab : sdivmod_optab,\n-\t\t\t\t\t adjusted_op0, op1,\n-\t\t\t\t\t NULL_RTX, result, unsignedp))\n-\t\tresult = 0;\n+\t      remainder = gen_reg_rtx (compute_mode);\n+\t      if (! expand_twoval_binop ((unsignedp\n+\t\t\t\t\t  ? udivmod_optab\n+\t\t\t\t\t  : sdivmod_optab),\n+\t\t\t\t\t op0, op1,\n+\t\t\t\t\t NULL_RTX, remainder, unsignedp))\n+\t\tremainder = 0;\n \t    }\n+\n+\t  if (remainder)\n+\t    return gen_lowpart (mode, remainder);\n \t}\n-    }\n \n-  if (result)\n-    return gen_lowpart (mode, result);\n-\n-  /* Produce the quotient.  */\n-  if (log >= 0)\n-    result = expand_shift (RSHIFT_EXPR, compute_mode, adjusted_op0,\n-\t\t\t   build_int_2 (log, 0), target, unsignedp);\n-  else if (rem_flag && !mod_insn_no_good)\n-    /* If producing quotient in order to subtract for remainder,\n-       and a remainder subroutine would be ok,\n-       don't use a divide subroutine.  */\n-    result = sign_expand_binop (compute_mode, udiv_optab, sdiv_optab,\n-\t\t\t\tadjusted_op0, op1, NULL_RTX, unsignedp,\n-\t\t\t\tOPTAB_WIDEN);\n-  else\n-    {\n+      /* Produce the quotient.  */\n       /* Try a quotient insn, but not a library call.  */\n-      result = sign_expand_binop (compute_mode, udiv_optab, sdiv_optab,\n-\t\t\t\t  adjusted_op0, op1,\n-\t\t\t\t  rem_flag ? NULL_RTX : target,\n-\t\t\t\t  unsignedp, OPTAB_WIDEN);\n-      if (result == 0)\n+      quotient = sign_expand_binop (compute_mode, udiv_optab, sdiv_optab,\n+\t\t\t\t    op0, op1, rem_flag ? NULL_RTX : target,\n+\t\t\t\t    unsignedp, OPTAB_WIDEN);\n+      if (quotient == 0)\n \t{\n \t  /* No luck there.  Try a quotient-and-remainder insn,\n \t     keeping the quotient alone.  */\n-\t  result = gen_reg_rtx (compute_mode);\n+\t  quotient = gen_reg_rtx (compute_mode);\n \t  if (! expand_twoval_binop (unsignedp ? udivmod_optab : sdivmod_optab,\n-\t\t\t\t     adjusted_op0, op1,\n-\t\t\t\t     result, NULL_RTX, unsignedp))\n-\t    result = 0;\n+\t\t\t\t     op0, op1,\n+\t\t\t\t     quotient, NULL_RTX, unsignedp))\n+\t    {\n+\t      quotient = 0;\n+\t      if (! rem_flag)\n+\t\t/* Still no luck.  If we are not computing the remainder,\n+\t\t   use a library call for the quotient.  */\n+\t\tquotient = sign_expand_binop (compute_mode,\n+\t\t\t\t\t      udiv_optab, sdiv_optab,\n+\t\t\t\t\t      op0, op1, target,\n+\t\t\t\t\t      unsignedp, OPTAB_LIB_WIDEN);\n+\t    }\n \t}\n-\n-      /* If still no luck, use a library call.  */\n-      if (result == 0)\n-\tresult = sign_expand_binop (compute_mode, udiv_optab, sdiv_optab,\n-\t\t\t\t    adjusted_op0, op1,\n-\t\t\t\t    rem_flag ? NULL_RTX : target,\n-\t\t\t\t    unsignedp, OPTAB_LIB_WIDEN);\n     }\n \n-  /* If we really want the remainder, get it by subtraction.  */\n   if (rem_flag)\n     {\n-      if (result == 0)\n+      if (quotient == 0)\n \t/* No divide instruction either.  Use library for remainder.  */\n-\tresult = sign_expand_binop (compute_mode, umod_optab, smod_optab,\n-\t\t\t\t    op0, op1, target,\n-\t\t\t\t    unsignedp, OPTAB_LIB_WIDEN);\n+\tremainder = sign_expand_binop (compute_mode, umod_optab, smod_optab,\n+\t\t\t\t       op0, op1, target,\n+\t\t\t\t       unsignedp, OPTAB_LIB_WIDEN);\n       else\n \t{\n \t  /* We divided.  Now finish doing X - Y * (X / Y).  */\n-\t  result = expand_mult (compute_mode, result, op1, target, unsignedp);\n-\t  if (! result) abort ();\n-\t  result = expand_binop (compute_mode, sub_optab, op0,\n-\t\t\t\t result, target, unsignedp, OPTAB_LIB_WIDEN);\n+\t  remainder = expand_mult (compute_mode, quotient, op1,\n+\t\t\t\t   NULL_RTX, unsignedp);\n+\t  remainder = expand_binop (compute_mode, sub_optab, op0,\n+\t\t\t\t    remainder, target, unsignedp,\n+\t\t\t\t    OPTAB_LIB_WIDEN);\n \t}\n     }\n \n-  if (result == 0)\n-    abort ();\n-\n-  return gen_lowpart (mode, result);\n+  return gen_lowpart (mode, rem_flag ? remainder : quotient);\n }\n \f\n /* Return a tree node with data type TYPE, describing the value of X."}]}