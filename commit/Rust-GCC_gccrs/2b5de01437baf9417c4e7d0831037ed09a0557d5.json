{"sha": "2b5de01437baf9417c4e7d0831037ed09a0557d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI1ZGUwMTQzN2JhZjk0MTdjNGU3ZDA4MzEwMzdlZDA5YTA1NTdkNQ==", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2017-10-26T09:57:09Z"}, "committer": {"name": "Tamar Christina", "email": "tnfchris@gcc.gnu.org", "date": "2017-10-26T09:57:09Z"}, "message": "2017-10-26  Tamar Christina  <tamar.christina@arm.com>\n\n\t* lib/target-supports.exp\n\t(check_effective_target_arm_v8_2a_dotprod_neon_ok_nocache): New.\n\t(check_effective_target_arm_v8_2a_dotprod_neon_ok): New.\n\t(add_options_for_arm_v8_2a_dotprod_neon): New.\n\t(check_effective_target_arm_v8_2a_dotprod_neon_hw): New.\n\t(check_effective_target_vect_sdot_qi): Add ARM && AArch64.\n\t(check_effective_target_vect_udot_qi): Likewise.\n\t* gcc.target/arm/simd/vdot-exec.c: New.\n\t* gcc.target/aarch64/advsimd-intrinsics/vdot-exec.c: New.\n\t* gcc/doc/sourcebuild.texi: Document arm_v8_2a_dotprod_neon.\n\nFrom-SVN: r254100", "tree": {"sha": "792738ae44c685ea8fc01efa008dc3daa0c2b2d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/792738ae44c685ea8fc01efa008dc3daa0c2b2d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b5de01437baf9417c4e7d0831037ed09a0557d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b5de01437baf9417c4e7d0831037ed09a0557d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b5de01437baf9417c4e7d0831037ed09a0557d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b5de01437baf9417c4e7d0831037ed09a0557d5/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c5a92111082b32711635a61a602f1495effe65ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5a92111082b32711635a61a602f1495effe65ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5a92111082b32711635a61a602f1495effe65ff"}], "stats": {"total": 194, "additions": 193, "deletions": 1}, "files": [{"sha": "c00aecefbfc29767d814b5d2c41d7a7246235957", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5de01437baf9417c4e7d0831037ed09a0557d5/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5de01437baf9417c4e7d0831037ed09a0557d5/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=2b5de01437baf9417c4e7d0831037ed09a0557d5", "patch": "@@ -1702,6 +1702,17 @@ ARM target supports executing instructions from ARMv8.2 with the FP16\n extension.  Some multilibs may be incompatible with these options.\n Implies arm_v8_2a_fp16_neon_ok and arm_v8_2a_fp16_scalar_hw.\n \n+@item arm_v8_2a_dotprod_neon_ok\n+@anchor{arm_v8_2a_dotprod_neon_ok}\n+ARM target supports options to generate instructions from ARMv8.2 with\n+the Dot Product extension. Some multilibs may be incompatible with these\n+options.\n+\n+@item arm_v8_2a_dotprod_neon_hw\n+ARM target supports executing instructions from ARMv8.2 with the Dot\n+Product extension. Some multilibs may be incompatible with these options.\n+Implies arm_v8_2a_dotprod_neon_ok.\n+\n @item arm_prefer_ldrd_strd\n ARM target prefers @code{LDRD} and @code{STRD} instructions over\n @code{LDM} and @code{STM} instructions.\n@@ -2308,6 +2319,11 @@ supported by the target; see the\n @ref{arm_v8_2a_fp16_neon_ok,,arm_v8_2a_fp16_neon_ok} effective target\n keyword.\n \n+@item arm_v8_2a_dotprod_neon\n+Add options for ARMv8.2 with Adv.SIMD Dot Product support, if this is\n+supported by the target; see the\n+@ref{arm_v8_2a_dotprod_neon_ok} effective target keyword.\n+\n @item bind_pic_locally\n Add the target-specific flags needed to enable functions to bind\n locally when using pic/PIC passes in the testsuite."}, {"sha": "6d42152d6da1317925853c617cc9704102fd9799", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5de01437baf9417c4e7d0831037ed09a0557d5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5de01437baf9417c4e7d0831037ed09a0557d5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2b5de01437baf9417c4e7d0831037ed09a0557d5", "patch": "@@ -1,3 +1,16 @@\n+2017-10-26  Tamar Christina  <tamar.christina@arm.com>\n+\n+\t* lib/target-supports.exp\n+\t(check_effective_target_arm_v8_2a_dotprod_neon_ok_nocache): New.\n+\t(check_effective_target_arm_v8_2a_dotprod_neon_ok): New.\n+\t(add_options_for_arm_v8_2a_dotprod_neon): New.\n+\t(check_effective_target_arm_v8_2a_dotprod_neon_hw): New.\n+\t(check_effective_target_vect_sdot_qi): Add ARM && AArch64.\n+\t(check_effective_target_vect_udot_qi): Likewise.\n+\t* gcc.target/arm/simd/vdot-exec.c: New.\n+\t* gcc.target/aarch64/advsimd-intrinsics/vdot-exec.c: New.\n+\t* gcc/doc/sourcebuild.texi: Document arm_v8_2a_dotprod_neon.\n+\n 2017-10-26  Tamar Christina  <tamar.christina@arm.com>\n \n \t* gcc.dg/vect/vect-multitypes-1.c: Correct target selector."}, {"sha": "3e7cd6c2fc22a5e5cdb355e269116636b890a9d3", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-exec.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5de01437baf9417c4e7d0831037ed09a0557d5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvdot-exec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5de01437baf9417c4e7d0831037ed09a0557d5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvdot-exec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2Fvdot-exec.c?ref=2b5de01437baf9417c4e7d0831037ed09a0557d5", "patch": "@@ -0,0 +1,81 @@\n+/* { dg-skip-if \"can't compile on arm.\" { arm*-*-* } } */\n+/* { dg-do run { target { aarch64*-*-* } } } */\n+/* { dg-additional-options \"-O3 -march=armv8.2-a+dotprod\" } */\n+/* { dg-require-effective-target arm_v8_2a_dotprod_neon_hw } */\n+\n+#include <arm_neon.h>\n+\n+extern void abort();\n+\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+# define ORDER(x, y) y\n+#else\n+# define ORDER(x, y) x - y\n+#endif\n+\n+#define P(n1,n2) n1,n1,n1,n1,n2,n2,n2,n2\n+#define ARR(nm, p, ty, ...) ty nm##_##p = { __VA_ARGS__ }\n+#define TEST(t1, t2, t3, f, r1, r2, n1, n2) \\\n+\tARR(f, x, t1, r1);\t\t    \\\n+\tARR(f, y, t2, r2);\t\t    \\\n+\tt3 f##_##r = {0};\t\t    \\\n+\tf##_##r = f (f##_##r, f##_##x, f##_##y);  \\\n+\tif (f##_##r[0] != n1 || f##_##r[1] != n2)   \\\n+\t  abort ();\n+\n+#define TEST_LANE(t1, t2, t3, f, r1, r2, n1, n2, n3, n4) \\\n+\tARR(f, x, t1, r1);\t\t    \\\n+\tARR(f, y, t2, r2);\t\t    \\\n+\tt3 f##_##rx = {0};\t\t    \\\n+\tf##_##rx = f (f##_##rx, f##_##x, f##_##y, ORDER (1, 0));  \\\n+\tif (f##_##rx[0] != n1 || f##_##rx[1] != n2)   \\\n+\t  abort ();\t\t\t\t    \\\n+\tt3 f##_##rx1 = {0};\t\t\t    \\\n+\tf##_##rx1 = f (f##_##rx1, f##_##x, f##_##y, ORDER (1, 1));  \\\n+\tif (f##_##rx1[0] != n3 || f##_##rx1[1] != n4)   \\\n+\t  abort ();\n+\n+#define Px(n1,n2,n3,n4) P(n1,n2),P(n3,n4)\n+#define TEST_LANEQ(t1, t2, t3, f, r1, r2, n1, n2, n3, n4, n5, n6, n7, n8) \\\n+\tARR(f, x, t1, r1);\t\t    \\\n+\tARR(f, y, t2, r2);\t\t    \\\n+\tt3 f##_##rx = {0};\t\t    \\\n+\tf##_##rx = f (f##_##rx, f##_##x, f##_##y, ORDER (3, 0));  \\\n+\tif (f##_##rx[0] != n1 || f##_##rx[1] != n2)   \\\n+\t  abort ();\t\t\t\t    \\\n+\tt3 f##_##rx1 = {0};\t\t\t    \\\n+\tf##_##rx1 = f (f##_##rx1, f##_##x, f##_##y, ORDER (3, 1));  \\\n+\tif (f##_##rx1[0] != n3 || f##_##rx1[1] != n4)   \\\n+\t  abort (); \\\n+\tt3 f##_##rx2 = {0};\t\t\t\t    \\\n+\tf##_##rx2 = f (f##_##rx2, f##_##x, f##_##y, ORDER (3, 2));  \\\n+\tif (f##_##rx2[0] != n5 || f##_##rx2[1] != n6)   \\\n+\t  abort ();\t\t\t\t    \\\n+\tt3 f##_##rx3 = {0};\t\t\t    \\\n+\tf##_##rx3 = f (f##_##rx3, f##_##x, f##_##y, ORDER (3, 3));  \\\n+\tif (f##_##rx3[0] != n7 || f##_##rx3[1] != n8)   \\\n+\t  abort ();\n+\n+int\n+main()\n+{\n+  TEST (uint8x8_t, uint8x8_t, uint32x2_t, vdot_u32, P(1,2), P(2,3), 8, 24);\n+  TEST (int8x8_t, int8x8_t, int32x2_t, vdot_s32, P(1,2), P(-2,-3), -8, -24);\n+\n+  TEST (uint8x16_t, uint8x16_t, uint32x4_t, vdotq_u32, P(1,2), P(2,3), 8, 24);\n+  TEST (int8x16_t, int8x16_t, int32x4_t, vdotq_s32, P(1,2), P(-2,-3), -8, -24);\n+\n+  TEST_LANE (uint8x8_t, uint8x8_t, uint32x2_t, vdot_lane_u32, P(1,2), P(2,3), 8, 16, 12, 24);\n+  TEST_LANE (int8x8_t, int8x8_t, int32x2_t, vdot_lane_s32, P(1,2), P(-2,-3), -8, -16, -12, -24);\n+\n+  TEST_LANE (uint8x16_t, uint8x8_t, uint32x4_t, vdotq_lane_u32, P(1,2), P(2,3), 8, 16, 12, 24);\n+  TEST_LANE (int8x16_t, int8x8_t, int32x4_t, vdotq_lane_s32, P(1,2), P(-2,-3), -8, -16, -12, -24);\n+\n+  TEST_LANEQ (uint8x8_t, uint8x16_t, uint32x2_t, vdot_laneq_u32, P(1,2), Px(2,3,1,4), 8, 16, 12, 24, 4, 8, 16, 32);\n+  TEST_LANEQ (int8x8_t, int8x16_t, int32x2_t, vdot_laneq_s32, P(1,2), Px(-2,-3,-1,-4), -8, -16, -12, -24, -4, -8, -16, -32);\n+\n+  TEST_LANEQ (uint8x16_t, uint8x16_t, uint32x4_t, vdotq_laneq_u32, Px(1,2,2,1), Px(2,3,1,4), 8, 16, 12, 24, 4, 8, 16, 32);\n+  TEST_LANEQ (int8x16_t, int8x16_t, int32x4_t, vdotq_laneq_s32, Px(1,2,2,1), Px(-2,-3,-1,-4), -8, -16, -12, -24, -4, -8, -16, -32);\n+\n+  return 0;\n+}"}, {"sha": "d7ef04f52213ad525f0b209c989e665e3bc1fefb", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b5de01437baf9417c4e7d0831037ed09a0557d5/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b5de01437baf9417c4e7d0831037ed09a0557d5/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=2b5de01437baf9417c4e7d0831037ed09a0557d5", "patch": "@@ -4396,6 +4396,48 @@ proc check_effective_target_arm_v8_2a_fp16_neon_ok { } {\n \t\tcheck_effective_target_arm_v8_2a_fp16_neon_ok_nocache]\n }\n \n+# Return 1 if the target supports ARMv8.2 Adv.SIMD Dot Product\n+# instructions, 0 otherwise.  The test is valid for ARM and for AArch64.\n+# Record the command line options needed.\n+\n+proc check_effective_target_arm_v8_2a_dotprod_neon_ok_nocache { } {\n+    global et_arm_v8_2a_dotprod_neon_flags\n+    set et_arm_v8_2a_dotprod_neon_flags \"\"\n+\n+    if { ![istarget arm*-*-*] && ![istarget aarch64*-*-*] } {\n+        return 0;\n+    }\n+\n+    # Iterate through sets of options to find the compiler flags that\n+    # need to be added to the -march option.\n+    foreach flags {\"\" \"-mfloat-abi=softfp -mfpu=neon-fp-armv8\" \"-mfloat-abi=hard -mfpu=neon-fp-armv8\"} {\n+        if { [check_no_compiler_messages_nocache \\\n+                  arm_v8_2a_dotprod_neon_ok object {\n+            #if !defined (__ARM_FEATURE_DOTPROD)\n+            #error \"__ARM_FEATURE_DOTPROD not defined\"\n+            #endif\n+        } \"$flags -march=armv8.2-a+dotprod\"] } {\n+            set et_arm_v8_2a_dotprod_neon_flags \"$flags -march=armv8.2-a+dotprod\"\n+            return 1\n+        }\n+    }\n+\n+    return 0;\n+}\n+\n+proc check_effective_target_arm_v8_2a_dotprod_neon_ok { } {\n+    return [check_cached_effective_target arm_v8_2a_dotprod_neon_ok \\\n+                check_effective_target_arm_v8_2a_dotprod_neon_ok_nocache]\n+}\n+\n+proc add_options_for_arm_v8_2a_dotprod_neon { flags } {\n+    if { ! [check_effective_target_arm_v8_2a_dotprod_neon_ok] } {\n+        return \"$flags\"\n+    }\n+    global et_arm_v8_2a_dotprod_neon_flags\n+    return \"$flags $et_arm_v8_2a_dotprod_neon_flags\"\n+}\n+\n # Return 1 if the target supports executing ARMv8 NEON instructions, 0\n # otherwise.\n \n@@ -4533,6 +4575,42 @@ proc check_effective_target_arm_v8_2a_fp16_neon_hw { } {\n     } [add_options_for_arm_v8_2a_fp16_neon \"\"]]\n }\n \n+# Return 1 if the target supports executing AdvSIMD instructions from ARMv8.2\n+# with the Dot Product extension, 0 otherwise.  The test is valid for ARM and for\n+# AArch64.\n+\n+proc check_effective_target_arm_v8_2a_dotprod_neon_hw { } {\n+    if { ![check_effective_target_arm_v8_2a_dotprod_neon_ok] } {\n+        return 0;\n+    }\n+    return [check_runtime arm_v8_2a_dotprod_neon_hw_available {\n+        #include \"arm_neon.h\"\n+        int\n+        main (void)\n+        {\n+\n+\t  uint32x2_t results = {0,0};\n+\t  uint8x8_t a = {1,1,1,1,2,2,2,2};\n+\t  uint8x8_t b = {2,2,2,2,3,3,3,3};\n+\n+          #ifdef __ARM_ARCH_ISA_A64\n+          asm (\"udot %0.2s, %1.8b, %2.8b\"\n+               : \"=w\"(results)\n+               : \"w\"(a), \"w\"(b)\n+               : /* No clobbers.  */);\n+\n+\t  #else\n+          asm (\"vudot.u8 %P0, %P1, %P2\"\n+               : \"=w\"(results)\n+               : \"w\"(a), \"w\"(b)\n+               : /* No clobbers.  */);\n+          #endif\n+\n+          return (results[0] == 8 && results[1] == 24) ? 1 : 0;\n+        }\n+    } [add_options_for_arm_v8_2a_dotprod_neon \"\"]]\n+}\n+\n # Return 1 if this is a ARM target with NEON enabled.\n \n proc check_effective_target_arm_neon { } {\n@@ -5850,6 +5928,8 @@ proc check_effective_target_vect_sdot_qi { } {\n     } else {\n \tset et_vect_sdot_qi_saved($et_index) 0\n \tif { [istarget ia64-*-*]\n+\t     || [istarget aarch64*-*-*]\n+\t     || [istarget arm*-*-*]\n \t     || ([istarget mips*-*-*]\n \t\t && [et-is-effective-target mips_msa]) } {\n             set et_vect_udot_qi_saved 1\n@@ -5874,6 +5954,8 @@ proc check_effective_target_vect_udot_qi { } {\n     } else {\n \tset et_vect_udot_qi_saved($et_index) 0\n         if { [istarget powerpc*-*-*]\n+\t     || [istarget aarch64*-*-*]\n+\t     || [istarget arm*-*-*]\n \t     || [istarget ia64-*-*]\n \t     || ([istarget mips*-*-*]\n \t\t && [et-is-effective-target mips_msa]) } {\n@@ -8290,7 +8372,7 @@ proc check_effective_target_aarch64_tiny { } {\n # Create functions to check that the AArch64 assembler supports the\n # various architecture extensions via the .arch_extension pseudo-op.\n \n-foreach { aarch64_ext } { \"fp\" \"simd\" \"crypto\" \"crc\" \"lse\"} {\n+foreach { aarch64_ext } { \"fp\" \"simd\" \"crypto\" \"crc\" \"lse\" \"dotprod\"} {\n     eval [string map [list FUNC $aarch64_ext] {\n \tproc check_effective_target_aarch64_asm_FUNC_ok { } {\n \t  if { [istarget aarch64*-*-*] } {"}]}