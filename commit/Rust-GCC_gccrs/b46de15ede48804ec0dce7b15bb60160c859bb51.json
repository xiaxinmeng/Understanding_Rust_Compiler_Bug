{"sha": "b46de15ede48804ec0dce7b15bb60160c859bb51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ2ZGUxNWVkZTQ4ODA0ZWMwZGNlN2IxNWJiNjAxNjBjODU5YmI1MQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-06-10T19:22:32Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-06-10T19:22:32Z"}, "message": "pa.h (cmp_type): Add CMP_PSI.\n\n        * pa/pa.h (cmp_type): Add CMP_PSI.\n        (FUNCTION_POINTER_COMPARISON_MODE): Define.\n        * pa.md (cmppsi): New expander.\n        (plabel_dereference): New pattern\n\nFrom-SVN: r12266", "tree": {"sha": "f92e62cb5cd9a76e107a30b40578d9fcc4a08aaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f92e62cb5cd9a76e107a30b40578d9fcc4a08aaf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b46de15ede48804ec0dce7b15bb60160c859bb51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b46de15ede48804ec0dce7b15bb60160c859bb51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b46de15ede48804ec0dce7b15bb60160c859bb51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b46de15ede48804ec0dce7b15bb60160c859bb51/comments", "author": null, "committer": null, "parents": [{"sha": "e47ae1c2d3c228f988571479613b1786fe6c9165", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e47ae1c2d3c228f988571479613b1786fe6c9165", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e47ae1c2d3c228f988571479613b1786fe6c9165"}], "stats": {"total": 147, "additions": 145, "deletions": 2}, "files": [{"sha": "9cc78a45cd4b1737d38e187c02514b06e05ca5ed", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46de15ede48804ec0dce7b15bb60160c859bb51/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46de15ede48804ec0dce7b15bb60160c859bb51/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=b46de15ede48804ec0dce7b15bb60160c859bb51", "patch": "@@ -4462,9 +4462,7 @@ output_millicode_call (insn, call_dest)\n      and we're sure that the branch will reach the beginning of the $CODE$\n      subspace.  */\n   if ((dbr_sequence_length () == 0\n-/* CYGNUS LOCAL mentor6480hack/law */\n        && (get_attr_length (insn) == 8 || get_attr_length (insn) == 28))\n-/* END CYGNUS LOCAL */\n       || (dbr_sequence_length () != 0\n \t  && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN\n \t  && get_attr_length (insn) == 4))"}, {"sha": "4ccb4871a6282b518a95be2a9a60e781214799a6", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46de15ede48804ec0dce7b15bb60160c859bb51/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46de15ede48804ec0dce7b15bb60160c859bb51/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=b46de15ede48804ec0dce7b15bb60160c859bb51", "patch": "@@ -23,6 +23,8 @@ Boston, MA 02111-1307, USA.  */\n \n enum cmp_type\t\t\t\t/* comparison type */\n {\n+  /* See FUNCTION_POINTER_COMPARISON_MODE for info on CMP_PSI.  */\n+  CMP_PSI,\t\t\t\t/* For function pointers.  */\n   CMP_SI,\t\t\t\t/* compare integers */\n   CMP_SF,\t\t\t\t/* compare single precision floats */\n   CMP_DF,\t\t\t\t/* compare double precision floats */\n@@ -1661,6 +1663,26 @@ while (0)\n    between pointers and any other objects of this machine mode.  */\n #define Pmode SImode\n \n+/* XXX FIXME.  The function pointer comparison code is only at the FSF\n+   for documentation and merging purposes, it is _NOT_ actually used.\n+\n+   I've been trying to get Kenner to deal with the machine independent\n+   problems for many months, and for whatever reason nothing ever seems\n+   to happen.\n+\n+   If you want function pointer comparisons to work, first scream at\n+   Kenner to deal with the MI problems, then email me for a hack that\n+   will get the job done (law@cygnus.com).\n+   \n+  The mode in which function pointer comparisons occur.  The PA backend\n+   uses this mode to identify function pointer comparisons so that special\n+   code needed to compare functions can be generated.\n+\n+   Note, special code is not needed for function pointer comparisons\n+   in the portable runtime model.  */\n+#define FUNCTION_POINTER_COMPARISON_MODE \\\n+  (TARGET_PORTABLE_RUNTIME ? Pmode : PSImode)\n+\n /* Add any extra modes needed to represent the condition code.\n \n    HPPA floating comparisons produce condition codes. */"}, {"sha": "7a909649c8b95c079c6afdcd571cac270d720075", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b46de15ede48804ec0dce7b15bb60160c859bb51/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b46de15ede48804ec0dce7b15bb60160c859bb51/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=b46de15ede48804ec0dce7b15bb60160c859bb51", "patch": "@@ -340,6 +340,44 @@\n ;; emit RTL for both the compare and the branch.\n ;;\n \n+;; This expander is not used by the FSF compiler, refer to\n+;; FUNCTION_POINTER_COMPARISON_MODE in pa.h for a brief discussion why.\n+(define_expand \"cmppsi\"\n+  [(set (reg:CC 0)\n+\t(compare:CC (match_operand:SI 0 \"reg_or_0_operand\" \"\")\n+\t\t    (match_operand:SI 1 \"reg_or_0_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  rtx res0, res1;\n+\n+  /* We need two new pseudos to hold the value of the dereferenced\n+     plabel.  */\n+  res0 = gen_reg_rtx (Pmode);\n+  res1 = gen_reg_rtx (Pmode);\n+\n+  /* Move the first function pointer into %r26 and call the\n+     magic millicode routine to get the function's actual\n+     address.   Copy the result from %r29 into the first\n+     psuedo.  */\n+  emit_move_insn (gen_rtx (REG, Pmode, 26), operands[0]);\n+  emit_insn (gen_plabel_dereference (gen_reg_rtx (SImode)));\n+  emit_move_insn (res0, gen_rtx (REG, Pmode, 29));\n+\n+  /* Likewise for the second function pointer. */\n+  emit_move_insn (gen_rtx (REG, Pmode, 26), operands[1]);\n+  emit_insn (gen_plabel_dereference (gen_reg_rtx (SImode)));\n+  emit_move_insn (res1, gen_rtx (REG, Pmode, 29));\n+\n+  /* Put the results in hppa_compare_op0 and hppa_compare_op1.  */\n+  hppa_compare_op0 = res0;\n+  hppa_compare_op1 = res1;\n+  /* The branch is really a SImode branch.  PSImode was used just\n+     so we could identify this as a function pointer comparison.  */\n+ hppa_branch_type = CMP_SI;\n+ DONE;\n+}\")\n+\n (define_expand \"cmpsi\"\n   [(set (reg:CC 0)\n \t(compare:CC (match_operand:SI 0 \"reg_or_0_operand\" \"\")\n@@ -5262,3 +5300,88 @@\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"8\")])\n \n+/* Given a function pointer (aka plabel) in %r26, return (in %r29) the\n+   actual address of the function that would be called if the function\n+   pointer was used in an indirect call.\n+\n+   We must show %r1 as clobbered since the linker might insert a stub\n+   in the call path that clobbers %r1 (yes, it really happens).  */\n+;; This expander is not used by the FSF compiler, refer to\n+;; FUNCTION_POINTER_COMPARISON_MODE in pa.h for a brief discussion why.\n+(define_insn \"plabel_dereference\"\n+  [(set (reg:SI 29) (unspec:SI [(reg:SI 26)] 0))\n+   (clobber (match_operand:SI 0 \"register_operand\" \"=a\"))\n+   (clobber (reg:SI 26))\n+   (clobber (reg:SI 22))\n+   (clobber (reg:SI 31))]\n+  \"\"\n+  \"*\n+{\n+  /* Must import the magic millicode routine.  */\n+  output_asm_insn (\\\".IMPORT $$sh_func_adrs,MILLICODE\\\", NULL);\n+\n+  /* This is absolutely fucking amazing.\n+\n+     First, copy our input parameter into %r29 just in case we don't\n+     need to call $$sh_func_adrs.  */\n+  output_asm_insn (\\\"copy %%r26,%%r29\\\", NULL);\n+\n+  /* Next, examine the low two bits in %r26, if they aren't 0x2, then\n+     we use %r26 unchanged.  */\n+  if (get_attr_length (insn) == 32)\n+    output_asm_insn (\\\"extru %%r26,31,2,%%r31\\;comib,<>,n 2,%%r31,.+24\\\", NULL);\n+  else if (get_attr_length (insn) == 40)\n+    output_asm_insn (\\\"extru %%r26,31,2,%%r31\\;comib,<>,n 2,%%r31,.+32\\\", NULL);\n+  else if (get_attr_length (insn) == 44)\n+    output_asm_insn (\\\"extru %%r26,31,2,%%r31\\;comib,<>,n 2,%%r31,.+36\\\", NULL);\n+  else\n+    output_asm_insn (\\\"extru %%r26,31,2,%%r31\\;comib,<>,n 2,%%r31,.+20\\\", NULL);\n+\n+  /* Next, compare %r26 with 4096, if %r26 is less than or equal to\n+     4096, then we use %r26 unchanged.  */\n+  if (get_attr_length (insn) == 32)\n+    output_asm_insn (\\\"ldi 4096,%%r31\\;comb,<<,n %%r26,%%r31,.+16\\\", NULL);\n+  else if (get_attr_length (insn) == 40)\n+    output_asm_insn (\\\"ldi 4096,%%r31\\;comb,<<,n %%r26,%%r31,.+24\\\", NULL);\n+  else if (get_attr_length (insn) == 44)\n+    output_asm_insn (\\\"ldi 4096,%%r31\\;comb,<<,n %%r26,%%r31,.+28\\\", NULL);\n+  else\n+    output_asm_insn (\\\"ldi 4096,%%r31\\;comb,<<,n %%r26,%%r31,.+12\\\", NULL);\n+\n+  /* Else call $$sh_func_adrs to extract the function's real add24.  */\n+  return output_millicode_call (insn,\n+\t\t\t\tgen_rtx (SYMBOL_REF, SImode,\n+\t\t\t\t\t \\\"$$sh_func_adrs\\\"));\n+}\"\n+  [(set_attr \"type\" \"multi\")\n+   (set (attr \"length\")\n+     (cond [\n+;; Target (or stub) within reach\n+            (and (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n+                     (const_int 240000))\n+                 (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+                     (const_int 0)))\n+            (const_int 28)\n+\n+;; NO_SPACE_REGS\n+            (ne (symbol_ref \"TARGET_NO_SPACE_REGS\")\n+                (const_int 0))\n+            (const_int 32)\n+\n+;; Out of reach, but not PIC or PORTABLE_RUNTIME\n+;; same as NO_SPACE_REGS code\n+            (and (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+                     (const_int 0))\n+                 (eq (symbol_ref \"flag_pic\")\n+                     (const_int 0)))\n+            (const_int 32)\n+\n+;; PORTABLE_RUTNIME\n+\t    (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n+\t\t(const_int 0))\n+\t    (const_int 40)]\n+\n+;; Out of range and PIC \n+\t  (const_int 44)))])\n+\n+"}]}