{"sha": "1954a27b0c3d427a8fddeab6b089cbbe10f9f049", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk1NGEyN2IwYzNkNDI3YThmZGRlYWI2YjA4OWNiYmUxMGY5ZjA0OQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2007-10-14T20:24:20Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2007-10-14T20:24:20Z"}, "message": "re PR fortran/33745 (-fbounds-check: Bogus out-of-bounds run-time error for assumed-size array)\n\n2007-10-14  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/33745\n        * trans-array.c (gfc_conv_ss_startstride): Fix dimension check.\n        (gfc_trans_array_bound_check, gfc_conv_array_ref,\n        gfc_conv_ss_startstride): Simplify error message.\n        * resolve.c (check_dimension): Fix dimension-type switch;\n        improve error message.\n\n2007-10-14  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/33745\n        * gfortran.dg/bounds_check_11.f90: New.\n\nFrom-SVN: r129302", "tree": {"sha": "672198e6c129385eba3404a760dce3a50fe15747", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/672198e6c129385eba3404a760dce3a50fe15747"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1954a27b0c3d427a8fddeab6b089cbbe10f9f049", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1954a27b0c3d427a8fddeab6b089cbbe10f9f049", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1954a27b0c3d427a8fddeab6b089cbbe10f9f049", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1954a27b0c3d427a8fddeab6b089cbbe10f9f049/comments", "author": null, "committer": null, "parents": [{"sha": "2c888488e1c807f061958445b4d166c2a1040721", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c888488e1c807f061958445b4d166c2a1040721", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c888488e1c807f061958445b4d166c2a1040721"}], "stats": {"total": 144, "additions": 107, "deletions": 37}, "files": [{"sha": "717053a68fe06d77721ee5078cb0ef474b7edb77", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1954a27b0c3d427a8fddeab6b089cbbe10f9f049/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1954a27b0c3d427a8fddeab6b089cbbe10f9f049/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1954a27b0c3d427a8fddeab6b089cbbe10f9f049", "patch": "@@ -1,3 +1,12 @@\n+2007-10-14  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/33745\n+\t* trans-array.c (gfc_conv_ss_startstride): Fix dimension check.\n+\t(gfc_trans_array_bound_check, gfc_conv_array_ref,\n+\tgfc_conv_ss_startstride): Simplify error message.\n+\t* resolve.c (check_dimension): Fix dimension-type switch;\n+\timprove error message.\n+\n 2007-10-13  Tobias Schl\ufffdter  <tobi@gcc.gnu.org>\n \t    Paul Thomas  <pault@gcc.gnu.org>\n "}, {"sha": "2461bc3beeb26097017c4f454305b34e202298bb", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 49, "deletions": 16, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1954a27b0c3d427a8fddeab6b089cbbe10f9f049/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1954a27b0c3d427a8fddeab6b089cbbe10f9f049/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=1954a27b0c3d427a8fddeab6b089cbbe10f9f049", "patch": "@@ -3215,20 +3215,32 @@ check_dimension (int i, gfc_array_ref *ar, gfc_array_spec *as)\n /* Given start, end and stride values, calculate the minimum and\n    maximum referenced indexes.  */\n \n-  switch (ar->type)\n+  switch (ar->dimen_type[i])\n     {\n-    case AR_FULL:\n+    case DIMEN_VECTOR:\n       break;\n \n-    case AR_ELEMENT:\n+    case DIMEN_ELEMENT:\n       if (compare_bound (ar->start[i], as->lower[i]) == CMP_LT)\n-\tgoto bound;\n+\t{\n+\t  gfc_warning (\"Array reference at %L is out of bounds \"\n+\t\t       \"(%ld < %ld) in dimension %d\", &ar->c_where[i],\n+\t\t       mpz_get_si (ar->start[i]->value.integer),\n+\t\t       mpz_get_si (as->lower[i]->value.integer), i+1);\n+\t  return SUCCESS;\n+\t}\n       if (compare_bound (ar->start[i], as->upper[i]) == CMP_GT)\n-\tgoto bound;\n+\t{\n+\t  gfc_warning (\"Array reference at %L is out of bounds \"\n+\t\t       \"(%ld > %ld) in dimension %d\", &ar->c_where[i],\n+\t\t       mpz_get_si (ar->start[i]->value.integer),\n+\t\t       mpz_get_si (as->upper[i]->value.integer), i+1);\n+\t  return SUCCESS;\n+\t}\n \n       break;\n \n-    case AR_SECTION:\n+    case DIMEN_RANGE:\n       {\n #define AR_START (ar->start[i] ? ar->start[i] : as->lower[i])\n #define AR_END (ar->end[i] ? ar->end[i] : as->upper[i])\n@@ -3253,9 +3265,22 @@ check_dimension (int i, gfc_array_ref *ar, gfc_array_spec *as)\n \t    || (compare_bound_int (ar->stride[i], 0) == CMP_LT\n \t        && comp_start_end == CMP_GT))\n \t  {\n-\t    if (compare_bound (AR_START, as->lower[i]) == CMP_LT\n-\t\t|| compare_bound (AR_START, as->upper[i]) == CMP_GT)\n-\t      goto bound;\n+\t    if (compare_bound (AR_START, as->lower[i]) == CMP_LT)\n+\t      {\n+\t\tgfc_warning (\"Lower array reference at %L is out of bounds \"\n+\t\t       \"(%ld < %ld) in dimension %d\", &ar->c_where[i],\n+\t\t       mpz_get_si (AR_START->value.integer),\n+\t\t       mpz_get_si (as->lower[i]->value.integer), i+1);\n+\t\treturn SUCCESS;\n+\t      }\n+\t    if (compare_bound (AR_START, as->upper[i]) == CMP_GT)\n+\t      {\n+\t\tgfc_warning (\"Lower array reference at %L is out of bounds \"\n+\t\t       \"(%ld > %ld) in dimension %d\", &ar->c_where[i],\n+\t\t       mpz_get_si (AR_START->value.integer),\n+\t\t       mpz_get_si (as->upper[i]->value.integer), i+1);\n+\t\treturn SUCCESS;\n+\t      }\n \t  }\n \n \t/* If we can compute the highest index of the array section,\n@@ -3264,11 +3289,23 @@ check_dimension (int i, gfc_array_ref *ar, gfc_array_spec *as)\n \tif (compute_last_value_for_triplet (AR_START, AR_END, ar->stride[i],\n \t\t\t\t\t    last_value))\n \t  {\n-\t    if (compare_bound_mpz_t (as->lower[i], last_value) == CMP_GT\n-\t        || compare_bound_mpz_t (as->upper[i], last_value) == CMP_LT)\n+\t    if (compare_bound_mpz_t (as->lower[i], last_value) == CMP_GT)\n+\t      {\n+\t\tgfc_warning (\"Upper array reference at %L is out of bounds \"\n+\t\t       \"(%ld < %ld) in dimension %d\", &ar->c_where[i],\n+\t\t       mpz_get_si (last_value),\n+\t\t       mpz_get_si (as->lower[i]->value.integer), i+1);\n+\t        mpz_clear (last_value);\n+\t\treturn SUCCESS;\n+\t      }\n+\t    if (compare_bound_mpz_t (as->upper[i], last_value) == CMP_LT)\n \t      {\n+\t\tgfc_warning (\"Upper array reference at %L is out of bounds \"\n+\t\t       \"(%ld > %ld) in dimension %d\", &ar->c_where[i],\n+\t\t       mpz_get_si (last_value),\n+\t\t       mpz_get_si (as->upper[i]->value.integer), i+1);\n \t        mpz_clear (last_value);\n-\t        goto bound;\n+\t\treturn SUCCESS;\n \t      }\n \t  }\n \tmpz_clear (last_value);\n@@ -3283,10 +3320,6 @@ check_dimension (int i, gfc_array_ref *ar, gfc_array_spec *as)\n     }\n \n   return SUCCESS;\n-\n-bound:\n-  gfc_warning (\"Array reference at %L is out of bounds\", &ar->c_where[i]);\n-  return SUCCESS;\n }\n \n "}, {"sha": "c598d25ac1e188c228c1c892dd021e15d3f97b1a", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1954a27b0c3d427a8fddeab6b089cbbe10f9f049/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1954a27b0c3d427a8fddeab6b089cbbe10f9f049/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=1954a27b0c3d427a8fddeab6b089cbbe10f9f049", "patch": "@@ -2109,11 +2109,11 @@ gfc_trans_array_bound_check (gfc_se * se, tree descriptor, tree index, int n,\n   tmp = gfc_conv_array_lbound (descriptor, n);\n   fault = fold_build2 (LT_EXPR, boolean_type_node, index, tmp);\n   if (name)\n-    asprintf (&msg, \"%s for array '%s', lower bound of dimension %d exceeded\",\n-\t      gfc_msg_fault, name, n+1);\n+    asprintf (&msg, \"%s for array '%s', lower bound of dimension %d exceeded\"\n+\t      \"(%%ld < %%ld)\", gfc_msg_fault, name, n+1);\n   else\n-    asprintf (&msg, \"%s, lower bound of dimension %d exceeded, %%ld is \"\n-\t      \"smaller than %%ld\", gfc_msg_fault, n+1);\n+    asprintf (&msg, \"%s, lower bound of dimension %d exceeded (%%ld < %%ld)\",\n+\t      gfc_msg_fault, n+1);\n   gfc_trans_runtime_check (fault, &se->pre, where, msg,\n \t\t\t   fold_convert (long_integer_type_node, index),\n \t\t\t   fold_convert (long_integer_type_node, tmp));\n@@ -2126,10 +2126,10 @@ gfc_trans_array_bound_check (gfc_se * se, tree descriptor, tree index, int n,\n       fault = fold_build2 (GT_EXPR, boolean_type_node, index, tmp);\n       if (name)\n \tasprintf (&msg, \"%s for array '%s', upper bound of dimension %d \"\n-\t\t\t\" exceeded\", gfc_msg_fault, name, n+1);\n+\t\t\t\" exceeded (%%ld > %%ld)\", gfc_msg_fault, name, n+1);\n       else\n-\tasprintf (&msg, \"%s, upper bound of dimension %d exceeded, %%ld is \"\n-\t\t  \"larger than %%ld\", gfc_msg_fault, n+1);\n+\tasprintf (&msg, \"%s, upper bound of dimension %d exceeded (%%ld > %%ld)\",\n+\t\t  gfc_msg_fault, n+1);\n       gfc_trans_runtime_check (fault, &se->pre, where, msg,\n \t\t\t       fold_convert (long_integer_type_node, index),\n \t\t\t       fold_convert (long_integer_type_node, tmp));\n@@ -2323,8 +2323,8 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,\n \t  cond = fold_build2 (LT_EXPR, boolean_type_node, \n \t\t\t      indexse.expr, tmp);\n \t  asprintf (&msg, \"%s for array '%s', \"\n-\t            \"lower bound of dimension %d exceeded, %%ld is smaller \"\n-\t\t    \"than %%ld\", gfc_msg_fault, sym->name, n+1);\n+\t            \"lower bound of dimension %d exceeded (%%ld < %%ld)\",\n+\t\t    gfc_msg_fault, sym->name, n+1);\n \t  gfc_trans_runtime_check (cond, &se->pre, where, msg,\n \t\t\t\t   fold_convert (long_integer_type_node,\n \t\t\t\t\t\t indexse.expr),\n@@ -2340,8 +2340,8 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,\n \t      cond = fold_build2 (GT_EXPR, boolean_type_node, \n \t\t\t\t  indexse.expr, tmp);\n \t      asprintf (&msg, \"%s for array '%s', \"\n-\t\t\t\"upper bound of dimension %d exceeded, %%ld is \"\n-\t\t\t\"greater than %%ld\", gfc_msg_fault, sym->name, n+1);\n+\t\t\t\"upper bound of dimension %d exceeded (%%ld > %%ld)\",\n+\t\t\tgfc_msg_fault, sym->name, n+1);\n \t      gfc_trans_runtime_check (cond, &se->pre, where, msg,\n \t\t\t\t   fold_convert (long_integer_type_node,\n \t\t\t\t\t\t indexse.expr),\n@@ -2888,7 +2888,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      if (info->ref->u.ar.dimen_type[dim] != DIMEN_RANGE)\n \t\tcontinue;\n \n-\t      if (n == info->ref->u.ar.dimen - 1\n+\t      if (dim == info->ref->u.ar.dimen - 1\n \t\t  && (info->ref->u.ar.as->type == AS_ASSUMED_SIZE\n \t\t      || info->ref->u.ar.as->cp_was_assumed))\n \t\tcheck_upper = false;\n@@ -2941,7 +2941,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t non_zerosized, tmp);\n \t      asprintf (&msg, \"%s, lower bound of dimension %d of array '%s'\"\n-\t\t\t\" exceeded, %%ld is smaller than %%ld\", gfc_msg_fault,\n+\t\t\t\" exceeded (%%ld < %%ld)\", gfc_msg_fault,\n \t\t\tinfo->dim[n]+1, ss->expr->symtree->name);\n \t      gfc_trans_runtime_check (tmp, &block, &ss->expr->where, msg,\n \t\t\t\t       fold_convert (long_integer_type_node,\n@@ -2957,9 +2957,8 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t  tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t     non_zerosized, tmp);\n \t          asprintf (&msg, \"%s, upper bound of dimension %d of array \"\n-\t\t\t    \"'%s' exceeded, %%ld is greater than %%ld\",\n-\t\t\t    gfc_msg_fault, info->dim[n]+1,\n-\t\t\t    ss->expr->symtree->name);\n+\t\t\t    \"'%s' exceeded (%%ld > %%ld)\", gfc_msg_fault,\n+\t\t\t    info->dim[n]+1, ss->expr->symtree->name);\n \t\t  gfc_trans_runtime_check (tmp, &block, &ss->expr->where, msg,\n \t\t\tfold_convert (long_integer_type_node, info->start[n]),\n \t\t\tfold_convert (long_integer_type_node, ubound));\n@@ -2980,7 +2979,7 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t      tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t non_zerosized, tmp);\n \t      asprintf (&msg, \"%s, lower bound of dimension %d of array '%s'\"\n-\t\t\t\" exceeded, %%ld is smaller than %%ld\", gfc_msg_fault,\n+\t\t\t\" exceeded (%%ld < %%ld)\", gfc_msg_fault,\n \t\t\tinfo->dim[n]+1, ss->expr->symtree->name);\n \t      gfc_trans_runtime_check (tmp, &block, &ss->expr->where, msg,\n \t\t\t\t       fold_convert (long_integer_type_node,\n@@ -2995,9 +2994,8 @@ gfc_conv_ss_startstride (gfc_loopinfo * loop)\n \t\t  tmp = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t     non_zerosized, tmp);\n \t\t  asprintf (&msg, \"%s, upper bound of dimension %d of array \"\n-\t\t\t    \"'%s' exceeded, %%ld is greater than %%ld\",\n-\t\t\t    gfc_msg_fault, info->dim[n]+1,\n-\t\t\t    ss->expr->symtree->name);\n+\t\t\t    \"'%s' exceeded (%%ld > %%ld)\", gfc_msg_fault,\n+\t\t\t    info->dim[n]+1, ss->expr->symtree->name);\n \t\t  gfc_trans_runtime_check (tmp, &block, &ss->expr->where, msg,\n \t\t\tfold_convert (long_integer_type_node, tmp2),\n \t\t\tfold_convert (long_integer_type_node, ubound));"}, {"sha": "4ec1dc3a349fba57a9bbcfd1287a6ba931992c44", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1954a27b0c3d427a8fddeab6b089cbbe10f9f049/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1954a27b0c3d427a8fddeab6b089cbbe10f9f049/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1954a27b0c3d427a8fddeab6b089cbbe10f9f049", "patch": "@@ -1,6 +1,11 @@\n+2007-10-14  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/33745\n+\t* gfortran.dg/bounds_check_11.f90: New.\n+\n 2007-10-14  Andrew Pinski  <pinskia@gmail.com>\n \n-        PR c++/30303\n+\tPR c++/30303\n \t* g++.dg/other/ctor1.C: New test.\n \t* g++.dg/other/ctor2.C: New test.\n \t* g++.dg/other/dtor1.C: New test."}, {"sha": "648e1d3ab610d2f6acf5a77e560dbf03a2254245", "filename": "gcc/testsuite/gfortran.dg/bounds_check_11.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1954a27b0c3d427a8fddeab6b089cbbe10f9f049/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_11.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1954a27b0c3d427a8fddeab6b089cbbe10f9f049/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_11.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fbounds_check_11.f90?ref=1954a27b0c3d427a8fddeab6b089cbbe10f9f049", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do run }\n+! { dg-options \"-fbounds-check\" }\n+! { dg-shouldfail \"Array bound checking\" }\n+! PR fortran/33745\n+!\n+! Don't check upper bound of assumed-size array\n+!\n+\n+program test\n+ implicit none\n+ integer, parameter :: maxss=7,maxc=8\n+ integer :: jp(2,maxc)\n+ call findphase(jp)\n+contains\n+  subroutine findphase(jp)\n+    integer, intent(out) :: jp(2,*)\n+    jp(2,2:4)=0\n+    jp(2,0:4)=0 ! { dg-warning \"out of bounds\" }\n+    jp(3,1:4)=0 ! { dg-warning \"out of bounds\" }\n+  end subroutine\n+end program test\n+\n+! { dg-output \"At line 18 of file .*\" }\n+! { dg-output \"Array reference out of bounds, lower bound of dimension 2 of array 'jp' exceeded .0 < 1.\" }\n+"}]}