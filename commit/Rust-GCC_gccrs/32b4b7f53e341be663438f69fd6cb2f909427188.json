{"sha": "32b4b7f53e341be663438f69fd6cb2f909427188", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzJiNGI3ZjUzZTM0MWJlNjYzNDM4ZjY5ZmQ2Y2IyZjkwOTQyNzE4OA==", "commit": {"author": {"name": "Dmitry Vyukov", "email": "dvyukov@google.com", "date": "2012-11-22T21:56:58Z"}, "committer": {"name": "Wei Mi", "email": "wmi@gcc.gnu.org", "date": "2012-11-22T21:56:58Z"}, "message": "builtins.def (DEF_SANITIZER_BUILTIN): Define tsan builtins.\n\n2012-11-22  Dmitry Vyukov  <dvyukov@google.com>\n\t    Wei Mi  <wmi@google.com>\n\n\t* builtins.def (DEF_SANITIZER_BUILTIN): Define tsan builtins. \n\t* sanitizer.def: Ditto. \n\t* Makefile.in (tsan.o): Add tsan.o target. \n\t(BUILTINS_DEF): Add sanitizer.def.\n\t* passes.c (init_optimization_passes): Add tsan passes.\n\t* tree-pass.h (register_pass_info): Ditto.\n\t* toplev.c (compile_file): Ditto. \n\t* doc/invoke.texi: Document tsan related options.\n\t* gcc.c (LINK_COMMAND_SPEC): Add LIBTSAN_SPEC in link command if\n\t-fsanitize=thread.\n\t* tsan.c: New file about tsan.\n\t* tsan.h: Ditto.\n\t* common.opt: Add -fsanitize=thread.\n\n\nCo-Authored-By: Wei Mi <wmi@google.com>\n\nFrom-SVN: r193736", "tree": {"sha": "368bbe384fc86dd4c4da764b1d83bb50a9b3ced8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/368bbe384fc86dd4c4da764b1d83bb50a9b3ced8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32b4b7f53e341be663438f69fd6cb2f909427188", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32b4b7f53e341be663438f69fd6cb2f909427188", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32b4b7f53e341be663438f69fd6cb2f909427188", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32b4b7f53e341be663438f69fd6cb2f909427188/comments", "author": {"login": "dvyukov", "id": 1095328, "node_id": "MDQ6VXNlcjEwOTUzMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1095328?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dvyukov", "html_url": "https://github.com/dvyukov", "followers_url": "https://api.github.com/users/dvyukov/followers", "following_url": "https://api.github.com/users/dvyukov/following{/other_user}", "gists_url": "https://api.github.com/users/dvyukov/gists{/gist_id}", "starred_url": "https://api.github.com/users/dvyukov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dvyukov/subscriptions", "organizations_url": "https://api.github.com/users/dvyukov/orgs", "repos_url": "https://api.github.com/users/dvyukov/repos", "events_url": "https://api.github.com/users/dvyukov/events{/privacy}", "received_events_url": "https://api.github.com/users/dvyukov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bdb6985c8782cdd91a637a6d36bab4ba561c3f9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bdb6985c8782cdd91a637a6d36bab4ba561c3f9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bdb6985c8782cdd91a637a6d36bab4ba561c3f9b"}], "stats": {"total": 545, "additions": 542, "deletions": 3}, "files": [{"sha": "9bd49a877de63e17b0ecf19deb9bb16f601a6fde", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32b4b7f53e341be663438f69fd6cb2f909427188", "patch": "@@ -1,3 +1,20 @@\n+2012-11-22  Dmitry Vyukov  <dvyukov@google.com>\n+\t    Wei Mi  <wmi@google.com>\n+\n+\t* builtins.def (DEF_SANITIZER_BUILTIN): Define tsan builtins. \n+\t* sanitizer.def: Ditto. \n+\t* Makefile.in (tsan.o): Add tsan.o target. \n+\t(BUILTINS_DEF): Add sanitizer.def.\n+\t* passes.c (init_optimization_passes): Add tsan passes.\n+\t* tree-pass.h (register_pass_info): Ditto.\n+\t* toplev.c (compile_file): Ditto. \n+\t* doc/invoke.texi: Document tsan related options.\n+\t* gcc.c (LINK_COMMAND_SPEC): Add LIBTSAN_SPEC in link command if\n+\t-fsanitize=thread.\n+\t* tsan.c: New file about tsan.\n+\t* tsan.h: Ditto.\n+\t* common.opt: Add -fsanitize=thread.\n+\n 2012-11-22  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* doc/md.texi (RTL Templates Transformation): Use @pxref for"}, {"sha": "7ac7b2594a215b018217d9c32baf85f220d79b00", "filename": "gcc/Makefile.in", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=32b4b7f53e341be663438f69fd6cb2f909427188", "patch": "@@ -863,7 +863,7 @@ RTL_ERROR_H = rtl-error.h $(RTL_H) $(DIAGNOSTIC_CORE_H)\n READ_MD_H = $(OBSTACK_H) $(HASHTAB_H) read-md.h\n PARAMS_H = params.h params.def\n BUILTINS_DEF = builtins.def sync-builtins.def omp-builtins.def \\\n-\tgtm-builtins.def\n+\tgtm-builtins.def sanitizer.def\n INTERNAL_FN_DEF = internal-fn.def\n INTERNAL_FN_H = internal-fn.h $(INTERNAL_FN_DEF)\n TREE_H = coretypes.h tree.h all-tree.def tree.def c-family/c-common.def \\\n@@ -1365,6 +1365,7 @@ OBJS = \\\n \ttrans-mem.o \\\n \ttree-affine.o \\\n \tasan.o \\\n+\ttsan.o \\\n \ttree-call-cdce.o \\\n \ttree-cfg.o \\\n \ttree-cfgcleanup.o \\\n@@ -2228,6 +2229,12 @@ asan.o : asan.c asan.h $(CONFIG_H) $(SYSTEM_H) $(GIMPLE_H) \\\n    output.h coretypes.h $(GIMPLE_PRETTY_PRINT_H) \\\n    tree-iterator.h $(TREE_FLOW_H) $(TREE_PASS_H) \\\n    $(TARGET_H) $(EXPR_H) $(OPTABS_H) $(TM_P_H)\n+tsan.o : $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(TREE_INLINE_H) \\\n+   $(GIMPLE_H) $(DIAGNOSTIC_H) langhooks.h \\\n+   $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_PASS_H) $(CGRAPH_H) $(GGC_H) \\\n+   $(BASIC_BLOCK_H) $(FLAGS_H) $(FUNCTION_H) \\\n+   $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_CORE_H) $(GIMPLE_H) tree-iterator.h \\\n+   intl.h cfghooks.h output.h options.h c-family/c-common.h tsan.h\n tree-ssa-tail-merge.o: tree-ssa-tail-merge.c \\\n    $(SYSTEM_H) $(CONFIG_H) coretypes.h $(TM_H) $(BITMAP_H) \\\n    $(FLAGS_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n@@ -2689,7 +2696,8 @@ toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(CGRAPH_H) $(COVERAGE_H) alloc-pool.h $(GGC_H) \\\n    $(OPTS_H) params.def tree-mudflap.h $(TREE_PASS_H) $(GIMPLE_H) \\\n    tree-ssa-alias.h $(PLUGIN_H) realmpfr.h tree-diagnostic.h \\\n-   $(TREE_PRETTY_PRINT_H) opts-diagnostic.h $(COMMON_TARGET_H)\n+   $(TREE_PRETTY_PRINT_H) opts-diagnostic.h $(COMMON_TARGET_H) \\\n+   tsan.h\n \n hwint.o : hwint.c $(CONFIG_H) $(SYSTEM_H) $(DIAGNOSTIC_CORE_H)\n \n@@ -3740,6 +3748,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/target-globals.h \\\n   $(srcdir)/ipa-inline.h \\\n   $(srcdir)/asan.c \\\n+  $(srcdir)/tsan.c \\\n   @all_gtfiles@\n \n # Compute the list of GT header files from the corresponding C sources,"}, {"sha": "bfafa5384ef4f56fe2e5a6f7442f0cc882fb9e7f", "filename": "gcc/builtins.def", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=32b4b7f53e341be663438f69fd6cb2f909427188", "patch": "@@ -149,6 +149,15 @@ along with GCC; see the file COPYING3.  If not see\n   DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n \t       true, true, true, ATTRS, false, flag_tm)\n \n+/* Builtin used by the implementation of libsanitizer. These\n+   functions are mapped to the actual implementation of the \n+   libtsan library. */\n+#undef DEF_SANITIZER_BUILTIN\n+#define DEF_SANITIZER_BUILTIN(ENUM, NAME, TYPE, ATTRS) \\\n+  DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,    \\\n+\t       true, true, true, ATTRS, true, \\\n+\t       flag_tsan)\n+\n /* Define an attribute list for math functions that are normally\n    \"impure\" because some of them may write into global memory for\n    `errno'.  If !flag_errno_math they are instead \"const\".  */\n@@ -825,3 +834,7 @@ DEF_GCC_BUILTIN (BUILT_IN_LINE, \"LINE\", BT_FN_INT, ATTR_NOTHROW_LEAF_LIST)\n \n /* GTM builtins. */\n #include \"gtm-builtins.def\"\n+\n+/* Sanitizer builtins. */\n+#include \"sanitizer.def\"\n+"}, {"sha": "5cf16b6b42a2c3cb1db940947708786d8d87078d", "filename": "gcc/common.opt", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=32b4b7f53e341be663438f69fd6cb2f909427188", "patch": "@@ -844,6 +844,10 @@ fsanitize=address\n Common Report Var(flag_asan)\n Enable AddressSanitizer, a memory error detector\n \n+fsanitize=thread\n+Common Report Var(flag_tsan)\n+Enable ThreadSanitizer, a data race detector\n+\n fasynchronous-unwind-tables\n Common Report Var(flag_asynchronous_unwind_tables) Optimization\n Generate unwind tables that are exact at each instruction boundary\n@@ -2519,6 +2523,9 @@ Driver\n static-libasan\n Driver\n \n+static-libtsan\n+Driver\n+\n symbolic\n Driver\n "}, {"sha": "9c2629cf77805e197106b305d84c1ced64f97437", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=32b4b7f53e341be663438f69fd6cb2f909427188", "patch": "@@ -453,7 +453,8 @@ Objective-C and Objective-C++ Dialects}.\n @xref{Link Options,,Options for Linking}.\n @gccoptlist{@var{object-file-name}  -l@var{library} @gol\n -nostartfiles  -nodefaultlibs  -nostdlib -pie -rdynamic @gol\n--s  -static -static-libgcc -static-libasan -static-libstdc++ @gol\n+-s  -static -static-libgcc -static-libstdc++ @gol\n+-static-libasan -static-libtsan @gol\n -shared -shared-libgcc  -symbolic @gol\n -T @var{script}  -Wl,@var{option}  -Xlinker @var{option} @gol\n -u @var{symbol}}\n@@ -6862,6 +6863,12 @@ Memory access instructions will be instrumented to detect\n out-of-bounds and use-after-free bugs. So far only heap bugs will be detected.\n See @uref{http://code.google.com/p/address-sanitizer/} for more details.\n \n+@item -fsanitize=thread\n+Enable ThreadSanitizer, a fast data race detector.\n+Memory access instructions will be instrumented to detect\n+data race bugs. \n+See @uref{http://code.google.com/p/data-race-test/wiki/ThreadSanitizer} for more details.\n+\n @item -fmudflap -fmudflapth -fmudflapir\n @opindex fmudflap\n @opindex fmudflapth\n@@ -9947,6 +9954,15 @@ option is not used, then this links against the shared version of\n driver to link @file{libasan} statically, without necessarily linking\n other libraries statically.\n \n+@item -static-libtsan\n+When the @option{-fsanitize=thread} option is used to link a program,\n+the GCC driver automatically links against @option{libtsan}.  If\n+@file{libtsan} is available as a shared library, and the @option{-static}\n+option is not used, then this links against the shared version of\n+@file{libtsan}.  The @option{-static-libtsan} option directs the GCC\n+driver to link @file{libtsan} statically, without necessarily linking\n+other libraries statically.\n+\n @item -static-libstdc++\n When the @command{g++} program is used to link a C++ program, it\n normally automatically links against @option{libstdc++}.  If"}, {"sha": "13e93e5566bbff4abad725fa4705f080036ce2aa", "filename": "gcc/gcc.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=32b4b7f53e341be663438f69fd6cb2f909427188", "patch": "@@ -560,6 +560,15 @@ proper position among the other output files.  */\n #endif\n #endif\n \n+#ifndef LIBTSAN_SPEC\n+#ifdef HAVE_LD_STATIC_DYNAMIC\n+#define LIBTSAN_SPEC \"%{static-libtsan:\" LD_STATIC_OPTION \\\n+\t\t     \"} -ltsan %{static-libtsan:\" LD_DYNAMIC_OPTION \"}\"\n+#else\n+#define LIBTSAN_SPEC \"-ltsan\"\n+#endif\n+#endif\n+\n /* config.h can define LIBGCC_SPEC to override how and when libgcc.a is\n    included.  */\n #ifndef LIBGCC_SPEC\n@@ -704,6 +713,7 @@ proper position among the other output files.  */\n     %(mflib) \" STACK_SPLIT_SPEC \"\\\n     %{fprofile-arcs|fprofile-generate*|coverage:-lgcov}\\\n     %{fsanitize=address:\" LIBASAN_SPEC \"%{static:%ecannot specify -static with -fsanitize=address}}\\\n+    %{fsanitize=thread:\" LIBTSAN_SPEC \"}\\\n     %{!nostdlib:%{!nodefaultlibs:%(link_ssp) %(link_gcc_c_sequence)}}\\\n     %{!nostdlib:%{!nostartfiles:%E}} %{T*} }}}}}}\"\n #endif"}, {"sha": "ee21a9ae3be286857ca3dbb7b187ba9d59d560bf", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=32b4b7f53e341be663438f69fd6cb2f909427188", "patch": "@@ -1450,6 +1450,7 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_pre);\n       NEXT_PASS (pass_sink_code);\n       NEXT_PASS (pass_asan);\n+      NEXT_PASS (pass_tsan);\n       NEXT_PASS (pass_tree_loop);\n \t{\n \t  struct opt_pass **p = &pass_tree_loop.pass.sub;\n@@ -1556,6 +1557,7 @@ init_optimization_passes (void)\n     }\n   NEXT_PASS (pass_lower_complex_O0);\n   NEXT_PASS (pass_asan_O0);\n+  NEXT_PASS (pass_tsan_O0);\n   NEXT_PASS (pass_cleanup_eh);\n   NEXT_PASS (pass_lower_resx);\n   NEXT_PASS (pass_nrv);"}, {"sha": "28518f3a97711fd69e06031d418ff5af1dab40cb", "filename": "gcc/sanitizer.def", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2Fsanitizer.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2Fsanitizer.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanitizer.def?ref=32b4b7f53e341be663438f69fd6cb2f909427188", "patch": "@@ -0,0 +1,28 @@\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_INIT, \"__tsan_init\", \n+\t\t      BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_FUNC_ENTRY, \"__tsan_func_entry\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_FUNC_EXIT, \"__tsan_func_exit\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_VPTR_UPDATE, \"__tsan_vptr_update\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_READ_1, \"__tsan_read1\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_READ_2, \"__tsan_read2\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_READ_4, \"__tsan_read4\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_READ_8, \"__tsan_read8\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_READ_16, \"__tsan_read16\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_WRITE_1, \"__tsan_write1\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_WRITE_2, \"__tsan_write2\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_WRITE_4, \"__tsan_write4\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_WRITE_8, \"__tsan_write8\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_WRITE_16, \"__tsan_write16\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)"}, {"sha": "d9d11270d7c47b96ae8f7dc8e41a1a26374de8a1", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=32b4b7f53e341be663438f69fd6cb2f909427188", "patch": "@@ -73,6 +73,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"alloc-pool.h\"\n #include \"tree-mudflap.h\"\n #include \"asan.h\"\n+#include \"tsan.h\"\n #include \"gimple.h\"\n #include \"tree-ssa-alias.h\"\n #include \"plugin.h\"\n@@ -575,6 +576,9 @@ compile_file (void)\n       if (flag_asan)\n         asan_finish_file ();\n \n+      if (flag_tsan)\n+\ttsan_finish_file ();\n+\n       output_shared_constant_pool ();\n       output_object_blocks ();\n       finish_tm_clone_pairs ();"}, {"sha": "7581cf347d8e32623d9d021875ef22601f006d99", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=32b4b7f53e341be663438f69fd6cb2f909427188", "patch": "@@ -261,6 +261,8 @@ extern struct gimple_opt_pass pass_mudflap_1;\n extern struct gimple_opt_pass pass_mudflap_2;\n extern struct gimple_opt_pass pass_asan;\n extern struct gimple_opt_pass pass_asan_O0;\n+extern struct gimple_opt_pass pass_tsan;\n+extern struct gimple_opt_pass pass_tsan_O0;\n extern struct gimple_opt_pass pass_lower_cf;\n extern struct gimple_opt_pass pass_refactor_eh;\n extern struct gimple_opt_pass pass_lower_eh;"}, {"sha": "8660b87addd6b44f79226fd78eba2bfb624a4722", "filename": "gcc/tsan.c", "status": "added", "additions": 405, "deletions": 0, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2Ftsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2Ftsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsan.c?ref=32b4b7f53e341be663438f69fd6cb2f909427188", "patch": "@@ -0,0 +1,405 @@\n+/* GCC instrumentation plugin for ThreadSanitizer.\n+   Copyright (C) 2011, 2012 Free Software Foundation, Inc.\n+   Contributed by Dmitry Vyukov <dvyukov@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"intl.h\"\n+#include \"tm.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"function.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-iterator.h\"\n+#include \"langhooks.h\"\n+#include \"output.h\"\n+#include \"options.h\"\n+#include \"target.h\"\n+#include \"cgraph.h\"\n+#include \"diagnostic.h\"\n+\n+/* Number of instrumented memory accesses in the current function.  */\n+\n+/* Builds the following decl\n+   void __tsan_read/writeX (void *addr);  */\n+\n+static tree\n+get_memory_access_decl (bool is_write, unsigned size)\n+{\n+  enum built_in_function fcode;\n+\n+  if (size <= 1)\n+    fcode = is_write ? BUILT_IN_TSAN_WRITE_1\n+\t\t     : BUILT_IN_TSAN_READ_1;\n+  else if (size <= 3)\n+    fcode = is_write ? BUILT_IN_TSAN_WRITE_2\n+\t\t     : BUILT_IN_TSAN_READ_2;\n+  else if (size <= 7)\n+    fcode = is_write ? BUILT_IN_TSAN_WRITE_4\n+\t\t     : BUILT_IN_TSAN_READ_4;\n+  else if (size <= 15)\n+    fcode = is_write ? BUILT_IN_TSAN_WRITE_8\n+\t\t     : BUILT_IN_TSAN_READ_8;\n+  else\n+    fcode = is_write ? BUILT_IN_TSAN_WRITE_16\n+\t\t     : BUILT_IN_TSAN_READ_16;\n+\n+  return builtin_decl_implicit (fcode);\n+}\n+\n+/* Check as to whether EXPR refers to a store to vptr.  */\n+\n+static tree\n+is_vptr_store (gimple stmt, tree expr, bool is_write)\n+{\n+  if (is_write == true\n+      && gimple_assign_single_p (stmt)\n+      && TREE_CODE (expr) == COMPONENT_REF)\n+    {\n+      tree field = TREE_OPERAND (expr, 1);\n+      if (TREE_CODE (field) == FIELD_DECL\n+\t  && DECL_VIRTUAL_P (field))\n+\treturn gimple_assign_rhs1 (stmt);\n+    }\n+  return NULL;\n+}\n+\n+/* Checks as to whether EXPR refers to constant var/field/param.\n+   Don't bother to instrument them.  */\n+\n+static bool\n+is_load_of_const_p (tree expr, bool is_write)\n+{\n+  if (is_write)\n+    return false;\n+  if (TREE_CODE (expr) == COMPONENT_REF)\n+    expr = TREE_OPERAND (expr, 1);\n+  if (TREE_CODE (expr) == VAR_DECL\n+      || TREE_CODE (expr) == PARM_DECL\n+      || TREE_CODE (expr) == FIELD_DECL)\n+    {\n+      if (TREE_READONLY (expr))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Instruments EXPR if needed. If any instrumentation is inserted,\n+ * return true. */\n+\n+static bool\n+instrument_expr (gimple_stmt_iterator gsi, tree expr, bool is_write)\n+{\n+  enum tree_code tcode;\n+  tree base, rhs, expr_type, expr_ptr, builtin_decl;\n+  basic_block bb;\n+  HOST_WIDE_INT size;\n+  gimple stmt, g;\n+  location_t loc;\n+\n+  base = get_base_address (expr);\n+  if (base == NULL_TREE\n+      || TREE_CODE (base) == SSA_NAME\n+      || TREE_CODE (base) == STRING_CST)\n+    return false;\n+\n+  tcode = TREE_CODE (expr);\n+\n+  /* Below are things we do not instrument\n+     (no possibility of races or not implemented yet).  */\n+  if (/* Compiler-emitted artificial variables.  */\n+      (DECL_P (expr) && DECL_ARTIFICIAL (expr))\n+      /* The var does not live in memory -> no possibility of races.  */\n+      || (tcode == VAR_DECL\n+\t  && !TREE_ADDRESSABLE (expr)\n+\t  && TREE_STATIC (expr) == 0)\n+      /* Not implemented.  */\n+      || TREE_CODE (TREE_TYPE (expr)) == RECORD_TYPE\n+      /* Not implemented.  */\n+      || tcode == CONSTRUCTOR\n+      /* Not implemented.  */\n+      || tcode == PARM_DECL\n+      /* Load of a const variable/parameter/field.  */\n+      || is_load_of_const_p (expr, is_write))\n+    return false;\n+\n+  size = int_size_in_bytes (TREE_TYPE (expr));\n+  if (size == -1)\n+    return false;\n+\n+  /* For now just avoid instrumenting bit field acceses.\n+     TODO: handle bit-fields as if touching the whole field.  */\n+  HOST_WIDE_INT bitsize, bitpos;\n+  tree offset;\n+  enum machine_mode mode;\n+  int volatilep = 0, unsignedp = 0;\n+  get_inner_reference (expr, &bitsize, &bitpos, &offset,\n+\t\t       &mode, &unsignedp, &volatilep, false);\n+  if (bitpos % (size * BITS_PER_UNIT)\n+      || bitsize != size * BITS_PER_UNIT)\n+    return false;\n+\n+  /* TODO: handle other case: ARRAY_RANGE_REF. */\n+  if (tcode != ARRAY_REF\n+      && tcode != VAR_DECL\n+      && tcode != COMPONENT_REF\n+      && tcode != INDIRECT_REF\n+      && tcode != MEM_REF)\n+    return false;\n+\n+  stmt = gsi_stmt (gsi);\n+  loc = gimple_location (stmt);\n+  rhs = is_vptr_store (stmt, expr, is_write);\n+  gcc_checking_assert (rhs != NULL || is_gimple_addressable (expr));\n+  expr_ptr = build_fold_addr_expr (unshare_expr (expr));\n+  if (rhs == NULL)\n+    {\n+      expr_type = TREE_TYPE (expr);\n+      while (TREE_CODE (expr_type) == ARRAY_TYPE)\n+\texpr_type = TREE_TYPE (expr_type);\n+      size = int_size_in_bytes (expr_type);\n+      g = gimple_build_call (get_memory_access_decl (is_write, size),\n+\t\t\t     1, expr_ptr);\n+    }\n+  else\n+    {\n+      builtin_decl = builtin_decl_implicit (BUILT_IN_TSAN_VPTR_UPDATE);\n+      g = gimple_build_call (builtin_decl, 1, expr_ptr);\n+    }\n+  gimple_set_location (g, loc);\n+  /* Instrumentation for assignment of a function result\n+     must be inserted after the call.  Instrumentation for\n+     reads of function arguments must be inserted before the call.\n+     That's because the call can contain synchronization.  */\n+  if (is_gimple_call (stmt) && is_write)\n+    {\n+      /* If the call can throw, it must be the last stmt in\n+\t a basic block, so the instrumented stmts need to be\n+\t inserted in successor bbs. */\n+      if (is_ctrl_altering_stmt (stmt))\n+\t{\n+\t  edge e;\n+\n+\t  bb = gsi_bb (gsi);\n+\t  e = find_fallthru_edge (bb->succs);\n+\t  if (e)\n+\t    gsi_insert_seq_on_edge_immediate (e, g);\n+\t}\n+      else\n+\tgsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+    }\n+  else\n+    gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\n+  return true;\n+}\n+\n+/* Instruments the gimple pointed to by GSI. Return\n+ * true if func entry/exit should be instrumented. */\n+\n+static bool\n+instrument_gimple (gimple_stmt_iterator gsi)\n+{\n+  gimple stmt;\n+  tree rhs, lhs;\n+  bool instrumented = false;\n+\n+  stmt = gsi_stmt (gsi);\n+  if (is_gimple_call (stmt)\n+      && (gimple_call_fndecl (stmt)\n+\t  != builtin_decl_implicit (BUILT_IN_TSAN_INIT)))\n+    return true;\n+  else if (is_gimple_assign (stmt))\n+    {\n+      if (gimple_store_p (stmt))\n+\t{\n+\t  lhs = gimple_assign_lhs (stmt);\n+\t  instrumented = instrument_expr (gsi, lhs, true);\n+\t}\n+      if (gimple_assign_load_p (stmt))\n+\t{\n+\t  rhs = gimple_assign_rhs1 (stmt);\n+\t  instrumented = instrument_expr (gsi, rhs, false);\n+\t}\n+    }\n+  return instrumented;\n+}\n+\n+/* Instruments all interesting memory accesses in the current function.\n+ * Return true if func entry/exit should be instrumented. */\n+\n+static bool\n+instrument_memory_accesses (void)\n+{\n+  basic_block bb;\n+  gimple_stmt_iterator gsi;\n+  bool fentry_exit_instrument = false;\n+\n+  FOR_EACH_BB (bb)\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      fentry_exit_instrument |= instrument_gimple (gsi);\n+  return fentry_exit_instrument;\n+}\n+\n+/* Instruments function entry.  */\n+\n+static void\n+instrument_func_entry (void)\n+{\n+  basic_block succ_bb;\n+  gimple_stmt_iterator gsi;\n+  tree ret_addr, builtin_decl;\n+  gimple g;\n+\n+  succ_bb = single_succ (ENTRY_BLOCK_PTR);\n+  gsi = gsi_after_labels (succ_bb);\n+\n+  builtin_decl = builtin_decl_implicit (BUILT_IN_RETURN_ADDRESS);\n+  g = gimple_build_call (builtin_decl, 1, integer_zero_node);\n+  ret_addr = make_ssa_name (ptr_type_node, NULL);\n+  gimple_call_set_lhs (g, ret_addr);\n+  gimple_set_location (g, cfun->function_start_locus);\n+  gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\n+  builtin_decl =  builtin_decl_implicit (BUILT_IN_TSAN_FUNC_ENTRY);\n+  g = gimple_build_call (builtin_decl, 1, ret_addr);\n+  gimple_set_location (g, cfun->function_start_locus);\n+  gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+}\n+\n+/* Instruments function exits.  */\n+\n+static void\n+instrument_func_exit (void)\n+{\n+  location_t loc;\n+  basic_block exit_bb;\n+  gimple_stmt_iterator gsi;\n+  gimple stmt, g;\n+  tree builtin_decl;\n+  edge e;\n+  edge_iterator ei;\n+\n+  /* Find all function exits.  */\n+  exit_bb = EXIT_BLOCK_PTR;\n+  FOR_EACH_EDGE (e, ei, exit_bb->preds)\n+    {\n+      gsi = gsi_last_bb (e->src);\n+      stmt = gsi_stmt (gsi);\n+      gcc_assert (gimple_code (stmt) == GIMPLE_RETURN);\n+      loc = gimple_location (stmt);\n+      builtin_decl = builtin_decl_implicit (BUILT_IN_TSAN_FUNC_EXIT);\n+      g = gimple_build_call (builtin_decl, 0);\n+      gimple_set_location (g, loc);\n+      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+    }\n+}\n+\n+/* ThreadSanitizer instrumentation pass.  */\n+\n+static unsigned\n+tsan_pass (void)\n+{\n+  if (instrument_memory_accesses ())\n+    {\n+      instrument_func_entry ();\n+      instrument_func_exit ();\n+    }\n+  return 0;\n+}\n+\n+/* The pass's gate.  */\n+\n+static bool\n+tsan_gate (void)\n+{\n+  return flag_tsan != 0\n+\t && builtin_decl_implicit_p (BUILT_IN_TSAN_INIT);\n+}\n+\n+/* Inserts __tsan_init () into the list of CTORs.  */\n+\n+void\n+tsan_finish_file (void)\n+{\n+  tree ctor_statements;\n+  tree init_decl;\n+\n+  ctor_statements = NULL_TREE;\n+  init_decl = builtin_decl_implicit (BUILT_IN_TSAN_INIT);\n+  append_to_statement_list (build_call_expr (init_decl, 0),\n+\t\t\t    &ctor_statements);\n+  cgraph_build_static_cdtor ('I', ctor_statements,\n+\t\t\t     MAX_RESERVED_INIT_PRIORITY - 1);\n+}\n+\n+/* The pass descriptor.  */\n+\n+struct gimple_opt_pass pass_tsan =\n+{\n+ {\n+  GIMPLE_PASS,\n+  \"tsan\",\t\t\t\t/* name  */\n+  OPTGROUP_NONE,\t\t\t/* optinfo_flags */\n+  tsan_gate,\t\t\t\t/* gate  */\n+  tsan_pass,\t\t\t\t/* execute  */\n+  NULL,\t\t\t\t\t/* sub  */\n+  NULL,\t\t\t\t\t/* next  */\n+  0,\t\t\t\t\t/* static_pass_number  */\n+  TV_NONE,\t\t\t\t/* tv_id  */\n+  PROP_ssa | PROP_cfg,\t\t\t/* properties_required  */\n+  0,\t\t\t\t\t/* properties_provided  */\n+  0,\t\t\t\t\t/* properties_destroyed  */\n+  0,\t\t\t\t\t/* todo_flags_start  */\n+  TODO_verify_all | TODO_update_ssa\n+  | TODO_update_address_taken\t\t/* todo_flags_finish  */\n+ }\n+};\n+\n+static bool\n+tsan_gate_O0 (void)\n+{\n+  return flag_tsan != 0 && !optimize\n+\t && builtin_decl_implicit_p (BUILT_IN_TSAN_INIT);\n+}\n+\n+struct gimple_opt_pass pass_tsan_O0 =\n+{\n+ {\n+  GIMPLE_PASS,\n+  \"tsan0\",\t\t\t\t/* name  */\n+  OPTGROUP_NONE,\t\t\t/* optinfo_flags */\n+  tsan_gate_O0,\t\t\t\t/* gate  */\n+  tsan_pass,\t\t\t\t/* execute  */\n+  NULL,\t\t\t\t\t/* sub  */\n+  NULL,\t\t\t\t\t/* next  */\n+  0,\t\t\t\t\t/* static_pass_number  */\n+  TV_NONE,\t\t\t\t/* tv_id  */\n+  PROP_ssa | PROP_cfg,\t\t\t/* properties_required  */\n+  0,\t\t\t\t\t/* properties_provided  */\n+  0,\t\t\t\t\t/* properties_destroyed  */\n+  0,\t\t\t\t\t/* todo_flags_start  */\n+  TODO_verify_all | TODO_update_ssa\n+  | TODO_update_address_taken\t\t/* todo_flags_finish  */\n+ }\n+};"}, {"sha": "cafc980962e74e4576a826f3dbd0af582606ce5e", "filename": "gcc/tsan.h", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2Ftsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32b4b7f53e341be663438f69fd6cb2f909427188/gcc%2Ftsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsan.h?ref=32b4b7f53e341be663438f69fd6cb2f909427188", "patch": "@@ -0,0 +1,26 @@\n+/* ThreadSanitizer, a data race detector.\n+   Copyright (C) 2011, 2012 Free Software Foundation, Inc.\n+   Contributed by Dmitry Vyukov <dvyukov@google.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef TREE_TSAN\n+#define TREE_TSAN\n+\n+extern void tsan_finish_file (void);\n+\n+#endif /* TREE_TSAN */"}]}