{"sha": "b9422b69c4574ea53d1a5fdbc90de3935589e502", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk0MjJiNjljNDU3NGVhNTNkMWE1ZmRiYzkwZGUzOTM1NTg5ZTUwMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-02-20T20:56:53Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-02-20T20:56:53Z"}, "message": "toplev.c (flag_sched2_use_superblocks, [...]): New global variables.\n\n\t* toplev.c (flag_sched2_use_superblocks, flag_sched2_use_traces):  New global variables.\n\t(lang_independent_options):  Add -fsched2-use-superblocks -fsced2-use-traces.\n\t(rest_of_compilation): Deal with it.\n\t* invoke.texi (-fsched2-use-traces, fsched2-use-superblocks):  Declare.\n\t* flags.h (flag_sched2_use_superblocks, flag_sched2_use_traces): Declare.\n\t* rtl.h (reg_to_stack):  Update prototype.\n\t* reg-stack.c (reg_to_stack): Return when something has changed;\n\tupdate liveness when executing after superblock scheduling.\n\n\t* combine.c (simplify_shift_const):  Simplify few special cases\n\tinto constants.\n\nFrom-SVN: r63183", "tree": {"sha": "2415e41e359f1d67f528163fbed9de0eeb20bffe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2415e41e359f1d67f528163fbed9de0eeb20bffe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9422b69c4574ea53d1a5fdbc90de3935589e502", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9422b69c4574ea53d1a5fdbc90de3935589e502", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9422b69c4574ea53d1a5fdbc90de3935589e502", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9422b69c4574ea53d1a5fdbc90de3935589e502/comments", "author": null, "committer": null, "parents": [{"sha": "e182f0a397a1b985f86641787df37d12b1d00aa3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e182f0a397a1b985f86641787df37d12b1d00aa3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e182f0a397a1b985f86641787df37d12b1d00aa3"}], "stats": {"total": 128, "additions": 118, "deletions": 10}, "files": [{"sha": "4d708ef4bdf9f31a73ed27d173b4323d1b1f4fbf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9422b69c4574ea53d1a5fdbc90de3935589e502/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9422b69c4574ea53d1a5fdbc90de3935589e502/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b9422b69c4574ea53d1a5fdbc90de3935589e502", "patch": "@@ -1,3 +1,17 @@\n+Thu Feb 20 21:41:19 CET 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* toplev.c (flag_sched2_use_superblocks, flag_sched2_use_traces):  New global variables.\n+\t(lang_independent_options):  Add -fsched2-use-superblocks -fsced2-use-traces.\n+\t(rest_of_compilation): Deal with it.\n+\t* invoke.texi (-fsched2-use-traces, fsched2-use-superblocks):  Declare.\n+\t* flags.h (flag_sched2_use_superblocks, flag_sched2_use_traces): Declare.\n+\t* rtl.h (reg_to_stack):  Update prototype.\n+\t* reg-stack.c (reg_to_stack): Return when something has changed;\n+\tupdate liveness when executing after superblock scheduling.\n+\n+\t* combine.c (simplify_shift_const):  Simplify few special cases\n+\tinto constants.\n+\n 2003-02-20  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/rs6000.md: (attr \"type\"): Add fast_compare."}, {"sha": "7792537d34b4e35e50099c4f4cb096fe163a18ba", "filename": "gcc/combine.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9422b69c4574ea53d1a5fdbc90de3935589e502/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9422b69c4574ea53d1a5fdbc90de3935589e502/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=b9422b69c4574ea53d1a5fdbc90de3935589e502", "patch": "@@ -9431,6 +9431,16 @@ simplify_shift_const (x, code, result_mode, varop, orig_count)\n \t      == 0))\n \tcode = LSHIFTRT;\n \n+      if (code == LSHIFTRT\n+\t  && GET_MODE_BITSIZE (shift_mode) <= HOST_BITS_PER_WIDE_INT\n+\t  && !(nonzero_bits (varop, shift_mode) >> count))\n+\treturn const0_rtx;\n+      if (code == ASHIFT\n+\t  && GET_MODE_BITSIZE (shift_mode) <= HOST_BITS_PER_WIDE_INT\n+\t  && !((nonzero_bits (varop, shift_mode) << count)\n+\t       & GET_MODE_MASK (shift_mode)))\n+\treturn const0_rtx;\n+\n       switch (GET_CODE (varop))\n \t{\n \tcase SIGN_EXTEND:"}, {"sha": "f47c51ec6661f06c498404e04a120305b7b3e32c", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9422b69c4574ea53d1a5fdbc90de3935589e502/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9422b69c4574ea53d1a5fdbc90de3935589e502/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=b9422b69c4574ea53d1a5fdbc90de3935589e502", "patch": "@@ -287,7 +287,8 @@ in the following sections.\n -frerun-cse-after-loop  -frerun-loop-opt @gol\n -fschedule-insns  -fschedule-insns2 @gol\n -fno-sched-interblock  -fno-sched-spec  -fsched-spec-load @gol\n--fsched-spec-load-dangerous  -fsignaling-nans @gol\n+-fsched-spec-load-dangerous  -fsched2-use-superblocks @gol\n+-fsched2-use-traces  -fsignaling-nans @gol\n -fsingle-precision-constant  -fssa -fssa-ccp -fssa-dce @gol\n -fstrength-reduce  -fstrict-aliasing  -ftracer -fthread-jumps @gol\n -funit-at-a-time -funroll-all-loops  -funroll-loops  -funswitch-loops @gol\n@@ -3895,6 +3896,30 @@ Allow speculative motion of more load instructions.  This only makes\n sense when scheduling before register allocation, i.e.@: with\n @option{-fschedule-insns} or at @option{-O2} or higher.\n \n+@item -fsched2-use-superblocks\n+@opindex fsched2-use-superblocks\n+When schedulilng after register allocation, do use superblock scheduling\n+algorithm.  Superblock scheduling allows motion acress basic block boundaries\n+resulting on faster schedules.  This option is experimental, as not all machine\n+descriptions used by GCC model the CPU closely enought to avoid unreliable\n+results from the algorithm. \n+\n+This only makes sense when scheduling after register allocation, i.e.@: with\n+@option{-fschedule-insns2} or at @option{-O2} or higher.\n+\n+@item -fsched2-use-traces\n+@opindex fsched2-use-traces\n+Use @option{-fsched2-use-superblocks} algorithm when scheduling after register\n+allocation and additionally perform code duplication in order to increase the\n+size of superblocks using tracer pass.  See @option{-ftracer} for details on\n+trace formation.\n+\n+This mode should produce faster but singificantly longer programs.  Also\n+without @code{-fbranch-probabilities} the traces constructed may not match the\n+reality and hurt the performance.  This only makes\n+sense when scheduling after register allocation, i.e.@: with\n+@option{-fschedule-insns2} or at @option{-O2} or higher.\n+\n @item -fcaller-saves\n @opindex fcaller-saves\n Enable values to be allocated in registers that will be clobbered by"}, {"sha": "559f70fd6b84a56ec4a18e0d4ee2a9b5ae35a030", "filename": "gcc/flags.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9422b69c4574ea53d1a5fdbc90de3935589e502/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9422b69c4574ea53d1a5fdbc90de3935589e502/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=b9422b69c4574ea53d1a5fdbc90de3935589e502", "patch": "@@ -416,6 +416,8 @@ extern int flag_shared_data;\n \n extern int flag_schedule_insns;\n extern int flag_schedule_insns_after_reload;\n+extern int flag_sched2_use_superblocks;\n+extern int flag_sched2_use_traces;\n \n /* The following flags have effect only for scheduling before register\n    allocation:"}, {"sha": "f8f4b3144bfe836f8dfe08e47902df601564feac", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9422b69c4574ea53d1a5fdbc90de3935589e502/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9422b69c4574ea53d1a5fdbc90de3935589e502/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=b9422b69c4574ea53d1a5fdbc90de3935589e502", "patch": "@@ -416,7 +416,7 @@ pop_stack (regstack, regno)\n    code duplication created when the converter inserts pop insns on\n    the edges.  */\n \n-void\n+bool\n reg_to_stack (first, file)\n      rtx first;\n      FILE *file;\n@@ -437,11 +437,15 @@ reg_to_stack (first, file)\n     if (regs_ever_live[i])\n       break;\n   if (i > LAST_STACK_REG)\n-    return;\n+    return false;\n \n   /* Ok, floating point instructions exist.  If not optimizing,\n-     build the CFG and run life analysis.  */\n-  if (!optimize)\n+     build the CFG and run life analysis.  \n+     Also need to rebuild life when superblock scheduling is done\n+     as it don't update liveness yet.  */\n+  if (!optimize\n+      || (flag_sched2_use_superblocks\n+\t  && flag_schedule_insns_after_reload))\n     {\n       count_or_remove_death_notes (NULL, 1);\n       life_analysis (first, file, PROP_DEATH_NOTES);\n@@ -498,6 +502,7 @@ reg_to_stack (first, file)\n   convert_regs (file);\n \n   free_aux_for_blocks ();\n+  return true;\n }\n \f\n /* Check PAT, which is in INSN, for LABEL_REFs.  Add INSN to the"}, {"sha": "ff6c581023231a30574d54f7940cae7be88247fd", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9422b69c4574ea53d1a5fdbc90de3935589e502/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9422b69c4574ea53d1a5fdbc90de3935589e502/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=b9422b69c4574ea53d1a5fdbc90de3935589e502", "patch": "@@ -2167,7 +2167,7 @@ extern void create_profiler\t\tPARAMS ((void));\n \n /* In reg-stack.c */\n #ifdef BUFSIZ\n-extern void reg_to_stack\t\tPARAMS ((rtx, FILE *));\n+extern bool reg_to_stack\t\tPARAMS ((rtx, FILE *));\n #endif\n \n /* In fold-const.c */"}, {"sha": "ffd3760a6a687ddd90042bec1e483d72d652ba5c", "filename": "gcc/toplev.c", "status": "modified", "additions": 56, "deletions": 4, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9422b69c4574ea53d1a5fdbc90de3935589e502/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9422b69c4574ea53d1a5fdbc90de3935589e502/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=b9422b69c4574ea53d1a5fdbc90de3935589e502", "patch": "@@ -254,9 +254,9 @@ enum dump_file_index\n   DFI_peephole2,\n   DFI_rnreg,\n   DFI_ce3,\n+  DFI_bbro,\n   DFI_sched2,\n   DFI_stack,\n-  DFI_bbro,\n   DFI_mach,\n   DFI_dbr,\n   DFI_MAX\n@@ -305,9 +305,9 @@ static struct dump_file_info dump_file[DFI_MAX] =\n   { \"peephole2\", 'z', 1, 0, 0 },\n   { \"rnreg\",\t'n', 1, 0, 0 },\n   { \"ce3\",\t'E', 1, 0, 0 },\n+  { \"bbro\",\t'B', 1, 0, 0 },\n   { \"sched2\",\t'R', 1, 0, 0 },\n   { \"stack\",\t'k', 1, 0, 0 },\n-  { \"bbro\",\t'B', 1, 0, 0 },\n   { \"mach\",\t'M', 1, 0, 0 },\n   { \"dbr\",\t'd', 0, 0, 0 },\n };\n@@ -745,6 +745,13 @@ int flag_pedantic_errors = 0;\n int flag_schedule_insns = 0;\n int flag_schedule_insns_after_reload = 0;\n \n+/* When flag_schedule_insns_after_reload is set, use EBB scheduler.  */\n+int flag_sched2_use_superblocks = 0;\n+\n+/* When flag_schedule_insns_after_reload is set, construct traces and EBB\n+   scheduler.  */\n+int flag_sched2_use_traces = 0;\n+\n /* The following flags have effect only for scheduling before register\n    allocation:\n \n@@ -1079,6 +1086,10 @@ static const lang_independent_options f_options[] =\n    N_(\"Allow speculative motion of some loads\") },\n   {\"sched-spec-load-dangerous\",&flag_schedule_speculative_load_dangerous, 1,\n    N_(\"Allow speculative motion of more loads\") },\n+  {\"sched2-use-superblocks\", &flag_sched2_use_superblocks, 1,\n+   N_(\"If scheduling post reload, do superblock sheduling\") },\n+  {\"sched2-use-traces\", &flag_sched2_use_traces, 1,\n+   N_(\"If scheduling post reload, do trace sheduling\") },\n   {\"branch-count-reg\",&flag_branch_on_count_reg, 1,\n    N_(\"Replace add,compare,branch with branch on count reg\") },\n   {\"pic\", &flag_pic, 1,\n@@ -3490,6 +3501,28 @@ rest_of_compilation (decl)\n     split_all_insns (1);\n #endif\n \n+  if (optimize > 0)\n+    {\n+      timevar_push (TV_REORDER_BLOCKS);\n+      open_dump_file (DFI_bbro, decl);\n+\n+      /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n+\t splitting possibly introduced more crossjumping opportunities. */\n+      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE\n+\t\t   | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0));\n+\n+      if (flag_sched2_use_traces && flag_schedule_insns_after_reload)\n+        tracer ();\n+      if (flag_reorder_blocks)\n+\treorder_basic_blocks ();\n+      if (flag_reorder_blocks\n+\t  || (flag_sched2_use_traces && flag_schedule_insns_after_reload))\n+\t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_UPDATE_LIFE);\n+\n+      close_dump_file (DFI_bbro, print_rtl_with_bb, insns);\n+      timevar_pop (TV_REORDER_BLOCKS);\n+    }\n+\n #ifdef INSN_SCHEDULING\n   if (optimize > 0 && flag_schedule_insns_after_reload)\n     {\n@@ -3501,7 +3534,16 @@ rest_of_compilation (decl)\n \n       split_all_insns (1);\n \n-      schedule_insns (rtl_dump_file);\n+      if (flag_sched2_use_superblocks || flag_sched2_use_traces)\n+\t{\n+\t  schedule_ebbs (rtl_dump_file);\n+\t  /* No liveness updating code yet, but it should be easy to do.\n+\t     reg-stack recompute the liveness when needed for now.  */\n+\t  count_or_remove_death_notes (NULL, 1);\n+\t  cleanup_cfg (CLEANUP_EXPENSIVE);\n+\t}\n+      else\n+        schedule_insns (rtl_dump_file);\n \n       close_dump_file (DFI_sched2, print_rtl_with_bb, insns);\n       timevar_pop (TV_SCHED2);\n@@ -3519,7 +3561,16 @@ rest_of_compilation (decl)\n   timevar_push (TV_REG_STACK);\n   open_dump_file (DFI_stack, decl);\n \n-  reg_to_stack (insns, rtl_dump_file);\n+  if (reg_to_stack (insns, rtl_dump_file) && optimize)\n+    {\n+      if (cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK\n+\t\t       | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0))\n+\t  && flag_reorder_blocks)\n+\t{\n+\t  reorder_basic_blocks ();\n+\t  cleanup_cfg (CLEANUP_EXPENSIVE);\n+\t}\n+    }\n \n   close_dump_file (DFI_stack, print_rtl_with_bb, insns);\n   timevar_pop (TV_REG_STACK);\n@@ -4904,6 +4955,7 @@ parse_options_and_default_flags (argc, argv)\n       flag_cse_skip_blocks = 1;\n       flag_gcse = 1;\n       flag_expensive_optimizations = 1;\n+      flag_unit_at_a_time = 1;\n       flag_strength_reduce = 1;\n       flag_rerun_cse_after_loop = 1;\n       flag_rerun_loop_opt = 1;"}]}