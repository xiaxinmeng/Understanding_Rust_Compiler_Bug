{"sha": "572f38e4b24c395d3841f9fb8939037885222e4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTcyZjM4ZTRiMjRjMzk1ZDM4NDFmOWZiODkzOTAzNzg4NTIyMmU0ZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-11-20T15:59:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-11-20T15:59:01Z"}, "message": "[multiple changes]\n\n2014-11-20  Thomas Quinot  <quinot@adacore.com>\n\n\t* freeze.adb (Freeze_Entity): Do not reset Is_True_Constant\n\tfor aliased constant objects.\n\n2014-11-20  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_util.adb (Following_Address_Clause): Use new Name_Table\n\tboolean flag set by parser to avoid the search if there is no\n\taddress clause anywhere for the name.\n\t* namet.adb (Name_Enter): Initialize Boolean_Info flag\n\t(Name_Find): ditto (Reinitialize): ditto (Get_Name_Table_Boolean):\n\tNew function (Set_Name_Table_Boolean): New procedure\n\t* namet.ads: Add and document new Boolean field in name table\n\t(Get_Name_Table_Boolean): New function.\n\t(Set_Name_Table_Boolean): New procedure.\n\t* par-ch13.adb (P_Representation_Clause): Set Name_Table boolean\n\tflag for an identifier name if we detect an address clause or\n\tuse-at clause for the identifier.\n\t* sem_ch3.adb (Analyze_Object_Declaration): Remove comment about\n\tFollowing_Address_Clause since this function is now optimized\n\tand is not a performance concern.\n\t* sem_prag.adb (Analyze_Pragma, case Elaborate): In SPARK\n\tmode, pragma Elaborate is now allowed, but does not suppress\n\telaboration checking.\n\nFrom-SVN: r217882", "tree": {"sha": "fc1b4c64b1b25a5f52510966575b600e26785069", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc1b4c64b1b25a5f52510966575b600e26785069"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/572f38e4b24c395d3841f9fb8939037885222e4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/572f38e4b24c395d3841f9fb8939037885222e4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/572f38e4b24c395d3841f9fb8939037885222e4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/572f38e4b24c395d3841f9fb8939037885222e4e/comments", "author": null, "committer": null, "parents": [{"sha": "28eccd34faa42af5012ac8a3002e022131fb0b4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28eccd34faa42af5012ac8a3002e022131fb0b4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28eccd34faa42af5012ac8a3002e022131fb0b4f"}], "stats": {"total": 183, "additions": 145, "deletions": 38}, "files": [{"sha": "7fba4d06016a6d477d713ecfb05d10fb60a263a7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/572f38e4b24c395d3841f9fb8939037885222e4e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/572f38e4b24c395d3841f9fb8939037885222e4e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=572f38e4b24c395d3841f9fb8939037885222e4e", "patch": "@@ -1,3 +1,29 @@\n+2014-11-20  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* freeze.adb (Freeze_Entity): Do not reset Is_True_Constant\n+\tfor aliased constant objects.\n+\n+2014-11-20  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_util.adb (Following_Address_Clause): Use new Name_Table\n+\tboolean flag set by parser to avoid the search if there is no\n+\taddress clause anywhere for the name.\n+\t* namet.adb (Name_Enter): Initialize Boolean_Info flag\n+\t(Name_Find): ditto (Reinitialize): ditto (Get_Name_Table_Boolean):\n+\tNew function (Set_Name_Table_Boolean): New procedure\n+\t* namet.ads: Add and document new Boolean field in name table\n+\t(Get_Name_Table_Boolean): New function.\n+\t(Set_Name_Table_Boolean): New procedure.\n+\t* par-ch13.adb (P_Representation_Clause): Set Name_Table boolean\n+\tflag for an identifier name if we detect an address clause or\n+\tuse-at clause for the identifier.\n+\t* sem_ch3.adb (Analyze_Object_Declaration): Remove comment about\n+\tFollowing_Address_Clause since this function is now optimized\n+\tand is not a performance concern.\n+\t* sem_prag.adb (Analyze_Pragma, case Elaborate): In SPARK\n+\tmode, pragma Elaborate is now allowed, but does not suppress\n+\telaboration checking.\n+\n 2014-11-20  Jerome Lambourg  <lambourg@adacore.com>\n \n \t* gcc-interface/Makefile.in: Add some support for VxWorks7."}, {"sha": "381002255c0bdb7429933f2672b3bc878a12206a", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/572f38e4b24c395d3841f9fb8939037885222e4e/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/572f38e4b24c395d3841f9fb8939037885222e4e/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=572f38e4b24c395d3841f9fb8939037885222e4e", "patch": "@@ -2960,6 +2960,15 @@ package body Exp_Util is\n       --  Start of processing for Following_Address_Clause\n \n    begin\n+      --  If parser detected no address clause for the identifier in question,\n+      --  then then answer is a quick NO, without the need for a search.\n+\n+      if not Get_Name_Table_Boolean (Chars (Id)) then\n+         return Empty;\n+      end if;\n+\n+      --  Otherwise search current declarative unit\n+\n       Result := Check_Decls (Next (D));\n \n       if Present (Result) then"}, {"sha": "4765d8ee6936d2bb22a282d9f1f7b6158a7f90a9", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/572f38e4b24c395d3841f9fb8939037885222e4e/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/572f38e4b24c395d3841f9fb8939037885222e4e/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=572f38e4b24c395d3841f9fb8939037885222e4e", "patch": "@@ -4596,19 +4596,27 @@ package body Freeze is\n \n                Check_Address_Clause (E);\n \n-               --  Reset Is_True_Constant for aliased object. We consider that\n-               --  the fact that something is aliased may indicate that some\n-               --  funny business is going on, e.g. an aliased object is passed\n-               --  by reference to a procedure which captures the address of\n-               --  the object, which is later used to assign a new value. Such\n-               --  code is highly dubious, but we choose to make it \"work\" for\n-               --  aliased objects.\n+               --  Reset Is_True_Constant for non-constant aliased object. We\n+               --  consider that the fact that a non-constant object is aliased\n+               --  may indicate that some funny business is going on, e.g. an\n+               --  aliased object is passed by reference to a procedure which\n+               --  captures the address of the object, which is later used to\n+               --  assign a new value, even though the compiler thinks that\n+               --  it is not modified. Such code is highly dubious, but we\n+               --  choose to make it \"work\" for non-constant aliased objects.\n+               --  Note that we used to do this for all aliased objects,\n+               --  whether or not constant, but this caused anomalies down\n+               --  the line because we ended up with static objects that\n+               --  were not Is_True_Constant. Not resetting Is_True_Constant\n+               --  for (aliased) constant objects ensures that this anomaly\n+               --  never occurs.\n \n                --  However, we don't do that for internal entities. We figure\n                --  that if we deliberately set Is_True_Constant for an internal\n                --  entity, e.g. a dispatch table entry, then we mean it.\n \n-               if (Is_Aliased (E) or else Is_Aliased (Etype (E)))\n+               if Ekind (E) /= E_Constant\n+                 and then (Is_Aliased (E) or else Is_Aliased (Etype (E)))\n                  and then not Is_Internal_Name (Chars (E))\n                then\n                   Set_Is_True_Constant (E, False);"}, {"sha": "e6df9db610d6436eb2fc425452f1f91e934a1097", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/572f38e4b24c395d3841f9fb8939037885222e4e/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/572f38e4b24c395d3841f9fb8939037885222e4e/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=572f38e4b24c395d3841f9fb8939037885222e4e", "patch": "@@ -705,6 +705,16 @@ package body Namet is\n       end loop;\n    end Get_Name_String_And_Append;\n \n+   ----------------------------\n+   -- Get_Name_Table_Boolean --\n+   ----------------------------\n+\n+   function Get_Name_Table_Boolean (Id : Name_Id) return Boolean is\n+   begin\n+      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n+      return Name_Entries.Table (Id).Boolean_Info;\n+   end Get_Name_Table_Boolean;\n+\n    -------------------------\n    -- Get_Name_Table_Byte --\n    -------------------------\n@@ -923,6 +933,7 @@ package body Namet is\n           Name_Len              => Short (Name_Len),\n           Byte_Info             => 0,\n           Int_Info              => 0,\n+          Boolean_Info          => False,\n           Name_Has_No_Encodings => False,\n           Hash_Link             => No_Name));\n \n@@ -1025,7 +1036,8 @@ package body Namet is\n              Hash_Link             => No_Name,\n              Name_Has_No_Encodings => False,\n              Int_Info              => 0,\n-             Byte_Info             => 0));\n+             Byte_Info             => 0,\n+             Boolean_Info          => False));\n \n          --  Set corresponding string entry in the Name_Chars table\n \n@@ -1250,6 +1262,7 @@ package body Namet is\n              Name_Len              => 1,\n              Byte_Info             => 0,\n              Int_Info              => 0,\n+             Boolean_Info          => False,\n              Name_Has_No_Encodings => True,\n              Hash_Link             => No_Name));\n \n@@ -1287,6 +1300,16 @@ package body Namet is\n       Store_Encoded_Character (C);\n    end Set_Character_Literal_Name;\n \n+   ----------------------------\n+   -- Set_Name_Table_Boolean --\n+   ----------------------------\n+\n+   procedure Set_Name_Table_Boolean (Id : Name_Id; Val : Boolean) is\n+   begin\n+      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n+      Name_Entries.Table (Id).Boolean_Info := Val;\n+   end Set_Name_Table_Boolean;\n+\n    -------------------------\n    -- Set_Name_Table_Byte --\n    -------------------------"}, {"sha": "ad52122c5860c667905da34b734e1e0e0d71b704", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 44, "deletions": 15, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/572f38e4b24c395d3841f9fb8939037885222e4e/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/572f38e4b24c395d3841f9fb8939037885222e4e/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=572f38e4b24c395d3841f9fb8939037885222e4e", "patch": "@@ -115,14 +115,32 @@ package Namet is\n --  character lower case letters in the range a-z, and these names are created\n --  and initialized by the Initialize procedure.\n \n---  Two values, one of type Int and one of type Byte, are stored with each\n---  names table entry and subprograms are provided for setting and retrieving\n---  these associated values. The usage of these values is up to the client. In\n---  the compiler, the Int field is used to point to a chain of potentially\n---  visible entities (see Sem.Ch8 for details), and the Byte field is used to\n---  hold the Token_Type value for reserved words (see Sem for details). In the\n---  binder, the Byte field is unused, and the Int field is used in various\n---  ways depending on the name involved (see binder documentation).\n+--  Three values, one of type Int, one of type Byte, and one of type Boolean,\n+--  are stored with each names table entry and subprograms are provided for\n+--  setting and retrieving these associated values. The usage of these values\n+--  is up to the client:\n+\n+--    In the compiler we have the following uses:\n+\n+--      The Int field is used to point to a chain of potentially visible\n+--      entities (see Sem.Ch8 for details).\n+\n+--      The Byte field is used to hold the Token_Type value for reserved words\n+--      (see Sem for details).\n+\n+--      The Boolean field is used to mark address clauses to optimize the\n+--      performance of the Exp_Util.Following_Address_Clause function.\n+\n+--    In the binder, we have the following uses:\n+\n+--      The Int field is used in various ways depending on the name involved,\n+--      see binder documentation for details.\n+\n+--      The Byte and Boolean fields are unused.\n+\n+--  Note that the value of the Int and Byte fields are initialized to zero,\n+--  and the Boolean field is initialized to False, when a new Name table entry\n+--  is created.\n \n    Name_Buffer : String (1 .. 4 * Max_Line_Length);\n    --  This buffer is used to set the name to be stored in the table for the\n@@ -349,6 +367,9 @@ package Namet is\n    pragma Inline (Get_Name_Table_Info);\n    --  Fetches the Int value associated with the given name\n \n+   function Get_Name_Table_Boolean (Id : Name_Id) return Boolean;\n+   --  Fetches the Boolean value associated with the given name\n+\n    function Is_Operator_Name (Id : Name_Id) return Boolean;\n    --  Returns True if name given is of the form of an operator (that\n    --  is, it starts with an upper case O).\n@@ -386,12 +407,12 @@ package Namet is\n    function Name_Find return Name_Id;\n    --  Name_Find is called with a string stored in Name_Buffer whose length is\n    --  in Name_Len (i.e. the characters of the name are in subscript positions\n-   --  1 to Name_Len in Name_Buffer). It searches the names table to see if\n-   --  the string has already been stored. If so the Id of the existing entry\n-   --  is returned. Otherwise a new entry is created with its Name_Table_Info\n-   --  field set to zero. The contents of Name_Buffer and Name_Len are not\n-   --  modified by this call. Note that it is permissible for Name_Len to be\n-   --  set to zero to lookup the null name string.\n+   --  1 to Name_Len in Name_Buffer). It searches the names table to see if the\n+   --  string has already been stored. If so the Id of the existing entry is\n+   --  returned. Otherwise a new entry is created with its Name_Table_Info\n+   --  fields set to zero/false. The contents of Name_Buffer and Name_Len are\n+   --  not modified by this call. Note that it is permissible for Name_Len to\n+   --  be set to zero to lookup the null name string.\n \n    function Name_Enter return Name_Id;\n    --  Name_Enter has the same calling interface as Name_Find. The difference\n@@ -483,6 +504,9 @@ package Namet is\n    pragma Inline (Set_Name_Table_Byte);\n    --  Sets the Byte value associated with the given name\n \n+   procedure Set_Name_Table_Boolean (Id : Name_Id; Val : Boolean);\n+   --  Sets the Boolean value associated with the given name\n+\n    procedure Store_Encoded_Character (C : Char_Code);\n    --  Stores given character code at the end of Name_Buffer, updating the\n    --  value in Name_Len appropriately. Lower case letters and digits are\n@@ -620,6 +644,9 @@ private\n       Byte_Info : Byte;\n       --  Byte value associated with this name\n \n+      Boolean_Info : Boolean;\n+      --  Boolean value associated with the name\n+\n       Name_Has_No_Encodings : Boolean;\n       --  This flag is set True if the name entry is known not to contain any\n       --  special character encodings. This is used to speed up repeated calls\n@@ -631,13 +658,15 @@ private\n \n       Int_Info : Int;\n       --  Int Value associated with this name\n+\n    end record;\n \n    for Name_Entry use record\n       Name_Chars_Index      at  0 range 0 .. 31;\n       Name_Len              at  4 range 0 .. 15;\n       Byte_Info             at  6 range 0 .. 7;\n-      Name_Has_No_Encodings at  7 range 0 .. 7;\n+      Boolean_Info          at  7 range 0 .. 0;\n+      Name_Has_No_Encodings at  7 range 1 .. 7;\n       Hash_Link             at  8 range 0 .. 31;\n       Int_Info              at 12 range 0 .. 31;\n    end record;"}, {"sha": "0bbca4339357d71f4337b32ac195959a8860a80f", "filename": "gcc/ada/par-ch13.adb", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/572f38e4b24c395d3841f9fb8939037885222e4e/gcc%2Fada%2Fpar-ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/572f38e4b24c395d3841f9fb8939037885222e4e/gcc%2Fada%2Fpar-ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch13.adb?ref=572f38e4b24c395d3841f9fb8939037885222e4e", "patch": "@@ -726,14 +726,23 @@ package body Ch13 is\n                end if;\n             end if;\n \n-            --  We come here with an OK attribute scanned, and the\n-            --  corresponding Attribute identifier node stored in Ident_Node.\n+            --  Here we have an OK attribute scanned, and the corresponding\n+            --  Attribute identifier node is stored in Ident_Node.\n \n             Prefix_Node := Name_Node;\n             Name_Node := New_Node (N_Attribute_Reference, Prev_Token_Ptr);\n             Set_Prefix (Name_Node, Prefix_Node);\n             Set_Attribute_Name (Name_Node, Attr_Name);\n             Scan;\n+\n+            --  Check for Address clause which needs to be marked for use in\n+            --  optimizing performance of Exp_Util.Following_Address_Clause.\n+\n+            if Attr_Name = Name_Address\n+              and then Nkind (Prefix_Node) = N_Identifier\n+            then\n+               Set_Name_Table_Boolean (Chars (Prefix_Node), True);\n+            end if;\n          end loop;\n \n          Rep_Clause_Node := New_Node (N_Attribute_Definition_Clause, For_Loc);\n@@ -759,6 +768,11 @@ package body Ch13 is\n             Check_Simple_Expression_In_Ada_83 (Expr_Node);\n             Set_Expression (Rep_Clause_Node, Expr_Node);\n \n+            --  Mark occurrence of address clause (used to optimize performance\n+            --  of Exp_Util.Following_Address_Clause).\n+\n+            Set_Name_Table_Boolean (Chars (Identifier_Node), True);\n+\n          --  RECORD follows USE (Record Representation Clause)\n \n          elsif Token = Tok_Record then"}, {"sha": "9adcb8208ac3b3894ad083d74be3d62c8a184232", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/572f38e4b24c395d3841f9fb8939037885222e4e/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/572f38e4b24c395d3841f9fb8939037885222e4e/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=572f38e4b24c395d3841f9fb8939037885222e4e", "patch": "@@ -3649,11 +3649,6 @@ package body Sem_Ch3 is\n          if Comes_From_Source (N)\n            and then Expander_Active\n            and then Nkind (E) = N_Aggregate\n-\n-           --  Note the importance of doing this the following test after the\n-           --  N_Aggregate test to avoid inefficiencies from too many calls to\n-           --  the function Following_Address_Clause which can be expensive.\n-\n            and then Present (Following_Address_Clause (N))\n          then\n             Set_Etype (E, T);"}, {"sha": "940f90f1bdafa27f9b125b50c392b88172bb492a", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/572f38e4b24c395d3841f9fb8939037885222e4e/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/572f38e4b24c395d3841f9fb8939037885222e4e/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=572f38e4b24c395d3841f9fb8939037885222e4e", "patch": "@@ -601,7 +601,7 @@ package body Sem_Elab is\n       Cunit_SC : Boolean := False;\n       --  Set to suppress dynamic elaboration checks where one of the\n       --  enclosing scopes has Elaboration_Checks_Suppressed set, or else\n-      --  if a pragma Elaborate (_All) applies to that scope, in which case\n+      --  if a pragma Elaborate[_All] applies to that scope, in which case\n       --  warnings on the scope are also suppressed. For the internal case,\n       --  we ignore this flag.\n "}, {"sha": "75f430c57624bbef53dadda3eb7cc3fcc545f431", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/572f38e4b24c395d3841f9fb8939037885222e4e/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/572f38e4b24c395d3841f9fb8939037885222e4e/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=572f38e4b24c395d3841f9fb8939037885222e4e", "patch": "@@ -13134,10 +13134,6 @@ package body Sem_Prag is\n             Citem : Node_Id;\n \n          begin\n-            if SPARK_Mode = On then\n-               Error_Msg_N (\"pragma Elaborate not allowed in SPARK\", N);\n-            end if;\n-\n             --  Pragma must be in context items list of a compilation unit\n \n             if not Is_In_Context_Clause then\n@@ -13197,8 +13193,15 @@ package body Sem_Prag is\n                      --  to the named unit, so we keep the check enabled.\n \n                      if In_Extended_Main_Source_Unit (N) then\n-                        Set_Suppress_Elaboration_Warnings\n-                          (Entity (Name (Citem)));\n+\n+                        --  This does not apply in SPARK mode, where we allow\n+                        --  pragma Elaborate, but we don't trust it to be right\n+                        --  so we will still insist on the Elaborate_All.\n+\n+                        if SPARK_Mode /= On then\n+                           Set_Suppress_Elaboration_Warnings\n+                             (Entity (Name (Citem)));\n+                        end if;\n                      end if;\n \n                      exit Inner;"}]}