{"sha": "7fb397a4b80067b7b5feda492aa4537d14bbcda7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZiMzk3YTRiODAwNjdiN2I1ZmVkYTQ5MmFhNDUzN2QxNGJiY2RhNw==", "commit": {"author": {"name": "Jerry Quinn", "email": "jlquinn@optonline.net", "date": "2004-02-03T03:33:24Z"}, "committer": {"name": "Jerry Quinn", "email": "jlquinn@gcc.gnu.org", "date": "2004-02-03T03:33:24Z"}, "message": "gslice.h (gslice): Document.\n\n2004-02-02  Jerry Quinn  <jlquinn@optonline.net>\n\n\t* include/bits/gslice.h (gslice):  Document.\n\t* include/bits/gslice_array.h (gslice_array):  Document.\n\t* include/bits/indirect_array (indirect_array):  Document.\n\t* include/bits/mask_array (mask_array):  Document.\n\t* include/bits/slice_array.h (slice,slice_array):  Document.\n\t* include/bits/stl_numeric.h (accumulate, inner_product, partial_sum,\n\tadjacent_difference):  Document\n\t* include/std/std_valarray.h (valarray):  Document.\n\nFrom-SVN: r77153", "tree": {"sha": "85681e18d82a4d6494bfbd368c2ef7f2d08816fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85681e18d82a4d6494bfbd368c2ef7f2d08816fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fb397a4b80067b7b5feda492aa4537d14bbcda7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fb397a4b80067b7b5feda492aa4537d14bbcda7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fb397a4b80067b7b5feda492aa4537d14bbcda7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fb397a4b80067b7b5feda492aa4537d14bbcda7/comments", "author": {"login": "jlquinn", "id": 826841, "node_id": "MDQ6VXNlcjgyNjg0MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/826841?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jlquinn", "html_url": "https://github.com/jlquinn", "followers_url": "https://api.github.com/users/jlquinn/followers", "following_url": "https://api.github.com/users/jlquinn/following{/other_user}", "gists_url": "https://api.github.com/users/jlquinn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jlquinn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jlquinn/subscriptions", "organizations_url": "https://api.github.com/users/jlquinn/orgs", "repos_url": "https://api.github.com/users/jlquinn/repos", "events_url": "https://api.github.com/users/jlquinn/events{/privacy}", "received_events_url": "https://api.github.com/users/jlquinn/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3168cb992791efed6b803d0f44a37528245b7a96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3168cb992791efed6b803d0f44a37528245b7a96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3168cb992791efed6b803d0f44a37528245b7a96"}], "stats": {"total": 781, "additions": 693, "deletions": 88}, "files": [{"sha": "778fd062c480dd8f323ed727d7806847cc094542", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb397a4b80067b7b5feda492aa4537d14bbcda7/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb397a4b80067b7b5feda492aa4537d14bbcda7/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7fb397a4b80067b7b5feda492aa4537d14bbcda7", "patch": "@@ -1,3 +1,14 @@\n+2004-02-02  Jerry Quinn  <jlquinn@optonline.net>\n+\n+\t* include/bits/gslice.h (gslice):  Document.\n+\t* include/bits/gslice_array.h (gslice_array):  Document.\n+\t* include/bits/indirect_array (indirect_array):  Document.\n+\t* include/bits/mask_array (mask_array):  Document.\n+\t* include/bits/slice_array.h (slice,slice_array):  Document.\n+\t* include/bits/stl_numeric.h (accumulate, inner_product, partial_sum,\n+\tadjacent_difference):  Document\n+\t* include/std/std_valarray.h (valarray):  Document.\n+\n 2004-02-02  Benjamin Kosnik  <bkoz@redhat.com>\n \n         * docs/html/19_diagnostics/howto.html: Move verbose terminate"}, {"sha": "92fd2d2e63872946ae0fa4a971e5e0b1d5ce99e4", "filename": "libstdc++-v3/include/bits/gslice.h", "status": "modified", "additions": 67, "deletions": 27, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb397a4b80067b7b5feda492aa4537d14bbcda7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb397a4b80067b7b5feda492aa4537d14bbcda7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice.h?ref=7fb397a4b80067b7b5feda492aa4537d14bbcda7", "patch": "@@ -41,40 +41,80 @@\n \n namespace std {\n     \n+  /**\n+   *  @brief  Class defining multi-dimensional subset of an array.\n+   *\n+   *  The slice class represents a multi-dimensional subset of an array,\n+   *  specified by three parameter sets: start offset, size array, and stride\n+   *  array.  The start offset is the index of the first element of the array\n+   *  that is part of the subset.  The size and stride array describe each\n+   *  dimension of the slice.  Size is the number of elements in that\n+   *  dimension, and stride is the distance in the array between successive\n+   *  elements in that dimension.  Each dimension's size and stride is taken\n+   *  to begin at an array element described by the previous dimension.  The\n+   *  size array and stride array must be the same size.\n+   *\n+   *  For example, if you have offset==3, stride[0]==11, size[1]==3,\n+   *  stride[1]==3, then slice[0,0]==array[3], slice[0,1]==array[6],\n+   *  slice[0,2]==array[9], slice[1,0]==array[14], slice[1,1]==array[17],\n+   *  slice[1,2]==array[20].\n+   */\n     class gslice\n     {\n     public:\n-        gslice ();\n-        gslice (size_t, const valarray<size_t>&, const valarray<size_t>&);\n-        // XXX: the IS says the copy-ctor and copy-assignment operators are\n-        //      synthetized by the compiler but they are just unsuitable\n-        //      for a ref-counted semantic\n-        gslice(const gslice&);\n-        ~gslice();\n-\n-        // XXX: See the note above.\n-        gslice& operator= (const gslice&);\n+      ///  Construct an empty slice.\n+      gslice ();\n+\n+      /**\n+       *  @brief  Construct a slice.\n+       *\n+       *  Constructs a slice with as many dimensions as the length of the @a l\n+       *  and @a s arrays.\n+       *\n+       *  @param  o  Offset in array of first element.\n+       *  @param  l  Array of dimension lengths.\n+       *  @param  s  Array of dimension strides between array elements.\n+       */\n+      gslice(size_t, const valarray<size_t>&, const valarray<size_t>&);\n+\n+      // XXX: the IS says the copy-ctor and copy-assignment operators are\n+      //      synthetized by the compiler but they are just unsuitable\n+      //      for a ref-counted semantic\n+      ///  Copy constructor.\n+      gslice(const gslice&);\n+\n+      ///  Destructor.\n+      ~gslice();\n+\n+      // XXX: See the note above.\n+      ///  Assignment operator.\n+      gslice& operator=(const gslice&);\n         \n-        size_t           start () const;\n-        valarray<size_t> size () const;\n-        valarray<size_t> stride () const;\n+      ///  Return array offset of first slice element.\n+      size_t           start() const;\n+\n+      ///  Return array of sizes of slice dimensions.\n+      valarray<size_t> size() const;\n+\n+      ///  Return array of array strides for each dimension.\n+      valarray<size_t> stride() const;\n         \n     private:\n-        struct _Indexer {\n-            size_t _M_count;\n-            size_t _M_start;\n-            valarray<size_t> _M_size;\n-            valarray<size_t> _M_stride;\n-            valarray<size_t> _M_index;\n-            _Indexer(size_t, const valarray<size_t>&,\n-                     const valarray<size_t>&);\n-            void _M_increment_use() { ++_M_count; }\n-            size_t _M_decrement_use() { return --_M_count; }\n-        };\n-\n-        _Indexer* _M_index;\n+      struct _Indexer {\n+\tsize_t _M_count;\n+\tsize_t _M_start;\n+\tvalarray<size_t> _M_size;\n+\tvalarray<size_t> _M_stride;\n+\tvalarray<size_t> _M_index;\n+\t_Indexer(size_t, const valarray<size_t>&,\n+\t\t const valarray<size_t>&);\n+\tvoid _M_increment_use() { ++_M_count; }\n+\tsize_t _M_decrement_use() { return --_M_count; }\n+      };\n+\n+      _Indexer* _M_index;\n         \n-        template<typename _Tp> friend class valarray;\n+      template<typename _Tp> friend class valarray;\n     };\n     \n     inline size_t"}, {"sha": "f6a0520ffcb16a98d7fc70d88a2d89cd29674bbe", "filename": "libstdc++-v3/include/bits/gslice_array.h", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb397a4b80067b7b5feda492aa4537d14bbcda7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb397a4b80067b7b5feda492aa4537d14bbcda7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fgslice_array.h?ref=7fb397a4b80067b7b5feda492aa4537d14bbcda7", "patch": "@@ -41,23 +41,48 @@\n \n namespace std {\n \n+  /**\n+   *  @brief  Reference to multi-dimensional subset of an array.\n+   *\n+   *  A gslice_array is a reference to the actual elements of an array\n+   *  specified by a gslice.  The way to get a gslice_array is to call\n+   *  operator[](gslice) on a valarray.  The returned gslice_array then\n+   *  permits carrying operations out on the referenced subset of elements in\n+   *  the original valarray.  For example, operator+=(valarray) will add\n+   *  values to the subset of elements in the underlying valarray this\n+   *  gslice_array refers to.\n+   *\n+   *  @param  Tp  Element type.\n+   */\n   template<typename _Tp>\n     class gslice_array\n     {\n     public:\n       typedef _Tp value_type;\n \n+      ///  Assign slice elements to corresponding elements of @a v.\n       void operator=(const valarray<_Tp>&) const;\n+      ///  Multiply slice elements by corresponding elements of @a v.\n       void operator*=(const valarray<_Tp>&) const;\n+      ///  Divide slice elements by corresponding elements of @a v.\n       void operator/=(const valarray<_Tp>&) const;\n+      ///  Modulo slice elements by corresponding elements of @a v.\n       void operator%=(const valarray<_Tp>&) const;\n+      ///  Add corresponding elements of @a v to slice elements.\n       void operator+=(const valarray<_Tp>&) const;\n+      ///  Subtract corresponding elements of @a v from slice elements.\n       void operator-=(const valarray<_Tp>&) const;\n+      ///  Logical xor slice elements with corresponding elements of @a v.\n       void operator^=(const valarray<_Tp>&) const;\n+      ///  Logical and slice elements with corresponding elements of @a v.\n       void operator&=(const valarray<_Tp>&) const;\n+      ///  Logical or slice elements with corresponding elements of @a v.\n       void operator|=(const valarray<_Tp>&) const;\n+      ///  Left shift slice elements by corresponding elements of @a v.\n       void operator<<=(const valarray<_Tp>&) const;\n+      ///  Right shift slice elements by corresponding elements of @a v.\n       void operator>>=(const valarray<_Tp>&) const;\n+      ///  Assign all slice elements to @a t.\n       void operator=(const _Tp&) const;\n \n       template<class _Dom>\n@@ -92,10 +117,14 @@ namespace std {\n       gslice_array(_Array<_Tp>, const valarray<size_t>&);\n \n       // this constructor needs to be implemented.\n+      ///  Copy constructor.  Both slices refer to the same underlying array.\n       gslice_array(const gslice_array&);\n \n       // not implemented\n       gslice_array();\n+\n+      ///  Assignment operator.  Assigns slice elements to corresponding\n+      ///  elements of @a a.\n       gslice_array& operator= (const gslice_array&);\n     };\n "}, {"sha": "77a7f40464a3d586e4cdf969254c4345ed06cdc1", "filename": "libstdc++-v3/include/bits/indirect_array.h", "status": "modified", "additions": 85, "deletions": 55, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb397a4b80067b7b5feda492aa4537d14bbcda7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Findirect_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb397a4b80067b7b5feda492aa4537d14bbcda7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Findirect_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Findirect_array.h?ref=7fb397a4b80067b7b5feda492aa4537d14bbcda7", "patch": "@@ -42,66 +42,96 @@\n \n namespace std\n {\n+  /**\n+   *  @brief  Reference to arbitrary subset of an array.\n+   *\n+   *  An indirect_array is a reference to the actual elements of an array\n+   *  specified by an ordered array of indices.  The way to get an indirect_array is to\n+   *  call operator[](valarray<size_t>) on a valarray.  The returned\n+   *  indirect_array then permits carrying operations out on the referenced\n+   *  subset of elements in the original valarray.\n+   *\n+   *  For example, if an indirect_array is obtained using the array (4,2,0) as\n+   *  an argument, and then assigned to an array containing (1,2,3), then the\n+   *  underlying array will have array[0]==3, array[2]==2, and array[4]==1.\n+   *\n+   *  @param  Tp  Element type.\n+   */\n   template <class _Tp>\n-     class indirect_array\n-     {\n-     public:\n-       typedef _Tp value_type;\n-\n-       // XXX: This is a proposed resolution for DR-253.\n-       indirect_array& operator=(const indirect_array&);\n+    class indirect_array\n+    {\n+    public:\n+      typedef _Tp value_type;\n+\n+      // XXX: This is a proposed resolution for DR-253.\n+      ///  Assignment operator.  Assigns elements to corresponding elements\n+      ///  of @a a.\n+      indirect_array& operator=(const indirect_array&);\n        \n-       void operator=(const valarray<_Tp>&) const;\n-       void operator*=(const valarray<_Tp>&) const;\n-       void operator/=(const valarray<_Tp>&) const;\n-       void operator%=(const valarray<_Tp>&) const; \n-       void operator+=(const valarray<_Tp>&) const;\n-       void operator-=(const valarray<_Tp>&) const;  \n-       void operator^=(const valarray<_Tp>&) const;\n-       void operator&=(const valarray<_Tp>&) const;\n-       void operator|=(const valarray<_Tp>&) const;\n-       void operator<<=(const valarray<_Tp>&) const;\n-       void operator>>=(const valarray<_Tp>&) const; \n-       void operator= (const _Tp&) const;\n-       //    ~indirect_array();\n+      ///  Assign slice elements to corresponding elements of @a v.\n+      void operator=(const valarray<_Tp>&) const;\n+      ///  Multiply slice elements by corresponding elements of @a v.\n+      void operator*=(const valarray<_Tp>&) const;\n+      ///  Divide slice elements by corresponding elements of @a v.\n+      void operator/=(const valarray<_Tp>&) const;\n+      ///  Modulo slice elements by corresponding elements of @a v.\n+      void operator%=(const valarray<_Tp>&) const; \n+      ///  Add corresponding elements of @a v to slice elements.\n+      void operator+=(const valarray<_Tp>&) const;\n+      ///  Subtract corresponding elements of @a v from slice elements.\n+      void operator-=(const valarray<_Tp>&) const;  \n+      ///  Logical xor slice elements with corresponding elements of @a v.\n+      void operator^=(const valarray<_Tp>&) const;\n+      ///  Logical and slice elements with corresponding elements of @a v.\n+      void operator&=(const valarray<_Tp>&) const;\n+      ///  Logical or slice elements with corresponding elements of @a v.\n+      void operator|=(const valarray<_Tp>&) const;\n+      ///  Left shift slice elements by corresponding elements of @a v.\n+      void operator<<=(const valarray<_Tp>&) const;\n+      ///  Right shift slice elements by corresponding elements of @a v.\n+      void operator>>=(const valarray<_Tp>&) const; \n+      ///  Assign all slice elements to @a t.\n+      void operator= (const _Tp&) const;\n+      //    ~indirect_array();\n        \n-       template<class _Dom>\n-         void operator=(const _Expr<_Dom, _Tp>&) const;\n-       template<class _Dom>\n-         void operator*=(const _Expr<_Dom, _Tp>&) const;\n-       template<class _Dom>\n-         void operator/=(const _Expr<_Dom, _Tp>&) const;\n-       template<class _Dom>\n-         void operator%=(const _Expr<_Dom, _Tp>&) const;\n-       template<class _Dom>\n-         void operator+=(const _Expr<_Dom, _Tp>&) const;\n-       template<class _Dom>\n-         void operator-=(const _Expr<_Dom, _Tp>&) const;\n-       template<class _Dom>\n-         void operator^=(const _Expr<_Dom, _Tp>&) const;\n-       template<class _Dom>\n-         void operator&=(const _Expr<_Dom, _Tp>&) const;\n-       template<class _Dom>\n-         void operator|=(const _Expr<_Dom, _Tp>&) const;\n-       template<class _Dom>\n-         void operator<<=(const _Expr<_Dom, _Tp>&) const;\n-       template<class _Dom>\n-         void operator>>=(const _Expr<_Dom, _Tp>&) const; \n-\n-     private:\n-       indirect_array(const indirect_array&);\n-       indirect_array(_Array<_Tp>, size_t, _Array<size_t>);\n-\n-       friend class valarray<_Tp>;\n-       friend class gslice_array<_Tp>;\n+      template<class _Dom>\n+      void operator=(const _Expr<_Dom, _Tp>&) const;\n+      template<class _Dom>\n+      void operator*=(const _Expr<_Dom, _Tp>&) const;\n+      template<class _Dom>\n+      void operator/=(const _Expr<_Dom, _Tp>&) const;\n+      template<class _Dom>\n+      void operator%=(const _Expr<_Dom, _Tp>&) const;\n+      template<class _Dom>\n+      void operator+=(const _Expr<_Dom, _Tp>&) const;\n+      template<class _Dom>\n+      void operator-=(const _Expr<_Dom, _Tp>&) const;\n+      template<class _Dom>\n+      void operator^=(const _Expr<_Dom, _Tp>&) const;\n+      template<class _Dom>\n+      void operator&=(const _Expr<_Dom, _Tp>&) const;\n+      template<class _Dom>\n+      void operator|=(const _Expr<_Dom, _Tp>&) const;\n+      template<class _Dom>\n+      void operator<<=(const _Expr<_Dom, _Tp>&) const;\n+      template<class _Dom>\n+      void operator>>=(const _Expr<_Dom, _Tp>&) const; \n+\n+    private:\n+      ///  Copy constructor.  Both slices refer to the same underlying array.\n+      indirect_array(const indirect_array&);\n+      indirect_array(_Array<_Tp>, size_t, _Array<size_t>);\n+\n+      friend class valarray<_Tp>;\n+      friend class gslice_array<_Tp>;\n        \n-       const size_t \t _M_sz;\n-       const _Array<size_t> _M_index;\n-       const _Array<_Tp> \t _M_array;\n+      const size_t \t _M_sz;\n+      const _Array<size_t> _M_index;\n+      const _Array<_Tp> \t _M_array;\n        \n-       // not implemented\n-       indirect_array();\n-     };\n+      // not implemented\n+      indirect_array();\n+    };\n \n   template<typename _Tp>\n     inline "}, {"sha": "a5d13d7162de921c8613fd8e8d869edb16ca9ae8", "filename": "libstdc++-v3/include/bits/mask_array.h", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb397a4b80067b7b5feda492aa4537d14bbcda7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmask_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb397a4b80067b7b5feda492aa4537d14bbcda7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmask_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fmask_array.h?ref=7fb397a4b80067b7b5feda492aa4537d14bbcda7", "patch": "@@ -42,23 +42,49 @@\n \n namespace std {\n \n+  /**\n+   *  @brief  Reference to selected subset of an array.\n+   *\n+   *  A mask_array is a reference to the actual elements of an array specified\n+   *  by a bitmask in the form of an array of bool.  The way to get a\n+   *  mask_array is to call operator[](valarray<bool>) on a valarray.  The\n+   *  returned mask_array then permits carrying operations out on the\n+   *  referenced subset of elements in the original valarray.\n+   *\n+   *  For example, if a mask_array is obtained using the array (false, true,\n+   *  false, true) as an argument, the mask array has two elements referring\n+   *  to array[1] and array[3] in the underlying array.\n+   *\n+   *  @param  Tp  Element type.\n+   */\n   template <class _Tp> \n     class mask_array\n     { \n     public:\n       typedef _Tp value_type;\n     \n       void operator=(const valarray<_Tp>&) const;\n+      ///  Multiply slice elements by corresponding elements of @a v.\n       void operator*=(const valarray<_Tp>&) const;\n+      ///  Divide slice elements by corresponding elements of @a v.\n       void operator/=(const valarray<_Tp>&) const;\n-      void operator%=(const valarray<_Tp>&) const;\n-      void operator+=(const valarray<_Tp>&) const; \n-      void operator-=(const valarray<_Tp>&) const;\n-      void operator^=(const valarray<_Tp>&) const;  \n+      ///  Modulo slice elements by corresponding elements of @a v.\n+      void operator%=(const valarray<_Tp>&) const; \n+      ///  Add corresponding elements of @a v to slice elements.\n+      void operator+=(const valarray<_Tp>&) const;\n+      ///  Subtract corresponding elements of @a v from slice elements.\n+      void operator-=(const valarray<_Tp>&) const;  \n+      ///  Logical xor slice elements with corresponding elements of @a v.\n+      void operator^=(const valarray<_Tp>&) const;\n+      ///  Logical and slice elements with corresponding elements of @a v.\n       void operator&=(const valarray<_Tp>&) const;\n+      ///  Logical or slice elements with corresponding elements of @a v.\n       void operator|=(const valarray<_Tp>&) const;\n-      void operator<<=(const valarray<_Tp>&) const;  \n+      ///  Left shift slice elements by corresponding elements of @a v.\n+      void operator<<=(const valarray<_Tp>&) const;\n+      ///  Right shift slice elements by corresponding elements of @a v.\n       void operator>>=(const valarray<_Tp>&) const; \n+      ///  Assign all slice elements to @a t.\n       void operator=(const _Tp&) const;\n     \n         //        ~mask_array ();\n@@ -94,10 +120,14 @@ namespace std {\n       const _Array<bool> _M_mask;\n       const _Array<_Tp>   _M_array;\n       \n+      ///  Copy constructor.  Both slices refer to the same underlying array.\n       mask_array (const mask_array&);\n       \n       // not implemented\n       mask_array();\n+\n+      ///  Assignment operator.  Assigns elements to corresponding elements\n+      ///  of @a a.\n       mask_array& operator=(const mask_array&);\n     };\n "}, {"sha": "fb4a810cc37ce89d79951a6ea2632f495d67a811", "filename": "libstdc++-v3/include/bits/slice_array.h", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb397a4b80067b7b5feda492aa4537d14bbcda7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fslice_array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb397a4b80067b7b5feda492aa4537d14bbcda7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fslice_array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fslice_array.h?ref=7fb397a4b80067b7b5feda492aa4537d14bbcda7", "patch": "@@ -41,14 +41,39 @@\n \n namespace std\n {\n+  /**\n+   *  @brief  Class defining one-dimensional subset of an array.\n+   *\n+   *  The slice class represents a one-dimensional subset of an array,\n+   *  specified by three parameters: start offset, size, and stride.  The\n+   *  start offset is the index of the first element of the array that is part\n+   *  of the subset.  The size is the total number of elements in the subset.\n+   *  Stride is the distance between each successive array element to include\n+   *  in the subset.\n+   *\n+   *  For example, with an array of size 10, and a slice with offset 1, size 3\n+   *  and stride 2, the subset consists of array elements 1, 3, and 5.\n+   */\n   class slice\n   {\n   public:\n+    ///  Construct an empty slice.\n     slice();\n+\n+    /**\n+     *  @brief  Construct a slice.\n+     *\n+     *  @param  o  Offset in array of first element.\n+     *  @param  d  Number of elements in slice.\n+     *  @param  s  Stride between array elements.\n+     */\n     slice(size_t, size_t, size_t);\n     \n+    ///  Return array offset of first slice element.\n     size_t start() const;\n+    ///  Return size of slice.\n     size_t size() const;\n+    ///  Return array stride of slice.\n     size_t stride() const;\n     \n   private:\n@@ -78,29 +103,57 @@ namespace std\n   slice::stride() const\n   { return _M_st; }\n \n+  /**\n+   *  @brief  Reference to one-dimensional subset of an array.\n+   *\n+   *  A slice_array is a reference to the actual elements of an array\n+   *  specified by a slice.  The way to get a slice_array is to call\n+   *  operator[](slice) on a valarray.  The returned slice_array then permits\n+   *  carrying operations out on the referenced subset of elements in the\n+   *  original valarray.  For example, operator+=(valarray) will add values\n+   *  to the subset of elements in the underlying valarray this slice_array\n+   *  refers to.\n+   *\n+   *  @param  Tp  Element type.\n+   */\n   template<typename _Tp>\n     class slice_array\n     {\n     public:\n       typedef _Tp value_type;\n \n       // This constructor is implemented since we need to return a value.\n+      ///  Copy constructor.  Both slices refer to the same underlying array.\n       slice_array(const slice_array&);\n \n       // This operator must be public.  See DR-253.\n+      ///  Assignment operator.  Assigns slice elements to corresponding\n+      ///  elements of @a a.\n       slice_array& operator=(const slice_array&);\n \n+      ///  Assign slice elements to corresponding elements of @a v.\n       void operator=(const valarray<_Tp>&) const;\n+      ///  Multiply slice elements by corresponding elements of @a v.\n       void operator*=(const valarray<_Tp>&) const;\n+      ///  Divide slice elements by corresponding elements of @a v.\n       void operator/=(const valarray<_Tp>&) const;\n+      ///  Modulo slice elements by corresponding elements of @a v.\n       void operator%=(const valarray<_Tp>&) const;\n+      ///  Add corresponding elements of @a v to slice elements.\n       void operator+=(const valarray<_Tp>&) const;\n+      ///  Subtract corresponding elements of @a v from slice elements.\n       void operator-=(const valarray<_Tp>&) const;\n+      ///  Logical xor slice elements with corresponding elements of @a v.\n       void operator^=(const valarray<_Tp>&) const;\n+      ///  Logical and slice elements with corresponding elements of @a v.\n       void operator&=(const valarray<_Tp>&) const;\n+      ///  Logical or slice elements with corresponding elements of @a v.\n       void operator|=(const valarray<_Tp>&) const;\n+      ///  Left shift slice elements by corresponding elements of @a v.\n       void operator<<=(const valarray<_Tp>&) const;\n+      ///  Right shift slice elements by corresponding elements of @a v.\n       void operator>>=(const valarray<_Tp>&) const;\n+      ///  Assign all slice elements to @a t.\n       void operator=(const _Tp &) const;\n       //        ~slice_array ();\n "}, {"sha": "d4eb358a7d470cc7b6e628b4c37abfa307e7330d", "filename": "libstdc++-v3/include/bits/stl_numeric.h", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb397a4b80067b7b5feda492aa4537d14bbcda7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb397a4b80067b7b5feda492aa4537d14bbcda7/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h?ref=7fb397a4b80067b7b5feda492aa4537d14bbcda7", "patch": "@@ -66,6 +66,17 @@\n namespace std\n {\n \n+  /**\n+   *  @brief  Accumulate values in a range.\n+   *\n+   *  Accumulates the values in the range [first,last) using operator+().  The\n+   *  initial value is @a init.  The values are processed in order.\n+   *\n+   *  @param  first  Start of range.\n+   *  @param  last  End of range.\n+   *  @param  init  Starting value to add other values to.\n+   *  @return  The final sum.\n+   */\n   template<typename _InputIterator, typename _Tp>\n     _Tp\n     accumulate(_InputIterator __first, _InputIterator __last, _Tp __init)\n@@ -79,6 +90,19 @@ namespace std\n       return __init;\n     }\n \n+  /**\n+   *  @brief  Accumulate values in a range with operation.\n+   *\n+   *  Accumulates the values in the range [first,last) using the function\n+   *  object @a binary_op.  The initial value is @a init.  The values are\n+   *  processed in order.\n+   *\n+   *  @param  first  Start of range.\n+   *  @param  last  End of range.\n+   *  @param  init  Starting value to add other values to.\n+   *  @param  binary_op  Function object to accumulate with.\n+   *  @return  The final sum.\n+   */\n   template<typename _InputIterator, typename _Tp, typename _BinaryOperation>\n     _Tp\n     accumulate(_InputIterator __first, _InputIterator __last, _Tp __init,\n@@ -93,6 +117,20 @@ namespace std\n       return __init;\n     }\n \n+  /**\n+   *  @brief  Compute inner product of two ranges.\n+   *\n+   *  Starting with an initial value of @a init, multiplies successive\n+   *  elements from the two ranges and adds each product into the accumulated\n+   *  value using operator+().  The values in the ranges are processed in\n+   *  order.\n+   *\n+   *  @param  first1  Start of range 1.\n+   *  @param  last1  End of range 1.\n+   *  @param  first2  Start of range 2.\n+   *  @param  init  Starting value to add other values to.\n+   *  @return  The final inner product.\n+   */\n   template<typename _InputIterator1, typename _InputIterator2, typename _Tp>\n     _Tp\n     inner_product(_InputIterator1 __first1, _InputIterator1 __last1,\n@@ -108,6 +146,22 @@ namespace std\n       return __init;\n     }\n \n+  /**\n+   *  @brief  Compute inner product of two ranges.\n+   *\n+   *  Starting with an initial value of @a init, applies @a binary_op2 to\n+   *  successive elements from the two ranges and accumulates each result into\n+   *  the accumulated value using @a binary_op1.  The values in the ranges are\n+   *  processed in order.\n+   *\n+   *  @param  first1  Start of range 1.\n+   *  @param  last1  End of range 1.\n+   *  @param  first2  Start of range 2.\n+   *  @param  init  Starting value to add other values to.\n+   *  @param  binary_op1  Function object to accumulate with.\n+   *  @param  binary_op2  Function object to apply to pairs of input values.\n+   *  @return  The final inner product.\n+   */\n   template<typename _InputIterator1, typename _InputIterator2, typename _Tp,\n \t    typename _BinaryOperation1, typename _BinaryOperation2>\n     _Tp\n@@ -126,6 +180,20 @@ namespace std\n       return __init;\n     }\n \n+  /**\n+   *  @brief  Return list of partial sums\n+   *\n+   *  Accumulates the values in the range [first,last) using operator+().\n+   *  As each successive input value is added into the total, that partial sum\n+   *  is written to @a result.  Therefore, the first value in result is the\n+   *  first value of the input, the second value in result is the sum of the\n+   *  first and second input values, and so on.\n+   *\n+   *  @param  first  Start of input range.\n+   *  @param  last  End of input range.\n+   *  @param  result  Output to write sums to.\n+   *  @return  Iterator pointing just beyond the values written to result.\n+   */\n   template<typename _InputIterator, typename _OutputIterator>\n     _OutputIterator \n     partial_sum(_InputIterator __first, _InputIterator __last,\n@@ -148,6 +216,20 @@ namespace std\n       return ++__result;\n     }\n \n+  /**\n+   *  @brief  Return list of partial sums\n+   *\n+   *  Accumulates the values in the range [first,last) using operator+().\n+   *  As each successive input value is added into the total, that partial sum\n+   *  is written to @a result.  Therefore, the first value in result is the\n+   *  first value of the input, the second value in result is the sum of the\n+   *  first and second input values, and so on.\n+   *\n+   *  @param  first  Start of input range.\n+   *  @param  last  End of input range.\n+   *  @param  result  Output to write sums to.\n+   *  @return  Iterator pointing just beyond the values written to result.\n+   */\n   template<typename _InputIterator, typename _OutputIterator, typename _BinaryOperation>\n     _OutputIterator \n     partial_sum(_InputIterator __first, _InputIterator __last,\n@@ -170,6 +252,17 @@ namespace std\n       return ++__result;\n     }\n \n+  /**\n+   *  @brief  Return differences between adjacent values.\n+   *\n+   *  Computes the difference between adjacent values in the range\n+   *  [first,last) using operator-() and writes the result to @a result.\n+   *\n+   *  @param  first  Start of input range.\n+   *  @param  last  End of input range.\n+   *  @param  result  Output to write sums to.\n+   *  @return  Iterator pointing just beyond the values written to result.\n+   */\n   template<typename _InputIterator, typename _OutputIterator>\n     _OutputIterator\n     adjacent_difference(_InputIterator __first,\n@@ -193,6 +286,18 @@ namespace std\n       return ++__result;\n     }\n \n+  /**\n+   *  @brief  Return differences between adjacent values.\n+   *\n+   *  Computes the difference between adjacent values in the range\n+   *  [first,last) using the function object @a binary_op and writes the\n+   *  result to @a result.\n+   *\n+   *  @param  first  Start of input range.\n+   *  @param  last  End of input range.\n+   *  @param  result  Output to write sums to.\n+   *  @return  Iterator pointing just beyond the values written to result.\n+   */\n   template<typename _InputIterator, typename _OutputIterator, typename _BinaryOperation>\n     _OutputIterator \n     adjacent_difference(_InputIterator __first, _InputIterator __last,"}, {"sha": "9cec1d34ccfd1d52f2413479bc87c80e133c6c19", "filename": "libstdc++-v3/include/std/std_valarray.h", "status": "modified", "additions": 308, "deletions": 1, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fb397a4b80067b7b5feda492aa4537d14bbcda7/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_valarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fb397a4b80067b7b5feda492aa4537d14bbcda7/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_valarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_valarray.h?ref=7fb397a4b80067b7b5feda492aa4537d14bbcda7", "patch": "@@ -95,6 +95,17 @@ namespace std\n   \n namespace std\n {\n+  /**\n+   *  @brief  Smart array designed to support numeric processing.\n+   *\n+   *  A valarray is an array that provides constraints intended to allow for\n+   *  effective optimization of numeric array processing by reducing the\n+   *  aliasing that can result from pointer representations.  It represents a\n+   *  one-dimensional array from which different multidimensional subsets can\n+   *  be accessed and modified.\n+   *  \n+   *  @param  Tp  Type of object in the array.\n+   */\n   template<class _Tp> \n     class valarray\n     {\n@@ -108,71 +119,292 @@ namespace std\n       typedef _Tp value_type;\n       \n \t// _lib.valarray.cons_ construct/destroy:\n+      ///  Construct an empty array.\n       valarray();\n+\n+      ///  Construct an array with @a n elements.\n       explicit valarray(size_t);\n+\n+      ///  Construct an array with @a n elements initialized to @a t.\n       valarray(const _Tp&, size_t);\n+\n+      ///  Construct an array initialized to the first @a n elements of @a t.\n       valarray(const _Tp* __restrict__, size_t);\n+\n+      ///  Copy constructor.\n       valarray(const valarray&);\n+\n+      ///  Construct an array with the same size and values in @a sa.\n       valarray(const slice_array<_Tp>&);\n+\n+      ///  Construct an array with the same size and values in @a ga.\n       valarray(const gslice_array<_Tp>&);\n+\n+      ///  Construct an array with the same size and values in @a ma.\n       valarray(const mask_array<_Tp>&);\n+\n+      ///  Construct an array with the same size and values in @a ia.\n       valarray(const indirect_array<_Tp>&);\n+\n       template<class _Dom>\n \tvalarray(const _Expr<_Dom,_Tp>& __e);\n       ~valarray();\n \n       // _lib.valarray.assign_ assignment:\n+      /**\n+       *  @brief  Assign elements to an array.\n+       *\n+       *  Assign elements of array to values in @a v.  Results are undefined\n+       *  if @a v is not the same size as this array.\n+       *\n+       *  @param  v  Valarray to get values from.\n+       */\n       valarray<_Tp>& operator=(const valarray<_Tp>&);\n+\n+      /**\n+       *  @brief  Assign elements to a value.\n+       *\n+       *  Assign all elements of array to @a t.\n+       *\n+       *  @param  t  Value for elements.\n+       */\n       valarray<_Tp>& operator=(const _Tp&);\n+\n+      /**\n+       *  @brief  Assign elements to an array subset.\n+       *\n+       *  Assign elements of array to values in @a sa.  Results are undefined\n+       *  if @a sa is not the same size as this array.\n+       *\n+       *  @param  sa  Array slice to get values from.\n+       */\n       valarray<_Tp>& operator=(const slice_array<_Tp>&);\n+\n+      /**\n+       *  @brief  Assign elements to an array subset.\n+       *\n+       *  Assign elements of array to values in @a ga.  Results are undefined\n+       *  if @a ga is not the same size as this array.\n+       *\n+       *  @param  ga  Array slice to get values from.\n+       */\n       valarray<_Tp>& operator=(const gslice_array<_Tp>&);\n+\n+      /**\n+       *  @brief  Assign elements to an array subset.\n+       *\n+       *  Assign elements of array to values in @a ma.  Results are undefined\n+       *  if @a ma is not the same size as this array.\n+       *\n+       *  @param  ma  Array slice to get values from.\n+       */\n       valarray<_Tp>& operator=(const mask_array<_Tp>&);\n+\n+      /**\n+       *  @brief  Assign elements to an array subset.\n+       *\n+       *  Assign elements of array to values in @a ia.  Results are undefined\n+       *  if @a ia is not the same size as this array.\n+       *\n+       *  @param  ia  Array slice to get values from.\n+       */\n       valarray<_Tp>& operator=(const indirect_array<_Tp>&);\n \n       template<class _Dom> valarray<_Tp>&\n \toperator= (const _Expr<_Dom,_Tp>&);\n \n       // _lib.valarray.access_ element access:\n       // XXX: LWG to be resolved.\n+      /**\n+       *  Return a reference to the i'th array element.  \n+       *\n+       *  The C++ spec defines the const version to return Tp instead of\n+       *  the more useful const Tp&.  This issue is being reviewed in DR389.\n+       *\n+       *  @param  i  Index of element to return.\n+       *  @return  Reference to the i'th element.\n+       */\n       const _Tp&                 operator[](size_t) const;\n+\n+      ///  Return a reference to the i'th array element.\n       _Tp&                operator[](size_t);\t\t\n+\n       // _lib.valarray.sub_ subset operations:\n+      /**\n+       *  @brief  Return an array subset.\n+       *\n+       *  Returns a new valarray containing the elements of the array\n+       *  indicated by the slice argument.  The new valarray is the size of\n+       *  the input slice.  @see slice.\n+       *\n+       *  @param  s  The source slice.\n+       *  @return  New valarray containing elements in @a s.\n+       */\n       _Expr<_SClos<_ValArray,_Tp>, _Tp> operator[](slice) const;\n+\n+      /**\n+       *  @brief  Return a reference to an array subset.\n+       *\n+       *  Returns a new valarray containing the elements of the array\n+       *  indicated by the slice argument.  The new valarray is the size of\n+       *  the input slice.  @see slice.\n+       *\n+       *  @param  s  The source slice.\n+       *  @return  New valarray containing elements in @a s.\n+       */\n       slice_array<_Tp>    operator[](slice);\n+\n+      /**\n+       *  @brief  Return an array subset.\n+       *\n+       *  Returns a slice_array referencing the elements of the array\n+       *  indicated by the slice argument.  @see gslice.\n+       *\n+       *  @param  s  The source slice.\n+       *  @return  Slice_array referencing elements indicated by @a s.\n+       */\n       _Expr<_GClos<_ValArray,_Tp>, _Tp> operator[](const gslice&) const;\n+\n+      /**\n+       *  @brief  Return a reference to an array subset.\n+       *\n+       *  Returns a new valarray containing the elements of the array\n+       *  indicated by the gslice argument.  The new valarray is\n+       *  the size of the input gslice.  @see gslice.\n+       *\n+       *  @param  s  The source gslice.\n+       *  @return  New valarray containing elements in @a s.\n+       */\n       gslice_array<_Tp>   operator[](const gslice&);\n+\n+      /**\n+       *  @brief  Return an array subset.\n+       *\n+       *  Returns a new valarray containing the elements of the array\n+       *  indicated by the argument.  The input is a valarray of bool which\n+       *  represents a bitmask indicating which elements should be copied into\n+       *  the new valarray.  Each element of the array is added to the return\n+       *  valarray if the corresponding element of the argument is true.\n+       *\n+       *  @param  m  The valarray bitmask.\n+       *  @return  New valarray containing elements indicated by @a m.\n+       */\n       valarray<_Tp>     \t operator[](const valarray<bool>&) const;\n+\n+      /**\n+       *  @brief  Return a reference to an array subset.\n+       *\n+       *  Returns a new mask_array referencing the elements of the array\n+       *  indicated by the argument.  The input is a valarray of bool which\n+       *  represents a bitmask indicating which elements are part of the\n+       *  subset.  Elements of the array are part of the subset if the\n+       *  corresponding element of the argument is true.\n+       *\n+       *  @param  m  The valarray bitmask.\n+       *  @return  New valarray containing elements indicated by @a m.\n+       */\n       mask_array<_Tp>     operator[](const valarray<bool>&);\n+\n+      /**\n+       *  @brief  Return an array subset.\n+       *\n+       *  Returns a new valarray containing the elements of the array\n+       *  indicated by the argument.  The elements in the argument are\n+       *  interpreted as the indices of elements of this valarray to copy to\n+       *  the return valarray.\n+       *\n+       *  @param  i  The valarray element index list.\n+       *  @return  New valarray containing elements in @a s.\n+       */\n       _Expr<_IClos<_ValArray, _Tp>, _Tp>\n         operator[](const valarray<size_t>&) const;\n+\n+      /**\n+       *  @brief  Return a reference to an array subset.\n+       *\n+       *  Returns an indirect_array referencing the elements of the array\n+       *  indicated by the argument.  The elements in the argument are\n+       *  interpreted as the indices of elements of this valarray to include\n+       *  in the subset.  The returned indirect_array refers to these\n+       *  elements.\n+       *\n+       *  @param  i  The valarray element index list.\n+       *  @return  Indirect_array referencing elements in @a i.\n+       */\n       indirect_array<_Tp> operator[](const valarray<size_t>&);\n \n       // _lib.valarray.unary_ unary operators:\n+      ///  Return a new valarray by applying unary + to each element.\n       typename _UnaryOp<__unary_plus>::_Rt  operator+() const;\n+\n+      ///  Return a new valarray by applying unary - to each element.\n       typename _UnaryOp<__negate>::_Rt      operator-() const;\n+\n+      ///  Return a new valarray by applying unary ~ to each element.\n       typename _UnaryOp<__bitwise_not>::_Rt operator~() const;\n+\n+      ///  Return a new valarray by applying unary ! to each element.\n       typename _UnaryOp<__logical_not>::_Rt operator!() const;\n \n       // _lib.valarray.cassign_ computed assignment:\n+      ///  Multiply each element of array by @a t.\n       valarray<_Tp>& operator*=(const _Tp&);\n+\n+      ///  Divide each element of array by @a t.\n       valarray<_Tp>& operator/=(const _Tp&);\n+\n+      ///  Set each element e of array to e % @a t.\n       valarray<_Tp>& operator%=(const _Tp&);\n+\n+      ///  Add @a t to each element of array.\n       valarray<_Tp>& operator+=(const _Tp&);\n+\n+      ///  Subtract @a t to each element of array.\n       valarray<_Tp>& operator-=(const _Tp&);\n+\n+      ///  Set each element e of array to e ^ @a t.\n       valarray<_Tp>& operator^=(const _Tp&);\n+\n+      ///  Set each element e of array to e & @a t.\n       valarray<_Tp>& operator&=(const _Tp&);\n+\n+      ///  Set each element e of array to e | @a t.\n       valarray<_Tp>& operator|=(const _Tp&);\n+\n+      ///  Left shift each element e of array by @a t bits.\n       valarray<_Tp>& operator<<=(const _Tp&);\n+\n+      ///  Right shift each element e of array by @a t bits.\n       valarray<_Tp>& operator>>=(const _Tp&);\n+\n+      ///  Multiply elements of array by corresponding elements of @a v.\n       valarray<_Tp>& operator*=(const valarray<_Tp>&);\n+\n+      ///  Divide elements of array by corresponding elements of @a v.\n       valarray<_Tp>& operator/=(const valarray<_Tp>&);\n+\n+      ///  Modulo elements of array by corresponding elements of @a v.\n       valarray<_Tp>& operator%=(const valarray<_Tp>&);\n+\n+      ///  Add corresponding elements of @a v to elements of array.\n       valarray<_Tp>& operator+=(const valarray<_Tp>&);\n+\n+      ///  Subtract corresponding elements of @a v from elements of array.\n       valarray<_Tp>& operator-=(const valarray<_Tp>&);\n+\n+      ///  Logical xor corresponding elements of @a v with elements of array.\n       valarray<_Tp>& operator^=(const valarray<_Tp>&);\n+\n+      ///  Logical or corresponding elements of @a v with elements of array.\n       valarray<_Tp>& operator|=(const valarray<_Tp>&);\n+\n+      ///  Logical and corresponding elements of @a v with elements of array.\n       valarray<_Tp>& operator&=(const valarray<_Tp>&);\n+\n+      ///  Left shift elements of array by corresponding elements of @a v.\n       valarray<_Tp>& operator<<=(const valarray<_Tp>&);\n+\n+      ///  Right shift elements of array by corresponding elements of @a v.\n       valarray<_Tp>& operator>>=(const valarray<_Tp>&);\n \n       template<class _Dom>\n@@ -198,18 +430,93 @@ namespace std\n \n \n       // _lib.valarray.members_ member functions:\n+      ///  Return the number of elements in array.\n       size_t size() const;\n-      _Tp    sum() const;\t\n+\n+      /**\n+       *  @brief  Return the sum of all elements in the array.\n+       *\n+       *  Accumulates the sum of all elements into a Tp using +=.  The order\n+       *  of adding the elements is unspecified.\n+       */\n+      _Tp    sum() const;\n+\n+      ///  Return the minimum element using operator<().\n       _Tp    min() const;\t\n+\n+      ///  Return the maximum element using operator<().\n       _Tp    max() const;\t\n \n   //           // FIXME: Extension\n   //       _Tp    product () const;\n \n+      /**\n+       *  @brief  Return a shifted array.\n+       *\n+       *  A new valarray is constructed as a copy of this array with elements\n+       *  in shifted positions.  For an element with index i, the new position\n+       *  is i - n.  The new valarray is the same size as the current one.\n+       *  New elements without a value are set to 0.  Elements whos new\n+       *  position is outside the bounds of the array are discarded.\n+       *\n+       *  Positive arguments shift toward index 0, discarding elements [0, n).\n+       *  Negative arguments discard elements from the top of the array.\n+       *\n+       *  @param  n  Number of element positions to shift.\n+       *  @return  New valarray with elements in shifted positions.\n+       */\n       valarray<_Tp> shift (int) const;\n+\n+      /**\n+       *  @brief  Return a rotated array.\n+       *\n+       *  A new valarray is constructed as a copy of this array with elements\n+       *  in shifted positions.  For an element with index i, the new position\n+       *  is (i - n) % size().  The new valarray is the same size as the\n+       *  current one.  Elements that are shifted beyond the array bounds are\n+       *  shifted into the other end of the array.  No elements are lost.\n+       *\n+       *  Positive arguments shift toward index 0, wrapping around the top.\n+       *  Negative arguments shift towards the top, wrapping around to 0.\n+       *\n+       *  @param  n  Number of element positions to rotate.\n+       *  @return  New valarray with elements in shifted positions.\n+       */\n       valarray<_Tp> cshift(int) const;\n+\n+      /**\n+       *  @brief  Apply a function to the array.\n+       *\n+       *  Returns a new valarray with elements assigned to the result of\n+       *  applying func to the corresponding element of this array.  The new\n+       *  array is the same size as this one.\n+       *\n+       *  @param  func  Function of Tp returning Tp to apply.\n+       *  @return  New valarray with transformed elements.\n+       */\n       _Expr<_ValFunClos<_ValArray,_Tp>,_Tp> apply(_Tp func(_Tp)) const;\n+\n+      /**\n+       *  @brief  Apply a function to the array.\n+       *\n+       *  Returns a new valarray with elements assigned to the result of\n+       *  applying func to the corresponding element of this array.  The new\n+       *  array is the same size as this one.\n+       *\n+       *  @param  func  Function of const Tp& returning Tp to apply.\n+       *  @return  New valarray with transformed elements.\n+       */\n       _Expr<_RefFunClos<_ValArray,_Tp>,_Tp> apply(_Tp func(const _Tp&)) const;\n+\n+      /**\n+       *  @brief  Resize array.\n+       *\n+       *  Resize this array to be @a size and set all elements to @a c.  All\n+       *  references and iterators are invalidated.\n+       *\n+       *  @param  size  New array size.\n+       *  @param  c  New value for all elements.\n+       */\n       void resize(size_t __size, _Tp __c = _Tp());\n \n     private:"}]}