{"sha": "69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjlkM2M5YTQzZTVlOWVjOTlkNTExN2EwYzA4MGIxYWQ0NWNmNDVkMA==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2004-11-23T02:02:38Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2004-11-23T02:02:38Z"}, "message": "re PR libfortran/15960 (missing function 'finite' on HP-UX 11.11)\n\n\tPR libfortran/15960\n\t* configure.ac: Check for finite in libm.\n\t* libgfortran.h: Define isfinite macro if not defined.\n\t* intrinsics/c99_functions.c: Use defined(fpclassify) instead of\n\tHAVE_FPCLASSIFY.\n\t* io/write.c (write_float): Use isfinite instead of finite.\n\t* configure, config.h.in: Rebuilt.\n\nFrom-SVN: r91064", "tree": {"sha": "61d4ad0cd550c3f974a87cf3001edc98e1bbd22a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61d4ad0cd550c3f974a87cf3001edc98e1bbd22a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0/comments", "author": null, "committer": null, "parents": [{"sha": "b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b52d5eaa44789d6c9593c12d7d1c1419fe59b0c1"}], "stats": {"total": 123, "additions": 118, "deletions": 5}, "files": [{"sha": "1228da1357ff2572d0b7300db7805aa9fef853ec", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0", "patch": "@@ -1,3 +1,13 @@\n+2004-11-22  Steven Bosscher  <stevenb@suse.de>\n+\n+\tPR libfortran/15960\n+\t* configure.ac: Check for finite in libm.\n+\t* libgfortran.h: Define isfinite macro if not defined.\n+\t* intrinsics/c99_functions.c: Use defined(fpclassify) instead of\n+\tHAVE_FPCLASSIFY.\n+\t* io/write.c (write_float): Use isfinite instead of finite.\n+\t* configure, config.h.in: Rebuilt.\n+\n 2004-11-20  Roger Sayle  <roger@eyesopen.com>\n \n \t* io/write.c (write_float, list_formatted_write): Fix indentation."}, {"sha": "3730a96d67f054edb8484d91e29577778700af4c", "filename": "libgfortran/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0/libgfortran%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0/libgfortran%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig.h.in?ref=69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0", "patch": "@@ -45,6 +45,9 @@\n /* libm includes expf */\n #undef HAVE_EXPF\n \n+/* libm includes finite */\n+#undef HAVE_FINITE\n+\n /* libm includes floorf */\n #undef HAVE_FLOORF\n "}, {"sha": "cfd4f175e10a632b712873511633384396237705", "filename": "libgfortran/configure", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0/libgfortran%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0/libgfortran%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure?ref=69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0", "patch": "@@ -10323,6 +10323,85 @@ _ACEOF\n fi\n \n \n+# Fallback in case isfinite is not available.\n+echo \"$as_me:$LINENO: checking for finite in -lm\" >&5\n+echo $ECHO_N \"checking for finite in -lm... $ECHO_C\" >&6\n+if test \"${ac_cv_lib_m_finite+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  ac_check_lib_save_LIBS=$LIBS\n+LIBS=\"-lm  $LIBS\"\n+if test x$gcc_no_link = xyes; then\n+  { { echo \"$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES.\" >&5\n+echo \"$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES.\" >&2;}\n+   { (exit 1); exit 1; }; }\n+fi\n+cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+\n+/* Override any gcc2 internal prototype to avoid an error.  */\n+#ifdef __cplusplus\n+extern \"C\"\n+#endif\n+/* We use char because int might match the return type of a gcc2\n+   builtin and then its argument prototype would still apply.  */\n+char finite ();\n+int\n+main ()\n+{\n+finite ();\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext conftest$ac_exeext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_link\\\"\") >&5\n+  (eval $ac_link) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest$ac_exeext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_lib_m_finite=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_lib_m_finite=no\n+fi\n+rm -f conftest.err conftest.$ac_objext \\\n+      conftest$ac_exeext conftest.$ac_ext\n+LIBS=$ac_check_lib_save_LIBS\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_lib_m_finite\" >&5\n+echo \"${ECHO_T}$ac_cv_lib_m_finite\" >&6\n+if test $ac_cv_lib_m_finite = yes; then\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_FINITE 1\n+_ACEOF\n+\n+fi\n+\n+\n # Let the user override this\n # Check whether --enable-cmath or --disable-cmath was given.\n if test \"${enable_cmath+set}\" = set; then"}, {"sha": "76d7ae1a722df5546edfa1589431666daeb39d00", "filename": "libgfortran/configure.ac", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0/libgfortran%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0/libgfortran%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.ac?ref=69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0", "patch": "@@ -210,6 +210,9 @@ AC_CHECK_LIB([m],[y1f],[AC_DEFINE([HAVE_Y1F],[1],[libm includes y1f])])\n AC_CHECK_LIB([m],[yn],[AC_DEFINE([HAVE_YN],[1],[libm includes yn])])\n AC_CHECK_LIB([m],[ynf],[AC_DEFINE([HAVE_YNF],[1],[libm includes ynf])])\n \n+# Fallback in case isfinite is not available.\n+AC_CHECK_LIB([m],[finite],[AC_DEFINE([HAVE_FINITE],[1],[libm includes finite])])\n+\n # Let the user override this\n AC_ARG_ENABLE(cmath,\n \tAC_HELP_STRING([--enable-cmath],[Include complex math functions]),"}, {"sha": "2c11ceb6a89053385a6e2d32892b37a958f713c6", "filename": "libgfortran/intrinsics/c99_functions.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0/libgfortran%2Fintrinsics%2Fc99_functions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0/libgfortran%2Fintrinsics%2Fc99_functions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fc99_functions.c?ref=69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0", "patch": "@@ -254,7 +254,7 @@ powf(float x, float y)\n }\n #endif\n \n-/* Note that if HAVE_FPCLASSIFY is not defined, then NaN is not handled */\n+/* Note that if fpclassify is not defined, then NaN is not handled */\n \n /* Algorithm by Steven G. Kargl.  */\n \n@@ -266,7 +266,7 @@ double\n round(double x)\n {\n    double t;\n-#ifdef HAVE_FPCLASSIFY\n+#if defined(fpclassify)\n    int i;\n    i = fpclassify(x);\n    if (i == FP_INFINITE || i == FP_NAN)\n@@ -298,7 +298,7 @@ float\n roundf(float x)\n {\n    float t;\n-#ifdef HAVE_FPCLASSIFY\n+#if defined(fpclassify)\n    int i;\n \n    i = fpclassify(x);"}, {"sha": "fd4665b4542da1f56dd1fca4294b87d11fe73c0d", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0", "patch": "@@ -654,7 +654,7 @@ write_float (fnode *f, const char *source, int len)\n \n   if (f->format != FMT_B && f->format != FMT_O && f->format != FMT_Z)\n     {\n-      res = finite (n);\n+      res = isfinite (n);\n       if (res == 0)\n \t{\n \t  nb =  f->u.real.w;"}, {"sha": "508a5df019c05cc171d8387a3146bee0ef9a784e", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=69d3c9a43e5e9ec99d5117a0c080b1ad45cf45d0", "patch": "@@ -82,6 +82,24 @@ typedef off_t gfc_offset;\n #define offsetof(TYPE, MEMBER)  ((size_t) &((TYPE *) 0)->MEMBER)\n #endif\n \n+/* The isfinite macro is only available with C99, but some non-C99\n+   systems still provide fpclassify, and there is a `finite' function\n+   in BSD.  When isfinite is not available, try to use one of the\n+   alternatives, or bail out.  */\n+#if !defined(isfinite)\n+static inline int\n+isfinite (double x)\n+{\n+#if defined(fpclassify)\n+  return (fpclassify(x) != FP_NAN && fpclassify(x) != FP_INFINITE);\n+#elif defined(HAVE_FINITE)\n+  return finite (x);\n+#else\n+#error \"libgfortran needs isfinite, fpclassify, or finite\"\n+#endif\n+}\n+#endif /* !defined(isfinite)  */\n+\n /* TODO: find the C99 version of these an move into above ifdef.  */\n #define REALPART(z) (__real__(z))\n #define IMAGPART(z) (__imag__(z))\n@@ -441,5 +459,5 @@ typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, void) array_t;\n #define size0 prefix(size0)\n index_type size0 (const array_t * array); \n \n-#endif\n+#endif  /* LIBGFOR_H  */\n "}]}