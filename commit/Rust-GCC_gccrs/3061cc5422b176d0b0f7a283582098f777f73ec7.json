{"sha": "3061cc5422b176d0b0f7a283582098f777f73ec7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA2MWNjNTQyMmIxNzZkMGIwZjdhMjgzNTgyMDk4Zjc3N2Y3M2VjNw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-27T10:27:03Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-27T10:27:03Z"}, "message": "(requires_inout): Renamed from requires_inout_p and returns number of alternatives that require a match.\n\n(requires_inout): Renamed from requires_inout_p and returns number of\nalternatives that require a match.\n(block_alloc): Use new function and handle case where all alternatives have\nsome operand that must match operand 0.\n\nFrom-SVN: r7358", "tree": {"sha": "79f01100754fd17da000c7e09f3c752aef5eb51e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79f01100754fd17da000c7e09f3c752aef5eb51e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3061cc5422b176d0b0f7a283582098f777f73ec7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3061cc5422b176d0b0f7a283582098f777f73ec7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3061cc5422b176d0b0f7a283582098f777f73ec7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3061cc5422b176d0b0f7a283582098f777f73ec7/comments", "author": null, "committer": null, "parents": [{"sha": "a6ba1470c243802732938fb4afd46828b0647308", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6ba1470c243802732938fb4afd46828b0647308", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6ba1470c243802732938fb4afd46828b0647308"}], "stats": {"total": 63, "additions": 47, "deletions": 16}, "files": [{"sha": "107ab9c4f3e0ce8a0425e50c9a40d5847da9e195", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 47, "deletions": 16, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3061cc5422b176d0b0f7a283582098f777f73ec7/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3061cc5422b176d0b0f7a283582098f777f73ec7/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=3061cc5422b176d0b0f7a283582098f777f73ec7", "patch": "@@ -263,7 +263,7 @@ static int find_free_reg\tPROTO((enum reg_class, enum machine_mode,\n static void mark_life\t\tPROTO((int, enum machine_mode, int));\n static void post_mark_life\tPROTO((int, enum machine_mode, int, int, int));\n static int no_conflict_p\tPROTO((rtx, rtx, rtx));\n-static int requires_inout_p\tPROTO((char *));\n+static int requires_inout\tPROTO((char *));\n \f\n /* Allocate a new quantity (new within current basic block)\n    for register number REGNO which is born at index BIRTH\n@@ -1207,13 +1207,21 @@ block_alloc (b)\n \t      )\n \t    {\n #ifdef REGISTER_CONSTRAINTS\n+\t      /* If non-negative, is an operand that must match operand 0.  */\n \t      int must_match_0 = -1;\n-\n+\t      /* Counts number of alternatives that require a match with\n+\t\t operand 0.  */\n+\t      int n_matching_alts = 0;\n \n \t      for (i = 1; i < insn_n_operands[insn_code_number]; i++)\n-\t\tif (requires_inout_p\n-\t\t    (insn_operand_constraint[insn_code_number][i]))\n-\t\t  must_match_0 = i;\n+\t\t{\n+\t\t  char *p = insn_operand_constraint[insn_code_number][i];\n+\t\t  int this_match = (requires_inout (p));\n+\n+\t\t  n_matching_alts += this_match;\n+\t\t  if (this_match == insn_n_alternatives[insn_code_number])\n+\t\t    must_match_0 = i;\n+\t\t}\n #endif\n \n \t      r0 = recog_operand[0];\n@@ -1230,6 +1238,16 @@ block_alloc (b)\n \t\t      && ! (i == must_match_0 - 1\n \t\t\t    && insn_operand_constraint[insn_code_number][i][0] == '%'))\n \t\t    continue;\n+\n+\t\t  /* Likewise if each alternative has some operand that\n+\t\t     must match operand zero.  In that case, skip any \n+\t\t     operand that doesn't list operand 0 since we know that\n+\t\t     the operand always conflicts with operand 0.  We\n+\t\t     ignore commutatity in this case to keep things simple.  */\n+\t\t  if (n_matching_alts == insn_n_alternatives[insn_code_number]\n+\t\t      && (0 == requires_inout\n+\t\t\t  (insn_operand_constraint[insn_code_number][i])))\n+\t\t    continue;\n #endif\n \n \t\t  r1 = recog_operand[i];\n@@ -2265,26 +2283,25 @@ no_conflict_p (insn, r0, r1)\n \f\n #ifdef REGISTER_CONSTRAINTS\n \n-/* Return 1 if the constraint string P indicates that the a the operand\n-   must be equal to operand 0 and that no register is acceptable.  */\n+/* Return the number of alternatives for which the constraint string P\n+   indicates that the operand must be equal to operand 0 and that no register\n+   is acceptable.  */\n \n static int\n-requires_inout_p (p)\n+requires_inout (p)\n      char *p;\n {\n   char c;\n   int found_zero = 0;\n+  int reg_allowed = 0;\n+  int num_matching_alts = 0;\n \n   while (c = *p++)\n     switch (c)\n       {\n-      case '0':\n-\tfound_zero = 1;\n-\tbreak;\n-\n       case '=':  case '+':  case '?':\n       case '#':  case '&':  case '!':\n-      case '*':  case '%':  case ',':\n+      case '*':  case '%':\n       case '1':  case '2':  case '3':  case '4':\n       case 'm':  case '<':  case '>':  case 'V':  case 'o':\n       case 'E':  case 'F':  case 'G':  case 'H':\n@@ -2298,14 +2315,28 @@ requires_inout_p (p)\n \t/* These don't say anything we care about.  */\n \tbreak;\n \n+      case ',':\n+\tif (found_zero && ! reg_allowed)\n+\t  num_matching_alts++;\n+\n+\tfound_zero = reg_allowed = 0;\n+\tbreak;\n+\n+      case '0':\n+\tfound_zero = 1;\n+\tbreak;\n+\n       case 'p':\n       case 'g': case 'r':\n       default:\n-\t/* These mean a register is allowed.  Fail if so.  */\n-\treturn 0;\n+\treg_allowed = 1;\n+\tbreak;\n       }\n \n-  return found_zero;\n+  if (found_zero && ! reg_allowed)\n+    num_matching_alts++;\n+\n+  return num_matching_alts;\n }\n #endif /* REGISTER_CONSTRAINTS */\n \f"}]}