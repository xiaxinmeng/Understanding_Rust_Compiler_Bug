{"sha": "c4f17c6f58d35c40b776b8cb0d9eb185f0a96538", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzRmMTdjNmY1OGQzNWM0MGI3NzZiOGNiMGQ5ZWIxODVmMGE5NjUzOA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2002-09-30T11:59:42Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2002-09-30T11:59:42Z"}, "message": "configure.in: Add s390x-*-linux-* target.\n\n\t* configure.in: Add s390x-*-linux-* target.\n\t* configure: Regenerate.\n\t* include/ffi.h.in: Define S390X for s390x targets.\n\t(FFI_CLOSURES): Define for s390/s390x.\n\t(FFI_TRAMPOLINE_SIZE): Likewise.\n\t(FFI_NATIVE_RAW_API): Likewise.\n\t* src/prep_cif.c (ffi_prep_cif): Do not compute stack space for s390.\n\t* src/types.c (FFI_TYPE_POINTER): Use 8-byte pointers on s390x.\n\t* src/s390/ffi.c: Major rework of existing code.  Add support for\n\ts390x targets.  Add closure support.\n\t* src/s390/sysv.S: Likewise.\n\nFrom-SVN: r57646", "tree": {"sha": "3f3009c6e05fa775a22de8c30178ef4f3c765709", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f3009c6e05fa775a22de8c30178ef4f3c765709"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4f17c6f58d35c40b776b8cb0d9eb185f0a96538", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4f17c6f58d35c40b776b8cb0d9eb185f0a96538", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4f17c6f58d35c40b776b8cb0d9eb185f0a96538", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4f17c6f58d35c40b776b8cb0d9eb185f0a96538/comments", "author": null, "committer": null, "parents": [{"sha": "b93a0fe6baa4f264b89d45434962c0bd52cfaa4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b93a0fe6baa4f264b89d45434962c0bd52cfaa4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b93a0fe6baa4f264b89d45434962c0bd52cfaa4b"}], "stats": {"total": 1666, "additions": 1030, "deletions": 636}, "files": [{"sha": "c2d664d3f8452e1def174a9ecc2d11c2fc434bc3", "filename": "libffi/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4f17c6f58d35c40b776b8cb0d9eb185f0a96538/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4f17c6f58d35c40b776b8cb0d9eb185f0a96538/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=c4f17c6f58d35c40b776b8cb0d9eb185f0a96538", "patch": "@@ -1,3 +1,17 @@\n+2002-09-30  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* configure.in: Add s390x-*-linux-* target.\n+\t* configure: Regenerate.\n+\t* include/ffi.h.in: Define S390X for s390x targets.\n+\t(FFI_CLOSURES): Define for s390/s390x.\n+\t(FFI_TRAMPOLINE_SIZE): Likewise.\n+\t(FFI_NATIVE_RAW_API): Likewise.\n+\t* src/prep_cif.c (ffi_prep_cif): Do not compute stack space for s390.\n+\t* src/types.c (FFI_TYPE_POINTER): Use 8-byte pointers on s390x.\n+\t* src/s390/ffi.c: Major rework of existing code.  Add support for \n+\ts390x targets.  Add closure support.\n+\t* src/s390/sysv.S: Likewise.\n+\n 2002-09-29  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* src/arm/sysv.S: Fix typo."}, {"sha": "37ea9b48dd0792d865afb4c383529a6cc75cbe5c", "filename": "libffi/configure", "status": "modified", "additions": 67, "deletions": 66, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4f17c6f58d35c40b776b8cb0d9eb185f0a96538/libffi%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4f17c6f58d35c40b776b8cb0d9eb185f0a96538/libffi%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure?ref=c4f17c6f58d35c40b776b8cb0d9eb185f0a96538", "patch": "@@ -2431,6 +2431,7 @@ powerpc-*-aix*) TARGET=POWERPC_AIX; TARGETDIR=powerpc;;\n rs6000-*-aix*) TARGET=POWERPC_AIX; TARGETDIR=powerpc;;\n arm*-*-linux-*) TARGET=ARM; TARGETDIR=arm;;\n s390-*-linux-*) TARGET=S390; TARGETDIR=s390;;\n+s390x-*-linux-*) TARGET=S390; TARGETDIR=s390;;\n x86_64-*-linux*) TARGET=X86_64; TARGETDIR=x86;;\n sh-*-linux* | sh[34]*-*-linux*) TARGET=SH; TARGETDIR=sh;;\n esac\n@@ -2589,7 +2590,7 @@ if test x$TARGET = xMIPS_LINUX; then\n fi\n \n echo $ac_n \"checking how to run the C preprocessor\"\"... $ac_c\" 1>&6\n-echo \"configure:2593: checking how to run the C preprocessor\" >&5\n+echo \"configure:2594: checking how to run the C preprocessor\" >&5\n # On Suns, sometimes $CPP names a directory.\n if test -n \"$CPP\" && test -d \"$CPP\"; then\n   CPP=\n@@ -2604,13 +2605,13 @@ else\n   # On the NeXT, cc -E runs the code through the compiler's parser,\n   # not just through cpp.\n   cat > conftest.$ac_ext <<EOF\n-#line 2608 \"configure\"\n+#line 2609 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2614: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2615: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2621,13 +2622,13 @@ else\n   rm -rf conftest*\n   CPP=\"${CC-cc} -E -traditional-cpp\"\n   cat > conftest.$ac_ext <<EOF\n-#line 2625 \"configure\"\n+#line 2626 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2631: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2632: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2638,13 +2639,13 @@ else\n   rm -rf conftest*\n   CPP=\"${CC-cc} -nologo -E\"\n   cat > conftest.$ac_ext <<EOF\n-#line 2642 \"configure\"\n+#line 2643 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2648: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2649: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2669,20 +2670,20 @@ fi\n echo \"$ac_t\"\"$CPP\" 1>&6\n \n echo $ac_n \"checking for ANSI C header files\"\"... $ac_c\" 1>&6\n-echo \"configure:2673: checking for ANSI C header files\" >&5\n+echo \"configure:2674: checking for ANSI C header files\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_stdc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2678 \"configure\"\n+#line 2679 \"configure\"\n #include \"confdefs.h\"\n #include <stdlib.h>\n #include <stdarg.h>\n #include <string.h>\n #include <float.h>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2686: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2687: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -2699,7 +2700,7 @@ rm -f conftest*\n if test $ac_cv_header_stdc = yes; then\n   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.\n cat > conftest.$ac_ext <<EOF\n-#line 2703 \"configure\"\n+#line 2704 \"configure\"\n #include \"confdefs.h\"\n #include <string.h>\n EOF\n@@ -2717,7 +2718,7 @@ fi\n if test $ac_cv_header_stdc = yes; then\n   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.\n cat > conftest.$ac_ext <<EOF\n-#line 2721 \"configure\"\n+#line 2722 \"configure\"\n #include \"confdefs.h\"\n #include <stdlib.h>\n EOF\n@@ -2738,7 +2739,7 @@ if test \"$cross_compiling\" = yes; then\n   :\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2742 \"configure\"\n+#line 2743 \"configure\"\n #include \"confdefs.h\"\n #include <ctype.h>\n #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')\n@@ -2749,7 +2750,7 @@ if (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);\n exit (0); }\n \n EOF\n-if { (eval echo configure:2753: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:2754: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   :\n else\n@@ -2775,12 +2776,12 @@ fi\n for ac_func in memcpy\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:2779: checking for $ac_func\" >&5\n+echo \"configure:2780: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2784 \"configure\"\n+#line 2785 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -2803,7 +2804,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2807: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2808: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -2830,19 +2831,19 @@ done\n # The Ultrix 4.2 mips builtin alloca declared by alloca.h only works\n # for constant arguments.  Useless!\n echo $ac_n \"checking for working alloca.h\"\"... $ac_c\" 1>&6\n-echo \"configure:2834: checking for working alloca.h\" >&5\n+echo \"configure:2835: checking for working alloca.h\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_alloca_h'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2839 \"configure\"\n+#line 2840 \"configure\"\n #include \"confdefs.h\"\n #include <alloca.h>\n int main() {\n char *p = alloca(2 * sizeof(int));\n ; return 0; }\n EOF\n-if { (eval echo configure:2846: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2847: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_header_alloca_h=yes\n else\n@@ -2863,12 +2864,12 @@ EOF\n fi\n \n echo $ac_n \"checking for alloca\"\"... $ac_c\" 1>&6\n-echo \"configure:2867: checking for alloca\" >&5\n+echo \"configure:2868: checking for alloca\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_alloca_works'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2872 \"configure\"\n+#line 2873 \"configure\"\n #include \"confdefs.h\"\n \n #ifdef __GNUC__\n@@ -2896,7 +2897,7 @@ int main() {\n char *p = (char *) alloca(1);\n ; return 0; }\n EOF\n-if { (eval echo configure:2900: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2901: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_func_alloca_works=yes\n else\n@@ -2928,12 +2929,12 @@ EOF\n \n \n echo $ac_n \"checking whether alloca needs Cray hooks\"\"... $ac_c\" 1>&6\n-echo \"configure:2932: checking whether alloca needs Cray hooks\" >&5\n+echo \"configure:2933: checking whether alloca needs Cray hooks\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_os_cray'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2937 \"configure\"\n+#line 2938 \"configure\"\n #include \"confdefs.h\"\n #if defined(CRAY) && ! defined(CRAY2)\n webecray\n@@ -2958,12 +2959,12 @@ echo \"$ac_t\"\"$ac_cv_os_cray\" 1>&6\n if test $ac_cv_os_cray = yes; then\n for ac_func in _getb67 GETB67 getb67; do\n   echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:2962: checking for $ac_func\" >&5\n+echo \"configure:2963: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2967 \"configure\"\n+#line 2968 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -2986,7 +2987,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2990: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2991: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3013,15 +3014,15 @@ done\n fi\n \n echo $ac_n \"checking stack direction for C alloca\"\"... $ac_c\" 1>&6\n-echo \"configure:3017: checking stack direction for C alloca\" >&5\n+echo \"configure:3018: checking stack direction for C alloca\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_c_stack_direction'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n   ac_cv_c_stack_direction=0\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3025 \"configure\"\n+#line 3026 \"configure\"\n #include \"confdefs.h\"\n find_stack_direction ()\n {\n@@ -3040,7 +3041,7 @@ main ()\n   exit (find_stack_direction() < 0);\n }\n EOF\n-if { (eval echo configure:3044: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:3045: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_c_stack_direction=1\n else\n@@ -3063,13 +3064,13 @@ fi\n \n \n echo $ac_n \"checking size of short\"\"... $ac_c\" 1>&6\n-echo \"configure:3067: checking size of short\" >&5\n+echo \"configure:3068: checking size of short\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_short'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3073 \"configure\"\n+#line 3074 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3079,7 +3080,7 @@ int main() {\n switch (0) case 0: case (sizeof (short) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3083: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3084: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_short=$ac_size\n else\n@@ -3102,13 +3103,13 @@ EOF\n \n \n echo $ac_n \"checking size of int\"\"... $ac_c\" 1>&6\n-echo \"configure:3106: checking size of int\" >&5\n+echo \"configure:3107: checking size of int\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_int'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3112 \"configure\"\n+#line 3113 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3118,7 +3119,7 @@ int main() {\n switch (0) case 0: case (sizeof (int) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3122: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3123: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_int=$ac_size\n else\n@@ -3141,13 +3142,13 @@ EOF\n \n \n echo $ac_n \"checking size of long\"\"... $ac_c\" 1>&6\n-echo \"configure:3145: checking size of long\" >&5\n+echo \"configure:3146: checking size of long\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_long'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3151 \"configure\"\n+#line 3152 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3157,7 +3158,7 @@ int main() {\n switch (0) case 0: case (sizeof (long) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3161: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3162: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_long=$ac_size\n else\n@@ -3180,13 +3181,13 @@ EOF\n \n \n echo $ac_n \"checking size of long long\"\"... $ac_c\" 1>&6\n-echo \"configure:3184: checking size of long long\" >&5\n+echo \"configure:3185: checking size of long long\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_long_long'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3190 \"configure\"\n+#line 3191 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3196,7 +3197,7 @@ int main() {\n switch (0) case 0: case (sizeof (long long) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3200: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3201: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_long_long=$ac_size\n else\n@@ -3219,13 +3220,13 @@ EOF\n \n \n echo $ac_n \"checking size of float\"\"... $ac_c\" 1>&6\n-echo \"configure:3223: checking size of float\" >&5\n+echo \"configure:3224: checking size of float\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_float'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3229 \"configure\"\n+#line 3230 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3235,7 +3236,7 @@ int main() {\n switch (0) case 0: case (sizeof (float) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3239: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3240: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_float=$ac_size\n else\n@@ -3258,13 +3259,13 @@ EOF\n \n \n echo $ac_n \"checking size of double\"\"... $ac_c\" 1>&6\n-echo \"configure:3262: checking size of double\" >&5\n+echo \"configure:3263: checking size of double\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_double'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3268 \"configure\"\n+#line 3269 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3274,7 +3275,7 @@ int main() {\n switch (0) case 0: case (sizeof (double) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3278: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3279: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_double=$ac_size\n else\n@@ -3297,13 +3298,13 @@ EOF\n \n \n echo $ac_n \"checking size of long double\"\"... $ac_c\" 1>&6\n-echo \"configure:3301: checking size of long double\" >&5\n+echo \"configure:3302: checking size of long double\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_long_double'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3307 \"configure\"\n+#line 3308 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3313,7 +3314,7 @@ int main() {\n switch (0) case 0: case (sizeof (long double) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3317: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3318: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_long_double=$ac_size\n else\n@@ -3337,13 +3338,13 @@ EOF\n \n \n echo $ac_n \"checking size of void *\"\"... $ac_c\" 1>&6\n-echo \"configure:3341: checking size of void *\" >&5\n+echo \"configure:3342: checking size of void *\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_void_p'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3347 \"configure\"\n+#line 3348 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3353,7 +3354,7 @@ int main() {\n switch (0) case 0: case (sizeof (void *) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3357: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3358: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_void_p=$ac_size\n else\n@@ -3376,14 +3377,14 @@ EOF\n \n \n echo $ac_n \"checking whether byte ordering is bigendian\"\"... $ac_c\" 1>&6\n-echo \"configure:3380: checking whether byte ordering is bigendian\" >&5\n+echo \"configure:3381: checking whether byte ordering is bigendian\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_c_bigendian'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_cv_c_bigendian=unknown\n # See if sys/param.h defines the BYTE_ORDER macro.\n cat > conftest.$ac_ext <<EOF\n-#line 3387 \"configure\"\n+#line 3388 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #include <sys/param.h>\n@@ -3394,11 +3395,11 @@ int main() {\n #endif\n ; return 0; }\n EOF\n-if { (eval echo configure:3398: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3399: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   # It does; now see whether it defined to BIG_ENDIAN or not.\n cat > conftest.$ac_ext <<EOF\n-#line 3402 \"configure\"\n+#line 3403 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #include <sys/param.h>\n@@ -3409,7 +3410,7 @@ int main() {\n #endif\n ; return 0; }\n EOF\n-if { (eval echo configure:3413: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3414: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_c_bigendian=yes\n else\n@@ -3429,7 +3430,7 @@ if test \"$cross_compiling\" = yes; then\n    echo $ac_n \"cross-compiling... \" 2>&6 \n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3433 \"configure\"\n+#line 3434 \"configure\"\n #include \"confdefs.h\"\n main () {\n   /* Are we little or big endian?  From Harbison&Steele.  */\n@@ -3442,7 +3443,7 @@ main () {\n   exit (u.c[sizeof (long) - 1] == 1);\n }\n EOF\n-if { (eval echo configure:3446: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:3447: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_c_bigendian=no\n else\n@@ -3460,7 +3461,7 @@ fi\n echo \"$ac_t\"\"$ac_cv_c_bigendian\" 1>&6\n if test $ac_cv_c_bigendian = unknown; then\n echo $ac_n \"checking to probe for byte ordering\"\"... $ac_c\" 1>&6\n-echo \"configure:3464: checking to probe for byte ordering\" >&5\n+echo \"configure:3465: checking to probe for byte ordering\" >&5\n \n cat >conftest.c <<EOF\n short ascii_mm[] = { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };\n@@ -3510,7 +3511,7 @@ fi\n \n if test x$TARGET = xSPARC; then\n     echo $ac_n \"checking assembler and linker support unaligned pc related relocs\"\"... $ac_c\" 1>&6\n-echo \"configure:3514: checking assembler and linker support unaligned pc related relocs\" >&5\n+echo \"configure:3515: checking assembler and linker support unaligned pc related relocs\" >&5\n if eval \"test \\\"`echo '$''{'libffi_cv_as_sparc_ua_pcrel'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3520,14 +3521,14 @@ else\n \tCFLAGS=\"$CFLAGS -fpic\"\n \tLDFLAGS=\"$LDFLAGS -shared\"\n \tcat > conftest.$ac_ext <<EOF\n-#line 3524 \"configure\"\n+#line 3525 \"configure\"\n #include \"confdefs.h\"\n asm (\".text; foo: nop; .data; .align 4; .byte 0; .uaword %r_disp32(foo); .text\");\n int main() {\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3531: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3532: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   libffi_cv_as_sparc_ua_pcrel=yes\n else"}, {"sha": "9062dca9e7e235d13ad7c978241608758c94f910", "filename": "libffi/configure.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4f17c6f58d35c40b776b8cb0d9eb185f0a96538/libffi%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4f17c6f58d35c40b776b8cb0d9eb185f0a96538/libffi%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure.in?ref=c4f17c6f58d35c40b776b8cb0d9eb185f0a96538", "patch": "@@ -70,6 +70,7 @@ powerpc-*-aix*) TARGET=POWERPC_AIX; TARGETDIR=powerpc;;\n rs6000-*-aix*) TARGET=POWERPC_AIX; TARGETDIR=powerpc;;\n arm*-*-linux-*) TARGET=ARM; TARGETDIR=arm;;\n s390-*-linux-*) TARGET=S390; TARGETDIR=s390;;\n+s390x-*-linux-*) TARGET=S390; TARGETDIR=s390;;\n x86_64-*-linux*) TARGET=X86_64; TARGETDIR=x86;;\n sh-*-linux* | sh[[34]]*-*-linux*) TARGET=SH; TARGETDIR=sh;;\n esac"}, {"sha": "70a784226b180bca7b431ff3de7eab4e96f124f8", "filename": "libffi/include/ffi.h.in", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4f17c6f58d35c40b776b8cb0d9eb185f0a96538/libffi%2Finclude%2Fffi.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4f17c6f58d35c40b776b8cb0d9eb185f0a96538/libffi%2Finclude%2Fffi.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi.h.in?ref=c4f17c6f58d35c40b776b8cb0d9eb185f0a96538", "patch": "@@ -164,6 +164,12 @@ extern \"C\" {\n #endif\n #endif\n \n+#ifdef S390\n+#if defined (__s390x__)\n+#define S390X\n+#endif\n+#endif\n+\n #ifndef LIBFFI_ASM\n \n /* ---- Generic type definitions ----------------------------------------- */\n@@ -435,6 +441,16 @@ struct ffi_ia64_trampoline_struct {\n #define FFI_TRAMPOLINE_SIZE 24 /* see struct below */ \n #define FFI_NATIVE_RAW_API 0\n \n+#elif defined(S390)\n+\n+#define FFI_CLOSURES 1\n+#ifdef S390X\n+#define FFI_TRAMPOLINE_SIZE 32\n+#else\n+#define FFI_TRAMPOLINE_SIZE 16\n+#endif\n+#define FFI_NATIVE_RAW_API 0\n+\n #elif defined(SH)\n \n #define FFI_CLOSURES 1"}, {"sha": "d3c89c365e95ed15bcf8a9a752932ffeddacfe59", "filename": "libffi/src/prep_cif.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4f17c6f58d35c40b776b8cb0d9eb185f0a96538/libffi%2Fsrc%2Fprep_cif.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4f17c6f58d35c40b776b8cb0d9eb185f0a96538/libffi%2Fsrc%2Fprep_cif.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fprep_cif.c?ref=c4f17c6f58d35c40b776b8cb0d9eb185f0a96538", "patch": "@@ -103,9 +103,8 @@ ffi_status ffi_prep_cif(/*@out@*/ /*@partial@*/ ffi_cif *cif,\n   /* Perform a sanity check on the return type */\n   FFI_ASSERT(ffi_type_test(cif->rtype));\n \n-  /* x86-64 and s390 stack space allocation is handled in prep_machdep.\n-     TODO: Disable this for s390 too?  */\n-#if !defined M68K && !defined __x86_64__\n+  /* x86-64 and s390 stack space allocation is handled in prep_machdep.  */\n+#if !defined M68K && !defined __x86_64__ && !defined S390\n   /* Make space for the return structure pointer */\n   if (cif->rtype->type == FFI_TYPE_STRUCT\n #ifdef SPARC\n@@ -124,8 +123,7 @@ ffi_status ffi_prep_cif(/*@out@*/ /*@partial@*/ ffi_cif *cif,\n       if (((*ptr)->size == 0) && (initialize_aggregate((*ptr)) != FFI_OK))\n \treturn FFI_BAD_TYPEDEF;\n \n-      /* TODO: Disable this calculation for s390 too?  */\n-#ifndef __x86_64__\n+#if !defined __x86_64__ && !defined S390\n #ifdef SPARC\n       if (((*ptr)->type == FFI_TYPE_STRUCT\n \t   && ((*ptr)->size > 16 || cif->abi != FFI_V9))"}, {"sha": "b40bdd43fc972c29301bd26252a850ffbdb393e1", "filename": "libffi/src/s390/ffi.c", "status": "modified", "additions": 608, "deletions": 438, "changes": 1046, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4f17c6f58d35c40b776b8cb0d9eb185f0a96538/libffi%2Fsrc%2Fs390%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4f17c6f58d35c40b776b8cb0d9eb185f0a96538/libffi%2Fsrc%2Fs390%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fs390%2Fffi.c?ref=c4f17c6f58d35c40b776b8cb0d9eb185f0a96538", "patch": "@@ -39,50 +39,39 @@\n /*                           Defines                                  */\n /*                           -------                                  */\n /*====================================================================*/\n- \n-#define MAX_GPRARGS 5        /* Max. no. of GPR available             */\n-#define MAX_FPRARGS 2        /* Max. no. of FPR available             */\n- \n-#define STR_GPR     1        /* Structure will fit in 1 or 2 GPR      */\n-#define STR_FPR     2        /* Structure will fit in a FPR           */\n-#define STR_STACK   3        /* Structure needs to go on stack        */\n- \n+\n+/* Maximum number of GPRs available for argument passing.  */ \n+#define MAX_GPRARGS 5\n+\n+/* Maximum number of FPRs available for argument passing.  */ \n+#ifdef __s390x__\n+#define MAX_FPRARGS 4\n+#else\n+#define MAX_FPRARGS 2\n+#endif\n+\n+/* Round to multiple of 16.  */\n+#define ROUND_SIZE(size) (((size) + 15) & ~15)\n+\n+/* If these values change, sysv.S must be adapted!  */\n+#define FFI390_RET_VOID\t\t0\n+#define FFI390_RET_STRUCT\t1\n+#define FFI390_RET_FLOAT\t2\n+#define FFI390_RET_DOUBLE\t3\n+#define FFI390_RET_INT32\t4\n+#define FFI390_RET_INT64\t5\n+\n /*===================== End of Defines ===============================*/\n  \n-/*====================================================================*/\n-/*                            Types                                   */\n-/*                            -----                                   */\n-/*====================================================================*/\n- \n-typedef struct stackLayout\n-{\n-  int   *backChain;\n-  int   *endOfStack;\n-  int   glue[2];\n-  int   scratch[2];\n-  int   gprArgs[MAX_GPRARGS];\n-  int   notUsed;\n-  union\n-  {\n-    float  f;\n-    double d;\n-  } fprArgs[MAX_FPRARGS];\n-  int   unUsed[8];\n-  int   outArgs[100];\n-} stackLayout;\n- \n-/*======================== End of Types ==============================*/\n- \n /*====================================================================*/\n /*                          Prototypes                                */\n /*                          ----------                                */\n /*====================================================================*/\n  \n-void ffi_prep_args(stackLayout *, extended_cif *);\n-static int  ffi_check_struct(ffi_type *, unsigned int *);\n-static void ffi_insert_int(int, stackLayout *, int *, int *);\n-static void ffi_insert_int64(long long, stackLayout *, int *, int *);\n-static void ffi_insert_double(double, stackLayout *, int *, int *);\n+static void ffi_prep_args (unsigned char *, extended_cif *);\n+static int ffi_check_float_struct (ffi_type *);\n+void ffi_closure_helper_SYSV (ffi_closure *, unsigned long *, \n+\t\t\t      unsigned long long *, unsigned long *);\n  \n /*====================== End of Prototypes ===========================*/\n  \n@@ -91,499 +80,680 @@ static void ffi_insert_double(double, stackLayout *, int *, int *);\n /*                          ---------                                 */\n /*====================================================================*/\n  \n-extern void ffi_call_SYSV(void (*)(stackLayout *, extended_cif *),\n+extern void ffi_call_SYSV(unsigned,\n \t\t\t  extended_cif *,\n-\t\t\t  unsigned, unsigned,\n-\t\t\t  unsigned *,\n+\t\t\t  void (*)(unsigned char *, extended_cif *),\n+\t\t\t  unsigned,\n+\t\t\t  void *,\n \t\t\t  void (*fn)());\n+\n+extern void ffi_closure_SYSV(void);\n  \n /*====================== End of Externals ============================*/\n  \n /*====================================================================*/\n /*                                                                    */\n-/* Name     - ffi_check_struct.                                       */\n+/* Name     - ffi_check_struct_type.                                  */\n /*                                                                    */\n /* Function - Determine if a structure can be passed within a         */\n-/*            general or floating point register.                     */\n+/*            general purpose or floating point register.             */\n /*                                                                    */\n /*====================================================================*/\n  \n-int\n-ffi_check_struct(ffi_type *arg, unsigned int *strFlags)\n+static int\n+ffi_check_struct_type (ffi_type *arg)\n {\n- ffi_type *element;\n- int      i_Element;\n- \n- for (i_Element = 0; arg->elements[i_Element]; i_Element++) {\n-   element = arg->elements[i_Element];\n-   switch (element->type) {\n-   case FFI_TYPE_DOUBLE :\n-     *strFlags |= STR_FPR;\n-     break;\n-     \n-   case FFI_TYPE_STRUCT :\n-     *strFlags |= ffi_check_struct(element, strFlags);\n-     break;\n-     \n-   default :\n-     *strFlags |= STR_GPR;\n-   }\n- }\n- return (*strFlags);\n+  size_t size = arg->size;\n+\n+  /* If the struct has just one element, look at that element\n+     to find out whether to consider the struct as floating point.  */\n+  while (arg->type == FFI_TYPE_STRUCT \n+         && arg->elements[0] && !arg->elements[1])\n+    arg = arg->elements[0];\n+\n+  /* Structs of size 1, 2, 4, and 8 are passed in registers,\n+     just like the corresponding int/float types.  */\n+  switch (size)\n+    {\n+      case 1:\n+        return FFI_TYPE_UINT8;\n+\n+      case 2:\n+        return FFI_TYPE_UINT16;\n+\n+      case 4:\n+\tif (arg->type == FFI_TYPE_FLOAT)\n+          return FFI_TYPE_FLOAT;\n+\telse\n+\t  return FFI_TYPE_UINT32;\n+\n+      case 8:\n+\tif (arg->type == FFI_TYPE_DOUBLE)\n+          return FFI_TYPE_DOUBLE;\n+\telse\n+\t  return FFI_TYPE_UINT64;\n+\n+      default:\n+\tbreak;\n+    }\n+\n+  /* Other structs are passed via a pointer to the data.  */\n+  return FFI_TYPE_POINTER;\n }\n  \n /*======================== End of Routine ============================*/\n  \n /*====================================================================*/\n /*                                                                    */\n-/* Name     - ffi_insert_int.                                         */\n+/* Name     - ffi_prep_args.                                          */\n+/*                                                                    */\n+/* Function - Prepare parameters for call to function.                */\n /*                                                                    */\n-/* Function - Insert an integer parameter in a register if there are  */\n-/*            spares else on the stack.                               */\n+/* ffi_prep_args is called by the assembly routine once stack space   */\n+/* has been allocated for the function's arguments.                   */\n /*                                                                    */\n /*====================================================================*/\n  \n-void\n-ffi_insert_int(int gprValue, stackLayout *stack,\n-               int *intArgC, int *outArgC)\n+static void\n+ffi_prep_args (unsigned char *stack, extended_cif *ecif)\n {\n-  if (*intArgC < MAX_GPRARGS) {\n-    stack->gprArgs[*intArgC] = gprValue;\n-    *intArgC += 1;\n-  }\n-  else {\n-    stack->outArgs[*outArgC++] = gprValue;\n-    *outArgC += 1;\n-  }\n-}\n+  /* The stack space will be filled with those areas:\n+\n+\tFPR argument register save area     (highest addresses)\n+\tGPR argument register save area\n+\ttemporary struct copies\n+\toverflow argument area              (lowest addresses)\n+\n+     We set up the following pointers:\n+\n+        p_fpr: bottom of the FPR area (growing upwards)\n+\tp_gpr: bottom of the GPR area (growing upwards)\n+\tp_ov: bottom of the overflow area (growing upwards)\n+\tp_struct: top of the struct copy area (growing downwards)\n+\n+     All areas are kept aligned to twice the word size.  */\n+\n+  int gpr_off = ecif->cif->bytes;\n+  int fpr_off = gpr_off + ROUND_SIZE (MAX_GPRARGS * sizeof (long));\n+\n+  unsigned long long *p_fpr = (unsigned long long *)(stack + fpr_off);\n+  unsigned long *p_gpr = (unsigned long *)(stack + gpr_off);\n+  unsigned char *p_struct = (unsigned char *)p_gpr;\n+  unsigned long *p_ov = (unsigned long *)stack;\n+\n+  int n_fpr = 0;\n+  int n_gpr = 0;\n+  int n_ov = 0;\n+\n+  ffi_type **ptr;\n+  void **p_argv = ecif->avalue;\n+  int i;\n+ \n+  /* If we returning a structure then we set the first parameter register\n+     to the address of where we are returning this structure.  */\n+\n+  if (ecif->cif->flags == FFI390_RET_STRUCT)\n+    p_gpr[n_gpr++] = (unsigned long) ecif->rvalue;\n+\n+  /* Now for the arguments.  */\n  \n+  for (ptr = ecif->cif->arg_types, i = ecif->cif->nargs;\n+       i > 0;\n+       i--, ptr++, p_argv++)\n+    {\n+      void *arg = *p_argv;\n+      int type = (*ptr)->type;\n+\n+      /* Check how a structure type is passed.  */\n+      if (type == FFI_TYPE_STRUCT)\n+\t{\n+\t  type = ffi_check_struct_type (*ptr);\n+\n+\t  /* If we pass the struct via pointer, copy the data.  */\n+\t  if (type == FFI_TYPE_POINTER)\n+\t    {\n+\t      p_struct -= ROUND_SIZE ((*ptr)->size);\n+\t      memcpy (p_struct, (char *)arg, (*ptr)->size);\n+\t      arg = &p_struct;\n+\t    }\n+\t}\n+\n+      /* Pointers are passed like UINTs of the same size.  */\n+      if (type == FFI_TYPE_POINTER)\n+#ifdef __s390x__\n+\ttype = FFI_TYPE_UINT64;\n+#else\n+\ttype = FFI_TYPE_UINT32;\n+#endif\n+\n+      /* Now handle all primitive int/float data types.  */\n+      switch (type) \n+\t{\n+\t  case FFI_TYPE_DOUBLE:\n+\t    if (n_fpr < MAX_FPRARGS)\n+\t      p_fpr[n_fpr++] = *(unsigned long long *) arg;\n+\t    else\n+#ifdef __s390x__\n+\t      p_ov[n_ov++] = *(unsigned long *) arg;\n+#else\n+\t      p_ov[n_ov++] = ((unsigned long *) arg)[0],\n+\t      p_ov[n_ov++] = ((unsigned long *) arg)[1];\n+#endif\n+\t    break;\n+\t\n+\t  case FFI_TYPE_FLOAT:\n+\t    if (n_fpr < MAX_FPRARGS)\n+\t      p_fpr[n_fpr++] = (long long) *(unsigned int *) arg << 32;\n+\t    else\n+\t      p_ov[n_ov++] = *(unsigned int *) arg;\n+\t    break;\n+ \n+\t  case FFI_TYPE_UINT64:\n+\t  case FFI_TYPE_SINT64:\n+#ifdef __s390x__\n+\t    if (n_gpr < MAX_GPRARGS)\n+\t      p_gpr[n_gpr++] = *(unsigned long *) arg;\n+\t    else\n+\t      p_ov[n_ov++] = *(unsigned long *) arg;\n+#else\n+\t    if (n_gpr == MAX_GPRARGS-1)\n+\t      n_gpr = MAX_GPRARGS;\n+\t    if (n_gpr < MAX_GPRARGS)\n+\t      p_gpr[n_gpr++] = ((unsigned long *) arg)[0],\n+\t      p_gpr[n_gpr++] = ((unsigned long *) arg)[1];\n+\t    else\n+\t      p_ov[n_ov++] = ((unsigned long *) arg)[0],\n+\t      p_ov[n_ov++] = ((unsigned long *) arg)[1];\n+#endif\n+\t    break;\n+ \n+\t  case FFI_TYPE_UINT32:\n+\t    if (n_gpr < MAX_GPRARGS)\n+\t      p_gpr[n_gpr++] = *(unsigned int *) arg;\n+\t    else\n+\t      p_ov[n_ov++] = *(unsigned int *) arg;\n+\t    break;\n+ \n+\t  case FFI_TYPE_INT:\n+\t  case FFI_TYPE_SINT32:\n+\t    if (n_gpr < MAX_GPRARGS)\n+\t      p_gpr[n_gpr++] = *(signed int *) arg;\n+\t    else\n+\t      p_ov[n_ov++] = *(signed int *) arg;\n+\t    break;\n+ \n+\t  case FFI_TYPE_UINT16:\n+\t    if (n_gpr < MAX_GPRARGS)\n+\t      p_gpr[n_gpr++] = *(unsigned short *) arg;\n+\t    else\n+\t      p_ov[n_ov++] = *(unsigned short *) arg;\n+\t    break;\n+ \n+\t  case FFI_TYPE_SINT16:\n+\t    if (n_gpr < MAX_GPRARGS)\n+\t      p_gpr[n_gpr++] = *(signed short *) arg;\n+\t    else\n+\t      p_ov[n_ov++] = *(signed short *) arg;\n+\t    break;\n+\n+\t  case FFI_TYPE_UINT8:\n+\t    if (n_gpr < MAX_GPRARGS)\n+\t      p_gpr[n_gpr++] = *(unsigned char *) arg;\n+\t    else\n+\t      p_ov[n_ov++] = *(unsigned char *) arg;\n+\t    break;\n+ \n+\t  case FFI_TYPE_SINT8:\n+\t    if (n_gpr < MAX_GPRARGS)\n+\t      p_gpr[n_gpr++] = *(signed char *) arg;\n+\t    else\n+\t      p_ov[n_ov++] = *(signed char *) arg;\n+\t    break;\n+ \n+\t  default:\n+\t    FFI_ASSERT (0);\n+\t    break;\n+        }\n+    }\n+}\n+\n /*======================== End of Routine ============================*/\n  \n /*====================================================================*/\n /*                                                                    */\n-/* Name     - ffi_insert_int64.                                       */\n+/* Name     - ffi_prep_cif_machdep.                                   */\n /*                                                                    */\n-/* Function - Insert a long long parameter in registers if there are  */\n-/*            spares else on the stack.                               */\n+/* Function - Perform machine dependent CIF processing.               */\n /*                                                                    */\n /*====================================================================*/\n  \n-void\n-ffi_insert_int64(long long llngValue, stackLayout *stack,\n-                 int *intArgC, int *outArgC)\n+ffi_status\n+ffi_prep_cif_machdep(ffi_cif *cif)\n {\n+  size_t struct_size = 0;\n+  int n_gpr = 0;\n+  int n_fpr = 0;\n+  int n_ov = 0;\n+\n+  ffi_type **ptr;\n+  int i;\n+\n+  /* Determine return value handling.  */ \n+\n+  switch (cif->rtype->type)\n+    {\n+      /* Void is easy.  */\n+      case FFI_TYPE_VOID:\n+\tcif->flags = FFI390_RET_VOID;\n+\tbreak;\n+\n+      /* Structures are returned via a hidden pointer.  */\n+      case FFI_TYPE_STRUCT:\n+\tcif->flags = FFI390_RET_STRUCT;\n+\tn_gpr++;  /* We need one GPR to pass the pointer.  */\n+\tbreak; \n+\n+      /* Floating point values are returned in fpr 0.  */\n+      case FFI_TYPE_FLOAT:\n+\tcif->flags = FFI390_RET_FLOAT;\n+\tbreak;\n+\n+      case FFI_TYPE_DOUBLE:\n+\tcif->flags = FFI390_RET_DOUBLE;\n+\tbreak;\n+\n+      /* Integer values are returned in gpr 2 (and gpr 3\n+\t for 64-bit values on 31-bit machines).  */\n+      case FFI_TYPE_UINT64:\n+      case FFI_TYPE_SINT64:\n+\tcif->flags = FFI390_RET_INT64;\n+\tbreak;\n+\n+      case FFI_TYPE_INT:\n+      case FFI_TYPE_UINT32:\n+      case FFI_TYPE_SINT32:\n+      case FFI_TYPE_UINT16:\n+      case FFI_TYPE_SINT16:\n+      case FFI_TYPE_UINT8:\n+      case FFI_TYPE_SINT8:\n+\t/* These are to be extended to word size.  */\n+#ifdef __s390x__\n+\tcif->flags = FFI390_RET_INT64;\n+#else\n+\tcif->flags = FFI390_RET_INT32;\n+#endif\n+\tbreak;\n  \n-  if (*intArgC < (MAX_GPRARGS-1)) {\n-    memcpy(&stack->gprArgs[*intArgC],\n-\t   &llngValue, sizeof(long long));\t\n-    *intArgC += 2;\n-  }\n-  else {\n-    memcpy(&stack->outArgs[*outArgC],\n-\t   &llngValue, sizeof(long long));\n-    *outArgC += 2;\n-  }\n+      default:\n+        FFI_ASSERT (0);\n+        break;\n+    }\n+\n+  /* Now for the arguments.  */\n  \n+  for (ptr = cif->arg_types, i = cif->nargs;\n+       i > 0;\n+       i--, ptr++)\n+    {\n+      int type = (*ptr)->type;\n+\n+      /* Check how a structure type is passed.  */\n+      if (type == FFI_TYPE_STRUCT)\n+\t{\n+\t  type = ffi_check_struct_type (*ptr);\n+\n+\t  /* If we pass the struct via pointer, we must reserve space\n+\t     to copy its data for proper call-by-value semantics.  */\n+\t  if (type == FFI_TYPE_POINTER)\n+\t    struct_size += ROUND_SIZE ((*ptr)->size);\n+\t}\n+\n+      /* Now handle all primitive int/float data types.  */\n+      switch (type) \n+\t{\n+\t  /* The first MAX_FPRARGS floating point arguments\n+\t     go in FPRs, the rest overflow to the stack.  */\n+\n+\t  case FFI_TYPE_DOUBLE:\n+\t    if (n_fpr < MAX_FPRARGS)\n+\t      n_fpr++;\n+\t    else\n+\t      n_ov += sizeof (double) / sizeof (long);\n+\t    break;\n+\t\n+\t  case FFI_TYPE_FLOAT:\n+\t    if (n_fpr < MAX_FPRARGS)\n+\t      n_fpr++;\n+\t    else\n+\t      n_ov++;\n+\t    break;\n+\n+\t  /* On 31-bit machines, 64-bit integers are passed in GPR pairs,\n+\t     if one is still available, or else on the stack.  If only one\n+\t     register is free, skip the register (it won't be used for any \n+\t     subsequent argument either).  */\n+\t      \n+#ifndef __s390x__\n+\t  case FFI_TYPE_UINT64:\n+\t  case FFI_TYPE_SINT64:\n+\t    if (n_gpr == MAX_GPRARGS-1)\n+\t      n_gpr = MAX_GPRARGS;\n+\t    if (n_gpr < MAX_GPRARGS)\n+\t      n_gpr += 2;\n+\t    else\n+\t      n_ov += 2;\n+\t    break;\n+#endif\n+\n+\t  /* Everything else is passed in GPRs (until MAX_GPRARGS\n+\t     have been used) or overflows to the stack.  */\n+\n+\t  default: \n+\t    if (n_gpr < MAX_GPRARGS)\n+\t      n_gpr++;\n+\t    else\n+\t      n_ov++;\n+\t    break;\n+        }\n+    }\n+\n+  /* Total stack space as required for overflow arguments\n+     and temporary structure copies.  */\n+\n+  cif->bytes = ROUND_SIZE (n_ov * sizeof (long)) + struct_size;\n+ \n+  return FFI_OK;\n }\n  \n /*======================== End of Routine ============================*/\n  \n /*====================================================================*/\n /*                                                                    */\n-/* Name     - ffi_insert_double.                                      */\n+/* Name     - ffi_call.                                               */\n /*                                                                    */\n-/* Function - Insert a double parameter in a FP register if there is  */\n-/*            a spare else on the stack.                              */\n+/* Function - Call the FFI routine.                                   */\n /*                                                                    */\n /*====================================================================*/\n  \n void\n-ffi_insert_double(double dblValue, stackLayout *stack,\n-                  int *fprArgC, int *outArgC)\n+ffi_call(ffi_cif *cif,\n+\t void (*fn)(),\n+\t void *rvalue,\n+\t void **avalue)\n {\n+  int ret_type = cif->flags;\n+  extended_cif ecif;\n  \n-  if (*fprArgC < MAX_FPRARGS) {\n-    stack->fprArgs[*fprArgC].d = dblValue;\n-    *fprArgC += 1;\n-  }\n-  else {\n-    memcpy(&stack->outArgs[*outArgC],\n-\t   &dblValue,sizeof(double));\n-    *outArgC += 2;\n-  }\n- \n+  ecif.cif    = cif;\n+  ecif.avalue = avalue;\n+  ecif.rvalue = rvalue;\n+\n+  /* If we don't have a return value, we need to fake one.  */\n+  if (rvalue == NULL)\n+    {\n+      if (ret_type == FFI390_RET_STRUCT)\n+\tecif.rvalue = alloca (cif->rtype->size);\n+      else\n+\tret_type = FFI390_RET_VOID;\n+    } \n+\n+  switch (cif->abi)\n+    {\n+      case FFI_SYSV:\n+        ffi_call_SYSV (cif->bytes, &ecif, ffi_prep_args,\n+\t\t       ret_type, ecif.rvalue, fn);\n+        break;\n+ \n+      default:\n+        FFI_ASSERT (0);\n+        break;\n+    }\n }\n  \n /*======================== End of Routine ============================*/\n- \n+\n /*====================================================================*/\n /*                                                                    */\n-/* Name     - ffi_prep_args.                                          */\n+/* Name     - ffi_closure_helper_SYSV.                                */\n /*                                                                    */\n-/* Function - Prepare parameters for call to function.                */\n-/*                                                                    */\n-/* ffi_prep_args is called by the assembly routine once stack space   */\n-/* has been allocated for the function's arguments.                   */\n-/*                                                                    */\n-/* The stack layout we want looks like this:                          */\n-/* *------------------------------------------------------------*     */\n-/* |  0     | Back chain (a 0 here signifies end of back chain) |     */\n-/* +--------+---------------------------------------------------+     */\n-/* |  4     | EOS (end of stack, not used on Linux for S390)    |     */\n-/* +--------+---------------------------------------------------+     */\n-/* |  8     | Glue used in other linkage formats                |     */\n-/* +--------+---------------------------------------------------+     */\n-/* | 12     | Glue used in other linkage formats                |     */\n-/* +--------+---------------------------------------------------+     */\n-/* | 16     | Scratch area                                      |     */\n-/* +--------+---------------------------------------------------+     */\n-/* | 20     | Scratch area                                      |     */\n-/* +--------+---------------------------------------------------+     */\n-/* | 24     | GPR parameter register 1                          |     */\n-/* +--------+---------------------------------------------------+     */\n-/* | 28     | GPR parameter register 2                          |     */\n-/* +--------+---------------------------------------------------+     */\n-/* | 32     | GPR parameter register 3                          |     */\n-/* +--------+---------------------------------------------------+     */\n-/* | 36     | GPR parameter register 4                          |     */\n-/* +--------+---------------------------------------------------+     */\n-/* | 40     | GPR parameter register 5                          |     */\n-/* +--------+---------------------------------------------------+     */\n-/* | 44     | Unused                                            |     */\n-/* +--------+---------------------------------------------------+     */\n-/* | 48     | FPR parameter register 1                          |     */\n-/* +--------+---------------------------------------------------+     */\n-/* | 56     | FPR parameter register 2                          |     */\n-/* +--------+---------------------------------------------------+     */\n-/* | 64     | Unused                                            |     */\n-/* +--------+---------------------------------------------------+     */\n-/* | 96     | Outgoing args (length x)                          |     */\n-/* +--------+---------------------------------------------------+     */\n-/* | 96+x   | Copy area for structures (length y)               |     */\n-/* +--------+---------------------------------------------------+     */\n-/* | 96+x+y | Possible stack alignment                          |     */\n-/* *------------------------------------------------------------*     */\n+/* Function - Call a FFI closure target function.                     */\n /*                                                                    */\n /*====================================================================*/\n  \n void\n-ffi_prep_args(stackLayout *stack, extended_cif *ecif)\n+ffi_closure_helper_SYSV (ffi_closure *closure,\n+\t\t\t unsigned long *p_gpr,\n+\t\t\t unsigned long long *p_fpr,\n+\t\t\t unsigned long *p_ov)\n {\n-  const unsigned bytes = ecif->cif->bytes;\n-  const unsigned flags = ecif->cif->flags;\n- \n-  /*----------------------------------------------------------*/\n-  /* Pointer to the copy area on stack for structures         */\n-  /*----------------------------------------------------------*/\n-  char *copySpace = (char *) stack + bytes + sizeof(stackLayout);\n- \n-  /*----------------------------------------------------------*/\n-  /* Count of general and floating point register usage       */\n-  /*----------------------------------------------------------*/\n-  int intArgC = 0,\n-    fprArgC = 0,\n-    outArgC = 0;\n- \n-  int      i;\n+  unsigned long long ret_buffer;\n+\n+  void *rvalue = &ret_buffer;\n+  void **avalue;\n+  void **p_arg;\n+\n+  int n_gpr = 0;\n+  int n_fpr = 0;\n+  int n_ov = 0;\n+\n   ffi_type **ptr;\n-  void     **p_argv;\n-  size_t   structCopySize;\n-  unsigned gprValue, strFlags = 0;\n-  unsigned long long llngValue;\n-  double   dblValue;\n- \n+  int i;\n+\n+  /* Allocate buffer for argument list pointers.  */\n+\n+  p_arg = avalue = alloca (closure->cif->nargs * sizeof (void *));\n+\n+  /* If we returning a structure, pass the structure address \n+     directly to the target function.  Otherwise, have the target \n+     function store the return value to the GPR save area.  */\n+\n+  if (closure->cif->flags == FFI390_RET_STRUCT)\n+    rvalue = (void *) p_gpr[n_gpr++];\n+\n   /* Now for the arguments.  */\n-  p_argv  = ecif->avalue;\n- \n-  /*----------------------------------------------------------------------*/\n-  /* If we returning a structure then we set the first parameter register */\n-  /* to the address of where we are returning this structure              */\n-  /*----------------------------------------------------------------------*/\n-  if (flags == FFI_TYPE_STRUCT)\n-    stack->gprArgs[intArgC++] = (int) ecif->rvalue;\n- \n-  for (ptr = ecif->cif->arg_types, i = ecif->cif->nargs;\n+\n+  for (ptr = closure->cif->arg_types, i = closure->cif->nargs;\n        i > 0;\n-       i--, ptr++, p_argv++)\n+       i--, p_arg++, ptr++)\n     {\n-      switch ((*ptr)->type) {\n- \n+      int deref_struct_pointer = 0;\n+      int type = (*ptr)->type;\n+\n+      /* Check how a structure type is passed.  */\n+      if (type == FFI_TYPE_STRUCT)\n+\t{\n+\t  type = ffi_check_struct_type (*ptr);\n+\n+\t  /* If we pass the struct via pointer, remember to \n+\t     retrieve the pointer later.  */\n+\t  if (type == FFI_TYPE_POINTER)\n+\t    deref_struct_pointer = 1;\n+\t}\n+\n+      /* Pointers are passed like UINTs of the same size.  */\n+      if (type == FFI_TYPE_POINTER)\n+#ifdef __s390x__\n+\ttype = FFI_TYPE_UINT64;\n+#else\n+\ttype = FFI_TYPE_UINT32;\n+#endif\n+\n+      /* Now handle all primitive int/float data types.  */\n+      switch (type) \n+\t{\n+\t  case FFI_TYPE_DOUBLE:\n+\t    if (n_fpr < MAX_FPRARGS)\n+\t      *p_arg = &p_fpr[n_fpr++];\n+\t    else\n+\t      *p_arg = &p_ov[n_ov], \n+\t      n_ov += sizeof (double) / sizeof (long);\n+\t    break;\n+\t\n+\t  case FFI_TYPE_FLOAT:\n+\t    if (n_fpr < MAX_FPRARGS)\n+\t      *p_arg = &p_fpr[n_fpr++];\n+\t    else\n+\t      *p_arg = (char *)&p_ov[n_ov++] + sizeof (long) - 4;\n+\t    break;\n+ \n+\t  case FFI_TYPE_UINT64:\n+\t  case FFI_TYPE_SINT64:\n+#ifdef __s390x__\n+\t    if (n_gpr < MAX_GPRARGS)\n+\t      *p_arg = &p_gpr[n_gpr++];\n+\t    else\n+\t      *p_arg = &p_ov[n_ov++];\n+#else\n+\t    if (n_gpr == MAX_GPRARGS-1)\n+\t      n_gpr = MAX_GPRARGS;\n+\t    if (n_gpr < MAX_GPRARGS)\n+\t      *p_arg = &p_gpr[n_gpr], n_gpr += 2;\n+\t    else\n+\t      *p_arg = &p_ov[n_ov], n_ov += 2;\n+#endif\n+\t    break;\n+ \n+\t  case FFI_TYPE_INT:\n+\t  case FFI_TYPE_UINT32:\n+\t  case FFI_TYPE_SINT32:\n+\t    if (n_gpr < MAX_GPRARGS)\n+\t      *p_arg = (char *)&p_gpr[n_gpr++] + sizeof (long) - 4;\n+\t    else\n+\t      *p_arg = (char *)&p_ov[n_ov++] + sizeof (long) - 4;\n+\t    break;\n+ \n+\t  case FFI_TYPE_UINT16:\n+\t  case FFI_TYPE_SINT16:\n+\t    if (n_gpr < MAX_GPRARGS)\n+\t      *p_arg = (char *)&p_gpr[n_gpr++] + sizeof (long) - 2;\n+\t    else\n+\t      *p_arg = (char *)&p_ov[n_ov++] + sizeof (long) - 2;\n+\t    break;\n+\n+\t  case FFI_TYPE_UINT8:\n+\t  case FFI_TYPE_SINT8:\n+\t    if (n_gpr < MAX_GPRARGS)\n+\t      *p_arg = (char *)&p_gpr[n_gpr++] + sizeof (long) - 1;\n+\t    else\n+\t      *p_arg = (char *)&p_ov[n_ov++] + sizeof (long) - 1;\n+\t    break;\n+ \n+\t  default:\n+\t    FFI_ASSERT (0);\n+\t    break;\n+        }\n+\n+      /* If this is a struct passed via pointer, we need to\n+\t actually retrieve that pointer.  */\n+      if (deref_struct_pointer)\n+\t*p_arg = *(void **)*p_arg;\n+    }\n+\n+\n+  /* Call the target function.  */\n+  (closure->fun) (closure->cif, rvalue, avalue, closure->user_data);\n+\n+  /* Convert the return value.  */\n+  switch (closure->cif->rtype->type)\n+    {\n+      /* Void is easy, and so is struct.  */\n+      case FFI_TYPE_VOID:\n+      case FFI_TYPE_STRUCT:\n+\tbreak;\n+\n+      /* Floating point values are returned in fpr 0.  */\n       case FFI_TYPE_FLOAT:\n-\tif (fprArgC < MAX_FPRARGS)\n-\t  stack->fprArgs[fprArgC++].f = *(float *) *p_argv;\n-\telse\n-\t  stack->outArgs[outArgC++] = *(int *) *p_argv;\n+\tp_fpr[0] = (long long) *(unsigned int *) rvalue << 32;\n \tbreak;\n- \n+\n       case FFI_TYPE_DOUBLE:\n-\tdblValue = *(double *) *p_argv;\n-\tffi_insert_double(dblValue, stack, &fprArgC, &outArgC);\n+\tp_fpr[0] = *(unsigned long long *) rvalue;\n \tbreak;\n-\t\n+\n+      /* Integer values are returned in gpr 2 (and gpr 3\n+\t for 64-bit values on 31-bit machines).  */\n       case FFI_TYPE_UINT64:\n       case FFI_TYPE_SINT64:\n-\tllngValue = *(unsigned long long *) *p_argv;\n-\tffi_insert_int64(llngValue, stack, &intArgC, &outArgC);\n+#ifdef __s390x__\n+\tp_gpr[0] = *(unsigned long *) rvalue;\n+#else\n+\tp_gpr[0] = ((unsigned long *) rvalue)[0],\n+\tp_gpr[1] = ((unsigned long *) rvalue)[1];\n+#endif\n \tbreak;\n- \n-      case FFI_TYPE_UINT8:\n-\tgprValue = *(unsigned char *)*p_argv;\n-\tffi_insert_int(gprValue, stack, &intArgC, &outArgC);\n+\n+      case FFI_TYPE_UINT32:\n+\tp_gpr[0] = *(unsigned int *) rvalue;\n \tbreak;\n- \n-      case FFI_TYPE_SINT8:\n-\tgprValue = *(signed char *)*p_argv;\n-\tffi_insert_int(gprValue, stack, &intArgC, &outArgC);\n+\n+      case FFI_TYPE_INT:\n+      case FFI_TYPE_SINT32:\n+\tp_gpr[0] = *(signed int *) rvalue;\n \tbreak;\n- \n+\n       case FFI_TYPE_UINT16:\n-\tgprValue = *(unsigned short *)*p_argv;\n-\tffi_insert_int(gprValue, stack, &intArgC, &outArgC);\n+\tp_gpr[0] = *(unsigned short *) rvalue;\n \tbreak;\n- \n+\n       case FFI_TYPE_SINT16:\n-\tgprValue = *(signed short *)*p_argv;\n-\tffi_insert_int(gprValue, stack, &intArgC, &outArgC);\n+\tp_gpr[0] = *(signed short *) rvalue;\n \tbreak;\n- \n-      case FFI_TYPE_STRUCT:\n-\t/*--------------------------------------------------*/\n-\t/* If structure > 8 bytes then it goes on the stack */\n-\t/*--------------------------------------------------*/\n-\tif (((*ptr)->size > 8) ||\n-\t    ((*ptr)->size > 4  &&\n-\t     (*ptr)->size < 8))\n-\t  strFlags = STR_STACK;\n-\telse\n-\t  strFlags = ffi_check_struct((ffi_type *) *ptr, &strFlags);\n- \n-\tswitch (strFlags) {\n-\t/*-------------------------------------------*/\n-\t/* Structure that will fit in one or two GPR */\n-\t/*-------------------------------------------*/\n-\tcase STR_GPR :\n-\t  if ((*ptr)->size <= 4) {\n-\t    gprValue = *(unsigned int *) *p_argv;\n-\t    gprValue = gprValue >> ((4 - (*ptr)->size) * 8);\n-\t    ffi_insert_int(gprValue, stack, &intArgC, &outArgC);\n-\t  }\n-\t  else {\n-\t    llngValue = *(unsigned long long *) *p_argv;\n-\t    ffi_insert_int64(llngValue, stack, &intArgC, &outArgC);\n-\t  }\n-\t  break;\n- \n-\t/*-------------------------------------------*/\n-\t/* Structure that will fit in one FPR        */\n-\t/*-------------------------------------------*/\n-\tcase STR_FPR :\n-\t  dblValue = *(double *) *p_argv;\n-\t  ffi_insert_double(dblValue, stack, &fprArgC, &outArgC);\n-\t  break;\n- \n-\t/*-------------------------------------------*/\n-\t/* Structure that must be copied to stack    */\n-\t/*-------------------------------------------*/\n-\tdefault :\n-\t  structCopySize = (((*ptr)->size + 15) & ~0xF);\n-\t  copySpace -= structCopySize;\n-\t  memcpy(copySpace, (char *)*p_argv, (*ptr)->size);\n-\t  gprValue = (unsigned) copySpace;\n-\t  if (intArgC < MAX_GPRARGS)\n-\t    stack->gprArgs[intArgC++] = gprValue;\n-\t  else\n-\t    stack->outArgs[outArgC++] = gprValue;\n-\t}\n-\tbreak;\n- \n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-      case FFI_TYPE_LONGDOUBLE:\n-\tstructCopySize = (((*ptr)->size + 15) & ~0xF);\n-\tcopySpace -= structCopySize;\n-\tmemcpy(copySpace, (char *)*p_argv, (*ptr)->size);\n-\tgprValue = (unsigned) copySpace;\n-\tif (intArgC < MAX_GPRARGS)\n-\t  stack->gprArgs[intArgC++] = gprValue;\n-\telse\n-\t  stack->outArgs[outArgC++] = gprValue;\n+\n+      case FFI_TYPE_UINT8:\n+\tp_gpr[0] = *(unsigned char *) rvalue;\n \tbreak;\n-#endif\n- \n-      case FFI_TYPE_INT:\n-      case FFI_TYPE_UINT32:\n-      case FFI_TYPE_SINT32:\n-      case FFI_TYPE_POINTER:\n-\tgprValue = *(unsigned *)*p_argv;\n-\tif (intArgC < MAX_GPRARGS)\n-\t  stack->gprArgs[intArgC++] = gprValue;\n-\telse\n-\t  stack->outArgs[outArgC++] = gprValue;\n+\n+      case FFI_TYPE_SINT8:\n+\tp_gpr[0] = *(signed char *) rvalue;\n \tbreak;\n- \n-      }\n+\n+      default:\n+        FFI_ASSERT (0);\n+        break;\n     }\n }\n-\n-/*======================== End of Routine ============================*/\n  \n+/*======================== End of Routine ============================*/\n+\n /*====================================================================*/\n /*                                                                    */\n-/* Name     - ffi_prep_cif_machdep.                                   */\n+/* Name     - ffi_prep_closure.                                       */\n /*                                                                    */\n-/* Function - Perform machine dependent CIF processing.               */\n+/* Function - Prepare a FFI closure.                                  */\n /*                                                                    */\n /*====================================================================*/\n  \n ffi_status\n-ffi_prep_cif_machdep(ffi_cif *cif)\n+ffi_prep_closure (ffi_closure *closure,\n+                  ffi_cif *cif,\n+                  void (*fun) (ffi_cif *, void *, void **, void *),\n+                  void *user_data)\n {\n-  int i;\n-  ffi_type **ptr;\n-  unsigned bytes;\n-  int fpArgC  = 0,\n-    intArgC = 0;\n-  unsigned flags = 0;\n-  unsigned structCopySize = 0;\n- \n-  /*-----------------------------------------------------------------*/\n-  /* Extra space required in stack for overflow parameters.          */\n-  /*-----------------------------------------------------------------*/\n-  bytes = 0;\n- \n-  /*--------------------------------------------------------*/\n-  /* Return value handling.  The rules are as follows:\t    */\n-  /* - 32-bit (or less) integer values are returned in gpr2 */\n-  /* - Structures are returned as pointers in gpr2\t    */\n-  /* - 64-bit integer values are returned in gpr2 and 3\t    */\n-  /* - Single/double FP values are returned in fpr0\t    */\n-  /*--------------------------------------------------------*/\n-  flags = cif->rtype->type;\n- \n-  /*------------------------------------------------------------------------*/\n-  /* The first MAX_GPRARGS words of integer arguments, and the      \t    */\n-  /* first MAX_FPRARGS floating point arguments, go in registers; the rest  */\n-  /* goes on the stack.  Structures and long doubles (if not equivalent     */\n-  /* to double) are passed as a pointer to a copy of the structure.\t    */\n-  /* Stuff on the stack needs to keep proper alignment.  \t\t    */\n-  /*------------------------------------------------------------------------*/\n-  for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)\n-    {\n-      switch ((*ptr)->type)\n-\t{\n-\tcase FFI_TYPE_FLOAT:\n-\tcase FFI_TYPE_DOUBLE:\n-\t  fpArgC++;\n-\t  if (fpArgC > MAX_FPRARGS && intArgC%2 != 0)\n-\t    intArgC++;\n-\t  break;\n- \n-\tcase FFI_TYPE_UINT64:\n-\tcase FFI_TYPE_SINT64:\n-\t  /*----------------------------------------------------*/\n-\t  /* 'long long' arguments are passed as two words, but */\n-\t  /* either both words must fit in registers or both go */\n-\t  /* on the stack.  If they go on the stack, they must  */\n-\t  /* be 8-byte-aligned. \t\t\t \t      */\n-\t  /*----------------------------------------------------*/\n-\t  if ((intArgC == MAX_GPRARGS-1) ||\n-\t      (intArgC >= MAX_GPRARGS)   &&\n-\t      (intArgC%2 != 0))\n-\t    intArgC++;\n-\t  intArgC += 2;\n-\t  break;\n- \n-\tcase FFI_TYPE_STRUCT:\n-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\tcase FFI_TYPE_LONGDOUBLE:\n-#endif\n-\t  /*----------------------------------------------------*/\n-\t  /* We must allocate space for a copy of these to      */\n-\t  /* enforce pass-by-value. Pad the space up to a       */\n-\t  /* multiple of 16 bytes (the maximum alignment \t      */\n-\t  /* required for anything under the SYSV ABI). \t      */\n-\t  /*----------------------------------------------------*/\n-\t  structCopySize += ((*ptr)->size + 15) & ~0xF;\n-\t  /*----------------------------------------------------*/\n-\t  /* Fall through (allocate space for the pointer).     */\n-\t  /*----------------------------------------------------*/\n- \n-\tdefault:\n-\t  /*----------------------------------------------------*/\n-\t  /* Everything else is passed as a 4-byte word in a    */\n-\t  /* GPR either the object itself or a pointer to it.   */\n-\t  /*----------------------------------------------------*/\n-\t  intArgC++;\n-\t  break;\n-\t}\n-    }\n- \n-  /*-----------------------------------------------------------------*/\n-  /* Stack space.                                                    */\n-  /*-----------------------------------------------------------------*/\n-  if (intArgC > MAX_GPRARGS)\n-    bytes += (intArgC - MAX_GPRARGS) * sizeof(int);\n-  if (fpArgC > MAX_FPRARGS)\n-    bytes += (fpArgC - MAX_FPRARGS) * sizeof(double);\n- \n-  /*-----------------------------------------------------------------*/\n-  /* The stack space allocated needs to be a multiple of 16 bytes.   */\n-  /*-----------------------------------------------------------------*/\n-  bytes = (bytes + 15) & ~0xF;\n- \n-  /*-----------------------------------------------------------------*/\n-  /* Add in the space for the copied structures.                     */\n-  /*-----------------------------------------------------------------*/\n-  bytes += structCopySize;\n- \n-  cif->flags = flags;\n-  cif->bytes = bytes;\n+  FFI_ASSERT (cif->abi == FFI_SYSV);\n+\n+#ifndef __s390x__\n+  *(short *)&closure->tramp [0] = 0x0d10;   /* basr %r1,0 */\n+  *(short *)&closure->tramp [2] = 0x9801;   /* lm %r0,%r1,6(%r1) */\n+  *(short *)&closure->tramp [4] = 0x1006;\n+  *(short *)&closure->tramp [6] = 0x07f1;   /* br %r1 */\n+  *(long  *)&closure->tramp [8] = (long)closure;\n+  *(long  *)&closure->tramp[12] = (long)&ffi_closure_SYSV;\n+#else\n+  *(short *)&closure->tramp [0] = 0x0d10;   /* basr %r1,0 */\n+  *(short *)&closure->tramp [2] = 0xeb01;   /* lmg %r0,%r1,14(%r1) */\n+  *(short *)&closure->tramp [4] = 0x100e;\n+  *(short *)&closure->tramp [6] = 0x0004;\n+  *(short *)&closure->tramp [8] = 0x07f1;   /* br %r1 */\n+  *(long  *)&closure->tramp[16] = (long)closure;\n+  *(long  *)&closure->tramp[24] = (long)&ffi_closure_SYSV;\n+#endif \n+ \n+  closure->cif = cif;\n+  closure->user_data = user_data;\n+  closure->fun = fun;\n  \n   return FFI_OK;\n }\n- \n+\n /*======================== End of Routine ============================*/\n  \n-/*====================================================================*/\n-/*                                                                    */\n-/* Name     - ffi_call.                                               */\n-/*                                                                    */\n-/* Function - Call the FFI routine.                                   */\n-/*                                                                    */\n-/*====================================================================*/\n- \n-void\n-ffi_call(ffi_cif *cif,\n-\t void (*fn)(),\n-\t void *rvalue,\n-\t void **avalue)\n-{\n-  extended_cif ecif;\n- \n-  ecif.cif    = cif;\n-  ecif.avalue = avalue;\n- \n-  /*-----------------------------------------------------------------*/\n-  /* If the return value is a struct and we don't have a return      */\n-  /* value address then we need to make one                          */\n-  /*-----------------------------------------------------------------*/\n-  if ((rvalue == NULL) &&\n-      (cif->rtype->type == FFI_TYPE_STRUCT))\n-    ecif.rvalue = alloca(cif->rtype->size);\n-  else\n-    ecif.rvalue = rvalue;\n- \n-  switch (cif->abi)\n-    {\n-    case FFI_SYSV:\n-      ffi_call_SYSV(ffi_prep_args,\n-\t\t    &ecif, cif->bytes,\n-\t\t    cif->flags, ecif.rvalue, fn);\n-      break;\n- \n-    default:\n-      FFI_ASSERT(0);\n-      break;\n-    }\n-}\n- \n-/*======================== End of Routine ============================*/"}, {"sha": "50e94f5ee2aacda64294b0afa29ef3587404c5d0", "filename": "libffi/src/s390/sysv.S", "status": "modified", "additions": 320, "deletions": 126, "changes": 446, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4f17c6f58d35c40b776b8cb0d9eb185f0a96538/libffi%2Fsrc%2Fs390%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4f17c6f58d35c40b776b8cb0d9eb185f0a96538/libffi%2Fsrc%2Fs390%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fs390%2Fsysv.S?ref=c4f17c6f58d35c40b776b8cb0d9eb185f0a96538", "patch": "@@ -22,150 +22,130 @@\n    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n    ----------------------------------------------------------------------- */\n+\n+#ifndef __s390x__\n  \n-#define LIBFFI_ASM\t\n-#include <ffi.h>\n-#ifdef HAVE_MACHINE_ASM_H\n-#include <machine/asm.h>\n-#endif\n-\t\n .text\n- \n-\t# r2:\tffi_prep_args\n+\n+\t# r2:\tcif->bytes\n \t# r3:\t&ecif\n-\t# r4:\tcif->bytes\n-\t# r5:\tfig->flags\n+\t# r4:\tffi_prep_args\n+\t# r5:\tret_type\n \t# r6:\tecif.rvalue\n-\t# sp+0: fn\n+\t# ov:\tfn \n  \n \t# This assumes we are using gas.\n \t.globl\tffi_call_SYSV\n \t.type\tffi_call_SYSV,%function\n ffi_call_SYSV:\n .LFB1:\n-\t# Save registers\n-\tstm\t%r6,%r15,24(%r15)\n+\tstm\t%r6,%r15,24(%r15)\t\t# Save registers\n .LCFI0:\n-\tl\t%r7,96(%r15)\t       # Get A(fn)\n-\tlr\t%r0,%r15\n-\tahi\t%r15,-128\t       # Make room for my args\n+\tbasr\t%r13,0\t\t\t\t# Set up base register\n+.Lbase:\n+\tlr\t%r11,%r15\t\t\t# Set up frame pointer\n .LCFI1:\n-\tst\t%r0,0(%r15)\t       # Set backchain\n-\tlr\t%r11,%r15\t       # Establish my stack register\n+\tsr\t%r15,%r2\n+\tahi\t%r15,-96-48\t\t\t# Allocate stack\n+\tlr\t%r8,%r6\t\t\t\t# Save ecif.rvalue\n+\tsr\t%r9,%r9\n+\tic\t%r9,.Ltable-.Lbase(%r13,%r5)\t# Load epilog address\n+\tl\t%r7,96(%r11)\t\t\t# Load function address\n+\tst\t%r11,0(%r15)\t\t\t# Set up back chain\n+\tahi\t%r11,-48\t\t\t# Register save area\n .LCFI2:\n-\tsr\t%r15,%r4\t       # Make room for fn args\n-\tahi\t%r15,-96\t       # Make room for new frame\n-\tlr\t%r10,%r15\t       # Establish stack build area\n-\tahi\t%r15,-96\t       # Stack for next call\n-\tlr\t%r1,%r7\n-\tstm\t%r2,%r7,96(%r11)       # Save args on my stack\n- \n-#------------------------------------------------------------------\n-#\tmove first 3 parameters in registers\n-#------------------------------------------------------------------\n-\tlr\t%r9,%r2\t\t       # r9:\t &ffi_prep_args\n-\tlr\t%r2,%r10\t       # Parm 1: &stack Parm 2: &ecif\n-\tbasr\t%r14,%r9\t       # call ffi_prep_args\n- \n-#------------------------------------------------------------------\n-#\tload  first 5 parameter registers\n-#------------------------------------------------------------------\n-\tlm\t%r2,%r6,24(%r10)\n- \n-#------------------------------------------------------------------\n-#\tload  fp parameter registers\n-#------------------------------------------------------------------\n-\tld\t%f0,48(%r10)\n-\tld\t%f2,56(%r10)\n- \n-#------------------------------------------------------------------\n-#\tcall  function\n-#------------------------------------------------------------------\n-\tlr\t%r15,%r10\t       # Set new stack\n-\tl\t%r9,116(%r11)\t       # Get &fn\n-\tbasr\t%r14,%r9\t       # Call function\n- \n-#------------------------------------------------------------------\n-#\tOn return:\n-#\t   r2: Return value (r3: Return value + 4 for long long)\n-#------------------------------------------------------------------\n- \n-#------------------------------------------------------------------\n-#\tIf the return value pointer is NULL, assume no return value.\n-#------------------------------------------------------------------\n-\ticm\t%r6,15,112(%r11)\n-\tjz\t.Lepilogue\n- \n-\tl\t%r5,108(%r11)\t       # Get return type\n-#------------------------------------------------------------------\n-#\treturn INT\n-#------------------------------------------------------------------\n-\tchi\t%r5,FFI_TYPE_INT\n-\tjne\t.Lchk64\n- \n-\tst\t%r2,0(%r6)\n-\tj\t.Lepilogue\n- \n-.Lchk64:\n-#------------------------------------------------------------------\n-#\treturn LONG LONG (signed/unsigned)\n-#------------------------------------------------------------------\n-\tchi\t%r5,FFI_TYPE_UINT64\n-\tje\t.LdoLongLong\n- \n-\tchi\t%r5,FFI_TYPE_SINT64\n-\tjne\t.LchkFloat\n- \n-.LdoLongLong:\n-\tstm\t%r2,%r3,0(%r6)\n-\tj\t.Lepilogue\n- \n-.LchkFloat:\n-#------------------------------------------------------------------\n-#\treturn FLOAT\n-#------------------------------------------------------------------\n-\tchi\t%r5,FFI_TYPE_FLOAT\n-\tjne\t.LchkDouble\n- \n-\tstd\t%f0,0(%r6)\n-\tj\t.Lepilogue\n- \n-.LchkDouble:\n-#------------------------------------------------------------------\n-#\treturn DOUBLE or LONGDOUBLE\n-#------------------------------------------------------------------\n-\tchi\t%r5,FFI_TYPE_DOUBLE\n-\tjne\t.LchkStruct\n- \n-\tstd\t%f0,0(%r6)\n-\tstd\t%f2,8(%r6)\n-\tj\t.Lepilogue\n- \n-.LchkStruct:\n-#------------------------------------------------------------------\n-# Structure - rvalue already set as sent as 1st parm to routine\n-#------------------------------------------------------------------\n-\tchi\t%r5,FFI_TYPE_STRUCT\n-\tje\t.Lepilogue\n+\n+\tla\t%r2,96(%r15)\t\t\t# Save area\n+\t\t\t\t\t\t# r3 already holds &ecif\n+\tbasr\t%r14,%r4\t\t\t# Call ffi_prep_args\n+\n+\tlm\t%r2,%r6,0(%r11)\t\t\t# Load arguments\n+\tld\t%f0,32(%r11)\n+\tld\t%f2,40(%r11)\n+\tla\t%r14,0(%r13,%r9)\t\t# Set return address\n+\tbr\t%r7\t\t\t\t# ... and call function\n+\n+.LretNone:\t\t\t\t\t# Return void\n+\tl\t%r4,48+56(%r11)\n+\tlm\t%r6,%r15,48+24(%r11)\n+\tbr\t%r4\n+\n+.LretFloat:\n+\tl\t%r4,48+56(%r11)\n+\tste\t%f0,0(%r8)\t\t\t# Return float\n+\tlm\t%r6,%r15,48+24(%r11)\n+\tbr\t%r4\n  \n-.Ldefault:\n-#------------------------------------------------------------------\n-#\treturn a pointer\n-#------------------------------------------------------------------\n-\tst\t%r2,0(%r6)\n-\tj\t.Lepilogue\n+.LretDouble:\n+\tl\t%r4,48+56(%r11)\n+\tstd\t%f0,0(%r8)\t\t\t# Return double\n+\tlm\t%r6,%r15,48+24(%r11)\n+\tbr\t%r4\n+\n+.LretInt32:\n+\tl\t%r4,48+56(%r11)\n+\tst\t%r2,0(%r8)\t\t\t# Return int\n+\tlm\t%r6,%r15,48+24(%r11)\n+\tbr\t%r4\n  \n-.Lepilogue:\n-\tl\t%r15,0(%r11)\n-\tl\t%r4,56(%r15)\n-\tlm\t%r6,%r15,24(%r15)\n+.LretInt64:\n+\tl\t%r4,48+56(%r11)\n+\tstm\t%r2,%r3,0(%r8)\t\t\t# Return long long\n+\tlm\t%r6,%r15,48+24(%r11)\n \tbr\t%r4\n+ \n+.Ltable:\n+\t.byte\t.LretNone-.Lbase\t\t# FFI390_RET_VOID\n+\t.byte\t.LretNone-.Lbase\t\t# FFI390_RET_STRUCT\n+\t.byte\t.LretFloat-.Lbase\t\t# FFI390_RET_FLOAT\n+\t.byte\t.LretDouble-.Lbase\t\t# FFI390_RET_DOUBLE\n+\t.byte\t.LretInt32-.Lbase\t\t# FFI390_RET_INT32\n+\t.byte\t.LretInt64-.Lbase\t\t# FFI390_RET_INT64\n \n .LFE1: \n .ffi_call_SYSV_end:\n \t.size\t ffi_call_SYSV,.ffi_call_SYSV_end-ffi_call_SYSV\n \n \n+\t.globl\tffi_closure_SYSV\n+\t.type\tffi_closure_SYSV,%function\n+ffi_closure_SYSV:\n+.LFB2:\n+\tstm\t%r12,%r15,48(%r15)\t\t# Save registers\n+.LCFI10:\n+\tbasr\t%r13,0\t\t\t\t# Set up base register\n+.Lcbase:\n+\tstm\t%r2,%r6,8(%r15)\t\t\t# Save arguments\n+\tstd\t%f0,64(%r15)\n+\tstd\t%f2,72(%r15)\n+\tlr\t%r1,%r15\t\t\t# Set up stack frame\n+\tahi\t%r15,-96\n+.LCFI11:\n+\tl\t%r12,.Lchelper-.Lcbase(%r13)\t# Get helper function\n+\tlr\t%r2,%r0\t\t\t\t# Closure\n+\tla\t%r3,8(%r1)\t\t\t# GPRs\n+\tla\t%r4,64(%r1)\t\t\t# FPRs\n+\tla\t%r5,96(%r1)\t\t\t# Overflow\n+\tst\t%r1,0(%r15)\t\t\t# Set up back chain\n+\n+\tbas\t%r14,0(%r12,%r13)\t\t# Call helper\n+\n+\tl\t%r4,96+56(%r15)\n+\tld\t%f0,96+64(%r15)\t\t\t# Load return registers\n+\tlm\t%r2,%r3,96+8(%r15)\n+\tlm\t%r12,%r15,96+48(%r15)\n+\tbr\t%r4\n+\n+\t.align 4\n+.Lchelper:\n+\t.long\tffi_closure_helper_SYSV-.Lcbase\n+\n+.LFE2: \n+\n+.ffi_closure_SYSV_end:\n+\t.size\t ffi_closure_SYSV,.ffi_closure_SYSV_end-ffi_closure_SYSV\n+\n+\n \t.section\t.eh_frame,\"aw\",@progbits\n .Lframe1:\n \t.4byte\t.LECIE1-.LSCIE1\t# Length of Common Information Entry\n@@ -187,7 +167,6 @@ ffi_call_SYSV:\n \t.4byte\t.LASFDE1-.Lframe1\t# FDE CIE offset\n \t.4byte\t.LFB1\t# FDE initial location\n \t.4byte\t.LFE1-.LFB1\t# FDE address range\n-\t.uleb128 0x0\t# Augmentation size\n \t.byte\t0x4\t# DW_CFA_advance_loc4\n \t.4byte\t.LCFI0-.LFB1\n \t.byte\t0x8f\t# DW_CFA_offset, column 0xf\n@@ -212,12 +191,227 @@ ffi_call_SYSV:\n \t.uleb128 0x12\n \t.byte\t0x4\t# DW_CFA_advance_loc4\n \t.4byte\t.LCFI1-.LCFI0\n-\t.byte\t0xe\t# DW_CFA_def_cfa_offset\n-\t.uleb128 0xe0\n+\t.byte\t0xd\t# DW_CFA_def_cfa_register\n+\t.uleb128 0xb\n \t.byte\t0x4\t# DW_CFA_advance_loc4\n \t.4byte\t.LCFI2-.LCFI1\n-\t.byte\t0xd\t# DW_CFA_def_cfa_register\n+\t.byte\t0xe\t# DW_CFA_def_cfa_offset\n+\t.uleb128 0x90\n+\t.align\t4\n+.LEFDE1:\n+.LSFDE2:\n+\t.4byte\t.LEFDE2-.LASFDE2\t# FDE Length\n+.LASFDE2:\n+\t.4byte\t.LASFDE2-.Lframe1\t# FDE CIE offset\n+\t.4byte\t.LFB2\t# FDE initial location\n+\t.4byte\t.LFE2-.LFB2\t# FDE address range\n+\t.byte\t0x4\t# DW_CFA_advance_loc4\n+\t.4byte\t.LCFI10-.LFB2\n+\t.byte\t0x8f\t# DW_CFA_offset, column 0xf\n+\t.uleb128 0x9\n+\t.byte\t0x8e\t# DW_CFA_offset, column 0xe\n+\t.uleb128 0xa\n+\t.byte\t0x8d\t# DW_CFA_offset, column 0xd\n \t.uleb128 0xb\n+\t.byte\t0x8c\t# DW_CFA_offset, column 0xc\n+\t.uleb128 0xc\n+\t.byte\t0x4\t# DW_CFA_advance_loc4\n+\t.4byte\t.LCFI11-.LCFI10\n+\t.byte\t0xe\t# DW_CFA_def_cfa_offset\n+\t.uleb128 0xc0\n \t.align\t4\n+.LEFDE2:\n+\n+#else\n+ \n+.text\n+ \n+\t# r2:\tcif->bytes\n+\t# r3:\t&ecif\n+\t# r4:\tffi_prep_args\n+\t# r5:\tret_type\n+\t# r6:\tecif.rvalue\n+\t# ov:\tfn \n+ \n+\t# This assumes we are using gas.\n+\t.globl\tffi_call_SYSV\n+\t.type\tffi_call_SYSV,%function\n+ffi_call_SYSV:\n+.LFB1:\n+\tstmg\t%r6,%r15,48(%r15)\t\t# Save registers\n+.LCFI0:\n+\tlarl\t%r13,.Lbase\t\t\t# Set up base register\n+\tlgr\t%r11,%r15\t\t\t# Set up frame pointer\n+.LCFI1:\n+\tsgr\t%r15,%r2\n+\taghi\t%r15,-160-80\t\t\t# Allocate stack\n+\tlgr\t%r8,%r6\t\t\t\t# Save ecif.rvalue\n+\tllgc\t%r9,.Ltable-.Lbase(%r13,%r5)\t# Load epilog address\n+\tlg\t%r7,160(%r11)\t\t\t# Load function address\n+\tstg\t%r11,0(%r15)\t\t\t# Set up back chain\n+\taghi\t%r11,-80\t\t\t# Register save area\n+.LCFI2:\n+\n+\tla\t%r2,160(%r15)\t\t\t# Save area\n+\t\t\t\t\t\t# r3 already holds &ecif\n+\tbasr\t%r14,%r4\t\t\t# Call ffi_prep_args\n+\n+\tlmg\t%r2,%r6,0(%r11)\t\t\t# Load arguments\n+\tld\t%f0,48(%r11)\n+\tld\t%f2,56(%r11)\n+\tld\t%f4,64(%r11)\n+\tld\t%f6,72(%r11)\n+\tla\t%r14,0(%r13,%r9)\t\t# Set return address\n+\tbr\t%r7\t\t\t\t# ... and call function\n+\n+.Lbase:\n+.LretNone:\t\t\t\t\t# Return void\n+\tlg\t%r4,80+112(%r11)\n+\tlmg\t%r6,%r15,80+48(%r11)\n+\tbr\t%r4\n+\n+.LretFloat:\n+\tlg\t%r4,80+112(%r11)\n+\tste\t%f0,0(%r8)\t\t\t# Return float\n+\tlmg\t%r6,%r15,80+48(%r11)\n+\tbr\t%r4\n+ \n+.LretDouble:\n+\tlg\t%r4,80+112(%r11)\n+\tstd\t%f0,0(%r8)\t\t\t# Return double\n+\tlmg\t%r6,%r15,80+48(%r11)\n+\tbr\t%r4\n+\n+.LretInt32:\n+\tlg\t%r4,80+112(%r11)\n+\tst\t%r2,0(%r8)\t\t\t# Return int\n+\tlmg\t%r6,%r15,80+48(%r11)\n+\tbr\t%r4\n+ \n+.LretInt64:\n+\tlg\t%r4,80+112(%r11)\n+\tstg\t%r2,0(%r8)\t\t\t# Return long\n+\tlmg\t%r6,%r15,80+48(%r11)\n+\tbr\t%r4\n+ \n+.Ltable:\n+\t.byte\t.LretNone-.Lbase\t\t# FFI390_RET_VOID\n+\t.byte\t.LretNone-.Lbase\t\t# FFI390_RET_STRUCT\n+\t.byte\t.LretFloat-.Lbase\t\t# FFI390_RET_FLOAT\n+\t.byte\t.LretDouble-.Lbase\t\t# FFI390_RET_DOUBLE\n+\t.byte\t.LretInt32-.Lbase\t\t# FFI390_RET_INT32\n+\t.byte\t.LretInt64-.Lbase\t\t# FFI390_RET_INT64\n+\n+.LFE1: \n+.ffi_call_SYSV_end:\n+\t.size\t ffi_call_SYSV,.ffi_call_SYSV_end-ffi_call_SYSV\n+\n+\n+\t.globl\tffi_closure_SYSV\n+\t.type\tffi_closure_SYSV,%function\n+ffi_closure_SYSV:\n+.LFB2:\n+\tstmg\t%r14,%r15,112(%r15)\t\t# Save registers\n+.LCFI10:\n+\tstmg\t%r2,%r6,16(%r15)\t\t# Save arguments\n+\tstd\t%f0,128(%r15)\n+\tstd\t%f2,136(%r15)\n+\tstd\t%f4,144(%r15)\n+\tstd\t%f6,152(%r15)\n+\tlgr\t%r1,%r15\t\t\t# Set up stack frame\n+\taghi\t%r15,-160\n+.LCFI11:\n+\tlgr\t%r2,%r0\t\t\t\t# Closure\n+\tla\t%r3,16(%r1)\t\t\t# GPRs\n+\tla\t%r4,128(%r1)\t\t\t# FPRs\n+\tla\t%r5,160(%r1)\t\t\t# Overflow\n+\tstg\t%r1,0(%r15)\t\t\t# Set up back chain\n+\n+\tbrasl\t%r14,ffi_closure_helper_SYSV\t# Call helper\n+\n+\tlg\t%r14,160+112(%r15)\n+\tld\t%f0,160+128(%r15)\t\t# Load return registers\n+\tlg\t%r2,160+16(%r15)\n+\tla\t%r15,160(%r15)\n+\tbr\t%r14\n+.LFE2: \n+\n+.ffi_closure_SYSV_end:\n+\t.size\t ffi_closure_SYSV,.ffi_closure_SYSV_end-ffi_closure_SYSV\n+\n+\n+\n+\t.section\t.eh_frame,\"aw\",@progbits\n+.Lframe1:\n+\t.4byte\t.LECIE1-.LSCIE1\t# Length of Common Information Entry\n+.LSCIE1:\n+\t.4byte\t0x0\t# CIE Identifier Tag\n+\t.byte\t0x1\t# CIE Version\n+\t.ascii \"\\0\"\t# CIE Augmentation\n+\t.uleb128 0x1\t# CIE Code Alignment Factor\n+\t.sleb128 -8\t# CIE Data Alignment Factor\n+\t.byte\t0xe\t# CIE RA Column\n+\t.byte\t0xc\t# DW_CFA_def_cfa\n+\t.uleb128 0xf\n+\t.uleb128 0xa0\n+\t.align\t8\n+.LECIE1:\n+.LSFDE1:\n+\t.4byte\t.LEFDE1-.LASFDE1\t# FDE Length\n+.LASFDE1:\n+\t.4byte\t.LASFDE1-.Lframe1\t# FDE CIE offset\n+\t.8byte\t.LFB1\t# FDE initial location\n+\t.8byte\t.LFE1-.LFB1\t# FDE address range\n+\t.byte\t0x4\t# DW_CFA_advance_loc4\n+\t.4byte\t.LCFI0-.LFB1\n+\t.byte\t0x8f\t# DW_CFA_offset, column 0xf\n+\t.uleb128 0x5\n+\t.byte\t0x8e\t# DW_CFA_offset, column 0xe\n+\t.uleb128 0x6\n+\t.byte\t0x8d\t# DW_CFA_offset, column 0xd\n+\t.uleb128 0x7\n+\t.byte\t0x8c\t# DW_CFA_offset, column 0xc\n+\t.uleb128 0x8\n+\t.byte\t0x8b\t# DW_CFA_offset, column 0xb\n+\t.uleb128 0x9\n+\t.byte\t0x8a\t# DW_CFA_offset, column 0xa\n+\t.uleb128 0xa\n+\t.byte\t0x89\t# DW_CFA_offset, column 0x9\n+\t.uleb128 0xb\n+\t.byte\t0x88\t# DW_CFA_offset, column 0x8\n+\t.uleb128 0xc\n+\t.byte\t0x87\t# DW_CFA_offset, column 0x7\n+\t.uleb128 0xd\n+\t.byte\t0x86\t# DW_CFA_offset, column 0x6\n+\t.uleb128 0xe\n+\t.byte\t0x4\t# DW_CFA_advance_loc4\n+\t.4byte\t.LCFI1-.LCFI0\n+\t.byte\t0xd\t# DW_CFA_def_cfa_register\n+\t.uleb128 0xb\n+\t.byte\t0x4\t# DW_CFA_advance_loc4\n+\t.4byte\t.LCFI2-.LCFI1\n+\t.byte\t0xe\t# DW_CFA_def_cfa_offset\n+\t.uleb128 0xf0\n+\t.align\t8\n .LEFDE1:\n+.LSFDE2:\n+\t.4byte\t.LEFDE2-.LASFDE2\t# FDE Length\n+.LASFDE2:\n+\t.4byte\t.LASFDE2-.Lframe1\t# FDE CIE offset\n+\t.8byte\t.LFB2\t# FDE initial location\n+\t.8byte\t.LFE2-.LFB2\t# FDE address range\n+\t.byte\t0x4\t# DW_CFA_advance_loc4\n+\t.4byte\t.LCFI10-.LFB2\n+\t.byte\t0x8f\t# DW_CFA_offset, column 0xf\n+\t.uleb128 0x5\n+\t.byte\t0x8e\t# DW_CFA_offset, column 0xe\n+\t.uleb128 0x6\n+\t.byte\t0x4\t# DW_CFA_advance_loc4\n+\t.4byte\t.LCFI11-.LCFI10\n+\t.byte\t0xe\t# DW_CFA_def_cfa_offset\n+\t.uleb128 0x140\n+\t.align\t8\n+.LEFDE2:\n+\n+#endif\n "}, {"sha": "8d1241de388ed9b679ff44f34e4c9a119a1d1c25", "filename": "libffi/src/types.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4f17c6f58d35c40b776b8cb0d9eb185f0a96538/libffi%2Fsrc%2Ftypes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4f17c6f58d35c40b776b8cb0d9eb185f0a96538/libffi%2Fsrc%2Ftypes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Ftypes.c?ref=c4f17c6f58d35c40b776b8cb0d9eb185f0a96538", "patch": "@@ -42,7 +42,7 @@ FFI_INTEGRAL_TYPEDEF(uint32, 4, 4, FFI_TYPE_UINT32);\n FFI_INTEGRAL_TYPEDEF(sint32, 4, 4, FFI_TYPE_SINT32);\n FFI_INTEGRAL_TYPEDEF(float, 4, 4, FFI_TYPE_FLOAT);\n \n-#if defined ALPHA || defined SPARC64 || defined X86_64\n+#if defined ALPHA || defined SPARC64 || defined X86_64 || defined S390X\n \n FFI_INTEGRAL_TYPEDEF(pointer, 8, 8, FFI_TYPE_POINTER);\n "}]}