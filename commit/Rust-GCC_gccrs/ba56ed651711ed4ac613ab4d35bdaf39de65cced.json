{"sha": "ba56ed651711ed4ac613ab4d35bdaf39de65cced", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE1NmVkNjUxNzExZWQ0YWM2MTNhYjRkMzViZGFmMzlkZTY1Y2NlZA==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2007-06-27T21:40:19Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2007-06-27T21:40:19Z"}, "message": "re PR target/32479 ([sh] ICE in cse_extended_basic_block, at cse.c:6117)\n\n\tPR target/32479\n\t* config/sh/sh.md (udivsi3): Don't wrap the sequence with\n\tREG_LIBCALL and REG_RETVAL notes.\n\t(divsi3, mulsi3): Likewise.\n\t(mulhisi3): Likewise.  Use emit_libcall_block.\n\t(umulhisi3, smulsi3_highpart, umulsi3_highpart_i): Likewise.\n\nFrom-SVN: r126065", "tree": {"sha": "d6e0a4eb0967591fd5916b0456e18f5d4630b6e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6e0a4eb0967591fd5916b0456e18f5d4630b6e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba56ed651711ed4ac613ab4d35bdaf39de65cced", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba56ed651711ed4ac613ab4d35bdaf39de65cced", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba56ed651711ed4ac613ab4d35bdaf39de65cced", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba56ed651711ed4ac613ab4d35bdaf39de65cced/comments", "author": null, "committer": null, "parents": [{"sha": "24189c587c23578bcbe2e7395fef5afb75ee5184", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24189c587c23578bcbe2e7395fef5afb75ee5184", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24189c587c23578bcbe2e7395fef5afb75ee5184"}], "stats": {"total": 113, "additions": 55, "deletions": 58}, "files": [{"sha": "07e40ddd88f2580b3adcc75016b0531d8797a42d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba56ed651711ed4ac613ab4d35bdaf39de65cced/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba56ed651711ed4ac613ab4d35bdaf39de65cced/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba56ed651711ed4ac613ab4d35bdaf39de65cced", "patch": "@@ -1,3 +1,12 @@\n+2007-06-27  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\tPR target/32479\n+\t* config/sh/sh.md (udivsi3): Don't wrap the sequence with\n+\tREG_LIBCALL and REG_RETVAL notes.\n+\t(divsi3, mulsi3): Likewise.\n+\t(mulhisi3): Likewise.  Use emit_libcall_block.\n+\t(umulhisi3, smulsi3_highpart, umulsi3_highpart_i): Likewise.\n+\n 2007-06-27  Seongbae Park  <seongbae.park@gmail.com>\n \n \tPR rtl-optimization/32481"}, {"sha": "b99af29dc6718636bac7bdd5d266df34451f8ae5", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 46, "deletions": 58, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba56ed651711ed4ac613ab4d35bdaf39de65cced/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba56ed651711ed4ac613ab4d35bdaf39de65cced/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=ba56ed651711ed4ac613ab4d35bdaf39de65cced", "patch": "@@ -1860,7 +1860,7 @@\n   \"\"\n   \"\n {\n-  rtx first, last;\n+  rtx last;\n \n   operands[3] = gen_reg_rtx (Pmode);\n   /* Emit the move of the address to a pseudo outside of the libcall.  */\n@@ -1924,13 +1924,9 @@\n       function_symbol (operands[3], \\\"__udivsi3\\\", SFUNC_STATIC);\n       last = gen_udivsi3_i1 (operands[0], operands[3]);\n     }\n-  first = emit_move_insn (gen_rtx_REG (SImode, 4), operands[1]);\n+  emit_move_insn (gen_rtx_REG (SImode, 4), operands[1]);\n   emit_move_insn (gen_rtx_REG (SImode, 5), operands[2]);\n-  last = emit_insn (last);\n-  /* Wrap the sequence in REG_LIBCALL / REG_RETVAL notes so that loop\n-     invariant code motion can move it.  */\n-  REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last, REG_NOTES (first));\n-  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));\n+  emit_insn (last);\n   DONE;\n }\")\n \n@@ -2132,7 +2128,7 @@\n   \"\"\n   \"\n {\n-  rtx first, last;\n+  rtx last;\n \n   operands[3] = gen_reg_rtx (Pmode);\n   /* Emit the move of the address to a pseudo outside of the libcall.  */\n@@ -2271,13 +2267,9 @@\n       function_symbol (operands[3], sh_divsi3_libfunc, SFUNC_GOT);\n       last = gen_divsi3_i1 (operands[0], operands[3]);\n     }\n-  first = emit_move_insn (gen_rtx_REG (SImode, 4), operands[1]);\n+  emit_move_insn (gen_rtx_REG (SImode, 4), operands[1]);\n   emit_move_insn (gen_rtx_REG (SImode, 5), operands[2]);\n-  last = emit_insn (last);\n-  /* Wrap the sequence in REG_LIBCALL / REG_RETVAL notes so that loop\n-     invariant code motion can move it.  */\n-  REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last, REG_NOTES (first));\n-  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));\n+  emit_insn (last);\n   DONE;\n }\")\n \n@@ -2746,21 +2738,21 @@ label:\n   \"TARGET_SH1\"\n   \"\n {\n-  rtx first, last;\n+  rtx insn, macl;\n \n-  first = emit_insn (gen_mulhisi3_i (operands[1], operands[2]));\n-  last = emit_move_insn (operands[0], gen_rtx_REG (SImode, MACL_REG));\n-  /* Wrap the sequence in REG_LIBCALL / REG_RETVAL notes so that loop\n-     invariant code motion can move it.  */\n-  REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last, REG_NOTES (first));\n-  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));\n+  macl = gen_rtx_REG (SImode, MACL_REG);\n+  start_sequence ();\n+  emit_insn (gen_mulhisi3_i (operands[1], operands[2]));\n+  insn = get_insns ();  \n+  end_sequence ();\n   /* expand_binop can't find a suitable code in umul_widen_optab to\n      make a REG_EQUAL note from, so make one here.\n      See also smulsi3_highpart.\n      ??? Alternatively, we could put this at the calling site of expand_binop,\n      i.e. expand_expr.  */\n-  set_unique_reg_note (last, REG_EQUAL,\n-\t\t       copy_rtx (SET_SRC (single_set (first))));\n+  /* Use emit_libcall_block for loop invariant code motion and to make\n+     a REG_EQUAL note.  */\n+  emit_libcall_block (insn, operands[0], macl, SET_SRC (single_set (insn)));\n \n   DONE;\n }\")\n@@ -2776,21 +2768,21 @@ label:\n   \"TARGET_SH1\"\n   \"\n {\n-  rtx first, last;\n+  rtx insn, macl;\n \n-  first = emit_insn (gen_umulhisi3_i (operands[1], operands[2]));\n-  last = emit_move_insn (operands[0], gen_rtx_REG (SImode, MACL_REG));\n-  /* Wrap the sequence in REG_LIBCALL / REG_RETVAL notes so that loop\n-     invariant code motion can move it.  */\n-  REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last, REG_NOTES (first));\n-  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));\n+  macl = gen_rtx_REG (SImode, MACL_REG);\n+  start_sequence ();\n+  emit_insn (gen_umulhisi3_i (operands[1], operands[2]));\n+  insn = get_insns ();  \n+  end_sequence ();\n   /* expand_binop can't find a suitable code in umul_widen_optab to\n      make a REG_EQUAL note from, so make one here.\n      See also smulsi3_highpart.\n      ??? Alternatively, we could put this at the calling site of expand_binop,\n      i.e. expand_expr.  */\n-  set_unique_reg_note (last, REG_EQUAL,\n-\t\t       copy_rtx (SET_SRC (single_set (first))));\n+  /* Use emit_libcall_block for loop invariant code motion and to make\n+     a REG_EQUAL note.  */\n+  emit_libcall_block (insn, operands[0], macl, SET_SRC (single_set (insn)));\n \n   DONE;\n }\")\n@@ -2854,8 +2846,6 @@ label:\n   \"TARGET_SH1\"\n   \"\n {\n-  rtx first, last;\n-\n   if (!TARGET_SH2)\n     {\n       /* The address must be set outside the libcall,\n@@ -2864,23 +2854,18 @@ label:\n       rtx addr = force_reg (SImode, sym);\n       rtx insns = gen_mulsi3_call (operands[0], operands[1],\n \t\t\t\t   operands[2], addr);\n-      first = insns;\n-      last = emit_insn (insns);\n+      emit_insn (insns);\n     }\n   else\n     {\n       rtx macl = gen_rtx_REG (SImode, MACL_REG);\n \n-      first = emit_insn (gen_mul_l (operands[1], operands[2]));\n+      emit_insn (gen_mul_l (operands[1], operands[2]));\n       /* consec_sets_giv can only recognize the first insn that sets a\n \t giv as the giv insn.  So we must tag this also with a REG_EQUAL\n \t note.  */\n-      last = emit_insn (gen_movsi_i ((operands[0]), macl));\n+      emit_insn (gen_movsi_i ((operands[0]), macl));\n     }\n-  /* Wrap the sequence in REG_LIBCALL / REG_RETVAL notes so that loop\n-     invariant code motion can move it.  */\n-  REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last, REG_NOTES (first));\n-  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));\n   DONE;\n }\")\n \n@@ -3055,21 +3040,21 @@ label:\n   \"TARGET_SH2\"\n   \"\n {\n-  rtx first, last;\n+  rtx insn, mach;\n \n-  first = emit_insn (gen_smulsi3_highpart_i (operands[1], operands[2]));\n-  last = emit_move_insn (operands[0], gen_rtx_REG (SImode, MACH_REG));\n-  /* Wrap the sequence in REG_LIBCALL / REG_RETVAL notes so that loop\n-     invariant code motion can move it.  */\n-  REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last, REG_NOTES (first));\n-  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));\n+  mach = gen_rtx_REG (SImode, MACH_REG);\n+  start_sequence ();\n+  emit_insn (gen_smulsi3_highpart_i (operands[1], operands[2]));\n+  insn = get_insns ();  \n+  end_sequence ();\n   /* expand_binop can't find a suitable code in mul_highpart_optab to\n      make a REG_EQUAL note from, so make one here.\n      See also {,u}mulhisi.\n      ??? Alternatively, we could put this at the calling site of expand_binop,\n      i.e. expand_mult_highpart.  */\n-  set_unique_reg_note (last, REG_EQUAL,\n-\t\t       copy_rtx (SET_SRC (single_set (first))));\n+  /* Use emit_libcall_block for loop invariant code motion and to make\n+     a REG_EQUAL note.  */\n+  emit_libcall_block (insn, operands[0], mach, SET_SRC (single_set (insn)));\n \n   DONE;\n }\")\n@@ -3102,14 +3087,17 @@ label:\n   \"TARGET_SH2\"\n   \"\n {\n-  rtx first, last;\n+  rtx insn, mach;\n+\n+  mach = gen_rtx_REG (SImode, MACH_REG);\n+  start_sequence ();\n+  emit_insn (gen_umulsi3_highpart_i (operands[1], operands[2]));\n+  insn = get_insns ();  \n+  end_sequence ();\n+  /* Use emit_libcall_block for loop invariant code motion and to make\n+     a REG_EQUAL note.  */\n+  emit_libcall_block (insn, operands[0], mach, SET_SRC (single_set (insn)));\n \n-  first = emit_insn (gen_umulsi3_highpart_i (operands[1], operands[2]));\n-  last = emit_move_insn (operands[0], gen_rtx_REG (SImode, MACH_REG));\n-  /* Wrap the sequence in REG_LIBCALL / REG_RETVAL notes so that loop\n-     invariant code motion can move it.  */\n-  REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last, REG_NOTES (first));\n-  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));\n   DONE;\n }\")\n "}]}