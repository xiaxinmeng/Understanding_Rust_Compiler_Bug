{"sha": "39d3009fafe3a4d3660f25ef803c9f266496fa53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlkMzAwOWZhZmUzYTRkMzY2MGYyNWVmODAzYzlmMjY2NDk2ZmE1Mw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-14T12:52:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-10-14T12:52:31Z"}, "message": "[multiple changes]\n\n2013-10-14  Tristan Gingold  <gingold@adacore.com>\n\n\t* s-vmexta.ads: Add comments.\n\n2013-10-14  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Contract): Add processing\n\tfor pragma Refined_State.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add processing\n\tfor aspect Refined_Depends.\n\t* sem_prag.adb (Analyze_Contract_Cases_In_Decl_Part):\n\tUse Find_Related_Subprogram_Or_Body to find the related\n\tcontext. Use the current scope when determining whether to\n\tensure proper visibility.\n\t(Analyze_Depends_In_Decl_Part):\n\tAdd local variable Spec_Id. Update the comment on usage of\n\tSubp_Id. Use Find_Related_Subprogram_Or_Body to find the\n\trelated context. Extract the corresponding spec of the body\n\t(if any). Use the current scope when determining when to\n\tensure proper visibility.\n\t(Analyze_Global_In_Decl_Part):\n\tAdd local variable Spec_Id. Update the comment on usage of\n\tSubp_Id. Use Find_Related_Subprogram_Or_Body to find the\n\trelated context. Extract the corresponding spec of the body\n\t(if any). Use the current scope when determining when to\n\tensure proper visibility.\n\t(Analyze_Global_Item): Use the\n\tentity of the subprogram spec when performing formal parameter\n\tchecks. Perform state-related checks.\n\t(Analyze_Input_Output):\n\tUse Is_Attribute_Result to detect 'Result. Query the\n\tentity of a subprogram spec when verifying the prefix of\n\t'Result. Perform state-related checks.\t(Analyze_Pragma):\n\tMerge the analysis of Refined_Depends and Refined_Global.\n\t(Analyze_Refined_Depends_In_Decl_Part): Provide implemenation.\n\t(Analyze_Refined_Global_In_Decl_Part): Move state-related checks\n\tto the body of Analyze_Global_In_Decl_Part. Rename local constant\n\tList to Items.\t(Analyze_Refined_Pragma): Remove circuitry to\n\tfind the proper context, use Find_Related_Subprogram_Or_Body\n\tinstead.\n\t(Check_Function_Return): Query the entity of\n\tthe subprogram spec when verifying the use of 'Result.\n\t(Check_In_Out_States, Check_Input_States, Check_Output_States):\n\tAvoid using Has_Null_Refinement to detect a state with\n\ta non-null refinement, use the Refinement_Constituents\n\tlist instead.\n\t(Check_Matching_Constituent): Remove initialization code.\n\t(Check_Mode_Restriction_In_Function): Use the entity of the subprogram\n\tspec when verifying mode usage in functions.\n\t(Collect_Global_Items): New routine.\n\t(Collect_Subprogram_Inputs_Outputs): Add local\n\tvariable Spec_Id. Add circuitry for bodies-as-specs. Use\n\tpragma Refined_Global when collecting for a body.\n\t(Create_Or_Modify_Clause): Use the location of the\n\tclause. Rename local variable Clause to New_Clause to avoid\n\tconfusion and update all occurrences.  Use Is_Attribute_Result\n\tto detect 'Result.\n\t(Find_Related_Subprogram): Removed.\n\t(Find_Related_Subprogram_Or_Body): New routine.\n\t(Is_Part_Of): Move routine to top level.\n\t(Normalize_Clause): Update the\n\tcomment on usage. The routine can now normalize a clause with\n\tmultiple outputs by splitting it.\n\t(Collect_Global_Items):\n\tRename local constant List to Items. Remove the check for\n\ta null list.\n\t(Requires_Profile_Installation): Removed.\n\t(Split_Multiple_Outputs): New routine.\n\t* sem_prag.ads: Update the comments on usage of various\n\tpragma-related analysis routines.\n\t* sem_util.adb (Contains_Refined_State): The routine can now\n\tprocess pragma [Refined_]Depends.\n\t(Has_Refined_State): Removed.\n\t(Has_State_In_Dependency): New routine.\n\t(Has_State_In_Global): New routine.\n\t(Is_Attribute_Result): New routine.\n\t* sem_util.ads (Is_Attribute_Result): New routine.\n\n2013-10-14  Emmanuel Briot  <briot@adacore.com>\n\n\t* s-regpat.adb (Compile): Fix finalization of the automaton\n\twhen its size was automatically computed to be exactly 1000 bytes.\n\n2013-10-14  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Complete_Private_Subtype): If the full view of\n\tthe base type is constrained, the full view of the subtype is\n\tknown to be constrained as well.\n\nFrom-SVN: r203531", "tree": {"sha": "09e9014865707bf6edb2537721ea906549ba54cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09e9014865707bf6edb2537721ea906549ba54cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39d3009fafe3a4d3660f25ef803c9f266496fa53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39d3009fafe3a4d3660f25ef803c9f266496fa53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39d3009fafe3a4d3660f25ef803c9f266496fa53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39d3009fafe3a4d3660f25ef803c9f266496fa53/comments", "author": null, "committer": null, "parents": [{"sha": "747412b8fe223d4ab3e0ed55faac7a786b7a098b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/747412b8fe223d4ab3e0ed55faac7a786b7a098b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/747412b8fe223d4ab3e0ed55faac7a786b7a098b"}], "stats": {"total": 2487, "additions": 1811, "deletions": 676}, "files": [{"sha": "93741193f28070fb5fb9d87d60452bb565854424", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d3009fafe3a4d3660f25ef803c9f266496fa53/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d3009fafe3a4d3660f25ef803c9f266496fa53/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=39d3009fafe3a4d3660f25ef803c9f266496fa53", "patch": "@@ -1,3 +1,92 @@\n+2013-10-14  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* s-vmexta.ads: Add comments.\n+\n+2013-10-14  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Contract): Add processing\n+\tfor pragma Refined_State.\n+\t* sem_ch13.adb (Analyze_Aspect_Specifications): Add processing\n+\tfor aspect Refined_Depends.\n+\t* sem_prag.adb (Analyze_Contract_Cases_In_Decl_Part):\n+\tUse Find_Related_Subprogram_Or_Body to find the related\n+\tcontext. Use the current scope when determining whether to\n+\tensure proper visibility.\n+\t(Analyze_Depends_In_Decl_Part):\n+\tAdd local variable Spec_Id. Update the comment on usage of\n+\tSubp_Id. Use Find_Related_Subprogram_Or_Body to find the\n+\trelated context. Extract the corresponding spec of the body\n+\t(if any). Use the current scope when determining when to\n+\tensure proper visibility.\n+\t(Analyze_Global_In_Decl_Part):\n+\tAdd local variable Spec_Id. Update the comment on usage of\n+\tSubp_Id. Use Find_Related_Subprogram_Or_Body to find the\n+\trelated context. Extract the corresponding spec of the body\n+\t(if any). Use the current scope when determining when to\n+\tensure proper visibility.\n+\t(Analyze_Global_Item): Use the\n+\tentity of the subprogram spec when performing formal parameter\n+\tchecks. Perform state-related checks.\n+\t(Analyze_Input_Output):\n+\tUse Is_Attribute_Result to detect 'Result. Query the\n+\tentity of a subprogram spec when verifying the prefix of\n+\t'Result. Perform state-related checks.\t(Analyze_Pragma):\n+\tMerge the analysis of Refined_Depends and Refined_Global.\n+\t(Analyze_Refined_Depends_In_Decl_Part): Provide implemenation.\n+\t(Analyze_Refined_Global_In_Decl_Part): Move state-related checks\n+\tto the body of Analyze_Global_In_Decl_Part. Rename local constant\n+\tList to Items.\t(Analyze_Refined_Pragma): Remove circuitry to\n+\tfind the proper context, use Find_Related_Subprogram_Or_Body\n+\tinstead.\n+\t(Check_Function_Return): Query the entity of\n+\tthe subprogram spec when verifying the use of 'Result.\n+\t(Check_In_Out_States, Check_Input_States, Check_Output_States):\n+\tAvoid using Has_Null_Refinement to detect a state with\n+\ta non-null refinement, use the Refinement_Constituents\n+\tlist instead.\n+\t(Check_Matching_Constituent): Remove initialization code.\n+\t(Check_Mode_Restriction_In_Function): Use the entity of the subprogram\n+\tspec when verifying mode usage in functions.\n+\t(Collect_Global_Items): New routine.\n+\t(Collect_Subprogram_Inputs_Outputs): Add local\n+\tvariable Spec_Id. Add circuitry for bodies-as-specs. Use\n+\tpragma Refined_Global when collecting for a body.\n+\t(Create_Or_Modify_Clause): Use the location of the\n+\tclause. Rename local variable Clause to New_Clause to avoid\n+\tconfusion and update all occurrences.  Use Is_Attribute_Result\n+\tto detect 'Result.\n+\t(Find_Related_Subprogram): Removed.\n+\t(Find_Related_Subprogram_Or_Body): New routine.\n+\t(Is_Part_Of): Move routine to top level.\n+\t(Normalize_Clause): Update the\n+\tcomment on usage. The routine can now normalize a clause with\n+\tmultiple outputs by splitting it.\n+\t(Collect_Global_Items):\n+\tRename local constant List to Items. Remove the check for\n+\ta null list.\n+\t(Requires_Profile_Installation): Removed.\n+\t(Split_Multiple_Outputs): New routine.\n+\t* sem_prag.ads: Update the comments on usage of various\n+\tpragma-related analysis routines.\n+\t* sem_util.adb (Contains_Refined_State): The routine can now\n+\tprocess pragma [Refined_]Depends.\n+\t(Has_Refined_State): Removed.\n+\t(Has_State_In_Dependency): New routine.\n+\t(Has_State_In_Global): New routine.\n+\t(Is_Attribute_Result): New routine.\n+\t* sem_util.ads (Is_Attribute_Result): New routine.\n+\n+2013-10-14  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* s-regpat.adb (Compile): Fix finalization of the automaton\n+\twhen its size was automatically computed to be exactly 1000 bytes.\n+\n+2013-10-14  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Complete_Private_Subtype): If the full view of\n+\tthe base type is constrained, the full view of the subtype is\n+\tknown to be constrained as well.\n+\n 2013-10-14  Vincent Celier  <celier@adacore.com>\n \n \t* projects.texi: Add documentation for new attributes of package"}, {"sha": "88143289e44bf1aac8d01784c6fb84adc1ed9e44", "filename": "gcc/ada/s-regpat.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d3009fafe3a4d3660f25ef803c9f266496fa53/gcc%2Fada%2Fs-regpat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d3009fafe3a4d3660f25ef803c9f266496fa53/gcc%2Fada%2Fs-regpat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-regpat.adb?ref=39d3009fafe3a4d3660f25ef803c9f266496fa53", "patch": "@@ -7,7 +7,7 @@\n --                                 B o d y                                  --\n --                                                                          --\n --               Copyright (C) 1986 by University of Toronto.               --\n---                      Copyright (C) 1999-2011, AdaCore                    --\n+--                      Copyright (C) 1999-2013, AdaCore                    --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -921,7 +921,7 @@ package body System.Regpat is\n \n          Link_Tail (IP, Ender);\n \n-         if Have_Branch and then Emit_Ptr <= PM.Size then\n+         if Have_Branch and then Emit_Ptr <= PM.Size + 1 then\n \n             --  Hook the tails of the branches to the closing node\n "}, {"sha": "4bf83dedc003eeb9fd017d056e544029c7fae470", "filename": "gcc/ada/s-vmexta.ads", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d3009fafe3a4d3660f25ef803c9f266496fa53/gcc%2Fada%2Fs-vmexta.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d3009fafe3a4d3660f25ef803c9f266496fa53/gcc%2Fada%2Fs-vmexta.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vmexta.ads?ref=39d3009fafe3a4d3660f25ef803c9f266496fa53", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1997-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1997-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,7 +29,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package is usually used only on Alpha/VMS systems in the case\n+--  This package is usually used only on OpenVMS systems in the case\n --  where there is at least one Import/Export exception present.\n \n with System.Standard_Library;\n@@ -44,16 +44,23 @@ package System.VMS_Exception_Table is\n    --  Register an exception in the hash table mapping with a VMS\n    --  condition code.\n \n+   --  The table is used by exception code (the personnality routine) to\n+   --  detect wether a VMS exception (aka condition) is known by the Ada code.\n+   --  In that case, the identity of the imported or exported exception is\n+   --  used to create the occurrence.\n+\n    --  LOTS more comments needed here regarding the entire scheme ???\n \n private\n \n+   --  The following functions are directly called (without import/export) in\n+   --  init.c by __gnat_handle_vms_condition.\n+\n    function Base_Code_In (Code : SSL.Exception_Code) return SSL.Exception_Code;\n    --  Value of Code with the severity bits masked off\n \n    function Coded_Exception (X : SSL.Exception_Code)\n      return SSL.Exception_Data_Ptr;\n    --  Given a VMS condition, find and return it's allocated Ada exception\n-   --  (called only from init.c).\n \n end System.VMS_Exception_Table;"}, {"sha": "0e01c8ebfab71e6cfc57c74d99b43d9978251891", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d3009fafe3a4d3660f25ef803c9f266496fa53/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d3009fafe3a4d3660f25ef803c9f266496fa53/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=39d3009fafe3a4d3660f25ef803c9f266496fa53", "patch": "@@ -1998,10 +1998,21 @@ package body Sem_Ch13 is\n \n                --  Refined_Depends\n \n-               --  ??? To be implemented\n+               --  Aspect Refined_Depends must be delayed because it can\n+               --  mention state refinements introduced by aspect Refined_State\n+               --  and further classified by aspect Refined_Global. Since both\n+               --  those aspects are delayed, so is Refined_Depends.\n \n                when Aspect_Refined_Depends =>\n-                  null;\n+                  Make_Aitem_Pragma\n+                    (Pragma_Argument_Associations => New_List (\n+                       Make_Pragma_Argument_Association (Loc,\n+                         Expression => Relocate_Node (Expr))),\n+                     Pragma_Name                  => Name_Refined_Depends);\n+\n+                  Decorate_Delayed_Aspect_And_Pragma (Aspect, Aitem);\n+                  Insert_Delayed_Pragma (Aitem);\n+                  goto Continue;\n \n                --  Refined_Global\n "}, {"sha": "acaf0ef0129c31e0d5dc3535abca29d320a1f36b", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d3009fafe3a4d3660f25ef803c9f266496fa53/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d3009fafe3a4d3660f25ef803c9f266496fa53/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=39d3009fafe3a4d3660f25ef803c9f266496fa53", "patch": "@@ -10393,6 +10393,14 @@ package body Sem_Ch3 is\n             Set_First_Entity (Full, First_Entity (Full_Base));\n             Set_Last_Entity  (Full, Last_Entity (Full_Base));\n \n+            --  If the underlying base type is constrained, we know that the\n+            --  full view of the subtype is constrained as well (the converse\n+            --  is not necessarily true).\n+\n+            if Is_Constrained (Full_Base) then\n+               Set_Is_Constrained (Full);\n+            end if;\n+\n          when others =>\n             Copy_Node (Full_Base, Full);\n "}, {"sha": "7d47436e7a86b3bcb5a28e482e1841c952f18bb0", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d3009fafe3a4d3660f25ef803c9f266496fa53/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d3009fafe3a4d3660f25ef803c9f266496fa53/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=39d3009fafe3a4d3660f25ef803c9f266496fa53", "patch": "@@ -2029,6 +2029,18 @@ package body Sem_Ch6 is\n \n       if Present (Ref_Depends) then\n          Analyze_Refined_Depends_In_Decl_Part (Ref_Depends);\n+\n+      --  When the corresponding Depends aspect/pragma references a state with\n+      --  visible refinement, the body requires Refined_Depends.\n+\n+      elsif Present (Spec_Id) then\n+         Prag := Get_Pragma (Spec_Id, Pragma_Depends);\n+\n+         if Present (Prag) and then Contains_Refined_State (Prag) then\n+            Error_Msg_NE\n+              (\"body of subprogram & requires dependance refinement\",\n+               Body_Decl, Spec_Id);\n+         end if;\n       end if;\n    end Analyze_Subprogram_Body_Contract;\n "}, {"sha": "ec9d9ae824041ce99ea2ccf824a80349009e2556", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 1531, "deletions": 624, "changes": 2155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d3009fafe3a4d3660f25ef803c9f266496fa53/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d3009fafe3a4d3660f25ef803c9f266496fa53/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=39d3009fafe3a4d3660f25ef803c9f266496fa53"}, {"sha": "3f7b30660593d2c44ddabe8cac6bc09250ababf2", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d3009fafe3a4d3660f25ef803c9f266496fa53/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d3009fafe3a4d3660f25ef803c9f266496fa53/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=39d3009fafe3a4d3660f25ef803c9f266496fa53", "patch": "@@ -57,10 +57,12 @@ package Sem_Prag is\n    --  Perform full analysis and expansion of delayed pragma Contract_Cases\n \n    procedure Analyze_Depends_In_Decl_Part (N : Node_Id);\n-   --  Perform full analysis of delayed pragma Depends\n+   --  Perform full analysis of delayed pragma Depends. This routine is also\n+   --  capable of performing basic analysis of pragma Refined_Depends.\n \n    procedure Analyze_Global_In_Decl_Part (N : Node_Id);\n-   --  Perform full analysis of delayed pragma Global\n+   --  Perform full analysis of delayed pragma Global. This routine is also\n+   --  capable of performing basic analysis of pragma Refind_Global.\n \n    procedure Analyze_Initializes_In_Decl_Part (N : Node_Id);\n    --  Perform full analysis of delayed pragma Initializes\n@@ -75,10 +77,14 @@ package Sem_Prag is\n    --  of Default and Per-Object Expressions in Sem).\n \n    procedure Analyze_Refined_Depends_In_Decl_Part (N : Node_Id);\n-   --  Preform full analysis of delayed pragma Refined_Depends\n+   --  Preform full analysis of delayed pragma Refined_Depends. This routine\n+   --  uses Analyze_Depends_In_Decl_Part as a starting point, then performs\n+   --  various consistency checks between Depends and Refined_Depends.\n \n    procedure Analyze_Refined_Global_In_Decl_Part (N : Node_Id);\n-   --  Perform full analysis of delayed pragma Refined_Global\n+   --  Perform full analysis of delayed pragma Refined_Global. This routine\n+   --  uses Analyze_Global_In_Decl_Part as a starting point, then performs\n+   --  various consistency checks between Global and Refined_Global.\n \n    procedure Analyze_Refined_State_In_Decl_Part (N : Node_Id);\n    --  Perform full analysis of delayed pragma Refined_State"}, {"sha": "2f0f41c2402f3a779c31de032f63e3685a256683", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 133, "deletions": 41, "changes": 174, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d3009fafe3a4d3660f25ef803c9f266496fa53/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d3009fafe3a4d3660f25ef803c9f266496fa53/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=39d3009fafe3a4d3660f25ef803c9f266496fa53", "patch": "@@ -3242,59 +3242,86 @@ package body Sem_Util is\n    ----------------------------\n \n    function Contains_Refined_State (Prag : Node_Id) return Boolean is\n-      function Has_Refined_State (List : Node_Id) return Boolean;\n+      function Has_State_In_Dependency (List : Node_Id) return Boolean;\n+      --  Determine whether a dependency list mentions a state with a visible\n+      --  refinement.\n+\n+      function Has_State_In_Global (List : Node_Id) return Boolean;\n       --  Determine whether a global list mentions a state with a visible\n       --  refinement.\n \n-      -----------------------\n-      -- Has_Refined_State --\n-      -----------------------\n+      function Is_Refined_State (Item : Node_Id) return Boolean;\n+      --  Determine whether Item is a reference to an abstract state with a\n+      --  visible refinement.\n \n-      function Has_Refined_State (List : Node_Id) return Boolean is\n-         function Is_Refined_State (Item : Node_Id) return Boolean;\n-         --  Determine whether Item is a reference to an abstract state with a\n-         --  visible refinement.\n+      -----------------------------\n+      -- Has_State_In_Dependency --\n+      -----------------------------\n \n-         ----------------------\n-         -- Is_Refined_State --\n-         ----------------------\n+      function Has_State_In_Dependency (List : Node_Id) return Boolean is\n+         Clause : Node_Id;\n+         Output : Node_Id;\n \n-         function Is_Refined_State (Item : Node_Id) return Boolean is\n-            Item_Id : Entity_Id;\n+      begin\n+         --  A null dependency list does not mention any states\n \n-         begin\n-            if Nkind (Item) = N_Null then\n-               return False;\n+         if Nkind (List) = N_Null then\n+            return False;\n \n-            else\n-               Item_Id := Entity_Of (Item);\n+         --  Dependency clauses appear as component associations of an\n+         --  aggregate.\n \n-               return\n-                 Ekind (Item_Id) = E_Abstract_State\n-                   and then Present (Refinement_Constituents (Item_Id));\n-            end if;\n-         end Is_Refined_State;\n+         elsif Nkind (List) = N_Aggregate\n+           and then Present (Component_Associations (List))\n+         then\n+            Clause := First (Component_Associations (List));\n+            while Present (Clause) loop\n \n-         --  Local variables\n+               --  Inspect the outputs of a dependency clause\n \n-         Item : Node_Id;\n+               Output := First (Choices (Clause));\n+               while Present (Output) loop\n+                  if Is_Refined_State (Output) then\n+                     return True;\n+                  end if;\n+\n+                  Next (Output);\n+               end loop;\n \n-      --  Start of processing for Has_Refined_State\n+               --  Inspect the outputs of a dependency clause\n+\n+               if Is_Refined_State (Expression (Clause)) then\n+                  return True;\n+               end if;\n+\n+               Next (Clause);\n+            end loop;\n+\n+            --  If we get here, then none of the dependency clauses mention a\n+            --  state with visible refinement.\n+\n+            return False;\n+\n+         --  An illegal pragma managed to sneak in\n+\n+         else\n+            raise Program_Error;\n+         end if;\n+      end Has_State_In_Dependency;\n+\n+      -------------------------\n+      -- Has_State_In_Global --\n+      -------------------------\n+\n+      function Has_State_In_Global (List : Node_Id) return Boolean is\n+         Item : Node_Id;\n \n       begin\n          --  A null global list does not mention any states\n \n          if Nkind (List) = N_Null then\n             return False;\n \n-         --  Single global item declaration\n-\n-         elsif Nkind_In (List, N_Expanded_Name,\n-                               N_Identifier,\n-                               N_Selected_Component)\n-         then\n-            return Is_Refined_State (List);\n-\n          --  Simple global list or moded global list declaration\n \n          elsif Nkind (List) = N_Aggregate then\n@@ -3319,7 +3346,7 @@ package body Sem_Util is\n             else\n                Item := First (Component_Associations (List));\n                while Present (Item) loop\n-                  if Has_Refined_State (Expression (Item)) then\n+                  if Has_State_In_Global (Expression (Item)) then\n                      return True;\n                   end if;\n \n@@ -3332,12 +3359,68 @@ package body Sem_Util is\n \n             return False;\n \n-         --  Something went horribly wrong, we have a malformed tree\n+         --  Single global item declaration\n+\n+         elsif Is_Entity_Name (List) then\n+            return Is_Refined_State (List);\n+\n+         --  An illegal pragma managed to sneak in\n \n          else\n             raise Program_Error;\n          end if;\n-      end Has_Refined_State;\n+      end Has_State_In_Global;\n+\n+      ----------------------\n+      -- Is_Refined_State --\n+      ----------------------\n+\n+      function Is_Refined_State (Item : Node_Id) return Boolean is\n+         Elmt    : Node_Id;\n+         Item_Id : Entity_Id;\n+\n+      begin\n+         if Nkind (Item) = N_Null then\n+            return False;\n+\n+         --  States cannot be subject to attribute 'Result. This case arises\n+         --  in dependency relations.\n+\n+         elsif Nkind (Item) = N_Attribute_Reference\n+           and then Attribute_Name (Item) = Name_Result\n+         then\n+            return False;\n+\n+         --  Multiple items appear as an aggregate. This case arises in\n+         --  dependency relations.\n+\n+         elsif Nkind (Item) = N_Aggregate\n+           and then Present (Expressions (Item))\n+         then\n+            Elmt := First (Expressions (Item));\n+            while Present (Elmt) loop\n+               if Is_Refined_State (Elmt) then\n+                  return True;\n+               end if;\n+\n+               Next (Elmt);\n+            end loop;\n+\n+            --  If we get here, then none of the inputs or outputs reference a\n+            --  state with visible refinement.\n+\n+            return False;\n+\n+         --  Single item\n+\n+         else\n+            Item_Id := Entity_Of (Item);\n+\n+            return\n+              Ekind (Item_Id) = E_Abstract_State\n+                and then Present (Refinement_Constituents (Item_Id));\n+         end if;\n+      end Is_Refined_State;\n \n       --  Local variables\n \n@@ -3348,13 +3431,11 @@ package body Sem_Util is\n    --  Start of processing for Contains_Refined_State\n \n    begin\n-      --  ??? To be implemented\n-\n       if Nam = Name_Depends then\n-         return False;\n+         return Has_State_In_Dependency (Arg);\n \n       else pragma Assert (Nam = Name_Global);\n-         return Has_Refined_State (Arg);\n+         return Has_State_In_Global (Arg);\n       end if;\n    end Contains_Refined_State;\n \n@@ -8188,6 +8269,17 @@ package body Sem_Util is\n       end if;\n    end Is_Atomic_Object;\n \n+   -------------------------\n+   -- Is_Attribute_Result --\n+   -------------------------\n+\n+   function Is_Attribute_Result (N : Node_Id) return Boolean is\n+   begin\n+      return\n+         Nkind (N) = N_Attribute_Reference\n+           and then Attribute_Name (N) = Name_Result;\n+   end Is_Attribute_Result;\n+\n    ------------------------------------\n    -- Is_Body_Or_Package_Declaration --\n    ------------------------------------"}, {"sha": "8eaa58014c89e6ee23aee308c586ad5c31c1a969", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39d3009fafe3a4d3660f25ef803c9f266496fa53/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39d3009fafe3a4d3660f25ef803c9f266496fa53/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=39d3009fafe3a4d3660f25ef803c9f266496fa53", "patch": "@@ -902,6 +902,9 @@ package Sem_Util is\n    --  Determines if the given node denotes an atomic object in the sense of\n    --  the legality checks described in RM C.6(12).\n \n+   function Is_Attribute_Result (N : Node_Id) return Boolean;\n+   --  Determine whether node N denotes attribute 'Result\n+\n    function Is_Body_Or_Package_Declaration (N : Node_Id) return Boolean;\n    --  Determine whether node N denotes a body or a package declaration\n "}]}