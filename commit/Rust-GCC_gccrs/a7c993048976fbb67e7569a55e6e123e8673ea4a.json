{"sha": "a7c993048976fbb67e7569a55e6e123e8673ea4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdjOTkzMDQ4OTc2ZmJiNjdlNzU2OWE1NWU2ZTEyM2U4NjczZWE0YQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-05T17:14:56Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-04-05T17:14:56Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r689", "tree": {"sha": "1e59adb26278ca1136362d3dcd6b0f052891b7c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e59adb26278ca1136362d3dcd6b0f052891b7c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7c993048976fbb67e7569a55e6e123e8673ea4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7c993048976fbb67e7569a55e6e123e8673ea4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7c993048976fbb67e7569a55e6e123e8673ea4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7c993048976fbb67e7569a55e6e123e8673ea4a/comments", "author": null, "committer": null, "parents": [{"sha": "8b3686ed860ccf729560c6d78fee95c2fa42cea5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b3686ed860ccf729560c6d78fee95c2fa42cea5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b3686ed860ccf729560c6d78fee95c2fa42cea5"}], "stats": {"total": 93, "additions": 76, "deletions": 17}, "files": [{"sha": "38788465982fb3c6fc91908738fc0c21ca1c3ead", "filename": "gcc/combine.c", "status": "modified", "additions": 76, "deletions": 17, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7c993048976fbb67e7569a55e6e123e8673ea4a/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7c993048976fbb67e7569a55e6e123e8673ea4a/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=a7c993048976fbb67e7569a55e6e123e8673ea4a", "patch": "@@ -3521,6 +3521,13 @@ subst (x, from, to, in_dest, unique_copy)\n \t}\n       break;\n \n+    case FFS:\n+      /* (ffs (*_extend <X>)) = (ffs <X>) */\n+      if (GET_CODE (XEXP (x, 0)) == SIGN_EXTEND\n+\t  || GET_CODE (XEXP (x, 0)) == ZERO_EXTEND)\n+\tSUBST (XEXP (x, 0), XEXP (XEXP (x, 0), 0));\n+      break;\n+\n     case FLOAT:\n       /* (float (sign_extend <X>)) = (float <X>).  */\n       if (GET_CODE (XEXP (x, 0)) == SIGN_EXTEND)\n@@ -4145,7 +4152,20 @@ make_compound_operation (x, in_code)\n \t\t\t       XEXP (SUBREG_REG (XEXP (x, 0)), 1), i, 1,\n \t\t\t       0, in_code == COMPARE);\n \n-      /* One machines without logical shifts, if the operand of the AND is\n+\n+      /* If we are have (and (rotate X C) M) and C is larger than the number\n+\t of bits in M, this is an extraction.  */\n+\n+      else if (GET_CODE (XEXP (x, 0)) == ROTATE\n+\t       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n+\t       && (i = exact_log2 (INTVAL (XEXP (x, 1)) + 1)) >= 0\n+\t       && i <= INTVAL (XEXP (XEXP (x, 0), 1)))\n+\tnew = make_extraction (mode, XEXP (XEXP (x, 0), 0),\n+\t\t\t       (GET_MODE_BITSIZE (mode)\n+\t\t\t\t- INTVAL (XEXP (XEXP (x, 0), 1))),\n+\t\t\t       0, i, 1, 0, in_code == COMPARE);\n+\n+      /* On machines without logical shifts, if the operand of the AND is\n \t a logical shift and our mask turns off all the propagated sign\n \t bits, we can replace the logical shift with an arithmetic shift.  */\n       else if (\n@@ -6191,7 +6211,7 @@ gen_lowpart_for_combine (mode, x)\n \n   /* If we couldn't simplify X any other way, just enclose it in a\n      SUBREG.  Normally, this SUBREG won't match, but some patterns may\n-     include and explicit SUBREG or we may simplify it further in combine.  */\n+     include an explicit SUBREG or we may simplify it further in combine.  */\n   else\n     {\n       int word = 0;\n@@ -7609,15 +7629,31 @@ move_deaths (x, from_cuid, to_insn, pnotes)\n \n       move_deaths (SET_SRC (x), from_cuid, to_insn, pnotes);\n \n-      if (GET_CODE (dest) == ZERO_EXTRACT)\n+      /* In the case of a ZERO_EXTRACT, a STRICT_LOW_PART, or a SUBREG\n+\t that accesses one word of a multi-word item, some\n+\t piece of everything register in the expression is used by\n+\t this insn, so remove any old death.  */\n+\n+      if (GET_CODE (dest) == ZERO_EXTRACT\n+\t  || GET_CODE (dest) == STRICT_LOW_PART\n+\t  || (GET_CODE (dest) == SUBREG\n+\t      && (((GET_MODE_SIZE (GET_MODE (dest))\n+\t\t    + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\t\t  == ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest)))\n+\t\t       + UNITS_PER_WORD - 1) / UNITS_PER_WORD))))\n \t{\n-\t  move_deaths (XEXP (dest, 1), from_cuid, to_insn, pnotes);\n-\t  move_deaths (XEXP (dest, 2), from_cuid, to_insn, pnotes);\n+\t  move_deaths (dest, from_cuid, to_insn, pnotes);\n+\t  return;\n \t}\n \n-      while (GET_CODE (dest) == ZERO_EXTRACT || GET_CODE (dest) == SUBREG\n-\t     || GET_CODE (dest) == STRICT_LOW_PART)\n-\tdest = XEXP (dest, 0);\n+      /* If this is some other SUBREG, we know it replaces the entire\n+\t value, so use that as the destination.  */\n+      if (GET_CODE (dest) == SUBREG)\n+\tdest = SUBREG_REG (dest);\n+\n+      /* If this is a MEM, adjust deaths of anything used in the address.\n+\t For a REG (the only other possibility), the entire value is\n+\t being replaced so the old value is not used in this insn.  */\n \n       if (GET_CODE (dest) == MEM)\n \tmove_deaths (XEXP (dest, 0), from_cuid, to_insn, pnotes);\n@@ -7643,25 +7679,48 @@ move_deaths (x, from_cuid, to_insn, pnotes)\n     }\n }\n \f\n-/* Return 1 if REG is the target of a bit-field assignment in BODY, the\n-   pattern of an insn.  */\n+/* Return 1 if X is the target of a bit-field assignment in BODY, the\n+   pattern of an insn.  X must be a REG.  */\n \n static int\n-reg_bitfield_target_p (reg, body)\n-     rtx reg;\n+reg_bitfield_target_p (x, body)\n+     rtx x;\n      rtx body;\n {\n   int i;\n \n   if (GET_CODE (body) == SET)\n-    return ((GET_CODE (SET_DEST (body)) == ZERO_EXTRACT\n-\t     && rtx_equal_p (reg, XEXP (SET_DEST (body), 0)))\n-\t    || (GET_CODE (SET_DEST (body)) == STRICT_LOW_PART\n-\t\t&& rtx_equal_p (reg, SUBREG_REG (XEXP (SET_DEST (body), 0)))));\n+    {\n+      rtx dest = SET_DEST (body);\n+      rtx target;\n+      int regno, tregno, endregno, endtregno;\n+\n+      if (GET_CODE (dest) == ZERO_EXTRACT)\n+\ttarget = XEXP (dest, 0);\n+      else if (GET_CODE (dest) == STRICT_LOW_PART)\n+\ttarget = SUBREG_REG (XEXP (dest, 0));\n+      else\n+\treturn 0;\n+\n+      if (GET_CODE (target) == SUBREG)\n+\ttarget = SUBREG_REG (target);\n+\n+      if (GET_CODE (target) != REG)\n+\treturn 0;\n+\n+      tregno = REGNO (target), regno = REGNO (x);\n+      if (tregno >= FIRST_PSEUDO_REGISTER || regno >= FIRST_PSEUDO_REGISTER)\n+\treturn target == x;\n+\n+      endtregno = tregno + HARD_REGNO_NREGS (tregno, GET_MODE (target));\n+      endregno = regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n+\n+      return endregno > tregno && regno < endtregno;\n+    }\n \n   else if (GET_CODE (body) == PARALLEL)\n     for (i = XVECLEN (body, 0) - 1; i >= 0; i--)\n-      if (reg_bitfield_target_p (reg, XVECEXP (body, 0, i)))\n+      if (reg_bitfield_target_p (x, XVECEXP (body, 0, i)))\n \treturn 1;\n \n   return 0;"}]}