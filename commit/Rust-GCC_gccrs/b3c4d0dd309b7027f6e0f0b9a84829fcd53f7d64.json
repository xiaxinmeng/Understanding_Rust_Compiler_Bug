{"sha": "b3c4d0dd309b7027f6e0f0b9a84829fcd53f7d64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNjNGQwZGQzMDliNzAyN2Y2ZTBmMGI5YTg0ODI5ZmNkNTNmN2Q2NA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-09-19T17:19:31Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-09-19T17:19:31Z"}, "message": "tree-vect-loop.c (vect_is_slp_reduction): Remove.\n\n2019-09-19  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vect-loop.c (vect_is_slp_reduction): Remove.\n\t(check_reduction_path): New overload having the path as result.\n\t(vect_is_simple_reduction): From the detected reduction\n\tpath build a SLP reduction chain if possible.\n\nFrom-SVN: r275972", "tree": {"sha": "8376cc6020cd54cbda58d6550abab52ae91f8a96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8376cc6020cd54cbda58d6550abab52ae91f8a96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3c4d0dd309b7027f6e0f0b9a84829fcd53f7d64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3c4d0dd309b7027f6e0f0b9a84829fcd53f7d64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3c4d0dd309b7027f6e0f0b9a84829fcd53f7d64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3c4d0dd309b7027f6e0f0b9a84829fcd53f7d64/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "54dc857754b64ae1e56191d983ae2c4434d96fb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54dc857754b64ae1e56191d983ae2c4434d96fb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54dc857754b64ae1e56191d983ae2c4434d96fb2"}], "stats": {"total": 226, "additions": 54, "deletions": 172}, "files": [{"sha": "e7fededd9b91a0d0bbd5b2d4daa49bef8981a7ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c4d0dd309b7027f6e0f0b9a84829fcd53f7d64/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c4d0dd309b7027f6e0f0b9a84829fcd53f7d64/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b3c4d0dd309b7027f6e0f0b9a84829fcd53f7d64", "patch": "@@ -1,3 +1,10 @@\n+2019-09-19  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vect-loop.c (vect_is_slp_reduction): Remove.\n+\t(check_reduction_path): New overload having the path as result.\n+\t(vect_is_simple_reduction): From the detected reduction\n+\tpath build a SLP reduction chain if possible.\n+\n 2019-09-19  Richard Biener  <rguenther@suse.de>\n \n \tPR target/91814"}, {"sha": "9a4d960d9b218c63a32363c5b62291072122063e", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 47, "deletions": 172, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3c4d0dd309b7027f6e0f0b9a84829fcd53f7d64/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3c4d0dd309b7027f6e0f0b9a84829fcd53f7d64/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=b3c4d0dd309b7027f6e0f0b9a84829fcd53f7d64", "patch": "@@ -2541,163 +2541,6 @@ vect_valid_reduction_input_p (stmt_vec_info def_stmt_info)\n \t      && !is_loop_header_bb_p (gimple_bb (def_stmt_info->stmt))));\n }\n \n-/* Detect SLP reduction of the form:\n-\n-   #a1 = phi <a5, a0>\n-   a2 = operation (a1)\n-   a3 = operation (a2)\n-   a4 = operation (a3)\n-   a5 = operation (a4)\n-\n-   #a = phi <a5>\n-\n-   PHI is the reduction phi node (#a1 = phi <a5, a0> above)\n-   FIRST_STMT is the first reduction stmt in the chain\n-   (a2 = operation (a1)).\n-\n-   Return TRUE if a reduction chain was detected.  */\n-\n-static bool\n-vect_is_slp_reduction (loop_vec_info loop_info, gimple *phi,\n-\t\t       gimple *first_stmt)\n-{\n-  class loop *loop = (gimple_bb (phi))->loop_father;\n-  class loop *vect_loop = LOOP_VINFO_LOOP (loop_info);\n-  enum tree_code code;\n-  gimple *loop_use_stmt = NULL;\n-  stmt_vec_info use_stmt_info;\n-  tree lhs;\n-  imm_use_iterator imm_iter;\n-  use_operand_p use_p;\n-  int nloop_uses, size = 0, n_out_of_loop_uses;\n-  bool found = false;\n-\n-  if (loop != vect_loop)\n-    return false;\n-\n-  auto_vec<stmt_vec_info, 8> reduc_chain;\n-  lhs = PHI_RESULT (phi);\n-  code = gimple_assign_rhs_code (first_stmt);\n-  while (1)\n-    {\n-      nloop_uses = 0;\n-      n_out_of_loop_uses = 0;\n-      FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)\n-        {\n-\t  gimple *use_stmt = USE_STMT (use_p);\n-\t  if (is_gimple_debug (use_stmt))\n-\t    continue;\n-\n-          /* Check if we got back to the reduction phi.  */\n-\t  if (use_stmt == phi)\n-            {\n-\t      loop_use_stmt = use_stmt;\n-              found = true;\n-              break;\n-            }\n-\n-          if (flow_bb_inside_loop_p (loop, gimple_bb (use_stmt)))\n-            {\n-\t      loop_use_stmt = use_stmt;\n-\t      nloop_uses++;\n-            }\n-           else\n-             n_out_of_loop_uses++;\n-\n-           /* There are can be either a single use in the loop or two uses in\n-              phi nodes.  */\n-           if (nloop_uses > 1 || (n_out_of_loop_uses && nloop_uses))\n-             return false;\n-        }\n-\n-      if (found)\n-        break;\n-\n-      /* We reached a statement with no loop uses.  */\n-      if (nloop_uses == 0)\n-\treturn false;\n-\n-      /* This is a loop exit phi, and we haven't reached the reduction phi.  */\n-      if (gimple_code (loop_use_stmt) == GIMPLE_PHI)\n-        return false;\n-\n-      if (!is_gimple_assign (loop_use_stmt)\n-\t  || code != gimple_assign_rhs_code (loop_use_stmt)\n-\t  || !flow_bb_inside_loop_p (loop, gimple_bb (loop_use_stmt)))\n-        return false;\n-\n-      /* Insert USE_STMT into reduction chain.  */\n-      use_stmt_info = loop_info->lookup_stmt (loop_use_stmt);\n-      reduc_chain.safe_push (use_stmt_info);\n-\n-      lhs = gimple_assign_lhs (loop_use_stmt);\n-      size++;\n-   }\n-\n-  if (!found || loop_use_stmt != phi || size < 2)\n-    return false;\n-\n-  /* Swap the operands, if needed, to make the reduction operand be the second\n-     operand.  */\n-  lhs = PHI_RESULT (phi);\n-  for (unsigned i = 0; i < reduc_chain.length (); ++i)\n-    {\n-      gassign *next_stmt = as_a <gassign *> (reduc_chain[i]->stmt);\n-      if (gimple_assign_rhs2 (next_stmt) == lhs)\n-\t{\n-\t  tree op = gimple_assign_rhs1 (next_stmt);\n-\t  stmt_vec_info def_stmt_info = loop_info->lookup_def (op);\n-\n-\t  /* Check that the other def is either defined in the loop\n-\t     (\"vect_internal_def\"), or it's an induction (defined by a\n-\t     loop-header phi-node).  */\n-\t  if (def_stmt_info\n-\t      && flow_bb_inside_loop_p (loop, gimple_bb (def_stmt_info->stmt))\n-\t      && vect_valid_reduction_input_p (def_stmt_info))\n-\t    {\n-\t      lhs = gimple_assign_lhs (next_stmt);\n- \t      continue;\n-\t    }\n-\n-\t  return false;\n-\t}\n-      else\n-\t{\n-\t  gcc_assert (gimple_assign_rhs1 (next_stmt) == lhs);\n-\t  tree op = gimple_assign_rhs2 (next_stmt);\n-\t  stmt_vec_info def_stmt_info = loop_info->lookup_def (op);\n-\n-          /* Check that the other def is either defined in the loop\n-            (\"vect_internal_def\"), or it's an induction (defined by a\n-            loop-header phi-node).  */\n-\t  if (def_stmt_info\n-\t      && flow_bb_inside_loop_p (loop, gimple_bb (def_stmt_info->stmt))\n-\t      && vect_valid_reduction_input_p (def_stmt_info))\n-  \t    {\n-\t      lhs = gimple_assign_lhs (next_stmt);\n-\t      continue;\n-\t    }\n-\n-\t  return false;\n-        }\n-    }\n-\n-  /* Build up the actual chain.  */\n-  for (unsigned i = 0; i < reduc_chain.length () - 1; ++i)\n-    {\n-      REDUC_GROUP_FIRST_ELEMENT (reduc_chain[i]) = reduc_chain[0];\n-      REDUC_GROUP_NEXT_ELEMENT (reduc_chain[i]) = reduc_chain[i+1];\n-    }\n-  REDUC_GROUP_FIRST_ELEMENT (reduc_chain.last ()) = reduc_chain[0];\n-  REDUC_GROUP_NEXT_ELEMENT (reduc_chain.last ()) = NULL;\n-\n-  /* Save the chain for further analysis in SLP detection.  */\n-  LOOP_VINFO_REDUCTION_CHAINS (loop_info).safe_push (reduc_chain[0]);\n-  REDUC_GROUP_SIZE (reduc_chain[0]) = size;\n-\n-  return true;\n-}\n-\n /* Return true if we need an in-order reduction for operation CODE\n    on type TYPE.  NEED_WRAPPING_INTEGRAL_OVERFLOW is true if integer\n    overflow must wrap.  */\n@@ -2738,11 +2581,11 @@ needs_fold_left_reduction_p (tree type, tree_code code,\n /* Return true if the reduction PHI in LOOP with latch arg LOOP_ARG and\n    reduction operation CODE has a handled computation expression.  */\n \n-bool\n+static bool\n check_reduction_path (dump_user_location_t loc, loop_p loop, gphi *phi,\n-\t\t      tree loop_arg, enum tree_code code)\n+\t\t      tree loop_arg, enum tree_code code,\n+\t\t      vec<std::pair<ssa_op_iter, use_operand_p> > &path)\n {\n-  auto_vec<std::pair<ssa_op_iter, use_operand_p> > path;\n   auto_bitmap visited;\n   tree lookfor = PHI_RESULT (phi);\n   ssa_op_iter curri;\n@@ -2839,6 +2682,15 @@ check_reduction_path (dump_user_location_t loc, loop_p loop, gphi *phi,\n   return ! fail && ! neg;\n }\n \n+bool\n+check_reduction_path (dump_user_location_t loc, loop_p loop, gphi *phi,\n+\t\t      tree loop_arg, enum tree_code code)\n+{\n+  auto_vec<std::pair<ssa_op_iter, use_operand_p> > path;\n+  return check_reduction_path (loc, loop, phi, loop_arg, code, path);\n+}\n+\n+\n \n /* Function vect_is_simple_reduction\n \n@@ -3223,23 +3075,46 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n       return def_stmt_info;\n     }\n \n-  /* Try to find SLP reduction chain.  */\n-  if (! nested_in_vect_loop\n-      && code != COND_EXPR\n-      && orig_code != MINUS_EXPR\n-      && vect_is_slp_reduction (loop_info, phi, def_stmt))\n+  /* Look for the expression computing loop_arg from loop PHI result.  */\n+  auto_vec<std::pair<ssa_op_iter, use_operand_p> > path;\n+  if (check_reduction_path (vect_location, loop, phi, loop_arg, code,\n+\t\t\t    path))\n     {\n-      if (dump_enabled_p ())\n-        report_vect_op (MSG_NOTE, def_stmt,\n-\t\t\t\"reduction: detected reduction chain: \");\n+      /* Try building an SLP reduction chain for which the additional\n+         restriction is that all operations in the chain are the same.  */\n+      auto_vec<stmt_vec_info, 8> reduc_chain;\n+      unsigned i;\n+      for (i = path.length () - 1; i >= 1; --i)\n+\t{\n+\t  gimple *stmt = USE_STMT (path[i].second);\n+\t  if (gimple_assign_rhs_code (stmt) != code)\n+\t    break;\n+\t  reduc_chain.safe_push (loop_info->lookup_stmt (stmt));\n+\t}\n+      if (i == 0\n+\t  && ! nested_in_vect_loop\n+\t  && code != COND_EXPR)\n+\t{\n+\t  for (unsigned i = 0; i < reduc_chain.length () - 1; ++i)\n+\t    {\n+\t      REDUC_GROUP_FIRST_ELEMENT (reduc_chain[i]) = reduc_chain[0];\n+\t      REDUC_GROUP_NEXT_ELEMENT (reduc_chain[i]) = reduc_chain[i+1];\n+\t    }\n+\t  REDUC_GROUP_FIRST_ELEMENT (reduc_chain.last ()) = reduc_chain[0];\n+\t  REDUC_GROUP_NEXT_ELEMENT (reduc_chain.last ()) = NULL;\n+\n+\t  /* Save the chain for further analysis in SLP detection.  */\n+\t  LOOP_VINFO_REDUCTION_CHAINS (loop_info).safe_push (reduc_chain[0]);\n+\t  REDUC_GROUP_SIZE (reduc_chain[0]) = reduc_chain.length ();\n+\n+\t  if (dump_enabled_p ())\n+\t    report_vect_op (MSG_NOTE, def_stmt,\n+\t\t\t    \"reduction: detected reduction chain: \");\n+\t}\n \n       return def_stmt_info;\n     }\n \n-  /* Look for the expression computing loop_arg from loop PHI result.  */\n-  if (check_reduction_path (vect_location, loop, phi, loop_arg, code))\n-    return def_stmt_info;\n-\n   if (dump_enabled_p ())\n     {\n       report_vect_op (MSG_MISSED_OPTIMIZATION, def_stmt,"}]}