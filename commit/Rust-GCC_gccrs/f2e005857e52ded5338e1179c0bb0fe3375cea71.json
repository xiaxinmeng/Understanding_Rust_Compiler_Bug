{"sha": "f2e005857e52ded5338e1179c0bb0fe3375cea71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJlMDA1ODU3ZTUyZGVkNTMzOGUxMTc5YzBiYjBmZTMzNzVjZWE3MQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-11-13T22:57:53Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-11-13T22:57:53Z"}, "message": "Improve handling of pool_options::largest_required_pool_block\n\nMake the munge_options function round the largest_required_pool_block\nvalue to a multiple of the smallest pool size (currently 8 bytes) to\navoid pools with odd sizes.\n\nEnsure there is a pool large enough for blocks of the requested size.\nPreviously when largest_required_pool_block was exactly equal to one of\nthe pool_sizes[] values there would be no pool of that size. This patch\nincreases _M_npools by one, so there is a pool at least as large as the\nrequested value. It also reduces the size of the largest pool to be no\nlarger than needed.\n\n\t* src/c++17/memory_resource.cc (munge_options): Round up value of\n\tlargest_required_pool_block to multiple of smallest pool size. Round\n\texcessively large values down to largest pool size.\n\t(select_num_pools): Increase number of pools by one unless it exactly\n\tmatches requested largest_required_pool_block.\n\t(__pool_resource::_M_alloc_pools()): Make largest pool size equal\n\tlargest_required_pool_block.\n\t* testsuite/20_util/unsynchronized_pool_resource/options.cc: Check\n\tthat pool_options::largest_required_pool_block is set appropriately.\n\nFrom-SVN: r266089", "tree": {"sha": "7215d345c266d8938cae0627f3d5592b824785d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7215d345c266d8938cae0627f3d5592b824785d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2e005857e52ded5338e1179c0bb0fe3375cea71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2e005857e52ded5338e1179c0bb0fe3375cea71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2e005857e52ded5338e1179c0bb0fe3375cea71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2e005857e52ded5338e1179c0bb0fe3375cea71/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3306a84a6cc954ff9d28d8a915a891fe15270f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3306a84a6cc954ff9d28d8a915a891fe15270f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3306a84a6cc954ff9d28d8a915a891fe15270f5"}], "stats": {"total": 122, "additions": 101, "deletions": 21}, "files": [{"sha": "97fbea7cc861ddc97bf0b3756d12de5c0deb8310", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2e005857e52ded5338e1179c0bb0fe3375cea71/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2e005857e52ded5338e1179c0bb0fe3375cea71/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f2e005857e52ded5338e1179c0bb0fe3375cea71", "patch": "@@ -1,5 +1,15 @@\n 2018-11-13  Jonathan Wakely  <jwakely@redhat.com>\n \n+\t* src/c++17/memory_resource.cc (munge_options): Round up value of\n+\tlargest_required_pool_block to multiple of smallest pool size. Round\n+\texcessively large values down to largest pool size.\n+\t(select_num_pools): Increase number of pools by one unless it exactly\n+\tmatches requested largest_required_pool_block.\n+\t(__pool_resource::_M_alloc_pools()): Make largest pool size equal\n+\tlargest_required_pool_block.\n+\t* testsuite/20_util/unsynchronized_pool_resource/options.cc: Check\n+\tthat pool_options::largest_required_pool_block is set appropriately.\n+\n \t* src/c++17/memory_resource.cc (big_block): Improve comments.\n \t(big_block::all_ones): Remove.\n \t(big_block::big_block(size_t, size_t)): Use alloc_size."}, {"sha": "691a2999de6dfb22e1aed6e494554312f53fe532", "filename": "libstdc++-v3/src/c++17/memory_resource.cc", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2e005857e52ded5338e1179c0bb0fe3375cea71/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2e005857e52ded5338e1179c0bb0fe3375cea71/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc?ref=f2e005857e52ded5338e1179c0bb0fe3375cea71", "patch": "@@ -830,6 +830,19 @@ namespace pmr\n \n   namespace {\n \n+  constexpr size_t pool_sizes[] = {\n+      8, 16, 24,\n+      32, 48,\n+      64, 80, 96, 112,\n+      128, 192,\n+      256, 320, 384, 448,\n+      512, 768,\n+      1024, 1536,\n+      2048, 3072,\n+      1<<12, 1<<13, 1<<14, 1<<15, 1<<16, 1<<17,\n+      1<<20, 1<<21, 1<<22 // 4MB should be enough for anybody\n+  };\n+\n   pool_options\n   munge_options(pool_options opts)\n   {\n@@ -860,29 +873,25 @@ namespace pmr\n       }\n     else\n       {\n-\t// TODO round to preferred granularity ?\n+\t// Round to preferred granularity\n+\tstatic_assert(std::__ispow2(pool_sizes[0]));\n+\tconstexpr size_t mask = pool_sizes[0] - 1;\n+\topts.largest_required_pool_block += mask;\n+\topts.largest_required_pool_block &= ~mask;\n       }\n \n     if (opts.largest_required_pool_block < big_block::min)\n       {\n \topts.largest_required_pool_block = big_block::min;\n       }\n+    else if (opts.largest_required_pool_block > std::end(pool_sizes)[-1])\n+      {\n+\t// Setting _M_opts to the largest pool allows users to query it:\n+\topts.largest_required_pool_block = std::end(pool_sizes)[-1];\n+      }\n     return opts;\n   }\n \n-  const size_t pool_sizes[] = {\n-      8, 16, 24,\n-      32, 48,\n-      64, 80, 96, 112,\n-      128, 192,\n-      256, 320, 384, 448,\n-      512, 768,\n-      1024, 1536,\n-      2048, 3072,\n-      1<<12, 1<<13, 1<<14, 1<<15, 1<<16, 1<<17,\n-      1<<20, 1<<21, 1<<22 // 4MB should be enough for anybody\n-  };\n-\n   inline int\n   pool_index(size_t block_size, int npools)\n   {\n@@ -898,9 +907,10 @@ namespace pmr\n   {\n     auto p = std::lower_bound(std::begin(pool_sizes), std::end(pool_sizes),\n \t\t\t      opts.largest_required_pool_block);\n-    if (int npools = p - std::begin(pool_sizes))\n-      return npools;\n-    return 1;\n+    const int n = p - std::begin(pool_sizes);\n+    if (p == std::end(pool_sizes) || *p == opts.largest_required_pool_block)\n+      return n;\n+    return n + 1;\n   }\n \n   } // namespace\n@@ -971,7 +981,11 @@ namespace pmr\n     _Pool* p = alloc.allocate(_M_npools);\n     for (int i = 0; i < _M_npools; ++i)\n       {\n-\tconst size_t block_size = pool_sizes[i];\n+\t// For last pool use largest_required_pool_block\n+\tconst size_t block_size = (i+1 == _M_npools)\n+\t  ? _M_opts.largest_required_pool_block\n+\t  : pool_sizes[i];\n+\n \t// Decide on initial number of blocks per chunk.\n \t// Always have at least 16 blocks per chunk:\n \tconst size_t min_blocks_per_chunk = 16;"}, {"sha": "a3e4c44aff0bce97168591495080dda5d59910df", "filename": "libstdc++-v3/testsuite/20_util/unsynchronized_pool_resource/options.cc", "status": "modified", "additions": 59, "deletions": 3, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2e005857e52ded5338e1179c0bb0fe3375cea71/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Foptions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2e005857e52ded5338e1179c0bb0fe3375cea71/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Foptions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Funsynchronized_pool_resource%2Foptions.cc?ref=f2e005857e52ded5338e1179c0bb0fe3375cea71", "patch": "@@ -20,6 +20,13 @@\n \n #include <memory_resource>\n #include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+bool eq(const std::pmr::pool_options& lhs, const std::pmr::pool_options& rhs)\n+{\n+  return lhs.max_blocks_per_chunk == rhs.max_blocks_per_chunk\n+    && lhs.largest_required_pool_block == rhs.largest_required_pool_block;\n+}\n \n void\n test01()\n@@ -30,13 +37,62 @@ test01()\n   VERIFY( opts.largest_required_pool_block != 0 );\n \n   std::pmr::unsynchronized_pool_resource r1(opts);\n-  auto [max_blocks_per_chunk, largest_required_pool_block ] = r1.options();\n-  VERIFY( max_blocks_per_chunk == opts.max_blocks_per_chunk );\n-  VERIFY( largest_required_pool_block == opts.largest_required_pool_block );\n+  const auto opts1 = r1.options();\n+  VERIFY( eq(opts, opts1) );\n+\n+  std::pmr::unsynchronized_pool_resource r2(std::pmr::pool_options{0, 0});\n+  const auto opts2 = r2.options();\n+  VERIFY( eq(opts, opts2) );\n+}\n+\n+void\n+test02()\n+{\n+  std::pmr::pool_options opts{0, 0};\n+  std::size_t num_allocs = 0;\n+\n+  __gnu_test::memory_resource test_mr;\n+\n+  std::pmr::unsynchronized_pool_resource r1(opts, &test_mr);\n+  opts = r1.options();\n+  // opts.largest_required_pool_block should be set to the block size of\n+  // the largest pool (this is a GNU extension). Confirm this by checking\n+  // that allocations larger than opts.largest_required_pool_block come\n+  // directly from the upstream allocator, test_mr, not from r1's pools.\n+\n+  // The following should result in a \"large\" allocation direct from upstream:\n+  (void) r1.allocate(opts.largest_required_pool_block + 1);\n+  num_allocs = test_mr.number_of_active_allocations();\n+  // This should result in another \"large\" allocation direct from upstream:\n+  (void) r1.allocate(opts.largest_required_pool_block + 1);\n+  // Which means the number of upstream allocations should have increased:\n+  VERIFY( test_mr.number_of_active_allocations() > num_allocs );\n+  r1.release();\n+\n+  // Repeat with a user-specified block size:\n+  opts.largest_required_pool_block = 64;\n+  std::pmr::unsynchronized_pool_resource r2(opts, &test_mr);\n+  opts = r2.options();\n+  (void) r2.allocate(opts.largest_required_pool_block + 1);\n+  num_allocs = test_mr.number_of_active_allocations();\n+  (void) r2.allocate(opts.largest_required_pool_block + 1);\n+  VERIFY( test_mr.number_of_active_allocations() > num_allocs );\n+  r2.release();\n+\n+  // Repeat with an odd user-specified block size:\n+  opts.largest_required_pool_block = 71;\n+  std::pmr::unsynchronized_pool_resource r3(opts, &test_mr);\n+  opts = r3.options();\n+  (void) r3.allocate(opts.largest_required_pool_block + 1);\n+  num_allocs = test_mr.number_of_active_allocations();\n+  (void) r3.allocate(opts.largest_required_pool_block + 1);\n+  VERIFY( test_mr.number_of_active_allocations() > num_allocs );\n+  r3.release();\n }\n \n int\n main()\n {\n   test01();\n+  test02();\n }"}]}