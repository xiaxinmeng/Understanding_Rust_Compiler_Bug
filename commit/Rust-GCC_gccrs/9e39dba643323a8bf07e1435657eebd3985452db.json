{"sha": "9e39dba643323a8bf07e1435657eebd3985452db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWUzOWRiYTY0MzMyM2E4YmYwN2UxNDM1NjU3ZWViZDM5ODU0NTJkYg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-02-19T10:12:25Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-02-19T10:12:25Z"}, "message": "re PR tree-optimization/39207 (Strict aliasing warnings in libstdc++ headers)\n\n2009-02-19  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/39207\n\tPR tree-optimization/39074\n\t* tree-ssa-structalias.c (storedanything_id, var_storedanything,\n\tstoredanything_tree): New.\n\t(do_ds_constraint): Simplify ANYTHING shortcutting.  Update\n\tthe STOREDANYTHING solution if the lhs solution contains\n\tANYTHING.\n\t(build_succ_graph): Add edges from STOREDANYTHING to all\n\tnon-direct nodes.\n\t(init_base_vars): Initialize STOREDANYTHING.\n\t(compute_points_to_sets): Free substitution info after\n\tbuilding the succ graph.\n\t(ipa_pta_execute): Likewise.\n\n\t* gcc.dg/torture/pr39074.c: New testcase.\n\t* gcc.dg/torture/pr39074-2.c: Likewise.\n\t* gcc.dg/torture/pr39074-3.c: Likewise.\n\n\t* tree-ssa-structalias.c (struct variable_info): Add may_have_pointers\n\tfield.\n\t(do_ds_constraint): Do not add to special var or non-pointer\n\tfield solutions.\n\t(type_could_have_pointers): Split out from ...\n\t(could_have_pointers): ... here.  For arrays use the element type.\n\t(create_variable_info_for): Initialize may_have_pointers.\n\t(new_var_info): Likewise.\n\t(handle_lhs_call): Make the HEAP variable unknown-sized.\n\t(intra_create_variable_infos): Use a type with pointers for\n\tPARM_NOALIAS, make it unknown-sized.\n\nFrom-SVN: r144292", "tree": {"sha": "8ded01ebc07aa42d47fe86aff0ccaeeb166b029d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ded01ebc07aa42d47fe86aff0ccaeeb166b029d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e39dba643323a8bf07e1435657eebd3985452db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e39dba643323a8bf07e1435657eebd3985452db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e39dba643323a8bf07e1435657eebd3985452db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e39dba643323a8bf07e1435657eebd3985452db/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aac2878e169cba8104e4458e24744f6b56cf87b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aac2878e169cba8104e4458e24744f6b56cf87b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aac2878e169cba8104e4458e24744f6b56cf87b4"}], "stats": {"total": 281, "additions": 226, "deletions": 55}, "files": [{"sha": "4d9cf7d554bdbbb334959c1e5b90f22b16c44188", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e39dba643323a8bf07e1435657eebd3985452db/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e39dba643323a8bf07e1435657eebd3985452db/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e39dba643323a8bf07e1435657eebd3985452db", "patch": "@@ -1,3 +1,31 @@\n+2009-02-19  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/39207\n+\tPR tree-optimization/39074\n+\t* tree-ssa-structalias.c (storedanything_id, var_storedanything,\n+\tstoredanything_tree): New.\n+\t(do_ds_constraint): Simplify ANYTHING shortcutting.  Update\n+\tthe STOREDANYTHING solution if the lhs solution contains\n+\tANYTHING.\n+\t(build_succ_graph): Add edges from STOREDANYTHING to all\n+\tnon-direct nodes.\n+\t(init_base_vars): Initialize STOREDANYTHING.\n+\t(compute_points_to_sets): Free substitution info after\n+\tbuilding the succ graph.\n+\t(ipa_pta_execute): Likewise.\n+\n+\t* tree-ssa-structalias.c (struct variable_info): Add may_have_pointers\n+\tfield.\n+\t(do_ds_constraint): Do not add to special var or non-pointer\n+\tfield solutions.\n+\t(type_could_have_pointers): Split out from ...\n+\t(could_have_pointers): ... here.  For arrays use the element type.\n+\t(create_variable_info_for): Initialize may_have_pointers.\n+\t(new_var_info): Likewise.\n+\t(handle_lhs_call): Make the HEAP variable unknown-sized.\n+\t(intra_create_variable_infos): Use a type with pointers for\n+\tPARM_NOALIAS, make it unknown-sized.\n+\n 2009-02-18  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/39224"}, {"sha": "036d40215f905d557c37c531d6072bb8b6437c42", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e39dba643323a8bf07e1435657eebd3985452db/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e39dba643323a8bf07e1435657eebd3985452db/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9e39dba643323a8bf07e1435657eebd3985452db", "patch": "@@ -1,3 +1,10 @@\n+2009-02-19  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/39074\n+\t* gcc.dg/torture/pr39074.c: New testcase.\n+\t* gcc.dg/torture/pr39074-2.c: Likewise.\n+\t* gcc.dg/torture/pr39074-3.c: Likewise.\n+\n 2009-02-18  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR c++/39219"}, {"sha": "89f7ebf8cd8f9737f527d9f74724b2a27ffa77ce", "filename": "gcc/testsuite/gcc.dg/torture/pr39074-2.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e39dba643323a8bf07e1435657eebd3985452db/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr39074-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e39dba643323a8bf07e1435657eebd3985452db/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr39074-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr39074-2.c?ref=9e39dba643323a8bf07e1435657eebd3985452db", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target stdint_types } */\n+/* { dg-options \"-fdump-tree-alias\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+#include <stdint.h>\n+\n+int i;\n+uintptr_t __attribute__((noinline,const)) bar(int ***p) { return (uintptr_t)p; }\n+void __attribute__((noinline))\n+foo(void)\n+{\n+  int *y;\n+  int **a = &y, **x;\n+  int ***p;\n+  uintptr_t b;\n+  b = bar(&a);\n+  p = (int ***)b;\n+  x = *p;\n+  *x = &i; /* *ANYTHING = &i has to make sure that y points to i.  */\n+  *y = 0;\n+}\n+extern void abort (void);\n+int main()\n+{\n+  i = 1;\n+  foo ();\n+  if (i != 0)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"y.._., name memory tag: NMT..., is dereferenced, points-to vars: { i }\" \"alias\" } } */\n+/* { dg-final { cleanup-tree-dump \"alias\" } } */"}, {"sha": "7c7604826216a2cfeb6fff4e4bf58b003be9aa93", "filename": "gcc/testsuite/gcc.dg/torture/pr39074-3.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e39dba643323a8bf07e1435657eebd3985452db/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr39074-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e39dba643323a8bf07e1435657eebd3985452db/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr39074-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr39074-3.c?ref=9e39dba643323a8bf07e1435657eebd3985452db", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target stdint_types } */\n+\n+#include <stdint.h>\n+\n+uintptr_t __attribute__((noinline,const)) bar(int ***p) { return (uintptr_t)p; }\n+extern void abort (void);\n+int main()\n+{\n+  int i, j;\n+  int *y = &j;\n+  int **a = &y, **x;\n+  int ***p;\n+  uintptr_t b;\n+  b = bar(&a);\n+  p = (int ***)b;\n+  x = *p;\n+  *x = &i;\n+  i = 1;\n+  *y = 0;\n+  if (i != 0)\n+    abort ();\n+  return 0;\n+}\n+"}, {"sha": "cc37c8e08ec6b84e8d27a696b01a3c59ba269f9a", "filename": "gcc/testsuite/gcc.dg/torture/pr39074.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e39dba643323a8bf07e1435657eebd3985452db/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr39074.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e39dba643323a8bf07e1435657eebd3985452db/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr39074.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr39074.c?ref=9e39dba643323a8bf07e1435657eebd3985452db", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fdump-tree-alias\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+int i;\n+void __attribute__((noinline))\n+foo(long b, long q)\n+{\n+  int *y;\n+  int **a = &y, **x;\n+  int ***p;\n+  if (b)\n+    p = (int ***)q;\n+  else\n+    p = &a;\n+  x = *p;\n+  *x = &i;  /* *ANYTHING = &i has to make sure that y points to i.  */\n+  *y = 0;\n+}\n+extern void abort (void);\n+int main()\n+{\n+  i = 1;\n+  foo (0, 0);\n+  if (i != 0)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"y.._., name memory tag: NMT..., is dereferenced, points-to vars: { i }\" \"alias\" } } */\n+/* { dg-final { cleanup-tree-dump \"alias\" } } */"}, {"sha": "9de341b68ab60a096987be7443c9772e5025863a", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 101, "deletions": 55, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e39dba643323a8bf07e1435657eebd3985452db/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e39dba643323a8bf07e1435657eebd3985452db/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=9e39dba643323a8bf07e1435657eebd3985452db", "patch": "@@ -230,6 +230,9 @@ struct variable_info\n      variable.  This is used for C++ placement new.  */\n   unsigned int no_tbaa_pruning : 1;\n \n+  /* True if this field may contain pointers.  */\n+  unsigned int may_have_pointers : 1;\n+\n   /* Variable id this was collapsed to due to type unsafety.  Zero if\n      this variable was not collapsed.  This should be unused completely\n      after build_succ_graph, or something is broken.  */\n@@ -297,7 +300,8 @@ get_varinfo_fc (unsigned int n)\n \n /* Static IDs for the special variables.  */\n enum { nothing_id = 0, anything_id = 1, readonly_id = 2,\n-       escaped_id = 3, nonlocal_id = 4, callused_id = 5, integer_id = 6 };\n+       escaped_id = 3, nonlocal_id = 4, callused_id = 5,\n+       storedanything_id = 6, integer_id = 7 };\n \n /* Variable that represents the unknown pointer.  */\n static varinfo_t var_anything;\n@@ -323,6 +327,10 @@ static tree nonlocal_tree;\n static varinfo_t var_callused;\n static tree callused_tree;\n \n+/* Variable that represents variables that are stored to anything.  */\n+static varinfo_t var_storedanything;\n+static tree storedanything_tree;\n+\n /* Variable that represents integers.  This is used for when people do things\n    like &0->a.b.  */\n static varinfo_t var_integer;\n@@ -377,6 +385,7 @@ new_var_info (tree t, unsigned int id, const char *name)\n   ret->is_special_var = false;\n   ret->is_unknown_size_var = false;\n   ret->is_full_var = false;\n+  ret->may_have_pointers = true;\n   var = t;\n   if (TREE_CODE (var) == SSA_NAME)\n     var = SSA_NAME_VAR (var);\n@@ -1182,7 +1191,7 @@ build_pred_graph (void)\n static void\n build_succ_graph (void)\n {\n-  int i;\n+  unsigned i, t;\n   constraint_t c;\n \n   for (i = 0; VEC_iterate (constraint_t, constraints, i, c); i++)\n@@ -1223,6 +1232,14 @@ build_succ_graph (void)\n \t  add_graph_edge (graph, lhsvar, rhsvar);\n \t}\n     }\n+\n+  /* Add edges from STOREDANYTHING to all non-direct nodes.  */\n+  t = find (storedanything_id);\n+  for (i = integer_id + 1; i < FIRST_REF_NODE; ++i)\n+    {\n+      if (!TEST_BIT (graph->direct_nodes, i))\n+\tadd_graph_edge (graph, find (i), t);\n+    }\n }\n \n \n@@ -1608,35 +1625,33 @@ do_ds_constraint (constraint_t c, bitmap delta)\n   unsigned int j;\n   bitmap_iterator bi;\n \n- if (bitmap_bit_p (sol, anything_id))\n-   {\n-     EXECUTE_IF_SET_IN_BITMAP (delta, 0, j, bi)\n-       {\n-\t varinfo_t jvi = get_varinfo (j);\n-\t unsigned int t;\n-\t unsigned int loff = c->lhs.offset;\n-\t unsigned HOST_WIDE_INT fieldoffset = jvi->offset + loff;\n-\t varinfo_t v;\n-\n-\t v = get_varinfo (j);\n-\t if (!v->is_full_var)\n-\t   {\n-\t     v = first_vi_for_offset (v, fieldoffset);\n-\t     /* If the access is outside of the variable we can ignore it.  */\n-\t     if (!v)\n-\t       continue;\n-\t   }\n-\t t = find (v->id);\n-\n-\t if (bitmap_set_bit (get_varinfo (t)->solution, anything_id)\n-\t     && !TEST_BIT (changed, t))\n-\t   {\n-\t     SET_BIT (changed, t);\n-\t     changed_count++;\n-\t   }\n-       }\n-     return;\n-   }\n+  /* Our IL does not allow this.  */\n+  gcc_assert (c->rhs.offset == 0);\n+\n+  /* If the solution of y contains ANYTHING simply use the ANYTHING\n+     solution.  This avoids needlessly increasing the points-to sets.  */\n+  if (bitmap_bit_p (sol, anything_id))\n+    sol = get_varinfo (find (anything_id))->solution;\n+\n+  /* If the solution for x contains ANYTHING we have to merge the\n+     solution of y into all pointer variables which we do via\n+     STOREDANYTHING.  */\n+  if (bitmap_bit_p (delta, anything_id))\n+    {\n+      unsigned t = find (storedanything_id);\n+      if (add_graph_edge (graph, t, rhs))\n+\t{\n+\t  if (bitmap_ior_into (get_varinfo (t)->solution, sol))\n+\t    {\n+\t      if (!TEST_BIT (changed, t))\n+\t\t{\n+\t\t  SET_BIT (changed, t);\n+\t\t  changed_count++;\n+\t\t}\n+\t    }\n+\t}\n+      return;\n+    }\n \n   /* For each member j of delta (Sol(x)), add an edge from y to j and\n      union Sol(y) into Sol(j) */\n@@ -1648,26 +1663,27 @@ do_ds_constraint (constraint_t c, bitmap delta)\n \t  varinfo_t v;\n \t  unsigned int t;\n \t  unsigned HOST_WIDE_INT fieldoffset = get_varinfo (j)->offset + loff;\n-\t  bitmap tmp;\n \n \t  v = first_vi_for_offset (get_varinfo (j), fieldoffset);\n \t  /* If the access is outside of the variable we can ignore it.  */\n \t  if (!v)\n \t    continue;\n-\t  t = find (v->id);\n-\t  tmp = get_varinfo (t)->solution;\n \n-            if (add_graph_edge (graph, t, rhs))\n+\t  if (v->may_have_pointers)\n \t    {\n-                if (bitmap_ior_into (get_varinfo (t)->solution, sol))\n+\t      t = find (v->id);\n+\t      if (add_graph_edge (graph, t, rhs))\n \t\t{\n-                    if (t == rhs)\n-                      sol = get_varinfo (rhs)->solution;\n-                    if (!TEST_BIT (changed, t))\n-                      {\n-                        SET_BIT (changed, t);\n-                        changed_count++;\n-                      }\n+\t\t  if (bitmap_ior_into (get_varinfo (t)->solution, sol))\n+\t\t    {\n+\t\t      if (t == rhs)\n+\t\t\tsol = get_varinfo (rhs)->solution;\n+\t\t      if (!TEST_BIT (changed, t))\n+\t\t\t{\n+\t\t\t  SET_BIT (changed, t);\n+\t\t\t  changed_count++;\n+\t\t\t}\n+\t\t    }\n \t\t}\n \t    }\n \t}\n@@ -2740,19 +2756,27 @@ process_constraint (constraint_t t)\n     }\n }\n \n+/* Return true if T is a type that could contain pointers.  */\n+\n+static bool\n+type_could_have_pointers (tree type)\n+{\n+  if (POINTER_TYPE_P (type))\n+    return true;\n+\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    return type_could_have_pointers (TREE_TYPE (type));\n+\n+  return AGGREGATE_TYPE_P (type);\n+}\n+\n /* Return true if T is a variable of a type that could contain\n    pointers.  */\n \n static bool\n could_have_pointers (tree t)\n {\n-  tree type = TREE_TYPE (t);\n-\n-  if (POINTER_TYPE_P (type)\n-      || AGGREGATE_TYPE_P (type))\n-    return true;\n-\n-  return false;\n+  return type_could_have_pointers (TREE_TYPE (t));\n }\n \n /* Return the position, in bits, of FIELD_DECL from the beginning of its\n@@ -3516,6 +3540,9 @@ handle_lhs_call (tree lhs, int flags)\n       vi = get_varinfo (rhsc.var);\n       vi->is_artificial_var = 1;\n       vi->is_heap_var = 1;\n+      vi->is_unknown_size_var = true;\n+      vi->fullsize = ~0;\n+      vi->size = ~0;\n       rhsc.type = ADDRESSOF;\n       rhsc.offset = 0;\n     }\n@@ -4356,6 +4383,7 @@ create_variable_info_for (tree decl, const char *name)\n   vi = new_var_info (decl, index, name);\n   vi->decl = decl;\n   vi->offset = 0;\n+  vi->may_have_pointers = could_have_pointers (decl);\n   if (!declsize\n       || !host_integerp (declsize, 1))\n     {\n@@ -4372,7 +4400,7 @@ create_variable_info_for (tree decl, const char *name)\n   insert_vi_for_tree (vi->decl, vi);\n   VEC_safe_push (varinfo_t, heap, varmap, vi);\n   if (is_global && (!flag_whole_program || !in_ipa_mode)\n-      && could_have_pointers (decl))\n+      && vi->may_have_pointers)\n     {\n       if (var_ann (decl)\n \t  && var_ann (decl)->noalias_state == NO_ALIAS_ANYTHING)\n@@ -4433,6 +4461,7 @@ create_variable_info_for (tree decl, const char *name)\n \n       vi->size = fo->size;\n       vi->offset = fo->offset;\n+      vi->may_have_pointers = fo->may_have_pointers;\n       for (i = VEC_length (fieldoff_s, fieldstack) - 1;\n \t   i >= 1 && VEC_iterate (fieldoff_s, fieldstack, i, fo);\n \t   i--)\n@@ -4454,10 +4483,11 @@ create_variable_info_for (tree decl, const char *name)\n \t  newvi->offset = fo->offset;\n \t  newvi->size = fo->size;\n \t  newvi->fullsize = vi->fullsize;\n+\t  newvi->may_have_pointers = fo->may_have_pointers;\n \t  insert_into_field_list (vi, newvi);\n \t  VEC_safe_push (varinfo_t, heap, varmap, newvi);\n \t  if (is_global && (!flag_whole_program || !in_ipa_mode)\n-\t      && fo->may_have_pointers)\n+\t      && newvi->may_have_pointers)\n \t    make_constraint_from (newvi, escaped_id);\n \n \t  stats.total_vars++;\n@@ -4541,7 +4571,7 @@ intra_create_variable_infos (void)\n \t  if (heapvar == NULL_TREE)\n \t    {\n \t      var_ann_t ann;\n-\t      heapvar = create_tmp_var_raw (TREE_TYPE (TREE_TYPE (t)),\n+\t      heapvar = create_tmp_var_raw (ptr_type_node,\n \t\t\t\t\t    \"PARM_NOALIAS\");\n \t      DECL_EXTERNAL (heapvar) = 1;\n \t      if (gimple_referenced_vars (cfun))\n@@ -4564,6 +4594,9 @@ intra_create_variable_infos (void)\n \t  vi = get_vi_for_tree (heapvar);\n \t  vi->is_artificial_var = 1;\n \t  vi->is_heap_var = 1;\n+\t  vi->is_unknown_size_var = true;\n+\t  vi->fullsize = ~0;\n+\t  vi->size = ~0;\n \t  rhs.var = vi->id;\n \t  rhs.type = ADDRESSOF;\n \t  rhs.offset = 0;\n@@ -5239,6 +5272,19 @@ init_base_vars (void)\n   rhs.offset = 0;\n   process_constraint (new_constraint (lhs, rhs));\n \n+  /* Create the STOREDANYTHING variable, used to represent the set of\n+     variables stored to *ANYTHING.  */\n+  storedanything_tree = create_tmp_var_raw (ptr_type_node, \"STOREDANYTHING\");\n+  var_storedanything = new_var_info (storedanything_tree, storedanything_id,\n+\t\t\t\t     \"STOREDANYTHING\");\n+  insert_vi_for_tree (storedanything_tree, var_storedanything);\n+  var_storedanything->is_artificial_var = 1;\n+  var_storedanything->offset = 0;\n+  var_storedanything->size = ~0;\n+  var_storedanything->fullsize = ~0;\n+  var_storedanything->is_special_var = 0;\n+  VEC_safe_push (varinfo_t, heap, varmap, var_storedanything);\n+\n   /* Create the INTEGER variable, used to represent that a variable points\n      to an INTEGER.  */\n   integer_tree = create_tmp_var_raw (void_type_node, \"INTEGER\");\n@@ -5537,9 +5583,9 @@ compute_points_to_sets (void)\n     fprintf (dump_file, \"Rewriting constraints and unifying \"\n \t     \"variables\\n\");\n   rewrite_constraints (graph, si);\n-  free_var_substitution_info (si);\n \n   build_succ_graph ();\n+  free_var_substitution_info (si);\n \n   if (dump_file && (dump_flags & TDF_GRAPH))\n     dump_constraint_graph (dump_file);\n@@ -5698,9 +5744,9 @@ ipa_pta_execute (void)\n   build_pred_graph ();\n   si = perform_var_substitution (graph);\n   rewrite_constraints (graph, si);\n-  free_var_substitution_info (si);\n \n   build_succ_graph ();\n+  free_var_substitution_info (si);\n   move_complex_constraints (graph);\n   unite_pointer_equivalences (graph);\n   find_indirect_cycles (graph);"}]}