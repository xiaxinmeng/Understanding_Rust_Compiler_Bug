{"sha": "4ad2e1ec08ab363f5137a84169040792844b56c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFkMmUxZWMwOGFiMzYzZjUxMzdhODQxNjkwNDA3OTI4NDRiNTZjNQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-05-26T16:55:35Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-05-26T16:55:35Z"}, "message": "dwarf2out.c (struct dw_fde_struct): Reorder flags.\n\n\t* dwarf2out.c (struct dw_fde_struct): Reorder flags.\n\t(fde_needed_for_eh_p): New predicate.\n\t(output_call_frame_info): Use it throughout to decide whether FDEs\n\tare needed for EH purpose.\n\t(dwarf2out_begin_prologue): Reorder assignments.\n\nFrom-SVN: r159889", "tree": {"sha": "bcf99300aba02d8b24960f57612260ba8302b499", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcf99300aba02d8b24960f57612260ba8302b499"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ad2e1ec08ab363f5137a84169040792844b56c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ad2e1ec08ab363f5137a84169040792844b56c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ad2e1ec08ab363f5137a84169040792844b56c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ad2e1ec08ab363f5137a84169040792844b56c5/comments", "author": null, "committer": null, "parents": [{"sha": "4204425f00aab5563c6af03729c1ef379b706e0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4204425f00aab5563c6af03729c1ef379b706e0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4204425f00aab5563c6af03729c1ef379b706e0d"}], "stats": {"total": 79, "additions": 45, "deletions": 34}, "files": [{"sha": "94f2d44f276c71b766a6e036d6f45810ce5978f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ad2e1ec08ab363f5137a84169040792844b56c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ad2e1ec08ab363f5137a84169040792844b56c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ad2e1ec08ab363f5137a84169040792844b56c5", "patch": "@@ -1,3 +1,11 @@\n+2010-05-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* dwarf2out.c (struct dw_fde_struct): Reorder flags.\n+\t(fde_needed_for_eh_p): New predicate.\n+\t(output_call_frame_info): Use it throughout to decide whether FDEs\n+\tare needed for EH purpose.\n+\t(dwarf2out_begin_prologue): Reorder assignments.\n+\n 2010-05-26  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* tree-if-conv.c (if_convertible_gimple_assign_stmt_p): Do not"}, {"sha": "a50e02ae5081469c12e52ceac4bcb216611b54d9", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 37, "deletions": 34, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ad2e1ec08ab363f5137a84169040792844b56c5/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ad2e1ec08ab363f5137a84169040792844b56c5/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=4ad2e1ec08ab363f5137a84169040792844b56c5", "patch": "@@ -311,9 +311,10 @@ typedef struct GTY(()) dw_fde_struct {\n   unsigned int drap_reg;\n   /* Virtual dynamic realign argument pointer register.  */\n   unsigned int vdrap_reg;\n+  /* These 3 flags are copied from rtl_data in function.h.  */\n   unsigned all_throwers_are_sibcalls : 1;\n-  unsigned nothrow : 1;\n   unsigned uses_eh_lsda : 1;\n+  unsigned nothrow : 1;\n   /* Whether we did stack realign in this call frame.  */\n   unsigned stack_realign : 1;\n   /* Whether dynamic realign argument pointer register has been saved.  */\n@@ -3602,6 +3603,27 @@ output_fde (dw_fde_ref fde, bool for_eh, bool second,\n   j += 2;\n }\n \n+/* Return true if frame description entry FDE is needed for EH.  */\n+\n+static bool\n+fde_needed_for_eh_p (dw_fde_ref fde)\n+{\n+  if (flag_asynchronous_unwind_tables)\n+    return true;\n+\n+  if (TARGET_USES_WEAK_UNWIND_INFO && DECL_WEAK (fde->decl))\n+    return true;\n+\n+  if (fde->uses_eh_lsda)\n+    return true;\n+\n+  /* If exceptions are enabled, we have collected nothrow info.  */\n+  if (flag_exceptions && (fde->all_throwers_are_sibcalls || fde->nothrow))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Output the call frame information used to record information\n    that relates to calculating the frame pointer, and records the\n    location of saved registers.  */\n@@ -3631,41 +3653,25 @@ output_call_frame_info (int for_eh)\n   if (dwarf2out_do_cfi_asm ())\n     return;\n \n-  /* If we make FDEs linkonce, we may have to emit an empty label for\n-     an FDE that wouldn't otherwise be emitted.  We want to avoid\n-     having an FDE kept around when the function it refers to is\n-     discarded.  Example where this matters: a primary function\n-     template in C++ requires EH information, but an explicit\n-     specialization doesn't.  */\n-  if (TARGET_USES_WEAK_UNWIND_INFO\n-      && ! flag_asynchronous_unwind_tables\n-      && flag_exceptions\n-      && for_eh)\n-    for (i = 0; i < fde_table_in_use; i++)\n-      if ((fde_table[i].nothrow || fde_table[i].all_throwers_are_sibcalls)\n-\t  && !fde_table[i].uses_eh_lsda\n-\t  && ! DECL_WEAK (fde_table[i].decl))\n-\ttargetm.asm_out.unwind_label (asm_out_file, fde_table[i].decl,\n-\t\t\t\t      for_eh, /* empty */ 1);\n-\n-  /* If we don't have any functions we'll want to unwind out of, don't\n-     emit any EH unwind information.  Note that if exceptions aren't\n-     enabled, we won't have collected nothrow information, and if we\n-     asked for asynchronous tables, we always want this info.  */\n+  /* If we don't have any functions we'll want to unwind out of, don't emit\n+     any EH unwind information.  If we make FDEs linkonce, we may have to\n+     emit an empty label for an FDE that wouldn't otherwise be emitted.  We\n+     want to avoid having an FDE kept around when the function it refers to\n+     is discarded.  Example where this matters: a primary function template\n+     in C++ requires EH information, an explicit specialization doesn't.  */\n   if (for_eh)\n     {\n-      bool any_eh_needed = !flag_exceptions || flag_asynchronous_unwind_tables;\n+      bool any_eh_needed = false;\n \n       for (i = 0; i < fde_table_in_use; i++)\n \tif (fde_table[i].uses_eh_lsda)\n \t  any_eh_needed = any_lsda_needed = true;\n-\telse if (TARGET_USES_WEAK_UNWIND_INFO && DECL_WEAK (fde_table[i].decl))\n-\t  any_eh_needed = true;\n-\telse if (! fde_table[i].nothrow\n-\t\t && ! fde_table[i].all_throwers_are_sibcalls)\n+\telse if (fde_needed_for_eh_p (&fde_table[i]))\n \t  any_eh_needed = true;\n+\telse if (TARGET_USES_WEAK_UNWIND_INFO)\n+\t  targetm.asm_out.unwind_label (asm_out_file, fde_table[i].decl, 1, 1);\n \n-      if (! any_eh_needed)\n+      if (!any_eh_needed)\n \treturn;\n     }\n \n@@ -3822,10 +3828,7 @@ output_call_frame_info (int for_eh)\n       fde = &fde_table[i];\n \n       /* Don't emit EH unwind info for leaf functions that don't need it.  */\n-      if (for_eh && !flag_asynchronous_unwind_tables && flag_exceptions\n-\t  && (fde->nothrow || fde->all_throwers_are_sibcalls)\n-\t  && ! (TARGET_USES_WEAK_UNWIND_INFO && DECL_WEAK (fde_table[i].decl))\n-\t  && !fde->uses_eh_lsda)\n+      if (for_eh && !fde_needed_for_eh_p (fde))\n \tcontinue;\n \n       for (k = 0; k < (fde->dw_fde_switched_sections ? 2 : 1); k++)\n@@ -3961,9 +3964,9 @@ dwarf2out_begin_prologue (unsigned int line ATTRIBUTE_UNUSED,\n   fde->dw_fde_cfi = NULL;\n   fde->dw_fde_switch_cfi = NULL;\n   fde->funcdef_number = current_function_funcdef_no;\n-  fde->nothrow = crtl->nothrow;\n-  fde->uses_eh_lsda = crtl->uses_eh_lsda;\n   fde->all_throwers_are_sibcalls = crtl->all_throwers_are_sibcalls;\n+  fde->uses_eh_lsda = crtl->uses_eh_lsda;\n+  fde->nothrow = crtl->nothrow;\n   fde->drap_reg = INVALID_REGNUM;\n   fde->vdrap_reg = INVALID_REGNUM;\n   if (flag_reorder_blocks_and_partition)"}]}