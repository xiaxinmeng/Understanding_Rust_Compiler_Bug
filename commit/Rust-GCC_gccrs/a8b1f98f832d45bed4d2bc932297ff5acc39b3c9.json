{"sha": "a8b1f98f832d45bed4d2bc932297ff5acc39b3c9", "node_id": "C_kwDOANBUbNoAKGE4YjFmOThmODMyZDQ1YmVkNGQyYmM5MzIyOTdmZjVhY2MzOWIzYzk", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-10-06T08:19:11Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-10-06T08:56:42Z"}, "message": "builtins: Move implementation into source file", "tree": {"sha": "bedb21bec114d90f3cbb532517426475692fce2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bedb21bec114d90f3cbb532517426475692fce2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8b1f98f832d45bed4d2bc932297ff5acc39b3c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8b1f98f832d45bed4d2bc932297ff5acc39b3c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8b1f98f832d45bed4d2bc932297ff5acc39b3c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8b1f98f832d45bed4d2bc932297ff5acc39b3c9/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8ff035ddc55079161d24941785114aa0f5056260", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ff035ddc55079161d24941785114aa0f5056260", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ff035ddc55079161d24941785114aa0f5056260"}], "stats": {"total": 264, "additions": 156, "deletions": 108}, "files": [{"sha": "e8735202ae7e5e244ffb2a47f896ab6239d791eb", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b1f98f832d45bed4d2bc932297ff5acc39b3c9/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b1f98f832d45bed4d2bc932297ff5acc39b3c9/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=a8b1f98f832d45bed4d2bc932297ff5acc39b3c9", "patch": "@@ -151,6 +151,7 @@ GRS_OBJS = \\\n     rust/rust-imports.o \\\n     rust/rust-import-archive.o \\\n     rust/rust-extern-crate.o \\\n+    rust/rust-builtins.o \\\n     $(END)\n # removed object files from here\n "}, {"sha": "14dc037edac95173218ca9db19ee0dda9e4d2cc1", "filename": "gcc/rust/backend/rust-builtins.cc", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b1f98f832d45bed4d2bc932297ff5acc39b3c9/gcc%2Frust%2Fbackend%2Frust-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b1f98f832d45bed4d2bc932297ff5acc39b3c9/gcc%2Frust%2Fbackend%2Frust-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-builtins.cc?ref=a8b1f98f832d45bed4d2bc932297ff5acc39b3c9", "patch": "@@ -0,0 +1,143 @@\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-builtins.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+static const int builtin_const = 1 << 0;\n+static const int builtin_noreturn = 1 << 1;\n+static const int builtin_novops = 1 << 2;\n+\n+BuiltinsContext &\n+BuiltinsContext::get ()\n+{\n+  static BuiltinsContext instance;\n+  return instance;\n+}\n+\n+bool\n+BuiltinsContext::lookup_simple_builtin (const std::string &name, tree *builtin)\n+{\n+  auto it = rust_intrinsic_to_gcc_builtin.find (name);\n+  if (it == rust_intrinsic_to_gcc_builtin.end ())\n+    return false;\n+\n+  return lookup_gcc_builtin (it->second, builtin);\n+}\n+\n+BuiltinsContext::BuiltinsContext () { setup (); }\n+\n+void\n+BuiltinsContext::setup_overflow_fns ()\n+{\n+  tree overflow_type\n+    = build_varargs_function_type_list (boolean_type_node, NULL_TREE);\n+\n+  define_builtin (\"add_overflow\", BUILT_IN_ADD_OVERFLOW,\n+\t\t  \"__builtin_add_overflow\", \"add_overflow\", overflow_type, 0);\n+  define_builtin (\"sub_overflow\", BUILT_IN_SUB_OVERFLOW,\n+\t\t  \"__builtin_sub_overflow\", \"sub_overflow\", overflow_type, 0);\n+  define_builtin (\"mul_overflow\", BUILT_IN_MUL_OVERFLOW,\n+\t\t  \"__builtin_mul_overflow\", \"mul_overflow\", overflow_type, 0);\n+}\n+\n+void\n+BuiltinsContext::setup_math_fns ()\n+{\n+  tree math_function_type_f32\n+    = build_function_type_list (float_type_node, float_type_node, NULL_TREE);\n+\n+  define_builtin (\"sinf32\", BUILT_IN_SINF, \"__builtin_sinf\", \"sinf\",\n+\t\t  math_function_type_f32, builtin_const);\n+  define_builtin (\"sqrtf32\", BUILT_IN_SQRTF, \"__builtin_sqrtf\", \"sqrtf\",\n+\t\t  math_function_type_f32, builtin_const);\n+}\n+\n+void\n+BuiltinsContext::setup ()\n+{\n+  setup_math_fns ();\n+  setup_overflow_fns ();\n+\n+  define_builtin (\"unreachable\", BUILT_IN_UNREACHABLE, \"__builtin_unreachable\",\n+\t\t  NULL, build_function_type (void_type_node, void_list_node),\n+\t\t  builtin_const | builtin_noreturn);\n+\n+  define_builtin (\"abort\", BUILT_IN_ABORT, \"__builtin_abort\", \"abort\",\n+\t\t  build_function_type (void_type_node, void_list_node),\n+\t\t  builtin_const | builtin_noreturn);\n+\n+  define_builtin (\"breakpoint\", BUILT_IN_TRAP, \"__builtin_trap\", \"breakpoint\",\n+\t\t  build_function_type (void_type_node, void_list_node),\n+\t\t  builtin_const | builtin_noreturn);\n+\n+  define_builtin (\"memcpy\", BUILT_IN_MEMCPY, \"__builtin_memcpy\", \"memcpy\",\n+\t\t  build_function_type_list (build_pointer_type (void_type_node),\n+\t\t\t\t\t    build_pointer_type (void_type_node),\n+\t\t\t\t\t    build_pointer_type (void_type_node),\n+\t\t\t\t\t    size_type_node, NULL_TREE),\n+\t\t  0);\n+}\n+\n+static void\n+handle_flags (tree decl, int flags)\n+{\n+  if (flags & builtin_const)\n+    TREE_READONLY (decl) = 1;\n+  if (flags & builtin_noreturn)\n+    TREE_READONLY (decl) = 1;\n+  if (flags & builtin_novops)\n+    DECL_IS_NOVOPS (decl) = 1;\n+}\n+\n+void\n+BuiltinsContext::define_builtin (const std::string rust_name,\n+\t\t\t\t built_in_function bcode, const char *name,\n+\t\t\t\t const char *libname, tree fntype, int flags)\n+{\n+  tree decl = add_builtin_function (name, fntype, bcode, BUILT_IN_NORMAL,\n+\t\t\t\t    libname, NULL_TREE);\n+  handle_flags (decl, flags);\n+  set_builtin_decl (bcode, decl, true);\n+\n+  this->builtin_functions_[name] = decl;\n+  if (libname != NULL)\n+    {\n+      decl = add_builtin_function (libname, fntype, bcode, BUILT_IN_NORMAL,\n+\t\t\t\t   NULL, NULL_TREE);\n+      handle_flags (decl, flags);\n+\n+      this->builtin_functions_[libname] = decl;\n+    }\n+\n+  rust_intrinsic_to_gcc_builtin[rust_name] = name;\n+}\n+\n+bool\n+BuiltinsContext::lookup_gcc_builtin (const std::string &name, tree *builtin)\n+{\n+  auto it = builtin_functions_.find (name);\n+  if (it == builtin_functions_.end ())\n+    return false;\n+\n+  *builtin = it->second;\n+  return true;\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "e421fa437552209f5371935941f7ee2914080376", "filename": "gcc/rust/backend/rust-builtins.h", "status": "modified", "additions": 12, "deletions": 108, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b1f98f832d45bed4d2bc932297ff5acc39b3c9/gcc%2Frust%2Fbackend%2Frust-builtins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b1f98f832d45bed4d2bc932297ff5acc39b3c9/gcc%2Frust%2Fbackend%2Frust-builtins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-builtins.h?ref=a8b1f98f832d45bed4d2bc932297ff5acc39b3c9", "patch": "@@ -78,88 +78,18 @@ namespace Compile {\n class BuiltinsContext\n {\n public:\n-  static BuiltinsContext &get ()\n-  {\n-    static BuiltinsContext instance;\n-    return instance;\n-  }\n+  static BuiltinsContext &get ();\n \n-  bool lookup_simple_builtin (const std::string &name, tree *builtin)\n-  {\n-    auto it = rust_intrinsic_to_gcc_builtin.find (name);\n-    if (it == rust_intrinsic_to_gcc_builtin.end ())\n-      return false;\n-\n-    return lookup_gcc_builtin (it->second, builtin);\n-  }\n+  bool lookup_simple_builtin (const std::string &name, tree *builtin);\n \n private:\n-  static const int builtin_const = 1 << 0;\n-  static const int builtin_noreturn = 1 << 1;\n-  static const int builtin_novops = 1 << 2;\n-\n-  BuiltinsContext () { setup (); }\n-\n-  void setup_overflow_fns ()\n-  {\n-    tree overflow_type\n-      = build_varargs_function_type_list (boolean_type_node, NULL_TREE);\n-\n-    define_builtin (\"add_overflow\", BUILT_IN_ADD_OVERFLOW,\n-\t\t    \"__builtin_add_overflow\", \"add_overflow\", overflow_type, 0);\n-    define_builtin (\"sub_overflow\", BUILT_IN_SUB_OVERFLOW,\n-\t\t    \"__builtin_sub_overflow\", \"sub_overflow\", overflow_type, 0);\n-    define_builtin (\"mul_overflow\", BUILT_IN_MUL_OVERFLOW,\n-\t\t    \"__builtin_mul_overflow\", \"mul_overflow\", overflow_type, 0);\n-  }\n-\n-  void setup_math_fns ()\n-  {\n-    tree math_function_type_f32\n-      = build_function_type_list (float_type_node, float_type_node, NULL_TREE);\n-\n-    define_builtin (\"sinf32\", BUILT_IN_SINF, \"__builtin_sinf\", \"sinf\",\n-\t\t    math_function_type_f32, builtin_const);\n-    define_builtin (\"sqrtf32\", BUILT_IN_SQRTF, \"__builtin_sqrtf\", \"sqrtf\",\n-\t\t    math_function_type_f32, builtin_const);\n-  }\n-\n-  void setup ()\n-  {\n-    setup_math_fns ();\n-    setup_overflow_fns ();\n-\n-    define_builtin (\"unreachable\", BUILT_IN_UNREACHABLE,\n-\t\t    \"__builtin_unreachable\", NULL,\n-\t\t    build_function_type (void_type_node, void_list_node),\n-\t\t    builtin_const | builtin_noreturn);\n-\n-    define_builtin (\"abort\", BUILT_IN_ABORT, \"__builtin_abort\", \"abort\",\n-\t\t    build_function_type (void_type_node, void_list_node),\n-\t\t    builtin_const | builtin_noreturn);\n-\n-    define_builtin (\"breakpoint\", BUILT_IN_TRAP, \"__builtin_trap\", \"breakpoint\",\n-\t\t    build_function_type (void_type_node, void_list_node),\n-\t\t    builtin_const | builtin_noreturn);\n-\n-    define_builtin (\n-      \"memcpy\", BUILT_IN_MEMCPY, \"__builtin_memcpy\", \"memcpy\",\n-      build_function_type_list (build_pointer_type (void_type_node),\n-\t\t\t\tbuild_pointer_type (void_type_node),\n-\t\t\t\tbuild_pointer_type (void_type_node),\n-\t\t\t\tsize_type_node, NULL_TREE),\n-      0);\n-  }\n-\n-  static void handle_flags (tree decl, int flags)\n-  {\n-    if (flags & builtin_const)\n-      TREE_READONLY (decl) = 1;\n-    if (flags & builtin_noreturn)\n-      TREE_READONLY (decl) = 1;\n-    if (flags & builtin_novops)\n-      DECL_IS_NOVOPS (decl) = 1;\n-  }\n+  BuiltinsContext ();\n+\n+  void setup_overflow_fns ();\n+\n+  void setup_math_fns ();\n+\n+  void setup ();\n \n   // Define a builtin function.  BCODE is the builtin function code\n   // defined by builtins.def.  NAME is the name of the builtin function.\n@@ -169,35 +99,9 @@ class BuiltinsContext\n   // NORETURN_P is true if the function has the noreturn attribute.\n   void define_builtin (const std::string rust_name, built_in_function bcode,\n \t\t       const char *name, const char *libname, tree fntype,\n-\t\t       int flags)\n-  {\n-    tree decl = add_builtin_function (name, fntype, bcode, BUILT_IN_NORMAL,\n-\t\t\t\t      libname, NULL_TREE);\n-    handle_flags (decl, flags);\n-    set_builtin_decl (bcode, decl, true);\n-\n-    this->builtin_functions_[name] = decl;\n-    if (libname != NULL)\n-      {\n-\tdecl = add_builtin_function (libname, fntype, bcode, BUILT_IN_NORMAL,\n-\t\t\t\t     NULL, NULL_TREE);\n-\thandle_flags (decl, flags);\n-\n-\tthis->builtin_functions_[libname] = decl;\n-      }\n-\n-    rust_intrinsic_to_gcc_builtin[rust_name] = name;\n-  }\n-\n-  bool lookup_gcc_builtin (const std::string &name, tree *builtin)\n-  {\n-    auto it = builtin_functions_.find (name);\n-    if (it == builtin_functions_.end ())\n-      return false;\n-\n-    *builtin = it->second;\n-    return true;\n-  }\n+\t\t       int flags);\n+\n+  bool lookup_gcc_builtin (const std::string &name, tree *builtin);\n \n   // A mapping of the GCC built-ins exposed to GCC Rust.\n   std::map<std::string, tree> builtin_functions_;"}]}