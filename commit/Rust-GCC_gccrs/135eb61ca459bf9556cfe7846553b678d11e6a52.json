{"sha": "135eb61ca459bf9556cfe7846553b678d11e6a52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTM1ZWI2MWNhNDU5YmY5NTU2Y2ZlNzg0NjU1M2I2NzhkMTFlNmE1Mg==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-11-11T19:36:29Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-11-11T19:36:29Z"}, "message": "Handle equivalences that have been obscured by gcse:\n\n\t* reload1.c (reload): Handle equivalences set up in multiple places.\n\t* local-alloc.c (reg_equiv_init_insns): New variable.\n\t(no_equiv): New function.\n\t(update_equiv_regs): Handle equivalences set up in multiple places.\n\tDon't ignore an insn just because its destination is likely to be\n\tspilled.\n\nFrom-SVN: r23610", "tree": {"sha": "c8cab010883f75fa1d7c0a582cd529b2af211861", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8cab010883f75fa1d7c0a582cd529b2af211861"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/135eb61ca459bf9556cfe7846553b678d11e6a52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/135eb61ca459bf9556cfe7846553b678d11e6a52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/135eb61ca459bf9556cfe7846553b678d11e6a52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/135eb61ca459bf9556cfe7846553b678d11e6a52/comments", "author": null, "committer": null, "parents": [{"sha": "b62d42fef48e4c1ac746efbc7b396047a2a36502", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b62d42fef48e4c1ac746efbc7b396047a2a36502", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b62d42fef48e4c1ac746efbc7b396047a2a36502"}], "stats": {"total": 211, "additions": 167, "deletions": 44}, "files": [{"sha": "f954f5e179b4b26e75bea4acb86ab95cb17d5bf0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/135eb61ca459bf9556cfe7846553b678d11e6a52/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/135eb61ca459bf9556cfe7846553b678d11e6a52/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=135eb61ca459bf9556cfe7846553b678d11e6a52", "patch": "@@ -1,3 +1,14 @@\n+Thu Nov 12 03:32:16 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\tHandle equivalences that have been obscured by gcse:\n+\n+\t* reload1.c (reload): Handle equivalences set up in multiple places.\n+\t* local-alloc.c (reg_equiv_init_insns): New variable.\n+\t(no_equiv): New function.\n+\t(update_equiv_regs): Handle equivalences set up in multiple places.\n+\tDon't ignore an insn just because its destination is likely to be\n+\tspilled.\n+\n Wed Nov 11 13:46:13 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* except.c (expand_eh_return): Readd force_operand call lost in"}, {"sha": "ddcd475041407a79c27ae2fa65733feb378fcacf", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 129, "deletions": 28, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/135eb61ca459bf9556cfe7846553b678d11e6a52/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/135eb61ca459bf9556cfe7846553b678d11e6a52/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=135eb61ca459bf9556cfe7846553b678d11e6a52", "patch": "@@ -234,13 +234,17 @@ static rtx this_insn;\n \n static rtx *reg_equiv_replacement;\n \n+/* Used for communication between update_equiv_regs and no_equiv.  */\n+static rtx *reg_equiv_init_insns;\n+\n static void alloc_qty\t\tPROTO((int, enum machine_mode, int, int));\n static void validate_equiv_mem_from_store PROTO((rtx, rtx));\n static int validate_equiv_mem\tPROTO((rtx, rtx, rtx));\n static int contains_replace_regs PROTO((rtx, char *));\n static int memref_referenced_p\tPROTO((rtx, rtx));\n static int memref_used_between_p PROTO((rtx, rtx, rtx));\n static void update_equiv_regs\tPROTO((void));\n+static void no_equiv\t\tPROTO((rtx, rtx));\n static void block_alloc\t\tPROTO((int));\n static int qty_sugg_compare    \tPROTO((int, int));\n static int qty_sugg_compare_1\tPROTO((const GENERIC_PTR, const GENERIC_PTR));\n@@ -633,17 +637,17 @@ memref_used_between_p (memref, start, end)\n static void\n update_equiv_regs ()\n {\n-  rtx *reg_equiv_init_insn = (rtx *) alloca (max_regno * sizeof (rtx));\n   /* Set when an attempt should be made to replace a register with the\n      associated reg_equiv_replacement entry at the end of this function.  */\n   char *reg_equiv_replace\n     = (char *) alloca (max_regno * sizeof *reg_equiv_replace);\n   rtx insn;\n   int block, depth;\n \n+  reg_equiv_init_insns = (rtx *) alloca (max_regno * sizeof (rtx));\n   reg_equiv_replacement = (rtx *) alloca (max_regno * sizeof (rtx));\n \n-  bzero ((char *) reg_equiv_init_insn, max_regno * sizeof (rtx));\n+  bzero ((char *) reg_equiv_init_insns, max_regno * sizeof (rtx));\n   bzero ((char *) reg_equiv_replacement, max_regno * sizeof (rtx));\n   bzero ((char *) reg_equiv_replace, max_regno * sizeof *reg_equiv_replace);\n \n@@ -657,7 +661,7 @@ update_equiv_regs ()\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       rtx note;\n-      rtx set = single_set (insn);\n+      rtx set;\n       rtx dest, src;\n       int regno;\n \n@@ -669,10 +673,34 @@ update_equiv_regs ()\n \t    loop_depth--;\n \t}\n \n-      /* If this insn contains more (or less) than a single SET, ignore it.  */\n-      if (set == 0)\n+      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n \tcontinue;\n \n+      for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+\tif (REG_NOTE_KIND (note) == REG_INC)\n+\t  no_equiv (XEXP (note, 0), note);\n+\n+      set = single_set (insn);\n+\n+      /* If this insn contains more (or less) than a single SET,\n+\t only mark all destinations as having no known equivalence.  */\n+      if (set == 0)\n+\t{\n+\t  note_stores (PATTERN (insn), no_equiv);\n+\t  continue;\n+\t}\n+      else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n+\t{\n+\t  int i;\n+\n+\t  for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n+\t    {\n+\t      rtx part = XVECEXP (PATTERN (insn), 0, i);\n+\t      if (part != set)\n+\t\tnote_stores (part, no_equiv);\n+\t    }\n+\t}\n+\n       dest = SET_DEST (set);\n       src = SET_SRC (set);\n \n@@ -688,35 +716,63 @@ update_equiv_regs ()\n \t If one of the regs in the address is marked as reg_equiv_replace,\n \t then we can't add this REG_EQUIV note.  The reg_equiv_replace\n \t optimization may move the set of this register immediately before\n-\t insn, which puts it after reg_equiv_init_insn[regno], and hence\n+\t insn, which puts it after reg_equiv_init_insns[regno], and hence\n \t the mention in the REG_EQUIV note would be to an uninitialized\n \t pseudo.  */\n-\n-      if (GET_CODE (dest) == MEM && GET_CODE (SET_SRC (set)) == REG\n-\t  && (regno = REGNO (SET_SRC (set))) >= FIRST_PSEUDO_REGISTER\n+      /* ????? This test isn't good enough; we might see a MEM with a use of\n+\t a pseudo register before we see its setting insn that will cause\n+\t reg_equiv_replace for that pseudo to be set.\n+\t Equivalences to MEMs should be made in another pass, after the\n+\t reg_equiv_replace information has been gathered.  */\n+\n+      if (GET_CODE (dest) == MEM && GET_CODE (src) == REG\n+\t  && (regno = REGNO (src)) >= FIRST_PSEUDO_REGISTER\n \t  && REG_BASIC_BLOCK (regno) >= 0\n-\t  && reg_equiv_init_insn[regno] != 0\n+\t  && REG_N_SETS (regno) == 1\n+\t  && reg_equiv_init_insns[regno] != 0\n+\t  && reg_equiv_init_insns[regno] != const0_rtx\n \t  && ! find_reg_note (insn, REG_EQUIV, NULL_RTX)\n-\t  && ! contains_replace_regs (XEXP (dest, 0), reg_equiv_replace)\n-\t  && validate_equiv_mem (reg_equiv_init_insn[regno], SET_SRC (set),\n-\t\t\t\t dest)\n-\t  && ! memref_used_between_p (SET_DEST (set),\n-\t\t\t\t      reg_equiv_init_insn[regno], insn))\n-\tREG_NOTES (reg_equiv_init_insn[regno])\n-\t  = gen_rtx_EXPR_LIST (REG_EQUIV, dest,\n-\t\t\t       REG_NOTES (reg_equiv_init_insn[regno]));\n+\t  && ! contains_replace_regs (XEXP (dest, 0), reg_equiv_replace))\n+\t{\n+\t  rtx init_insn = XEXP (reg_equiv_init_insns[regno], 0);\n+\t  if (validate_equiv_mem (init_insn, src, dest)\n+\t      && ! memref_used_between_p (dest, init_insn, insn))\n+\t    REG_NOTES (init_insn)\n+\t      = gen_rtx_EXPR_LIST (REG_EQUIV, dest, REG_NOTES (init_insn));\n+\t}\n \n       /* We only handle the case of a pseudo register being set\n-\t once and only if neither the source nor the destination are\n-\t in a register class that's likely to be spilled.  */\n+\t once, or always to the same value.  */\n+      /* ??? The mn10200 port breaks if we add equivalences for\n+\t values that need an ADDRESS_REGS register and set them equivalent\n+\t to a MEM of a pseudo.  The actual problem is in the over-conservative\n+\t handling of INPADDR_ADDRESS / INPUT_ADDRESS / INPUT triples in\n+\t calculate_needs, but we traditionally work around this problem\n+\t here by rejecting equivalences when the destination is in a register\n+\t that's likely spilled.  This is fragile, of course, since the\n+\t preferred class of a pseudo depends on all intructions that set\n+\t or use it.  */\n+\n       if (GET_CODE (dest) != REG\n \t  || (regno = REGNO (dest)) < FIRST_PSEUDO_REGISTER\n-\t  || REG_N_SETS (regno) != 1\n-\t  || CLASS_LIKELY_SPILLED_P (reg_preferred_class (REGNO (dest)))\n-\t  || (GET_CODE (src) == REG\n-\t      && REGNO (src) >= FIRST_PSEUDO_REGISTER\n-\t      && CLASS_LIKELY_SPILLED_P (reg_preferred_class (REGNO (src)))))\n-\tcontinue;\n+\t  || reg_equiv_init_insns[regno] == const0_rtx\n+\t  || (CLASS_LIKELY_SPILLED_P (reg_preferred_class (regno))\n+\t      && GET_CODE (src) == MEM))\n+\t{\n+\t  /* This might be seting a SUBREG of a pseudo, a pseudo that is\n+\t     also set somewhere else to a constant.  */\n+\t  note_stores (set, no_equiv);\n+\t  continue;\n+\t}\n+      /* Don't handle the equivalence if the source is in a register\n+\t class that's likely to be spilled.  */\n+      if (GET_CODE (src) == REG\n+\t  && REGNO (src) >= FIRST_PSEUDO_REGISTER\n+\t  && CLASS_LIKELY_SPILLED_P (reg_preferred_class (REGNO (src))))\n+\t{\n+\t  no_equiv (dest, set);\n+\t  continue;\n+\t}\n \n       note = find_reg_note (insn, REG_EQUAL, NULL_RTX);\n \n@@ -736,8 +792,19 @@ update_equiv_regs ()\n         note = NULL;\n #endif\n \n+      if (REG_N_SETS (regno) != 1\n+\t  && (! note\n+\t      || ! CONSTANT_P (XEXP (note, 0))\n+\t      || (reg_equiv_replacement[regno]\n+\t\t  && ! rtx_equal_p (XEXP (note, 0),\n+\t\t\t\t    reg_equiv_replacement[regno]))))\n+\t{\n+\t  no_equiv (dest, set);\n+\t  continue;\n+\t}\n       /* Record this insn as initializing this register.  */\n-      reg_equiv_init_insn[regno] = insn;\n+      reg_equiv_init_insns[regno]\n+\t= gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv_init_insns[regno]);\n \n       /* If this register is known to be equal to a constant, record that\n \t it is always equivalent to the constant.  */\n@@ -849,7 +916,12 @@ update_equiv_regs ()\n \t      if (! reg_equiv_replace[regno])\n \t\tcontinue;\n \n-\t      equiv_insn = reg_equiv_init_insn[regno];\n+\t      /* reg_equiv_replace[REGNO] gets set only when\n+\t\t REG_N_REFS[REGNO] is 2, i.e. the register is set\n+\t\t once and used once.  (If it were only set, but not used,\n+\t\t flow would have deleted the setting insns.)  Hence \n+\t\t there can only be one insn in reg_equiv_init_insns.  */\n+\t      equiv_insn = XEXP (reg_equiv_init_insns[regno], 0);\n \n \t      if (validate_replace_rtx (regno_reg_rtx[regno],\n \t\t\t\t\treg_equiv_replacement[regno], insn))\n@@ -896,6 +968,35 @@ update_equiv_regs ()\n \t}\n     }\n }\n+\n+/* Mark REG as having no known equivalence.\n+   Some instructions might have been proceessed before and furnished\n+   with REG_EQUIV notes for this register; these notes will have to be\n+   removed.\n+   STORE is the piece of RTL that does the non-constant / conflicting\n+   assignment - a SET, CLOBBER or REG_INC note.  It is currently not used,\n+   but needs to be there because this function is called from note_stores.  */\n+static void\n+no_equiv (reg, store)\n+     rtx reg, store;\n+{\n+  int regno;\n+  rtx list;\n+\n+  if (GET_CODE (reg) != REG)\n+    return;\n+  regno = REGNO (reg);\n+  list = reg_equiv_init_insns[regno];\n+  if (list == const0_rtx)\n+    return;\n+  for (; list; list =  XEXP (list, 1))\n+    {\n+      rtx insn = XEXP (list, 0);\n+      remove_note (insn, find_reg_note (insn, REG_EQUIV, NULL_RTX));\n+    }\n+  reg_equiv_init_insns[regno] = const0_rtx;\n+  reg_equiv_replacement[regno] = NULL_RTX;\n+}\n \f\n /* Allocate hard regs to the pseudo regs used only within block number B.\n    Only the pseudos that die but once can be handled.  */"}, {"sha": "5df3c155f755b91462daa6a13c8087446e8779e1", "filename": "gcc/reload1.c", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/135eb61ca459bf9556cfe7846553b678d11e6a52/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/135eb61ca459bf9556cfe7846553b678d11e6a52/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=135eb61ca459bf9556cfe7846553b678d11e6a52", "patch": "@@ -114,7 +114,7 @@ rtx *reg_equiv_mem;\n /* Widest width in which each pseudo reg is referred to (via subreg).  */\n static int *reg_max_ref_width;\n \n-/* Element N is the insn that initialized reg N from its equivalent\n+/* Element N is the list of insns that initialized reg N from its equivalent\n    constant or memory slot.  */\n static rtx *reg_equiv_init;\n \n@@ -710,7 +710,8 @@ reload (first, global, dumpfile)\n \t\t     So don't mark this insn now.  */\n \t\t  if (GET_CODE (x) != MEM\n \t\t      || rtx_equal_p (SET_SRC (set), x))\n-\t\t    reg_equiv_init[i] = insn;\n+\t\t    reg_equiv_init[i]\n+\t\t      = gen_rtx_INSN_LIST (VOIDmode, insn, reg_equiv_init[i]);\n \t\t}\n \t    }\n \t}\n@@ -722,7 +723,9 @@ reload (first, global, dumpfile)\n \t       && reg_equiv_memory_loc[REGNO (SET_SRC (set))]\n \t       && rtx_equal_p (SET_DEST (set),\n \t\t\t       reg_equiv_memory_loc[REGNO (SET_SRC (set))]))\n-\treg_equiv_init[REGNO (SET_SRC (set))] = insn;\n+\treg_equiv_init[REGNO (SET_SRC (set))]\n+\t  = gen_rtx_INSN_LIST (VOIDmode, insn,\n+\t\t\t       reg_equiv_init[REGNO (SET_SRC (set))]);\n \n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \tscan_paradoxical_subregs (PATTERN (insn));\n@@ -971,22 +974,30 @@ reload (first, global, dumpfile)\n      If that insn didn't set the register (i.e., it copied the register to\n      memory), just delete that insn instead of the equivalencing insn plus\n      anything now dead.  If we call delete_dead_insn on that insn, we may\n-     delete the insn that actually sets the register if the register die\n+     delete the insn that actually sets the register if the register dies\n      there and that is incorrect.  */\n \n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-    if (reg_renumber[i] < 0 && reg_equiv_init[i] != 0\n-\t&& GET_CODE (reg_equiv_init[i]) != NOTE)\n-      {\n-\tif (reg_set_p (regno_reg_rtx[i], PATTERN (reg_equiv_init[i])))\n-\t  delete_dead_insn (reg_equiv_init[i]);\n-\telse\n-\t  {\n-\t    PUT_CODE (reg_equiv_init[i], NOTE);\n-\t    NOTE_SOURCE_FILE (reg_equiv_init[i]) = 0;\n-\t    NOTE_LINE_NUMBER (reg_equiv_init[i]) = NOTE_INSN_DELETED;\n-\t  }\n-      }\n+    {\n+      if (reg_renumber[i] < 0 && reg_equiv_init[i] != 0)\n+\t{\n+\t  rtx list;\n+\t  for (list = reg_equiv_init[i]; list; list = XEXP (list, 1))\n+\t    {\n+\t      rtx equiv_insn = XEXP (list, 0);\n+\t      if (GET_CODE (equiv_insn) == NOTE)\n+\t\tcontinue;\n+\t      if (reg_set_p (regno_reg_rtx[i], PATTERN (equiv_insn)))\n+\t\tdelete_dead_insn (equiv_insn);\n+\t      else\n+\t\t{\n+\t\t  PUT_CODE (equiv_insn, NOTE);\n+\t\t  NOTE_SOURCE_FILE (equiv_insn) = 0;\n+\t\t  NOTE_LINE_NUMBER (equiv_insn) = NOTE_INSN_DELETED;\n+\t\t}\n+\t    }\n+\t}\n+    }\n \n   /* Use the reload registers where necessary\n      by generating move instructions to move the must-be-register"}]}