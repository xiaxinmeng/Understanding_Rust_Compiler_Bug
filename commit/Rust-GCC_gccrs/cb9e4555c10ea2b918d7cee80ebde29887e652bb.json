{"sha": "cb9e4555c10ea2b918d7cee80ebde29887e652bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I5ZTQ1NTVjMTBlYTJiOTE4ZDdjZWU4MGViZGUyOTg4N2U2NTJiYg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2003-02-26T16:55:10Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2003-02-26T16:55:10Z"}, "message": "gcov-dump.c (print_prefix): Fix signedness warning.\n\n\t* gcov-dump.c (print_prefix): Fix signedness warning.\n\t* gcov-io.h (struct counter_section, struct counter_section_data): New.\n\t(struct function_info): n_arc_counts field removed, n_counter_sections,\n\tcounter_sections fields added.\n\t(struct gcov_info): arc_counts, n_arc_counts fields removed,\n\tn_counter_sections, counter_sections fields added.\n\t* libgcov.c (gcov_exit, __gcov_flush): Add support for multiple\n\tprofile sections.\n\t* profile.h (MAX_COUNTER_SECTIONS): New.\n\t(struct section_info): New.\n\t(struct profile_info): count_instrumented_edges,\n\tcount_edges_instrumented_now fields removed, n_sections, section_info\n\tfields added.\n\t(find_counters_section): Declare.\n\t* profile.c (struct function_list): count_edges field removed,\n\tn_counter_sections, counter_sections fields added.\n\t(set_purpose, label_for_tag, build_counter_section_fields,\n\tbuild_counter_section_value, build_counter_section_data_fields,\n\tbuild_counter_section_data_value, build_function_info_fields,\n\tbuild_function_info_value, build_gcov_info_fields,\n\tbuild_gcov_info_value): New static functions.\n\t(find_counters_section): New function.\n\t(instrument_edges, get_exec_counts, compute_branch_probabilities,\n\tbranch_prob, create_profiler): Modified to support multiple profile\n\tsections.\n\nFrom-SVN: r63474", "tree": {"sha": "f82b07c8e80193a8fc0c8a5fe9eabdc6f54a41eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f82b07c8e80193a8fc0c8a5fe9eabdc6f54a41eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb9e4555c10ea2b918d7cee80ebde29887e652bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb9e4555c10ea2b918d7cee80ebde29887e652bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb9e4555c10ea2b918d7cee80ebde29887e652bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb9e4555c10ea2b918d7cee80ebde29887e652bb/comments", "author": null, "committer": null, "parents": [{"sha": "b0d7ef9afda5f6ddc09446e6387301ebe761616f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0d7ef9afda5f6ddc09446e6387301ebe761616f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0d7ef9afda5f6ddc09446e6387301ebe761616f"}], "stats": {"total": 984, "additions": 745, "deletions": 239}, "files": [{"sha": "fb5ca7e38c6d60f48f050bb0ba1462aed402b291", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9e4555c10ea2b918d7cee80ebde29887e652bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9e4555c10ea2b918d7cee80ebde29887e652bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cb9e4555c10ea2b918d7cee80ebde29887e652bb", "patch": "@@ -1,3 +1,31 @@\n+2003-02-26  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* gcov-dump.c (print_prefix): Fix signedness warning.\n+\t* gcov-io.h (struct counter_section, struct counter_section_data): New.\n+\t(struct function_info): n_arc_counts field removed, n_counter_sections,\n+\tcounter_sections fields added.\n+\t(struct gcov_info): arc_counts, n_arc_counts fields removed,\n+\tn_counter_sections, counter_sections fields added.\n+\t* libgcov.c (gcov_exit, __gcov_flush): Add support for multiple\n+\tprofile sections.\n+\t* profile.h (MAX_COUNTER_SECTIONS): New.\n+\t(struct section_info): New.\n+\t(struct profile_info): count_instrumented_edges,\n+\tcount_edges_instrumented_now fields removed, n_sections, section_info\n+\tfields added.\n+\t(find_counters_section): Declare.\n+\t* profile.c (struct function_list): count_edges field removed,\n+\tn_counter_sections, counter_sections fields added.\n+\t(set_purpose, label_for_tag, build_counter_section_fields,\n+\tbuild_counter_section_value, build_counter_section_data_fields,\n+\tbuild_counter_section_data_value, build_function_info_fields,\n+\tbuild_function_info_value, build_gcov_info_fields,\n+\tbuild_gcov_info_value): New static functions.\n+\t(find_counters_section): New function.\n+\t(instrument_edges, get_exec_counts, compute_branch_probabilities,\n+\tbranch_prob, create_profiler): Modified to support multiple profile\n+\tsections.\n+\n 2003-02-26  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* pa.c (compute_frame_size): Don't assume PREFERRED_STACK_BOUNDARY"}, {"sha": "acea56d9d64f8d4cd4a207d64c3b5bc142cbc7d7", "filename": "gcc/gcov-dump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9e4555c10ea2b918d7cee80ebde29887e652bb/gcc%2Fgcov-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9e4555c10ea2b918d7cee80ebde29887e652bb/gcc%2Fgcov-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-dump.c?ref=cb9e4555c10ea2b918d7cee80ebde29887e652bb", "patch": "@@ -131,7 +131,7 @@ print_prefix (filename, depth)\n {\n   static const char prefix[] = \"    \";\n   \n-  printf (\"%s:%.*s\", filename, depth, prefix);\n+  printf (\"%s:%.*s\", filename, (int) depth, prefix);\n }\n \n static void"}, {"sha": "ce29f67c8cb98b78ed7302e6d170bbc083ac6e9c", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9e4555c10ea2b918d7cee80ebde29887e652bb/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9e4555c10ea2b918d7cee80ebde29887e652bb/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=cb9e4555c10ea2b918d7cee80ebde29887e652bb", "patch": "@@ -216,16 +216,33 @@ struct gcov_summary\n   gcov_type arc_sum_max;  /* sum of max_one */\n };\n \n-#if IN_LIBGCC2\n /* Structures embedded in coveraged program.  The structures generated\n    by write_profile must match these.  */\n \n+/* Information about section of counters for a function.  */\n+struct counter_section\n+{\n+  unsigned tag;\t\t/* Tag of the section.  */\n+  unsigned n_counters;\t/* Number of counters in the section.  */\n+};\n+\n+#if IN_LIBGCC2\n+/* Information about section of counters for an object file.  */\n+struct counter_section_data\n+{\n+  unsigned tag;\t\t/* Tag of the section.  */\n+  unsigned n_counters;\t/* Number of counters in the section.  */\n+  gcov_type *counters;\t/* The data.  */\n+};\n+\n /* Information about a single function.  */\n struct function_info\n {\n   const char *name;\t        /* (mangled) name of function */\n   unsigned checksum;\t\t/* function checksum */\n-  unsigned n_arc_counts;\t/* number of instrumented arcs */\n+  unsigned n_counter_sections;\t/* Number of types of counters */\n+  const struct counter_section *counter_sections;\n+  \t\t\t\t/* The section descriptions */\n };\n \n /* Information about a single object file.  */\n@@ -237,11 +254,12 @@ struct gcov_info\n   const char *filename;\t\t/* output file name */\n   long wkspc;\t  \t        /* libgcc workspace */\n \n-  const struct function_info *functions; /* table of functions */\n   unsigned n_functions;             /* number of functions */\n+  const struct function_info *functions; /* table of functions */\n \n-  gcov_type *arc_counts;\t/* table of arc counts */\n-  unsigned n_arc_counts;\t/* number of arc counts */\n+  unsigned n_counter_sections;\t/* Number of types of counters */\n+  const struct counter_section_data *counter_sections;\n+  \t\t\t\t/* The data to be put into the sections.  */\n };\n \n /* Register a new object file module.  */"}, {"sha": "657de36d30030a225275083ff91b857d778dc20e", "filename": "gcc/libgcov.c", "status": "modified", "additions": 94, "deletions": 48, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9e4555c10ea2b918d7cee80ebde29887e652bb/gcc%2Flibgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9e4555c10ea2b918d7cee80ebde29887e652bb/gcc%2Flibgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcov.c?ref=cb9e4555c10ea2b918d7cee80ebde29887e652bb", "patch": "@@ -112,14 +112,35 @@ gcov_exit (void)\n       int merging = 0;\n       long base;\n       const struct function_info *fn_info;\n+      gcov_type **counters;\n       gcov_type *count_ptr;\n       gcov_type object_max_one = 0;\n+      gcov_type count;\n+      unsigned tag, length, flength, checksum;\n+      unsigned arc_data_index, f_sect_index, sect_index;\n \n       ptr->wkspc = 0;\n       if (!ptr->filename)\n \tcontinue;\n \n-      for (ix = ptr->n_arc_counts, count_ptr = ptr->arc_counts; ix--;)\n+      counters = malloc (sizeof (gcov_type *) * ptr->n_counter_sections);\n+      for (ix = 0; ix < ptr->n_counter_sections; ix++)\n+\tcounters[ix] = ptr->counter_sections[ix].counters;\n+\n+      for (arc_data_index = 0;\n+\t   arc_data_index < ptr->n_counter_sections\n+\t   && ptr->counter_sections[arc_data_index].tag != GCOV_TAG_ARC_COUNTS;\n+\t   arc_data_index++)\n+\tcontinue;\n+\n+      if (arc_data_index == ptr->n_counter_sections)\n+\t{\n+\t  /* For now; later we may want to just measure other profiles,\n+\t     but now I am lazy to check for all consequences.  */\n+\t  abort ();\n+\t}\n+      for (ix = ptr->counter_sections[arc_data_index].n_counters,\n+\t   count_ptr = ptr->counter_sections[arc_data_index].counters; ix--;)\n \t{\n \t  gcov_type count = *count_ptr++;\n \n@@ -155,7 +176,6 @@ gcov_exit (void)\n       if (merging)\n \t{\n \t  /* Merge data from file.  */\n-\t  unsigned tag, length;\n \t      \n \t  if (gcov_read_unsigned (da_file, &tag) || tag != GCOV_DATA_MAGIC)\n \t    {\n@@ -173,7 +193,6 @@ gcov_exit (void)\n \t    }\n \t  \n \t  /* Merge execution counts for each function.  */\n-\t  count_ptr = ptr->arc_counts;\n \t  for (ix = ptr->n_functions, fn_info = ptr->functions;\n \t       ix--; fn_info++)\n \t    {\n@@ -194,33 +213,40 @@ gcov_exit (void)\n \t\t\t   ptr->filename, fn_info->name);\n \t\t  goto read_fatal;\n \t\t}\n-\t      {\n-\t\tunsigned flength, checksum;\n-\t\t\n-\t\tif (gcov_read_unsigned (da_file, &flength)\n-\t\t    || gcov_skip_string (da_file, flength)\n-\t\t    || gcov_read_unsigned (da_file, &checksum))\n-\t\t  goto read_error;\n-\t\tif (flength != strlen (fn_info->name)\n-\t\t    || checksum != fn_info->checksum)\n-\t\t  goto read_mismatch;\n-\t      }\n-\t      /* Check arc counts */\n-\t      if (gcov_read_unsigned (da_file, &tag)\n-\t\t  || gcov_read_unsigned (da_file, &length))\n+\n+\t      if (gcov_read_unsigned (da_file, &flength)\n+\t\t  || gcov_skip_string (da_file, flength)\n+\t\t  || gcov_read_unsigned (da_file, &checksum))\n \t\tgoto read_error;\n-\t      if (tag != GCOV_TAG_ARC_COUNTS\n-\t\t  || length / 8 != fn_info->n_arc_counts)\n+\t      if (flength != strlen (fn_info->name)\n+\t\t  || checksum != fn_info->checksum)\n \t\tgoto read_mismatch;\n-\t      {\n-\t\tgcov_type count;\n-\t\t\n-\t\tfor (jx = fn_info->n_arc_counts; jx--; count_ptr++)\n-\t\t  if (gcov_read_counter (da_file, &count))\n+\n+\t      /* Counters.  */\n+\t      for (f_sect_index = 0;\n+\t\t   f_sect_index < fn_info->n_counter_sections;\n+\t\t   f_sect_index++)\n+\t\t{\n+\t\t  if (gcov_read_unsigned (da_file, &tag)\n+\t\t      || gcov_read_unsigned (da_file, &length))\n \t\t    goto read_error;\n-\t\t  else\n-\t\t    *count_ptr += count;\n-\t      }\n+\t\t  for (sect_index = 0;\n+\t\t       sect_index < ptr->n_counter_sections;\n+\t\t       sect_index++)\n+\t\t    if (ptr->counter_sections[sect_index].tag == tag)\n+\t\t      break;\n+\t\t  if (fn_info->counter_sections[f_sect_index].tag != tag\n+\t\t      || sect_index == ptr->n_counter_sections\n+\t\t      || length / 8 != fn_info->counter_sections[f_sect_index].n_counters)\n+\t\t    goto read_mismatch;\n+\t\t  \n+\t\t  for (jx = fn_info->counter_sections[f_sect_index].n_counters;\n+\t\t       jx--; counters[sect_index]++)\n+\t\t    if (gcov_read_counter (da_file, &count))\n+\t\t      goto read_error;\n+\t\t    else\n+\t\t      *counters[sect_index] += count;\n+\t\t}\n \t    }\n \n \t  /* Check object summary */\n@@ -279,7 +305,7 @@ gcov_exit (void)\n \t}\n \n       object.runs++;\n-      object.arcs = ptr->n_arc_counts;\n+      object.arcs = ptr->counter_sections[arc_data_index].n_counters;\n       object.arc_sum = 0;\n       if (object.arc_max_one < object_max_one)\n \tobject.arc_max_one = object_max_one;\n@@ -299,7 +325,8 @@ gcov_exit (void)\n \t}\n       \n       /* Write execution counts for each function.  */\n-      count_ptr = ptr->arc_counts;\n+      for (ix = 0; ix < ptr->n_counter_sections; ix++)\n+\tcounters[ix] = ptr->counter_sections[ix].counters;\n       for (ix = ptr->n_functions, fn_info = ptr->functions; ix--; fn_info++)\n \t{\n \t  /* Announce function.  */\n@@ -312,24 +339,41 @@ gcov_exit (void)\n \t      || gcov_write_unsigned (da_file, fn_info->checksum)\n \t      || gcov_write_length (da_file, base))\n \t    goto write_error;\n-\t  \n-\t  /* arc counts.  */\n-\t  if (gcov_write_unsigned (da_file, GCOV_TAG_ARC_COUNTS)\n-\t      || !(base = gcov_reserve_length (da_file)))\n-\t    goto write_error;\n-\t  \n-\t  for (jx = fn_info->n_arc_counts; jx--;)\n+\n+\t  /* counters.  */\n+\t  for (f_sect_index = 0;\n+\t       f_sect_index < fn_info->n_counter_sections;\n+\t       f_sect_index++)\n \t    {\n-\t      gcov_type count = *count_ptr++;\n+\t      tag = fn_info->counter_sections[f_sect_index].tag;\n+\t      for (sect_index = 0;\n+    \t\t   sect_index < ptr->n_counter_sections;\n+\t\t   sect_index++)\n+\t\tif (ptr->counter_sections[sect_index].tag == tag)\n+\t\t  break;\n+\t      if (sect_index == ptr->n_counter_sections)\n+\t\tabort ();\n+\n+\t      if (gcov_write_unsigned (da_file, tag)\n+\t\t  || !(base = gcov_reserve_length (da_file)))\n+\t\tgoto write_error;\n+\t  \n+    \t      for (jx = fn_info->counter_sections[f_sect_index].n_counters; jx--;)\n+\t\t{\n+\t\t  gcov_type count = *counters[sect_index]++;\n \t      \n-\t      object.arc_sum += count;\n-\t      if (object.arc_max_sum < count)\n-\t\tobject.arc_max_sum = count;\n-\t      if (gcov_write_counter (da_file, count))\n-\t\tgoto write_error; /* RIP Edsger Dijkstra */\n+\t\t  if (tag == GCOV_TAG_ARC_COUNTS)\n+\t\t    {\n+\t\t      object.arc_sum += count;\n+\t\t      if (object.arc_max_sum < count)\n+\t\t\tobject.arc_max_sum = count;\n+\t\t    }\n+\t\t  if (gcov_write_counter (da_file, count))\n+\t\t    goto write_error; /* RIP Edsger Dijkstra */\n+\t\t}\n+\t      if (gcov_write_length (da_file, base))\n+\t\tgoto write_error;\n \t    }\n-\t  if (gcov_write_length (da_file, base))\n-\t    goto write_error;\n \t}\n \n       /* Object file summary.  */\n@@ -367,11 +411,12 @@ gcov_exit (void)\n \t}\n       else\n \t{\n-\t  program_arcs += ptr->n_arc_counts;\n+\t  program_arcs += ptr->counter_sections[arc_data_index].n_counters;\n \t  program_sum += object.arc_sum;\n \t  if (program_max_sum < object.arc_max_sum)\n \t    program_max_sum = object.arc_max_sum;\n \t}\n+      free(counters);\n     }\n \n   /* Generate whole program statistics.  */\n@@ -465,9 +510,10 @@ __gcov_flush (void)\n   gcov_exit ();\n   for (ptr = gcov_list; ptr; ptr = ptr->next)\n     {\n-      unsigned i;\n+      unsigned i, j;\n       \n-      for (i = ptr->n_arc_counts; i--;)\n-\tptr->arc_counts[i] = 0;\n+      for (j = 0; j < ptr->n_counter_sections; j++)\n+\tfor (i = ptr->counter_sections[j].n_counters; i--;)\n+\t  ptr->counter_sections[j].counters[i] = 0;\n     }\n }"}, {"sha": "261bfd0d007fe195c9a74bc0901399c182830da1", "filename": "gcc/profile.c", "status": "modified", "additions": 580, "deletions": 174, "changes": 754, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9e4555c10ea2b918d7cee80ebde29887e652bb/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9e4555c10ea2b918d7cee80ebde29887e652bb/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=cb9e4555c10ea2b918d7cee80ebde29887e652bb", "patch": "@@ -96,7 +96,9 @@ struct function_list\n   struct function_list *next; \t/* next function */\n   const char *name; \t\t/* function name */\n   unsigned cfg_checksum;\t/* function checksum */\n-  unsigned count_edges;\t        /* number of intrumented edges  */\n+  unsigned n_counter_sections;\t/* number of counter sections */\n+  struct counter_section counter_sections[MAX_COUNTER_SECTIONS];\n+  \t\t\t\t/* the sections */\n };\n \n static struct function_list *functions_head = 0;\n@@ -156,6 +158,16 @@ static gcov_type * get_exec_counts PARAMS ((void));\n static unsigned compute_checksum PARAMS ((void));\n static basic_block find_group PARAMS ((basic_block));\n static void union_groups PARAMS ((basic_block, basic_block));\n+static void set_purpose PARAMS ((tree, tree));\n+static rtx label_for_tag PARAMS ((unsigned));\n+static tree build_counter_section_fields PARAMS ((void));\n+static tree build_counter_section_value PARAMS ((unsigned, unsigned));\n+static tree build_counter_section_data_fields PARAMS ((void));\n+static tree build_counter_section_data_value PARAMS ((unsigned, unsigned));\n+static tree build_function_info_fields PARAMS ((void));\n+static tree build_function_info_value PARAMS ((struct function_list *));\n+static tree build_gcov_info_fields PARAMS ((tree));\n+static tree build_gcov_info_value PARAMS ((void));\n \n \f\n /* Add edge instrumentation code to the entire insn chain.\n@@ -170,6 +182,7 @@ instrument_edges (el)\n   int num_instr_edges = 0;\n   int num_edges = NUM_EDGES (el);\n   basic_block bb;\n+  struct section_info *section_info;\n   remove_fake_edges ();\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n@@ -194,15 +207,14 @@ instrument_edges (el)\n \t}\n     }\n \n-  profile_info.count_edges_instrumented_now = num_instr_edges;\n+  section_info = find_counters_section (GCOV_TAG_ARC_COUNTS);\n+  section_info->n_counters_now = num_instr_edges;\n   total_num_edges_instrumented += num_instr_edges;\n-  profile_info.count_instrumented_edges = total_num_edges_instrumented;\n+  section_info->n_counters = total_num_edges_instrumented;\n \n   total_num_blocks_created += num_edges;\n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \"%d edges instrumented\\n\", num_instr_edges);\n-\n-  commit_edge_insertions_watch_calls ();\n }\n \f\n struct section_reference\n@@ -847,6 +859,7 @@ compute_branch_probabilities ()\n   free_aux_for_blocks ();\n   if (exec_counts)\n     free (exec_counts);\n+  find_counters_section (GCOV_TAG_ARC_COUNTS)->present = 1;\n }\n \n /* Compute checksum for the current function.  We generate a CRC32.  */\n@@ -908,13 +921,18 @@ void\n branch_prob ()\n {\n   basic_block bb;\n-  int i;\n-  int num_edges, ignored_edges;\n+  unsigned i;\n+  unsigned num_edges, ignored_edges;\n   struct edge_list *el;\n   const char *name = IDENTIFIER_POINTER\n \t\t      (DECL_ASSEMBLER_NAME (current_function_decl));\n \n   profile_info.current_function_cfg_checksum = compute_checksum ();\n+  for (i = 0; i < profile_info.n_sections; i++)\n+    {\n+      profile_info.section_info[i].n_counters_now = 0;\n+      profile_info.section_info[i].present = 0;\n+    }\n \n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \"CFG checksum is %u\\n\",\n@@ -1082,7 +1100,7 @@ branch_prob ()\n       if (gcov_write_unsigned (bbg_file, GCOV_TAG_BLOCKS)\n \t  || !(offset = gcov_reserve_length (bbg_file)))\n \tgoto bbg_error;\n-      for (i = 0; i != n_basic_blocks + 2; i++)\n+      for (i = 0; i != (unsigned) (n_basic_blocks + 2); i++)\n \tif (gcov_write_unsigned (bbg_file, 0))\n \t  goto bbg_error;\n       if (gcov_write_length (bbg_file, offset))\n@@ -1118,6 +1136,7 @@ branch_prob ()\n \t\t    goto bbg_error;\n \t        }\n \t    }\n+\n \t  if (gcov_write_length (bbg_file, offset))\n \t    goto bbg_error;\n \t}\n@@ -1184,6 +1203,7 @@ branch_prob ()\n \t\t  }\n \t\tinsn = NEXT_INSN (insn);\n \t      }\n+\n \t    if (offset)\n \t      {\n \t\tif (gcov_write_unsigned (bbg_file, 0)\n@@ -1210,6 +1230,9 @@ branch_prob ()\n       struct function_list *item;\n       \n       instrument_edges (el);\n+\n+      /* Commit changes done by instrumentation.  */\n+      commit_edge_insertions_watch_calls ();\n       allocate_reg_info (max_reg_num (), FALSE, FALSE);\n \n       /* ??? Probably should re-use the existing struct function.  */\n@@ -1221,17 +1244,26 @@ branch_prob ()\n       item->next = 0;\n       item->name = xstrdup (name);\n       item->cfg_checksum = profile_info.current_function_cfg_checksum;\n-      item->count_edges = profile_info.count_edges_instrumented_now;\n+      item->n_counter_sections = 0;\n+      for (i = 0; i < profile_info.n_sections; i++)\n+\tif (profile_info.section_info[i].n_counters_now)\n+\t  {\n+\t    item->counter_sections[item->n_counter_sections].tag = \n+\t\t    profile_info.section_info[i].tag;\n+\t    item->counter_sections[item->n_counter_sections].n_counters =\n+\t\t    profile_info.section_info[i].n_counters_now;\n+\t    item->n_counter_sections++;\n+\t  }\n     }\n \n   remove_fake_edges ();\n+  free_aux_for_edges ();\n   /* Re-merge split basic blocks and the mess introduced by\n      insert_insn_on_edge.  */\n   cleanup_cfg (profile_arc_flag ? CLEANUP_EXPENSIVE : 0);\n   if (rtl_dump_file)\n     dump_flow_info (rtl_dump_file);\n \n-  free_aux_for_edges ();\n   free_edge_list (el);\n }\n \f\n@@ -1477,198 +1509,570 @@ end_branch_prob ()\n     }\n }\n \n-/* Write out the structure which libgcc uses to locate all the arc\n-   counters.  The structures used here must match those defined in\n-   gcov-io.h.  Write out the constructor to call __gcov_init.  */\n+/* Find (and create if not present) a section with TAG.  */\n+struct section_info *\n+find_counters_section (tag)\n+     unsigned tag;\n+{\n+  unsigned i;\n \n-void\n-create_profiler ()\n+  for (i = 0; i < profile_info.n_sections; i++)\n+    if (profile_info.section_info[i].tag == tag)\n+      return profile_info.section_info + i;\n+\n+  if (i == MAX_COUNTER_SECTIONS)\n+    abort ();\n+\n+  profile_info.section_info[i].tag = tag;\n+  profile_info.section_info[i].present = 0;\n+  profile_info.section_info[i].n_counters = 0;\n+  profile_info.section_info[i].n_counters_now = 0;\n+  profile_info.n_sections++;\n+\n+  return profile_info.section_info + i;\n+}\n+\n+/* Set FIELDS as purpose to VALUE.  */\n+static void\n+set_purpose (value, fields)\n+     tree value;\n+     tree fields;\n {\n-  tree fields, field, value = NULL_TREE;\n-  tree ginfo_type;\n-  tree string_type;\n-  tree gcov_type, gcov_ptr_type;\n-  char name[20];\n-  char *ctor_name;\n-  tree structure, ctor;\n-  rtx structure_address;\n-  int save_flag_inline_functions = flag_inline_functions;\n+  tree act_field, act_value;\n+  \n+  for (act_field = fields, act_value = value;\n+       act_field;\n+       act_field = TREE_CHAIN (act_field), act_value = TREE_CHAIN (act_value))\n+    TREE_PURPOSE (act_value) = act_field;\n+}\n \n-  if (!profile_info.count_instrumented_edges)\n-    return;\n+/* Returns label for base of counters inside TAG section.  */\n+static rtx\n+label_for_tag (tag)\n+     unsigned tag;\n+{\n+  switch (tag)\n+    {\n+    case GCOV_TAG_ARC_COUNTS:\n+      return profiler_label;\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Creates fields of struct counter_section (in gcov-io.h).  */\n+static tree\n+build_counter_section_fields ()\n+{\n+  tree field, fields;\n+\n+  /* tag */\n+  fields = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+\n+  /* n_counters */\n+  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+\n+  return fields;\n+}\n+\n+/* Creates value of struct counter_section (in gcov-io.h).  */\n+static tree\n+build_counter_section_value (tag, n_counters)\n+     unsigned tag;\n+     unsigned n_counters;\n+{\n+  tree value = NULL_TREE;\n+\n+  /* tag */\n+  value = tree_cons (NULL_TREE,\n+\t\t     convert (unsigned_type_node,\n+\t\t\t      build_int_2 (tag, 0)),\n+\t\t     value);\n   \n-  string_type = build_pointer_type\n-    (build_qualified_type (char_type_node,  TYPE_QUAL_CONST));\n+  /* n_counters */\n+  value = tree_cons (NULL_TREE,\n+\t\t     convert (unsigned_type_node,\n+\t\t\t      build_int_2 (n_counters, 0)),\n+\t\t     value);\n+\n+  return value;\n+}\n+\n+/* Creates fields of struct counter_section_data (in gcov-io.h).  */\n+static tree\n+build_counter_section_data_fields ()\n+{\n+  tree field, fields, gcov_type, gcov_ptr_type;\n+\n+  gcov_type = make_signed_type (GCOV_TYPE_SIZE);\n+  gcov_ptr_type =\n+\t  build_pointer_type (build_qualified_type (gcov_type,\n+\t\t\t\t\t\t    TYPE_QUAL_CONST));\n+\n+  /* tag */\n+  fields = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+\n+  /* n_counters */\n+  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+\n+  /* counters */\n+  field = build_decl (FIELD_DECL, NULL_TREE, gcov_ptr_type);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+\n+  return fields;\n+}\n+\n+/* Creates value of struct counter_section_data (in gcov-io.h).  */\n+static tree\n+build_counter_section_data_value (tag, n_counters)\n+     unsigned tag;\n+     unsigned n_counters;\n+{\n+  tree value = NULL_TREE, counts_table, gcov_type, gcov_ptr_type;\n+\n   gcov_type = make_signed_type (GCOV_TYPE_SIZE);\n   gcov_ptr_type\n     = build_pointer_type (build_qualified_type\n \t\t\t  (gcov_type, TYPE_QUAL_CONST));\n+\n+  /* tag */\n+  value = tree_cons (NULL_TREE,\n+\t\t     convert (unsigned_type_node,\n+\t\t\t      build_int_2 (tag, 0)),\n+\t\t     value);\n   \n-  ginfo_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n-  \n+  /* n_counters */\n+  value = tree_cons (NULL_TREE,\n+\t\t     convert (unsigned_type_node,\n+\t\t\t      build_int_2 (n_counters, 0)),\n+\t\t     value);\n+\n+  /* counters */\n+  if (n_counters)\n+    {\n+      tree gcov_type_array_type =\n+\t      build_array_type (gcov_type,\n+\t\t\t\tbuild_index_type (build_int_2 (n_counters - 1,\n+\t\t\t\t\t\t\t       0)));\n+      counts_table =\n+\t      build (VAR_DECL, gcov_type_array_type, NULL_TREE, NULL_TREE);\n+      TREE_STATIC (counts_table) = 1;\n+      DECL_NAME (counts_table) = get_identifier (XSTR (label_for_tag (tag), 0));\n+      assemble_variable (counts_table, 0, 0, 0);\n+      counts_table = build1 (ADDR_EXPR, gcov_ptr_type, counts_table);\n+    }\n+  else\n+    counts_table = null_pointer_node;\n+\n+  value = tree_cons (NULL_TREE, counts_table, value);\n+\n+  return value;\n+}\n+\n+/* Creates fields for struct function_info type (in gcov-io.h).  */\n+static tree\n+build_function_info_fields ()\n+{\n+  tree field, fields, counter_section_fields, counter_section_type;\n+  tree counter_sections_ptr_type;\n+  tree string_type =\n+\t  build_pointer_type (build_qualified_type (char_type_node,\n+\t\t\t\t\t\t    TYPE_QUAL_CONST));\n+  /* name */\n+  fields = build_decl (FIELD_DECL, NULL_TREE, string_type);\n+\n+  /* checksum */\n+  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+\n+  /* n_counter_sections */\n+  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+\n+  /* counter_sections */\n+  counter_section_fields = build_counter_section_fields ();\n+  counter_section_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+  finish_builtin_struct (counter_section_type, \"__counter_section\",\n+\t\t\t counter_section_fields, NULL_TREE);\n+  counter_sections_ptr_type =\n+\t  build_pointer_type\n+\t  \t(build_qualified_type (counter_section_type,\n+\t\t\t\t       TYPE_QUAL_CONST));\n+  field = build_decl (FIELD_DECL, NULL_TREE, counter_sections_ptr_type);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+\n+  return fields;\n+}\n+\n+/* Creates value for struct function_info (in gcov-io.h).  */\n+static tree\n+build_function_info_value (function)\n+     struct function_list *function;\n+{\n+  tree value = NULL_TREE;\n+  size_t name_len = strlen (function->name);\n+  tree fname = build_string (name_len + 1, function->name);\n+  tree string_type =\n+\t  build_pointer_type (build_qualified_type (char_type_node,\n+\t\t\t\t\t\t    TYPE_QUAL_CONST));\n+  tree counter_section_fields, counter_section_type, counter_sections_value;\n+  tree counter_sections_ptr_type, counter_sections_array_type;\n+  unsigned i;\n+\n+  /* name */\n+  TREE_TYPE (fname) =\n+\t  build_array_type (char_type_node,\n+\t\t\t    build_index_type (build_int_2 (name_len, 0)));\n+  value = tree_cons (NULL_TREE,\n+\t\t     build1 (ADDR_EXPR,\n+\t\t\t     string_type,\n+\t\t\t     fname),\n+\t\t     value);\n+\n+  /* checksum */\n+  value = tree_cons (NULL_TREE,\n+\t\t     convert (unsigned_type_node,\n+\t\t\t      build_int_2 (function->cfg_checksum, 0)),\n+\t\t     value);\n+\n+  /* n_counter_sections */\n+\n+  value = tree_cons (NULL_TREE,\n+\t\t     convert (unsigned_type_node,\n+\t\t\t      build_int_2 (function->n_counter_sections, 0)),\n+\t    \t    value);\n+\n+  /* counter_sections */\n+  counter_section_fields = build_counter_section_fields ();\n+  counter_section_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+  counter_sections_ptr_type =\n+\t  build_pointer_type\n+\t  \t(build_qualified_type (counter_section_type,\n+\t\t\t\t       TYPE_QUAL_CONST));\n+  counter_sections_array_type =\n+\t  build_array_type (counter_section_type,\n+\t\t\t    build_index_type (\n+      \t\t\t\tbuild_int_2 (function->n_counter_sections - 1,\n+\t\t  \t\t\t     0)));\n+\n+  counter_sections_value = NULL_TREE;\n+  for (i = 0; i < function->n_counter_sections; i++)\n+    {\n+      tree counter_section_value =\n+\t      build_counter_section_value (function->counter_sections[i].tag,\n+\t\t\t\t\t   function->counter_sections[i].n_counters);\n+      set_purpose (counter_section_value, counter_section_fields);\n+      counter_sections_value = tree_cons (NULL_TREE,\n+\t\t\t\t\t  build (CONSTRUCTOR,\n+\t\t\t\t\t\t counter_section_type,\n+\t\t\t\t\t\t NULL_TREE,\n+\t\t\t\t\t\t nreverse (counter_section_value)),\n+\t\t\t\t\t  counter_sections_value);\n+    }\n+  finish_builtin_struct (counter_section_type, \"__counter_section\",\n+\t\t\t counter_section_fields, NULL_TREE);\n+\n+  if (function->n_counter_sections)\n+    {\n+      counter_sections_value = \n+\t      build (CONSTRUCTOR,\n+ \t\t     counter_sections_array_type,\n+\t\t     NULL_TREE,\n+\t\t     nreverse (counter_sections_value)),\n+      counter_sections_value = build1 (ADDR_EXPR,\n+\t\t\t\t       counter_sections_ptr_type,\n+\t\t\t\t       counter_sections_value);\n+    }\n+  else\n+    counter_sections_value = null_pointer_node;\n+\n+  value = tree_cons (NULL_TREE, counter_sections_value, value);\n+\n+  return value;\n+}\n+\n+/* Creates fields of struct gcov_info type (in gcov-io.h).  */\n+static tree\n+build_gcov_info_fields (gcov_info_type)\n+     tree gcov_info_type;\n+{\n+  tree field, fields;\n+  char *filename;\n+  int filename_len;\n+  tree string_type =\n+\t  build_pointer_type (build_qualified_type (char_type_node,\n+\t\t\t\t\t\t    TYPE_QUAL_CONST));\n+  tree function_info_fields, function_info_type, function_info_ptr_type;\n+  tree counter_section_data_fields, counter_section_data_type;\n+  tree counter_section_data_ptr_type;\n \n   /* Version ident */\n   fields = build_decl (FIELD_DECL, NULL_TREE, long_unsigned_type_node);\n-  value = tree_cons (fields, convert (long_unsigned_type_node, build_int_2\n-\t\t\t\t      (GCOV_VERSION, 0)), value);\n-      \n-  /* NULL */\n-  field = build_decl (FIELD_DECL, NULL_TREE, build_pointer_type\n-\t\t      (build_qualified_type\n-\t\t       (ginfo_type, TYPE_QUAL_CONST)));\n+\n+  /* next -- NULL */\n+  field = build_decl (FIELD_DECL, NULL_TREE,\n+\t\t      build_pointer_type (build_qualified_type (gcov_info_type,\n+\t\t\t\t\t\t\t\tTYPE_QUAL_CONST)));\n   TREE_CHAIN (field) = fields;\n   fields = field;\n-  value = tree_cons (fields, null_pointer_node, value);\n   \n   /* Filename */\n-  {\n-    tree filename_string;\n-    char *filename;\n-    int filename_len;\n-    \n-    filename = getpwd ();\n-    filename = (filename && da_file_name[0] != '/'\n-\t\t? concat (filename, \"/\", da_file_name, NULL)\n-\t\t: da_file_name);\n-    filename_len = strlen (filename);\n-    filename_string = build_string (filename_len + 1, filename);\n-    if (filename != da_file_name)\n-      free (filename);\n-    TREE_TYPE (filename_string) = build_array_type\n-      (char_type_node, build_index_type\n-       (build_int_2 (filename_len, 0)));\n-    \n-    field = build_decl (FIELD_DECL, NULL_TREE, string_type);\n-    TREE_CHAIN (field) = fields;\n-    fields = field;\n-    value = tree_cons (fields, build1 (ADDR_EXPR, string_type,\n-\t\t\t\t       filename_string), value);\n-  }\n+  filename = getpwd ();\n+  filename = (filename && da_file_name[0] != '/'\n+\t      ? concat (filename, \"/\", da_file_name, NULL)\n+\t      : da_file_name);\n+  filename_len = strlen (filename);\n+  if (filename != da_file_name)\n+    free (filename);\n+\n+  field = build_decl (FIELD_DECL, NULL_TREE, string_type);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n   \n   /* Workspace */\n   field = build_decl (FIELD_DECL, NULL_TREE, long_integer_type_node);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n-  value = tree_cons (fields,\n-\t\t     convert (long_integer_type_node, integer_zero_node),\n-\t\t     value);\n+\n+  /* number of functions */\n+  field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n       \n   /* function_info table */\n-  {\n-    struct function_list *item;\n-    int num_nodes = 0;\n-    tree array_value = NULL_TREE;\n-    tree finfo_type, finfo_ptr_type;\n-    tree name, checksum, arcs;\n-    \n-    finfo_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n-    name = build_decl (FIELD_DECL, NULL_TREE, string_type);\n-    checksum = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n-    TREE_CHAIN (checksum) = name;\n-    arcs = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n-    TREE_CHAIN (arcs) = checksum;\n-    finish_builtin_struct (finfo_type, \"__function_info\",\n-\t\t\t   arcs, NULL_TREE);\n-    finfo_ptr_type = build_pointer_type\n-      (build_qualified_type (finfo_type, TYPE_QUAL_CONST));\n-    \n-    for (item = functions_head; item != 0; item = item->next, num_nodes++)\n-      {\n-\tsize_t name_len = strlen (item->name);\n-\ttree finfo_value = NULL_TREE;\n-\ttree fname = build_string (name_len + 1, item->name);\n-\t\n-\tTREE_TYPE (fname) = build_array_type\n-\t  (char_type_node, build_index_type (build_int_2 (name_len, 0)));\n-\tfinfo_value = tree_cons (name, build1\n-\t\t\t\t (ADDR_EXPR, string_type,\n-\t\t\t\t  fname), finfo_value);\n-\tfinfo_value = tree_cons (checksum, convert\n-\t\t\t\t (unsigned_type_node,\n-\t\t\t\t  build_int_2 (item->cfg_checksum, 0)),\n-\t\t\t\t finfo_value);\n-\tfinfo_value = tree_cons (arcs, convert\n-\t\t\t\t (unsigned_type_node,\n-\t\t\t\t  build_int_2 (item->count_edges, 0)),\n-\t\t\t\t finfo_value);\n-\tarray_value = tree_cons (NULL_TREE, build\n-\t\t\t\t (CONSTRUCTOR, finfo_type, NULL_TREE,\n-\t\t\t\t  nreverse (finfo_value)), array_value);\n-      }\n-\n-    /* Create constructor for array.  */\n-    if (num_nodes)\n-      {\n-\ttree array_type;\n-\n-\tarray_type = build_array_type (finfo_type, build_index_type\n-\t\t\t\t       (build_int_2 (num_nodes - 1, 0)));\n-\tarray_value = build (CONSTRUCTOR, array_type,\n-\t\t\t     NULL_TREE, nreverse (array_value));\n-\tarray_value = build1\n-\t  (ADDR_EXPR, finfo_ptr_type, array_value);\n-      }\n-    else\n-      array_value = null_pointer_node;\n-    \n-    field = build_decl (FIELD_DECL, NULL_TREE, finfo_ptr_type);\n-    TREE_CHAIN (field) = fields;\n-    fields = field;\n-    value = tree_cons (fields, array_value, value);\n-    \n-    /* number of functions */\n-    field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n-    TREE_CHAIN (field) = fields;\n-    fields = field;\n-    value = tree_cons (fields, convert (unsigned_type_node, build_int_2\n-\t\t\t\t\t(num_nodes, 0)), value);\n-  }\n-  \n-  /* arc count table */\n-  {\n-    tree counts_table = null_pointer_node;\n-    \n-    if (profile_info.count_instrumented_edges)\n-      {\n-\ttree gcov_type_array_type\n-\t  = build_array_type (gcov_type, build_index_type\n-\t\t\t      (build_int_2 (profile_info.\n-\t\t\t\t\t    count_instrumented_edges - 1, 0)));\n-\t/* No values.  */\n-\tcounts_table\n-\t  = build (VAR_DECL, gcov_type_array_type, NULL_TREE, NULL_TREE);\n-\tTREE_STATIC (counts_table) = 1;\n-\tDECL_NAME (counts_table) = get_identifier (XSTR (profiler_label, 0));\n-\tassemble_variable (counts_table, 0, 0, 0);\n-\tcounts_table = build1 (ADDR_EXPR, gcov_ptr_type, counts_table);\n-      }\n+  function_info_fields = build_function_info_fields ();\n+  function_info_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+  finish_builtin_struct (function_info_type, \"__function_info\",\n+\t\t\t function_info_fields, NULL_TREE);\n+  function_info_ptr_type =\n+\t  build_pointer_type\n+\t  \t(build_qualified_type (function_info_type,\n+\t\t\t\t       TYPE_QUAL_CONST));\n+  field = build_decl (FIELD_DECL, NULL_TREE, function_info_ptr_type);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n     \n-    field = build_decl (FIELD_DECL, NULL_TREE, gcov_ptr_type);\n-    TREE_CHAIN (field) = fields;\n-    fields = field;\n-    value = tree_cons (fields, counts_table, value);\n-  }\n-  \n-  /* number of arc counts */\n+  /* n_counter_sections  */\n   field = build_decl (FIELD_DECL, NULL_TREE, unsigned_type_node);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n-  value = tree_cons (fields, convert\n-\t\t     (unsigned_type_node,\n-\t\t      build_int_2 (profile_info\n-\t\t\t\t   .count_instrumented_edges, 0)),\n+  \n+  /* counter sections */\n+  counter_section_data_fields = build_counter_section_data_fields ();\n+  counter_section_data_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+  finish_builtin_struct (counter_section_data_type, \"__counter_section_data\",\n+\t\t\t counter_section_data_fields, NULL_TREE);\n+  counter_section_data_ptr_type =\n+\t  build_pointer_type\n+\t  \t(build_qualified_type (counter_section_data_type,\n+\t\t\t\t       TYPE_QUAL_CONST));\n+  field = build_decl (FIELD_DECL, NULL_TREE, counter_section_data_ptr_type);\n+  TREE_CHAIN (field) = fields;\n+  fields = field;\n+\n+  return fields;\n+}\n+\n+/* Creates struct gcov_info value (in gcov-io.h).  */\n+static tree\n+build_gcov_info_value ()\n+{\n+  tree value = NULL_TREE;\n+  tree filename_string;\n+  char *filename;\n+  int filename_len;\n+  unsigned n_functions, i;\n+  struct function_list *item;\n+  tree string_type =\n+\t  build_pointer_type (build_qualified_type (char_type_node,\n+\t\t\t\t\t\t    TYPE_QUAL_CONST));\n+  tree function_info_fields, function_info_type, function_info_ptr_type;\n+  tree functions;\n+  tree counter_section_data_fields, counter_section_data_type;\n+  tree counter_section_data_ptr_type, counter_sections;\n+\n+  /* Version ident */\n+  value = tree_cons (NULL_TREE,\n+\t\t     convert (long_unsigned_type_node,\n+\t\t\t      build_int_2 (GCOV_VERSION, 0)),\n+\t\t     value);\n+\n+  /* next -- NULL */\n+  value = tree_cons (NULL_TREE, null_pointer_node, value);\n+  \n+  /* Filename */\n+  filename = getpwd ();\n+  filename = (filename && da_file_name[0] != '/'\n+\t      ? concat (filename, \"/\", da_file_name, NULL)\n+\t      : da_file_name);\n+  filename_len = strlen (filename);\n+  filename_string = build_string (filename_len + 1, filename);\n+  if (filename != da_file_name)\n+    free (filename);\n+  TREE_TYPE (filename_string) =\n+\t  build_array_type (char_type_node,\n+\t\t\t    build_index_type (build_int_2 (filename_len, 0)));\n+  value = tree_cons (NULL_TREE,\n+\t\t     build1 (ADDR_EXPR,\n+\t\t\t     string_type,\n+\t\t       \t     filename_string),\n+\t\t     value);\n+  \n+  /* Workspace */\n+  value = tree_cons (NULL_TREE,\n+\t\t     convert (long_integer_type_node, integer_zero_node),\n+\t\t     value);\n+      \n+  /* number of functions */\n+  n_functions = 0;\n+  for (item = functions_head; item != 0; item = item->next, n_functions++)\n+    continue;\n+  value = tree_cons (NULL_TREE,\n+\t\t     convert (unsigned_type_node,\n+\t\t\t      build_int_2 (n_functions, 0)),\n \t\t     value);\n+\n+  /* function_info table */\n+  function_info_fields = build_function_info_fields ();\n+  function_info_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+  function_info_ptr_type =\n+\t  build_pointer_type (\n+\t\tbuild_qualified_type (function_info_type,\n+\t       \t\t\t      TYPE_QUAL_CONST));\n+  functions = NULL_TREE;\n+  for (item = functions_head; item != 0; item = item->next)\n+    {\n+      tree function_info_value = build_function_info_value (item);\n+      set_purpose (function_info_value, function_info_fields);\n+      functions = tree_cons (NULL_TREE,\n+    \t\t\t     build (CONSTRUCTOR,\n+\t\t\t    \t    function_info_type,\n+\t\t\t\t    NULL_TREE,\n+\t\t\t\t    nreverse (function_info_value)),\n+\t\t\t     functions);\n+    }\n+  finish_builtin_struct (function_info_type, \"__function_info\",\n+\t\t\t function_info_fields, NULL_TREE);\n+\n+  /* Create constructor for array.  */\n+  if (n_functions)\n+    {\n+      tree array_type;\n+\n+      array_type = build_array_type (\n+\t\t\tfunction_info_type,\n+   \t\t\tbuild_index_type (build_int_2 (n_functions - 1, 0)));\n+      functions = build (CONSTRUCTOR,\n+      \t\t\t array_type,\n+\t\t\t NULL_TREE,\n+\t\t\t nreverse (functions));\n+      functions = build1 (ADDR_EXPR,\n+\t\t\t  function_info_ptr_type,\n+\t\t\t  functions);\n+    }\n+  else\n+    functions = null_pointer_node;\n+\n+  value = tree_cons (NULL_TREE, functions, value);\n+\n+  /* n_counter_sections  */\n+  value = tree_cons (NULL_TREE,\n+\t\t     convert (unsigned_type_node,\n+\t\t\t      build_int_2 (profile_info.n_sections, 0)),\n+\t\t     value);\n+  \n+  /* counter sections */\n+  counter_section_data_fields = build_counter_section_data_fields ();\n+  counter_section_data_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+  counter_sections = NULL_TREE;\n+  for (i = 0; i < profile_info.n_sections; i++)\n+    {\n+      tree counter_sections_value =\n+\t      build_counter_section_data_value (\n+\t\tprofile_info.section_info[i].tag,\n+\t\tprofile_info.section_info[i].n_counters);\n+      set_purpose (counter_sections_value, counter_section_data_fields);\n+      counter_sections = tree_cons (NULL_TREE,\n+\t\t       \t\t    build (CONSTRUCTOR,\n+\t\t       \t\t\t   counter_section_data_type,\n+\t\t       \t\t\t   NULL_TREE,\n+\t\t       \t\t\t   nreverse (counter_sections_value)),\n+\t\t       \t\t    counter_sections);\n+    }\n+  finish_builtin_struct (counter_section_data_type, \"__counter_section_data\",\n+\t\t\t counter_section_data_fields, NULL_TREE);\n+  counter_section_data_ptr_type =\n+\t  build_pointer_type\n+\t  \t(build_qualified_type (counter_section_data_type,\n+\t\t\t\t       TYPE_QUAL_CONST));\n+\n+  if (profile_info.n_sections)\n+    {\n+      counter_sections =\n+    \t      build (CONSTRUCTOR,\n+    \t\t     build_array_type (\n+\t       \t\t\t       counter_section_data_type,\n+\t\t       \t\t       build_index_type (build_int_2 (profile_info.n_sections - 1, 0))),\n+\t\t     NULL_TREE,\n+\t\t     nreverse (counter_sections));\n+      counter_sections = build1 (ADDR_EXPR,\n+\t\t\t\t counter_section_data_ptr_type,\n+\t\t\t\t counter_sections);\n+    }\n+  else\n+    counter_sections = null_pointer_node;\n+  value = tree_cons (NULL_TREE, counter_sections, value);\n+\n+  return value;\n+}\n+\n+/* Write out the structure which libgcc uses to locate all the arc\n+   counters.  The structures used here must match those defined in\n+   gcov-io.h.  Write out the constructor to call __gcov_init.  */\n+\n+void\n+create_profiler ()\n+{\n+  tree gcov_info_fields, gcov_info_type, gcov_info_value, gcov_info;\n+  char name[20];\n+  char *ctor_name;\n+  tree ctor;\n+  rtx gcov_info_address;\n+  int save_flag_inline_functions = flag_inline_functions;\n+  unsigned i;\n+\n+  for (i = 0; i < profile_info.n_sections; i++)\n+    if (profile_info.section_info[i].n_counters_now)\n+      break;\n+  if (i == profile_info.n_sections)\n+    return;\n   \n-  finish_builtin_struct (ginfo_type, \"__gcov_info\", fields, NULL_TREE);\n-  structure = build (VAR_DECL, ginfo_type, NULL_TREE, NULL_TREE);\n-  DECL_INITIAL (structure)\n-    = build (CONSTRUCTOR, ginfo_type, NULL_TREE, nreverse (value));\n-  TREE_STATIC (structure) = 1;\n+  gcov_info_type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+  gcov_info_fields = build_gcov_info_fields (gcov_info_type);\n+  gcov_info_value = build_gcov_info_value ();\n+  set_purpose (gcov_info_value, gcov_info_fields);\n+  finish_builtin_struct (gcov_info_type, \"__gcov_info\",\n+\t\t\t gcov_info_fields, NULL_TREE);\n+\n+  gcov_info = build (VAR_DECL, gcov_info_type, NULL_TREE, NULL_TREE);\n+  DECL_INITIAL (gcov_info) =\n+\t  build (CONSTRUCTOR, gcov_info_type, NULL_TREE,\n+\t\t nreverse (gcov_info_value));\n+\n+  TREE_STATIC (gcov_info) = 1;\n   ASM_GENERATE_INTERNAL_LABEL (name, \"LPBX\", 0);\n-  DECL_NAME (structure) = get_identifier (name);\n+  DECL_NAME (gcov_info) = get_identifier (name);\n   \n   /* Build structure.  */\n-  assemble_variable (structure, 0, 0, 0);\n+  assemble_variable (gcov_info, 0, 0, 0);\n \n   /* Build the constructor function to invoke __gcov_init.  */\n   ctor_name = concat (IDENTIFIER_POINTER (get_file_function_name ('I')),\n@@ -1696,12 +2100,14 @@ create_profiler ()\n   cfun->arc_profile = 0;\n \n   /* Actually generate the code to call __gcov_init.  */\n-  structure_address = force_reg (Pmode, gen_rtx_SYMBOL_REF\n-\t\t\t\t (Pmode, IDENTIFIER_POINTER\n-\t\t\t\t  (DECL_NAME (structure))));\n+  gcov_info_address = force_reg (Pmode,\n+\t\t\t\t gen_rtx_SYMBOL_REF (\n+\t\t\t\t\tPmode,\n+\t\t\t\t\tIDENTIFIER_POINTER (\n+\t\t\t\t\t\tDECL_NAME (gcov_info))));\n   emit_library_call (gen_rtx_SYMBOL_REF (Pmode, \"__gcov_init\"),\n \t\t     LCT_NORMAL, VOIDmode, 1,\n-\t\t     structure_address, Pmode);\n+\t\t     gcov_info_address, Pmode);\n \n   expand_function_end (input_filename, lineno, 0);\n   (*lang_hooks.decls.poplevel) (1, 0, 1);"}, {"sha": "5d681e8f5db9ec14b7ecbb4f1a91ff61e8f8912a", "filename": "gcc/profile.h", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb9e4555c10ea2b918d7cee80ebde29887e652bb/gcc%2Fprofile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb9e4555c10ea2b918d7cee80ebde29887e652bb/gcc%2Fprofile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.h?ref=cb9e4555c10ea2b918d7cee80ebde29887e652bb", "patch": "@@ -21,18 +21,25 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #ifndef GCC_PROFILE_H\n #define GCC_PROFILE_H\n \n+/* The number of different counter sections.  */\n+#define MAX_COUNTER_SECTIONS\t1\n+\n+/* Info about number of counters in the section.  */\n+struct section_info\n+{\n+  unsigned tag;\t\t/* Section tag.  */\n+  int present;\t\t/* Are the data from this section read into gcc?  */\n+  int n_counters;\t/* Total number of counters.  */\n+  int n_counters_now;\t/* Number of counters in the current function.  */\n+};\n+\n struct profile_info\n   {\n-    /* Used by final, for allocating the proper amount of storage for the\n-       instrumented arc execution counts.  */\n-\n-    int count_instrumented_edges;\n-\n-    /* Used by final, for writing correct # of instrumented edges\n-       in this function.  */\n-\n-    int count_edges_instrumented_now;\n-\n+    /* Information about numbers of counters in counter sections, for\n+       allocating the storage and storing the sizes.  */\n+    unsigned n_sections;\n+    struct section_info section_info[MAX_COUNTER_SECTIONS];\n+    \n     /* Checksum of the cfg. Used for 'identification' of code.\n        Used by final.  */\n \n@@ -46,9 +53,10 @@ struct profile_info\n     /* The number of profiles merged to form the profile data for the current\n        function.  */\n     int count_profiles_merged;\n-\n   };\n \n extern struct profile_info profile_info;\n \n+struct section_info *find_counters_section\tPARAMS ((unsigned));\n+\n #endif"}]}