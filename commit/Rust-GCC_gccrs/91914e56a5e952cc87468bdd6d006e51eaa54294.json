{"sha": "91914e56a5e952cc87468bdd6d006e51eaa54294", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE5MTRlNTZhNWU5NTJjYzg3NDY4YmRkNmQwMDZlNTFlYWE1NDI5NA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-20T12:54:28Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-20T12:54:28Z"}, "message": "poly_int: SUBREG_BYTE\n\nThis patch changes SUBREG_BYTE from an int to a poly_int.\nSince valid SUBREG_BYTEs must be contained within the mode of the\nSUBREG_REG, the required range is the same as for GET_MODE_SIZE,\ni.e. unsigned short.  The patch therefore uses poly_uint16(_pod)\nfor the SUBREG_BYTE.\n\nUsing poly_uint16_pod rtx fields requires a new field code ('p').\nSince there are no other uses of 'p' besides SUBREG_BYTE, the patch\ndoesn't add an XPOLY or whatever; all uses should go via SUBREG_BYTE\ninstead.\n\nThe patch doesn't bother implementing 'p' support for legacy\ndefine_peepholes, since none of the remaining ones have subregs\nin their patterns.\n\nAs it happened, the rtl documentation used SUBREG as an example of a\ncode with mixed field types, accessed via XEXP (x, 0) and XINT (x, 1).\nSince there's no direct replacement for XINT, and since people should\nnever use it even if there were, the patch changes the example to use\nINT_LIST instead.\n\nThe patch also changes subreg-related helper functions so that they too\ntake and return polynomial offsets.  This makes the patch quite big, but\nit's mostly mechanical.  The patch generally sticks to existing choices\nwrt signedness.\n\n2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* doc/rtl.texi: Update documentation of SUBREG_BYTE.  Document the\n\t'p' format code.  Use INT_LIST rather than SUBREG as the example of\n\ta code with an XINT and an XEXP.  Remove the implication that\n\taccessing an rtx field using XINT is expected to work.\n\t* rtl.def (SUBREG): Change format from \"ei\" to \"ep\".\n\t* rtl.h (rtunion::rt_subreg): New field.\n\t(XCSUBREG): New macro.\n\t(SUBREG_BYTE): Use it.\n\t(subreg_shape): Change offset from an unsigned int to a poly_uint16.\n\tUpdate constructor accordingly.\n\t(subreg_shape::operator ==): Update accordingly.\n\t(subreg_shape::unique_id): Return an unsigned HOST_WIDE_INT rather\n\tthan an unsigned int.\n\t(subreg_lsb, subreg_lowpart_offset, subreg_highpart_offset): Return\n\ta poly_uint64 rather than an unsigned int.\n\t(subreg_lsb_1): Likewise.  Take the offset as a poly_uint64 rather\n\tthan an unsigned int.\n\t(subreg_size_offset_from_lsb, subreg_size_lowpart_offset)\n\t(subreg_size_highpart_offset): Return a poly_uint64 rather than\n\tan unsigned int.  Take the sizes as poly_uint64s.\n\t(subreg_offset_from_lsb): Return a poly_uint64 rather than\n\tan unsigned int.  Take the shift as a poly_uint64 rather than\n\tan unsigned int.\n\t(subreg_regno_offset, subreg_offset_representable_p): Take the offset\n\tas a poly_uint64 rather than an unsigned int.\n\t(simplify_subreg_regno): Likewise.\n\t(byte_lowpart_offset): Return the memory offset as a poly_int64\n\trather than an int.\n\t(subreg_memory_offset): Likewise.  Take the subreg offset as a\n\tpoly_uint64 rather than an unsigned int.\n\t(simplify_subreg, simplify_gen_subreg, subreg_get_info)\n\t(gen_rtx_SUBREG, validate_subreg): Take the subreg offset as a\n\tpoly_uint64 rather than an unsigned int.\n\t* rtl.c (rtx_format): Describe 'p' in comment.\n\t(copy_rtx, rtx_equal_p_cb, rtx_equal_p): Handle 'p'.\n\t* emit-rtl.c (validate_subreg, gen_rtx_SUBREG): Take the subreg\n\toffset as a poly_uint64 rather than an unsigned int.\n\t(byte_lowpart_offset): Return the memory offset as a poly_int64\n\trather than an int.\n\t(subreg_memory_offset): Likewise.  Take the subreg offset as a\n\tpoly_uint64 rather than an unsigned int.\n\t(subreg_size_lowpart_offset, subreg_size_highpart_offset): Take the\n\tmode sizes as poly_uint64s rather than unsigned ints.  Return a\n\tpoly_uint64 rather than an unsigned int.\n\t(subreg_lowpart_p): Treat subreg offsets as poly_ints.\n\t(copy_insn_1): Handle 'p'.\n\t* rtlanal.c (set_noop_p): Treat subregs offsets as poly_uint64s.\n\t(subreg_lsb_1): Take the subreg offset as a poly_uint64 rather than\n\tan unsigned int.  Return the shift in the same way.\n\t(subreg_lsb): Return the shift as a poly_uint64 rather than an\n\tunsigned int.\n\t(subreg_size_offset_from_lsb): Take the sizes and shift as\n\tpoly_uint64s rather than unsigned ints.  Return the offset as\n\ta poly_uint64.\n\t(subreg_get_info, subreg_regno_offset, subreg_offset_representable_p)\n\t(simplify_subreg_regno): Take the offset as a poly_uint64 rather than\n\tan unsigned int.\n\t* rtlhash.c (add_rtx): Handle 'p'.\n\t* genemit.c (gen_exp): Likewise.\n\t* gengenrtl.c (type_from_format, gendef): Likewise.\n\t* gensupport.c (subst_pattern_match, get_alternatives_number)\n\t(collect_insn_data, alter_predicate_for_insn, alter_constraints)\n\t(subst_dup): Likewise.\n\t* gengtype.c (adjust_field_rtx_def): Likewise.\n\t* genrecog.c (find_operand, find_matching_operand, validate_pattern)\n\t(match_pattern_2): Likewise.\n\t(rtx_test::SUBREG_FIELD): New rtx_test::kind_enum.\n\t(rtx_test::subreg_field): New function.\n\t(operator ==, safe_to_hoist_p, transition_parameter_type)\n\t(print_nonbool_test, print_test): Handle SUBREG_FIELD.\n\t* genattrtab.c (attr_rtx_1): Say that 'p' is deliberately not handled.\n\t* genpeep.c (match_rtx): Likewise.\n\t* print-rtl.c (print_poly_int): Include if GENERATOR_FILE too.\n\t(rtx_writer::print_rtx_operand): Handle 'p'.\n\t(print_value): Handle SUBREG.\n\t* read-rtl.c (apply_int_iterator): Likewise.\n\t(rtx_reader::read_rtx_operand): Handle 'p'.\n\t* alias.c (rtx_equal_for_memref_p): Likewise.\n\t* cselib.c (rtx_equal_for_cselib_1, cselib_hash_rtx): Likewise.\n\t* caller-save.c (replace_reg_with_saved_mem): Treat subreg offsets\n\tas poly_ints.\n\t* calls.c (expand_call): Likewise.\n\t* combine.c (combine_simplify_rtx, expand_field_assignment): Likewise.\n\t(make_extraction, gen_lowpart_for_combine): Likewise.\n\t* loop-invariant.c (hash_invariant_expr_1, invariant_expr_equal_p):\n\tLikewise.\n\t* cse.c (remove_invalid_subreg_refs): Take the offset as a poly_uint64\n\trather than an unsigned int.  Treat subreg offsets as poly_ints.\n\t(exp_equiv_p): Handle 'p'.\n\t(hash_rtx_cb): Likewise.  Treat subreg offsets as poly_ints.\n\t(equiv_constant, cse_insn): Treat subreg offsets as poly_ints.\n\t* dse.c (find_shift_sequence): Likewise.\n\t* dwarf2out.c (rtl_for_decl_location): Likewise.\n\t* expmed.c (extract_low_bits): Likewise.\n\t* expr.c (emit_group_store, undefined_operand_subword_p): Likewise.\n\t(expand_expr_real_2): Likewise.\n\t* final.c (alter_subreg): Likewise.\n\t(leaf_renumber_regs_insn): Handle 'p'.\n\t* function.c (assign_parm_find_stack_rtl, assign_parm_setup_stack):\n\tTreat subreg offsets as poly_ints.\n\t* fwprop.c (forward_propagate_and_simplify): Likewise.\n\t* ifcvt.c (noce_emit_move_insn, noce_emit_cmove): Likewise.\n\t* ira.c (get_subreg_tracking_sizes): Likewise.\n\t* ira-conflicts.c (go_through_subreg): Likewise.\n\t* ira-lives.c (process_single_reg_class_operands): Likewise.\n\t* jump.c (rtx_renumbered_equal_p): Likewise.  Handle 'p'.\n\t* lower-subreg.c (simplify_subreg_concatn): Take the subreg offset\n\tas a poly_uint64 rather than an unsigned int.\n\t(simplify_gen_subreg_concatn, resolve_simple_move): Treat\n\tsubreg offsets as poly_ints.\n\t* lra-constraints.c (operands_match_p): Handle 'p'.\n\t(match_reload, curr_insn_transform): Treat subreg offsets as poly_ints.\n\t* lra-spills.c (assign_mem_slot): Likewise.\n\t* postreload.c (move2add_valid_value_p): Likewise.\n\t* recog.c (general_operand, indirect_operand): Likewise.\n\t* regcprop.c (copy_value, maybe_mode_change): Likewise.\n\t(copyprop_hardreg_forward_1): Likewise.\n\t* reginfo.c (simplifiable_subregs_hasher::hash, simplifiable_subregs)\n\t(record_subregs_of_mode): Likewise.\n\t* rtlhooks.c (gen_lowpart_general, gen_lowpart_if_possible): Likewise.\n\t* reload.c (operands_match_p): Handle 'p'.\n\t(find_reloads_subreg_address): Treat subreg offsets as poly_ints.\n\t* reload1.c (alter_reg, choose_reload_regs): Likewise.\n\t(compute_reload_subreg_offset): Likewise, and return an poly_int64.\n\t* simplify-rtx.c (simplify_truncation, simplify_binary_operation_1):\n\t(test_vector_ops_duplicate): Treat subreg offsets as poly_ints.\n\t(simplify_const_poly_int_tests<N>::run): Likewise.\n\t(simplify_subreg, simplify_gen_subreg): Take the subreg offset as\n\ta poly_uint64 rather than an unsigned int.\n\t* valtrack.c (debug_lowpart_subreg): Likewise.\n\t* var-tracking.c (var_lowpart): Likewise.\n\t(loc_cmp): Handle 'p'.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255882", "tree": {"sha": "bd8f6dfd41592b49da05616444cddb8a72b5109f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd8f6dfd41592b49da05616444cddb8a72b5109f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91914e56a5e952cc87468bdd6d006e51eaa54294", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91914e56a5e952cc87468bdd6d006e51eaa54294", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91914e56a5e952cc87468bdd6d006e51eaa54294", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91914e56a5e952cc87468bdd6d006e51eaa54294/comments", "author": null, "committer": null, "parents": [{"sha": "9dcf1f868c048e20c72df7ee5d378625d1e77bc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9dcf1f868c048e20c72df7ee5d378625d1e77bc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9dcf1f868c048e20c72df7ee5d378625d1e77bc8"}], "stats": {"total": 895, "additions": 608, "deletions": 287}, "files": [{"sha": "ad7ee7e6ca303599bfc1fa2a38a73ddb29569100", "filename": "gcc/ChangeLog", "status": "modified", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -1,3 +1,140 @@\n+2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* doc/rtl.texi: Update documentation of SUBREG_BYTE.  Document the\n+\t'p' format code.  Use INT_LIST rather than SUBREG as the example of\n+\ta code with an XINT and an XEXP.  Remove the implication that\n+\taccessing an rtx field using XINT is expected to work.\n+\t* rtl.def (SUBREG): Change format from \"ei\" to \"ep\".\n+\t* rtl.h (rtunion::rt_subreg): New field.\n+\t(XCSUBREG): New macro.\n+\t(SUBREG_BYTE): Use it.\n+\t(subreg_shape): Change offset from an unsigned int to a poly_uint16.\n+\tUpdate constructor accordingly.\n+\t(subreg_shape::operator ==): Update accordingly.\n+\t(subreg_shape::unique_id): Return an unsigned HOST_WIDE_INT rather\n+\tthan an unsigned int.\n+\t(subreg_lsb, subreg_lowpart_offset, subreg_highpart_offset): Return\n+\ta poly_uint64 rather than an unsigned int.\n+\t(subreg_lsb_1): Likewise.  Take the offset as a poly_uint64 rather\n+\tthan an unsigned int.\n+\t(subreg_size_offset_from_lsb, subreg_size_lowpart_offset)\n+\t(subreg_size_highpart_offset): Return a poly_uint64 rather than\n+\tan unsigned int.  Take the sizes as poly_uint64s.\n+\t(subreg_offset_from_lsb): Return a poly_uint64 rather than\n+\tan unsigned int.  Take the shift as a poly_uint64 rather than\n+\tan unsigned int.\n+\t(subreg_regno_offset, subreg_offset_representable_p): Take the offset\n+\tas a poly_uint64 rather than an unsigned int.\n+\t(simplify_subreg_regno): Likewise.\n+\t(byte_lowpart_offset): Return the memory offset as a poly_int64\n+\trather than an int.\n+\t(subreg_memory_offset): Likewise.  Take the subreg offset as a\n+\tpoly_uint64 rather than an unsigned int.\n+\t(simplify_subreg, simplify_gen_subreg, subreg_get_info)\n+\t(gen_rtx_SUBREG, validate_subreg): Take the subreg offset as a\n+\tpoly_uint64 rather than an unsigned int.\n+\t* rtl.c (rtx_format): Describe 'p' in comment.\n+\t(copy_rtx, rtx_equal_p_cb, rtx_equal_p): Handle 'p'.\n+\t* emit-rtl.c (validate_subreg, gen_rtx_SUBREG): Take the subreg\n+\toffset as a poly_uint64 rather than an unsigned int.\n+\t(byte_lowpart_offset): Return the memory offset as a poly_int64\n+\trather than an int.\n+\t(subreg_memory_offset): Likewise.  Take the subreg offset as a\n+\tpoly_uint64 rather than an unsigned int.\n+\t(subreg_size_lowpart_offset, subreg_size_highpart_offset): Take the\n+\tmode sizes as poly_uint64s rather than unsigned ints.  Return a\n+\tpoly_uint64 rather than an unsigned int.\n+\t(subreg_lowpart_p): Treat subreg offsets as poly_ints.\n+\t(copy_insn_1): Handle 'p'.\n+\t* rtlanal.c (set_noop_p): Treat subregs offsets as poly_uint64s.\n+\t(subreg_lsb_1): Take the subreg offset as a poly_uint64 rather than\n+\tan unsigned int.  Return the shift in the same way.\n+\t(subreg_lsb): Return the shift as a poly_uint64 rather than an\n+\tunsigned int.\n+\t(subreg_size_offset_from_lsb): Take the sizes and shift as\n+\tpoly_uint64s rather than unsigned ints.  Return the offset as\n+\ta poly_uint64.\n+\t(subreg_get_info, subreg_regno_offset, subreg_offset_representable_p)\n+\t(simplify_subreg_regno): Take the offset as a poly_uint64 rather than\n+\tan unsigned int.\n+\t* rtlhash.c (add_rtx): Handle 'p'.\n+\t* genemit.c (gen_exp): Likewise.\n+\t* gengenrtl.c (type_from_format, gendef): Likewise.\n+\t* gensupport.c (subst_pattern_match, get_alternatives_number)\n+\t(collect_insn_data, alter_predicate_for_insn, alter_constraints)\n+\t(subst_dup): Likewise.\n+\t* gengtype.c (adjust_field_rtx_def): Likewise.\n+\t* genrecog.c (find_operand, find_matching_operand, validate_pattern)\n+\t(match_pattern_2): Likewise.\n+\t(rtx_test::SUBREG_FIELD): New rtx_test::kind_enum.\n+\t(rtx_test::subreg_field): New function.\n+\t(operator ==, safe_to_hoist_p, transition_parameter_type)\n+\t(print_nonbool_test, print_test): Handle SUBREG_FIELD.\n+\t* genattrtab.c (attr_rtx_1): Say that 'p' is deliberately not handled.\n+\t* genpeep.c (match_rtx): Likewise.\n+\t* print-rtl.c (print_poly_int): Include if GENERATOR_FILE too.\n+\t(rtx_writer::print_rtx_operand): Handle 'p'.\n+\t(print_value): Handle SUBREG.\n+\t* read-rtl.c (apply_int_iterator): Likewise.\n+\t(rtx_reader::read_rtx_operand): Handle 'p'.\n+\t* alias.c (rtx_equal_for_memref_p): Likewise.\n+\t* cselib.c (rtx_equal_for_cselib_1, cselib_hash_rtx): Likewise.\n+\t* caller-save.c (replace_reg_with_saved_mem): Treat subreg offsets\n+\tas poly_ints.\n+\t* calls.c (expand_call): Likewise.\n+\t* combine.c (combine_simplify_rtx, expand_field_assignment): Likewise.\n+\t(make_extraction, gen_lowpart_for_combine): Likewise.\n+\t* loop-invariant.c (hash_invariant_expr_1, invariant_expr_equal_p):\n+\tLikewise.\n+\t* cse.c (remove_invalid_subreg_refs): Take the offset as a poly_uint64\n+\trather than an unsigned int.  Treat subreg offsets as poly_ints.\n+\t(exp_equiv_p): Handle 'p'.\n+\t(hash_rtx_cb): Likewise.  Treat subreg offsets as poly_ints.\n+\t(equiv_constant, cse_insn): Treat subreg offsets as poly_ints.\n+\t* dse.c (find_shift_sequence): Likewise.\n+\t* dwarf2out.c (rtl_for_decl_location): Likewise.\n+\t* expmed.c (extract_low_bits): Likewise.\n+\t* expr.c (emit_group_store, undefined_operand_subword_p): Likewise.\n+\t(expand_expr_real_2): Likewise.\n+\t* final.c (alter_subreg): Likewise.\n+\t(leaf_renumber_regs_insn): Handle 'p'.\n+\t* function.c (assign_parm_find_stack_rtl, assign_parm_setup_stack):\n+\tTreat subreg offsets as poly_ints.\n+\t* fwprop.c (forward_propagate_and_simplify): Likewise.\n+\t* ifcvt.c (noce_emit_move_insn, noce_emit_cmove): Likewise.\n+\t* ira.c (get_subreg_tracking_sizes): Likewise.\n+\t* ira-conflicts.c (go_through_subreg): Likewise.\n+\t* ira-lives.c (process_single_reg_class_operands): Likewise.\n+\t* jump.c (rtx_renumbered_equal_p): Likewise.  Handle 'p'.\n+\t* lower-subreg.c (simplify_subreg_concatn): Take the subreg offset\n+\tas a poly_uint64 rather than an unsigned int.\n+\t(simplify_gen_subreg_concatn, resolve_simple_move): Treat\n+\tsubreg offsets as poly_ints.\n+\t* lra-constraints.c (operands_match_p): Handle 'p'.\n+\t(match_reload, curr_insn_transform): Treat subreg offsets as poly_ints.\n+\t* lra-spills.c (assign_mem_slot): Likewise.\n+\t* postreload.c (move2add_valid_value_p): Likewise.\n+\t* recog.c (general_operand, indirect_operand): Likewise.\n+\t* regcprop.c (copy_value, maybe_mode_change): Likewise.\n+\t(copyprop_hardreg_forward_1): Likewise.\n+\t* reginfo.c (simplifiable_subregs_hasher::hash, simplifiable_subregs)\n+\t(record_subregs_of_mode): Likewise.\n+\t* rtlhooks.c (gen_lowpart_general, gen_lowpart_if_possible): Likewise.\n+\t* reload.c (operands_match_p): Handle 'p'.\n+\t(find_reloads_subreg_address): Treat subreg offsets as poly_ints.\n+\t* reload1.c (alter_reg, choose_reload_regs): Likewise.\n+\t(compute_reload_subreg_offset): Likewise, and return an poly_int64.\n+\t* simplify-rtx.c (simplify_truncation, simplify_binary_operation_1):\n+\t(test_vector_ops_duplicate): Treat subreg offsets as poly_ints.\n+\t(simplify_const_poly_int_tests<N>::run): Likewise.\n+\t(simplify_subreg, simplify_gen_subreg): Take the subreg offset as\n+\ta poly_uint64 rather than an unsigned int.\n+\t* valtrack.c (debug_lowpart_subreg): Likewise.\n+\t* var-tracking.c (var_lowpart): Likewise.\n+\t(loc_cmp): Handle 'p'.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "16f82240174e787d0fbac512556ec8d9cc79215e", "filename": "gcc/alias.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -1833,6 +1833,11 @@ rtx_equal_for_memref_p (const_rtx x, const_rtx y)\n \t    return 0;\n \t  break;\n \n+\tcase 'p':\n+\t  if (maybe_ne (SUBREG_BYTE (x), SUBREG_BYTE (y)))\n+\t    return 0;\n+\t  break;\n+\n \tcase 'E':\n \t  /* Two vectors must have the same length.  */\n \t  if (XVECLEN (x, i) != XVECLEN (y, i))"}, {"sha": "da49efeda55f49a46dc576df6cba77b7549fa0ad", "filename": "gcc/caller-save.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -1129,7 +1129,7 @@ replace_reg_with_saved_mem (rtx *loc,\n \t{\n \t  /* This is gen_lowpart_if_possible(), but without validating\n \t     the newly-formed address.  */\n-\t  HOST_WIDE_INT offset = byte_lowpart_offset (mode, GET_MODE (mem));\n+\t  poly_int64 offset = byte_lowpart_offset (mode, GET_MODE (mem));\n \t  mem = adjust_address_nv (mem, mode, offset);\n \t}\n     }"}, {"sha": "5feab3ac1d0b578b17220bf44fec5f45e6b2e6e2", "filename": "gcc/calls.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -4315,8 +4315,8 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t\t\t\t funtype, 1);\n \t  gcc_assert (GET_MODE (target) == pmode);\n \n-\t  unsigned int offset = subreg_lowpart_offset (TYPE_MODE (type),\n-\t\t\t\t\t\t       GET_MODE (target));\n+\t  poly_uint64 offset = subreg_lowpart_offset (TYPE_MODE (type),\n+\t\t\t\t\t\t      GET_MODE (target));\n \t  target = gen_rtx_SUBREG (TYPE_MODE (type), target, offset);\n \t  SUBREG_PROMOTED_VAR_P (target) = 1;\n \t  SUBREG_PROMOTED_SET (target, unsignedp);"}, {"sha": "9f19ee43c74109b0a95a4d4848de6cb09eaf0a81", "filename": "gcc/combine.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -5857,7 +5857,7 @@ combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,\n \n       /* See if this can be moved to simplify_subreg.  */\n       if (CONSTANT_P (SUBREG_REG (x))\n-\t  && subreg_lowpart_offset (mode, op0_mode) == SUBREG_BYTE (x)\n+\t  && known_eq (subreg_lowpart_offset (mode, op0_mode), SUBREG_BYTE (x))\n \t     /* Don't call gen_lowpart if the inner mode\n \t\tis VOIDmode and we cannot simplify it, as SUBREG without\n \t\tinner mode is invalid.  */\n@@ -5881,8 +5881,8 @@ combine_simplify_rtx (rtx x, machine_mode op0_mode, int in_dest,\n \t    && is_a <scalar_int_mode> (op0_mode, &int_op0_mode)\n \t    && (GET_MODE_PRECISION (int_mode)\n \t\t< GET_MODE_PRECISION (int_op0_mode))\n-\t    && (subreg_lowpart_offset (int_mode, int_op0_mode)\n-\t\t== SUBREG_BYTE (x))\n+\t    && known_eq (subreg_lowpart_offset (int_mode, int_op0_mode),\n+\t\t\t SUBREG_BYTE (x))\n \t    && HWI_COMPUTABLE_MODE_P (int_op0_mode)\n \t    && (nonzero_bits (SUBREG_REG (x), int_op0_mode)\n \t\t& GET_MODE_MASK (int_mode)) == 0)\n@@ -7357,7 +7357,8 @@ expand_field_assignment (const_rtx x)\n \t{\n \t  inner = SUBREG_REG (XEXP (SET_DEST (x), 0));\n \t  len = GET_MODE_PRECISION (GET_MODE (XEXP (SET_DEST (x), 0)));\n-\t  pos = GEN_INT (subreg_lsb (XEXP (SET_DEST (x), 0)));\n+\t  pos = gen_int_mode (subreg_lsb (XEXP (SET_DEST (x), 0)),\n+\t\t\t      MAX_MODE_INT);\n \t}\n       else if (GET_CODE (SET_DEST (x)) == ZERO_EXTRACT\n \t       && CONST_INT_P (XEXP (SET_DEST (x), 1)))\n@@ -7606,7 +7607,7 @@ make_extraction (machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n \t\t return a new hard register.  */\n \t      if (pos || in_dest)\n \t\t{\n-\t\t  unsigned int offset\n+\t\t  poly_uint64 offset\n \t\t    = subreg_offset_from_lsb (tmode, inner_mode, pos);\n \n \t\t  /* Avoid creating invalid subregs, for example when\n@@ -11663,7 +11664,7 @@ gen_lowpart_for_combine (machine_mode omode, rtx x)\n       if (paradoxical_subreg_p (omode, imode))\n \treturn gen_rtx_SUBREG (omode, x, 0);\n \n-      HOST_WIDE_INT offset = byte_lowpart_offset (omode, imode);\n+      poly_int64 offset = byte_lowpart_offset (omode, imode);\n       return adjust_address_nv (x, omode, offset);\n     }\n "}, {"sha": "708c3a02bda6031970be1e63c49d6dbb0a70187a", "filename": "gcc/cse.c", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -561,7 +561,7 @@ static struct table_elt *insert (rtx, struct table_elt *, unsigned,\n static void merge_equiv_classes (struct table_elt *, struct table_elt *);\n static void invalidate (rtx, machine_mode);\n static void remove_invalid_refs (unsigned int);\n-static void remove_invalid_subreg_refs (unsigned int, unsigned int,\n+static void remove_invalid_subreg_refs (unsigned int, poly_uint64,\n \t\t\t\t\tmachine_mode);\n static void rehash_using_reg (rtx);\n static void invalidate_memory (void);\n@@ -1994,12 +1994,11 @@ remove_invalid_refs (unsigned int regno)\n /* Likewise for a subreg with subreg_reg REGNO, subreg_byte OFFSET,\n    and mode MODE.  */\n static void\n-remove_invalid_subreg_refs (unsigned int regno, unsigned int offset,\n+remove_invalid_subreg_refs (unsigned int regno, poly_uint64 offset,\n \t\t\t    machine_mode mode)\n {\n   unsigned int i;\n   struct table_elt *p, *next;\n-  unsigned int end = offset + (GET_MODE_SIZE (mode) - 1);\n \n   for (i = 0; i < HASH_SIZE; i++)\n     for (p = table[i]; p; p = next)\n@@ -2011,9 +2010,9 @@ remove_invalid_subreg_refs (unsigned int regno, unsigned int offset,\n \t    && (GET_CODE (exp) != SUBREG\n \t\t|| !REG_P (SUBREG_REG (exp))\n \t\t|| REGNO (SUBREG_REG (exp)) != regno\n-\t\t|| (((SUBREG_BYTE (exp)\n-\t\t      + (GET_MODE_SIZE (GET_MODE (exp)) - 1)) >= offset)\n-\t\t    && SUBREG_BYTE (exp) <= end))\n+\t\t|| ranges_maybe_overlap_p (SUBREG_BYTE (exp),\n+\t\t\t\t\t   GET_MODE_SIZE (GET_MODE (exp)),\n+\t\t\t\t\t   offset, GET_MODE_SIZE (mode)))\n \t    && refers_to_regno_p (regno, p->exp))\n \t  remove_from_table (p, i);\n       }\n@@ -2307,7 +2306,8 @@ hash_rtx_cb (const_rtx x, machine_mode mode,\n \t  {\n \t    hash += (((unsigned int) SUBREG << 7)\n \t\t     + REGNO (SUBREG_REG (x))\n-\t\t     + (SUBREG_BYTE (x) / UNITS_PER_WORD));\n+\t\t     + (constant_lower_bound (SUBREG_BYTE (x))\n+\t\t\t/ UNITS_PER_WORD));\n \t    return hash;\n \t  }\n \tbreak;\n@@ -2526,6 +2526,10 @@ hash_rtx_cb (const_rtx x, machine_mode mode,\n \t  hash += (unsigned int) XINT (x, i);\n \t  break;\n \n+\tcase 'p':\n+\t  hash += constant_lower_bound (SUBREG_BYTE (x));\n+\t  break;\n+\n \tcase '0': case 't':\n \t  /* Unused.  */\n \t  break;\n@@ -2776,6 +2780,11 @@ exp_equiv_p (const_rtx x, const_rtx y, int validate, bool for_gcse)\n \t    return 0;\n \t  break;\n \n+\tcase 'p':\n+\t  if (maybe_ne (SUBREG_BYTE (x), SUBREG_BYTE (y)))\n+\t    return 0;\n+\t  break;\n+\n \tcase '0':\n \tcase 't':\n \t  break;\n@@ -3801,8 +3810,9 @@ equiv_constant (rtx x)\n       if (GET_MODE_SIZE (mode) < GET_MODE_SIZE (word_mode)\n \t  && GET_MODE_SIZE (word_mode) < GET_MODE_SIZE (imode))\n \t{\n-\t  int byte = SUBREG_BYTE (x) - subreg_lowpart_offset (mode, word_mode);\n-\t  if (byte >= 0 && (byte % UNITS_PER_WORD) == 0)\n+\t  poly_int64 byte = (SUBREG_BYTE (x)\n+\t\t\t     - subreg_lowpart_offset (mode, word_mode));\n+\t  if (known_ge (byte, 0) && multiple_p (byte, UNITS_PER_WORD))\n \t    {\n \t      rtx y = gen_rtx_SUBREG (word_mode, SUBREG_REG (x), byte);\n \t      new_rtx = lookup_as_function (y, CONST_INT);\n@@ -6002,7 +6012,7 @@ cse_insn (rtx_insn *insn)\n \t\t  new_src = elt->exp;\n \t\telse\n \t\t  {\n-\t\t    unsigned int byte\n+\t\t    poly_uint64 byte\n \t\t      = subreg_lowpart_offset (new_mode, GET_MODE (dest));\n \t\t    new_src = simplify_gen_subreg (new_mode, elt->exp,\n \t\t\t\t\t           GET_MODE (dest), byte);"}, {"sha": "5a1da98c1fe1e55bc55462d0e2f81fd0e1b20f74", "filename": "gcc/cselib.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -987,6 +987,11 @@ rtx_equal_for_cselib_1 (rtx x, rtx y, machine_mode memmode, int depth)\n \t    return 0;\n \t  break;\n \n+\tcase 'p':\n+\t  if (maybe_ne (SUBREG_BYTE (x), SUBREG_BYTE (y)))\n+\t    return 0;\n+\t  break;\n+\n \tcase 'V':\n \tcase 'E':\n \t  /* Two vectors must have the same length.  */\n@@ -1278,6 +1283,10 @@ cselib_hash_rtx (rtx x, int create, machine_mode memmode)\n \t  hash += XINT (x, i);\n \t  break;\n \n+\tcase 'p':\n+\t  hash += constant_lower_bound (SUBREG_BYTE (x));\n+\t  break;\n+\n \tcase '0':\n \tcase 't':\n \t  /* unused */"}, {"sha": "badaae707e4588ff917e6c07aea12057d29e9ccb", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -109,10 +109,10 @@ and what kinds of objects they are.  In RTL, unlike Lisp, you cannot tell\n by looking at an operand what kind of object it is.  Instead, you must know\n from its context---from the expression code of the containing expression.\n For example, in an expression of code @code{subreg}, the first operand is\n-to be regarded as an expression and the second operand as an integer.  In\n-an expression of code @code{plus}, there are two operands, both of which\n-are to be regarded as expressions.  In a @code{symbol_ref} expression,\n-there is one operand, which is to be regarded as a string.\n+to be regarded as an expression and the second operand as a polynomial\n+integer.  In an expression of code @code{plus}, there are two operands,\n+both of which are to be regarded as expressions.  In a @code{symbol_ref}\n+expression, there is one operand, which is to be regarded as a string.\n \n Expressions are written as parentheses containing the name of the\n expression type, its flags and machine mode if any, and then the operands\n@@ -209,7 +209,7 @@ chain, such as @code{NOTE}, @code{BARRIER}, and @code{CODE_LABEL}.\n For each expression code, @file{rtl.def} specifies the number of\n contained objects and their kinds using a sequence of characters\n called the @dfn{format} of the expression code.  For example,\n-the format of @code{subreg} is @samp{ei}.\n+the format of @code{subreg} is @samp{ep}.\n \n @cindex RTL format characters\n These are the most commonly used format characters:\n@@ -258,6 +258,9 @@ An omitted vector is effectively the same as a vector of no elements.\n @item B\n @samp{B} indicates a pointer to basic block structure.\n \n+@item p\n+A polynomial integer.  At present this is used only for @code{SUBREG_BYTE}.\n+\n @item 0\n @samp{0} means a slot whose contents do not fit any normal category.\n @samp{0} slots are not printed at all in dumps, and are often used in\n@@ -340,16 +343,13 @@ stored in the operand.  You would do this based on the expression code of\n the containing expression.  That is also how you would know how many\n operands there are.\n \n-For example, if @var{x} is a @code{subreg} expression, you know that it has\n-two operands which can be correctly accessed as @code{XEXP (@var{x}, 0)}\n-and @code{XINT (@var{x}, 1)}.  If you did @code{XINT (@var{x}, 0)}, you\n-would get the address of the expression operand but cast as an integer;\n-that might occasionally be useful, but it would be cleaner to write\n-@code{(int) XEXP (@var{x}, 0)}.  @code{XEXP (@var{x}, 1)} would also\n-compile without error, and would return the second, integer operand cast as\n-an expression pointer, which would probably result in a crash when\n-accessed.  Nothing stops you from writing @code{XEXP (@var{x}, 28)} either,\n-but this will access memory past the end of the expression with\n+For example, if @var{x} is an @code{int_list} expression, you know that it has\n+two operands which can be correctly accessed as @code{XINT (@var{x}, 0)}\n+and @code{XEXP (@var{x}, 1)}.  Incorrect accesses like\n+@code{XEXP (@var{x}, 0)} and @code{XINT (@var{x}, 1)} would compile,\n+but would trigger an internal compiler error when rtl checking is enabled.\n+Nothing stops you from writing @code{XEXP (@var{x}, 28)} either, but\n+this will access memory past the end of the expression with\n unpredictable results.\n \n Access to operands which are vectors is more complicated.  You can use the\n@@ -2020,6 +2020,13 @@ on a @code{BYTES_BIG_ENDIAN}, @samp{UNITS_PER_WORD == 4} target is the same as\n on a little-endian, @samp{UNITS_PER_WORD == 4} target.  Both\n @code{subreg}s access the lower two bytes of register @var{x}.\n \n+Note that the byte offset is a polynomial integer; it may not be a\n+compile-time constant on targets with variable-sized modes.  However,\n+the restrictions above mean that there are only a certain set of\n+acceptable offsets for a given combination of @var{m1} and @var{m2}.\n+The compiler can always tell which blocks a valid subreg occupies, and\n+whether the subreg is a lowpart of a block.\n+\n @end table\n \n A @code{MODE_PARTIAL_INT} mode behaves as if it were as wide as the"}, {"sha": "3740c5b7de0f7c6d9fc4093be3eb50666e37f22d", "filename": "gcc/dse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -1709,7 +1709,7 @@ find_shift_sequence (poly_int64 access_size,\n \t e.g. at -Os, even when no actual shift will be needed.  */\n       if (store_info->const_rhs)\n \t{\n-\t  unsigned int byte = subreg_lowpart_offset (new_mode, store_mode);\n+\t  poly_uint64 byte = subreg_lowpart_offset (new_mode, store_mode);\n \t  rtx ret = simplify_subreg (new_mode, store_info->const_rhs,\n \t\t\t\t     store_mode, byte);\n \t  if (ret && CONSTANT_P (ret))"}, {"sha": "88c947f14e787a9def7689bc4460acc5a2ca8daf", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -19226,16 +19226,16 @@ rtl_for_decl_location (tree decl)\n \t   && GET_MODE (rtl) != TYPE_MODE (TREE_TYPE (decl)))\n     {\n       machine_mode addr_mode = get_address_mode (rtl);\n-      HOST_WIDE_INT offset = byte_lowpart_offset (TYPE_MODE (TREE_TYPE (decl)),\n-\t\t\t\t\t\t  GET_MODE (rtl));\n+      poly_int64 offset = byte_lowpart_offset (TYPE_MODE (TREE_TYPE (decl)),\n+\t\t\t\t\t       GET_MODE (rtl));\n \n       /* If a variable is declared \"register\" yet is smaller than\n \t a register, then if we store the variable to memory, it\n \t looks like we're storing a register-sized value, when in\n \t fact we are not.  We need to adjust the offset of the\n \t storage location to reflect the actual value's bytes,\n \t else gdb will not be able to display it.  */\n-      if (offset != 0)\n+      if (maybe_ne (offset, 0))\n \trtl = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (decl)),\n \t\t\t   plus_constant (addr_mode, XEXP (rtl, 0), offset));\n     }"}, {"sha": "f8d2f55e05264470848bc30ec314a20a934f4188", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -891,17 +891,17 @@ gen_tmp_stack_mem (machine_mode mode, rtx addr)\n \n bool\n validate_subreg (machine_mode omode, machine_mode imode,\n-\t\t const_rtx reg, unsigned int offset)\n+\t\t const_rtx reg, poly_uint64 offset)\n {\n   unsigned int isize = GET_MODE_SIZE (imode);\n   unsigned int osize = GET_MODE_SIZE (omode);\n \n   /* All subregs must be aligned.  */\n-  if (offset % osize != 0)\n+  if (!multiple_p (offset, osize))\n     return false;\n \n   /* The subreg offset cannot be outside the inner object.  */\n-  if (offset >= isize)\n+  if (maybe_ge (offset, isize))\n     return false;\n \n   unsigned int regsize = REGMODE_NATURAL_SIZE (imode);\n@@ -946,7 +946,7 @@ validate_subreg (machine_mode omode, machine_mode imode,\n \n   /* Paradoxical subregs must have offset zero.  */\n   if (osize > isize)\n-    return offset == 0;\n+    return known_eq (offset, 0U);\n \n   /* This is a normal subreg.  Verify that the offset is representable.  */\n \n@@ -978,18 +978,20 @@ validate_subreg (machine_mode omode, machine_mode imode,\n   if (osize < regsize\n       && ! (lra_in_progress && (FLOAT_MODE_P (imode) || FLOAT_MODE_P (omode))))\n     {\n-      unsigned int block_size = MIN (isize, regsize);\n-      unsigned int offset_within_block = offset % block_size;\n-      if (BYTES_BIG_ENDIAN\n-\t  ? offset_within_block != block_size - osize\n-\t  : offset_within_block != 0)\n+      poly_uint64 block_size = MIN (isize, regsize);\n+      unsigned int start_reg;\n+      poly_uint64 offset_within_reg;\n+      if (!can_div_trunc_p (offset, block_size, &start_reg, &offset_within_reg)\n+\t  || (BYTES_BIG_ENDIAN\n+\t      ? maybe_ne (offset_within_reg, block_size - osize)\n+\t      : maybe_ne (offset_within_reg, 0U)))\n \treturn false;\n     }\n   return true;\n }\n \n rtx\n-gen_rtx_SUBREG (machine_mode mode, rtx reg, int offset)\n+gen_rtx_SUBREG (machine_mode mode, rtx reg, poly_uint64 offset)\n {\n   gcc_assert (validate_subreg (mode, GET_MODE (reg), reg, offset));\n   return gen_rtx_raw_SUBREG (mode, reg, offset);\n@@ -1090,7 +1092,7 @@ gen_rtvec_v (int n, rtx_insn **argp)\n    paradoxical lowpart, in which case the offset will be negative\n    on big-endian targets.  */\n \n-int\n+poly_int64\n byte_lowpart_offset (machine_mode outer_mode,\n \t\t     machine_mode inner_mode)\n {\n@@ -1104,13 +1106,13 @@ byte_lowpart_offset (machine_mode outer_mode,\n    from address X.  For paradoxical big-endian subregs this is a\n    negative value, otherwise it's the same as OFFSET.  */\n \n-int\n+poly_int64\n subreg_memory_offset (machine_mode outer_mode, machine_mode inner_mode,\n-\t\t      unsigned int offset)\n+\t\t      poly_uint64 offset)\n {\n   if (paradoxical_subreg_p (outer_mode, inner_mode))\n     {\n-      gcc_assert (offset == 0);\n+      gcc_assert (known_eq (offset, 0U));\n       return -subreg_lowpart_offset (inner_mode, outer_mode);\n     }\n   return offset;\n@@ -1120,7 +1122,7 @@ subreg_memory_offset (machine_mode outer_mode, machine_mode inner_mode,\n    if SUBREG_REG (X) were stored in memory.  The only significant thing\n    about the current SUBREG_REG is its mode.  */\n \n-int\n+poly_int64\n subreg_memory_offset (const_rtx x)\n {\n   return subreg_memory_offset (GET_MODE (x), GET_MODE (SUBREG_REG (x)),\n@@ -1626,10 +1628,11 @@ gen_highpart_mode (machine_mode outermode, machine_mode innermode, rtx exp)\n /* Return the SUBREG_BYTE for a lowpart subreg whose outer mode has\n    OUTER_BYTES bytes and whose inner mode has INNER_BYTES bytes.  */\n \n-unsigned int\n-subreg_size_lowpart_offset (unsigned int outer_bytes, unsigned int inner_bytes)\n+poly_uint64\n+subreg_size_lowpart_offset (poly_uint64 outer_bytes, poly_uint64 inner_bytes)\n {\n-  if (outer_bytes > inner_bytes)\n+  gcc_checking_assert (ordered_p (outer_bytes, inner_bytes));\n+  if (maybe_gt (outer_bytes, inner_bytes))\n     /* Paradoxical subregs always have a SUBREG_BYTE of 0.  */\n     return 0;\n \n@@ -1644,11 +1647,10 @@ subreg_size_lowpart_offset (unsigned int outer_bytes, unsigned int inner_bytes)\n /* Return the SUBREG_BYTE for a highpart subreg whose outer mode has\n    OUTER_BYTES bytes and whose inner mode has INNER_BYTES bytes.  */\n \n-unsigned int\n-subreg_size_highpart_offset (unsigned int outer_bytes,\n-\t\t\t     unsigned int inner_bytes)\n+poly_uint64\n+subreg_size_highpart_offset (poly_uint64 outer_bytes, poly_uint64 inner_bytes)\n {\n-  gcc_assert (inner_bytes >= outer_bytes);\n+  gcc_assert (known_ge (inner_bytes, outer_bytes));\n \n   if (BYTES_BIG_ENDIAN && WORDS_BIG_ENDIAN)\n     return 0;\n@@ -1672,8 +1674,9 @@ subreg_lowpart_p (const_rtx x)\n   else if (GET_MODE (SUBREG_REG (x)) == VOIDmode)\n     return 0;\n \n-  return (subreg_lowpart_offset (GET_MODE (x), GET_MODE (SUBREG_REG (x)))\n-\t  == SUBREG_BYTE (x));\n+  return known_eq (subreg_lowpart_offset (GET_MODE (x),\n+\t\t\t\t\t  GET_MODE (SUBREG_REG (x))),\n+\t\t   SUBREG_BYTE (x));\n }\n \f\n /* Return subword OFFSET of operand OP.\n@@ -5732,6 +5735,7 @@ copy_insn_1 (rtx orig)\n       case 't':\n       case 'w':\n       case 'i':\n+      case 'p':\n       case 's':\n       case 'S':\n       case 'u':"}, {"sha": "6b22946f69a100a3910d88980adbcb67337a1c38", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -2345,7 +2345,7 @@ extract_low_bits (machine_mode mode, machine_mode src_mode, rtx src)\n       /* simplify_gen_subreg can't be used here, as if simplify_subreg\n \t fails, it will happily create (subreg (symbol_ref)) or similar\n \t invalid SUBREGs.  */\n-      unsigned int byte = subreg_lowpart_offset (mode, src_mode);\n+      poly_uint64 byte = subreg_lowpart_offset (mode, src_mode);\n       rtx ret = simplify_subreg (mode, src, src_mode, byte);\n       if (ret)\n \treturn ret;"}, {"sha": "9020327984a01c7845b6ba570b32e3a7886bdba5", "filename": "gcc/expr.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -2446,7 +2446,7 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n     {\n       machine_mode outer = GET_MODE (dst);\n       machine_mode inner;\n-      HOST_WIDE_INT bytepos;\n+      poly_int64 bytepos;\n       bool done = false;\n       rtx temp;\n \n@@ -2461,7 +2461,7 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n \t{\n \t  inner = GET_MODE (tmps[start]);\n \t  bytepos = subreg_lowpart_offset (inner, outer);\n-\t  if (INTVAL (XEXP (XVECEXP (src, 0, start), 1)) == bytepos)\n+\t  if (known_eq (INTVAL (XEXP (XVECEXP (src, 0, start), 1)), bytepos))\n \t    {\n \t      temp = simplify_gen_subreg (outer, tmps[start],\n \t\t\t\t\t  inner, 0);\n@@ -2480,7 +2480,8 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n \t{\n \t  inner = GET_MODE (tmps[finish - 1]);\n \t  bytepos = subreg_lowpart_offset (inner, outer);\n-\t  if (INTVAL (XEXP (XVECEXP (src, 0, finish - 1), 1)) == bytepos)\n+\t  if (known_eq (INTVAL (XEXP (XVECEXP (src, 0, finish - 1), 1)),\n+\t\t\tbytepos))\n \t    {\n \t      temp = simplify_gen_subreg (outer, tmps[finish - 1],\n \t\t\t\t\t  inner, 0);\n@@ -3545,9 +3546,9 @@ undefined_operand_subword_p (const_rtx op, int i)\n   if (GET_CODE (op) != SUBREG)\n     return false;\n   machine_mode innermostmode = GET_MODE (SUBREG_REG (op));\n-  HOST_WIDE_INT offset = i * UNITS_PER_WORD + subreg_memory_offset (op);\n-  return (offset >= GET_MODE_SIZE (innermostmode)\n-\t  || offset <= -UNITS_PER_WORD);\n+  poly_int64 offset = i * UNITS_PER_WORD + subreg_memory_offset (op);\n+  return (known_ge (offset, GET_MODE_SIZE (innermostmode))\n+\t  || known_le (offset, -UNITS_PER_WORD));\n }\n \n /* A subroutine of emit_move_insn_1.  Generate a move from Y into X.\n@@ -9247,8 +9248,8 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t\t\t>= GET_MODE_BITSIZE (word_mode)))\n \t\t  {\n \t\t    rtx_insn *seq, *seq_old;\n-\t\t    unsigned int high_off = subreg_highpart_offset (word_mode,\n-\t\t\t\t\t\t\t\t    int_mode);\n+\t\t    poly_uint64 high_off = subreg_highpart_offset (word_mode,\n+\t\t\t\t\t\t\t\t   int_mode);\n \t\t    bool extend_unsigned\n \t\t      = TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (def)));\n \t\t    rtx low = lowpart_subreg (word_mode, op0, int_mode);"}, {"sha": "29a5c1e824ba85a6d170a559ec731d8cd8965f86", "filename": "gcc/final.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -3251,7 +3251,7 @@ alter_subreg (rtx *xp, bool final_p)\n      We are required to.  */\n   if (MEM_P (y))\n     {\n-      int offset = SUBREG_BYTE (x);\n+      poly_int64 offset = SUBREG_BYTE (x);\n \n       /* For paradoxical subregs on big-endian machines, SUBREG_BYTE\n \t contains 0 instead of the proper offset.  See simplify_subreg.  */\n@@ -3274,7 +3274,7 @@ alter_subreg (rtx *xp, bool final_p)\n \t{\n \t  /* Simplify_subreg can't handle some REG cases, but we have to.  */\n \t  unsigned int regno;\n-\t  HOST_WIDE_INT offset;\n+\t  poly_int64 offset;\n \n \t  regno = subreg_regno (x);\n \t  if (subreg_lowpart_p (x))\n@@ -4523,6 +4523,7 @@ leaf_renumber_regs_insn (rtx in_rtx)\n       case '0':\n       case 'i':\n       case 'w':\n+      case 'p':\n       case 'n':\n       case 'u':\n \tbreak;"}, {"sha": "3d270154631e986bfcb98edd564da8d292f4988f", "filename": "gcc/function.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -2705,9 +2705,9 @@ assign_parm_find_stack_rtl (tree parm, struct assign_parm_data_one *data)\n \t  set_mem_size (stack_parm, GET_MODE_SIZE (data->promoted_mode));\n \t  if (MEM_EXPR (stack_parm) && MEM_OFFSET_KNOWN_P (stack_parm))\n \t    {\n-\t      int offset = subreg_lowpart_offset (DECL_MODE (parm),\n-\t\t\t\t\t\t  data->promoted_mode);\n-\t      if (offset)\n+\t      poly_int64 offset = subreg_lowpart_offset (DECL_MODE (parm),\n+\t\t\t\t\t\t\t data->promoted_mode);\n+\t      if (maybe_ne (offset, 0))\n \t\tset_mem_offset (stack_parm, MEM_OFFSET (stack_parm) - offset);\n \t    }\n \t}\n@@ -3431,12 +3431,13 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,\n \n       if (data->stack_parm)\n \t{\n-\t  int offset = subreg_lowpart_offset (data->nominal_mode,\n-\t\t\t\t\t      GET_MODE (data->stack_parm));\n+\t  poly_int64 offset\n+\t    = subreg_lowpart_offset (data->nominal_mode,\n+\t\t\t\t     GET_MODE (data->stack_parm));\n \t  /* ??? This may need a big-endian conversion on sparc64.  */\n \t  data->stack_parm\n \t    = adjust_address (data->stack_parm, data->nominal_mode, 0);\n-\t  if (offset && MEM_OFFSET_KNOWN_P (data->stack_parm))\n+\t  if (maybe_ne (offset, 0) && MEM_OFFSET_KNOWN_P (data->stack_parm))\n \t    set_mem_offset (data->stack_parm,\n \t\t\t    MEM_OFFSET (data->stack_parm) + offset);\n \t}"}, {"sha": "764b5392c4e82dafc65ba9f9ee410e54e9ea1151", "filename": "gcc/fwprop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -1263,7 +1263,7 @@ forward_propagate_and_simplify (df_ref use, rtx_insn *def_insn, rtx def_set)\n   reg = DF_REF_REG (use);\n   if (GET_CODE (reg) == SUBREG && GET_CODE (SET_DEST (def_set)) == SUBREG)\n     {\n-      if (SUBREG_BYTE (SET_DEST (def_set)) != SUBREG_BYTE (reg))\n+      if (maybe_ne (SUBREG_BYTE (SET_DEST (def_set)), SUBREG_BYTE (reg)))\n \treturn false;\n     }\n   /* Check if the def had a subreg, but the use has the whole reg.  */"}, {"sha": "463782411de9576ad7b3f5b2db91c13c1dc20514", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -563,6 +563,7 @@ attr_rtx_1 (enum rtx_code code, va_list p)\n \t      break;\n \n \t    default:\n+\t      /* Don't need to handle 'p' for attributes.  */\n \t      gcc_unreachable ();\n \t    }\n \t}"}, {"sha": "708da27221546c406030e88a4b07a51fb9df4a14", "filename": "gcc/genemit.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -235,6 +235,12 @@ gen_exp (rtx x, enum rtx_code subroutine_type, char *used)\n \t  printf (\"%u\", REGNO (x));\n \t  break;\n \n+\tcase 'p':\n+\t  /* We don't have a way of parsing polynomial offsets yet,\n+\t     and hopefully never will.  */\n+\t  printf (\"%d\", SUBREG_BYTE (x).to_constant ());\n+\t  break;\n+\n \tcase 's':\n \t  printf (\"\\\"%s\\\"\", XSTR (x, i));\n \t  break;"}, {"sha": "d988ddb6f5f0f3fafa790a0ff16a4b0ea3c05e2f", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -54,6 +54,9 @@ type_from_format (int c)\n     case 'w':\n       return \"HOST_WIDE_INT \";\n \n+    case 'p':\n+      return \"poly_uint16 \";\n+\n     case 's':\n       return \"const char *\";\n \n@@ -256,10 +259,12 @@ gendef (const char *format)\n   puts (\"  PUT_MODE_RAW (rt, mode);\");\n \n   for (p = format, i = j = 0; *p ; ++p, ++i)\n-    if (*p != '0')\n-      printf (\"  %s (rt, %d) = arg%d;\\n\", accessor_from_format (*p), i, j++);\n-    else\n+    if (*p == '0')\n       printf (\"  X0EXP (rt, %d) = NULL_RTX;\\n\", i);\n+    else if (*p == 'p')\n+      printf (\"  SUBREG_BYTE (rt) = arg%d;\\n\", j++);\n+    else\n+      printf (\"  %s (rt, %d) = arg%d;\\n\", accessor_from_format (*p), i, j++);\n \n   puts (\"\\n  return rt;\\n}\\n\");\n   printf (\"#define gen_rtx_fmt_%s(c, m\", format);"}, {"sha": "64190ed69e0fd24b58e48c86d63b907d26255908", "filename": "gcc/gengtype.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -1241,6 +1241,11 @@ adjust_field_rtx_def (type_p t, options_p ARG_UNUSED (opt))\n \t      subname = \"rt_int\";\n \t      break;\n \n+\t    case 'p':\n+\t      t = scalar_tp;\n+\t      subname = \"rt_subreg\";\n+\t      break;\n+\n \t    case '0':\n \t      if (i == MEM && aindex == 1)\n \t\tt = mem_attrs_tp, subname = \"rt_mem\";"}, {"sha": "20239544bdb717ee6b9b6bcf0bce8a4ff5a9cfaa", "filename": "gcc/genpeep.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fgenpeep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fgenpeep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpeep.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -306,6 +306,9 @@ match_rtx (rtx x, struct link *path, int fail_label)\n \t  printf (\"  if (strcmp (XSTR (x, %d), \\\"%s\\\")) goto L%d;\\n\",\n \t\t  i, XSTR (x, i), fail_label);\n \t}\n+      else if (fmt[i] == 'p')\n+\t/* Not going to support subregs for legacy define_peeholes.  */\n+\tgcc_unreachable ();\n     }\n }\n "}, {"sha": "ce2f26272afdb62936de9ef1eec28df4e00c3972", "filename": "gcc/genrecog.c", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -388,7 +388,7 @@ find_operand (rtx pattern, int n, rtx stop)\n \t      return r;\n \t  break;\n \n-\tcase 'i': case 'r': case 'w': case '0': case 's':\n+\tcase 'r': case 'p': case 'i': case 'w': case '0': case 's':\n \t  break;\n \n \tdefault:\n@@ -439,7 +439,7 @@ find_matching_operand (rtx pattern, int n)\n \t      return r;\n \t  break;\n \n-\tcase 'i': case 'r': case 'w': case '0': case 's':\n+\tcase 'r': case 'p': case 'i': case 'w': case '0': case 's':\n \t  break;\n \n \tdefault:\n@@ -797,7 +797,7 @@ validate_pattern (rtx pattern, md_rtx_info *info, rtx set, int set_code)\n \t    validate_pattern (XVECEXP (pattern, i, j), info, NULL_RTX, 0);\n \t  break;\n \n-\tcase 'i': case 'r': case 'w': case '0': case 's':\n+\tcase 'r': case 'p': case 'i': case 'w': case '0': case 's':\n \t  break;\n \n \tdefault:\n@@ -1119,6 +1119,9 @@ struct rtx_test\n     /* Check REGNO (X) == LABEL.  */\n     REGNO_FIELD,\n \n+    /* Check known_eq (SUBREG_BYTE (X), LABEL).  */\n+    SUBREG_FIELD,\n+\n     /* Check XINT (X, u.opno) == LABEL.  */\n     INT_FIELD,\n \n@@ -1199,6 +1202,7 @@ struct rtx_test\n   static rtx_test code (position *);\n   static rtx_test mode (position *);\n   static rtx_test regno_field (position *);\n+  static rtx_test subreg_field (position *);\n   static rtx_test int_field (position *, int);\n   static rtx_test wide_int_field (position *, int);\n   static rtx_test veclen (position *);\n@@ -1243,6 +1247,13 @@ rtx_test::regno_field (position *pos)\n   return res;\n }\n \n+rtx_test\n+rtx_test::subreg_field (position *pos)\n+{\n+  rtx_test res (pos, rtx_test::SUBREG_FIELD);\n+  return res;\n+}\n+\n rtx_test\n rtx_test::int_field (position *pos, int opno)\n {\n@@ -1364,6 +1375,7 @@ operator == (const rtx_test &a, const rtx_test &b)\n     case rtx_test::CODE:\n     case rtx_test::MODE:\n     case rtx_test::REGNO_FIELD:\n+    case rtx_test::SUBREG_FIELD:\n     case rtx_test::VECLEN:\n     case rtx_test::HAVE_NUM_CLOBBERS:\n       return true;\n@@ -1821,6 +1833,7 @@ safe_to_hoist_p (decision *d, const rtx_test &test, known_conditions *kc)\n       gcc_unreachable ();\n \n     case rtx_test::REGNO_FIELD:\n+    case rtx_test::SUBREG_FIELD:\n     case rtx_test::INT_FIELD:\n     case rtx_test::WIDE_INT_FIELD:\n     case rtx_test::VECLEN:\n@@ -2028,6 +2041,7 @@ transition_parameter_type (rtx_test::kind_enum kind)\n       return parameter::MODE;\n \n     case rtx_test::REGNO_FIELD:\n+    case rtx_test::SUBREG_FIELD:\n       return parameter::UINT;\n \n     case rtx_test::INT_FIELD:\n@@ -4039,6 +4053,14 @@ match_pattern_2 (state *s, md_rtx_info *info, position *pos, rtx pattern)\n \t\t\t\t      XWINT (pattern, 0), false);\n \t\t    break;\n \n+\t\t  case 'p':\n+\t\t    /* We don't have a way of parsing polynomial offsets yet,\n+\t\t       and hopefully never will.  */\n+\t\t    s = add_decision (s, rtx_test::subreg_field (pos),\n+\t\t\t\t      SUBREG_BYTE (pattern).to_constant (),\n+\t\t\t\t      false);\n+\t\t    break;\n+\n \t\t  case '0':\n \t\t    break;\n \n@@ -4571,6 +4593,12 @@ print_nonbool_test (output_state *os, const rtx_test &test)\n       printf (\")\");\n       break;\n \n+    case rtx_test::SUBREG_FIELD:\n+      printf (\"SUBREG_BYTE (\");\n+      print_test_rtx (os, test);\n+      printf (\")\");\n+      break;\n+\n     case rtx_test::WIDE_INT_FIELD:\n       printf (\"XWINT (\");\n       print_test_rtx (os, test);\n@@ -4653,6 +4681,14 @@ print_test (output_state *os, const rtx_test &test, bool is_param,\n       print_label_value (test, is_param, value);\n       break;\n \n+    case rtx_test::SUBREG_FIELD:\n+      printf (\"%s (\", invert_p ? \"maybe_ne\" : \"known_eq\");\n+      print_nonbool_test (os, test);\n+      printf (\", \");\n+      print_label_value (test, is_param, value);\n+      printf (\")\");\n+      break;\n+\n     case rtx_test::SAVED_CONST_INT:\n       gcc_assert (!is_param && value == 1);\n       print_test_rtx (os, test);"}, {"sha": "e7662b08247ba264bcf4d277ae3e0175904ef91b", "filename": "gcc/gensupport.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -883,7 +883,7 @@ subst_pattern_match (rtx x, rtx pt, file_location loc)\n \n       switch (fmt[i])\n \t{\n-\tcase 'i': case 'r': case 'w': case 's':\n+\tcase 'r': case 'p': case 'i': case 'w': case 's':\n \t  continue;\n \n \tcase 'e': case 'u':\n@@ -1047,7 +1047,8 @@ get_alternatives_number (rtx pattern, int *n_alt, file_location loc)\n \t      return 0;\n \t  break;\n \n-\tcase 'i': case 'r': case 'w': case '0': case 's': case 'S': case 'T':\n+\tcase 'r': case 'p': case 'i': case 'w':\n+\tcase '0': case 's': case 'S': case 'T':\n \t  break;\n \n \tdefault:\n@@ -1106,7 +1107,8 @@ collect_insn_data (rtx pattern, int *palt, int *pmax)\n \t    collect_insn_data (XVECEXP (pattern, i, j), palt, pmax);\n \t  break;\n \n-\tcase 'i': case 'r': case 'w': case '0': case 's': case 'S': case 'T':\n+\tcase 'r': case 'p': case 'i': case 'w':\n+\tcase '0': case 's': case 'S': case 'T':\n \t  break;\n \n \tdefault:\n@@ -1190,7 +1192,7 @@ alter_predicate_for_insn (rtx pattern, int alt, int max_op,\n \t    }\n \t  break;\n \n-\tcase 'i': case 'r': case 'w': case '0': case 's':\n+\tcase 'r': case 'p': case 'i': case 'w': case '0': case 's':\n \t  break;\n \n \tdefault:\n@@ -1248,7 +1250,7 @@ alter_constraints (rtx pattern, int n_dup, constraints_handler_t alter)\n \t    }\n \t  break;\n \n-\tcase 'i': case 'r': case 'w': case '0': case 's':\n+\tcase 'r': case 'p': case 'i': case 'w': case '0': case 's':\n \t  break;\n \n \tdefault:\n@@ -2164,7 +2166,8 @@ subst_dup (rtx pattern, int n_alt, int n_subst_alt)\n \t\t\t\t\t\t   n_alt, n_subst_alt);\n \t  break;\n \n-\tcase 'i': case 'r': case 'w': case '0': case 's': case 'S': case 'T':\n+\tcase 'r': case 'p': case 'i': case 'w':\n+\tcase '0': case 's': case 'S': case 'T':\n \t  break;\n \n \tdefault:"}, {"sha": "591105176d1eabf9a241100432f41def323df07a", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -894,7 +894,7 @@ noce_emit_move_insn (rtx x, rtx y)\n {\n   machine_mode outmode;\n   rtx outer, inner;\n-  int bitpos;\n+  poly_int64 bitpos;\n \n   if (GET_CODE (x) != STRICT_LOW_PART)\n     {\n@@ -1724,12 +1724,12 @@ noce_emit_cmove (struct noce_if_info *if_info, rtx x, enum rtx_code code,\n     {\n       rtx reg_vtrue = SUBREG_REG (vtrue);\n       rtx reg_vfalse = SUBREG_REG (vfalse);\n-      unsigned int byte_vtrue = SUBREG_BYTE (vtrue);\n-      unsigned int byte_vfalse = SUBREG_BYTE (vfalse);\n+      poly_uint64 byte_vtrue = SUBREG_BYTE (vtrue);\n+      poly_uint64 byte_vfalse = SUBREG_BYTE (vfalse);\n       rtx promoted_target;\n \n       if (GET_MODE (reg_vtrue) != GET_MODE (reg_vfalse)\n-\t  || byte_vtrue != byte_vfalse\n+\t  || maybe_ne (byte_vtrue, byte_vfalse)\n \t  || (SUBREG_PROMOTED_VAR_P (vtrue)\n \t      != SUBREG_PROMOTED_VAR_P (vfalse))\n \t  || (SUBREG_PROMOTED_GET (vtrue)"}, {"sha": "61c03e2ddfdc16118e1f73e06fd23214a8f203e7", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -226,8 +226,11 @@ go_through_subreg (rtx x, int *offset)\n   if (REGNO (reg) < FIRST_PSEUDO_REGISTER)\n     *offset = subreg_regno_offset (REGNO (reg), GET_MODE (reg),\n \t\t\t\t   SUBREG_BYTE (x), GET_MODE (x));\n-  else\n-    *offset = (SUBREG_BYTE (x) / REGMODE_NATURAL_SIZE (GET_MODE (x)));\n+  else if (!can_div_trunc_p (SUBREG_BYTE (x),\n+\t\t\t     REGMODE_NATURAL_SIZE (GET_MODE (x)), offset))\n+    /* Checked by validate_subreg.  We must know at compile time which\n+       inner hard registers are being accessed.  */\n+    gcc_unreachable ();\n   return reg;\n }\n "}, {"sha": "d70868d50de0254d03991a82b0c86ffe33f3f885", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -919,7 +919,7 @@ process_single_reg_class_operands (bool in_p, int freq)\n \t\t    (subreg:YMODE (reg:XMODE XREGNO) OFFSET).  */\n \t      machine_mode ymode, xmode;\n \t      int xregno, yregno;\n-\t      HOST_WIDE_INT offset;\n+\t      poly_int64 offset;\n \n \t      xmode = recog_data.operand_mode[i];\n \t      xregno = ira_class_singleton[cl][xmode];"}, {"sha": "765a1d01a5d2e23756e8758d7e82bb7ce25255b5", "filename": "gcc/ira.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -4048,8 +4048,7 @@ get_subreg_tracking_sizes (rtx x, HOST_WIDE_INT *outer_size,\n   rtx reg = regno_reg_rtx[REGNO (SUBREG_REG (x))];\n   *outer_size = GET_MODE_SIZE (GET_MODE (x));\n   *inner_size = GET_MODE_SIZE (GET_MODE (reg));\n-  *start = SUBREG_BYTE (x);\n-  return true;\n+  return SUBREG_BYTE (x).is_constant (start);\n }\n \n /* Init LIVE_SUBREGS[ALLOCNUM] and LIVE_SUBREGS_USED[ALLOCNUM] for"}, {"sha": "8ee05129bafb518826c7507f5d6d6223c191668f", "filename": "gcc/jump.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -1724,7 +1724,7 @@ rtx_renumbered_equal_p (const_rtx x, const_rtx y)\n \t\t\t\t  && REG_P (SUBREG_REG (y)))))\n     {\n       int reg_x = -1, reg_y = -1;\n-      int byte_x = 0, byte_y = 0;\n+      poly_int64 byte_x = 0, byte_y = 0;\n       struct subreg_info info;\n \n       if (GET_MODE (x) != GET_MODE (y))\n@@ -1781,7 +1781,7 @@ rtx_renumbered_equal_p (const_rtx x, const_rtx y)\n \t    reg_y = reg_renumber[reg_y];\n \t}\n \n-      return reg_x >= 0 && reg_x == reg_y && byte_x == byte_y;\n+      return reg_x >= 0 && reg_x == reg_y && known_eq (byte_x, byte_y);\n     }\n \n   /* Now we have disposed of all the cases\n@@ -1873,6 +1873,11 @@ rtx_renumbered_equal_p (const_rtx x, const_rtx y)\n \t    }\n \t  break;\n \n+\tcase 'p':\n+\t  if (maybe_ne (SUBREG_BYTE (x), SUBREG_BYTE (y)))\n+\t    return 0;\n+\t  break;\n+\n \tcase 't':\n \t  if (XTREE (x, i) != XTREE (y, i))\n \t    return 0;"}, {"sha": "ed491697f3246e953bbb3d985bd60ed46b16a55f", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -335,6 +335,8 @@ hash_invariant_expr_1 (rtx_insn *insn, rtx x)\n \t}\n       else if (fmt[i] == 'i' || fmt[i] == 'n')\n \tval ^= XINT (x, i);\n+      else if (fmt[i] == 'p')\n+\tval ^= constant_lower_bound (SUBREG_BYTE (x));\n     }\n \n   return val;\n@@ -420,6 +422,11 @@ invariant_expr_equal_p (rtx_insn *insn1, rtx e1, rtx_insn *insn2, rtx e2)\n \t  if (XINT (e1, i) != XINT (e2, i))\n \t    return false;\n \t}\n+      else if (fmt[i] == 'p')\n+\t{\n+\t  if (maybe_ne (SUBREG_BYTE (e1), SUBREG_BYTE (e2)))\n+\t    return false;\n+\t}\n       /* Unhandled type of subexpression, we fail conservatively.  */\n       else\n \treturn false;"}, {"sha": "e10844cda7694217e2fc2f2529051d9066111bbf", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -609,19 +609,21 @@ decompose_register (unsigned int regno)\n /* Get a SUBREG of a CONCATN.  */\n \n static rtx\n-simplify_subreg_concatn (machine_mode outermode, rtx op,\n-\t\t\t unsigned int byte)\n+simplify_subreg_concatn (machine_mode outermode, rtx op, poly_uint64 orig_byte)\n {\n   unsigned int outer_size, outer_words, inner_size, inner_words;\n   machine_mode innermode, partmode;\n   rtx part;\n   unsigned int final_offset;\n+  unsigned int byte;\n \n   innermode = GET_MODE (op);\n   if (!interesting_mode_p (outermode, &outer_size, &outer_words)\n       || !interesting_mode_p (innermode, &inner_size, &inner_words))\n     gcc_unreachable ();\n \n+  /* Must be constant if interesting_mode_p passes.  */\n+  byte = orig_byte.to_constant ();\n   gcc_assert (GET_CODE (op) == CONCATN);\n   gcc_assert (byte % outer_size == 0);\n \n@@ -667,7 +669,7 @@ simplify_gen_subreg_concatn (machine_mode outermode, rtx op,\n \n       if ((GET_MODE_SIZE (GET_MODE (op))\n \t   == GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))))\n-\t  && SUBREG_BYTE (op) == 0)\n+\t  && known_eq (SUBREG_BYTE (op), 0))\n \treturn simplify_gen_subreg_concatn (outermode, SUBREG_REG (op),\n \t\t\t\t\t    GET_MODE (SUBREG_REG (op)), byte);\n \n@@ -866,7 +868,7 @@ resolve_simple_move (rtx set, rtx_insn *insn)\n \n   if (GET_CODE (src) == SUBREG\n       && resolve_reg_p (SUBREG_REG (src))\n-      && (SUBREG_BYTE (src) != 0\n+      && (maybe_ne (SUBREG_BYTE (src), 0)\n \t  || (GET_MODE_SIZE (orig_mode)\n \t      != GET_MODE_SIZE (GET_MODE (SUBREG_REG (src))))))\n     {\n@@ -881,7 +883,7 @@ resolve_simple_move (rtx set, rtx_insn *insn)\n \n   if (GET_CODE (dest) == SUBREG\n       && resolve_reg_p (SUBREG_REG (dest))\n-      && (SUBREG_BYTE (dest) != 0\n+      && (maybe_ne (SUBREG_BYTE (dest), 0)\n \t  || (GET_MODE_SIZE (orig_mode)\n \t      != GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest))))))\n     {"}, {"sha": "5162183f913a7952de7d61e09448bd72e23f0686", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -786,6 +786,11 @@ operands_match_p (rtx x, rtx y, int y_hard_regno)\n \t    return false;\n \t  break;\n \n+\tcase 'p':\n+\t  if (maybe_ne (SUBREG_BYTE (x), SUBREG_BYTE (y)))\n+\t    return false;\n+\t  break;\n+\n \tcase 'e':\n \t  val = operands_match_p (XEXP (x, i), XEXP (y, i), -1);\n \t  if (val == 0)\n@@ -974,7 +979,7 @@ match_reload (signed char out, signed char *ins, signed char *outs,\n \t      if (REG_P (subreg_reg)\n \t\t  && (int) REGNO (subreg_reg) < lra_new_regno_start\n \t\t  && GET_MODE (subreg_reg) == outmode\n-\t\t  && SUBREG_BYTE (in_rtx) == SUBREG_BYTE (new_in_reg)\n+\t\t  && known_eq (SUBREG_BYTE (in_rtx), SUBREG_BYTE (new_in_reg))\n \t\t  && find_regno_note (curr_insn, REG_DEAD, REGNO (subreg_reg))\n \t\t  && (! early_clobber_p\n \t\t      || check_conflict_input_operands (REGNO (subreg_reg),\n@@ -4205,15 +4210,15 @@ curr_insn_transform (bool check_only_p)\n \t{\n \t  machine_mode mode;\n \t  rtx reg, *loc;\n-\t  int hard_regno, byte;\n+\t  int hard_regno;\n \t  enum op_type type = curr_static_id->operand[i].type;\n \n \t  loc = curr_id->operand_loc[i];\n \t  mode = curr_operand_mode[i];\n \t  if (GET_CODE (*loc) == SUBREG)\n \t    {\n \t      reg = SUBREG_REG (*loc);\n-\t      byte = SUBREG_BYTE (*loc);\n+\t      poly_int64 byte = SUBREG_BYTE (*loc);\n \t      if (REG_P (reg)\n \t\t  /* Strict_low_part requires reloading the register and not\n \t\t     just the subreg.  Likewise for a strict subreg no wider"}, {"sha": "60117f5600ee628e49378b8a6e3a17ba0709ac10", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -136,7 +136,7 @@ assign_mem_slot (int i)\n   machine_mode wider_mode\n     = wider_subreg_mode (mode, lra_reg_info[i].biggest_mode);\n   HOST_WIDE_INT total_size = GET_MODE_SIZE (wider_mode);\n-  HOST_WIDE_INT adjust = 0;\n+  poly_int64 adjust = 0;\n \n   lra_assert (regno_reg_rtx[i] != NULL_RTX && REG_P (regno_reg_rtx[i])\n \t      && lra_reg_info[i].nrefs != 0 && reg_renumber[i] < 0);"}, {"sha": "ced8ec9823e3a0161781d10f889687dfa61ee71f", "filename": "gcc/postreload.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -1704,9 +1704,9 @@ move2add_valid_value_p (int regno, scalar_int_mode mode)\n \t mode after truncation only if (REG:mode regno) is the lowpart of\n \t (REG:reg_mode[regno] regno).  Now, for big endian, the starting\n \t regno of the lowpart might be different.  */\n-      int s_off = subreg_lowpart_offset (mode, old_mode);\n+      poly_int64 s_off = subreg_lowpart_offset (mode, old_mode);\n       s_off = subreg_regno_offset (regno, old_mode, s_off, mode);\n-      if (s_off != 0)\n+      if (maybe_ne (s_off, 0))\n \t/* We could in principle adjust regno, check reg_mode[regno] to be\n \t   BLKmode, and return s_off to the caller (vs. -1 for failure),\n \t   but we currently have no callers that could make use of this"}, {"sha": "379ff0071cfcdf02f71d8ef81edc1dba7f5f9e6b", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -178,6 +178,7 @@ print_mem_expr (FILE *outfile, const_tree expr)\n   fputc (' ', outfile);\n   print_generic_expr (outfile, CONST_CAST_TREE (expr), dump_flags);\n }\n+#endif\n \n /* Print X to FILE.  */\n \n@@ -195,7 +196,6 @@ print_poly_int (FILE *file, poly_int64 x)\n       fprintf (file, \"]\");\n     }\n }\n-#endif\n \n /* Subroutine of print_rtx_operand for handling code '0'.\n    0 indicates a field for internal use that should not be printed.\n@@ -638,6 +638,11 @@ rtx_writer::print_rtx_operand (const_rtx in_rtx, int idx)\n       print_rtx_operand_code_i (in_rtx, idx);\n       break;\n \n+    case 'p':\n+      fprintf (m_outfile, \" \");\n+      print_poly_int (m_outfile, SUBREG_BYTE (in_rtx));\n+      break;\n+\n     case 'r':\n       print_rtx_operand_code_r (in_rtx);\n       break;\n@@ -1688,7 +1693,8 @@ print_value (pretty_printer *pp, const_rtx x, int verbose)\n       break;\n     case SUBREG:\n       print_value (pp, SUBREG_REG (x), verbose);\n-      pp_printf (pp, \"#%d\", SUBREG_BYTE (x));\n+      pp_printf (pp, \"#\");\n+      pp_wide_integer (pp, SUBREG_BYTE (x));\n       break;\n     case SCRATCH:\n     case CC0:"}, {"sha": "7e7dd0088d759cb6da53f35bb6d76d9344ed4362", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -222,7 +222,10 @@ find_int (const char *name)\n static void\n apply_int_iterator (rtx x, unsigned int index, int value)\n {\n-  XINT (x, index) = value;\n+  if (GET_CODE (x) == SUBREG)\n+    SUBREG_BYTE (x) = value;\n+  else\n+    XINT (x, index) = value;\n }\n \n #ifdef GENERATOR_FILE\n@@ -1608,6 +1611,7 @@ rtx_reader::read_rtx_operand (rtx return_rtx, int idx)\n \n     case 'i':\n     case 'n':\n+    case 'p':\n       /* Can be an iterator or an integer constant.  */\n       read_name (&name);\n       record_potential_iterator_use (&ints, return_rtx, idx, name.string);"}, {"sha": "8e1218b519d80fceefcf558d88d77e7d44fbef7c", "filename": "gcc/recog.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -1006,7 +1006,8 @@ general_operand (rtx op, machine_mode mode)\n \t might be called from cleanup_subreg_operands.\n \n \t ??? This is a kludge.  */\n-      if (!reload_completed && SUBREG_BYTE (op) != 0\n+      if (!reload_completed\n+\t  && maybe_ne (SUBREG_BYTE (op), 0)\n \t  && MEM_P (sub))\n \treturn 0;\n \n@@ -1368,22 +1369,17 @@ indirect_operand (rtx op, machine_mode mode)\n   if (! reload_completed\n       && GET_CODE (op) == SUBREG && MEM_P (SUBREG_REG (op)))\n     {\n-      int offset = SUBREG_BYTE (op);\n-      rtx inner = SUBREG_REG (op);\n-\n       if (mode != VOIDmode && GET_MODE (op) != mode)\n \treturn 0;\n \n       /* The only way that we can have a general_operand as the resulting\n \t address is if OFFSET is zero and the address already is an operand\n \t or if the address is (plus Y (const_int -OFFSET)) and Y is an\n \t operand.  */\n-\n-      return ((offset == 0 && general_operand (XEXP (inner, 0), Pmode))\n-\t      || (GET_CODE (XEXP (inner, 0)) == PLUS\n-\t\t  && CONST_INT_P (XEXP (XEXP (inner, 0), 1))\n-\t\t  && INTVAL (XEXP (XEXP (inner, 0), 1)) == -offset\n-\t\t  && general_operand (XEXP (XEXP (inner, 0), 0), Pmode)));\n+      poly_int64 offset;\n+      rtx addr = strip_offset (XEXP (SUBREG_REG (op), 0), &offset);\n+      return (known_eq (offset + SUBREG_BYTE (op), 0)\n+\t      && general_operand (addr, Pmode));\n     }\n \n   return (MEM_P (op)"}, {"sha": "10d8395050609aba11c27ea7e7847f99b7959893", "filename": "gcc/regcprop.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -345,7 +345,8 @@ copy_value (rtx dest, rtx src, struct value_data *vd)\n      We can't properly represent the latter case in our tables, so don't\n      record anything then.  */\n   else if (sn < hard_regno_nregs (sr, vd->e[sr].mode)\n-\t   && subreg_lowpart_offset (GET_MODE (dest), vd->e[sr].mode) != 0)\n+\t   && maybe_ne (subreg_lowpart_offset (GET_MODE (dest),\n+\t\t\t\t\t       vd->e[sr].mode), 0U))\n     return;\n \n   /* If SRC had been assigned a mode narrower than the copy, we can't\n@@ -407,7 +408,7 @@ maybe_mode_change (machine_mode orig_mode, machine_mode copy_mode,\n       int use_nregs = hard_regno_nregs (copy_regno, new_mode);\n       int copy_offset\n \t= GET_MODE_SIZE (copy_mode) / copy_nregs * (copy_nregs - use_nregs);\n-      unsigned int offset\n+      poly_uint64 offset\n \t= subreg_size_lowpart_offset (GET_MODE_SIZE (new_mode) + copy_offset,\n \t\t\t\t      GET_MODE_SIZE (orig_mode));\n       regno += subreg_regno_offset (regno, orig_mode, offset, new_mode);\n@@ -868,7 +869,8 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t      /* And likewise, if we are narrowing on big endian the transformation\n \t\t is also invalid.  */\n \t      if (REG_NREGS (src) < hard_regno_nregs (regno, vd->e[regno].mode)\n-\t\t  && subreg_lowpart_offset (mode, vd->e[regno].mode) != 0)\n+\t\t  && maybe_ne (subreg_lowpart_offset (mode,\n+\t\t\t\t\t\t      vd->e[regno].mode), 0U))\n \t\tgoto no_move_special_case;\n \t    }\n "}, {"sha": "3d1c2ed51664f56dea5d9ad7f00914184f70abac", "filename": "gcc/reginfo.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -1206,7 +1206,9 @@ reg_classes_intersect_p (reg_class_t c1, reg_class_t c2)\n inline hashval_t\n simplifiable_subregs_hasher::hash (const simplifiable_subreg *value)\n {\n-  return value->shape.unique_id ();\n+  inchash::hash h;\n+  h.add_hwi (value->shape.unique_id ());\n+  return h.end ();\n }\n \n inline bool\n@@ -1231,9 +1233,11 @@ simplifiable_subregs (const subreg_shape &shape)\n   if (!this_target_hard_regs->x_simplifiable_subregs)\n     this_target_hard_regs->x_simplifiable_subregs\n       = new hash_table <simplifiable_subregs_hasher> (30);\n+  inchash::hash h;\n+  h.add_hwi (shape.unique_id ());\n   simplifiable_subreg **slot\n     = (this_target_hard_regs->x_simplifiable_subregs\n-       ->find_slot_with_hash (&shape, shape.unique_id (), INSERT));\n+       ->find_slot_with_hash (&shape, h.end (), INSERT));\n \n   if (!*slot)\n     {\n@@ -1294,7 +1298,7 @@ record_subregs_of_mode (rtx subreg, bool partial_def)\n       unsigned int size = MAX (REGMODE_NATURAL_SIZE (shape.inner_mode),\n \t\t\t       GET_MODE_SIZE (shape.outer_mode));\n       gcc_checking_assert (size < GET_MODE_SIZE (shape.inner_mode));\n-      if (shape.offset >= size)\n+      if (known_ge (shape.offset, size))\n \tshape.offset -= size;\n       else\n \tshape.offset += size;"}, {"sha": "59b0326a46022825b170b3429ed069f866a9dccf", "filename": "gcc/reload.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -2307,6 +2307,11 @@ operands_match_p (rtx x, rtx y)\n \t    return 0;\n \t  break;\n \n+\tcase 'p':\n+\t  if (maybe_ne (SUBREG_BYTE (x), SUBREG_BYTE (y)))\n+\t    return 0;\n+\t  break;\n+\n \tcase 'e':\n \t  val = operands_match_p (XEXP (x, i), XEXP (y, i));\n \t  if (val == 0)\n@@ -6095,7 +6100,7 @@ find_reloads_subreg_address (rtx x, int opnum, enum reload_type type,\n   int regno = REGNO (SUBREG_REG (x));\n   int reloaded = 0;\n   rtx tem, orig;\n-  int offset;\n+  poly_int64 offset;\n \n   gcc_assert (reg_equiv_memory_loc (regno) != 0);\n \n@@ -6142,7 +6147,7 @@ find_reloads_subreg_address (rtx x, int opnum, enum reload_type type,\n \t\t\t\t   XEXP (tem, 0), &XEXP (tem, 0),\n \t\t\t\t   opnum, type, ind_levels, insn);\n   /* ??? Do we need to handle nonzero offsets somehow?  */\n-  if (!offset && !rtx_equal_p (tem, orig))\n+  if (known_eq (offset, 0) && !rtx_equal_p (tem, orig))\n     push_reg_equiv_alt_mem (regno, tem);\n \n   /* For some processors an address may be valid in the original mode but"}, {"sha": "f17edda9721a10cf021d397c56d1ee49cd71d105", "filename": "gcc/reload1.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -2140,12 +2140,12 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n     {\n       rtx x = NULL_RTX;\n       machine_mode mode = GET_MODE (regno_reg_rtx[i]);\n-      unsigned int inherent_size = PSEUDO_REGNO_BYTES (i);\n+      unsigned HOST_WIDE_INT inherent_size = PSEUDO_REGNO_BYTES (i);\n       unsigned int inherent_align = GET_MODE_ALIGNMENT (mode);\n       machine_mode wider_mode = wider_subreg_mode (mode, reg_max_ref_mode[i]);\n-      unsigned int total_size = GET_MODE_SIZE (wider_mode);\n+      unsigned HOST_WIDE_INT total_size = GET_MODE_SIZE (wider_mode);\n       unsigned int min_align = GET_MODE_BITSIZE (reg_max_ref_mode[i]);\n-      int adjust = 0;\n+      poly_int64 adjust = 0;\n \n       something_was_spilled = true;\n \n@@ -2185,7 +2185,7 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n \t  if (BYTES_BIG_ENDIAN)\n \t    {\n \t      adjust = inherent_size - total_size;\n-\t      if (adjust)\n+\t      if (maybe_ne (adjust, 0))\n \t\t{\n \t\t  unsigned int total_bits = total_size * BITS_PER_UNIT;\n \t\t  machine_mode mem_mode\n@@ -2237,7 +2237,7 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n \t  if (BYTES_BIG_ENDIAN)\n \t    {\n \t      adjust = GET_MODE_SIZE (mode) - total_size;\n-\t      if (adjust)\n+\t      if (maybe_ne (adjust, 0))\n \t\t{\n \t\t  unsigned int total_bits = total_size * BITS_PER_UNIT;\n \t\t  machine_mode mem_mode\n@@ -6347,12 +6347,12 @@ replaced_subreg (rtx x)\n    SUBREG is non-NULL if the pseudo is a subreg whose reg is a pseudo,\n    otherwise it is NULL.  */\n \n-static int\n+static poly_int64\n compute_reload_subreg_offset (machine_mode outermode,\n \t\t\t      rtx subreg,\n \t\t\t      machine_mode innermode)\n {\n-  int outer_offset;\n+  poly_int64 outer_offset;\n   machine_mode middlemode;\n \n   if (!subreg)\n@@ -6506,7 +6506,7 @@ choose_reload_regs (struct insn_chain *chain)\n \n \t  if (inheritance)\n \t    {\n-\t      int byte = 0;\n+\t      poly_int64 byte = 0;\n \t      int regno = -1;\n \t      machine_mode mode = VOIDmode;\n \t      rtx subreg = NULL_RTX;\n@@ -6556,8 +6556,9 @@ choose_reload_regs (struct insn_chain *chain)\n \n \t      if (regno >= 0\n \t\t  && reg_last_reload_reg[regno] != 0\n-\t\t  && (GET_MODE_SIZE (GET_MODE (reg_last_reload_reg[regno]))\n-\t\t      >= GET_MODE_SIZE (mode) + byte)\n+\t\t  && (known_ge\n+\t\t      (GET_MODE_SIZE (GET_MODE (reg_last_reload_reg[regno])),\n+\t\t       GET_MODE_SIZE (mode) + byte))\n \t\t  /* Verify that the register it's in can be used in\n \t\t     mode MODE.  */\n \t\t  && (REG_CAN_CHANGE_MODE_P"}, {"sha": "4d037816c974da083576cb51db8ca7eb5b6e4a66", "filename": "gcc/rtl.c", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -89,7 +89,8 @@ const char * const rtx_format[NUM_RTX_CODE] = {\n      \"b\" is a pointer to a bitmap header.\n      \"B\" is a basic block pointer.\n      \"t\" is a tree pointer.\n-     \"r\" a register.  */\n+     \"r\" a register.\n+     \"p\" is a poly_uint16 offset.  */\n \n #define DEF_RTL_EXPR(ENUM, NAME, FORMAT, CLASS)   FORMAT ,\n #include \"rtl.def\"\t\t/* rtl expressions are defined here */\n@@ -346,6 +347,7 @@ copy_rtx (rtx orig)\n       case 't':\n       case 'w':\n       case 'i':\n+      case 'p':\n       case 's':\n       case 'S':\n       case 'T':\n@@ -500,6 +502,11 @@ rtx_equal_p_cb (const_rtx x, const_rtx y, rtx_equal_p_callback_function cb)\n \t    }\n \t  break;\n \n+\tcase 'p':\n+\t  if (maybe_ne (SUBREG_BYTE (x), SUBREG_BYTE (y)))\n+\t    return 0;\n+\t  break;\n+\n \tcase 'V':\n \tcase 'E':\n \t  /* Two vectors must have the same length.  */\n@@ -637,6 +644,11 @@ rtx_equal_p (const_rtx x, const_rtx y)\n \t    }\n \t  break;\n \n+\tcase 'p':\n+\t  if (maybe_ne (SUBREG_BYTE (x), SUBREG_BYTE (y)))\n+\t    return 0;\n+\t  break;\n+\n \tcase 'V':\n \tcase 'E':\n \t  /* Two vectors must have the same length.  */"}, {"sha": "ea08f7caf070a39b7e988ee16b0b07fd81958657", "filename": "gcc/rtl.def", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -394,7 +394,7 @@ DEF_RTL_EXPR(SCRATCH, \"scratch\", \"\", RTX_OBJ)\n \n /* A reference to a part of another value.  The first operand is the\n    complete value and the second is the byte offset of the selected part.   */\n-DEF_RTL_EXPR(SUBREG, \"subreg\", \"ei\", RTX_EXTRA)\n+DEF_RTL_EXPR(SUBREG, \"subreg\", \"ep\", RTX_EXTRA)\n \n /* This one-argument rtx is used for move instructions\n    that are guaranteed to alter only the low part of a destination."}, {"sha": "df410789d2b4528496db3c84d3be759a7b9048d3", "filename": "gcc/rtl.h", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -198,6 +198,7 @@ union rtunion\n {\n   int rt_int;\n   unsigned int rt_uint;\n+  poly_uint16_pod rt_subreg;\n   const char *rt_str;\n   rtx rt_rtx;\n   rtvec rt_rtvec;\n@@ -1335,6 +1336,7 @@ extern void rtl_check_failed_flag (const char *, const_rtx, const char *,\n \n #define XCINT(RTX, N, C)      (RTL_CHECKC1 (RTX, N, C).rt_int)\n #define XCUINT(RTX, N, C)     (RTL_CHECKC1 (RTX, N, C).rt_uint)\n+#define XCSUBREG(RTX, N, C)   (RTL_CHECKC1 (RTX, N, C).rt_subreg)\n #define XCSTR(RTX, N, C)      (RTL_CHECKC1 (RTX, N, C).rt_str)\n #define XCEXP(RTX, N, C)      (RTL_CHECKC1 (RTX, N, C).rt_rtx)\n #define XCVEC(RTX, N, C)      (RTL_CHECKC1 (RTX, N, C).rt_rtvec)\n@@ -1963,7 +1965,7 @@ set_regno_raw (rtx x, unsigned int regno, unsigned int nregs)\n    SUBREG_BYTE extracts the byte-number.  */\n \n #define SUBREG_REG(RTX) XCEXP (RTX, 0, SUBREG)\n-#define SUBREG_BYTE(RTX) XCUINT (RTX, 1, SUBREG)\n+#define SUBREG_BYTE(RTX) XCSUBREG (RTX, 1, SUBREG)\n \n /* in rtlanal.c */\n /* Return the right cost to give to an operation\n@@ -2036,19 +2038,19 @@ costs_add_n_insns (struct full_rtx_costs *c, int n)\n    offset     == the SUBREG_BYTE\n    outer_mode == the mode of the SUBREG itself.  */\n struct subreg_shape {\n-  subreg_shape (machine_mode, unsigned int, machine_mode);\n+  subreg_shape (machine_mode, poly_uint16, machine_mode);\n   bool operator == (const subreg_shape &) const;\n   bool operator != (const subreg_shape &) const;\n-  unsigned int unique_id () const;\n+  unsigned HOST_WIDE_INT unique_id () const;\n \n   machine_mode inner_mode;\n-  unsigned int offset;\n+  poly_uint16 offset;\n   machine_mode outer_mode;\n };\n \n inline\n subreg_shape::subreg_shape (machine_mode inner_mode_in,\n-\t\t\t    unsigned int offset_in,\n+\t\t\t    poly_uint16 offset_in,\n \t\t\t    machine_mode outer_mode_in)\n   : inner_mode (inner_mode_in), offset (offset_in), outer_mode (outer_mode_in)\n {}\n@@ -2057,7 +2059,7 @@ inline bool\n subreg_shape::operator == (const subreg_shape &other) const\n {\n   return (inner_mode == other.inner_mode\n-\t  && offset == other.offset\n+\t  && known_eq (offset, other.offset)\n \t  && outer_mode == other.outer_mode);\n }\n \n@@ -2072,11 +2074,16 @@ subreg_shape::operator != (const subreg_shape &other) const\n    current mode is anywhere near being 65536 bytes in size, so the\n    id comfortably fits in an int.  */\n \n-inline unsigned int\n+inline unsigned HOST_WIDE_INT\n subreg_shape::unique_id () const\n {\n-  STATIC_ASSERT (MAX_MACHINE_MODE <= 256);\n-  return (int) inner_mode + ((int) outer_mode << 8) + (offset << 16);\n+  { STATIC_ASSERT (MAX_MACHINE_MODE <= 256); }\n+  { STATIC_ASSERT (NUM_POLY_INT_COEFFS <= 3); }\n+  { STATIC_ASSERT (sizeof (offset.coeffs[0]) <= 2); }\n+  int res = (int) inner_mode + ((int) outer_mode << 8);\n+  for (int i = 0; i < NUM_POLY_INT_COEFFS; ++i)\n+    res += (HOST_WIDE_INT) offset.coeffs[i] << ((1 + i) * 16);\n+  return res;\n }\n \n /* Return the shape of a SUBREG rtx.  */\n@@ -2330,11 +2337,10 @@ extern int rtx_cost (rtx, machine_mode, enum rtx_code, int, bool);\n extern int address_cost (rtx, machine_mode, addr_space_t, bool);\n extern void get_full_rtx_cost (rtx, machine_mode, enum rtx_code, int,\n \t\t\t       struct full_rtx_costs *);\n-extern unsigned int subreg_lsb (const_rtx);\n-extern unsigned int subreg_lsb_1 (machine_mode, machine_mode,\n-\t\t\t\t  unsigned int);\n-extern unsigned int subreg_size_offset_from_lsb (unsigned int, unsigned int,\n-\t\t\t\t\t\t unsigned int);\n+extern poly_uint64 subreg_lsb (const_rtx);\n+extern poly_uint64 subreg_lsb_1 (machine_mode, machine_mode, poly_uint64);\n+extern poly_uint64 subreg_size_offset_from_lsb (poly_uint64, poly_uint64,\n+\t\t\t\t\t\tpoly_uint64);\n extern bool read_modify_subreg_p (const_rtx);\n \n /* Return the subreg byte offset for a subreg whose outer mode is\n@@ -2343,22 +2349,22 @@ extern bool read_modify_subreg_p (const_rtx);\n    the inner value.  This is the inverse of subreg_lsb_1 (which converts\n    byte offsets to bit shifts).  */\n \n-inline unsigned int\n+inline poly_uint64\n subreg_offset_from_lsb (machine_mode outer_mode,\n \t\t\tmachine_mode inner_mode,\n-\t\t\tunsigned int lsb_shift)\n+\t\t\tpoly_uint64 lsb_shift)\n {\n   return subreg_size_offset_from_lsb (GET_MODE_SIZE (outer_mode),\n \t\t\t\t      GET_MODE_SIZE (inner_mode), lsb_shift);\n }\n \n-extern unsigned int subreg_regno_offset\t(unsigned int, machine_mode,\n-\t\t\t\t\t unsigned int, machine_mode);\n+extern unsigned int subreg_regno_offset (unsigned int, machine_mode,\n+\t\t\t\t\t poly_uint64, machine_mode);\n extern bool subreg_offset_representable_p (unsigned int, machine_mode,\n-\t\t\t\t\t   unsigned int, machine_mode);\n+\t\t\t\t\t   poly_uint64, machine_mode);\n extern unsigned int subreg_regno (const_rtx);\n extern int simplify_subreg_regno (unsigned int, machine_mode,\n-\t\t\t\t  unsigned int, machine_mode);\n+\t\t\t\t  poly_uint64, machine_mode);\n extern unsigned int subreg_nregs (const_rtx);\n extern unsigned int subreg_nregs_with_regno (unsigned int, const_rtx);\n extern unsigned HOST_WIDE_INT nonzero_bits (const_rtx, machine_mode);\n@@ -3042,7 +3048,7 @@ extern rtx operand_subword (rtx, unsigned int, int, machine_mode);\n /* In emit-rtl.c */\n extern rtx operand_subword_force (rtx, unsigned int, machine_mode);\n extern int subreg_lowpart_p (const_rtx);\n-extern unsigned int subreg_size_lowpart_offset (unsigned int, unsigned int);\n+extern poly_uint64 subreg_size_lowpart_offset (poly_uint64, poly_uint64);\n \n /* Return true if a subreg of mode OUTERMODE would only access part of\n    an inner register with mode INNERMODE.  The other bits of the inner\n@@ -3089,7 +3095,7 @@ paradoxical_subreg_p (const_rtx x)\n \n /* Return the SUBREG_BYTE for an OUTERMODE lowpart of an INNERMODE value.  */\n \n-inline unsigned int\n+inline poly_uint64\n subreg_lowpart_offset (machine_mode outermode, machine_mode innermode)\n {\n   return subreg_size_lowpart_offset (GET_MODE_SIZE (outermode),\n@@ -3124,20 +3130,21 @@ wider_subreg_mode (const_rtx x)\n   return wider_subreg_mode (GET_MODE (x), GET_MODE (SUBREG_REG (x)));\n }\n \n-extern unsigned int subreg_size_highpart_offset (unsigned int, unsigned int);\n+extern poly_uint64 subreg_size_highpart_offset (poly_uint64, poly_uint64);\n \n /* Return the SUBREG_BYTE for an OUTERMODE highpart of an INNERMODE value.  */\n \n-inline unsigned int\n+inline poly_uint64\n subreg_highpart_offset (machine_mode outermode, machine_mode innermode)\n {\n   return subreg_size_highpart_offset (GET_MODE_SIZE (outermode),\n \t\t\t\t      GET_MODE_SIZE (innermode));\n }\n \n-extern int byte_lowpart_offset (machine_mode, machine_mode);\n-extern int subreg_memory_offset (machine_mode, machine_mode, unsigned int);\n-extern int subreg_memory_offset (const_rtx);\n+extern poly_int64 byte_lowpart_offset (machine_mode, machine_mode);\n+extern poly_int64 subreg_memory_offset (machine_mode, machine_mode,\n+\t\t\t\t\tpoly_uint64);\n+extern poly_int64 subreg_memory_offset (const_rtx);\n extern rtx make_safe_from (rtx, rtx);\n extern rtx convert_memory_address_addr_space_1 (scalar_int_mode, rtx,\n \t\t\t\t\t\taddr_space_t, bool, bool);\n@@ -3289,16 +3296,8 @@ extern rtx simplify_gen_ternary (enum rtx_code, machine_mode,\n \t\t\t\t machine_mode, rtx, rtx, rtx);\n extern rtx simplify_gen_relational (enum rtx_code, machine_mode,\n \t\t\t\t    machine_mode, rtx, rtx);\n-extern rtx simplify_subreg (machine_mode, rtx, machine_mode,\n-\t\t\t    unsigned int);\n-extern rtx simplify_gen_subreg (machine_mode, rtx, machine_mode,\n-\t\t\t\tunsigned int);\n-inline rtx\n-simplify_gen_subreg (machine_mode omode, rtx x, machine_mode imode,\n-\t\t     poly_uint64 offset)\n-{\n-  return simplify_gen_subreg (omode, x, imode, offset.to_constant ());\n-}\n+extern rtx simplify_subreg (machine_mode, rtx, machine_mode, poly_uint64);\n+extern rtx simplify_gen_subreg (machine_mode, rtx, machine_mode, poly_uint64);\n extern rtx lowpart_subreg (machine_mode, rtx, machine_mode);\n extern rtx simplify_replace_fn_rtx (rtx, const_rtx,\n \t\t\t\t    rtx (*fn) (rtx, const_rtx, void *), void *);\n@@ -3484,7 +3483,7 @@ struct subreg_info\n };\n \n extern void subreg_get_info (unsigned int, machine_mode,\n-\t\t\t     unsigned int, machine_mode,\n+\t\t\t     poly_uint64, machine_mode,\n \t\t\t     struct subreg_info *);\n \n /* lists.c */\n@@ -3722,7 +3721,7 @@ extern rtx gen_rtx_CONST_VECTOR (machine_mode, rtvec);\n extern void set_mode_and_regno (rtx, machine_mode, unsigned int);\n extern rtx gen_raw_REG (machine_mode, unsigned int);\n extern rtx gen_rtx_REG (machine_mode, unsigned int);\n-extern rtx gen_rtx_SUBREG (machine_mode, rtx, int);\n+extern rtx gen_rtx_SUBREG (machine_mode, rtx, poly_uint64);\n extern rtx gen_rtx_MEM (machine_mode, rtx);\n extern rtx gen_rtx_VAR_LOCATION (machine_mode, tree, rtx,\n \t\t\t\t enum var_init_status);\n@@ -3939,7 +3938,7 @@ extern rtx gen_const_mem (machine_mode, rtx);\n extern rtx gen_frame_mem (machine_mode, rtx);\n extern rtx gen_tmp_stack_mem (machine_mode, rtx);\n extern bool validate_subreg (machine_mode, machine_mode,\n-\t\t\t     const_rtx, unsigned int);\n+\t\t\t     const_rtx, poly_uint64);\n \n /* In combine.c  */\n extern unsigned int extended_count (const_rtx, machine_mode, int);"}, {"sha": "5a9da9e47c233cdc421317651884bb60b46230c9", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 79, "deletions": 59, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -1586,7 +1586,7 @@ set_noop_p (const_rtx set)\n \n   if (GET_CODE (src) == SUBREG && GET_CODE (dst) == SUBREG)\n     {\n-      if (SUBREG_BYTE (src) != SUBREG_BYTE (dst))\n+      if (maybe_ne (SUBREG_BYTE (src), SUBREG_BYTE (dst)))\n \treturn 0;\n       src = SUBREG_REG (src);\n       dst = SUBREG_REG (dst);\n@@ -3557,48 +3557,50 @@ loc_mentioned_in_p (rtx *loc, const_rtx in)\n    and SUBREG_BYTE, return the bit offset where the subreg begins\n    (counting from the least significant bit of the operand).  */\n \n-unsigned int\n+poly_uint64\n subreg_lsb_1 (machine_mode outer_mode,\n \t      machine_mode inner_mode,\n-\t      unsigned int subreg_byte)\n+\t      poly_uint64 subreg_byte)\n {\n-  unsigned int bitpos;\n-  unsigned int byte;\n-  unsigned int word;\n+  poly_uint64 subreg_end, trailing_bytes, byte_pos;\n \n   /* A paradoxical subreg begins at bit position 0.  */\n   if (paradoxical_subreg_p (outer_mode, inner_mode))\n     return 0;\n \n-  if (WORDS_BIG_ENDIAN != BYTES_BIG_ENDIAN)\n-    /* If the subreg crosses a word boundary ensure that\n-       it also begins and ends on a word boundary.  */\n-    gcc_assert (!((subreg_byte % UNITS_PER_WORD\n-\t\t  + GET_MODE_SIZE (outer_mode)) > UNITS_PER_WORD\n-\t\t  && (subreg_byte % UNITS_PER_WORD\n-\t\t      || GET_MODE_SIZE (outer_mode) % UNITS_PER_WORD)));\n-\n-  if (WORDS_BIG_ENDIAN)\n-    word = (GET_MODE_SIZE (inner_mode)\n-\t    - (subreg_byte + GET_MODE_SIZE (outer_mode))) / UNITS_PER_WORD;\n-  else\n-    word = subreg_byte / UNITS_PER_WORD;\n-  bitpos = word * BITS_PER_WORD;\n-\n-  if (BYTES_BIG_ENDIAN)\n-    byte = (GET_MODE_SIZE (inner_mode)\n-\t    - (subreg_byte + GET_MODE_SIZE (outer_mode))) % UNITS_PER_WORD;\n+  subreg_end = subreg_byte + GET_MODE_SIZE (outer_mode);\n+  trailing_bytes = GET_MODE_SIZE (inner_mode) - subreg_end;\n+  if (WORDS_BIG_ENDIAN && BYTES_BIG_ENDIAN)\n+    byte_pos = trailing_bytes;\n+  else if (!WORDS_BIG_ENDIAN && !BYTES_BIG_ENDIAN)\n+    byte_pos = subreg_byte;\n   else\n-    byte = subreg_byte % UNITS_PER_WORD;\n-  bitpos += byte * BITS_PER_UNIT;\n+    {\n+      /* When bytes and words have opposite endianness, we must be able\n+\t to split offsets into words and bytes at compile time.  */\n+      poly_uint64 leading_word_part\n+\t= force_align_down (subreg_byte, UNITS_PER_WORD);\n+      poly_uint64 trailing_word_part\n+\t= force_align_down (trailing_bytes, UNITS_PER_WORD);\n+      /* If the subreg crosses a word boundary ensure that\n+\t it also begins and ends on a word boundary.  */\n+      gcc_assert (known_le (subreg_end - leading_word_part,\n+\t\t\t    (unsigned int) UNITS_PER_WORD)\n+\t\t  || (known_eq (leading_word_part, subreg_byte)\n+\t\t      && known_eq (trailing_word_part, trailing_bytes)));\n+      if (WORDS_BIG_ENDIAN)\n+\tbyte_pos = trailing_word_part + (subreg_byte - leading_word_part);\n+      else\n+\tbyte_pos = leading_word_part + (trailing_bytes - trailing_word_part);\n+    }\n \n-  return bitpos;\n+  return byte_pos * BITS_PER_UNIT;\n }\n \n /* Given a subreg X, return the bit offset where the subreg begins\n    (counting from the least significant bit of the reg).  */\n \n-unsigned int\n+poly_uint64\n subreg_lsb (const_rtx x)\n {\n   return subreg_lsb_1 (GET_MODE (x), GET_MODE (SUBREG_REG (x)),\n@@ -3611,29 +3613,32 @@ subreg_lsb (const_rtx x)\n    lsb of the inner value.  This is the inverse of the calculation\n    performed by subreg_lsb_1 (which converts byte offsets to bit shifts).  */\n \n-unsigned int\n-subreg_size_offset_from_lsb (unsigned int outer_bytes,\n-\t\t\t     unsigned int inner_bytes,\n-\t\t\t     unsigned int lsb_shift)\n+poly_uint64\n+subreg_size_offset_from_lsb (poly_uint64 outer_bytes, poly_uint64 inner_bytes,\n+\t\t\t     poly_uint64 lsb_shift)\n {\n   /* A paradoxical subreg begins at bit position 0.  */\n-  if (outer_bytes > inner_bytes)\n+  gcc_checking_assert (ordered_p (outer_bytes, inner_bytes));\n+  if (maybe_gt (outer_bytes, inner_bytes))\n     {\n-      gcc_checking_assert (lsb_shift == 0);\n+      gcc_checking_assert (known_eq (lsb_shift, 0U));\n       return 0;\n     }\n \n-  gcc_assert (lsb_shift % BITS_PER_UNIT == 0);\n-  unsigned int lower_bytes = lsb_shift / BITS_PER_UNIT;\n-  unsigned int upper_bytes = inner_bytes - (lower_bytes + outer_bytes);\n+  poly_uint64 lower_bytes = exact_div (lsb_shift, BITS_PER_UNIT);\n+  poly_uint64 upper_bytes = inner_bytes - (lower_bytes + outer_bytes);\n   if (WORDS_BIG_ENDIAN && BYTES_BIG_ENDIAN)\n     return upper_bytes;\n   else if (!WORDS_BIG_ENDIAN && !BYTES_BIG_ENDIAN)\n     return lower_bytes;\n   else\n     {\n-      unsigned int lower_word_part = lower_bytes & -UNITS_PER_WORD;\n-      unsigned int upper_word_part = upper_bytes & -UNITS_PER_WORD;\n+      /* When bytes and words have opposite endianness, we must be able\n+\t to split offsets into words and bytes at compile time.  */\n+      poly_uint64 lower_word_part = force_align_down (lower_bytes,\n+\t\t\t\t\t\t      UNITS_PER_WORD);\n+      poly_uint64 upper_word_part = force_align_down (upper_bytes,\n+\t\t\t\t\t\t      UNITS_PER_WORD);\n       if (WORDS_BIG_ENDIAN)\n \treturn upper_word_part + (lower_bytes - lower_word_part);\n       else\n@@ -3662,7 +3667,7 @@ subreg_size_offset_from_lsb (unsigned int outer_bytes,\n \n void\n subreg_get_info (unsigned int xregno, machine_mode xmode,\n-\t\t unsigned int offset, machine_mode ymode,\n+\t\t poly_uint64 offset, machine_mode ymode,\n \t\t struct subreg_info *info)\n {\n   unsigned int nregs_xmode, nregs_ymode;\n@@ -3679,6 +3684,9 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n      at least one register.  */\n   if (HARD_REGNO_NREGS_HAS_PADDING (xregno, xmode))\n     {\n+      /* As a consequence, we must be dealing with a constant number of\n+\t scalars, and thus a constant offset.  */\n+      HOST_WIDE_INT coffset = offset.to_constant ();\n       nregs_xmode = HARD_REGNO_NREGS_WITH_PADDING (xregno, xmode);\n       unsigned int nunits = GET_MODE_NUNITS (xmode);\n       scalar_mode xmode_unit = GET_MODE_INNER (xmode);\n@@ -3697,9 +3705,9 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n \t 3 for each part, but in memory it's two 128-bit parts.\n \t Padding is assumed to be at the end (not necessarily the 'high part')\n \t of each unit.  */\n-      if ((offset / GET_MODE_SIZE (xmode_unit) + 1 < nunits)\n-\t  && (offset / GET_MODE_SIZE (xmode_unit)\n-\t      != ((offset + ysize - 1) / GET_MODE_SIZE (xmode_unit))))\n+      if ((coffset / GET_MODE_SIZE (xmode_unit) + 1 < nunits)\n+\t  && (coffset / GET_MODE_SIZE (xmode_unit)\n+\t      != ((coffset + ysize - 1) / GET_MODE_SIZE (xmode_unit))))\n \t{\n \t  info->representable_p = false;\n \t  rknown = true;\n@@ -3711,7 +3719,7 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n   nregs_ymode = hard_regno_nregs (xregno, ymode);\n \n   /* Paradoxical subregs are otherwise valid.  */\n-  if (!rknown && offset == 0 && ysize > xsize)\n+  if (!rknown && known_eq (offset, 0U) && ysize > xsize)\n     {\n       info->representable_p = true;\n       /* If this is a big endian paradoxical subreg, which uses more\n@@ -3746,43 +3754,50 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n \t{\n \t  info->representable_p = false;\n \t  info->nregs = CEIL (ysize, regsize_xmode);\n-\t  info->offset = offset / regsize_xmode;\n+\t  if (!can_div_trunc_p (offset, regsize_xmode, &info->offset))\n+\t    /* Checked by validate_subreg.  We must know at compile time\n+\t       which inner registers are being accessed.  */\n+\t    gcc_unreachable ();\n \t  return;\n \t}\n       /* It's not valid to extract a subreg of mode YMODE at OFFSET that\n \t would go outside of XMODE.  */\n-      if (!rknown && ysize + offset > xsize)\n+      if (!rknown && maybe_gt (ysize + offset, xsize))\n \t{\n \t  info->representable_p = false;\n \t  info->nregs = nregs_ymode;\n-\t  info->offset = offset / regsize_xmode;\n+\t  if (!can_div_trunc_p (offset, regsize_xmode, &info->offset))\n+\t    /* Checked by validate_subreg.  We must know at compile time\n+\t       which inner registers are being accessed.  */\n+\t    gcc_unreachable ();\n \t  return;\n \t}\n       /* Quick exit for the simple and common case of extracting whole\n \t subregisters from a multiregister value.  */\n       /* ??? It would be better to integrate this into the code below,\n \t if we can generalize the concept enough and figure out how\n \t odd-sized modes can coexist with the other weird cases we support.  */\n+      HOST_WIDE_INT count;\n       if (!rknown\n \t  && WORDS_BIG_ENDIAN == REG_WORDS_BIG_ENDIAN\n \t  && regsize_xmode == regsize_ymode\n-\t  && (offset % regsize_ymode) == 0)\n+\t  && constant_multiple_p (offset, regsize_ymode, &count))\n \t{\n \t  info->representable_p = true;\n \t  info->nregs = nregs_ymode;\n-\t  info->offset = offset / regsize_ymode;\n+\t  info->offset = count;\n \t  gcc_assert (info->offset + info->nregs <= (int) nregs_xmode);\n \t  return;\n \t}\n     }\n \n   /* Lowpart subregs are otherwise valid.  */\n-  if (!rknown && offset == subreg_lowpart_offset (ymode, xmode))\n+  if (!rknown && known_eq (offset, subreg_lowpart_offset (ymode, xmode)))\n     {\n       info->representable_p = true;\n       rknown = true;\n \n-      if (offset == 0 || nregs_xmode == nregs_ymode)\n+      if (known_eq (offset, 0U) || nregs_xmode == nregs_ymode)\n \t{\n \t  info->offset = 0;\n \t  info->nregs = nregs_ymode;\n@@ -3803,19 +3818,24 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n      These conditions may be relaxed but subreg_regno_offset would\n      need to be redesigned.  */\n   gcc_assert ((xsize % num_blocks) == 0);\n-  unsigned int bytes_per_block = xsize / num_blocks;\n+  poly_uint64 bytes_per_block = xsize / num_blocks;\n \n   /* Get the number of the first block that contains the subreg and the byte\n      offset of the subreg from the start of that block.  */\n-  unsigned int block_number = offset / bytes_per_block;\n-  unsigned int subblock_offset = offset % bytes_per_block;\n+  unsigned int block_number;\n+  poly_uint64 subblock_offset;\n+  if (!can_div_trunc_p (offset, bytes_per_block, &block_number,\n+\t\t\t&subblock_offset))\n+    /* Checked by validate_subreg.  We must know at compile time which\n+       inner registers are being accessed.  */\n+    gcc_unreachable ();\n \n   if (!rknown)\n     {\n       /* Only the lowpart of each block is representable.  */\n       info->representable_p\n-\t= (subblock_offset\n-\t   == subreg_size_lowpart_offset (ysize, bytes_per_block));\n+\t= known_eq (subblock_offset,\n+\t\t    subreg_size_lowpart_offset (ysize, bytes_per_block));\n       rknown = true;\n     }\n \n@@ -3842,7 +3862,7 @@ subreg_get_info (unsigned int xregno, machine_mode xmode,\n    RETURN - The regno offset which would be used.  */\n unsigned int\n subreg_regno_offset (unsigned int xregno, machine_mode xmode,\n-\t\t     unsigned int offset, machine_mode ymode)\n+\t\t     poly_uint64 offset, machine_mode ymode)\n {\n   struct subreg_info info;\n   subreg_get_info (xregno, xmode, offset, ymode, &info);\n@@ -3858,7 +3878,7 @@ subreg_regno_offset (unsigned int xregno, machine_mode xmode,\n    RETURN - Whether the offset is representable.  */\n bool\n subreg_offset_representable_p (unsigned int xregno, machine_mode xmode,\n-\t\t\t       unsigned int offset, machine_mode ymode)\n+\t\t\t       poly_uint64 offset, machine_mode ymode)\n {\n   struct subreg_info info;\n   subreg_get_info (xregno, xmode, offset, ymode, &info);\n@@ -3875,7 +3895,7 @@ subreg_offset_representable_p (unsigned int xregno, machine_mode xmode,\n \n int\n simplify_subreg_regno (unsigned int xregno, machine_mode xmode,\n-\t\t       unsigned int offset, machine_mode ymode)\n+\t\t       poly_uint64 offset, machine_mode ymode)\n {\n   struct subreg_info info;\n   unsigned int yregno;"}, {"sha": "8cb496afafb28355c32b2697eea1a0ef6ad2917a", "filename": "gcc/rtlhash.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Frtlhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Frtlhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlhash.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -87,6 +87,9 @@ add_rtx (const_rtx x, hash &hstate)\n       case 'i':\n \thstate.add_int (XINT (x, i));\n \tbreak;\n+      case 'p':\n+\thstate.add_poly_int (SUBREG_BYTE (x));\n+\tbreak;\n       case 'V':\n       case 'E':\n \tj = XVECLEN (x, i);"}, {"sha": "7214e764bf5d3d8a5af82d0fe3fdbd26b8f3e2fc", "filename": "gcc/rtlhooks.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Frtlhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Frtlhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlhooks.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -70,7 +70,7 @@ gen_lowpart_general (machine_mode mode, rtx x)\n \t  && !reload_completed)\n \treturn gen_lowpart_general (mode, force_reg (xmode, x));\n \n-      HOST_WIDE_INT offset = byte_lowpart_offset (mode, GET_MODE (x));\n+      poly_int64 offset = byte_lowpart_offset (mode, GET_MODE (x));\n       return adjust_address (x, mode, offset);\n     }\n }\n@@ -115,7 +115,7 @@ gen_lowpart_if_possible (machine_mode mode, rtx x)\n   else if (MEM_P (x))\n     {\n       /* This is the only other case we handle.  */\n-      HOST_WIDE_INT offset = byte_lowpart_offset (mode, GET_MODE (x));\n+      poly_int64 offset = byte_lowpart_offset (mode, GET_MODE (x));\n       rtx new_rtx = adjust_address_nv (x, mode, offset);\n       if (! memory_address_addr_space_p (mode, XEXP (new_rtx, 0),\n \t\t\t\t\t MEM_ADDR_SPACE (x)))"}, {"sha": "6feaaf78d6c02cea62c9657b8fb89810bf89399f", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 42, "deletions": 35, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -789,7 +789,7 @@ simplify_truncation (machine_mode mode, rtx op,\n       && (INTVAL (XEXP (op, 1)) & (precision - 1)) == 0\n       && UINTVAL (XEXP (op, 1)) < op_precision)\n     {\n-      int byte = subreg_lowpart_offset (mode, op_mode);\n+      poly_int64 byte = subreg_lowpart_offset (mode, op_mode);\n       int shifted_bytes = INTVAL (XEXP (op, 1)) / BITS_PER_UNIT;\n       return simplify_gen_subreg (mode, XEXP (op, 0), op_mode,\n \t\t\t\t  (WORDS_BIG_ENDIAN\n@@ -815,7 +815,7 @@ simplify_truncation (machine_mode mode, rtx op,\n       && (GET_MODE_SIZE (int_mode) >= UNITS_PER_WORD\n \t  || WORDS_BIG_ENDIAN == BYTES_BIG_ENDIAN))\n     {\n-      int byte = subreg_lowpart_offset (int_mode, int_op_mode);\n+      poly_int64 byte = subreg_lowpart_offset (int_mode, int_op_mode);\n       int shifted_bytes = INTVAL (XEXP (op, 1)) / BITS_PER_UNIT;\n       return adjust_address_nv (XEXP (op, 0), int_mode,\n \t\t\t\t(WORDS_BIG_ENDIAN\n@@ -2825,7 +2825,7 @@ simplify_binary_operation_1 (enum rtx_code code, machine_mode mode,\n           && GET_CODE (SUBREG_REG (opleft)) == ASHIFT\n           && GET_CODE (opright) == LSHIFTRT\n           && GET_CODE (XEXP (opright, 0)) == SUBREG\n-          && SUBREG_BYTE (opleft) == SUBREG_BYTE (XEXP (opright, 0))\n+\t  && known_eq (SUBREG_BYTE (opleft), SUBREG_BYTE (XEXP (opright, 0)))\n \t  && GET_MODE_SIZE (int_mode) < GET_MODE_SIZE (inner_mode)\n           && rtx_equal_p (XEXP (SUBREG_REG (opleft), 0),\n                           SUBREG_REG (XEXP (opright, 0)))\n@@ -6236,7 +6236,7 @@ simplify_immed_subreg (fixed_size_mode outermode, rtx op,\n    Return 0 if no simplifications are possible.  */\n rtx\n simplify_subreg (machine_mode outermode, rtx op,\n-\t\t machine_mode innermode, unsigned int byte)\n+\t\t machine_mode innermode, poly_uint64 byte)\n {\n   /* Little bit of sanity checking.  */\n   gcc_assert (innermode != VOIDmode);\n@@ -6247,16 +6247,16 @@ simplify_subreg (machine_mode outermode, rtx op,\n   gcc_assert (GET_MODE (op) == innermode\n \t      || GET_MODE (op) == VOIDmode);\n \n-  if ((byte % GET_MODE_SIZE (outermode)) != 0)\n+  if (!multiple_p (byte, GET_MODE_SIZE (outermode)))\n     return NULL_RTX;\n \n-  if (byte >= GET_MODE_SIZE (innermode))\n+  if (maybe_ge (byte, GET_MODE_SIZE (innermode)))\n     return NULL_RTX;\n \n-  if (outermode == innermode && !byte)\n+  if (outermode == innermode && known_eq (byte, 0U))\n     return op;\n \n-  if (byte % GET_MODE_UNIT_SIZE (innermode) == 0)\n+  if (multiple_p (byte, GET_MODE_UNIT_SIZE (innermode)))\n     {\n       rtx elt;\n \n@@ -6277,12 +6277,15 @@ simplify_subreg (machine_mode outermode, rtx op,\n     {\n       /* simplify_immed_subreg deconstructs OP into bytes and constructs\n \t the result from bytes, so it only works if the sizes of the modes\n-\t are known at compile time.  Cases that apply to general modes\n-\t should be handled here before calling simplify_immed_subreg.  */\n+\t and the value of the offset are known at compile time.  Cases that\n+\t that apply to general modes and offsets should be handled here\n+\t before calling simplify_immed_subreg.  */\n       fixed_size_mode fs_outermode, fs_innermode;\n+      unsigned HOST_WIDE_INT cbyte;\n       if (is_a <fixed_size_mode> (outermode, &fs_outermode)\n-\t  && is_a <fixed_size_mode> (innermode, &fs_innermode))\n-\treturn simplify_immed_subreg (fs_outermode, op, fs_innermode, byte);\n+\t  && is_a <fixed_size_mode> (innermode, &fs_innermode)\n+\t  && byte.is_constant (&cbyte))\n+\treturn simplify_immed_subreg (fs_outermode, op, fs_innermode, cbyte);\n \n       return NULL_RTX;\n     }\n@@ -6295,32 +6298,33 @@ simplify_subreg (machine_mode outermode, rtx op,\n       rtx newx;\n \n       if (outermode == innermostmode\n-\t  && byte == 0 && SUBREG_BYTE (op) == 0)\n+\t  && known_eq (byte, 0U)\n+\t  && known_eq (SUBREG_BYTE (op), 0))\n \treturn SUBREG_REG (op);\n \n       /* Work out the memory offset of the final OUTERMODE value relative\n \t to the inner value of OP.  */\n-      HOST_WIDE_INT mem_offset = subreg_memory_offset (outermode,\n-\t\t\t\t\t\t       innermode, byte);\n-      HOST_WIDE_INT op_mem_offset = subreg_memory_offset (op);\n-      HOST_WIDE_INT final_offset = mem_offset + op_mem_offset;\n+      poly_int64 mem_offset = subreg_memory_offset (outermode,\n+\t\t\t\t\t\t    innermode, byte);\n+      poly_int64 op_mem_offset = subreg_memory_offset (op);\n+      poly_int64 final_offset = mem_offset + op_mem_offset;\n \n       /* See whether resulting subreg will be paradoxical.  */\n       if (!paradoxical_subreg_p (outermode, innermostmode))\n \t{\n \t  /* In nonparadoxical subregs we can't handle negative offsets.  */\n-\t  if (final_offset < 0)\n+\t  if (maybe_lt (final_offset, 0))\n \t    return NULL_RTX;\n \t  /* Bail out in case resulting subreg would be incorrect.  */\n-\t  if (final_offset % GET_MODE_SIZE (outermode)\n-\t      || (unsigned) final_offset >= GET_MODE_SIZE (innermostmode))\n+\t  if (!multiple_p (final_offset, GET_MODE_SIZE (outermode))\n+\t      || maybe_ge (final_offset, GET_MODE_SIZE (innermostmode)))\n \t    return NULL_RTX;\n \t}\n       else\n \t{\n-\t  HOST_WIDE_INT required_offset\n-\t    = subreg_memory_offset (outermode, innermostmode, 0);\n-\t  if (final_offset != required_offset)\n+\t  poly_int64 required_offset = subreg_memory_offset (outermode,\n+\t\t\t\t\t\t\t     innermostmode, 0);\n+\t  if (maybe_ne (final_offset, required_offset))\n \t    return NULL_RTX;\n \t  /* Paradoxical subregs always have byte offset 0.  */\n \t  final_offset = 0;\n@@ -6373,7 +6377,7 @@ simplify_subreg (machine_mode outermode, rtx op,\n \t     The information is used only by alias analysis that can not\n \t     grog partial register anyway.  */\n \n-\t  if (subreg_lowpart_offset (outermode, innermode) == byte)\n+\t  if (known_eq (subreg_lowpart_offset (outermode, innermode), byte))\n \t    ORIGINAL_REGNO (x) = ORIGINAL_REGNO (op);\n \t  return x;\n \t}\n@@ -6398,25 +6402,28 @@ simplify_subreg (machine_mode outermode, rtx op,\n   if (GET_CODE (op) == CONCAT\n       || GET_CODE (op) == VEC_CONCAT)\n     {\n-      unsigned int part_size, final_offset;\n+      unsigned int part_size;\n+      poly_uint64 final_offset;\n       rtx part, res;\n \n       machine_mode part_mode = GET_MODE (XEXP (op, 0));\n       if (part_mode == VOIDmode)\n \tpart_mode = GET_MODE_INNER (GET_MODE (op));\n       part_size = GET_MODE_SIZE (part_mode);\n-      if (byte < part_size)\n+      if (known_lt (byte, part_size))\n \t{\n \t  part = XEXP (op, 0);\n \t  final_offset = byte;\n \t}\n-      else\n+      else if (known_ge (byte, part_size))\n \t{\n \t  part = XEXP (op, 1);\n \t  final_offset = byte - part_size;\n \t}\n+      else\n+\treturn NULL_RTX;\n \n-      if (final_offset + GET_MODE_SIZE (outermode) > part_size)\n+      if (maybe_gt (final_offset + GET_MODE_SIZE (outermode), part_size))\n \treturn NULL_RTX;\n \n       part_mode = GET_MODE (part);\n@@ -6434,15 +6441,15 @@ simplify_subreg (machine_mode outermode, rtx op,\n      it extracts higher bits that the ZERO_EXTEND's source bits.  */\n   if (GET_CODE (op) == ZERO_EXTEND && SCALAR_INT_MODE_P (innermode))\n     {\n-      unsigned int bitpos = subreg_lsb_1 (outermode, innermode, byte);\n-      if (bitpos >= GET_MODE_PRECISION (GET_MODE (XEXP (op, 0))))\n+      poly_uint64 bitpos = subreg_lsb_1 (outermode, innermode, byte);\n+      if (known_ge (bitpos, GET_MODE_PRECISION (GET_MODE (XEXP (op, 0)))))\n \treturn CONST0_RTX (outermode);\n     }\n \n   scalar_int_mode int_outermode, int_innermode;\n   if (is_a <scalar_int_mode> (outermode, &int_outermode)\n       && is_a <scalar_int_mode> (innermode, &int_innermode)\n-      && byte == subreg_lowpart_offset (int_outermode, int_innermode))\n+      && known_eq (byte, subreg_lowpart_offset (int_outermode, int_innermode)))\n     {\n       /* Handle polynomial integers.  The upper bits of a paradoxical\n \t subreg are undefined, so this is safe regardless of whether\n@@ -6472,7 +6479,7 @@ simplify_subreg (machine_mode outermode, rtx op,\n \n rtx\n simplify_gen_subreg (machine_mode outermode, rtx op,\n-\t\t     machine_mode innermode, unsigned int byte)\n+\t\t     machine_mode innermode, poly_uint64 byte)\n {\n   rtx newx;\n \n@@ -6668,7 +6675,7 @@ test_vector_ops_duplicate (machine_mode mode, rtx scalar_reg)\n \t\t\t\t\t\tduplicate, last_par));\n \n   /* Test a scalar subreg of a VEC_DUPLICATE.  */\n-  unsigned int offset = subreg_lowpart_offset (inner_mode, mode);\n+  poly_uint64 offset = subreg_lowpart_offset (inner_mode, mode);\n   ASSERT_RTX_EQ (scalar_reg,\n \t\t simplify_gen_subreg (inner_mode, duplicate,\n \t\t\t\t      mode, offset));\n@@ -6688,7 +6695,7 @@ test_vector_ops_duplicate (machine_mode mode, rtx scalar_reg)\n \t\t\t\t\t\tduplicate, vec_par));\n \n       /* Test a vector subreg of a VEC_DUPLICATE.  */\n-      unsigned int offset = subreg_lowpart_offset (narrower_mode, mode);\n+      poly_uint64 offset = subreg_lowpart_offset (narrower_mode, mode);\n       ASSERT_RTX_EQ (narrower_duplicate,\n \t\t     simplify_gen_subreg (narrower_mode, duplicate,\n \t\t\t\t\t  mode, offset));\n@@ -6801,7 +6808,7 @@ simplify_const_poly_int_tests<N>::run ()\n   rtx x10 = gen_int_mode (poly_int64 (-31, -24), HImode);\n   rtx two = GEN_INT (2);\n   rtx six = GEN_INT (6);\n-  HOST_WIDE_INT offset = subreg_lowpart_offset (QImode, HImode);\n+  poly_uint64 offset = subreg_lowpart_offset (QImode, HImode);\n \n   /* These tests only try limited operation combinations.  Fuller arithmetic\n      testing is done directly on poly_ints.  */"}, {"sha": "4abb62515999deb27abefab927a0fa9c67f5a247", "filename": "gcc/valtrack.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fvaltrack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fvaltrack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvaltrack.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -555,7 +555,7 @@ debug_lowpart_subreg (machine_mode outer_mode, rtx expr,\n {\n   if (inner_mode == VOIDmode)\n     inner_mode = GET_MODE (expr);\n-  int offset = subreg_lowpart_offset (outer_mode, inner_mode);\n+  poly_int64 offset = subreg_lowpart_offset (outer_mode, inner_mode);\n   rtx ret = simplify_gen_subreg (outer_mode, expr, inner_mode, offset);\n   if (ret)\n     return ret;"}, {"sha": "33e5a2410268590c7787d287aaf438606d743ed4", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91914e56a5e952cc87468bdd6d006e51eaa54294/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=91914e56a5e952cc87468bdd6d006e51eaa54294", "patch": "@@ -3522,6 +3522,12 @@ loc_cmp (rtx x, rtx y)\n \telse\n \t  return 1;\n \n+      case 'p':\n+\tr = compare_sizes_for_sort (SUBREG_BYTE (x), SUBREG_BYTE (y));\n+\tif (r != 0)\n+\t  return r;\n+\tbreak;\n+\n       case 'V':\n       case 'E':\n \t/* Compare the vector length first.  */\n@@ -5369,20 +5375,20 @@ track_loc_p (rtx loc, tree expr, poly_int64 offset, bool store_reg_p,\n static rtx\n var_lowpart (machine_mode mode, rtx loc)\n {\n-  unsigned int offset, reg_offset, regno;\n+  unsigned int regno;\n \n   if (GET_MODE (loc) == mode)\n     return loc;\n \n   if (!REG_P (loc) && !MEM_P (loc))\n     return NULL;\n \n-  offset = byte_lowpart_offset (mode, GET_MODE (loc));\n+  poly_uint64 offset = byte_lowpart_offset (mode, GET_MODE (loc));\n \n   if (MEM_P (loc))\n     return adjust_address_nv (loc, mode, offset);\n \n-  reg_offset = subreg_lowpart_offset (mode, GET_MODE (loc));\n+  poly_uint64 reg_offset = subreg_lowpart_offset (mode, GET_MODE (loc));\n   regno = REGNO (loc) + subreg_regno_offset (REGNO (loc), GET_MODE (loc),\n \t\t\t\t\t     reg_offset, mode);\n   return gen_rtx_REG_offset (loc, mode, regno, offset);"}]}