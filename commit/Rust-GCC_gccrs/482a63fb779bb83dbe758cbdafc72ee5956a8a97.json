{"sha": "482a63fb779bb83dbe758cbdafc72ee5956a8a97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgyYTYzZmI3NzliYjgzZGJlNzU4Y2JkYWZjNzJlZTU5NTZhOGE5Nw==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2005-03-15T16:12:58Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-03-15T16:12:58Z"}, "message": "re PR ada/15608 (Bug box at sem_ch3.adb:8228)\n\n2005-03-08  Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\tPR ada/15608\n\t* sem_util.adb (Get_Task_Body_Procedure): Type may be the completion\n\tof a private type, in which case it is underlying_type that denotes\n\tthe proper task. Also modified to use the new entity attribute\n\tthat is directly available in the task type and task subtype entities\n\t(Build_Actual_Subtype_Of_Component): Handle properly multidimensional\n\tarrays when other dimensions than the first are constrained by\n\tdiscriminants of an enclosing record.\n\t(Insert_Explicit_Dereference): If the prefix is an indexed component or\n\ta combination of indexed and selected components, find ultimate entity\n\tand generate the appropriate reference for it, to suppress spurious\n\twarnings.\n\t(Note_Possible_Modification): If an entity name has no entity, return.\n\t(Is_Variable): A function call never denotes a variable.\n\t(Requires_Transient_Scope): For record types, recurse only on\n\tcomponents, not on internal subtypes that may have been generated for\n\tconstrained components.\n\nFrom-SVN: r96504", "tree": {"sha": "4def8f97f4a7c80ada69fda1a85cba3939d9c8ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4def8f97f4a7c80ada69fda1a85cba3939d9c8ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/482a63fb779bb83dbe758cbdafc72ee5956a8a97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/482a63fb779bb83dbe758cbdafc72ee5956a8a97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/482a63fb779bb83dbe758cbdafc72ee5956a8a97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/482a63fb779bb83dbe758cbdafc72ee5956a8a97/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "89167cad83a461fd0c74d6df3a96a5cd28507469", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89167cad83a461fd0c74d6df3a96a5cd28507469", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89167cad83a461fd0c74d6df3a96a5cd28507469"}], "stats": {"total": 90, "additions": 61, "deletions": 29}, "files": [{"sha": "00fc1a19a5932e2b56f404ef2ca9edb360cafe2b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 61, "deletions": 29, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482a63fb779bb83dbe758cbdafc72ee5956a8a97/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482a63fb779bb83dbe758cbdafc72ee5956a8a97/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=482a63fb779bb83dbe758cbdafc72ee5956a8a97", "patch": "@@ -415,9 +415,9 @@ package body Sem_Util is\n \n       if Ekind (Deaccessed_T) = E_Array_Subtype then\n          Id := First_Index (Deaccessed_T);\n-         Indx_Type := Underlying_Type (Etype (Id));\n \n          while Present (Id) loop\n+            Indx_Type := Underlying_Type (Etype (Id));\n \n             if Denotes_Discriminant (Type_Low_Bound  (Indx_Type)) or else\n                Denotes_Discriminant (Type_High_Bound (Indx_Type))\n@@ -2697,7 +2697,13 @@ package body Sem_Util is\n \n    function Get_Task_Body_Procedure (E : Entity_Id) return Node_Id is\n    begin\n-      return Task_Body_Procedure (Declaration_Node (Root_Type (E)));\n+      --  Note: A task type may be the completion of a private type with\n+      --  discriminants. when performing elaboration checks on a task\n+      --  declaration, the current view of the type may be the private one,\n+      --  and the procedure that holds the body of the task is held in its\n+      --  underlying type.\n+\n+      return Task_Body_Procedure (Underlying_Type (Root_Type (E)));\n    end Get_Task_Body_Procedure;\n \n    -----------------------\n@@ -3136,6 +3142,7 @@ package body Sem_Util is\n    procedure Insert_Explicit_Dereference (N : Node_Id) is\n       New_Prefix : constant Node_Id := Relocate_Node (N);\n       Ent        : Entity_Id := Empty;\n+      Pref       : Node_Id;\n       I          : Interp_Index;\n       It         : Interp;\n       T          : Entity_Id;\n@@ -3174,8 +3181,26 @@ package body Sem_Util is\n \n          if Is_Entity_Name (New_Prefix) then\n             Ent := Entity (New_Prefix);\n-         elsif Nkind (New_Prefix) = N_Selected_Component then\n-            Ent := Entity (Selector_Name (New_Prefix));\n+\n+         --  For a retrieval of a subcomponent of some composite object,\n+         --  retrieve the ultimate entity if there is one.\n+\n+         elsif Nkind (New_Prefix) = N_Selected_Component\n+           or else Nkind (New_Prefix) = N_Indexed_Component\n+         then\n+            Pref := Prefix (New_Prefix);\n+\n+            while Present (Pref)\n+              and then\n+                (Nkind (Pref) = N_Selected_Component\n+                  or else Nkind (Pref) = N_Indexed_Component)\n+            loop\n+               Pref := Prefix (Pref);\n+            end loop;\n+\n+            if Present (Pref) and then Is_Entity_Name (Pref) then\n+               Ent := Entity (Pref);\n+            end if;\n          end if;\n \n          if Present (Ent) then\n@@ -3532,7 +3557,6 @@ package body Sem_Util is\n \n    function Is_Dereferenced (N : Node_Id) return Boolean is\n       P : constant Node_Id := Parent (N);\n-\n    begin\n       return\n          (Nkind (P) = N_Selected_Component\n@@ -3916,7 +3940,6 @@ package body Sem_Util is\n \n    function Is_Inherited_Operation (E : Entity_Id) return Boolean is\n       Kind : constant Node_Kind := Nkind (Parent (E));\n-\n    begin\n       pragma Assert (Is_Overloadable (E));\n       return Kind = N_Full_Type_Declaration\n@@ -4325,8 +4348,7 @@ package body Sem_Util is\n       D : Entity_Id;\n \n       function Comes_From_Limited_Private_Type_Declaration\n-        (E    : Entity_Id)\n-         return Boolean;\n+        (E : Entity_Id) return Boolean;\n       --  Check that the type is declared by a limited type declaration,\n       --  or else is derived from a Remote_Type ancestor through private\n       --  extensions.\n@@ -4335,10 +4357,11 @@ package body Sem_Util is\n       -- Comes_From_Limited_Private_Type_Declaration --\n       -------------------------------------------------\n \n-      function Comes_From_Limited_Private_Type_Declaration (E : in Entity_Id)\n-        return Boolean\n+      function Comes_From_Limited_Private_Type_Declaration\n+        (E : Entity_Id) return Boolean\n       is\n          N : constant Node_Id := Declaration_Node (E);\n+\n       begin\n          if Nkind (N) = N_Private_Type_Declaration\n            and then Limited_Present (N)\n@@ -4415,7 +4438,7 @@ package body Sem_Util is\n \n       elsif Nkind (Name (N)) = N_Explicit_Dereference\n         and then Is_Remote_Access_To_Subprogram_Type\n-          (Etype (Prefix (Name (N))))\n+                   (Etype (Prefix (Name (N))))\n       then\n          --  The dereference of a RAS is a remote call\n \n@@ -4441,13 +4464,11 @@ package body Sem_Util is\n    ----------------------\n \n    function Is_Selector_Name (N : Node_Id) return Boolean is\n-\n    begin\n       if not Is_List_Member (N) then\n          declare\n             P : constant Node_Id   := Parent (N);\n             K : constant Node_Kind := Nkind (P);\n-\n          begin\n             return\n               (K = N_Expanded_Name          or else\n@@ -4461,7 +4482,6 @@ package body Sem_Util is\n          declare\n             L : constant List_Id := List_Containing (N);\n             P : constant Node_Id := Parent (L);\n-\n          begin\n             return (Nkind (P) = N_Discriminant_Association\n                      and then Selector_Names (P) = L)\n@@ -4566,9 +4586,7 @@ package body Sem_Util is\n             return False;\n          else\n             S := Current_Scope;\n-\n             while Present (S) and then S /= Prot loop\n-\n                if Ekind (S) = E_Function\n                  and then Scope (S) = Prot\n                then\n@@ -4629,6 +4647,11 @@ package body Sem_Util is\n       then\n          return Is_Variable_Prefix (Original_Node (Prefix (N)));\n \n+      --  A function call is never a variable\n+\n+      elsif Nkind (N) = N_Function_Call then\n+         return False;\n+\n       --  All remaining checks use the original node\n \n       elsif Is_Entity_Name (Orig_Node) then\n@@ -4667,7 +4690,6 @@ package body Sem_Util is\n             when N_Explicit_Dereference =>\n                declare\n                   Typ : constant Entity_Id := Etype (Prefix (Orig_Node));\n-\n                begin\n                   return Is_Access_Type (Typ)\n                     and then not Is_Access_Constant (Root_Type (Typ))\n@@ -5277,6 +5299,13 @@ package body Sem_Util is\n          if Is_Entity_Name (Exp) then\n             Ent := Entity (Exp);\n \n+            --  If the entity is missing, it is an undeclared identifier,\n+            --  and there is nothing to annotate.\n+\n+            if No (Ent) then\n+               return;\n+            end if;\n+\n          elsif Nkind (Exp) = N_Explicit_Dereference then\n             declare\n                P : constant Node_Id := Prefix (Exp);\n@@ -5883,7 +5912,9 @@ package body Sem_Util is\n             begin\n                Comp := First_Entity (Typ);\n                while Present (Comp) loop\n-                  if Requires_Transient_Scope (Etype (Comp)) then\n+                  if Ekind (Comp) = E_Component\n+                     and then Requires_Transient_Scope (Etype (Comp))\n+                  then\n                      return True;\n                   else\n                      Next_Entity (Comp);\n@@ -6334,7 +6365,6 @@ package body Sem_Util is\n    function Statically_Different (E1, E2 : Node_Id) return Boolean is\n       R1 : constant Node_Id := Get_Referenced_Object (E1);\n       R2 : constant Node_Id := Get_Referenced_Object (E2);\n-\n    begin\n       return     Is_Entity_Name (R1)\n         and then Is_Entity_Name (R2)\n@@ -6571,10 +6601,13 @@ package body Sem_Util is\n       Expec_Type : constant Entity_Id := First_Subtype (Expected_Type);\n \n       function Has_One_Matching_Field return Boolean;\n-      --  Determines whether Expec_Type is a record type with a single\n-      --  component or discriminant whose type matches the found type or\n-      --  is a one dimensional array whose component type matches the\n-      --  found type.\n+      --  Determines if Expec_Type is a record type with a single component or\n+      --  discriminant whose type matches the found type or is one dimensional\n+      --  array whose component type matches the found type.\n+\n+      ----------------------------\n+      -- Has_One_Matching_Field --\n+      ----------------------------\n \n       function Has_One_Matching_Field return Boolean is\n          E : Entity_Id;\n@@ -6592,7 +6625,6 @@ package body Sem_Util is\n \n          else\n             E := First_Entity (Expec_Type);\n-\n             loop\n                if No (E) then\n                   return False;\n@@ -6773,9 +6805,9 @@ package body Sem_Util is\n            and then Etype (Designated_Type (Expec_Type)) = Etype (Expr)\n            and then No (Parameter_Associations (Expr))\n          then\n-               Error_Msg_N\n-                 (\"found function name, possibly missing Access attribute!\",\n-                   Expr);\n+            Error_Msg_N\n+              (\"found function name, possibly missing Access attribute!\",\n+               Expr);\n \n          --  Catch common error: a prefix or infix operator which is not\n          --  directly visible because the type isn't.\n@@ -6787,8 +6819,8 @@ package body Sem_Util is\n             and then not In_Use (Expec_Type)\n             and then Has_Compatible_Type (Right_Opnd (Expr), Expec_Type)\n          then\n-            Error_Msg_N (\n-              \"operator of the type is not directly visible!\", Expr);\n+            Error_Msg_N\n+              (\"operator of the type is not directly visible!\", Expr);\n \n          elsif Ekind (Found_Type) = E_Void\n            and then Present (Parent (Found_Type))"}]}