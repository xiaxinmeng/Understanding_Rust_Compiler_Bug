{"sha": "92869a7b6b8dc3ad4c0e0a299ec36906c2090c8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI4NjlhN2I2YjhkYzNhZDRjMGUwYTI5OWVjMzY5MDZjMjA5MGM4Yw==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2006-10-31T17:55:55Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:55:55Z"}, "message": "exp_dist.adb (Get_Subprogram_Ids): This function will no more assign subprogram Ids, even if they are not yet assigned.\n\n2006-10-31  Thomas Quinot  <quinot@adacore.com>\n\t    Pablo Oliveira  <oliveira@adacore.com>\n        \n        * exp_dist.adb (Get_Subprogram_Ids): This function will no more assign\n\tsubprogram Ids, even if they are not yet assigned.\n\t(Build_Subprogram_Id): It is now this function that will take care of\n\tcalling Assign_Subprogram_Ids if necessary.\n\t(Add_Receiving_Stubs_To_Declarations): Checking the subprograms ids\n\tshould be done only once they are assigned.\n\t(Build_From_Any_Function, case of tagged types): Add missing call to\n\tAllocate_Buffer.\n\t(Corresponding_Stub_Type): New subprogram. Returns the associated stub\n\ttype for an RACW type.\n\t(Add_RACW_Features): When processing an RACW declaration for which the\n\tdesignated type is already frozen, enforce E.2.2(14) rules immediately.\n\t(GARLIC_Support.Build_Subprogram_Receiving_Stubs): Do not perform any\n\tspecial reordering of controlling formals.\n\n\t* exp_dist.ads (Corresponding_Stub_Type): New subprogram. Returns the\n\tassociated stub type for an RACW type.\n\nFrom-SVN: r118264", "tree": {"sha": "780930857e5be48b62644253dd43da21a95fc277", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/780930857e5be48b62644253dd43da21a95fc277"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92869a7b6b8dc3ad4c0e0a299ec36906c2090c8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92869a7b6b8dc3ad4c0e0a299ec36906c2090c8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92869a7b6b8dc3ad4c0e0a299ec36906c2090c8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92869a7b6b8dc3ad4c0e0a299ec36906c2090c8c/comments", "author": null, "committer": null, "parents": [{"sha": "108e13eb74bd925fba2a6e2e692bd1de1342fd3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/108e13eb74bd925fba2a6e2e692bd1de1342fd3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/108e13eb74bd925fba2a6e2e692bd1de1342fd3c"}], "stats": {"total": 358, "additions": 197, "deletions": 161}, "files": [{"sha": "7e79bfb0448f228c1661ca1984b016f61eedc8e4", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 194, "deletions": 161, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92869a7b6b8dc3ad4c0e0a299ec36906c2090c8c/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92869a7b6b8dc3ad4c0e0a299ec36906c2090c8c/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=92869a7b6b8dc3ad4c0e0a299ec36906c2090c8c", "patch": "@@ -24,32 +24,34 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Atree;       use Atree;\n-with Einfo;       use Einfo;\n-with Elists;      use Elists;\n-with Exp_Strm;    use Exp_Strm;\n-with Exp_Tss;     use Exp_Tss;\n-with Exp_Util;    use Exp_Util;\n+with Atree;    use Atree;\n+with Einfo;    use Einfo;\n+with Elists;   use Elists;\n+with Exp_Strm; use Exp_Strm;\n+with Exp_Tss;  use Exp_Tss;\n+with Exp_Util; use Exp_Util;\n+with Lib;      use Lib;\n+with Namet;    use Namet;\n+with Nlists;   use Nlists;\n+with Nmake;    use Nmake;\n+with Opt;      use Opt;\n+with Rtsfind;  use Rtsfind;\n+with Sem;      use Sem;\n+with Sem_Cat;  use Sem_Cat;\n+with Sem_Ch3;  use Sem_Ch3;\n+with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Dist; use Sem_Dist;\n+with Sem_Eval; use Sem_Eval;\n+with Sem_Util; use Sem_Util;\n+with Sinfo;    use Sinfo;\n+with Snames;   use Snames;\n+with Stand;    use Stand;\n+with Stringt;  use Stringt;\n+with Tbuild;   use Tbuild;\n+with Ttypes;   use Ttypes;\n+with Uintp;    use Uintp;\n+\n with GNAT.HTable; use GNAT.HTable;\n-with Lib;         use Lib;\n-with Namet;       use Namet;\n-with Nlists;      use Nlists;\n-with Nmake;       use Nmake;\n-with Opt;         use Opt;\n-with Rtsfind;     use Rtsfind;\n-with Sem;         use Sem;\n-with Sem_Ch3;     use Sem_Ch3;\n-with Sem_Ch8;     use Sem_Ch8;\n-with Sem_Dist;    use Sem_Dist;\n-with Sem_Eval;    use Sem_Eval;\n-with Sem_Util;    use Sem_Util;\n-with Sinfo;       use Sinfo;\n-with Snames;      use Snames;\n-with Stand;       use Stand;\n-with Stringt;     use Stringt;\n-with Tbuild;      use Tbuild;\n-with Ttypes;      use Ttypes;\n-with Uintp;       use Uintp;\n \n package body Exp_Dist is\n \n@@ -1012,45 +1014,53 @@ package body Exp_Dist is\n    -- Add_RACW_Features --\n    -----------------------\n \n-   procedure Add_RACW_Features (RACW_Type : Entity_Id)\n-   is\n-      Desig : constant Entity_Id :=\n-                Etype (Designated_Type (RACW_Type));\n-      Decls : List_Id :=\n-                List_Containing (Declaration_Node (RACW_Type));\n-\n-      Same_Scope : constant Boolean :=\n-                     Scope (Desig) = Scope (RACW_Type);\n+   procedure Add_RACW_Features (RACW_Type : Entity_Id) is\n+      Desig      : constant Entity_Id := Etype (Designated_Type (RACW_Type));\n+      Same_Scope : constant Boolean   := Scope (Desig) = Scope (RACW_Type);\n+      Decls      : List_Id;\n \n       Stub_Type         : Entity_Id;\n       Stub_Type_Access  : Entity_Id;\n       RPC_Receiver_Decl : Node_Id;\n-      Existing          : Boolean;\n+\n+      Existing : Boolean;\n+      --  True when appropriate stubs have already been generated (this is the\n+      --  case when another RACW with the same designated type has already been\n+      --  encountered, in which case we reuse the previous stubs rather than\n+      --  generating new ones).\n \n    begin\n       if not Expander_Active then\n          return;\n       end if;\n \n-      if Same_Scope then\n+      --  Look for declarations\n \n-         --  We are declaring a RACW in the same package than its designated\n-         --  type, so the list to use for late declarations must be the\n-         --  private part of the package. We do know that this private part\n-         --  exists since the designated type has to be a private one.\n+      --  Case of declaring a RACW in the same package than its designated\n+      --  type, so the list to use for late declarations must be the private\n+      --  part of the package. We do know that this private part exists since\n+      --  the designated type has to be a private one.\n+\n+      if Same_Scope then\n \n          Decls := Private_Declarations\n            (Package_Specification_Of_Scope (Current_Scope));\n \n-      elsif Nkind (Parent (Decls)) = N_Package_Specification\n-        and then Present (Private_Declarations (Parent (Decls)))\n-      then\n-         Decls := Private_Declarations (Parent (Decls));\n+      --  Comment here???\n+\n+      else\n+         Decls := List_Containing (Declaration_Node (RACW_Type));\n+\n+         if Nkind (Parent (Decls)) = N_Package_Specification\n+           and then Present (Private_Declarations (Parent (Decls)))\n+         then\n+            Decls := Private_Declarations (Parent (Decls));\n+         end if;\n       end if;\n \n       --  If we were unable to find the declarations, that means that the\n-      --  completion of the type was missing. We can safely return and let\n-      --  the error be caught by the semantic analysis.\n+      --  completion of the type was missing. We can safely return and let the\n+      --  error be caught by the semantic analysis.\n \n       if No (Decls) then\n          return;\n@@ -1083,12 +1093,17 @@ package body Exp_Dist is\n          --  type and has not been handled by another RACW in the same package\n          --  as the first one, so add primitive for the stub type here.\n \n+         Validate_RACW_Primitives (RACW_Type);\n          Add_RACW_Primitive_Declarations_And_Bodies\n            (Designated_Type  => Desig,\n             Insertion_Node   => RPC_Receiver_Decl,\n             Decls            => Decls);\n \n       else\n+         --  Validate_RACW_Primitives will be called when the designated type\n+         --  is frozen, see Exp_Ch3.Freeze_Type.\n+         --  ??? Shouldn't we have a pragma Assert (not Is_Frozen (Desig))?\n+\n          Add_Access_Type_To_Process (E => Desig, A => RACW_Type);\n       end if;\n    end Add_RACW_Features;\n@@ -1102,17 +1117,17 @@ package body Exp_Dist is\n       Insertion_Node  : Node_Id;\n       Decls           : List_Id)\n    is\n+      Loc : constant Source_Ptr := Sloc (Insertion_Node);\n       --  Set Sloc of generated declaration copy of insertion node Sloc, so\n       --  the declarations are recognized as belonging to the current package.\n \n-      Loc : constant Source_Ptr := Sloc (Insertion_Node);\n-\n       Stub_Elements : constant Stub_Structure :=\n                         Stubs_Table.Get (Designated_Type);\n \n       pragma Assert (Stub_Elements /= Empty_Stub_Structure);\n+\n       Is_RAS : constant Boolean :=\n-        not Comes_From_Source (Stub_Elements.RACW_Type);\n+                 not Comes_From_Source (Stub_Elements.RACW_Type);\n \n       Current_Insertion_Node : Node_Id := Insertion_Node;\n \n@@ -1161,8 +1176,8 @@ package body Exp_Dist is\n          if Get_PCS_Name = Name_PolyORB_DSA then\n \n             --  For the case of PolyORB, we need to map a textual operation\n-            --  name into a primitive index. Currently we do so using a\n-            --  simple sequence of string comparisons.\n+            --  name into a primitive index. Currently we do so using a simple\n+            --  sequence of string comparisons.\n \n             RPC_Receiver_Elsif_Parts := New_List;\n          end if;\n@@ -1179,15 +1194,15 @@ package body Exp_Dist is\n          while Current_Primitive_Elmt /= No_Elmt loop\n             Current_Primitive := Node (Current_Primitive_Elmt);\n \n-            --  Copy the primitive of all the parents, except predefined\n-            --  ones that are not remotely dispatching.\n+            --  Copy the primitive of all the parents, except predefined ones\n+            --  that are not remotely dispatching.\n \n             if Chars (Current_Primitive) /= Name_uSize\n               and then Chars (Current_Primitive) /= Name_uAlignment\n               and then not Is_TSS (Current_Primitive, TSS_Deep_Finalize)\n             then\n-               --  The first thing to do is build an up-to-date copy of\n-               --  the spec with all the formals referencing Designated_Type\n+               --  The first thing to do is build an up-to-date copy of the\n+               --  spec with all the formals referencing Designated_Type\n                --  transformed into formals referencing Stub_Type. Since this\n                --  primitive may have been inherited, go back the alias chain\n                --  until the real primitive has been found.\n@@ -1237,8 +1252,8 @@ package body Exp_Dist is\n \n                --  Analyzing the body here would cause the Stub type to be\n                --  frozen, thus preventing subsequent primitive declarations.\n-               --  For this reason, it will be analyzed later in the\n-               --  regular flow.\n+               --  For this reason, it will be analyzed later in the regular\n+               --  flow.\n \n                --  Build the receiver stubs\n \n@@ -1331,8 +1346,8 @@ package body Exp_Dist is\n       end if;\n \n       --  Do not analyze RPC receiver at this stage since it will otherwise\n-      --  reference subprograms that have not been analyzed yet. It will\n-      --  be analyzed in the regular flow.\n+      --  reference subprograms that have not been analyzed yet. It will be\n+      --  analyzed in the regular flow.\n \n    end Add_RACW_Primitive_Declarations_And_Bodies;\n \n@@ -1372,8 +1387,8 @@ package body Exp_Dist is\n                       Nkind (Type_Def) = N_Access_Function_Definition;\n \n       Is_Degenerate : Boolean;\n-      --  Set to True if the subprogram_specification for this RAS has\n-      --  an anonymous access parameter (see Process_Remote_AST_Declaration).\n+      --  Set to True if the subprogram_specification for this RAS has an\n+      --  anonymous access parameter (see Process_Remote_AST_Declaration).\n \n       Spec : constant Node_Id := Type_Def;\n \n@@ -1382,8 +1397,8 @@ package body Exp_Dist is\n    --  Start of processing for Add_RAS_Dereference_TSS\n \n    begin\n-      --  The Dereference TSS for a remote access-to-subprogram type\n-      --  has the form:\n+      --  The Dereference TSS for a remote access-to-subprogram type has the\n+      --  form:\n \n       --    [function|procedure] ras_typeRD (RAS_Value, <RAS_Parameters>)\n       --       [return <>]\n@@ -1406,11 +1421,12 @@ package body Exp_Dist is\n       Is_Degenerate := False;\n       Current_Parameter := First (Parameter_Specifications (Type_Def));\n       Parameters : while Present (Current_Parameter) loop\n-         if Nkind (Parameter_Type (Current_Parameter))\n-           = N_Access_Definition\n+         if Nkind (Parameter_Type (Current_Parameter)) =\n+                                            N_Access_Definition\n          then\n             Is_Degenerate := True;\n          end if;\n+\n          Append_To (Param_Specs,\n            Make_Parameter_Specification (Loc,\n              Defining_Identifier =>\n@@ -1445,8 +1461,8 @@ package body Exp_Dist is\n \n       else\n          --  For a normal RAS type, we cast the RAS formal to the corresponding\n-         --  tagged type, and perform a dispatching call to its Call\n-         --  primitive operation.\n+         --  tagged type, and perform a dispatching call to its Call primitive\n+         --  operation.\n \n          Prepend_To (Param_Assoc,\n            Unchecked_Convert_To (RACW_Type,\n@@ -2198,9 +2214,50 @@ package body Exp_Dist is\n       E   : Entity_Id) return Node_Id\n    is\n    begin\n+      if Get_Subprogram_Ids (E).Str_Identifier = No_String then\n+         declare\n+            Current_Declaration : Node_Id;\n+            Current_Subp        : Entity_Id;\n+            Current_Subp_Str    : String_Id;\n+            Current_Subp_Number : Int := First_RCI_Subprogram_Id;\n+\n+         begin\n+            --  Build_Subprogram_Id is called outside of the context of\n+            --  generating calling or receiving stubs. Hence we are processing\n+            --  an 'Access attribute_reference for an RCI subprogram, for the\n+            --  purpose of obtaining a RAS value.\n+\n+            pragma Assert\n+              (Is_Remote_Call_Interface (Scope (E))\n+                 and then\n+                  (Nkind (Parent (E)) = N_Procedure_Specification\n+                     or else\n+                   Nkind (Parent (E)) = N_Function_Specification));\n+\n+            Current_Declaration :=\n+              First (Visible_Declarations\n+                (Package_Specification_Of_Scope (Scope (E))));\n+            while Present (Current_Declaration) loop\n+               if Nkind (Current_Declaration) = N_Subprogram_Declaration\n+                 and then Comes_From_Source (Current_Declaration)\n+               then\n+                  Current_Subp := Defining_Unit_Name (Specification (\n+                    Current_Declaration));\n+\n+                  Assign_Subprogram_Identifier\n+                    (Current_Subp, Current_Subp_Number, Current_Subp_Str);\n+\n+                  Current_Subp_Number := Current_Subp_Number + 1;\n+               end if;\n+\n+               Next (Current_Declaration);\n+            end loop;\n+         end;\n+      end if;\n+\n       case Get_PCS_Name is\n          when Name_PolyORB_DSA =>\n-            return Make_String_Literal  (Loc, Get_Subprogram_Id (E));\n+            return Make_String_Literal (Loc, Get_Subprogram_Id (E));\n          when others =>\n             return Make_Integer_Literal (Loc, Get_Subprogram_Id (E));\n       end case;\n@@ -2335,6 +2392,18 @@ package body Exp_Dist is\n       end case;\n    end Copy_Specification;\n \n+   -----------------------------\n+   -- Corresponding_Stub_Type --\n+   -----------------------------\n+\n+   function Corresponding_Stub_Type (RACW_Type : Entity_Id) return Entity_Id is\n+      Desig         : constant Entity_Id      :=\n+                        Etype (Designated_Type (RACW_Type));\n+      Stub_Elements : constant Stub_Structure := Stubs_Table.Get (Desig);\n+   begin\n+      return Stub_Elements.Stub_Type;\n+   end Corresponding_Stub_Type;\n+\n    ---------------------------\n    -- Could_Be_Asynchronous --\n    ---------------------------\n@@ -3466,9 +3535,6 @@ package body Exp_Dist is\n                   Subp_Val : String_Id;\n \n                begin\n-                  pragma Assert (Current_Subprogram_Number =\n-                    Get_Subprogram_Id (Subp_Def));\n-\n                   --  Build receiving stub\n \n                   Current_Stubs :=\n@@ -3499,6 +3565,9 @@ package body Exp_Dist is\n                     Current_Subprogram_Number,\n                     Subp_Val);\n \n+                  pragma Assert (Current_Subprogram_Number =\n+                    Get_Subprogram_Id (Subp_Def));\n+\n                   --  Add subprogram descriptor (RCI_Subp_Info) to the\n                   --  subprograms table for this receiver. The aggregate\n                   --  below must be kept consistent with the declaration\n@@ -4440,13 +4509,16 @@ package body Exp_Dist is\n                  or else not Constrained\n                  or else Is_Controlling_Formal\n                then\n-                  --  If an input parameter is contrained, then its reading is\n-                  --  deferred until the beginning of the subprogram body. If\n-                  --  it is unconstrained, then an expression is built for\n-                  --  the object declaration and the variable is set using\n-                  --  'Input instead of 'Read.\n+                  --  If an input parameter is constrained, then the read of\n+                  --  the parameter is deferred until the beginning of the\n+                  --  subprogram body. If it is unconstrained, then an\n+                  --  expression is built for the object declaration and the\n+                  --  variable is set using 'Input instead of 'Read. Note that\n+                  --  this deferral does not change the order in which the\n+                  --  actuals are read because Build_Ordered_Parameter_List\n+                  --  puts them unconstrained first.\n \n-                  if Constrained and then not Is_Controlling_Formal then\n+                  if Constrained then\n                      Append_To (Statements,\n                        Make_Attribute_Reference (Loc,\n                          Prefix         => New_Occurrence_Of (Etyp, Loc),\n@@ -4780,8 +4852,10 @@ package body Exp_Dist is\n    -----------------------\n \n    function Get_Subprogram_Id (Def : Entity_Id) return String_Id is\n+      Result : constant String_Id := Get_Subprogram_Ids (Def).Str_Identifier;\n    begin\n-      return Get_Subprogram_Ids (Def).Str_Identifier;\n+      pragma Assert (Result /= No_String);\n+      return Result;\n    end Get_Subprogram_Id;\n \n    -----------------------\n@@ -4800,54 +4874,8 @@ package body Exp_Dist is\n    function Get_Subprogram_Ids\n      (Def : Entity_Id) return Subprogram_Identifiers\n    is\n-      Result : Subprogram_Identifiers :=\n-                 Subprogram_Identifier_Table.Get (Def);\n-\n-      Current_Declaration : Node_Id;\n-      Current_Subp        : Entity_Id;\n-      Current_Subp_Str    : String_Id;\n-      Current_Subp_Number : Int := First_RCI_Subprogram_Id;\n-\n    begin\n-      if Result.Str_Identifier = No_String then\n-\n-         --  We are looking up this subprogram's identifier outside of the\n-         --  context of generating calling or receiving stubs. Hence we are\n-         --  processing an 'Access attribute_reference for an RCI subprogram,\n-         --  for the purpose of obtaining a RAS value.\n-\n-         pragma Assert\n-           (Is_Remote_Call_Interface (Scope (Def))\n-              and then\n-               (Nkind (Parent (Def)) = N_Procedure_Specification\n-                  or else\n-                Nkind (Parent (Def)) = N_Function_Specification));\n-\n-         Current_Declaration :=\n-           First (Visible_Declarations\n-             (Package_Specification_Of_Scope (Scope (Def))));\n-         while Present (Current_Declaration) loop\n-            if Nkind (Current_Declaration) = N_Subprogram_Declaration\n-              and then Comes_From_Source (Current_Declaration)\n-            then\n-               Current_Subp := Defining_Unit_Name (Specification (\n-                 Current_Declaration));\n-               Assign_Subprogram_Identifier\n-                 (Current_Subp, Current_Subp_Number, Current_Subp_Str);\n-\n-               if Current_Subp = Def then\n-                  Result := (Current_Subp_Str, Current_Subp_Number);\n-               end if;\n-\n-               Current_Subp_Number := Current_Subp_Number + 1;\n-            end if;\n-\n-            Next (Current_Declaration);\n-         end loop;\n-      end if;\n-\n-      pragma Assert (Result.Str_Identifier /= No_String);\n-      return Result;\n+      return Subprogram_Identifier_Table.Get (Def);\n    end Get_Subprogram_Ids;\n \n    ----------\n@@ -6712,9 +6740,6 @@ package body Exp_Dist is\n                   Proxy_Object_Addr : Entity_Id;\n \n                begin\n-                  pragma Assert (Current_Subprogram_Number =\n-                    Get_Subprogram_Id (Subp_Def));\n-\n                   --  Build receiving stub\n \n                   Current_Stubs :=\n@@ -6745,6 +6770,9 @@ package body Exp_Dist is\n                     Current_Subprogram_Number,\n                     Subp_Val);\n \n+                  pragma Assert (Current_Subprogram_Number =\n+                    Get_Subprogram_Id (Subp_Def));\n+\n                   Append_To (Decls,\n                     Make_Object_Declaration (Loc,\n                       Defining_Identifier => Subp_Dist_Name,\n@@ -6979,9 +7007,9 @@ package body Exp_Dist is\n          Is_Controlling_Formal         : Boolean;\n          Is_First_Controlling_Formal   : Boolean;\n          First_Controlling_Formal_Seen : Boolean := False;\n-         --  Controlling formal parameters of distributed object\n-         --  primitives require special handling, and the first\n-         --  such parameter needs even more.\n+         --  Controlling formal parameters of distributed object primitives\n+         --  require special handling, and the first such parameter needs even\n+         --  more special handling.\n \n       begin\n          --  ??? document general form of stub subprograms for the PolyORB case\n@@ -7069,18 +7097,17 @@ package body Exp_Dist is\n \n             if Is_Controlling_Formal then\n \n-               --  In the case of a controlling formal argument, we send\n-               --  its reference.\n+               --  In the case of a controlling formal argument, we send its\n+               --  reference.\n \n                Etyp := RACW_Type;\n \n             else\n                Etyp := Etype (Parameter_Type (Current_Parameter));\n             end if;\n \n-            --  The first controlling formal parameter is treated\n-            --  specially: it is used to set the target object of\n-            --  the call.\n+            --  The first controlling formal parameter is treated specially: it\n+            --  is used to set the target object of the call.\n \n             if not Is_First_Controlling_Formal then\n \n@@ -7103,11 +7130,10 @@ package body Exp_Dist is\n                begin\n                   if Is_Controlling_Formal then\n \n-                     --  For a controlling formal parameter (other\n-                     --  than the first one), use the corresponding\n-                     --  RACW. If the parameter is not an anonymous\n-                     --  access parameter, that involves taking\n-                     --  its 'Unrestricted_Access.\n+                     --  For a controlling formal parameter (other than the\n+                     --  first one), use the corresponding RACW. If the\n+                     --  parameter is not an anonymous access parameter, that\n+                     --  involves taking its 'Unrestricted_Access.\n \n                      if Nkind (Parameter_Type (Current_Parameter))\n                        = N_Access_Definition\n@@ -7130,10 +7156,10 @@ package body Exp_Dist is\n                     or else not Constrained\n                     or else Is_Controlling_Formal\n                   then\n-                     --  The parameter has an input value, is constrained\n-                     --  at runtime by an input value, or is a controlling\n-                     --  formal parameter (always passed as a reference)\n-                     --  other than the first one.\n+                     --  The parameter has an input value, is constrained at\n+                     --  runtime by an input value, or is a controlling formal\n+                     --  parameter (always passed as a reference) other than\n+                     --  the first one.\n \n                      Expr := PolyORB_Support.Helpers.Build_To_Any_Call (\n                                Actual_Parameter, Decls);\n@@ -7181,8 +7207,8 @@ package body Exp_Dist is\n                end;\n             end if;\n \n-            --  If the current parameter has a dynamic constrained status,\n-            --  then this status is transmitted as well.\n+            --  If the current parameter has a dynamic constrained status, then\n+            --  this status is transmitted as well.\n             --  This should be done for accessibility as well ???\n \n             if Nkind (Parameter_Type (Current_Parameter))\n@@ -7254,9 +7280,9 @@ package body Exp_Dist is\n          else\n             pragma Assert (Present (Asynchronous));\n             Asynchronous_P := New_Copy_Tree (Asynchronous);\n-            --  The expression node Asynchronous will be used to build\n-            --  an 'if' statement at the end of Build_General_Calling_Stubs:\n-            --  we need to make a copy here.\n+            --  The expression node Asynchronous will be used to build an 'if'\n+            --  statement at the end of Build_General_Calling_Stubs: we need to\n+            --  make a copy here.\n          end if;\n \n          Append_To (Parameter_Associations (Last (Statements)),\n@@ -7290,8 +7316,7 @@ package body Exp_Dist is\n \n             if Is_Function then\n \n-               --  If this is a function call, then read the value and\n-               --  return it.\n+               --  If this is a function call, read the value and return it\n \n                Append_To (Non_Asynchronous_Statements,\n                  Make_Tag_Check (Loc,\n@@ -7353,8 +7378,8 @@ package body Exp_Dist is\n                       Make_Selected_Component (Loc,\n                         Prefix        => Controlling_Parameter,\n                         Selector_Name => Name_Target)))));\n-            --  Controlling_Parameter has the same components\n-            --  as System.Partition_Interface.RACW_Stub_Type.\n+            --  Controlling_Parameter has the same components as\n+            --  System.Partition_Interface.RACW_Stub_Type.\n \n             Target_Info.Object := New_Occurrence_Of (Target_Reference, Loc);\n \n@@ -7503,10 +7528,9 @@ package body Exp_Dist is\n          --  ???\n \n          Outer_Decls : constant List_Id := New_List;\n-         --  At the outermost level, an NVList and Any's are\n-         --  declared for all parameters. The Dynamic_Async\n-         --  flag also needs to be declared there to be visible\n-         --  from the exception handling code.\n+         --  At the outermost level, an NVList and Any's are declared for all\n+         --  parameters. The Dynamic_Async flag also needs to be declared there\n+         --  to be visible from the exception handling code.\n \n          Outer_Statements : constant List_Id := New_List;\n          --  Statements that occur prior to the declaration of the actual\n@@ -7685,7 +7709,7 @@ package body Exp_Dist is\n                   or else not Out_Present (Current_Parameter)\n                   or else not Constrained\n                then\n-                  --  If an input parameter is contrained, then its reading is\n+                  --  If an input parameter is constrained, then its reading is\n                   --  deferred until the beginning of the subprogram body. If\n                   --  it is unconstrained, then an expression is built for\n                   --  the object declaration and the variable is set using\n@@ -7705,8 +7729,8 @@ package body Exp_Dist is\n                      Expr := Empty;\n                   else\n                      null;\n-                     --  Expr will be used to initialize (and constrain)\n-                     --  the parameter when it is declared.\n+                     --  Expr will be used to initialize (and constrain) the\n+                     --  parameter when it is declared.\n                   end if;\n \n                end if;\n@@ -8764,6 +8788,15 @@ package body Exp_Dist is\n                       Object_Definition   =>\n                         New_Occurrence_Of (RTE (RE_Buffer_Stream_Type), Loc)));\n \n+                  --  Allocate_Buffer (Strm);\n+\n+                  Append_To (Stms,\n+                    Make_Procedure_Call_Statement (Loc,\n+                      Name =>\n+                        New_Occurrence_Of (RTE (RE_Allocate_Buffer), Loc),\n+                      Parameter_Associations => New_List (\n+                        New_Occurrence_Of (Strm, Loc))));\n+\n                   --  Any_To_BS (Strm, A);\n \n                   Append_To (Stms,"}, {"sha": "b501bcc6b980791497543aa9feed6b6762b2a7fa", "filename": "gcc/ada/exp_dist.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92869a7b6b8dc3ad4c0e0a299ec36906c2090c8c/gcc%2Fada%2Fexp_dist.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92869a7b6b8dc3ad4c0e0a299ec36906c2090c8c/gcc%2Fada%2Fexp_dist.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.ads?ref=92869a7b6b8dc3ad4c0e0a299ec36906c2090c8c", "patch": "@@ -95,6 +95,9 @@ package Exp_Dist is\n    --  access to Stub_Type. If New_Name is given, then it will be used as\n    --  the name for the newly created spec.\n \n+   function Corresponding_Stub_Type (RACW_Type : Entity_Id) return Entity_Id;\n+   --  Return the stub type associated with the given RACW type\n+\n    function Underlying_RACW_Type\n      (RAS_Typ : Entity_Id) return Entity_Id;\n    --  Given a remote access-to-subprogram type or its equivalent"}]}