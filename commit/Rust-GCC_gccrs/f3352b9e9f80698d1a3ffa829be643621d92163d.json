{"sha": "f3352b9e9f80698d1a3ffa829be643621d92163d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjMzNTJiOWU5ZjgwNjk4ZDFhM2ZmYTgyOWJlNjQzNjIxZDkyMTYzZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1997-10-28T05:28:29Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1997-10-28T05:28:29Z"}, "message": "alpha.md (movqi, movhi): Make sure new insns created during reload won't need reloading themselves.\n\n* alpha.md (movqi, movhi): Make sure new insns created during reload\nwon't need reloading themselves.\n(reload_inqi, reload_inhi, reload_outqi, reload_outhi): Likewise.\n\nFrom-SVN: r16211", "tree": {"sha": "7ec4cb55f621d3cb6c3ff85824ade93aa2d4e424", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ec4cb55f621d3cb6c3ff85824ade93aa2d4e424"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3352b9e9f80698d1a3ffa829be643621d92163d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3352b9e9f80698d1a3ffa829be643621d92163d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3352b9e9f80698d1a3ffa829be643621d92163d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3352b9e9f80698d1a3ffa829be643621d92163d/comments", "author": null, "committer": null, "parents": [{"sha": "0cecc1904d81554d7e955ed43709f9c6aff91b20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0cecc1904d81554d7e955ed43709f9c6aff91b20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0cecc1904d81554d7e955ed43709f9c6aff91b20"}], "stats": {"total": 90, "additions": 78, "deletions": 12}, "files": [{"sha": "001cf1f12be0cff78022704e86b54f7d32a9a1e7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3352b9e9f80698d1a3ffa829be643621d92163d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3352b9e9f80698d1a3ffa829be643621d92163d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3352b9e9f80698d1a3ffa829be643621d92163d", "patch": "@@ -1,3 +1,9 @@\n+Mon Oct 27 21:25:20 1997  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha.md (movqi, movhi): Make sure new insns created during reload\n+\twon't need reloading themselves.\n+\t(reload_inqi, reload_inhi, reload_outqi, reload_outhi): Likewise.\n+\n Mon Oct 27 16:11:10 1997  Jeffrey A Law  (law@cygnus.com)\n \n \t* mn10300.h (GO_IF_LEGITIMATE_ADDRESS): Disable reg+reg."}, {"sha": "221d5d9094fcf1261c88454c1cfaa0885b720938", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 72, "deletions": 12, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3352b9e9f80698d1a3ffa829be643621d92163d/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3352b9e9f80698d1a3ffa829be643621d92163d/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=f3352b9e9f80698d1a3ffa829be643621d92163d", "patch": "@@ -4071,6 +4071,18 @@\n \t\t\t ? gen_rtx (REG, SImode, REGNO (operands[0]))\n \t\t\t : gen_reg_rtx (SImode));\n \n+\t  /* ??? This code creates a new MEM rtx.  If we were called during\n+\t     reload, then we must be careful to make sure that the new rtx\n+\t     will not need reloading.  */\n+\t  if (reload_in_progress\n+\t      && GET_CODE (operands[1]) == MEM\n+\t      && ! strict_memory_address_p (SImode, XEXP (operands[1], 0)))\n+\t    {\n+\t      rtx tmp = gen_rtx (REG, Pmode, REGNO (operands[0]));\n+\t      emit_insn (gen_move_insn (tmp, XEXP (operands[1], 0)));\n+\t      XEXP (operands[1], 0) = tmp;\n+\t    }\n+\n \t  get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n \n \t  emit_insn (gen_aligned_loadqi (operands[0], aligned_mem, bitnum,\n@@ -4183,6 +4195,18 @@\n \t\t\t ? gen_rtx (REG, SImode, REGNO (operands[0]))\n \t\t\t : gen_reg_rtx (SImode));\n \n+\t  /* ??? This code creates a new MEM rtx.  If we were called during\n+\t     reload, then we must be careful to make sure that the new rtx\n+\t     will not need reloading.  */\n+\t  if (reload_in_progress\n+\t      && GET_CODE (operands[1]) == MEM\n+\t      && ! strict_memory_address_p (SImode, XEXP (operands[1], 0)))\n+\t    {\n+\t      rtx tmp = gen_rtx (REG, Pmode, REGNO (operands[0]));\n+\t      emit_insn (gen_move_insn (tmp, XEXP (operands[1], 0)));\n+\t      XEXP (operands[1], 0) = tmp;\n+\t    }\n+\n \t  get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n \n \t  emit_insn (gen_aligned_loadhi (operands[0], aligned_mem, bitnum,\n@@ -4257,15 +4281,26 @@\n   \"! TARGET_BYTE_OPS\"\n   \"\n { extern rtx get_unaligned_address ();\n-  rtx addr = get_unaligned_address (operands[1], 0);\n+  rtx addr, scratch, seq, tmp;\n+\n   /* It is possible that one of the registers we got for operands[2]\n      might coincide with that of operands[0] (which is why we made\n      it TImode).  Pick the other one to use as our scratch.  */\n-  rtx scratch = gen_rtx (REG, DImode,\n-\t\t\t REGNO (operands[0]) == REGNO (operands[2]) \n-\t\t\t ? REGNO (operands[2]) + 1 : REGNO (operands[2]));\n-  rtx seq = gen_unaligned_loadqi (operands[0], addr, scratch,\n-\t\t\t\t  gen_rtx (REG, DImode, REGNO (operands[0])));\n+  scratch = gen_rtx (REG, DImode,\n+\t\t     REGNO (operands[0]) == REGNO (operands[2]) \n+\t\t     ? REGNO (operands[2]) + 1 : REGNO (operands[2]));\n+\n+  /* We must be careful to make sure that the new rtx won't need reloading.  */\n+  if (! strict_memory_address_p (DImode, XEXP (operands[1], 0)))\n+    {\n+      tmp = gen_rtx (REG, Pmode, REGNO (operands[0]));\n+      emit_insn (gen_move_insn (tmp, XEXP (operands[1], 0)));\n+      XEXP (operands[1], 0) = tmp;\n+    }\n+  addr = get_unaligned_address (operands[1], 0);\n+\n+  seq = gen_unaligned_loadqi (operands[0], addr, scratch,\n+\t\t\t      gen_rtx (REG, DImode, REGNO (operands[0])));\n \n   alpha_set_memflags (seq, operands[1]);\n   emit_insn (seq);\n@@ -4279,15 +4314,26 @@\n   \"! TARGET_BYTE_OPS\"\n   \"\n { extern rtx get_unaligned_address ();\n-  rtx addr = get_unaligned_address (operands[1], 0);\n+  rtx scratch, seq, tmp, addr;\n+\n   /* It is possible that one of the registers we got for operands[2]\n      might coincide with that of operands[0] (which is why we made\n      it TImode).  Pick the other one to use as our scratch.  */\n-  rtx scratch = gen_rtx (REG, DImode,\n-\t\t\t REGNO (operands[0]) == REGNO (operands[2]) \n-\t\t\t ? REGNO (operands[2]) + 1 : REGNO (operands[2]));\n-  rtx seq = gen_unaligned_loadhi (operands[0], addr, scratch,\n-\t\t\t\t  gen_rtx (REG, DImode, REGNO (operands[0])));\n+  scratch = gen_rtx (REG, DImode,\n+\t\t     REGNO (operands[0]) == REGNO (operands[2]) \n+\t\t     ? REGNO (operands[2]) + 1 : REGNO (operands[2]));\n+\n+  /* We must be careful to make sure that the new rtx won't need reloading.  */\n+  if (!strict_memory_address_p (DImode, XEXP (operands[1], 0)))\n+    {\n+      tmp = gen_rtx (REG, Pmode, REGNO (operands[0]));\n+      emit_insn (gen_move_insn (tmp, XEXP (operands[1], 0)));\n+      XEXP (operands[1], 0) = tmp;\n+    }\n+  addr = get_unaligned_address (operands[1], 0);\n+\n+  seq = gen_unaligned_loadhi (operands[0], addr, scratch,\n+\t\t\t      gen_rtx (REG, DImode, REGNO (operands[0])));\n \n   alpha_set_memflags (seq, operands[1]);\n   emit_insn (seq);\n@@ -4302,6 +4348,13 @@\n   \"\n { extern rtx get_unaligned_address ();\n \n+  if (!strict_memory_address_p (DImode, XEXP (operands[0], 0)))\n+    {\n+      rtx scratch1 = gen_rtx (REG, DImode, REGNO (operands[2]));\n+      emit_insn (gen_move_insn (scratch1, XEXP (operands[0], 0)));\n+      XEXP (operands[0], 0) = scratch1;\n+    }\n+\n   if (aligned_memory_operand (operands[0], QImode))\n     {\n       rtx aligned_mem, bitnum;\n@@ -4341,6 +4394,13 @@\n   \"\n { extern rtx get_unaligned_address ();\n \n+  if (!strict_memory_address_p (DImode, XEXP (operands[0], 0)))\n+    {\n+      rtx scratch1 = gen_rtx (REG, DImode, REGNO (operands[2]));\n+      emit_insn (gen_move_insn (scratch1, XEXP (operands[0], 0)));\n+      XEXP (operands[0], 0) = scratch1;\n+    }\n+\n   if (aligned_memory_operand (operands[0], HImode))\n     {\n       rtx aligned_mem, bitnum;"}]}