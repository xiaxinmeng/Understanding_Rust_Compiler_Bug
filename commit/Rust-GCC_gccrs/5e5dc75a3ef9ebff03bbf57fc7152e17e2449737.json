{"sha": "5e5dc75a3ef9ebff03bbf57fc7152e17e2449737", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU1ZGM3NWEzZWY5ZWJmZjAzYmJmNTdmYzcxNTJlMTdlMjQ0OTczNw==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2008-08-20T15:51:37Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-08-20T15:51:37Z"}, "message": "2008-08-20  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch13.adb:\n\t(Adjust_Record_For_Reverse_Bit_Order): Do not access First_Bit for\n\tnon-existing component clause.\n\nFrom-SVN: r139323", "tree": {"sha": "b7a787da57befa24834db4afd2ab147b56f624ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7a787da57befa24834db4afd2ab147b56f624ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e5dc75a3ef9ebff03bbf57fc7152e17e2449737", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e5dc75a3ef9ebff03bbf57fc7152e17e2449737", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e5dc75a3ef9ebff03bbf57fc7152e17e2449737", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e5dc75a3ef9ebff03bbf57fc7152e17e2449737/comments", "author": null, "committer": null, "parents": [{"sha": "db58b50218a667a806eaf74fb42c8e9afa82afe5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db58b50218a667a806eaf74fb42c8e9afa82afe5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db58b50218a667a806eaf74fb42c8e9afa82afe5"}], "stats": {"total": 105, "additions": 62, "deletions": 43}, "files": [{"sha": "e5057d222bdf2f1333a74e1af601a6404d7d8019", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e5dc75a3ef9ebff03bbf57fc7152e17e2449737/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e5dc75a3ef9ebff03bbf57fc7152e17e2449737/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5e5dc75a3ef9ebff03bbf57fc7152e17e2449737", "patch": "@@ -1,3 +1,19 @@\n+2008-08-20  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch13.adb:\n+\t(Adjust_Record_For_Reverse_Bit_Order): Do not access First_Bit for\n+\tnon-existing component clause.\n+\n+\t* exp_ch5.adb: Minor reformatting\n+\n+\t* g-comlin.adb: Minor reformatting\n+\n+\t* make.adb: Minor reformatting\n+\n+\t* prj-proc.adb: Minor reformatting\n+\n+\t* stylesw.ads: Minor reformatting\n+\n 2008-08-20  Vincent Celier  <celier@adacore.com>\n \n \t* make.adb (Gnatmake_Switch_Found): New Boolean global variable"}, {"sha": "0de30ebaec70c20b9d681ca08a5c084f7c3fcca6", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 46, "deletions": 43, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e5dc75a3ef9ebff03bbf57fc7152e17e2449737/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e5dc75a3ef9ebff03bbf57fc7152e17e2449737/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=5e5dc75a3ef9ebff03bbf57fc7152e17e2449737", "patch": "@@ -222,66 +222,69 @@ package body Sem_Ch13 is\n       Comp   := First_Component_Or_Discriminant (R);\n       while Present (Comp) loop\n          declare\n-            CC    : constant Node_Id := Component_Clause (Comp);\n-            Fbit  : constant Uint    := Static_Integer (First_Bit (CC));\n+            CC : constant Node_Id := Component_Clause (Comp);\n \n          begin\n             if Present (CC) then\n+               declare\n+                  Fbit : constant Uint := Static_Integer (First_Bit (CC));\n \n-               --  Case of component with size > max machine scalar\n-\n-               if Esize (Comp) > Max_Machine_Scalar_Size then\n+               begin\n+                  --  Case of component with size > max machine scalar\n \n-                  --  Must begin on byte boundary\n+                  if Esize (Comp) > Max_Machine_Scalar_Size then\n \n-                  if Fbit mod SSU /= 0 then\n-                     Error_Msg_N\n-                       (\"illegal first bit value for reverse bit order\",\n-                        First_Bit (CC));\n-                     Error_Msg_Uint_1 := SSU;\n-                     Error_Msg_Uint_2 := Max_Machine_Scalar_Size;\n+                     --  Must begin on byte boundary\n \n-                     Error_Msg_N\n-                       (\"\\must be a multiple of ^ if size greater than ^\",\n-                        First_Bit (CC));\n+                     if Fbit mod SSU /= 0 then\n+                        Error_Msg_N\n+                          (\"illegal first bit value for reverse bit order\",\n+                           First_Bit (CC));\n+                        Error_Msg_Uint_1 := SSU;\n+                        Error_Msg_Uint_2 := Max_Machine_Scalar_Size;\n \n-                  --  Must end on byte boundary\n+                        Error_Msg_N\n+                          (\"\\must be a multiple of ^ if size greater than ^\",\n+                           First_Bit (CC));\n \n-                  elsif Esize (Comp) mod SSU /= 0 then\n-                     Error_Msg_N\n-                       (\"illegal last bit value for reverse bit order\",\n-                        Last_Bit (CC));\n-                     Error_Msg_Uint_1 := SSU;\n-                     Error_Msg_Uint_2 := Max_Machine_Scalar_Size;\n+                     --  Must end on byte boundary\n \n-                     Error_Msg_N\n-                       (\"\\must be a multiple of ^ if size greater than ^\",\n-                        Last_Bit (CC));\n+                     elsif Esize (Comp) mod SSU /= 0 then\n+                        Error_Msg_N\n+                          (\"illegal last bit value for reverse bit order\",\n+                           Last_Bit (CC));\n+                        Error_Msg_Uint_1 := SSU;\n+                        Error_Msg_Uint_2 := Max_Machine_Scalar_Size;\n \n-                  --  OK, give warning if enabled\n+                        Error_Msg_N\n+                          (\"\\must be a multiple of ^ if size greater than ^\",\n+                           Last_Bit (CC));\n \n-                  elsif Warn_On_Reverse_Bit_Order then\n-                     Error_Msg_N\n-                       (\"multi-byte field specified with non-standard\"\n-                        & \" Bit_Order?\", CC);\n+                     --  OK, give warning if enabled\n \n-                     if Bytes_Big_Endian then\n-                        Error_Msg_N\n-                          (\"\\bytes are not reversed \"\n-                           & \"(component is big-endian)?\", CC);\n-                     else\n+                     elsif Warn_On_Reverse_Bit_Order then\n                         Error_Msg_N\n-                          (\"\\bytes are not reversed \"\n-                           & \"(component is little-endian)?\", CC);\n+                          (\"multi-byte field specified with non-standard\"\n+                           & \" Bit_Order?\", CC);\n+\n+                        if Bytes_Big_Endian then\n+                           Error_Msg_N\n+                             (\"\\bytes are not reversed \"\n+                              & \"(component is big-endian)?\", CC);\n+                        else\n+                           Error_Msg_N\n+                             (\"\\bytes are not reversed \"\n+                              & \"(component is little-endian)?\", CC);\n+                        end if;\n                      end if;\n-                  end if;\n \n-               --  Case where size is not greater than max machine scalar.\n-               --  For now, we just count these.\n+                     --  Case where size is not greater than max machine\n+                     --  scalar. For now, we just count these.\n \n-               else\n-                  Num_CC := Num_CC + 1;\n-               end if;\n+                  else\n+                     Num_CC := Num_CC + 1;\n+                  end if;\n+               end;\n             end if;\n          end;\n "}]}