{"sha": "a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJjMmNlZTkyZTVkZWZmZjliZjIzZDNiMTE4NGVlOTZlNTdlNWZkZA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-06-10T18:00:08Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2020-06-10T18:02:12Z"}, "message": "PR middle-end/95353 - spurious -Wstringop-overflow writing to a trailing array plus offset\n\nAlso resolves:\nPR middle-end/92939 - missing -Wstringop-overflow on negative index from the end of array\n\ngcc/ChangeLog:\n\n\tPR middle-end/95353\n\tPR middle-end/92939\n\t* builtins.c (inform_access): New function.\n\t(check_access): Call it.  Add argument.\n\t(addr_decl_size): Remove.\n\t(get_range): New function.\n\t(compute_objsize): New overload.  Only use compute_builtin_object_size\n\twith raw memory function.\n\t(check_memop_access): Pass new argument to compute_objsize and\n\tcheck_access.\n\t(expand_builtin_memchr, expand_builtin_strcat): Same.\n\t(expand_builtin_strcpy, expand_builtin_stpcpy_1): Same.\n\t(expand_builtin_stpncpy, check_strncat_sizes): Same.\n\t(expand_builtin_strncat, expand_builtin_strncpy): Same.\n\t(expand_builtin_memcmp): Same.\n\t* builtins.h (check_nul_terminated_array): Declare extern.\n\t(check_access): Add argument.\n\t(struct access_ref, struct access_data): New structs.\n\t* gimple-ssa-warn-restrict.c (clamp_offset): New helper.\n\t(builtin_access::overlap): Call it.\n\t* tree-object-size.c (decl_init_size): Declare extern.\n\t(addr_object_size): Correct offset computation.\n\t* tree-object-size.h (decl_init_size): Declare.\n\t* tree-ssa-strlen.c (handle_integral_assign): Remove a call\n\tto maybe_warn_overflow when assigning to an SSA_NAME.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/95353\n\tPR middle-end/92939\n\t* c-c++-common/Wstringop-truncation.c: Remove an xfail.\n\t* gcc.dg/Warray-bounds-46.c: Remove a bogus warning.\n\t* gcc.dg/Wrestrict-9.c: Disable -Wstringop-overflow.\n\t* gcc.dg/Wstringop-overflow-12.c: Remove xfails.\n\t* gcc.dg/Wstringop-overflow-28.c: Same.\n\t* gcc.dg/builtin-stringop-chk-4.c: Same.\n\t* gcc.dg/builtin-stringop-chk-5.c: Same.\n\t* gcc.dg/builtin-stringop-chk-8.c: Same.\n\t* gcc.dg/strlenopt-74.c: Avoid buffer overflow.\n\t* gcc.dg/Wstringop-overflow-34.c: New test.\n\t* gcc.dg/Wstringop-overflow-35.c: New test.\n\t* gcc.dg/Wstringop-overflow-36.c: New test.\n\t* gcc.dg/Wstringop-overflow-37.c: New test.\n\t* gcc.dg/Wstringop-overflow-38.c: New test.", "tree": {"sha": "aba4fb6e58da7b6f6e30f7e67e716a20a1a8a5ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aba4fb6e58da7b6f6e30f7e67e716a20a1a8a5ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a391adf7a38780f8d01dbac08a2a143fc80b469", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a391adf7a38780f8d01dbac08a2a143fc80b469", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a391adf7a38780f8d01dbac08a2a143fc80b469"}], "stats": {"total": 1549, "additions": 1188, "deletions": 361}, "files": [{"sha": "caab188e81c429fcc419689fe5c5befe2f4b2d38", "filename": "gcc/builtins.c", "status": "modified", "additions": 418, "deletions": 302, "changes": 720, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "patch": "@@ -3394,6 +3394,130 @@ warn_for_access (location_t loc, tree func, tree exp, int opt, tree range[2],\n   return warned;\n }\n \n+/* Issue an inform message describing the target of an access REF.\n+   WRITE is set for a write access and clear for a read access.  */\n+\n+static void\n+inform_access (const access_ref &ref, bool write)\n+{\n+  if (!ref.ref)\n+    return;\n+\n+  /* Convert offset range and avoid including a zero range since it isn't\n+     necessarily meaningful.  */\n+  long long minoff = 0, maxoff = 0;\n+  if (wi::fits_shwi_p (ref.offrng[0])\n+      && wi::fits_shwi_p (ref.offrng[1]))\n+    {\n+      minoff = ref.offrng[0].to_shwi ();\n+      maxoff = ref.offrng[1].to_shwi ();\n+    }\n+\n+  /* Convert size range and always include it since all sizes are\n+     meaningful. */\n+  unsigned long long minsize = 0, maxsize = 0;\n+  if (wi::fits_shwi_p (ref.sizrng[0])\n+      && wi::fits_shwi_p (ref.sizrng[1]))\n+    {\n+      minsize = ref.sizrng[0].to_shwi ();\n+      maxsize = ref.sizrng[1].to_shwi ();\n+    }\n+\n+  char sizestr[80];\n+  location_t loc;\n+  tree allocfn = NULL_TREE;\n+  if (TREE_CODE (ref.ref) == SSA_NAME)\n+    {\n+      gimple *stmt = SSA_NAME_DEF_STMT (ref.ref);\n+      gcc_assert (is_gimple_call (stmt));\n+      loc = gimple_location (stmt);\n+      allocfn = gimple_call_fndecl (stmt);\n+      if (!allocfn)\n+\t/* Handle calls through pointers to functions.  */\n+\tallocfn = gimple_call_fn (stmt);\n+\n+      /* SIZRNG doesn't necessarily have the same range as the allocation\n+\t size determined by gimple_call_alloc_size ().  */\n+\n+      if (minsize == maxsize)\n+\tsprintf (sizestr, \"%llu\", minsize);\n+      else\n+\tsprintf (sizestr, \"[%llu, %llu]\", minsize, maxsize);\n+\n+    }\n+  else\n+    loc = DECL_SOURCE_LOCATION (ref.ref);\n+\n+  if (write)\n+    {\n+      if (DECL_P (ref.ref))\n+\t{\n+\t  if (minoff == maxoff)\n+\t    {\n+\t      if (minoff == 0)\n+\t\tinform (loc, \"destination object %qD\", ref.ref);\n+\t      else\n+\t\tinform (loc, \"at offset %lli into destination object %qD\",\n+\t\t\tminoff, ref.ref);\n+\t    }\n+\t  else\n+\t    inform (loc, \"at offset [%lli, %lli] into destination object %qD\",\n+\t\t    minoff, maxoff, ref.ref);\n+\t  return;\n+\t}\n+\n+      if (minoff == maxoff)\n+\t{\n+\t  if (minoff == 0)\n+\t    inform (loc, \"destination object of size %s allocated by %qE\",\n+\t\t    sizestr, allocfn);\n+\t  else\n+\t    inform (loc,\n+\t\t    \"at offset %lli into destination object of size %s \"\n+\t\t    \"allocated by %qE\", minoff, sizestr, allocfn);\n+\t}\n+      else\n+\tinform (loc,\n+\t\t\"at offset [%lli, %lli] into destination object of size %s \"\n+\t\t\"allocated by %qE\",\n+\t\tminoff, maxoff, sizestr, allocfn);\n+\n+      return;\n+    }\n+\n+  if (DECL_P (ref.ref))\n+    {\n+      if (minoff == maxoff)\n+\t{\n+\t  if (minoff == 0)\n+\t    inform (loc, \"source object %qD\", ref.ref);\n+\t  else\n+\t    inform (loc, \"at offset %lli into source object %qD\",\n+\t\t    minoff, ref.ref);\n+\t}\n+      else\n+\tinform (loc, \"at offset [%lli, %lli] into source object %qD\",\n+\t\tminoff, maxoff, ref.ref);\n+      return;\n+    }\n+\n+  if (minoff == maxoff)\n+    {\n+      if (minoff == 0)\n+\tinform (loc, \"source object of size %s allocated by %qE\",\n+\t\tsizestr, allocfn);\n+      else\n+\tinform (loc,\n+\t\t\"at offset %lli into source object of size %s \"\n+\t\t\"allocated by %qE\", minoff, sizestr, allocfn);\n+    }\n+  else\n+    inform (loc,\n+\t    \"at offset [%lli, %lli] into source object of size %s \"\n+\t    \"allocated by %qE\",\n+\t    minoff, maxoff, sizestr, allocfn);\n+}\n+\n /* Try to verify that the sizes and lengths of the arguments to a string\n    manipulation function given by EXP are within valid bounds and that\n    the operation does not lead to buffer overflow or read past the end.\n@@ -3423,13 +3547,16 @@ warn_for_access (location_t loc, tree func, tree exp, int opt, tree range[2],\n    ACCESS is true for accesses, false for simple size checks in calls\n    to functions that neither read from nor write to the region.\n \n+   When nonnull, PAD points to a more detailed description of the access.\n+\n    If the call is successfully verified as safe return true, otherwise\n    return false.  */\n \n bool\n check_access (tree exp, tree, tree, tree dstwrite,\n \t      tree maxread, tree srcstr, tree dstsize,\n-\t      bool access /* = true */)\n+\t      bool access /* = true */,\n+\t      const access_data *pad /* = NULL */)\n {\n   int opt = OPT_Wstringop_overflow_;\n \n@@ -3633,7 +3760,11 @@ check_access (tree exp, tree, tree, tree dstwrite,\n \t\t\t\t    exp, range[0], range[1],\n \t\t\t\t    dstsize));\n \t  if (warned)\n-\t    TREE_NO_WARNING (exp) = true;\n+\t    {\n+\t      TREE_NO_WARNING (exp) = true;\n+\t      if (pad)\n+\t\tinform_access (pad->dst, true);\n+\t    }\n \n \t  /* Return error when an overflow has been detected.  */\n \t  return false;\n@@ -3741,8 +3872,11 @@ check_access (tree exp, tree, tree, tree dstwrite,\n       loc = expansion_point_location_if_in_system_header (loc);\n \n       if (warn_for_access (loc, func, exp, opt, range, slen, access))\n-\tTREE_NO_WARNING (exp) = true;\n-\n+\t{\n+\t  TREE_NO_WARNING (exp) = true;\n+\t  if (pad)\n+\t    inform_access (pad->src, false);\n+\t}\n       return false;\n     }\n \n@@ -3841,185 +3975,135 @@ gimple_call_alloc_size (gimple *stmt, wide_int rng1[2] /* = NULL */,\n   return wide_int_to_tree (sizetype, rng1[1]);\n }\n \n-/* Helper for compute_objsize.  Returns the constant size of the DEST\n-   if it refers to a variable or field and sets *PDECL to the DECL and\n-   *POFF to zero.  Otherwise returns null for other nodes.  */\n+/* Wrapper around the wide_int overload of get_range.  Returns the same\n+   result but accepts offset_int instead.  */\n \n-static tree\n-addr_decl_size (tree dest, tree *pdecl, tree *poff)\n+static bool\n+get_range (tree x, signop sgn, offset_int r[2],\n+\t   const vr_values *rvals /* = NULL */)\n {\n-  if (TREE_CODE (dest) == ADDR_EXPR)\n-    dest = TREE_OPERAND (dest, 0);\n-\n-  if (DECL_P (dest))\n-    {\n-      *pdecl = dest;\n-      *poff = integer_zero_node;\n-      if (tree size = DECL_SIZE_UNIT (dest))\n-\treturn TREE_CODE (size) == INTEGER_CST ? size : NULL_TREE;\n-    }\n-\n-  if (TREE_CODE (dest) == COMPONENT_REF)\n-    {\n-      *pdecl = TREE_OPERAND (dest, 1);\n-      *poff = integer_zero_node;\n-      /* Only return constant sizes for now while callers depend on it.  */\n-      if (tree size = component_ref_size (dest))\n-\treturn TREE_CODE (size) == INTEGER_CST ? size : NULL_TREE;\n-    }\n+  wide_int wr[2];\n+  if (!get_range (x, wr, rvals))\n+    return false;\n \n-  return NULL_TREE;\n+  r[0] = offset_int::from (wr[0], sgn);\n+  r[1] = offset_int::from (wr[1], sgn);\n+  return true;\n }\n \n-/* Helper to compute the size of the object referenced by the DEST\n+/* Helper to compute the size of the object referenced by the PTR\n    expression which must have pointer type, using Object Size type\n    OSTYPE (only the least significant 2 bits are used).\n-   Returns an estimate of the size of the object represented as\n-   a sizetype constant if successful or NULL when the size cannot\n-   be determined.\n-   When the referenced object involves a non-constant offset in some\n-   range the returned value represents the largest size given the\n-   smallest non-negative offset in the range.\n-   If nonnull, sets *PDECL to the decl of the referenced subobject\n-   if it can be determined, or to null otherwise.  Likewise, when\n-   POFF is nonnull *POFF is set to the offset into *PDECL.\n+   On success, sets PREF->REF to the DECL of the referenced object\n+   if it's unique, otherwise to null, PREF->OFFRNG to the range of\n+   offsets into it, and PREF->SIZRNG to the range of sizes of\n+   the object(s).\n+   VISITED is used to avoid visiting the same PHI operand multiple\n+   times, and, when nonnull, RVALS to determine range information.\n+   Returns true on success, false when the size cannot be determined.\n \n    The function is intended for diagnostics and should not be used\n    to influence code generation or optimization.  */\n \n-tree\n-compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */,\n-\t\t tree *poff /* = NULL */, const vr_values *rvals /* = NULL */)\n+static bool\n+compute_objsize (tree ptr, int ostype, access_ref *pref,\n+\t\t bitmap *visited, const vr_values *rvals /* = NULL */)\n {\n-  tree dummy_decl = NULL_TREE;\n-  if (!pdecl)\n-    pdecl = &dummy_decl;\n+  if (ostype == 0)\n+    {\n+      /* Use BOS only for raw memory functions like memcpy to get\n+\t the size of the largest enclosing object.  */\n+      tree off = NULL_TREE;\n+      unsigned HOST_WIDE_INT size;\n+      if (compute_builtin_object_size (ptr, ostype, &size, &pref->ref, &off))\n+\t{\n+\t  if (off)\n+\t    {\n+\t      offset_int offset = wi::to_offset (off);\n+\t      pref->offrng[0] += offset;\n+\t      pref->offrng[1] += offset;\n+\n+\t      /* compute_builtin_object_size() returns the remaining\n+\t\t size in PTR.  Add the offset to it to get the full\n+\t\t size.  */\n+\t      pref->sizrng[0] = pref->sizrng[1] = size + offset;\n+\t    }\n+\t  else\n+\t    pref->sizrng[0] = pref->sizrng[1] = size;\n+\t  return true;\n+\t}\n+    }\n \n-  tree dummy_off = NULL_TREE;\n-  if (!poff)\n-    poff = &dummy_off;\n+  const bool addr = TREE_CODE (ptr) == ADDR_EXPR;\n+  if (addr)\n+    ptr = TREE_OPERAND (ptr, 0);\n \n-  /* Only the two least significant bits are meaningful.  */\n-  ostype &= 3;\n+  if (DECL_P (ptr))\n+    {\n+      /* Bail if the reference is to the pointer itself (as opposed\n+\t to what it points to).  */\n+      if (!addr && POINTER_TYPE_P (TREE_TYPE (ptr)))\n+\treturn false;\n+\n+      tree size = decl_init_size (ptr, false);\n+      if (!size || TREE_CODE (size) != INTEGER_CST)\n+\treturn false;\n \n-  if (ostype)\n-    /* Except for overly permissive calls to memcpy and other raw\n-       memory functions with zero OSTYPE, detect the size from simple\n-       DECLs first to more reliably than compute_builtin_object_size\n-       set *PDECL and *POFF.  */\n-    if (tree size = addr_decl_size (dest, pdecl, poff))\n-      return size;\n+      pref->ref = ptr;\n+      pref->sizrng[0] = pref->sizrng[1] = wi::to_offset (size);\n+      return true;\n+    }\n \n-  unsigned HOST_WIDE_INT size;\n-  if (compute_builtin_object_size (dest, ostype, &size, pdecl, poff))\n-    return build_int_cst (sizetype, size);\n+  const tree_code code = TREE_CODE (ptr);\n \n-  if (TREE_CODE (dest) == SSA_NAME)\n+  if (code == COMPONENT_REF)\n     {\n-      gimple *stmt = SSA_NAME_DEF_STMT (dest);\n-      if (is_gimple_call (stmt))\n+      if (ostype == 0)\n \t{\n-\t  /* If STMT is a call to an allocation function get the size\n-\t     from its argument(s).  If successful, also set *PDECL to\n-\t     DEST for the caller to include in diagnostics.  */\n-\t  if (tree size = gimple_call_alloc_size (stmt))\n-\t    {\n-\t      *pdecl = dest;\n-\t      *poff = integer_zero_node;\n-\t      return size;\n-\t    }\n-\t  return NULL_TREE;\n+\t  /* For raw memory functions like memcpy bail if the size\n+\t     of the enclosing object cannot be determined.  */\n+\t  access_ref tmpref;\n+\t  tree ref = TREE_OPERAND (ptr, 0);\n+\t  if (!compute_objsize (ref, ostype, &tmpref, visited, rvals)\n+\t      || !tmpref.ref)\n+\t    return false;\n \t}\n \n-      if (!is_gimple_assign (stmt))\n-\treturn NULL_TREE;\n-\n-      dest = gimple_assign_rhs1 (stmt);\n+      tree field = TREE_OPERAND (ptr, 1);\n+      /* Bail if the reference is to the pointer itself (as opposed\n+\t to what it points to).  */\n+      if (!addr && POINTER_TYPE_P (TREE_TYPE (field)))\n+\treturn false;\n \n-      tree_code code = gimple_assign_rhs_code (stmt);\n-      if (code == POINTER_PLUS_EXPR)\n+      pref->ref = field;\n+      /* Only return constant sizes for now while callers depend\n+\t on it.  INT0LEN is true for interior zero-length arrays.  */\n+      bool int0len = false;\n+      tree size = component_ref_size (ptr, &int0len);\n+      if (int0len)\n \t{\n-\t  /* compute_builtin_object_size fails for addresses with\n-\t     non-constant offsets.  Try to determine the range of\n-\t     such an offset here and use it to adjust the constant\n-\t     size.  */\n-\t  tree off = gimple_assign_rhs2 (stmt);\n-\t  if (TREE_CODE (off) == INTEGER_CST)\n-\t    {\n-\t      if (tree size = compute_objsize (dest, ostype, pdecl, poff))\n-\t\t{\n-\t\t  wide_int wioff = wi::to_wide (off);\n-\t\t  wide_int wisiz = wi::to_wide (size);\n-\n-\t\t  /* Ignore negative offsets for now.  For others,\n-\t\t     use the lower bound as the most optimistic\n-\t\t     estimate of the (remaining) size.  */\n-\t\t  if (wi::neg_p (wioff))\n-\t\t    ;\n-\t\t  else\n-\t\t    {\n-\t\t      if (*poff)\n-\t\t\t{\n-\t\t\t  *poff = fold_convert (ptrdiff_type_node, *poff);\n-\t\t\t  off = fold_convert (ptrdiff_type_node, *poff);\n-\t\t\t  *poff = size_binop (PLUS_EXPR, *poff, off);\n-\t\t\t}\n-\t\t      else\n-\t\t\t*poff = off;\n-\t\t      if (wi::ltu_p (wioff, wisiz))\n-\t\t\treturn wide_int_to_tree (TREE_TYPE (size),\n-\t\t\t\t\t\t wi::sub (wisiz, wioff));\n-\t\t      return size_zero_node;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t  else if (TREE_CODE (off) == SSA_NAME\n-\t\t   && INTEGRAL_TYPE_P (TREE_TYPE (off)))\n-\t    {\n-\t      wide_int min, max;\n-\t      enum value_range_kind rng = get_range_info (off, &min, &max);\n-\n-\t      if (rng == VR_RANGE)\n-\t\tif (tree size = compute_objsize (dest, ostype, pdecl, poff))\n-\t\t  {\n-\t\t    wide_int wisiz = wi::to_wide (size);\n-\n-\t\t    /* Ignore negative offsets for now.  For others,\n-\t\t       use the lower bound as the most optimistic\n-\t\t       estimate of the (remaining)size.  */\n-\t\t    if (wi::neg_p (min) || wi::neg_p (max))\n-\t\t      ;\n-\t\t    else\n-\t\t      {\n-\t\t\t/* FIXME: For now, since the offset is non-constant,\n-\t\t\t   clear *POFF to keep it from being \"misused.\"\n-\t\t\t   Eventually *POFF will need to become a range that\n-\t\t\t   can be properly added to the outer offset if it\n-\t\t\t   too is one.  */\n-\t\t\t*poff = NULL_TREE;\n-\t\t\tif (wi::ltu_p (min, wisiz))\n-\t\t\t  return wide_int_to_tree (TREE_TYPE (size),\n-\t\t\t\t\t\t   wi::sub (wisiz, min));\n-\t\t\treturn size_zero_node;\n-\t\t      }\n-\t\t  }\n-\t    }\n+\t  pref->sizrng[0] = pref->sizrng[1] = 0;\n+\t  return true;\n \t}\n-      else if (code != ADDR_EXPR)\n-\treturn NULL_TREE;\n-    }\n \n-  /* Unless computing the largest size (for memcpy and other raw memory\n-     functions), try to determine the size of the object from its type.  */\n-  if (!ostype)\n-    return NULL_TREE;\n+      if (!size || TREE_CODE (size) != INTEGER_CST)\n+\treturn false;\n+\n+      pref->sizrng[0] = pref->sizrng[1] = wi::to_offset (size);\n+      return true;\n+    }\n \n-  if (TREE_CODE (dest) == ARRAY_REF\n-      || TREE_CODE (dest) == MEM_REF)\n+  if (code == ARRAY_REF || code == MEM_REF)\n     {\n-      tree ref = TREE_OPERAND (dest, 0);\n+      tree ref = TREE_OPERAND (ptr, 0);\n       tree reftype = TREE_TYPE (ref);\n-      if (TREE_CODE (dest) == MEM_REF && TREE_CODE (reftype) == POINTER_TYPE)\n+      if (code == ARRAY_REF\n+\t  && TREE_CODE (TREE_TYPE (reftype)) == POINTER_TYPE)\n+\t/* Avoid arrays of pointers.  FIXME: Hande pointers to arrays\n+\t   of known bound.  */\n+\treturn false;\n+\n+      if (code == MEM_REF && TREE_CODE (reftype) == POINTER_TYPE)\n \t{\n \t  /* Give up for MEM_REFs of vector types; those may be synthesized\n \t     from multiple assignments to consecutive data members.  See PR\n@@ -4028,158 +4112,175 @@ compute_objsize (tree dest, int ostype, tree *pdecl /* = NULL */,\n \t     MEM_REFs at the time they're created.  */\n \t  reftype = TREE_TYPE (reftype);\n \t  if (TREE_CODE (reftype) == VECTOR_TYPE)\n-\t    return NULL_TREE;\n+\t    return false;\n \t}\n-      tree off = TREE_OPERAND (dest, 1);\n-      if (tree size = compute_objsize (ref, ostype, pdecl, poff))\n-\t{\n-\t  /* If the declaration of the destination object is known\n-\t     to have zero size, return zero.  */\n-\t  if (integer_zerop (size)\n-\t      && *pdecl && DECL_P (*pdecl)\n-\t      && *poff && integer_zerop (*poff))\n-\t    return size_zero_node;\n-\n-\t  /* A valid offset into a declared object cannot be negative.\n-\t     A zero size with a zero \"inner\" offset is still zero size\n-\t     regardless of the \"other\" offset OFF.  */\n-\t  if (*poff\n-\t      && ((integer_zerop (*poff) && integer_zerop (size))\n-\t\t  || (TREE_CODE (*poff) == INTEGER_CST\n-\t\t      && tree_int_cst_sgn (*poff) < 0)))\n-\t    return size_zero_node;\n-\n-\t  wide_int offrng[2];\n-\t  if (!get_range (off, offrng, rvals))\n-\t    return NULL_TREE;\n \n-\t  /* Convert to the same precision to keep wide_int from \"helpfully\"\n-\t     crashing whenever it sees other arguments.  */\n-\t  const unsigned sizprec = TYPE_PRECISION (sizetype);\n-\t  offrng[0] = wide_int::from (offrng[0], sizprec, SIGNED);\n-\t  offrng[1] = wide_int::from (offrng[1], sizprec, SIGNED);\n+      if (!compute_objsize (ref, ostype, pref, visited, rvals))\n+\treturn false;\n \n-\t  /* Adjust SIZE either up or down by the sum of *POFF and OFF\n-\t     above.  */\n-\t  if (TREE_CODE (dest) == ARRAY_REF)\n-\t    {\n-\t      tree lowbnd = array_ref_low_bound (dest);\n-\t      if (!integer_zerop (lowbnd) && tree_fits_uhwi_p (lowbnd))\n-\t\t{\n-\t\t  /* Adjust the offset by the low bound of the array\n-\t\t     domain (normally zero but 1 in Fortran).  */\n-\t\t  unsigned HOST_WIDE_INT lb = tree_to_uhwi (lowbnd);\n-\t\t  offrng[0] -= lb;\n-\t\t  offrng[1] -= lb;\n-\t\t}\n+      offset_int orng[2];\n+      tree off = TREE_OPERAND (ptr, 1);\n+      if (!get_range (off, SIGNED, orng, rvals))\n+\t/* Fail unless the size of the object is zero.  */\n+\treturn pref->sizrng[0] == 0 && pref->sizrng[0] == pref->sizrng[1];\n \n-\t      /* Convert the array index into a byte offset.  */\n-\t      tree eltype = TREE_TYPE (dest);\n-\t      tree tpsize = TYPE_SIZE_UNIT (eltype);\n-\t      if (tpsize && TREE_CODE (tpsize) == INTEGER_CST)\n-\t\t{\n-\t\t  wide_int wsz = wi::to_wide (tpsize, offrng->get_precision ());\n-\t\t  offrng[0] *= wsz;\n-\t\t  offrng[1] *= wsz;\n-\t\t}\n-\t      else\n-\t\treturn NULL_TREE;\n+      if (TREE_CODE (ptr) == ARRAY_REF)\n+\t{\n+\t  /* Convert the array index range determined above to a byte\n+\t     offset.  */\n+\t  tree lowbnd = array_ref_low_bound (ptr);\n+\t  if (!integer_zerop (lowbnd) && tree_fits_uhwi_p (lowbnd))\n+\t    {\n+\t      /* Adjust the index by the low bound of the array domain\n+\t\t (normally zero but 1 in Fortran).  */\n+\t      unsigned HOST_WIDE_INT lb = tree_to_uhwi (lowbnd);\n+\t      orng[0] -= lb;\n+\t      orng[1] -= lb;\n \t    }\n \n-\t  wide_int wisize = wi::to_wide (size);\n+\t  tree eltype = TREE_TYPE (ptr);\n+\t  tree tpsize = TYPE_SIZE_UNIT (eltype);\n+\t  if (!tpsize || TREE_CODE (tpsize) != INTEGER_CST)\n+\t    return false;\n+\n+\t  offset_int sz = wi::to_offset (tpsize);\n+\t  orng[0] *= sz;\n+\t  orng[1] *= sz;\n \n-\t  if (!*poff)\n+\t  if (TREE_CODE (eltype) == ARRAY_TYPE)\n \t    {\n-\t      /* If the \"inner\" offset is unknown and the \"outer\" offset\n-\t\t is either negative or less than SIZE, return the size\n-\t\t minus the offset.  This may be overly optimistic in\n-\t\t the first case if the inner offset happens to be less\n-\t\t than the absolute value of the outer offset.  */\n-\t      if (wi::neg_p (offrng[0]))\n-\t\treturn size;\n-\t      if (wi::ltu_p (offrng[0], wisize))\n-\t\treturn build_int_cst (sizetype, (wisize - offrng[0]).to_uhwi ());\n-\t      return size_zero_node;\n+\t      pref->sizrng[0] = pref->offrng[0] + orng[0] + sz;\n+\t      pref->sizrng[1] = pref->offrng[1] + orng[1] + sz;\n \t    }\n+\t}\n+\n+      pref->offrng[0] += orng[0];\n+      pref->offrng[1] += orng[1];\n \n-\t  /* Convert to the same precision to keep wide_int from \"helpfuly\"\n-\t     crashing whenever it sees other argumments.  */\n-\t  offrng[0] = wide_int::from (offrng[0], sizprec, SIGNED);\n-\t  offrng[1] = wide_int::from (offrng[1], sizprec, SIGNED);\n+      return true;\n+    }\n \n-\t  tree dstoff = *poff;\n-\t  if (integer_zerop (*poff))\n-\t    *poff = off;\n-\t  else if (!integer_zerop (off))\n+  if (TREE_CODE (ptr) == SSA_NAME)\n+    {\n+      gimple *stmt = SSA_NAME_DEF_STMT (ptr);\n+      if (is_gimple_call (stmt))\n+\t{\n+\t  /* If STMT is a call to an allocation function get the size\n+\t     from its argument(s).  If successful, also set *PDECL to\n+\t     PTR for the caller to include in diagnostics.  */\n+\t  wide_int wr[2];\n+\t  if (gimple_call_alloc_size (stmt, wr, rvals))\n \t    {\n-\t      *poff = fold_convert (ptrdiff_type_node, *poff);\n-\t      off = fold_convert (ptrdiff_type_node, off);\n-\t      *poff = size_binop (PLUS_EXPR, *poff, off);\n+\t      pref->ref = ptr;\n+\t      pref->sizrng[0] = offset_int::from (wr[0], UNSIGNED);\n+\t      pref->sizrng[1] = offset_int::from (wr[1], UNSIGNED);\n+\t      return true;\n \t    }\n+\t  return false;\n+\t}\n \n-\t  if (!wi::neg_p (offrng[0]))\n-\t    {\n-\t      if (TREE_CODE (size) != INTEGER_CST)\n-\t\treturn NULL_TREE;\n+      /* TODO: Handle PHI.  */\n \n-\t      /* Return the difference between the size and the offset\n-\t\t or zero if the offset is greater.  */\n-\t      wide_int wisize = wi::to_wide (size, sizprec);\n-\t      if (wi::ltu_p (wisize, offrng[0]))\n-\t\treturn size_zero_node;\n+      if (!is_gimple_assign (stmt))\n+\treturn false;\n \n-\t      return wide_int_to_tree (sizetype, wisize - offrng[0]);\n-\t    }\n+      ptr = gimple_assign_rhs1 (stmt);\n+\n+      tree_code code = gimple_assign_rhs_code (stmt);\n+      if (TREE_CODE (TREE_TYPE (ptr)) != POINTER_TYPE)\n+\t/* Avoid conversions from non-pointers.  */\n+\treturn false;\n \n-\t  wide_int dstoffrng[2];\n-\t  if (TREE_CODE (dstoff) == INTEGER_CST)\n-\t    dstoffrng[0] = dstoffrng[1] = wi::to_wide (dstoff);\n-\t  else if (TREE_CODE (dstoff) == SSA_NAME)\n+      if (code == POINTER_PLUS_EXPR)\n+\t{\n+\t  /* If the the offset in the expression can be determined use\n+\t     it to adjust the overall offset.  Otherwise, set the overall\n+\t     offset to the maximum.  */\n+\t  offset_int orng[2];\n+\t  tree off = gimple_assign_rhs2 (stmt);\n+\t  if (!get_range (off, SIGNED, orng, rvals)\n+\t      || !wi::les_p (orng[0], orng[1]))\n \t    {\n-\t      enum value_range_kind rng\n-\t\t= get_range_info (dstoff, dstoffrng, dstoffrng + 1);\n-\t      if (rng != VR_RANGE)\n-\t\treturn NULL_TREE;\n+\t      orng[0] = wi::to_offset (TYPE_MIN_VALUE (ptrdiff_type_node));\n+\t      orng[1] = wi::to_offset (TYPE_MAX_VALUE (ptrdiff_type_node));\n \t    }\n-\t  else\n-\t    return NULL_TREE;\n-\n-\t  dstoffrng[0] = wide_int::from (dstoffrng[0], sizprec, SIGNED);\n-\t  dstoffrng[1] = wide_int::from (dstoffrng[1], sizprec, SIGNED);\n \n-\t  if (!wi::neg_p (dstoffrng[0]))\n-\t    wisize += dstoffrng[0];\n-\n-\t  offrng[1] += dstoffrng[1];\n-\t  if (wi::neg_p (offrng[1]))\n-\t    return size_zero_node;\n-\n-\t  return wide_int_to_tree (sizetype, wisize);\n+\t  pref->offrng[0] += orng[0];\n+\t  pref->offrng[1] += orng[1];\n \t}\n+      else if (code != ADDR_EXPR)\n+\treturn false;\n \n-      return NULL_TREE;\n+      return compute_objsize (ptr, ostype, pref, visited, rvals);\n     }\n \n-  /* Try simple DECLs not handled above.  */\n-  if (tree size = addr_decl_size (dest, pdecl, poff))\n-    return size;\n-\n-  tree type = TREE_TYPE (dest);\n-  if (TREE_CODE (type) == POINTER_TYPE)\n-    type = TREE_TYPE (type);\n-\n+  tree type = TREE_TYPE (ptr);\n   type = TYPE_MAIN_VARIANT (type);\n-  if (TREE_CODE (dest) == ADDR_EXPR)\n-    dest = TREE_OPERAND (dest, 0);\n+  if (TREE_CODE (ptr) == ADDR_EXPR)\n+    ptr = TREE_OPERAND (ptr, 0);\n \n   if (TREE_CODE (type) == ARRAY_TYPE\n-      && !array_at_struct_end_p (dest))\n+      && !array_at_struct_end_p (ptr))\n     {\n       if (tree size = TYPE_SIZE_UNIT (type))\n-\treturn TREE_CODE (size) == INTEGER_CST ? size : NULL_TREE;\n+\treturn get_range (size, UNSIGNED, pref->sizrng, rvals);\n     }\n \n-  return NULL_TREE;\n+  return false;\n+}\n+\n+/* Convenience wrapper around the above.  */\n+\n+static tree\n+compute_objsize (tree ptr, int ostype, access_ref *pref,\n+\t\t const vr_values *rvals = NULL)\n+{\n+  bitmap visited = NULL;\n+\n+  bool success\n+    = compute_objsize (ptr, ostype, pref, &visited, rvals);\n+\n+  if (visited)\n+    BITMAP_FREE (visited);\n+\n+  if (!success)\n+    return NULL_TREE;\n+\n+  if (pref->offrng[0] < 0)\n+    {\n+      if (pref->offrng[1] < 0)\n+\treturn size_zero_node;\n+\n+      pref->offrng[0] = 0;\n+    }\n+\n+  if (pref->sizrng[1] < pref->offrng[0])\n+    return size_zero_node;\n+\n+  return wide_int_to_tree (sizetype, pref->sizrng[1] - pref->offrng[0]);\n+}\n+\n+/* Transitional wrapper around the above.  The function should be removed\n+   once callers transition to one of the two above.  */\n+\n+tree\n+compute_objsize (tree ptr, int ostype, tree *pdecl /* = NULL */,\n+\t\t tree *poff /* = NULL */, const vr_values *rvals /* = NULL */)\n+{\n+  /* Set the initial offsets to zero and size to negative to indicate\n+     none has been computed yet.  */\n+  access_ref ref;\n+  tree size = compute_objsize (ptr, ostype, &ref, rvals);\n+  if (!size)\n+    return NULL_TREE;\n+\n+  if (pdecl)\n+    *pdecl = ref.ref;\n+\n+  if (poff)\n+    *poff = wide_int_to_tree (ptrdiff_type_node, ref.offrng[ref.offrng[0] < 0]);\n+\n+  return size;\n }\n \n /* Helper to determine and check the sizes of the source and the destination\n@@ -4196,11 +4297,12 @@ check_memop_access (tree exp, tree dest, tree src, tree size)\n      try to determine the size of the largest source and destination\n      object using type-0 Object Size regardless of the object size\n      type specified by the option.  */\n-  tree srcsize = src ? compute_objsize (src, 0) : NULL_TREE;\n-  tree dstsize = compute_objsize (dest, 0);\n+  access_data data;\n+  tree srcsize = src ? compute_objsize (src, 0, &data.src) : NULL_TREE;\n+  tree dstsize = compute_objsize (dest, 0, &data.dst);\n \n   return check_access (exp, dest, src, size, /*maxread=*/NULL_TREE,\n-\t\t       srcsize, dstsize);\n+\t\t       srcsize, dstsize, true, &data);\n }\n \n /* Validate memchr arguments without performing any expansion.\n@@ -4220,9 +4322,11 @@ expand_builtin_memchr (tree exp, rtx)\n      of the object.  */\n   if (warn_stringop_overflow)\n     {\n-      tree size = compute_objsize (arg1, 0);\n+      access_data data;\n+      tree size = compute_objsize (arg1, 0, &data.src);\n       check_access (exp, /*dst=*/NULL_TREE, /*src=*/NULL_TREE, len,\n-\t\t    /*maxread=*/NULL_TREE, size, /*objsize=*/NULL_TREE);\n+\t\t    /*maxread=*/NULL_TREE, size, /*objsize=*/NULL_TREE,\n+\t\t    true, &data);\n     }\n \n   return NULL_RTX;\n@@ -4497,10 +4601,11 @@ expand_builtin_strcat (tree exp)\n      just diagnose cases when the souce string is longer than\n      the destination object.  */\n \n-  tree destsize = compute_objsize (dest, warn_stringop_overflow - 1);\n+  access_data data;\n+  tree destsize = compute_objsize (dest, warn_stringop_overflow - 1, &data.dst);\n \n   check_access (exp, dest, src, /*size=*/NULL_TREE, /*maxread=*/NULL_TREE, src,\n-\t\tdestsize);\n+\t\tdestsize, true, &data);\n \n   return NULL_RTX;\n }\n@@ -4521,9 +4626,11 @@ expand_builtin_strcpy (tree exp, rtx target)\n \n   if (warn_stringop_overflow)\n     {\n-      tree destsize = compute_objsize (dest, warn_stringop_overflow - 1);\n+      access_data data;\n+      tree destsize = compute_objsize (dest, warn_stringop_overflow - 1,\n+\t\t\t\t       &data.dst);\n       check_access (exp, dest, src, /*size=*/NULL_TREE, /*maxread=*/NULL_TREE,\n-\t\t    src, destsize);\n+\t\t    src, destsize, true, &data);\n     }\n \n   if (rtx ret = expand_builtin_strcpy_args (exp, dest, src, target))\n@@ -4579,9 +4686,11 @@ expand_builtin_stpcpy_1 (tree exp, rtx target, machine_mode mode)\n \n   if (warn_stringop_overflow)\n     {\n-      tree destsize = compute_objsize (dst, warn_stringop_overflow - 1);\n+      access_data data;\n+      tree destsize = compute_objsize (dst, warn_stringop_overflow - 1,\n+\t\t\t\t       &data.dst);\n       check_access (exp, dst, src, /*size=*/NULL_TREE, /*maxread=*/NULL_TREE,\n-\t\t    src, destsize);\n+\t\t    src, destsize, true, &data);\n     }\n \n   /* If return value is ignored, transform stpcpy into strcpy.  */\n@@ -4690,10 +4799,12 @@ expand_builtin_stpncpy (tree exp, rtx)\n   if (!check_nul_terminated_array (exp, src, len))\n     return NULL_RTX;\n \n+  access_data data;\n   /* The size of the destination object.  */\n-  tree destsize = compute_objsize (dest, warn_stringop_overflow - 1);\n+  tree destsize = compute_objsize (dest, warn_stringop_overflow - 1, &data.dst);\n \n-  check_access (exp, dest, src, len, /*maxread=*/NULL_TREE, src, destsize);\n+  check_access (exp, dest, src, len, /*maxread=*/NULL_TREE, src, destsize,\n+\t\ttrue, &data);\n \n   return NULL_RTX;\n }\n@@ -4733,12 +4844,13 @@ check_strncat_sizes (tree exp, tree objsize)\n   /* Try to verify that the destination is big enough for the shortest\n      string.  */\n \n+  access_data data;\n   if (!objsize && warn_stringop_overflow)\n     {\n       /* If it hasn't been provided by __strncat_chk, try to determine\n \t the size of the destination object into which the source is\n \t being copied.  */\n-      objsize = compute_objsize (dest, warn_stringop_overflow - 1);\n+      objsize = compute_objsize (dest, warn_stringop_overflow - 1, &data.dst);\n     }\n \n   /* Add one for the terminating nul.  */\n@@ -4769,10 +4881,10 @@ check_strncat_sizes (tree exp, tree objsize)\n \t  && tree_int_cst_lt (maxread, srclen)))\n     srclen = maxread;\n \n-  /* The number of bytes to write is LEN but check_access will also\n+  /* The number of bytes to write is LEN but check_access will alsoa\n      check SRCLEN if LEN's value isn't known.  */\n   return check_access (exp, dest, src, /*size=*/NULL_TREE, maxread, srclen,\n-\t\t       objsize);\n+\t\t       objsize, true, &data);\n }\n \n /* Similar to expand_builtin_strcat, do some very basic size validation\n@@ -4810,10 +4922,11 @@ expand_builtin_strncat (tree exp, rtx)\n       maxlen = lendata.maxbound;\n     }\n \n+  access_data data;\n   /* Try to verify that the destination is big enough for the shortest\n      string.  First try to determine the size of the destination object\n      into which the source is being copied.  */\n-  tree destsize = compute_objsize (dest, warn_stringop_overflow - 1);\n+  tree destsize = compute_objsize (dest, warn_stringop_overflow - 1, &data.dst);\n \n   /* Add one for the terminating nul.  */\n   tree srclen = (maxlen\n@@ -4843,8 +4956,8 @@ expand_builtin_strncat (tree exp, rtx)\n \t  && tree_int_cst_lt (maxread, srclen)))\n     srclen = maxread;\n \n-  /* The number of bytes to write is SRCLEN.  */\n-  check_access (exp, dest, src, NULL_TREE, maxread, srclen, destsize);\n+  check_access (exp, dest, src, NULL_TREE, maxread, srclen, destsize,\n+\t\ttrue, &data);\n \n   return NULL_RTX;\n }\n@@ -4873,13 +4986,14 @@ expand_builtin_strncpy (tree exp, rtx target)\n \n   if (warn_stringop_overflow)\n     {\n-      tree destsize = compute_objsize (dest,\n-\t\t\t\t       warn_stringop_overflow - 1);\n+      access_data data;\n+      tree destsize = compute_objsize (dest, warn_stringop_overflow - 1,\n+\t\t\t\t       &data.dst);\n \n       /* The number of bytes to write is LEN but check_access will also\n \t check SLEN if LEN's value isn't known.  */\n       check_access (exp, dest, src, len, /*maxread=*/NULL_TREE, src,\n-\t\t    destsize);\n+\t\t    destsize, true, &data);\n     }\n \n   /* We must be passed a constant len and src parameter.  */\n@@ -5192,16 +5306,18 @@ expand_builtin_memcmp (tree exp, rtx target, bool result_eq)\n \n   /* Diagnose calls where the specified length exceeds the size of either\n      object.  */\n-  tree size = compute_objsize (arg1, 0);\n+  access_data data;\n+  tree size = compute_objsize (arg1, 0, &data.src);\n   no_overflow = check_access (exp, /*dst=*/NULL_TREE, /*src=*/NULL_TREE,\n \t\t\t      len, /*maxread=*/NULL_TREE, size,\n-\t\t\t      /*objsize=*/NULL_TREE);\n+\t\t\t      /*objsize=*/NULL_TREE, true, &data);\n   if (no_overflow)\n     {\n-      size = compute_objsize (arg2, 0);\n+      access_data data;\n+      size = compute_objsize (arg2, 0, &data.src);\n       no_overflow = check_access (exp, /*dst=*/NULL_TREE, /*src=*/NULL_TREE,\n \t\t\t\t  len,  /*maxread=*/NULL_TREE, size,\n-\t\t\t\t  /*objsize=*/NULL_TREE);\n+\t\t\t\t  /*objsize=*/NULL_TREE, true, &data);\n     }\n \n   /* If the specified length exceeds the size of either object, "}, {"sha": "8b812ceb2c4e9660519b12004b0ce4171a378562", "filename": "gcc/builtins.h", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "patch": "@@ -152,12 +152,39 @@ extern bool target_char_cst_p (tree t, char *p);\n extern internal_fn associated_internal_fn (tree);\n extern internal_fn replacement_internal_fn (gcall *);\n \n-bool check_nul_terminated_array (tree, tree, tree = NULL_TREE);\n+extern bool check_nul_terminated_array (tree, tree, tree = NULL_TREE);\n extern void warn_string_no_nul (location_t, const char *, tree, tree);\n extern tree unterminated_array (tree, tree * = NULL, bool * = NULL);\n extern bool builtin_with_linkage_p (tree);\n-extern bool check_access (tree, tree, tree, tree, tree, tree, tree,\n-\t\t\t  bool = true);\n \n+/* Describes a reference to an object used in an access.  */\n+struct access_ref\n+{\n+  access_ref (): ref ()\n+  {\n+    /* Set to valid.  */\n+    offrng[0] = offrng[1] = 0;\n+    /* Invalidate.   */\n+    sizrng[0] = sizrng[1] = -1;\n+  }\n+\n+  /* Reference to the object.  */\n+  tree ref;\n+\n+  /* Range of offsets into and sizes of the object(s).  */\n+  offset_int offrng[2];\n+  offset_int sizrng[2];\n+};\n+\n+/* Describes a pair of references used in an access by built-in\n+   functions like memcpy.  */\n+struct access_data\n+{\n+  /* Destination and source of the access.  */\n+  access_ref dst, src;\n+};\n+\n+extern bool check_access (tree, tree, tree, tree, tree, tree, tree,\n+\t\t\t  bool = true, const access_data * = NULL);\n \n #endif /* GCC_BUILTINS_H */"}, {"sha": "512fc138528e97107844eccf39e885c15d45ce1c", "filename": "gcc/gimple-ssa-warn-restrict.c", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Fgimple-ssa-warn-restrict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Fgimple-ssa-warn-restrict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-warn-restrict.c?ref=a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "patch": "@@ -1274,6 +1274,27 @@ builtin_access::strcpy_overlap ()\n   return generic_overlap ();\n }\n \n+/* For a BASE of array type, clamp REFOFF to at most [0, BASE_SIZE]\n+   if known, or [0, MAXOBJSIZE] otherwise.  */\n+\n+static void\n+clamp_offset (tree base, offset_int refoff[2], offset_int maxobjsize)\n+{\n+  if (!base || TREE_CODE (TREE_TYPE (base)) != ARRAY_TYPE)\n+    return;\n+\n+  if (refoff[0] < 0 && refoff[1] >= 0)\n+    refoff[0] = 0;\n+\n+  if (refoff[1] < refoff[0])\n+    {\n+      offset_int maxsize =  maxobjsize;\n+      if (tree size = TYPE_SIZE_UNIT (TREE_TYPE (base)))\n+\tmaxsize = wi::to_offset (size);\n+\n+      refoff[1] = wi::umin (refoff[1], maxsize);\n+    }\n+}\n \n /* Return true if DSTREF and SRCREF describe accesses that either overlap\n    one another or that, in order not to overlap, would imply that the size\n@@ -1312,35 +1333,12 @@ builtin_access::overlap ()\n \n   /* If the base object is an array adjust the bounds of the offset\n      to be non-negative and within the bounds of the array if possible.  */\n-  if (dstref->base\n-      && TREE_CODE (TREE_TYPE (dstref->base)) == ARRAY_TYPE)\n-    {\n-      if (acs.dstoff[0] < 0 && acs.dstoff[1] >= 0)\n-\tacs.dstoff[0] = 0;\n-\n-      if (acs.dstoff[1] < acs.dstoff[0])\n-\t{\n-\t  if (tree size = TYPE_SIZE_UNIT (TREE_TYPE (dstref->base)))\n-\t    acs.dstoff[1] = wi::umin (acs.dstoff[1], wi::to_offset (size));\n-\t  else\n-\t    acs.dstoff[1] = wi::umin (acs.dstoff[1], maxobjsize);\n-\t}\n-    }\n+  clamp_offset (dstref->base, acs.dstoff, maxobjsize);\n \n   acs.srcoff[0] = srcref->offrange[0];\n   acs.srcoff[1] = srcref->offrange[1];\n \n-  if (srcref->base\n-      && TREE_CODE (TREE_TYPE (srcref->base)) == ARRAY_TYPE)\n-    {\n-      if (acs.srcoff[0] < 0 && acs.srcoff[1] >= 0)\n-\tacs.srcoff[0] = 0;\n-\n-      if (tree size = TYPE_SIZE_UNIT (TREE_TYPE (srcref->base)))\n-\tacs.srcoff[1] = wi::umin (acs.srcoff[1], wi::to_offset (size));\n-      else if (acs.srcoff[1] < acs.srcoff[0])\n-\tacs.srcoff[1] = wi::umin (acs.srcoff[1], maxobjsize);\n-    }\n+  clamp_offset (srcref->base, acs.srcoff, maxobjsize);\n \n   /* When the upper bound of the offset is less than the lower bound\n      the former is the result of a negative offset being represented"}, {"sha": "f29eee29e8544381ebf803397fefafff72e4acfa", "filename": "gcc/testsuite/c-c++-common/Wstringop-truncation.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-truncation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-truncation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2FWstringop-truncation.c?ref=a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "patch": "@@ -269,7 +269,7 @@ void test_strncpy_array (Dest *pd, int i, const char* s)\n   CPY (dst7, s, 7);                 /* { dg-warning \"specified bound 7 equals destination size\" } */\n   CPY (dst7, s, sizeof dst7);       /* { dg-warning \"specified bound 7 equals destination size\" } */\n \n-  CPY (dst2_5[0], s, sizeof dst2_5[0]); /* { dg-warning \"specified bound 5 equals destination size\" \"bug 77293\" { xfail *-*-* } } */\n+  CPY (dst2_5[0], s, sizeof dst2_5[0]); /* { dg-warning \"specified bound 5 equals destination size\" \"bug 77293\" } */\n   CPY (dst2_5[1], s, sizeof dst2_5[1]); /* { dg-warning \"specified bound 5 equals destination size\" } */\n \n   /* Verify that copies that nul-terminate are not diagnosed.  */"}, {"sha": "3f1c6c715ea3e3b8caccc976f9cd48bed0fe9967", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-46.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-46.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-46.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-46.c?ref=a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "patch": "@@ -66,8 +66,10 @@ void strcpy_global (void)\n   T (gma.a17, 17);        // { dg-warning \"'strcpy' offset 157 from the object at 'gma' is out of the bounds of referenced subobject 'a17' with type 'char\\\\\\[17]' at offset 140\" }\n \n   SA (__builtin_offsetof (struct MA17, ax) == 157);\n-\n-  T (gma.ax, 0);          // { dg-warning \"'strcpy' offset 157 from the object at 'gma' is out of the bounds of referenced subobject 'ax' with type 'char[]' at offset 157|'strcpy' offset 157 is out of the bounds \\\\\\[0, 157] of object 'gma' with type 'struct MA17'\" }\n+  // GCC allows static initialization of flexible array members of\n+  // non-local objects.  Verify that writing into one that may be\n+  // initialized in another translation unit isn't diagnosed.  */\n+  T (gma.ax, 0);          // { dg-bogus \"\\\\\\[-Warray-bounds\" }\n }\n \n "}, {"sha": "878fc811bc6269642236a5faf79f8189ab5a8042", "filename": "gcc/testsuite/gcc.dg/Wrestrict-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWrestrict-9.c?ref=a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "patch": "@@ -1,7 +1,7 @@\n /* PR tree-optimization/84095 - false-positive -Wrestrict warnings for\n    strcpy within array\n    { dg-do compile }\n-   { dg-options \"-O2 -Wrestrict -ftrack-macro-expansion=0\" } */\n+   { dg-options \"-O2 -Wrestrict -Wno-stringop-overflow -ftrack-macro-expansion=0\" } */\n \n typedef __SIZE_TYPE__ size_t;\n "}, {"sha": "1e67b5fd928533e968e8cb1a871fa4024b1ac9bf", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-12.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-12.c?ref=a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "patch": "@@ -29,15 +29,15 @@ void test_memcpy_array_cst_range_off (const void *s)\n   T (d + UR (1, 2), 6);       /* { dg-warning \".memcpy. writing 6 bytes into a region of size 5 overflows the destination\" } */\n   T (d + UR (1, 2), 7);       /* { dg-warning \"writing 7 bytes into a region of size 5 \" } */\n \n-  T (d + SR (-3, -2), 1);     /* { dg-warning \"writing 1 byte into a region of size 0 \" \"pr85350\" { xfail *-*-* } } */\n+  T (d + SR (-3, -2), 1);     /* { dg-warning \"writing 1 byte into a region of size 0 \" } */\n   T (d + SR (-2, -1), 1);\n   T (d + SR (-2, -1), 2);     /* { dg-warning \"writing 2 bytes into a region of size 7 \" \"pr89428\" { xfail *-*-* } } */\n-  T (d + SR (-2, -1), 9);     /* { dg-warning \"writing 9 bytes into a region of size 7 \" \"pr85350\" { xfail *-*-* } } */\n+  T (d + SR (-2, -1), 9);     /* { dg-warning \"writing 9 bytes into a region of size 7 \" } */\n \n   d = ga7 + 7;\n   T (d + SR (-7, -6), 1);\n   T (d + SR (-7, -1), 1);\n-  T (d + SR (-2, -1), 3);     /* { dg-warning \"writing 3 bytes into a region of size 2 \" \"pr85350\" { xfail *-*-* } } */\n+  T (d + SR (-2, -1), 3);     /* { dg-warning \"writing 3 bytes into a region of size 2 \" } */\n \n   T (d + UR (1, 2), 1);       /* { dg-warning \"writing 1 byte into a region of size 0 \" } */\n }\n@@ -67,15 +67,15 @@ void test_memset_array_unsigned_off (void)\n   T (d + UR (1, 2), 6);       /* { dg-warning \".memset. writing 6 bytes into a region of size 5 overflows the destination\" } */\n   T (d + UR (1, 2), 7);       /* { dg-warning \"writing 7 bytes into a region of size 5 \" } */\n \n-  T (d + SR (-3, -2), 1);     /* { dg-warning \"writing 1 byte into a region of size 0 \" \"pr85350\" { xfail *-*-* } } */\n+  T (d + SR (-3, -2), 1);     /* { dg-warning \"writing 1 byte into a region of size 0 \" } */\n   T (d + SR (-2, -1), 1);\n   T (d + SR (-2, -1), 2);     /* { dg-warning \"writing 2 bytes into a region of size 7 \" \"pr89428\" { xfail *-*-* } } */\n-  T (d + SR (-2, -1), 9);     /* { dg-warning \"writing 9 bytes into a region of size 7 \" \"pr85350\" { xfail *-*-* } } */\n+  T (d + SR (-2, -1), 9);     /* { dg-warning \"writing 9 bytes into a region of size 7 \" } */\n \n   d = ga7 + 7;\n   T (d + SR (-7, -6), 1);\n   T (d + SR (-7, -1), 1);\n-  T (d + SR (-2, -1), 3);     /* { dg-warning \"writing 3 bytes into a region of size 2 \" \"pr85350\" { xfail *-*-* } } */\n+  T (d + SR (-2, -1), 3);     /* { dg-warning \"writing 3 bytes into a region of size 2 \" } */\n \n   T (d + UR (1, 2), 1);       /* { dg-warning \"writing 1 byte into a region of size 0 \" } */\n }\n@@ -110,8 +110,8 @@ void test_memcpy_array_signed_off (const void *s)\n \n   T (d + SR (-7, 7), 7);\n   T (d + SR (-1, 1), 7);\n-  T (d + SR (-1, 1), 9);      /* { dg-warning \"writing 9 bytes into a region of size \" \"pr89428\" { xfail *-*-* } } */\n-  T (d + SR (-1, 2), 9);      /* { dg-warning \"writing 9 bytes into a region of size \" \"pr89428\" { xfail *-*-* } } */\n+  T (d + SR (-1, 1), 9);      /* { dg-warning \"writing 9 bytes into a region of size \" } */\n+  T (d + SR (-1, 2), 9);      /* { dg-warning \"writing 9 bytes into a region of size \" } */\n   T (d + SR (1, 2), 1);\n   T (d + SR (1, 2), 5);\n "}, {"sha": "be7f51ad3a5626a6f1b0499ba2c50023e7e9ca5c", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-28.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-28.c?ref=a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "patch": "@@ -224,7 +224,7 @@ void ptr_sub_from_end (int n, int i0, int i1, int i2, int i3)\n   q += n;      //  N=1     N=2\n   q[-1] = 0;   // p[0]    p[1]\n   q[-2] = 1;   // p[-1]   p[0]\n-  q[-3] = 2;   // p[-2]   p[-1]   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr92939: negative offset from end\" { xfail *-*-* } }\n+  q[-3] = 2;   // p[-2]   p[-1]   // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr92939: negative offset from end\" }\n \n   /* The following isn't diagnosed because the warning doesn't recognize\n      the index below as necessarily having the same value as the size"}, {"sha": "fd43f3afb59fcb18956d40dc4ebd0c2aa45a3892", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-34.c", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-34.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-34.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-34.c?ref=a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "patch": "@@ -0,0 +1,252 @@\n+/* PR middle-end/95353 - spurious -Wstringop-overflow writing to a trailing\n+   array plus offset\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+struct S0 { char n, a[0]; };\n+\n+\n+void s0_nowarn_cstidx (struct S0 *p)\n+{\n+  char *q = p->a;\n+  q[1] = __LINE__;\n+  q[9] = __LINE__;\n+}\n+\n+void s0_nowarn_cstoff_cstidx (struct S0 *p)\n+{\n+  char *q = p->a + 1;\n+  q[1] = __LINE__;\n+  q[9] = __LINE__;\n+}\n+\n+void s0_nowarn_varoff_cstdix (struct S0 *p, int i)\n+{\n+  char *q = p->a + i;\n+  q[1] = __LINE__;            // { dg-bogus \"\\\\\\[-Wstringop-overflow\" }\n+  q[9] = __LINE__;            // { dg-bogus \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+void s0_nowarn_cstoff_varidx (struct S0 *p, int i)\n+{\n+  char *q = p->a + 1;\n+  q[i] = __LINE__;\n+}\n+\n+void s0_nowarn_varoff_varidx (struct S0 *p, int i, int j)\n+{\n+  char *q = p->a + i;\n+  q[j] = __LINE__;            // { dg-bogus \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+\n+/* Accesses past the end of a trailing array with one element is\n+   discouraged but still reluctantly not diagnosed.  This should\n+   change.  */\n+\n+struct S1 { char n, a[1]; };\n+\n+\n+void s1_nowarn_cstidx (struct S1 *p)\n+{\n+  char *q = p->a;\n+  q[1] = __LINE__;\n+  q[9] = __LINE__;\n+}\n+\n+void s1_nowarn_cstoff_cstidx (struct S1 *p)\n+{\n+  char *q = p->a + 1;\n+  q[1] = __LINE__;\n+  q[9] = __LINE__;\n+}\n+\n+void s1_nowarn_varoff_cstdix (struct S1 *p, int i)\n+{\n+  char *q = p->a + i;\n+  q[1] = __LINE__;            // { dg-bogus \"\\\\\\[-Wstringop-overflow\" }\n+  q[9] = __LINE__;            // { dg-bogus \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+void s1_nowarn_cstoff_varidx (struct S1 *p, int i)\n+{\n+  char *q = p->a + 1;\n+  q[i] = __LINE__;\n+}\n+\n+void s1_nowarn_varoff_varidx (struct S1 *p, int i, int j)\n+{\n+  char *q = p->a + i;\n+  q[j] = __LINE__;\n+}\n+\n+\n+/* Accesses past the end of a trailing array with more than one\n+   element should be diagnosed but aren't yet because the MEM_REF\n+   makes the out-of-bounds accesses indistinguishable from valid\n+   ones to subsequent elements of the array pointed by P.  */\n+\n+struct S2 { char n, a[2]; };\n+\n+\n+void s2_warn_cstidx (struct S2 *p)\n+{\n+  char *q = p->a;\n+\n+  /* The following invalid store is represented as\n+       MEM[(char *)p_1(D) + 3B] = __LINE__;\n+     which is indistinguishable from the valid\n+       q = &p[1].n; q[0] = __LINE__;\n+  */\n+  q[2] = __LINE__;            // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr?????\" { xfail *-*-* } }\n+}\n+\n+void s2_warn_cstoff_cstidx (struct S2 *p)\n+{\n+  char *q = p->a + 1;\n+  q[1] = __LINE__;            // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr?????\" { xfail *-*-* }  }\n+}\n+\n+void s2_warn_varoff_cstdix (struct S2 *p, int i)\n+{\n+  char *q = p->a + i;\n+  q[2] = __LINE__;            // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr?????\" { xfail *-*-* }  }\n+}\n+\n+void s2_warn_cstoff_varidx (struct S2 *p, int i)\n+{\n+  char *q = p->a + 1;\n+  q[i] = __LINE__;            // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr?????\" { xfail *-*-* }  }\n+}\n+\n+void s2_warn_varoff_varidx (struct S2 *p, int i, int j)\n+{\n+  char *q = p->a + i;\n+  q[j] = __LINE__;            // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr?????\" { xfail *-*-* }  }\n+}\n+\n+\n+/* Verify that none of these triggers a bogus warning (not tested\n+   elsewhere but triggered during bootstrap).  */\n+\n+void s2_nowarn_varidx_int (struct S2 *p, int i)\n+{\n+  extern struct S2 s2;\n+  extern struct S2 s2a[];\n+\n+  s2.a[i - 1] = __LINE__;\n+  s2.a[i] = __LINE__;\n+  s2.a[i + 1] = __LINE__;\n+\n+  s2a[i].a[i - 1] = __LINE__;\n+  s2a[i].a[i] = __LINE__;\n+  s2a[i].a[i + 1] = __LINE__;\n+\n+  p[i].a[i - 1] = __LINE__;\n+  p[i].a[i] = __LINE__;\n+  p[i].a[i + 1] = __LINE__;\n+\n+  char *q = p->a;\n+  q[i - 1] = __LINE__;\n+  q[i] = __LINE__;\n+  q[i + 1] = __LINE__;\n+}\n+\n+/* Same as above but with a size_t index in range [1, SIZE_MAX].  */\n+\n+void* s2_nowarn_varidx_size (struct S2 *p, size_t i, size_t j)\n+{\n+  extern struct S2 s2;\n+  extern struct S2 s2a[];\n+  struct S2 *ps2 = __builtin_malloc (3 * sizeof *ps2);\n+\n+  s2.a[i - 1] = __LINE__;\n+  s2.a[i] = __LINE__;\n+  s2.a[i + 1] = __LINE__;\n+\n+  s2a[i].a[i - 1] = __LINE__;\n+  s2a[i].a[i] = __LINE__;\n+  s2a[i].a[i + 1] = __LINE__;\n+\n+  p[i].a[i - 1] = __LINE__;\n+  p[i].a[i] = __LINE__;\n+  p[i].a[i + 1] = __LINE__;\n+\n+  ps2->a[i - 1] = __LINE__;\n+  ps2->a[i] = __LINE__;\n+  ps2->a[i + 1] = __LINE__;\n+\n+  char *q = p->a;\n+  q[i - 1] = __LINE__;\n+  q[i] = __LINE__;\n+  q[i + 1] = __LINE__;\n+\n+  if (j == 0)\n+    return ps2;\n+\n+  s2.a[j - 1] = __LINE__;\n+  s2.a[j] = __LINE__;\n+  s2.a[j + 1] = __LINE__;\n+\n+  s2a[j].a[j - 1] = __LINE__;\n+  s2a[j].a[j] = __LINE__;\n+  s2a[j].a[j + 1] = __LINE__;\n+\n+  p[j].a[j - 1] = __LINE__;\n+  p[j].a[j] = __LINE__;\n+  p[j].a[j + 1] = __LINE__;\n+\n+  ps2->a[j - 1] = __LINE__;\n+  ps2->a[j] = __LINE__;\n+  ps2->a[j + 1] = __LINE__;\n+\n+  q = p->a;\n+  q[j - 1] = __LINE__;\n+  q[j] = __LINE__;\n+  q[j + 1] = __LINE__;\n+\n+  return ps2;\n+}\n+\n+/* Verify that accesses to an interior zero-length array are diagnosed.  */\n+\n+struct Si0 { char c, a[0], d; };\n+\n+void si0_warn_cstidx (struct Si0 *p)\n+{\n+  // These are indistinguishable from valid accesses to p->d:\n+  //   MEM[(char *)p_1(D) + 1B] = 0;\n+  char *q = p->a;\n+  q[1] = __LINE__;            // { dg-warning \"writing 1 byte into a region of size 0\"  \"pr?????\" { xfail *-*-* } }\n+  q[9] = __LINE__;            // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr?????\" { xfail *-*-* } }\n+}\n+\n+void si0_warn_cstoff_cstidx (struct Si0 *p)\n+{\n+  // Like those above, these too are indistinguishable from valid accesses\n+  // to p->d.\n+  char *q = p->a + 1;\n+  q[1] = __LINE__;            // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr?????\" { xfail *-*-* } }\n+  q[9] = __LINE__;            // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr?????\" { xfail *-*-* } }\n+}\n+\n+void si0_warn_varoff_cstdix (struct Si0 *p, int i)\n+{\n+  char *q = p->a + i;\n+  q[1] = __LINE__;            // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+  q[9] = __LINE__;            // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}\n+\n+void si0_warn_cstoff_varidx (struct Si0 *p, int i)\n+{\n+  char *q = p->a + 1;\n+  q[i] = __LINE__;            // { dg-warning \"\\\\\\[-Wstringop-overflow\" \"pr?????\" { xfail *-*-* } }\n+}\n+\n+void si0_warn_varoff_varidx (struct Si0 *p, int i, int j)\n+{\n+  char *q = p->a + i;\n+  q[j] = __LINE__;            // { dg-warning \"\\\\\\[-Wstringop-overflow\" }\n+}"}, {"sha": "612137ee469c1ff5a2f29c0cac7f202192ebf6b4", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-35.c", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-35.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-35.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-35.c?ref=a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "patch": "@@ -0,0 +1,76 @@\n+/* Verify that calls to strcpy to write to an element of an array of pointers\n+   are not diagnosed (due to mistakenly using the size of the array as that\n+   of the destination).\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+typedef char A1[1];\n+typedef char A2[2];\n+typedef char A3[3];\n+typedef char A4[4];\n+typedef char A5[5];\n+typedef char A6[6];\n+typedef char A7[7];\n+typedef char A8[8];\n+typedef char A9[9];\n+typedef char A10[10];\n+\n+A1* pa1[3];\n+A2* pa2[3];\n+A3* pa3[3];\n+A4* pa4[3];\n+A5* pa5[3];\n+A6* pa6[3];\n+A7* pa7[3];\n+A8* pa8[3];\n+A9* pa9[3];\n+A10* pa10[3];\n+\n+void nowarn_a1_1 (int i)\n+{\n+  __builtin_strcpy (*pa1[0], \"\");\n+  __builtin_strcpy (*pa1[1], \"\");\n+  __builtin_strcpy (*pa1[i], \"\");\n+}\n+\n+void nowarn_a2_2 (int i)\n+{\n+  __builtin_strcpy (*pa2[0], \"1\");\n+  __builtin_strcpy (*pa2[1], \"2\");\n+  __builtin_strcpy (*pa2[i], \"3\");\n+}\n+\n+void nowarn_a3_3 (int i)\n+{\n+  __builtin_strcpy (*pa3[0], \"12\");\n+  __builtin_strcpy (*pa3[1], \"23\");\n+  __builtin_strcpy (*pa3[i], \"34\");\n+}\n+\n+void nowarn_a4_4 (int i)\n+{\n+  __builtin_strcpy (*pa4[0], \"123\");\n+  __builtin_strcpy (*pa4[1], \"234\");\n+  __builtin_strcpy (*pa4[i], \"345\");\n+}\n+\n+void nowarn_a5_5 (int i)\n+{\n+  __builtin_strcpy (*pa5[0], \"1234\");\n+  __builtin_strcpy (*pa5[1], \"2345\");\n+  __builtin_strcpy (*pa5[i], \"3456\");\n+}\n+\n+void nowarn_a6_6 (int i)\n+{\n+  __builtin_strcpy (*pa6[0], \"12345\");\n+  __builtin_strcpy (*pa6[1], \"23456\");\n+  __builtin_strcpy (*pa6[1], \"34567\");\n+}\n+\n+void nowarn_a10_10 (int i)\n+{\n+  __builtin_strcpy (*pa10[0], \"0123456789\");\n+  __builtin_strcpy (*pa10[1], \"1234567890\");\n+  __builtin_strcpy (*pa10[i], \"2345678909\");\n+}"}, {"sha": "3f0874dc5bb11f2d52bb4dc7812d783e3b47cf71", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-36.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-36.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-36.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-36.c?ref=a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "patch": "@@ -0,0 +1,24 @@\n+/* Verify that casts between pointers and integers don't trigger false\n+   positives.  Test derived from Glibc's _dl_allocate_tls_storage() in\n+   dl-tls.c.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wno-array-bounds\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+typedef __UINTPTR_TYPE__ uintptr_t;\n+\n+size_t a;\n+size_t s;\n+\n+void* _dl_allocate_tls_storage (void)\n+{\n+  void *p = __builtin_malloc (s + a + sizeof (void *));\n+\n+  char *q = (char *)(__builtin_constant_p (a) && (((a - 1) & a) == 0)\n+             ? ((((uintptr_t)p) + a - 1) & ~(a - 1))\n+             : (((((uintptr_t)p) + (a - 1)) / a) * a));\n+\n+  char *r = q + s - sizeof (int[4]);\n+  __builtin_memset (r, '\\0', sizeof (int[4]));\n+  return r;\n+}"}, {"sha": "339f904d7a62ca13624a739ed669a8bcc4552365", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-37.c", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-37.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-37.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-37.c?ref=a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "patch": "@@ -0,0 +1,229 @@\n+/* Verify that -Wstringop-overflow detects writing past the end of each\n+   individual element of a multidimensional array.\n+  { dg-do compile }\n+  { dg-options \"-O2 -Wall -Wno-array-bounds -Wno-stringop-truncation\" } */\n+\n+#define CONCAT(x, y)    x ## y\n+#define CAT(name, line) CONCAT (name, line)\n+#define UNIQ_NAME(name) CAT (name, __LINE__)\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void* malloc (size_t);\n+extern char* strncpy (char*, const char*, size_t);\n+\n+extern char a2_2_8[2][2][8];\n+\n+void nowarn_a2_2_8 (const char *s)\n+{\n+  // The following trigger -Wstringop-truncation.\n+  strncpy (a2_2_8[0][0], s, 8);\n+  strncpy (a2_2_8[0][1], s, 8);\n+  strncpy (a2_2_8[1][0], s, 8);\n+  strncpy (a2_2_8[1][1], s, 8);\n+}\n+\n+void warn_a2_2_8 (const char *s)\n+{\n+  strncpy (a2_2_8[0][0], s, 9);         // { dg-warning \"writing 9 bytes into a region of size 8 \" }\n+  strncpy (a2_2_8[0][1], s, 9);         // { dg-warning \"writing 9 bytes into a region of size 8 \" }\n+  strncpy (a2_2_8[1][0], s, 9);         // { dg-warning \"writing 9 bytes into a region of size 8 \" }\n+  strncpy (a2_2_8[1][1], s, 9);         // { dg-warning \"writing 9 bytes into a region of size 8 \" }\n+}\n+\n+\n+extern char a2_3_5[2][3][5];\n+\n+void nowarn_a2_3_5 (const char *s)\n+{\n+  // The following trigger -Wstringop-truncation.\n+  strncpy (a2_3_5[0][0], s, 5);\n+  strncpy (a2_3_5[0][1], s, 5);\n+  strncpy (a2_3_5[0][2], s, 5);\n+  strncpy (a2_3_5[1][0], s, 5);\n+  strncpy (a2_3_5[1][1], s, 5);\n+  strncpy (a2_3_5[1][2], s, 5);\n+}\n+\n+void warn_a2_3_5 (const char *s)\n+{\n+  strncpy (a2_3_5[0][0], s, 6);         // { dg-warning \"writing 6 bytes into a region of size 5 \" }\n+  strncpy (a2_3_5[0][1], s, 7);         // { dg-warning \"writing 7 bytes into a region of size 5 \" }\n+  strncpy (a2_3_5[1][0], s, 8);         // { dg-warning \"writing 8 bytes into a region of size 5 \" }\n+  strncpy (a2_3_5[1][1], s, 9);         // { dg-warning \"writing 9 bytes into a region of size 5 \" }\n+}\n+\n+\n+void* nowarn_malloc_3_5 (const char *s, unsigned n)\n+{\n+  if (n < 3 || 5 < n)\n+    n = 3;\n+  char *p = (char*)malloc (n);\n+  strncpy (p + 1, s, 4);\n+  return p;\n+}\n+\n+void* warn_malloc_3_5 (const char *s, unsigned n)\n+{\n+  if (n < 3 || 5 < n)\n+    n = 3;\n+  char *p = (char*)malloc (n);          // { dg-message \"at offset 1 into destination object of size \\\\\\[3, 5] allocated by 'malloc'\" }\n+  // The size below should be a range like the one above.\n+  strncpy (p + 1, s, 5);                // { dg-warning \"writing 5 bytes into a region of size 4 \" }\n+  return p;\n+}\n+\n+\n+typedef __attribute__ ((alloc_size (1, 2))) void* UsrAlloc (int, int);\n+\n+void* nowarn_use_alloc_3_5 (UsrAlloc *usr_alloc, const char *s, unsigned n)\n+{\n+  if (n < 3 || 5 < n)\n+    n = 3;\n+  char *p = (char*)usr_alloc (n, 3);\n+  strncpy (p + 1, s, 14);\n+  return p;\n+}\n+\n+void* warn_usr_alloc_3_5 (UsrAlloc *usr_alloc, const char *s, unsigned n)\n+{\n+  if (n < 3 || 5 < n)\n+    n = 3;\n+  char *p = (char*)usr_alloc (n, 3);    // { dg-message \"at offset 1 into destination object of size \\\\\\[9, 15] allocated by 'usr_alloc'\" }\n+  // The size below should be a range like the one above.\n+  strncpy (p + 1, s, 15);               // { dg-warning \"writing 15 bytes into a region of size 14 \" }\n+  return p;\n+}\n+\n+struct S\n+{\n+  char a2_3_4[2][3][4];\n+  char a3_4_5[3][4][5];\n+};\n+\n+extern struct S sa[];\n+\n+void nowarn_sa_cstidx_cstsize (const char* const s[])\n+{\n+  strncpy (sa[0].a2_3_4[0][0], s[0], 4);\n+  strncpy (sa[0].a2_3_4[0][1], s[1], 4);\n+  strncpy (sa[0].a2_3_4[0][2], s[2], 4);\n+\n+  strncpy (sa[0].a2_3_4[1][0], s[3], 4);\n+  strncpy (sa[0].a2_3_4[1][1], s[4], 4);\n+  strncpy (sa[0].a2_3_4[1][2], s[5], 4);\n+\n+  strncpy (sa[1].a2_3_4[0][0], s[6], 4);\n+  strncpy (sa[1].a2_3_4[0][1], s[7], 4);\n+  strncpy (sa[1].a2_3_4[0][2], s[8], 4);\n+\n+  strncpy (sa[1].a2_3_4[1][0], s[9], 4);\n+  strncpy (sa[1].a2_3_4[1][1], s[10], 4);\n+  strncpy (sa[1].a2_3_4[1][2], s[11], 4);\n+}\n+\n+void warn_sa_cstidx_cstsize (const char* const s[])\n+{\n+  strncpy (sa[0].a2_3_4[0][0], s[0], 5);    // { dg-warning \"writing 5 bytes into a region of size 4 \" }\n+  strncpy (sa[0].a2_3_4[0][1], s[1], 6);    // { dg-warning \"writing 6 bytes into a region of size 4 \" }\n+  strncpy (sa[0].a2_3_4[0][2], s[2], 7);    // { dg-warning \"writing 7 bytes into a region of size 4 \" }\n+\n+  strncpy (sa[0].a2_3_4[1][0], s[3], 5);    // { dg-warning \"writing 5 bytes into a region of size 4 \" }\n+  strncpy (sa[0].a2_3_4[1][1], s[4], 6);    // { dg-warning \"writing 6 bytes into a region of size 4 \" }\n+  strncpy (sa[0].a2_3_4[1][2], s[5], 7);    // { dg-warning \"writing 7 bytes into a region of size 4 \" }\n+\n+  strncpy (sa[1].a2_3_4[0][0], s[6], 5);    // { dg-warning \"writing 5 bytes into a region of size 4 \" }\n+  strncpy (sa[1].a2_3_4[0][1], s[7], 6);    // { dg-warning \"writing 6 bytes into a region of size 4 \" }\n+  strncpy (sa[1].a2_3_4[0][2], s[8], 7);    // { dg-warning \"writing 7 bytes into a region of size 4 \" }\n+\n+  strncpy (sa[1].a2_3_4[1][0], s[9], 5);    // { dg-warning \"writing 5 bytes into a region of size 4 \" }\n+  strncpy (sa[1].a2_3_4[1][1], s[10], 6);   // { dg-warning \"writing 6 bytes into a region of size 4 \" }\n+  strncpy (sa[1].a2_3_4[1][2], s[11], 7);   // { dg-warning \"writing 7 bytes into a region of size 4 \" }\n+}\n+\n+void nowarn_sa_cstidx_varsize (const char* const s[], unsigned n)\n+{\n+  strncpy (sa[0].a2_3_4[0][0], s[0], n);\n+  strncpy (sa[0].a2_3_4[0][1], s[1], n);\n+  strncpy (sa[0].a2_3_4[0][2], s[2], n);\n+\n+  strncpy (sa[0].a2_3_4[1][0], s[3], n);\n+  strncpy (sa[0].a2_3_4[1][1], s[4], n);\n+  strncpy (sa[0].a2_3_4[1][2], s[5], n);\n+\n+  strncpy (sa[1].a2_3_4[0][0], s[6], n);\n+  strncpy (sa[1].a2_3_4[0][1], s[7], n);\n+  strncpy (sa[1].a2_3_4[0][2], s[8], n);\n+\n+  strncpy (sa[1].a2_3_4[1][0], s[9], n);\n+  strncpy (sa[1].a2_3_4[1][1], s[10], n);\n+  strncpy (sa[1].a2_3_4[1][2], s[11], n);\n+}\n+\n+void nowarn_sa_loop (const char* const s[], unsigned n)\n+{\n+  for (unsigned i0 = 0; i0 != 5; ++i0)\n+    for (unsigned i1 = 0; i1 != 3; ++i1)\n+      for (unsigned i2 = 0; i2 != 2; ++i2)\n+\tstrncpy (sa[i0].a2_3_4[i1][i2], s[i2], n);\n+}\n+\n+\n+/* Verify that a note after the warning points to the accessed object\n+   and mentions the starting offset of the access.  Another alternative\n+   might be for the offset to be the starting offset of the overflow.\n+   As it is, it's not clear to which of the two the offset refers.  */\n+\n+void test_note (const char *s)\n+{\n+  extern void sink (void*);\n+\n+  {\n+    char a[1][1][2];                    // { dg-message \"destination object\" }\n+    strncpy (a[0][0], s, 3);            // { dg-warning \"writing 3 bytes into a region of size 2 \" }\n+    sink (a);\n+  }\n+\n+  {\n+    char a[1][2][2];                    // { dg-message \"at offset 2 into \" }\n+    strncpy (a[0][1], s, 3);            // { dg-warning \"writing 3 bytes into a region of size 2 \" }\n+    sink (a);\n+  }\n+\n+  {\n+    char a[1][2][2];                    // { dg-message \"at offset 4 into \" }\n+    strncpy (a[1][0], s, 3);            // { dg-warning \"writing 3 bytes into a region of size 2 \" }\n+    sink (a);\n+  }\n+\n+  {\n+    char a[2][1][2];                    // { dg-message \"at offset 2 into \" }\n+    strncpy (a[1][0], s, 3);            // { dg-warning \"writing 3 bytes into a region of size 2 \" }\n+    sink (a);\n+  }\n+\n+  {\n+    char a[2][2][3];                    // { dg-message \"at offset 9 into \" }\n+    strncpy (a[1][1], s, 4);            // { dg-warning \"writing 4 bytes into a region of size 3 \" }\n+    sink (a);\n+  }\n+\n+  {\n+    char a[2][3][3];                    // { dg-message \"at offset 12 into \" }\n+    strncpy (a[1][1], s, 5);            // { dg-warning \"writing 5 bytes into a region of size 3 \" }\n+    sink (a);\n+  }\n+\n+  {\n+    char a[2][3][3];                    // { dg-message \"at offset 12 into \" }\n+    strncpy (a[1][1], s, 6);            // { dg-warning \"writing 6 bytes into a region of size 3 \" }\n+    sink (a);\n+  }\n+\n+  {\n+    char a[2][3][3];                    // { dg-message \"at offset 15 into \" }\n+    strncpy (a[1][2], s, 7);            // { dg-warning \"writing 7 bytes into a region of size 3 \" }\n+    sink (a);\n+  }\n+\n+}"}, {"sha": "12bda2b31a73c464f185ade50bda85c9319ce4cf", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-38.c", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-38.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-38.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-38.c?ref=a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "patch": "@@ -0,0 +1,94 @@\n+/* Verify that non-constant offsets don't suppress warnings in cases\n+   when the size of the access alone makes it invalid, regardless of\n+   the offset value.\n+   Also verify that writing into unknown objects through pointers\n+   (or pointer members) doesn't trigger warnings.\n+   { dg-do compile }\n+   { dg-options \"-O1 -Wall -Wno-array-bounds\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void* memcpy (void*, const void*, size_t);\n+extern void* memset (void*, int, size_t);\n+\n+\n+struct Xp { char *p; } xp;\n+struct Xa { char *a[2]; } xa;\n+\n+void nowarn_copy_read_pointed_obj_plus_cst (void *d)\n+{\n+  int i = 0;\n+  memcpy (d, xp.p + i, 9);\n+  memcpy (d, xa.a[i], 9);\n+}\n+\n+void nowarn_copy_read_pointed_obj_plus_var (void *d, int i)\n+{\n+  memcpy (d, xp.p + i, 9);\n+  memcpy (d, xa.a[i], 9);\n+}\n+\n+\n+void warn_copy_read_pointer_plus_cst (void *d)\n+{\n+  int i = 0;\n+  memcpy (d, &xp.p + i, 9);   // { dg-warning \"reading 9 bytes from a region of size . \" }\n+}\n+\n+void warn_copy_read_pointer_plus_var (void *d, int i)\n+{\n+  memcpy (d, &xp.p + i, 9);   // { dg-warning \"reading 9 bytes from a region of size . \" }\n+}\n+\n+\n+void nowarn_copy_write_pointed_obj_plus_cst (const void *s)\n+{\n+  int i = 0;\n+  memcpy (xp.p + i, s, 9);\n+  memcpy (xa.a[i], s, 9);\n+}\n+\n+void nowarn_copy_write_pointed_obj_plus_var (const void *s, int i)\n+{\n+  memcpy (xp.p + i, s, 9);\n+  memcpy (xa.a[i], s, 9);\n+}\n+\n+\n+void warn_copy_write_pointer_plus_cst (const void *s)\n+{\n+  int i = 0;\n+  memcpy (&xp.p + i, s, 9);   // { dg-warning \"writing 9 bytes into a region of size . \" }\n+}\n+\n+void warn_copy_write_pointer_plus_var (const void *s, int i)\n+{\n+  memcpy (&xp.p + i, s, 9);   // { dg-warning \"writing 9 bytes into a region of size . \" }\n+}\n+\n+\n+void nowarn_set_pointed_obj_plus_cst (void)\n+{\n+  int i = 0;\n+  memset (xp.p + i, 0, 9);\n+  memset (xa.a[i], 0, 9);\n+}\n+\n+void nowarn_set_pointed_obj_plus_var (int i)\n+{\n+  memset (xp.p + i, 0, 9);\n+  memset (xa.a[i], 0, 9);\n+}\n+\n+\n+void warn_set_pointer_plus_cst (void)\n+{\n+  int i = 0;\n+  memset (&xp.p + i, 0, 9);   // { dg-warning \"writing 9 bytes into a region of size . \" }\n+}\n+\n+void warn_set_pointer_plus_var (int i)\n+{\n+  memset (&xp.p + i, 0, 9);   // { dg-warning \"writing 9 bytes into a region of size . \" }\n+  memset (&xa.a[i], 0, 17);   // { dg-warning \"writing 17 bytes into a region of size \\[0-9\\]+ \" }\n+}"}, {"sha": "2409e597aacc5e08e70811910b3f636a188092d7", "filename": "gcc/testsuite/gcc.dg/builtin-stringop-chk-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-4.c?ref=a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "patch": "@@ -99,7 +99,7 @@ void test_memcpy_range (void *d, const void *s)\n \n   memcpy (buf + 5, s, UR (1, 2));  /* { dg-warning \"writing between 1 and 2 bytes into a region of size 0 overflows the destination\" } */\n \n-  memcpy (buf + size_max, s, UR (1, 2));  /* { dg-warning \"writing between 1 and 2 bytes into a region of size 0 overflows the destination\" \"excessive pointer offset\" { xfail *-*-* } } */\n+  memcpy (buf + size_max, s, UR (1, 2));  /* { dg-warning \"writing between 1 and 2 bytes into a region of size 0 overflows the destination\" \"excessive pointer offset\" } */\n \n   memcpy (buf, s, UR (ssize_max, size_max));   /* { dg-warning \"writing \\[0-9\\]+ or more bytes into a region of size 5 overflows the destination\" } */\n   memcpy (buf, s, UR (ssize_max + 1, size_max));  /* { dg-warning \"specified \\(bound|size\\) between \\[0-9\\]+ and \\[0-9\\]+ exceeds maximum object size\" } */"}, {"sha": "5398e9f1f9c41975c35f96292ab396b5eef8ce9c", "filename": "gcc/testsuite/gcc.dg/builtin-stringop-chk-5.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-5.c?ref=a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "patch": "@@ -1,6 +1,6 @@\n /* Test exercising -Wstringop-overflow warnings.  */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -Wstringop-overflow=1\" } */\n+/* { dg-options \"-O2 -Wstringop-overflow=1 -Wno-array-bounds\" } */\n \n #define offsetof(type, mem)   __builtin_offsetof (type, mem)\n \n@@ -120,7 +120,7 @@ void test_memop_warn_alloc (const void *src)\n \n   /* Verify the same as above but by writing into the first mmeber\n      of the first element of the array.  */\n-  memcpy (&a[0].a, src, n);   /* { dg-warning \"writing between 8 and 32 bytes into a region of size 4 overflows the destination\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  memcpy (&a[0].a, src, n);   /* { dg-warning \"writing between 8 and 32 bytes into a region of size \" \"memcpy into allocated\" } */\n   escape (a, src);\n \n   n = range (12, 32);\n@@ -133,33 +133,33 @@ void test_memop_warn_alloc (const void *src)\n   /* The following idiom of clearing multiple members of a struct is\n      used in a few places in the Linux kernel.  Verify that a warning\n      is issued for it when it writes past the end of the array object.  */\n-  memset (&b[0].a.b, 0, offsetfrom (struct B, b, a.b) + 1);   /* { dg-warning \"writing 8 bytes into a region of size 7\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  memset (&b[0].a.b, 0, offsetfrom (struct B, b, a.b) + 1);   /* { dg-warning \"writing 8 bytes into a region of size \" \"memcpy into allocated\" } */\n   escape (b);\n \n-  memset (&b->a.b, 0, offsetfrom (struct B, b, a.b) + 1);   /* { dg-warning \"writing 8 bytes into a region of size 7\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  memset (&b->a.b, 0, offsetfrom (struct B, b, a.b) + 1);   /* { dg-warning \"writing 8 bytes into a region of size \" \"memcpy into allocated\" } */\n   escape (b);\n \n-  memset (&b[0].c, 0, offsetfrom (struct B, b, c) + 1);   /* { dg-warning \"writing 7 bytes into a region of size 6\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  memset (&b[0].c, 0, offsetfrom (struct B, b, c) + 1);   /* { dg-warning \"writing 7 bytes into a region of size \" \"memcpy into allocated\" } */\n   escape (b);\n \n-  memset (&b->c, 0, offsetfrom (struct B, b, c) + 1);   /* { dg-warning \"writing 7 bytes into a region of size 6\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  memset (&b->c, 0, offsetfrom (struct B, b, c) + 1);   /* { dg-warning \"writing 7 bytes into a region of size \" \"memcpy into allocated\" } */\n   escape (b);\n \n-  memset (&b[0].d, 0, offsetfrom (struct B, b, d) + 1);   /* { dg-warning \"writing 6 bytes into a region of size 5\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  memset (&b[0].d, 0, offsetfrom (struct B, b, d) + 1);   /* { dg-warning \"writing 6 bytes into a region of size \" \"memcpy into allocated\" } */\n   escape (b);\n \n-  memset (&b->d, 0, offsetfrom (struct B, b, d) + 1);   /* { dg-warning \"writing 6 bytes into a region of size 5\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  memset (&b->d, 0, offsetfrom (struct B, b, d) + 1);   /* { dg-warning \"writing 6 bytes into a region of size \" \"memcpy into allocated\" } */\n   escape (b);\n \n   /* Same as above but clearing just elements of the second element\n      of the array.  */\n-  memset (&b[1].a.b, 0, offsetfrom (struct B, b[1], a.b) + 1);   /* { dg-warning \"writing 4 bytes into a region of size 3\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  memset (&b[1].a.b, 0, offsetfrom (struct B, b[1], a.b) + 1);   /* { dg-warning \"writing 4 bytes into a region of size \" \"memcpy into allocated\" } */\n   escape (b);\n \n-  memset (&b[1].c, 0, offsetfrom (struct B, b[1], c) + 1);   /* { dg-warning \"writing 3 bytes into a region of size 2\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  memset (&b[1].c, 0, offsetfrom (struct B, b[1], c) + 1);   /* { dg-warning \"writing 3 bytes into a region of size \" \"memcpy into allocated\" } */\n   escape (b);\n \n-  memset (&b[1].d, 0, offsetfrom (struct B, b[1], d) + 1);   /* { dg-warning \"writing 2 bytes into a region of size 1\" \"memcpy into allocated\" { xfail *-*-*} } */\n+  memset (&b[1].d, 0, offsetfrom (struct B, b[1], d) + 1);   /* { dg-warning \"writing 2 bytes into a region of size 1\" \"memcpy into allocated\" } */\n   escape (b);\n }\n "}, {"sha": "12d2491b9f5b53e46a34bd5a700d297df7f8d616", "filename": "gcc/testsuite/gcc.dg/builtin-stringop-chk-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltin-stringop-chk-8.c?ref=a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "patch": "@@ -106,7 +106,7 @@ void test_memop_warn_alloc (void *p)\n \n   memcpy (p, &a[0], n);   /* { dg-warning \"reading between 8 and 32 bytes from a region of size 4\" \"memcpy from allocated\" } */\n \n-  memcpy (p, &a[0].a, n);   /* { dg-warning \"reading between 8 and 32 bytes from a region of size 4\" \"memcpy from allocated\" { xfail *-*-*} } */\n+  memcpy (p, &a[0].a, n);   /* { dg-warning \"reading between 8 and 32 bytes from a region of size \" \"memcpy from allocated\" } */\n \n   n = range (12, 32);\n "}, {"sha": "19e9a60858383a15922a57eb46ab6efdb6743884", "filename": "gcc/testsuite/gcc.dg/strlenopt-74.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-74.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-74.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrlenopt-74.c?ref=a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "patch": "@@ -75,7 +75,7 @@ VERIFY (i0 ? (a8 + 2) : (b8 + 2), 7, 6);\n VERIFY (i0 ? (a8 + 0) : (c4 + 0), 9, 4);\n VERIFY (i0 ? (a8 + 0) : (c4 + 1), 9, 3);\n VERIFY (i0 ? (a8 + 0) : (c4 + 3), 9, 1);\n-VERIFY (i0 ? (a8 + 0) : (c4 + 4), 9, 0);\n+VERIFY (i0 ? (a8 + 0) : (c4 + 4), 8, 0);\n VERIFY (i0 ? (a8 + 1) : (c4 + 0), 8, 4);\n VERIFY (i0 ? (a8 + 1) : (c4 + 1), 8, 3);\n VERIFY (i0 ? (a8 + 1) : (c4 + 2), 8, 2);"}, {"sha": "bc55b27cff08ea3b5bccbb5b0e500762e76f2695", "filename": "gcc/tree-object-size.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftree-object-size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftree-object-size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.c?ref=a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "patch": "@@ -172,7 +172,7 @@ compute_object_offset (const_tree expr, const_tree var)\n    is true, else null.  An object's initializer affects the object's\n    size if it's a struct type with a flexible array member.  */\n \n-static tree\n+tree\n decl_init_size (tree decl, bool min)\n {\n   tree size = DECL_SIZE_UNIT (decl);\n@@ -259,6 +259,11 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n \t  offset_int mem_offset;\n \t  if (mem_ref_offset (pt_var).is_constant (&mem_offset))\n \t    {\n+\t      if (*poff)\n+\t\t*poff = wide_int_to_tree (ptrdiff_type_node,\n+\t\t\t\t\t  mem_offset + wi::to_offset (*poff));\n+\t      else\n+\t\t*poff = wide_int_to_tree (ptrdiff_type_node, mem_offset);\n \t      offset_int dsz = wi::sub (sz, mem_offset);\n \t      if (wi::neg_p (dsz))\n \t\tsz = 0;\n@@ -413,12 +418,12 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n       bytes = compute_object_offset (TREE_OPERAND (ptr, 0), var);\n       if (bytes != error_mark_node)\n \t{\n+\t  *poff = bytes;\n \t  if (TREE_CODE (bytes) == INTEGER_CST\n \t      && tree_int_cst_lt (var_size, bytes))\n \t    bytes = size_zero_node;\n \t  else\n \t    bytes = size_binop (MINUS_EXPR, var_size, bytes);\n-\t  *poff = bytes;\n \t}\n       if (var != pt_var\n \t  && pt_var_size\n@@ -441,7 +446,11 @@ addr_object_size (struct object_size_info *osi, const_tree ptr,\n   else if (!pt_var_size)\n     return false;\n   else\n-    bytes = pt_var_size;\n+    {\n+      bytes = pt_var_size;\n+      if (!*poff)\n+\t*poff = size_zero_node;\n+    }\n \n   if (tree_fits_uhwi_p (bytes))\n     {"}, {"sha": "e677c973ab960edd30dcfb3a7ba3dff6237560a8", "filename": "gcc/tree-object-size.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftree-object-size.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftree-object-size.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-object-size.h?ref=a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "patch": "@@ -24,5 +24,6 @@ extern void init_object_sizes (void);\n extern void fini_object_sizes (void);\n extern bool compute_builtin_object_size (tree, int, unsigned HOST_WIDE_INT *,\n \t\t\t\t\t tree * = NULL, tree * = NULL);\n+extern tree decl_init_size (tree, bool);\n \n #endif  // GCC_TREE_OBJECT_SIZE_H"}, {"sha": "fbaee745f7d13a521f00a8dcac7c2628b55658de", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=a2c2cee92e5defff9bf23d3b1184ee96e57e5fdd", "patch": "@@ -5589,7 +5589,6 @@ handle_integral_assign (gimple_stmt_iterator *gsi, bool *cleanup_eh,\n \t      set_strinfo (idx, si);\n \t      si->writable = true;\n \t      si->dont_invalidate = true;\n-\t      maybe_warn_overflow (stmt, lenrange[2], rvals);\n \t    }\n \t}\n     }"}]}