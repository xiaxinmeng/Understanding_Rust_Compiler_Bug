{"sha": "fb7342fd6f834c6786278eeb9d99d704c2f6a0a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI3MzQyZmQ2ZjgzNGM2Nzg2Mjc4ZWViOWQ5OWQ3MDRjMmY2YTBhMQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2010-10-28T16:01:05Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2010-10-28T16:01:05Z"}, "message": "PR libstdc++/44436 (partial)\n\n2010-10-28  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR libstdc++/44436 (partial)\n\t* include/bits/hashtable.h (_Hashtable<>::insert(value_type&&),\n\tinsert(_Pair&&), insert(const_iterator, value_type&&),\n\tinsert(const_iterator, _Pair&&)): Add.\n\t(_M_allocate_node, _M_insert, _M_insert_bucket): Templatize.\n\t* include/bits/hashtable_policy.h (__detail::_Select1st): Add; use\n\tit throughout.\n\t(_Map_base<>::operator[](_Key&&)): Add.\n\t* include/bits/unordered_map.h: Use __detail::_Select1st throughout.\n\t* include/debug/unordered_map: Update.\n\t* include/debug/unordered_set: Likewise.\n\t* include/profile/unordered_map: Likewise.\n\t* include/profile/unordered_set: Likewise.\n\t* testsuite/util/testsuite_rvalref.h (struct hash<rvalstruct>): Add;\n\tminor tweaks throughout, use deleted special members.\n\t* testsuite/23_containers/unordered_map/insert/map_single_move-1.cc:\n\tNew.\n\t* testsuite/23_containers/unordered_map/insert/map_single_move-2.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_map/insert/array_syntax_move.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_multimap/insert/\n\tmultimap_single_move-1.cc: Likewise.\n\t* testsuite/23_containers/unordered_multimap/insert/\n\tmultimap_single_move-2.cc: Likewise.\n\t* testsuite/23_containers/unordered_set/insert/set_single_move.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_multiset/insert/\n\tmultiset_single_move.cc: Likewise.\n\n\t* testsuite/23_containers/unordered_map/insert/array_syntax.cc:\n\tMinor cosmetic changes.\n\nFrom-SVN: r166030", "tree": {"sha": "8c058c4b504e6a5cbf998753e6c41978cf0ba81f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c058c4b504e6a5cbf998753e6c41978cf0ba81f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/comments", "author": null, "committer": null, "parents": [{"sha": "d724c8f0a9ea6bbb8bfd10fc00754902093e40ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d724c8f0a9ea6bbb8bfd10fc00754902093e40ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d724c8f0a9ea6bbb8bfd10fc00754902093e40ce"}], "stats": {"total": 1145, "additions": 959, "deletions": 186}, "files": [{"sha": "8b5b94aaec7f2066dc48dfc56ae4dc6570fb05ea", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=fb7342fd6f834c6786278eeb9d99d704c2f6a0a1", "patch": "@@ -1,3 +1,38 @@\n+2010-10-28  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR libstdc++/44436 (partial)\n+\t* include/bits/hashtable.h (_Hashtable<>::insert(value_type&&),\n+\tinsert(_Pair&&), insert(const_iterator, value_type&&),\n+\tinsert(const_iterator, _Pair&&)): Add.\n+\t(_M_allocate_node, _M_insert, _M_insert_bucket): Templatize.\n+\t* include/bits/hashtable_policy.h (__detail::_Select1st): Add; use\n+\tit throughout.\n+\t(_Map_base<>::operator[](_Key&&)): Add.\n+\t* include/bits/unordered_map.h: Use __detail::_Select1st throughout.\n+\t* include/debug/unordered_map: Update.\n+\t* include/debug/unordered_set: Likewise.\n+\t* include/profile/unordered_map: Likewise.\n+\t* include/profile/unordered_set: Likewise.\n+\t* testsuite/util/testsuite_rvalref.h (struct hash<rvalstruct>): Add;\n+\tminor tweaks throughout, use deleted special members.\n+\t* testsuite/23_containers/unordered_map/insert/map_single_move-1.cc:\n+\tNew.\n+\t* testsuite/23_containers/unordered_map/insert/map_single_move-2.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/unordered_map/insert/array_syntax_move.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/unordered_multimap/insert/\n+\tmultimap_single_move-1.cc: Likewise.\n+\t* testsuite/23_containers/unordered_multimap/insert/\n+\tmultimap_single_move-2.cc: Likewise.\n+\t* testsuite/23_containers/unordered_set/insert/set_single_move.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/unordered_multiset/insert/\n+\tmultiset_single_move.cc: Likewise.\n+\n+\t* testsuite/23_containers/unordered_map/insert/array_syntax.cc:\n+\tMinor cosmetic changes.\n+\n 2010-10-27  Jason Merrill  <jason@redhat.com>\n \n \t* include/std/type_traits (is_literal_type): New."}, {"sha": "343a12267fdf918f69da09a903f8ec9ddb4abb7b", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 164, "deletions": 131, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=fb7342fd6f834c6786278eeb9d99d704c2f6a0a1", "patch": "@@ -178,9 +178,10 @@ namespace std\n       size_type              _M_begin_bucket_index; // First non-empty bucket.\n       size_type              _M_element_count;\n       _RehashPolicy          _M_rehash_policy;\n-      \n-      _Node*\n-      _M_allocate_node(const value_type& __v);\n+\n+      template<typename... _Args>\n+        _Node*\n+        _M_allocate_node(_Args&&... __args);\n   \n       void\n       _M_deallocate_node(_Node* __n);\n@@ -360,11 +361,27 @@ namespace std\n       std::pair<const_iterator, const_iterator>\n       equal_range(const key_type& __k) const;\n \n-    private:\t\t\t// Find, insert and erase helper functions\n-      // ??? This dispatching is a workaround for the fact that we don't\n-      // have partial specialization of member templates; it would be\n-      // better to just specialize insert on __unique_keys.  There may be a\n-      // cleaner workaround.\n+    private:\n+      // Find, insert and erase helper functions\n+      _Node*\n+      _M_find_node(_Node*, const key_type&,\n+\t\t   typename _Hashtable::_Hash_code_type) const;\n+\n+      template<typename _Pair>\n+        iterator\n+        _M_insert_bucket(_Pair&&, size_type,\n+\t\t\t typename _Hashtable::_Hash_code_type);\n+\n+      template<typename _Pair>\n+        std::pair<iterator, bool>\n+        _M_insert(_Pair&&, std::true_type);\n+\n+      template<typename _Pair>\n+        iterator\n+        _M_insert(_Pair&&, std::false_type);\n+\n+    public:\n+      // Insert and erase\n       typedef typename std::conditional<__unique_keys,\n \t\t\t\t\tstd::pair<iterator, bool>,\n \t\t\t\t\titerator>::type\n@@ -376,30 +393,39 @@ namespace std\n                                    >::type\n         _Insert_Conv_Type;\n \n-      _Node*\n-      _M_find_node(_Node*, const key_type&,\n-\t\t   typename _Hashtable::_Hash_code_type) const;\n-\n-      iterator\n-      _M_insert_bucket(const value_type&, size_type,\n-\t\t       typename _Hashtable::_Hash_code_type);\n-\n-      std::pair<iterator, bool>\n-      _M_insert(const value_type&, std::true_type);\n+      _Insert_Return_Type\n+      insert(const value_type& __v)\n+      { return _M_insert(__v, std::integral_constant<bool, __unique_keys>()); }\n \n       iterator\n-      _M_insert(const value_type&, std::false_type);\n+      insert(const_iterator, const value_type& __v)\n+      { return _Insert_Conv_Type()(insert(__v)); }\n \n-    public:\n-      // Insert and erase\n       _Insert_Return_Type\n-      insert(const value_type& __v) \n-      { return _M_insert(__v, std::integral_constant<bool,\n-\t\t\t __unique_keys>()); }\n+      insert(value_type&& __v)\n+      { return _M_insert(std::move(__v),\n+\t\t\t std::integral_constant<bool, __unique_keys>()); }\n \n       iterator\n-      insert(const_iterator, const value_type& __v)\n-      { return iterator(_Insert_Conv_Type()(this->insert(__v))); }\n+      insert(const_iterator, value_type&& __v)\n+      { return _Insert_Conv_Type()(insert(std::move(__v))); }\n+\n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<!__constant_iterators\n+\t\t\t      && std::is_convertible<_Pair,\n+\t\t\t\t\t\t     value_type>::value>::type>\n+        _Insert_Return_Type\n+        insert(_Pair&& __v)\n+        { return _M_insert(std::forward<_Pair>(__v),\n+\t\t\t   std::integral_constant<bool, __unique_keys>()); }\n+\n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<!__constant_iterators\n+\t\t\t      && std::is_convertible<_Pair,\n+\t\t\t\t\t\t     value_type>::value>::type>\n+        iterator\n+        insert(const_iterator, _Pair&& __v)\n+        { return _Insert_Conv_Type()(insert(std::forward<_Pair>(__v))); }\n \n       template<typename _InputIterator>\n         void\n@@ -438,26 +464,27 @@ namespace std\n \t   typename _Allocator, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::_Node*\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_allocate_node(const value_type& __v)\n-    {\n-      _Node* __n = _M_node_allocator.allocate(1);\n-      __try\n-\t{\n-\t  _M_node_allocator.construct(__n, __v);\n-\t  __n->_M_next = 0;\n-\t  return __n;\n-\t}\n-      __catch(...)\n-\t{\n-\t  _M_node_allocator.deallocate(__n, 1);\n-\t  __throw_exception_again;\n-\t}\n-    }\n+    template<typename... _Args>\n+      typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t  _H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t  __chc, __cit, __uk>::_Node*\n+      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+      _M_allocate_node(_Args&&... __args)\n+      {\n+\t_Node* __n = _M_node_allocator.allocate(1);\n+\t__try\n+\t  {\n+\t    _M_node_allocator.construct(__n, std::forward<_Args>(__args)...);\n+\t    __n->_M_next = 0;\n+\t    return __n;\n+\t  }\n+\t__catch(...)\n+\t  {\n+\t    _M_node_allocator.deallocate(__n, 1);\n+\t    __throw_exception_again;\n+\t  }\n+      }\n \n   template<typename _Key, typename _Value, \n \t   typename _Allocator, typename _ExtractKey, typename _Equal,\n@@ -871,111 +898,117 @@ namespace std\n \t   typename _Allocator, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::iterator\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_insert_bucket(const value_type& __v, size_type __n,\n-\t\t     typename _Hashtable::_Hash_code_type __code)\n-    {\n-      std::pair<bool, std::size_t> __do_rehash\n-\t= _M_rehash_policy._M_need_rehash(_M_bucket_count,\n-\t\t\t\t\t  _M_element_count, 1);\n+    template<typename _Pair>\n+      typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t  _H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t  __chc, __cit, __uk>::iterator\n+      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+      _M_insert_bucket(_Pair&& __v, size_type __n,\n+\t\t       typename _Hashtable::_Hash_code_type __code)\n+      {\n+\tstd::pair<bool, std::size_t> __do_rehash\n+\t  = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n+\t\t\t\t\t    _M_element_count, 1);\n \n-      // Allocate the new node before doing the rehash so that we don't\n-      // do a rehash if the allocation throws.\n-      _Node* __new_node = _M_allocate_node(__v);\n+\tif (__do_rehash.first)\n+\t  {\n+\t    const key_type& __k = this->_M_extract(__v);\n+\t    __n = this->_M_bucket_index(__k, __code, __do_rehash.second);\n+\t  }\n \n-      __try\n-\t{\n-\t  if (__do_rehash.first)\n-\t    {\n-\t      const key_type& __k = this->_M_extract(__v);\n-\t      __n = this->_M_bucket_index(__k, __code, __do_rehash.second);\n+\t// Allocate the new node before doing the rehash so that we don't\n+\t// do a rehash if the allocation throws.\n+\t_Node* __new_node = _M_allocate_node(std::forward<_Pair>(__v));\n+\n+\t__try\n+\t  {\n+\t    if (__do_rehash.first)\n \t      _M_rehash(__do_rehash.second);\n-\t    }\n \n-\t  __new_node->_M_next = _M_buckets[__n];\n-\t  this->_M_store_code(__new_node, __code);\n-\t  _M_buckets[__n] = __new_node;\n-\t  ++_M_element_count;\n-\t  if (__n < _M_begin_bucket_index)\n-\t    _M_begin_bucket_index = __n;\n-\t  return iterator(__new_node, _M_buckets + __n);\n-\t}\n-      __catch(...)\n-\t{\n-\t  _M_deallocate_node(__new_node);\n-\t  __throw_exception_again;\n-\t}\n-    }\n+\t    __new_node->_M_next = _M_buckets[__n];\n+\t    this->_M_store_code(__new_node, __code);\n+\t    _M_buckets[__n] = __new_node;\n+\t    ++_M_element_count;\n+\t    if (__n < _M_begin_bucket_index)\n+\t      _M_begin_bucket_index = __n;\n+\t    return iterator(__new_node, _M_buckets + __n);\n+\t  }\n+\t__catch(...)\n+\t  {\n+\t    _M_deallocate_node(__new_node);\n+\t    __throw_exception_again;\n+\t  }\n+      }\n \n   // Insert v if no element with its key is already present.\n   template<typename _Key, typename _Value, \n \t   typename _Allocator, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   bool __chc, bool __cit, bool __uk>\n-    std::pair<typename _Hashtable<_Key, _Value, _Allocator,\n-\t\t\t\t  _ExtractKey, _Equal, _H1,\n-\t\t\t\t  _H2, _Hash, _RehashPolicy,\n-\t\t\t\t  __chc, __cit, __uk>::iterator, bool>\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_insert(const value_type& __v, std::true_type)\n-    {\n-      const key_type& __k = this->_M_extract(__v);\n-      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n-      size_type __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n-\n-      if (_Node* __p = _M_find_node(_M_buckets[__n], __k, __code))\n-\treturn std::make_pair(iterator(__p, _M_buckets + __n), false);\n-      return std::make_pair(_M_insert_bucket(__v, __n, __code), true);\n-    }\n+    template<typename _Pair>\n+      std::pair<typename _Hashtable<_Key, _Value, _Allocator,\n+\t\t\t\t    _ExtractKey, _Equal, _H1,\n+\t\t\t\t    _H2, _Hash, _RehashPolicy,\n+\t\t\t\t    __chc, __cit, __uk>::iterator, bool>\n+      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+      _M_insert(_Pair&& __v, std::true_type)\n+      {\n+\tconst key_type& __k = this->_M_extract(__v);\n+\ttypename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+\tsize_type __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+\n+\tif (_Node* __p = _M_find_node(_M_buckets[__n], __k, __code))\n+\t  return std::make_pair(iterator(__p, _M_buckets + __n), false);\n+\treturn std::make_pair(_M_insert_bucket(std::forward<_Pair>(__v),\n+\t\t\t      __n, __code), true);\n+      }\n \n   // Insert v unconditionally.\n   template<typename _Key, typename _Value, \n \t   typename _Allocator, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   bool __chc, bool __cit, bool __uk>\n-    typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy,\n-\t\t\t__chc, __cit, __uk>::iterator\n-    _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n-    _M_insert(const value_type& __v, std::false_type)\n-    {\n-      std::pair<bool, std::size_t> __do_rehash\n-\t= _M_rehash_policy._M_need_rehash(_M_bucket_count,\n-\t\t\t\t\t  _M_element_count, 1);\n-      if (__do_rehash.first)\n-\t_M_rehash(__do_rehash.second);\n+    template<typename _Pair>\n+      typename _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t\t  _H1, _H2, _Hash, _RehashPolicy,\n+\t\t\t  __chc, __cit, __uk>::iterator\n+      _Hashtable<_Key, _Value, _Allocator, _ExtractKey, _Equal,\n+\t\t _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk>::\n+      _M_insert(_Pair&& __v, std::false_type)\n+      {\n+\tstd::pair<bool, std::size_t> __do_rehash\n+\t  = _M_rehash_policy._M_need_rehash(_M_bucket_count,\n+\t\t\t\t\t    _M_element_count, 1);\n+\tif (__do_rehash.first)\n+\t  _M_rehash(__do_rehash.second);\n  \n-      const key_type& __k = this->_M_extract(__v);\n-      typename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n-      size_type __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n+\tconst key_type& __k = this->_M_extract(__v);\n+\ttypename _Hashtable::_Hash_code_type __code = this->_M_hash_code(__k);\n+\tsize_type __n = this->_M_bucket_index(__k, __code, _M_bucket_count);\n \n-      // First find the node, avoid leaking new_node if compare throws.\n-      _Node* __prev = _M_find_node(_M_buckets[__n], __k, __code);\n-      _Node* __new_node = _M_allocate_node(__v);\n+\t// First find the node, avoid leaking new_node if compare throws.\n+\t_Node* __prev = _M_find_node(_M_buckets[__n], __k, __code);\n+\t_Node* __new_node = _M_allocate_node(std::forward<_Pair>(__v));\n \n-      if (__prev)\n-\t{\n-\t  __new_node->_M_next = __prev->_M_next;\n-\t  __prev->_M_next = __new_node;\n-\t}\n-      else\n-\t{\n-\t  __new_node->_M_next = _M_buckets[__n];\n-\t  _M_buckets[__n] = __new_node;\n-\t  if (__n < _M_begin_bucket_index)\n-\t    _M_begin_bucket_index = __n;\n-\t}\n-      this->_M_store_code(__new_node, __code);\n+        if (__prev)\n+\t  {\n+\t    __new_node->_M_next = __prev->_M_next;\n+\t    __prev->_M_next = __new_node;\n+\t  }\n+\telse\n+\t  {\n+\t    __new_node->_M_next = _M_buckets[__n];\n+\t    _M_buckets[__n] = __new_node;\n+\t    if (__n < _M_begin_bucket_index)\n+\t      _M_begin_bucket_index = __n;\n+\t  }\n+        this->_M_store_code(__new_node, __code);\n \n-      ++_M_element_count;\n-      return iterator(__new_node, _M_buckets + __n);\n-    }\n+        ++_M_element_count;\n+        return iterator(__new_node, _M_buckets + __n);\n+      }\n \n   template<typename _Key, typename _Value, \n \t   typename _Allocator, typename _ExtractKey, typename _Equal,"}, {"sha": "3d76839f7f0043b9decf56991c75f2f848bfaefb", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=fb7342fd6f834c6786278eeb9d99d704c2f6a0a1", "patch": "@@ -56,6 +56,14 @@ namespace __detail\n       return __distance_fw(__first, __last, _Tag());\n     }\n \n+  struct _Select1st\n+  {\n+    template<typename _Pair>\n+      const typename _Pair::first_type&\n+      operator()(const _Pair& __pair) const\n+      { return __pair.first; }\n+  };\n+\n   // Auxiliary types used for all instantiations of _Hashtable: nodes\n   // and iterators.\n   \n@@ -497,25 +505,28 @@ namespace __detail\n   // the form pair<T1, T2> and a key extraction policy that returns the\n   // first part of the pair, the hashtable gets a mapped_type typedef.\n   // If it satisfies those criteria and also has unique keys, then it\n-  // also gets an operator[].  \n+  // also gets an operator[].\n   template<typename _Key, typename _Value, typename _Ex, bool __unique,\n \t   typename _Hashtable>\n     struct _Map_base { };\n \n   template<typename _Key, typename _Pair, typename _Hashtable>\n-    struct _Map_base<_Key, _Pair, std::_Select1st<_Pair>, false, _Hashtable>\n+    struct _Map_base<_Key, _Pair, _Select1st, false, _Hashtable>\n     {\n       typedef typename _Pair::second_type mapped_type;\n     };\n \n   template<typename _Key, typename _Pair, typename _Hashtable>\n-    struct _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>\n+    struct _Map_base<_Key, _Pair, _Select1st, true, _Hashtable>\n     {\n       typedef typename _Pair::second_type mapped_type;\n \n       mapped_type&\n       operator[](const _Key& __k);\n \n+      mapped_type&\n+      operator[](_Key&& __k);\n+\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // DR 761. unordered_map needs an at() member function.\n       mapped_type&\n@@ -526,9 +537,9 @@ namespace __detail\n     };\n \n   template<typename _Key, typename _Pair, typename _Hashtable>\n-    typename _Map_base<_Key, _Pair, std::_Select1st<_Pair>,\n+    typename _Map_base<_Key, _Pair, _Select1st,\n \t\t       true, _Hashtable>::mapped_type&\n-    _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>::\n+    _Map_base<_Key, _Pair, _Select1st, true, _Hashtable>::\n     operator[](const _Key& __k)\n     {\n       _Hashtable* __h = static_cast<_Hashtable*>(this);\n@@ -545,10 +556,30 @@ namespace __detail\n     }\n \n   template<typename _Key, typename _Pair, typename _Hashtable>\n-    typename _Map_base<_Key, _Pair, std::_Select1st<_Pair>,\n+    typename _Map_base<_Key, _Pair, _Select1st,\n+\t\t       true, _Hashtable>::mapped_type&\n+    _Map_base<_Key, _Pair, _Select1st, true, _Hashtable>::\n+    operator[](_Key&& __k)\n+    {\n+      _Hashtable* __h = static_cast<_Hashtable*>(this);\n+      typename _Hashtable::_Hash_code_type __code = __h->_M_hash_code(__k);\n+      std::size_t __n = __h->_M_bucket_index(__k, __code,\n+\t\t\t\t\t     __h->_M_bucket_count);\n+\n+      typename _Hashtable::_Node* __p =\n+\t__h->_M_find_node(__h->_M_buckets[__n], __k, __code);\n+      if (!__p)\n+\treturn __h->_M_insert_bucket(std::make_pair(std::move(__k),\n+\t\t\t\t\t\t    mapped_type()),\n+\t\t\t\t     __n, __code)->second;\n+      return (__p->_M_v).second;\n+    }\n+\n+  template<typename _Key, typename _Pair, typename _Hashtable>\n+    typename _Map_base<_Key, _Pair, _Select1st,\n \t\t       true, _Hashtable>::mapped_type&\n-    _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>::\n-    at(const _Key& __k)\n+    _Map_base<_Key, _Pair, _Select1st, true, _Hashtable>::\n+     at(const _Key& __k)\n     {\n       _Hashtable* __h = static_cast<_Hashtable*>(this);\n       typename _Hashtable::_Hash_code_type __code = __h->_M_hash_code(__k);\n@@ -563,10 +594,10 @@ namespace __detail\n     }\n \n   template<typename _Key, typename _Pair, typename _Hashtable>\n-    const typename _Map_base<_Key, _Pair, std::_Select1st<_Pair>,\n+    const typename _Map_base<_Key, _Pair, _Select1st,\n \t\t\t     true, _Hashtable>::mapped_type&\n-    _Map_base<_Key, _Pair, std::_Select1st<_Pair>, true, _Hashtable>::\n-    at(const _Key& __k) const\n+    _Map_base<_Key, _Pair, _Select1st, true, _Hashtable>::\n+     at(const _Key& __k) const\n     {\n       const _Hashtable* __h = static_cast<const _Hashtable*>(this);\n       typename _Hashtable::_Hash_code_type __code = __h->_M_hash_code(__k);"}, {"sha": "efd613191527e028deaca6cd24d01f86ad5619cd", "filename": "libstdc++-v3/include/bits/unordered_map.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funordered_map.h?ref=fb7342fd6f834c6786278eeb9d99d704c2f6a0a1", "patch": "@@ -41,14 +41,14 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \t   bool __cache_hash_code = false>\n     class __unordered_map\n     : public _Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc,\n-\t\t\tstd::_Select1st<std::pair<const _Key, _Tp> >, _Pred, \n+\t\t\t__detail::_Select1st, _Pred, \n \t\t\t_Hash, __detail::_Mod_range_hashing,\n \t\t\t__detail::_Default_ranged_hash,\n \t\t\t__detail::_Prime_rehash_policy,\n \t\t\t__cache_hash_code, false, true>\n     {\n       typedef _Hashtable<_Key, std::pair<const _Key, _Tp>, _Alloc,\n-\t\t\t std::_Select1st<std::pair<const _Key, _Tp> >, _Pred,\n+\t\t\t __detail::_Select1st, _Pred,\n \t\t\t _Hash, __detail::_Mod_range_hashing,\n \t\t\t __detail::_Default_ranged_hash,\n \t\t\t __detail::_Prime_rehash_policy,\n@@ -69,7 +69,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \t\t      const allocator_type& __a = allocator_type())\n       : _Base(__n, __hf, __detail::_Mod_range_hashing(),\n \t      __detail::_Default_ranged_hash(),\n-\t      __eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n+\t      __eql, __detail::_Select1st(), __a)\n       { }\n \n       template<typename _InputIterator>\n@@ -80,7 +80,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \t\t\tconst allocator_type& __a = allocator_type())\n \t: _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),\n \t\t__detail::_Default_ranged_hash(),\n-\t\t__eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n+\t\t__eql, __detail::_Select1st(), __a)\n \t{ }\n \n       __unordered_map(initializer_list<value_type> __l,\n@@ -91,7 +91,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       : _Base(__l.begin(), __l.end(), __n, __hf,\n \t      __detail::_Mod_range_hashing(),\n \t      __detail::_Default_ranged_hash(),\n-\t      __eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n+\t      __eql, __detail::_Select1st(), __a)\n       { }\n \n       __unordered_map&\n@@ -111,15 +111,15 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n     class __unordered_multimap\n     : public _Hashtable<_Key, std::pair<const _Key, _Tp>,\n \t\t\t_Alloc,\n-\t\t\tstd::_Select1st<std::pair<const _Key, _Tp> >, _Pred,\n+\t\t\t__detail::_Select1st, _Pred,\n \t\t\t_Hash, __detail::_Mod_range_hashing,\n \t\t\t__detail::_Default_ranged_hash,\n \t\t\t__detail::_Prime_rehash_policy,\n \t\t\t__cache_hash_code, false, false>\n     {\n       typedef _Hashtable<_Key, std::pair<const _Key, _Tp>,\n \t\t\t _Alloc,\n-\t\t\t std::_Select1st<std::pair<const _Key, _Tp> >, _Pred,\n+\t\t\t __detail::_Select1st, _Pred,\n \t\t\t _Hash, __detail::_Mod_range_hashing,\n \t\t\t __detail::_Default_ranged_hash,\n \t\t\t __detail::_Prime_rehash_policy,\n@@ -140,7 +140,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \t\t\t   const allocator_type& __a = allocator_type())\n       : _Base(__n, __hf, __detail::_Mod_range_hashing(),\n \t      __detail::_Default_ranged_hash(),\n-\t      __eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n+\t      __eql, __detail::_Select1st(), __a)\n       { }\n \n \n@@ -152,7 +152,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n \t\t\t     const allocator_type& __a = allocator_type())\n \t: _Base(__f, __l, __n, __hf, __detail::_Mod_range_hashing(),\n \t\t__detail::_Default_ranged_hash(),\n-\t\t__eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n+\t\t__eql, __detail::_Select1st(), __a)\n         { }\n \n       __unordered_multimap(initializer_list<value_type> __l,\n@@ -163,7 +163,7 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD_D)\n       : _Base(__l.begin(), __l.end(), __n, __hf,\n \t      __detail::_Mod_range_hashing(),\n \t      __detail::_Default_ranged_hash(),\n-\t      __eql, std::_Select1st<std::pair<const _Key, _Tp> >(), __a)\n+\t      __eql, __detail::_Select1st(), __a)\n       { }\n \n       __unordered_multimap&"}, {"sha": "6f37e040a26debf6d4ccfb1b2516797a8859c4dd", "filename": "libstdc++-v3/include/debug/unordered_map", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_map?ref=fb7342fd6f834c6786278eeb9d99d704c2f6a0a1", "patch": "@@ -190,6 +190,28 @@ namespace __debug\n \treturn iterator(__res.first, this);\n       }\n \n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<std::is_convertible<_Pair,\n+\t\t\t\t\t\t  value_type>::value>::type>\n+        std::pair<iterator, bool>\n+        insert(_Pair&& __obj)\n+        {\n+\t  typedef std::pair<typename _Base::iterator, bool> __pair_type;\n+\t  __pair_type __res = _Base::insert(std::forward<_Pair>(__obj));\n+\t  return std::make_pair(iterator(__res.first, this), __res.second);\n+\t}\n+\n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<std::is_convertible<_Pair,\n+\t\t\t\t\t\t  value_type>::value>::type>\n+        iterator\n+        insert(const_iterator, _Pair&& __obj)\n+        {\n+\t  typedef std::pair<typename _Base::iterator, bool> __pair_type;\n+\t  __pair_type __res = _Base::insert(std::forward<_Pair>(__obj));\n+\t  return iterator(__res.first, this);\n+\t}\n+\n       void\n       insert(std::initializer_list<value_type> __l)\n       { _Base::insert(__l); }\n@@ -444,6 +466,20 @@ namespace __debug\n       insert(const_iterator, const value_type& __obj)\n       { return iterator(_Base::insert(__obj), this); }\n \n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<std::is_convertible<_Pair,\n+\t\t\t\t\t\t  value_type>::value>::type>\n+        iterator\n+        insert(_Pair&& __obj)\n+        { return iterator(_Base::insert(std::forward<_Pair>(__obj)), this); }\n+\n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<std::is_convertible<_Pair,\n+\t\t\t\t\t\t  value_type>::value>::type>\n+        iterator\n+        insert(const_iterator, _Pair&& __obj)\n+        { return iterator(_Base::insert(std::forward<_Pair>(__obj)), this); }\n+\n       void\n       insert(std::initializer_list<value_type> __l)\n       { _Base::insert(__l); }"}, {"sha": "1d42905e2363913f914693df80c47eeca0b4939f", "filename": "libstdc++-v3/include/debug/unordered_set", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Funordered_set?ref=fb7342fd6f834c6786278eeb9d99d704c2f6a0a1", "patch": "@@ -190,6 +190,22 @@ namespace __debug\n \treturn iterator(__res.first, this);\n       }\n \n+      std::pair<iterator, bool>\n+      insert(value_type&& __obj)\n+      {\n+\ttypedef std::pair<typename _Base::iterator, bool> __pair_type;\n+\t__pair_type __res = _Base::insert(std::move(__obj));\n+\treturn std::make_pair(iterator(__res.first, this), __res.second);\n+      }\n+\n+      iterator\n+      insert(const_iterator, value_type&& __obj)\n+      {\n+\ttypedef std::pair<typename _Base::iterator, bool> __pair_type;\n+\t__pair_type __res = _Base::insert(std::move(__obj));\n+\treturn iterator(__res.first, this);\n+      }\n+\n       void\n       insert(std::initializer_list<value_type> __l)\n       { _Base::insert(__l); }\n@@ -440,6 +456,14 @@ namespace __debug\n       insert(const_iterator, const value_type& __obj)\n       { return iterator(_Base::insert(__obj), this); }\n \n+      iterator\n+      insert(value_type&& __obj)\n+      { return iterator(_Base::insert(std::move(__obj)), this); }\n+\n+      iterator\n+      insert(const_iterator, value_type&& __obj)\n+      { return iterator(_Base::insert(std::move(__obj)), this); }\n+\n       void\n       insert(std::initializer_list<value_type> __l)\n       { _Base::insert(__l); }"}, {"sha": "18563d8750822651d8b1964e118080451327387b", "filename": "libstdc++-v3/include/profile/unordered_map", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_map?ref=fb7342fd6f834c6786278eeb9d99d704c2f6a0a1", "patch": "@@ -191,6 +191,31 @@ namespace __profile\n         return __res;\n       }\n \n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<std::is_convertible<_Pair,\n+\t\t\t\t\t\t  value_type>::value>::type>\n+        std::pair<iterator, bool>\n+        insert(_Pair&& __obj)\n+        {\n+\t  size_type __old_size =  _Base::bucket_count();\n+\t  std::pair<iterator, bool> __res\n+\t    = _Base::insert(std::forward<_Pair>(__obj));\n+\t  _M_profile_resize(__old_size, _Base::bucket_count()); \n+\t  return __res;\n+\t}\n+\n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<std::is_convertible<_Pair,\n+\t\t\t\t\t\t  value_type>::value>::type>\n+        iterator\n+        insert(const_iterator __iter, _Pair&& __v)\n+        { \n+\t  size_type __old_size = _Base::bucket_count(); \n+\t  iterator __res = _Base::insert(__iter, std::forward<_Pair>(__v));\n+\t  _M_profile_resize(__old_size, _Base::bucket_count()); \n+\t  return __res;\n+\t}\n+\n       template<typename _InputIter>\n         void\n         insert(_InputIter __first, _InputIter __last)\n@@ -420,11 +445,35 @@ namespace __profile\n       insert(const_iterator __iter, const value_type& __v)\n       { \n         size_type __old_size = _Base::bucket_count(); \n-        iterator __res =_Base::insert(__iter, __v);\n+        iterator __res = _Base::insert(__iter, __v);\n         _M_profile_resize(__old_size, _Base::bucket_count()); \n         return __res;\n       }\n \n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<std::is_convertible<_Pair,\n+\t\t\t\t\t\t  value_type>::value>::type>\n+        iterator\n+        insert(_Pair&& __obj)\n+        {\n+\t  size_type __old_size =  _Base::bucket_count();\n+\t  iterator __res = _Base::insert(std::forward<_Pair>(__obj));\n+\t  _M_profile_resize(__old_size, _Base::bucket_count()); \n+\t  return __res;\n+\t}\n+\n+      template<typename _Pair, typename = typename\n+\t       std::enable_if<std::is_convertible<_Pair,\n+\t\t\t\t\t\t  value_type>::value>::type>\n+        iterator\n+        insert(const_iterator __iter, _Pair&& __v)\n+        {\n+\t  size_type __old_size = _Base::bucket_count(); \n+\t  iterator __res = _Base::insert(__iter, std::forward<_Pair>(__v));\n+\t  _M_profile_resize(__old_size, _Base::bucket_count()); \n+\t  return __res;\n+\t}\n+\n       template<typename _InputIter>\n         void\n         insert(_InputIter __first, _InputIter __last)"}, {"sha": "f46cf5c8bdd0068ceeca6e03bd8a8e8e6e0a61b9", "filename": "libstdc++-v3/include/profile/unordered_set", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Funordered_set?ref=fb7342fd6f834c6786278eeb9d99d704c2f6a0a1", "patch": "@@ -174,7 +174,7 @@ namespace __profile\n       std::pair<iterator, bool>\n       insert(const value_type& __obj)\n       {\n-        size_type __old_size =  _Base::bucket_count();\n+        size_type __old_size = _Base::bucket_count();\n         std::pair<iterator, bool> __res = _Base::insert(__obj);\n         _M_profile_resize(__old_size,  _Base::bucket_count()); \n         return __res;\n@@ -189,6 +189,24 @@ namespace __profile\n         return __res;\n       }\n \n+      std::pair<iterator, bool>\n+      insert(value_type&& __obj)\n+      {\n+        size_type __old_size = _Base::bucket_count();\n+        std::pair<iterator, bool> __res = _Base::insert(std::move(__obj));\n+        _M_profile_resize(__old_size,  _Base::bucket_count()); \n+        return __res;\n+      }\n+\n+      iterator\n+      insert(const_iterator __iter, value_type&& __v)\n+      { \n+        size_type __old_size = _Base::bucket_count();\n+        iterator __res = _Base::insert(__iter, std::move(__v));\n+        _M_profile_resize(__old_size, _Base::bucket_count()); \n+        return __res;\n+      }\n+\n       template<typename _InputIter>\n         void\n         insert(_InputIter __first, _InputIter __last)\n@@ -406,13 +424,31 @@ namespace __profile\n \n       iterator\n       insert(const_iterator __iter, const value_type& __v)\n-      { \n+      {\n         size_type __old_size = _Base::bucket_count(); \n         iterator __res = _Base::insert(__iter, __v);\n         _M_profile_resize(__old_size, _Base::bucket_count()); \n         return __res;\n       }\n \n+      iterator\n+      insert(value_type&& __obj)\n+      {\n+\tsize_type __old_size =  _Base::bucket_count();\n+        iterator __res = _Base::insert(std::move(__obj));\n+        _M_profile_resize(__old_size,  _Base::bucket_count()); \n+        return __res;\n+      }\n+\n+      iterator\n+      insert(const_iterator __iter, value_type&& __v)\n+      {\n+        size_type __old_size = _Base::bucket_count(); \n+        iterator __res = _Base::insert(__iter, std::move(__v));\n+        _M_profile_resize(__old_size, _Base::bucket_count()); \n+        return __res;\n+      }\n+\n       template<typename _InputIter>\n         void\n         insert(_InputIter __first, _InputIter __last)"}, {"sha": "91f58799a58ecaf6af9d88f66fa4808fe64f887e", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/insert/array_syntax.cc", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2Farray_syntax.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2Farray_syntax.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2Farray_syntax.cc?ref=fb7342fd6f834c6786278eeb9d99d704c2f6a0a1", "patch": "@@ -29,25 +29,24 @@ void test01()\n   bool test __attribute__((unused)) = true;\n \n   typedef std::unordered_map<std::string, int> Map;\n-  typedef std::pair<const std::string, int> Pair;\n \n   Map m;\n-  VERIFY(m.empty());\n+  VERIFY( m.empty() );\n \n   m[\"red\"] = 17;\n-  VERIFY(m.size() == 1);\n-  VERIFY(m.begin()->first == \"red\");\n-  VERIFY(m.begin()->second == 17);\n-  VERIFY(m[\"red\"] == 17);\n+  VERIFY( m.size() == 1 );\n+  VERIFY( m.begin()->first == \"red\" );\n+  VERIFY( m.begin()->second == 17 );\n+  VERIFY( m[\"red\"] == 17 );\n \n   m[\"blue\"] = 9;\n-  VERIFY(m.size() == 2);\n-  VERIFY(m[\"blue\"] == 9);\n+  VERIFY( m.size() == 2 );\n+  VERIFY( m[\"blue\"] == 9 );\n \n   m[\"red\"] = 5;\n-  VERIFY(m.size() == 2);\n-  VERIFY(m[\"red\"] == 5);\n-  VERIFY(m[\"blue\"] == 9);\n+  VERIFY( m.size() == 2 );\n+  VERIFY( m[\"red\"] == 5 );\n+  VERIFY( m[\"blue\"] == 9 );\n }\n \n int main()"}, {"sha": "b0729e3271293047973b14f370a974728c1e63d5", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/insert/array_syntax_move.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2Farray_syntax_move.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2Farray_syntax_move.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2Farray_syntax_move.cc?ref=fb7342fd6f834c6786278eeb9d99d704c2f6a0a1", "patch": "@@ -0,0 +1,59 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-10-27  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Array version of insert\n+\n+#include <iterator>\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::unordered_map<rvalstruct, rvalstruct> Map;\n+\n+  Map m;\n+  VERIFY( m.empty() );\n+\n+  m[rvalstruct(1)] = rvalstruct(17);\n+  VERIFY( m.size() == 1 );\n+  VERIFY( (m.begin()->first).val == 1 );\n+  VERIFY( (m.begin()->second).val == 17 );\n+  VERIFY( m[rvalstruct(1)].val == 17 );\n+\n+  m[rvalstruct(2)] = rvalstruct(9);\n+  VERIFY( m.size() == 2 );\n+  VERIFY( m[rvalstruct(2)].val == 9 );\n+\n+  m[rvalstruct(1)] = rvalstruct(5);\n+  VERIFY( m.size() == 2 );\n+  VERIFY( m[rvalstruct(1)].val == 5 );\n+  VERIFY( m[rvalstruct(2)].val == 9 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "45186ce459b64df3363eb82317a4f1cdbd322750", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/insert/map_single_move-1.cc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2Fmap_single_move-1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2Fmap_single_move-1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2Fmap_single_move-1.cc?ref=fb7342fd6f834c6786278eeb9d99d704c2f6a0a1", "patch": "@@ -0,0 +1,76 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-10-27  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Single-element insert\n+\n+#include <iterator>\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::unordered_map<int, rvalstruct> Map;\n+  typedef std::pair<const int, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty());\n+\n+  std::pair<Map::iterator, bool> p = m.insert(Pair(1, rvalstruct(3)));\n+  VERIFY( p.second );\n+  VERIFY( m.size() == 1 );\n+  VERIFY( std::distance(m.begin(), m.end()) == 1 );\n+  VERIFY( p.first == m.begin() );\n+  VERIFY( p.first->first == 1 );\n+  VERIFY( (p.first->second).val == 3 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::unordered_map<int, rvalstruct> Map;\n+  typedef std::pair<const int, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty() );\n+\n+  std::pair<Map::iterator, bool> p1 = m.insert(Pair(2, rvalstruct(3)));\n+  std::pair<Map::iterator, bool> p2 = m.insert(Pair(2, rvalstruct(7)));\n+\n+  VERIFY( p1.second );\n+  VERIFY( !p2.second );\n+  VERIFY( m.size() == 1 );\n+  VERIFY( p1.first == p2.first );\n+  VERIFY( p1.first->first == 2 );\n+  VERIFY( (p2.first->second).val == 3 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "76b6bba00776eccbe731945601e23d701d65e97b", "filename": "libstdc++-v3/testsuite/23_containers/unordered_map/insert/map_single_move-2.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2Fmap_single_move-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2Fmap_single_move-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_map%2Finsert%2Fmap_single_move-2.cc?ref=fb7342fd6f834c6786278eeb9d99d704c2f6a0a1", "patch": "@@ -0,0 +1,79 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-10-27  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Single-element insert\n+\n+#include <iterator>\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::unordered_map<rvalstruct, rvalstruct> Map;\n+  typedef std::pair<rvalstruct, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty());\n+\n+  std::pair<Map::iterator, bool> p = m.insert(Pair(rvalstruct(1),\n+\t\t\t\t\t\t   rvalstruct(3)));\n+  VERIFY( p.second );\n+  VERIFY( m.size() == 1 );\n+  VERIFY( std::distance(m.begin(), m.end()) == 1 );\n+  VERIFY( p.first == m.begin() );\n+  VERIFY( (p.first->first).val == 1 );\n+  VERIFY( (p.first->second).val == 3 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::unordered_map<rvalstruct, rvalstruct> Map;\n+  typedef std::pair<rvalstruct, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty() );\n+\n+  std::pair<Map::iterator, bool> p1 = m.insert(Pair(rvalstruct(2),\n+\t\t\t\t\t\t    rvalstruct(3)));\n+  std::pair<Map::iterator, bool> p2 = m.insert(Pair(rvalstruct(2),\n+\t\t\t\t\t\t    rvalstruct(7)));\n+\n+  VERIFY( p1.second );\n+  VERIFY( !p2.second );\n+  VERIFY( m.size() == 1 );\n+  VERIFY( p1.first == p2.first );\n+  VERIFY( (p1.first->first).val == 2 );\n+  VERIFY( (p2.first->second).val == 3 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "4c933069c46484690d0d48ff7707c4fb40aa401f", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/insert/multimap_single_move-1.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2Fmultimap_single_move-1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2Fmultimap_single_move-1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2Fmultimap_single_move-1.cc?ref=fb7342fd6f834c6786278eeb9d99d704c2f6a0a1", "patch": "@@ -0,0 +1,80 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-10-27  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Single-element insert\n+\n+#include <iterator>\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::unordered_multimap<int, rvalstruct> Map;\n+  typedef std::pair<const int, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty() );\n+\n+  Map::iterator i = m.insert(Pair(1, rvalstruct(3)));\n+  VERIFY( m.size() == 1 );\n+  VERIFY( std::distance(m.begin(), m.end()) == 1 );\n+  VERIFY( i == m.begin() );\n+  VERIFY( i->first == 1 );\n+  VERIFY( (i->second).val == 3 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::unordered_multimap<int, rvalstruct> Map;\n+  typedef std::pair<const int, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty() );\n+\n+  m.insert(Pair(2, rvalstruct(3)));\n+  m.insert(Pair(2, rvalstruct(7)));\n+\n+  VERIFY( m.size() == 2 );\n+  VERIFY( std::distance(m.begin(), m.end()) == 2 );\n+\n+  Map::iterator i1 = m.begin();\n+  Map::iterator i2 = i1;\n+  ++i2;\n+\n+  VERIFY( i1->first == 2 );\n+  VERIFY( i2->first == 2 );\n+  VERIFY( ((i1->second).val == 3 && (i2->second).val == 7)\n+\t  || ((i1->second).val == 7 && (i2->second).val == 3) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "e9008b461566152fd537b6cd165bad6c70f45bd4", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/insert/multimap_single_move-2.cc", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2Fmultimap_single_move-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2Fmultimap_single_move-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2Fmultimap_single_move-2.cc?ref=fb7342fd6f834c6786278eeb9d99d704c2f6a0a1", "patch": "@@ -0,0 +1,80 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-10-27  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Single-element insert\n+\n+#include <iterator>\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::unordered_multimap<rvalstruct, rvalstruct> Map;\n+  typedef std::pair<rvalstruct, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty() );\n+\n+  Map::iterator i = m.insert(Pair(rvalstruct(1), rvalstruct(3)));\n+  VERIFY( m.size() == 1 );\n+  VERIFY( std::distance(m.begin(), m.end()) == 1 );\n+  VERIFY( i == m.begin() );\n+  VERIFY( (i->first).val == 1 );\n+  VERIFY( (i->second).val == 3 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::unordered_multimap<rvalstruct, rvalstruct> Map;\n+  typedef std::pair<rvalstruct, rvalstruct> Pair;\n+\n+  Map m;\n+  VERIFY( m.empty() );\n+\n+  m.insert(Pair(rvalstruct(2), rvalstruct(3)));\n+  m.insert(Pair(rvalstruct(2), rvalstruct(7)));\n+\n+  VERIFY( m.size() == 2 );\n+  VERIFY( std::distance(m.begin(), m.end()) == 2 );\n+\n+  Map::iterator i1 = m.begin();\n+  Map::iterator i2 = i1;\n+  ++i2;\n+\n+  VERIFY( (i1->first).val == 2 );\n+  VERIFY( (i2->first).val == 2 );\n+  VERIFY( ((i1->second).val == 3 && (i2->second).val == 7)\n+\t  || ((i1->second).val == 7 && (i2->second).val == 3) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "14b8e16817a6aa7083edc89a5fe1be5f57fe42cd", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multiset/insert/multiset_single_move.cc", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Finsert%2Fmultiset_single_move.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Finsert%2Fmultiset_single_move.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multiset%2Finsert%2Fmultiset_single_move.cc?ref=fb7342fd6f834c6786278eeb9d99d704c2f6a0a1", "patch": "@@ -0,0 +1,71 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-10-27  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Single-element insert\n+\n+#include <iterator>\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::unordered_multiset<rvalstruct> Set;\n+  Set s;\n+  VERIFY( s.empty() );\n+\n+  Set::iterator i = s.insert(rvalstruct(1));\n+  VERIFY( s.size() == 1 );\n+  VERIFY( std::distance(s.begin(), s.end()) == 1 );\n+  VERIFY( i == s.begin() );\n+  VERIFY( (*i).val == 1 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::unordered_multiset<rvalstruct> Set;\n+  Set s;\n+  VERIFY( s.empty() );\n+\n+  s.insert(rvalstruct(2));\n+  Set::iterator i = s.insert(rvalstruct(2));\n+  VERIFY( s.size() == 2 );\n+  VERIFY( std::distance(s.begin(), s.end()) == 2 );\n+  VERIFY( (*i).val == 2 );\n+  \n+  Set::iterator i2 = s.begin();\n+  ++i2;\n+  VERIFY( i == s.begin() || i == i2 );\n+  VERIFY( (*(s.begin())).val == 2 && (*i2).val == 2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "0b9ad173b0f7a1885cb130e7e98878c49a65c4f7", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/insert/set_single_move.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2Fset_single_move.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2Fset_single_move.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2Fset_single_move.cc?ref=fb7342fd6f834c6786278eeb9d99d704c2f6a0a1", "patch": "@@ -0,0 +1,69 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// 2010-10-27  Paolo Carlini  <paolo.carlini@oracle.com> \n+//\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// Single-element insert\n+\n+#include <iterator>\n+#include <unordered_set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_rvalref.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::unordered_set<rvalstruct> Set;\n+  Set s;\n+  VERIFY( s.empty() );\n+\n+  std::pair<Set::iterator, bool> p = s.insert(rvalstruct(1));\n+  VERIFY( p.second );\n+  VERIFY( s.size() == 1 );\n+  VERIFY( std::distance(s.begin(), s.end()) == 1 );\n+  VERIFY( p.first == s.begin() );\n+  VERIFY( (*p.first).val == 1 );\n+}\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using __gnu_test::rvalstruct;\n+\n+  typedef std::unordered_set<rvalstruct> Set;\n+  Set s;\n+  VERIFY( s.empty() );\n+\n+  std::pair<Set::iterator, bool> p1 = s.insert(rvalstruct(2));\n+  std::pair<Set::iterator, bool> p2 = s.insert(rvalstruct(2));  \n+  VERIFY( p1.second );\n+  VERIFY( !p2.second );\n+  VERIFY( s.size() == 1 );\n+  VERIFY( p1.first == p2.first );\n+  VERIFY( (*p1.first).val == 2 );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  return 0;\n+}"}, {"sha": "5610b77cc43ac09a4841615b5c55db52225eff9e", "filename": "libstdc++-v3/testsuite/util/testsuite_rvalref.h", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_rvalref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb7342fd6f834c6786278eeb9d99d704c2f6a0a1/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_rvalref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_rvalref.h?ref=fb7342fd6f834c6786278eeb9d99d704c2f6a0a1", "patch": "@@ -1,7 +1,8 @@\n // -*- C++ -*-\n // Testing utilities for the rvalue reference.\n //\n-// Copyright (C) 2005, 2007, 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -27,35 +28,30 @@\n namespace __gnu_test\n {\n \n-  //  This class is designed to test libstdc++'s template-based rvalue\n-  //  reference support. It should fail at compile-time if there is an attempt\n-  //  to copy it (although see note just below).\n-  class rvalstruct\n+  // This class is designed to test libstdc++'s template-based rvalue\n+  // reference support. It should fail at compile-time if there is an\n+  // attempt to copy it.\n+  struct rvalstruct\n   {\n-    bool\n-    operator=(const rvalstruct&);\n-\n-    rvalstruct(const rvalstruct&);\n-\n-  public:\n     int val;\n     bool valid;\n \n-    rvalstruct() : valid(false)\n+    rvalstruct() : val(0), valid(true)\n     { }\n \n     rvalstruct(int inval) : val(inval), valid(true)\n     { }\n-    \n+\n     rvalstruct&\n     operator=(int newval)\n     { \n-      VERIFY(valid == false);\n-      val = newval; \n+      val = newval;\n       valid = true;\n       return *this;\n     }\n \n+    rvalstruct(const rvalstruct&) = delete;\n+\n     rvalstruct(rvalstruct&& in)\n     { \n       VERIFY(in.valid == true);\n@@ -64,6 +60,9 @@ namespace __gnu_test\n       valid = true;\n     }\n \n+    rvalstruct&\n+    operator=(const rvalstruct&) = delete;\n+\n     rvalstruct&\n     operator=(rvalstruct&& in)\n     { \n@@ -75,11 +74,11 @@ namespace __gnu_test\n     }\n   };\n \n-  bool \n+  inline bool \n   operator==(const rvalstruct& lhs, const rvalstruct& rhs)\n   { return lhs.val == rhs.val; }\n \n-  bool\n+  inline bool\n   operator<(const rvalstruct& lhs, const rvalstruct& rhs)\n   { return lhs.val < rhs.val; }\n \n@@ -156,15 +155,15 @@ namespace __gnu_test\n \n   int copycounter::copycount = 0;\n   \n-  bool \n+  inline bool\n   operator==(const copycounter& lhs, const copycounter& rhs)\n   { return lhs.val == rhs.val; }\n \n-  bool\n+  inline bool\n   operator<(const copycounter& lhs, const copycounter& rhs)\n   { return lhs.val < rhs.val; }\n \n-  void\n+  inline void\n   swap(copycounter& lhs, copycounter& rhs)\n   {  \n     VERIFY(lhs.valid && rhs.valid);\n@@ -175,4 +174,21 @@ namespace __gnu_test\n   \n } // namespace __gnu_test\n \n+namespace std\n+{\n+  template<typename _Tp> struct hash;\n+\n+  /// std::hash specialization for type_index.\n+  template<>\n+    struct hash<__gnu_test::rvalstruct>\n+    {\n+      typedef size_t                    result_type;\n+      typedef __gnu_test::rvalstruct  argument_type;\n+\n+      size_t\n+      operator()(const __gnu_test::rvalstruct& __rvs) const\n+      { return __rvs.val; }\n+    };\n+}\n+\n #endif // _GLIBCXX_TESTSUITE_TR1_H"}]}