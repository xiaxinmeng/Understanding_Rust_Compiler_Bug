{"sha": "6f652a50723f0fe0f8b055a1f532058c1dce3c18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY2NTJhNTA3MjNmMGZlMGY4YjA1NWExZjUzMjA1OGMxZGNlM2MxOA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2016-03-31T17:28:29Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2016-03-31T17:28:29Z"}, "message": "re PR hsa/70399 (HSA:  Wrong emission of st_align(4)_u8 HSAIL insn)\n\nFix PR hsa/70399\n\n\tPR hsa/70399\n\t* hsa-brig.c (hsa_op_immed::emit_to_buffer): Emit either\n\ta tree value or an immediate integer value to a buffer\n\tthat is eventually copied to a BRIG section.\n\t(emit_immediate_operand): Call the function here.\n\t* hsa-dump.c (dump_hsa_immed): Remove checking assert.\n\t* hsa-gen.c (hsa_op_immed::hsa_op_immed): Remove initialization\n\tof class' fields that are removed.\n\t(hsa_op_immed::~hsa_op_immed): Remove deinitialization.\n\t* hsa.h (class hsa_op_immed): Remove m_brig_repr and\n\tm_brig_repr_size fields.\n\nFrom-SVN: r234647", "tree": {"sha": "192a6bd144bcde32b380ffedb4a8406f76e58090", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/192a6bd144bcde32b380ffedb4a8406f76e58090"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f652a50723f0fe0f8b055a1f532058c1dce3c18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f652a50723f0fe0f8b055a1f532058c1dce3c18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f652a50723f0fe0f8b055a1f532058c1dce3c18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f652a50723f0fe0f8b055a1f532058c1dce3c18/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c1c341ab925c44695f4f27bcc0f7222895e0650f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1c341ab925c44695f4f27bcc0f7222895e0650f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1c341ab925c44695f4f27bcc0f7222895e0650f"}], "stats": {"total": 229, "additions": 123, "deletions": 106}, "files": [{"sha": "dac7727950b024b4857963d25c4db7ba1ca48b54", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f652a50723f0fe0f8b055a1f532058c1dce3c18/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f652a50723f0fe0f8b055a1f532058c1dce3c18/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f652a50723f0fe0f8b055a1f532058c1dce3c18", "patch": "@@ -1,3 +1,17 @@\n+2016-03-31  Martin Liska  <mliska@suse.cz>\n+\n+\tPR hsa/70399\n+\t* hsa-brig.c (hsa_op_immed::emit_to_buffer): Emit either\n+\ta tree value or an immediate integer value to a buffer\n+\tthat is eventually copied to a BRIG section.\n+\t(emit_immediate_operand): Call the function here.\n+\t* hsa-dump.c (dump_hsa_immed): Remove checking assert.\n+\t* hsa-gen.c (hsa_op_immed::hsa_op_immed): Remove initialization\n+\tof class' fields that are removed.\n+\t(hsa_op_immed::~hsa_op_immed): Remove deinitialization.\n+\t* hsa.h (class hsa_op_immed): Remove m_brig_repr and\n+\tm_brig_repr_size fields.\n+\n 2016-03-31  Martin Liska  <mliska@suse.cz>\n \n \tPR hsa/70391"}, {"sha": "018b7be12fb6d0348a79e57f7e716dad0bc910a5", "filename": "gcc/hsa-brig.c", "status": "modified", "additions": 88, "deletions": 45, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f652a50723f0fe0f8b055a1f532058c1dce3c18/gcc%2Fhsa-brig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f652a50723f0fe0f8b055a1f532058c1dce3c18/gcc%2Fhsa-brig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-brig.c?ref=6f652a50723f0fe0f8b055a1f532058c1dce3c18", "patch": "@@ -929,62 +929,101 @@ emit_immediate_scalar_to_buffer (tree value, char *data, unsigned need_len)\n   return len;\n }\n \n-void\n-hsa_op_immed::emit_to_buffer (tree value)\n+char *\n+hsa_op_immed::emit_to_buffer (unsigned *brig_repr_size)\n {\n-  unsigned total_len = m_brig_repr_size;\n-\n-  /* As we can have a constructor with fewer elements, fill the memory\n-     with zeros.  */\n-  m_brig_repr = XCNEWVEC (char, total_len);\n-  char *p = m_brig_repr;\n+  char *brig_repr;\n+  *brig_repr_size = hsa_get_imm_brig_type_len (m_type);\n \n-  if (TREE_CODE (value) == VECTOR_CST)\n+  if (m_tree_value != NULL_TREE)\n     {\n-      int i, num = VECTOR_CST_NELTS (value);\n-      for (i = 0; i < num; i++)\n+      /* Update brig_repr_size for special tree values.  */\n+      if (TREE_CODE (m_tree_value) == STRING_CST)\n+\t*brig_repr_size = TREE_STRING_LENGTH (m_tree_value);\n+      else if (TREE_CODE (m_tree_value) == CONSTRUCTOR)\n+\t*brig_repr_size\n+\t  = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (m_tree_value)));\n+\n+      unsigned total_len = *brig_repr_size;\n+\n+      /* As we can have a constructor with fewer elements, fill the memory\n+\t with zeros.  */\n+      brig_repr = XCNEWVEC (char, total_len);\n+      char *p = brig_repr;\n+\n+      if (TREE_CODE (m_tree_value) == VECTOR_CST)\n \t{\n+\t  int i, num = VECTOR_CST_NELTS (m_tree_value);\n+\t  for (i = 0; i < num; i++)\n+\t    {\n+\t      tree v = VECTOR_CST_ELT (m_tree_value, i);\n+\t      unsigned actual = emit_immediate_scalar_to_buffer (v, p, 0);\n+\t      total_len -= actual;\n+\t      p += actual;\n+\t    }\n+\t  /* Vectors should have the exact size.  */\n+\t  gcc_assert (total_len == 0);\n+\t}\n+      else if (TREE_CODE (m_tree_value) == STRING_CST)\n+\tmemcpy (brig_repr, TREE_STRING_POINTER (m_tree_value),\n+\t\tTREE_STRING_LENGTH (m_tree_value));\n+      else if (TREE_CODE (m_tree_value) == COMPLEX_CST)\n+\t{\n+\t  gcc_assert (total_len % 2 == 0);\n \t  unsigned actual;\n \t  actual\n-\t    = emit_immediate_scalar_to_buffer (VECTOR_CST_ELT (value, i), p, 0);\n-\t  total_len -= actual;\n+\t    = emit_immediate_scalar_to_buffer (TREE_REALPART (m_tree_value), p,\n+\t\t\t\t\t       total_len / 2);\n+\n+\t  gcc_assert (actual == total_len / 2);\n \t  p += actual;\n+\n+\t  actual\n+\t    = emit_immediate_scalar_to_buffer (TREE_IMAGPART (m_tree_value), p,\n+\t\t\t\t\t       total_len / 2);\n+\t  gcc_assert (actual == total_len / 2);\n \t}\n-      /* Vectors should have the exact size.  */\n-      gcc_assert (total_len == 0);\n-    }\n-  else if (TREE_CODE (value) == STRING_CST)\n-    memcpy (m_brig_repr, TREE_STRING_POINTER (value),\n-\t    TREE_STRING_LENGTH (value));\n-  else if (TREE_CODE (value) == COMPLEX_CST)\n-    {\n-      gcc_assert (total_len % 2 == 0);\n-      unsigned actual;\n-      actual\n-\t= emit_immediate_scalar_to_buffer (TREE_REALPART (value), p,\n-\t\t\t\t\t   total_len / 2);\n-\n-      gcc_assert (actual == total_len / 2);\n-      p += actual;\n-\n-      actual\n-\t= emit_immediate_scalar_to_buffer (TREE_IMAGPART (value), p,\n-\t\t\t\t\t   total_len / 2);\n-      gcc_assert (actual == total_len / 2);\n+      else if (TREE_CODE (m_tree_value) == CONSTRUCTOR)\n+\t{\n+\t  unsigned len = vec_safe_length (CONSTRUCTOR_ELTS (m_tree_value));\n+\t  for (unsigned i = 0; i < len; i++)\n+\t    {\n+\t      tree v = CONSTRUCTOR_ELT (m_tree_value, i)->value;\n+\t      unsigned actual = emit_immediate_scalar_to_buffer (v, p, 0);\n+\t      total_len -= actual;\n+\t      p += actual;\n+\t    }\n+\t}\n+      else\n+\temit_immediate_scalar_to_buffer (m_tree_value, p, total_len);\n     }\n-  else if (TREE_CODE (value) == CONSTRUCTOR)\n+  else\n     {\n-      unsigned len = vec_safe_length (CONSTRUCTOR_ELTS (value));\n-      for (unsigned i = 0; i < len; i++)\n+      hsa_bytes bytes;\n+\n+      switch (*brig_repr_size)\n \t{\n-\t  tree v = CONSTRUCTOR_ELT (value, i)->value;\n-\t  unsigned actual = emit_immediate_scalar_to_buffer (v, p, 0);\n-\t  total_len -= actual;\n-\t  p += actual;\n+\tcase 1:\n+\t  bytes.b8 = (uint8_t) m_int_value;\n+\t  break;\n+\tcase 2:\n+\t  bytes.b16 = (uint16_t) m_int_value;\n+\t  break;\n+\tcase 4:\n+\t  bytes.b32 = (uint32_t) m_int_value;\n+\t  break;\n+\tcase 8:\n+\t  bytes.b64 = (uint64_t) m_int_value;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n \t}\n+\n+      brig_repr = XNEWVEC (char, *brig_repr_size);\n+      memcpy (brig_repr, &bytes, *brig_repr_size);\n     }\n-  else\n-    emit_immediate_scalar_to_buffer (value, p, total_len);\n+\n+  return brig_repr;\n }\n \n /* Emit an immediate BRIG operand IMM.  The BRIG type of the immediate might\n@@ -996,17 +1035,21 @@ hsa_op_immed::emit_to_buffer (tree value)\n static void\n emit_immediate_operand (hsa_op_immed *imm)\n {\n+  unsigned brig_repr_size;\n+  char *brig_repr = imm->emit_to_buffer (&brig_repr_size);\n   struct BrigOperandConstantBytes out;\n \n   memset (&out, 0, sizeof (out));\n   out.base.byteCount = lendian16 (sizeof (out));\n   out.base.kind = lendian16 (BRIG_KIND_OPERAND_CONSTANT_BYTES);\n-  uint32_t byteCount = lendian32 (imm->m_brig_repr_size);\n+  uint32_t byteCount = lendian32 (brig_repr_size);\n   out.type = lendian16 (imm->m_type);\n   out.bytes = lendian32 (brig_data.add (&byteCount, sizeof (byteCount)));\n   brig_operand.add (&out, sizeof (out));\n-  brig_data.add (imm->m_brig_repr, imm->m_brig_repr_size);\n+  brig_data.add (brig_repr, brig_repr_size);\n   brig_data.round_size_up (4);\n+\n+  free (brig_repr);\n }\n \n /* Emit a register BRIG operand REG.  */"}, {"sha": "71b971234d4cf1219c851e7ea74ab07cd70bae61", "filename": "gcc/hsa-dump.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f652a50723f0fe0f8b055a1f532058c1dce3c18/gcc%2Fhsa-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f652a50723f0fe0f8b055a1f532058c1dce3c18/gcc%2Fhsa-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-dump.c?ref=6f652a50723f0fe0f8b055a1f532058c1dce3c18", "patch": "@@ -647,8 +647,6 @@ dump_hsa_immed (FILE *f, hsa_op_immed *imm)\n     print_generic_expr (f, imm->m_tree_value, 0);\n   else\n     {\n-      gcc_checking_assert (imm->m_brig_repr_size <= 8);\n-\n       if (unsigned_int_type)\n \tfprintf (f, HOST_WIDE_INT_PRINT_DEC, imm->m_int_value);\n       else"}, {"sha": "bc95c5c1955139e4a84655b9be2b1b258b809bbe", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 16, "deletions": 52, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f652a50723f0fe0f8b055a1f532058c1dce3c18/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f652a50723f0fe0f8b055a1f532058c1dce3c18/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=6f652a50723f0fe0f8b055a1f532058c1dce3c18", "patch": "@@ -1075,8 +1075,7 @@ hsa_op_with_type::get_in_type (BrigType16_t dtype, hsa_bb *hbb)\n hsa_op_immed::hsa_op_immed (tree tree_val, bool min32int)\n   : hsa_op_with_type (BRIG_KIND_OPERAND_CONSTANT_BYTES,\n \t\t      hsa_type_for_tree_type (TREE_TYPE (tree_val), NULL,\n-\t\t\t\t\t      min32int)),\n-  m_brig_repr (NULL)\n+\t\t\t\t\t      min32int))\n {\n   if (hsa_seen_error ())\n     return;\n@@ -1086,69 +1085,35 @@ hsa_op_immed::hsa_op_immed (tree tree_val, bool min32int)\n \t\t\t   || TREE_CODE (tree_val) == INTEGER_CST))\n \t\t       || TREE_CODE (tree_val) == CONSTRUCTOR);\n   m_tree_value = tree_val;\n-  m_brig_repr_size = hsa_get_imm_brig_type_len (m_type);\n \n-  if (TREE_CODE (m_tree_value) == STRING_CST)\n-    m_brig_repr_size = TREE_STRING_LENGTH (m_tree_value);\n-  else if (TREE_CODE (m_tree_value) == CONSTRUCTOR)\n-    {\n-      m_brig_repr_size\n-\t= tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (m_tree_value)));\n-\n-      /* Verify that all elements of a constructor are constants.  */\n-      for (unsigned i = 0;\n-\t   i < vec_safe_length (CONSTRUCTOR_ELTS (m_tree_value)); i++)\n-\t{\n-\t  tree v = CONSTRUCTOR_ELT (m_tree_value, i)->value;\n-\t  if (!CONSTANT_CLASS_P (v))\n-\t    {\n-\t      HSA_SORRY_AT (EXPR_LOCATION (tree_val),\n-\t\t\t    \"HSA ctor should have only constants\");\n-\t      return;\n-\t    }\n-\t}\n-    }\n-\n-  emit_to_buffer (m_tree_value);\n+  /* Verify that all elements of a constructor are constants.  */\n+  if (TREE_CODE (m_tree_value) == CONSTRUCTOR)\n+    for (unsigned i = 0;\n+\t i < vec_safe_length (CONSTRUCTOR_ELTS (m_tree_value)); i++)\n+      {\n+\ttree v = CONSTRUCTOR_ELT (m_tree_value, i)->value;\n+\tif (!CONSTANT_CLASS_P (v))\n+\t  {\n+\t    HSA_SORRY_AT (EXPR_LOCATION (tree_val),\n+\t\t\t  \"HSA ctor should have only constants\");\n+\t    return;\n+\t  }\n+      }\n }\n \n /* Constructor of class representing HSA immediate values.  INTEGER_VALUE is the\n    integer representation of the immediate value.  TYPE is BRIG type.  */\n \n hsa_op_immed::hsa_op_immed (HOST_WIDE_INT integer_value, BrigType16_t type)\n   : hsa_op_with_type (BRIG_KIND_OPERAND_CONSTANT_BYTES, type),\n-    m_tree_value (NULL), m_brig_repr (NULL)\n+    m_tree_value (NULL)\n {\n   gcc_assert (hsa_type_integer_p (type));\n   m_int_value = integer_value;\n-  m_brig_repr_size = hsa_type_bit_size (type) / BITS_PER_UNIT;\n-\n-  hsa_bytes bytes;\n-\n-  switch (m_brig_repr_size)\n-    {\n-    case 1:\n-      bytes.b8 = (uint8_t) m_int_value;\n-      break;\n-    case 2:\n-      bytes.b16 = (uint16_t) m_int_value;\n-      break;\n-    case 4:\n-      bytes.b32 = (uint32_t) m_int_value;\n-      break;\n-    case 8:\n-      bytes.b64 = (uint64_t) m_int_value;\n-      break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  m_brig_repr = XNEWVEC (char, m_brig_repr_size);\n-  memcpy (m_brig_repr, &bytes, m_brig_repr_size);\n }\n \n hsa_op_immed::hsa_op_immed ()\n-  : hsa_op_with_type (BRIG_KIND_NONE, BRIG_TYPE_NONE), m_brig_repr (NULL)\n+  : hsa_op_with_type (BRIG_KIND_NONE, BRIG_TYPE_NONE)\n {\n }\n \n@@ -1164,7 +1129,6 @@ hsa_op_immed::operator new (size_t)\n \n hsa_op_immed::~hsa_op_immed ()\n {\n-  free (m_brig_repr);\n }\n \n /* Change type of the immediate value to T.  */"}, {"sha": "77ef6f184bdc23de09a3b92c06d3f6dfed8b1b03", "filename": "gcc/hsa.h", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f652a50723f0fe0f8b055a1f532058c1dce3c18/gcc%2Fhsa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f652a50723f0fe0f8b055a1f532058c1dce3c18/gcc%2Fhsa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa.h?ref=6f652a50723f0fe0f8b055a1f532058c1dce3c18", "patch": "@@ -175,25 +175,23 @@ class hsa_op_immed : public hsa_op_with_type\n   ~hsa_op_immed ();\n   void set_type (BrigKind16_t t);\n \n+  /* Function returns pointer to a buffer that contains binary representation\n+     of the immeadiate value.  The buffer has length of BRIG_SIZE and\n+     a caller is responsible for deallocation of the buffer.  */\n+  char *emit_to_buffer (unsigned *brig_size);\n+\n   /* Value as represented by middle end.  */\n   tree m_tree_value;\n \n   /* Integer value representation.  */\n   HOST_WIDE_INT m_int_value;\n \n-  /* Brig data representation.  */\n-  char *m_brig_repr;\n-\n-  /* Brig data representation size in bytes.  */\n-  unsigned m_brig_repr_size;\n-\n private:\n   /* Make the default constructor inaccessible.  */\n   hsa_op_immed ();\n   /* All objects are deallocated by destroying their pool, so make delete\n      inaccessible too.  */\n   void operator delete (void *) {}\n-  void emit_to_buffer (tree value);\n };\n \n /* Report whether or not P is a an immediate operand.  */"}]}