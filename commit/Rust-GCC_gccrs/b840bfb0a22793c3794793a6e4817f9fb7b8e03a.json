{"sha": "b840bfb0a22793c3794793a6e4817f9fb7b8e03a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjg0MGJmYjBhMjI3OTNjMzc5NDc5M2E2ZTQ4MTdmOWZiN2I4ZTAzYQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1994-09-20T18:36:51Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1994-09-20T18:36:51Z"}, "message": "Respin DI support to be combine friendly; Allow push of SF without temp reg; Fix broken i386 untyped_call\n\nFrom-SVN: r8098", "tree": {"sha": "6807dcc71df9d1143e9db694545eb8346bd766b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6807dcc71df9d1143e9db694545eb8346bd766b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b840bfb0a22793c3794793a6e4817f9fb7b8e03a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b840bfb0a22793c3794793a6e4817f9fb7b8e03a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b840bfb0a22793c3794793a6e4817f9fb7b8e03a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b840bfb0a22793c3794793a6e4817f9fb7b8e03a/comments", "author": null, "committer": null, "parents": [{"sha": "3221f176136402b4df91492f2234ce203cba6e76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3221f176136402b4df91492f2234ce203cba6e76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3221f176136402b4df91492f2234ce203cba6e76"}], "stats": {"total": 588, "additions": 243, "deletions": 345}, "files": [{"sha": "5a9e8824777b2e7c342ae6678efd821d7f0b71c5", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b840bfb0a22793c3794793a6e4817f9fb7b8e03a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b840bfb0a22793c3794793a6e4817f9fb7b8e03a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b840bfb0a22793c3794793a6e4817f9fb7b8e03a", "patch": "@@ -378,6 +378,7 @@ find_addr_reg (addr)\n   abort ();\n }\n \n+\f\n /* Output an insn to add the constant N to the register X.  */\n \n static void\n@@ -404,6 +405,7 @@ asm_add (n, x)\n     }\n }\n \n+\f\n /* Output assembler code to perform a doubleword move insn\n    with operands OPERANDS.  */\n \n@@ -735,6 +737,199 @@ output_move_double (operands)\n \n   return \"\";\n }\n+\n+\f\n+#define MAX_TMPS 2\t\t/* max temporary registers used */\n+\n+/* Output the appropriate code to move push memory on the stack */\n+\n+char *\n+output_move_pushmem (operands, insn, length, tmp_start, n_operands)\n+     rtx operands[];\n+     rtx insn;\n+     int length;\n+     int tmp_start;\n+     int n_operands;\n+{\n+\n+  struct {\n+    char *load;\n+    char *push;\n+    rtx   xops[2];\n+  } tmp_info[MAX_TMPS];\n+\n+  rtx src = operands[1];\n+  int max_tmps = 0;\n+  int offset = 0;\n+  int stack_p = reg_overlap_mentioned_p (stack_pointer_rtx, src);\n+  int stack_offset = 0;\n+  int i, num_tmps;\n+  rtx xops[1];\n+\n+  if (!offsettable_memref_p (src))\n+    fatal_insn (\"Source is not offsettable\", insn);\n+\n+  if ((length & 3) != 0)\n+    fatal_insn (\"Pushing non-word aligned size\", insn);\n+\n+  /* Figure out which temporary registers we have available */\n+  for (i = tmp_start; i < n_operands; i++)\n+    {\n+      if (GET_CODE (operands[i]) == REG)\n+\t{\n+\t  if (reg_overlap_mentioned_p (operands[i], src))\n+\t    continue;\n+\n+\t  tmp_info[ max_tmps++ ].xops[1] = operands[i];\n+\t  if (max_tmps == MAX_TMPS)\n+\t    break;\n+\t}\n+    }\n+\n+  if (max_tmps == 0)\n+    for (offset = length - 4; offset >= 0; offset -= 4)\n+      {\n+\txops[0] = adj_offsettable_operand (src, offset + stack_offset);\n+\toutput_asm_insn (AS1(push%L0,%0), xops);\n+\tif (stack_p)\n+\t  stack_offset += 4;\n+      }\n+\n+  else\n+    for (offset = length - 4; offset >= 0; )\n+      {\n+\tfor (num_tmps = 0; num_tmps < max_tmps && offset >= 0; num_tmps++)\n+\t  {\n+\t    tmp_info[num_tmps].load    = AS2(mov%L0,%0,%1);\n+\t    tmp_info[num_tmps].push    = AS1(push%L0,%1);\n+\t    tmp_info[num_tmps].xops[0] = adj_offsettable_operand (src, offset + stack_offset);\n+\t    offset -= 4;\n+\t  }\n+\n+\tfor (i = 0; i < num_tmps; i++)\n+\t  output_asm_insn (tmp_info[i].load, tmp_info[i].xops);\n+\n+\tfor (i = 0; i < num_tmps; i++)\n+\t  output_asm_insn (tmp_info[i].push, tmp_info[i].xops);\n+\n+\tif (stack_p)\n+\t  stack_offset += 4*num_tmps;\n+      }\n+\n+  return \"\";\n+}\n+\n+\f\n+\n+/* Output the appropriate code to move data between two memory locations */\n+\n+char *\n+output_move_memory (operands, insn, length, tmp_start, n_operands)\n+     rtx operands[];\n+     rtx insn;\n+     int length;\n+     int tmp_start;\n+     int n_operands;\n+{\n+  struct {\n+    char *load;\n+    char *store;\n+    rtx   xops[3];\n+  } tmp_info[MAX_TMPS];\n+\n+  rtx dest = operands[0];\n+  rtx src  = operands[1];\n+  rtx qi_tmp = NULL_RTX;\n+  int max_tmps = 0;\n+  int offset = 0;\n+  int i, num_tmps;\n+  rtx xops[3];\n+\n+  if (GET_CODE (dest) == MEM\n+      && GET_CODE (XEXP (dest, 0)) == PRE_INC\n+      && XEXP (XEXP (dest, 0), 0) == stack_pointer_rtx)\n+    return output_move_pushmem (operands, insn, length, tmp_start, n_operands);\n+\n+  if (!offsettable_memref_p (src))\n+    fatal_insn (\"Source is not offsettable\", insn);\n+\n+  if (!offsettable_memref_p (dest))\n+    fatal_insn (\"Destination is not offsettable\", insn);\n+\n+  /* Figure out which temporary registers we have available */\n+  for (i = tmp_start; i < n_operands; i++)\n+    {\n+      if (GET_CODE (operands[i]) == REG)\n+\t{\n+\t  if ((length & 1) != 0 && !qi_tmp && QI_REG_P (operands[i]))\n+\t    qi_tmp = operands[i];\n+\n+\t  if (reg_overlap_mentioned_p (operands[i], dest))\n+\t    fatal_insn (\"Temporary register overlaps the destination\", insn);\n+\n+\t  if (reg_overlap_mentioned_p (operands[i], src))\n+\t    fatal_insn (\"Temporary register overlaps the source\", insn);\n+\n+\t  tmp_info[ max_tmps++ ].xops[2] = operands[i];\n+\t  if (max_tmps == MAX_TMPS)\n+\t    break;\n+\t}\n+    }\n+\n+  if (max_tmps == 0)\n+    fatal_insn (\"No scratch registers were found to do memory->memory moves\", insn);\n+\n+  if ((length & 1) != 0)\n+    {\n+      if (!qi_tmp)\n+\tfatal_insn (\"No byte register found when moving odd # of bytes.\", insn);\n+    }\n+\n+  while (length > 1)\n+    {\n+      for (num_tmps = 0; num_tmps < max_tmps; num_tmps++)\n+\t{\n+\t  if (length >= 4)\n+\t    {\n+\t      tmp_info[num_tmps].load    = AS2(mov%L0,%1,%2);\n+\t      tmp_info[num_tmps].store   = AS2(mov%L0,%2,%0);\n+\t      tmp_info[num_tmps].xops[0] = adj_offsettable_operand (dest, offset);\n+\t      tmp_info[num_tmps].xops[1] = adj_offsettable_operand (src, offset);\n+\t      offset += 4;\n+\t      length -= 4;\n+\t    }\n+\t  else if (length >= 2)\n+\t    {\n+\t      tmp_info[num_tmps].load    = AS2(mov%W0,%1,%2);\n+\t      tmp_info[num_tmps].store   = AS2(mov%W0,%2,%0);\n+\t      tmp_info[num_tmps].xops[0] = adj_offsettable_operand (dest, offset);\n+\t      tmp_info[num_tmps].xops[1] = adj_offsettable_operand (src, offset);\n+\t      offset += 2;\n+\t      length -= 2;\n+\t    }\n+\t  else\n+\t    break;\n+\t}\n+\n+      for (i = 0; i < num_tmps; i++)\n+\toutput_asm_insn (tmp_info[i].load, tmp_info[i].xops);\n+\n+      for (i = 0; i < num_tmps; i++)\n+\toutput_asm_insn (tmp_info[i].store, tmp_info[i].xops);\n+    }\n+\n+  if (length == 1)\n+    {\n+      xops[0] = adj_offsettable_operand (dest, offset);\n+      xops[1] = adj_offsettable_operand (src, offset);\n+      xops[2] = qi_tmp;\n+      output_asm_insn (AS2(mov%B0,%1,%2), xops);\n+      output_asm_insn (AS2(mov%B0,%2,%0), xops);\n+    }\n+\n+  return \"\";\n+}\n+\n \f\n int\n standard_80387_constant_p (x)"}, {"sha": "562f0bdf744f8b4846b03a8fbff48675900bafc6", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b840bfb0a22793c3794793a6e4817f9fb7b8e03a/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b840bfb0a22793c3794793a6e4817f9fb7b8e03a/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=b840bfb0a22793c3794793a6e4817f9fb7b8e03a", "patch": "@@ -1704,6 +1704,8 @@ extern void output_op_from_reg ();\n extern void output_to_reg ();\n extern char *singlemove_string ();\n extern char *output_move_double ();\n+extern char *output_move_memory ();\n+extern char *output_move_pushmem ();\n extern int standard_80387_constant_p ();\n extern char *output_move_const_single ();\n extern int symbolic_operand ();"}, {"sha": "0c1c31c59b82b2b01007c87a1890420a00bf86f5", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 45, "deletions": 342, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b840bfb0a22793c3794793a6e4817f9fb7b8e03a/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b840bfb0a22793c3794793a6e4817f9fb7b8e03a/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=b840bfb0a22793c3794793a6e4817f9fb7b8e03a", "patch": "@@ -808,6 +808,11 @@\n     /* Fastest way to change a 0 to a 1.  */\n     return AS1 (inc%L0,%0);\n \n+  if (flag_pic\n+      && GET_CODE (operands[1]) == SYMBOL_REF\n+      && CONSTANT_POOL_ADDRESS_P (operands[1]))\n+    return AS2 (lea%L0,%a1,%0);\n+\n   return AS2 (mov%L0,%1,%0);\n }\")\n \n@@ -1108,9 +1113,9 @@\n }\")\n \n (define_insn \"movsf_push\"\n-  [(set (match_operand:SF 0 \"push_operand\" \"=<,<,<\")\n-\t(match_operand:SF 1 \"general_operand\" \"rF,f,m\"))\n-   (clobber (match_scratch:SI 2 \"=X,X,r\"))]\n+  [(set (match_operand:SF 0 \"push_operand\" \"=<,<,<,<\")\n+\t(match_operand:SF 1 \"general_operand\" \"rF,f,m,m\"))\n+   (clobber (match_scratch:SI 2 \"=X,X,r,X\"))]\n   \"\"\n   \"*\n {\n@@ -1134,7 +1139,7 @@\n       RET;\n     }\n \n-  else if (GET_CODE (operands[1]) != MEM)\n+  else if (GET_CODE (operands[1]) != MEM || GET_CODE (operands[2]) != REG)\n     return AS1 (push%L1,%1);\n \n   else\n@@ -1301,42 +1306,11 @@\n       RET;\n     }\n \n-  else if (GET_CODE (operands[1]) != MEM\n-\t   || GET_CODE (operands[2]) != REG)\n+  else if (GET_CODE (operands[1]) != MEM)\n     return output_move_double (operands);\n \n   else\n-    {\n-      rtx low[1], high[1], xop[4];\n-\n-      split_di (&operands[1], 1, low, high);\n-      xop[0] = operands[2];\n-      xop[1] = operands[3];\n-      xop[2] = high[0];\n-      xop[3] = low[0];\n-\n-      if (GET_CODE (operands[3]) == REG)\n-\t{\t\t\t/* 2 scratch registers available */\n-\t  output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n-\t  output_asm_insn (AS2 (mov%L0,%3,%1), xop);\n-\t  output_asm_insn (AS1 (push%L0,%0), xop);\n-\t  output_asm_insn (AS1 (push%L0,%1), xop);\n-\t}\n-      else\n-\t{\t\t\t/* 1 scratch register */\n-\t  output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n-\t  output_asm_insn (AS1 (push%L0,%0), xop);\n-\n-\t\t\t\t/* account for push above */\n-\t  if (reg_mentioned_p (stack_pointer_rtx, XEXP (xop[3], 0)))\n-\t    xop[3] = adj_offsettable_operand (xop[3], 4);\n-\n-\t  output_asm_insn (AS2 (mov%L0,%3,%0), xop);\n-\t  output_asm_insn (AS1 (push%L0,%0), xop);\n-\t}\n-\n-      RET;\n-    }\n+    return output_move_pushmem (operands, insn, GET_MODE_SIZE (DFmode), 2, 4);\n }\")\n \n (define_insn \"movdf_mem\"\n@@ -1345,34 +1319,7 @@\n    (clobber (match_scratch:SI 2 \"=&r,&r\"))\n    (clobber (match_scratch:SI 3 \"=&r,X\"))]\n   \"\"\n-  \"*\n-{\n-  rtx low[2], high[2], xop[6];\n-\n-  split_di (operands, 2, low, high);\n-  xop[0] = operands[2];\n-  xop[1] = operands[3];\n-  xop[2] = high[0];\n-  xop[3] = high[1];\n-  xop[4] = low[0];\n-  xop[5] = low[1];\n-  if (GET_CODE (operands[3]) == REG)\n-    {\t\t\t\t/* 2 scratch registers available */\n-      output_asm_insn (AS2 (mov%L0,%5,%0), xop);\n-      output_asm_insn (AS2 (mov%L0,%3,%1), xop);\n-      output_asm_insn (AS2 (mov%L0,%0,%4), xop);\n-      output_asm_insn (AS2 (mov%L0,%1,%2), xop);\n-    }\n-  else\n-    {\t\t\t\t/* 1 scratch register */\n-      output_asm_insn (AS2 (mov%L0,%5,%0), xop);\n-      output_asm_insn (AS2 (mov%L0,%0,%4), xop);\n-      output_asm_insn (AS2 (mov%L0,%3,%0), xop);\n-      output_asm_insn (AS2 (mov%L0,%0,%2), xop);\n-    }\n-\n-  RET;\n-}\")\n+  \"* return output_move_memory (operands, insn, GET_MODE_SIZE (DFmode), 2, 4);\")\n \n ;; For the purposes of regclass, prefer FLOAT_REGS.\n (define_insn \"movdf_normal\"\n@@ -1520,51 +1467,7 @@\n     return output_move_double (operands);\n \n   else\n-    {\n-      rtx xop[5];\n-\n-      xop[0] = operands[2];\n-      xop[1] = operands[3];\n-      xop[2] = adj_offsettable_operand (operands[1], 8);\n-      xop[3] = adj_offsettable_operand (operands[1], 4);\n-      xop[4] = operands[1];\n-\n-      if (GET_CODE (operands[3]) == REG)\n-\t{\t\t\t/* 2 scratch registers available */\n-\t  output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n-\t  output_asm_insn (AS2 (mov%L0,%3,%1), xop);\n-\t  output_asm_insn (AS1 (push%L0,%0), xop);\n-\t  output_asm_insn (AS1 (push%L0,%1), xop);\n-\n-\t\t\t\t/* account for 2 pushes above */\n-\t  if (reg_mentioned_p (stack_pointer_rtx, XEXP (xop[4], 0)))\n-\t    xop[4] = adj_offsettable_operand (xop[4], 8);\n-\n-\t  output_asm_insn (AS2 (mov%L0,%4,%0), xop);\n-\t  output_asm_insn (AS1 (push%L0,%0), xop);\n-\t}\n-      else\n-\t{\t\t\t/* 1 scratch register */\n-\t  output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n-\t  output_asm_insn (AS1 (push%L0,%0), xop);\n-\n-\t\t\t\t/* account for 1 push above */\n-\t  if (reg_mentioned_p (stack_pointer_rtx, XEXP (xop[3], 0)))\n-\t    xop[3] = adj_offsettable_operand (xop[3], 4);\n-\n-\t  output_asm_insn (AS2 (mov%L0,%3,%0), xop);\n-\t  output_asm_insn (AS1 (push%L0,%0), xop);\n-\n-\t\t\t\t/* account for 2 pushes above */\n-\t  if (reg_mentioned_p (stack_pointer_rtx, XEXP (xop[4], 0)))\n-\t    xop[4] = adj_offsettable_operand (xop[4], 8);\n-\n-\t  output_asm_insn (AS2 (mov%L0,%4,%0), xop);\n-\t  output_asm_insn (AS1 (push%L0,%0), xop);\n-\t}\n-\n-      RET;\n-    }\n+    return output_move_pushmem (operands, insn, GET_MODE_SIZE (XFmode), 2, 4);\n }\")\n \n (define_insn \"movxf_mem\"\n@@ -1573,40 +1476,7 @@\n    (clobber (match_scratch:SI 2 \"=&r,&r\"))\n    (clobber (match_scratch:SI 3 \"=&r,X\"))]\n   \"\"\n-  \"*\n-{\n-  rtx xop[8];\n-\n-  xop[0] = operands[2];\n-  xop[1] = operands[3];\n-  xop[2] = adj_offsettable_operand (operands[1], 8);\n-  xop[3] = adj_offsettable_operand (operands[1], 4);\n-  xop[4] = operands[1];\n-  xop[5] = adj_offsettable_operand (operands[0], 8);\n-  xop[6] = adj_offsettable_operand (operands[0], 4);\n-  xop[7] = operands[0];\n-\n-  if (GET_CODE (operands[3]) == REG)\n-    {\t\t\t\t/* 2 scratch registers available */\n-      output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n-      output_asm_insn (AS2 (mov%L0,%3,%1), xop);\n-      output_asm_insn (AS2 (mov%L5,%0,%5), xop);\n-      output_asm_insn (AS2 (mov%L6,%1,%6), xop);\n-      output_asm_insn (AS2 (mov%L0,%4,%0), xop);\n-      output_asm_insn (AS2 (mov%L7,%0,%7), xop);\n-    }\n-  else\n-    {\t\t\t\t/* 1 scratch register */\n-      output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n-      output_asm_insn (AS2 (mov%L0,%0,%5), xop);\n-      output_asm_insn (AS2 (mov%L0,%3,%0), xop);\n-      output_asm_insn (AS2 (mov%L0,%0,%6), xop);\n-      output_asm_insn (AS2 (mov%L0,%4,%0), xop);\n-      output_asm_insn (AS2 (mov%L7,%0,%7), xop);\n-    }\n-\n-  RET;\n-}\")\n+  \"* return output_move_memory (operands, insn, GET_MODE_SIZE (XFmode), 2, 4);\")\n \n (define_insn \"movxf_normal\"\n   [(set (match_operand:XF 0 \"general_operand\" \"=f,fm,!*rf,!*rm\")\n@@ -1678,120 +1548,37 @@\n     return AS1 (fxch,%0);\n }\")\n \n-(define_expand \"movdi\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"\")\n-\t(match_operand:DI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  /* Special case memory->memory moves and pushes */\n-  if (TARGET_MOVE\n-      && (reload_in_progress | reload_completed) == 0\n-      && GET_CODE (operands[0]) == MEM\n-      && (GET_CODE (operands[1]) == MEM || push_operand (operands[0], DImode)))\n-    {\n-      rtx (*genfunc) PROTO((rtx, rtx)) = (push_operand (operands[0], DImode))\n-\t\t\t\t\t\t? gen_movdi_push\n-\t\t\t\t\t\t: gen_movdi_mem;\n-\n-      emit_insn ((*genfunc) (operands[0], operands[1]));\n-      DONE;\n-    }\n-}\")\n-\n-(define_insn \"movdi_push_nomove\"\n-  [(set (match_operand:DI 0 \"push_operand\" \"=<\")\n-\t(match_operand:DI 1 \"general_operand\" \"roiF\"))]\n-  \"!TARGET_MOVE\"\n-  \"* return output_move_double (operands);\")\n-\n-(define_insn \"movdi_push\"\n+(define_insn \"\"\n   [(set (match_operand:DI 0 \"push_operand\" \"=<,<,<,<\")\n \t(match_operand:DI 1 \"general_operand\" \"riF,o,o,o\"))\n    (clobber (match_scratch:SI 2 \"=X,&r,&r,X\"))\n    (clobber (match_scratch:SI 3 \"=X,&r,X,X\"))]\n   \"\"\n   \"*\n {\n-  if (GET_CODE (operands[1]) != MEM\n-      || GET_CODE (operands[2]) != REG)\n+  if (GET_CODE (operands[1]) != MEM)\n     return output_move_double (operands);\n \n   else\n-    {\n-      rtx low[1], high[1], xop[4];\n-\n-      split_di (&operands[1], 1, low, high);\n-      xop[0] = operands[2];\n-      xop[1] = operands[3];\n-      xop[2] = high[0];\n-      xop[3] = low[0];\n-\n-      if (GET_CODE (operands[3]) == REG)\n-\t{\t\t\t/* 2 scratch registers available */\n-\t  output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n-\t  output_asm_insn (AS2 (mov%L0,%3,%1), xop);\n-\t  output_asm_insn (AS1 (push%L0,%0), xop);\n-\t  output_asm_insn (AS1 (push%L0,%1), xop);\n-\t}\n-      else\n-\t{\t\t\t/* 1 scratch register */\n-\t  output_asm_insn (AS2 (mov%L0,%2,%0), xop);\n-\t  output_asm_insn (AS1 (push%L0,%0), xop);\n-\n-\t\t\t\t/* account for push above */\n-\t  if (reg_mentioned_p (stack_pointer_rtx, XEXP (xop[3], 0)))\n-\t    xop[3] = adj_offsettable_operand (xop[3], 4);\n-\n-\t  output_asm_insn (AS2 (mov%L0,%3,%0), xop);\n-\t  output_asm_insn (AS1 (push%L0,%0), xop);\n-\t}\n-\n-      RET;\n-    }\n+    return output_move_pushmem (operands, insn, GET_MODE_SIZE (DImode), 2, 4);\n }\")\n \n-(define_insn \"movdi_mem\"\n-  [(set (match_operand:DI 0 \"memory_operand\" \"=o,o\")\n-\t(match_operand:DI 1 \"memory_operand\" \"o,o\"))\n-   (clobber (match_scratch:SI 2 \"=&r,&r\"))\n-   (clobber (match_scratch:SI 3 \"=&r,X\"))]\n+(define_insn \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"=o,o,r,rm\")\n+\t(match_operand:DI 1 \"general_operand\" \"o,o,m,riF\"))\n+   (clobber (match_scratch:SI 2 \"=&r,&r,X,X\"))\n+   (clobber (match_scratch:SI 3 \"=&r,X,X,X\"))]\n   \"\"\n   \"*\n {\n   rtx low[2], high[2], xop[6];\n \n-  split_di (operands, 2, low, high);\n-  xop[0] = operands[2];\n-  xop[1] = operands[3];\n-  xop[2] = high[0];\n-  xop[3] = high[1];\n-  xop[4] = low[0];\n-  xop[5] = low[1];\n-  if (GET_CODE (operands[3]) == REG)\n-    {\t\t\t\t/* 2 scratch registers available */\n-      output_asm_insn (AS2 (mov%L0,%5,%0), xop);\n-      output_asm_insn (AS2 (mov%L0,%3,%1), xop);\n-      output_asm_insn (AS2 (mov%L0,%0,%4), xop);\n-      output_asm_insn (AS2 (mov%L0,%1,%2), xop);\n-    }\n+  if (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n+    return output_move_double (operands);\n   else\n-    {\t\t\t\t/* 1 scratch register */\n-      output_asm_insn (AS2 (mov%L0,%5,%0), xop);\n-      output_asm_insn (AS2 (mov%L0,%0,%4), xop);\n-      output_asm_insn (AS2 (mov%L0,%3,%0), xop);\n-      output_asm_insn (AS2 (mov%L0,%0,%2), xop);\n-    }\n-\n-  RET;\n+    return output_move_memory (operands, insn, GET_MODE_SIZE (DImode), 2, 4);\n }\")\n \n-(define_insn \"movdi_normal\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=r,rm\")\n-\t(match_operand:DI 1 \"general_operand\" \"m,riF\"))]\n-  \"(!TARGET_MOVE || GET_CODE (operands[0]) != MEM) || (GET_CODE (operands[1]) != MEM)\"\n-  \"* return output_move_double (operands);\")\n-\n \f\n ;;- conversion instructions\n ;;- NONE\n@@ -5296,126 +5083,42 @@\n   \"!HALF_PIC_P ()\"\n   \"call %P1\")\n \n+;; Call subroutine returning any type.\n+\n (define_expand \"untyped_call\"\n-  [(parallel [(call (match_operand:QI 0 \"indirect_operand\" \"\")\n+  [(parallel [(call (match_operand 0 \"\" \"\")\n \t\t    (const_int 0))\n-\t      (match_operand:BLK 1 \"memory_operand\" \"\")\n+\t      (match_operand 1 \"\" \"\")\n \t      (match_operand 2 \"\" \"\")])]\n   \"\"\n   \"\n {\n-  rtx addr;\n+  int i;\n \n-  if (flag_pic)\n-    current_function_uses_pic_offset_table = 1;\n-\n-  /* With half-pic, force the address into a register.  */\n-  addr = XEXP (operands[0], 0);\n-  if (GET_CODE (addr) != REG && HALF_PIC_P () && !CONSTANT_ADDRESS_P (addr))\n-    XEXP (operands[0], 0) = force_reg (Pmode, addr);\n-\n-  operands[1] = change_address (operands[1], DImode, XEXP (operands[1], 0));\n-  if (! expander_call_insn_operand (operands[1], QImode))\n-    operands[1]\n-      = change_address (operands[1], VOIDmode,\n-\t\t\tcopy_to_mode_reg (Pmode, XEXP (operands[1], 0)));\n-}\")\n+  emit_call_insn (gen_call (operands[0], const0_rtx, NULL, const0_rtx));\n \n-(define_insn \"\"\n-  [(call (match_operand:QI 0 \"call_insn_operand\" \"m\")\n-\t (const_int 0))\n-   (match_operand:DI 1 \"memory_operand\" \"o\")\n-   (match_operand 2 \"\" \"\")]\n-  \"\"\n-  \"*\n-{\n-  rtx addr = operands[1];\n-\n-  if (GET_CODE (operands[0]) == MEM\n-      && ! CONSTANT_ADDRESS_P (XEXP (operands[0], 0)))\n+  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n     {\n-      operands[0] = XEXP (operands[0], 0);\n-      output_asm_insn (AS1 (call,%*%0), operands);\n+      rtx set = XVECEXP (operands[2], 0, i);\n+      emit_move_insn (SET_DEST (set), SET_SRC (set));\n     }\n-  else\n-    output_asm_insn (AS1 (call,%P0), operands);\n-\n-  operands[2] = gen_rtx (REG, SImode, 0);\n-  output_asm_insn (AS2 (mov%L2,%2,%1), operands);\n-\n-  operands[2] = gen_rtx (REG, SImode, 1);\n-  operands[1] = adj_offsettable_operand (addr, 4);\n-  output_asm_insn (AS2 (mov%L2,%2,%1), operands);\n-\n-  operands[1] = adj_offsettable_operand (addr, 8);\n-  return AS1 (fnsave,%1);\n-}\")\n-\n-(define_insn \"\"\n-  [(call (mem:QI (match_operand:SI 0 \"symbolic_operand\" \"\"))\n-\t (const_int 0))\n-   (match_operand:DI 1 \"memory_operand\" \"o\")\n-   (match_operand 2 \"\" \"\")]\n-  \"!HALF_PIC_P ()\"\n-  \"*\n-{\n-  rtx addr = operands[1];\n-\n-  output_asm_insn (AS1 (call,%P0), operands);\n-\n-  operands[2] = gen_rtx (REG, SImode, 0);\n-  output_asm_insn (AS2 (mov%L2,%2,%1), operands);\n-\n-  operands[2] = gen_rtx (REG, SImode, 1);\n-  operands[1] = adj_offsettable_operand (addr, 4);\n-  output_asm_insn (AS2 (mov%L2,%2,%1), operands);\n-\n-  operands[1] = adj_offsettable_operand (addr, 8);\n-  return AS1 (fnsave,%1);\n-}\")\n-\n-;; We use fnsave and frstor to save and restore the floating point result.\n-;; These are expensive instructions and require a large space to save the\n-;; FPU state.  An more complicated alternative is to use fnstenv to store\n-;; the FPU environment and test whether the stack top is valid.  Store the\n-;; result of the test, and if it is valid, pop and save the value.  The\n-;; untyped_return would check the test and optionally push the saved value.\n-\n-(define_expand \"untyped_return\"\n-  [(match_operand:BLK 0 \"memory_operand\" \"\")\n-   (match_operand 1 \"\" \"\")]\n-  \"\"\n-  \"\n-{\n-  rtx valreg1 = gen_rtx (REG, SImode, 0);\n-  rtx valreg2 = gen_rtx (REG, SImode, 1);\n-  rtx result = operands[0];\n-\n-  /* Restore the FPU state.  */\n-  emit_insn (gen_update_return (change_address (result, SImode,\n-\t\t\t\t\t\tplus_constant (XEXP (result, 0),\n-\t\t\t\t\t\t\t       8))));\n \n-  /* Reload the function value registers.  */\n-  emit_move_insn (valreg1, change_address (result, SImode, XEXP (result, 0)));\n-  emit_move_insn (valreg2,\n-\t\t  change_address (result, SImode,\n-\t\t\t\t  plus_constant (XEXP (result, 0), 4)));\n-\n-  /* Put USE insns before the return.  */\n-  emit_insn (gen_rtx (USE, VOIDmode, valreg1));\n-  emit_insn (gen_rtx (USE, VOIDmode, valreg2));\n-\n-  /* Construct the return.  */\n-  expand_null_return ();\n+  /* The optimizer does not know that the call sets the function value\n+     registers we stored in the result block.  We avoid problems by\n+     claiming that all hard registers are used and clobbered at this\n+     point.  */\n+  emit_insn (gen_blockage ());\n \n   DONE;\n }\")\n \n-(define_insn \"update_return\"\n-  [(unspec:SI [(match_operand:SI 0 \"memory_operand\" \"m\")] 0)]\n+;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n+;; all of memory.  This blocks insns from being moved across this point.\n+\n+(define_insn \"blockage\"\n+  [(unspec_volatile [(const_int 0)] 0)]\n   \"\"\n-  \"frstor %0\")\n+  \"\")\n \n ;; Insn emitted into the body of a function to return from a function.\n ;; This is only done if the function's epilogue is known to be simple."}, {"sha": "818548578987272424f972ad74cea6694658293c", "filename": "gcc/objc/sendmsg.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b840bfb0a22793c3794793a6e4817f9fb7b8e03a/gcc%2Fobjc%2Fsendmsg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b840bfb0a22793c3794793a6e4817f9fb7b8e03a/gcc%2Fobjc%2Fsendmsg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fsendmsg.c?ref=b840bfb0a22793c3794793a6e4817f9fb7b8e03a", "patch": "@@ -68,9 +68,7 @@ nil_method(id receiver, SEL op, ...)\n }\n \n /* Given a class and selector, return the selector's implementation.  */\n-#ifndef i386\n-__inline__ /* this is broken on i386... */\n-#endif\n+__inline__\n IMP\n get_imp (Class* class, SEL sel)\n {"}]}