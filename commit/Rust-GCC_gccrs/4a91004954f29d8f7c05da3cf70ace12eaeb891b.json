{"sha": "4a91004954f29d8f7c05da3cf70ace12eaeb891b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE5MTAwNDk1NGYyOWQ4ZjdjMDVkYTNjZjcwYWNlMTJlYWViODkxYg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2014-11-18T16:09:11Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2014-11-18T16:09:11Z"}, "message": "New template fibonacci_heap class introduced.\n\n\t* fibonacci_heap.h: New file.\n\t(fibonacci_heap::insert): Created from fibheap_insert.\n\t(fibonacci_heap::empty): Created from fibheap_empty.\n\t(fibonacci_heap::nodes): Created from fibheap_nodes.\n\t(fibonacci_heap::min_key): Created from fibheap_min_key.\n\t(fibonacci_heap::decrease_key): Created from fibheap_replace_key.\n\t(fibonacci_heap::replace_key_data): Created from fibheap_replace_key_data.\n\t(fibonacci_heap::extract_min): Created from fibheap_extract_min.\n\t(fibonacci_heap::min): Created from fibheap_min.\n\t(fibonacci_heap::replace_data): Created from fibheap_replace_data.\n\t(fibonacci_heap::delete_node): Created from fibheap_delete_node.\n\t(fibonacci_heap::union_with): Created from fibheap_union.\n\t* ipa-inline.c (update_edge_key): New heap API is used.\n\t(update_caller_keys): Likewise.\n\t(update_callee_keys): Likewise.\n\t(lookup_recursive_calls): Likewise.\n\t(recursive_inlining): Likewise.\n\t(add_new_edges_to_heap): Likewise.\n\t(heap_edge_removal_hook): Likewise.\n\t(inline_small_functions): Likewise.\n\nFrom-SVN: r217720", "tree": {"sha": "decc7bbcfc96f5291df49c1f55054531f4b5a6a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/decc7bbcfc96f5291df49c1f55054531f4b5a6a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a91004954f29d8f7c05da3cf70ace12eaeb891b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a91004954f29d8f7c05da3cf70ace12eaeb891b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a91004954f29d8f7c05da3cf70ace12eaeb891b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a91004954f29d8f7c05da3cf70ace12eaeb891b/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1b85e4b23b4a6dfbdb05c3a24ccb2e271d014981", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b85e4b23b4a6dfbdb05c3a24ccb2e271d014981", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b85e4b23b4a6dfbdb05c3a24ccb2e271d014981"}], "stats": {"total": 738, "additions": 682, "deletions": 56}, "files": [{"sha": "9c5f5fccacea08b6fe9f4b6799efee5e7fa15c14", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a91004954f29d8f7c05da3cf70ace12eaeb891b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a91004954f29d8f7c05da3cf70ace12eaeb891b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a91004954f29d8f7c05da3cf70ace12eaeb891b", "patch": "@@ -1,3 +1,26 @@\n+2014-11-18  Martin Liska  <mliska@suse.cz>\n+\n+\t* fibonacci_heap.h: New file.\n+\t(fibonacci_heap::insert): Created from fibheap_insert.\n+\t(fibonacci_heap::empty): Created from fibheap_empty.\n+\t(fibonacci_heap::nodes): Created from fibheap_nodes.\n+\t(fibonacci_heap::min_key): Created from fibheap_min_key.\n+\t(fibonacci_heap::decrease_key): Created from fibheap_replace_key.\n+\t(fibonacci_heap::replace_key_data): Created from fibheap_replace_key_data.\n+\t(fibonacci_heap::extract_min): Created from fibheap_extract_min.\n+\t(fibonacci_heap::min): Created from fibheap_min.\n+\t(fibonacci_heap::replace_data): Created from fibheap_replace_data.\n+\t(fibonacci_heap::delete_node): Created from fibheap_delete_node.\n+\t(fibonacci_heap::union_with): Created from fibheap_union.\n+\t* ipa-inline.c (update_edge_key): New heap API is used.\n+\t(update_caller_keys): Likewise.\n+\t(update_callee_keys): Likewise.\n+\t(lookup_recursive_calls): Likewise.\n+\t(recursive_inlining): Likewise.\n+\t(add_new_edges_to_heap): Likewise.\n+\t(heap_edge_removal_hook): Likewise.\n+\t(inline_small_functions): Likewise.\n+\n 2014-11-18  Marek Polacek  <polacek@redhat.com>\n \n \tPR sanitizer/63866"}, {"sha": "ecb92f8b01f2e93551d461eee4fb1ef2a983e964", "filename": "gcc/fibonacci_heap.h", "status": "added", "additions": 608, "deletions": 0, "changes": 608, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a91004954f29d8f7c05da3cf70ace12eaeb891b/gcc%2Ffibonacci_heap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a91004954f29d8f7c05da3cf70ace12eaeb891b/gcc%2Ffibonacci_heap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffibonacci_heap.h?ref=4a91004954f29d8f7c05da3cf70ace12eaeb891b", "patch": "@@ -0,0 +1,608 @@\n+/* Vector API for GNU compiler.\n+   Copyright (C) 1998-2014 Free Software Foundation, Inc.\n+   Contributed by Daniel Berlin (dan@cgsoftware.com).\n+   Re-implemented in C++ by Martin Liska <mliska@suse.cz>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Fibonacci heaps are somewhat complex, but, there's an article in\n+   DDJ that explains them pretty well:\n+\n+   http://www.ddj.com/articles/1997/9701/9701o/9701o.htm?topic=algoritms\n+\n+   Introduction to algorithms by Corman and Rivest also goes over them.\n+\n+   The original paper that introduced them is \"Fibonacci heaps and their\n+   uses in improved network optimization algorithms\" by Tarjan and\n+   Fredman (JACM 34(3), July 1987).\n+\n+   Amortized and real worst case time for operations:\n+\n+   ExtractMin: O(lg n) amortized. O(n) worst case.\n+   DecreaseKey: O(1) amortized.  O(lg n) worst case.\n+   Insert: O(1) amortized.\n+   Union: O(1) amortized.  */\n+\n+#ifndef GCC_FIBONACCI_HEAP_H\n+#define GCC_FIBONACCI_HEAP_H\n+\n+/* Forward definition.  */\n+\n+template<class K, class V>\n+class fibonacci_heap;\n+\n+/* Fibonacci heap node class.  */\n+\n+template<class K, class V>\n+class fibonacci_node\n+{\n+  typedef fibonacci_node<K,V> fibonacci_node_t;\n+  friend class fibonacci_heap<K,V>;\n+\n+public:\n+  /* Default constructor.  */\n+  fibonacci_node (): m_parent (NULL), m_child (NULL), m_left (this),\n+    m_right (this), m_degree (0), m_mark (0)\n+  {\n+  }\n+\n+  /* Constructor for a node with given KEY.  */\n+  fibonacci_node (K key): m_parent (NULL), m_child (NULL), m_left (this),\n+    m_right (this), m_key (key),\n+    m_degree (0), m_mark (0)\n+  {\n+  }\n+\n+  /* Compare fibonacci node with OTHER node.  */\n+  int compare (fibonacci_node_t *other)\n+  {\n+    if (m_key < other->m_key)\n+      return -1;\n+    if (m_key > other->m_key)\n+      return 1;\n+    return 0;\n+  }\n+\n+  /* Compare the node with a given KEY.  */\n+  int compare_data (K key)\n+  {\n+    return fibonacci_node_t (key).compare (this);\n+  }\n+\n+  /* Remove fibonacci heap node.  */\n+  fibonacci_node_t *remove ();\n+\n+  /* Link the node with PARENT.  */\n+  void link (fibonacci_node_t *parent);\n+\n+  /* Return key associated with the node.  */\n+  K get_key ()\n+  {\n+    return m_key;\n+  }\n+\n+  /* Return data associated with the node.  */\n+  V *get_data ()\n+  {\n+    return m_data;\n+  }\n+\n+private:\n+  /* Put node B after this node.  */\n+  void insert_after (fibonacci_node_t *b);\n+\n+  /* Insert fibonacci node B after this node.  */\n+  void insert_before (fibonacci_node_t *b)\n+  {\n+    m_left->insert_after (b);\n+  }\n+\n+  /* Parent node.  */\n+  fibonacci_node *m_parent;\n+  /* Child node.  */\n+  fibonacci_node *m_child;\n+  /* Left sibling.  */\n+  fibonacci_node *m_left;\n+  /* Right node.  */\n+  fibonacci_node *m_right;\n+  /* Key associated with node.  */\n+  K m_key;\n+  /* Data associated with node.  */\n+  V *m_data;\n+\n+#if defined (__GNUC__) && (!defined (SIZEOF_INT) || SIZEOF_INT < 4)\n+  /* Degree of the node.  */\n+  __extension__ unsigned long int m_degree : 31;\n+  /* Mark of the node.  */\n+  __extension__ unsigned long int m_mark : 1;\n+#else\n+  /* Degree of the node.  */\n+  unsigned int m_degree : 31;\n+  /* Mark of the node.  */\n+  unsigned int m_mark : 1;\n+#endif\n+};\n+\n+/* Fibonacci heap class. */\n+template<class K, class V>\n+class fibonacci_heap\n+{\n+  typedef fibonacci_node<K,V> fibonacci_node_t;\n+  friend class fibonacci_node<K,V>;\n+\n+public:\n+  /* Default constructor.  */\n+  fibonacci_heap (K global_min_key): m_nodes (0), m_min (NULL), m_root (NULL),\n+    m_global_min_key (global_min_key)\n+  {\n+  }\n+\n+  /* Destructor.  */\n+  ~fibonacci_heap ()\n+  {\n+    while (m_min != NULL)\n+      delete (extract_minimum_node ());\n+  }\n+\n+  /* Insert new node given by KEY and DATA associated with the key.  */\n+  fibonacci_node_t *insert (K key, V *data);\n+\n+  /* Return true if no entry is present.  */\n+  bool empty ()\n+  {\n+    return m_nodes == 0;\n+  }\n+\n+  /* Return the number of nodes.  */\n+  size_t nodes ()\n+  {\n+    return m_nodes;\n+  }\n+\n+  /* Return minimal key presented in the heap.  */\n+  K min_key ()\n+  {\n+    if (m_min == NULL)\n+      gcc_unreachable ();\n+\n+    return m_min->m_key;\n+  }\n+\n+  /* For given NODE, set new KEY value.  */\n+  K decrease_key (fibonacci_node_t *node, K key)\n+  {\n+    K okey = node->m_key;\n+    gcc_assert (key <= okey);\n+\n+    replace_key_data (node, key, node->m_data);\n+    return okey;\n+  }\n+\n+  /* For given NODE, set new KEY and DATA value.  */\n+  V *replace_key_data (fibonacci_node_t *node, K key, V *data);\n+\n+  /* Extract minimum node in the heap. */\n+  V *extract_min ();\n+\n+  /* Return value associated with minimum node in the heap.  */\n+  V *min ()\n+  {\n+    if (m_min == NULL)\n+      return NULL;\n+\n+    return m_min->data;\n+  }\n+\n+  /* Replace data associated with NODE and replace it with DATA.  */\n+  V *replace_data (fibonacci_node_t *node, V *data)\n+  {\n+    return replace_key_data (node, node->m_key, data);\n+  }\n+\n+  /* Delete NODE in the heap.  */\n+  V *delete_node (fibonacci_node_t *node);\n+\n+  /* Union the heap with HEAPB.  */\n+  fibonacci_heap *union_with (fibonacci_heap *heapb);\n+\n+private:\n+  /* Insert it into the root list.  */\n+  void insert_root (fibonacci_node_t *node);\n+\n+  /* Remove NODE from PARENT's child list.  */\n+  void cut (fibonacci_node_t *node, fibonacci_node_t *parent);\n+\n+  /* Process cut of node Y and do it recursivelly.  */\n+  void cascading_cut (fibonacci_node_t *y);\n+\n+  /* Extract minimum node from the heap.  */\n+  fibonacci_node_t * extract_minimum_node ();\n+\n+  /* Remove root NODE from the heap.  */\n+  void remove_root (fibonacci_node_t *node);\n+\n+  /* Consolidate heap.  */\n+  void consolidate ();\n+\n+  /* Number of nodes.  */\n+  size_t m_nodes;\n+  /* Minimum node of the heap.  */\n+  fibonacci_node_t *m_min;\n+  /* Root node of the heap.  */\n+  fibonacci_node_t *m_root;\n+  /* Global minimum given in the heap construction.  */\n+  K m_global_min_key;\n+};\n+\n+/* Remove fibonacci heap node.  */\n+\n+template<class K, class V>\n+fibonacci_node<K,V> *\n+fibonacci_node<K,V>::remove ()\n+{\n+  fibonacci_node<K,V> *ret;\n+\n+  if (this == m_left)\n+    ret = NULL;\n+  else\n+    ret = m_left;\n+\n+  if (m_parent != NULL && m_parent->m_child == this)\n+    m_parent->m_child = ret;\n+\n+  m_right->m_left = m_left;\n+  m_left->m_right = m_right;\n+\n+  m_parent = NULL;\n+  m_left = this;\n+  m_right = this;\n+\n+  return ret;\n+}\n+\n+/* Link the node with PARENT.  */\n+\n+template<class K, class V>\n+void\n+fibonacci_node<K,V>::link (fibonacci_node<K,V> *parent)\n+{\n+  if (parent->m_child == NULL)\n+    parent->m_child = this;\n+  else\n+    parent->m_child->insert_before (this);\n+  m_parent = parent;\n+  parent->m_degree++;\n+  m_mark = 0;\n+}\n+\n+/* Put node B after this node.  */\n+\n+template<class K, class V>\n+void\n+fibonacci_node<K,V>::insert_after (fibonacci_node<K,V> *b)\n+{\n+  fibonacci_node<K,V> *a = this;\n+\n+  if (a == a->m_right)\n+    {\n+      a->m_right = b;\n+      a->m_left = b;\n+      b->m_right = a;\n+      b->m_left = a;\n+    }\n+  else\n+    {\n+      b->m_right = a->m_right;\n+      a->m_right->m_left = b;\n+      a->m_right = b;\n+      b->m_left = a;\n+    }\n+}\n+\n+/* Insert new node given by KEY and DATA associated with the key.  */\n+\n+template<class K, class V>\n+fibonacci_node<K,V>*\n+fibonacci_heap<K,V>::insert (K key, V *data)\n+{\n+  /* Create the new node.  */\n+  fibonacci_node<K,V> *node = new fibonacci_node_t ();\n+\n+  /* Set the node's data.  */\n+  node->m_data = data;\n+  node->m_key = key;\n+\n+  /* Insert it into the root list.  */\n+  insert_root (node);\n+\n+  /* If their was no minimum, or this key is less than the min,\n+     it's the new min.  */\n+  if (m_min == NULL || node->m_key < m_min->m_key)\n+    m_min = node;\n+\n+  m_nodes++;\n+\n+  return node;\n+}\n+\n+/* For given NODE, set new KEY and DATA value.  */\n+template<class K, class V>\n+V*\n+fibonacci_heap<K,V>::replace_key_data (fibonacci_node<K,V> *node, K key,\n+\t\t\t\t       V *data)\n+{\n+  V *odata;\n+  K okey;\n+  fibonacci_node<K,V> *y;\n+\n+  /* If we wanted to, we could actually do a real increase by redeleting and\n+     inserting. However, this would require O (log n) time. So just bail out\n+     for now.  */\n+  if (node->compare_data (key) > 0)\n+    return NULL;\n+\n+  odata = node->m_data;\n+  okey = node->m_key;\n+  node->m_data = data;\n+  node->m_key = key;\n+  y = node->m_parent;\n+\n+  /* Short-circuit if the key is the same, as we then don't have to\n+     do anything.  Except if we're trying to force the new node to\n+     be the new minimum for delete.  */\n+  if (okey == key && okey != m_global_min_key)\n+    return odata;\n+\n+  /* These two compares are specifically <= 0 to make sure that in the case\n+     of equality, a node we replaced the data on, becomes the new min.  This\n+     is needed so that delete's call to extractmin gets the right node.  */\n+  if (y != NULL && node->compare (y) <= 0)\n+    {\n+      cut (node, y);\n+      cascading_cut (y);\n+    }\n+\n+  if (node->compare (m_min) <= 0)\n+    m_min = node;\n+\n+  return odata;\n+}\n+\n+/* Extract minimum node in the heap.  */\n+template<class K, class V>\n+V*\n+fibonacci_heap<K,V>::extract_min ()\n+{\n+  fibonacci_node<K,V> *z;\n+  V *ret = NULL;\n+\n+  /* If we don't have a min set, it means we have no nodes.  */\n+  if (m_min != NULL)\n+    {\n+      /* Otherwise, extract the min node, free the node, and return the\n+       node's data.  */\n+      z = extract_minimum_node ();\n+      ret = z->m_data;\n+      delete (z);\n+    }\n+\n+  return ret;\n+}\n+\n+/* Delete NODE in the heap.  */\n+\n+template<class K, class V>\n+V*\n+fibonacci_heap<K,V>::delete_node (fibonacci_node<K,V> *node)\n+{\n+  V *ret = node->m_data;\n+\n+  /* To perform delete, we just make it the min key, and extract.  */\n+  decrease_key (node, m_global_min_key);\n+  if (node != m_min)\n+    {\n+      fprintf (stderr, \"Can't force minimum on fibheap.\\n\");\n+      abort ();\n+    }\n+  extract_min ();\n+\n+  return ret;\n+}\n+\n+/* Union the heap with HEAPB.  */\n+\n+template<class K, class V>\n+fibonacci_heap<K,V>*\n+fibonacci_heap<K,V>::union_with (fibonacci_heap<K,V> *heapb)\n+{\n+  fibonacci_heap<K,V> *heapa = this;\n+\n+  fibonacci_node<K,V> *a_root, *b_root, *temp;\n+\n+  /* If one of the heaps is empty, the union is just the other heap.  */\n+  if ((a_root = heapa->m_root) == NULL)\n+    {\n+      delete (heapa);\n+      return heapb;\n+    }\n+  if ((b_root = heapb->m_root) == NULL)\n+    {\n+      delete (heapb);\n+      return heapa;\n+    }\n+\n+  /* Merge them to the next nodes on the opposite chain.  */\n+  a_root->m_left->m_right = b_root;\n+  b_root->m_left->m_right = a_root;\n+  temp = a_root->m_left;\n+  a_root->m_left = b_root->m_left;\n+  b_root->m_left = temp;\n+  heapa->m_nodes += heapb->m_nodes;\n+\n+  /* And set the new minimum, if it's changed.  */\n+  if (heapb->min->compare (heapa->min) < 0)\n+    heapa->m_min = heapb->m_min;\n+\n+  delete (heapb);\n+  return heapa;\n+}\n+\n+/* Insert it into the root list.  */\n+\n+template<class K, class V>\n+void\n+fibonacci_heap<K,V>::insert_root (fibonacci_node_t *node)\n+{\n+  /* If the heap is currently empty, the new node becomes the singleton\n+     circular root list.  */\n+  if (m_root == NULL)\n+    {\n+      m_root = node;\n+      node->m_left = node;\n+      node->m_right = node;\n+      return;\n+    }\n+\n+  /* Otherwise, insert it in the circular root list between the root\n+     and it's right node.  */\n+  m_root->insert_after (node);\n+}\n+\n+/* Remove NODE from PARENT's child list.  */\n+\n+template<class K, class V>\n+void\n+fibonacci_heap<K,V>::cut (fibonacci_node<K,V> *node,\n+\t\t\t  fibonacci_node<K,V> *parent)\n+{\n+  node->remove ();\n+  parent->m_degree--;\n+  insert_root (node);\n+  node->m_parent = NULL;\n+  node->m_mark = 0;\n+}\n+\n+/* Process cut of node Y and do it recursivelly.  */\n+\n+template<class K, class V>\n+void\n+fibonacci_heap<K,V>::cascading_cut (fibonacci_node<K,V> *y)\n+{\n+  fibonacci_node<K,V> *z;\n+\n+  while ((z = y->m_parent) != NULL)\n+    {\n+      if (y->m_mark == 0)\n+\t{\n+\t  y->m_mark = 1;\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  cut (y, z);\n+\t  y = z;\n+\t}\n+    }\n+}\n+\n+/* Extract minimum node from the heap.  */\n+template<class K, class V>\n+fibonacci_node<K,V>*\n+fibonacci_heap<K,V>::extract_minimum_node ()\n+{\n+  fibonacci_node<K,V> *ret = m_min;\n+  fibonacci_node<K,V> *x, *y, *orig;\n+\n+  /* Attach the child list of the minimum node to the root list of the heap.\n+     If there is no child list, we don't do squat.  */\n+  for (x = ret->m_child, orig = NULL; x != orig && x != NULL; x = y)\n+    {\n+      if (orig == NULL)\n+\torig = x;\n+      y = x->m_right;\n+      x->m_parent = NULL;\n+      insert_root (x);\n+    }\n+\n+  /* Remove the old root.  */\n+  remove_root (ret);\n+  m_nodes--;\n+\n+  /* If we are left with no nodes, then the min is NULL.  */\n+  if (m_nodes == 0)\n+    m_min = NULL;\n+  else\n+    {\n+      /* Otherwise, consolidate to find new minimum, as well as do the reorg\n+       work that needs to be done.  */\n+      m_min = ret->m_right;\n+      consolidate ();\n+    }\n+\n+  return ret;\n+}\n+\n+/* Remove root NODE from the heap.  */\n+\n+template<class K, class V>\n+void\n+fibonacci_heap<K,V>::remove_root (fibonacci_node<K,V> *node)\n+{\n+  if (node->m_left == node)\n+    m_root = NULL;\n+  else\n+    m_root = node->remove ();\n+}\n+\n+/* Consolidate heap.  */\n+\n+template<class K, class V>\n+void fibonacci_heap<K,V>::consolidate ()\n+{\n+  int D = 1 + 8 * sizeof (long);\n+  auto_vec<fibonacci_node<K,V> *> a (D);\n+  a.safe_grow_cleared (D);\n+  fibonacci_node<K,V> *w, *x, *y;\n+  int i, d;\n+\n+  while ((w = m_root) != NULL)\n+    {\n+      x = w;\n+      remove_root (w);\n+      d = x->m_degree;\n+      while (a[d] != NULL)\n+\t{\n+\t  y = a[d];\n+\t  if (x->compare (y) > 0)\n+\t    std::swap (x, y);\n+\t  y->link (x);\n+\t  a[d] = NULL;\n+\t  d++;\n+\t}\n+      a[d] = x;\n+    }\n+  m_min = NULL;\n+  for (i = 0; i < D; i++)\n+    if (a[i] != NULL)\n+      {\n+\tinsert_root (a[i]);\n+\tif (m_min == NULL || a[i]->compare (m_min) < 0)\n+\t  m_min = a[i];\n+      }\n+}\n+\n+#endif  // GCC_FIBONACCI_HEAP_H"}, {"sha": "ca50ad5268ce7bb1e69ae51b3e59c70b51ec2353", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 51, "deletions": 56, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a91004954f29d8f7c05da3cf70ace12eaeb891b/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a91004954f29d8f7c05da3cf70ace12eaeb891b/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=4a91004954f29d8f7c05da3cf70ace12eaeb891b", "patch": "@@ -102,7 +102,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic.h\"\n #include \"gimple-pretty-print.h\"\n #include \"params.h\"\n-#include \"fibheap.h\"\n #include \"intl.h\"\n #include \"tree-pass.h\"\n #include \"coverage.h\"\n@@ -138,6 +137,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"auto-profile.h\"\n #include \"cilk.h\"\n #include \"builtins.h\"\n+#include \"fibonacci_heap.h\"\n+\n+typedef fibonacci_heap <long, cgraph_edge> edge_heap_t;\n+typedef fibonacci_node <long, cgraph_edge> edge_heap_node_t;\n \n /* Statistics we collect about inlining algorithm.  */\n static int overall_size;\n@@ -1076,19 +1079,19 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \n /* Recompute badness of EDGE and update its key in HEAP if needed.  */\n static inline void\n-update_edge_key (fibheap_t heap, struct cgraph_edge *edge)\n+update_edge_key (edge_heap_t *heap, struct cgraph_edge *edge)\n {\n   int badness = edge_badness (edge, false);\n   if (edge->aux)\n     {\n-      fibnode_t n = (fibnode_t) edge->aux;\n-      gcc_checking_assert (n->data == edge);\n+      edge_heap_node_t *n = (edge_heap_node_t *) edge->aux;\n+      gcc_checking_assert (n->get_data () == edge);\n \n-      /* fibheap_replace_key only decrease the keys.\n+      /* fibonacci_heap::replace_key only decrease the keys.\n \t When we increase the key we do not update heap\n \t and instead re-insert the element once it becomes\n \t a minimum of heap.  */\n-      if (badness < n->key)\n+      if (badness < n->get_key ())\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n@@ -1098,11 +1101,11 @@ update_edge_key (fibheap_t heap, struct cgraph_edge *edge)\n \t\t       edge->caller->order,\n \t\t       xstrdup (edge->callee->name ()),\n \t\t       edge->callee->order,\n-\t\t       (int)n->key,\n+\t\t       (int)n->get_key (),\n \t\t       badness);\n \t    }\n-\t  fibheap_replace_key (heap, n, badness);\n-\t  gcc_checking_assert (n->key == badness);\n+\t  heap->decrease_key (n, badness);\n+\t  gcc_checking_assert (n->get_key () == badness);\n \t}\n     }\n   else\n@@ -1117,7 +1120,7 @@ update_edge_key (fibheap_t heap, struct cgraph_edge *edge)\n \t\t    edge->callee->order,\n \t\t    badness);\n \t }\n-      edge->aux = fibheap_insert (heap, badness, edge);\n+      edge->aux = heap->insert (badness, edge);\n     }\n }\n \n@@ -1180,7 +1183,7 @@ reset_edge_caches (struct cgraph_node *node)\n    it is inlinable. Otherwise check all edges.  */\n \n static void\n-update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n+update_caller_keys (edge_heap_t *heap, struct cgraph_node *node,\n \t\t    bitmap updated_nodes,\n \t\t    struct cgraph_edge *check_inlinablity_for)\n {\n@@ -1211,7 +1214,7 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n \t    else if (edge->aux)\n \t      {\n \t\treport_inline_failed_reason (edge);\n-\t\tfibheap_delete_node (heap, (fibnode_t) edge->aux);\n+\t\theap->delete_node ((edge_heap_node_t *) edge->aux);\n \t\tedge->aux = NULL;\n \t      }\n \t  }\n@@ -1226,7 +1229,7 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n    created edges into heap.  */\n \n static void\n-update_callee_keys (fibheap_t heap, struct cgraph_node *node,\n+update_callee_keys (edge_heap_t *heap, struct cgraph_node *node,\n \t\t    bitmap updated_nodes)\n {\n   struct cgraph_edge *e = node->callees;\n@@ -1255,7 +1258,7 @@ update_callee_keys (fibheap_t heap, struct cgraph_node *node,\n \t    else if (e->aux)\n \t      {\n \t\treport_inline_failed_reason (e);\n-\t\tfibheap_delete_node (heap, (fibnode_t) e->aux);\n+\t\theap->delete_node ((edge_heap_node_t *) e->aux);\n \t\te->aux = NULL;\n \t      }\n \t  }\n@@ -1280,7 +1283,7 @@ update_callee_keys (fibheap_t heap, struct cgraph_node *node,\n \n static void\n lookup_recursive_calls (struct cgraph_node *node, struct cgraph_node *where,\n-\t\t\tfibheap_t heap)\n+\t\t\tedge_heap_t *heap)\n {\n   struct cgraph_edge *e;\n   enum availability avail;\n@@ -1292,10 +1295,9 @@ lookup_recursive_calls (struct cgraph_node *node, struct cgraph_node *where,\n       {\n \t/* When profile feedback is available, prioritize by expected number\n \t   of calls.  */\n-        fibheap_insert (heap,\n-\t\t\t!max_count ? -e->frequency\n-\t\t        : -(e->count / ((max_count + (1<<24) - 1) / (1<<24))),\n-\t\t        e);\n+        heap->insert (!max_count ? -e->frequency\n+\t\t      : -(e->count / ((max_count + (1<<24) - 1) / (1<<24))),\n+\t\t      e);\n       }\n   for (e = where->callees; e; e = e->next_callee)\n     if (!e->inline_failed)\n@@ -1312,7 +1314,7 @@ recursive_inlining (struct cgraph_edge *edge,\n \t\t    vec<cgraph_edge *> *new_edges)\n {\n   int limit = PARAM_VALUE (PARAM_MAX_INLINE_INSNS_RECURSIVE_AUTO);\n-  fibheap_t heap;\n+  edge_heap_t heap (LONG_MIN);\n   struct cgraph_node *node;\n   struct cgraph_edge *e;\n   struct cgraph_node *master_clone = NULL, *next;\n@@ -1329,24 +1331,19 @@ recursive_inlining (struct cgraph_edge *edge,\n   /* Make sure that function is small enough to be considered for inlining.  */\n   if (estimate_size_after_inlining (node, edge)  >= limit)\n     return false;\n-  heap = fibheap_new ();\n-  lookup_recursive_calls (node, node, heap);\n-  if (fibheap_empty (heap))\n-    {\n-      fibheap_delete (heap);\n-      return false;\n-    }\n+  lookup_recursive_calls (node, node, &heap);\n+  if (heap.empty ())\n+    return false;\n \n   if (dump_file)\n     fprintf (dump_file,\n \t     \"  Performing recursive inlining on %s\\n\",\n \t     node->name ());\n \n   /* Do the inlining and update list of recursive call during process.  */\n-  while (!fibheap_empty (heap))\n+  while (!heap.empty ())\n     {\n-      struct cgraph_edge *curr\n-\t= (struct cgraph_edge *) fibheap_extract_min (heap);\n+      struct cgraph_edge *curr = heap.extract_min ();\n       struct cgraph_node *cnode, *dest = curr->callee;\n \n       if (!can_inline_edge_p (curr, true))\n@@ -1408,13 +1405,12 @@ recursive_inlining (struct cgraph_edge *edge,\n \t}\n \n       inline_call (curr, false, new_edges, &overall_size, true);\n-      lookup_recursive_calls (node, curr->callee, heap);\n+      lookup_recursive_calls (node, curr->callee, &heap);\n       n++;\n     }\n \n-  if (!fibheap_empty (heap) && dump_file)\n+  if (!heap.empty () && dump_file)\n     fprintf (dump_file, \"    Recursive inlining growth limit met.\\n\");\n-  fibheap_delete (heap);\n \n   if (!master_clone)\n     return false;\n@@ -1459,7 +1455,7 @@ compute_max_insns (int insns)\n /* Compute badness of all edges in NEW_EDGES and add them to the HEAP.  */\n \n static void\n-add_new_edges_to_heap (fibheap_t heap, vec<cgraph_edge *> new_edges)\n+add_new_edges_to_heap (edge_heap_t *heap, vec<cgraph_edge *> new_edges)\n {\n   while (new_edges.length () > 0)\n     {\n@@ -1469,7 +1465,7 @@ add_new_edges_to_heap (fibheap_t heap, vec<cgraph_edge *> new_edges)\n       if (edge->inline_failed\n \t  && can_inline_edge_p (edge, true)\n \t  && want_inline_small_function_p (edge, true))\n-        edge->aux = fibheap_insert (heap, edge_badness (edge, false), edge);\n+        edge->aux = heap->insert (edge_badness (edge, false), edge);\n     }\n }\n \n@@ -1482,7 +1478,7 @@ heap_edge_removal_hook (struct cgraph_edge *e, void *data)\n     reset_node_growth_cache (e->callee);\n   if (e->aux)\n     {\n-      fibheap_delete_node ((fibheap_t)data, (fibnode_t)e->aux);\n+      ((edge_heap_t *)data)->delete_node ((edge_heap_node_t *)e->aux);\n       e->aux = NULL;\n     }\n }\n@@ -1540,7 +1536,7 @@ speculation_useful_p (struct cgraph_edge *e, bool anticipate_inlining)\n    See if we can remove speculation.  */\n \n static void\n-resolve_noninline_speculation (fibheap_t edge_heap, struct cgraph_edge *edge)\n+resolve_noninline_speculation (edge_heap_t *edge_heap, struct cgraph_edge *edge)\n {\n   if (edge->speculative && !speculation_useful_p (edge, false))\n     {\n@@ -1572,7 +1568,7 @@ inline_small_functions (void)\n {\n   struct cgraph_node *node;\n   struct cgraph_edge *edge;\n-  fibheap_t edge_heap = fibheap_new ();\n+  edge_heap_t edge_heap (LONG_MIN);\n   bitmap updated_nodes = BITMAP_ALLOC (NULL);\n   int min_size, max_size;\n   auto_vec<cgraph_edge *> new_indirect_edges;\n@@ -1583,7 +1579,7 @@ inline_small_functions (void)\n     new_indirect_edges.create (8);\n \n   edge_removal_hook_holder\n-    = symtab->add_edge_removal_hook (&heap_edge_removal_hook, edge_heap);\n+    = symtab->add_edge_removal_hook (&heap_edge_removal_hook, &edge_heap);\n \n   /* Compute overall unit size and other global parameters used by badness\n      metrics.  */\n@@ -1662,7 +1658,7 @@ inline_small_functions (void)\n \t      && edge->inline_failed)\n \t    {\n \t      gcc_assert (!edge->aux);\n-\t      update_edge_key (edge_heap, edge);\n+\t      update_edge_key (&edge_heap, edge);\n \t    }\n \t  if (edge->speculative && !speculation_useful_p (edge, edge->aux != NULL))\n \t    {\n@@ -1677,7 +1673,7 @@ inline_small_functions (void)\n \t  inline_update_overall_summary (where);\n           reset_node_growth_cache (where);\n \t  reset_edge_caches (where);\n-          update_caller_keys (edge_heap, where,\n+          update_caller_keys (&edge_heap, where,\n \t\t\t      updated_nodes, NULL);\n           bitmap_clear (updated_nodes);\n \t}\n@@ -1687,16 +1683,16 @@ inline_small_functions (void)\n \t      || !max_count\n \t      || (profile_info && flag_branch_probabilities));\n \n-  while (!fibheap_empty (edge_heap))\n+  while (!edge_heap.empty ())\n     {\n       int old_size = overall_size;\n       struct cgraph_node *where, *callee;\n-      int badness = fibheap_min_key (edge_heap);\n+      int badness = edge_heap.min_key ();\n       int current_badness;\n       int cached_badness;\n       int growth;\n \n-      edge = (struct cgraph_edge *) fibheap_extract_min (edge_heap);\n+      edge = edge_heap.extract_min ();\n       gcc_assert (edge->aux);\n       edge->aux = NULL;\n       if (!edge->inline_failed || !edge->callee->analyzed)\n@@ -1717,13 +1713,13 @@ inline_small_functions (void)\n       gcc_assert (current_badness >= badness);\n       if (current_badness != badness)\n \t{\n-\t  edge->aux = fibheap_insert (edge_heap, current_badness, edge);\n+\t  edge->aux = edge_heap.insert (current_badness, edge);\n \t  continue;\n \t}\n \n       if (!can_inline_edge_p (edge, true))\n \t{\n-\t  resolve_noninline_speculation (edge_heap, edge);\n+\t  resolve_noninline_speculation (&edge_heap, edge);\n \t  continue;\n \t}\n       \n@@ -1757,13 +1753,13 @@ inline_small_functions (void)\n \t{\n \t  edge->inline_failed = CIF_INLINE_UNIT_GROWTH_LIMIT;\n \t  report_inline_failed_reason (edge);\n-\t  resolve_noninline_speculation (edge_heap, edge);\n+\t  resolve_noninline_speculation (&edge_heap, edge);\n \t  continue;\n \t}\n \n       if (!want_inline_small_function_p (edge, true))\n \t{\n-\t  resolve_noninline_speculation (edge_heap, edge);\n+\t  resolve_noninline_speculation (&edge_heap, edge);\n \t  continue;\n \t}\n \n@@ -1781,15 +1777,15 @@ inline_small_functions (void)\n \t\t\t\t   ? &new_indirect_edges : NULL))\n \t    {\n \t      edge->inline_failed = CIF_RECURSIVE_INLINING;\n-\t      resolve_noninline_speculation (edge_heap, edge);\n+\t      resolve_noninline_speculation (&edge_heap, edge);\n \t      continue;\n \t    }\n \t  reset_edge_caches (where);\n \t  /* Recursive inliner inlines all recursive calls of the function\n \t     at once. Consequently we need to update all callee keys.  */\n \t  if (flag_indirect_inlining)\n-\t    add_new_edges_to_heap (edge_heap, new_indirect_edges);\n-          update_callee_keys (edge_heap, where, updated_nodes);\n+\t    add_new_edges_to_heap (&edge_heap, new_indirect_edges);\n+          update_callee_keys (&edge_heap, where, updated_nodes);\n \t  bitmap_clear (updated_nodes);\n \t}\n       else\n@@ -1817,7 +1813,7 @@ inline_small_functions (void)\n \t      edge->inline_failed\n \t\t= (DECL_DISREGARD_INLINE_LIMITS (edge->callee->decl)\n \t\t   ? CIF_RECURSIVE_INLINING : CIF_UNSPECIFIED);\n-\t      resolve_noninline_speculation (edge_heap, edge);\n+\t      resolve_noninline_speculation (&edge_heap, edge);\n \t      continue;\n \t    }\n \t  else if (depth && dump_file)\n@@ -1826,12 +1822,12 @@ inline_small_functions (void)\n \t  gcc_checking_assert (!callee->global.inlined_to);\n \t  inline_call (edge, true, &new_indirect_edges, &overall_size, true);\n \t  if (flag_indirect_inlining)\n-\t    add_new_edges_to_heap (edge_heap, new_indirect_edges);\n+\t    add_new_edges_to_heap (&edge_heap, new_indirect_edges);\n \n \t  reset_edge_caches (edge->callee);\n           reset_node_growth_cache (callee);\n \n-\t  update_callee_keys (edge_heap, where, updated_nodes);\n+\t  update_callee_keys (&edge_heap, where, updated_nodes);\n \t}\n       where = edge->caller;\n       if (where->global.inlined_to)\n@@ -1843,7 +1839,7 @@ inline_small_functions (void)\n \t inlined into (since it's body size changed) and for the functions\n \t called by function we inlined (since number of it inlinable callers\n \t might change).  */\n-      update_caller_keys (edge_heap, where, updated_nodes, NULL);\n+      update_caller_keys (&edge_heap, where, updated_nodes, NULL);\n       bitmap_clear (updated_nodes);\n \n       if (dump_file)\n@@ -1867,7 +1863,6 @@ inline_small_functions (void)\n     }\n \n   free_growth_caches ();\n-  fibheap_delete (edge_heap);\n   if (dump_file)\n     fprintf (dump_file,\n \t     \"Unit growth for small function inlining: %i->%i (%i%%)\\n\","}]}