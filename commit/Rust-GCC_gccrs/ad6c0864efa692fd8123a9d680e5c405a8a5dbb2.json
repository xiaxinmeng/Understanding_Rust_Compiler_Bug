{"sha": "ad6c0864efa692fd8123a9d680e5c405a8a5dbb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQ2YzA4NjRlZmE2OTJmZDgxMjNhOWQ2ODBlNWM0MDVhOGE1ZGJiMg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2009-05-08T22:38:49Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2009-05-08T22:38:49Z"}, "message": "Fix PR 40049\n\nFrom-SVN: r147298", "tree": {"sha": "0af10d3c32a433a02b46a4025e3c6673a396c80e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0af10d3c32a433a02b46a4025e3c6673a396c80e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad6c0864efa692fd8123a9d680e5c405a8a5dbb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad6c0864efa692fd8123a9d680e5c405a8a5dbb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad6c0864efa692fd8123a9d680e5c405a8a5dbb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad6c0864efa692fd8123a9d680e5c405a8a5dbb2/comments", "author": null, "committer": null, "parents": [{"sha": "c94f9067af215b26b634b6c9678297aa92d74fc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c94f9067af215b26b634b6c9678297aa92d74fc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c94f9067af215b26b634b6c9678297aa92d74fc7"}], "stats": {"total": 217, "additions": 214, "deletions": 3}, "files": [{"sha": "83b14c34bf93e5444edb892dd853c2dbabd923f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad6c0864efa692fd8123a9d680e5c405a8a5dbb2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad6c0864efa692fd8123a9d680e5c405a8a5dbb2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad6c0864efa692fd8123a9d680e5c405a8a5dbb2", "patch": "@@ -1,3 +1,11 @@\n+2009-05-07  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR tree-optimization/40049\n+\t* tree-vect-stmts.c (vectorizable_operation): If the machine has\n+\tonly vector/vector shifts, convert the type of the constant to the\n+\tappropriate type to avoid building incorrect trees, which\n+\teventually have problems with garbage collection.\n+\n 2009-05-08  Joseph Myers  <joseph@codesourcery.com>\n \n \t* fold-const.c (fold_binary): Do not fold multiplication by 1 or"}, {"sha": "3099e1bded678453a70408e4a6ec7bca8642708a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad6c0864efa692fd8123a9d680e5c405a8a5dbb2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad6c0864efa692fd8123a9d680e5c405a8a5dbb2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ad6c0864efa692fd8123a9d680e5c405a8a5dbb2", "patch": "@@ -1,3 +1,8 @@\n+2009-05-08  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR tree-optimization/40049\n+\t* gcc.dg/vect/vect-shift-2.c: New test.\n+\n 2009-05-08  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gcc.dg/torture/complex-sign-mul-minus-one.c,"}, {"sha": "ea41c998db1e1616b94b31784ae65d0813701170", "filename": "gcc/testsuite/gcc.dg/vect/vect-shift-2.c", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad6c0864efa692fd8123a9d680e5c405a8a5dbb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-shift-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad6c0864efa692fd8123a9d680e5c405a8a5dbb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-shift-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-shift-2.c?ref=ad6c0864efa692fd8123a9d680e5c405a8a5dbb2", "patch": "@@ -0,0 +1,189 @@\n+/* { dg-require-effective-target vect_shift } */\n+/* { dg-require-effective-target vect_int } */\n+/* Check the standard integer types for left and right shifts to see if the\n+   compiler replaced a scalar instruction with a vector instruction whether the\n+   correct value is generated.  */\n+\n+#ifdef TRACE\n+#include <stdio.h>\n+#endif\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#ifndef ALIGN\n+#define ALIGN __attribute__((__aligned__(32)))\n+#endif\n+\n+#ifndef NOINLINE\n+#define NOINLINE __attribute__((__noinline__))\n+#endif\n+\n+#ifdef TRACE\n+#define TRACE_FUNC(PREFIX, NAME) printf (#PREFIX #NAME \"\\n\")\n+#define TRACE_DONE()  printf (\"done!\\n\")\n+#define TRACE_ABORT(I,E,G)\t\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  printf (\"Element %d, expected 0x%lx, got 0x%lx\\n\",\t\t\t\\\n+\t  I, (long)(E), (long)(G));\t\t\t\t\t\\\n+  abort ();\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+#else\n+#define TRACE_FUNC(PREFIX, A)\n+#define TRACE_DONE()\n+#define TRACE_ABORT(I,E,G) abort ()\n+#endif\n+\n+#define NAME(A,B) A ## B\n+\n+#define VECT_TESTS(PREFIX, TYPE, N)\t\t\t\t\t\\\n+ /* Restrict the optimizer from optimizing the setup loops.  */\t\t\\\n+volatile TYPE NAME (PREFIX, zero) = 0;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+TYPE NAME (PREFIX, a)[N] ALIGN;\t\t\t\t\t\t\\\n+TYPE NAME (PREFIX, b)[N] ALIGN;\t\t\t\t\t\t\\\n+TYPE NAME (PREFIX, c)[N] ALIGN;\t\t\t\t\t\t\\\n+TYPE NAME (PREFIX, d)[N] ALIGN;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+static void NOINLINE\t\t\t\t\t\t\t\\\n+NAME (PREFIX, lshift_2) (void)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  TRACE_FUNC (PREFIX, lshift_2);\t\t\t\t\t\\\n+  for (i = 0; i < N; i++)\t\t\t\t\t\t\\\n+    NAME (PREFIX, a)[i] = NAME (PREFIX, b)[i] << 2;\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+static void NOINLINE\t\t\t\t\t\t\t\\\n+NAME (PREFIX, lshift_var) (int shift)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  TRACE_FUNC (PREFIX, lshift_var);\t\t\t\t\t\\\n+  for (i = 0; i < N; i++)\t\t\t\t\t\t\\\n+    NAME (PREFIX, a)[i] = NAME (PREFIX, b)[i] << shift;\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+static void NOINLINE\t\t\t\t\t\t\t\\\n+NAME (PREFIX, lshift_vect) (void)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  TRACE_FUNC (PREFIX, lshift_vect);\t\t\t\t\t\\\n+  for (i = 0; i < N; i++)\t\t\t\t\t\t\\\n+    NAME (PREFIX, a)[i] = NAME (PREFIX, b)[i] << NAME (PREFIX, c)[i];\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+static void NOINLINE\t\t\t\t\t\t\t\\\n+NAME (PREFIX, rshift_2) (void)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  TRACE_FUNC (PREFIX, rshift_2);\t\t\t\t\t\\\n+  for (i = 0; i < N; i++)\t\t\t\t\t\t\\\n+    NAME (PREFIX, a)[i] = NAME (PREFIX, b)[i] >> 2;\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+static void NOINLINE\t\t\t\t\t\t\t\\\n+NAME (PREFIX, rshift_var) (int shift)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  TRACE_FUNC (PREFIX, rshift_var);\t\t\t\t\t\\\n+  for (i = 0; i < N; i++)\t\t\t\t\t\t\\\n+    NAME (PREFIX, a)[i] = NAME (PREFIX, b)[i] >> shift;\t\t\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+static void NOINLINE\t\t\t\t\t\t\t\\\n+NAME (PREFIX, rshift_vect) (void)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  TRACE_FUNC (PREFIX, rshift_vect);\t\t\t\t\t\\\n+  for (i = 0; i < N; i++)\t\t\t\t\t\t\\\n+    NAME (PREFIX, a)[i] = NAME (PREFIX, b)[i] >> NAME (PREFIX, c)[i];\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+static void NOINLINE\t\t\t\t\t\t\t\\\n+NAME (PREFIX, check) (void)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  TRACE_FUNC (PREFIX, check);\t\t\t\t\t\t\\\n+  for (i = 0; i < N; i++)\t\t\t\t\t\t\\\n+    if (NAME (PREFIX, a)[i] != NAME (PREFIX, d)[i])\t\t\t\\\n+      TRACE_ABORT (i, NAME (PREFIX, d)[i], NAME (PREFIX, a)[i]);\t\\\n+}\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+static void NOINLINE\t\t\t\t\t\t\t\\\n+NAME (PREFIX, tests) (void)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  int i;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  TRACE_FUNC (PREFIX, tests);\t\t\t\t\t\t\\\n+  for (i = 0; i < N; i++)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      NAME (PREFIX, b)[i] = (i + NAME (PREFIX, zero));\t\t\t\\\n+      NAME (PREFIX, c)[i] = 2;\t\t\t\t\t\t\\\n+      NAME (PREFIX, d)[i] = (i + NAME (PREFIX, zero)) << 2;\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  NAME (PREFIX, lshift_2) ();\t\t\t\t\t\t\\\n+  NAME (PREFIX, check) ();\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  NAME (PREFIX, lshift_var) (2);\t\t\t\t\t\\\n+  NAME (PREFIX, check) ();\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  NAME (PREFIX, lshift_vect) ();\t\t\t\t\t\\\n+  NAME (PREFIX, check) ();\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  for (i = 0; i < N; i++)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      NAME (PREFIX, b)[i] = ((i + NAME (PREFIX, zero)) << 4)\t\t\\\n+\t| (((TYPE)0x80) << ((sizeof (TYPE) * 8) - 8));\t\t\t\\\n+      NAME (PREFIX, c)[i] = 2;\t\t\t\t\t\t\\\n+      NAME (PREFIX, d)[i] = (TYPE)((NAME (PREFIX, b)[i]\t\t\t\\\n+\t\t\t\t    + NAME (PREFIX, zero)) >> 2);\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  NAME (PREFIX, rshift_2) ();\t\t\t\t\t\t\\\n+  NAME (PREFIX, check) ();\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  NAME (PREFIX, rshift_var) (2);\t\t\t\t\t\\\n+  NAME (PREFIX, check) ();\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  NAME (PREFIX, rshift_vect) ();\t\t\t\t\t\\\n+  NAME (PREFIX, check) ();\t\t\t\t\t\t\\\n+}\n+\n+VECT_TESTS(uc_, unsigned char,  16)\n+VECT_TESTS(us_, unsigned short, 32)\n+VECT_TESTS(ui_, unsigned int,   32)\n+VECT_TESTS(ul_, unsigned long,  32)\n+\n+VECT_TESTS(sc_, signed char,    16)\n+VECT_TESTS(ss_, short,          32)\n+VECT_TESTS(si_, int,            32)\n+VECT_TESTS(sl_, long,           32)\n+\n+int main ()\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  uc_tests ();\n+  us_tests ();\n+  ui_tests ();\n+  ul_tests ();\n+\n+  sc_tests ();\n+  ss_tests ();\n+  si_tests ();\n+  sl_tests ();\n+\n+  TRACE_DONE ();\n+  return 0;\n+}"}, {"sha": "06d51e2d3180723330b12e6d231558c536a482b0", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad6c0864efa692fd8123a9d680e5c405a8a5dbb2/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad6c0864efa692fd8123a9d680e5c405a8a5dbb2/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=ad6c0864efa692fd8123a9d680e5c405a8a5dbb2", "patch": "@@ -1974,11 +1974,20 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \t  else\n \t    {\n \t      optab = optab_for_tree_code (code, vectype, optab_vector);\n-\t      if (vect_print_dump_info (REPORT_DETAILS)\n-\t\t  && optab\n+\t      if (optab\n \t\t  && (optab_handler (optab, TYPE_MODE (vectype))->insn_code\n \t\t      != CODE_FOR_nothing))\n-\t\tfprintf (vect_dump, \"vector/vector shift/rotate found.\");\n+\t\t{\n+\t\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t\t    fprintf (vect_dump, \"vector/vector shift/rotate found.\");\n+\n+\t\t  /* Unlike the other binary operators, shifts/rotates have\n+\t\t     the rhs being int, instead of the same type as the lhs,\n+\t\t     so make sure the scalar is the right type if we are\n+\t\t     dealing with vectors of short/char.  */\n+\t\t  if (dt[1] == vect_constant_def)\n+\t\t    op1 = fold_convert (TREE_TYPE (vectype), op1);\n+\t\t}\n \t    }\n \t}\n "}]}