{"sha": "58f0ea2f8565b62d2060c2d244cc7d98b5b0a7a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThmMGVhMmY4NTY1YjYyZDIwNjBjMmQyNDRjYzdkOThiNWIwYTdhNQ==", "commit": {"author": {"name": "Andy Hutchinson", "email": "hutchinsonandy@gcc.gnu.org", "date": "2010-01-08T23:01:45Z"}, "committer": {"name": "Andy Hutchinson", "email": "hutchinsonandy@gcc.gnu.org", "date": "2010-01-08T23:01:45Z"}, "message": "re PR target/41885 (AVR Rotate patterns do not correctly consider overlap.)\n\n2010-01-08  Andy Hutchinson  <hutchinsonandy@gcc.gnu.org>\n\n  PR target/41885\n  * avr.md (rotlqi3): Add CONST_INT_P check.\n  (rotlhi3): Delete.\n  (rotlhi3_8): Delete.\n  (rotlsi3): Delete.\n  (rotlsi3_8): Delete.\n  (rotlsi3_16): Delete.\n  (rotlsi3_24): Delete.\n  (rotl<mode>3): New.\n  (*rotw<mode>3): New.\n  (*rotb<mode>3): New.\n  *avr.c (avr_rotate_bytes): New function.\n  *avr-proto.h (avr_rotate_bytes): New function.\n\nFrom-SVN: r155746", "tree": {"sha": "f0cc63ddccf87079365955c57a69e269a70d2260", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0cc63ddccf87079365955c57a69e269a70d2260"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58f0ea2f8565b62d2060c2d244cc7d98b5b0a7a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58f0ea2f8565b62d2060c2d244cc7d98b5b0a7a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58f0ea2f8565b62d2060c2d244cc7d98b5b0a7a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58f0ea2f8565b62d2060c2d244cc7d98b5b0a7a5/comments", "author": null, "committer": null, "parents": [{"sha": "601fc26e4e7625131573450f11dfb7ae5f57ffeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/601fc26e4e7625131573450f11dfb7ae5f57ffeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/601fc26e4e7625131573450f11dfb7ae5f57ffeb"}], "stats": {"total": 376, "additions": 210, "deletions": 166}, "files": [{"sha": "c6343625d22e1ff630f34eec69f7acf4d95d2dca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58f0ea2f8565b62d2060c2d244cc7d98b5b0a7a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58f0ea2f8565b62d2060c2d244cc7d98b5b0a7a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=58f0ea2f8565b62d2060c2d244cc7d98b5b0a7a5", "patch": "@@ -1,3 +1,19 @@\n+2010-01-08  Andy Hutchinson  <hutchinsonandy@gcc.gnu.org>\n+\n+\tPR target/41885\n+\t* avr.md (rotlqi3): Add CONST_INT_P check.\n+\t(rotlhi3): Delete.\n+\t(rotlhi3_8): Delete.\n+\t(rotlsi3): Delete.\n+\t(rotlsi3_8): Delete.\n+\t(rotlsi3_16): Delete.\n+\t(rotlsi3_24): Delete.\n+\t(rotl<mode>3): New.\n+\t(*rotw<mode>3): New.\n+\t(*rotb<mode>3): New.\n+\t* avr.c (avr_rotate_bytes): New function.\n+\t* avr-proto.h (avr_rotate_bytes): New function. \n+\n 2010-01-08  Steve Ellcey  <sje@cup.hp.com>\n \n \tPR target/37454"}, {"sha": "ea55a9bd5c3c5ab654b502f56f61fb8743d9bb83", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58f0ea2f8565b62d2060c2d244cc7d98b5b0a7a5/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58f0ea2f8565b62d2060c2d244cc7d98b5b0a7a5/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=58f0ea2f8565b62d2060c2d244cc7d98b5b0a7a5", "patch": "@@ -82,6 +82,7 @@ extern const char *ashrsi3_out (rtx insn, rtx operands[], int *len);\n extern const char *lshrqi3_out (rtx insn, rtx operands[], int *len);\n extern const char *lshrhi3_out (rtx insn, rtx operands[], int *len);\n extern const char *lshrsi3_out (rtx insn, rtx operands[], int *len);\n+extern bool avr_rotate_bytes (rtx operands[]);\n \n extern void expand_prologue (void);\n extern void expand_epilogue (void);"}, {"sha": "a5f3db87347ea1ee252b4200428aa645c594adca", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58f0ea2f8565b62d2060c2d244cc7d98b5b0a7a5/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58f0ea2f8565b62d2060c2d244cc7d98b5b0a7a5/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=58f0ea2f8565b62d2060c2d244cc7d98b5b0a7a5", "patch": "@@ -4218,6 +4218,142 @@ lshrsi3_out (rtx insn, rtx operands[], int *len)\n   return \"\";\n }\n \n+/* Create RTL split patterns for byte sized rotate expressions.  This\n+  produces a series of move instructions and considers overlap situations.\n+  Overlapping non-HImode operands need a scratch register.  */\n+\n+bool\n+avr_rotate_bytes (rtx operands[])\n+{\n+    int i, j;\n+    enum machine_mode mode = GET_MODE (operands[0]);\n+    bool overlapped = reg_overlap_mentioned_p (operands[0], operands[1]);\n+    bool same_reg = rtx_equal_p (operands[0], operands[1]);\n+    int num = INTVAL (operands[2]);\n+    rtx scratch = operands[3];\n+    /* Work out if byte or word move is needed.  Odd byte rotates need QImode.\n+       Word move if no scratch is needed, otherwise use size of scratch.  */\n+    enum machine_mode move_mode = QImode;\n+    if (num & 0xf)\n+      move_mode = QImode;\n+    else if ((mode == SImode && !same_reg) || !overlapped)\n+      move_mode = HImode;\n+    else\n+      move_mode = GET_MODE (scratch);\n+\n+    /* Force DI rotate to use QI moves since other DI moves are currently split\n+       into QI moves so forward propagation works better.  */\n+    if (mode == DImode)\n+      move_mode = QImode;\n+    /* Make scratch smaller if needed.  */\n+    if (GET_MODE (scratch) == HImode && move_mode == QImode)\n+      scratch = simplify_gen_subreg (move_mode, scratch, HImode, 0); \n+\n+    int move_size = GET_MODE_SIZE (move_mode);\n+    /* Number of bytes/words to rotate.  */\n+    int offset = (num  >> 3) / move_size;\n+    /* Number of moves needed.  */\n+    int size = GET_MODE_SIZE (mode) / move_size;\n+    /* Himode byte swap is special case to avoid a scratch register.  */\n+    if (mode == HImode && same_reg)\n+      {\n+\t/* HImode byte swap, using xor.  This is as quick as using scratch.  */\n+\trtx src, dst;\n+\tsrc = simplify_gen_subreg (move_mode, operands[1], mode, 0);\n+\tdst = simplify_gen_subreg (move_mode, operands[0], mode, 1);\n+\tif (!rtx_equal_p (dst, src))\n+\t  {\n+\t     emit_move_insn (dst, gen_rtx_XOR (QImode, dst, src));\n+\t     emit_move_insn (src, gen_rtx_XOR (QImode, src, dst));\n+\t     emit_move_insn (dst, gen_rtx_XOR (QImode, dst, src));\n+\t  }\n+      }    \n+    else  \n+      {\n+\t/* Create linked list of moves to determine move order.  */\n+\tstruct {\n+\t  rtx src, dst;\n+\t  int links;\n+\t} move[size + 8];\n+\n+\t/* Generate list of subreg moves.  */\n+\tfor (i = 0; i < size; i++)\n+\t  {\n+\t    int from = i;\n+\t    int to = (from + offset) % size;          \n+\t    move[i].src = simplify_gen_subreg (move_mode, operands[1],\n+\t\t\t\t\t\tmode, from * move_size);\n+\t    move[i].dst = simplify_gen_subreg (move_mode, operands[0],\n+\t\t\t\t\t\tmode, to   * move_size);\n+\t    move[i].links = -1;\n+\t   }\n+\t/* Mark dependence where a dst of one move is the src of another move.\n+\t   The first move is a conflict as it must wait until second is\n+\t   performed.  We ignore moves to self - we catch this later.  */\n+\tif (overlapped)\n+\t  for (i = 0; i < size; i++)\n+\t    if (reg_overlap_mentioned_p (move[i].dst, operands[1]))\n+\t      for (j = 0; j < size; j++)\n+\t\tif (j != i && rtx_equal_p (move[j].src, move[i].dst))\n+\t\t  {\n+\t\t    /* The dst of move i is the src of move j.  */\n+\t\t    move[i].links = j;\n+\t\t    break;\n+\t\t  }\n+\n+\tint blocked = -1;\n+\tint moves = 0;\n+\t/* Go through move list and perform non-conflicting moves.  As each\n+\t   non-overlapping move is made, it may remove other conflicts\n+\t   so the process is repeated until no conflicts remain.  */\n+\tdo\n+\t  {\n+\t    blocked = -1;\n+\t    moves = 0;\n+\t    /* Emit move where dst is not also a src or we have used that\n+\t       src already.  */\n+\t    for (i = 0; i < size; i++)\n+\t      if (move[i].src != NULL_RTX)\n+\t\tif  (move[i].links == -1 || move[move[i].links].src == NULL_RTX)\n+\t\t  {\n+\t\t    moves++;\n+\t\t    /* Ignore NOP moves to self.  */\n+\t\t    if (!rtx_equal_p (move[i].dst, move[i].src))\n+\t\t      emit_move_insn (move[i].dst, move[i].src);\n+\n+\t\t    /* Remove  conflict from list.  */\n+\t\t    move[i].src = NULL_RTX;\n+\t\t  }\n+\t\telse\n+\t\t  blocked = i;\n+\n+\t    /* Check for deadlock. This is when no moves occurred and we have\n+\t       at least one blocked move.  */\n+\t    if (moves == 0 && blocked != -1)\n+\t      {\n+\t\t/* Need to use scratch register to break deadlock.\n+\t\t   Add move to put dst of blocked move into scratch.\n+\t\t   When this move occurs, it will break chain deadlock.\n+\t\t   The scratch register is substituted for real move.  */\n+\n+\t\tmove[size].src = move[blocked].dst;\n+\t\tmove[size].dst =  scratch;\n+\t\t/* Scratch move is never blocked.  */\n+\t\tmove[size].links = -1; \n+\t\t/* Make sure we have valid link.  */\n+\t\tgcc_assert (move[blocked].links != -1);\n+\t\t/* Replace src of  blocking move with scratch reg.  */\n+\t\tmove[move[blocked].links].src = scratch;\n+\t\t/* Make dependent on scratch move occuring.  */\n+\t\tmove[blocked].links = size; \n+\t\tsize=size+1;\n+\t      }\n+\t  }\n+\twhile (blocked != -1);\n+      }\n+    return true;\n+}\n+\n /* Modifies the length assigned to instruction INSN\n  LEN is the initially computed length of the insn.  */\n "}, {"sha": "9b6b69217d583c1d22a62f6618016dc2cbec71f1", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 57, "deletions": 166, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58f0ea2f8565b62d2060c2d244cc7d98b5b0a7a5/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58f0ea2f8565b62d2060c2d244cc7d98b5b0a7a5/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=58f0ea2f8565b62d2060c2d244cc7d98b5b0a7a5", "patch": "@@ -121,6 +121,8 @@\n ;; Define mode iterator\n (define_mode_iterator QISI [(QI \"\") (HI \"\") (SI \"\")])\n (define_mode_iterator QIDI [(QI \"\") (HI \"\") (SI \"\") (DI \"\")])\n+(define_mode_iterator HIDI [(HI \"\") (SI \"\") (DI \"\")])\n+(define_mode_iterator HISI [(HI \"\") (SI \"\")])\n \n ;;========================================================================\n ;; The following is used by nonlocal_goto and setjmp.\n@@ -1485,7 +1487,7 @@\n   \"\"\n   \"\n {\n-  if (INTVAL (operands[2]) != 4)\n+  if (!CONST_INT_P (operands[2]) || (INTVAL (operands[2]) != 4))\n     FAIL;\n }\")\n \n@@ -1498,185 +1500,74 @@\n   [(set_attr \"length\" \"1\")\n    (set_attr \"cc\" \"none\")])\n \n-(define_expand \"rotlhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(rotate:HI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t   (match_operand:HI 2 \"const_int_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (INTVAL (operands[2]) != 8)\n-    FAIL;\n-}\")\n+;; Split all rotates of HI,SI and DImode registers where rotation is by\n+;; a whole number of bytes.  The split creates the appropriate moves and\n+;; considers all overlap situations.  DImode is split before reload.\n \n-(define_insn_and_split \"*rotlhi3_8\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(rotate:HI (match_operand:HI 1 \"register_operand\" \"r\")\n-\t\t   (const_int 8)))]\n-  \"\"\n-  \"mov __tmp_reg__,%A0\n-\tmov %A0,%B0\n-\tmov %B0, __tmp_reg__\"\n-  \"reload_completed\n-   && REGNO (operands[0]) != REGNO (operands[1])\"\n-  [(set (match_dup 2) (match_dup 5))\n-   (set (match_dup 3) (match_dup 4))]\n-  \"operands[2] = gen_lowpart (QImode, operands[0]);\n-   operands[3] = gen_highpart (QImode, operands[0]);\n-\n-   operands[4] = gen_lowpart (QImode, operands[1]);\n-   operands[5] = gen_highpart (QImode, operands[1]);\"\n-   [(set_attr \"length\" \"3\")\n-   (set_attr \"cc\" \"none\")])\n+;; HImode does not need scratch.  Use attribute for this constraint.\n+;; Use QI scratch for DI mode as this is often split into byte sized operands.\n \n-(define_expand \"rotlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(rotate:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t   (match_operand:SI 2 \"const_int_operand\" \"\")))]\n+(define_mode_attr rotx [(DI \"&r,&r,X\") (SI \"&r,&r,X\") (HI \"X,X,X\")])\n+(define_mode_attr rotsmode [(DI \"QI\") (SI \"HI\") (HI \"QI\")])\n+\n+(define_expand \"rotl<mode>3\"\n+  [(parallel [(set (match_operand:HIDI 0 \"register_operand\" \"\")\n+\t\t   (rotate:HIDI (match_operand:HIDI 1 \"register_operand\" \"\")\n+\t\t\t\t(match_operand:VOID 2 \"const_int_operand\" \"\")))\n+\t\t(clobber (match_operand 3 \"\"))])]\n   \"\"\n   \"\n {\n-  if (INTVAL (operands[2]) != 8\n-      || INTVAL (operands[2]) != 16\n-      || INTVAL (operands[2]) != 24)\n+  if (CONST_INT_P (operands[2]) && 0 == (INTVAL (operands[2]) % 8))\n+  {\n+  if (AVR_HAVE_MOVW && 0 == INTVAL (operands[2]) % 16)\n+    operands[3] = gen_reg_rtx (<rotsmode>mode);\n+  else\n+    operands[3] = gen_reg_rtx (QImode);\n+  }\n+  else\n     FAIL;\n }\")\n \n-(define_insn_and_split \"*rotlsi3_16\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(rotate:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t   (const_int 16)))]\n-  \"\"\n-  \"{mov __tmp_reg__,%A1\\;mov %A0,%C1\\;mov %C0, __tmp_reg__\\;mov __tmp_reg__,%B1\\;mov %B0,%D1\\;mov %D0, __tmp_reg__|movw __tmp_reg__,%A1\\;movw %A0,%C1\\;movw %C0, __tmp_reg__\\;clr __zero_reg__}\"\n-  \"reload_completed\n-   && REGNO (operands[0]) != REGNO (operands[1])\"\n-  [(set (match_dup 2) (match_dup 5))\n-   (set (match_dup 3) (match_dup 4))]\n-  \"unsigned int si_lo_off = subreg_lowpart_offset (HImode, SImode);\n-   unsigned int si_hi_off = subreg_highpart_offset (HImode, SImode);\n \n-   operands[2] = simplify_gen_subreg (HImode, operands[0], SImode, si_lo_off);\n-   operands[3] = simplify_gen_subreg (HImode, operands[0], SImode, si_hi_off);\n+;; Overlapping non-HImode registers often (but not always) need a scratch.\n+;; The best we can do is use early clobber alternative \"#&r\" so that\n+;; completely non-overlapping operands dont get a scratch but # so register\n+;; allocation does not prefer non-overlapping.\n \n-   operands[4] = simplify_gen_subreg (HImode, operands[1], SImode, si_lo_off);\n-   operands[5] = simplify_gen_subreg (HImode, operands[1], SImode, si_hi_off);\n \n-   if (REGNO (operands[0]) == REGNO(operands[1]) + 2)\n-     {\n-       emit_move_insn (operands[3], operands[4]);\n-       DONE;\n-     }\n-   else if (REGNO (operands[0]) == REGNO(operands[1]) - 2)\n-     {\n-       emit_move_insn (operands[2], operands[5]);\n-       DONE;\n-     }\"\n-  [(set (attr \"length\") (if_then_else (eq_attr \"mcu_have_movw\" \"yes\")\n-\t\t\t\t      (const_int 4)\n-\t\t\t\t      (const_int 6)))\n-   (set (attr \"cc\") (if_then_else (eq_attr \"mcu_have_movw\" \"yes\")\n-\t\t\t\t  (const_string \"clobber\")\n-\t\t\t\t  (const_string \"none\")))])\n-\n-(define_insn_and_split \"*rotlsi3_8\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(rotate:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t   (const_int 8)))]\n-  \"\"\n-  \"mov __tmp_reg__,%D1\n-\tmov %D0,%C1\n-\tmov %C0,%B1\n-\tmov %B0,%A1\n-\tmov %A0, __tmp_reg__\"\n-  \"reload_completed\n-   && REGNO (operands[0]) != REGNO (operands[1])\"\n+; Split word aligned rotates using scratch that is mode dependent.\n+(define_insn_and_split \"*rotw<mode>\"\n+  [(set (match_operand:HIDI 0 \"register_operand\" \"=r,r,#&r\")\n+\t(rotate:HIDI (match_operand:HIDI 1 \"register_operand\" \"0,r,r\")\n+\t\t     (match_operand 2 \"immediate_operand\" \"n,n,n\")))\n+   (clobber (match_operand:<rotsmode> 3 \"register_operand\"  \"=<rotx>\" ))]\n+  \"(CONST_INT_P (operands[2]) &&\n+     (0 == (INTVAL (operands[2]) % 16) && AVR_HAVE_MOVW))\"\n+  \"#\"\n+  \"&& (reload_completed || <MODE>mode == DImode)\"\n   [(const_int 0)]\n-  \"unsigned int si_lo_off = subreg_lowpart_offset (HImode, SImode);\n-   unsigned int si_hi_off = subreg_highpart_offset (HImode, SImode);\n-   unsigned int hi_lo_off = subreg_lowpart_offset (QImode, HImode);\n-   unsigned int hi_hi_off = subreg_highpart_offset (QImode, HImode);\n-\n-   operands[2] = simplify_gen_subreg (HImode, operands[0], SImode, si_lo_off);\n-   operands[4] = simplify_gen_subreg (HImode, operands[0], SImode, si_hi_off);\n-   operands[3] = simplify_gen_subreg (QImode, operands[2], HImode, hi_hi_off);\n-   operands[2] = simplify_gen_subreg (QImode, operands[2], HImode, hi_lo_off);\n-   operands[5] = simplify_gen_subreg (QImode, operands[4], HImode, hi_hi_off);\n-   operands[4] = simplify_gen_subreg (QImode, operands[4], HImode, hi_lo_off);\n-\n-   operands[6] = simplify_gen_subreg (HImode, operands[1], SImode, si_lo_off);\n-   operands[8] = simplify_gen_subreg (HImode, operands[1], SImode, si_hi_off);\n-   operands[7] = simplify_gen_subreg (QImode, operands[6], HImode, hi_hi_off);\n-   operands[6] = simplify_gen_subreg (QImode, operands[6], HImode, hi_lo_off);\n-   operands[9] = simplify_gen_subreg (QImode, operands[8], HImode, hi_hi_off);\n-   operands[8] = simplify_gen_subreg (QImode, operands[8], HImode, hi_lo_off);\n- \n-   if (REGNO (operands[0]) < REGNO(operands[1]))\n-     {\n-       emit_move_insn (operands[2], operands[9]);\n-       emit_move_insn (operands[3], operands[6]);\n-       emit_move_insn (operands[4], operands[7]);\n-       emit_move_insn (operands[5], operands[8]);\n-     }\n-   else\n-     {\n-       emit_move_insn (operands[5], operands[8]);\n-       emit_move_insn (operands[2], operands[9]);\n-       emit_move_insn (operands[4], operands[7]);\n-       emit_move_insn (operands[3], operands[6]);\n-     }\n-   DONE;\"\n-   [(set_attr \"length\" \"5\")\n-   (set_attr \"cc\" \"none\")])\n+  \"avr_rotate_bytes (operands);\n+  DONE;\"\n+)\n \n-(define_insn_and_split \"*rotlsi3_24\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(rotate:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t   (const_int 24)))]\n-  \"\"\n-  \"mov __tmp_reg__,%A1\n-\tmov %A0,%B1\n-\tmov %B0,%C1\n-\tmov %C0,%D1\n-\tmov %D0, __tmp_reg__\"\n-  \"reload_completed\n-   && REGNO (operands[0]) != REGNO (operands[1])\"\n+\n+; Split byte aligned rotates using scratch that is always QI mode.\n+(define_insn_and_split \"*rotb<mode>\"\n+  [(set (match_operand:HIDI 0 \"register_operand\" \"=r,r,#&r\")\n+\t(rotate:HIDI (match_operand:HIDI 1 \"register_operand\" \"0,r,r\")\n+\t\t     (match_operand 2 \"immediate_operand\" \"n,n,n\")))\n+   (clobber (match_operand:QI 3 \"register_operand\" \"=<rotx>\" ))]\n+  \"(CONST_INT_P (operands[2]) &&\n+     (8 == (INTVAL (operands[2]) % 16)\n+     \t|| (!AVR_HAVE_MOVW && 0 == (INTVAL (operands[2]) % 16))))\"\n+  \"#\"\n+  \"&& (reload_completed || <MODE>mode == DImode)\"\n   [(const_int 0)]\n-  \"unsigned int si_lo_off = subreg_lowpart_offset (HImode, SImode);\n-   unsigned int si_hi_off = subreg_highpart_offset (HImode, SImode);\n-   unsigned int hi_lo_off = subreg_lowpart_offset (QImode, HImode);\n-   unsigned int hi_hi_off = subreg_highpart_offset (QImode, HImode);\n-\n-   operands[2] = simplify_gen_subreg (HImode, operands[0], SImode, si_lo_off);\n-   operands[4] = simplify_gen_subreg (HImode, operands[0], SImode, si_hi_off);\n-   operands[3] = simplify_gen_subreg (QImode, operands[2], HImode, hi_hi_off);\n-   operands[2] = simplify_gen_subreg (QImode, operands[2], HImode, hi_lo_off);\n-   operands[5] = simplify_gen_subreg (QImode, operands[4], HImode, hi_hi_off);\n-   operands[4] = simplify_gen_subreg (QImode, operands[4], HImode, hi_lo_off);\n-\n-   operands[6] = simplify_gen_subreg (HImode, operands[1], SImode, si_lo_off);\n-   operands[8] = simplify_gen_subreg (HImode, operands[1], SImode, si_hi_off);\n-   operands[7] = simplify_gen_subreg (QImode, operands[6], HImode, hi_hi_off);\n-   operands[6] = simplify_gen_subreg (QImode, operands[6], HImode, hi_lo_off);\n-   operands[9] = simplify_gen_subreg (QImode, operands[8], HImode, hi_hi_off);\n-   operands[8] = simplify_gen_subreg (QImode, operands[8], HImode, hi_lo_off);\n-\n-   if (REGNO (operands[0]) < REGNO(operands[1]))\n-     {\n-       emit_move_insn (operands[2], operands[7]);\n-       emit_move_insn (operands[5], operands[6]);\n-       emit_move_insn (operands[3], operands[8]);\n-       emit_move_insn (operands[4], operands[9]);\n-     }\n-   else\n-     {\n-       emit_move_insn (operands[5], operands[6]);\n-       emit_move_insn (operands[4], operands[9]);\n-       emit_move_insn (operands[3], operands[8]);\n-       emit_move_insn (operands[2], operands[7]);\n-     }\n-   DONE;\"\n-   [(set_attr \"length\" \"5\")\n-   (set_attr \"cc\" \"none\")])\n+  \"avr_rotate_bytes (operands);\n+  DONE;\"\n+)\n+\n \n ;;<< << << << << << << << << << << << << << << << << << << << << << << << << <<\n ;; arithmetic shift left"}]}