{"sha": "21810de45dcfec0ac4141dfa6a59e0f0859aed3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjE4MTBkZTQ1ZGNmZWMwYWM0MTQxZGZhNmE1OWUwZjA4NTlhZWQzZQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-12-20T12:54:44Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-12-20T12:54:44Z"}, "message": "poly_int: DWARF CFA offsets\n\nThis patch makes the DWARF code use poly_int64 rather than\nHOST_WIDE_INT for CFA offsets.  The main changes are:\n\n- to make reg_save use a DW_CFA_expression representation when\n  the offset isn't constant and\n\n- to record the CFA information alongside a def_cfa_expression\n  if either offset is polynomial, since it's quite difficult\n  to reconstruct the CFA information otherwise.\n\n2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* gengtype.c (main): Handle poly_int64_pod.\n\t* dwarf2out.h (dw_cfi_oprnd_cfa_loc): New dw_cfi_oprnd_type.\n\t(dw_cfi_oprnd::dw_cfi_cfa_loc): New field.\n\t(dw_cfa_location::offset, dw_cfa_location::base_offset): Change\n\tfrom HOST_WIDE_INT to poly_int64_pod.\n\t* dwarf2cfi.c (queued_reg_save::cfa_offset): Likewise.\n\t(copy_cfa): New function.\n\t(lookup_cfa_1): Use the cached dw_cfi_cfa_loc, if it exists.\n\t(cfi_oprnd_equal_p): Handle dw_cfi_oprnd_cfa_loc.\n\t(cfa_equal_p, dwarf2out_frame_debug_adjust_cfa)\n\t(dwarf2out_frame_debug_cfa_offset, dwarf2out_frame_debug_expr)\n\t(initial_return_save): Treat offsets as poly_ints.\n\t(def_cfa_0): Likewise.  Cache the CFA in dw_cfi_cfa_loc if either\n\toffset is nonconstant.\n\t(reg_save): Take the offset as a poly_int64.  Fall back to\n\tDW_CFA_expression for nonconstant offsets.\n\t(queue_reg_save): Take the offset as a poly_int64.\n\t* dwarf2out.c (dw_cfi_oprnd2_desc): Handle DW_CFA_def_cfa_expression.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r255884", "tree": {"sha": "b9445062124ec0c6049bcfa25ffcbc0dfe5c7113", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9445062124ec0c6049bcfa25ffcbc0dfe5c7113"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/21810de45dcfec0ac4141dfa6a59e0f0859aed3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21810de45dcfec0ac4141dfa6a59e0f0859aed3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/21810de45dcfec0ac4141dfa6a59e0f0859aed3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/21810de45dcfec0ac4141dfa6a59e0f0859aed3e/comments", "author": null, "committer": null, "parents": [{"sha": "fdbfe4e5523f9fe55b7759b2d16b1ce2704fd3ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fdbfe4e5523f9fe55b7759b2d16b1ce2704fd3ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fdbfe4e5523f9fe55b7759b2d16b1ce2704fd3ac"}], "stats": {"total": 218, "additions": 136, "deletions": 82}, "files": [{"sha": "7bb3f5d5371449878588444d4674ada17635b871", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21810de45dcfec0ac4141dfa6a59e0f0859aed3e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21810de45dcfec0ac4141dfa6a59e0f0859aed3e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=21810de45dcfec0ac4141dfa6a59e0f0859aed3e", "patch": "@@ -1,3 +1,26 @@\n+2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* gengtype.c (main): Handle poly_int64_pod.\n+\t* dwarf2out.h (dw_cfi_oprnd_cfa_loc): New dw_cfi_oprnd_type.\n+\t(dw_cfi_oprnd::dw_cfi_cfa_loc): New field.\n+\t(dw_cfa_location::offset, dw_cfa_location::base_offset): Change\n+\tfrom HOST_WIDE_INT to poly_int64_pod.\n+\t* dwarf2cfi.c (queued_reg_save::cfa_offset): Likewise.\n+\t(copy_cfa): New function.\n+\t(lookup_cfa_1): Use the cached dw_cfi_cfa_loc, if it exists.\n+\t(cfi_oprnd_equal_p): Handle dw_cfi_oprnd_cfa_loc.\n+\t(cfa_equal_p, dwarf2out_frame_debug_adjust_cfa)\n+\t(dwarf2out_frame_debug_cfa_offset, dwarf2out_frame_debug_expr)\n+\t(initial_return_save): Treat offsets as poly_ints.\n+\t(def_cfa_0): Likewise.  Cache the CFA in dw_cfi_cfa_loc if either\n+\toffset is nonconstant.\n+\t(reg_save): Take the offset as a poly_int64.  Fall back to\n+\tDW_CFA_expression for nonconstant offsets.\n+\t(queue_reg_save): Take the offset as a poly_int64.\n+\t* dwarf2out.c (dw_cfi_oprnd2_desc): Handle DW_CFA_def_cfa_expression.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "8d08d86df12314e6e39f21d7b2016141e39739a3", "filename": "gcc/dwarf2cfi.c", "status": "modified", "additions": 103, "deletions": 79, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21810de45dcfec0ac4141dfa6a59e0f0859aed3e/gcc%2Fdwarf2cfi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21810de45dcfec0ac4141dfa6a59e0f0859aed3e/gcc%2Fdwarf2cfi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2cfi.c?ref=21810de45dcfec0ac4141dfa6a59e0f0859aed3e", "patch": "@@ -206,7 +206,7 @@ static dw_cfa_location *cur_cfa;\n struct queued_reg_save {\n   rtx reg;\n   rtx saved_reg;\n-  HOST_WIDE_INT cfa_offset;\n+  poly_int64_pod cfa_offset;\n };\n \n \n@@ -434,6 +434,16 @@ copy_cfi_row (dw_cfi_row *src)\n   return dst;\n }\n \n+/* Return a copy of an existing CFA location.  */\n+\n+static dw_cfa_location *\n+copy_cfa (dw_cfa_location *src)\n+{\n+  dw_cfa_location *dst = ggc_alloc<dw_cfa_location> ();\n+  *dst = *src;\n+  return dst;\n+}\n+\n /* Generate a new label for the CFI info to refer to.  */\n \n static char *\n@@ -629,7 +639,10 @@ lookup_cfa_1 (dw_cfi_ref cfi, dw_cfa_location *loc, dw_cfa_location *remember)\n       loc->offset = cfi->dw_cfi_oprnd2.dw_cfi_offset;\n       break;\n     case DW_CFA_def_cfa_expression:\n-      get_cfa_from_loc_descr (loc, cfi->dw_cfi_oprnd1.dw_cfi_loc);\n+      if (cfi->dw_cfi_oprnd2.dw_cfi_cfa_loc)\n+\t*loc = *cfi->dw_cfi_oprnd2.dw_cfi_cfa_loc;\n+      else\n+\tget_cfa_from_loc_descr (loc, cfi->dw_cfi_oprnd1.dw_cfi_loc);\n       break;\n \n     case DW_CFA_remember_state:\n@@ -654,10 +667,10 @@ bool\n cfa_equal_p (const dw_cfa_location *loc1, const dw_cfa_location *loc2)\n {\n   return (loc1->reg == loc2->reg\n-\t  && loc1->offset == loc2->offset\n+\t  && known_eq (loc1->offset, loc2->offset)\n \t  && loc1->indirect == loc2->indirect\n \t  && (loc1->indirect == 0\n-\t      || loc1->base_offset == loc2->base_offset));\n+\t      || known_eq (loc1->base_offset, loc2->base_offset)));\n }\n \n /* Determine if two CFI operands are identical.  */\n@@ -678,6 +691,8 @@ cfi_oprnd_equal_p (enum dw_cfi_oprnd_type t, dw_cfi_oprnd *a, dw_cfi_oprnd *b)\n \t      || strcmp (a->dw_cfi_addr, b->dw_cfi_addr) == 0);\n     case dw_cfi_oprnd_loc:\n       return loc_descr_equal_p (a->dw_cfi_loc, b->dw_cfi_loc);\n+    case dw_cfi_oprnd_cfa_loc:\n+      return cfa_equal_p (a->dw_cfi_cfa_loc, b->dw_cfi_cfa_loc);\n     }\n   gcc_unreachable ();\n }\n@@ -758,42 +773,50 @@ def_cfa_0 (dw_cfa_location *old_cfa, dw_cfa_location *new_cfa)\n \n   cfi = new_cfi ();\n \n-  if (new_cfa->reg == old_cfa->reg && !new_cfa->indirect && !old_cfa->indirect)\n+  HOST_WIDE_INT const_offset;\n+  if (new_cfa->reg == old_cfa->reg\n+      && !new_cfa->indirect\n+      && !old_cfa->indirect\n+      && new_cfa->offset.is_constant (&const_offset))\n     {\n       /* Construct a \"DW_CFA_def_cfa_offset <offset>\" instruction, indicating\n \t the CFA register did not change but the offset did.  The data\n \t factoring for DW_CFA_def_cfa_offset_sf happens in output_cfi, or\n \t in the assembler via the .cfi_def_cfa_offset directive.  */\n-      if (new_cfa->offset < 0)\n+      if (const_offset < 0)\n \tcfi->dw_cfi_opc = DW_CFA_def_cfa_offset_sf;\n       else\n \tcfi->dw_cfi_opc = DW_CFA_def_cfa_offset;\n-      cfi->dw_cfi_oprnd1.dw_cfi_offset = new_cfa->offset;\n+      cfi->dw_cfi_oprnd1.dw_cfi_offset = const_offset;\n     }\n-  else if (new_cfa->offset == old_cfa->offset\n+  else if (new_cfa->offset.is_constant ()\n+\t   && known_eq (new_cfa->offset, old_cfa->offset)\n \t   && old_cfa->reg != INVALID_REGNUM\n \t   && !new_cfa->indirect\n \t   && !old_cfa->indirect)\n     {\n       /* Construct a \"DW_CFA_def_cfa_register <register>\" instruction,\n \t indicating the CFA register has changed to <register> but the\n-\t offset has not changed.  */\n+\t offset has not changed.  This requires the old CFA to have\n+\t been set as a register plus offset rather than a general\n+\t DW_CFA_def_cfa_expression.  */\n       cfi->dw_cfi_opc = DW_CFA_def_cfa_register;\n       cfi->dw_cfi_oprnd1.dw_cfi_reg_num = new_cfa->reg;\n     }\n-  else if (new_cfa->indirect == 0)\n+  else if (new_cfa->indirect == 0\n+\t   && new_cfa->offset.is_constant (&const_offset))\n     {\n       /* Construct a \"DW_CFA_def_cfa <register> <offset>\" instruction,\n \t indicating the CFA register has changed to <register> with\n \t the specified offset.  The data factoring for DW_CFA_def_cfa_sf\n \t happens in output_cfi, or in the assembler via the .cfi_def_cfa\n \t directive.  */\n-      if (new_cfa->offset < 0)\n+      if (const_offset < 0)\n \tcfi->dw_cfi_opc = DW_CFA_def_cfa_sf;\n       else\n \tcfi->dw_cfi_opc = DW_CFA_def_cfa;\n       cfi->dw_cfi_oprnd1.dw_cfi_reg_num = new_cfa->reg;\n-      cfi->dw_cfi_oprnd2.dw_cfi_offset = new_cfa->offset;\n+      cfi->dw_cfi_oprnd2.dw_cfi_offset = const_offset;\n     }\n   else\n     {\n@@ -805,6 +828,13 @@ def_cfa_0 (dw_cfa_location *old_cfa, dw_cfa_location *new_cfa)\n       cfi->dw_cfi_opc = DW_CFA_def_cfa_expression;\n       loc_list = build_cfa_loc (new_cfa, 0);\n       cfi->dw_cfi_oprnd1.dw_cfi_loc = loc_list;\n+      if (!new_cfa->offset.is_constant ()\n+\t  || !new_cfa->base_offset.is_constant ())\n+\t/* It's hard to reconstruct the CFA location for a polynomial\n+\t   expression, so just cache it instead.  */\n+\tcfi->dw_cfi_oprnd2.dw_cfi_cfa_loc = copy_cfa (new_cfa);\n+      else\n+\tcfi->dw_cfi_oprnd2.dw_cfi_cfa_loc = NULL;\n     }\n \n   return cfi;\n@@ -836,33 +866,42 @@ def_cfa_1 (dw_cfa_location *new_cfa)\n    otherwise it is saved in SREG.  */\n \n static void\n-reg_save (unsigned int reg, unsigned int sreg, HOST_WIDE_INT offset)\n+reg_save (unsigned int reg, unsigned int sreg, poly_int64 offset)\n {\n   dw_fde_ref fde = cfun ? cfun->fde : NULL;\n   dw_cfi_ref cfi = new_cfi ();\n \n   cfi->dw_cfi_oprnd1.dw_cfi_reg_num = reg;\n \n-  /* When stack is aligned, store REG using DW_CFA_expression with FP.  */\n-  if (fde\n-      && fde->stack_realign\n-      && sreg == INVALID_REGNUM)\n-    {\n-      cfi->dw_cfi_opc = DW_CFA_expression;\n-      cfi->dw_cfi_oprnd1.dw_cfi_reg_num = reg;\n-      cfi->dw_cfi_oprnd2.dw_cfi_loc\n-\t= build_cfa_aligned_loc (&cur_row->cfa, offset,\n-\t\t\t\t fde->stack_realignment);\n-    }\n-  else if (sreg == INVALID_REGNUM)\n+  if (sreg == INVALID_REGNUM)\n     {\n-      if (need_data_align_sf_opcode (offset))\n-\tcfi->dw_cfi_opc = DW_CFA_offset_extended_sf;\n-      else if (reg & ~0x3f)\n-\tcfi->dw_cfi_opc = DW_CFA_offset_extended;\n+      HOST_WIDE_INT const_offset;\n+      /* When stack is aligned, store REG using DW_CFA_expression with FP.  */\n+      if (fde && fde->stack_realign)\n+\t{\n+\t  cfi->dw_cfi_opc = DW_CFA_expression;\n+\t  cfi->dw_cfi_oprnd1.dw_cfi_reg_num = reg;\n+\t  cfi->dw_cfi_oprnd2.dw_cfi_loc\n+\t    = build_cfa_aligned_loc (&cur_row->cfa, offset,\n+\t\t\t\t     fde->stack_realignment);\n+\t}\n+      else if (offset.is_constant (&const_offset))\n+\t{\n+\t  if (need_data_align_sf_opcode (const_offset))\n+\t    cfi->dw_cfi_opc = DW_CFA_offset_extended_sf;\n+\t  else if (reg & ~0x3f)\n+\t    cfi->dw_cfi_opc = DW_CFA_offset_extended;\n+\t  else\n+\t    cfi->dw_cfi_opc = DW_CFA_offset;\n+\t  cfi->dw_cfi_oprnd2.dw_cfi_offset = const_offset;\n+\t}\n       else\n-\tcfi->dw_cfi_opc = DW_CFA_offset;\n-      cfi->dw_cfi_oprnd2.dw_cfi_offset = offset;\n+\t{\n+\t  cfi->dw_cfi_opc = DW_CFA_expression;\n+\t  cfi->dw_cfi_oprnd1.dw_cfi_reg_num = reg;\n+\t  cfi->dw_cfi_oprnd2.dw_cfi_loc\n+\t    = build_cfa_loc (&cur_row->cfa, offset);\n+\t}\n     }\n   else if (sreg == reg)\n     {\n@@ -995,7 +1034,7 @@ record_reg_saved_in_reg (rtx dest, rtx src)\n    SREG, or if SREG is NULL then it is saved at OFFSET to the CFA.  */\n \n static void\n-queue_reg_save (rtx reg, rtx sreg, HOST_WIDE_INT offset)\n+queue_reg_save (rtx reg, rtx sreg, poly_int64 offset)\n {\n   queued_reg_save *q;\n   queued_reg_save e = {reg, sreg, offset};\n@@ -1097,20 +1136,11 @@ dwarf2out_frame_debug_def_cfa (rtx pat)\n {\n   memset (cur_cfa, 0, sizeof (*cur_cfa));\n \n-  if (GET_CODE (pat) == PLUS)\n-    {\n-      cur_cfa->offset = INTVAL (XEXP (pat, 1));\n-      pat = XEXP (pat, 0);\n-    }\n+  pat = strip_offset (pat, &cur_cfa->offset);\n   if (MEM_P (pat))\n     {\n       cur_cfa->indirect = 1;\n-      pat = XEXP (pat, 0);\n-      if (GET_CODE (pat) == PLUS)\n-\t{\n-\t  cur_cfa->base_offset = INTVAL (XEXP (pat, 1));\n-\t  pat = XEXP (pat, 0);\n-\t}\n+      pat = strip_offset (XEXP (pat, 0), &cur_cfa->base_offset);\n     }\n   /* ??? If this fails, we could be calling into the _loc functions to\n      define a full expression.  So far no port does that.  */\n@@ -1133,7 +1163,7 @@ dwarf2out_frame_debug_adjust_cfa (rtx pat)\n     {\n     case PLUS:\n       gcc_assert (dwf_regno (XEXP (src, 0)) == cur_cfa->reg);\n-      cur_cfa->offset -= INTVAL (XEXP (src, 1));\n+      cur_cfa->offset -= rtx_to_poly_int64 (XEXP (src, 1));\n       break;\n \n     case REG:\n@@ -1152,7 +1182,7 @@ dwarf2out_frame_debug_adjust_cfa (rtx pat)\n static void\n dwarf2out_frame_debug_cfa_offset (rtx set)\n {\n-  HOST_WIDE_INT offset;\n+  poly_int64 offset;\n   rtx src, addr, span;\n   unsigned int sregno;\n \n@@ -1170,7 +1200,7 @@ dwarf2out_frame_debug_cfa_offset (rtx set)\n       break;\n     case PLUS:\n       gcc_assert (dwf_regno (XEXP (addr, 0)) == cur_cfa->reg);\n-      offset = INTVAL (XEXP (addr, 1)) - cur_cfa->offset;\n+      offset = rtx_to_poly_int64 (XEXP (addr, 1)) - cur_cfa->offset;\n       break;\n     default:\n       gcc_unreachable ();\n@@ -1195,7 +1225,7 @@ dwarf2out_frame_debug_cfa_offset (rtx set)\n     {\n       /* We have a PARALLEL describing where the contents of SRC live.\n    \t Adjust the offset for each piece of the PARALLEL.  */\n-      HOST_WIDE_INT span_offset = offset;\n+      poly_int64 span_offset = offset;\n \n       gcc_assert (GET_CODE (span) == PARALLEL);\n \n@@ -1535,7 +1565,7 @@ static void\n dwarf2out_frame_debug_expr (rtx expr)\n {\n   rtx src, dest, span;\n-  HOST_WIDE_INT offset;\n+  poly_int64 offset;\n   dw_fde_ref fde;\n \n   /* If RTX_FRAME_RELATED_P is set on a PARALLEL, process each member of\n@@ -1639,19 +1669,14 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t    {\n \t      /* Rule 2 */\n \t      /* Adjusting SP.  */\n-\t      switch (GET_CODE (XEXP (src, 1)))\n+\t      if (REG_P (XEXP (src, 1)))\n \t\t{\n-\t\tcase CONST_INT:\n-\t\t  offset = INTVAL (XEXP (src, 1));\n-\t\t  break;\n-\t\tcase REG:\n \t\t  gcc_assert (dwf_regno (XEXP (src, 1))\n \t\t\t      == cur_trace->cfa_temp.reg);\n \t\t  offset = cur_trace->cfa_temp.offset;\n-\t\t  break;\n-\t\tdefault:\n-\t\t  gcc_unreachable ();\n \t\t}\n+\t      else if (!poly_int_rtx_p (XEXP (src, 1), &offset))\n+\t\tgcc_unreachable ();\n \n \t      if (XEXP (src, 0) == hard_frame_pointer_rtx)\n \t\t{\n@@ -1680,9 +1705,8 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t      gcc_assert (frame_pointer_needed);\n \n \t      gcc_assert (REG_P (XEXP (src, 0))\n-\t\t\t  && dwf_regno (XEXP (src, 0)) == cur_cfa->reg\n-\t\t\t  && CONST_INT_P (XEXP (src, 1)));\n-\t      offset = INTVAL (XEXP (src, 1));\n+\t\t\t  && dwf_regno (XEXP (src, 0)) == cur_cfa->reg);\n+\t      offset = rtx_to_poly_int64 (XEXP (src, 1));\n \t      if (GET_CODE (src) != MINUS)\n \t\toffset = -offset;\n \t      cur_cfa->offset += offset;\n@@ -1695,11 +1719,11 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t      /* Rule 4 */\n \t      if (REG_P (XEXP (src, 0))\n \t\t  && dwf_regno (XEXP (src, 0)) == cur_cfa->reg\n-\t\t  && CONST_INT_P (XEXP (src, 1)))\n+\t\t  && poly_int_rtx_p (XEXP (src, 1), &offset))\n \t\t{\n \t\t  /* Setting a temporary CFA register that will be copied\n \t\t     into the FP later on.  */\n-\t\t  offset = - INTVAL (XEXP (src, 1));\n+\t\t  offset = -offset;\n \t\t  cur_cfa->offset += offset;\n \t\t  cur_cfa->reg = dwf_regno (dest);\n \t\t  /* Or used to save regs to the stack.  */\n@@ -1722,20 +1746,19 @@ dwarf2out_frame_debug_expr (rtx expr)\n \n \t      /* Rule 9 */\n \t      else if (GET_CODE (src) == LO_SUM\n-\t\t       && CONST_INT_P (XEXP (src, 1)))\n-\t\t{\n-\t\t  cur_trace->cfa_temp.reg = dwf_regno (dest);\n-\t\t  cur_trace->cfa_temp.offset = INTVAL (XEXP (src, 1));\n-\t\t}\n+\t\t       && poly_int_rtx_p (XEXP (src, 1),\n+\t\t\t\t\t  &cur_trace->cfa_temp.offset))\n+\t\tcur_trace->cfa_temp.reg = dwf_regno (dest);\n \t      else\n \t\tgcc_unreachable ();\n \t    }\n \t  break;\n \n \t  /* Rule 6 */\n \tcase CONST_INT:\n+\tcase POLY_INT_CST:\n \t  cur_trace->cfa_temp.reg = dwf_regno (dest);\n-\t  cur_trace->cfa_temp.offset = INTVAL (src);\n+\t  cur_trace->cfa_temp.offset = rtx_to_poly_int64 (src);\n \t  break;\n \n \t  /* Rule 7 */\n@@ -1745,7 +1768,11 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t\t      && CONST_INT_P (XEXP (src, 1)));\n \n \t  cur_trace->cfa_temp.reg = dwf_regno (dest);\n-\t  cur_trace->cfa_temp.offset |= INTVAL (XEXP (src, 1));\n+\t  if (!can_ior_p (cur_trace->cfa_temp.offset, INTVAL (XEXP (src, 1)),\n+\t\t\t  &cur_trace->cfa_temp.offset))\n+\t    /* The target shouldn't generate this kind of CFI note if we\n+\t       can't represent it.  */\n+\t    gcc_unreachable ();\n \t  break;\n \n \t  /* Skip over HIGH, assuming it will be followed by a LO_SUM,\n@@ -1800,9 +1827,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \tcase PRE_MODIFY:\n \tcase POST_MODIFY:\n \t  /* We can't handle variable size modifications.  */\n-\t  gcc_assert (GET_CODE (XEXP (XEXP (XEXP (dest, 0), 1), 1))\n-\t\t      == CONST_INT);\n-\t  offset = -INTVAL (XEXP (XEXP (XEXP (dest, 0), 1), 1));\n+\t  offset = -rtx_to_poly_int64 (XEXP (XEXP (XEXP (dest, 0), 1), 1));\n \n \t  gcc_assert (REGNO (XEXP (XEXP (dest, 0), 0)) == STACK_POINTER_REGNUM\n \t\t      && cur_trace->cfa_store.reg == dw_stack_pointer_regnum);\n@@ -1860,9 +1885,8 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t  {\n \t    unsigned int regno;\n \n-\t    gcc_assert (CONST_INT_P (XEXP (XEXP (dest, 0), 1))\n-\t\t\t&& REG_P (XEXP (XEXP (dest, 0), 0)));\n-\t    offset = INTVAL (XEXP (XEXP (dest, 0), 1));\n+\t    gcc_assert (REG_P (XEXP (XEXP (dest, 0), 0)));\n+\t    offset = rtx_to_poly_int64 (XEXP (XEXP (dest, 0), 1));\n \t    if (GET_CODE (XEXP (dest, 0)) == MINUS)\n \t      offset = -offset;\n \n@@ -1923,7 +1947,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t{\n \t  /* We're storing the current CFA reg into the stack.  */\n \n-\t  if (cur_cfa->offset == 0)\n+\t  if (known_eq (cur_cfa->offset, 0))\n \t    {\n               /* Rule 19 */\n               /* If stack is aligned, putting CFA reg into stack means\n@@ -1981,7 +2005,7 @@ dwarf2out_frame_debug_expr (rtx expr)\n \t{\n \t  /* We have a PARALLEL describing where the contents of SRC live.\n \t     Queue register saves for each piece of the PARALLEL.  */\n-\t  HOST_WIDE_INT span_offset = offset;\n+\t  poly_int64 span_offset = offset;\n \n \t  gcc_assert (GET_CODE (span) == PARALLEL);\n \n@@ -2884,7 +2908,7 @@ static void\n initial_return_save (rtx rtl)\n {\n   unsigned int reg = INVALID_REGNUM;\n-  HOST_WIDE_INT offset = 0;\n+  poly_int64 offset = 0;\n \n   switch (GET_CODE (rtl))\n     {\n@@ -2905,12 +2929,12 @@ initial_return_save (rtx rtl)\n \n \tcase PLUS:\n \t  gcc_assert (REGNO (XEXP (rtl, 0)) == STACK_POINTER_REGNUM);\n-\t  offset = INTVAL (XEXP (rtl, 1));\n+\t  offset = rtx_to_poly_int64 (XEXP (rtl, 1));\n \t  break;\n \n \tcase MINUS:\n \t  gcc_assert (REGNO (XEXP (rtl, 0)) == STACK_POINTER_REGNUM);\n-\t  offset = -INTVAL (XEXP (rtl, 1));\n+\t  offset = -rtx_to_poly_int64 (XEXP (rtl, 1));\n \t  break;\n \n \tdefault:"}, {"sha": "63efe647053cb7dbbc98300203d64d5f8d04f71f", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21810de45dcfec0ac4141dfa6a59e0f0859aed3e/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21810de45dcfec0ac4141dfa6a59e0f0859aed3e/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=21810de45dcfec0ac4141dfa6a59e0f0859aed3e", "patch": "@@ -573,6 +573,9 @@ dw_cfi_oprnd2_desc (enum dwarf_call_frame_info cfi)\n     case DW_CFA_val_expression:\n       return dw_cfi_oprnd_loc;\n \n+    case DW_CFA_def_cfa_expression:\n+      return dw_cfi_oprnd_cfa_loc;\n+\n     default:\n       return dw_cfi_oprnd_unused;\n     }"}, {"sha": "abaa9d03e1199007c280040bf61153e3d9e6fdc8", "filename": "gcc/dwarf2out.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21810de45dcfec0ac4141dfa6a59e0f0859aed3e/gcc%2Fdwarf2out.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21810de45dcfec0ac4141dfa6a59e0f0859aed3e/gcc%2Fdwarf2out.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.h?ref=21810de45dcfec0ac4141dfa6a59e0f0859aed3e", "patch": "@@ -43,14 +43,17 @@ enum dw_cfi_oprnd_type {\n   dw_cfi_oprnd_reg_num,\n   dw_cfi_oprnd_offset,\n   dw_cfi_oprnd_addr,\n-  dw_cfi_oprnd_loc\n+  dw_cfi_oprnd_loc,\n+  dw_cfi_oprnd_cfa_loc\n };\n \n typedef union GTY(()) {\n   unsigned int GTY ((tag (\"dw_cfi_oprnd_reg_num\"))) dw_cfi_reg_num;\n   HOST_WIDE_INT GTY ((tag (\"dw_cfi_oprnd_offset\"))) dw_cfi_offset;\n   const char * GTY ((tag (\"dw_cfi_oprnd_addr\"))) dw_cfi_addr;\n   struct dw_loc_descr_node * GTY ((tag (\"dw_cfi_oprnd_loc\"))) dw_cfi_loc;\n+  struct dw_cfa_location * GTY ((tag (\"dw_cfi_oprnd_cfa_loc\")))\n+    dw_cfi_cfa_loc;\n } dw_cfi_oprnd;\n \n struct GTY(()) dw_cfi_node {\n@@ -114,8 +117,8 @@ struct GTY(()) dw_fde_node {\n    Instead of passing around REG and OFFSET, we pass a copy\n    of this structure.  */\n struct GTY(()) dw_cfa_location {\n-  HOST_WIDE_INT offset;\n-  HOST_WIDE_INT base_offset;\n+  poly_int64_pod offset;\n+  poly_int64_pod base_offset;\n   /* REG is in DWARF_FRAME_REGNUM space, *not* normal REGNO space.  */\n   unsigned int reg;\n   BOOL_BITFIELD indirect : 1;  /* 1 if CFA is accessed via a dereference.  */"}, {"sha": "e76d1fedef2fa1ac737e95985ae6df6d58c5fb70", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/21810de45dcfec0ac4141dfa6a59e0f0859aed3e/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/21810de45dcfec0ac4141dfa6a59e0f0859aed3e/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=21810de45dcfec0ac4141dfa6a59e0f0859aed3e", "patch": "@@ -5192,6 +5192,7 @@ main (int argc, char **argv)\n       POS_HERE (do_scalar_typedef (\"REAL_VALUE_TYPE\", &pos));\n       POS_HERE (do_scalar_typedef (\"FIXED_VALUE_TYPE\", &pos));\n       POS_HERE (do_scalar_typedef (\"double_int\", &pos));\n+      POS_HERE (do_scalar_typedef (\"poly_int64_pod\", &pos));\n       POS_HERE (do_scalar_typedef (\"offset_int\", &pos));\n       POS_HERE (do_scalar_typedef (\"widest_int\", &pos));\n       POS_HERE (do_scalar_typedef (\"int64_t\", &pos));"}]}