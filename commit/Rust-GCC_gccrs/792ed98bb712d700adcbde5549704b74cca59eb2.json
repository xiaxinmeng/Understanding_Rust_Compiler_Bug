{"sha": "792ed98bb712d700adcbde5549704b74cca59eb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzkyZWQ5OGJiNzEyZDcwMGFkY2JkZTU1NDk3MDRiNzRjY2E1OWViMg==", "commit": {"author": {"name": "Harsha Jagasia", "email": "harsha.jagasia@amd.com", "date": "2007-06-08T16:30:49Z"}, "committer": {"name": "Harsha Jagasia", "email": "hjagasia@gcc.gnu.org", "date": "2007-06-08T16:30:49Z"}, "message": "extend.texi: Add fvect-cost-model flag.\n\ngcc/ChangeLog:\n2007-06-08  Harsha Jagasia <harsha.jagasia@amd.com>\n            Tony Linthicum <tony.linthicum@amd.com>\n\n\t* doc/extend.texi: Add fvect-cost-model flag.\n\t* common.opt (fvect-cost-model): New flag.\n\t* tree-vectorizer.c (new_stmt_vec_info): Initialize inside and outside\n\tcost fields in stmt_vec_info struct for STMT.\n\t* tree-vectorizer.h (stmt_vec_info): Define inside and outside cost\n\tfields in stmt_vec_info struct and access functions for the same.\n\t(TARG_COND_BRANCH_COST): Define cost of conditional branch.\n\t(TARG_VEC_STMT_COST): Define cost of any vector operation, excluding\n\tload, store and vector to scalar operation.\n\t(TARG_VEC_TO_SCALAR_COST): Define cost of vector to scalar operation.\n\t(TARG_VEC_LOAD_COST): Define cost of aligned vector load.\n\t(TARG_VEC_UNALIGNED_LOAD_COST): Define cost of misasligned vector load.\n\t(TARG_VEC_STORE_COST): Define cost of vector store.\n\t(vect_estimate_min_profitable_iters): Define new function.\n\t* tree-vect-analyze.c (vect_analyze_operations): Add a compile-time\n\tcheck to evaluate if loop iterations are less than minimum profitable\n\titerations determined by cost model or minimum vect loop bound defined\n\tby user, whichever is more conservative.\n\t* tree-vect-transform.c (vect_do_peeling_for_loop_bound): Add a\n\trun-time check to evaluate if loop iterations are less than minimum\n\tprofitable iterations determined by cost model or minimum vect loop\n\tbound defined by user, whichever is more conservative.\n\t(vect_estimate_min_profitable_iterations): New function to estimate\n\tmimimimum iterartions required for vector version of loop to be\n\tprofitable over scalar version.\n        (vect_model_reduction_cost): New function.\n\t(vect_model_induction_cost): New function.\n\t(vect_model_simple_cost): New function.\n\t(vect_cost_strided_group_size): New function.\n\t(vect_model_store_cost): New function.\n\t(vect_model_load_cost): New function.\n\t(vectorizable_reduction): Call vect_model_reduction_cost during\n\tanalysis phase.\n\t(vectorizable_induction): Call vect_model_induction_cost during\n\tanalysis phase.\n\t(vectorizable_load): Call vect_model_load_cost during analysis phase.\n\t(vectorizable_store): Call vect_model_store_cost during analysis phase.\n\t(vectorizable_call, vectorizable_assignment, vectorizable_operation,\n\tvectorizable_promotion, vectorizable_demotion): Call \n\tvect_model_simple_cost during analysis phase.\n\ngcc/testsuite/ChangeLog:\n2007-06-08  Harsha Jagasia <harsha.jagasia@amd.com>\n\n\t* gcc.dg/vect/costmodel: New directory.\n\t* gcc.dg/vect/costmodel/i386: New directory.\n\t* gcc.dg/vect/costmodel/i386/i386-costmodel-vect.exp: New testsuite.\n\t* gcc.dg/vect/costmodel/i386/costmodel-fast-math-vect-pr29925.c:\n\tNew test.\n\t* gcc.dg/vect/costmodel/i386/costmodel-vect-31.c: New test.\n\t* gcc.dg/vect/costmodel/i386/costmodel-vect-33.c: New test.\n\t* gcc.dg/vect/costmodel/i386/costmodel-vect-68.c: New test.\n\t* gcc.dg/vect/costmodel/i386/costmodel-vect-reduc-1char.c: New test.\n\t* gcc.dg/vect/costmodel/x86_64: New directory.\n\t* gcc.dg/vect/costmodel/x86_64/x86_64-costmodel-vect.exp:\n\tNew testsuite.\t\n\t* gcc.dg/vect/costmodel/x86_64/costmodel-fast-math-vect-pr29925.c:\n\tNew test.\n\t* gcc.dg/vect/costmodel/x86_64/costmodel-vect-31.c: New test.\n\t* gcc.dg/vect/costmodel/x86_64/costmodel-vect-33.c: New test.\n\t* gcc.dg/vect/costmodel/x86_64/costmodel-vect-68.c: New test.\n\t* gcc.dg/vect/costmodel/x86_64/costmodel-vect-reduc-1char.c: New test.\n\t* gcc.dg/vect/costmodel/x86_64/costmodel-pr30843.c: New test.\n\nCo-Authored-By: Tony Linthicum <tony.linthicum@amd.com>\n\nFrom-SVN: r125575", "tree": {"sha": "b261d3382cad73cc9bf2627a1ef52c49c881835e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b261d3382cad73cc9bf2627a1ef52c49c881835e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/792ed98bb712d700adcbde5549704b74cca59eb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/792ed98bb712d700adcbde5549704b74cca59eb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/792ed98bb712d700adcbde5549704b74cca59eb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/792ed98bb712d700adcbde5549704b74cca59eb2/comments", "author": null, "committer": null, "parents": [{"sha": "c8e2516ccf14cbd0b22e8a2bd0685e120a32a1d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8e2516ccf14cbd0b22e8a2bd0685e120a32a1d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8e2516ccf14cbd0b22e8a2bd0685e120a32a1d1"}], "stats": {"total": 1507, "additions": 1486, "deletions": 21}, "files": [{"sha": "264e3f59da0589fbadc80e7a8d24da374b6c5496", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=792ed98bb712d700adcbde5549704b74cca59eb2", "patch": "@@ -1,3 +1,47 @@\n+2007-06-08  Harsha Jagasia <harsha.jagasia@amd.com>\n+            Tony Linthicum <tony.linthicum@amd.com>\n+\n+\t* doc/extend.texi: Add fvect-cost-model flag.\n+\t* common.opt (fvect-cost-model): New flag.\n+\t* tree-vectorizer.c (new_stmt_vec_info): Initialize inside and outside\n+\tcost fields in stmt_vec_info struct for STMT.\n+\t* tree-vectorizer.h (stmt_vec_info): Define inside and outside cost\n+\tfields in stmt_vec_info struct and access functions for the same.\n+\t(TARG_COND_BRANCH_COST): Define cost of conditional branch.\n+\t(TARG_VEC_STMT_COST): Define cost of any vector operation, excluding\n+\tload, store and vector to scalar operation.\n+\t(TARG_VEC_TO_SCALAR_COST): Define cost of vector to scalar operation.\n+\t(TARG_VEC_LOAD_COST): Define cost of aligned vector load.\n+\t(TARG_VEC_UNALIGNED_LOAD_COST): Define cost of misasligned vector load.\n+\t(TARG_VEC_STORE_COST): Define cost of vector store.\n+\t(vect_estimate_min_profitable_iters): Define new function.\n+\t* tree-vect-analyze.c (vect_analyze_operations): Add a compile-time\n+\tcheck to evaluate if loop iterations are less than minimum profitable\n+\titerations determined by cost model or minimum vect loop bound defined\n+\tby user, whichever is more conservative.\n+\t* tree-vect-transform.c (vect_do_peeling_for_loop_bound): Add a\n+\trun-time check to evaluate if loop iterations are less than minimum\n+\tprofitable iterations determined by cost model or minimum vect loop\n+\tbound defined by user, whichever is more conservative.\n+\t(vect_estimate_min_profitable_iterations): New function to estimate\n+\tmimimimum iterartions required for vector version of loop to be\n+\tprofitable over scalar version.\n+        (vect_model_reduction_cost): New function.\n+\t(vect_model_induction_cost): New function.\n+\t(vect_model_simple_cost): New function.\n+\t(vect_cost_strided_group_size): New function.\n+\t(vect_model_store_cost): New function.\n+\t(vect_model_load_cost): New function.\n+\t(vectorizable_reduction): Call vect_model_reduction_cost during\n+\tanalysis phase.\n+\t(vectorizable_induction): Call vect_model_induction_cost during\n+\tanalysis phase.\n+\t(vectorizable_load): Call vect_model_load_cost during analysis phase.\n+\t(vectorizable_store): Call vect_model_store_cost during analysis phase.\n+\t(vectorizable_call, vectorizable_assignment, vectorizable_operation,\n+\tvectorizable_promotion, vectorizable_demotion): Call \n+\tvect_model_simple_cost during analysis phase.\n+\n 2007-06-08  Simon Baldwin  <simonb@google.com>\n \n \t* reg-stack.c (get_true_reg): Readability change.  Moved default case"}, {"sha": "629957325520c6c0f28a9d3ca2c932ee35cd7743", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=792ed98bb712d700adcbde5549704b74cca59eb2", "patch": "@@ -1110,6 +1110,10 @@ ftree-vectorize\n Common Report Var(flag_tree_vectorize) Optimization\n Enable loop vectorization on trees\n \n+fvect-cost-model\n+Common Report Var(flag_vect_cost_model) Optimization\n+Enable use of cost model in vectorization\n+\n ftree-vect-loop-version\n Common Report Var(flag_tree_vect_loop_version) Init(1) Optimization\n Enable loop versioning when doing loop vectorization on trees"}, {"sha": "3675ebdc73ad3fc81540c5e37c5a68b016353c40", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=792ed98bb712d700adcbde5549704b74cca59eb2", "patch": "@@ -357,7 +357,7 @@ Objective-C and Objective-C++ Dialects}.\n -fcheck-data-deps @gol\n -ftree-dominator-opts -ftree-dse -ftree-copyrename -ftree-sink @gol\n -ftree-ch -ftree-sra -ftree-ter -ftree-fre -ftree-vectorize @gol\n--ftree-vect-loop-version -ftree-salias -fipa-pta -fweb @gol\n+-ftree-vect-loop-version -fvect-cost-model -ftree-salias -fipa-pta -fweb @gol\n -ftree-copy-prop -ftree-store-ccp -ftree-store-copy-prop -fwhole-program @gol\n --param @var{name}=@var{value}\n -O  -O0  -O1  -O2  -O3  -Os}\n@@ -5666,6 +5666,9 @@ the loop are generated along with runtime checks for alignment or dependence\n to control which version is executed.  This option is enabled by default\n except at level @option{-Os} where it is disabled.\n \n+@item -fvect-cost-model\n+Enable cost model for vectorization.\n+\n @item -ftree-vrp\n Perform Value Range Propagation on trees.  This is similar to the\n constant propagation pass, but instead of values, ranges of values are"}, {"sha": "14f7bafa2133048c212fa4ad4fed258ade3c2b74", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=792ed98bb712d700adcbde5549704b74cca59eb2", "patch": "@@ -1,3 +1,25 @@\n+2007-06-08  Harsha Jagasia <harsha.jagasia@amd.com>\n+\n+\t* gcc.dg/vect/costmodel: New directory.\n+\t* gcc.dg/vect/costmodel/i386: New directory.\n+\t* gcc.dg/vect/costmodel/i386/i386-costmodel-vect.exp: New testsuite.\n+\t* gcc.dg/vect/costmodel/i386/costmodel-fast-math-vect-pr29925.c:\n+\tNew test.\n+\t* gcc.dg/vect/costmodel/i386/costmodel-vect-31.c: New test.\n+\t* gcc.dg/vect/costmodel/i386/costmodel-vect-33.c: New test.\n+\t* gcc.dg/vect/costmodel/i386/costmodel-vect-68.c: New test.\n+\t* gcc.dg/vect/costmodel/i386/costmodel-vect-reduc-1char.c: New test.\n+\t* gcc.dg/vect/costmodel/x86_64: New directory.\n+\t* gcc.dg/vect/costmodel/x86_64/x86_64-costmodel-vect.exp:\n+\tNew testsuite.\t\n+\t* gcc.dg/vect/costmodel/x86_64/costmodel-fast-math-vect-pr29925.c:\n+\tNew test.\n+\t* gcc.dg/vect/costmodel/x86_64/costmodel-vect-31.c: New test.\n+\t* gcc.dg/vect/costmodel/x86_64/costmodel-vect-33.c: New test.\n+\t* gcc.dg/vect/costmodel/x86_64/costmodel-vect-68.c: New test.\n+\t* gcc.dg/vect/costmodel/x86_64/costmodel-vect-reduc-1char.c: New test.\n+\t* gcc.dg/vect/costmodel/x86_64/costmodel-pr30843.c: New test.\n+\n 2007-06-08  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR tree-optimization/32243"}, {"sha": "9347d05ea2d981d9beaf9e5287079fac3c7a5bba", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-fast-math-vect-pr29925.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-fast-math-vect-pr29925.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-fast-math-vect-pr29925.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-fast-math-vect-pr29925.c?ref=792ed98bb712d700adcbde5549704b74cca59eb2", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdlib.h>\n+#include \"../../tree-vect.h\"\n+\n+void interp_pitch(float *exc, float *interp, int pitch, int len)\n+{\n+   int i,k;\n+   int maxj;\n+\n+   maxj=3;\n+   for (i=0;i<len;i++)\n+   {\n+      float tmp = 0;\n+      for (k=0;k<7;k++)\n+      {\n+         tmp += exc[i-pitch+k+maxj-6];\n+      }\n+      interp[i] = tmp;\n+   }\n+}\n+\n+int main()\n+{\n+   float *exc = calloc(126,sizeof(float));\n+   float *interp = calloc(80,sizeof(float));\n+   int pitch = -35;\n+\n+   check_vect ();\n+\n+   interp_pitch(exc, interp, pitch, 80);\n+   free(exc);\n+   free(interp);\n+   return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "11e8a29eada5b2356a6b7e6b2a41ac34a29b81e9", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-vect-31.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-31.c?ref=792ed98bb712d700adcbde5549704b74cca59eb2", "patch": "@@ -0,0 +1,91 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 32\n+\n+struct t{\n+  int k[N];\n+  int l; \n+};\n+  \n+struct s{\n+  char a;\t/* aligned */\n+  char b[N-1];  /* unaligned (offset 1B) */\n+  char c[N];    /* aligned (offset NB) */\n+  struct t d;   /* aligned (offset 2NB) */\n+  struct t e;   /* unaligned (offset 2N+4N+4 B) */\n+};\n+ \n+int main1 ()\n+{  \n+  int i;\n+  struct s tmp;\n+\n+  /* unaligned */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      tmp.b[i] = 5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i <N/2; i++)\n+    {\n+      if (tmp.b[i] != 5)\n+        abort ();\n+    }\n+\n+  /* aligned */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      tmp.c[i] = 6;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i <N/2; i++)\n+    {\n+      if (tmp.c[i] != 6)\n+        abort ();\n+    }\n+\n+  /* aligned */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      tmp.d.k[i] = 7;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i <N/2; i++)\n+    {\n+      if (tmp.d.k[i] != 7)\n+        abort ();\n+    }\n+\n+  /* unaligned */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      tmp.e.k[i] = 8;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i <N/2; i++)\n+    {\n+      if (tmp.e.k[i] != 8)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 2 \"vect\" } }\n+ */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "feaf58591300b775dbf5458cb6f38f51860e51d2", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-vect-33.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-33.c?ref=792ed98bb712d700adcbde5549704b74cca59eb2", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 16\n+struct test {\n+  char ca[N];\n+};\n+\n+extern struct test s;\n+ \n+int main1 ()\n+{  \n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      s.ca[i] = 5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (s.ca[i] != 5)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "7fa1cd1854adc53a4e8af88d725023d081a557b6", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-vect-68.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-68.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-68.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-68.c?ref=792ed98bb712d700adcbde5549704b74cca59eb2", "patch": "@@ -0,0 +1,89 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 32\n+\n+struct s{\n+  int m;\n+  int n[N][N][N];\n+};\n+\n+struct test1{\n+  struct s a; /* array a.n is unaligned */\n+  int b;\n+  int c;\n+  struct s e; /* array e.n is aligned */\n+};\n+\n+int main1 ()\n+{  \n+  int i,j;\n+  struct test1 tmp1;\n+\n+  /* 1. unaligned */\n+  for (i = 0; i < N; i++)\n+    {\n+      tmp1.a.n[1][2][i] = 5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i <N; i++)\n+    {\n+      if (tmp1.a.n[1][2][i] != 5)\n+        abort ();\n+    }\n+\n+  /* 2. aligned */\n+  for (i = 3; i < N-1; i++)\n+    {\n+      tmp1.a.n[1][2][i] = 6;\n+    }\n+\n+  /* check results:  */\n+  for (i = 3; i < N-1; i++)\n+    {\n+      if (tmp1.a.n[1][2][i] != 6)\n+        abort ();\n+    }\n+\n+  /* 3. aligned */\n+  for (i = 0; i < N; i++)\n+    {\n+      tmp1.e.n[1][2][i] = 7;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (tmp1.e.n[1][2][i] != 7)\n+        abort ();\n+    }\n+\n+  /* 4. unaligned */\n+  for (i = 3; i < N-3; i++)\n+    {\n+      tmp1.e.n[1][2][i] = 8;\n+    }\n+ \n+  /* check results:  */\n+  for (i = 3; i <N-3; i++)\n+    {\n+      if (tmp1.e.n[1][2][i] != 8)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "cf5becc4908b0b67f1733cd102e2c7c4a3f520b4", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/i386/costmodel-vect-reduc-1char.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-reduc-1char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-reduc-1char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fcostmodel-vect-reduc-1char.c?ref=792ed98bb712d700adcbde5549704b74cca59eb2", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 16\n+#define DIFF 242\n+\n+void\n+main1 (unsigned char x, unsigned char max_result, unsigned char min_result)\n+{\n+  int i;\n+  unsigned char ub[N] = {1,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  unsigned char uc[N] = {1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+  unsigned char udiff = 2;\n+  unsigned char umax = x;\n+  unsigned char umin = x;\n+\n+  for (i = 0; i < N; i++) {\n+    udiff += (unsigned char)(ub[i] - uc[i]);\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    umax = umax < uc[i] ? uc[i] : umax;\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    umin = umin > uc[i] ? uc[i] : umin;\n+  }\n+\n+  /* check results:  */\n+  if (udiff != DIFF)\n+    abort ();\n+  if (umax != max_result)\n+    abort ();\n+  if (umin != min_result)\n+    abort ();\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  main1 (100, 100, 1);\n+  main1 (0, 15, 0);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_int_max } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 2 \"vect\" { xfail vect_no_int_max } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "97b86ab3e802b6667d39d9e715c6698a26f04927", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/i386/i386-costmodel-vect.exp", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fi386-costmodel-vect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fi386-costmodel-vect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fi386%2Fi386-costmodel-vect.exp?ref=792ed98bb712d700adcbde5549704b74cca59eb2", "patch": "@@ -0,0 +1,67 @@\n+# Copyright (C) 1997, 2004, 2005, 2006 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  \n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# Exit immediately if this isn't a x86 target.\n+if { ![istarget i?86*-*-*] && ![istarget x86_64-*-*] } then {\n+  return\n+}\n+\n+# Set up flags used for tests that don't specify options.\n+set DEFAULT_VECTCFLAGS \"\"\n+\n+# These flags are used for all targets.\n+lappend DEFAULT_VECTCFLAGS \"-O2\" \"-ftree-vectorize\" \"-fvect-cost-model\"\n+\n+# If the target system supports vector instructions, the default action\n+# for a test is 'run', otherwise it's 'compile'.  Save current default.\n+# Executing vector instructions on a system without hardware vector support\n+# is also disabled by a call to check_vect, but disabling execution here is\n+# more efficient.\n+global dg-do-what-default\n+set save-dg-do-what-default ${dg-do-what-default}\n+\n+lappend DEFAULT_VECTCFLAGS \"-msse2\"\n+set dg-do-what-default run\n+\n+# Initialize `dg'.\n+dg-init\n+\n+lappend DEFAULT_VECTCFLAGS \"-fdump-tree-vect-details\"\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/costmodel-vect-*.\\[cS\\]]]  \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n+\n+#### Tests with special options\n+global SAVED_DEFAULT_VECTCFLAGS\n+set SAVED_DEFAULT_VECTCFLAGS $DEFAULT_VECTCFLAGS\n+\n+# -ffast-math tests\n+set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n+lappend DEFAULT_VECTCFLAGS \"-ffast-math\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/costmodel-fast-math-vect*.\\[cS\\]]]  \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n+\n+# Clean up.\n+set dg-do-what-default ${save-dg-do-what-default}\n+\n+# All done.\n+dg-finish"}, {"sha": "9347d05ea2d981d9beaf9e5287079fac3c7a5bba", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-fast-math-vect-pr29925.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-fast-math-vect-pr29925.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-fast-math-vect-pr29925.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-fast-math-vect-pr29925.c?ref=792ed98bb712d700adcbde5549704b74cca59eb2", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-require-effective-target vect_float } */\n+\n+#include <stdlib.h>\n+#include \"../../tree-vect.h\"\n+\n+void interp_pitch(float *exc, float *interp, int pitch, int len)\n+{\n+   int i,k;\n+   int maxj;\n+\n+   maxj=3;\n+   for (i=0;i<len;i++)\n+   {\n+      float tmp = 0;\n+      for (k=0;k<7;k++)\n+      {\n+         tmp += exc[i-pitch+k+maxj-6];\n+      }\n+      interp[i] = tmp;\n+   }\n+}\n+\n+int main()\n+{\n+   float *exc = calloc(126,sizeof(float));\n+   float *interp = calloc(80,sizeof(float));\n+   int pitch = -35;\n+\n+   check_vect ();\n+\n+   interp_pitch(exc, interp, pitch, 80);\n+   free(exc);\n+   free(interp);\n+   return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "5d5d415874796f24de0e8b88f910c6271e796cf9", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-pr30843.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-pr30843.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-pr30843.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-pr30843.c?ref=792ed98bb712d700adcbde5549704b74cca59eb2", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_long } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 16\n+\n+void dacP98FillRGBMap (unsigned char *pBuffer)\n+{\n+    unsigned long dw, dw1;\n+    unsigned long *pdw = (unsigned long *)(pBuffer);\n+\n+    for( dw = 256, dw1 = 0; dw; dw--, dw1 += 0x01010101) \n+    {\n+       *pdw++ = dw1;\n+       *pdw++ = dw1;\n+       *pdw++ = dw1;\n+       *pdw++ = dw1;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" { target vect_interleave\n+} } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "11e8a29eada5b2356a6b7e6b2a41ac34a29b81e9", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-vect-31.c", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-31.c?ref=792ed98bb712d700adcbde5549704b74cca59eb2", "patch": "@@ -0,0 +1,91 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 32\n+\n+struct t{\n+  int k[N];\n+  int l; \n+};\n+  \n+struct s{\n+  char a;\t/* aligned */\n+  char b[N-1];  /* unaligned (offset 1B) */\n+  char c[N];    /* aligned (offset NB) */\n+  struct t d;   /* aligned (offset 2NB) */\n+  struct t e;   /* unaligned (offset 2N+4N+4 B) */\n+};\n+ \n+int main1 ()\n+{  \n+  int i;\n+  struct s tmp;\n+\n+  /* unaligned */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      tmp.b[i] = 5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i <N/2; i++)\n+    {\n+      if (tmp.b[i] != 5)\n+        abort ();\n+    }\n+\n+  /* aligned */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      tmp.c[i] = 6;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i <N/2; i++)\n+    {\n+      if (tmp.c[i] != 6)\n+        abort ();\n+    }\n+\n+  /* aligned */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      tmp.d.k[i] = 7;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i <N/2; i++)\n+    {\n+      if (tmp.d.k[i] != 7)\n+        abort ();\n+    }\n+\n+  /* unaligned */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      tmp.e.k[i] = 8;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i <N/2; i++)\n+    {\n+      if (tmp.e.k[i] != 8)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 2 \"vect\" } }\n+ */\n+/* { dg-final { scan-tree-dump-times \"vectorized 2 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "feaf58591300b775dbf5458cb6f38f51860e51d2", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-vect-33.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-33.c?ref=792ed98bb712d700adcbde5549704b74cca59eb2", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 16\n+struct test {\n+  char ca[N];\n+};\n+\n+extern struct test s;\n+ \n+int main1 ()\n+{  \n+  int i;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      s.ca[i] = 5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (s.ca[i] != 5)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "7fa1cd1854adc53a4e8af88d725023d081a557b6", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-vect-68.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-68.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-68.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-68.c?ref=792ed98bb712d700adcbde5549704b74cca59eb2", "patch": "@@ -0,0 +1,89 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 32\n+\n+struct s{\n+  int m;\n+  int n[N][N][N];\n+};\n+\n+struct test1{\n+  struct s a; /* array a.n is unaligned */\n+  int b;\n+  int c;\n+  struct s e; /* array e.n is aligned */\n+};\n+\n+int main1 ()\n+{  \n+  int i,j;\n+  struct test1 tmp1;\n+\n+  /* 1. unaligned */\n+  for (i = 0; i < N; i++)\n+    {\n+      tmp1.a.n[1][2][i] = 5;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i <N; i++)\n+    {\n+      if (tmp1.a.n[1][2][i] != 5)\n+        abort ();\n+    }\n+\n+  /* 2. aligned */\n+  for (i = 3; i < N-1; i++)\n+    {\n+      tmp1.a.n[1][2][i] = 6;\n+    }\n+\n+  /* check results:  */\n+  for (i = 3; i < N-1; i++)\n+    {\n+      if (tmp1.a.n[1][2][i] != 6)\n+        abort ();\n+    }\n+\n+  /* 3. aligned */\n+  for (i = 0; i < N; i++)\n+    {\n+      tmp1.e.n[1][2][i] = 7;\n+    }\n+\n+  /* check results:  */\n+  for (i = 0; i < N; i++)\n+    {\n+      if (tmp1.e.n[1][2][i] != 7)\n+        abort ();\n+    }\n+\n+  /* 4. unaligned */\n+  for (i = 3; i < N-3; i++)\n+    {\n+      tmp1.e.n[1][2][i] = 8;\n+    }\n+ \n+  /* check results:  */\n+  for (i = 3; i <N-3; i++)\n+    {\n+      if (tmp1.e.n[1][2][i] != 8)\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  return main1 ();\n+} \n+\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 3 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "cf5becc4908b0b67f1733cd102e2c7c4a3f520b4", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/x86_64/costmodel-vect-reduc-1char.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-reduc-1char.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-reduc-1char.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fcostmodel-vect-reduc-1char.c?ref=792ed98bb712d700adcbde5549704b74cca59eb2", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"../../tree-vect.h\"\n+\n+#define N 16\n+#define DIFF 242\n+\n+void\n+main1 (unsigned char x, unsigned char max_result, unsigned char min_result)\n+{\n+  int i;\n+  unsigned char ub[N] = {1,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45};\n+  unsigned char uc[N] = {1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n+  unsigned char udiff = 2;\n+  unsigned char umax = x;\n+  unsigned char umin = x;\n+\n+  for (i = 0; i < N; i++) {\n+    udiff += (unsigned char)(ub[i] - uc[i]);\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    umax = umax < uc[i] ? uc[i] : umax;\n+  }\n+\n+  for (i = 0; i < N; i++) {\n+    umin = umin > uc[i] ? uc[i] : umin;\n+  }\n+\n+  /* check results:  */\n+  if (udiff != DIFF)\n+    abort ();\n+  if (umax != max_result)\n+    abort ();\n+  if (umin != min_result)\n+    abort ();\n+}\n+\n+int main (void)\n+{ \n+  check_vect ();\n+  \n+  main1 (100, 100, 1);\n+  main1 (0, 15, 0);\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail vect_no_int_max } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorization not profitable\" 2 \"vect\" { xfail vect_no_int_max } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "0f80ca535630ef41e65d56a7ea825b2777be91f5", "filename": "gcc/testsuite/gcc.dg/vect/costmodel/x86_64/x86_64-costmodel-vect.exp", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fx86_64-costmodel-vect.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fx86_64-costmodel-vect.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcostmodel%2Fx86_64%2Fx86_64-costmodel-vect.exp?ref=792ed98bb712d700adcbde5549704b74cca59eb2", "patch": "@@ -0,0 +1,70 @@\n+# Copyright (C) 1997, 2004, 2005, 2006 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  \n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# Exit immediately if this isn't a x86 target.\n+if { (![istarget x86_64-*-*] && ![istarget i?86-*-*])\n+     || ![is-effective-target lp64] } then {\n+  return\n+}\n+\n+# Set up flags used for tests that don't specify options.\n+set DEFAULT_VECTCFLAGS \"\"\n+\n+# These flags are used for all targets.\n+lappend DEFAULT_VECTCFLAGS \"-O2\" \"-ftree-vectorize\" \"-fvect-cost-model\"\n+\n+# If the target system supports vector instructions, the default action\n+# for a test is 'run', otherwise it's 'compile'.  Save current default.\n+# Executing vector instructions on a system without hardware vector support\n+# is also disabled by a call to check_vect, but disabling execution here is\n+# more efficient.\n+global dg-do-what-default\n+set save-dg-do-what-default ${dg-do-what-default}\n+\n+lappend DEFAULT_VECTCFLAGS \"-msse2\"\n+set dg-do-what-default run\n+\n+# Initialize `dg'.\n+dg-init\n+\n+lappend DEFAULT_VECTCFLAGS \"-fdump-tree-vect-details\"\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/costmodel-pr*.\\[cS\\]]]  \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/costmodel-vect-*.\\[cS\\]]]  \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n+\n+#### Tests with special options\n+global SAVED_DEFAULT_VECTCFLAGS\n+set SAVED_DEFAULT_VECTCFLAGS $DEFAULT_VECTCFLAGS\n+\n+# -ffast-math tests\n+set DEFAULT_VECTCFLAGS $SAVED_DEFAULT_VECTCFLAGS\n+lappend DEFAULT_VECTCFLAGS \"-ffast-math\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/costmodel-fast-math-vect*.\\[cS\\]]]  \\\n+\t\"\" $DEFAULT_VECTCFLAGS\n+\n+# Clean up.\n+set dg-do-what-default ${save-dg-do-what-default}\n+\n+# All done.\n+dg-finish"}, {"sha": "b4cd79d5b6ddc85c56da68d190fa06b6c722df7c", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 48, "deletions": 8, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=792ed98bb712d700adcbde5549704b74cca59eb2", "patch": "@@ -1,5 +1,5 @@\n /* Analysis Utilities for Loop Vectorization.\n-   Copyright (C) 2003,2004,2005,2006 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Dorit Naishlos <dorit@il.ibm.com>\n \n This file is part of GCC.\n@@ -300,6 +300,9 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n   tree phi;\n   stmt_vec_info stmt_info;\n   bool need_to_vectorize = false;\n+  int min_profitable_iters;\n+  int min_scalar_loop_bound;\n+  unsigned int th;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_analyze_operations ===\");\n@@ -443,8 +446,6 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n \t} /* stmts in bb */\n     } /* bbs */\n \n-  /* TODO: Analyze cost. Decide if worth while to vectorize.  */\n-\n   /* All operations in the loop are either irrelevant (deal with loop\n      control, or dead), or only used outside the loop and can be moved\n      out of the loop (e.g. invariants, inductions).  The loop can be \n@@ -468,16 +469,55 @@ vect_analyze_operations (loop_vec_info loop_vinfo)\n         vectorization_factor, LOOP_VINFO_INT_NITERS (loop_vinfo));\n \n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      && ((LOOP_VINFO_INT_NITERS (loop_vinfo) < vectorization_factor)\n-\t  || (LOOP_VINFO_INT_NITERS (loop_vinfo) <=\n-\t\t((unsigned) (PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND)) \n-\t\t\t\t\t   * vectorization_factor))))\n+      && (LOOP_VINFO_INT_NITERS (loop_vinfo) < vectorization_factor))\n     {\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n-\tfprintf (vect_dump, \"not vectorized: iteration count too small.\");\n+        fprintf (vect_dump, \"not vectorized: iteration count too small.\");\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump,\"not vectorized: iteration count smaller than \"\n+                 \"vectorization factor.\");\n       return false;\n     }\n \n+  /* Analyze cost. Decide if worth while to vectorize.  */\n+\n+  min_profitable_iters = vect_estimate_min_profitable_iters (loop_vinfo);\n+\n+  if (min_profitable_iters < 0)\n+    {\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\n+        fprintf (vect_dump, \"not vectorized: vectorization not profitable.\");\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"not vectorized: vector version will never be \"\n+                 \"profitable.\");\n+      return false;\n+    }\n+\n+  min_scalar_loop_bound = (PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND))\n+                          * vectorization_factor;\n+\n+  /* Use the cost model only if it is more conservative than user specified\n+     threshold.  */\n+\n+  th = (unsigned) min_scalar_loop_bound;\n+  if (min_profitable_iters \n+      && (!min_scalar_loop_bound\n+          || min_profitable_iters > min_scalar_loop_bound))\n+    th = (unsigned) min_profitable_iters;\n+\n+  if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      && LOOP_VINFO_INT_NITERS (loop_vinfo) < th)\n+    {\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOOPS))\t      \n+        fprintf (vect_dump, \"not vectorized: vectorization not \"\n+                 \"profitable.\");\n+      if (vect_print_dump_info (REPORT_DETAILS))\t      \n+        fprintf (vect_dump, \"not vectorized: iteration count smaller than \"\n+                 \"user specified loop bound parameter or minimum \"\n+                 \"profitable iterations (whichever is more conservative).\");\n+      return false;\n+    }  \n+\n   if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       || LOOP_VINFO_INT_NITERS (loop_vinfo) % vectorization_factor != 0\n       || LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo))"}, {"sha": "00e55ed209a028e5994d2c0d672e150e861ecbde", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 536, "deletions": 11, "changes": 547, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=792ed98bb712d700adcbde5549704b74cca59eb2", "patch": "@@ -74,6 +74,490 @@ static void vect_update_inits_of_drs (loop_vec_info, tree);\n static int vect_min_worthwhile_factor (enum tree_code);\n \n \n+/* Function vect_estimate_min_profitable_iters\n+\n+   Return the number of iterations required for the vector version of the\n+   loop to be profitable relative to the cost of the scalar version of the\n+   loop.\n+\n+   TODO: Take profile info into account before making vectorization\n+   decisions, if available.  */\n+\n+int\n+vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo)\n+{\n+  int i;\n+  int min_profitable_iters;\n+  int peel_iters_prologue;\n+  int peel_iters_epilogue;\n+  int vec_inside_cost = 0;\n+  int vec_outside_cost = 0;\n+  int scalar_single_iter_cost = 0;\n+  int vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+  basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n+  int nbbs = loop->num_nodes;\n+\n+  /* Cost model disabled.  */\n+  if (!flag_vect_cost_model)\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"cost model disabled.\");      \n+      return 0;\n+    }\n+\n+  /* Requires loop versioning tests to handle misalignment.\n+     FIXME: Make cost depend on number of stmts in may_misalign list.  */\n+\n+  if (LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo))\n+    {\n+      vec_outside_cost += TARG_COND_BRANCH_COST;\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"cost model: Adding cost of checks for loop \"\n+                 \"versioning.\\n\");\n+    }\n+\n+  /* Requires a prologue loop when peeling to handle misalignment. Add cost of\n+     two guards, one for the peeled loop and one for the vector loop.  */\n+\n+  peel_iters_prologue = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n+  if (peel_iters_prologue)\n+    {\n+      vec_outside_cost += 2 * TARG_COND_BRANCH_COST;\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"cost model: Adding cost of checks for \"\n+                 \"prologue.\\n\");\n+    }\n+\n+ /* Requires an epilogue loop to finish up remaining iterations after vector\n+    loop. Add cost of two guards, one for the peeled loop and one for the\n+    vector loop.  */\n+\n+  if ((peel_iters_prologue < 0)\n+      || !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n+      || LOOP_VINFO_INT_NITERS (loop_vinfo) % vf)\n+    {\n+      vec_outside_cost += 2 * TARG_COND_BRANCH_COST;\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"cost model : Adding cost of checks for \"\n+                 \"epilogue.\\n\");\n+    }\n+\n+  /* Count statements in scalar loop.  Using this as scalar cost for a single\n+     iteration for now.\n+\n+     TODO: Add outer loop support.\n+\n+     TODO: Consider assigning different costs to different scalar\n+     statements.  */\n+\n+  for (i = 0; i < nbbs; i++)\n+    {\n+      block_stmt_iterator si;\n+      basic_block bb = bbs[i];\n+\n+      for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n+        {\n+          tree stmt = bsi_stmt (si);\n+          stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+          if (!STMT_VINFO_RELEVANT_P (stmt_info)\n+              && !STMT_VINFO_LIVE_P (stmt_info))\n+            continue;\n+          scalar_single_iter_cost++;\n+          vec_inside_cost += STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info);\n+          vec_outside_cost += STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info);\n+        }\n+    }\n+\n+  /* Add additional cost for the peeled instructions in prologue and epilogue\n+     loop.\n+\n+     FORNOW: If we dont know the value of peel_iters for prologue or epilogue\n+     at compile-time - we assume the worst.  \n+\n+     TODO: Build an expression that represents peel_iters for prologue and\n+     epilogue to be used in a run-time test.  */\n+\n+  peel_iters_prologue = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n+\n+  if (peel_iters_prologue < 0)\n+    {\n+      peel_iters_prologue = vf - 1;\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"cost model: \"\n+                 \"prologue peel iters set conservatively.\");\n+\n+      /* If peeling for alignment is unknown, loop bound of main loop becomes\n+         unkown.  */\n+      peel_iters_epilogue = vf - 1;\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"cost model: \"\n+                 \"epilogue peel iters set conservatively because \"\n+                 \"peeling for alignment is unknown .\");\n+    }\n+  else \n+    {\n+      if (!LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n+        {\n+          peel_iters_epilogue = vf - 1;\n+          if (vect_print_dump_info (REPORT_DETAILS))\n+            fprintf (vect_dump, \"cost model: \"\n+                     \"epilogue peel iters set conservatively because \"\n+                     \"loop iterations are unknown .\");\n+        }\n+      else      \n+        peel_iters_epilogue = \n+                     (LOOP_VINFO_INT_NITERS (loop_vinfo) - peel_iters_prologue)\n+                     % vf;\n+    }\n+\n+  vec_outside_cost += (peel_iters_prologue * scalar_single_iter_cost)\n+                      + (peel_iters_epilogue * scalar_single_iter_cost);\n+\n+  /* Calculate number of iterations required to make the vector version \n+     profitable, relative to the loop bodies only. The following condition\n+     must hold true: ((SIC*VF)-VIC)*niters > VOC*VF, where\n+     SIC = scalar iteration cost, VIC = vector iteration cost,\n+     VOC = vector outside cost and VF = vectorization factor.  */\n+\n+  if ((scalar_single_iter_cost * vf) > vec_inside_cost)\n+    {\n+      if (vec_outside_cost == 0)\n+        min_profitable_iters = 1;\n+      else\n+        {\n+          min_profitable_iters = (vec_outside_cost * vf)\n+                                 / ((scalar_single_iter_cost * vf)\n+                                    - vec_inside_cost);\n+\n+          if ((scalar_single_iter_cost * vf * min_profitable_iters)\n+              <= ((vec_inside_cost * min_profitable_iters)\n+                  + (vec_outside_cost * vf)))\n+            min_profitable_iters++;\n+        }\n+    }\n+  /* vector version will never be profitable.  */\n+  else\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"cost model: vector iteration cost = %d \"\n+                 \"is divisible by scalar iteration cost = %d by a factor \"\n+                 \"greater than or equal to the vectorization factor = %d .\",\n+                 vec_inside_cost, scalar_single_iter_cost, vf);\n+      return -1;\n+    }\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    {\n+      fprintf (vect_dump, \"Cost model analysis: \\n\");\n+      fprintf (vect_dump, \"  Vector inside of loop cost: %d\\n\",\n+\t       vec_inside_cost);\n+      fprintf (vect_dump, \"  Vector outside of loop cost: %d\\n\",\n+\t       vec_outside_cost);\n+      fprintf (vect_dump, \"  Scalar cost: %d\\n\", scalar_single_iter_cost);\n+      fprintf (vect_dump, \"  prologue iterations: %d\\n\",\n+               peel_iters_prologue);\n+      fprintf (vect_dump, \"  epilogue iterations: %d\\n\",\n+               peel_iters_epilogue);\n+      fprintf (vect_dump, \"  Calculated minimum iters for profitability: %d\\n\",\n+\t       min_profitable_iters);\n+      fprintf (vect_dump, \"  Actual minimum iters for profitability: %d\\n\",\n+\t       min_profitable_iters < vf ? vf : min_profitable_iters);\n+    }\n+\n+  return min_profitable_iters < vf ? vf : min_profitable_iters;\n+}\n+\n+\n+/* TODO: Close dependency between vect_model_*_cost and vectorizable_* \n+   functions. Design better to avoid maintainence issues.  */\n+    \n+/* Function vect_model_reduction_cost.  \n+\n+   Models cost for a reduction operation, including the vector ops \n+   generated within the strip-mine loop, the initial definition before\n+   the loop, and the epilogue code that must be generated.  */\n+\n+static void\n+vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n+\t\t\t   int ncopies)\n+{\n+  int outer_cost = 0;\n+  enum tree_code code;\n+  optab optab;\n+  tree vectype;\n+  tree orig_stmt;\n+  tree reduction_op;\n+  enum machine_mode mode;\n+  tree operation = GIMPLE_STMT_OPERAND (STMT_VINFO_STMT (stmt_info), 1);\n+  int op_type = TREE_CODE_LENGTH (TREE_CODE (operation));\n+\n+  /* Cost of reduction op inside loop.  */\n+  STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) += ncopies * TARG_VEC_STMT_COST;\n+\n+  reduction_op = TREE_OPERAND (operation, op_type-1);\n+  vectype = get_vectype_for_scalar_type (TREE_TYPE (reduction_op));\n+  mode = TYPE_MODE (vectype);\n+  orig_stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n+\n+  if (!orig_stmt) \n+    orig_stmt = STMT_VINFO_STMT (stmt_info);\n+\n+  code = TREE_CODE (GIMPLE_STMT_OPERAND (orig_stmt, 1));\n+\n+  /* Add in cost for initial definition.  */\n+  outer_cost += TARG_VEC_STMT_COST;\n+\n+  /* Determine cost of epilogue code.\n+\n+     We have a reduction operator that will reduce the vector in one statement.\n+     Also requires scalar extract.  */\n+\n+  if (reduc_code < NUM_TREE_CODES) \n+    outer_cost += TARG_VEC_STMT_COST + TARG_VEC_TO_SCALAR_COST;\n+  else \n+    {\n+      int vec_size_in_bits = tree_low_cst (TYPE_SIZE (vectype), 1);\n+      tree bitsize =\n+\tTYPE_SIZE (TREE_TYPE ( GIMPLE_STMT_OPERAND (orig_stmt, 0)));\n+      int element_bitsize = tree_low_cst (bitsize, 1);\n+      int nelements = vec_size_in_bits / element_bitsize;\n+\n+      optab = optab_for_tree_code (code, vectype);\n+\n+      /* We have a whole vector shift available.  */\n+      if (!VECTOR_MODE_P (mode) \n+          || optab->handlers[mode].insn_code == CODE_FOR_nothing)\n+        /* Final reduction via vector shifts and the reduction operator. Also\n+           requires scalar extract.  */\n+\touter_cost += ((exact_log2(nelements) * 2 + 1) * TARG_VEC_STMT_COST); \n+      else\n+\t/* Use extracts and reduction op for final reduction.  For N elements,\n+           we have N extracts and N-1 reduction ops.  */\n+\touter_cost += ((nelements + nelements - 1) * TARG_VEC_STMT_COST);\n+    }\n+\n+  STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info) = outer_cost;\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"vect_model_reduction_cost: inside_cost = %d, \"\n+             \"outside_cost = %d .\", STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info),\n+             STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info));\n+}\n+\n+\n+/* Function vect_model_induction_cost.\n+\n+   Models cost for induction operations.  */\n+\n+static void\n+vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies)\n+{\n+  /* loop cost for vec_loop.  */\n+  STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) = ncopies * TARG_VEC_STMT_COST;\n+  /* prologue cost for vec_init and vec_step.  */\n+  STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info) = 2 * TARG_VEC_STMT_COST;\n+  \n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"vect_model_induction_cost: inside_cost = %d, \"\n+             \"outside_cost = %d .\", STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info),\n+             STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info));\n+}\n+\n+\n+/* Function vect_model_simple_cost.  \n+\n+   Models cost for simple operations, i.e. those that only emit ncopies of a \n+   single op.  Right now, this does not account for multiple insns that could\n+   be generated for the single vector op.  We will handle that shortly.  */\n+\n+static void\n+vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies)\n+{\n+  STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) = ncopies * TARG_VEC_STMT_COST;\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"vect_model_simple_cost: inside_cost = %d, \"\n+             \"outside_cost = %d .\", STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info),\n+             STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info));\n+}\n+\n+\n+/* Function vect_cost_strided_group_size \n+ \n+   For strided load or store, return the group_size only if it is the first\n+   load or store of a group, else return 1.  This ensures that group size is\n+   only returned once per group.  */\n+\n+static int\n+vect_cost_strided_group_size (stmt_vec_info stmt_info)\n+{\n+  tree first_stmt = DR_GROUP_FIRST_DR (stmt_info);\n+\n+  if (first_stmt == STMT_VINFO_STMT (stmt_info))\n+    return DR_GROUP_SIZE (stmt_info);\n+\n+  return 1;\n+}\n+\n+\n+/* Function vect_model_store_cost\n+\n+   Models cost for stores.  In the case of strided accesses, one access\n+   has the overhead of the strided access attributed to it.  */\n+\n+static void\n+vect_model_store_cost (stmt_vec_info stmt_info, int ncopies)\n+{\n+  int cost = 0;\n+  int group_size;\n+\n+  /* Strided access?  */\n+  if (DR_GROUP_FIRST_DR (stmt_info)) \n+    group_size = vect_cost_strided_group_size (stmt_info);\n+  /* Not a strided access.  */\n+  else\n+    group_size = 1;\n+\n+  /* Is this an access in a group of stores, which provide strided access?  \n+     If so, add in the cost of the permutes.  */\n+  if (group_size > 1) \n+    {\n+      /* Uses a high and low interleave operation for each needed permute.  */\n+      cost = ncopies * exact_log2(group_size) * group_size \n+             * TARG_VEC_STMT_COST;\n+\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"vect_model_store_cost: strided group_size = %d .\",\n+                 group_size);\n+\n+    }\n+\n+  /* Costs of the stores.  */\n+  cost += ncopies * TARG_VEC_STORE_COST;\n+\n+  STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) = cost;\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"vect_model_store_cost: inside_cost = %d, \"\n+             \"outside_cost = %d .\", STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info),\n+             STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info));\n+}\n+\n+\n+/* Function vect_model_load_cost\n+\n+   Models cost for loads.  In the case of strided accesses, the last access\n+   has the overhead of the strided access attributed to it.  Since unaligned\n+   accesses are supported for loads, we also account for the costs of the \n+   access scheme chosen.  */\n+\n+static void\n+vect_model_load_cost (stmt_vec_info stmt_info, int ncopies)\n+\t\t \n+{\n+  int inner_cost = 0;\n+  int group_size;\n+  int alignment_support_cheme;\n+  tree first_stmt;\n+  struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info), *first_dr;\n+\n+  /* Strided accesses?  */\n+  first_stmt = DR_GROUP_FIRST_DR (stmt_info);\n+  if (first_stmt)\n+    {\n+      group_size = vect_cost_strided_group_size (stmt_info);\n+      first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n+    }\n+  /* Not a strided access.  */\n+  else\n+    {\n+      group_size = 1;\n+      first_dr = dr;\n+    }\n+\n+  alignment_support_cheme = vect_supportable_dr_alignment (first_dr);\n+\n+  /* Is this an access in a group of loads providing strided access?  \n+     If so, add in the cost of the permutes.  */\n+  if (group_size > 1) \n+    {\n+      /* Uses an even and odd extract operations for each needed permute.  */\n+      inner_cost = ncopies * exact_log2(group_size) * group_size\n+                   * TARG_VEC_STMT_COST;\n+\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"vect_model_load_cost: strided group_size = %d .\",\n+                 group_size);\n+\n+    }\n+\n+  /* The loads themselves.  */\n+  switch (alignment_support_cheme)\n+    {\n+    case dr_aligned:\n+      {\n+        inner_cost += ncopies * TARG_VEC_LOAD_COST;\n+\n+        if (vect_print_dump_info (REPORT_DETAILS))\n+          fprintf (vect_dump, \"vect_model_load_cost: aligned.\");\n+\n+        break;\n+      }\n+    case dr_unaligned_supported:\n+      {\n+        /* Here, we assign an additional cost for the unaligned load.  */\n+        inner_cost += ncopies * TARG_VEC_UNALIGNED_LOAD_COST;\n+\n+        if (vect_print_dump_info (REPORT_DETAILS))\n+          fprintf (vect_dump, \"vect_model_load_cost: unaligned supported by \"\n+                   \"hardware.\");\n+\n+        break;\n+      }\n+    case dr_unaligned_software_pipeline:\n+      {\n+        int outer_cost = 0;\n+\n+        if (vect_print_dump_info (REPORT_DETAILS))\n+          fprintf (vect_dump, \"vect_model_load_cost: unaligned software \"\n+                   \"pipelined.\");\n+\n+        /* Unaligned software pipeline has a load of an address, an initial\n+           load, and possibly a mask operation to \"prime\" the loop. However,\n+           if this is an access in a group of loads, which provide strided\n+           acccess, then the above cost should only be considered for one\n+           access in the group. Inside the loop, there is a load op\n+           and a realignment op.  */\n+\n+        if ((!DR_GROUP_FIRST_DR (stmt_info)) || group_size > 1)\n+          {\n+            outer_cost = 2*TARG_VEC_STMT_COST;\n+            if (targetm.vectorize.builtin_mask_for_load)\n+              outer_cost += TARG_VEC_STMT_COST;\n+          }\n+        \n+        STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info) = outer_cost;\n+\n+        inner_cost += ncopies * (TARG_VEC_LOAD_COST + TARG_VEC_STMT_COST);\n+\n+        break;\n+      }\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info) = inner_cost;\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"vect_model_load_cost: inside_cost = %d, \"\n+             \"outside_cost = %d .\", STMT_VINFO_INSIDE_OF_LOOP_COST (stmt_info),\n+             STMT_VINFO_OUTSIDE_OF_LOOP_COST (stmt_info));\n+\n+}\n+\n+\n /* Function vect_get_new_vect_var.\n \n    Returns a name for a new variable. The current naming scheme appends the \n@@ -1655,6 +2139,7 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = reduc_vec_info_type;\n+      vect_model_reduction_cost (stmt_info, epilog_reduc_code, ncopies);\n       return true;\n     }\n \n@@ -1862,9 +2347,15 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n \n   gcc_assert (ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS));\n \n+  ncopies = (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n+\t     / TYPE_VECTOR_SUBPARTS (vectype_out));\n+\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = call_vec_info_type;\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"=== vectorizable_call ===\");\n+      vect_model_simple_cost (stmt_info, ncopies);\n       return true;\n     }\n \n@@ -1873,8 +2364,6 @@ vectorizable_call (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"transform operation.\");\n \n-  ncopies = (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-\t     / TYPE_VECTOR_SUBPARTS (vectype_out));\n   gcc_assert (ncopies >= 1);\n \n   /* Handle def.  */\n@@ -2302,6 +2791,9 @@ vectorizable_assignment (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = assignment_vec_info_type;\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"=== vectorizable_assignment ===\");\n+      vect_model_simple_cost (stmt_info, ncopies);\n       return true;\n     }\n \n@@ -2392,6 +2884,9 @@ vectorizable_induction (tree phi, block_stmt_iterator *bsi ATTRIBUTE_UNUSED,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = induc_vec_info_type;\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"=== vectorizable_induction ===\");\n+      vect_model_induction_cost (stmt_info, ncopies);\n       return true;\n     }\n \n@@ -2555,6 +3050,9 @@ vectorizable_operation (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = op_vec_info_type;\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"=== vectorizable_operation ===\");\n+      vect_model_simple_cost (stmt_info, ncopies);\n       return true;\n     }\n \n@@ -2772,6 +3270,9 @@ vectorizable_type_demotion (tree stmt, block_stmt_iterator *bsi,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = type_demotion_vec_info_type;\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"=== vectorizable_demotion ===\");\n+      vect_model_simple_cost (stmt_info, ncopies);\n       return true;\n     }\n \n@@ -2932,6 +3433,9 @@ vectorizable_type_promotion (tree stmt, block_stmt_iterator *bsi,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = type_promotion_vec_info_type;\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"=== vectorizable_promotion ===\");\n+      vect_model_simple_cost (stmt_info, 2*ncopies);\n       return true;\n     }\n \n@@ -3252,14 +3756,12 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = store_vec_info_type;\n+      vect_model_store_cost (stmt_info, ncopies);\n       return true;\n     }\n \n   /** Transform.  **/\n \n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"transform store. ncopies = %d\",ncopies);\n-\n   if (strided_store)\n     {\n       first_stmt = DR_GROUP_FIRST_DR (stmt_info);\n@@ -3284,6 +3786,9 @@ vectorizable_store (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n       group_size = 1;\n     }\n   \n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"transform store. ncopies = %d\",ncopies);\n+\n   dr_chain = VEC_alloc (tree, heap, group_size);\n   oprnds = VEC_alloc (tree, heap, group_size);\n \n@@ -3915,14 +4420,15 @@ vectorizable_load (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = load_vec_info_type;\n+      vect_model_load_cost (stmt_info, ncopies);\n       return true;\n     }\n \n-  /** Transform.  **/\n-\n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"transform load.\");\n \n+  /** Transform.  **/\n+\n   if (strided_load)\n     {\n       first_stmt = DR_GROUP_FIRST_DR (stmt_info);\n@@ -4807,6 +5313,8 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio)\n   basic_block preheader;\n   int loop_num;\n   unsigned int th;\n+  int min_scalar_loop_bound;\n+  int min_profitable_iters;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"=== vect_do_peeling_for_loop_bound ===\");\n@@ -4822,11 +5330,28 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio)\n \t\t\t\t   &ratio_mult_vf_name, ratio);\n \n   loop_num  = loop->num; \n-  /* Threshold for vectorized loop.  */\n-  th = (PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND)) * \n-\t\t\tLOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+\n+  /* Analyze cost to set threshhold for vectorized loop.  */\n+  min_profitable_iters = vect_estimate_min_profitable_iters (loop_vinfo);\n+\n+  min_scalar_loop_bound = (PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND))\n+                          * LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+\n+  /* Use the cost model only if it is more conservative than user specified\n+     threshold.  */\n+\n+  th = (unsigned) min_scalar_loop_bound;\n+  if (min_profitable_iters\n+      && (!min_scalar_loop_bound\n+          || min_profitable_iters > min_scalar_loop_bound))\n+    th = (unsigned) min_profitable_iters;\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"vectorization may not be profitable.\");\n+\n   new_loop = slpeel_tree_peel_loop_to_edge (loop, single_exit (loop),\n-\t\t\t\t\t    ratio_mult_vf_name, ni_name, false, th);\n+                                            ratio_mult_vf_name, ni_name, false,\n+                                            th);\n   gcc_assert (new_loop);\n   gcc_assert (loop_num == loop->num);\n #ifdef ENABLE_CHECKING"}, {"sha": "baf699d23f0d59cef882fc881d2233e5880a0ab3", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=792ed98bb712d700adcbde5549704b74cca59eb2", "patch": "@@ -1351,6 +1351,8 @@ new_stmt_vec_info (tree stmt, loop_vec_info loop_vinfo)\n   else\n     STMT_VINFO_DEF_TYPE (res) = vect_loop_def;\n   STMT_VINFO_SAME_ALIGN_REFS (res) = VEC_alloc (dr_p, heap, 5);\n+  STMT_VINFO_INSIDE_OF_LOOP_COST (res) = 0;\n+  STMT_VINFO_OUTSIDE_OF_LOOP_COST (res) = 0;\n   DR_GROUP_FIRST_DR (res) = NULL_TREE;\n   DR_GROUP_NEXT_DR (res) = NULL_TREE;\n   DR_GROUP_SIZE (res) = 0;"}, {"sha": "25299944e4fb8d8997979532308c725b981de792", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/792ed98bb712d700adcbde5549704b74cca59eb2/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=792ed98bb712d700adcbde5549704b74cca59eb2", "patch": "@@ -1,5 +1,5 @@\n /* Loop Vectorization\n-   Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Dorit Naishlos <dorit@il.ibm.com>\n \n This file is part of GCC.\n@@ -268,6 +268,13 @@ typedef struct _stmt_vec_info {\n   /* For loads only, if there is a store with the same location, this field is\n      TRUE.  */\n   bool read_write_dep;\n+\n+  /* Vectorization costs associated with statement.  */\n+  struct  \n+  {\n+    int outside_of_loop;     /* Statements generated outside loop.  */\n+    int inside_of_loop;      /* Statements generated inside loop.  */\n+  } cost;\n } *stmt_vec_info;\n \n /* Access Functions.  */\n@@ -300,6 +307,42 @@ typedef struct _stmt_vec_info {\n #define DR_GROUP_READ_WRITE_DEPENDENCE(S)  (S)->read_write_dep\n \n #define STMT_VINFO_RELEVANT_P(S)          ((S)->relevant != vect_unused_in_loop)\n+#define STMT_VINFO_OUTSIDE_OF_LOOP_COST(S) (S)->cost.outside_of_loop\n+#define STMT_VINFO_INSIDE_OF_LOOP_COST(S)  (S)->cost.inside_of_loop\n+\n+/* These are some defines for the initial implementation of the vectorizer's\n+   cost model.  These will later be target specific hooks.  */\n+\n+/* Cost of conditional branch.  */\n+#ifndef TARG_COND_BRANCH_COST\n+#define TARG_COND_BRANCH_COST        3\n+#endif\n+\n+/* Cost of any vector operation, excluding load, store or vector to scalar\n+   operation.  */ \n+#ifndef TARG_VEC_STMT_COST\n+#define TARG_VEC_STMT_COST           1\n+#endif\n+\n+/* Cost of vector to scalar operation.  */\n+#ifndef TARG_VEC_TO_SCALAR_COST\n+#define TARG_VEC_TO_SCALAR_COST      1\n+#endif\n+\n+/* Cost of aligned vector load.  */\n+#ifndef TARG_VEC_LOAD_COST\n+#define TARG_VEC_LOAD_COST           1\n+#endif\n+\n+/* Cost of misaligned vector load.  */\n+#ifndef TARG_VEC_UNALIGNED_LOAD_COST\n+#define TARG_VEC_UNALIGNED_LOAD_COST 2\n+#endif\n+\n+/* Cost of vector store.  */\n+#ifndef TARG_VEC_STORE_COST\n+#define TARG_VEC_STORE_COST          1\n+#endif\n \n static inline void set_stmt_info (stmt_ann_t ann, stmt_vec_info stmt_info);\n static inline stmt_vec_info vinfo_for_stmt (tree stmt);\n@@ -437,6 +480,7 @@ extern bool vectorizable_condition (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_live_operation (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_reduction (tree, block_stmt_iterator *, tree *);\n extern bool vectorizable_induction (tree, block_stmt_iterator *, tree *);\n+extern int  vect_estimate_min_profitable_iters (loop_vec_info);\n /* Driver for transformation stage.  */\n extern void vect_transform_loop (loop_vec_info);\n "}]}