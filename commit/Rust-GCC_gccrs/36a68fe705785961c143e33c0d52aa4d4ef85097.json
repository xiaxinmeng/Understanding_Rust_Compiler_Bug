{"sha": "36a68fe705785961c143e33c0d52aa4d4ef85097", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZhNjhmZTcwNTc4NTk2MWMxNDNlMzNjMGQ1MmFhNGQ0ZWY4NTA5Nw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-11-15T10:03:41Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-11-15T10:03:41Z"}, "message": "re PR c++/3154 (Tree check: expected class 't', have 'd' (type_decl) in is_aggr_type, at cp/init.c:1435)\n\ncp:\n\tPR g++/3154\n\t* init.c (sort_base_init): Remove unreachable code.\n\t(expand_member_init): Adjust comment to reflect reality. Simplify\n\tand remove unreachable code.\ntestsuite:\n\t* g++.dg/other/init1.C: New test.\n\nFrom-SVN: r47047", "tree": {"sha": "0641d81cf0e6078472b02b99684118322500976f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0641d81cf0e6078472b02b99684118322500976f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36a68fe705785961c143e33c0d52aa4d4ef85097", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36a68fe705785961c143e33c0d52aa4d4ef85097", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36a68fe705785961c143e33c0d52aa4d4ef85097", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36a68fe705785961c143e33c0d52aa4d4ef85097/comments", "author": null, "committer": null, "parents": [{"sha": "f5e99456f19b80978984f781e1d847b90d09b30a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5e99456f19b80978984f781e1d847b90d09b30a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5e99456f19b80978984f781e1d847b90d09b30a"}], "stats": {"total": 220, "additions": 106, "deletions": 114}, "files": [{"sha": "025defa26b90d5bba98450a13cc09201c31e1d59", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a68fe705785961c143e33c0d52aa4d4ef85097/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a68fe705785961c143e33c0d52aa4d4ef85097/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=36a68fe705785961c143e33c0d52aa4d4ef85097", "patch": "@@ -1,3 +1,10 @@\n+2001-11-15  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR g++/3154\n+\t* init.c (sort_base_init): Remove unreachable code.\n+\t(expand_member_init): Adjust comment to reflect reality. Simplify\n+\tand remove unreachable code.\n+\n 2001-11-15  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* cp-tree.h (init_reswords, cxx_init_decl_processing): New."}, {"sha": "fdb3557d2b104ed261558ec73c0057ab010b7203", "filename": "gcc/cp/init.c", "status": "modified", "additions": 67, "deletions": 114, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a68fe705785961c143e33c0d52aa4d4ef85097/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a68fe705785961c143e33c0d52aa4d4ef85097/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=36a68fe705785961c143e33c0d52aa4d4ef85097", "patch": "@@ -557,68 +557,39 @@ sort_base_init (t, base_init_list, rbase_ptr, vbase_ptr)\n   tree vbases = NULL_TREE;\n \n   /* First walk through and splice out vbase and invalid initializers.\n-     Also replace names with binfos.  */\n+     Also replace types with binfos.  */\n \n   last = tree_cons (NULL_TREE, NULL_TREE, base_init_list);\n   for (x = TREE_CHAIN (last); x; x = TREE_CHAIN (x))\n     {\n       tree basetype = TREE_PURPOSE (x);\n-      tree binfo = NULL_TREE;\n+      tree binfo = binfo_or_else (basetype, t);\n+      \n+      if (binfo == NULL_TREE)\n+\t/* BASETYPE might be an inaccessible direct base (because it\n+\t   is also an indirect base).  */\n+\tcontinue;\n \n-      if (basetype == NULL_TREE)\n+      if (TREE_VIA_VIRTUAL (binfo))\n \t{\n-\t  /* Initializer for single base class.  Must not\n-\t     use multiple inheritance or this is ambiguous.  */\n-\t  switch (n_baseclasses)\n-\t    {\n-\t    case 0:\n-\t      cp_error (\"`%T' does not have a base class to initialize\",\n-\t\t\tcurrent_class_type);\n-\t      return;\n-\t    case 1:\n-\t      break;\n-\t    default:\n-\t      cp_error (\"unnamed initializer ambiguous for `%T' which uses multiple inheritance\",\n-\t\t\tcurrent_class_type);\n-\t      return;\n-\t    }\n-\t  binfo = TREE_VEC_ELT (binfos, 0);\n+\t  /* Virtual base classes are special cases.  Their\n+\t     initializers are recorded with this constructor, and they\n+\t     are used when this constructor is the top-level\n+\t     constructor called.  */\n+\t  tree v = binfo_for_vbase (BINFO_TYPE (binfo), t);\n+\t  vbases = tree_cons (v, TREE_VALUE (x), vbases);\n \t}\n-      else if (is_aggr_type (basetype, 1))\n+      else\n \t{\n-\t  binfo = binfo_or_else (basetype, t);\n-\t  if (binfo == NULL_TREE)\n-\t    continue;\n-\n-\t  /* Virtual base classes are special cases.  Their initializers\n-\t     are recorded with this constructor, and they are used when\n-\t     this constructor is the top-level constructor called.  */\n-\t  if (TREE_VIA_VIRTUAL (binfo))\n-\t    {\n-\t      tree v = binfo_for_vbase (BINFO_TYPE (binfo), t);\n-\t      vbases = tree_cons (v, TREE_VALUE (x), vbases);\n-\t      continue;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Otherwise, if it is not an immediate base class, complain.  */\n-\t      for (i = n_baseclasses-1; i >= 0; i--)\n-\t\tif (BINFO_TYPE (binfo) == BINFO_TYPE (TREE_VEC_ELT (binfos, i)))\n-\t\t  break;\n-\t      if (i < 0)\n-\t\t{\n-\t\t  cp_error (\"`%T' is not an immediate base class of `%T'\",\n-\t\t\t    basetype, current_class_type);\n-\t\t  continue;\n-\t\t}\n-\t    }\n+\t  /* Otherwise, it must be an immediate base class.  */\n+\t  my_friendly_assert\n+\t    (same_type_p (BINFO_TYPE (BINFO_INHERITANCE_CHAIN (binfo)),\n+\t\t\t  t), 20011113);\n+\n+\t  TREE_PURPOSE (x) = binfo;\n+\t  TREE_CHAIN (last) = x;\n+\t  last = x;\n \t}\n-      else\n-\tmy_friendly_abort (365);\n-\n-      TREE_PURPOSE (x) = binfo;\n-      TREE_CHAIN (last) = x;\n-      last = x;\n     }\n   TREE_CHAIN (last) = NULL_TREE;\n \n@@ -1039,17 +1010,16 @@ member_init_ok_or_else (field, type, member_name)\n   return 1;\n }\n \n-/* If NAME is a viable field name for the aggregate DECL,\n-   and PARMS is a viable parameter list, then expand an _EXPR\n-   which describes this initialization.\n-\n-   Note that we do not need to chase through the class's base classes\n-   to look for NAME, because if it's in that list, it will be handled\n-   by the constructor for that base class.\n+/* EXP is an expression of aggregate type. NAME is an IDENTIFIER_NODE\n+   which names a field, or it is a _TYPE node or TYPE_DECL which names\n+   a base for that type.  INIT is a parameter list for that field's or\n+   base's constructor.  Check the validity of NAME, and return a\n+   TREE_LIST of the base _TYPE or FIELD_DECL and the INIT. EXP is used\n+   only to get its type.  If NAME is invalid, return NULL_TREE and\n+   issue a diagnostic.\n \n-   We do not yet have a fixed-point finder to instantiate types\n-   being fed to overloaded constructors.  If there is a unique\n-   constructor, then argument types can be got from that one.  */\n+   An old style unnamed direct single base construction is permitted,\n+   where NAME is NULL.  */\n \n tree\n expand_member_init (exp, name, init)\n@@ -1062,80 +1032,63 @@ expand_member_init (exp, name, init)\n     return NULL_TREE;\n \n   type = TYPE_MAIN_VARIANT (TREE_TYPE (exp));\n+  my_friendly_assert (IS_AGGR_TYPE (type), 20011113);\n \n-  if (name && TYPE_P (name))\n+  if (!name)\n     {\n-      basetype = name;\n-      name = TYPE_IDENTIFIER (name);\n+      /* This is an obsolete unnamed base class initializer.  The\n+\t parser will already have warned about its use.  */\n+      switch (CLASSTYPE_N_BASECLASSES (type))\n+\t{\n+\tcase 0:\n+\t  cp_error (\"unnamed initializer for `%T', which has no base classes\",\n+\t\t    type);\n+\t  return NULL_TREE;\n+\tcase 1:\n+\t  basetype = TYPE_BINFO_BASETYPE (type, 0);\n+\t  break;\n+\tdefault:\n+\t  cp_error (\"unnamed initializer for `%T', which uses multiple inheritance\",\n+\t\t    type);\n+\t  return NULL_TREE;\n+      }\n     }\n-  else if (name && TREE_CODE (name) == TYPE_DECL)\n+  else if (TYPE_P (name))\n     {\n-      basetype = TYPE_MAIN_VARIANT (TREE_TYPE (name));\n-      name = DECL_NAME (name);\n+      basetype = name;\n+      name = TYPE_NAME (name);\n     }\n-\n-  if (name == NULL_TREE && IS_AGGR_TYPE (type))\n-    switch (CLASSTYPE_N_BASECLASSES (type))\n-      {\n-      case 0:\n-\terror (\"base class initializer specified, but no base class to initialize\");\n-\treturn NULL_TREE;\n-      case 1:\n-\tbasetype = TYPE_BINFO_BASETYPE (type, 0);\n-\tbreak;\n-      default:\n-\terror (\"initializer for unnamed base class ambiguous\");\n-\tcp_error (\"(type `%T' uses multiple inheritance)\", type);\n-\treturn NULL_TREE;\n-      }\n+  else if (TREE_CODE (name) == TYPE_DECL)\n+    basetype = TYPE_MAIN_VARIANT (TREE_TYPE (name));\n \n   my_friendly_assert (init != NULL_TREE, 0);\n \n-  /* The grammar should not allow fields which have names that are\n-     TYPENAMEs.  Therefore, if the field has a non-NULL TREE_TYPE, we\n-     may assume that this is an attempt to initialize a base class\n-     member of the current type.  Otherwise, it is an attempt to\n-     initialize a member field.  */\n-\n   if (init == void_type_node)\n     init = NULL_TREE;\n \n-  if (name == NULL_TREE || basetype)\n+  if (basetype)\n     {\n-      if (name == NULL_TREE)\n-\t{\n-#if 0\n-\t  if (basetype)\n-\t    name = TYPE_IDENTIFIER (basetype);\n-\t  else\n-\t    {\n-\t      error (\"no base class to initialize\");\n-\t      return;\n-\t    }\n-#endif\n-\t}\n-      else if (basetype != type\n-\t       && ! current_template_parms\n-\t       && ! vec_binfo_member (basetype,\n-\t\t\t\t      TYPE_BINFO_BASETYPES (type))\n-\t       && ! binfo_for_vbase (basetype, type))\n+      if (current_template_parms)\n+\t;\n+      else if (vec_binfo_member (basetype, TYPE_BINFO_BASETYPES (type)))\n+\t/* A direct base.  */;\n+      else if (binfo_for_vbase (basetype, type))\n+\t/* A virtual base.  */;\n+      else\n \t{\n-\t  if (IDENTIFIER_CLASS_VALUE (name))\n-\t    goto try_member;\n \t  if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n-\t    cp_error (\"type `%T' is not an immediate or virtual basetype for `%T'\",\n-\t\t      basetype, type);\n+\t    cp_error (\"type `%D' is not a direct or virtual base of `%T'\",\n+\t\t      name, type);\n \t  else\n-\t    cp_error (\"type `%T' is not an immediate basetype for `%T'\",\n-\t\t      basetype, type);\n+\t    cp_error (\"type `%D' is not a direct base of `%T'\",\n+\t\t      name, type);\n \t  return NULL_TREE;\n \t}\n \n       init = build_tree_list (basetype, init);\n     }\n   else\n     {\n-    try_member:\n       field = lookup_field (type, name, 1, 0);\n \n       if (! member_init_ok_or_else (field, type, name))"}, {"sha": "e544dcc57e8b34e31047247332af76971f89f16f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a68fe705785961c143e33c0d52aa4d4ef85097/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a68fe705785961c143e33c0d52aa4d4ef85097/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=36a68fe705785961c143e33c0d52aa4d4ef85097", "patch": "@@ -1,3 +1,7 @@\n+2001-11-15  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.dg/other/init1.C: New test.\n+\n 2001-11-14  Geoffrey Keating  <geoffk@redhat.com>\n \n \t* gcc.dg/noncompile/920923-1.c: xstormy16 produces an extra error"}, {"sha": "bf4c0794758d31c6bf283ac2d35505a3ab47d21b", "filename": "gcc/testsuite/g++.dg/other/init1.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36a68fe705785961c143e33c0d52aa4d4ef85097/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Finit1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36a68fe705785961c143e33c0d52aa4d4ef85097/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Finit1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Finit1.C?ref=36a68fe705785961c143e33c0d52aa4d4ef85097", "patch": "@@ -0,0 +1,28 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 13 Nov 2001 <nathan@codesourcery.com>\n+\n+// Bug 3154\n+\n+class A {};\n+\n+struct B : A\n+{\n+  typedef A Parent;\n+  \n+  B () : Parent () {};\n+};\n+\n+class T\n+{\n+  typedef int Foo;\n+  T () : Foo () {}\t// { dg-error \"type `T::Foo' is not\" \"\" }\n+};\n+\n+struct S : B\n+{\n+  int Parent;\n+\n+  S () :Parent (1) {}\n+};"}]}