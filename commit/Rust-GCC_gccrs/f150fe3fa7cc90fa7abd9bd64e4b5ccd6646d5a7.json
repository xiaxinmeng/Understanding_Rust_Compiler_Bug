{"sha": "f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE1MGZlM2ZhN2NjOTBmYTdhYmQ5YmQ2NGU0YjVjY2Q2NjQ2ZDVhNw==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2002-11-07T18:01:05Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2002-11-07T18:01:05Z"}, "message": "backport: MarshalledObject.java (equals): Check hashcode first.\n\n        Merge Orp RMI patches from Wu Gansha <gansha.wu@intel.com>\n\t* java/rmi/MarshalledObject.java (equals): Check hashcode first.\n\n\t* java/rmi/server/RMIClassLoader.java (MyClassLoader): Create/Use\n\tannotation.\n\t(loadClass): Take String as codebases.\n\t(getClassAnnotation): Use MyClassLoader annotations.\n\t* java/rmi/server/UnicastRemoteObject.java (UnicastRemoteObject):\n\tcall exportObject(this).\n\n\t* gnu/java/rmi/RMIMarshalledObjectOutputStream.java\n\t(RMIMarshalledObjectOutputStream): set locBytesStream and locStream.\n\t(setAnnotation): Don't set locBytesStream and locStream.\n\t(replaceObject): Removed.\n\t(flush): Don't test locStream.\n\t(getLocBytes): LikeWise.\n\t* gnu/java/rmi/dgc/DGCImpl.java: extends UnicastServerRef.\n\t(leaseCache): New field.\n\t(dirty): Use leaseCache.\n\t(LeaseRecord): New inner class.\n\t* gnu/java/rmi/registry/RegistryImpl.java (RegistryImpl): Don't\n\texplicitly call exportObject().\n\t* gnu/java/rmi/registry/RegistryImpl_Stub.java: set useNewInvoke to\n\tfalse to communicate with Sun JDK130.\n\t* gnu/java/rmi/server/ConnectionRunnerPool.java: Add CPU comment.\n\t* gnu/java/rmi/server/RMIObjectInputStream.java\n\t(UnicastConnectionManager): Removed field.\n\t* gnu/java/rmi/server/RMIObjectOutputStream.java (replaceObject):\n\tUse UnicastServer.getExportedRef().\n\t* gnu/java/rmi/server/UnicastConnection.java (reviveTime): New field.\n\t(expireTime): Likewise.\n\t(CONNECTION_TIMEOUT): Likewise.\n\t(disconnect): Call sock.close().\n\t(isExpired): New method.\n\t(resetTime): Likewise.\n\t(run): Use do while loop and catch Exception for discardConnection().\n\t* gnu/java/rmi/server/UnicastConnectionManager.java: Pool connections.\n\t* gnu/java/rmi/server/UnicastRef.java: Lots of changes.\n\t* gnu/java/rmi/server/UnicastRemoteCall.java: Lots of changes.\n\t* gnu/java/rmi/server/UnicastServer.java (refcache): New field.\n\t(exportObject): Use refcache.\n\t(unexportObject): Likewise.\n\t(getExportedRef): New method.\n\t* gnu/java/rmi/server/UnicastServerRef.java (UnicastServerRef): New\n\tconstructor.\n\t(exportObject): Save manager.serverobj.\n\t(getStub): New method.\n\nFrom-SVN: r58900", "tree": {"sha": "dfca54cc19c9efec9125010fd9fcb7030f24bea4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfca54cc19c9efec9125010fd9fcb7030f24bea4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/comments", "author": null, "committer": null, "parents": [{"sha": "396a80436c733527118877c95bfec72e38401eeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/396a80436c733527118877c95bfec72e38401eeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/396a80436c733527118877c95bfec72e38401eeb"}], "stats": {"total": 793, "additions": 597, "deletions": 196}, "files": [{"sha": "11ec52e2135c0994cbf01efb5f5fc0a014ff7bc0", "filename": "libjava/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "patch": "@@ -1,3 +1,53 @@\n+2002-11-07  Mark Wielaard  <mark@klomp.org>\n+\n+        Merge Orp RMI patches from Wu Gansha <gansha.wu@intel.com>\n+\t* java/rmi/MarshalledObject.java (equals): Check hashcode first.\n+\n+\t* java/rmi/server/RMIClassLoader.java (MyClassLoader): Create/Use\n+\tannotation.\n+\t(loadClass): Take String as codebases.\n+\t(getClassAnnotation): Use MyClassLoader annotations.\n+\t* java/rmi/server/UnicastRemoteObject.java (UnicastRemoteObject):\n+\tcall exportObject(this).\n+\n+\t* gnu/java/rmi/RMIMarshalledObjectOutputStream.java\n+\t(RMIMarshalledObjectOutputStream): set locBytesStream and locStream.\n+\t(setAnnotation): Don't set locBytesStream and locStream.\n+\t(replaceObject): Removed.\n+\t(flush): Don't test locStream.\n+\t(getLocBytes): LikeWise.\n+\t* gnu/java/rmi/dgc/DGCImpl.java: extends UnicastServerRef.\n+\t(leaseCache): New field.\n+\t(dirty): Use leaseCache.\n+\t(LeaseRecord): New inner class.\n+\t* gnu/java/rmi/registry/RegistryImpl.java (RegistryImpl): Don't\n+\texplicitly call exportObject().\n+\t* gnu/java/rmi/registry/RegistryImpl_Stub.java: set useNewInvoke to\n+\tfalse to communicate with Sun JDK130.\n+\t* gnu/java/rmi/server/ConnectionRunnerPool.java: Add CPU comment.\n+\t* gnu/java/rmi/server/RMIObjectInputStream.java\n+\t(UnicastConnectionManager): Removed field.\n+\t* gnu/java/rmi/server/RMIObjectOutputStream.java (replaceObject):\n+\tUse UnicastServer.getExportedRef().\n+\t* gnu/java/rmi/server/UnicastConnection.java (reviveTime): New field.\n+\t(expireTime): Likewise.\n+\t(CONNECTION_TIMEOUT): Likewise.\n+\t(disconnect): Call sock.close().\n+\t(isExpired): New method.\n+\t(resetTime): Likewise.\n+\t(run): Use do while loop and catch Exception for discardConnection().\n+\t* gnu/java/rmi/server/UnicastConnectionManager.java: Pool connections.\n+\t* gnu/java/rmi/server/UnicastRef.java: Lots of changes.\n+\t* gnu/java/rmi/server/UnicastRemoteCall.java: Lots of changes.\n+\t* gnu/java/rmi/server/UnicastServer.java (refcache): New field.\n+\t(exportObject): Use refcache.\n+\t(unexportObject): Likewise.\n+\t(getExportedRef): New method.\n+\t* gnu/java/rmi/server/UnicastServerRef.java (UnicastServerRef): New\n+\tconstructor.\n+\t(exportObject): Save manager.serverobj.\n+\t(getStub): New method.\n+\n 2002-11-07  Mark Wielaard  <mark@klomp.org>\n \n \t* java/lang/reflect/natField.cc (getBoolean): Use getType()."}, {"sha": "a721fc47194cf1e0fc7d2c29238a2f1c57482171", "filename": "libjava/gnu/java/rmi/RMIMarshalledObjectOutputStream.java", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2FRMIMarshalledObjectOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2FRMIMarshalledObjectOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2FRMIMarshalledObjectOutputStream.java?ref=f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "patch": "@@ -61,42 +61,22 @@ public class RMIMarshalledObjectOutputStream extends RMIObjectOutputStream\n   public RMIMarshalledObjectOutputStream(OutputStream objStream) throws IOException\n   {\n     super(objStream);\n+    locBytesStream = new ByteArrayOutputStream(256);\n+    locStream = new ObjectOutputStream(locBytesStream);\n   }\n   \n   //This method overrides RMIObjectOutputStream's.\n   protected void setAnnotation(String annotation) throws IOException{\n-    synchronized(this){\n-      if(locStream == null){\n-\tlocBytesStream = new ByteArrayOutputStream();\n-\tlocStream = new ObjectOutputStream(locBytesStream);\n-      }\n-    }\n     locStream.writeObject(annotation);\n   }\n   \n-  //This method overrides ObjectOutputStream's to replace Remote to RemoteStub \n-  protected Object replaceObject(Object obj) throws IOException\n-  {\n-    if((obj instanceof Remote) && !(obj instanceof RemoteStub))\n-      {\n-\tUnicastServerRef ref = new UnicastServerRef(new ObjID(), 0, null);\n-\ttry{\n-\t  return ref.exportObject((Remote)obj);\n-\t}catch(Exception e){}\n-      }\n-    return obj;\n-  }\n-  \n   public void flush() throws IOException {\n     super.flush();\n-    if(locStream != null)\n-      locStream.flush();\n+    locStream.flush();\n   }\n   \n   public byte[] getLocBytes(){\n-    if(locStream != null)\n-      return locBytesStream.toByteArray();\n-    return null;\n+    return locBytesStream.toByteArray();\n   }\n   \n } // End of RMIMarshalledObjectOutputStream"}, {"sha": "4216b6466baa0ddb3ea722cf669693240aaeba1a", "filename": "libjava/gnu/java/rmi/dgc/DGCImpl.java", "status": "modified", "additions": 56, "deletions": 7, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fdgc%2FDGCImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fdgc%2FDGCImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fdgc%2FDGCImpl.java?ref=f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "patch": "@@ -1,5 +1,5 @@\n /*\n-  Copyright (c) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n+  Copyright (c) 1996, 1997, 1998, 1999, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -46,24 +46,73 @@\n import java.rmi.server.RMISocketFactory;\n import gnu.java.rmi.server.UnicastServerRef;\n \n+import java.util.Hashtable;\n+\n+/**\n+  * I let DGCImpl to extend UnicastServerRef, but not \n+  * UnicastRemoteObject, because UnicastRemoteObject must\n+  * exportObject automatically.\n+  */\n public class DGCImpl\n-\textends UnicastRemoteObject implements DGC {\n+    extends UnicastServerRef implements DGC {\n \n-private static final long leaseValue = 600000L;\n+    private static final long LEASE_VALUE = 600000L;\n+    // leaseCache caches a LeaseRecord associated with a vmid\n+    private Hashtable leaseCache = new Hashtable();\n \n public DGCImpl() throws RemoteException {\n-\tsuper(new UnicastServerRef(new ObjID(ObjID.DGC_ID), 0, RMISocketFactory.getSocketFactory()));\n+    \tsuper(new ObjID(ObjID.DGC_ID), 0, RMISocketFactory.getSocketFactory());\n }\n \n public Lease dirty(ObjID[] ids, long sequenceNum, Lease lease) throws RemoteException {\n \tVMID vmid = lease.getVMID();\n+    \tif (vmid == null)\n+    \t    vmid = new VMID();\n+    \tlong leaseValue = LEASE_VALUE;\n+    \t//long leaseValue = lease.getValue();\n     lease = new Lease(vmid, leaseValue);\n-\tSystem.out.println(\"DGCImpl.dirty - not completely implemented\");\n+        synchronized(leaseCache){\n+            LeaseRecord lr = (LeaseRecord)leaseCache.get(vmid);\n+            if (lr != null)\n+                lr.reset(leaseValue);\n+            else{\n+                lr = new LeaseRecord(vmid, leaseValue);\n+                leaseCache.put(vmid, lr);\n+            }\n+        }\n+        \n \treturn (lease);\n }\n \n public void clean(ObjID[] ids, long sequenceNum, VMID vmid, boolean strong) throws RemoteException {\n-\tSystem.out.println(\"DGCImpl.clean - not implemented\");\n+  // Not implemented\n }\n+    \n+  /**\n+   * LeaseRecord associates a vmid to expireTime.\n+   */\n+  private static class LeaseRecord{\n+    private VMID vmid;\n+    private long expireTime;\n+    \n+    LeaseRecord(VMID vmid, long leaseValue){\n+      this.vmid = vmid;\n+      reset(leaseValue);\n+    }\n+    \n+    // reset expireTime\n+    void reset(long leaseValue){\n+      long l = System.currentTimeMillis();\n+      expireTime = l + leaseValue;\n+    }\n \n-}\n+    boolean isExpired(){\n+      long l = System.currentTimeMillis();\n+      if ( l > expireTime)\n+\treturn true;\n+      return false;\n+    }\n+        \n+  } //End of LeaseRecord\n+\n+} //End of DGCImpl"}, {"sha": "007d5a97de98805a5e22b47b9bb42d0b9230f11e", "filename": "libjava/gnu/java/rmi/registry/RegistryImpl.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fregistry%2FRegistryImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fregistry%2FRegistryImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fregistry%2FRegistryImpl.java?ref=f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "patch": "@@ -64,7 +64,8 @@ public RegistryImpl(int port) throws RemoteException {\n \n public RegistryImpl(int port, RMIClientSocketFactory cf, RMIServerSocketFactory sf) throws RemoteException {\n \tsuper(new UnicastServerRef(new ObjID(ObjID.REGISTRY_ID), port, sf));\n-\t((UnicastServerRef)getRef()).exportObject(this);\n+\t// The following is unnecessary, because UnicastRemoteObject export itself automatically.\n+\t//((UnicastServerRef)getRef()).exportObject(this);\n }\n \n public Remote lookup(String name) throws RemoteException, NotBoundException, AccessException {"}, {"sha": "45e10c490506ca6eb4fa0c967fdb431a45c8fde7", "filename": "libjava/gnu/java/rmi/registry/RegistryImpl_Stub.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fregistry%2FRegistryImpl_Stub.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fregistry%2FRegistryImpl_Stub.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fregistry%2FRegistryImpl_Stub.java?ref=f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "patch": "@@ -67,7 +67,7 @@\n     static {\n         try {\n             java.rmi.server.RemoteRef.class.getMethod(\"invoke\", new java.lang.Class[] { java.rmi.Remote.class, java.lang.reflect.Method.class, java.lang.Object[].class, long.class });\n-            useNewInvoke = true;\n+            useNewInvoke = false;\n             $method_bind_0 = gnu.java.rmi.registry.RegistryImpl.class.getMethod(\"bind\", new java.lang.Class[] {java.lang.String.class, java.rmi.Remote.class});\n             $method_list_1 = gnu.java.rmi.registry.RegistryImpl.class.getMethod(\"list\", new java.lang.Class[] {});\n             $method_lookup_2 = gnu.java.rmi.registry.RegistryImpl.class.getMethod(\"lookup\", new java.lang.Class[] {java.lang.String.class});"}, {"sha": "af7dc0501aef841a5839a3788706c351f9029b2c", "filename": "libjava/gnu/java/rmi/server/ConnectionRunnerPool.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FConnectionRunnerPool.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FConnectionRunnerPool.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FConnectionRunnerPool.java?ref=f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "patch": "@@ -91,6 +91,7 @@ void exit(){\n       \n     }\n   \n+  // Should this value equal to number of CPU?\n   private static int size = 5;\n   private static int max_size = 10;\n   "}, {"sha": "3e862c3c184d43ca97b1bcdc7e4a6c5c96532cf6", "filename": "libjava/gnu/java/rmi/server/RMIObjectInputStream.java", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FRMIObjectInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FRMIObjectInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FRMIObjectInputStream.java?ref=f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "patch": "@@ -1,5 +1,5 @@\n /*\n-  Copyright (c) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n+  Copyright (c) 1996, 1997, 1998, 1999, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -50,23 +50,13 @@\n public class RMIObjectInputStream\n \textends ObjectInputStream {\n \n-UnicastConnectionManager manager;\n-\n-public RMIObjectInputStream(InputStream strm, UnicastConnectionManager man) throws IOException {\n+public RMIObjectInputStream(InputStream strm) throws IOException {\n \tsuper(strm);\n-\tmanager = man;\n \tenableResolveObject(true);\n }\n \n-public RMIObjectInputStream(InputStream strm) throws IOException {\n-\tthis(strm, UnicastConnectionManager.getInstance(0, null));\n-}\n-\n protected Class resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {\n \tString annotation = (String)getAnnotation();\n-\ttry{\n-\t\treturn super.resolveClass(desc);\n-\t}catch(ClassNotFoundException _){};\n \t\n \ttry {\n \t\tif(annotation == null)\n@@ -90,24 +80,23 @@ protected Class resolveProxyClass(String intfs[])\n         throws IOException, ClassNotFoundException\n {\n     String annotation = (String)getAnnotation();\n-    try{\n-\t\treturn super.resolveProxyClass(intfs);\n-\t}catch(ClassNotFoundException _){};\n \t\n     Class clss[] = new Class[intfs.length];\n     if(annotation == null)\n         clss[0] = RMIClassLoader.loadClass(intfs[0]);\n     else\n         clss[0] = RMIClassLoader.loadClass(annotation, intfs[0]);\n+    \n     //assume all interfaces can be loaded by the same classloader\n     ClassLoader loader = clss[0].getClassLoader();\n-    if(loader == null)\n-        for(int i = 1; i < intfs.length; i++)\n-            clss[i] = Class.forName(intfs[i]);    \n-    else\n-        for(int i = 1; i < intfs.length; i++)\n-            clss[i] = loader.loadClass(intfs[i]);    \n+    for (int i = 0; i < intfs.length; i++)\n+        clss[i] = Class.forName(intfs[i], false, loader);\n+        \n+    try {\n     return Proxy.getProxyClass(loader, clss);\n+\t} catch (IllegalArgumentException e) {\n+\t    throw new ClassNotFoundException(null, e);\n+\t}  \n }\n \n protected Object readValue(Class valueClass) throws IOException, ClassNotFoundException {\n@@ -134,4 +123,4 @@ protected Object readValue(Class valueClass) throws IOException, ClassNotFoundEx\n         return readObject();\n }\n \n-}\n\\ No newline at end of file\n+}"}, {"sha": "97ac88aabc145910156d2512577ec6cc5f4e0ab6", "filename": "libjava/gnu/java/rmi/server/RMIObjectOutputStream.java", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FRMIObjectOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FRMIObjectOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FRMIObjectOutputStream.java?ref=f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "patch": "@@ -1,5 +1,5 @@\n /*\n-  Copyright (c) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n+  Copyright (c) 1996, 1997, 1998, 1999, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -72,10 +72,9 @@ protected Object replaceObject(Object obj)\n         throws IOException\n {\n     if((obj instanceof Remote) && !(obj instanceof RemoteStub)){\n-\t    UnicastServerRef ref = new UnicastServerRef(new ObjID(), 0, null);\n-\t\ttry{\n-\t\t    return ref.exportObject((Remote)obj);\n-\t\t}catch(Exception e){}\n+\t    UnicastServerRef ref = UnicastServer.getExportedRef((Remote)obj);\n+\t    if (ref != null)\n+\t\t    return ref.getStub();\n     }\n     return obj;\n }"}, {"sha": "14d28f26c91b6ab015cee8b0c94c56cd32e8a006", "filename": "libjava/gnu/java/rmi/server/UnicastConnection.java", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastConnection.java?ref=f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "patch": "@@ -1,5 +1,5 @@\n /*\n-  Copyright (c) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n+  Copyright (c) 1996, 1997, 1998, 1999, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -61,6 +61,10 @@ public class UnicastConnection\n ObjectInputStream oin;\n ObjectOutputStream oout;\n \n+// reviveTime and expireTime make UnicastConnection pool-able\n+long reviveTime = 0;\n+long expireTime = Long.MAX_VALUE;\n+\n UnicastConnection(UnicastConnectionManager man, Socket sock) {\n \tthis.manager = man;\n \tthis.sock = sock;\n@@ -137,7 +141,7 @@ DataOutputStream getDataOutputStream() throws IOException {\n \n ObjectInputStream getObjectInputStream() throws IOException {\n \tif (oin == null) {\n-\t\toin = new RMIObjectInputStream(din, manager);\n+        oin = new RMIObjectInputStream(din);\n \t}\n \treturn (oin);\n }\n@@ -153,6 +157,7 @@ void disconnect() {\n \ttry {\n \t    if(oout != null)\n \t        oout.close();\n+        sock.close();\n \t}\n \tcatch (IOException _) {\n     }\n@@ -164,17 +169,35 @@ void disconnect() {\n \tsock = null;\n }\n \n+public static final long CONNECTION_TIMEOUT = 10000L;\n+\n+static boolean isExpired(UnicastConnection conn, long l){\n+    if (l <= conn.expireTime )\n+        return false;\n+    return true;\n+}\n+\n+static void resetTime(UnicastConnection conn){\n+    long l = System.currentTimeMillis();\n+    conn.reviveTime = l;\n+    conn.expireTime = l + CONNECTION_TIMEOUT;\n+}\n+\n /**\n  * We run connects on the server. Dispatch it then discard it.\n  */\n public void run() {\n+    do{\n \ttry {\n \t\tUnicastServer.dispatch(this);\n+            //don't discardConnection explicitly, only when\n+            //  exception happens or the connection's expireTime \n+            //  comes\n+        } catch (Exception e ){\n \t\tmanager.discardConnection(this);\n+            break;\n \t}\n-\tcatch (Exception e) {\n-\t\te.printStackTrace();\n-\t}\n+    }while(true);\n }\n \n }"}, {"sha": "d54dcf1d4cd654d2619f419bd49e6a0d00ce13bb", "filename": "libjava/gnu/java/rmi/server/UnicastConnectionManager.java", "status": "modified", "additions": 160, "deletions": 16, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastConnectionManager.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastConnectionManager.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastConnectionManager.java?ref=f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "patch": "@@ -1,5 +1,5 @@\n /*\n-  Copyright (c) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n+  Copyright (c) 1996, 1997, 1998, 1999, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -41,34 +41,59 @@\n import java.rmi.server.RMIServerSocketFactory;\n import java.rmi.server.RMIClientSocketFactory;\n import java.rmi.RemoteException;\n-import gnu.java.rmi.server.UnicastConnection;\n-import java.util.Hashtable;\n-import java.net.Socket;\n-import java.net.ServerSocket;\n import java.io.IOException;\n import java.io.ObjectOutput;\n import java.io.ObjectInput;\n+import java.io.DataInputStream;\n import java.lang.Thread;\n import java.lang.Runnable;\n import java.net.InetAddress;\n+import java.net.Socket;\n+import java.net.ServerSocket;\n import java.net.UnknownHostException;\n \n+import java.util.ArrayList;\n+import java.util.ConcurrentModificationException;\n+import java.util.Enumeration;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+\n+import gnu.java.rmi.server.UnicastConnection;\n+\n public class UnicastConnectionManager\n \timplements Runnable, ProtocolConstants {\n \n private static String localhost;\n // use different maps for server/client type UnicastConnectionManager\n private static Hashtable servers = new Hashtable();\n private static Hashtable clients = new Hashtable();\n+private ArrayList connections; //client connection pool\n \n // make serverThread volatile for poll\n private volatile Thread serverThread;\n private ServerSocket ssock;\n String serverName;\n int serverPort;\n+\n+static private Thread scavenger;\n+\n+// If client and server are in the same VM, serverobj represents server\n+Object serverobj;\n+\n+private static RMISocketFactory defaultSocketFactory = RMISocketFactory.getSocketFactory();\n private RMIServerSocketFactory serverFactory;\n private RMIClientSocketFactory clientFactory;\n \n+// The following is for debug\n+private static int ncsock = 0;    //count of client socket\n+private static int nssock = 0;    //count of server socket\n+private static int ncmanager = 0; //count of client manager\n+private static int nsmanager = 0; //count of server manager\n+\n+private static final boolean debug = false;\n+\n+private static final Object GLOBAL_LOCK = new Object();\n+\n static {\n         try {\n                 //Use host address instead of host name to avoid name resolving issues\n@@ -78,16 +103,73 @@\n         catch (UnknownHostException _) {\n                 localhost = \"localhost\";\n         }\n+        \n+        \n+}\n+\n+//Only one scavenger thread running globally\n+private static void startScavenger(){\n+    scavenger = new Thread(new Runnable(){\n+        public void run(){\n+            if (debug) System.out.println(\"************* start scavenger.\");\n+            boolean liveon = true;\n+            while (liveon){\n+                // Sleep for the expire timeout\n+                try{\n+                    Thread.sleep(UnicastConnection.CONNECTION_TIMEOUT);\n+                }catch(InterruptedException _ie){\n+                    break;\n+                }\n+                liveon = false;\n+                // Scavenge all clients' connections that're expired\n+                Iterator iter = clients.values().iterator();\n+                long l = System.currentTimeMillis();\n+                try{\n+                    while(iter.hasNext()){\n+                        UnicastConnectionManager man = (UnicastConnectionManager)iter.next();\n+                        ArrayList conns = man.connections;\n+                        synchronized(conns) { // is the lock a little coarser?\n+                            for (int last = conns.size() - 1;\n+                                 last >= 0;\n+                                 --last)\n+                            {\n+                                UnicastConnection conn = (UnicastConnection)conns.get(last);\n+                                if (UnicastConnection.isExpired(conn, l)){\n+                                    conns.remove(last);\n+                                    conn.disconnect();\n+                                    conn = null;   \n+                                }else\n+                                    liveon = true; //there're still live connections\n+                            }\n+                        }\n+                    }\n+                }catch(ConcurrentModificationException cme) {\n+                    // handle it lazily\n+                    liveon = true;\n+                }\n+            }\n+            scavenger = null;\n+            if (debug) System.out.println(\"************* exit scavenger.\");\n+        }\n+    });\n+    scavenger.start();\n }\n \n+/**\n+  * Client UnicastConnectionManager constructor\n+  */\n private UnicastConnectionManager(String host, int port, RMIClientSocketFactory csf) {\n \tssock = null;\n \tserverName = host;\n \tserverPort = port;\n \tserverFactory = null;\n \tclientFactory = csf;\n+    connections = new ArrayList();\n }\n \n+/**\n+  * Server UnicastConnectionManager constructor\n+  */\n private UnicastConnectionManager(int port, RMIServerSocketFactory ssf) {\n \ttry {\n \t\tssock = ssf.createServerSocket(port);\n@@ -115,7 +197,7 @@ private UnicastConnectionManager(int port, RMIServerSocketFactory ssf) {\n public static synchronized UnicastConnectionManager getInstance(String host, int port, RMIClientSocketFactory csf) {\n //System.out.println(\"getInstance: \" + host + \",\" + port + \",\" + csf);\n \tif (csf == null) {\n-\t\tcsf = RMISocketFactory.getSocketFactory();\n+        csf = defaultSocketFactory;\n \t}\n \t// change host name to host address to avoid name resolving issues\n \ttry{\n@@ -126,7 +208,17 @@ public static synchronized UnicastConnectionManager getInstance(String host, int\n \tUnicastConnectionManager man = (UnicastConnectionManager)clients.get(key);\n \tif (man == null) {\n \t\tman = new UnicastConnectionManager(host, port, csf);\n+        if (debug) {\n+            ncmanager++;\n+            System.out.println(\"\\n\\n ====== \" + ncmanager + \" client managers.\\n\\n\");\n+        }\n \t\tclients.put(key, man);\n+        \n+        // Detect if client and server are in the same VM, i.e., their keys are equal\n+        UnicastConnectionManager svrman = (UnicastConnectionManager)servers.get(key);\n+        if(svrman != null){ // server and client are in the same VM\n+            man.serverobj = svrman.serverobj;\n+        }\n \t}\n \treturn (man);\n }\n@@ -138,12 +230,16 @@ public static synchronized UnicastConnectionManager getInstance(String host, int\n public static synchronized UnicastConnectionManager getInstance(int port, RMIServerSocketFactory ssf) {\n //System.out.println(\"getInstance: \" + port + \",\" + ssf);\n \tif (ssf == null) {\n-\t\tssf = RMISocketFactory.getSocketFactory();\n+        ssf = defaultSocketFactory;\n \t}\n \tTripleKey key = new TripleKey(localhost, port, ssf);\n \tUnicastConnectionManager man = (UnicastConnectionManager)servers.get(key);\n \tif (man == null) {\n \t\tman = new UnicastConnectionManager(port, ssf);\n+        if (debug) {\n+            nsmanager++;\n+            System.out.println(\"\\n\\n ****** \" + nsmanager + \" server managers.\\n\\n\");\n+        }\n \t\t// The provided port might not be the set port.\n \t\tkey.port = man.serverPort;\n \t\tservers.put(key, man);\n@@ -168,20 +264,53 @@ public UnicastConnection getConnection() throws IOException {\n  */\n private UnicastConnection getServerConnection() throws IOException {\n \tSocket sock = ssock.accept();\n+    sock.setTcpNoDelay(true); //??\n \tUnicastConnection conn = new UnicastConnection(this, sock);\n \tconn.acceptConnection();\n-//System.out.println(\"Server connection \" + conn);\n+    if (debug){\n+        nssock++;\n+        System.out.println(\"\\n\\n ****** \" + nssock + \" server socks.\\n\\n\");\n+    }\n+    //System.out.println(\"Server connection \" + sock);\n \treturn (conn);\n }\n \n /**\n  * Make a conection from this client to the server.\n  */\n private UnicastConnection getClientConnection() throws IOException {\n+    ArrayList conns = connections;\n+    UnicastConnection conn;\n+    \n+    synchronized(conns) {\n+        int nconn = conns.size() - 1;\n+    \n+        // if there're free connections in connection pool\n+        if(nconn >= 0) {\n+            conn = (UnicastConnection)conns.get(nconn);\n+            //Should we check if conn is alive using Ping??\n+            conns.remove(nconn);\n+            \n+            // Check if the connection is already expired\n+            long l = System.currentTimeMillis();\n+            if (!UnicastConnection.isExpired(conn, l)){\n+                return conn;\n+            }else {\n+                conn.disconnect();\n+                conn = null;   \n+            }\n+        }\n+    }\n+    \n \tSocket sock = clientFactory.createSocket(serverName, serverPort);\n-\tUnicastConnection conn = new UnicastConnection(this, sock);\n+    conn = new UnicastConnection(this, sock);\n \tconn.makeConnection(DEFAULT_PROTOCOL);\n-//System.out.println(\"Client connection \" + conn);\n+    \n+    if (debug) {\n+        ncsock++;\n+        System.out.println(\"\\n\\n ====== \" + ncsock + \" client socks.\\n\\n\");\n+    }\n+\n \treturn (conn);\n }\n \n@@ -191,7 +320,19 @@ private UnicastConnection getClientConnection() throws IOException {\n  */\n public void discardConnection(UnicastConnection conn) {\n //System.out.println(\"Discarding connection \" + conn);\n+    //conn.disconnect();\n+    if (ssock != null) //server connection\n \tconn.disconnect();\n+    else {\n+        // To client connection, we'd like to return back to pool\n+        UnicastConnection.resetTime(conn);\n+        //Ensure there're only one scavenger globally\n+        synchronized(GLOBAL_LOCK) {\n+            connections.add(conn); //borrow this lock to garantee thread safety \n+            if (scavenger == null)\n+                startScavenger();\n+        }\n+    }\n }\n \n /**\n@@ -204,6 +345,8 @@ public void startServer() {\n \t\t\treturn;\n \t\t}\n \t\tserverThread = new Thread(this);\n+        // The following is not necessary when java.lang.Thread's constructor do this.\n+        // serverThread.setContextClassLoader(Thread.currentThread().getContextClassLoader());\n \t}\n \tserverThread.start();\n }\n@@ -231,11 +374,11 @@ public void run() {\n //System.out.println(\"Waiting for connection on \" + serverPort);\n \t\t\tUnicastConnection conn = getServerConnection();\n \t\t\t// use a thread pool to improve performance\n-\t\t\t// (new Thread(conn)).start();\n-\t\t\tConnectionRunnerPool.dispatchConnection(conn);\n+            //ConnectionRunnerPool.dispatchConnection(conn);\n+            (new Thread(conn)).start();\n \t\t}\n \t\tcatch (Exception e) {\n-\t\t\t// e.printStackTrace();\n+            e.printStackTrace();\n \t\t}\n \t}\n }\n@@ -254,8 +397,9 @@ void write(ObjectOutput out) throws IOException {\n static UnicastConnectionManager read(ObjectInput in) throws IOException {\n         String host = in.readUTF();\n         int port = in.readInt();\n-\tRMIClientSocketFactory csf = ((RMIObjectInputStream)in).manager.clientFactory;\n-        return (getInstance(host, port, csf));\n+        //RMIClientSocketFactory csf = ((RMIObjectInputStream)in).manager.clientFactory;\n+        //return (getInstance(host, port, csf));\n+        return (getInstance(host, port, null));\n }\n \n }\n@@ -288,7 +432,7 @@ public boolean equals(Object obj) {\n \t\tTripleKey other = (TripleKey)obj;\n \t\tif (this.host.equals(other.host) &&\n \t\t    this.other == other.other &&\n-\t\t    (this.port == other.port || this.port == 0 || other.port == 0)) {\n+            (this.port == other.port /* || this.port == 0 || other.port == 0*/)) {\n \t\t\treturn (true);\n \t\t}\n \t}"}, {"sha": "9ab020db6c3f0e28269e12dfde31f2ce4fdccd9b", "filename": "libjava/gnu/java/rmi/server/UnicastRef.java", "status": "modified", "additions": 51, "deletions": 25, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastRef.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastRef.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastRef.java?ref=f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "patch": "@@ -1,5 +1,5 @@\n /*\n-  Copyright (c) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n+  Copyright (c) 1996, 1997, 1998, 1999, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -62,16 +62,19 @@\n import java.io.DataInputStream;\n import java.io.DataOutputStream;\n \n+import java.lang.reflect.InvocationTargetException;\n+\n public class UnicastRef\n \timplements RemoteRef, ProtocolConstants {\n \n public ObjID objid;\n UnicastConnectionManager manager;\n \n /**\n- * Used by serialization.\n+ * Used by serialization, and let subclass capable of having default constructor\n  */\n-private UnicastRef() {\n+//private \n+UnicastRef() {\n }\n \n public UnicastRef(ObjID objid, String host, int port, RMIClientSocketFactory csf) {\n@@ -84,6 +87,21 @@ public UnicastRef(ObjID objid) {\n }\n \n public Object invoke(Remote obj, Method method, Object[] params, long opnum) throws Exception {\n+    // Check if client and server are in the same VM, then local call can be used to\n+    // replace remote call, but it's somewhat violating remote semantic.\n+    Object svrobj = manager.serverobj;\n+    if(svrobj != null){\n+        //local call\n+\t\tObject ret = null;\n+\t\ttry{\n+\t\t    ret = method.invoke(svrobj, params);\n+\t\t}catch(InvocationTargetException e){\n+\t\t    throw (Exception)e.getTargetException();\n+\t\t}\n+\t\t//System.out.println(\"\\n\\n ***** local call: \" + method + \"\\nreturn: \" + ret + \"\\n\\n\");\n+\t\treturn ret;\n+\t}\n+\t//System.out.println(\"***************** remote call:\" + manager.serverPort);\n \treturn (invokeCommon(obj, method, params, -1, opnum));\n }\n \n@@ -107,18 +125,7 @@ private Object invokeCommon(Remote obj, Method method, Object[] params, int opnu\n \t\tobjid.write(out);\n \t\tout.writeInt(opnum);\n \t\tout.writeLong(hash);\n-\t\t/*\n-\t\tif (params != null) {\n-\t\t\tfor (int i = 0; i < params.length; i++) {\n-\t\t\t\tif (params[i] instanceof UnicastRemoteObject) {\n-\t\t\t\t\tout.writeObject(UnicastRemoteObject.exportObject((UnicastRemoteObject)params[i]));\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tout.writeObject(params[i]);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t*/\n+\t\t\n \t\t// must handle primitive class and their wrapper classes\n \t\tClass clss[] = method.getParameterTypes();\n \t    for(int i = 0; i < clss.length; i++)\n@@ -137,26 +144,30 @@ private Object invokeCommon(Remote obj, Method method, Object[] params, int opnu\n \tUID ack;\n \ttry {\n \t\tdin = conn.getDataInputStream();\n-\t\tif (din.readUnsignedByte() != MESSAGE_CALL_ACK) {\n-\t\t\tthrow new RemoteException(\"Call not acked\");\n+\t\t\n+\t\tif ((returncode = din.readUnsignedByte()) != MESSAGE_CALL_ACK) {\n+\t\t    conn.disconnect();\n+\t\t\tthrow new RemoteException(\"Call not acked:\" + returncode);\n \t\t}\n \n \t\tin = conn.getObjectInputStream();\n-\n \t\treturncode = in.readUnsignedByte();\n \t\tack = UID.read(in);\n-\t\t//returnval = in.readObject();\n+\n \t\tClass cls = method.getReturnType();\n         if(cls == Void.TYPE){\n             returnval = null;\n+            in.readObject();\n         }else\n             returnval = ((RMIObjectInputStream)in).readValue(cls);\n+\n \t}\n \tcatch (IOException e3) {\n+\t    //for debug: e3.printStackTrace();\n \t\tthrow new RemoteException(\"call return failed: \", e3);\n \t}\n \n-    /* if DGCAck is necessary\n+    /* if DGCAck is necessary??\n     //According to RMI wire protocol, send a DGCAck \n     // to indicate receiving return value\n     dout.writeByte(MESSAGE_DGCACK);\n@@ -166,7 +177,7 @@ private Object invokeCommon(Remote obj, Method method, Object[] params, int opnu\n     \n \tmanager.discardConnection(conn);\n \n-\tif (returncode != RETURN_ACK) {\n+\tif (returncode != RETURN_ACK && returnval != null) {\n \t\tthrow (Exception)returnval;\n \t}\n \n@@ -177,23 +188,38 @@ private Object invokeCommon(Remote obj, Method method, Object[] params, int opnu\n  * @deprecated\n  */\n public RemoteCall newCall(RemoteObject obj, Operation[] op, int opnum, long hash) throws RemoteException {\n-\treturn (new UnicastRemoteCall(obj, opnum, hash));\n+    UnicastConnection conn;\n+    \n+\ttry {\n+\t\tconn = manager.getConnection();\n+\t}\n+\tcatch (IOException e1) {\n+\t\tthrow new RemoteException(\"connection failed to host: \" + manager.serverName, e1);\n+\t}\n+\n+    //obj: useless?\n+\n+\treturn (new UnicastRemoteCall(conn, objid, opnum, hash));\n }\n \n /**\n  * @deprecated\n  */\n public void invoke(RemoteCall call) throws Exception {\n \tUnicastRemoteCall c = (UnicastRemoteCall)call;\n-\tObject ret = invokeCommon((Remote)c.getObject(), (Method)null, c.getArguments(), c.getOpnum(), c.getHash());\n-\tc.setReturnValue(ret);\n+\tcall.executeCall();\n }\n \n /**\n  * @deprecated\n  */\n public void done(RemoteCall call) throws RemoteException {\n-\t/* Does nothing */\n+\tUnicastRemoteCall c = (UnicastRemoteCall)call;\n+\ttry{\n+\t    c.done();\n+\t} catch(IOException e){}\n+    UnicastConnection conn = c.getConnection();\n+\tmanager.discardConnection(conn);\n }\n \n public void writeExternal(ObjectOutput out) throws IOException {"}, {"sha": "734002aaa65f4c763b04f63f54560fb7d2afcc49", "filename": "libjava/gnu/java/rmi/server/UnicastRemoteCall.java", "status": "modified", "additions": 109, "deletions": 13, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastRemoteCall.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastRemoteCall.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastRemoteCall.java?ref=f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "patch": "@@ -38,14 +38,24 @@\n package gnu.java.rmi.server;\n \n import java.lang.Exception;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n import java.io.IOException;\n import java.io.ObjectOutput;\n import java.io.ObjectInput;\n import java.io.StreamCorruptedException;\n import java.rmi.server.RemoteCall;\n+import java.rmi.RemoteException;\n+import java.rmi.MarshalException;\n+import java.rmi.UnmarshalException;\n+import java.rmi.server.UID;\n+import java.rmi.server.ObjID;\n+import java.rmi.server.RemoteObject;\n+\n import java.util.Vector;\n \n-public class UnicastRemoteCall implements RemoteCall\n+public class UnicastRemoteCall\n+\timplements RemoteCall, ProtocolConstants\n {\n \n   private UnicastConnection conn;\n@@ -56,6 +66,9 @@ public class UnicastRemoteCall implements RemoteCall\n   private Vector vec;\n   private int ptr;\n \n+  private ObjectOutput oout;\n+  private ObjectInput oin;\n+\n   /**\n    * Incoming call.\n    */\n@@ -67,30 +80,71 @@ public class UnicastRemoteCall implements RemoteCall\n   /**\n    * Outgoing call.\n    */\n-  UnicastRemoteCall(Object obj, int opnum, long hash)\n+  UnicastRemoteCall(UnicastConnection conn, ObjID objid, int opnum, long hash)\n+    throws RemoteException\n   {\n-    this.object = obj;\n+    this.conn = conn;\n     this.opnum = opnum;\n     this.hash = hash;\n+    \n+    // signal the call when constructing\n+    try\n+      {\n+\tDataOutputStream dout = conn.getDataOutputStream();\n+\tdout.write(MESSAGE_CALL);\n+\t\n+\toout = conn.getObjectOutputStream();\n+\tobjid.write(oout);\n+\toout.writeInt(opnum);\n+\toout.writeLong(hash);\n+      }\n+    catch(IOException ex)\n+      {\n+\tthrow new MarshalException(\"Try to write header but failed.\", ex);\n+      }\n   }\n-\n+  \n+  UnicastConnection getConnection()\n+  {\n+    return conn;\n+  }\n+  \n   public ObjectOutput getOutputStream() throws IOException\n   {\n-    vec = new Vector();\n-    return new DummyObjectOutputStream();\n+    if (conn != null)\n+      {\n+\tif(oout == null)\n+\t  return (oout = conn.getObjectOutputStream());\n+\telse\n+\t  return oout;\n+      }\n+    else\n+      {\n+\tvec = new Vector();\n+\treturn (new DummyObjectOutputStream());\n+      }\n   }\n \n   public void releaseOutputStream() throws IOException\n   {\n-    // Does nothing.\n+    if(oout != null)\n+      oout.flush();\n   }\n \n   public ObjectInput getInputStream() throws IOException\n   {\n     if (conn != null)\n-      return conn.getObjectInputStream();\n-    ptr = 0;\n-    return new DummyObjectInputStream();\n+      {\n+\tif(oin == null)\n+\t  return (oin = conn.getObjectInputStream());\n+\telse\n+\t  return oin;\n+      }\n+    else\n+      {\n+\tptr = 0;\n+\treturn (new DummyObjectInputStream());\n+      }\n   }\n \n   public void releaseInputStream() throws IOException\n@@ -104,15 +158,57 @@ public ObjectOutput getResultStream(boolean success)\n     vec = new Vector();\n     return new DummyObjectOutputStream();\n   }\n-\n+  \n   public void executeCall() throws Exception\n   {\n-    throw new Error(\"Not implemented\");\n+    byte returncode;\n+    ObjectInput oin;\n+    try\n+      {\n+\treleaseOutputStream();\n+\tDataInputStream din = conn.getDataInputStream();\n+        if (din.readByte() != MESSAGE_CALL_ACK)\n+\t    throw new RemoteException(\"Call not acked\");\n+\n+        oin = getInputStream();\n+        returncode = oin.readByte();\n+        UID.read(oin);\n+      }\n+    catch(IOException ex)\n+      {\n+        throw new UnmarshalException(\"Try to read header but failed:\", ex);\n+      }\n+    \n+    //check return code\n+    switch(returncode)\n+      {\n+      case RETURN_ACK: //it's ok\n+\treturn;\n+      case RETURN_NACK:\n+\tObject returnobj;\n+\ttry\n+\t  {\n+\t    returnobj = oin.readObject();\n+\t  }\n+\tcatch(Exception ex2)\n+\t  {\n+\t    throw new UnmarshalException\n+\t      (\"Try to read exception object but failed\", ex2);\n+\t  }\n+\t\n+\tif(!(returnobj instanceof Exception))\n+\t  throw new UnmarshalException(\"Should be Exception type here: \"\n+\t\t\t\t       + returnobj);\n+\tthrow (Exception)returnobj;\n+\t\n+      default:\n+\tthrow new UnmarshalException(\"Invalid return code\");\n+      }\n   }\n \n   public void done() throws IOException\n   {\n-    /* Does nothing */\n+    // conn.disconnect();\n   }\n \n   Object returnValue()"}, {"sha": "baa1ef1aa4a2d7c91bad52f462adc105d4d83f8e", "filename": "libjava/gnu/java/rmi/server/UnicastServer.java", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastServer.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastServer.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastServer.java?ref=f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "patch": "@@ -1,5 +1,5 @@\n /*\n-  Copyright (c) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n+  Copyright (c) 1996, 1997, 1998, 1999, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -45,6 +45,7 @@\n import java.net.InetAddress;\n import java.util.Hashtable;\n import java.net.UnknownHostException;\n+import java.rmi.Remote;\n import java.rmi.server.ObjID;\n import java.rmi.server.UnicastRemoteObject;\n import java.rmi.server.UID;\n@@ -56,27 +57,36 @@\n public class UnicastServer\n \timplements ProtocolConstants {\n \n-static private Hashtable objects = new Hashtable();\n+static private Hashtable objects = new Hashtable();  //mapping OBJID to server ref\n+static private Hashtable refcache = new Hashtable(); //mapping obj itself to server ref\n static private DGCImpl dgc;\n \n public static void exportObject(UnicastServerRef obj) {\n \tstartDGC();\n \tobjects.put(obj.objid, obj);\n+\trefcache.put(obj.myself, obj);\n \tobj.manager.startServer();\n }\n \n // FIX ME: I haven't handle force parameter\n public static boolean unexportObject(UnicastServerRef obj, boolean force) {\n \tobjects.remove(obj.objid);\n+\trefcache.remove(obj.myself);\n \tobj.manager.stopServer();\n \treturn true;\n }\n \n+public static UnicastServerRef getExportedRef(Remote remote){\n+    return (UnicastServerRef)refcache.get(remote);\n+}\n+\n private static synchronized void startDGC() {\n \tif (dgc == null) {\n \t\ttry {\n \t\t\tdgc = new DGCImpl();\n-\t\t\t((UnicastServerRef)dgc.getRef()).exportObject(dgc);\n+\t\t\t// Changed DGCImpl to inherit UnicastServerRef directly\n+\t\t\t//((UnicastServerRef)dgc.getRef()).exportObject(dgc);\n+\t\t\tdgc.exportObject(dgc);\n \t\t}\n \t\tcatch (RemoteException e) {\n \t\t\te.printStackTrace();"}, {"sha": "4f64452b1247bd8ee0ce5efb796f0a4e3efeed9f", "filename": "libjava/gnu/java/rmi/server/UnicastServerRef.java", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastServerRef.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastServerRef.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Frmi%2Fserver%2FUnicastServerRef.java?ref=f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "patch": "@@ -1,5 +1,5 @@\n /*\n-  Copyright (c) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n+  Copyright (c) 1996, 1997, 1998, 1999, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -63,6 +63,8 @@\n import java.io.DataOutputStream;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n import java.util.Hashtable;\n \n public class UnicastServerRef\n@@ -71,11 +73,18 @@\n \n final static private Class[] stubprototype = new Class[] { RemoteRef.class };\n \n-Remote myself;\n+Remote myself; //save the remote object itself\n private Skeleton skel;\n private RemoteStub stub;\n private Hashtable methods = new Hashtable();\n \n+/**\n+ * Used by serialization.\n+ */\n+UnicastServerRef()\n+{\n+}\n+\n public UnicastServerRef(ObjID id, int port, RMIServerSocketFactory ssf) {\n \tsuper(id);\n \tmanager = UnicastConnectionManager.getInstance(port, ssf);\n@@ -84,6 +93,9 @@ public UnicastServerRef(ObjID id, int port, RMIServerSocketFactory ssf) {\n public RemoteStub exportObject(Remote obj) throws RemoteException {\n \tif (myself == null) {\n \t\tmyself = obj;\n+\t\t// Save it to server manager, to let client calls in the same VM to issue\n+\t\t//  local call\n+\t\tmanager.serverobj = obj;\n \n \t\t// Find and install the stub\n \t\tClass cls = obj.getClass();\n@@ -112,6 +124,10 @@ public RemoteStub exportObject(Remote remote, Object obj)\n \treturn exportObject(remote);\n }\n \n+public RemoteStub getStub(){\n+    return stub;\n+}\n+\n \n public boolean unexportObject(Remote obj, boolean force) throws RemoteException {\n     // Remove all hashes of methods which may be called."}, {"sha": "9f966b9d9dce59dc07193b83ef339545410c41ed", "filename": "libjava/java/rmi/MarshalledObject.java", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fjava%2Frmi%2FMarshalledObject.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fjava%2Frmi%2FMarshalledObject.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Frmi%2FMarshalledObject.java?ref=f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "patch": "@@ -78,6 +78,10 @@ public boolean equals(Object obj)\n   {\n     if(obj == null || !(obj instanceof MarshalledObject) )\n       return false;\n+\n+    // hashCode even differs, don't do the time-consuming comparisons\n+    if (obj.hashCode() != hash)\n+      return false;\n     \n     MarshalledObject aobj = (MarshalledObject)obj;\n     if (objBytes == null || aobj.objBytes == null)"}, {"sha": "1b00970e44191938db7a681760dbd53bf99a5180", "filename": "libjava/java/rmi/server/RMIClassLoader.java", "status": "modified", "additions": 80, "deletions": 63, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fjava%2Frmi%2Fserver%2FRMIClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fjava%2Frmi%2Fserver%2FRMIClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Frmi%2Fserver%2FRMIClassLoader.java?ref=f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "patch": "@@ -43,39 +43,72 @@\n import java.io.IOException;\n import java.io.DataInputStream;\n import java.net.MalformedURLException;\n-import java.util.StringTokenizer;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Hashtable;\n import java.util.Map;\n+import java.util.StringTokenizer;\n import java.util.WeakHashMap;\n-import java.util.ArrayList;\n \n public class RMIClassLoader\n {\n \n   static private class MyClassLoader extends URLClassLoader\n   {\n+\n+    private MyClassLoader(URL[] urls, ClassLoader parent, String annotation)\n+    {\n+      super(urls, parent);\n+      this.annotation = annotation;\n+    }\n+\n     private MyClassLoader(URL[] urls, ClassLoader parent)\n     {\n       super (urls, parent);\n+      this.annotation = urlToAnnotation(urls);\n     }\n \n-    Class defineClass(String name, byte[] data)\n+    public static String urlToAnnotation(URL[] urls)\n     {\n-      return defineClass(name, data, 0, data.length);\n+      if (urls.length == 0)\n+\treturn null;\n+\n+      StringBuffer annotation = new StringBuffer(64*urls.length);\n+      for(int i = 0; i < urls.length; i++)\n+\t{\n+\t  annotation.append(urls[i].toExternalForm());\n+\t  annotation.append(' ');\n+\t}\n+\n+      return annotation.toString();\n+    }\n+\n+    public final String getClassAnnotation(){\n+      return annotation;\n     }\n+\n+    private final String annotation;\n+\n   }\n \n   private static Map cacheLoaders; //map annotations to loaders\n-  private static Map cacheClasses; //map loader to classes that the loader loaded+\n+  private static Map cacheAnnotations; //map loaders to annotations\n+\n+  //defaultAnnotation is got from system property\n+  // \"java.rmi.server.defaultAnnotation\"\n   private static String defaultAnnotation;\n+  //URL object for defaultAnnotation\n   private static URL defaultCodebase;\n+  //class loader for defaultAnnotation\n   private static MyClassLoader defaultLoader;\n   \n   static\n   {\n-    cacheLoaders = Collections.synchronizedMap(new WeakHashMap(5)); \n-    cacheClasses = Collections.synchronizedMap(new WeakHashMap(5));\n+    // 89 is a nice prime number for Hashtable initial capacity\n+    cacheLoaders = new Hashtable(89);\n+    cacheAnnotations = new Hashtable(89);\n+    \n     defaultAnnotation = System.getProperty(\"java.rmi.server.defaultAnnotation\");\n     try \n       {\n@@ -89,9 +122,8 @@ Class defineClass(String name, byte[] data)\n     if (defaultCodebase != null)\n       {\n         defaultLoader = new MyClassLoader(new URL[]{ defaultCodebase },\n-\t\t\t\t\t  Thread.currentThread().getContextClassLoader());\n+\t\t\t\t\t  null, defaultAnnotation);\n         cacheLoaders.put(defaultAnnotation, defaultLoader);\n-        cacheClasses.put(defaultLoader, Collections.synchronizedMap(new WeakHashMap())); \n       }\n   }\n   \n@@ -104,91 +136,76 @@ public static Class loadClass(String name)\n     return (loadClass(\"\", name));\n   }\n \n-  public static Class loadClass(URL codebase, String name) \n+  public static Class loadClass(String codebases, String name) \n     throws MalformedURLException, ClassNotFoundException \n   {\n-    URL u = new URL(codebase, name + \".class\");\n+    Class c = null;\n+    ClassLoader loader = Thread.currentThread().getContextClassLoader();\n+    //try context class loader first\n     try \n       {\n-\tURLConnection conn = u.openConnection();\n-\tDataInputStream strm = new DataInputStream(conn.getInputStream());\n-\tbyte data[] = new byte[conn.getContentLength()];\n-\tstrm.readFully(data);\n-\treturn (defaultLoader.defineClass(name, data));\n-      }\n-    catch (IOException _) \n-      {\n-\tthrow new ClassNotFoundException(name);\n+\t    c = loader.loadClass(name);       \n       }\n-  }\n-  \n-  public static Class loadClass(String codebases, String name) \n-    throws MalformedURLException, ClassNotFoundException \n-  {\n-    ClassLoader loader = (ClassLoader)cacheLoaders.get(codebases);\n-    if (loader == null)\n+    catch(ClassNotFoundException e) {}\n+\n+    if (c != null)\n+      return c;\n+\n+    if (codebases.length() == 0) //==\"\"\n+      loader = defaultLoader;\n+    else \n       {\n-\tif (codebases != \"\")\n+\tloader = (ClassLoader)cacheLoaders.get(codebases);\n+\tif (loader == null)\n \t  {\n-\t    //codebases are separated by \" \"\n+\t    //create an entry in cacheLoaders mapping a loader to codebases.\n+            \n+\t    // codebases are separated by \" \"\n \t    StringTokenizer tok = new StringTokenizer(codebases, \" \"); \n \t    ArrayList urls = new ArrayList();\n \t    while (tok.hasMoreTokens())\n \t      urls.add(new URL(tok.nextToken()));\n-\t    \n+  \n \t    loader = new MyClassLoader((URL[])urls.toArray(new URL[urls.size()]),\n-\t\t\t\t       Thread.currentThread().getContextClassLoader());\n+\t\t\t\t\tnull, codebases);\n \t    cacheLoaders.put(codebases, loader);\n-\t    cacheClasses.put(loader, Collections.synchronizedMap(new WeakHashMap())); \n-\t  }\n-\telse\n-\t  {\n-\t    //if codebases is empty, construct a classloader \n-\t    // based on current context classloader,\n-\t    // and we won't cache classloader for empty codebases\n-\t    loader = new MyClassLoader(new URL[]{ defaultCodebase },\n-\t\t\t\t       Thread.currentThread().getContextClassLoader());\n \t  }\n       }\n \n-    Class c = null;\n-    Map classes = (Map)cacheClasses.get(loader);\n-    if (classes != null)\n-      {\n-        c = (Class)classes.get(name);\n-        if (c == null)\n-\t  {\n-            c = loader.loadClass(name);\n-            classes.put(name, c); \n-\t  }\n-      }else\n-        c = loader.loadClass(name);\n-    \n-    return c;\n+    return loader != null ? loader.loadClass(name) : Class.forName(name);\n   }\n   \n   public static String getClassAnnotation(Class cl)\n   {\n     ClassLoader loader = cl.getClassLoader();\n-    if (loader == null)\n+    if (loader == null || loader == ClassLoader.getSystemClassLoader())\n       {\n-\tif (defaultCodebase != null)\n-\t  return defaultCodebase.toExternalForm();\n-\telse\n-\t  return null;\n+\treturn null; //??\n+      }\n+\t\n+    if (loader instanceof MyClassLoader)\n+      {\n+\treturn ((MyClassLoader)loader).getClassAnnotation();\n       }\n+\t\n+    String s = (String)cacheAnnotations.get(loader);\n+    if (s != null)\n+      return s;\n+\t    \n     if (loader instanceof URLClassLoader)\n       {\n \tURL[] urls = ((URLClassLoader)loader).getURLs();\n \tif(urls.length == 0)\n \t  return null;\n-\tStringBuffer annotation = new StringBuffer(urls[0].toExternalForm());\n-\tfor(int i = 1; i < urls.length; i++)\n+\n+\tStringBuffer annotation = new StringBuffer(64*urls.length);\n+\tfor(int i = 0; i < urls.length; i++)\n \t  {\n-\t    annotation.append(' ');\n \t    annotation.append(urls[i].toExternalForm());\n+\t    annotation.append(' ');\n \t  }\n-\treturn annotation.toString();\n+\ts = annotation.toString();\n+\tcacheAnnotations.put(loader, s);\n       }\n     return null;\n   }"}, {"sha": "a1febf2dd62708871be3ed14b0d2d545d8325f59", "filename": "libjava/java/rmi/server/RemoteObject.java", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fjava%2Frmi%2Fserver%2FRemoteObject.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fjava%2Frmi%2Fserver%2FRemoteObject.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Frmi%2Fserver%2FRemoteObject.java?ref=f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "patch": "@@ -127,11 +127,11 @@ private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundE\n \t  }\n \tcatch (InstantiationException e1) \n \t  {\n-\t    throw new UnmarshalException(\"failed to create ref\");\n+\t    throw new UnmarshalException(\"failed to create ref\", e1);\n \t  }\n \tcatch (IllegalAccessException e2) \n \t  {\n-\t    throw new UnmarshalException(\"failed to create ref\");\n+\t    throw new UnmarshalException(\"failed to create ref\", e2);\n \t  }\n \tref.readExternal(in);\n       }"}, {"sha": "aefe9701ecd90cc17011cdc47f85ec882c81dd0c", "filename": "libjava/java/rmi/server/UnicastRemoteObject.java", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fjava%2Frmi%2Fserver%2FUnicastRemoteObject.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7/libjava%2Fjava%2Frmi%2Fserver%2FUnicastRemoteObject.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Frmi%2Fserver%2FUnicastRemoteObject.java?ref=f150fe3fa7cc90fa7abd9bd64e4b5ccd6646d5a7", "patch": "@@ -1,5 +1,5 @@\n /*\n-  Copyright (c) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.\n+  Copyright (c) 1996, 1997, 1998, 1999, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -67,16 +67,12 @@ protected UnicastRemoteObject(int port, RMIClientSocketFactory csf, RMIServerSoc\n   //this.csf = csf;\n   //this.ssf = ssf;\n   this.ref = new UnicastServerRef(new ObjID(), port, ssf);\n-  //Should we export it here?\n-  // if we export, we got infinite recursive call:\n-  //  UnicastRemoteObject.<init>->...->UnicastServer.startDGC()->UnicastRemoteObject.<init>->...\n-  //exportObject(this);\n+  exportObject(this);\n }\n \n protected UnicastRemoteObject(RemoteRef ref) throws RemoteException {\n \tsuper((UnicastServerRef)ref);\n-       //Should we export it here?\n-       //exportObject(this);\n+\texportObject(this);\n }\n \n public Object clone() throws CloneNotSupportedException {"}]}