{"sha": "ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI2MWU5YzRkYTcwN2YzYmM3YjE3N2MwYzhmOTJkYWNjZGIxNDJkYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-12-12T23:40:51Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-12-12T23:40:51Z"}, "message": "libgo: Update to weekly.2011-11-18.\n\nFrom-SVN: r182266", "tree": {"sha": "0c68629fac9d7c6f103b401c9063ef00ed259f06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c68629fac9d7c6f103b401c9063ef00ed259f06"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/comments", "author": null, "committer": null, "parents": [{"sha": "6e456f4cf4deee3e2ccd9849286f59b90644c48b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e456f4cf4deee3e2ccd9849286f59b90644c48b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e456f4cf4deee3e2ccd9849286f59b90644c48b"}], "stats": {"total": 10318, "additions": 6346, "deletions": 3972}, "files": [{"sha": "f62ea21e57c1d9e231bb3e113b023e7a9e95d664", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -1,4 +1,4 @@\n-2f4482b89a6b\n+b4a91b693374\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "9701bada7cef70e251b192c04cf3b76cd1e1fbc6", "filename": "libgo/Makefile.am", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -648,7 +648,8 @@ go_math_files = \\\n go_mime_files = \\\n \tgo/mime/grammar.go \\\n \tgo/mime/mediatype.go \\\n-\tgo/mime/type.go\n+\tgo/mime/type.go \\\n+\tgo/mime/type_unix.go\n \n if LIBGO_IS_RTEMS\n go_net_fd_os_file = go/net/fd_select.go\n@@ -770,7 +771,6 @@ go_os_files = \\\n \t$(go_os_dir_file) \\\n \tgo/os/dir.go \\\n \tgo/os/env.go \\\n-\tgo/os/env_unix.go \\\n \tgo/os/error.go \\\n \tgo/os/error_posix.go \\\n \tgo/os/exec.go \\\n@@ -1156,6 +1156,7 @@ go_exp_sql_files = \\\n \tgo/exp/sql/sql.go\n go_exp_ssh_files = \\\n \tgo/exp/ssh/channel.go \\\n+\tgo/exp/ssh/cipher.go \\\n \tgo/exp/ssh/client.go \\\n \tgo/exp/ssh/client_auth.go \\\n \tgo/exp/ssh/common.go \\\n@@ -1164,10 +1165,11 @@ go_exp_ssh_files = \\\n \tgo/exp/ssh/server.go \\\n \tgo/exp/ssh/server_shell.go \\\n \tgo/exp/ssh/session.go \\\n+\tgo/exp/ssh/tcpip.go \\\n \tgo/exp/ssh/transport.go\n go_exp_terminal_files = \\\n-\tgo/exp/terminal/shell.go \\\n-\tgo/exp/terminal/terminal.go\n+\tgo/exp/terminal/terminal.go \\\n+\tgo/exp/terminal/util.go\n go_exp_types_files = \\\n \tgo/exp/types/check.go \\\n \tgo/exp/types/const.go \\\n@@ -1546,6 +1548,7 @@ syscall_netlink_file =\n endif\n \n go_base_syscall_files = \\\n+\tgo/syscall/env_unix.go \\\n \tgo/syscall/libcall_support.go \\\n \tgo/syscall/libcall_posix.go \\\n \tgo/syscall/socket.go \\"}, {"sha": "3d9ed7c1ca0d7905ceb3383532a109a1ed6fda53", "filename": "libgo/Makefile.in", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -1032,7 +1032,8 @@ go_math_files = \\\n go_mime_files = \\\n \tgo/mime/grammar.go \\\n \tgo/mime/mediatype.go \\\n-\tgo/mime/type.go\n+\tgo/mime/type.go \\\n+\tgo/mime/type_unix.go\n \n # By default use select with pipes.  Most systems should have\n # something better.\n@@ -1103,7 +1104,6 @@ go_os_files = \\\n \t$(go_os_dir_file) \\\n \tgo/os/dir.go \\\n \tgo/os/env.go \\\n-\tgo/os/env_unix.go \\\n \tgo/os/error.go \\\n \tgo/os/error_posix.go \\\n \tgo/os/exec.go \\\n@@ -1521,6 +1521,7 @@ go_exp_sql_files = \\\n \n go_exp_ssh_files = \\\n \tgo/exp/ssh/channel.go \\\n+\tgo/exp/ssh/cipher.go \\\n \tgo/exp/ssh/client.go \\\n \tgo/exp/ssh/client_auth.go \\\n \tgo/exp/ssh/common.go \\\n@@ -1529,11 +1530,12 @@ go_exp_ssh_files = \\\n \tgo/exp/ssh/server.go \\\n \tgo/exp/ssh/server_shell.go \\\n \tgo/exp/ssh/session.go \\\n+\tgo/exp/ssh/tcpip.go \\\n \tgo/exp/ssh/transport.go\n \n go_exp_terminal_files = \\\n-\tgo/exp/terminal/shell.go \\\n-\tgo/exp/terminal/terminal.go\n+\tgo/exp/terminal/terminal.go \\\n+\tgo/exp/terminal/util.go\n \n go_exp_types_files = \\\n \tgo/exp/types/check.go \\\n@@ -1890,6 +1892,7 @@ go_unicode_utf8_files = \\\n # Support for netlink sockets and messages.\n @LIBGO_IS_LINUX_TRUE@syscall_netlink_file = go/syscall/netlink_linux.go\n go_base_syscall_files = \\\n+\tgo/syscall/env_unix.go \\\n \tgo/syscall/libcall_support.go \\\n \tgo/syscall/libcall_posix.go \\\n \tgo/syscall/socket.go \\"}, {"sha": "54029cd40fdd2e76a484344d588a1c68b25561c9", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -10,7 +10,6 @@ import (\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n-\t\"os\"\n \t\"strings\"\n \t\"testing\"\n \t\"testing/iotest\"\n@@ -425,9 +424,9 @@ var errorWriterTests = []errorWriterTest{\n \t{0, 1, nil, io.ErrShortWrite},\n \t{1, 2, nil, io.ErrShortWrite},\n \t{1, 1, nil, nil},\n-\t{0, 1, os.EPIPE, os.EPIPE},\n-\t{1, 2, os.EPIPE, os.EPIPE},\n-\t{1, 1, os.EPIPE, os.EPIPE},\n+\t{0, 1, io.ErrClosedPipe, io.ErrClosedPipe},\n+\t{1, 2, io.ErrClosedPipe, io.ErrClosedPipe},\n+\t{1, 1, io.ErrClosedPipe, io.ErrClosedPipe},\n }\n \n func TestWriteErrors(t *testing.T) {"}, {"sha": "e81616ca41894e3b3bba5405e72d5a1525269490", "filename": "libgo/go/builtin/builtin.go", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbuiltin%2Fbuiltin.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -91,6 +91,11 @@ type rune rune\n // invocation.\n type Type int\n \n+// Type1 is here for the purposes of documentation only. It is a stand-in\n+// for any Go type, but represents the same type for any given function\n+// invocation.\n+type Type1 int\n+\n // IntegerType is here for the purposes of documentation only. It is a stand-in\n // for any integer type: int, uint, int8 etc.\n type IntegerType int\n@@ -119,6 +124,11 @@ func append(slice []Type, elems ...Type) []Type\n // len(src) and len(dst).\n func copy(dst, src []Type) int\n \n+// The delete built-in function deletes the element with the specified key\n+// (m[key]) from the map. If there is no such element, delete is a no-op.\n+// If m is nil, delete panics.\n+func delete(m map[Type]Type1, key Type)\n+\n // The len built-in function returns the length of v, according to its type:\n //\tArray: the number of elements in v.\n //\tPointer to array: the number of elements in *v (even if v is nil).\n@@ -171,7 +181,7 @@ func complex(r, i FloatType) ComplexType\n // The return value will be floating point type corresponding to the type of c.\n func real(c ComplexType) FloatType\n \n-// The imaginary built-in function returns the imaginary part of the complex\n+// The imag built-in function returns the imaginary part of the complex\n // number c. The return value will be floating point type corresponding to\n // the type of c.\n func imag(c ComplexType) FloatType"}, {"sha": "21a1a4f5808fee29a7fdc28bd19588a8ebcaa4ed", "filename": "libgo/go/bytes/bytes_test.go", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fbytes%2Fbytes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -662,48 +662,49 @@ func TestRunes(t *testing.T) {\n }\n \n type TrimTest struct {\n-\tf               func([]byte, string) []byte\n+\tf               string\n \tin, cutset, out string\n }\n \n var trimTests = []TrimTest{\n-\t{Trim, \"abba\", \"a\", \"bb\"},\n-\t{Trim, \"abba\", \"ab\", \"\"},\n-\t{TrimLeft, \"abba\", \"ab\", \"\"},\n-\t{TrimRight, \"abba\", \"ab\", \"\"},\n-\t{TrimLeft, \"abba\", \"a\", \"bba\"},\n-\t{TrimRight, \"abba\", \"a\", \"abb\"},\n-\t{Trim, \"<tag>\", \"<>\", \"tag\"},\n-\t{Trim, \"* listitem\", \" *\", \"listitem\"},\n-\t{Trim, `\"quote\"`, `\"`, \"quote\"},\n-\t{Trim, \"\\u2C6F\\u2C6F\\u0250\\u0250\\u2C6F\\u2C6F\", \"\\u2C6F\", \"\\u0250\\u0250\"},\n+\t{\"Trim\", \"abba\", \"a\", \"bb\"},\n+\t{\"Trim\", \"abba\", \"ab\", \"\"},\n+\t{\"TrimLeft\", \"abba\", \"ab\", \"\"},\n+\t{\"TrimRight\", \"abba\", \"ab\", \"\"},\n+\t{\"TrimLeft\", \"abba\", \"a\", \"bba\"},\n+\t{\"TrimRight\", \"abba\", \"a\", \"abb\"},\n+\t{\"Trim\", \"<tag>\", \"<>\", \"tag\"},\n+\t{\"Trim\", \"* listitem\", \" *\", \"listitem\"},\n+\t{\"Trim\", `\"quote\"`, `\"`, \"quote\"},\n+\t{\"Trim\", \"\\u2C6F\\u2C6F\\u0250\\u0250\\u2C6F\\u2C6F\", \"\\u2C6F\", \"\\u0250\\u0250\"},\n \t//empty string tests\n-\t{Trim, \"abba\", \"\", \"abba\"},\n-\t{Trim, \"\", \"123\", \"\"},\n-\t{Trim, \"\", \"\", \"\"},\n-\t{TrimLeft, \"abba\", \"\", \"abba\"},\n-\t{TrimLeft, \"\", \"123\", \"\"},\n-\t{TrimLeft, \"\", \"\", \"\"},\n-\t{TrimRight, \"abba\", \"\", \"abba\"},\n-\t{TrimRight, \"\", \"123\", \"\"},\n-\t{TrimRight, \"\", \"\", \"\"},\n-\t{TrimRight, \"\u263a\\xc0\", \"\u263a\", \"\u263a\\xc0\"},\n+\t{\"Trim\", \"abba\", \"\", \"abba\"},\n+\t{\"Trim\", \"\", \"123\", \"\"},\n+\t{\"Trim\", \"\", \"\", \"\"},\n+\t{\"TrimLeft\", \"abba\", \"\", \"abba\"},\n+\t{\"TrimLeft\", \"\", \"123\", \"\"},\n+\t{\"TrimLeft\", \"\", \"\", \"\"},\n+\t{\"TrimRight\", \"abba\", \"\", \"abba\"},\n+\t{\"TrimRight\", \"\", \"123\", \"\"},\n+\t{\"TrimRight\", \"\", \"\", \"\"},\n+\t{\"TrimRight\", \"\u263a\\xc0\", \"\u263a\", \"\u263a\\xc0\"},\n }\n \n func TestTrim(t *testing.T) {\n \tfor _, tc := range trimTests {\n-\t\tactual := string(tc.f([]byte(tc.in), tc.cutset))\n-\t\tvar name string\n-\t\tswitch tc.f {\n-\t\tcase Trim:\n-\t\t\tname = \"Trim\"\n-\t\tcase TrimLeft:\n-\t\t\tname = \"TrimLeft\"\n-\t\tcase TrimRight:\n-\t\t\tname = \"TrimRight\"\n+\t\tname := tc.f\n+\t\tvar f func([]byte, string) []byte\n+\t\tswitch name {\n+\t\tcase \"Trim\":\n+\t\t\tf = Trim\n+\t\tcase \"TrimLeft\":\n+\t\t\tf = TrimLeft\n+\t\tcase \"TrimRight\":\n+\t\t\tf = TrimRight\n \t\tdefault:\n-\t\t\tt.Error(\"Undefined trim function\")\n+\t\t\tt.Error(\"Undefined trim function %s\", name)\n \t\t}\n+\t\tactual := string(f([]byte(tc.in), tc.cutset))\n \t\tif actual != tc.out {\n \t\t\tt.Errorf(\"%s(%q, %q) = %q; want %q\", name, tc.in, tc.cutset, actual, tc.out)\n \t\t}"}, {"sha": "0ed742c897774af7515f3fad0b41946b0eca42c1", "filename": "libgo/go/compress/lzw/reader.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Freader.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -19,7 +19,6 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"os\"\n )\n \n // Order specifies the bit ordering in an LZW data stream.\n@@ -212,8 +211,10 @@ func (d *decoder) flush() {\n \td.o = 0\n }\n \n+var errClosed = errors.New(\"compress/lzw: reader/writer is closed\")\n+\n func (d *decoder) Close() error {\n-\td.err = os.EINVAL // in case any Reads come along\n+\td.err = errClosed // in case any Reads come along\n \treturn nil\n }\n "}, {"sha": "488ba6428db63703b1f056d81113c98f3c447470", "filename": "libgo/go/compress/lzw/writer.go", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -9,7 +9,6 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n-\t\"os\"\n )\n \n // A writer is a buffered, flushable writer.\n@@ -49,8 +48,9 @@ const (\n type encoder struct {\n \t// w is the writer that compressed bytes are written to.\n \tw writer\n-\t// write, bits, nBits and width are the state for converting a code stream\n-\t// into a byte stream.\n+\t// order, write, bits, nBits and width are the state for\n+\t// converting a code stream into a byte stream.\n+\torder Order\n \twrite func(*encoder, uint32) error\n \tbits  uint32\n \tnBits uint\n@@ -64,7 +64,7 @@ type encoder struct {\n \t// call. It is equal to invalidCode if there was no such call.\n \tsavedCode uint32\n \t// err is the first error encountered during writing. Closing the encoder\n-\t// will make any future Write calls return os.EINVAL.\n+\t// will make any future Write calls return errClosed\n \terr error\n \t// table is the hash table from 20-bit keys to 12-bit values. Each table\n \t// entry contains key<<12|val and collisions resolve by linear probing.\n@@ -191,13 +191,13 @@ loop:\n // flush e's underlying writer.\n func (e *encoder) Close() error {\n \tif e.err != nil {\n-\t\tif e.err == os.EINVAL {\n+\t\tif e.err == errClosed {\n \t\t\treturn nil\n \t\t}\n \t\treturn e.err\n \t}\n-\t// Make any future calls to Write return os.EINVAL.\n-\te.err = os.EINVAL\n+\t// Make any future calls to Write return errClosed.\n+\te.err = errClosed\n \t// Write the savedCode if valid.\n \tif e.savedCode != invalidCode {\n \t\tif err := e.write(e, e.savedCode); err != nil {\n@@ -214,7 +214,7 @@ func (e *encoder) Close() error {\n \t}\n \t// Write the final bits.\n \tif e.nBits > 0 {\n-\t\tif e.write == (*encoder).writeMSB {\n+\t\tif e.order == MSB {\n \t\t\te.bits >>= 24\n \t\t}\n \t\tif err := e.w.WriteByte(uint8(e.bits)); err != nil {\n@@ -250,6 +250,7 @@ func NewWriter(w io.Writer, order Order, litWidth int) io.WriteCloser {\n \tlw := uint(litWidth)\n \treturn &encoder{\n \t\tw:         bw,\n+\t\torder:     order,\n \t\twrite:     write,\n \t\twidth:     1 + lw,\n \t\tlitWidth:  lw,"}, {"sha": "d249a09b295ee5a237aa1da4df5f0bdc17bdd942", "filename": "libgo/go/compress/lzw/writer_test.go", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -50,10 +50,6 @@ func testFile(t *testing.T, fn string, order Order, litWidth int) {\n \t\t\t\treturn\n \t\t\t}\n \t\t\t_, err1 := lzww.Write(b[:n])\n-\t\t\tif err1 == os.EPIPE {\n-\t\t\t\t// Fail, but do not report the error, as some other (presumably reportable) error broke the pipe.\n-\t\t\t\treturn\n-\t\t\t}\n \t\t\tif err1 != nil {\n \t\t\t\tt.Errorf(\"%s (order=%d litWidth=%d): %v\", fn, order, litWidth, err1)\n \t\t\t\treturn"}, {"sha": "a71894da3200ab92258727682f8344bd1a5f47fd", "filename": "libgo/go/compress/zlib/writer_test.go", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -59,10 +59,6 @@ func testLevelDict(t *testing.T, fn string, b0 []byte, level int, d string) {\n \t\t}\n \t\tdefer zlibw.Close()\n \t\t_, err = zlibw.Write(b0)\n-\t\tif err == os.EPIPE {\n-\t\t\t// Fail, but do not report the error, as some other (presumably reported) error broke the pipe.\n-\t\t\treturn\n-\t\t}\n \t\tif err != nil {\n \t\t\tt.Errorf(\"%s (level=%d, dict=%q): %v\", fn, level, d, err)\n \t\t\treturn"}, {"sha": "28752e73613cd18d33d3ec7340b0cf7bde597214", "filename": "libgo/go/crypto/aes/cipher.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Faes%2Fcipher.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -41,7 +41,7 @@ func NewCipher(key []byte) (*Cipher, error) {\n }\n \n // BlockSize returns the AES block size, 16 bytes.\n-// It is necessary to satisfy the Cipher interface in the\n+// It is necessary to satisfy the Block interface in the\n // package \"crypto/cipher\".\n func (c *Cipher) BlockSize() int { return BlockSize }\n "}, {"sha": "94e10f0e267cce2ad76ba9f80c85cb4300208eed", "filename": "libgo/go/crypto/blowfish/cipher.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblowfish%2Fcipher.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -54,7 +54,7 @@ func NewSaltedCipher(key, salt []byte) (*Cipher, error) {\n }\n \n // BlockSize returns the Blowfish block size, 8 bytes.\n-// It is necessary to satisfy the Cipher interface in the\n+// It is necessary to satisfy the Block interface in the\n // package \"crypto/cipher\".\n func (c *Cipher) BlockSize() int { return BlockSize }\n "}, {"sha": "2b2bd4bba6b0e87dbdb1dc7fc2334cf83ce224f4", "filename": "libgo/go/crypto/rand/rand_windows.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_windows.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -28,16 +28,16 @@ func (r *rngReader) Read(b []byte) (n int, err error) {\n \tif r.prov == 0 {\n \t\tconst provType = syscall.PROV_RSA_FULL\n \t\tconst flags = syscall.CRYPT_VERIFYCONTEXT | syscall.CRYPT_SILENT\n-\t\terrno := syscall.CryptAcquireContext(&r.prov, nil, nil, provType, flags)\n-\t\tif errno != 0 {\n+\t\terr := syscall.CryptAcquireContext(&r.prov, nil, nil, provType, flags)\n+\t\tif err != nil {\n \t\t\tr.mu.Unlock()\n-\t\t\treturn 0, os.NewSyscallError(\"CryptAcquireContext\", errno)\n+\t\t\treturn 0, os.NewSyscallError(\"CryptAcquireContext\", err)\n \t\t}\n \t}\n \tr.mu.Unlock()\n-\terrno := syscall.CryptGenRandom(r.prov, uint32(len(b)), &b[0])\n-\tif errno != 0 {\n-\t\treturn 0, os.NewSyscallError(\"CryptGenRandom\", errno)\n+\terr = syscall.CryptGenRandom(r.prov, uint32(len(b)), &b[0])\n+\tif err != nil {\n+\t\treturn 0, os.NewSyscallError(\"CryptGenRandom\", err)\n \t}\n \treturn len(b), nil\n }"}, {"sha": "fc5fe6c65e9cb07633948ee01febce582d6bfd75", "filename": "libgo/go/crypto/rand/util.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcrypto%2Frand%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcrypto%2Frand%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Futil.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -5,16 +5,16 @@\n package rand\n \n import (\n+\t\"errors\"\n \t\"io\"\n \t\"math/big\"\n-\t\"os\"\n )\n \n // Prime returns a number, p, of the given size, such that p is prime\n // with high probability.\n func Prime(rand io.Reader, bits int) (p *big.Int, err error) {\n \tif bits < 1 {\n-\t\terr = os.EINVAL\n+\t\terr = errors.New(\"crypto/rand: prime size must be positive\")\n \t}\n \n \tb := uint(bits % 8)"}, {"sha": "b8fa2737f67e77a9c349ea191ac5cf8b75a922c7", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -93,7 +93,8 @@ func (c *Conn) SetTimeout(nsec int64) error {\n }\n \n // SetReadTimeout sets the time (in nanoseconds) that\n-// Read will wait for data before returning os.EAGAIN.\n+// Read will wait for data before returning a net.Error\n+// with Timeout() == true.\n // Setting nsec == 0 (the default) disables the deadline.\n func (c *Conn) SetReadTimeout(nsec int64) error {\n \treturn c.conn.SetReadTimeout(nsec)\n@@ -737,7 +738,7 @@ func (c *Conn) Write(b []byte) (n int, err error) {\n \treturn c.writeRecord(recordTypeApplicationData, b)\n }\n \n-// Read can be made to time out and return err == os.EAGAIN\n+// Read can be made to time out and return a net.Error with Timeout() == true\n // after a fixed time limit; see SetTimeout and SetReadTimeout.\n func (c *Conn) Read(b []byte) (n int, err error) {\n \tif err = c.Handshake(); err != nil {"}, {"sha": "5438e749ce8b8713a7955617a4444e3947835e83", "filename": "libgo/go/crypto/tls/handshake_messages.go", "status": "modified", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -4,6 +4,8 @@\n \n package tls\n \n+import \"bytes\"\n+\n type clientHelloMsg struct {\n \traw                []byte\n \tvers               uint16\n@@ -18,6 +20,25 @@ type clientHelloMsg struct {\n \tsupportedPoints    []uint8\n }\n \n+func (m *clientHelloMsg) equal(i interface{}) bool {\n+\tm1, ok := i.(*clientHelloMsg)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\n+\treturn bytes.Equal(m.raw, m1.raw) &&\n+\t\tm.vers == m1.vers &&\n+\t\tbytes.Equal(m.random, m1.random) &&\n+\t\tbytes.Equal(m.sessionId, m1.sessionId) &&\n+\t\teqUint16s(m.cipherSuites, m1.cipherSuites) &&\n+\t\tbytes.Equal(m.compressionMethods, m1.compressionMethods) &&\n+\t\tm.nextProtoNeg == m1.nextProtoNeg &&\n+\t\tm.serverName == m1.serverName &&\n+\t\tm.ocspStapling == m1.ocspStapling &&\n+\t\teqUint16s(m.supportedCurves, m1.supportedCurves) &&\n+\t\tbytes.Equal(m.supportedPoints, m1.supportedPoints)\n+}\n+\n func (m *clientHelloMsg) marshal() []byte {\n \tif m.raw != nil {\n \t\treturn m.raw\n@@ -309,6 +330,23 @@ type serverHelloMsg struct {\n \tocspStapling      bool\n }\n \n+func (m *serverHelloMsg) equal(i interface{}) bool {\n+\tm1, ok := i.(*serverHelloMsg)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\n+\treturn bytes.Equal(m.raw, m1.raw) &&\n+\t\tm.vers == m1.vers &&\n+\t\tbytes.Equal(m.random, m1.random) &&\n+\t\tbytes.Equal(m.sessionId, m1.sessionId) &&\n+\t\tm.cipherSuite == m1.cipherSuite &&\n+\t\tm.compressionMethod == m1.compressionMethod &&\n+\t\tm.nextProtoNeg == m1.nextProtoNeg &&\n+\t\teqStrings(m.nextProtos, m1.nextProtos) &&\n+\t\tm.ocspStapling == m1.ocspStapling\n+}\n+\n func (m *serverHelloMsg) marshal() []byte {\n \tif m.raw != nil {\n \t\treturn m.raw\n@@ -463,6 +501,16 @@ type certificateMsg struct {\n \tcertificates [][]byte\n }\n \n+func (m *certificateMsg) equal(i interface{}) bool {\n+\tm1, ok := i.(*certificateMsg)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\n+\treturn bytes.Equal(m.raw, m1.raw) &&\n+\t\teqByteSlices(m.certificates, m1.certificates)\n+}\n+\n func (m *certificateMsg) marshal() (x []byte) {\n \tif m.raw != nil {\n \t\treturn m.raw\n@@ -540,6 +588,16 @@ type serverKeyExchangeMsg struct {\n \tkey []byte\n }\n \n+func (m *serverKeyExchangeMsg) equal(i interface{}) bool {\n+\tm1, ok := i.(*serverKeyExchangeMsg)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\n+\treturn bytes.Equal(m.raw, m1.raw) &&\n+\t\tbytes.Equal(m.key, m1.key)\n+}\n+\n func (m *serverKeyExchangeMsg) marshal() []byte {\n \tif m.raw != nil {\n \t\treturn m.raw\n@@ -571,6 +629,17 @@ type certificateStatusMsg struct {\n \tresponse   []byte\n }\n \n+func (m *certificateStatusMsg) equal(i interface{}) bool {\n+\tm1, ok := i.(*certificateStatusMsg)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\n+\treturn bytes.Equal(m.raw, m1.raw) &&\n+\t\tm.statusType == m1.statusType &&\n+\t\tbytes.Equal(m.response, m1.response)\n+}\n+\n func (m *certificateStatusMsg) marshal() []byte {\n \tif m.raw != nil {\n \t\treturn m.raw\n@@ -622,6 +691,11 @@ func (m *certificateStatusMsg) unmarshal(data []byte) bool {\n \n type serverHelloDoneMsg struct{}\n \n+func (m *serverHelloDoneMsg) equal(i interface{}) bool {\n+\t_, ok := i.(*serverHelloDoneMsg)\n+\treturn ok\n+}\n+\n func (m *serverHelloDoneMsg) marshal() []byte {\n \tx := make([]byte, 4)\n \tx[0] = typeServerHelloDone\n@@ -637,6 +711,16 @@ type clientKeyExchangeMsg struct {\n \tciphertext []byte\n }\n \n+func (m *clientKeyExchangeMsg) equal(i interface{}) bool {\n+\tm1, ok := i.(*clientKeyExchangeMsg)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\n+\treturn bytes.Equal(m.raw, m1.raw) &&\n+\t\tbytes.Equal(m.ciphertext, m1.ciphertext)\n+}\n+\n func (m *clientKeyExchangeMsg) marshal() []byte {\n \tif m.raw != nil {\n \t\treturn m.raw\n@@ -671,6 +755,16 @@ type finishedMsg struct {\n \tverifyData []byte\n }\n \n+func (m *finishedMsg) equal(i interface{}) bool {\n+\tm1, ok := i.(*finishedMsg)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\n+\treturn bytes.Equal(m.raw, m1.raw) &&\n+\t\tbytes.Equal(m.verifyData, m1.verifyData)\n+}\n+\n func (m *finishedMsg) marshal() (x []byte) {\n \tif m.raw != nil {\n \t\treturn m.raw\n@@ -698,6 +792,16 @@ type nextProtoMsg struct {\n \tproto string\n }\n \n+func (m *nextProtoMsg) equal(i interface{}) bool {\n+\tm1, ok := i.(*nextProtoMsg)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\n+\treturn bytes.Equal(m.raw, m1.raw) &&\n+\t\tm.proto == m1.proto\n+}\n+\n func (m *nextProtoMsg) marshal() []byte {\n \tif m.raw != nil {\n \t\treturn m.raw\n@@ -759,6 +863,17 @@ type certificateRequestMsg struct {\n \tcertificateAuthorities [][]byte\n }\n \n+func (m *certificateRequestMsg) equal(i interface{}) bool {\n+\tm1, ok := i.(*certificateRequestMsg)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\n+\treturn bytes.Equal(m.raw, m1.raw) &&\n+\t\tbytes.Equal(m.certificateTypes, m1.certificateTypes) &&\n+\t\teqByteSlices(m.certificateAuthorities, m1.certificateAuthorities)\n+}\n+\n func (m *certificateRequestMsg) marshal() (x []byte) {\n \tif m.raw != nil {\n \t\treturn m.raw\n@@ -859,6 +974,16 @@ type certificateVerifyMsg struct {\n \tsignature []byte\n }\n \n+func (m *certificateVerifyMsg) equal(i interface{}) bool {\n+\tm1, ok := i.(*certificateVerifyMsg)\n+\tif !ok {\n+\t\treturn false\n+\t}\n+\n+\treturn bytes.Equal(m.raw, m1.raw) &&\n+\t\tbytes.Equal(m.signature, m1.signature)\n+}\n+\n func (m *certificateVerifyMsg) marshal() (x []byte) {\n \tif m.raw != nil {\n \t\treturn m.raw\n@@ -902,3 +1027,39 @@ func (m *certificateVerifyMsg) unmarshal(data []byte) bool {\n \n \treturn true\n }\n+\n+func eqUint16s(x, y []uint16) bool {\n+\tif len(x) != len(y) {\n+\t\treturn false\n+\t}\n+\tfor i, v := range x {\n+\t\tif y[i] != v {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func eqStrings(x, y []string) bool {\n+\tif len(x) != len(y) {\n+\t\treturn false\n+\t}\n+\tfor i, v := range x {\n+\t\tif y[i] != v {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+func eqByteSlices(x, y [][]byte) bool {\n+\tif len(x) != len(y) {\n+\t\treturn false\n+\t}\n+\tfor i, v := range x {\n+\t\tif !bytes.Equal(v, y[i]) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}"}, {"sha": "e62a9d581b353b438d8289d8d4ce03bd375facad", "filename": "libgo/go/crypto/tls/handshake_messages_test.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -27,10 +27,12 @@ var tests = []interface{}{\n type testMessage interface {\n \tmarshal() []byte\n \tunmarshal([]byte) bool\n+\tequal(interface{}) bool\n }\n \n func TestMarshalUnmarshal(t *testing.T) {\n \trand := rand.New(rand.NewSource(0))\n+\n \tfor i, iface := range tests {\n \t\tty := reflect.ValueOf(iface).Type()\n \n@@ -54,7 +56,7 @@ func TestMarshalUnmarshal(t *testing.T) {\n \t\t\t}\n \t\t\tm2.marshal() // to fill any marshal cache in the message\n \n-\t\t\tif !reflect.DeepEqual(m1, m2) {\n+\t\t\tif !m1.equal(m2) {\n \t\t\t\tt.Errorf(\"#%d got:%#v want:%#v %x\", i, m2, m1, marshaled)\n \t\t\t\tbreak\n \t\t\t}"}, {"sha": "13073dcee78c453f4788acae5ac99d808929c3aa", "filename": "libgo/go/crypto/tls/root_windows.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Froot_windows.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -12,8 +12,8 @@ import (\n )\n \n func loadStore(roots *x509.CertPool, name string) {\n-\tstore, errno := syscall.CertOpenSystemStore(syscall.InvalidHandle, syscall.StringToUTF16Ptr(name))\n-\tif errno != 0 {\n+\tstore, err := syscall.CertOpenSystemStore(syscall.InvalidHandle, syscall.StringToUTF16Ptr(name))\n+\tif err != nil {\n \t\treturn\n \t}\n "}, {"sha": "3ed05814a3b76163ee0f8774479b46a7d7e5964b", "filename": "libgo/go/crypto/xtea/cipher.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcrypto%2Fxtea%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fcrypto%2Fxtea%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fxtea%2Fcipher.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -44,7 +44,7 @@ func NewCipher(key []byte) (*Cipher, error) {\n }\n \n // BlockSize returns the XTEA block size, 8 bytes.\n-// It is necessary to satisfy the Cipher interface in the\n+// It is necessary to satisfy the Block interface in the\n // package \"crypto/cipher\".\n func (c *Cipher) BlockSize() int { return BlockSize }\n "}, {"sha": "f0c52011a1db594c18eefdee99f698ddca09920e", "filename": "libgo/go/encoding/json/bench_test.go", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fencoding%2Fjson%2Fbench_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fencoding%2Fjson%2Fbench_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fbench_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -0,0 +1,157 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Large data benchmark.\n+// The JSON data is a summary of agl's changes in the\n+// go, webkit, and chromium open source projects.\n+// We benchmark converting between the JSON form\n+// and in-memory data structures.\n+\n+package json\n+\n+import (\n+\t\"bytes\"\n+\t\"compress/gzip\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+type codeResponse struct {\n+\tTree     *codeNode `json:\"tree\"`\n+\tUsername string    `json:\"username\"`\n+}\n+\n+type codeNode struct {\n+\tName     string      `json:\"name\"`\n+\tKids     []*codeNode `json:\"kids\"`\n+\tCLWeight float64     `json:\"cl_weight\"`\n+\tTouches  int         `json:\"touches\"`\n+\tMinT     int64       `json:\"min_t\"`\n+\tMaxT     int64       `json:\"max_t\"`\n+\tMeanT    int64       `json:\"mean_t\"`\n+}\n+\n+var codeJSON []byte\n+var codeStruct codeResponse\n+\n+func codeInit() {\n+\tf, err := os.Open(\"testdata/code.json.gz\")\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\tdefer f.Close()\n+\tgz, err := gzip.NewReader(f)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\tdata, err := ioutil.ReadAll(gz)\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\n+\tcodeJSON = data\n+\n+\tif err := Unmarshal(codeJSON, &codeStruct); err != nil {\n+\t\tpanic(\"unmarshal code.json: \" + err.Error())\n+\t}\n+\n+\tif data, err = Marshal(&codeStruct); err != nil {\n+\t\tpanic(\"marshal code.json: \" + err.Error())\n+\t}\n+\n+\tif !bytes.Equal(data, codeJSON) {\n+\t\tprintln(\"different lengths\", len(data), len(codeJSON))\n+\t\tfor i := 0; i < len(data) && i < len(codeJSON); i++ {\n+\t\t\tif data[i] != codeJSON[i] {\n+\t\t\t\tprintln(\"re-marshal: changed at byte\", i)\n+\t\t\t\tprintln(\"orig: \", string(codeJSON[i-10:i+10]))\n+\t\t\t\tprintln(\"new: \", string(data[i-10:i+10]))\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tpanic(\"re-marshal code.json: different result\")\n+\t}\n+}\n+\n+func BenchmarkCodeEncoder(b *testing.B) {\n+\tif codeJSON == nil {\n+\t\tb.StopTimer()\n+\t\tcodeInit()\n+\t\tb.StartTimer()\n+\t}\n+\tenc := NewEncoder(ioutil.Discard)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tif err := enc.Encode(&codeStruct); err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t}\n+\tb.SetBytes(int64(len(codeJSON)))\n+}\n+\n+func BenchmarkCodeMarshal(b *testing.B) {\n+\tif codeJSON == nil {\n+\t\tb.StopTimer()\n+\t\tcodeInit()\n+\t\tb.StartTimer()\n+\t}\n+\tfor i := 0; i < b.N; i++ {\n+\t\tif _, err := Marshal(&codeStruct); err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t}\n+\tb.SetBytes(int64(len(codeJSON)))\n+}\n+\n+func BenchmarkCodeDecoder(b *testing.B) {\n+\tif codeJSON == nil {\n+\t\tb.StopTimer()\n+\t\tcodeInit()\n+\t\tb.StartTimer()\n+\t}\n+\tvar buf bytes.Buffer\n+\tdec := NewDecoder(&buf)\n+\tvar r codeResponse\n+\tfor i := 0; i < b.N; i++ {\n+\t\tbuf.Write(codeJSON)\n+\t\t// hide EOF\n+\t\tbuf.WriteByte('\\n')\n+\t\tbuf.WriteByte('\\n')\n+\t\tbuf.WriteByte('\\n')\n+\t\tif err := dec.Decode(&r); err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t}\n+\tb.SetBytes(int64(len(codeJSON)))\n+}\n+\n+func BenchmarkCodeUnmarshal(b *testing.B) {\n+\tif codeJSON == nil {\n+\t\tb.StopTimer()\n+\t\tcodeInit()\n+\t\tb.StartTimer()\n+\t}\n+\tfor i := 0; i < b.N; i++ {\n+\t\tvar r codeResponse\n+\t\tif err := Unmarshal(codeJSON, &r); err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t}\n+\tb.SetBytes(int64(len(codeJSON)))\n+}\n+\n+func BenchmarkCodeUnmarshalReuse(b *testing.B) {\n+\tif codeJSON == nil {\n+\t\tb.StopTimer()\n+\t\tcodeInit()\n+\t\tb.StartTimer()\n+\t}\n+\tvar r codeResponse\n+\tfor i := 0; i < b.N; i++ {\n+\t\tif err := Unmarshal(codeJSON, &r); err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t}\n+\tb.SetBytes(int64(len(codeJSON)))\n+}"}, {"sha": "2ea06c50c277985e216ed2eac3d73d498f71ffa4", "filename": "libgo/go/encoding/json/decode.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -227,7 +227,7 @@ func (d *decodeState) value(v reflect.Value) {\n \t\t// d.scan thinks we're still at the beginning of the item.\n \t\t// Feed in an empty string - the shortest, simplest value -\n \t\t// so that it knows we got to the end of the value.\n-\t\tif d.scan.step == stateRedo {\n+\t\tif d.scan.redo {\n \t\t\tpanic(\"redo\")\n \t\t}\n \t\td.scan.step(&d.scan, '\"')\n@@ -381,6 +381,7 @@ func (d *decodeState) array(v reflect.Value) {\n \t\t\td.error(errPhase)\n \t\t}\n \t}\n+\n \tif i < av.Len() {\n \t\tif !sv.IsValid() {\n \t\t\t// Array.  Zero the rest.\n@@ -392,6 +393,9 @@ func (d *decodeState) array(v reflect.Value) {\n \t\t\tsv.SetLen(i)\n \t\t}\n \t}\n+\tif i == 0 && av.Kind() == reflect.Slice && sv.IsNil() {\n+\t\tsv.Set(reflect.MakeSlice(sv.Type(), 0, 0))\n+\t}\n }\n \n // object consumes an object from d.data[d.off-1:], decoding into the value v."}, {"sha": "2661f410e015e138553a696a18360623e5697a83", "filename": "libgo/go/encoding/json/scanner.go", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -80,13 +80,17 @@ type scanner struct {\n \t// on a 64-bit Mac Mini, and it's nicer to read.\n \tstep func(*scanner, int) int\n \n+\t// Reached end of top-level value.\n+\tendTop bool\n+\n \t// Stack of what we're in the middle of - array values, object keys, object values.\n \tparseState []int\n \n \t// Error that happened, if any.\n \terr error\n \n \t// 1-byte redo (see undo method)\n+\tredo      bool\n \tredoCode  int\n \tredoState func(*scanner, int) int\n \n@@ -135,6 +139,8 @@ func (s *scanner) reset() {\n \ts.step = stateBeginValue\n \ts.parseState = s.parseState[0:0]\n \ts.err = nil\n+\ts.redo = false\n+\ts.endTop = false\n }\n \n // eof tells the scanner that the end of input has been reached.\n@@ -143,11 +149,11 @@ func (s *scanner) eof() int {\n \tif s.err != nil {\n \t\treturn scanError\n \t}\n-\tif s.step == stateEndTop {\n+\tif s.endTop {\n \t\treturn scanEnd\n \t}\n \ts.step(s, ' ')\n-\tif s.step == stateEndTop {\n+\tif s.endTop {\n \t\treturn scanEnd\n \t}\n \tif s.err == nil {\n@@ -166,8 +172,10 @@ func (s *scanner) pushParseState(p int) {\n func (s *scanner) popParseState() {\n \tn := len(s.parseState) - 1\n \ts.parseState = s.parseState[0:n]\n+\ts.redo = false\n \tif n == 0 {\n \t\ts.step = stateEndTop\n+\t\ts.endTop = true\n \t} else {\n \t\ts.step = stateEndValue\n \t}\n@@ -269,6 +277,7 @@ func stateEndValue(s *scanner, c int) int {\n \tif n == 0 {\n \t\t// Completed top-level before the current byte.\n \t\ts.step = stateEndTop\n+\t\ts.endTop = true\n \t\treturn stateEndTop(s, c)\n \t}\n \tif c <= ' ' && (c == ' ' || c == '\\t' || c == '\\r' || c == '\\n') {\n@@ -606,16 +615,18 @@ func quoteChar(c int) string {\n // undo causes the scanner to return scanCode from the next state transition.\n // This gives callers a simple 1-byte undo mechanism.\n func (s *scanner) undo(scanCode int) {\n-\tif s.step == stateRedo {\n-\t\tpanic(\"invalid use of scanner\")\n+\tif s.redo {\n+\t\tpanic(\"json: invalid use of scanner\")\n \t}\n \ts.redoCode = scanCode\n \ts.redoState = s.step\n \ts.step = stateRedo\n+\ts.redo = true\n }\n \n // stateRedo helps implement the scanner's 1-byte undo.\n func stateRedo(s *scanner, c int) int {\n+\ts.redo = false\n \ts.step = s.redoState\n \treturn s.redoCode\n }"}, {"sha": "14d850865a673c3d387cd847ee2720a9503a0bff", "filename": "libgo/go/encoding/json/scanner_test.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fscanner_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -186,11 +186,12 @@ func TestNextValueBig(t *testing.T) {\n \t}\n }\n \n+var benchScan scanner\n+\n func BenchmarkSkipValue(b *testing.B) {\n \tinitBig()\n-\tvar scan scanner\n \tfor i := 0; i < b.N; i++ {\n-\t\tnextValue(jsonBig, &scan)\n+\t\tnextValue(jsonBig, &benchScan)\n \t}\n \tb.SetBytes(int64(len(jsonBig)))\n }"}, {"sha": "bcb22afde00e2d1a38c4e17fc7eea01594f6303e", "filename": "libgo/go/encoding/xml/xml_test.go", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -7,7 +7,6 @@ package xml\n import (\n \t\"bytes\"\n \t\"io\"\n-\t\"os\"\n \t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n@@ -43,17 +42,17 @@ var rawTokens = []Token{\n \tCharData([]byte(\"World <>'\\\" \u767d\u9d6c\u7fd4\")),\n \tEndElement{Name{\"\", \"hello\"}},\n \tCharData([]byte(\"\\n  \")),\n-\tStartElement{Name{\"\", \"goodbye\"}, nil},\n+\tStartElement{Name{\"\", \"goodbye\"}, []Attr{}},\n \tEndElement{Name{\"\", \"goodbye\"}},\n \tCharData([]byte(\"\\n  \")),\n \tStartElement{Name{\"\", \"outer\"}, []Attr{{Name{\"foo\", \"attr\"}, \"value\"}, {Name{\"xmlns\", \"tag\"}, \"ns4\"}}},\n \tCharData([]byte(\"\\n    \")),\n-\tStartElement{Name{\"\", \"inner\"}, nil},\n+\tStartElement{Name{\"\", \"inner\"}, []Attr{}},\n \tEndElement{Name{\"\", \"inner\"}},\n \tCharData([]byte(\"\\n  \")),\n \tEndElement{Name{\"\", \"outer\"}},\n \tCharData([]byte(\"\\n  \")),\n-\tStartElement{Name{\"tag\", \"name\"}, nil},\n+\tStartElement{Name{\"tag\", \"name\"}, []Attr{}},\n \tCharData([]byte(\"\\n    \")),\n \tCharData([]byte(\"Some text here.\")),\n \tCharData([]byte(\"\\n  \")),\n@@ -77,17 +76,17 @@ var cookedTokens = []Token{\n \tCharData([]byte(\"World <>'\\\" \u767d\u9d6c\u7fd4\")),\n \tEndElement{Name{\"ns2\", \"hello\"}},\n \tCharData([]byte(\"\\n  \")),\n-\tStartElement{Name{\"ns2\", \"goodbye\"}, nil},\n+\tStartElement{Name{\"ns2\", \"goodbye\"}, []Attr{}},\n \tEndElement{Name{\"ns2\", \"goodbye\"}},\n \tCharData([]byte(\"\\n  \")),\n \tStartElement{Name{\"ns2\", \"outer\"}, []Attr{{Name{\"ns1\", \"attr\"}, \"value\"}, {Name{\"xmlns\", \"tag\"}, \"ns4\"}}},\n \tCharData([]byte(\"\\n    \")),\n-\tStartElement{Name{\"ns2\", \"inner\"}, nil},\n+\tStartElement{Name{\"ns2\", \"inner\"}, []Attr{}},\n \tEndElement{Name{\"ns2\", \"inner\"}},\n \tCharData([]byte(\"\\n  \")),\n \tEndElement{Name{\"ns2\", \"outer\"}},\n \tCharData([]byte(\"\\n  \")),\n-\tStartElement{Name{\"ns3\", \"name\"}, nil},\n+\tStartElement{Name{\"ns3\", \"name\"}, []Attr{}},\n \tCharData([]byte(\"\\n    \")),\n \tCharData([]byte(\"Some text here.\")),\n \tCharData([]byte(\"\\n  \")),\n@@ -105,7 +104,7 @@ var rawTokensAltEncoding = []Token{\n \tCharData([]byte(\"\\n\")),\n \tProcInst{\"xml\", []byte(`version=\"1.0\" encoding=\"x-testing-uppercase\"`)},\n \tCharData([]byte(\"\\n\")),\n-\tStartElement{Name{\"\", \"tag\"}, nil},\n+\tStartElement{Name{\"\", \"tag\"}, []Attr{}},\n \tCharData([]byte(\"value\")),\n \tEndElement{Name{\"\", \"tag\"}},\n }\n@@ -205,7 +204,7 @@ func (d *downCaser) ReadByte() (c byte, err error) {\n \n func (d *downCaser) Read(p []byte) (int, error) {\n \td.t.Fatalf(\"unexpected Read call on downCaser reader\")\n-\treturn 0, os.EINVAL\n+\tpanic(\"unreachable\")\n }\n \n func TestRawTokenAltEncoding(t *testing.T) {"}, {"sha": "f12436618f299e7cc297712a2168b77f970855bd", "filename": "libgo/go/exp/inotify/inotify_linux.go", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Finotify%2Finotify_linux.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -105,9 +105,9 @@ func (w *Watcher) AddWatch(path string, flags uint32) error {\n \t\twatchEntry.flags |= flags\n \t\tflags |= syscall.IN_MASK_ADD\n \t}\n-\twd, errno := syscall.InotifyAddWatch(w.fd, path, flags)\n-\tif wd == -1 {\n-\t\treturn &os.PathError{\"inotify_add_watch\", path, os.Errno(errno)}\n+\twd, err := syscall.InotifyAddWatch(w.fd, path, flags)\n+\tif err != nil {\n+\t\treturn &os.PathError{\"inotify_add_watch\", path, err}\n \t}\n \n \tif !found {\n@@ -139,14 +139,10 @@ func (w *Watcher) RemoveWatch(path string) error {\n // readEvents reads from the inotify file descriptor, converts the\n // received events into Event objects and sends them via the Event channel\n func (w *Watcher) readEvents() {\n-\tvar (\n-\t\tbuf   [syscall.SizeofInotifyEvent * 4096]byte // Buffer for a maximum of 4096 raw events\n-\t\tn     int                                     // Number of bytes read with read()\n-\t\terrno int                                     // Syscall errno\n-\t)\n+\tvar buf [syscall.SizeofInotifyEvent * 4096]byte\n \n \tfor {\n-\t\tn, errno = syscall.Read(w.fd, buf[0:])\n+\t\tn, err := syscall.Read(w.fd, buf[0:])\n \t\t// See if there is a message on the \"done\" channel\n \t\tvar done bool\n \t\tselect {\n@@ -156,16 +152,16 @@ func (w *Watcher) readEvents() {\n \n \t\t// If EOF or a \"done\" message is received\n \t\tif n == 0 || done {\n-\t\t\terrno := syscall.Close(w.fd)\n-\t\t\tif errno == -1 {\n-\t\t\t\tw.Error <- os.NewSyscallError(\"close\", errno)\n+\t\t\terr := syscall.Close(w.fd)\n+\t\t\tif err != nil {\n+\t\t\t\tw.Error <- os.NewSyscallError(\"close\", err)\n \t\t\t}\n \t\t\tclose(w.Event)\n \t\t\tclose(w.Error)\n \t\t\treturn\n \t\t}\n \t\tif n < 0 {\n-\t\t\tw.Error <- os.NewSyscallError(\"read\", errno)\n+\t\t\tw.Error <- os.NewSyscallError(\"read\", err)\n \t\t\tcontinue\n \t\t}\n \t\tif n < syscall.SizeofInotifyEvent {"}, {"sha": "48e281203bead02bd2f197a330c9a0528bd81090", "filename": "libgo/go/exp/sql/convert.go", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fsql%2Fconvert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fsql%2Fconvert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fconvert.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -14,6 +14,21 @@ import (\n \t\"strconv\"\n )\n \n+// subsetTypeArgs takes a slice of arguments from callers of the sql\n+// package and converts them into a slice of the driver package's\n+// \"subset types\".\n+func subsetTypeArgs(args []interface{}) ([]interface{}, error) {\n+\tout := make([]interface{}, len(args))\n+\tfor n, arg := range args {\n+\t\tvar err error\n+\t\tout[n], err = driver.DefaultParameterConverter.ConvertValue(arg)\n+\t\tif err != nil {\n+\t\t\treturn nil, fmt.Errorf(\"sql: converting argument #%d's type: %v\", n+1, err)\n+\t\t}\n+\t}\n+\treturn out, nil\n+}\n+\n // convertAssign copies to dest the value in src, converting it if possible.\n // An error is returned if the copy would result in loss of information.\n // dest should be a pointer type."}, {"sha": "91a388421d17b40724b5660b214bb3b1866a4b6c", "filename": "libgo/go/exp/sql/driver/driver.go", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Fdriver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Fdriver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Fdriver.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -36,19 +36,22 @@ type Driver interface {\n \tOpen(name string) (Conn, error)\n }\n \n-// Execer is an optional interface that may be implemented by a Driver\n-// or a Conn.\n-//\n-// If a Driver does not implement Execer, the sql package's DB.Exec\n-// method first obtains a free connection from its free pool or from\n-// the driver's Open method. Execer should only be implemented by\n-// drivers that can provide a more efficient implementation.\n+// ErrSkip may be returned by some optional interfaces' methods to\n+// indicate at runtime that the fast path is unavailable and the sql\n+// package should continue as if the optional interface was not\n+// implemented. ErrSkip is only supported where explicitly\n+// documented.\n+var ErrSkip = errors.New(\"driver: skip fast-path; continue as if unimplemented\")\n+\n+// Execer is an optional interface that may be implemented by a Conn.\n //\n // If a Conn does not implement Execer, the db package's DB.Exec will\n // first prepare a query, execute the statement, and then close the\n // statement.\n //\n // All arguments are of a subset type as defined in the package docs.\n+//\n+// Exec may return ErrSkip.\n type Execer interface {\n \tExec(query string, args []interface{}) (Result, error)\n }\n@@ -94,6 +97,9 @@ type Stmt interface {\n \tClose() error\n \n \t// NumInput returns the number of placeholder parameters.\n+\t// -1 means the driver doesn't know how to count the number of\n+\t// placeholders, so we won't sanity check input here and instead let the\n+\t// driver deal with errors.\n \tNumInput() int\n \n \t// Exec executes a query that doesn't return rows, such\n@@ -135,6 +141,8 @@ type Rows interface {\n \t// The dest slice may be populated with only with values\n \t// of subset types defined above, but excluding string.\n \t// All string values must be converted to []byte.\n+\t//\n+\t// Next should return io.EOF when there are no more rows.\n \tNext(dest []interface{}) error\n }\n "}, {"sha": "17028e2cc388401fec45cecff753b79a7f15403d", "filename": "libgo/go/exp/sql/fakedb_test.go", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Ffakedb_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -195,6 +195,29 @@ func (c *fakeConn) Close() error {\n \treturn nil\n }\n \n+func checkSubsetTypes(args []interface{}) error {\n+\tfor n, arg := range args {\n+\t\tswitch arg.(type) {\n+\t\tcase int64, float64, bool, nil, []byte, string:\n+\t\tdefault:\n+\t\t\treturn fmt.Errorf(\"fakedb_test: invalid argument #%d: %v, type %T\", n+1, arg, arg)\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (c *fakeConn) Exec(query string, args []interface{}) (driver.Result, error) {\n+\t// This is an optional interface, but it's implemented here\n+\t// just to check that all the args of of the proper types.\n+\t// ErrSkip is returned so the caller acts as if we didn't\n+\t// implement this at all.\n+\terr := checkSubsetTypes(args)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn nil, driver.ErrSkip\n+}\n+\n func errf(msg string, args ...interface{}) error {\n \treturn errors.New(\"fakedb: \" + fmt.Sprintf(msg, args...))\n }\n@@ -323,6 +346,11 @@ func (s *fakeStmt) Close() error {\n }\n \n func (s *fakeStmt) Exec(args []interface{}) (driver.Result, error) {\n+\terr := checkSubsetTypes(args)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n \tdb := s.c.db\n \tswitch s.cmd {\n \tcase \"WIPE\":\n@@ -377,6 +405,11 @@ func (s *fakeStmt) execInsert(args []interface{}) (driver.Result, error) {\n }\n \n func (s *fakeStmt) Query(args []interface{}) (driver.Rows, error) {\n+\terr := checkSubsetTypes(args)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n \tdb := s.c.db\n \tif len(args) != s.placeholders {\n \t\tpanic(\"error in pkg db; should only get here if size is correct\")"}, {"sha": "c055fdd68c63648194d7165790e23f33efaf8449", "filename": "libgo/go/exp/sql/sql.go", "status": "modified", "additions": 57, "deletions": 21, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fsql.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -88,8 +88,9 @@ type DB struct {\n \tdriver driver.Driver\n \tdsn    string\n \n-\tmu       sync.Mutex\n+\tmu       sync.Mutex // protects freeConn and closed\n \tfreeConn []driver.Conn\n+\tclosed   bool\n }\n \n // Open opens a database specified by its database driver name and a\n@@ -106,6 +107,22 @@ func Open(driverName, dataSourceName string) (*DB, error) {\n \treturn &DB{driver: driver, dsn: dataSourceName}, nil\n }\n \n+// Close closes the database, releasing any open resources.\n+func (db *DB) Close() error {\n+\tdb.mu.Lock()\n+\tdefer db.mu.Unlock()\n+\tvar err error\n+\tfor _, c := range db.freeConn {\n+\t\terr1 := c.Close()\n+\t\tif err1 != nil {\n+\t\t\terr = err1\n+\t\t}\n+\t}\n+\tdb.freeConn = nil\n+\tdb.closed = true\n+\treturn err\n+}\n+\n func (db *DB) maxIdleConns() int {\n \tconst defaultMaxIdleConns = 2\n \t// TODO(bradfitz): ask driver, if supported, for its default preference\n@@ -116,6 +133,9 @@ func (db *DB) maxIdleConns() int {\n // conn returns a newly-opened or cached driver.Conn\n func (db *DB) conn() (driver.Conn, error) {\n \tdb.mu.Lock()\n+\tif db.closed {\n+\t\treturn nil, errors.New(\"sql: database is closed\")\n+\t}\n \tif n := len(db.freeConn); n > 0 {\n \t\tconn := db.freeConn[n-1]\n \t\tdb.freeConn = db.freeConn[:n-1]\n@@ -140,11 +160,13 @@ func (db *DB) connIfFree(wanted driver.Conn) (conn driver.Conn, ok bool) {\n }\n \n func (db *DB) putConn(c driver.Conn) {\n-\tif n := len(db.freeConn); n < db.maxIdleConns() {\n+\tdb.mu.Lock()\n+\tdefer db.mu.Unlock()\n+\tif n := len(db.freeConn); !db.closed && n < db.maxIdleConns() {\n \t\tdb.freeConn = append(db.freeConn, c)\n \t\treturn\n \t}\n-\tdb.closeConn(c)\n+\tdb.closeConn(c) // TODO(bradfitz): release lock before calling this?\n }\n \n func (db *DB) closeConn(c driver.Conn) {\n@@ -180,37 +202,34 @@ func (db *DB) Prepare(query string) (*Stmt, error) {\n \n // Exec executes a query without returning any rows.\n func (db *DB) Exec(query string, args ...interface{}) (Result, error) {\n-\t// Optional fast path, if the driver implements driver.Execer.\n-\tif execer, ok := db.driver.(driver.Execer); ok {\n-\t\tresi, err := execer.Exec(query, args)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n-\t\t}\n-\t\treturn result{resi}, nil\n+\tsargs, err := subsetTypeArgs(args)\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n \n-\t// If the driver does not implement driver.Execer, we need\n-\t// a connection.\n \tci, err := db.conn()\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \tdefer db.putConn(ci)\n \n \tif execer, ok := ci.(driver.Execer); ok {\n-\t\tresi, err := execer.Exec(query, args)\n-\t\tif err != nil {\n-\t\t\treturn nil, err\n+\t\tresi, err := execer.Exec(query, sargs)\n+\t\tif err != driver.ErrSkip {\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t\treturn result{resi}, nil\n \t\t}\n-\t\treturn result{resi}, nil\n \t}\n \n \tsti, err := ci.Prepare(query)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \tdefer sti.Close()\n-\tresi, err := sti.Exec(args)\n+\n+\tresi, err := sti.Exec(sargs)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -386,7 +405,13 @@ func (tx *Tx) Exec(query string, args ...interface{}) (Result, error) {\n \t\treturn nil, err\n \t}\n \tdefer sti.Close()\n-\tresi, err := sti.Exec(args)\n+\n+\tsargs, err := subsetTypeArgs(args)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tresi, err := sti.Exec(sargs)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -449,7 +474,10 @@ func (s *Stmt) Exec(args ...interface{}) (Result, error) {\n \t}\n \tdefer releaseConn()\n \n-\tif want := si.NumInput(); len(args) != want {\n+\t// -1 means the driver doesn't know how to count the number of\n+\t// placeholders, so we won't sanity check input here and instead let the\n+\t// driver deal with errors.\n+\tif want := si.NumInput(); want != -1 && len(args) != want {\n \t\treturn nil, fmt.Errorf(\"db: expected %d arguments, got %d\", want, len(args))\n \t}\n \n@@ -545,10 +573,18 @@ func (s *Stmt) Query(args ...interface{}) (*Rows, error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tif len(args) != si.NumInput() {\n+\n+\t// -1 means the driver doesn't know how to count the number of\n+\t// placeholders, so we won't sanity check input here and instead let the\n+\t// driver deal with errors.\n+\tif want := si.NumInput(); want != -1 && len(args) != want {\n \t\treturn nil, fmt.Errorf(\"db: statement expects %d inputs; got %d\", si.NumInput(), len(args))\n \t}\n-\trowsi, err := si.Query(args)\n+\tsargs, err := subsetTypeArgs(args)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\trowsi, err := si.Query(sargs)\n \tif err != nil {\n \t\ts.db.putConn(ci)\n \t\treturn nil, err"}, {"sha": "d365f6ba190970d0f0124a8ea0208f787a6c0844", "filename": "libgo/go/exp/sql/sql_test.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fsql_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -34,8 +34,16 @@ func exec(t *testing.T, db *DB, query string, args ...interface{}) {\n \t}\n }\n \n+func closeDB(t *testing.T, db *DB) {\n+\terr := db.Close()\n+\tif err != nil {\n+\t\tt.Fatalf(\"error closing DB: %v\", err)\n+\t}\n+}\n+\n func TestQuery(t *testing.T) {\n \tdb := newTestDB(t, \"people\")\n+\tdefer closeDB(t, db)\n \tvar name string\n \tvar age int\n \n@@ -69,6 +77,7 @@ func TestQuery(t *testing.T) {\n \n func TestStatementQueryRow(t *testing.T) {\n \tdb := newTestDB(t, \"people\")\n+\tdefer closeDB(t, db)\n \tstmt, err := db.Prepare(\"SELECT|people|age|name=?\")\n \tif err != nil {\n \t\tt.Fatalf(\"Prepare: %v\", err)\n@@ -94,6 +103,7 @@ func TestStatementQueryRow(t *testing.T) {\n // just a test of fakedb itself\n func TestBogusPreboundParameters(t *testing.T) {\n \tdb := newTestDB(t, \"foo\")\n+\tdefer closeDB(t, db)\n \texec(t, db, \"CREATE|t1|name=string,age=int32,dead=bool\")\n \t_, err := db.Prepare(\"INSERT|t1|name=?,age=bogusconversion\")\n \tif err == nil {\n@@ -106,6 +116,7 @@ func TestBogusPreboundParameters(t *testing.T) {\n \n func TestDb(t *testing.T) {\n \tdb := newTestDB(t, \"foo\")\n+\tdefer closeDB(t, db)\n \texec(t, db, \"CREATE|t1|name=string,age=int32,dead=bool\")\n \tstmt, err := db.Prepare(\"INSERT|t1|name=?,age=?\")\n \tif err != nil {"}, {"sha": "de4926d7b81788d84f749b59ea62e15700cee786", "filename": "libgo/go/exp/ssh/cipher.go", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fcipher.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ssh\n+\n+import (\n+\t\"crypto/aes\"\n+\t\"crypto/cipher\"\n+\t\"crypto/rc4\"\n+)\n+\n+// streamDump is used to dump the initial keystream for stream ciphers. It is a\n+// a write-only buffer, and not intended for reading so do not require a mutex.\n+var streamDump [512]byte\n+\n+// noneCipher implements cipher.Stream and provides no encryption. It is used\n+// by the transport before the first key-exchange.\n+type noneCipher struct{}\n+\n+func (c noneCipher) XORKeyStream(dst, src []byte) {\n+\tcopy(dst, src)\n+}\n+\n+func newAESCTR(key, iv []byte) (cipher.Stream, error) {\n+\tc, err := aes.NewCipher(key)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn cipher.NewCTR(c, iv), nil\n+}\n+\n+func newRC4(key, iv []byte) (cipher.Stream, error) {\n+\treturn rc4.NewCipher(key)\n+}\n+\n+type cipherMode struct {\n+\tkeySize  int\n+\tivSize   int\n+\tskip     int\n+\tcreateFn func(key, iv []byte) (cipher.Stream, error)\n+}\n+\n+func (c *cipherMode) createCipher(key, iv []byte) (cipher.Stream, error) {\n+\tif len(key) < c.keySize {\n+\t\tpanic(\"ssh: key length too small for cipher\")\n+\t}\n+\tif len(iv) < c.ivSize {\n+\t\tpanic(\"ssh: iv too small for cipher\")\n+\t}\n+\n+\tstream, err := c.createFn(key[:c.keySize], iv[:c.ivSize])\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tfor remainingToDump := c.skip; remainingToDump > 0; {\n+\t\tdumpThisTime := remainingToDump\n+\t\tif dumpThisTime > len(streamDump) {\n+\t\t\tdumpThisTime = len(streamDump)\n+\t\t}\n+\t\tstream.XORKeyStream(streamDump[:dumpThisTime], streamDump[:dumpThisTime])\n+\t\tremainingToDump -= dumpThisTime\n+\t}\n+\n+\treturn stream, nil\n+}\n+\n+// Specifies a default set of ciphers and a preference order. This is based on\n+// OpenSSH's default client preference order, minus algorithms that are not\n+// implemented.\n+var DefaultCipherOrder = []string{\n+\t\"aes128-ctr\", \"aes192-ctr\", \"aes256-ctr\",\n+\t\"arcfour256\", \"arcfour128\",\n+}\n+\n+var cipherModes = map[string]*cipherMode{\n+\t// Ciphers from RFC4344, which introduced many CTR-based ciphers. Algorithms\n+\t// are defined in the order specified in the RFC.\n+\t\"aes128-ctr\": &cipherMode{16, aes.BlockSize, 0, newAESCTR},\n+\t\"aes192-ctr\": &cipherMode{24, aes.BlockSize, 0, newAESCTR},\n+\t\"aes256-ctr\": &cipherMode{32, aes.BlockSize, 0, newAESCTR},\n+\n+\t// Ciphers from RFC4345, which introduces security-improved arcfour ciphers.\n+\t// They are defined in the order specified in the RFC.\n+\t\"arcfour128\": &cipherMode{16, 0, 1536, newRC4},\n+\t\"arcfour256\": &cipherMode{32, 0, 1536, newRC4},\n+}"}, {"sha": "ea27bd8a8035fe94dbe4e4824707b39c86cfd9e2", "filename": "libgo/go/exp/ssh/cipher_test.go", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Fcipher_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Fcipher_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fcipher_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ssh\n+\n+import (\n+\t\"bytes\"\n+\t\"testing\"\n+)\n+\n+// TestCipherReversal tests that each cipher factory produces ciphers that can\n+// encrypt and decrypt some data successfully.\n+func TestCipherReversal(t *testing.T) {\n+\ttestData := []byte(\"abcdefghijklmnopqrstuvwxyz012345\")\n+\ttestKey := []byte(\"AbCdEfGhIjKlMnOpQrStUvWxYz012345\")\n+\ttestIv := []byte(\"sdflkjhsadflkjhasdflkjhsadfklhsa\")\n+\n+\tcryptBuffer := make([]byte, 32)\n+\n+\tfor name, cipherMode := range cipherModes {\n+\t\tencrypter, err := cipherMode.createCipher(testKey, testIv)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"failed to create encrypter for %q: %s\", name, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tdecrypter, err := cipherMode.createCipher(testKey, testIv)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"failed to create decrypter for %q: %s\", name, err)\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tcopy(cryptBuffer, testData)\n+\n+\t\tencrypter.XORKeyStream(cryptBuffer, cryptBuffer)\n+\t\tif name == \"none\" {\n+\t\t\tif !bytes.Equal(cryptBuffer, testData) {\n+\t\t\t\tt.Errorf(\"encryption made change with 'none' cipher\")\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif bytes.Equal(cryptBuffer, testData) {\n+\t\t\t\tt.Errorf(\"encryption made no change with %q\", name)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t}\n+\n+\t\tdecrypter.XORKeyStream(cryptBuffer, cryptBuffer)\n+\t\tif !bytes.Equal(cryptBuffer, testData) {\n+\t\t\tt.Errorf(\"decrypted bytes not equal to input with %q\", name)\n+\t\t\tcontinue\n+\t\t}\n+\t}\n+}\n+\n+func TestDefaultCiphersExist(t *testing.T) {\n+\tfor _, cipherAlgo := range DefaultCipherOrder {\n+\t\tif _, ok := cipherModes[cipherAlgo]; !ok {\n+\t\t\tt.Errorf(\"default cipher %q is unknown\", cipherAlgo)\n+\t\t}\n+\t}\n+}"}, {"sha": "24569ad9389bd65d6c026a208606660ecd75d032", "filename": "libgo/go/exp/ssh/client.go", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -35,10 +35,6 @@ func Client(c net.Conn, config *ClientConfig) (*ClientConn, error) {\n \t\tconn.Close()\n \t\treturn nil, err\n \t}\n-\tif err := conn.authenticate(); err != nil {\n-\t\tconn.Close()\n-\t\treturn nil, err\n-\t}\n \tgo conn.mainLoop()\n \treturn conn, nil\n }\n@@ -64,8 +60,8 @@ func (c *ClientConn) handshake() error {\n \tclientKexInit := kexInitMsg{\n \t\tKexAlgos:                supportedKexAlgos,\n \t\tServerHostKeyAlgos:      supportedHostKeyAlgos,\n-\t\tCiphersClientServer:     supportedCiphers,\n-\t\tCiphersServerClient:     supportedCiphers,\n+\t\tCiphersClientServer:     c.config.Crypto.ciphers(),\n+\t\tCiphersServerClient:     c.config.Crypto.ciphers(),\n \t\tMACsClientServer:        supportedMACs,\n \t\tMACsServerClient:        supportedMACs,\n \t\tCompressionClientServer: supportedCompressions,\n@@ -128,7 +124,10 @@ func (c *ClientConn) handshake() error {\n \tif packet[0] != msgNewKeys {\n \t\treturn UnexpectedMessageError{msgNewKeys, packet[0]}\n \t}\n-\treturn c.transport.reader.setupKeys(serverKeys, K, H, H, hashFunc)\n+\tif err := c.transport.reader.setupKeys(serverKeys, K, H, H, hashFunc); err != nil {\n+\t\treturn err\n+\t}\n+\treturn c.authenticate(H)\n }\n \n // kexDH performs Diffie-Hellman key agreement on a ClientConn. The\n@@ -195,6 +194,7 @@ func (c *ClientConn) openChan(typ string) (*clientChan, error) {\n \tswitch msg := (<-ch.msg).(type) {\n \tcase *channelOpenConfirmMsg:\n \t\tch.peersId = msg.MyId\n+\t\tch.win <- int(msg.MyWindow)\n \tcase *channelOpenFailureMsg:\n \t\tc.chanlist.remove(ch.id)\n \t\treturn nil, errors.New(msg.Message)\n@@ -301,6 +301,9 @@ type ClientConfig struct {\n \t// A slice of ClientAuth methods. Only the first instance \n \t// of a particular RFC 4252 method will be used during authentication.\n \tAuth []ClientAuth\n+\n+\t// Cryptographic-related configuration.\n+\tCrypto CryptoConfig\n }\n \n func (c *ClientConfig) rand() io.Reader {"}, {"sha": "25f9e21622530b40ef687fcf5133fc3066cd80ad", "filename": "libgo/go/exp/ssh/client_auth.go", "status": "modified", "additions": 143, "deletions": 5, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -6,10 +6,11 @@ package ssh\n \n import (\n \t\"errors\"\n+\t\"io\"\n )\n \n // authenticate authenticates with the remote server. See RFC 4252. \n-func (c *ClientConn) authenticate() error {\n+func (c *ClientConn) authenticate(session []byte) error {\n \t// initiate user auth session\n \tif err := c.writePacket(marshal(msgServiceRequest, serviceRequestMsg{serviceUserAuth})); err != nil {\n \t\treturn err\n@@ -26,7 +27,7 @@ func (c *ClientConn) authenticate() error {\n \t// then any untried methods suggested by the server. \n \ttried, remain := make(map[string]bool), make(map[string]bool)\n \tfor auth := ClientAuth(new(noneAuth)); auth != nil; {\n-\t\tok, methods, err := auth.auth(c.config.User, c.transport)\n+\t\tok, methods, err := auth.auth(session, c.config.User, c.transport, c.config.rand())\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}\n@@ -60,7 +61,7 @@ type ClientAuth interface {\n \t// Returns true if authentication is successful.\n \t// If authentication is not successful, a []string of alternative \n \t// method names is returned.\n-\tauth(user string, t *transport) (bool, []string, error)\n+\tauth(session []byte, user string, t *transport, rand io.Reader) (bool, []string, error)\n \n \t// method returns the RFC 4252 method name.\n \tmethod() string\n@@ -69,7 +70,7 @@ type ClientAuth interface {\n // \"none\" authentication, RFC 4252 section 5.2.\n type noneAuth int\n \n-func (n *noneAuth) auth(user string, t *transport) (bool, []string, error) {\n+func (n *noneAuth) auth(session []byte, user string, t *transport, rand io.Reader) (bool, []string, error) {\n \tif err := t.writePacket(marshal(msgUserAuthRequest, userAuthRequestMsg{\n \t\tUser:    user,\n \t\tService: serviceSSH,\n@@ -102,7 +103,7 @@ type passwordAuth struct {\n \tClientPassword\n }\n \n-func (p *passwordAuth) auth(user string, t *transport) (bool, []string, error) {\n+func (p *passwordAuth) auth(session []byte, user string, t *transport, rand io.Reader) (bool, []string, error) {\n \ttype passwordAuthMsg struct {\n \t\tUser     string\n \t\tService  string\n@@ -155,3 +156,140 @@ type ClientPassword interface {\n func ClientAuthPassword(impl ClientPassword) ClientAuth {\n \treturn &passwordAuth{impl}\n }\n+\n+// ClientKeyring implements access to a client key ring.\n+type ClientKeyring interface {\n+\t// Key returns the i'th rsa.Publickey or dsa.Publickey, or nil if \n+\t// no key exists at i.\n+\tKey(i int) (key interface{}, err error)\n+\n+\t// Sign returns a signature of the given data using the i'th key\n+\t// and the supplied random source.\n+\tSign(i int, rand io.Reader, data []byte) (sig []byte, err error)\n+}\n+\n+// \"publickey\" authentication, RFC 4252 Section 7.\n+type publickeyAuth struct {\n+\tClientKeyring\n+}\n+\n+func (p *publickeyAuth) auth(session []byte, user string, t *transport, rand io.Reader) (bool, []string, error) {\n+\ttype publickeyAuthMsg struct {\n+\t\tUser    string\n+\t\tService string\n+\t\tMethod  string\n+\t\t// HasSig indicates to the reciver packet that the auth request is signed and\n+\t\t// should be used for authentication of the request.\n+\t\tHasSig   bool\n+\t\tAlgoname string\n+\t\tPubkey   string\n+\t\t// Sig is defined as []byte so marshal will exclude it during the query phase\n+\t\tSig []byte `ssh:\"rest\"`\n+\t}\n+\n+\t// Authentication is performed in two stages. The first stage sends an\n+\t// enquiry to test if each key is acceptable to the remote. The second\n+\t// stage attempts to authenticate with the valid keys obtained in the \n+\t// first stage.\n+\n+\tvar index int\n+\t// a map of public keys to their index in the keyring \n+\tvalidKeys := make(map[int]interface{})\n+\tfor {\n+\t\tkey, err := p.Key(index)\n+\t\tif err != nil {\n+\t\t\treturn false, nil, err\n+\t\t}\n+\t\tif key == nil {\n+\t\t\t// no more keys in the keyring\n+\t\t\tbreak\n+\t\t}\n+\t\tpubkey := serializePublickey(key)\n+\t\talgoname := algoName(key)\n+\t\tmsg := publickeyAuthMsg{\n+\t\t\tUser:     user,\n+\t\t\tService:  serviceSSH,\n+\t\t\tMethod:   p.method(),\n+\t\t\tHasSig:   false,\n+\t\t\tAlgoname: algoname,\n+\t\t\tPubkey:   string(pubkey),\n+\t\t}\n+\t\tif err := t.writePacket(marshal(msgUserAuthRequest, msg)); err != nil {\n+\t\t\treturn false, nil, err\n+\t\t}\n+\t\tpacket, err := t.readPacket()\n+\t\tif err != nil {\n+\t\t\treturn false, nil, err\n+\t\t}\n+\t\tswitch packet[0] {\n+\t\tcase msgUserAuthPubKeyOk:\n+\t\t\tmsg := decode(packet).(*userAuthPubKeyOkMsg)\n+\t\t\tif msg.Algo != algoname || msg.PubKey != string(pubkey) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tvalidKeys[index] = key\n+\t\tcase msgUserAuthFailure:\n+\t\tdefault:\n+\t\t\treturn false, nil, UnexpectedMessageError{msgUserAuthSuccess, packet[0]}\n+\t\t}\n+\t\tindex++\n+\t}\n+\n+\t// methods that may continue if this auth is not successful.\n+\tvar methods []string\n+\tfor i, key := range validKeys {\n+\t\tpubkey := serializePublickey(key)\n+\t\talgoname := algoName(key)\n+\t\tsign, err := p.Sign(i, rand, buildDataSignedForAuth(session, userAuthRequestMsg{\n+\t\t\tUser:    user,\n+\t\t\tService: serviceSSH,\n+\t\t\tMethod:  p.method(),\n+\t\t}, []byte(algoname), pubkey))\n+\t\tif err != nil {\n+\t\t\treturn false, nil, err\n+\t\t}\n+\t\t// manually wrap the serialized signature in a string\n+\t\ts := serializeSignature(algoname, sign)\n+\t\tsig := make([]byte, stringLength(s))\n+\t\tmarshalString(sig, s)\n+\t\tmsg := publickeyAuthMsg{\n+\t\t\tUser:     user,\n+\t\t\tService:  serviceSSH,\n+\t\t\tMethod:   p.method(),\n+\t\t\tHasSig:   true,\n+\t\t\tAlgoname: algoname,\n+\t\t\tPubkey:   string(pubkey),\n+\t\t\tSig:      sig,\n+\t\t}\n+\t\tp := marshal(msgUserAuthRequest, msg)\n+\t\tif err := t.writePacket(p); err != nil {\n+\t\t\treturn false, nil, err\n+\t\t}\n+\t\tpacket, err := t.readPacket()\n+\t\tif err != nil {\n+\t\t\treturn false, nil, err\n+\t\t}\n+\t\tswitch packet[0] {\n+\t\tcase msgUserAuthSuccess:\n+\t\t\treturn true, nil, nil\n+\t\tcase msgUserAuthFailure:\n+\t\t\tmsg := decode(packet).(*userAuthFailureMsg)\n+\t\t\tmethods = msg.Methods\n+\t\t\tcontinue\n+\t\tcase msgDisconnect:\n+\t\t\treturn false, nil, io.EOF\n+\t\tdefault:\n+\t\t\treturn false, nil, UnexpectedMessageError{msgUserAuthSuccess, packet[0]}\n+\t\t}\n+\t}\n+\treturn false, methods, nil\n+}\n+\n+func (p *publickeyAuth) method() string {\n+\treturn \"publickey\"\n+}\n+\n+// ClientAuthPublickey returns a ClientAuth using public key authentication.\n+func ClientAuthPublickey(impl ClientKeyring) ClientAuth {\n+\treturn &publickeyAuth{impl}\n+}"}, {"sha": "6467f578356a21632cd0b1169c050d7c271b59b0", "filename": "libgo/go/exp/ssh/client_auth_test.go", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fclient_auth_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -0,0 +1,248 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ssh\n+\n+import (\n+\t\"bytes\"\n+\t\"crypto\"\n+\t\"crypto/rand\"\n+\t\"crypto/rsa\"\n+\t\"crypto/x509\"\n+\t\"encoding/pem\"\n+\t\"errors\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"testing\"\n+)\n+\n+const _pem = `-----BEGIN RSA PRIVATE KEY-----\n+MIIEpAIBAAKCAQEA19lGVsTqIT5iiNYRgnoY1CwkbETW5cq+Rzk5v/kTlf31XpSU\n+70HVWkbTERECjaYdXM2gGcbb+sxpq6GtXf1M3kVomycqhxwhPv4Cr6Xp4WT/jkFx\n+9z+FFzpeodGJWjOH6L2H5uX1Cvr9EDdQp9t9/J32/qBFntY8GwoUI/y/1MSTmMiF\n+tupdMODN064vd3gyMKTwrlQ8tZM6aYuyOPsutLlUY7M5x5FwMDYvnPDSeyT/Iw0z\n+s3B+NCyqeeMd2T7YzQFnRATj0M7rM5LoSs7DVqVriOEABssFyLj31PboaoLhOKgc\n+qoM9khkNzr7FHVvi+DhYM2jD0DwvqZLN6NmnLwIDAQABAoIBAQCGVj+kuSFOV1lT\n++IclQYA6bM6uY5mroqcSBNegVxCNhWU03BxlW//BE9tA/+kq53vWylMeN9mpGZea\n+riEMIh25KFGWXqXlOOioH8bkMsqA8S7sBmc7jljyv+0toQ9vCCtJ+sueNPhxQQxH\n+D2YvUjfzBQ04I9+wn30BByDJ1QA/FoPsunxIOUCcRBE/7jxuLYcpR+JvEF68yYIh\n+atXRld4W4in7T65YDR8jK1Uj9XAcNeDYNpT/M6oFLx1aPIlkG86aCWRO19S1jLPT\n+b1ZAKHHxPMCVkSYW0RqvIgLXQOR62D0Zne6/2wtzJkk5UCjkSQ2z7ZzJpMkWgDgN\n+ifCULFPBAoGBAPoMZ5q1w+zB+knXUD33n1J+niN6TZHJulpf2w5zsW+m2K6Zn62M\n+MXndXlVAHtk6p02q9kxHdgov34Uo8VpuNjbS1+abGFTI8NZgFo+bsDxJdItemwC4\n+KJ7L1iz39hRN/ZylMRLz5uTYRGddCkeIHhiG2h7zohH/MaYzUacXEEy3AoGBANz8\n+e/msleB+iXC0cXKwds26N4hyMdAFE5qAqJXvV3S2W8JZnmU+sS7vPAWMYPlERPk1\n+D8Q2eXqdPIkAWBhrx4RxD7rNc5qFNcQWEhCIxC9fccluH1y5g2M+4jpMX2CT8Uv+\n+3z+NoJ5uDTXZTnLCfoZzgZ4nCZVZ+6iU5U1+YXFJAoGBANLPpIV920n/nJmmquMj\n+orI1R/QXR9Cy56cMC65agezlGOfTYxk5Cfl5Ve+/2IJCfgzwJyjWUsFx7RviEeGw\n+64o7JoUom1HX+5xxdHPsyZ96OoTJ5RqtKKoApnhRMamau0fWydH1yeOEJd+TRHhc\n+XStGfhz8QNa1dVFvENczja1vAoGABGWhsd4VPVpHMc7lUvrf4kgKQtTC2PjA4xoc\n+QJ96hf/642sVE76jl+N6tkGMzGjnVm4P2j+bOy1VvwQavKGoXqJBRd5Apppv727g\n+/SM7hBXKFc/zH80xKBBgP/i1DR7kdjakCoeu4ngeGywvu2jTS6mQsqzkK+yWbUxJ\n+I7mYBsECgYB/KNXlTEpXtz/kwWCHFSYA8U74l7zZbVD8ul0e56JDK+lLcJ0tJffk\n+gqnBycHj6AhEycjda75cs+0zybZvN4x65KZHOGW/O/7OAWEcZP5TPb3zf9ned3Hl\n+NsZoFj52ponUM6+99A2CmezFCN16c4mbA//luWF+k3VVqR6BpkrhKw==\n+-----END RSA PRIVATE KEY-----`\n+\n+// reused internally by tests\n+var serverConfig = new(ServerConfig)\n+\n+func init() {\n+\tif err := serverConfig.SetRSAPrivateKey([]byte(_pem)); err != nil {\n+\t\tpanic(\"unable to set private key: \" + err.Error())\n+\t}\n+}\n+\n+// keychain implements the ClientPublickey interface\n+type keychain struct {\n+\tkeys []*rsa.PrivateKey\n+}\n+\n+func (k *keychain) Key(i int) (interface{}, error) {\n+\tif i < 0 || i >= len(k.keys) {\n+\t\treturn nil, nil\n+\t}\n+\treturn k.keys[i].PublicKey, nil\n+}\n+\n+func (k *keychain) Sign(i int, rand io.Reader, data []byte) (sig []byte, err error) {\n+\thashFunc := crypto.SHA1\n+\th := hashFunc.New()\n+\th.Write(data)\n+\tdigest := h.Sum()\n+\treturn rsa.SignPKCS1v15(rand, k.keys[i], hashFunc, digest)\n+}\n+\n+func (k *keychain) loadPEM(file string) error {\n+\tbuf, err := ioutil.ReadFile(file)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tblock, _ := pem.Decode(buf)\n+\tif block == nil {\n+\t\treturn errors.New(\"ssh: no key found\")\n+\t}\n+\tr, err := x509.ParsePKCS1PrivateKey(block.Bytes)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tk.keys = append(k.keys, r)\n+\treturn nil\n+}\n+\n+var pkey *rsa.PrivateKey\n+\n+func init() {\n+\tvar err error\n+\tpkey, err = rsa.GenerateKey(rand.Reader, 512)\n+\tif err != nil {\n+\t\tpanic(\"unable to generate public key\")\n+\t}\n+}\n+\n+func TestClientAuthPublickey(t *testing.T) {\n+\tk := new(keychain)\n+\tk.keys = append(k.keys, pkey)\n+\n+\tserverConfig.PubKeyCallback = func(user, algo string, pubkey []byte) bool {\n+\t\texpected := []byte(serializePublickey(k.keys[0].PublicKey))\n+\t\talgoname := algoName(k.keys[0].PublicKey)\n+\t\treturn user == \"testuser\" && algo == algoname && bytes.Equal(pubkey, expected)\n+\t}\n+\tserverConfig.PasswordCallback = nil\n+\n+\tl, err := Listen(\"tcp\", \"127.0.0.1:0\", serverConfig)\n+\tif err != nil {\n+\t\tt.Fatalf(\"unable to listen: %s\", err)\n+\t}\n+\tdefer l.Close()\n+\n+\tdone := make(chan bool, 1)\n+\tgo func() {\n+\t\tc, err := l.Accept()\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tdefer c.Close()\n+\t\tif err := c.Handshake(); err != nil {\n+\t\t\tt.Error(err)\n+\t\t}\n+\t\tdone <- true\n+\t}()\n+\n+\tconfig := &ClientConfig{\n+\t\tUser: \"testuser\",\n+\t\tAuth: []ClientAuth{\n+\t\t\tClientAuthPublickey(k),\n+\t\t},\n+\t}\n+\n+\tc, err := Dial(\"tcp\", l.Addr().String(), config)\n+\tif err != nil {\n+\t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n+\t}\n+\tdefer c.Close()\n+\t<-done\n+}\n+\n+// password implements the ClientPassword interface\n+type password string\n+\n+func (p password) Password(user string) (string, error) {\n+\treturn string(p), nil\n+}\n+\n+func TestClientAuthPassword(t *testing.T) {\n+\tpw := password(\"tiger\")\n+\n+\tserverConfig.PasswordCallback = func(user, pass string) bool {\n+\t\treturn user == \"testuser\" && pass == string(pw)\n+\t}\n+\tserverConfig.PubKeyCallback = nil\n+\n+\tl, err := Listen(\"tcp\", \"127.0.0.1:0\", serverConfig)\n+\tif err != nil {\n+\t\tt.Fatalf(\"unable to listen: %s\", err)\n+\t}\n+\tdefer l.Close()\n+\n+\tdone := make(chan bool)\n+\tgo func() {\n+\t\tc, err := l.Accept()\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif err := c.Handshake(); err != nil {\n+\t\t\tt.Error(err)\n+\t\t}\n+\t\tdefer c.Close()\n+\t\tdone <- true\n+\t}()\n+\n+\tconfig := &ClientConfig{\n+\t\tUser: \"testuser\",\n+\t\tAuth: []ClientAuth{\n+\t\t\tClientAuthPassword(pw),\n+\t\t},\n+\t}\n+\n+\tc, err := Dial(\"tcp\", l.Addr().String(), config)\n+\tif err != nil {\n+\t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n+\t}\n+\tdefer c.Close()\n+\t<-done\n+}\n+\n+func TestClientAuthPasswordAndPublickey(t *testing.T) {\n+\tpw := password(\"tiger\")\n+\n+\tserverConfig.PasswordCallback = func(user, pass string) bool {\n+\t\treturn user == \"testuser\" && pass == string(pw)\n+\t}\n+\n+\tk := new(keychain)\n+\tk.keys = append(k.keys, pkey)\n+\n+\tserverConfig.PubKeyCallback = func(user, algo string, pubkey []byte) bool {\n+\t\texpected := []byte(serializePublickey(k.keys[0].PublicKey))\n+\t\talgoname := algoName(k.keys[0].PublicKey)\n+\t\treturn user == \"testuser\" && algo == algoname && bytes.Equal(pubkey, expected)\n+\t}\n+\n+\tl, err := Listen(\"tcp\", \"127.0.0.1:0\", serverConfig)\n+\tif err != nil {\n+\t\tt.Fatalf(\"unable to listen: %s\", err)\n+\t}\n+\tdefer l.Close()\n+\n+\tdone := make(chan bool)\n+\tgo func() {\n+\t\tc, err := l.Accept()\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif err := c.Handshake(); err != nil {\n+\t\t\tt.Error(err)\n+\t\t}\n+\t\tdefer c.Close()\n+\t\tdone <- true\n+\t}()\n+\n+\twrongPw := password(\"wrong\")\n+\tconfig := &ClientConfig{\n+\t\tUser: \"testuser\",\n+\t\tAuth: []ClientAuth{\n+\t\t\tClientAuthPassword(wrongPw),\n+\t\t\tClientAuthPublickey(k),\n+\t\t},\n+\t}\n+\n+\tc, err := Dial(\"tcp\", l.Addr().String(), config)\n+\tif err != nil {\n+\t\tt.Fatalf(\"unable to dial remote side: %s\", err)\n+\t}\n+\tdefer c.Close()\n+\t<-done\n+}"}, {"sha": "137456095a06cc13265da077c751c17e13cbd78a", "filename": "libgo/go/exp/ssh/client_func_test.go", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Fclient_func_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Fclient_func_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fclient_func_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ssh\n+\n+// ClientConn functional tests.\n+// These tests require a running ssh server listening on port 22\n+// on the local host. Functional tests will be skipped unless \n+// -ssh.user and -ssh.pass must be passed to gotest.\n+\n+import (\n+\t\"flag\"\n+\t\"testing\"\n+)\n+\n+var (\n+\tsshuser    = flag.String(\"ssh.user\", \"\", \"ssh username\")\n+\tsshpass    = flag.String(\"ssh.pass\", \"\", \"ssh password\")\n+\tsshprivkey = flag.String(\"ssh.privkey\", \"\", \"ssh privkey file\")\n+)\n+\n+func TestFuncPasswordAuth(t *testing.T) {\n+\tif *sshuser == \"\" {\n+\t\tt.Log(\"ssh.user not defined, skipping test\")\n+\t\treturn\n+\t}\n+\tconfig := &ClientConfig{\n+\t\tUser: *sshuser,\n+\t\tAuth: []ClientAuth{\n+\t\t\tClientAuthPassword(password(*sshpass)),\n+\t\t},\n+\t}\n+\tconn, err := Dial(\"tcp\", \"localhost:22\", config)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Unable to connect: %s\", err)\n+\t}\n+\tdefer conn.Close()\n+}\n+\n+func TestFuncPublickeyAuth(t *testing.T) {\n+\tif *sshuser == \"\" {\n+\t\tt.Log(\"ssh.user not defined, skipping test\")\n+\t\treturn\n+\t}\n+\tkc := new(keychain)\n+\tif err := kc.loadPEM(*sshprivkey); err != nil {\n+\t\tt.Fatalf(\"unable to load private key: %s\", err)\n+\t}\n+\tconfig := &ClientConfig{\n+\t\tUser: *sshuser,\n+\t\tAuth: []ClientAuth{\n+\t\t\tClientAuthPublickey(kc),\n+\t\t},\n+\t}\n+\tconn, err := Dial(\"tcp\", \"localhost:22\", config)\n+\tif err != nil {\n+\t\tt.Fatalf(\"unable to connect: %s\", err)\n+\t}\n+\tdefer conn.Close()\n+}"}, {"sha": "01c55219d47578f2133c43663b5052eb762b503c", "filename": "libgo/go/exp/ssh/common.go", "status": "modified", "additions": 99, "deletions": 2, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fcommon.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -5,6 +5,8 @@\n package ssh\n \n import (\n+\t\"crypto/dsa\"\n+\t\"crypto/rsa\"\n \t\"math/big\"\n \t\"strconv\"\n \t\"sync\"\n@@ -14,7 +16,6 @@ import (\n const (\n \tkexAlgoDH14SHA1 = \"diffie-hellman-group14-sha1\"\n \thostAlgoRSA     = \"ssh-rsa\"\n-\tcipherAES128CTR = \"aes128-ctr\"\n \tmacSHA196       = \"hmac-sha1-96\"\n \tcompressionNone = \"none\"\n \tserviceUserAuth = \"ssh-userauth\"\n@@ -23,7 +24,6 @@ const (\n \n var supportedKexAlgos = []string{kexAlgoDH14SHA1}\n var supportedHostKeyAlgos = []string{hostAlgoRSA}\n-var supportedCiphers = []string{cipherAES128CTR}\n var supportedMACs = []string{macSHA196}\n var supportedCompressions = []string{compressionNone}\n \n@@ -127,3 +127,100 @@ func findAgreedAlgorithms(transport *transport, clientKexInit, serverKexInit *ke\n \tok = true\n \treturn\n }\n+\n+// Cryptographic configuration common to both ServerConfig and ClientConfig.\n+type CryptoConfig struct {\n+\t// The allowed cipher algorithms. If unspecified then DefaultCipherOrder is\n+\t// used.\n+\tCiphers []string\n+}\n+\n+func (c *CryptoConfig) ciphers() []string {\n+\tif c.Ciphers == nil {\n+\t\treturn DefaultCipherOrder\n+\t}\n+\treturn c.Ciphers\n+}\n+\n+// serialize a signed slice according to RFC 4254 6.6.\n+func serializeSignature(algoname string, sig []byte) []byte {\n+\tlength := stringLength([]byte(algoname))\n+\tlength += stringLength(sig)\n+\n+\tret := make([]byte, length)\n+\tr := marshalString(ret, []byte(algoname))\n+\tr = marshalString(r, sig)\n+\n+\treturn ret\n+}\n+\n+// serialize an rsa.PublicKey or dsa.PublicKey according to RFC 4253 6.6.\n+func serializePublickey(key interface{}) []byte {\n+\talgoname := algoName(key)\n+\tswitch key := key.(type) {\n+\tcase rsa.PublicKey:\n+\t\te := new(big.Int).SetInt64(int64(key.E))\n+\t\tlength := stringLength([]byte(algoname))\n+\t\tlength += intLength(e)\n+\t\tlength += intLength(key.N)\n+\t\tret := make([]byte, length)\n+\t\tr := marshalString(ret, []byte(algoname))\n+\t\tr = marshalInt(r, e)\n+\t\tmarshalInt(r, key.N)\n+\t\treturn ret\n+\tcase dsa.PublicKey:\n+\t\tlength := stringLength([]byte(algoname))\n+\t\tlength += intLength(key.P)\n+\t\tlength += intLength(key.Q)\n+\t\tlength += intLength(key.G)\n+\t\tlength += intLength(key.Y)\n+\t\tret := make([]byte, length)\n+\t\tr := marshalString(ret, []byte(algoname))\n+\t\tr = marshalInt(r, key.P)\n+\t\tr = marshalInt(r, key.Q)\n+\t\tr = marshalInt(r, key.G)\n+\t\tmarshalInt(r, key.Y)\n+\t\treturn ret\n+\t}\n+\tpanic(\"unexpected key type\")\n+}\n+\n+func algoName(key interface{}) string {\n+\tswitch key.(type) {\n+\tcase rsa.PublicKey:\n+\t\treturn \"ssh-rsa\"\n+\tcase dsa.PublicKey:\n+\t\treturn \"ssh-dss\"\n+\t}\n+\tpanic(\"unexpected key type\")\n+}\n+\n+// buildDataSignedForAuth returns the data that is signed in order to prove\n+// posession of a private key. See RFC 4252, section 7.\n+func buildDataSignedForAuth(sessionId []byte, req userAuthRequestMsg, algo, pubKey []byte) []byte {\n+\tuser := []byte(req.User)\n+\tservice := []byte(req.Service)\n+\tmethod := []byte(req.Method)\n+\n+\tlength := stringLength(sessionId)\n+\tlength += 1\n+\tlength += stringLength(user)\n+\tlength += stringLength(service)\n+\tlength += stringLength(method)\n+\tlength += 1\n+\tlength += stringLength(algo)\n+\tlength += stringLength(pubKey)\n+\n+\tret := make([]byte, length)\n+\tr := marshalString(ret, sessionId)\n+\tr[0] = msgUserAuthRequest\n+\tr = r[1:]\n+\tr = marshalString(r, user)\n+\tr = marshalString(r, service)\n+\tr = marshalString(r, method)\n+\tr[0] = 1\n+\tr = r[1:]\n+\tr = marshalString(r, algo)\n+\tr = marshalString(r, pubKey)\n+\treturn ret\n+}"}, {"sha": "cebb5609db38711e01f8992923e126b4bb9374f5", "filename": "libgo/go/exp/ssh/messages.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Fmessages.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Fmessages.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fmessages.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -392,14 +392,18 @@ func parseString(in []byte) (out, rest []byte, ok bool) {\n \treturn\n }\n \n-var comma = []byte{','}\n+var (\n+\tcomma         = []byte{','}\n+\temptyNameList = []string{}\n+)\n \n func parseNameList(in []byte) (out []string, rest []byte, ok bool) {\n \tcontents, rest, ok := parseString(in)\n \tif !ok {\n \t\treturn\n \t}\n \tif len(contents) == 0 {\n+\t\tout = emptyNameList\n \t\treturn\n \t}\n \tparts := bytes.Split(contents, comma)\n@@ -444,8 +448,6 @@ func parseUint32(in []byte) (out uint32, rest []byte, ok bool) {\n \treturn\n }\n \n-const maxPacketSize = 36000\n-\n func nameListLength(namelist []string) int {\n \tlength := 4 /* uint32 length prefix */\n \tfor i, name := range namelist {"}, {"sha": "428a747e1e0c89b424d0349d5f6ccde744d2c503", "filename": "libgo/go/exp/ssh/server.go", "status": "modified", "additions": 9, "deletions": 45, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fserver.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -40,6 +40,9 @@ type ServerConfig struct {\n \t// key authentication. It must return true iff the given public key is\n \t// valid for the given user.\n \tPubKeyCallback func(user, algo string, pubkey []byte) bool\n+\n+\t// Cryptographic-related configuration.\n+\tCrypto CryptoConfig\n }\n \n func (c *ServerConfig) rand() io.Reader {\n@@ -221,7 +224,7 @@ func (s *ServerConn) kexDH(group *dhGroup, hashFunc crypto.Hash, magics *handsha\n \t\treturn nil, nil, errors.New(\"internal error\")\n \t}\n \n-\tserializedSig := serializeRSASignature(sig)\n+\tserializedSig := serializeSignature(hostAlgoRSA, sig)\n \n \tkexDHReply := kexDHReplyMsg{\n \t\tHostKey:   serializedHostKey,\n@@ -234,50 +237,9 @@ func (s *ServerConn) kexDH(group *dhGroup, hashFunc crypto.Hash, magics *handsha\n \treturn\n }\n \n-func serializeRSASignature(sig []byte) []byte {\n-\tlength := stringLength([]byte(hostAlgoRSA))\n-\tlength += stringLength(sig)\n-\n-\tret := make([]byte, length)\n-\tr := marshalString(ret, []byte(hostAlgoRSA))\n-\tr = marshalString(r, sig)\n-\n-\treturn ret\n-}\n-\n // serverVersion is the fixed identification string that Server will use.\n var serverVersion = []byte(\"SSH-2.0-Go\\r\\n\")\n \n-// buildDataSignedForAuth returns the data that is signed in order to prove\n-// posession of a private key. See RFC 4252, section 7.\n-func buildDataSignedForAuth(sessionId []byte, req userAuthRequestMsg, algo, pubKey []byte) []byte {\n-\tuser := []byte(req.User)\n-\tservice := []byte(req.Service)\n-\tmethod := []byte(req.Method)\n-\n-\tlength := stringLength(sessionId)\n-\tlength += 1\n-\tlength += stringLength(user)\n-\tlength += stringLength(service)\n-\tlength += stringLength(method)\n-\tlength += 1\n-\tlength += stringLength(algo)\n-\tlength += stringLength(pubKey)\n-\n-\tret := make([]byte, length)\n-\tr := marshalString(ret, sessionId)\n-\tr[0] = msgUserAuthRequest\n-\tr = r[1:]\n-\tr = marshalString(r, user)\n-\tr = marshalString(r, service)\n-\tr = marshalString(r, method)\n-\tr[0] = 1\n-\tr = r[1:]\n-\tr = marshalString(r, algo)\n-\tr = marshalString(r, pubKey)\n-\treturn ret\n-}\n-\n // Handshake performs an SSH transport and client authentication on the given ServerConn.\n func (s *ServerConn) Handshake() error {\n \tvar magics handshakeMagics\n@@ -298,8 +260,8 @@ func (s *ServerConn) Handshake() error {\n \tserverKexInit := kexInitMsg{\n \t\tKexAlgos:                supportedKexAlgos,\n \t\tServerHostKeyAlgos:      supportedHostKeyAlgos,\n-\t\tCiphersClientServer:     supportedCiphers,\n-\t\tCiphersServerClient:     supportedCiphers,\n+\t\tCiphersClientServer:     s.config.Crypto.ciphers(),\n+\t\tCiphersServerClient:     s.config.Crypto.ciphers(),\n \t\tMACsClientServer:        supportedMACs,\n \t\tMACsServerClient:        supportedMACs,\n \t\tCompressionClientServer: supportedCompressions,\n@@ -364,7 +326,9 @@ func (s *ServerConn) Handshake() error {\n \tif packet[0] != msgNewKeys {\n \t\treturn UnexpectedMessageError{msgNewKeys, packet[0]}\n \t}\n-\ts.transport.reader.setupKeys(clientKeys, K, H, H, hashFunc)\n+\tif err = s.transport.reader.setupKeys(clientKeys, K, H, H, hashFunc); err != nil {\n+\t\treturn err\n+\t}\n \tif packet, err = s.readPacket(); err != nil {\n \t\treturn err\n \t}"}, {"sha": "859dedc93b3e2d166ca47fff4a80702d490de4cf", "filename": "libgo/go/exp/ssh/tcpip.go", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Ftcpip.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -0,0 +1,146 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ssh\n+\n+import (\n+\t\"errors\"\n+\t\"io\"\n+\t\"net\"\n+)\n+// Dial initiates a connection to the addr from the remote host.\n+// addr is resolved using net.ResolveTCPAddr before connection. \n+// This could allow an observer to observe the DNS name of the \n+// remote host. Consider using ssh.DialTCP to avoid this.\n+func (c *ClientConn) Dial(n, addr string) (net.Conn, error) {\n+\traddr, err := net.ResolveTCPAddr(n, addr)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn c.DialTCP(n, nil, raddr)\n+}\n+\n+// DialTCP connects to the remote address raddr on the network net,\n+// which must be \"tcp\", \"tcp4\", or \"tcp6\".  If laddr is not nil, it is used\n+// as the local address for the connection.\n+func (c *ClientConn) DialTCP(n string, laddr, raddr *net.TCPAddr) (net.Conn, error) {\n+\tif laddr == nil {\n+\t\tladdr = &net.TCPAddr{\n+\t\t\tIP:   net.IPv4zero,\n+\t\t\tPort: 0,\n+\t\t}\n+\t}\n+\tch, err := c.dial(laddr.IP.String(), laddr.Port, raddr.IP.String(), raddr.Port)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn &tcpchanconn{\n+\t\ttcpchan: ch,\n+\t\tladdr:   laddr,\n+\t\traddr:   raddr,\n+\t}, nil\n+}\n+\n+// dial opens a direct-tcpip connection to the remote server. laddr and raddr are passed as\n+// strings and are expected to be resolveable at the remote end.\n+func (c *ClientConn) dial(laddr string, lport int, raddr string, rport int) (*tcpchan, error) {\n+\t// RFC 4254 7.2\n+\ttype channelOpenDirectMsg struct {\n+\t\tChanType      string\n+\t\tPeersId       uint32\n+\t\tPeersWindow   uint32\n+\t\tMaxPacketSize uint32\n+\t\traddr         string\n+\t\trport         uint32\n+\t\tladdr         string\n+\t\tlport         uint32\n+\t}\n+\tch := c.newChan(c.transport)\n+\tif err := c.writePacket(marshal(msgChannelOpen, channelOpenDirectMsg{\n+\t\tChanType:      \"direct-tcpip\",\n+\t\tPeersId:       ch.id,\n+\t\tPeersWindow:   1 << 14,\n+\t\tMaxPacketSize: 1 << 15, // RFC 4253 6.1\n+\t\traddr:         raddr,\n+\t\trport:         uint32(rport),\n+\t\tladdr:         laddr,\n+\t\tlport:         uint32(lport),\n+\t})); err != nil {\n+\t\tc.chanlist.remove(ch.id)\n+\t\treturn nil, err\n+\t}\n+\t// wait for response\n+\tswitch msg := (<-ch.msg).(type) {\n+\tcase *channelOpenConfirmMsg:\n+\t\tch.peersId = msg.MyId\n+\t\tch.win <- int(msg.MyWindow)\n+\tcase *channelOpenFailureMsg:\n+\t\tc.chanlist.remove(ch.id)\n+\t\treturn nil, errors.New(\"ssh: error opening remote TCP connection: \" + msg.Message)\n+\tdefault:\n+\t\tc.chanlist.remove(ch.id)\n+\t\treturn nil, errors.New(\"ssh: unexpected packet\")\n+\t}\n+\treturn &tcpchan{\n+\t\tclientChan: ch,\n+\t\tReader: &chanReader{\n+\t\t\tpacketWriter: ch,\n+\t\t\tid:           ch.id,\n+\t\t\tdata:         ch.data,\n+\t\t},\n+\t\tWriter: &chanWriter{\n+\t\t\tpacketWriter: ch,\n+\t\t\tid:           ch.id,\n+\t\t\twin:          ch.win,\n+\t\t},\n+\t}, nil\n+}\n+\n+type tcpchan struct {\n+\t*clientChan // the backing channel\n+\tio.Reader\n+\tio.Writer\n+}\n+\n+// tcpchanconn fulfills the net.Conn interface without \n+// the tcpchan having to hold laddr or raddr directly.\n+type tcpchanconn struct {\n+\t*tcpchan\n+\tladdr, raddr net.Addr\n+}\n+\n+// LocalAddr returns the local network address.\n+func (t *tcpchanconn) LocalAddr() net.Addr {\n+\treturn t.laddr\n+}\n+\n+// RemoteAddr returns the remote network address.\n+func (t *tcpchanconn) RemoteAddr() net.Addr {\n+\treturn t.raddr\n+}\n+\n+// SetTimeout sets the read and write deadlines associated\n+// with the connection.\n+func (t *tcpchanconn) SetTimeout(nsec int64) error {\n+\tif err := t.SetReadTimeout(nsec); err != nil {\n+\t\treturn err\n+\t}\n+\treturn t.SetWriteTimeout(nsec)\n+}\n+\n+// SetReadTimeout sets the time (in nanoseconds) that\n+// Read will wait for data before returning an error with Timeout() == true.\n+// Setting nsec == 0 (the default) disables the deadline.\n+func (t *tcpchanconn) SetReadTimeout(nsec int64) error {\n+\treturn errors.New(\"ssh: tcpchan: timeout not supported\")\n+}\n+\n+// SetWriteTimeout sets the time (in nanoseconds) that\n+// Write will wait to send its data before returning an error with Timeout() == true.\n+// Setting nsec == 0 (the default) disables the deadline.\n+// Even if write times out, it may return n > 0, indicating that\n+// some of the data was successfully written.\n+func (t *tcpchanconn) SetWriteTimeout(nsec int64) error {\n+\treturn errors.New(\"ssh: tcpchan: timeout not supported\")\n+}"}, {"sha": "b8cb2c319d85e119495cee900a81993a4a5ffc73", "filename": "libgo/go/exp/ssh/transport.go", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -7,7 +7,6 @@ package ssh\n import (\n \t\"bufio\"\n \t\"crypto\"\n-\t\"crypto/aes\"\n \t\"crypto/cipher\"\n \t\"crypto/hmac\"\n \t\"crypto/subtle\"\n@@ -19,7 +18,10 @@ import (\n )\n \n const (\n-\tpaddingMultiple = 16 // TODO(dfc) does this need to be configurable?\n+\tpacketSizeMultiple = 16 // TODO(huin) this should be determined by the cipher.\n+\tminPacketSize      = 16\n+\tmaxPacketSize      = 36000\n+\tminPaddingSize     = 4 // TODO(huin) should this be configurable?\n )\n \n // filteredConn reduces the set of methods exposed when embeddeding\n@@ -61,8 +63,7 @@ type reader struct {\n type writer struct {\n \t*sync.Mutex // protects writer.Writer from concurrent writes\n \t*bufio.Writer\n-\tpaddingMultiple int\n-\trand            io.Reader\n+\trand io.Reader\n \tcommon\n }\n \n@@ -82,14 +83,11 @@ type common struct {\n func (r *reader) readOnePacket() ([]byte, error) {\n \tvar lengthBytes = make([]byte, 5)\n \tvar macSize uint32\n-\n \tif _, err := io.ReadFull(r, lengthBytes); err != nil {\n \t\treturn nil, err\n \t}\n \n-\tif r.cipher != nil {\n-\t\tr.cipher.XORKeyStream(lengthBytes, lengthBytes)\n-\t}\n+\tr.cipher.XORKeyStream(lengthBytes, lengthBytes)\n \n \tif r.mac != nil {\n \t\tr.mac.Reset()\n@@ -153,9 +151,9 @@ func (w *writer) writePacket(packet []byte) error {\n \tw.Mutex.Lock()\n \tdefer w.Mutex.Unlock()\n \n-\tpaddingLength := paddingMultiple - (5+len(packet))%paddingMultiple\n+\tpaddingLength := packetSizeMultiple - (5+len(packet))%packetSizeMultiple\n \tif paddingLength < 4 {\n-\t\tpaddingLength += paddingMultiple\n+\t\tpaddingLength += packetSizeMultiple\n \t}\n \n \tlength := len(packet) + 1 + paddingLength\n@@ -188,11 +186,9 @@ func (w *writer) writePacket(packet []byte) error {\n \n \t// TODO(dfc) lengthBytes, packet and padding should be\n \t// subslices of a single buffer\n-\tif w.cipher != nil {\n-\t\tw.cipher.XORKeyStream(lengthBytes, lengthBytes)\n-\t\tw.cipher.XORKeyStream(packet, packet)\n-\t\tw.cipher.XORKeyStream(padding, padding)\n-\t}\n+\tw.cipher.XORKeyStream(lengthBytes, lengthBytes)\n+\tw.cipher.XORKeyStream(packet, packet)\n+\tw.cipher.XORKeyStream(padding, padding)\n \n \tif _, err := w.Write(lengthBytes); err != nil {\n \t\treturn err\n@@ -227,11 +223,17 @@ func newTransport(conn net.Conn, rand io.Reader) *transport {\n \treturn &transport{\n \t\treader: reader{\n \t\t\tReader: bufio.NewReader(conn),\n+\t\t\tcommon: common{\n+\t\t\t\tcipher: noneCipher{},\n+\t\t\t},\n \t\t},\n \t\twriter: writer{\n \t\t\tWriter: bufio.NewWriter(conn),\n \t\t\trand:   rand,\n \t\t\tMutex:  new(sync.Mutex),\n+\t\t\tcommon: common{\n+\t\t\t\tcipher: noneCipher{},\n+\t\t\t},\n \t\t},\n \t\tfilteredConn: conn,\n \t}\n@@ -249,29 +251,32 @@ var (\n \tclientKeys = direction{[]byte{'A'}, []byte{'C'}, []byte{'E'}}\n )\n \n-// setupKeys sets the cipher and MAC keys from K, H and sessionId, as\n+// setupKeys sets the cipher and MAC keys from kex.K, kex.H and sessionId, as\n // described in RFC 4253, section 6.4. direction should either be serverKeys\n // (to setup server->client keys) or clientKeys (for client->server keys).\n func (c *common) setupKeys(d direction, K, H, sessionId []byte, hashFunc crypto.Hash) error {\n-\th := hashFunc.New()\n+\tcipherMode := cipherModes[c.cipherAlgo]\n \n-\tblockSize := 16\n-\tkeySize := 16\n \tmacKeySize := 20\n \n-\tiv := make([]byte, blockSize)\n-\tkey := make([]byte, keySize)\n+\tiv := make([]byte, cipherMode.ivSize)\n+\tkey := make([]byte, cipherMode.keySize)\n \tmacKey := make([]byte, macKeySize)\n+\n+\th := hashFunc.New()\n \tgenerateKeyMaterial(iv, d.ivTag, K, H, sessionId, h)\n \tgenerateKeyMaterial(key, d.keyTag, K, H, sessionId, h)\n \tgenerateKeyMaterial(macKey, d.macKeyTag, K, H, sessionId, h)\n \n \tc.mac = truncatingMAC{12, hmac.NewSHA1(macKey)}\n-\taes, err := aes.NewCipher(key)\n+\n+\tcipher, err := cipherMode.createCipher(key, iv)\n \tif err != nil {\n \t\treturn err\n \t}\n-\tc.cipher = cipher.NewCTR(aes, iv)\n+\n+\tc.cipher = cipher\n+\n \treturn nil\n }\n "}, {"sha": "5c5916755d603b844601a455c4852fcdd752488b", "filename": "libgo/go/exp/terminal/shell.go", "status": "removed", "additions": 0, "deletions": 356, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e456f4cf4deee3e2ccd9849286f59b90644c48b/libgo%2Fgo%2Fexp%2Fterminal%2Fshell.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e456f4cf4deee3e2ccd9849286f59b90644c48b/libgo%2Fgo%2Fexp%2Fterminal%2Fshell.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fterminal%2Fshell.go?ref=6e456f4cf4deee3e2ccd9849286f59b90644c48b", "patch": "@@ -1,356 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package terminal\n-\n-import \"io\"\n-\n-// Shell contains the state for running a VT100 terminal that is capable of\n-// reading lines of input.\n-type Shell struct {\n-\tc      io.ReadWriter\n-\tprompt string\n-\n-\t// line is the current line being entered.\n-\tline []byte\n-\t// pos is the logical position of the cursor in line\n-\tpos int\n-\n-\t// cursorX contains the current X value of the cursor where the left\n-\t// edge is 0. cursorY contains the row number where the first row of\n-\t// the current line is 0.\n-\tcursorX, cursorY int\n-\t// maxLine is the greatest value of cursorY so far.\n-\tmaxLine int\n-\n-\ttermWidth, termHeight int\n-\n-\t// outBuf contains the terminal data to be sent.\n-\toutBuf []byte\n-\t// remainder contains the remainder of any partial key sequences after\n-\t// a read. It aliases into inBuf.\n-\tremainder []byte\n-\tinBuf     [256]byte\n-}\n-\n-// NewShell runs a VT100 terminal on the given ReadWriter. If the ReadWriter is\n-// a local terminal, that terminal must first have been put into raw mode.\n-// prompt is a string that is written at the start of each input line (i.e.\n-// \"> \").\n-func NewShell(c io.ReadWriter, prompt string) *Shell {\n-\treturn &Shell{\n-\t\tc:          c,\n-\t\tprompt:     prompt,\n-\t\ttermWidth:  80,\n-\t\ttermHeight: 24,\n-\t}\n-}\n-\n-const (\n-\tkeyCtrlD     = 4\n-\tkeyEnter     = '\\r'\n-\tkeyEscape    = 27\n-\tkeyBackspace = 127\n-\tkeyUnknown   = 256 + iota\n-\tkeyUp\n-\tkeyDown\n-\tkeyLeft\n-\tkeyRight\n-\tkeyAltLeft\n-\tkeyAltRight\n-)\n-\n-// bytesToKey tries to parse a key sequence from b. If successful, it returns\n-// the key and the remainder of the input. Otherwise it returns -1.\n-func bytesToKey(b []byte) (int, []byte) {\n-\tif len(b) == 0 {\n-\t\treturn -1, nil\n-\t}\n-\n-\tif b[0] != keyEscape {\n-\t\treturn int(b[0]), b[1:]\n-\t}\n-\n-\tif len(b) >= 3 && b[0] == keyEscape && b[1] == '[' {\n-\t\tswitch b[2] {\n-\t\tcase 'A':\n-\t\t\treturn keyUp, b[3:]\n-\t\tcase 'B':\n-\t\t\treturn keyDown, b[3:]\n-\t\tcase 'C':\n-\t\t\treturn keyRight, b[3:]\n-\t\tcase 'D':\n-\t\t\treturn keyLeft, b[3:]\n-\t\t}\n-\t}\n-\n-\tif len(b) >= 6 && b[0] == keyEscape && b[1] == '[' && b[2] == '1' && b[3] == ';' && b[4] == '3' {\n-\t\tswitch b[5] {\n-\t\tcase 'C':\n-\t\t\treturn keyAltRight, b[6:]\n-\t\tcase 'D':\n-\t\t\treturn keyAltLeft, b[6:]\n-\t\t}\n-\t}\n-\n-\t// If we get here then we have a key that we don't recognise, or a\n-\t// partial sequence. It's not clear how one should find the end of a\n-\t// sequence without knowing them all, but it seems that [a-zA-Z] only\n-\t// appears at the end of a sequence.\n-\tfor i, c := range b[0:] {\n-\t\tif c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' {\n-\t\t\treturn keyUnknown, b[i+1:]\n-\t\t}\n-\t}\n-\n-\treturn -1, b\n-}\n-\n-// queue appends data to the end of ss.outBuf\n-func (ss *Shell) queue(data []byte) {\n-\tif len(ss.outBuf)+len(data) > cap(ss.outBuf) {\n-\t\tnewOutBuf := make([]byte, len(ss.outBuf), 2*(len(ss.outBuf)+len(data)))\n-\t\tcopy(newOutBuf, ss.outBuf)\n-\t\tss.outBuf = newOutBuf\n-\t}\n-\n-\toldLen := len(ss.outBuf)\n-\tss.outBuf = ss.outBuf[:len(ss.outBuf)+len(data)]\n-\tcopy(ss.outBuf[oldLen:], data)\n-}\n-\n-var eraseUnderCursor = []byte{' ', keyEscape, '[', 'D'}\n-\n-func isPrintable(key int) bool {\n-\treturn key >= 32 && key < 127\n-}\n-\n-// moveCursorToPos appends data to ss.outBuf which will move the cursor to the\n-// given, logical position in the text.\n-func (ss *Shell) moveCursorToPos(pos int) {\n-\tx := len(ss.prompt) + pos\n-\ty := x / ss.termWidth\n-\tx = x % ss.termWidth\n-\n-\tup := 0\n-\tif y < ss.cursorY {\n-\t\tup = ss.cursorY - y\n-\t}\n-\n-\tdown := 0\n-\tif y > ss.cursorY {\n-\t\tdown = y - ss.cursorY\n-\t}\n-\n-\tleft := 0\n-\tif x < ss.cursorX {\n-\t\tleft = ss.cursorX - x\n-\t}\n-\n-\tright := 0\n-\tif x > ss.cursorX {\n-\t\tright = x - ss.cursorX\n-\t}\n-\n-\tmovement := make([]byte, 3*(up+down+left+right))\n-\tm := movement\n-\tfor i := 0; i < up; i++ {\n-\t\tm[0] = keyEscape\n-\t\tm[1] = '['\n-\t\tm[2] = 'A'\n-\t\tm = m[3:]\n-\t}\n-\tfor i := 0; i < down; i++ {\n-\t\tm[0] = keyEscape\n-\t\tm[1] = '['\n-\t\tm[2] = 'B'\n-\t\tm = m[3:]\n-\t}\n-\tfor i := 0; i < left; i++ {\n-\t\tm[0] = keyEscape\n-\t\tm[1] = '['\n-\t\tm[2] = 'D'\n-\t\tm = m[3:]\n-\t}\n-\tfor i := 0; i < right; i++ {\n-\t\tm[0] = keyEscape\n-\t\tm[1] = '['\n-\t\tm[2] = 'C'\n-\t\tm = m[3:]\n-\t}\n-\n-\tss.cursorX = x\n-\tss.cursorY = y\n-\tss.queue(movement)\n-}\n-\n-const maxLineLength = 4096\n-\n-// handleKey processes the given key and, optionally, returns a line of text\n-// that the user has entered.\n-func (ss *Shell) handleKey(key int) (line string, ok bool) {\n-\tswitch key {\n-\tcase keyBackspace:\n-\t\tif ss.pos == 0 {\n-\t\t\treturn\n-\t\t}\n-\t\tss.pos--\n-\n-\t\tcopy(ss.line[ss.pos:], ss.line[1+ss.pos:])\n-\t\tss.line = ss.line[:len(ss.line)-1]\n-\t\tss.writeLine(ss.line[ss.pos:])\n-\t\tss.moveCursorToPos(ss.pos)\n-\t\tss.queue(eraseUnderCursor)\n-\tcase keyAltLeft:\n-\t\t// move left by a word.\n-\t\tif ss.pos == 0 {\n-\t\t\treturn\n-\t\t}\n-\t\tss.pos--\n-\t\tfor ss.pos > 0 {\n-\t\t\tif ss.line[ss.pos] != ' ' {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tss.pos--\n-\t\t}\n-\t\tfor ss.pos > 0 {\n-\t\t\tif ss.line[ss.pos] == ' ' {\n-\t\t\t\tss.pos++\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tss.pos--\n-\t\t}\n-\t\tss.moveCursorToPos(ss.pos)\n-\tcase keyAltRight:\n-\t\t// move right by a word.\n-\t\tfor ss.pos < len(ss.line) {\n-\t\t\tif ss.line[ss.pos] == ' ' {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tss.pos++\n-\t\t}\n-\t\tfor ss.pos < len(ss.line) {\n-\t\t\tif ss.line[ss.pos] != ' ' {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tss.pos++\n-\t\t}\n-\t\tss.moveCursorToPos(ss.pos)\n-\tcase keyLeft:\n-\t\tif ss.pos == 0 {\n-\t\t\treturn\n-\t\t}\n-\t\tss.pos--\n-\t\tss.moveCursorToPos(ss.pos)\n-\tcase keyRight:\n-\t\tif ss.pos == len(ss.line) {\n-\t\t\treturn\n-\t\t}\n-\t\tss.pos++\n-\t\tss.moveCursorToPos(ss.pos)\n-\tcase keyEnter:\n-\t\tss.moveCursorToPos(len(ss.line))\n-\t\tss.queue([]byte(\"\\r\\n\"))\n-\t\tline = string(ss.line)\n-\t\tok = true\n-\t\tss.line = ss.line[:0]\n-\t\tss.pos = 0\n-\t\tss.cursorX = 0\n-\t\tss.cursorY = 0\n-\t\tss.maxLine = 0\n-\tdefault:\n-\t\tif !isPrintable(key) {\n-\t\t\treturn\n-\t\t}\n-\t\tif len(ss.line) == maxLineLength {\n-\t\t\treturn\n-\t\t}\n-\t\tif len(ss.line) == cap(ss.line) {\n-\t\t\tnewLine := make([]byte, len(ss.line), 2*(1+len(ss.line)))\n-\t\t\tcopy(newLine, ss.line)\n-\t\t\tss.line = newLine\n-\t\t}\n-\t\tss.line = ss.line[:len(ss.line)+1]\n-\t\tcopy(ss.line[ss.pos+1:], ss.line[ss.pos:])\n-\t\tss.line[ss.pos] = byte(key)\n-\t\tss.writeLine(ss.line[ss.pos:])\n-\t\tss.pos++\n-\t\tss.moveCursorToPos(ss.pos)\n-\t}\n-\treturn\n-}\n-\n-func (ss *Shell) writeLine(line []byte) {\n-\tfor len(line) != 0 {\n-\t\tif ss.cursorX == ss.termWidth {\n-\t\t\tss.queue([]byte(\"\\r\\n\"))\n-\t\t\tss.cursorX = 0\n-\t\t\tss.cursorY++\n-\t\t\tif ss.cursorY > ss.maxLine {\n-\t\t\t\tss.maxLine = ss.cursorY\n-\t\t\t}\n-\t\t}\n-\n-\t\tremainingOnLine := ss.termWidth - ss.cursorX\n-\t\ttodo := len(line)\n-\t\tif todo > remainingOnLine {\n-\t\t\ttodo = remainingOnLine\n-\t\t}\n-\t\tss.queue(line[:todo])\n-\t\tss.cursorX += todo\n-\t\tline = line[todo:]\n-\t}\n-}\n-\n-func (ss *Shell) Write(buf []byte) (n int, err error) {\n-\treturn ss.c.Write(buf)\n-}\n-\n-// ReadLine returns a line of input from the terminal.\n-func (ss *Shell) ReadLine() (line string, err error) {\n-\tss.writeLine([]byte(ss.prompt))\n-\tss.c.Write(ss.outBuf)\n-\tss.outBuf = ss.outBuf[:0]\n-\n-\tfor {\n-\t\t// ss.remainder is a slice at the beginning of ss.inBuf\n-\t\t// containing a partial key sequence\n-\t\treadBuf := ss.inBuf[len(ss.remainder):]\n-\t\tvar n int\n-\t\tn, err = ss.c.Read(readBuf)\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\n-\t\tif err == nil {\n-\t\t\tss.remainder = ss.inBuf[:n+len(ss.remainder)]\n-\t\t\trest := ss.remainder\n-\t\t\tlineOk := false\n-\t\t\tfor !lineOk {\n-\t\t\t\tvar key int\n-\t\t\t\tkey, rest = bytesToKey(rest)\n-\t\t\t\tif key < 0 {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t\tif key == keyCtrlD {\n-\t\t\t\t\treturn \"\", io.EOF\n-\t\t\t\t}\n-\t\t\t\tline, lineOk = ss.handleKey(key)\n-\t\t\t}\n-\t\t\tif len(rest) > 0 {\n-\t\t\t\tn := copy(ss.inBuf[:], rest)\n-\t\t\t\tss.remainder = ss.inBuf[:n]\n-\t\t\t} else {\n-\t\t\t\tss.remainder = nil\n-\t\t\t}\n-\t\t\tss.c.Write(ss.outBuf)\n-\t\t\tss.outBuf = ss.outBuf[:0]\n-\t\t\tif lineOk {\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\t}\n-\tpanic(\"unreachable\")\n-}"}, {"sha": "18d76cd6b902769d709afc54dac26871c6918662", "filename": "libgo/go/exp/terminal/terminal.go", "status": "modified", "additions": 330, "deletions": 71, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -2,102 +2,361 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package terminal provides support functions for dealing with terminals, as\n-// commonly found on UNIX systems.\n-//\n-// Putting a terminal into raw mode is the most common requirement:\n-//\n-// \toldState, err := terminal.MakeRaw(0)\n-// \tif err != nil {\n-// \t        panic(err.String())\n-// \t}\n-// \tdefer terminal.Restore(0, oldState)\n package terminal\n \n-import (\n-\t\"io\"\n-\t\"os\"\n-\t\"syscall\"\n-)\n+import \"io\"\n+\n+// Terminal contains the state for running a VT100 terminal that is capable of\n+// reading lines of input.\n+type Terminal struct {\n+\tc      io.ReadWriter\n+\tprompt string\n+\n+\t// line is the current line being entered.\n+\tline []byte\n+\t// pos is the logical position of the cursor in line\n+\tpos int\n+\n+\t// cursorX contains the current X value of the cursor where the left\n+\t// edge is 0. cursorY contains the row number where the first row of\n+\t// the current line is 0.\n+\tcursorX, cursorY int\n+\t// maxLine is the greatest value of cursorY so far.\n+\tmaxLine int\n+\n+\ttermWidth, termHeight int\n \n-// State contains the state of a terminal.\n-type State struct {\n-\ttermios syscall.Termios\n+\t// outBuf contains the terminal data to be sent.\n+\toutBuf []byte\n+\t// remainder contains the remainder of any partial key sequences after\n+\t// a read. It aliases into inBuf.\n+\tremainder []byte\n+\tinBuf     [256]byte\n }\n \n-// IsTerminal returns true if the given file descriptor is a terminal.\n-func IsTerminal(fd int) bool {\n-\tvar termios syscall.Termios\n-\te := syscall.Tcgetattr(fd, &termios)\n-\treturn e == 0\n+// NewTerminal runs a VT100 terminal on the given ReadWriter. If the ReadWriter is\n+// a local terminal, that terminal must first have been put into raw mode.\n+// prompt is a string that is written at the start of each input line (i.e.\n+// \"> \").\n+func NewTerminal(c io.ReadWriter, prompt string) *Terminal {\n+\treturn &Terminal{\n+\t\tc:          c,\n+\t\tprompt:     prompt,\n+\t\ttermWidth:  80,\n+\t\ttermHeight: 24,\n+\t}\n }\n \n-// MakeRaw put the terminal connected to the given file descriptor into raw\n-// mode and returns the previous state of the terminal so that it can be\n-// restored.\n-func MakeRaw(fd int) (*State, error) {\n-\tvar oldState State\n-\tif e := syscall.Tcgetattr(fd, &oldState.termios); e != 0 {\n-\t\treturn nil, os.Errno(e)\n+const (\n+\tkeyCtrlD     = 4\n+\tkeyEnter     = '\\r'\n+\tkeyEscape    = 27\n+\tkeyBackspace = 127\n+\tkeyUnknown   = 256 + iota\n+\tkeyUp\n+\tkeyDown\n+\tkeyLeft\n+\tkeyRight\n+\tkeyAltLeft\n+\tkeyAltRight\n+)\n+\n+// bytesToKey tries to parse a key sequence from b. If successful, it returns\n+// the key and the remainder of the input. Otherwise it returns -1.\n+func bytesToKey(b []byte) (int, []byte) {\n+\tif len(b) == 0 {\n+\t\treturn -1, nil\n+\t}\n+\n+\tif b[0] != keyEscape {\n+\t\treturn int(b[0]), b[1:]\n+\t}\n+\n+\tif len(b) >= 3 && b[0] == keyEscape && b[1] == '[' {\n+\t\tswitch b[2] {\n+\t\tcase 'A':\n+\t\t\treturn keyUp, b[3:]\n+\t\tcase 'B':\n+\t\t\treturn keyDown, b[3:]\n+\t\tcase 'C':\n+\t\t\treturn keyRight, b[3:]\n+\t\tcase 'D':\n+\t\t\treturn keyLeft, b[3:]\n+\t\t}\n+\t}\n+\n+\tif len(b) >= 6 && b[0] == keyEscape && b[1] == '[' && b[2] == '1' && b[3] == ';' && b[4] == '3' {\n+\t\tswitch b[5] {\n+\t\tcase 'C':\n+\t\t\treturn keyAltRight, b[6:]\n+\t\tcase 'D':\n+\t\t\treturn keyAltLeft, b[6:]\n+\t\t}\n+\t}\n+\n+\t// If we get here then we have a key that we don't recognise, or a\n+\t// partial sequence. It's not clear how one should find the end of a\n+\t// sequence without knowing them all, but it seems that [a-zA-Z] only\n+\t// appears at the end of a sequence.\n+\tfor i, c := range b[0:] {\n+\t\tif c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' {\n+\t\t\treturn keyUnknown, b[i+1:]\n+\t\t}\n \t}\n \n-\tnewState := oldState.termios\n-\tnewState.Iflag &^= syscall.ISTRIP | syscall.INLCR | syscall.ICRNL | syscall.IGNCR | syscall.IXON | syscall.IXOFF\n-\tnewState.Lflag &^= syscall.ECHO | syscall.ICANON | syscall.ISIG\n-\tif e := syscall.Tcsetattr(fd, syscall.TCSANOW, &newState); e != 0 {\n-\t\treturn nil, os.Errno(e)\n+\treturn -1, b\n+}\n+\n+// queue appends data to the end of t.outBuf\n+func (t *Terminal) queue(data []byte) {\n+\tif len(t.outBuf)+len(data) > cap(t.outBuf) {\n+\t\tnewOutBuf := make([]byte, len(t.outBuf), 2*(len(t.outBuf)+len(data)))\n+\t\tcopy(newOutBuf, t.outBuf)\n+\t\tt.outBuf = newOutBuf\n \t}\n \n-\treturn &oldState, nil\n+\toldLen := len(t.outBuf)\n+\tt.outBuf = t.outBuf[:len(t.outBuf)+len(data)]\n+\tcopy(t.outBuf[oldLen:], data)\n }\n \n-// Restore restores the terminal connected to the given file descriptor to a\n-// previous state.\n-func Restore(fd int, state *State) error {\n-\te := syscall.Tcsetattr(fd, syscall.TCSANOW, &state.termios)\n-\treturn os.Errno(e)\n+var eraseUnderCursor = []byte{' ', keyEscape, '[', 'D'}\n+\n+func isPrintable(key int) bool {\n+\treturn key >= 32 && key < 127\n }\n \n-// ReadPassword reads a line of input from a terminal without local echo.  This\n-// is commonly used for inputting passwords and other sensitive data. The slice\n-// returned does not include the \\n.\n-func ReadPassword(fd int) ([]byte, error) {\n-\tvar oldState syscall.Termios\n-\tif e := syscall.Tcgetattr(fd, &oldState); e != 0 {\n-\t\treturn nil, os.Errno(e)\n+// moveCursorToPos appends data to t.outBuf which will move the cursor to the\n+// given, logical position in the text.\n+func (t *Terminal) moveCursorToPos(pos int) {\n+\tx := len(t.prompt) + pos\n+\ty := x / t.termWidth\n+\tx = x % t.termWidth\n+\n+\tup := 0\n+\tif y < t.cursorY {\n+\t\tup = t.cursorY - y\n \t}\n \n-\tnewState := oldState\n-\tnewState.Lflag &^= syscall.ECHO\n-\tif e := syscall.Tcsetattr(fd, syscall.TCSANOW, &newState); e != 0 {\n-\t\treturn nil, os.Errno(e)\n+\tdown := 0\n+\tif y > t.cursorY {\n+\t\tdown = y - t.cursorY\n \t}\n \n-\tdefer func() {\n-\t\tsyscall.Tcsetattr(fd, syscall.TCSANOW, &oldState)\n-\t}()\n+\tleft := 0\n+\tif x < t.cursorX {\n+\t\tleft = t.cursorX - x\n+\t}\n \n-\tvar buf [16]byte\n-\tvar ret []byte\n-\tfor {\n-\t\tn, errno := syscall.Read(fd, buf[:])\n-\t\tif errno != 0 {\n-\t\t\treturn nil, os.Errno(errno)\n+\tright := 0\n+\tif x > t.cursorX {\n+\t\tright = x - t.cursorX\n+\t}\n+\n+\tmovement := make([]byte, 3*(up+down+left+right))\n+\tm := movement\n+\tfor i := 0; i < up; i++ {\n+\t\tm[0] = keyEscape\n+\t\tm[1] = '['\n+\t\tm[2] = 'A'\n+\t\tm = m[3:]\n+\t}\n+\tfor i := 0; i < down; i++ {\n+\t\tm[0] = keyEscape\n+\t\tm[1] = '['\n+\t\tm[2] = 'B'\n+\t\tm = m[3:]\n+\t}\n+\tfor i := 0; i < left; i++ {\n+\t\tm[0] = keyEscape\n+\t\tm[1] = '['\n+\t\tm[2] = 'D'\n+\t\tm = m[3:]\n+\t}\n+\tfor i := 0; i < right; i++ {\n+\t\tm[0] = keyEscape\n+\t\tm[1] = '['\n+\t\tm[2] = 'C'\n+\t\tm = m[3:]\n+\t}\n+\n+\tt.cursorX = x\n+\tt.cursorY = y\n+\tt.queue(movement)\n+}\n+\n+const maxLineLength = 4096\n+\n+// handleKey processes the given key and, optionally, returns a line of text\n+// that the user has entered.\n+func (t *Terminal) handleKey(key int) (line string, ok bool) {\n+\tswitch key {\n+\tcase keyBackspace:\n+\t\tif t.pos == 0 {\n+\t\t\treturn\n+\t\t}\n+\t\tt.pos--\n+\n+\t\tcopy(t.line[t.pos:], t.line[1+t.pos:])\n+\t\tt.line = t.line[:len(t.line)-1]\n+\t\tt.writeLine(t.line[t.pos:])\n+\t\tt.moveCursorToPos(t.pos)\n+\t\tt.queue(eraseUnderCursor)\n+\tcase keyAltLeft:\n+\t\t// move left by a word.\n+\t\tif t.pos == 0 {\n+\t\t\treturn\n+\t\t}\n+\t\tt.pos--\n+\t\tfor t.pos > 0 {\n+\t\t\tif t.line[t.pos] != ' ' {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tt.pos--\n+\t\t}\n+\t\tfor t.pos > 0 {\n+\t\t\tif t.line[t.pos] == ' ' {\n+\t\t\t\tt.pos++\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tt.pos--\n+\t\t}\n+\t\tt.moveCursorToPos(t.pos)\n+\tcase keyAltRight:\n+\t\t// move right by a word.\n+\t\tfor t.pos < len(t.line) {\n+\t\t\tif t.line[t.pos] == ' ' {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tt.pos++\n \t\t}\n-\t\tif n == 0 {\n-\t\t\tif len(ret) == 0 {\n-\t\t\t\treturn nil, io.EOF\n+\t\tfor t.pos < len(t.line) {\n+\t\t\tif t.line[t.pos] != ' ' {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tt.pos++\n+\t\t}\n+\t\tt.moveCursorToPos(t.pos)\n+\tcase keyLeft:\n+\t\tif t.pos == 0 {\n+\t\t\treturn\n+\t\t}\n+\t\tt.pos--\n+\t\tt.moveCursorToPos(t.pos)\n+\tcase keyRight:\n+\t\tif t.pos == len(t.line) {\n+\t\t\treturn\n+\t\t}\n+\t\tt.pos++\n+\t\tt.moveCursorToPos(t.pos)\n+\tcase keyEnter:\n+\t\tt.moveCursorToPos(len(t.line))\n+\t\tt.queue([]byte(\"\\r\\n\"))\n+\t\tline = string(t.line)\n+\t\tok = true\n+\t\tt.line = t.line[:0]\n+\t\tt.pos = 0\n+\t\tt.cursorX = 0\n+\t\tt.cursorY = 0\n+\t\tt.maxLine = 0\n+\tdefault:\n+\t\tif !isPrintable(key) {\n+\t\t\treturn\n+\t\t}\n+\t\tif len(t.line) == maxLineLength {\n+\t\t\treturn\n+\t\t}\n+\t\tif len(t.line) == cap(t.line) {\n+\t\t\tnewLine := make([]byte, len(t.line), 2*(1+len(t.line)))\n+\t\t\tcopy(newLine, t.line)\n+\t\t\tt.line = newLine\n+\t\t}\n+\t\tt.line = t.line[:len(t.line)+1]\n+\t\tcopy(t.line[t.pos+1:], t.line[t.pos:])\n+\t\tt.line[t.pos] = byte(key)\n+\t\tt.writeLine(t.line[t.pos:])\n+\t\tt.pos++\n+\t\tt.moveCursorToPos(t.pos)\n+\t}\n+\treturn\n+}\n+\n+func (t *Terminal) writeLine(line []byte) {\n+\tfor len(line) != 0 {\n+\t\tif t.cursorX == t.termWidth {\n+\t\t\tt.queue([]byte(\"\\r\\n\"))\n+\t\t\tt.cursorX = 0\n+\t\t\tt.cursorY++\n+\t\t\tif t.cursorY > t.maxLine {\n+\t\t\t\tt.maxLine = t.cursorY\n \t\t\t}\n-\t\t\tbreak\n \t\t}\n-\t\tif buf[n-1] == '\\n' {\n-\t\t\tn--\n+\n+\t\tremainingOnLine := t.termWidth - t.cursorX\n+\t\ttodo := len(line)\n+\t\tif todo > remainingOnLine {\n+\t\t\ttodo = remainingOnLine\n \t\t}\n-\t\tret = append(ret, buf[:n]...)\n-\t\tif n < len(buf) {\n-\t\t\tbreak\n+\t\tt.queue(line[:todo])\n+\t\tt.cursorX += todo\n+\t\tline = line[todo:]\n+\t}\n+}\n+\n+func (t *Terminal) Write(buf []byte) (n int, err error) {\n+\treturn t.c.Write(buf)\n+}\n+\n+// ReadLine returns a line of input from the terminal.\n+func (t *Terminal) ReadLine() (line string, err error) {\n+\tif t.cursorX == 0 {\n+\t\tt.writeLine([]byte(t.prompt))\n+\t\tt.c.Write(t.outBuf)\n+\t\tt.outBuf = t.outBuf[:0]\n+\t}\n+\n+\tfor {\n+\t\t// t.remainder is a slice at the beginning of t.inBuf\n+\t\t// containing a partial key sequence\n+\t\treadBuf := t.inBuf[len(t.remainder):]\n+\t\tvar n int\n+\t\tn, err = t.c.Read(readBuf)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\n+\t\tif err == nil {\n+\t\t\tt.remainder = t.inBuf[:n+len(t.remainder)]\n+\t\t\trest := t.remainder\n+\t\t\tlineOk := false\n+\t\t\tfor !lineOk {\n+\t\t\t\tvar key int\n+\t\t\t\tkey, rest = bytesToKey(rest)\n+\t\t\t\tif key < 0 {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tif key == keyCtrlD {\n+\t\t\t\t\treturn \"\", io.EOF\n+\t\t\t\t}\n+\t\t\t\tline, lineOk = t.handleKey(key)\n+\t\t\t}\n+\t\t\tif len(rest) > 0 {\n+\t\t\t\tn := copy(t.inBuf[:], rest)\n+\t\t\t\tt.remainder = t.inBuf[:n]\n+\t\t\t} else {\n+\t\t\t\tt.remainder = nil\n+\t\t\t}\n+\t\t\tt.c.Write(t.outBuf)\n+\t\t\tt.outBuf = t.outBuf[:0]\n+\t\t\tif lineOk {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tcontinue\n \t\t}\n \t}\n+\tpanic(\"unreachable\")\n+}\n \n-\treturn ret, nil\n+func (t *Terminal) SetSize(width, height int) {\n+\tt.termWidth, t.termHeight = width, height\n }"}, {"sha": "a2197210e2a8d4da5720b2c797afccd21156011d", "filename": "libgo/go/exp/terminal/terminal_test.go", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -41,7 +41,7 @@ func (c *MockTerminal) Write(data []byte) (n int, err error) {\n \n func TestClose(t *testing.T) {\n \tc := &MockTerminal{}\n-\tss := NewShell(c, \"> \")\n+\tss := NewTerminal(c, \"> \")\n \tline, err := ss.ReadLine()\n \tif line != \"\" {\n \t\tt.Errorf(\"Expected empty line but got: %s\", line)\n@@ -95,7 +95,7 @@ func TestKeyPresses(t *testing.T) {\n \t\t\t\ttoSend:       []byte(test.in),\n \t\t\t\tbytesPerRead: j,\n \t\t\t}\n-\t\t\tss := NewShell(c, \"> \")\n+\t\t\tss := NewTerminal(c, \"> \")\n \t\t\tline, err := ss.ReadLine()\n \t\t\tif line != test.line {\n \t\t\t\tt.Errorf(\"Line resulting from test %d (%d bytes per read) was '%s', expected '%s'\", i, j, line, test.line)", "previous_filename": "libgo/go/exp/terminal/shell_test.go"}, {"sha": "030356738697d986750f1805cbe33aea9a878685", "filename": "libgo/go/exp/terminal/util.go", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fterminal%2Futil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fexp%2Fterminal%2Futil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fterminal%2Futil.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -0,0 +1,102 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package terminal provides support functions for dealing with terminals, as\n+// commonly found on UNIX systems.\n+//\n+// Putting a terminal into raw mode is the most common requirement:\n+//\n+// \toldState, err := terminal.MakeRaw(0)\n+// \tif err != nil {\n+// \t        panic(err.String())\n+// \t}\n+// \tdefer terminal.Restore(0, oldState)\n+package terminal\n+\n+import (\n+\t\"io\"\n+\t\"syscall\"\n+)\n+\n+// State contains the state of a terminal.\n+type State struct {\n+\ttermios syscall.Termios\n+}\n+\n+// IsTerminal returns true if the given file descriptor is a terminal.\n+func IsTerminal(fd int) bool {\n+\tvar termios syscall.Termios\n+\terr := syscall.Tcgetattr(fd, &termios)\n+\treturn err == nil\n+}\n+\n+// MakeRaw put the terminal connected to the given file descriptor into raw\n+// mode and returns the previous state of the terminal so that it can be\n+// restored.\n+func MakeRaw(fd int) (*State, error) {\n+\tvar oldState State\n+\tif err := syscall.Tcgetattr(fd, &oldState.termios); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tnewState := oldState.termios\n+\tnewState.Iflag &^= syscall.ISTRIP | syscall.INLCR | syscall.ICRNL | syscall.IGNCR | syscall.IXON | syscall.IXOFF\n+\tnewState.Lflag &^= syscall.ECHO | syscall.ICANON | syscall.ISIG\n+\tif err := syscall.Tcsetattr(fd, syscall.TCSANOW, &newState); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn &oldState, nil\n+}\n+\n+// Restore restores the terminal connected to the given file descriptor to a\n+// previous state.\n+func Restore(fd int, state *State) error {\n+\terr := syscall.Tcsetattr(fd, syscall.TCSANOW, &state.termios)\n+\treturn err\n+}\n+\n+// ReadPassword reads a line of input from a terminal without local echo.  This\n+// is commonly used for inputting passwords and other sensitive data. The slice\n+// returned does not include the \\n.\n+func ReadPassword(fd int) ([]byte, error) {\n+\tvar oldState syscall.Termios\n+\tif err := syscall.Tcgetattr(fd, &oldState); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tnewState := oldState\n+\tnewState.Lflag &^= syscall.ECHO\n+\tif err := syscall.Tcsetattr(fd, syscall.TCSANOW, &newState); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tdefer func() {\n+\t\tsyscall.Tcsetattr(fd, syscall.TCSANOW, &oldState)\n+\t}()\n+\n+\tvar buf [16]byte\n+\tvar ret []byte\n+\tfor {\n+\t\tn, err := syscall.Read(fd, buf[:])\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif n == 0 {\n+\t\t\tif len(ret) == 0 {\n+\t\t\t\treturn nil, io.EOF\n+\t\t\t}\n+\t\t\tbreak\n+\t\t}\n+\t\tif buf[n-1] == '\\n' {\n+\t\t\tn--\n+\t\t}\n+\t\tret = append(ret, buf[:n]...)\n+\t\tif n < len(buf) {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\treturn ret, nil\n+}"}, {"sha": "6370560d0bfa65acfa1b71bc21febb7fecc1494e", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -357,6 +357,10 @@ var fmttests = []struct {\n \t{\"%#v\", map[string]B{\"a\": {1, 2}}, `map[string] fmt_test.B{\"a\":fmt_test.B{I:1, j:2}}`},\n \t{\"%#v\", []string{\"a\", \"b\"}, `[]string{\"a\", \"b\"}`},\n \t{\"%#v\", SI{}, `fmt_test.SI{I:interface {}(nil)}`},\n+\t{\"%#v\", []int(nil), `[]int(nil)`},\n+\t{\"%#v\", []int{}, `[]int{}`},\n+\t{\"%#v\", map[int]byte(nil), `map[int] uint8(nil)`},\n+\t{\"%#v\", map[int]byte{}, `map[int] uint8{}`},\n \n \t// slices with other formats\n \t{\"%#x\", []int{1, 2, 15}, `[0x1 0x2 0xf]`},"}, {"sha": "7143e07a36e96f6f21b6a041a377535f5c62f46c", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -795,6 +795,10 @@ BigSwitch:\n \tcase reflect.Map:\n \t\tif goSyntax {\n \t\t\tp.buf.WriteString(f.Type().String())\n+\t\t\tif f.IsNil() {\n+\t\t\t\tp.buf.WriteString(\"(nil)\")\n+\t\t\t\tbreak\n+\t\t\t}\n \t\t\tp.buf.WriteByte('{')\n \t\t} else {\n \t\t\tp.buf.Write(mapBytes)\n@@ -873,6 +877,10 @@ BigSwitch:\n \t\t}\n \t\tif goSyntax {\n \t\t\tp.buf.WriteString(value.Type().String())\n+\t\t\tif f.IsNil() {\n+\t\t\t\tp.buf.WriteString(\"(nil)\")\n+\t\t\t\tbreak\n+\t\t\t}\n \t\t\tp.buf.WriteByte('{')\n \t\t} else {\n \t\t\tp.buf.WriteByte('[')"}, {"sha": "0689bf3b6e4e35f6508962ec64a0dd0b38ea54df", "filename": "libgo/go/fmt/scan_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ffmt%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ffmt%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -324,7 +324,7 @@ var x, y Xs\n var z IntString\n \n var multiTests = []ScanfMultiTest{\n-\t{\"\", \"\", nil, nil, \"\"},\n+\t{\"\", \"\", []interface{}{}, []interface{}{}, \"\"},\n \t{\"%d\", \"23\", args(&i), args(23), \"\"},\n \t{\"%2s%3s\", \"22333\", args(&s, &t), args(\"22\", \"333\"), \"\"},\n \t{\"%2d%3d\", \"44555\", args(&i, &j), args(44, 555), \"\"},\n@@ -378,7 +378,7 @@ func testScan(name string, t *testing.T, scan func(r io.Reader, a ...interface{}\n \t\t}\n \t\tval := v.Interface()\n \t\tif !reflect.DeepEqual(val, test.out) {\n-\t\t\tt.Errorf(\"%s scanning %q: expected %v got %v, type %T\", name, test.text, test.out, val, val)\n+\t\t\tt.Errorf(\"%s scanning %q: expected %#v got %#v, type %T\", name, test.text, test.out, val, val)\n \t\t}\n \t}\n }\n@@ -417,7 +417,7 @@ func TestScanf(t *testing.T) {\n \t\t}\n \t\tval := v.Interface()\n \t\tif !reflect.DeepEqual(val, test.out) {\n-\t\t\tt.Errorf(\"scanning (%q, %q): expected %v got %v, type %T\", test.format, test.text, test.out, val, val)\n+\t\t\tt.Errorf(\"scanning (%q, %q): expected %#v got %#v, type %T\", test.format, test.text, test.out, val, val)\n \t\t}\n \t}\n }\n@@ -520,7 +520,7 @@ func testScanfMulti(name string, t *testing.T) {\n \t\t}\n \t\tresult := resultVal.Interface()\n \t\tif !reflect.DeepEqual(result, test.out) {\n-\t\t\tt.Errorf(\"scanning (%q, %q): expected %v got %v\", test.format, test.text, test.out, result)\n+\t\t\tt.Errorf(\"scanning (%q, %q): expected %#v got %#v\", test.format, test.text, test.out, result)\n \t\t}\n \t}\n }"}, {"sha": "1485f351c07e115954f9f127b3868822242519ba", "filename": "libgo/go/go/ast/ast.go", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fast.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -412,29 +412,29 @@ func (x *ChanType) End() token.Pos      { return x.Value.End() }\n // exprNode() ensures that only expression/type nodes can be\n // assigned to an ExprNode.\n //\n-func (x *BadExpr) exprNode()        {}\n-func (x *Ident) exprNode()          {}\n-func (x *Ellipsis) exprNode()       {}\n-func (x *BasicLit) exprNode()       {}\n-func (x *FuncLit) exprNode()        {}\n-func (x *CompositeLit) exprNode()   {}\n-func (x *ParenExpr) exprNode()      {}\n-func (x *SelectorExpr) exprNode()   {}\n-func (x *IndexExpr) exprNode()      {}\n-func (x *SliceExpr) exprNode()      {}\n-func (x *TypeAssertExpr) exprNode() {}\n-func (x *CallExpr) exprNode()       {}\n-func (x *StarExpr) exprNode()       {}\n-func (x *UnaryExpr) exprNode()      {}\n-func (x *BinaryExpr) exprNode()     {}\n-func (x *KeyValueExpr) exprNode()   {}\n-\n-func (x *ArrayType) exprNode()     {}\n-func (x *StructType) exprNode()    {}\n-func (x *FuncType) exprNode()      {}\n-func (x *InterfaceType) exprNode() {}\n-func (x *MapType) exprNode()       {}\n-func (x *ChanType) exprNode()      {}\n+func (*BadExpr) exprNode()        {}\n+func (*Ident) exprNode()          {}\n+func (*Ellipsis) exprNode()       {}\n+func (*BasicLit) exprNode()       {}\n+func (*FuncLit) exprNode()        {}\n+func (*CompositeLit) exprNode()   {}\n+func (*ParenExpr) exprNode()      {}\n+func (*SelectorExpr) exprNode()   {}\n+func (*IndexExpr) exprNode()      {}\n+func (*SliceExpr) exprNode()      {}\n+func (*TypeAssertExpr) exprNode() {}\n+func (*CallExpr) exprNode()       {}\n+func (*StarExpr) exprNode()       {}\n+func (*UnaryExpr) exprNode()      {}\n+func (*BinaryExpr) exprNode()     {}\n+func (*KeyValueExpr) exprNode()   {}\n+\n+func (*ArrayType) exprNode()     {}\n+func (*StructType) exprNode()    {}\n+func (*FuncType) exprNode()      {}\n+func (*InterfaceType) exprNode() {}\n+func (*MapType) exprNode()       {}\n+func (*ChanType) exprNode()      {}\n \n // ----------------------------------------------------------------------------\n // Convenience functions for Idents\n@@ -711,27 +711,27 @@ func (s *RangeStmt) End() token.Pos  { return s.Body.End() }\n // stmtNode() ensures that only statement nodes can be\n // assigned to a StmtNode.\n //\n-func (s *BadStmt) stmtNode()        {}\n-func (s *DeclStmt) stmtNode()       {}\n-func (s *EmptyStmt) stmtNode()      {}\n-func (s *LabeledStmt) stmtNode()    {}\n-func (s *ExprStmt) stmtNode()       {}\n-func (s *SendStmt) stmtNode()       {}\n-func (s *IncDecStmt) stmtNode()     {}\n-func (s *AssignStmt) stmtNode()     {}\n-func (s *GoStmt) stmtNode()         {}\n-func (s *DeferStmt) stmtNode()      {}\n-func (s *ReturnStmt) stmtNode()     {}\n-func (s *BranchStmt) stmtNode()     {}\n-func (s *BlockStmt) stmtNode()      {}\n-func (s *IfStmt) stmtNode()         {}\n-func (s *CaseClause) stmtNode()     {}\n-func (s *SwitchStmt) stmtNode()     {}\n-func (s *TypeSwitchStmt) stmtNode() {}\n-func (s *CommClause) stmtNode()     {}\n-func (s *SelectStmt) stmtNode()     {}\n-func (s *ForStmt) stmtNode()        {}\n-func (s *RangeStmt) stmtNode()      {}\n+func (*BadStmt) stmtNode()        {}\n+func (*DeclStmt) stmtNode()       {}\n+func (*EmptyStmt) stmtNode()      {}\n+func (*LabeledStmt) stmtNode()    {}\n+func (*ExprStmt) stmtNode()       {}\n+func (*SendStmt) stmtNode()       {}\n+func (*IncDecStmt) stmtNode()     {}\n+func (*AssignStmt) stmtNode()     {}\n+func (*GoStmt) stmtNode()         {}\n+func (*DeferStmt) stmtNode()      {}\n+func (*ReturnStmt) stmtNode()     {}\n+func (*BranchStmt) stmtNode()     {}\n+func (*BlockStmt) stmtNode()      {}\n+func (*IfStmt) stmtNode()         {}\n+func (*CaseClause) stmtNode()     {}\n+func (*SwitchStmt) stmtNode()     {}\n+func (*TypeSwitchStmt) stmtNode() {}\n+func (*CommClause) stmtNode()     {}\n+func (*SelectStmt) stmtNode()     {}\n+func (*ForStmt) stmtNode()        {}\n+func (*RangeStmt) stmtNode()      {}\n \n // ----------------------------------------------------------------------------\n // Declarations\n@@ -807,9 +807,9 @@ func (s *TypeSpec) End() token.Pos { return s.Type.End() }\n // specNode() ensures that only spec nodes can be\n // assigned to a Spec.\n //\n-func (s *ImportSpec) specNode() {}\n-func (s *ValueSpec) specNode()  {}\n-func (s *TypeSpec) specNode()   {}\n+func (*ImportSpec) specNode() {}\n+func (*ValueSpec) specNode()  {}\n+func (*TypeSpec) specNode()   {}\n \n // A declaration is represented by one of the following declaration nodes.\n //\n@@ -875,9 +875,9 @@ func (d *FuncDecl) End() token.Pos {\n // declNode() ensures that only declaration nodes can be\n // assigned to a DeclNode.\n //\n-func (d *BadDecl) declNode()  {}\n-func (d *GenDecl) declNode()  {}\n-func (d *FuncDecl) declNode() {}\n+func (*BadDecl) declNode()  {}\n+func (*GenDecl) declNode()  {}\n+func (*FuncDecl) declNode() {}\n \n // ----------------------------------------------------------------------------\n // Files and packages"}, {"sha": "bec235e2f98480c54dc2bf9ae9688b132eb9245e", "filename": "libgo/go/go/ast/filter.go", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -24,7 +24,7 @@ func exportFilter(name string) bool {\n // it returns false otherwise.\n //\n func FileExports(src *File) bool {\n-\treturn FilterFile(src, exportFilter)\n+\treturn filterFile(src, exportFilter, true)\n }\n \n // PackageExports trims the AST for a Go package in place such that\n@@ -35,7 +35,7 @@ func FileExports(src *File) bool {\n // it returns false otherwise.\n //\n func PackageExports(pkg *Package) bool {\n-\treturn FilterPackage(pkg, exportFilter)\n+\treturn filterPackage(pkg, exportFilter, true)\n }\n \n // ----------------------------------------------------------------------------\n@@ -72,7 +72,7 @@ func fieldName(x Expr) *Ident {\n \treturn nil\n }\n \n-func filterFieldList(fields *FieldList, filter Filter) (removedFields bool) {\n+func filterFieldList(fields *FieldList, filter Filter, export bool) (removedFields bool) {\n \tif fields == nil {\n \t\treturn false\n \t}\n@@ -93,8 +93,8 @@ func filterFieldList(fields *FieldList, filter Filter) (removedFields bool) {\n \t\t\tkeepField = len(f.Names) > 0\n \t\t}\n \t\tif keepField {\n-\t\t\tif filter == exportFilter {\n-\t\t\t\tfilterType(f.Type, filter)\n+\t\t\tif export {\n+\t\t\t\tfilterType(f.Type, filter, export)\n \t\t\t}\n \t\t\tlist[j] = f\n \t\t\tj++\n@@ -107,84 +107,84 @@ func filterFieldList(fields *FieldList, filter Filter) (removedFields bool) {\n \treturn\n }\n \n-func filterParamList(fields *FieldList, filter Filter) bool {\n+func filterParamList(fields *FieldList, filter Filter, export bool) bool {\n \tif fields == nil {\n \t\treturn false\n \t}\n \tvar b bool\n \tfor _, f := range fields.List {\n-\t\tif filterType(f.Type, filter) {\n+\t\tif filterType(f.Type, filter, export) {\n \t\t\tb = true\n \t\t}\n \t}\n \treturn b\n }\n \n-func filterType(typ Expr, f Filter) bool {\n+func filterType(typ Expr, f Filter, export bool) bool {\n \tswitch t := typ.(type) {\n \tcase *Ident:\n \t\treturn f(t.Name)\n \tcase *ParenExpr:\n-\t\treturn filterType(t.X, f)\n+\t\treturn filterType(t.X, f, export)\n \tcase *ArrayType:\n-\t\treturn filterType(t.Elt, f)\n+\t\treturn filterType(t.Elt, f, export)\n \tcase *StructType:\n-\t\tif filterFieldList(t.Fields, f) {\n+\t\tif filterFieldList(t.Fields, f, export) {\n \t\t\tt.Incomplete = true\n \t\t}\n \t\treturn len(t.Fields.List) > 0\n \tcase *FuncType:\n-\t\tb1 := filterParamList(t.Params, f)\n-\t\tb2 := filterParamList(t.Results, f)\n+\t\tb1 := filterParamList(t.Params, f, export)\n+\t\tb2 := filterParamList(t.Results, f, export)\n \t\treturn b1 || b2\n \tcase *InterfaceType:\n-\t\tif filterFieldList(t.Methods, f) {\n+\t\tif filterFieldList(t.Methods, f, export) {\n \t\t\tt.Incomplete = true\n \t\t}\n \t\treturn len(t.Methods.List) > 0\n \tcase *MapType:\n-\t\tb1 := filterType(t.Key, f)\n-\t\tb2 := filterType(t.Value, f)\n+\t\tb1 := filterType(t.Key, f, export)\n+\t\tb2 := filterType(t.Value, f, export)\n \t\treturn b1 || b2\n \tcase *ChanType:\n-\t\treturn filterType(t.Value, f)\n+\t\treturn filterType(t.Value, f, export)\n \t}\n \treturn false\n }\n \n-func filterSpec(spec Spec, f Filter) bool {\n+func filterSpec(spec Spec, f Filter, export bool) bool {\n \tswitch s := spec.(type) {\n \tcase *ValueSpec:\n \t\ts.Names = filterIdentList(s.Names, f)\n \t\tif len(s.Names) > 0 {\n-\t\t\tif f == exportFilter {\n-\t\t\t\tfilterType(s.Type, f)\n+\t\t\tif export {\n+\t\t\t\tfilterType(s.Type, f, export)\n \t\t\t}\n \t\t\treturn true\n \t\t}\n \tcase *TypeSpec:\n \t\tif f(s.Name.Name) {\n-\t\t\tif f == exportFilter {\n-\t\t\t\tfilterType(s.Type, f)\n+\t\t\tif export {\n+\t\t\t\tfilterType(s.Type, f, export)\n \t\t\t}\n \t\t\treturn true\n \t\t}\n-\t\tif f != exportFilter {\n+\t\tif !export {\n \t\t\t// For general filtering (not just exports),\n \t\t\t// filter type even if name is not filtered\n \t\t\t// out.\n \t\t\t// If the type contains filtered elements,\n \t\t\t// keep the declaration.\n-\t\t\treturn filterType(s.Type, f)\n+\t\t\treturn filterType(s.Type, f, export)\n \t\t}\n \t}\n \treturn false\n }\n \n-func filterSpecList(list []Spec, f Filter) []Spec {\n+func filterSpecList(list []Spec, f Filter, export bool) []Spec {\n \tj := 0\n \tfor _, s := range list {\n-\t\tif filterSpec(s, f) {\n+\t\tif filterSpec(s, f, export) {\n \t\t\tlist[j] = s\n \t\t\tj++\n \t\t}\n@@ -200,9 +200,13 @@ func filterSpecList(list []Spec, f Filter) []Spec {\n // filtering; it returns false otherwise.\n //\n func FilterDecl(decl Decl, f Filter) bool {\n+\treturn filterDecl(decl, f, false)\n+}\n+\n+func filterDecl(decl Decl, f Filter, export bool) bool {\n \tswitch d := decl.(type) {\n \tcase *GenDecl:\n-\t\td.Specs = filterSpecList(d.Specs, f)\n+\t\td.Specs = filterSpecList(d.Specs, f, export)\n \t\treturn len(d.Specs) > 0\n \tcase *FuncDecl:\n \t\treturn f(d.Name.Name)\n@@ -221,9 +225,13 @@ func FilterDecl(decl Decl, f Filter) bool {\n // left after filtering; it returns false otherwise.\n //\n func FilterFile(src *File, f Filter) bool {\n+\treturn filterFile(src, f, false)\n+}\n+\n+func filterFile(src *File, f Filter, export bool) bool {\n \tj := 0\n \tfor _, d := range src.Decls {\n-\t\tif FilterDecl(d, f) {\n+\t\tif filterDecl(d, f, export) {\n \t\t\tsrc.Decls[j] = d\n \t\t\tj++\n \t\t}\n@@ -244,9 +252,13 @@ func FilterFile(src *File, f Filter) bool {\n // left after filtering; it returns false otherwise.\n //\n func FilterPackage(pkg *Package, f Filter) bool {\n+\treturn filterPackage(pkg, f, false)\n+}\n+\n+func filterPackage(pkg *Package, f Filter, export bool) bool {\n \thasDecls := false\n \tfor _, src := range pkg.Files {\n-\t\tif FilterFile(src, f) {\n+\t\tif filterFile(src, f, export) {\n \t\t\thasDecls = true\n \t\t}\n \t}"}, {"sha": "e22a49aa3d6179d0b202046f7944da8b901a7300", "filename": "libgo/go/go/build/build_test.go", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -37,18 +37,20 @@ var buildPkgs = []struct {\n \t{\n \t\t\"go/build/cmdtest\",\n \t\t&DirInfo{\n-\t\t\tGoFiles: []string{\"main.go\"},\n-\t\t\tPackage: \"main\",\n-\t\t\tImports: []string{\"go/build/pkgtest\"},\n+\t\t\tGoFiles:     []string{\"main.go\"},\n+\t\t\tPackage:     \"main\",\n+\t\t\tImports:     []string{\"go/build/pkgtest\"},\n+\t\t\tTestImports: []string{},\n \t\t},\n \t},\n \t{\n \t\t\"go/build/cgotest\",\n \t\t&DirInfo{\n-\t\t\tCgoFiles: []string{\"cgotest.go\"},\n-\t\t\tCFiles:   []string{\"cgotest.c\"},\n-\t\t\tImports:  []string{\"C\", \"unsafe\"},\n-\t\t\tPackage:  \"cgotest\",\n+\t\t\tCgoFiles:    []string{\"cgotest.go\"},\n+\t\t\tCFiles:      []string{\"cgotest.c\"},\n+\t\t\tImports:     []string{\"C\", \"unsafe\"},\n+\t\t\tTestImports: []string{},\n+\t\t\tPackage:     \"cgotest\",\n \t\t},\n \t},\n }"}, {"sha": "6104c326c665ea7c0cb12419b3521e4c44c5e40f", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 34, "deletions": 2, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -13,6 +13,8 @@ import (\n \t\"io\"\n \t\"os\"\n \t\"path/filepath\"\n+\t\"strconv\"\n+\t\"strings\"\n \t\"text/tabwriter\"\n )\n \n@@ -244,6 +246,8 @@ func (p *printer) writeItem(pos token.Position, data string) {\n \tp.last = p.pos\n }\n \n+const linePrefix = \"//line \"\n+\n // writeCommentPrefix writes the whitespace before a comment.\n // If there is any pending whitespace, it consumes as much of\n // it as is likely to help position the comment nicely.\n@@ -252,7 +256,7 @@ func (p *printer) writeItem(pos token.Position, data string) {\n // a group of comments (or nil), and isKeyword indicates if the\n // next item is a keyword.\n //\n-func (p *printer) writeCommentPrefix(pos, next token.Position, prev *ast.Comment, isKeyword bool) {\n+func (p *printer) writeCommentPrefix(pos, next token.Position, prev, comment *ast.Comment, isKeyword bool) {\n \tif p.written == 0 {\n \t\t// the comment is the first item to be printed - don't write any whitespace\n \t\treturn\n@@ -337,6 +341,13 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, prev *ast.Comment\n \t\t\t}\n \t\t\tp.writeWhitespace(j)\n \t\t}\n+\n+\t\t// turn off indent if we're about to print a line directive.\n+\t\tindent := p.indent\n+\t\tif strings.HasPrefix(comment.Text, linePrefix) {\n+\t\t\tp.indent = 0\n+\t\t}\n+\n \t\t// use formfeeds to break columns before a comment;\n \t\t// this is analogous to using formfeeds to separate\n \t\t// individual lines of /*-style comments - but make\n@@ -347,6 +358,7 @@ func (p *printer) writeCommentPrefix(pos, next token.Position, prev *ast.Comment\n \t\t\tn = 1\n \t\t}\n \t\tp.writeNewlines(n, true)\n+\t\tp.indent = indent\n \t}\n }\n \n@@ -526,6 +538,26 @@ func stripCommonPrefix(lines [][]byte) {\n func (p *printer) writeComment(comment *ast.Comment) {\n \ttext := comment.Text\n \n+\tif strings.HasPrefix(text, linePrefix) {\n+\t\tpos := strings.TrimSpace(text[len(linePrefix):])\n+\t\ti := strings.LastIndex(pos, \":\")\n+\t\tif i >= 0 {\n+\t\t\t// The line directive we are about to print changed\n+\t\t\t// the Filename and Line number used by go/token\n+\t\t\t// as it was reading the input originally.\n+\t\t\t// In order to match the original input, we have to\n+\t\t\t// update our own idea of the file and line number\n+\t\t\t// accordingly, after printing the directive.\n+\t\t\tfile := pos[:i]\n+\t\t\tline, _ := strconv.Atoi(string(pos[i+1:]))\n+\t\t\tdefer func() {\n+\t\t\t\tp.pos.Filename = string(file)\n+\t\t\t\tp.pos.Line = line\n+\t\t\t\tp.pos.Column = 1\n+\t\t\t}()\n+\t\t}\n+\t}\n+\n \t// shortcut common case of //-style comments\n \tif text[1] == '/' {\n \t\tp.writeItem(p.fset.Position(comment.Pos()), p.escape(text))\n@@ -599,7 +631,7 @@ func (p *printer) intersperseComments(next token.Position, tok token.Token) (dro\n \tvar last *ast.Comment\n \tfor ; p.commentBefore(next); p.cindex++ {\n \t\tfor _, c := range p.comments[p.cindex].List {\n-\t\t\tp.writeCommentPrefix(p.fset.Position(c.Pos()), next, last, tok.IsKeyword())\n+\t\t\tp.writeCommentPrefix(p.fset.Position(c.Pos()), next, last, c, tok.IsKeyword())\n \t\t\tp.writeComment(c)\n \t\t\tlast = c\n \t\t}"}, {"sha": "56b194ffb9080c3ec6d77784a47403e9ddb7ce5c", "filename": "libgo/go/html/doc.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fhtml%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fhtml%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fdoc.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -37,7 +37,7 @@ lower-cased, and attributes are collected into a []Attribute. For example:\n \tfor {\n \t\tif z.Next() == html.ErrorToken {\n \t\t\t// Returning io.EOF indicates success.\n-\t\t\treturn z.Error()\n+\t\t\treturn z.Err()\n \t\t}\n \t\temitToken(z.Token())\n \t}\n@@ -51,7 +51,7 @@ call to Next. For example, to extract an HTML page's anchor text:\n \t\ttt := z.Next()\n \t\tswitch tt {\n \t\tcase ErrorToken:\n-\t\t\treturn z.Error()\n+\t\t\treturn z.Err()\n \t\tcase TextToken:\n \t\t\tif depth > 0 {\n \t\t\t\t// emitBytes should copy the []byte it receives,"}, {"sha": "9b7e934ac343e27b1ac9e6f55d587a421e0b729d", "filename": "libgo/go/html/parse.go", "status": "modified", "additions": 437, "deletions": 153, "changes": 590, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fhtml%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fhtml%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -29,6 +29,8 @@ type parser struct {\n \thead, form *Node\n \t// Other parsing state flags (section 11.2.3.5).\n \tscripting, framesetOK bool\n+\t// im is the current insertion mode.\n+\tim insertionMode\n \t// originalIM is the insertion mode to go back to after completing a text\n \t// or inTableText insertion mode.\n \toriginalIM insertionMode\n@@ -265,133 +267,113 @@ func (p *parser) acknowledgeSelfClosingTag() {\n \n // An insertion mode (section 11.2.3.1) is the state transition function from\n // a particular state in the HTML5 parser's state machine. It updates the\n-// parser's fields depending on parser.token (where ErrorToken means EOF). In\n-// addition to returning the next insertionMode state, it also returns whether\n-// the token was consumed.\n-type insertionMode func(*parser) (insertionMode, bool)\n-\n-// useTheRulesFor runs the delegate insertionMode over p, returning the actual\n-// insertionMode unless the delegate caused a state transition.\n-// Section 11.2.3.1, \"using the rules for\".\n-func useTheRulesFor(p *parser, actual, delegate insertionMode) (insertionMode, bool) {\n-\tim, consumed := delegate(p)\n-\tif p.originalIM == delegate {\n-\t\tp.originalIM = actual\n-\t}\n-\tif im != delegate {\n-\t\treturn im, consumed\n-\t}\n-\treturn actual, consumed\n-}\n+// parser's fields depending on parser.tok (where ErrorToken means EOF).\n+// It returns whether the token was consumed.\n+type insertionMode func(*parser) bool\n \n // setOriginalIM sets the insertion mode to return to after completing a text or\n // inTableText insertion mode.\n // Section 11.2.3.1, \"using the rules for\".\n-func (p *parser) setOriginalIM(im insertionMode) {\n+func (p *parser) setOriginalIM() {\n \tif p.originalIM != nil {\n \t\tpanic(\"html: bad parser state: originalIM was set twice\")\n \t}\n-\tp.originalIM = im\n+\tp.originalIM = p.im\n }\n \n // Section 11.2.3.1, \"reset the insertion mode\".\n-func (p *parser) resetInsertionMode() insertionMode {\n+func (p *parser) resetInsertionMode() {\n \tfor i := len(p.oe) - 1; i >= 0; i-- {\n \t\tn := p.oe[i]\n \t\tif i == 0 {\n \t\t\t// TODO: set n to the context element, for HTML fragment parsing.\n \t\t}\n \t\tswitch n.Data {\n \t\tcase \"select\":\n-\t\t\treturn inSelectIM\n+\t\t\tp.im = inSelectIM\n \t\tcase \"td\", \"th\":\n-\t\t\treturn inCellIM\n+\t\t\tp.im = inCellIM\n \t\tcase \"tr\":\n-\t\t\treturn inRowIM\n+\t\t\tp.im = inRowIM\n \t\tcase \"tbody\", \"thead\", \"tfoot\":\n-\t\t\treturn inTableBodyIM\n+\t\t\tp.im = inTableBodyIM\n \t\tcase \"caption\":\n-\t\t\t// TODO: return inCaptionIM\n+\t\t\tp.im = inCaptionIM\n \t\tcase \"colgroup\":\n-\t\t\t// TODO: return inColumnGroupIM\n+\t\t\tp.im = inColumnGroupIM\n \t\tcase \"table\":\n-\t\t\treturn inTableIM\n+\t\t\tp.im = inTableIM\n \t\tcase \"head\":\n-\t\t\treturn inBodyIM\n+\t\t\tp.im = inBodyIM\n \t\tcase \"body\":\n-\t\t\treturn inBodyIM\n+\t\t\tp.im = inBodyIM\n \t\tcase \"frameset\":\n-\t\t\t// TODO: return inFramesetIM\n+\t\t\tp.im = inFramesetIM\n \t\tcase \"html\":\n-\t\t\treturn beforeHeadIM\n+\t\t\tp.im = beforeHeadIM\n+\t\tdefault:\n+\t\t\tcontinue\n \t\t}\n+\t\treturn\n \t}\n-\treturn inBodyIM\n+\tp.im = inBodyIM\n }\n \n // Section 11.2.5.4.1.\n-func initialIM(p *parser) (insertionMode, bool) {\n+func initialIM(p *parser) bool {\n \tswitch p.tok.Type {\n \tcase CommentToken:\n \t\tp.doc.Add(&Node{\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n-\t\treturn initialIM, true\n+\t\treturn true\n \tcase DoctypeToken:\n \t\tp.doc.Add(&Node{\n \t\t\tType: DoctypeNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n-\t\treturn beforeHTMLIM, true\n+\t\tp.im = beforeHTMLIM\n+\t\treturn true\n \t}\n \t// TODO: set \"quirks mode\"? It's defined in the DOM spec instead of HTML5 proper,\n \t// and so switching on \"quirks mode\" might belong in a different package.\n-\treturn beforeHTMLIM, false\n+\tp.im = beforeHTMLIM\n+\treturn false\n }\n \n // Section 11.2.5.4.2.\n-func beforeHTMLIM(p *parser) (insertionMode, bool) {\n-\tvar (\n-\t\tadd     bool\n-\t\tattr    []Attribute\n-\t\timplied bool\n-\t)\n+func beforeHTMLIM(p *parser) bool {\n \tswitch p.tok.Type {\n-\tcase ErrorToken:\n-\t\timplied = true\n-\tcase TextToken:\n-\t\t// TODO: distinguish whitespace text from others.\n-\t\timplied = true\n \tcase StartTagToken:\n \t\tif p.tok.Data == \"html\" {\n-\t\t\tadd = true\n-\t\t\tattr = p.tok.Attr\n-\t\t} else {\n-\t\t\timplied = true\n+\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\tp.im = beforeHeadIM\n+\t\t\treturn true\n \t\t}\n \tcase EndTagToken:\n \t\tswitch p.tok.Data {\n \t\tcase \"head\", \"body\", \"html\", \"br\":\n-\t\t\timplied = true\n+\t\t\t// Drop down to creating an implied <html> tag.\n \t\tdefault:\n \t\t\t// Ignore the token.\n+\t\t\treturn true\n \t\t}\n \tcase CommentToken:\n \t\tp.doc.Add(&Node{\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n-\t\treturn beforeHTMLIM, true\n-\t}\n-\tif add || implied {\n-\t\tp.addElement(\"html\", attr)\n+\t\treturn true\n \t}\n-\treturn beforeHeadIM, !implied\n+\t// Create an implied <html> tag.\n+\tp.addElement(\"html\", nil)\n+\tp.im = beforeHeadIM\n+\treturn false\n }\n \n // Section 11.2.5.4.3.\n-func beforeHeadIM(p *parser) (insertionMode, bool) {\n+func beforeHeadIM(p *parser) bool {\n \tvar (\n \t\tadd     bool\n \t\tattr    []Attribute\n@@ -409,7 +391,7 @@ func beforeHeadIM(p *parser) (insertionMode, bool) {\n \t\t\tadd = true\n \t\t\tattr = p.tok.Attr\n \t\tcase \"html\":\n-\t\t\treturn useTheRulesFor(p, beforeHeadIM, inBodyIM)\n+\t\t\treturn inBodyIM(p)\n \t\tdefault:\n \t\t\timplied = true\n \t\t}\n@@ -425,19 +407,20 @@ func beforeHeadIM(p *parser) (insertionMode, bool) {\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n-\t\treturn beforeHeadIM, true\n+\t\treturn true\n \t}\n \tif add || implied {\n \t\tp.addElement(\"head\", attr)\n \t\tp.head = p.top()\n \t}\n-\treturn inHeadIM, !implied\n+\tp.im = inHeadIM\n+\treturn !implied\n }\n \n const whitespace = \" \\t\\r\\n\\f\"\n \n // Section 11.2.5.4.4.\n-func inHeadIM(p *parser) (insertionMode, bool) {\n+func inHeadIM(p *parser) bool {\n \tvar (\n \t\tpop     bool\n \t\timplied bool\n@@ -451,7 +434,7 @@ func inHeadIM(p *parser) (insertionMode, bool) {\n \t\t\t// Add the initial whitespace to the current node.\n \t\t\tp.addText(p.tok.Data[:len(p.tok.Data)-len(s)])\n \t\t\tif s == \"\" {\n-\t\t\t\treturn inHeadIM, true\n+\t\t\t\treturn true\n \t\t\t}\n \t\t\tp.tok.Data = s\n \t\t}\n@@ -464,35 +447,42 @@ func inHeadIM(p *parser) (insertionMode, bool) {\n \t\t\tp.acknowledgeSelfClosingTag()\n \t\tcase \"script\", \"title\", \"noscript\", \"noframes\", \"style\":\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n-\t\t\tp.setOriginalIM(inHeadIM)\n-\t\t\treturn textIM, true\n+\t\t\tp.setOriginalIM()\n+\t\t\tp.im = textIM\n+\t\t\treturn true\n \t\tdefault:\n \t\t\timplied = true\n \t\t}\n \tcase EndTagToken:\n-\t\tif p.tok.Data == \"head\" {\n+\t\tswitch p.tok.Data {\n+\t\tcase \"head\":\n \t\t\tpop = true\n+\t\tcase \"body\", \"html\", \"br\":\n+\t\t\timplied = true\n+\t\tdefault:\n+\t\t\t// Ignore the token.\n+\t\t\treturn true\n \t\t}\n-\t\t// TODO.\n \tcase CommentToken:\n \t\tp.addChild(&Node{\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n-\t\treturn inHeadIM, true\n+\t\treturn true\n \t}\n \tif pop || implied {\n \t\tn := p.oe.pop()\n \t\tif n.Data != \"head\" {\n \t\t\tpanic(\"html: bad parser state: <head> element not found, in the in-head insertion mode\")\n \t\t}\n-\t\treturn afterHeadIM, !implied\n+\t\tp.im = afterHeadIM\n+\t\treturn !implied\n \t}\n-\treturn inHeadIM, true\n+\treturn true\n }\n \n // Section 11.2.5.4.6.\n-func afterHeadIM(p *parser) (insertionMode, bool) {\n+func afterHeadIM(p *parser) bool {\n \tvar (\n \t\tadd        bool\n \t\tattr       []Attribute\n@@ -512,31 +502,41 @@ func afterHeadIM(p *parser) (insertionMode, bool) {\n \t\t\tattr = p.tok.Attr\n \t\t\tframesetOK = false\n \t\tcase \"frameset\":\n-\t\t\t// TODO.\n+\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\tp.im = inFramesetIM\n+\t\t\treturn true\n \t\tcase \"base\", \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\":\n \t\t\tp.oe = append(p.oe, p.head)\n \t\t\tdefer p.oe.pop()\n-\t\t\treturn useTheRulesFor(p, afterHeadIM, inHeadIM)\n+\t\t\treturn inHeadIM(p)\n \t\tcase \"head\":\n \t\t\t// TODO.\n \t\tdefault:\n \t\t\timplied = true\n \t\t\tframesetOK = true\n \t\t}\n \tcase EndTagToken:\n-\t\t// TODO.\n+\t\tswitch p.tok.Data {\n+\t\tcase \"body\", \"html\", \"br\":\n+\t\t\timplied = true\n+\t\t\tframesetOK = true\n+\t\tdefault:\n+\t\t\t// Ignore the token.\n+\t\t\treturn true\n+\t\t}\n \tcase CommentToken:\n \t\tp.addChild(&Node{\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n-\t\treturn afterHeadIM, true\n+\t\treturn true\n \t}\n \tif add || implied {\n \t\tp.addElement(\"body\", attr)\n \t\tp.framesetOK = framesetOK\n \t}\n-\treturn inBodyIM, !implied\n+\tp.im = inBodyIM\n+\treturn !implied\n }\n \n // copyAttributes copies attributes of src not found on dst to dst.\n@@ -557,7 +557,7 @@ func copyAttributes(dst *Node, src Token) {\n }\n \n // Section 11.2.5.4.7.\n-func inBodyIM(p *parser) (insertionMode, bool) {\n+func inBodyIM(p *parser) bool {\n \tswitch p.tok.Type {\n \tcase TextToken:\n \t\tp.reconstructActiveFormattingElements()\n@@ -604,7 +604,8 @@ func inBodyIM(p *parser) (insertionMode, bool) {\n \t\t\tp.popUntil(buttonScopeStopTags, \"p\") // TODO: skip this step in quirks mode.\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\t\tp.framesetOK = false\n-\t\t\treturn inTableIM, true\n+\t\t\tp.im = inTableIM\n+\t\t\treturn true\n \t\tcase \"hr\":\n \t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n@@ -616,7 +617,14 @@ func inBodyIM(p *parser) (insertionMode, bool) {\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\t\tp.framesetOK = false\n \t\t\t// TODO: detect <select> inside a table.\n-\t\t\treturn inSelectIM, true\n+\t\t\tp.im = inSelectIM\n+\t\t\treturn true\n+\t\tcase \"form\":\n+\t\t\tif p.form == nil {\n+\t\t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n+\t\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\t\tp.form = p.top()\n+\t\t\t}\n \t\tcase \"li\":\n \t\t\tp.framesetOK = false\n \t\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n@@ -634,7 +642,28 @@ func inBodyIM(p *parser) (insertionMode, bool) {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n-\t\t\tp.addElement(\"li\", p.tok.Attr)\n+\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\tcase \"dd\", \"dt\":\n+\t\t\tp.framesetOK = false\n+\t\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n+\t\t\t\tnode := p.oe[i]\n+\t\t\t\tswitch node.Data {\n+\t\t\t\tcase \"dd\", \"dt\":\n+\t\t\t\t\tp.oe = p.oe[:i]\n+\t\t\t\tcase \"address\", \"div\", \"p\":\n+\t\t\t\t\tcontinue\n+\t\t\t\tdefault:\n+\t\t\t\t\tif !isSpecialElement[node.Data] {\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n+\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\tcase \"plaintext\":\n+\t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n+\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\tcase \"optgroup\", \"option\":\n \t\t\tif p.top().Data == \"option\" {\n \t\t\t\tp.oe.pop()\n@@ -650,10 +679,50 @@ func inBodyIM(p *parser) (insertionMode, bool) {\n \t\t\t\t}\n \t\t\t}\n \t\tcase \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\":\n-\t\t\treturn useTheRulesFor(p, inBodyIM, inHeadIM)\n+\t\t\treturn inHeadIM(p)\n \t\tcase \"image\":\n \t\t\tp.tok.Data = \"img\"\n-\t\t\treturn inBodyIM, false\n+\t\t\treturn false\n+\t\tcase \"isindex\":\n+\t\t\tif p.form != nil {\n+\t\t\t\t// Ignore the token.\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t\taction := \"\"\n+\t\t\tprompt := \"This is a searchable index. Enter search keywords: \"\n+\t\t\tattr := []Attribute{{Key: \"name\", Val: \"isindex\"}}\n+\t\t\tfor _, a := range p.tok.Attr {\n+\t\t\t\tswitch a.Key {\n+\t\t\t\tcase \"action\":\n+\t\t\t\t\taction = a.Val\n+\t\t\t\tcase \"name\":\n+\t\t\t\t\t// Ignore the attribute.\n+\t\t\t\tcase \"prompt\":\n+\t\t\t\t\tprompt = a.Val\n+\t\t\t\tdefault:\n+\t\t\t\t\tattr = append(attr, a)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tp.acknowledgeSelfClosingTag()\n+\t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n+\t\t\tp.addElement(\"form\", nil)\n+\t\t\tp.form = p.top()\n+\t\t\tif action != \"\" {\n+\t\t\t\tp.form.Attr = []Attribute{{Key: \"action\", Val: action}}\n+\t\t\t}\n+\t\t\tp.addElement(\"hr\", nil)\n+\t\t\tp.oe.pop()\n+\t\t\tp.addElement(\"label\", nil)\n+\t\t\tp.addText(prompt)\n+\t\t\tp.addElement(\"input\", attr)\n+\t\t\tp.oe.pop()\n+\t\t\tp.oe.pop()\n+\t\t\tp.addElement(\"hr\", nil)\n+\t\t\tp.oe.pop()\n+\t\t\tp.oe.pop()\n+\t\t\tp.form = nil\n+\t\tcase \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\":\n+\t\t\t// Ignore the token.\n \t\tdefault:\n \t\t\t// TODO.\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n@@ -662,7 +731,8 @@ func inBodyIM(p *parser) (insertionMode, bool) {\n \t\tswitch p.tok.Data {\n \t\tcase \"body\":\n \t\t\t// TODO: autoclose the stack of open elements.\n-\t\t\treturn afterBodyIM, true\n+\t\t\tp.im = afterBodyIM\n+\t\t\treturn true\n \t\tcase \"p\":\n \t\t\tif !p.elementInScope(buttonScopeStopTags, \"p\") {\n \t\t\t\tp.addElement(\"p\", nil)\n@@ -676,6 +746,9 @@ func inBodyIM(p *parser) (insertionMode, bool) {\n \t\t\tif p.popUntil(defaultScopeStopTags, p.tok.Data) {\n \t\t\t\tp.clearActiveFormattingElements()\n \t\t\t}\n+\t\tcase \"br\":\n+\t\t\tp.tok.Type = StartTagToken\n+\t\t\treturn false\n \t\tdefault:\n \t\t\tp.inBodyEndTagOther(p.tok.Data)\n \t\t}\n@@ -686,7 +759,7 @@ func inBodyIM(p *parser) (insertionMode, bool) {\n \t\t})\n \t}\n \n-\treturn inBodyIM, true\n+\treturn true\n }\n \n func (p *parser) inBodyEndTagFormatting(tag string) {\n@@ -827,66 +900,86 @@ func (p *parser) inBodyEndTagOther(tag string) {\n }\n \n // Section 11.2.5.4.8.\n-func textIM(p *parser) (insertionMode, bool) {\n+func textIM(p *parser) bool {\n \tswitch p.tok.Type {\n \tcase ErrorToken:\n \t\tp.oe.pop()\n \tcase TextToken:\n \t\tp.addText(p.tok.Data)\n-\t\treturn textIM, true\n+\t\treturn true\n \tcase EndTagToken:\n \t\tp.oe.pop()\n \t}\n-\to := p.originalIM\n+\tp.im = p.originalIM\n \tp.originalIM = nil\n-\treturn o, p.tok.Type == EndTagToken\n+\treturn p.tok.Type == EndTagToken\n }\n \n // Section 11.2.5.4.9.\n-func inTableIM(p *parser) (insertionMode, bool) {\n+func inTableIM(p *parser) bool {\n \tswitch p.tok.Type {\n \tcase ErrorToken:\n \t\t// Stop parsing.\n-\t\treturn nil, true\n+\t\treturn true\n \tcase TextToken:\n \t\t// TODO.\n \tcase StartTagToken:\n \t\tswitch p.tok.Data {\n+\t\tcase \"caption\":\n+\t\t\tp.clearStackToContext(tableScopeStopTags)\n+\t\t\tp.afe = append(p.afe, &scopeMarker)\n+\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\tp.im = inCaptionIM\n+\t\t\treturn true\n \t\tcase \"tbody\", \"tfoot\", \"thead\":\n \t\t\tp.clearStackToContext(tableScopeStopTags)\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n-\t\t\treturn inTableBodyIM, true\n+\t\t\tp.im = inTableBodyIM\n+\t\t\treturn true\n \t\tcase \"td\", \"th\", \"tr\":\n \t\t\tp.clearStackToContext(tableScopeStopTags)\n \t\t\tp.addElement(\"tbody\", nil)\n-\t\t\treturn inTableBodyIM, false\n+\t\t\tp.im = inTableBodyIM\n+\t\t\treturn false\n \t\tcase \"table\":\n \t\t\tif p.popUntil(tableScopeStopTags, \"table\") {\n-\t\t\t\treturn p.resetInsertionMode(), false\n+\t\t\t\tp.resetInsertionMode()\n+\t\t\t\treturn false\n \t\t\t}\n \t\t\t// Ignore the token.\n-\t\t\treturn inTableIM, true\n+\t\t\treturn true\n+\t\tcase \"colgroup\":\n+\t\t\tp.clearStackToContext(tableScopeStopTags)\n+\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\tp.im = inColumnGroupIM\n+\t\t\treturn true\n+\t\tcase \"col\":\n+\t\t\tp.clearStackToContext(tableScopeStopTags)\n+\t\t\tp.addElement(\"colgroup\", p.tok.Attr)\n+\t\t\tp.im = inColumnGroupIM\n+\t\t\treturn false\n \t\tdefault:\n \t\t\t// TODO.\n \t\t}\n \tcase EndTagToken:\n \t\tswitch p.tok.Data {\n \t\tcase \"table\":\n \t\t\tif p.popUntil(tableScopeStopTags, \"table\") {\n-\t\t\t\treturn p.resetInsertionMode(), true\n+\t\t\t\tp.resetInsertionMode()\n+\t\t\t\treturn true\n \t\t\t}\n \t\t\t// Ignore the token.\n-\t\t\treturn inTableIM, true\n+\t\t\treturn true\n \t\tcase \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\":\n \t\t\t// Ignore the token.\n-\t\t\treturn inTableIM, true\n+\t\t\treturn true\n \t\t}\n \tcase CommentToken:\n \t\tp.addChild(&Node{\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n-\t\treturn inTableIM, true\n+\t\treturn true\n \t}\n \n \tswitch p.top().Data {\n@@ -895,7 +988,7 @@ func inTableIM(p *parser) (insertionMode, bool) {\n \t\tdefer func() { p.fosterParenting = false }()\n \t}\n \n-\treturn useTheRulesFor(p, inTableIM, inBodyIM)\n+\treturn inBodyIM(p)\n }\n \n // clearStackToContext pops elements off the stack of open elements\n@@ -911,8 +1004,90 @@ func (p *parser) clearStackToContext(stopTags []string) {\n \t}\n }\n \n+// Section 11.2.5.4.11.\n+func inCaptionIM(p *parser) bool {\n+\tswitch p.tok.Type {\n+\tcase StartTagToken:\n+\t\tswitch p.tok.Data {\n+\t\tcase \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"thead\", \"tr\":\n+\t\t\tif p.popUntil(tableScopeStopTags, \"caption\") {\n+\t\t\t\tp.clearActiveFormattingElements()\n+\t\t\t\tp.im = inTableIM\n+\t\t\t\treturn false\n+\t\t\t} else {\n+\t\t\t\t// Ignore the token.\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\tcase EndTagToken:\n+\t\tswitch p.tok.Data {\n+\t\tcase \"caption\":\n+\t\t\tif p.popUntil(tableScopeStopTags, \"caption\") {\n+\t\t\t\tp.clearActiveFormattingElements()\n+\t\t\t\tp.im = inTableIM\n+\t\t\t}\n+\t\t\treturn true\n+\t\tcase \"table\":\n+\t\t\tif p.popUntil(tableScopeStopTags, \"caption\") {\n+\t\t\t\tp.clearActiveFormattingElements()\n+\t\t\t\tp.im = inTableIM\n+\t\t\t\treturn false\n+\t\t\t} else {\n+\t\t\t\t// Ignore the token.\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\tcase \"body\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\":\n+\t\t\t// Ignore the token.\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn inBodyIM(p)\n+}\n+\n+// Section 11.2.5.4.12.\n+func inColumnGroupIM(p *parser) bool {\n+\tswitch p.tok.Type {\n+\tcase CommentToken:\n+\t\tp.addChild(&Node{\n+\t\t\tType: CommentNode,\n+\t\t\tData: p.tok.Data,\n+\t\t})\n+\t\treturn true\n+\tcase DoctypeToken:\n+\t\t// Ignore the token.\n+\t\treturn true\n+\tcase StartTagToken:\n+\t\tswitch p.tok.Data {\n+\t\tcase \"html\":\n+\t\t\treturn inBodyIM(p)\n+\t\tcase \"col\":\n+\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\tp.oe.pop()\n+\t\t\tp.acknowledgeSelfClosingTag()\n+\t\t\treturn true\n+\t\t}\n+\tcase EndTagToken:\n+\t\tswitch p.tok.Data {\n+\t\tcase \"colgroup\":\n+\t\t\tif p.oe.top().Data != \"html\" {\n+\t\t\t\tp.oe.pop()\n+\t\t\t}\n+\t\t\tp.im = inTableIM\n+\t\t\treturn true\n+\t\tcase \"col\":\n+\t\t\t// Ignore the token.\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\tif p.oe.top().Data != \"html\" {\n+\t\tp.oe.pop()\n+\t}\n+\tp.im = inTableIM\n+\treturn false\n+}\n+\n // Section 11.2.5.4.13.\n-func inTableBodyIM(p *parser) (insertionMode, bool) {\n+func inTableBodyIM(p *parser) bool {\n \tvar (\n \t\tadd      bool\n \t\tdata     string\n@@ -942,31 +1117,33 @@ func inTableBodyIM(p *parser) (insertionMode, bool) {\n \t\tswitch p.tok.Data {\n \t\tcase \"table\":\n \t\t\tif p.popUntil(tableScopeStopTags, \"tbody\", \"thead\", \"tfoot\") {\n-\t\t\t\treturn inTableIM, false\n+\t\t\t\tp.im = inTableIM\n+\t\t\t\treturn false\n \t\t\t}\n \t\t\t// Ignore the token.\n-\t\t\treturn inTableBodyIM, true\n+\t\t\treturn true\n \t\tcase \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\", \"tr\":\n \t\t\t// Ignore the token.\n-\t\t\treturn inTableBodyIM, true\n+\t\t\treturn true\n \t\t}\n \tcase CommentToken:\n \t\tp.addChild(&Node{\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n-\t\treturn inTableBodyIM, true\n+\t\treturn true\n \t}\n \tif add {\n \t\t// TODO: clear the stack back to a table body context.\n \t\tp.addElement(data, attr)\n-\t\treturn inRowIM, consumed\n+\t\tp.im = inRowIM\n+\t\treturn consumed\n \t}\n-\treturn useTheRulesFor(p, inTableBodyIM, inTableIM)\n+\treturn inTableIM(p)\n }\n \n // Section 11.2.5.4.14.\n-func inRowIM(p *parser) (insertionMode, bool) {\n+func inRowIM(p *parser) bool {\n \tswitch p.tok.Type {\n \tcase ErrorToken:\n \t\t// TODO.\n@@ -978,35 +1155,39 @@ func inRowIM(p *parser) (insertionMode, bool) {\n \t\t\tp.clearStackToContext(tableRowContextStopTags)\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\t\tp.afe = append(p.afe, &scopeMarker)\n-\t\t\treturn inCellIM, true\n+\t\t\tp.im = inCellIM\n+\t\t\treturn true\n \t\tcase \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\", \"tr\":\n \t\t\tif p.popUntil(tableScopeStopTags, \"tr\") {\n-\t\t\t\treturn inTableBodyIM, false\n+\t\t\t\tp.im = inTableBodyIM\n+\t\t\t\treturn false\n \t\t\t}\n \t\t\t// Ignore the token.\n-\t\t\treturn inRowIM, true\n+\t\t\treturn true\n \t\tdefault:\n \t\t\t// TODO.\n \t\t}\n \tcase EndTagToken:\n \t\tswitch p.tok.Data {\n \t\tcase \"tr\":\n \t\t\tif p.popUntil(tableScopeStopTags, \"tr\") {\n-\t\t\t\treturn inTableBodyIM, true\n+\t\t\t\tp.im = inTableBodyIM\n+\t\t\t\treturn true\n \t\t\t}\n \t\t\t// Ignore the token.\n-\t\t\treturn inRowIM, true\n+\t\t\treturn true\n \t\tcase \"table\":\n \t\t\tif p.popUntil(tableScopeStopTags, \"tr\") {\n-\t\t\t\treturn inTableBodyIM, false\n+\t\t\t\tp.im = inTableBodyIM\n+\t\t\t\treturn false\n \t\t\t}\n \t\t\t// Ignore the token.\n-\t\t\treturn inRowIM, true\n+\t\t\treturn true\n \t\tcase \"tbody\", \"tfoot\", \"thead\":\n \t\t\t// TODO.\n \t\tcase \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\":\n \t\t\t// Ignore the token.\n-\t\t\treturn inRowIM, true\n+\t\t\treturn true\n \t\tdefault:\n \t\t\t// TODO.\n \t\t}\n@@ -1015,13 +1196,13 @@ func inRowIM(p *parser) (insertionMode, bool) {\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n-\t\treturn inRowIM, true\n+\t\treturn true\n \t}\n-\treturn useTheRulesFor(p, inRowIM, inTableIM)\n+\treturn inTableIM(p)\n }\n \n // Section 11.2.5.4.15.\n-func inCellIM(p *parser) (insertionMode, bool) {\n+func inCellIM(p *parser) bool {\n \tvar (\n \t\tcloseTheCellAndReprocess bool\n \t)\n@@ -1037,10 +1218,11 @@ func inCellIM(p *parser) (insertionMode, bool) {\n \t\tcase \"td\", \"th\":\n \t\t\tif !p.popUntil(tableScopeStopTags, p.tok.Data) {\n \t\t\t\t// Ignore the token.\n-\t\t\t\treturn inCellIM, true\n+\t\t\t\treturn true\n \t\t\t}\n \t\t\tp.clearActiveFormattingElements()\n-\t\t\treturn inRowIM, true\n+\t\t\tp.im = inRowIM\n+\t\t\treturn true\n \t\tcase \"body\", \"caption\", \"col\", \"colgroup\", \"html\":\n \t\t\t// TODO.\n \t\tcase \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\":\n@@ -1052,19 +1234,20 @@ func inCellIM(p *parser) (insertionMode, bool) {\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n-\t\treturn inCellIM, true\n+\t\treturn true\n \t}\n \tif closeTheCellAndReprocess {\n \t\tif p.popUntil(tableScopeStopTags, \"td\") || p.popUntil(tableScopeStopTags, \"th\") {\n \t\t\tp.clearActiveFormattingElements()\n-\t\t\treturn inRowIM, false\n+\t\t\tp.im = inRowIM\n+\t\t\treturn false\n \t\t}\n \t}\n-\treturn useTheRulesFor(p, inCellIM, inBodyIM)\n+\treturn inBodyIM(p)\n }\n \n // Section 11.2.5.4.16.\n-func inSelectIM(p *parser) (insertionMode, bool) {\n+func inSelectIM(p *parser) bool {\n \tendSelect := false\n \tswitch p.tok.Type {\n \tcase ErrorToken:\n@@ -1081,7 +1264,13 @@ func inSelectIM(p *parser) (insertionMode, bool) {\n \t\t\t}\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\tcase \"optgroup\":\n-\t\t\t// TODO.\n+\t\t\tif p.top().Data == \"option\" {\n+\t\t\t\tp.oe.pop()\n+\t\t\t}\n+\t\t\tif p.top().Data == \"optgroup\" {\n+\t\t\t\tp.oe.pop()\n+\t\t\t}\n+\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\tcase \"select\":\n \t\t\tendSelect = true\n \t\tcase \"input\", \"keygen\", \"textarea\":\n@@ -1094,9 +1283,17 @@ func inSelectIM(p *parser) (insertionMode, bool) {\n \tcase EndTagToken:\n \t\tswitch p.tok.Data {\n \t\tcase \"option\":\n-\t\t\t// TODO.\n+\t\t\tif p.top().Data == \"option\" {\n+\t\t\t\tp.oe.pop()\n+\t\t\t}\n \t\tcase \"optgroup\":\n-\t\t\t// TODO.\n+\t\t\ti := len(p.oe) - 1\n+\t\t\tif p.oe[i].Data == \"option\" {\n+\t\t\t\ti--\n+\t\t\t}\n+\t\t\tif p.oe[i].Data == \"optgroup\" {\n+\t\t\t\tp.oe = p.oe[:i]\n+\t\t\t}\n \t\tcase \"select\":\n \t\t\tendSelect = true\n \t\tdefault:\n@@ -1113,34 +1310,33 @@ func inSelectIM(p *parser) (insertionMode, bool) {\n \t\t\tswitch p.oe[i].Data {\n \t\t\tcase \"select\":\n \t\t\t\tp.oe = p.oe[:i]\n-\t\t\t\treturn p.resetInsertionMode(), true\n+\t\t\t\tp.resetInsertionMode()\n+\t\t\t\treturn true\n \t\t\tcase \"option\", \"optgroup\":\n \t\t\t\tcontinue\n \t\t\tdefault:\n \t\t\t\t// Ignore the token.\n-\t\t\t\treturn inSelectIM, true\n+\t\t\t\treturn true\n \t\t\t}\n \t\t}\n \t}\n-\treturn inSelectIM, true\n+\treturn true\n }\n \n // Section 11.2.5.4.18.\n-func afterBodyIM(p *parser) (insertionMode, bool) {\n+func afterBodyIM(p *parser) bool {\n \tswitch p.tok.Type {\n \tcase ErrorToken:\n-\t\t// TODO.\n-\tcase TextToken:\n-\t\t// TODO.\n+\t\t// Stop parsing.\n+\t\treturn true\n \tcase StartTagToken:\n-\t\t// TODO.\n+\t\tif p.tok.Data == \"html\" {\n+\t\t\treturn inBodyIM(p)\n+\t\t}\n \tcase EndTagToken:\n-\t\tswitch p.tok.Data {\n-\t\tcase \"html\":\n-\t\t\t// TODO: autoclose the stack of open elements.\n-\t\t\treturn afterAfterBodyIM, true\n-\t\tdefault:\n-\t\t\t// TODO.\n+\t\tif p.tok.Data == \"html\" {\n+\t\t\tp.im = afterAfterBodyIM\n+\t\t\treturn true\n \t\t}\n \tcase CommentToken:\n \t\t// The comment is attached to the <html> element.\n@@ -1151,32 +1347,119 @@ func afterBodyIM(p *parser) (insertionMode, bool) {\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n-\t\treturn afterBodyIM, true\n+\t\treturn true\n+\t}\n+\tp.im = inBodyIM\n+\treturn false\n+}\n+\n+// Section 11.2.5.4.19.\n+func inFramesetIM(p *parser) bool {\n+\tswitch p.tok.Type {\n+\tcase CommentToken:\n+\t\tp.addChild(&Node{\n+\t\t\tType: CommentNode,\n+\t\t\tData: p.tok.Data,\n+\t\t})\n+\tcase StartTagToken:\n+\t\tswitch p.tok.Data {\n+\t\tcase \"html\":\n+\t\t\treturn inBodyIM(p)\n+\t\tcase \"frameset\":\n+\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\tcase \"frame\":\n+\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\tp.oe.pop()\n+\t\t\tp.acknowledgeSelfClosingTag()\n+\t\tcase \"noframes\":\n+\t\t\treturn inHeadIM(p)\n+\t\t}\n+\tcase EndTagToken:\n+\t\tswitch p.tok.Data {\n+\t\tcase \"frameset\":\n+\t\t\tif p.oe.top().Data != \"html\" {\n+\t\t\t\tp.oe.pop()\n+\t\t\t\tif p.oe.top().Data != \"frameset\" {\n+\t\t\t\t\tp.im = afterFramesetIM\n+\t\t\t\t\treturn true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\tdefault:\n+\t\t// Ignore the token.\n+\t}\n+\treturn true\n+}\n+\n+// Section 11.2.5.4.20.\n+func afterFramesetIM(p *parser) bool {\n+\tswitch p.tok.Type {\n+\tcase CommentToken:\n+\t\tp.addChild(&Node{\n+\t\t\tType: CommentNode,\n+\t\t\tData: p.tok.Data,\n+\t\t})\n+\tcase StartTagToken:\n+\t\tswitch p.tok.Data {\n+\t\tcase \"html\":\n+\t\t\treturn inBodyIM(p)\n+\t\tcase \"noframes\":\n+\t\t\treturn inHeadIM(p)\n+\t\t}\n+\tcase EndTagToken:\n+\t\tswitch p.tok.Data {\n+\t\tcase \"html\":\n+\t\t\tp.im = afterAfterFramesetIM\n+\t\t\treturn true\n+\t\t}\n+\tdefault:\n+\t\t// Ignore the token.\n \t}\n-\t// TODO: should this be \"return inBodyIM, true\"?\n-\treturn afterBodyIM, true\n+\treturn true\n }\n \n // Section 11.2.5.4.21.\n-func afterAfterBodyIM(p *parser) (insertionMode, bool) {\n+func afterAfterBodyIM(p *parser) bool {\n \tswitch p.tok.Type {\n \tcase ErrorToken:\n \t\t// Stop parsing.\n-\t\treturn nil, true\n+\t\treturn true\n \tcase TextToken:\n \t\t// TODO.\n \tcase StartTagToken:\n \t\tif p.tok.Data == \"html\" {\n-\t\t\treturn useTheRulesFor(p, afterAfterBodyIM, inBodyIM)\n+\t\t\treturn inBodyIM(p)\n \t\t}\n \tcase CommentToken:\n \t\tp.doc.Add(&Node{\n \t\t\tType: CommentNode,\n \t\t\tData: p.tok.Data,\n \t\t})\n-\t\treturn afterAfterBodyIM, true\n+\t\treturn true\n+\t}\n+\tp.im = inBodyIM\n+\treturn false\n+}\n+\n+// Section 11.2.5.4.22.\n+func afterAfterFramesetIM(p *parser) bool {\n+\tswitch p.tok.Type {\n+\tcase CommentToken:\n+\t\tp.addChild(&Node{\n+\t\t\tType: CommentNode,\n+\t\t\tData: p.tok.Data,\n+\t\t})\n+\tcase StartTagToken:\n+\t\tswitch p.tok.Data {\n+\t\tcase \"html\":\n+\t\t\treturn inBodyIM(p)\n+\t\tcase \"noframes\":\n+\t\t\treturn inHeadIM(p)\n+\t\t}\n+\tdefault:\n+\t\t// Ignore the token.\n \t}\n-\treturn inBodyIM, false\n+\treturn true\n }\n \n // Parse returns the parse tree for the HTML from the given Reader.\n@@ -1189,9 +1472,10 @@ func Parse(r io.Reader) (*Node, error) {\n \t\t},\n \t\tscripting:  true,\n \t\tframesetOK: true,\n+\t\tim:         initialIM,\n \t}\n \t// Iterate until EOF. Any other error will cause an early return.\n-\tim, consumed := initialIM, true\n+\tconsumed := true\n \tfor {\n \t\tif consumed {\n \t\t\tif err := p.read(); err != nil {\n@@ -1201,11 +1485,11 @@ func Parse(r io.Reader) (*Node, error) {\n \t\t\t\treturn nil, err\n \t\t\t}\n \t\t}\n-\t\tim, consumed = im(p)\n+\t\tconsumed = p.im(p)\n \t}\n \t// Loop until the final token (the ErrorToken signifying EOF) is consumed.\n \tfor {\n-\t\tif im, consumed = im(p); consumed {\n+\t\tif consumed = p.im(p); consumed {\n \t\t\tbreak\n \t\t}\n \t}"}, {"sha": "4f15ae1d554c55eae9a3db4a9708939fc1759468", "filename": "libgo/go/html/parse_test.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fhtml%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fhtml%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -133,8 +133,8 @@ func TestParser(t *testing.T) {\n \t\tn int\n \t}{\n \t\t// TODO(nigeltao): Process all the test cases from all the .dat files.\n-\t\t{\"tests1.dat\", 92},\n-\t\t{\"tests2.dat\", 0},\n+\t\t{\"tests1.dat\", -1},\n+\t\t{\"tests2.dat\", 43},\n \t\t{\"tests3.dat\", 0},\n \t}\n \tfor _, tf := range testFiles {\n@@ -213,4 +213,8 @@ var renderTestBlacklist = map[string]bool{\n \t// More cases of <a> being reparented:\n \t`<a href=\"blah\">aba<table><a href=\"foo\">br<tr><td></td></tr>x</table>aoe`: true,\n \t`<a><table><a></table><p><a><div><a>`:                                     true,\n+\t`<a><table><td><a><table></table><a></tr><a></table><a>`:                  true,\n+\t// A <plaintext> element is reparented, putting it before a table.\n+\t// A <plaintext> element can't have anything after it in HTML.\n+\t`<table><plaintext><td>`: true,\n }"}, {"sha": "92c349fb32c890addd69796b02b03279641b0eff", "filename": "libgo/go/html/render.go", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fhtml%2Frender.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fhtml%2Frender.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Frender.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -52,7 +52,19 @@ func Render(w io.Writer, n *Node) error {\n \treturn buf.Flush()\n }\n \n+// plaintextAbort is returned from render1 when a <plaintext> element \n+// has been rendered. No more end tags should be rendered after that.\n+var plaintextAbort = errors.New(\"html: internal error (plaintext abort)\")\n+\n func render(w writer, n *Node) error {\n+\terr := render1(w, n)\n+\tif err == plaintextAbort {\n+\t\terr = nil\n+\t}\n+\treturn err\n+}\n+\n+func render1(w writer, n *Node) error {\n \t// Render non-element nodes; these are the easy cases.\n \tswitch n.Type {\n \tcase ErrorNode:\n@@ -61,7 +73,7 @@ func render(w writer, n *Node) error {\n \t\treturn escape(w, n.Data)\n \tcase DocumentNode:\n \t\tfor _, c := range n.Child {\n-\t\t\tif err := render(w, c); err != nil {\n+\t\t\tif err := render1(w, c); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t}\n@@ -128,7 +140,7 @@ func render(w writer, n *Node) error {\n \n \t// Render any child nodes.\n \tswitch n.Data {\n-\tcase \"noembed\", \"noframes\", \"noscript\", \"script\", \"style\":\n+\tcase \"noembed\", \"noframes\", \"noscript\", \"plaintext\", \"script\", \"style\":\n \t\tfor _, c := range n.Child {\n \t\t\tif c.Type != TextNode {\n \t\t\t\treturn fmt.Errorf(\"html: raw text element <%s> has non-text child node\", n.Data)\n@@ -137,18 +149,23 @@ func render(w writer, n *Node) error {\n \t\t\t\treturn err\n \t\t\t}\n \t\t}\n+\t\tif n.Data == \"plaintext\" {\n+\t\t\t// Don't render anything else. <plaintext> must be the\n+\t\t\t// last element in the file, with no closing tag.\n+\t\t\treturn plaintextAbort\n+\t\t}\n \tcase \"textarea\", \"title\":\n \t\tfor _, c := range n.Child {\n \t\t\tif c.Type != TextNode {\n \t\t\t\treturn fmt.Errorf(\"html: RCDATA element <%s> has non-text child node\", n.Data)\n \t\t\t}\n-\t\t\tif err := render(w, c); err != nil {\n+\t\t\tif err := render1(w, c); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t}\n \tdefault:\n \t\tfor _, c := range n.Child {\n-\t\t\tif err := render(w, c); err != nil {\n+\t\t\tif err := render1(w, c); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t}"}, {"sha": "3fb15a6e93f56e294f169a88c99da5b0dc6b7b1a", "filename": "libgo/go/html/template/content.go", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fcontent.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -6,6 +6,7 @@ package template\n \n import (\n \t\"fmt\"\n+\t\"reflect\"\n )\n \n // Strings of content from a trusted source.\n@@ -70,10 +71,25 @@ const (\n \tcontentTypeUnsafe\n )\n \n+// indirect returns the value, after dereferencing as many times\n+// as necessary to reach the base type (or nil).\n+func indirect(a interface{}) interface{} {\n+\tif t := reflect.TypeOf(a); t.Kind() != reflect.Ptr {\n+\t\t// Avoid creating a reflect.Value if it's not a pointer.\n+\t\treturn a\n+\t}\n+\tv := reflect.ValueOf(a)\n+\tfor v.Kind() == reflect.Ptr && !v.IsNil() {\n+\t\tv = v.Elem()\n+\t}\n+\treturn v.Interface()\n+}\n+\n // stringify converts its arguments to a string and the type of the content.\n+// All pointers are dereferenced, as in the text/template package.\n func stringify(args ...interface{}) (string, contentType) {\n \tif len(args) == 1 {\n-\t\tswitch s := args[0].(type) {\n+\t\tswitch s := indirect(args[0]).(type) {\n \t\tcase string:\n \t\t\treturn s, contentTypePlain\n \t\tcase CSS:\n@@ -90,5 +106,8 @@ func stringify(args ...interface{}) (string, contentType) {\n \t\t\treturn string(s), contentTypeURL\n \t\t}\n \t}\n+\tfor i, arg := range args {\n+\t\targs[i] = indirect(arg)\n+\t}\n \treturn fmt.Sprint(args...), contentTypePlain\n }"}, {"sha": "4af583097bd55fb165e69e3b0fc8af3019cc9b10", "filename": "libgo/go/html/template/escape_test.go", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -28,7 +28,7 @@ func (x *goodMarshaler) MarshalJSON() ([]byte, error) {\n }\n \n func TestEscape(t *testing.T) {\n-\tvar data = struct {\n+\tdata := struct {\n \t\tF, T    bool\n \t\tC, G, H string\n \t\tA, E    []string\n@@ -50,6 +50,7 @@ func TestEscape(t *testing.T) {\n \t\tZ: nil,\n \t\tW: HTML(`&iexcl;<b class=\"foo\">Hello</b>, <textarea>O'World</textarea>!`),\n \t}\n+\tpdata := &data\n \n \ttests := []struct {\n \t\tname   string\n@@ -668,6 +669,15 @@ func TestEscape(t *testing.T) {\n \t\t\tt.Errorf(\"%s: escaped output: want\\n\\t%q\\ngot\\n\\t%q\", test.name, w, g)\n \t\t\tcontinue\n \t\t}\n+\t\tb.Reset()\n+\t\tif err := tmpl.Execute(b, pdata); err != nil {\n+\t\t\tt.Errorf(\"%s: template execution failed for pointer: %s\", test.name, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif w, g := test.output, b.String(); w != g {\n+\t\t\tt.Errorf(\"%s: escaped output for pointer: want\\n\\t%q\\ngot\\n\\t%q\", test.name, w, g)\n+\t\t\tcontinue\n+\t\t}\n \t}\n }\n \n@@ -1605,6 +1615,29 @@ func TestRedundantFuncs(t *testing.T) {\n \t}\n }\n \n+func TestIndirectPrint(t *testing.T) {\n+\ta := 3\n+\tap := &a\n+\tb := \"hello\"\n+\tbp := &b\n+\tbpp := &bp\n+\ttmpl := Must(New(\"t\").Parse(`{{.}}`))\n+\tvar buf bytes.Buffer\n+\terr := tmpl.Execute(&buf, ap)\n+\tif err != nil {\n+\t\tt.Errorf(\"Unexpected error: %s\", err)\n+\t} else if buf.String() != \"3\" {\n+\t\tt.Errorf(`Expected \"3\"; got %q`, buf.String())\n+\t}\n+\tbuf.Reset()\n+\terr = tmpl.Execute(&buf, bpp)\n+\tif err != nil {\n+\t\tt.Errorf(\"Unexpected error: %s\", err)\n+\t} else if buf.String() != \"hello\" {\n+\t\tt.Errorf(`Expected \"hello\"; got %q`, buf.String())\n+\t}\n+}\n+\n func BenchmarkEscapedExecute(b *testing.B) {\n \ttmpl := Must(New(\"t\").Parse(`<a onclick=\"alert('{{.}}')\">{{.}}</a>`))\n \tvar buf bytes.Buffer"}, {"sha": "0e632df42201e49661f98d0671069e2b4bcb155e", "filename": "libgo/go/html/template/js.go", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fhtml%2Ftemplate%2Fjs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fhtml%2Ftemplate%2Fjs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fjs.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"bytes\"\n \t\"encoding/json\"\n \t\"fmt\"\n+\t\"reflect\"\n \t\"strings\"\n \t\"unicode/utf8\"\n )\n@@ -117,12 +118,24 @@ var regexpPrecederKeywords = map[string]bool{\n \t\"void\":       true,\n }\n \n+var jsonMarshalType = reflect.TypeOf((*json.Marshaler)(nil)).Elem()\n+\n+// indirectToJSONMarshaler returns the value, after dereferencing as many times\n+// as necessary to reach the base type (or nil) or an implementation of json.Marshal.\n+func indirectToJSONMarshaler(a interface{}) interface{} {\n+\tv := reflect.ValueOf(a)\n+\tfor !v.Type().Implements(jsonMarshalType) && v.Kind() == reflect.Ptr && !v.IsNil() {\n+\t\tv = v.Elem()\n+\t}\n+\treturn v.Interface()\n+}\n+\n // jsValEscaper escapes its inputs to a JS Expression (section 11.14) that has\n-// nether side-effects nor free variables outside (NaN, Infinity).\n+// neither side-effects nor free variables outside (NaN, Infinity).\n func jsValEscaper(args ...interface{}) string {\n \tvar a interface{}\n \tif len(args) == 1 {\n-\t\ta = args[0]\n+\t\ta = indirectToJSONMarshaler(args[0])\n \t\tswitch t := a.(type) {\n \t\tcase JS:\n \t\t\treturn string(t)\n@@ -135,6 +148,9 @@ func jsValEscaper(args ...interface{}) string {\n \t\t\ta = t.String()\n \t\t}\n \t} else {\n+\t\tfor i, arg := range args {\n+\t\t\targs[i] = indirectToJSONMarshaler(arg)\n+\t\t}\n \t\ta = fmt.Sprint(args...)\n \t}\n \t// TODO: detect cycles before calling Marshal which loops infinitely on"}, {"sha": "9400873e6b8e6b81639d8358700f63910032bda6", "filename": "libgo/go/html/token.go", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fhtml%2Ftoken.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fhtml%2Ftoken.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftoken.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -401,14 +401,14 @@ func (z *Tokenizer) readStartTag() TokenType {\n \t\t\tbreak\n \t\t}\n \t}\n-\t// Any \"<noembed>\", \"<noframes>\", \"<noscript>\", \"<script>\", \"<style>\",\n+\t// Any \"<noembed>\", \"<noframes>\", \"<noscript>\", \"<plaintext\", \"<script>\", \"<style>\",\n \t// \"<textarea>\" or \"<title>\" tag flags the tokenizer's next token as raw.\n-\t// The tag name lengths of these special cases ranges in [5, 8].\n-\tif x := z.data.end - z.data.start; 5 <= x && x <= 8 {\n+\t// The tag name lengths of these special cases ranges in [5, 9].\n+\tif x := z.data.end - z.data.start; 5 <= x && x <= 9 {\n \t\tswitch z.buf[z.data.start] {\n-\t\tcase 'n', 's', 't', 'N', 'S', 'T':\n+\t\tcase 'n', 'p', 's', 't', 'N', 'P', 'S', 'T':\n \t\t\tswitch s := strings.ToLower(string(z.buf[z.data.start:z.data.end])); s {\n-\t\t\tcase \"noembed\", \"noframes\", \"noscript\", \"script\", \"style\", \"textarea\", \"title\":\n+\t\t\tcase \"noembed\", \"noframes\", \"noscript\", \"plaintext\", \"script\", \"style\", \"textarea\", \"title\":\n \t\t\t\tz.rawTag = s\n \t\t\t}\n \t\t}\n@@ -551,9 +551,19 @@ func (z *Tokenizer) Next() TokenType {\n \tz.data.start = z.raw.end\n \tz.data.end = z.raw.end\n \tif z.rawTag != \"\" {\n-\t\tz.readRawOrRCDATA()\n-\t\tz.tt = TextToken\n-\t\treturn z.tt\n+\t\tif z.rawTag == \"plaintext\" {\n+\t\t\t// Read everything up to EOF.\n+\t\t\tfor z.err == nil {\n+\t\t\t\tz.readByte()\n+\t\t\t}\n+\t\t\tz.textIsRaw = true\n+\t\t} else {\n+\t\t\tz.readRawOrRCDATA()\n+\t\t}\n+\t\tif z.data.end > z.data.start {\n+\t\t\tz.tt = TextToken\n+\t\t\treturn z.tt\n+\t\t}\n \t}\n \tz.textIsRaw = false\n "}, {"sha": "27533c6047d5579eab29e4aad71db5dc558c0d08", "filename": "libgo/go/image/tiff/buffer.go", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fimage%2Ftiff%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fimage%2Ftiff%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Ftiff%2Fbuffer.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -4,10 +4,7 @@\n \n package tiff\n \n-import (\n-\t\"io\"\n-\t\"os\"\n-)\n+import \"io\"\n \n // buffer buffers an io.Reader to satisfy io.ReaderAt.\n type buffer struct {\n@@ -19,7 +16,7 @@ func (b *buffer) ReadAt(p []byte, off int64) (int, error) {\n \to := int(off)\n \tend := o + len(p)\n \tif int64(end) != off+int64(len(p)) {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, io.ErrUnexpectedEOF\n \t}\n \n \tm := len(b.buf)"}, {"sha": "71028e226773a40cd393f46b56fdd1aad2851c42", "filename": "libgo/go/io/ioutil/tempfile.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"os\"\n \t\"path/filepath\"\n \t\"strconv\"\n+\t\"time\"\n )\n \n // Random number state, accessed without lock; racy but harmless.\n@@ -17,8 +18,7 @@ import (\n var rand uint32\n \n func reseed() uint32 {\n-\tsec, nsec, _ := os.Time()\n-\treturn uint32(sec*1e9 + nsec + int64(os.Getpid()))\n+\treturn uint32(time.Nanoseconds() + int64(os.Getpid()))\n }\n \n func nextSuffix() string {"}, {"sha": "546bc296a5ffd9d4f4526f133dce0fec944b9f9e", "filename": "libgo/go/log/syslog/syslog.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -8,6 +8,7 @@\n package syslog\n \n import (\n+\t\"errors\"\n \t\"fmt\"\n \t\"log\"\n \t\"net\"\n@@ -75,7 +76,7 @@ func Dial(network, raddr string, priority Priority, prefix string) (w *Writer, e\n // Write sends a log message to the syslog daemon.\n func (w *Writer) Write(b []byte) (int, error) {\n \tif w.priority > LOG_DEBUG || w.priority < LOG_EMERG {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, errors.New(\"log/syslog: invalid priority\")\n \t}\n \treturn w.conn.writeBytes(w.priority, w.prefix, b)\n }"}, {"sha": "35e2e2941832294032ef563298b87ad31b45454f", "filename": "libgo/go/math/big/int.go", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmath%2Fbig%2Fint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmath%2Fbig%2Fint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fint.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -176,7 +176,7 @@ func (z *Int) Quo(x, y *Int) *Int {\n // If y == 0, a division-by-zero run-time panic occurs.\n // Rem implements truncated modulus (like Go); see QuoRem for more details.\n func (z *Int) Rem(x, y *Int) *Int {\n-\t_, z.abs = nat{}.div(z.abs, x.abs, y.abs)\n+\t_, z.abs = nat(nil).div(z.abs, x.abs, y.abs)\n \tz.neg = len(z.abs) > 0 && x.neg // 0 has no sign\n \treturn z\n }\n@@ -678,14 +678,14 @@ func (z *Int) Bit(i int) uint {\n \t\tpanic(\"negative bit index\")\n \t}\n \tif z.neg {\n-\t\tt := nat{}.sub(z.abs, natOne)\n+\t\tt := nat(nil).sub(z.abs, natOne)\n \t\treturn t.bit(uint(i)) ^ 1\n \t}\n \n \treturn z.abs.bit(uint(i))\n }\n \n-// SetBit sets the i'th bit of z to bit and returns z.\n+// SetBit sets z to x, with x's i'th bit set to b (0 or 1).\n // That is, if bit is 1 SetBit sets z = x | (1 << i);\n // if bit is 0 it sets z = x &^ (1 << i). If bit is not 0 or 1,\n // SetBit will panic.\n@@ -710,8 +710,8 @@ func (z *Int) And(x, y *Int) *Int {\n \tif x.neg == y.neg {\n \t\tif x.neg {\n \t\t\t// (-x) & (-y) == ^(x-1) & ^(y-1) == ^((x-1) | (y-1)) == -(((x-1) | (y-1)) + 1)\n-\t\t\tx1 := nat{}.sub(x.abs, natOne)\n-\t\t\ty1 := nat{}.sub(y.abs, natOne)\n+\t\t\tx1 := nat(nil).sub(x.abs, natOne)\n+\t\t\ty1 := nat(nil).sub(y.abs, natOne)\n \t\t\tz.abs = z.abs.add(z.abs.or(x1, y1), natOne)\n \t\t\tz.neg = true // z cannot be zero if x and y are negative\n \t\t\treturn z\n@@ -729,7 +729,7 @@ func (z *Int) And(x, y *Int) *Int {\n \t}\n \n \t// x & (-y) == x & ^(y-1) == x &^ (y-1)\n-\ty1 := nat{}.sub(y.abs, natOne)\n+\ty1 := nat(nil).sub(y.abs, natOne)\n \tz.abs = z.abs.andNot(x.abs, y1)\n \tz.neg = false\n \treturn z\n@@ -740,8 +740,8 @@ func (z *Int) AndNot(x, y *Int) *Int {\n \tif x.neg == y.neg {\n \t\tif x.neg {\n \t\t\t// (-x) &^ (-y) == ^(x-1) &^ ^(y-1) == ^(x-1) & (y-1) == (y-1) &^ (x-1)\n-\t\t\tx1 := nat{}.sub(x.abs, natOne)\n-\t\t\ty1 := nat{}.sub(y.abs, natOne)\n+\t\t\tx1 := nat(nil).sub(x.abs, natOne)\n+\t\t\ty1 := nat(nil).sub(y.abs, natOne)\n \t\t\tz.abs = z.abs.andNot(y1, x1)\n \t\t\tz.neg = false\n \t\t\treturn z\n@@ -755,14 +755,14 @@ func (z *Int) AndNot(x, y *Int) *Int {\n \n \tif x.neg {\n \t\t// (-x) &^ y == ^(x-1) &^ y == ^(x-1) & ^y == ^((x-1) | y) == -(((x-1) | y) + 1)\n-\t\tx1 := nat{}.sub(x.abs, natOne)\n+\t\tx1 := nat(nil).sub(x.abs, natOne)\n \t\tz.abs = z.abs.add(z.abs.or(x1, y.abs), natOne)\n \t\tz.neg = true // z cannot be zero if x is negative and y is positive\n \t\treturn z\n \t}\n \n \t// x &^ (-y) == x &^ ^(y-1) == x & (y-1)\n-\ty1 := nat{}.add(y.abs, natOne)\n+\ty1 := nat(nil).add(y.abs, natOne)\n \tz.abs = z.abs.and(x.abs, y1)\n \tz.neg = false\n \treturn z\n@@ -773,8 +773,8 @@ func (z *Int) Or(x, y *Int) *Int {\n \tif x.neg == y.neg {\n \t\tif x.neg {\n \t\t\t// (-x) | (-y) == ^(x-1) | ^(y-1) == ^((x-1) & (y-1)) == -(((x-1) & (y-1)) + 1)\n-\t\t\tx1 := nat{}.sub(x.abs, natOne)\n-\t\t\ty1 := nat{}.sub(y.abs, natOne)\n+\t\t\tx1 := nat(nil).sub(x.abs, natOne)\n+\t\t\ty1 := nat(nil).sub(y.abs, natOne)\n \t\t\tz.abs = z.abs.add(z.abs.and(x1, y1), natOne)\n \t\t\tz.neg = true // z cannot be zero if x and y are negative\n \t\t\treturn z\n@@ -792,7 +792,7 @@ func (z *Int) Or(x, y *Int) *Int {\n \t}\n \n \t// x | (-y) == x | ^(y-1) == ^((y-1) &^ x) == -(^((y-1) &^ x) + 1)\n-\ty1 := nat{}.sub(y.abs, natOne)\n+\ty1 := nat(nil).sub(y.abs, natOne)\n \tz.abs = z.abs.add(z.abs.andNot(y1, x.abs), natOne)\n \tz.neg = true // z cannot be zero if one of x or y is negative\n \treturn z\n@@ -803,8 +803,8 @@ func (z *Int) Xor(x, y *Int) *Int {\n \tif x.neg == y.neg {\n \t\tif x.neg {\n \t\t\t// (-x) ^ (-y) == ^(x-1) ^ ^(y-1) == (x-1) ^ (y-1)\n-\t\t\tx1 := nat{}.sub(x.abs, natOne)\n-\t\t\ty1 := nat{}.sub(y.abs, natOne)\n+\t\t\tx1 := nat(nil).sub(x.abs, natOne)\n+\t\t\ty1 := nat(nil).sub(y.abs, natOne)\n \t\t\tz.abs = z.abs.xor(x1, y1)\n \t\t\tz.neg = false\n \t\t\treturn z\n@@ -822,7 +822,7 @@ func (z *Int) Xor(x, y *Int) *Int {\n \t}\n \n \t// x ^ (-y) == x ^ ^(y-1) == ^(x ^ (y-1)) == -((x ^ (y-1)) + 1)\n-\ty1 := nat{}.sub(y.abs, natOne)\n+\ty1 := nat(nil).sub(y.abs, natOne)\n \tz.abs = z.abs.add(z.abs.xor(x.abs, y1), natOne)\n \tz.neg = true // z cannot be zero if only one of x or y is negative\n \treturn z"}, {"sha": "eee8ee3f66cc6dadf4f0c1998aa0cb54ed601d0c", "filename": "libgo/go/math/big/nat.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -447,10 +447,10 @@ func (z nat) mulRange(a, b uint64) nat {\n \tcase a == b:\n \t\treturn z.setUint64(a)\n \tcase a+1 == b:\n-\t\treturn z.mul(nat{}.setUint64(a), nat{}.setUint64(b))\n+\t\treturn z.mul(nat(nil).setUint64(a), nat(nil).setUint64(b))\n \t}\n \tm := (a + b) / 2\n-\treturn z.mul(nat{}.mulRange(a, m), nat{}.mulRange(m+1, b))\n+\treturn z.mul(nat(nil).mulRange(a, m), nat(nil).mulRange(m+1, b))\n }\n \n // q = (x-r)/y, with 0 <= r < y\n@@ -785,7 +785,7 @@ func (x nat) string(charset string) string {\n \t}\n \n \t// preserve x, create local copy for use in repeated divisions\n-\tq := nat{}.set(x)\n+\tq := nat(nil).set(x)\n \tvar r Word\n \n \t// convert\n@@ -1191,11 +1191,11 @@ func (n nat) probablyPrime(reps int) bool {\n \t\treturn false\n \t}\n \n-\tnm1 := nat{}.sub(n, natOne)\n+\tnm1 := nat(nil).sub(n, natOne)\n \t// 1<<k * q = nm1;\n \tq, k := nm1.powersOfTwoDecompose()\n \n-\tnm3 := nat{}.sub(nm1, natTwo)\n+\tnm3 := nat(nil).sub(nm1, natTwo)\n \trand := rand.New(rand.NewSource(int64(n[0])))\n \n \tvar x, y, quotient nat"}, {"sha": "b208646f2f2839c08dc47aae6817a02fffe85988", "filename": "libgo/go/math/big/nat_test.go", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -16,9 +16,9 @@ var cmpTests = []struct {\n \tr    int\n }{\n \t{nil, nil, 0},\n-\t{nil, nat{}, 0},\n-\t{nat{}, nil, 0},\n-\t{nat{}, nat{}, 0},\n+\t{nil, nat(nil), 0},\n+\t{nat(nil), nil, 0},\n+\t{nat(nil), nat(nil), 0},\n \t{nat{0}, nat{0}, 0},\n \t{nat{0}, nat{1}, -1},\n \t{nat{1}, nat{0}, 1},\n@@ -67,7 +67,7 @@ var prodNN = []argNN{\n \n func TestSet(t *testing.T) {\n \tfor _, a := range sumNN {\n-\t\tz := nat{}.set(a.z)\n+\t\tz := nat(nil).set(a.z)\n \t\tif z.cmp(a.z) != 0 {\n \t\t\tt.Errorf(\"got z = %v; want %v\", z, a.z)\n \t\t}\n@@ -129,7 +129,7 @@ var mulRangesN = []struct {\n \n func TestMulRangeN(t *testing.T) {\n \tfor i, r := range mulRangesN {\n-\t\tprod := nat{}.mulRange(r.a, r.b).decimalString()\n+\t\tprod := nat(nil).mulRange(r.a, r.b).decimalString()\n \t\tif prod != r.prod {\n \t\t\tt.Errorf(\"#%d: got %s; want %s\", i, prod, r.prod)\n \t\t}\n@@ -175,7 +175,7 @@ func toString(x nat, charset string) string {\n \ts := make([]byte, i)\n \n \t// don't destroy x\n-\tq := nat{}.set(x)\n+\tq := nat(nil).set(x)\n \n \t// convert\n \tfor len(q) > 0 {\n@@ -212,7 +212,7 @@ func TestString(t *testing.T) {\n \t\t\tt.Errorf(\"string%+v\\n\\tgot s = %s; want %s\", a, s, a.s)\n \t\t}\n \n-\t\tx, b, err := nat{}.scan(strings.NewReader(a.s), len(a.c))\n+\t\tx, b, err := nat(nil).scan(strings.NewReader(a.s), len(a.c))\n \t\tif x.cmp(a.x) != 0 {\n \t\t\tt.Errorf(\"scan%+v\\n\\tgot z = %v; want %v\", a, x, a.x)\n \t\t}\n@@ -271,7 +271,7 @@ var natScanTests = []struct {\n func TestScanBase(t *testing.T) {\n \tfor _, a := range natScanTests {\n \t\tr := strings.NewReader(a.s)\n-\t\tx, b, err := nat{}.scan(r, a.base)\n+\t\tx, b, err := nat(nil).scan(r, a.base)\n \t\tif err == nil && !a.ok {\n \t\t\tt.Errorf(\"scan%+v\\n\\texpected error\", a)\n \t\t}\n@@ -651,17 +651,17 @@ var expNNTests = []struct {\n \n func TestExpNN(t *testing.T) {\n \tfor i, test := range expNNTests {\n-\t\tx, _, _ := nat{}.scan(strings.NewReader(test.x), 0)\n-\t\ty, _, _ := nat{}.scan(strings.NewReader(test.y), 0)\n-\t\tout, _, _ := nat{}.scan(strings.NewReader(test.out), 0)\n+\t\tx, _, _ := nat(nil).scan(strings.NewReader(test.x), 0)\n+\t\ty, _, _ := nat(nil).scan(strings.NewReader(test.y), 0)\n+\t\tout, _, _ := nat(nil).scan(strings.NewReader(test.out), 0)\n \n \t\tvar m nat\n \n \t\tif len(test.m) > 0 {\n-\t\t\tm, _, _ = nat{}.scan(strings.NewReader(test.m), 0)\n+\t\t\tm, _, _ = nat(nil).scan(strings.NewReader(test.m), 0)\n \t\t}\n \n-\t\tz := nat{}.expNN(x, y, m)\n+\t\tz := nat(nil).expNN(x, y, m)\n \t\tif z.cmp(out) != 0 {\n \t\t\tt.Errorf(\"#%d got %v want %v\", i, z, out)\n \t\t}"}, {"sha": "adf412485f69e923575fc83d534dd10be9984828", "filename": "libgo/go/math/big/rat.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmath%2Fbig%2Frat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmath%2Fbig%2Frat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Frat.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -33,7 +33,7 @@ func (z *Rat) SetFrac(a, b *Int) *Rat {\n \t\tpanic(\"division by zero\")\n \t}\n \tif &z.a == b || alias(z.a.abs, babs) {\n-\t\tbabs = nat{}.set(babs) // make a copy\n+\t\tbabs = nat(nil).set(babs) // make a copy\n \t}\n \tz.a.abs = z.a.abs.set(a.abs)\n \tz.b = z.b.set(babs)\n@@ -315,7 +315,7 @@ func (z *Rat) SetString(s string) (*Rat, bool) {\n \tif _, ok := z.a.SetString(s, 10); !ok {\n \t\treturn nil, false\n \t}\n-\tpowTen := nat{}.expNN(natTen, exp.abs, nil)\n+\tpowTen := nat(nil).expNN(natTen, exp.abs, nil)\n \tif exp.neg {\n \t\tz.b = powTen\n \t\tz.norm()\n@@ -357,23 +357,23 @@ func (z *Rat) FloatString(prec int) string {\n \t}\n \t// z.b != 0\n \n-\tq, r := nat{}.div(nat{}, z.a.abs, z.b)\n+\tq, r := nat(nil).div(nat(nil), z.a.abs, z.b)\n \n \tp := natOne\n \tif prec > 0 {\n-\t\tp = nat{}.expNN(natTen, nat{}.setUint64(uint64(prec)), nil)\n+\t\tp = nat(nil).expNN(natTen, nat(nil).setUint64(uint64(prec)), nil)\n \t}\n \n \tr = r.mul(r, p)\n-\tr, r2 := r.div(nat{}, r, z.b)\n+\tr, r2 := r.div(nat(nil), r, z.b)\n \n \t// see if we need to round up\n \tr2 = r2.add(r2, r2)\n \tif z.b.cmp(r2) <= 0 {\n \t\tr = r.add(r, natOne)\n \t\tif r.cmp(p) >= 0 {\n-\t\t\tq = nat{}.add(q, natOne)\n-\t\t\tr = nat{}.sub(r, p)\n+\t\t\tq = nat(nil).add(q, natOne)\n+\t\t\tr = nat(nil).sub(r, p)\n \t\t}\n \t}\n "}, {"sha": "ae2c0c418ab7b04cb3a03adfa7c2e4cae200eb07", "filename": "libgo/go/math/gamma.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmath%2Fgamma.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmath%2Fgamma.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fgamma.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -63,7 +63,7 @@ package math\n //   Stephen L. Moshier\n //   moshier@na-net.ornl.gov\n \n-var _P = [...]float64{\n+var _gamP = [...]float64{\n \t1.60119522476751861407e-04,\n \t1.19135147006586384913e-03,\n \t1.04213797561761569935e-02,\n@@ -72,7 +72,7 @@ var _P = [...]float64{\n \t4.94214826801497100753e-01,\n \t9.99999999999999996796e-01,\n }\n-var _Q = [...]float64{\n+var _gamQ = [...]float64{\n \t-2.31581873324120129819e-05,\n \t5.39605580493303397842e-04,\n \t-4.45641913851797240494e-03,\n@@ -82,7 +82,7 @@ var _Q = [...]float64{\n \t7.14304917030273074085e-02,\n \t1.00000000000000000320e+00,\n }\n-var _S = [...]float64{\n+var _gamS = [...]float64{\n \t7.87311395793093628397e-04,\n \t-2.29549961613378126380e-04,\n \t-2.68132617805781232825e-03,\n@@ -98,7 +98,7 @@ func stirling(x float64) float64 {\n \t\tMaxStirling = 143.01608\n \t)\n \tw := 1 / x\n-\tw = 1 + w*((((_S[0]*w+_S[1])*w+_S[2])*w+_S[3])*w+_S[4])\n+\tw = 1 + w*((((_gamS[0]*w+_gamS[1])*w+_gamS[2])*w+_gamS[3])*w+_gamS[4])\n \ty := Exp(x)\n \tif x > MaxStirling { // avoid Pow() overflow\n \t\tv := Pow(x, 0.5*x-0.25)\n@@ -176,8 +176,8 @@ func Gamma(x float64) float64 {\n \t}\n \n \tx = x - 2\n-\tp = (((((x*_P[0]+_P[1])*x+_P[2])*x+_P[3])*x+_P[4])*x+_P[5])*x + _P[6]\n-\tq = ((((((x*_Q[0]+_Q[1])*x+_Q[2])*x+_Q[3])*x+_Q[4])*x+_Q[5])*x+_Q[6])*x + _Q[7]\n+\tp = (((((x*_gamP[0]+_gamP[1])*x+_gamP[2])*x+_gamP[3])*x+_gamP[4])*x+_gamP[5])*x + _gamP[6]\n+\tq = ((((((x*_gamQ[0]+_gamQ[1])*x+_gamQ[2])*x+_gamQ[3])*x+_gamQ[4])*x+_gamQ[5])*x+_gamQ[6])*x + _gamQ[7]\n \treturn z * p / q\n \n small:"}, {"sha": "e2bad69dc03d0f8d9fa2245419122f3121f37846", "filename": "libgo/go/math/lgamma.go", "status": "modified", "additions": 86, "deletions": 69, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmath%2Flgamma.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmath%2Flgamma.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Flgamma.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -88,6 +88,81 @@ package math\n //\n //\n \n+var _lgamA = [...]float64{\n+\t7.72156649015328655494e-02, // 0x3FB3C467E37DB0C8\n+\t3.22467033424113591611e-01, // 0x3FD4A34CC4A60FAD\n+\t6.73523010531292681824e-02, // 0x3FB13E001A5562A7\n+\t2.05808084325167332806e-02, // 0x3F951322AC92547B\n+\t7.38555086081402883957e-03, // 0x3F7E404FB68FEFE8\n+\t2.89051383673415629091e-03, // 0x3F67ADD8CCB7926B\n+\t1.19270763183362067845e-03, // 0x3F538A94116F3F5D\n+\t5.10069792153511336608e-04, // 0x3F40B6C689B99C00\n+\t2.20862790713908385557e-04, // 0x3F2CF2ECED10E54D\n+\t1.08011567247583939954e-04, // 0x3F1C5088987DFB07\n+\t2.52144565451257326939e-05, // 0x3EFA7074428CFA52\n+\t4.48640949618915160150e-05, // 0x3F07858E90A45837\n+}\n+var _lgamR = [...]float64{\n+\t1.0, // placeholder\n+\t1.39200533467621045958e+00, // 0x3FF645A762C4AB74\n+\t7.21935547567138069525e-01, // 0x3FE71A1893D3DCDC\n+\t1.71933865632803078993e-01, // 0x3FC601EDCCFBDF27\n+\t1.86459191715652901344e-02, // 0x3F9317EA742ED475\n+\t7.77942496381893596434e-04, // 0x3F497DDACA41A95B\n+\t7.32668430744625636189e-06, // 0x3EDEBAF7A5B38140\n+}\n+var _lgamS = [...]float64{\n+\t-7.72156649015328655494e-02, // 0xBFB3C467E37DB0C8\n+\t2.14982415960608852501e-01,  // 0x3FCB848B36E20878\n+\t3.25778796408930981787e-01,  // 0x3FD4D98F4F139F59\n+\t1.46350472652464452805e-01,  // 0x3FC2BB9CBEE5F2F7\n+\t2.66422703033638609560e-02,  // 0x3F9B481C7E939961\n+\t1.84028451407337715652e-03,  // 0x3F5E26B67368F239\n+\t3.19475326584100867617e-05,  // 0x3F00BFECDD17E945\n+}\n+var _lgamT = [...]float64{\n+\t4.83836122723810047042e-01,  // 0x3FDEF72BC8EE38A2\n+\t-1.47587722994593911752e-01, // 0xBFC2E4278DC6C509\n+\t6.46249402391333854778e-02,  // 0x3FB08B4294D5419B\n+\t-3.27885410759859649565e-02, // 0xBFA0C9A8DF35B713\n+\t1.79706750811820387126e-02,  // 0x3F9266E7970AF9EC\n+\t-1.03142241298341437450e-02, // 0xBF851F9FBA91EC6A\n+\t6.10053870246291332635e-03,  // 0x3F78FCE0E370E344\n+\t-3.68452016781138256760e-03, // 0xBF6E2EFFB3E914D7\n+\t2.25964780900612472250e-03,  // 0x3F6282D32E15C915\n+\t-1.40346469989232843813e-03, // 0xBF56FE8EBF2D1AF1\n+\t8.81081882437654011382e-04,  // 0x3F4CDF0CEF61A8E9\n+\t-5.38595305356740546715e-04, // 0xBF41A6109C73E0EC\n+\t3.15632070903625950361e-04,  // 0x3F34AF6D6C0EBBF7\n+\t-3.12754168375120860518e-04, // 0xBF347F24ECC38C38\n+\t3.35529192635519073543e-04,  // 0x3F35FD3EE8C2D3F4\n+}\n+var _lgamU = [...]float64{\n+\t-7.72156649015328655494e-02, // 0xBFB3C467E37DB0C8\n+\t6.32827064025093366517e-01,  // 0x3FE4401E8B005DFF\n+\t1.45492250137234768737e+00,  // 0x3FF7475CD119BD6F\n+\t9.77717527963372745603e-01,  // 0x3FEF497644EA8450\n+\t2.28963728064692451092e-01,  // 0x3FCD4EAEF6010924\n+\t1.33810918536787660377e-02,  // 0x3F8B678BBF2BAB09\n+}\n+var _lgamV = [...]float64{\n+\t1.0,\n+\t2.45597793713041134822e+00, // 0x4003A5D7C2BD619C\n+\t2.12848976379893395361e+00, // 0x40010725A42B18F5\n+\t7.69285150456672783825e-01, // 0x3FE89DFBE45050AF\n+\t1.04222645593369134254e-01, // 0x3FBAAE55D6537C88\n+\t3.21709242282423911810e-03, // 0x3F6A5ABB57D0CF61\n+}\n+var _lgamW = [...]float64{\n+\t4.18938533204672725052e-01,  // 0x3FDACFE390C97D69\n+\t8.33333333333329678849e-02,  // 0x3FB555555555553B\n+\t-2.77777777728775536470e-03, // 0xBF66C16C16B02E5C\n+\t7.93650558643019558500e-04,  // 0x3F4A019F98CF38B6\n+\t-5.95187557450339963135e-04, // 0xBF4380CB8C0FE741\n+\t8.36339918996282139126e-04,  // 0x3F4B67BA4CDAD5D1\n+\t-1.63092934096575273989e-03, // 0xBF5AB89D0B9E43E4\n+}\n+\n // Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).\n //\n // Special cases are:\n@@ -103,68 +178,10 @@ func Lgamma(x float64) (lgamma float64, sign int) {\n \t\tTwo53 = 1 << 53                     // 0x4340000000000000 ~9.0072e+15\n \t\tTwo58 = 1 << 58                     // 0x4390000000000000 ~2.8823e+17\n \t\tTiny  = 1.0 / (1 << 70)             // 0x3b90000000000000 ~8.47033e-22\n-\t\tA0    = 7.72156649015328655494e-02  // 0x3FB3C467E37DB0C8\n-\t\tA1    = 3.22467033424113591611e-01  // 0x3FD4A34CC4A60FAD\n-\t\tA2    = 6.73523010531292681824e-02  // 0x3FB13E001A5562A7\n-\t\tA3    = 2.05808084325167332806e-02  // 0x3F951322AC92547B\n-\t\tA4    = 7.38555086081402883957e-03  // 0x3F7E404FB68FEFE8\n-\t\tA5    = 2.89051383673415629091e-03  // 0x3F67ADD8CCB7926B\n-\t\tA6    = 1.19270763183362067845e-03  // 0x3F538A94116F3F5D\n-\t\tA7    = 5.10069792153511336608e-04  // 0x3F40B6C689B99C00\n-\t\tA8    = 2.20862790713908385557e-04  // 0x3F2CF2ECED10E54D\n-\t\tA9    = 1.08011567247583939954e-04  // 0x3F1C5088987DFB07\n-\t\tA10   = 2.52144565451257326939e-05  // 0x3EFA7074428CFA52\n-\t\tA11   = 4.48640949618915160150e-05  // 0x3F07858E90A45837\n \t\tTc    = 1.46163214496836224576e+00  // 0x3FF762D86356BE3F\n \t\tTf    = -1.21486290535849611461e-01 // 0xBFBF19B9BCC38A42\n \t\t// Tt = -(tail of Tf)\n-\t\tTt  = -3.63867699703950536541e-18 // 0xBC50C7CAA48A971F\n-\t\tT0  = 4.83836122723810047042e-01  // 0x3FDEF72BC8EE38A2\n-\t\tT1  = -1.47587722994593911752e-01 // 0xBFC2E4278DC6C509\n-\t\tT2  = 6.46249402391333854778e-02  // 0x3FB08B4294D5419B\n-\t\tT3  = -3.27885410759859649565e-02 // 0xBFA0C9A8DF35B713\n-\t\tT4  = 1.79706750811820387126e-02  // 0x3F9266E7970AF9EC\n-\t\tT5  = -1.03142241298341437450e-02 // 0xBF851F9FBA91EC6A\n-\t\tT6  = 6.10053870246291332635e-03  // 0x3F78FCE0E370E344\n-\t\tT7  = -3.68452016781138256760e-03 // 0xBF6E2EFFB3E914D7\n-\t\tT8  = 2.25964780900612472250e-03  // 0x3F6282D32E15C915\n-\t\tT9  = -1.40346469989232843813e-03 // 0xBF56FE8EBF2D1AF1\n-\t\tT10 = 8.81081882437654011382e-04  // 0x3F4CDF0CEF61A8E9\n-\t\tT11 = -5.38595305356740546715e-04 // 0xBF41A6109C73E0EC\n-\t\tT12 = 3.15632070903625950361e-04  // 0x3F34AF6D6C0EBBF7\n-\t\tT13 = -3.12754168375120860518e-04 // 0xBF347F24ECC38C38\n-\t\tT14 = 3.35529192635519073543e-04  // 0x3F35FD3EE8C2D3F4\n-\t\tU0  = -7.72156649015328655494e-02 // 0xBFB3C467E37DB0C8\n-\t\tU1  = 6.32827064025093366517e-01  // 0x3FE4401E8B005DFF\n-\t\tU2  = 1.45492250137234768737e+00  // 0x3FF7475CD119BD6F\n-\t\tU3  = 9.77717527963372745603e-01  // 0x3FEF497644EA8450\n-\t\tU4  = 2.28963728064692451092e-01  // 0x3FCD4EAEF6010924\n-\t\tU5  = 1.33810918536787660377e-02  // 0x3F8B678BBF2BAB09\n-\t\tV1  = 2.45597793713041134822e+00  // 0x4003A5D7C2BD619C\n-\t\tV2  = 2.12848976379893395361e+00  // 0x40010725A42B18F5\n-\t\tV3  = 7.69285150456672783825e-01  // 0x3FE89DFBE45050AF\n-\t\tV4  = 1.04222645593369134254e-01  // 0x3FBAAE55D6537C88\n-\t\tV5  = 3.21709242282423911810e-03  // 0x3F6A5ABB57D0CF61\n-\t\tS0  = -7.72156649015328655494e-02 // 0xBFB3C467E37DB0C8\n-\t\tS1  = 2.14982415960608852501e-01  // 0x3FCB848B36E20878\n-\t\tS2  = 3.25778796408930981787e-01  // 0x3FD4D98F4F139F59\n-\t\tS3  = 1.46350472652464452805e-01  // 0x3FC2BB9CBEE5F2F7\n-\t\tS4  = 2.66422703033638609560e-02  // 0x3F9B481C7E939961\n-\t\tS5  = 1.84028451407337715652e-03  // 0x3F5E26B67368F239\n-\t\tS6  = 3.19475326584100867617e-05  // 0x3F00BFECDD17E945\n-\t\tR1  = 1.39200533467621045958e+00  // 0x3FF645A762C4AB74\n-\t\tR2  = 7.21935547567138069525e-01  // 0x3FE71A1893D3DCDC\n-\t\tR3  = 1.71933865632803078993e-01  // 0x3FC601EDCCFBDF27\n-\t\tR4  = 1.86459191715652901344e-02  // 0x3F9317EA742ED475\n-\t\tR5  = 7.77942496381893596434e-04  // 0x3F497DDACA41A95B\n-\t\tR6  = 7.32668430744625636189e-06  // 0x3EDEBAF7A5B38140\n-\t\tW0  = 4.18938533204672725052e-01  // 0x3FDACFE390C97D69\n-\t\tW1  = 8.33333333333329678849e-02  // 0x3FB555555555553B\n-\t\tW2  = -2.77777777728775536470e-03 // 0xBF66C16C16B02E5C\n-\t\tW3  = 7.93650558643019558500e-04  // 0x3F4A019F98CF38B6\n-\t\tW4  = -5.95187557450339963135e-04 // 0xBF4380CB8C0FE741\n-\t\tW5  = 8.36339918996282139126e-04  // 0x3F4B67BA4CDAD5D1\n-\t\tW6  = -1.63092934096575273989e-03 // 0xBF5AB89D0B9E43E4\n+\t\tTt = -3.63867699703950536541e-18 // 0xBC50C7CAA48A971F\n \t)\n \t// TODO(rsc): Remove manual inlining of IsNaN, IsInf\n \t// when compiler does it for us\n@@ -249,28 +266,28 @@ func Lgamma(x float64) (lgamma float64, sign int) {\n \t\tswitch i {\n \t\tcase 0:\n \t\t\tz := y * y\n-\t\t\tp1 := A0 + z*(A2+z*(A4+z*(A6+z*(A8+z*A10))))\n-\t\t\tp2 := z * (A1 + z*(A3+z*(A5+z*(A7+z*(A9+z*A11)))))\n+\t\t\tp1 := _lgamA[0] + z*(_lgamA[2]+z*(_lgamA[4]+z*(_lgamA[6]+z*(_lgamA[8]+z*_lgamA[10]))))\n+\t\t\tp2 := z * (_lgamA[1] + z*(+_lgamA[3]+z*(_lgamA[5]+z*(_lgamA[7]+z*(_lgamA[9]+z*_lgamA[11])))))\n \t\t\tp := y*p1 + p2\n \t\t\tlgamma += (p - 0.5*y)\n \t\tcase 1:\n \t\t\tz := y * y\n \t\t\tw := z * y\n-\t\t\tp1 := T0 + w*(T3+w*(T6+w*(T9+w*T12))) // parallel comp\n-\t\t\tp2 := T1 + w*(T4+w*(T7+w*(T10+w*T13)))\n-\t\t\tp3 := T2 + w*(T5+w*(T8+w*(T11+w*T14)))\n+\t\t\tp1 := _lgamT[0] + w*(_lgamT[3]+w*(_lgamT[6]+w*(_lgamT[9]+w*_lgamT[12]))) // parallel comp\n+\t\t\tp2 := _lgamT[1] + w*(_lgamT[4]+w*(_lgamT[7]+w*(_lgamT[10]+w*_lgamT[13])))\n+\t\t\tp3 := _lgamT[2] + w*(_lgamT[5]+w*(_lgamT[8]+w*(_lgamT[11]+w*_lgamT[14])))\n \t\t\tp := z*p1 - (Tt - w*(p2+y*p3))\n \t\t\tlgamma += (Tf + p)\n \t\tcase 2:\n-\t\t\tp1 := y * (U0 + y*(U1+y*(U2+y*(U3+y*(U4+y*U5)))))\n-\t\t\tp2 := 1 + y*(V1+y*(V2+y*(V3+y*(V4+y*V5))))\n+\t\t\tp1 := y * (_lgamU[0] + y*(_lgamU[1]+y*(_lgamU[2]+y*(_lgamU[3]+y*(_lgamU[4]+y*_lgamU[5])))))\n+\t\t\tp2 := 1 + y*(_lgamV[1]+y*(_lgamV[2]+y*(_lgamV[3]+y*(_lgamV[4]+y*_lgamV[5]))))\n \t\t\tlgamma += (-0.5*y + p1/p2)\n \t\t}\n \tcase x < 8: // 2 <= x < 8\n \t\ti := int(x)\n \t\ty := x - float64(i)\n-\t\tp := y * (S0 + y*(S1+y*(S2+y*(S3+y*(S4+y*(S5+y*S6))))))\n-\t\tq := 1 + y*(R1+y*(R2+y*(R3+y*(R4+y*(R5+y*R6)))))\n+\t\tp := y * (_lgamS[0] + y*(_lgamS[1]+y*(_lgamS[2]+y*(_lgamS[3]+y*(_lgamS[4]+y*(_lgamS[5]+y*_lgamS[6]))))))\n+\t\tq := 1 + y*(_lgamR[1]+y*(_lgamR[2]+y*(_lgamR[3]+y*(_lgamR[4]+y*(_lgamR[5]+y*_lgamR[6])))))\n \t\tlgamma = 0.5*y + p/q\n \t\tz := 1.0 // Lgamma(1+s) = Log(s) + Lgamma(s)\n \t\tswitch i {\n@@ -294,7 +311,7 @@ func Lgamma(x float64) (lgamma float64, sign int) {\n \t\tt := Log(x)\n \t\tz := 1 / x\n \t\ty := z * z\n-\t\tw := W0 + z*(W1+y*(W2+y*(W3+y*(W4+y*(W5+y*W6)))))\n+\t\tw := _lgamW[0] + z*(_lgamW[1]+y*(_lgamW[2]+y*(_lgamW[3]+y*(_lgamW[4]+y*(_lgamW[5]+y*_lgamW[6])))))\n \t\tlgamma = (x-0.5)*(t-1) + w\n \tdefault: // 2**58 <= x <= Inf\n \t\tlgamma = x * (Log(x) - 1)"}, {"sha": "ec643c1476fd930230cabb351e6b57d6f13c0da3", "filename": "libgo/go/mime/multipart/formdata.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmime%2Fmultipart%2Fformdata.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmime%2Fmultipart%2Fformdata.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmultipart%2Fformdata.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -160,7 +160,7 @@ type sliceReaderAt []byte\n \n func (r sliceReaderAt) ReadAt(b []byte, off int64) (int, error) {\n \tif int(off) >= len(r) || off < 0 {\n-\t\treturn 0, os.EINVAL\n+\t\treturn 0, io.ErrUnexpectedEOF\n \t}\n \tn := copy(b, r[int(off):])\n \treturn n, nil"}, {"sha": "e3d968fb81a15b882c1b1dcbd182488595686e41", "filename": "libgo/go/mime/type.go", "status": "modified", "additions": 3, "deletions": 42, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmime%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmime%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Ftype.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -6,19 +6,11 @@\n package mime\n \n import (\n-\t\"bufio\"\n \t\"fmt\"\n-\t\"os\"\n \t\"strings\"\n \t\"sync\"\n )\n \n-var typeFiles = []string{\n-\t\"/etc/mime.types\",\n-\t\"/etc/apache2/mime.types\",\n-\t\"/etc/apache/mime.types\",\n-}\n-\n var mimeTypes = map[string]string{\n \t\".css\":  \"text/css; charset=utf-8\",\n \t\".gif\":  \"image/gif\",\n@@ -33,53 +25,22 @@ var mimeTypes = map[string]string{\n \n var mimeLock sync.RWMutex\n \n-func loadMimeFile(filename string) {\n-\tf, err := os.Open(filename)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n-\treader := bufio.NewReader(f)\n-\tfor {\n-\t\tline, err := reader.ReadString('\\n')\n-\t\tif err != nil {\n-\t\t\tf.Close()\n-\t\t\treturn\n-\t\t}\n-\t\tfields := strings.Fields(line)\n-\t\tif len(fields) <= 1 || fields[0][0] == '#' {\n-\t\t\tcontinue\n-\t\t}\n-\t\tmimeType := fields[0]\n-\t\tfor _, ext := range fields[1:] {\n-\t\t\tif ext[0] == '#' {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tsetExtensionType(\".\"+ext, mimeType)\n-\t\t}\n-\t}\n-}\n-\n-func initMime() {\n-\tfor _, filename := range typeFiles {\n-\t\tloadMimeFile(filename)\n-\t}\n-}\n-\n var once sync.Once\n \n // TypeByExtension returns the MIME type associated with the file extension ext.\n // The extension ext should begin with a leading dot, as in \".html\".\n // When ext has no associated type, TypeByExtension returns \"\".\n //\n-// The built-in table is small but is is augmented by the local\n+// The built-in table is small but on unix it is augmented by the local\n // system's mime.types file(s) if available under one or more of these\n // names:\n //\n //   /etc/mime.types\n //   /etc/apache2/mime.types\n //   /etc/apache/mime.types\n //\n+// Windows system mime types are extracted from registry.\n+//\n // Text types have the charset parameter set to \"utf-8\" by default.\n func TypeByExtension(ext string) string {\n \tonce.Do(initMime)"}, {"sha": "07e1cd5daecfbfb84896a582fd1c1b3be9eb1705", "filename": "libgo/go/mime/type_test.go", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmime%2Ftype_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmime%2Ftype_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Ftype_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -6,15 +6,9 @@ package mime\n \n import \"testing\"\n \n-var typeTests = map[string]string{\n-\t\".t1\":  \"application/test\",\n-\t\".t2\":  \"text/test; charset=utf-8\",\n-\t\".png\": \"image/png\",\n-}\n+var typeTests = initMimeForTests()\n \n func TestTypeByExtension(t *testing.T) {\n-\ttypeFiles = []string{\"test.types\"}\n-\n \tfor ext, want := range typeTests {\n \t\tval := TypeByExtension(ext)\n \t\tif val != want {"}, {"sha": "45127ba29df4e5b827f9fc2084ccf4e2a77811c5", "filename": "libgo/go/mime/type_unix.go", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmime%2Ftype_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmime%2Ftype_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Ftype_unix.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package mime\n+\n+import (\n+\t\"bufio\"\n+\t\"os\"\n+\t\"strings\"\n+)\n+\n+var typeFiles = []string{\n+\t\"/etc/mime.types\",\n+\t\"/etc/apache2/mime.types\",\n+\t\"/etc/apache/mime.types\",\n+}\n+\n+func loadMimeFile(filename string) {\n+\tf, err := os.Open(filename)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\treader := bufio.NewReader(f)\n+\tfor {\n+\t\tline, err := reader.ReadString('\\n')\n+\t\tif err != nil {\n+\t\t\tf.Close()\n+\t\t\treturn\n+\t\t}\n+\t\tfields := strings.Fields(line)\n+\t\tif len(fields) <= 1 || fields[0][0] == '#' {\n+\t\t\tcontinue\n+\t\t}\n+\t\tmimeType := fields[0]\n+\t\tfor _, ext := range fields[1:] {\n+\t\t\tif ext[0] == '#' {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tsetExtensionType(\".\"+ext, mimeType)\n+\t\t}\n+\t}\n+}\n+\n+func initMime() {\n+\tfor _, filename := range typeFiles {\n+\t\tloadMimeFile(filename)\n+\t}\n+}\n+\n+func initMimeForTests() map[string]string {\n+\ttypeFiles = []string{\"test.types\"}\n+\treturn map[string]string{\n+\t\t\".t1\":  \"application/test\",\n+\t\t\".t2\":  \"text/test; charset=utf-8\",\n+\t\t\".png\": \"image/png\",\n+\t}\n+}"}, {"sha": "7cf2d3984b1e193a8fd52d2c3aab1e75ca768eb7", "filename": "libgo/go/mime/type_windows.go", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmime%2Ftype_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fmime%2Ftype_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Ftype_windows.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package mime\n+\n+import (\n+\t\"syscall\"\n+\t\"unsafe\"\n+)\n+\n+func initMime() {\n+\tvar root syscall.Handle\n+\tif syscall.RegOpenKeyEx(syscall.HKEY_CLASSES_ROOT, syscall.StringToUTF16Ptr(`\\`),\n+\t\t0, syscall.KEY_READ, &root) != 0 {\n+\t\treturn\n+\t}\n+\tdefer syscall.RegCloseKey(root)\n+\tvar count uint32\n+\tif syscall.RegQueryInfoKey(root, nil, nil, nil, &count, nil, nil, nil, nil, nil, nil, nil) != 0 {\n+\t\treturn\n+\t}\n+\tvar buf [1 << 10]uint16\n+\tfor i := uint32(0); i < count; i++ {\n+\t\tn := uint32(len(buf))\n+\t\tif syscall.RegEnumKeyEx(root, i, &buf[0], &n, nil, nil, nil, nil) != 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\text := syscall.UTF16ToString(buf[:])\n+\t\tif len(ext) < 2 || ext[0] != '.' { // looking for extensions only\n+\t\t\tcontinue\n+\t\t}\n+\t\tvar h syscall.Handle\n+\t\tif syscall.RegOpenKeyEx(\n+\t\t\tsyscall.HKEY_CLASSES_ROOT, syscall.StringToUTF16Ptr(`\\`+ext),\n+\t\t\t0, syscall.KEY_READ, &h) != 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tvar typ uint32\n+\t\tn = uint32(len(buf) * 2) // api expects array of bytes, not uint16\n+\t\tif syscall.RegQueryValueEx(\n+\t\t\th, syscall.StringToUTF16Ptr(\"Content Type\"),\n+\t\t\tnil, &typ, (*byte)(unsafe.Pointer(&buf[0])), &n) != 0 {\n+\t\t\tsyscall.RegCloseKey(h)\n+\t\t\tcontinue\n+\t\t}\n+\t\tsyscall.RegCloseKey(h)\n+\t\tif typ != syscall.REG_SZ { // null terminated strings only\n+\t\t\tcontinue\n+\t\t}\n+\t\tmimeType := syscall.UTF16ToString(buf[:])\n+\t\tsetExtensionType(ext, mimeType)\n+\t}\n+}\n+\n+func initMimeForTests() map[string]string {\n+\treturn map[string]string{\n+\t\t\".bmp\": \"image/bmp\",\n+\t\t\".png\": \"image/png\",\n+\t}\n+}"}, {"sha": "1a0f4063c5a7ee5a8f3fcf1890e0cddd935a7d12", "filename": "libgo/go/net/cgo_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fcgo_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fcgo_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fcgo_unix.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -109,7 +109,7 @@ func cgoLookupIPCNAME(name string) (addrs []IP, cname string, err error, complet\n \t\tif gerrno == syscall.EAI_NONAME {\n \t\t\tstr = noSuchHost\n \t\t} else if gerrno == syscall.EAI_SYSTEM {\n-\t\t\tstr = syscall.Errstr(syscall.GetErrno())\n+\t\t\tstr = syscall.GetErrno().Error()\n \t\t} else {\n \t\t\tstr = bytePtrToString(libc_gai_strerror(gerrno))\n \t\t}"}, {"sha": "70e04a21c0b5c0cf50f64023771fc80e65d49e33", "filename": "libgo/go/net/fd.go", "status": "modified", "additions": 105, "deletions": 99, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Ffd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Ffd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -278,8 +278,8 @@ func startServer() {\n \n func newFD(fd, family, proto int, net string) (f *netFD, err error) {\n \tonceStartServer.Do(startServer)\n-\tif e := syscall.SetNonblock(fd, true); e != 0 {\n-\t\treturn nil, os.Errno(e)\n+\tif e := syscall.SetNonblock(fd, true); e != nil {\n+\t\treturn nil, e\n \t}\n \tf = &netFD{\n \t\tsysfd:  fd,\n@@ -306,19 +306,19 @@ func (fd *netFD) setAddr(laddr, raddr Addr) {\n }\n \n func (fd *netFD) connect(ra syscall.Sockaddr) (err error) {\n-\te := syscall.Connect(fd.sysfd, ra)\n-\tif e == syscall.EINPROGRESS {\n-\t\tvar errno int\n+\terr = syscall.Connect(fd.sysfd, ra)\n+\tif err == syscall.EINPROGRESS {\n \t\tpollserver.WaitWrite(fd)\n-\t\te, errno = syscall.GetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_ERROR)\n-\t\tif errno != 0 {\n-\t\t\treturn os.NewSyscallError(\"getsockopt\", errno)\n+\t\tvar e int\n+\t\te, err = syscall.GetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_ERROR)\n+\t\tif err != nil {\n+\t\t\treturn os.NewSyscallError(\"getsockopt\", err)\n+\t\t}\n+\t\tif e != 0 {\n+\t\t\terr = syscall.Errno(e)\n \t\t}\n \t}\n-\tif e != 0 {\n-\t\treturn os.Errno(e)\n-\t}\n-\treturn nil\n+\treturn err\n }\n \n // Add a reference to this fd.\n@@ -362,9 +362,9 @@ func (fd *netFD) shutdown(how int) error {\n \tif fd == nil || fd.sysfile == nil {\n \t\treturn os.EINVAL\n \t}\n-\terrno := syscall.Shutdown(fd.sysfd, how)\n-\tif errno != 0 {\n-\t\treturn &OpError{\"shutdown\", fd.net, fd.laddr, os.Errno(errno)}\n+\terr := syscall.Shutdown(fd.sysfd, how)\n+\tif err != nil {\n+\t\treturn &OpError{\"shutdown\", fd.net, fd.laddr, err}\n \t}\n \treturn nil\n }\n@@ -377,6 +377,14 @@ func (fd *netFD) CloseWrite() error {\n \treturn fd.shutdown(syscall.SHUT_WR)\n }\n \n+type timeoutError struct{}\n+\n+func (e *timeoutError) Error() string   { return \"i/o timeout\" }\n+func (e *timeoutError) Timeout() bool   { return true }\n+func (e *timeoutError) Temporary() bool { return true }\n+\n+var errTimeout error = &timeoutError{}\n+\n func (fd *netFD) Read(p []byte) (n int, err error) {\n \tif fd == nil {\n \t\treturn 0, os.EINVAL\n@@ -393,24 +401,24 @@ func (fd *netFD) Read(p []byte) (n int, err error) {\n \t} else {\n \t\tfd.rdeadline = 0\n \t}\n-\tvar oserr error\n \tfor {\n-\t\tvar errno int\n-\t\tn, errno = syscall.Read(fd.sysfile.Fd(), p)\n-\t\tif errno == syscall.EAGAIN && fd.rdeadline >= 0 {\n-\t\t\tpollserver.WaitRead(fd)\n-\t\t\tcontinue\n+\t\tn, err = syscall.Read(fd.sysfile.Fd(), p)\n+\t\tif err == syscall.EAGAIN {\n+\t\t\tif fd.rdeadline >= 0 {\n+\t\t\t\tpollserver.WaitRead(fd)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\terr = errTimeout\n \t\t}\n-\t\tif errno != 0 {\n+\t\tif err != nil {\n \t\t\tn = 0\n-\t\t\toserr = os.Errno(errno)\n-\t\t} else if n == 0 && errno == 0 && fd.proto != syscall.SOCK_DGRAM {\n+\t\t} else if n == 0 && err == nil && fd.proto != syscall.SOCK_DGRAM {\n \t\t\terr = io.EOF\n \t\t}\n \t\tbreak\n \t}\n-\tif oserr != nil {\n-\t\terr = &OpError{\"read\", fd.net, fd.raddr, oserr}\n+\tif err != nil && err != io.EOF {\n+\t\terr = &OpError{\"read\", fd.net, fd.raddr, err}\n \t}\n \treturn\n }\n@@ -428,22 +436,22 @@ func (fd *netFD) ReadFrom(p []byte) (n int, sa syscall.Sockaddr, err error) {\n \t} else {\n \t\tfd.rdeadline = 0\n \t}\n-\tvar oserr error\n \tfor {\n-\t\tvar errno int\n-\t\tn, sa, errno = syscall.Recvfrom(fd.sysfd, p, 0)\n-\t\tif errno == syscall.EAGAIN && fd.rdeadline >= 0 {\n-\t\t\tpollserver.WaitRead(fd)\n-\t\t\tcontinue\n+\t\tn, sa, err = syscall.Recvfrom(fd.sysfd, p, 0)\n+\t\tif err == syscall.EAGAIN {\n+\t\t\tif fd.rdeadline >= 0 {\n+\t\t\t\tpollserver.WaitRead(fd)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\terr = errTimeout\n \t\t}\n-\t\tif errno != 0 {\n+\t\tif err != nil {\n \t\t\tn = 0\n-\t\t\toserr = os.Errno(errno)\n \t\t}\n \t\tbreak\n \t}\n-\tif oserr != nil {\n-\t\terr = &OpError{\"read\", fd.net, fd.laddr, oserr}\n+\tif err != nil {\n+\t\terr = &OpError{\"read\", fd.net, fd.laddr, err}\n \t}\n \treturn\n }\n@@ -461,24 +469,22 @@ func (fd *netFD) ReadMsg(p []byte, oob []byte) (n, oobn, flags int, sa syscall.S\n \t} else {\n \t\tfd.rdeadline = 0\n \t}\n-\tvar oserr error\n \tfor {\n-\t\tvar errno int\n-\t\tn, oobn, flags, sa, errno = syscall.Recvmsg(fd.sysfd, p, oob, 0)\n-\t\tif errno == syscall.EAGAIN && fd.rdeadline >= 0 {\n-\t\t\tpollserver.WaitRead(fd)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif errno != 0 {\n-\t\t\toserr = os.Errno(errno)\n+\t\tn, oobn, flags, sa, err = syscall.Recvmsg(fd.sysfd, p, oob, 0)\n+\t\tif err == syscall.EAGAIN {\n+\t\t\tif fd.rdeadline >= 0 {\n+\t\t\t\tpollserver.WaitRead(fd)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\terr = errTimeout\n \t\t}\n-\t\tif n == 0 {\n-\t\t\toserr = io.EOF\n+\t\tif err == nil && n == 0 {\n+\t\t\terr = io.EOF\n \t\t}\n \t\tbreak\n \t}\n-\tif oserr != nil {\n-\t\terr = &OpError{\"read\", fd.net, fd.laddr, oserr}\n+\tif err != nil && err != io.EOF {\n+\t\terr = &OpError{\"read\", fd.net, fd.laddr, err}\n \t\treturn\n \t}\n \treturn\n@@ -501,32 +507,34 @@ func (fd *netFD) Write(p []byte) (n int, err error) {\n \t\tfd.wdeadline = 0\n \t}\n \tnn := 0\n-\tvar oserr error\n \n \tfor {\n-\t\tn, errno := syscall.Write(fd.sysfile.Fd(), p[nn:])\n+\t\tvar n int\n+\t\tn, err = syscall.Write(fd.sysfile.Fd(), p[nn:])\n \t\tif n > 0 {\n \t\t\tnn += n\n \t\t}\n \t\tif nn == len(p) {\n \t\t\tbreak\n \t\t}\n-\t\tif errno == syscall.EAGAIN && fd.wdeadline >= 0 {\n-\t\t\tpollserver.WaitWrite(fd)\n-\t\t\tcontinue\n+\t\tif err == syscall.EAGAIN {\n+\t\t\tif fd.wdeadline >= 0 {\n+\t\t\t\tpollserver.WaitWrite(fd)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\terr = errTimeout\n \t\t}\n-\t\tif errno != 0 {\n+\t\tif err != nil {\n \t\t\tn = 0\n-\t\t\toserr = os.Errno(errno)\n \t\t\tbreak\n \t\t}\n \t\tif n == 0 {\n-\t\t\toserr = io.ErrUnexpectedEOF\n+\t\t\terr = io.ErrUnexpectedEOF\n \t\t\tbreak\n \t\t}\n \t}\n-\tif oserr != nil {\n-\t\terr = &OpError{\"write\", fd.net, fd.raddr, oserr}\n+\tif err != nil {\n+\t\terr = &OpError{\"write\", fd.net, fd.raddr, err}\n \t}\n \treturn nn, err\n }\n@@ -544,22 +552,21 @@ func (fd *netFD) WriteTo(p []byte, sa syscall.Sockaddr) (n int, err error) {\n \t} else {\n \t\tfd.wdeadline = 0\n \t}\n-\tvar oserr error\n \tfor {\n-\t\terrno := syscall.Sendto(fd.sysfd, p, 0, sa)\n-\t\tif errno == syscall.EAGAIN && fd.wdeadline >= 0 {\n-\t\t\tpollserver.WaitWrite(fd)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif errno != 0 {\n-\t\t\toserr = os.Errno(errno)\n+\t\terr = syscall.Sendto(fd.sysfd, p, 0, sa)\n+\t\tif err == syscall.EAGAIN {\n+\t\t\tif fd.wdeadline >= 0 {\n+\t\t\t\tpollserver.WaitWrite(fd)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\terr = errTimeout\n \t\t}\n \t\tbreak\n \t}\n-\tif oserr == nil {\n+\tif err == nil {\n \t\tn = len(p)\n \t} else {\n-\t\terr = &OpError{\"write\", fd.net, fd.raddr, oserr}\n+\t\terr = &OpError{\"write\", fd.net, fd.raddr, err}\n \t}\n \treturn\n }\n@@ -577,24 +584,22 @@ func (fd *netFD) WriteMsg(p []byte, oob []byte, sa syscall.Sockaddr) (n int, oob\n \t} else {\n \t\tfd.wdeadline = 0\n \t}\n-\tvar oserr error\n \tfor {\n-\t\tvar errno int\n-\t\terrno = syscall.Sendmsg(fd.sysfd, p, oob, sa, 0)\n-\t\tif errno == syscall.EAGAIN && fd.wdeadline >= 0 {\n-\t\t\tpollserver.WaitWrite(fd)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif errno != 0 {\n-\t\t\toserr = os.Errno(errno)\n+\t\terr = syscall.Sendmsg(fd.sysfd, p, oob, sa, 0)\n+\t\tif err == syscall.EAGAIN {\n+\t\t\tif fd.wdeadline >= 0 {\n+\t\t\t\tpollserver.WaitWrite(fd)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\terr = errTimeout\n \t\t}\n \t\tbreak\n \t}\n-\tif oserr == nil {\n+\tif err == nil {\n \t\tn = len(p)\n \t\toobn = len(oob)\n \t} else {\n-\t\terr = &OpError{\"write\", fd.net, fd.raddr, oserr}\n+\t\terr = &OpError{\"write\", fd.net, fd.raddr, err}\n \t}\n \treturn\n }\n@@ -615,25 +620,26 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (nfd *netFD, err err\n \t// See ../syscall/exec.go for description of ForkLock.\n \t// It is okay to hold the lock across syscall.Accept\n \t// because we have put fd.sysfd into non-blocking mode.\n-\tsyscall.ForkLock.RLock()\n-\tvar s, e int\n+\tvar s int\n \tvar rsa syscall.Sockaddr\n \tfor {\n \t\tif fd.closing {\n-\t\t\tsyscall.ForkLock.RUnlock()\n \t\t\treturn nil, os.EINVAL\n \t\t}\n-\t\ts, rsa, e = syscall.Accept(fd.sysfd)\n-\t\tif e != syscall.EAGAIN || fd.rdeadline < 0 {\n-\t\t\tbreak\n-\t\t}\n-\t\tsyscall.ForkLock.RUnlock()\n-\t\tpollserver.WaitRead(fd)\n \t\tsyscall.ForkLock.RLock()\n-\t}\n-\tif e != 0 {\n-\t\tsyscall.ForkLock.RUnlock()\n-\t\treturn nil, &OpError{\"accept\", fd.net, fd.laddr, os.Errno(e)}\n+\t\ts, rsa, err = syscall.Accept(fd.sysfd)\n+\t\tif err != nil {\n+\t\t\tsyscall.ForkLock.RUnlock()\n+\t\t\tif err == syscall.EAGAIN {\n+\t\t\t\tif fd.rdeadline >= 0 {\n+\t\t\t\t\tpollserver.WaitRead(fd)\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\terr = errTimeout\n+\t\t\t}\n+\t\t\treturn nil, &OpError{\"accept\", fd.net, fd.laddr, err}\n+\t\t}\n+\t\tbreak\n \t}\n \tsyscall.CloseOnExec(s)\n \tsyscall.ForkLock.RUnlock()\n@@ -648,19 +654,19 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (nfd *netFD, err err\n }\n \n func (fd *netFD) dup() (f *os.File, err error) {\n-\tns, e := syscall.Dup(fd.sysfd)\n-\tif e != 0 {\n-\t\treturn nil, &OpError{\"dup\", fd.net, fd.laddr, os.Errno(e)}\n+\tns, err := syscall.Dup(fd.sysfd)\n+\tif err != nil {\n+\t\treturn nil, &OpError{\"dup\", fd.net, fd.laddr, err}\n \t}\n \n \t// We want blocking mode for the new fd, hence the double negative.\n-\tif e = syscall.SetNonblock(ns, false); e != 0 {\n-\t\treturn nil, &OpError{\"setnonblock\", fd.net, fd.laddr, os.Errno(e)}\n+\tif err = syscall.SetNonblock(ns, false); err != nil {\n+\t\treturn nil, &OpError{\"setnonblock\", fd.net, fd.laddr, err}\n \t}\n \n \treturn os.NewFile(ns, fd.sysfile.Name()), nil\n }\n \n-func closesocket(s int) (errno int) {\n+func closesocket(s int) error {\n \treturn syscall.Close(s)\n }"}, {"sha": "8e07833882e5a48d88c9158bedaf05b707856297", "filename": "libgo/go/net/fd_linux.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Ffd_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Ffd_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_linux.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -35,12 +35,12 @@ type pollster struct {\n \n func newpollster() (p *pollster, err error) {\n \tp = new(pollster)\n-\tvar e int\n+\tvar e error\n \n \t// The arg to epoll_create is a hint to the kernel\n \t// about the number of FDs we will care about.\n \t// We don't know, and since 2.6.8 the kernel ignores it anyhow.\n-\tif p.epfd, e = syscall.EpollCreate(16); e != 0 {\n+\tif p.epfd, e = syscall.EpollCreate(16); e != nil {\n \t\treturn nil, os.NewSyscallError(\"epoll_create\", e)\n \t}\n \tp.events = make(map[int]uint32)\n@@ -68,7 +68,7 @@ func (p *pollster) AddFD(fd int, mode int, repeat bool) (bool, error) {\n \t} else {\n \t\top = syscall.EPOLL_CTL_ADD\n \t}\n-\tif e := syscall.EpollCtl(p.epfd, op, fd, &p.ctlEvent); e != 0 {\n+\tif e := syscall.EpollCtl(p.epfd, op, fd, &p.ctlEvent); e != nil {\n \t\treturn false, os.NewSyscallError(\"epoll_ctl\", e)\n \t}\n \tp.events[fd] = p.ctlEvent.Events\n@@ -97,13 +97,13 @@ func (p *pollster) StopWaiting(fd int, bits uint) {\n \tif int32(events)&^syscall.EPOLLONESHOT != 0 {\n \t\tp.ctlEvent.Fd = int32(fd)\n \t\tp.ctlEvent.Events = events\n-\t\tif e := syscall.EpollCtl(p.epfd, syscall.EPOLL_CTL_MOD, fd, &p.ctlEvent); e != 0 {\n-\t\t\tprint(\"Epoll modify fd=\", fd, \": \", os.Errno(e).Error(), \"\\n\")\n+\t\tif e := syscall.EpollCtl(p.epfd, syscall.EPOLL_CTL_MOD, fd, &p.ctlEvent); e != nil {\n+\t\t\tprint(\"Epoll modify fd=\", fd, \": \", e.Error(), \"\\n\")\n \t\t}\n \t\tp.events[fd] = events\n \t} else {\n-\t\tif e := syscall.EpollCtl(p.epfd, syscall.EPOLL_CTL_DEL, fd, nil); e != 0 {\n-\t\t\tprint(\"Epoll delete fd=\", fd, \": \", os.Errno(e).Error(), \"\\n\")\n+\t\tif e := syscall.EpollCtl(p.epfd, syscall.EPOLL_CTL_DEL, fd, nil); e != nil {\n+\t\t\tprint(\"Epoll delete fd=\", fd, \": \", e.Error(), \"\\n\")\n \t\t}\n \t\tdelete(p.events, fd)\n \t}\n@@ -141,7 +141,7 @@ func (p *pollster) WaitFD(s *pollServer, nsec int64) (fd int, mode int, err erro\n \t\tn, e := syscall.EpollWait(p.epfd, p.waitEventBuf[0:], msec)\n \t\ts.Lock()\n \n-\t\tif e != 0 {\n+\t\tif e != nil {\n \t\t\tif e == syscall.EAGAIN || e == syscall.EINTR {\n \t\t\t\tcontinue\n \t\t\t}"}, {"sha": "e52ac356b9fd5b086c3bb38e37fb34b28a04bb50", "filename": "libgo/go/net/fd_openbsd.go", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Ffd_openbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Ffd_openbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_openbsd.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -23,9 +23,8 @@ type pollster struct {\n \n func newpollster() (p *pollster, err error) {\n \tp = new(pollster)\n-\tvar e int\n-\tif p.kq, e = syscall.Kqueue(); e != 0 {\n-\t\treturn nil, os.NewSyscallError(\"kqueue\", e)\n+\tif p.kq, err = syscall.Kqueue(); err != nil {\n+\t\treturn nil, os.NewSyscallError(\"kqueue\", err)\n \t}\n \tp.events = p.eventbuf[0:0]\n \treturn p, nil\n@@ -50,14 +49,14 @@ func (p *pollster) AddFD(fd int, mode int, repeat bool) (bool, error) {\n \tsyscall.SetKevent(ev, fd, kmode, flags)\n \n \tn, e := syscall.Kevent(p.kq, p.kbuf[:], nil, nil)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn false, os.NewSyscallError(\"kevent\", e)\n \t}\n \tif n != 1 || (ev.Flags&syscall.EV_ERROR) == 0 || int(ev.Ident) != fd || int(ev.Filter) != kmode {\n \t\treturn false, os.NewSyscallError(\"kqueue phase error\", e)\n \t}\n \tif ev.Data != 0 {\n-\t\treturn false, os.Errno(int(ev.Data))\n+\t\treturn false, syscall.Errno(int(ev.Data))\n \t}\n \treturn false, nil\n }\n@@ -91,7 +90,7 @@ func (p *pollster) WaitFD(s *pollServer, nsec int64) (fd int, mode int, err erro\n \t\tnn, e := syscall.Kevent(p.kq, nil, p.eventbuf[:], t)\n \t\ts.Lock()\n \n-\t\tif e != 0 {\n+\t\tif e != nil {\n \t\t\tif e == syscall.EINTR {\n \t\t\t\tcontinue\n \t\t\t}"}, {"sha": "7a1602371e9c726a178f5fc20cda66523c448d3b", "filename": "libgo/go/net/fd_windows.go", "status": "modified", "additions": 36, "deletions": 40, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Ffd_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Ffd_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_windows.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -26,25 +26,25 @@ func init() {\n \tvar d syscall.WSAData\n \te := syscall.WSAStartup(uint32(0x202), &d)\n \tif e != 0 {\n-\t\tinitErr = os.NewSyscallError(\"WSAStartup\", e)\n+\t\tinitErr = os.NewSyscallError(\"WSAStartup\", syscall.Errno(e))\n \t}\n }\n \n-func closesocket(s syscall.Handle) (errno int) {\n+func closesocket(s syscall.Handle) (err error) {\n \treturn syscall.Closesocket(s)\n }\n \n // Interface for all io operations.\n type anOpIface interface {\n \tOp() *anOp\n \tName() string\n-\tSubmit() (errno int)\n+\tSubmit() (err error)\n }\n \n // IO completion result parameters.\n type ioResult struct {\n \tqty uint32\n-\terr int\n+\terr error\n }\n \n // anOp implements functionality common to all io operations.\n@@ -54,7 +54,7 @@ type anOp struct {\n \to syscall.Overlapped\n \n \tresultc chan ioResult\n-\terrnoc  chan int\n+\terrnoc  chan error\n \tfd      *netFD\n }\n \n@@ -71,7 +71,7 @@ func (o *anOp) Init(fd *netFD, mode int) {\n \t}\n \to.resultc = fd.resultc[i]\n \tif fd.errnoc[i] == nil {\n-\t\tfd.errnoc[i] = make(chan int)\n+\t\tfd.errnoc[i] = make(chan error)\n \t}\n \to.errnoc = fd.errnoc[i]\n }\n@@ -111,14 +111,14 @@ func (s *resultSrv) Run() {\n \tfor {\n \t\tr.err = syscall.GetQueuedCompletionStatus(s.iocp, &(r.qty), &key, &o, syscall.INFINITE)\n \t\tswitch {\n-\t\tcase r.err == 0:\n+\t\tcase r.err == nil:\n \t\t\t// Dequeued successfully completed io packet.\n-\t\tcase r.err == syscall.WAIT_TIMEOUT && o == nil:\n+\t\tcase r.err == syscall.Errno(syscall.WAIT_TIMEOUT) && o == nil:\n \t\t\t// Wait has timed out (should not happen now, but might be used in the future).\n \t\t\tpanic(\"GetQueuedCompletionStatus timed out\")\n \t\tcase o == nil:\n \t\t\t// Failed to dequeue anything -> report the error.\n-\t\t\tpanic(\"GetQueuedCompletionStatus failed \" + syscall.Errstr(r.err))\n+\t\t\tpanic(\"GetQueuedCompletionStatus failed \" + r.err.Error())\n \t\tdefault:\n \t\t\t// Dequeued failed io packet.\n \t\t}\n@@ -153,7 +153,7 @@ func (s *ioSrv) ProcessRemoteIO() {\n // inline, or, if timeouts are employed, passes the request onto\n // a special goroutine and waits for completion or cancels request.\n func (s *ioSrv) ExecIO(oi anOpIface, deadline_delta int64) (n int, err error) {\n-\tvar e int\n+\tvar e error\n \to := oi.Op()\n \tif deadline_delta > 0 {\n \t\t// Send request to a special dedicated thread,\n@@ -164,12 +164,12 @@ func (s *ioSrv) ExecIO(oi anOpIface, deadline_delta int64) (n int, err error) {\n \t\te = oi.Submit()\n \t}\n \tswitch e {\n-\tcase 0:\n+\tcase nil:\n \t\t// IO completed immediately, but we need to get our completion message anyway.\n \tcase syscall.ERROR_IO_PENDING:\n \t\t// IO started, and we have to wait for its completion.\n \tdefault:\n-\t\treturn 0, &OpError{oi.Name(), o.fd.net, o.fd.laddr, os.Errno(e)}\n+\t\treturn 0, &OpError{oi.Name(), o.fd.net, o.fd.laddr, e}\n \t}\n \t// Wait for our request to complete.\n \tvar r ioResult\n@@ -187,8 +187,8 @@ func (s *ioSrv) ExecIO(oi anOpIface, deadline_delta int64) (n int, err error) {\n \t} else {\n \t\tr = <-o.resultc\n \t}\n-\tif r.err != 0 {\n-\t\terr = &OpError{oi.Name(), o.fd.net, o.fd.laddr, os.Errno(r.err)}\n+\tif r.err != nil {\n+\t\terr = &OpError{oi.Name(), o.fd.net, o.fd.laddr, r.err}\n \t}\n \treturn int(r.qty), err\n }\n@@ -200,10 +200,10 @@ var onceStartServer sync.Once\n \n func startServer() {\n \tresultsrv = new(resultSrv)\n-\tvar errno int\n-\tresultsrv.iocp, errno = syscall.CreateIoCompletionPort(syscall.InvalidHandle, 0, 0, 1)\n-\tif errno != 0 {\n-\t\tpanic(\"CreateIoCompletionPort failed \" + syscall.Errstr(errno))\n+\tvar err error\n+\tresultsrv.iocp, err = syscall.CreateIoCompletionPort(syscall.InvalidHandle, 0, 0, 1)\n+\tif err != nil {\n+\t\tpanic(\"CreateIoCompletionPort: \" + err.Error())\n \t}\n \tgo resultsrv.Run()\n \n@@ -228,7 +228,7 @@ type netFD struct {\n \tladdr   Addr\n \traddr   Addr\n \tresultc [2]chan ioResult // read/write completion results\n-\terrnoc  [2]chan int      // read/write submit or cancel operation errors\n+\terrnoc  [2]chan error    // read/write submit or cancel operation errors\n \n \t// owned by client\n \trdeadline_delta int64\n@@ -256,8 +256,8 @@ func newFD(fd syscall.Handle, family, proto int, net string) (f *netFD, err erro\n \t}\n \tonceStartServer.Do(startServer)\n \t// Associate our socket with resultsrv.iocp.\n-\tif _, e := syscall.CreateIoCompletionPort(syscall.Handle(fd), resultsrv.iocp, 0, 0); e != 0 {\n-\t\treturn nil, os.Errno(e)\n+\tif _, e := syscall.CreateIoCompletionPort(syscall.Handle(fd), resultsrv.iocp, 0, 0); e != nil {\n+\t\treturn nil, e\n \t}\n \treturn allocFD(fd, family, proto, net), nil\n }\n@@ -268,11 +268,7 @@ func (fd *netFD) setAddr(laddr, raddr Addr) {\n }\n \n func (fd *netFD) connect(ra syscall.Sockaddr) (err error) {\n-\te := syscall.Connect(fd.sysfd, ra)\n-\tif e != 0 {\n-\t\treturn os.Errno(e)\n-\t}\n-\treturn nil\n+\treturn syscall.Connect(fd.sysfd, ra)\n }\n \n // Add a reference to this fd.\n@@ -317,9 +313,9 @@ func (fd *netFD) shutdown(how int) error {\n \tif fd == nil || fd.sysfd == syscall.InvalidHandle {\n \t\treturn os.EINVAL\n \t}\n-\terrno := syscall.Shutdown(fd.sysfd, how)\n-\tif errno != 0 {\n-\t\treturn &OpError{\"shutdown\", fd.net, fd.laddr, os.Errno(errno)}\n+\terr := syscall.Shutdown(fd.sysfd, how)\n+\tif err != nil {\n+\t\treturn &OpError{\"shutdown\", fd.net, fd.laddr, err}\n \t}\n \treturn nil\n }\n@@ -338,7 +334,7 @@ type readOp struct {\n \tbufOp\n }\n \n-func (o *readOp) Submit() (errno int) {\n+func (o *readOp) Submit() (err error) {\n \tvar d, f uint32\n \treturn syscall.WSARecv(syscall.Handle(o.fd.sysfd), &o.buf, 1, &d, &f, &o.o, nil)\n }\n@@ -375,7 +371,7 @@ type readFromOp struct {\n \trsan int32\n }\n \n-func (o *readFromOp) Submit() (errno int) {\n+func (o *readFromOp) Submit() (err error) {\n \tvar d, f uint32\n \treturn syscall.WSARecvFrom(o.fd.sysfd, &o.buf, 1, &d, &f, &o.rsa, &o.rsan, &o.o, nil)\n }\n@@ -415,7 +411,7 @@ type writeOp struct {\n \tbufOp\n }\n \n-func (o *writeOp) Submit() (errno int) {\n+func (o *writeOp) Submit() (err error) {\n \tvar d uint32\n \treturn syscall.WSASend(o.fd.sysfd, &o.buf, 1, &d, 0, &o.o, nil)\n }\n@@ -447,7 +443,7 @@ type writeToOp struct {\n \tsa syscall.Sockaddr\n }\n \n-func (o *writeToOp) Submit() (errno int) {\n+func (o *writeToOp) Submit() (err error) {\n \tvar d uint32\n \treturn syscall.WSASendto(o.fd.sysfd, &o.buf, 1, &d, 0, o.sa, &o.o, nil)\n }\n@@ -484,7 +480,7 @@ type acceptOp struct {\n \tattrs   [2]syscall.RawSockaddrAny // space for local and remote address only\n }\n \n-func (o *acceptOp) Submit() (errno int) {\n+func (o *acceptOp) Submit() (err error) {\n \tvar d uint32\n \tl := uint32(unsafe.Sizeof(o.attrs[0]))\n \treturn syscall.AcceptEx(o.fd.sysfd, o.newsock,\n@@ -506,17 +502,17 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (nfd *netFD, err err\n \t// See ../syscall/exec.go for description of ForkLock.\n \tsyscall.ForkLock.RLock()\n \ts, e := syscall.Socket(fd.family, fd.proto, 0)\n-\tif e != 0 {\n+\tif e != nil {\n \t\tsyscall.ForkLock.RUnlock()\n-\t\treturn nil, os.Errno(e)\n+\t\treturn nil, e\n \t}\n \tsyscall.CloseOnExec(s)\n \tsyscall.ForkLock.RUnlock()\n \n \t// Associate our new socket with IOCP.\n \tonceStartServer.Do(startServer)\n-\tif _, e = syscall.CreateIoCompletionPort(s, resultsrv.iocp, 0, 0); e != 0 {\n-\t\treturn nil, &OpError{\"CreateIoCompletionPort\", fd.net, fd.laddr, os.Errno(e)}\n+\tif _, e = syscall.CreateIoCompletionPort(s, resultsrv.iocp, 0, 0); e != nil {\n+\t\treturn nil, &OpError{\"CreateIoCompletionPort\", fd.net, fd.laddr, e}\n \t}\n \n \t// Submit accept request.\n@@ -531,9 +527,9 @@ func (fd *netFD) accept(toAddr func(syscall.Sockaddr) Addr) (nfd *netFD, err err\n \n \t// Inherit properties of the listening socket.\n \te = syscall.Setsockopt(s, syscall.SOL_SOCKET, syscall.SO_UPDATE_ACCEPT_CONTEXT, (*byte)(unsafe.Pointer(&fd.sysfd)), int32(unsafe.Sizeof(fd.sysfd)))\n-\tif e != 0 {\n+\tif e != nil {\n \t\tclosesocket(s)\n-\t\treturn nil, err\n+\t\treturn nil, e\n \t}\n \n \t// Get local and peer addr out of AcceptEx buffer."}, {"sha": "bf8cd9dae043e75c23daecb601cd85bd30d892f6", "filename": "libgo/go/net/file.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffile.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -13,12 +13,12 @@ import (\n \n func newFileFD(f *os.File) (nfd *netFD, err error) {\n \tfd, errno := syscall.Dup(f.Fd())\n-\tif errno != 0 {\n+\tif errno != nil {\n \t\treturn nil, os.NewSyscallError(\"dup\", errno)\n \t}\n \n \tproto, errno := syscall.GetsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_TYPE)\n-\tif errno != 0 {\n+\tif errno != nil {\n \t\treturn nil, os.NewSyscallError(\"getsockopt\", errno)\n \t}\n "}, {"sha": "ddfb074ee8f12a43f119c344cf218f20c6c15feb", "filename": "libgo/go/net/hosts.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhosts.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhosts.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhosts.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -7,8 +7,8 @@\n package net\n \n import (\n-\t\"os\"\n \t\"sync\"\n+\t\"time\"\n )\n \n const cacheMaxAge = int64(300) // 5 minutes.\n@@ -26,7 +26,7 @@ var hosts struct {\n }\n \n func readHosts() {\n-\tnow, _, _ := os.Time()\n+\tnow := time.Seconds()\n \thp := hostsPath\n \tif len(hosts.byName) == 0 || hosts.time+cacheMaxAge <= now || hosts.path != hp {\n \t\ths := make(map[string][]string)\n@@ -51,7 +51,7 @@ func readHosts() {\n \t\t\t}\n \t\t}\n \t\t// Update the data cache.\n-\t\thosts.time, _, _ = os.Time()\n+\t\thosts.time = time.Seconds()\n \t\thosts.path = hp\n \t\thosts.byName = hs\n \t\thosts.byAddr = is"}, {"sha": "e6e85e8db3b0f4db9ae139941990aaa2245af580", "filename": "libgo/go/net/http/cgi/host_test.go", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcgi%2Fhost_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -363,14 +363,13 @@ func TestCopyError(t *testing.T) {\n \t}\n \tconn.Close()\n \n-\tif tries := 0; childRunning() {\n-\t\tfor tries < 15 && childRunning() {\n-\t\t\ttime.Sleep(50e6 * int64(tries))\n-\t\t\ttries++\n-\t\t}\n-\t\tif childRunning() {\n-\t\t\tt.Fatalf(\"post-conn.Close, expected child to be gone\")\n-\t\t}\n+\ttries := 0\n+\tfor tries < 15 && childRunning() {\n+\t\ttime.Sleep(50e6 * int64(tries))\n+\t\ttries++\n+\t}\n+\tif childRunning() {\n+\t\tt.Fatalf(\"post-conn.Close, expected child to be gone\")\n \t}\n }\n "}, {"sha": "74c41aabd41fd49ad1a63dea3c573617f8cb5e82", "filename": "libgo/go/net/http/chunked.go", "status": "modified", "additions": 119, "deletions": 6, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fchunked.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fchunked.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fchunked.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -2,20 +2,137 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// The wire protocol for HTTP's \"chunked\" Transfer-Encoding.\n+\n+// This code is duplicated in httputil/chunked.go.\n+// Please make any changes in both files.\n+\n package http\n \n import (\n \t\"bufio\"\n+\t\"bytes\"\n+\t\"errors\"\n \t\"io\"\n \t\"strconv\"\n )\n \n+const maxLineLength = 4096 // assumed <= bufio.defaultBufSize\n+\n+var ErrLineTooLong = errors.New(\"header line too long\")\n+\n+// newChunkedReader returns a new chunkedReader that translates the data read from r\n+// out of HTTP \"chunked\" format before returning it. \n+// The chunkedReader returns io.EOF when the final 0-length chunk is read.\n+//\n+// newChunkedReader is not needed by normal applications. The http package\n+// automatically decodes chunking when reading response bodies.\n+func newChunkedReader(r io.Reader) io.Reader {\n+\tbr, ok := r.(*bufio.Reader)\n+\tif !ok {\n+\t\tbr = bufio.NewReader(r)\n+\t}\n+\treturn &chunkedReader{r: br}\n+}\n+\n+type chunkedReader struct {\n+\tr   *bufio.Reader\n+\tn   uint64 // unread bytes in chunk\n+\terr error\n+}\n+\n+func (cr *chunkedReader) beginChunk() {\n+\t// chunk-size CRLF\n+\tvar line string\n+\tline, cr.err = readLine(cr.r)\n+\tif cr.err != nil {\n+\t\treturn\n+\t}\n+\tcr.n, cr.err = strconv.Btoui64(line, 16)\n+\tif cr.err != nil {\n+\t\treturn\n+\t}\n+\tif cr.n == 0 {\n+\t\tcr.err = io.EOF\n+\t}\n+}\n+\n+func (cr *chunkedReader) Read(b []uint8) (n int, err error) {\n+\tif cr.err != nil {\n+\t\treturn 0, cr.err\n+\t}\n+\tif cr.n == 0 {\n+\t\tcr.beginChunk()\n+\t\tif cr.err != nil {\n+\t\t\treturn 0, cr.err\n+\t\t}\n+\t}\n+\tif uint64(len(b)) > cr.n {\n+\t\tb = b[0:cr.n]\n+\t}\n+\tn, cr.err = cr.r.Read(b)\n+\tcr.n -= uint64(n)\n+\tif cr.n == 0 && cr.err == nil {\n+\t\t// end of chunk (CRLF)\n+\t\tb := make([]byte, 2)\n+\t\tif _, cr.err = io.ReadFull(cr.r, b); cr.err == nil {\n+\t\t\tif b[0] != '\\r' || b[1] != '\\n' {\n+\t\t\t\tcr.err = errors.New(\"malformed chunked encoding\")\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn n, cr.err\n+}\n+\n+// Read a line of bytes (up to \\n) from b.\n+// Give up if the line exceeds maxLineLength.\n+// The returned bytes are a pointer into storage in\n+// the bufio, so they are only valid until the next bufio read.\n+func readLineBytes(b *bufio.Reader) (p []byte, err error) {\n+\tif p, err = b.ReadSlice('\\n'); err != nil {\n+\t\t// We always know when EOF is coming.\n+\t\t// If the caller asked for a line, there should be a line.\n+\t\tif err == io.EOF {\n+\t\t\terr = io.ErrUnexpectedEOF\n+\t\t} else if err == bufio.ErrBufferFull {\n+\t\t\terr = ErrLineTooLong\n+\t\t}\n+\t\treturn nil, err\n+\t}\n+\tif len(p) >= maxLineLength {\n+\t\treturn nil, ErrLineTooLong\n+\t}\n+\n+\t// Chop off trailing white space.\n+\tp = bytes.TrimRight(p, \" \\r\\t\\n\")\n+\n+\treturn p, nil\n+}\n+\n+// readLineBytes, but convert the bytes into a string.\n+func readLine(b *bufio.Reader) (s string, err error) {\n+\tp, e := readLineBytes(b)\n+\tif e != nil {\n+\t\treturn \"\", e\n+\t}\n+\treturn string(p), nil\n+}\n+\n+// newChunkedWriter returns a new chunkedWriter that translates writes into HTTP\n+// \"chunked\" format before writing them to w. Closing the returned chunkedWriter\n+// sends the final 0-length chunk that marks the end of the stream.\n+//\n+// newChunkedWriter is not needed by normal applications. The http\n+// package adds chunking automatically if handlers don't set a\n+// Content-Length header. Using newChunkedWriter inside a handler\n+// would result in double chunking or chunking with a Content-Length\n+// length, both of which are wrong.\n func newChunkedWriter(w io.Writer) io.WriteCloser {\n \treturn &chunkedWriter{w}\n }\n \n-// Writing to ChunkedWriter translates to writing in HTTP chunked Transfer\n-// Encoding wire format to the underlying Wire writer.\n+// Writing to chunkedWriter translates to writing in HTTP chunked Transfer\n+// Encoding wire format to the underlying Wire chunkedWriter.\n type chunkedWriter struct {\n \tWire io.Writer\n }\n@@ -51,7 +168,3 @@ func (cw *chunkedWriter) Close() error {\n \t_, err := io.WriteString(cw.Wire, \"0\\r\\n\")\n \treturn err\n }\n-\n-func newChunkedReader(r *bufio.Reader) io.Reader {\n-\treturn &chunkedReader{r: r}\n-}"}, {"sha": "b77ee2ff26ce492e83581ad19252b45462fd906c", "filename": "libgo/go/net/http/chunked_test.go", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fchunked_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fchunked_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fchunked_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This code is duplicated in httputil/chunked_test.go.\n+// Please make any changes in both files.\n+\n+package http\n+\n+import (\n+\t\"bytes\"\n+\t\"io/ioutil\"\n+\t\"testing\"\n+)\n+\n+func TestChunk(t *testing.T) {\n+\tvar b bytes.Buffer\n+\n+\tw := newChunkedWriter(&b)\n+\tconst chunk1 = \"hello, \"\n+\tconst chunk2 = \"world! 0123456789abcdef\"\n+\tw.Write([]byte(chunk1))\n+\tw.Write([]byte(chunk2))\n+\tw.Close()\n+\n+\tif g, e := b.String(), \"7\\r\\nhello, \\r\\n17\\r\\nworld! 0123456789abcdef\\r\\n0\\r\\n\"; g != e {\n+\t\tt.Fatalf(\"chunk writer wrote %q; want %q\", g, e)\n+\t}\n+\n+\tr := newChunkedReader(&b)\n+\tdata, err := ioutil.ReadAll(r)\n+\tif err != nil {\n+\t\tt.Logf(`data: \"%s\"`, data)\n+\t\tt.Fatalf(\"ReadAll from reader: %v\", err)\n+\t}\n+\tif g, e := string(data), chunk1+chunk2; g != e {\n+\t\tt.Errorf(\"chunk reader read %q; want %q\", g, e)\n+\t}\n+}"}, {"sha": "57a9dd9574d1a6c201ed635a22c26a460196d038", "filename": "libgo/go/net/http/client_test.go", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fclient_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -26,14 +26,39 @@ var robotsTxtHandler = HandlerFunc(func(w ResponseWriter, r *Request) {\n \tfmt.Fprintf(w, \"User-agent: go\\nDisallow: /something/\")\n })\n \n+// pedanticReadAll works like ioutil.ReadAll but additionally\n+// verifies that r obeys the documented io.Reader contract.\n+func pedanticReadAll(r io.Reader) (b []byte, err error) {\n+\tvar bufa [64]byte\n+\tbuf := bufa[:]\n+\tfor {\n+\t\tn, err := r.Read(buf)\n+\t\tif n == 0 && err == nil {\n+\t\t\treturn nil, fmt.Errorf(\"Read: n=0 with err=nil\")\n+\t\t}\n+\t\tb = append(b, buf[:n]...)\n+\t\tif err == io.EOF {\n+\t\t\tn, err := r.Read(buf)\n+\t\t\tif n != 0 || err != io.EOF {\n+\t\t\t\treturn nil, fmt.Errorf(\"Read: n=%d err=%#v after EOF\", n, err)\n+\t\t\t}\n+\t\t\treturn b, nil\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn b, err\n+\t\t}\n+\t}\n+\tpanic(\"unreachable\")\n+}\n+\n func TestClient(t *testing.T) {\n \tts := httptest.NewServer(robotsTxtHandler)\n \tdefer ts.Close()\n \n \tr, err := Get(ts.URL)\n \tvar b []byte\n \tif err == nil {\n-\t\tb, err = ioutil.ReadAll(r.Body)\n+\t\tb, err = pedanticReadAll(r.Body)\n \t\tr.Body.Close()\n \t}\n \tif err != nil {"}, {"sha": "529440cbe92a0d7a644e93cdefb9215fb8aba7aa", "filename": "libgo/go/net/http/fcgi/child.go", "status": "modified", "additions": 78, "deletions": 65, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Fchild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Fchild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Fchild.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -7,6 +7,7 @@ package fcgi\n // This file implements FastCGI from the perspective of a child process.\n \n import (\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"net\"\n@@ -123,89 +124,101 @@ func (r *response) Close() error {\n }\n \n type child struct {\n-\tconn    *conn\n-\thandler http.Handler\n+\tconn     *conn\n+\thandler  http.Handler\n+\trequests map[uint16]*request // keyed by request ID\n }\n \n-func newChild(rwc net.Conn, handler http.Handler) *child {\n-\treturn &child{newConn(rwc), handler}\n+func newChild(rwc io.ReadWriteCloser, handler http.Handler) *child {\n+\treturn &child{\n+\t\tconn:     newConn(rwc),\n+\t\thandler:  handler,\n+\t\trequests: make(map[uint16]*request),\n+\t}\n }\n \n func (c *child) serve() {\n-\trequests := map[uint16]*request{}\n \tdefer c.conn.Close()\n \tvar rec record\n-\tvar br beginRequest\n \tfor {\n \t\tif err := rec.read(c.conn.rwc); err != nil {\n \t\t\treturn\n \t\t}\n-\n-\t\treq, ok := requests[rec.h.Id]\n-\t\tif !ok && rec.h.Type != typeBeginRequest && rec.h.Type != typeGetValues {\n-\t\t\t// The spec says to ignore unknown request IDs.\n-\t\t\tcontinue\n-\t\t}\n-\t\tif ok && rec.h.Type == typeBeginRequest {\n-\t\t\t// The server is trying to begin a request with the same ID\n-\t\t\t// as an in-progress request. This is an error.\n+\t\tif err := c.handleRecord(&rec); err != nil {\n \t\t\treturn\n \t\t}\n+\t}\n+}\n \n-\t\tswitch rec.h.Type {\n-\t\tcase typeBeginRequest:\n-\t\t\tif err := br.read(rec.content()); err != nil {\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tif br.role != roleResponder {\n-\t\t\t\tc.conn.writeEndRequest(rec.h.Id, 0, statusUnknownRole)\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\trequests[rec.h.Id] = newRequest(rec.h.Id, br.flags)\n-\t\tcase typeParams:\n-\t\t\t// NOTE(eds): Technically a key-value pair can straddle the boundary\n-\t\t\t// between two packets. We buffer until we've received all parameters.\n-\t\t\tif len(rec.content()) > 0 {\n-\t\t\t\treq.rawParams = append(req.rawParams, rec.content()...)\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\treq.parseParams()\n-\t\tcase typeStdin:\n-\t\t\tcontent := rec.content()\n-\t\t\tif req.pw == nil {\n-\t\t\t\tvar body io.ReadCloser\n-\t\t\t\tif len(content) > 0 {\n-\t\t\t\t\t// body could be an io.LimitReader, but it shouldn't matter\n-\t\t\t\t\t// as long as both sides are behaving.\n-\t\t\t\t\tbody, req.pw = io.Pipe()\n-\t\t\t\t}\n-\t\t\t\tgo c.serveRequest(req, body)\n-\t\t\t}\n+var errCloseConn = errors.New(\"fcgi: connection should be closed\")\n+\n+func (c *child) handleRecord(rec *record) error {\n+\treq, ok := c.requests[rec.h.Id]\n+\tif !ok && rec.h.Type != typeBeginRequest && rec.h.Type != typeGetValues {\n+\t\t// The spec says to ignore unknown request IDs.\n+\t\treturn nil\n+\t}\n+\tif ok && rec.h.Type == typeBeginRequest {\n+\t\t// The server is trying to begin a request with the same ID\n+\t\t// as an in-progress request. This is an error.\n+\t\treturn errors.New(\"fcgi: received ID that is already in-flight\")\n+\t}\n+\n+\tswitch rec.h.Type {\n+\tcase typeBeginRequest:\n+\t\tvar br beginRequest\n+\t\tif err := br.read(rec.content()); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif br.role != roleResponder {\n+\t\t\tc.conn.writeEndRequest(rec.h.Id, 0, statusUnknownRole)\n+\t\t\treturn nil\n+\t\t}\n+\t\tc.requests[rec.h.Id] = newRequest(rec.h.Id, br.flags)\n+\tcase typeParams:\n+\t\t// NOTE(eds): Technically a key-value pair can straddle the boundary\n+\t\t// between two packets. We buffer until we've received all parameters.\n+\t\tif len(rec.content()) > 0 {\n+\t\t\treq.rawParams = append(req.rawParams, rec.content()...)\n+\t\t\treturn nil\n+\t\t}\n+\t\treq.parseParams()\n+\tcase typeStdin:\n+\t\tcontent := rec.content()\n+\t\tif req.pw == nil {\n+\t\t\tvar body io.ReadCloser\n \t\t\tif len(content) > 0 {\n-\t\t\t\t// TODO(eds): This blocks until the handler reads from the pipe.\n-\t\t\t\t// If the handler takes a long time, it might be a problem.\n-\t\t\t\treq.pw.Write(content)\n-\t\t\t} else if req.pw != nil {\n-\t\t\t\treq.pw.Close()\n-\t\t\t}\n-\t\tcase typeGetValues:\n-\t\t\tvalues := map[string]string{\"FCGI_MPXS_CONNS\": \"1\"}\n-\t\t\tc.conn.writePairs(0, typeGetValuesResult, values)\n-\t\tcase typeData:\n-\t\t\t// If the filter role is implemented, read the data stream here.\n-\t\tcase typeAbortRequest:\n-\t\t\tdelete(requests, rec.h.Id)\n-\t\t\tc.conn.writeEndRequest(rec.h.Id, 0, statusRequestComplete)\n-\t\t\tif !req.keepConn {\n-\t\t\t\t// connection will close upon return\n-\t\t\t\treturn\n+\t\t\t\t// body could be an io.LimitReader, but it shouldn't matter\n+\t\t\t\t// as long as both sides are behaving.\n+\t\t\t\tbody, req.pw = io.Pipe()\n \t\t\t}\n-\t\tdefault:\n-\t\t\tb := make([]byte, 8)\n-\t\t\tb[0] = rec.h.Type\n-\t\t\tc.conn.writeRecord(typeUnknownType, 0, b)\n+\t\t\tgo c.serveRequest(req, body)\n+\t\t}\n+\t\tif len(content) > 0 {\n+\t\t\t// TODO(eds): This blocks until the handler reads from the pipe.\n+\t\t\t// If the handler takes a long time, it might be a problem.\n+\t\t\treq.pw.Write(content)\n+\t\t} else if req.pw != nil {\n+\t\t\treq.pw.Close()\n+\t\t}\n+\tcase typeGetValues:\n+\t\tvalues := map[string]string{\"FCGI_MPXS_CONNS\": \"1\"}\n+\t\tc.conn.writePairs(typeGetValuesResult, 0, values)\n+\tcase typeData:\n+\t\t// If the filter role is implemented, read the data stream here.\n+\tcase typeAbortRequest:\n+\t\tdelete(c.requests, rec.h.Id)\n+\t\tc.conn.writeEndRequest(rec.h.Id, 0, statusRequestComplete)\n+\t\tif !req.keepConn {\n+\t\t\t// connection will close upon return\n+\t\t\treturn errCloseConn\n \t\t}\n+\tdefault:\n+\t\tb := make([]byte, 8)\n+\t\tb[0] = byte(rec.h.Type)\n+\t\tc.conn.writeRecord(typeUnknownType, 0, b)\n \t}\n+\treturn nil\n }\n \n func (c *child) serveRequest(req *request, body io.ReadCloser) {"}, {"sha": "d35aa84d229aab920addb06265aa9768f43b1c1d", "filename": "libgo/go/net/http/fcgi/fcgi.go", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Ffcgi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Ffcgi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Ffcgi.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -19,19 +19,22 @@ import (\n \t\"sync\"\n )\n \n+// recType is a record type, as defined by\n+// http://www.fastcgi.com/devkit/doc/fcgi-spec.html#S8\n+type recType uint8\n+\n const (\n-\t// Packet Types\n-\ttypeBeginRequest = iota + 1\n-\ttypeAbortRequest\n-\ttypeEndRequest\n-\ttypeParams\n-\ttypeStdin\n-\ttypeStdout\n-\ttypeStderr\n-\ttypeData\n-\ttypeGetValues\n-\ttypeGetValuesResult\n-\ttypeUnknownType\n+\ttypeBeginRequest    recType = 1\n+\ttypeAbortRequest    recType = 2\n+\ttypeEndRequest      recType = 3\n+\ttypeParams          recType = 4\n+\ttypeStdin           recType = 5\n+\ttypeStdout          recType = 6\n+\ttypeStderr          recType = 7\n+\ttypeData            recType = 8\n+\ttypeGetValues       recType = 9\n+\ttypeGetValuesResult recType = 10\n+\ttypeUnknownType     recType = 11\n )\n \n // keep the connection between web-server and responder open after request\n@@ -59,7 +62,7 @@ const headerLen = 8\n \n type header struct {\n \tVersion       uint8\n-\tType          uint8\n+\tType          recType\n \tId            uint16\n \tContentLength uint16\n \tPaddingLength uint8\n@@ -85,7 +88,7 @@ func (br *beginRequest) read(content []byte) error {\n // not synchronized because we don't care what the contents are\n var pad [maxPad]byte\n \n-func (h *header) init(recType uint8, reqId uint16, contentLength int) {\n+func (h *header) init(recType recType, reqId uint16, contentLength int) {\n \th.Version = 1\n \th.Type = recType\n \th.Id = reqId\n@@ -137,7 +140,7 @@ func (r *record) content() []byte {\n }\n \n // writeRecord writes and sends a single record.\n-func (c *conn) writeRecord(recType uint8, reqId uint16, b []byte) error {\n+func (c *conn) writeRecord(recType recType, reqId uint16, b []byte) error {\n \tc.mutex.Lock()\n \tdefer c.mutex.Unlock()\n \tc.buf.Reset()\n@@ -167,12 +170,12 @@ func (c *conn) writeEndRequest(reqId uint16, appStatus int, protocolStatus uint8\n \treturn c.writeRecord(typeEndRequest, reqId, b)\n }\n \n-func (c *conn) writePairs(recType uint8, reqId uint16, pairs map[string]string) error {\n+func (c *conn) writePairs(recType recType, reqId uint16, pairs map[string]string) error {\n \tw := newWriter(c, recType, reqId)\n \tb := make([]byte, 8)\n \tfor k, v := range pairs {\n \t\tn := encodeSize(b, uint32(len(k)))\n-\t\tn += encodeSize(b[n:], uint32(len(k)))\n+\t\tn += encodeSize(b[n:], uint32(len(v)))\n \t\tif _, err := w.Write(b[:n]); err != nil {\n \t\t\treturn err\n \t\t}\n@@ -235,7 +238,7 @@ func (w *bufWriter) Close() error {\n \treturn w.closer.Close()\n }\n \n-func newWriter(c *conn, recType uint8, reqId uint16) *bufWriter {\n+func newWriter(c *conn, recType recType, reqId uint16) *bufWriter {\n \ts := &streamWriter{c: c, recType: recType, reqId: reqId}\n \tw, _ := bufio.NewWriterSize(s, maxWrite)\n \treturn &bufWriter{s, w}\n@@ -245,7 +248,7 @@ func newWriter(c *conn, recType uint8, reqId uint16) *bufWriter {\n // It only writes maxWrite bytes at a time.\n type streamWriter struct {\n \tc       *conn\n-\trecType uint8\n+\trecType recType\n \treqId   uint16\n }\n "}, {"sha": "6c7e1a9ce831ff428aa19605e42f74d554a12361", "filename": "libgo/go/net/http/fcgi/fcgi_test.go", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Ffcgi_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Ffcgi_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffcgi%2Ffcgi_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -6,6 +6,7 @@ package fcgi\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"io\"\n \t\"testing\"\n )\n@@ -40,25 +41,25 @@ func TestSize(t *testing.T) {\n \n var streamTests = []struct {\n \tdesc    string\n-\trecType uint8\n+\trecType recType\n \treqId   uint16\n \tcontent []byte\n \traw     []byte\n }{\n \t{\"single record\", typeStdout, 1, nil,\n-\t\t[]byte{1, typeStdout, 0, 1, 0, 0, 0, 0},\n+\t\t[]byte{1, byte(typeStdout), 0, 1, 0, 0, 0, 0},\n \t},\n \t// this data will have to be split into two records\n \t{\"two records\", typeStdin, 300, make([]byte, 66000),\n \t\tbytes.Join([][]byte{\n \t\t\t// header for the first record\n-\t\t\t{1, typeStdin, 0x01, 0x2C, 0xFF, 0xFF, 1, 0},\n+\t\t\t{1, byte(typeStdin), 0x01, 0x2C, 0xFF, 0xFF, 1, 0},\n \t\t\tmake([]byte, 65536),\n \t\t\t// header for the second\n-\t\t\t{1, typeStdin, 0x01, 0x2C, 0x01, 0xD1, 7, 0},\n+\t\t\t{1, byte(typeStdin), 0x01, 0x2C, 0x01, 0xD1, 7, 0},\n \t\t\tmake([]byte, 472),\n \t\t\t// header for the empty record\n-\t\t\t{1, typeStdin, 0x01, 0x2C, 0, 0, 0, 0},\n+\t\t\t{1, byte(typeStdin), 0x01, 0x2C, 0, 0, 0, 0},\n \t\t},\n \t\t\tnil),\n \t},\n@@ -111,3 +112,39 @@ outer:\n \t\t}\n \t}\n }\n+\n+type writeOnlyConn struct {\n+\tbuf []byte\n+}\n+\n+func (c *writeOnlyConn) Write(p []byte) (int, error) {\n+\tc.buf = append(c.buf, p...)\n+\treturn len(p), nil\n+}\n+\n+func (c *writeOnlyConn) Read(p []byte) (int, error) {\n+\treturn 0, errors.New(\"conn is write-only\")\n+}\n+\n+func (c *writeOnlyConn) Close() error {\n+\treturn nil\n+}\n+\n+func TestGetValues(t *testing.T) {\n+\tvar rec record\n+\trec.h.Type = typeGetValues\n+\n+\twc := new(writeOnlyConn)\n+\tc := newChild(wc, nil)\n+\terr := c.handleRecord(&rec)\n+\tif err != nil {\n+\t\tt.Fatalf(\"handleRecord: %v\", err)\n+\t}\n+\n+\tconst want = \"\\x01\\n\\x00\\x00\\x00\\x12\\x06\\x00\" +\n+\t\t\"\\x0f\\x01FCGI_MPXS_CONNS1\" +\n+\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\n\\x00\\x00\\x00\\x00\\x00\\x00\"\n+\tif got := string(wc.buf); got != want {\n+\t\tt.Errorf(\" got: %q\\nwant: %q\\n\", got, want)\n+\t}\n+}"}, {"sha": "5aadac17a23535401049e52dda1e705a300aac33", "filename": "libgo/go/net/http/fs.go", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Ffs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Ffs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffs.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -22,13 +22,19 @@ import (\n \n // A Dir implements http.FileSystem using the native file\n // system restricted to a specific directory tree.\n+//\n+// An empty Dir is treated as \".\".\n type Dir string\n \n func (d Dir) Open(name string) (File, error) {\n \tif filepath.Separator != '/' && strings.IndexRune(name, filepath.Separator) >= 0 {\n \t\treturn nil, errors.New(\"http: invalid character in file path\")\n \t}\n-\tf, err := os.Open(filepath.Join(string(d), filepath.FromSlash(path.Clean(\"/\"+name))))\n+\tdir := string(d)\n+\tif dir == \"\" {\n+\t\tdir = \".\"\n+\t}\n+\tf, err := os.Open(filepath.Join(dir, filepath.FromSlash(path.Clean(\"/\"+name))))\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "6697189900ed947ddc943ede45420e289057ba97", "filename": "libgo/go/net/http/fs_test.go", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ffs_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -208,6 +208,20 @@ func TestDirJoin(t *testing.T) {\n \ttest(Dir(\"/etc/hosts\"), \"../\")\n }\n \n+func TestEmptyDirOpenCWD(t *testing.T) {\n+\ttest := func(d Dir) {\n+\t\tname := \"fs_test.go\"\n+\t\tf, err := d.Open(name)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"open of %s: %v\", name, err)\n+\t\t}\n+\t\tdefer f.Close()\n+\t}\n+\ttest(Dir(\"\"))\n+\ttest(Dir(\".\"))\n+\ttest(Dir(\"./\"))\n+}\n+\n func TestServeFileContentType(t *testing.T) {\n \tconst ctype = \"icecream/chocolate\"\n \toverride := false\n@@ -247,6 +261,20 @@ func TestServeFileMimeType(t *testing.T) {\n \t}\n }\n \n+func TestServeFileFromCWD(t *testing.T) {\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tServeFile(w, r, \"fs_test.go\")\n+\t}))\n+\tdefer ts.Close()\n+\tr, err := Get(ts.URL)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif r.StatusCode != 200 {\n+\t\tt.Fatalf(\"expected 200 OK, got %s\", r.Status)\n+\t}\n+}\n+\n func TestServeFileWithContentEncoding(t *testing.T) {\n \tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n \t\tw.Header().Set(\"Content-Encoding\", \"foo\")"}, {"sha": "69bcc0e816fdbd5432f891a47f4131d2fe79edda", "filename": "libgo/go/net/http/httputil/chunked.go", "status": "modified", "additions": 114, "deletions": 26, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fchunked.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fchunked.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fchunked.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -2,18 +2,126 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// The wire protocol for HTTP's \"chunked\" Transfer-Encoding.\n+\n+// This code is a duplicate of ../chunked.go with these edits:\n+//\ts/newChunked/NewChunked/g\n+//\ts/package http/package httputil/\n+// Please make any changes in both files.\n+\n package httputil\n \n import (\n \t\"bufio\"\n+\t\"bytes\"\n+\t\"errors\"\n \t\"io\"\n-\t\"net/http\"\n \t\"strconv\"\n-\t\"strings\"\n )\n \n-// NewChunkedWriter returns a new writer that translates writes into HTTP\n-// \"chunked\" format before writing them to w. Closing the returned writer\n+const maxLineLength = 4096 // assumed <= bufio.defaultBufSize\n+\n+var ErrLineTooLong = errors.New(\"header line too long\")\n+\n+// NewChunkedReader returns a new chunkedReader that translates the data read from r\n+// out of HTTP \"chunked\" format before returning it. \n+// The chunkedReader returns io.EOF when the final 0-length chunk is read.\n+//\n+// NewChunkedReader is not needed by normal applications. The http package\n+// automatically decodes chunking when reading response bodies.\n+func NewChunkedReader(r io.Reader) io.Reader {\n+\tbr, ok := r.(*bufio.Reader)\n+\tif !ok {\n+\t\tbr = bufio.NewReader(r)\n+\t}\n+\treturn &chunkedReader{r: br}\n+}\n+\n+type chunkedReader struct {\n+\tr   *bufio.Reader\n+\tn   uint64 // unread bytes in chunk\n+\terr error\n+}\n+\n+func (cr *chunkedReader) beginChunk() {\n+\t// chunk-size CRLF\n+\tvar line string\n+\tline, cr.err = readLine(cr.r)\n+\tif cr.err != nil {\n+\t\treturn\n+\t}\n+\tcr.n, cr.err = strconv.Btoui64(line, 16)\n+\tif cr.err != nil {\n+\t\treturn\n+\t}\n+\tif cr.n == 0 {\n+\t\tcr.err = io.EOF\n+\t}\n+}\n+\n+func (cr *chunkedReader) Read(b []uint8) (n int, err error) {\n+\tif cr.err != nil {\n+\t\treturn 0, cr.err\n+\t}\n+\tif cr.n == 0 {\n+\t\tcr.beginChunk()\n+\t\tif cr.err != nil {\n+\t\t\treturn 0, cr.err\n+\t\t}\n+\t}\n+\tif uint64(len(b)) > cr.n {\n+\t\tb = b[0:cr.n]\n+\t}\n+\tn, cr.err = cr.r.Read(b)\n+\tcr.n -= uint64(n)\n+\tif cr.n == 0 && cr.err == nil {\n+\t\t// end of chunk (CRLF)\n+\t\tb := make([]byte, 2)\n+\t\tif _, cr.err = io.ReadFull(cr.r, b); cr.err == nil {\n+\t\t\tif b[0] != '\\r' || b[1] != '\\n' {\n+\t\t\t\tcr.err = errors.New(\"malformed chunked encoding\")\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn n, cr.err\n+}\n+\n+// Read a line of bytes (up to \\n) from b.\n+// Give up if the line exceeds maxLineLength.\n+// The returned bytes are a pointer into storage in\n+// the bufio, so they are only valid until the next bufio read.\n+func readLineBytes(b *bufio.Reader) (p []byte, err error) {\n+\tif p, err = b.ReadSlice('\\n'); err != nil {\n+\t\t// We always know when EOF is coming.\n+\t\t// If the caller asked for a line, there should be a line.\n+\t\tif err == io.EOF {\n+\t\t\terr = io.ErrUnexpectedEOF\n+\t\t} else if err == bufio.ErrBufferFull {\n+\t\t\terr = ErrLineTooLong\n+\t\t}\n+\t\treturn nil, err\n+\t}\n+\tif len(p) >= maxLineLength {\n+\t\treturn nil, ErrLineTooLong\n+\t}\n+\n+\t// Chop off trailing white space.\n+\tp = bytes.TrimRight(p, \" \\r\\t\\n\")\n+\n+\treturn p, nil\n+}\n+\n+// readLineBytes, but convert the bytes into a string.\n+func readLine(b *bufio.Reader) (s string, err error) {\n+\tp, e := readLineBytes(b)\n+\tif e != nil {\n+\t\treturn \"\", e\n+\t}\n+\treturn string(p), nil\n+}\n+\n+// NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP\n+// \"chunked\" format before writing them to w. Closing the returned chunkedWriter\n // sends the final 0-length chunk that marks the end of the stream.\n //\n // NewChunkedWriter is not needed by normal applications. The http\n@@ -25,8 +133,8 @@ func NewChunkedWriter(w io.Writer) io.WriteCloser {\n \treturn &chunkedWriter{w}\n }\n \n-// Writing to ChunkedWriter translates to writing in HTTP chunked Transfer\n-// Encoding wire format to the underlying Wire writer.\n+// Writing to chunkedWriter translates to writing in HTTP chunked Transfer\n+// Encoding wire format to the underlying Wire chunkedWriter.\n type chunkedWriter struct {\n \tWire io.Writer\n }\n@@ -62,23 +170,3 @@ func (cw *chunkedWriter) Close() error {\n \t_, err := io.WriteString(cw.Wire, \"0\\r\\n\")\n \treturn err\n }\n-\n-// NewChunkedReader returns a new reader that translates the data read from r\n-// out of HTTP \"chunked\" format before returning it. \n-// The reader returns io.EOF when the final 0-length chunk is read.\n-//\n-// NewChunkedReader is not needed by normal applications. The http package\n-// automatically decodes chunking when reading response bodies.\n-func NewChunkedReader(r io.Reader) io.Reader {\n-\t// This is a bit of a hack so we don't have to copy chunkedReader into\n-\t// httputil.  It's a bit more complex than chunkedWriter, which is copied\n-\t// above.\n-\treq, err := http.ReadRequest(bufio.NewReader(io.MultiReader(\n-\t\tstrings.NewReader(\"POST / HTTP/1.1\\r\\nTransfer-Encoding: chunked\\r\\n\\r\\n\"),\n-\t\tr,\n-\t\tstrings.NewReader(\"\\r\\n\"))))\n-\tif err != nil {\n-\t\tpanic(\"bad fake request: \" + err.Error())\n-\t}\n-\treturn req.Body\n-}"}, {"sha": "155a32bdf9a2aca3a371e503699cd5f5165ac186", "filename": "libgo/go/net/http/httputil/chunked_test.go", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fchunked_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fchunked_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fchunked_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -2,6 +2,11 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n+// This code is a duplicate of ../chunked_test.go with these edits:\n+//\ts/newChunked/NewChunked/g\n+//\ts/package http/package httputil/\n+// Please make any changes in both files.\n+\n package httputil\n \n import (\n@@ -27,7 +32,8 @@ func TestChunk(t *testing.T) {\n \tr := NewChunkedReader(&b)\n \tdata, err := ioutil.ReadAll(r)\n \tif err != nil {\n-\t\tt.Fatalf(\"ReadAll from NewChunkedReader: %v\", err)\n+\t\tt.Logf(`data: \"%s\"`, data)\n+\t\tt.Fatalf(\"ReadAll from reader: %v\", err)\n \t}\n \tif g, e := string(data), chunk1+chunk2; g != e {\n \t\tt.Errorf(\"chunk reader read %q; want %q\", g, e)"}, {"sha": "1266bd3ad22eb98414956543c5211b8cfacd234c", "filename": "libgo/go/net/http/httputil/persist.go", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fpersist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fpersist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fhttputil%2Fpersist.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -22,6 +22,10 @@ var (\n \tErrPipeline   = &http.ProtocolError{\"pipeline error\"}\n )\n \n+// This is an API usage error - the local side is closed.\n+// ErrPersistEOF (above) reports that the remote side is closed.\n+var errClosed = errors.New(\"i/o operation on closed connection\")\n+\n // A ServerConn reads requests and sends responses over an underlying\n // connection, until the HTTP keepalive logic commands an end. ServerConn\n // also allows hijacking the underlying connection by calling Hijack\n@@ -108,7 +112,7 @@ func (sc *ServerConn) Read() (req *http.Request, err error) {\n \t}\n \tif sc.r == nil { // connection closed by user in the meantime\n \t\tdefer sc.lk.Unlock()\n-\t\treturn nil, os.EBADF\n+\t\treturn nil, errClosed\n \t}\n \tr := sc.r\n \tlastbody := sc.lastbody\n@@ -313,7 +317,7 @@ func (cc *ClientConn) Write(req *http.Request) (err error) {\n \t}\n \tif cc.c == nil { // connection closed by user in the meantime\n \t\tdefer cc.lk.Unlock()\n-\t\treturn os.EBADF\n+\t\treturn errClosed\n \t}\n \tc := cc.c\n \tif req.Close {\n@@ -369,7 +373,7 @@ func (cc *ClientConn) Read(req *http.Request) (resp *http.Response, err error) {\n \t}\n \tif cc.r == nil { // connection closed by user in the meantime\n \t\tdefer cc.lk.Unlock()\n-\t\treturn nil, os.EBADF\n+\t\treturn nil, errClosed\n \t}\n \tr := cc.r\n \tlastbody := cc.lastbody"}, {"sha": "c64fff6109f2270564b11878fce42505d09129f2", "filename": "libgo/go/net/http/readrequest_test.go", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Freadrequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Freadrequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Freadrequest_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -70,7 +70,6 @@ var reqTests = []reqTest{\n \t\t\tClose:         false,\n \t\t\tContentLength: 7,\n \t\t\tHost:          \"www.techcrunch.com\",\n-\t\t\tForm:          url.Values{},\n \t\t},\n \n \t\t\"abcdef\\n\",\n@@ -94,10 +93,10 @@ var reqTests = []reqTest{\n \t\t\tProto:         \"HTTP/1.1\",\n \t\t\tProtoMajor:    1,\n \t\t\tProtoMinor:    1,\n+\t\t\tHeader:        Header{},\n \t\t\tClose:         false,\n \t\t\tContentLength: 0,\n \t\t\tHost:          \"foo.com\",\n-\t\t\tForm:          url.Values{},\n \t\t},\n \n \t\tnoBody,\n@@ -131,7 +130,6 @@ var reqTests = []reqTest{\n \t\t\tClose:         false,\n \t\t\tContentLength: 0,\n \t\t\tHost:          \"test\",\n-\t\t\tForm:          url.Values{},\n \t\t},\n \n \t\tnoBody,\n@@ -180,9 +178,9 @@ var reqTests = []reqTest{\n \t\t\tProto:            \"HTTP/1.1\",\n \t\t\tProtoMajor:       1,\n \t\t\tProtoMinor:       1,\n+\t\t\tHeader:           Header{},\n \t\t\tContentLength:    -1,\n \t\t\tHost:             \"foo.com\",\n-\t\t\tForm:             url.Values{},\n \t\t},\n \n \t\t\"foobar\","}, {"sha": "66178490e37b80dfb8e427ab30eafe39b2539d91", "filename": "libgo/go/net/http/request.go", "status": "modified", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -19,12 +19,10 @@ import (\n \t\"mime/multipart\"\n \t\"net/textproto\"\n \t\"net/url\"\n-\t\"strconv\"\n \t\"strings\"\n )\n \n const (\n-\tmaxLineLength    = 4096 // assumed <= bufio.defaultBufSize\n \tmaxValueLength   = 4096\n \tmaxHeaderLines   = 1024\n \tchunkSize        = 4 << 10  // 4 KB chunks\n@@ -43,7 +41,6 @@ type ProtocolError struct {\n func (err *ProtocolError) Error() string { return err.ErrorString }\n \n var (\n-\tErrLineTooLong          = &ProtocolError{\"header line too long\"}\n \tErrHeaderTooLong        = &ProtocolError{\"header too long\"}\n \tErrShortBody            = &ProtocolError{\"entity body too short\"}\n \tErrNotSupported         = &ProtocolError{\"feature not supported\"}\n@@ -375,44 +372,6 @@ func (req *Request) write(w io.Writer, usingProxy bool, extraHeaders Header) err\n \treturn nil\n }\n \n-// Read a line of bytes (up to \\n) from b.\n-// Give up if the line exceeds maxLineLength.\n-// The returned bytes are a pointer into storage in\n-// the bufio, so they are only valid until the next bufio read.\n-func readLineBytes(b *bufio.Reader) (p []byte, err error) {\n-\tif p, err = b.ReadSlice('\\n'); err != nil {\n-\t\t// We always know when EOF is coming.\n-\t\t// If the caller asked for a line, there should be a line.\n-\t\tif err == io.EOF {\n-\t\t\terr = io.ErrUnexpectedEOF\n-\t\t} else if err == bufio.ErrBufferFull {\n-\t\t\terr = ErrLineTooLong\n-\t\t}\n-\t\treturn nil, err\n-\t}\n-\tif len(p) >= maxLineLength {\n-\t\treturn nil, ErrLineTooLong\n-\t}\n-\n-\t// Chop off trailing white space.\n-\tvar i int\n-\tfor i = len(p); i > 0; i-- {\n-\t\tif c := p[i-1]; c != ' ' && c != '\\r' && c != '\\t' && c != '\\n' {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\treturn p[0:i], nil\n-}\n-\n-// readLineBytes, but convert the bytes into a string.\n-func readLine(b *bufio.Reader) (s string, err error) {\n-\tp, e := readLineBytes(b)\n-\tif e != nil {\n-\t\treturn \"\", e\n-\t}\n-\treturn string(p), nil\n-}\n-\n // Convert decimal at s[i:len(s)] to integer,\n // returning value, string position where the digits stopped,\n // and whether there was a valid number (digits, not too big).\n@@ -448,55 +407,6 @@ func ParseHTTPVersion(vers string) (major, minor int, ok bool) {\n \treturn major, minor, true\n }\n \n-type chunkedReader struct {\n-\tr   *bufio.Reader\n-\tn   uint64 // unread bytes in chunk\n-\terr error\n-}\n-\n-func (cr *chunkedReader) beginChunk() {\n-\t// chunk-size CRLF\n-\tvar line string\n-\tline, cr.err = readLine(cr.r)\n-\tif cr.err != nil {\n-\t\treturn\n-\t}\n-\tcr.n, cr.err = strconv.Btoui64(line, 16)\n-\tif cr.err != nil {\n-\t\treturn\n-\t}\n-\tif cr.n == 0 {\n-\t\tcr.err = io.EOF\n-\t}\n-}\n-\n-func (cr *chunkedReader) Read(b []uint8) (n int, err error) {\n-\tif cr.err != nil {\n-\t\treturn 0, cr.err\n-\t}\n-\tif cr.n == 0 {\n-\t\tcr.beginChunk()\n-\t\tif cr.err != nil {\n-\t\t\treturn 0, cr.err\n-\t\t}\n-\t}\n-\tif uint64(len(b)) > cr.n {\n-\t\tb = b[0:cr.n]\n-\t}\n-\tn, cr.err = cr.r.Read(b)\n-\tcr.n -= uint64(n)\n-\tif cr.n == 0 && cr.err == nil {\n-\t\t// end of chunk (CRLF)\n-\t\tb := make([]byte, 2)\n-\t\tif _, cr.err = io.ReadFull(cr.r, b); cr.err == nil {\n-\t\t\tif b[0] != '\\r' || b[1] != '\\n' {\n-\t\t\t\tcr.err = errors.New(\"malformed chunked encoding\")\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn n, cr.err\n-}\n-\n // NewRequest returns a new Request given a method, URL, and optional body.\n func NewRequest(method, urlStr string, body io.Reader) (*Request, error) {\n \tu, err := url.Parse(urlStr)"}, {"sha": "e5d01698e5504bdd1949bc1758661be6a4eeae48", "filename": "libgo/go/net/http/response_test.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fresponse_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -65,6 +65,7 @@ var respTests = []respTest{\n \t\t\tProto:         \"HTTP/1.1\",\n \t\t\tProtoMajor:    1,\n \t\t\tProtoMinor:    1,\n+\t\t\tHeader:        Header{},\n \t\t\tRequest:       dummyReq(\"GET\"),\n \t\t\tClose:         true,\n \t\t\tContentLength: -1,\n@@ -85,6 +86,7 @@ var respTests = []respTest{\n \t\t\tProto:         \"HTTP/1.1\",\n \t\t\tProtoMajor:    1,\n \t\t\tProtoMinor:    1,\n+\t\t\tHeader:        Header{},\n \t\t\tRequest:       dummyReq(\"GET\"),\n \t\t\tClose:         false,\n \t\t\tContentLength: 0,\n@@ -315,7 +317,7 @@ func TestReadResponseCloseInMiddle(t *testing.T) {\n \t\t}\n \t\tvar wr io.Writer = &buf\n \t\tif test.chunked {\n-\t\t\twr = &chunkedWriter{wr}\n+\t\t\twr = newChunkedWriter(wr)\n \t\t}\n \t\tif test.compressed {\n \t\t\tbuf.WriteString(\"Content-Encoding: gzip\\r\\n\")"}, {"sha": "97a0b139e392796aa9e03b8f725156905221e856", "filename": "libgo/go/net/http/serve_test.go", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserve_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -1077,6 +1077,31 @@ func TestClientWriteShutdown(t *testing.T) {\n \t}\n }\n \n+// Tests that chunked server responses that write 1 byte at a time are\n+// buffered before chunk headers are added, not after chunk headers.\n+func TestServerBufferedChunking(t *testing.T) {\n+\tif true {\n+\t\tt.Logf(\"Skipping known broken test; see Issue 2357\")\n+\t\treturn\n+\t}\n+\tconn := new(testConn)\n+\tconn.readBuf.Write([]byte(\"GET / HTTP/1.1\\r\\n\\r\\n\"))\n+\tdone := make(chan bool)\n+\tls := &oneConnListener{conn}\n+\tgo Serve(ls, HandlerFunc(func(rw ResponseWriter, req *Request) {\n+\t\tdefer close(done)\n+\t\trw.Header().Set(\"Content-Type\", \"text/plain\") // prevent sniffing, which buffers\n+\t\trw.Write([]byte{'x'})\n+\t\trw.Write([]byte{'y'})\n+\t\trw.Write([]byte{'z'})\n+\t}))\n+\t<-done\n+\tif !bytes.HasSuffix(conn.writeBuf.Bytes(), []byte(\"\\r\\n\\r\\n3\\r\\nxyz\\r\\n0\\r\\n\\r\\n\")) {\n+\t\tt.Errorf(\"response didn't end with a single 3 byte 'xyz' chunk; got:\\n%q\",\n+\t\t\tconn.writeBuf.Bytes())\n+\t}\n+}\n+\n // goTimeout runs f, failing t if f takes more than ns to complete.\n func goTimeout(t *testing.T, ns int64, f func()) {\n \tch := make(chan bool, 2)\n@@ -1120,7 +1145,7 @@ func TestAcceptMaxFds(t *testing.T) {\n \tln := &errorListener{[]error{\n \t\t&net.OpError{\n \t\t\tOp:  \"accept\",\n-\t\t\tErr: os.Errno(syscall.EMFILE),\n+\t\t\tErr: syscall.EMFILE,\n \t\t}}}\n \terr := Serve(ln, HandlerFunc(HandlerFunc(func(ResponseWriter, *Request) {})))\n \tif err != io.EOF {"}, {"sha": "7221d2508bb4e4856e8f61080160190fbf295f5e", "filename": "libgo/go/net/http/server.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fserver.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -149,11 +149,13 @@ type writerOnly struct {\n }\n \n func (w *response) ReadFrom(src io.Reader) (n int64, err error) {\n-\t// Flush before checking w.chunking, as Flush will call\n-\t// WriteHeader if it hasn't been called yet, and WriteHeader\n-\t// is what sets w.chunking.\n-\tw.Flush()\n+\t// Call WriteHeader before checking w.chunking if it hasn't\n+\t// been called yet, since WriteHeader is what sets w.chunking.\n+\tif !w.wroteHeader {\n+\t\tw.WriteHeader(StatusOK)\n+\t}\n \tif !w.chunking && w.bodyAllowed() && !w.needSniff {\n+\t\tw.Flush()\n \t\tif rf, ok := w.conn.rwc.(io.ReaderFrom); ok {\n \t\t\tn, err = rf.ReadFrom(src)\n \t\t\tw.written += n"}, {"sha": "86744eeb56b762f22e517e6ece559ff023baf704", "filename": "libgo/go/net/http/sniff_test.go", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fsniff_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Fsniff_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fsniff_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -6,6 +6,7 @@ package http_test\n \n import (\n \t\"bytes\"\n+\t\"io\"\n \t\"io/ioutil\"\n \t\"log\"\n \t. \"net/http\"\n@@ -79,3 +80,35 @@ func TestServerContentType(t *testing.T) {\n \t\tresp.Body.Close()\n \t}\n }\n+\n+func TestContentTypeWithCopy(t *testing.T) {\n+\tconst (\n+\t\tinput    = \"\\n<html>\\n\\t<head>\\n\"\n+\t\texpected = \"text/html; charset=utf-8\"\n+\t)\n+\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\t// Use io.Copy from a bytes.Buffer to trigger ReadFrom.\n+\t\tbuf := bytes.NewBuffer([]byte(input))\n+\t\tn, err := io.Copy(w, buf)\n+\t\tif int(n) != len(input) || err != nil {\n+\t\t\tt.Errorf(\"io.Copy(w, %q) = %v, %v want %d, nil\", input, n, err, len(input))\n+\t\t}\n+\t}))\n+\tdefer ts.Close()\n+\n+\tresp, err := Get(ts.URL)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Get: %v\", err)\n+\t}\n+\tif ct := resp.Header.Get(\"Content-Type\"); ct != expected {\n+\t\tt.Errorf(\"Content-Type = %q, want %q\", ct, expected)\n+\t}\n+\tdata, err := ioutil.ReadAll(resp.Body)\n+\tif err != nil {\n+\t\tt.Errorf(\"reading body: %v\", err)\n+\t} else if !bytes.Equal(data, []byte(input)) {\n+\t\tt.Errorf(\"data is %q, want %q\", data, input)\n+\t}\n+\tresp.Body.Close()\n+}"}, {"sha": "d25c8fcde42b25c8b781e3f352bd1f35f89c4118", "filename": "libgo/go/net/http/transfer.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransfer.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -537,7 +537,9 @@ func (b *body) Read(p []byte) (n int, err error) {\n \n \t// Read the final trailer once we hit EOF.\n \tif err == io.EOF && b.hdr != nil {\n-\t\terr = b.readTrailer()\n+\t\tif e := b.readTrailer(); e != nil {\n+\t\t\terr = e\n+\t\t}\n \t\tb.hdr = nil\n \t}\n \treturn n, err"}, {"sha": "e622e41f0a2de014b8ee9e3a95b5082cab1c05d2", "filename": "libgo/go/net/http/transport.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -504,7 +504,7 @@ func (pc *persistConn) expectingResponse() bool {\n var remoteSideClosedFunc func(error) bool // or nil to use default\n \n func remoteSideClosed(err error) bool {\n-\tif err == io.EOF || err == os.EINVAL {\n+\tif err == io.EOF {\n \t\treturn true\n \t}\n \tif remoteSideClosedFunc != nil {"}, {"sha": "c9ef2c2ab6ea511219a05ce897cef116470ef461", "filename": "libgo/go/net/http/transport_windows.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Ftransport_windows.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -6,14 +6,14 @@ package http\n \n import (\n \t\"net\"\n-\t\"os\"\n+\t\"syscall\"\n )\n \n func init() {\n \tremoteSideClosedFunc = func(err error) (out bool) {\n \t\top, ok := err.(*net.OpError)\n-\t\tif ok && op.Op == \"WSARecv\" && op.Net == \"tcp\" && op.Err == os.Errno(10058) {\n-\t\t\t// TODO(bradfitz): find the symbol for 10058\n+\t\tif ok && op.Op == \"WSARecv\" && op.Net == \"tcp\" && op.Err == syscall.Errno(10058) {\n+\t\t\t// TODO(brainman,rsc): Fix whatever is generating this.\n \t\t\treturn true\n \t\t}\n \t\treturn false"}, {"sha": "e896d43c321f29f8f7c1d05180747369e6a2d3e3", "filename": "libgo/go/net/interface_bsd.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Finterface_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Finterface_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_bsd.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -20,18 +20,18 @@ import (\n func interfaceTable(ifindex int) ([]Interface, error) {\n \tvar (\n \t\ttab  []byte\n-\t\te    int\n+\t\te    error\n \t\tmsgs []syscall.RoutingMessage\n \t\tift  []Interface\n \t)\n \n \ttab, e = syscall.RouteRIB(syscall.NET_RT_IFLIST, ifindex)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, os.NewSyscallError(\"route rib\", e)\n \t}\n \n \tmsgs, e = syscall.ParseRoutingMessage(tab)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, os.NewSyscallError(\"route message\", e)\n \t}\n \n@@ -55,7 +55,7 @@ func newLink(m *syscall.InterfaceMessage) ([]Interface, error) {\n \tvar ift []Interface\n \n \tsas, e := syscall.ParseRoutingSockaddr(m)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, os.NewSyscallError(\"route sockaddr\", e)\n \t}\n \n@@ -110,18 +110,18 @@ func linkFlags(rawFlags int32) Flags {\n func interfaceAddrTable(ifindex int) ([]Addr, error) {\n \tvar (\n \t\ttab  []byte\n-\t\te    int\n+\t\te    error\n \t\tmsgs []syscall.RoutingMessage\n \t\tifat []Addr\n \t)\n \n \ttab, e = syscall.RouteRIB(syscall.NET_RT_IFLIST, ifindex)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, os.NewSyscallError(\"route rib\", e)\n \t}\n \n \tmsgs, e = syscall.ParseRoutingMessage(tab)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, os.NewSyscallError(\"route message\", e)\n \t}\n \n@@ -145,7 +145,7 @@ func newAddr(m *syscall.InterfaceAddrMessage) ([]Addr, error) {\n \tvar ifat []Addr\n \n \tsas, e := syscall.ParseRoutingSockaddr(m)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, os.NewSyscallError(\"route sockaddr\", e)\n \t}\n "}, {"sha": "2da447adc8438ed4ee6fb997d3a6dbbdc02bb321", "filename": "libgo/go/net/interface_darwin.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Finterface_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Finterface_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_darwin.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -17,18 +17,18 @@ import (\n func interfaceMulticastAddrTable(ifindex int) ([]Addr, error) {\n \tvar (\n \t\ttab   []byte\n-\t\te     int\n+\t\te     error\n \t\tmsgs  []syscall.RoutingMessage\n \t\tifmat []Addr\n \t)\n \n \ttab, e = syscall.RouteRIB(syscall.NET_RT_IFLIST2, ifindex)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, os.NewSyscallError(\"route rib\", e)\n \t}\n \n \tmsgs, e = syscall.ParseRoutingMessage(tab)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, os.NewSyscallError(\"route message\", e)\n \t}\n \n@@ -52,7 +52,7 @@ func newMulticastAddr(m *syscall.InterfaceMulticastAddrMessage) ([]Addr, error)\n \tvar ifmat []Addr\n \n \tsas, e := syscall.ParseRoutingSockaddr(m)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, os.NewSyscallError(\"route sockaddr\", e)\n \t}\n "}, {"sha": "a12877e251b0cb35950f78dae0791acf8d4bf8ad", "filename": "libgo/go/net/interface_freebsd.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Finterface_freebsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Finterface_freebsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_freebsd.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -17,18 +17,18 @@ import (\n func interfaceMulticastAddrTable(ifindex int) ([]Addr, error) {\n \tvar (\n \t\ttab   []byte\n-\t\te     int\n+\t\te     error\n \t\tmsgs  []syscall.RoutingMessage\n \t\tifmat []Addr\n \t)\n \n \ttab, e = syscall.RouteRIB(syscall.NET_RT_IFMALIST, ifindex)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, os.NewSyscallError(\"route rib\", e)\n \t}\n \n \tmsgs, e = syscall.ParseRoutingMessage(tab)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, os.NewSyscallError(\"route message\", e)\n \t}\n \n@@ -52,7 +52,7 @@ func newMulticastAddr(m *syscall.InterfaceMulticastAddrMessage) ([]Addr, error)\n \tvar ifmat []Addr\n \n \tsas, e := syscall.ParseRoutingSockaddr(m)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, os.NewSyscallError(\"route sockaddr\", e)\n \t}\n "}, {"sha": "96db7186af552d6d53cbb8af04a6aa1980383239", "filename": "libgo/go/net/interface_linux.go", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Finterface_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Finterface_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_linux.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -21,16 +21,16 @@ func interfaceTable(ifindex int) ([]Interface, error) {\n \t\tift  []Interface\n \t\ttab  []byte\n \t\tmsgs []syscall.NetlinkMessage\n-\t\te    int\n+\t\te    error\n \t)\n \n \ttab, e = syscall.NetlinkRIB(syscall.RTM_GETLINK, syscall.AF_UNSPEC)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, os.NewSyscallError(\"netlink rib\", e)\n \t}\n \n \tmsgs, e = syscall.ParseNetlinkMessage(tab)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, os.NewSyscallError(\"netlink message\", e)\n \t}\n \n@@ -42,7 +42,7 @@ func interfaceTable(ifindex int) ([]Interface, error) {\n \t\t\tifim := (*syscall.IfInfomsg)(unsafe.Pointer(&m.Data[0]))\n \t\t\tif ifindex == 0 || ifindex == int(ifim.Index) {\n \t\t\t\tattrs, e := syscall.ParseNetlinkRouteAttr(&m)\n-\t\t\t\tif e != 0 {\n+\t\t\t\tif e != nil {\n \t\t\t\t\treturn nil, os.NewSyscallError(\"netlink routeattr\", e)\n \t\t\t\t}\n \t\t\t\tifi := newLink(attrs, ifim)\n@@ -102,27 +102,19 @@ func linkFlags(rawFlags uint32) Flags {\n // for all network interfaces.  Otherwise it returns addresses\n // for a specific interface.\n func interfaceAddrTable(ifindex int) ([]Addr, error) {\n-\tvar (\n-\t\ttab  []byte\n-\t\te    int\n-\t\terr  error\n-\t\tifat []Addr\n-\t\tmsgs []syscall.NetlinkMessage\n-\t)\n-\n-\ttab, e = syscall.NetlinkRIB(syscall.RTM_GETADDR, syscall.AF_UNSPEC)\n-\tif e != 0 {\n+\ttab, e := syscall.NetlinkRIB(syscall.RTM_GETADDR, syscall.AF_UNSPEC)\n+\tif e != nil {\n \t\treturn nil, os.NewSyscallError(\"netlink rib\", e)\n \t}\n \n-\tmsgs, e = syscall.ParseNetlinkMessage(tab)\n-\tif e != 0 {\n+\tmsgs, e := syscall.ParseNetlinkMessage(tab)\n+\tif e != nil {\n \t\treturn nil, os.NewSyscallError(\"netlink message\", e)\n \t}\n \n-\tifat, err = addrTable(msgs, ifindex)\n-\tif err != nil {\n-\t\treturn nil, err\n+\tifat, e := addrTable(msgs, ifindex)\n+\tif e != nil {\n+\t\treturn nil, e\n \t}\n \n \treturn ifat, nil\n@@ -139,7 +131,7 @@ func addrTable(msgs []syscall.NetlinkMessage, ifindex int) ([]Addr, error) {\n \t\t\tifam := (*syscall.IfAddrmsg)(unsafe.Pointer(&m.Data[0]))\n \t\t\tif ifindex == 0 || ifindex == int(ifam.Index) {\n \t\t\t\tattrs, e := syscall.ParseNetlinkRouteAttr(&m)\n-\t\t\t\tif e != 0 {\n+\t\t\t\tif e != nil {\n \t\t\t\t\treturn nil, os.NewSyscallError(\"netlink routeattr\", e)\n \t\t\t\t}\n \t\t\t\tifat = append(ifat, newAddr(attrs, int(ifam.Family))...)"}, {"sha": "2ed66cdce377a58e489f4cf4a5ded52419e2cfa9", "filename": "libgo/go/net/interface_windows.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Finterface_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Finterface_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface_windows.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -39,7 +39,7 @@ func getAdapterList() (*syscall.IpAdapterInfo, error) {\n \n func getInterfaceList() ([]syscall.InterfaceInfo, error) {\n \ts, e := syscall.Socket(syscall.AF_INET, syscall.SOCK_DGRAM, syscall.IPPROTO_UDP)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, os.NewSyscallError(\"Socket\", e)\n \t}\n \tdefer syscall.Closesocket(s)\n@@ -48,7 +48,7 @@ func getInterfaceList() ([]syscall.InterfaceInfo, error) {\n \tret := uint32(0)\n \tsize := uint32(unsafe.Sizeof(ii))\n \te = syscall.WSAIoctl(s, syscall.SIO_GET_INTERFACE_LIST, nil, 0, (*byte)(unsafe.Pointer(&ii[0])), size, &ret, nil, 0)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, os.NewSyscallError(\"WSAIoctl\", e)\n \t}\n \tc := ret / uint32(unsafe.Sizeof(ii[0]))"}, {"sha": "9234f5aff65127391f39593980d13a0f05c29dc0", "filename": "libgo/go/net/ipsock.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fipsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fipsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -9,7 +9,7 @@ package net\n var supportsIPv6, supportsIPv4map = probeIPv6Stack()\n \n func firstFavoriteAddr(filter func(IP) IP, addrs []string) (addr IP) {\n-\tif filter == anyaddr {\n+\tif filter == nil {\n \t\t// We'll take any IP address, but since the dialing code\n \t\t// does not yet try multiple addresses, prefer to use\n \t\t// an IPv4 address if possible.  This is especially relevant\n@@ -113,7 +113,7 @@ func hostPortToIP(net, hostport string) (ip IP, iport int, err error) {\n \t\t// Try as an IP address.\n \t\taddr = ParseIP(host)\n \t\tif addr == nil {\n-\t\t\tfilter := anyaddr\n+\t\t\tvar filter func(IP) IP\n \t\t\tif net != \"\" && net[len(net)-1] == '4' {\n \t\t\t\tfilter = ipv4only\n \t\t\t}"}, {"sha": "f0ca7dad3457b485d208bf2e0e4437c7c3694b21", "filename": "libgo/go/net/ipsock_posix.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fipsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fipsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock_posix.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -33,17 +33,17 @@ func probeIPv6Stack() (supportsIPv6, supportsIPv4map bool) {\n \t}\n \n \tfor i := range probes {\n-\t\ts, errno := syscall.Socket(syscall.AF_INET6, syscall.SOCK_STREAM, syscall.IPPROTO_TCP)\n-\t\tif errno != 0 {\n+\t\ts, err := syscall.Socket(syscall.AF_INET6, syscall.SOCK_STREAM, syscall.IPPROTO_TCP)\n+\t\tif err != nil {\n \t\t\tcontinue\n \t\t}\n \t\tdefer closesocket(s)\n \t\tsa, err := probes[i].la.toAddr().sockaddr(syscall.AF_INET6)\n \t\tif err != nil {\n \t\t\tcontinue\n \t\t}\n-\t\terrno = syscall.Bind(s, sa)\n-\t\tif errno != 0 {\n+\t\terr = syscall.Bind(s, sa)\n+\t\tif err != nil {\n \t\t\tcontinue\n \t\t}\n \t\tprobes[i].ok = true"}, {"sha": "020871b46d6c88fd98f79b14ddf17e10e2f169af", "filename": "libgo/go/net/lookup_windows.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Flookup_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Flookup_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Flookup_windows.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -22,7 +22,7 @@ func lookupProtocol(name string) (proto int, err error) {\n \tprotoentLock.Lock()\n \tdefer protoentLock.Unlock()\n \tp, e := syscall.GetProtoByName(name)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn 0, os.NewSyscallError(\"GetProtoByName\", e)\n \t}\n \treturn int(p.Proto), nil\n@@ -44,7 +44,7 @@ func LookupIP(name string) (addrs []IP, err error) {\n \thostentLock.Lock()\n \tdefer hostentLock.Unlock()\n \th, e := syscall.GetHostByName(name)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, os.NewSyscallError(\"GetHostByName\", e)\n \t}\n \tswitch h.AddrType {\n@@ -71,7 +71,7 @@ func LookupPort(network, service string) (port int, err error) {\n \tserventLock.Lock()\n \tdefer serventLock.Unlock()\n \ts, e := syscall.GetServByName(service, network)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn 0, os.NewSyscallError(\"GetServByName\", e)\n \t}\n \treturn int(syscall.Ntohs(s.Port)), nil\n@@ -81,7 +81,7 @@ func LookupCNAME(name string) (cname string, err error) {\n \tvar r *syscall.DNSRecord\n \te := syscall.DnsQuery(name, syscall.DNS_TYPE_CNAME, 0, nil, &r, nil)\n \tif e != 0 {\n-\t\treturn \"\", os.NewSyscallError(\"LookupCNAME\", int(e))\n+\t\treturn \"\", os.NewSyscallError(\"LookupCNAME\", e)\n \t}\n \tdefer syscall.DnsRecordListFree(r, 1)\n \tif r != nil && r.Type == syscall.DNS_TYPE_CNAME {\n@@ -110,7 +110,7 @@ func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err err\n \tvar r *syscall.DNSRecord\n \te := syscall.DnsQuery(target, syscall.DNS_TYPE_SRV, 0, nil, &r, nil)\n \tif e != 0 {\n-\t\treturn \"\", nil, os.NewSyscallError(\"LookupSRV\", int(e))\n+\t\treturn \"\", nil, os.NewSyscallError(\"LookupSRV\", e)\n \t}\n \tdefer syscall.DnsRecordListFree(r, 1)\n \taddrs = make([]*SRV, 0, 10)\n@@ -126,7 +126,7 @@ func LookupMX(name string) (mx []*MX, err error) {\n \tvar r *syscall.DNSRecord\n \te := syscall.DnsQuery(name, syscall.DNS_TYPE_MX, 0, nil, &r, nil)\n \tif e != 0 {\n-\t\treturn nil, os.NewSyscallError(\"LookupMX\", int(e))\n+\t\treturn nil, os.NewSyscallError(\"LookupMX\", e)\n \t}\n \tdefer syscall.DnsRecordListFree(r, 1)\n \tmx = make([]*MX, 0, 10)\n@@ -142,7 +142,7 @@ func LookupTXT(name string) (txt []string, err error) {\n \tvar r *syscall.DNSRecord\n \te := syscall.DnsQuery(name, syscall.DNS_TYPE_TEXT, 0, nil, &r, nil)\n \tif e != 0 {\n-\t\treturn nil, os.NewSyscallError(\"LookupTXT\", int(e))\n+\t\treturn nil, os.NewSyscallError(\"LookupTXT\", e)\n \t}\n \tdefer syscall.DnsRecordListFree(r, 1)\n \ttxt = make([]string, 0, 10)\n@@ -164,7 +164,7 @@ func LookupAddr(addr string) (name []string, err error) {\n \tvar r *syscall.DNSRecord\n \te := syscall.DnsQuery(arpa, syscall.DNS_TYPE_PTR, 0, nil, &r, nil)\n \tif e != 0 {\n-\t\treturn nil, os.NewSyscallError(\"LookupAddr\", int(e))\n+\t\treturn nil, os.NewSyscallError(\"LookupAddr\", e)\n \t}\n \tdefer syscall.DnsRecordListFree(r, 1)\n \tname = make([]string, 0, 10)"}, {"sha": "035df4a6ff141864f5bf9d5c5b5b6cc2975eda90", "filename": "libgo/go/net/newpollserver.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fnewpollserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fnewpollserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fnewpollserver.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -18,11 +18,10 @@ func newPollServer() (s *pollServer, err error) {\n \tif s.pr, s.pw, err = os.Pipe(); err != nil {\n \t\treturn nil, err\n \t}\n-\tvar e int\n-\tif e = syscall.SetNonblock(s.pr.Fd(), true); e != 0 {\n+\tif err = syscall.SetNonblock(s.pr.Fd(), true); err != nil {\n \t\tgoto Errno\n \t}\n-\tif e = syscall.SetNonblock(s.pw.Fd(), true); e != 0 {\n+\tif err = syscall.SetNonblock(s.pw.Fd(), true); err != nil {\n \t\tgoto Errno\n \t}\n \tif s.poll, err = newpollster(); err != nil {\n@@ -37,7 +36,7 @@ func newPollServer() (s *pollServer, err error) {\n \treturn s, nil\n \n Errno:\n-\terr = &os.PathError{\"setnonblock\", s.pr.Name(), os.Errno(e)}\n+\terr = &os.PathError{\"setnonblock\", s.pr.Name(), err}\n Error:\n \ts.pr.Close()\n \ts.pw.Close()"}, {"sha": "0ce7ccb9d7b1af1144adf5d8d33cfbfe5a86578e", "filename": "libgo/go/net/pipe.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fpipe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fpipe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fpipe.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -1,3 +1,7 @@\n+// Copyright 2010 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package net\n \n import ("}, {"sha": "350abe451f37854b1d26889ca5a243010e51f251", "filename": "libgo/go/net/sendfile_linux.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fsendfile_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fsendfile_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsendfile_linux.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -62,18 +62,18 @@ func sendFile(c *netFD, r io.Reader) (written int64, err error, handled bool) {\n \t\t\twritten += int64(n)\n \t\t\tremain -= int64(n)\n \t\t}\n-\t\tif n == 0 && errno == 0 {\n+\t\tif n == 0 && errno == nil {\n \t\t\tbreak\n \t\t}\n \t\tif errno == syscall.EAGAIN && c.wdeadline >= 0 {\n \t\t\tpollserver.WaitWrite(c)\n \t\t\tcontinue\n \t\t}\n-\t\tif errno != 0 {\n+\t\tif errno != nil {\n \t\t\t// This includes syscall.ENOSYS (no kernel\n \t\t\t// support) and syscall.EINVAL (fd types which\n \t\t\t// don't implement sendfile together)\n-\t\t\terr = &OpError{\"sendfile\", c.net, c.raddr, os.Errno(errno)}\n+\t\t\terr = &OpError{\"sendfile\", c.net, c.raddr, errno}\n \t\t\tbreak\n \t\t}\n \t}"}, {"sha": "ee7ff8b98c2d9849f4905610d22a13d3955a9c81", "filename": "libgo/go/net/sendfile_windows.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fsendfile_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fsendfile_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsendfile_windows.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -16,7 +16,7 @@ type sendfileOp struct {\n \tn   uint32\n }\n \n-func (o *sendfileOp) Submit() (errno int) {\n+func (o *sendfileOp) Submit() (err error) {\n \treturn syscall.TransmitFile(o.fd.sysfd, o.src, o.n, 0, &o.o, nil, syscall.TF_WRITE_BEHIND)\n }\n "}, {"sha": "33f11f219c9f2a8ca2d79f15ff0844be571f4c77", "filename": "libgo/go/net/sock.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Fsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -28,9 +28,9 @@ func socket(net string, f, p, t int, la, ra syscall.Sockaddr, toAddr func(syscal\n \t// See ../syscall/exec.go for description of ForkLock.\n \tsyscall.ForkLock.RLock()\n \ts, e := syscall.Socket(f, p, t)\n-\tif e != 0 {\n+\tif err != nil {\n \t\tsyscall.ForkLock.RUnlock()\n-\t\treturn nil, os.Errno(e)\n+\t\treturn nil, err\n \t}\n \tsyscall.CloseOnExec(s)\n \tsyscall.ForkLock.RUnlock()\n@@ -39,9 +39,9 @@ func socket(net string, f, p, t int, la, ra syscall.Sockaddr, toAddr func(syscal\n \n \tif la != nil {\n \t\te = syscall.Bind(s, la)\n-\t\tif e != 0 {\n+\t\tif e != nil {\n \t\t\tclosesocket(s)\n-\t\t\treturn nil, os.Errno(e)\n+\t\t\treturn nil, e\n \t\t}\n \t}\n "}, {"sha": "44890ba66bb53391236128b78914ba8765efcdd2", "filename": "libgo/go/net/tcpsock_posix.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -250,9 +250,9 @@ func ListenTCP(net string, laddr *TCPAddr) (l *TCPListener, err error) {\n \t\treturn nil, err\n \t}\n \terrno := syscall.Listen(fd.sysfd, listenBacklog())\n-\tif errno != 0 {\n+\tif errno != nil {\n \t\tclosesocket(fd.sysfd)\n-\t\treturn nil, &OpError{\"listen\", \"tcp\", laddr, os.Errno(errno)}\n+\t\treturn nil, &OpError{\"listen\", \"tcp\", laddr, errno}\n \t}\n \tl = new(TCPListener)\n \tl.fd = fd"}, {"sha": "929f6409a4f0836fe18c719b36b0b133b4de7cb7", "filename": "libgo/go/net/unixsock_posix.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Funixsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fnet%2Funixsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funixsock_posix.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -327,9 +327,9 @@ func ListenUnix(net string, laddr *UnixAddr) (l *UnixListener, err error) {\n \t\treturn nil, err\n \t}\n \te1 := syscall.Listen(fd.sysfd, 8) // listenBacklog());\n-\tif e1 != 0 {\n+\tif e1 != nil {\n \t\tclosesocket(fd.sysfd)\n-\t\treturn nil, &OpError{Op: \"listen\", Net: \"unix\", Addr: laddr, Err: os.Errno(e1)}\n+\t\treturn nil, &OpError{Op: \"listen\", Net: \"unix\", Addr: laddr, Err: e1}\n \t}\n \treturn &UnixListener{fd, laddr.Name}, nil\n }"}, {"sha": "d6b4239610ec22a8dda6a43db5c129a7f815006b", "filename": "libgo/go/os/dir_largefile.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fdir_largefile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fdir_largefile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdir_largefile.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -9,4 +9,4 @@ package os\n \n import \"syscall\"\n \n-func libc_readdir_r(*syscall.DIR, *syscall.Dirent, **syscall.Dirent) int __asm__ (\"readdir64_r\")\n+func libc_readdir_r(*syscall.DIR, *syscall.Dirent, **syscall.Dirent) syscall.Errno __asm__ (\"readdir64_r\")"}, {"sha": "7effdf7851a84daf5a7a858f1fc218fe868afa78", "filename": "libgo/go/os/dir_regfile.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fdir_regfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fdir_regfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdir_regfile.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -9,4 +9,4 @@ package os\n \n import \"syscall\"\n \n-func libc_readdir_r(*syscall.DIR, *syscall.Dirent, **syscall.Dirent) int __asm__ (\"readdir_r\")\n+func libc_readdir_r(*syscall.DIR, *syscall.Dirent, **syscall.Dirent) syscall.Errno __asm__ (\"readdir_r\")"}, {"sha": "e4dff835d89975033f728f3aa105465382cf6288", "filename": "libgo/go/os/dir_unix.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fdir_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fdir_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdir_unix.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -47,9 +47,9 @@ func (f *File) Readdirnames(n int) (names []string, err error) {\n \t\t// Refill the buffer if necessary\n \t\tif d.bufp >= d.nbuf {\n \t\t\td.bufp = 0\n-\t\t\tvar errno int\n+\t\t\tvar errno error\n \t\t\td.nbuf, errno = syscall.ReadDirent(f.fd, d.buf)\n-\t\t\tif errno != 0 {\n+\t\t\tif errno != nil {\n \t\t\t\treturn names, NewSyscallError(\"readdirent\", errno)\n \t\t\t}\n \t\t\tif d.nbuf <= 0 {"}, {"sha": "7e3f52502e54ef93afec26e75991de666e19c17c", "filename": "libgo/go/os/env.go", "status": "modified", "additions": 48, "deletions": 1, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fenv.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -6,7 +6,10 @@\n \n package os\n \n-func setenv_c(k, v string)\n+import (\n+\t\"errors\"\n+\t\"syscall\"\n+)\n \n // Expand replaces ${var} or $var in the string based on the mapping function.\n // Invocations of undefined variables are replaced with the empty string.\n@@ -73,3 +76,47 @@ func getShellName(s string) (string, int) {\n \t}\n \treturn s[:i], i\n }\n+\n+// ENOENV is the error indicating that an environment variable does not exist.\n+var ENOENV = errors.New(\"no such environment variable\")\n+\n+// Getenverror retrieves the value of the environment variable named by the key.\n+// It returns the value and an error, if any.\n+func Getenverror(key string) (value string, err error) {\n+\tif len(key) == 0 {\n+\t\treturn \"\", EINVAL\n+\t}\n+\tval, found := syscall.Getenv(key)\n+\tif !found {\n+\t\treturn \"\", ENOENV\n+\t}\n+\treturn val, nil\n+}\n+\n+// Getenv retrieves the value of the environment variable named by the key.\n+// It returns the value, which will be empty if the variable is not present.\n+func Getenv(key string) string {\n+\tv, _ := Getenverror(key)\n+\treturn v\n+}\n+\n+// Setenv sets the value of the environment variable named by the key.\n+// It returns an error, if any.\n+func Setenv(key, value string) error {\n+\terr := syscall.Setenv(key, value)\n+\tif err != nil {\n+\t\treturn NewSyscallError(\"setenv\", err)\n+\t}\n+\treturn nil\n+}\n+\n+// Clearenv deletes all environment variables.\n+func Clearenv() {\n+\tsyscall.Clearenv()\n+}\n+\n+// Environ returns an array of strings representing the environment,\n+// in the form \"key=value\".\n+func Environ() []string {\n+\treturn syscall.Environ()\n+}"}, {"sha": "9757aa902af8f23206ddce19cb2724921df05fe2", "filename": "libgo/go/os/env_plan9.go", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e456f4cf4deee3e2ccd9849286f59b90644c48b/libgo%2Fgo%2Fos%2Fenv_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e456f4cf4deee3e2ccd9849286f59b90644c48b/libgo%2Fgo%2Fos%2Fenv_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fenv_plan9.go?ref=6e456f4cf4deee3e2ccd9849286f59b90644c48b", "patch": "@@ -1,99 +0,0 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Plan 9 environment variables.\n-\n-package os\n-\n-import (\n-\t\"errors\"\n-\t\"syscall\"\n-)\n-\n-// ENOENV is the error indicating that an environment variable does not exist.\n-var ENOENV = errors.New(\"no such environment variable\")\n-\n-// Getenverror retrieves the value of the environment variable named by the key.\n-// It returns the value and an error, if any.\n-func Getenverror(key string) (value string, err error) {\n-\tif len(key) == 0 {\n-\t\treturn \"\", EINVAL\n-\t}\n-\tf, e := Open(\"/env/\" + key)\n-\tif iserror(e) {\n-\t\treturn \"\", ENOENV\n-\t}\n-\tdefer f.Close()\n-\n-\tl, _ := f.Seek(0, 2)\n-\tf.Seek(0, 0)\n-\tbuf := make([]byte, l)\n-\tn, e := f.Read(buf)\n-\tif iserror(e) {\n-\t\treturn \"\", ENOENV\n-\t}\n-\n-\tif n > 0 && buf[n-1] == 0 {\n-\t\tbuf = buf[:n-1]\n-\t}\n-\treturn string(buf), nil\n-}\n-\n-// Getenv retrieves the value of the environment variable named by the key.\n-// It returns the value, which will be empty if the variable is not present.\n-func Getenv(key string) string {\n-\tv, _ := Getenverror(key)\n-\treturn v\n-}\n-\n-// Setenv sets the value of the environment variable named by the key.\n-// It returns an error, if any.\n-func Setenv(key, value string) error {\n-\tif len(key) == 0 {\n-\t\treturn EINVAL\n-\t}\n-\n-\tf, e := Create(\"/env/\" + key)\n-\tif iserror(e) {\n-\t\treturn e\n-\t}\n-\tdefer f.Close()\n-\n-\t_, e = f.Write([]byte(value))\n-\treturn nil\n-}\n-\n-// Clearenv deletes all environment variables.\n-func Clearenv() {\n-\tsyscall.RawSyscall(syscall.SYS_RFORK, syscall.RFCENVG, 0, 0)\n-}\n-\n-// Environ returns an array of strings representing the environment,\n-// in the form \"key=value\".\n-func Environ() []string {\n-\tenv := make([]string, 0, 100)\n-\n-\tf, e := Open(\"/env\")\n-\tif iserror(e) {\n-\t\tpanic(e)\n-\t}\n-\tdefer f.Close()\n-\n-\tnames, e := f.Readdirnames(-1)\n-\tif iserror(e) {\n-\t\tpanic(e)\n-\t}\n-\n-\tfor _, k := range names {\n-\t\tif v, e := Getenverror(k); !iserror(e) {\n-\t\t\tenv = append(env, k+\"=\"+v)\n-\t\t}\n-\t}\n-\treturn env[0:len(env)]\n-}\n-\n-// TempDir returns the default directory to use for temporary files.\n-func TempDir() string {\n-\treturn \"/tmp\"\n-}"}, {"sha": "01fd9d449f36bd730a95fbc7afb1220ede4f2a9e", "filename": "libgo/go/os/env_unix.go", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e456f4cf4deee3e2ccd9849286f59b90644c48b/libgo%2Fgo%2Fos%2Fenv_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e456f4cf4deee3e2ccd9849286f59b90644c48b/libgo%2Fgo%2Fos%2Fenv_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fenv_unix.go?ref=6e456f4cf4deee3e2ccd9849286f59b90644c48b", "patch": "@@ -1,112 +0,0 @@\n-// Copyright 2010 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// +build darwin freebsd linux openbsd\n-\n-// Unix environment variables.\n-\n-package os\n-\n-import (\n-\t\"errors\"\n-\t\"sync\"\n-)\n-\n-// ENOENV is the error indicating that an environment variable does not exist.\n-var ENOENV = errors.New(\"no such environment variable\")\n-\n-var env map[string]string\n-var once sync.Once\n-\n-func copyenv() {\n-\tenv = make(map[string]string)\n-\tfor _, s := range Envs {\n-\t\tfor j := 0; j < len(s); j++ {\n-\t\t\tif s[j] == '=' {\n-\t\t\t\tenv[s[0:j]] = s[j+1:]\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-var envLock sync.RWMutex\n-\n-// Getenverror retrieves the value of the environment variable named by the key.\n-// It returns the value and an error, if any.\n-func Getenverror(key string) (value string, err error) {\n-\tonce.Do(copyenv)\n-\n-\tif len(key) == 0 {\n-\t\treturn \"\", EINVAL\n-\t}\n-\n-\tenvLock.RLock()\n-\tdefer envLock.RUnlock()\n-\n-\tv, ok := env[key]\n-\tif !ok {\n-\t\treturn \"\", ENOENV\n-\t}\n-\treturn v, nil\n-}\n-\n-// Getenv retrieves the value of the environment variable named by the key.\n-// It returns the value, which will be empty if the variable is not present.\n-func Getenv(key string) string {\n-\tv, _ := Getenverror(key)\n-\treturn v\n-}\n-\n-// Setenv sets the value of the environment variable named by the key.\n-// It returns an error, if any.\n-func Setenv(key, value string) error {\n-\tonce.Do(copyenv)\n-\tif len(key) == 0 {\n-\t\treturn EINVAL\n-\t}\n-\n-\tenvLock.Lock()\n-\tdefer envLock.Unlock()\n-\n-\tenv[key] = value\n-\tsetenv_c(key, value) // is a no-op if cgo isn't loaded\n-\treturn nil\n-}\n-\n-// Clearenv deletes all environment variables.\n-func Clearenv() {\n-\tonce.Do(copyenv) // prevent copyenv in Getenv/Setenv\n-\n-\tenvLock.Lock()\n-\tdefer envLock.Unlock()\n-\n-\tenv = make(map[string]string)\n-\n-\t// TODO(bradfitz): pass through to C\n-}\n-\n-// Environ returns an array of strings representing the environment,\n-// in the form \"key=value\".\n-func Environ() []string {\n-\tonce.Do(copyenv)\n-\tenvLock.RLock()\n-\tdefer envLock.RUnlock()\n-\ta := make([]string, len(env))\n-\ti := 0\n-\tfor k, v := range env {\n-\t\ta[i] = k + \"=\" + v\n-\t\ti++\n-\t}\n-\treturn a\n-}\n-\n-// TempDir returns the default directory to use for temporary files.\n-func TempDir() string {\n-\tdir := Getenv(\"TMPDIR\")\n-\tif dir == \"\" {\n-\t\tdir = \"/tmp\"\n-\t}\n-\treturn dir\n-}"}, {"sha": "4e90385da96dc69b98882b9a24b266695fa9e969", "filename": "libgo/go/os/env_windows.go", "status": "removed", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e456f4cf4deee3e2ccd9849286f59b90644c48b/libgo%2Fgo%2Fos%2Fenv_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e456f4cf4deee3e2ccd9849286f59b90644c48b/libgo%2Fgo%2Fos%2Fenv_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fenv_windows.go?ref=6e456f4cf4deee3e2ccd9849286f59b90644c48b", "patch": "@@ -1,128 +0,0 @@\n-// Copyright 2010 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Windows environment variables.\n-\n-package os\n-\n-import (\n-\t\"errors\"\n-\t\"syscall\"\n-\t\"unicode/utf16\"\n-\t\"unsafe\"\n-)\n-\n-// ENOENV is the error indicating that an environment variable does not exist.\n-var ENOENV = errors.New(\"no such environment variable\")\n-\n-// Getenverror retrieves the value of the environment variable named by the key.\n-// It returns the value and an error, if any.\n-func Getenverror(key string) (value string, err error) {\n-\tb := make([]uint16, 100)\n-\tn, e := syscall.GetEnvironmentVariable(syscall.StringToUTF16Ptr(key), &b[0], uint32(len(b)))\n-\tif n == 0 && e == syscall.ERROR_ENVVAR_NOT_FOUND {\n-\t\treturn \"\", ENOENV\n-\t}\n-\tif n > uint32(len(b)) {\n-\t\tb = make([]uint16, n)\n-\t\tn, e = syscall.GetEnvironmentVariable(syscall.StringToUTF16Ptr(key), &b[0], uint32(len(b)))\n-\t\tif n > uint32(len(b)) {\n-\t\t\tn = 0\n-\t\t}\n-\t}\n-\tif n == 0 {\n-\t\treturn \"\", NewSyscallError(\"GetEnvironmentVariable\", e)\n-\t}\n-\treturn string(utf16.Decode(b[0:n])), nil\n-}\n-\n-// Getenv retrieves the value of the environment variable named by the key.\n-// It returns the value, which will be empty if the variable is not present.\n-func Getenv(key string) string {\n-\tv, _ := Getenverror(key)\n-\treturn v\n-}\n-\n-// Setenv sets the value of the environment variable named by the key.\n-// It returns an error, if any.\n-func Setenv(key, value string) error {\n-\tvar v *uint16\n-\tif len(value) > 0 {\n-\t\tv = syscall.StringToUTF16Ptr(value)\n-\t}\n-\te := syscall.SetEnvironmentVariable(syscall.StringToUTF16Ptr(key), v)\n-\tif e != 0 {\n-\t\treturn NewSyscallError(\"SetEnvironmentVariable\", e)\n-\t}\n-\treturn nil\n-}\n-\n-// Clearenv deletes all environment variables.\n-func Clearenv() {\n-\tfor _, s := range Environ() {\n-\t\t// Environment variables can begin with =\n-\t\t// so start looking for the separator = at j=1.\n-\t\t// http://blogs.msdn.com/b/oldnewthing/archive/2010/05/06/10008132.aspx\n-\t\tfor j := 1; j < len(s); j++ {\n-\t\t\tif s[j] == '=' {\n-\t\t\t\tSetenv(s[0:j], \"\")\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-// Environ returns an array of strings representing the environment,\n-// in the form \"key=value\".\n-func Environ() []string {\n-\ts, e := syscall.GetEnvironmentStrings()\n-\tif e != 0 {\n-\t\treturn nil\n-\t}\n-\tdefer syscall.FreeEnvironmentStrings(s)\n-\tr := make([]string, 0, 50) // Empty with room to grow.\n-\tfor from, i, p := 0, 0, (*[1 << 24]uint16)(unsafe.Pointer(s)); true; i++ {\n-\t\tif p[i] == 0 {\n-\t\t\t// empty string marks the end\n-\t\t\tif i <= from {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tr = append(r, string(utf16.Decode(p[from:i])))\n-\t\t\tfrom = i + 1\n-\t\t}\n-\t}\n-\treturn r\n-}\n-\n-// TempDir returns the default directory to use for temporary files.\n-func TempDir() string {\n-\tconst pathSep = '\\\\'\n-\tdirw := make([]uint16, syscall.MAX_PATH)\n-\tn, _ := syscall.GetTempPath(uint32(len(dirw)), &dirw[0])\n-\tif n > uint32(len(dirw)) {\n-\t\tdirw = make([]uint16, n)\n-\t\tn, _ = syscall.GetTempPath(uint32(len(dirw)), &dirw[0])\n-\t\tif n > uint32(len(dirw)) {\n-\t\t\tn = 0\n-\t\t}\n-\t}\n-\tif n > 0 && dirw[n-1] == pathSep {\n-\t\tn--\n-\t}\n-\treturn string(utf16.Decode(dirw[0:n]))\n-}\n-\n-func init() {\n-\tvar argc int32\n-\tcmd := syscall.GetCommandLine()\n-\targv, e := syscall.CommandLineToArgv(cmd, &argc)\n-\tif e != 0 {\n-\t\treturn\n-\t}\n-\tdefer syscall.LocalFree(syscall.Handle(uintptr(unsafe.Pointer(argv))))\n-\tArgs = make([]string, argc)\n-\tfor i, v := range (*argv)[:argc] {\n-\t\tArgs[i] = string(syscall.UTF16ToString((*v)[:]))\n-\t}\n-}"}, {"sha": "8f005efbe056fa38468bb43e9d01284ff6e9e9c6", "filename": "libgo/go/os/error_plan9.go", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Ferror_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Ferror_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_plan9.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -24,7 +24,7 @@ func (e *SyscallError) Error() string { return e.Syscall + \": \" + e.Err }\n // NewSyscallError returns, as an error, a new SyscallError\n // with the given system call name and error details.\n // As a convenience, if err is nil, NewSyscallError returns nil.\n-func NewSyscallError(syscall string, err syscall.Error) error {\n+func NewSyscallError(syscall string, err error) error {\n \tif err == nil {\n \t\treturn nil\n \t}\n@@ -57,9 +57,3 @@ var (\n \tEPIPE        = errors.New(\"Broken Pipe\")\n \tEPLAN9       = errors.New(\"not supported by plan 9\")\n )\n-\n-func iserror(err syscall.Error) bool {\n-\treturn err != nil\n-}\n-\n-func Errno(e syscall.Error) syscall.Error { return e }"}, {"sha": "dbe1b9a8d5eeb37cd7b7a6bc32796ca78586dc26", "filename": "libgo/go/os/error_posix.go", "status": "modified", "additions": 44, "deletions": 62, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Ferror_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Ferror_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_posix.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -8,67 +8,53 @@ package os\n \n import syscall \"syscall\"\n \n-// Errno is the Unix error number.  Names such as EINVAL are simple\n-// wrappers to convert the error number into an error.\n-type Errno int64\n-\n-func (e Errno) Error() string { return syscall.Errstr(int(e)) }\n-\n-func (e Errno) Temporary() bool {\n-\treturn e == Errno(syscall.EINTR) || e == Errno(syscall.EMFILE) || e.Timeout()\n-}\n-\n-func (e Errno) Timeout() bool {\n-\treturn e == Errno(syscall.EAGAIN) || e == Errno(syscall.EWOULDBLOCK) || e == Errno(syscall.ETIMEDOUT)\n-}\n-\n // Commonly known Unix errors.\n var (\n-\tEPERM        error = Errno(syscall.EPERM)\n-\tENOENT       error = Errno(syscall.ENOENT)\n-\tESRCH        error = Errno(syscall.ESRCH)\n-\tEINTR        error = Errno(syscall.EINTR)\n-\tEIO          error = Errno(syscall.EIO)\n-\tENXIO        error = Errno(syscall.ENXIO)\n-\tE2BIG        error = Errno(syscall.E2BIG)\n-\tENOEXEC      error = Errno(syscall.ENOEXEC)\n-\tEBADF        error = Errno(syscall.EBADF)\n-\tECHILD       error = Errno(syscall.ECHILD)\n-\tEDEADLK      error = Errno(syscall.EDEADLK)\n-\tENOMEM       error = Errno(syscall.ENOMEM)\n-\tEACCES       error = Errno(syscall.EACCES)\n-\tEFAULT       error = Errno(syscall.EFAULT)\n-\tEBUSY        error = Errno(syscall.EBUSY)\n-\tEEXIST       error = Errno(syscall.EEXIST)\n-\tEXDEV        error = Errno(syscall.EXDEV)\n-\tENODEV       error = Errno(syscall.ENODEV)\n-\tENOTDIR      error = Errno(syscall.ENOTDIR)\n-\tEISDIR       error = Errno(syscall.EISDIR)\n-\tEINVAL       error = Errno(syscall.EINVAL)\n-\tENFILE       error = Errno(syscall.ENFILE)\n-\tEMFILE       error = Errno(syscall.EMFILE)\n-\tENOTTY       error = Errno(syscall.ENOTTY)\n-\tEFBIG        error = Errno(syscall.EFBIG)\n-\tENOSPC       error = Errno(syscall.ENOSPC)\n-\tESPIPE       error = Errno(syscall.ESPIPE)\n-\tEROFS        error = Errno(syscall.EROFS)\n-\tEMLINK       error = Errno(syscall.EMLINK)\n-\tEPIPE        error = Errno(syscall.EPIPE)\n-\tEAGAIN       error = Errno(syscall.EAGAIN)\n-\tEDOM         error = Errno(syscall.EDOM)\n-\tERANGE       error = Errno(syscall.ERANGE)\n-\tEADDRINUSE   error = Errno(syscall.EADDRINUSE)\n-\tECONNREFUSED error = Errno(syscall.ECONNREFUSED)\n-\tENAMETOOLONG error = Errno(syscall.ENAMETOOLONG)\n-\tEAFNOSUPPORT error = Errno(syscall.EAFNOSUPPORT)\n-\tETIMEDOUT    error = Errno(syscall.ETIMEDOUT)\n-\tENOTCONN     error = Errno(syscall.ENOTCONN)\n+\tEPERM        error = syscall.EPERM\n+\tENOENT       error = syscall.ENOENT\n+\tESRCH        error = syscall.ESRCH\n+\tEINTR        error = syscall.EINTR\n+\tEIO          error = syscall.EIO\n+\tENXIO        error = syscall.ENXIO\n+\tE2BIG        error = syscall.E2BIG\n+\tENOEXEC      error = syscall.ENOEXEC\n+\tEBADF        error = syscall.EBADF\n+\tECHILD       error = syscall.ECHILD\n+\tEDEADLK      error = syscall.EDEADLK\n+\tENOMEM       error = syscall.ENOMEM\n+\tEACCES       error = syscall.EACCES\n+\tEFAULT       error = syscall.EFAULT\n+\tEBUSY        error = syscall.EBUSY\n+\tEEXIST       error = syscall.EEXIST\n+\tEXDEV        error = syscall.EXDEV\n+\tENODEV       error = syscall.ENODEV\n+\tENOTDIR      error = syscall.ENOTDIR\n+\tEISDIR       error = syscall.EISDIR\n+\tEINVAL       error = syscall.EINVAL\n+\tENFILE       error = syscall.ENFILE\n+\tEMFILE       error = syscall.EMFILE\n+\tENOTTY       error = syscall.ENOTTY\n+\tEFBIG        error = syscall.EFBIG\n+\tENOSPC       error = syscall.ENOSPC\n+\tESPIPE       error = syscall.ESPIPE\n+\tEROFS        error = syscall.EROFS\n+\tEMLINK       error = syscall.EMLINK\n+\tEPIPE        error = syscall.EPIPE\n+\tEAGAIN       error = syscall.EAGAIN\n+\tEDOM         error = syscall.EDOM\n+\tERANGE       error = syscall.ERANGE\n+\tEADDRINUSE   error = syscall.EADDRINUSE\n+\tECONNREFUSED error = syscall.ECONNREFUSED\n+\tENAMETOOLONG error = syscall.ENAMETOOLONG\n+\tEAFNOSUPPORT error = syscall.EAFNOSUPPORT\n+\tETIMEDOUT    error = syscall.ETIMEDOUT\n+\tENOTCONN     error = syscall.ENOTCONN\n )\n \n // SyscallError records an error from a specific system call.\n type SyscallError struct {\n \tSyscall string\n-\tErrno   Errno\n+\tErrno   error\n }\n \n func (e *SyscallError) Error() string { return e.Syscall + \": \" + e.Errno.Error() }\n@@ -79,14 +65,10 @@ func (e *SyscallError) Error() string { return e.Syscall + \": \" + e.Errno.Error(\n \n // NewSyscallError returns, as an error, a new SyscallError\n // with the given system call name and error details.\n-// As a convenience, if errno is 0, NewSyscallError returns nil.\n-func NewSyscallError(syscall string, errno int) error {\n-\tif errno == 0 {\n+// As a convenience, if err is nil, NewSyscallError returns nil.\n+func NewSyscallError(syscall string, err error) error {\n+\tif err == nil {\n \t\treturn nil\n \t}\n-\treturn &SyscallError{syscall, Errno(errno)}\n-}\n-\n-func iserror(errno int) bool {\n-\treturn errno != 0\n+\treturn &SyscallError{syscall, err}\n }"}, {"sha": "4c95c1b0dac5a750592365eb4311895e378f9e98", "filename": "libgo/go/os/exec/exec.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fexec%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fexec%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec%2Fexec.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -50,14 +50,14 @@ type Cmd struct {\n \t// calling process's current directory.\n \tDir string\n \n-\t// Stdin specifies the process's standard input.\n-\t// If Stdin is nil, the process reads from DevNull.\n+\t// Stdin specifies the process's standard input. If Stdin is\n+\t// nil, the process reads from the null device (os.DevNull).\n \tStdin io.Reader\n \n \t// Stdout and Stderr specify the process's standard output and error.\n \t//\n-\t// If either is nil, Run connects the\n-\t// corresponding file descriptor to /dev/null.\n+\t// If either is nil, Run connects the corresponding file descriptor\n+\t// to the null device (os.DevNull).\n \t//\n \t// If Stdout and Stderr are are the same writer, at most one\n \t// goroutine at a time will call Write."}, {"sha": "9a0db6dd3efbdcf0c71dccaf7ae499df2a915e9b", "filename": "libgo/go/os/exec_plan9.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fexec_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fexec_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_plan9.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -32,7 +32,7 @@ func StartProcess(name string, argv []string, attr *ProcAttr) (p *Process, err e\n \tsysattr.Files = intfd\n \n \tpid, h, e := syscall.StartProcess(name, argv, sysattr)\n-\tif iserror(e) {\n+\tif e != nil {\n \t\treturn nil, &PathError{\"fork/exec\", name, e}\n \t}\n \n@@ -52,7 +52,7 @@ func (p *Process) Signal(sig Signal) error {\n \t}\n \n \tf, e := OpenFile(\"/proc/\"+itoa(p.Pid)+\"/note\", O_WRONLY, 0)\n-\tif iserror(e) {\n+\tif e != nil {\n \t\treturn NewSyscallError(\"signal\", e)\n \t}\n \tdefer f.Close()\n@@ -63,7 +63,7 @@ func (p *Process) Signal(sig Signal) error {\n // Kill causes the Process to exit immediately.\n func (p *Process) Kill() error {\n \tf, e := OpenFile(\"/proc/\"+itoa(p.Pid)+\"/ctl\", O_WRONLY, 0)\n-\tif iserror(e) {\n+\tif e != nil {\n \t\treturn NewSyscallError(\"kill\", e)\n \t}\n \tdefer f.Close()\n@@ -77,7 +77,7 @@ func (p *Process) Kill() error {\n // ForkExec is almost always a better way to execute a program.\n func Exec(name string, argv []string, envv []string) error {\n \te := syscall.Exec(name, argv, envv)\n-\tif iserror(e) {\n+\tif e != nil {\n \t\treturn &PathError{\"exec\", name, e}\n \t}\n \n@@ -102,7 +102,7 @@ func (p *Process) Wait(options int) (w *Waitmsg, err error) {\n \tfor true {\n \t\terr = syscall.Await(&waitmsg)\n \n-\t\tif iserror(err) {\n+\t\tif err != nil {\n \t\t\treturn nil, NewSyscallError(\"wait\", err)\n \t\t}\n "}, {"sha": "8b08eebd0daf0fb195b6f237ec1aa0d26d135839", "filename": "libgo/go/os/exec_posix.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fexec_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fexec_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_posix.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -40,8 +40,8 @@ func StartProcess(name string, argv []string, attr *ProcAttr) (p *Process, err e\n \t}\n \n \tpid, h, e := syscall.StartProcess(name, argv, sysattr)\n-\tif iserror(e) {\n-\t\treturn nil, &PathError{\"fork/exec\", name, Errno(e)}\n+\tif e != nil {\n+\t\treturn nil, &PathError{\"fork/exec\", name, e}\n \t}\n \treturn newProcess(pid, h), nil\n }\n@@ -62,8 +62,8 @@ func Exec(name string, argv []string, envv []string) error {\n \t\tenvv = Environ()\n \t}\n \te := syscall.Exec(name, argv, envv)\n-\tif iserror(e) {\n-\t\treturn &PathError{\"exec\", name, Errno(e)}\n+\tif e != nil {\n+\t\treturn &PathError{\"exec\", name, e}\n \t}\n \treturn nil\n }"}, {"sha": "3dcac414c5ab41cba7b14b23c36eac96239ef343", "filename": "libgo/go/os/exec_unix.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fexec_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fexec_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_unix.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -38,7 +38,7 @@ func (p *Process) Wait(options int) (w *Waitmsg, err error) {\n \t\toptions ^= WRUSAGE\n \t}\n \tpid1, e := syscall.Wait4(p.Pid, &status, options, rusage)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, NewSyscallError(\"wait\", e)\n \t}\n \t// With WNOHANG pid is 0 if child has not exited.\n@@ -57,8 +57,8 @@ func (p *Process) Signal(sig Signal) error {\n \tif p.done {\n \t\treturn errors.New(\"os: process already finished\")\n \t}\n-\tif e := syscall.Kill(p.Pid, int(sig.(UnixSignal))); e != 0 {\n-\t\treturn Errno(e)\n+\tif e := syscall.Kill(p.Pid, int(sig.(UnixSignal))); e != nil {\n+\t\treturn e\n \t}\n \treturn nil\n }"}, {"sha": "c4c9dcfe8292d72418c816ec3810bb5b2b53fa33", "filename": "libgo/go/os/exec_windows.go", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fexec_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fexec_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_windows.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"errors\"\n \t\"runtime\"\n \t\"syscall\"\n+\t\"unsafe\"\n )\n \n func (p *Process) Wait(options int) (w *Waitmsg, err error) {\n@@ -22,7 +23,7 @@ func (p *Process) Wait(options int) (w *Waitmsg, err error) {\n \t}\n \tvar ec uint32\n \te = syscall.GetExitCodeProcess(syscall.Handle(p.handle), &ec)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, NewSyscallError(\"GetExitCodeProcess\", e)\n \t}\n \tp.done = true\n@@ -39,15 +40,15 @@ func (p *Process) Signal(sig Signal) error {\n \t\te := syscall.TerminateProcess(syscall.Handle(p.handle), 1)\n \t\treturn NewSyscallError(\"TerminateProcess\", e)\n \t}\n-\treturn Errno(syscall.EWINDOWS)\n+\treturn syscall.Errno(syscall.EWINDOWS)\n }\n \n func (p *Process) Release() error {\n \tif p.handle == -1 {\n \t\treturn EINVAL\n \t}\n \te := syscall.CloseHandle(syscall.Handle(p.handle))\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn NewSyscallError(\"CloseHandle\", e)\n \t}\n \tp.handle = -1\n@@ -60,8 +61,22 @@ func FindProcess(pid int) (p *Process, err error) {\n \tconst da = syscall.STANDARD_RIGHTS_READ |\n \t\tsyscall.PROCESS_QUERY_INFORMATION | syscall.SYNCHRONIZE\n \th, e := syscall.OpenProcess(da, false, uint32(pid))\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, NewSyscallError(\"OpenProcess\", e)\n \t}\n \treturn newProcess(pid, int(h)), nil\n }\n+\n+func init() {\n+\tvar argc int32\n+\tcmd := syscall.GetCommandLine()\n+\targv, e := syscall.CommandLineToArgv(cmd, &argc)\n+\tif e != nil {\n+\t\treturn\n+\t}\n+\tdefer syscall.LocalFree(syscall.Handle(uintptr(unsafe.Pointer(argv))))\n+\tArgs = make([]string, argc)\n+\tfor i, v := range (*argv)[:argc] {\n+\t\tArgs[i] = string(syscall.UTF16ToString((*v)[:]))\n+\t}\n+}"}, {"sha": "386afb889b2c9c3e8e4225e0a013a530d6fe14d8", "filename": "libgo/go/os/file.go", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -59,11 +59,11 @@ func (file *File) Read(b []byte) (n int, err error) {\n \tif n < 0 {\n \t\tn = 0\n \t}\n-\tif n == 0 && len(b) > 0 && !iserror(e) {\n+\tif n == 0 && len(b) > 0 && e == nil {\n \t\treturn 0, io.EOF\n \t}\n-\tif iserror(e) {\n-\t\terr = &PathError{\"read\", file.name, Errno(e)}\n+\tif e != nil {\n+\t\terr = &PathError{\"read\", file.name, e}\n \t}\n \treturn n, err\n }\n@@ -78,11 +78,11 @@ func (file *File) ReadAt(b []byte, off int64) (n int, err error) {\n \t}\n \tfor len(b) > 0 {\n \t\tm, e := file.pread(b, off)\n-\t\tif m == 0 && !iserror(e) {\n+\t\tif m == 0 && e == nil {\n \t\t\treturn n, io.EOF\n \t\t}\n-\t\tif iserror(e) {\n-\t\t\terr = &PathError{\"read\", file.name, Errno(e)}\n+\t\tif e != nil {\n+\t\t\terr = &PathError{\"read\", file.name, e}\n \t\t\tbreak\n \t\t}\n \t\tn += m\n@@ -106,8 +106,8 @@ func (file *File) Write(b []byte) (n int, err error) {\n \n \tepipecheck(file, e)\n \n-\tif iserror(e) {\n-\t\terr = &PathError{\"write\", file.name, Errno(e)}\n+\tif e != nil {\n+\t\terr = &PathError{\"write\", file.name, e}\n \t}\n \treturn n, err\n }\n@@ -121,8 +121,8 @@ func (file *File) WriteAt(b []byte, off int64) (n int, err error) {\n \t}\n \tfor len(b) > 0 {\n \t\tm, e := file.pwrite(b, off)\n-\t\tif iserror(e) {\n-\t\t\terr = &PathError{\"write\", file.name, Errno(e)}\n+\t\tif e != nil {\n+\t\t\terr = &PathError{\"write\", file.name, e}\n \t\t\tbreak\n \t\t}\n \t\tn += m\n@@ -138,11 +138,11 @@ func (file *File) WriteAt(b []byte, off int64) (n int, err error) {\n // It returns the new offset and an error, if any.\n func (file *File) Seek(offset int64, whence int) (ret int64, err error) {\n \tr, e := file.seek(offset, whence)\n-\tif !iserror(e) && file.dirinfo != nil && r != 0 {\n+\tif e == nil && file.dirinfo != nil && r != 0 {\n \t\te = syscall.EISDIR\n \t}\n-\tif iserror(e) {\n-\t\treturn 0, &PathError{\"seek\", file.name, Errno(e)}\n+\tif e != nil {\n+\t\treturn 0, &PathError{\"seek\", file.name, e}\n \t}\n \treturn r, nil\n }\n@@ -160,25 +160,25 @@ func (file *File) WriteString(s string) (ret int, err error) {\n // It returns an error, if any.\n func Mkdir(name string, perm uint32) error {\n \te := syscall.Mkdir(name, perm)\n-\tif iserror(e) {\n-\t\treturn &PathError{\"mkdir\", name, Errno(e)}\n+\tif e != nil {\n+\t\treturn &PathError{\"mkdir\", name, e}\n \t}\n \treturn nil\n }\n \n // Chdir changes the current working directory to the named directory.\n func Chdir(dir string) error {\n-\tif e := syscall.Chdir(dir); iserror(e) {\n-\t\treturn &PathError{\"chdir\", dir, Errno(e)}\n+\tif e := syscall.Chdir(dir); e != nil {\n+\t\treturn &PathError{\"chdir\", dir, e}\n \t}\n \treturn nil\n }\n \n // Chdir changes the current working directory to the file,\n // which must be a directory.\n func (f *File) Chdir() error {\n-\tif e := syscall.Fchdir(f.fd); iserror(e) {\n-\t\treturn &PathError{\"chdir\", f.name, Errno(e)}\n+\tif e := syscall.Fchdir(f.fd); e != nil {\n+\t\treturn &PathError{\"chdir\", f.name, e}\n \t}\n \treturn nil\n }"}, {"sha": "42fefa96fe8ed4e0c0d61a439063570aaf06069a", "filename": "libgo/go/os/file_plan9.go", "status": "modified", "additions": 39, "deletions": 22, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Ffile_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Ffile_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_plan9.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -11,6 +11,14 @@ import (\n \n // File represents an open file descriptor.\n type File struct {\n+\t*file\n+}\n+\n+// file is the real representation of *File.\n+// The extra level of indirection ensures that no clients of os\n+// can overwrite this data, which could cause the finalizer\n+// to close the wrong file descriptor.\n+type file struct {\n \tfd      int\n \tname    string\n \tdirinfo *dirInfo // nil unless directory being read\n@@ -29,8 +37,8 @@ func NewFile(fd int, name string) *File {\n \tif fd < 0 {\n \t\treturn nil\n \t}\n-\tf := &File{fd: fd, name: name}\n-\truntime.SetFinalizer(f, (*File).Close)\n+\tf := &File{&file{fd: fd, name: name}}\n+\truntime.SetFinalizer(f.file, (*file).close)\n \treturn f\n }\n \n@@ -41,7 +49,7 @@ type dirInfo struct {\n \tbufp int                   // location of next record in buf.\n }\n \n-func epipecheck(file *File, e syscall.Error) {\n+func epipecheck(file *File, e error) {\n }\n \n // DevNull is the name of the operating system's ``null device.''\n@@ -56,7 +64,7 @@ const DevNull = \"/dev/null\"\n func OpenFile(name string, flag int, perm uint32) (file *File, err error) {\n \tvar (\n \t\tfd     int\n-\t\te      syscall.Error\n+\t\te      error\n \t\tcreate bool\n \t\texcl   bool\n \t\ttrunc  bool\n@@ -85,7 +93,7 @@ func OpenFile(name string, flag int, perm uint32) (file *File, err error) {\n \t} else {\n \t\tfd, e = syscall.Open(name, flag)\n \t\tif e != nil && create {\n-\t\t\tvar e1 syscall.Error\n+\t\t\tvar e1 error\n \t\t\tfd, e1 = syscall.Create(name, flag, perm)\n \t\t\tif e1 == nil {\n \t\t\t\te = nil\n@@ -110,6 +118,10 @@ func OpenFile(name string, flag int, perm uint32) (file *File, err error) {\n // Close closes the File, rendering it unusable for I/O.\n // It returns an error, if any.\n func (file *File) Close() error {\n+\treturn file.file.close()\n+}\n+\n+func (file *file) close() error {\n \tif file == nil || file.fd < 0 {\n \t\treturn Ebadfd\n \t}\n@@ -130,7 +142,7 @@ func (file *File) Close() error {\n // It returns the FileInfo and an error, if any.\n func (f *File) Stat() (fi *FileInfo, err error) {\n \td, err := dirstat(f)\n-\tif iserror(err) {\n+\tif err != nil {\n \t\treturn nil, err\n \t}\n \treturn fileInfoFromStat(new(FileInfo), d), err\n@@ -144,7 +156,7 @@ func (f *File) Truncate(size int64) error {\n \n \td.Length = uint64(size)\n \n-\tif e := syscall.Fwstat(f.fd, pdir(nil, &d)); iserror(e) {\n+\tif e := syscall.Fwstat(f.fd, pdir(nil, &d)); e != nil {\n \t\treturn &PathError{\"truncate\", f.name, e}\n \t}\n \treturn nil\n@@ -157,12 +169,12 @@ func (f *File) Chmod(mode uint32) error {\n \n \td.Null()\n \todir, e := dirstat(f)\n-\tif iserror(e) {\n+\tif e != nil {\n \t\treturn &PathError{\"chmod\", f.name, e}\n \t}\n \n \td.Mode = (odir.Mode & mask) | (mode &^ mask)\n-\tif e := syscall.Fwstat(f.fd, pdir(nil, &d)); iserror(e) {\n+\tif e := syscall.Fwstat(f.fd, pdir(nil, &d)); e != nil {\n \t\treturn &PathError{\"chmod\", f.name, e}\n \t}\n \treturn nil\n@@ -179,42 +191,42 @@ func (f *File) Sync() (err error) {\n \tvar d Dir\n \td.Null()\n \n-\tif e := syscall.Fwstat(f.fd, pdir(nil, &d)); iserror(e) {\n+\tif e := syscall.Fwstat(f.fd, pdir(nil, &d)); e != nil {\n \t\treturn NewSyscallError(\"fsync\", e)\n \t}\n \treturn nil\n }\n \n // read reads up to len(b) bytes from the File.\n // It returns the number of bytes read and an error, if any.\n-func (f *File) read(b []byte) (n int, err syscall.Error) {\n+func (f *File) read(b []byte) (n int, err error) {\n \treturn syscall.Read(f.fd, b)\n }\n \n // pread reads len(b) bytes from the File starting at byte offset off.\n // It returns the number of bytes read and the error, if any.\n // EOF is signaled by a zero count with err set to nil.\n-func (f *File) pread(b []byte, off int64) (n int, err syscall.Error) {\n+func (f *File) pread(b []byte, off int64) (n int, err error) {\n \treturn syscall.Pread(f.fd, b, off)\n }\n \n // write writes len(b) bytes to the File.\n // It returns the number of bytes written and an error, if any.\n-func (f *File) write(b []byte) (n int, err syscall.Error) {\n+func (f *File) write(b []byte) (n int, err error) {\n \treturn syscall.Write(f.fd, b)\n }\n \n // pwrite writes len(b) bytes to the File starting at byte offset off.\n // It returns the number of bytes written and an error, if any.\n-func (f *File) pwrite(b []byte, off int64) (n int, err syscall.Error) {\n+func (f *File) pwrite(b []byte, off int64) (n int, err error) {\n \treturn syscall.Pwrite(f.fd, b, off)\n }\n \n // seek sets the offset for the next Read or Write on file to offset, interpreted\n // according to whence: 0 means relative to the origin of the file, 1 means\n // relative to the current offset, and 2 means relative to the end.\n // It returns the new offset and an error, if any.\n-func (f *File) seek(offset int64, whence int) (ret int64, err syscall.Error) {\n+func (f *File) seek(offset int64, whence int) (ret int64, err error) {\n \treturn syscall.Seek(f.fd, offset, whence)\n }\n \n@@ -226,15 +238,15 @@ func Truncate(name string, size int64) error {\n \n \td.Length = uint64(size)\n \n-\tif e := syscall.Wstat(name, pdir(nil, &d)); iserror(e) {\n+\tif e := syscall.Wstat(name, pdir(nil, &d)); e != nil {\n \t\treturn &PathError{\"truncate\", name, e}\n \t}\n \treturn nil\n }\n \n // Remove removes the named file or directory.\n func Remove(name string) error {\n-\tif e := syscall.Remove(name); iserror(e) {\n+\tif e := syscall.Remove(name); e != nil {\n \t\treturn &PathError{\"remove\", name, e}\n \t}\n \treturn nil\n@@ -247,7 +259,7 @@ func Rename(oldname, newname string) error {\n \n \td.Name = newname\n \n-\tif e := syscall.Wstat(oldname, pdir(nil, &d)); iserror(e) {\n+\tif e := syscall.Wstat(oldname, pdir(nil, &d)); e != nil {\n \t\treturn &PathError{\"rename\", oldname, e}\n \t}\n \treturn nil\n@@ -260,12 +272,12 @@ func Chmod(name string, mode uint32) error {\n \n \td.Null()\n \todir, e := dirstat(name)\n-\tif iserror(e) {\n+\tif e != nil {\n \t\treturn &PathError{\"chmod\", name, e}\n \t}\n \n \td.Mode = (odir.Mode & mask) | (mode &^ mask)\n-\tif e := syscall.Wstat(name, pdir(nil, &d)); iserror(e) {\n+\tif e := syscall.Wstat(name, pdir(nil, &d)); e != nil {\n \t\treturn &PathError{\"chmod\", name, e}\n \t}\n \treturn nil\n@@ -284,7 +296,7 @@ func Chtimes(name string, atimeNs int64, mtimeNs int64) error {\n \td.Atime = uint32(atimeNs / 1e9)\n \td.Mtime = uint32(mtimeNs / 1e9)\n \n-\tif e := syscall.Wstat(name, pdir(nil, &d)); iserror(e) {\n+\tif e := syscall.Wstat(name, pdir(nil, &d)); e != nil {\n \t\treturn &PathError{\"chtimes\", name, e}\n \t}\n \treturn nil\n@@ -294,7 +306,7 @@ func Pipe() (r *File, w *File, err error) {\n \tvar p [2]int\n \n \tsyscall.ForkLock.RLock()\n-\tif e := syscall.Pipe(p[0:]); iserror(e) {\n+\tif e := syscall.Pipe(p[0:]); e != nil {\n \t\tsyscall.ForkLock.RUnlock()\n \t\treturn nil, nil, NewSyscallError(\"pipe\", e)\n \t}\n@@ -329,3 +341,8 @@ func Lchown(name string, uid, gid int) error {\n func (f *File) Chown(uid, gid int) error {\n \treturn EPLAN9\n }\n+\n+// TempDir returns the default directory to use for temporary files.\n+func TempDir() string {\n+\treturn \"/tmp\"\n+}"}, {"sha": "c80d3df5e50a5ffc64783913f41664b76f07c834", "filename": "libgo/go/os/file_posix.go", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Ffile_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Ffile_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_posix.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -12,7 +12,7 @@ import (\n \n func sigpipe() // implemented in package runtime\n \n-func epipecheck(file *File, e int) {\n+func epipecheck(file *File, e error) {\n \tif e == syscall.EPIPE {\n \t\tfile.nepipe++\n \t\tif file.nepipe >= 10 {\n@@ -30,11 +30,11 @@ func Remove(name string) error {\n \t// Try both: it is cheaper on average than\n \t// doing a Stat plus the right one.\n \te := syscall.Unlink(name)\n-\tif !iserror(e) {\n+\tif e == nil {\n \t\treturn nil\n \t}\n \te1 := syscall.Rmdir(name)\n-\tif !iserror(e1) {\n+\tif e1 == nil {\n \t\treturn nil\n \t}\n \n@@ -53,7 +53,7 @@ func Remove(name string) error {\n \tif e1 != syscall.ENOTDIR {\n \t\te = e1\n \t}\n-\treturn &PathError{\"remove\", name, Errno(e)}\n+\treturn &PathError{\"remove\", name, e}\n }\n \n // LinkError records an error during a link or symlink or rename\n@@ -72,17 +72,17 @@ func (e *LinkError) Error() string {\n // Link creates a hard link.\n func Link(oldname, newname string) error {\n \te := syscall.Link(oldname, newname)\n-\tif iserror(e) {\n-\t\treturn &LinkError{\"link\", oldname, newname, Errno(e)}\n+\tif e != nil {\n+\t\treturn &LinkError{\"link\", oldname, newname, e}\n \t}\n \treturn nil\n }\n \n // Symlink creates a symbolic link.\n func Symlink(oldname, newname string) error {\n \te := syscall.Symlink(oldname, newname)\n-\tif iserror(e) {\n-\t\treturn &LinkError{\"symlink\", oldname, newname, Errno(e)}\n+\tif e != nil {\n+\t\treturn &LinkError{\"symlink\", oldname, newname, e}\n \t}\n \treturn nil\n }\n@@ -93,8 +93,8 @@ func Readlink(name string) (string, error) {\n \tfor len := 128; ; len *= 2 {\n \t\tb := make([]byte, len)\n \t\tn, e := syscall.Readlink(name, b)\n-\t\tif iserror(e) {\n-\t\t\treturn \"\", &PathError{\"readlink\", name, Errno(e)}\n+\t\tif e != nil {\n+\t\t\treturn \"\", &PathError{\"readlink\", name, e}\n \t\t}\n \t\tif n < len {\n \t\t\treturn string(b[0:n]), nil\n@@ -107,60 +107,60 @@ func Readlink(name string) (string, error) {\n // Rename renames a file.\n func Rename(oldname, newname string) error {\n \te := syscall.Rename(oldname, newname)\n-\tif iserror(e) {\n-\t\treturn &LinkError{\"rename\", oldname, newname, Errno(e)}\n+\tif e != nil {\n+\t\treturn &LinkError{\"rename\", oldname, newname, e}\n \t}\n \treturn nil\n }\n \n // Chmod changes the mode of the named file to mode.\n // If the file is a symbolic link, it changes the mode of the link's target.\n func Chmod(name string, mode uint32) error {\n-\tif e := syscall.Chmod(name, mode); iserror(e) {\n-\t\treturn &PathError{\"chmod\", name, Errno(e)}\n+\tif e := syscall.Chmod(name, mode); e != nil {\n+\t\treturn &PathError{\"chmod\", name, e}\n \t}\n \treturn nil\n }\n \n // Chmod changes the mode of the file to mode.\n func (f *File) Chmod(mode uint32) error {\n-\tif e := syscall.Fchmod(f.fd, mode); iserror(e) {\n-\t\treturn &PathError{\"chmod\", f.name, Errno(e)}\n+\tif e := syscall.Fchmod(f.fd, mode); e != nil {\n+\t\treturn &PathError{\"chmod\", f.name, e}\n \t}\n \treturn nil\n }\n \n // Chown changes the numeric uid and gid of the named file.\n // If the file is a symbolic link, it changes the uid and gid of the link's target.\n func Chown(name string, uid, gid int) error {\n-\tif e := syscall.Chown(name, uid, gid); iserror(e) {\n-\t\treturn &PathError{\"chown\", name, Errno(e)}\n+\tif e := syscall.Chown(name, uid, gid); e != nil {\n+\t\treturn &PathError{\"chown\", name, e}\n \t}\n \treturn nil\n }\n \n // Lchown changes the numeric uid and gid of the named file.\n // If the file is a symbolic link, it changes the uid and gid of the link itself.\n func Lchown(name string, uid, gid int) error {\n-\tif e := syscall.Lchown(name, uid, gid); iserror(e) {\n-\t\treturn &PathError{\"lchown\", name, Errno(e)}\n+\tif e := syscall.Lchown(name, uid, gid); e != nil {\n+\t\treturn &PathError{\"lchown\", name, e}\n \t}\n \treturn nil\n }\n \n // Chown changes the numeric uid and gid of the named file.\n func (f *File) Chown(uid, gid int) error {\n-\tif e := syscall.Fchown(f.fd, uid, gid); iserror(e) {\n-\t\treturn &PathError{\"chown\", f.name, Errno(e)}\n+\tif e := syscall.Fchown(f.fd, uid, gid); e != nil {\n+\t\treturn &PathError{\"chown\", f.name, e}\n \t}\n \treturn nil\n }\n \n // Truncate changes the size of the file.\n // It does not change the I/O offset.\n func (f *File) Truncate(size int64) error {\n-\tif e := syscall.Ftruncate(f.fd, size); iserror(e) {\n-\t\treturn &PathError{\"truncate\", f.name, Errno(e)}\n+\tif e := syscall.Ftruncate(f.fd, size); e != nil {\n+\t\treturn &PathError{\"truncate\", f.name, e}\n \t}\n \treturn nil\n }\n@@ -172,7 +172,7 @@ func (file *File) Sync() (err error) {\n \tif file == nil {\n \t\treturn EINVAL\n \t}\n-\tif e := syscall.Fsync(file.fd); iserror(e) {\n+\tif e := syscall.Fsync(file.fd); e != nil {\n \t\treturn NewSyscallError(\"fsync\", e)\n \t}\n \treturn nil\n@@ -188,8 +188,8 @@ func Chtimes(name string, atime_ns int64, mtime_ns int64) error {\n \tvar utimes [2]syscall.Timeval\n \tutimes[0] = syscall.NsecToTimeval(atime_ns)\n \tutimes[1] = syscall.NsecToTimeval(mtime_ns)\n-\tif e := syscall.Utimes(name, utimes[0:]); iserror(e) {\n-\t\treturn &PathError{\"chtimes\", name, Errno(e)}\n+\tif e := syscall.Utimes(name, utimes[0:]); e != nil {\n+\t\treturn &PathError{\"chtimes\", name, e}\n \t}\n \treturn nil\n }"}, {"sha": "0bf31ecb9a74258abf8a4b1768ea58e3421c114c", "filename": "libgo/go/os/file_unix.go", "status": "modified", "additions": 43, "deletions": 22, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Ffile_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Ffile_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_unix.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -13,6 +13,14 @@ import (\n \n // File represents an open file descriptor.\n type File struct {\n+\t*file\n+}\n+\n+// file is the real representation of *File.\n+// The extra level of indirection ensures that no clients of os\n+// can overwrite this data, which could cause the finalizer\n+// to close the wrong file descriptor.\n+type file struct {\n \tfd      int\n \tname    string\n \tdirinfo *dirInfo // nil unless directory being read\n@@ -32,8 +40,8 @@ func NewFile(fd int, name string) *File {\n \tif fd < 0 {\n \t\treturn nil\n \t}\n-\tf := &File{fd: fd, name: name}\n-\truntime.SetFinalizer(f, (*File).Close)\n+\tf := &File{&file{fd: fd, name: name}}\n+\truntime.SetFinalizer(f.file, (*file).close)\n \treturn f\n }\n \n@@ -54,8 +62,8 @@ const DevNull = \"/dev/null\"\n // It returns the File and an error, if any.\n func OpenFile(name string, flag int, perm uint32) (file *File, err error) {\n \tr, e := syscall.Open(name, flag|syscall.O_CLOEXEC, perm)\n-\tif e != 0 {\n-\t\treturn nil, &PathError{\"open\", name, Errno(e)}\n+\tif e != nil {\n+\t\treturn nil, &PathError{\"open\", name, e}\n \t}\n \n \t// There's a race here with fork/exec, which we are\n@@ -70,17 +78,21 @@ func OpenFile(name string, flag int, perm uint32) (file *File, err error) {\n // Close closes the File, rendering it unusable for I/O.\n // It returns an error, if any.\n func (file *File) Close() error {\n+\treturn file.file.close()\n+}\n+\n+func (file *file) close() error {\n \tif file == nil || file.fd < 0 {\n \t\treturn EINVAL\n \t}\n \tvar err error\n-\tif e := syscall.Close(file.fd); e != 0 {\n-\t\terr = &PathError{\"close\", file.name, Errno(e)}\n+\tif e := syscall.Close(file.fd); e != nil {\n+\t\terr = &PathError{\"close\", file.name, e}\n \t}\n \n \tif file.dirinfo != nil {\n \t\tif libc_closedir(file.dirinfo.dir) < 0 && err == nil {\n-\t\t\terr = &PathError{\"closedir\", file.name, Errno(syscall.GetErrno())}\n+\t\t\terr = &PathError{\"closedir\", file.name, syscall.GetErrno()}\n \t\t}\n \t}\n \n@@ -96,8 +108,8 @@ func (file *File) Close() error {\n func (file *File) Stat() (fi *FileInfo, err error) {\n \tvar stat syscall.Stat_t\n \te := syscall.Fstat(file.fd, &stat)\n-\tif e != 0 {\n-\t\treturn nil, &PathError{\"stat\", file.name, Errno(e)}\n+\tif e != nil {\n+\t\treturn nil, &PathError{\"stat\", file.name, e}\n \t}\n \treturn fileInfoFromStat(file.name, new(FileInfo), &stat, &stat), nil\n }\n@@ -110,13 +122,13 @@ func (file *File) Stat() (fi *FileInfo, err error) {\n func Stat(name string) (fi *FileInfo, err error) {\n \tvar lstat, stat syscall.Stat_t\n \te := syscall.Lstat(name, &lstat)\n-\tif iserror(e) {\n-\t\treturn nil, &PathError{\"stat\", name, Errno(e)}\n+\tif e != nil {\n+\t\treturn nil, &PathError{\"stat\", name, e}\n \t}\n \tstatp := &lstat\n \tif lstat.Mode&syscall.S_IFMT == syscall.S_IFLNK {\n \t\te := syscall.Stat(name, &stat)\n-\t\tif !iserror(e) {\n+\t\tif e == nil {\n \t\t\tstatp = &stat\n \t\t}\n \t}\n@@ -129,8 +141,8 @@ func Stat(name string) (fi *FileInfo, err error) {\n func Lstat(name string) (fi *FileInfo, err error) {\n \tvar stat syscall.Stat_t\n \te := syscall.Lstat(name, &stat)\n-\tif iserror(e) {\n-\t\treturn nil, &PathError{\"lstat\", name, Errno(e)}\n+\tif e != nil {\n+\t\treturn nil, &PathError{\"lstat\", name, e}\n \t}\n \treturn fileInfoFromStat(name, new(FileInfo), &stat, &stat), nil\n }\n@@ -171,42 +183,42 @@ func (file *File) Readdir(n int) (fi []FileInfo, err error) {\n \n // read reads up to len(b) bytes from the File.\n // It returns the number of bytes read and an error, if any.\n-func (f *File) read(b []byte) (n int, err int) {\n+func (f *File) read(b []byte) (n int, err error) {\n \treturn syscall.Read(f.fd, b)\n }\n \n // pread reads len(b) bytes from the File starting at byte offset off.\n // It returns the number of bytes read and the error, if any.\n // EOF is signaled by a zero count with err set to 0.\n-func (f *File) pread(b []byte, off int64) (n int, err int) {\n+func (f *File) pread(b []byte, off int64) (n int, err error) {\n \treturn syscall.Pread(f.fd, b, off)\n }\n \n // write writes len(b) bytes to the File.\n // It returns the number of bytes written and an error, if any.\n-func (f *File) write(b []byte) (n int, err int) {\n+func (f *File) write(b []byte) (n int, err error) {\n \treturn syscall.Write(f.fd, b)\n }\n \n // pwrite writes len(b) bytes to the File starting at byte offset off.\n // It returns the number of bytes written and an error, if any.\n-func (f *File) pwrite(b []byte, off int64) (n int, err int) {\n+func (f *File) pwrite(b []byte, off int64) (n int, err error) {\n \treturn syscall.Pwrite(f.fd, b, off)\n }\n \n // seek sets the offset for the next Read or Write on file to offset, interpreted\n // according to whence: 0 means relative to the origin of the file, 1 means\n // relative to the current offset, and 2 means relative to the end.\n // It returns the new offset and an error, if any.\n-func (f *File) seek(offset int64, whence int) (ret int64, err int) {\n+func (f *File) seek(offset int64, whence int) (ret int64, err error) {\n \treturn syscall.Seek(f.fd, offset, whence)\n }\n \n // Truncate changes the size of the named file.\n // If the file is a symbolic link, it changes the size of the link's target.\n func Truncate(name string, size int64) error {\n-\tif e := syscall.Truncate(name, size); e != 0 {\n-\t\treturn &PathError{\"truncate\", name, Errno(e)}\n+\tif e := syscall.Truncate(name, size); e != nil {\n+\t\treturn &PathError{\"truncate\", name, e}\n \t}\n \treturn nil\n }\n@@ -237,7 +249,7 @@ func Pipe() (r *File, w *File, err error) {\n \t// See ../syscall/exec.go for description of lock.\n \tsyscall.ForkLock.RLock()\n \te := syscall.Pipe(p[0:])\n-\tif iserror(e) {\n+\tif e != nil {\n \t\tsyscall.ForkLock.RUnlock()\n \t\treturn nil, nil, NewSyscallError(\"pipe\", e)\n \t}\n@@ -247,3 +259,12 @@ func Pipe() (r *File, w *File, err error) {\n \n \treturn NewFile(p[0], \"|0\"), NewFile(p[1], \"|1\"), nil\n }\n+\n+// TempDir returns the default directory to use for temporary files.\n+func TempDir() string {\n+\tdir := Getenv(\"TMPDIR\")\n+\tif dir == \"\" {\n+\t\tdir = \"/tmp\"\n+\t}\n+\treturn dir\n+}"}, {"sha": "170f7331c6e4547f1229dbbac220c983b5392f26", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -18,7 +18,7 @@ import (\n \n var dot = []string{\n \t\"dir_unix.go\",\n-\t\"env_unix.go\",\n+\t\"env.go\",\n \t\"error.go\",\n \t\"file.go\",\n \t\"os_test.go\",\n@@ -940,11 +940,6 @@ func TestHostname(t *testing.T) {\n \t\treturn\n \t}\n \n-\t// TODO(jsing): Fix nametomib() on OpenBSD\n-\tif syscall.OS == \"openbsd\" {\n-\t\treturn\n-\t}\n-\n \t// Check internal Hostname() against the output of /bin/hostname.\n \t// Allow that the internal Hostname returns a Fully Qualified Domain Name\n \t// and the /bin/hostname only returns the first component"}, {"sha": "61545f4456a316aa8abec19d2571d299409a2a01", "filename": "libgo/go/os/proc.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fproc.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -8,8 +8,8 @@ package os\n \n import \"syscall\"\n \n-var Args []string // provided by runtime\n-var Envs []string // provided by runtime\n+// Args hold the command-line arguments, starting with the program name.\n+var Args []string\n \n // Getuid returns the numeric user id of the caller.\n func Getuid() int { return syscall.Getuid() }"}, {"sha": "e4a1dbbaea394f6af4a81edeed5c296ae9df4148", "filename": "libgo/go/os/stat_plan9.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fstat_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fstat_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fstat_plan9.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -34,7 +34,7 @@ func dirstat(arg interface{}) (d *Dir, err error) {\n \t\tbuf := make([]byte, nd)\n \n \t\tvar n int\n-\t\tvar e syscall.Error\n+\t\tvar e error\n \n \t\tswitch syscallArg := arg.(type) {\n \t\tcase *File:\n@@ -72,7 +72,7 @@ func dirstat(arg interface{}) (d *Dir, err error) {\n // Stat returns a FileInfo structure describing the named file and an error, if any.\n func Stat(name string) (fi *FileInfo, err error) {\n \td, err := dirstat(name)\n-\tif iserror(err) {\n+\tif err != nil {\n \t\treturn nil, err\n \t}\n \treturn fileInfoFromStat(new(FileInfo), d), err\n@@ -83,7 +83,7 @@ func Stat(name string) (fi *FileInfo, err error) {\n // the returned FileInfo describes the symbolic link.  Lstat makes no attempt to follow the link.\n func Lstat(name string) (fi *FileInfo, err error) {\n \td, err := dirstat(name)\n-\tif iserror(err) {\n+\tif err != nil {\n \t\treturn nil, err\n \t}\n \treturn fileInfoFromStat(new(FileInfo), d), err"}, {"sha": "c6a6de5c816f6d39826afa182610022a4a36ab2c", "filename": "libgo/go/os/sys_bsd.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fsys_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fsys_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fsys_bsd.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -12,10 +12,9 @@ package os\n import \"syscall\"\n \n func Hostname() (name string, err error) {\n-\tvar errno int\n-\tname, errno = syscall.Sysctl(\"kern.hostname\")\n-\tif errno != 0 {\n-\t\treturn \"\", NewSyscallError(\"sysctl kern.hostname\", errno)\n+\tname, err = syscall.Sysctl(\"kern.hostname\")\n+\tif err != nil {\n+\t\treturn \"\", NewSyscallError(\"sysctl kern.hostname\", err)\n \t}\n \treturn name, nil\n }"}, {"sha": "eb564e57a6cc05baf2171bb130cd08e931e653f7", "filename": "libgo/go/os/time.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ftime.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -12,7 +12,7 @@ import \"syscall\"\n // time is the Unix epoch.\n func Time() (sec int64, nsec int64, err error) {\n \tvar tv syscall.Timeval\n-\tif e := syscall.Gettimeofday(&tv); iserror(e) {\n+\tif e := syscall.Gettimeofday(&tv); e != nil {\n \t\treturn 0, 0, NewSyscallError(\"gettimeofday\", e)\n \t}\n \treturn int64(tv.Sec), int64(tv.Usec) * 1000, err"}, {"sha": "89886cb03cf2c0f9d0f5628eab30e08abb9b1441", "filename": "libgo/go/os/user/lookup_unix.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fuser%2Flookup_unix.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -8,7 +8,6 @@ package user\n \n import (\n \t\"fmt\"\n-\t\"os\"\n \t\"strings\"\n \t\"syscall\"\n \t\"unsafe\"\n@@ -70,7 +69,7 @@ func lookup(uid int, username string, lookupByName bool) (*User, error) {\n \t\t\tbufSize,\n \t\t\t&result)\n \t\tif rv != 0 {\n-\t\t\treturn nil, fmt.Errorf(\"user: lookup username %s: %s\", username, os.Errno(syscall.GetErrno()))\n+\t\t\treturn nil, fmt.Errorf(\"user: lookup username %s: %s\", username, syscall.GetErrno())\n \t\t}\n \t\tif result == nil {\n \t\t\treturn nil, UnknownUserError(username)\n@@ -82,7 +81,7 @@ func lookup(uid int, username string, lookupByName bool) (*User, error) {\n \t\t\tbufSize,\n \t\t\t&result)\n \t\tif rv != 0 {\n-\t\t\treturn nil, fmt.Errorf(\"user: lookup userid %d: %s\", uid, os.Errno(syscall.GetErrno()))\n+\t\t\treturn nil, fmt.Errorf(\"user: lookup userid %d: %s\", uid, syscall.GetErrno())\n \t\t}\n \t\tif result == nil {\n \t\t\treturn nil, UnknownUserIdError(uid)"}, {"sha": "cf31d1ba39d326c253b3a6020a1788e8240db840", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 48, "deletions": 7, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -16,6 +16,13 @@ import (\n \t\"unsafe\"\n )\n \n+func TestBool(t *testing.T) {\n+\tv := ValueOf(true)\n+\tif v.Bool() != true {\n+\t\tt.Fatal(\"ValueOf(true).Bool() = false\")\n+\t}\n+}\n+\n type integer int\n type T struct {\n \ta int\n@@ -215,7 +222,8 @@ func TestTypes(t *testing.T) {\n \n func TestSet(t *testing.T) {\n \tfor i, tt := range valueTests {\n-\t\tv := ValueOf(tt.i).Elem()\n+\t\tv := ValueOf(tt.i)\n+\t\tv = v.Elem()\n \t\tswitch v.Kind() {\n \t\tcase Int:\n \t\t\tv.SetInt(132)\n@@ -651,6 +659,14 @@ var deepEqualTests = []DeepEqualTest{\n \t{nil, 1, false},\n \t{1, nil, false},\n \n+\t// Nil vs empty: not the same.\n+\t{[]int{}, []int(nil), false},\n+\t{[]int{}, []int{}, true},\n+\t{[]int(nil), []int(nil), true},\n+\t{map[int]int{}, map[int]int(nil), false},\n+\t{map[int]int{}, map[int]int{}, true},\n+\t{map[int]int(nil), map[int]int(nil), true},\n+\n \t// Mismatched types\n \t{1, 1.0, false},\n \t{int32(1), int64(1), false},\n@@ -1092,21 +1108,38 @@ func TestMethod(t *testing.T) {\n \t}\n \n \t// Curried method of value.\n-\ti = ValueOf(p).Method(1).Call([]Value{ValueOf(10)})[0].Int()\n+\ttfunc := TypeOf(func(int) int(nil))\n+\tv := ValueOf(p).Method(1)\n+\tif tt := v.Type(); tt != tfunc {\n+\t\tt.Errorf(\"Value Method Type is %s; want %s\", tt, tfunc)\n+\t}\n+\ti = v.Call([]Value{ValueOf(10)})[0].Int()\n \tif i != 250 {\n \t\tt.Errorf(\"Value Method returned %d; want 250\", i)\n \t}\n-\ti = ValueOf(p).MethodByName(\"Dist\").Call([]Value{ValueOf(10)})[0].Int()\n+\tv = ValueOf(p).MethodByName(\"Dist\")\n+\tif tt := v.Type(); tt != tfunc {\n+\t\tt.Errorf(\"Value MethodByName Type is %s; want %s\", tt, tfunc)\n+\t}\n+\ti = v.Call([]Value{ValueOf(10)})[0].Int()\n \tif i != 250 {\n \t\tt.Errorf(\"Value MethodByName returned %d; want 250\", i)\n \t}\n \n \t// Curried method of pointer.\n-\ti = ValueOf(&p).Method(1).Call([]Value{ValueOf(10)})[0].Int()\n+\tv = ValueOf(&p).Method(1)\n+\tif tt := v.Type(); tt != tfunc {\n+\t\tt.Errorf(\"Pointer Value Method Type is %s; want %s\", tt, tfunc)\n+\t}\n+\ti = v.Call([]Value{ValueOf(10)})[0].Int()\n \tif i != 250 {\n \t\tt.Errorf(\"Pointer Value Method returned %d; want 250\", i)\n \t}\n-\ti = ValueOf(&p).MethodByName(\"Dist\").Call([]Value{ValueOf(10)})[0].Int()\n+\tv = ValueOf(&p).MethodByName(\"Dist\")\n+\tif tt := v.Type(); tt != tfunc {\n+\t\tt.Errorf(\"Pointer Value MethodByName Type is %s; want %s\", tt, tfunc)\n+\t}\n+\ti = v.Call([]Value{ValueOf(10)})[0].Int()\n \tif i != 250 {\n \t\tt.Errorf(\"Pointer Value MethodByName returned %d; want 250\", i)\n \t}\n@@ -1121,11 +1154,19 @@ func TestMethod(t *testing.T) {\n \t\t}\n \t}{p}\n \tpv := ValueOf(s).Field(0)\n-\ti = pv.Method(0).Call([]Value{ValueOf(10)})[0].Int()\n+\tv = pv.Method(0)\n+\tif tt := v.Type(); tt != tfunc {\n+\t\tt.Errorf(\"Interface Method Type is %s; want %s\", tt, tfunc)\n+\t}\n+\ti = v.Call([]Value{ValueOf(10)})[0].Int()\n \tif i != 250 {\n \t\tt.Errorf(\"Interface Method returned %d; want 250\", i)\n \t}\n-\ti = pv.MethodByName(\"Dist\").Call([]Value{ValueOf(10)})[0].Int()\n+\tv = pv.MethodByName(\"Dist\")\n+\tif tt := v.Type(); tt != tfunc {\n+\t\tt.Errorf(\"Interface MethodByName Type is %s; want %s\", tt, tfunc)\n+\t}\n+\ti = v.Call([]Value{ValueOf(10)})[0].Int()\n \tif i != 250 {\n \t\tt.Errorf(\"Interface MethodByName returned %d; want 250\", i)\n \t}"}, {"sha": "df5ec0a6099576a27ecc83282ed3e346a8ebb015", "filename": "libgo/go/reflect/deepequal.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Freflect%2Fdeepequal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Freflect%2Fdeepequal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fdeepequal.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -69,6 +69,9 @@ func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) (b bool\n \t\t}\n \t\treturn true\n \tcase Slice:\n+\t\tif v1.IsNil() != v2.IsNil() {\n+\t\t\treturn false\n+\t\t}\n \t\tif v1.Len() != v2.Len() {\n \t\t\treturn false\n \t\t}\n@@ -93,6 +96,9 @@ func deepValueEqual(v1, v2 Value, visited map[uintptr]*visit, depth int) (b bool\n \t\t}\n \t\treturn true\n \tcase Map:\n+\t\tif v1.IsNil() != v2.IsNil() {\n+\t\t\treturn false\n+\t\t}\n \t\tif v1.Len() != v2.Len() {\n \t\t\treturn false\n \t\t}"}, {"sha": "07cc0f5ba401be24e205854b1c6aa760f249ecf3", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -188,7 +188,7 @@ type Type interface {\n \n // A Kind represents the specific kind of type that a Type represents.\n // The zero Kind is not a valid kind.\n-type Kind uint8\n+type Kind uint\n \n const (\n \tInvalid Kind = iota\n@@ -455,15 +455,16 @@ func (t *uncommonType) Method(i int) (m Method) {\n \tif p.name != nil {\n \t\tm.Name = *p.name\n \t}\n-\tflag := uint32(0)\n+\tfl := flag(Func) << flagKindShift\n \tif p.pkgPath != nil {\n \t\tm.PkgPath = *p.pkgPath\n-\t\tflag |= flagRO\n+\t\tfl |= flagRO\n \t}\n-\tm.Type = toType(p.typ)\n+\tmt := toCommonType(p.typ)\n+\tm.Type = mt.toType()\n \tx := new(unsafe.Pointer)\n \t*x = p.tfn\n-\tm.Func = valueFromIword(flag, m.Type, iword(uintptr(unsafe.Pointer(x))))\n+\tm.Func = Value{mt, unsafe.Pointer(x), fl|flagIndir}\n \tm.Index = i\n \treturn\n }\n@@ -769,7 +770,7 @@ func (t *structType) Field(i int) (f StructField) {\n \tif i < 0 || i >= len(t.fields) {\n \t\treturn\n \t}\n-\tp := t.fields[i]\n+\tp := &t.fields[i]\n \tf.Type = toType(p.typ)\n \tif p.name != nil {\n \t\tf.Name = *p.name\n@@ -868,10 +869,12 @@ L:\n \n \tif n == 1 {\n \t\t// Found matching field.\n-\t\tif len(ff.Index) <= depth {\n+\t\tif depth >= len(ff.Index) {\n \t\t\tff.Index = make([]int, depth+1)\n \t\t}\n-\t\tff.Index[depth] = fi\n+\t\tif len(ff.Index) > 1 {\n+\t\t\tff.Index[depth] = fi\n+\t\t}\n \t} else {\n \t\t// None or more than one matching field found.\n \t\tfd = inf\n@@ -903,9 +906,6 @@ func toCommonType(p *runtime.Type) *commonType {\n \t\treturn nil\n \t}\n \tx := unsafe.Pointer(p)\n-\tif uintptr(x)&reflectFlags != 0 {\n-\t\tpanic(\"reflect: invalid interface value\")\n-\t}\n \treturn (*commonType)(x)\n }\n \n@@ -967,10 +967,12 @@ func (t *commonType) runtimeType() *runtime.Type {\n // PtrTo returns the pointer type with element t.\n // For example, if t represents type Foo, PtrTo(t) represents *Foo.\n func PtrTo(t Type) Type {\n-\t// If t records its pointer-to type, use it.\n-\tct := t.(*commonType)\n+\treturn t.(*commonType).ptrTo()\n+}\n+\n+func (ct *commonType) ptrTo() *commonType {\n \tif p := ct.ptrToThis; p != nil {\n-\t\treturn toType(p)\n+\t\treturn toCommonType(p)\n \t}\n \n \t// Otherwise, synthesize one.\n@@ -982,7 +984,7 @@ func PtrTo(t Type) Type {\n \tif m := ptrMap.m; m != nil {\n \t\tif p := m[ct]; p != nil {\n \t\t\tptrMap.RUnlock()\n-\t\t\treturn p.commonType.toType()\n+\t\t\treturn &p.commonType\n \t\t}\n \t}\n \tptrMap.RUnlock()\n@@ -994,7 +996,7 @@ func PtrTo(t Type) Type {\n \tif p != nil {\n \t\t// some other goroutine won the race and created it\n \t\tptrMap.Unlock()\n-\t\treturn p\n+\t\treturn &p.commonType\n \t}\n \n \trt := (*runtime.Type)(unsafe.Pointer(ct))\n@@ -1024,7 +1026,7 @@ func PtrTo(t Type) Type {\n \n \tptrMap.m[ct] = p\n \tptrMap.Unlock()\n-\treturn p.commonType.toType()\n+\treturn &p.commonType\n }\n \n func (t *commonType) Implements(u Type) bool {"}, {"sha": "b57ed462c84cb7ad12923355a02394e3c91366ba", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 683, "deletions": 713, "changes": 1396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"unsafe\"\n )\n \n+const bigEndian = false // can be smarter if we find a big-endian machine\n const ptrSize = unsafe.Sizeof((*byte)(nil))\n const cannotSet = \"cannot set value obtained from unexported struct field\"\n \n@@ -53,14 +54,54 @@ func memmove(adst, asrc unsafe.Pointer, n uintptr) {\n // its String method returns \"<invalid Value>\", and all other methods panic.\n // Most functions and methods never return an invalid value.\n // If one does, its documentation states the conditions explicitly.\n-//\n-// The fields of Value are exported so that clients can copy and\n-// pass Values around, but they should not be edited or inspected\n-// directly.  A future language change may make it possible not to\n-// export these fields while still keeping Values usable as values.\n type Value struct {\n-\tInternal       interface{}\n-\tInternalMethod int\n+\t// typ holds the type of the value represented by a Value.\n+\ttyp *commonType\n+\n+\t// val holds the 1-word representation of the value.\n+\t// If flag's flagIndir bit is set, then val is a pointer to the data.\n+\t// Otherwise val is a word holding the actual data.\n+\t// When the data is smaller than a word, it begins at\n+\t// the first byte (in the memory address sense) of val.\n+\t// We use unsafe.Pointer so that the garbage collector\n+\t// knows that val could be a pointer.\n+\tval unsafe.Pointer\n+\n+\t// flag holds metadata about the value.\n+\t// The lowest bits are flag bits:\n+\t//\t- flagRO: obtained via unexported field, so read-only\n+\t//\t- flagIndir: val holds a pointer to the data\n+\t//\t- flagAddr: v.CanAddr is true (implies flagIndir)\n+\t//\t- flagMethod: v is a method value.\n+\t// The next five bits give the Kind of the value.\n+\t// This repeats typ.Kind() except for method values.\n+\t// The remaining 23+ bits give a method number for method values.\n+\t// If flag.kind() != Func, code can assume that flagMethod is unset.\n+\t// If typ.size > ptrSize, code can assume that flagIndir is set.\n+\tflag\n+\n+\t// A method value represents a curried method invocation\n+\t// like r.Read for some receiver r.  The typ+val+flag bits describe\n+\t// the receiver r, but the flag's Kind bits say Func (methods are\n+\t// functions), and the top bits of the flag give the method number\n+\t// in r's type's method table.\n+}\n+\n+type flag uintptr\n+\n+const (\n+\tflagRO flag = 1 << iota\n+\tflagIndir\n+\tflagAddr\n+\tflagMethod\n+\tflagKindShift        = iota\n+\tflagKindWidth        = 5 // there are 27 kinds\n+\tflagKindMask    flag = 1<<flagKindWidth - 1\n+\tflagMethodShift      = flagKindShift + flagKindWidth\n+)\n+\n+func (f flag) kind() Kind {\n+\treturn Kind((f >> flagKindShift) & flagKindMask)\n }\n \n // A ValueError occurs when a Value method is invoked on\n@@ -92,17 +133,30 @@ func methodName() string {\n // An iword is the word that would be stored in an\n // interface to represent a given value v.  Specifically, if v is\n // bigger than a pointer, its word is a pointer to v's data.\n-// Otherwise, its word is a zero uintptr with the data stored\n-// in the leading bytes.\n-type iword uintptr\n+// Otherwise, its word holds the data stored\n+// in its leading bytes (so is not a pointer).\n+// Because the value sometimes holds a pointer, we use\n+// unsafe.Pointer to represent it, so that if iword appears\n+// in a struct, the garbage collector knows that might be\n+// a pointer.\n+type iword unsafe.Pointer\n+\n+func (v Value) iword() iword {\n+\tif v.flag&flagIndir != 0 && (v.kind() == Ptr || v.kind() == UnsafePointer) {\n+\t\t// Have indirect but want direct word.\n+\t\treturn loadIword(v.val, v.typ.size)\n+\t}\n+\treturn iword(v.val)\n+}\n \n-func loadIword(p unsafe.Pointer, size uintptr) iword {\n+// loadIword loads n bytes at p from memory into an iword.\n+func loadIword(p unsafe.Pointer, n uintptr) iword {\n \t// Run the copy ourselves instead of calling memmove\n-\t// to avoid moving v to the heap.\n-\tw := iword(0)\n-\tswitch size {\n+\t// to avoid moving w to the heap.\n+\tvar w iword\n+\tswitch n {\n \tdefault:\n-\t\tpanic(\"reflect: internal error: loadIword of \" + strconv.Itoa(int(size)) + \"-byte value\")\n+\t\tpanic(\"reflect: internal error: loadIword of \" + strconv.Itoa(int(n)) + \"-byte value\")\n \tcase 0:\n \tcase 1:\n \t\t*(*uint8)(unsafe.Pointer(&w)) = *(*uint8)(p)\n@@ -124,12 +178,13 @@ func loadIword(p unsafe.Pointer, size uintptr) iword {\n \treturn w\n }\n \n-func storeIword(p unsafe.Pointer, w iword, size uintptr) {\n+// storeIword stores n bytes from w into p.\n+func storeIword(p unsafe.Pointer, w iword, n uintptr) {\n \t// Run the copy ourselves instead of calling memmove\n-\t// to avoid moving v to the heap.\n-\tswitch size {\n+\t// to avoid moving w to the heap.\n+\tswitch n {\n \tdefault:\n-\t\tpanic(\"reflect: internal error: storeIword of \" + strconv.Itoa(int(size)) + \"-byte value\")\n+\t\tpanic(\"reflect: internal error: storeIword of \" + strconv.Itoa(int(n)) + \"-byte value\")\n \tcase 0:\n \tcase 1:\n \t\t*(*uint8)(p) = *(*uint8)(unsafe.Pointer(&w))\n@@ -166,237 +221,42 @@ type nonEmptyInterface struct {\n \tword iword\n }\n \n-// Regarding the implementation of Value:\n-//\n-// The Internal interface is a true interface value in the Go sense,\n-// but it also serves as a (type, address) pair in which one cannot\n-// be changed separately from the other.  That is, it serves as a way\n-// to prevent unsafe mutations of the Internal state even though\n-// we cannot (yet?) hide the field while preserving the ability for\n-// clients to make copies of Values.\n-//\n-// The internal method converts a Value into the expanded internalValue struct.\n-// If we could avoid exporting fields we'd probably make internalValue the\n-// definition of Value.\n-//\n-// If a Value is addressable (CanAddr returns true), then the Internal\n-// interface value holds a pointer to the actual field data, and Set stores\n-// through that pointer.  If a Value is not addressable (CanAddr returns false),\n-// then the Internal interface value holds the actual value.\n-//\n-// In addition to whether a value is addressable, we track whether it was\n-// obtained by using an unexported struct field.  Such values are allowed\n-// to be read, mainly to make fmt.Print more useful, but they are not\n-// allowed to be written.  We call such values read-only.\n-//\n-// A Value can be set (via the Set, SetUint, etc. methods) only if it is both\n-// addressable and not read-only.\n-//\n-// The two permission bits - addressable and read-only - are stored in\n-// the bottom two bits of the type pointer in the interface value.\n-//\n-//\tordinary value: Internal = value\n-//\taddressable value: Internal = value, Internal.typ |= flagAddr\n-//\tread-only value: Internal = value, Internal.typ |= flagRO\n-//\taddressable, read-only value: Internal = value, Internal.typ |= flagAddr | flagRO\n-//\n-// It is important that the read-only values have the extra bit set\n-// (as opposed to using the bit to mean writable), because client code\n-// can grab the interface field and try to use it.  Having the extra bit\n-// set makes the type pointer compare not equal to any real type,\n-// so that a client cannot, say, write through v.Internal.(*int).\n-// The runtime routines that access interface types reject types with\n-// low bits set.\n-//\n-// If a Value fv = v.Method(i), then fv = v with the InternalMethod\n-// field set to i+1.  Methods are never addressable.\n-//\n-// All in all, this is a lot of effort just to avoid making this new API\n-// depend on a language change we'll probably do anyway, but\n-// it's helpful to keep the two separate, and much of the logic is\n-// necessary to implement the Interface method anyway.\n-\n-const (\n-\tflagAddr uint32 = 1 << iota // holds address of value\n-\tflagRO                      // read-only\n-\n-\treflectFlags = 3\n-)\n-\n-// An internalValue is the unpacked form of a Value.\n-// The zero Value unpacks to a zero internalValue\n-type internalValue struct {\n-\ttyp       *commonType // type of value\n-\tkind      Kind        // kind of value\n-\tflag      uint32\n-\tword      iword\n-\taddr      unsafe.Pointer\n-\trcvr      iword\n-\tmethod    bool\n-\tnilmethod bool\n-}\n-\n-func (v Value) internal() internalValue {\n-\tvar iv internalValue\n-\teface := *(*emptyInterface)(unsafe.Pointer(&v.Internal))\n-\tp := uintptr(unsafe.Pointer(eface.typ))\n-\tiv.typ = toCommonType((*runtime.Type)(unsafe.Pointer(p &^ reflectFlags)))\n-\tif iv.typ == nil {\n-\t\treturn iv\n-\t}\n-\tiv.flag = uint32(p & reflectFlags)\n-\tiv.word = eface.word\n-\tif iv.flag&flagAddr != 0 {\n-\t\tiv.addr = unsafe.Pointer(uintptr(iv.word))\n-\t\tiv.typ = iv.typ.Elem().common()\n-\t\tif Kind(iv.typ.kind) == Ptr || Kind(iv.typ.kind) == UnsafePointer {\n-\t\t\tiv.word = loadIword(iv.addr, iv.typ.size)\n-\t\t}\n-\t} else {\n-\t\tif Kind(iv.typ.kind) != Ptr && Kind(iv.typ.kind) != UnsafePointer {\n-\t\t\tiv.addr = unsafe.Pointer(uintptr(iv.word))\n-\t\t}\n+// mustBe panics if f's kind is not expected.\n+// Making this a method on flag instead of on Value\n+// (and embedding flag in Value) means that we can write\n+// the very clear v.mustBe(Bool) and have it compile into\n+// v.flag.mustBe(Bool), which will only bother to copy the\n+// single important word for the receiver.\n+func (f flag) mustBe(expected Kind) {\n+\tk := f.kind()\n+\tif k != expected {\n+\t\tpanic(&ValueError{methodName(), k})\n \t}\n-\tiv.kind = iv.typ.Kind()\n-\n-\t// Is this a method?  If so, iv describes the receiver.\n-\t// Rewrite to describe the method function.\n-\tif v.InternalMethod != 0 {\n-\t\t// If this Value is a method value (x.Method(i) for some Value x)\n-\t\t// then we will invoke it using the interface form of the method,\n-\t\t// which always passes the receiver as a single word.\n-\t\t// Record that information.\n-\t\ti := v.InternalMethod - 1\n-\t\tif iv.kind == Interface {\n-\t\t\tit := (*interfaceType)(unsafe.Pointer(iv.typ))\n-\t\t\tif i < 0 || i >= len(it.methods) {\n-\t\t\t\tpanic(\"reflect: broken Value\")\n-\t\t\t}\n-\t\t\tm := &it.methods[i]\n-\t\t\tif m.pkgPath != nil {\n-\t\t\t\tiv.flag |= flagRO\n-\t\t\t}\n-\t\t\tiv.typ = toCommonType(m.typ)\n-\t\t\tiface := (*nonEmptyInterface)(iv.addr)\n-\t\t\tif iface.itab == nil {\n-\t\t\t\tiv.word = 0\n-\t\t\t\tiv.nilmethod = true\n-\t\t\t} else {\n-\t\t\t\tiv.word = iword(uintptr(iface.itab.fun[i]))\n-\t\t\t}\n-\t\t\tiv.rcvr = iface.word\n-\t\t} else {\n-\t\t\tut := iv.typ.uncommon()\n-\t\t\tif ut == nil || i < 0 || i >= len(ut.methods) {\n-\t\t\t\tpanic(\"reflect: broken Value\")\n-\t\t\t}\n-\t\t\tm := &ut.methods[i]\n-\t\t\tif m.pkgPath != nil {\n-\t\t\t\tiv.flag |= flagRO\n-\t\t\t}\n-\t\t\tiv.typ = toCommonType(m.mtyp)\n-\t\t\tiv.rcvr = iv.word\n-\t\t\tiv.word = iword(uintptr(m.tfn))\n-\t\t}\n-\t\tif iv.word != 0 {\n-\t\t\tp := new(iword)\n-\t\t\t*p = iv.word\n-\t\t\tiv.word = iword(uintptr(unsafe.Pointer(p)))\n-\t\t}\n-\t\tiv.kind = Func\n-\t\tiv.method = true\n-\t\tiv.flag &^= flagAddr\n-\t\tiv.addr = unsafe.Pointer(uintptr(iv.word))\n-\t}\n-\n-\treturn iv\n }\n \n-// packValue returns a Value with the given flag bits, type, and interface word.\n-func packValue(flag uint32, typ *runtime.Type, word iword) Value {\n-\tif typ == nil {\n-\t\tpanic(\"packValue\")\n+// mustBeExported panics if f records that the value was obtained using\n+// an unexported field.\n+func (f flag) mustBeExported() {\n+\tif f == 0 {\n+\t\tpanic(&ValueError{methodName(), 0})\n \t}\n-\tt := uintptr(unsafe.Pointer(typ))\n-\tt |= uintptr(flag)\n-\teface := emptyInterface{(*runtime.Type)(unsafe.Pointer(t)), word}\n-\treturn Value{Internal: *(*interface{})(unsafe.Pointer(&eface))}\n-}\n-\n-var dummy struct {\n-\tb bool\n-\tx interface{}\n-}\n-\n-// Dummy annotation marking that the value x escapes,\n-// for use in cases where the reflect code is so clever that\n-// the compiler cannot follow.\n-func escapes(x interface{}) {\n-\tif dummy.b {\n-\t\tdummy.x = x\n-\t}\n-}\n-\n-// valueFromAddr returns a Value using the given type and address.\n-func valueFromAddr(flag uint32, typ Type, addr unsafe.Pointer) Value {\n-\t// TODO(rsc): Eliminate this terrible hack.\n-\t// The escape analysis knows that addr is a pointer\n-\t// but it doesn't see addr get passed to anything\n-\t// that keeps it.  packValue keeps it, but packValue\n-\t// takes a uintptr (iword(addr)), and integers (non-pointers)\n-\t// are assumed not to matter.  The escapes function works\n-\t// because return values always escape (for now).\n-\tescapes(addr)\n-\n-\tif flag&flagAddr != 0 {\n-\t\t// Addressable, so the internal value is\n-\t\t// an interface containing a pointer to the real value.\n-\t\treturn packValue(flag, PtrTo(typ).runtimeType(), iword(uintptr(addr)))\n-\t}\n-\n-\tvar w iword\n-\tif k := typ.Kind(); k == Ptr || k == UnsafePointer {\n-\t\t// In line, so the interface word is the actual value.\n-\t\tw = loadIword(addr, typ.Size())\n-\t} else {\n-\t\t// Not in line: the interface word is the address.\n-\t\tw = iword(uintptr(addr))\n-\t}\n-\treturn packValue(flag, typ.runtimeType(), w)\n-}\n-\n-// valueFromIword returns a Value using the given type and interface word.\n-func valueFromIword(flag uint32, typ Type, w iword) Value {\n-\tif flag&flagAddr != 0 {\n-\t\tpanic(\"reflect: internal error: valueFromIword addressable\")\n-\t}\n-\treturn packValue(flag, typ.runtimeType(), w)\n-}\n-\n-func (iv internalValue) mustBe(want Kind) {\n-\tif iv.kind != want {\n-\t\tpanic(&ValueError{methodName(), iv.kind})\n-\t}\n-}\n-\n-func (iv internalValue) mustBeExported() {\n-\tif iv.kind == 0 {\n-\t\tpanic(&ValueError{methodName(), iv.kind})\n-\t}\n-\tif iv.flag&flagRO != 0 {\n+\tif f&flagRO != 0 {\n \t\tpanic(methodName() + \" using value obtained using unexported field\")\n \t}\n }\n \n-func (iv internalValue) mustBeAssignable() {\n-\tif iv.kind == 0 {\n-\t\tpanic(&ValueError{methodName(), iv.kind})\n+// mustBeAssignable panics if f records that the value is not assignable,\n+// which is to say that either it was obtained using an unexported field\n+// or it is not addressable.\n+func (f flag) mustBeAssignable() {\n+\tif f == 0 {\n+\t\tpanic(&ValueError{methodName(), Invalid})\n \t}\n \t// Assignable if addressable and not read-only.\n-\tif iv.flag&flagRO != 0 {\n+\tif f&flagRO != 0 {\n \t\tpanic(methodName() + \" using value obtained using unexported field\")\n \t}\n-\tif iv.flag&flagAddr == 0 {\n+\tif f&flagAddr == 0 {\n \t\tpanic(methodName() + \" using unaddressable value\")\n \t}\n }\n@@ -407,31 +267,31 @@ func (iv internalValue) mustBeAssignable() {\n // or slice element in order to call a method that requires a\n // pointer receiver.\n func (v Value) Addr() Value {\n-\tiv := v.internal()\n-\tif iv.flag&flagAddr == 0 {\n+\tif v.flag&flagAddr == 0 {\n \t\tpanic(\"reflect.Value.Addr of unaddressable value\")\n \t}\n-\treturn valueFromIword(iv.flag&flagRO, PtrTo(iv.typ.toType()), iword(uintptr(iv.addr)))\n+\treturn Value{v.typ.ptrTo(), v.val, (v.flag & flagRO) | flag(Ptr)<<flagKindShift}\n }\n \n // Bool returns v's underlying value.\n // It panics if v's kind is not Bool.\n func (v Value) Bool() bool {\n-\tiv := v.internal()\n-\tiv.mustBe(Bool)\n-\treturn *(*bool)(unsafe.Pointer(iv.addr))\n+\tv.mustBe(Bool)\n+\tif v.flag&flagIndir != 0 {\n+\t\treturn *(*bool)(v.val)\n+\t}\n+\treturn *(*bool)(unsafe.Pointer(&v.val))\n }\n \n // Bytes returns v's underlying value.\n // It panics if v's underlying value is not a slice of bytes.\n func (v Value) Bytes() []byte {\n-\tiv := v.internal()\n-\tiv.mustBe(Slice)\n-\ttyp := iv.typ.toType()\n-\tif typ.Elem().Kind() != Uint8 {\n+\tv.mustBe(Slice)\n+\tif v.typ.Elem().Kind() != Uint8 {\n \t\tpanic(\"reflect.Value.Bytes of non-byte slice\")\n \t}\n-\treturn *(*[]byte)(iv.addr)\n+\t// Slice is always bigger than a word; assume flagIndir.\n+\treturn *(*[]byte)(v.val)\n }\n \n // CanAddr returns true if the value's address can be obtained with Addr.\n@@ -440,8 +300,7 @@ func (v Value) Bytes() []byte {\n // a field of an addressable struct, or the result of dereferencing a pointer.\n // If CanAddr returns false, calling Addr will panic.\n func (v Value) CanAddr() bool {\n-\tiv := v.internal()\n-\treturn iv.flag&flagAddr != 0\n+\treturn v.flag&flagAddr != 0\n }\n \n // CanSet returns true if the value of v can be changed.\n@@ -450,8 +309,7 @@ func (v Value) CanAddr() bool {\n // If CanSet returns false, calling Set or any type-specific\n // setter (e.g., SetBool, SetInt64) will panic.\n func (v Value) CanSet() bool {\n-\tiv := v.internal()\n-\treturn iv.flag&(flagAddr|flagRO) == flagAddr\n+\treturn v.flag&(flagAddr|flagRO) == flagAddr\n }\n \n // Call calls the function v with the input arguments in.\n@@ -463,10 +321,9 @@ func (v Value) CanSet() bool {\n // If v is a variadic function, Call creates the variadic slice parameter\n // itself, copying in the corresponding values.\n func (v Value) Call(in []Value) []Value {\n-\tiv := v.internal()\n-\tiv.mustBe(Func)\n-\tiv.mustBeExported()\n-\treturn iv.call(\"Call\", in)\n+\tv.mustBe(Func)\n+\tv.mustBeExported()\n+\treturn v.call(\"Call\", in)\n }\n \n // CallSlice calls the variadic function v with the input arguments in,\n@@ -477,22 +334,60 @@ func (v Value) Call(in []Value) []Value {\n // As in Go, each input argument must be assignable to the\n // type of the function's corresponding input parameter.\n func (v Value) CallSlice(in []Value) []Value {\n-\tiv := v.internal()\n-\tiv.mustBe(Func)\n-\tiv.mustBeExported()\n-\treturn iv.call(\"CallSlice\", in)\n-}\n-\n-func (iv internalValue) call(method string, in []Value) []Value {\n-\tif iv.word == 0 {\n-\t\tif iv.nilmethod {\n-\t\t\tpanic(\"reflect.Value.Call: call of method on nil interface value\")\n+\tv.mustBe(Func)\n+\tv.mustBeExported()\n+\treturn v.call(\"CallSlice\", in)\n+}\n+\n+func (v Value) call(method string, in []Value) []Value {\n+\t// Get function pointer, type.\n+\tt := v.typ\n+\tvar (\n+\t\tfn   unsafe.Pointer\n+\t\trcvr iword\n+\t)\n+\tif v.flag&flagMethod != 0 {\n+\t\ti := int(v.flag) >> flagMethodShift\n+\t\tif v.typ.Kind() == Interface {\n+\t\t\ttt := (*interfaceType)(unsafe.Pointer(v.typ))\n+\t\t\tif i < 0 || i >= len(tt.methods) {\n+\t\t\t\tpanic(\"reflect: broken Value\")\n+\t\t\t}\n+\t\t\tm := &tt.methods[i]\n+\t\t\tif m.pkgPath != nil {\n+\t\t\t\tpanic(method + \" of unexported method\")\n+\t\t\t}\n+\t\t\tt = toCommonType(m.typ)\n+\t\t\tiface := (*nonEmptyInterface)(v.val)\n+\t\t\tif iface.itab == nil {\n+\t\t\t\tpanic(method + \" of method on nil interface value\")\n+\t\t\t}\n+\t\t\tfn = iface.itab.fun[i]\n+\t\t\trcvr = iface.word\n+\t\t} else {\n+\t\t\tut := v.typ.uncommon()\n+\t\t\tif ut == nil || i < 0 || i >= len(ut.methods) {\n+\t\t\t\tpanic(\"reflect: broken Value\")\n+\t\t\t}\n+\t\t\tm := &ut.methods[i]\n+\t\t\tif m.pkgPath != nil {\n+\t\t\t\tpanic(method + \" of unexported method\")\n+\t\t\t}\n+\t\t\tfn = m.tfn\n+\t\t\tt = toCommonType(m.mtyp)\n+\t\t\trcvr = v.iword()\n \t\t}\n+\t} else if v.flag&flagIndir != 0 {\n+\t\tfn = *(*unsafe.Pointer)(v.val)\n+\t} else {\n+\t\tfn = v.val\n+\t}\n+\n+\tif fn == nil {\n \t\tpanic(\"reflect.Value.Call: call of nil function\")\n \t}\n \n \tisSlice := method == \"CallSlice\"\n-\tt := iv.typ\n \tn := t.NumIn()\n \tif isSlice {\n \t\tif !t.IsVariadic() {\n@@ -549,34 +444,32 @@ func (iv internalValue) call(method string, in []Value) []Value {\n \t}\n \tnout := t.NumOut()\n \n-\tif iv.method {\n+\tif v.flag&flagMethod != 0 {\n \t\tnin++\n \t}\n \tparams := make([]unsafe.Pointer, nin)\n \tdelta := 0\n \toff := 0\n-\tif iv.method {\n+\tif v.flag&flagMethod != 0 {\n \t\t// Hard-wired first argument.\n \t\tp := new(iword)\n-\t\t*p = iv.rcvr\n+\t\t*p = rcvr\n \t\tparams[0] = unsafe.Pointer(p)\n \t\toff = 1\n \t}\n-\n \tfirst_pointer := false\n-\tfor i, v := range in {\n-\t\tsiv := v.internal()\n-\t\tsiv.mustBeExported()\n+\tfor i, pv := range in {\n+\t\tpv.mustBeExported()\n \t\ttarg := t.In(i).(*commonType)\n-\t\tsiv = convertForAssignment(\"reflect.Value.Call\", nil, targ, siv)\n-\t\tif siv.addr == nil {\n+\t\tpv = pv.assignTo(\"reflect.Value.Call\", targ, nil)\n+\t\tif pv.flag&flagIndir == 0 {\n \t\t\tp := new(unsafe.Pointer)\n-\t\t\t*p = unsafe.Pointer(uintptr(siv.word))\n+\t\t\t*p = pv.val\n \t\t\tparams[off] = unsafe.Pointer(p)\n \t\t} else {\n-\t\t\tparams[off] = siv.addr\n+\t\t\tparams[off] = pv.val\n \t\t}\n-\t\tif i == 0 && Kind(targ.kind) != Ptr && !iv.method && isMethod(iv.typ) {\n+\t\tif i == 0 && Kind(targ.kind) != Ptr && v.flag&flagMethod == 0 && isMethod(v.typ) {\n \t\t\tp := new(unsafe.Pointer)\n \t\t\t*p = params[off]\n \t\t\tparams[off] = unsafe.Pointer(p)\n@@ -602,7 +495,7 @@ func (iv internalValue) call(method string, in []Value) []Value {\n \t\tpr = &results[0]\n \t}\n \n-\tcall(t, *(*unsafe.Pointer)(iv.addr), iv.method, first_pointer, pp, pr)\n+\tcall(t, fn, v.flag&flagMethod != 0, first_pointer, pp, pr)\n \n \treturn ret\n }\n@@ -635,130 +528,137 @@ func isMethod(t *commonType) bool {\n // Cap returns v's capacity.\n // It panics if v's Kind is not Array, Chan, or Slice.\n func (v Value) Cap() int {\n-\tiv := v.internal()\n-\tswitch iv.kind {\n+\tk := v.kind()\n+\tswitch k {\n \tcase Array:\n-\t\treturn iv.typ.Len()\n+\t\treturn v.typ.Len()\n \tcase Chan:\n-\t\treturn int(chancap(*(*iword)(iv.addr)))\n+\t\treturn int(chancap(*(*iword)(v.iword())))\n \tcase Slice:\n-\t\treturn (*SliceHeader)(iv.addr).Cap\n+\t\t// Slice is always bigger than a word; assume flagIndir.\n+\t\treturn (*SliceHeader)(v.val).Cap\n \t}\n-\tpanic(&ValueError{\"reflect.Value.Cap\", iv.kind})\n+\tpanic(&ValueError{\"reflect.Value.Cap\", k})\n }\n \n // Close closes the channel v.\n // It panics if v's Kind is not Chan.\n func (v Value) Close() {\n-\tiv := v.internal()\n-\tiv.mustBe(Chan)\n-\tiv.mustBeExported()\n-\tch := *(*iword)(iv.addr)\n-\tchanclose(ch)\n+\tv.mustBe(Chan)\n+\tv.mustBeExported()\n+\tchanclose(*(*iword)(v.iword()))\n }\n \n // Complex returns v's underlying value, as a complex128.\n // It panics if v's Kind is not Complex64 or Complex128\n func (v Value) Complex() complex128 {\n-\tiv := v.internal()\n-\tswitch iv.kind {\n+\tk := v.kind()\n+\tswitch k {\n \tcase Complex64:\n-\t\treturn complex128(*(*complex64)(iv.addr))\n+\t\tif v.flag&flagIndir != 0 {\n+\t\t\treturn complex128(*(*complex64)(v.val))\n+\t\t}\n+\t\treturn complex128(*(*complex64)(unsafe.Pointer(&v.val)))\n \tcase Complex128:\n-\t\treturn *(*complex128)(iv.addr)\n+\t\t// complex128 is always bigger than a word; assume flagIndir.\n+\t\treturn *(*complex128)(v.val)\n \t}\n-\tpanic(&ValueError{\"reflect.Value.Complex\", iv.kind})\n+\tpanic(&ValueError{\"reflect.Value.Complex\", k})\n }\n \n // Elem returns the value that the interface v contains\n // or that the pointer v points to.\n // It panics if v's Kind is not Interface or Ptr.\n // It returns the zero Value if v is nil.\n func (v Value) Elem() Value {\n-\tiv := v.internal()\n-\treturn iv.Elem()\n-}\n-\n-func (iv internalValue) Elem() Value {\n-\tswitch iv.kind {\n+\tk := v.kind()\n+\tswitch k {\n \tcase Interface:\n-\t\t// Empty interface and non-empty interface have different layouts.\n-\t\t// Convert to empty interface.\n-\t\tvar eface emptyInterface\n-\t\tif iv.typ.NumMethod() == 0 {\n-\t\t\teface = *(*emptyInterface)(iv.addr)\n+\t\tvar (\n+\t\t\ttyp *commonType\n+\t\t\tval unsafe.Pointer\n+\t\t)\n+\t\tif v.typ.NumMethod() == 0 {\n+\t\t\teface := (*emptyInterface)(v.val)\n+\t\t\tif eface.typ == nil {\n+\t\t\t\t// nil interface value\n+\t\t\t\treturn Value{}\n+\t\t\t}\n+\t\t\ttyp = toCommonType(eface.typ)\n+\t\t\tval = unsafe.Pointer(eface.word)\n \t\t} else {\n-\t\t\tiface := (*nonEmptyInterface)(iv.addr)\n-\t\t\tif iface.itab != nil {\n-\t\t\t\teface.typ = iface.itab.typ\n+\t\t\tiface := (*nonEmptyInterface)(v.val)\n+\t\t\tif iface.itab == nil {\n+\t\t\t\t// nil interface value\n+\t\t\t\treturn Value{}\n \t\t\t}\n-\t\t\teface.word = iface.word\n+\t\t\ttyp = toCommonType(iface.itab.typ)\n+\t\t\tval = unsafe.Pointer(iface.word)\n \t\t}\n-\t\tif eface.typ == nil {\n-\t\t\treturn Value{}\n+\t\tfl := v.flag & flagRO\n+\t\tfl |= flag(typ.Kind()) << flagKindShift\n+\t\tif typ.Kind() != Ptr && typ.Kind() != UnsafePointer {\n+\t\t\tfl |= flagIndir\n \t\t}\n-\t\treturn valueFromIword(iv.flag&flagRO, toType(eface.typ), eface.word)\n+\t\treturn Value{typ, val, fl}\n \n \tcase Ptr:\n+\t\tval := v.val\n+\t\tif v.flag&flagIndir != 0 {\n+\t\t\tval = *(*unsafe.Pointer)(val)\n+\t\t}\n \t\t// The returned value's address is v's value.\n-\t\tif iv.word == 0 {\n+\t\tif val == nil {\n \t\t\treturn Value{}\n \t\t}\n-\t\treturn valueFromAddr(iv.flag&flagRO|flagAddr, iv.typ.Elem(), unsafe.Pointer(uintptr(iv.word)))\n+\t\ttt := (*ptrType)(unsafe.Pointer(v.typ))\n+\t\ttyp := toCommonType(tt.elem)\n+\t\tfl := v.flag&flagRO | flagIndir | flagAddr\n+\t\tfl |= flag(typ.Kind() << flagKindShift)\n+\t\treturn Value{typ, val, fl}\n \t}\n-\tpanic(&ValueError{\"reflect.Value.Elem\", iv.kind})\n+\tpanic(&ValueError{\"reflect.Value.Elem\", k})\n }\n \n // Field returns the i'th field of the struct v.\n // It panics if v's Kind is not Struct or i is out of range.\n func (v Value) Field(i int) Value {\n-\tiv := v.internal()\n-\tiv.mustBe(Struct)\n-\tt := iv.typ.toType()\n-\tif i < 0 || i >= t.NumField() {\n+\tv.mustBe(Struct)\n+\ttt := (*structType)(unsafe.Pointer(v.typ))\n+\tif i < 0 || i >= len(tt.fields) {\n \t\tpanic(\"reflect: Field index out of range\")\n \t}\n-\tf := t.Field(i)\n+\tfield := &tt.fields[i]\n+\ttyp := toCommonType(field.typ)\n \n \t// Inherit permission bits from v.\n-\tflag := iv.flag\n+\tfl := v.flag & (flagRO | flagIndir | flagAddr)\n \t// Using an unexported field forces flagRO.\n-\tif f.PkgPath != \"\" {\n-\t\tflag |= flagRO\n+\tif field.pkgPath != nil {\n+\t\tfl |= flagRO\n \t}\n-\treturn valueFromValueOffset(flag, f.Type, iv, f.Offset)\n-}\n+\tfl |= flag(typ.Kind()) << flagKindShift\n \n-// valueFromValueOffset returns a sub-value of outer\n-// (outer is an array or a struct) with the given flag and type\n-// starting at the given byte offset into outer.\n-func valueFromValueOffset(flag uint32, typ Type, outer internalValue, offset uintptr) Value {\n-\tif outer.addr != nil {\n-\t\treturn valueFromAddr(flag, typ, unsafe.Pointer(uintptr(outer.addr)+offset))\n+\tvar val unsafe.Pointer\n+\tswitch {\n+\tcase fl&flagIndir != 0:\n+\t\t// Indirect.  Just bump pointer.\n+\t\tval = unsafe.Pointer(uintptr(v.val) + field.offset)\n+\tcase bigEndian:\n+\t\t// Direct.  Discard leading bytes.\n+\t\tval = unsafe.Pointer(uintptr(v.val) << (field.offset * 8))\n+\tdefault:\n+\t\t// Direct.  Discard leading bytes.\n+\t\tval = unsafe.Pointer(uintptr(v.val) >> (field.offset * 8))\n \t}\n \n-\t// outer is so tiny it is in line.\n-\t// We have to use outer.word and derive\n-\t// the new word (it cannot possibly be bigger).\n-\t// In line, so not addressable.\n-\tif flag&flagAddr != 0 {\n-\t\tpanic(\"reflect: internal error: misuse of valueFromValueOffset\")\n-\t}\n-\tb := *(*[ptrSize]byte)(unsafe.Pointer(&outer.word))\n-\tfor i := uintptr(0); i < typ.Size(); i++ {\n-\t\tb[i] = b[offset+i]\n-\t}\n-\tfor i := typ.Size(); i < ptrSize; i++ {\n-\t\tb[i] = 0\n-\t}\n-\tw := *(*iword)(unsafe.Pointer(&b))\n-\treturn valueFromIword(flag, typ, w)\n+\treturn Value{typ, val, fl}\n }\n \n // FieldByIndex returns the nested field corresponding to index.\n // It panics if v's Kind is not struct.\n func (v Value) FieldByIndex(index []int) Value {\n-\tv.internal().mustBe(Struct)\n+\tv.mustBe(Struct)\n \tfor i, x := range index {\n \t\tif i > 0 {\n \t\t\tif v.Kind() == Ptr && v.Elem().Kind() == Struct {\n@@ -774,9 +674,8 @@ func (v Value) FieldByIndex(index []int) Value {\n // It returns the zero Value if no field was found.\n // It panics if v's Kind is not struct.\n func (v Value) FieldByName(name string) Value {\n-\tiv := v.internal()\n-\tiv.mustBe(Struct)\n-\tif f, ok := iv.typ.FieldByName(name); ok {\n+\tv.mustBe(Struct)\n+\tif f, ok := v.typ.FieldByName(name); ok {\n \t\treturn v.FieldByIndex(f.Index)\n \t}\n \treturn Value{}\n@@ -787,8 +686,8 @@ func (v Value) FieldByName(name string) Value {\n // It panics if v's Kind is not struct.\n // It returns the zero Value if no field was found.\n func (v Value) FieldByNameFunc(match func(string) bool) Value {\n-\tv.internal().mustBe(Struct)\n-\tif f, ok := v.Type().FieldByNameFunc(match); ok {\n+\tv.mustBe(Struct)\n+\tif f, ok := v.typ.FieldByNameFunc(match); ok {\n \t\treturn v.FieldByIndex(f.Index)\n \t}\n \treturn Value{}\n@@ -797,74 +696,101 @@ func (v Value) FieldByNameFunc(match func(string) bool) Value {\n // Float returns v's underlying value, as an float64.\n // It panics if v's Kind is not Float32 or Float64\n func (v Value) Float() float64 {\n-\tiv := v.internal()\n-\tswitch iv.kind {\n+\tk := v.kind()\n+\tswitch k {\n \tcase Float32:\n-\t\treturn float64(*(*float32)(iv.addr))\n+\t\tif v.flag&flagIndir != 0 {\n+\t\t\treturn float64(*(*float32)(v.val))\n+\t\t}\n+\t\treturn float64(*(*float32)(unsafe.Pointer(&v.val)))\n \tcase Float64:\n-\t\treturn *(*float64)(iv.addr)\n+\t\tif v.flag&flagIndir != 0 {\n+\t\t\treturn *(*float64)(v.val)\n+\t\t}\n+\t\treturn *(*float64)(unsafe.Pointer(&v.val))\n \t}\n-\tpanic(&ValueError{\"reflect.Value.Float\", iv.kind})\n+\tpanic(&ValueError{\"reflect.Value.Float\", k})\n }\n \n // Index returns v's i'th element.\n // It panics if v's Kind is not Array or Slice or i is out of range.\n func (v Value) Index(i int) Value {\n-\tiv := v.internal()\n-\tswitch iv.kind {\n-\tdefault:\n-\t\tpanic(&ValueError{\"reflect.Value.Index\", iv.kind})\n+\tk := v.kind()\n+\tswitch k {\n \tcase Array:\n-\t\tflag := iv.flag // element flag same as overall array\n-\t\tt := iv.typ.toType()\n-\t\tif i < 0 || i > t.Len() {\n+\t\ttt := (*arrayType)(unsafe.Pointer(v.typ))\n+\t\tif i < 0 || i > int(tt.len) {\n \t\t\tpanic(\"reflect: array index out of range\")\n \t\t}\n-\t\ttyp := t.Elem()\n-\t\treturn valueFromValueOffset(flag, typ, iv, uintptr(i)*typ.Size())\n+\t\ttyp := toCommonType(tt.elem)\n+\t\tfl := v.flag & (flagRO | flagIndir | flagAddr) // bits same as overall array\n+\t\tfl |= flag(typ.Kind()) << flagKindShift\n+\t\toffset := uintptr(i) * typ.size\n+\n+\t\tvar val unsafe.Pointer\n+\t\tswitch {\n+\t\tcase fl&flagIndir != 0:\n+\t\t\t// Indirect.  Just bump pointer.\n+\t\t\tval = unsafe.Pointer(uintptr(v.val) + offset)\n+\t\tcase bigEndian:\n+\t\t\t// Direct.  Discard leading bytes.\n+\t\t\tval = unsafe.Pointer(uintptr(v.val) << (offset * 8))\n+\t\tdefault:\n+\t\t\t// Direct.  Discard leading bytes.\n+\t\t\tval = unsafe.Pointer(uintptr(v.val) >> (offset * 8))\n+\t\t}\n+\t\treturn Value{typ, val, fl}\n \n \tcase Slice:\n \t\t// Element flag same as Elem of Ptr.\n-\t\t// Addressable, possibly read-only.\n-\t\tflag := iv.flag&flagRO | flagAddr\n-\t\ts := (*SliceHeader)(iv.addr)\n+\t\t// Addressable, indirect, possibly read-only.\n+\t\tfl := flagAddr | flagIndir | v.flag&flagRO\n+\t\ts := (*SliceHeader)(v.val)\n \t\tif i < 0 || i >= s.Len {\n \t\t\tpanic(\"reflect: slice index out of range\")\n \t\t}\n-\t\ttyp := iv.typ.Elem()\n-\t\taddr := unsafe.Pointer(s.Data + uintptr(i)*typ.Size())\n-\t\treturn valueFromAddr(flag, typ, addr)\n+\t\ttt := (*sliceType)(unsafe.Pointer(v.typ))\n+\t\ttyp := toCommonType(tt.elem)\n+\t\tfl |= flag(typ.Kind()) << flagKindShift\n+\t\tval := unsafe.Pointer(s.Data + uintptr(i)*typ.size)\n+\t\treturn Value{typ, val, fl}\n \t}\n-\n-\tpanic(\"not reached\")\n+\tpanic(&ValueError{\"reflect.Value.Index\", k})\n }\n \n // Int returns v's underlying value, as an int64.\n // It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64.\n func (v Value) Int() int64 {\n-\tiv := v.internal()\n-\tswitch iv.kind {\n+\tk := v.kind()\n+\tvar p unsafe.Pointer\n+\tif v.flag&flagIndir != 0 {\n+\t\tp = v.val\n+\t} else {\n+\t\t// The escape analysis is good enough that &v.val\n+\t\t// does not trigger a heap allocation.\n+\t\tp = unsafe.Pointer(&v.val)\n+\t}\n+\tswitch k {\n \tcase Int:\n-\t\treturn int64(*(*int)(iv.addr))\n+\t\treturn int64(*(*int)(p))\n \tcase Int8:\n-\t\treturn int64(*(*int8)(iv.addr))\n+\t\treturn int64(*(*int8)(p))\n \tcase Int16:\n-\t\treturn int64(*(*int16)(iv.addr))\n+\t\treturn int64(*(*int16)(p))\n \tcase Int32:\n-\t\treturn int64(*(*int32)(iv.addr))\n+\t\treturn int64(*(*int32)(p))\n \tcase Int64:\n-\t\treturn *(*int64)(iv.addr)\n+\t\treturn int64(*(*int64)(p))\n \t}\n-\tpanic(&ValueError{\"reflect.Value.Int\", iv.kind})\n+\tpanic(&ValueError{\"reflect.Value.Int\", k})\n }\n \n // CanInterface returns true if Interface can be used without panicking.\n func (v Value) CanInterface() bool {\n-\tiv := v.internal()\n-\tif iv.kind == Invalid {\n-\t\tpanic(&ValueError{\"reflect.Value.CanInterface\", iv.kind})\n+\tif v.flag == 0 {\n+\t\tpanic(&ValueError{\"reflect.Value.CanInterface\", Invalid})\n \t}\n-\treturn v.InternalMethod == 0 && iv.flag&flagRO == 0\n+\treturn v.flag&(flagMethod|flagRO) == 0\n }\n \n // Interface returns v's value as an interface{}.\n@@ -876,75 +802,72 @@ func (v Value) Interface() interface{} {\n }\n \n func valueInterface(v Value, safe bool) interface{} {\n-\tiv := v.internal()\n-\treturn iv.valueInterface(safe)\n-}\n-\n-func (iv internalValue) valueInterface(safe bool) interface{} {\n-\tif iv.kind == 0 {\n-\t\tpanic(&ValueError{\"reflect.Value.Interface\", iv.kind})\n+\tif v.flag == 0 {\n+\t\tpanic(&ValueError{\"reflect.Value.Interface\", 0})\n \t}\n-\tif iv.method {\n+\tif v.flag&flagMethod != 0 {\n \t\tpanic(\"reflect.Value.Interface: cannot create interface value for method with bound receiver\")\n \t}\n \n-\tif safe && iv.flag&flagRO != 0 {\n+\tif safe && v.flag&flagRO != 0 {\n \t\t// Do not allow access to unexported values via Interface,\n \t\t// because they might be pointers that should not be \n \t\t// writable or methods or function that should not be callable.\n \t\tpanic(\"reflect.Value.Interface: cannot return value obtained from unexported field or method\")\n \t}\n-\tif iv.kind == Interface {\n+\n+\tk := v.kind()\n+\tif k == Interface {\n \t\t// Special case: return the element inside the interface.\n-\t\t// Won't recurse further because an interface cannot contain an interface.\n-\t\tif iv.IsNil() {\n-\t\t\treturn nil\n+\t\t// Empty interface has one layout, all interfaces with\n+\t\t// methods have a second layout.\n+\t\tif v.NumMethod() == 0 {\n+\t\t\treturn *(*interface{})(v.val)\n \t\t}\n-\t\treturn iv.Elem().Interface()\n+\t\treturn *(*interface {\n+\t\t\tM()\n+\t\t})(v.val)\n \t}\n \n \t// Non-interface value.\n \tvar eface emptyInterface\n-\teface.typ = iv.typ.runtimeType()\n-\teface.word = iv.word\n+\teface.typ = v.typ.runtimeType()\n+\teface.word = v.iword()\n \treturn *(*interface{})(unsafe.Pointer(&eface))\n }\n \n // InterfaceData returns the interface v's value as a uintptr pair.\n // It panics if v's Kind is not Interface.\n func (v Value) InterfaceData() [2]uintptr {\n-\tiv := v.internal()\n-\tiv.mustBe(Interface)\n+\tv.mustBe(Interface)\n \t// We treat this as a read operation, so we allow\n \t// it even for unexported data, because the caller\n \t// has to import \"unsafe\" to turn it into something\n \t// that can be abused.\n-\treturn *(*[2]uintptr)(iv.addr)\n+\t// Interface value is always bigger than a word; assume flagIndir.\n+\treturn *(*[2]uintptr)(v.val)\n }\n \n // IsNil returns true if v is a nil value.\n // It panics if v's Kind is not Chan, Func, Interface, Map, Ptr, or Slice.\n func (v Value) IsNil() bool {\n-\treturn v.internal().IsNil()\n-}\n-\n-func (iv internalValue) IsNil() bool {\n-\tswitch iv.kind {\n-\tcase Ptr:\n-\t\tif iv.method {\n+\tk := v.kind()\n+\tswitch k {\n+\tcase Chan, Func, Map, Ptr:\n+\t\tif v.flag&flagMethod != 0 {\n \t\t\tpanic(\"reflect: IsNil of method Value\")\n \t\t}\n-\t\treturn iv.word == 0\n-\tcase Chan, Func, Map:\n-\t\tif iv.method {\n-\t\t\tpanic(\"reflect: IsNil of method Value\")\n+\t\tptr := v.val\n+\t\tif v.flag&flagIndir != 0 {\n+\t\t\tptr = *(*unsafe.Pointer)(ptr)\n \t\t}\n-\t\treturn *(*uintptr)(iv.addr) == 0\n+\t\treturn ptr == nil\n \tcase Interface, Slice:\n \t\t// Both interface and slice are nil if first word is 0.\n-\t\treturn *(*uintptr)(iv.addr) == 0\n+\t\t// Both are always bigger than a word; assume flagIndir.\n+\t\treturn *(*unsafe.Pointer)(v.val) == nil\n \t}\n-\tpanic(&ValueError{\"reflect.Value.IsNil\", iv.kind})\n+\tpanic(&ValueError{\"reflect.Value.IsNil\", k})\n }\n \n // IsValid returns true if v represents a value.\n@@ -953,88 +876,96 @@ func (iv internalValue) IsNil() bool {\n // Most functions and methods never return an invalid value.\n // If one does, its documentation states the conditions explicitly.\n func (v Value) IsValid() bool {\n-\treturn v.Internal != nil\n+\treturn v.flag != 0\n }\n \n // Kind returns v's Kind.\n // If v is the zero Value (IsValid returns false), Kind returns Invalid.\n func (v Value) Kind() Kind {\n-\treturn v.internal().kind\n+\treturn v.kind()\n }\n \n // Len returns v's length.\n // It panics if v's Kind is not Array, Chan, Map, Slice, or String.\n func (v Value) Len() int {\n-\tiv := v.internal()\n-\tswitch iv.kind {\n+\tk := v.kind()\n+\tswitch k {\n \tcase Array:\n-\t\treturn iv.typ.Len()\n+\t\ttt := (*arrayType)(unsafe.Pointer(v.typ))\n+\t\treturn int(tt.len)\n \tcase Chan:\n-\t\treturn int(chanlen(*(*iword)(iv.addr)))\n+\t\treturn int(chanlen(*(*iword)(v.iword())))\n \tcase Map:\n-\t\treturn int(maplen(*(*iword)(iv.addr)))\n+\t\treturn int(maplen(*(*iword)(v.iword())))\n \tcase Slice:\n-\t\treturn (*SliceHeader)(iv.addr).Len\n+\t\t// Slice is bigger than a word; assume flagIndir.\n+\t\treturn (*SliceHeader)(v.val).Len\n \tcase String:\n-\t\treturn (*StringHeader)(iv.addr).Len\n+\t\t// String is bigger than a word; assume flagIndir.\n+\t\treturn (*StringHeader)(v.val).Len\n \t}\n-\tpanic(&ValueError{\"reflect.Value.Len\", iv.kind})\n+\tpanic(&ValueError{\"reflect.Value.Len\", k})\n }\n \n // MapIndex returns the value associated with key in the map v.\n // It panics if v's Kind is not Map.\n // It returns the zero Value if key is not found in the map or if v represents a nil map.\n // As in Go, the key's value must be assignable to the map's key type.\n func (v Value) MapIndex(key Value) Value {\n-\tiv := v.internal()\n-\tiv.mustBe(Map)\n-\ttyp := iv.typ.toType()\n+\tv.mustBe(Map)\n+\ttt := (*mapType)(unsafe.Pointer(v.typ))\n \n-\t// Do not require ikey to be exported, so that DeepEqual\n+\t// Do not require key to be exported, so that DeepEqual\n \t// and other programs can use all the keys returned by\n \t// MapKeys as arguments to MapIndex.  If either the map\n \t// or the key is unexported, though, the result will be\n-\t// considered unexported.\n-\n-\tikey := key.internal()\n-\tikey = convertForAssignment(\"reflect.Value.MapIndex\", nil, typ.Key(), ikey)\n-\tif iv.word == 0 {\n-\t\treturn Value{}\n-\t}\n+\t// considered unexported.  This is consistent with the\n+\t// behavior for structs, which allow read but not write\n+\t// of unexported fields.\n+\tkey = key.assignTo(\"reflect.Value.MapIndex\", toCommonType(tt.key), nil)\n \n-\tflag := (iv.flag | ikey.flag) & flagRO\n-\telemType := typ.Elem()\n-\telemWord, ok := mapaccess(typ.runtimeType(), *(*iword)(iv.addr), ikey.word)\n+\tword, ok := mapaccess(v.typ.runtimeType(), *(*iword)(v.iword()), key.iword())\n \tif !ok {\n \t\treturn Value{}\n \t}\n-\treturn valueFromIword(flag, elemType, elemWord)\n+\ttyp := toCommonType(tt.elem)\n+\tfl := (v.flag | key.flag) & flagRO\n+\tif typ.Kind() != Ptr && typ.Kind() != UnsafePointer {\n+\t\tfl |= flagIndir\n+\t}\n+\tfl |= flag(typ.Kind()) << flagKindShift\n+\treturn Value{typ, unsafe.Pointer(word), fl}\n }\n \n // MapKeys returns a slice containing all the keys present in the map,\n // in unspecified order.\n // It panics if v's Kind is not Map.\n // It returns an empty slice if v represents a nil map.\n func (v Value) MapKeys() []Value {\n-\tiv := v.internal()\n-\tiv.mustBe(Map)\n-\tkeyType := iv.typ.Key()\n+\tv.mustBe(Map)\n+\ttt := (*mapType)(unsafe.Pointer(v.typ))\n+\tkeyType := toCommonType(tt.key)\n+\n+\tfl := v.flag & flagRO\n+\tfl |= flag(keyType.Kind()) << flagKindShift\n+\tif keyType.Kind() != Ptr && keyType.Kind() != UnsafePointer {\n+\t\tfl |= flagIndir\n+\t}\n \n-\tflag := iv.flag & flagRO\n-\tm := *(*iword)(iv.addr)\n+\tm := *(*iword)(v.iword())\n \tmlen := int32(0)\n-\tif m != 0 {\n+\tif m != nil {\n \t\tmlen = maplen(m)\n \t}\n-\tit := mapiterinit(iv.typ.runtimeType(), m)\n+\tit := mapiterinit(v.typ.runtimeType(), m)\n \ta := make([]Value, mlen)\n \tvar i int\n \tfor i = 0; i < len(a); i++ {\n \t\tkeyWord, ok := mapiterkey(it)\n \t\tif !ok {\n \t\t\tbreak\n \t\t}\n-\t\ta[i] = valueFromIword(flag, keyType, keyWord)\n+\t\ta[i] = Value{keyType, unsafe.Pointer(keyWord), fl}\n \t\tmapiternext(it)\n \t}\n \treturn a[:i]\n@@ -1045,23 +976,27 @@ func (v Value) MapKeys() []Value {\n // a receiver; the returned function will always use v as the receiver.\n // Method panics if i is out of range.\n func (v Value) Method(i int) Value {\n-\tiv := v.internal()\n-\tif iv.kind == Invalid {\n+\tif v.typ == nil {\n \t\tpanic(&ValueError{\"reflect.Value.Method\", Invalid})\n \t}\n-\tif i < 0 || i >= iv.typ.NumMethod() {\n+\tif v.flag&flagMethod != 0 || i < 0 || i >= v.typ.NumMethod() {\n \t\tpanic(\"reflect: Method index out of range\")\n \t}\n-\treturn Value{v.Internal, i + 1}\n+\tfl := v.flag & (flagRO | flagAddr | flagIndir)\n+\tfl |= flag(Func) << flagKindShift\n+\tfl |= flag(i)<<flagMethodShift | flagMethod\n+\treturn Value{v.typ, v.val, fl}\n }\n \n // NumMethod returns the number of methods in the value's method set.\n func (v Value) NumMethod() int {\n-\tiv := v.internal()\n-\tif iv.kind == Invalid {\n+\tif v.typ == nil {\n \t\tpanic(&ValueError{\"reflect.Value.NumMethod\", Invalid})\n \t}\n-\treturn iv.typ.NumMethod()\n+\tif v.flag&flagMethod != 0 {\n+\t\treturn 0\n+\t}\n+\treturn v.typ.NumMethod()\n }\n \n // MethodByName returns a function value corresponding to the method\n@@ -1070,49 +1005,51 @@ func (v Value) NumMethod() int {\n // a receiver; the returned function will always use v as the receiver.\n // It returns the zero Value if no method was found.\n func (v Value) MethodByName(name string) Value {\n-\tiv := v.internal()\n-\tif iv.kind == Invalid {\n+\tif v.typ == nil {\n \t\tpanic(&ValueError{\"reflect.Value.MethodByName\", Invalid})\n \t}\n-\tm, ok := iv.typ.MethodByName(name)\n-\tif ok {\n-\t\treturn Value{v.Internal, m.Index + 1}\n+\tif v.flag&flagMethod != 0 {\n+\t\treturn Value{}\n \t}\n-\treturn Value{}\n+\tm, ok := v.typ.MethodByName(name)\n+\tif !ok {\n+\t\treturn Value{}\n+\t}\n+\treturn v.Method(m.Index)\n }\n \n // NumField returns the number of fields in the struct v.\n // It panics if v's Kind is not Struct.\n func (v Value) NumField() int {\n-\tiv := v.internal()\n-\tiv.mustBe(Struct)\n-\treturn iv.typ.NumField()\n+\tv.mustBe(Struct)\n+\ttt := (*structType)(unsafe.Pointer(v.typ))\n+\treturn len(tt.fields)\n }\n \n // OverflowComplex returns true if the complex128 x cannot be represented by v's type.\n // It panics if v's Kind is not Complex64 or Complex128.\n func (v Value) OverflowComplex(x complex128) bool {\n-\tiv := v.internal()\n-\tswitch iv.kind {\n+\tk := v.kind()\n+\tswitch k {\n \tcase Complex64:\n \t\treturn overflowFloat32(real(x)) || overflowFloat32(imag(x))\n \tcase Complex128:\n \t\treturn false\n \t}\n-\tpanic(&ValueError{\"reflect.Value.OverflowComplex\", iv.kind})\n+\tpanic(&ValueError{\"reflect.Value.OverflowComplex\", k})\n }\n \n // OverflowFloat returns true if the float64 x cannot be represented by v's type.\n // It panics if v's Kind is not Float32 or Float64.\n func (v Value) OverflowFloat(x float64) bool {\n-\tiv := v.internal()\n-\tswitch iv.kind {\n+\tk := v.kind()\n+\tswitch k {\n \tcase Float32:\n \t\treturn overflowFloat32(x)\n \tcase Float64:\n \t\treturn false\n \t}\n-\tpanic(&ValueError{\"reflect.Value.OverflowFloat\", iv.kind})\n+\tpanic(&ValueError{\"reflect.Value.OverflowFloat\", k})\n }\n \n func overflowFloat32(x float64) bool {\n@@ -1125,27 +1062,27 @@ func overflowFloat32(x float64) bool {\n // OverflowInt returns true if the int64 x cannot be represented by v's type.\n // It panics if v's Kind is not Int, Int8, int16, Int32, or Int64.\n func (v Value) OverflowInt(x int64) bool {\n-\tiv := v.internal()\n-\tswitch iv.kind {\n+\tk := v.kind()\n+\tswitch k {\n \tcase Int, Int8, Int16, Int32, Int64:\n-\t\tbitSize := iv.typ.size * 8\n+\t\tbitSize := v.typ.size * 8\n \t\ttrunc := (x << (64 - bitSize)) >> (64 - bitSize)\n \t\treturn x != trunc\n \t}\n-\tpanic(&ValueError{\"reflect.Value.OverflowInt\", iv.kind})\n+\tpanic(&ValueError{\"reflect.Value.OverflowInt\", k})\n }\n \n // OverflowUint returns true if the uint64 x cannot be represented by v's type.\n // It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.\n func (v Value) OverflowUint(x uint64) bool {\n-\tiv := v.internal()\n-\tswitch iv.kind {\n+\tk := v.kind()\n+\tswitch k {\n \tcase Uint, Uintptr, Uint8, Uint16, Uint32, Uint64:\n-\t\tbitSize := iv.typ.size * 8\n+\t\tbitSize := v.typ.size * 8\n \t\ttrunc := (x << (64 - bitSize)) >> (64 - bitSize)\n \t\treturn x != trunc\n \t}\n-\tpanic(&ValueError{\"reflect.Value.OverflowUint\", iv.kind})\n+\tpanic(&ValueError{\"reflect.Value.OverflowUint\", k})\n }\n \n // Pointer returns v's value as a uintptr.\n@@ -1154,22 +1091,21 @@ func (v Value) OverflowUint(x uint64) bool {\n // without importing the unsafe package explicitly.\n // It panics if v's Kind is not Chan, Func, Map, Ptr, Slice, or UnsafePointer.\n func (v Value) Pointer() uintptr {\n-\tiv := v.internal()\n-\tswitch iv.kind {\n-\tcase Ptr, UnsafePointer:\n-\t\tif iv.kind == Func && v.InternalMethod != 0 {\n+\tk := v.kind()\n+\tswitch k {\n+\tcase Chan, Func, Map, Ptr, UnsafePointer:\n+\t\tif k == Func && v.flag&flagMethod != 0 {\n \t\t\tpanic(\"reflect.Value.Pointer of method Value\")\n \t\t}\n-\t\treturn uintptr(iv.word)\n-\tcase Chan, Func, Map:\n-\t\tif iv.kind == Func && v.InternalMethod != 0 {\n-\t\t\tpanic(\"reflect.Value.Pointer of method Value\")\n+\t\tp := v.val\n+\t\tif v.flag&flagIndir != 0 {\n+\t\t\tp = *(*unsafe.Pointer)(p)\n \t\t}\n-\t\treturn *(*uintptr)(iv.addr)\n+\t\treturn uintptr(p)\n \tcase Slice:\n-\t\treturn (*SliceHeader)(iv.addr).Data\n+\t\treturn (*SliceHeader)(v.val).Data\n \t}\n-\tpanic(&ValueError{\"reflect.Value.Pointer\", iv.kind})\n+\tpanic(&ValueError{\"reflect.Value.Pointer\", k})\n }\n \n // Recv receives and returns a value from the channel v.\n@@ -1178,25 +1114,26 @@ func (v Value) Pointer() uintptr {\n // The boolean value ok is true if the value x corresponds to a send\n // on the channel, false if it is a zero value received because the channel is closed.\n func (v Value) Recv() (x Value, ok bool) {\n-\tiv := v.internal()\n-\tiv.mustBe(Chan)\n-\tiv.mustBeExported()\n-\treturn iv.recv(false)\n+\tv.mustBe(Chan)\n+\tv.mustBeExported()\n+\treturn v.recv(false)\n }\n \n-// internal recv, possibly non-blocking (nb)\n-func (iv internalValue) recv(nb bool) (val Value, ok bool) {\n-\tt := iv.typ.toType()\n-\tif t.ChanDir()&RecvDir == 0 {\n+// internal recv, possibly non-blocking (nb).\n+// v is known to be a channel.\n+func (v Value) recv(nb bool) (val Value, ok bool) {\n+\ttt := (*chanType)(unsafe.Pointer(v.typ))\n+\tif ChanDir(tt.dir)&RecvDir == 0 {\n \t\tpanic(\"recv on send-only channel\")\n \t}\n-\tch := *(*iword)(iv.addr)\n-\tif ch == 0 {\n-\t\tpanic(\"recv on nil channel\")\n-\t}\n-\tvalWord, selected, ok := chanrecv(iv.typ.runtimeType(), ch, nb)\n+\tword, selected, ok := chanrecv(v.typ.runtimeType(), *(*iword)(v.iword()), nb)\n \tif selected {\n-\t\tval = valueFromIword(0, t.Elem(), valWord)\n+\t\ttyp := toCommonType(tt.elem)\n+\t\tfl := flag(typ.Kind()) << flagKindShift\n+\t\tif typ.Kind() != Ptr && typ.Kind() != UnsafePointer {\n+\t\t\tfl |= flagIndir\n+\t\t}\n+\t\tval = Value{typ, unsafe.Pointer(word), fl}\n \t}\n \treturn\n }\n@@ -1205,128 +1142,114 @@ func (iv internalValue) recv(nb bool) (val Value, ok bool) {\n // It panics if v's kind is not Chan or if x's type is not the same type as v's element type.\n // As in Go, x's value must be assignable to the channel's element type.\n func (v Value) Send(x Value) {\n-\tiv := v.internal()\n-\tiv.mustBe(Chan)\n-\tiv.mustBeExported()\n-\tiv.send(x, false)\n+\tv.mustBe(Chan)\n+\tv.mustBeExported()\n+\tv.send(x, false)\n }\n \n-// internal send, possibly non-blocking\n-func (iv internalValue) send(x Value, nb bool) (selected bool) {\n-\tt := iv.typ.toType()\n-\tif t.ChanDir()&SendDir == 0 {\n+// internal send, possibly non-blocking.\n+// v is known to be a channel.\n+func (v Value) send(x Value, nb bool) (selected bool) {\n+\ttt := (*chanType)(unsafe.Pointer(v.typ))\n+\tif ChanDir(tt.dir)&SendDir == 0 {\n \t\tpanic(\"send on recv-only channel\")\n \t}\n-\tix := x.internal()\n-\tix.mustBeExported() // do not let unexported x leak\n-\tix = convertForAssignment(\"reflect.Value.Send\", nil, t.Elem(), ix)\n-\tch := *(*iword)(iv.addr)\n-\tif ch == 0 {\n-\t\tpanic(\"send on nil channel\")\n-\t}\n-\treturn chansend(iv.typ.runtimeType(), ch, ix.word, nb)\n+\tx.mustBeExported()\n+\tx = x.assignTo(\"reflect.Value.Send\", toCommonType(tt.elem), nil)\n+\treturn chansend(v.typ.runtimeType(), *(*iword)(v.iword()), x.iword(), nb)\n }\n \n // Set assigns x to the value v.\n // It panics if CanSet returns false.\n // As in Go, x's value must be assignable to v's type.\n func (v Value) Set(x Value) {\n-\tiv := v.internal()\n-\tix := x.internal()\n-\n-\tiv.mustBeAssignable()\n-\tix.mustBeExported() // do not let unexported x leak\n-\n-\tix = convertForAssignment(\"reflect.Set\", iv.addr, iv.typ, ix)\n-\n-\tn := ix.typ.size\n-\tif Kind(ix.typ.kind) == Ptr || Kind(ix.typ.kind) == UnsafePointer {\n-\t\tstoreIword(iv.addr, ix.word, n)\n+\tv.mustBeAssignable()\n+\tx.mustBeExported() // do not let unexported x leak\n+\tvar target *interface{}\n+\tif v.kind() == Interface {\n+\t\ttarget = (*interface{})(v.val)\n+\t}\n+\tx = x.assignTo(\"reflect.Set\", v.typ, target)\n+\tif x.flag&flagIndir != 0 {\n+\t\tmemmove(v.val, x.val, v.typ.size)\n \t} else {\n-\t\tmemmove(iv.addr, ix.addr, n)\n+\t\tstoreIword(v.val, iword(x.val), v.typ.size)\n \t}\n }\n \n // SetBool sets v's underlying value.\n // It panics if v's Kind is not Bool or if CanSet() is false.\n func (v Value) SetBool(x bool) {\n-\tiv := v.internal()\n-\tiv.mustBeAssignable()\n-\tiv.mustBe(Bool)\n-\t*(*bool)(iv.addr) = x\n+\tv.mustBeAssignable()\n+\tv.mustBe(Bool)\n+\t*(*bool)(v.val) = x\n }\n \n // SetBytes sets v's underlying value.\n // It panics if v's underlying value is not a slice of bytes.\n func (v Value) SetBytes(x []byte) {\n-\tiv := v.internal()\n-\tiv.mustBeAssignable()\n-\tiv.mustBe(Slice)\n-\ttyp := iv.typ.toType()\n-\tif typ.Elem().Kind() != Uint8 {\n+\tv.mustBeAssignable()\n+\tv.mustBe(Slice)\n+\tif v.typ.Elem().Kind() != Uint8 {\n \t\tpanic(\"reflect.Value.SetBytes of non-byte slice\")\n \t}\n-\t*(*[]byte)(iv.addr) = x\n+\t*(*[]byte)(v.val) = x\n }\n \n // SetComplex sets v's underlying value to x.\n // It panics if v's Kind is not Complex64 or Complex128, or if CanSet() is false.\n func (v Value) SetComplex(x complex128) {\n-\tiv := v.internal()\n-\tiv.mustBeAssignable()\n-\tswitch iv.kind {\n+\tv.mustBeAssignable()\n+\tswitch k := v.kind(); k {\n \tdefault:\n-\t\tpanic(&ValueError{\"reflect.Value.SetComplex\", iv.kind})\n+\t\tpanic(&ValueError{\"reflect.Value.SetComplex\", k})\n \tcase Complex64:\n-\t\t*(*complex64)(iv.addr) = complex64(x)\n+\t\t*(*complex64)(v.val) = complex64(x)\n \tcase Complex128:\n-\t\t*(*complex128)(iv.addr) = x\n+\t\t*(*complex128)(v.val) = x\n \t}\n }\n \n // SetFloat sets v's underlying value to x.\n // It panics if v's Kind is not Float32 or Float64, or if CanSet() is false.\n func (v Value) SetFloat(x float64) {\n-\tiv := v.internal()\n-\tiv.mustBeAssignable()\n-\tswitch iv.kind {\n+\tv.mustBeAssignable()\n+\tswitch k := v.kind(); k {\n \tdefault:\n-\t\tpanic(&ValueError{\"reflect.Value.SetFloat\", iv.kind})\n+\t\tpanic(&ValueError{\"reflect.Value.SetFloat\", k})\n \tcase Float32:\n-\t\t*(*float32)(iv.addr) = float32(x)\n+\t\t*(*float32)(v.val) = float32(x)\n \tcase Float64:\n-\t\t*(*float64)(iv.addr) = x\n+\t\t*(*float64)(v.val) = x\n \t}\n }\n \n // SetInt sets v's underlying value to x.\n // It panics if v's Kind is not Int, Int8, Int16, Int32, or Int64, or if CanSet() is false.\n func (v Value) SetInt(x int64) {\n-\tiv := v.internal()\n-\tiv.mustBeAssignable()\n-\tswitch iv.kind {\n+\tv.mustBeAssignable()\n+\tswitch k := v.kind(); k {\n \tdefault:\n-\t\tpanic(&ValueError{\"reflect.Value.SetInt\", iv.kind})\n+\t\tpanic(&ValueError{\"reflect.Value.SetInt\", k})\n \tcase Int:\n-\t\t*(*int)(iv.addr) = int(x)\n+\t\t*(*int)(v.val) = int(x)\n \tcase Int8:\n-\t\t*(*int8)(iv.addr) = int8(x)\n+\t\t*(*int8)(v.val) = int8(x)\n \tcase Int16:\n-\t\t*(*int16)(iv.addr) = int16(x)\n+\t\t*(*int16)(v.val) = int16(x)\n \tcase Int32:\n-\t\t*(*int32)(iv.addr) = int32(x)\n+\t\t*(*int32)(v.val) = int32(x)\n \tcase Int64:\n-\t\t*(*int64)(iv.addr) = x\n+\t\t*(*int64)(v.val) = x\n \t}\n }\n \n // SetLen sets v's length to n.\n // It panics if v's Kind is not Slice.\n func (v Value) SetLen(n int) {\n-\tiv := v.internal()\n-\tiv.mustBeAssignable()\n-\tiv.mustBe(Slice)\n-\ts := (*SliceHeader)(iv.addr)\n+\tv.mustBeAssignable()\n+\tv.mustBe(Slice)\n+\ts := (*SliceHeader)(v.val)\n \tif n < 0 || n > int(s.Cap) {\n \t\tpanic(\"reflect: slice length out of range in SetLen\")\n \t}\n@@ -1339,117 +1262,113 @@ func (v Value) SetLen(n int) {\n // As in Go, key's value must be assignable to the map's key type,\n // and val's value must be assignable to the map's value type.\n func (v Value) SetMapIndex(key, val Value) {\n-\tiv := v.internal()\n-\tikey := key.internal()\n-\tival := val.internal()\n-\n-\tiv.mustBe(Map)\n-\tiv.mustBeExported()\n-\n-\tikey.mustBeExported()\n-\tikey = convertForAssignment(\"reflect.Value.SetMapIndex\", nil, iv.typ.Key(), ikey)\n-\n-\tif ival.kind != Invalid {\n-\t\tival.mustBeExported()\n-\t\tival = convertForAssignment(\"reflect.Value.SetMapIndex\", nil, iv.typ.Elem(), ival)\n+\tv.mustBe(Map)\n+\tv.mustBeExported()\n+\tkey.mustBeExported()\n+\ttt := (*mapType)(unsafe.Pointer(v.typ))\n+\tkey = key.assignTo(\"reflect.Value.SetMapIndex\", toCommonType(tt.key), nil)\n+\tif val.typ != nil {\n+\t\tval.mustBeExported()\n+\t\tval = val.assignTo(\"reflect.Value.SetMapIndex\", toCommonType(tt.elem), nil)\n \t}\n-\n-\tmapassign(iv.typ.runtimeType(), *(*iword)(iv.addr), ikey.word, ival.word, ival.kind != Invalid)\n+\tmapassign(v.typ.runtimeType(), *(*iword)(v.iword()), key.iword(), val.iword(), val.typ != nil)\n }\n \n // SetUint sets v's underlying value to x.\n // It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64, or if CanSet() is false.\n func (v Value) SetUint(x uint64) {\n-\tiv := v.internal()\n-\tiv.mustBeAssignable()\n-\tswitch iv.kind {\n+\tv.mustBeAssignable()\n+\tswitch k := v.kind(); k {\n \tdefault:\n-\t\tpanic(&ValueError{\"reflect.Value.SetUint\", iv.kind})\n+\t\tpanic(&ValueError{\"reflect.Value.SetUint\", k})\n \tcase Uint:\n-\t\t*(*uint)(iv.addr) = uint(x)\n+\t\t*(*uint)(v.val) = uint(x)\n \tcase Uint8:\n-\t\t*(*uint8)(iv.addr) = uint8(x)\n+\t\t*(*uint8)(v.val) = uint8(x)\n \tcase Uint16:\n-\t\t*(*uint16)(iv.addr) = uint16(x)\n+\t\t*(*uint16)(v.val) = uint16(x)\n \tcase Uint32:\n-\t\t*(*uint32)(iv.addr) = uint32(x)\n+\t\t*(*uint32)(v.val) = uint32(x)\n \tcase Uint64:\n-\t\t*(*uint64)(iv.addr) = x\n+\t\t*(*uint64)(v.val) = x\n \tcase Uintptr:\n-\t\t*(*uintptr)(iv.addr) = uintptr(x)\n+\t\t*(*uintptr)(v.val) = uintptr(x)\n \t}\n }\n \n // SetPointer sets the unsafe.Pointer value v to x.\n // It panics if v's Kind is not UnsafePointer.\n func (v Value) SetPointer(x unsafe.Pointer) {\n-\tiv := v.internal()\n-\tiv.mustBeAssignable()\n-\tiv.mustBe(UnsafePointer)\n-\t*(*unsafe.Pointer)(iv.addr) = x\n+\tv.mustBeAssignable()\n+\tv.mustBe(UnsafePointer)\n+\t*(*unsafe.Pointer)(v.val) = x\n }\n \n // SetString sets v's underlying value to x.\n // It panics if v's Kind is not String or if CanSet() is false.\n func (v Value) SetString(x string) {\n-\tiv := v.internal()\n-\tiv.mustBeAssignable()\n-\tiv.mustBe(String)\n-\t*(*string)(iv.addr) = x\n+\tv.mustBeAssignable()\n+\tv.mustBe(String)\n+\t*(*string)(v.val) = x\n }\n \n // Slice returns a slice of v.\n // It panics if v's Kind is not Array or Slice.\n func (v Value) Slice(beg, end int) Value {\n-\tiv := v.internal()\n-\tif iv.kind != Array && iv.kind != Slice {\n-\t\tpanic(&ValueError{\"reflect.Value.Slice\", iv.kind})\n-\t}\n-\tcap := v.Cap()\n-\tif beg < 0 || end < beg || end > cap {\n-\t\tpanic(\"reflect.Value.Slice: slice index out of bounds\")\n-\t}\n-\tvar typ Type\n-\tvar base uintptr\n-\tswitch iv.kind {\n+\tvar (\n+\t\tcap  int\n+\t\ttyp  *sliceType\n+\t\tbase unsafe.Pointer\n+\t)\n+\tswitch k := v.kind(); k {\n+\tdefault:\n+\t\tpanic(&ValueError{\"reflect.Value.Slice\", k})\n \tcase Array:\n-\t\tif iv.flag&flagAddr == 0 {\n+\t\tif v.flag&flagAddr == 0 {\n \t\t\tpanic(\"reflect.Value.Slice: slice of unaddressable array\")\n \t\t}\n-\t\ttyp = toType((*arrayType)(unsafe.Pointer(iv.typ)).slice)\n-\t\tbase = uintptr(iv.addr)\n+\t\ttt := (*arrayType)(unsafe.Pointer(v.typ))\n+\t\tcap = int(tt.len)\n+\t\ttyp = (*sliceType)(unsafe.Pointer(toCommonType(tt.slice)))\n+\t\tbase = v.val\n \tcase Slice:\n-\t\ttyp = iv.typ.toType()\n-\t\tbase = (*SliceHeader)(iv.addr).Data\n+\t\ttyp = (*sliceType)(unsafe.Pointer(v.typ))\n+\t\ts := (*SliceHeader)(v.val)\n+\t\tbase = unsafe.Pointer(s.Data)\n+\t\tcap = s.Cap\n+\n+\t}\n+\tif beg < 0 || end < beg || end > cap {\n+\t\tpanic(\"reflect.Value.Slice: slice index out of bounds\")\n \t}\n \n \t// Declare slice so that gc can see the base pointer in it.\n \tvar x []byte\n \n \t// Reinterpret as *SliceHeader to edit.\n \ts := (*SliceHeader)(unsafe.Pointer(&x))\n-\ts.Data = base + uintptr(beg)*typ.Elem().Size()\n+\ts.Data = uintptr(base) + uintptr(beg)*toCommonType(typ.elem).Size()\n \ts.Len = end - beg\n \ts.Cap = end - beg\n \n-\treturn valueFromAddr(iv.flag&flagRO, typ, unsafe.Pointer(&x))\n+\tfl := v.flag&flagRO | flagIndir | flag(Slice)<<flagKindShift\n+\treturn Value{typ.common(), unsafe.Pointer(&x), fl}\n }\n \n // String returns the string v's underlying value, as a string.\n // String is a special case because of Go's String method convention.\n // Unlike the other getters, it does not panic if v's Kind is not String.\n // Instead, it returns a string of the form \"<T value>\" where T is v's type.\n func (v Value) String() string {\n-\tiv := v.internal()\n-\tswitch iv.kind {\n+\tswitch k := v.kind(); k {\n \tcase Invalid:\n \t\treturn \"<invalid Value>\"\n \tcase String:\n-\t\treturn *(*string)(iv.addr)\n+\t\treturn *(*string)(v.val)\n \t}\n \t// If you call String on a reflect.Value of other type, it's better to\n \t// print something than to panic. Useful in debugging.\n-\treturn \"<\" + iv.typ.String() + \" Value>\"\n+\treturn \"<\" + v.typ.String() + \" Value>\"\n }\n \n // TryRecv attempts to receive a value from the channel v but will not block.\n@@ -1458,65 +1377,93 @@ func (v Value) String() string {\n // The boolean ok is true if the value x corresponds to a send\n // on the channel, false if it is a zero value received because the channel is closed.\n func (v Value) TryRecv() (x Value, ok bool) {\n-\tiv := v.internal()\n-\tiv.mustBe(Chan)\n-\tiv.mustBeExported()\n-\treturn iv.recv(true)\n+\tv.mustBe(Chan)\n+\tv.mustBeExported()\n+\treturn v.recv(true)\n }\n \n // TrySend attempts to send x on the channel v but will not block.\n // It panics if v's Kind is not Chan.\n // It returns true if the value was sent, false otherwise.\n // As in Go, x's value must be assignable to the channel's element type.\n func (v Value) TrySend(x Value) bool {\n-\tiv := v.internal()\n-\tiv.mustBe(Chan)\n-\tiv.mustBeExported()\n-\treturn iv.send(x, true)\n+\tv.mustBe(Chan)\n+\tv.mustBeExported()\n+\treturn v.send(x, true)\n }\n \n // Type returns v's type.\n func (v Value) Type() Type {\n-\tt := v.internal().typ\n-\tif t == nil {\n+\tf := v.flag\n+\tif f == 0 {\n \t\tpanic(&ValueError{\"reflect.Value.Type\", Invalid})\n \t}\n-\treturn t.toType()\n+\tif f&flagMethod == 0 {\n+\t\t// Easy case\n+\t\treturn v.typ.toType()\n+\t}\n+\n+\t// Method value.\n+\t// v.typ describes the receiver, not the method type.\n+\ti := int(v.flag) >> flagMethodShift\n+\tif v.typ.Kind() == Interface {\n+\t\t// Method on interface.\n+\t\ttt := (*interfaceType)(unsafe.Pointer(v.typ))\n+\t\tif i < 0 || i >= len(tt.methods) {\n+\t\t\tpanic(\"reflect: broken Value\")\n+\t\t}\n+\t\tm := &tt.methods[i]\n+\t\treturn toCommonType(m.typ).toType()\n+\t}\n+\t// Method on concrete type.\n+\tut := v.typ.uncommon()\n+\tif ut == nil || i < 0 || i >= len(ut.methods) {\n+\t\tpanic(\"reflect: broken Value\")\n+\t}\n+\tm := &ut.methods[i]\n+\treturn toCommonType(m.mtyp).toType()\n }\n \n // Uint returns v's underlying value, as a uint64.\n // It panics if v's Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.\n func (v Value) Uint() uint64 {\n-\tiv := v.internal()\n-\tswitch iv.kind {\n+\tk := v.kind()\n+\tvar p unsafe.Pointer\n+\tif v.flag&flagIndir != 0 {\n+\t\tp = v.val\n+\t} else {\n+\t\t// The escape analysis is good enough that &v.val\n+\t\t// does not trigger a heap allocation.\n+\t\tp = unsafe.Pointer(&v.val)\n+\t}\n+\tswitch k {\n \tcase Uint:\n-\t\treturn uint64(*(*uint)(iv.addr))\n+\t\treturn uint64(*(*uint)(p))\n \tcase Uint8:\n-\t\treturn uint64(*(*uint8)(iv.addr))\n+\t\treturn uint64(*(*uint8)(p))\n \tcase Uint16:\n-\t\treturn uint64(*(*uint16)(iv.addr))\n+\t\treturn uint64(*(*uint16)(p))\n \tcase Uint32:\n-\t\treturn uint64(*(*uint32)(iv.addr))\n-\tcase Uintptr:\n-\t\treturn uint64(*(*uintptr)(iv.addr))\n+\t\treturn uint64(*(*uint32)(p))\n \tcase Uint64:\n-\t\treturn *(*uint64)(iv.addr)\n+\t\treturn uint64(*(*uint64)(p))\n+\tcase Uintptr:\n+\t\treturn uint64(*(*uintptr)(p))\n \t}\n-\tpanic(&ValueError{\"reflect.Value.Uint\", iv.kind})\n+\tpanic(&ValueError{\"reflect.Value.Uint\", k})\n }\n \n // UnsafeAddr returns a pointer to v's data.\n // It is for advanced clients that also import the \"unsafe\" package.\n // It panics if v is not addressable.\n func (v Value) UnsafeAddr() uintptr {\n-\tiv := v.internal()\n-\tif iv.kind == Invalid {\n-\t\tpanic(&ValueError{\"reflect.Value.UnsafeAddr\", iv.kind})\n+\tif v.typ == nil {\n+\t\tpanic(&ValueError{\"reflect.Value.UnsafeAddr\", Invalid})\n \t}\n-\tif iv.flag&flagAddr == 0 {\n+\tif v.flag&flagAddr == 0 {\n \t\tpanic(\"reflect.Value.UnsafeAddr of unaddressable value\")\n \t}\n-\treturn uintptr(iv.addr)\n+\treturn uintptr(v.val)\n }\n \n // StringHeader is the runtime representation of a string.\n@@ -1536,7 +1483,7 @@ type SliceHeader struct {\n \n func typesMustMatch(what string, t1, t2 Type) {\n \tif t1 != t2 {\n-\t\tpanic(\"reflect: \" + what + \": \" + t1.String() + \" != \" + t2.String())\n+\t\tpanic(what + \": \" + t1.String() + \" != \" + t2.String())\n \t}\n }\n \n@@ -1571,7 +1518,7 @@ func grow(s Value, extra int) (Value, int, int) {\n // Append appends the values x to a slice s and returns the resulting slice.\n // As in Go, each x's value must be assignable to the slice's element type.\n func Append(s Value, x ...Value) Value {\n-\ts.internal().mustBe(Slice)\n+\ts.mustBe(Slice)\n \ts, i0, i1 := grow(s, len(x))\n \tfor i, j := i0, 0; i < i1; i, j = i+1, j+1 {\n \t\ts.Index(i).Set(x[j])\n@@ -1582,8 +1529,8 @@ func Append(s Value, x ...Value) Value {\n // AppendSlice appends a slice t to a slice s and returns the resulting slice.\n // The slices s and t must have the same element type.\n func AppendSlice(s, t Value) Value {\n-\ts.internal().mustBe(Slice)\n-\tt.internal().mustBe(Slice)\n+\ts.mustBe(Slice)\n+\tt.mustBe(Slice)\n \ttypesMustMatch(\"reflect.AppendSlice\", s.Type().Elem(), t.Type().Elem())\n \ts, i0, i1 := grow(s, t.Len())\n \tCopy(s.Slice(i0, i1), t)\n@@ -1596,23 +1543,23 @@ func AppendSlice(s, t Value) Value {\n // Dst and src each must have kind Slice or Array, and\n // dst and src must have the same element type.\n func Copy(dst, src Value) int {\n-\tidst := dst.internal()\n-\tisrc := src.internal()\n-\n-\tif idst.kind != Array && idst.kind != Slice {\n-\t\tpanic(&ValueError{\"reflect.Copy\", idst.kind})\n+\tdk := dst.kind()\n+\tif dk != Array && dk != Slice {\n+\t\tpanic(&ValueError{\"reflect.Copy\", dk})\n \t}\n-\tif idst.kind == Array {\n-\t\tidst.mustBeAssignable()\n+\tif dk == Array {\n+\t\tdst.mustBeAssignable()\n \t}\n-\tidst.mustBeExported()\n-\tif isrc.kind != Array && isrc.kind != Slice {\n-\t\tpanic(&ValueError{\"reflect.Copy\", isrc.kind})\n+\tdst.mustBeExported()\n+\n+\tsk := src.kind()\n+\tif sk != Array && sk != Slice {\n+\t\tpanic(&ValueError{\"reflect.Copy\", sk})\n \t}\n-\tisrc.mustBeExported()\n+\tsrc.mustBeExported()\n \n-\tde := idst.typ.Elem()\n-\tse := isrc.typ.Elem()\n+\tde := dst.typ.Elem()\n+\tse := src.typ.Elem()\n \ttypesMustMatch(\"reflect.Copy\", de, se)\n \n \tn := dst.Len()\n@@ -1622,7 +1569,7 @@ func Copy(dst, src Value) int {\n \n \t// If sk is an in-line array, cannot take its address.\n \t// Instead, copy element by element.\n-\tif isrc.addr == nil {\n+\tif src.flag&flagIndir == 0 {\n \t\tfor i := 0; i < n; i++ {\n \t\t\tdst.Index(i).Set(src.Index(i))\n \t\t}\n@@ -1631,15 +1578,15 @@ func Copy(dst, src Value) int {\n \n \t// Copy via memmove.\n \tvar da, sa unsafe.Pointer\n-\tif idst.kind == Array {\n-\t\tda = idst.addr\n+\tif dk == Array {\n+\t\tda = dst.val\n \t} else {\n-\t\tda = unsafe.Pointer((*SliceHeader)(idst.addr).Data)\n+\t\tda = unsafe.Pointer((*SliceHeader)(dst.val).Data)\n \t}\n-\tif isrc.kind == Array {\n-\t\tsa = isrc.addr\n+\tif sk == Array {\n+\t\tsa = src.val\n \t} else {\n-\t\tsa = unsafe.Pointer((*SliceHeader)(isrc.addr).Data)\n+\t\tsa = unsafe.Pointer((*SliceHeader)(src.val).Data)\n \t}\n \tmemmove(da, sa, uintptr(n)*de.Size())\n \treturn n\n@@ -1653,7 +1600,7 @@ func Copy(dst, src Value) int {\n // for the specified slice type, length, and capacity.\n func MakeSlice(typ Type, len, cap int) Value {\n \tif typ.Kind() != Slice {\n-\t\tpanic(\"reflect: MakeSlice of non-slice type\")\n+\t\tpanic(\"reflect.MakeSlice of non-slice type\")\n \t}\n \n \t// Declare slice so that gc can see the base pointer in it.\n@@ -1665,31 +1612,31 @@ func MakeSlice(typ Type, len, cap int) Value {\n \ts.Len = len\n \ts.Cap = cap\n \n-\treturn valueFromAddr(0, typ, unsafe.Pointer(&x))\n+\treturn Value{typ.common(), unsafe.Pointer(&x), flagIndir | flag(Slice)<<flagKindShift}\n }\n \n // MakeChan creates a new channel with the specified type and buffer size.\n func MakeChan(typ Type, buffer int) Value {\n \tif typ.Kind() != Chan {\n-\t\tpanic(\"reflect: MakeChan of non-chan type\")\n+\t\tpanic(\"reflect.MakeChan of non-chan type\")\n \t}\n \tif buffer < 0 {\n-\t\tpanic(\"MakeChan: negative buffer size\")\n+\t\tpanic(\"reflect.MakeChan: negative buffer size\")\n \t}\n \tif typ.ChanDir() != BothDir {\n-\t\tpanic(\"MakeChan: unidirectional channel type\")\n+\t\tpanic(\"reflect.MakeChan: unidirectional channel type\")\n \t}\n \tch := makechan(typ.runtimeType(), uint32(buffer))\n-\treturn valueFromIword(0, typ, ch)\n+\treturn Value{typ.common(), unsafe.Pointer(ch), flagIndir | (flag(Chan)<<flagKindShift)}\n }\n \n // MakeMap creates a new map of the specified type.\n func MakeMap(typ Type) Value {\n \tif typ.Kind() != Map {\n-\t\tpanic(\"reflect: MakeMap of non-map type\")\n+\t\tpanic(\"reflect.MakeMap of non-map type\")\n \t}\n \tm := makemap(typ.runtimeType())\n-\treturn valueFromIword(0, typ, m)\n+\treturn Value{typ.common(), unsafe.Pointer(m), flagIndir | (flag(Map)<<flagKindShift)}\n }\n \n // Indirect returns the value that v points to.\n@@ -1719,7 +1666,12 @@ func ValueOf(i interface{}) Value {\n \t// For an interface value with the noAddr bit set,\n \t// the representation is identical to an empty interface.\n \teface := *(*emptyInterface)(unsafe.Pointer(&i))\n-\treturn packValue(0, eface.typ, eface.word)\n+\ttyp := toCommonType(eface.typ)\n+\tfl := flag(typ.Kind()) << flagKindShift\n+\tif typ.Kind() != Ptr && typ.Kind() != UnsafePointer {\n+\t\tfl |= flagIndir\n+\t}\n+\treturn Value{typ, unsafe.Pointer(eface.word), fl}\n }\n \n // Zero returns a Value representing a zero value for the specified type.\n@@ -1730,10 +1682,12 @@ func Zero(typ Type) Value {\n \tif typ == nil {\n \t\tpanic(\"reflect: Zero(nil)\")\n \t}\n-\tif typ.Kind() == Ptr || typ.Kind() == UnsafePointer {\n-\t\treturn valueFromIword(0, typ, 0)\n+\tt := typ.common()\n+\tfl := flag(t.Kind()) << flagKindShift\n+\tif t.Kind() == Ptr || t.Kind() == UnsafePointer {\n+\t\treturn Value{t, nil, fl}\n \t}\n-\treturn valueFromAddr(0, typ, unsafe.New(typ))\n+\treturn Value{t, unsafe.New(typ), fl | flagIndir}\n }\n \n // New returns a Value representing a pointer to a new zero value\n@@ -1743,40 +1697,42 @@ func New(typ Type) Value {\n \t\tpanic(\"reflect: New(nil)\")\n \t}\n \tptr := unsafe.New(typ)\n-\treturn valueFromIword(0, PtrTo(typ), iword(uintptr(ptr)))\n+\tfl := flag(Ptr) << flagKindShift\n+\treturn Value{typ.common().ptrTo(), ptr, fl}\n }\n \n-// convertForAssignment \n-func convertForAssignment(what string, addr unsafe.Pointer, dst Type, iv internalValue) internalValue {\n-\tif iv.method {\n-\t\tpanic(what + \": cannot assign method value to type \" + dst.String())\n+// assignTo returns a value v that can be assigned directly to typ.\n+// It panics if v is not assignable to typ.\n+// For a conversion to an interface type, target is a suggested scratch space to use.\n+func (v Value) assignTo(context string, dst *commonType, target *interface{}) Value {\n+\tif v.flag&flagMethod != 0 {\n+\t\tpanic(context + \": cannot assign method value to type \" + dst.String())\n \t}\n \n-\tdst1 := dst.(*commonType)\n-\tif directlyAssignable(dst1, iv.typ) {\n+\tswitch {\n+\tcase directlyAssignable(dst, v.typ):\n \t\t// Overwrite type so that they match.\n \t\t// Same memory layout, so no harm done.\n-\t\tiv.typ = dst1\n-\t\treturn iv\n-\t}\n-\tif implements(dst1, iv.typ) {\n-\t\tif addr == nil {\n-\t\t\taddr = unsafe.Pointer(new(interface{}))\n+\t\tv.typ = dst\n+\t\tfl := v.flag & (flagRO | flagAddr | flagIndir)\n+\t\tfl |= flag(dst.Kind()) << flagKindShift\n+\t\treturn Value{dst, v.val, fl}\n+\n+\tcase implements(dst, v.typ):\n+\t\tif target == nil {\n+\t\t\ttarget = new(interface{})\n \t\t}\n-\t\tx := iv.valueInterface(false)\n+\t\tx := valueInterface(v, false)\n \t\tif dst.NumMethod() == 0 {\n-\t\t\t*(*interface{})(addr) = x\n+\t\t\t*target = x\n \t\t} else {\n-\t\t\tifaceE2I(dst1.runtimeType(), x, addr)\n+\t\t\tifaceE2I(dst.runtimeType(), x, unsafe.Pointer(target))\n \t\t}\n-\t\tiv.addr = addr\n-\t\tiv.word = iword(uintptr(addr))\n-\t\tiv.typ = dst1\n-\t\treturn iv\n+\t\treturn Value{dst, unsafe.Pointer(target), flagIndir | flag(Interface)<<flagKindShift}\n \t}\n \n \t// Failed.\n-\tpanic(what + \": value of type \" + iv.typ.String() + \" is not assignable to type \" + dst.String())\n+\tpanic(context + \": value of type \" + v.typ.String() + \" is not assignable to type \" + dst.String())\n }\n \n // implemented in ../pkg/runtime\n@@ -1787,7 +1743,7 @@ func chanrecv(t *runtime.Type, ch iword, nb bool) (val iword, selected, received\n func chansend(t *runtime.Type, ch iword, val iword, nb bool) bool\n \n func makechan(typ *runtime.Type, size uint32) (ch iword)\n-func makemap(t *runtime.Type) iword\n+func makemap(t *runtime.Type) (m iword)\n func mapaccess(t *runtime.Type, m iword, key iword) (val iword, ok bool)\n func mapassign(t *runtime.Type, m iword, key, val iword, ok bool)\n func mapiterinit(t *runtime.Type, m iword) *byte\n@@ -1797,3 +1753,17 @@ func maplen(m iword) int32\n \n func call(typ *commonType, fnaddr unsafe.Pointer, isInterface bool, isMethod bool, params *unsafe.Pointer, results *unsafe.Pointer)\n func ifaceE2I(t *runtime.Type, src interface{}, dst unsafe.Pointer)\n+\n+// Dummy annotation marking that the value x escapes,\n+// for use in cases where the reflect code is so clever that\n+// the compiler cannot follow.\n+func escapes(x interface{}) {\n+\tif dummy.b {\n+\t\tdummy.x = x\n+\t}\n+}\n+\n+var dummy struct {\n+\tb bool\n+\tx interface{}\n+}"}, {"sha": "59f3be39d294d56ab19ca4c6bb7a4b01215ceeb9", "filename": "libgo/go/regexp/regexp.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fregexp%2Fregexp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fregexp%2Fregexp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fregexp%2Fregexp.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -1,7 +1,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package regexp implements a simple regular expression library.\n+// Package regexp implements regular expression search.\n //\n // The syntax of the regular expressions accepted is the same\n // general syntax used by Perl, Python, and other languages."}, {"sha": "541553097bbb3a2e9fcb1449bc2cc34710693277", "filename": "libgo/go/strconv/decimal.go", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fstrconv%2Fdecimal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fstrconv%2Fdecimal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fdecimal.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -102,12 +102,6 @@ func (a *decimal) Assign(v uint64) {\n \ttrim(a)\n }\n \n-func newDecimal(i uint64) *decimal {\n-\ta := new(decimal)\n-\ta.Assign(i)\n-\treturn a\n-}\n-\n // Maximum shift that we can do in one pass without overflow.\n // Signed int has 31 bits, and we have to be able to accommodate 9<<k.\n const maxShift = 27\n@@ -303,32 +297,32 @@ func shouldRoundUp(a *decimal, nd int) bool {\n // If nd is zero, it means we're rounding\n // just to the left of the digits, as in\n // 0.09 -> 0.1.\n-func (a *decimal) Round(nd int) *decimal {\n+func (a *decimal) Round(nd int) {\n \tif nd < 0 || nd >= a.nd {\n-\t\treturn a\n+\t\treturn\n \t}\n \tif shouldRoundUp(a, nd) {\n-\t\treturn a.RoundUp(nd)\n+\t\ta.RoundUp(nd)\n+\t} else {\n+\t\ta.RoundDown(nd)\n \t}\n-\treturn a.RoundDown(nd)\n }\n \n // Round a down to nd digits (or fewer).\n // Returns receiver for convenience.\n-func (a *decimal) RoundDown(nd int) *decimal {\n+func (a *decimal) RoundDown(nd int) {\n \tif nd < 0 || nd >= a.nd {\n-\t\treturn a\n+\t\treturn\n \t}\n \ta.nd = nd\n \ttrim(a)\n-\treturn a\n }\n \n // Round a up to nd digits (or fewer).\n // Returns receiver for convenience.\n-func (a *decimal) RoundUp(nd int) *decimal {\n+func (a *decimal) RoundUp(nd int) {\n \tif nd < 0 || nd >= a.nd {\n-\t\treturn a\n+\t\treturn\n \t}\n \n \t// round up\n@@ -337,7 +331,7 @@ func (a *decimal) RoundUp(nd int) *decimal {\n \t\tif c < '9' { // can stop after this digit\n \t\t\ta.d[i]++\n \t\t\ta.nd = i + 1\n-\t\t\treturn a\n+\t\t\treturn\n \t\t}\n \t}\n \n@@ -346,7 +340,6 @@ func (a *decimal) RoundUp(nd int) *decimal {\n \ta.d[0] = '1'\n \ta.nd = 1\n \ta.dp++\n-\treturn a\n }\n \n // Extract integer part, rounded appropriately."}, {"sha": "13a127f5b2cfc9a1123a86d2711132ca69555891", "filename": "libgo/go/strconv/decimal_test.go", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fstrconv%2Fdecimal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fstrconv%2Fdecimal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fdecimal_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -70,17 +70,23 @@ var roundtests = []roundTest{\n func TestDecimalRound(t *testing.T) {\n \tfor i := 0; i < len(roundtests); i++ {\n \t\ttest := &roundtests[i]\n-\t\ts := NewDecimal(test.i).RoundDown(test.nd).String()\n+\t\td := NewDecimal(test.i)\n+\t\td.RoundDown(test.nd)\n+\t\ts := d.String()\n \t\tif s != test.down {\n \t\t\tt.Errorf(\"Decimal %v RoundDown %d = %v, want %v\",\n \t\t\t\ttest.i, test.nd, s, test.down)\n \t\t}\n-\t\ts = NewDecimal(test.i).Round(test.nd).String()\n+\t\td = NewDecimal(test.i)\n+\t\td.Round(test.nd)\n+\t\ts = d.String()\n \t\tif s != test.round {\n \t\t\tt.Errorf(\"Decimal %v Round %d = %v, want %v\",\n \t\t\t\ttest.i, test.nd, s, test.down)\n \t\t}\n-\t\ts = NewDecimal(test.i).RoundUp(test.nd).String()\n+\t\td = NewDecimal(test.i)\n+\t\td.RoundUp(test.nd)\n+\t\ts = d.String()\n \t\tif s != test.up {\n \t\t\tt.Errorf(\"Decimal %v RoundUp %d = %v, want %v\",\n \t\t\t\ttest.i, test.nd, s, test.up)"}, {"sha": "8342b6abe79494db82e085a377396e3479518c6b", "filename": "libgo/go/strconv/ftoa.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fstrconv%2Fftoa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fstrconv%2Fftoa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fftoa.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -98,7 +98,8 @@ func genericFtoa(bits uint64, fmt byte, prec int, flt *floatInfo) string {\n \t// The shift is exp - flt.mantbits because mant is a 1-bit integer\n \t// followed by a flt.mantbits fraction, and we are treating it as\n \t// a 1+flt.mantbits-bit integer.\n-\td := newDecimal(mant)\n+\td := new(decimal)\n+\td.Assign(mant)\n \td.Shift(exp - int(flt.mantbits))\n \n \t// Round appropriately.\n@@ -184,7 +185,8 @@ func roundShortest(d *decimal, mant uint64, exp int, flt *floatInfo) {\n \t// d = mant << (exp - mantbits)\n \t// Next highest floating point number is mant+1 << exp-mantbits.\n \t// Our upper bound is halfway inbetween, mant*2+1 << exp-mantbits-1.\n-\tupper := newDecimal(mant*2 + 1)\n+\tupper := new(decimal)\n+\tupper.Assign(mant*2 + 1)\n \tupper.Shift(exp - int(flt.mantbits) - 1)\n \n \t// d = mant << (exp - mantbits)\n@@ -203,7 +205,8 @@ func roundShortest(d *decimal, mant uint64, exp int, flt *floatInfo) {\n \t\tmantlo = mant*2 - 1\n \t\texplo = exp - 1\n \t}\n-\tlower := newDecimal(mantlo*2 + 1)\n+\tlower := new(decimal)\n+\tlower.Assign(mantlo*2 + 1)\n \tlower.Shift(explo - int(flt.mantbits) - 1)\n \n \t// The upper and lower bounds are possible outputs only if"}, {"sha": "8bac5da452671e3047bfe3210a500129e51e1f89", "filename": "libgo/go/strconv/ftoa_test.go", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fstrconv%2Fftoa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fstrconv%2Fftoa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fftoa_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -148,3 +148,27 @@ func TestFtoa(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func BenchmarkFtoa64Decimal(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tFtoa64(33909, 'g', -1)\n+\t}\n+}\n+\n+func BenchmarkFtoa64Float(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tFtoa64(339.7784, 'g', -1)\n+\t}\n+}\n+\n+func BenchmarkFtoa64FloatExp(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tFtoa64(-5.09e75, 'g', -1)\n+\t}\n+}\n+\n+func BenchmarkFtoa64Big(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tFtoa64(123456789123456789123456789, 'g', -1)\n+\t}\n+}"}, {"sha": "d0fa80edfb6f9a7f2a66535405111c313ef863ce", "filename": "libgo/go/strconv/internal_test.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fstrconv%2Finternal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fstrconv%2Finternal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Finternal_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -6,7 +6,11 @@\n \n package strconv\n \n-func NewDecimal(i uint64) *decimal { return newDecimal(i) }\n+func NewDecimal(i uint64) *decimal {\n+\td := new(decimal)\n+\td.Assign(i)\n+\treturn d\n+}\n \n func SetOptimize(b bool) bool {\n \told := optimize"}, {"sha": "96207f5a2da6f995938dab15be67e5806023a4c2", "filename": "libgo/go/strings/strings_test.go", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fstrings%2Fstrings_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fstrings%2Fstrings_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fstrings_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -489,46 +489,47 @@ func TestSpecialCase(t *testing.T) {\n func TestTrimSpace(t *testing.T) { runStringTests(t, TrimSpace, \"TrimSpace\", trimSpaceTests) }\n \n var trimTests = []struct {\n-\tf               func(string, string) string\n+\tf               string\n \tin, cutset, out string\n }{\n-\t{Trim, \"abba\", \"a\", \"bb\"},\n-\t{Trim, \"abba\", \"ab\", \"\"},\n-\t{TrimLeft, \"abba\", \"ab\", \"\"},\n-\t{TrimRight, \"abba\", \"ab\", \"\"},\n-\t{TrimLeft, \"abba\", \"a\", \"bba\"},\n-\t{TrimRight, \"abba\", \"a\", \"abb\"},\n-\t{Trim, \"<tag>\", \"<>\", \"tag\"},\n-\t{Trim, \"* listitem\", \" *\", \"listitem\"},\n-\t{Trim, `\"quote\"`, `\"`, \"quote\"},\n-\t{Trim, \"\\u2C6F\\u2C6F\\u0250\\u0250\\u2C6F\\u2C6F\", \"\\u2C6F\", \"\\u0250\\u0250\"},\n+\t{\"Trim\", \"abba\", \"a\", \"bb\"},\n+\t{\"Trim\", \"abba\", \"ab\", \"\"},\n+\t{\"TrimLeft\", \"abba\", \"ab\", \"\"},\n+\t{\"TrimRight\", \"abba\", \"ab\", \"\"},\n+\t{\"TrimLeft\", \"abba\", \"a\", \"bba\"},\n+\t{\"TrimRight\", \"abba\", \"a\", \"abb\"},\n+\t{\"Trim\", \"<tag>\", \"<>\", \"tag\"},\n+\t{\"Trim\", \"* listitem\", \" *\", \"listitem\"},\n+\t{\"Trim\", `\"quote\"`, `\"`, \"quote\"},\n+\t{\"Trim\", \"\\u2C6F\\u2C6F\\u0250\\u0250\\u2C6F\\u2C6F\", \"\\u2C6F\", \"\\u0250\\u0250\"},\n \t//empty string tests\n-\t{Trim, \"abba\", \"\", \"abba\"},\n-\t{Trim, \"\", \"123\", \"\"},\n-\t{Trim, \"\", \"\", \"\"},\n-\t{TrimLeft, \"abba\", \"\", \"abba\"},\n-\t{TrimLeft, \"\", \"123\", \"\"},\n-\t{TrimLeft, \"\", \"\", \"\"},\n-\t{TrimRight, \"abba\", \"\", \"abba\"},\n-\t{TrimRight, \"\", \"123\", \"\"},\n-\t{TrimRight, \"\", \"\", \"\"},\n-\t{TrimRight, \"\u263a\\xc0\", \"\u263a\", \"\u263a\\xc0\"},\n+\t{\"Trim\", \"abba\", \"\", \"abba\"},\n+\t{\"Trim\", \"\", \"123\", \"\"},\n+\t{\"Trim\", \"\", \"\", \"\"},\n+\t{\"TrimLeft\", \"abba\", \"\", \"abba\"},\n+\t{\"TrimLeft\", \"\", \"123\", \"\"},\n+\t{\"TrimLeft\", \"\", \"\", \"\"},\n+\t{\"TrimRight\", \"abba\", \"\", \"abba\"},\n+\t{\"TrimRight\", \"\", \"123\", \"\"},\n+\t{\"TrimRight\", \"\", \"\", \"\"},\n+\t{\"TrimRight\", \"\u263a\\xc0\", \"\u263a\", \"\u263a\\xc0\"},\n }\n \n func TestTrim(t *testing.T) {\n \tfor _, tc := range trimTests {\n-\t\tactual := tc.f(tc.in, tc.cutset)\n-\t\tvar name string\n-\t\tswitch tc.f {\n-\t\tcase Trim:\n-\t\t\tname = \"Trim\"\n-\t\tcase TrimLeft:\n-\t\t\tname = \"TrimLeft\"\n-\t\tcase TrimRight:\n-\t\t\tname = \"TrimRight\"\n+\t\tname := tc.f\n+\t\tvar f func(string, string) string\n+\t\tswitch name {\n+\t\tcase \"Trim\":\n+\t\t\tf = Trim\n+\t\tcase \"TrimLeft\":\n+\t\t\tf = TrimLeft\n+\t\tcase \"TrimRight\":\n+\t\t\tf = TrimRight\n \t\tdefault:\n-\t\t\tt.Error(\"Undefined trim function\")\n+\t\t\tt.Error(\"Undefined trim function %s\", name)\n \t\t}\n+\t\tactual := f(tc.in, tc.cutset)\n \t\tif actual != tc.out {\n \t\t\tt.Errorf(\"%s(%q, %q) = %q; want %q\", name, tc.in, tc.cutset, actual, tc.out)\n \t\t}"}, {"sha": "4fc02743c6e717b19903ee99867f7d7cafba375b", "filename": "libgo/go/sync/mutex.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsync%2Fmutex.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsync%2Fmutex.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fmutex.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -6,6 +6,8 @@\n // exclusion locks.  Other than the Once and WaitGroup types, most are intended\n // for use by low-level library routines.  Higher-level synchronization is\n // better done via channels and communication.\n+//\n+// Values containing the types defined in this package should not be copied.\n package sync\n \n import ("}, {"sha": "f94b7233b6716d66a5be7a6d19f2cd374c2a447d", "filename": "libgo/go/syscall/bpf_bsd.go", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fbpf_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fbpf_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fbpf_bsd.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -20,150 +20,150 @@ func BpfJump(code, k, jt, jf int) *BpfInsn {\n \treturn &BpfInsn{Code: uint16(code), Jt: uint8(jt), Jf: uint8(jf), K: uint32(k)}\n }\n \n-func BpfBuflen(fd int) (int, int) {\n+func BpfBuflen(fd int) (int, error) {\n \tvar l int\n-\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCGBLEN, uintptr(unsafe.Pointer(&l)))\n-\tif e := int(ep); e != 0 {\n-\t\treturn 0, e\n+\t_, _, err := Syscall(SYS_IOCTL, uintptr(fd), BIOCGBLEN, uintptr(unsafe.Pointer(&l)))\n+\tif err != 0 {\n+\t\treturn 0, Errno(err)\n \t}\n-\treturn l, 0\n+\treturn l, nil\n }\n \n-func SetBpfBuflen(fd, l int) (int, int) {\n-\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCSBLEN, uintptr(unsafe.Pointer(&l)))\n-\tif e := int(ep); e != 0 {\n-\t\treturn 0, e\n+func SetBpfBuflen(fd, l int) (int, error) {\n+\t_, _, err := Syscall(SYS_IOCTL, uintptr(fd), BIOCSBLEN, uintptr(unsafe.Pointer(&l)))\n+\tif err != 0 {\n+\t\treturn 0, Errno(err)\n \t}\n-\treturn l, 0\n+\treturn l, nil\n }\n \n-func BpfDatalink(fd int) (int, int) {\n+func BpfDatalink(fd int) (int, error) {\n \tvar t int\n-\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCGDLT, uintptr(unsafe.Pointer(&t)))\n-\tif e := int(ep); e != 0 {\n-\t\treturn 0, e\n+\t_, _, err := Syscall(SYS_IOCTL, uintptr(fd), BIOCGDLT, uintptr(unsafe.Pointer(&t)))\n+\tif err != 0 {\n+\t\treturn 0, Errno(err)\n \t}\n-\treturn t, 0\n+\treturn t, nil\n }\n \n-func SetBpfDatalink(fd, t int) (int, int) {\n-\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCSDLT, uintptr(unsafe.Pointer(&t)))\n-\tif e := int(ep); e != 0 {\n-\t\treturn 0, e\n+func SetBpfDatalink(fd, t int) (int, error) {\n+\t_, _, err := Syscall(SYS_IOCTL, uintptr(fd), BIOCSDLT, uintptr(unsafe.Pointer(&t)))\n+\tif err != 0 {\n+\t\treturn 0, Errno(err)\n \t}\n-\treturn t, 0\n+\treturn t, nil\n }\n \n-func SetBpfPromisc(fd, m int) int {\n-\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCPROMISC, uintptr(unsafe.Pointer(&m)))\n-\tif e := int(ep); e != 0 {\n-\t\treturn e\n+func SetBpfPromisc(fd, m int) error {\n+\t_, _, err := Syscall(SYS_IOCTL, uintptr(fd), BIOCPROMISC, uintptr(unsafe.Pointer(&m)))\n+\tif err != 0 {\n+\t\treturn Errno(err)\n \t}\n-\treturn 0\n+\treturn nil\n }\n \n-func FlushBpf(fd int) int {\n-\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCFLUSH, 0)\n-\tif e := int(ep); e != 0 {\n-\t\treturn e\n+func FlushBpf(fd int) error {\n+\t_, _, err := Syscall(SYS_IOCTL, uintptr(fd), BIOCFLUSH, 0)\n+\tif err != 0 {\n+\t\treturn Errno(err)\n \t}\n-\treturn 0\n+\treturn nil\n }\n \n type ivalue struct {\n \tname  [IFNAMSIZ]byte\n \tvalue int16\n }\n \n-func BpfInterface(fd int, name string) (string, int) {\n+func BpfInterface(fd int, name string) (string, error) {\n \tvar iv ivalue\n-\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCGETIF, uintptr(unsafe.Pointer(&iv)))\n-\tif e := int(ep); e != 0 {\n-\t\treturn \"\", e\n+\t_, _, err := Syscall(SYS_IOCTL, uintptr(fd), BIOCGETIF, uintptr(unsafe.Pointer(&iv)))\n+\tif err != 0 {\n+\t\treturn \"\", Errno(err)\n \t}\n-\treturn name, 0\n+\treturn name, nil\n }\n \n-func SetBpfInterface(fd int, name string) int {\n+func SetBpfInterface(fd int, name string) error {\n \tvar iv ivalue\n \tcopy(iv.name[:], []byte(name))\n-\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCSETIF, uintptr(unsafe.Pointer(&iv)))\n-\tif e := int(ep); e != 0 {\n-\t\treturn e\n+\t_, _, err := Syscall(SYS_IOCTL, uintptr(fd), BIOCSETIF, uintptr(unsafe.Pointer(&iv)))\n+\tif err != 0 {\n+\t\treturn Errno(err)\n \t}\n-\treturn 0\n+\treturn nil\n }\n \n-func BpfTimeout(fd int) (*Timeval, int) {\n+func BpfTimeout(fd int) (*Timeval, error) {\n \tvar tv Timeval\n-\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCGRTIMEOUT, uintptr(unsafe.Pointer(&tv)))\n-\tif e := int(ep); e != 0 {\n-\t\treturn nil, e\n+\t_, _, err := Syscall(SYS_IOCTL, uintptr(fd), BIOCGRTIMEOUT, uintptr(unsafe.Pointer(&tv)))\n+\tif err != 0 {\n+\t\treturn nil, Errno(err)\n \t}\n-\treturn &tv, 0\n+\treturn &tv, nil\n }\n \n-func SetBpfTimeout(fd int, tv *Timeval) int {\n-\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCSRTIMEOUT, uintptr(unsafe.Pointer(tv)))\n-\tif e := int(ep); e != 0 {\n-\t\treturn e\n+func SetBpfTimeout(fd int, tv *Timeval) error {\n+\t_, _, err := Syscall(SYS_IOCTL, uintptr(fd), BIOCSRTIMEOUT, uintptr(unsafe.Pointer(tv)))\n+\tif err != 0 {\n+\t\treturn Errno(err)\n \t}\n-\treturn 0\n+\treturn nil\n }\n \n-func BpfStats(fd int) (*BpfStat, int) {\n+func BpfStats(fd int) (*BpfStat, error) {\n \tvar s BpfStat\n-\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCGSTATS, uintptr(unsafe.Pointer(&s)))\n-\tif e := int(ep); e != 0 {\n-\t\treturn nil, e\n+\t_, _, err := Syscall(SYS_IOCTL, uintptr(fd), BIOCGSTATS, uintptr(unsafe.Pointer(&s)))\n+\tif err != 0 {\n+\t\treturn nil, Errno(err)\n \t}\n-\treturn &s, 0\n+\treturn &s, nil\n }\n \n-func SetBpfImmediate(fd, m int) int {\n-\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCIMMEDIATE, uintptr(unsafe.Pointer(&m)))\n-\tif e := int(ep); e != 0 {\n-\t\treturn e\n+func SetBpfImmediate(fd, m int) error {\n+\t_, _, err := Syscall(SYS_IOCTL, uintptr(fd), BIOCIMMEDIATE, uintptr(unsafe.Pointer(&m)))\n+\tif err != 0 {\n+\t\treturn Errno(err)\n \t}\n-\treturn 0\n+\treturn nil\n }\n \n-func SetBpf(fd int, i []BpfInsn) int {\n+func SetBpf(fd int, i []BpfInsn) error {\n \tvar p BpfProgram\n \tp.Len = uint32(len(i))\n \tp.Insns = (*BpfInsn)(unsafe.Pointer(&i[0]))\n-\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCSETF, uintptr(unsafe.Pointer(&p)))\n-\tif e := int(ep); e != 0 {\n-\t\treturn e\n+\t_, _, err := Syscall(SYS_IOCTL, uintptr(fd), BIOCSETF, uintptr(unsafe.Pointer(&p)))\n+\tif err != 0 {\n+\t\treturn Errno(err)\n \t}\n-\treturn 0\n+\treturn nil\n }\n \n-func CheckBpfVersion(fd int) int {\n+func CheckBpfVersion(fd int) error {\n \tvar v BpfVersion\n-\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCVERSION, uintptr(unsafe.Pointer(&v)))\n-\tif e := int(ep); e != 0 {\n-\t\treturn e\n+\t_, _, err := Syscall(SYS_IOCTL, uintptr(fd), BIOCVERSION, uintptr(unsafe.Pointer(&v)))\n+\tif err != 0 {\n+\t\treturn Errno(err)\n \t}\n \tif v.Major != BPF_MAJOR_VERSION || v.Minor != BPF_MINOR_VERSION {\n \t\treturn EINVAL\n \t}\n-\treturn 0\n+\treturn nil\n }\n \n-func BpfHeadercmpl(fd int) (int, int) {\n+func BpfHeadercmpl(fd int) (int, error) {\n \tvar f int\n-\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCGHDRCMPLT, uintptr(unsafe.Pointer(&f)))\n-\tif e := int(ep); e != 0 {\n-\t\treturn 0, e\n+\t_, _, err := Syscall(SYS_IOCTL, uintptr(fd), BIOCGHDRCMPLT, uintptr(unsafe.Pointer(&f)))\n+\tif err != 0 {\n+\t\treturn 0, Errno(err)\n \t}\n-\treturn f, 0\n+\treturn f, nil\n }\n \n-func SetBpfHeadercmpl(fd, f int) int {\n-\t_, _, ep := Syscall(SYS_IOCTL, uintptr(fd), BIOCSHDRCMPLT, uintptr(unsafe.Pointer(&f)))\n-\tif e := int(ep); e != 0 {\n-\t\treturn e\n+func SetBpfHeadercmpl(fd, f int) error {\n+\t_, _, err := Syscall(SYS_IOCTL, uintptr(fd), BIOCSHDRCMPLT, uintptr(unsafe.Pointer(&f)))\n+\tif err != 0 {\n+\t\treturn Errno(err)\n \t}\n-\treturn 0\n+\treturn nil\n }"}, {"sha": "518573318efa59908192d70fae4b9f85972c3be0", "filename": "libgo/go/syscall/env_plan9.go", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fenv_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fenv_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fenv_plan9.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Plan 9 environment variables.\n+\n+package syscall\n+\n+import \"errors\"\n+\n+func Getenv(key string) (value string, found bool) {\n+\tif len(key) == 0 {\n+\t\treturn \"\", false\n+\t}\n+\tf, e := Open(\"/env/\"+key, O_RDONLY)\n+\tif e != nil {\n+\t\treturn \"\", false\n+\t}\n+\tdefer Close(f)\n+\n+\tl, _ := Seek(f, 0, 2)\n+\tSeek(f, 0, 0)\n+\tbuf := make([]byte, l)\n+\tn, e := Read(f, buf)\n+\tif e != nil {\n+\t\treturn \"\", false\n+\t}\n+\n+\tif n > 0 && buf[n-1] == 0 {\n+\t\tbuf = buf[:n-1]\n+\t}\n+\treturn string(buf), true\n+}\n+\n+func Setenv(key, value string) error {\n+\tif len(key) == 0 {\n+\t\treturn errors.New(\"bad arg in system call\")\n+\t}\n+\n+\tf, e := Create(\"/env/\"+key, O_RDWR, 0666)\n+\tif e != nil {\n+\t\treturn e\n+\t}\n+\tdefer Close(f)\n+\n+\t_, e = Write(f, []byte(value))\n+\treturn nil\n+}\n+\n+func Clearenv() {\n+\tRawSyscall(SYS_RFORK, RFCENVG, 0, 0)\n+}\n+\n+func Environ() []string {\n+\tenv := make([]string, 0, 100)\n+\n+\tf, e := Open(\"/env\", O_RDONLY)\n+\tif e != nil {\n+\t\tpanic(e)\n+\t}\n+\tdefer Close(f)\n+\n+\tnames, e := readdirnames(f)\n+\tif e != nil {\n+\t\tpanic(e)\n+\t}\n+\n+\tfor _, k := range names {\n+\t\tif v, ok := Getenv(k); ok {\n+\t\t\tenv = append(env, k+\"=\"+v)\n+\t\t}\n+\t}\n+\treturn env[0:len(env)]\n+}"}, {"sha": "df259097c6aabed3ca32ee7fd7338b0291064a58", "filename": "libgo/go/syscall/env_unix.go", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fenv_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fenv_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fenv_unix.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2010 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin freebsd linux openbsd\n+\n+// Unix environment variables.\n+\n+package syscall\n+\n+import \"sync\"\n+\n+var env map[string]string\n+var envOnce sync.Once\n+var Envs []string // provided by runtime\n+\n+func setenv_c(k, v string)\n+\n+func copyenv() {\n+\tenv = make(map[string]string)\n+\tfor _, s := range Envs {\n+\t\tfor j := 0; j < len(s); j++ {\n+\t\t\tif s[j] == '=' {\n+\t\t\t\tenv[s[0:j]] = s[j+1:]\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+var envLock sync.RWMutex\n+\n+func Getenv(key string) (value string, found bool) {\n+\tenvOnce.Do(copyenv)\n+\tif len(key) == 0 {\n+\t\treturn \"\", false\n+\t}\n+\n+\tenvLock.RLock()\n+\tdefer envLock.RUnlock()\n+\n+\tv, ok := env[key]\n+\tif !ok {\n+\t\treturn \"\", false\n+\t}\n+\treturn v, true\n+}\n+\n+func Setenv(key, value string) error {\n+\tenvOnce.Do(copyenv)\n+\tif len(key) == 0 {\n+\t\treturn EINVAL\n+\t}\n+\n+\tenvLock.Lock()\n+\tdefer envLock.Unlock()\n+\n+\tenv[key] = value\n+\tsetenv_c(key, value) // is a no-op if cgo isn't loaded\n+\treturn nil\n+}\n+\n+func Clearenv() {\n+\tenvOnce.Do(copyenv) // prevent copyenv in Getenv/Setenv\n+\n+\tenvLock.Lock()\n+\tdefer envLock.Unlock()\n+\n+\tenv = make(map[string]string)\n+\n+\t// TODO(bradfitz): pass through to C\n+}\n+\n+func Environ() []string {\n+\tenvOnce.Do(copyenv)\n+\tenvLock.RLock()\n+\tdefer envLock.RUnlock()\n+\ta := make([]string, len(env))\n+\ti := 0\n+\tfor k, v := range env {\n+\t\ta[i] = k + \"=\" + v\n+\t\ti++\n+\t}\n+\treturn a\n+}"}, {"sha": "8308f10a2dc0df56552ca15b9ac52564c03d8141", "filename": "libgo/go/syscall/env_windows.go", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fenv_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fenv_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fenv_windows.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2010 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Windows environment variables.\n+\n+package syscall\n+\n+import (\n+\t\"unicode/utf16\"\n+\t\"unsafe\"\n+)\n+\n+func Getenv(key string) (value string, found bool) {\n+\tb := make([]uint16, 100)\n+\tn, e := GetEnvironmentVariable(StringToUTF16Ptr(key), &b[0], uint32(len(b)))\n+\tif n == 0 && e == ERROR_ENVVAR_NOT_FOUND {\n+\t\treturn \"\", false\n+\t}\n+\tif n > uint32(len(b)) {\n+\t\tb = make([]uint16, n)\n+\t\tn, e = GetEnvironmentVariable(StringToUTF16Ptr(key), &b[0], uint32(len(b)))\n+\t\tif n > uint32(len(b)) {\n+\t\t\tn = 0\n+\t\t}\n+\t}\n+\tif n == 0 {\n+\t\treturn \"\", false\n+\t}\n+\treturn string(utf16.Decode(b[0:n])), true\n+}\n+\n+func Setenv(key, value string) error {\n+\tvar v *uint16\n+\tif len(value) > 0 {\n+\t\tv = StringToUTF16Ptr(value)\n+\t}\n+\te := SetEnvironmentVariable(StringToUTF16Ptr(key), v)\n+\tif e != nil {\n+\t\treturn e\n+\t}\n+\treturn nil\n+}\n+\n+func Clearenv() {\n+\tfor _, s := range Environ() {\n+\t\t// Environment variables can begin with =\n+\t\t// so start looking for the separator = at j=1.\n+\t\t// http://blogs.msdn.com/b/oldnewthing/archive/2010/05/06/10008132.aspx\n+\t\tfor j := 1; j < len(s); j++ {\n+\t\t\tif s[j] == '=' {\n+\t\t\t\tSetenv(s[0:j], \"\")\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func Environ() []string {\n+\ts, e := GetEnvironmentStrings()\n+\tif e != nil {\n+\t\treturn nil\n+\t}\n+\tdefer FreeEnvironmentStrings(s)\n+\tr := make([]string, 0, 50) // Empty with room to grow.\n+\tfor from, i, p := 0, 0, (*[1 << 24]uint16)(unsafe.Pointer(s)); true; i++ {\n+\t\tif p[i] == 0 {\n+\t\t\t// empty string marks the end\n+\t\t\tif i <= from {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tr = append(r, string(utf16.Decode(p[from:i])))\n+\t\t\tfrom = i + 1\n+\t\t}\n+\t}\n+\treturn r\n+}"}, {"sha": "8e57811151a5e3cea00c3e6eb1997ce5d2c6847e", "filename": "libgo/go/syscall/errno.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Ferrno.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Ferrno.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Ferrno.c?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -5,21 +5,22 @@\n    license that can be found in the LICENSE file.  */\n \n #include <errno.h>\n+#include <stdint.h>\n \n /* errno is typically a macro. These functions set \n    and get errno specific to the libc being used.  */\n \n-int GetErrno() asm (\"libgo_syscall.syscall.GetErrno\");\n-void SetErrno(int) asm (\"libgo_syscall.syscall.SetErrno\");\n+uintptr_t GetErrno() asm (\"libgo_syscall.syscall.GetErrno\");\n+void SetErrno(uintptr_t) asm (\"libgo_syscall.syscall.SetErrno\");\n \n-int \n+uintptr_t\n GetErrno()\n {\n-  return errno;\n+  return (uintptr_t) errno;\n }\n \n void\n-SetErrno(int value)\n+SetErrno(uintptr_t value)\n {\n-  errno = value;\n+  errno = (int) value;\n }"}, {"sha": "5ef10da1fd4d47f8f38c0dd18498c65ae5d4d7e7", "filename": "libgo/go/syscall/errstr.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Ferrstr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Ferrstr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Ferrstr.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -6,14 +6,14 @@\n \n package syscall\n \n-//sysnb\tstrerror_r(errnum int, buf []byte) (errno int)\n+//sysnb\tstrerror_r(errnum int, buf []byte) (err error)\n //strerror_r(errnum int, buf *byte, buflen Size_t) int\n \n func Errstr(errnum int) string {\n \tfor len := 128; ; len *= 2 {\n \t\tb := make([]byte, len)\n \t\terr := strerror_r(errnum, b)\n-\t\tif err == 0 {\n+\t\tif err == nil {\n \t\t\ti := 0\n \t\t\tfor b[i] != 0 {\n \t\t\t\ti++"}, {"sha": "74b0af597e8d1c4edc78be923219becc7f317d03", "filename": "libgo/go/syscall/exec_stubs.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fexec_stubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fexec_stubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_stubs.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -14,10 +14,10 @@ func Exec(argv0 string, argv []string, envv []string) (err int) {\n \treturn ENOSYS;\n }\n \n-func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, errno int) {\n+func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, err error) {\n \treturn -1, ENOSYS;\n }\n \n-func raw_ptrace(request int, pid int, addr *byte, data *byte) int {\n+func raw_ptrace(request int, pid int, addr *byte, data *byte) Errno {\n \treturn ENOSYS\n }"}, {"sha": "c9814b7050efcccf6209c729f0c6fbef7192e366", "filename": "libgo/go/syscall/exec_unix.go", "status": "modified", "additions": 71, "deletions": 50, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fexec_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fexec_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_unix.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -11,39 +11,43 @@ import (\n \t\"unsafe\"\n )\n \n-//sysnb\traw_fork() (pid Pid_t, errno int)\n+//sysnb\traw_fork() (pid Pid_t, err Errno)\n //fork() Pid_t\n \n-//sysnb raw_setsid() (errno int)\n+//sysnb raw_setsid() (err Errno)\n //setsid() Pid_t\n \n-//sysnb\traw_chroot(path *byte) (errno int)\n+//sysnb raw_setpgid(pid int, pgid int) (err Errno)\n+//setpgid(pid Pid_t, pgid Pid_t) int\n+\n+//sysnb\traw_chroot(path *byte) (err Errno)\n //chroot(path *byte) int\n \n-//sysnb\traw_chdir(path *byte) (errno int)\n+//sysnb\traw_chdir(path *byte) (err Errno)\n //chdir(path *byte) int\n \n-//sysnb\traw_fcntl(fd int, cmd int, arg int) (val int, errno int)\n+//sysnb\traw_fcntl(fd int, cmd int, arg int) (val int, err Errno)\n //fcntl(fd int, cmd int, arg int) int\n \n-//sysnb\traw_close(fd int) (errno int)\n+//sysnb\traw_close(fd int) (err Errno)\n //close(fd int) int\n \n-//sysnb\traw_ioctl(fd int, cmd int, val int) (rval int, errno int)\n+//sysnb\traw_ioctl(fd int, cmd int, val int) (rval int, err Errno)\n //ioctl(fd int, cmd int, val int) int\n \n-//sysnb\traw_execve(argv0 *byte, argv **byte, envv **byte) (errno int)\n+//sysnb\traw_execve(argv0 *byte, argv **byte, envv **byte) (err Errno)\n //execve(argv0 *byte, argv **byte, envv **byte) int\n \n-//sysnb\traw_read(fd int, p *byte, np int) (n int, errno int)\n-//read(fd int, buf *byte, count Size_t) Ssize_t\n-\n-//sysnb\traw_write(fd int, buf *byte, count int) int\n+//sysnb\traw_write(fd int, buf *byte, count int) (err Errno)\n //write(fd int, buf *byte, count Size_t) Ssize_t\n \n //sysnb\traw_exit(status int)\n //_exit(status int)\n \n+// Note: not raw, returns error rather than Errno.\n+//sys\tread(fd int, p *byte, np int) (n int, err error)\n+//read(fd int, buf *byte, count Size_t) Ssize_t\n+\n // Lock synchronizing creation of new file descriptors with fork.\n //\n // We want the child in a fork/exec sequence to inherit only the\n@@ -106,9 +110,9 @@ func StringSlicePtr(ss []string) []*byte {\n \n func CloseOnExec(fd int) { fcntl(fd, F_SETFD, FD_CLOEXEC) }\n \n-func SetNonblock(fd int, nonblocking bool) (errno int) {\n+func SetNonblock(fd int, nonblocking bool) (err error) {\n \tflag, err := fcntl(fd, F_GETFL, 0)\n-\tif err != 0 {\n+\tif err != nil {\n \t\treturn err\n \t}\n \tif nonblocking {\n@@ -121,20 +125,22 @@ func SetNonblock(fd int, nonblocking bool) (errno int) {\n }\n \n // Fork, dup fd onto 0..len(fd), and exec(argv0, argvv, envv) in child.\n-// If a dup or exec fails, write the errno int to pipe.\n+// If a dup or exec fails, write the errno error to pipe.\n // (Pipe is close-on-exec so if exec succeeds, it will be closed.)\n // In the child, this function must not acquire any locks, because\n // they might have been locked at the time of the fork.  This means\n // no rescheduling, no malloc calls, and no new stack segments.\n // The calls to RawSyscall are okay because they are assembly\n // functions that do not grow the stack.\n-func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr *ProcAttr, sys *SysProcAttr, pipe int) (pid int, err int) {\n+func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr *ProcAttr, sys *SysProcAttr, pipe int) (pid int, err Errno) {\n \t// Declare all variables at top in case any\n \t// declarations require heap allocation (e.g., err1).\n-\tvar r1 Pid_t\n-\tvar err1 int\n-\tvar nextfd int\n-\tvar i int\n+\tvar (\n+\t\tr1 Pid_t\n+\t\terr1 Errno\n+\t\tnextfd int\n+\t\ti int\n+\t)\n \n \t// guard against side effects of shuffling fds below.\n \tfd := append([]int(nil), attr.Files...)\n@@ -143,7 +149,7 @@ func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr\n \t// No more allocation or calls of non-assembly functions.\n \tr1, err1 = raw_fork()\n \tif err1 != 0 {\n-\t\treturn 0, int(err1)\n+\t\treturn 0, err1\n \t}\n \n \tif r1 != 0 {\n@@ -171,7 +177,7 @@ func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr\n \n \t// Set process group\n \tif sys.Setpgid {\n-\t\terr1 = Setpgid(0, 0)\n+\t\terr1 = raw_setpgid(0, 0)\n \t\tif err1 != 0 {\n \t\t\tgoto childerror\n \t\t}\n@@ -189,23 +195,35 @@ func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr\n \tif cred := sys.Credential; cred != nil {\n \t\tngroups := len(cred.Groups)\n \t\tif ngroups == 0 {\n-\t\t\terr1 = setgroups(0, nil)\n+\t\t\terr2 := setgroups(0, nil)\n+\t\t\tif err2 == nil {\n+\t\t\t\terr1 = 0\n+\t\t\t} else {\n+\t\t\t\terr1 = err2.(Errno)\n+\t\t\t}\n \t\t} else {\n \t\t\tgroups := make([]Gid_t, ngroups)\n \t\t\tfor i, v := range cred.Groups {\n \t\t\t\tgroups[i] = Gid_t(v)\n \t\t\t}\n-\t\t\terr1 = setgroups(ngroups, &groups[0])\n+\t\t\terr2 := setgroups(ngroups, &groups[0])\n+\t\t\tif err2 == nil {\n+\t\t\t\terr1 = 0\n+\t\t\t} else {\n+\t\t\t\terr1 = err2.(Errno)\n+\t\t\t}\n \t\t}\n \t\tif err1 != 0 {\n \t\t\tgoto childerror\n \t\t}\n-\t\terr1 = Setgid(int(cred.Gid))\n-\t\tif err1 != 0 {\n+\t\terr2 := Setgid(int(cred.Gid))\n+\t\tif err2 != nil {\n+\t\t\terr1 = err2.(Errno)\n \t\t\tgoto childerror\n \t\t}\n-\t\terr1 = Setuid(int(cred.Uid))\n-\t\tif err1 != 0 {\n+\t\terr2 = Setuid(int(cred.Uid))\n+\t\tif err2 != nil {\n+\t\t\terr1 = err2.(Errno)\n \t\t\tgoto childerror\n \t\t}\n \t}\n@@ -222,8 +240,9 @@ func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr\n \t// so that pass 2 won't stomp on an fd it needs later.\n \tnextfd = int(len(fd))\n \tif pipe < nextfd {\n-\t\t_, err1 = Dup2(pipe, nextfd)\n-\t\tif err1 != 0 {\n+\t\t_, err2 := Dup2(pipe, nextfd)\n+\t\tif err2 != nil {\n+\t\t\terr1 = err2.(Errno)\n \t\t\tgoto childerror\n \t\t}\n \t\traw_fcntl(nextfd, F_SETFD, FD_CLOEXEC)\n@@ -232,8 +251,9 @@ func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr\n \t}\n \tfor i = 0; i < len(fd); i++ {\n \t\tif fd[i] >= 0 && fd[i] < int(i) {\n-\t\t\t_, err1 = Dup2(fd[i], nextfd)\n-\t\t\tif err1 != 0 {\n+\t\t\t_, err2 := Dup2(fd[i], nextfd)\n+\t\t\tif err2 != nil {\n+\t\t\t\terr1 = err2.(Errno)\n \t\t\t\tgoto childerror\n \t\t\t}\n \t\t\traw_fcntl(nextfd, F_SETFD, FD_CLOEXEC)\n@@ -262,8 +282,9 @@ func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr\n \t\t}\n \t\t// The new fd is created NOT close-on-exec,\n \t\t// which is exactly what we want.\n-\t\t_, err1 = Dup2(fd[i], i)\n-\t\tif err1 != 0 {\n+\t\t_, err2 := Dup2(fd[i], i)\n+\t\tif err2 != nil {\n+\t\t\terr1 = err2.(Errno)\n \t\t\tgoto childerror\n \t\t}\n \t}\n@@ -338,10 +359,10 @@ type SysProcAttr struct {\n var zeroProcAttr ProcAttr\n var zeroSysProcAttr SysProcAttr\n \n-func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err int) {\n+func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err error) {\n \tvar p [2]int\n \tvar n int\n-\tvar err1 uintptr\n+\tvar err1 Errno\n \tvar wstatus WaitStatus\n \n \tif attr == nil {\n@@ -379,32 +400,32 @@ func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err int) {\n \tForkLock.Lock()\n \n \t// Allocate child status pipe close on exec.\n-\tif err = Pipe(p[0:]); err != 0 {\n+\tif err = Pipe(p[0:]); err != nil {\n \t\tgoto error\n \t}\n-\tif _, err = fcntl(p[0], F_SETFD, FD_CLOEXEC); err != 0 {\n+\tif _, err = fcntl(p[0], F_SETFD, FD_CLOEXEC); err != nil {\n \t\tgoto error\n \t}\n-\tif _, err = fcntl(p[1], F_SETFD, FD_CLOEXEC); err != 0 {\n+\tif _, err = fcntl(p[1], F_SETFD, FD_CLOEXEC); err != nil {\n \t\tgoto error\n \t}\n \n \t// Kick off child.\n-\tpid, err = forkAndExecInChild(argv0p, argvp, envvp, chroot, dir, attr, sys, p[1])\n-\tif err != 0 {\n+\tpid, err1 = forkAndExecInChild(argv0p, argvp, envvp, chroot, dir, attr, sys, p[1])\n+\tif err1 != 0 {\n \t\tgoto error\n \t}\n \tForkLock.Unlock()\n \n \t// Read child error status from pipe.\n \tClose(p[1])\n-\tn, err = raw_read(p[0], (*byte)(unsafe.Pointer(&err1)), int(unsafe.Sizeof(err1)))\n+\tn, err = read(p[0], (*byte)(unsafe.Pointer(&err1)), int(unsafe.Sizeof(err1)))\n \tClose(p[0])\n-\tif err != 0 || n != 0 {\n+\tif err != nil || n != 0 {\n \t\tif n == int(unsafe.Sizeof(err1)) {\n-\t\t\terr = int(err1)\n+\t\t\terr = Errno(err1)\n \t\t}\n-\t\tif err == 0 {\n+\t\tif err == nil {\n \t\t\terr = EPIPE\n \t\t}\n \n@@ -418,7 +439,7 @@ func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err int) {\n \t}\n \n \t// Read got EOF, so pipe closed on exec, so exec succeeded.\n-\treturn pid, 0\n+\treturn pid, nil\n \n error:\n \tif p[0] >= 0 {\n@@ -430,20 +451,20 @@ error:\n }\n \n // Combination of fork and exec, careful to be thread safe.\n-func ForkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err int) {\n+func ForkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err error) {\n \treturn forkExec(argv0, argv, attr)\n }\n \n // StartProcess wraps ForkExec for package os.\n-func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid, handle int, err int) {\n+func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid, handle int, err error) {\n \tpid, err = forkExec(argv0, argv, attr)\n \treturn pid, 0, err\n }\n \n // Ordinary exec.\n-func Exec(argv0 string, argv []string, envv []string) (err int) {\n+func Exec(argv0 string, argv []string, envv []string) (err error) {\n \terr1 := raw_execve(StringBytePtr(argv0),\n \t\t&StringSlicePtr(argv)[0],\n \t\t&StringSlicePtr(envv)[0])\n-\treturn int(err1)\n+\treturn Errno(err1)\n }"}, {"sha": "2826e2f35a6ccdc0f1c3e7ae0475f8274a476da5", "filename": "libgo/go/syscall/exec_windows.go", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fexec_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fexec_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_windows.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -8,8 +8,8 @@ package syscall\n \n import (\n \t\"sync\"\n+\t\"unicode/utf16\"\n \t\"unsafe\"\n-\t\"utf16\"\n )\n \n var ForkLock sync.RWMutex\n@@ -100,7 +100,7 @@ func makeCmdLine(args []string) string {\n // Last bytes are two UCS-2 NULs, or four NUL bytes.\n func createEnvBlock(envv []string) *uint16 {\n \tif len(envv) == 0 {\n-\t\treturn &utf16.Encode([]int(\"\\x00\\x00\"))[0]\n+\t\treturn &utf16.Encode([]rune(\"\\x00\\x00\"))[0]\n \t}\n \tlength := 0\n \tfor _, s := range envv {\n@@ -118,54 +118,54 @@ func createEnvBlock(envv []string) *uint16 {\n \t}\n \tcopy(b[i:i+1], []byte{0})\n \n-\treturn &utf16.Encode([]int(string(b)))[0]\n+\treturn &utf16.Encode([]rune(string(b)))[0]\n }\n \n func CloseOnExec(fd Handle) {\n \tSetHandleInformation(Handle(fd), HANDLE_FLAG_INHERIT, 0)\n }\n \n-func SetNonblock(fd Handle, nonblocking bool) (errno int) {\n-\treturn 0\n+func SetNonblock(fd Handle, nonblocking bool) (err error) {\n+\treturn nil\n }\n \n // getFullPath retrieves the full path of the specified file.\n // Just a wrapper for Windows GetFullPathName api.\n-func getFullPath(name string) (path string, err int) {\n+func getFullPath(name string) (path string, err error) {\n \tp := StringToUTF16Ptr(name)\n \tbuf := make([]uint16, 100)\n \tn, err := GetFullPathName(p, uint32(len(buf)), &buf[0], nil)\n-\tif err != 0 {\n+\tif err != nil {\n \t\treturn \"\", err\n \t}\n \tif n > uint32(len(buf)) {\n \t\t// Windows is asking for bigger buffer.\n \t\tbuf = make([]uint16, n)\n \t\tn, err = GetFullPathName(p, uint32(len(buf)), &buf[0], nil)\n-\t\tif err != 0 {\n+\t\tif err != nil {\n \t\t\treturn \"\", err\n \t\t}\n \t\tif n > uint32(len(buf)) {\n \t\t\treturn \"\", EINVAL\n \t\t}\n \t}\n-\treturn UTF16ToString(buf[:n]), 0\n+\treturn UTF16ToString(buf[:n]), nil\n }\n \n func isSlash(c uint8) bool {\n \treturn c == '\\\\' || c == '/'\n }\n \n-func normalizeDir(dir string) (name string, err int) {\n+func normalizeDir(dir string) (name string, err error) {\n \tndir, err := getFullPath(dir)\n-\tif err != 0 {\n+\tif err != nil {\n \t\treturn \"\", err\n \t}\n \tif len(ndir) > 2 && isSlash(ndir[0]) && isSlash(ndir[1]) {\n \t\t// dir cannot have \\\\server\\share\\path form\n \t\treturn \"\", EINVAL\n \t}\n-\treturn ndir, 0\n+\treturn ndir, nil\n }\n \n func volToUpper(ch int) int {\n@@ -175,24 +175,24 @@ func volToUpper(ch int) int {\n \treturn ch\n }\n \n-func joinExeDirAndFName(dir, p string) (name string, err int) {\n+func joinExeDirAndFName(dir, p string) (name string, err error) {\n \tif len(p) == 0 {\n \t\treturn \"\", EINVAL\n \t}\n \tif len(p) > 2 && isSlash(p[0]) && isSlash(p[1]) {\n \t\t// \\\\server\\share\\path form\n-\t\treturn p, 0\n+\t\treturn p, nil\n \t}\n \tif len(p) > 1 && p[1] == ':' {\n \t\t// has drive letter\n \t\tif len(p) == 2 {\n \t\t\treturn \"\", EINVAL\n \t\t}\n \t\tif isSlash(p[2]) {\n-\t\t\treturn p, 0\n+\t\t\treturn p, nil\n \t\t} else {\n \t\t\td, err := normalizeDir(dir)\n-\t\t\tif err != 0 {\n+\t\t\tif err != nil {\n \t\t\t\treturn \"\", err\n \t\t\t}\n \t\t\tif volToUpper(int(p[0])) == volToUpper(int(d[0])) {\n@@ -204,7 +204,7 @@ func joinExeDirAndFName(dir, p string) (name string, err int) {\n \t} else {\n \t\t// no drive letter\n \t\td, err := normalizeDir(dir)\n-\t\tif err != 0 {\n+\t\tif err != nil {\n \t\t\treturn \"\", err\n \t\t}\n \t\tif isSlash(p[0]) {\n@@ -232,7 +232,7 @@ type SysProcAttr struct {\n var zeroProcAttr ProcAttr\n var zeroSysProcAttr SysProcAttr\n \n-func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid, handle int, err int) {\n+func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid, handle int, err error) {\n \tif len(argv0) == 0 {\n \t\treturn 0, 0, EWINDOWS\n \t}\n@@ -255,9 +255,9 @@ func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid, handle int,\n \t\t// argv0 relative to the current directory, and, only once the new\n \t\t// process is started, it does Chdir(attr.Dir). We are adjusting\n \t\t// for that difference here by making argv0 absolute.\n-\t\tvar err int\n+\t\tvar err error\n \t\targv0, err = joinExeDirAndFName(attr.Dir, argv0)\n-\t\tif err != 0 {\n+\t\tif err != nil {\n \t\t\treturn 0, 0, err\n \t\t}\n \t}\n@@ -294,7 +294,7 @@ func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid, handle int,\n \tfor i := range attr.Files {\n \t\tif attr.Files[i] > 0 {\n \t\t\terr := DuplicateHandle(p, Handle(attr.Files[i]), p, &fd[i], 0, true, DUPLICATE_SAME_ACCESS)\n-\t\t\tif err != 0 {\n+\t\t\tif err != nil {\n \t\t\t\treturn 0, 0, err\n \t\t\t}\n \t\t\tdefer CloseHandle(Handle(fd[i]))\n@@ -314,14 +314,14 @@ func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid, handle int,\n \tpi := new(ProcessInformation)\n \n \terr = CreateProcess(argv0p, argvp, nil, nil, true, CREATE_UNICODE_ENVIRONMENT, createEnvBlock(attr.Env), dirp, si, pi)\n-\tif err != 0 {\n+\tif err != nil {\n \t\treturn 0, 0, err\n \t}\n \tdefer CloseHandle(Handle(pi.Thread))\n \n-\treturn int(pi.ProcessId), int(pi.Process), 0\n+\treturn int(pi.ProcessId), int(pi.Process), nil\n }\n \n-func Exec(argv0 string, argv []string, envv []string) (err int) {\n+func Exec(argv0 string, argv []string, envv []string) (err error) {\n \treturn EWINDOWS\n }"}, {"sha": "69e0db264bdaad9ed050e17893c8e4593fb54e2c", "filename": "libgo/go/syscall/libcall_irix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_irix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_irix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_irix.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -4,5 +4,5 @@\n \n package syscall\n \n-//sysnb raw_ptrace(request int, pid int, addr *byte, data *byte) (errno int)\n+//sysnb raw_ptrace(request int, pid int, addr *byte, data *byte) (err Errno)\n //ptrace(request int, pid Pid_t, addr *byte, data *byte) _C_long"}, {"sha": "79f5d48ae8b5df08056dcbf5ed4eb8e75d2c56c2", "filename": "libgo/go/syscall/libcall_linux.go", "status": "modified", "additions": 86, "deletions": 86, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_linux.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -8,31 +8,31 @@ package syscall\n \n import \"unsafe\"\n \n-//sys\tOpenat(dirfd int, path string, flags int, mode uint32) (fd int, errno int)\n+//sys\tOpenat(dirfd int, path string, flags int, mode uint32) (fd int, err error)\n //openat(dirfd int, path *byte, flags int, mode Mode_t) int\n \n-//sys\tfutimesat(dirfd int, path *byte, times *[2]Timeval) (errno int)\n+//sys\tfutimesat(dirfd int, path *byte, times *[2]Timeval) (err error)\n //futimesat(dirfd int, path *byte, times *[2]Timeval) int\n-func Futimesat(dirfd int, path string, tv []Timeval) (errno int) {\n+func Futimesat(dirfd int, path string, tv []Timeval) (err error) {\n \tif len(tv) != 2 {\n \t\treturn EINVAL\n \t}\n \treturn futimesat(dirfd, StringBytePtr(path), (*[2]Timeval)(unsafe.Pointer(&tv[0])))\n }\n \n-func Futimes(fd int, tv []Timeval) (errno int) {\n+func Futimes(fd int, tv []Timeval) (err error) {\n \t// Believe it or not, this is the best we can do on GNU/Linux\n \t// (and is what glibc does).\n \treturn Utimes(\"/proc/self/fd/\"+itoa(fd), tv)\n }\n \n-//sys\tptrace(request int, pid int, addr uintptr, data uintptr) (errno int)\n+//sys\tptrace(request int, pid int, addr uintptr, data uintptr) (err error)\n //ptrace(request int, pid Pid_t, addr *byte, data *byte) _C_long\n \n-//sysnb raw_ptrace(request int, pid int, addr *byte, data *byte) (errno int)\n+//sysnb raw_ptrace(request int, pid int, addr *byte, data *byte) (err Errno)\n //ptrace(request int, pid Pid_t, addr *byte, data *byte) _C_long\n \n-func ptracePeek(req int, pid int, addr uintptr, out []byte) (count int, errno int) {\n+func ptracePeek(req int, pid int, addr uintptr, out []byte) (count int, err error) {\n \t// The peek requests are machine-size oriented, so we wrap it\n \t// to retrieve arbitrary-length data.\n \n@@ -48,9 +48,9 @@ func ptracePeek(req int, pid int, addr uintptr, out []byte) (count int, errno in\n \t// boundary.\n \tn := 0\n \tif addr%sizeofPtr != 0 {\n-\t\terrno = ptrace(req, pid, addr-addr%sizeofPtr, uintptr(unsafe.Pointer(&buf[0])))\n-\t\tif errno != 0 {\n-\t\t\treturn 0, errno\n+\t\terr = ptrace(req, pid, addr-addr%sizeofPtr, uintptr(unsafe.Pointer(&buf[0])))\n+\t\tif err != nil {\n+\t\t\treturn 0, err\n \t\t}\n \t\tn += copy(out, buf[addr%sizeofPtr:])\n \t\tout = out[n:]\n@@ -60,53 +60,53 @@ func ptracePeek(req int, pid int, addr uintptr, out []byte) (count int, errno in\n \tfor len(out) > 0 {\n \t\t// We use an internal buffer to gaurantee alignment.\n \t\t// It's not documented if this is necessary, but we're paranoid.\n-\t\terrno = ptrace(req, pid, addr+uintptr(n), uintptr(unsafe.Pointer(&buf[0])))\n-\t\tif errno != 0 {\n-\t\t\treturn n, errno\n+\t\terr = ptrace(req, pid, addr+uintptr(n), uintptr(unsafe.Pointer(&buf[0])))\n+\t\tif err != nil {\n+\t\t\treturn n, err\n \t\t}\n \t\tcopied := copy(out, buf[0:])\n \t\tn += copied\n \t\tout = out[copied:]\n \t}\n \n-\treturn n, 0\n+\treturn n, nil\n }\n \n-func PtracePeekText(pid int, addr uintptr, out []byte) (count int, errno int) {\n+func PtracePeekText(pid int, addr uintptr, out []byte) (count int, err error) {\n \treturn ptracePeek(PTRACE_PEEKTEXT, pid, addr, out)\n }\n \n-func PtracePeekData(pid int, addr uintptr, out []byte) (count int, errno int) {\n+func PtracePeekData(pid int, addr uintptr, out []byte) (count int, err error) {\n \treturn ptracePeek(PTRACE_PEEKDATA, pid, addr, out)\n }\n \n-func ptracePoke(pokeReq int, peekReq int, pid int, addr uintptr, data []byte) (count int, errno int) {\n+func ptracePoke(pokeReq int, peekReq int, pid int, addr uintptr, data []byte) (count int, err error) {\n \t// As for ptracePeek, we need to align our accesses to deal\n \t// with the possibility of straddling an invalid page.\n \n \t// Leading edge.\n \tn := 0\n \tif addr%sizeofPtr != 0 {\n \t\tvar buf [sizeofPtr]byte\n-\t\terrno = ptrace(peekReq, pid, addr-addr%sizeofPtr, uintptr(unsafe.Pointer(&buf[0])))\n-\t\tif errno != 0 {\n-\t\t\treturn 0, errno\n+\t\terr = ptrace(peekReq, pid, addr-addr%sizeofPtr, uintptr(unsafe.Pointer(&buf[0])))\n+\t\tif err != nil {\n+\t\t\treturn 0, err\n \t\t}\n \t\tn += copy(buf[addr%sizeofPtr:], data)\n \t\tword := *((*uintptr)(unsafe.Pointer(&buf[0])))\n-\t\terrno = ptrace(pokeReq, pid, addr-addr%sizeofPtr, word)\n-\t\tif errno != 0 {\n-\t\t\treturn 0, errno\n+\t\terr = ptrace(pokeReq, pid, addr-addr%sizeofPtr, word)\n+\t\tif err != nil {\n+\t\t\treturn 0, err\n \t\t}\n \t\tdata = data[n:]\n \t}\n \n \t// Interior.\n \tfor len(data) > int(sizeofPtr) {\n \t\tword := *((*uintptr)(unsafe.Pointer(&data[0])))\n-\t\terrno = ptrace(pokeReq, pid, addr+uintptr(n), word)\n-\t\tif errno != 0 {\n-\t\t\treturn n, errno\n+\t\terr = ptrace(pokeReq, pid, addr+uintptr(n), word)\n+\t\tif err != nil {\n+\t\t\treturn n, err\n \t\t}\n \t\tn += int(sizeofPtr)\n \t\tdata = data[sizeofPtr:]\n@@ -115,167 +115,167 @@ func ptracePoke(pokeReq int, peekReq int, pid int, addr uintptr, data []byte) (c\n \t// Trailing edge.\n \tif len(data) > 0 {\n \t\tvar buf [sizeofPtr]byte\n-\t\terrno = ptrace(peekReq, pid, addr+uintptr(n), uintptr(unsafe.Pointer(&buf[0])))\n-\t\tif errno != 0 {\n-\t\t\treturn n, errno\n+\t\terr = ptrace(peekReq, pid, addr+uintptr(n), uintptr(unsafe.Pointer(&buf[0])))\n+\t\tif err != nil {\n+\t\t\treturn n, err\n \t\t}\n \t\tcopy(buf[0:], data)\n \t\tword := *((*uintptr)(unsafe.Pointer(&buf[0])))\n-\t\terrno = ptrace(pokeReq, pid, addr+uintptr(n), word)\n-\t\tif errno != 0 {\n-\t\t\treturn n, errno\n+\t\terr = ptrace(pokeReq, pid, addr+uintptr(n), word)\n+\t\tif err != nil {\n+\t\t\treturn n, err\n \t\t}\n \t\tn += len(data)\n \t}\n \n-\treturn n, 0\n+\treturn n, nil\n }\n \n-func PtracePokeText(pid int, addr uintptr, data []byte) (count int, errno int) {\n+func PtracePokeText(pid int, addr uintptr, data []byte) (count int, err error) {\n \treturn ptracePoke(PTRACE_POKETEXT, PTRACE_PEEKTEXT, pid, addr, data)\n }\n \n-func PtracePokeData(pid int, addr uintptr, data []byte) (count int, errno int) {\n+func PtracePokeData(pid int, addr uintptr, data []byte) (count int, err error) {\n \treturn ptracePoke(PTRACE_POKEDATA, PTRACE_PEEKDATA, pid, addr, data)\n }\n \n-func PtraceGetRegs(pid int, regsout *PtraceRegs) (errno int) {\n+func PtraceGetRegs(pid int, regsout *PtraceRegs) (err error) {\n \treturn ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))\n }\n \n-func PtraceSetRegs(pid int, regs *PtraceRegs) (errno int) {\n+func PtraceSetRegs(pid int, regs *PtraceRegs) (err error) {\n \treturn ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))\n }\n \n-func PtraceSetOptions(pid int, options int) (errno int) {\n+func PtraceSetOptions(pid int, options int) (err error) {\n \treturn ptrace(PTRACE_SETOPTIONS, pid, 0, uintptr(options))\n }\n \n-func PtraceGetEventMsg(pid int) (msg uint, errno int) {\n+func PtraceGetEventMsg(pid int) (msg uint, err error) {\n \tvar data _C_long\n-\terrno = ptrace(PTRACE_GETEVENTMSG, pid, 0, uintptr(unsafe.Pointer(&data)))\n+\terr = ptrace(PTRACE_GETEVENTMSG, pid, 0, uintptr(unsafe.Pointer(&data)))\n \tmsg = uint(data)\n \treturn\n }\n \n-func PtraceCont(pid int, signal int) (errno int) {\n+func PtraceCont(pid int, signal int) (err error) {\n \treturn ptrace(PTRACE_CONT, pid, 0, uintptr(signal))\n }\n \n-func PtraceSingleStep(pid int) (errno int) { return ptrace(PTRACE_SINGLESTEP, pid, 0, 0) }\n+func PtraceSingleStep(pid int) (err error) { return ptrace(PTRACE_SINGLESTEP, pid, 0, 0) }\n \n-func PtraceAttach(pid int) (errno int) { return ptrace(PTRACE_ATTACH, pid, 0, 0) }\n+func PtraceAttach(pid int) (err error) { return ptrace(PTRACE_ATTACH, pid, 0, 0) }\n \n-func PtraceDetach(pid int) (errno int) { return ptrace(PTRACE_DETACH, pid, 0, 0) }\n+func PtraceDetach(pid int) (err error) { return ptrace(PTRACE_DETACH, pid, 0, 0) }\n \n // FIXME: mksysinfo needs to produce LINUX_REBOOT_MAGIC[12].\n \n-// //sys\treboot(magic1 uint, magic2 uint, cmd int, arg string) (errno int)\n+// //sys\treboot(magic1 uint, magic2 uint, cmd int, arg string) (err error)\n // //reboot(magic1 uint, magic2 uint, cmd int, arg *byte) int\n-// func Reboot(cmd int) (errno int) {\n+// func Reboot(cmd int) (err error) {\n // \treturn reboot(LINUX_REBOOT_MAGIC1, LINUX_REBOOT_MAGIC2, cmd, \"\")\n // }\n \n-//sys\tAcct(path string) (errno int)\n+//sys\tAcct(path string) (err error)\n //acct(path *byte) int\n \n // FIXME: mksysinfo Timex\n-// //sys\tAdjtimex(buf *Timex) (state int, errno int)\n+// //sys\tAdjtimex(buf *Timex) (state int, err error)\n // //adjtimex(buf *Timex) int\n \n-//sys\tFaccessat(dirfd int, path string, mode uint32, flags int) (errno int)\n+//sys\tFaccessat(dirfd int, path string, mode uint32, flags int) (err error)\n //faccessat(dirfd int, pathname *byte, mode int, flags int) int\n \n // FIXME: Only in glibc 2.10 and later.\n-// //sys\tFallocate(fd int, mode uint32, off int64, len int64) (errno int)\n+// //sys\tFallocate(fd int, mode uint32, off int64, len int64) (err error)\n // //fallocate(fd int, mode int, offset Offset_t, len Offset_t) int\n \n-//sys\tFchmodat(dirfd int, path string, mode uint32, flags int) (errno int)\n+//sys\tFchmodat(dirfd int, path string, mode uint32, flags int) (err error)\n //fchmodat(dirfd int, pathname *byte, mode Mode_t, flags int) int\n \n-//sys\tFchownat(dirfd int, path string, uid int, gid int, flags int) (errno int)\n+//sys\tFchownat(dirfd int, path string, uid int, gid int, flags int) (err error)\n //fchownat(dirfd int, path *byte, owner Uid_t, group Gid_t, flags int) int\n \n-//sys\tFlock(fd int, how int) (errno int)\n+//sys\tFlock(fd int, how int) (err error)\n //flock(fd int, how int) int\n \n // FIXME: mksysinfo statfs\n-// //sys\tFstatfs(fd int, buf *Statfs_t) (errno int)\n+// //sys\tFstatfs(fd int, buf *Statfs_t) (err error)\n // //fstatfs(fd int, buf *Statfs_t) int\n \n // FIXME: Only available as a syscall.\n // //sysnb\tGettid() (tid int)\n // //gettid() Pid_t\n \n-//sys\tIoperm(from int, num int, on int) (errno int)\n+//sys\tIoperm(from int, num int, on int) (err error)\n //ioperm(from _C_long, num _C_long, on int) int\n \n-//sys\tIopl(level int) (errno int)\n+//sys\tIopl(level int) (err error)\n //iopl(level int) int\n \n // FIXME: mksysinfo linux_dirent\n //    Or just abandon this function.\n-// //sys\tGetdents(fd int, buf []byte) (n int, errno int)\n+// //sys\tGetdents(fd int, buf []byte) (n int, err error)\n // //getdents64(fd int, buf *byte, count uint)\n \n-//sys\tInotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, errno int)\n+//sys\tInotifyAddWatch(fd int, pathname string, mask uint32) (watchdesc int, err error)\n //inotify_add_watch(fd int, pathname *byte, mask uint32) int\n \n-//sysnb\tInotifyInit() (fd int, errno int)\n+//sysnb\tInotifyInit() (fd int, err error)\n //inotify_init() int\n \n // FIXME: Only in glibc 2.9 and later.\n-// //sysnb\tInotifyInit1(flags int) (fd int, errno int)\n+// //sysnb\tInotifyInit1(flags int) (fd int, err error)\n // //inotify_init1(flags int) int\n \n-//sysnb\tInotifyRmWatch(fd int, watchdesc uint32) (success int, errno int)\n+//sysnb\tInotifyRmWatch(fd int, watchdesc uint32) (success int, err error)\n //inotify_rm_watch(fd int, wd uint32) int\n \n-//sys\tKlogctl(typ int, buf []byte) (n int, errno int)\n+//sys\tKlogctl(typ int, buf []byte) (n int, err error)\n //klogctl(typ int, bufp *byte, len int) int\n \n-//sys\tMkdirat(dirfd int, path string, mode uint32) (errno int)\n+//sys\tMkdirat(dirfd int, path string, mode uint32) (err error)\n //mkdirat(dirfd int, path *byte, mode Mode_t) int\n \n-//sys\tMknodat(dirfd int, path string, mode uint32, dev int) (errno int)\n+//sys\tMknodat(dirfd int, path string, mode uint32, dev int) (err error)\n //mknodat(dirfd int, path *byte, mode Mode_t, dev _dev_t) int\n \n-//sys\tPivotRoot(newroot string, putold string) (errno int)\n+//sys\tPivotRoot(newroot string, putold string) (err error)\n //pivot_root(newroot *byte, putold *byte) int\n \n-//sys\tRenameat(olddirfd int, oldpath string, newdirfd int, newpath string) (errno int)\n+//sys\tRenameat(olddirfd int, oldpath string, newdirfd int, newpath string) (err error)\n //renameat(olddirfd int, oldpath *byte, newdirfd int, newpath *byte) int\n \n-//sys\tsendfile(outfd int, infd int, offset *Offset_t, count int) (written int, errno int)\n+//sys\tsendfile(outfd int, infd int, offset *Offset_t, count int) (written int, err error)\n //sendfile64(outfd int, infd int, offset *Offset_t, count Size_t) Ssize_t\n-func Sendfile(outfd int, infd int, offset *int64, count int) (written int, errno int) {\n+func Sendfile(outfd int, infd int, offset *int64, count int) (written int, err error) {\n \tvar soff Offset_t\n \tvar psoff *Offset_t\n \tif offset != nil {\n \t\tpsoff = &soff\n \t}\n-\twritten, errno = sendfile(outfd, infd, psoff, count)\n+\twritten, err = sendfile(outfd, infd, psoff, count)\n \tif offset != nil {\n \t\t*offset = int64(soff)\n \t}\n \treturn\n }\n \n-//sys\tSetfsgid(gid int) (errno int)\n+//sys\tSetfsgid(gid int) (err error)\n //setfsgid(gid Gid_t) int\n \n-//sys\tSetfsuid(uid int) (errno int)\n+//sys\tSetfsuid(uid int) (err error)\n //setfsuid(uid Uid_t) int\n \n-//sysnb\tSetresgid(rgid int, egid int, sgid int) (errno int)\n+//sysnb\tSetresgid(rgid int, egid int, sgid int) (err error)\n //setresgid(rgid Gid_t, egid Gid_t, sgid Gid_t) int\n \n-//sysnb\tSetresuid(ruid int, eguid int, suid int) (errno int)\n+//sysnb\tSetresuid(ruid int, eguid int, suid int) (err error)\n //setresuid(ruid Uid_t, euid Uid_t, suid Uid_t) int\n \n-//sys\tsplice(rfd int, roff *_loff_t, wfd int, woff *_loff_t, len int, flags int) (n int64, errno int)\n+//sys\tsplice(rfd int, roff *_loff_t, wfd int, woff *_loff_t, len int, flags int) (n int64, err error)\n //splice(rfd int, roff *_loff_t, wfd int, woff *_loff_t, len Size_t, flags uint) Ssize_t\n-func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, errno int) {\n+func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n int64, err error) {\n \tvar lroff _loff_t\n \tvar plroff *_loff_t\n \tif (roff != nil) {\n@@ -286,7 +286,7 @@ func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n i\n \tif (woff != nil) {\n \t\tplwoff = &lwoff\n \t}\n-\tn, errno = splice(rfd, plroff, wfd, plwoff, len, flags)\n+\tn, err = splice(rfd, plroff, wfd, plwoff, len, flags)\n \tif (roff != nil) {\n \t\t*roff = int64(lroff)\n \t}\n@@ -297,37 +297,37 @@ func Splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) (n i\n }\n \n // FIXME: mksysinfo statfs\n-// //sys\tStatfs(path string, buf *Statfs_t) (errno int)\n+// //sys\tStatfs(path string, buf *Statfs_t) (err error)\n // //statfs(path *byte, buf *Statfs_t) int\n \n // FIXME: Only in glibc 2.6 and later.\n-// //sys\tSyncFileRange(fd int, off int64, n int64, flags int) (errno int)\n+// //sys\tSyncFileRange(fd int, off int64, n int64, flags int) (err error)\n // //sync_file_range(fd int, off Offset_t, n Offset_t, flags uint) int\n \n // FIXME: mksysinfo Sysinfo_t\n-// //sysnb\tSysinfo(info *Sysinfo_t) (errno int)\n+// //sysnb\tSysinfo(info *Sysinfo_t) (err error)\n // //sysinfo(info *Sysinfo_t) int\n \n-//sys\tTee(rfd int, wfd int, len int, flags int) (n int64, errno int)\n+//sys\tTee(rfd int, wfd int, len int, flags int) (n int64, err error)\n //tee(rfd int, wfd int, len Size_t, flags uint) Ssize_t\n \n // FIXME: Only available as a syscall.\n-// //sysnb\tTgkill(tgid int, tid int, sig int) (errno int)\n+// //sysnb\tTgkill(tgid int, tid int, sig int) (err error)\n // //tgkill(tgid int, tid int, sig int) int\n \n-//sys\tunlinkat(dirfd int, path string, flags int) (errno int)\n+//sys\tunlinkat(dirfd int, path string, flags int) (err error)\n //unlinkat(dirfd int, path *byte, flags int) int\n \n-func Unlinkat(dirfd int, path string) (errno int) {\n+func Unlinkat(dirfd int, path string) (err error) {\n \treturn unlinkat(dirfd, path, 0)\n }\n \n-//sys\tUnmount(target string, flags int) (errno int) = SYS_UMOUNT2\n+//sys\tUnmount(target string, flags int) (err error) = SYS_UMOUNT2\n //umount2(target *byte, flags int) int\n \n-//sys\tUnshare(flags int) (errno int)\n+//sys\tUnshare(flags int) (err error)\n //unshare(flags int) int\n \n // FIXME: mksysinfo Ustat_t\n-// //sys\tUstat(dev int, ubuf *Ustat_t) (errno int)\n+// //sys\tUstat(dev int, ubuf *Ustat_t) (err error)\n // //ustat(dev _dev_t, ubuf *Ustat_t) int"}, {"sha": "d90e595dba36bf966434912a6c14fa97fbd27d38", "filename": "libgo/go/syscall/libcall_posix.go", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_posix.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -17,60 +17,60 @@ import \"unsafe\"\n  * Wrapped\n  */\n \n-//sysnb\tpipe(p *[2]int) (errno int)\n+//sysnb\tpipe(p *[2]int) (err error)\n //pipe(p *[2]int) int\n-func Pipe(p []int) (errno int) {\n+func Pipe(p []int) (err error) {\n \tif len(p) != 2 {\n \t\treturn EINVAL\n \t}\n \tvar pp [2]int\n-\terrno = pipe(&pp)\n+\terr = pipe(&pp)\n \tp[0] = pp[0]\n \tp[1] = pp[1]\n \treturn\n }\n \n-//sys\tutimes(path string, times *[2]Timeval) (errno int)\n+//sys\tutimes(path string, times *[2]Timeval) (err error)\n //utimes(path *byte, times *[2]Timeval) int\n-func Utimes(path string, tv []Timeval) (errno int) {\n+func Utimes(path string, tv []Timeval) (err error) {\n \tif len(tv) != 2 {\n \t\treturn EINVAL\n \t}\n \treturn utimes(path, (*[2]Timeval)(unsafe.Pointer(&tv[0])))\n }\n \n-//sys\tgetcwd(buf *byte, size Size_t) (errno int)\n+//sys\tgetcwd(buf *byte, size Size_t) (err error)\n //getcwd(buf *byte, size Size_t) *byte\n \n const ImplementsGetwd = true\n \n-func Getwd() (ret string, errno int) {\n+func Getwd() (ret string, err error) {\n \tfor len := Size_t(4096); ; len *= 2 {\n \t\tb := make([]byte, len)\n \t\terr := getcwd(&b[0], len)\n-\t\tif err == 0 {\n-\t\t\ti := 0;\n+\t\tif err == nil {\n+\t\t\ti := 0\n \t\t\tfor b[i] != 0 {\n-\t\t\t\ti++;\n+\t\t\t\ti++\n \t\t\t}\n-\t\t\treturn string(b[0:i]), 0;\n+\t\t\treturn string(b[0:i]), nil\n \t\t}\n \t\tif err != ERANGE {\n \t\t\treturn \"\", err\n \t\t}\n \t}\n }\n \n-//sysnb\tgetgroups(size int, list *Gid_t) (nn int, errno int)\n+//sysnb\tgetgroups(size int, list *Gid_t) (nn int, err error)\n //getgroups(size int, list *Gid_t) int\n \n-func Getgroups() (gids []int, errno int) {\n+func Getgroups() (gids []int, err error) {\n \tn, err := getgroups(0, nil)\n-\tif err != 0 {\n-\t\treturn nil, errno\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n \tif n == 0 {\n-\t\treturn nil, 0\n+\t\treturn nil, nil\n \t}\n \n \t// Sanity check group count.  Max is 1<<16 on GNU/Linux.\n@@ -80,8 +80,8 @@ func Getgroups() (gids []int, errno int) {\n \n \ta := make([]Gid_t, n)\n \tn, err = getgroups(n, &a[0])\n-\tif err != 0 {\n-\t\treturn nil, errno\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n \tgids = make([]int, n)\n \tfor i, v := range a[0:n] {\n@@ -90,10 +90,10 @@ func Getgroups() (gids []int, errno int) {\n \treturn\n }\n \n-//sysnb\tsetgroups(n int, list *Gid_t) (errno int)\n+//sysnb\tsetgroups(n int, list *Gid_t) (err error)\n //setgroups(n Size_t, list *Gid_t) int\n \n-func Setgroups(gids []int) (errno int) {\n+func Setgroups(gids []int) (err error) {\n \tif len(gids) == 0 {\n \t\treturn setgroups(0, nil)\n \t}\n@@ -120,10 +120,10 @@ func (w WaitStatus) Signal() int\n func (w WaitStatus) StopSignal() int\n func (w WaitStatus) TrapCause() int\n \n-//sys\tMkfifo(path string, mode uint32) (errno int)\n+//sys\tMkfifo(path string, mode uint32) (err error)\n //mkfifo(path *byte, mode Mode_t) int\n \n-//sys\tSelect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, errno int)\n+//sys\tSelect(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) (n int, err error)\n //select(nfd int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval) int\n \n const nfdbits = unsafe.Sizeof(fds_bits_type) * 8\n@@ -154,52 +154,52 @@ func FDZero(set *FdSet) {\n \t}\n }\n \n-//sys\tAccess(path string, mode uint32) (errno int)\n+//sys\tAccess(path string, mode uint32) (err error)\n //access(path *byte, mode int) int\n \n-//sys\tChdir(path string) (errno int)\n+//sys\tChdir(path string) (err error)\n //chdir(path *byte) int\n \n-//sys\tChmod(path string, mode uint32) (errno int)\n+//sys\tChmod(path string, mode uint32) (err error)\n //chmod(path *byte, mode Mode_t) int\n \n-//sys\tChown(path string, uid int, gid int) (errno int)\n+//sys\tChown(path string, uid int, gid int) (err error)\n //chown(path *byte, uid Uid_t, gid Gid_t) int\n \n-//sys\tChroot(path string) (errno int)\n+//sys\tChroot(path string) (err error)\n //chroot(path *byte) int\n \n-//sys\tClose(fd int) (errno int)\n+//sys\tClose(fd int) (err error)\n //close(fd int) int\n \n-//sys\tCreat(path string, mode uint32) (fd int, errno int)\n+//sys\tCreat(path string, mode uint32) (fd int, err error)\n //creat(path *byte, mode Mode_t) int\n \n-//sysnb\tDup(oldfd int) (fd int, errno int)\n+//sysnb\tDup(oldfd int) (fd int, err error)\n //dup(oldfd int) int\n \n-//sysnb\tDup2(oldfd int, newfd int) (fd int, errno int)\n+//sysnb\tDup2(oldfd int, newfd int) (fd int, err error)\n //dup2(oldfd int, newfd int) int\n \n //sys\tExit(code int)\n //exit(code int)\n \n-//sys\tFchdir(fd int) (errno int)\n+//sys\tFchdir(fd int) (err error)\n //fchdir(fd int) int\n \n-//sys\tFchmod(fd int, mode uint32) (errno int)\n+//sys\tFchmod(fd int, mode uint32) (err error)\n //fchmod(fd int, mode Mode_t) int\n \n-//sys\tFchown(fd int, uid int, gid int) (errno int)\n+//sys\tFchown(fd int, uid int, gid int) (err error)\n //fchown(fd int, uid Uid_t, gid Gid_t) int\n \n-//sys\tfcntl(fd int, cmd int, arg int) (val int, errno int)\n+//sys\tfcntl(fd int, cmd int, arg int) (val int, err error)\n //fcntl(fd int, cmd int, arg int) int\n \n-//sys\tFdatasync(fd int) (errno int)\n+//sys\tFdatasync(fd int) (err error)\n //fdatasync(fd int) int\n \n-//sys\tFsync(fd int) (errno int)\n+//sys\tFsync(fd int) (err error)\n //fsync(fd int) int\n \n //sysnb Getegid() (egid int)\n@@ -214,7 +214,7 @@ func FDZero(set *FdSet) {\n //sysnb\tGetpagesize() (pagesize int)\n //getpagesize() int\n \n-//sysnb\tGetpgid(pid int) (pgid int, errno int)\n+//sysnb\tGetpgid(pid int) (pgid int, err error)\n //getpgid(pid Pid_t) Pid_t\n \n //sysnb\tGetpgrp() (pid int)\n@@ -227,138 +227,138 @@ func FDZero(set *FdSet) {\n //getppid() Pid_t\n \n // FIXME: mksysinfo Rlimit\n-// //sysnb\tGetrlimit(resource int, rlim *Rlimit) (errno int)\n+// //sysnb\tGetrlimit(resource int, rlim *Rlimit) (err error)\n // //getrlimit(resource int, rlim *Rlimit) int\n \n-//sysnb\tGetrusage(who int, rusage *Rusage) (errno int)\n+//sysnb\tGetrusage(who int, rusage *Rusage) (err error)\n //getrusage(who int, rusage *Rusage) int\n \n-//sysnb\tgettimeofday(tv *Timeval, tz *byte) (errno int)\n+//sysnb\tgettimeofday(tv *Timeval, tz *byte) (err error)\n //gettimeofday(tv *Timeval, tz *byte) int\n-func Gettimeofday(tv *Timeval) (errno int) {\n+func Gettimeofday(tv *Timeval) (err error) {\n \treturn gettimeofday(tv, nil)\n }\n \n //sysnb Getuid() (uid int)\n //getuid() Uid_t\n \n-//sysnb\tKill(pid int, sig int) (errno int)\n+//sysnb\tKill(pid int, sig int) (err error)\n //kill(pid Pid_t, sig int) int\n \n-//sys\tLchown(path string, uid int, gid int) (errno int)\n+//sys\tLchown(path string, uid int, gid int) (err error)\n //lchown(path *byte, uid Uid_t, gid Gid_t) int\n \n-//sys\tLink(oldpath string, newpath string) (errno int)\n+//sys\tLink(oldpath string, newpath string) (err error)\n //link(oldpath *byte, newpath *byte) int\n \n-//sys\tMkdir(path string, mode uint32) (errno int)\n+//sys\tMkdir(path string, mode uint32) (err error)\n //mkdir(path *byte, mode Mode_t) int\n \n-//sys\tMknod(path string, mode uint32, dev int) (errno int)\n+//sys\tMknod(path string, mode uint32, dev int) (err error)\n //mknod(path *byte, mode Mode_t, dev _dev_t) int\n \n-//sys\tMount(source string, target string, fstype string, flags int, data string) (errno int)\n+//sys\tMount(source string, target string, fstype string, flags int, data string) (err error)\n //mount(source *byte, target *byte, fstype *byte, flags _C_long, data *byte) int\n \n-//sys\tNanosleep(time *Timespec, leftover *Timespec) (errno int)\n+//sys\tNanosleep(time *Timespec, leftover *Timespec) (err error)\n //nanosleep(time *Timespec, leftover *Timespec) int\n \n-//sys\tPause() (errno int)\n+//sys\tPause() (err error)\n //pause() int\n \n-//sys\tRead(fd int, p []byte) (n int, errno int)\n+//sys\tRead(fd int, p []byte) (n int, err error)\n //read(fd int, buf *byte, count Size_t) Ssize_t\n \n-//sys\tReadlink(path string, buf []byte) (n int, errno int)\n+//sys\tReadlink(path string, buf []byte) (n int, err error)\n //readlink(path *byte, buf *byte, bufsiz Size_t) Ssize_t\n \n-//sys\tRename(oldpath string, newpath string) (errno int)\n+//sys\tRename(oldpath string, newpath string) (err error)\n //rename(oldpath *byte, newpath *byte) int\n \n-//sys\tRmdir(path string) (errno int)\n+//sys\tRmdir(path string) (err error)\n //rmdir(path *byte) int\n \n-//sys\tSetdomainname(p []byte) (errno int)\n+//sys\tSetdomainname(p []byte) (err error)\n //setdomainname(name *byte, len Size_t) int\n \n-//sys\tSethostname(p []byte) (errno int)\n+//sys\tSethostname(p []byte) (err error)\n //sethostname(name *byte, len Size_t) int\n \n-//sysnb\tSetgid(gid int) (errno int)\n+//sysnb\tSetgid(gid int) (err error)\n //setgid(gid Gid_t) int\n \n-//sysnb Setregid(rgid int, egid int) (errno int)\n+//sysnb Setregid(rgid int, egid int) (err error)\n //setregid(rgid Gid_t, egid Gid_t) int\n \n-//sysnb\tSetpgid(pid int, pgid int) (errno int)\n+//sysnb\tSetpgid(pid int, pgid int) (err error)\n //setpgid(pid Pid_t, pgid Pid_t) int\n \n-//sysnb\tSetreuid(ruid int, euid int) (errno int)\n+//sysnb\tSetreuid(ruid int, euid int) (err error)\n //setreuid(ruid Uid_t, euid Uid_t) int\n \n // FIXME: mksysinfo Rlimit\n-// //sysnb\tSetrlimit(resource int, rlim *Rlimit) (errno int)\n+// //sysnb\tSetrlimit(resource int, rlim *Rlimit) (err error)\n // //setrlimit(resource int, rlim *Rlimit) int\n \n-//sysnb\tSetsid() (pid int, errno int)\n+//sysnb\tSetsid() (pid int, err error)\n //setsid() Pid_t\n \n-//sysnb\tsettimeofday(tv *Timeval, tz *byte) (errno int)\n+//sysnb\tsettimeofday(tv *Timeval, tz *byte) (err error)\n //settimeofday(tv *Timeval, tz *byte) int\n \n-func Settimeofday(tv *Timeval) (errno int) {\n+func Settimeofday(tv *Timeval) (err error) {\n \treturn settimeofday(tv, nil)\n }\n \n-//sysnb\tSetuid(uid int) (errno int)\n+//sysnb\tSetuid(uid int) (err error)\n //setuid(uid Uid_t) int\n \n-//sys\tSymlink(oldpath string, newpath string) (errno int)\n+//sys\tSymlink(oldpath string, newpath string) (err error)\n //symlink(oldpath *byte, newpath *byte) int\n \n //sys\tSync()\n //sync()\n \n // FIXME: mksysinfo Time_t\n-// //sysnb\tTime(t *Time_t) (tt Time_t, errno int)\n+// //sysnb\tTime(t *Time_t) (tt Time_t, err error)\n // //time(t *Time_t) Time_t\n \n // FIXME: mksysinfo Tms\n-// //sysnb\tTimes(tms *Tms) (ticks uintptr, errno int)\n+// //sysnb\tTimes(tms *Tms) (ticks uintptr, err error)\n // //times(tms *Tms) _clock_t\n \n //sysnb\tUmask(mask int) (oldmask int)\n //umask(mask Mode_t) Mode_t\n \n-//sys\tUnlink(path string) (errno int)\n+//sys\tUnlink(path string) (err error)\n //unlink(path *byte) int\n \n // FIXME: mksysinfo Utimbuf\n-// //sys\tUtime(path string, buf *Utimbuf) (errno int)\n+// //sys\tUtime(path string, buf *Utimbuf) (err error)\n // //utime(path *byte, buf *Utimbuf) int\n \n-//sys\tWrite(fd int, p []byte) (n int, errno int)\n+//sys\tWrite(fd int, p []byte) (n int, err error)\n //write(fd int, buf *byte, count Size_t) Ssize_t\n \n-//sys\tmunmap(addr uintptr, length uintptr) (errno int)\n+//sys\tmunmap(addr uintptr, length uintptr) (err error)\n //munmap(addr *byte, length Size_t) int\n \n-//sys Madvise(b []byte, advice int) (errno int)\n+//sys Madvise(b []byte, advice int) (err error)\n //madvise(addr *byte, len Size_t, advice int) int\n \n-//sys\tMprotect(b []byte, prot int) (errno int)\n+//sys\tMprotect(b []byte, prot int) (err error)\n //mprotect(addr *byte, len Size_t, prot int) int\n \n-//sys\tMlock(b []byte) (errno int)\n+//sys\tMlock(b []byte) (err error)\n //mlock(addr *byte, len Size_t) int\n \n-//sys\tMunlock(b []byte) (errno int)\n+//sys\tMunlock(b []byte) (err error)\n //munlock(addr *byte, len Size_t) int\n \n-//sys\tMlockall(flags int) (errno int)\n+//sys\tMlockall(flags int) (err error)\n //mlockall(flags int) int\n \n-//sys\tMunlockall() (errno int)\n+//sys\tMunlockall() (err error)\n //munlockall() int\n \n func TimespecToNsec(ts Timespec) int64 { return int64(ts.Sec)*1e9 + int64(ts.Nsec) }\n@@ -378,8 +378,8 @@ func NsecToTimeval(nsec int64) (tv Timeval) {\n \treturn\n }\n \n-//sysnb\tTcgetattr(fd int, p *Termios) (errno int)\n+//sysnb\tTcgetattr(fd int, p *Termios) (err error)\n //tcgetattr(fd int, p *Termios) int\n \n-//sys\tTcsetattr(fd int, actions int, p *Termios) (errno int)\n+//sys\tTcsetattr(fd int, actions int, p *Termios) (err error)\n //tcsetattr(fd int, actions int, p *Termios) int"}, {"sha": "e898648157dfbcf3f6436b1fbbf406b704141de8", "filename": "libgo/go/syscall/libcall_posix_largefile.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_posix_largefile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_posix_largefile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_posix_largefile.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -6,32 +6,32 @@\n \n package syscall\n \n-//sys\tFstat(fd int, stat *Stat_t) (errno int)\n+//sys\tFstat(fd int, stat *Stat_t) (err error)\n //fstat64(fd int, stat *Stat_t) int\n \n-//sys\tFtruncate(fd int, length int64) (errno int)\n+//sys\tFtruncate(fd int, length int64) (err error)\n //ftruncate64(fd int, length Offset_t) int\n \n-//sys\tLstat(path string, stat *Stat_t) (errno int)\n+//sys\tLstat(path string, stat *Stat_t) (err error)\n //lstat64(path *byte, stat *Stat_t) int\n \n-//sys\tmmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, errno int)\n+//sys\tmmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error)\n //mmap64(addr *byte, length Size_t, prot int, flags int, fd int, offset Offset_t) *byte\n \n-//sys\tOpen(path string, mode int, perm uint32) (fd int, errno int)\n+//sys\tOpen(path string, mode int, perm uint32) (fd int, err error)\n //open64(path *byte, mode int, perm Mode_t) int\n \n-//sys\tPread(fd int, p []byte, offset int64) (n int, errno int)\n+//sys\tPread(fd int, p []byte, offset int64) (n int, err error)\n //pread64(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t\n \n-//sys\tPwrite(fd int, p []byte, offset int64) (n int, errno int)\n+//sys\tPwrite(fd int, p []byte, offset int64) (n int, err error)\n //pwrite64(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t\n \n-//sys\tSeek(fd int, offset int64, whence int) (off int64, errno int)\n+//sys\tSeek(fd int, offset int64, whence int) (off int64, err error)\n //lseek64(fd int, offset Offset_t, whence int) Offset_t\n \n-//sys\tStat(path string, stat *Stat_t) (errno int)\n+//sys\tStat(path string, stat *Stat_t) (err error)\n //stat64(path *byte, stat *Stat_t) int\n \n-//sys\tTruncate(path string, length int64) (errno int)\n+//sys\tTruncate(path string, length int64) (err error)\n //truncate64(path *byte, length Offset_t) int"}, {"sha": "97167013a182d0cdb4ed4158b8ff4714cf5fb3db", "filename": "libgo/go/syscall/libcall_posix_regfile.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_posix_regfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_posix_regfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_posix_regfile.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -7,32 +7,32 @@\n \n package syscall\n \n-//sys\tFstat(fd int, stat *Stat_t) (errno int)\n+//sys\tFstat(fd int, stat *Stat_t) (err error)\n //fstat(fd int, stat *Stat_t) int\n \n-//sys\tFtruncate(fd int, length int64) (errno int)\n+//sys\tFtruncate(fd int, length int64) (err error)\n //ftruncate(fd int, length Offset_t) int\n \n-//sys\tLstat(path string, stat *Stat_t) (errno int)\n+//sys\tLstat(path string, stat *Stat_t) (err error)\n //lstat(path *byte, stat *Stat_t) int\n \n-//sys\tmmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, errno int)\n+//sys\tmmap(addr uintptr, length uintptr, prot int, flags int, fd int, offset int64) (xaddr uintptr, err error)\n //mmap(addr *byte, length Size_t, prot int, flags int, fd int, offset Offset_t) *byte\n \n-//sys\tOpen(path string, mode int, perm uint32) (fd int, errno int)\n+//sys\tOpen(path string, mode int, perm uint32) (fd int, err error)\n //open(path *byte, mode int, perm Mode_t) int\n \n-//sys\tPread(fd int, p []byte, offset int64) (n int, errno int)\n+//sys\tPread(fd int, p []byte, offset int64) (n int, err error)\n //pread(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t\n \n-//sys\tPwrite(fd int, p []byte, offset int64) (n int, errno int)\n+//sys\tPwrite(fd int, p []byte, offset int64) (n int, err error)\n //pwrite(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t\n \n-//sys\tSeek(fd int, offset int64, whence int) (off int64, errno int)\n+//sys\tSeek(fd int, offset int64, whence int) (off int64, err error)\n //lseek(fd int, offset Offset_t, whence int) Offset_t\n \n-//sys\tStat(path string, stat *Stat_t) (errno int)\n+//sys\tStat(path string, stat *Stat_t) (err error)\n //stat(path *byte, stat *Stat_t) int\n \n-//sys\tTruncate(path string, length int64) (errno int)\n+//sys\tTruncate(path string, length int64) (err error)\n //truncate(path *byte, length Offset_t) int"}, {"sha": "e94deecf8cddbc1fee5257444625e2d190e21bca", "filename": "libgo/go/syscall/libcall_solaris_386.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_solaris_386.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_solaris_386.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_solaris_386.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -5,8 +5,8 @@\n package syscall\n \n // 32-bit Solaris 2/x86 needs to use _nuname internally, cf. <sys/utsname.h>.\n-//sysnb\tUname(buf *Utsname) (errno int)\n+//sysnb\tUname(buf *Utsname) (err error)\n //_nuname(buf *Utsname) int\n \n-//sysnb raw_ptrace(request int, pid int, addr *byte, data *byte) (errno int)\n+//sysnb raw_ptrace(request int, pid int, addr *byte, data *byte) (err Errno)\n //ptrace(request int, pid Pid_t, addr *byte, data *byte) _C_long"}, {"sha": "69b11ba5ee64810c5785a64d20d40b8a37d571d3", "filename": "libgo/go/syscall/libcall_solaris_amd64.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_solaris_amd64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_solaris_amd64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_solaris_amd64.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -5,6 +5,6 @@\n package syscall\n \n // 64-bit ptrace(3C) doesn't exist\n-func raw_ptrace(request int, pid int, addr *byte, data *byte) int {\n+func raw_ptrace(request int, pid int, addr *byte, data *byte) Errno {\n \treturn ENOSYS\n }"}, {"sha": "69e0db264bdaad9ed050e17893c8e4593fb54e2c", "filename": "libgo/go/syscall/libcall_solaris_sparc.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_solaris_sparc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_solaris_sparc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_solaris_sparc.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -4,5 +4,5 @@\n \n package syscall\n \n-//sysnb raw_ptrace(request int, pid int, addr *byte, data *byte) (errno int)\n+//sysnb raw_ptrace(request int, pid int, addr *byte, data *byte) (err Errno)\n //ptrace(request int, pid Pid_t, addr *byte, data *byte) _C_long"}, {"sha": "69b11ba5ee64810c5785a64d20d40b8a37d571d3", "filename": "libgo/go/syscall/libcall_solaris_sparc64.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_solaris_sparc64.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_solaris_sparc64.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_solaris_sparc64.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -5,6 +5,6 @@\n package syscall\n \n // 64-bit ptrace(3C) doesn't exist\n-func raw_ptrace(request int, pid int, addr *byte, data *byte) int {\n+func raw_ptrace(request int, pid int, addr *byte, data *byte) Errno {\n \treturn ENOSYS\n }"}, {"sha": "7449a0adf79d545ed5bdd7cfa2268596cd3a6389", "filename": "libgo/go/syscall/libcall_support.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_support.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_support.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_support.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -8,5 +8,5 @@ package syscall\n \n func entersyscall()\n func exitsyscall()\n-func GetErrno() int\n-func SetErrno(int)\n+func GetErrno() Errno\n+func SetErrno(Errno)"}, {"sha": "519e6dc25d07c7f8bbe46239b4f866f88997ed5f", "filename": "libgo/go/syscall/libcall_uname.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_uname.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_uname.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_uname.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -4,5 +4,5 @@\n \n package syscall\n \n-//sysnb\tUname(buf *Utsname) (errno int)\n+//sysnb\tUname(buf *Utsname) (err error)\n //uname(buf *Utsname) int"}, {"sha": "578686926f34373df8925025f1bcfa94c0d00734", "filename": "libgo/go/syscall/libcall_wait4.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_wait4.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_wait4.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_wait4.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -6,14 +6,13 @@\n \n package syscall\n \n-//sys\twait4(pid Pid_t, status *int, options int, rusage *Rusage) (wpid Pid_t, errno int)\n+//sys\twait4(pid Pid_t, status *int, options int, rusage *Rusage) (wpid Pid_t, err error)\n //wait4(pid Pid_t, status *int, options int, rusage *Rusage) Pid_t\n \n-func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, errno int) {\n+func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, err error) {\n \tvar status int\n \tr, err := wait4(Pid_t(pid), &status, options, rusage)\n \twpid = int(r)\n-\terrno = err\n \tif wstatus != nil {\n \t\t*wstatus = WaitStatus(status)\n \t}"}, {"sha": "1c476d829d0489c9950e8e0246efdfe8afa21510", "filename": "libgo/go/syscall/libcall_waitpid.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_waitpid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flibcall_waitpid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_waitpid.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -6,14 +6,13 @@\n \n package syscall\n \n-//sys\twaitpid(pid Pid_t, status *int, options int) (wpid Pid_t, errno int)\n+//sys\twaitpid(pid Pid_t, status *int, options int) (wpid Pid_t, err error)\n //waitpid(pid Pid_t, status *int, options int) Pid_t\n \n-func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, errno int) {\n+func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, err error) {\n \tvar status int\n \tr, err := waitpid(Pid_t(pid), &status, options)\n \twpid = int(r)\n-\terrno = err\n \tif wstatus != nil {\n \t\t*wstatus = WaitStatus(status)\n \t}"}, {"sha": "05d653b4aa0cf56c2a3d84a56076488a7af280b5", "filename": "libgo/go/syscall/lsf_linux.go", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flsf_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Flsf_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flsf_linux.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// GNU/Linux socket filter\n+// Linux socket filter\n \n package syscall\n \n@@ -18,61 +18,61 @@ func LsfJump(code, k, jt, jf int) *SockFilter {\n \treturn &SockFilter{Code: uint16(code), Jt: uint8(jt), Jf: uint8(jf), K: uint32(k)}\n }\n \n-func LsfSocket(ifindex, proto int) (int, int) {\n+func LsfSocket(ifindex, proto int) (int, error) {\n \tvar lsall SockaddrLinklayer\n \ts, e := Socket(AF_PACKET, SOCK_RAW, proto)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn 0, e\n \t}\n \tp := (*[2]byte)(unsafe.Pointer(&lsall.Protocol))\n \tp[0] = byte(proto >> 8)\n \tp[1] = byte(proto)\n \tlsall.Ifindex = ifindex\n \te = Bind(s, &lsall)\n-\tif e != 0 {\n+\tif e != nil {\n \t\tClose(s)\n \t\treturn 0, e\n \t}\n-\treturn s, 0\n+\treturn s, nil\n }\n \n type iflags struct {\n \tname  [IFNAMSIZ]byte\n \tflags uint16\n }\n \n-func SetLsfPromisc(name string, m bool) int {\n+func SetLsfPromisc(name string, m bool) error {\n \ts, e := Socket(AF_INET, SOCK_DGRAM, 0)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn e\n \t}\n \tdefer Close(s)\n \tvar ifl iflags\n \tcopy(ifl.name[:], []byte(name))\n \t_, _, ep := Syscall(SYS_IOCTL, uintptr(s), SIOCGIFFLAGS, uintptr(unsafe.Pointer(&ifl)))\n-\tif e := int(ep); e != 0 {\n-\t\treturn e\n+\tif ep != 0 {\n+\t\treturn Errno(ep)\n \t}\n \tif m {\n \t\tifl.flags |= uint16(IFF_PROMISC)\n \t} else {\n \t\tifl.flags &= ^uint16(IFF_PROMISC)\n \t}\n \t_, _, ep = Syscall(SYS_IOCTL, uintptr(s), SIOCSIFFLAGS, uintptr(unsafe.Pointer(&ifl)))\n-\tif e := int(ep); e != 0 {\n-\t\treturn e\n+\tif ep != 0 {\n+\t\treturn Errno(ep)\n \t}\n-\treturn 0\n+\treturn nil\n }\n \n-func AttachLsf(fd int, i []SockFilter) int {\n+func AttachLsf(fd int, i []SockFilter) error {\n \tvar p SockFprog\n \tp.Len = uint16(len(i))\n \tp.Filter = (*SockFilter)(unsafe.Pointer(&i[0]))\n \treturn setsockopt(fd, SOL_SOCKET, SO_ATTACH_FILTER, uintptr(unsafe.Pointer(&p)), unsafe.Sizeof(p))\n }\n \n-func DetachLsf(fd int) int {\n+func DetachLsf(fd int) error {\n \tvar dummy int\n \treturn setsockopt(fd, SOL_SOCKET, SO_DETACH_FILTER, uintptr(unsafe.Pointer(&dummy)), unsafe.Sizeof(dummy))\n }"}, {"sha": "b02989cc323e7391777725d84cd56e174b8f2ebe", "filename": "libgo/go/syscall/mksyscall.awk", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fmksyscall.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fmksyscall.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fmksyscall.awk?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -12,7 +12,7 @@\n #\t  This includes return parameters.\n #\t* The parameter lists must give a type for each argument:\n #\t   the (x, y, z int) shorthand is not allowed.\n-#\t* If the return parameter is an error number, it must be named errno.\n+#\t* If the return parameter is an error, it must be named err.\n \n # A line beginning with //sysnb is like //sys, except that the\n # goroutine will not be suspended during the execution of the library\n@@ -217,13 +217,13 @@ BEGIN {\n \t    goname = goparam[1]\n \t    gotype = goparam[2]\n \n-\t    if (goname == \"errno\") {\n+\t    if (goname == \"err\") {\n \t\tif (cfnresult ~ /^\\*/) {\n \t\t    print \"\\tif _r == nil {\"\n \t\t} else {\n \t\t    print \"\\tif _r < 0 {\"\n \t\t}\n-\t\tprint \"\\t\\terrno = GetErrno()\"\n+\t\tprint \"\\t\\terr = GetErrno()\"\n \t\tprint \"\\t}\"\n \t    } else if (gotype == \"uintptr\" && cfnresult ~ /^\\*/) {\n \t\tprintf(\"\\t%s = (%s)(unsafe.Pointer(_r))\\n\", goname, gotype)"}, {"sha": "8683bb3dacb4dfa159f7e2fc23c27ff3c4da8f8b", "filename": "libgo/go/syscall/netlink_linux.go", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fnetlink_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fnetlink_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fnetlink_linux.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -63,31 +63,28 @@ func newNetlinkRouteRequest(proto, seq, family int) []byte {\n // NetlinkRIB returns routing information base, as known as RIB,\n // which consists of network facility information, states and\n // parameters.\n-func NetlinkRIB(proto, family int) ([]byte, int) {\n+func NetlinkRIB(proto, family int) ([]byte, error) {\n \tvar (\n-\t\ts     int\n-\t\te     int\n \t\tlsanl SockaddrNetlink\n-\t\tseq   int\n \t\ttab   []byte\n \t)\n \n-\ts, e = Socket(AF_NETLINK, SOCK_RAW, 0)\n-\tif e != 0 {\n+\ts, e := Socket(AF_NETLINK, SOCK_RAW, 0)\n+\tif e != nil {\n \t\treturn nil, e\n \t}\n \tdefer Close(s)\n \n \tlsanl.Family = AF_NETLINK\n \te = Bind(s, &lsanl)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, e\n \t}\n \n-\tseq++\n+\tseq := 1\n \twb := newNetlinkRouteRequest(proto, seq, family)\n \te = Sendto(s, wb, 0, &lsanl)\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil, e\n \t}\n \n@@ -100,7 +97,7 @@ func NetlinkRIB(proto, family int) ([]byte, int) {\n \n \t\trb = make([]byte, Getpagesize())\n \t\tnr, _, e = Recvfrom(s, rb, 0)\n-\t\tif e != 0 {\n+\t\tif e != nil {\n \t\t\treturn nil, e\n \t\t}\n \t\tif nr < NLMSG_HDRLEN {\n@@ -111,7 +108,7 @@ func NetlinkRIB(proto, family int) ([]byte, int) {\n \n \t\tmsgs, _ := ParseNetlinkMessage(rb)\n \t\tfor _, m := range msgs {\n-\t\t\tif lsa, e = Getsockname(s); e != 0 {\n+\t\t\tif lsa, e = Getsockname(s); e != nil {\n \t\t\t\treturn nil, e\n \t\t\t}\n \t\t\tswitch v := lsa.(type) {\n@@ -132,7 +129,7 @@ func NetlinkRIB(proto, family int) ([]byte, int) {\n \t}\n \n done:\n-\treturn tab, 0\n+\treturn tab, nil\n }\n \n // NetlinkMessage represents the netlink message.\n@@ -143,18 +140,18 @@ type NetlinkMessage struct {\n \n // ParseNetlinkMessage parses buf as netlink messages and returns\n // the slice containing the NetlinkMessage structs.\n-func ParseNetlinkMessage(buf []byte) ([]NetlinkMessage, int) {\n+func ParseNetlinkMessage(buf []byte) ([]NetlinkMessage, error) {\n \tvar (\n \t\th    *NlMsghdr\n \t\tdbuf []byte\n \t\tdlen int\n-\t\te    int\n+\t\te    error\n \t\tmsgs []NetlinkMessage\n \t)\n \n \tfor len(buf) >= NLMSG_HDRLEN {\n \t\th, dbuf, dlen, e = netlinkMessageHeaderAndData(buf)\n-\t\tif e != 0 {\n+\t\tif e != nil {\n \t\t\tbreak\n \t\t}\n \t\tm := NetlinkMessage{}\n@@ -167,12 +164,12 @@ func ParseNetlinkMessage(buf []byte) ([]NetlinkMessage, int) {\n \treturn msgs, e\n }\n \n-func netlinkMessageHeaderAndData(buf []byte) (*NlMsghdr, []byte, int, int) {\n+func netlinkMessageHeaderAndData(buf []byte) (*NlMsghdr, []byte, int, error) {\n \th := (*NlMsghdr)(unsafe.Pointer(&buf[0]))\n \tif int(h.Len) < NLMSG_HDRLEN || int(h.Len) > len(buf) {\n \t\treturn nil, nil, 0, EINVAL\n \t}\n-\treturn h, buf[NLMSG_HDRLEN:], nlmAlignOf(int(h.Len)), 0\n+\treturn h, buf[NLMSG_HDRLEN:], nlmAlignOf(int(h.Len)), nil\n }\n \n // NetlinkRouteAttr represents the netlink route attribute.\n@@ -184,13 +181,13 @@ type NetlinkRouteAttr struct {\n // ParseNetlinkRouteAttr parses msg's payload as netlink route\n // attributes and returns the slice containing the NetlinkRouteAttr\n // structs.\n-func ParseNetlinkRouteAttr(msg *NetlinkMessage) ([]NetlinkRouteAttr, int) {\n+func ParseNetlinkRouteAttr(msg *NetlinkMessage) ([]NetlinkRouteAttr, error) {\n \tvar (\n \t\tbuf   []byte\n \t\ta     *RtAttr\n \t\talen  int\n \t\tvbuf  []byte\n-\t\te     int\n+\t\te     error\n \t\tattrs []NetlinkRouteAttr\n \t)\n \n@@ -207,7 +204,7 @@ func ParseNetlinkRouteAttr(msg *NetlinkMessage) ([]NetlinkRouteAttr, int) {\n \n \tfor len(buf) >= SizeofRtAttr {\n \t\ta, vbuf, alen, e = netlinkRouteAttrAndValue(buf)\n-\t\tif e != 0 {\n+\t\tif e != nil {\n \t\t\tbreak\n \t\t}\n \t\tra := NetlinkRouteAttr{}\n@@ -217,13 +214,13 @@ func ParseNetlinkRouteAttr(msg *NetlinkMessage) ([]NetlinkRouteAttr, int) {\n \t\tbuf = buf[alen:]\n \t}\n \n-\treturn attrs, 0\n+\treturn attrs, nil\n }\n \n-func netlinkRouteAttrAndValue(buf []byte) (*RtAttr, []byte, int, int) {\n+func netlinkRouteAttrAndValue(buf []byte) (*RtAttr, []byte, int, error) {\n \th := (*RtAttr)(unsafe.Pointer(&buf[0]))\n \tif int(h.Len) < SizeofRtAttr || int(h.Len) > len(buf) {\n \t\treturn nil, nil, 0, EINVAL\n \t}\n-\treturn h, buf[SizeofRtAttr:], rtaAlignOf(int(h.Len)), 0\n+\treturn h, buf[SizeofRtAttr:], rtaAlignOf(int(h.Len)), nil\n }"}, {"sha": "bc4c15e950bfa8c48bb9065d86393f4525df0c97", "filename": "libgo/go/syscall/route_bsd.go", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Froute_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Froute_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Froute_bsd.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -29,29 +29,24 @@ func rsaAlignOf(salen int) int {\n // RouteRIB returns routing information base, as known as RIB,\n // which consists of network facility information, states and\n // parameters.\n-func RouteRIB(facility, param int) ([]byte, int) {\n-\tvar (\n-\t\ttab []byte\n-\t\te   int\n-\t)\n-\n+func RouteRIB(facility, param int) ([]byte, error) {\n \tmib := []_C_int{CTL_NET, AF_ROUTE, 0, 0, _C_int(facility), _C_int(param)}\n \n \t// Find size.\n \tn := uintptr(0)\n-\tif e = sysctl(mib, nil, &n, nil, 0); e != 0 {\n-\t\treturn nil, e\n+\tif err := sysctl(mib, nil, &n, nil, 0); err != nil {\n+\t\treturn nil, err\n \t}\n \tif n == 0 {\n-\t\treturn nil, 0\n+\t\treturn nil, nil\n \t}\n \n-\ttab = make([]byte, n)\n-\tif e = sysctl(mib, &tab[0], &n, nil, 0); e != 0 {\n-\t\treturn nil, e\n+\ttab := make([]byte, n)\n+\tif err := sysctl(mib, &tab[0], &n, nil, 0); err != nil {\n+\t\treturn nil, err\n \t}\n \n-\treturn tab[:n], 0\n+\treturn tab[:n], nil\n }\n \n // RoutingMessage represents a routing message.\n@@ -91,7 +86,7 @@ func (m *RouteMessage) sockaddr() []Sockaddr {\n \t\tswitch i {\n \t\tcase RTAX_DST, RTAX_GATEWAY:\n \t\t\tsa, e := anyToSockaddr((*RawSockaddrAny)(unsafe.Pointer(rsa)))\n-\t\t\tif e != 0 {\n+\t\t\tif e != nil {\n \t\t\t\treturn nil\n \t\t\t}\n \t\t\tif i == RTAX_DST {\n@@ -134,7 +129,7 @@ func (m *InterfaceMessage) sockaddr() (sas []Sockaddr) {\n \t\treturn nil\n \t}\n \tsa, e := anyToSockaddr((*RawSockaddrAny)(unsafe.Pointer(&m.Data[0])))\n-\tif e != 0 {\n+\tif e != nil {\n \t\treturn nil\n \t}\n \treturn append(sas, sa)\n@@ -163,7 +158,7 @@ func (m *InterfaceAddrMessage) sockaddr() (sas []Sockaddr) {\n \t\tswitch i {\n \t\tcase RTAX_IFA:\n \t\t\tsa, e := anyToSockaddr((*RawSockaddrAny)(unsafe.Pointer(rsa)))\n-\t\t\tif e != 0 {\n+\t\t\tif e != nil {\n \t\t\t\treturn nil\n \t\t\t}\n \t\t\tsas = append(sas, sa)\n@@ -178,7 +173,7 @@ func (m *InterfaceAddrMessage) sockaddr() (sas []Sockaddr) {\n \n // ParseRoutingMessage parses buf as routing messages and returns\n // the slice containing the RoutingMessage interfaces.\n-func ParseRoutingMessage(buf []byte) (msgs []RoutingMessage, errno int) {\n+func ParseRoutingMessage(buf []byte) (msgs []RoutingMessage, err error) {\n \tfor len(buf) >= anyMessageLen {\n \t\tany := (*anyMessage)(unsafe.Pointer(&buf[0]))\n \t\tif any.Version != RTM_VERSION {\n@@ -187,11 +182,11 @@ func ParseRoutingMessage(buf []byte) (msgs []RoutingMessage, errno int) {\n \t\tmsgs = append(msgs, any.toRoutingMessage(buf))\n \t\tbuf = buf[any.Msglen:]\n \t}\n-\treturn msgs, 0\n+\treturn msgs, nil\n }\n \n // ParseRoutingMessage parses msg's payload as raw sockaddrs and\n // returns the slice containing the Sockaddr interfaces.\n-func ParseRoutingSockaddr(msg RoutingMessage) (sas []Sockaddr, errno int) {\n-\treturn append(sas, msg.sockaddr()...), 0\n+func ParseRoutingSockaddr(msg RoutingMessage) (sas []Sockaddr, err error) {\n+\treturn append(sas, msg.sockaddr()...), nil\n }"}, {"sha": "410e70a138a9ffaed192a94f2ea53da2f1af6c5a", "filename": "libgo/go/syscall/route_darwin.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Froute_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Froute_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Froute_darwin.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -63,7 +63,7 @@ func (m *InterfaceMulticastAddrMessage) sockaddr() (sas []Sockaddr) {\n \t\tswitch i {\n \t\tcase RTAX_IFA:\n \t\t\tsa, e := anyToSockaddr((*RawSockaddrAny)(unsafe.Pointer(rsa)))\n-\t\t\tif e != 0 {\n+\t\t\tif e != nil {\n \t\t\t\treturn nil\n \t\t\t}\n \t\t\tsas = append(sas, sa)"}, {"sha": "094e17044dbb1fe8069a3de917b797f354389711", "filename": "libgo/go/syscall/route_freebsd.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Froute_freebsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Froute_freebsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Froute_freebsd.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -63,7 +63,7 @@ func (m *InterfaceMulticastAddrMessage) sockaddr() (sas []Sockaddr) {\n \t\tswitch i {\n \t\tcase RTAX_IFA:\n \t\t\tsa, e := anyToSockaddr((*RawSockaddrAny)(unsafe.Pointer(rsa)))\n-\t\t\tif e != 0 {\n+\t\t\tif e != nil {\n \t\t\t\treturn nil\n \t\t\t}\n \t\t\tsas = append(sas, sa)"}, {"sha": "9d72203e8eff82b14c455a89c8c9930850488a03", "filename": "libgo/go/syscall/sleep_rtems.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsleep_rtems.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsleep_rtems.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsleep_rtems.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -6,8 +6,8 @@\n \n package syscall\n \n-func Sleep(nsec int64) (errno int) {\n+func Sleep(nsec int64) (err error) {\n \tts := NsecToTimespec(nsec)\n-\terrno = Nanosleep(&ts, nil)\n+\terr = Nanosleep(&ts, nil)\n \treturn\n }"}, {"sha": "533f554da05387885f969e276b568902e1408a1d", "filename": "libgo/go/syscall/sleep_select.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsleep_select.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsleep_select.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsleep_select.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -6,8 +6,8 @@\n \n package syscall\n \n-func Sleep(nsec int64) (errno int) {\n+func Sleep(nsec int64) (err error) {\n \ttv := NsecToTimeval(nsec);\n-\t_, err := Select(0, nil, nil, nil, &tv);\n+\t_, err = Select(0, nil, nil, nil, &tv);\n \treturn err;\n }"}, {"sha": "0b4caa1d0557fbfa643bac5154b6a71624039460", "filename": "libgo/go/syscall/sockcmsg_linux.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsockcmsg_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsockcmsg_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsockcmsg_linux.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -26,13 +26,13 @@ func UnixCredentials(ucred *Ucred) []byte {\n // ParseUnixCredentials decodes a socket control message that contains\n // credentials in a Ucred structure. To receive such a message, the\n // SO_PASSCRED option must be enabled on the socket.\n-func ParseUnixCredentials(msg *SocketControlMessage) (*Ucred, int) {\n+func ParseUnixCredentials(msg *SocketControlMessage) (*Ucred, error) {\n \tif msg.Header.Level != SOL_SOCKET {\n \t\treturn nil, EINVAL\n \t}\n \tif msg.Header.Type != SCM_CREDENTIALS {\n \t\treturn nil, EINVAL\n \t}\n \tucred := *(*Ucred)(unsafe.Pointer(&msg.Data[0]))\n-\treturn &ucred, 0\n+\treturn &ucred, nil\n }"}, {"sha": "84c1383d7e28e1e65bc11ee876d7df6932adedf7", "filename": "libgo/go/syscall/sockcmsg_unix.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsockcmsg_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsockcmsg_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsockcmsg_unix.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -47,17 +47,17 @@ type SocketControlMessage struct {\n \tData   []byte\n }\n \n-func ParseSocketControlMessage(buf []byte) ([]SocketControlMessage, int) {\n+func ParseSocketControlMessage(buf []byte) ([]SocketControlMessage, error) {\n \tvar (\n \t\th     *Cmsghdr\n \t\tdbuf  []byte\n-\t\te     int\n+\t\te     error\n \t\tcmsgs []SocketControlMessage\n \t)\n \n \tfor len(buf) >= CmsgLen(0) {\n \t\th, dbuf, e = socketControlMessageHeaderAndData(buf)\n-\t\tif e != 0 {\n+\t\tif e != nil {\n \t\t\tbreak\n \t\t}\n \t\tm := SocketControlMessage{}\n@@ -70,12 +70,12 @@ func ParseSocketControlMessage(buf []byte) ([]SocketControlMessage, int) {\n \treturn cmsgs, e\n }\n \n-func socketControlMessageHeaderAndData(buf []byte) (*Cmsghdr, []byte, int) {\n+func socketControlMessageHeaderAndData(buf []byte) (*Cmsghdr, []byte, error) {\n \th := (*Cmsghdr)(unsafe.Pointer(&buf[0]))\n \tif h.Len < SizeofCmsghdr || int(h.Len) > len(buf) {\n \t\treturn nil, nil, EINVAL\n \t}\n-\treturn h, buf[cmsgAlignOf(SizeofCmsghdr):], 0\n+\treturn h, buf[cmsgAlignOf(SizeofCmsghdr):], nil\n }\n \n // UnixRights encodes a set of open file descriptors into a socket\n@@ -99,7 +99,7 @@ func UnixRights(fds ...int) []byte {\n \n // ParseUnixRights decodes a socket control message that contains an\n // integer array of open file descriptors from another process.\n-func ParseUnixRights(msg *SocketControlMessage) ([]int, int) {\n+func ParseUnixRights(msg *SocketControlMessage) ([]int, error) {\n \tif msg.Header.Level != SOL_SOCKET {\n \t\treturn nil, EINVAL\n \t}\n@@ -111,5 +111,5 @@ func ParseUnixRights(msg *SocketControlMessage) ([]int, int) {\n \t\tfds[j] = int(*(*int32)(unsafe.Pointer(&msg.Data[i])))\n \t\tj++\n \t}\n-\treturn fds, 0\n+\treturn fds, nil\n }"}, {"sha": "005fd843486d15e351ab6bddc39d8c3293ae8e72", "filename": "libgo/go/syscall/socket.go", "status": "modified", "additions": 91, "deletions": 91, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsocket.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsocket.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsocket.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -17,7 +17,7 @@ import \"unsafe\"\n var SocketDisableIPv6 bool\n \n type Sockaddr interface {\n-\tsockaddr() (ptr *RawSockaddrAny, len Socklen_t, errno int)\t// lowercase; only we can define Sockaddrs\n+\tsockaddr() (ptr *RawSockaddrAny, len Socklen_t, err error)\t// lowercase; only we can define Sockaddrs\n }\n \n type RawSockaddrAny struct {\n@@ -33,7 +33,7 @@ type SockaddrInet4 struct {\n \traw RawSockaddrInet4\n }\n \n-func (sa *SockaddrInet4) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n+func (sa *SockaddrInet4) sockaddr() (*RawSockaddrAny, Socklen_t, error) {\n \tif sa.Port < 0 || sa.Port > 0xFFFF {\n \t\treturn nil, 0, EINVAL\n \t}\n@@ -45,7 +45,7 @@ func (sa *SockaddrInet4) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n \tfor i := 0; i < len(sa.Addr); i++ {\n \t\tsa.raw.Addr[i] = sa.Addr[i]\n \t}\n-\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), n, 0\n+\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), n, nil\n }\n \n type SockaddrInet6 struct {\n@@ -55,7 +55,7 @@ type SockaddrInet6 struct {\n \traw RawSockaddrInet6\n }\n \n-func (sa *SockaddrInet6) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n+func (sa *SockaddrInet6) sockaddr() (*RawSockaddrAny, Socklen_t, error) {\n \tif sa.Port < 0 || sa.Port > 0xFFFF {\n \t\treturn nil, 0, EINVAL\n \t}\n@@ -68,15 +68,15 @@ func (sa *SockaddrInet6) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n \tfor i := 0; i < len(sa.Addr); i++ {\n \t\tsa.raw.Addr[i] = sa.Addr[i]\n \t}\n-\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), n, 0\n+\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), n, nil\n }\n \n type SockaddrUnix struct {\n \tName string\n \traw RawSockaddrUnix\n }\n \n-func (sa *SockaddrUnix) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n+func (sa *SockaddrUnix) sockaddr() (*RawSockaddrAny, Socklen_t, error) {\n \tname := sa.Name\n \tn := len(name)\n \tif n >= len(sa.raw.Path) || n == 0 {\n@@ -92,186 +92,186 @@ func (sa *SockaddrUnix) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n \t}\n \n \t// length is family (uint16), name, NUL.\n-\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), 2 + Socklen_t(n) + 1, 0\n+\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), 2 + Socklen_t(n) + 1, nil\n }\n \n-func anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, int) {\n+func anyToSockaddr(rsa *RawSockaddrAny) (Sockaddr, error) {\n \tswitch rsa.Addr.Family {\n \tcase AF_UNIX:\n \t\tpp := (*RawSockaddrUnix)(unsafe.Pointer(rsa))\n \t\tsa := new(SockaddrUnix)\n \t\tn, err := pp.getLen()\n-\t\tif err != 0 {\n+\t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tbytes := (*[len(pp.Path)]byte)(unsafe.Pointer(&pp.Path[0]));\n-\t\tsa.Name = string(bytes[0:n]);\n-\t\treturn sa, 0;\n+\t\tbytes := (*[len(pp.Path)]byte)(unsafe.Pointer(&pp.Path[0]))\n+\t\tsa.Name = string(bytes[0:n])\n+\t\treturn sa, nil\n \n \tcase AF_INET:\n-\t\tpp := (*RawSockaddrInet4)(unsafe.Pointer(rsa));\n-\t\tsa := new(SockaddrInet4);\n-\t\tp := (*[2]byte)(unsafe.Pointer(&pp.Port));\n-\t\tsa.Port = int(p[0])<<8 + int(p[1]);\n+\t\tpp := (*RawSockaddrInet4)(unsafe.Pointer(rsa))\n+\t\tsa := new(SockaddrInet4)\n+\t\tp := (*[2]byte)(unsafe.Pointer(&pp.Port))\n+\t\tsa.Port = int(p[0])<<8 + int(p[1])\n \t\tfor i := 0; i < len(sa.Addr); i++ {\n-\t\t\tsa.Addr[i] = pp.Addr[i];\n+\t\t\tsa.Addr[i] = pp.Addr[i]\n \t\t}\n-\t\treturn sa, 0;\n+\t\treturn sa, nil\n \n \tcase AF_INET6:\n-\t\tpp := (*RawSockaddrInet6)(unsafe.Pointer(rsa));\n-\t\tsa := new(SockaddrInet6);\n-\t\tp := (*[2]byte)(unsafe.Pointer(&pp.Port));\n-\t\tsa.Port = int(p[0])<<8 + int(p[1]);\n+\t\tpp := (*RawSockaddrInet6)(unsafe.Pointer(rsa))\n+\t\tsa := new(SockaddrInet6)\n+\t\tp := (*[2]byte)(unsafe.Pointer(&pp.Port))\n+\t\tsa.Port = int(p[0])<<8 + int(p[1])\n \t\tfor i := 0; i < len(sa.Addr); i++ {\n-\t\t\tsa.Addr[i] = pp.Addr[i];\n+\t\t\tsa.Addr[i] = pp.Addr[i]\n \t\t}\n-\t\treturn sa, 0;\n+\t\treturn sa, nil\n \t}\n \treturn anyToSockaddrOS(rsa)\n }\n \n-//sys\taccept(fd int, sa *RawSockaddrAny, len *Socklen_t) (nfd int, errno int)\n+//sys\taccept(fd int, sa *RawSockaddrAny, len *Socklen_t) (nfd int, err error)\n //accept(fd int, sa *RawSockaddrAny, len *Socklen_t) int\n \n-func Accept(fd int) (nfd int, sa Sockaddr, errno int) {\n+func Accept(fd int) (nfd int, sa Sockaddr, err error) {\n \tvar rsa RawSockaddrAny\n \tvar len Socklen_t = SizeofSockaddrAny\n-\tnfd, errno = accept(fd, &rsa, &len)\n-\tif errno != 0 {\n+\tnfd, err = accept(fd, &rsa, &len)\n+\tif err != nil {\n \t\treturn\n \t}\n-\tsa, errno = anyToSockaddr(&rsa)\n-\tif errno != 0 {\n+\tsa, err = anyToSockaddr(&rsa)\n+\tif err != nil {\n \t\tClose(nfd)\n \t\tnfd = 0\n \t}\n \treturn\n }\n \n-//sysnb\tgetsockname(fd int, sa *RawSockaddrAny, len *Socklen_t) (errno int)\n+//sysnb\tgetsockname(fd int, sa *RawSockaddrAny, len *Socklen_t) (err error)\n //getsockname(fd int, sa *RawSockaddrAny, len *Socklen_t) int\n \n-func Getsockname(fd int) (sa Sockaddr, errno int) {\n+func Getsockname(fd int) (sa Sockaddr, err error) {\n \tvar rsa RawSockaddrAny\n \tvar len Socklen_t = SizeofSockaddrAny\n-\tif errno = getsockname(fd, &rsa, &len); errno != 0 {\n+\tif err = getsockname(fd, &rsa, &len); err != nil {\n \t\treturn\n \t}\n \treturn anyToSockaddr(&rsa)\n }\n \n-//sysnb getpeername(fd int, sa *RawSockaddrAny, len *Socklen_t) (errno int)\n+//sysnb getpeername(fd int, sa *RawSockaddrAny, len *Socklen_t) (err error)\n //getpeername(fd int, sa *RawSockaddrAny, len *Socklen_t) int\n \n-func Getpeername(fd int) (sa Sockaddr, errno int) {\n+func Getpeername(fd int) (sa Sockaddr, err error) {\n \tvar rsa RawSockaddrAny\n \tvar len Socklen_t = SizeofSockaddrAny\n-\tif getpeername(fd, &rsa, &len); errno != 0 {\n+\tif err = getpeername(fd, &rsa, &len); err != nil {\n \t\treturn\n \t}\n \treturn anyToSockaddr(&rsa)\n }\n \n-//sys\tbind(fd int, sa *RawSockaddrAny, len Socklen_t) (errno int)\n+//sys\tbind(fd int, sa *RawSockaddrAny, len Socklen_t) (err error)\n //bind(fd int, sa *RawSockaddrAny, len Socklen_t) int\n \n-func Bind(fd int, sa Sockaddr) (errno int) {\n+func Bind(fd int, sa Sockaddr) (err error) {\n \tptr, n, err := sa.sockaddr()\n-\tif err != 0 {\n+\tif err != nil {\n \t\treturn err\n \t}\n \treturn bind(fd, ptr, n)\n }\n \n-//sys\tconnect(s int, addr *RawSockaddrAny, addrlen Socklen_t) (errno int)\n+//sys\tconnect(s int, addr *RawSockaddrAny, addrlen Socklen_t) (err error)\n //connect(s int, addr *RawSockaddrAny, addrlen Socklen_t) int\n \n-func Connect(fd int, sa Sockaddr) (errno int) {\n+func Connect(fd int, sa Sockaddr) (err error) {\n \tptr, n, err := sa.sockaddr()\n-\tif err != 0 {\n+\tif err != nil {\n \t\treturn err\n \t}\n \treturn connect(fd, ptr, n)\n }\n \n-//sysnb\tsocket(domain int, typ int, proto int) (fd int, errno int)\n+//sysnb\tsocket(domain int, typ int, proto int) (fd int, err error)\n //socket(domain int, typ int, protocol int) int\n \n-func Socket(domain, typ, proto int) (fd, errno int) {\n+func Socket(domain, typ, proto int) (fd int, err error) {\n \tif domain == AF_INET6 && SocketDisableIPv6 {\n \t\treturn -1, EAFNOSUPPORT\n \t}\n-\tfd, errno = socket(domain, typ, proto)\n+\tfd, err = socket(domain, typ, proto)\n \treturn\n }\n \n-//sysnb\tsocketpair(domain int, typ int, proto int, fd *[2]int) (errno int)\n+//sysnb\tsocketpair(domain int, typ int, proto int, fd *[2]int) (err error)\n //socketpair(domain int, typ int, protocol int, fd *[2]int) int\n \n-func Socketpair(domain, typ, proto int) (fd [2]int, errno int) {\n-\terrno = socketpair(domain, typ, proto, &fd)\n+func Socketpair(domain, typ, proto int) (fd [2]int, err error) {\n+\terr = socketpair(domain, typ, proto, &fd)\n \treturn\n }\n \n-//sys\tgetsockopt(s int, level int, name int, val uintptr, vallen *Socklen_t) (errno int)\n+//sys\tgetsockopt(s int, level int, name int, val uintptr, vallen *Socklen_t) (err error)\n //getsockopt(s int, level int, name int, val *byte, vallen *Socklen_t) int\n \n-func GetsockoptInt(fd, level, opt int) (value, errno int) {\n+func GetsockoptInt(fd, level, opt int) (value int, err error) {\n \tvar n int32\n \tvallen := Socklen_t(4)\n-\terrno = getsockopt(fd, level, opt, (uintptr)(unsafe.Pointer(&n)), &vallen)\n-\treturn int(n), errno\n+\terr = getsockopt(fd, level, opt, (uintptr)(unsafe.Pointer(&n)), &vallen)\n+\treturn int(n), err\n }\n \n-func GetsockoptInet4Addr(fd, level, opt int) (value [4]byte, errno int) {\n+func GetsockoptInet4Addr(fd, level, opt int) (value [4]byte, err error) {\n \tvallen := Socklen_t(4)\n-\terrno = getsockopt(fd, level, opt, uintptr(unsafe.Pointer(&value[0])), &vallen)\n-\treturn value, errno\n+\terr = getsockopt(fd, level, opt, uintptr(unsafe.Pointer(&value[0])), &vallen)\n+\treturn value, err\n }\n \n-func GetsockoptIPMreq(fd, level, opt int) (*IPMreq, int) {\n+func GetsockoptIPMreq(fd, level, opt int) (*IPMreq, error) {\n \tvar value IPMreq\n \tvallen := Socklen_t(SizeofIPMreq)\n-\terrno := getsockopt(fd, level, opt, uintptr(unsafe.Pointer(&value)), &vallen)\n-\treturn &value, errno\n+\terr := getsockopt(fd, level, opt, uintptr(unsafe.Pointer(&value)), &vallen)\n+\treturn &value, err\n }\n \n /* FIXME: mksysinfo needs to support IPMreqn.\n \n-func GetsockoptIPMreqn(fd, level, opt int) (*IPMreqn, int) {\n+func GetsockoptIPMreqn(fd, level, opt int) (*IPMreqn, error) {\n \tvar value IPMreqn\n \tvallen := Socklen_t(SizeofIPMreqn)\n-\terrno := getsockopt(fd, level, opt, uintptr(unsafe.Pointer(&value)), &vallen)\n-\treturn &value, errno\n+\terr := getsockopt(fd, level, opt, uintptr(unsafe.Pointer(&value)), &vallen)\n+\treturn &value, err\n }\n \n */\n \n /* FIXME: mksysinfo needs to support IPv6Mreq.\n \n-func GetsockoptIPv6Mreq(fd, level, opt int) (*IPv6Mreq, int) {\n+func GetsockoptIPv6Mreq(fd, level, opt int) (*IPv6Mreq, error) {\n \tvar value IPv6Mreq\n \tvallen := Socklen_t(SizeofIPv6Mreq)\n-\terrno := getsockopt(fd, level, opt, uintptr(unsafe.Pointer(&value)), &vallen)\n-\treturn &value, errno\n+\terr := getsockopt(fd, level, opt, uintptr(unsafe.Pointer(&value)), &vallen)\n+\treturn &value, err\n }\n \n */\n \n-//sys\tsetsockopt(s int, level int, name int, val *byte, vallen Socklen_t) (errno int)\n+//sys\tsetsockopt(s int, level int, name int, val *byte, vallen Socklen_t) (err error)\n //setsockopt(s int, level int, optname int, val *byte, vallen Socklen_t) int\n \n-func SetsockoptInt(fd, level, opt int, value int) (errno int) {\n+func SetsockoptInt(fd, level, opt int, value int) (err error) {\n \tvar n = int32(value)\n \treturn setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(&n)), 4)\n }\n \n-func SetsockoptInet4Addr(fd, level, opt int, value [4]byte) (errno int) {\n+func SetsockoptInet4Addr(fd, level, opt int, value [4]byte) (err error) {\n \treturn setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(&value[0])), 4)\n }\n \n-func SetsockoptTimeval(fd, level, opt int, tv *Timeval) (errno int) {\n+func SetsockoptTimeval(fd, level, opt int, tv *Timeval) (err error) {\n \treturn setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(tv)), Socklen_t(unsafe.Sizeof(*tv)))\n }\n \n@@ -280,58 +280,58 @@ type Linger struct {\n \tLinger int32;\n }\n \n-func SetsockoptLinger(fd, level, opt int, l *Linger) (errno int) {\n+func SetsockoptLinger(fd, level, opt int, l *Linger) (err error) {\n \treturn setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(l)), Socklen_t(unsafe.Sizeof(*l)));\n }\n \n-func SetsockoptIPMreq(fd, level, opt int, mreq *IPMreq) (errno int) {\n+func SetsockoptIPMreq(fd, level, opt int, mreq *IPMreq) (err error) {\n \treturn setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(mreq)), Socklen_t(unsafe.Sizeof(*mreq)))\n }\n \n /* FIXME: mksysinfo needs to support IMPreqn.\n \n-func SetsockoptIPMreqn(fd, level, opt int, mreq *IPMreqn) (errno int) {\n+func SetsockoptIPMreqn(fd, level, opt int, mreq *IPMreqn) (err error) {\n \treturn setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(mreq)), Socklen_t(unsafe.Sizeof(*mreq)))\n }\n \n */\n \n-func SetsockoptIPv6Mreq(fd, level, opt int, mreq *IPv6Mreq) (errno int) {\n+func SetsockoptIPv6Mreq(fd, level, opt int, mreq *IPv6Mreq) (err error) {\n \treturn setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(mreq)), Socklen_t(unsafe.Sizeof(*mreq)))\n }\n \n-func SetsockoptString(fd, level, opt int, s string) (errno int) {\n+func SetsockoptString(fd, level, opt int, s string) (err error) {\n \treturn setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(&[]byte(s)[0])), Socklen_t(len(s)))\n }\n \n-//sys\trecvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *Socklen_t) (n int, errno int)\n+//sys\trecvfrom(fd int, p []byte, flags int, from *RawSockaddrAny, fromlen *Socklen_t) (n int, err error)\n //recvfrom(fd int, buf *byte, len Size_t, flags int, from *RawSockaddrAny, fromlen *Socklen_t) Ssize_t\n \n-func Recvfrom(fd int, p []byte, flags int) (n int, from Sockaddr, errno int) {\n+func Recvfrom(fd int, p []byte, flags int) (n int, from Sockaddr, err error) {\n \tvar rsa RawSockaddrAny\n \tvar len Socklen_t = SizeofSockaddrAny\n-\tif n, errno = recvfrom(fd, p, flags, &rsa, &len); errno != 0 {\n+\tif n, err = recvfrom(fd, p, flags, &rsa, &len); err != nil {\n \t\treturn\n \t}\n-\tfrom, errno = anyToSockaddr(&rsa)\n+\tfrom, err = anyToSockaddr(&rsa)\n \treturn\n }\n \n-//sys\tsendto(s int, buf []byte, flags int, to *RawSockaddrAny, tolen Socklen_t) (errno int)\n+//sys\tsendto(s int, buf []byte, flags int, to *RawSockaddrAny, tolen Socklen_t) (err error)\n //sendto(s int, buf *byte, len Size_t, flags int, to *RawSockaddrAny, tolen Socklen_t) Ssize_t\n \n-func Sendto(fd int, p []byte, flags int, to Sockaddr) (errno int) {\n+func Sendto(fd int, p []byte, flags int, to Sockaddr) (err error) {\n \tptr, n, err := to.sockaddr()\n-\tif err != 0 {\n+\tif err != nil {\n \t\treturn err\n \t}\n \treturn sendto(fd, p, flags, ptr, n)\n }\n \n-//sys\trecvmsg(s int, msg *Msghdr, flags int) (n int, errno int)\n+//sys\trecvmsg(s int, msg *Msghdr, flags int) (n int, err error)\n //recvmsg(s int, msg *Msghdr, flags int) Ssize_t\n \n-func Recvmsg(fd int, p, oob []byte, flags int) (n, oobn int, recvflags int, from Sockaddr, errno int) {\n+func Recvmsg(fd int, p, oob []byte, flags int) (n, oobn int, recvflags int, from Sockaddr, err error) {\n \tvar msg Msghdr\n \tvar rsa RawSockaddrAny\n \tmsg.Name = (*byte)(unsafe.Pointer(&rsa))\n@@ -353,28 +353,28 @@ func Recvmsg(fd int, p, oob []byte, flags int) (n, oobn int, recvflags int, from\n \t}\n \tmsg.Iov = &iov\n \tmsg.Iovlen = 1\n-\tif n, errno = recvmsg(fd, &msg, flags); errno != 0 {\n+\tif n, err = recvmsg(fd, &msg, flags); err != nil {\n \t\treturn\n \t}\n \toobn = int(msg.Controllen)\n \trecvflags = int(msg.Flags)\n \t// source address is only specified if the socket is unconnected\n \tif rsa.Addr.Family != AF_UNSPEC {\n-\t\tfrom, errno = anyToSockaddr(&rsa)\n+\t\tfrom, err = anyToSockaddr(&rsa)\n \t}\n \treturn\n }\n \n-//sys\tsendmsg(s int, msg *Msghdr, flags int) (errno int)\n+//sys\tsendmsg(s int, msg *Msghdr, flags int) (err error)\n //sendmsg(s int, msg *Msghdr, flags int) Ssize_t\n \n-func Sendmsg(fd int, p, oob []byte, to Sockaddr, flags int) (errno int) {\n+func Sendmsg(fd int, p, oob []byte, to Sockaddr, flags int) (err error) {\n \tvar ptr *RawSockaddrAny\n \tvar salen Socklen_t\n \tif to != nil {\n-\t\tvar err int\n+\t\tvar err error\n \t\tptr, salen, err = to.sockaddr()\n-\t\tif err != 0 {\n+\t\tif err != nil {\n \t\t\treturn err\n \t\t}\n \t}\n@@ -398,16 +398,16 @@ func Sendmsg(fd int, p, oob []byte, to Sockaddr, flags int) (errno int) {\n \t}\n \tmsg.Iov = &iov\n \tmsg.Iovlen = 1\n-\tif errno = sendmsg(fd, &msg, flags); errno != 0 {\n+\tif err = sendmsg(fd, &msg, flags); err != nil {\n \t\treturn\n \t}\n \treturn\n }\n \n-//sys\tListen(fd int, n int) (errno int)\n+//sys\tListen(fd int, n int) (err error)\n //listen(fd int, n int) int\n \n-//sys\tShutdown(fd int, how int) (errno int)\n+//sys\tShutdown(fd int, how int) (err error)\n //shutdown(fd int, how int) int\n \n func (iov *Iovec) SetLen(length int) {"}, {"sha": "be55991595164c4fa2037827191e3ce8f0a9c31e", "filename": "libgo/go/syscall/socket_bsd.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsocket_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsocket_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsocket_bsd.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -47,7 +47,7 @@ func (sa *RawSockaddrUnix) setLen(n int) {\n \tsa.Len = uint8(3 + n) // 2 for Family, Len; 1 for NUL.\n }\n \n-func (sa *RawSockaddrUnix) getLen() (int, int) {\n+func (sa *RawSockaddrUnix) getLen() (int, error) {\n \tif sa.Len < 3 || sa.Len > SizeofSockaddrUnix {\n \t\treturn 0, EINVAL\n \t}\n@@ -59,7 +59,7 @@ func (sa *RawSockaddrUnix) getLen() (int, int) {\n \t\t\tbreak\n \t\t}\n \t}\n-\treturn n, 0\n+\treturn n, nil\n }\n \n type RawSockaddr struct {\n@@ -69,10 +69,10 @@ type RawSockaddr struct {\n }\n \n // BindToDevice binds the socket associated with fd to device.\n-func BindToDevice(fd int, device string) (errno int) {\n+func BindToDevice(fd int, device string) (err error) {\n \treturn ENOSYS\n }\n \n-func anyToSockaddrOS(rsa *RawSockaddrAny) (Sockaddr, int) {\n-\treturn nil, EAFNOSUPPORT;\n+func anyToSockaddrOS(rsa *RawSockaddrAny) (Sockaddr, error) {\n+\treturn nil, EAFNOSUPPORT\n }"}, {"sha": "c1fdc656ab0916e8ed32ac32b513910da0b2fabf", "filename": "libgo/go/syscall/socket_irix.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsocket_irix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsocket_irix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsocket_irix.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -41,7 +41,7 @@ type RawSockaddrUnix struct {\n func (sa *RawSockaddrUnix) setLen(int) {\n }\n \n-func (sa *RawSockaddrUnix) getLen() (int, int) {\n+func (sa *RawSockaddrUnix) getLen() (int, error) {\n \tif sa.Path[0] == 0 {\n \t\t// \"Abstract\" Unix domain socket.\n \t\t// Rewrite leading NUL as @ for textual display.\n@@ -61,7 +61,7 @@ func (sa *RawSockaddrUnix) getLen() (int, int) {\n \t\tn++\n \t}\n \n-\treturn n, 0\n+\treturn n, nil\n }\n \n type RawSockaddr struct {\n@@ -70,7 +70,7 @@ type RawSockaddr struct {\n }\n \n // BindToDevice binds the socket associated with fd to device.\n-func BindToDevice(fd int, device string) (errno int) {\n+func BindToDevice(fd int, device string) (err error) {\n \treturn ENOSYS\n }\n \n@@ -124,6 +124,6 @@ const (\n \tEAI_MAX\t\t= 14\n )\n \n-func anyToSockaddrOS(rsa *RawSockaddrAny) (Sockaddr, int) {\n-\treturn nil, EAFNOSUPPORT;\n+func anyToSockaddrOS(rsa *RawSockaddrAny) (Sockaddr, error) {\n+\treturn nil, EAFNOSUPPORT\n }"}, {"sha": "212e0b2d4181ffa466c163e04f5d9ee7134d82b2", "filename": "libgo/go/syscall/socket_linux.go", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsocket_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsocket_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsocket_linux.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -24,7 +24,7 @@ type SockaddrLinklayer struct {\n \traw      RawSockaddrLinklayer\n }\n \n-func (sa *SockaddrLinklayer) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n+func (sa *SockaddrLinklayer) sockaddr() (*RawSockaddrAny, Socklen_t, error) {\n \tif sa.Ifindex < 0 || sa.Ifindex > 0x7fffffff {\n \t\treturn nil, 0, EINVAL\n \t}\n@@ -37,7 +37,7 @@ func (sa *SockaddrLinklayer) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n \tfor i := 0; i < len(sa.Addr); i++ {\n \t\tsa.raw.Addr[i] = sa.Addr[i]\n \t}\n-\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), SizeofSockaddrLinklayer, 0\n+\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), SizeofSockaddrLinklayer, nil\n }\n \n type SockaddrNetlink struct {\n@@ -48,12 +48,12 @@ type SockaddrNetlink struct {\n \traw    RawSockaddrNetlink\n }\n \n-func (sa *SockaddrNetlink) sockaddr() (*RawSockaddrAny, Socklen_t, int) {\n+func (sa *SockaddrNetlink) sockaddr() (*RawSockaddrAny, Socklen_t, error) {\n \tsa.raw.Family = AF_NETLINK\n \tsa.raw.Pad = sa.Pad\n \tsa.raw.Pid = sa.Pid\n \tsa.raw.Groups = sa.Groups\n-\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), SizeofSockaddrNetlink, 0\n+\treturn (*RawSockaddrAny)(unsafe.Pointer(&sa.raw)), SizeofSockaddrNetlink, nil\n }\n \n type RawSockaddrInet4 struct {\n@@ -87,7 +87,7 @@ type RawSockaddrUnix struct {\n func (sa *RawSockaddrUnix) setLen(int) {\n }\n \n-func (sa *RawSockaddrUnix) getLen() (int, int) {\n+func (sa *RawSockaddrUnix) getLen() (int, error) {\n \tif sa.Path[0] == 0 {\n \t\t// \"Abstract\" Unix domain socket.\n \t\t// Rewrite leading NUL as @ for textual display.\n@@ -107,7 +107,7 @@ func (sa *RawSockaddrUnix) getLen() (int, int) {\n \t\tn++\n \t}\n \n-\treturn n, 0\n+\treturn n, nil\n }\n \n type RawSockaddrLinklayer struct {\n@@ -133,11 +133,11 @@ type RawSockaddr struct {\n }\n \n // BindToDevice binds the socket associated with fd to device.\n-func BindToDevice(fd int, device string) (errno int) {\n+func BindToDevice(fd int, device string) (err error) {\n \treturn SetsockoptString(fd, SOL_SOCKET, SO_BINDTODEVICE, device)\n }\n \n-func anyToSockaddrOS(rsa *RawSockaddrAny) (Sockaddr, int) {\n+func anyToSockaddrOS(rsa *RawSockaddrAny) (Sockaddr, error) {\n \tswitch rsa.Addr.Family {\n \tcase AF_NETLINK:\n \t\tpp := (*RawSockaddrNetlink)(unsafe.Pointer(rsa))\n@@ -146,7 +146,7 @@ func anyToSockaddrOS(rsa *RawSockaddrAny) (Sockaddr, int) {\n \t\tsa.Pad = pp.Pad\n \t\tsa.Pid = pp.Pid\n \t\tsa.Groups = pp.Groups\n-\t\treturn sa, 0\n+\t\treturn sa, nil\n \n \tcase AF_PACKET:\n \t\tpp := (*RawSockaddrLinklayer)(unsafe.Pointer(rsa))\n@@ -159,16 +159,16 @@ func anyToSockaddrOS(rsa *RawSockaddrAny) (Sockaddr, int) {\n \t\tfor i := 0; i < len(sa.Addr); i++ {\n \t\t\tsa.Addr[i] = pp.Addr[i]\n \t\t}\n-\t\treturn sa, 0\n+\t\treturn sa, nil\n \t}\n \treturn nil, EAFNOSUPPORT\n }\n \n-//sysnb\tEpollCreate(size int) (fd int, errno int)\n+//sysnb\tEpollCreate(size int) (fd int, err error)\n //epoll_create(size int) int\n \n-//sysnb\tEpollCtl(epfd int, op int, fd int, event *EpollEvent) (errno int)\n+//sysnb\tEpollCtl(epfd int, op int, fd int, event *EpollEvent) (err error)\n //epoll_ctl(epfd int, op int, fd int, event *EpollEvent) int\n \n-//sys\tEpollWait(epfd int, events []EpollEvent, msec int) (n int, errno int)\n+//sys\tEpollWait(epfd int, events []EpollEvent, msec int) (n int, err error)\n //epoll_wait(epfd int, events *EpollEvent, maxevents int, timeout int) int"}, {"sha": "0a03465a3388821217b7378fae836a55ca241369", "filename": "libgo/go/syscall/socket_solaris.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsocket_solaris.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsocket_solaris.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsocket_solaris.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -42,7 +42,7 @@ type RawSockaddrUnix struct {\n func (sa *RawSockaddrUnix) setLen(int) {\n }\n \n-func (sa *RawSockaddrUnix) getLen() (int, int) {\n+func (sa *RawSockaddrUnix) getLen() (int, error) {\n \tif sa.Path[0] == 0 {\n \t\t// \"Abstract\" Unix domain socket.\n \t\t// Rewrite leading NUL as @ for textual display.\n@@ -62,7 +62,7 @@ func (sa *RawSockaddrUnix) getLen() (int, int) {\n \t\tn++\n \t}\n \n-\treturn n, 0\n+\treturn n, nil\n }\n \n type RawSockaddr struct {\n@@ -71,10 +71,10 @@ type RawSockaddr struct {\n }\n \n // BindToDevice binds the socket associated with fd to device.\n-func BindToDevice(fd int, device string) (errno int) {\n+func BindToDevice(fd int, device string) (err error) {\n \treturn ENOSYS\n }\n \n-func anyToSockaddrOS(rsa *RawSockaddrAny) (Sockaddr, int) {\n-\treturn nil, EAFNOSUPPORT;\n+func anyToSockaddrOS(rsa *RawSockaddrAny) (Sockaddr, error) {\n+\treturn nil, EAFNOSUPPORT\n }"}, {"sha": "ad9df6cff9859c0dc3ca4518d3e3e0789729dfa6", "filename": "libgo/go/syscall/syscall.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsyscall.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsyscall.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -9,8 +9,9 @@\n // packages rather than this one if you can.\n // For details of the functions and data types in this package consult\n // the manuals for the appropriate operating system.\n-// These calls return errno == 0 to indicate success; otherwise\n-// errno is an operating system error number describing the failure.\n+// These calls return err == nil to indicate success; otherwise\n+// err is an operating system error describing the failure.\n+// On most systems, that error has type syscall.Errno.\n package syscall\n \n import \"unsafe\""}, {"sha": "899a65ca9b441083156c2d5e039df4245b2277b5", "filename": "libgo/go/syscall/syscall_unix.go", "status": "modified", "additions": 44, "deletions": 22, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsyscall_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fsyscall%2Fsyscall_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_unix.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -23,7 +23,7 @@ func c_syscall64(trap int64, a1, a2, a3, a4, a5, a6 int64) int64 __asm__ (\"sysca\n // Do a system call.  We look at the size of uintptr to see how to pass\n // the arguments, so that we don't pass a 64-bit value when the function\n // expects a 32-bit one.\n-func Syscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr) {\n+func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) {\n \tentersyscall()\n \tvar r uintptr\n \tif unsafe.Sizeof(r) == 4 {\n@@ -33,12 +33,12 @@ func Syscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr) {\n \t\tr1 := c_syscall64(int64(trap), int64(a1), int64(a2), int64(a3), 0, 0, 0)\n \t\tr = uintptr(r1)\n \t}\n-\terrno := GetErrno()\n+\terr = GetErrno()\n \texitsyscall()\n-\treturn r, 0, uintptr(errno)\n+\treturn r, 0, err\n }\n \n-func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr) {\n+func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno) {\n \tentersyscall()\n \tvar r uintptr\n \tif unsafe.Sizeof(r) == 4 {\n@@ -50,12 +50,12 @@ func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr) {\n \t\t\tint64(a4), int64(a5), int64(a6))\n \t\tr = uintptr(r1)\n \t}\n-\terrno := GetErrno()\n+\terr = GetErrno()\n \texitsyscall()\n-\treturn r, 0, uintptr(errno)\n+\treturn r, 0, err\n }\n \n-func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr) {\n+func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) {\n \tvar r uintptr\n \tif unsafe.Sizeof(r) == 4 {\n \t\tr1 := c_syscall32(int32(trap), int32(a1), int32(a2), int32(a3), 0, 0, 0)\n@@ -64,11 +64,11 @@ func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr) {\n \t\tr1 := c_syscall64(int64(trap), int64(a1), int64(a2), int64(a3), 0, 0, 0)\n \t\tr = uintptr(r1)\n \t}\n-\terrno := GetErrno()\n-\treturn r, 0, uintptr(errno)\n+\terr = GetErrno()\n+\treturn r, 0, err\n }\n \n-func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr) {\n+func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno) {\n \tvar r uintptr\n \tif unsafe.Sizeof(r) == 4 {\n \t\tr1 := c_syscall32(int32(trap), int32(a1), int32(a2), int32(a3),\n@@ -79,8 +79,8 @@ func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr) {\n \t\t\tint64(a4), int64(a5), int64(a6))\n \t\tr = uintptr(r1)\n \t}\n-\terrno := GetErrno()\n-\treturn r, 0, uintptr(errno)\n+\terr = GetErrno()\n+\treturn r, 0, err\n }\n \n // Mmap manager, for use by operating system-specific implementations.\n@@ -89,18 +89,18 @@ func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr) {\n type mmapper struct {\n \tsync.Mutex\n \tactive map[*byte][]byte // active mappings; key is last byte in mapping\n-\tmmap   func(addr, length uintptr, prot, flags, fd int, offset int64) (uintptr, int)\n-\tmunmap func(addr uintptr, length uintptr) int\n+\tmmap   func(addr, length uintptr, prot, flags, fd int, offset int64) (uintptr, error)\n+\tmunmap func(addr uintptr, length uintptr) error\n }\n \n-func (m *mmapper) Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, errno int) {\n+func (m *mmapper) Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, err error) {\n \tif length <= 0 {\n \t\treturn nil, EINVAL\n \t}\n \n \t// Map the requested memory.\n \taddr, errno := m.mmap(0, uintptr(length), prot, flags, fd, offset)\n-\tif errno != 0 {\n+\tif errno != nil {\n \t\treturn nil, errno\n \t}\n \n@@ -119,10 +119,10 @@ func (m *mmapper) Mmap(fd int, offset int64, length int, prot int, flags int) (d\n \tm.Lock()\n \tdefer m.Unlock()\n \tm.active[p] = b\n-\treturn b, 0\n+\treturn b, nil\n }\n \n-func (m *mmapper) Munmap(data []byte) (errno int) {\n+func (m *mmapper) Munmap(data []byte) (err error) {\n \tif len(data) == 0 || len(data) != cap(data) {\n \t\treturn EINVAL\n \t}\n@@ -137,11 +137,11 @@ func (m *mmapper) Munmap(data []byte) (errno int) {\n \t}\n \n \t// Unmap the memory and update m.\n-\tif errno := m.munmap(uintptr(unsafe.Pointer(&b[0])), uintptr(len(b))); errno != 0 {\n+\tif errno := m.munmap(uintptr(unsafe.Pointer(&b[0])), uintptr(len(b))); errno != nil {\n \t\treturn errno\n \t}\n \tm.active[p] = nil, false\n-\treturn 0\n+\treturn nil\n }\n \n var mapper = &mmapper{\n@@ -150,10 +150,32 @@ var mapper = &mmapper{\n \tmunmap: munmap,\n }\n \n-func Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, errno int) {\n+func Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, err error) {\n \treturn mapper.Mmap(fd, offset, length, prot, flags)\n }\n \n-func Munmap(b []byte) (errno int) {\n+func Munmap(b []byte) (err error) {\n \treturn mapper.Munmap(b)\n }\n+\n+\n+// An Errno is an unsigned number describing an error condition.\n+// It implements the error interface.  The zero Errno is by convention\n+// a non-error, so code to convert from Errno to error should use:\n+//\terr = nil\n+//\tif errno != 0 {\n+//\t\terr = errno\n+//\t}\n+type Errno uintptr\n+\n+func (e Errno) Error() string {\n+\treturn Errstr(int(e))\n+}\n+\n+func (e Errno) Temporary() bool {\n+\treturn e == EINTR || e == EMFILE || e.Timeout()\n+}\n+\n+func (e Errno) Timeout() bool {\n+\treturn e == EAGAIN || e == EWOULDBLOCK || e == ETIMEDOUT\n+}"}, {"sha": "4f049a31f758d5c3ae1b8713050bbfce25e78f80", "filename": "libgo/go/testing/benchmark.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fbenchmark.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -205,7 +205,7 @@ func RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks [\n \tfor _, Benchmark := range benchmarks {\n \t\tmatched, err := matchString(*matchBenchmarks, Benchmark.Name)\n \t\tif err != nil {\n-\t\t\tprintln(\"invalid regexp for -test.bench:\", err.Error())\n+\t\t\tfmt.Fprintf(os.Stderr, \"testing: invalid regexp for -test.bench: %s\\n\", err)\n \t\t\tos.Exit(1)\n \t\t}\n \t\tif !matched {\n@@ -218,11 +218,11 @@ func RunBenchmarks(matchString func(pat, str string) (bool, error), benchmarks [\n \t\t\tif procs != 1 {\n \t\t\t\tbenchName = fmt.Sprintf(\"%s-%d\", Benchmark.Name, procs)\n \t\t\t}\n-\t\t\tprint(fmt.Sprintf(\"%s\\t\", benchName))\n+\t\t\tfmt.Printf(\"%s\\t\", benchName)\n \t\t\tr := b.run()\n-\t\t\tprint(fmt.Sprintf(\"%v\\n\", r))\n+\t\t\tfmt.Printf(\"%v\\n\", r)\n \t\t\tif p := runtime.GOMAXPROCS(-1); p != procs {\n-\t\t\t\tprint(fmt.Sprintf(\"%s left GOMAXPROCS set to %d\\n\", benchName, p))\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"testing: %s left GOMAXPROCS set to %d\\n\", benchName, p)\n \t\t\t}\n \t\t}\n \t}"}, {"sha": "3b026ee66e00787d78f58eb94c3f29a15b181023", "filename": "libgo/go/testing/example.go", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftesting%2Fexample.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftesting%2Fexample.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fexample.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -21,24 +21,23 @@ type InternalExample struct {\n func RunExamples(examples []InternalExample) (ok bool) {\n \tok = true\n \n+\tvar eg InternalExample\n+\n \tstdout, stderr := os.Stdout, os.Stderr\n \tdefer func() {\n \t\tos.Stdout, os.Stderr = stdout, stderr\n \t\tif e := recover(); e != nil {\n-\t\t\tif err, ok := e.(error); ok {\n-\t\t\t\tfmt.Fprintln(os.Stderr, err)\n-\t\t\t\tos.Exit(1)\n-\t\t\t}\n-\t\t\tpanic(e)\n+\t\t\tfmt.Printf(\"--- FAIL: %s\\npanic: %v\\n\", eg.Name, e)\n+\t\t\tos.Exit(1)\n \t\t}\n \t}()\n \n-\tfor _, eg := range examples {\n+\tfor _, eg = range examples {\n \t\tif *chatty {\n-\t\t\tfmt.Fprintln(os.Stderr, \"=== RUN:\", eg.Name)\n+\t\t\tfmt.Printf(\"=== RUN: %s\\n\", eg.Name)\n \t\t}\n \n-\t\t// capture stdout and stderr for testing purposes\n+\t\t// capture stdout and stderr\n \t\tr, w, err := os.Pipe()\n \t\tif err != nil {\n \t\t\tfmt.Fprintln(os.Stderr, err)\n@@ -50,7 +49,7 @@ func RunExamples(examples []InternalExample) (ok bool) {\n \t\t\tbuf := new(bytes.Buffer)\n \t\t\t_, err := io.Copy(buf, r)\n \t\t\tif err != nil {\n-\t\t\t\tfmt.Fprintln(os.Stderr, err)\n+\t\t\t\tfmt.Fprintf(stderr, \"testing: copying pipe: %v\\n\", err)\n \t\t\t\tos.Exit(1)\n \t\t\t}\n \t\t\toutC <- buf.String()\n@@ -67,16 +66,15 @@ func RunExamples(examples []InternalExample) (ok bool) {\n \t\tout := <-outC\n \n \t\t// report any errors\n+\t\ttstr := fmt.Sprintf(\"(%.2f seconds)\", float64(ns)/1e9)\n \t\tif out != eg.Output {\n-\t\t\tfmt.Fprintf(\n-\t\t\t\tos.Stderr,\n-\t\t\t\t\"--- FAIL: %s\\ngot:\\n%s\\nwant:\\n%s\\n\",\n-\t\t\t\teg.Name, out, eg.Output,\n+\t\t\tfmt.Printf(\n+\t\t\t\t\"--- FAIL: %s %s\\ngot:\\n%s\\nwant:\\n%s\\n\",\n+\t\t\t\teg.Name, tstr, out, eg.Output,\n \t\t\t)\n \t\t\tok = false\n \t\t} else if *chatty {\n-\t\t\ttstr := fmt.Sprintf(\"(%.2f seconds)\", float64(ns)/1e9)\n-\t\t\tfmt.Fprintln(os.Stderr, \"--- PASS:\", eg.Name, tstr)\n+\t\t\tfmt.Printf(\"--- PASS: %s %s\\n\", eg.Name, tstr)\n \t\t}\n \t}\n "}, {"sha": "08443a31259d702db23e4ea04e4d3ec1eff88808", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 37, "deletions": 18, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -75,16 +75,34 @@ func Short() bool {\n \treturn *short\n }\n \n-// Insert final newline if needed and tabs after internal newlines.\n-func tabify(s string) string {\n+// decorate inserts the a final newline if needed and indentation tabs for formatting.\n+// If addFileLine is true, it also prefixes the string with the file and line of the call site.\n+func decorate(s string, addFileLine bool) string {\n+\tif addFileLine {\n+\t\t_, file, line, ok := runtime.Caller(3) // decorate + log + public function.\n+\t\tif ok {\n+\t\t\t// Truncate file name at last file name separator.\n+\t\t\tif index := strings.LastIndex(file, \"/\"); index >= 0 {\n+\t\t\t\tfile = file[index+1:]\n+\t\t\t} else if index = strings.LastIndex(file, \"\\\\\"); index >= 0 {\n+\t\t\t\tfile = file[index+1:]\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfile = \"???\"\n+\t\t\tline = 1\n+\t\t}\n+\t\ts = fmt.Sprintf(\"%s:%d: %s\", file, line, s)\n+\t}\n+\ts = \"\\t\" + s // Every line is indented at least one tab.\n \tn := len(s)\n \tif n > 0 && s[n-1] != '\\n' {\n \t\ts += \"\\n\"\n \t\tn++\n \t}\n \tfor i := 0; i < n-1; i++ { // -1 to avoid final newline\n \t\tif s[i] == '\\n' {\n-\t\t\treturn s[0:i+1] + \"\\t\" + tabify(s[i+1:n])\n+\t\t\t// Second and subsequent lines are indented an extra tab.\n+\t\t\treturn s[0:i+1] + \"\\t\" + decorate(s[i+1:n], false)\n \t\t}\n \t}\n \treturn s\n@@ -116,37 +134,38 @@ func (t *T) FailNow() {\n \truntime.Goexit()\n }\n \n+// log generates the output. It's always at the same stack depth.\n+func (t *T) log(s string) { t.errors += decorate(s, true) }\n+\n // Log formats its arguments using default formatting, analogous to Print(),\n // and records the text in the error log.\n-func (t *T) Log(args ...interface{}) { t.errors += \"\\t\" + tabify(fmt.Sprintln(args...)) }\n+func (t *T) Log(args ...interface{}) { t.log(fmt.Sprintln(args...)) }\n \n // Logf formats its arguments according to the format, analogous to Printf(),\n // and records the text in the error log.\n-func (t *T) Logf(format string, args ...interface{}) {\n-\tt.errors += \"\\t\" + tabify(fmt.Sprintf(format, args...))\n-}\n+func (t *T) Logf(format string, args ...interface{}) { t.log(fmt.Sprintf(format, args...)) }\n \n // Error is equivalent to Log() followed by Fail().\n func (t *T) Error(args ...interface{}) {\n-\tt.Log(args...)\n+\tt.log(fmt.Sprintln(args...))\n \tt.Fail()\n }\n \n // Errorf is equivalent to Logf() followed by Fail().\n func (t *T) Errorf(format string, args ...interface{}) {\n-\tt.Logf(format, args...)\n+\tt.log(fmt.Sprintf(format, args...))\n \tt.Fail()\n }\n \n // Fatal is equivalent to Log() followed by FailNow().\n func (t *T) Fatal(args ...interface{}) {\n-\tt.Log(args...)\n+\tt.log(fmt.Sprintln(args...))\n \tt.FailNow()\n }\n \n // Fatalf is equivalent to Logf() followed by FailNow().\n func (t *T) Fatalf(format string, args ...interface{}) {\n-\tt.Logf(format, args...)\n+\tt.log(fmt.Sprintf(format, args...))\n \tt.FailNow()\n }\n \n@@ -182,10 +201,10 @@ func Main(matchString func(pat, str string) (bool, error), tests []InternalTest,\n \ttestOk := RunTests(matchString, tests)\n \texampleOk := RunExamples(examples)\n \tif !testOk || !exampleOk {\n-\t\tfmt.Fprintln(os.Stderr, \"FAIL\")\n+\t\tfmt.Println(\"FAIL\")\n \t\tos.Exit(1)\n \t}\n-\tfmt.Fprintln(os.Stderr, \"PASS\")\n+\tfmt.Println(\"PASS\")\n \tstopAlarm()\n \tRunBenchmarks(matchString, benchmarks)\n \tafter()\n@@ -195,9 +214,9 @@ func report(t *T) {\n \ttstr := fmt.Sprintf(\"(%.2f seconds)\", float64(t.ns)/1e9)\n \tformat := \"--- %s: %s %s\\n%s\"\n \tif t.failed {\n-\t\tfmt.Fprintf(os.Stderr, format, \"FAIL\", t.name, tstr, t.errors)\n+\t\tfmt.Printf(format, \"FAIL\", t.name, tstr, t.errors)\n \t} else if *chatty {\n-\t\tfmt.Fprintf(os.Stderr, format, \"PASS\", t.name, tstr, t.errors)\n+\t\tfmt.Printf(format, \"PASS\", t.name, tstr, t.errors)\n \t}\n }\n \n@@ -217,7 +236,7 @@ func RunTests(matchString func(pat, str string) (bool, error), tests []InternalT\n \t\tfor i := 0; i < len(tests); i++ {\n \t\t\tmatched, err := matchString(*match, tests[i].Name)\n \t\t\tif err != nil {\n-\t\t\t\tprintln(\"invalid regexp for -test.run:\", err.Error())\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"testing: invalid regexp for -test.run: %s\\n\", err)\n \t\t\t\tos.Exit(1)\n \t\t\t}\n \t\t\tif !matched {\n@@ -229,7 +248,7 @@ func RunTests(matchString func(pat, str string) (bool, error), tests []InternalT\n \t\t\t}\n \t\t\tt := &T{ch: ch, name: testName, startParallel: startParallel}\n \t\t\tif *chatty {\n-\t\t\t\tprintln(\"=== RUN\", t.name)\n+\t\t\t\tfmt.Printf(\"=== RUN %s\\n\", t.name)\n \t\t\t}\n \t\t\tgo tRunner(t, &tests[i])\n \t\t\tout := <-t.ch\n@@ -325,7 +344,7 @@ func parseCpuList() {\n \t\tfor _, val := range strings.Split(*cpuListStr, \",\") {\n \t\t\tcpu, err := strconv.Atoi(val)\n \t\t\tif err != nil || cpu <= 0 {\n-\t\t\t\tprintln(\"invalid value for -test.cpu\")\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"testing: invalid value %q for -test.cpu\", val)\n \t\t\t\tos.Exit(1)\n \t\t\t}\n \t\t\tcpuList = append(cpuList, cpu)"}, {"sha": "201a685c6305656b8319e19bae17eb7e1072d66b", "filename": "libgo/go/text/tabwriter/tabwriter.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftext%2Ftabwriter%2Ftabwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftext%2Ftabwriter%2Ftabwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftabwriter%2Ftabwriter.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -13,7 +13,6 @@ package tabwriter\n import (\n \t\"bytes\"\n \t\"io\"\n-\t\"os\"\n \t\"unicode/utf8\"\n )\n \n@@ -221,7 +220,7 @@ type osError struct {\n func (b *Writer) write0(buf []byte) {\n \tn, err := b.output.Write(buf)\n \tif n != len(buf) && err == nil {\n-\t\terr = os.EIO\n+\t\terr = io.ErrShortWrite\n \t}\n \tif err != nil {\n \t\tpanic(osError{err})"}, {"sha": "67b9416cd7673b87de38de93a7792d3d5efd0350", "filename": "libgo/go/text/template/exec_test.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -487,7 +487,11 @@ func testExecute(execTests []execTest, set *Set, t *testing.T) {\n \t}\n \tfor _, test := range execTests {\n \t\ttmpl := New(test.name).Funcs(funcs)\n-\t\t_, err := tmpl.ParseInSet(test.input, set)\n+\t\ttheSet := set\n+\t\tif theSet == nil {\n+\t\t\ttheSet = new(Set)\n+\t\t}\n+\t\t_, err := tmpl.ParseInSet(test.input, theSet)\n \t\tif err != nil {\n \t\t\tt.Errorf(\"%s: parse error: %s\", test.name, err)\n \t\t\tcontinue"}, {"sha": "7075f2ac20e61d0d016da087cb17f3f683088b21", "filename": "libgo/go/text/template/parse.go", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -62,7 +62,7 @@ func (t *Template) Funcs(funcMap FuncMap) *Template {\n // Parse parses the template definition string to construct an internal\n // representation of the template for execution.\n func (t *Template) Parse(s string) (tmpl *Template, err error) {\n-\tt.Tree, err = parse.New(t.name).Parse(s, t.leftDelim, t.rightDelim, t.parseFuncs, builtins)\n+\tt.Tree, err = parse.New(t.name).Parse(s, t.leftDelim, t.rightDelim, nil, t.parseFuncs, builtins)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -71,19 +71,13 @@ func (t *Template) Parse(s string) (tmpl *Template, err error) {\n \n // ParseInSet parses the template definition string to construct an internal\n // representation of the template for execution. It also adds the template\n-// to the set. It is an error if s is already defined in the set.\n+// to the set, which must not be nil. It is an error if s is already defined in the set.\n // Function bindings are checked against those in the set.\n func (t *Template) ParseInSet(s string, set *Set) (tmpl *Template, err error) {\n-\tvar setFuncs FuncMap\n-\tif set != nil {\n-\t\tsetFuncs = set.parseFuncs\n-\t}\n-\tt.Tree, err = parse.New(t.name).Parse(s, t.leftDelim, t.rightDelim, t.parseFuncs, setFuncs, builtins)\n+\tt.Tree, err = parse.New(t.name).Parse(s, t.leftDelim, t.rightDelim, set.trees, t.parseFuncs, set.parseFuncs, builtins)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tif set != nil {\n-\t\terr = set.add(t)\n-\t}\n+\terr = set.add(t)\n \treturn t, err\n }"}, {"sha": "e906ee83aacb5a14b38ec8bbaf72eaba12ebf0d2", "filename": "libgo/go/text/template/parse/parse.go", "status": "modified", "additions": 57, "deletions": 18, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -146,29 +146,70 @@ func (t *Tree) atEOF() bool {\n // Parse parses the template definition string to construct an internal\n // representation of the template for execution. If either action delimiter\n // string is empty, the default (\"{{\" or \"}}\") is used.\n-func (t *Tree) Parse(s, leftDelim, rightDelim string, funcs ...map[string]interface{}) (tree *Tree, err error) {\n+func (t *Tree) Parse(s, leftDelim, rightDelim string, treeSet map[string]*Tree, funcs ...map[string]interface{}) (tree *Tree, err error) {\n \tdefer t.recover(&err)\n \tt.startParse(funcs, lex(t.Name, s, leftDelim, rightDelim))\n-\tt.parse(true)\n+\tt.parse(treeSet)\n \tt.stopParse()\n \treturn t, nil\n }\n \n-// parse is the helper for Parse.\n-// It triggers an error if we expect EOF but don't reach it.\n-func (t *Tree) parse(toEOF bool) (next Node) {\n-\tt.Root, next = t.itemList(true)\n-\tif toEOF && next != nil {\n-\t\tt.errorf(\"unexpected %s\", next)\n+// parse is the top-level parser for a template, essentially the same\n+// as itemList except it also parses {{define}} actions.\n+// It runs to EOF.\n+func (t *Tree) parse(treeSet map[string]*Tree) (next Node) {\n+\tt.Root = newList()\n+\tfor t.peek().typ != itemEOF {\n+\t\tif t.peek().typ == itemLeftDelim {\n+\t\t\tdelim := t.next()\n+\t\t\tif t.next().typ == itemDefine {\n+\t\t\t\tnewT := New(\"new definition\") // name will be updated once we know it.\n+\t\t\t\tnewT.startParse(t.funcs, t.lex)\n+\t\t\t\tnewT.parseDefinition(treeSet)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tt.backup2(delim)\n+\t\t}\n+\t\tn := t.textOrAction()\n+\t\tif n.Type() == nodeEnd {\n+\t\t\tt.errorf(\"unexpected %s\", n)\n+\t\t}\n+\t\tt.Root.append(n)\n \t}\n-\treturn next\n+\treturn nil\n+}\n+\n+// parseDefinition parses a {{define}} ...  {{end}} template definition and\n+// installs the definition in the treeSet map.  The \"define\" keyword has already\n+// been scanned.\n+func (t *Tree) parseDefinition(treeSet map[string]*Tree) {\n+\tif treeSet == nil {\n+\t\tt.errorf(\"no set specified for template definition\")\n+\t}\n+\tconst context = \"define clause\"\n+\tname := t.expect(itemString, context)\n+\tvar err error\n+\tt.Name, err = strconv.Unquote(name.val)\n+\tif err != nil {\n+\t\tt.error(err)\n+\t}\n+\tt.expect(itemRightDelim, context)\n+\tvar end Node\n+\tt.Root, end = t.itemList()\n+\tif end.Type() != nodeEnd {\n+\t\tt.errorf(\"unexpected %s in %s\", end, context)\n+\t}\n+\tt.stopParse()\n+\tif _, present := treeSet[t.Name]; present {\n+\t\tt.errorf(\"template: %q multiply defined\", name)\n+\t}\n+\ttreeSet[t.Name] = t\n }\n \n // itemList:\n //\ttextOrAction*\n-// Terminates at EOF and at {{end}} or {{else}}, which is returned separately.\n-// The toEOF flag tells whether we expect to reach EOF.\n-func (t *Tree) itemList(toEOF bool) (list *ListNode, next Node) {\n+// Terminates at {{end}} or {{else}}, returned separately.\n+func (t *Tree) itemList() (list *ListNode, next Node) {\n \tlist = newList()\n \tfor t.peek().typ != itemEOF {\n \t\tn := t.textOrAction()\n@@ -178,10 +219,8 @@ func (t *Tree) itemList(toEOF bool) (list *ListNode, next Node) {\n \t\t}\n \t\tlist.append(n)\n \t}\n-\tif !toEOF {\n-\t\tt.unexpected(t.next(), \"input\")\n-\t}\n-\treturn list, nil\n+\tt.errorf(\"unexpected EOF\")\n+\treturn\n }\n \n // textOrAction:\n@@ -276,11 +315,11 @@ func (t *Tree) parseControl(context string) (lineNum int, pipe *PipeNode, list,\n \tdefer t.popVars(len(t.vars))\n \tpipe = t.pipeline(context)\n \tvar next Node\n-\tlist, next = t.itemList(false)\n+\tlist, next = t.itemList()\n \tswitch next.Type() {\n \tcase nodeEnd: //done\n \tcase nodeElse:\n-\t\telseList, next = t.itemList(false)\n+\t\telseList, next = t.itemList()\n \t\tif next.Type() != nodeEnd {\n \t\t\tt.errorf(\"expected end; found %s\", next)\n \t\t}"}, {"sha": "5c10086cc7c2cf765944658a6e935f3541ac9ae2", "filename": "libgo/go/text/template/parse/parse_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fparse_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -236,7 +236,7 @@ var builtins = map[string]interface{}{\n \n func TestParse(t *testing.T) {\n \tfor _, test := range parseTests {\n-\t\ttmpl, err := New(test.name).Parse(test.input, \"\", \"\", builtins)\n+\t\ttmpl, err := New(test.name).Parse(test.input, \"\", \"\", nil, builtins)\n \t\tswitch {\n \t\tcase err == nil && !test.ok:\n \t\t\tt.Errorf(\"%q: expected error; got none\", test.name)"}, {"sha": "55f3ceb3d515ae432424f73df428238e058e823e", "filename": "libgo/go/text/template/parse/set.go", "status": "modified", "additions": 2, "deletions": 36, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fset.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fset.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fparse%2Fset.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -4,46 +4,12 @@\n \n package parse\n \n-import (\n-\t\"fmt\"\n-\t\"strconv\"\n-)\n-\n // Set returns a slice of Trees created by parsing the template set\n // definition in the argument string. If an error is encountered,\n // parsing stops and an empty slice is returned with the error.\n func Set(text, leftDelim, rightDelim string, funcs ...map[string]interface{}) (tree map[string]*Tree, err error) {\n \ttree = make(map[string]*Tree)\n-\tdefer (*Tree)(nil).recover(&err)\n-\tlex := lex(\"set\", text, leftDelim, rightDelim)\n-\tconst context = \"define clause\"\n-\tfor {\n-\t\tt := New(\"set\") // name will be updated once we know it.\n-\t\tt.startParse(funcs, lex)\n-\t\t// Expect EOF or \"{{ define name }}\".\n-\t\tif t.atEOF() {\n-\t\t\tbreak\n-\t\t}\n-\t\tt.expect(itemLeftDelim, context)\n-\t\tt.expect(itemDefine, context)\n-\t\tname := t.expect(itemString, context)\n-\t\tt.Name, err = strconv.Unquote(name.val)\n-\t\tif err != nil {\n-\t\t\tt.error(err)\n-\t\t}\n-\t\tt.expect(itemRightDelim, context)\n-\t\tend := t.parse(false)\n-\t\tif end == nil {\n-\t\t\tt.errorf(\"unexpected EOF in %s\", context)\n-\t\t}\n-\t\tif end.Type() != nodeEnd {\n-\t\t\tt.errorf(\"unexpected %s in %s\", end, context)\n-\t\t}\n-\t\tt.stopParse()\n-\t\tif _, present := tree[t.Name]; present {\n-\t\t\treturn nil, fmt.Errorf(\"template: %q multiply defined\", name)\n-\t\t}\n-\t\ttree[t.Name] = t\n-\t}\n+\t// Top-level template name is needed but unused. TODO: clean this up.\n+\t_, err = New(\"ROOT\").Parse(text, leftDelim, rightDelim, tree, funcs...)\n \treturn\n }"}, {"sha": "48417044e7755799bd92e8439357bc18f3f0cbcf", "filename": "libgo/go/text/template/set.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftext%2Ftemplate%2Fset.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftext%2Ftemplate%2Fset.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fset.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -16,6 +16,7 @@ import (\n // A template may be a member of multiple sets.\n type Set struct {\n \ttmpl       map[string]*Template\n+\ttrees      map[string]*parse.Tree // maintained by parse package\n \tleftDelim  string\n \trightDelim string\n \tparseFuncs FuncMap"}, {"sha": "967fca09b99641e04bec2f1b067681c37570a8fa", "filename": "libgo/go/time/sleep.go", "status": "modified", "additions": 52, "deletions": 142, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Fsleep.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Fsleep.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsleep.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -4,54 +4,60 @@\n \n package time\n \n-import (\n-\t\"container/heap\"\n-\t\"sync\"\n-)\n+// Interface to timers implemented in package runtime.\n+// Must be in sync with ../runtime/runtime.h:/^struct.Timer$\n+type runtimeTimer struct {\n+\ti      int32\n+\twhen   int64\n+\tperiod int64\n+\tf      func(int64, interface{})\n+\targ    interface{}\n+}\n+\n+func startTimer(*runtimeTimer)\n+func stopTimer(*runtimeTimer) bool\n \n // The Timer type represents a single event.\n-// When the Timer expires, the current time will be sent on C\n-// unless the Timer represents an AfterFunc event.\n+// When the Timer expires, the current time will be sent on C,\n+// unless the Timer was created by AfterFunc.\n type Timer struct {\n \tC <-chan int64\n-\tt int64       // The absolute time that the event should fire.\n-\tf func(int64) // The function to call when the event fires.\n-\ti int         // The event's index inside eventHeap.\n+\tr runtimeTimer\n }\n \n-type timerHeap []*Timer\n-\n-// forever is the absolute time (in ns) of an event that is forever away.\n-const forever = 1 << 62\n-\n-// maxSleepTime is the maximum length of time that a sleeper\n-// sleeps for before checking if it is defunct.\n-const maxSleepTime = 1e9\n-\n-var (\n-\t// timerMutex guards the variables inside this var group.\n-\ttimerMutex sync.Mutex\n-\n-\t// timers holds a binary heap of pending events, terminated with a sentinel.\n-\ttimers timerHeap\n-\n-\t// currentSleeper is an ever-incrementing counter which represents\n-\t// the current sleeper. It allows older sleepers to detect that they are\n-\t// defunct and exit.\n-\tcurrentSleeper int64\n-)\n-\n-func init() {\n-\ttimers.Push(&Timer{t: forever}) // sentinel\n+// Stop prevents the Timer from firing.\n+// It returns true if the call stops the timer, false if the timer has already\n+// expired or stopped.\n+func (t *Timer) Stop() (ok bool) {\n+\treturn stopTimer(&t.r)\n }\n \n // NewTimer creates a new Timer that will send\n // the current time on its channel after at least ns nanoseconds.\n func NewTimer(ns int64) *Timer {\n \tc := make(chan int64, 1)\n-\te := after(ns, func(t int64) { c <- t })\n-\te.C = c\n-\treturn e\n+\tt := &Timer{\n+\t\tC: c,\n+\t\tr: runtimeTimer{\n+\t\t\twhen: Nanoseconds() + ns,\n+\t\t\tf:    sendTime,\n+\t\t\targ:  c,\n+\t\t},\n+\t}\n+\tstartTimer(&t.r)\n+\treturn t\n+}\n+\n+func sendTime(now int64, c interface{}) {\n+\t// Non-blocking send of time on c.\n+\t// Used in NewTimer, it cannot block anyway (buffer).\n+\t// Used in NewTicker, dropping sends on the floor is\n+\t// the desired behavior when the reader gets behind,\n+\t// because the sends are periodic.\n+\tselect {\n+\tcase c.(chan int64) <- now:\n+\tdefault:\n+\t}\n }\n \n // After waits at least ns nanoseconds before sending the current time\n@@ -65,113 +71,17 @@ func After(ns int64) <-chan int64 {\n // in its own goroutine. It returns a Timer that can\n // be used to cancel the call using its Stop method.\n func AfterFunc(ns int64, f func()) *Timer {\n-\treturn after(ns, func(_ int64) {\n-\t\tgo f()\n-\t})\n-}\n-\n-// Stop prevents the Timer from firing.\n-// It returns true if the call stops the timer, false if the timer has already\n-// expired or stopped.\n-func (e *Timer) Stop() (ok bool) {\n-\ttimerMutex.Lock()\n-\t// Avoid removing the first event in the queue so that\n-\t// we don't start a new sleeper unnecessarily.\n-\tif e.i > 0 {\n-\t\theap.Remove(timers, e.i)\n-\t}\n-\tok = e.f != nil\n-\te.f = nil\n-\ttimerMutex.Unlock()\n-\treturn\n-}\n-\n-// after is the implementation of After and AfterFunc.\n-// When the current time is after ns, it calls f with the current time.\n-// It assumes that f will not block.\n-func after(ns int64, f func(int64)) (e *Timer) {\n-\tnow := Nanoseconds()\n-\tt := now + ns\n-\tif ns > 0 && t < now {\n-\t\tpanic(\"time: time overflow\")\n-\t}\n-\ttimerMutex.Lock()\n-\tt0 := timers[0].t\n-\te = &Timer{nil, t, f, -1}\n-\theap.Push(timers, e)\n-\t// Start a new sleeper if the new event is before\n-\t// the first event in the queue. If the length of time\n-\t// until the new event is at least maxSleepTime,\n-\t// then we're guaranteed that the sleeper will wake up\n-\t// in time to service it, so no new sleeper is needed.\n-\tif t0 > t && (t0 == forever || ns < maxSleepTime) {\n-\t\tcurrentSleeper++\n-\t\tgo sleeper(currentSleeper)\n-\t}\n-\ttimerMutex.Unlock()\n-\treturn\n-}\n-\n-// sleeper continually looks at the earliest event in the queue, waits until it happens,\n-// then removes any events in the queue that are due. It stops when the queue\n-// is empty or when another sleeper has been started.\n-func sleeper(sleeperId int64) {\n-\ttimerMutex.Lock()\n-\te := timers[0]\n-\tt := Nanoseconds()\n-\tfor e.t != forever {\n-\t\tif dt := e.t - t; dt > 0 {\n-\t\t\tif dt > maxSleepTime {\n-\t\t\t\tdt = maxSleepTime\n-\t\t\t}\n-\t\t\ttimerMutex.Unlock()\n-\t\t\tsysSleep(dt)\n-\t\t\ttimerMutex.Lock()\n-\t\t\tif currentSleeper != sleeperId {\n-\t\t\t\t// Another sleeper has been started, making this one redundant.\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t\te = timers[0]\n-\t\tt = Nanoseconds()\n-\t\tfor t >= e.t {\n-\t\t\tif e.f != nil {\n-\t\t\t\te.f(t)\n-\t\t\t\te.f = nil\n-\t\t\t}\n-\t\t\theap.Pop(timers)\n-\t\t\te = timers[0]\n-\t\t}\n+\tt := &Timer{\n+\t\tr: runtimeTimer{\n+\t\t\twhen: Nanoseconds() + ns,\n+\t\t\tf:    goFunc,\n+\t\t\targ:  f,\n+\t\t},\n \t}\n-\ttimerMutex.Unlock()\n-}\n-\n-func (timerHeap) Len() int {\n-\treturn len(timers)\n-}\n-\n-func (timerHeap) Less(i, j int) bool {\n-\treturn timers[i].t < timers[j].t\n-}\n-\n-func (timerHeap) Swap(i, j int) {\n-\ttimers[i], timers[j] = timers[j], timers[i]\n-\ttimers[i].i = i\n-\ttimers[j].i = j\n-}\n-\n-func (timerHeap) Push(x interface{}) {\n-\te := x.(*Timer)\n-\te.i = len(timers)\n-\ttimers = append(timers, e)\n+\tstartTimer(&t.r)\n+\treturn t\n }\n \n-func (timerHeap) Pop() interface{} {\n-\t// TODO: possibly shrink array.\n-\tn := len(timers) - 1\n-\te := timers[n]\n-\ttimers[n] = nil\n-\ttimers = timers[0:n]\n-\te.i = -1\n-\treturn e\n+func goFunc(now int64, arg interface{}) {\n+\tgo arg.(func())()\n }"}, {"sha": "9171da3af1cec59bea2d1dbf3f58060668d3c31a", "filename": "libgo/go/time/sleep_test.go", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Fsleep_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Fsleep_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsleep_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -7,7 +7,9 @@ package time_test\n import (\n \t\"errors\"\n \t\"fmt\"\n+\t\"runtime\"\n \t\"sort\"\n+\t\"sync/atomic\"\n \t\"testing\"\n \t. \"time\"\n )\n@@ -47,6 +49,23 @@ func TestAfterFunc(t *testing.T) {\n \t<-c\n }\n \n+func TestAfterStress(t *testing.T) {\n+\tstop := uint32(0)\n+\tgo func() {\n+\t\tfor atomic.LoadUint32(&stop) == 0 {\n+\t\t\truntime.GC()\n+\t\t\t// Need to yield, because otherwise\n+\t\t\t// the main goroutine will never set the stop flag.\n+\t\t\truntime.Gosched()\n+\t\t}\n+\t}()\n+\tc := Tick(1)\n+\tfor i := 0; i < 100; i++ {\n+\t\t<-c\n+\t}\n+\tatomic.StoreUint32(&stop, 1)\n+}\n+\n func BenchmarkAfterFunc(b *testing.B) {\n \ti := b.N\n \tc := make(chan bool)"}, {"sha": "a5e529b814a936af7150660602debafbd449b52f", "filename": "libgo/go/time/sys.go", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Fsys.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Fsys.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsys.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -17,25 +17,4 @@ func Seconds() int64 {\n func Nanoseconds() int64\n \n // Sleep pauses the current goroutine for at least ns nanoseconds.\n-// Higher resolution sleeping may be provided by syscall.Nanosleep \n-// on some operating systems.\n-func Sleep(ns int64) error {\n-\t_, err := sleep(Nanoseconds(), ns)\n-\treturn err\n-}\n-\n-// sleep takes the current time and a duration,\n-// pauses for at least ns nanoseconds, and\n-// returns the current time and an error.\n-func sleep(t, ns int64) (int64, error) {\n-\t// TODO(cw): use monotonic-time once it's available\n-\tend := t + ns\n-\tfor t < end {\n-\t\terr := sysSleep(end - t)\n-\t\tif err != nil {\n-\t\t\treturn 0, err\n-\t\t}\n-\t\tt = Nanoseconds()\n-\t}\n-\treturn t, nil\n-}\n+func Sleep(ns int64)"}, {"sha": "e58fb519ea32e5c22065a2a551213d00e2e6cdd4", "filename": "libgo/go/time/sys_plan9.go", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Fsys_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Fsys_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsys_plan9.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -4,19 +4,6 @@\n \n package time\n \n-import (\n-\t\"os\"\n-\t\"syscall\"\n-)\n-\n-func sysSleep(t int64) error {\n-\terr := syscall.Sleep(t)\n-\tif err != nil {\n-\t\treturn os.NewSyscallError(\"sleep\", err)\n-\t}\n-\treturn nil\n-}\n-\n // for testing: whatever interrupts a sleep\n func interrupt() {\n \t// cannot predict pid, don't want to kill group"}, {"sha": "3d313228b01970ad6cd0eb038a527d444255f433", "filename": "libgo/go/time/sys_unix.go", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Fsys_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Fsys_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsys_unix.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -11,14 +11,6 @@ import (\n \t\"syscall\"\n )\n \n-func sysSleep(t int64) error {\n-\terrno := syscall.Sleep(t)\n-\tif errno != 0 && errno != syscall.EINTR {\n-\t\treturn os.NewSyscallError(\"sleep\", errno)\n-\t}\n-\treturn nil\n-}\n-\n // for testing: whatever interrupts a sleep\n func interrupt() {\n \tsyscall.Kill(os.Getpid(), syscall.SIGCHLD)"}, {"sha": "8c7242f4275cb7b5718a97b81545c9f34c00de7d", "filename": "libgo/go/time/sys_windows.go", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Fsys_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Fsys_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsys_windows.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -4,19 +4,6 @@\n \n package time\n \n-import (\n-\t\"os\"\n-\t\"syscall\"\n-)\n-\n-func sysSleep(t int64) error {\n-\terrno := syscall.Sleep(t)\n-\tif errno != 0 && errno != syscall.EINTR {\n-\t\treturn os.NewSyscallError(\"sleep\", errno)\n-\t}\n-\treturn nil\n-}\n-\n // for testing: whatever interrupts a sleep\n func interrupt() {\n }"}, {"sha": "95941a1e8196a6e85816d2b888364d6e650dbb6b", "filename": "libgo/go/time/tick.go", "status": "modified", "additions": 29, "deletions": 153, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Ftick.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Ftick.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftick.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -4,156 +4,15 @@\n \n package time\n \n-import (\n-\t\"errors\"\n-\t\"sync\"\n-)\n+import \"errors\"\n \n // A Ticker holds a synchronous channel that delivers `ticks' of a clock\n // at intervals.\n type Ticker struct {\n-\tC        <-chan int64 // The channel on which the ticks are delivered.\n-\tc        chan<- int64 // The same channel, but the end we use.\n-\tns       int64\n-\tshutdown chan bool // Buffered channel used to signal shutdown.\n-\tnextTick int64\n-\tnext     *Ticker\n+\tC <-chan int64 // The channel on which the ticks are delivered.\n+\tr runtimeTimer\n }\n \n-// Stop turns off a ticker.  After Stop, no more ticks will be sent.\n-func (t *Ticker) Stop() {\n-\tselect {\n-\tcase t.shutdown <- true:\n-\t\t// ok\n-\tdefault:\n-\t\t// Stop in progress already\n-\t}\n-}\n-\n-// Tick is a convenience wrapper for NewTicker providing access to the ticking\n-// channel only.  Useful for clients that have no need to shut down the ticker.\n-func Tick(ns int64) <-chan int64 {\n-\tif ns <= 0 {\n-\t\treturn nil\n-\t}\n-\treturn NewTicker(ns).C\n-}\n-\n-type alarmer struct {\n-\twakeUp   chan bool // wakeup signals sent/received here\n-\twakeMeAt chan int64\n-\twakeTime int64\n-}\n-\n-// Set alarm to go off at time ns, if not already set earlier.\n-func (a *alarmer) set(ns int64) {\n-\tswitch {\n-\tcase a.wakeTime > ns:\n-\t\t// Next tick we expect is too late; shut down the late runner\n-\t\t// and (after fallthrough) start a new wakeLoop.\n-\t\tclose(a.wakeMeAt)\n-\t\tfallthrough\n-\tcase a.wakeMeAt == nil:\n-\t\t// There's no wakeLoop, start one.\n-\t\ta.wakeMeAt = make(chan int64)\n-\t\ta.wakeUp = make(chan bool, 1)\n-\t\tgo wakeLoop(a.wakeMeAt, a.wakeUp)\n-\t\tfallthrough\n-\tcase a.wakeTime == 0:\n-\t\t// Nobody else is waiting; it's just us.\n-\t\ta.wakeTime = ns\n-\t\ta.wakeMeAt <- ns\n-\tdefault:\n-\t\t// There's already someone scheduled.\n-\t}\n-}\n-\n-// Channel to notify tickerLoop of new Tickers being created.\n-var newTicker chan *Ticker\n-\n-func startTickerLoop() {\n-\tnewTicker = make(chan *Ticker)\n-\tgo tickerLoop()\n-}\n-\n-// wakeLoop delivers ticks at scheduled times, sleeping until the right moment.\n-// If another, earlier Ticker is created while it sleeps, tickerLoop() will start a new\n-// wakeLoop and signal that this one is done by closing the wakeMeAt channel.\n-func wakeLoop(wakeMeAt chan int64, wakeUp chan bool) {\n-\tfor wakeAt := range wakeMeAt {\n-\t\tSleep(wakeAt - Nanoseconds())\n-\t\twakeUp <- true\n-\t}\n-}\n-\n-// A single tickerLoop serves all ticks to Tickers.  It waits for two events:\n-// either the creation of a new Ticker or a tick from the alarm,\n-// signaling a time to wake up one or more Tickers.\n-func tickerLoop() {\n-\t// Represents the next alarm to be delivered.\n-\tvar alarm alarmer\n-\tvar now, wakeTime int64\n-\tvar tickers *Ticker\n-\tfor {\n-\t\tselect {\n-\t\tcase t := <-newTicker:\n-\t\t\t// Add Ticker to list\n-\t\t\tt.next = tickers\n-\t\t\ttickers = t\n-\t\t\t// Arrange for a new alarm if this one precedes the existing one.\n-\t\t\talarm.set(t.nextTick)\n-\t\tcase <-alarm.wakeUp:\n-\t\t\tnow = Nanoseconds()\n-\t\t\twakeTime = now + 1e15 // very long in the future\n-\t\t\tvar prev *Ticker = nil\n-\t\t\t// Scan list of tickers, delivering updates to those\n-\t\t\t// that need it and determining the next wake time.\n-\t\t\t// TODO(r): list should be sorted in time order.\n-\t\t\tfor t := tickers; t != nil; t = t.next {\n-\t\t\t\tselect {\n-\t\t\t\tcase <-t.shutdown:\n-\t\t\t\t\t// Ticker is done; remove it from list.\n-\t\t\t\t\tif prev == nil {\n-\t\t\t\t\t\ttickers = t.next\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tprev.next = t.next\n-\t\t\t\t\t}\n-\t\t\t\t\tcontinue\n-\t\t\t\tdefault:\n-\t\t\t\t}\n-\t\t\t\tif t.nextTick <= now {\n-\t\t\t\t\tif len(t.c) == 0 {\n-\t\t\t\t\t\t// Only send if there's room.  We must not block.\n-\t\t\t\t\t\t// The channel is allocated with a one-element\n-\t\t\t\t\t\t// buffer, which is sufficient: if he hasn't picked\n-\t\t\t\t\t\t// up the last tick, no point in sending more.\n-\t\t\t\t\t\tt.c <- now\n-\t\t\t\t\t}\n-\t\t\t\t\tt.nextTick += t.ns\n-\t\t\t\t\tif t.nextTick <= now {\n-\t\t\t\t\t\t// Still behind; advance in one big step.\n-\t\t\t\t\t\tt.nextTick += (now - t.nextTick + t.ns) / t.ns * t.ns\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif t.nextTick < wakeTime {\n-\t\t\t\t\twakeTime = t.nextTick\n-\t\t\t\t}\n-\t\t\t\tprev = t\n-\t\t\t}\n-\t\t\tif tickers != nil {\n-\t\t\t\t// Please send wakeup at earliest required time.\n-\t\t\t\t// If there are no tickers, don't bother.\n-\t\t\t\talarm.wakeTime = wakeTime\n-\t\t\t\talarm.wakeMeAt <- wakeTime\n-\t\t\t} else {\n-\t\t\t\talarm.wakeTime = 0\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-var onceStartTickerLoop sync.Once\n-\n // NewTicker returns a new Ticker containing a channel that will\n // send the time, in nanoseconds, every ns nanoseconds.  It adjusts the\n // intervals to make up for pauses in delivery of the ticks. The value of\n@@ -162,16 +21,33 @@ func NewTicker(ns int64) *Ticker {\n \tif ns <= 0 {\n \t\tpanic(errors.New(\"non-positive interval for NewTicker\"))\n \t}\n-\tc := make(chan int64, 1) //  See comment on send in tickerLoop\n+\t// Give the channel a 1-element time buffer.\n+\t// If the client falls behind while reading, we drop ticks\n+\t// on the floor until the client catches up.\n+\tc := make(chan int64, 1)\n \tt := &Ticker{\n-\t\tC:        c,\n-\t\tc:        c,\n-\t\tns:       ns,\n-\t\tshutdown: make(chan bool, 1),\n-\t\tnextTick: Nanoseconds() + ns,\n+\t\tC: c,\n+\t\tr: runtimeTimer{\n+\t\t\twhen:   Nanoseconds() + ns,\n+\t\t\tperiod: ns,\n+\t\t\tf:      sendTime,\n+\t\t\targ:    c,\n+\t\t},\n \t}\n-\tonceStartTickerLoop.Do(startTickerLoop)\n-\t// must be run in background so global Tickers can be created\n-\tgo func() { newTicker <- t }()\n+\tstartTimer(&t.r)\n \treturn t\n }\n+\n+// Stop turns off a ticker.  After Stop, no more ticks will be sent.\n+func (t *Ticker) Stop() {\n+\tstopTimer(&t.r)\n+}\n+\n+// Tick is a convenience wrapper for NewTicker providing access to the ticking\n+// channel only.  Useful for clients that have no need to shut down the ticker.\n+func Tick(ns int64) <-chan int64 {\n+\tif ns <= 0 {\n+\t\treturn nil\n+\t}\n+\treturn NewTicker(ns).C\n+}"}, {"sha": "e11d17731b4fe3dd5c6b400e1ff14c840fd141b1", "filename": "libgo/go/time/time.go", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -237,3 +237,63 @@ func (t *Time) Weekday() int {\n \t}\n \treturn weekday\n }\n+\n+// julianDayNumber returns the time's Julian Day Number\n+// relative to the epoch 12:00 January 1, 4713 BC, Monday.\n+func julianDayNumber(year int64, month, day int) int64 {\n+\ta := int64(14-month) / 12\n+\ty := year + 4800 - a\n+\tm := int64(month) + 12*a - 3\n+\treturn int64(day) + (153*m+2)/5 + 365*y + y/4 - y/100 + y/400 - 32045\n+}\n+\n+// startOfFirstWeek returns the julian day number of the first day\n+// of the first week of the given year.\n+func startOfFirstWeek(year int64) (d int64) {\n+\tjan01 := julianDayNumber(year, 1, 1)\n+\tweekday := (jan01 % 7) + 1\n+\tif weekday <= 4 {\n+\t\td = jan01 - weekday + 1\n+\t} else {\n+\t\td = jan01 + 8 - weekday\n+\t}\n+\treturn\n+}\n+\n+// dayOfWeek returns the weekday of the given date.\n+func dayOfWeek(year int64, month, day int) int {\n+\tt := Time{Year: year, Month: month, Day: day}\n+\treturn t.Weekday()\n+}\n+\n+// ISOWeek returns the time's year and week number according to ISO 8601. \n+// Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to \n+// week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1 \n+// of year n+1.\n+func (t *Time) ISOWeek() (year int64, week int) {\n+\td := julianDayNumber(t.Year, t.Month, t.Day)\n+\tweek1Start := startOfFirstWeek(t.Year)\n+\n+\tif d < week1Start {\n+\t\t// Previous year, week 52 or 53\n+\t\tyear = t.Year - 1\n+\t\tif dayOfWeek(t.Year-1, 1, 1) == 4 || dayOfWeek(t.Year-1, 12, 31) == 4 {\n+\t\t\tweek = 53\n+\t\t} else {\n+\t\t\tweek = 52\n+\t\t}\n+\t\treturn\n+\t}\n+\n+\tif d < startOfFirstWeek(t.Year+1) {\n+\t\t// Current year, week 01..52(,53)\n+\t\tyear = t.Year\n+\t\tweek = int((d-week1Start)/7 + 1)\n+\t\treturn\n+\t}\n+\n+\t// Next year, week 1\n+\tyear = t.Year + 1\n+\tweek = 1\n+\treturn\n+}"}, {"sha": "01b8bea4aad495a6e933a5f9f62fc377f29896b8", "filename": "libgo/go/time/time_test.go", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Ftime_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Ftime_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime_test.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -478,6 +478,68 @@ func TestMinutesInTimeZone(t *testing.T) {\n \t}\n }\n \n+type ISOWeekTest struct {\n+\tyear       int64 // year\n+\tmonth, day int   // month and day\n+\tyex        int64 // expected year\n+\twex        int   // expected week\n+}\n+\n+var isoWeekTests = []ISOWeekTest{\n+\t{1981, 1, 1, 1981, 1}, {1982, 1, 1, 1981, 53}, {1983, 1, 1, 1982, 52},\n+\t{1984, 1, 1, 1983, 52}, {1985, 1, 1, 1985, 1}, {1986, 1, 1, 1986, 1},\n+\t{1987, 1, 1, 1987, 1}, {1988, 1, 1, 1987, 53}, {1989, 1, 1, 1988, 52},\n+\t{1990, 1, 1, 1990, 1}, {1991, 1, 1, 1991, 1}, {1992, 1, 1, 1992, 1},\n+\t{1993, 1, 1, 1992, 53}, {1994, 1, 1, 1993, 52}, {1995, 1, 2, 1995, 1},\n+\t{1996, 1, 1, 1996, 1}, {1996, 1, 7, 1996, 1}, {1996, 1, 8, 1996, 2},\n+\t{1997, 1, 1, 1997, 1}, {1998, 1, 1, 1998, 1}, {1999, 1, 1, 1998, 53},\n+\t{2000, 1, 1, 1999, 52}, {2001, 1, 1, 2001, 1}, {2002, 1, 1, 2002, 1},\n+\t{2003, 1, 1, 2003, 1}, {2004, 1, 1, 2004, 1}, {2005, 1, 1, 2004, 53},\n+\t{2006, 1, 1, 2005, 52}, {2007, 1, 1, 2007, 1}, {2008, 1, 1, 2008, 1},\n+\t{2009, 1, 1, 2009, 1}, {2010, 1, 1, 2009, 53}, {2010, 1, 1, 2009, 53},\n+\t{2011, 1, 1, 2010, 52}, {2011, 1, 2, 2010, 52}, {2011, 1, 3, 2011, 1},\n+\t{2011, 1, 4, 2011, 1}, {2011, 1, 5, 2011, 1}, {2011, 1, 6, 2011, 1},\n+\t{2011, 1, 7, 2011, 1}, {2011, 1, 8, 2011, 1}, {2011, 1, 9, 2011, 1},\n+\t{2011, 1, 10, 2011, 2}, {2011, 1, 11, 2011, 2}, {2011, 6, 12, 2011, 23},\n+\t{2011, 6, 13, 2011, 24}, {2011, 12, 25, 2011, 51}, {2011, 12, 26, 2011, 52},\n+\t{2011, 12, 27, 2011, 52}, {2011, 12, 28, 2011, 52}, {2011, 12, 29, 2011, 52},\n+\t{2011, 12, 30, 2011, 52}, {2011, 12, 31, 2011, 52}, {1995, 1, 1, 1994, 52},\n+\t{2012, 1, 1, 2011, 52}, {2012, 1, 2, 2012, 1}, {2012, 1, 8, 2012, 1},\n+\t{2012, 1, 9, 2012, 2}, {2012, 12, 23, 2012, 51}, {2012, 12, 24, 2012, 52},\n+\t{2012, 12, 30, 2012, 52}, {2012, 12, 31, 2013, 1}, {2013, 1, 1, 2013, 1},\n+\t{2013, 1, 6, 2013, 1}, {2013, 1, 7, 2013, 2}, {2013, 12, 22, 2013, 51},\n+\t{2013, 12, 23, 2013, 52}, {2013, 12, 29, 2013, 52}, {2013, 12, 30, 2014, 1},\n+\t{2014, 1, 1, 2014, 1}, {2014, 1, 5, 2014, 1}, {2014, 1, 6, 2014, 2},\n+\t{2015, 1, 1, 2015, 1}, {2016, 1, 1, 2015, 53}, {2017, 1, 1, 2016, 52},\n+\t{2018, 1, 1, 2018, 1}, {2019, 1, 1, 2019, 1}, {2020, 1, 1, 2020, 1},\n+\t{2021, 1, 1, 2020, 53}, {2022, 1, 1, 2021, 52}, {2023, 1, 1, 2022, 52},\n+\t{2024, 1, 1, 2024, 1}, {2025, 1, 1, 2025, 1}, {2026, 1, 1, 2026, 1},\n+\t{2027, 1, 1, 2026, 53}, {2028, 1, 1, 2027, 52}, {2029, 1, 1, 2029, 1},\n+\t{2030, 1, 1, 2030, 1}, {2031, 1, 1, 2031, 1}, {2032, 1, 1, 2032, 1},\n+\t{2033, 1, 1, 2032, 53}, {2034, 1, 1, 2033, 52}, {2035, 1, 1, 2035, 1},\n+\t{2036, 1, 1, 2036, 1}, {2037, 1, 1, 2037, 1}, {2038, 1, 1, 2037, 53},\n+\t{2039, 1, 1, 2038, 52}, {2040, 1, 1, 2039, 52},\n+}\n+\n+func TestISOWeek(t *testing.T) {\n+\t// Selected dates and corner cases\n+\tfor _, wt := range isoWeekTests {\n+\t\tdt := &Time{Year: wt.year, Month: wt.month, Day: wt.day}\n+\t\ty, w := dt.ISOWeek()\n+\t\tif w != wt.wex || y != wt.yex {\n+\t\t\tt.Errorf(\"got %d/%d; expected %d/%d for %d-%02d-%02d\",\n+\t\t\t\ty, w, wt.yex, wt.wex, wt.year, wt.month, wt.day)\n+\t\t}\n+\t}\n+\n+\t// The only real invariant: Jan 04 is in week 1\n+\tfor year := int64(1950); year < 2100; year++ {\n+\t\tif y, w := (&Time{Year: year, Month: 1, Day: 4}).ISOWeek(); y != year || w != 1 {\n+\t\t\tt.Errorf(\"got %d/%d; expected %d/1 for Jan 04\", y, w, year)\n+\t\t}\n+\t}\n+}\n+\n func BenchmarkSeconds(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n \t\tSeconds()"}, {"sha": "b552e589aa947a08a97d0fbb9dcadb458330ff79", "filename": "libgo/go/time/zoneinfo_unix.go", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Fzoneinfo_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Fzoneinfo_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fzoneinfo_unix.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -12,7 +12,7 @@\n package time\n \n import (\n-\t\"io/ioutil\"\n+\t\"bytes\"\n \t\"os\"\n )\n \n@@ -180,11 +180,17 @@ func parseinfo(bytes []byte) (zt []zonetime, ok bool) {\n }\n \n func readinfofile(name string) ([]zonetime, bool) {\n-\tbuf, err := ioutil.ReadFile(name)\n+\tvar b bytes.Buffer\n+\n+\tf, err := os.Open(name)\n \tif err != nil {\n \t\treturn nil, false\n \t}\n-\treturn parseinfo(buf)\n+\tdefer f.Close()\n+\tif _, err := b.ReadFrom(f); err != nil {\n+\t\treturn nil, false\n+\t}\n+\treturn parseinfo(b.Bytes())\n }\n \n func setupTestingZone() {"}, {"sha": "995fd44dc063a5a7f6cf58d10ecf26750e43ccf2", "filename": "libgo/go/time/zoneinfo_windows.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Fzoneinfo_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Ftime%2Fzoneinfo_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fzoneinfo_windows.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -161,7 +161,7 @@ var onceSetupZone sync.Once\n \n func setupZone() {\n \tvar i syscall.Timezoneinformation\n-\tif _, e := syscall.GetTimeZoneInformation(&i); e != 0 {\n+\tif _, e := syscall.GetTimeZoneInformation(&i); e != nil {\n \t\tinitError = os.NewSyscallError(\"GetTimeZoneInformation\", e)\n \t\treturn\n \t}"}, {"sha": "df4416e22ed9e999ffe5c4a3bca6bc2bc2f2ca91", "filename": "libgo/go/websocket/websocket.go", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fwebsocket%2Fwebsocket.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fgo%2Fwebsocket%2Fwebsocket.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fwebsocket.go?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -10,12 +10,12 @@ import (\n \t\"bufio\"\n \t\"crypto/tls\"\n \t\"encoding/json\"\n+\t\"errors\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"net\"\n \t\"net/http\"\n \t\"net/url\"\n-\t\"os\"\n \t\"sync\"\n )\n \n@@ -243,28 +243,30 @@ func (ws *Conn) RemoteAddr() net.Addr {\n \treturn &Addr{ws.config.Origin}\n }\n \n+var errSetTimeout = errors.New(\"websocket: cannot set timeout: not using a net.Conn\")\n+\n // SetTimeout sets the connection's network timeout in nanoseconds.\n func (ws *Conn) SetTimeout(nsec int64) error {\n \tif conn, ok := ws.rwc.(net.Conn); ok {\n \t\treturn conn.SetTimeout(nsec)\n \t}\n-\treturn os.EINVAL\n+\treturn errSetTimeout\n }\n \n // SetReadTimeout sets the connection's network read timeout in nanoseconds.\n func (ws *Conn) SetReadTimeout(nsec int64) error {\n \tif conn, ok := ws.rwc.(net.Conn); ok {\n \t\treturn conn.SetReadTimeout(nsec)\n \t}\n-\treturn os.EINVAL\n+\treturn errSetTimeout\n }\n \n // SetWriteTimeout sets the connection's network write timeout in nanoseconds.\n func (ws *Conn) SetWriteTimeout(nsec int64) error {\n \tif conn, ok := ws.rwc.(net.Conn); ok {\n \t\treturn conn.SetWriteTimeout(nsec)\n \t}\n-\treturn os.EINVAL\n+\treturn errSetTimeout\n }\n \n // Config returns the WebSocket config."}, {"sha": "496abe53ad54eca290a4feb7cf9c9f730697c842", "filename": "libgo/merge.sh", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmerge.sh?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -137,9 +137,6 @@ merge_c() {\n }\n \n (cd ${NEWDIR}/src/pkg && find . -name '*.go' -print) | while read f; do\n-  if test `dirname $f` = \"./syscall\"; then\n-    continue\n-  fi\n   oldfile=${OLDDIR}/src/pkg/$f\n   newfile=${NEWDIR}/src/pkg/$f\n   libgofile=go/$f"}, {"sha": "6d8575c92625af99d483131feeec0eca90e776c5", "filename": "libgo/mksysinfo.sh", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fmksysinfo.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fmksysinfo.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmksysinfo.sh?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -120,9 +120,10 @@ grep -v '^// ' gen-sysinfo.go | \\\n       -e 's/\\([^a-zA-Z0-9_]\\)_timestruc_t\\([^a-zA-Z0-9_]\\)/\\1Timestruc\\2/g' \\\n     >> ${OUT}\n \n-# The errno constants.\n-grep '^const _E' gen-sysinfo.go | \\\n-  sed -e 's/^\\(const \\)_\\(E[^= ]*\\)\\(.*\\)$/\\1\\2 = _\\2/' >> ${OUT}\n+# The errno constants.  These get type Errno.\n+echo '#include <errno.h>' | ${CC} -x c - -E -dM | \\\n+  egrep '#define E[A-Z0-9_]+ ' | \\\n+  sed -e 's/^#define \\(E[A-Z0-9_]*\\) .*$/const \\1 = Errno(_\\1)/' >> ${OUT}\n \n # The O_xxx flags.\n egrep '^const _(O|F|FD)_' gen-sysinfo.go | \\\n@@ -191,8 +192,10 @@ fi\n grep '^const __PC' gen-sysinfo.go |\n   sed -e 's/^\\(const \\)__\\(PC[^= ]*\\)\\(.*\\)$/\\1\\2 = __\\2/' >> ${OUT}\n \n-# The epoll constants were picked up by the errno constants, but we\n-# need to be sure the EPOLLRDHUP is defined.\n+# epoll constants.\n+grep '^const _EPOLL' gen-sysinfo.go |\n+  sed -e 's/^\\(const \\)_\\(EPOLL[^= ]*\\)\\(.*\\)$/\\1\\2 = _\\2/' >> ${OUT}\n+# Make sure EPOLLRDHUP is defined.\n if ! grep '^const EPOLLRDHUP' ${OUT} >/dev/null 2>&1; then\n   echo \"const EPOLLRDHUP = 0x2000\" >> ${OUT}\n fi\n@@ -498,9 +501,11 @@ grep '^type _addrinfo ' gen-sysinfo.go | \\\n       -e 's/ ai_/ Ai_/g' \\\n     >> ${OUT}\n \n-# The addrinfo flags.\n+# The addrinfo flags and errors.\n grep '^const _AI_' gen-sysinfo.go | \\\n   sed -e 's/^\\(const \\)_\\(AI_[^= ]*\\)\\(.*\\)$/\\1\\2 = _\\2/' >> ${OUT}\n+grep '^const _EAI_' gen-sysinfo.go | \\\n+  sed -e 's/^\\(const \\)_\\(EAI_[^= ]*\\)\\(.*\\)$/\\1\\2 = _\\2/' >> ${OUT}\n \n # The passwd struct.\n grep '^type _passwd ' gen-sysinfo.go | \\\n@@ -644,17 +649,18 @@ grep '^type _termios ' gen-sysinfo.go | \\\n       -e 's/c_ospeed/Ospeed/' \\\n     >> ${OUT}\n \n-# The termios constants.  The ones starting with 'E' were picked up above.\n+# The termios constants.\n for n in IGNBRK BRKINT IGNPAR PARMRK INPCK ISTRIP INLCR IGNCR ICRNL IUCLC \\\n     IXON IXANY IXOFF IMAXBEL IUTF8 OPOST OLCUC ONLCR OCRNL ONOCR ONLRET \\\n     OFILL OFDEL NLDLY NL0 NL1 CRDLY CR0 CR1 CR2 CR3 TABDLY BSDLY VTDLY \\\n     FFDLY CBAUD CBAUDEX CSIZE CSTOPB CREAD PARENB PARODD HUPCL CLOCAL \\\n-    LOBLK CIBAUD CMSPAR CRTSCTS ISIG ICANON XCASE DEFECHK FLUSHO NOFLSH \\\n-    TOSTOP PENDIN IEXTEN VINTR VQUIT VERASE VKILL VEOF VMIN VEOL VTIME VEOL2 \\\n-    VSWTCH VSTART VSTOP VSUSP VDSUSP VLNEXT VWERASE VREPRINT VDISCARD VSTATUS \\\n-    TCSANOW TCSADRAIN, TCSAFLUSH TCIFLUSH TCOFLUSH TCIOFLUSH TCOOFF TCOON \\\n-    TCIOFF TCION B0 B50 B75 B110 B134 B150 B200 B300 B600 B1200 B1800 B2400 \\\n-    B4800 B9600 B19200 B38400 B57600 B115200 B230400; do\n+    LOBLK CIBAUD CMSPAR CRTSCTS ISIG ICANON XCASE ECHO ECHOE ECHOK ECHONL \\\n+    ECHOCTL ECHOPRT ECHOKE DEFECHO FLUSHO NOFLSH TOSTOP PENDIN IEXTEN VINTR \\\n+    VQUIT VERASE VKILL VEOF VMIN VEOL VTIME VEOL2 VSWTCH VSTART VSTOP VSUSP \\\n+    VDSUSP VLNEXT VWERASE VREPRINT VDISCARD VSTATUS TCSANOW TCSADRAIN \\\n+    TCSAFLUSH TCIFLUSH TCOFLUSH TCIOFLUSH TCOOFF TCOON TCIOFF TCION B0 B50 \\\n+    B75 B110 B134 B150 B200 B300 B600 B1200 B1800 B2400 B4800 B9600 B19200 \\\n+    B38400 B57600 B115200 B230400; do\n \n     grep \"^const _$n \" gen-sysinfo.go | \\\n \tsed -e 's/^\\(const \\)_\\([^=]*\\)\\(.*\\)$/\\1\\2 = _\\2/' >> ${OUT}"}, {"sha": "78717f4705ab383281dde0a4f67568392fc5bc60", "filename": "libgo/runtime/go-setenv.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fruntime%2Fgo-setenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fruntime%2Fgo-setenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-setenv.c?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -12,10 +12,10 @@\n #include \"go-alloc.h\"\n #include \"go-string.h\"\n \n-/* Set the C environment from Go.  This is called by os.Setenv.  */\n+/* Set the C environment from Go.  This is called by syscall.Setenv.  */\n \n void setenv_c (struct __go_string, struct __go_string)\n-  __asm__ (\"libgo_os.os.setenv_c\");\n+  __asm__ (\"libgo_syscall.syscall.setenv_c\");\n \n void\n setenv_c (struct __go_string k, struct __go_string v)"}, {"sha": "c4ab1454c5bf8ec5e223220d682b3d1de1c2e7d8", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -741,6 +741,7 @@ mark(void (*scan)(byte*, int64))\n \tscan((byte*)&runtime_allg, sizeof runtime_allg);\n \tscan((byte*)&runtime_allm, sizeof runtime_allm);\n \truntime_MProf_Mark(scan);\n+\truntime_time_scan(scan);\n \n \t// mark stacks\n \tfor(gp=runtime_allg; gp!=nil; gp=gp->alllink) {"}, {"sha": "34566fbf9a0fc5d6817b9ac9ca195c506d5af6bc", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -42,7 +42,6 @@ extern void *__splitstack_find(void *, void *, size_t *, void **, void **,\n #endif\n \n static void schedule(G*);\n-static M *startm(void);\n \n typedef struct Sched Sched;\n \n@@ -128,7 +127,7 @@ struct Sched {\n \tvolatile uint32 atomic;\t// atomic scheduling word (see below)\n \n \tint32 profilehz;\t// cpu profiling rate\n-\t\n+\n \tbool init;  // running initialization\n \tbool lockmain;  // init called runtime.LockOSThread\n \n@@ -826,7 +825,7 @@ runtime_starttheworld(bool extra)\n \t\t// but m is not running a specific goroutine,\n \t\t// so set the helpgc flag as a signal to m's\n \t\t// first schedule(nil) to mcpu-- and grunning--.\n-\t\tm = startm();\n+\t\tm = runtime_newm();\n \t\tm->helpgc = 1;\n \t\truntime_sched.grunning++;\n \t}\n@@ -876,8 +875,6 @@ struct CgoThreadStart\n };\n \n // Kick off new m's as needed (up to mcpumax).\n-// There are already `other' other cpus that will\n-// start looking for goroutines shortly.\n // Sched is locked.\n static void\n matchmg(void)\n@@ -895,13 +892,14 @@ matchmg(void)\n \n \t\t// Find the m that will run gp.\n \t\tif((mp = mget(gp)) == nil)\n-\t\t\tmp = startm();\n+\t\t\tmp = runtime_newm();\n \t\tmnextg(mp, gp);\n \t}\n }\n \n-static M*\n-startm(void)\n+// Create a new m.  It will start off with a call to runtime_mstart.\n+M*\n+runtime_newm(void)\n {\n \tM *m;\n \tpthread_attr_t attr;\n@@ -1135,6 +1133,7 @@ runtime_exitsyscall(void)\n \truntime_memclr(gp->gcregs, sizeof gp->gcregs);\n }\n \n+// Allocate a new g, with a stack big enough for stacksize bytes.\n G*\n runtime_malg(int32 stacksize, byte** ret_stack, size_t* ret_stacksize)\n {\n@@ -1283,6 +1282,7 @@ runtime_Gosched(void)\n \truntime_gosched();\n }\n \n+// Implementation of runtime.GOMAXPROCS.\n // delete when scheduler is stronger\n int32\n runtime_gomaxprocsfunc(int32 n)\n@@ -1390,6 +1390,7 @@ static struct {\n \tuintptr pcbuf[100];\n } prof;\n \n+// Called if we receive a SIGPROF signal.\n void\n runtime_sigprof(uint8 *pc __attribute__ ((unused)),\n \t\tuint8 *sp __attribute__ ((unused)),\n@@ -1412,6 +1413,7 @@ runtime_sigprof(uint8 *pc __attribute__ ((unused)),\n \truntime_unlock(&prof);\n }\n \n+// Arrange to call fn with a traceback hz times a second.\n void\n runtime_setcpuprofilerate(void (*fn)(uintptr*, int32), int32 hz)\n {"}, {"sha": "ec96f5b615f711247bf2107cb52e8b3dc8df828c", "filename": "libgo/runtime/runtime.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fruntime%2Fruntime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fruntime%2Fruntime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.c?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -87,7 +87,7 @@ static int32\targc;\n static byte**\targv;\n \n extern Slice os_Args asm (\"libgo_os.os.Args\");\n-extern Slice os_Envs asm (\"libgo_os.os.Envs\");\n+extern Slice syscall_Envs asm (\"libgo_syscall.syscall.Envs\");\n \n void\n runtime_args(int32 c, byte **v)\n@@ -126,9 +126,9 @@ runtime_goenvs(void)\n \ts = runtime_malloc(n*sizeof s[0]);\n \tfor(i=0; i<n; i++)\n \t\ts[i] = runtime_gostringnocopy(argv[argc+1+i]);\n-\tos_Envs.__values = (void*)s;\n-\tos_Envs.__count = n;\n-\tos_Envs.__capacity = n;\n+\tsyscall_Envs.__values = (void*)s;\n+\tsyscall_Envs.__count = n;\n+\tsyscall_Envs.__capacity = n;\n }\n \n const byte*\n@@ -141,8 +141,8 @@ runtime_getenv(const char *s)\n \n \tbs = (const byte*)s;\n \tlen = runtime_findnull(bs);\n-\tenvv = (String*)os_Envs.__values;\n-\tenvc = os_Envs.__count;\n+\tenvv = (String*)syscall_Envs.__values;\n+\tenvc = syscall_Envs.__count;\n \tfor(i=0; i<envc; i++){\n \t\tif(envv[i].__length <= len)\n \t\t\tcontinue;"}, {"sha": "1c7ede927222f7878f02c5610deb1a56d0a48c0c", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -56,6 +56,8 @@ typedef\tunion\tNote\t\tNote;\n typedef\tstruct\tMCache\t\tMCache;\n typedef struct\tFixAlloc\tFixAlloc;\n typedef\tstruct\tHchan\t\tHchan;\n+typedef\tstruct\tTimers\t\tTimers;\n+typedef\tstruct\tTimer\t\tTimer;\n \n typedef\tstruct\t__go_open_array\t\tSlice;\n typedef\tstruct\t__go_string\t\tString;\n@@ -190,6 +192,38 @@ enum {\n };\n #endif\n \n+struct\tTimers\n+{\n+\tLock;\n+\tG\t*timerproc;\n+\tbool\t\tsleeping;\n+\tbool\t\trescheduling;\n+\tNote\twaitnote;\n+\tTimer\t**t;\n+\tint32\tlen;\n+\tint32\tcap;\n+};\n+\n+// Package time knows the layout of this structure.\n+// If this struct changes, adjust ../time/sleep.go:/runtimeTimer.\n+struct\tTimer\n+{\n+\tint32\ti;\t\t// heap index\n+\n+\t// Timer wakes up at when, and then at when+period, ... (period > 0 only)\n+\t// each time calling f(now, arg) in the timer goroutine, so f must be\n+\t// a well-behaved function and not block.\n+\tint64\twhen;\n+\tint64\tperiod;\n+\tvoid\t(*f)(int64, Eface);\n+\tEface\targ;\n+};\n+\n+/*\n+ * defined macros\n+ *    you need super-gopher-guru privilege\n+ *    to add this list.\n+ */\n #define\tnelem(x)\t(sizeof(x)/sizeof((x)[0]))\n #define\tnil\t\t((void*)0)\n #define USED(v)\t\t((void) v)\n@@ -229,6 +263,8 @@ G*\truntime_malg(int32, byte**, size_t*);\n void\truntime_minit(void);\n void\truntime_mallocinit(void);\n void\truntime_gosched(void);\n+void\truntime_tsleep(int64);\n+M*\truntime_newm(void);\n void\truntime_goexit(void);\n void\truntime_entersyscall(void) __asm__(\"libgo_syscall.syscall.entersyscall\");\n void\truntime_exitsyscall(void) __asm__(\"libgo_syscall.syscall.exitsyscall\");\n@@ -341,3 +377,5 @@ void reflect_call(const struct __go_func_type *, const void *, _Bool, _Bool,\n #ifdef __rtems__\n void __wrap_rtems_task_variable_add(void **);\n #endif\n+\n+void\truntime_time_scan(void (*)(byte*, int64));"}, {"sha": "a0ee36006500c0ddc1739fff603f613dca02c443", "filename": "libgo/runtime/thread-linux.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fruntime%2Fthread-linux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fruntime%2Fthread-linux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fthread-linux.c?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -30,7 +30,7 @@ runtime_futexsleep(uint32 *addr, uint32 val, int64 ns)\n \telse {\n \t\tts.tv_sec = ns/1000000000LL;\n \t\tts.tv_nsec = ns%1000000000LL;\n-\t\t// Avoid overflowdefs\n+\t\t// Avoid overflow\n \t\tif(ts.tv_sec > 1<<30)\n \t\t\tts.tv_sec = 1<<30;\n \t\ttsp = &ts;"}, {"sha": "93b896ed0d2eb85e2a15fcb1b0d81e393a768d95", "filename": "libgo/runtime/time.goc", "status": "modified", "additions": 254, "deletions": 1, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fruntime%2Ftime.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab61e9c4da707f3bc7b177c0c8f92daccdb142dc/libgo%2Fruntime%2Ftime.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Ftime.goc?ref=ab61e9c4da707f3bc7b177c0c8f92daccdb142dc", "patch": "@@ -2,12 +2,265 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Runtime implementations to help package time.\n+// Time-related runtime and pieces of package time.\n \n package time\n \n #include \"runtime.h\"\n+#include \"defs.h\"\n+#include \"arch.h\"\n+#include \"malloc.h\"\n \n+static Timers timers;\n+static void addtimer(Timer*);\n+static bool deltimer(Timer*);\n+\n+// Package time APIs.\n+// Godoc uses the comments in package time, not these.\n+\n+// Nanoseconds returns the current time in nanoseconds.\n func Nanoseconds() (ret int64) {\n \tret = runtime_nanotime();\n }\n+\n+// Sleep puts the current goroutine to sleep for at least ns nanoseconds.\n+func Sleep(ns int64) {\n+\tG *g;\n+\n+\tg = runtime_g();\n+\tg->status = Gwaiting;\n+\tg->waitreason = \"sleep\";\n+\truntime_tsleep(ns);\n+}\n+\n+// startTimer adds t to the timer heap.\n+func startTimer(t *Timer) {\n+\taddtimer(t);\n+}\n+\n+// stopTimer removes t from the timer heap if it is there.\n+// It returns true if t was removed, false if t wasn't even there.\n+func stopTimer(t *Timer) (stopped bool) {\n+\tstopped = deltimer(t);\n+}\n+\n+// C runtime.\n+\n+static void timerproc(void*);\n+static void siftup(int32);\n+static void siftdown(int32);\n+\n+// Ready the goroutine e.data.\n+static void\n+ready(int64 now, Eface e)\n+{\n+\tUSED(now);\n+\n+\truntime_ready(e.__object);\n+}\n+\n+// Put the current goroutine to sleep for ns nanoseconds.\n+// The caller must have set g->status and g->waitreason.\n+void\n+runtime_tsleep(int64 ns)\n+{\n+\tTimer t;\n+\n+\tif(ns <= 0)\n+\t\treturn;\n+\n+\tt.when = runtime_nanotime() + ns;\n+\tt.period = 0;\n+\tt.f = ready;\n+\tt.arg.__object = runtime_g();\n+\taddtimer(&t);\n+\truntime_gosched();\n+}\n+\n+// Add a timer to the heap and start or kick the timer proc\n+// if the new timer is earlier than any of the others.\n+static void\n+addtimer(Timer *t)\n+{\n+\tint32 n;\n+\tTimer **nt;\n+\n+\truntime_lock(&timers);\n+\tif(timers.len >= timers.cap) {\n+\t\t// Grow slice.\n+\t\tn = 16;\n+\t\tif(n <= timers.cap)\n+\t\t\tn = timers.cap*3 / 2;\n+\t\tnt = runtime_malloc(n*sizeof nt[0]);\n+\t\truntime_memmove(nt, timers.t, timers.len*sizeof nt[0]);\n+\t\truntime_free(timers.t);\n+\t\ttimers.t = nt;\n+\t\ttimers.cap = n;\n+\t}\n+\tt->i = timers.len++;\n+\ttimers.t[t->i] = t;\n+\tsiftup(t->i);\n+\tif(t->i == 0) {\n+\t\t// siftup moved to top: new earliest deadline.\n+\t\tif(timers.sleeping) {\n+\t\t\ttimers.sleeping = false;\n+\t\t\truntime_notewakeup(&timers.waitnote);\n+\t\t}\n+\t\tif(timers.rescheduling) {\n+\t\t\ttimers.rescheduling = false;\n+\t\t\truntime_ready(timers.timerproc);\n+\t\t}\n+\t}\n+\tif(timers.timerproc == nil)\n+\t\ttimers.timerproc = __go_go(timerproc, nil);\n+\truntime_unlock(&timers);\n+}\n+\n+// Delete timer t from the heap.\n+// Do not need to update the timerproc:\n+// if it wakes up early, no big deal.\n+static bool\n+deltimer(Timer *t)\n+{\n+\tint32 i;\n+\n+\truntime_lock(&timers);\n+\n+\t// t may not be registered anymore and may have\n+\t// a bogus i (typically 0, if generated by Go).\n+\t// Verify it before proceeding.\n+\ti = t->i;\n+\tif(i < 0 || i >= timers.len || timers.t[i] != t) {\n+\t\truntime_unlock(&timers);\n+\t\treturn false;\n+\t}\n+\n+\ttimers.len--;\n+\tif(i == timers.len) {\n+\t\ttimers.t[i] = nil;\n+\t} else {\n+\t\ttimers.t[i] = timers.t[timers.len];\n+\t\ttimers.t[timers.len] = nil;\n+\t\ttimers.t[i]->i = i;\n+\t\tsiftup(i);\n+\t\tsiftdown(i);\n+\t}\n+\truntime_unlock(&timers);\n+\treturn true;\n+}\n+\n+// Timerproc runs the time-driven events.\n+// It sleeps until the next event in the timers heap.\n+// If addtimer inserts a new earlier event, addtimer\n+// wakes timerproc early.\n+static void\n+timerproc(void* dummy __attribute__ ((unused)))\n+{\n+\tG *g;\n+\tint64 delta, now;\n+\tTimer *t;\n+\tvoid (*f)(int64, Eface);\n+\tEface arg;\n+\n+\tg = runtime_g();\n+\tfor(;;) {\n+\t\truntime_lock(&timers);\n+\t\tnow = runtime_nanotime();\n+\t\tfor(;;) {\n+\t\t\tif(timers.len == 0) {\n+\t\t\t\tdelta = -1;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tt = timers.t[0];\n+\t\t\tdelta = t->when - now;\n+\t\t\tif(delta > 0)\n+\t\t\t\tbreak;\n+\t\t\tif(t->period > 0) {\n+\t\t\t\t// leave in heap but adjust next time to fire\n+\t\t\t\tt->when += t->period * (1 + -delta/t->period);\n+\t\t\t\tsiftdown(0);\n+\t\t\t} else {\n+\t\t\t\t// remove from heap\n+\t\t\t\ttimers.t[0] = timers.t[--timers.len];\n+\t\t\t\ttimers.t[0]->i = 0;\n+\t\t\t\tsiftdown(0);\n+\t\t\t\tt->i = -1;  // mark as removed\n+\t\t\t}\n+\t\t\tf = t->f;\n+\t\t\targ = t->arg;\n+\t\t\truntime_unlock(&timers);\n+\t\t\tf(now, arg);\n+\t\t\truntime_lock(&timers);\n+\t\t}\n+\t\tif(delta < 0) {\n+\t\t\t// No timers left - put goroutine to sleep.\n+\t\t\ttimers.rescheduling = true;\n+\t\t\tg->status = Gwaiting;\n+\t\t\tg->waitreason = \"timer goroutine (idle)\";\n+\t\t\truntime_unlock(&timers);\n+\t\t\truntime_gosched();\n+\t\t\tcontinue;\n+\t\t}\n+\t\t// At least one timer pending.  Sleep until then.\n+\t\ttimers.sleeping = true;\n+\t\truntime_noteclear(&timers.waitnote);\n+\t\truntime_unlock(&timers);\n+\t\truntime_entersyscall();\n+\t\truntime_notetsleep(&timers.waitnote, delta);\n+\t\truntime_exitsyscall();\n+\t}\n+}\n+\n+// heap maintenance algorithms.\n+\n+static void\n+siftup(int32 i)\n+{\n+\tint32 p;\n+\tTimer **t, *tmp;\n+\n+\tt = timers.t;\n+\twhile(i > 0) {\n+\t\tp = (i-1)/2;  // parent\n+\t\tif(t[i]->when >= t[p]->when)\n+\t\t\tbreak;\n+\t\ttmp = t[i];\n+\t\tt[i] = t[p];\n+\t\tt[p] = tmp;\n+\t\tt[i]->i = i;\n+\t\tt[p]->i = p;\n+\t\ti = p;\n+\t}\n+}\n+\n+static void\n+siftdown(int32 i)\n+{\n+\tint32 c, len;\n+\tTimer **t, *tmp;\n+\n+\tt = timers.t;\n+\tlen = timers.len;\n+\tfor(;;) {\n+\t\tc = i*2 + 1;  // left child\n+\t\tif(c >= len) {\n+\t\t\tbreak;\n+\t\t}\n+\t\tif(c+1 < len && t[c+1]->when < t[c]->when)\n+\t\t\tc++;\n+\t\tif(t[c]->when >= t[i]->when)\n+\t\t\tbreak;\n+\t\ttmp = t[i];\n+\t\tt[i] = t[c];\n+\t\tt[c] = tmp;\n+\t\tt[i]->i = i;\n+\t\tt[c]->i = c;\n+\t\ti = c;\n+\t}\n+}\n+\n+void\n+runtime_time_scan(void (*scan)(byte*, int64))\n+{\n+\tscan((byte*)&timers, sizeof timers);\n+}"}]}