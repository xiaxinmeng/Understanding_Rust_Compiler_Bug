{"sha": "2eed8f16bfefbf50d991419cc11fe9a0e2122aa8", "node_id": "C_kwDOANBUbNoAKDJlZWQ4ZjE2YmZlZmJmNTBkOTkxNDE5Y2MxMWZlOWEwZTIxMjJhYTg", "commit": {"author": {"name": "Javier Miranda", "email": "miranda@adacore.com", "date": "2021-12-17T16:43:57Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-01-07T16:24:14Z"}, "message": "[Ada] Crash in class-wide pre/postconditions\n\ngcc/ada/\n\n\t* atree.ads (Traverse_Func_With_Parent): New generic subprogram.\n\t(Traverse_Proc_With_Parent): Likewise.\n\t* atree.adb (Parents_Stack): New table used to traverse trees\n\tpassing the parent field of each node.\n\t(Internal_Traverse_With_Parent): New generic subprogram.\n\t(Traverse_Func_With_Parent): Likewise.\n\t(Traverse_Proc_With_Parent): Likewise.\n\t* contracts.adb (Fix_Parents): New subprogram.\n\t(Restore_Original_Selected_Component): Enhanced to fix the\n\tparent field of restored nodes.\n\t(Inherit_Condition): Adding assertions to check the parent field\n\tof inherited conditions and to ensure that the built inherited\n\tcondition has no reference to the formals of the parent\n\tsubprogram.\n\t* sem_util.ads, sem_util.adb (Check_Parents): New subprogram.", "tree": {"sha": "0348cf267081ac448c0616d726ea41bb60d304dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0348cf267081ac448c0616d726ea41bb60d304dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2eed8f16bfefbf50d991419cc11fe9a0e2122aa8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eed8f16bfefbf50d991419cc11fe9a0e2122aa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2eed8f16bfefbf50d991419cc11fe9a0e2122aa8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eed8f16bfefbf50d991419cc11fe9a0e2122aa8/comments", "author": {"login": "miranda-adacore", "id": 54413934, "node_id": "MDQ6VXNlcjU0NDEzOTM0", "avatar_url": "https://avatars.githubusercontent.com/u/54413934?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miranda-adacore", "html_url": "https://github.com/miranda-adacore", "followers_url": "https://api.github.com/users/miranda-adacore/followers", "following_url": "https://api.github.com/users/miranda-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/miranda-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/miranda-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miranda-adacore/subscriptions", "organizations_url": "https://api.github.com/users/miranda-adacore/orgs", "repos_url": "https://api.github.com/users/miranda-adacore/repos", "events_url": "https://api.github.com/users/miranda-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/miranda-adacore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f4e820d3bb5b65eab4c5693bdbe0cbe5877cd85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f4e820d3bb5b65eab4c5693bdbe0cbe5877cd85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f4e820d3bb5b65eab4c5693bdbe0cbe5877cd85"}], "stats": {"total": 445, "additions": 433, "deletions": 12}, "files": [{"sha": "8bffc976378a75a0eabf52676716736fd337844d", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8f16bfefbf50d991419cc11fe9a0e2122aa8/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8f16bfefbf50d991419cc11fe9a0e2122aa8/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=2eed8f16bfefbf50d991419cc11fe9a0e2122aa8", "patch": "@@ -88,6 +88,23 @@ package body Atree is\n       Table_Increment      => Alloc.Node_Offsets_Increment,\n       Table_Name           => \"Orig_Nodes\");\n \n+   ------------------\n+   -- Parent Stack --\n+   ------------------\n+\n+   --  A separate table is used to traverse trees. It passes the parent field\n+   --  of each node to the called process subprogram. It is defined global to\n+   --  avoid adding performance overhead if allocated each time the traversal\n+   --  functions are invoked.\n+\n+   package Parents_Stack is new Table.Table\n+     (Table_Component_Type => Node_Id,\n+      Table_Index_Type     => Nat,\n+      Table_Low_Bound      => 1,\n+      Table_Initial        => 256,\n+      Table_Increment      => 100,\n+      Table_Name           => \"Parents_Stack\");\n+\n    --------------------------\n    -- Paren_Count Handling --\n    --------------------------\n@@ -135,6 +152,20 @@ package body Atree is\n    --  Fix up parent pointers for the children of Fix_Node after a copy,\n    --  setting them to Fix_Node when they pointed to Ref_Node.\n \n+   generic\n+      with function Process\n+        (Parent_Node : Node_Id;\n+         Node        : Node_Id) return Traverse_Result is <>;\n+   function Internal_Traverse_With_Parent\n+     (Node : Node_Id) return Traverse_Final_Result;\n+   pragma Inline (Internal_Traverse_With_Parent);\n+   --  Internal function that provides a functionality similar to Traverse_Func\n+   --  but extended to pass the Parent node to the called Process subprogram;\n+   --  delegates to Traverse_Func_With_Parent the initialization of the stack\n+   --  data structure which stores the parent nodes (cf. Parents_Stack).\n+   --  ??? Could we factorize the common code of Internal_Traverse_Func and\n+   --  Traverse_Func?\n+\n    procedure Mark_New_Ghost_Node (N : Node_Or_Entity_Id);\n    --  Mark arbitrary node or entity N as Ghost when it is created within a\n    --  Ghost region.\n@@ -2322,6 +2353,167 @@ package body Atree is\n       return Size_In_Slots (N) - N_Head;\n    end Size_In_Slots_Dynamic;\n \n+   -----------------------------------\n+   -- Internal_Traverse_With_Parent --\n+   -----------------------------------\n+\n+   function Internal_Traverse_With_Parent\n+      (Node : Node_Id) return Traverse_Final_Result\n+   is\n+      Tail_Recursion_Counter : Natural := 0;\n+\n+      procedure Pop_Parents;\n+      --  Pop enclosing nodes of tail recursion plus the current parent.\n+\n+      function Traverse_Field (Fld : Union_Id) return Traverse_Final_Result;\n+      --  Fld is one of the Traversed fields of Nod, which is necessarily a\n+      --  Node_Id or List_Id. It is traversed, and the result is the result of\n+      --  this traversal.\n+\n+      -----------------\n+      -- Pop_Parents --\n+      -----------------\n+\n+      procedure Pop_Parents is\n+      begin\n+         --  Pop the enclosing nodes of the tail recursion\n+\n+         for J in 1 .. Tail_Recursion_Counter loop\n+            Parents_Stack.Decrement_Last;\n+         end loop;\n+\n+         --  Pop the current node\n+\n+         pragma Assert (Parents_Stack.Table (Parents_Stack.Last) = Node);\n+         Parents_Stack.Decrement_Last;\n+      end Pop_Parents;\n+\n+      --------------------\n+      -- Traverse_Field --\n+      --------------------\n+\n+      function Traverse_Field (Fld : Union_Id) return Traverse_Final_Result is\n+      begin\n+         if Fld /= Union_Id (Empty) then\n+\n+            --  Descendant is a node\n+\n+            if Fld in Node_Range then\n+               return Internal_Traverse_With_Parent (Node_Id (Fld));\n+\n+            --  Descendant is a list\n+\n+            elsif Fld in List_Range then\n+               declare\n+                  Elmt : Node_Id := First (List_Id (Fld));\n+               begin\n+                  while Present (Elmt) loop\n+                     if Internal_Traverse_With_Parent (Elmt) = Abandon then\n+                        return Abandon;\n+                     end if;\n+\n+                     Next (Elmt);\n+                  end loop;\n+               end;\n+\n+            else\n+               raise Program_Error;\n+            end if;\n+         end if;\n+\n+         return OK;\n+      end Traverse_Field;\n+\n+      --  Local variables\n+\n+      Parent_Node : Node_Id := Parents_Stack.Table (Parents_Stack.Last);\n+      Cur_Node    : Node_Id := Node;\n+\n+   --  Start of processing for Internal_Traverse_With_Parent\n+\n+   begin\n+      --  If the last field is a node, we eliminate the tail recursion by\n+      --  jumping back to this label. This is because concatenations are\n+      --  sometimes deeply nested, as in X1&X2&...&Xn. Gen_IL ensures that the\n+      --  Left_Opnd field of N_Op_Concat comes last in Traversed_Fields, so the\n+      --  tail recursion is eliminated in that case. This trick prevents us\n+      --  from running out of stack memory in that case. We don't bother\n+      --  eliminating the tail recursion if the last field is a list.\n+\n+      <<Tail_Recurse>>\n+\n+      Parents_Stack.Append (Cur_Node);\n+\n+      case Process (Parent_Node, Cur_Node) is\n+         when Abandon =>\n+            Pop_Parents;\n+            return Abandon;\n+\n+         when Skip =>\n+            Pop_Parents;\n+            return OK;\n+\n+         when OK =>\n+            null;\n+\n+         when OK_Orig =>\n+            Cur_Node := Original_Node (Cur_Node);\n+      end case;\n+\n+      --  Check for empty Traversed_Fields before entering loop below, so the\n+      --  tail recursive step won't go past the end.\n+\n+      declare\n+         Cur_Field : Offset_Array_Index := Traversed_Offset_Array'First;\n+         Offsets : Traversed_Offset_Array renames\n+           Traversed_Fields (Nkind (Cur_Node));\n+\n+      begin\n+         if Offsets (Traversed_Offset_Array'First) /= No_Field_Offset then\n+            while Offsets (Cur_Field + 1) /= No_Field_Offset loop\n+               declare\n+                  F : constant Union_Id :=\n+                    Get_Node_Field_Union (Cur_Node, Offsets (Cur_Field));\n+\n+               begin\n+                  if Traverse_Field (F) = Abandon then\n+                     Pop_Parents;\n+                     return Abandon;\n+                  end if;\n+               end;\n+\n+               Cur_Field := Cur_Field + 1;\n+            end loop;\n+\n+            declare\n+               F : constant Union_Id :=\n+                 Get_Node_Field_Union (Cur_Node, Offsets (Cur_Field));\n+\n+            begin\n+               if F not in Node_Range then\n+                  if Traverse_Field (F) = Abandon then\n+                     Pop_Parents;\n+                     return Abandon;\n+                  end if;\n+\n+               elsif F /= Empty_List_Or_Node then\n+                  --  Here is the tail recursion step, we reset Cur_Node and\n+                  --  jump back to the start of the procedure, which has the\n+                  --  same semantic effect as a call.\n+\n+                  Tail_Recursion_Counter := Tail_Recursion_Counter + 1;\n+                  Parent_Node := Cur_Node;\n+                  Cur_Node := Node_Id (F);\n+                  goto Tail_Recurse;\n+               end if;\n+            end;\n+         end if;\n+      end;\n+\n+      Pop_Parents;\n+      return OK;\n+   end Internal_Traverse_With_Parent;\n+\n    -------------------\n    -- Traverse_Func --\n    -------------------\n@@ -2454,6 +2646,32 @@ package body Atree is\n       return OK;\n    end Traverse_Func;\n \n+   -------------------------------\n+   -- Traverse_Func_With_Parent --\n+   -------------------------------\n+\n+   function Traverse_Func_With_Parent\n+     (Node : Node_Id) return Traverse_Final_Result\n+   is\n+      function Traverse is new Internal_Traverse_With_Parent (Process);\n+      Result : Traverse_Final_Result;\n+   begin\n+      --  Ensure that the Parents stack is not currently in use; required since\n+      --  it is global and hence a tree traversal with parents must be finished\n+      --  before the next tree traversal with parents starts.\n+\n+      pragma Assert (Parents_Stack.Last = 0);\n+      Parents_Stack.Set_Last (0);\n+\n+      Parents_Stack.Append (Parent (Node));\n+      Result := Traverse (Node);\n+      Parents_Stack.Decrement_Last;\n+\n+      pragma Assert (Parents_Stack.Last = 0);\n+\n+      return Result;\n+   end Traverse_Func_With_Parent;\n+\n    -------------------\n    -- Traverse_Proc --\n    -------------------\n@@ -2466,6 +2684,18 @@ package body Atree is\n       Discard := Traverse (Node);\n    end Traverse_Proc;\n \n+   -------------------------------\n+   -- Traverse_Proc_With_Parent --\n+   -------------------------------\n+\n+   procedure Traverse_Proc_With_Parent (Node : Node_Id) is\n+      function Traverse is new Traverse_Func_With_Parent (Process);\n+      Discard : Traverse_Final_Result;\n+      pragma Warnings (Off, Discard);\n+   begin\n+      Discard := Traverse (Node);\n+   end Traverse_Proc_With_Parent;\n+\n    ------------\n    -- Unlock --\n    ------------"}, {"sha": "90980e26b540e846287b300de070e22bc948b2c8", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8f16bfefbf50d991419cc11fe9a0e2122aa8/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8f16bfefbf50d991419cc11fe9a0e2122aa8/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=2eed8f16bfefbf50d991419cc11fe9a0e2122aa8", "patch": "@@ -409,13 +409,32 @@ package Atree is\n    --  by a call to Process returning Abandon, otherwise it is OK (meaning that\n    --  all calls to process returned either OK, OK_Orig, or Skip).\n \n+   generic\n+      with function Process\n+        (Parent_Node : Node_Id;\n+         Node        : Node_Id) return Traverse_Result is <>;\n+   function Traverse_Func_With_Parent\n+     (Node : Node_Id) return Traverse_Final_Result;\n+   pragma Inline (Traverse_Func_With_Parent);\n+   --  Same as Traverse_Func except that the called function Process receives\n+   --  also the Parent_Node of Node.\n+\n    generic\n       with function Process (N : Node_Id) return Traverse_Result is <>;\n    procedure Traverse_Proc (Node : Node_Id);\n    pragma Inline (Traverse_Proc);\n    --  This is the same as Traverse_Func except that no result is returned,\n    --  i.e. Traverse_Func is called and the result is simply discarded.\n \n+   generic\n+      with function Process\n+        (Parent_Node : Node_Id;\n+         Node        : Node_Id) return Traverse_Result is <>;\n+   procedure Traverse_Proc_With_Parent (Node : Node_Id);\n+   pragma Inline (Traverse_Proc_With_Parent);\n+   --  Same as Traverse_Proc except that the called function Process receives\n+   --  also the Parent_Node of Node.\n+\n    ---------------------------\n    -- Node Access Functions --\n    ---------------------------"}, {"sha": "24bd568cd54163b271e14c6ad26014306e73d840", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 142, "deletions": 12, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8f16bfefbf50d991419cc11fe9a0e2122aa8/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8f16bfefbf50d991419cc11fe9a0e2122aa8/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=2eed8f16bfefbf50d991419cc11fe9a0e2122aa8", "patch": "@@ -4323,9 +4323,55 @@ package body Contracts is\n          -----------------------------------------\n \n          procedure Restore_Original_Selected_Component is\n+            Restored_Nodes_List : Elist_Id := No_Elist;\n+\n+            procedure Fix_Parents (N : Node_Id);\n+            --  Traverse the subtree of N fixing the Parent field of all the\n+            --  nodes.\n \n             function Restore_Node (N : Node_Id) return Traverse_Result;\n-            --  Process a single node\n+            --  Process dispatching calls to functions whose original node was\n+            --  a selected component, and replace them with their original\n+            --  node. Restored nodes are stored in the Restored_Nodes_List\n+            --  to fix the parent fields of their subtrees in a separate\n+            --  tree traversal.\n+\n+            -----------------\n+            -- Fix_Parents --\n+            -----------------\n+\n+            procedure Fix_Parents (N : Node_Id) is\n+\n+               function Fix_Parent\n+                 (Parent_Node : Node_Id;\n+                  Node        : Node_Id) return Traverse_Result;\n+               --  Process a single node\n+\n+               ----------------\n+               -- Fix_Parent --\n+               ----------------\n+\n+               function Fix_Parent\n+                 (Parent_Node : Node_Id;\n+                  Node        : Node_Id) return Traverse_Result\n+               is\n+                  Par : constant Node_Id := Parent (Node);\n+\n+               begin\n+                  if Par /= Parent_Node then\n+                     pragma Assert (not Is_List_Member (Node));\n+                     Set_Parent (Node, Parent_Node);\n+                  end if;\n+\n+                  return OK;\n+               end Fix_Parent;\n+\n+               procedure Fix_Parents is\n+                  new Traverse_Proc_With_Parent (Fix_Parent);\n+\n+            begin\n+               Fix_Parents (N);\n+            end Fix_Parents;\n \n             ------------------\n             -- Restore_Node --\n@@ -4340,22 +4386,41 @@ package body Contracts is\n                   Rewrite (N, Original_Node (N));\n                   Set_Original_Node (N, N);\n \n-                  --  Restore decoration of its child nodes; required to ensure\n-                  --  proper copies of this subtree (if required) by subsequent\n-                  --  calls to New_Copy_Tree (since otherwise these child nodes\n-                  --  are not duplicated).\n+                  --  Save the restored node in the Restored_Nodes_List to fix\n+                  --  the parent fields of their subtrees in a separate tree\n+                  --  traversal.\n \n-                  Set_Parent (Prefix (N), N);\n-                  Set_Parent (Selector_Name (N), N);\n+                  Append_New_Elmt (N, Restored_Nodes_List);\n                end if;\n \n                return OK;\n             end Restore_Node;\n \n             procedure Restore_Nodes is new Traverse_Proc (Restore_Node);\n \n+         --  Start of processing for Restore_Original_Selected_Component\n+\n          begin\n             Restore_Nodes (Expr);\n+\n+            --  After restoring the original node we must fix the decoration\n+            --  of the Parent attribute to ensure tree consistency; required\n+            --  because when the class-wide condition is inherited, calls to\n+            --  New_Copy_Tree will perform copies of this subtree, and formal\n+            --  occurrences with wrong Parent field cannot be mapped to the\n+            --  new formals.\n+\n+            if Present (Restored_Nodes_List) then\n+               declare\n+                  Elmt : Elmt_Id := First_Elmt (Restored_Nodes_List);\n+\n+               begin\n+                  while Present (Elmt) loop\n+                     Fix_Parents (Node (Elmt));\n+                     Next_Elmt (Elmt);\n+                  end loop;\n+               end;\n+            end if;\n          end Restore_Original_Selected_Component;\n \n       --  Start of processing for Preanalyze_Condition\n@@ -4428,11 +4493,60 @@ package body Contracts is\n            (Par_Subp : Entity_Id;\n             Subp     : Entity_Id) return Node_Id\n          is\n+            function Check_Condition (Expr : Node_Id) return Boolean;\n+            --  Used in assertion to check that Expr has no reference to the\n+            --  formals of Par_Subp.\n+\n+            ---------------------\n+            -- Check_Condition --\n+            ---------------------\n+\n+            function Check_Condition (Expr : Node_Id) return Boolean is\n+               Par_Formal_Id : Entity_Id;\n+\n+               function Check_Entity (N : Node_Id) return Traverse_Result;\n+               --  Check occurrence of Par_Formal_Id\n+\n+               ------------------\n+               -- Check_Entity --\n+               ------------------\n+\n+               function Check_Entity (N : Node_Id) return Traverse_Result is\n+               begin\n+                  if Nkind (N) = N_Identifier\n+                    and then Present (Entity (N))\n+                    and then Entity (N) = Par_Formal_Id\n+                  then\n+                     return Abandon;\n+                  end if;\n+\n+                  return OK;\n+               end Check_Entity;\n+\n+               function Check_Expression is new Traverse_Func (Check_Entity);\n+\n+            --  Start of processing for Check_Condition\n+\n+            begin\n+               Par_Formal_Id := First_Formal (Par_Subp);\n+\n+               while Present (Par_Formal_Id) loop\n+                  if Check_Expression (Expr) = Abandon then\n+                     return False;\n+                  end if;\n+\n+                  Next_Formal (Par_Formal_Id);\n+               end loop;\n+\n+               return True;\n+            end Check_Condition;\n+\n+            --  Local variables\n+\n             Assoc_List     : constant Elist_Id := New_Elmt_List;\n             Par_Formal_Id  : Entity_Id := First_Formal (Par_Subp);\n             Subp_Formal_Id : Entity_Id := First_Formal (Subp);\n-\n-         --  Start of processing for Inherit_Condition\n+            New_Condition  : Node_Id;\n \n          begin\n             while Present (Par_Formal_Id) loop\n@@ -4443,9 +4557,25 @@ package body Contracts is\n                Next_Formal (Subp_Formal_Id);\n             end loop;\n \n-            return New_Copy_Tree\n-                     (Source => Class_Condition (Kind, Par_Subp),\n-                      Map    => Assoc_List);\n+            --  Check that Parent field of all the nodes have their correct\n+            --  decoration; required because otherwise mapped nodes with\n+            --  wrong Parent field are left unmodified in the copied tree\n+            --  and cause reporting wrong errors at later stages.\n+\n+            pragma Assert\n+              (Check_Parents (Class_Condition (Kind, Par_Subp), Assoc_List));\n+\n+            New_Condition :=\n+              New_Copy_Tree\n+                (Source => Class_Condition (Kind, Par_Subp),\n+                 Map    => Assoc_List);\n+\n+            --  Ensure that the inherited condition has no reference to the\n+            --  formals of the parent subprogram.\n+\n+            pragma Assert (Check_Condition (New_Condition));\n+\n+            return New_Condition;\n          end Inherit_Condition;\n \n          ----------------------"}, {"sha": "bf3d6c032c987056d61dfa839dcf5daae6f675c4", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8f16bfefbf50d991419cc11fe9a0e2122aa8/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8f16bfefbf50d991419cc11fe9a0e2122aa8/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=2eed8f16bfefbf50d991419cc11fe9a0e2122aa8", "patch": "@@ -4443,6 +4443,44 @@ package body Sem_Util is\n       end if;\n    end Check_Nonvolatile_Function_Profile;\n \n+   -------------------\n+   -- Check_Parents --\n+   -------------------\n+\n+   function Check_Parents (N : Node_Id; List : Elist_Id) return Boolean is\n+\n+      function Check_Node\n+        (Parent_Node : Node_Id;\n+         N           : Node_Id) return Traverse_Result;\n+      --  Process a single node.\n+\n+      ----------------\n+      -- Check_Node --\n+      ----------------\n+\n+      function Check_Node\n+        (Parent_Node : Node_Id;\n+         N           : Node_Id) return Traverse_Result is\n+      begin\n+         if Nkind (N) = N_Identifier\n+           and then Parent (N) /= Parent_Node\n+           and then Present (Entity (N))\n+           and then Contains (List, Entity (N))\n+         then\n+            return Abandon;\n+         end if;\n+\n+         return OK;\n+      end Check_Node;\n+\n+      function Traverse is new Traverse_Func_With_Parent (Check_Node);\n+\n+   --  Start of processing for Check_Parents\n+\n+   begin\n+      return Traverse (N) = OK;\n+   end Check_Parents;\n+\n    -----------------------------\n    -- Check_Part_Of_Reference --\n    -----------------------------"}, {"sha": "a9f80b9979a3ccd36bdfe9744905a88d776fc8f3", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eed8f16bfefbf50d991419cc11fe9a0e2122aa8/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eed8f16bfefbf50d991419cc11fe9a0e2122aa8/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=2eed8f16bfefbf50d991419cc11fe9a0e2122aa8", "patch": "@@ -448,6 +448,10 @@ package Sem_Util is\n    --  Verify that the profile of nonvolatile function Func_Id does not contain\n    --  effectively volatile parameters or return type for reading.\n \n+   function Check_Parents (N : Node_Id; List : Elist_Id) return Boolean;\n+   --  Return True if all the occurrences of subtree N referencing entities in\n+   --  the given List have the right value in their Parent field.\n+\n    procedure Check_Part_Of_Reference (Var_Id : Entity_Id; Ref : Node_Id);\n    --  Verify the legality of reference Ref to variable Var_Id when the\n    --  variable is a constituent of a single protected/task type."}]}