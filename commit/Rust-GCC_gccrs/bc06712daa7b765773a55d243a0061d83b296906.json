{"sha": "bc06712daa7b765773a55d243a0061d83b296906", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmMwNjcxMmRhYTdiNzY1NzczYTU1ZDI0M2EwMDYxZDgzYjI5NjkwNg==", "commit": {"author": {"name": "Tom Rix", "email": "trix@redhat.com", "date": "2002-01-13T04:43:55Z"}, "committer": {"name": "Tom Rix", "email": "trix@gcc.gnu.org", "date": "2002-01-13T04:43:55Z"}, "message": "Use ior for loading constant\n\nFrom-SVN: r48810", "tree": {"sha": "32e0cec4ffb87a5aacbbc28a3346cdb0408677c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32e0cec4ffb87a5aacbbc28a3346cdb0408677c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc06712daa7b765773a55d243a0061d83b296906", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc06712daa7b765773a55d243a0061d83b296906", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc06712daa7b765773a55d243a0061d83b296906", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc06712daa7b765773a55d243a0061d83b296906/comments", "author": {"login": "trixirt", "id": 7824193, "node_id": "MDQ6VXNlcjc4MjQxOTM=", "avatar_url": "https://avatars.githubusercontent.com/u/7824193?v=4", "gravatar_id": "", "url": "https://api.github.com/users/trixirt", "html_url": "https://github.com/trixirt", "followers_url": "https://api.github.com/users/trixirt/followers", "following_url": "https://api.github.com/users/trixirt/following{/other_user}", "gists_url": "https://api.github.com/users/trixirt/gists{/gist_id}", "starred_url": "https://api.github.com/users/trixirt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/trixirt/subscriptions", "organizations_url": "https://api.github.com/users/trixirt/orgs", "repos_url": "https://api.github.com/users/trixirt/repos", "events_url": "https://api.github.com/users/trixirt/events{/privacy}", "received_events_url": "https://api.github.com/users/trixirt/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ae72572be948907827c02a4f20e92dcff0f92b29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae72572be948907827c02a4f20e92dcff0f92b29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae72572be948907827c02a4f20e92dcff0f92b29"}], "stats": {"total": 127, "additions": 58, "deletions": 69}, "files": [{"sha": "88782fb2aa78064a02377faa511916015502c0bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc06712daa7b765773a55d243a0061d83b296906/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc06712daa7b765773a55d243a0061d83b296906/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc06712daa7b765773a55d243a0061d83b296906", "patch": "@@ -1,3 +1,8 @@\n+2002-01-12  Tom Rix  <trix@redhat.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_emit_set_long_const): Use ior for \n+\tTARGET_POWERPC64.\n+\n 2002-01-12  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386.c (bdesc_2arg): Mark psadbw MASK_3DNOW_A."}, {"sha": "81e358b52a286c479d94dacc29b0756a18896932", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 53, "deletions": 69, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc06712daa7b765773a55d243a0061d83b296906/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc06712daa7b765773a55d243a0061d83b296906/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=bc06712daa7b765773a55d243a0061d83b296906", "patch": "@@ -2003,86 +2003,70 @@ rs6000_emit_set_long_const (dest, c1, c2)\n     }\n   else\n     {\n-      HOST_WIDE_INT d1, d2, d2_s, d3, d4;\n+      HOST_WIDE_INT ud1, ud2, ud3, ud4;\n \n-      /* This function is called by rs6000_emit_allocate_stack after reload \n-\t with a dest of r0.  r0 is an invalid register for addsi.  Use an addi \n-\t and a shift instead.  */\n-      int regnum = REGNO (dest);\n-\n-  /* Decompose the entire word */\n+      ud1 = c1 & 0xffff;\n+      ud2 = (c1 & 0xffff0000) >> 16;\n #if HOST_BITS_PER_WIDE_INT >= 64\n-      if (c2 != -(c1 < 0))\n-\tabort ();\n-      d1 = ((c1 & 0xffff) ^ 0x8000) - 0x8000;\n-      c1 -= d1;\n-      d2 = ((c1 & 0xffffffff) ^ 0x80000000) - 0x80000000;\n-      d2_s = d2 >> 16;\n-      c1 = (c1 - d2) >> 32;\n-      d3 = ((c1 & 0xffff) ^ 0x8000) - 0x8000;\n-      c1 -= d3;\n-      d4 = ((c1 & 0xffffffff) ^ 0x80000000) - 0x80000000;\n-      if (c1 != d4)\n-\tabort ();\n-#else\n-      d1 = ((c1 & 0xffff) ^ 0x8000) - 0x8000;\n-      c1 -= d1;\n-      d2 = ((c1 & 0xffffffff) ^ 0x80000000) - 0x80000000;\n-      d2_s = d2 >> 16;\n-      if (c1 != d2)\n-\tabort ();\n-      c2 += (d2 < 0);\n-      d3 = ((c2 & 0xffff) ^ 0x8000) - 0x8000;\n-      c2 -= d3;\n-      d4 = ((c2 & 0xffffffff) ^ 0x80000000) - 0x80000000;\n-      if (c2 != d4)\n-\tabort ();\n+      c2 = c1 >> 32;\n #endif\n+      ud3 = c2 & 0xffff;\n+      ud4 = (c2 & 0xffff0000) >> 16;\n \n-      /* Construct the high word */\n-      if (d4 != 0)\n+      if ((ud4 == 0xffff && ud3 == 0xffff && ud2 == 0xffff && (ud1 & 0x8000)) \n+\t  || (ud4 == 0 && ud3 == 0 && ud2 == 0 && ! (ud1 & 0x8000)))\n \t{\n-\t  emit_move_insn (dest, GEN_INT (d4));\n-\t  if (d3 != 0)\n-\t    emit_move_insn (dest,\n-\t\t\t    gen_rtx_PLUS (DImode, dest, GEN_INT (d3)));\n+\t  if (ud1 & 0x8000)\n+\t    emit_move_insn (dest, GEN_INT (((ud1  ^ 0x8000) -  0x8000)));\n+\t  else\n+\t    emit_move_insn (dest, GEN_INT (ud1));\n \t}\n-      else if (d3 != 0)\n-\temit_move_insn (dest, GEN_INT (d3));\n-\n-      /* Shift it into place */\n-      if (d3 != 0 || d4 != 0)\n- \tif (regnum == 0 && d2 != 0) \n- \t  emit_move_insn (dest, gen_rtx_ASHIFT (DImode, dest, GEN_INT (16)));\n- \telse \n-\t  emit_move_insn (dest, gen_rtx_ASHIFT (DImode, dest, GEN_INT (32)));\n \n-      /* Add in the low bits.  */\n-      if (d2 != 0)\n+      else if ((ud4 == 0xffff && ud3 == 0xffff && (ud2 & 0x8000)) \n+\t       || (ud4 == 0 && ud3 == 0 && ! (ud2 & 0x8000)))\n \t{\n-\t  if (d3 != 0 || d4 != 0)\n-\t    {\n-\t      if (regnum == 0)\n-\t\t{\n-\t\t  emit_move_insn (dest, gen_rtx_PLUS (DImode, dest, \n-\t\t\t\t\t\t      GEN_INT (d2_s)));\n-\t\t  emit_move_insn (dest, gen_rtx_ASHIFT (DImode, dest,  \n-\t\t\t\t\t\t\tGEN_INT (16)));\n-\t\t}\n-\t      else\n-\t\temit_move_insn (dest, gen_rtx_PLUS (DImode, dest, \n-\t\t\t\t\t\t    GEN_INT (d2)));\n-\t    }\n+\t  if (ud2 & 0x8000)\n+\t    emit_move_insn (dest, GEN_INT (((ud2 << 16) ^ 0x80000000) \n+\t\t\t\t\t   - 0x80000000));\n \t  else\n-\t    emit_move_insn (dest, GEN_INT (d2));\n+\t    emit_move_insn (dest, GEN_INT (ud2 << 16));\n+\t  if (ud1 != 0)\n+\t    emit_move_insn (dest, gen_rtx_IOR (DImode, dest, GEN_INT (ud1)));\n \t}\n-      if (d1 != 0)\n-\tif (d2 != 0 || d3 != 0 || d4 != 0)\n-\t  emit_move_insn (dest, gen_rtx_PLUS (DImode, dest, GEN_INT (d1)));\n-\telse\n-\t  emit_move_insn (dest, GEN_INT (d1));\n-    }\n+      else if ((ud4 == 0xffff && (ud3 & 0x8000)) \n+\t       || (ud4 == 0 && ! (ud3 & 0x8000)))\n+\t{\n+\t  if (ud3 & 0x8000)\n+\t    emit_move_insn (dest, GEN_INT (((ud3 << 16) ^ 0x80000000) \n+\t\t\t\t\t   - 0x80000000));\n+\t  else\n+\t    emit_move_insn (dest, GEN_INT (ud3 << 16));\n+\n+\t  if (ud2 != 0)\n+\t    emit_move_insn (dest, gen_rtx_IOR (DImode, dest, GEN_INT (ud2)));\n+\t  emit_move_insn (dest, gen_rtx_ASHIFT (DImode, dest, GEN_INT (16)));\n+\t  if (ud1 != 0)\n+\t    emit_move_insn (dest, gen_rtx_IOR (DImode, dest, GEN_INT (ud1)));\n+\t}\n+      else \n+\t{\n+\t  if (ud4 & 0x8000)\n+\t    emit_move_insn (dest, GEN_INT (((ud4 << 16) ^ 0x80000000) \n+\t\t\t\t\t   - 0x80000000));\n+\t  else\n+\t    emit_move_insn (dest, GEN_INT (ud4 << 16));\n+\n+\t  if (ud3 != 0)\n+\t    emit_move_insn (dest, gen_rtx_IOR (DImode, dest, GEN_INT (ud3)));\n \n+\t  emit_move_insn (dest, gen_rtx_ASHIFT (DImode, dest, GEN_INT (32)));\n+\t  if (ud2 != 0)\n+\t    emit_move_insn (dest, gen_rtx_IOR (DImode, dest, \n+\t\t\t\t\t       GEN_INT (ud2 << 16)));\t\n+\t  if (ud1 != 0)\n+\t    emit_move_insn (dest, gen_rtx_IOR (DImode, dest, GEN_INT (ud1)));\n+\t}\n+    }\n   return dest;\n }\n "}]}