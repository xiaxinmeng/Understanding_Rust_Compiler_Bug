{"sha": "7a0347fff32015826a7da2704442a80979f43e10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2EwMzQ3ZmZmMzIwMTU4MjZhN2RhMjcwNDQ0MmE4MDk3OWY0M2UxMA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-10-06T00:23:17Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-10-06T00:23:17Z"}, "message": "(shadow_tag_warned): Use pedwarn for useless keyword.\n\n(pushdecl): Internally generated vars can be\ndetected with DECL_SOURCE_LINE of zero, not DECL_IGNORED_P.\n\n(start_enum): Push obstacks, switch to permanent if global.\n(finish_enum): Pop obstacks.\n(store_parm_decls): When clearing ->names, clear out the values\nfrom the identifiers, restore shadowed values, and clear ->shadowed.\n\n(grokdeclarator): Don't warn of const or volatile function\nin a system header file.\n(start_struct): Push the obstacks.\nSwitch to permanent if at top level.\n(finish_struct): Pop them.\n\n(store_parm_decls): If we have (erroneously) a prototype\nand old-style parm decls, throw away the old-style parm decls.\n(finish_decl): Do the pop_obstacks sooner, when it's\ntime to start allocating in the ambient context's obstack.\nDon't call permanent_allocation unless got back to permanent obstack.\n\n(explicit_flag_signed_bitfields): New variable.\n(c_decode_option): Set that for -f[un]signed-bitfields.\n(grokdeclarator): If that's set, and -fsigned-bitfields,\ndisregard -traditional when handling bitfield signedness.\n\nFrom-SVN: r2332", "tree": {"sha": "c13cf491e7e5df55cdbd0f9b4be624ee8a4441df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c13cf491e7e5df55cdbd0f9b4be624ee8a4441df"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a0347fff32015826a7da2704442a80979f43e10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a0347fff32015826a7da2704442a80979f43e10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a0347fff32015826a7da2704442a80979f43e10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a0347fff32015826a7da2704442a80979f43e10/comments", "author": null, "committer": null, "parents": [{"sha": "ed7601742bab10559e7a8e0db37b8afb096d8576", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed7601742bab10559e7a8e0db37b8afb096d8576", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed7601742bab10559e7a8e0db37b8afb096d8576"}], "stats": {"total": 102, "additions": 76, "deletions": 26}, "files": [{"sha": "5e8fd4320b5f20504fd14cd2ba84b8ed88d6e123", "filename": "gcc/c-decl.c", "status": "modified", "additions": 76, "deletions": 26, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a0347fff32015826a7da2704442a80979f43e10/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a0347fff32015826a7da2704442a80979f43e10/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=7a0347fff32015826a7da2704442a80979f43e10", "patch": "@@ -428,6 +428,7 @@ int flag_traditional;\n /* Nonzero means to treat bitfields as signed unless they say `unsigned'.  */\n \n int flag_signed_bitfields = 1;\n+int explicit_flag_signed_bitfields = 0;\n \n /* Nonzero means handle `#ident' directives.  0 means ignore them.  */\n \n@@ -536,14 +537,18 @@ c_decode_option (p)\n     flag_signed_char = 0;\n   else if (!strcmp (p, \"-fno-unsigned-char\"))\n     flag_signed_char = 1;\n-  else if (!strcmp (p, \"-fsigned-bitfields\"))\n-    flag_signed_bitfields = 1;\n-  else if (!strcmp (p, \"-funsigned-bitfields\"))\n-    flag_signed_bitfields = 0;\n-  else if (!strcmp (p, \"-fno-signed-bitfields\"))\n-    flag_signed_bitfields = 0;\n-  else if (!strcmp (p, \"-fno-unsigned-bitfields\"))\n-    flag_signed_bitfields = 1;\n+  else if (!strcmp (p, \"-fsigned-bitfields\")\n+\t   || !strcmp (p, \"-fno-unsigned-bitfields\"))\n+    {\n+      flag_signed_bitfields = 1;\n+      explicit_flag_signed_bitfields = 1;\n+    }\n+  else if (!strcmp (p, \"-funsigned-bitfields\")\n+\t   || !strcmp (p, \"-fno-signed-bitfields\"))\n+    {\n+      flag_signed_bitfields = 0;\n+      explicit_flag_signed_bitfields = 1;\n+    }\n   else if (!strcmp (p, \"-fshort-enums\"))\n     flag_short_enums = 1;\n   else if (!strcmp (p, \"-fno-short-enums\"))\n@@ -2016,7 +2021,7 @@ pushdecl (x)\n \t  /* Maybe warn if shadowing something else.  */\n \t  else if (warn_shadow && !DECL_EXTERNAL (x)\n \t\t   /* No shadow warnings for internally generated vars.  */\n-\t\t   && !DECL_IGNORED_P (x)\n+\t\t   && DECL_SOURCE_LINE (x) != 0\n \t\t   /* No shadow warnings for vars made for inlining.  */\n \t\t   && ! DECL_FROM_INLINE (x))\n \t    {\n@@ -2487,10 +2492,10 @@ init_decl_processing ()\n   /* Define `char', which is like either `signed char' or `unsigned char'\n      but not the same as either.  */\n \n-  char_type_node =\n-    (flag_signed_char\n-     ? make_signed_type (CHAR_TYPE_SIZE)\n-     : make_unsigned_type (CHAR_TYPE_SIZE));\n+  char_type_node\n+    = (flag_signed_char\n+       ? make_signed_type (CHAR_TYPE_SIZE)\n+       : make_unsigned_type (CHAR_TYPE_SIZE));\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"char\"),\n \t\t\tchar_type_node));\n \n@@ -2982,7 +2987,7 @@ shadow_tag_warned (declspecs, warned)\n       else\n \t{\n \t  if (!warned)\n-\t    warning (\"useless keyword or type name in empty declaration\");\n+\t    pedwarn (\"useless keyword or type name in empty declaration\");\n \t  warned = 1;\n \t}\n     }\n@@ -3205,13 +3210,15 @@ finish_decl (decl, init, asmspec_tree)\n \t}\n     }\n \n-  /* For top-level declaration, the initial value was read in\n-     the temporary obstack.  MAXINDEX, rtl, etc. to be made below\n-     must go in the permanent obstack; but don't discard the\n+  /* Pop back to the obstack that is current for this binding level.\n+     This is because MAXINDEX, rtl, etc. to be made below\n+     must go in the permanent obstack.  But don't discard the\n      temporary data yet.  */\n-\n+  pop_obstacks ();\n+#if 0 /* pop_obstacks was near the end; this is what was here.  */\n   if (current_binding_level == global_binding_level && temporary)\n     end_temporary_allocation ();\n+#endif\n \n   /* Deduce size of array from initialization, if not already known */\n \n@@ -3338,12 +3345,16 @@ finish_decl (decl, init, asmspec_tree)\n \tDECL_INITIAL (decl) = error_mark_node;\n     }\n \n+#if 0\n   /* Resume permanent allocation, if not within a function.  */\n   /* The corresponding push_obstacks_nochange is in start_decl,\n      and in push_parm_decl and in grokfield.  */\n   pop_obstacks ();\n-  if (current_binding_level == global_binding_level && temporary)\n-    /* Actually free the temporary space that we no longer need.  */\n+#endif\n+\n+  /* If we have gone back from temporary to permanent allocation,\n+     actually free the temporary space that we no longer need.  */\n+  if (temporary && !allocation_temporary_p ())\n     permanent_allocation ();\n \n   /* At the end of a declaration, throw away any variable type sizes\n@@ -3729,7 +3740,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n      Optionally treat bitfields as signed by default.  */\n   if (specbits & 1 << (int) RID_UNSIGNED\n       /* Traditionally, all bitfields are unsigned.  */\n-      || (bitfield && flag_traditional)\n+      || (bitfield && flag_traditional\n+\t  && (! explicit_flag_signed_bitfields || !flag_signed_bitfields))\n       || (bitfield && ! flag_signed_bitfields\n \t  && (explicit_int || explicit_char\n \t      /* A typedef for plain `int' without `signed'\n@@ -4279,7 +4291,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \n \tdecl = build_decl (FUNCTION_DECL, declarator, type);\n \n-\tif (pedantic && (constp || volatilep))\n+\tif (pedantic && (constp || volatilep)\n+\t    && ! DECL_IN_SYSTEM_HEADER (decl))\n \t  pedwarn (\"ANSI C forbids const or volatile functions\");\n \n \tif (extern_ref)\n@@ -4706,7 +4719,10 @@ xref_tag (code, name)\n \f\n /* Make sure that the tag NAME is defined *in the current binding level*\n    at least as a forward reference.\n-   CODE says which kind of tag NAME ought to be.  */\n+   CODE says which kind of tag NAME ought to be.\n+\n+   We also do a push_obstacks_nochange\n+   whose matching pop is in finish_struct.  */\n \n tree\n start_struct (code, name)\n@@ -4718,6 +4734,10 @@ start_struct (code, name)\n \n   register tree ref = 0;\n \n+  push_obstacks_nochange ();\n+  if (current_binding_level == global_binding_level)\n+    end_temporary_allocation ();\n+\n   if (name != 0)\n     ref = lookup_tag (code, name, current_binding_level, 1);\n   if (ref && TREE_CODE (ref) == code)\n@@ -4776,7 +4796,9 @@ field_decl_cmp (x, y)\n }\n \n /* Fill in the fields of a RECORD_TYPE or UNION_TYPE node, T.\n-   FIELDLIST is a chain of FIELD_DECL nodes for the fields.  */\n+   FIELDLIST is a chain of FIELD_DECL nodes for the fields.\n+\n+   We also do a pop_obstacks to match the push in start_struct.  */\n \n tree\n finish_struct (t, fieldlist)\n@@ -5074,6 +5096,9 @@ finish_struct (t, fieldlist)\n   /* Finish debugging output for this type.  */\n   rest_of_type_compilation (t, toplevel);\n \n+  /* The matching push is in start_struct.  */\n+  pop_obstacks ();\n+\n   return t;\n }\n \n@@ -5107,6 +5132,12 @@ start_enum (name)\n   if (name != 0)\n     enumtype = lookup_tag (ENUMERAL_TYPE, name, current_binding_level, 1);\n \n+  /* The corresponding pop_obstacks is in finish_enum.  */\n+  push_obstacks_nochange ();\n+  /* If these symbols and types are global, make them permanent.  */\n+  if (current_binding_level == global_binding_level)\n+    end_temporary_allocation ();\n+\n   if (enumtype == 0 || TREE_CODE (enumtype) != ENUMERAL_TYPE)\n     {\n       enumtype = make_node (ENUMERAL_TYPE);\n@@ -5147,6 +5178,7 @@ finish_enum (enumtype, values)\n   register int i;\n   unsigned precision = 0;\n   int toplevel = global_binding_level == current_binding_level;\n+  int temporary = allocation_temporary_p ();\n \n   if (in_parm_level_p ())\n     warning (\"enum defined inside parms\");\n@@ -5232,6 +5264,9 @@ finish_enum (enumtype, values)\n   /* Finish debugging output for this type.  */\n   rest_of_type_compilation (enumtype, toplevel);\n \n+  /* This matches a push in start_enum.  */\n+  pop_obstacks ();\n+\n   return enumtype;\n }\n \n@@ -5486,8 +5521,23 @@ store_parm_decls ()\n       prototype = 1;\n \n       if (parmdecls != 0)\n-\terror_with_decl (fndecl,\n-\t\t\t \"parm types given both in parmlist and separately\");\n+\t{\n+\t  tree decl, link;\n+\n+\t  error_with_decl (fndecl,\n+\t\t\t   \"parm types given both in parmlist and separately\");\n+\t  /* Get rid of the erroneous decls; don't keep them on\n+\t     the list of parms, since they might not be PARM_DECLs.  */\n+\t  for (decl = current_binding_level->names;\n+\t       decl; decl = TREE_CHAIN (decl))\n+\t    if (DECL_NAME (decl))\n+\t      IDENTIFIER_LOCAL_VALUE (DECL_NAME (decl)) = 0;\n+\t  for (link = current_binding_level->shadowed;\n+\t       link; link = TREE_CHAIN (link))\n+\t    IDENTIFIER_LOCAL_VALUE (TREE_PURPOSE (link)) = TREE_VALUE (link);\n+\t  current_binding_level->names = 0;\n+\t  current_binding_level->shadowed = 0;\n+\t}\n \n       specparms = nreverse (specparms);\n       for (parm = specparms; parm; parm = next)"}]}