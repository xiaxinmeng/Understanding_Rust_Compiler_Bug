{"sha": "d0a5624bb40470cb0ee03fe86530118ca6de0b3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBhNTYyNGJiNDA0NzBjYjBlZTAzZmU4NjUzMDExOGNhNmRlMGIzYQ==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2021-07-26T01:52:08Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2021-08-05T08:44:20Z"}, "message": "cfgloop: Make loops_list support an optional loop_p root\n\nThis patch follows Richi's suggestion to add one optional\nargument class loop* root to loops_list's CTOR, it can\nprovide the ability to construct a visiting list starting\nfrom the given class loop* ROOT rather than the default\ntree_root of loops_for_fn (FN), for visiting a subset of\nthe loop tree.\n\nIt unifies all orders of walkings into walk_loop_tree, but\nit still uses linear search for LI_ONLY_INNERMOST when\nlooking at the whole loop tree since it has a more stable\nbound.\n\ngcc/ChangeLog:\n\n\t* cfgloop.h (loops_list::loops_list): Add one optional argument\n\troot and adjust accordingly, update loop tree walking and factor\n\tout to ...\n\t* cfgloop.c (loops_list::walk_loop_tree): ... this.  New function.", "tree": {"sha": "876feb4d59f64933f2dd59e335a6d85555fe50ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/876feb4d59f64933f2dd59e335a6d85555fe50ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0a5624bb40470cb0ee03fe86530118ca6de0b3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0a5624bb40470cb0ee03fe86530118ca6de0b3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0a5624bb40470cb0ee03fe86530118ca6de0b3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0a5624bb40470cb0ee03fe86530118ca6de0b3a/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e3129b0caceec008a940aa5eada253cd0f0b3ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e3129b0caceec008a940aa5eada253cd0f0b3ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e3129b0caceec008a940aa5eada253cd0f0b3ec"}], "stats": {"total": 166, "additions": 106, "deletions": 60}, "files": [{"sha": "2ba9918bfa2a1070925df67afdcf0dd72c8dac58", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a5624bb40470cb0ee03fe86530118ca6de0b3a/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a5624bb40470cb0ee03fe86530118ca6de0b3a/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=d0a5624bb40470cb0ee03fe86530118ca6de0b3a", "patch": "@@ -2104,3 +2104,69 @@ mark_loop_for_removal (loop_p loop)\n   loop->latch = NULL;\n   loops_state_set (LOOPS_NEED_FIXUP);\n }\n+\n+/* Starting from loop tree ROOT, walk loop tree as the visiting\n+   order specified by FLAGS.  The supported visiting orders\n+   are:\n+     - LI_ONLY_INNERMOST\n+     - LI_FROM_INNERMOST\n+     - Preorder (if neither of above is specified)  */\n+\n+void\n+loops_list::walk_loop_tree (class loop *root, unsigned flags)\n+{\n+  bool only_innermost_p = flags & LI_ONLY_INNERMOST;\n+  bool from_innermost_p = flags & LI_FROM_INNERMOST;\n+  bool preorder_p = !(only_innermost_p || from_innermost_p);\n+\n+  /* Early handle root without any inner loops, make later\n+     processing simpler, that is all loops processed in the\n+     following while loop are impossible to be root.  */\n+  if (!root->inner)\n+    {\n+      if (flags & LI_INCLUDE_ROOT)\n+\tthis->to_visit.quick_push (root->num);\n+      return;\n+    }\n+  else if (preorder_p && flags & LI_INCLUDE_ROOT)\n+    this->to_visit.quick_push (root->num);\n+\n+  class loop *aloop;\n+  for (aloop = root->inner;\n+       aloop->inner != NULL;\n+       aloop = aloop->inner)\n+    {\n+      if (preorder_p)\n+\tthis->to_visit.quick_push (aloop->num);\n+      continue;\n+    }\n+\n+  while (1)\n+    {\n+      gcc_assert (aloop != root);\n+      if (from_innermost_p || aloop->inner == NULL)\n+\tthis->to_visit.quick_push (aloop->num);\n+\n+      if (aloop->next)\n+\t{\n+\t  for (aloop = aloop->next;\n+\t       aloop->inner != NULL;\n+\t       aloop = aloop->inner)\n+\t    {\n+\t      if (preorder_p)\n+\t\tthis->to_visit.quick_push (aloop->num);\n+\t      continue;\n+\t    }\n+\t}\n+      else if (loop_outer (aloop) == root)\n+\tbreak;\n+      else\n+\taloop = loop_outer (aloop);\n+    }\n+\n+  /* When visiting from innermost, we need to consider root here\n+     since the previous while loop doesn't handle it.  */\n+  if (from_innermost_p && flags & LI_INCLUDE_ROOT)\n+    this->to_visit.quick_push (root->num);\n+}\n+"}, {"sha": "0f71a6bf18f2ed8f10f54c62dd2d9efca5fa804c", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 40, "deletions": 60, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0a5624bb40470cb0ee03fe86530118ca6de0b3a/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0a5624bb40470cb0ee03fe86530118ca6de0b3a/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=d0a5624bb40470cb0ee03fe86530118ca6de0b3a", "patch": "@@ -669,13 +669,15 @@ as_const (T &t)\n }\n \n /* A list for visiting loops, which contains the loop numbers instead of\n-   the loop pointers.  The scope is restricted in function FN and the\n-   visiting order is specified by FLAGS.  */\n+   the loop pointers.  If the loop ROOT is offered (non-null), the visiting\n+   will start from it, otherwise it would start from the tree_root of\n+   loops_for_fn (FN) instead.  The scope is restricted in function FN and\n+   the visiting order is specified by FLAGS.  */\n \n class loops_list\n {\n public:\n-  loops_list (function *fn, unsigned flags);\n+  loops_list (function *fn, unsigned flags, class loop *root = nullptr);\n \n   template <typename T> class Iter\n   {\n@@ -750,6 +752,10 @@ class loops_list\n   }\n \n private:\n+  /* Walk loop tree starting from ROOT as the visiting order specified\n+     by FLAGS.  */\n+  void walk_loop_tree (class loop *root, unsigned flags);\n+\n   /* The function we are visiting.  */\n   function *fn;\n \n@@ -782,76 +788,50 @@ loops_list::Iter<T>::fill_curr_loop ()\n }\n \n /* Set up the loops list to visit according to the specified\n-   function scope FN and iterating order FLAGS.  */\n+   function scope FN and iterating order FLAGS.  If ROOT is\n+   not null, the visiting would start from it, otherwise it\n+   will start from tree_root of loops_for_fn (FN).  */\n \n-inline loops_list::loops_list (function *fn, unsigned flags)\n+inline loops_list::loops_list (function *fn, unsigned flags, class loop *root)\n {\n-  class loop *aloop;\n-  unsigned i;\n-  int mn;\n+  struct loops *loops = loops_for_fn (fn);\n+  gcc_assert (!root || loops);\n+\n+  /* Check mutually exclusive flags should not co-exist.  */\n+  unsigned checked_flags = LI_ONLY_INNERMOST | LI_FROM_INNERMOST;\n+  gcc_assert ((flags & checked_flags) != checked_flags);\n \n   this->fn = fn;\n-  if (!loops_for_fn (fn))\n+  if (!loops)\n     return;\n \n+  class loop *tree_root = root ? root : loops->tree_root;\n+\n   this->to_visit.reserve_exact (number_of_loops (fn));\n-  mn = (flags & LI_INCLUDE_ROOT) ? 0 : 1;\n \n-  if (flags & LI_ONLY_INNERMOST)\n+  /* When root is tree_root of loops_for_fn (fn) and the visiting\n+     order is LI_ONLY_INNERMOST, we would like to use linear\n+     search here since it has a more stable bound than the\n+     walk_loop_tree.  */\n+  if (flags & LI_ONLY_INNERMOST && tree_root == loops->tree_root)\n     {\n-      for (i = 0; vec_safe_iterate (loops_for_fn (fn)->larray, i, &aloop); i++)\n-\tif (aloop != NULL\n-\t    && aloop->inner == NULL\n-\t    && aloop->num >= mn)\n-\t  this->to_visit.quick_push (aloop->num);\n-    }\n-  else if (flags & LI_FROM_INNERMOST)\n-    {\n-      /* Push the loops to LI->TO_VISIT in postorder.  */\n-      for (aloop = loops_for_fn (fn)->tree_root;\n-\t   aloop->inner != NULL;\n-\t   aloop = aloop->inner)\n-\tcontinue;\n-\n-      while (1)\n+      gcc_assert (tree_root->num == 0);\n+      if (tree_root->inner == NULL)\n \t{\n-\t  if (aloop->num >= mn)\n-\t    this->to_visit.quick_push (aloop->num);\n-\n-\t  if (aloop->next)\n-\t    {\n-\t      for (aloop = aloop->next;\n-\t\t   aloop->inner != NULL;\n-\t\t   aloop = aloop->inner)\n-\t\tcontinue;\n-\t    }\n-\t  else if (!loop_outer (aloop))\n-\t    break;\n-\t  else\n-\t    aloop = loop_outer (aloop);\n+\t  if (flags & LI_INCLUDE_ROOT)\n+\t    this->to_visit.quick_push (0);\n+\n+\t  return;\n \t}\n+\n+      class loop *aloop;\n+      unsigned int i;\n+      for (i = 1; vec_safe_iterate (loops->larray, i, &aloop); i++)\n+\tif (aloop != NULL && aloop->inner == NULL)\n+\t  this->to_visit.quick_push (aloop->num);\n     }\n   else\n-    {\n-      /* Push the loops to LI->TO_VISIT in preorder.  */\n-      aloop = loops_for_fn (fn)->tree_root;\n-      while (1)\n-\t{\n-\t  if (aloop->num >= mn)\n-\t    this->to_visit.quick_push (aloop->num);\n-\n-\t  if (aloop->inner != NULL)\n-\t    aloop = aloop->inner;\n-\t  else\n-\t    {\n-\t      while (aloop != NULL && aloop->next == NULL)\n-\t\taloop = loop_outer (aloop);\n-\t      if (aloop == NULL)\n-\t\tbreak;\n-\t      aloop = aloop->next;\n-\t    }\n-\t}\n-    }\n+    walk_loop_tree (tree_root, flags);\n }\n \n /* The properties of the target.  */"}]}