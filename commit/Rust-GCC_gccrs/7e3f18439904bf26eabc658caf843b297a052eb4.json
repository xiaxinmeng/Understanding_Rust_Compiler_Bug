{"sha": "7e3f18439904bf26eabc658caf843b297a052eb4", "node_id": "C_kwDOANBUbNoAKDdlM2YxODQzOTkwNGJmMjZlYWJjNjU4Y2FmODQzYjI5N2EwNTJlYjQ", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-08-30T10:13:31Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-08-30T12:26:38Z"}, "message": "Force a [NAN, NAN] range when the definite NAN property is set.\n\nSetting the definite NAN property should also force a [NAN, NAN]\nrange, otherwise we'd have two ways of representing a NAN: with the\nendpoints or with the property.  In the ranger world we avoid at all\ncosts having more than one representation for a range.\n\nIn doing this, I removed the FRANGE_PROP_ACCESSOR macro, since it\nlooks like setting a property may have repercurssions in the range\nitself, so it's best for the client to definte its own setter.\n\ngcc/ChangeLog:\n\n\t* value-range-storage.cc (frange_storage_slot::get_frange): Use\n\tfrange_nan.\n\t* value-range.cc (frange::set_nan): New.\n\t(frange_nan): Move to header file.\n\t(range_tests_nan): Adjust frange_nan callers to pass type.\n\tNew test.\n\t* value-range.h (FRANGE_PROP_ACCESSOR): Remove.\n\t(frange_nan): New.", "tree": {"sha": "b94a6c3f5c713df4290cd61e6636af5b89a678f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b94a6c3f5c713df4290cd61e6636af5b89a678f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e3f18439904bf26eabc658caf843b297a052eb4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e3f18439904bf26eabc658caf843b297a052eb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e3f18439904bf26eabc658caf843b297a052eb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e3f18439904bf26eabc658caf843b297a052eb4/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "865d7352b6e73c1f2135561b0a18398b7e7df152", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/865d7352b6e73c1f2135561b0a18398b7e7df152", "html_url": "https://github.com/Rust-GCC/gccrs/commit/865d7352b6e73c1f2135561b0a18398b7e7df152"}], "stats": {"total": 85, "additions": 51, "deletions": 34}, "files": [{"sha": "494392737ac166bf49027a48cbd0663e486660c3", "filename": "gcc/value-range-storage.cc", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3f18439904bf26eabc658caf843b297a052eb4/gcc%2Fvalue-range-storage.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3f18439904bf26eabc658caf843b297a052eb4/gcc%2Fvalue-range-storage.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-storage.cc?ref=7e3f18439904bf26eabc658caf843b297a052eb4", "patch": "@@ -267,9 +267,7 @@ frange_storage_slot::get_frange (frange &r, tree type) const\n   // endpoints.\n   if (m_props.get_nan ().yes_p ())\n     {\n-      REAL_VALUE_TYPE rv;\n-      real_nan (&rv, \"\", 1, TYPE_MODE (type));\n-      r.set (type, rv, rv);\n+      r = frange_nan (type);\n       return;\n     }\n "}, {"sha": "b6d6c62c06ca488f751a53408e37c85a472a0922", "filename": "gcc/value-range.cc", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3f18439904bf26eabc658caf843b297a052eb4/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3f18439904bf26eabc658caf843b297a052eb4/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=7e3f18439904bf26eabc658caf843b297a052eb4", "patch": "@@ -267,6 +267,29 @@ tree_compare (tree_code code, tree op1, tree op2)\n   return !integer_zerop (fold_build2 (code, integer_type_node, op1, op2));\n }\n \n+// Set the NAN property.  Adjust the range if appopriate.\n+\n+void\n+frange::set_nan (fp_prop::kind k)\n+{\n+  if (k == fp_prop::YES)\n+    {\n+      gcc_checking_assert (!undefined_p ());\n+      *this = frange_nan (m_type);\n+      return;\n+    }\n+\n+  // Setting NO on an obviously NAN range is nonsensical.\n+  gcc_checking_assert (k != fp_prop::NO || !real_isnan (&m_min));\n+\n+  // Setting VARYING on an obviously NAN range is a no-op.\n+  if (k == fp_prop::VARYING && real_isnan (&m_min))\n+    return;\n+\n+  m_props.set_nan (k);\n+  normalize_kind ();\n+}\n+\n // Setter for franges.\n \n void\n@@ -3493,17 +3516,6 @@ frange_float (const char *lb, const char *ub, tree type = float_type_node)\n   return frange (type, min, max);\n }\n \n-// Build a NAN of type TYPE.\n-\n-static inline frange\n-frange_nan (tree type = float_type_node)\n-{\n-  REAL_VALUE_TYPE r;\n-\n-  gcc_assert (real_nan (&r, \"\", 1, TYPE_MODE (type)));\n-  return frange (type, r, r);\n-}\n-\n static void\n range_tests_nan ()\n {\n@@ -3517,41 +3529,46 @@ range_tests_nan ()\n   ASSERT_NE (r0, r1);\n   r0.set_nan (fp_prop::YES);\n   ASSERT_NE (r0, r1);\n-  r0.set_nan (fp_prop::VARYING);\n-  ASSERT_EQ (r0, r1);\n \n   // NAN ranges are not equal to each other.\n-  r0 = frange_nan ();\n+  r0 = frange_nan (float_type_node);\n   r1 = r0;\n   ASSERT_FALSE (r0 == r1);\n   ASSERT_FALSE (r0 == r0);\n   ASSERT_TRUE (r0 != r0);\n \n   // Make sure that combining NAN and INF doesn't give any crazy results.\n-  r0 = frange_nan ();\n+  r0 = frange_nan (float_type_node);\n   ASSERT_TRUE (r0.get_nan ().yes_p ());\n   r1 = frange_float (\"+Inf\", \"+Inf\");\n   r0.union_ (r1);\n   // [INF, INF] U NAN = VARYING\n   ASSERT_TRUE (r0.varying_p ());\n \n   // [INF, INF] ^ NAN = VARYING\n-  r0 = frange_nan ();\n+  r0 = frange_nan (float_type_node);\n   r1 = frange_float (\"+Inf\", \"+Inf\");\n   r0.intersect (r1);\n   ASSERT_TRUE (r0.varying_p ());\n \n   // NAN ^ NAN = NAN\n-  r0 = frange_nan ();\n-  r1 = frange_nan ();\n+  r0 = frange_nan (float_type_node);\n+  r1 = frange_nan (float_type_node);\n   r0.intersect (r1);\n   ASSERT_TRUE (r0.get_nan ().yes_p ());\n \n   // VARYING ^ NAN = NAN.\n-  r0 = frange_nan ();\n+  r0 = frange_nan (float_type_node);\n   r1.set_varying (float_type_node);\n   r0.intersect (r1);\n   ASSERT_TRUE (r0.get_nan ().yes_p ());\n+\n+  // Setting the NAN bit to yes, forces to range to [NAN, NAN].\n+  r0.set_varying (float_type_node);\n+  r0.set_nan (fp_prop::YES);\n+  ASSERT_TRUE (r0.get_nan ().yes_p ());\n+  ASSERT_TRUE (real_isnan (&r0.lower_bound ()));\n+  ASSERT_TRUE (real_isnan (&r0.upper_bound ()));\n }\n \n static void"}, {"sha": "07379d58f8857a7d3a657d97bdf9dad23a0794af", "filename": "gcc/value-range.h", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e3f18439904bf26eabc658caf843b297a052eb4/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e3f18439904bf26eabc658caf843b297a052eb4/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=7e3f18439904bf26eabc658caf843b297a052eb4", "patch": "@@ -323,16 +323,6 @@ class frange_props\n   } u;\n };\n \n-// Accessors for getting/setting all FP properties at once.\n-\n-#define FRANGE_PROP_ACCESSOR(NAME)\t\t\t\t\\\n-  fp_prop get_##NAME () const { return m_props.get_##NAME (); }\t\\\n-  void set_##NAME (fp_prop::kind f)\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\\\n-    m_props.set_##NAME (f);\t\t\t\t\t\\\n-    normalize_kind ();\t\t\t\t\t\t\\\n-  }\n-\n // A floating point range.\n \n class frange : public vrange\n@@ -371,8 +361,9 @@ class frange : public vrange\n   const REAL_VALUE_TYPE &lower_bound () const;\n   const REAL_VALUE_TYPE &upper_bound () const;\n \n-  // Each fp_prop can be accessed with get_PROP() and set_PROP().\n-  FRANGE_PROP_ACCESSOR(nan)\n+  // Accessors for FP properties.\n+  fp_prop get_nan () const { return m_props.get_nan (); }\n+  void set_nan (fp_prop::kind f);\n private:\n   void verify_range ();\n   bool normalize_kind ();\n@@ -1186,4 +1177,15 @@ real_min_representable (REAL_VALUE_TYPE *r, tree type)\n   *r = real_value_negate (r);\n }\n \n+// Build a NAN of type TYPE.\n+\n+inline frange\n+frange_nan (tree type)\n+{\n+  REAL_VALUE_TYPE r;\n+\n+  gcc_assert (real_nan (&r, \"\", 1, TYPE_MODE (type)));\n+  return frange (type, r, r);\n+}\n+\n #endif // GCC_VALUE_RANGE_H"}]}