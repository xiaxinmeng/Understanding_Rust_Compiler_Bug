{"sha": "684f25f432c571fc5d2dfd03a3c3389a801b75bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njg0ZjI1ZjQzMmM1NzFmYzVkMmRmZDAzYTNjMzM4OWE4MDFiNzViYw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2010-01-09T14:40:40Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2010-01-09T14:40:40Z"}, "message": "re PR debug/42604 (VTA ICE in the vectorizer)\n\ngcc/ChangeLog:\nPR debug/42604\nPR debug/42395\n* tree-vect-loop-manip.c (adjust_info): New type.\n(adjust_vec): New pointer to vector.\n(adjust_debug_stmts_now, adjust_vec_debug_stmts): New.\n(adjust_debug_stmts, adjust_phi_and_debug_stmts): New.\n(slpeel_update_phis_for_duplicate_loop): Use them.\n(slpeel_update_phi_nodes_for_guard1): Likewise.\n(slpeel_update_phi_nodes_for_guard2): Likewise.\n(slpeel_tree_peel_loop_to_edge): Likewise.\n(vect_update_ivs_after_vectorizer): Likewise.\ngcc/testsuite/ChangeLog:\nPR debug/42604\nPR debug/42395\n* gcc.dg/vect/pr42604.c: New.\n* gcc.dg/vect/pr42395.c: New.\n\nFrom-SVN: r155761", "tree": {"sha": "595e1768bdc44cb318f183c1b788f77697ae0164", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/595e1768bdc44cb318f183c1b788f77697ae0164"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/684f25f432c571fc5d2dfd03a3c3389a801b75bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/684f25f432c571fc5d2dfd03a3c3389a801b75bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/684f25f432c571fc5d2dfd03a3c3389a801b75bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/684f25f432c571fc5d2dfd03a3c3389a801b75bc/comments", "author": null, "committer": null, "parents": [{"sha": "0e00563c88bd7e6c0ac4e9c0923fe46fba9f72b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e00563c88bd7e6c0ac4e9c0923fe46fba9f72b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e00563c88bd7e6c0ac4e9c0923fe46fba9f72b6"}], "stats": {"total": 224, "additions": 214, "deletions": 10}, "files": [{"sha": "b5c240789f7f5d36b9b8cd89a01ff957f09c9b02", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/684f25f432c571fc5d2dfd03a3c3389a801b75bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/684f25f432c571fc5d2dfd03a3c3389a801b75bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=684f25f432c571fc5d2dfd03a3c3389a801b75bc", "patch": "@@ -1,3 +1,17 @@\n+2010-01-09  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/42604\n+\tPR debug/42395\n+\t* tree-vect-loop-manip.c (adjust_info): New type.\n+\t(adjust_vec): New pointer to vector.\n+\t(adjust_debug_stmts_now, adjust_vec_debug_stmts): New.\n+\t(adjust_debug_stmts, adjust_phi_and_debug_stmts): New.\n+\t(slpeel_update_phis_for_duplicate_loop): Use them.\n+\t(slpeel_update_phi_nodes_for_guard1): Likewise.\n+\t(slpeel_update_phi_nodes_for_guard2): Likewise.\n+\t(slpeel_tree_peel_loop_to_edge): Likewise.\n+\t(vect_update_ivs_after_vectorizer): Likewise.\n+\n 2010-01-09  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* vec.h (DEF_VEC_ALLOC_FUNC_O_STACK): Drop excess paren."}, {"sha": "08c6bffc6fe41d5588efef82b05c28325a64ab46", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/684f25f432c571fc5d2dfd03a3c3389a801b75bc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/684f25f432c571fc5d2dfd03a3c3389a801b75bc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=684f25f432c571fc5d2dfd03a3c3389a801b75bc", "patch": "@@ -1,3 +1,10 @@\n+2010-01-09  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/42604\n+\tPR debug/42395\n+\t* gcc.dg/vect/pr42604.c: New.\n+\t* gcc.dg/vect/pr42395.c: New.\n+\n 2010-01-09  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/42512"}, {"sha": "7d0b8324f683a161b30c27f2b1ab12ac2be38394", "filename": "gcc/testsuite/gcc.dg/vect/pr42395.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/684f25f432c571fc5d2dfd03a3c3389a801b75bc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr42395.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/684f25f432c571fc5d2dfd03a3c3389a801b75bc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr42395.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr42395.c?ref=684f25f432c571fc5d2dfd03a3c3389a801b75bc", "patch": "@@ -0,0 +1,10 @@\n+/* PR debug/42395 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -ftree-vectorize -g\" } */\n+\n+void foo(int j, int *A)\n+{\n+  int i;\n+  for (i = 0; i < j; i ++) A[i] = i;\n+  for (; i < 4096; i ++) A[i] = 0;\n+}"}, {"sha": "14f255a40a6939d211b7a5f1a20fb3b68fd3e0a6", "filename": "gcc/testsuite/gcc.dg/vect/pr42604.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/684f25f432c571fc5d2dfd03a3c3389a801b75bc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr42604.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/684f25f432c571fc5d2dfd03a3c3389a801b75bc/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr42604.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr42604.c?ref=684f25f432c571fc5d2dfd03a3c3389a801b75bc", "patch": "@@ -0,0 +1,35 @@\n+/* PR debug/42604 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -ftree-vectorize -g -ffast-math\" } */\n+\n+unsigned *d;\n+unsigned short e;\n+int f;\n+float h[3][4];\n+\n+void\n+test (unsigned short *b)\n+{\n+  int a, c, i;\n+  float g[3];\n+  unsigned j[32] = { 10, 0x63707274 };\n+  for (i = 0; i < (int) j[0]; i++)\n+    {\n+      j[i * 3 + 2] = d[0];\n+      d[0] += (j[i * 3 + 3] + 3) & -4;\n+    }\n+  for (a = 0; a < e; a++)\n+    {\n+      g[0] = g[1] = g[2] = 0;\n+      for (c = 0; c < f; c++)\n+\t{\n+\t  g[0] += h[0][c] * b[c];\n+\t  g[1] += h[1][c] * b[c];\n+\t}\n+      for (c = 0; c < 3; c++)\n+\tb[c] = 0 > ((int) g[c] < 65535 ? ((int) g[c]) : 65535)\n+\t  ? 0 : ((int) g[c]) < 65535 ? (int) g[c] : 65535;\n+    }\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "72b905660beaf427eb4d82809e05c1d092debf92", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 148, "deletions": 10, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/684f25f432c571fc5d2dfd03a3c3389a801b75bc/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/684f25f432c571fc5d2dfd03a3c3389a801b75bc/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=684f25f432c571fc5d2dfd03a3c3389a801b75bc", "patch": "@@ -113,6 +113,131 @@ rename_variables_in_loop (struct loop *loop)\n   free (bbs);\n }\n \n+typedef struct\n+{\n+  tree from, to;\n+  basic_block bb;\n+} adjust_info;\n+\n+DEF_VEC_O(adjust_info);\n+DEF_VEC_ALLOC_O_STACK(adjust_info);\n+#define VEC_adjust_info_stack_alloc(alloc) VEC_stack_alloc (adjust_info, alloc)\n+\n+/* A stack of values to be adjusted in debug stmts.  We have to\n+   process them LIFO, so that the closest substitution applies.  If we\n+   processed them FIFO, without the stack, we might substitute uses\n+   with a PHI DEF that would soon become non-dominant, and when we got\n+   to the suitable one, it wouldn't have anything to substitute any\n+   more.  */\n+static VEC(adjust_info, stack) *adjust_vec;\n+\n+/* Adjust any debug stmts that referenced AI->from values to use the\n+   loop-closed AI->to, if the references are dominated by AI->bb and\n+   not by the definition of AI->from.  */\n+\n+static void\n+adjust_debug_stmts_now (adjust_info *ai)\n+{\n+  basic_block bbphi = ai->bb;\n+  tree orig_def = ai->from;\n+  tree new_def = ai->to;\n+  imm_use_iterator imm_iter;\n+  gimple stmt;\n+  basic_block bbdef = gimple_bb (SSA_NAME_DEF_STMT (orig_def));\n+\n+  gcc_assert (dom_info_available_p (CDI_DOMINATORS));\n+\n+  /* Adjust any debug stmts that held onto non-loop-closed\n+     references.  */\n+  FOR_EACH_IMM_USE_STMT (stmt, imm_iter, orig_def)\n+    {\n+      use_operand_p use_p;\n+      basic_block bbuse;\n+\n+      if (!is_gimple_debug (stmt))\n+\tcontinue;\n+\n+      gcc_assert (gimple_debug_bind_p (stmt));\n+\n+      bbuse = gimple_bb (stmt);\n+\n+      if ((bbuse == bbphi\n+\t   || dominated_by_p (CDI_DOMINATORS, bbuse, bbphi))\n+\t  && !(bbuse == bbdef\n+\t       || dominated_by_p (CDI_DOMINATORS, bbuse, bbdef)))\n+\t{\n+\t  if (new_def)\n+\t    FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n+\t      SET_USE (use_p, new_def);\n+\t  else\n+\t    {\n+\t      gimple_debug_bind_reset_value (stmt);\n+\t      update_stmt (stmt);\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Adjust debug stmts as scheduled before.  */\n+\n+static void\n+adjust_vec_debug_stmts (void)\n+{\n+  if (!MAY_HAVE_DEBUG_STMTS)\n+    return;\n+\n+  gcc_assert (adjust_vec);\n+\n+  while (!VEC_empty (adjust_info, adjust_vec))\n+    {\n+      adjust_debug_stmts_now (VEC_last (adjust_info, adjust_vec));\n+      VEC_pop (adjust_info, adjust_vec);\n+    }\n+\n+  VEC_free (adjust_info, stack, adjust_vec);\n+}\n+\n+/* Adjust any debug stmts that referenced FROM values to use the\n+   loop-closed TO, if the references are dominated by BB and not by\n+   the definition of FROM.  If adjust_vec is non-NULL, adjustments\n+   will be postponed until adjust_vec_debug_stmts is called.  */\n+\n+static void\n+adjust_debug_stmts (tree from, tree to, basic_block bb)\n+{\n+  adjust_info ai;\n+\n+  if (MAY_HAVE_DEBUG_STMTS && TREE_CODE (from) == SSA_NAME\n+      && SSA_NAME_VAR (from) != gimple_vop (cfun))\n+    {\n+      ai.from = from;\n+      ai.to = to;\n+      ai.bb = bb;\n+\n+      if (adjust_vec)\n+\tVEC_safe_push (adjust_info, stack, adjust_vec, &ai);\n+      else\n+\tadjust_debug_stmts_now (&ai);\n+    }\n+}\n+\n+/* Change E's phi arg in UPDATE_PHI to NEW_DEF, and record information\n+   to adjust any debug stmts that referenced the old phi arg,\n+   presumably non-loop-closed references left over from other\n+   transformations.  */\n+\n+static void\n+adjust_phi_and_debug_stmts (gimple update_phi, edge e, tree new_def)\n+{\n+  tree orig_def = PHI_ARG_DEF_FROM_EDGE (update_phi, e);\n+\n+  SET_PHI_ARG_DEF (update_phi, e->dest_idx, new_def);\n+\n+  if (MAY_HAVE_DEBUG_STMTS)\n+    adjust_debug_stmts (orig_def, PHI_RESULT (update_phi),\n+\t\t\tgimple_bb (update_phi));\n+}\n+\n \n /* Update the PHI nodes of NEW_LOOP.\n \n@@ -195,13 +320,15 @@ slpeel_update_phis_for_duplicate_loop (struct loop *orig_loop,\n       /* An ordinary ssa name defined in the loop.  */\n       add_phi_arg (phi_new, new_ssa_name, loop_latch_edge (new_loop), locus);\n \n+      /* Drop any debug references outside the loop, if they would\n+\t become ill-formed SSA.  */\n+      adjust_debug_stmts (def, NULL, single_exit (orig_loop)->dest);\n+\n       /* step 3 (case 1).  */\n       if (!after)\n         {\n           gcc_assert (new_loop_exit_e == orig_entry_e);\n-          SET_PHI_ARG_DEF (phi_orig,\n-                           new_loop_exit_e->dest_idx,\n-                           new_ssa_name);\n+\t  adjust_phi_and_debug_stmts (phi_orig, new_loop_exit_e, new_ssa_name);\n         }\n     }\n }\n@@ -413,7 +540,7 @@ slpeel_update_phi_nodes_for_guard1 (edge guard_edge, struct loop *loop,\n       /* 1.3. Update phi in successor block.  */\n       gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi, e) == loop_arg\n                   || PHI_ARG_DEF_FROM_EDGE (update_phi, e) == guard_arg);\n-      SET_PHI_ARG_DEF (update_phi, e->dest_idx, PHI_RESULT (new_phi));\n+      adjust_phi_and_debug_stmts (update_phi, e, PHI_RESULT (new_phi));\n       update_phi2 = new_phi;\n \n \n@@ -431,7 +558,8 @@ slpeel_update_phi_nodes_for_guard1 (edge guard_edge, struct loop *loop,\n \n       /* 2.3. Update phi in successor of NEW_EXIT_BB:  */\n       gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi2, new_exit_e) == loop_arg);\n-      SET_PHI_ARG_DEF (update_phi2, new_exit_e->dest_idx, PHI_RESULT (new_phi));\n+      adjust_phi_and_debug_stmts (update_phi2, new_exit_e,\n+\t\t\t\t  PHI_RESULT (new_phi));\n \n       /* 2.4. Record the newly created name with set_current_def.\n          We want to find a name such that\n@@ -560,7 +688,7 @@ slpeel_update_phi_nodes_for_guard2 (edge guard_edge, struct loop *loop,\n \n       /* 1.3. Update phi in successor block.  */\n       gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi, e) == orig_def);\n-      SET_PHI_ARG_DEF (update_phi, e->dest_idx, PHI_RESULT (new_phi));\n+      adjust_phi_and_debug_stmts (update_phi, e, PHI_RESULT (new_phi));\n       update_phi2 = new_phi;\n \n \n@@ -575,7 +703,8 @@ slpeel_update_phi_nodes_for_guard2 (edge guard_edge, struct loop *loop,\n \n       /* 2.3. Update phi in successor of NEW_EXIT_BB:  */\n       gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi2, new_exit_e) == loop_arg);\n-      SET_PHI_ARG_DEF (update_phi2, new_exit_e->dest_idx, PHI_RESULT (new_phi));\n+      adjust_phi_and_debug_stmts (update_phi2, new_exit_e,\n+\t\t\t\t  PHI_RESULT (new_phi));\n \n \n       /** 3. Handle loop-closed-ssa-form phis for first loop  **/\n@@ -612,7 +741,8 @@ slpeel_update_phi_nodes_for_guard2 (edge guard_edge, struct loop *loop,\n       /* 3.4. Update phi in successor of GUARD_BB:  */\n       gcc_assert (PHI_ARG_DEF_FROM_EDGE (update_phi2, guard_edge)\n                                                                 == guard_arg);\n-      SET_PHI_ARG_DEF (update_phi2, guard_edge->dest_idx, PHI_RESULT (new_phi));\n+      adjust_phi_and_debug_stmts (update_phi2, guard_edge,\n+\t\t\t\t  PHI_RESULT (new_phi));\n     }\n }\n \n@@ -1083,6 +1213,12 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n       return NULL;\n     }\n \n+  if (MAY_HAVE_DEBUG_STMTS)\n+    {\n+      gcc_assert (!adjust_vec);\n+      adjust_vec = VEC_alloc (adjust_info, stack, 32);\n+    }\n+\n   if (e == exit_e)\n     {\n       /* NEW_LOOP was placed after LOOP.  */\n@@ -1278,6 +1414,8 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n   if (update_first_loop_count)\n     slpeel_make_loop_iterate_ntimes (first_loop, first_niters);\n \n+  adjust_vec_debug_stmts ();\n+\n   BITMAP_FREE (definitions);\n   delete_update_ssa ();\n \n@@ -1668,7 +1806,7 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n \t\t\t\t\t  true, GSI_SAME_STMT);\n \n       /* Fix phi expressions in the successor bb.  */\n-      SET_PHI_ARG_DEF (phi1, update_e->dest_idx, ni_name);\n+      adjust_phi_and_debug_stmts (phi1, update_e, ni_name);\n     }\n }\n \n@@ -2399,7 +2537,7 @@ vect_loop_versioning (loop_vec_info loop_vinfo, bool do_versioning,\n       arg = PHI_ARG_DEF_FROM_EDGE (orig_phi, e);\n       add_phi_arg (new_phi, arg, new_exit_e,\n \t\t   gimple_phi_arg_location_from_edge (orig_phi, e));\n-      SET_PHI_ARG_DEF (orig_phi, e->dest_idx, PHI_RESULT (new_phi));\n+      adjust_phi_and_debug_stmts (orig_phi, e, PHI_RESULT (new_phi));\n     }\n \n   /* End loop-exit-fixes after versioning.  */"}]}