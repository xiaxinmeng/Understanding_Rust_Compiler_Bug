{"sha": "8342981f2de7306bf857c96b8b418be8882a0c63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODM0Mjk4MWYyZGU3MzA2YmY4NTdjOTZiOGI0MThiZTg4ODJhMGM2Mw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1997-12-18T23:11:42Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-12-18T23:11:42Z"}, "message": "* com.c (ffecom_sym_transform_): Assumed arrays have no upper bound.\n\nFrom-SVN: r17141", "tree": {"sha": "1f5da7670ce1a6a93e7a6e2181fac33d74360569", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f5da7670ce1a6a93e7a6e2181fac33d74360569"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8342981f2de7306bf857c96b8b418be8882a0c63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8342981f2de7306bf857c96b8b418be8882a0c63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8342981f2de7306bf857c96b8b418be8882a0c63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8342981f2de7306bf857c96b8b418be8882a0c63/comments", "author": null, "committer": null, "parents": [{"sha": "dfe9141827d18651bf75ac735c0f28f6ebbbe1ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dfe9141827d18651bf75ac735c0f28f6ebbbe1ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dfe9141827d18651bf75ac735c0f28f6ebbbe1ca"}], "stats": {"total": 28, "additions": 18, "deletions": 10}, "files": [{"sha": "85fd78822942ba067b5b3368047ad5b315d8ab37", "filename": "gcc/f/ChangeLog.egcs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8342981f2de7306bf857c96b8b418be8882a0c63/gcc%2Ff%2FChangeLog.egcs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8342981f2de7306bf857c96b8b418be8882a0c63/gcc%2Ff%2FChangeLog.egcs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog.egcs?ref=8342981f2de7306bf857c96b8b418be8882a0c63", "patch": "@@ -1,3 +1,7 @@\n+Fri Dec 19 00:12:01 1997  Richard Henderson  <rth@cygnus.com>\n+\n+\t* com.c (ffecom_sym_transform_): Assumed arrays have no upper bound.\n+\n Mon Dec 15 17:35:35 1997  Richard Henderson  <rth@cygnus.com>\n \n \t* com.c (ffecom_type_vardesc_): Vardesc.dims is a `ftnlen*'."}, {"sha": "6d33573485ebf4fe8f105741a6844c559677b3e7", "filename": "gcc/f/com.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8342981f2de7306bf857c96b8b418be8882a0c63/gcc%2Ff%2Fcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8342981f2de7306bf857c96b8b418be8882a0c63/gcc%2Ff%2Fcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fcom.c?ref=8342981f2de7306bf857c96b8b418be8882a0c63", "patch": "@@ -8260,13 +8260,17 @@ ffecom_sym_transform_ (ffesymbol s)\n \t\tassert (ffebld_right (dim) != NULL);\n \t\tif ((ffebld_op (ffebld_right (dim)) == FFEBLD_opSTAR)\n \t\t    || ffecom_doing_entry_)\n-\t\t  /* Used to just do high=low.  But for ffecom_tree_\n-\t\t     canonize_ref_, it probably is important to correctly\n-\t\t     assess the size.  E.g. given COMPLEX C(*),CFUNC and\n-\t\t     C(2)=CFUNC(C), overlap can happen, while it can't\n-\t\t     for, say, C(1)=CFUNC(C(2)).  */\n-\t\t  high = convert (TREE_TYPE (low),\n-\t\t\t\t  TYPE_MAX_VALUE (TREE_TYPE (low)));\n+\t\t  {\n+\t\t    /* Used to just do high=low.  But for ffecom_tree_\n+\t\t       canonize_ref_, it probably is important to correctly\n+\t\t       assess the size.  E.g. given COMPLEX C(*),CFUNC and\n+\t\t       C(2)=CFUNC(C), overlap can happen, while it can't\n+\t\t       for, say, C(1)=CFUNC(C(2)).  */\n+\t\t    /* Even more recently used to set to INT_MAX, but that\n+\t\t       broke when some overflow checking went into the back\n+\t\t       end.  Now we just leave the upper bound unspecified.  */\n+\t\t    high = NULL;\n+\t\t  }\n \t\telse\n \t\t  high = ffecom_expr (ffebld_right (dim));\n \n@@ -8406,7 +8410,7 @@ ffecom_sym_transform_ (ffesymbol s)\n \n \t\tif (!adjustable\n \t\t    && ((TREE_CODE (low) != INTEGER_CST)\n-\t\t\t|| (TREE_CODE (high) != INTEGER_CST)))\n+\t\t\t|| (high && TREE_CODE (high) != INTEGER_CST)))\n \t\t  adjustable = TRUE;\n \n #if 0\t\t\t\t/* Old approach -- see below. */\n@@ -8416,7 +8420,7 @@ ffecom_sym_transform_ (ffesymbol s)\n \t\t\t\t  low,\n \t\t\t\t  ffecom_integer_zero_node);\n \n-\t\tif (TREE_CODE (high) != INTEGER_CST)\n+\t\tif (high && TREE_CODE (high) != INTEGER_CST)\n \t\t  high = ffecom_3 (COND_EXPR, integer_type_node,\n \t\t\t\t   ffecom_adjarray_passed_ (s),\n \t\t\t\t   high,\n@@ -8432,7 +8436,7 @@ ffecom_sym_transform_ (ffesymbol s)\n \t\t/* ~~~similarly, this fixes dumb0.f.  The C front end\n \t\t   does this, which is why dumb0.c would work.  */\n \n-\t\tif (TREE_CODE (high) != INTEGER_CST)\n+\t\tif (high && TREE_CODE (high) != INTEGER_CST)\n \t\t  high = variable_size (high);\n \n \t\ttype"}]}