{"sha": "8b583a0651c326c12cd2a3d6a4cfba7bf6b68963", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI1ODNhMDY1MWMzMjZjMTJjZDJhM2Q2YTRjZmJhN2JmNmI2ODk2Mw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-10-24T13:32:12Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-10-24T13:32:12Z"}, "message": "ipa-reference.c (check_call): Noreturn notrhow calls do not write to memory.\n\n\n\t* ipa-reference.c (check_call): Noreturn notrhow calls do not write\n\tto memory.\n\t(analyze_function): When analyzing noreturn nothrow call, do not compute\n\twritten stats; free bitmaps of vars early if possible.\n\t(generate_summary): Only update bitmaps if computed.\n\t(propagate): Only dump bitmaps if computed.\n\t(ipa_reference_read_summary): Fix pasto.\n\nFrom-SVN: r153529", "tree": {"sha": "0c9ac17cef83655fe69252d93958fccc69378ba3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c9ac17cef83655fe69252d93958fccc69378ba3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b583a0651c326c12cd2a3d6a4cfba7bf6b68963", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b583a0651c326c12cd2a3d6a4cfba7bf6b68963", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b583a0651c326c12cd2a3d6a4cfba7bf6b68963", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b583a0651c326c12cd2a3d6a4cfba7bf6b68963/comments", "author": null, "committer": null, "parents": [{"sha": "e99c3ccc40fac2b63c005b2bdc7ef3a18e74cb07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e99c3ccc40fac2b63c005b2bdc7ef3a18e74cb07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e99c3ccc40fac2b63c005b2bdc7ef3a18e74cb07"}], "stats": {"total": 132, "additions": 89, "deletions": 43}, "files": [{"sha": "0a42a8aa22bd6db7e9834751b83e04e1e47cd20e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b583a0651c326c12cd2a3d6a4cfba7bf6b68963/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b583a0651c326c12cd2a3d6a4cfba7bf6b68963/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b583a0651c326c12cd2a3d6a4cfba7bf6b68963", "patch": "@@ -1,3 +1,13 @@\n+2009-10-24  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-reference.c (check_call): Noreturn notrhow calls do not write\n+\tto memory.\n+\t(analyze_function): When analyzing noreturn nothrow call, do not compute\n+\twritten stats; free bitmaps of vars early if possible.\n+\t(generate_summary): Only update bitmaps if computed.\n+\t(propagate): Only dump bitmaps if computed.\n+\t(ipa_reference_read_summary): Fix pasto.\n+\n 2009-10-24  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree-ssa-alias.c (nonaliasing_component_refs_p): Rename into..."}, {"sha": "8610f13311f60bcc2f74ba7bb7b4ff34c56e64d2", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 79, "deletions": 43, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b583a0651c326c12cd2a3d6a4cfba7bf6b68963/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b583a0651c326c12cd2a3d6a4cfba7bf6b68963/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=8b583a0651c326c12cd2a3d6a4cfba7bf6b68963", "patch": "@@ -427,7 +427,11 @@ check_call (ipa_reference_local_vars_info_t local, gimple stmt)\n       else \n \t{\n \t  local->calls_read_all = true;\n-\t  local->calls_write_all = true;\n+\t  /* When function does not reutrn, it is safe to ignore anythign it writes\n+\t     to, because the effect will never happen.  */\n+\t  if ((flags & (ECF_NOTHROW | ECF_NORETURN))\n+\t      != (ECF_NOTHROW | ECF_NORETURN))\n+\t    local->calls_write_all = true;\n \t}\n     }\n }\n@@ -663,6 +667,7 @@ analyze_function (struct cgraph_node *fn)\n #ifdef ENABLE_CHECKING\n   tree step;\n #endif\n+  ipa_reference_local_vars_info_t local;\n \n   if (dump_file)\n     fprintf (dump_file, \"\\n local analysis of %s\\n\", cgraph_node_name (fn));\n@@ -697,6 +702,21 @@ analyze_function (struct cgraph_node *fn)\n \tscan_stmt_for_static_refs (&gsi, fn);\n     }\n \n+  local = get_reference_vars_info (fn)->local;\n+  if ((flags_from_decl_or_type (decl) & (ECF_NOTHROW | ECF_NORETURN))\n+      == (ECF_NOTHROW | ECF_NORETURN))\n+    {\n+      local->calls_write_all = false;\n+      bitmap_clear (local->statics_written);\n+    }\n+\n+  /* Free bitmaps of direct references if we can not use them anyway.  */\n+  if (local->calls_write_all)\n+    BITMAP_FREE (local->statics_written);\n+  if (local->calls_read_all)\n+    BITMAP_FREE (local->statics_read);\n+\n+\n #ifdef ENABLE_CHECKING\n   /* Verify that all local initializers was expanded by gimplifier.  */\n   for (step = DECL_STRUCT_FUNCTION (decl)->local_decls;\n@@ -956,10 +976,12 @@ generate_summary (void)\n \t   removed from the local maps.  This will include all of the\n \t   variables that were found to escape in the function\n \t   scanning.  */\n-\tbitmap_and_into (l->statics_read, \n-\t\t\t all_module_statics);\n-\tbitmap_and_into (l->statics_written, \n-\t\t\t all_module_statics);\n+\tif (l->statics_read)\n+\t  bitmap_and_into (l->statics_read, \n+\t\t\t   all_module_statics);\n+\tif (l->statics_written)\n+\t  bitmap_and_into (l->statics_written, \n+\t\t\t   all_module_statics);\n       }\n   \n   BITMAP_FREE(module_statics_readonly);\n@@ -978,19 +1000,21 @@ generate_summary (void)\n \t\t   \"\\nFunction name:%s/%i:\", \n \t\t   cgraph_node_name (node), node->uid);\n \t  fprintf (dump_file, \"\\n  locals read: \");\n-\t  EXECUTE_IF_SET_IN_BITMAP (l->statics_read,\n-\t\t\t\t    0, index, bi)\n-\t    {\n-\t      fprintf (dump_file, \"%s \",\n-\t\t       get_static_name (index));\n-\t    }\n+\t  if (l->statics_read)\n+\t    EXECUTE_IF_SET_IN_BITMAP (l->statics_read,\n+\t\t\t\t      0, index, bi)\n+\t      {\n+\t        fprintf (dump_file, \"%s \",\n+\t\t         get_static_name (index));\n+\t      }\n \t  fprintf (dump_file, \"\\n  locals written: \");\n-\t  EXECUTE_IF_SET_IN_BITMAP (l->statics_written,\n-\t\t\t\t    0, index, bi)\n-\t    {\n-\t      fprintf(dump_file, \"%s \",\n-\t\t      get_static_name (index));\n-\t    }\n+\t  if (l->statics_written)\n+\t    EXECUTE_IF_SET_IN_BITMAP (l->statics_written,\n+\t\t\t\t      0, index, bi)\n+\t      {\n+\t        fprintf(dump_file, \"%s \",\n+\t\t        get_static_name (index));\n+\t      }\n \t  if (l->calls_read_all)\n \t     fprintf (dump_file, \"\\n  calls read all: \");\n \t  if (l->calls_write_all)\n@@ -1128,7 +1152,7 @@ ipa_reference_read_summary (void)\n \t      /* Set the statics written.  */\n \t      v_count = lto_input_sleb128 (ib);\n \t      if (v_count == -1)\n-\t        l->calls_read_all = true;\n+\t        l->calls_write_all = true;\n \t      else\n \t\tfor (j = 0; j < (unsigned int)v_count; j++)\n \t\t  {\n@@ -1165,7 +1189,11 @@ read_write_all_from_decl (tree decl, bool * read_all, bool * write_all)\n \t  Indirect calls hsould be only counted and as inliner is replacing them\n \t  by direct calls, we can conclude if any indirect calls are left in body */\n       *read_all = true;\n-      *write_all = true;\n+      /* When function does not reutrn, it is safe to ignore anythign it writes\n+\t to, because the effect will never happen.  */\n+      if ((flags & (ECF_NOTHROW | ECF_NORETURN))\n+\t  != (ECF_NOTHROW | ECF_NORETURN))\n+        *write_all = true;\n     }\n }\n \n@@ -1336,19 +1364,21 @@ propagate (void)\n \t\t   \"\\nFunction name:%s/%i:\", \n \t\t   cgraph_node_name (node), node->uid);\n \t  fprintf (dump_file, \"\\n  locals read: \");\n-\t  EXECUTE_IF_SET_IN_BITMAP (node_l->statics_read,\n-\t\t\t\t    0, index, bi)\n-\t    {\n-\t      fprintf (dump_file, \"%s \",\n-\t\t       get_static_name (index));\n-\t    }\n+\t  if (node_l->statics_read)\n+\t    EXECUTE_IF_SET_IN_BITMAP (node_l->statics_read,\n+\t\t\t\t      0, index, bi)\n+\t      {\n+\t\tfprintf (dump_file, \"%s \",\n+\t\t\t get_static_name (index));\n+\t      }\n \t  fprintf (dump_file, \"\\n  locals written: \");\n-\t  EXECUTE_IF_SET_IN_BITMAP (node_l->statics_written,\n-\t\t\t\t    0, index, bi)\n-\t    {\n-\t      fprintf(dump_file, \"%s \",\n-\t\t      get_static_name (index));\n-\t    }\n+\t  if (node_l->statics_written)\n+\t    EXECUTE_IF_SET_IN_BITMAP (node_l->statics_written,\n+\t\t\t\t      0, index, bi)\n+\t      {\n+\t\tfprintf(dump_file, \"%s \",\n+\t\t\tget_static_name (index));\n+\t      }\n \n \t  w_info = (struct ipa_dfs_info *) node->aux;\n \t  w = w_info->next_cycle;\n@@ -1380,19 +1410,25 @@ propagate (void)\n \t      w = w_info->next_cycle;\n \t    }\n \t  fprintf (dump_file, \"\\n  globals read: \");\n-\t  EXECUTE_IF_SET_IN_BITMAP (node_g->statics_read,\n-\t\t\t\t    0, index, bi)\n-\t    {\n-\t      fprintf (dump_file, \"%s \",\n-\t\t       get_static_name (index));\n-\t    }\n+\t  if (node_g->statics_read == all_module_statics)\n+\t    fprintf (dump_file, \"ALL\");\n+\t  else\n+\t    EXECUTE_IF_SET_IN_BITMAP (node_g->statics_read,\n+\t\t\t\t      0, index, bi)\n+\t      {\n+\t        fprintf (dump_file, \"%s \",\n+\t\t         get_static_name (index));\n+\t      }\n \t  fprintf (dump_file, \"\\n  globals written: \");\n-\t  EXECUTE_IF_SET_IN_BITMAP (node_g->statics_written,\n-\t\t\t\t    0, index, bi)\n-\t    {\n-\t      fprintf (dump_file, \"%s \",\n-\t\t       get_static_name (index));\n-\t    }\n+\t  if (node_g->statics_written == all_module_statics)\n+\t    fprintf (dump_file, \"ALL\");\n+\t  else\n+\t    EXECUTE_IF_SET_IN_BITMAP (node_g->statics_written,\n+\t\t\t\t      0, index, bi)\n+\t      {\n+\t\tfprintf (dump_file, \"%s \",\n+\t\t\t get_static_name (index));\n+\t      }\n \t}\n     }\n "}]}