{"sha": "c575221adaa3075be660a28371977f52ce939ba8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU3NTIyMWFkYWEzMDc1YmU2NjBhMjgzNzE5NzdmNTJjZTkzOWJhOA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2015-07-01T12:34:24Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2015-07-01T12:34:24Z"}, "message": "jit: clarify (lack of) lifetime requirements on input const char *\n\ngcc/jit/ChangeLog:\n\t* docs/topics/contexts.rst (gcc_jit_context_set_bool_option):\n\tClarify lack of lifetime requirements on (const char *) parameter.\n\t* docs/topics/expressions.rst\n\t(gcc_jit_context_new_string_literal): Likewise.\n\t(gcc_jit_context_new_global): Likewise.\n\t* docs/topics/functions.rst (gcc_jit_context_new_param): Likewise.\n\t(gcc_jit_context_new_function): Likewise.\n\t(gcc_jit_function_new_block): Likewise.\n\t(gcc_jit_block_add_comment): Likewise.\n\t* docs/topics/locations.rst (gcc_jit_context_new_location):\n\tLikewise.\n\t* docs/topics/types.rst (gcc_jit_context_new_field): Likewise.\n\t(gcc_jit_context_new_struct_type): Likewise.\n\t* docs/_build/texinfo/libgccjit.texi: Regenerate.\n\nFrom-SVN: r225245", "tree": {"sha": "bcf2f6e8f13471582397d75105c3321cc4d570aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcf2f6e8f13471582397d75105c3321cc4d570aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c575221adaa3075be660a28371977f52ce939ba8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c575221adaa3075be660a28371977f52ce939ba8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c575221adaa3075be660a28371977f52ce939ba8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c575221adaa3075be660a28371977f52ce939ba8/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7946683835932333aafd231f140b1e8812137bfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7946683835932333aafd231f140b1e8812137bfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7946683835932333aafd231f140b1e8812137bfb"}], "stats": {"total": 147, "additions": 144, "deletions": 3}, "files": [{"sha": "469d1bc2dabe2731dbd30fb7fa9b6d9b2c8d6f22", "filename": "gcc/jit/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c575221adaa3075be660a28371977f52ce939ba8/gcc%2Fjit%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c575221adaa3075be660a28371977f52ce939ba8/gcc%2Fjit%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2FChangeLog?ref=c575221adaa3075be660a28371977f52ce939ba8", "patch": "@@ -1,3 +1,20 @@\n+2015-07-01  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* docs/topics/contexts.rst (gcc_jit_context_set_bool_option):\n+\tClarify lack of lifetime requirements on (const char *) parameter.\n+\t* docs/topics/expressions.rst\n+\t(gcc_jit_context_new_string_literal): Likewise.\n+\t(gcc_jit_context_new_global): Likewise.\n+\t* docs/topics/functions.rst (gcc_jit_context_new_param): Likewise.\n+\t(gcc_jit_context_new_function): Likewise.\n+\t(gcc_jit_function_new_block): Likewise.\n+\t(gcc_jit_block_add_comment): Likewise.\n+\t* docs/topics/locations.rst (gcc_jit_context_new_location):\n+\tLikewise.\n+\t* docs/topics/types.rst (gcc_jit_context_new_field): Likewise.\n+\t(gcc_jit_context_new_struct_type): Likewise.\n+\t* docs/_build/texinfo/libgccjit.texi: Regenerate.\n+\n 2015-06-30  David Malcolm  <dmalcolm@redhat.com>\n \n \t* docs/cp/topics/functions.rst (Blocks): Add switch statements to"}, {"sha": "f6ab632688dba52cf2b472154df65a40d1ba35db", "filename": "gcc/jit/docs/_build/texinfo/libgccjit.texi", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c575221adaa3075be660a28371977f52ce939ba8/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c575221adaa3075be660a28371977f52ce939ba8/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2F_build%2Ftexinfo%2Flibgccjit.texi?ref=c575221adaa3075be660a28371977f52ce939ba8", "patch": "@@ -19,7 +19,7 @@\n \n @copying\n @quotation\n-libgccjit 6.0.0 (experimental 20150630), June 30, 2015\n+libgccjit 6.0.0 (experimental 20150701), July 01, 2015\n \n David Malcolm\n \n@@ -5287,6 +5287,10 @@ Set a string option of the context.\n @deffn {C Type} enum gcc_jit_str_option\n @end deffn\n \n+The parameter @code{value} can be NULL.   If non-NULL, the call takes a\n+copy of the underlying string, so it is valid to pass in a pointer to\n+an on-stack buffer.\n+\n There is just one string option specified this way:\n \n @geindex GCC_JIT_STR_OPTION_PROGNAME (C macro)\n@@ -6077,6 +6081,10 @@ gcc_jit_struct_set_fields (node, NULL, 2, fields);\n @deffn {C Function} gcc_jit_field *           gcc_jit_context_new_field (gcc_jit_context@w{ }*ctxt, gcc_jit_location@w{ }*loc, gcc_jit_type@w{ }*type, const char@w{ }*name)\n \n Construct a new field, with the given type and name.\n+\n+The parameter @code{name} must be non-NULL.  The call takes a copy of the\n+underlying string, so it is valid to pass in a pointer to an on-stack\n+buffer.\n @end deffn\n \n @geindex gcc_jit_field_as_object (C function)\n@@ -6093,6 +6101,10 @@ Upcast from field to object.\n @quotation\n \n Construct a new struct type, with the given name and fields.\n+\n+The parameter @code{name} must be non-NULL.  The call takes a copy of\n+the underlying string, so it is valid to pass in a pointer to an\n+on-stack buffer.\n @end quotation\n @end deffn\n \n@@ -6104,6 +6116,10 @@ Construct a new struct type, with the given name, but without\n specifying the fields.   The fields can be omitted (in which case the\n size of the struct is not known), or later specified using\n @pxref{85,,gcc_jit_struct_set_fields()}.\n+\n+The parameter @code{name} must be non-NULL.  The call takes a copy of\n+the underlying string, so it is valid to pass in a pointer to an\n+on-stack buffer.\n @end deffn\n \n @geindex gcc_jit_struct_as_type (C function)\n@@ -6327,6 +6343,10 @@ gcc_jit_context_new_rvalue_from_ptr (ctxt, pointer_type, NULL)\n \n Generate an rvalue for the given NIL-terminated string, of type\n @code{GCC_JIT_TYPE_CONST_CHAR_PTR}.\n+\n+The parameter @code{value} must be non-NULL.  The call takes a copy of the\n+underlying string, so it is valid to pass in a pointer to an on-stack\n+buffer.\n @end deffn\n \n @node Unary Operations,Binary Operations,Simple expressions,Rvalues\n@@ -6975,6 +6995,10 @@ in C.\n \n Add a new global variable of the given type and name to the context.\n \n+The parameter @code{name} must be non-NULL.  The call takes a copy of the\n+underlying string, so it is valid to pass in a pointer to an on-stack\n+buffer.\n+\n The \"kind\" parameter determines the visibility of the \"global\" outside\n of the @pxref{16,,gcc_jit_result}:\n \n@@ -7150,6 +7174,10 @@ A @cite{gcc_jit_param} represents a parameter to a function.\n \n In preparation for creating a function, create a new parameter of the\n given type and name.\n+\n+The parameter @code{name} must be non-NULL.  The call takes a copy of the\n+underlying string, so it is valid to pass in a pointer to an on-stack\n+buffer.\n @end deffn\n \n Parameters are lvalues, and thus are also rvalues (and objects), so the\n@@ -7249,6 +7277,10 @@ above 0; when optimization is off, this is essentially the\n same as GCC_JIT_FUNCTION_INTERNAL.\n @end deffn\n @end quotation\n+\n+The parameter @code{name} must be non-NULL.  The call takes a copy of the\n+underlying string, so it is valid to pass in a pointer to an on-stack\n+buffer.\n @end deffn\n \n @geindex gcc_jit_context_get_builtin_function (C function)\n@@ -7283,6 +7315,10 @@ Emit the function in graphviz format to the given path.\n \n Create a new local variable within the function, of the given type and\n name.\n+\n+The parameter @code{name} must be non-NULL.  The call takes a copy of the\n+underlying string, so it is valid to pass in a pointer to an on-stack\n+buffer.\n @end deffn\n \n @node Blocks,Statements,Functions,Creating and using functions\n@@ -7316,7 +7352,19 @@ one function.\n Create a basic block of the given name.  The name may be NULL, but\n providing meaningful names is often helpful when debugging: it may\n show up in dumps of the internal representation, and in error\n-messages.\n+messages.  It is copied, so the input buffer does not need to outlive\n+the call; you can pass in a pointer to an on-stack buffer, e.g.:\n+\n+@example\n+for (pc = 0; pc < fn->fn_num_ops; pc++)\n+ @{\n+   char buf[16];\n+   sprintf (buf, \"instr%i\", pc);\n+   state.op_blocks[pc] = gcc_jit_function_new_block (state.fn, buf);\n+ @}\n+@end example\n+\n+@noindent\n @end deffn\n \n @geindex gcc_jit_block_as_object (C function)\n@@ -7411,6 +7459,19 @@ seen via @pxref{66,,GCC_JIT_BOOL_OPTION_DUMP_INITIAL_TREE}\n and @pxref{1c,,GCC_JIT_BOOL_OPTION_DUMP_INITIAL_GIMPLE},\n and thus may be of use when debugging how your project's internal\n representation gets converted to the libgccjit IR.\n+\n+The parameter @code{text} must be non-NULL.  It is copied, so the input\n+buffer does not need to outlive the call.  For example:\n+\n+@example\n+char buf[100];\n+snprintf (buf, sizeof (buf),\n+          \"op%i: %s\",\n+          pc, opcode_names[op->op_opcode]);\n+gcc_jit_block_add_comment (block, loc, buf);\n+@end example\n+\n+@noindent\n @end deffn\n \n @geindex gcc_jit_block_end_with_conditional (C function)\n@@ -7747,6 +7808,10 @@ gcc_jit_context_set_bool_option (\n \n Create a @cite{gcc_jit_location} instance representing the given source\n location.\n+\n+The parameter @code{filename} must be non-NULL.  The call takes a copy of\n+the underlying string, so it is valid to pass in a pointer to an\n+on-stack buffer.\n @end deffn\n \n @menu"}, {"sha": "78bcb71fac4ec69fabb7296617740181e3fefd24", "filename": "gcc/jit/docs/topics/contexts.rst", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c575221adaa3075be660a28371977f52ce939ba8/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c575221adaa3075be660a28371977f52ce939ba8/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fcontexts.rst?ref=c575221adaa3075be660a28371977f52ce939ba8", "patch": "@@ -313,6 +313,10 @@ String Options\n \n    .. type:: enum gcc_jit_str_option\n \n+   The parameter ``value`` can be NULL.   If non-NULL, the call takes a\n+   copy of the underlying string, so it is valid to pass in a pointer to\n+   an on-stack buffer.\n+\n    There is just one string option specified this way:\n \n    .. macro:: GCC_JIT_STR_OPTION_PROGNAME"}, {"sha": "c12a3780a9ebc2a58c568bb3496554fde7cb5312", "filename": "gcc/jit/docs/topics/expressions.rst", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c575221adaa3075be660a28371977f52ce939ba8/gcc%2Fjit%2Fdocs%2Ftopics%2Fexpressions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c575221adaa3075be660a28371977f52ce939ba8/gcc%2Fjit%2Fdocs%2Ftopics%2Fexpressions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Fexpressions.rst?ref=c575221adaa3075be660a28371977f52ce939ba8", "patch": "@@ -122,6 +122,9 @@ Simple expressions\n    Generate an rvalue for the given NIL-terminated string, of type\n    :c:data:`GCC_JIT_TYPE_CONST_CHAR_PTR`.\n \n+   The parameter ``value`` must be non-NULL.  The call takes a copy of the\n+   underlying string, so it is valid to pass in a pointer to an on-stack\n+   buffer.\n \n Unary Operations\n ****************\n@@ -466,6 +469,10 @@ Global variables\n \n    Add a new global variable of the given type and name to the context.\n \n+   The parameter ``name`` must be non-NULL.  The call takes a copy of the\n+   underlying string, so it is valid to pass in a pointer to an on-stack\n+   buffer.\n+\n    The \"kind\" parameter determines the visibility of the \"global\" outside\n    of the :c:type:`gcc_jit_result`:\n "}, {"sha": "f2f8f34970e608c7b9f03571cee15b665e32d16c", "filename": "gcc/jit/docs/topics/functions.rst", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c575221adaa3075be660a28371977f52ce939ba8/gcc%2Fjit%2Fdocs%2Ftopics%2Ffunctions.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c575221adaa3075be660a28371977f52ce939ba8/gcc%2Fjit%2Fdocs%2Ftopics%2Ffunctions.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Ffunctions.rst?ref=c575221adaa3075be660a28371977f52ce939ba8", "patch": "@@ -35,6 +35,10 @@ Params\n    In preparation for creating a function, create a new parameter of the\n    given type and name.\n \n+   The parameter ``name`` must be non-NULL.  The call takes a copy of the\n+   underlying string, so it is valid to pass in a pointer to an on-stack\n+   buffer.\n+\n Parameters are lvalues, and thus are also rvalues (and objects), so the\n following upcasts are available:\n \n@@ -111,6 +115,10 @@ Functions\n          above 0; when optimization is off, this is essentially the\n          same as GCC_JIT_FUNCTION_INTERNAL.\n \n+   The parameter ``name`` must be non-NULL.  The call takes a copy of the\n+   underlying string, so it is valid to pass in a pointer to an on-stack\n+   buffer.\n+\n .. function::  gcc_jit_function *\\\n                gcc_jit_context_get_builtin_function (gcc_jit_context *ctxt,\\\n                                                      const char *name)\n@@ -140,6 +148,9 @@ Functions\n    Create a new local variable within the function, of the given type and\n    name.\n \n+   The parameter ``name`` must be non-NULL.  The call takes a copy of the\n+   underlying string, so it is valid to pass in a pointer to an on-stack\n+   buffer.\n \n Blocks\n ------\n@@ -166,7 +177,17 @@ Blocks\n    Create a basic block of the given name.  The name may be NULL, but\n    providing meaningful names is often helpful when debugging: it may\n    show up in dumps of the internal representation, and in error\n-   messages.\n+   messages.  It is copied, so the input buffer does not need to outlive\n+   the call; you can pass in a pointer to an on-stack buffer, e.g.:\n+\n+   .. code-block:: c\n+\n+     for (pc = 0; pc < fn->fn_num_ops; pc++)\n+      {\n+        char buf[16];\n+        sprintf (buf, \"instr%i\", pc);\n+        state.op_blocks[pc] = gcc_jit_function_new_block (state.fn, buf);\n+      }\n \n .. function::  gcc_jit_object *\\\n                gcc_jit_block_as_object (gcc_jit_block *block)\n@@ -252,6 +273,17 @@ Statements\n    and thus may be of use when debugging how your project's internal\n    representation gets converted to the libgccjit IR.\n \n+   The parameter ``text`` must be non-NULL.  It is copied, so the input\n+   buffer does not need to outlive the call.  For example:\n+\n+   .. code-block:: c\n+\n+     char buf[100];\n+     snprintf (buf, sizeof (buf),\n+               \"op%i: %s\",\n+               pc, opcode_names[op->op_opcode]);\n+     gcc_jit_block_add_comment (block, loc, buf);\n+\n .. function:: void\\\n               gcc_jit_block_end_with_conditional (gcc_jit_block *block,\\\n                                                   gcc_jit_location *loc,\\"}, {"sha": "e5e927386834d577be9a6eddabb97b811fc44804", "filename": "gcc/jit/docs/topics/locations.rst", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c575221adaa3075be660a28371977f52ce939ba8/gcc%2Fjit%2Fdocs%2Ftopics%2Flocations.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c575221adaa3075be660a28371977f52ce939ba8/gcc%2Fjit%2Fdocs%2Ftopics%2Flocations.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Flocations.rst?ref=c575221adaa3075be660a28371977f52ce939ba8", "patch": "@@ -52,6 +52,10 @@ Source Locations\n    Create a `gcc_jit_location` instance representing the given source\n    location.\n \n+   The parameter ``filename`` must be non-NULL.  The call takes a copy of\n+   the underlying string, so it is valid to pass in a pointer to an\n+   on-stack buffer.\n+\n Faking it\n ---------\n If you don't have source code for your internal representation, but need"}, {"sha": "5bfba726c001a0315376539c3e3c9d59cf21ddc7", "filename": "gcc/jit/docs/topics/types.rst", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c575221adaa3075be660a28371977f52ce939ba8/gcc%2Fjit%2Fdocs%2Ftopics%2Ftypes.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c575221adaa3075be660a28371977f52ce939ba8/gcc%2Fjit%2Fdocs%2Ftopics%2Ftypes.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjit%2Fdocs%2Ftopics%2Ftypes.rst?ref=c575221adaa3075be660a28371977f52ce939ba8", "patch": "@@ -180,6 +180,10 @@ You can model C `struct` types by creating :c:type:`gcc_jit_struct *` and\n \n    Construct a new field, with the given type and name.\n \n+   The parameter ``name`` must be non-NULL.  The call takes a copy of the\n+   underlying string, so it is valid to pass in a pointer to an on-stack\n+   buffer.\n+\n .. function:: gcc_jit_object *\\\n               gcc_jit_field_as_object (gcc_jit_field *field)\n \n@@ -194,6 +198,10 @@ You can model C `struct` types by creating :c:type:`gcc_jit_struct *` and\n \n      Construct a new struct type, with the given name and fields.\n \n+     The parameter ``name`` must be non-NULL.  The call takes a copy of\n+     the underlying string, so it is valid to pass in a pointer to an\n+     on-stack buffer.\n+\n .. function:: gcc_jit_struct *\\\n               gcc_jit_context_new_opaque_struct (gcc_jit_context *ctxt,\\\n                                                  gcc_jit_location *loc,\\\n@@ -204,6 +212,10 @@ You can model C `struct` types by creating :c:type:`gcc_jit_struct *` and\n      size of the struct is not known), or later specified using\n      :c:func:`gcc_jit_struct_set_fields`.\n \n+     The parameter ``name`` must be non-NULL.  The call takes a copy of\n+     the underlying string, so it is valid to pass in a pointer to an\n+     on-stack buffer.\n+\n .. function:: gcc_jit_type *\\\n               gcc_jit_struct_as_type (gcc_jit_struct *struct_type)\n "}]}