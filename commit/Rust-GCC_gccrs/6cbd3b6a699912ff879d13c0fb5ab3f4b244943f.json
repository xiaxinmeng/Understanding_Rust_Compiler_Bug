{"sha": "6cbd3b6a699912ff879d13c0fb5ab3f4b244943f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNiZDNiNmE2OTk5MTJmZjg3OWQxM2MwZmI1YWIzZjRiMjQ0OTQzZg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2010-05-04T17:34:01Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2010-05-04T17:34:01Z"}, "message": "tree-sra.c (build_access_from_expr_1): The first parameter type changed to simple tree.\n\n2010-05-04  Martin Jambor  <mjambor@suse.cz>\n\n\t* tree-sra.c (build_access_from_expr_1): The first parameter type\n\tchanged to simple tree.\n\t(build_access_from_expr): Likewise, gsi parameter was eliminated.\n\t(scan_assign_result): Renamed to assignment_mod_result, enum elements\n\trenamed as well.\n\t(build_accesses_from_assign): Removed all parameters except for a\n\tsimple gimple statement.  Now returns a simple bool.\n\t(scan_function): All non-analysis parts moved to separate functions\n\tsra_modify_function_body and ipa_sra_modify_function_body.  Removed all\n\tparameters and updated both callers.\n\t(sra_modify_expr): Removed parameter data.\n\t(sra_modify_function_body): New function.\n\t(perform_intra_sra): Call sra_modify_function_body to modify the\n\tfunction body.\n\t(replace_removed_params_ssa_names): Parameter data changed into\n\tadjustments vector.\n\t(sra_ipa_modify_expr): Likewise.  Also removed unused parameter gsi and\n\tchanged the parameter dont_convert to convert with the opposite\n\tmeaning.\n\t(sra_ipa_modify_assign): Parameter data changed into adjustments\n\tvector, return value changed to bool.\n\t(ipa_sra_modify_function_body): New function.\n\t(sra_ipa_reset_debug_stmts): Updated a comment.\n\t(modify_function): Use ipa_sra_modify_function_body to modify function\n\tbody.\n\nFrom-SVN: r159038", "tree": {"sha": "fbf0e8c6815f54c2f72fc7d9a758ef50fc3da37e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fbf0e8c6815f54c2f72fc7d9a758ef50fc3da37e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cbd3b6a699912ff879d13c0fb5ab3f4b244943f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cbd3b6a699912ff879d13c0fb5ab3f4b244943f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cbd3b6a699912ff879d13c0fb5ab3f4b244943f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cbd3b6a699912ff879d13c0fb5ab3f4b244943f/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ed24bfdf685375d4f82f7da01c3233e8f0898b88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed24bfdf685375d4f82f7da01c3233e8f0898b88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed24bfdf685375d4f82f7da01c3233e8f0898b88"}], "stats": {"total": 496, "additions": 303, "deletions": 193}, "files": [{"sha": "41139cb9f90e5f1f75947424dd3fae6ded3fad89", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbd3b6a699912ff879d13c0fb5ab3f4b244943f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbd3b6a699912ff879d13c0fb5ab3f4b244943f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6cbd3b6a699912ff879d13c0fb5ab3f4b244943f", "patch": "@@ -1,3 +1,31 @@\n+2010-05-04  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* tree-sra.c (build_access_from_expr_1): The first parameter type\n+\tchanged to simple tree.\n+\t(build_access_from_expr): Likewise, gsi parameter was eliminated.\n+\t(scan_assign_result): Renamed to assignment_mod_result, enum elements\n+\trenamed as well.\n+\t(build_accesses_from_assign): Removed all parameters except for a\n+\tsimple gimple statement.  Now returns a simple bool.\n+\t(scan_function): All non-analysis parts moved to separate functions\n+\tsra_modify_function_body and ipa_sra_modify_function_body.  Removed all\n+\tparameters and updated both callers.\n+\t(sra_modify_expr): Removed parameter data.\n+\t(sra_modify_function_body): New function.\n+\t(perform_intra_sra): Call sra_modify_function_body to modify the\n+\tfunction body.\n+\t(replace_removed_params_ssa_names): Parameter data changed into\n+\tadjustments vector.\n+\t(sra_ipa_modify_expr): Likewise.  Also removed unused parameter gsi and\n+\tchanged the parameter dont_convert to convert with the opposite\n+\tmeaning.\n+\t(sra_ipa_modify_assign): Parameter data changed into adjustments\n+\tvector, return value changed to bool.\n+\t(ipa_sra_modify_function_body): New function.\n+\t(sra_ipa_reset_debug_stmts): Updated a comment.\n+\t(modify_function): Use ipa_sra_modify_function_body to modify function\n+\tbody.\n+\n 2010-05-04  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR middle-end/43671"}, {"sha": "166338ffa5b97be54c8dec26edfdb8748eb517f4", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 275, "deletions": 193, "changes": 468, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cbd3b6a699912ff879d13c0fb5ab3f4b244943f/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cbd3b6a699912ff879d13c0fb5ab3f4b244943f/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=6cbd3b6a699912ff879d13c0fb5ab3f4b244943f", "patch": "@@ -903,10 +903,9 @@ disqualify_base_of_expr (tree t, const char *reason)\n    created.  */\n \n static struct access *\n-build_access_from_expr_1 (tree *expr_ptr, gimple stmt, bool write)\n+build_access_from_expr_1 (tree expr, gimple stmt, bool write)\n {\n   struct access *ret = NULL;\n-  tree expr = *expr_ptr;\n   bool partial_ref;\n \n   if (TREE_CODE (expr) == BIT_FIELD_REF\n@@ -958,18 +957,17 @@ build_access_from_expr_1 (tree *expr_ptr, gimple stmt, bool write)\n   return ret;\n }\n \n-/* Callback of scan_function.  Scan expression EXPR and create access\n-   structures for all accesses to candidates for scalarization.  Return true if\n-   any access has been inserted.  */\n+/* Scan expression EXPR and create access structures for all accesses to\n+   candidates for scalarization.  Return true if any access has been inserted.\n+   STMT must be the statement from which the expression is taken, WRITE must be\n+   true if the expression is a store and false otherwise. */\n \n static bool\n-build_access_from_expr (tree *expr_ptr,\n-\t\t\tgimple_stmt_iterator *gsi ATTRIBUTE_UNUSED, bool write,\n-\t\t\tvoid *data ATTRIBUTE_UNUSED)\n+build_access_from_expr (tree expr, gimple stmt, bool write)\n {\n   struct access *access;\n \n-  access = build_access_from_expr_1 (expr_ptr, gsi_stmt (*gsi), write);\n+  access = build_access_from_expr_1 (expr, stmt, write);\n   if (access)\n     {\n       /* This means the aggregate is accesses as a whole in a way other than an\n@@ -1001,39 +999,28 @@ disqualify_ops_if_throwing_stmt (gimple stmt, tree lhs, tree rhs)\n   return false;\n }\n \n-\n-/* Result code for scan_assign callback for scan_function.  */\n-enum scan_assign_result { SRA_SA_NONE,       /* nothing done for the stmt */\n-\t\t\t  SRA_SA_PROCESSED,  /* stmt analyzed/changed */\n-\t\t\t  SRA_SA_REMOVED };  /* stmt redundant and eliminated */\n-\n-\n-/* Callback of scan_function.  Scan expressions occuring in the statement\n-   pointed to by STMT_EXPR, create access structures for all accesses to\n-   candidates for scalarization and remove those candidates which occur in\n+/* Scan expressions occuring in STMT, create access structures for all accesses\n+   to candidates for scalarization and remove those candidates which occur in\n    statements or expressions that prevent them from being split apart.  Return\n    true if any access has been inserted.  */\n \n-static enum scan_assign_result\n-build_accesses_from_assign (gimple *stmt_ptr,\n-\t\t\t    gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n-\t\t\t    void *data ATTRIBUTE_UNUSED)\n+static bool\n+build_accesses_from_assign (gimple stmt)\n {\n-  gimple stmt = *stmt_ptr;\n-  tree *lhs_ptr, *rhs_ptr;\n+  tree lhs, rhs;\n   struct access *lacc, *racc;\n \n   if (!gimple_assign_single_p (stmt))\n-    return SRA_SA_NONE;\n+    return false;\n \n-  lhs_ptr = gimple_assign_lhs_ptr (stmt);\n-  rhs_ptr = gimple_assign_rhs1_ptr (stmt);\n+  lhs = gimple_assign_lhs (stmt);\n+  rhs = gimple_assign_rhs1 (stmt);\n \n-  if (disqualify_ops_if_throwing_stmt (stmt, *lhs_ptr, *rhs_ptr))\n-    return SRA_SA_NONE;\n+  if (disqualify_ops_if_throwing_stmt (stmt, lhs, rhs))\n+    return false;\n \n-  racc = build_access_from_expr_1 (rhs_ptr, stmt, false);\n-  lacc = build_access_from_expr_1 (lhs_ptr, stmt, true);\n+  racc = build_access_from_expr_1 (rhs, stmt, false);\n+  lacc = build_access_from_expr_1 (lhs, stmt, true);\n \n   if (racc)\n     {\n@@ -1047,7 +1034,7 @@ build_accesses_from_assign (gimple *stmt_ptr,\n       && (sra_mode == SRA_MODE_EARLY_INTRA || sra_mode == SRA_MODE_INTRA)\n       && !lacc->grp_unscalarizable_region\n       && !racc->grp_unscalarizable_region\n-      && AGGREGATE_TYPE_P (TREE_TYPE (*lhs_ptr))\n+      && AGGREGATE_TYPE_P (TREE_TYPE (lhs))\n       /* FIXME: Turn the following line into an assert after PR 40058 is\n \t fixed.  */\n       && lacc->size == racc->size\n@@ -1064,7 +1051,7 @@ build_accesses_from_assign (gimple *stmt_ptr,\n       add_link_to_rhs (racc, link);\n     }\n \n-  return (lacc || racc) ? SRA_SA_PROCESSED : SRA_SA_NONE;\n+  return lacc || racc;\n }\n \n /* Callback of walk_stmt_load_store_addr_ops visit_addr used to determine\n@@ -1091,76 +1078,46 @@ callsite_has_enough_arguments_p (gimple call)\n   return gimple_call_num_args (call) >= (unsigned) func_param_count;\n }\n \n-/* Scan function and look for interesting statements. Return true if any has\n-   been found or processed, as indicated by callbacks.  SCAN_EXPR is a callback\n-   called on all expressions within statements except assign statements and\n-   those deemed entirely unsuitable for some reason (all operands in such\n-   statements and expression are removed from candidate_bitmap).  SCAN_ASSIGN\n-   is a callback called on all assign statements, HANDLE_SSA_DEFS is a callback\n-   called on assign statements and those call statements which have a lhs, it\n-   can be NULL.  ANALYSIS_STAGE is true when running in the analysis stage of a\n-   pass and thus no statement is being modified.  DATA is a pointer passed to\n-   all callbacks.  If any single callback returns true, this function also\n-   returns true, otherwise it returns false.  */\n+/* Scan function and look for interesting expressions and create access\n+   structures for them.  Return true iff any access is created.  */\n \n static bool\n-scan_function (bool (*scan_expr) (tree *, gimple_stmt_iterator *, bool, void *),\n-\t       enum scan_assign_result (*scan_assign) (gimple *,\n-\t\t\t\t\t\t       gimple_stmt_iterator *,\n-\t\t\t\t\t\t       void *),\n-\t       bool (*handle_ssa_defs)(gimple, void *),\n-\t       bool analysis_stage, void *data)\n+scan_function (void)\n {\n-  gimple_stmt_iterator gsi;\n   basic_block bb;\n-  unsigned i;\n-  tree *t;\n   bool ret = false;\n \n   FOR_EACH_BB (bb)\n     {\n-      bool bb_changed = false;\n-\n-      if (handle_ssa_defs)\n-\tfor (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t  ret |= handle_ssa_defs (gsi_stmt (gsi), data);\n-\n-      gsi = gsi_start_bb (bb);\n-      while (!gsi_end_p (gsi))\n+      gimple_stmt_iterator gsi;\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple stmt = gsi_stmt (gsi);\n-\t  enum scan_assign_result assign_result;\n-\t  bool any = false, deleted = false;\n+\t  tree t;\n+\t  unsigned i;\n \n-\t  if (analysis_stage && final_bbs && stmt_can_throw_external (stmt))\n+\t  if (final_bbs && stmt_can_throw_external (stmt))\n \t    bitmap_set_bit (final_bbs, bb->index);\n \t  switch (gimple_code (stmt))\n \t    {\n \t    case GIMPLE_RETURN:\n-\t      t = gimple_return_retval_ptr (stmt);\n-\t      if (*t != NULL_TREE)\n-\t\tany |= scan_expr (t, &gsi, false, data);\n-\t      if (analysis_stage && final_bbs)\n+\t      t = gimple_return_retval (stmt);\n+\t      if (t != NULL_TREE)\n+\t\tret |= build_access_from_expr (t, stmt, false);\n+\t      if (final_bbs)\n \t\tbitmap_set_bit (final_bbs, bb->index);\n \t      break;\n \n \t    case GIMPLE_ASSIGN:\n-\t      assign_result = scan_assign (&stmt, &gsi, data);\n-\t      any |= assign_result == SRA_SA_PROCESSED;\n-\t      deleted = assign_result == SRA_SA_REMOVED;\n-\t      if (handle_ssa_defs && assign_result != SRA_SA_REMOVED)\n-\t\tany |= handle_ssa_defs (stmt, data);\n+\t      ret |= build_accesses_from_assign (stmt);\n \t      break;\n \n \t    case GIMPLE_CALL:\n-\t      /* Operands must be processed before the lhs.  */\n \t      for (i = 0; i < gimple_call_num_args (stmt); i++)\n-\t\t{\n-\t\t  tree *argp = gimple_call_arg_ptr (stmt, i);\n-\t\t  any |= scan_expr (argp, &gsi, false, data);\n-\t\t}\n+\t\tret |= build_access_from_expr (gimple_call_arg (stmt, i),\n+\t\t\t\t\t       stmt, false);\n \n-\t      if (analysis_stage && sra_mode == SRA_MODE_EARLY_IPA)\n+\t      if (sra_mode == SRA_MODE_EARLY_IPA)\n \t\t{\n \t\t  tree dest = gimple_call_fndecl (stmt);\n \t\t  int flags = gimple_call_flags (stmt);\n@@ -1184,65 +1141,33 @@ scan_function (bool (*scan_expr) (tree *, gimple_stmt_iterator *, bool, void *),\n \t\t    bitmap_set_bit (final_bbs, bb->index);\n \t\t}\n \n-\t      if (gimple_call_lhs (stmt))\n-\t\t{\n-\t\t  tree *lhs_ptr = gimple_call_lhs_ptr (stmt);\n-\t\t  if (!analysis_stage\n-\t\t      || !disqualify_ops_if_throwing_stmt (stmt,\n-\t\t\t\t\t\t\t   *lhs_ptr, NULL))\n-\t\t    {\n-\t\t      any |= scan_expr (lhs_ptr, &gsi, true, data);\n-\t\t      if (handle_ssa_defs)\n-\t\t\tany |= handle_ssa_defs (stmt, data);\n-\t\t    }\n-\t\t}\n+\t      t = gimple_call_lhs (stmt);\n+\t      if (t && !disqualify_ops_if_throwing_stmt (stmt, t, NULL))\n+\t\tret |= build_access_from_expr (t, stmt, true);\n \t      break;\n \n \t    case GIMPLE_ASM:\n-\t      if (analysis_stage)\n-\t\t{\n-\t\t  walk_stmt_load_store_addr_ops (stmt, NULL, NULL, NULL,\n-\t\t\t\t\t\t asm_visit_addr);\n-\t\t  if (final_bbs)\n-\t\t    bitmap_set_bit (final_bbs, bb->index);\n-\t\t}\n+\t      walk_stmt_load_store_addr_ops (stmt, NULL, NULL, NULL,\n+\t\t\t\t\t     asm_visit_addr);\n+\t      if (final_bbs)\n+\t\tbitmap_set_bit (final_bbs, bb->index);\n+\n \t      for (i = 0; i < gimple_asm_ninputs (stmt); i++)\n \t\t{\n-\t\t  tree *op = &TREE_VALUE (gimple_asm_input_op (stmt, i));\n-\t\t  any |= scan_expr (op, &gsi, false, data);\n+\t\t  t = TREE_VALUE (gimple_asm_input_op (stmt, i));\n+\t\t  ret |= build_access_from_expr (t, stmt, false);\n \t\t}\n \t      for (i = 0; i < gimple_asm_noutputs (stmt); i++)\n \t\t{\n-\t\t  tree *op = &TREE_VALUE (gimple_asm_output_op (stmt, i));\n-\t\t  any |= scan_expr (op, &gsi, true, data);\n+\t\t  t = TREE_VALUE (gimple_asm_output_op (stmt, i));\n+\t\t  ret |= build_access_from_expr (t, stmt, true);\n \t\t}\n \t      break;\n \n \t    default:\n \t      break;\n \t    }\n-\n-\t  if (any)\n-\t    {\n-\t      ret = true;\n-\n-\t      if (!analysis_stage)\n-\t\t{\n-\t\t  bb_changed = true;\n-\t\t  update_stmt (stmt);\n-\t\t  maybe_clean_eh_stmt (stmt);\n-\t\t}\n-\t    }\n-\t  if (deleted)\n-\t    bb_changed = true;\n-\t  else\n-\t    {\n-\t      gsi_next (&gsi);\n-\t      ret = true;\n-\t    }\n \t}\n-      if (!analysis_stage && bb_changed && sra_mode == SRA_MODE_EARLY_IPA)\n-\tgimple_purge_dead_eh_edges (bb);\n     }\n \n   return ret;\n@@ -2300,15 +2225,14 @@ get_access_for_expr (tree expr)\n   return get_var_base_offset_size_access (base, offset, max_size);\n }\n \n-/* Callback for scan_function.  Replace the expression EXPR with a scalar\n-   replacement if there is one and generate other statements to do type\n-   conversion or subtree copying if necessary.  GSI is used to place newly\n-   created statements, WRITE is true if the expression is being written to (it\n-   is on a LHS of a statement or output in an assembly statement).  */\n+/* Replace the expression EXPR with a scalar replacement if there is one and\n+   generate other statements to do type conversion or subtree copying if\n+   necessary.  GSI is used to place newly created statements, WRITE is true if\n+   the expression is being written to (it is on a LHS of a statement or output\n+   in an assembly statement).  */\n \n static bool\n-sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write,\n-\t\t void *data ATTRIBUTE_UNUSED)\n+sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)\n {\n   struct access *access;\n   tree type, bfr;\n@@ -2510,19 +2434,25 @@ load_assign_lhs_subreplacements (struct access *lacc, struct access *top_racc,\n   while (lacc);\n }\n \n+/* Result code for SRA assignment modification.  */\n+enum assignment_mod_result { SRA_AM_NONE,       /* nothing done for the stmt */\n+\t\t\t     SRA_AM_MODIFIED,  /* stmt changed but not\n+\t\t\t\t\t\t  removed */\n+\t\t\t     SRA_AM_REMOVED };  /* stmt eliminated */\n+\n /* Modify assignments with a CONSTRUCTOR on their RHS.  STMT contains a pointer\n    to the assignment and GSI is the statement iterator pointing at it.  Returns\n    the same values as sra_modify_assign.  */\n \n-static enum scan_assign_result\n+static enum assignment_mod_result\n sra_modify_constructor_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n {\n   tree lhs = gimple_assign_lhs (*stmt);\n   struct access *acc;\n \n   acc = get_access_for_expr (lhs);\n   if (!acc)\n-    return SRA_SA_NONE;\n+    return SRA_AM_NONE;\n \n   if (VEC_length (constructor_elt,\n \t\t  CONSTRUCTOR_ELTS (gimple_assign_rhs1 (*stmt))) > 0)\n@@ -2532,20 +2462,20 @@ sra_modify_constructor_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n       if (access_has_children_p (acc))\n \tgenerate_subtree_copies (acc->first_child, acc->base, 0, 0, 0, gsi,\n \t\t\t\t true, true);\n-      return SRA_SA_PROCESSED;\n+      return SRA_AM_MODIFIED;\n     }\n \n   if (acc->grp_covered)\n     {\n       init_subtree_with_zero (acc, gsi, false);\n       unlink_stmt_vdef (*stmt);\n       gsi_remove (gsi, true);\n-      return SRA_SA_REMOVED;\n+      return SRA_AM_REMOVED;\n     }\n   else\n     {\n       init_subtree_with_zero (acc, gsi, true);\n-      return SRA_SA_PROCESSED;\n+      return SRA_AM_MODIFIED;\n     }\n }\n \n@@ -2578,16 +2508,14 @@ replace_uses_with_default_def_ssa_name (tree ssa)\n   replace_uses_by (ssa, repl);\n }\n \n-/* Callback of scan_function to process assign statements.  It examines both\n-   sides of the statement, replaces them with a scalare replacement if there is\n-   one and generating copying of replacements if scalarized aggregates have been\n-   used in the assignment.  STMT is a pointer to the assign statement, GSI is\n-   used to hold generated statements for type conversions and subtree\n+/* Examine both sides of the assignment statement pointed to by STMT, replace\n+   them with a scalare replacement if there is one and generate copying of\n+   replacements if scalarized aggregates have been used in the assignment.  GSI\n+   is used to hold generated statements for type conversions and subtree\n    copying.  */\n \n-static enum scan_assign_result\n-sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi,\n-\t\t   void *data ATTRIBUTE_UNUSED)\n+static enum assignment_mod_result\n+sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n {\n   struct access *lacc, *racc;\n   tree lhs, rhs;\n@@ -2597,7 +2525,7 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi,\n   gimple_stmt_iterator orig_gsi = *gsi;\n \n   if (!gimple_assign_single_p (*stmt))\n-    return SRA_SA_NONE;\n+    return SRA_AM_NONE;\n   lhs = gimple_assign_lhs (*stmt);\n   rhs = gimple_assign_rhs1 (*stmt);\n \n@@ -2609,16 +2537,16 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi,\n       || TREE_CODE (rhs) == BIT_FIELD_REF || TREE_CODE (lhs) == BIT_FIELD_REF)\n     {\n       modify_this_stmt = sra_modify_expr (gimple_assign_rhs1_ptr (*stmt),\n-\t\t\t\t\t  gsi, false, data);\n+\t\t\t\t\t  gsi, false);\n       modify_this_stmt |= sra_modify_expr (gimple_assign_lhs_ptr (*stmt),\n-\t\t\t\t\t   gsi, true, data);\n-      return modify_this_stmt ? SRA_SA_PROCESSED : SRA_SA_NONE;\n+\t\t\t\t\t   gsi, true);\n+      return modify_this_stmt ? SRA_AM_MODIFIED : SRA_AM_NONE;\n     }\n \n   lacc = get_access_for_expr (lhs);\n   racc = get_access_for_expr (rhs);\n   if (!lacc && !racc)\n-    return SRA_SA_NONE;\n+    return SRA_AM_NONE;\n \n   if (lacc && lacc->grp_to_be_replaced)\n     {\n@@ -2747,7 +2675,7 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      unlink_stmt_vdef (*stmt);\n \t      gsi_remove (&orig_gsi, true);\n \t      sra_stats.deleted++;\n-\t      return SRA_SA_REMOVED;\n+\t      return SRA_AM_REMOVED;\n \t    }\n \t}\n       else\n@@ -2767,7 +2695,7 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t  unlink_stmt_vdef (*stmt);\n \t\t  gsi_remove (gsi, true);\n \t\t  sra_stats.deleted++;\n-\t\t  return SRA_SA_REMOVED;\n+\t\t  return SRA_AM_REMOVED;\n \t\t}\n \t      else if (racc->first_child)\n \t\tgenerate_subtree_copies (racc->first_child, lhs,\n@@ -2790,7 +2718,83 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi,\n       gcc_assert (*stmt == gsi_stmt (orig_gsi));\n     }\n \n-  return modify_this_stmt ? SRA_SA_PROCESSED : SRA_SA_NONE;\n+  return modify_this_stmt ? SRA_AM_MODIFIED : SRA_AM_NONE;\n+}\n+\n+/* Traverse the function body and all modifications as decided in\n+   analyze_all_variable_accesses.  */\n+\n+static void\n+sra_modify_function_body (void)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      gimple_stmt_iterator gsi = gsi_start_bb (bb);\n+      while (!gsi_end_p (gsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  enum assignment_mod_result assign_result;\n+\t  bool modified = false, deleted = false;\n+\t  tree *t;\n+\t  unsigned i;\n+\n+\t  switch (gimple_code (stmt))\n+\t    {\n+\t    case GIMPLE_RETURN:\n+\t      t = gimple_return_retval_ptr (stmt);\n+\t      if (*t != NULL_TREE)\n+\t\tmodified |= sra_modify_expr (t, &gsi, false);\n+\t      break;\n+\n+\t    case GIMPLE_ASSIGN:\n+\t      assign_result = sra_modify_assign (&stmt, &gsi);\n+\t      modified |= assign_result == SRA_AM_MODIFIED;\n+\t      deleted = assign_result == SRA_AM_REMOVED;\n+\t      break;\n+\n+\t    case GIMPLE_CALL:\n+\t      /* Operands must be processed before the lhs.  */\n+\t      for (i = 0; i < gimple_call_num_args (stmt); i++)\n+\t\t{\n+\t\t  t = gimple_call_arg_ptr (stmt, i);\n+\t\t  modified |= sra_modify_expr (t, &gsi, false);\n+\t\t}\n+\n+\t      if (gimple_call_lhs (stmt))\n+\t\t{\n+\t\t  t = gimple_call_lhs_ptr (stmt);\n+\t\t  modified |= sra_modify_expr (t, &gsi, true);\n+\t\t}\n+\t      break;\n+\n+\t    case GIMPLE_ASM:\n+\t      for (i = 0; i < gimple_asm_ninputs (stmt); i++)\n+\t\t{\n+\t\t  t = &TREE_VALUE (gimple_asm_input_op (stmt, i));\n+\t\t  modified |= sra_modify_expr (t, &gsi, false);\n+\t\t}\n+\t      for (i = 0; i < gimple_asm_noutputs (stmt); i++)\n+\t\t{\n+\t\t  t = &TREE_VALUE (gimple_asm_output_op (stmt, i));\n+\t\t  modified |= sra_modify_expr (t, &gsi, true);\n+\t\t}\n+\t      break;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\n+\t  if (modified)\n+\t    {\n+\t      update_stmt (stmt);\n+\t      maybe_clean_eh_stmt (stmt);\n+\t    }\n+\t  if (!deleted)\n+\t    gsi_next (&gsi);\n+\t}\n+    }\n }\n \n /* Generate statements initializing scalar replacements of parts of function\n@@ -2844,14 +2848,13 @@ perform_intra_sra (void)\n   if (!find_var_candidates ())\n     goto out;\n \n-  if (!scan_function (build_access_from_expr, build_accesses_from_assign, NULL,\n-\t\t      true, NULL))\n+  if (!scan_function ())\n     goto out;\n \n   if (!analyze_all_variable_accesses ())\n     goto out;\n \n-  scan_function (sra_modify_expr, sra_modify_assign, NULL, false, NULL);\n+  sra_modify_function_body ();\n   initialize_parameter_reductions ();\n \n   statistics_counter_event (cfun, \"Scalar replacements created\",\n@@ -3786,20 +3789,18 @@ get_adjustment_for_base (ipa_parm_adjustment_vec adjustments, tree base)\n   return NULL;\n }\n \n-/* Callback for scan_function.  If the statement STMT defines an SSA_NAME of a\n-   parameter which is to be removed because its value is not used, replace the\n-   SSA_NAME with a one relating to a created VAR_DECL and replace all of its\n-   uses too and return true (update_stmt is then issued for the statement by\n-   the caller).  DATA is a pointer to an adjustments vector.  */\n+/* If the statement STMT defines an SSA_NAME of a parameter which is to be\n+   removed because its value is not used, replace the SSA_NAME with a one\n+   relating to a created VAR_DECL together all of its uses and return true.\n+   ADJUSTMENTS is a pointer to an adjustments vector.  */\n \n static bool\n-replace_removed_params_ssa_names (gimple stmt, void *data)\n+replace_removed_params_ssa_names (gimple stmt,\n+\t\t\t\t  ipa_parm_adjustment_vec adjustments)\n {\n-  VEC (ipa_parm_adjustment_t, heap) *adjustments;\n   struct ipa_parm_adjustment *adj;\n   tree lhs, decl, repl, name;\n \n-  adjustments = (VEC (ipa_parm_adjustment_t, heap) *) data;\n   if (gimple_code (stmt) == GIMPLE_PHI)\n     lhs = gimple_phi_result (stmt);\n   else if (is_gimple_assign (stmt))\n@@ -3842,35 +3843,30 @@ replace_removed_params_ssa_names (gimple stmt, void *data)\n   return true;\n }\n \n-/* Callback for scan_function and helper to sra_ipa_modify_assign.  If the\n-   expression *EXPR should be replaced by a reduction of a parameter, do so.\n-   DATA is a pointer to a vector of adjustments.  DONT_CONVERT specifies\n-   whether the function should care about type incompatibility the current and\n-   new expressions.  If it is true, the function will leave incompatibility\n-   issues to the caller.\n-\n-   When called directly by scan_function, DONT_CONVERT is true when the EXPR is\n-   a write (LHS) expression.  */\n+/* If the expression *EXPR should be replaced by a reduction of a parameter, do\n+   so.  ADJUSTMENTS is a pointer to a vector of adjustments.  CONVERT\n+   specifies whether the function should care about type incompatibility the\n+   current and new expressions.  If it is false, the function will leave\n+   incompatibility issues to the caller.  Return true iff the expression\n+   was modified. */\n \n static bool\n-sra_ipa_modify_expr (tree *expr, gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n-\t\t     bool dont_convert, void *data)\n+sra_ipa_modify_expr (tree *expr, bool convert,\n+\t\t     ipa_parm_adjustment_vec adjustments)\n {\n-  ipa_parm_adjustment_vec adjustments;\n   int i, len;\n   struct ipa_parm_adjustment *adj, *cand = NULL;\n   HOST_WIDE_INT offset, size, max_size;\n   tree base, src;\n \n-  adjustments = (VEC (ipa_parm_adjustment_t, heap) *) data;\n   len = VEC_length (ipa_parm_adjustment_t, adjustments);\n \n   if (TREE_CODE (*expr) == BIT_FIELD_REF\n       || TREE_CODE (*expr) == IMAGPART_EXPR\n       || TREE_CODE (*expr) == REALPART_EXPR)\n     {\n       expr = &TREE_OPERAND (*expr, 0);\n-      dont_convert = false;\n+      convert = true;\n     }\n \n   base = get_ref_base_and_extent (*expr, &offset, &size, &max_size);\n@@ -3919,8 +3915,7 @@ sra_ipa_modify_expr (tree *expr, gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  if (!dont_convert\n-      && !useless_type_conversion_p (TREE_TYPE (*expr), cand->type))\n+  if (convert && !useless_type_conversion_p (TREE_TYPE (*expr), cand->type))\n     {\n       tree vce = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (*expr), src);\n       *expr = vce;\n@@ -3930,24 +3925,28 @@ sra_ipa_modify_expr (tree *expr, gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n   return true;\n }\n \n-/* Callback for scan_function to process assign statements.  Performs\n-   essentially the same function like sra_ipa_modify_expr.  */\n+/* If the statement pointed to by STMT_PTR contains any expressions that need\n+   to replaced with a different one as noted by ADJUSTMENTS, do so.  Handle any\n+   potential type incompatibilities (GSI is used to accommodate conversion\n+   statements and must point to the statement).  Return true iff the statement\n+   was modified.  */\n \n-static enum scan_assign_result\n-sra_ipa_modify_assign (gimple *stmt_ptr, gimple_stmt_iterator *gsi, void *data)\n+static bool\n+sra_ipa_modify_assign (gimple *stmt_ptr, gimple_stmt_iterator *gsi,\n+\t\t       ipa_parm_adjustment_vec adjustments)\n {\n   gimple stmt = *stmt_ptr;\n   tree *lhs_p, *rhs_p;\n   bool any;\n \n   if (!gimple_assign_single_p (stmt))\n-    return SRA_SA_NONE;\n+    return false;\n \n   rhs_p = gimple_assign_rhs1_ptr (stmt);\n   lhs_p = gimple_assign_lhs_ptr (stmt);\n \n-  any = sra_ipa_modify_expr (rhs_p, gsi, true, data);\n-  any |= sra_ipa_modify_expr (lhs_p, gsi, true, data);\n+  any = sra_ipa_modify_expr (rhs_p, false, adjustments);\n+  any |= sra_ipa_modify_expr (lhs_p, false, adjustments);\n   if (any)\n     {\n       tree new_rhs = NULL_TREE;\n@@ -3983,10 +3982,94 @@ sra_ipa_modify_assign (gimple *stmt_ptr, gimple_stmt_iterator *gsi, void *data)\n \t  gimple_assign_set_rhs_from_tree (gsi, tmp);\n \t}\n \n-      return SRA_SA_PROCESSED;\n+      return true;\n     }\n \n-  return SRA_SA_NONE;\n+  return false;\n+}\n+\n+/* Traverse the function body and all modifications as described in\n+   ADJUSTMENTS.  */\n+\n+static void\n+ipa_sra_modify_function_body (ipa_parm_adjustment_vec adjustments)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      gimple_stmt_iterator gsi;\n+      bool bb_changed = false;\n+\n+      for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\treplace_removed_params_ssa_names (gsi_stmt (gsi), adjustments);\n+\n+      gsi = gsi_start_bb (bb);\n+      while (!gsi_end_p (gsi))\n+\t{\n+\t  gimple stmt = gsi_stmt (gsi);\n+\t  bool modified = false;\n+\t  tree *t;\n+\t  unsigned i;\n+\n+\t  switch (gimple_code (stmt))\n+\t    {\n+\t    case GIMPLE_RETURN:\n+\t      t = gimple_return_retval_ptr (stmt);\n+\t      if (*t != NULL_TREE)\n+\t\tmodified |= sra_ipa_modify_expr (t, true, adjustments);\n+\t      break;\n+\n+\t    case GIMPLE_ASSIGN:\n+\t      modified |= sra_ipa_modify_assign (&stmt, &gsi, adjustments);\n+\t      modified |= replace_removed_params_ssa_names (stmt, adjustments);\n+\t      break;\n+\n+\t    case GIMPLE_CALL:\n+\t      /* Operands must be processed before the lhs.  */\n+\t      for (i = 0; i < gimple_call_num_args (stmt); i++)\n+\t\t{\n+\t\t  t = gimple_call_arg_ptr (stmt, i);\n+\t\t  modified |= sra_ipa_modify_expr (t, true, adjustments);\n+\t\t}\n+\n+\t      if (gimple_call_lhs (stmt))\n+\t\t{\n+\t\t  t = gimple_call_lhs_ptr (stmt);\n+\t\t  modified |= sra_ipa_modify_expr (t, false, adjustments);\n+\t\t  modified |= replace_removed_params_ssa_names (stmt,\n+\t\t\t\t\t\t\t\tadjustments);\n+\t\t}\n+\t      break;\n+\n+\t    case GIMPLE_ASM:\n+\t      for (i = 0; i < gimple_asm_ninputs (stmt); i++)\n+\t\t{\n+\t\t  t = &TREE_VALUE (gimple_asm_input_op (stmt, i));\n+\t\t  modified |= sra_ipa_modify_expr (t, true, adjustments);\n+\t\t}\n+\t      for (i = 0; i < gimple_asm_noutputs (stmt); i++)\n+\t\t{\n+\t\t  t = &TREE_VALUE (gimple_asm_output_op (stmt, i));\n+\t\t  modified |= sra_ipa_modify_expr (t, false, adjustments);\n+\t\t}\n+\t      break;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\n+\t  if (modified)\n+\t    {\n+\t      bb_changed = true;\n+\t      update_stmt (stmt);\n+\t      maybe_clean_eh_stmt (stmt);\n+\t    }\n+\t  gsi_next (&gsi);\n+\t}\n+      if (bb_changed)\n+\tgimple_purge_dead_eh_edges (bb);\n+    }\n }\n \n /* Call gimple_debug_bind_reset_value on all debug statements describing\n@@ -4013,7 +4096,8 @@ sra_ipa_reset_debug_stmts (ipa_parm_adjustment_vec adjustments)\n \tcontinue;\n       FOR_EACH_IMM_USE_STMT (stmt, ui, name)\n \t{\n-\t  /* All other users must have been removed by scan_function.  */\n+\t  /* All other users must have been removed by\n+\t     ipa_sra_modify_function_body.  */\n \t  gcc_assert (is_gimple_debug (stmt));\n \t  gimple_debug_bind_reset_value (stmt);\n \t  update_stmt (stmt);\n@@ -4131,8 +4215,7 @@ modify_function (struct cgraph_node *node, ipa_parm_adjustment_vec adjustments)\n      as following functions will use what it computed.  */\n   create_abstract_origin (current_function_decl);\n   ipa_modify_formal_parameters (current_function_decl, adjustments, \"ISRA\");\n-  scan_function (sra_ipa_modify_expr, sra_ipa_modify_assign,\n-\t\t replace_removed_params_ssa_names, false, adjustments);\n+  ipa_sra_modify_function_body (adjustments);\n   sra_ipa_reset_debug_stmts (adjustments);\n   convert_callers (node, adjustments);\n   cgraph_make_node_local (node);\n@@ -4224,8 +4307,7 @@ ipa_early_sra (void)\n \t\t\t\t * last_basic_block_for_function (cfun));\n   final_bbs = BITMAP_ALLOC (NULL);\n \n-  scan_function (build_access_from_expr, build_accesses_from_assign,\n-\t\t NULL, true, NULL);\n+  scan_function ();\n   if (encountered_apply_args)\n     {\n       if (dump_file)"}]}