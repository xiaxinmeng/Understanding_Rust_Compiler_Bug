{"sha": "125e025e06060daa5583d98cf47c209dfbef95e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI1ZTAyNWUwNjA2MGRhYTU1ODNkOThjZjQ3YzIwOWRmYmVmOTVlNA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-01-10T14:28:40Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-01-10T14:28:40Z"}, "message": "re PR tree-optimization/34651 (ICE in set_value_range, at tree-vrp.c:321)\n\n2008-01-10  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/34651\n\t* tree-sra.c (sra_build_assignment): Sanitize.  Use the correct\n\ttypes and ordering for masking and converting.\n\n\t* g++.dg/torture/pr34651.C: New testcase.\n\nFrom-SVN: r131442", "tree": {"sha": "bab6ca4972bc76d834d97e22b85ba6b65f1e9a33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bab6ca4972bc76d834d97e22b85ba6b65f1e9a33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/125e025e06060daa5583d98cf47c209dfbef95e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/125e025e06060daa5583d98cf47c209dfbef95e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/125e025e06060daa5583d98cf47c209dfbef95e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/125e025e06060daa5583d98cf47c209dfbef95e4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5817ff8e5f722e2a36ed6982f94d003164c01992", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5817ff8e5f722e2a36ed6982f94d003164c01992", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5817ff8e5f722e2a36ed6982f94d003164c01992"}], "stats": {"total": 174, "additions": 96, "deletions": 78}, "files": [{"sha": "cc61c7050ba3d424572b185cf8f6ceeeeefa933b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/125e025e06060daa5583d98cf47c209dfbef95e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/125e025e06060daa5583d98cf47c209dfbef95e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=125e025e06060daa5583d98cf47c209dfbef95e4", "patch": "@@ -1,3 +1,9 @@\n+2008-01-10  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/34651\n+\t* tree-sra.c (sra_build_assignment): Sanitize.  Use the correct\n+\ttypes and ordering for masking and converting.\n+\n 2008-01-09  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tPR tree-optimization/34017"}, {"sha": "496ef45a8f0ae53406d30f22a39573d631e0629b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/125e025e06060daa5583d98cf47c209dfbef95e4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/125e025e06060daa5583d98cf47c209dfbef95e4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=125e025e06060daa5583d98cf47c209dfbef95e4", "patch": "@@ -1,3 +1,8 @@\n+2008-01-10  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/34651\n+\t* g++.dg/torture/pr34651.C: New testcase.\n+\n 2008-01-09  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tPR tree-optimization/34017"}, {"sha": "2fce4d7a1af76be80d9d86c17e6d410202ed3799", "filename": "gcc/testsuite/g++.dg/torture/pr34651.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/125e025e06060daa5583d98cf47c209dfbef95e4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr34651.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/125e025e06060daa5583d98cf47c209dfbef95e4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr34651.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr34651.C?ref=125e025e06060daa5583d98cf47c209dfbef95e4", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */\n+\n+typedef bool Bool;\n+struct CString {\n+    CString (const char * =__null);\n+    CString & operator += (const CString &);\n+};\n+struct THotKey {\n+   short Key;\n+   Bool Control;\n+   Bool Shift;\n+   Bool Alt;\n+};\n+THotKey m_HotKey;\n+THotKey GetHotKey () { return m_HotKey; }\n+void Serialize ()\n+{\n+   THotKey inHotKey (GetHotKey());\n+   CString outCombinaison (inHotKey.Control\n+\t\t\t   ? ((inHotKey.Alt || inHotKey.Shift)\n+\t\t\t      ? \"ctrl+\" : \"ctrl\")\n+\t\t\t   : __null);\n+   outCombinaison += inHotKey.Alt ? inHotKey.Shift ? \"alt+\" : \"alt\" : \"\";\n+   outCombinaison += inHotKey.Shift ? \"shift\" : \"\";\n+}"}, {"sha": "df6c6dc7be651497810c3800e96f333f6ccf8cb6", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 60, "deletions": 78, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/125e025e06060daa5583d98cf47c209dfbef95e4/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/125e025e06060daa5583d98cf47c209dfbef95e4/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=125e025e06060daa5583d98cf47c209dfbef95e4", "patch": "@@ -2127,30 +2127,37 @@ static tree\n sra_build_assignment (tree dst, tree src)\n {\n   /* Turning BIT_FIELD_REFs into bit operations enables other passes\n-     to do a much better job at optimizing the code.  */\n+     to do a much better job at optimizing the code.\n+     From dst = BIT_FIELD_REF <var, sz, off> we produce\n+\n+\tSR.1 = (scalar type) var;\n+\tSR.2 = SR.1 >> off;\n+\tSR.3 = SR.2 & ((1 << sz) - 1);\n+\t... possible sign extension of SR.3 ...\n+\tdst = (destination type) SR.3;\n+   */\n   if (scalar_bitfield_p (src))\n     {\n-      tree cst, cst2, mask, minshift, maxshift;\n-      tree tmp, var, utype, stype;\n+      tree var, shift, width;\n+      tree utype, stype, stmp, utmp;\n       tree list, stmt;\n       bool unsignedp = BIT_FIELD_REF_UNSIGNED (src);\n \n       var = TREE_OPERAND (src, 0);\n-      cst = TREE_OPERAND (src, 2);\n-      cst2 = size_binop (PLUS_EXPR, TREE_OPERAND (src, 1),\n-\t\t\t TREE_OPERAND (src, 2));\n-\n+      width = TREE_OPERAND (src, 1);\n+      /* The offset needs to be adjusted to a right shift quantity\n+\t depending on the endianess.  */\n       if (BYTES_BIG_ENDIAN)\n \t{\n-\t  maxshift = size_binop (MINUS_EXPR, TYPE_SIZE (TREE_TYPE (var)), cst);\n-\t  minshift = size_binop (MINUS_EXPR, TYPE_SIZE (TREE_TYPE (var)), cst2);\n+\t  tree tmp = size_binop (PLUS_EXPR, width, TREE_OPERAND (src, 2));\n+\t  shift = size_binop (MINUS_EXPR, TYPE_SIZE (TREE_TYPE (var)), tmp);\n \t}\n       else\n-\t{\n-\t  maxshift = cst2;\n-\t  minshift = cst;\n-\t}\n+\tshift = TREE_OPERAND (src, 2);\n \n+      /* In weird cases we have non-integral types for the source or\n+\t destination object.\n+\t ???  For unknown reasons we also want an unsigned scalar type.  */\n       stype = TREE_TYPE (var);\n       if (!INTEGRAL_TYPE_P (stype))\n \tstype = lang_hooks.types.type_for_size (TREE_INT_CST_LOW\n@@ -2166,117 +2173,92 @@ sra_build_assignment (tree dst, tree src)\n \tutype = unsigned_type_for (utype);\n \n       list = NULL;\n+      stmp = make_rename_temp (stype, \"SR\");\n \n-      cst2 = size_binop (MINUS_EXPR, maxshift, minshift);\n-      if (TREE_INT_CST_LOW (cst2) == TYPE_PRECISION (utype))\n-\t{\n-\t  unsignedp = true;\n-\t  mask = NULL_TREE;\n-\t}\n-      else\n-\t{\n-\t  mask = build_int_cst_wide (utype, 1, 0);\n-\t  cst = int_const_binop (LSHIFT_EXPR, mask, cst2, true);\n-\t  mask = int_const_binop (MINUS_EXPR, cst, mask, true);\n-\t}\n-\n-      tmp = make_rename_temp (stype, \"SR\");\n-      if (TYPE_MAIN_VARIANT (TREE_TYPE (var)) != TYPE_MAIN_VARIANT (stype))\n+      /* Convert the base var of the BIT_FIELD_REF to the scalar type\n+\t we use for computation if we cannot use it directly.  */\n+      if (!useless_type_conversion_p (stype, TREE_TYPE (var)))\n \t{\n \t  if (INTEGRAL_TYPE_P (TREE_TYPE (var)))\n-\t    stmt = build_gimple_modify_stmt (tmp,\n+\t    stmt = build_gimple_modify_stmt (stmp,\n \t\t\t\t\t     fold_convert (stype, var));\n \t  else\n-\t    stmt = build_gimple_modify_stmt (tmp,\n+\t    stmt = build_gimple_modify_stmt (stmp,\n \t\t\t\t\t     fold_build1 (VIEW_CONVERT_EXPR,\n \t\t\t\t\t\t\t  stype, var));\n \t  append_to_statement_list (stmt, &list);\n-\n-\t  var = tmp;\n+\t  var = stmp;\n \t}\n \n-      if (!integer_zerop (minshift))\n+      if (!integer_zerop (shift))\n \t{\n-\t  tmp = make_rename_temp (stype, \"SR\");\n-\t  stmt = build_gimple_modify_stmt (tmp,\n+\t  stmt = build_gimple_modify_stmt (stmp,\n \t\t\t\t\t   fold_build2 (RSHIFT_EXPR, stype,\n-\t\t\t\t\t\t\tvar, minshift));\n+\t\t\t\t\t\t\tvar, shift));\n \t  append_to_statement_list (stmt, &list);\n-\n-\t  var = tmp;\n+\t  var = stmp;\n \t}\n \n-      if (TYPE_MAIN_VARIANT (utype) != TYPE_MAIN_VARIANT (stype))\n+      /* If we need a masking operation, produce one.  */\n+      if (TREE_INT_CST_LOW (width) == TYPE_PRECISION (stype))\n+\tunsignedp = true;\n+      else\n \t{\n-\t  if (!mask && unsignedp\n-\t      && (TYPE_MAIN_VARIANT (utype)\n-\t\t  == TYPE_MAIN_VARIANT (TREE_TYPE (dst))))\n-\t    tmp = dst;\n-\t  else\n-\t    tmp = make_rename_temp (utype, \"SR\");\n+\t  tree one = build_int_cst_wide (stype, 1, 0);\n+\t  tree mask = int_const_binop (LSHIFT_EXPR, one, width, 0);\n+\t  mask = int_const_binop (MINUS_EXPR, mask, one, 0);\n \n-\t  stmt = build_gimple_modify_stmt (tmp, fold_convert (utype, var));\n+\t  stmt = build_gimple_modify_stmt (stmp,\n+\t\t\t\t\t   fold_build2 (BIT_AND_EXPR, stype,\n+\t\t\t\t\t\t\tvar, mask));\n \t  append_to_statement_list (stmt, &list);\n-\n-\t  var = tmp;\n+\t  var = stmp;\n \t}\n \n-      if (mask)\n+      /* After shifting and masking, convert to the target type.  */\n+      utmp = stmp;\n+      if (!useless_type_conversion_p (utype, stype))\n \t{\n-\t  if (!unsignedp\n-\t      || (TYPE_MAIN_VARIANT (TREE_TYPE (dst))\n-\t\t  != TYPE_MAIN_VARIANT (utype)))\n-\t    tmp = make_rename_temp (utype, \"SR\");\n-\t  else\n-\t    tmp = dst;\n+\t  utmp = make_rename_temp (utype, \"SR\");\n \n-\t  stmt = build_gimple_modify_stmt (tmp,\n-\t\t\t\t\t   fold_build2 (BIT_AND_EXPR, utype,\n-\t\t\t\t\t\t\tvar, mask));\n+\t  stmt = build_gimple_modify_stmt (utmp, fold_convert (utype, var));\n \t  append_to_statement_list (stmt, &list);\n \n-\t  var = tmp;\n+\t  var = utmp;\n \t}\n \n+      /* Perform sign extension, if required.\n+\t ???  This should never be necessary.  */\n       if (!unsignedp)\n \t{\n \t  tree signbit = int_const_binop (LSHIFT_EXPR,\n \t\t\t\t\t  build_int_cst_wide (utype, 1, 0),\n-\t\t\t\t\t  size_binop (MINUS_EXPR, cst2,\n-\t\t\t\t\t\t      bitsize_int (1)),\n-\t\t\t\t\t  true);\n+\t\t\t\t\t  size_binop (MINUS_EXPR, width,\n+\t\t\t\t\t\t      bitsize_int (1)), 0);\n \n-\t  tmp = make_rename_temp (utype, \"SR\");\n-\t  stmt = build_gimple_modify_stmt (tmp,\n+\t  stmt = build_gimple_modify_stmt (utmp,\n \t\t\t\t\t   fold_build2 (BIT_XOR_EXPR, utype,\n \t\t\t\t\t\t\tvar, signbit));\n \t  append_to_statement_list (stmt, &list);\n \n-\t  var = tmp;\n-\n-\t  if (TYPE_MAIN_VARIANT (TREE_TYPE (dst)) != TYPE_MAIN_VARIANT (utype))\n-\t    tmp = make_rename_temp (utype, \"SR\");\n-\t  else\n-\t    tmp = dst;\n-\n-\t  stmt = build_gimple_modify_stmt (tmp,\n+\t  stmt = build_gimple_modify_stmt (utmp,\n \t\t\t\t\t   fold_build2 (MINUS_EXPR, utype,\n-\t\t\t\t\t\t\tvar, signbit));\n+\t\t\t\t\t\t\tutmp, signbit));\n \t  append_to_statement_list (stmt, &list);\n \n-\t  var = tmp;\n+\t  var = utmp;\n \t}\n \n-      if (var != dst)\n+      /* Finally, move and convert to the destination.  */\n+      if (!useless_type_conversion_p (TREE_TYPE (dst), TREE_TYPE (var)))\n \t{\n \t  if (INTEGRAL_TYPE_P (TREE_TYPE (dst)))\n \t    var = fold_convert (TREE_TYPE (dst), var);\n \t  else\n \t    var = fold_build1 (VIEW_CONVERT_EXPR, TREE_TYPE (dst), var);\n-\n-\t  stmt = build_gimple_modify_stmt (dst, var);\n-\t  append_to_statement_list (stmt, &list);\n \t}\n+      stmt = build_gimple_modify_stmt (dst, var);\n+      append_to_statement_list (stmt, &list);\n \n       return list;\n     }"}]}