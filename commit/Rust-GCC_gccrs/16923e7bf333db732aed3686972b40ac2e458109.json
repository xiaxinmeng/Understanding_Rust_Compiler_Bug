{"sha": "16923e7bf333db732aed3686972b40ac2e458109", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY5MjNlN2JmMzMzZGI3MzJhZWQzNjg2OTcyYjQwYWMyZTQ1ODEwOQ==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2010-12-18T17:10:34Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2010-12-18T17:10:34Z"}, "message": "re PR target/46915 (Wrong code is generated for conditional branch followed by zero length asm)\n\n\tPR target/46915\n\t* config/pa/pa.c (branch_to_delay_slot_p): Use next_active_insn instead\n\tof next_real_insn.  Search forward checking for both ASM_INPUT and\n\tASM_OPERANDS asms until exit condition is found.\n\t(branch_needs_nop_p): Likewise.\n\t(use_skip_p): New function.\n\t(output_cbranch): Use use_skip_p.\n\t(output_bb, output_bvb): Likewise.\n\nFrom-SVN: r168026", "tree": {"sha": "1e81f7c53d72184586caf1560f886f5fa2696c0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1e81f7c53d72184586caf1560f886f5fa2696c0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16923e7bf333db732aed3686972b40ac2e458109", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16923e7bf333db732aed3686972b40ac2e458109", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16923e7bf333db732aed3686972b40ac2e458109", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16923e7bf333db732aed3686972b40ac2e458109/comments", "author": null, "committer": null, "parents": [{"sha": "c50ebc7332db306b3b7e122fb5251605db3bcd96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c50ebc7332db306b3b7e122fb5251605db3bcd96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c50ebc7332db306b3b7e122fb5251605db3bcd96"}], "stats": {"total": 117, "additions": 84, "deletions": 33}, "files": [{"sha": "9536e0a73d86a25907b13872e60e69b5b6063db7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16923e7bf333db732aed3686972b40ac2e458109/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16923e7bf333db732aed3686972b40ac2e458109/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=16923e7bf333db732aed3686972b40ac2e458109", "patch": "@@ -1,3 +1,14 @@\n+2010-12-18  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR target/46915\n+\t* config/pa/pa.c (branch_to_delay_slot_p): Use next_active_insn instead\n+\tof next_real_insn.  Search forward checking for both ASM_INPUT and\n+\tASM_OPERANDS asms until exit condition is found.\n+\t(branch_needs_nop_p): Likewise.\n+\t(use_skip_p): New function.\n+\t(output_cbranch): Use use_skip_p.\n+\t(output_bb, output_bvb): Likewise.\n+\n 2010-12-18  Kai Tietz  <kai.tietz@onevision.com>\n \n \tPR target/36834"}, {"sha": "89f7e500820781bb30310bd289b57379ecc11413", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 73, "deletions": 33, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16923e7bf333db732aed3686972b40ac2e458109/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16923e7bf333db732aed3686972b40ac2e458109/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=16923e7bf333db732aed3686972b40ac2e458109", "patch": "@@ -6188,35 +6188,92 @@ pa_scalar_mode_supported_p (enum machine_mode mode)\n }\n \n /* Return TRUE if INSN, a jump insn, has an unfilled delay slot and\n-   it branches to the next real instruction.  Otherwise, return FALSE.  */\n+   it branches into the delay slot.  Otherwise, return FALSE.  */\n \n static bool\n branch_to_delay_slot_p (rtx insn)\n {\n+  rtx jump_insn;\n+\n   if (dbr_sequence_length ())\n     return FALSE;\n \n-  return next_real_insn (JUMP_LABEL (insn)) == next_real_insn (insn);\n+  jump_insn = next_active_insn (JUMP_LABEL (insn));\n+  while (insn)\n+    {\n+      insn = next_active_insn (insn);\n+      if (jump_insn == insn)\n+\treturn TRUE;\n+\n+      /* We can't rely on the length of asms.  So, we return FALSE when\n+\t the branch is followed by an asm.  */\n+      if (!insn\n+\t  || GET_CODE (PATTERN (insn)) == ASM_INPUT\n+\t  || extract_asm_operands (PATTERN (insn)) != NULL_RTX\n+\t  || get_attr_length (insn) > 0)\n+\tbreak;\n+    }\n+\n+  return FALSE;\n }\n \n-/* Return TRUE if INSN, a jump insn, needs a nop in its delay slot.\n+/* Return TRUE if INSN, a forward jump insn, needs a nop in its delay slot.\n \n    This occurs when INSN has an unfilled delay slot and is followed\n-   by an ASM_INPUT.  Disaster can occur if the ASM_INPUT is empty and\n-   the jump branches into the delay slot.  So, we add a nop in the delay\n-   slot just to be safe.  This messes up our instruction count, but we\n-   don't know how big the ASM_INPUT insn is anyway.  */\n+   by an asm.  Disaster can occur if the asm is empty and the jump\n+   branches into the delay slot.  So, we add a nop in the delay slot\n+   when this occurs.  */\n \n static bool\n branch_needs_nop_p (rtx insn)\n {\n-  rtx next_insn;\n+  rtx jump_insn;\n \n   if (dbr_sequence_length ())\n     return FALSE;\n \n-  next_insn = next_real_insn (insn);\n-  return GET_CODE (PATTERN (next_insn)) == ASM_INPUT;\n+  jump_insn = next_active_insn (JUMP_LABEL (insn));\n+  while (insn)\n+    {\n+      insn = next_active_insn (insn);\n+      if (!insn || jump_insn == insn)\n+\treturn TRUE;\n+\n+      if (!(GET_CODE (PATTERN (insn)) == ASM_INPUT\n+\t   || extract_asm_operands (PATTERN (insn)) != NULL_RTX)\n+\t  && get_attr_length (insn) > 0)\n+\tbreak;\n+    }\n+\n+  return FALSE;\n+}\n+\n+/* Return TRUE if INSN, a forward jump insn, can use nullification\n+   to skip the following instruction.  This avoids an extra cycle due\n+   to a mis-predicted branch when we fall through.  */\n+\n+static bool\n+use_skip_p (rtx insn)\n+{\n+  rtx jump_insn = next_active_insn (JUMP_LABEL (insn));\n+\n+  while (insn)\n+    {\n+      insn = next_active_insn (insn);\n+\n+      /* We can't rely on the length of asms, so we can't skip asms.  */\n+      if (!insn\n+\t  || GET_CODE (PATTERN (insn)) == ASM_INPUT\n+\t  || extract_asm_operands (PATTERN (insn)) != NULL_RTX)\n+\tbreak;\n+      if (get_attr_length (insn) == 4\n+\t  && jump_insn == next_active_insn (insn))\n+\treturn TRUE;\n+      if (get_attr_length (insn) > 0)\n+\tbreak;\n+    }\n+\n+  return FALSE;\n }\n \n /* This routine handles all the normal conditional branch sequences we\n@@ -6230,7 +6287,7 @@ const char *\n output_cbranch (rtx *operands, int negated, rtx insn)\n {\n   static char buf[100];\n-  int useskip = 0;\n+  bool useskip;\n   int nullify = INSN_ANNULLED_BRANCH_P (insn);\n   int length = get_attr_length (insn);\n   int xdelay;\n@@ -6268,12 +6325,7 @@ output_cbranch (rtx *operands, int negated, rtx insn)\n   /* A forward branch over a single nullified insn can be done with a\n      comclr instruction.  This avoids a single cycle penalty due to\n      mis-predicted branch if we fall through (branch not taken).  */\n-  if (length == 4\n-      && next_real_insn (insn) != 0\n-      && get_attr_length (next_real_insn (insn)) == 4\n-      && JUMP_LABEL (insn) == next_nonnote_insn (next_real_insn (insn))\n-      && nullify)\n-    useskip = 1;\n+  useskip = (length == 4 && nullify) ? use_skip_p (insn) : FALSE;\n \n   switch (length)\n     {\n@@ -6561,7 +6613,7 @@ const char *\n output_bb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)\n {\n   static char buf[100];\n-  int useskip = 0;\n+  bool useskip;\n   int nullify = INSN_ANNULLED_BRANCH_P (insn);\n   int length = get_attr_length (insn);\n   int xdelay;\n@@ -6587,13 +6639,7 @@ output_bb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)\n   /* A forward branch over a single nullified insn can be done with a\n      extrs instruction.  This avoids a single cycle penalty due to\n      mis-predicted branch if we fall through (branch not taken).  */\n-\n-  if (length == 4\n-      && next_real_insn (insn) != 0\n-      && get_attr_length (next_real_insn (insn)) == 4\n-      && JUMP_LABEL (insn) == next_nonnote_insn (next_real_insn (insn))\n-      && nullify)\n-    useskip = 1;\n+  useskip = (length == 4 && nullify) ? use_skip_p (insn) : FALSE;\n \n   switch (length)\n     {\n@@ -6752,7 +6798,7 @@ const char *\n output_bvb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)\n {\n   static char buf[100];\n-  int useskip = 0;\n+  bool useskip;\n   int nullify = INSN_ANNULLED_BRANCH_P (insn);\n   int length = get_attr_length (insn);\n   int xdelay;\n@@ -6778,13 +6824,7 @@ output_bvb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)\n   /* A forward branch over a single nullified insn can be done with a\n      extrs instruction.  This avoids a single cycle penalty due to\n      mis-predicted branch if we fall through (branch not taken).  */\n-\n-  if (length == 4\n-      && next_real_insn (insn) != 0\n-      && get_attr_length (next_real_insn (insn)) == 4\n-      && JUMP_LABEL (insn) == next_nonnote_insn (next_real_insn (insn))\n-      && nullify)\n-    useskip = 1;\n+  useskip = (length == 4 && nullify) ? use_skip_p (insn) : FALSE;\n \n   switch (length)\n     {"}]}