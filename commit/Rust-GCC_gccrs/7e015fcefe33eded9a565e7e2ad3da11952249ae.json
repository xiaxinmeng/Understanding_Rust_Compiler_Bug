{"sha": "7e015fcefe33eded9a565e7e2ad3da11952249ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2UwMTVmY2VmZTMzZWRlZDlhNTY1ZTdlMmFkM2RhMTE5NTIyNDlhZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-11-28T08:57:43Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-11-28T08:57:43Z"}, "message": "re PR tree-optimization/64084 (match-and-simplify prefers complex matches)\n\n2014-11-28  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/64084\n\t* genmatch.c (dt_node::gen_kids_1): New function, split out\n\tfrom dt_node::gen_kids.\n\t(decision_tree::cmp_node): DT_TRUE are generally not equal.\n\t(decision_tree::find_node): Treat DT_TRUE as barrier for\n\tnode CSE on the same level.\n\t(dt_node::append_node): Do not keep DT_TRUE last.\n\t(dt_node::gen_kids): Emit code after each DT_TRUE node seen.\n\n\t* gcc.dg/tree-ssa/ssa-ccp-34.c: New testcase.\n\t* gcc.dg/tree-ssa/forwprop-31.c: Likewise.\n\nFrom-SVN: r218141", "tree": {"sha": "356b7102afa2ca34e687601a0c8e4114bd1500da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/356b7102afa2ca34e687601a0c8e4114bd1500da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e015fcefe33eded9a565e7e2ad3da11952249ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e015fcefe33eded9a565e7e2ad3da11952249ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e015fcefe33eded9a565e7e2ad3da11952249ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e015fcefe33eded9a565e7e2ad3da11952249ae/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "abd5932ea9a0b502fa69e7a7d90d445331e2a4f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abd5932ea9a0b502fa69e7a7d90d445331e2a4f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abd5932ea9a0b502fa69e7a7d90d445331e2a4f5"}], "stats": {"total": 116, "additions": 97, "deletions": 19}, "files": [{"sha": "a9e4eca79c5449658b706ed8ee58f5ffb8d91885", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e015fcefe33eded9a565e7e2ad3da11952249ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e015fcefe33eded9a565e7e2ad3da11952249ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e015fcefe33eded9a565e7e2ad3da11952249ae", "patch": "@@ -1,3 +1,14 @@\n+2014-11-28  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/64084\n+\t* genmatch.c (dt_node::gen_kids_1): New function, split out\n+\tfrom dt_node::gen_kids.\n+\t(decision_tree::cmp_node): DT_TRUE are generally not equal.\n+\t(decision_tree::find_node): Treat DT_TRUE as barrier for\n+\tnode CSE on the same level.\n+\t(dt_node::append_node): Do not keep DT_TRUE last.\n+\t(dt_node::gen_kids): Emit code after each DT_TRUE node seen.\n+\n 2014-11-28  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \t* config/arm/t-aprofile (MULTILIB_MATCHES): New entry for"}, {"sha": "7cfd3544628974c2f9ea943106f5532092f258d5", "filename": "gcc/genmatch.c", "status": "modified", "additions": 52, "deletions": 19, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e015fcefe33eded9a565e7e2ad3da11952249ae/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e015fcefe33eded9a565e7e2ad3da11952249ae/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=7e015fcefe33eded9a565e7e2ad3da11952249ae", "patch": "@@ -1098,6 +1098,9 @@ struct dt_node\n   virtual void gen (FILE *, bool) {}\n \n   void gen_kids (FILE *, bool);\n+  void gen_kids_1 (FILE *, bool,\n+\t\t   vec<dt_operand *>, vec<dt_operand *>, vec<dt_operand *>,\n+\t\t   vec<dt_operand *>, vec<dt_operand *>, vec<dt_node *>);\n };\n \n /* Generic decision tree node used for DT_OPERAND and DT_MATCH.  */\n@@ -1203,9 +1206,12 @@ decision_tree::cmp_node (dt_node *n1, dt_node *n2)\n   if (!n1 || !n2 || n1->type != n2->type)\n     return false;\n \n-  if (n1 == n2 || n1->type == dt_node::DT_TRUE)\n+  if (n1 == n2)\n     return true;\n \n+  if (n1->type == dt_node::DT_TRUE)\n+    return false;\n+\n   if (n1->type == dt_node::DT_OPERAND)\n     return cmp_operand ((as_a<dt_operand *> (n1))->op,\n \t\t\t(as_a<dt_operand *> (n2))->op);\n@@ -1220,10 +1226,21 @@ decision_tree::cmp_node (dt_node *n1, dt_node *n2)\n dt_node *\n decision_tree::find_node (vec<dt_node *>& ops, dt_node *p)\n {\n-  for (unsigned i = 0; i < ops.length (); ++i)\n-    if (decision_tree::cmp_node (ops[i], p))\n-      return ops[i];\n-\n+  /* We can merge adjacent DT_TRUE.  */\n+  if (p->type == dt_node::DT_TRUE\n+      && !ops.is_empty ()\n+      && ops.last ()->type == dt_node::DT_TRUE)\n+    return ops.last ();\n+  for (int i = ops.length () - 1; i >= 0; --i)\n+    {\n+      /* But we can't merge across DT_TRUE nodes as they serve as\n+         pattern order barriers to make sure that patterns apply\n+\t in order of appearance in case multiple matches are possible.  */\n+      if (ops[i]->type == dt_node::DT_TRUE)\n+\treturn NULL;\n+      if (decision_tree::cmp_node (ops[i], p))\n+\treturn ops[i];\n+    }\n   return NULL;\n }\n \n@@ -1242,15 +1259,6 @@ dt_node::append_node (dt_node *n)\n   kids.safe_push (n);\n   n->level = this->level + 1;\n \n-  unsigned len = kids.length ();\n-\n-  if (len > 1 && kids[len - 2]->type == dt_node::DT_TRUE)\n-    {\n-      dt_node *p = kids[len - 2];\n-      kids[len - 2] = kids[len - 1];\n-      kids[len - 1] = p;\n-    }\n-\n   return n;\n }\n \n@@ -2006,7 +2014,6 @@ dt_node::gen_kids (FILE *f, bool gimple)\n   auto_vec<dt_operand *> generic_fns;\n   auto_vec<dt_operand *> preds;\n   auto_vec<dt_node *> others;\n-  dt_node *true_operand = NULL;\n \n   for (unsigned i = 0; i < kids.length (); ++i)\n     {\n@@ -2044,11 +2051,40 @@ dt_node::gen_kids (FILE *f, bool gimple)\n \t       || kids[i]->type == dt_node::DT_SIMPLIFY)\n \tothers.safe_push (kids[i]);\n       else if (kids[i]->type == dt_node::DT_TRUE)\n-\ttrue_operand = kids[i];\n+\t{\n+\t  /* A DT_TRUE operand serves as a barrier - generate code now\n+\t     for what we have collected sofar.  */\n+\t  gen_kids_1 (f, gimple, gimple_exprs, generic_exprs,\n+\t\t      fns, generic_fns, preds, others);\n+\t  /* And output the true operand itself.  */\n+\t  kids[i]->gen (f, gimple);\n+\t  gimple_exprs.truncate (0);\n+\t  generic_exprs.truncate (0);\n+\t  fns.truncate (0);\n+\t  generic_fns.truncate (0);\n+\t  preds.truncate (0);\n+\t  others.truncate (0);\n+\t}\n       else\n \tgcc_unreachable ();\n     }\n \n+  /* Generate code for the remains.  */\n+  gen_kids_1 (f, gimple, gimple_exprs, generic_exprs,\n+\t      fns, generic_fns, preds, others);\n+}\n+\n+/* Generate matching code for the children of the decision tree node.  */\n+\n+void\n+dt_node::gen_kids_1 (FILE *f, bool gimple,\n+\t\t     vec<dt_operand *> gimple_exprs,\n+\t\t     vec<dt_operand *> generic_exprs,\n+\t\t     vec<dt_operand *> fns,\n+\t\t     vec<dt_operand *> generic_fns,\n+\t\t     vec<dt_operand *> preds,\n+\t\t     vec<dt_node *> others)\n+{\n   char buf[128];\n   char *kid_opname = buf;\n \n@@ -2200,9 +2236,6 @@ dt_node::gen_kids (FILE *f, bool gimple)\n \n   for (unsigned i = 0; i < others.length (); ++i)\n     others[i]->gen (f, gimple);\n-\n-  if (true_operand)\n-    true_operand->gen (f, gimple);\n }\n \n /* Generate matching code for the decision tree operand.  */"}, {"sha": "4647a46595d6f5bf93b4c2a1b201487949d749bd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e015fcefe33eded9a565e7e2ad3da11952249ae/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e015fcefe33eded9a565e7e2ad3da11952249ae/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7e015fcefe33eded9a565e7e2ad3da11952249ae", "patch": "@@ -1,3 +1,9 @@\n+2014-11-28  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/64084\n+\t* gcc.dg/tree-ssa/ssa-ccp-34.c: New testcase.\n+\t* gcc.dg/tree-ssa/forwprop-31.c: Likewise.\n+\n 2014-11-27  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/64088"}, {"sha": "ddb376f55985b1db59631083f44a5c42a4346f62", "filename": "gcc/testsuite/gcc.dg/tree-ssa/forwprop-31.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e015fcefe33eded9a565e7e2ad3da11952249ae/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e015fcefe33eded9a565e7e2ad3da11952249ae/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fforwprop-31.c?ref=7e015fcefe33eded9a565e7e2ad3da11952249ae", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fno-tree-ccp -fdump-tree-forwprop1\" } */\n+\n+int foo (int x)\n+{\n+  int y = 0;\n+  int z = x + 1;\n+  int w = z + y; /* becomes z */\n+  return w - z; /* becomes 0 */\n+}\n+\n+/* The original y = 0 stmt is also retained.  */\n+/* { dg-final { scan-tree-dump-times \"= 0;\" 2 \"forwprop1\" } } */\n+/* { dg-final { scan-tree-dump-times \"-\" 0 \"forwprop1\" } } */\n+/* { dg-final { scan-tree-dump-times \"\\\\+\" 1 \"forwprop1\" } } */\n+/* { dg-final { cleanup-tree-dump \"forwprop1\" } } */"}, {"sha": "5d12beaf4cdf51291b0b06837f80e8e07caff4ce", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-34.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e015fcefe33eded9a565e7e2ad3da11952249ae/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-34.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e015fcefe33eded9a565e7e2ad3da11952249ae/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-34.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-34.c?ref=7e015fcefe33eded9a565e7e2ad3da11952249ae", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-ccp1\" } */\n+\n+int foo (int x)\n+{\n+  int y = 0;\n+  int z = x + 1;\n+  return z + y;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"\\\\+\" 1 \"ccp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"ccp1\" } } */"}]}