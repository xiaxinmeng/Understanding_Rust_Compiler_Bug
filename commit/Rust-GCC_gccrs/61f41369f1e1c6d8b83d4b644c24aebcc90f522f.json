{"sha": "61f41369f1e1c6d8b83d4b644c24aebcc90f522f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFmNDEzNjlmMWUxYzZkOGI4M2Q0YjY0NGMyNGFlYmNjOTBmNTIyZg==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2016-10-12T15:34:39Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2016-10-12T15:34:39Z"}, "message": "rs6000: Separate shrink-wrapping\n\nThis implements the hooks for separate shrink-wrapping for rs6000.\nIt handles GPRs and LR.  The GPRs get a component number corresponding\nto their register number; LR gets component number 0.\n\n\n\t* config/rs6000/rs6000.c (machine_function): Add new fields\n\tgpr_is_wrapped_separately and lr_is_wrapped_separately.\n\t(TARGET_SHRINK_WRAP_GET_SEPARATE_COMPONENTS,\n\tTARGET_SHRINK_WRAP_COMPONENTS_FOR_BB,\n\tTARGET_SHRINK_WRAP_DISQUALIFY_COMPONENTS,\n\tTARGET_SHRINK_WRAP_EMIT_PROLOGUE_COMPONENTS,\n\tTARGET_SHRINK_WRAP_EMIT_EPILOGUE_COMPONENTS,\n\tTARGET_SHRINK_WRAP_SET_HANDLED_COMPONENTS): Define.\n\t(rs6000_get_separate_components): New function.\n\t(rs6000_components_for_bb): New function.\n\t(rs6000_disqualify_components): New function.\n\t(rs6000_emit_prologue_components): New function.\n\t(rs6000_emit_epilogue_components): New function.\n\t(rs6000_set_handled_components): New function.\n\t(rs6000_emit_prologue): Don't emit LR save if lr_is_wrapped_separately.\n\tDon't emit GPR saves if gpr_is_wrapped_separately for that register.\n\t(restore_saved_lr): Don't restore LR if lr_is_wrapped_separately.\n\t(rs6000_emit_epilogue): Don't emit GPR restores if\n\tgpr_is_wrapped_separately for that register.  Don't make a\n\tREG_CFA_RESTORE note for registers we did not restore, either.\n\nFrom-SVN: r241065", "tree": {"sha": "57e6c0241ef8227a5614c375428a61b6023c3c17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57e6c0241ef8227a5614c375428a61b6023c3c17"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61f41369f1e1c6d8b83d4b644c24aebcc90f522f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61f41369f1e1c6d8b83d4b644c24aebcc90f522f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61f41369f1e1c6d8b83d4b644c24aebcc90f522f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61f41369f1e1c6d8b83d4b644c24aebcc90f522f/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aa07dfe7a053e6c7faad05c87306ee6829356eb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa07dfe7a053e6c7faad05c87306ee6829356eb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa07dfe7a053e6c7faad05c87306ee6829356eb3"}], "stats": {"total": 292, "additions": 276, "deletions": 16}, "files": [{"sha": "3a67339b3b88695fa050b908be0c87bcde6bb2a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f41369f1e1c6d8b83d4b644c24aebcc90f522f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f41369f1e1c6d8b83d4b644c24aebcc90f522f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61f41369f1e1c6d8b83d4b644c24aebcc90f522f", "patch": "@@ -1,3 +1,26 @@\n+2016-10-12  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* config/rs6000/rs6000.c (machine_function): Add new fields\n+\tgpr_is_wrapped_separately and lr_is_wrapped_separately.\n+\t(TARGET_SHRINK_WRAP_GET_SEPARATE_COMPONENTS,\n+\tTARGET_SHRINK_WRAP_COMPONENTS_FOR_BB,\n+\tTARGET_SHRINK_WRAP_DISQUALIFY_COMPONENTS,\n+\tTARGET_SHRINK_WRAP_EMIT_PROLOGUE_COMPONENTS,\n+\tTARGET_SHRINK_WRAP_EMIT_EPILOGUE_COMPONENTS,\n+\tTARGET_SHRINK_WRAP_SET_HANDLED_COMPONENTS): Define.\n+\t(rs6000_get_separate_components): New function.\n+\t(rs6000_components_for_bb): New function.\n+\t(rs6000_disqualify_components): New function.\n+\t(rs6000_emit_prologue_components): New function.\n+\t(rs6000_emit_epilogue_components): New function.\n+\t(rs6000_set_handled_components): New function.\n+\t(rs6000_emit_prologue): Don't emit LR save if lr_is_wrapped_separately.\n+\tDon't emit GPR saves if gpr_is_wrapped_separately for that register.\n+\t(restore_saved_lr): Don't restore LR if lr_is_wrapped_separately.\n+\t(rs6000_emit_epilogue): Don't emit GPR restores if\n+\tgpr_is_wrapped_separately for that register.  Don't make a\n+\tREG_CFA_RESTORE note for registers we did not restore, either.\n+\n 2016-10-12  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* function.c (thread_prologue_and_epilogue_insns): Call"}, {"sha": "1110ee260ab8a60c24a2a3eb71348d29c8c68353", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 253, "deletions": 16, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61f41369f1e1c6d8b83d4b644c24aebcc90f522f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61f41369f1e1c6d8b83d4b644c24aebcc90f522f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=61f41369f1e1c6d8b83d4b644c24aebcc90f522f", "patch": "@@ -153,6 +153,10 @@ typedef struct GTY(()) machine_function\n   bool split_stack_argp_used;\n   /* Flag if r2 setup is needed with ELFv2 ABI.  */\n   bool r2_setup_needed;\n+  /* The components already handled by separate shrink-wrapping, which should\n+     not be considered by the prologue and epilogue.  */\n+  bool gpr_is_wrapped_separately[32];\n+  bool lr_is_wrapped_separately;\n } machine_function;\n \n /* Support targetm.vectorize.builtin_mask_for_load.  */\n@@ -1522,6 +1526,19 @@ static const struct attribute_spec rs6000_attribute_table[] =\n #undef TARGET_SET_UP_BY_PROLOGUE\n #define TARGET_SET_UP_BY_PROLOGUE rs6000_set_up_by_prologue\n \n+#undef TARGET_SHRINK_WRAP_GET_SEPARATE_COMPONENTS\n+#define TARGET_SHRINK_WRAP_GET_SEPARATE_COMPONENTS rs6000_get_separate_components\n+#undef TARGET_SHRINK_WRAP_COMPONENTS_FOR_BB\n+#define TARGET_SHRINK_WRAP_COMPONENTS_FOR_BB rs6000_components_for_bb\n+#undef TARGET_SHRINK_WRAP_DISQUALIFY_COMPONENTS\n+#define TARGET_SHRINK_WRAP_DISQUALIFY_COMPONENTS rs6000_disqualify_components\n+#undef TARGET_SHRINK_WRAP_EMIT_PROLOGUE_COMPONENTS\n+#define TARGET_SHRINK_WRAP_EMIT_PROLOGUE_COMPONENTS rs6000_emit_prologue_components\n+#undef TARGET_SHRINK_WRAP_EMIT_EPILOGUE_COMPONENTS\n+#define TARGET_SHRINK_WRAP_EMIT_EPILOGUE_COMPONENTS rs6000_emit_epilogue_components\n+#undef TARGET_SHRINK_WRAP_SET_HANDLED_COMPONENTS\n+#define TARGET_SHRINK_WRAP_SET_HANDLED_COMPONENTS rs6000_set_handled_components\n+\n #undef TARGET_EXTRA_LIVE_ON_ENTRY\n #define TARGET_EXTRA_LIVE_ON_ENTRY rs6000_live_on_entry\n \n@@ -27411,6 +27428,212 @@ rs6000_global_entry_point_needed_p (void)\n   return cfun->machine->r2_setup_needed;\n }\n \n+/* Implement TARGET_SHRINK_WRAP_GET_SEPARATE_COMPONENTS.  */\n+static sbitmap\n+rs6000_get_separate_components (void)\n+{\n+  rs6000_stack_t *info = rs6000_stack_info ();\n+\n+  if (!(info->savres_strategy & SAVE_INLINE_GPRS)\n+      || !(info->savres_strategy & REST_INLINE_GPRS)\n+      || WORLD_SAVE_P (info))\n+    return NULL;\n+\n+  sbitmap components = sbitmap_alloc (32);\n+  bitmap_clear (components);\n+\n+  /* The GPRs we need saved to the frame.  */\n+  int reg_size = TARGET_32BIT ? 4 : 8;\n+  int offset = info->gp_save_offset;\n+  if (info->push_p)\n+    offset += info->total_size;\n+\n+  for (unsigned regno = info->first_gp_reg_save; regno < 32; regno++)\n+    {\n+      if (IN_RANGE (offset, -0x8000, 0x7fff)\n+\t  && rs6000_reg_live_or_pic_offset_p (regno))\n+\tbitmap_set_bit (components, regno);\n+\n+      offset += reg_size;\n+    }\n+\n+  /* Don't mess with the hard frame pointer.  */\n+  if (frame_pointer_needed)\n+    bitmap_clear_bit (components, HARD_FRAME_POINTER_REGNUM);\n+\n+  /* Don't mess with the fixed TOC register.  */\n+  if ((TARGET_TOC && TARGET_MINIMAL_TOC)\n+      || (flag_pic == 1 && DEFAULT_ABI == ABI_V4)\n+      || (flag_pic && DEFAULT_ABI == ABI_DARWIN))\n+    bitmap_clear_bit (components, RS6000_PIC_OFFSET_TABLE_REGNUM);\n+\n+  /* Optimize LR save and restore if we can.  This is component 0.  */\n+  if (info->lr_save_p\n+      && !(flag_pic && (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_DARWIN)))\n+    {\n+      offset = info->lr_save_offset;\n+      if (info->push_p)\n+\toffset += info->total_size;\n+      if (IN_RANGE (offset, -0x8000, 0x7fff))\n+\tbitmap_set_bit (components, 0);\n+    }\n+\n+  return components;\n+}\n+\n+/* Implement TARGET_SHRINK_WRAP_COMPONENTS_FOR_BB.  */\n+static sbitmap\n+rs6000_components_for_bb (basic_block bb)\n+{\n+  rs6000_stack_t *info = rs6000_stack_info ();\n+\n+  bitmap in = DF_LIVE_IN (bb);\n+  bitmap gen = &DF_LIVE_BB_INFO (bb)->gen;\n+  bitmap kill = &DF_LIVE_BB_INFO (bb)->kill;\n+\n+  sbitmap components = sbitmap_alloc (32);\n+  bitmap_clear (components);\n+\n+  /* GPRs are used in a bb if they are in the IN, GEN, or KILL sets.  */\n+  for (unsigned regno = info->first_gp_reg_save; regno < 32; regno++)\n+    if (bitmap_bit_p (in, regno)\n+\t|| bitmap_bit_p (gen, regno)\n+\t|| bitmap_bit_p (kill, regno))\n+      bitmap_set_bit (components, regno);\n+\n+  /* LR needs to be saved around a bb if it is killed in that bb.  */\n+  if (bitmap_bit_p (gen, LR_REGNO)\n+      || bitmap_bit_p (kill, LR_REGNO))\n+    bitmap_set_bit (components, 0);\n+\n+  return components;\n+}\n+\n+/* Implement TARGET_SHRINK_WRAP_DISQUALIFY_COMPONENTS.  */\n+static void\n+rs6000_disqualify_components (sbitmap components, edge e,\n+\t\t\t      sbitmap edge_components, bool /*is_prologue*/)\n+{\n+  /* Our LR pro/epilogue code moves LR via R0, so R0 had better not be\n+     live where we want to place that code.  */\n+  if (bitmap_bit_p (edge_components, 0)\n+      && bitmap_bit_p (DF_LIVE_IN (e->dest), 0))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Disqualifying LR because GPR0 is live \"\n+\t\t \"on entry to bb %d\\n\", e->dest->index);\n+      bitmap_clear_bit (components, 0);\n+    }\n+}\n+\n+/* Implement TARGET_SHRINK_WRAP_EMIT_PROLOGUE_COMPONENTS.  */\n+static void\n+rs6000_emit_prologue_components (sbitmap components)\n+{\n+  rs6000_stack_t *info = rs6000_stack_info ();\n+  rtx ptr_reg = gen_rtx_REG (Pmode, frame_pointer_needed\n+\t\t\t     ? HARD_FRAME_POINTER_REGNUM\n+\t\t\t     : STACK_POINTER_REGNUM);\n+  int reg_size = TARGET_32BIT ? 4 : 8;\n+\n+  /* Prologue for LR.  */\n+  if (bitmap_bit_p (components, 0))\n+    {\n+      rtx reg = gen_rtx_REG (Pmode, 0);\n+      rtx_insn *insn = emit_move_insn (reg, gen_rtx_REG (Pmode, LR_REGNO));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      add_reg_note (insn, REG_CFA_REGISTER, NULL);\n+\n+      int offset = info->lr_save_offset;\n+      if (info->push_p)\n+\toffset += info->total_size;\n+\n+      insn = emit_insn (gen_frame_store (reg, ptr_reg, offset));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      rtx lr = gen_rtx_REG (Pmode, LR_REGNO);\n+      rtx mem = copy_rtx (SET_DEST (single_set (insn)));\n+      add_reg_note (insn, REG_CFA_OFFSET, gen_rtx_SET (mem, lr));\n+    }\n+\n+  /* Prologue for the GPRs.  */\n+  int offset = info->gp_save_offset;\n+  if (info->push_p)\n+    offset += info->total_size;\n+\n+  for (int i = info->first_gp_reg_save; i < 32; i++)\n+    {\n+      if (bitmap_bit_p (components, i))\n+\t{\n+\t  rtx reg = gen_rtx_REG (Pmode, i);\n+\t  rtx_insn *insn = emit_insn (gen_frame_store (reg, ptr_reg, offset));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  rtx set = copy_rtx (single_set (insn));\n+\t  add_reg_note (insn, REG_CFA_OFFSET, set);\n+\t}\n+\n+      offset += reg_size;\n+    }\n+}\n+\n+/* Implement TARGET_SHRINK_WRAP_EMIT_EPILOGUE_COMPONENTS.  */\n+static void\n+rs6000_emit_epilogue_components (sbitmap components)\n+{\n+  rs6000_stack_t *info = rs6000_stack_info ();\n+  rtx ptr_reg = gen_rtx_REG (Pmode, frame_pointer_needed\n+\t\t\t     ? HARD_FRAME_POINTER_REGNUM\n+\t\t\t     : STACK_POINTER_REGNUM);\n+  int reg_size = TARGET_32BIT ? 4 : 8;\n+\n+  /* Epilogue for the GPRs.  */\n+  int offset = info->gp_save_offset;\n+  if (info->push_p)\n+    offset += info->total_size;\n+\n+  for (int i = info->first_gp_reg_save; i < 32; i++)\n+    {\n+      if (bitmap_bit_p (components, i))\n+\t{\n+\t  rtx reg = gen_rtx_REG (Pmode, i);\n+\t  rtx_insn *insn = emit_insn (gen_frame_load (reg, ptr_reg, offset));\n+\t  RTX_FRAME_RELATED_P (insn) = 1;\n+\t  add_reg_note (insn, REG_CFA_RESTORE, reg);\n+\t}\n+\n+      offset += reg_size;\n+    }\n+\n+  /* Epilogue for LR.  */\n+  if (bitmap_bit_p (components, 0))\n+    {\n+      int offset = info->lr_save_offset;\n+      if (info->push_p)\n+\toffset += info->total_size;\n+\n+      rtx reg = gen_rtx_REG (Pmode, 0);\n+      rtx_insn *insn = emit_insn (gen_frame_load (reg, ptr_reg, offset));\n+\n+      rtx lr = gen_rtx_REG (Pmode, LR_REGNO);\n+      insn = emit_move_insn (lr, reg);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+      add_reg_note (insn, REG_CFA_RESTORE, lr);\n+    }\n+}\n+\n+/* Implement TARGET_SHRINK_WRAP_SET_HANDLED_COMPONENTS.  */\n+static void\n+rs6000_set_handled_components (sbitmap components)\n+{\n+  rs6000_stack_t *info = rs6000_stack_info ();\n+\n+  for (int i = info->first_gp_reg_save; i < 32; i++)\n+    if (bitmap_bit_p (components, i))\n+      cfun->machine->gpr_is_wrapped_separately[i] = true;\n+\n+  if (bitmap_bit_p (components, 0))\n+    cfun->machine->lr_is_wrapped_separately = true;\n+}\n+\n /* Emit function prologue as insns.  */\n \n void\n@@ -27668,7 +27891,8 @@ rs6000_emit_prologue (void)\n     }\n \n   /* If we use the link register, get it into r0.  */\n-  if (!WORLD_SAVE_P (info) && info->lr_save_p)\n+  if (!WORLD_SAVE_P (info) && info->lr_save_p\n+      && !cfun->machine->lr_is_wrapped_separately)\n     {\n       rtx addr, reg, mem;\n \n@@ -27896,13 +28120,16 @@ rs6000_emit_prologue (void)\n     }\n   else if (!WORLD_SAVE_P (info))\n     {\n-      int i;\n-      for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n-\tif (rs6000_reg_live_or_pic_offset_p (info->first_gp_reg_save + i))\n-\t  emit_frame_save (frame_reg_rtx, reg_mode,\n-\t\t\t   info->first_gp_reg_save + i,\n-\t\t\t   info->gp_save_offset + frame_off + reg_size * i,\n-\t\t\t   sp_off - frame_off);\n+      int offset = info->gp_save_offset + frame_off;\n+      for (int i = info->first_gp_reg_save; i < 32; i++)\n+\t{\n+\t  if (rs6000_reg_live_or_pic_offset_p (i)\n+\t      && !cfun->machine->gpr_is_wrapped_separately[i])\n+\t    emit_frame_save (frame_reg_rtx, reg_mode, i, offset,\n+\t\t\t     sp_off - frame_off);\n+\n+\t  offset += reg_size;\n+\t}\n     }\n \n   if (crtl->calls_eh_return)\n@@ -28825,7 +29052,9 @@ rs6000_emit_epilogue (int sibcall)\n \t\t&& (restoring_FPRs_inline\n \t\t    || (strategy & REST_NOINLINE_FPRS_DOESNT_RESTORE_LR))\n \t\t&& (restoring_GPRs_inline\n-\t\t    || info->first_fp_reg_save < 64));\n+\t\t    || info->first_fp_reg_save < 64)\n+\t\t&& !cfun->machine->lr_is_wrapped_separately);\n+\n \n   if (WORLD_SAVE_P (info))\n     {\n@@ -29460,12 +29689,18 @@ rs6000_emit_epilogue (int sibcall)\n     }\n   else\n     {\n-      for (i = 0; i < 32 - info->first_gp_reg_save; i++)\n-\tif (rs6000_reg_live_or_pic_offset_p (info->first_gp_reg_save + i))\n-\t  emit_insn (gen_frame_load\n-\t\t     (gen_rtx_REG (reg_mode, info->first_gp_reg_save + i),\n-\t\t      frame_reg_rtx,\n-\t\t      info->gp_save_offset + frame_off + reg_size * i));\n+      int offset = info->gp_save_offset + frame_off;\n+      for (i = info->first_gp_reg_save; i < 32; i++)\n+\t{\n+\t  if (rs6000_reg_live_or_pic_offset_p (i)\n+\t      && !cfun->machine->gpr_is_wrapped_separately[i])\n+\t    {\n+\t      rtx reg = gen_rtx_REG (reg_mode, i);\n+\t      emit_insn (gen_frame_load (reg, frame_reg_rtx, offset));\n+\t    }\n+\n+\t  offset += reg_size;\n+\t}\n     }\n \n   if (DEFAULT_ABI == ABI_V4 || flag_shrink_wrap)\n@@ -29504,8 +29739,10 @@ rs6000_emit_epilogue (int sibcall)\n \t    || using_load_multiple\n \t    || rs6000_reg_live_or_pic_offset_p (i))\n \t  {\n-\t    rtx reg = gen_rtx_REG (reg_mode, i);\n+\t    if (cfun->machine->gpr_is_wrapped_separately[i])\n+\t      continue;\n \n+\t    rtx reg = gen_rtx_REG (reg_mode, i);\n \t    cfa_restores = alloc_reg_note (REG_CFA_RESTORE, reg, cfa_restores);\n \t  }\n     }"}]}