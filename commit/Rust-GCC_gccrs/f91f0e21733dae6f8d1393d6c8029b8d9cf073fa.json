{"sha": "f91f0e21733dae6f8d1393d6c8029b8d9cf073fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjkxZjBlMjE3MzNkYWU2ZjhkMTM5M2Q2YzgwMjliOGQ5Y2YwNzNmYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-07-06T17:34:03Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-07-06T17:34:03Z"}, "message": "escape: Implement tag phase.\n\n    \n    Adds notes to function parameters which summarize the escape of that\n    parameter with respect to the function's scope.\n    \n    Reviewed-on: https://go-review.googlesource.com/18443\n\nFrom-SVN: r238057", "tree": {"sha": "0aa44a0547ac2ca5457a2740648a3ffd2307f05e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0aa44a0547ac2ca5457a2740648a3ffd2307f05e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f91f0e21733dae6f8d1393d6c8029b8d9cf073fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f91f0e21733dae6f8d1393d6c8029b8d9cf073fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f91f0e21733dae6f8d1393d6c8029b8d9cf073fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f91f0e21733dae6f8d1393d6c8029b8d9cf073fa/comments", "author": null, "committer": null, "parents": [{"sha": "5e030517680b8e7660d323007e5aa843f87b835d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e030517680b8e7660d323007e5aa843f87b835d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e030517680b8e7660d323007e5aa843f87b835d"}], "stats": {"total": 100, "additions": 94, "deletions": 6}, "files": [{"sha": "49976238de94e109f208ef9af4a982f2fcb565fb", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f91f0e21733dae6f8d1393d6c8029b8d9cf073fa/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f91f0e21733dae6f8d1393d6c8029b8d9cf073fa/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=f91f0e21733dae6f8d1393d6c8029b8d9cf073fa", "patch": "@@ -1,4 +1,4 @@\n-1f2f2c77c7ec92efa254e07162a8fc0d22a550e7\n+c8fdad389ce6f439a02fb654d231053b47ff4e02\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "af8f1e2f9936e22e84e303282978bcb6ad9a63e6", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 93, "deletions": 5, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f91f0e21733dae6f8d1393d6c8029b8d9cf073fa/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f91f0e21733dae6f8d1393d6c8029b8d9cf073fa/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=f91f0e21733dae6f8d1393d6c8029b8d9cf073fa", "patch": "@@ -2194,15 +2194,103 @@ Gogo::propagate_escape(Escape_context* context, Node* dst)\n     }\n }\n \n+class Escape_analysis_tag\n+{\n+ public:\n+  Escape_analysis_tag(Escape_context* context)\n+    : context_(context)\n+  { }\n+\n+  // Add notes to the function's type about the escape information of its\n+  // input parameters.\n+  void\n+  tag(Named_object* fn);\n+\n+ private:\n+  Escape_context* context_;\n+};\n+\n+void\n+Escape_analysis_tag::tag(Named_object* fn)\n+{\n+  // External functions are assumed unsafe\n+  // unless //go:noescape is given before the declaration.\n+  if (fn->package() != NULL || !fn->is_function())\n+    {\n+      // TODO(cmang): Implement //go:noescape directive for external functions;\n+      // mark input parameters as not escaping.\n+      return;\n+    }\n+\n+  Function_type* fntype = fn->func_value()->type();\n+  Bindings* bindings = fn->func_value()->block()->bindings();\n+\n+  if (fntype->is_method()\n+      && !fntype->receiver()->name().empty()\n+      && !Gogo::is_sink_name(fntype->receiver()->name()))\n+    {\n+      Named_object* rcvr_no = bindings->lookup(fntype->receiver()->name());\n+      go_assert(rcvr_no != NULL);\n+      Node* rcvr_node = Node::make_node(rcvr_no);\n+      switch ((rcvr_node->encoding() & ESCAPE_MASK))\n+\t{\n+\tcase Node::ESCAPE_NONE: // not touched by flood\n+\tcase Node::ESCAPE_RETURN:\n+\t  if (fntype->receiver()->type()->has_pointer())\n+\t    // Don't bother tagging for scalars.\n+\t    fntype->add_receiver_note(rcvr_node->encoding());\n+\t  break;\n+\n+\tcase Node::ESCAPE_HEAP: // flooded, moved to heap.\n+\tcase Node::ESCAPE_SCOPE: // flooded, value leaves scope.\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  int i = 0;\n+  if (fntype->parameters() != NULL)\n+    {\n+      const Typed_identifier_list* til = fntype->parameters();\n+      for (Typed_identifier_list::const_iterator p = til->begin();\n+\t   p != til->end();\n+\t   ++p, ++i)\n+\t{\n+\t  if (p->name().empty() || Gogo::is_sink_name(p->name()))\n+\t    continue;\n+\n+\t  Named_object* param_no = bindings->lookup(p->name());\n+\t  go_assert(param_no != NULL);\n+\t  Node* param_node = Node::make_node(param_no);\n+\t  switch ((param_node->encoding() & ESCAPE_MASK))\n+\t    {\n+\t    case Node::ESCAPE_NONE: // not touched by flood\n+\t    case Node::ESCAPE_RETURN:\n+\t      if (p->type()->has_pointer())\n+\t\t// Don't bother tagging for scalars.\n+\t\tfntype->add_parameter_note(i, param_node->encoding());\n+\t      break;\n+\n+\t    case Node::ESCAPE_HEAP: // flooded, moved to heap.\n+\t    case Node::ESCAPE_SCOPE: // flooded, value leaves scope.\n+\t      break;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  fntype->set_is_tagged();\n+}\n \n // Tag each top-level function with escape information that will be used to\n // retain analysis results across imports.\n \n void\n-Gogo::tag_function(Escape_context*, Named_object*)\n+Gogo::tag_function(Escape_context* context, Named_object* fn)\n {\n-  // TODO(cmang): Create escape information notes for each input and output\n-  // parameter in a given function.\n-  // Escape_analysis_tag eat(context, fn);\n-  // this->traverse(&eat);\n+  Escape_analysis_tag eat(context);\n+  eat.tag(fn);\n }"}]}