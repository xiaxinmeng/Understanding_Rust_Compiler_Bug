{"sha": "6b02d5f75384dde3f9aa29817a806b797d86e377", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmIwMmQ1Zjc1Mzg0ZGRlM2Y5YWEyOTgxN2E4MDZiNzk3ZDg2ZTM3Nw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-03-28T16:55:40Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2009-03-28T16:55:40Z"}, "message": "re PR fortran/38765 (ICE in check_host_association)\n\n2009-03-28  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/38765\n\t* parse.c (parse_derived): Do not break on finding pointer,\n\tallocatable or private components.\n\n2009-03-28  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/38765\n\t* gfortran.dg/alloc_comp_assign_9.f90: New test.\n\nFrom-SVN: r145195", "tree": {"sha": "ba10f22f9a067ba1652a724bb97b398686fa99c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba10f22f9a067ba1652a724bb97b398686fa99c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b02d5f75384dde3f9aa29817a806b797d86e377", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b02d5f75384dde3f9aa29817a806b797d86e377", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b02d5f75384dde3f9aa29817a806b797d86e377", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b02d5f75384dde3f9aa29817a806b797d86e377/comments", "author": null, "committer": null, "parents": [{"sha": "1de812a6cce2199fc81ae2fe074ebac1e0769174", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1de812a6cce2199fc81ae2fe074ebac1e0769174", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1de812a6cce2199fc81ae2fe074ebac1e0769174"}], "stats": {"total": 49, "additions": 36, "deletions": 13}, "files": [{"sha": "633775fc625bfce725409c8e07810b34ad50d963", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b02d5f75384dde3f9aa29817a806b797d86e377/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b02d5f75384dde3f9aa29817a806b797d86e377/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6b02d5f75384dde3f9aa29817a806b797d86e377", "patch": "@@ -1,3 +1,9 @@\n+2009-03-28  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/38765\n+\t* parse.c (parse_derived): Do not break on finding pointer,\n+\tallocatable or private components.\n+\n 2009-03-28  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/32626"}, {"sha": "1bf13e2de8fda2f4316317289460ad12dac109c5", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b02d5f75384dde3f9aa29817a806b797d86e377/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b02d5f75384dde3f9aa29817a806b797d86e377/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=6b02d5f75384dde3f9aa29817a806b797d86e377", "patch": "@@ -1,5 +1,6 @@\n /* Main parser.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n+   2009\n    Free Software Foundation, Inc.\n    Contributed by Andy Vaught\n \n@@ -1978,27 +1979,18 @@ parse_derived (void)\n       /* Look for allocatable components.  */\n       if (c->attr.allocatable\n \t  || (c->ts.type == BT_DERIVED && c->ts.derived->attr.alloc_comp))\n-\t{\n-\t  sym->attr.alloc_comp = 1;\n-\t  break;\n-\t}\n+\tsym->attr.alloc_comp = 1;\n \n       /* Look for pointer components.  */\n       if (c->attr.pointer\n \t  || (c->ts.type == BT_DERIVED && c->ts.derived->attr.pointer_comp))\n-\t{\n-\t  sym->attr.pointer_comp = 1;\n-\t  break;\n-\t}\n+\tsym->attr.pointer_comp = 1;\n \n       /* Look for private components.  */\n       if (sym->component_access == ACCESS_PRIVATE\n \t  || c->attr.access == ACCESS_PRIVATE\n \t  || (c->ts.type == BT_DERIVED && c->ts.derived->attr.private_comp))\n-\t{\n-\t  sym->attr.private_comp = 1;\n-\t  break;\n-\t}\n+\tsym->attr.private_comp = 1;\n     }\n \n   if (!seen_component)"}, {"sha": "c5018d7d5757d919a5158533f8f27ed009e83a6b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b02d5f75384dde3f9aa29817a806b797d86e377/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b02d5f75384dde3f9aa29817a806b797d86e377/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6b02d5f75384dde3f9aa29817a806b797d86e377", "patch": "@@ -1,3 +1,8 @@\n+2009-03-28  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/38765\n+\t* gfortran.dg/alloc_comp_assign_9.f90: New test.\n+\n 2009-03-28  Daniel Kraft  <d@domob.eu>\n \n \t* gfortran.dg/trim_1.f90: New test."}, {"sha": "9051bafa0198eee755880f29298d7209e5b1b718", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_assign_9.f90", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b02d5f75384dde3f9aa29817a806b797d86e377/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b02d5f75384dde3f9aa29817a806b797d86e377/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_assign_9.f90?ref=6b02d5f75384dde3f9aa29817a806b797d86e377", "patch": "@@ -0,0 +1,20 @@\n+! { dg-do run }\n+! Test the fix for PR39519, where the presence of the pointer\n+! as the first component was preventing the second from passing\n+! the \"alloc_comp\" attribute to the derived type.\n+!\n+! Contributed by Gilbert Scott <gilbert.scott@easynet.co.uk>\n+!\n+PROGRAM X\n+  TYPE T\n+    INTEGER, POINTER :: P\n+    INTEGER, ALLOCATABLE :: A(:)\n+  END TYPE T\n+  TYPE(T) :: T1,T2\n+  ALLOCATE ( T1%A(1) )\n+  ALLOCATE ( T2%A(1) )\n+  T1%A = 23\n+  T2 = T1\n+  T1%A = 42\n+  if (T2%A(1) .NE. 23) CALL ABORT\n+END PROGRAM X"}]}