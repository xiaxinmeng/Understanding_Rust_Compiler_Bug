{"sha": "24ee13842edcacff46a4f06d3b469d0bdc6d0a73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjRlZTEzODQyZWRjYWNmZjQ2YTRmMDZkM2I0NjlkMGJkYzZkMGE3Mw==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2012-02-05T05:58:18Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2012-02-05T05:58:18Z"}, "message": "re PR tree-optimization/52091 (ICE: verify_gimple failed)\n\n\n        PR tree-optimization/52091\n        * tree-vectorizer.h (vect_is_simple_use): Add an argument.\n        (vect_is_simple_use_1): Likewise.\n        * tree-vect-loop.c (vectorizable_reduction): Update calls\n        to vect_is_simple_use_1 and vect_is_simple_use.\n        (vectorizable_live_operation): Likewise.\n        * tree-vect-patterns.c (widened_name_p,\n        vect_recog_vector_vector_shift_pattern, check_bool_pattern):\n        Likewise.\n        * tree-vect-stmts.c (process_use, vect_get_vec_def_for_operand,\n        vectorizable_call, vectorizable_conversion,\n        vectorizable_assignment, vectorizable_shift,\n        vectorizable_operation, vectorizable_store, vectorizable_load):\n        Likewise.\n        (vect_is_simple_cond): Add an argument, pass it to\n        vect_is_simple_use_1.\n        (vectorizable_condition): Update calls to vect_is_simple_cond,\n        vect_is_simple_use.\n        (vect_is_simple_use): Add an argument, the statement in which\n        OPERAND is used.  Check that if OPERAND's def stmt is a double\n        reduction phi node, the use is a phi node too.\n        (vect_is_simple_use_1): Add an argument, pass it to\n        vect_is_simple_use.\n        * tree-vect-slp.c (vect_get_and_check_slp_defs): Update a call\n        to vect_is_simple_use.\n\nFrom-SVN: r183902", "tree": {"sha": "725e87b3955717cd08b8ed5276d6dcea3a4a8724", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/725e87b3955717cd08b8ed5276d6dcea3a4a8724"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/24ee13842edcacff46a4f06d3b469d0bdc6d0a73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24ee13842edcacff46a4f06d3b469d0bdc6d0a73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24ee13842edcacff46a4f06d3b469d0bdc6d0a73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24ee13842edcacff46a4f06d3b469d0bdc6d0a73/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3bbdbe67bc710e5758250df8bfb995c7f0d6b3b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bbdbe67bc710e5758250df8bfb995c7f0d6b3b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bbdbe67bc710e5758250df8bfb995c7f0d6b3b5"}], "stats": {"total": 195, "additions": 135, "deletions": 60}, "files": [{"sha": "5989120590636642546caec1e1e307c32b8492a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ee13842edcacff46a4f06d3b469d0bdc6d0a73/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ee13842edcacff46a4f06d3b469d0bdc6d0a73/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=24ee13842edcacff46a4f06d3b469d0bdc6d0a73", "patch": "@@ -1,3 +1,31 @@\n+2012-02-05  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/52091\n+\t* tree-vectorizer.h (vect_is_simple_use): Add an argument.\n+\t(vect_is_simple_use_1): Likewise.\n+\t* tree-vect-loop.c (vectorizable_reduction): Update calls\n+\tto vect_is_simple_use_1 and vect_is_simple_use.\n+\t(vectorizable_live_operation): Likewise.\n+\t* tree-vect-patterns.c (widened_name_p,\n+\tvect_recog_vector_vector_shift_pattern, check_bool_pattern):\n+\tLikewise.\n+\t* tree-vect-stmts.c (process_use, vect_get_vec_def_for_operand,\n+\tvectorizable_call, vectorizable_conversion,\n+\tvectorizable_assignment, vectorizable_shift,\n+\tvectorizable_operation, vectorizable_store, vectorizable_load):\n+\tLikewise.\n+\t(vect_is_simple_cond): Add an argument, pass it to\n+\tvect_is_simple_use_1.\n+\t(vectorizable_condition): Update calls to vect_is_simple_cond,\n+\tvect_is_simple_use.\n+\t(vect_is_simple_use): Add an argument, the statement in which\n+\tOPERAND is used.  Check that if OPERAND's def stmt is a double\n+\treduction phi node, the use is a phi node too.\n+\t(vect_is_simple_use_1): Add an argument, pass it to\n+\tvect_is_simple_use.\n+\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Update a call\n+\tto vect_is_simple_use.\n+\n 2012-02-04  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/52095"}, {"sha": "93a7c0f1b580ec0474a438052649b6a4e749c660", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ee13842edcacff46a4f06d3b469d0bdc6d0a73/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ee13842edcacff46a4f06d3b469d0bdc6d0a73/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=24ee13842edcacff46a4f06d3b469d0bdc6d0a73", "patch": "@@ -1,3 +1,8 @@\n+2012-02-05  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/52091\n+\t* gcc.dg/vect/pr52091.c: New test.\n+\n 2012-02-04  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/52113"}, {"sha": "ff583b299a8b1db8d4f2ce7b67920f015cb2d411", "filename": "gcc/testsuite/gcc.dg/vect/pr52091.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ee13842edcacff46a4f06d3b469d0bdc6d0a73/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr52091.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ee13842edcacff46a4f06d3b469d0bdc6d0a73/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr52091.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr52091.c?ref=24ee13842edcacff46a4f06d3b469d0bdc6d0a73", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+/* PR tree-optimization/52091 */\n+\n+int b, c, d, f;\n+unsigned h;\n+extern void abort (void);\n+\n+int\n+main ()\n+{\n+  d = -1;\n+  h = 65;\n+  asm volatile (\"\" : : : \"memory\");\n+  for (f = 0; f < 4; f++)\n+    {\n+      h &= (unsigned short) d;\n+      for (b = 0; b <= 1; b++)\n+    {\n+      c = 0;\n+      d &= 1;\n+    }\n+    }\n+  asm volatile (\"\" : : : \"memory\");\n+  if (b != 2 || c != 0 || d != 1 || f != 4 || h != 1)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "051d340e2d89a932d21690304a9efb13de7307aa", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ee13842edcacff46a4f06d3b469d0bdc6d0a73/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ee13842edcacff46a4f06d3b469d0bdc6d0a73/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=24ee13842edcacff46a4f06d3b469d0bdc6d0a73", "patch": "@@ -1,5 +1,5 @@\n /* Loop Vectorization\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Dorit Naishlos <dorit@il.ibm.com> and\n    Ira Rosen <irar@il.ibm.com>\n@@ -4486,7 +4486,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n       if (i == 0 && code == COND_EXPR)\n         continue;\n \n-      is_simple_use = vect_is_simple_use_1 (ops[i], loop_vinfo, NULL,\n+      is_simple_use = vect_is_simple_use_1 (ops[i], stmt, loop_vinfo, NULL,\n \t\t\t\t\t    &def_stmt, &def, &dt, &tem);\n       if (!vectype_in)\n \tvectype_in = tem;\n@@ -4507,8 +4507,8 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n         }\n     }\n \n-  is_simple_use = vect_is_simple_use_1 (ops[i], loop_vinfo, NULL, &def_stmt,\n-\t\t\t\t\t&def, &dt, &tem);\n+  is_simple_use = vect_is_simple_use_1 (ops[i], stmt, loop_vinfo, NULL,\n+\t\t\t\t\t&def_stmt, &def, &dt, &tem);\n   if (!vectype_in)\n     vectype_in = tem;\n   gcc_assert (is_simple_use);\n@@ -4864,14 +4864,14 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n               gimple dummy_stmt;\n               tree dummy;\n \n-              vect_is_simple_use (ops[!reduc_index], loop_vinfo, NULL,\n+              vect_is_simple_use (ops[!reduc_index], stmt, loop_vinfo, NULL,\n                                   &dummy_stmt, &dummy, &dt);\n               loop_vec_def0 = vect_get_vec_def_for_stmt_copy (dt,\n                                                               loop_vec_def0);\n               VEC_replace (tree, vec_oprnds0, 0, loop_vec_def0);\n               if (op_type == ternary_op)\n                 {\n-                  vect_is_simple_use (op1, loop_vinfo, NULL, &dummy_stmt,\n+                  vect_is_simple_use (op1, stmt, loop_vinfo, NULL, &dummy_stmt,\n                                       &dummy, &dt);\n                   loop_vec_def1 = vect_get_vec_def_for_stmt_copy (dt,\n                                                                 loop_vec_def1);\n@@ -5103,7 +5103,8 @@ vectorizable_live_operation (gimple stmt,\n       else\n \top = gimple_op (stmt, i + 1);\n       if (op\n-          && !vect_is_simple_use (op, loop_vinfo, NULL, &def_stmt, &def, &dt))\n+          && !vect_is_simple_use (op, stmt, loop_vinfo, NULL, &def_stmt, &def,\n+\t\t\t\t  &dt))\n         {\n           if (vect_print_dump_info (REPORT_DETAILS))\n             fprintf (vect_dump, \"use not simple.\");"}, {"sha": "d95502103f74adb4b5f646cba3ad544238e136b3", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ee13842edcacff46a4f06d3b469d0bdc6d0a73/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ee13842edcacff46a4f06d3b469d0bdc6d0a73/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=24ee13842edcacff46a4f06d3b469d0bdc6d0a73", "patch": "@@ -109,7 +109,8 @@ widened_name_p (tree name, gimple use_stmt, tree *half_type, gimple *def_stmt,\n   stmt_vinfo = vinfo_for_stmt (use_stmt);\n   loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n \n-  if (!vect_is_simple_use (name, loop_vinfo, NULL, def_stmt, &def, &dt))\n+  if (!vect_is_simple_use (name, use_stmt, loop_vinfo, NULL, def_stmt, &def,\n+\t\t\t   &dt))\n     return false;\n \n   if (dt != vect_internal_def\n@@ -133,8 +134,8 @@ widened_name_p (tree name, gimple use_stmt, tree *half_type, gimple *def_stmt,\n       || (TYPE_PRECISION (type) < (TYPE_PRECISION (*half_type) * 2)))\n     return false;\n \n-  if (!vect_is_simple_use (oprnd0, loop_vinfo, NULL, &dummy_gimple, &dummy,\n-                           &dt))\n+  if (!vect_is_simple_use (oprnd0, *def_stmt, loop_vinfo,\n+\t\t\t   NULL, &dummy_gimple, &dummy, &dt))\n     return false;\n \n   return true;\n@@ -1550,7 +1551,8 @@ vect_recog_vector_vector_shift_pattern (VEC (gimple, heap) **stmts,\n \t != TYPE_PRECISION (TREE_TYPE (oprnd0)))\n     return NULL;\n \n-  if (!vect_is_simple_use (oprnd1, loop_vinfo, NULL, &def_stmt, &def, &dt))\n+  if (!vect_is_simple_use (oprnd1, last_stmt, loop_vinfo, NULL, &def_stmt,\n+\t\t\t   &def, &dt))\n     return NULL;\n \n   if (dt != vect_internal_def)\n@@ -1926,7 +1928,7 @@ check_bool_pattern (tree var, loop_vec_info loop_vinfo)\n   tree def, rhs1;\n   enum tree_code rhs_code;\n \n-  if (!vect_is_simple_use (var, loop_vinfo, NULL, &def_stmt, &def, &dt))\n+  if (!vect_is_simple_use (var, NULL, loop_vinfo, NULL, &def_stmt, &def, &dt))\n     return false;\n \n   if (dt != vect_internal_def)"}, {"sha": "1177816ab600cb33bf39190f72615108ca9ec80d", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ee13842edcacff46a4f06d3b469d0bdc6d0a73/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ee13842edcacff46a4f06d3b469d0bdc6d0a73/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=24ee13842edcacff46a4f06d3b469d0bdc6d0a73", "patch": "@@ -233,8 +233,8 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n           oprnd = TREE_OPERAND (oprnd, 0);\n \t}\n \n-      if (!vect_is_simple_use (oprnd, loop_vinfo, bb_vinfo, &def_stmt, &def,\n-                               &dt)\n+      if (!vect_is_simple_use (oprnd, NULL, loop_vinfo, bb_vinfo, &def_stmt,\n+\t\t\t       &def, &dt)\n \t  || (!def_stmt && dt != vect_constant_def))\n \t{\n \t  if (vect_print_dump_info (REPORT_SLP))"}, {"sha": "6ce742cdfa73f74f12792f46dc8cf888f29e53ae", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 49, "deletions": 43, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ee13842edcacff46a4f06d3b469d0bdc6d0a73/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ee13842edcacff46a4f06d3b469d0bdc6d0a73/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=24ee13842edcacff46a4f06d3b469d0bdc6d0a73", "patch": "@@ -374,7 +374,7 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n   if (!force && !exist_non_indexing_operands_for_use_p (use, stmt))\n      return true;\n \n-  if (!vect_is_simple_use (use, loop_vinfo, NULL, &def_stmt, &def, &dt))\n+  if (!vect_is_simple_use (use, stmt, loop_vinfo, NULL, &def_stmt, &def, &dt))\n     {\n       if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n         fprintf (vect_dump, \"not vectorized: unsupported use in stmt.\");\n@@ -1193,8 +1193,8 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n       print_generic_expr (vect_dump, op, TDF_SLIM);\n     }\n \n-  is_simple_use = vect_is_simple_use (op, loop_vinfo, NULL, &def_stmt, &def,\n-                                      &dt);\n+  is_simple_use = vect_is_simple_use (op, stmt, loop_vinfo, NULL,\n+\t\t\t\t      &def_stmt, &def, &dt);\n   gcc_assert (is_simple_use);\n   if (vect_print_dump_info (REPORT_DETAILS))\n     {\n@@ -1596,7 +1596,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       if (!rhs_type)\n \trhs_type = TREE_TYPE (op);\n \n-      if (!vect_is_simple_use_1 (op, loop_vinfo, bb_vinfo,\n+      if (!vect_is_simple_use_1 (op, stmt, loop_vinfo, bb_vinfo,\n \t\t\t\t &def_stmt, &def, &dt[i], &opvectype))\n \t{\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n@@ -2208,7 +2208,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n     }\n \n   /* Check the operands of the operation.  */\n-  if (!vect_is_simple_use_1 (op0, loop_vinfo, bb_vinfo,\n+  if (!vect_is_simple_use_1 (op0, stmt, loop_vinfo, bb_vinfo,\n \t\t\t     &def_stmt, &def, &dt[0], &vectype_in))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -2224,11 +2224,11 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n       /* For WIDEN_MULT_EXPR, if OP0 is a constant, use the type of\n \t OP1.  */\n       if (CONSTANT_CLASS_P (op0))\n-\tok = vect_is_simple_use_1 (op1, loop_vinfo, NULL,\n+\tok = vect_is_simple_use_1 (op1, stmt, loop_vinfo, NULL,\n \t\t\t\t   &def_stmt, &def, &dt[1], &vectype_in);\n       else\n-\tok = vect_is_simple_use (op1, loop_vinfo, NULL, &def_stmt, &def,\n-\t\t\t\t &dt[1]);\n+\tok = vect_is_simple_use (op1, stmt, loop_vinfo, NULL, &def_stmt,\n+\t\t\t\t &def, &dt[1]);\n \n       if (!ok)\n \t{\n@@ -2757,7 +2757,7 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n   if (code == VIEW_CONVERT_EXPR)\n     op = TREE_OPERAND (op, 0);\n \n-  if (!vect_is_simple_use_1 (op, loop_vinfo, bb_vinfo,\n+  if (!vect_is_simple_use_1 (op, stmt, loop_vinfo, bb_vinfo,\n \t\t\t     &def_stmt, &def, &dt[0], &vectype_in))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -2957,7 +2957,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n     }\n \n   op0 = gimple_assign_rhs1 (stmt);\n-  if (!vect_is_simple_use_1 (op0, loop_vinfo, bb_vinfo,\n+  if (!vect_is_simple_use_1 (op0, stmt, loop_vinfo, bb_vinfo,\n                              &def_stmt, &def, &dt[0], &vectype))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -2987,8 +2987,8 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n     return false;\n \n   op1 = gimple_assign_rhs2 (stmt);\n-  if (!vect_is_simple_use_1 (op1, loop_vinfo, bb_vinfo, &def_stmt, &def,\n-\t\t\t     &dt[1], &op1_vectype))\n+  if (!vect_is_simple_use_1 (op1, stmt, loop_vinfo, bb_vinfo, &def_stmt,\n+\t\t\t     &def, &dt[1], &op1_vectype))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"use not simple.\");\n@@ -3334,7 +3334,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n     }\n \n   op0 = gimple_assign_rhs1 (stmt);\n-  if (!vect_is_simple_use_1 (op0, loop_vinfo, bb_vinfo,\n+  if (!vect_is_simple_use_1 (op0, stmt, loop_vinfo, bb_vinfo,\n \t\t\t     &def_stmt, &def, &dt[0], &vectype))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n@@ -3366,8 +3366,8 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   if (op_type == binary_op || op_type == ternary_op)\n     {\n       op1 = gimple_assign_rhs2 (stmt);\n-      if (!vect_is_simple_use (op1, loop_vinfo, bb_vinfo, &def_stmt, &def,\n-                               &dt[1]))\n+      if (!vect_is_simple_use (op1, stmt, loop_vinfo, bb_vinfo, &def_stmt,\n+\t\t\t       &def, &dt[1]))\n \t{\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"use not simple.\");\n@@ -3377,8 +3377,8 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   if (op_type == ternary_op)\n     {\n       op2 = gimple_assign_rhs3 (stmt);\n-      if (!vect_is_simple_use (op2, loop_vinfo, bb_vinfo, &def_stmt, &def,\n-                               &dt[2]))\n+      if (!vect_is_simple_use (op2, stmt, loop_vinfo, bb_vinfo, &def_stmt,\n+\t\t\t       &def, &dt[2]))\n \t{\n \t  if (vect_print_dump_info (REPORT_DETAILS))\n \t    fprintf (vect_dump, \"use not simple.\");\n@@ -3684,7 +3684,8 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n   gcc_assert (gimple_assign_single_p (stmt));\n   op = gimple_assign_rhs1 (stmt);\n-  if (!vect_is_simple_use (op, loop_vinfo, bb_vinfo, &def_stmt, &def, &dt))\n+  if (!vect_is_simple_use (op, stmt, loop_vinfo, bb_vinfo, &def_stmt,\n+\t\t\t   &def, &dt))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"use not simple.\");\n@@ -3731,8 +3732,8 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n             {\n \t      gcc_assert (gimple_assign_single_p (next_stmt));\n \t      op = gimple_assign_rhs1 (next_stmt);\n-              if (!vect_is_simple_use (op, loop_vinfo, bb_vinfo, &def_stmt,\n-                                       &def, &dt))\n+              if (!vect_is_simple_use (op, next_stmt, loop_vinfo, bb_vinfo,\n+\t\t\t\t       &def_stmt, &def, &dt))\n                 {\n                   if (vect_print_dump_info (REPORT_DETAILS))\n                     fprintf (vect_dump, \"use not simple.\");\n@@ -3917,8 +3918,8 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t  for (i = 0; i < group_size; i++)\n \t    {\n \t      op = VEC_index (tree, oprnds, i);\n-\t      vect_is_simple_use (op, loop_vinfo, bb_vinfo, &def_stmt, &def,\n-\t                          &dt);\n+\t      vect_is_simple_use (op, NULL, loop_vinfo, bb_vinfo, &def_stmt,\n+\t\t\t\t  &def, &dt);\n \t      vec_oprnd = vect_get_vec_def_for_stmt_copy (dt, op);\n \t      VEC_replace(tree, dr_chain, i, vec_oprnd);\n \t      VEC_replace(tree, oprnds, i, vec_oprnd);\n@@ -4279,7 +4280,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n       gather_decl = vect_check_gather (stmt, loop_vinfo, &gather_base,\n \t\t\t\t       &gather_off, &gather_scale);\n       gcc_assert (gather_decl);\n-      if (!vect_is_simple_use_1 (gather_off, loop_vinfo, bb_vinfo,\n+      if (!vect_is_simple_use_1 (gather_off, NULL, loop_vinfo, bb_vinfo,\n \t\t\t\t &def_stmt, &def, &gather_dt,\n \t\t\t\t &gather_off_vectype))\n \t{\n@@ -4914,8 +4915,8 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n    condition operands are supportable using vec_is_simple_use.  */\n \n static bool\n-vect_is_simple_cond (tree cond, loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n-\t\t     tree *comp_vectype)\n+vect_is_simple_cond (tree cond, gimple stmt, loop_vec_info loop_vinfo,\n+\t\t     bb_vec_info bb_vinfo, tree *comp_vectype)\n {\n   tree lhs, rhs;\n   tree def;\n@@ -4931,8 +4932,8 @@ vect_is_simple_cond (tree cond, loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   if (TREE_CODE (lhs) == SSA_NAME)\n     {\n       gimple lhs_def_stmt = SSA_NAME_DEF_STMT (lhs);\n-      if (!vect_is_simple_use_1 (lhs, loop_vinfo, bb_vinfo, &lhs_def_stmt, &def,\n-\t\t\t\t &dt, &vectype1))\n+      if (!vect_is_simple_use_1 (lhs, stmt, loop_vinfo, bb_vinfo,\n+\t\t\t\t &lhs_def_stmt, &def, &dt, &vectype1))\n \treturn false;\n     }\n   else if (TREE_CODE (lhs) != INTEGER_CST && TREE_CODE (lhs) != REAL_CST\n@@ -4942,8 +4943,8 @@ vect_is_simple_cond (tree cond, loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   if (TREE_CODE (rhs) == SSA_NAME)\n     {\n       gimple rhs_def_stmt = SSA_NAME_DEF_STMT (rhs);\n-      if (!vect_is_simple_use_1 (rhs, loop_vinfo, bb_vinfo, &rhs_def_stmt, &def,\n-\t\t\t\t &dt, &vectype2))\n+      if (!vect_is_simple_use_1 (rhs, stmt, loop_vinfo, bb_vinfo,\n+\t\t\t\t &rhs_def_stmt, &def, &dt, &vectype2))\n \treturn false;\n     }\n   else if (TREE_CODE (rhs) != INTEGER_CST && TREE_CODE (rhs) != REAL_CST\n@@ -5035,14 +5036,15 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   then_clause = gimple_assign_rhs2 (stmt);\n   else_clause = gimple_assign_rhs3 (stmt);\n \n-  if (!vect_is_simple_cond (cond_expr, loop_vinfo, bb_vinfo, &comp_vectype)\n+  if (!vect_is_simple_cond (cond_expr, stmt, loop_vinfo, bb_vinfo,\n+\t\t\t    &comp_vectype)\n       || !comp_vectype)\n     return false;\n \n   if (TREE_CODE (then_clause) == SSA_NAME)\n     {\n       gimple then_def_stmt = SSA_NAME_DEF_STMT (then_clause);\n-      if (!vect_is_simple_use (then_clause, loop_vinfo, bb_vinfo,\n+      if (!vect_is_simple_use (then_clause, stmt, loop_vinfo, bb_vinfo,\n \t\t\t       &then_def_stmt, &def, &dt))\n \treturn false;\n     }\n@@ -5054,7 +5056,7 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n   if (TREE_CODE (else_clause) == SSA_NAME)\n     {\n       gimple else_def_stmt = SSA_NAME_DEF_STMT (else_clause);\n-      if (!vect_is_simple_use (else_clause, loop_vinfo, bb_vinfo,\n+      if (!vect_is_simple_use (else_clause, stmt, loop_vinfo, bb_vinfo,\n \t\t\t       &else_def_stmt, &def, &dt))\n \treturn false;\n     }\n@@ -5114,21 +5116,21 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n \t      vec_cond_lhs =\n \t      vect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 0),\n \t\t\t\t\t    stmt, NULL);\n-\t      vect_is_simple_use (TREE_OPERAND (cond_expr, 0), loop_vinfo,\n-\t\t\t      NULL, &gtemp, &def, &dts[0]);\n+\t      vect_is_simple_use (TREE_OPERAND (cond_expr, 0), stmt,\n+\t\t\t\t  loop_vinfo, NULL, &gtemp, &def, &dts[0]);\n \n \t      vec_cond_rhs =\n \t\tvect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 1),\n \t\t\t\t\t\tstmt, NULL);\n-\t      vect_is_simple_use (TREE_OPERAND (cond_expr, 1), loop_vinfo,\n-\t\t\t\t\tNULL, &gtemp, &def, &dts[1]);\n+\t      vect_is_simple_use (TREE_OPERAND (cond_expr, 1), stmt,\n+\t\t\t\t  loop_vinfo, NULL, &gtemp, &def, &dts[1]);\n \t      if (reduc_index == 1)\n \t\tvec_then_clause = reduc_def;\n \t      else\n \t\t{\n \t\t  vec_then_clause = vect_get_vec_def_for_operand (then_clause,\n \t\t \t\t  \t\t\t      stmt, NULL);\n-\t          vect_is_simple_use (then_clause, loop_vinfo,\n+\t          vect_is_simple_use (then_clause, stmt, loop_vinfo,\n \t\t\t\t\t  NULL, &gtemp, &def, &dts[2]);\n \t\t}\n \t      if (reduc_index == 2)\n@@ -5137,7 +5139,7 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n \t\t{\n \t\t  vec_else_clause = vect_get_vec_def_for_operand (else_clause,\n \t\t\t\t\t\t\t      stmt, NULL);\n-\t\t  vect_is_simple_use (else_clause, loop_vinfo,\n+\t\t  vect_is_simple_use (else_clause, stmt, loop_vinfo,\n \t\t\t\t  NULL, &gtemp, &def, &dts[3]);\n \t\t}\n \t    }\n@@ -5831,7 +5833,7 @@ get_same_sized_vectype (tree scalar_type, tree vector_type)\n    Input:\n    LOOP_VINFO - the vect info of the loop that is being vectorized.\n    BB_VINFO - the vect info of the basic block that is being vectorized.\n-   OPERAND - operand of a stmt in the loop or bb.\n+   OPERAND - operand of STMT in the loop or bb.\n    DEF - the defining stmt in case OPERAND is an SSA_NAME.\n \n    Returns whether a stmt with OPERAND can be vectorized.\n@@ -5843,7 +5845,7 @@ get_same_sized_vectype (tree scalar_type, tree vector_type)\n    For now, operands defined outside the basic block are not supported.  */\n \n bool\n-vect_is_simple_use (tree operand, loop_vec_info loop_vinfo,\n+vect_is_simple_use (tree operand, gimple stmt, loop_vec_info loop_vinfo,\n                     bb_vec_info bb_vinfo, gimple *def_stmt,\n \t\t    tree *def, enum vect_def_type *dt)\n {\n@@ -5925,7 +5927,10 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo,\n       *dt = STMT_VINFO_DEF_TYPE (stmt_vinfo);\n     }\n \n-  if (*dt == vect_unknown_def_type)\n+  if (*dt == vect_unknown_def_type\n+      || (stmt\n+\t  && *dt == vect_double_reduction_def\n+\t  && gimple_code (stmt) != GIMPLE_PHI))\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n         fprintf (vect_dump, \"Unsupported pattern.\");\n@@ -5969,11 +5974,12 @@ vect_is_simple_use (tree operand, loop_vec_info loop_vinfo,\n    scalar operand.  */\n \n bool\n-vect_is_simple_use_1 (tree operand, loop_vec_info loop_vinfo,\n+vect_is_simple_use_1 (tree operand, gimple stmt, loop_vec_info loop_vinfo,\n \t\t      bb_vec_info bb_vinfo, gimple *def_stmt,\n \t\t      tree *def, enum vect_def_type *dt, tree *vectype)\n {\n-  if (!vect_is_simple_use (operand, loop_vinfo, bb_vinfo, def_stmt, def, dt))\n+  if (!vect_is_simple_use (operand, stmt, loop_vinfo, bb_vinfo, def_stmt,\n+\t\t\t   def, dt))\n     return false;\n \n   /* Now get a vector type if the def is internal, otherwise supply"}, {"sha": "35420ba141cfb5e148040a115102e2abb65070c2", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/24ee13842edcacff46a4f06d3b469d0bdc6d0a73/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/24ee13842edcacff46a4f06d3b469d0bdc6d0a73/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=24ee13842edcacff46a4f06d3b469d0bdc6d0a73", "patch": "@@ -1,5 +1,5 @@\n /* Vectorizer\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012\n    Free Software Foundation, Inc.\n    Contributed by Dorit Naishlos <dorit@il.ibm.com>\n \n@@ -808,9 +808,11 @@ extern bool vect_can_advance_ivs_p (loop_vec_info);\n extern unsigned int current_vector_size;\n extern tree get_vectype_for_scalar_type (tree);\n extern tree get_same_sized_vectype (tree, tree);\n-extern bool vect_is_simple_use (tree, loop_vec_info, bb_vec_info, gimple *,\n+extern bool vect_is_simple_use (tree, gimple, loop_vec_info,\n+\t\t\t        bb_vec_info, gimple *,\n                                 tree *,  enum vect_def_type *);\n-extern bool vect_is_simple_use_1 (tree, loop_vec_info, bb_vec_info, gimple *,\n+extern bool vect_is_simple_use_1 (tree, gimple, loop_vec_info,\n+\t\t\t\t  bb_vec_info, gimple *,\n \t\t\t\t  tree *,  enum vect_def_type *, tree *);\n extern bool supportable_widening_operation (enum tree_code, gimple, tree, tree,\n                                             tree *, tree *, enum tree_code *,"}]}