{"sha": "64dc53f34db1cea9ea657a32e72216baa3a524fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRkYzUzZjM0ZGIxY2VhOWVhNjU3YTMyZTcyMjE2YmFhM2E1MjRmYg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-03-06T09:50:17Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-03-06T09:50:17Z"}, "message": "function.c (free_temps_for_rtl_expr): Don't free slots that have been pushed into a higher level.\n\n\t* function.c (free_temps_for_rtl_expr): Don't free slots\n\tthat have been pushed into a higher level.\n\n\t* expr.c (cplus_expand_expr, case STMT_EXPR): Don't set\n\tRTL_EXPR_HAS_NO_SCOPE after all.\n\nFrom-SVN: r32355", "tree": {"sha": "7f3c2d7139227eb4e97559a0a0454c54f36c4988", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7f3c2d7139227eb4e97559a0a0454c54f36c4988"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64dc53f34db1cea9ea657a32e72216baa3a524fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64dc53f34db1cea9ea657a32e72216baa3a524fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64dc53f34db1cea9ea657a32e72216baa3a524fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64dc53f34db1cea9ea657a32e72216baa3a524fb/comments", "author": null, "committer": null, "parents": [{"sha": "7b45d84d6003c363968fea7e52f12809c259cb83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b45d84d6003c363968fea7e52f12809c259cb83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b45d84d6003c363968fea7e52f12809c259cb83"}], "stats": {"total": 85, "additions": 34, "deletions": 51}, "files": [{"sha": "8a98ec8094ca16391c420cbd4c34da890f4f844b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64dc53f34db1cea9ea657a32e72216baa3a524fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64dc53f34db1cea9ea657a32e72216baa3a524fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=64dc53f34db1cea9ea657a32e72216baa3a524fb", "patch": "@@ -1,3 +1,11 @@\n+2000-03-06  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* function.c (free_temps_for_rtl_expr): Don't free slots\n+\tthat have been pushed into a higher level.\n+\t\n+\tRevert this patch:\n+\t2000-03-05  Mark Mitchell  <mark@codesourcery.com>\n+\n 2000-03-05  Mark Mitchell  <mark@codesourcery.com>\n \n \t* basic-block.h (ALLOCA_REG_SET): Remove."}, {"sha": "e0faa86a719615e78a3ba4cf2c1fa7d62654a9ce", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64dc53f34db1cea9ea657a32e72216baa3a524fb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64dc53f34db1cea9ea657a32e72216baa3a524fb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=64dc53f34db1cea9ea657a32e72216baa3a524fb", "patch": "@@ -1,3 +1,8 @@\n+2000-03-06  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* expr.c (cplus_expand_expr, case STMT_EXPR): Don't set\n+\tRTL_EXPR_HAS_NO_SCOPE after all.\n+\n 2000-03-05  Mark Mitchell  <mark@codesourcery.com>\n \n \t* expr.c (cplus_expand_expr, case STMT_EXPR): Use"}, {"sha": "3fe6f99b305eecb94116d370e96d58917d7e270a", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64dc53f34db1cea9ea657a32e72216baa3a524fb/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64dc53f34db1cea9ea657a32e72216baa3a524fb/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=64dc53f34db1cea9ea657a32e72216baa3a524fb", "patch": "@@ -148,7 +148,6 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \ttree rtl_expr = expand_start_stmt_expr ();\n \texpand_stmt (STMT_EXPR_STMT (exp));\n \texpand_end_stmt_expr (rtl_expr);\n-\tRTL_EXPR_HAS_NO_SCOPE (rtl_expr) = 1;\n \treturn expand_expr (rtl_expr, target, tmode, modifier);\n       }\n       break;"}, {"sha": "fb266e272264d85cf69ef821761e878909483743", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64dc53f34db1cea9ea657a32e72216baa3a524fb/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64dc53f34db1cea9ea657a32e72216baa3a524fb/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=64dc53f34db1cea9ea657a32e72216baa3a524fb", "patch": "@@ -6306,13 +6306,8 @@ expand_expr (exp, target, tmode, modifier)\n \t  emit_insns (RTL_EXPR_SEQUENCE (exp));\n \t  RTL_EXPR_SEQUENCE (exp) = const0_rtx;\n \t}\n-      if (RTL_EXPR_HAS_NO_SCOPE (exp))\n-\tpreserve_rtl_expr_temps (exp);\n-      else\n-\t{\n-\t  preserve_rtl_expr_result (RTL_EXPR_RTL (exp));\n-\t  free_temps_for_rtl_expr (exp);\n-\t}\n+      preserve_rtl_expr_result (RTL_EXPR_RTL (exp));\n+      free_temps_for_rtl_expr (exp);\n       return RTL_EXPR_RTL (exp);\n \n     case CONSTRUCTOR:"}, {"sha": "093a0d83c046f27556b2d07b92ed99fd7765bbb4", "filename": "gcc/function.c", "status": "modified", "additions": 15, "deletions": 34, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64dc53f34db1cea9ea657a32e72216baa3a524fb/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64dc53f34db1cea9ea657a32e72216baa3a524fb/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=64dc53f34db1cea9ea657a32e72216baa3a524fb", "patch": "@@ -293,7 +293,6 @@ static void mark_function_chain PARAMS ((void *));\n static void prepare_function_start PARAMS ((void));\n static void do_clobber_return_reg PARAMS ((rtx, void *));\n static void do_use_return_reg PARAMS ((rtx, void *));\n-static void preserve_rtl_expr_temp PARAMS ((struct temp_slot *));\n \f\n /* Pointer to chain of `struct function' for containing functions.  */\n struct function *outer_function_chain;\n@@ -1130,36 +1129,6 @@ preserve_temp_slots (x)\n       p->level--;\n }\n \n-/* Preserve the temporary slot given by P (originally created during\n-   the building of an RTL_EXPR) at least as long as things in our\n-   current scope.  */\n-\n-static void\n-preserve_rtl_expr_temp (p)\n-     struct temp_slot *p;\n-{\n-  /* Set the slot level to that of the currently prevailing scope.  */\n-  p->level = MIN (p->level, temp_slot_level);\n-  /* This slot is no longer associated with the RTL_EXPR from which it\n-     originated.  */\n-  p->rtl_expr = NULL_TREE;\n-}\n-\n-/* Preserve the temporary slots created during the building of the\n-   RTL_EXPR given by T at least as long as things in our current\n-   scope.  */\n-\n-void\n-preserve_rtl_expr_temps (t)\n-     tree t;\n-{\n-  struct temp_slot *p;\n-\n-  for (p = temp_slots; p; p = p->next)\n-    if (p->in_use && p->rtl_expr == t)\n-      preserve_rtl_expr_temp (p);\n-}\n-\n /* X is the result of an RTL_EXPR.  If it is a temporary slot associated\n    with that RTL_EXPR, promote it into a temporary slot at the present\n    level so it will not be freed when we free slots made in the\n@@ -1179,8 +1148,11 @@ preserve_rtl_expr_result (x)\n   /* If we can find a match, move it to our level unless it is already at\n      an upper level.  */\n   p = find_temp_slot_from_address (XEXP (x, 0));\n-  if (p)\n-    preserve_rtl_expr_temp (p);\n+  if (p != 0)\n+    {\n+      p->level = MIN (p->level, temp_slot_level);\n+      p->rtl_expr = 0;\n+    }\n \n   return;\n }\n@@ -1215,7 +1187,16 @@ free_temps_for_rtl_expr (t)\n \n   for (p = temp_slots; p; p = p->next)\n     if (p->rtl_expr == t)\n-      p->in_use = 0;\n+      {\n+\t/* If this slot is below the current TEMP_SLOT_LEVEL, then it\n+\t   needs to be preserved.  This can happen if a temporary in\n+\t   the RTL_EXPR was addressed; preserve_temp_slots will move\n+\t   the temporary into a higher level.   */\n+\tif (temp_slot_level <= p->level)\n+\t  p->in_use = 0;\n+\telse\n+\t  p->rtl_expr = NULL_TREE;\n+      }\n \n   combine_temp_slots ();\n }"}, {"sha": "92bc594e0dd08a912788f39dcf90020c2a242e63", "filename": "gcc/tree.def", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64dc53f34db1cea9ea657a32e72216baa3a524fb/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64dc53f34db1cea9ea657a32e72216baa3a524fb/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=64dc53f34db1cea9ea657a32e72216baa3a524fb", "patch": "@@ -689,11 +689,10 @@ DEFTREECODE (UNSAVE_EXPR, \"unsave_expr\", 'e', 1)\n /* Represents something whose RTL has already been expanded as a\n    sequence which should be emitted when this expression is expanded.\n    The first operand is the RTL to emit.  It is the first of a chain\n-   of insns.  The second is the RTL expression for the result.  If\n-   RTL_EXPR_HAS_NO_SCOPE does not hold for this expression, then all\n-   temporaries created within this RTL_EXPR (except for the\n-   RTL_EXPR_RTL) are out-of-scope after the RTL_EXPR is expanded.  (In\n-   other words, their stack slots may be reused.)  */\n+   of insns.  The second is the RTL expression for the result.  Any\n+   temporaries created during the building of the RTL_EXPR can be\n+   reused once the RTL_EXPR has been expanded, with the exception of\n+   the RTL_EXPR_RTL.  */\n DEFTREECODE (RTL_EXPR, \"rtl_expr\", 'e', 2)\n \n /* & in C.  Value is the address at which the operand's value resides."}, {"sha": "1a827581c6b3d573c95250ff5b8eb60aee6a89a6", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64dc53f34db1cea9ea657a32e72216baa3a524fb/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64dc53f34db1cea9ea657a32e72216baa3a524fb/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=64dc53f34db1cea9ea657a32e72216baa3a524fb", "patch": "@@ -749,10 +749,6 @@ struct tree_vec\n /* In a RTL_EXPR node.  */\n #define RTL_EXPR_SEQUENCE(NODE) (*(struct rtx_def **) &EXPR_CHECK (NODE)->exp.operands[0])\n #define RTL_EXPR_RTL(NODE) (*(struct rtx_def **) &EXPR_CHECK (NODE)->exp.operands[1])\n-/* Nonzero if the RTL_EXPR does not define a scope, i.e., if\n-   temporaries defined during its scope should persist even after the\n-   RTL_EXPR has been expanded.  */\n-#define RTL_EXPR_HAS_NO_SCOPE(NODE) TREE_ASM_WRITTEN (NODE)\n \n /* In a CALL_EXPR node.  */\n #define CALL_EXPR_RTL(NODE) (*(struct rtx_def **) &EXPR_CHECK (NODE)->exp.operands[2])"}]}