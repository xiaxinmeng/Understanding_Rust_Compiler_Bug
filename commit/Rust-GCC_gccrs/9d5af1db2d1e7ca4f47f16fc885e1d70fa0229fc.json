{"sha": "9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ1YWYxZGIyZDFlN2NhNGY0N2YxNmZjODg1ZTFkNzBmYTAyMjlmYw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-10-02T16:41:34Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-10-02T16:41:34Z"}, "message": "ipa: Bundle vectors describing argument values\n\nHi,\n\nthis large patch is mostly mechanical change which aims to replace\nuses of separate vectors about known scalar values (usually called\nknown_vals or known_csts), known aggregate values (known_aggs), known\nvirtual call contexts (known_contexts) and known value\nranges (known_value_ranges) with uses of either new type\nipa_call_arg_values or ipa_auto_call_arg_values, both of which simply\ncontain these vectors inside them.\n\nThe need for two distinct comes from the fact that when the vectors\nare constructed from jump functions or lattices, we really should use\nauto_vecs with embedded storage allocated on stack.  On the other hand,\nthe bundle in ipa_call_context can be allocated on heap when in cache,\none time for each call_graph node.\n\nipa_call_context is constructible from ipa_auto_call_arg_values but\nthen its vectors must not be resized, otherwise the vectors will stop\npointing to the stack ones.  Unfortunately, I don't think the\nstructure embedded in ipa_call_context can be made constant because we\nneed to manipulate and deallocate it when in cache.\n\ngcc/ChangeLog:\n\n2020-09-01  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.h (ipa_auto_call_arg_values): New type.\n\t(class ipa_call_arg_values): Likewise.\n\t(ipa_get_indirect_edge_target): Replaced vector arguments with\n\tipa_call_arg_values in declaration.  Added an overload for\n\tipa_auto_call_arg_values.\n\t* ipa-fnsummary.h (ipa_call_context): Removed members m_known_vals,\n\tm_known_contexts, m_known_aggs, duplicate_from, release and equal_to,\n\tnew members m_avals, store_to_cache and equivalent_to_p.  Adjusted\n\tconstrucotr arguments.\n\t(estimate_ipcp_clone_size_and_time): Replaced vector arguments\n\twith ipa_auto_call_arg_values in declaration.\n\t(evaluate_properties_for_edge): Likewise.\n\t* ipa-cp.c (ipa_get_indirect_edge_target): Adjusted to work on\n\tipa_call_arg_values rather than on separate vectors.  Added an\n\toverload for ipa_auto_call_arg_values.\n\t(devirtualization_time_bonus): Adjusted to work on\n\tipa_auto_call_arg_values rather than on separate vectors.\n\t(gather_context_independent_values): Adjusted to work on\n\tipa_auto_call_arg_values rather than on separate vectors.\n\t(perform_estimation_of_a_value): Likewise.\n\t(estimate_local_effects): Likewise.\n\t(modify_known_vectors_with_val): Adjusted both variants to work on\n\tipa_auto_call_arg_values and rename them to\n\tcopy_known_vectors_add_val.\n\t(decide_about_value): Adjusted to work on ipa_call_arg_values rather\n\tthan on separate vectors.\n\t(decide_whether_version_node): Likewise.\n\t* ipa-fnsummary.c (evaluate_conditions_for_known_args): Likewise.\n\t(evaluate_properties_for_edge): Likewise.\n\t(ipa_fn_summary_t::duplicate): Likewise.\n\t(estimate_edge_devirt_benefit): Adjusted to work on\n\tipa_call_arg_values rather than on separate vectors.\n\t(estimate_edge_size_and_time): Likewise.\n\t(estimate_calls_size_and_time_1): Likewise.\n\t(summarize_calls_size_and_time): Adjusted calls to\n\testimate_edge_size_and_time.\n\t(estimate_calls_size_and_time): Adjusted to work on\n\tipa_call_arg_values rather than on separate vectors.\n\t(ipa_call_context::ipa_call_context): Construct from a pointer to\n\tipa_auto_call_arg_values instead of inividual vectors.\n\t(ipa_call_context::duplicate_from): Adjusted to access vectors within\n\tm_avals.\n\t(ipa_call_context::release): Likewise.\n\t(ipa_call_context::equal_to): Likewise.\n\t(ipa_call_context::estimate_size_and_time): Adjusted to work on\n\tipa_call_arg_values rather than on separate vectors.\n\t(estimate_ipcp_clone_size_and_time): Adjusted to work with\n\tipa_auto_call_arg_values rather than on separate vectors.\n\t(ipa_merge_fn_summary_after_inlining): Likewise.  Adjusted call to\n\testimate_edge_size_and_time.\n\t(ipa_update_overall_fn_summary): Adjusted call to\n\testimate_edge_size_and_time.\n\t* ipa-inline-analysis.c (do_estimate_edge_time): Adjusted to work with\n\tipa_auto_call_arg_values rather than with separate vectors.\n\t(do_estimate_edge_size): Likewise.\n\t(do_estimate_edge_hints): Likewise.\n\t* ipa-prop.c (ipa_auto_call_arg_values::~ipa_auto_call_arg_values):\n\tNew destructor.", "tree": {"sha": "b3bf0625431eeee99ab6d73db07caec903d4b266", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3bf0625431eeee99ab6d73db07caec903d4b266"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "080a23bce12fa3f25860631f019777f728d2ef11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/080a23bce12fa3f25860631f019777f728d2ef11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/080a23bce12fa3f25860631f019777f728d2ef11"}], "stats": {"total": 875, "additions": 449, "deletions": 426}, "files": [{"sha": "292dd7e5bdf5b3bbc45ac942434143e70bf0636b", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 114, "deletions": 131, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc", "patch": "@@ -3117,30 +3117,40 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n   return target;\n }\n \n+/* If an indirect edge IE can be turned into a direct one based on data in\n+   AVALS, return the destination.  Store into *SPECULATIVE a boolean determinig\n+   whether the discovered target is only speculative guess.  */\n \n-/* If an indirect edge IE can be turned into a direct one based on KNOWN_CSTS,\n-   KNOWN_CONTEXTS (which can be vNULL) or KNOWN_AGGS (which also can be vNULL)\n-   return the destination.  */\n+tree\n+ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n+\t\t\t      ipa_call_arg_values *avals,\n+\t\t\t      bool *speculative)\n+{\n+  return ipa_get_indirect_edge_target_1 (ie, avals->m_known_vals,\n+\t\t\t\t\t avals->m_known_contexts,\n+\t\t\t\t\t avals->m_known_aggs,\n+\t\t\t\t\t NULL, speculative);\n+}\n+\n+/* The same functionality as above overloaded for ipa_auto_call_arg_values.  */\n \n tree\n ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n-\t\t\t      vec<tree> known_csts,\n-\t\t\t      vec<ipa_polymorphic_call_context> known_contexts,\n-\t\t\t      vec<ipa_agg_value_set> known_aggs,\n+\t\t\t      ipa_auto_call_arg_values *avals,\n \t\t\t      bool *speculative)\n {\n-  return ipa_get_indirect_edge_target_1 (ie, known_csts, known_contexts,\n-\t\t\t\t\t known_aggs, NULL, speculative);\n+  return ipa_get_indirect_edge_target_1 (ie, avals->m_known_vals,\n+\t\t\t\t\t avals->m_known_contexts,\n+\t\t\t\t\t avals->m_known_aggs,\n+\t\t\t\t\t NULL, speculative);\n }\n \n-/* Calculate devirtualization time bonus for NODE, assuming we know KNOWN_CSTS\n-   and KNOWN_CONTEXTS.  */\n+/* Calculate devirtualization time bonus for NODE, assuming we know information\n+   about arguments stored in AVALS.  */\n \n static int\n devirtualization_time_bonus (struct cgraph_node *node,\n-\t\t\t     vec<tree> known_csts,\n-\t\t\t     vec<ipa_polymorphic_call_context> known_contexts,\n-\t\t\t     vec<ipa_agg_value_set> known_aggs)\n+\t\t\t     ipa_auto_call_arg_values *avals)\n {\n   struct cgraph_edge *ie;\n   int res = 0;\n@@ -3153,8 +3163,7 @@ devirtualization_time_bonus (struct cgraph_node *node,\n       tree target;\n       bool speculative;\n \n-      target = ipa_get_indirect_edge_target (ie, known_csts, known_contexts,\n-\t\t\t\t\t     known_aggs, &speculative);\n+      target = ipa_get_indirect_edge_target (ie, avals, &speculative);\n       if (!target)\n \tcontinue;\n \n@@ -3306,32 +3315,27 @@ context_independent_aggregate_values (class ipcp_param_lattices *plats)\n   return res;\n }\n \n-/* Allocate KNOWN_CSTS, KNOWN_CONTEXTS and, if non-NULL, KNOWN_AGGS and\n-   populate them with values of parameters that are known independent of the\n-   context.  INFO describes the function.  If REMOVABLE_PARAMS_COST is\n-   non-NULL, the movement cost of all removable parameters will be stored in\n-   it.  */\n+/* Grow vectors in AVALS and fill them with information about values of\n+   parameters that are known to be independent of the context.  Only calculate\n+   m_known_aggs if CALCULATE_AGGS is true.  INFO describes the function.  If\n+   REMOVABLE_PARAMS_COST is non-NULL, the movement cost of all removable\n+   parameters will be stored in it.\n+\n+   TODO: Also grow context independent value range vectors.  */\n \n static bool\n gather_context_independent_values (class ipa_node_params *info,\n-\t\t\t\t   vec<tree> *known_csts,\n-\t\t\t\t   vec<ipa_polymorphic_call_context>\n-\t\t\t\t   *known_contexts,\n-\t\t\t\t   vec<ipa_agg_value_set> *known_aggs,\n+\t\t\t\t   ipa_auto_call_arg_values *avals,\n+\t\t\t\t   bool calculate_aggs,\n \t\t\t\t   int *removable_params_cost)\n {\n   int i, count = ipa_get_param_count (info);\n   bool ret = false;\n \n-  known_csts->create (0);\n-  known_contexts->create (0);\n-  known_csts->safe_grow_cleared (count, true);\n-  known_contexts->safe_grow_cleared (count, true);\n-  if (known_aggs)\n-    {\n-      known_aggs->create (0);\n-      known_aggs->safe_grow_cleared (count, true);\n-    }\n+  avals->m_known_vals.safe_grow_cleared (count, true);\n+  avals->m_known_contexts.safe_grow_cleared (count, true);\n+  if (calculate_aggs)\n+    avals->m_known_aggs.safe_grow_cleared (count, true);\n \n   if (removable_params_cost)\n     *removable_params_cost = 0;\n@@ -3345,7 +3349,7 @@ gather_context_independent_values (class ipa_node_params *info,\n \t{\n \t  ipcp_value<tree> *val = lat->values;\n \t  gcc_checking_assert (TREE_CODE (val->value) != TREE_BINFO);\n-\t  (*known_csts)[i] = val->value;\n+\t  avals->m_known_vals[i] = val->value;\n \t  if (removable_params_cost)\n \t    *removable_params_cost\n \t      += estimate_move_cost (TREE_TYPE (val->value), false);\n@@ -3363,15 +3367,15 @@ gather_context_independent_values (class ipa_node_params *info,\n       /* Do not account known context as reason for cloning.  We can see\n \t if it permits devirtualization.  */\n       if (ctxlat->is_single_const ())\n-\t(*known_contexts)[i] = ctxlat->values->value;\n+\tavals->m_known_contexts[i] = ctxlat->values->value;\n \n-      if (known_aggs)\n+      if (calculate_aggs)\n \t{\n \t  vec<ipa_agg_value> agg_items;\n \t  struct ipa_agg_value_set *agg;\n \n \t  agg_items = context_independent_aggregate_values (plats);\n-\t  agg = &(*known_aggs)[i];\n+\t  agg = &avals->m_known_aggs[i];\n \t  agg->items = agg_items;\n \t  agg->by_ref = plats->aggs_by_ref;\n \t  ret |= !agg_items.is_empty ();\n@@ -3381,25 +3385,23 @@ gather_context_independent_values (class ipa_node_params *info,\n   return ret;\n }\n \n-/* Perform time and size measurement of NODE with the context given in\n-   KNOWN_CSTS, KNOWN_CONTEXTS and KNOWN_AGGS, calculate the benefit and cost\n-   given BASE_TIME of the node without specialization, REMOVABLE_PARAMS_COST of\n-   all context-independent removable parameters and EST_MOVE_COST of estimated\n-   movement of the considered parameter and store it into VAL.  */\n+/* Perform time and size measurement of NODE with the context given in AVALS,\n+   calculate the benefit compared to the node without specialization and store\n+   it into VAL.  Take into account REMOVABLE_PARAMS_COST of all\n+   context-independent or unused removable parameters and EST_MOVE_COST, the\n+   estimated movement of the considered parameter.  */\n \n static void\n-perform_estimation_of_a_value (cgraph_node *node, vec<tree> known_csts,\n-\t\t\t       vec<ipa_polymorphic_call_context> known_contexts,\n-\t\t\t       vec<ipa_agg_value_set> known_aggs,\n-\t\t\t       int removable_params_cost,\n-\t\t\t       int est_move_cost, ipcp_value_base *val)\n+perform_estimation_of_a_value (cgraph_node *node,\n+\t\t\t       ipa_auto_call_arg_values *avals,\n+\t\t\t       int removable_params_cost, int est_move_cost,\n+\t\t\t       ipcp_value_base *val)\n {\n   int size, time_benefit;\n   sreal time, base_time;\n   ipa_hints hints;\n \n-  estimate_ipcp_clone_size_and_time (node, known_csts, known_contexts,\n-\t\t\t\t     known_aggs, &size, &time,\n+  estimate_ipcp_clone_size_and_time (node, avals, &size, &time,\n \t\t\t\t     &base_time, &hints);\n   base_time -= time;\n   if (base_time > 65535)\n@@ -3412,8 +3414,7 @@ perform_estimation_of_a_value (cgraph_node *node, vec<tree> known_csts,\n     time_benefit = 0;\n   else\n     time_benefit = base_time.to_int ()\n-      + devirtualization_time_bonus (node, known_csts, known_contexts,\n-\t\t\t\t     known_aggs)\n+      + devirtualization_time_bonus (node, avals)\n       + hint_time_bonus (node, hints)\n       + removable_params_cost + est_move_cost;\n \n@@ -3454,9 +3455,6 @@ estimate_local_effects (struct cgraph_node *node)\n {\n   class ipa_node_params *info = IPA_NODE_REF (node);\n   int i, count = ipa_get_param_count (info);\n-  vec<tree> known_csts;\n-  vec<ipa_polymorphic_call_context> known_contexts;\n-  vec<ipa_agg_value_set> known_aggs;\n   bool always_const;\n   int removable_params_cost;\n \n@@ -3466,11 +3464,10 @@ estimate_local_effects (struct cgraph_node *node)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"\\nEstimating effects for %s.\\n\", node->dump_name ());\n \n-  always_const = gather_context_independent_values (info, &known_csts,\n-\t\t\t\t\t\t    &known_contexts, &known_aggs,\n+  ipa_auto_call_arg_values avals;\n+  always_const = gather_context_independent_values (info, &avals, true,\n \t\t\t\t\t\t    &removable_params_cost);\n-  int devirt_bonus = devirtualization_time_bonus (node, known_csts,\n-\t\t\t\t\t   known_contexts, known_aggs);\n+  int devirt_bonus = devirtualization_time_bonus (node, &avals);\n   if (always_const || devirt_bonus\n       || (removable_params_cost && node->can_change_signature))\n     {\n@@ -3482,8 +3479,7 @@ estimate_local_effects (struct cgraph_node *node)\n       init_caller_stats (&stats);\n       node->call_for_symbol_thunks_and_aliases (gather_caller_stats, &stats,\n \t\t\t\t\t      false);\n-      estimate_ipcp_clone_size_and_time (node, known_csts, known_contexts,\n-\t\t\t\t\t known_aggs, &size, &time,\n+      estimate_ipcp_clone_size_and_time (node, &avals, &size, &time,\n \t\t\t\t\t &base_time, &hints);\n       time -= devirt_bonus;\n       time -= hint_time_bonus (node, hints);\n@@ -3536,18 +3532,17 @@ estimate_local_effects (struct cgraph_node *node)\n \n       if (lat->bottom\n \t  || !lat->values\n-\t  || known_csts[i])\n+\t  || avals.m_known_vals[i])\n \tcontinue;\n \n       for (val = lat->values; val; val = val->next)\n \t{\n \t  gcc_checking_assert (TREE_CODE (val->value) != TREE_BINFO);\n-\t  known_csts[i] = val->value;\n+\t  avals.m_known_vals[i] = val->value;\n \n \t  int emc = estimate_move_cost (TREE_TYPE (val->value), true);\n-\t  perform_estimation_of_a_value (node, known_csts, known_contexts,\n-\t\t\t\t\t known_aggs,\n-\t\t\t\t\t removable_params_cost, emc, val);\n+\t  perform_estimation_of_a_value (node, &avals, removable_params_cost,\n+\t\t\t\t\t emc, val);\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n@@ -3559,7 +3554,7 @@ estimate_local_effects (struct cgraph_node *node)\n \t\t       val->local_time_benefit, val->local_size_cost);\n \t    }\n \t}\n-      known_csts[i] = NULL_TREE;\n+      avals.m_known_vals[i] = NULL_TREE;\n     }\n \n   for (i = 0; i < count; i++)\n@@ -3574,15 +3569,14 @@ estimate_local_effects (struct cgraph_node *node)\n \n       if (ctxlat->bottom\n \t  || !ctxlat->values\n-\t  || !known_contexts[i].useless_p ())\n+\t  || !avals.m_known_contexts[i].useless_p ())\n \tcontinue;\n \n       for (val = ctxlat->values; val; val = val->next)\n \t{\n-\t  known_contexts[i] = val->value;\n-\t  perform_estimation_of_a_value (node, known_csts, known_contexts,\n-\t\t\t\t\t known_aggs,\n-\t\t\t\t\t removable_params_cost, 0, val);\n+\t  avals.m_known_contexts[i] = val->value;\n+\t  perform_estimation_of_a_value (node, &avals, removable_params_cost,\n+\t\t\t\t\t 0, val);\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    {\n@@ -3594,20 +3588,18 @@ estimate_local_effects (struct cgraph_node *node)\n \t\t       val->local_time_benefit, val->local_size_cost);\n \t    }\n \t}\n-      known_contexts[i] = ipa_polymorphic_call_context ();\n+      avals.m_known_contexts[i] = ipa_polymorphic_call_context ();\n     }\n \n   for (i = 0; i < count; i++)\n     {\n       class ipcp_param_lattices *plats = ipa_get_parm_lattices (info, i);\n-      struct ipa_agg_value_set *agg;\n-      struct ipcp_agg_lattice *aglat;\n \n       if (plats->aggs_bottom || !plats->aggs)\n \tcontinue;\n \n-      agg = &known_aggs[i];\n-      for (aglat = plats->aggs; aglat; aglat = aglat->next)\n+      ipa_agg_value_set *agg = &avals.m_known_aggs[i];\n+      for (ipcp_agg_lattice *aglat = plats->aggs; aglat; aglat = aglat->next)\n \t{\n \t  ipcp_value<tree> *val;\n \t  if (aglat->bottom || !aglat->values\n@@ -3624,8 +3616,7 @@ estimate_local_effects (struct cgraph_node *node)\n \t      item.value = val->value;\n \t      agg->items.safe_push (item);\n \n-\t      perform_estimation_of_a_value (node, known_csts, known_contexts,\n-\t\t\t\t\t     known_aggs,\n+\t      perform_estimation_of_a_value (node, &avals,\n \t\t\t\t\t     removable_params_cost, 0, val);\n \n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3645,10 +3636,6 @@ estimate_local_effects (struct cgraph_node *node)\n \t    }\n \t}\n     }\n-\n-  known_csts.release ();\n-  known_contexts.release ();\n-  ipa_release_agg_values (known_aggs);\n }\n \n \n@@ -5372,31 +5359,34 @@ copy_useful_known_contexts (vec<ipa_polymorphic_call_context> known_contexts)\n     return vNULL;\n }\n \n-/* Copy KNOWN_CSTS and modify the copy according to VAL and INDEX.  If\n-   non-empty, replace KNOWN_CONTEXTS with its copy too.  */\n+/* Copy known scalar values from AVALS into KNOWN_CSTS and modify the copy\n+   according to VAL and INDEX.  If non-empty, replace KNOWN_CONTEXTS with its\n+   copy too.  */\n \n static void\n-modify_known_vectors_with_val (vec<tree> *known_csts,\n-\t\t\t       vec<ipa_polymorphic_call_context> *known_contexts,\n-\t\t\t       ipcp_value<tree> *val,\n-\t\t\t       int index)\n+copy_known_vectors_add_val (ipa_auto_call_arg_values *avals,\n+\t\t\t    vec<tree> *known_csts,\n+\t\t\t    vec<ipa_polymorphic_call_context> *known_contexts,\n+\t\t\t    ipcp_value<tree> *val, int index)\n {\n-  *known_csts = known_csts->copy ();\n-  *known_contexts = copy_useful_known_contexts (*known_contexts);\n+  *known_csts = avals->m_known_vals.copy ();\n+  *known_contexts = copy_useful_known_contexts (avals->m_known_contexts);\n   (*known_csts)[index] = val->value;\n }\n \n-/* Replace KNOWN_CSTS with its copy.  Also copy KNOWN_CONTEXTS and modify the\n-   copy according to VAL and INDEX.  */\n+/* Copy known scalar values from AVALS into KNOWN_CSTS.  Similarly, copy\n+   contexts to KNOWN_CONTEXTS and modify the copy according to VAL and\n+   INDEX.  */\n \n static void\n-modify_known_vectors_with_val (vec<tree> *known_csts,\n-\t\t\t       vec<ipa_polymorphic_call_context> *known_contexts,\n-\t\t\t       ipcp_value<ipa_polymorphic_call_context> *val,\n-\t\t\t       int index)\n-{\n-  *known_csts = known_csts->copy ();\n-  *known_contexts = known_contexts->copy ();\n+copy_known_vectors_add_val (ipa_auto_call_arg_values *avals,\n+\t\t\t    vec<tree> *known_csts,\n+\t\t\t    vec<ipa_polymorphic_call_context> *known_contexts,\n+\t\t\t    ipcp_value<ipa_polymorphic_call_context> *val,\n+\t\t\t    int index)\n+{\n+  *known_csts = avals->m_known_vals.copy ();\n+  *known_contexts = avals->m_known_contexts.copy ();\n   (*known_contexts)[index] = val->value;\n }\n \n@@ -5433,16 +5423,15 @@ ipcp_val_agg_replacement_ok_p (ipa_agg_replacement_value *,\n   return offset == -1;\n }\n \n-/* Decide whether to create a special version of NODE for value VAL of parameter\n-   at the given INDEX.  If OFFSET is -1, the value is for the parameter itself,\n-   otherwise it is stored at the given OFFSET of the parameter.  KNOWN_CSTS,\n-   KNOWN_CONTEXTS and KNOWN_AGGS describe the other already known values.  */\n+/* Decide whether to create a special version of NODE for value VAL of\n+   parameter at the given INDEX.  If OFFSET is -1, the value is for the\n+   parameter itself, otherwise it is stored at the given OFFSET of the\n+   parameter.  AVALS describes the other already known values.  */\n \n template <typename valtype>\n static bool\n decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n-\t\t    ipcp_value<valtype> *val, vec<tree> known_csts,\n-\t\t    vec<ipa_polymorphic_call_context> known_contexts)\n+\t\t    ipcp_value<valtype> *val, ipa_auto_call_arg_values *avals)\n {\n   struct ipa_agg_replacement_value *aggvals;\n   int freq_sum, caller_count;\n@@ -5492,13 +5481,16 @@ decide_about_value (struct cgraph_node *node, int index, HOST_WIDE_INT offset,\n     fprintf (dump_file, \"  Creating a specialized node of %s.\\n\",\n \t     node->dump_name ());\n \n+  vec<tree> known_csts;\n+  vec<ipa_polymorphic_call_context> known_contexts;\n+\n   callers = gather_edges_for_value (val, node, caller_count);\n   if (offset == -1)\n-    modify_known_vectors_with_val (&known_csts, &known_contexts, val, index);\n+    copy_known_vectors_add_val (avals, &known_csts, &known_contexts, val, index);\n   else\n     {\n-      known_csts = known_csts.copy ();\n-      known_contexts = copy_useful_known_contexts (known_contexts);\n+      known_csts = avals->m_known_vals.copy ();\n+      known_contexts = copy_useful_known_contexts (avals->m_known_contexts);\n     }\n   find_more_scalar_values_for_callers_subset (node, known_csts, callers);\n   find_more_contexts_for_caller_subset (node, &known_contexts, callers);\n@@ -5522,8 +5514,6 @@ decide_whether_version_node (struct cgraph_node *node)\n {\n   class ipa_node_params *info = IPA_NODE_REF (node);\n   int i, count = ipa_get_param_count (info);\n-  vec<tree> known_csts;\n-  vec<ipa_polymorphic_call_context> known_contexts;\n   bool ret = false;\n \n   if (count == 0)\n@@ -5533,8 +5523,8 @@ decide_whether_version_node (struct cgraph_node *node)\n     fprintf (dump_file, \"\\nEvaluating opportunities for %s.\\n\",\n \t     node->dump_name ());\n \n-  gather_context_independent_values (info, &known_csts, &known_contexts,\n-\t\t\t\t     NULL, NULL);\n+  ipa_auto_call_arg_values avals;\n+  gather_context_independent_values (info, &avals, false, NULL);\n \n   for (i = 0; i < count;i++)\n     {\n@@ -5543,12 +5533,11 @@ decide_whether_version_node (struct cgraph_node *node)\n       ipcp_lattice<ipa_polymorphic_call_context> *ctxlat = &plats->ctxlat;\n \n       if (!lat->bottom\n-\t  && !known_csts[i])\n+\t  && !avals.m_known_vals[i])\n \t{\n \t  ipcp_value<tree> *val;\n \t  for (val = lat->values; val; val = val->next)\n-\t    ret |= decide_about_value (node, i, -1, val, known_csts,\n-\t\t\t\t       known_contexts);\n+\t    ret |= decide_about_value (node, i, -1, val, &avals);\n \t}\n \n       if (!plats->aggs_bottom)\n@@ -5557,22 +5546,20 @@ decide_whether_version_node (struct cgraph_node *node)\n \t  ipcp_value<tree> *val;\n \t  for (aglat = plats->aggs; aglat; aglat = aglat->next)\n \t    if (!aglat->bottom && aglat->values\n-\t\t/* If the following is false, the one value is in\n-\t\t   known_aggs.  */\n+\t\t/* If the following is false, the one value has been considered\n+\t\t   for cloning for all contexts.  */\n \t\t&& (plats->aggs_contain_variable\n \t\t    || !aglat->is_single_const ()))\n \t      for (val = aglat->values; val; val = val->next)\n-\t\tret |= decide_about_value (node, i, aglat->offset, val,\n-\t\t\t\t\t   known_csts, known_contexts);\n+\t\tret |= decide_about_value (node, i, aglat->offset, val, &avals);\n \t}\n \n       if (!ctxlat->bottom\n-\t  && known_contexts[i].useless_p ())\n+\t  && avals.m_known_contexts[i].useless_p ())\n \t{\n \t  ipcp_value<ipa_polymorphic_call_context> *val;\n \t  for (val = ctxlat->values; val; val = val->next)\n-\t    ret |= decide_about_value (node, i, -1, val, known_csts,\n-\t\t\t\t       known_contexts);\n+\t    ret |= decide_about_value (node, i, -1, val, &avals);\n \t}\n \n \tinfo = IPA_NODE_REF (node);\n@@ -5595,11 +5582,9 @@ decide_whether_version_node (struct cgraph_node *node)\n       if (!adjust_callers_for_value_intersection (callers, node))\n \t{\n \t  /* If node is not called by anyone, or all its caller edges are\n-\t     self-recursive, the node is not really be in use, no need to\n-\t     do cloning.  */\n+\t     self-recursive, the node is not really in use, no need to do\n+\t     cloning.  */\n \t  callers.release ();\n-\t  known_csts.release ();\n-\t  known_contexts.release ();\n \t  info->do_clone_for_all_contexts = false;\n \t  return ret;\n \t}\n@@ -5608,6 +5593,9 @@ decide_whether_version_node (struct cgraph_node *node)\n \tfprintf (dump_file, \" - Creating a specialized node of %s \"\n \t\t \"for all known contexts.\\n\", node->dump_name ());\n \n+      vec<tree> known_csts = avals.m_known_vals.copy ();\n+      vec<ipa_polymorphic_call_context> known_contexts\n+\t= copy_useful_known_contexts (avals.m_known_contexts);\n       find_more_scalar_values_for_callers_subset (node, known_csts, callers);\n       find_more_contexts_for_caller_subset (node, &known_contexts, callers);\n       ipa_agg_replacement_value *aggvals\n@@ -5625,11 +5613,6 @@ decide_whether_version_node (struct cgraph_node *node)\n       IPA_NODE_REF (clone)->is_all_contexts_clone = true;\n       ret = true;\n     }\n-  else\n-    {\n-      known_csts.release ();\n-      known_contexts.release ();\n-    }\n \n   return ret;\n }"}, {"sha": "b525cfd5c3bf26ebdd5bfe88b0a17f4a8e8dd454", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 198, "deletions": 242, "changes": 440, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc", "patch": "@@ -320,19 +320,18 @@ set_hint_predicate (predicate **p, predicate new_predicate)\n    is always false in the second and also builtin_constant_p tests cannot use\n    the fact that parameter is indeed a constant.\n \n-   KNOWN_VALS is partial mapping of parameters of NODE to constant values.\n-   KNOWN_AGGS is a vector of aggregate known offset/value set for each\n-   parameter.  Return clause of possible truths.  When INLINE_P is true, assume\n-   that we are inlining.\n+   When INLINE_P is true, assume that we are inlining.  AVAL contains known\n+   information about argument values.  The function does not modify its content\n+   and so AVALs could also be of type ipa_call_arg_values but so far all\n+   callers work with the auto version and so we avoid the conversion for\n+   convenience.\n \n-   ERROR_MARK means compile time invariant.  */\n+   ERROR_MARK value of an argument means compile time invariant.  */\n \n static void\n evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t\t\t\t    bool inline_p,\n-\t\t\t\t    vec<tree> known_vals,\n-\t\t\t\t    vec<value_range> known_value_ranges,\n-\t\t\t\t    vec<ipa_agg_value_set> known_aggs,\n+\t\t\t\t    ipa_auto_call_arg_values *avals,\n \t\t\t\t    clause_t *ret_clause,\n \t\t\t\t    clause_t *ret_nonspec_clause)\n {\n@@ -351,38 +350,33 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \n       /* We allow call stmt to have fewer arguments than the callee function\n          (especially for K&R style programs).  So bound check here (we assume\n-         known_aggs vector, if non-NULL, has the same length as\n-         known_vals).  */\n-      gcc_checking_assert (!known_aggs.length () || !known_vals.length ()\n-\t\t\t   || (known_vals.length () == known_aggs.length ()));\n+         m_known_aggs vector is either empty or has the same length as\n+         m_known_vals).  */\n+      gcc_checking_assert (!avals->m_known_aggs.length ()\n+\t\t\t   || !avals->m_known_vals.length ()\n+\t\t\t   || (avals->m_known_vals.length ()\n+\t\t\t       == avals->m_known_aggs.length ()));\n \n       if (c->agg_contents)\n \t{\n-\t  struct ipa_agg_value_set *agg;\n-\n \t  if (c->code == predicate::changed\n \t      && !c->by_ref\n-\t      && c->operand_num < (int)known_vals.length ()\n-\t      && (known_vals[c->operand_num] == error_mark_node))\n+\t      && (avals->safe_sval_at(c->operand_num) == error_mark_node))\n \t    continue;\n \n-\t  if (c->operand_num < (int)known_aggs.length ())\n+\t  if (ipa_agg_value_set *agg = avals->safe_aggval_at (c->operand_num))\n \t    {\n-\t      agg = &known_aggs[c->operand_num];\n-\t      val = ipa_find_agg_cst_for_param (agg,\n-\t\t\t\t\t\tc->operand_num\n-\t\t\t\t\t\t   < (int) known_vals.length ()\n-\t\t\t\t\t\t? known_vals[c->operand_num]\n-\t\t\t\t\t\t: NULL,\n-\t\t\t\t\t\tc->offset, c->by_ref);\n+\t      tree sval = avals->safe_sval_at (c->operand_num);\n+\t      val = ipa_find_agg_cst_for_param (agg, sval, c->offset,\n+\t\t\t\t\t\tc->by_ref);\n \t    }\n \t  else\n \t    val = NULL_TREE;\n \t}\n-      else if (c->operand_num < (int) known_vals.length ())\n+      else\n \t{\n-\t  val = known_vals[c->operand_num];\n-\t  if (val == error_mark_node && c->code != predicate::changed)\n+\t  val = avals->safe_sval_at (c->operand_num);\n+\t  if (val && val == error_mark_node && c->code != predicate::changed)\n \t    val = NULL_TREE;\n \t}\n \n@@ -446,53 +440,54 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t      continue;\n \t    }\n \t}\n-      if (c->operand_num < (int) known_value_ranges.length ()\n+      if (c->operand_num < (int) avals->m_known_value_ranges.length ()\n \t  && !c->agg_contents\n-\t  && !known_value_ranges[c->operand_num].undefined_p ()\n-\t  && !known_value_ranges[c->operand_num].varying_p ()\n-\t  && TYPE_SIZE (c->type)\n-\t\t == TYPE_SIZE (known_value_ranges[c->operand_num].type ())\n \t  && (!val || TREE_CODE (val) != INTEGER_CST))\n \t{\n-\t  value_range vr = known_value_ranges[c->operand_num];\n-\t  if (!useless_type_conversion_p (c->type, vr.type ()))\n+\t  value_range vr = avals->m_known_value_ranges[c->operand_num];\n+\t  if (!vr.undefined_p ()\n+\t      && !vr.varying_p ()\n+\t      && (TYPE_SIZE (c->type) == TYPE_SIZE (vr.type ())))\n \t    {\n-\t      value_range res;\n-\t      range_fold_unary_expr (&res, NOP_EXPR,\n+\t      if (!useless_type_conversion_p (c->type, vr.type ()))\n+\t\t{\n+\t\t  value_range res;\n+\t\t  range_fold_unary_expr (&res, NOP_EXPR,\n \t\t\t\t     c->type, &vr, vr.type ());\n-\t      vr = res;\n-\t    }\n-\t  tree type = c->type;\n+\t\t  vr = res;\n+\t\t}\n+\t      tree type = c->type;\n \n-\t  for (j = 0; vec_safe_iterate (c->param_ops, j, &op); j++)\n-\t    {\n-\t      if (vr.varying_p () || vr.undefined_p ())\n-\t\tbreak;\n+\t      for (j = 0; vec_safe_iterate (c->param_ops, j, &op); j++)\n+\t\t{\n+\t\t  if (vr.varying_p () || vr.undefined_p ())\n+\t\t    break;\n \n-\t      value_range res;\n-\t      if (!op->val[0])\n-\t        range_fold_unary_expr (&res, op->code, op->type, &vr, type);\n-\t      else if (!op->val[1])\n+\t\t  value_range res;\n+\t\t  if (!op->val[0])\n+\t\t    range_fold_unary_expr (&res, op->code, op->type, &vr, type);\n+\t\t  else if (!op->val[1])\n+\t\t    {\n+\t\t      value_range op0 (op->val[0], op->val[0]);\n+\t\t      range_fold_binary_expr (&res, op->code, op->type,\n+\t\t\t\t\t      op->index ? &op0 : &vr,\n+\t\t\t\t\t      op->index ? &vr : &op0);\n+\t\t    }\n+\t\t  else\n+\t\t    gcc_unreachable ();\n+\t\t  type = op->type;\n+\t\t  vr = res;\n+\t\t}\n+\t      if (!vr.varying_p () && !vr.undefined_p ())\n \t\t{\n-\t\t  value_range op0 (op->val[0], op->val[0]);\n-\t\t  range_fold_binary_expr (&res, op->code, op->type,\n-\t\t\t\t\t  op->index ? &op0 : &vr,\n-\t\t\t\t\t  op->index ? &vr : &op0);\n+\t\t  value_range res;\n+\t\t  value_range val_vr (c->val, c->val);\n+\t\t  range_fold_binary_expr (&res, c->code, boolean_type_node,\n+\t\t\t\t\t  &vr,\n+\t\t\t\t\t  &val_vr);\n+\t\t  if (res.zero_p ())\n+\t\t    continue;\n \t\t}\n-\t      else\n-\t\tgcc_unreachable ();\n-\t      type = op->type;\n-\t      vr = res;\n-\t    }\n-\t  if (!vr.varying_p () && !vr.undefined_p ())\n-\t    {\n-\t      value_range res;\n-\t      value_range val_vr (c->val, c->val);\n-\t      range_fold_binary_expr (&res, c->code, boolean_type_node,\n-\t\t\t\t      &vr,\n-\t\t\t\t      &val_vr);\n-\t      if (res.zero_p ())\n-\t\tcontinue;\n \t    }\n \t}\n \n@@ -538,32 +533,28 @@ fre_will_run_p (struct cgraph_node *node)\n    (if non-NULL) conditions evaluated for nonspecialized clone called\n    in a given context.\n \n-   KNOWN_VALS_PTR and KNOWN_AGGS_PTR must be non-NULL and will be filled by\n-   known constant and aggregate values of parameters.\n-\n-   KNOWN_CONTEXT_PTR, if non-NULL, will be filled by polymorphic call contexts\n-   of parameter used by a polymorphic call.  */\n+   Vectors in AVALS will be populated with useful known information about\n+   argument values - information not known to have any uses will be omitted -\n+   except for m_known_contexts which will only be calculated if\n+   COMPUTE_CONTEXTS is true.  */\n \n void\n evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t\t\t      clause_t *clause_ptr,\n \t\t\t      clause_t *nonspec_clause_ptr,\n-\t\t\t      vec<tree> *known_vals_ptr,\n-\t\t\t      vec<ipa_polymorphic_call_context>\n-\t\t\t      *known_contexts_ptr,\n-\t\t\t      vec<ipa_agg_value_set> *known_aggs_ptr)\n+\t\t\t      ipa_auto_call_arg_values *avals,\n+\t\t\t      bool compute_contexts)\n {\n   struct cgraph_node *callee = e->callee->ultimate_alias_target ();\n   class ipa_fn_summary *info = ipa_fn_summaries->get (callee);\n-  auto_vec<value_range, 32> known_value_ranges;\n   class ipa_edge_args *args;\n \n   if (clause_ptr)\n     *clause_ptr = inline_p ? 0 : 1 << predicate::not_inlined_condition;\n \n   if (ipa_node_params_sum\n       && !e->call_stmt_cannot_inline_p\n-      && (info->conds || known_contexts_ptr)\n+      && (info->conds || compute_contexts)\n       && (args = IPA_EDGE_REF (e)) != NULL)\n     {\n       struct cgraph_node *caller;\n@@ -608,35 +599,36 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t\tif (cst)\n \t\t  {\n \t\t    gcc_checking_assert (TREE_CODE (cst) != TREE_BINFO);\n-\t\t    if (!known_vals_ptr->length ())\n-\t\t      vec_safe_grow_cleared (known_vals_ptr, count, true);\n-\t\t    (*known_vals_ptr)[i] = cst;\n+\t\t    if (!avals->m_known_vals.length ())\n+\t\t      avals->m_known_vals.safe_grow_cleared (count, true);\n+\t\t    avals->m_known_vals[i] = cst;\n \t\t  }\n \t\telse if (inline_p && !es->param[i].change_prob)\n \t\t  {\n-\t\t    if (!known_vals_ptr->length ())\n-\t\t      vec_safe_grow_cleared (known_vals_ptr, count, true);\n-\t\t    (*known_vals_ptr)[i] = error_mark_node;\n+\t\t    if (!avals->m_known_vals.length ())\n+\t\t      avals->m_known_vals.safe_grow_cleared (count, true);\n+\t\t    avals->m_known_vals[i] = error_mark_node;\n \t\t  }\n \n \t\t/* If we failed to get simple constant, try value range.  */\n \t\tif ((!cst || TREE_CODE (cst) != INTEGER_CST)\n \t\t    && vrp_will_run_p (caller)\n \t\t    && ipa_is_param_used_by_ipa_predicates (callee_pi, i))\n \t\t  {\n-\t\t    value_range vr \n+\t\t    value_range vr\n \t\t       = ipa_value_range_from_jfunc (caller_parms_info, e, jf,\n \t\t\t\t\t\t     ipa_get_type (callee_pi,\n \t\t\t\t\t\t\t\t   i));\n \t\t    if (!vr.undefined_p () && !vr.varying_p ())\n \t\t      {\n-\t\t\tif (!known_value_ranges.length ())\n+\t\t\tif (!avals->m_known_value_ranges.length ())\n \t\t\t  {\n-\t\t\t    known_value_ranges.safe_grow (count, true);\n+\t\t\t    avals->m_known_value_ranges.safe_grow (count, true);\n \t\t\t    for (int i = 0; i < count; ++i)\n-\t\t\t      new (&known_value_ranges[i]) value_range ();\n+\t\t\t      new (&avals->m_known_value_ranges[i])\n+\t\t\t\tvalue_range ();\n \t\t\t  }\n-\t\t\tknown_value_ranges[i] = vr;\n+\t\t\tavals->m_known_value_ranges[i] = vr;\n \t\t      }\n \t\t  }\n \n@@ -648,25 +640,25 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t\t\t\t\t\t\tcaller, &jf->agg);\n \t\t    if (agg.items.length ())\n \t\t      {\n-\t\t\tif (!known_aggs_ptr->length ())\n-\t\t\t  vec_safe_grow_cleared (known_aggs_ptr, count, true);\n-\t\t\t(*known_aggs_ptr)[i] = agg;\n+\t\t\tif (!avals->m_known_aggs.length ())\n+\t\t\t  avals->m_known_aggs.safe_grow_cleared (count, true);\n+\t\t\tavals->m_known_aggs[i] = agg;\n \t\t      }\n \t\t  }\n \t      }\n \n \t    /* For calls used in polymorphic calls we further determine\n \t       polymorphic call context.  */\n-\t    if (known_contexts_ptr\n+\t    if (compute_contexts\n \t\t&& ipa_is_param_used_by_polymorphic_call (callee_pi, i))\n \t      {\n \t\tipa_polymorphic_call_context\n \t\t   ctx = ipa_context_from_jfunc (caller_parms_info, e, i, jf);\n \t\tif (!ctx.useless_p ())\n \t\t  {\n-\t\t    if (!known_contexts_ptr->length ())\n-\t\t      known_contexts_ptr->safe_grow_cleared (count, true);\n-\t\t    (*known_contexts_ptr)[i]\n+\t\t    if (!avals->m_known_contexts.length ())\n+\t\t      avals->m_known_contexts.safe_grow_cleared (count, true);\n+\t\t    avals->m_known_contexts[i]\n \t\t      = ipa_context_from_jfunc (caller_parms_info, e, i, jf);\n \t\t  }\n \t       }\n@@ -685,18 +677,14 @@ evaluate_properties_for_edge (struct cgraph_edge *e, bool inline_p,\n \t    cst = NULL;\n \t  if (cst)\n \t    {\n-\t      if (!known_vals_ptr->length ())\n-\t\tvec_safe_grow_cleared (known_vals_ptr, count, true);\n-\t      (*known_vals_ptr)[i] = cst;\n+\t      if (!avals->m_known_vals.length ())\n+\t\tavals->m_known_vals.safe_grow_cleared (count, true);\n+\t      avals->m_known_vals[i] = cst;\n \t    }\n \t}\n     }\n \n-  evaluate_conditions_for_known_args (callee, inline_p,\n-\t\t\t\t      *known_vals_ptr,\n-\t\t\t\t      known_value_ranges,\n-\t\t\t\t      *known_aggs_ptr,\n-\t\t\t\t      clause_ptr,\n+  evaluate_conditions_for_known_args (callee, inline_p, avals, clause_ptr,\n \t\t\t\t      nonspec_clause_ptr);\n }\n \n@@ -781,7 +769,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n       vec<size_time_entry, va_gc> *entry = info->size_time_table;\n       /* Use SRC parm info since it may not be copied yet.  */\n       class ipa_node_params *parms_info = IPA_NODE_REF (src);\n-      vec<tree> known_vals = vNULL;\n+      ipa_auto_call_arg_values avals;\n       int count = ipa_get_param_count (parms_info);\n       int i, j;\n       clause_t possible_truths;\n@@ -792,7 +780,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n       struct cgraph_edge *edge, *next;\n \n       info->size_time_table = 0;\n-      known_vals.safe_grow_cleared (count, true);\n+      avals.m_known_vals.safe_grow_cleared (count, true);\n       for (i = 0; i < count; i++)\n \t{\n \t  struct ipa_replace_map *r;\n@@ -801,20 +789,17 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n \t    {\n \t      if (r->parm_num == i)\n \t\t{\n-\t\t  known_vals[i] = r->new_tree;\n+\t\t  avals.m_known_vals[i] = r->new_tree;\n \t\t  break;\n \t\t}\n \t    }\n \t}\n       evaluate_conditions_for_known_args (dst, false,\n-\t\t\t\t\t  known_vals,\n-\t\t\t\t\t  vNULL,\n-\t\t\t\t\t  vNULL,\n+\t\t\t\t\t  &avals,\n \t\t\t\t\t  &possible_truths,\n \t\t\t\t\t  /* We are going to specialize,\n \t\t\t\t\t     so ignore nonspec truths.  */\n \t\t\t\t\t  NULL);\n-      known_vals.release ();\n \n       info->account_size_time (0, 0, true_pred, true_pred);\n \n@@ -3054,29 +3039,28 @@ compute_fn_summary_for_current (void)\n   return 0;\n }\n \n-/* Estimate benefit devirtualizing indirect edge IE, provided KNOWN_VALS,\n-   KNOWN_CONTEXTS and KNOWN_AGGS.  */\n+/* Estimate benefit devirtualizing indirect edge IE and return true if it can\n+   be devirtualized and inlined, provided m_known_vals, m_known_contexts and\n+   m_known_aggs in AVALS.  Return false straight away if AVALS is NULL.  */\n \n static bool\n estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n \t\t\t      int *size, int *time,\n-\t\t\t      vec<tree> known_vals,\n-\t\t\t      vec<ipa_polymorphic_call_context> known_contexts,\n-\t\t\t      vec<ipa_agg_value_set> known_aggs)\n+\t\t\t      ipa_call_arg_values *avals)\n {\n   tree target;\n   struct cgraph_node *callee;\n   class ipa_fn_summary *isummary;\n   enum availability avail;\n   bool speculative;\n \n-  if (!known_vals.length () && !known_contexts.length ())\n+  if (!avals\n+      || (!avals->m_known_vals.length() && !avals->m_known_contexts.length ()))\n     return false;\n   if (!opt_for_fn (ie->caller->decl, flag_indirect_inlining))\n     return false;\n \n-  target = ipa_get_indirect_edge_target (ie, known_vals, known_contexts,\n-\t\t\t\t\t known_aggs, &speculative);\n+  target = ipa_get_indirect_edge_target (ie, avals, &speculative);\n   if (!target || speculative)\n     return false;\n \n@@ -3100,17 +3084,13 @@ estimate_edge_devirt_benefit (struct cgraph_edge *ie,\n }\n \n /* Increase SIZE, MIN_SIZE (if non-NULL) and TIME for size and time needed to\n-   handle edge E with probability PROB.\n-   Set HINTS if edge may be devirtualized.\n-   KNOWN_VALS, KNOWN_AGGS and KNOWN_CONTEXTS describe context of the call\n-   site.  */\n+   handle edge E with probability PROB.  Set HINTS accordingly if edge may be\n+   devirtualized.  AVALS, if non-NULL, describes the context of the call site\n+   as far as values of parameters are concerened.  */\n \n static inline void\n estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n-\t\t\t     sreal *time,\n-\t\t\t     vec<tree> known_vals,\n-\t\t\t     vec<ipa_polymorphic_call_context> known_contexts,\n-\t\t\t     vec<ipa_agg_value_set> known_aggs,\n+\t\t\t     sreal *time, ipa_call_arg_values *avals,\n \t\t\t     ipa_hints *hints)\n {\n   class ipa_call_summary *es = ipa_call_summaries->get (e);\n@@ -3119,8 +3099,7 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n   int cur_size;\n \n   if (!e->callee && hints && e->maybe_hot_p ()\n-      && estimate_edge_devirt_benefit (e, &call_size, &call_time,\n-\t\t\t\t       known_vals, known_contexts, known_aggs))\n+      && estimate_edge_devirt_benefit (e, &call_size, &call_time, avals))\n     *hints |= INLINE_HINT_indirect_call;\n   cur_size = call_size * ipa_fn_summary::size_scale;\n   *size += cur_size;\n@@ -3132,9 +3111,9 @@ estimate_edge_size_and_time (struct cgraph_edge *e, int *size, int *min_size,\n \n \n /* Increase SIZE, MIN_SIZE and TIME for size and time needed to handle all\n-   calls in NODE.  POSSIBLE_TRUTHS, KNOWN_VALS, KNOWN_AGGS and KNOWN_CONTEXTS\n-   describe context of the call site.\n- \n+   calls in NODE.  POSSIBLE_TRUTHS and AVALS describe the context of the call\n+   site.\n+\n    Helper for estimate_calls_size_and_time which does the same but\n    (in most cases) faster.  */\n \n@@ -3143,9 +3122,7 @@ estimate_calls_size_and_time_1 (struct cgraph_node *node, int *size,\n \t\t\t        int *min_size, sreal *time,\n \t\t\t        ipa_hints *hints,\n \t\t\t        clause_t possible_truths,\n-\t\t\t        vec<tree> known_vals,\n-\t\t\t        vec<ipa_polymorphic_call_context> known_contexts,\n-\t\t\t        vec<ipa_agg_value_set> known_aggs)\n+\t\t\t\tipa_call_arg_values *avals)\n {\n   struct cgraph_edge *e;\n   for (e = node->callees; e; e = e->next_callee)\n@@ -3154,10 +3131,8 @@ estimate_calls_size_and_time_1 (struct cgraph_node *node, int *size,\n \t{\n \t  gcc_checking_assert (!ipa_call_summaries->get (e));\n \t  estimate_calls_size_and_time_1 (e->callee, size, min_size, time,\n-\t\t\t\t\t  hints,\n-\t\t\t\t\t  possible_truths,\n-\t\t\t\t\t  known_vals, known_contexts,\n-\t\t\t\t\t  known_aggs);\n+\t\t\t\t\t  hints, possible_truths, avals);\n+\n \t  continue;\n \t}\n       class ipa_call_summary *es = ipa_call_summaries->get (e);\n@@ -3175,9 +3150,7 @@ estimate_calls_size_and_time_1 (struct cgraph_node *node, int *size,\n \t     so we do not need to compute probabilities.  */\n \t  estimate_edge_size_and_time (e, size,\n \t\t\t\t       es->predicate ? NULL : min_size,\n-\t\t\t\t       time,\n-\t\t\t\t       known_vals, known_contexts,\n-\t\t\t\t       known_aggs, hints);\n+\t\t\t\t       time, avals, hints);\n \t}\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n@@ -3187,9 +3160,7 @@ estimate_calls_size_and_time_1 (struct cgraph_node *node, int *size,\n \t  || es->predicate->evaluate (possible_truths))\n \testimate_edge_size_and_time (e, size,\n \t\t\t\t     es->predicate ? NULL : min_size,\n-\t\t\t\t     time,\n-\t\t\t\t     known_vals, known_contexts, known_aggs,\n-\t\t\t\t     hints);\n+\t\t\t\t     time, avals, hints);\n     }\n }\n \n@@ -3211,8 +3182,7 @@ summarize_calls_size_and_time (struct cgraph_node *node,\n       int size = 0;\n       sreal time = 0;\n \n-      estimate_edge_size_and_time (e, &size, NULL, &time,\n-\t\t\t\t   vNULL, vNULL, vNULL, NULL);\n+      estimate_edge_size_and_time (e, &size, NULL, &time, NULL, NULL);\n \n       struct predicate pred = true;\n       class ipa_call_summary *es = ipa_call_summaries->get (e);\n@@ -3226,8 +3196,7 @@ summarize_calls_size_and_time (struct cgraph_node *node,\n       int size = 0;\n       sreal time = 0;\n \n-      estimate_edge_size_and_time (e, &size, NULL, &time,\n-\t\t\t\t   vNULL, vNULL, vNULL, NULL);\n+      estimate_edge_size_and_time (e, &size, NULL, &time, NULL, NULL);\n       struct predicate pred = true;\n       class ipa_call_summary *es = ipa_call_summaries->get (e);\n \n@@ -3238,17 +3207,15 @@ summarize_calls_size_and_time (struct cgraph_node *node,\n }\n \n /* Increase SIZE, MIN_SIZE and TIME for size and time needed to handle all\n-   calls in NODE.  POSSIBLE_TRUTHS, KNOWN_VALS, KNOWN_AGGS and KNOWN_CONTEXTS\n-   describe context of the call site.  */\n+   calls in NODE.  POSSIBLE_TRUTHS and AVALS (the latter if non-NULL) describe\n+   context of the call site.  */\n \n static void\n estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n \t\t\t      int *min_size, sreal *time,\n \t\t\t      ipa_hints *hints,\n \t\t\t      clause_t possible_truths,\n-\t\t\t      vec<tree> known_vals,\n-\t\t\t      vec<ipa_polymorphic_call_context> known_contexts,\n-\t\t\t      vec<ipa_agg_value_set> known_aggs)\n+\t\t\t      ipa_call_arg_values *avals)\n {\n   class ipa_fn_summary *sum = ipa_fn_summaries->get (node);\n   bool use_table = true;\n@@ -3267,9 +3234,10 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n     use_table = false;\n   /* If there is an indirect edge that may be optimized, we need\n      to go the slow way.  */\n-  else if ((known_vals.length ()\n-     \t    || known_contexts.length ()\n-\t    || known_aggs.length ()) && hints)\n+  else if (avals && hints\n+\t   && (avals->m_known_vals.length ()\n+\t       || avals->m_known_contexts.length ()\n+\t       || avals->m_known_aggs.length ()))\n     {\n       class ipa_node_params *params_summary = IPA_NODE_REF (node);\n       unsigned int nargs = params_summary\n@@ -3278,13 +3246,13 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n       for (unsigned int i = 0; i < nargs && use_table; i++)\n \t{\n \t  if (ipa_is_param_used_by_indirect_call (params_summary, i)\n-\t      && ((known_vals.length () > i && known_vals[i])\n-\t\t  || (known_aggs.length () > i\n-\t\t      && known_aggs[i].items.length ())))\n+\t      && (avals->safe_sval_at (i)\n+\t\t  || (avals->m_known_aggs.length () > i\n+\t\t      && avals->m_known_aggs[i].items.length ())))\n \t    use_table = false;\n \t  else if (ipa_is_param_used_by_polymorphic_call (params_summary, i)\n-\t\t   && (known_contexts.length () > i\n-\t\t       && !known_contexts[i].useless_p ()))\n+\t\t   && (avals->m_known_contexts.length () > i\n+\t\t       && !avals->m_known_contexts[i].useless_p ()))\n \t    use_table = false;\n \t}\n     }\n@@ -3327,8 +3295,7 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n \t     < ipa_fn_summary::max_size_time_table_size)\n \t{\n \t  estimate_calls_size_and_time_1 (node, &old_size, NULL, &old_time, NULL,\n-\t\t\t\t\t  possible_truths, known_vals,\n-\t\t\t\t\t  known_contexts, known_aggs);\n+\t\t\t\t\t  possible_truths, avals);\n \t  gcc_assert (*size == old_size);\n \t  if (time && (*time - old_time > 1 || *time - old_time < -1)\n \t      && dump_file)\n@@ -3340,31 +3307,22 @@ estimate_calls_size_and_time (struct cgraph_node *node, int *size,\n   /* Slow path by walking all edges.  */\n   else\n     estimate_calls_size_and_time_1 (node, size, min_size, time, hints,\n-\t\t\t\t    possible_truths, known_vals, known_contexts,\n-\t\t\t\t    known_aggs);\n+\t\t\t\t    possible_truths, avals);\n }\n \n-/* Default constructor for ipa call context.\n-   Memory allocation of known_vals, known_contexts\n-   and known_aggs vectors is owned by the caller, but can\n-   be release by ipa_call_context::release.  \n-   \n-   inline_param_summary is owned by the caller.  */\n-ipa_call_context::ipa_call_context (cgraph_node *node,\n-\t\t\t\t    clause_t possible_truths,\n+/* Main constructor for ipa call context.  Memory allocation of ARG_VALUES\n+   is owned by the caller.  INLINE_PARAM_SUMMARY is also owned by the\n+   caller.  */\n+\n+ipa_call_context::ipa_call_context (cgraph_node *node, clause_t possible_truths,\n \t\t\t\t    clause_t nonspec_possible_truths,\n-\t\t\t\t    vec<tree> known_vals,\n-\t\t\t\t    vec<ipa_polymorphic_call_context>\n-\t\t\t\t   \t known_contexts,\n-\t\t\t\t    vec<ipa_agg_value_set> known_aggs,\n \t\t\t\t    vec<inline_param_summary>\n-\t\t\t\t   \t inline_param_summary)\n+\t\t\t\t      inline_param_summary,\n+\t\t\t\t    ipa_auto_call_arg_values *arg_values)\n : m_node (node), m_possible_truths (possible_truths),\n   m_nonspec_possible_truths (nonspec_possible_truths),\n   m_inline_param_summary (inline_param_summary),\n-  m_known_vals (known_vals),\n-  m_known_contexts (known_contexts),\n-  m_known_aggs (known_aggs)\n+  m_avals (arg_values)\n {\n }\n \n@@ -3395,47 +3353,50 @@ ipa_call_context::duplicate_from (const ipa_call_context &ctx)\n \t    break;\n \t  }\n     }\n-  m_known_vals = vNULL;\n-  if (ctx.m_known_vals.exists ())\n+  m_avals.m_known_vals = vNULL;\n+  if (ctx.m_avals.m_known_vals.exists ())\n     {\n-      unsigned int n = MIN (ctx.m_known_vals.length (), nargs);\n+      unsigned int n = MIN (ctx.m_avals.m_known_vals.length (), nargs);\n \n       for (unsigned int i = 0; i < n; i++)\n \tif (ipa_is_param_used_by_indirect_call (params_summary, i)\n-\t    && ctx.m_known_vals[i])\n+\t    && ctx.m_avals.m_known_vals[i])\n \t  {\n-\t    m_known_vals = ctx.m_known_vals.copy ();\n+\t    m_avals.m_known_vals = ctx.m_avals.m_known_vals.copy ();\n \t    break;\n \t  }\n     }\n \n-  m_known_contexts = vNULL;\n-  if (ctx.m_known_contexts.exists ())\n+  m_avals.m_known_contexts = vNULL;\n+  if (ctx.m_avals.m_known_contexts.exists ())\n     {\n-      unsigned int n = MIN (ctx.m_known_contexts.length (), nargs);\n+      unsigned int n = MIN (ctx.m_avals.m_known_contexts.length (), nargs);\n \n       for (unsigned int i = 0; i < n; i++)\n \tif (ipa_is_param_used_by_polymorphic_call (params_summary, i)\n-\t    && !ctx.m_known_contexts[i].useless_p ())\n+\t    && !ctx.m_avals.m_known_contexts[i].useless_p ())\n \t  {\n-\t    m_known_contexts = ctx.m_known_contexts.copy ();\n+\t    m_avals.m_known_contexts = ctx.m_avals.m_known_contexts.copy ();\n \t    break;\n \t  }\n     }\n \n-  m_known_aggs = vNULL;\n-  if (ctx.m_known_aggs.exists ())\n+  m_avals.m_known_aggs = vNULL;\n+  if (ctx.m_avals.m_known_aggs.exists ())\n     {\n-      unsigned int n = MIN (ctx.m_known_aggs.length (), nargs);\n+      unsigned int n = MIN (ctx.m_avals.m_known_aggs.length (), nargs);\n \n       for (unsigned int i = 0; i < n; i++)\n \tif (ipa_is_param_used_by_indirect_call (params_summary, i)\n-\t    && !ctx.m_known_aggs[i].is_empty ())\n+\t    && !ctx.m_avals.m_known_aggs[i].is_empty ())\n \t  {\n-\t    m_known_aggs = ipa_copy_agg_values (ctx.m_known_aggs);\n+\t    m_avals.m_known_aggs\n+\t      = ipa_copy_agg_values (ctx.m_avals.m_known_aggs);\n \t    break;\n \t  }\n     }\n+\n+  m_avals.m_known_value_ranges = vNULL;\n }\n \n /* Release memory used by known_vals/contexts/aggs vectors.\n@@ -3449,11 +3410,11 @@ ipa_call_context::release (bool all)\n   /* See if context is initialized at first place.  */\n   if (!m_node)\n     return;\n-  ipa_release_agg_values (m_known_aggs, all);\n+  ipa_release_agg_values (m_avals.m_known_aggs, all);\n   if (all)\n     {\n-      m_known_vals.release ();\n-      m_known_contexts.release ();\n+      m_avals.m_known_vals.release ();\n+      m_avals.m_known_contexts.release ();\n       m_inline_param_summary.release ();\n     }\n }\n@@ -3499,77 +3460,81 @@ ipa_call_context::equal_to (const ipa_call_context &ctx)\n \t    return false;\n \t}\n     }\n-  if (m_known_vals.exists () || ctx.m_known_vals.exists ())\n+  if (m_avals.m_known_vals.exists () || ctx.m_avals.m_known_vals.exists ())\n     {\n       for (unsigned int i = 0; i < nargs; i++)\n \t{\n \t  if (!ipa_is_param_used_by_indirect_call (params_summary, i))\n \t    continue;\n-\t  if (i >= m_known_vals.length () || !m_known_vals[i])\n+\t  if (i >= m_avals.m_known_vals.length () || !m_avals.m_known_vals[i])\n \t    {\n-\t      if (i < ctx.m_known_vals.length () && ctx.m_known_vals[i])\n+\t      if (i < ctx.m_avals.m_known_vals.length ()\n+\t\t  && ctx.m_avals.m_known_vals[i])\n \t\treturn false;\n \t      continue;\n \t    }\n-\t  if (i >= ctx.m_known_vals.length () || !ctx.m_known_vals[i])\n+\t  if (i >= ctx.m_avals.m_known_vals.length ()\n+\t      || !ctx.m_avals.m_known_vals[i])\n \t    {\n-\t      if (i < m_known_vals.length () && m_known_vals[i])\n+\t      if (i < m_avals.m_known_vals.length () && m_avals.m_known_vals[i])\n \t\treturn false;\n \t      continue;\n \t    }\n-\t  if (m_known_vals[i] != ctx.m_known_vals[i])\n+\t  if (m_avals.m_known_vals[i] != ctx.m_avals.m_known_vals[i])\n \t    return false;\n \t}\n     }\n-  if (m_known_contexts.exists () || ctx.m_known_contexts.exists ())\n+  if (m_avals.m_known_contexts.exists ()\n+      || ctx.m_avals.m_known_contexts.exists ())\n     {\n       for (unsigned int i = 0; i < nargs; i++)\n \t{\n \t  if (!ipa_is_param_used_by_polymorphic_call (params_summary, i))\n \t    continue;\n-\t  if (i >= m_known_contexts.length ()\n-\t      || m_known_contexts[i].useless_p ())\n+\t  if (i >= m_avals.m_known_contexts.length ()\n+\t      || m_avals.m_known_contexts[i].useless_p ())\n \t    {\n-\t      if (i < ctx.m_known_contexts.length ()\n-\t\t  && !ctx.m_known_contexts[i].useless_p ())\n+\t      if (i < ctx.m_avals.m_known_contexts.length ()\n+\t\t  && !ctx.m_avals.m_known_contexts[i].useless_p ())\n \t\treturn false;\n \t      continue;\n \t    }\n-\t  if (i >= ctx.m_known_contexts.length ()\n-\t      || ctx.m_known_contexts[i].useless_p ())\n+\t  if (i >= ctx.m_avals.m_known_contexts.length ()\n+\t      || ctx.m_avals.m_known_contexts[i].useless_p ())\n \t    {\n-\t      if (i < m_known_contexts.length ()\n-\t\t  && !m_known_contexts[i].useless_p ())\n+\t      if (i < m_avals.m_known_contexts.length ()\n+\t\t  && !m_avals.m_known_contexts[i].useless_p ())\n \t\treturn false;\n \t      continue;\n \t    }\n-\t  if (!m_known_contexts[i].equal_to\n-\t     \t (ctx.m_known_contexts[i]))\n+\t  if (!m_avals.m_known_contexts[i].equal_to\n+\t     \t (ctx.m_avals.m_known_contexts[i]))\n \t    return false;\n \t}\n     }\n-  if (m_known_aggs.exists () || ctx.m_known_aggs.exists ())\n+  if (m_avals.m_known_aggs.exists () || ctx.m_avals.m_known_aggs.exists ())\n     {\n       for (unsigned int i = 0; i < nargs; i++)\n \t{\n \t  if (!ipa_is_param_used_by_indirect_call (params_summary, i))\n \t    continue;\n-\t  if (i >= m_known_aggs.length () || m_known_aggs[i].is_empty ())\n+\t  if (i >= m_avals.m_known_aggs.length ()\n+\t      || m_avals.m_known_aggs[i].is_empty ())\n \t    {\n-\t      if (i < ctx.m_known_aggs.length ()\n-\t\t  && !ctx.m_known_aggs[i].is_empty ())\n+\t      if (i < ctx.m_avals.m_known_aggs.length ()\n+\t\t  && !ctx.m_avals.m_known_aggs[i].is_empty ())\n \t\treturn false;\n \t      continue;\n \t    }\n-\t  if (i >= ctx.m_known_aggs.length ()\n-\t      || ctx.m_known_aggs[i].is_empty ())\n+\t  if (i >= ctx.m_avals.m_known_aggs.length ()\n+\t      || ctx.m_avals.m_known_aggs[i].is_empty ())\n \t    {\n-\t      if (i < m_known_aggs.length ()\n-\t\t  && !m_known_aggs[i].is_empty ())\n+\t      if (i < m_avals.m_known_aggs.length ()\n+\t\t  && !m_avals.m_known_aggs[i].is_empty ())\n \t\treturn false;\n \t      continue;\n \t    }\n-\t  if (!m_known_aggs[i].equal_to (ctx.m_known_aggs[i]))\n+\t  if (!m_avals.m_known_aggs[i].equal_to (ctx.m_avals.m_known_aggs[i]))\n \t    return false;\n \t}\n     }\n@@ -3619,7 +3584,7 @@ ipa_call_context::estimate_size_and_time (int *ret_size,\n     estimate_calls_size_and_time (m_node, &size, &min_size,\n \t\t\t\t  ret_time ? &time : NULL,\n \t\t\t\t  ret_hints ? &hints : NULL, m_possible_truths,\n-\t\t\t\t  m_known_vals, m_known_contexts, m_known_aggs);\n+\t\t\t\t  &m_avals);\n \n   sreal nonspecialized_time = time;\n \n@@ -3726,22 +3691,16 @@ ipa_call_context::estimate_size_and_time (int *ret_size,\n \n void\n estimate_ipcp_clone_size_and_time (struct cgraph_node *node,\n-\t\t\t\t   vec<tree> known_vals,\n-\t\t\t\t   vec<ipa_polymorphic_call_context>\n-\t\t\t\t   known_contexts,\n-\t\t\t\t   vec<ipa_agg_value_set> known_aggs,\n+\t\t\t\t   ipa_auto_call_arg_values *avals,\n \t\t\t\t   int *ret_size, sreal *ret_time,\n \t\t\t\t   sreal *ret_nonspec_time,\n \t\t\t\t   ipa_hints *hints)\n {\n   clause_t clause, nonspec_clause;\n \n-  /* TODO: Also pass known value ranges.  */\n-  evaluate_conditions_for_known_args (node, false, known_vals, vNULL,\n-\t\t\t\t      known_aggs, &clause, &nonspec_clause);\n-  ipa_call_context ctx (node, clause, nonspec_clause,\n-\t\t        known_vals, known_contexts,\n-\t\t        known_aggs, vNULL);\n+  evaluate_conditions_for_known_args (node, false, avals, &clause,\n+\t\t\t\t      &nonspec_clause);\n+  ipa_call_context ctx (node, clause, nonspec_clause, vNULL, avals);\n   ctx.estimate_size_and_time (ret_size, NULL, ret_time,\n \t\t\t      ret_nonspec_time, hints);\n }\n@@ -3970,10 +3929,8 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n \n   if (callee_info->conds)\n     {\n-      auto_vec<tree, 32> known_vals;\n-      auto_vec<ipa_agg_value_set, 32> known_aggs;\n-      evaluate_properties_for_edge (edge, true, &clause, NULL,\n-\t\t\t\t    &known_vals, NULL, &known_aggs);\n+      ipa_auto_call_arg_values avals;\n+      evaluate_properties_for_edge (edge, true, &clause, NULL, &avals, false);\n     }\n   if (ipa_node_params_sum && callee_info->conds)\n     {\n@@ -4067,8 +4024,7 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n       int edge_size = 0;\n       sreal edge_time = 0;\n \n-      estimate_edge_size_and_time (edge, &edge_size, NULL, &edge_time, vNULL,\n-\t\t      \t\t   vNULL, vNULL, 0);\n+      estimate_edge_size_and_time (edge, &edge_size, NULL, &edge_time, NULL, 0);\n       /* Unaccount size and time of the optimized out call.  */\n       info->account_size_time (-edge_size, -edge_time,\n \t \t\t       es->predicate ? *es->predicate : true,\n@@ -4110,7 +4066,7 @@ ipa_update_overall_fn_summary (struct cgraph_node *node, bool reset)\n     estimate_calls_size_and_time (node, &size_info->size, &info->min_size,\n \t\t\t\t  &info->time, NULL,\n \t\t\t\t  ~(clause_t) (1 << predicate::false_condition),\n-\t\t\t\t  vNULL, vNULL, vNULL);\n+\t\t\t\t  NULL);\n   size_info->size = RDIV (size_info->size, ipa_fn_summary::size_scale);\n   info->min_size = RDIV (info->min_size, ipa_fn_summary::size_scale);\n }"}, {"sha": "6893858d18e2e82323a5f264d1e374432bd112c1", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc", "patch": "@@ -297,10 +297,8 @@ class ipa_call_context\n   ipa_call_context (cgraph_node *node,\n       \t\t    clause_t possible_truths,\n \t\t    clause_t nonspec_possible_truths,\n-\t\t    vec<tree> known_vals,\n-\t\t    vec<ipa_polymorphic_call_context> known_contexts,\n-\t\t    vec<ipa_agg_value_set> known_aggs,\n-\t\t    vec<inline_param_summary> m_inline_param_summary);\n+\t\t    vec<inline_param_summary> inline_param_summary,\n+\t\t    ipa_auto_call_arg_values *arg_values);\n   ipa_call_context ()\n   : m_node(NULL)\n   {\n@@ -328,14 +326,9 @@ class ipa_call_context\n   /* Inline summary maintains info about change probabilities.  */\n   vec<inline_param_summary> m_inline_param_summary;\n \n-  /* The following is used only to resolve indirect calls.  */\n-\n-  /* Vector describing known values of parameters.  */\n-  vec<tree> m_known_vals;\n-  /* Vector describing known polymorphic call contexts.  */\n-  vec<ipa_polymorphic_call_context> m_known_contexts;\n-  /* Vector describing known aggregate values.  */\n-  vec<ipa_agg_value_set> m_known_aggs;\n+  /* Even after having calculated clauses, the information about argument\n+     values is used to resolve indirect calls.  */\n+  ipa_call_arg_values m_avals;\n };\n \n extern fast_call_summary <ipa_call_summary *, va_heap> *ipa_call_summaries;\n@@ -349,9 +342,7 @@ void ipa_free_fn_summary (void);\n void ipa_free_size_summary (void);\n void inline_analyze_function (struct cgraph_node *node);\n void estimate_ipcp_clone_size_and_time (struct cgraph_node *,\n-\t\t\t\t\tvec<tree>,\n-\t\t\t\t\tvec<ipa_polymorphic_call_context>,\n-\t\t\t\t\tvec<ipa_agg_value_set>,\n+\t\t\t\t\tipa_auto_call_arg_values *,\n \t\t\t\t\tint *, sreal *, sreal *,\n \t\t\t\t        ipa_hints *);\n void ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge);\n@@ -365,10 +356,8 @@ void evaluate_properties_for_edge (struct cgraph_edge *e,\n \t       \t\t           bool inline_p,\n \t\t\t\t   clause_t *clause_ptr,\n \t\t\t\t   clause_t *nonspec_clause_ptr,\n-\t\t\t\t   vec<tree> *known_vals_ptr,\n-\t\t\t\t   vec<ipa_polymorphic_call_context>\n-\t\t\t\t   *known_contexts_ptr,\n-\t\t\t\t   vec<ipa_agg_value_set> *);\n+\t\t\t\t   ipa_auto_call_arg_values *avals,\n+\t\t\t\t   bool compute_contexts);\n \n void ipa_fnsummary_c_finalize (void);\n HOST_WIDE_INT ipa_get_stack_frame_offset (struct cgraph_node *node);"}, {"sha": "d2ae8196d09cda19ece1034e48ba5fa44a6167a2", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 12, "deletions": 29, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc", "patch": "@@ -184,20 +184,16 @@ do_estimate_edge_time (struct cgraph_edge *edge, sreal *ret_nonspec_time)\n   ipa_hints hints;\n   struct cgraph_node *callee;\n   clause_t clause, nonspec_clause;\n-  auto_vec<tree, 32> known_vals;\n-  auto_vec<ipa_polymorphic_call_context, 32> known_contexts;\n-  auto_vec<ipa_agg_value_set, 32> known_aggs;\n+  ipa_auto_call_arg_values avals;\n   class ipa_call_summary *es = ipa_call_summaries->get (edge);\n   int min_size = -1;\n \n   callee = edge->callee->ultimate_alias_target ();\n \n   gcc_checking_assert (edge->inline_failed);\n-  evaluate_properties_for_edge (edge, true,\n-\t\t\t\t&clause, &nonspec_clause, &known_vals,\n-\t\t\t\t&known_contexts, &known_aggs);\n-  ipa_call_context ctx (callee, clause, nonspec_clause, known_vals,\n-\t\t  \tknown_contexts, known_aggs, es->param);\n+  evaluate_properties_for_edge (edge, true, &clause, &nonspec_clause,\n+\t\t\t\t&avals, true);\n+  ipa_call_context ctx (callee, clause, nonspec_clause, es->param, &avals);\n   if (node_context_cache != NULL)\n     {\n       node_context_summary *e = node_context_cache->get_create (callee);\n@@ -255,7 +251,6 @@ do_estimate_edge_time (struct cgraph_edge *edge, sreal *ret_nonspec_time)\n \t     : edge->caller->count.ipa ())))\n     hints |= INLINE_HINT_known_hot;\n \n-  ctx.release ();\n   gcc_checking_assert (size >= 0);\n   gcc_checking_assert (time >= 0);\n \n@@ -307,9 +302,6 @@ do_estimate_edge_size (struct cgraph_edge *edge)\n   int size;\n   struct cgraph_node *callee;\n   clause_t clause, nonspec_clause;\n-  auto_vec<tree, 32> known_vals;\n-  auto_vec<ipa_polymorphic_call_context, 32> known_contexts;\n-  auto_vec<ipa_agg_value_set, 32> known_aggs;\n \n   /* When we do caching, use do_estimate_edge_time to populate the entry.  */\n \n@@ -325,14 +317,11 @@ do_estimate_edge_size (struct cgraph_edge *edge)\n \n   /* Early inliner runs without caching, go ahead and do the dirty work.  */\n   gcc_checking_assert (edge->inline_failed);\n-  evaluate_properties_for_edge (edge, true,\n-\t\t\t\t&clause, &nonspec_clause,\n-\t\t\t\t&known_vals, &known_contexts,\n-\t\t\t\t&known_aggs);\n-  ipa_call_context ctx (callee, clause, nonspec_clause, known_vals,\n-\t\t  \tknown_contexts, known_aggs, vNULL);\n+  ipa_auto_call_arg_values avals;\n+  evaluate_properties_for_edge (edge, true, &clause, &nonspec_clause,\n+\t\t\t\t&avals, true);\n+  ipa_call_context ctx (callee, clause, nonspec_clause, vNULL, &avals);\n   ctx.estimate_size_and_time (&size, NULL, NULL, NULL, NULL);\n-  ctx.release ();\n   return size;\n }\n \n@@ -346,9 +335,6 @@ do_estimate_edge_hints (struct cgraph_edge *edge)\n   ipa_hints hints;\n   struct cgraph_node *callee;\n   clause_t clause, nonspec_clause;\n-  auto_vec<tree, 32> known_vals;\n-  auto_vec<ipa_polymorphic_call_context, 32> known_contexts;\n-  auto_vec<ipa_agg_value_set, 32> known_aggs;\n \n   /* When we do caching, use do_estimate_edge_time to populate the entry.  */\n \n@@ -364,14 +350,11 @@ do_estimate_edge_hints (struct cgraph_edge *edge)\n \n   /* Early inliner runs without caching, go ahead and do the dirty work.  */\n   gcc_checking_assert (edge->inline_failed);\n-  evaluate_properties_for_edge (edge, true,\n-\t\t\t\t&clause, &nonspec_clause,\n-\t\t\t\t&known_vals, &known_contexts,\n-\t\t\t\t&known_aggs);\n-  ipa_call_context ctx (callee, clause, nonspec_clause, known_vals,\n-\t\t  \tknown_contexts, known_aggs, vNULL);\n+  ipa_auto_call_arg_values avals;\n+  evaluate_properties_for_edge (edge, true, &clause, &nonspec_clause,\n+\t\t\t\t&avals, true);\n+  ipa_call_context ctx (callee, clause, nonspec_clause, vNULL, &avals);\n   ctx.estimate_size_and_time (NULL, NULL, NULL, NULL, &hints);\n-  ctx.release ();\n   hints |= simple_edge_hints (edge);\n   return hints;\n }"}, {"sha": "dec6c739a63c513dbf2025164b76b80d129abdae", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc", "patch": "@@ -5797,4 +5797,14 @@ ipa_agg_value::equal_to (const ipa_agg_value &other)\n   return offset == other.offset\n \t && operand_equal_p (value, other.value, 0);\n }\n+\n+/* Destructor also removing individual aggregate values.  */\n+\n+ipa_auto_call_arg_values::~ipa_auto_call_arg_values ()\n+{\n+  ipa_release_agg_values (m_known_aggs, false);\n+}\n+\n+\n+\n #include \"gt-ipa-prop.h\""}, {"sha": "8b2edf6300c106d16354bb155dfa63d8b6287397", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 107, "deletions": 5, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=9d5af1db2d1e7ca4f47f16fc885e1d70fa0229fc", "patch": "@@ -433,6 +433,107 @@ ipa_get_jf_ancestor_type_preserved (struct ipa_jump_func *jfunc)\n   return jfunc->value.ancestor.agg_preserved;\n }\n \n+/* Class for allocating a bundle of various potentially known properties about\n+   actual arguments of a particular call on stack for the usual case and on\n+   heap only if there are unusually many arguments.  The data is deallocated\n+   when the instance of this class goes out of scope or is otherwise\n+   destructed.  */\n+\n+class ipa_auto_call_arg_values\n+{\n+public:\n+  ~ipa_auto_call_arg_values ();\n+\n+  /* If m_known_vals (vector of known \"scalar\" values) is sufficiantly long,\n+     return its element at INDEX, otherwise return NULL.  */\n+  tree safe_sval_at (int index)\n+  {\n+    /* TODO: Assert non-negative index here and test.  */\n+    if ((unsigned) index < m_known_vals.length ())\n+      return m_known_vals[index];\n+    return NULL;\n+  }\n+\n+  /* If m_known_aggs is sufficiantly long, return the pointer rto its element\n+     at INDEX, otherwise return NULL.  */\n+  ipa_agg_value_set *safe_aggval_at (int index)\n+  {\n+    /* TODO: Assert non-negative index here and test.  */\n+    if ((unsigned) index < m_known_aggs.length ())\n+      return &m_known_aggs[index];\n+    return NULL;\n+  }\n+\n+  /* Vector describing known values of parameters.  */\n+  auto_vec<tree, 32> m_known_vals;\n+\n+  /* Vector describing known polymorphic call contexts.  */\n+  auto_vec<ipa_polymorphic_call_context, 32> m_known_contexts;\n+\n+  /* Vector describing known aggregate values.  */\n+  auto_vec<ipa_agg_value_set, 32> m_known_aggs;\n+\n+  /* Vector describing known value ranges of arguments.  */\n+  auto_vec<value_range, 32> m_known_value_ranges;\n+};\n+\n+/* Class bundling the various potentially known properties about actual\n+   arguments of a particular call.  This variant does not deallocate the\n+   bundled data in any way.  */\n+\n+class ipa_call_arg_values\n+{\n+public:\n+  /* Default constructor, setting the vectors to empty ones.  */\n+  ipa_call_arg_values ()\n+  {}\n+\n+  /* Construct this general variant of the bundle from the variant which uses\n+     auto_vecs to hold the vectors.  This means that vectors of objects\n+     constructed with this constructor should not be changed because if they\n+     get reallocated, the member vectors and the underlying auto_vecs would get\n+     out of sync.  */\n+  ipa_call_arg_values (ipa_auto_call_arg_values *aavals)\n+    : m_known_vals (aavals->m_known_vals),\n+      m_known_contexts (aavals->m_known_contexts),\n+      m_known_aggs (aavals->m_known_aggs),\n+      m_known_value_ranges (aavals->m_known_value_ranges)\n+  {}\n+\n+  /* If m_known_vals (vector of known \"scalar\" values) is sufficiantly long,\n+     return its element at INDEX, otherwise return NULL.  */\n+  tree safe_sval_at (int index)\n+  {\n+    /* TODO: Assert non-negative index here and test.  */\n+    if ((unsigned) index < m_known_vals.length ())\n+      return m_known_vals[index];\n+    return NULL;\n+  }\n+\n+  /* If m_known_aggs is sufficiantly long, return the pointer rto its element\n+     at INDEX, otherwise return NULL.  */\n+  ipa_agg_value_set *safe_aggval_at (int index)\n+  {\n+    /* TODO: Assert non-negative index here and test.  */\n+    if ((unsigned) index < m_known_aggs.length ())\n+      return &m_known_aggs[index];\n+    return NULL;\n+  }\n+\n+  /* Vector describing known values of parameters.  */\n+  vec<tree> m_known_vals = vNULL;\n+\n+  /* Vector describing known polymorphic call contexts.  */\n+  vec<ipa_polymorphic_call_context> m_known_contexts = vNULL;\n+\n+  /* Vector describing known aggregate values.  */\n+  vec<ipa_agg_value_set> m_known_aggs = vNULL;\n+\n+  /* Vector describing known value ranges of arguments.  */\n+  vec<value_range> m_known_value_ranges = vNULL;\n+};\n+\n+\n /* Summary describing a single formal parameter.  */\n \n struct GTY(()) ipa_param_descriptor\n@@ -970,12 +1071,13 @@ void ipa_initialize_node_params (struct cgraph_node *node);\n bool ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,\n \t\t\t\t\tvec<cgraph_edge *> *new_edges);\n \n-/* Indirect edge and binfo processing.  */\n+/* Indirect edge processing and target discovery.  */\n+tree ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n+\t\t\t\t   ipa_call_arg_values *avals,\n+\t\t\t\t   bool *speculative);\n tree ipa_get_indirect_edge_target (struct cgraph_edge *ie,\n-\t\t\t\t   vec<tree>,\n-\t\t\t\t   vec<ipa_polymorphic_call_context>,\n-\t\t\t\t   vec<ipa_agg_value_set>,\n-\t\t\t\t   bool *);\n+\t\t\t\t   ipa_auto_call_arg_values *avals,\n+\t\t\t\t   bool *speculative);\n struct cgraph_edge *ipa_make_edge_direct_to_target (struct cgraph_edge *, tree,\n \t\t\t\t\t\t    bool speculative = false);\n tree ipa_impossible_devirt_target (struct cgraph_edge *, tree);"}]}