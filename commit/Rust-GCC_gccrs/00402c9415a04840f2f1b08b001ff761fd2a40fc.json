{"sha": "00402c9415a04840f2f1b08b001ff761fd2a40fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA0MDJjOTQxNWEwNDg0MGYyZjFiMDhiMDAxZmY3NjFmZDJhNDBmYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2015-11-09T09:20:21Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2015-11-09T09:20:21Z"}, "message": "i386: Add address spaces for fs/gs segments and tls\n\n        * config/i386/i386-c.c (ix86_target_macros): Define __SEG_FS,\n        __SEG_GS, __SEG_TLS.\n        (ix86_register_pragmas): Register address spaces __seg_fs,\n        __seg_gs, __seg_tls.\n        * config/i386/i386-protos.h (enum ix86_address_seg): Remove.\n        (ADDR_SPACE_SEG_FS, ADDR_SPACE_SEG_GS, ADDR_SPACE_SEG_TLS): New.\n        (struct ix86_address): Use addr_space_t instead of ix86_address_seg.\n        * config/i386/i386.c (ix86_decompose_address): Likewise.\n        (ix86_legitimate_address_p): Likewise.\n        (memory_address_length): Likewise.  Check mem address space too.\n        (ix86_print_operand): Use ix86_print_operand_address_as.\n        (ix86_print_operand_address_as): Rename from\n        ix86_print_operand_address, add new addr_space_t parameter.\n        Validate that either the parameter or the ix86_address segment\n        is default address space.  Handle ADDR_SPACE_SEG_TLS.\n        (ix86_print_operand_address): New.\n        (ix86_addr_space_subset_p, TARGET_ADDR_SPACE_SUBSET_P): New.\n        (ix86_addr_space_convert, TARGET_ADDR_SPACE_CONVERT): New.\n        (ix86_addr_space_debug, TARGET_ADDR_SPACE_DEBUG): New.\n        (ix86_addr_space_zero_address_valid): New.\n        (TARGET_ADDR_SPACE_ZERO_ADDRESS_VALID): New.\n        * config/i386/i386.h (DEFAULT_TLS_SEG_REG): Use addr_space_t constants.\n        * config/i386/rdos.h (DEFAULT_TLS_SEG_REG): Likewise.\n        * config/i386/predicates.md (address_no_seg_operand): Likewise.\n        (vsib_address_operand): Likewise.\n        (address_mpx_no_base_operand): Likewise.\n        (address_mpx_no_index_operand): Likewise.\n        * doc/extend.texi (x86 Named Address Spaces): New section.\n\n        * gcc.target/i386/addr-space-1.c: New test.\n        * gcc.target/i386/addr-space-2.c: New test.\n        * gcc.target/i386/addr-space-3.c: New test.\n\nFrom-SVN: r230003", "tree": {"sha": "c3e9b3591e6708bd300d869bbfb7bda737b90b37", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3e9b3591e6708bd300d869bbfb7bda737b90b37"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00402c9415a04840f2f1b08b001ff761fd2a40fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00402c9415a04840f2f1b08b001ff761fd2a40fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00402c9415a04840f2f1b08b001ff761fd2a40fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00402c9415a04840f2f1b08b001ff761fd2a40fc/comments", "author": null, "committer": null, "parents": [{"sha": "16734677674ae7f58f4339fa97a91411a347e5db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16734677674ae7f58f4339fa97a91411a347e5db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16734677674ae7f58f4339fa97a91411a347e5db"}], "stats": {"total": 388, "additions": 307, "deletions": 81}, "files": [{"sha": "d0b119f0c5b3c4dbd9ee510635d87835cff74131", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00402c9415a04840f2f1b08b001ff761fd2a40fc", "patch": "@@ -1,5 +1,34 @@\n 2015-11-09  Richard Henderson  <rth@redhat.com>\n \n+\t* config/i386/i386-c.c (ix86_target_macros): Define __SEG_FS,\n+\t__SEG_GS, __SEG_TLS.\n+\t(ix86_register_pragmas): Register address spaces __seg_fs,\n+\t__seg_gs, __seg_tls.\n+\t* config/i386/i386-protos.h (enum ix86_address_seg): Remove.\n+\t(ADDR_SPACE_SEG_FS, ADDR_SPACE_SEG_GS, ADDR_SPACE_SEG_TLS): New.\n+\t(struct ix86_address): Use addr_space_t instead of ix86_address_seg.\n+\t* config/i386/i386.c (ix86_decompose_address): Likewise.\n+\t(ix86_legitimate_address_p): Likewise.\n+\t(memory_address_length): Likewise.  Check mem address space too.\n+\t(ix86_print_operand): Use ix86_print_operand_address_as.\n+\t(ix86_print_operand_address_as): Rename from\n+\tix86_print_operand_address, add new addr_space_t parameter.\n+\tValidate that either the parameter or the ix86_address segment\n+\tis default address space.  Handle ADDR_SPACE_SEG_TLS.\n+\t(ix86_print_operand_address): New.\n+\t(ix86_addr_space_subset_p, TARGET_ADDR_SPACE_SUBSET_P): New.\n+\t(ix86_addr_space_convert, TARGET_ADDR_SPACE_CONVERT): New.\n+\t(ix86_addr_space_debug, TARGET_ADDR_SPACE_DEBUG): New.\n+\t(ix86_addr_space_zero_address_valid): New.\n+\t(TARGET_ADDR_SPACE_ZERO_ADDRESS_VALID): New.\n+\t* config/i386/i386.h (DEFAULT_TLS_SEG_REG): Use addr_space_t constants.\n+\t* config/i386/rdos.h (DEFAULT_TLS_SEG_REG): Likewise.\n+\t* config/i386/predicates.md (address_no_seg_operand): Likewise.\n+\t(vsib_address_operand): Likewise.\n+\t(address_mpx_no_base_operand): Likewise.\n+\t(address_mpx_no_index_operand): Likewise.\n+\t* doc/extend.texi (x86 Named Address Spaces): New section.\n+\n \t* config/i386/i386.c (ix86_check_no_addr_space): New.\n \t(decide_alg): Add have_as parameter.\n \t(alg_usable_p): Likewise; disable rep algorithms if set."}, {"sha": "e3a301205e612cb7a4807f9196b32750c6550c62", "filename": "gcc/config/i386/i386-c.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Fconfig%2Fi386%2Fi386-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Fconfig%2Fi386%2Fi386-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-c.c?ref=00402c9415a04840f2f1b08b001ff761fd2a40fc", "patch": "@@ -586,6 +586,10 @@ ix86_target_macros (void)\n \t\t\t       ix86_tune,\n \t\t\t       ix86_fpmath,\n \t\t\t       cpp_define);\n+\n+  cpp_define (parse_in, \"__SEG_FS\");\n+  cpp_define (parse_in, \"__SEG_GS\");\n+  cpp_define (parse_in, \"__SEG_TLS\");\n }\n \n \f\n@@ -600,6 +604,10 @@ ix86_register_pragmas (void)\n   /* Update pragma hook to allow parsing #pragma GCC target.  */\n   targetm.target_option.pragma_parse = ix86_pragma_target_parse;\n \n+  c_register_addr_space (\"__seg_fs\", ADDR_SPACE_SEG_FS);\n+  c_register_addr_space (\"__seg_gs\", ADDR_SPACE_SEG_GS);\n+  c_register_addr_space (\"__seg_tls\", ADDR_SPACE_SEG_TLS);\n+\n #ifdef REGISTER_SUBTARGET_PRAGMAS\n   REGISTER_SUBTARGET_PRAGMAS ();\n #endif"}, {"sha": "026b778f4e398e45c6d1f7cf60ecf94fcd4824c6", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=00402c9415a04840f2f1b08b001ff761fd2a40fc", "patch": "@@ -279,12 +279,11 @@ extern rtx maybe_get_pool_constant (rtx);\n extern char internal_label_prefix[16];\n extern int internal_label_prefix_len;\n \n-enum ix86_address_seg { SEG_DEFAULT, SEG_FS, SEG_GS };\n struct ix86_address\n {\n   rtx base, index, disp;\n   HOST_WIDE_INT scale;\n-  enum ix86_address_seg seg;\n+  addr_space_t seg;\n };\n \n extern int ix86_decompose_address (rtx, struct ix86_address *);\n@@ -326,3 +325,7 @@ struct ix86_first_cycle_multipass_data_\n # define TARGET_SCHED_FIRST_CYCLE_MULTIPASS_DATA_T\t\\\n   struct ix86_first_cycle_multipass_data_\n #endif /* RTX_CODE */\n+\n+const addr_space_t ADDR_SPACE_SEG_FS = 1;\n+const addr_space_t ADDR_SPACE_SEG_GS = 2;\n+const addr_space_t ADDR_SPACE_SEG_TLS = 3;"}, {"sha": "0d84cde9cbe97431d73a42faacdd6aacfda5da96", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 175, "deletions": 71, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=00402c9415a04840f2f1b08b001ff761fd2a40fc", "patch": "@@ -80,6 +80,7 @@ along with GCC; see the file COPYING3.  If not see\n static rtx legitimize_dllimport_symbol (rtx, bool);\n static rtx legitimize_pe_coff_extern_decl (rtx, bool);\n static rtx legitimize_pe_coff_symbol (rtx, bool);\n+static void ix86_print_operand_address_as (FILE *file, rtx addr, addr_space_t);\n \n #ifndef CHECK_STACK_LIMIT\n #define CHECK_STACK_LIMIT (-1)\n@@ -13988,7 +13989,7 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n   rtx scale_rtx = NULL_RTX;\n   rtx tmp;\n   int retval = 1;\n-  enum ix86_address_seg seg = SEG_DEFAULT;\n+  addr_space_t seg = ADDR_SPACE_GENERIC;\n \n   /* Allow zero-extended SImode addresses,\n      they will be emitted with addr32 prefix.  */\n@@ -14087,7 +14088,7 @@ ix86_decompose_address (rtx addr, struct ix86_address *out)\n \t    case UNSPEC:\n \t      if (XINT (op, 1) == UNSPEC_TP\n \t          && TARGET_TLS_DIRECT_SEG_REFS\n-\t          && seg == SEG_DEFAULT)\n+\t          && seg == ADDR_SPACE_GENERIC)\n \t\tseg = DEFAULT_TLS_SEG_REG;\n \t      else\n \t\treturn 0;\n@@ -14675,7 +14676,7 @@ ix86_legitimate_address_p (machine_mode, rtx addr, bool strict)\n   struct ix86_address parts;\n   rtx base, index, disp;\n   HOST_WIDE_INT scale;\n-  enum ix86_address_seg seg;\n+  addr_space_t seg;\n \n   if (ix86_decompose_address (addr, &parts) <= 0)\n     /* Decomposition failed.  */\n@@ -14721,7 +14722,7 @@ ix86_legitimate_address_p (machine_mode, rtx addr, bool strict)\n     return false;\n \n   /* Address override works only on the (%reg) part of %fs:(%reg).  */\n-  if (seg != SEG_DEFAULT\n+  if (seg != ADDR_SPACE_GENERIC\n       && ((base && GET_MODE (base) != word_mode)\n \t  || (index && GET_MODE (index) != word_mode)))\n     return false;\n@@ -17128,32 +17129,22 @@ ix86_print_operand (FILE *file, rtx x, int code)\n \n   else if (MEM_P (x))\n     {\n-      /* No `byte ptr' prefix for call instructions or BLKmode operands.  */\n-      if (ASSEMBLER_DIALECT == ASM_INTEL && code != 'X' && code != 'P'\n-\t  && GET_MODE (x) != BLKmode)\n+      rtx addr = XEXP (x, 0);\n+\n+      /* Avoid (%rip) for call operands.  */\n+      if (code == 'P' && CONSTANT_ADDRESS_P (x) && !CONST_INT_P (x))\n \t{\n-\t  const char * size;\n-\t  switch (GET_MODE_SIZE (GET_MODE (x)))\n-\t    {\n-\t    case 1: size = \"BYTE\"; break;\n-\t    case 2: size = \"WORD\"; break;\n-\t    case 4: size = \"DWORD\"; break;\n-\t    case 8: size = \"QWORD\"; break;\n-\t    case 12: size = \"TBYTE\"; break;\n-\t    case 16:\n-\t      if (GET_MODE (x) == XFmode)\n-\t\tsize = \"TBYTE\";\n-              else\n-\t\tsize = \"XMMWORD\";\n-              break;\n-\t    case 32: size = \"YMMWORD\"; break;\n-\t    case 64: size = \"ZMMWORD\"; break;\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n+\t  output_addr_const (file, addr);\n+\t  return;\n+\t}\n \n-\t  /* Check for explicit size override (codes 'b', 'w', 'k',\n-\t     'q' and 'x')  */\n+      /* No `byte ptr' prefix for call instructions ... */\n+      if (ASSEMBLER_DIALECT == ASM_INTEL && code != 'X' && code != 'P')\n+\t{\n+\t  machine_mode mode = GET_MODE (x);\n+\t  const char *size;\n+\n+\t  /* Check for explicit size override codes.  */\n \t  if (code == 'b')\n \t    size = \"BYTE\";\n \t  else if (code == 'w')\n@@ -17164,20 +17155,39 @@ ix86_print_operand (FILE *file, rtx x, int code)\n \t    size = \"QWORD\";\n \t  else if (code == 'x')\n \t    size = \"XMMWORD\";\n-\n-\t  fputs (size, file);\n-\t  fputs (\" PTR \", file);\n+\t  else if (mode == BLKmode)\n+\t    /* ... or BLKmode operands, when not overridden.  */\n+\t    size = NULL;\n+\t  else\n+\t    switch (GET_MODE_SIZE (mode))\n+\t      {\n+\t      case 1: size = \"BYTE\"; break;\n+\t      case 2: size = \"WORD\"; break;\n+\t      case 4: size = \"DWORD\"; break;\n+\t      case 8: size = \"QWORD\"; break;\n+\t      case 12: size = \"TBYTE\"; break;\n+\t      case 16:\n+\t\tif (mode == XFmode)\n+\t\t  size = \"TBYTE\";\n+\t\telse\n+\t\t  size = \"XMMWORD\";\n+\t\tbreak;\n+\t      case 32: size = \"YMMWORD\"; break;\n+\t      case 64: size = \"ZMMWORD\"; break;\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n+\t  if (size)\n+\t    {\n+\t      fputs (size, file);\n+\t      fputs (\" PTR \", file);\n+\t    }\n \t}\n \n-      x = XEXP (x, 0);\n-      /* Avoid (%rip) for call operands.  */\n-      if (CONSTANT_ADDRESS_P (x) && code == 'P'\n-\t  && !CONST_INT_P (x))\n-\toutput_addr_const (file, x);\n-      else if (this_is_asm_operands && ! address_operand (x, VOIDmode))\n+      if (this_is_asm_operands && ! address_operand (addr, VOIDmode))\n \toutput_operand_lossage (\"invalid constraints for operand\");\n       else\n-\toutput_address (x);\n+\tix86_print_operand_address_as (file, addr, MEM_ADDR_SPACE (x));\n     }\n \n   else if (CONST_DOUBLE_P (x) && GET_MODE (x) == SFmode)\n@@ -17262,7 +17272,7 @@ ix86_print_operand_punct_valid_p (unsigned char code)\n /* Print a memory operand whose address is ADDR.  */\n \n static void\n-ix86_print_operand_address (FILE *file, rtx addr)\n+ix86_print_operand_address_as (FILE *file, rtx addr, addr_space_t as)\n {\n   struct ix86_address parts;\n   rtx base, index, disp;\n@@ -17315,18 +17325,24 @@ ix86_print_operand_address (FILE *file, rtx addr)\n   disp = parts.disp;\n   scale = parts.scale;\n \n-  switch (parts.seg)\n+  if (ADDR_SPACE_GENERIC_P (as))\n+    as = parts.seg;\n+  else\n+    gcc_assert (ADDR_SPACE_GENERIC_P (parts.seg));\n+\n+  if (!ADDR_SPACE_GENERIC_P (as))\n     {\n-    case SEG_DEFAULT:\n-      break;\n-    case SEG_FS:\n-    case SEG_GS:\n-      if (ASSEMBLER_DIALECT == ASM_ATT)\n-\tputc ('%', file);\n-      fputs ((parts.seg == SEG_FS ? \"fs:\" : \"gs:\"), file);\n-      break;\n-    default:\n-      gcc_unreachable ();\n+      const char *string;\n+\n+      if (as == ADDR_SPACE_SEG_TLS)\n+\tas = DEFAULT_TLS_SEG_REG;\n+      if (as == ADDR_SPACE_SEG_FS)\n+\tstring = (ASSEMBLER_DIALECT == ASM_ATT ? \"%fs:\" : \"fs:\");\n+      else if (as == ADDR_SPACE_SEG_GS)\n+\tstring = (ASSEMBLER_DIALECT == ASM_ATT ? \"%gs:\" : \"gs:\");\n+      else\n+\tgcc_unreachable ();\n+      fputs (string, file);\n     }\n \n   /* Use one byte shorter RIP relative addressing for 64bit mode.  */\n@@ -17350,7 +17366,7 @@ ix86_print_operand_address (FILE *file, rtx addr)\n \n       if (CONST_INT_P (disp))\n \t{\n-\t  if (ASSEMBLER_DIALECT == ASM_INTEL && parts.seg == SEG_DEFAULT)\n+\t  if (ASSEMBLER_DIALECT == ASM_INTEL && parts.seg == ADDR_SPACE_GENERIC)\n \t    fputs (\"ds:\", file);\n \t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (disp));\n \t}\n@@ -17486,6 +17502,12 @@ ix86_print_operand_address (FILE *file, rtx addr)\n     }\n }\n \n+static void\n+ix86_print_operand_address (FILE *file, rtx addr)\n+{\n+  ix86_print_operand_address_as (file, addr, ADDR_SPACE_GENERIC);\n+}\n+\n /* Implementation of TARGET_ASM_OUTPUT_ADDR_CONST_EXTRA.  */\n \n static bool\n@@ -27136,7 +27158,7 @@ memory_address_length (rtx addr, bool lea)\n   ok = ix86_decompose_address (addr, &parts);\n   gcc_assert (ok);\n \n-  len = (parts.seg == SEG_DEFAULT) ? 0 : 1;\n+  len = (parts.seg == ADDR_SPACE_GENERIC) ? 0 : 1;\n \n   /*  If this is not LEA instruction, add the length of addr32 prefix.  */\n   if (TARGET_64BIT && !lea\n@@ -27297,25 +27319,35 @@ ix86_attr_length_address_default (rtx_insn *insn)\n \n   extract_insn_cached (insn);\n   for (i = recog_data.n_operands - 1; i >= 0; --i)\n-    if (MEM_P (recog_data.operand[i]))\n-      {\n-        constrain_operands_cached (insn, reload_completed);\n-        if (which_alternative != -1)\n-\t  {\n-\t    const char *constraints = recog_data.constraints[i];\n-\t    int alt = which_alternative;\n-\n-\t    while (*constraints == '=' || *constraints == '+')\n-\t      constraints++;\n-\t    while (alt-- > 0)\n-\t      while (*constraints++ != ',')\n-\t\t;\n-\t    /* Skip ignored operands.  */\n-\t    if (*constraints == 'X')\n-\t      continue;\n-\t  }\n-\treturn memory_address_length (XEXP (recog_data.operand[i], 0), false);\n-      }\n+    {\n+      rtx op = recog_data.operand[i];\n+      if (MEM_P (op))\n+\t{\n+\t  constrain_operands_cached (insn, reload_completed);\n+\t  if (which_alternative != -1)\n+\t    {\n+\t      const char *constraints = recog_data.constraints[i];\n+\t      int alt = which_alternative;\n+\n+\t      while (*constraints == '=' || *constraints == '+')\n+\t\tconstraints++;\n+\t      while (alt-- > 0)\n+\t        while (*constraints++ != ',')\n+\t\t  ;\n+\t      /* Skip ignored operands.  */\n+\t      if (*constraints == 'X')\n+\t\tcontinue;\n+\t    }\n+\n+\t  int len = memory_address_length (XEXP (op, 0), false);\n+\n+\t  /* Account for segment prefix for non-default addr spaces.  */\n+\t  if (!ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (op)))\n+\t    len++;\n+\n+\t  return len;\n+\t}\n+    }\n   return 0;\n }\n \n@@ -53669,6 +53701,78 @@ ix86_operands_ok_for_move_multiple (rtx *operands, bool load,\n   return true;\n }\n \n+/* Address space support.\n+\n+   This is not \"far pointers\" in the 16-bit sense, but an easy way\n+   to use %fs and %gs segment prefixes.  Therefore:\n+\n+    (a) All address spaces have the same modes,\n+    (b) All address spaces have the same addresss forms,\n+    (c) While %fs and %gs are technically subsets of the generic\n+        address space, they are probably not subsets of each other.\n+    (d) Since we have no access to the segment base register values\n+        without resorting to a system call, we cannot convert a\n+        non-default address space to a default address space.\n+        Therefore we do not claim %fs or %gs are subsets of generic.\n+    (e) However, __seg_tls uses UNSPEC_TP as the base (which itself is\n+\tstored at __seg_tls:0) so we can map between tls and generic.  */\n+\n+static bool\n+ix86_addr_space_subset_p (addr_space_t subset, addr_space_t superset)\n+{\n+    return (subset == superset\n+\t    || (superset == ADDR_SPACE_GENERIC\n+\t\t&& subset == ADDR_SPACE_SEG_TLS));\n+}\n+#undef TARGET_ADDR_SPACE_SUBSET_P\n+#define TARGET_ADDR_SPACE_SUBSET_P ix86_addr_space_subset_p\n+\n+static rtx\n+ix86_addr_space_convert (rtx op, tree from_type, tree to_type)\n+{\n+  addr_space_t from_as = TYPE_ADDR_SPACE (TREE_TYPE (from_type));\n+  addr_space_t to_as = TYPE_ADDR_SPACE (TREE_TYPE (to_type));\n+\n+  /* Conversion between SEG_TLS and GENERIC is handled by adding or\n+     subtracting the thread pointer.  */\n+  if ((from_as == ADDR_SPACE_GENERIC && to_as == ADDR_SPACE_SEG_TLS)\n+      || (from_as == ADDR_SPACE_SEG_TLS && to_as == ADDR_SPACE_GENERIC))\n+    {\n+      machine_mode mode = GET_MODE (op);\n+      if (mode == VOIDmode)\n+\tmode = ptr_mode;\n+      rtx tp = get_thread_pointer (mode, optimize || mode != ptr_mode);\n+      return expand_binop (mode, (to_as == ADDR_SPACE_GENERIC\n+\t\t\t\t  ? add_optab : sub_optab),\n+\t\t\t   op, tp, NULL, 1, OPTAB_WIDEN);\n+    }\n+\n+  return op;\n+}\n+#undef TARGET_ADDR_SPACE_CONVERT\n+#define TARGET_ADDR_SPACE_CONVERT ix86_addr_space_convert\n+\n+static int\n+ix86_addr_space_debug (addr_space_t as)\n+{\n+  /* Fold __seg_tls to __seg_fs or __seg_gs for debugging.  */\n+  if (as == ADDR_SPACE_SEG_TLS)\n+    as = DEFAULT_TLS_SEG_REG;\n+  return as;\n+}\n+#undef TARGET_ADDR_SPACE_DEBUG\n+#define TARGET_ADDR_SPACE_DEBUG ix86_addr_space_debug\n+\n+/* All use of segmentation is assumed to make address 0 valid.  */\n+\n+static bool\n+ix86_addr_space_zero_address_valid (addr_space_t as)\n+{\n+  return as != ADDR_SPACE_GENERIC;\n+}\n+#undef TARGET_ADDR_SPACE_ZERO_ADDRESS_VALID\n+#define TARGET_ADDR_SPACE_ZERO_ADDRESS_VALID ix86_addr_space_zero_address_valid\n+\n /* Initialize the GCC target structure.  */\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY ix86_return_in_memory"}, {"sha": "3d5b2b25ced64b558f5f4e82424f079799488250", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=00402c9415a04840f2f1b08b001ff761fd2a40fc", "patch": "@@ -602,7 +602,8 @@ extern tree x86_mfence;\n #define DEFAULT_ABI SYSV_ABI\n \n /* The default TLS segment register used by target.  */\n-#define DEFAULT_TLS_SEG_REG (TARGET_64BIT ? SEG_FS : SEG_GS)\n+#define DEFAULT_TLS_SEG_REG \\\n+  (TARGET_64BIT ? ADDR_SPACE_SEG_FS : ADDR_SPACE_SEG_GS)\n \n /* Subtargets may reset this to 1 in order to enable 96-bit long double\n    with the rounding mode forced to 53 bits.  */"}, {"sha": "c11f2d7d228e0a6b9e743ffa4797084ff452bcd2", "filename": "gcc/config/i386/predicates.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Fconfig%2Fi386%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Fconfig%2Fi386%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fpredicates.md?ref=00402c9415a04840f2f1b08b001ff761fd2a40fc", "patch": "@@ -974,7 +974,7 @@\n \n   ok = ix86_decompose_address (op, &parts);\n   gcc_assert (ok);\n-  return parts.seg == SEG_DEFAULT;\n+  return parts.seg == ADDR_SPACE_GENERIC;\n })\n \n ;; Return true if op if a valid base register, displacement or\n@@ -988,7 +988,7 @@\n \n   ok = ix86_decompose_address (op, &parts);\n   gcc_assert (ok);\n-  if (parts.index || parts.seg != SEG_DEFAULT)\n+  if (parts.index || parts.seg != ADDR_SPACE_GENERIC)\n     return false;\n \n   /* VSIB addressing doesn't support (%rip).  */\n@@ -1032,7 +1032,7 @@\n   if (parts.index && parts.base)\n     return false;\n \n-  if (parts.seg != SEG_DEFAULT)\n+  if (parts.seg != ADDR_SPACE_GENERIC)\n     return false;\n \n   /* Do not support (%rip).  */\n@@ -1064,7 +1064,7 @@\n   if (parts.index)\n     return false;\n \n-  if (parts.seg != SEG_DEFAULT)\n+  if (parts.seg != ADDR_SPACE_GENERIC)\n     return false;\n \n   /* Do not support (%rip).  */"}, {"sha": "ccf6b78824a77518cb4d9d85d816f427affb844a", "filename": "gcc/config/i386/rdos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Fconfig%2Fi386%2Frdos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Fconfig%2Fi386%2Frdos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Frdos.h?ref=00402c9415a04840f2f1b08b001ff761fd2a40fc", "patch": "@@ -25,7 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #define TARGET_TLS_DIRECT_SEG_REFS_DEFAULT MASK_TLS_DIRECT_SEG_REFS\n \n #undef DEFAULT_TLS_SEG_REG\n-#define DEFAULT_TLS_SEG_REG SEG_GS \n+#define DEFAULT_TLS_SEG_REG ADDR_SPACE_SEG_GS\n \n #undef TARGET_RDOS\n #define TARGET_RDOS 1"}, {"sha": "aab6bad905c182966661a3de1c65c0977d01b3a0", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=00402c9415a04840f2f1b08b001ff761fd2a40fc", "patch": "@@ -1261,8 +1261,8 @@ As an extension, GNU C supports named address spaces as\n defined in the N1275 draft of ISO/IEC DTR 18037.  Support for named\n address spaces in GCC will evolve as the draft technical report\n changes.  Calling conventions for any target might also change.  At\n-present, only the AVR, SPU, M32C, and RL78 targets support address\n-spaces other than the generic address space.\n+present, only the AVR, SPU, M32C, RL78, and x86 targets support\n+address spaces other than the generic address space.\n \n Address space identifiers may be used exactly like any other C type\n qualifier (e.g., @code{const} or @code{volatile}).  See the N1275\n@@ -1451,6 +1451,49 @@ It may use runtime library\n support, or generate special machine instructions to access that address\n space.\n \n+@subsection x86 Named Address Spaces\n+@cindex x86 named address spaces\n+\n+On the x86 target, variables may be declared as being relative\n+to the @code{%fs} or @code{%gs} segments.\n+\n+@table @code\n+@item __seg_fs\n+@itemx __seg_gs\n+@cindex @code{__seg_fs} x86 named address space\n+@cindex @code{__seg_gs} x86 named address space\n+The object is accessed with the respective segment override prefix.\n+\n+The respective segment base must be set via some method specific to\n+the operating system.  Rather than require an expensive system call\n+to retrieve the segment base, these address spaces are not considered\n+to be subspaces of the generic (flat) address space.  This means that\n+explicit casts are required to convert pointers between these address\n+spaces and the generic address space.  In practice the application\n+should cast to @code{uintptr_t} and apply the segment base offset\n+that it installed previously.\n+\n+The preprocessor symbols @code{__SEG_FS} and @code{__SEG_GS} are\n+defined when these address spaces are supported.\n+\n+@item __seg_tls\n+@cindex @code{__seg_tls} x86 named address space\n+Some operating systems define either the @code{%fs} or @code{%gs}\n+segment as the thread-local storage base for each thread.  Objects\n+within this address space are accessed with the appropriate\n+segment override prefix.\n+\n+The pointer located at address 0 within the segment contains the\n+offset of the segment within the generic address space.  Thus this\n+address space is considered a subspace of the generic address space,\n+and the known segment offset is applied when converting addresses\n+to and from the generic address space.\n+\n+The preprocessor symbol @code{__SEG_TLS} is defined when this\n+address space is supported.\n+\n+@end table\n+\n @node Zero Length\n @section Arrays of Length Zero\n @cindex arrays of length zero"}, {"sha": "c6fe2972e2db817d8d4d8acb88921741437b766d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=00402c9415a04840f2f1b08b001ff761fd2a40fc", "patch": "@@ -1,3 +1,9 @@\n+2015-11-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc.target/i386/addr-space-1.c: New test.\n+\t* gcc.target/i386/addr-space-2.c: New test.\n+\t* gcc.target/i386/addr-space-3.c: New test.\n+\n 2015-11-08  Steven g. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/68053"}, {"sha": "1e1314760e2064771a21d8137a0c5857aac2112e", "filename": "gcc/testsuite/gcc.target/i386/addr-space-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Faddr-space-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Faddr-space-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Faddr-space-1.c?ref=00402c9415a04840f2f1b08b001ff761fd2a40fc", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler \"movl\\[ \\t\\]%gs:\\\\((%eax|%rax)\\\\), %eax\" } } */\n+\n+extern __seg_gs int *call_me (void);\n+\n+int\n+read_seg_gs (void)\n+{\n+  return *call_me();\n+}"}, {"sha": "d5c24b61096f872f0bbb9957390935f5b15da400", "filename": "gcc/testsuite/gcc.target/i386/addr-space-2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Faddr-space-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Faddr-space-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Faddr-space-2.c?ref=00402c9415a04840f2f1b08b001ff761fd2a40fc", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+/* { dg-final { scan-assembler \"fs:16\" } } */\n+/* { dg-final { scan-assembler \"gs:16\" } } */\n+\n+int test(void)\n+{\n+  int __seg_fs *f = (int __seg_fs *)16;\n+  int __seg_gs *g = (int __seg_gs *)16;\n+  return *f + *g;\n+}"}, {"sha": "63f1f031a08bae60a66b1e28db5983fad8aa4f49", "filename": "gcc/testsuite/gcc.target/i386/addr-space-3.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Faddr-space-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00402c9415a04840f2f1b08b001ff761fd2a40fc/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Faddr-space-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Faddr-space-3.c?ref=00402c9415a04840f2f1b08b001ff761fd2a40fc", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+/* { dg-final { scan-assembler \"[fg]s:0\" } } */\n+\n+void test(int *y)\n+{\n+  int *x = (int __seg_tls *)0;\n+  if (x == y)\n+    asm(\"\");\n+}"}]}