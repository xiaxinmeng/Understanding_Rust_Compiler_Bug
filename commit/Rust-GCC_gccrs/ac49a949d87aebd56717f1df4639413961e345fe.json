{"sha": "ac49a949d87aebd56717f1df4639413961e345fe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM0OWE5NDlkODdhZWJkNTY3MTdmMWRmNDYzOTQxMzk2MWUzNDVmZQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-11-30T23:13:16Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-11-30T23:13:16Z"}, "message": "(subst, make_field_assignment, num_sign_bit_copies): Protect calls to significant_bits...\n\n(subst, make_field_assignment, num_sign_bit_copies): Protect calls to\nsignificant_bits; unless we only care if the result is a power of two,\ndon't call if mode size is wider than HOST_BITS_PER_WIDE_INT.\n(extended_count, simplify_shift_const, simplify_comparison): Likewise.\n\nFrom-SVN: r2824", "tree": {"sha": "2f29dd0b1fd0696f12b1aa55da4e500281a1c2a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f29dd0b1fd0696f12b1aa55da4e500281a1c2a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac49a949d87aebd56717f1df4639413961e345fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac49a949d87aebd56717f1df4639413961e345fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac49a949d87aebd56717f1df4639413961e345fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac49a949d87aebd56717f1df4639413961e345fe/comments", "author": null, "committer": null, "parents": [{"sha": "fc5c2df84b591e28497656e3abfab28da1501933", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc5c2df84b591e28497656e3abfab28da1501933", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc5c2df84b591e28497656e3abfab28da1501933"}], "stats": {"total": 33, "additions": 25, "deletions": 8}, "files": [{"sha": "90a48636e6c2164d45fa56761257b90c6951737f", "filename": "gcc/combine.c", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac49a949d87aebd56717f1df4639413961e345fe/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac49a949d87aebd56717f1df4639413961e345fe/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=ac49a949d87aebd56717f1df4639413961e345fe", "patch": "@@ -3256,8 +3256,9 @@ subst (x, from, to, in_dest, unique_copy)\n \t for example in cases like ((a & 1) + (a & 2)), which can\n \t become a & 3.  */\n \n-      if ((significant_bits (XEXP (x, 0), mode)\n-\t   & significant_bits (XEXP (x, 1), mode)) == 0)\n+      if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+\t  && (significant_bits (XEXP (x, 0), mode)\n+\t      & significant_bits (XEXP (x, 1), mode)) == 0)\n \t{\n \t  x = gen_binary (IOR, mode, XEXP (x, 0), XEXP (x, 1));\n \t  goto restart;\n@@ -4067,6 +4068,7 @@ subst (x, from, to, in_dest, unique_copy)\n     case IOR:\n       /* (ior A C) is C if all significant bits of A are on in C.  */\n       if (GET_CODE (XEXP (x, 1)) == CONST_INT\n+\t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n \t  && (significant_bits (XEXP (x, 0), mode)\n \t      & ~ INTVAL (XEXP (x, 1))) == 0)\n \treturn XEXP (x, 1);\n@@ -5449,7 +5451,8 @@ make_field_assignment (x)\n \n   pos = get_pos_from_mask (~c1, &len);\n   if (pos < 0 || pos + len > GET_MODE_BITSIZE (GET_MODE (dest))\n-      || (c1 & significant_bits (other, GET_MODE (other))) != 0)\n+      || (GET_MODE_BITSIZE (GET_MODE (other)) <= HOST_BITS_PER_WIDE_INT\n+\t  && (c1 & significant_bits (other, GET_MODE (other))) != 0))\n     return x;\n \n   assign = make_extraction (VOIDmode, dest, pos, NULL_RTX, len, 1, 1, 0);\n@@ -6247,7 +6250,8 @@ num_sign_bit_copies (x, mode)\n       /* If the constant is negative, take its 1's complement and remask.\n \t Then see how many zero bits we have.  */\n       sig = INTVAL (x) & GET_MODE_MASK (mode);\n-      if (sig & ((HOST_WIDE_INT) 1 << (bitwidth - 1)))\n+      if (bitwidth <= HOST_BITS_PER_WIDE_INT\n+\t  && (sig & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n \tsig = (~ sig) & GET_MODE_MASK (mode);\n \n       return (sig == 0 ? bitwidth : bitwidth - floor_log2 (sig) - 1);\n@@ -6326,6 +6330,7 @@ num_sign_bit_copies (x, mode)\n \n       num0 = num_sign_bit_copies (XEXP (x, 0), mode);\n       if (num0 > 1\n+\t  && bitwidth <= HOST_BITS_PER_WIDE_INT\n \t  && (((HOST_WIDE_INT) 1 << (bitwidth - 1)) & sig))\n \tnum0--;\n \n@@ -6373,6 +6378,7 @@ num_sign_bit_copies (x, mode)\n \n       result = bitwidth - (bitwidth - num0) - (bitwidth - num1);\n       if (result > 0\n+\t  && bitwidth <= HOST_BITS_PER_INT\n \t  && ((significant_bits (XEXP (x, 0), mode)\n \t       & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n \t  && (significant_bits (XEXP (x, 1), mode)\n@@ -6395,6 +6401,7 @@ num_sign_bit_copies (x, mode)\n \t to add 1.  */\n       result = num_sign_bit_copies (XEXP (x, 0), mode);\n       if (result > 1\n+\t  && bitwidth <= HOST_BITS_PER_WIDE_INT\n \t  && (significant_bits (XEXP (x, 1), mode)\n \t      & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n \tresult --;\n@@ -6404,6 +6411,7 @@ num_sign_bit_copies (x, mode)\n     case MOD:\n       result = num_sign_bit_copies (XEXP (x, 1), mode);\n       if (result > 1\n+\t  && bitwidth <= HOST_BITS_PER_WIDE_INT\n \t  && (significant_bits (XEXP (x, 1), mode)\n \t      & ((HOST_WIDE_INT) 1 << (bitwidth - 1))) != 0)\n \tresult --;\n@@ -6445,7 +6453,11 @@ num_sign_bit_copies (x, mode)\n \n   /* If we haven't been able to figure it out by one of the above rules,\n      see if some of the high-order bits are known to be zero.  If so,\n-     count those bits and return one less than that amount.  */\n+     count those bits and return one less than that amount.  If we can't\n+     safely compute the mask for this mode, always return BITWIDTH.  */\n+\n+  if (bitwidth > HOST_BITS_PER_WIDE_INT)\n+    return bitwidth;\n \n   sig = significant_bits (x, mode);\n   return sig == GET_MODE_MASK (mode) ? 1 : bitwidth - floor_log2 (sig) - 1;\n@@ -6472,8 +6484,9 @@ extended_count (x, mode, unsignedp)\n     return 0;\n \n   return (unsignedp\n-\t  ? (GET_MODE_BITSIZE (mode) - 1\n-\t     - floor_log2 (significant_bits (x, mode)))\n+\t  ? (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n+\t     && (GET_MODE_BITSIZE (mode) - 1\n+\t\t - floor_log2 (significant_bits (x, mode))))\n \t  : num_sign_bit_copies (x, mode) - 1);\n }\n \f\n@@ -7148,6 +7161,7 @@ simplify_shift_const (x, code, result_mode, varop, count)\n \t    }\n \t  else if ((code == ASHIFTRT || code == LSHIFTRT)\n \t\t   && count < HOST_BITS_PER_WIDE_INT\n+\t\t   && GET_MODE_BITSIZE (result_mode) <= HOST_BITS_PER_WIDE_INT\n \t\t   && 0 == (significant_bits (XEXP (varop, 0), result_mode)\n \t\t\t    >> count)\n \t\t   && 0 == (significant_bits (XEXP (varop, 0), result_mode)\n@@ -7667,6 +7681,8 @@ simplify_comparison (code, pop0, pop1)\n \t\t    > GET_MODE_SIZE (GET_MODE (SUBREG_REG (XEXP (op0, 0)))))\n \t\t&& (GET_MODE (SUBREG_REG (XEXP (op0, 0)))\n \t\t    == GET_MODE (SUBREG_REG (XEXP (op1, 0))))\n+\t\t&& (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (XEXP (op0, 0))))\n+\t\t    <= HOST_BITS_PER_WIDE_INT)\n \t\t&& (significant_bits (SUBREG_REG (XEXP (op0, 0)),\n \t\t\t\t      GET_MODE (SUBREG_REG (XEXP (op0, 0))))\n \t\t    & ~ INTVAL (XEXP (op0, 1))) == 0\n@@ -8433,7 +8449,8 @@ simplify_comparison (code, pop0, pop1)\n   else if (GET_CODE (op0) == SUBREG && subreg_lowpart_p (op0)\n \t   && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT\n \t   && (code == NE || code == EQ)\n-\t   && GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_WIDE_INT\n+\t   && (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (op0)))\n+\t       <= HOST_BITS_PER_WIDE_INT)\n \t   && (significant_bits (SUBREG_REG (op0), GET_MODE (SUBREG_REG (op0)))\n \t       & ~ GET_MODE_MASK (GET_MODE (op0))) == 0\n \t   && (tem = gen_lowpart_for_combine (GET_MODE (SUBREG_REG (op0)),"}]}