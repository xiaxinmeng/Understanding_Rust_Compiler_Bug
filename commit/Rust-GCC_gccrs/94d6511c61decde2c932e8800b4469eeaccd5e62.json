{"sha": "94d6511c61decde2c932e8800b4469eeaccd5e62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRkNjUxMWM2MWRlY2RlMmM5MzJlODgwMGI0NDY5ZWVhY2NkNWU2Mg==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1994-08-31T23:42:28Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1994-08-31T23:42:28Z"}, "message": "stmt.c (all_cases_count, [...]): New functions.\n\n* stmt.c (all_cases_count, mark_seen_cases):  New functions.\n(BITARRAY_TEST, BITARRAY_SET):  New macros.  Used (mainly by\nChill) to check all cases are covered (for enums and ranges).\n(check_for_full_enumeration_handling):  Re-write to use the\nnew functions, now that we have them.\n\nFrom-SVN: r8009", "tree": {"sha": "0a4bb7db39b8818eaae4160604d11a8b0acba84d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a4bb7db39b8818eaae4160604d11a8b0acba84d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94d6511c61decde2c932e8800b4469eeaccd5e62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94d6511c61decde2c932e8800b4469eeaccd5e62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94d6511c61decde2c932e8800b4469eeaccd5e62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94d6511c61decde2c932e8800b4469eeaccd5e62/comments", "author": null, "committer": null, "parents": [{"sha": "91378b76fda1883f0ace90ca04e883ef35bcbbe0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91378b76fda1883f0ace90ca04e883ef35bcbbe0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91378b76fda1883f0ace90ca04e883ef35bcbbe0"}], "stats": {"total": 243, "additions": 224, "deletions": 19}, "files": [{"sha": "59a6777921e9e77476b8a059a28ed0d0bacb0b0b", "filename": "gcc/stmt.c", "status": "modified", "additions": 224, "deletions": 19, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d6511c61decde2c932e8800b4469eeaccd5e62/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d6511c61decde2c932e8800b4469eeaccd5e62/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=94d6511c61decde2c932e8800b4469eeaccd5e62", "patch": "@@ -4077,6 +4077,193 @@ bc_pushcase (value, label)\n   return 0;\n }\n \f\n+/* Returns the number of possible values of TYPE.\n+   Returns -1 if the number is unknown or variable.\n+   Returns -2 if the number does not fit in a HOST_WIDE_INT.\n+   Sets *SPARENESS to 2 if TYPE is an ENUMERAL_TYPE whose values\n+   do not increase monotonically (there may be duplicates);\n+   to 1 if the values increase monotonically, but not always by 1;\n+   otherwise sets it to 0.  */\n+\n+HOST_WIDE_INT\n+all_cases_count (type, spareness)\n+     tree type;\n+     int *spareness;\n+{\n+  HOST_WIDE_INT count, count_high = 0;\n+  *spareness = 0;\n+\n+  switch (TREE_CODE (type))\n+    {\n+      tree t;\n+    case BOOLEAN_TYPE:\n+      count = 2;\n+      break;\n+    case CHAR_TYPE:\n+      count = 1 << BITS_PER_UNIT;\n+      break;\n+    default:\n+    case INTEGER_TYPE:\n+      if (TREE_CODE (TYPE_MIN_VALUE (type)) != INTEGER_CST\n+\t  || TREE_CODE (TYPE_MIN_VALUE (type)) != INTEGER_CST)\n+\treturn -1;\n+      else\n+\t{\n+\t  /* count\n+\t     = TREE_INT_CST_LOW (TYPE_MAX_VALUE (type))\n+\t     - TREE_INT_CST_LOW (TYPE_MIN_VALUE (type)) + 1\n+\t     but with overflow checking. */\n+\t  tree mint = TYPE_MIN_VALUE (type);\n+\t  tree maxt = TYPE_MAX_VALUE (type);\n+\t  HOST_WIDE_INT lo, hi;\n+\t  neg_double(TREE_INT_CST_LOW (mint), TREE_INT_CST_HIGH (mint),\n+\t\t     &lo, &hi);\n+\t  add_double(TREE_INT_CST_LOW (maxt), TREE_INT_CST_HIGH (maxt),\n+\t\t     lo, hi, &lo, &hi);\n+\t  add_double (lo, hi, 1, 0, &lo, &hi);\n+\t  if (hi != 0 || lo < 0)\n+\t    return -2;\n+\t  count = lo;\n+\t}\n+      break;\n+    case ENUMERAL_TYPE:\n+      count = 0;\n+      for (t = TYPE_VALUES (type); t != NULL_TREE; t = TREE_CHAIN (t))\n+\t{\n+\t  if (TREE_CODE (TYPE_MIN_VALUE (type)) != INTEGER_CST\n+\t      || TREE_CODE (TREE_VALUE (t)) != INTEGER_CST\n+\t      || TREE_INT_CST_LOW (TYPE_MIN_VALUE (type)) + count\n+\t      != TREE_INT_CST_LOW (TREE_VALUE (t)))\n+\t    *spareness = 1;\n+\t  count++;\n+\t}\n+      if (*spareness == 1)\n+\t{\n+\t  tree prev = TREE_VALUE (TYPE_VALUES (type));\n+\t  for (t = TYPE_VALUES (type); t = TREE_CHAIN (t), t != NULL_TREE; )\n+\t    {\n+\t      if (! tree_int_cst_lt (prev, TREE_VALUE (t)))\n+\t\t{\n+\t\t  *spareness = 2;\n+\t\t  break;\n+\t\t}\n+\t      prev = TREE_VALUE (t);\n+\t    }\n+\t  \n+\t}\n+    }\n+  return count;\n+}\n+\n+\n+#define BITARRAY_TEST(ARRAY, INDEX) \\\n+  ((ARRAY)[(unsigned)(INDEX) / HOST_BITS_PER_CHAR]\\\n+\t\t\t  & (1 << ((unsigned)(INDEX) % HOST_BITS_PER_CHAR)))\n+#define BITARRAY_SET(ARRAY, INDEX) \\\n+  ((ARRAY)[(unsigned)(INDEX) / HOST_BITS_PER_CHAR]\\\n+\t\t\t  |= 1 << ((unsigned)(INDEX) % HOST_BITS_PER_CHAR))\n+\n+/* Set the elements of the bitstring CASES_SEEN (which has length COUNT),\n+   with the case values we have seen, assuming the case expression\n+   has the given TYPE.\n+   SPARSENESS is as determined by all_cases_count.\n+\n+   The time needed is propotional to COUNT, unless\n+   SPARSENESS is 2, in which case quadratic time is needed.  */\n+\n+void\n+mark_seen_cases (type, cases_seen, count, sparseness)\n+     tree type;\n+     unsigned char *cases_seen;\n+     long count;\n+     int sparseness;\n+{\n+  long i;\n+\n+  tree next_node_to_try = NULL_TREE;\n+  long next_node_offset = 0;\n+\n+  register struct case_node *n;\n+  tree val = make_node (INTEGER_CST);\n+  TREE_TYPE (val) = type;\n+  for (n = case_stack->data.case_stmt.case_list; n;\n+       n = n->right)\n+    {\n+      TREE_INT_CST_LOW (val) = TREE_INT_CST_LOW (n->low);\n+      TREE_INT_CST_HIGH (val) = TREE_INT_CST_HIGH (n->low);\n+      while ( ! tree_int_cst_lt (n->high, val))\n+\t{\n+\t  /* Calculate (into xlo) the \"offset\" of the integer (val).\n+\t     The element with lowest value has offset 0, the next smallest\n+\t     element has offset 1, etc.  */\n+\n+\t  HOST_WIDE_INT xlo, xhi;\n+\t  tree t;\n+\t  if (sparseness == 2)\n+\t    {\n+\t      /* This less efficient loop is only needed to handle\n+\t\t duplicate case values (multiple enum constants\n+\t\t with the same value).  */\n+\t      for (t = TYPE_VALUES (type), xlo = 0;  t != NULL_TREE;\n+\t\t   t = TREE_CHAIN (t), xlo++)\n+\t\t{\n+\t\t  if (tree_int_cst_equal (val, TREE_VALUE (t)))\n+\t\t    BITARRAY_SET (cases_seen, xlo);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if (sparseness && TYPE_VALUES (type) != NULL_TREE)\n+\t\t{\n+\t\t  /* The TYPE_VALUES will be in increasing order, so\n+\t\t     starting searching where we last ended.  */\n+\t\t  t = next_node_to_try;\n+\t\t  xlo = next_node_offset;\n+\t\t  xhi = 0;\n+\t\t  for (;;)\n+\t\t    {\n+\t\t      if (t == NULL_TREE)\n+\t\t\t{\n+\t\t\t  t = TYPE_VALUES (type);\n+\t\t\t  xlo = 0;\n+\t\t\t}\n+\t\t      if (tree_int_cst_equal (val, TREE_VALUE (t)))\n+\t\t\t{\n+\t\t\t  next_node_to_try = TREE_CHAIN (t);\n+\t\t\t  next_node_offset = xlo + 1;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t      xlo++;\n+\t\t      t = TREE_CHAIN (t);\n+\t\t      if (t == next_node_to_try)\n+\t\t\tbreak;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  t = TYPE_MIN_VALUE (type);\n+\t\t  if (t)\n+\t\t    neg_double (TREE_INT_CST_LOW (t), TREE_INT_CST_HIGH (t),\n+\t\t\t\t&xlo, &xhi);\n+\t\t  else\n+\t\t    xlo = xhi = 0;\n+\t\t  add_double (xlo, xhi,\n+\t\t\t      TREE_INT_CST_LOW (val), TREE_INT_CST_HIGH (val),\n+\t\t\t      &xlo, &xhi);\n+\t\t}\n+\t      \n+\t      if (xhi != 0 || xlo < 0 || xlo >= count)\n+\t\tfatal (\"internal error - mark_cases_seen\");\n+\t      else\n+\t\tBITARRAY_SET (cases_seen, xlo);\n+\t    }\n+\t  add_double (TREE_INT_CST_LOW (val), TREE_INT_CST_HIGH (val),\n+\t\t      1, 0,\n+\t\t      &TREE_INT_CST_LOW (val), &TREE_INT_CST_HIGH (val));\n+\t}\n+    }\n+}\n+\n /* Called when the index of a switch statement is an enumerated type\n    and there is no default label.\n \n@@ -4097,37 +4284,55 @@ check_for_full_enumeration_handling (type)\n   register tree chain;\n   int all_values = 1;\n \n+  /* True iff the selector type is a numbered set mode. */\n+  int sparseness = 0;\n+\n+  /* The number of possible selector values. */\n+  HOST_WIDE_INT size;\n+\n+  /* For each possible selector value. a one iff it has been matched\n+     by a case value alternative. */\n+  unsigned char *cases_seen;\n+\n+  /* The allocated size of cases_seen, in chars. */\n+  long bytes_needed;\n+  tree t;\n+\n   if (output_bytecode)\n     {\n       bc_check_for_full_enumeration_handling (type);\n       return;\n     }\n \n-  /* The time complexity of this loop is currently O(N * M), with\n-     N being the number of members in the enumerated type, and\n-     M being the number of case expressions in the switch. */\n+  if (! warn_switch)\n+    return;\n+\n+  size = all_cases_count (type, &sparseness);\n+  bytes_needed = (size + HOST_BITS_PER_CHAR) / HOST_BITS_PER_CHAR;\n \n-  for (chain = TYPE_VALUES (type);\n-       chain;\n-       chain = TREE_CHAIN (chain))\n+  if (size > 0 && size < 600000\n+      /* We deliberately use malloc here - not xmalloc. */\n+      && (cases_seen = (char*) malloc (bytes_needed)) != NULL)\n     {\n-      /* Find a match between enumeral and case expression, if possible.\n-\t Quit looking when we've gone too far (since case expressions\n-\t are kept sorted in ascending order).  Warn about enumerators not\n-\t handled in the switch statement case expression list. */\n-\n-      for (n = case_stack->data.case_stmt.case_list;\n-\t   n && tree_int_cst_lt (n->high, TREE_VALUE (chain));\n-\t   n = n->right)\n-\t;\n+      long i;\n+      tree v = TYPE_VALUES (type);\n+      bzero (cases_seen, bytes_needed);\n+\n+      /* The time complexity of this code is normally O(N), where\n+\t N being the number of members in the enumerated type.\n+\t However, if type is a ENUMERAL_TYPE whose values do not\n+\t increase monotonically, quadratic time may be needed. */\n \n-      if (!n || tree_int_cst_lt (TREE_VALUE (chain), n->low))\n+      mark_seen_cases (type, cases_seen, size, sparseness);\n+\n+      for (i = 0;  v != NULL_TREE && i < size; i++, v = TREE_CHAIN (v))\n \t{\n-\t  if (warn_switch)\n+\t  if (BITARRAY_TEST(cases_seen, i) == 0)\n \t    warning (\"enumeration value `%s' not handled in switch\",\n-\t\t     IDENTIFIER_POINTER (TREE_PURPOSE (chain)));\n-\t  all_values = 0;\n+\t\t     IDENTIFIER_POINTER (TREE_PURPOSE (v)));\n \t}\n+\n+      free (cases_seen);\n     }\n \n   /* Now we go the other way around; we warn if there are case"}]}