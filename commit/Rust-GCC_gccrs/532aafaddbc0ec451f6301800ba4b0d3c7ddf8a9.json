{"sha": "532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMyYWFmYWRkYmMwZWM0NTFmNjMwMTgwMGJhNGIwZDNjN2RkZjhhOQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-07-08T10:06:14Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-07-08T10:06:14Z"}, "message": "basic-block.h: Re-group most prototypes per file.\n\ngcc/\n\t* basic-block.h: Re-group most prototypes per file.\n\t(struct edge_list): Remove num_blocks field.\n\t(dump_bb_info): Adjust prototypes.\n\t(dump_reg_info): Move prototype to regs.h.\n\t* function.h: Do not include tree.h.\n\tInclude vec.h, vecir.h, input.h and machmode.h to compensate.\n\t(function_name): New prototype.\n\t* gimple.h: Include tree.h to compensate for basic-block.h change.\n\t* langhooks.h: Note that tree.h is only necessary for enum tree_code.\n\t* regs.h (dump_reg_info): Prototype here.\n\t* regset.h: Adjust file reference in comment.\n\t(debug_regset): Remove prototype.\n\t* rtl.h: Include flags.h for flag_var_tracking_assignments.\n\t(MAY_HAVE_DEBUG_INSNS): Define as flag_var_tracking_assignments\n\tinstead of no-longer-available tree.h's MAY_HAVE_DEBUG_STMTS.\n\t(dump_reg_info, dump_flow_info): Remove prototypes.\n\t* bb-reorder.c (set_edge_can_fallthru_flag): Move from cfganal.c\n\tto here, the only user.  Make static.\n\t(reorder_basic_blocks): Call dump_reg_info before dump_flow_info.\n\t* cfg.c: Do not include tm.h, tree.h, rtl.h, hard-reg-set.h, regs.h,\n\tflags.h, function.h, except.h, diagnostic-core.h, tm_p.h, timevar.h,\n\ttree-pass.h, cfgloop.h, and tree-flow.h.\n\tInclude basic-block.h, the first header I'd expect to be included.\n\t(reg_obstack): Move to df-core.c.\n\t(free_edge): Remove bogus ATTRIBUTE_UNUSED.\n\t(remove_edge_raw): Do not call tree-ssa's redirect_edge_var_map_clear.\n\t(redirect_edge_succ_nodup): Move to cfghooks.c.\n\t(dump_regset, debug_regset): Move to df-core.c.\n\t(dump_bb_info): Move to cfgrtl.c.\n\t(dump_reg_info): Move to regstat.c.\n\t(dump_flow_info): Move to cfgrtl.c.\n\t(debug_flow_info): Likewise.\n\t(dump_edge_info): Do not look at cfun, a CFG without cfun is nonsense.\n\t* cfganal.c: Do not include tm.h, rtl.h, obstack.h, hard-reg-set.h,\n\tinsn-config.h, recog.h, diagnostic-core.h, tm_p.h, and cfgloop.h.\n\t(flow_active_insn_p, forwarder_block_p, can_fallthru,\n\tcould_fall_through): Move to cfgrtl.c.\n\t(set_edge_can_fallthru_flag): Moved to bb-reorder.c.\n\t(create_edge_list): Do not set edge_list's removed num_blocks.\n\t(print_edge_list): Look at n_basic_blocks instead of num_blocks.\n\t(flow_nodes_print): Remove.\n\t(flow_edge_list_print): Remove.\n\t(inverted_post_order_compute): Use FOR_ALL_BB.\n\t*cfgrtl.c (dump_flow_info): Moved from cfg.c.\n\tDo not call dump_reg_info.\n\t(debug_flow_info): Moved from cfg.c\n\t(dump_bb_info): Moved from cfg.c.  Take 'verbose' argument\n\tto avoid looking at TDF_* flags from tree-pass.h.\n\t(flow_active_insn_p, forwarder_block_p, can_fallthru,\n\tcould_fall_through): Moved from cfganal.c.\n\t(print_rtl_with_bb): Adjust dump_bb_info calls.\n\t* cfghooks.c (redirect_edge_succ_nodup): Moved from cfg.c.\n\t(remove_edge): Call redirect_edge_var_map_clear if IR_GIMPLE.\n\t(cfgcleanup.c): Look at MAY_HAVE_DEBUG_INSNS, not MAY_HAVE_DEBUG_STMTS.\n\t* cselib.c: Include tree.h with a FIXME.\n\t* df-core.c (reg_obstack): Moved from cfg.c.\n\t(dump_regset): Likewise.\n\t(debug_regset): Likewise.  Make a DEBUG_FUNCTION.\n\t* final.c (compute_alignments): Call dump_reg_info before\n\tdump_flow_info.\n\t* function.c (function_name): New function.\n\t(current_function_name): Use it.\n\t* ifcvt.c (rest_of_handle_if_conversion): Call dump_reg_info before\n\tdump_flow_info.\n\t* ira-conflicts.c: Include tree.h with a note.\n\t* regstat.c (dump_reg_info): Moved here from cfg.c.\n\t* loop-init.c: Include regs.h instead of hard-reg-set.h.\n\t(rtl_loop_init): Call dump_reg_info before dump_flow_info.\n\t(rtl_loop_done): Likewise.\n\t* mcf.c: Include tree.h before langhooks.h.\n\t* predict.c (maybe_hot_count_p): Assert we have cfun.\n\t(probably_never_executed_bb_p): Likewise.\n\t* profile.c (compute_branch_probabilities): Use gimple_dump_cfg\n\tinstead of dump_flow_info.\n\t* sched-deps.c: Include tree.h with a FIXME.\n\t(call_may_noreturn_p): Add FIXME note why this function has to\n\tlook at function decls instead of function decl flags.\n\t* sched-vis.c: Include tree.h with a FIXME.\n\t(print_rtl_slim): Adjust dump_bb_info uses.\n\t* statistics.c (statistics_fini_pass_2): Use current_function_name\n\tto avoid including tree.h.\n\t(statistics_counter_event): Use function_name for the same reason.\n\t(statistics_histogram_event): Likewise.\n\t* tracer.c (tracer): Remove bogus gcc_assert.  Use brief_dump_cfg\n\tinstead of dump_flow_info.\n\t* var-tracking.c (variable_tracking_main_1): Call dump_reg_info\n\tbefore dump_flow_info.\n\t* doc/cfg.texi: Update CFG documentation.\n\t* Makefile.in (RTL_H): Depend on FLAGS_H.\n\t(GIMPLE_H): Depend on TREE_H.\n\t(FUNCTION_H): Depend on VEC_H, vecir.h, INPUT_H and MACHMODE_H,\n\tbut no longer on TREE_H.\n\t(C_COMMON_H): Depend on TREE_H.\n\t(cselib.o, cse.o, cfganal.o, loop-init.o, ira-conflicts.o,\n\tsched-deps.o, sched-vis.o): Fixup dependencies.\n\nc-family/\n\t* c-common.h: Include tree.h.\n\ncp/\n\t* decl.c (cp_finish_decl): Add FIXME at add_local_decl call site.\n\nFrom-SVN: r189359", "tree": {"sha": "6449db5e8557f01213c64b681cc559f5835d3636", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6449db5e8557f01213c64b681cc559f5835d3636"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/comments", "author": null, "committer": null, "parents": [{"sha": "79bdca32d42fcd1a77fbb94826d22f020dca8829", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79bdca32d42fcd1a77fbb94826d22f020dca8829", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79bdca32d42fcd1a77fbb94826d22f020dca8829"}], "stats": {"total": 1395, "additions": 751, "deletions": 644}, "files": [{"sha": "f0f0bfaa3c2e2dc6994783f30d5bb8c322390754", "filename": "gcc/ChangeLog", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -1,3 +1,101 @@\n+2012-07-08  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* basic-block.h: Re-group most prototypes per file.\n+\t(struct edge_list): Remove num_blocks field.\n+\t(dump_bb_info): Adjust prototypes.\n+\t(dump_reg_info): Move prototype to regs.h.\n+\t* function.h: Do not include tree.h.\n+\tInclude vec.h, vecir.h, input.h and machmode.h to compensate.\n+\t(function_name): New prototype.\n+\t* gimple.h: Include tree.h to compensate for basic-block.h change.\n+\t* langhooks.h: Note that tree.h is only necessary for enum tree_code.\n+\t* regs.h (dump_reg_info): Prototype here.\n+\t* regset.h: Adjust file reference in comment.\n+\t(debug_regset): Remove prototype.\n+\t* rtl.h: Include flags.h for flag_var_tracking_assignments.\n+\t(MAY_HAVE_DEBUG_INSNS): Define as flag_var_tracking_assignments\n+\tinstead of no-longer-available tree.h's MAY_HAVE_DEBUG_STMTS.\n+\t(dump_reg_info, dump_flow_info): Remove prototypes.\n+\t* bb-reorder.c (set_edge_can_fallthru_flag): Move from cfganal.c\n+\tto here, the only user.  Make static.\n+\t(reorder_basic_blocks): Call dump_reg_info before dump_flow_info.\n+\t* cfg.c: Do not include tm.h, tree.h, rtl.h, hard-reg-set.h, regs.h,\n+\tflags.h, function.h, except.h, diagnostic-core.h, tm_p.h, timevar.h,\n+\ttree-pass.h, cfgloop.h, and tree-flow.h.\n+\tInclude basic-block.h, the first header I'd expect to be included.\n+\t(reg_obstack): Move to df-core.c.\n+\t(free_edge): Remove bogus ATTRIBUTE_UNUSED.\n+\t(remove_edge_raw): Do not call tree-ssa's redirect_edge_var_map_clear.\n+\t(redirect_edge_succ_nodup): Move to cfghooks.c.\n+\t(dump_regset, debug_regset): Move to df-core.c.\n+\t(dump_bb_info): Move to cfgrtl.c.\n+\t(dump_reg_info): Move to regstat.c.\n+\t(dump_flow_info): Move to cfgrtl.c.\n+\t(debug_flow_info): Likewise.\n+\t(dump_edge_info): Do not look at cfun, a CFG without cfun is nonsense.\n+\t* cfganal.c: Do not include tm.h, rtl.h, obstack.h, hard-reg-set.h,\n+\tinsn-config.h, recog.h, diagnostic-core.h, tm_p.h, and cfgloop.h.\n+\t(flow_active_insn_p, forwarder_block_p, can_fallthru,\n+\tcould_fall_through): Move to cfgrtl.c.\n+\t(set_edge_can_fallthru_flag): Moved to bb-reorder.c.\n+\t(create_edge_list): Do not set edge_list's removed num_blocks.\n+\t(print_edge_list): Look at n_basic_blocks instead of num_blocks.\n+\t(flow_nodes_print): Remove.\n+\t(flow_edge_list_print): Remove.\n+\t(inverted_post_order_compute): Use FOR_ALL_BB.\n+\t*cfgrtl.c (dump_flow_info): Moved from cfg.c.\n+\tDo not call dump_reg_info.\n+\t(debug_flow_info): Moved from cfg.c\n+\t(dump_bb_info): Moved from cfg.c.  Take 'verbose' argument\n+\tto avoid looking at TDF_* flags from tree-pass.h.\n+\t(flow_active_insn_p, forwarder_block_p, can_fallthru,\n+\tcould_fall_through): Moved from cfganal.c.\n+\t(print_rtl_with_bb): Adjust dump_bb_info calls.\n+\t* cfghooks.c (redirect_edge_succ_nodup): Moved from cfg.c.\n+\t(remove_edge): Call redirect_edge_var_map_clear if IR_GIMPLE.\n+\t(cfgcleanup.c): Look at MAY_HAVE_DEBUG_INSNS, not MAY_HAVE_DEBUG_STMTS.\n+\t* cselib.c: Include tree.h with a FIXME.\n+\t* df-core.c (reg_obstack): Moved from cfg.c.\n+\t(dump_regset): Likewise.\n+\t(debug_regset): Likewise.  Make a DEBUG_FUNCTION.\n+\t* final.c (compute_alignments): Call dump_reg_info before\n+\tdump_flow_info.\n+\t* function.c (function_name): New function.\n+\t(current_function_name): Use it.\n+\t* ifcvt.c (rest_of_handle_if_conversion): Call dump_reg_info before\n+\tdump_flow_info.\n+\t* ira-conflicts.c: Include tree.h with a note.\n+\t* regstat.c (dump_reg_info): Moved here from cfg.c.\n+\t* loop-init.c: Include regs.h instead of hard-reg-set.h.\n+\t(rtl_loop_init): Call dump_reg_info before dump_flow_info.\n+\t(rtl_loop_done): Likewise.\n+\t* mcf.c: Include tree.h before langhooks.h.\n+\t* predict.c (maybe_hot_count_p): Assert we have cfun.\n+\t(probably_never_executed_bb_p): Likewise.\n+\t* profile.c (compute_branch_probabilities): Use gimple_dump_cfg\n+\tinstead of dump_flow_info.\n+\t* sched-deps.c: Include tree.h with a FIXME.\n+\t(call_may_noreturn_p): Add FIXME note why this function has to\n+\tlook at function decls instead of function decl flags.\n+\t* sched-vis.c: Include tree.h with a FIXME.\n+\t(print_rtl_slim): Adjust dump_bb_info uses.\n+\t* statistics.c (statistics_fini_pass_2): Use current_function_name\n+\tto avoid including tree.h.\n+\t(statistics_counter_event): Use function_name for the same reason.\n+\t(statistics_histogram_event): Likewise.\n+\t* tracer.c (tracer): Remove bogus gcc_assert.  Use brief_dump_cfg\n+\tinstead of dump_flow_info.\n+\t* var-tracking.c (variable_tracking_main_1): Call dump_reg_info\n+\tbefore dump_flow_info.\n+\t* doc/cfg.texi: Update CFG documentation.\n+\t* Makefile.in (RTL_H): Depend on FLAGS_H.\n+\t(GIMPLE_H): Depend on TREE_H.\n+\t(FUNCTION_H): Depend on VEC_H, vecir.h, INPUT_H and MACHMODE_H,\n+\tbut no longer on TREE_H.\n+\t(C_COMMON_H): Depend on TREE_H.\n+\t(cselib.o, cse.o, cfganal.o, loop-init.o, ira-conflicts.o,\n+\tsched-deps.o, sched-vis.o): Fixup dependencies.\n+\n 2012-07-08  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* alias.h: Do not include coretypes.h in header files."}, {"sha": "e92ad945527dc0b2ed071b6512ee257b621168d6", "filename": "gcc/Makefile.in", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -859,7 +859,7 @@ RTL_BASE_H = coretypes.h rtl.h rtl.def $(MACHMODE_H) reg-notes.def \\\n   insn-notes.def $(INPUT_H) $(REAL_H) statistics.h $(VEC_H) \\\n   $(FIXED_VALUE_H) alias.h $(HASHTAB_H)\n FIXED_VALUE_H = fixed-value.h $(MACHMODE_H) double-int.h\n-RTL_H = $(RTL_BASE_H) genrtl.h vecir.h\n+RTL_H = $(RTL_BASE_H) $(FLAGS_H) genrtl.h vecir.h\n RTL_ERROR_H = rtl-error.h $(RTL_H) $(DIAGNOSTIC_CORE_H)\n READ_MD_H = $(OBSTACK_H) $(HASHTAB_H) read-md.h\n PARAMS_H = params.h params.def\n@@ -875,7 +875,7 @@ TREE_H = coretypes.h tree.h all-tree.def tree.def c-family/c-common.def \\\n REGSET_H = regset.h $(BITMAP_H) hard-reg-set.h\n BASIC_BLOCK_H = basic-block.h $(PREDICT_H) $(VEC_H) $(FUNCTION_H) cfghooks.h\n GIMPLE_H = gimple.h gimple.def gsstruct.def pointer-set.h $(VEC_H) \\\n-\tvecir.h $(GGC_H) $(BASIC_BLOCK_H) tree-ssa-operands.h \\\n+\tvecir.h $(GGC_H) $(BASIC_BLOCK_H) $(TREE_H) tree-ssa-operands.h \\\n \ttree-ssa-alias.h $(INTERNAL_FN_H)\n TRANS_MEM_H = trans-mem.h\n GCOV_IO_H = gcov-io.h gcov-iov.h auto-host.h\n@@ -886,7 +886,8 @@ ALIAS_H = alias.h\n EMIT_RTL_H = emit-rtl.h\n FLAGS_H = flags.h flag-types.h $(OPTIONS_H)\n OPTIONS_H = options.h flag-types.h $(OPTIONS_H_EXTRA)\n-FUNCTION_H = function.h $(TREE_H) $(HASHTAB_H) vecprim.h $(TM_H) hard-reg-set.h\n+FUNCTION_H = function.h $(HASHTAB_H) vecprim.h $(TM_H) hard-reg-set.h \\\n+\t$(VEC_H) vecir.h $(INPUT_H) $(MACHMODE_H)\n EXPR_H = expr.h insn-config.h $(FUNCTION_H) $(RTL_H) $(FLAGS_H) $(TREE_H) $(MACHMODE_H) $(EMIT_RTL_H)\n OPTABS_H = optabs.h insn-codes.h\n REGS_H = regs.h $(MACHMODE_H) hard-reg-set.h\n@@ -911,7 +912,7 @@ GGC_INTERNAL_H = ggc-internal.h $(GGC_H)\n TIMEVAR_H = timevar.h timevar.def\n INSN_ATTR_H = insn-attr.h insn-attr-common.h $(INSN_ADDR_H)\n INSN_ADDR_H = $(srcdir)/insn-addr.h vecprim.h\n-C_COMMON_H = c-family/c-common.h c-family/c-common.def \\\n+C_COMMON_H = c-family/c-common.h c-family/c-common.def $(TREE_H) \\\n \t$(SPLAY_TREE_H) $(CPPLIB_H) $(GGC_H) $(DIAGNOSTIC_CORE_H)\n C_PRAGMA_H = c-family/c-pragma.h $(CPPLIB_H)\n C_TREE_H = c-tree.h $(C_COMMON_H) $(DIAGNOSTIC_H)\n@@ -2937,7 +2938,7 @@ cselib.o : cselib.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h $(RECOG_H) \\\n    $(EMIT_RTL_H) $(DIAGNOSTIC_CORE_H) $(FUNCTION_H) $(TREE_PASS_H) \\\n    cselib.h gt-cselib.h $(GGC_H) $(TM_P_H) $(PARAMS_H) alloc-pool.h \\\n-   $(HASHTAB_H) $(TARGET_H) $(BITMAP_H)\n+   $(HASHTAB_H) $(TARGET_H) $(BITMAP_H) $(TREE_H)\n cse.o : cse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h $(FLAGS_H) insn-config.h $(RECOG_H) $(EXPR_H) toplev.h $(DIAGNOSTIC_CORE_H) \\\n    $(FUNCTION_H) $(BASIC_BLOCK_H) $(GGC_H) $(TM_P_H) $(TIMEVAR_H) \\\n@@ -3076,10 +3077,8 @@ auto-inc-dec.o : auto-inc-dec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(RTL_H) $(TM_P_H) hard-reg-set.h $(BASIC_BLOCK_H) insn-config.h \\\n    $(REGS_H) $(FLAGS_H) $(FUNCTION_H) $(EXCEPT_H) $(DIAGNOSTIC_CORE_H) $(RECOG_H) \\\n    $(EXPR_H) $(TIMEVAR_H) $(TREE_PASS_H) $(DF_H) $(DBGCNT_H) $(TARGET_H)\n-cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \\\n-   $(REGS_H) hard-reg-set.h $(DIAGNOSTIC_CORE_H) $(FUNCTION_H) $(EXCEPT_H) $(GGC_H) \\\n-   $(TM_P_H) $(TIMEVAR_H) $(OBSTACK_H) $(TREE_H) alloc-pool.h \\\n-   $(HASHTAB_H) $(DF_H) $(CFGLOOP_H) $(TREE_FLOW_H) $(TREE_PASS_H)\n+cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(DIAGNOSTIC_CORE_H) $(GGC_H) \\\n+   $(OBSTACK_H) alloc-pool.h $(HASHTAB_H) $(CFGLOOP_H) $(BASIC_BLOCK_H)\n cfghooks.o: cfghooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) $(TIMEVAR_H) toplev.h $(DIAGNOSTIC_CORE_H) $(CFGLOOP_H)\n cfgexpand.o : cfgexpand.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n@@ -3095,10 +3094,8 @@ cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_ERROR_H) \\\n    insn-config.h $(EXPR_H) \\\n    $(CFGLOOP_H) $(OBSTACK_H) $(TARGET_H) $(TREE_H) \\\n    $(TREE_PASS_H) $(DF_H) $(GGC_H) $(COMMON_TARGET_H) gt-cfgrtl.h\n-cfganal.o : cfganal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n-   $(BASIC_BLOCK_H) hard-reg-set.h insn-config.h $(RECOG_H) $(TM_P_H) \\\n-   $(TIMEVAR_H) $(OBSTACK_H) $(DIAGNOSTIC_CORE_H) vecprim.h sbitmap.h \\\n-   $(BITMAP_H) $(CFGLOOP_H)\n+cfganal.o : cfganal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(BASIC_BLOCK_H) \\\n+   $(TIMEVAR_H) vecprim.h sbitmap.h $(BITMAP_H)\n cfgbuild.o : cfgbuild.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h $(DIAGNOSTIC_CORE_H) \\\n    $(FUNCTION_H) $(EXCEPT_H) $(TIMEVAR_H) $(TREE_H) $(EXPR_H) sbitmap.h\n@@ -3129,7 +3126,7 @@ cfgloopmanip.o : cfgloopmanip.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) \\\n loop-init.o : loop-init.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(GGC_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) \\\n    coretypes.h $(TM_H) $(OBSTACK_H) $(TREE_PASS_H) $(TIMEVAR_H) $(FLAGS_H) \\\n-   $(DF_H)\n+   $(REGS_H) $(DF_H)\n loop-unswitch.o : loop-unswitch.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(PARAMS_H) \\\n    $(EXPR_H) coretypes.h $(TM_H) $(OBSTACK_H)\n@@ -3212,7 +3209,7 @@ ira-costs.o: ira-costs.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(REGS_H) addresses.h insn-config.h $(RECOG_H) $(DIAGNOSTIC_CORE_H) $(TARGET_H) \\\n    $(PARAMS_H) $(IRA_INT_H) reload.h\n ira-conflicts.o: ira-conflicts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(TARGET_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) \\\n+   $(TARGET_H) $(RTL_H) $(REGS_H) hard-reg-set.h $(TREE_H) $(FLAGS_H) \\\n    insn-config.h $(RECOG_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_CORE_H) $(TM_P_H) $(PARAMS_H) \\\n    $(DF_H) sparseset.h addresses.h $(IRA_INT_H)\n ira-color.o: ira-color.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n@@ -3263,7 +3260,7 @@ haifa-sched.o : haifa-sched.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_\n sched-deps.o : sched-deps.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(FUNCTION_H) $(INSN_ATTR_H) $(DIAGNOSTIC_CORE_H) $(RECOG_H) $(EXCEPT_H) cselib.h \\\n-   ira.h $(PARAMS_H) $(TM_P_H) ira.h $(TARGET_H)\n+   ira.h $(PARAMS_H) $(TM_P_H) ira.h $(TARGET_H) $(TREE_H)\n sched-rgn.o : sched-rgn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(FUNCTION_H) $(INSN_ATTR_H) $(DIAGNOSTIC_CORE_H) $(RECOG_H) $(EXCEPT_H) $(PARAMS_H) \\\n@@ -3275,7 +3272,7 @@ sched-ebb.o : sched-ebb.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(PARAMS_H) $(TARGET_H)\n sched-vis.o : sched-vis.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_H) $(SCHED_INT_H) hard-reg-set.h $(BASIC_BLOCK_H) $(OBSTACK_H) \\\n-   $(TREE_PASS_H) $(INSN_ATTR_H)\n+   $(TREE_PASS_H) $(INSN_ATTR_H) $(TREE_H)\n sel-sched.o : sel-sched.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_ERROR_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(FUNCTION_H) $(INSN_ATTR_H)  $(RECOG_H) $(EXCEPT_H) $(PARAMS_H) \\"}, {"sha": "5a4540579d4229ff48137b2beb3d64b233fa5f0d", "filename": "gcc/basic-block.h", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -448,10 +448,6 @@ basic_block split_edge_and_insert (edge, rtx);\n extern void commit_one_edge_insertion (edge e);\n extern void commit_edge_insertions (void);\n \n-extern void remove_fake_edges (void);\n-extern void remove_fake_exit_edges (void);\n-extern void add_noreturn_fake_exit_edges (void);\n-extern void connect_infinite_loops_to_exit (void);\n extern edge unchecked_make_edge (basic_block, basic_block, int);\n extern edge cached_make_edge (sbitmap, basic_block, basic_block, int);\n extern edge make_edge (basic_block, basic_block, int);\n@@ -462,15 +458,7 @@ extern edge redirect_edge_succ_nodup (edge, basic_block);\n extern void redirect_edge_pred (edge, basic_block);\n extern basic_block create_basic_block_structure (rtx, rtx, rtx, basic_block);\n extern void clear_bb_flags (void);\n-extern int post_order_compute (int *, bool, bool);\n-extern int inverted_post_order_compute (int *);\n-extern int pre_and_rev_post_order_compute (int *, int *, bool);\n-extern int dfs_enumerate_from (basic_block, int,\n-\t\t\t       bool (*)(const_basic_block, const void *),\n-\t\t\t       basic_block *, int, const void *);\n-extern void compute_dominance_frontiers (struct bitmap_head_def *);\n-extern bitmap compute_idf (bitmap, struct bitmap_head_def *);\n-extern void dump_bb_info (basic_block, bool, bool, int, const char *, FILE *);\n+extern void dump_bb_info (basic_block, bool, bool, bool, const char *, FILE *);\n extern void dump_edge_info (FILE *, edge, int);\n extern void brief_dump_cfg (FILE *);\n extern void clear_edges (void);\n@@ -501,9 +489,9 @@ typedef struct ce_if_block\n } ce_if_block_t;\n \n /* This structure maintains an edge list vector.  */\n+/* FIXME: Make this a VEC(edge).  */\n struct edge_list\n {\n-  int num_blocks;\n   int num_edges;\n   edge *index_to_edge;\n };\n@@ -734,13 +722,6 @@ ei_cond (edge_iterator ei, edge *p)\n        ei_cond ((ITER), &(EDGE));\t\t\\\n        ei_next (&(ITER)))\n \n-struct edge_list * create_edge_list (void);\n-void free_edge_list (struct edge_list *);\n-void print_edge_list (FILE *, struct edge_list *);\n-void verify_edge_list (FILE *, struct edge_list *);\n-int find_edge_index (struct edge_list *, basic_block, basic_block);\n-edge find_edge (basic_block, basic_block);\n-\n #define CLEANUP_EXPENSIVE\t1\t/* Do relatively expensive optimizations\n \t\t\t\t\t   except for edge forwarding */\n #define CLEANUP_CROSSJUMP\t2\t/* Do crossjumping.  */\n@@ -789,6 +770,7 @@ extern bool predictable_edge_p (edge);\n extern void init_flow (struct function *);\n extern void debug_bb (basic_block);\n extern basic_block debug_bb_n (int);\n+extern void dump_flow_info (FILE *, int);\n extern void expunge_block (basic_block);\n extern void link_block (basic_block, basic_block);\n extern void unlink_block (basic_block);\n@@ -804,11 +786,25 @@ extern void free_aux_for_edges (void);\n \n /* In cfganal.c  */\n extern void find_unreachable_blocks (void);\n-extern bool forwarder_block_p (const_basic_block);\n-extern bool can_fallthru (basic_block, basic_block);\n-extern bool could_fall_through (basic_block, basic_block);\n-extern void flow_nodes_print (const char *, const_sbitmap, FILE *);\n-extern void flow_edge_list_print (const char *, const edge *, int, FILE *);\n+extern bool mark_dfs_back_edges (void);\n+struct edge_list * create_edge_list (void);\n+void free_edge_list (struct edge_list *);\n+void print_edge_list (FILE *, struct edge_list *);\n+void verify_edge_list (FILE *, struct edge_list *);\n+int find_edge_index (struct edge_list *, basic_block, basic_block);\n+edge find_edge (basic_block, basic_block);\n+extern void remove_fake_edges (void);\n+extern void remove_fake_exit_edges (void);\n+extern void add_noreturn_fake_exit_edges (void);\n+extern void connect_infinite_loops_to_exit (void);\n+extern int post_order_compute (int *, bool, bool);\n+extern int inverted_post_order_compute (int *);\n+extern int pre_and_rev_post_order_compute (int *, int *, bool);\n+extern int dfs_enumerate_from (basic_block, int,\n+\t\t\t       bool (*)(const_basic_block, const void *),\n+\t\t\t       basic_block *, int, const void *);\n+extern void compute_dominance_frontiers (struct bitmap_head_def *);\n+extern bitmap compute_idf (bitmap, struct bitmap_head_def *);\n \n /* In cfgrtl.c  */\n extern rtx block_label (basic_block);\n@@ -817,6 +813,8 @@ extern bool purge_all_dead_edges (void);\n extern bool purge_dead_edges (basic_block);\n extern bool fixup_abnormal_edges (void);\n extern basic_block force_nonfallthru_and_redirect (edge, basic_block, rtx);\n+extern bool forwarder_block_p (const_basic_block);\n+extern bool can_fallthru (basic_block, basic_block);\n \n /* In cfgbuild.c.  */\n extern void find_many_sub_basic_blocks (sbitmap);\n@@ -833,8 +831,6 @@ extern int flow_find_head_matching_sequence (basic_block, basic_block,\n \n extern bool delete_unreachable_blocks (void);\n \n-extern bool mark_dfs_back_edges (void);\n-extern void set_edge_can_fallthru_flag (void);\n extern void update_br_prob_note (basic_block);\n extern bool inside_basic_block_p (const_rtx);\n extern bool control_flow_insn_p (const_rtx);"}, {"sha": "dd41dee6006ec380293a2b151a4ca792e6d257e1", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -1384,6 +1384,41 @@ find_rarely_executed_basic_blocks_and_crossing_edges (void)\n   return crossing_edges;\n }\n \n+/* Set the flag EDGE_CAN_FALLTHRU for edges that can be fallthru.  */\n+\n+static void\n+set_edge_can_fallthru_flag (void)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      edge e;\n+      edge_iterator ei;\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\t{\n+\t  e->flags &= ~EDGE_CAN_FALLTHRU;\n+\n+\t  /* The FALLTHRU edge is also CAN_FALLTHRU edge.  */\n+\t  if (e->flags & EDGE_FALLTHRU)\n+\t    e->flags |= EDGE_CAN_FALLTHRU;\n+\t}\n+\n+      /* If the BB ends with an invertible condjump all (2) edges are\n+\t CAN_FALLTHRU edges.  */\n+      if (EDGE_COUNT (bb->succs) != 2)\n+\tcontinue;\n+      if (!any_condjump_p (BB_END (bb)))\n+\tcontinue;\n+      if (!invert_jump (BB_END (bb), JUMP_LABEL (BB_END (bb)), 0))\n+\tcontinue;\n+      invert_jump (BB_END (bb), JUMP_LABEL (BB_END (bb)), 0);\n+      EDGE_SUCC (bb, 0)->flags |= EDGE_CAN_FALLTHRU;\n+      EDGE_SUCC (bb, 1)->flags |= EDGE_CAN_FALLTHRU;\n+    }\n+}\n+\n /* If any destination of a crossing edge does not have a label, add label;\n    Convert any easy fall-through crossing edges to unconditional jumps.  */\n \n@@ -1959,7 +1994,11 @@ reorder_basic_blocks (void)\n   relink_block_chain (/*stay_in_cfglayout_mode=*/true);\n \n   if (dump_file)\n-    dump_flow_info (dump_file, dump_flags);\n+    {\n+      if (dump_flags & TDF_DETAILS)\n+\tdump_reg_info (dump_file);\n+      dump_flow_info (dump_file, dump_flags);\n+    }\n \n   if (flag_reorder_blocks_and_partition)\n     verify_hot_cold_block_grouping ();"}, {"sha": "dde9c936957e775fda4c63f21f9be9d701ac3183", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -1,3 +1,7 @@\n+2012-07-08  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* c-common.h: Include tree.h.\n+\n 2012-07-02  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/53524"}, {"sha": "050112e5372f6c1e69eb75025c6fd83f0fbcc261", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"splay-tree.h\"\n #include \"cpplib.h\"\n #include \"ggc.h\"\n+#include \"tree.h\"\n \n /* In order for the format checking to accept the C frontend\n    diagnostic framework extensions, you must include this file before"}, {"sha": "08b34dbb5675dc2556d439f49e6a3f5fd9bdec18", "filename": "gcc/cfg.c", "status": "modified", "additions": 11, "deletions": 261, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -43,37 +43,22 @@ along with GCC; see the file COPYING3.  If not see\n \t verify_flow_info\n      - Dumping and debugging\n \t print_rtl_with_bb, dump_bb, debug_bb, debug_bb_n\n+\n+   TODO: Document these \"Available functionality\" functions in the files\n+   that implement them.\n  */\n \f\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"rtl.h\"\n-#include \"hard-reg-set.h\"\n-#include \"regs.h\"\n-#include \"flags.h\"\n-#include \"function.h\"\n-#include \"except.h\"\n-#include \"diagnostic-core.h\"\n-#include \"tm_p.h\"\n #include \"obstack.h\"\n-#include \"timevar.h\"\n-#include \"tree-pass.h\"\n #include \"ggc.h\"\n #include \"hashtab.h\"\n #include \"alloc-pool.h\"\n+#include \"basic-block.h\"\n #include \"df.h\"\n-#include \"cfgloop.h\"\n-#include \"tree-flow.h\"\n-\n-/* The obstack on which the flow graph components are allocated.  */\n-\n-struct bitmap_obstack reg_obstack;\n+#include \"cfgloop.h\" /* FIXME: For struct loop.  */\n \n-void debug_flow_info (void);\n-static void free_edge (edge);\n \f\n #define RDIV(X,Y) (((X) + (Y) / 2) / (Y))\n \n@@ -98,10 +83,10 @@ init_flow (struct function *the_fun)\n }\n \f\n /* Helper function for remove_edge and clear_edges.  Frees edge structure\n-   without actually unlinking it from the pred/succ lists.  */\n+   without actually removing it from the pred/succ arrays.  */\n \n static void\n-free_edge (edge e ATTRIBUTE_UNUSED)\n+free_edge (edge e)\n {\n   n_edges--;\n   ggc_free (e);\n@@ -363,9 +348,6 @@ remove_edge_raw (edge e)\n   disconnect_src (e);\n   disconnect_dest (e);\n \n-  /* This is probably not needed, but it doesn't hurt.  */\n-  redirect_edge_var_map_clear (e);\n-\n   free_edge (e);\n }\n \n@@ -386,31 +368,6 @@ redirect_edge_succ (edge e, basic_block new_succ)\n   execute_on_growing_pred (e);\n }\n \n-/* Like previous but avoid possible duplicate edge.  */\n-\n-edge\n-redirect_edge_succ_nodup (edge e, basic_block new_succ)\n-{\n-  edge s;\n-\n-  s = find_edge (e->src, new_succ);\n-  if (s && s != e)\n-    {\n-      s->flags |= e->flags;\n-      s->probability += e->probability;\n-      if (s->probability > REG_BR_PROB_BASE)\n-\ts->probability = REG_BR_PROB_BASE;\n-      s->count += e->count;\n-      redirect_edge_var_map_dup (s, e);\n-      remove_edge (e);\n-      e = s;\n-    }\n-  else\n-    redirect_edge_succ (e, new_succ);\n-\n-  return e;\n-}\n-\n /* Redirect an edge's predecessor from one block to another.  */\n \n void\n@@ -485,222 +442,15 @@ check_bb_profile (basic_block bb, FILE * file)\n     }\n }\n \f\n-/* Write information about registers and basic blocks into FILE.\n-   This is part of making a debugging dump.  */\n-\n-void\n-dump_regset (regset r, FILE *outf)\n-{\n-  unsigned i;\n-  reg_set_iterator rsi;\n-\n-  if (r == NULL)\n-    {\n-      fputs (\" (nil)\", outf);\n-      return;\n-    }\n-\n-  EXECUTE_IF_SET_IN_REG_SET (r, 0, i, rsi)\n-    {\n-      fprintf (outf, \" %d\", i);\n-      if (i < FIRST_PSEUDO_REGISTER)\n-\tfprintf (outf, \" [%s]\",\n-\t\t reg_names[i]);\n-    }\n-}\n-\n-/* Print a human-readable representation of R on the standard error\n-   stream.  This function is designed to be used from within the\n-   debugger.  */\n-\n-DEBUG_FUNCTION void\n-debug_regset (regset r)\n-{\n-  dump_regset (r, stderr);\n-  putc ('\\n', stderr);\n-}\n-\n-/* Emit basic block information for BB.  HEADER is true if the user wants\n-   the generic information and the predecessors, FOOTER is true if they want\n-   the successors.  FLAGS is the dump flags of interest; TDF_DETAILS emit\n-   global register liveness information.  PREFIX is put in front of every\n-   line.  The output is emitted to FILE.  */\n-void\n-dump_bb_info (basic_block bb, bool header, bool footer, int flags,\n-\t      const char *prefix, FILE *file)\n-{\n-  edge e;\n-  edge_iterator ei;\n-\n-  if (header)\n-    {\n-      fprintf (file, \"\\n%sBasic block %d \", prefix, bb->index);\n-      if (bb->prev_bb)\n-        fprintf (file, \", prev %d\", bb->prev_bb->index);\n-      if (bb->next_bb)\n-        fprintf (file, \", next %d\", bb->next_bb->index);\n-      fprintf (file, \", loop_depth %d, count \", bb->loop_depth);\n-      fprintf (file, HOST_WIDEST_INT_PRINT_DEC, bb->count);\n-      fprintf (file, \", freq %i\", bb->frequency);\n-      /* Both maybe_hot_bb_p & probably_never_executed_bb_p functions\n-\t crash without cfun. */\n-      if (cfun && maybe_hot_bb_p (bb))\n-\tfputs (\", maybe hot\", file);\n-      if (cfun && probably_never_executed_bb_p (bb))\n-\tfputs (\", probably never executed\", file);\n-      if (bb->flags)\n-\t{\n-\t  static const char * const bits[] = {\n-\t    \"new\", \"reachable\", \"irr_loop\", \"superblock\", \"disable_sched\",\n-\t    \"hot_partition\", \"cold_partition\", \"duplicated\",\n-\t    \"non_local_goto_target\", \"rtl\", \"forwarder\", \"nonthreadable\",\n-\t    \"modified\"\n-\t  };\n-\t  unsigned int flags;\n-\n-\t  fputs (\", flags:\", file);\n-\t  for (flags = bb->flags; flags ; flags &= flags - 1)\n-\t    {\n-\t      unsigned i = ctz_hwi (flags);\n-\t      if (i < ARRAY_SIZE (bits))\n-\t\tfprintf (file, \" %s\", bits[i]);\n-\t      else\n-\t\tfprintf (file, \" <%d>\", i);\n-\t    }\n-\t}\n-      fputs (\".\\n\", file);\n-\n-      fprintf (file, \"%sPredecessors: \", prefix);\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\tdump_edge_info (file, e, 0);\n-\n-      if ((flags & TDF_DETAILS)\n-\t  && (bb->flags & BB_RTL)\n-\t  && df)\n-\t{\n-\t  putc ('\\n', file);\n-\t  df_dump_top (bb, file);\n-\t}\n-   }\n-\n-  if (footer)\n-    {\n-      fprintf (file, \"\\n%sSuccessors: \", prefix);\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\tdump_edge_info (file, e, 1);\n-\n-      if ((flags & TDF_DETAILS)\n-\t  && (bb->flags & BB_RTL)\n-\t  && df)\n-\t{\n-\t  putc ('\\n', file);\n-\t  df_dump_bottom (bb, file);\n-\t}\n-   }\n-\n-  putc ('\\n', file);\n-}\n-\n-/* Dump the register info to FILE.  */\n-\n-void\n-dump_reg_info (FILE *file)\n-{\n-  unsigned int i, max = max_reg_num ();\n-  if (reload_completed)\n-    return;\n-\n-  if (reg_info_p_size < max)\n-    max = reg_info_p_size;\n-\n-  fprintf (file, \"%d registers.\\n\", max);\n-  for (i = FIRST_PSEUDO_REGISTER; i < max; i++)\n-    {\n-      enum reg_class rclass, altclass;\n-\n-      if (regstat_n_sets_and_refs)\n-\tfprintf (file, \"\\nRegister %d used %d times across %d insns\",\n-\t\t i, REG_N_REFS (i), REG_LIVE_LENGTH (i));\n-      else if (df)\n-\tfprintf (file, \"\\nRegister %d used %d times across %d insns\",\n-\t\t i, DF_REG_USE_COUNT (i) + DF_REG_DEF_COUNT (i), REG_LIVE_LENGTH (i));\n-\n-      if (REG_BASIC_BLOCK (i) >= NUM_FIXED_BLOCKS)\n-\tfprintf (file, \" in block %d\", REG_BASIC_BLOCK (i));\n-      if (regstat_n_sets_and_refs)\n-\tfprintf (file, \"; set %d time%s\", REG_N_SETS (i),\n-\t\t (REG_N_SETS (i) == 1) ? \"\" : \"s\");\n-      else if (df)\n-\tfprintf (file, \"; set %d time%s\", DF_REG_DEF_COUNT (i),\n-\t\t (DF_REG_DEF_COUNT (i) == 1) ? \"\" : \"s\");\n-      if (regno_reg_rtx[i] != NULL && REG_USERVAR_P (regno_reg_rtx[i]))\n-\tfputs (\"; user var\", file);\n-      if (REG_N_DEATHS (i) != 1)\n-\tfprintf (file, \"; dies in %d places\", REG_N_DEATHS (i));\n-      if (REG_N_CALLS_CROSSED (i) == 1)\n-\tfputs (\"; crosses 1 call\", file);\n-      else if (REG_N_CALLS_CROSSED (i))\n-\tfprintf (file, \"; crosses %d calls\", REG_N_CALLS_CROSSED (i));\n-      if (REG_FREQ_CALLS_CROSSED (i))\n-\tfprintf (file, \"; crosses call with %d frequency\", REG_FREQ_CALLS_CROSSED (i));\n-      if (regno_reg_rtx[i] != NULL\n-\t  && PSEUDO_REGNO_BYTES (i) != UNITS_PER_WORD)\n-\tfprintf (file, \"; %d bytes\", PSEUDO_REGNO_BYTES (i));\n-\n-      rclass = reg_preferred_class (i);\n-      altclass = reg_alternate_class (i);\n-      if (rclass != GENERAL_REGS || altclass != ALL_REGS)\n-\t{\n-\t  if (altclass == ALL_REGS || rclass == ALL_REGS)\n-\t    fprintf (file, \"; pref %s\", reg_class_names[(int) rclass]);\n-\t  else if (altclass == NO_REGS)\n-\t    fprintf (file, \"; %s or none\", reg_class_names[(int) rclass]);\n-\t  else\n-\t    fprintf (file, \"; pref %s, else %s\",\n-\t\t     reg_class_names[(int) rclass],\n-\t\t     reg_class_names[(int) altclass]);\n-\t}\n-\n-      if (regno_reg_rtx[i] != NULL && REG_POINTER (regno_reg_rtx[i]))\n-\tfputs (\"; pointer\", file);\n-      fputs (\".\\n\", file);\n-    }\n-}\n-\n-\n-void\n-dump_flow_info (FILE *file, int flags)\n-{\n-  basic_block bb;\n-\n-  /* There are no pseudo registers after reload.  Don't dump them.  */\n-  if (reg_info_p_size && (flags & TDF_DETAILS) != 0)\n-    dump_reg_info (file);\n-\n-  fprintf (file, \"\\n%d basic blocks, %d edges.\\n\", n_basic_blocks, n_edges);\n-  FOR_ALL_BB (bb)\n-    {\n-      dump_bb_info (bb, true, true, flags, \"\", file);\n-      check_bb_profile (bb, file);\n-    }\n-\n-  putc ('\\n', file);\n-}\n-\n-DEBUG_FUNCTION void\n-debug_flow_info (void)\n-{\n-  dump_flow_info (stderr, TDF_DETAILS);\n-}\n-\n void\n dump_edge_info (FILE *file, edge e, int do_succ)\n {\n   basic_block side = (do_succ ? e->dest : e->src);\n-  /* both ENTRY_BLOCK_PTR & EXIT_BLOCK_PTR depend upon cfun. */\n-  if (cfun && side == ENTRY_BLOCK_PTR)\n+  /* ENTRY_BLOCK_PTR/EXIT_BLOCK_PTR depend on cfun.\n+     Compare against ENTRY_BLOCK/EXIT_BLOCK to avoid that dependency.  */\n+  if (side->index == ENTRY_BLOCK)\n     fputs (\" ENTRY\", file);\n-  else if (cfun && side == EXIT_BLOCK_PTR)\n+  else if (side->index == EXIT_BLOCK)\n     fputs (\" EXIT\", file);\n   else\n     fprintf (file, \" %d\", side->index);"}, {"sha": "c906e17e358dd6672c99dff3427c3266581a4229", "filename": "gcc/cfganal.c", "status": "modified", "additions": 6, "deletions": 192, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -1,7 +1,5 @@\n /* Control flow graph analysis code for GNU compiler.\n-   Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007, 2008, 2010\n-   Free Software Foundation, Inc.\n+   Copyright (C) 1987-2012 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -20,24 +18,16 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n /* This file contains various simple utilities to analyze the CFG.  */\n+\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"rtl.h\"\n-#include \"obstack.h\"\n-#include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n-#include \"insn-config.h\"\n-#include \"recog.h\"\n-#include \"diagnostic-core.h\"\n-#include \"tm_p.h\"\n #include \"vec.h\"\n #include \"vecprim.h\"\n #include \"bitmap.h\"\n #include \"sbitmap.h\"\n #include \"timevar.h\"\n-#include \"cfgloop.h\"\n \n /* Store the data structures necessary for depth-first search.  */\n struct depth_first_search_dsS {\n@@ -59,106 +49,6 @@ static void flow_dfs_compute_reverse_add_bb (depth_first_search_ds,\n static basic_block flow_dfs_compute_reverse_execute (depth_first_search_ds,\n \t\t\t\t\t\t     basic_block);\n static void flow_dfs_compute_reverse_finish (depth_first_search_ds);\n-static bool flow_active_insn_p (const_rtx);\n-\f\n-/* Like active_insn_p, except keep the return value clobber around\n-   even after reload.  */\n-\n-static bool\n-flow_active_insn_p (const_rtx insn)\n-{\n-  if (active_insn_p (insn))\n-    return true;\n-\n-  /* A clobber of the function return value exists for buggy\n-     programs that fail to return a value.  Its effect is to\n-     keep the return value from being live across the entire\n-     function.  If we allow it to be skipped, we introduce the\n-     possibility for register lifetime confusion.  */\n-  if (GET_CODE (PATTERN (insn)) == CLOBBER\n-      && REG_P (XEXP (PATTERN (insn), 0))\n-      && REG_FUNCTION_VALUE_P (XEXP (PATTERN (insn), 0)))\n-    return true;\n-\n-  return false;\n-}\n-\n-/* Return true if the block has no effect and only forwards control flow to\n-   its single destination.  */\n-\n-bool\n-forwarder_block_p (const_basic_block bb)\n-{\n-  rtx insn;\n-\n-  if (bb == EXIT_BLOCK_PTR || bb == ENTRY_BLOCK_PTR\n-      || !single_succ_p (bb))\n-    return false;\n-\n-  /* Protect loop latches, headers and preheaders.  */\n-  if (current_loops)\n-    {\n-      basic_block dest;\n-      if (bb->loop_father->header == bb)\n-\treturn false;\n-      dest = EDGE_SUCC (bb, 0)->dest;\n-      if (dest->loop_father->header == dest)\n-\treturn false;\n-    }\n-\n-  for (insn = BB_HEAD (bb); insn != BB_END (bb); insn = NEXT_INSN (insn))\n-    if (INSN_P (insn) && flow_active_insn_p (insn))\n-      return false;\n-\n-  return (!INSN_P (insn)\n-\t  || (JUMP_P (insn) && simplejump_p (insn))\n-\t  || !flow_active_insn_p (insn));\n-}\n-\n-/* Return nonzero if we can reach target from src by falling through.  */\n-\n-bool\n-can_fallthru (basic_block src, basic_block target)\n-{\n-  rtx insn = BB_END (src);\n-  rtx insn2;\n-  edge e;\n-  edge_iterator ei;\n-\n-  if (target == EXIT_BLOCK_PTR)\n-    return true;\n-  if (src->next_bb != target)\n-    return 0;\n-  FOR_EACH_EDGE (e, ei, src->succs)\n-    if (e->dest == EXIT_BLOCK_PTR\n-\t&& e->flags & EDGE_FALLTHRU)\n-      return 0;\n-\n-  insn2 = BB_HEAD (target);\n-  if (insn2 && !active_insn_p (insn2))\n-    insn2 = next_active_insn (insn2);\n-\n-  /* ??? Later we may add code to move jump tables offline.  */\n-  return next_active_insn (insn) == insn2;\n-}\n-\n-/* Return nonzero if we could reach target from src by falling through,\n-   if the target was made adjacent.  If we already have a fall-through\n-   edge to the exit block, we can't do that.  */\n-bool\n-could_fall_through (basic_block src, basic_block target)\n-{\n-  edge e;\n-  edge_iterator ei;\n-\n-  if (target == EXIT_BLOCK_PTR)\n-    return true;\n-  FOR_EACH_EDGE (e, ei, src->succs)\n-    if (e->dest == EXIT_BLOCK_PTR\n-\t&& e->flags & EDGE_FALLTHRU)\n-      return 0;\n-  return true;\n-}\n \f\n /* Mark the back edges in DFS traversal.\n    Return nonzero if a loop (natural or otherwise) is present.\n@@ -252,41 +142,6 @@ mark_dfs_back_edges (void)\n   return found;\n }\n \n-/* Set the flag EDGE_CAN_FALLTHRU for edges that can be fallthru.  */\n-\n-void\n-set_edge_can_fallthru_flag (void)\n-{\n-  basic_block bb;\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      edge e;\n-      edge_iterator ei;\n-\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t{\n-\t  e->flags &= ~EDGE_CAN_FALLTHRU;\n-\n-\t  /* The FALLTHRU edge is also CAN_FALLTHRU edge.  */\n-\t  if (e->flags & EDGE_FALLTHRU)\n-\t    e->flags |= EDGE_CAN_FALLTHRU;\n-\t}\n-\n-      /* If the BB ends with an invertible condjump all (2) edges are\n-\t CAN_FALLTHRU edges.  */\n-      if (EDGE_COUNT (bb->succs) != 2)\n-\tcontinue;\n-      if (!any_condjump_p (BB_END (bb)))\n-\tcontinue;\n-      if (!invert_jump (BB_END (bb), JUMP_LABEL (BB_END (bb)), 0))\n-\tcontinue;\n-      invert_jump (BB_END (bb), JUMP_LABEL (BB_END (bb)), 0);\n-      EDGE_SUCC (bb, 0)->flags |= EDGE_CAN_FALLTHRU;\n-      EDGE_SUCC (bb, 1)->flags |= EDGE_CAN_FALLTHRU;\n-    }\n-}\n-\n /* Find unreachable blocks.  An unreachable block will have 0 in\n    the reachable bit in block->flags.  A nonzero value indicates the\n    block is reachable.  */\n@@ -357,23 +212,18 @@ create_edge_list (void)\n   struct edge_list *elist;\n   edge e;\n   int num_edges;\n-  int block_count;\n   basic_block bb;\n   edge_iterator ei;\n \n-  block_count = n_basic_blocks; /* Include the entry and exit blocks.  */\n-\n-  num_edges = 0;\n-\n   /* Determine the number of edges in the flow graph by counting successor\n      edges on each basic block.  */\n+  num_edges = 0;\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n     {\n       num_edges += EDGE_COUNT (bb->succs);\n     }\n \n   elist = XNEW (struct edge_list);\n-  elist->num_blocks = block_count;\n   elist->num_edges = num_edges;\n   elist->index_to_edge = XNEWVEC (edge, num_edges);\n \n@@ -407,7 +257,7 @@ print_edge_list (FILE *f, struct edge_list *elist)\n   int x;\n \n   fprintf (f, \"Compressed edge list, %d BBs + entry & exit, and %d edges\\n\",\n-\t   elist->num_blocks, elist->num_edges);\n+\t   n_basic_blocks, elist->num_edges);\n \n   for (x = 0; x < elist->num_edges; x++)\n     {\n@@ -459,7 +309,7 @@ verify_edge_list (FILE *f, struct edge_list *elist)\n     }\n \n   /* We've verified that all the edges are in the list, now lets make sure\n-     there are no spurious edges in the list.  */\n+     there are no spurious edges in the list.  This is an expensive check!  */\n \n   FOR_BB_BETWEEN (p, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n     FOR_BB_BETWEEN (s, ENTRY_BLOCK_PTR->next_bb, NULL, next_bb)\n@@ -531,42 +381,6 @@ find_edge_index (struct edge_list *edge_list, basic_block pred, basic_block succ\n \n   return (EDGE_INDEX_NO_EDGE);\n }\n-\n-/* Dump the list of basic blocks in the bitmap NODES.  */\n-\n-void\n-flow_nodes_print (const char *str, const_sbitmap nodes, FILE *file)\n-{\n-  unsigned int node = 0;\n-  sbitmap_iterator sbi;\n-\n-  if (! nodes)\n-    return;\n-\n-  fprintf (file, \"%s { \", str);\n-  EXECUTE_IF_SET_IN_SBITMAP (nodes, 0, node, sbi)\n-    fprintf (file, \"%d \", node);\n-  fputs (\"}\\n\", file);\n-}\n-\n-/* Dump the list of edges in the array EDGE_LIST.  */\n-\n-void\n-flow_edge_list_print (const char *str, const edge *edge_list, int num_edges, FILE *file)\n-{\n-  int i;\n-\n-  if (! edge_list)\n-    return;\n-\n-  fprintf (file, \"%s { \", str);\n-  for (i = 0; i < num_edges; i++)\n-    fprintf (file, \"%d->%d \", edge_list[i]->src->index,\n-\t     edge_list[i]->dest->index);\n-\n-  fputs (\"}\\n\", file);\n-}\n-\n \f\n /* This routine will remove any fake predecessor edges for a basic block.\n    When the edge is removed, it is also removed from whatever successor\n@@ -843,7 +657,7 @@ inverted_post_order_compute (int *post_order)\n   sbitmap_zero (visited);\n \n   /* Put all blocks that have no successor into the initial work list.  */\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+  FOR_ALL_BB (bb)\n     if (EDGE_COUNT (bb->succs) == 0)\n       {\n         /* Push the initial edge on to the stack.  */"}, {"sha": "a7f8546d51f46bb9de8bf61a6b0d90e3ee797de6", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -2797,7 +2797,7 @@ delete_unreachable_blocks (void)\n      have dominators information, walking blocks backward gets us a\n      better chance of retaining most debug information than\n      otherwise.  */\n-  if (MAY_HAVE_DEBUG_STMTS && current_ir_type () == IR_GIMPLE\n+  if (MAY_HAVE_DEBUG_INSNS && current_ir_type () == IR_GIMPLE\n       && dom_info_available_p (CDI_DOMINATORS))\n     {\n       for (b = EXIT_BLOCK_PTR->prev_bb; b != ENTRY_BLOCK_PTR; b = prev_bb)"}, {"sha": "07cbad6462f663608021cd98e92f3dcf1eac55f8", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -377,9 +377,40 @@ remove_edge (edge e)\n   if (current_loops != NULL)\n     rescan_loop_exit (e, false, true);\n \n+  /* This is probably not needed, but it doesn't hurt.  */\n+  /* FIXME: This should be called via a remove_edge hook.  */\n+  if (current_ir_type () == IR_GIMPLE)\n+    redirect_edge_var_map_clear (e);\n+\n   remove_edge_raw (e);\n }\n \n+/* Like redirect_edge_succ but avoid possible duplicate edge.  */\n+\n+edge\n+redirect_edge_succ_nodup (edge e, basic_block new_succ)\n+{\n+  edge s;\n+\n+  s = find_edge (e->src, new_succ);\n+  if (s && s != e)\n+    {\n+      s->flags |= e->flags;\n+      s->probability += e->probability;\n+      if (s->probability > REG_BR_PROB_BASE)\n+\ts->probability = REG_BR_PROB_BASE;\n+      s->count += e->count;\n+      /* FIXME: This should be called via a hook and only for IR_GIMPLE.  */\n+      redirect_edge_var_map_dup (s, e);\n+      remove_edge (e);\n+      e = s;\n+    }\n+  else\n+    redirect_edge_succ (e, new_succ);\n+\n+  return e;\n+}\n+\n /* Redirect the edge E to basic block DEST even if it requires creating\n    of a new basic block; then it returns the newly created basic block.\n    Aborts when redirection is impossible.  */"}, {"sha": "595975194ddf72380ae15e8b23218adb8169e857", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 220, "deletions": 3, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -516,6 +516,107 @@ update_bb_for_insn (basic_block bb)\n   update_bb_for_insn_chain (BB_HEAD (bb), BB_END (bb), bb);\n }\n \n+\f\n+/* Like active_insn_p, except keep the return value clobber around\n+   even after reload.  */\n+\n+static bool\n+flow_active_insn_p (const_rtx insn)\n+{\n+  if (active_insn_p (insn))\n+    return true;\n+\n+  /* A clobber of the function return value exists for buggy\n+     programs that fail to return a value.  Its effect is to\n+     keep the return value from being live across the entire\n+     function.  If we allow it to be skipped, we introduce the\n+     possibility for register lifetime confusion.  */\n+  if (GET_CODE (PATTERN (insn)) == CLOBBER\n+      && REG_P (XEXP (PATTERN (insn), 0))\n+      && REG_FUNCTION_VALUE_P (XEXP (PATTERN (insn), 0)))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Return true if the block has no effect and only forwards control flow to\n+   its single destination.  */\n+/* FIXME: Make this a cfg hook.  */\n+\n+bool\n+forwarder_block_p (const_basic_block bb)\n+{\n+  rtx insn;\n+\n+  if (bb == EXIT_BLOCK_PTR || bb == ENTRY_BLOCK_PTR\n+      || !single_succ_p (bb))\n+    return false;\n+\n+  /* Protect loop latches, headers and preheaders.  */\n+  if (current_loops)\n+    {\n+      basic_block dest;\n+      if (bb->loop_father->header == bb)\n+\treturn false;\n+      dest = EDGE_SUCC (bb, 0)->dest;\n+      if (dest->loop_father->header == dest)\n+\treturn false;\n+    }\n+\n+  for (insn = BB_HEAD (bb); insn != BB_END (bb); insn = NEXT_INSN (insn))\n+    if (INSN_P (insn) && flow_active_insn_p (insn))\n+      return false;\n+\n+  return (!INSN_P (insn)\n+\t  || (JUMP_P (insn) && simplejump_p (insn))\n+\t  || !flow_active_insn_p (insn));\n+}\n+\n+/* Return nonzero if we can reach target from src by falling through.  */\n+/* FIXME: Make this a cfg hook.  */\n+\n+bool\n+can_fallthru (basic_block src, basic_block target)\n+{\n+  rtx insn = BB_END (src);\n+  rtx insn2;\n+  edge e;\n+  edge_iterator ei;\n+\n+  if (target == EXIT_BLOCK_PTR)\n+    return true;\n+  if (src->next_bb != target)\n+    return 0;\n+  FOR_EACH_EDGE (e, ei, src->succs)\n+    if (e->dest == EXIT_BLOCK_PTR\n+\t&& e->flags & EDGE_FALLTHRU)\n+      return 0;\n+\n+  insn2 = BB_HEAD (target);\n+  if (insn2 && !active_insn_p (insn2))\n+    insn2 = next_active_insn (insn2);\n+\n+  /* ??? Later we may add code to move jump tables offline.  */\n+  return next_active_insn (insn) == insn2;\n+}\n+\n+/* Return nonzero if we could reach target from src by falling through,\n+   if the target was made adjacent.  If we already have a fall-through\n+   edge to the exit block, we can't do that.  */\n+static bool\n+could_fall_through (basic_block src, basic_block target)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  if (target == EXIT_BLOCK_PTR)\n+    return true;\n+  FOR_EACH_EDGE (e, ei, src->succs)\n+    if (e->dest == EXIT_BLOCK_PTR\n+\t&& e->flags & EDGE_FALLTHRU)\n+      return 0;\n+  return true;\n+}\n \f\n /* Return the NOTE_INSN_BASIC_BLOCK of BB.  */\n rtx\n@@ -1811,10 +1912,11 @@ print_rtl_with_bb (FILE *outf, const_rtx rtx_first)\n       for (tmp_rtx = rtx_first; NULL != tmp_rtx; tmp_rtx = NEXT_INSN (tmp_rtx))\n \t{\n \t  int did_output;\n+\t  bool verbose = ((dump_flags & TDF_DETAILS) != 0);\n \n \t  bb = start[INSN_UID (tmp_rtx)];\n \t  if (bb != NULL)\n-\t    dump_bb_info (bb, true, false, dump_flags, \";; \", outf);\n+\t    dump_bb_info (bb, true, false, verbose, \";; \", outf);\n \n \t  if (in_bb_p[INSN_UID (tmp_rtx)] == NOT_IN_BB\n \t      && !NOTE_P (tmp_rtx)\n@@ -1827,7 +1929,7 @@ print_rtl_with_bb (FILE *outf, const_rtx rtx_first)\n \n \t  bb = end[INSN_UID (tmp_rtx)];\n \t  if (bb != NULL)\n-\t    dump_bb_info (bb, false, true, dump_flags, \";; \", outf);\n+\t    dump_bb_info (bb, false, true, verbose, \";; \", outf);\n \t  if (did_output)\n \t    putc ('\\n', outf);\n \t}\n@@ -1846,6 +1948,115 @@ print_rtl_with_bb (FILE *outf, const_rtx rtx_first)\n     }\n }\n \f\n+/* Emit basic block information for BB.  HEADER is true if the user wants\n+   the generic information and the predecessors, FOOTER is true if they want\n+   the successors.  If VERBOSE is true, emit global register liveness\n+   information.  PREFIX is put in front of every line.  The output is emitted\n+   to FILE.  This function should only be called by RTL CFG users.  */\n+/* FIXME: Dumping of the basic block shared info (index, prev, next, etc.)\n+   is done here and also in dump_bb_header (but to a pretty-printer buffer).\n+   This should be re-factored to give similar dumps for RTL and GIMPLE.  */\n+\n+void\n+dump_bb_info (basic_block bb, bool header, bool footer, bool verbose,\n+\t      const char *prefix, FILE *file)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  if (header)\n+    {\n+      fprintf (file, \"\\n%sBasic block %d \", prefix, bb->index);\n+      if (bb->prev_bb)\n+        fprintf (file, \", prev %d\", bb->prev_bb->index);\n+      if (bb->next_bb)\n+        fprintf (file, \", next %d\", bb->next_bb->index);\n+      fprintf (file, \", loop_depth %d, count \", bb->loop_depth);\n+      fprintf (file, HOST_WIDEST_INT_PRINT_DEC, bb->count);\n+      fprintf (file, \", freq %i\", bb->frequency);\n+      if (maybe_hot_bb_p (bb))\n+\tfputs (\", maybe hot\", file);\n+      if (probably_never_executed_bb_p (bb))\n+\tfputs (\", probably never executed\", file);\n+      if (bb->flags)\n+\t{\n+\t  static const char * const bits[] = {\n+\t    \"new\", \"reachable\", \"irr_loop\", \"superblock\", \"disable_sched\",\n+\t    \"hot_partition\", \"cold_partition\", \"duplicated\",\n+\t    \"non_local_goto_target\", \"rtl\", \"forwarder\", \"nonthreadable\",\n+\t    \"modified\"\n+\t  };\n+\t  unsigned int flags;\n+\n+\t  fputs (\", flags:\", file);\n+\t  for (flags = bb->flags; flags ; flags &= flags - 1)\n+\t    {\n+\t      unsigned i = ctz_hwi (flags);\n+\t      if (i < ARRAY_SIZE (bits))\n+\t\tfprintf (file, \" %s\", bits[i]);\n+\t      else\n+\t\tfprintf (file, \" <%d>\", i);\n+\t    }\n+\t}\n+      fputs (\".\\n\", file);\n+\n+      fprintf (file, \"%sPredecessors: \", prefix);\n+      FOR_EACH_EDGE (e, ei, bb->preds)\n+\tdump_edge_info (file, e, 0);\n+\n+      if (verbose\n+\t  && (bb->flags & BB_RTL)\n+\t  && df)\n+\t{\n+\t  putc ('\\n', file);\n+\t  df_dump_top (bb, file);\n+\t}\n+   }\n+\n+  if (footer)\n+    {\n+      fprintf (file, \"\\n%sSuccessors: \", prefix);\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tdump_edge_info (file, e, 1);\n+\n+      if (verbose\n+\t  && (bb->flags & BB_RTL)\n+\t  && df)\n+\t{\n+\t  putc ('\\n', file);\n+\t  df_dump_bottom (bb, file);\n+\t}\n+   }\n+\n+  putc ('\\n', file);\n+}\n+\n+\n+void\n+dump_flow_info (FILE *file, int flags)\n+{\n+  basic_block bb;\n+  bool verbose = ((flags & TDF_DETAILS) != 0);\n+\n+  fprintf (file, \"\\n%d basic blocks, %d edges.\\n\", n_basic_blocks, n_edges);\n+  FOR_ALL_BB (bb)\n+    {\n+      dump_bb_info (bb, true, true, verbose, \"\", file);\n+      check_bb_profile (bb, file);\n+    }\n+\n+  putc ('\\n', file);\n+}\n+\n+void debug_flow_info (void);\n+DEBUG_FUNCTION void\n+debug_flow_info (void)\n+{\n+  dump_flow_info (stderr, TDF_DETAILS);\n+}\n+\f\n+/* Update the branch probability of BB if a REG_BR_PROB is present.  */\n+\n void\n update_br_prob_note (basic_block bb)\n {\n@@ -2893,7 +3104,13 @@ struct rtl_opt_pass pass_outof_cfg_layout_mode =\n    some transformations while in cfglayout mode.  The required sequence\n    of the basic blocks is in a linked list along the bb->aux field.\n    This functions re-links the basic block prev_bb and next_bb pointers\n-   accordingly, and it compacts and renumbers the blocks.  */\n+   accordingly, and it compacts and renumbers the blocks.\n+\n+   FIXME: This currently works only for RTL, but the only RTL-specific\n+   bits are the STAY_IN_CFGLAYOUT_MODE bits.  The tracer pass was moved\n+   to GIMPLE a long time ago, but it doesn't relink the basic block\n+   chain.  It could do that (to give better initial RTL) if this function\n+   is made IR-agnostic (and moved to cfganal.c or cfg.c while at it).  */\n \n void\n relink_block_chain (bool stay_in_cfglayout_mode)"}, {"sha": "44ea7865c9e15186711b7fffa392b0260f9ca036", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -1,3 +1,7 @@\n+2012-07-08  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* decl.c (cp_finish_decl): Add FIXME at add_local_decl call site.\n+\n 2012-07-06  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/53862"}, {"sha": "842c2d8c545cd4100c7adafd07a9ff1f060d0c85", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -6190,7 +6190,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t    /* Normally local_decls is populated during GIMPLE lowering,\n \t       but [cd]tors are never actually compiled directly.  We need\n \t       to put statics on the list so we can deal with the label\n-\t       address extension.  */\n+\t       address extension.  FIXME.  */\n \t    add_local_decl (cfun, decl);\n \t}\n "}, {"sha": "6383a8753e3ffd56c17dca08eb818f0ab9ad2957", "filename": "gcc/cselib.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n \n #include \"rtl.h\"\n+#include \"tree.h\"/* FIXME: For hashing DEBUG_EXPR & friends.  */\n #include \"tm_p.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\""}, {"sha": "5c631f3a56858aaf1207f36bc2522ce8e6554931", "filename": "gcc/df-core.c", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fdf-core.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fdf-core.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-core.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -403,6 +403,9 @@ static void df_clear_bb_info (struct dataflow *, unsigned int);\n static void df_set_clean_cfg (void);\n #endif\n \n+/* The obstack on which regsets are allocated.  */\n+struct bitmap_obstack reg_obstack;\n+\n /* An obstack for bitmap not related to specific dataflow problems.\n    This obstack should e.g. be used for bitmaps with a short life time\n    such as temporary bitmaps.  */\n@@ -1860,6 +1863,40 @@ df_reg_used (rtx insn, rtx reg)\n    Debugging and printing functions.\n ----------------------------------------------------------------------------*/\n \n+/* Write information about registers and basic blocks into FILE.\n+   This is part of making a debugging dump.  */\n+\n+void\n+dump_regset (regset r, FILE *outf)\n+{\n+  unsigned i;\n+  reg_set_iterator rsi;\n+\n+  if (r == NULL)\n+    {\n+      fputs (\" (nil)\", outf);\n+      return;\n+    }\n+\n+  EXECUTE_IF_SET_IN_REG_SET (r, 0, i, rsi)\n+    {\n+      fprintf (outf, \" %d\", i);\n+      if (i < FIRST_PSEUDO_REGISTER)\n+\tfprintf (outf, \" [%s]\",\n+\t\t reg_names[i]);\n+    }\n+}\n+\n+/* Print a human-readable representation of R on the standard error\n+   stream.  This function is designed to be used from within the\n+   debugger.  */\n+extern void debug_regset (regset);\n+DEBUG_FUNCTION void\n+debug_regset (regset r)\n+{\n+  dump_regset (r, stderr);\n+  putc ('\\n', stderr);\n+}\n \n /* Write information about registers and basic blocks into FILE.\n    This is part of making a debugging dump.  */"}, {"sha": "4e77cd1029968d03f7ea57d0a34e909e5c6cf26c", "filename": "gcc/doc/cfg.texi", "status": "modified", "additions": 130, "deletions": 108, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fdoc%2Fcfg.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fdoc%2Fcfg.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcfg.texi?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -1,6 +1,5 @@\n @c -*-texinfo-*-\n-@c Copyright (C) 2001, 2003, 2004, 2005, 2006, 2007, 2008 Free Software\n-@c Foundation, Inc.\n+@c Copyright (C) 2001-2012 Free Software Foundation, Inc.\n @c This is part of the GCC manual.\n @c For copying conditions, see the file gcc.texi.\n \n@@ -14,14 +13,28 @@\n @findex basic-block.h\n \n A control flow graph (CFG) is a data structure built on top of the\n-intermediate code representation (the RTL or @code{tree} instruction\n+intermediate code representation (the RTL or @code{GIMPLE} instruction\n stream) abstracting the control flow behavior of a function that is\n being compiled.  The CFG is a directed graph where the vertices\n represent basic blocks and edges represent possible transfer of\n control flow from one basic block to another.  The data structures\n used to represent the control flow graph are defined in\n @file{basic-block.h}.\n \n+In GCC, the representation of control flow is maintained throughout\n+the compilation process, from constructing the CFG early in \n+@code{pass_build_cfg} to @code{pass_free_cfg} (see @file{passes.c}).\n+The CFG takes various different modes and may undergo extensive\n+manipulations, but the graph is always valid between its construction\n+and its release.  This way, transfer of information such as data flow,\n+a measured profile, or the loop tree, can be propagated through the\n+passes pipeline, and even from @code{GIMPLE} to @code{RTL}.\n+\n+Often the CFG may be better viewed as integral part of instruction\n+chain, than structure built on the top of it.  Updating the compiler's\n+intermediate representation for instructions can not be easily done\n+without proper maintenance of the CFG simultaneously.\n+\n @menu\n * Basic Blocks::           The definition and representation of basic blocks.\n * Edges::                  Types of edges and their representation.\n@@ -40,16 +53,10 @@ A basic block is a straight-line sequence of code with only one entry\n point and only one exit.  In GCC, basic blocks are represented using\n the @code{basic_block} data type.\n \n-@findex next_bb, prev_bb, FOR_EACH_BB\n-Two pointer members of the @code{basic_block} structure are the\n-pointers @code{next_bb} and @code{prev_bb}.  These are used to keep\n-doubly linked chain of basic blocks in the same order as the\n-underlying instruction stream.  The chain of basic blocks is updated\n-transparently by the provided API for manipulating the CFG@.  The macro\n-@code{FOR_EACH_BB} can be used to visit all the basic blocks in\n-lexicographical order.  Dominator traversals are also possible using\n-@code{walk_dominator_tree}.  Given two basic blocks A and B, block A\n-dominates block B if A is @emph{always} executed before B@.\n+@findex ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR\n+Special basic blocks represent possible entry and exit points of a\n+function.  These blocks are called @code{ENTRY_BLOCK_PTR} and\n+@code{EXIT_BLOCK_PTR}.  These blocks do not contain any code.\n \n @findex BASIC_BLOCK\n The @code{BASIC_BLOCK} array contains all basic blocks in an\n@@ -61,39 +68,61 @@ The total number of basic blocks in the function is\n the total number of basic blocks may vary during the compilation\n process, as passes reorder, create, duplicate, and destroy basic\n blocks.  The index for any block should never be greater than\n-@code{last_basic_block}.\n+@code{last_basic_block}.  The indices 0 and 1 are special codes\n+reserved for @code{ENTRY_BLOCK} and @code{EXIT_BLOCK}, the\n+indices of @code{ENTRY_BLOCK_PTR} and @code{EXIT_BLOCK_PTR}.\n \n-@findex ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR\n-Special basic blocks represent possible entry and exit points of a\n-function.  These blocks are called @code{ENTRY_BLOCK_PTR} and\n-@code{EXIT_BLOCK_PTR}.  These blocks do not contain any code, and are\n-not elements of the @code{BASIC_BLOCK} array.  Therefore they have\n-been assigned unique, negative index numbers.\n+@findex next_bb, prev_bb, FOR_EACH_BB, FOR_ALL_BB\n+Two pointer members of the @code{basic_block} structure are the\n+pointers @code{next_bb} and @code{prev_bb}.  These are used to keep\n+doubly linked chain of basic blocks in the same order as the\n+underlying instruction stream.  The chain of basic blocks is updated\n+transparently by the provided API for manipulating the CFG@.  The macro\n+@code{FOR_EACH_BB} can be used to visit all the basic blocks in\n+lexicographical order, except @code{ENTRY_BLOCK} and @code{EXIT_BLOCK}.\n+The macro @code{FOR_ALL_BB} also visits all basic blocks in\n+lexicographical order, including @code{ENTRY_BLOCK} and @code{EXIT_BLOCK}.\n+\n+@findex post_order_compute, inverted_post_order_compute, walk_dominator_tree\n+The functions @code{post_order_compute} and @code{inverted_post_order_compute}\n+can be used to compute topological orders of the CFG.  The orders are\n+stored as vectors of basic block indices.  The @code{BASIC_BLOCK} array\n+can be used to iterate each basic block by index.\n+Dominator traversals are also possible using\n+@code{walk_dominator_tree}.  Given two basic blocks A and B, block A\n+dominates block B if A is @emph{always} executed before B@.\n \n Each @code{basic_block} also contains pointers to the first\n instruction (the @dfn{head}) and the last instruction (the @dfn{tail})\n or @dfn{end} of the instruction stream contained in a basic block.  In\n fact, since the @code{basic_block} data type is used to represent\n-blocks in both major intermediate representations of GCC (@code{tree}\n+blocks in both major intermediate representations of GCC (@code{GIMPLE}\n and RTL), there are pointers to the head and end of a basic block for\n-both representations.\n+both representations, stored in intermediate representation specific\n+data in the @code{il} field of @code{struct basic_block_def}.\n+\n+@findex CODE_LABEL\n+@findex NOTE_INSN_BASIC_BLOCK\n+For RTL, these pointers are @code{BB_HEAD} and @code{BB_END}.\n \n-@findex NOTE_INSN_BASIC_BLOCK, CODE_LABEL, notes\n-For RTL, these pointers are @code{rtx head, end}.  In the RTL function\n-representation, the head pointer always points either to a\n-@code{NOTE_INSN_BASIC_BLOCK} or to a @code{CODE_LABEL}, if present.\n+@cindex insn notes, notes\n+@findex NOTE_INSN_BASIC_BLOCK\n In the RTL representation of a function, the instruction stream\n-contains not only the ``real'' instructions, but also @dfn{notes}.\n+contains not only the ``real'' instructions, but also @dfn{notes}\n+or @dfn{insn notes} (to distinguish them from @dfn{reg notes}).\n Any function that moves or duplicates the basic blocks needs\n to take care of updating of these notes.  Many of these notes expect\n-that the instruction stream consists of linear regions, making such\n-updates difficult.   The @code{NOTE_INSN_BASIC_BLOCK} note is the only\n-kind of note that may appear in the instruction stream contained in a\n-basic block.  The instruction stream of a basic block always follows a\n-@code{NOTE_INSN_BASIC_BLOCK},  but zero or more @code{CODE_LABEL}\n-nodes can precede the block note.   A basic block ends by control flow\n-instruction or last instruction before following @code{CODE_LABEL} or\n-@code{NOTE_INSN_BASIC_BLOCK}.  A @code{CODE_LABEL} cannot appear in\n+that the instruction stream consists of linear regions, so updating\n+can sometimes be tedious.  All types of insn notes are defined\n+in @file{insn-notes.def}.\n+\n+In the RTL function representation, the instructions contained in a\n+basic block always follow a @code{NOTE_INSN_BASIC_BLOCK}, but zero\n+or more @code{CODE_LABEL} nodes can precede the block note.\n+A basic block ends with a control flow instruction or with the last\n+instruction before the next @code{CODE_LABEL} or\n+@code{NOTE_INSN_BASIC_BLOCK}.\n+By definition, a @code{CODE_LABEL} cannot appear in the middle of\n the instruction stream of a basic block.\n \n @findex can_fallthru\n@@ -110,27 +139,34 @@ Before any edge is made @dfn{fall-thru}, the existence of such\n construct in the way needs to be checked by calling\n @code{can_fallthru} function.\n \n-@cindex block statement iterators\n-For the @code{tree} representation, the head and end of the basic block\n-are being pointed to by the @code{stmt_list} field, but this special\n-@code{tree} should never be referenced directly.  Instead, at the tree\n-level abstract containers and iterators are used to access statements\n-and expressions in basic blocks.  These iterators are called\n-@dfn{block statement iterators} (BSIs).  Grep for @code{^bsi}\n-in the various @file{tree-*} files.\n-The following snippet will pretty-print all the statements of the\n-program in the GIMPLE representation.\n+@cindex GIMPLE statement iterators\n+For the @code{GIMPLE} representation, the PHI nodes and statements\n+contained in a basic block are in a @code{gimple_seq} pointed to by\n+the basic block intermediate language specific pointers.\n+Abstract containers and iterators are used to access the PHI nodes\n+and statements in a basic blocks.  These iterators are called\n+@dfn{GIMPLE statement iterators} (GSIs).  Grep for @code{^gsi}\n+in the various @file{gimple-*} and @file{tree-*} files.\n+The following snippet will pretty-print all PHI nodes the statements\n+of the current function in the GIMPLE representation.\n \n @smallexample\n+basic_block bb;\n+\n FOR_EACH_BB (bb)\n   @{\n-     block_stmt_iterator si;\n-\n-     for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n-       @{\n-          tree stmt = bsi_stmt (si);\n-          print_generic_stmt (stderr, stmt, 0);\n-       @}\n+   gimple_stmt_iterator si;\n+\n+   for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n+     @{\n+       gimple phi = gsi_stmt (si);\n+       print_gimple_stmt (dump_file, phi, 0, TDF_SLIM);\n+     @}\n+   for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+     @{\n+       gimple stmt = gsi_stmt (si);\n+       print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n+     @}\n   @}\n @end smallexample\n \n@@ -144,7 +180,7 @@ Edges represent possible control flow transfers from the end of some\n basic block A to the head of another basic block B@.  We say that A is\n a predecessor of B, and B is a successor of A@.  Edges are represented\n in GCC with the @code{edge} data type.  Each @code{edge} acts as a\n-link between two basic blocks: the @code{src} member of an edge\n+link between two basic blocks: The @code{src} member of an edge\n points to the predecessor basic block of the @code{dest} basic block.\n The members @code{preds} and @code{succs} of the @code{basic_block} data\n type point to type-safe vectors of edges to the predecessors and\n@@ -245,7 +281,7 @@ is needed.  Note that this may require creation of a new basic block.\n Exception handling edges represent possible control transfers from a\n trapping instruction to an exception handler.  The definition of\n ``trapping'' varies.  In C++, only function calls can throw, but for\n-Java, exceptions like division by zero or segmentation fault are\n+Java and Ada, exceptions like division by zero or segmentation fault are\n defined and thus each instruction possibly throwing this kind of\n exception needs to be handled as control flow instruction.  Exception\n edges have the @code{EDGE_ABNORMAL} and @code{EDGE_EH} flags set.\n@@ -260,7 +296,7 @@ anyway.  The edges can be eliminated via @code{purge_dead_edges} call.\n In the RTL representation, the destination of an exception edge is\n specified by @code{REG_EH_REGION} note attached to the insn.\n In case of a trapping call the @code{EDGE_ABNORMAL_CALL} flag is set\n-too.  In the @code{tree} representation, this extra flag is not set.\n+too.  In the @code{GIMPLE} representation, this extra flag is not set.\n \n @findex may_trap_p, tree_could_trap_p\n In the RTL representation, the predicate @code{may_trap_p} may be used\n@@ -320,9 +356,11 @@ y:\n   goto *x;\n @end smallexample\n \n+@findex pass_duplicate_computed_gotos\n However, the classic problem with this transformation is that it has a\n runtime cost in there resulting code: An extra jump.  Therefore, the\n-computed jumps are un-factored in the later passes of the compiler.\n+computed jumps are un-factored in the later passes of the compiler\n+(in the pass called @code{pass_duplicate_computed_gotos}).\n Be aware of that when you work on passes in that area.  There have\n been numerous examples already where the compile time for code with\n unfactored computed jumps caused some serious headaches.\n@@ -343,7 +381,7 @@ edge from the call to the label is created with the\n @findex LABEL_ALTERNATE_NAME\n By definition, execution of function starts at basic block 0, so there\n is always an edge from the @code{ENTRY_BLOCK_PTR} to basic block 0.\n-There is no @code{tree} representation for alternate entry points at\n+There is no @code{GIMPLE} representation for alternate entry points at\n this moment.  In RTL, alternate entry points are specified by\n @code{CODE_LABEL} with @code{LABEL_ALTERNATE_NAME} defined.  This\n feature is currently used for multiple entry point prologues and is\n@@ -372,7 +410,7 @@ speed.  In such cases it is useful to know information about how often\n some given block will be executed.  That is the purpose for\n maintaining profile within the flow graph.\n GCC can handle profile information obtained through @dfn{profile\n-feedback}, but it can also  estimate branch probabilities based on\n+feedback}, but it can also estimate branch probabilities based on\n statics and heuristics.\n \n @cindex profile feedback\n@@ -425,7 +463,7 @@ Each edge also contains a branch probability field: an integer in the\n range from 0 to @code{REG_BR_PROB_BASE}.  It represents probability of\n passing control from the end of the @code{src} basic block to the\n @code{dest} basic block, i.e.@: the probability that control will flow\n-along this edge.   The @code{EDGE_FREQUENCY} macro is available to\n+along this edge.  The @code{EDGE_FREQUENCY} macro is available to\n compute how frequently a given edge is taken.  There is a @code{count}\n field for each edge as well, representing same information as for a\n basic block.\n@@ -482,76 +520,63 @@ manipulation routines when necessary.  These hooks are defined in\n manipulations, including block splitting and merging, edge redirection\n and creating and deleting basic blocks.  These hooks should provide\n everything you need to maintain and manipulate the CFG in both the RTL\n-and @code{tree} representation.\n+and @code{GIMPLE} representation.\n \n At the moment, the basic block boundaries are maintained transparently\n when modifying instructions, so there rarely is a need to move them\n manually (such as in case someone wants to output instruction outside\n basic block explicitly).\n-Often the CFG may be better viewed as integral part of instruction\n-chain, than structure built on the top of it.  However, in principle\n-the control flow graph for the @code{tree} representation is\n-@emph{not} an integral part of the representation, in that a function\n-tree may be expanded without first building a  flow graph for the\n-@code{tree} representation at all.  This happens when compiling\n-without any @code{tree} optimization enabled.  When the @code{tree}\n-optimizations are enabled and the instruction stream is rewritten in\n-SSA form, the CFG is very tightly coupled with the instruction stream.\n-In particular, statement insertion and removal has to be done with\n-care.  In fact, the whole @code{tree} representation can not be easily\n-used or maintained without proper maintenance of the CFG\n-simultaneously.\n-\n-@findex BLOCK_FOR_INSN, bb_for_stmt\n+\n+@findex BLOCK_FOR_INSN, gimple_bb\n In the RTL representation, each instruction has a\n @code{BLOCK_FOR_INSN} value that represents pointer to the basic block\n-that contains the instruction.  In the @code{tree} representation, the\n-function @code{bb_for_stmt} returns a pointer to the basic block\n+that contains the instruction.  In the @code{GIMPLE} representation, the\n+function @code{gimple_bb} returns a pointer to the basic block\n containing the queried statement.\n \n-@cindex block statement iterators\n-When changes need to be applied to a function in its @code{tree}\n-representation, @dfn{block statement iterators} should be used.  These\n+@cindex GIMPLE statement iterators\n+When changes need to be applied to a function in its @code{GIMPLE}\n+representation, @dfn{GIMPLE statement iterators} should be used.  These\n iterators provide an integrated abstraction of the flow graph and the\n instruction stream.  Block statement iterators are constructed using\n-the @code{block_stmt_iterator} data structure and several modifier are\n+the @code{gimple_stmt_iterator} data structure and several modifier are\n available, including the following:\n \n @ftable @code\n-@item bsi_start\n-This function initializes a @code{block_stmt_iterator} that points to\n+@item gsi_start\n+This function initializes a @code{gimple_stmt_iterator} that points to\n the first non-empty statement in a basic block.\n \n-@item bsi_last\n-This function initializes a @code{block_stmt_iterator} that points to\n+@item gsi_last\n+This function initializes a @code{gimple_stmt_iterator} that points to\n the last statement in a basic block.\n \n-@item bsi_end_p\n-This predicate is @code{true} if a @code{block_stmt_iterator}\n+@item gsi_end_p\n+This predicate is @code{true} if a @code{gimple_stmt_iterator}\n represents the end of a basic block.\n \n-@item bsi_next\n-This function takes a @code{block_stmt_iterator} and makes it point to\n+@item gsi_next\n+This function takes a @code{gimple_stmt_iterator} and makes it point to\n its successor.\n \n-@item bsi_prev\n-This function takes a @code{block_stmt_iterator} and makes it point to\n+@item gsi_prev\n+This function takes a @code{gimple_stmt_iterator} and makes it point to\n its predecessor.\n \n-@item bsi_insert_after\n-This function inserts a statement after the @code{block_stmt_iterator}\n+@item gsi_insert_after\n+This function inserts a statement after the @code{gimple_stmt_iterator}\n passed in.  The final parameter determines whether the statement\n iterator is updated to point to the newly inserted statement, or left\n pointing to the original statement.\n \n-@item bsi_insert_before\n-This function inserts a statement before the @code{block_stmt_iterator}\n+@item gsi_insert_before\n+This function inserts a statement before the @code{gimple_stmt_iterator}\n passed in.  The final parameter determines whether the statement\n iterator is updated to point to the newly inserted statement, or left\n pointing to the original  statement.\n \n-@item bsi_remove\n-This function removes the @code{block_stmt_iterator} passed in and\n+@item gsi_remove\n+This function removes the @code{gimple_stmt_iterator} passed in and\n rechains the remaining statements in a basic block, if any.\n @end ftable\n \n@@ -591,8 +616,8 @@ target of a jump or branch instruction.\n \n @findex insert_insn_on_edge\n @findex commit_edge_insertions\n-@findex bsi_insert_on_edge\n-@findex bsi_commit_edge_inserts\n+@findex gsi_insert_on_edge\n+@findex gsi_commit_edge_inserts\n @cindex edge splitting\n For a global optimizer, a common operation is to split edges in the\n flow graph and insert instructions on them.  In the RTL\n@@ -602,20 +627,17 @@ representation, this can be easily done using the\n call that will take care of moving the inserted instructions off the\n edge into the instruction stream contained in a basic block.  This\n includes the creation of new basic blocks where needed.  In the\n-@code{tree} representation, the equivalent functions are\n-@code{bsi_insert_on_edge} which inserts a block statement\n-iterator on an edge, and @code{bsi_commit_edge_inserts} which flushes\n+@code{GIMPLE} representation, the equivalent functions are\n+@code{gsi_insert_on_edge} which inserts a block statement\n+iterator on an edge, and @code{gsi_commit_edge_inserts} which flushes\n the instruction to actual instruction stream.\n \n-While debugging the optimization pass, a @code{verify_flow_info}\n+@findex verify_flow_info\n+@cindex CFG verification\n+While debugging the optimization pass, the @code{verify_flow_info}\n function may be useful to find bugs in the control flow graph updating\n code.\n \n-Note that at present, the representation of control flow in the\n-@code{tree} representation is discarded before expanding to RTL@.\n-Long term the CFG should be maintained and ``expanded'' to the\n-RTL representation along with the function @code{tree} itself.\n-\n \n @node Liveness information\n @section Liveness information"}, {"sha": "668aacb309eebfb3913c1410bcf907af18a659aa", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -716,6 +716,7 @@ compute_alignments (void)\n \n   if (dump_file)\n     {\n+      dump_reg_info (dump_file);\n       dump_flow_info (dump_file, TDF_DETAILS);\n       flow_loops_dump (dump_file, NULL, 1);\n     }"}, {"sha": "b37646922a457cdaf5a6e5523529d7c27510eec5", "filename": "gcc/function.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -6738,13 +6738,20 @@ reposition_prologue_and_epilogue_notes (void)\n #endif /* HAVE_prologue or HAVE_epilogue */\n }\n \n+/* Returns the name of function FN.  */\n+const char *\n+function_name (struct function *fn)\n+{\n+  if (fn == NULL)\n+    return \"(nofn)\";\n+  return lang_hooks.decl_printable_name (fn->decl, 2);\n+}\n+\n /* Returns the name of the current function.  */\n const char *\n current_function_name (void)\n {\n-  if (cfun == NULL)\n-    return \"<none>\";\n-  return lang_hooks.decl_printable_name (cfun->decl, 2);\n+  return function_name (cfun);\n }\n \f\n "}, {"sha": "a7d8b44a5d0a1d6576c126fa4d20044004f5077e", "filename": "gcc/function.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -22,11 +22,14 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_FUNCTION_H\n #define GCC_FUNCTION_H\n \n-#include \"tree.h\"\n #include \"hashtab.h\"\n+#include \"vec.h\"\n #include \"vecprim.h\"\n-#include \"tm.h\"\t\t/* For CUMULATIVE_ARGS.  */\n-#include \"hard-reg-set.h\"\n+#include \"vecir.h\"\n+#include \"machmode.h\"\n+#include \"tm.h\"\t\t\t/* For CUMULATIVE_ARGS.  */\n+#include \"hard-reg-set.h\"\t/* For HARD_REG_SET in struct rtl_data. */\n+#include \"input.h\"\t\t/* For location_t.  */\n \n /* Stack of pending (incomplete) sequences saved by `start_sequence'.\n    Each element describes one pending sequence.\n@@ -760,6 +763,7 @@ extern void clobber_return_register (void);\n extern rtx get_arg_pointer_save_area (void);\n \n /* Returns the name of the current function.  */\n+extern const char *function_name (struct function *);\n extern const char *current_function_name (void);\n \n extern void do_warn_unused_parameter (tree);"}, {"sha": "6bb6d93064092bd78597d26020a69cb0e453408a", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -28,6 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vecir.h\"\n #include \"ggc.h\"\n #include \"basic-block.h\"\n+#include \"tree.h\"\n #include \"tree-ssa-operands.h\"\n #include \"tree-ssa-alias.h\"\n #include \"internal-fn.h\""}, {"sha": "68b50a1a3381afb8500cebb40b5eac71dbb0c6d1", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -4454,7 +4454,10 @@ rest_of_handle_if_conversion (void)\n   if (flag_if_conversion)\n     {\n       if (dump_file)\n-        dump_flow_info (dump_file, dump_flags);\n+\t{\n+\t  dump_reg_info (dump_file);\n+\t  dump_flow_info (dump_file, dump_flags);\n+\t}\n       cleanup_cfg (CLEANUP_EXPENSIVE);\n       if_convert ();\n     }"}, {"sha": "1d740797ecfe9882e3606e5a8389722c48e527cc", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"regs.h\"\n #include \"rtl.h\"\n+#include \"tree.h\"\t\t/* For DECL_ARTIFICIAL and friends.  */\n #include \"tm_p.h\"\n #include \"target.h\"\n #include \"flags.h\""}, {"sha": "a91906729204cc0033c0f2c8adcfb6197c78989a", "filename": "gcc/langhooks.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -21,7 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_LANG_HOOKS_H\n #define GCC_LANG_HOOKS_H\n \n-/* This file should be #include-d after tree.h.  */\n+/* FIXME: This file should be #include-d after tree.h (for enum tree_code).  */\n \n struct diagnostic_info;\n "}, {"sha": "45d49f22cad8559556d185a240f8bc65050f377d", "filename": "gcc/loop-init.c", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -23,7 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"rtl.h\"\n-#include \"hard-reg-set.h\"\n+#include \"regs.h\"\n #include \"obstack.h\"\n #include \"basic-block.h\"\n #include \"cfgloop.h\"\n@@ -204,7 +204,10 @@ rtl_loop_init (void)\n   gcc_assert (current_ir_type () == IR_RTL_CFGLAYOUT);\n \n   if (dump_file)\n-    dump_flow_info (dump_file, dump_flags);\n+    {\n+      dump_reg_info (dump_file);\n+      dump_flow_info (dump_file, dump_flags);\n+    }\n \n   loop_optimizer_init (LOOPS_NORMAL);\n   return 0;\n@@ -242,7 +245,10 @@ rtl_loop_done (void)\n \n   cleanup_cfg (0);\n   if (dump_file)\n-    dump_flow_info (dump_file, dump_flags);\n+    {\n+      dump_reg_info (dump_file);\n+      dump_flow_info (dump_file, dump_flags);\n+    }\n \n   return 0;\n }"}, {"sha": "b6112100a31d1dd00bb5cf50184f3026e4dedcb6", "filename": "gcc/mcf.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fmcf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fmcf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmcf.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"basic-block.h\"\n+#include \"tree.h\"\t\t/* FIXME: Only for langhooks.h.  */\n #include \"langhooks.h\"\n #include \"tree.h\"\n #include \"gcov-io.h\""}, {"sha": "78f15e388e32f70fa07da6ba965614afd770068b", "filename": "gcc/predict.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -150,6 +150,8 @@ maybe_hot_count_p (gcov_type count)\n bool\n maybe_hot_bb_p (const_basic_block bb)\n {\n+  /* Make sure CFUN exists, for dump_bb_info.  */\n+  gcc_assert (cfun);\n   if (profile_status == PROFILE_READ)\n     return maybe_hot_count_p (bb->count);\n   return maybe_hot_frequency_p (bb->frequency);\n@@ -201,6 +203,8 @@ maybe_hot_edge_p (edge e)\n bool\n probably_never_executed_bb_p (const_basic_block bb)\n {\n+  /* Make sure CFUN exists, for dump_bb_info.  */\n+  gcc_assert (cfun);\n   if (profile_info && flag_branch_probabilities)\n     return ((bb->count + profile_info->runs / 2) / profile_info->runs) == 0;\n   if ((!profile_info || !flag_branch_probabilities)"}, {"sha": "bf48cffdf2ca477641a7b2372ed6f76efbbdc1df", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -640,7 +640,7 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n   if (dump_file)\n     {\n       int overlap = compute_frequency_overlap ();\n-      dump_flow_info (dump_file, dump_flags);\n+      gimple_dump_cfg (dump_file, dump_flags);\n       fprintf (dump_file, \"Static profile overlap: %d.%d%%\\n\",\n \t       overlap / (OVERLAP_BASE / 100),\n \t       overlap % (OVERLAP_BASE / 100));"}, {"sha": "99d1a94078d9e0c0af7528b80f21450ac3a7ab1c", "filename": "gcc/reginfo.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -936,7 +936,7 @@ reginfo_init (void)\n   if (df)\n     df_compute_regs_ever_live (true);\n \n-  /* This prevents dump_flow_info from losing if called\n+  /* This prevents dump_reg_info from losing if called\n      before reginfo is run.  */\n   reg_pref = NULL;\n   /* No more global register variables may be declared.  */"}, {"sha": "4c9d7a6ce4218201b3f3ff880161f9c8ba85077d", "filename": "gcc/regs.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -92,15 +92,15 @@ REG_N_SETS (int regno)\n #define INC_REG_N_SETS(N,V) (regstat_n_sets_and_refs[N].sets += V)\n \n \n-/* Functions defined in reg-stat.c.  */\n+/* Functions defined in regstat.c.  */\n extern void regstat_init_n_sets_and_refs (void);\n extern void regstat_free_n_sets_and_refs (void);\n extern void regstat_compute_ri (void);\n extern void regstat_free_ri (void);\n extern bitmap regstat_get_setjmp_crosses (void);\n extern void regstat_compute_calls_crossed (void);\n extern void regstat_free_calls_crossed (void);\n-\n+extern void dump_reg_info (FILE *);\n \n /* Register information indexed by register number.  This structure is\n    initialized by calling regstat_compute_ri and is destroyed by"}, {"sha": "c4981c720355e186fece0f5201325d2ec29f5a51", "filename": "gcc/regset.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fregset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fregset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregset.h?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -121,8 +121,7 @@ extern regset fixed_reg_set_regset;\n /* An obstack for regsets.  */\n extern bitmap_obstack reg_obstack;\n \n-/* In cfg.c  */\n+/* In df-core.c (which should use regset consistently instead of bitmap...)  */\n extern void dump_regset (regset, FILE *);\n-extern void debug_regset (regset);\n \n #endif /* GCC_REGSET_H */"}, {"sha": "ddfb404fbf2a2df10ccc3e16e5509a10277b4743", "filename": "gcc/regstat.c", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fregstat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fregstat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregstat.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -544,3 +544,69 @@ regstat_free_calls_crossed (void)\n   reg_info_p = NULL;\n }\n \n+/* Dump the register info to FILE.  */\n+\n+void\n+dump_reg_info (FILE *file)\n+{\n+  unsigned int i, max = max_reg_num ();\n+  if (reload_completed)\n+    return;\n+\n+  if (reg_info_p_size < max)\n+    max = reg_info_p_size;\n+\n+  fprintf (file, \"%d registers.\\n\", max);\n+  for (i = FIRST_PSEUDO_REGISTER; i < max; i++)\n+    {\n+      enum reg_class rclass, altclass;\n+\n+      if (regstat_n_sets_and_refs)\n+\tfprintf (file, \"\\nRegister %d used %d times across %d insns\",\n+\t\t i, REG_N_REFS (i), REG_LIVE_LENGTH (i));\n+      else if (df)\n+\tfprintf (file, \"\\nRegister %d used %d times across %d insns\",\n+\t\t i, DF_REG_USE_COUNT (i) + DF_REG_DEF_COUNT (i), REG_LIVE_LENGTH (i));\n+\n+      if (REG_BASIC_BLOCK (i) >= NUM_FIXED_BLOCKS)\n+\tfprintf (file, \" in block %d\", REG_BASIC_BLOCK (i));\n+      if (regstat_n_sets_and_refs)\n+\tfprintf (file, \"; set %d time%s\", REG_N_SETS (i),\n+\t\t (REG_N_SETS (i) == 1) ? \"\" : \"s\");\n+      else if (df)\n+\tfprintf (file, \"; set %d time%s\", DF_REG_DEF_COUNT (i),\n+\t\t (DF_REG_DEF_COUNT (i) == 1) ? \"\" : \"s\");\n+      if (regno_reg_rtx[i] != NULL && REG_USERVAR_P (regno_reg_rtx[i]))\n+\tfputs (\"; user var\", file);\n+      if (REG_N_DEATHS (i) != 1)\n+\tfprintf (file, \"; dies in %d places\", REG_N_DEATHS (i));\n+      if (REG_N_CALLS_CROSSED (i) == 1)\n+\tfputs (\"; crosses 1 call\", file);\n+      else if (REG_N_CALLS_CROSSED (i))\n+\tfprintf (file, \"; crosses %d calls\", REG_N_CALLS_CROSSED (i));\n+      if (REG_FREQ_CALLS_CROSSED (i))\n+\tfprintf (file, \"; crosses call with %d frequency\", REG_FREQ_CALLS_CROSSED (i));\n+      if (regno_reg_rtx[i] != NULL\n+\t  && PSEUDO_REGNO_BYTES (i) != UNITS_PER_WORD)\n+\tfprintf (file, \"; %d bytes\", PSEUDO_REGNO_BYTES (i));\n+\n+      rclass = reg_preferred_class (i);\n+      altclass = reg_alternate_class (i);\n+      if (rclass != GENERAL_REGS || altclass != ALL_REGS)\n+\t{\n+\t  if (altclass == ALL_REGS || rclass == ALL_REGS)\n+\t    fprintf (file, \"; pref %s\", reg_class_names[(int) rclass]);\n+\t  else if (altclass == NO_REGS)\n+\t    fprintf (file, \"; %s or none\", reg_class_names[(int) rclass]);\n+\t  else\n+\t    fprintf (file, \"; pref %s, else %s\",\n+\t\t     reg_class_names[(int) rclass],\n+\t\t     reg_class_names[(int) altclass]);\n+\t}\n+\n+      if (regno_reg_rtx[i] != NULL && REG_POINTER (regno_reg_rtx[i]))\n+\tfputs (\"; pointer\", file);\n+      fputs (\".\\n\", file);\n+    }\n+}\n+"}, {"sha": "4bef6f84003f5eeb28fbc0c94418e3a3634178fb", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"fixed-value.h\"\n #include \"alias.h\"\n #include \"hashtab.h\"\n+#include \"flags.h\"\n \n #undef FFS  /* Some systems predefine this symbol; don't let it interfere.  */\n #undef FLOAT /* Likewise.  */\n@@ -423,7 +424,7 @@ struct GTY((variable_size)) rtvec_def {\n #define NONDEBUG_INSN_P(X) (INSN_P (X) && !DEBUG_INSN_P (X))\n \n /* Nonzero if DEBUG_INSN_P may possibly hold.  */\n-#define MAY_HAVE_DEBUG_INSNS MAY_HAVE_DEBUG_STMTS\n+#define MAY_HAVE_DEBUG_INSNS (flag_var_tracking_assignments)\n \n /* Predicate yielding nonzero iff X is a real insn.  */\n #define INSN_P(X) \\\n@@ -2512,10 +2513,6 @@ extern int fixup_args_size_notes (rtx, rtx, int);\n extern void print_rtl_with_bb (FILE *, const_rtx);\n extern rtx duplicate_insn_chain (rtx, rtx);\n \n-/* In cfg.c.  */\n-extern void dump_reg_info (FILE *);\n-extern void dump_flow_info (FILE *, int);\n-\n /* In expmed.c */\n extern void init_expmed (void);\n extern void expand_inc (rtx, rtx);"}, {"sha": "1469818a1829e6a4d8288bc20b56e7c77d468701", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"diagnostic-core.h\"\n #include \"rtl.h\"\n+#include \"tree.h\"\t\t/* FIXME: Used by call_may_noreturn_p.  */\n #include \"tm_p.h\"\n #include \"hard-reg-set.h\"\n #include \"regs.h\"\n@@ -3374,6 +3375,8 @@ sched_analyze_insn (struct deps_desc *deps, rtx x, rtx insn)\n \n /* Return TRUE if INSN might not always return normally (e.g. call exit,\n    longjmp, loop forever, ...).  */\n+/* FIXME: Why can't this function just use flags_from_decl_or_type and\n+   test for ECF_NORETURN?  */\n static bool\n call_may_noreturn_p (rtx insn)\n {"}, {"sha": "2b4d6240cb801bc1794ce96c46d5f20c599d7772", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"tm.h\"\n #include \"rtl.h\"\n+#include \"tree.h\"\t/* FIXME: To dump INSN_VAR_LOCATION_DECL.  */\n #include \"obstack.h\"\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n@@ -806,13 +807,15 @@ print_rtl_slim (FILE *f, rtx first, rtx last, int count, int flags)\n        (insn != NULL) && (insn != tail) && (count != 0);\n        insn = NEXT_INSN (insn))\n     {\n+      bool verbose = ((flags & TDF_DETAILS) != 0);\n+\n       if ((flags & TDF_BLOCKS)\n \t  && (INSN_P (insn) || NOTE_P (insn))\n \t  && BLOCK_FOR_INSN (insn)\n \t  && !current_bb)\n \t{\n \t  current_bb = BLOCK_FOR_INSN (insn);\n-\t  dump_bb_info (current_bb, true, false, flags, \";; \", f);\n+\t  dump_bb_info (current_bb, true, false, verbose, \";; \", f);\n \t}\n \n       dump_insn_slim (f, insn);\n@@ -821,7 +824,7 @@ print_rtl_slim (FILE *f, rtx first, rtx last, int count, int flags)\n \t  && current_bb\n \t  && insn == BB_END (current_bb))\n \t{\n-\t  dump_bb_info (current_bb, false, true, flags, \";; \", f);\n+\t  dump_bb_info (current_bb, false, true, verbose, \";; \", f);\n \t  current_bb = NULL;\n \t}\n       if (count > 0)"}, {"sha": "55ec981f3bb504294fa08d44fcc7c8abe93ec20c", "filename": "gcc/statistics.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fstatistics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fstatistics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstatistics.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -142,15 +142,15 @@ statistics_fini_pass_2 (void **slot, void *data ATTRIBUTE_UNUSED)\n \t     current_pass->static_pass_number,\n \t     current_pass->name,\n \t     counter->id, counter->val,\n-\t     cfun ? IDENTIFIER_POINTER (DECL_NAME (cfun->decl)) : \"(nofn)\",\n+\t     current_function_name (),\n \t     count);\n   else\n     fprintf (statistics_dump_file,\n \t     \"%d %s \\\"%s\\\" \\\"%s\\\" \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n \t     current_pass->static_pass_number,\n \t     current_pass->name,\n \t     counter->id,\n-\t     cfun ? IDENTIFIER_POINTER (DECL_NAME (cfun->decl)) : \"(nofn)\",\n+\t     current_function_name (),\n \t     count);\n   counter->prev_dumped_count = counter->count;\n   return 1;\n@@ -312,7 +312,7 @@ statistics_counter_event (struct function *fn, const char *id, int incr)\n \t   current_pass->static_pass_number,\n \t   current_pass->name,\n \t   id,\n-\t   fn ? IDENTIFIER_POINTER (DECL_NAME (fn->decl)) : \"(nofn)\",\n+\t   function_name (fn),\n \t   incr);\n }\n \n@@ -342,5 +342,5 @@ statistics_histogram_event (struct function *fn, const char *id, int val)\n \t   current_pass->static_pass_number,\n \t   current_pass->name,\n \t   id, val,\n-\t   fn ? IDENTIFIER_POINTER (DECL_NAME (fn->decl)) : \"(nofn)\");\n+\t   function_name (fn));\n }"}, {"sha": "e005702eef158af4b8612cebf6d40785a1a585bc", "filename": "gcc/tracer.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -370,22 +370,20 @@ tracer (void)\n {\n   bool changed;\n \n-  gcc_assert (current_ir_type () == IR_GIMPLE);\n-\n   if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n     return 0;\n \n   mark_dfs_back_edges ();\n   if (dump_file)\n-    dump_flow_info (dump_file, dump_flags);\n+    brief_dump_cfg (dump_file);\n \n   /* Trace formation is done on the fly inside tail_duplicate */\n   changed = tail_duplicate ();\n   if (changed)\n     free_dominance_info (CDI_DOMINATORS);\n \n   if (dump_file)\n-    dump_flow_info (dump_file, dump_flags);\n+    brief_dump_cfg (dump_file);\n \n   return changed ? TODO_cleanup_cfg : 0;\n }"}, {"sha": "31773dddb17dea091f393fa70d942210c4e4f4e1", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -3833,6 +3833,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n \n   /* Set input_location here so we get the right instantiation context\n      if we call instantiate_decl from inlinable_function_p.  */\n+  /* FIXME: instantiate_decl isn't called by inlinable_function_p.  */\n   saved_location = input_location;\n   input_location = gimple_location (stmt);\n "}, {"sha": "4570b97c0a4e6d0c8da5c07ab323aa62e15d4a5f", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=532aafaddbc0ec451f6301800ba4b0d3c7ddf8a9", "patch": "@@ -10041,6 +10041,7 @@ variable_tracking_main_1 (void)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       dump_dataflow_sets ();\n+      dump_reg_info (dump_file);\n       dump_flow_info (dump_file, dump_flags);\n     }\n "}]}