{"sha": "0dee5a2a29183210dc989b0cfc2870dccab7c071", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRlZTVhMmEyOTE4MzIxMGRjOTg5YjBjZmMyODcwZGNjYWI3YzA3MQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-11-17T17:29:57Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-11-17T17:29:57Z"}, "message": "gimple-ssa-evrp.c (evrp_dom_walker::record_ranges_from_phis): New method extracted from evrp_dom_walker::before_dom_children.\n\n\t* gimple-ssa-evrp.c (evrp_dom_walker::record_ranges_from_phis): New\n\tmethod extracted from evrp_dom_walker::before_dom_children.\n\t(evrp_dom_walker::record_ranges_from_stmt): Likewise.\n\t(evrp_dom_walker::record_ranges_from_incoming_edge): Likewise.\n\nFrom-SVN: r254883", "tree": {"sha": "1a90f8d8b19f0263de3df11ce48953039adabe45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a90f8d8b19f0263de3df11ce48953039adabe45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0dee5a2a29183210dc989b0cfc2870dccab7c071", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dee5a2a29183210dc989b0cfc2870dccab7c071", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dee5a2a29183210dc989b0cfc2870dccab7c071", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dee5a2a29183210dc989b0cfc2870dccab7c071/comments", "author": null, "committer": null, "parents": [{"sha": "271eeb1818da892c0143019e29d20780dcadac8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/271eeb1818da892c0143019e29d20780dcadac8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/271eeb1818da892c0143019e29d20780dcadac8e"}], "stats": {"total": 240, "additions": 144, "deletions": 96}, "files": [{"sha": "54fa3a0e4f61c930e35b7053f381a02248048ff7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dee5a2a29183210dc989b0cfc2870dccab7c071/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dee5a2a29183210dc989b0cfc2870dccab7c071/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0dee5a2a29183210dc989b0cfc2870dccab7c071", "patch": "@@ -1,5 +1,10 @@\n 2017-11-17  Jeff Law  <law@redhat.com>\n \n+\t* gimple-ssa-evrp.c (evrp_dom_walker::record_ranges_from_phis): New\n+\tmethod extracted from evrp_dom_walker::before_dom_children.\n+\t(evrp_dom_walker::record_ranges_from_stmt): Likewise.\n+\t(evrp_dom_walker::record_ranges_from_incoming_edge): Likewise.\n+\n \t* gimple-ssa-evrp.c (evrp_dom_walker): Add cleanup method.\n \tAdd private copy constructor and move assignment operators.\n \tPrivatize methods and class data where trivially possible."}, {"sha": "c2ba904b4b8b32a3e30b34959e285407797ad72b", "filename": "gcc/gimple-ssa-evrp.c", "status": "modified", "additions": 139, "deletions": 96, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dee5a2a29183210dc989b0cfc2870dccab7c071/gcc%2Fgimple-ssa-evrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dee5a2a29183210dc989b0cfc2870dccab7c071/gcc%2Fgimple-ssa-evrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-evrp.c?ref=0dee5a2a29183210dc989b0cfc2870dccab7c071", "patch": "@@ -81,6 +81,10 @@ class evrp_dom_walker : public dom_walker\n   value_range *pop_value_range (tree var);\n   value_range *try_find_new_range (tree, tree op, tree_code code, tree limit);\n \n+  void record_ranges_from_incoming_edge (basic_block);\n+  void record_ranges_from_phis (basic_block);\n+  void record_ranges_from_stmt (gimple *);\n+\n   /* STACK holds the old VR.  */\n   auto_vec<std::pair <tree, value_range*> > stack;\n   bitmap need_eh_cleanup;\n@@ -147,17 +151,14 @@ evrp_dom_walker::try_find_new_range (tree name,\n   return NULL;\n }\n \n-/* See if there is any new scope is entered with new VR and set that VR to\n-   ssa_name before visiting the statements in the scope.  */\n+/* If BB is reached by a single incoming edge (ignoring loop edges),\n+   then derive ranges implied by traversing that edge.  */\n \n-edge\n-evrp_dom_walker::before_dom_children (basic_block bb)\n+void\n+evrp_dom_walker::record_ranges_from_incoming_edge (basic_block bb)\n {\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Visiting BB%d\\n\", bb->index);\n-\n-  stack.safe_push (std::make_pair (NULL_TREE, (value_range *)NULL));\n-\n+/* See if there is any new scope is entered with new VR and set that VR to\n+   ssa_name before visiting the statements in the scope.  */\n   edge pred_e = single_pred_edge_ignoring_loop_edges (bb, false);\n   if (pred_e)\n     {\n@@ -204,7 +205,13 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t    push_value_range (vrs[i].first, vrs[i].second);\n \t}\n     }\n+}\n+\n+/* Record ranges from any PHI nodes at the start of basic block BB.  */\n \n+void\n+evrp_dom_walker::record_ranges_from_phis (basic_block bb)\n+{\n   /* Visit PHI stmts and discover any new VRs possible.  */\n   bool has_unvisited_preds = false;\n   edge_iterator ei;\n@@ -249,14 +256,6 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t}\n       update_value_range (lhs, &vr_result);\n \n-      /* Mark PHIs whose lhs we fully propagate for removal.  */\n-      tree val = op_with_constant_singleton_value_range (lhs);\n-      if (val && may_propagate_copy (lhs, val))\n-\t{\n-\t  stmts_to_remove.safe_push (phi);\n-\t  continue;\n-\t}\n-\n       /* Set the SSA with the value range.  */\n       if (INTEGRAL_TYPE_P (TREE_TYPE (lhs)))\n \t{\n@@ -277,6 +276,122 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t\t\t\t\t\t vr_result.max) == 1)))\n \tset_ptr_nonnull (lhs);\n     }\n+}\n+\n+/* Record any ranges created by statement STMT.  */\n+\n+void\n+evrp_dom_walker::record_ranges_from_stmt (gimple *stmt)\n+{\n+  tree output = NULL_TREE;\n+\n+  if (dyn_cast <gcond *> (stmt))\n+    ;\n+  else if (stmt_interesting_for_vrp (stmt))\n+    {\n+      edge taken_edge;\n+      value_range vr = VR_INITIALIZER;\n+      extract_range_from_stmt (stmt, &taken_edge, &output, &vr);\n+      if (output && (vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE))\n+\t{\n+\t  update_value_range (output, &vr);\n+\n+\t  /* Set the SSA with the value range.  */\n+\t  if (INTEGRAL_TYPE_P (TREE_TYPE (output)))\n+\t    {\n+\t      if ((vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE)\n+\t\t   && (TREE_CODE (vr.min) == INTEGER_CST)\n+\t\t   && (TREE_CODE (vr.max) == INTEGER_CST))\n+\t\tset_range_info (output, vr.type,\n+\t\t\t\twi::to_wide (vr.min),\n+\t\t\t\twi::to_wide (vr.max));\n+\t    }\n+\t  else if (POINTER_TYPE_P (TREE_TYPE (output))\n+\t\t   && ((vr.type == VR_RANGE\n+\t\t\t&& range_includes_zero_p (vr.min, vr.max) == 0)\n+\t\t       || (vr.type == VR_ANTI_RANGE\n+\t\t\t   && range_includes_zero_p (vr.min, vr.max) == 1)))\n+\t    set_ptr_nonnull (output);\n+\t}\n+      else\n+\tset_defs_to_varying (stmt);\n+    }\n+  else\n+    set_defs_to_varying (stmt);\n+\n+  /* See if we can derive a range for any of STMT's operands.  */\n+  tree op;\n+  ssa_op_iter i;\n+  FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_USE)\n+    {\n+      tree value;\n+      enum tree_code comp_code;\n+\n+      /* If OP is used in such a way that we can infer a value\n+\t range for it, and we don't find a previous assertion for\n+\t it, create a new assertion location node for OP.  */\n+      if (infer_value_range (stmt, op, &comp_code, &value))\n+\t{\n+\t  /* If we are able to infer a nonzero value range for OP,\n+\t     then walk backwards through the use-def chain to see if OP\n+\t     was set via a typecast.\n+\t     If so, then we can also infer a nonzero value range\n+\t     for the operand of the NOP_EXPR.  */\n+\t  if (comp_code == NE_EXPR && integer_zerop (value))\n+\t    {\n+\t      tree t = op;\n+\t      gimple *def_stmt = SSA_NAME_DEF_STMT (t);\n+\t      while (is_gimple_assign (def_stmt)\n+\t\t     && CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt))\n+\t\t     && TREE_CODE (gimple_assign_rhs1 (def_stmt)) == SSA_NAME\n+\t\t     && POINTER_TYPE_P\n+\t\t\t  (TREE_TYPE (gimple_assign_rhs1 (def_stmt))))\n+\t\t{\n+\t\t  t = gimple_assign_rhs1 (def_stmt);\n+\t\t  def_stmt = SSA_NAME_DEF_STMT (t);\n+\n+\t\t  /* Add VR when (T COMP_CODE value) condition is true.  */\n+\t\t  value_range *op_range\n+\t\t    = try_find_new_range (t, t, comp_code, value);\n+\t\t  if (op_range)\n+\t\t    push_value_range (t, op_range);\n+\t\t}\n+\t    }\n+\t  /* Add VR when (OP COMP_CODE value) condition is true.  */\n+\t  value_range *op_range = try_find_new_range (op, op,\n+\t\t\t\t\t\t      comp_code, value);\n+\t  if (op_range)\n+\t    push_value_range (op, op_range);\n+\t}\n+    }\n+}\n+\n+edge\n+evrp_dom_walker::before_dom_children (basic_block bb)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Visiting BB%d\\n\", bb->index);\n+\n+  stack.safe_push (std::make_pair (NULL_TREE, (value_range *)NULL));\n+  record_ranges_from_incoming_edge (bb);\n+  record_ranges_from_phis (bb);\n+\n+  for (gphi_iterator gpi = gsi_start_phis (bb);\n+       !gsi_end_p (gpi); gsi_next (&gpi))\n+    {\n+      gphi *phi = gpi.phi ();\n+      tree lhs = PHI_RESULT (phi);\n+      if (virtual_operand_p (lhs))\n+\tcontinue;\n+\n+      /* Mark PHIs whose lhs we fully propagate for removal.  */\n+      tree val = op_with_constant_singleton_value_range (lhs);\n+      if (val && may_propagate_copy (lhs, val))\n+\t{\n+\t  stmts_to_remove.safe_push (phi);\n+\t  continue;\n+\t}\n+    }\n \n   edge taken_edge = NULL;\n \n@@ -296,6 +411,7 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t  print_gimple_stmt (dump_file, stmt, 0);\n \t}\n \n+      record_ranges_from_stmt (stmt);\n       if (gcond *cond = dyn_cast <gcond *> (stmt))\n \t{\n \t  vrp_visit_cond_stmt (cond, &taken_edge);\n@@ -312,98 +428,23 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n \t}\n       else if (stmt_interesting_for_vrp (stmt))\n \t{\n-\t  edge taken_edge;\n \t  value_range vr = VR_INITIALIZER;\n-\t  extract_range_from_stmt (stmt, &taken_edge, &output, &vr);\n-\t  if (output\n-\t      && (vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE))\n+\t  output = get_output_for_vrp (stmt);\n+\t  if (output)\n \t    {\n-\t      update_value_range (output, &vr);\n \t      vr = *get_value_range (output);\n \n \t      /* Mark stmts whose output we fully propagate for removal.  */\n \t      tree val;\n-\t      if ((val = op_with_constant_singleton_value_range (output))\n+\t      if ((vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE)\n+\t\t  && (val = op_with_constant_singleton_value_range (output))\n \t\t  && may_propagate_copy (output, val)\n \t\t  && !stmt_could_throw_p (stmt)\n \t\t  && !gimple_has_side_effects (stmt))\n \t\t{\n \t\t  stmts_to_remove.safe_push (stmt);\n \t\t  continue;\n \t\t}\n-\n-\t      /* Set the SSA with the value range.  */\n-\t      if (INTEGRAL_TYPE_P (TREE_TYPE (output)))\n-\t\t{\n-\t\t  if ((vr.type == VR_RANGE\n-\t\t       || vr.type == VR_ANTI_RANGE)\n-\t\t      && (TREE_CODE (vr.min) == INTEGER_CST)\n-\t\t      && (TREE_CODE (vr.max) == INTEGER_CST))\n-\t\t    set_range_info (output, vr.type,\n-\t\t\t\t    wi::to_wide (vr.min),\n-\t\t\t\t    wi::to_wide (vr.max));\n-\t\t}\n-\t      else if (POINTER_TYPE_P (TREE_TYPE (output))\n-\t\t       && ((vr.type == VR_RANGE\n-\t\t\t    && range_includes_zero_p (vr.min,\n-\t\t\t\t\t\t      vr.max) == 0)\n-\t\t\t   || (vr.type == VR_ANTI_RANGE\n-\t\t\t       && range_includes_zero_p (vr.min,\n-\t\t\t\t\t\t\t vr.max) == 1)))\n-\t\tset_ptr_nonnull (output);\n-\t    }\n-\t  else\n-\t    set_defs_to_varying (stmt);\n-\t}\n-      else\n-\tset_defs_to_varying (stmt);\n-\n-      /* See if we can derive a range for any of STMT's operands.  */\n-      tree op;\n-      ssa_op_iter i;\n-      FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_USE)\n-\t{\n-\t  tree value;\n-\t  enum tree_code comp_code;\n-\n-\t  /* If OP is used in such a way that we can infer a value\n-\t     range for it, and we don't find a previous assertion for\n-\t     it, create a new assertion location node for OP.  */\n-\t  if (infer_value_range (stmt, op, &comp_code, &value))\n-\t    {\n-\t      /* If we are able to infer a nonzero value range for OP,\n-\t\t then walk backwards through the use-def chain to see if OP\n-\t\t was set via a typecast.\n-\t\t If so, then we can also infer a nonzero value range\n-\t\t for the operand of the NOP_EXPR.  */\n-\t      if (comp_code == NE_EXPR && integer_zerop (value))\n-\t\t{\n-\t\t  tree t = op;\n-\t\t  gimple *def_stmt = SSA_NAME_DEF_STMT (t);\n-\t\t  while (is_gimple_assign (def_stmt)\n-\t\t\t && CONVERT_EXPR_CODE_P\n-\t\t\t      (gimple_assign_rhs_code (def_stmt))\n-\t\t\t && TREE_CODE\n-\t\t\t      (gimple_assign_rhs1 (def_stmt)) == SSA_NAME\n-\t\t\t && POINTER_TYPE_P\n-\t\t\t      (TREE_TYPE (gimple_assign_rhs1 (def_stmt))))\n-\t\t    {\n-\t\t      t = gimple_assign_rhs1 (def_stmt);\n-\t\t      def_stmt = SSA_NAME_DEF_STMT (t);\n-\n-\t\t      /* Add VR when (T COMP_CODE value) condition is\n-\t\t\t true.  */\n-\t\t      value_range *op_range\n-\t\t\t= try_find_new_range (t, t, comp_code, value);\n-\t\t      if (op_range)\n-\t\t\tpush_value_range (t, op_range);\n-\t\t    }\n-\t\t}\n-\t      /* Add VR when (OP COMP_CODE value) condition is true.  */\n-\t      value_range *op_range = try_find_new_range (op, op,\n-\t\t\t\t\t\t\t  comp_code, value);\n-\t      if (op_range)\n-\t\tpush_value_range (op, op_range);\n \t    }\n \t}\n \n@@ -443,6 +484,8 @@ evrp_dom_walker::before_dom_children (basic_block bb)\n     }\n \n   /* Visit BB successor PHI nodes and replace PHI args.  */\n+  edge e;\n+  edge_iterator ei;\n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n       for (gphi_iterator gpi = gsi_start_phis (e->dest);"}]}