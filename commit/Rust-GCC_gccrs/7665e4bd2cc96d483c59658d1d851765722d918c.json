{"sha": "7665e4bd2cc96d483c59658d1d851765722d918c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY2NWU0YmQyY2M5NmQ0ODNjNTk2NThkMWQ4NTE3NjU3MjJkOTE4Yw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-23T06:11:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-23T06:11:20Z"}, "message": "[multiple changes]\n\n2010-06-23  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Properly handle\n\tchecking returns in generic case.\n\t(Check_Missing_Return): New procedure.\n\n2010-06-23  Robert Dewar  <dewar@adacore.com>\n\n\t* bindgen.adb, switch-b.adb: Minor reformatting.\n\n2010-06-23  Javier Miranda  <miranda@adacore.com>\n\n\t* frontend.adb (Frontend): Add call to initialize the new package\n\tSCIL_LL.\n\t* exp_ch7.adb (Wrap_Transient_Expression): Remove call to\n\tAdjust_SCIL_Node.\n\t(Wrap_Transient_Statement): Remove call to Adjust_SCIL_Node.\n\t* sem_ch5.adb (Analyze_Iteration_Scheme.Process_Bounds): Remove call to\n\tAdjust_SCIL_Node.\n\t* exp_util.adb (Insert_Actions): Remove code for\n\tN_SCIL_Dispatch_Table_Object_Init and N_SCIL_Tag_Init nodes.\n\t(Remove_Side_Effects): Remove calls to Adjust_SCIL_Node.\n\t* sinfo.adb (SCIL_Entity, SCIL_Tag_Value): Remove checks on\n\tN_SCIL_Tag_Init and N_SCIL_Dispatch_Table_Object_Init in the assertion.\n\t(SCIL_Related_Node, Set_SCIL_Related_Node): Removed.\n\t* sinfo.ads (SCIL_Related_Node): Field removed.\n\t(N_SCIL_Dispatch_Table_Object_Init): Node removed.\n\t(N_SCIL_Tag_Init): Node removed.\n\t* sem_scil.ads, sem_scil.adb (Adjust_SCIL_Node): Removed.\n\t(Check_SCIL_Node): New implementation.\n\t(Find_SCIL_Node): Removed.\n\t* sem.adb (Analyze): Remove management of\n\tN_SCIL_Dispatch_Table_Object_Init and N_SCIL_Tag_Init nodes.\n\t* sem_util.adb (Insert_Explicit_Dereference): Remove call to\n\tAdjust_SCIL_Node.\n\t* exp_ch4.adb (Expand_N_In): Code cleanup: remove call to\n\tSet_SCIL_Related_Node and avoid adding the SCIL node before the\n\treferenced node using Insert_Action because this is not longer required.\n\t(Expand_Short_Circuit_Operator): Remove call to SCIL node.\n\t* exp_ch6.adb (Expand_Call): Remove call to Adjust_SCIL_Node.\n\t* sem_ch4.adb (Analyze_Type_Conversion): Remove call to Adjust_SCIL_Node\n\t* exp_disp.adb (Expand_Dispatching_Call): Minor code reorganization\n\tbecause we no longer require to generate the SCIL node before the call.\n\t(Make_DT): Remove generation of SCI_Dispatch_Table_Object_Init node.\n\tRemove calls to Set_SCIL_Related_Node and avoid adding the SCIL\n\tnodes before the referenced node using Insert_Action because this\n\tis not longer required.\n\t* atree.adb (Allocate_Initialize_Node, Replace, Rewrite): Add call to\n\tupdate the SCIL_Node field.\n\t* sprint.adb (Sprint_Node_Actual): Remove code for\n\tN_SCIL_Dispatch_Table_Object_Init and N_SCIL_Tag_Init nodes.\n\t* treepr.adb (Print_Node): Print the SCIL node field (if available).\n\t* exp_ch3.adb (Build_Init_Procedure): Remove generation of\n\tSCIL_Tag_Init nodes.\n\t* scil_ll.ads, scil_ll.adb: New files.\n\nFrom-SVN: r161244", "tree": {"sha": "a113ff1fa79d32ab0316b4d56173faae6ce7c95a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a113ff1fa79d32ab0316b4d56173faae6ce7c95a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7665e4bd2cc96d483c59658d1d851765722d918c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7665e4bd2cc96d483c59658d1d851765722d918c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7665e4bd2cc96d483c59658d1d851765722d918c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7665e4bd2cc96d483c59658d1d851765722d918c/comments", "author": null, "committer": null, "parents": [{"sha": "5b9c3fc489788e131d89749e99c88d31bdae418f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b9c3fc489788e131d89749e99c88d31bdae418f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b9c3fc489788e131d89749e99c88d31bdae418f"}], "stats": {"total": 3081, "additions": 1317, "deletions": 1764}, "files": [{"sha": "39c2dad2d7c0d6641db9cd5498abc22d5b7466dd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -1,3 +1,61 @@\n+2010-06-23  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_ch6.adb (Analyze_Subprogram_Body_Helper): Properly handle\n+\tchecking returns in generic case.\n+\t(Check_Missing_Return): New procedure.\n+\n+2010-06-23  Robert Dewar  <dewar@adacore.com>\n+\n+\t* bindgen.adb, switch-b.adb: Minor reformatting.\n+\n+2010-06-23  Javier Miranda  <miranda@adacore.com>\n+\n+\t* frontend.adb (Frontend): Add call to initialize the new package\n+\tSCIL_LL.\n+\t* exp_ch7.adb (Wrap_Transient_Expression): Remove call to\n+\tAdjust_SCIL_Node.\n+\t(Wrap_Transient_Statement): Remove call to Adjust_SCIL_Node.\n+\t* sem_ch5.adb (Analyze_Iteration_Scheme.Process_Bounds): Remove call to\n+\tAdjust_SCIL_Node.\n+\t* exp_util.adb (Insert_Actions): Remove code for\n+\tN_SCIL_Dispatch_Table_Object_Init and N_SCIL_Tag_Init nodes.\n+\t(Remove_Side_Effects): Remove calls to Adjust_SCIL_Node.\n+\t* sinfo.adb (SCIL_Entity, SCIL_Tag_Value): Remove checks on\n+\tN_SCIL_Tag_Init and N_SCIL_Dispatch_Table_Object_Init in the assertion.\n+\t(SCIL_Related_Node, Set_SCIL_Related_Node): Removed.\n+\t* sinfo.ads (SCIL_Related_Node): Field removed.\n+\t(N_SCIL_Dispatch_Table_Object_Init): Node removed.\n+\t(N_SCIL_Tag_Init): Node removed.\n+\t* sem_scil.ads, sem_scil.adb (Adjust_SCIL_Node): Removed.\n+\t(Check_SCIL_Node): New implementation.\n+\t(Find_SCIL_Node): Removed.\n+\t* sem.adb (Analyze): Remove management of\n+\tN_SCIL_Dispatch_Table_Object_Init and N_SCIL_Tag_Init nodes.\n+\t* sem_util.adb (Insert_Explicit_Dereference): Remove call to\n+\tAdjust_SCIL_Node.\n+\t* exp_ch4.adb (Expand_N_In): Code cleanup: remove call to\n+\tSet_SCIL_Related_Node and avoid adding the SCIL node before the\n+\treferenced node using Insert_Action because this is not longer required.\n+\t(Expand_Short_Circuit_Operator): Remove call to SCIL node.\n+\t* exp_ch6.adb (Expand_Call): Remove call to Adjust_SCIL_Node.\n+\t* sem_ch4.adb (Analyze_Type_Conversion): Remove call to Adjust_SCIL_Node\n+\t* exp_disp.adb (Expand_Dispatching_Call): Minor code reorganization\n+\tbecause we no longer require to generate the SCIL node before the call.\n+\t(Make_DT): Remove generation of SCI_Dispatch_Table_Object_Init node.\n+\tRemove calls to Set_SCIL_Related_Node and avoid adding the SCIL\n+\tnodes before the referenced node using Insert_Action because this\n+\tis not longer required.\n+\t* atree.adb (Allocate_Initialize_Node, Replace, Rewrite): Add call to\n+\tupdate the SCIL_Node field.\n+\t* sprint.adb (Sprint_Node_Actual): Remove code for\n+\tN_SCIL_Dispatch_Table_Object_Init and N_SCIL_Tag_Init nodes.\n+\t* treepr.adb (Print_Node): Print the SCIL node field (if available).\n+\t* exp_ch3.adb (Build_Init_Procedure): Remove generation of\n+\tSCIL_Tag_Init nodes.\n+\t* scil_ll.ads, scil_ll.adb: New files.\n+\t* gcc-interface/Makefile.in, gcc-interface/Make-lang.in: Update\n+\tdependencies.\n+\n 2010-06-23  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch6.adb: Minor reformatting."}, {"sha": "c0c5bd8dde9f116bf7b70c3dfa4928460a807610", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -38,8 +38,10 @@ pragma Style_Checks (All_Checks);\n \n with Debug;   use Debug;\n with Nlists;  use Nlists;\n+with Opt;     use Opt;\n with Output;  use Output;\n with Sinput;  use Sinput;\n+with SCIL_LL; use SCIL_LL;\n with Tree_IO; use Tree_IO;\n \n package body Atree is\n@@ -531,6 +533,13 @@ package body Atree is\n \n       Orig_Nodes.Set_Last (Nodes.Last);\n       Allocate_List_Tables (Nodes.Last);\n+\n+      --  Update the SCIL_Node field (if available)\n+\n+      if Generate_SCIL then\n+         Set_SCIL_Node (New_Id, Get_SCIL_Node (Src));\n+      end if;\n+\n       return New_Id;\n    end Allocate_Initialize_Node;\n \n@@ -1570,6 +1579,12 @@ package body Atree is\n       --  to Rewrite if there were an intention to save the original node.\n \n       Orig_Nodes.Table (Old_Node) := Old_Node;\n+\n+      --  Update the SCIL_Node field (if available)\n+\n+      if Generate_SCIL then\n+         Set_SCIL_Node (Old_Node, Get_SCIL_Node (New_Node));\n+      end if;\n    end Replace;\n \n    -------------\n@@ -1628,6 +1643,12 @@ package body Atree is\n       end if;\n \n       Fix_Parents (Ref_Node => New_Node, Fix_Node => Old_Node);\n+\n+      --  Update the SCIL_Node field (if available)\n+\n+      if Generate_SCIL then\n+         Set_SCIL_Node (Old_Node, Get_SCIL_Node (New_Node));\n+      end if;\n    end Rewrite;\n \n    -------------------------"}, {"sha": "3d1201617895027b23947a6a4e490a1e1f51e696", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -811,7 +811,6 @@ package body Bindgen is\n                Write_Statement_Buffer;\n             end if;\n          end if;\n-\n       end if;\n \n       --  Generate call to set Initialize_Scalar values if active"}, {"sha": "e3b48d4ea274a310d2e71c1513f89b95159d9cf8", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -2331,22 +2331,6 @@ package body Exp_Ch3 is\n                   New_Reference_To\n                     (Node (First_Elmt (Access_Disp_Table (Rec_Type))), Loc)));\n \n-            --  Generate the SCIL node associated with the initialization of\n-            --  the tag component.\n-\n-            if Generate_SCIL then\n-               declare\n-                  New_Node : Node_Id;\n-\n-               begin\n-                  New_Node :=\n-                    Make_SCIL_Tag_Init (Sloc (First (Init_Tags_List)));\n-                  Set_SCIL_Related_Node (New_Node, First (Init_Tags_List));\n-                  Set_SCIL_Entity (New_Node, Rec_Type);\n-                  Prepend_To (Init_Tags_List, New_Node);\n-               end;\n-            end if;\n-\n             --  Ada 2005 (AI-251): Initialize the secondary tags components\n             --  located at fixed positions (tags whose position depends on\n             --  variable size components are initialized later ---see below)."}, {"sha": "49e02c3633a38a151f450a9ed6cd47d38d48a5ba", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -59,13 +59,13 @@ with Sem_Ch8;  use Sem_Ch8;\n with Sem_Ch13; use Sem_Ch13;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n-with Sem_SCIL; use Sem_SCIL;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n+with SCIL_LL;  use SCIL_LL;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n@@ -4627,8 +4627,7 @@ package body Exp_Ch4 is\n                   if Generate_SCIL\n                     and then Present (SCIL_Node)\n                   then\n-                     Set_SCIL_Related_Node (SCIL_Node, N);\n-                     Insert_Action (N, SCIL_Node);\n+                     Set_SCIL_Node (N, SCIL_Node);\n                   end if;\n                end if;\n \n@@ -8970,7 +8969,6 @@ package body Exp_Ch4 is\n    procedure Expand_Short_Circuit_Operator (N : Node_Id) is\n       Loc     : constant Source_Ptr := Sloc (N);\n       Typ     : constant Entity_Id  := Etype (N);\n-      Kind    : constant Node_Kind  := Nkind (N);\n       Left    : constant Node_Id    := Left_Opnd (N);\n       Right   : constant Node_Id    := Right_Opnd (N);\n       LocR    : constant Source_Ptr := Sloc (Right);\n@@ -9126,18 +9124,6 @@ package body Exp_Ch4 is\n             Analyze_And_Resolve (Right, Standard_Boolean);\n          end if;\n \n-         --  Special processing necessary for SCIL generation for AND THEN\n-         --  with a function call as the right operand.\n-\n-         --  What is this about, and is it needed for both cases above???\n-\n-         if Generate_SCIL\n-           and then Kind = N_And_Then\n-           and then Nkind (Right) = N_Function_Call\n-         then\n-            Adjust_SCIL_Node (N, Right);\n-         end if;\n-\n          Adjust_Result_Type (N, Typ);\n          return;\n       end if;"}, {"sha": "9ddb278417c23f07dea5752a337a622cf0f2adc3", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -2768,20 +2768,6 @@ package body Exp_Ch6 is\n                         Rewrite (Actual,\n                           Unchecked_Convert_To (Parent_Typ,\n                             Relocate_Node (Actual)));\n-\n-                        --  If the relocated node is a function call then it\n-                        --  can be part of the expansion of the predefined\n-                        --  equality operator of a tagged type and we may\n-                        --  need to adjust its SCIL dispatching node.\n-\n-                        if Generate_SCIL\n-                          and then Nkind (Actual) /= N_Null\n-                          and then Nkind (Expression (Actual))\n-                                     = N_Function_Call\n-                        then\n-                           Adjust_SCIL_Node (Actual, Expression (Actual));\n-                        end if;\n-\n                         Analyze (Actual);\n                         Resolve (Actual, Parent_Typ);\n                      end if;"}, {"sha": "308021472c2e14705e7f411e4b00463f37f02c17", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -54,7 +54,6 @@ with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch7;  use Sem_Ch7;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Res;  use Sem_Res;\n-with Sem_SCIL; use Sem_SCIL;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Snames;   use Snames;\n@@ -3566,15 +3565,6 @@ package body Exp_Ch7 is\n       Expr : constant Node_Id    := Relocate_Node (N);\n \n    begin\n-      --  If the relocated node is a function call then check if some SCIL\n-      --  node references it and needs readjustment.\n-\n-      if Generate_SCIL\n-        and then Nkind (N) = N_Function_Call\n-      then\n-         Adjust_SCIL_Node (N, Expr);\n-      end if;\n-\n       Insert_Actions (N, New_List (\n         Make_Object_Declaration (Loc,\n           Defining_Identifier => E,\n@@ -3622,15 +3612,6 @@ package body Exp_Ch7 is\n       New_Statement : constant Node_Id := Relocate_Node (N);\n \n    begin\n-      --  If the relocated node is a procedure call then check if some SCIL\n-      --  node references it and needs readjustment.\n-\n-      if Generate_SCIL\n-        and then Nkind (New_Statement) = N_Procedure_Call_Statement\n-      then\n-         Adjust_SCIL_Node (N, New_Statement);\n-      end if;\n-\n       Rewrite (N, Make_Transient_Block (Loc, New_Statement));\n \n       --  With the scope stack back to normal, we can call analyze on the"}, {"sha": "fd8fe7307877cca88a7d3a2acbc2cd1e451c0f2b", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 23, "deletions": 89, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -60,6 +60,7 @@ with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n+with SCIL_LL;  use SCIL_LL;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n \n@@ -578,8 +579,9 @@ package body Exp_Disp is\n \n       --  Local variables\n \n-      New_Node  : Node_Id;\n-      SCIL_Node : Node_Id;\n+      New_Node          : Node_Id;\n+      SCIL_Node         : Node_Id;\n+      SCIL_Related_Node : Node_Id := Call_Node;\n \n    --  Start of processing for Expand_Dispatching_Call\n \n@@ -649,19 +651,6 @@ package body Exp_Disp is\n          Typ := Non_Limited_View (Typ);\n       end if;\n \n-      --  Generate the SCIL node for this dispatching call. The SCIL node for a\n-      --  dispatching call is inserted in the tree before the call is rewriten\n-      --  and expanded because the SCIL node must be found by the SCIL backend\n-      --  BEFORE the expanded nodes associated with the call node are found.\n-\n-      if Generate_SCIL then\n-         SCIL_Node := Make_SCIL_Dispatching_Call (Sloc (Call_Node));\n-         Set_SCIL_Related_Node (SCIL_Node, Call_Node);\n-         Set_SCIL_Entity       (SCIL_Node, Typ);\n-         Set_SCIL_Target_Prim  (SCIL_Node, Subp);\n-         Insert_Action (Call_Node, SCIL_Node);\n-      end if;\n-\n       if not Is_Limited_Type (Typ) then\n          Eq_Prim_Op := Find_Prim_Op (Typ, Name_Op_Eq);\n       end if;\n@@ -841,12 +830,16 @@ package body Exp_Disp is\n       New_Call_Name :=\n         Unchecked_Convert_To (Subp_Ptr_Typ, New_Node);\n \n-      --  Complete decoration of SCIL dispatching node. It must be done after\n-      --  the new call name is built to reference the nodes that will see the\n-      --  SCIL backend (because Build_Get_Prim_Op_Address generates an\n-      --  unchecked type conversion which relocates the controlling tag node).\n+      --  Generate the SCIL node for this dispatching call. Done now because\n+      --  attribute SCIL_Controlling_Tag must be set after the new call name\n+      --  is built to reference the nodes that will see the SCIL backend\n+      --  (because Build_Get_Prim_Op_Address generates an unchecked type\n+      --  conversion which relocates the controlling tag node).\n \n       if Generate_SCIL then\n+         SCIL_Node := Make_SCIL_Dispatching_Call (Sloc (Call_Node));\n+         Set_SCIL_Entity      (SCIL_Node, Typ);\n+         Set_SCIL_Target_Prim (SCIL_Node, Subp);\n \n          --  Common case: the controlling tag is the tag of an object\n          --  (for example, obj.tag)\n@@ -923,15 +916,6 @@ package body Exp_Disp is\n          --  we generate: x.tag = y.tag and then x = y\n \n          if Subp = Eq_Prim_Op then\n-\n-            --  Adjust the node referenced by the SCIL node to skip the tags\n-            --  comparison because it is the information needed by the SCIL\n-            --  backend to process this dispatching call\n-\n-            if Generate_SCIL then\n-               Set_SCIL_Related_Node (SCIL_Node, New_Call);\n-            end if;\n-\n             Param := First_Actual (Call_Node);\n             New_Call :=\n               Make_And_Then (Loc,\n@@ -953,6 +937,8 @@ package body Exp_Disp is\n                              New_Reference_To\n                                (First_Tag_Component (Typ), Loc))),\n                 Right_Opnd => New_Call);\n+\n+            SCIL_Related_Node := Right_Opnd (New_Call);\n          end if;\n \n       else\n@@ -968,6 +954,12 @@ package body Exp_Disp is\n \n       Rewrite (Call_Node, New_Call);\n \n+      --  Associate the SCIL node of this dispatching call\n+\n+      if Generate_SCIL then\n+         Set_SCIL_Node (SCIL_Related_Node, SCIL_Node);\n+      end if;\n+\n       --  Suppress all checks during the analysis of the expanded code\n       --  to avoid the generation of spurious warnings under ZFP run-time.\n \n@@ -4384,17 +4376,6 @@ package body Exp_Disp is\n                   New_Reference_To\n                     (RTE (RE_No_Dispatch_Table_Wrapper), Loc)));\n \n-            --  Generate a SCIL node for the previous object declaration\n-            --  because it has a null dispatch table.\n-\n-            if Generate_SCIL then\n-               New_Node :=\n-                 Make_SCIL_Dispatch_Table_Object_Init (Sloc (Last (Result)));\n-               Set_SCIL_Related_Node (New_Node, Last (Result));\n-               Set_SCIL_Entity (New_Node, Typ);\n-               Insert_Before (Last (Result), New_Node);\n-            end if;\n-\n             Append_To (Result,\n               Make_Attribute_Definition_Clause (Loc,\n                 Name       => New_Reference_To (DT, Loc),\n@@ -4427,9 +4408,8 @@ package body Exp_Disp is\n             if Generate_SCIL then\n                New_Node :=\n                  Make_SCIL_Dispatch_Table_Tag_Init (Sloc (Last (Result)));\n-               Set_SCIL_Related_Node (New_Node, Last (Result));\n                Set_SCIL_Entity (New_Node, Typ);\n-               Insert_Before (Last (Result), New_Node);\n+               Set_SCIL_Node (Last (Result), New_Node);\n             end if;\n \n          --  Generate:\n@@ -4461,17 +4441,6 @@ package body Exp_Disp is\n                     Constraint => Make_Index_Or_Discriminant_Constraint (Loc,\n                                     Constraints => DT_Constr_List))));\n \n-            --  Generate the SCIL node for the previous object declaration\n-            --  because it contains a dispatch table.\n-\n-            if Generate_SCIL then\n-               New_Node :=\n-                 Make_SCIL_Dispatch_Table_Object_Init (Sloc (Last (Result)));\n-               Set_SCIL_Related_Node (New_Node, Last (Result));\n-               Set_SCIL_Entity (New_Node, Typ);\n-               Insert_Before (Last (Result), New_Node);\n-            end if;\n-\n             Append_To (Result,\n               Make_Attribute_Definition_Clause (Loc,\n                 Name       => New_Reference_To (DT, Loc),\n@@ -4504,9 +4473,8 @@ package body Exp_Disp is\n             if Generate_SCIL then\n                New_Node :=\n                  Make_SCIL_Dispatch_Table_Tag_Init (Sloc (Last (Result)));\n-               Set_SCIL_Related_Node (New_Node, Last (Result));\n                Set_SCIL_Entity (New_Node, Typ);\n-               Insert_Before (Last (Result), New_Node);\n+               Set_SCIL_Node (Last (Result), New_Node);\n             end if;\n \n             Append_To (Result,\n@@ -5274,17 +5242,6 @@ package body Exp_Disp is\n                 Expression => Make_Aggregate (Loc,\n                   Expressions => DT_Aggr_List)));\n \n-            --  Generate the SCIL node for the previous object declaration\n-            --  because it has a null dispatch table.\n-\n-            if Generate_SCIL then\n-               New_Node :=\n-                 Make_SCIL_Dispatch_Table_Object_Init (Sloc (Last (Result)));\n-               Set_SCIL_Related_Node (New_Node, Last (Result));\n-               Set_SCIL_Entity (New_Node, Typ);\n-               Insert_Before (Last (Result), New_Node);\n-            end if;\n-\n             Append_To (Result,\n               Make_Attribute_Definition_Clause (Loc,\n                 Name       => New_Reference_To (DT, Loc),\n@@ -5585,17 +5542,6 @@ package body Exp_Disp is\n                 Expression => Make_Aggregate (Loc,\n                   Expressions => DT_Aggr_List)));\n \n-            --  Generate the SCIL node for the previous object declaration\n-            --  because it contains a dispatch table.\n-\n-            if Generate_SCIL then\n-               New_Node :=\n-                 Make_SCIL_Dispatch_Table_Object_Init (Sloc (Last (Result)));\n-               Set_SCIL_Related_Node (New_Node, Last (Result));\n-               Set_SCIL_Entity (New_Node, Typ);\n-               Insert_Before (Last (Result), New_Node);\n-            end if;\n-\n             Append_To (Result,\n               Make_Attribute_Definition_Clause (Loc,\n                 Name       => New_Reference_To (DT, Loc),\n@@ -6294,9 +6240,8 @@ package body Exp_Disp is\n             if Generate_SCIL then\n                New_Node :=\n                  Make_SCIL_Dispatch_Table_Tag_Init (Sloc (Last (Result)));\n-               Set_SCIL_Related_Node (New_Node, Last (Result));\n                Set_SCIL_Entity (New_Node, Typ);\n-               Insert_Before (Last (Result), New_Node);\n+               Set_SCIL_Node (Last (Result), New_Node);\n             end if;\n \n             Append_To (Result,\n@@ -6333,17 +6278,6 @@ package body Exp_Disp is\n                           New_Occurrence_Of\n                             (RTE_Record_Component (RE_NDT_Prims_Ptr), Loc)),\n                       Attribute_Name => Name_Address))));\n-\n-            --  Generate the SCIL node for the previous object declaration\n-            --  because it has a tag initialization.\n-\n-            if Generate_SCIL then\n-               New_Node :=\n-                 Make_SCIL_Dispatch_Table_Object_Init (Sloc (Last (Result)));\n-               Set_SCIL_Related_Node (New_Node, Last (Result));\n-               Set_SCIL_Entity (New_Node, Typ);\n-               Insert_Before (Last (Result), New_Node);\n-            end if;\n          end if;\n \n          Set_Is_True_Constant (DT_Ptr);"}, {"sha": "8d2f46ce1f5a90f110e616445353d1a4c1f84e4c", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -43,7 +43,6 @@ with Rident;   use Rident;\n with Sem;      use Sem;\n with Sem_Aux;  use Sem_Aux;\n with Sem_Ch8;  use Sem_Ch8;\n-with Sem_SCIL; use Sem_SCIL;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Type; use Sem_Type;\n@@ -2812,11 +2811,9 @@ package body Exp_Util is\n                N_Real_Range_Specification               |\n                N_Record_Definition                      |\n                N_Reference                              |\n-               N_SCIL_Dispatch_Table_Object_Init        |\n                N_SCIL_Dispatch_Table_Tag_Init           |\n                N_SCIL_Dispatching_Call                  |\n                N_SCIL_Membership_Test                   |\n-               N_SCIL_Tag_Init                          |\n                N_Selected_Component                     |\n                N_Signed_Integer_Type_Definition         |\n                N_Single_Protected_Declaration           |\n@@ -4718,15 +4715,6 @@ package body Exp_Util is\n              Constant_Present    => True,\n              Expression          => Relocate_Node (Exp));\n \n-         --  Check if the previous node relocation requires readjustment of\n-         --  some SCIL Dispatching node.\n-\n-         if Generate_SCIL\n-           and then Nkind (Exp) = N_Function_Call\n-         then\n-            Adjust_SCIL_Node (Exp, Expression (E));\n-         end if;\n-\n          Set_Assignment_OK (E);\n          Insert_Action (Exp, E);\n \n@@ -4888,15 +4876,6 @@ package body Exp_Util is\n                    Object_Definition   => New_Occurrence_Of (Exp_Type, Loc),\n                    Expression          => Relocate_Node (Exp));\n \n-               --  Check if the previous node relocation requires readjustment\n-               --  of some SCIL Dispatching node.\n-\n-               if Generate_SCIL\n-                 and then Nkind (Exp) = N_Function_Call\n-               then\n-                  Adjust_SCIL_Node (Exp, Expression (Decl));\n-               end if;\n-\n                Insert_Action (Exp, Decl);\n                Set_Etype (Obj, Exp_Type);\n                Rewrite (Exp, New_Occurrence_Of (Obj, Loc));\n@@ -4956,15 +4935,6 @@ package body Exp_Util is\n              Defining_Identifier => Def_Id,\n              Object_Definition   => New_Reference_To (Ref_Type, Loc),\n              Expression          => New_Exp));\n-\n-         --  Check if the previous node relocation requires readjustment\n-         --  of some SCIL Dispatching node.\n-\n-         if Generate_SCIL\n-           and then Nkind (Exp) = N_Function_Call\n-         then\n-            Adjust_SCIL_Node (Exp, Prefix (New_Exp));\n-         end if;\n       end if;\n \n       --  Preserve the Assignment_OK flag in all copies, since at least"}, {"sha": "fb5eb4319f1d16225001e4e39c115fd0530a6215", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -60,6 +60,7 @@ with Sem_Warn; use Sem_Warn;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Sinput.L; use Sinput.L;\n+with SCIL_LL;  use SCIL_LL;\n with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Types;    use Types;\n@@ -89,6 +90,10 @@ begin\n    Sem_Warn.Initialize;\n    Prep.Initialize;\n \n+   if Generate_SCIL then\n+      SCIL_LL.Initialize;\n+   end if;\n+\n    --  Create package Standard\n \n    CStand.Create_Standard;"}, {"sha": "8518a08e1eedef843df9e180aaa6ba2f19776403", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 833, "deletions": 803, "changes": 1636, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=7665e4bd2cc96d483c59658d1d851765722d918c"}, {"sha": "87d9dc73d0e960140bc5f98363717ccede1980af", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -309,7 +309,7 @@ GNATMAKE_OBJS = a-except.o ali.o ali-util.o s-casuti.o \\\n  scans.o scng.o sdefault.o sfn_scan.o s-purexc.o s-htable.o sinfo.o sinput.o \\\n  sinput-c.o sinput-p.o snames.o stand.o stringt.o styleg.o stylesw.o system.o \\\n  validsw.o switch.o switch-m.o table.o targparm.o tempdir.o tree_io.o types.o \\\n- uintp.o uname.o urealp.o usage.o widechar.o \\\n+ uintp.o uname.o urealp.o usage.o widechar.o scil_ll.o \\\n  $(EXTRA_GNATMAKE_OBJS)\n \n # Convert the target variable into a space separated list of architecture,"}, {"sha": "388abdb288523f376f17bf5dd3ec6d6570cd3dd5", "filename": "gcc/ada/scil_ll.adb", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fscil_ll.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fscil_ll.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscil_ll.adb?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -0,0 +1,130 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              S C I L _ L L                               --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2010, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Alloc; use Alloc;\n+with Atree; use Atree;\n+with Opt;   use Opt;\n+with Sinfo; use Sinfo;\n+with Table;\n+\n+package body SCIL_LL is\n+\n+   function SCIL_Nodes_Table_Size return Pos;\n+   --  Used to initialize the table of SCIL nodes because we do not want\n+   --  to consume memory for this table if it is not required.\n+\n+   ----------------------------\n+   --  SCIL_Nodes_Table_Size --\n+   ----------------------------\n+\n+   function SCIL_Nodes_Table_Size return Pos is\n+   begin\n+      if Generate_SCIL then\n+         return Alloc.Orig_Nodes_Initial;\n+      else\n+         return 1;\n+      end if;\n+   end SCIL_Nodes_Table_Size;\n+\n+   package SCIL_Nodes is new Table.Table (\n+      Table_Component_Type => Node_Id,\n+      Table_Index_Type     => Node_Id'Base,\n+      Table_Low_Bound      => First_Node_Id,\n+      Table_Initial        => SCIL_Nodes_Table_Size,\n+      Table_Increment      => Alloc.Orig_Nodes_Increment,\n+      Table_Name           => \"SCIL_Nodes\");\n+   --  This table records the value of attribute SCIL_Node of all the\n+   --  tree nodes.\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize is\n+   begin\n+      SCIL_Nodes.Init;\n+   end Initialize;\n+\n+   -------------------\n+   -- Get_SCIL_Node --\n+   -------------------\n+\n+   function Get_SCIL_Node (N : Node_Id) return Node_Id is\n+   begin\n+      if Generate_SCIL\n+        and then Present (N)\n+      then\n+         return SCIL_Nodes.Table (N);\n+      else\n+         return Empty;\n+      end if;\n+   end Get_SCIL_Node;\n+\n+   -------------------\n+   -- Set_SCIL_Node --\n+   -------------------\n+\n+   procedure Set_SCIL_Node (N : Node_Id; Value : Node_Id) is\n+   begin\n+      pragma Assert (Generate_SCIL);\n+\n+      if Present (Value) then\n+         case Nkind (Value) is\n+            when N_SCIL_Dispatch_Table_Tag_Init =>\n+               pragma Assert (Nkind (N) = N_Object_Declaration);\n+               null;\n+\n+            when N_SCIL_Dispatching_Call =>\n+               pragma Assert (Nkind_In (N, N_Function_Call,\n+                                           N_Procedure_Call_Statement));\n+               null;\n+\n+            when N_SCIL_Membership_Test =>\n+               pragma Assert (Nkind_In (N, N_Identifier,\n+                                           N_And_Then,\n+                                           N_Or_Else,\n+                                           N_Expression_With_Actions));\n+               null;\n+\n+            when others =>\n+               pragma Assert (False);\n+               raise Program_Error;\n+         end case;\n+      end if;\n+\n+      if Atree.Last_Node_Id > SCIL_Nodes.Last then\n+         SCIL_Nodes.Set_Last (Atree.Last_Node_Id);\n+      end if;\n+\n+      SCIL_Nodes.Set_Item (N, Value);\n+   end Set_SCIL_Node;\n+\n+end SCIL_LL;"}, {"sha": "8265a19df30f2b97e1bc8a18ad952b69347cb4c6", "filename": "gcc/ada/scil_ll.ads", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fscil_ll.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fscil_ll.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscil_ll.ads?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -0,0 +1,48 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                              S C I L _ L L                               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2010, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package extends the tree nodes with a field that is used to reference\n+--  the SCIL node.\n+\n+with Types; use Types;\n+\n+package SCIL_LL is\n+\n+   function Get_SCIL_Node (N : Node_Id) return Node_Id;\n+   --  Read the value of attribute SCIL node\n+\n+   procedure Set_SCIL_Node (N : Node_Id; Value : Node_Id);\n+   --  Set the value of attribute SCIL node\n+\n+   procedure Initialize;\n+   --  Initialize the table of SCIL nodes\n+\n+end SCIL_LL;"}, {"sha": "42adb52a44de4b3511195828adc3ef3b0f742d3a", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -615,11 +615,9 @@ package body Sem is\n          --  analyzed.\n \n          when\n-           N_SCIL_Dispatch_Table_Object_Init        |\n-           N_SCIL_Dispatch_Table_Tag_Init           |\n-           N_SCIL_Dispatching_Call                  |\n-           N_SCIL_Membership_Test                   |\n-           N_SCIL_Tag_Init                          =>\n+           N_SCIL_Dispatch_Table_Tag_Init |\n+           N_SCIL_Dispatching_Call        |\n+           N_SCIL_Membership_Test         =>\n             null;\n \n          --  For the remaining node types, we generate compiler abort, because"}, {"sha": "5ba25952c186b46d1c6efd306fb5c7fb32f5bf37", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -48,7 +48,6 @@ with Sem_Cat;  use Sem_Cat;\n with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n-with Sem_SCIL; use Sem_SCIL;\n with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n with Sem_Eval; use Sem_Eval;\n@@ -4105,15 +4104,6 @@ package body Sem_Ch4 is\n       T    : Entity_Id;\n \n    begin\n-      --  Check if the expression is a function call for which we need to\n-      --  adjust a SCIL dispatching node.\n-\n-      if Generate_SCIL\n-        and then Nkind (Expr) = N_Function_Call\n-      then\n-         Adjust_SCIL_Node (N, Expr);\n-      end if;\n-\n       --  If Conversion_OK is set, then the Etype is already set, and the\n       --  only processing required is to analyze the expression. This is\n       --  used to construct certain \"illegal\" conversions which are not"}, {"sha": "6867940a57d342e8e46cdc3be551aac977f897e1", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -46,7 +46,6 @@ with Sem_Disp; use Sem_Disp;\n with Sem_Elab; use Sem_Elab;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n-with Sem_SCIL; use Sem_SCIL;\n with Sem_Type; use Sem_Type;\n with Sem_Util; use Sem_Util;\n with Sem_Warn; use Sem_Warn;\n@@ -1572,15 +1571,6 @@ package body Sem_Ch5 is\n                 Name        => New_Occurrence_Of (Id, Loc),\n                 Expression  => Relocate_Node (Original_Bound));\n \n-            --  If the relocated node is a function call then check if some\n-            --  SCIL node references it and needs readjustment.\n-\n-            if Generate_SCIL\n-              and then Nkind (Original_Bound) = N_Function_Call\n-            then\n-               Adjust_SCIL_Node (Original_Bound, Expression (Assign));\n-            end if;\n-\n             Insert_Before (Parent (N), Assign);\n             Analyze (Assign);\n "}, {"sha": "b09f91e585a4db30ae5d4c6adb09b9de96163739", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 56, "deletions": 41, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -515,10 +515,10 @@ package body Sem_Ch6 is\n       -------------------------------------\n \n       procedure Check_Return_Subtype_Indication (Obj_Decl : Node_Id) is\n-         Return_Obj  : constant Node_Id   := Defining_Identifier (Obj_Decl);\n-         R_Stm_Type  : constant Entity_Id := Etype (Return_Obj);\n-         --  Subtype given in the extended return statement;\n-         --  this must match R_Type.\n+         Return_Obj : constant Node_Id   := Defining_Identifier (Obj_Decl);\n+\n+         R_Stm_Type : constant Entity_Id := Etype (Return_Obj);\n+         --  Subtype given in the extended return statement (must match R_Type)\n \n          Subtype_Ind : constant Node_Id :=\n                          Object_Definition (Original_Node (Obj_Decl));\n@@ -543,7 +543,7 @@ package body Sem_Ch6 is\n          --  True if type of the return object is an anonymous access type\n \n       begin\n-         --  First, avoid cascade errors:\n+         --  First, avoid cascaded errors\n \n          if Error_Posted (Obj_Decl) or else Error_Posted (Subtype_Ind) then\n             return;\n@@ -1430,7 +1430,6 @@ package body Sem_Ch6 is\n       Prev_Id      : constant Entity_Id  := Current_Entity_In_Scope (Body_Id);\n       Conformant   : Boolean;\n       HSS          : Node_Id;\n-      Missing_Ret  : Boolean;\n       P_Ent        : Entity_Id;\n       Prot_Typ     : Entity_Id := Empty;\n       Spec_Id      : Entity_Id;\n@@ -1472,6 +1471,10 @@ package body Sem_Ch6 is\n       --  If pragma does not appear after the body, check whether there is\n       --  an inline pragma before any local declarations.\n \n+      procedure Check_Missing_Return;\n+      --  Checks for a function with a no return statements, and also performs\n+      --  the warning checks implemented by Check_Returns.\n+\n       function Disambiguate_Spec return Entity_Id;\n       --  When a primitive is declared between the private view and the full\n       --  view of a concurrent type which implements an interface, a special\n@@ -1664,6 +1667,46 @@ package body Sem_Ch6 is\n          end if;\n       end Check_Inline_Pragma;\n \n+      --------------------------\n+      -- Check_Missing_Return --\n+      --------------------------\n+\n+      procedure Check_Missing_Return is\n+         Id          : Entity_Id;\n+         Missing_Ret : Boolean;\n+\n+      begin\n+         if Nkind (Body_Spec) = N_Function_Specification then\n+            if Present (Spec_Id) then\n+               Id := Spec_Id;\n+            else\n+               Id := Body_Id;\n+            end if;\n+\n+            if Return_Present (Id) then\n+               Check_Returns (HSS, 'F', Missing_Ret);\n+\n+               if Missing_Ret then\n+                  Set_Has_Missing_Return (Id);\n+               end if;\n+\n+            elsif (Is_Generic_Subprogram (Id)\n+                     or else not Is_Machine_Code_Subprogram (Id))\n+              and then not Body_Deleted\n+            then\n+               Error_Msg_N (\"missing RETURN statement in function body\", N);\n+            end if;\n+\n+         --  If procedure with No_Return, check returns\n+\n+         elsif Nkind (Body_Spec) = N_Procedure_Specification\n+           and then Present (Spec_Id)\n+           and then No_Return (Spec_Id)\n+         then\n+               Check_Returns (HSS, 'P', Missing_Ret, Spec_Id);\n+         end if;\n+      end Check_Missing_Return;\n+\n       -----------------------\n       -- Disambiguate_Spec --\n       -----------------------\n@@ -1888,6 +1931,12 @@ package body Sem_Ch6 is\n             Set_Is_Child_Unit       (Body_Id, Is_Child_Unit       (Spec_Id));\n \n             Analyze_Generic_Subprogram_Body (N, Spec_Id);\n+\n+            if Nkind (N) = N_Subprogram_Body then\n+               HSS := Handled_Statement_Sequence (N);\n+               Check_Missing_Return;\n+            end if;\n+\n             return;\n \n          else\n@@ -2426,41 +2475,7 @@ package body Sem_Ch6 is\n          end if;\n       end if;\n \n-      --  If function, check return statements\n-\n-      if Nkind (Body_Spec) = N_Function_Specification then\n-         declare\n-            Id : Entity_Id;\n-\n-         begin\n-            if Present (Spec_Id) then\n-               Id := Spec_Id;\n-            else\n-               Id := Body_Id;\n-            end if;\n-\n-            if Return_Present (Id) then\n-               Check_Returns (HSS, 'F', Missing_Ret);\n-\n-               if Missing_Ret then\n-                  Set_Has_Missing_Return (Id);\n-               end if;\n-\n-            elsif not Is_Machine_Code_Subprogram (Id)\n-              and then not Body_Deleted\n-            then\n-               Error_Msg_N (\"missing RETURN statement in function body\", N);\n-            end if;\n-         end;\n-\n-      --  If procedure with No_Return, check returns\n-\n-      elsif Nkind (Body_Spec) = N_Procedure_Specification\n-        and then Present (Spec_Id)\n-        and then No_Return (Spec_Id)\n-      then\n-         Check_Returns (HSS, 'P', Missing_Ret, Spec_Id);\n-      end if;\n+      Check_Missing_Return;\n \n       --  Now we are going to check for variables that are never modified in\n       --  the body of the procedure. But first we deal with a special case"}, {"sha": "3ab7511663e20c2af029e0921fc0debcb00975ba", "filename": "gcc/ada/sem_scil.adb", "status": "modified", "additions": 114, "deletions": 603, "changes": 717, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fsem_scil.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fsem_scil.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_scil.adb?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -23,659 +23,170 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Einfo;    use Einfo;\n-with Namet;    use Namet;\n-with Nlists;   use Nlists;\n-with Opt;      use Opt;\n-with Rtsfind;  use Rtsfind;\n-with Sem;      use Sem;\n-with Sem_Aux;  use Sem_Aux;\n-with Sem_Util; use Sem_Util;\n-with Sinfo;    use Sinfo;\n-with Snames;   use Snames;\n-with Stand;    use Stand;\n+with Einfo;   use Einfo;\n+with Nlists;  use Nlists;\n+with Rtsfind; use Rtsfind;\n+with Sem_Aux; use Sem_Aux;\n+with Sinfo;   use Sinfo;\n+with Stand;   use Stand;\n+with SCIL_LL; use SCIL_LL;\n \n package body Sem_SCIL is\n \n-   ----------------------\n-   -- Adjust_SCIL_Node --\n-   ----------------------\n-\n-   procedure Adjust_SCIL_Node (Old_Node : Node_Id; New_Node : Node_Id) is\n-      SCIL_Node : Node_Id;\n-\n-   begin\n-      pragma Assert (Generate_SCIL);\n-\n-      --  Check cases in which no action is required. Currently the only SCIL\n-      --  nodes that may require adjustment are those of dispatching calls\n-      --  internally generated by the frontend.\n-\n-      if Comes_From_Source (Old_Node)\n-        or else not\n-          Nkind_In (New_Node, N_Function_Call, N_Procedure_Call_Statement)\n-      then\n-         return;\n-\n-      --  Conditional expression associated with equality operator. Old_Node\n-      --  may be part of the expansion of the predefined equality operator of\n-      --  a tagged type and hence we need to check if it has a SCIL dispatching\n-      --  node that needs adjustment.\n-\n-      elsif Nkind (Old_Node) = N_Conditional_Expression\n-        and then (Nkind (Original_Node (Old_Node)) = N_Op_Eq\n-                    or else\n-                      (Nkind (Original_Node (Old_Node)) = N_Function_Call\n-                        and then Chars (Name (Original_Node (Old_Node))) =\n-                                                                 Name_Op_Eq))\n-      then\n-         null;\n-\n-      --  Type conversions may involve dispatching calls to functions whose\n-      --  associated SCIL dispatching node needs adjustment.\n-\n-      elsif Nkind_In (Old_Node, N_Type_Conversion,\n-                                N_Unchecked_Type_Conversion)\n-      then\n-         null;\n-\n-      --  Relocated subprogram call\n-\n-      elsif Nkind (Old_Node) = Nkind (New_Node)\n-        and then Original_Node (Old_Node) = Original_Node (New_Node)\n-      then\n-         null;\n-\n-      else\n-         return;\n-      end if;\n-\n-      --  Search for the SCIL node and update it (if found)\n-\n-      SCIL_Node := Find_SCIL_Node (Old_Node);\n-\n-      if Present (SCIL_Node) then\n-         Set_SCIL_Related_Node (SCIL_Node, New_Node);\n-      end if;\n-   end Adjust_SCIL_Node;\n-\n    ---------------------\n    -- Check_SCIL_Node --\n    ---------------------\n \n    function Check_SCIL_Node (N : Node_Id) return Traverse_Result is\n-      Ctrl_Tag : Node_Id;\n-      Ctrl_Typ : Entity_Id;\n+      SCIL_Node : constant Node_Id := Get_SCIL_Node (N);\n+      Ctrl_Tag  : Node_Id;\n+      Ctrl_Typ  : Entity_Id;\n \n    begin\n-      if Nkind (N) = N_SCIL_Membership_Test then\n-\n-         --  Check contents of the boolean expression associated with the\n-         --  membership test.\n-\n-         pragma Assert (Nkind (SCIL_Related_Node (N)) = N_Identifier\n-           and then Etype (SCIL_Related_Node (N)) = Standard_Boolean);\n-\n-         --  Check the entity identifier of the associated tagged type (that\n-         --  is, in testing for membership in T'Class, the entity id of the\n-         --  specific type T).\n-\n-         --  Note: When the SCIL node is generated the private and full-view\n-         --    of the tagged types may have been swapped and hence the node\n-         --    referenced by attribute SCIL_Entity may be the private view.\n-         --    Therefore, in order to uniformily locate the full-view we use\n-         --    attribute Underlying_Type.\n-\n-         pragma Assert (Is_Tagged_Type (Underlying_Type (SCIL_Entity (N))));\n-\n-         --  Interface types are unsupported\n-\n-         pragma Assert (not Is_Interface (Underlying_Type (SCIL_Entity (N))));\n-\n-         --  Check the decoration of the expression that denotes the tag value\n-         --  being tested\n-\n-         Ctrl_Tag := SCIL_Tag_Value (N);\n-\n-         case Nkind (Ctrl_Tag) is\n-\n-            --  For class-wide membership tests the SCIL tag value is the tag\n-            --  of the tested object (i.e. Obj.Tag).\n-\n-            when N_Selected_Component =>\n-               pragma Assert (Etype (Ctrl_Tag) = RTE (RE_Tag));\n-               null;\n-\n-            when others =>\n-               pragma Assert (False);\n-               null;\n-         end case;\n-\n-         return Skip;\n+      --  For nodes that do not have SCIL node continue traversing the tree\n \n-      elsif Nkind (N) = N_SCIL_Dispatching_Call then\n-         Ctrl_Tag := SCIL_Controlling_Tag (N);\n-\n-         --  SCIL_Related_Node of SCIL dispatching call nodes MUST reference\n-         --  subprogram calls.\n-\n-         if not Nkind_In (SCIL_Related_Node (N), N_Function_Call,\n-                                                 N_Procedure_Call_Statement)\n-         then\n-            pragma Assert (False);\n-            raise Program_Error;\n-\n-         --  In simple cases the controlling tag is the tag of the controlling\n-         --  argument (i.e. Obj.Tag).\n-\n-         elsif Nkind (Ctrl_Tag) = N_Selected_Component then\n-            Ctrl_Typ := Etype (Ctrl_Tag);\n-\n-            --  Interface types are unsupported\n-\n-            if Is_Interface (Ctrl_Typ)\n-              or else (RTE_Available (RE_Interface_Tag)\n-                         and then Ctrl_Typ = RTE (RE_Interface_Tag))\n-            then\n-               null;\n-\n-            else\n-               pragma Assert (Ctrl_Typ = RTE (RE_Tag));\n-               null;\n-            end if;\n-\n-         --  When the controlling tag of a dispatching call is an identifier\n-         --  the SCIL_Controlling_Tag attribute references the corresponding\n-         --  object or parameter declaration. Interface types are still\n-         --  unsupported.\n-\n-         elsif Nkind_In (Ctrl_Tag, N_Object_Declaration,\n-                                   N_Parameter_Specification)\n-         then\n-            Ctrl_Typ := Etype (Defining_Identifier (Ctrl_Tag));\n-\n-            --  Interface types are unsupported.\n-\n-            if Is_Interface (Ctrl_Typ)\n-              or else (RTE_Available (RE_Interface_Tag)\n-                        and then Ctrl_Typ = RTE (RE_Interface_Tag))\n-              or else (Is_Access_Type (Ctrl_Typ)\n-                        and then\n-                          Is_Interface\n-                            (Available_View\n-                              (Base_Type (Designated_Type (Ctrl_Typ)))))\n-            then\n-               null;\n-\n-            else\n-               pragma Assert\n-                 (Ctrl_Typ = RTE (RE_Tag)\n-                    or else\n-                      (Is_Access_Type (Ctrl_Typ)\n-                        and then Available_View\n-                                  (Base_Type (Designated_Type (Ctrl_Typ))) =\n-                                                                RTE (RE_Tag)));\n-               null;\n-            end if;\n-\n-         --  Interface types are unsupported\n-\n-         elsif Is_Interface (Etype (Ctrl_Tag)) then\n-            null;\n-\n-         else\n-            pragma Assert (False);\n-            raise Program_Error;\n-         end if;\n-\n-         return Skip;\n-\n-      --  Node is not N_SCIL_Dispatching_Call\n-\n-      else\n+      if No (SCIL_Node) then\n          return OK;\n       end if;\n-   end Check_SCIL_Node;\n \n-   --------------------\n-   -- Find_SCIL_Node --\n-   --------------------\n-\n-   function Find_SCIL_Node (Node : Node_Id) return Node_Id is\n-      Found_Node : Node_Id;\n-      --  This variable stores the last node found by the nested subprogram\n-      --  Find_SCIL_Node.\n-\n-      function Find_SCIL_Node (L : List_Id) return Boolean;\n-      --  Searches in list L for a SCIL node associated with a dispatching call\n-      --  whose SCIL_Related_Node is Node. If found returns true and stores the\n-      --  SCIL node in Found_Node; otherwise returns False and sets Found_Node\n-      --  to Empty.\n-\n-      --------------------\n-      -- Find_SCIL_Node --\n-      --------------------\n-\n-      function Find_SCIL_Node (L : List_Id) return Boolean is\n-         N : Node_Id;\n-\n-      begin\n-         N := First (L);\n-         while Present (N) loop\n-            if Nkind (N) in N_SCIL_Node\n-              and then SCIL_Related_Node (N) = Node\n-            then\n-               Found_Node := N;\n-               return True;\n-            end if;\n-\n-            Next (N);\n-         end loop;\n-\n-         Found_Node := Empty;\n-         return False;\n-      end Find_SCIL_Node;\n-\n-      --  Local variables\n+      case Nkind (SCIL_Node) is\n+         when N_SCIL_Dispatch_Table_Tag_Init =>\n+            pragma Assert (Nkind (N) = N_Object_Declaration);\n+            null;\n \n-      P : Node_Id;\n+         when N_SCIL_Dispatching_Call =>\n+            Ctrl_Tag := SCIL_Controlling_Tag (SCIL_Node);\n \n-   --  Start of processing for Find_SCIL_Node\n+            --  Parent of SCIL dispatching call nodes MUST be a subprogram call\n \n-   begin\n-      pragma Assert (Generate_SCIL);\n-\n-      --  Search for the SCIL node in list associated with a transient scope\n-\n-      if Scope_Is_Transient then\n-         declare\n-            SE : Scope_Stack_Entry\n-                   renames Scope_Stack.Table (Scope_Stack.Last);\n-         begin\n-            if SE.Is_Transient\n-              and then Present (SE.Actions_To_Be_Wrapped_Before)\n-              and then Find_SCIL_Node (SE.Actions_To_Be_Wrapped_Before)\n+            if not Nkind_In (N, N_Function_Call,\n+                                N_Procedure_Call_Statement)\n             then\n-               return Found_Node;\n-            end if;\n-         end;\n-      end if;\n+               pragma Assert (False);\n+               raise Program_Error;\n \n-      --  Otherwise climb up the tree searching for the SCIL node analyzing\n-      --  all the lists in which Insert_Actions may have inserted it\n+            --  In simple cases the controlling tag is the tag of the\n+            --  controlling argument (i.e. Obj.Tag).\n \n-      P := Node;\n-      while Present (P) loop\n-         case Nkind (P) is\n+            elsif Nkind (Ctrl_Tag) = N_Selected_Component then\n+               Ctrl_Typ := Etype (Ctrl_Tag);\n \n-            --  Actions associated with AND THEN or OR ELSE\n+               --  Interface types are unsupported\n \n-            when N_Short_Circuit =>\n-               if Present (Actions (P))\n-                 and then Find_SCIL_Node (Actions (P))\n+               if Is_Interface (Ctrl_Typ)\n+                 or else (RTE_Available (RE_Interface_Tag)\n+                            and then Ctrl_Typ = RTE (RE_Interface_Tag))\n                then\n-                  return Found_Node;\n-               end if;\n-\n-            --  Actions of case expressions\n+                  null;\n \n-            when N_Case_Expression_Alternative =>\n-               if Present (Actions (P))\n-                 and then Find_SCIL_Node (Actions (P))\n-               then\n-                  return Found_Node;\n+               else\n+                  pragma Assert (Ctrl_Typ = RTE (RE_Tag));\n+                  null;\n                end if;\n \n-            --  Actions of conditional expressions\n+            --  When the controlling tag of a dispatching call is an identifier\n+            --  the SCIL_Controlling_Tag attribute references the corresponding\n+            --  object or parameter declaration. Interface types are still\n+            --  unsupported.\n \n-            when N_Conditional_Expression =>\n-               if (Present (Then_Actions (P))\n-                    and then Find_SCIL_Node (Actions (P)))\n-                 or else\n-                  (Present (Else_Actions (P))\n-                    and then Find_SCIL_Node (Else_Actions (P)))\n+            elsif Nkind_In (Ctrl_Tag, N_Object_Declaration,\n+                                      N_Parameter_Specification)\n+            then\n+               Ctrl_Typ := Etype (Defining_Identifier (Ctrl_Tag));\n+\n+               --  Interface types are unsupported.\n+\n+               if Is_Interface (Ctrl_Typ)\n+                 or else (RTE_Available (RE_Interface_Tag)\n+                           and then Ctrl_Typ = RTE (RE_Interface_Tag))\n+                 or else (Is_Access_Type (Ctrl_Typ)\n+                           and then\n+                             Is_Interface\n+                               (Available_View\n+                                 (Base_Type (Designated_Type (Ctrl_Typ)))))\n                then\n-                  return Found_Node;\n+                  null;\n+\n+               else\n+                  pragma Assert\n+                    (Ctrl_Typ = RTE (RE_Tag)\n+                       or else\n+                         (Is_Access_Type (Ctrl_Typ)\n+                           and then Available_View\n+                                      (Base_Type (Designated_Type (Ctrl_Typ)))\n+                                        = RTE (RE_Tag)));\n+                  null;\n                end if;\n \n-            --  Actions in handled sequence of statements\n+            --  Interface types are unsupported\n \n-            when\n-               N_Handled_Sequence_Of_Statements =>\n-                  if Find_SCIL_Node (Statements (P)) then\n-                     return Found_Node;\n-                  end if;\n+            elsif Is_Interface (Etype (Ctrl_Tag)) then\n+               null;\n \n-            --  Conditions of while expression or elsif.\n+            else\n+               pragma Assert (False);\n+               raise Program_Error;\n+            end if;\n \n-            when N_Iteration_Scheme |\n-                 N_Elsif_Part\n-            =>\n-               if Present (Condition_Actions (P))\n-                 and then Find_SCIL_Node (Condition_Actions (P))\n-               then\n-                  return Found_Node;\n-               end if;\n+            return Skip;\n \n-            --  Statements, declarations, pragmas, representation clauses\n-\n-            when\n-               --  Statements\n-\n-               N_Procedure_Call_Statement               |\n-               N_Statement_Other_Than_Procedure_Call    |\n-\n-               --  Pragmas\n-\n-               N_Pragma                                 |\n-\n-               --  Representation_Clause\n-\n-               N_At_Clause                              |\n-               N_Attribute_Definition_Clause            |\n-               N_Enumeration_Representation_Clause      |\n-               N_Record_Representation_Clause           |\n-\n-               --  Declarations\n-\n-               N_Abstract_Subprogram_Declaration        |\n-               N_Entry_Body                             |\n-               N_Exception_Declaration                  |\n-               N_Exception_Renaming_Declaration         |\n-               N_Formal_Abstract_Subprogram_Declaration |\n-               N_Formal_Concrete_Subprogram_Declaration |\n-               N_Formal_Object_Declaration              |\n-               N_Formal_Type_Declaration                |\n-               N_Full_Type_Declaration                  |\n-               N_Function_Instantiation                 |\n-               N_Generic_Function_Renaming_Declaration  |\n-               N_Generic_Package_Declaration            |\n-               N_Generic_Package_Renaming_Declaration   |\n-               N_Generic_Procedure_Renaming_Declaration |\n-               N_Generic_Subprogram_Declaration         |\n-               N_Implicit_Label_Declaration             |\n-               N_Incomplete_Type_Declaration            |\n-               N_Number_Declaration                     |\n-               N_Object_Declaration                     |\n-               N_Object_Renaming_Declaration            |\n-               N_Package_Body                           |\n-               N_Package_Body_Stub                      |\n-               N_Package_Declaration                    |\n-               N_Package_Instantiation                  |\n-               N_Package_Renaming_Declaration           |\n-               N_Private_Extension_Declaration          |\n-               N_Private_Type_Declaration               |\n-               N_Procedure_Instantiation                |\n-               N_Protected_Body                         |\n-               N_Protected_Body_Stub                    |\n-               N_Protected_Type_Declaration             |\n-               N_Single_Task_Declaration                |\n-               N_Subprogram_Body                        |\n-               N_Subprogram_Body_Stub                   |\n-               N_Subprogram_Declaration                 |\n-               N_Subprogram_Renaming_Declaration        |\n-               N_Subtype_Declaration                    |\n-               N_Task_Body                              |\n-               N_Task_Body_Stub                         |\n-               N_Task_Type_Declaration                  |\n-\n-               --  Freeze entity behaves like a declaration or statement\n-\n-               N_Freeze_Entity\n-            =>\n-               --  Do not search here if the item is not a list member\n-\n-               if not Is_List_Member (P) then\n-                  null;\n+         when N_SCIL_Membership_Test =>\n \n-               --  Do not search if parent of P is an N_Component_Association\n-               --  node (i.e. we are in the context of an N_Aggregate or\n-               --  N_Extension_Aggregate node). In this case the node should\n-               --  have been added before the entire aggregate.\n+            --  Check contents of the boolean expression associated with the\n+            --  membership test.\n \n-               elsif Nkind (Parent (P)) = N_Component_Association then\n-                  null;\n+            pragma Assert (Nkind_In (N, N_Identifier,\n+                                        N_And_Then,\n+                                        N_Or_Else,\n+                                        N_Expression_With_Actions)\n+              and then Etype (N) = Standard_Boolean);\n \n-               --  Do not search if the parent of P is either an N_Variant\n-               --  node or an N_Record_Definition node. In this case the node\n-               --  should have been added before the entire record.\n+            --  Check the entity identifier of the associated tagged type (that\n+            --  is, in testing for membership in T'Class, the entity id of the\n+            --  specific type T).\n \n-               elsif Nkind (Parent (P)) = N_Variant\n-                 or else Nkind (Parent (P)) = N_Record_Definition\n-               then\n-                  null;\n+            --  Note: When the SCIL node is generated the private and full-view\n+            --    of the tagged types may have been swapped and hence the node\n+            --    referenced by attribute SCIL_Entity may be the private view.\n+            --    Therefore, in order to uniformily locate the full-view we use\n+            --    attribute Underlying_Type.\n \n-               --  Otherwise search it in the list containing this node\n+            pragma Assert\n+              (Is_Tagged_Type (Underlying_Type (SCIL_Entity (SCIL_Node))));\n \n-               elsif Find_SCIL_Node (List_Containing (P)) then\n-                  return Found_Node;\n-               end if;\n+            --  Interface types are unsupported\n \n-            --  A special case, N_Raise_xxx_Error can act either as a statement\n-            --  or a subexpression. We diferentiate them by looking at the\n-            --  Etype. It is set to Standard_Void_Type in the statement case.\n-\n-            when\n-               N_Raise_xxx_Error =>\n-                  if Etype (P) = Standard_Void_Type then\n-                     if Is_List_Member (P)\n-                       and then Find_SCIL_Node (List_Containing (P))\n-                     then\n-                        return Found_Node;\n-                     end if;\n-\n-                  --  In the subexpression case, keep climbing\n-\n-                  else\n-                     null;\n-                  end if;\n-\n-            --  If a component association appears within a loop created for\n-            --  an array aggregate, check if the SCIL node was added to the\n-            --  the list of nodes attached to the association.\n-\n-            when\n-               N_Component_Association =>\n-                  if Nkind (Parent (P)) = N_Aggregate\n-                    and then Present (Loop_Actions (P))\n-                    and then Find_SCIL_Node (Loop_Actions (P))\n-                  then\n-                     return Found_Node;\n-                  end if;\n-\n-            --  Another special case, an attribute denoting a procedure call\n-\n-            when\n-               N_Attribute_Reference =>\n-                  if Is_Procedure_Attribute_Name (Attribute_Name (P))\n-                    and then Find_SCIL_Node (List_Containing (P))\n-                  then\n-                     return Found_Node;\n-\n-                  --  In the subexpression case keep climbing\n-\n-                  else\n-                     null;\n-                  end if;\n-\n-            --  SCIL nodes do not have subtrees and hence they can never be\n-            --  found climbing tree\n-\n-            when\n-               N_SCIL_Dispatch_Table_Object_Init        |\n-               N_SCIL_Dispatch_Table_Tag_Init           |\n-               N_SCIL_Dispatching_Call                  |\n-               N_SCIL_Membership_Test                   |\n-               N_SCIL_Tag_Init\n-            =>\n-               pragma Assert (False);\n-               raise Program_Error;\n+            pragma Assert\n+              (not Is_Interface (Underlying_Type (SCIL_Entity (SCIL_Node))));\n \n-            --  For all other node types, keep climbing tree\n-\n-            when\n-               N_Abortable_Part                         |\n-               N_Accept_Alternative                     |\n-               N_Access_Definition                      |\n-               N_Access_Function_Definition             |\n-               N_Access_Procedure_Definition            |\n-               N_Access_To_Object_Definition            |\n-               N_Aggregate                              |\n-               N_Allocator                              |\n-               N_Case_Expression                        |\n-               N_Case_Statement_Alternative             |\n-               N_Character_Literal                      |\n-               N_Compilation_Unit                       |\n-               N_Compilation_Unit_Aux                   |\n-               N_Component_Clause                       |\n-               N_Component_Declaration                  |\n-               N_Component_Definition                   |\n-               N_Component_List                         |\n-               N_Constrained_Array_Definition           |\n-               N_Decimal_Fixed_Point_Definition         |\n-               N_Defining_Character_Literal             |\n-               N_Defining_Identifier                    |\n-               N_Defining_Operator_Symbol               |\n-               N_Defining_Program_Unit_Name             |\n-               N_Delay_Alternative                      |\n-               N_Delta_Constraint                       |\n-               N_Derived_Type_Definition                |\n-               N_Designator                             |\n-               N_Digits_Constraint                      |\n-               N_Discriminant_Association               |\n-               N_Discriminant_Specification             |\n-               N_Empty                                  |\n-               N_Entry_Body_Formal_Part                 |\n-               N_Entry_Call_Alternative                 |\n-               N_Entry_Declaration                      |\n-               N_Entry_Index_Specification              |\n-               N_Enumeration_Type_Definition            |\n-               N_Error                                  |\n-               N_Exception_Handler                      |\n-               N_Expanded_Name                          |\n-               N_Explicit_Dereference                   |\n-               N_Expression_With_Actions                |\n-               N_Extension_Aggregate                    |\n-               N_Floating_Point_Definition              |\n-               N_Formal_Decimal_Fixed_Point_Definition  |\n-               N_Formal_Derived_Type_Definition         |\n-               N_Formal_Discrete_Type_Definition        |\n-               N_Formal_Floating_Point_Definition       |\n-               N_Formal_Modular_Type_Definition         |\n-               N_Formal_Ordinary_Fixed_Point_Definition |\n-               N_Formal_Package_Declaration             |\n-               N_Formal_Private_Type_Definition         |\n-               N_Formal_Signed_Integer_Type_Definition  |\n-               N_Function_Call                          |\n-               N_Function_Specification                 |\n-               N_Generic_Association                    |\n-               N_Identifier                             |\n-               N_In                                     |\n-               N_Index_Or_Discriminant_Constraint       |\n-               N_Indexed_Component                      |\n-               N_Integer_Literal                        |\n-               N_Itype_Reference                        |\n-               N_Label                                  |\n-               N_Loop_Parameter_Specification           |\n-               N_Mod_Clause                             |\n-               N_Modular_Type_Definition                |\n-               N_Not_In                                 |\n-               N_Null                                   |\n-               N_Op_Abs                                 |\n-               N_Op_Add                                 |\n-               N_Op_And                                 |\n-               N_Op_Concat                              |\n-               N_Op_Divide                              |\n-               N_Op_Eq                                  |\n-               N_Op_Expon                               |\n-               N_Op_Ge                                  |\n-               N_Op_Gt                                  |\n-               N_Op_Le                                  |\n-               N_Op_Lt                                  |\n-               N_Op_Minus                               |\n-               N_Op_Mod                                 |\n-               N_Op_Multiply                            |\n-               N_Op_Ne                                  |\n-               N_Op_Not                                 |\n-               N_Op_Or                                  |\n-               N_Op_Plus                                |\n-               N_Op_Rem                                 |\n-               N_Op_Rotate_Left                         |\n-               N_Op_Rotate_Right                        |\n-               N_Op_Shift_Left                          |\n-               N_Op_Shift_Right                         |\n-               N_Op_Shift_Right_Arithmetic              |\n-               N_Op_Subtract                            |\n-               N_Op_Xor                                 |\n-               N_Operator_Symbol                        |\n-               N_Ordinary_Fixed_Point_Definition        |\n-               N_Others_Choice                          |\n-               N_Package_Specification                  |\n-               N_Parameter_Association                  |\n-               N_Parameter_Specification                |\n-               N_Pop_Constraint_Error_Label             |\n-               N_Pop_Program_Error_Label                |\n-               N_Pop_Storage_Error_Label                |\n-               N_Pragma_Argument_Association            |\n-               N_Procedure_Specification                |\n-               N_Protected_Definition                   |\n-               N_Push_Constraint_Error_Label            |\n-               N_Push_Program_Error_Label               |\n-               N_Push_Storage_Error_Label               |\n-               N_Qualified_Expression                   |\n-               N_Range                                  |\n-               N_Range_Constraint                       |\n-               N_Real_Literal                           |\n-               N_Real_Range_Specification               |\n-               N_Record_Definition                      |\n-               N_Reference                              |\n-               N_Selected_Component                     |\n-               N_Signed_Integer_Type_Definition         |\n-               N_Single_Protected_Declaration           |\n-               N_Slice                                  |\n-               N_String_Literal                         |\n-               N_Subprogram_Info                        |\n-               N_Subtype_Indication                     |\n-               N_Subunit                                |\n-               N_Task_Definition                        |\n-               N_Terminate_Alternative                  |\n-               N_Triggering_Alternative                 |\n-               N_Type_Conversion                        |\n-               N_Unchecked_Expression                   |\n-               N_Unchecked_Type_Conversion              |\n-               N_Unconstrained_Array_Definition         |\n-               N_Unused_At_End                          |\n-               N_Unused_At_Start                        |\n-               N_Use_Package_Clause                     |\n-               N_Use_Type_Clause                        |\n-               N_Variant                                |\n-               N_Variant_Part                           |\n-               N_Validate_Unchecked_Conversion          |\n-               N_With_Clause\n-            =>\n-               null;\n+            --  Check the decoration of the expression that denotes the tag\n+            --  value being tested\n \n-         end case;\n+            Ctrl_Tag := SCIL_Tag_Value (SCIL_Node);\n \n-         --  If we fall through above tests keep climbing tree\n+            case Nkind (Ctrl_Tag) is\n \n-         if Nkind (Parent (P)) = N_Subunit then\n+               --  For class-wide membership tests the SCIL tag value is the\n+               --  tag of the tested object (i.e. Obj.Tag).\n \n-            --  This is the proper body corresponding to a stub. Insertion done\n-            --  at the point of the stub, which is in the declarative part of\n-            --  the parent unit.\n+               when N_Selected_Component =>\n+                  pragma Assert (Etype (Ctrl_Tag) = RTE (RE_Tag));\n+                  null;\n \n-            P := Corresponding_Stub (Parent (P));\n+               when others =>\n+                  pragma Assert (False);\n+                  null;\n+            end case;\n \n-         else\n-            P := Parent (P);\n-         end if;\n-      end loop;\n+            return Skip;\n \n-      --  SCIL node not found\n+         when others =>\n+            pragma Assert (False);\n+            raise Program_Error;\n+      end case;\n \n-      return Empty;\n-   end Find_SCIL_Node;\n+      return Skip;\n+   end Check_SCIL_Node;\n \n    -------------------------\n    -- First_Non_SCIL_Node --"}, {"sha": "1a6e45caacb492cea9602cef40ecd1b150398e11", "filename": "gcc/ada/sem_scil.ads", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fsem_scil.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fsem_scil.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_scil.ads?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -4,9 +4,9 @@\n --                                                                          --\n --                             S E M _ S C I L                              --\n --                                                                          --\n---                                 B o d y                                  --\n+--                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2009, Free Software Foundation, Inc.           --\n+--          Copyright (C) 2009-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,21 +33,13 @@ package Sem_SCIL is\n \n    --  Here would be a good place to document what SCIL is all about ???\n \n-   procedure Adjust_SCIL_Node (Old_Node : Node_Id; New_Node : Node_Id);\n-   --  Searches for a SCIL dispatching node associated with Old_Node. If found\n-   --  then update its SCIL_Related_Node field to reference New_Node.\n-\n    function Check_SCIL_Node (N : Node_Id) return Traverse_Result;\n    --  Process a single node during the tree traversal. Done to verify that\n    --  SCIL nodes decoration fulfill the requirements of the SCIL backend.\n \n    procedure Check_SCIL_Nodes is new Traverse_Proc (Check_SCIL_Node);\n    --  The traversal procedure itself\n \n-   function Find_SCIL_Node (Node : Node_Id) return Node_Id;\n-   --  Searches for a SCIL dispatching node associated with Node. If not found\n-   --  then return Empty.\n-\n    function First_Non_SCIL_Node (L : List_Id) return Node_Id;\n    --  Returns the first non-SCIL node of list L\n "}, {"sha": "81046af05da5fc9eabc701f155f3dd55291757ef", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -50,7 +50,6 @@ with Sem_Ch8;  use Sem_Ch8;\n with Sem_Disp; use Sem_Disp;\n with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n-with Sem_SCIL; use Sem_SCIL;\n with Sem_Type; use Sem_Type;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n@@ -5450,15 +5449,6 @@ package body Sem_Util is\n    begin\n       Save_Interps (N, New_Prefix);\n \n-      --  Check if the node relocation requires readjustment of some SCIL\n-      --  dispatching node.\n-\n-      if Generate_SCIL\n-        and then Nkind (N) = N_Function_Call\n-      then\n-         Adjust_SCIL_Node (N, New_Prefix);\n-      end if;\n-\n       Rewrite (N, Make_Explicit_Dereference (Sloc (N), Prefix => New_Prefix));\n \n       Set_Etype (N, Designated_Type (Etype (New_Prefix)));"}, {"sha": "c43e0b4cbe2e97f6bb8f28433be4b1974d9aa2bc", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 2, "deletions": 30, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -2592,26 +2592,12 @@ package body Sinfo is\n       (N : Node_Id) return Node_Id is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_SCIL_Dispatch_Table_Object_Init\n         or else NT (N).Nkind = N_SCIL_Dispatch_Table_Tag_Init\n         or else NT (N).Nkind = N_SCIL_Dispatching_Call\n-        or else NT (N).Nkind = N_SCIL_Membership_Test\n-        or else NT (N).Nkind = N_SCIL_Tag_Init);\n+        or else NT (N).Nkind = N_SCIL_Membership_Test);\n       return Node4 (N);\n    end SCIL_Entity;\n \n-   function SCIL_Related_Node\n-      (N : Node_Id) return Node_Id is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_SCIL_Dispatch_Table_Object_Init\n-        or else NT (N).Nkind = N_SCIL_Dispatch_Table_Tag_Init\n-        or else NT (N).Nkind = N_SCIL_Dispatching_Call\n-        or else NT (N).Nkind = N_SCIL_Membership_Test\n-        or else NT (N).Nkind = N_SCIL_Tag_Init);\n-      return Node1 (N);\n-   end SCIL_Related_Node;\n-\n    function SCIL_Tag_Value\n       (N : Node_Id) return Node_Id is\n    begin\n@@ -5509,26 +5495,12 @@ package body Sinfo is\n       (N : Node_Id; Val : Node_Id) is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_SCIL_Dispatch_Table_Object_Init\n         or else NT (N).Nkind = N_SCIL_Dispatch_Table_Tag_Init\n         or else NT (N).Nkind = N_SCIL_Dispatching_Call\n-        or else NT (N).Nkind = N_SCIL_Membership_Test\n-        or else NT (N).Nkind = N_SCIL_Tag_Init);\n+        or else NT (N).Nkind = N_SCIL_Membership_Test);\n       Set_Node4 (N, Val); -- semantic field, no parent set\n    end Set_SCIL_Entity;\n \n-   procedure Set_SCIL_Related_Node\n-      (N : Node_Id; Val : Node_Id) is\n-   begin\n-      pragma Assert (False\n-        or else NT (N).Nkind = N_SCIL_Dispatch_Table_Object_Init\n-        or else NT (N).Nkind = N_SCIL_Dispatch_Table_Tag_Init\n-        or else NT (N).Nkind = N_SCIL_Dispatching_Call\n-        or else NT (N).Nkind = N_SCIL_Membership_Test\n-        or else NT (N).Nkind = N_SCIL_Tag_Init);\n-      Set_Node1 (N, Val); -- semantic field, no parent set\n-   end Set_SCIL_Related_Node;\n-\n    procedure Set_SCIL_Tag_Value\n       (N : Node_Id; Val : Node_Id) is\n    begin"}, {"sha": "cb358c4d75b389fe4053c2f024eca674f9fd5b2a", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 5, "deletions": 46, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -1626,10 +1626,6 @@ package Sinfo is\n    --    Present in SCIL nodes. Used to reference the tagged type associated\n    --    with the SCIL node.\n \n-   --  SCIL_Related_Node (Node1-Sem)\n-   --    Present in SCIL nodes. Used to reference a tree node that requires\n-   --    special processing in the CodePeer backend.\n-\n    --  SCIL_Controlling_Tag (Node5-Sem)\n    --    Present in N_SCIL_Dispatching_Call nodes. Used to reference the\n    --    controlling tag of a dispatching call.\n@@ -6993,34 +6989,21 @@ package Sinfo is\n       --  Meanwhile these nodes should be considered in experimental form, and\n       --  should be ignored by all code generating back ends. ???\n \n-      --  N_SCIL_Dispatch_Table_Object_Init\n-      --  Sloc references a declaration node containing a dispatch table\n-      --  SCIL_Related_Node (Node1-Sem)\n-      --  SCIL_Entity (Node4-Sem)\n-\n       --  N_SCIL_Dispatch_Table_Tag_Init\n       --  Sloc references a node for a tag initialization\n-      --  SCIL_Related_Node (Node1-Sem)\n       --  SCIL_Entity (Node4-Sem)\n \n       --  N_SCIL_Dispatching_Call\n       --  Sloc references the node of a dispatching call\n-      --  SCIL_Related_Node (Node1-Sem)\n       --  SCIL_Target_Prim (Node2-Sem)\n       --  SCIL_Entity (Node4-Sem)\n       --  SCIL_Controlling_Tag (Node5-Sem)\n \n       --  N_SCIL_Membership_Test\n       --  Sloc references the node of a membership test\n-      --  SCIL_Related_Node (Node1-Sem)\n       --  SCIL_Tag_Value (Node5-Sem)\n       --  SCIL_Entity (Node4-Sem)\n \n-      --  N_SCIL_Tag_Init\n-      --  Sloc references the node of a tag component initialization\n-      --  SCIL_Related_Node (Node1-Sem)\n-      --  SCIL_Entity (Node4-Sem)\n-\n       ---------------------\n       -- Subprogram_Info --\n       ---------------------\n@@ -7462,11 +7445,9 @@ package Sinfo is\n \n       --  SCIL nodes\n \n-      N_SCIL_Dispatch_Table_Object_Init,\n       N_SCIL_Dispatch_Table_Tag_Init,\n       N_SCIL_Dispatching_Call,\n       N_SCIL_Membership_Test,\n-      N_SCIL_Tag_Init,\n \n       --  Other nodes (not part of any subtype class)\n \n@@ -7680,8 +7661,8 @@ package Sinfo is\n      N_Or_Else;\n \n    subtype N_SCIL_Node is Node_Kind range\n-     N_SCIL_Dispatch_Table_Object_Init ..\n-     N_SCIL_Tag_Init;\n+     N_SCIL_Dispatch_Table_Tag_Init ..\n+     N_SCIL_Membership_Test;\n \n    subtype N_Statement_Other_Than_Procedure_Call is Node_Kind range\n      N_Abort_Statement ..\n@@ -8533,9 +8514,6 @@ package Sinfo is\n    function SCIL_Entity\n      (N : Node_Id) return Node_Id;    -- Node4\n \n-   function SCIL_Related_Node\n-     (N : Node_Id) return Node_Id;    -- Node1\n-\n    function SCIL_Tag_Value\n      (N : Node_Id) return Node_Id;    -- Node5\n \n@@ -9463,9 +9441,6 @@ package Sinfo is\n    procedure Set_SCIL_Entity\n      (N : Node_Id; Val : Node_Id);            -- Node4\n \n-   procedure Set_SCIL_Related_Node\n-     (N : Node_Id; Val : Node_Id);            -- Node1\n-\n    procedure Set_SCIL_Tag_Value\n      (N : Node_Id; Val : Node_Id);            -- Node5\n \n@@ -11226,41 +11201,27 @@ package Sinfo is\n \n    --  Entries for SCIL nodes\n \n-     N_SCIL_Dispatch_Table_Object_Init =>\n-       (1 => False,   --  SCIL_Related_Node (Node1-Sem)\n-        2 => False,   --  unused\n-        3 => False,   --  unused\n-        4 => False,   --  SCIL_Entity (Node4-Sem)\n-        5 => False),  --  unused\n-\n      N_SCIL_Dispatch_Table_Tag_Init =>\n-       (1 => False,   --  SCIL_Related_Node (Node1-Sem)\n+       (1 => False,   --  unused\n         2 => False,   --  unused\n         3 => False,   --  unused\n         4 => False,   --  SCIL_Entity (Node4-Sem)\n         5 => False),  --  unused\n \n      N_SCIL_Dispatching_Call =>\n-       (1 => False,   --  SCIL_Related_Node (Node1-Sem)\n+       (1 => False,   --  unused\n         2 => False,   --  SCIL_Target_Prim (Node2-Sem)\n         3 => False,   --  unused\n         4 => False,   --  SCIL_Entity (Node4-Sem)\n         5 => False),  --  SCIL_Controlling_Tag (Node5-Sem)\n \n      N_SCIL_Membership_Test =>\n-       (1 => False,   --  SCIL_Related_Node (Node1-Sem)\n+       (1 => False,   --  unused\n         2 => False,   --  unused\n         3 => False,   --  unused\n         4 => False,   --  SCIL_Entity (Node4-Sem)\n         5 => False),  --  SCIL_Tag_Value (Node5-Sem)\n \n-     N_SCIL_Tag_Init =>\n-       (1 => False,   --  SCIL_Related_Node (Node1-Sem)\n-        2 => False,   --  unused\n-        3 => False,   --  unused\n-        4 => False,   --  SCIL_Entity (Node4-Sem)\n-        5 => False),  --  unused\n-\n    --  Entries for Empty, Error and Unused. Even thought these have a Chars\n    --  field for debugging purposes, they are not really syntactic fields, so\n    --  we mark all fields as unused.\n@@ -11565,7 +11526,6 @@ package Sinfo is\n    pragma Inline (Rounded_Result);\n    pragma Inline (SCIL_Controlling_Tag);\n    pragma Inline (SCIL_Entity);\n-   pragma Inline (SCIL_Related_Node);\n    pragma Inline (SCIL_Tag_Value);\n    pragma Inline (SCIL_Target_Prim);\n    pragma Inline (Scope);\n@@ -11871,7 +11831,6 @@ package Sinfo is\n    pragma Inline (Set_Rounded_Result);\n    pragma Inline (Set_SCIL_Controlling_Tag);\n    pragma Inline (Set_SCIL_Entity);\n-   pragma Inline (Set_SCIL_Related_Node);\n    pragma Inline (Set_SCIL_Tag_Value);\n    pragma Inline (Set_SCIL_Target_Prim);\n    pragma Inline (Set_Scope);"}, {"sha": "44c12f0ab2d09dc42af5a0ce03312f01640f1568", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -2689,9 +2689,6 @@ package body Sprint is\n          --  Doc of this extended syntax belongs in sinfo.ads and/or\n          --  sprint.ads ???\n \n-         when N_SCIL_Dispatch_Table_Object_Init =>\n-            Write_Indent_Str (\"[N_SCIL_Dispatch_Table_Object_Init]\");\n-\n          when N_SCIL_Dispatch_Table_Tag_Init =>\n             Write_Indent_Str (\"[N_SCIL_Dispatch_Table_Tag_Init]\");\n \n@@ -2701,9 +2698,6 @@ package body Sprint is\n          when N_SCIL_Membership_Test =>\n             Write_Indent_Str (\"[N_SCIL_Membership_Test]\");\n \n-         when N_SCIL_Tag_Init =>\n-            Write_Indent_Str (\"[N_SCIL_Dispatch_Table_Tag_Init]\");\n-\n          when N_Simple_Return_Statement =>\n             if Present (Expression (Node)) then\n                Write_Indent_Str_Sloc (\"return \");"}, {"sha": "b41296b2cc987bc5e1b1d83743fcc710bef239ab", "filename": "gcc/ada/switch-b.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fswitch-b.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Fswitch-b.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-b.adb?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -280,6 +280,7 @@ package body Switch.B is\n \n             Ptr := Ptr + 1;\n             Scan_Nat (Switch_Chars, Max, Ptr, Heap_Size, C);\n+\n             if Heap_Size /= 32 and then Heap_Size /= 64 then\n                Bad_Switch (Switch_Chars);\n             end if;"}, {"sha": "6102453de8c241e97727409c4faf513c712d865b", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7665e4bd2cc96d483c59658d1d851765722d918c/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=7665e4bd2cc96d483c59658d1d851765722d918c", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -38,6 +38,7 @@ with Snames;   use Snames;\n with Sinput;   use Sinput;\n with Stand;    use Stand;\n with Stringt;  use Stringt;\n+with SCIL_LL;  use SCIL_LL;\n with Treeprs;  use Treeprs;\n with Uintp;    use Uintp;\n with Urealp;   use Urealp;\n@@ -1188,6 +1189,14 @@ package body Treepr is\n          Print_Entity_Info (N, Prefix_Str_Char);\n       end if;\n \n+      --  Print the SCIL node (if available)\n+\n+      if Present (Get_SCIL_Node (N)) then\n+         Print_Str (Prefix_Str_Char);\n+         Print_Str (\"SCIL_Node = \");\n+         Print_Node_Ref (Get_SCIL_Node (N));\n+         Print_Eol;\n+      end if;\n    end Print_Node;\n \n    ---------------------"}]}