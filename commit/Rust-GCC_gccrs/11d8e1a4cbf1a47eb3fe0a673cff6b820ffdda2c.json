{"sha": "11d8e1a4cbf1a47eb3fe0a673cff6b820ffdda2c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFkOGUxYTRjYmYxYTQ3ZWIzZmUwYTY3M2NmZjZiODIwZmZkZGEyYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-01-11T21:20:41Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-01-11T21:20:41Z"}, "message": "compiler: Don't use memcmp for structs/arrays with padding.\n\nFrom-SVN: r183109", "tree": {"sha": "42ef542db68c33e13f4e261277beb7a8be2ffbdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42ef542db68c33e13f4e261277beb7a8be2ffbdc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11d8e1a4cbf1a47eb3fe0a673cff6b820ffdda2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11d8e1a4cbf1a47eb3fe0a673cff6b820ffdda2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11d8e1a4cbf1a47eb3fe0a673cff6b820ffdda2c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11d8e1a4cbf1a47eb3fe0a673cff6b820ffdda2c/comments", "author": null, "committer": null, "parents": [{"sha": "ef079a56e47d898ae7ad347c5d84a4ccfd9cba91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef079a56e47d898ae7ad347c5d84a4ccfd9cba91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef079a56e47d898ae7ad347c5d84a4ccfd9cba91"}], "stats": {"total": 287, "additions": 170, "deletions": 117}, "files": [{"sha": "7166a56692dcbc57af732aad901893cc866468fc", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11d8e1a4cbf1a47eb3fe0a673cff6b820ffdda2c/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11d8e1a4cbf1a47eb3fe0a673cff6b820ffdda2c/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=11d8e1a4cbf1a47eb3fe0a673cff6b820ffdda2c", "patch": "@@ -5844,7 +5844,7 @@ Binary_expression::lower_struct_comparison(Gogo* gogo,\n   // See if we can compare using memcmp.  As a heuristic, we use\n   // memcmp rather than field references and comparisons if there are\n   // more than two fields.\n-  if (st->compare_is_identity() && st->total_field_count() > 2)\n+  if (st->compare_is_identity(gogo) && st->total_field_count() > 2)\n     return this->lower_compare_to_memcmp(gogo, inserter);\n \n   Location loc = this->location();\n@@ -5919,7 +5919,7 @@ Binary_expression::lower_array_comparison(Gogo* gogo,\n \n   // Call memcmp directly if possible.  This may let the middle-end\n   // optimize the call.\n-  if (at->compare_is_identity())\n+  if (at->compare_is_identity(gogo))\n     return this->lower_compare_to_memcmp(gogo, inserter);\n \n   // Call the array comparison function.\n@@ -12966,10 +12966,10 @@ class Composite_literal_expression : public Parser_expression\n   lower_struct(Gogo*, Type*);\n \n   Expression*\n-  lower_array(Gogo*, Type*);\n+  lower_array(Type*);\n \n   Expression*\n-  make_array(Gogo*, Type*, Expression_list*);\n+  make_array(Type*, Expression_list*);\n \n   Expression*\n   lower_map(Gogo*, Named_object*, Statement_inserter*, Type*);\n@@ -13036,7 +13036,7 @@ Composite_literal_expression::do_lower(Gogo* gogo, Named_object* function,\n   else if (type->struct_type() != NULL)\n     ret = this->lower_struct(gogo, type);\n   else if (type->array_type() != NULL)\n-    ret = this->lower_array(gogo, type);\n+    ret = this->lower_array(type);\n   else if (type->map_type() != NULL)\n     ret = this->lower_map(gogo, function, inserter, type);\n   else\n@@ -13249,11 +13249,11 @@ Composite_literal_expression::lower_struct(Gogo* gogo, Type* type)\n // Lower an array composite literal.\n \n Expression*\n-Composite_literal_expression::lower_array(Gogo* gogo, Type* type)\n+Composite_literal_expression::lower_array(Type* type)\n {\n   Location location = this->location();\n   if (this->vals_ == NULL || !this->has_keys_)\n-    return this->make_array(gogo, type, this->vals_);\n+    return this->make_array(type, this->vals_);\n \n   std::vector<Expression*> vals;\n   vals.reserve(this->vals_->size());\n@@ -13353,15 +13353,14 @@ Composite_literal_expression::lower_array(Gogo* gogo, Type* type)\n   for (size_t i = 0; i < size; ++i)\n     list->push_back(vals[i]);\n \n-  return this->make_array(gogo, type, list);\n+  return this->make_array(type, list);\n }\n \n // Actually build the array composite literal. This handles\n // [...]{...}.\n \n Expression*\n-Composite_literal_expression::make_array(Gogo* gogo, Type* type,\n-\t\t\t\t\t Expression_list* vals)\n+Composite_literal_expression::make_array(Type* type, Expression_list* vals)\n {\n   Location location = this->location();\n   Array_type* at = type->array_type();\n@@ -13373,10 +13372,6 @@ Composite_literal_expression::make_array(Gogo* gogo, Type* type,\n       Expression* elen = Expression::make_integer(&vlen, NULL, location);\n       mpz_clear(vlen);\n       at = Type::make_array_type(at->element_type(), elen);\n-\n-      // This is after the finalize_methods pass, so run that now.\n-      at->finalize_methods(gogo);\n-\n       type = at;\n     }\n   if (at->length() != NULL)"}, {"sha": "f6f22d44be3f55f452bbb525c7dc6b460099724a", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 63, "deletions": 4, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11d8e1a4cbf1a47eb3fe0a673cff6b820ffdda2c/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11d8e1a4cbf1a47eb3fe0a673cff6b820ffdda2c/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=11d8e1a4cbf1a47eb3fe0a673cff6b820ffdda2c", "patch": "@@ -1149,11 +1149,74 @@ Gogo::queue_specific_type_function(Type* type, Named_type* name,\n   this->specific_type_functions_.push_back(tsf);\n }\n \n+// Look for types which need specific hash or equality functions.\n+\n+class Specific_type_functions : public Traverse\n+{\n+ public:\n+  Specific_type_functions(Gogo* gogo)\n+    : Traverse(traverse_types),\n+      gogo_(gogo)\n+  { }\n+\n+  int\n+  type(Type*);\n+\n+ private:\n+  Gogo* gogo_;\n+};\n+\n+int\n+Specific_type_functions::type(Type* t)\n+{\n+  Named_object* hash_fn;\n+  Named_object* equal_fn;\n+  switch (t->classification())\n+    {\n+    case Type::TYPE_NAMED:\n+      {\n+\tif (!t->compare_is_identity(this->gogo_) && t->is_comparable())\n+\t  t->type_functions(this->gogo_, t->named_type(), NULL, NULL, &hash_fn,\n+\t\t\t    &equal_fn);\n+\n+\t// If this is a struct type, we don't want to make functions\n+\t// for the unnamed struct.\n+\tType* rt = t->named_type()->real_type();\n+\tif (rt->struct_type() == NULL)\n+\t  {\n+\t    if (Type::traverse(rt, this) == TRAVERSE_EXIT)\n+\t      return TRAVERSE_EXIT;\n+\t  }\n+\telse\n+\t  {\n+\t    if (rt->struct_type()->traverse_field_types(this) == TRAVERSE_EXIT)\n+\t      return TRAVERSE_EXIT;\n+\t  }\n+\n+\treturn TRAVERSE_SKIP_COMPONENTS;\n+      }\n+\n+    case Type::TYPE_STRUCT:\n+    case Type::TYPE_ARRAY:\n+      if (!t->compare_is_identity(this->gogo_) && t->is_comparable())\n+\tt->type_functions(this->gogo_, NULL, NULL, NULL, &hash_fn, &equal_fn);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return TRAVERSE_CONTINUE;\n+}\n+\n // Write out type specific functions.\n \n void\n Gogo::write_specific_type_functions()\n {\n+  Specific_type_functions stf(this);\n+  this->traverse(&stf);\n+\n   while (!this->specific_type_functions_.empty())\n     {\n       Specific_type_function* tsf = this->specific_type_functions_.back();\n@@ -1520,10 +1583,6 @@ Finalize_methods::type(Type* t)\n       t->struct_type()->finalize_methods(this->gogo_);\n       break;\n \n-    case Type::TYPE_ARRAY:\n-      t->array_type()->finalize_methods(this->gogo_);\n-      break;\n-\n     default:\n       break;\n     }"}, {"sha": "c8600ac1baf7e60ee5a06ed25062d628469239e9", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 76, "deletions": 71, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11d8e1a4cbf1a47eb3fe0a673cff6b820ffdda2c/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11d8e1a4cbf1a47eb3fe0a673cff6b820ffdda2c/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=11d8e1a4cbf1a47eb3fe0a673cff6b820ffdda2c", "patch": "@@ -571,7 +571,8 @@ Type::are_compatible_for_comparison(bool is_equality_op, const Type *t1,\n \t}\n       else if (t1->array_type() != NULL)\n \t{\n-\t  if (!t1->array_type()->element_type()->is_comparable())\n+\t  if (t1->array_type()->length()->is_nil_expression()\n+\t      || !t1->array_type()->element_type()->is_comparable())\n \t    {\n \t      if (reason != NULL)\n \t\t*reason = _(\"invalid comparison of non-comparable array\");\n@@ -1372,7 +1373,7 @@ Type::type_functions(Gogo* gogo, Named_type* name, Function_type* hash_fntype,\n \n   const char* hash_fnname;\n   const char* equal_fnname;\n-  if (this->compare_is_identity())\n+  if (this->compare_is_identity(gogo))\n     {\n       hash_fnname = \"__go_type_hash_identity\";\n       equal_fnname = \"__go_type_equal_identity\";\n@@ -1963,7 +1964,7 @@ Type::mangled_name(Gogo* gogo) const\n // Return whether the backend size of the type is known.\n \n bool\n-Type::is_backend_type_size_known(Gogo* gogo) const\n+Type::is_backend_type_size_known(Gogo* gogo)\n {\n   switch (this->classification_)\n     {\n@@ -2014,11 +2015,14 @@ Type::is_backend_type_size_known(Gogo* gogo) const\n       }\n \n     case TYPE_NAMED:\n+      // Begin converting this type to the backend representation.\n+      // This will create a placeholder if necessary.\n+      this->get_backend(gogo);\n       return this->named_type()->is_named_backend_type_size_known();\n \n     case TYPE_FORWARD:\n       {\n-\tconst Forward_declaration_type* fdt = this->forward_declaration_type();\n+\tForward_declaration_type* fdt = this->forward_declaration_type();\n \treturn fdt->real_type()->is_backend_type_size_known(gogo);\n       }\n \n@@ -2038,10 +2042,9 @@ Type::is_backend_type_size_known(Gogo* gogo) const\n bool\n Type::backend_type_size(Gogo* gogo, unsigned int *psize)\n {\n-  Btype* btype = this->get_backend(gogo);\n   if (!this->is_backend_type_size_known(gogo))\n     return false;\n-  size_t size = gogo->backend()->type_size(btype);\n+  size_t size = gogo->backend()->type_size(this->get_backend(gogo));\n   *psize = static_cast<unsigned int>(size);\n   if (*psize != size)\n     return false;\n@@ -2054,10 +2057,9 @@ Type::backend_type_size(Gogo* gogo, unsigned int *psize)\n bool\n Type::backend_type_align(Gogo* gogo, unsigned int *palign)\n {\n-  Btype* btype = this->get_backend(gogo);\n   if (!this->is_backend_type_size_known(gogo))\n     return false;\n-  size_t align = gogo->backend()->type_alignment(btype);\n+  size_t align = gogo->backend()->type_alignment(this->get_backend(gogo));\n   *palign = static_cast<unsigned int>(align);\n   if (*palign != align)\n     return false;\n@@ -2070,10 +2072,9 @@ Type::backend_type_align(Gogo* gogo, unsigned int *palign)\n bool\n Type::backend_type_field_align(Gogo* gogo, unsigned int *palign)\n {\n-  Btype* btype = this->get_backend(gogo);\n   if (!this->is_backend_type_size_known(gogo))\n     return false;\n-  size_t a = gogo->backend()->type_field_alignment(btype);\n+  size_t a = gogo->backend()->type_field_alignment(this->get_backend(gogo));\n   *palign = static_cast<unsigned int>(a);\n   if (*palign != a)\n     return false;\n@@ -2126,7 +2127,7 @@ class Error_type : public Type\n \n  protected:\n   bool\n-  do_compare_is_identity() const\n+  do_compare_is_identity(Gogo*) const\n   { return false; }\n \n   Btype*\n@@ -2164,7 +2165,7 @@ class Void_type : public Type\n \n  protected:\n   bool\n-  do_compare_is_identity() const\n+  do_compare_is_identity(Gogo*) const\n   { return false; }\n \n   Btype*\n@@ -2202,7 +2203,7 @@ class Boolean_type : public Type\n \n  protected:\n   bool\n-  do_compare_is_identity() const\n+  do_compare_is_identity(Gogo*) const\n   { return true; }\n \n   Btype*\n@@ -2793,7 +2794,7 @@ class Sink_type : public Type\n \n  protected:\n   bool\n-  do_compare_is_identity() const\n+  do_compare_is_identity(Gogo*) const\n   { return false; }\n \n   Btype*\n@@ -3705,7 +3706,7 @@ class Nil_type : public Type\n \n  protected:\n   bool\n-  do_compare_is_identity() const\n+  do_compare_is_identity(Gogo*) const\n   { return false; }\n \n   Btype*\n@@ -3756,7 +3757,7 @@ class Call_multiple_result_type : public Type\n   }\n \n   bool\n-  do_compare_is_identity() const\n+  do_compare_is_identity(Gogo*) const\n   { return false; }\n \n   Btype*\n@@ -4037,16 +4038,35 @@ Struct_type::struct_has_hidden_fields(const Named_type* within,\n // comparisons.\n \n bool\n-Struct_type::do_compare_is_identity() const\n+Struct_type::do_compare_is_identity(Gogo* gogo) const\n {\n   const Struct_field_list* fields = this->fields_;\n   if (fields == NULL)\n     return true;\n+  unsigned int offset = 0;\n   for (Struct_field_list::const_iterator pf = fields->begin();\n        pf != fields->end();\n        ++pf)\n-    if (!pf->type()->compare_is_identity())\n-      return false;\n+    {\n+      if (!pf->type()->compare_is_identity(gogo))\n+\treturn false;\n+\n+      unsigned int field_align;\n+      if (!pf->type()->backend_type_align(gogo, &field_align))\n+\treturn false;\n+      if ((offset & (field_align - 1)) != 0)\n+\t{\n+\t  // This struct has padding.  We don't guarantee that that\n+\t  // padding is zero-initialized for a stack variable, so we\n+\t  // can't use memcmp to compare struct values.\n+\t  return false;\n+\t}\n+\n+      unsigned int field_size;\n+      if (!pf->type()->backend_type_size(gogo, &field_size))\n+\treturn false;\n+      offset += field_size;\n+    }\n   return true;\n }\n \n@@ -4231,7 +4251,7 @@ Struct_type::total_field_count() const\n        pf != this->fields_->end();\n        ++pf)\n     {\n-      if (!pf->is_anonymous() || pf->type()->deref()->struct_type() == NULL)\n+      if (!pf->is_anonymous() || pf->type()->struct_type() == NULL)\n \t++ret;\n       else\n \tret += pf->type()->struct_type()->total_field_count();\n@@ -4267,17 +4287,6 @@ Struct_type::is_unexported_local_field(Gogo* gogo,\n void\n Struct_type::finalize_methods(Gogo* gogo)\n {\n-  // If this type needs explicit comparison and hash functions, create\n-  // them now.  It would be a bit better to do this only if the\n-  // functions are needed, but they will be static so the backend can\n-  // discard them if they are not used.\n-  if (!this->compare_is_identity() && this->is_comparable())\n-    {\n-      Named_object* hash_fn;\n-      Named_object* equal_fn;\n-      this->type_functions(gogo, NULL, NULL, NULL, &hash_fn, &equal_fn);\n-    }\n-\n   if (this->all_methods_ != NULL)\n     return;\n   Type::finalize_methods(gogo, this, this->location_, &this->all_methods_);\n@@ -4727,10 +4736,10 @@ bool\n Struct_type::backend_field_offset(Gogo* gogo, unsigned int index,\n \t\t\t\t  unsigned int* poffset)\n {\n-  Btype* btype = this->get_backend(gogo);\n   if (!this->is_backend_type_size_known(gogo))\n     return false;\n-  size_t offset = gogo->backend()->type_field_offset(btype, index);\n+  size_t offset = gogo->backend()->type_field_offset(this->get_backend(gogo),\n+\t\t\t\t\t\t     index);\n   *poffset = static_cast<unsigned int>(offset);\n   if (*poffset != offset)\n     return false;\n@@ -4871,25 +4880,6 @@ Array_type::is_identical(const Array_type* t, bool errors_are_identical) const\n   return false;\n }\n \n-// If this type needs explicit comparison and hash functions, create\n-// them now.  It would be a bit better to do this only if the\n-// functions are needed, but they will be static so the backend can\n-// discard them if they are not used.\n-\n-void\n-Array_type::finalize_methods(Gogo* gogo)\n-{\n-  if (this->length_ != NULL\n-      && !this->length_->is_nil_expression()\n-      && !this->compare_is_identity()\n-      && this->is_comparable())\n-    {\n-      Named_object* hash_fn;\n-      Named_object* equal_fn;\n-      this->type_functions(gogo, NULL, NULL, NULL, &hash_fn, &equal_fn);\n-    }\n-}\n-\n // Traversal.\n \n int\n@@ -4988,6 +4978,33 @@ Array_type::do_verify()\n   return true;\n }\n \n+// Whether we can use memcmp to compare this array.\n+\n+bool\n+Array_type::do_compare_is_identity(Gogo* gogo) const\n+{\n+  if (this->length_ == NULL)\n+    return false;\n+\n+  // Check for [...], which indicates that this is not a real type.\n+  if (this->length_->is_nil_expression())\n+    return false;\n+\n+  if (!this->element_type_->compare_is_identity(gogo))\n+    return false;\n+\n+  // If there is any padding, then we can't use memcmp.\n+  unsigned int size;\n+  unsigned int align;\n+  if (!this->element_type_->backend_type_size(gogo, &size)\n+      || !this->element_type_->backend_type_align(gogo, &align))\n+    return false;\n+  if ((size & (align - 1)) != 0)\n+    return false;\n+\n+  return true;\n+}\n+\n // Array type hash code.\n \n unsigned int\n@@ -7272,20 +7289,6 @@ Named_type::is_unexported_local_method(Gogo* gogo,\n void\n Named_type::finalize_methods(Gogo* gogo)\n {\n-  // If this type needs explicit comparison and hash functions, create\n-  // them now.  It would be a bit better to do this only if the\n-  // functions are needed, but they will be static so the backend can\n-  // discard them if they are not used.\n-  if ((this->struct_type() != NULL\n-       || (this->array_type() != NULL && !this->is_slice_type()))\n-      && !this->compare_is_identity()\n-      && this->is_comparable())\n-    {\n-      Named_object* hash_fn;\n-      Named_object* equal_fn;\n-      this->type_functions(gogo, this, NULL, NULL, &hash_fn, &equal_fn);\n-    }\n-\n   if (this->all_methods_ != NULL)\n     return;\n \n@@ -7539,13 +7542,15 @@ Named_type::do_has_pointer() const\n // function.\n \n bool\n-Named_type::do_compare_is_identity() const\n+Named_type::do_compare_is_identity(Gogo* gogo) const\n {\n-  if (this->seen_)\n+  // We don't use this->seen_ here because compare_is_identity may\n+  // call base() later, and that will mess up if seen_ is set here.\n+  if (this->seen_in_compare_is_identity_)\n     return false;\n-  this->seen_ = true;\n-  bool ret = this->type_->compare_is_identity();\n-  this->seen_ = false;\n+  this->seen_in_compare_is_identity_ = true;\n+  bool ret = this->type_->compare_is_identity(gogo);\n+  this->seen_in_compare_is_identity_ = false;\n   return ret;\n }\n "}, {"sha": "9de1b84334d768aecb1e59cc7a86bbb1b45ba3f0", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11d8e1a4cbf1a47eb3fe0a673cff6b820ffdda2c/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11d8e1a4cbf1a47eb3fe0a673cff6b820ffdda2c/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=11d8e1a4cbf1a47eb3fe0a673cff6b820ffdda2c", "patch": "@@ -568,8 +568,8 @@ class Type\n   // identity function which gets nothing but a pointer to the value\n   // and a size.\n   bool\n-  compare_is_identity() const\n-  { return this->do_compare_is_identity(); }\n+  compare_is_identity(Gogo* gogo) const\n+  { return this->do_compare_is_identity(gogo); }\n \n   // Return a hash code for this type for the method hash table.\n   // Types which are equivalent according to are_identical will have\n@@ -880,7 +880,7 @@ class Type\n \n   // Whether the backend size is known.\n   bool\n-  is_backend_type_size_known(Gogo*) const;\n+  is_backend_type_size_known(Gogo*);\n \n   // Get the hash and equality functions for a type.\n   void\n@@ -924,7 +924,7 @@ class Type\n   { return false; }\n \n   virtual bool\n-  do_compare_is_identity() const = 0;\n+  do_compare_is_identity(Gogo*) const = 0;\n \n   virtual unsigned int\n   do_hash_for_method(Gogo*) const;\n@@ -1388,7 +1388,7 @@ class Integer_type : public Type\n \n  protected:\n   bool\n-  do_compare_is_identity() const\n+  do_compare_is_identity(Gogo*) const\n   { return true; }\n \n   unsigned int\n@@ -1461,7 +1461,7 @@ class Float_type : public Type\n \n  protected:\n   bool\n-  do_compare_is_identity() const\n+  do_compare_is_identity(Gogo*) const\n   { return false; }\n \n   unsigned int\n@@ -1530,7 +1530,7 @@ class Complex_type : public Type\n \n  protected:\n   bool\n-  do_compare_is_identity() const\n+  do_compare_is_identity(Gogo*) const\n   { return false; }\n \n   unsigned int\n@@ -1590,7 +1590,7 @@ class String_type : public Type\n   { return true; }\n \n   bool\n-  do_compare_is_identity() const\n+  do_compare_is_identity(Gogo*) const\n   { return false; }\n \n   Btype*\n@@ -1708,7 +1708,7 @@ class Function_type : public Type\n   { return true; }\n \n   bool\n-  do_compare_is_identity() const\n+  do_compare_is_identity(Gogo*) const\n   { return false; }\n \n   unsigned int\n@@ -1793,7 +1793,7 @@ class Pointer_type : public Type\n   { return true; }\n \n   bool\n-  do_compare_is_identity() const\n+  do_compare_is_identity(Gogo*) const\n   { return true; }\n \n   unsigned int\n@@ -1985,7 +1985,7 @@ class Struct_type : public Type\n \t\t  Location) const;\n \n   // Return the total number of fields, including embedded fields.\n-  // This is the number of values which can appear in a conversion to\n+  // This is the number of values that can appear in a conversion to\n   // this type.\n   unsigned int\n   total_field_count() const;\n@@ -2066,7 +2066,7 @@ class Struct_type : public Type\n   do_has_pointer() const;\n \n   bool\n-  do_compare_is_identity() const;\n+  do_compare_is_identity(Gogo*) const;\n \n   unsigned int\n   do_hash_for_method(Gogo*) const;\n@@ -2136,10 +2136,6 @@ class Array_type : public Type\n   array_has_hidden_fields(const Named_type* within, std::string* reason) const\n   { return this->element_type_->has_hidden_fields(within, reason); }\n \n-  // Build the hash and equality functions if necessary.\n-  void\n-  finalize_methods(Gogo*);\n-\n   // Return a tree for the pointer to the values in an array.\n   tree\n   value_pointer_tree(Gogo*, tree array) const;\n@@ -2192,11 +2188,7 @@ class Array_type : public Type\n   }\n \n   bool\n-  do_compare_is_identity() const\n-  {\n-    return (this->length_ != NULL\n-\t    && this->element_type_->compare_is_identity());\n-  }\n+  do_compare_is_identity(Gogo*) const;\n \n   unsigned int\n   do_hash_for_method(Gogo*) const;\n@@ -2289,7 +2281,7 @@ class Map_type : public Type\n   { return true; }\n \n   bool\n-  do_compare_is_identity() const\n+  do_compare_is_identity(Gogo*) const\n   { return false; }\n \n   unsigned int\n@@ -2375,7 +2367,7 @@ class Channel_type : public Type\n   { return true; }\n \n   bool\n-  do_compare_is_identity() const\n+  do_compare_is_identity(Gogo*) const\n   { return true; }\n \n   unsigned int\n@@ -2490,7 +2482,7 @@ class Interface_type : public Type\n   { return true; }\n \n   bool\n-  do_compare_is_identity() const\n+  do_compare_is_identity(Gogo*) const\n   { return false; }\n \n   unsigned int\n@@ -2536,7 +2528,7 @@ class Named_type : public Type\n       location_(location), named_btype_(NULL), dependencies_(),\n       is_visible_(true), is_error_(false), is_placeholder_(false),\n       is_converted_(false), is_circular_(false), seen_(false),\n-      seen_in_get_backend_(false)\n+      seen_in_compare_is_identity_(false), seen_in_get_backend_(false)\n   { }\n \n   // Return the associated Named_object.  This holds the actual name.\n@@ -2731,7 +2723,7 @@ class Named_type : public Type\n   do_has_pointer() const;\n \n   bool\n-  do_compare_is_identity() const;\n+  do_compare_is_identity(Gogo*) const;\n \n   unsigned int\n   do_hash_for_method(Gogo*) const;\n@@ -2815,6 +2807,8 @@ class Named_type : public Type\n   // This is mutable because it is always reset to false when the\n   // function exits.\n   mutable bool seen_;\n+  // Like seen_, but used only by do_compare_is_identity.\n+  mutable bool seen_in_compare_is_identity_;\n   // Like seen_, but used only by do_get_backend.\n   bool seen_in_get_backend_;\n };\n@@ -2869,8 +2863,8 @@ class Forward_declaration_type : public Type\n   { return this->real_type()->has_pointer(); }\n \n   bool\n-  do_compare_is_identity() const\n-  { return this->real_type()->compare_is_identity(); }\n+  do_compare_is_identity(Gogo* gogo) const\n+  { return this->real_type()->compare_is_identity(gogo); }\n \n   unsigned int\n   do_hash_for_method(Gogo* gogo) const"}]}