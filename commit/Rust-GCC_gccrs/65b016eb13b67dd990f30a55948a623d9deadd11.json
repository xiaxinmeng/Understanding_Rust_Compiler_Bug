{"sha": "65b016eb13b67dd990f30a55948a623d9deadd11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjViMDE2ZWIxM2I2N2RkOTkwZjMwYTU1OTQ4YTYyM2Q5ZGVhZGQxMQ==", "commit": {"author": {"name": "Aditya Kumar", "email": "aditya.k7@samsung.com", "date": "2015-11-12T00:37:47Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-11-12T00:37:47Z"}, "message": "Preserve the original program while using graphite.\n\nEarlier, graphite used to translate portions of the original program after\nscop-detection in order to represent the SCoP into polyhedral model.  This was\nrequired because each basic block was represented as independent basic block in\nthe polyhedral model. So all the cross-basic-block dependencies were translated\nout-of-ssa.\n\nWith this patch those dependencies are also exposed to the ISL, so there is no\nneed to modify the original structure of the program.\n\nAfter this patch we should be able to enable graphite at some default\noptimization level.\n\nHighlights:\nRemove cross bb scalar to array translation\nFor reductions, add support for more than just INT_CST\nEarly bailout on codegen.\nVerify loop-closed ssa structure during copy of renames\nThe uses of exprs should come from bb which dominates the bb\nCollect the init value of close phi in loop-guard\nDo not follow vuses for close-phi, postpone loop-close phi until the\n    corresponding loop-phi is processed\nBail out if no bb found to place cond/loop -phis\nMove insertion of liveouts at the end of codegen\nInsert loop-phis in the loop-header.\n\nThis patch passes regtest and bootstrap with BOOT_CFLAGS='-O2 -fgraphite-identity -floop-nest-optimize'\n\n2015-11-11  Aditya Kumar  <aditya.k7@samsung.com>\n      Sebastian Pop  <s.pop@samsung.com>\n\n\t* graphite-isl-ast-to-gimple.c (class translate_isl_ast_to_gimple):\n\t  New member codegen_error\n\t(translate_isl_ast_for_loop): Remove call to single_succ_edge and early return.\n\t(translate_isl_ast_node_user): Early return in case of error.\n\t(translate_isl_ast_to_gimple::translate_isl_ast): Same.\n\t(translate_isl_ast_to_gimple::translate_pending_phi_nodes): New.\n\t(add_parameters_to_ivs_params): Remove macro.\n\t(graphite_regenerate_ast_isl): Add if_region pointer to region.\n\t* graphite-poly.c (new_poly_dr): Remove macro.\n\t(print_pdr): Same.\n\t(new_gimple_poly_bb): Same.\n\t(free_gimple_poly_bb): Same.\n\t(print_scop_params): Same.\n\t* graphite-poly.h (struct poly_dr): Same.\n\t(struct poly_bb): Add new_bb.\n\t(gbb_from_bb): Remove dead code.\n\t(pbb_from_bb): Same.\n\t* graphite-scop-detection.c (parameter_index_in_region_1): Same.\n\t(parameter_index_in_region): Same.\n\t(find_scop_parameters): Same.\n\t(build_cross_bb_scalars_def): New.\n\t(build_cross_bb_scalars_use): New.\n\t(graphite_find_cross_bb_scalar_vars): New\n\t(try_generate_gimple_bb): Reads and Writes.\n\t(build_alias_set): Move.\n\t(gather_bbs::before_dom_children): Gather bbs visited.\n\t(build_scops): call build_alias_set.\n\t* graphite-sese-to-poly.c (phi_arg_in_outermost_loop): Delete.\n\t(remove_simple_copy_phi): Delete.\n\t(remove_invariant_phi): Delete.\n\t(simple_copy_phi_p): Delete.\n\t(reduction_phi_p): Delete.\n\t(isl_id_for_dr): Remove unused param.\n\t(parameter_index_in_region_1): Remove macro usage.\n\t(set_scop_parameter_dim): Same.\n\t(add_param_constraints): Same.\n\t(add_conditions_to_constraints): Same\n\t(build_scop_iteration_domain): Same.\n\t(pdr_add_alias_set): Comment.\n\t(add_scalar_version_numbers): New.\n\t(build_poly_dr): ISL id.\n\t(build_scop_drs): Move.\n\t(build_poly_sr_1): Same.\n\t(insert_stmts): Remove.\n\t(build_poly_sr): New.\n\t(new_pbb_from_pbb): Delete.\n\t(insert_out_of_ssa_copy_on_edge): Delete.\n\t(create_zero_dim_array): Delete.\n\t(scalar_close_phi_node_p): Delete.\n\t(propagate_expr_outside_region): Delete.\n\t(rewrite_close_phi_out_of_ssa): Delete.\n\t(rewrite_phi_out_of_ssa): Delete.\n\t(rewrite_degenerate_phi): Delete.\n\t(rewrite_reductions_out_of_ssa): Delete.\n\t(rewrite_cross_bb_scalar_dependence): Delete.\n\t(handle_scalar_deps_crossing_scop_limits):\n\t(rewrite_cross_bb_scalar_deps): Delete.\n\t(build_poly_scop): Remove calls to out-of-ssa functions.\n\t* graphite.c (graphite_transform_loops): Early return in case of codegen error.\n\t* sese.c (debug_rename_map_1): Delete.\n\t(debug_rename_map): Delete.\n\t(sese_record_loop): Remove macro.\n\t(build_sese_loop_nests): Same.\n\t(new_sese_info): Same.\n\t(free_sese_info): Same.\n\t(sese_insert_phis_for_liveouts):\n\t(is_loop_closed_ssa_use): New.\n\t(number_of_phi_nodes): New.\n\t(bb_contains_loop_close_phi_nodes): New.\n\t(bb_contains_loop_phi_nodes): New.\n\t(phi_uses_name): New.\n\t(is_valid_rename):\n\t(get_rename): Add old_bb and loop_phi for more precise matching of\n\texprs.\n\t(set_rename): Pass region.\n\t(later_of_the_two): New.\n\t(gsi_insert_earliest): New.\n\t(collect_all_ssa_names): New.\n\t(substitute_ssa_name): New.\n\t(rename_all_uses): New.\n\t(get_rename_from_scev): New.\n\t(rename_uses): Pass old_bb for more precise matching of exprs.\n\t(get_def_bb_for_const): New.\n\t(get_new_name): New.\n\t(get_loc): New.\n\t(get_edges): New.\n\t(copy_loop_phi_args): New.\n\t(copy_loop_phi_nodes): New.\n\t(get_loop_init_value): New.\n\t(find_init_value): New.\n\t(find_init_value_close_phi): New.\n\t(copy_loop_close_phi_args): New.\n\t(copy_loop_close_phi_nodes): New.\n\t(add_phi_arg_for_new_expr): New.\n\t(copy_cond_phi_args): New.\n\t(copy_cond_phi_nodes): New.\n\t(copy_phi_nodes): New.\n\t(should_copy_to_new_region): New.\n\t(set_rename_for_each_def): New.\n\t(graphite_copy_stmts_from_block): Early return in case of error.\n\t(copy_bb_and_scalar_dependences): Same.\n\t* sese.h (vec_find): New.\n\t(SESE_PARAMS): Delete.\n\t(SESE_LOOPS): Delete.\n\t(SESE_LOOP_NEST): Delete.\n\t(sese_contains_loop): Remove macro usage.\n\t(sese_nb_params): Same.\n\t(struct gimple_poly_bb): Added read_scalar_refs, write_scalar_refs.\n\nCo-Authored-By: Sebastian Pop <s.pop@samsung.com>\n\nFrom-SVN: r230200", "tree": {"sha": "060abae1fd33510d658454e5540d87444d3babb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/060abae1fd33510d658454e5540d87444d3babb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65b016eb13b67dd990f30a55948a623d9deadd11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65b016eb13b67dd990f30a55948a623d9deadd11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65b016eb13b67dd990f30a55948a623d9deadd11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65b016eb13b67dd990f30a55948a623d9deadd11/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f891c4f0b39ac7b3788ab8bc2bdf73b63dd6b88e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f891c4f0b39ac7b3788ab8bc2bdf73b63dd6b88e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f891c4f0b39ac7b3788ab8bc2bdf73b63dd6b88e"}], "stats": {"total": 2953, "additions": 1978, "deletions": 975}, "files": [{"sha": "fcf0bf66fabcb6936761645dfbd22555d0c24f70", "filename": "gcc/ChangeLog", "status": "modified", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65b016eb13b67dd990f30a55948a623d9deadd11/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65b016eb13b67dd990f30a55948a623d9deadd11/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65b016eb13b67dd990f30a55948a623d9deadd11", "patch": "@@ -1,3 +1,117 @@\n+2015-11-11  Aditya Kumar  <aditya.k7@samsung.com>\n+\t    Sebastian Pop  <s.pop@samsung.com>\n+\n+\t* graphite-isl-ast-to-gimple.c (class translate_isl_ast_to_gimple):\n+\tNew member codegen_error\n+\t(translate_isl_ast_for_loop): Remove call to single_succ_edge and\n+\tearly return.\n+\t(translate_isl_ast_node_user): Early return in case of error.\n+\t(translate_isl_ast_to_gimple::translate_isl_ast): Same.\n+\t(translate_isl_ast_to_gimple::translate_pending_phi_nodes): New.\n+\t(add_parameters_to_ivs_params): Remove macro.\n+\t(graphite_regenerate_ast_isl): Add if_region pointer to region.\n+\t* graphite-poly.c (new_poly_dr): Remove macro.\n+\t(print_pdr): Same.\n+\t(new_gimple_poly_bb): Same.\n+\t(free_gimple_poly_bb): Same.\n+\t(print_scop_params): Same.\n+\t* graphite-poly.h (struct poly_dr): Same.\n+\t(struct poly_bb): Add new_bb.\n+\t(gbb_from_bb): Remove dead code.\n+\t(pbb_from_bb): Same.\n+\t* graphite-scop-detection.c (parameter_index_in_region_1): Same.\n+\t(parameter_index_in_region): Same.\n+\t(find_scop_parameters): Same.\n+\t(build_cross_bb_scalars_def): New.\n+\t(build_cross_bb_scalars_use): New.\n+\t(graphite_find_cross_bb_scalar_vars): New\n+\t(try_generate_gimple_bb): Reads and Writes.\n+\t(build_alias_set): Move.\n+\t(gather_bbs::before_dom_children): Gather bbs visited.\n+\t(build_scops): call build_alias_set.\n+\t* graphite-sese-to-poly.c (phi_arg_in_outermost_loop): Delete.\n+\t(remove_simple_copy_phi): Delete.\n+\t(remove_invariant_phi): Delete.\n+\t(simple_copy_phi_p): Delete.\n+\t(reduction_phi_p): Delete.\n+\t(isl_id_for_dr): Remove unused param.\n+\t(parameter_index_in_region_1): Remove macro usage.\n+\t(set_scop_parameter_dim): Same.\n+\t(add_param_constraints): Same.\n+\t(add_conditions_to_constraints): Same\n+\t(build_scop_iteration_domain): Same.\n+\t(pdr_add_alias_set): Comment.\n+\t(add_scalar_version_numbers): New.\n+\t(build_poly_dr): ISL id.\n+\t(build_scop_drs): Move.\n+\t(build_poly_sr_1): Same.\n+\t(insert_stmts): Remove.\n+\t(build_poly_sr): New.\n+\t(new_pbb_from_pbb): Delete.\n+\t(insert_out_of_ssa_copy_on_edge): Delete.\n+\t(create_zero_dim_array): Delete.\n+\t(scalar_close_phi_node_p): Delete.\n+\t(propagate_expr_outside_region): Delete.\n+\t(rewrite_close_phi_out_of_ssa): Delete.\n+\t(rewrite_phi_out_of_ssa): Delete.\n+\t(rewrite_degenerate_phi): Delete.\n+\t(rewrite_reductions_out_of_ssa): Delete.\n+\t(rewrite_cross_bb_scalar_dependence): Delete.\n+\t(handle_scalar_deps_crossing_scop_limits):\n+\t(rewrite_cross_bb_scalar_deps): Delete.\n+\t(build_poly_scop): Remove calls to out-of-ssa functions.\n+\t* graphite.c (graphite_transform_loops): Early return in case of\n+\tcodegen error.\n+\t* sese.c (debug_rename_map_1): Delete.\n+\t(debug_rename_map): Delete.\n+\t(sese_record_loop): Remove macro.\n+\t(build_sese_loop_nests): Same.\n+\t(new_sese_info): Same.\n+\t(free_sese_info): Same.\n+\t(sese_insert_phis_for_liveouts):\n+\t(is_loop_closed_ssa_use): New.\n+\t(number_of_phi_nodes): New.\n+\t(bb_contains_loop_close_phi_nodes): New.\n+\t(bb_contains_loop_phi_nodes): New.\n+\t(phi_uses_name): New.\n+\t(is_valid_rename):\n+\t(get_rename): Add old_bb and loop_phi for more precise matching of\n+\texprs.\n+\t(set_rename): Pass region.\n+\t(later_of_the_two): New.\n+\t(gsi_insert_earliest): New.\n+\t(collect_all_ssa_names): New.\n+\t(substitute_ssa_name): New.\n+\t(rename_all_uses): New.\n+\t(get_rename_from_scev): New.\n+\t(rename_uses): Pass old_bb for more precise matching of exprs.\n+\t(get_def_bb_for_const): New.\n+\t(get_new_name): New.\n+\t(get_loc): New.\n+\t(get_edges): New.\n+\t(copy_loop_phi_args): New.\n+\t(copy_loop_phi_nodes): New.\n+\t(get_loop_init_value): New.\n+\t(find_init_value): New.\n+\t(find_init_value_close_phi): New.\n+\t(copy_loop_close_phi_args): New.\n+\t(copy_loop_close_phi_nodes): New.\n+\t(add_phi_arg_for_new_expr): New.\n+\t(copy_cond_phi_args): New.\n+\t(copy_cond_phi_nodes): New.\n+\t(copy_phi_nodes): New.\n+\t(should_copy_to_new_region): New.\n+\t(set_rename_for_each_def): New.\n+\t(graphite_copy_stmts_from_block): Early return in case of error.\n+\t(copy_bb_and_scalar_dependences): Same.\n+\t* sese.h (vec_find): New.\n+\t(SESE_PARAMS): Delete.\n+\t(SESE_LOOPS): Delete.\n+\t(SESE_LOOP_NEST): Delete.\n+\t(sese_contains_loop): Remove macro usage.\n+\t(sese_nb_params): Same.\n+\t(struct gimple_poly_bb): Added read_scalar_refs, write_scalar_refs.\n+\n 2015-11-11  Abderrazek Zaafrani  <a.zaafrani@samsung.com>\n \n \t* graphite-sese-to-poly.c (build_scop_original_schedule): Call"}, {"sha": "7fa4ce3d395ef13cd36606ecc4db3bc15d0313f5", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 117, "deletions": 34, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65b016eb13b67dd990f30a55948a623d9deadd11/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65b016eb13b67dd990f30a55948a623d9deadd11/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=65b016eb13b67dd990f30a55948a623d9deadd11", "patch": "@@ -63,11 +63,7 @@ extern \"C\" {\n #include <map>\n #include \"graphite-isl-ast-to-gimple.h\"\n #include \"tree-cfg.h\"\n-\n-/* This flag is set when an error occurred during the translation of\n-   ISL AST to Gimple.  */\n-\n-static bool graphite_regenerate_error;\n+#include \"gimple-pretty-print.h\"\n \n /* We always try to use signed 128 bit types, but fall back to smaller types\n    in case a platform does not provide types of these sizes. In the future we\n@@ -132,7 +128,7 @@ class translate_isl_ast_to_gimple\n {\n  public:\n   translate_isl_ast_to_gimple (sese_info_p r)\n-    : region (r)\n+    : region (r), codegen_error (false)\n   { }\n \n   /* Translates an ISL AST node NODE to GCC representation in the\n@@ -261,8 +257,17 @@ class translate_isl_ast_to_gimple\n   void build_iv_mapping (vec<tree> iv_map, gimple_poly_bb_p gbb,\n \t\t\t __isl_keep isl_ast_expr *user_expr, ivs_params &ip,\n \t\t\t sese_l &region);\n+\n+  void translate_pending_phi_nodes (void);\n+\n+  bool codegen_error_p () { return codegen_error; }\n+\n private:\n   sese_info_p region;\n+\n+  /* This flag is set when an error occurred during the translation of ISL AST\n+     to Gimple.  */\n+  bool codegen_error;\n };\n \n /* Return the tree variable that corresponds to the given isl ast identifier\n@@ -575,13 +580,15 @@ translate_isl_ast_for_loop (loop_p context_loop,\n   edge to_body = single_succ_edge (loop->header);\n   basic_block after = to_body->dest;\n \n-  /* Create a basic block for loop close phi nodes.  */\n-  last_e = single_succ_edge (split_edge (last_e));\n-\n   /* Translate the body of the loop.  */\n   isl_ast_node *for_body = isl_ast_node_for_get_body (node_for);\n   next_e = translate_isl_ast (loop, for_body, to_body, ip);\n   isl_ast_node_free (for_body);\n+\n+  /* Early return if we failed to translate loop body.  */\n+  if (!next_e || codegen_error)\n+    return NULL;\n+\n   redirect_edge_succ_nodup (next_e, after);\n   set_immediate_dominator (CDI_DOMINATORS, next_e->dest, next_e->src);\n \n@@ -770,21 +777,25 @@ translate_isl_ast_node_user (__isl_keep isl_ast_node *node,\n \t\t\t     edge next_e, ivs_params &ip)\n {\n   gcc_assert (isl_ast_node_get_type (node) == isl_ast_node_user);\n+\n   isl_ast_expr *user_expr = isl_ast_node_user_get_expr (node);\n   isl_ast_expr *name_expr = isl_ast_expr_get_op_arg (user_expr, 0);\n   gcc_assert (isl_ast_expr_get_type (name_expr) == isl_ast_expr_id);\n+\n   isl_id *name_id = isl_ast_expr_get_id (name_expr);\n   poly_bb_p pbb = (poly_bb_p) isl_id_get_user (name_id);\n   gcc_assert (pbb);\n+\n   gimple_poly_bb_p gbb = PBB_BLACK_BOX (pbb);\n-  vec<tree> iv_map;\n+\n   isl_ast_expr_free (name_expr);\n   isl_id_free (name_id);\n \n   gcc_assert (GBB_BB (gbb) != ENTRY_BLOCK_PTR_FOR_FN (cfun) &&\n \t      \"The entry block should not even appear within a scop\");\n \n   int nb_loops = number_of_loops (cfun);\n+  vec<tree> iv_map;\n   iv_map.create (nb_loops);\n   iv_map.safe_grow_cleared (nb_loops);\n \n@@ -793,23 +804,35 @@ translate_isl_ast_node_user (__isl_keep isl_ast_node *node,\n \n   if (dump_file)\n     {\n-      fprintf (dump_file, \"[codegen] copying\");\n+      fprintf (dump_file, \"[codegen] copying from basic block\\n\");\n       print_loops_bb (dump_file, GBB_BB (gbb), 0, 3);\n+      fprintf (dump_file, \"\\n[codegen] to new basic block\\n\");\n+      print_loops_bb (dump_file, next_e->src, 0, 3);\n     }\n \n   next_e = copy_bb_and_scalar_dependences (GBB_BB (gbb),\n \t\t\t\t\t   pbb->scop->scop_info, next_e,\n \t\t\t\t\t   iv_map,\n-\t\t\t\t\t   &graphite_regenerate_error);\n+\t\t\t\t\t   &codegen_error);\n+  if (codegen_error)\n+    return NULL;\n+\n   if (dump_file)\n     {\n-      fprintf (dump_file, \"[codegen] to\");\n+      fprintf (dump_file, \"\\n[codegen] (after copy) new basic block\\n\");\n       print_loops_bb (dump_file, next_e->src, 0, 3);\n     }\n \n   iv_map.release ();\n   mark_virtual_operands_for_renaming (cfun);\n   update_ssa (TODO_update_ssa);\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\n[codegen] (after update SSA) new basic block\\n\");\n+      print_loops_bb (dump_file, next_e->src, 0, 3);\n+    }\n+\n   return next_e;\n }\n \n@@ -881,6 +904,9 @@ translate_isl_ast_to_gimple::translate_isl_ast (loop_p context_loop,\n \t\t\t\t\t\t__isl_keep isl_ast_node *node,\n \t\t\t\t\t\tedge next_e, ivs_params &ip)\n {\n+  if (codegen_error)\n+    return NULL;\n+\n   switch (isl_ast_node_get_type (node))\n     {\n     case isl_ast_node_error:\n@@ -906,6 +932,47 @@ translate_isl_ast_to_gimple::translate_isl_ast (loop_p context_loop,\n     }\n }\n \n+/* Patch the missing arguments of the phi nodes.  */\n+\n+void\n+translate_isl_ast_to_gimple::translate_pending_phi_nodes ()\n+{\n+  int i;\n+  phi_rename *rename;\n+  FOR_EACH_VEC_ELT (region->incomplete_phis, i, rename)\n+    {\n+      gphi *old_phi = rename->first;\n+      gphi *new_phi = rename->second;\n+      basic_block old_bb = gimple_bb (old_phi);\n+      basic_block new_bb = gimple_bb (new_phi);\n+\n+      /* First edge is the init edge and second is the back edge.  */\n+      init_back_edge_pair_t ibp_old_bb = get_edges (old_bb);\n+      init_back_edge_pair_t ibp_new_bb = get_edges (new_bb);\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"\\n[codegen] translating pending old-phi: \");\n+\t  print_gimple_stmt (dump_file, old_phi, 0, 0);\n+\t}\n+\n+      auto_vec <tree, 1> iv_map;\n+      if (bb_contains_loop_phi_nodes (new_bb))\n+\tcopy_loop_phi_args (old_phi, ibp_old_bb, new_phi,\n+\t\t\t    ibp_new_bb, region, false);\n+      else if (bb_contains_loop_close_phi_nodes (new_bb))\n+\tcopy_loop_close_phi_args (old_bb, new_bb, region, false);\n+      else if (!copy_cond_phi_args (old_phi, new_phi, iv_map, region, false))\n+\tgcc_unreachable ();\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"[codegen] to new-phi: \");\n+\t  print_gimple_stmt (dump_file, new_phi, 0, 0);\n+\t}\n+    }\n+}\n+\n /* Prints NODE to FILE.  */\n \n void\n@@ -926,13 +993,13 @@ add_parameters_to_ivs_params (scop_p scop, ivs_params &ip)\n {\n   sese_info_p region = scop->scop_info;\n   unsigned nb_parameters = isl_set_dim (scop->param_context, isl_dim_param);\n-  gcc_assert (nb_parameters == SESE_PARAMS (region).length ());\n+  gcc_assert (nb_parameters == region->params.length ());\n   unsigned i;\n   for (i = 0; i < nb_parameters; i++)\n     {\n       isl_id *tmp_id = isl_set_get_dim_id (scop->param_context,\n                                            isl_dim_param, i);\n-      ip[tmp_id] = SESE_PARAMS (region)[i];\n+      ip[tmp_id] = region->params[i];\n     }\n }\n \n@@ -1101,7 +1168,6 @@ graphite_regenerate_ast_isl (scop_p scop)\n   ivs_params ip;\n \n   timevar_push (TV_GRAPHITE_CODE_GEN);\n-  graphite_regenerate_error = false;\n   root_node = scop_to_isl_ast (scop, ip);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1115,30 +1181,47 @@ graphite_regenerate_ast_isl (scop_p scop)\n   graphite_verify ();\n \n   if_region = move_sese_in_condition (region);\n-  sese_insert_phis_for_liveouts (region,\n-\t\t\t\t if_region->region->region.exit->src,\n-\t\t\t\t if_region->false_region->region.exit,\n-\t\t\t\t if_region->true_region->region.exit);\n+  region->if_region = if_region;\n   recompute_all_dominators ();\n-  graphite_verify ();\n \n   context_loop = region->region.entry->src->loop_father;\n \n   translate_isl_ast_to_gimple t(region);\n   edge e = single_succ_edge (if_region->true_region->region.entry->dest);\n-  split_edge (e);\n-  t.translate_isl_ast (context_loop, root_node, e, ip);\n+  basic_block bb = split_edge (e);\n+  /* Update the true_region exit edge.  */\n+  region->if_region->true_region->region.exit = single_succ_edge (bb);\n \n-  mark_virtual_operands_for_renaming (cfun);\n-  update_ssa (TODO_update_ssa);\n-\n-  graphite_verify ();\n-  scev_reset ();\n-  recompute_all_dominators ();\n-  graphite_verify ();\n-\n-  if (graphite_regenerate_error)\n-    set_ifsese_condition (if_region, integer_zero_node);\n+  t.translate_isl_ast (context_loop, root_node, e, ip);\n+  if (t.codegen_error_p ())\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\n[codegen] unsuccessful, \"\n+\t\t \"reverting back to the original code.\");\n+      set_ifsese_condition (if_region, integer_zero_node);\n+    }\n+  else\n+    {\n+      t.translate_pending_phi_nodes ();\n+      if (!t.codegen_error_p ())\n+\t{\n+\t  sese_insert_phis_for_liveouts (region,\n+\t\t\t\t\t if_region->region->region.exit->src,\n+\t\t\t\t\t if_region->false_region->region.exit,\n+\t\t\t\t\t if_region->true_region->region.exit);\n+\t  mark_virtual_operands_for_renaming (cfun);\n+\t  update_ssa (TODO_update_ssa);\n+\n+\n+\t  graphite_verify ();\n+\t  scev_reset ();\n+\t  recompute_all_dominators ();\n+\t  graphite_verify ();\n+\t}\n+      else if (dump_file)\n+\tfprintf (dump_file, \"\\n[codegen] unsuccessful in translating \"\n+\t\t \"pending phis, reverting back to the original code.\");\n+    }\n \n   free (if_region->true_region);\n   free (if_region->region);\n@@ -1161,6 +1244,6 @@ graphite_regenerate_ast_isl (scop_p scop)\n \t       num_no_dependency);\n     }\n \n-  return !graphite_regenerate_error;\n+  return !t.codegen_error_p ();\n }\n #endif  /* HAVE_isl */"}, {"sha": "5928b4ce60643480b88682f77a8ac41bbc51cbff", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65b016eb13b67dd990f30a55948a623d9deadd11/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65b016eb13b67dd990f30a55948a623d9deadd11/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=65b016eb13b67dd990f30a55948a623d9deadd11", "patch": "@@ -132,21 +132,19 @@ apply_poly_transforms (scop_p scop)\n    NB_SUBSCRIPTS.  */\n \n void\n-new_poly_dr (poly_bb_p pbb, enum poly_dr_type type, data_reference_p cdr,\n-\t     graphite_dim_t nb_subscripts,\n+new_poly_dr (poly_bb_p pbb, gimple *stmt, enum poly_dr_type type,\n \t     isl_map *acc, isl_set *subscript_sizes)\n {\n   static int id = 0;\n   poly_dr_p pdr = XNEW (struct poly_dr);\n \n+  pdr->stmt = stmt;\n   PDR_ID (pdr) = id++;\n   PDR_NB_REFS (pdr) = 1;\n   PDR_PBB (pdr) = pbb;\n   pdr->accesses = acc;\n   pdr->subscript_sizes = subscript_sizes;\n   PDR_TYPE (pdr) = type;\n-  PDR_CDR (pdr) = cdr;\n-  PDR_NB_SUBSCRIPTS (pdr) = nb_subscripts;\n   PBB_DRS (pbb).safe_push (pdr);\n }\n \n@@ -226,6 +224,8 @@ print_pdr (FILE *file, poly_dr_p pdr)\n       gcc_unreachable ();\n     }\n \n+  fprintf (file, \"in gimple stmt: \");\n+  print_gimple_stmt (file, pdr->stmt, 0, 0);\n   fprintf (file, \"data accesses: \");\n   print_isl_map (file, pdr->accesses);\n   fprintf (file, \"subscript sizes: \");\n@@ -244,14 +244,14 @@ debug_pdr (poly_dr_p pdr)\n /* Store the GRAPHITE representation of BB.  */\n \n gimple_poly_bb_p\n-new_gimple_poly_bb (basic_block bb, vec<data_reference_p> drs)\n+new_gimple_poly_bb (basic_block bb, vec<data_reference_p> drs,\n+\t\t    vec<scalar_use> reads, vec<tree> writes)\n {\n-  gimple_poly_bb_p gbb;\n-\n-  gbb = XNEW (struct gimple_poly_bb);\n-  bb->aux = gbb;\n+  gimple_poly_bb_p gbb = XNEW (struct gimple_poly_bb);\n   GBB_BB (gbb) = bb;\n   GBB_DATA_REFS (gbb) = drs;\n+  gbb->read_scalar_refs = reads;\n+  gbb->write_scalar_refs = writes;\n   GBB_CONDITIONS (gbb).create (0);\n   GBB_CONDITION_CASES (gbb).create (0);\n \n@@ -264,10 +264,10 @@ void\n free_gimple_poly_bb (gimple_poly_bb_p gbb)\n {\n   free_data_refs (GBB_DATA_REFS (gbb));\n-\n   GBB_CONDITIONS (gbb).release ();\n   GBB_CONDITION_CASES (gbb).release ();\n-  GBB_BB (gbb)->aux = 0;\n+  gbb->read_scalar_refs.release ();\n+  gbb->write_scalar_refs.release ();\n   XDELETE (gbb);\n }\n \n@@ -477,13 +477,13 @@ print_pbb (FILE *file, poly_bb_p pbb)\n void\n print_scop_params (FILE *file, scop_p scop)\n {\n-  if (SESE_PARAMS (scop->scop_info).is_empty ())\n+  if (scop->scop_info->params.is_empty ())\n     return;\n \n   int i;\n   tree t;\n   fprintf (file, \"parameters (\");\n-  FOR_EACH_VEC_ELT (SESE_PARAMS (scop->scop_info), i, t)\n+  FOR_EACH_VEC_ELT (scop->scop_info->params, i, t)\n     {\n       print_generic_expr (file, t, 0);\n       fprintf (file, \", \");"}, {"sha": "3fcbbaf5c38022f141b733831cceeda0e27011ad", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 9, "deletions": 26, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65b016eb13b67dd990f30a55948a623d9deadd11/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65b016eb13b67dd990f30a55948a623d9deadd11/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=65b016eb13b67dd990f30a55948a623d9deadd11", "patch": "@@ -58,8 +58,8 @@ struct poly_dr\n   /* The number of data refs identical to this one in the PBB.  */\n   int nb_refs;\n \n-  /* A pointer to compiler's data reference description.  */\n-  data_reference_p compiler_dr;\n+  /* A pointer to the gimple stmt containing this reference.  */\n+  gimple *stmt;\n \n   /* A pointer to the PBB that contains this data reference.  */\n   poly_bb_p pbb;\n@@ -181,21 +181,16 @@ struct poly_dr\n      In the example, the vector \"R C O I L P\" is \"7 7 3 2 0 1\".  */\n   isl_map *accesses;\n   isl_set *subscript_sizes;\n-\n-  /* The number of subscripts.  */\n-  graphite_dim_t nb_subscripts;\n };\n \n #define PDR_ID(PDR) (PDR->id)\n #define PDR_NB_REFS(PDR) (PDR->nb_refs)\n-#define PDR_CDR(PDR) (PDR->compiler_dr)\n #define PDR_PBB(PDR) (PDR->pbb)\n #define PDR_TYPE(PDR) (PDR->type)\n #define PDR_ACCESSES(PDR) (NULL)\n-#define PDR_NB_SUBSCRIPTS(PDR) (PDR->nb_subscripts)\n \n-void new_poly_dr (poly_bb_p, enum poly_dr_type, data_reference_p,\n-\t\t  graphite_dim_t, isl_map *, isl_set *);\n+void new_poly_dr (poly_bb_p, gimple *, enum poly_dr_type,\n+\t\t  isl_map *, isl_set *);\n void free_poly_dr (poly_dr_p);\n void debug_pdr (poly_dr_p);\n void print_pdr (FILE *, poly_dr_p);\n@@ -270,6 +265,9 @@ struct poly_bb\n \n   /* True when this PBB contains only a reduction statement.  */\n   bool is_reduction;\n+\n+  /* The last basic block generated for this pbb.  */\n+  basic_block new_bb;\n };\n \n #define PBB_BLACK_BOX(PBB) ((gimple_poly_bb_p) PBB->black_box)\n@@ -314,22 +312,6 @@ extern bool optimize_isl (scop_p);\n extern void pbb_number_of_iterations_at_time (poly_bb_p, graphite_dim_t, mpz_t);\n extern void debug_gmp_value (mpz_t);\n \n-/* Returns a gimple_bb from BB.  */\n-\n-static inline gimple_poly_bb_p\n-gbb_from_bb (basic_block bb)\n-{\n-  return (gimple_poly_bb_p) bb->aux;\n-}\n-\n-/* The poly_bb of the BB.  */\n-\n-static inline poly_bb_p\n-pbb_from_bb (basic_block bb)\n-{\n-  return GBB_PBB (gbb_from_bb (bb));\n-}\n-\n /* The basic block of the PBB.  */\n \n static inline basic_block\n@@ -446,7 +428,8 @@ struct scop\n \n extern scop_p new_scop (edge, edge);\n extern void free_scop (scop_p);\n-extern gimple_poly_bb_p new_gimple_poly_bb (basic_block, vec<data_reference_p>);\n+extern gimple_poly_bb_p new_gimple_poly_bb (basic_block, vec<data_reference_p>,\n+\t\t\t\t\t    vec<scalar_use>, vec<tree>);\n extern void free_gimple_poly_bb (gimple_poly_bb_p);\n extern void print_generated_program (FILE *, scop_p);\n extern void debug_generated_program (scop_p);"}, {"sha": "a7179d97d8928d38fbbdf06d2edd2edf4a5e65c2", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 152, "deletions": 9, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65b016eb13b67dd990f30a55948a623d9deadd11/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65b016eb13b67dd990f30a55948a623d9deadd11/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=65b016eb13b67dd990f30a55948a623d9deadd11", "patch": "@@ -1507,7 +1507,7 @@ parameter_index_in_region_1 (tree name, sese_info_p region)\n \n   gcc_assert (TREE_CODE (name) == SSA_NAME);\n \n-  FOR_EACH_VEC_ELT (SESE_PARAMS (region), i, p)\n+  FOR_EACH_VEC_ELT (region->params, i, p)\n     if (p == name)\n       return i;\n \n@@ -1536,8 +1536,8 @@ parameter_index_in_region (tree name, sese_info_p region)\n   if (i != -1)\n     return i;\n \n-  i = SESE_PARAMS (region).length ();\n-  SESE_PARAMS (region).safe_push (name);\n+  i = region->params.length ();\n+  region->params.safe_push (name);\n   return i;\n }\n \n@@ -1635,7 +1635,7 @@ find_scop_parameters (scop_p scop)\n   struct loop *loop;\n \n   /* Find the parameters used in the loop bounds.  */\n-  FOR_EACH_VEC_ELT (SESE_LOOP_NEST (region), i, loop)\n+  FOR_EACH_VEC_ELT (region->loop_nest, i, loop)\n     {\n       tree nb_iters = number_of_latch_executions (loop);\n \n@@ -1655,32 +1655,166 @@ find_scop_parameters (scop_p scop)\n   scop_set_nb_params (scop, nbp);\n }\n \n+/* Record DEF if it is used in other bbs different than DEF_BB in the SCOP.  */\n+\n+static void\n+build_cross_bb_scalars_def (scop_p scop, tree def, basic_block def_bb,\n+\t\t\t     vec<tree> *writes)\n+{\n+  gcc_assert (def);\n+  if (!is_gimple_reg (def))\n+    return;\n+\n+  /* Do not gather scalar variables that can be analyzed by SCEV as they can be\n+     generated out of the induction variables.  */\n+  if (scev_analyzable_p (def, scop->scop_info->region))\n+    return;\n+\n+  gimple *use_stmt;\n+  imm_use_iterator imm_iter;\n+  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)\n+    if (def_bb != gimple_bb (use_stmt) && !is_gimple_debug (use_stmt))\n+      {\n+\twrites->safe_push (def);\n+\tDEBUG_PRINT (dp << \"Adding scalar write:\\n\";\n+\t\t     print_generic_expr (dump_file, def, 0);\n+\t\t     dp << \"From stmt:\\n\";\n+\t\t     print_gimple_stmt (dump_file,\n+\t\t\t\t\tSSA_NAME_DEF_STMT (def), 0, 0));\n+\t/* This is required by the FOR_EACH_IMM_USE_STMT when we want to break\n+\t   before all the uses have been visited.  */\n+\tBREAK_FROM_IMM_USE_STMT (imm_iter);\n+      }\n+}\n+\n+/* Record DEF if it is used in other bbs different than DEF_BB in the SCOP.  */\n+\n+static void\n+build_cross_bb_scalars_use (scop_p scop, tree use, gimple *use_stmt,\n+\t\t\t    vec<scalar_use> *reads)\n+{\n+  gcc_assert (use);\n+  if (!is_gimple_reg (use))\n+    return;\n+\n+  /* Do not gather scalar variables that can be analyzed by SCEV as they can be\n+     generated out of the induction variables.  */\n+  if (scev_analyzable_p (use, scop->scop_info->region))\n+    return;\n+\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (use);\n+  if (gimple_bb (def_stmt) != gimple_bb (use_stmt))\n+    {\n+      DEBUG_PRINT (dp << \"Adding scalar read:\\n\";\n+\t\t   print_generic_expr (dump_file, use, 0);\n+\t\t   dp << \"From stmt:\\n\";\n+\t\t   print_gimple_stmt (dump_file, use_stmt, 0, 0));\n+      reads->safe_push (std::make_pair (use_stmt, use));\n+    }\n+}\n+\n+/* Record all scalar variables that are defined and used in different BBs of the\n+   SCOP.  */\n+\n+static void\n+graphite_find_cross_bb_scalar_vars (scop_p scop, gimple *stmt,\n+\t\t\t\t    vec<scalar_use> *reads, vec<tree> *writes)\n+{\n+  tree def;\n+\n+  if (gimple_code (stmt) == GIMPLE_ASSIGN)\n+    def = gimple_assign_lhs (stmt);\n+  else if (gimple_code (stmt) == GIMPLE_CALL)\n+    def = gimple_call_lhs (stmt);\n+  else if (gimple_code (stmt) == GIMPLE_PHI)\n+    def = gimple_phi_result (stmt);\n+  else\n+    return;\n+\n+\n+  build_cross_bb_scalars_def (scop, def, gimple_bb (stmt), writes);\n+\n+  ssa_op_iter iter;\n+  use_operand_p use_p;\n+  FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, iter, SSA_OP_USE)\n+    {\n+      tree use = USE_FROM_PTR (use_p);\n+      build_cross_bb_scalars_use (scop, use, stmt, reads);\n+    }\n+}\n+\n /* Generates a polyhedral black box only if the bb contains interesting\n    information.  */\n \n static gimple_poly_bb_p\n try_generate_gimple_bb (scop_p scop, basic_block bb)\n {\n   vec<data_reference_p> drs;\n-  drs.create (5);\n+  drs.create (3);\n+  vec<tree> writes;\n+  writes.create (3);\n+  vec<scalar_use> reads;\n+  reads.create (3);\n+\n   sese_l region = scop->scop_info->region;\n   loop_p nest = outermost_loop_in_sese (region, bb);\n \n   loop_p loop = bb->loop_father;\n   if (!loop_in_sese_p (loop, region))\n     loop = nest;\n \n-  gimple_stmt_iterator gsi;\n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n     {\n       gimple *stmt = gsi_stmt (gsi);\n       if (is_gimple_debug (stmt))\n \tcontinue;\n \n       graphite_find_data_references_in_stmt (nest, loop, stmt, &drs);\n+      graphite_find_cross_bb_scalar_vars (scop, stmt, &reads, &writes);\n     }\n \n-  return new_gimple_poly_bb (bb, drs);\n+  for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);\n+       gsi_next (&psi))\n+    if (!virtual_operand_p (gimple_phi_result (psi.phi ())))\n+      graphite_find_cross_bb_scalar_vars (scop, psi.phi (), &reads, &writes);\n+\n+  if (drs.is_empty () && writes.is_empty () && reads.is_empty ())\n+    return NULL;\n+\n+  return new_gimple_poly_bb (bb, drs, reads, writes);\n+}\n+\n+/* Compute alias-sets for all data references in DRS.  */\n+\n+static void\n+build_alias_set (scop_p scop)\n+{\n+  int num_vertices = scop->drs.length ();\n+  struct graph *g = new_graph (num_vertices);\n+  dr_info *dr1, *dr2;\n+  int i, j;\n+  int *all_vertices;\n+\n+  FOR_EACH_VEC_ELT (scop->drs, i, dr1)\n+    for (j = i+1; scop->drs.iterate (j, &dr2); j++)\n+      if (dr_may_alias_p (dr1->dr, dr2->dr, true))\n+\t{\n+\t  add_edge (g, i, j);\n+\t  add_edge (g, j, i);\n+\t}\n+\n+  all_vertices = XNEWVEC (int, num_vertices);\n+  for (i = 0; i < num_vertices; i++)\n+    all_vertices[i] = i;\n+\n+  graphds_dfs (g, all_vertices, num_vertices, NULL, true, NULL);\n+  free (all_vertices);\n+\n+  for (i = 0; i < g->n_vertices; i++)\n+    scop->drs[i].alias_set = g->vertices[i].component + 1;\n+\n+  free_graph (g);\n }\n \n /* Gather BBs and conditions for a SCOP.  */\n@@ -1728,11 +1862,19 @@ gather_bbs::before_dom_children (basic_block bb)\n   scop->scop_info->bbs.safe_push (bb);\n \n   gimple_poly_bb_p gbb = try_generate_gimple_bb (scop, bb);\n+  if (!gbb)\n+    return;\n+\n   GBB_CONDITIONS (gbb) = conditions.copy ();\n   GBB_CONDITION_CASES (gbb) = cases.copy ();\n \n   poly_bb_p pbb = new_poly_bb (scop, gbb);\n   scop->pbbs.safe_push (pbb);\n+\n+  int i;\n+  data_reference_p dr;\n+  FOR_EACH_VEC_ELT (gbb->data_refs, i, dr)\n+    scop->drs.safe_push (dr_info (dr, pbb));\n }\n \n /* Call-back for dom_walk executed after visiting the dominated\n@@ -1776,6 +1918,8 @@ build_scops (vec<scop_p> *scops)\n       /* Record all basic blocks and their conditions in REGION.  */\n       gather_bbs (CDI_DOMINATORS, scop).walk (cfun->cfg->x_entry_block_ptr);\n \n+      build_alias_set (scop);\n+\n       /* Do not optimize a scop containing only PBBs that do not belong\n \t to any loops.  */\n       if (sb.nb_pbbs_in_loops (scop) == 0)\n@@ -1807,7 +1951,6 @@ build_scops (vec<scop_p> *scops)\n \t\t          << scop_nb_params (scop)\n \t\t          << \" larger than --param graphite-max-nb-scop-params=\"\n \t\t          << max_dim << \".\\n\");\n-\n \t  free_scop (scop);\n \t  continue;\n \t}"}, {"sha": "83acc4ac6ca0b13c5b5ad151e128a4ed14981567", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 76, "deletions": 723, "changes": 799, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65b016eb13b67dd990f30a55948a623d9deadd11/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65b016eb13b67dd990f30a55948a623d9deadd11/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=65b016eb13b67dd990f30a55948a623d9deadd11", "patch": "@@ -75,124 +75,6 @@ tree_int_to_gmp (tree t, mpz_t res)\n   wi::to_mpz (t, res, TYPE_SIGN (TREE_TYPE (t)));\n }\n \n-/* Returns the index of the PHI argument defined in the outermost\n-   loop.  */\n-\n-static size_t\n-phi_arg_in_outermost_loop (gphi *phi)\n-{\n-  loop_p loop = gimple_bb (phi)->loop_father;\n-  size_t i, res = 0;\n-\n-  for (i = 0; i < gimple_phi_num_args (phi); i++)\n-    if (!flow_bb_inside_loop_p (loop, gimple_phi_arg_edge (phi, i)->src))\n-      {\n-\tloop = gimple_phi_arg_edge (phi, i)->src->loop_father;\n-\tres = i;\n-      }\n-\n-  return res;\n-}\n-\n-/* Removes a simple copy phi node \"RES = phi (INIT, RES)\" at position\n-   PSI by inserting on the loop ENTRY edge assignment \"RES = INIT\".  */\n-\n-static void\n-remove_simple_copy_phi (gphi_iterator *psi)\n-{\n-  gphi *phi = psi->phi ();\n-  tree res = gimple_phi_result (phi);\n-  size_t entry = phi_arg_in_outermost_loop (phi);\n-  tree init = gimple_phi_arg_def (phi, entry);\n-  gassign *stmt = gimple_build_assign (res, init);\n-  edge e = gimple_phi_arg_edge (phi, entry);\n-\n-  remove_phi_node (psi, false);\n-  gsi_insert_on_edge_immediate (e, stmt);\n-}\n-\n-/* Removes an invariant phi node at position PSI by inserting on the\n-   loop ENTRY edge the assignment RES = INIT.  */\n-\n-static void\n-remove_invariant_phi (sese_l &region, gphi_iterator *psi)\n-{\n-  gphi *phi = psi->phi ();\n-  loop_p loop = loop_containing_stmt (phi);\n-  tree res = gimple_phi_result (phi);\n-  tree scev = scalar_evolution_in_region (region, loop, res);\n-  size_t entry = phi_arg_in_outermost_loop (phi);\n-  edge e = gimple_phi_arg_edge (phi, entry);\n-  tree var;\n-  gassign *stmt;\n-  gimple_seq stmts = NULL;\n-\n-  if (tree_contains_chrecs (scev, NULL))\n-    scev = gimple_phi_arg_def (phi, entry);\n-\n-  var = force_gimple_operand (scev, &stmts, true, NULL_TREE);\n-  stmt = gimple_build_assign (res, var);\n-  remove_phi_node (psi, false);\n-\n-  gimple_seq_add_stmt (&stmts, stmt);\n-  gsi_insert_seq_on_edge (e, stmts);\n-  gsi_commit_edge_inserts ();\n-  SSA_NAME_DEF_STMT (res) = stmt;\n-}\n-\n-/* Returns true when the phi node at PSI is of the form \"a = phi (a, x)\".  */\n-\n-static inline bool\n-simple_copy_phi_p (gphi *phi)\n-{\n-  if (gimple_phi_num_args (phi) != 2)\n-    return false;\n-\n-  tree res = gimple_phi_result (phi);\n-  return (res == gimple_phi_arg_def (phi, 0)\n-\t  || res == gimple_phi_arg_def (phi, 1));\n-}\n-\n-/* Returns true when the phi node at position PSI is a reduction phi\n-   node in REGION.  Otherwise moves the pointer PSI to the next phi to\n-   be considered.  */\n-\n-static bool\n-reduction_phi_p (sese_l &region, gphi_iterator *psi)\n-{\n-  loop_p loop;\n-  gphi *phi = psi->phi ();\n-  tree res = gimple_phi_result (phi);\n-\n-  loop = loop_containing_stmt (phi);\n-\n-  if (simple_copy_phi_p (phi))\n-    {\n-      /* PRE introduces phi nodes like these, for an example,\n-\t see id-5.f in the fortran graphite testsuite:\n-\n-\t # prephitmp.85_265 = PHI <prephitmp.85_258(33), prephitmp.85_265(18)>\n-      */\n-      remove_simple_copy_phi (psi);\n-      return false;\n-    }\n-\n-  if (scev_analyzable_p (res, region))\n-    {\n-      tree scev = scalar_evolution_in_region (region, loop, res);\n-\n-      if (evolution_function_is_invariant_p (scev, loop->num))\n-\tremove_invariant_phi (region, psi);\n-      else\n-\tgsi_next (psi);\n-\n-      return false;\n-    }\n-\n-  /* All the other cases are considered reductions.  */\n-  return true;\n-}\n-\n /* Return an ISL identifier for the polyhedral basic block PBB.  */\n \n static isl_id *\n@@ -532,14 +414,14 @@ isl_id_for_ssa_name (scop_p s, tree e)\n   return id;\n }\n \n-/* Return an ISL identifier for the data reference DR.  */\n+/* Return an ISL identifier for the data reference DR.  Data references and\n+   scalar references get the same isl_id.  They need to be comparable and are\n+   distinguished through the first dimension, which contains the alias set or\n+   SSA_NAME_VERSION number.  */\n \n static isl_id *\n-isl_id_for_dr (scop_p s, data_reference_p dr ATTRIBUTE_UNUSED)\n+isl_id_for_dr (scop_p s)\n {\n-  /* Data references all get the same isl_id.  They need to be comparable\n-     and are distinguished through the first dimension, which contains the\n-     alias set number.  */\n   return isl_id_alloc (s->isl_context, \"\", 0);\n }\n \n@@ -612,7 +494,7 @@ parameter_index_in_region_1 (tree name, sese_info_p region)\n \n   gcc_assert (TREE_CODE (name) == SSA_NAME);\n \n-  FOR_EACH_VEC_ELT (SESE_PARAMS (region), i, p)\n+  FOR_EACH_VEC_ELT (region->params, i, p)\n     if (p == name)\n       return i;\n \n@@ -700,7 +582,7 @@ set_scop_parameter_dim (scop_p scop)\n \n   unsigned i;\n   tree e;\n-  FOR_EACH_VEC_ELT (SESE_PARAMS (region), i, e)\n+  FOR_EACH_VEC_ELT (region->params, i, e)\n     space = isl_space_set_dim_id (space, isl_dim_param, i,\n                                   isl_id_for_ssa_name (scop, e));\n \n@@ -941,7 +823,7 @@ add_conditions_to_constraints (scop_p scop)\n static void\n add_param_constraints (scop_p scop, graphite_dim_t p)\n {\n-  tree parameter = SESE_PARAMS (scop->scop_info)[p];\n+  tree parameter = scop->scop_info->params[p];\n   tree type = TREE_TYPE (parameter);\n   tree lb = NULL_TREE;\n   tree ub = NULL_TREE;\n@@ -1021,7 +903,7 @@ build_scop_iteration_domain (scop_p scop)\n \n   int i;\n   struct loop *loop;\n-  FOR_EACH_VEC_ELT (SESE_LOOP_NEST (region), i, loop)\n+  FOR_EACH_VEC_ELT (region->loop_nest, i, loop)\n     if (!loop_in_sese_p (loop_outer (loop), region->region))\n       build_loop_iteration_domains (scop, loop, 0,\n \t\t\t\t    isl_set_copy (scop->param_context), doms);\n@@ -1057,12 +939,32 @@ pdr_add_alias_set (isl_map *acc, dr_info &dri)\n {\n   isl_constraint *c = isl_equality_alloc\n       (isl_local_space_from_space (isl_map_get_space (acc)));\n+  /* Positive numbers for all alias sets.  */\n   c = isl_constraint_set_constant_si (c, -dri.alias_set);\n   c = isl_constraint_set_coefficient_si (c, isl_dim_out, 0, 1);\n \n   return isl_map_add_constraint (acc, c);\n }\n \n+/* Add a constrain to the ACCESSES polyhedron for the alias set of\n+   data reference DR.  ACCESSP_NB_DIMS is the dimension of the\n+   ACCESSES polyhedron, DOM_NB_DIMS is the dimension of the iteration\n+   domain.  */\n+\n+static isl_map *\n+add_scalar_version_numbers (isl_map *acc, tree var)\n+{\n+  isl_constraint *c = isl_equality_alloc\n+      (isl_local_space_from_space (isl_map_get_space (acc)));\n+  int max_arrays = PARAM_VALUE (PARAM_GRAPHITE_MAX_ARRAYS_PER_SCOP);\n+  /* Each scalar variables has a unique alias set number starting from\n+     max_arrays.  */\n+  c = isl_constraint_set_constant_si (c, -max_arrays - SSA_NAME_VERSION (var));\n+  c = isl_constraint_set_coefficient_si (c, isl_dim_out, 0, 1);\n+\n+  return isl_map_add_constraint (acc, c);\n+}\n+\n /* Assign the affine expression INDEX to the output dimension POS of\n    MAP and return the result.  */\n \n@@ -1178,7 +1080,7 @@ pdr_add_data_dimensions (isl_set *subscript_sizes, scop_p scop,\n   return subscript_sizes;\n }\n \n-/* Build data accesses for DR in PBB.  */\n+/* Build data accesses for DRI.  */\n \n static void\n build_poly_dr (dr_info &dri)\n@@ -1188,6 +1090,7 @@ build_poly_dr (dr_info &dri)\n   poly_bb_p pbb = dri.pbb;\n   data_reference_p dr = dri.dr;\n   scop_p scop = PBB_SCOP (pbb);\n+  isl_id *id = isl_id_for_dr (scop);\n \n   {\n     isl_space *dc = isl_set_get_space (pbb->domain);\n@@ -1196,14 +1099,13 @@ build_poly_dr (dr_info &dri)\n \t\t\t\t\t   isl_dim_out, nb_out);\n \n     acc = isl_map_universe (space);\n-    acc = isl_map_set_tuple_id (acc, isl_dim_out, isl_id_for_dr (scop, dr));\n+    acc = isl_map_set_tuple_id (acc, isl_dim_out, isl_id_copy (id));\n   }\n \n   acc = pdr_add_alias_set (acc, dri);\n   acc = pdr_add_memory_accesses (acc, dri);\n \n   {\n-    isl_id *id = isl_id_for_dr (scop, dr);\n     int nb = 1 + DR_NUM_DIMENSIONS (dr);\n     isl_space *space = isl_space_set_alloc (scop->isl_context, 0, nb);\n \n@@ -1214,614 +1116,72 @@ build_poly_dr (dr_info &dri)\n     subscript_sizes = pdr_add_data_dimensions (subscript_sizes, scop, dr);\n   }\n \n-  new_poly_dr (pbb,\n-\t       DR_IS_READ (dr) ? PDR_READ : PDR_WRITE,\n-\t       dr, DR_NUM_DIMENSIONS (dr), acc, subscript_sizes);\n-}\n-\n-/* Compute alias-sets for all data references in DRS.  */\n-\n-static void\n-build_alias_set (scop_p scop)\n-{\n-  int num_vertices = scop->drs.length ();\n-  struct graph *g = new_graph (num_vertices);\n-  dr_info *dr1, *dr2;\n-  int i, j;\n-  int *all_vertices;\n-\n-  FOR_EACH_VEC_ELT (scop->drs, i, dr1)\n-    for (j = i+1; scop->drs.iterate (j, &dr2); j++)\n-      if (dr_may_alias_p (dr1->dr, dr2->dr, true))\n-\t{\n-\t  add_edge (g, i, j);\n-\t  add_edge (g, j, i);\n-\t}\n-\n-  all_vertices = XNEWVEC (int, num_vertices);\n-  for (i = 0; i < num_vertices; i++)\n-    all_vertices[i] = i;\n-\n-  graphds_dfs (g, all_vertices, num_vertices, NULL, true, NULL);\n-  free (all_vertices);\n-\n-  for (i = 0; i < g->n_vertices; i++)\n-    scop->drs[i].alias_set = g->vertices[i].component + 1;\n-\n-  free_graph (g);\n-}\n-\n-/* Build data references in SCOP.  */\n-\n-static void\n-build_scop_drs (scop_p scop)\n-{\n-  int i, j;\n-  poly_bb_p pbb;\n-\n-  /* Remove all the PBBs that do not have data references: these basic\n-     blocks are not handled in the polyhedral representation.  */\n-  for (i = 0; scop->pbbs.iterate (i, &pbb); i++)\n-    if (GBB_DATA_REFS (PBB_BLACK_BOX (pbb)).is_empty ())\n-      {\n-\tfree_gimple_poly_bb (PBB_BLACK_BOX (pbb));\n-\tfree_poly_bb (pbb);\n-\tscop->pbbs.ordered_remove (i);\n-\ti--;\n-      }\n-\n-  data_reference_p dr;\n-  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n-    if (pbb)\n-      FOR_EACH_VEC_ELT (GBB_DATA_REFS (PBB_BLACK_BOX (pbb)), j, dr)\n-\tscop->drs.safe_push (dr_info (dr, pbb));\n-\n-  build_alias_set (scop);\n-\n-  dr_info *dri;\n-  FOR_EACH_VEC_ELT (scop->drs, i, dri)\n-    build_poly_dr (*dri);\n+  new_poly_dr (pbb, DR_STMT (dr), DR_IS_READ (dr) ? PDR_READ : PDR_WRITE,\n+\t       acc, subscript_sizes);\n }\n \n-/* Analyze all the data references of STMTS and add them to the\n-   GBB_DATA_REFS vector of BB.  */\n-\n static void\n-analyze_drs_in_stmts (scop_p scop, basic_block bb, vec<gimple *> stmts)\n+build_poly_sr_1 (poly_bb_p pbb, gimple *stmt, tree var, enum poly_dr_type kind,\n+\t\t isl_map *acc, isl_set *subscript_sizes)\n {\n-  sese_l region = scop->scop_info->region;\n-  if (!bb_in_sese_p (bb, region))\n-    return;\n-\n-  loop_p nest = outermost_loop_in_sese (region, bb);\n-  loop_p loop = bb->loop_father;\n-  if (!loop_in_sese_p (loop, region))\n-    loop = nest;\n-\n-  gimple_poly_bb_p gbb = gbb_from_bb (bb);\n-\n-  gimple *stmt;\n-  int i;\n-  FOR_EACH_VEC_ELT (stmts, i, stmt)\n-    {\n-      if (is_gimple_debug (stmt))\n-\tcontinue;\n-\n-      graphite_find_data_references_in_stmt (nest, loop, stmt,\n-\t\t\t\t\t     &GBB_DATA_REFS (gbb));\n-    }\n-}\n-\n-/* Insert STMT at the end of the STMTS sequence and then insert the\n-   statements from STMTS at INSERT_GSI and call analyze_drs_in_stmts\n-   on STMTS.  */\n-\n-static void\n-insert_stmts (scop_p scop, gimple *stmt, gimple_seq stmts,\n-\t      gimple_stmt_iterator insert_gsi)\n-{\n-  gimple_stmt_iterator gsi;\n-  auto_vec<gimple *, 3> x;\n-\n-  gimple_seq_add_stmt (&stmts, stmt);\n-  for (gsi = gsi_start (stmts); !gsi_end_p (gsi); gsi_next (&gsi))\n-    x.safe_push (gsi_stmt (gsi));\n-\n-  gsi_insert_seq_before (&insert_gsi, stmts, GSI_SAME_STMT);\n-  analyze_drs_in_stmts (scop, gsi_bb (insert_gsi), x);\n+  int max_arrays = PARAM_VALUE (PARAM_GRAPHITE_MAX_ARRAYS_PER_SCOP);\n+  /* Each scalar variables has a unique alias set number starting from\n+     max_arrays.  */\n+  subscript_sizes = isl_set_fix_si (subscript_sizes, isl_dim_set, 0,\n+\t\t\t\t    max_arrays + SSA_NAME_VERSION (var));\n+\n+  new_poly_dr (pbb, stmt, kind, add_scalar_version_numbers (acc, var),\n+\t       subscript_sizes);\n }\n \n-/* Insert the assignment \"RES := EXPR\" just after AFTER_STMT.  */\n+/* Record all cross basic block scalar variables in PBB.  */\n \n static void\n-insert_out_of_ssa_copy (scop_p scop, tree res, tree expr, gimple *after_stmt)\n+build_poly_sr (poly_bb_p pbb)\n {\n-  gimple_stmt_iterator gsi;\n-  auto_vec<gimple *, 3> x;\n-  gimple_seq stmts;\n-  tree var = force_gimple_operand (expr, &stmts, true, NULL_TREE);\n-  gassign *stmt = gimple_build_assign (unshare_expr (res), var);\n-\n-  gimple_seq_add_stmt (&stmts, stmt);\n-\n-  for (gsi = gsi_start (stmts); !gsi_end_p (gsi); gsi_next (&gsi))\n-    x.safe_push (gsi_stmt (gsi));\n-\n-  if (gimple_code (after_stmt) == GIMPLE_PHI)\n-    {\n-      gsi = gsi_after_labels (gimple_bb (after_stmt));\n-      gsi_insert_seq_before (&gsi, stmts, GSI_NEW_STMT);\n-    }\n-  else\n-    {\n-      gsi = gsi_for_stmt (after_stmt);\n-      gsi_insert_seq_after (&gsi, stmts, GSI_NEW_STMT);\n-    }\n-\n-  analyze_drs_in_stmts (scop, gimple_bb (after_stmt), x);\n-}\n-\n-/* Creates a poly_bb_p for basic_block BB from the existing PBB.  */\n-\n-static void\n-new_pbb_from_pbb (scop_p scop, poly_bb_p pbb, basic_block bb)\n-{\n-  vec<data_reference_p> drs;\n-  drs.create (3);\n+  scop_p scop = PBB_SCOP (pbb);\n   gimple_poly_bb_p gbb = PBB_BLACK_BOX (pbb);\n-  gimple_poly_bb_p gbb1 = new_gimple_poly_bb (bb, drs);\n-  poly_bb_p pbb1 = new_poly_bb (scop, gbb1);\n-  int index, n = scop->pbbs.length ();\n-\n-  for (index = 0; index < n; index++)\n-    if (scop->pbbs[index] == pbb)\n-      break;\n-\n-  pbb1->domain = isl_set_copy (pbb->domain);\n-  pbb1->domain = isl_set_set_tuple_id (pbb1->domain,\n-\t\t\t\t       isl_id_for_pbb (scop, pbb1));\n-\n-  GBB_PBB (gbb1) = pbb1;\n-  GBB_CONDITIONS (gbb1) = GBB_CONDITIONS (gbb).copy ();\n-  GBB_CONDITION_CASES (gbb1) = GBB_CONDITION_CASES (gbb).copy ();\n-  scop->pbbs.safe_insert (index + 1, pbb1);\n-}\n-\n-/* Insert on edge E the assignment \"RES := EXPR\".  */\n-\n-static void\n-insert_out_of_ssa_copy_on_edge (scop_p scop, edge e, tree res, tree expr)\n-{\n-  gimple_seq stmts = NULL;\n-  tree var = force_gimple_operand (expr, &stmts, true, NULL_TREE);\n-  gimple *stmt = gimple_build_assign (unshare_expr (res), var);\n-  auto_vec<gimple *, 3> x;\n-\n-  gimple_seq_add_stmt (&stmts, stmt);\n-  gimple_stmt_iterator gsi;\n-  for (gsi = gsi_start (stmts); !gsi_end_p (gsi); gsi_next (&gsi))\n-    x.safe_push (gsi_stmt (gsi));\n-\n-  gsi_insert_seq_on_edge (e, stmts);\n-  gsi_commit_edge_inserts ();\n-  basic_block bb = gimple_bb (stmt);\n-\n-  if (!bb_in_sese_p (bb, scop->scop_info->region))\n-    return;\n-\n-  if (!gbb_from_bb (bb))\n-    new_pbb_from_pbb (scop, pbb_from_bb (e->src), bb);\n-\n-  analyze_drs_in_stmts (scop, bb, x);\n-}\n-\n-/* Creates a zero dimension array of the same type as VAR.  */\n-\n-static tree\n-create_zero_dim_array (tree var, const char *base_name)\n-{\n-  tree index_type = build_index_type (integer_zero_node);\n-  tree elt_type = TREE_TYPE (var);\n-  tree array_type = build_array_type (elt_type, index_type);\n-  tree base = create_tmp_var (array_type, base_name);\n-\n-  return build4 (ARRAY_REF, elt_type, base, integer_zero_node, NULL_TREE,\n-\t\t NULL_TREE);\n-}\n-\n-/* Returns true when PHI is a loop close phi node.  */\n-\n-static bool\n-scalar_close_phi_node_p (gimple *phi)\n-{\n-  if (gimple_code (phi) != GIMPLE_PHI\n-      || virtual_operand_p (gimple_phi_result (phi)))\n-    return false;\n-\n-  /* Note that loop close phi nodes should have a single argument\n-     because we translated the representation into a canonical form\n-     before Graphite: see canonicalize_loop_closed_ssa_form.  */\n-  return (gimple_phi_num_args (phi) == 1);\n-}\n-\n-/* For a definition DEF in REGION, propagates the expression EXPR in\n-   all the uses of DEF outside REGION.  */\n+  vec<scalar_use> reads = gbb->read_scalar_refs;\n+  vec<tree> writes = gbb->write_scalar_refs;\n \n-static void\n-propagate_expr_outside_region (tree def, tree expr, sese_l &region)\n-{\n-  gimple_seq stmts;\n-  bool replaced_once = false;\n-\n-  gcc_assert (TREE_CODE (def) == SSA_NAME);\n-\n-  expr = force_gimple_operand (unshare_expr (expr), &stmts, true,\n-\t\t\t       NULL_TREE);\n-\n-  imm_use_iterator imm_iter;\n-  gimple *use_stmt;\n-  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)\n-    if (!is_gimple_debug (use_stmt)\n-\t&& !bb_in_sese_p (gimple_bb (use_stmt), region))\n-      {\n-\tssa_op_iter iter;\n-\tuse_operand_p use_p;\n-\n-\tFOR_EACH_PHI_OR_STMT_USE (use_p, use_stmt, iter, SSA_OP_ALL_USES)\n-\t  if (operand_equal_p (def, USE_FROM_PTR (use_p), 0)\n-\t      && (replaced_once = true))\n-\t    replace_exp (use_p, expr);\n-\n-\tupdate_stmt (use_stmt);\n-      }\n-\n-  if (replaced_once)\n-    {\n-      gsi_insert_seq_on_edge (region.entry, stmts);\n-      gsi_commit_edge_inserts ();\n-    }\n-}\n-\n-/* Rewrite out of SSA the reduction phi node at PSI by creating a zero\n-   dimension array for it.  */\n-\n-static void\n-rewrite_close_phi_out_of_ssa (scop_p scop, gimple_stmt_iterator *psi)\n-{\n-  sese_l region = scop->scop_info->region;\n-  gimple *phi = gsi_stmt (*psi);\n-  tree res = gimple_phi_result (phi);\n-  basic_block bb = gimple_bb (phi);\n-  gimple_stmt_iterator gsi = gsi_after_labels (bb);\n-  tree arg = gimple_phi_arg_def (phi, 0);\n-  gimple *stmt;\n-\n-  /* Note that loop close phi nodes should have a single argument\n-     because we translated the representation into a canonical form\n-     before Graphite: see canonicalize_loop_closed_ssa_form.  */\n-  gcc_assert (gimple_phi_num_args (phi) == 1);\n-\n-  /* The phi node can be a non close phi node, when its argument is\n-     invariant, or a default definition.  */\n-  if (is_gimple_min_invariant (arg)\n-      || SSA_NAME_IS_DEFAULT_DEF (arg))\n-    {\n-      propagate_expr_outside_region (res, arg, region);\n-      gsi_next (psi);\n-      return;\n-    }\n-\n-  else if (gimple_bb (SSA_NAME_DEF_STMT (arg))->loop_father == bb->loop_father)\n-    {\n-      propagate_expr_outside_region (res, arg, region);\n-      stmt = gimple_build_assign (res, arg);\n-      remove_phi_node (psi, false);\n-      gsi_insert_before (&gsi, stmt, GSI_NEW_STMT);\n-      return;\n-    }\n-\n-  /* If res is scev analyzable and is not a scalar value, it is safe\n-     to ignore the close phi node: it will be code generated in the\n-     out of Graphite pass.  */\n-  else if (scev_analyzable_p (res, region))\n-    {\n-      loop_p loop = loop_containing_stmt (SSA_NAME_DEF_STMT (res));\n-      tree scev;\n-\n-      if (!loop_in_sese_p (loop, region))\n-\t{\n-\t  loop = loop_containing_stmt (SSA_NAME_DEF_STMT (arg));\n-\t  scev = scalar_evolution_in_region (region, loop, arg);\n-\t  scev = compute_overall_effect_of_inner_loop (loop, scev);\n-\t}\n-      else\n-\tscev = scalar_evolution_in_region (region, loop, res);\n-\n-      if (tree_does_not_contain_chrecs (scev))\n-\tpropagate_expr_outside_region (res, scev, region);\n-\n-      gsi_next (psi);\n-      return;\n-    }\n-  else\n-    {\n-      tree zero_dim_array = create_zero_dim_array (res, \"Close_Phi\");\n-\n-      stmt = gimple_build_assign (res, unshare_expr (zero_dim_array));\n-\n-      if (TREE_CODE (arg) == SSA_NAME)\n-\tinsert_out_of_ssa_copy (scop, zero_dim_array, arg,\n-\t\t\t\tSSA_NAME_DEF_STMT (arg));\n-      else\n-\tinsert_out_of_ssa_copy_on_edge (scop, single_pred_edge (bb),\n-\t\t\t\t\tzero_dim_array, arg);\n-    }\n-\n-  remove_phi_node (psi, false);\n-  SSA_NAME_DEF_STMT (res) = stmt;\n-\n-  insert_stmts (scop, stmt, NULL, gsi_after_labels (bb));\n-}\n-\n-/* Rewrite out of SSA the reduction phi node at PSI by creating a zero\n-   dimension array for it.  */\n-\n-static void\n-rewrite_phi_out_of_ssa (scop_p scop, gphi_iterator *psi)\n-{\n-  gphi *phi = psi->phi ();\n-  basic_block bb = gimple_bb (phi);\n-  tree res = gimple_phi_result (phi);\n-  tree zero_dim_array = create_zero_dim_array (res, \"phi_out_of_ssa\");\n-\n-  for (size_t i = 0; i < gimple_phi_num_args (phi); i++)\n-    {\n-      tree arg = gimple_phi_arg_def (phi, i);\n-      edge e = gimple_phi_arg_edge (phi, i);\n-\n-      /* Avoid the insertion of code in the loop latch to please the\n-\t pattern matching of the vectorizer.  */\n-      if (TREE_CODE (arg) == SSA_NAME\n-\t  && !SSA_NAME_IS_DEFAULT_DEF (arg)\n-\t  && e->src == bb->loop_father->latch)\n-\tinsert_out_of_ssa_copy (scop, zero_dim_array, arg,\n-\t\t\t\tSSA_NAME_DEF_STMT (arg));\n-      else\n-\tinsert_out_of_ssa_copy_on_edge (scop, e, zero_dim_array, arg);\n-    }\n-\n-  gimple *stmt = gimple_build_assign (res, unshare_expr (zero_dim_array));\n-  remove_phi_node (psi, false);\n-  insert_stmts (scop, stmt, NULL, gsi_after_labels (bb));\n-}\n-\n-/* Rewrite the degenerate phi node at position PSI from the degenerate\n-   form \"x = phi (y, y, ..., y)\" to \"x = y\".  */\n-\n-static void\n-rewrite_degenerate_phi (gphi_iterator *psi)\n-{\n-  gphi *phi = psi->phi ();\n-  tree res = gimple_phi_result (phi);\n-\n-  basic_block bb = gimple_bb (phi);\n-  tree rhs = degenerate_phi_result (phi);\n-  gcc_assert (rhs);\n-\n-  gimple *stmt = gimple_build_assign (res, rhs);\n-  remove_phi_node (psi, false);\n-\n-  gimple_stmt_iterator gsi = gsi_after_labels (bb);\n-  gsi_insert_before (&gsi, stmt, GSI_NEW_STMT);\n-}\n-\n-/* Rewrite out of SSA all the reduction phi nodes of SCOP.  */\n+  isl_space *dc = isl_set_get_space (pbb->domain);\n+  int nb_out = 1;\n+  isl_space *space = isl_space_add_dims (isl_space_from_domain (dc),\n+\t\t\t\t\t isl_dim_out, nb_out);\n+  isl_id *id = isl_id_for_dr (scop);\n+  space = isl_space_set_tuple_id (space, isl_dim_set, isl_id_copy (id));\n+  isl_map *acc = isl_map_universe (isl_space_copy (space));\n+  acc = isl_map_set_tuple_id (acc, isl_dim_out, id);\n+  isl_set *subscript_sizes = isl_set_nat_universe (space);\n \n-static void\n-rewrite_reductions_out_of_ssa (scop_p scop)\n-{\n   int i;\n-  basic_block bb;\n-  FOR_EACH_VEC_ELT (scop->scop_info->bbs, i, bb)\n-    for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);)\n-      {\n-\tgphi *phi = psi.phi ();\n-\n-\tif (virtual_operand_p (gimple_phi_result (phi)))\n-\t  {\n-\t    gsi_next (&psi);\n-\t    continue;\n-\t  }\n-\n-\tif (gimple_phi_num_args (phi) > 1\n-\t    && degenerate_phi_result (phi))\n-\t  rewrite_degenerate_phi (&psi);\n-\n-\telse if (scalar_close_phi_node_p (phi))\n-\t  rewrite_close_phi_out_of_ssa (scop, &psi);\n-\n-\telse if (reduction_phi_p (scop->scop_info->region, &psi))\n-\t  rewrite_phi_out_of_ssa (scop, &psi);\n-      }\n-\n-  update_ssa (TODO_update_ssa);\n-  checking_verify_loop_closed_ssa (true);\n-}\n-\n-/* Rewrite the scalar dependence of DEF used in USE_STMT with a memory\n-   read from ZERO_DIM_ARRAY.  */\n-\n-static void\n-rewrite_cross_bb_scalar_dependence (scop_p scop, tree zero_dim_array,\n-\t\t\t\t    tree def, gimple *use_stmt)\n-{\n-  gcc_assert (gimple_code (use_stmt) != GIMPLE_PHI);\n-\n-  tree name = copy_ssa_name (def);\n-  gimple *name_stmt = gimple_build_assign (name, zero_dim_array);\n-\n-  gimple_assign_set_lhs (name_stmt, name);\n-  insert_stmts (scop, name_stmt, NULL, gsi_for_stmt (use_stmt));\n-\n-  ssa_op_iter iter;\n-  use_operand_p use_p;\n-  FOR_EACH_SSA_USE_OPERAND (use_p, use_stmt, iter, SSA_OP_ALL_USES)\n-    if (operand_equal_p (def, USE_FROM_PTR (use_p), 0))\n-      replace_exp (use_p, name);\n-\n-  update_stmt (use_stmt);\n-}\n-\n-/* For every definition DEF in the SCOP that is used outside the scop,\n-   insert a closing-scop definition in the basic block just after this\n-   SCOP.  */\n-\n-static void\n-handle_scalar_deps_crossing_scop_limits (scop_p scop, tree def, gimple *stmt)\n-{\n-  tree var = create_tmp_reg (TREE_TYPE (def));\n-  tree new_name = make_ssa_name (var, stmt);\n-  bool needs_copy = false;\n-  sese_l region = scop->scop_info->region;\n-\n-  imm_use_iterator imm_iter;\n-  gimple *use_stmt;\n-  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)\n-    {\n-      if (!bb_in_sese_p (gimple_bb (use_stmt), region))\n-\t{\n-\t  use_operand_p use_p;\n-\t  FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n-\t    {\n-\t      SET_USE (use_p, new_name);\n-\t    }\n-\t  update_stmt (use_stmt);\n-\t  needs_copy = true;\n-\t}\n-    }\n-\n-  /* Insert in the empty BB just after the scop a use of DEF such\n-     that the rewrite of cross_bb_scalar_dependences won't insert\n-     arrays everywhere else.  */\n-  if (needs_copy)\n-    {\n-      gimple *assign = gimple_build_assign (new_name, def);\n-      gimple_stmt_iterator psi = gsi_after_labels (region.exit->dest);\n-\n-      update_stmt (assign);\n-      gsi_insert_before (&psi, assign, GSI_SAME_STMT);\n-    }\n-}\n-\n-/* Rewrite the scalar dependences crossing the boundary of the BB\n-   containing STMT with an array.  Return true when something has been\n-   changed.  */\n-\n-static bool\n-rewrite_cross_bb_scalar_deps (scop_p scop, gimple_stmt_iterator *gsi)\n-{\n-  sese_l region = scop->scop_info->region;\n-  gimple *stmt = gsi_stmt (*gsi);\n-  imm_use_iterator imm_iter;\n-  tree def;\n-  tree zero_dim_array = NULL_TREE;\n-  gimple *use_stmt;\n-  bool res = false;\n-\n-  switch (gimple_code (stmt))\n-    {\n-    case GIMPLE_ASSIGN:\n-      def = gimple_assign_lhs (stmt);\n-      break;\n-\n-    case GIMPLE_CALL:\n-      def = gimple_call_lhs (stmt);\n-      break;\n-\n-    default:\n-      return false;\n-    }\n-\n-  if (!def\n-      || !is_gimple_reg (def))\n-    return false;\n-\n-  if (scev_analyzable_p (def, region))\n-    {\n-      loop_p loop = loop_containing_stmt (SSA_NAME_DEF_STMT (def));\n-      tree scev = scalar_evolution_in_region (region, loop, def);\n-\n-      if (tree_contains_chrecs (scev, NULL))\n-\treturn false;\n-\n-      propagate_expr_outside_region (def, scev, region);\n-      return true;\n-    }\n-\n-  basic_block def_bb = gimple_bb (stmt);\n-\n-  handle_scalar_deps_crossing_scop_limits (scop, def, stmt);\n-\n-  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)\n-    if (gphi *phi = dyn_cast <gphi *> (use_stmt))\n-      {\n-\tres = true;\n-\tgphi_iterator psi = gsi_for_phi (phi);\n-\n-\tif (scalar_close_phi_node_p (gsi_stmt (psi)))\n-\t  rewrite_close_phi_out_of_ssa (scop, &psi);\n-\telse\n-\t  rewrite_phi_out_of_ssa (scop, &psi);\n-      }\n-\n-  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)\n-    if (gimple_code (use_stmt) != GIMPLE_PHI\n-\t&& def_bb != gimple_bb (use_stmt)\n-\t&& !is_gimple_debug (use_stmt)\n-\t&& (res = true))\n-      {\n-\tif (!zero_dim_array)\n-\t  {\n-\t    zero_dim_array = create_zero_dim_array\n-\t      (def, \"Cross_BB_scalar_dependence\");\n-\t    insert_out_of_ssa_copy (scop, zero_dim_array, def,\n-\t\t\t\t    SSA_NAME_DEF_STMT (def));\n-\t    gsi_next (gsi);\n-\t  }\n-\n-\trewrite_cross_bb_scalar_dependence (scop, unshare_expr (zero_dim_array),\n-\t\t\t\t\t    def, use_stmt);\n-      }\n+  tree var;\n+  FOR_EACH_VEC_ELT (writes, i, var)\n+    build_poly_sr_1 (pbb, SSA_NAME_DEF_STMT (var), var, PDR_WRITE,\n+\t\t     isl_map_copy (acc), isl_set_copy (subscript_sizes));\n \n-  update_ssa (TODO_update_ssa);\n+  scalar_use *use;\n+  FOR_EACH_VEC_ELT (reads, i, use)\n+    build_poly_sr_1 (pbb, use->first, use->second, PDR_READ, isl_map_copy (acc),\n+\t\t     isl_set_copy (subscript_sizes));\n \n-  return res;\n+  isl_map_free (acc);\n+  isl_set_free (subscript_sizes);\n }\n \n-/* Rewrite out of SSA all the reduction phi nodes of SCOP.  */\n+/* Build data references in SCOP.  */\n \n static void\n-rewrite_cross_bb_scalar_deps_out_of_ssa (scop_p scop)\n+build_scop_drs (scop_p scop)\n {\n-  gimple_stmt_iterator psi;\n-  sese_l region = scop->scop_info->region;\n-  bool changed = false;\n-\n-  /* Create an extra empty BB after the scop.  */\n-  split_edge (region.exit);\n-\n   int i;\n-  basic_block bb;\n-  FOR_EACH_VEC_ELT (scop->scop_info->bbs, i, bb)\n-    for (psi = gsi_start_bb (bb); !gsi_end_p (psi); gsi_next (&psi))\n-      changed |= rewrite_cross_bb_scalar_deps (scop, &psi);\n+  dr_info *dri;\n+  FOR_EACH_VEC_ELT (scop->drs, i, dri)\n+    build_poly_dr (*dri);\n \n-  if (changed)\n-    {\n-      scev_reset_htab ();\n-      update_ssa (TODO_update_ssa);\n-      checking_verify_loop_closed_ssa (true);\n-    }\n+  poly_bb_p pbb;\n+  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n+    build_poly_sr (pbb);\n }\n \n /* Builds the polyhedral representation for a SESE region.  */\n@@ -1834,13 +1194,6 @@ build_poly_scop (scop_p scop)\n   build_scop_context (scop);\n   add_conditions_to_constraints (scop);\n \n-  /* Rewrite out of SSA only after having translated the\n-     representation to the polyhedral representation to avoid scev\n-     analysis failures.  That means that these functions will insert\n-     new data references that they create in the right place.  */\n-  rewrite_reductions_out_of_ssa (scop);\n-  rewrite_cross_bb_scalar_deps_out_of_ssa (scop);\n-\n   build_scop_drs (scop);\n   build_scop_minimal_scattering (scop);\n   build_scop_original_schedule (scop);"}, {"sha": "5316bc4fa7d2b1a656b1cdfbf3a3e36da0565ee6", "filename": "gcc/graphite.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65b016eb13b67dd990f30a55948a623d9deadd11/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65b016eb13b67dd990f30a55948a623d9deadd11/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=65b016eb13b67dd990f30a55948a623d9deadd11", "patch": "@@ -333,12 +333,16 @@ graphite_transform_loops (void)\n \n \tif (dump_file && dump_flags)\n \t  print_scop (dump_file, scop);\n-\n \tif (scop->poly_scop_p\n-\t    && apply_poly_transforms (scop)\n-\t    && graphite_regenerate_ast_isl (scop))\n-\t  need_cfg_cleanup_p = true;\n-\n+\t    && apply_poly_transforms (scop))\n+\t  {\n+\t    need_cfg_cleanup_p = true;\n+\t    /* When code generation is not successful, do not continue\n+\t       generating code for the next scops: the IR has to be cleaned up\n+\t       and could be in an inconsistent state.  */\n+\t    if (!graphite_regenerate_ast_isl (scop))\n+\t      break;\n+\t  }\n       }\n \n   free_scops (scops);"}, {"sha": "5aa558b88ac3a321653e58ea211a0ac44ad3e194", "filename": "gcc/sese.c", "status": "modified", "additions": 1434, "deletions": 159, "changes": 1593, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65b016eb13b67dd990f30a55948a623d9deadd11/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65b016eb13b67dd990f30a55948a623d9deadd11/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=65b016eb13b67dd990f30a55948a623d9deadd11", "patch": "@@ -25,6 +25,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"backend.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n+#include \"cfganal.h\"\n #include \"cfghooks.h\"\n #include \"tree-pass.h\"\n #include \"ssa.h\"\n@@ -34,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-eh.h\"\n #include \"gimplify.h\"\n #include \"gimple-iterator.h\"\n+#include \"gimple-pretty-print.h\"\n #include \"gimplify-me.h\"\n #include \"tree-cfg.h\"\n #include \"tree-ssa-loop.h\"\n@@ -44,33 +46,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"value-prof.h\"\n #include \"sese.h\"\n #include \"tree-ssa-propagate.h\"\n-#include \"tree-hash-traits.h\"\n-\n-/* Helper function for debug_rename_map.  */\n-\n-bool\n-debug_rename_map_1 (tree_node *const &old_name, tree_node *const &expr,\n-\t\t    void *)\n-{\n-  fprintf (stderr, \"(\");\n-  print_generic_expr (stderr, old_name, 0);\n-  fprintf (stderr, \", \");\n-  print_generic_expr (stderr, expr, 0);\n-  fprintf (stderr, \")\\n\");\n-  return true;\n-}\n-\f\n-typedef hash_map<tree_ssa_name_hash, tree> rename_map_type;\n-\f\n-\n-/* Print to stderr all the elements of RENAME_MAP.  */\n-\n-DEBUG_FUNCTION void\n-debug_rename_map (rename_map_type *rename_map)\n-{\n-  rename_map->traverse <void *, debug_rename_map_1> (NULL);\n-}\n-\f\n \n /* Record LOOP as occurring in REGION.  */\n \n@@ -80,8 +55,8 @@ sese_record_loop (sese_info_p region, loop_p loop)\n   if (sese_contains_loop (region, loop))\n     return;\n \n-  bitmap_set_bit (SESE_LOOPS (region), loop->num);\n-  SESE_LOOP_NEST (region).safe_push (loop);\n+  bitmap_set_bit (region->loops, loop->num);\n+  region->loop_nest.safe_push (loop);\n }\n \n /* Build the loop nests contained in REGION.  Returns true when the\n@@ -108,16 +83,16 @@ build_sese_loop_nests (sese_info_p region)\n   /* Make sure that the loops in the SESE_LOOP_NEST are ordered.  It\n      can be the case that an inner loop is inserted before an outer\n      loop.  To avoid this, semi-sort once.  */\n-  FOR_EACH_VEC_ELT (SESE_LOOP_NEST (region), i, loop0)\n+  FOR_EACH_VEC_ELT (region->loop_nest, i, loop0)\n     {\n-      if (SESE_LOOP_NEST (region).length () == i + 1)\n+      if (region->loop_nest.length () == i + 1)\n \tbreak;\n \n-      loop1 = SESE_LOOP_NEST (region)[i + 1];\n+      loop1 = region->loop_nest[i + 1];\n       if (loop0->num > loop1->num)\n \t{\n-\t  SESE_LOOP_NEST (region)[i] = loop1;\n-\t  SESE_LOOP_NEST (region)[i + 1] = loop0;\n+\t  region->loop_nest[i] = loop1;\n+\t  region->loop_nest[i + 1] = loop0;\n \t}\n     }\n }\n@@ -256,10 +231,13 @@ new_sese_info (edge entry, edge exit)\n \n   region->region.entry = entry;\n   region->region.exit = exit;\n-  SESE_LOOPS (region) = BITMAP_ALLOC (NULL);\n-  SESE_LOOP_NEST (region).create (3);\n-  SESE_PARAMS (region).create (3);\n+  region->loops = BITMAP_ALLOC (NULL);\n+  region->loop_nest.create (3);\n+  region->params.create (3);\n+  region->rename_map = new rename_map_t;\n+  region->copied_bb_map = new bb_map_t;\n   region->bbs.create (3);\n+  region->incomplete_phis.create (3);\n \n   return region;\n }\n@@ -269,11 +247,28 @@ new_sese_info (edge entry, edge exit)\n void\n free_sese_info (sese_info_p region)\n {\n-  if (SESE_LOOPS (region))\n-    SESE_LOOPS (region) = BITMAP_ALLOC (NULL);\n+  if (region->loops)\n+    region->loops = BITMAP_ALLOC (NULL);\n+\n+  region->params.release ();\n+  region->loop_nest.release ();\n+\n+  for (rename_map_t::iterator it = region->rename_map->begin ();\n+       it != region->rename_map->begin (); ++it)\n+    (*it).second.release ();\n+\n+  for (bb_map_t::iterator it = region->copied_bb_map->begin ();\n+       it != region->copied_bb_map->begin (); ++it)\n+    (*it).second.release ();\n \n-  SESE_PARAMS (region).release ();\n-  SESE_LOOP_NEST (region).release ();\n+  delete region->rename_map;\n+  delete region->copied_bb_map;\n+\n+  region->rename_map = NULL;\n+  region->copied_bb_map = NULL;\n+\n+  region->bbs.release ();\n+  region->incomplete_phis.release ();\n \n   XDELETE (region);\n }\n@@ -312,8 +307,11 @@ sese_insert_phis_for_liveouts (sese_info_p region, basic_block bb,\n   update_ssa (TODO_update_ssa);\n \n   sese_build_liveouts (region, liveouts);\n+\n   EXECUTE_IF_SET_IN_BITMAP (liveouts, 0, i, bi)\n-    sese_add_exit_phis_edge (bb, ssa_name (i), false_e, true_e);\n+    if (!virtual_operand_p (ssa_name (i)))\n+      sese_add_exit_phis_edge (bb, ssa_name (i), false_e, true_e);\n+\n   BITMAP_FREE (liveouts);\n \n   update_ssa (TODO_update_ssa);\n@@ -351,37 +349,550 @@ get_false_edge_from_guard_bb (basic_block bb)\n   return NULL;\n }\n \n-/* Returns the expression associated to OLD_NAME in RENAME_MAP.  */\n+/* Check if USE is defined in a basic block from where the definition of USE can\n+ propagate from all the paths.  */\n+\n+static bool\n+is_loop_closed_ssa_use (basic_block bb, tree use)\n+{\n+  if (TREE_CODE (use) != SSA_NAME)\n+    return true;\n+\n+  /* We should not have a rename for virtual operands.  */\n+  gcc_assert (!virtual_operand_p (use));\n+\n+  /* For close-phi nodes def always comes from a loop which has a back-edge.  */\n+  if (bb_contains_loop_close_phi_nodes (bb))\n+    return true;\n+\n+  gimple *def = SSA_NAME_DEF_STMT (use);\n+  basic_block def_bb = gimple_bb (def);\n+  return (!def_bb\n+\t  || flow_bb_inside_loop_p (def_bb->loop_father, bb));\n+}\n+\n+/* Return the number of phi nodes in BB.  */\n+\n+static int\n+number_of_phi_nodes (basic_block bb)\n+{\n+  int num_phis = 0;\n+  for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);\n+       gsi_next (&psi))\n+    num_phis++;\n+  return num_phis;\n+}\n+\n+/* Return true when BB contains loop close phi nodes.  */\n+\n+bool\n+bb_contains_loop_close_phi_nodes (basic_block bb)\n+{\n+  return single_pred_p (bb)\n+    && bb->loop_father != single_pred_edge (bb)->src->loop_father;\n+}\n+\n+/* Return true when BB contains loop phi nodes.  */\n+\n+bool\n+bb_contains_loop_phi_nodes (basic_block bb)\n+{\n+  gcc_assert (EDGE_COUNT (bb->preds) <= 2);\n+\n+  if (bb->preds->length () == 1)\n+    return false;\n+\n+  unsigned depth = loop_depth (bb->loop_father);\n+\n+  edge preds[2] = { (*bb->preds)[0], (*bb->preds)[1] };\n+\n+  if (depth > loop_depth (preds[0]->src->loop_father)\n+      || depth > loop_depth (preds[1]->src->loop_father))\n+    return true;\n+\n+  /* When one of the edges correspond to the same loop father and other\n+     doesn't.  */\n+  if (bb->loop_father != preds[0]->src->loop_father\n+      && bb->loop_father == preds[1]->src->loop_father)\n+    return true;\n+\n+  if (bb->loop_father != preds[1]->src->loop_father\n+      && bb->loop_father == preds[0]->src->loop_father)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Returns true if BB uses name in one of its PHIs.  */\n+\n+static bool\n+phi_uses_name (basic_block bb, tree name)\n+{\n+  for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);\n+       gsi_next (&psi))\n+    {\n+      gphi *phi = psi.phi ();\n+      for (unsigned i = 0; i < gimple_phi_num_args (phi); i++)\n+\t{\n+\t  tree use_arg = gimple_phi_arg_def (phi, i);\n+\t  if (use_arg == name)\n+\t    return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Return true if RENAME (defined in BB) is a valid use in NEW_BB.  The\n+definition should flow into use, and the use should respect the loop-closed SSA\n+form.  */\n+\n+static bool\n+is_valid_rename (tree rename, basic_block def_bb,\n+\t\t basic_block use_bb, bool loop_phi,\n+\t\t tree old_name, basic_block old_bb)\n+{\n+  /* The def of the rename must either dominate the uses or come from a\n+     back-edge.  Also the def must respect the loop closed ssa form.  */\n+  if (!is_loop_closed_ssa_use (use_bb, rename))\n+    {\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"\\n[codegen] rename not in loop closed ssa:\");\n+\t  print_generic_expr (dump_file, rename, 0);\n+\t}\n+      return false;\n+    }\n+\n+  if (dominated_by_p (CDI_DOMINATORS, use_bb, def_bb))\n+    return true;\n+\n+  if (bb_contains_loop_phi_nodes (use_bb) && loop_phi)\n+    {\n+      /* The loop-header dominates the loop-body.  */\n+      if (!dominated_by_p (CDI_DOMINATORS, def_bb, use_bb))\n+\treturn false;\n+\n+      /* RENAME would be used in loop-phi.  */\n+      gcc_assert (number_of_phi_nodes (use_bb));\n+\n+      /* For definitions coming from back edges, we should check that\n+\t old_name is used in a loop PHI node.  */\n+      if (phi_uses_name (old_bb, old_name))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Returns the expression associated to OLD_NAME (which is used in OLD_BB), in\n+   NEW_BB from RENAME_MAP.  LOOP_PHI is true when we want to rename OLD_NAME\n+   within a loop PHI instruction.  */\n \n static tree\n-get_rename (rename_map_type *rename_map, tree old_name)\n+get_rename (rename_map_t *rename_map, basic_block new_bb, tree old_name,\n+\t    basic_block old_bb, bool loop_phi)\n {\n   gcc_assert (TREE_CODE (old_name) == SSA_NAME);\n-  tree *expr = rename_map->get (old_name);\n-  if (expr)\n-    return *expr;\n+  vec <tree> *renames = rename_map->get (old_name);\n \n-  return NULL_TREE;\n+  if (!renames || renames->is_empty ())\n+    return NULL_TREE;\n+\n+  if (1 == renames->length ())\n+    {\n+      tree rename = (*renames)[0];\n+      basic_block bb = gimple_bb (SSA_NAME_DEF_STMT (rename));\n+      if (is_valid_rename (rename, bb, new_bb, loop_phi, old_name, old_bb))\n+\treturn rename;\n+      return NULL_TREE;\n+    }\n+\n+  /* More than one renames corresponding to the old_name.  Find the rename for\n+     which the definition flows into usage at new_bb.  */\n+  int i;\n+  tree t1 = NULL_TREE, t2;\n+  basic_block t1_bb = NULL;\n+  FOR_EACH_VEC_ELT (*renames, i, t2)\n+    {\n+      basic_block t2_bb = gimple_bb (SSA_NAME_DEF_STMT (t2));\n+\n+      /* Defined in the same basic block as used.  */\n+      if (t2_bb == new_bb)\n+\treturn t2;\n+\n+      /* NEW_BB and T2_BB are in two unrelated if-clauses.  */\n+      if (!dominated_by_p (CDI_DOMINATORS, new_bb, t2_bb))\n+\tcontinue;\n+\n+      /* Compute the nearest dominator.  */\n+      if (!t1 || dominated_by_p (CDI_DOMINATORS, t2_bb, t1_bb))\n+\t{\n+\t  t1_bb = t2_bb;\n+\t  t1 = t2;\n+\t}\n+      //if (is_valid_rename (rename, bb, new_bb, loop_phi, old_name, old_bb))\n+      //return rename;\n+    }\n+\n+  return t1;\n }\n \n-/* Register in RENAME_MAP the rename tuple (OLD_NAME, EXPR).  */\n+/* Register in RENAME_MAP the rename tuple (OLD_NAME, EXPR).\n+   When OLD_NAME and EXPR are the same we assert.  */\n \n static void\n-set_rename (rename_map_type *rename_map, tree old_name, tree expr)\n+set_rename (tree old_name, tree expr, sese_info_p region)\n {\n   if (dump_file)\n     {\n-      fprintf (dump_file, \"[codegen] setting rename: old_name = \");\n+      fprintf (dump_file, \"\\n[codegen] setting rename: old_name = \");\n       print_generic_expr (dump_file, old_name, 0);\n       fprintf (dump_file, \", new_name = \");\n       print_generic_expr (dump_file, expr, 0);\n-      fprintf (dump_file, \"\\n\");\n     }\n \n   if (old_name == expr)\n     return;\n \n-  rename_map->put (old_name, expr);\n+  vec <tree> *renames = region->rename_map->get (old_name);\n+\n+  if (renames)\n+    renames->safe_push (expr);\n+  else\n+    {\n+      vec<tree> r;\n+      r.create (2);\n+      r.safe_push (expr);\n+      region->rename_map->put (old_name, r);\n+    }\n+}\n+\n+/* Return an iterator to the instructions comes\n+   last in the execution order.  Either GSI1 and GSI2 should belong\n+   to the same basic block or one of their respective basic blocks\n+   should dominate the other.  */\n+\n+gimple_stmt_iterator\n+later_of_the_two (gimple_stmt_iterator gsi1, gimple_stmt_iterator gsi2)\n+{\n+  basic_block bb1 = gsi_bb (gsi1);\n+  basic_block bb2 = gsi_bb (gsi2);\n+\n+  /* Find the iterator which is the latest.  */\n+  if (bb1 == bb2)\n+    {\n+      /* For empty basic blocks gsis point to the end of the sequence.  Since\n+\t there is no operator== defined for gimple_stmt_iterator and for gsis\n+\t not pointing to a valid statement gsi_next would assert.  */\n+      gimple_stmt_iterator gsi = gsi1;\n+      do {\n+\tif (gsi_stmt (gsi) == gsi_stmt (gsi2))\n+\t  return gsi2;\n+\tgsi_next (&gsi);\n+      } while (!gsi_end_p (gsi));\n+\n+      return gsi1;\n+    }\n+\n+  /* Find the basic block closest to the basic block which defines stmt.  */\n+  if (dominated_by_p (CDI_DOMINATORS, bb1, bb2))\n+    return gsi1;\n+\n+  gcc_assert (dominated_by_p (CDI_DOMINATORS, bb2, bb1));\n+  return gsi2;\n+}\n+\n+/* Insert each statement from SEQ at its earliest insertion p.  */\n+\n+static void\n+gsi_insert_earliest (gimple_seq seq, sese_info_p region)\n+{\n+  update_modified_stmts (seq);\n+  sese_l &codegen_region = region->if_region->true_region->region;\n+  basic_block begin_bb = get_entry_bb (codegen_region);\n+\n+  /* Inserting the gimple statements in a vector because gimple_seq behave\n+     in strage ways when inserting the stmts from it into different basic\n+     blocks one at a time.  */\n+  auto_vec<gimple *, 3> stmts;\n+  for (gimple_stmt_iterator gsi = gsi_start (seq); !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n+    stmts.safe_push (gsi_stmt (gsi));\n+\n+  int i;\n+  gimple *use_stmt;\n+  FOR_EACH_VEC_ELT (stmts, i, use_stmt)\n+    {\n+      gcc_assert (gimple_code (use_stmt) != GIMPLE_PHI);\n+      gimple_stmt_iterator gsi_def_stmt = gsi_start_bb_nondebug (begin_bb);\n+\n+      use_operand_p use_p;\n+      ssa_op_iter op_iter;\n+      FOR_EACH_SSA_USE_OPERAND (use_p, use_stmt, op_iter, SSA_OP_USE)\n+\t{\n+\t  /* Iterator to the current def of use_p.  For function parameters or\n+\t     anything where def is not found, insert at the beginning of the\n+\t     generated region.  */\n+\t  gimple_stmt_iterator gsi_stmt = gsi_def_stmt;\n+\n+\t  tree op = USE_FROM_PTR (use_p);\n+\t  gimple *stmt = SSA_NAME_DEF_STMT (op);\n+\t  if (stmt && (gimple_code (stmt) != GIMPLE_NOP))\n+\t    gsi_stmt = gsi_for_stmt (stmt);\n+\n+\t  /* For region parameters, insert at the beginning of the generated\n+\t     region.  */\n+\t  if (!bb_in_sese_p (gsi_bb (gsi_stmt), codegen_region))\n+\t    {\n+\t      /* The parameter should have been inserted in the parameter\n+\t\t map or it must have a scev.  */\n+\t      gsi_stmt = gsi_def_stmt;\n+\t    }\n+\n+\t  gsi_def_stmt = later_of_the_two (gsi_stmt, gsi_def_stmt);\n+\t}\n+\n+      if (!gsi_stmt (gsi_def_stmt))\n+\t{\n+\t  gimple_stmt_iterator gsi = gsi_after_labels (gsi_bb (gsi_def_stmt));\n+\t  gsi_insert_before (&gsi, use_stmt, GSI_NEW_STMT);\n+\t}\n+      else if (gimple_code (gsi_stmt (gsi_def_stmt)) == GIMPLE_PHI)\n+\t{\n+\t  gimple_stmt_iterator bsi\n+\t    = gsi_start_bb_nondebug (gsi_bb (gsi_def_stmt));\n+\t  /* Insert right after the PHI statements.  */\n+\t  gsi_insert_before (&bsi, use_stmt, GSI_NEW_STMT);\n+\t}\n+      else\n+\tgsi_insert_after (&gsi_def_stmt, use_stmt, GSI_NEW_STMT);\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"\\n[codegen] inserting statement: \");\n+\t  print_gimple_stmt (dump_file, use_stmt, 0, TDF_VOPS | TDF_MEMSYMS);\n+\t  print_loops_bb (dump_file, gimple_bb (use_stmt), 0, 3);\n+\t}\n+    }\n+}\n+\n+/* Collect all the operands of NEW_EXPR by recursively visiting each\n+   operand.  */\n+\n+static void\n+collect_all_ssa_names (tree new_expr, vec<tree> *vec_ssa, sese_info_p region)\n+{\n+\n+  /* Rename all uses in new_expr.  */\n+  if (TREE_CODE (new_expr) == SSA_NAME)\n+    {\n+      vec_ssa->safe_push (new_expr);\n+      return;\n+    }\n+\n+  /* Iterate over SSA_NAMES in NEW_EXPR.  */\n+  for (int i = 0; i < (TREE_CODE_LENGTH (TREE_CODE (new_expr))); i++)\n+    {\n+      tree op = TREE_OPERAND (new_expr, i);\n+      collect_all_ssa_names (op, vec_ssa, region);\n+    }\n+}\n+\n+static tree\n+substitute_ssa_name (tree exp, tree f, tree r)\n+{\n+  enum tree_code code = TREE_CODE (exp);\n+  tree op0, op1, op2, op3;\n+  tree new_tree;\n+\n+  /* We handle TREE_LIST and COMPONENT_REF separately.  */\n+  if (code == TREE_LIST)\n+    {\n+      op0 = substitute_ssa_name (TREE_CHAIN (exp), f, r);\n+      op1 = substitute_ssa_name (TREE_VALUE (exp), f, r);\n+      if (op0 == TREE_CHAIN (exp) && op1 == TREE_VALUE (exp))\n+\treturn exp;\n+\n+      return tree_cons (TREE_PURPOSE (exp), op1, op0);\n+    }\n+  else if (code == COMPONENT_REF)\n+    {\n+      tree inner;\n+\n+      /* If this expression is getting a value from a PLACEHOLDER_EXPR\n+\t and it is the right field, replace it with R.  */\n+      for (inner = TREE_OPERAND (exp, 0);\n+\t   REFERENCE_CLASS_P (inner);\n+\t   inner = TREE_OPERAND (inner, 0))\n+\t;\n+\n+      /* The field.  */\n+      op1 = TREE_OPERAND (exp, 1);\n+\n+      if (TREE_CODE (inner) == PLACEHOLDER_EXPR && op1 == f)\n+\treturn r;\n+\n+      /* If this expression hasn't been completed let, leave it alone.  */\n+      if (TREE_CODE (inner) == PLACEHOLDER_EXPR && !TREE_TYPE (inner))\n+\treturn exp;\n+\n+      op0 = substitute_ssa_name (TREE_OPERAND (exp, 0), f, r);\n+      if (op0 == TREE_OPERAND (exp, 0))\n+\treturn exp;\n+\n+      new_tree\n+\t= fold_build3 (COMPONENT_REF, TREE_TYPE (exp), op0, op1, NULL_TREE);\n+   }\n+  else\n+    switch (TREE_CODE_CLASS (code))\n+      {\n+      case tcc_constant:\n+\treturn exp;\n+\n+      case tcc_declaration:\n+\tif (exp == f)\n+\t  return r;\n+\telse\n+\t  return exp;\n+\n+      case tcc_expression:\n+\tif (exp == f)\n+\t  return r;\n+\n+\t/* Fall through...  */\n+\n+      case tcc_exceptional:\n+      case tcc_unary:\n+      case tcc_binary:\n+      case tcc_comparison:\n+      case tcc_reference:\n+\tswitch (TREE_CODE_LENGTH (code))\n+\t  {\n+\t  case 0:\n+\t    if (exp == f)\n+\t      return r;\n+\t    return exp;\n+\n+\t  case 1:\n+\t    op0 = substitute_ssa_name (TREE_OPERAND (exp, 0), f, r);\n+\t    if (op0 == TREE_OPERAND (exp, 0))\n+\t      return exp;\n+\n+\t    new_tree = fold_build1 (code, TREE_TYPE (exp), op0);\n+\t    break;\n+\n+\t  case 2:\n+\t    op0 = substitute_ssa_name (TREE_OPERAND (exp, 0), f, r);\n+\t    op1 = substitute_ssa_name (TREE_OPERAND (exp, 1), f, r);\n+\n+\t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1))\n+\t      return exp;\n+\n+\t    new_tree = fold_build2 (code, TREE_TYPE (exp), op0, op1);\n+\t    break;\n+\n+\t  case 3:\n+\t    op0 = substitute_ssa_name (TREE_OPERAND (exp, 0), f, r);\n+\t    op1 = substitute_ssa_name (TREE_OPERAND (exp, 1), f, r);\n+\t    op2 = substitute_ssa_name (TREE_OPERAND (exp, 2), f, r);\n+\n+\t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)\n+\t\t&& op2 == TREE_OPERAND (exp, 2))\n+\t      return exp;\n+\n+\t    new_tree = fold_build3 (code, TREE_TYPE (exp), op0, op1, op2);\n+\t    break;\n+\n+\t  case 4:\n+\t    op0 = substitute_ssa_name (TREE_OPERAND (exp, 0), f, r);\n+\t    op1 = substitute_ssa_name (TREE_OPERAND (exp, 1), f, r);\n+\t    op2 = substitute_ssa_name (TREE_OPERAND (exp, 2), f, r);\n+\t    op3 = substitute_ssa_name (TREE_OPERAND (exp, 3), f, r);\n+\n+\t    if (op0 == TREE_OPERAND (exp, 0) && op1 == TREE_OPERAND (exp, 1)\n+\t\t&& op2 == TREE_OPERAND (exp, 2)\n+\t\t&& op3 == TREE_OPERAND (exp, 3))\n+\t      return exp;\n+\n+\t    new_tree\n+\t      = fold (build4 (code, TREE_TYPE (exp), op0, op1, op2, op3));\n+\t    break;\n+\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\tbreak;\n+\n+      case tcc_vl_exp:\n+      default:\n+\tgcc_unreachable ();\n+      }\n+\n+  TREE_READONLY (new_tree) |= TREE_READONLY (exp);\n+\n+  if (code == INDIRECT_REF || code == ARRAY_REF || code == ARRAY_RANGE_REF)\n+    TREE_THIS_NOTRAP (new_tree) |= TREE_THIS_NOTRAP (exp);\n+\n+  return new_tree;\n+}\n+\n+/* Rename all the operands of NEW_EXPR by recursively visiting each operand.  */\n+\n+static tree\n+rename_all_uses (tree new_expr, basic_block new_bb, basic_block old_bb,\n+\t\t sese_info_p region)\n+{\n+  vec<tree> ssa_names;\n+  ssa_names.create (2);\n+  collect_all_ssa_names (new_expr, &ssa_names, region);\n+  tree t;\n+  int i;\n+  FOR_EACH_VEC_ELT (ssa_names, i, t)\n+    {\n+      if (tree r = get_rename (region->rename_map, new_bb, t, old_bb, false))\n+\tnew_expr = substitute_ssa_name (new_expr, t, r);\n+      /* else\n+\t return NULL_TREE;*/\n+    }\n+\n+  return new_expr;\n+}\n+\n+static tree\n+get_rename_from_scev (tree old_name, gimple_seq *stmts, loop_p loop,\n+\t\t      basic_block new_bb, basic_block old_bb,\n+\t\t      vec<tree> iv_map, sese_info_p region, bool *gloog_error)\n+{\n+  tree scev = scalar_evolution_in_region (region->region, loop, old_name);\n+\n+  /* At this point we should know the exact scev for each\n+     scalar SSA_NAME used in the scop: all the other scalar\n+     SSA_NAMEs should have been translated out of SSA using\n+     arrays with one element.  */\n+  tree new_expr;\n+  if (chrec_contains_undetermined (scev))\n+    {\n+      *gloog_error = true;\n+      return build_zero_cst (TREE_TYPE (old_name));\n+    }\n+\n+    new_expr = chrec_apply_map (scev, iv_map);\n+\n+  /* The apply should produce an expression tree containing\n+     the uses of the new induction variables.  We should be\n+     able to use new_expr instead of the old_name in the newly\n+     generated loop nest.  */\n+  if (chrec_contains_undetermined (new_expr)\n+      || tree_contains_chrecs (new_expr, NULL))\n+    {\n+      *gloog_error = true;\n+      return build_zero_cst (TREE_TYPE (old_name));\n+    }\n+\n+  new_expr = rename_all_uses (new_expr, new_bb, old_bb, region);\n+\n+  /* Replace the old_name with the new_expr.  */\n+  return force_gimple_operand (unshare_expr (new_expr), stmts,\n+\t\t\t       true, NULL_TREE);\n }\n \n /* Renames the scalar uses of the statement COPY, using the\n@@ -392,13 +903,10 @@ set_rename (rename_map_type *rename_map, tree old_name, tree expr)\n    is set when the code generation cannot continue.  */\n \n static bool\n-rename_uses (gimple *copy, rename_map_type *rename_map,\n-\t     gimple_stmt_iterator *gsi_tgt,\n-\t     sese_info_p region, loop_p loop, vec<tree> iv_map,\n-\t     bool *gloog_error)\n+rename_uses (gimple *copy, gimple_stmt_iterator *gsi_tgt,\n+\t     basic_block old_bb, sese_info_p region,\n+\t     loop_p loop, vec<tree> iv_map, bool *gloog_error)\n {\n-  use_operand_p use_p;\n-  ssa_op_iter op_iter;\n   bool changed = false;\n \n   if (is_gimple_debug (copy))\n@@ -413,23 +921,43 @@ rename_uses (gimple *copy, rename_map_type *rename_map,\n       return false;\n     }\n \n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\n[codegen] renaming uses of stmt: \");\n+      print_gimple_stmt (dump_file, copy, 0, 0);\n+    }\n+\n+  use_operand_p use_p;\n+  ssa_op_iter op_iter;\n   FOR_EACH_SSA_USE_OPERAND (use_p, copy, op_iter, SSA_OP_USE)\n     {\n       tree old_name = USE_FROM_PTR (use_p);\n-      tree new_expr, scev;\n-      gimple_seq stmts;\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"\\n[codegen] renaming old_name = \");\n+\t  print_generic_expr (dump_file, old_name, 0);\n+\t}\n \n       if (TREE_CODE (old_name) != SSA_NAME\n \t  || SSA_NAME_IS_DEFAULT_DEF (old_name))\n \tcontinue;\n \n       changed = true;\n-      new_expr = get_rename (rename_map, old_name);\n+      tree new_expr = get_rename (region->rename_map, gsi_tgt->bb, old_name,\n+\t\t\t\t  old_bb, false);\n+\n       if (new_expr)\n \t{\n \t  tree type_old_name = TREE_TYPE (old_name);\n \t  tree type_new_expr = TREE_TYPE (new_expr);\n \n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"\\n[codegen] from rename_map: new_name = \");\n+\t      print_generic_expr (dump_file, new_expr, 0);\n+\t    }\n+\n \t  if (type_old_name != type_new_expr\n \t      || TREE_CODE (new_expr) != SSA_NAME)\n \t    {\n@@ -438,44 +966,28 @@ rename_uses (gimple *copy, rename_map_type *rename_map,\n \t      if (!useless_type_conversion_p (type_old_name, type_new_expr))\n \t\tnew_expr = fold_convert (type_old_name, new_expr);\n \n+\t      gimple_seq stmts;\n \t      new_expr = force_gimple_operand (new_expr, &stmts, true, var);\n-\t      gsi_insert_seq_before (gsi_tgt, stmts, GSI_SAME_STMT);\n+\t      gsi_insert_earliest (stmts, region);\n \t    }\n \n \t  replace_exp (use_p, new_expr);\n \t  continue;\n \t}\n \n-      scev = scalar_evolution_in_region (region->region, loop, old_name);\n-\n-      /* At this point we should know the exact scev for each\n-\t scalar SSA_NAME used in the scop: all the other scalar\n-\t SSA_NAMEs should have been translated out of SSA using\n-\t arrays with one element.  */\n-      if (chrec_contains_undetermined (scev))\n-\t{\n-\t  *gloog_error = true;\n-\t  new_expr = build_zero_cst (TREE_TYPE (old_name));\n-\t}\n-      else\n-\tnew_expr = chrec_apply_map (scev, iv_map);\n+      gimple_seq stmts;\n+      new_expr = get_rename_from_scev (old_name, &stmts, loop, gimple_bb (copy),\n+\t\t\t\t       old_bb, iv_map, region, gloog_error);\n+      if (!new_expr || *gloog_error)\n+\treturn false;\n \n-      /* The apply should produce an expression tree containing\n-\t the uses of the new induction variables.  We should be\n-\t able to use new_expr instead of the old_name in the newly\n-\t generated loop nest.  */\n-      if (chrec_contains_undetermined (new_expr)\n-\t  || tree_contains_chrecs (new_expr, NULL))\n+      if (dump_file)\n \t{\n-\t  *gloog_error = true;\n-\t  new_expr = build_zero_cst (TREE_TYPE (old_name));\n+\t  fprintf (dump_file, \"\\n[codegen] not in rename map, scev: \");\n+\t  print_generic_expr (dump_file, new_expr, 0);\n \t}\n-      else\n-\t/* Replace the old_name with the new_expr.  */\n-\tnew_expr = force_gimple_operand (unshare_expr (new_expr), &stmts,\n-\t\t\t\t\t true, NULL_TREE);\n \n-      gsi_insert_seq_before (gsi_tgt, stmts, GSI_SAME_STMT);\n+      gsi_insert_earliest (stmts, region);\n       replace_exp (use_p, new_expr);\n \n       if (TREE_CODE (new_expr) == INTEGER_CST\n@@ -487,97 +999,860 @@ rename_uses (gimple *copy, rename_map_type *rename_map,\n \t    recompute_tree_invariant_for_addr_expr (rhs);\n \t}\n \n-      set_rename (rename_map, old_name, new_expr);\n+      set_rename (old_name, new_expr, region);\n     }\n \n   return changed;\n }\n \n-/* Duplicates the statements of basic block BB into basic block NEW_BB\n-   and compute the new induction variables according to the IV_MAP.\n-   GLOOG_ERROR is set when the code generation cannot continue.  */\n+/* Returns a basic block that could correspond to where a constant was defined\n+   in the original code.  In the original code OLD_BB had the definition, we\n+   need to find which basic block out of the copies of old_bb, in the new\n+   region, should a definition correspond to if it has to reach BB.  */\n \n-static void\n-graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb,\n-\t\t\t\trename_map_type *rename_map,\n-\t\t\t\tvec<tree> iv_map, sese_info_p region,\n-\t\t\t\tbool *gloog_error)\n+static basic_block\n+get_def_bb_for_const (sese_info_p region, basic_block bb, basic_block old_bb)\n {\n-  gimple_stmt_iterator gsi, gsi_tgt;\n-  loop_p loop = bb->loop_father;\n+  vec <basic_block> *bbs = region->copied_bb_map->get (old_bb);\n \n-  gsi_tgt = gsi_start_bb (new_bb);\n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      def_operand_p def_p;\n-      ssa_op_iter op_iter;\n-      gimple *stmt = gsi_stmt (gsi);\n-      gimple *copy;\n-      tree lhs;\n+  if (!bbs || bbs->is_empty ())\n+    return NULL;\n \n-      /* Do not copy labels or conditions.  */\n-      if (gimple_code (stmt) == GIMPLE_LABEL\n-\t  || gimple_code (stmt) == GIMPLE_COND)\n-\tcontinue;\n+  if (1 == bbs->length ())\n+    return (*bbs)[0];\n \n-      /* Do not copy induction variables.  */\n-      if (is_gimple_assign (stmt)\n-\t  && (lhs = gimple_assign_lhs (stmt))\n-\t  && TREE_CODE (lhs) == SSA_NAME\n-\t  && is_gimple_reg (lhs)\n-\t  && scev_analyzable_p (lhs, region->region))\n+  int i;\n+  basic_block b1 = NULL, b2;\n+  FOR_EACH_VEC_ELT (*bbs, i, b2)\n+    {\n+      if (b2 == bb)\n+\treturn bb;\n+\n+      /* BB and B2 are in two unrelated if-clauses.  */\n+      if (!dominated_by_p (CDI_DOMINATORS, bb, b2))\n \tcontinue;\n \n-      /* Create a new copy of STMT and duplicate STMT's virtual\n-\t operands.  */\n-      copy = gimple_copy (stmt);\n-      gsi_insert_after (&gsi_tgt, copy, GSI_NEW_STMT);\n+      /* Compute the nearest dominator.  */\n+      if (!b1 || dominated_by_p (CDI_DOMINATORS, b2, b1))\n+\tb1 = b2;\n+    }\n \n-      maybe_duplicate_eh_stmt (copy, stmt);\n-      gimple_duplicate_stmt_histograms (cfun, copy, cfun, stmt);\n+  gcc_assert (b1);\n+  return b1;\n+}\n \n-      /* Create new names for all the definitions created by COPY and\n-\t add replacement mappings for each new name.  */\n-      FOR_EACH_SSA_DEF_OPERAND (def_p, copy, op_iter, SSA_OP_ALL_DEFS)\n- \t{\n- \t  tree old_name = DEF_FROM_PTR (def_p);\n- \t  tree new_name = create_new_def_for (old_name, copy, def_p);\n-\t  set_rename (rename_map, old_name, new_name);\n- \t}\n+/* LOOP_PHI is true when we want to rename an OP within a loop PHI\n+   instruction.  */\n \n-      if (rename_uses (copy, rename_map, &gsi_tgt, region, loop, iv_map,\n-\t\t       gloog_error))\n-\t{\n-\t  gcc_assert (gsi_stmt (gsi_tgt) == copy);\n-\t  fold_stmt_inplace (&gsi_tgt);\n-\t}\n+static tree\n+get_new_name (sese_info_p region, basic_block new_bb, tree op,\n+\t      basic_block old_bb, bool loop_phi)\n+{\n+  if (TREE_CODE (op) == INTEGER_CST\n+      || TREE_CODE (op) == REAL_CST\n+      || TREE_CODE (op) == COMPLEX_CST\n+      || TREE_CODE (op) == VECTOR_CST)\n+    return op;\n \n-      update_stmt (copy);\n-    }\n+  return get_rename (region->rename_map, new_bb, op, old_bb, loop_phi);\n }\n \n-/* Copies BB and includes in the copied BB all the statements that can\n-   be reached following the use-def chains from the memory accesses,\n-   and returns the next edge following this new block.  GLOOG_ERROR is\n-   set when the code generation cannot continue.  */\n+/* Return a debug location for OP.  */\n \n-edge\n-copy_bb_and_scalar_dependences (basic_block bb, sese_info_p region,\n-\t\t\t\tedge next_e, vec<tree> iv_map,\n-\t\t\t\tbool *gloog_error)\n+static location_t\n+get_loc (tree op)\n {\n-  basic_block new_bb = split_edge (next_e);\n-  rename_map_type rename_map (10);\n+  location_t loc = UNKNOWN_LOCATION;\n \n-  next_e = single_succ_edge (new_bb);\n-  graphite_copy_stmts_from_block (bb, new_bb, &rename_map, iv_map, region,\n-\t\t\t\t  gloog_error);\n-  remove_phi_nodes (new_bb);\n-\n-  return next_e;\n+  if (TREE_CODE (op) == SSA_NAME)\n+    loc = gimple_location (SSA_NAME_DEF_STMT (op));\n+  return loc;\n }\n \n-/* Returns the outermost loop in SCOP that contains BB.  */\n+/* Returns the incoming edges of basic_block BB in the pair.  The first edge is\n+   the init edge (from outside the loop) and the second one is the back edge\n+   from the same loop.  */\n+\n+std::pair<edge, edge>\n+get_edges (basic_block bb)\n+{\n+  std::pair<edge, edge> edges;\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (bb->loop_father != e->src->loop_father)\n+      edges.first = e;\n+    else\n+      edges.second = e;\n+  return edges;\n+}\n+\n+/* Copy the PHI arguments from OLD_PHI to the NEW_PHI.  The arguments to NEW_PHI\n+   must be found unless they can be POSTPONEd for later.  */\n+\n+void\n+copy_loop_phi_args (gphi *old_phi, init_back_edge_pair_t &ibp_old_bb,\n+\t\t    gphi *new_phi, init_back_edge_pair_t &ibp_new_bb,\n+\t\t    sese_info_p region, bool postpone)\n+{\n+  gcc_assert (gimple_phi_num_args (old_phi) == gimple_phi_num_args (new_phi));\n+\n+  basic_block new_bb = gimple_bb (new_phi);\n+  for (unsigned i = 0; i < gimple_phi_num_args (old_phi); i++)\n+    {\n+      edge e;\n+      if (gimple_phi_arg_edge (old_phi, i) == ibp_old_bb.first)\n+\te = ibp_new_bb.first;\n+      else\n+\te = ibp_new_bb.second;\n+\n+      tree old_name = gimple_phi_arg_def (old_phi, i);\n+      tree new_name = get_new_name (region, new_bb, old_name,\n+\t\t\t\t    gimple_bb (old_phi), true);\n+      if (new_name)\n+\t{\n+\t  add_phi_arg (new_phi, new_name, e, get_loc (old_name));\n+\t  continue;\n+\t}\n+\n+      gimple *old_def_stmt = SSA_NAME_DEF_STMT (old_name);\n+      if (!old_def_stmt || gimple_code (old_def_stmt) == GIMPLE_NOP)\n+      /* If the phi arg was a function arg, or wasn't defined, just use the old\n+\t name.  */\n+\tadd_phi_arg (new_phi, old_name, e, get_loc (old_name));\n+      else if (postpone)\n+\t{\n+\t  /* Postpone code gen for later for those back-edges we don't have the\n+\t     names yet.  */\n+\t  region->incomplete_phis.safe_push (std::make_pair (old_phi, new_phi));\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"\\n[codegen] postpone loop phi nodes: \");\n+\t}\n+      else\n+\t/* Either we should add the arg to phi or, we should postpone.  */\n+\tgcc_unreachable ();\n+    }\n+}\n+\n+/* Copy loop phi nodes from BB to NEW_BB.  */\n+\n+static bool\n+copy_loop_phi_nodes (basic_block bb, basic_block new_bb, sese_info_p region)\n+{\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n[codegen] copying loop phi nodes in bb_%d.\",\n+\t     new_bb->index);\n+\n+  /* Loop phi nodes should have only two arguments.  */\n+  gcc_assert (2 == EDGE_COUNT (bb->preds));\n+\n+  /* First edge is the init edge and second is the back edge.  */\n+  init_back_edge_pair_t ibp_old_bb = get_edges (bb);\n+\n+  /* First edge is the init edge and second is the back edge.  */\n+  init_back_edge_pair_t ibp_new_bb = get_edges (new_bb);\n+\n+  for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);\n+       gsi_next (&psi))\n+    {\n+      gphi *phi = psi.phi ();\n+      tree res = gimple_phi_result (phi);\n+      if (virtual_operand_p (res))\n+\tcontinue;\n+      if (is_gimple_reg (res) && scev_analyzable_p (res, region->region))\n+\tcontinue;\n+\n+      gphi *new_phi = create_phi_node (SSA_NAME_VAR (res), new_bb);\n+      tree new_res = create_new_def_for (res, new_phi,\n+\t\t\t\t\t gimple_phi_result_ptr (new_phi));\n+      set_rename (res, new_res, region);\n+      copy_loop_phi_args (phi, ibp_old_bb, new_phi, ibp_new_bb, region, true);\n+      update_stmt (new_phi);\n+    }\n+\n+  return true;\n+}\n+\n+/* Return the init value of PHI, the value coming from outside the loop.  */\n+\n+static tree\n+get_loop_init_value (gphi *phi)\n+{\n+\n+  loop_p loop = gimple_bb (phi)->loop_father;\n+\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, gimple_bb (phi)->preds)\n+    if (e->src->loop_father != loop)\n+      return gimple_phi_arg_def (phi, e->dest_idx);\n+\n+  return NULL_TREE;\n+}\n+\n+/* Find the init value (the value which comes from outside the loop), of one of\n+   the operands of DEF which is defined by a loop phi.  */\n+\n+static tree\n+find_init_value (gimple *def)\n+{\n+  if (gimple_code (def) == GIMPLE_PHI)\n+    return get_loop_init_value (as_a <gphi*> (def));\n+\n+  if (gimple_vuse (def))\n+    return NULL_TREE;\n+\n+  ssa_op_iter iter;\n+  use_operand_p use_p;\n+  FOR_EACH_SSA_USE_OPERAND (use_p, def, iter, SSA_OP_USE)\n+    {\n+      tree use = USE_FROM_PTR (use_p);\n+      if (TREE_CODE (use) == SSA_NAME)\n+\t{\n+\t  if (tree res = find_init_value (SSA_NAME_DEF_STMT (use)))\n+\t    return res;\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Return the init value, the value coming from outside the loop.  */\n+\n+static tree\n+find_init_value_close_phi (gphi *phi)\n+{\n+  gcc_assert (gimple_phi_num_args (phi) == 1);\n+  tree use_arg = gimple_phi_arg_def (phi, 0);\n+  gimple *def = SSA_NAME_DEF_STMT (use_arg);\n+  return find_init_value (def);\n+}\n+\n+/* Copy all the loop-close phi args from BB to NEW_BB.  */\n+\n+bool\n+copy_loop_close_phi_args (basic_block old_bb, basic_block new_bb,\n+\t\t\t  sese_info_p region, bool postpone)\n+{\n+  /* The successor of bb having close phi should be a merge of the diamond\n+     inserted to guard the loop during codegen.  */\n+  basic_block close_phi_merge_bb = single_succ (new_bb);\n+\n+  for (gphi_iterator psi = gsi_start_phis (old_bb); !gsi_end_p (psi);\n+       gsi_next (&psi))\n+    {\n+      gphi *phi = psi.phi ();\n+      tree res = gimple_phi_result (phi);\n+      if (virtual_operand_p (res))\n+\tcontinue;\n+\n+      if (is_gimple_reg (res) && scev_analyzable_p (res, region->region))\n+\t/* Loop close phi nodes should not be scev_analyzable_p.  */\n+\tgcc_unreachable ();\n+\n+      gphi *new_phi = create_phi_node (SSA_NAME_VAR (res), new_bb);\n+      tree new_res = create_new_def_for (res, new_phi,\n+\t\t\t\t\t gimple_phi_result_ptr (new_phi));\n+      set_rename (res, new_res, region);\n+\n+      tree old_name = gimple_phi_arg_def (phi, 0);\n+      tree new_name = get_new_name (region, new_bb, old_name, old_bb, false);\n+\n+      /* Predecessor basic blocks of a loop close phi should have been code\n+\t generated before.  FIXME: This is fixable by merging PHIs from inner\n+\t loops as well.  When we are looking at close-phi of an outer loop, and\n+\t arguments flowing out of inner loop as not been collected by the\n+\t outer-loop close phi, we will hit this situation.  For now we just bail\n+\t out.  See: gfortran.dg/graphite/interchange-3.f90.  */\n+      if (!new_name)\n+\treturn false;\n+\n+      add_phi_arg (new_phi, new_name, single_pred_edge (new_bb),\n+\t\t   get_loc (old_name));\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"\\n[codegen] Adding loop-closed phi: \");\n+\t  print_gimple_stmt (dump_file, new_phi, 0, 0);\n+\t}\n+\n+      update_stmt (new_phi);\n+\n+      /* When there is no loop guard around this codegenerated loop, there is no\n+\t need to collect the close-phi arg.  */\n+      if (2 != EDGE_COUNT (close_phi_merge_bb->preds))\n+\tcontinue;\n+\n+      /* Add a PHI in the close_phi_merge_bb for each close phi of the loop.  */\n+      tree init = find_init_value_close_phi (new_phi);\n+\n+      /* A close phi must come from a loop-phi having an init value.  */\n+      if (!init)\n+\t{\n+\t  gcc_assert (postpone);\n+\t  region->incomplete_phis.safe_push (std::make_pair (phi, new_phi));\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"\\n[codegen] postpone close phi nodes: \");\n+\t      print_gimple_stmt (dump_file, new_phi, 0, 0);\n+\t    }\n+\t  continue;\n+\t}\n+\n+      gphi *merge_phi = create_phi_node (SSA_NAME_VAR (res),\n+\t\t\t\t\t close_phi_merge_bb);\n+      tree merge_res = create_new_def_for (res, merge_phi,\n+\t\t\t\t\t   gimple_phi_result_ptr (merge_phi));\n+      set_rename (res, merge_res, region);\n+\n+      edge from_loop = single_succ_edge (new_bb);\n+      add_phi_arg (merge_phi, new_res, from_loop, get_loc (old_name));\n+\n+      /* The edge coming from loop guard.  */\n+      edge other = from_loop == (*close_phi_merge_bb->preds)[0]\n+\t? (*close_phi_merge_bb->preds)[1] : (*close_phi_merge_bb->preds)[0];\n+\n+      add_phi_arg (merge_phi, init, other, get_loc (old_name));\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"\\n[codegen] Adding guard-phi: \");\n+\t  print_gimple_stmt (dump_file, merge_phi, 0, 0);\n+\t}\n+\n+      update_stmt (new_phi);\n+    }\n+\n+  return true;\n+}\n+\n+/* Copy loop close phi nodes from BB to NEW_BB.  */\n+\n+static bool\n+copy_loop_close_phi_nodes (basic_block old_bb, basic_block new_bb,\n+\t\t\t   sese_info_p region)\n+{\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n[codegen] copying loop closed phi nodes in bb_%d.\",\n+\t     new_bb->index);\n+  /* Loop close phi nodes should have only one argument.  */\n+  gcc_assert (1 == EDGE_COUNT (old_bb->preds));\n+\n+  return copy_loop_close_phi_args (old_bb, new_bb, region, true);\n+}\n+\n+\n+/* Add NEW_NAME as the ARGNUM-th arg of NEW_PHI which is in NEW_BB.\n+   DOMINATING_PRED is the predecessor basic block of OLD_BB which dominates the\n+   other pred of OLD_BB as well.  If no such basic block exists then it is NULL.\n+   NON_DOMINATING_PRED is a pred which does not dominate OLD_BB, it cannot be\n+   NULL.\n+\n+   Case1: OLD_BB->preds {BB1, BB2} and BB1 does not dominate BB2 and vice versa.\n+   In this case DOMINATING_PRED = NULL.\n+\n+   Case2: OLD_BB->preds {BB1, BB2} and BB1 dominates BB2.\n+\n+   Returns true on successful copy of the args, false otherwise.  */\n+\n+static bool\n+add_phi_arg_for_new_expr (tree old_phi_args[2], tree new_phi_args[2],\n+\t\t\t  edge old_bb_dominating_edge,\n+\t\t\t  edge old_bb_non_dominating_edge,\n+\t\t\t  gphi *phi, gphi *new_phi,\n+\t\t\t  basic_block new_bb, sese_info_p region)\n+{\n+  basic_block def_pred[2];\n+  int not_found_bb_index = -1;\n+  for (int i = 0; i < 2; i++)\n+    {\n+      /* If the corresponding def_bb could not be found the entry will be\n+\t NULL.  */\n+      if (TREE_CODE (old_phi_args[i]) == INTEGER_CST)\n+\tdef_pred[i] = get_def_bb_for_const (region, new_bb,\n+\t\t\t\t\t gimple_phi_arg_edge (phi, i)->src);\n+      else\n+\tdef_pred[i] = gimple_bb (SSA_NAME_DEF_STMT (new_phi_args[i]));\n+      if (!def_pred[i])\n+\t{\n+\t  gcc_assert (not_found_bb_index == -1);\n+\t  not_found_bb_index = i;\n+\t}\n+    }\n+\n+  /* Here we are pattern matching on the structure of CFG w.r.t. old one.  */\n+  if (old_bb_dominating_edge)\n+    {\n+      return false;\n+      basic_block new_pred1 = (*new_bb->preds)[0]->src;\n+      basic_block new_pred2 = (*new_bb->preds)[1]->src;\n+      vec <basic_block> *bbs\n+\t= region->copied_bb_map->get (old_bb_non_dominating_edge->src);\n+      gcc_assert (bbs);\n+      basic_block new_pred = NULL;\n+      basic_block b;\n+      int i;\n+      FOR_EACH_VEC_ELT (*bbs, i, b)\n+\tif (new_pred1 == b || new_pred2 == b)\n+\t  {\n+\t    gcc_assert (!new_pred);\n+\t    new_pred = b;\n+\t  }\n+\n+      gcc_assert (new_pred);\n+\n+      edge new_non_dominating_edge = find_edge (new_pred, new_bb);\n+      /* By the process of elimination we first insert insert phi-edge for\n+\t non-dominating pred which is computed above and then we insert the\n+\t remaining one.  */\n+      int inserted_edge = 0;\n+      for (; inserted_edge < 2; inserted_edge++)\n+\t{\n+\t  edge new_bb_pred_edge = gimple_phi_arg_edge (phi, inserted_edge);\n+\t  if (new_non_dominating_edge == new_bb_pred_edge)\n+\t    {\n+\t      add_phi_arg (new_phi, new_phi_args[inserted_edge],\n+\t\t\t   new_non_dominating_edge,\n+\t\t\t   get_loc (old_phi_args[inserted_edge]));\n+\t      break;\n+\t    }\n+\t}\n+\n+      int edge_dominating = 0;\n+      if (inserted_edge == 0)\n+\tedge_dominating = 1;\n+\n+      edge new_dominating_edge = NULL;\n+      for (int i; i < 2; i++)\n+\t{\n+\t  edge e = gimple_phi_arg_edge (new_phi, i);\n+\t  if (e != new_non_dominating_edge)\n+\t    new_dominating_edge = e;\n+\t}\n+\n+      add_phi_arg (new_phi, new_phi_args[edge_dominating], new_dominating_edge,\n+\t\t   get_loc (old_phi_args[inserted_edge]));\n+    }\n+  else\n+    {\n+      /* Classic diamond structure: both edges are non-dominating.  We need to\n+\t find one unique edge then the other can be found be elimination.  If\n+\t any definition (def_pred) dominates both the preds of new_bb then we\n+\t bail out.  Entries of def_pred maybe NULL, in that case we must\n+\t uniquely find pred with help of only one entry.  */\n+      edge new_e[2] = { NULL, NULL };\n+      for (int i = 0; i < 2; i++)\n+\t{\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  FOR_EACH_EDGE (e, ei, new_bb->preds)\n+\t    if (def_pred[i]\n+\t\t&& dominated_by_p (CDI_DOMINATORS, e->src, def_pred[i]))\n+\t      {\n+\t\tif (new_e[i])\n+\t\t  /* We do not know how to handle the case when def_pred\n+\t\t     dominates more than a predecessor.  */\n+\t\t  return false;\n+\t\tnew_e[i] = e;\n+\t      }\n+\t}\n+\n+      gcc_assert (new_e[0] || new_e[1]);\n+\n+      /* Find the other edge by process of elimination.  */\n+      if (not_found_bb_index != -1)\n+\t{\n+\t  gcc_assert (!new_e[not_found_bb_index]);\n+\t  int found_bb_index = not_found_bb_index == 1 ? 0 : 1;\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  FOR_EACH_EDGE (e, ei, new_bb->preds)\n+\t    {\n+\t      if (new_e[found_bb_index] == e)\n+\t\tcontinue;\n+\t      new_e[not_found_bb_index] = e;\n+\t    }\n+\t}\n+\n+      /* Add edges to phi args.  */\n+      for (int i = 0; i < 2; i++)\n+\tadd_phi_arg (new_phi, new_phi_args[i], new_e[i],\n+\t\t     get_loc (old_phi_args[i]));\n+    }\n+\n+  return true;\n+}\n+\n+/* Copy the arguments of cond-phi node PHI, to NEW_PHI in the codegenerated\n+   region.  If postpone is true and it isn't possible to copy any arg of PHI,\n+   the PHI is added to the REGION->INCOMPLETE_PHIS to be codegenerated\n+   later.  Returns false if the copying was unsuccessful.  */\n+\n+bool\n+copy_cond_phi_args (gphi *phi, gphi *new_phi, vec<tree> iv_map,\n+\t\t    sese_info_p region, bool postpone)\n+{\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n[codegen] copying cond phi args: \");\n+  gcc_assert (2 == gimple_phi_num_args (phi));\n+\n+  basic_block new_bb = gimple_bb (new_phi);\n+  loop_p loop = gimple_bb (phi)->loop_father;\n+\n+  basic_block old_bb = gimple_bb (phi);\n+  edge old_bb_non_dominating_edge = NULL, old_bb_dominating_edge = NULL;\n+\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, old_bb->preds)\n+    if (!dominated_by_p (CDI_DOMINATORS, old_bb, e->src))\n+      old_bb_non_dominating_edge = e;\n+    else\n+      old_bb_dominating_edge = e;\n+\n+  gcc_assert (!dominated_by_p (CDI_DOMINATORS, old_bb,\n+\t\t\t       old_bb_non_dominating_edge->src));\n+\n+  tree new_phi_args[2];\n+  tree old_phi_args[2];\n+\n+  for (unsigned i = 0; i < gimple_phi_num_args (phi); i++)\n+    {\n+      tree old_name = gimple_phi_arg_def (phi, i);\n+      tree new_name = get_new_name (region, new_bb, old_name, old_bb, false);\n+      old_phi_args[i] = old_name;\n+      if (new_name)\n+\t{\n+\t  new_phi_args [i] = new_name;\n+\t  continue;\n+\t}\n+\n+      if (vec_find (region->params, old_name))\n+\t{\n+\t  new_phi_args [i] = old_name;\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file,\n+\t\t       \"\\n[codegen] parameter argument to phi, new_expr: \");\n+\t      print_gimple_stmt (dump_file, new_phi, 0, 0);\n+\t    }\n+\t  continue;\n+\t}\n+\n+      /* If the phi-arg is scev-analyzeable but only in the first stage.  */\n+      if (postpone && is_gimple_reg (old_name)\n+\t  && scev_analyzable_p (old_name, region->region))\n+\t{\n+\t  gimple_seq stmts;\n+\t  bool gloog_error = false;\n+\t  tree new_expr\n+\t    = get_rename_from_scev (old_name, &stmts, loop, new_bb,\n+\t\t\t\t    old_bb, iv_map, region, &gloog_error);\n+\t  if (gloog_error)\n+\t    return false;\n+\n+\t  gcc_assert (new_expr);\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"\\n[codegen] scev analyzeable, new_expr: \");\n+\t      print_generic_expr (dump_file, new_expr, 0);\n+\t    }\n+\t  gsi_insert_earliest (stmts, region);\n+\t  new_phi_args [i] = new_name;\n+\t  continue;\n+\t}\n+\n+      gimple *old_def_stmt = SSA_NAME_DEF_STMT (old_name);\n+      if (!old_def_stmt || gimple_code (old_def_stmt) == GIMPLE_NOP)\n+\t/* If the phi arg was a function arg, or wasn't defined, just use the\n+\t   old name.  */\n+\tgcc_unreachable ();\n+      else if (postpone)\n+\t{\n+\t  /* Postpone code gen for later for back-edges.  */\n+\t  region->incomplete_phis.safe_push (std::make_pair (phi, new_phi));\n+\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"\\n[codegen] postpone cond phi nodes: \");\n+\t      print_gimple_stmt (dump_file, new_phi, 0, 0);\n+\t    }\n+\n+\t  new_phi_args [i] = NULL_TREE;\n+\t  continue;\n+\t}\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n+  return add_phi_arg_for_new_expr (old_phi_args, new_phi_args,\n+\t\t\t\t   old_bb_dominating_edge,\n+\t\t\t\t   old_bb_non_dominating_edge,\n+\t\t\t\t   phi, new_phi, new_bb, region);\n+}\n+\n+/* Copy cond phi nodes from BB to NEW_BB.  */\n+\n+static bool\n+copy_cond_phi_nodes (basic_block bb, basic_block new_bb, vec<tree> iv_map,\n+\t\t     sese_info_p region)\n+{\n+\n+  gcc_assert (!bb_contains_loop_close_phi_nodes (bb));\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n[codegen] copying cond phi nodes in bb_%d:\",\n+\t     new_bb->index);\n+\n+  /* Cond phi nodes should have exactly two arguments.  */\n+  gcc_assert (2 == EDGE_COUNT (bb->preds));\n+\n+  for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);\n+       gsi_next (&psi))\n+    {\n+      gphi *phi = psi.phi ();\n+      tree res = gimple_phi_result (phi);\n+      if (virtual_operand_p (res))\n+\tcontinue;\n+      if (is_gimple_reg (res) && scev_analyzable_p (res, region->region))\n+\t/* Cond phi nodes should not be scev_analyzable_p.  */\n+\tgcc_unreachable ();\n+\n+      gphi *new_phi = create_phi_node (SSA_NAME_VAR (res), new_bb);\n+      tree new_res = create_new_def_for (res, new_phi,\n+\t\t\t\t\t gimple_phi_result_ptr (new_phi));\n+      set_rename (res, new_res, region);\n+\n+      if (!copy_cond_phi_args (phi, new_phi, iv_map, region, true))\n+\treturn false;\n+\n+      update_stmt (new_phi);\n+    }\n+\n+  return true;\n+}\n+\n+/* Return true if STMT should be copied from region to the\n+   new code-generated region.  LABELs, CONDITIONS, induction-variables\n+   and region parameters need not be copied.  */\n+\n+static bool\n+should_copy_to_new_region (gimple *stmt, sese_info_p region)\n+{\n+  /* Do not copy labels or conditions.  */\n+  if (gimple_code (stmt) == GIMPLE_LABEL\n+      || gimple_code (stmt) == GIMPLE_COND)\n+    return false;\n+\n+  tree lhs;\n+  /* Do not copy induction variables.  */\n+  if (is_gimple_assign (stmt)\n+      && (lhs = gimple_assign_lhs (stmt))\n+      && TREE_CODE (lhs) == SSA_NAME\n+      && is_gimple_reg (lhs)\n+      && scev_analyzable_p (lhs, region->region))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Create new names for all the definitions created by COPY and\n+   add replacement mappings for each new name.  */\n+\n+static void\n+set_rename_for_each_def (gimple *stmt, sese_info_p region)\n+{\n+  def_operand_p def_p;\n+  ssa_op_iter op_iter;\n+  FOR_EACH_SSA_DEF_OPERAND (def_p, stmt, op_iter, SSA_OP_ALL_DEFS)\n+    {\n+      tree old_name = DEF_FROM_PTR (def_p);\n+      tree new_name = create_new_def_for (old_name, stmt, def_p);\n+      set_rename (old_name, new_name, region);\n+    }\n+}\n+\n+/* Duplicates the statements of basic block BB into basic block NEW_BB\n+   and compute the new induction variables according to the IV_MAP.\n+   GLOOG_ERROR is set when the code generation cannot continue.  */\n+static bool\n+graphite_copy_stmts_from_block (basic_block bb, basic_block new_bb,\n+\t\t\t\tvec<tree> iv_map, sese_info_p region,\n+\t\t\t\tbool *gloog_error)\n+{\n+  /* Iterator poining to the place where new statement (s) will be inserted.  */\n+  gimple_stmt_iterator gsi_tgt = gsi_last_bb (new_bb);\n+\n+  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);\n+       gsi_next (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+      if (!should_copy_to_new_region (stmt, region))\n+\tcontinue;\n+\n+      /* Create a new copy of STMT and duplicate STMT's virtual\n+\t operands.  */\n+      gimple *copy = gimple_copy (stmt);\n+      gsi_insert_after (&gsi_tgt, copy, GSI_NEW_STMT);\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"\\n[codegen] inserting statement: \");\n+\t  print_gimple_stmt (dump_file, copy, 0, 0);\n+\t}\n+\n+      maybe_duplicate_eh_stmt (copy, stmt);\n+      gimple_duplicate_stmt_histograms (cfun, copy, cfun, stmt);\n+\n+      /* Crete new names for each def in the copied stmt.  */\n+      set_rename_for_each_def (copy, region);\n+\n+      loop_p loop = bb->loop_father;\n+      if (rename_uses (copy, &gsi_tgt, bb, region, loop, iv_map, gloog_error))\n+\t{\n+\t  fold_stmt_inplace (&gsi_tgt);\n+\t  gcc_assert (gsi_stmt (gsi_tgt) == copy);\n+\t}\n+\n+      if (*gloog_error)\n+\treturn false;\n+\n+      update_stmt (copy);\n+    }\n+\n+  return true;\n+}\n+\n+/* Copies BB and includes in the copied BB all the statements that can\n+   be reached following the use-def chains from the memory accesses,\n+   and returns the next edge following this new block.  GLOOG_ERROR is\n+   set when the code generation cannot continue.  */\n+\n+edge\n+copy_bb_and_scalar_dependences (basic_block bb, sese_info_p region,\n+\t\t\t\tedge next_e, vec<tree> iv_map,\n+\t\t\t\tbool *codegen_err)\n+{\n+  int num_phis = number_of_phi_nodes (bb);\n+\n+  if (region->copied_bb_map->get (bb))\n+    {\n+      /* FIXME: We do not handle inner loop unrolling when the inner loop has\n+\t phi-nodes.  In that case inner loop will be copied multiple times\n+\t outside the region.  */\n+      if (num_phis)\n+\t{\n+\t  *codegen_err = true;\n+\t  return NULL;\n+\t}\n+    }\n+\n+  basic_block new_bb = split_edge (next_e);\n+  if (num_phis > 0 && bb_contains_loop_phi_nodes (bb))\n+    {\n+      basic_block phi_bb = next_e->dest->loop_father->header;\n+\n+      /* At this point we are unable to codegenerate by still preserving the SSA\n+\t structure because maybe the loop is completely unrolled and the PHIs\n+\t and cross-bb scalar dependencies are untrackable w.r.t. the original\n+\t code.  See gfortran.dg/graphite/pr29832.f90.  */\n+      if (EDGE_COUNT (bb->preds) != EDGE_COUNT (phi_bb->preds))\n+\t{\n+\t  *codegen_err = true;\n+\t  return NULL;\n+\t}\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\n[codegen] bb_%d contains loop phi nodes\",\n+\t\t bb->index);\n+      if (!copy_loop_phi_nodes (bb, phi_bb, region))\n+\t{\n+\t  *codegen_err = true;\n+\t  return NULL;\n+\t}\n+    }\n+  else if (bb_contains_loop_close_phi_nodes (bb))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\n[codegen] bb_%d contains close phi nodes\",\n+\t\t bb->index);\n+\n+      /* Make sure that NEW_BB is the loop->exit->dest.  */\n+      edge e = single_pred_edge (new_bb);\n+      basic_block phi_bb = new_bb;\n+      if (e->src->loop_father == e->dest->loop_father)\n+\t{\n+\t  /* This is one of the places which shows preserving original structure\n+\t     is not always possible, as we may need to insert close PHI for a\n+\t     loop where the latch does not have any mapping, or the mapping is\n+\t     ambiguous.  */\n+\t  basic_block old_loop_bb = single_pred_edge (bb)->src;\n+\t  vec <basic_block> *bbs = region->copied_bb_map->get (old_loop_bb);\n+\t  if (!bbs || bbs->length () != 1)\n+\t    {\n+\t      *codegen_err = true;\n+\t      return NULL;\n+\t    }\n+\n+\t  basic_block new_loop_bb = (*bbs)[0];\n+\t  loop_p new_loop = new_loop_bb->loop_father;\n+\t  phi_bb = single_exit (new_loop)->dest;\n+\t  e = single_pred_edge (phi_bb);\n+\t}\n+\n+      gcc_assert (e->src->loop_father != e->dest->loop_father);\n+\n+      if (!copy_loop_close_phi_nodes (bb, phi_bb, region))\n+\t{\n+\t  *codegen_err = true;\n+\t  return NULL;\n+\t}\n+    }\n+  else if (num_phis > 0)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\n[codegen] bb_%d contains cond phi nodes\",\n+\t\t bb->index);\n+\n+      basic_block phi_bb = single_pred (new_bb);\n+      loop_p loop_father = new_bb->loop_father;\n+\n+      /* Move back until we find the block with two predecessors.  */\n+      while (single_pred_p (phi_bb))\n+\tphi_bb = single_pred_edge (phi_bb)->src;\n+\n+      /* If a corresponding merge-point was not found, then abort codegen.  */\n+      if (phi_bb->loop_father != loop_father\n+\t  || !copy_cond_phi_nodes (bb, phi_bb, iv_map, region))\n+\t{\n+\t  *codegen_err = true;\n+\t  return NULL;\n+\t}\n+    }\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"\\n[codegen] copying from bb_%d to bb_%d\",\n+\t     bb->index, new_bb->index);\n+\n+  vec <basic_block> *copied_bbs = region->copied_bb_map->get (bb);\n+  if (copied_bbs)\n+    copied_bbs->safe_push (new_bb);\n+  else\n+    {\n+      vec<basic_block> bbs;\n+      bbs.create (2);\n+      bbs.safe_push (new_bb);\n+      region->copied_bb_map->put (bb, bbs);\n+    }\n+\n+  if (!graphite_copy_stmts_from_block (bb, new_bb, iv_map, region, codegen_err))\n+    {\n+      *codegen_err = true;\n+      return NULL;\n+    }\n+\n+  return single_succ_edge (new_bb);\n+}\n+\n+/* Returns the outermost loop in SCOP that contains BB.  */\n \n struct loop *\n outermost_loop_in_sese_1 (sese_l &region, basic_block bb)\n@@ -759,8 +2034,6 @@ set_ifsese_condition (ifsese if_region, tree condition)\n bool\n invariant_in_sese_p_rec (tree t, sese_l &region, bool *has_vdefs)\n {\n-  ssa_op_iter iter;\n-  use_operand_p use_p;\n   if (!defined_in_sese_p (t, region))\n     return true;\n \n@@ -782,6 +2055,8 @@ invariant_in_sese_p_rec (tree t, sese_l &region, bool *has_vdefs)\n   if (tree vuse = gimple_vuse (stmt))\n     return invariant_in_sese_p_rec (vuse, region, has_vdefs);\n \n+  ssa_op_iter iter;\n+  use_operand_p use_p;\n   FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)\n     {\n       tree use = USE_FROM_PTR (use_p);"}, {"sha": "bce226a6cfc4315f102709ccc12c2b74009eb02c", "filename": "gcc/sese.h", "status": "modified", "additions": 54, "deletions": 6, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65b016eb13b67dd990f30a55948a623d9deadd11/gcc%2Fsese.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65b016eb13b67dd990f30a55948a623d9deadd11/gcc%2Fsese.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.h?ref=65b016eb13b67dd990f30a55948a623d9deadd11", "patch": "@@ -22,6 +22,14 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_SESE_H\n #define GCC_SESE_H\n \n+typedef hash_map<basic_block, vec<basic_block> > bb_map_t;\n+typedef hash_map<tree, vec<tree> > rename_map_t;\n+typedef struct ifsese_s *ifsese;\n+/* First phi is the new codegenerated phi second one is original phi.  */\n+typedef std::pair <gphi *, gphi *> phi_rename;\n+/* First edge is the init edge and second is the back edge w.r.t. a loop.  */\n+typedef std::pair<edge, edge> init_back_edge_pair_t;\n+\n /* A Single Entry, Single Exit region is a part of the CFG delimited\n    by two edges.  */\n struct sese_l\n@@ -50,6 +58,20 @@ get_exit_bb (sese_l &s)\n   return s.exit->src;\n }\n \n+/* Returns the index of V where ELEM can be found. -1 Otherwise.  */\n+\n+template<typename T>\n+int\n+vec_find (const vec<T> &v, const T &elem)\n+{\n+  int i;\n+  T t;\n+  FOR_EACH_VEC_ELT (v, i, t)\n+    if (elem == t)\n+      return i;\n+  return -1;\n+}\n+\n /* A helper structure for bookkeeping information about a scop in graphite.  */\n typedef struct sese_info_t\n {\n@@ -59,17 +81,29 @@ typedef struct sese_info_t\n   /* Parameters used within the SCOP.  */\n   vec<tree> params;\n \n+  /* Maps an old name to one or more new names.  When there are several new\n+     names, one has to select the definition corresponding to the immediate\n+     dominator.  */\n+  rename_map_t *rename_map;\n+\n   /* Loops completely contained in this SESE.  */\n   bitmap loops;\n   vec<loop_p> loop_nest;\n \n   /* Basic blocks contained in this SESE.  */\n   vec<basic_block> bbs;\n-} *sese_info_p;\n \n-#define SESE_PARAMS(S) (S->params)\n-#define SESE_LOOPS(S) (S->loops)\n-#define SESE_LOOP_NEST(S) (S->loop_nest)\n+  /* Copied basic blocks indexed by the original bb.  */\n+  bb_map_t *copied_bb_map;\n+\n+  /* A vector of phi nodes to be updated when all arguments are available.  The\n+     pair contains first the old_phi and second the new_phi.  */\n+  vec<phi_rename> incomplete_phis;\n+\n+  /* The condition region generated for this sese.  */\n+  ifsese if_region;\n+\n+} *sese_info_p;\n \n extern sese_info_p new_sese_info (edge, edge);\n extern void free_sese_info (sese_info_p);\n@@ -80,21 +114,31 @@ extern edge copy_bb_and_scalar_dependences (basic_block, sese_info_p, edge,\n extern struct loop *outermost_loop_in_sese (sese_l &, basic_block);\n extern tree scalar_evolution_in_region (sese_l &, loop_p, tree);\n extern bool invariant_in_sese_p_rec (tree, sese_l &, bool *);\n+extern bool bb_contains_loop_phi_nodes (basic_block);\n+extern bool bb_contains_loop_close_phi_nodes (basic_block);\n+extern std::pair<edge, edge> get_edges (basic_block bb);\n+extern void copy_loop_phi_args (gphi *, init_back_edge_pair_t &,\n+\t\t\t\tgphi *, init_back_edge_pair_t &,\n+\t\t\t\tsese_info_p, bool);\n+extern bool copy_loop_close_phi_args (basic_block, basic_block,\n+\t\t\t\t      sese_info_p, bool);\n+extern bool copy_cond_phi_args (gphi *, gphi *, vec<tree>,\n+\t\t\t\tsese_info_p, bool);\n \n /* Check that SESE contains LOOP.  */\n \n static inline bool\n sese_contains_loop (sese_info_p sese, struct loop *loop)\n {\n-  return bitmap_bit_p (SESE_LOOPS (sese), loop->num);\n+  return bitmap_bit_p (sese->loops, loop->num);\n }\n \n /* The number of parameters in REGION. */\n \n static inline unsigned\n sese_nb_params (sese_info_p region)\n {\n-  return SESE_PARAMS (region).length ();\n+  return region->params.length ();\n }\n \n /* Checks whether BB is contained in the region delimited by ENTRY and\n@@ -239,6 +283,8 @@ recompute_all_dominators (void)\n   calculate_dominance_info (CDI_POST_DOMINATORS);\n }\n \n+typedef std::pair <gimple *, tree> scalar_use;\n+\n typedef struct gimple_poly_bb\n {\n   basic_block bb;\n@@ -267,6 +313,8 @@ typedef struct gimple_poly_bb\n   vec<gimple *> conditions;\n   vec<gimple *> condition_cases;\n   vec<data_reference_p> data_refs;\n+  vec<scalar_use> read_scalar_refs;\n+  vec<tree> write_scalar_refs;\n } *gimple_poly_bb_p;\n \n #define GBB_BB(GBB) (GBB)->bb"}]}