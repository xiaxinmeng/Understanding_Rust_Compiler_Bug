{"sha": "abe6e52f2327fb3eeb45e40eeeea83033485daa1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJlNmU1MmYyMzI3ZmIzZWViNDVlNDBlZWVlYTgzMDMzNDg1ZGFhMQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-12-31T11:44:59Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-12-31T11:44:59Z"}, "message": "(added_links_insn): New variable.\n\n(distribute_links): Set it.\n(if_then_else_cond): New function.\n(try_combine): Return added_links_insn if it is earlier than what we would\notherwise return.\n(subst): Generalize (OP X Y) to call if_then_else_cond instead of only\nchecking for an explicit IF_THEN_ELSE.\n(subst, case IF_THEN_ELSE): When converting to a MULT, simplify the MULT\nbefore putting it into OP.\n(subst, case AND): Don't make IF_THEN_ELSE here; now made in generic case\nearlier.\n\nFrom-SVN: r6343", "tree": {"sha": "704d7314fe48f3331d4c3c7ddf53fd07c81ee40f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/704d7314fe48f3331d4c3c7ddf53fd07c81ee40f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abe6e52f2327fb3eeb45e40eeeea83033485daa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abe6e52f2327fb3eeb45e40eeeea83033485daa1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abe6e52f2327fb3eeb45e40eeeea83033485daa1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abe6e52f2327fb3eeb45e40eeeea83033485daa1/comments", "author": null, "committer": null, "parents": [{"sha": "e3d616e3da1033aa9417bebf8005854cc4621d63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3d616e3da1033aa9417bebf8005854cc4621d63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3d616e3da1033aa9417bebf8005854cc4621d63"}], "stats": {"total": 263, "additions": 186, "deletions": 77}, "files": [{"sha": "a71b201859477df6682c3dace83f3e1cdb911180", "filename": "gcc/combine.c", "status": "modified", "additions": 186, "deletions": 77, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe6e52f2327fb3eeb45e40eeeea83033485daa1/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe6e52f2327fb3eeb45e40eeeea83033485daa1/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=abe6e52f2327fb3eeb45e40eeeea83033485daa1", "patch": "@@ -173,6 +173,12 @@ static rtx subst_prev_insn;\n \n static int subst_low_cuid;\n \n+/* This is an insn to which a LOG_LINKS entry has been added.  If this\n+   insn is the earlier than I2 or I3, combine should rescan starting at\n+   that location.  */\n+\n+static rtx added_links_insn;\n+\n /* This is the value of undobuf.num_undo when we started processing this \n    substitution.  This will prevent gen_rtx_combine from re-used a piece\n    from the previous expression.  Doing so can produce circular rtl\n@@ -377,6 +383,7 @@ static rtx make_compound_operation  PROTO((rtx, enum rtx_code));\n static int get_pos_from_mask\tPROTO((unsigned HOST_WIDE_INT, int *));\n static rtx force_to_mode\tPROTO((rtx, enum machine_mode,\n \t\t\t\t       unsigned HOST_WIDE_INT, rtx, int));\n+static rtx if_then_else_cond\tPROTO((rtx, rtx *, rtx *));\n static rtx known_cond\t\tPROTO((rtx, enum rtx_code, rtx, rtx));\n static rtx make_field_assignment  PROTO((rtx));\n static rtx apply_distributive_law  PROTO((rtx));\n@@ -1136,8 +1143,9 @@ combinable_i3pat (i3, loc, i2dest, i1dest, i1_not_in_src, pi3dest_killed)\n    and I1 is pseudo-deleted by turning it into a NOTE.  Otherwise, I1 and I2\n    are pseudo-deleted.\n \n-   If we created two insns, return I2; otherwise return I3.\n-   Return 0 if the combination does not work.  Then nothing is changed.  */\n+   Return 0 if the combination does not work.  Then nothing is changed. \n+   If we did the combination, return the insn at which combine should\n+   resume scanning.  */\n \n static rtx\n try_combine (i3, i2, i1)\n@@ -1201,6 +1209,7 @@ try_combine (i3, i2, i1)\n     temp = i1, i1 = i2, i2 = temp;\n \n   subst_prev_insn = 0;\n+  added_links_insn = 0;\n \n   /* First check for one important special-case that the code below will\n      not handle.  Namely, the case where I1 is zero, I2 has multiple sets,\n@@ -2291,7 +2300,12 @@ try_combine (i3, i2, i1)\n \n   combine_successes++;\n \n-  return newi2pat ? i2 : i3;\n+  if (added_links_insn\n+      && (newi2pat == 0 || INSN_CUID (added_links_insn) < INSN_CUID (i2))\n+      && INSN_CUID (added_links_insn) < INSN_CUID (i3))\n+    return added_links_insn;\n+  else\n+    return newi2pat ? i2 : i3;\n }\n \f\n /* Undo all the modifications recorded in undobuf.  */\n@@ -2941,55 +2955,63 @@ subst (x, from, to, in_dest, unique_copy)\n \n   /* If this is a simple operation applied to an IF_THEN_ELSE, try \n      applying it to the arms of the IF_THEN_ELSE.  This often simplifies\n-     things.  Don't deal with operations that change modes here.  */\n-\n-  if ((GET_RTX_CLASS (code) == '2' || GET_RTX_CLASS (code) == 'c')\n-      && GET_CODE (XEXP (x, 0)) == IF_THEN_ELSE)\n+     things.  Check for cases where both arms are testing the same\n+     condition.\n+\n+     Don't do anything if all operands are very simple.  */\n+\n+  if (((GET_RTX_CLASS (code) == '2' || GET_RTX_CLASS (code) == 'c'\n+\t|| GET_RTX_CLASS (code) == '<')\n+       && ((GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) != 'o'\n+\t    && ! (GET_CODE (XEXP (x, 0)) == SUBREG\n+\t\t  && (GET_RTX_CLASS (GET_CODE (SUBREG_REG (XEXP (x, 0))))\n+\t\t      == 'o')))\n+\t   || (GET_RTX_CLASS (GET_CODE (XEXP (x, 1))) != 'o'\n+\t       && ! (GET_CODE (XEXP (x, 1)) == SUBREG\n+\t\t     && (GET_RTX_CLASS (GET_CODE (SUBREG_REG (XEXP (x, 1))))\n+\t\t\t == 'o')))))\n+      || (GET_RTX_CLASS (code) == '1'\n+\t  && ((GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) != 'o'\n+\t       && ! (GET_CODE (XEXP (x, 0)) == SUBREG\n+\t\t     && (GET_RTX_CLASS (GET_CODE (SUBREG_REG (XEXP (x, 0))))\n+\t\t\t == 'o'))))))\n     {\n-      /* Don't do this by using SUBST inside X since we might be messing\n-\t up a shared expression.  */\n-      rtx cond = XEXP (XEXP (x, 0), 0);\n-      rtx t_arm = subst (gen_binary (code, mode, XEXP (XEXP (x, 0), 1),\n-\t\t\t\t     XEXP (x, 1)),\n-\t\t\t pc_rtx, pc_rtx, 0, 0);\n-      rtx f_arm = subst (gen_binary (code, mode, XEXP (XEXP (x, 0), 2),\n-\t\t\t\t     XEXP (x, 1)),\n-\t\t\t pc_rtx, pc_rtx, 0, 0);\n-\n-\n-      x = gen_rtx (IF_THEN_ELSE, mode, cond, t_arm, f_arm);\n-      goto restart;\n-    }\n-\n-  else if ((GET_RTX_CLASS (code) == '2' || GET_RTX_CLASS (code) == 'c')\n-\t   && GET_CODE (XEXP (x, 1)) == IF_THEN_ELSE)\n-    {\n-      /* Don't do this by using SUBST inside X since we might be messing\n-\t up a shared expression.  */\n-      rtx cond = XEXP (XEXP (x, 1), 0);\n-      rtx t_arm = subst (gen_binary (code, mode, XEXP (x, 0),\n-\t\t\t\t     XEXP (XEXP (x, 1), 1)),\n-\t\t\t pc_rtx, pc_rtx, 0, 0);\n-      rtx f_arm = subst (gen_binary (code, mode, XEXP (x, 0),\n-\t\t\t\t     XEXP (XEXP (x, 1), 2)),\n-\t\t\t pc_rtx, pc_rtx, 0, 0);\n-\n-      x = gen_rtx (IF_THEN_ELSE, mode, cond, t_arm, f_arm);\n-      goto restart;\n-    }\n+      rtx cond, true, false;\n+\n+      cond = if_then_else_cond (x, &true, &false);\n+      if (cond != 0)\n+\t{\n+\t  rtx cop1 = const0_rtx;\n+\t  enum rtx_code cond_code = simplify_comparison (NE, &cond, &cop1);\n+\n+\t  /* If the result values are STORE_FLAG_VALUE and zero, we can\n+\t     just make the comparison operation.  */\n+\t  if (true == const_true_rtx && false == const0_rtx)\n+\t    x = gen_binary (cond_code, mode, cond, cop1);\n+\t  else if (true == const0_rtx && false == const_true_rtx)\n+\t    x = gen_binary (reverse_condition (cond_code), mode, cond, cop1);\n+\n+\t  /* Likewise, we can make the negate of a comparison operation\n+\t     if the result values are - STORE_FLAG_VALUE and zero.  */\n+\t  else if (GET_CODE (true) == CONST_INT\n+\t\t   && INTVAL (true) == - STORE_FLAG_VALUE\n+\t\t   && false == const0_rtx)\n+\t    x = gen_unary (NEG, mode,\n+\t\t\t   gen_binary (cond_code, mode, cond, cop1));\n+\t  else if (GET_CODE (false) == CONST_INT\n+\t\t   && INTVAL (false) == - STORE_FLAG_VALUE\n+\t\t   && true == const0_rtx)\n+\t    x = gen_unary (NEG, mode,\n+\t\t\t   gen_binary (reverse_condition (cond_code), \n+\t\t\t\t       mode, cond, cop1));\n+\t  else\n+\t    x = gen_rtx (IF_THEN_ELSE, mode,\n+\t\t\t gen_binary (cond_code, VOIDmode, cond, cop1),\n+\t\t\t subst (true, pc_rtx, pc_rtx, 0, 0),\n+\t\t\t subst (false, pc_rtx, pc_rtx, 0, 0));\n \n-  else if (GET_RTX_CLASS (code) == '1'\n-\t   && GET_CODE (XEXP (x, 0)) == IF_THEN_ELSE\n-\t   && GET_MODE (XEXP (x, 0)) == mode)\n-    {\n-      rtx cond = XEXP (XEXP (x, 0), 0);\n-      rtx t_arm = subst (gen_unary (code, mode, XEXP (XEXP (x, 0), 1)),\n-\t\t\t pc_rtx, pc_rtx, 0, 0);\n-      rtx f_arm = subst (gen_unary (code, mode, XEXP (XEXP (x, 0), 2)),\n-\t\t\t pc_rtx, pc_rtx, 0, 0);\n-\n-      x = gen_rtx_combine (IF_THEN_ELSE, mode, cond, t_arm, f_arm);\n-      goto restart;\n+\t  goto restart;\n+\t}\n     }\n \n   /* Try to fold this expression in case we have constants that weren't\n@@ -4042,6 +4064,8 @@ subst (x, from, to, in_dest, unique_copy)\n \t\t\t\t gen_binary (MULT, m, c1,\n \t\t\t\t\t     GEN_INT (STORE_FLAG_VALUE)));\n \n+\t      temp = subst (temp, pc_rtx, pc_rtx, 0, 0);\n+\n \t      temp = gen_binary (op, m, gen_lowpart_for_combine (m, z), temp);\n \n \t      if (extend_op != NIL)\n@@ -4405,33 +4429,6 @@ subst (x, from, to, in_dest, unique_copy)\n \t  goto restart;\n \t}\n \n-      /* If we have (and A B) with A not an object but that is known to\n-\t be -1 or 0, this is equivalent to the expression\n-\t (if_then_else (ne A (const_int 0)) B (const_int 0))\n-\t We make this conversion because it may allow further\n-\t simplifications and then allow use of conditional move insns.\n-\t If the machine doesn't have condition moves, code in case SET\n-\t will convert the IF_THEN_ELSE back to the logical operation.\n-\t We build the IF_THEN_ELSE here in case further simplification\n-\t is possible (e.g., we can convert it to ABS).  */\n-\n-      if (GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) != 'o'\n-\t  && ! (GET_CODE (XEXP (x, 0)) == SUBREG\n-\t\t&& GET_RTX_CLASS (GET_CODE (SUBREG_REG (XEXP (x, 0)))) == 'o')\n-\t  && (num_sign_bit_copies (XEXP (x, 0), GET_MODE (XEXP (x, 0)))\n-\t      == GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)))))\n-\t{\n-\t  rtx op0 = XEXP (x, 0);\n-\t  rtx op1 = const0_rtx;\n-\t  enum rtx_code comp_code\n-\t    = simplify_comparison (NE, &op0, &op1);\n-\n-\t  x =  gen_rtx_combine (IF_THEN_ELSE, mode,\n-\t\t\t\tgen_binary (comp_code, VOIDmode, op0, op1),\n-\t\t\t\tXEXP (x, 1), const0_rtx);\n-\t  goto restart;\n-\t}\n-\n       /* In the following group of tests (and those in case IOR below),\n \t we start with some combination of logical operations and apply\n \t the distributive law followed by the inverse distributive law.\n@@ -6042,6 +6039,112 @@ force_to_mode (x, mode, mask, reg, just_select)\n   return gen_lowpart_for_combine (mode, x);\n }\n \f\n+/* Return nonzero if X is an expression that has one of two values depending on\n+   whether some other value is zero or nonzero.  In that case, we return the\n+   value that is being tested, *PTRUE is set to the value if the rtx being\n+   returned has a nonzero value, and *PFALSE is set to the other alternative.\n+\n+   If we return zero, we set *PTRUE and *PFALSE to X.  */\n+\n+static rtx\n+if_then_else_cond (x, ptrue, pfalse)\n+     rtx x;\n+     rtx *ptrue, *pfalse;\n+{\n+  enum machine_mode mode = GET_MODE (x);\n+  enum rtx_code code = GET_CODE (x);\n+  int size = GET_MODE_BITSIZE (mode);\n+  rtx cond0, cond1, true0, true1, false0, false1;\n+  unsigned HOST_WIDE_INT nz;\n+\n+  /* If this is a unary operation whose operand has one of two values, apply\n+     our opcode to compute those values.  */\n+  if (GET_RTX_CLASS (code) == '1'\n+      && (cond0 = if_then_else_cond (XEXP (x, 0), &true0, &false0)) != 0)\n+    {\n+      *ptrue = gen_unary (code, mode, true0);\n+      *pfalse = gen_unary (code, mode, false0);\n+      return cond0;\n+    }\n+\n+  /* If this is a binary operation, see if either side has only one of two\n+     values.  If either one does or if both do and they are conditional on\n+     the same value, compute the new true and false values.  */\n+  else if (GET_RTX_CLASS (code) == 'c' || GET_RTX_CLASS (code) == '2'\n+\t   || GET_RTX_CLASS (code) == '<')\n+    {\n+      cond0 = if_then_else_cond (XEXP (x, 0), &true0, &false0);\n+      cond1 = if_then_else_cond (XEXP (x, 1), &true1, &false1);\n+\n+      if ((cond0 != 0 || cond1 != 0)\n+\t  && ! (cond0 != 0 && cond1 != 0 && ! rtx_equal_p (cond0, cond1)))\n+\t{\n+\t  *ptrue = gen_binary (code, mode, true0, true1);\n+\t  *pfalse = gen_binary (code, mode, false0, false1);\n+\t  return cond0 ? cond0 : cond1;\n+\t}\n+    }\n+\n+  else if (code == IF_THEN_ELSE)\n+    {\n+      /* If we have IF_THEN_ELSE already, extract the condition and\n+\t canonicalize it if it is NE or EQ.  */\n+      cond0 = XEXP (x, 0);\n+      *ptrue = XEXP (x, 1), *pfalse = XEXP (x, 2);\n+      if (GET_CODE (cond0) == NE && XEXP (cond0, 1) == const0_rtx)\n+\treturn XEXP (cond0, 0);\n+      else if (GET_CODE (cond0) == EQ && XEXP (cond0, 1) == const0_rtx)\n+\t{\n+\t  *ptrue = XEXP (x, 2), *pfalse = XEXP (x, 1);\n+\t  return XEXP (cond0, 0);\n+\t}\n+      else\n+\treturn cond0;\n+    }\n+\n+  /* If X is a normal SUBREG with both inner and outer modes integral,\n+     we can narrow both the true and false values of the inner expression,\n+     if there is a condition.  */\n+  else if (code == SUBREG && GET_MODE_CLASS (mode) == MODE_INT\n+\t   && GET_MODE_CLASS (GET_MODE (SUBREG_REG (x))) == MODE_INT\n+\t   && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))\n+\t   && 0 != (cond0 = if_then_else_cond (SUBREG_REG (x),\n+\t\t\t\t\t       &true0, &false0)))\n+    {\n+      enum machine_mode inner_mode = GET_MODE (SUBREG_REG (x));\n+      unsigned HOST_WIDE_INT mask = GET_MODE_MASK (inner_mode);\n+\n+      *ptrue = force_to_mode (true0, inner_mode, mask, NULL_RTX, 0);\n+      *pfalse = force_to_mode (false0, inner_mode, mask, NULL_RTX, 0);\n+      return cond0;\n+    }\n+\n+  /* If X is a constant, this isn't special and will cause confusions\n+     if we treat it as such.  Likewise if it is equivalent to a constant.  */\n+  else if (CONSTANT_P (x)\n+\t   || ((cond0 = get_last_value (x)) != 0 && CONSTANT_P (cond0)))\n+    ;\n+\n+  /* If X is known to be either 0 or -1, those are the true and \n+     false values when testing X.  */\n+  else if (num_sign_bit_copies (x, mode) == size)\n+    {\n+      *ptrue = constm1_rtx, *pfalse = const0_rtx;\n+      return x;\n+    }\n+\n+  /* Likewise for 0 or a single bit.  */\n+  else if (exact_log2 (nz = nonzero_bits (x, mode)) >= 0)\n+    {\n+      *ptrue = GEN_INT (nz), *pfalse = const0_rtx;\n+      return x;\n+    }\n+\n+  /* Otherwise fail; show no condition with true and false values the same.  */\n+  *ptrue = *pfalse = x;\n+  return 0;\n+}\n+\f\n /* Return the value of expression X given the fact that condition COND\n    is known to be true when applied to REG as its first operand and VAL\n    as its second.  X is known to not be shared and so can be modified in\n@@ -10363,6 +10466,12 @@ distribute_links (links)\n \t    {\n \t      XEXP (link, 1) = LOG_LINKS (place);\n \t      LOG_LINKS (place) = link;\n+\n+\t      /* Set added_links_insn to the earliest insn we added a\n+\t\t link to.  */\n+\t      if (added_links_insn == 0 \n+\t\t  || INSN_CUID (added_links_insn) > INSN_CUID (place))\n+\t\tadded_links_insn = place;\n \t    }\n \t}\n     }"}]}