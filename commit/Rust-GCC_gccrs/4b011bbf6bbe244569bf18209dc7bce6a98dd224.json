{"sha": "4b011bbf6bbe244569bf18209dc7bce6a98dd224", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGIwMTFiYmY2YmJlMjQ0NTY5YmYxODIwOWRjN2JjZTZhOThkZDIyNA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2003-10-09T08:38:46Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2003-10-09T08:38:46Z"}, "message": "re PR middle-end/6392 (Problems with __restrict__ type qualifier (array))\n\n        PR c++/6392\n        * cp/tree.c (build_cplus_array_type): Handle all quals the same.\n        (cp_build_qualified_type_real): Look through arrays first.\n        * c-common.c (c_build_qualified_type): Look through arrays first.\n        (c_apply_type_quals_to_decl): Look through arrays.\n\n        * c-common.c (c_apply_type_quals_to_decl): Unset TREE_READONLY for\n        types with constructors.\n\nFrom-SVN: r72259", "tree": {"sha": "d0f777b45d19a136899a383c83866e289a331465", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0f777b45d19a136899a383c83866e289a331465"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4b011bbf6bbe244569bf18209dc7bce6a98dd224", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b011bbf6bbe244569bf18209dc7bce6a98dd224", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b011bbf6bbe244569bf18209dc7bce6a98dd224", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b011bbf6bbe244569bf18209dc7bce6a98dd224/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e913996db1ff90fd5ae6fc7940c1f8a6fe9d10ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e913996db1ff90fd5ae6fc7940c1f8a6fe9d10ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e913996db1ff90fd5ae6fc7940c1f8a6fe9d10ea"}], "stats": {"total": 157, "additions": 87, "deletions": 70}, "files": [{"sha": "cd3b6d9d8eab300f8f77a5a4b239a0e83269a945", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b011bbf6bbe244569bf18209dc7bce6a98dd224/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b011bbf6bbe244569bf18209dc7bce6a98dd224/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4b011bbf6bbe244569bf18209dc7bce6a98dd224", "patch": "@@ -1,5 +1,12 @@\n 2003-10-09  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/6392\n+\t* c-common.c (c_build_qualified_type): Look through arrays first.\n+\t(c_apply_type_quals_to_decl): Look through arrays.\n+\n+\t* c-common.c (c_apply_type_quals_to_decl): Unset TREE_READONLY for\n+\ttypes with constructors.\n+\n \t* coverage.c (build_ctr_info_value): Use build_decl to make a\n \tVAR_DECL.\n \t(create_coverage): Likewise."}, {"sha": "b58eda14966d320b67231d5d3a5d59f7c9921a89", "filename": "gcc/c-common.c", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b011bbf6bbe244569bf18209dc7bce6a98dd224/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b011bbf6bbe244569bf18209dc7bce6a98dd224/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=4b011bbf6bbe244569bf18209dc7bce6a98dd224", "patch": "@@ -2766,13 +2766,14 @@ static tree builtin_function_2 (const char *, const char *, tree, tree,\n tree\n c_build_qualified_type (tree type, int type_quals)\n {\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    return build_array_type (c_build_qualified_type (TREE_TYPE (type),\n+\t\t\t\t\t\t     type_quals),\n+\t\t\t     TYPE_DOMAIN (type));\n+\n   /* A restrict-qualified pointer type must be a pointer to object or\n      incomplete type.  Note that the use of POINTER_TYPE_P also allows\n-     REFERENCE_TYPEs, which is appropriate for C++.  Unfortunately,\n-     the C++ front-end also use POINTER_TYPE for pointer-to-member\n-     values, so even though it should be illegal to use `restrict'\n-     with such an entity we don't flag that here.  Thus, special case\n-     code for that case is required in the C++ front-end.  */\n+     REFERENCE_TYPEs, which is appropriate for C++.  */\n   if ((type_quals & TYPE_QUAL_RESTRICT)\n       && (!POINTER_TYPE_P (type)\n \t  || !C_TYPE_OBJECT_OR_INCOMPLETE_P (TREE_TYPE (type))))\n@@ -2781,10 +2782,6 @@ c_build_qualified_type (tree type, int type_quals)\n       type_quals &= ~TYPE_QUAL_RESTRICT;\n     }\n \n-  if (TREE_CODE (type) == ARRAY_TYPE)\n-    return build_array_type (c_build_qualified_type (TREE_TYPE (type),\n-\t\t\t\t\t\t     type_quals),\n-\t\t\t     TYPE_DOMAIN (type));\n   return build_qualified_type (type, type_quals);\n }\n \n@@ -2793,9 +2790,16 @@ c_build_qualified_type (tree type, int type_quals)\n void\n c_apply_type_quals_to_decl (int type_quals, tree decl)\n {\n-  if ((type_quals & TYPE_QUAL_CONST)\n-      || (TREE_TYPE (decl)\n-\t  && TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE))\n+  tree type = TREE_TYPE (decl);\n+\n+  if (((type_quals & TYPE_QUAL_CONST)\n+       || (type && TREE_CODE (type) == REFERENCE_TYPE))\n+      /* An object declared 'const' is only readonly after it is\n+\t initialized.  We don't have any way of expressing this currently,\n+\t so we need to be conservative and unset TREE_READONLY for types\n+\t with constructors.  Otherwise aliasing code will ignore stores in\n+\t an inline constructor.  */\n+      && !(type && TYPE_NEEDS_CONSTRUCTING (type)))\n     TREE_READONLY (decl) = 1;\n   if (type_quals & TYPE_QUAL_VOLATILE)\n     {\n@@ -2804,11 +2808,15 @@ c_apply_type_quals_to_decl (int type_quals, tree decl)\n     }\n   if (type_quals & TYPE_QUAL_RESTRICT)\n     {\n-      if (!TREE_TYPE (decl)\n-\t  || !POINTER_TYPE_P (TREE_TYPE (decl))\n-\t  || !C_TYPE_OBJECT_OR_INCOMPLETE_P (TREE_TYPE (TREE_TYPE (decl))))\n+      while (type && TREE_CODE (type) == ARRAY_TYPE)\n+\t/* Allow 'restrict' on arrays of pointers.\n+\t   FIXME currently we just ignore it.  */\n+\ttype = TREE_TYPE (type);\n+      if (!type\n+\t  || !POINTER_TYPE_P (type)\n+\t  || !C_TYPE_OBJECT_OR_INCOMPLETE_P (TREE_TYPE (type)))\n \terror (\"invalid use of `restrict'\");\n-      else if (flag_strict_aliasing)\n+      else if (flag_strict_aliasing && type == TREE_TYPE (decl))\n \t/* Indicate we need to make a unique alias set for this pointer.\n \t   We can't do it here because it might be pointing to an\n \t   incomplete type.  */"}, {"sha": "da318cfc9a215ec941182a75d221a010f873378f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b011bbf6bbe244569bf18209dc7bce6a98dd224/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b011bbf6bbe244569bf18209dc7bce6a98dd224/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4b011bbf6bbe244569bf18209dc7bce6a98dd224", "patch": "@@ -1,5 +1,9 @@\n 2003-10-09  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/6392\n+\t* tree.c (build_cplus_array_type): Handle all quals the same.\n+\t(cp_build_qualified_type_real): Look through arrays first.\n+\n \t* tree.c (build_cplus_new): Use build_decl to create a VAR_DECL.\n \t(build_target_expr_with_type): Likewise.\n "}, {"sha": "f99b3168da66404dcff4d33c753874756bc614cb", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 52, "deletions": 54, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4b011bbf6bbe244569bf18209dc7bce6a98dd224/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4b011bbf6bbe244569bf18209dc7bce6a98dd224/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=4b011bbf6bbe244569bf18209dc7bce6a98dd224", "patch": "@@ -367,16 +367,14 @@ build_cplus_array_type (tree elt_type, tree index_type)\n {\n   tree t;\n   int type_quals = cp_type_quals (elt_type);\n-  int cv_quals = type_quals & (TYPE_QUAL_CONST|TYPE_QUAL_VOLATILE);\n-  int other_quals = type_quals & ~(TYPE_QUAL_CONST|TYPE_QUAL_VOLATILE);\n \n-  if (cv_quals)\n-    elt_type = cp_build_qualified_type (elt_type, other_quals);\n+  if (type_quals != TYPE_UNQUALIFIED)\n+    elt_type = cp_build_qualified_type (elt_type, TYPE_UNQUALIFIED);\n \n   t = build_cplus_array_type_1 (elt_type, index_type);\n \n-  if (cv_quals)\n-    t = cp_build_qualified_type (t, cv_quals);\n+  if (type_quals != TYPE_UNQUALIFIED)\n+    t = cp_build_qualified_type (t, type_quals);\n \n   return t;\n }\n@@ -420,54 +418,6 @@ cp_build_qualified_type_real (tree type,\n   if (type_quals == cp_type_quals (type))\n     return type;\n \n-  /* A reference, fucntion or method type shall not be cv qualified.\n-     [dcl.ref], [dct.fct]  */\n-  if (type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE)\n-      && (TREE_CODE (type) == REFERENCE_TYPE\n-\t  || TREE_CODE (type) == FUNCTION_TYPE\n-\t  || TREE_CODE (type) == METHOD_TYPE))\n-    {\n-      bad_quals |= type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n-      if (TREE_CODE (type) != REFERENCE_TYPE)\n-\tbad_func_quals |= type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n-      type_quals &= ~(TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n-    }\n-  \n-  /* A restrict-qualified type must be a pointer (or reference)\n-     to object or incomplete type.  */\n-  if ((type_quals & TYPE_QUAL_RESTRICT)\n-      && TREE_CODE (type) != TEMPLATE_TYPE_PARM\n-      && TREE_CODE (type) != TYPENAME_TYPE\n-      && !POINTER_TYPE_P (type))\n-    {\n-      bad_quals |= TYPE_QUAL_RESTRICT;\n-      type_quals &= ~TYPE_QUAL_RESTRICT;\n-    }\n-\n-  if (bad_quals == TYPE_UNQUALIFIED)\n-    /*OK*/;\n-  else if (!(complain & (tf_error | tf_ignore_bad_quals)))\n-    return error_mark_node;\n-  else if (bad_func_quals && !(complain & tf_error))\n-    return error_mark_node;\n-  else\n-    {\n-      if (complain & tf_ignore_bad_quals)\n- \t/* We're not going to warn about constifying things that can't\n- \t   be constified.  */\n- \tbad_quals &= ~TYPE_QUAL_CONST;\n-      bad_quals |= bad_func_quals;\n-      if (bad_quals)\n- \t{\n- \t  tree bad_type = build_qualified_type (ptr_type_node, bad_quals);\n- \n- \t  if (!(complain & tf_ignore_bad_quals)\n-\t      || bad_func_quals)\n- \t    error (\"`%V' qualifiers cannot be applied to `%T'\",\n-\t\t   bad_type, type);\n- \t}\n-    }\n-  \n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       /* In C++, the qualification really applies to the array element\n@@ -522,6 +472,54 @@ cp_build_qualified_type_real (tree type,\n       return build_ptrmemfunc_type (t);\n     }\n   \n+  /* A reference, function or method type shall not be cv qualified.\n+     [dcl.ref], [dct.fct]  */\n+  if (type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE)\n+      && (TREE_CODE (type) == REFERENCE_TYPE\n+\t  || TREE_CODE (type) == FUNCTION_TYPE\n+\t  || TREE_CODE (type) == METHOD_TYPE))\n+    {\n+      bad_quals |= type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n+      if (TREE_CODE (type) != REFERENCE_TYPE)\n+\tbad_func_quals |= type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n+      type_quals &= ~(TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n+    }\n+  \n+  /* A restrict-qualified type must be a pointer (or reference)\n+     to object or incomplete type.  */\n+  if ((type_quals & TYPE_QUAL_RESTRICT)\n+      && TREE_CODE (type) != TEMPLATE_TYPE_PARM\n+      && TREE_CODE (type) != TYPENAME_TYPE\n+      && !POINTER_TYPE_P (type))\n+    {\n+      bad_quals |= TYPE_QUAL_RESTRICT;\n+      type_quals &= ~TYPE_QUAL_RESTRICT;\n+    }\n+\n+  if (bad_quals == TYPE_UNQUALIFIED)\n+    /*OK*/;\n+  else if (!(complain & (tf_error | tf_ignore_bad_quals)))\n+    return error_mark_node;\n+  else if (bad_func_quals && !(complain & tf_error))\n+    return error_mark_node;\n+  else\n+    {\n+      if (complain & tf_ignore_bad_quals)\n+ \t/* We're not going to warn about constifying things that can't\n+ \t   be constified.  */\n+ \tbad_quals &= ~TYPE_QUAL_CONST;\n+      bad_quals |= bad_func_quals;\n+      if (bad_quals)\n+ \t{\n+ \t  tree bad_type = build_qualified_type (ptr_type_node, bad_quals);\n+ \n+ \t  if (!(complain & tf_ignore_bad_quals)\n+\t      || bad_func_quals)\n+ \t    error (\"`%V' qualifiers cannot be applied to `%T'\",\n+\t\t   bad_type, type);\n+ \t}\n+    }\n+  \n   /* Retrieve (or create) the appropriately qualified variant.  */\n   result = build_qualified_type (type, type_quals);\n "}]}