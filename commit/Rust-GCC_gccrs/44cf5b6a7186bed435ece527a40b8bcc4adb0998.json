{"sha": "44cf5b6a7186bed435ece527a40b8bcc4adb0998", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRjZjViNmE3MTg2YmVkNDM1ZWNlNTI3YTQwYjhiY2M0YWRiMDk5OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-10-16T22:04:20Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-10-16T22:04:20Z"}, "message": "i386.c (split_ti): New function.\n\n\t* i386.c (split_ti): New function.\n\t(ix86_split_to_parts): Support TImodes.\n\t* i386.h (VALID_INT_MODE_P): Add TImode.\n\t* i386.md (movdi splitter): Fix.\n\t(movti): Support 64bit integer registers.\n\t(movti_rex64): New function and splitter.\n\n\t* i386.c (*_cost): Add movsx/movzx cost.\n\t* i386.h (struct processor_costs): Add movsx/movzx fields.\n\t(RTX_COSTS): Handle zero/sign extend + avoid believing that\n\t64bit operations require split on 64bit machine.\n\t(CONST_COST): Make large 64bit constants expensive on 64bit compilation.\n\n\t* i386.c (ix86_setup_incomming_varargs): Fix mode of PLUS.\n\t(ix86_expand_move): Avoid pushes of memory if size does not match;\n\tmove long constants to register.\n\t(x86_initialize_trampoline): Fix mode.\n\t* i386.h (ASM_OUTPUT_ADDR_VEC_ELT, ASM_OUTPUT_ADDR_DIFF_ELT):\n\tUse ASM_QUAD on 64bit.\n\t* i386.md (test pattern): Disallow impossible constants.\n\t(tablejump PIC expander): Fix emitting of sum.\n\t(movdicc_rex64): Rename to movdicc.\n\t* linux64.h (LINK_SPEC): Add missing '%'.\n\nFrom-SVN: r46296", "tree": {"sha": "a0319e5394119e2ee58b9dc6087f2cc800e7871b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0319e5394119e2ee58b9dc6087f2cc800e7871b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44cf5b6a7186bed435ece527a40b8bcc4adb0998", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44cf5b6a7186bed435ece527a40b8bcc4adb0998", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44cf5b6a7186bed435ece527a40b8bcc4adb0998", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44cf5b6a7186bed435ece527a40b8bcc4adb0998/comments", "author": null, "committer": null, "parents": [{"sha": "c0e5eb1602961b12e138911a6a61f0a84a3f42c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e5eb1602961b12e138911a6a61f0a84a3f42c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0e5eb1602961b12e138911a6a61f0a84a3f42c2"}], "stats": {"total": 197, "additions": 179, "deletions": 18}, "files": [{"sha": "de74d35399e33dfc5e43b6a6f6bed172874445b8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44cf5b6a7186bed435ece527a40b8bcc4adb0998/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44cf5b6a7186bed435ece527a40b8bcc4adb0998/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44cf5b6a7186bed435ece527a40b8bcc4adb0998", "patch": "@@ -1,3 +1,29 @@\n+Wed Oct 17 00:01:02 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (split_ti): New function.\n+\t(ix86_split_to_parts): Support TImodes.\n+\t* i386.h (VALID_INT_MODE_P): Add TImode.\n+\t* i386.md (movdi splitter): Fix.\n+\t(movti): Support 64bit integer registers.\n+\t(movti_rex64): New function and splitter.\n+\n+\t* i386.c (*_cost): Add movsx/movzx cost.\n+\t* i386.h (struct processor_costs): Add movsx/movzx fields.\n+\t(RTX_COSTS): Handle zero/sign extend + avoid believing that\n+\t64bit operations require split on 64bit machine.\n+\t(CONST_COST): Make large 64bit constants expensive on 64bit compilation.\n+\n+\t* i386.c (ix86_setup_incomming_varargs): Fix mode of PLUS.\n+\t(ix86_expand_move): Avoid pushes of memory if size does not match;\n+\tmove long constants to register.\n+\t(x86_initialize_trampoline): Fix mode.\n+\t* i386.h (ASM_OUTPUT_ADDR_VEC_ELT, ASM_OUTPUT_ADDR_DIFF_ELT):\n+\tUse ASM_QUAD on 64bit.\n+\t* i386.md (test pattern): Disallow impossible constants.\n+\t(tablejump PIC expander): Fix emitting of sum.\n+\t(movdicc_rex64): Rename to movdicc.\n+\t* linux64.h (LINK_SPEC): Add missing '%'.\n+\n 2001-10-16  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* tree-inline.c (inlinable_function_p): Leave it up to the"}, {"sha": "00b28a94628a3827bfc63cd0d3220daa9a7d31d0", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 85, "deletions": 5, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44cf5b6a7186bed435ece527a40b8bcc4adb0998/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44cf5b6a7186bed435ece527a40b8bcc4adb0998/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=44cf5b6a7186bed435ece527a40b8bcc4adb0998", "patch": "@@ -57,6 +57,8 @@ struct processor_costs size_cost = {\t/* costs for tunning for size */\n   3,\t\t\t\t\t/* cost of starting a multiply */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   3,\t\t\t\t\t/* cost of a divide/mod */\n+  3,\t\t\t\t\t/* cost of movsx */\n+  3,\t\t\t\t\t/* cost of movzx */\n   0,\t\t\t\t\t/* \"large\" insn */\n   2,\t\t\t\t\t/* MOVE_RATIO */\n   2,\t\t\t\t\t/* cost for loading QImode using movzbl */\n@@ -90,6 +92,8 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n   6,\t\t\t\t\t/* cost of starting a multiply */\n   1,\t\t\t\t\t/* cost of multiply per each bit set */\n   23,\t\t\t\t\t/* cost of a divide/mod */\n+  3,\t\t\t\t\t/* cost of movsx */\n+  2,\t\t\t\t\t/* cost of movzx */\n   15,\t\t\t\t\t/* \"large\" insn */\n   3,\t\t\t\t\t/* MOVE_RATIO */\n   4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n@@ -123,6 +127,8 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n   12,\t\t\t\t\t/* cost of starting a multiply */\n   1,\t\t\t\t\t/* cost of multiply per each bit set */\n   40,\t\t\t\t\t/* cost of a divide/mod */\n+  3,\t\t\t\t\t/* cost of movsx */\n+  2,\t\t\t\t\t/* cost of movzx */\n   15,\t\t\t\t\t/* \"large\" insn */\n   3,\t\t\t\t\t/* MOVE_RATIO */\n   4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n@@ -156,6 +162,8 @@ struct processor_costs pentium_cost = {\n   11,\t\t\t\t\t/* cost of starting a multiply */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   25,\t\t\t\t\t/* cost of a divide/mod */\n+  3,\t\t\t\t\t/* cost of movsx */\n+  2,\t\t\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   6,\t\t\t\t\t/* MOVE_RATIO */\n   6,\t\t\t\t\t/* cost for loading QImode using movzbl */\n@@ -189,6 +197,8 @@ struct processor_costs pentiumpro_cost = {\n   4,\t\t\t\t\t/* cost of starting a multiply */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   17,\t\t\t\t\t/* cost of a divide/mod */\n+  1,\t\t\t\t\t/* cost of movsx */\n+  1,\t\t\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   6,\t\t\t\t\t/* MOVE_RATIO */\n   2,\t\t\t\t\t/* cost for loading QImode using movzbl */\n@@ -222,6 +232,8 @@ struct processor_costs k6_cost = {\n   3,\t\t\t\t\t/* cost of starting a multiply */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   18,\t\t\t\t\t/* cost of a divide/mod */\n+  2,\t\t\t\t\t/* cost of movsx */\n+  2,\t\t\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   4,\t\t\t\t\t/* MOVE_RATIO */\n   3,\t\t\t\t\t/* cost for loading QImode using movzbl */\n@@ -255,6 +267,8 @@ struct processor_costs athlon_cost = {\n   5,\t\t\t\t\t/* cost of starting a multiply */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   42,\t\t\t\t\t/* cost of a divide/mod */\n+  1,\t\t\t\t\t/* cost of movsx */\n+  1,\t\t\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n   4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n@@ -288,6 +302,8 @@ struct processor_costs pentium4_cost = {\n   30,\t\t\t\t\t/* cost of starting a multiply */\n   0,\t\t\t\t\t/* cost of multiply per each bit set */\n   112,\t\t\t\t\t/* cost of a divide/mod */\n+  1,\t\t\t\t\t/* cost of movsx */\n+  1,\t\t\t\t\t/* cost of movzx */\n   16,\t\t\t\t\t/* \"large\" insn */\n   6,\t\t\t\t\t/* MOVE_RATIO */\n   2,\t\t\t\t\t/* cost for loading QImode using movzbl */\n@@ -2212,7 +2228,7 @@ ix86_setup_incoming_varargs (cum, mode, type, pretend_size, no_rtl)\n       nsse_reg = gen_reg_rtx (Pmode);\n       emit_insn (gen_zero_extendqidi2 (nsse_reg, gen_rtx_REG (QImode, 0)));\n       emit_insn (gen_rtx_SET (VOIDmode, tmp_reg,\n-\t\t\t      gen_rtx_MULT (VOIDmode, nsse_reg,\n+\t\t\t      gen_rtx_MULT (Pmode, nsse_reg,\n \t\t\t\t\t    GEN_INT (4))));\n       if (next_cum.sse_regno)\n \temit_move_insn\n@@ -5938,6 +5954,57 @@ split_di (operands, num, lo_half, hi_half)\n \tabort ();\n     }\n }\n+/* Split one or more TImode RTL references into pairs of SImode\n+   references.  The RTL can be REG, offsettable MEM, integer constant, or\n+   CONST_DOUBLE.  \"operands\" is a pointer to an array of DImode RTL to\n+   split and \"num\" is its length.  lo_half and hi_half are output arrays\n+   that parallel \"operands\".  */\n+\n+void\n+split_ti (operands, num, lo_half, hi_half)\n+     rtx operands[];\n+     int num;\n+     rtx lo_half[], hi_half[];\n+{\n+  while (num--)\n+    {\n+      rtx op = operands[num];\n+      if (CONSTANT_P (op))\n+\t{\n+\t  if (GET_CODE (op) == CONST_INT)\n+\t    {\n+\t      lo_half[num] = GEN_INT (trunc_int_for_mode (INTVAL (op), SImode));\n+\t      hi_half[num] = (1 << (HOST_BITS_PER_WIDE_INT -1)) != 0 ? constm1_rtx : const0_rtx;\n+\t    }\n+\t  else if (GET_CODE (op) == CONST_DOUBLE && HOST_BITS_PER_WIDE_INT == 64)\n+\t    {\n+\t      lo_half[num] = GEN_INT (trunc_int_for_mode (CONST_DOUBLE_LOW (op), SImode));\n+\t      hi_half[num] = GEN_INT (trunc_int_for_mode (CONST_DOUBLE_HIGH (op), SImode));\n+\t    }\n+\t  else\n+\t    abort ();\n+\t}\n+      else if (! reload_completed)\n+\t{\n+\t  lo_half[num] = gen_lowpart (DImode, op);\n+\t  hi_half[num] = gen_highpart (DImode, op);\n+\t}\n+      else if (GET_CODE (op) == REG)\n+\t{\n+\t  if (TARGET_64BIT)\n+\t    abort();\n+\t  lo_half[num] = gen_rtx_REG (DImode, REGNO (op));\n+\t  hi_half[num] = gen_rtx_REG (DImode, REGNO (op) + 1);\n+\t}\n+      else if (offsettable_memref_p (op))\n+\t{\n+\t  lo_half[num] = adjust_address (op, DImode, 0);\n+\t  hi_half[num] = adjust_address (op, DImode, 8);\n+\t}\n+      else\n+\tabort ();\n+    }\n+}\n \f\n /* Output code to perform a 387 binary operation in INSN, one of PLUS,\n    MINUS, MULT or DIV.  OPERANDS are the insn operands, where operands[3]\n@@ -6621,7 +6688,7 @@ ix86_expand_move (mode, operands)\n   else\n     {\n       if (GET_CODE (operands[0]) == MEM\n-\t  && (GET_MODE (operands[0]) == QImode\n+\t  && (PUSH_ROUNDING (GET_MODE_SIZE (mode)) != GET_MODE_SIZE (mode)\n \t      || !push_operand (operands[0], mode))\n \t  && GET_CODE (operands[1]) == MEM)\n \toperands[1] = force_reg (mode, operands[1]);\n@@ -6630,6 +6697,15 @@ ix86_expand_move (mode, operands)\n \t  && ! general_no_elim_operand (operands[1], mode))\n \toperands[1] = copy_to_mode_reg (mode, operands[1]);\n \n+      /* Force large constants in 64bit compilation into register\n+\t to get them CSEed.  */\n+      if (TARGET_64BIT && mode == DImode\n+\t  && immediate_operand (operands[1], mode)\n+\t  && !x86_64_zero_extended_value (operands[1])\n+\t  && !register_operand (operands[0], mode)\n+\t  && optimize && !reload_completed && !reload_in_progress)\n+\toperands[1] = copy_to_mode_reg (mode, operands[1]);\n+\n       if (FLOAT_MODE_P (mode))\n \t{\n \t  /* If we are loading a floating point constant to a register,\n@@ -8490,6 +8566,8 @@ ix86_split_to_parts (operand, parts, mode)\n     }\n   else\n     {\n+      if (mode == TImode)\n+\tsplit_ti (&operand, 1, &parts[0], &parts[1]);\n       if (mode == XFmode || mode == TFmode)\n \t{\n \t  if (REG_P (operand))\n@@ -8515,8 +8593,10 @@ ix86_split_to_parts (operand, parts, mode)\n \t      /* Do not use shift by 32 to avoid warning on 32bit systems.  */\n \t      if (HOST_BITS_PER_WIDE_INT >= 64)\n \t        parts[0]\n-\t\t  = GEN_INT (trunc_int_for_mode (l[0] + ((l[1] << 31) << 1),\n-\t\t\t\t\t\t SImode));\n+\t\t  = GEN_INT (trunc_int_for_mode\n+\t\t      ((l[0] & (((HOST_WIDE_INT) 2 << 31) - 1))\n+\t\t       + ((((HOST_WIDE_INT)l[1]) << 31) << 1),\n+\t\t       DImode));\n \t      else\n \t        parts[0] = immed_double_const (l[0], l[1], DImode);\n \t      parts[1] = GEN_INT (trunc_int_for_mode (l[2], SImode));\n@@ -10701,7 +10781,7 @@ x86_initialize_trampoline (tramp, fnaddr, cxt)\n       emit_move_insn (gen_rtx_MEM (HImode, plus_constant (tramp, offset)),\n \t\t      GEN_INT (trunc_int_for_mode (0xff49, HImode)));\n       emit_move_insn (gen_rtx_MEM (QImode, plus_constant (tramp, offset+2)),\n-\t\t      GEN_INT (trunc_int_for_mode (0xe3, HImode)));\n+\t\t      GEN_INT (trunc_int_for_mode (0xe3, QImode)));\n       offset += 3;\n       if (offset > TRAMPOLINE_SIZE)\n \tabort();"}, {"sha": "75b72d813e57b48968b48537ec8981400b15d92c", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44cf5b6a7186bed435ece527a40b8bcc4adb0998/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44cf5b6a7186bed435ece527a40b8bcc4adb0998/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=44cf5b6a7186bed435ece527a40b8bcc4adb0998", "patch": "@@ -58,6 +58,8 @@ struct processor_costs {\n   const int mult_init;\t\t/* cost of starting a multiply */\n   const int mult_bit;\t\t/* cost of multiply per each bit set */\n   const int divide;\t\t/* cost of a divide/mod */\n+  int movsx;\t\t\t/* The cost of movsx operation.  */\n+  int movzx;\t\t\t/* The cost of movzx operation.  */\n   const int large_insn;\t\t/* insns larger than this cost more */\n   const int move_ratio;\t\t/* The threshold of number of scalar\n \t\t\t\t   memory-to-memory move insns.  */\n@@ -953,7 +955,8 @@ extern int ix86_arch;\n     ((mode) == QImode || (mode) == HImode || (mode) == SImode\t\\\n      || (mode) == DImode\t\t\t\t\t\\\n      || (mode) == CQImode || (mode) == CHImode || (mode) == CSImode \\\n-     || (mode) == CDImode)\n+     || (mode) == CDImode\t\t\t\t\t\\\n+     || (TARGET_64BIT && ((mode) == TImode || (mode) == CTImode)))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.  */\n \n@@ -2427,6 +2430,10 @@ while (0)\n   case CONST:\t\t\t\t\t\t\t\\\n   case LABEL_REF:\t\t\t\t\t\t\\\n   case SYMBOL_REF:\t\t\t\t\t\t\\\n+    if (TARGET_64BIT && !x86_64_sign_extended_value (RTX))\t\\\n+      return 3;\t\t\t\t\t\t\t\\\n+    if (TARGET_64BIT && !x86_64_zero_extended_value (RTX))\t\\\n+      return 2;\t\t\t\t\t\t\t\\\n     return flag_pic && SYMBOLIC_CONST (RTX) ? 1 : 0;\t\t\\\n \t\t\t\t\t\t\t\t\\\n   case CONST_DOUBLE:\t\t\t\t\t\t\\\n@@ -2456,9 +2463,24 @@ while (0)\n    assumptions are adequate for the target machine.  */\n \n #define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\t\t\\\n+  case ZERO_EXTEND:\t\t\t\t\t\t\t\\\n+    /* The zero extensions is often completely free on x86_64, so make\t\\\n+       it as cheap as possible.  */\t\t\t\t\t\\\n+    if (TARGET_64BIT && GET_MODE (X) == DImode\t\t\t\t\\\n+\t&& GET_MODE (XEXP (X, 0)) == SImode)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\ttotal = 1; goto egress_rtx_costs;\t\t\t\t\\\n+      } \t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      TOPLEVEL_COSTS_N_INSNS (TARGET_ZERO_EXTEND_WITH_AND ?\t\t\\\n+\t\t\t      ix86_cost->add : ix86_cost->movzx);\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n+  case SIGN_EXTEND:\t\t\t\t\t\t\t\\\n+    TOPLEVEL_COSTS_N_INSNS (ix86_cost->movsx);\t\t\t\t\\\n+    break;\t\t\t\t\t\t\t\t\\\n   case ASHIFT:\t\t\t\t\t\t\t\t\\\n     if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n-\t&& GET_MODE (XEXP (X, 0)) == SImode)\t\t\t\t\\\n+\t&& (GET_MODE (XEXP (X, 0)) != DImode || TARGET_64BIT))\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tHOST_WIDE_INT value = INTVAL (XEXP (X, 1));\t\t\t\\\n \tif (value == 1)\t\t\t\t\t\t\t\\\n@@ -2472,7 +2494,7 @@ while (0)\n   case ASHIFTRT:\t\t\t\t\t\t\t\\\n   case LSHIFTRT:\t\t\t\t\t\t\t\\\n   case ROTATERT:\t\t\t\t\t\t\t\\\n-    if (GET_MODE (XEXP (X, 0)) == DImode)\t\t\t\t\\\n+    if (!TARGET_64BIT && GET_MODE (XEXP (X, 0)) == DImode)\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n \tif (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n@@ -2562,7 +2584,7 @@ while (0)\n   case IOR:\t\t\t\t\t\t\t\t\\\n   case XOR:\t\t\t\t\t\t\t\t\\\n   case MINUS:\t\t\t\t\t\t\t\t\\\n-    if (GET_MODE (X) == DImode)\t\t\t\t\t\t\\\n+    if (!TARGET_64BIT && GET_MODE (X) == DImode)\t\t\t\\\n       return (COSTS_N_INSNS (ix86_cost->add) * 2\t\t\t\\\n \t      + (rtx_cost (XEXP (X, 0), OUTER_CODE)\t\t\t\\\n \t         << (GET_MODE (XEXP (X, 0)) != DImode))\t\t\t\\\n@@ -2572,7 +2594,7 @@ while (0)\n     /* fall through */\t\t\t\t\t\t\t\\\n   case NEG:\t\t\t\t\t\t\t\t\\\n   case NOT:\t\t\t\t\t\t\t\t\\\n-    if (GET_MODE (X) == DImode)\t\t\t\t\t\t\\\n+    if (!TARGET_64BIT && GET_MODE (X) == DImode)\t\t\t\\\n       TOPLEVEL_COSTS_N_INSNS (ix86_cost->add * 2);\t\t\t\\\n     TOPLEVEL_COSTS_N_INSNS (ix86_cost->add);\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n@@ -2961,7 +2983,7 @@ do { long l;\t\t\t\t\t\t\\\n      */\n \n #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  fprintf (FILE, \"%s%s%d\\n\", ASM_LONG, LPREFIX, VALUE)\n+  fprintf (FILE, \"%s%s%d\\n\", TARGET_64BIT ? ASM_QUAD : ASM_LONG, LPREFIX, VALUE)\n \n /* This is how to output an element of a case-vector that is relative.\n    We don't use these on the 386 yet, because the ATT assembler can't do"}, {"sha": "c02702ab34f9782f44b75d6e3d3942e8d112751d", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 39, "deletions": 6, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44cf5b6a7186bed435ece527a40b8bcc4adb0998/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44cf5b6a7186bed435ece527a40b8bcc4adb0998/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=44cf5b6a7186bed435ece527a40b8bcc4adb0998", "patch": "@@ -8106,6 +8106,12 @@\n \t\t (const_int 0)))]\n   \"TARGET_64BIT\n    && ix86_match_ccmode (insn, CCNOmode)\n+   /* The code bellow cannot deal with constants outside HOST_WIDE_INT.  */\n+   && INTVAL (operands[1]) + INTVAL (operands[2]) < HOST_BITS_PER_WIDE_INT\n+   /* Ensure that resulting mask is zero or sign extended operand.  */\n+   && (INTVAL (operands[1]) + INTVAL (operands[2]) <= 32\n+       || (INTVAL (operands[1]) + INTVAL (operands[2]) == 64\n+\t   && INTVAL (operands[1]) > 32))\n    && (GET_MODE (operands[0]) == SImode\n        || GET_MODE (operands[0]) == DImode\n        || GET_MODE (operands[0]) == HImode\n@@ -13114,7 +13120,8 @@\n     {\n       if (TARGET_64BIT)\n \toperands[0] = expand_simple_binop (Pmode, PLUS, operands[0],\n-\t\t\t\t\t   operands[1], NULL_RTX, 0,\n+\t\t\t\t\t   gen_rtx_LABEL_REF (Pmode, operands[1]),\n+\t\t\t\t\t   NULL_RTX, 0,\n \t\t\t\t\t   OPTAB_DIRECT);\n       else\n \t{\n@@ -15638,11 +15645,11 @@\n \f\n ;; Conditional move instructions.\n \n-(define_expand \"movdicc_rex64\"\n+(define_expand \"movdicc\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(if_then_else:DI (match_operand 1 \"comparison_operator\" \"\")\n-\t\t\t (match_operand:DI 2 \"x86_64_general_operand\" \"\")\n-\t\t\t (match_operand:DI 3 \"x86_64_general_operand\" \"\")))]\n+\t\t\t (match_operand:DI 2 \"general_operand\" \"\")\n+\t\t\t (match_operand:DI 3 \"general_operand\" \"\")))]\n   \"TARGET_64BIT\"\n   \"if (!ix86_expand_int_movcc (operands)) FAIL; DONE;\")\n \n@@ -17653,8 +17660,13 @@\n (define_expand \"movti\"\n   [(set (match_operand:TI 0 \"general_operand\" \"\")\n \t(match_operand:TI 1 \"general_operand\" \"\"))]\n-  \"TARGET_SSE\"\n+  \"TARGET_SSE || TARGET_64BIT\"\n {\n+  if (TARGET_64BIT)\n+    {\n+      ix86_expand_move (TImode, operands);\n+      DONE;\n+    }\n   /* For constants other than zero into memory.  We do not know how the\n      instructions used to build constants modify the upper 64 bits\n      of the register, once we have that information we may be able\n@@ -17950,12 +17962,33 @@\n (define_insn \"movti_internal\"\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=x,m\")\n \t(match_operand:TI 1 \"general_operand\" \"xm,x\"))]\n-  \"TARGET_SSE\"\n+  \"TARGET_SSE && !TARGET_64BIT\"\n   \"@\n    movaps\\t{%1, %0|%0, %1}\n    movaps\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"sse\")])\n \n+(define_insn \"*movti_rex64\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,o,mx,x\")\n+\t(match_operand:DI 1 \"general_operand\" \"riFo,riF,x,m\"))]\n+  \"TARGET_64BIT\n+   && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\"\n+  \"@\n+   #\n+   #\n+   movaps\\\\t{%1, %0|%0, %1}\n+   movaps\\\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"*,*,sse,sse\")\n+   (set_attr \"mode\" \"TI\")])\n+\n+(define_split\n+  [(set (match_operand:TI 0 \"nonimmediate_operand\" \"\")\n+        (match_operand:TI 1 \"general_operand\" \"\"))]\n+  \"reload_completed && GENERAL_REG_P (operands[0])\n+   && GENERAL_REG_P (operands[1])\"\n+  [(const_int 0)]\n+  \"ix86_split_long_move (operands); DONE;\")\n+\n ;; These two patterns are useful for specifying exactly whether to use\n ;; movaps or movups\n (define_insn \"sse_movaps\""}, {"sha": "22e461ffbebe105bd1fbd30f14484597c2e8c618", "filename": "gcc/config/i386/linux64.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44cf5b6a7186bed435ece527a40b8bcc4adb0998/gcc%2Fconfig%2Fi386%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44cf5b6a7186bed435ece527a40b8bcc4adb0998/gcc%2Fconfig%2Fi386%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux64.h?ref=44cf5b6a7186bed435ece527a40b8bcc4adb0998", "patch": "@@ -39,7 +39,7 @@ Boston, MA 02111-1307, USA.  */\n    done.  */\n \n #undef\tLINK_SPEC\n-#define LINK_SPEC \"%{!m32:-m elf_x86_64} %{m32:-m elf_i386} {shared:-shared} \\\n+#define LINK_SPEC \"%{!m32:-m elf_x86_64} %{m32:-m elf_i386} %{shared:-shared} \\\n   %{!shared: \\\n     %{!static: \\\n       %{rdynamic:-export-dynamic} \\"}]}