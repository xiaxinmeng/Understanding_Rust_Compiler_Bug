{"sha": "ba412f14ad13a1e71af1aebe1ee97c6591e1f12e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmE0MTJmMTRhZDEzYTFlNzFhZjFhZWJlMWVlOTdjNjU5MWUxZjEyZQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-03-01T00:57:09Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-03-01T00:57:09Z"}, "message": "cpplib.h (CPP_ASSERTION, [...]): New token types.\n\n\t* cpplib.h (CPP_ASSERTION, CPP_STRINGIZE, CPP_TOKPASTE): New\n\ttoken types.\n\t(struct cpp_reader): Add parsing_if_directive and\n\tparsing_define_directive flags.\n\t(struct cpp_options): Remove output_conditionals flag.\n\t(check_macro_name): Delete prototype.\n\n\t* cpphash.h (struct macrodef): Delete.\n\t(struct reflist): Separate from struct definition.\n\t(struct definition): Remove unused fields.  Add column number.\n\t(create_definition): Returns a DEFINITION *.  Takes a\n\tcpp_reader * and an int.\n\n\t* cpphash.c (SKIP_WHITE_SPACE): Delete.\n\t(PEEKC): Copy defn from cpplib.c.\n\t(rest_extension, REST_EXTENSION_LENGTH): Delete.\n\t(struct arg): New.\n\t(struct arglist): Simplify.\n\t(collect_expansion): Rewrite.  Get tokens by calling\n\tcpp_get_token.  Add more error checking.\n\t(collect_formal_parameters): New function, broken out of\n\tcreate_definition and reworked to use get_directive_token.\n\t(create_definition): All real work is now in collect_expansion\n\tand collect_formal_parameters.  do_define handles finding the\n\tmacro name.  Return a DEFINITION, not a MACRODEF.\n\t(macroexpand): Replace bcopy with memcpy throughout.  Replace\n\tcharacter-at-a-time copy loop with memcpy and pointer increments.\n\t(compare-defs): d1->argnames / d2->argnames might be null.\n\n\t* cpplib.c (copy_rest_of_line): Delete function.\n\t(skip_rest_of_line): Do all the work ourselves.\n\t(skip_string): New function.\n\t(parse_string): Use skip_string.\n\t(get_macro_name): New function.\n\t(check_macro_name): Delete.\n\t(copy_comment): Use CPP_RESERVE and CPP_PUTC_Q.\n\t(cpp_skip_hspace): Use CPP_BUMP_LINE.\n\t(handle_directive): ICE if we're called on a macro buffer.\n\t(do_define): Determine macro name and type (funlike/objlike)\n\there.  Expunge all uses of MACRODEF.\n\t(cpp_push_buffer): Set line_base to NULL.\n\t(do_undef, read_line_number): Don't worry about getting a POP token.\n\t(eval_if_expression): Set/reset parsing_if_directive around\n\tcpp_parse_expr. Don't clear only_seen_white.\n\t(skip_if_group): Remove output_conditionals logic.  Use\n\tskip_rest_of_line.\n\t(cpp_get_token): Return ASSERTION, STRINGIZE, and TOKPASTE\n\ttokens under appropriate conditions.\n\t(cpp_unassert): Call do_unassert not do_assert.  Oops.\n\n\t* cppexp.c (parse_defined): New function, break out of\n\tcpp_lex.\n\t(cpp_lex): We now get CPP_ASSERTION tokens and can check them\n\tourselves, with cpp_defined.\n\t* cppinit.c (cpp_handle_option, print_help): Delete -ifoutput.\n\n\t* gcc.dg/20000209-2.c: Turn off -pedantic-errors.\n\t* gcc.dg/strpaste-2.c: New.\n\nFrom-SVN: r32274", "tree": {"sha": "68077897eecebf1187d9c261fbded410af33eaf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68077897eecebf1187d9c261fbded410af33eaf4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e/comments", "author": null, "committer": null, "parents": [{"sha": "38769add25b9fb5b4d60e98c60ab2d6fb8bf0854", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38769add25b9fb5b4d60e98c60ab2d6fb8bf0854", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38769add25b9fb5b4d60e98c60ab2d6fb8bf0854"}], "stats": {"total": 1508, "additions": 774, "deletions": 734}, "files": [{"sha": "c2638d3235e0cdb80bde5d0d04896bdc8ad46349", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba412f14ad13a1e71af1aebe1ee97c6591e1f12e", "patch": "@@ -1,3 +1,64 @@\n+2000-02-29  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cpplib.h (CPP_ASSERTION, CPP_STRINGIZE, CPP_TOKPASTE): New\n+\ttoken types.\n+\t(struct cpp_reader): Add parsing_if_directive and\n+\tparsing_define_directive flags.\t\t      \n+\t(struct cpp_options): Remove output_conditionals flag.\n+\t(check_macro_name): Delete prototype.\n+\n+\t* cpphash.h (struct macrodef): Delete.\n+\t(struct reflist): Separate from struct definition.\n+\t(struct definition): Remove unused fields.  Add column number.\n+\t(create_definition): Returns a DEFINITION *.  Takes a\n+\tcpp_reader * and an int.\n+\n+\t* cpphash.c (SKIP_WHITE_SPACE): Delete.\n+\t(PEEKC): Copy defn from cpplib.c.\n+\t(rest_extension, REST_EXTENSION_LENGTH): Delete.\n+\t(struct arg): New.\n+\t(struct arglist): Simplify.\n+\t(collect_expansion): Rewrite.  Get tokens by calling\n+\tcpp_get_token.  Add more error checking.\n+\t(collect_formal_parameters): New function, broken out of\n+\tcreate_definition and reworked to use get_directive_token.\n+\t(create_definition): All real work is now in collect_expansion\n+\tand collect_formal_parameters.  do_define handles finding the\n+\tmacro name.  Return a DEFINITION, not a MACRODEF.\n+\t(macroexpand): Replace bcopy with memcpy throughout.  Replace\n+\tcharacter-at-a-time copy loop with memcpy and pointer increments.\n+\t(compare-defs): d1->argnames / d2->argnames might be null.\n+\n+\t* cpplib.c (copy_rest_of_line): Delete function.\n+\t(skip_rest_of_line): Do all the work ourselves.\n+\t(skip_string): New function.\n+\t(parse_string): Use skip_string.\n+\t(get_macro_name): New function.\n+\t(check_macro_name): Delete.\n+\t(copy_comment): Use CPP_RESERVE and CPP_PUTC_Q.\n+\t(cpp_skip_hspace): Use CPP_BUMP_LINE.\n+\t(handle_directive): ICE if we're called on a macro buffer.\n+\t(do_define): Determine macro name and type (funlike/objlike)\n+\there.  Expunge all uses of MACRODEF.\n+\t(cpp_push_buffer): Set line_base to NULL.\n+\t(do_undef, read_line_number): Don't worry about getting a POP token.\n+\t(eval_if_expression): Set/reset parsing_if_directive around\n+\tcpp_parse_expr. Don't clear only_seen_white.\n+\t(skip_if_group): Remove output_conditionals logic.  Use\n+\tskip_rest_of_line.\n+\t(cpp_get_token): Return ASSERTION, STRINGIZE, and TOKPASTE\n+\ttokens under appropriate conditions.\n+\t(cpp_unassert): Call do_unassert not do_assert.  Oops.\n+\n+\t* cppexp.c (parse_defined): New function, break out of\n+\tcpp_lex.\n+\t(cpp_lex): We now get CPP_ASSERTION tokens and can check them\n+\tourselves, with cpp_defined.\n+\t* cppinit.c (cpp_handle_option, print_help): Delete -ifoutput.\n+\n+\t* gcc.dg/20000209-2.c: Turn off -pedantic-errors.\n+\t* gcc.dg/strpaste-2.c: New.\n+\n 2000-02-29  Mark Mitchell  <mark@codesourcery.com>\n \n \t* fold-const.c (size_binop): Don't asert inputs are the same and"}, {"sha": "ec9fecf51349fdbabcd1915edd143f7245b0ceff", "filename": "gcc/cppexp.c", "status": "modified", "additions": 59, "deletions": 47, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=ba412f14ad13a1e71af1aebe1ee97c6591e1f12e", "patch": "@@ -81,6 +81,7 @@ static HOST_WIDEST_INT left_shift PARAMS ((cpp_reader *, HOST_WIDEST_INT, int, u\n static HOST_WIDEST_INT right_shift PARAMS ((cpp_reader *, HOST_WIDEST_INT, int, unsigned HOST_WIDEST_INT));\n static struct operation parse_number PARAMS ((cpp_reader *, U_CHAR *, U_CHAR *));\n static struct operation parse_charconst PARAMS ((cpp_reader *, U_CHAR *, U_CHAR *));\n+static struct operation parse_defined PARAMS ((cpp_reader *));\n static struct operation cpp_lex PARAMS ((cpp_reader *, int));\n extern HOST_WIDEST_INT cpp_parse_expr PARAMS ((cpp_reader *));\n static HOST_WIDEST_INT cpp_parse_escape PARAMS ((cpp_reader *, U_CHAR **, HOST_WIDEST_INT));\n@@ -349,6 +350,53 @@ parse_charconst (pfile, start, end)\n   return op;\n }\n \n+static struct operation\n+parse_defined (pfile)\n+     cpp_reader *pfile;\n+{\n+  int paren = 0, len;\n+  U_CHAR *tok;\n+  enum cpp_token token;\n+  struct operation op;\n+  long old_written = CPP_WRITTEN (pfile);\n+\n+  op.unsignedp = 0;\n+  op.op = INT;\n+\n+  pfile->no_macro_expand++;\n+  token = get_directive_token (pfile);\n+  if (token == CPP_LPAREN)\n+    {\n+      paren++;\n+      CPP_SET_WRITTEN (pfile, old_written);\n+      token = get_directive_token (pfile);\n+    }\n+\n+  if (token != CPP_NAME)\n+    goto oops;\n+\n+  tok = pfile->token_buffer + old_written;\n+  len = CPP_PWRITTEN (pfile) - tok;\n+  op.value = cpp_defined (pfile, tok, len);\n+\n+  if (paren)\n+    {\n+      if (get_directive_token (pfile) != CPP_RPAREN)\n+\tgoto oops;\n+    }\n+  CPP_SET_WRITTEN (pfile, old_written);\n+  pfile->no_macro_expand--;\n+  return op;\n+\n+ oops:\n+  CPP_SET_WRITTEN (pfile, old_written);\n+  pfile->no_macro_expand--;\n+  cpp_error (pfile, \"`defined' without an identifier\");\n+\n+  op.op = ERROR;\n+  return op;\n+}\n+\n \n struct token {\n   const char *operator;\n@@ -389,7 +437,7 @@ cpp_lex (pfile, skip_evaluation)\n   tok_end = CPP_PWRITTEN (pfile);\n   CPP_SET_WRITTEN (pfile, old_written);\n   switch (token)\n-  {\n+    {\n     case CPP_EOF: /* Should not happen ...  */\n     case CPP_VSPACE:\n       op.op = 0;\n@@ -407,51 +455,22 @@ cpp_lex (pfile, skip_evaluation)\n       return parse_charconst (pfile, tok_start, tok_end);\n \n     case CPP_NAME:\n+      if (!strcmp (tok_start, \"defined\"))\n+\treturn parse_defined (pfile);\n+\n       op.op = INT;\n       op.unsignedp = 0;\n       op.value = 0;\n-      if (strcmp (tok_start, \"defined\"))\n-\t{\n-\t  if (CPP_WARN_UNDEF (pfile) && !skip_evaluation)\n-\t    cpp_warning (pfile, \"`%.*s' is not defined\",\n-\t\t\t (int) (tok_end - tok_start), tok_start);\n-\t}\n-      else\n-\t{\n-\t  int paren = 0, len;\n-\t  U_CHAR *tok;\n-\n-\t  pfile->no_macro_expand++;\n-\t  token = get_directive_token (pfile);\n-\t  if (token == CPP_LPAREN)\n-\t    {\n-\t      paren++;\n-\t      CPP_SET_WRITTEN (pfile, old_written);\n-\t      token = get_directive_token (pfile);\n-\t    }\n \n-\t  if (token != CPP_NAME)\n-\t    goto oops;\n-\n-\t  tok = pfile->token_buffer + old_written;\n-\t  len = CPP_PWRITTEN (pfile) - tok;\n-\t  if (cpp_defined (pfile, tok, len))\n-\t    op.value = 1;\n-\n-\t  if (paren)\n-\t    {\n-\t      if (get_directive_token (pfile) != CPP_RPAREN)\n-\t\tgoto oops;\n-\t    }\n-\t  CPP_SET_WRITTEN (pfile, old_written);\n-\t  pfile->no_macro_expand--;\n-\t}\n+      if (CPP_WARN_UNDEF (pfile) && !skip_evaluation)\n+\tcpp_warning (pfile, \"`%.*s' is not defined\",\n+\t\t     (int) (tok_end - tok_start), tok_start);\n       return op;\n \n-    oops:\n-      CPP_SET_WRITTEN (pfile, old_written);\n-      pfile->no_macro_expand--;\n-      cpp_error (pfile, \"`defined' without an identifier\");\n+    case CPP_ASSERTION:\n+      op.op = INT;\n+      op.unsignedp = 0;\n+      op.value = cpp_defined (pfile, tok_start, tok_end - tok_start);\n       return op;\n \n     case CPP_OTHER:\n@@ -468,13 +487,6 @@ cpp_lex (pfile, skip_evaluation)\n \t  op.op = toktab->token; \n \t  return op;\n \t}\n-      else if (tok_start + 1 == tok_end && *tok_start == '#')\n-\t{\n-\t  CPP_FORWARD (CPP_BUFFER (pfile), -1);\n-\t  op.op = INT;\n-\t  op.value = cpp_read_check_assertion (pfile);\n-\t  return op;\n-\t}\n       /* fall through */\n     default:\n       op.op = *tok_start;"}, {"sha": "c5c20ac9bf852d961c9a363c158562e3acf6916d", "filename": "gcc/cpphash.c", "status": "modified", "additions": 429, "deletions": 453, "changes": 882, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=ba412f14ad13a1e71af1aebe1ee97c6591e1f12e", "patch": "@@ -41,10 +41,9 @@ static enum cpp_token macarg\t PARAMS ((cpp_reader *, int));\n static struct tm *timestamp\t PARAMS ((cpp_reader *));\n static void special_symbol\t PARAMS ((HASHNODE *, cpp_reader *));\n \n-\n-#define SKIP_WHITE_SPACE(p) do { while (is_hspace(*p)) p++; } while (0)\n #define CPP_IS_MACRO_BUFFER(PBUF) ((PBUF)->data != NULL)\n #define FORWARD(N) CPP_FORWARD (CPP_BUFFER (pfile), (N))\n+#define PEEKC() CPP_BUF_PEEK (CPP_BUFFER (pfile))\n \n /* The arglist structure is built by create_definition to tell\n    collect_expansion where the argument names begin.  That\n@@ -57,17 +56,23 @@ static void special_symbol\t PARAMS ((HASHNODE *, cpp_reader *));\n    the current #define has been processed and entered into the\n    hash table.  */\n \n-struct arglist\n+struct arg\n {\n-  struct arglist *next;\n   U_CHAR *name;\n-  int length;\n-  int argno;\n-  char rest_args;\n+  int len;\n+  char rest_arg;\n+};\n+\n+struct arglist\n+{\n+  U_CHAR *namebuf;\n+  struct arg *argv;\n+  int argc;\n };\n \n-static DEFINITION *collect_expansion PARAMS ((cpp_reader *, U_CHAR *, U_CHAR *,\n-\t\t\t\t\t      int, struct arglist *));\n+\n+static DEFINITION *collect_expansion PARAMS ((cpp_reader *, struct arglist *));\n+static struct arglist *collect_formal_parameters PARAMS ((cpp_reader *));\n \n /* This structure represents one parsed argument in a macro call.\n    `raw' points to the argument text as written (`raw_length' is its length).\n@@ -251,502 +256,470 @@ macro_cleanup (pbuf, pfile)\n }\n \n \n-/* Read a replacement list for a macro with parameters.\n-   Build the DEFINITION structure.\n-   Reads characters of text starting at BUF until END.\n-   ARGLIST specifies the formal parameters to look for\n-   in the text of the definition; NARGS is the number of args\n-   in that list, or -1 for a macro name that wants no argument list.\n-   MACRONAME is the macro name itself (so we can avoid recursive expansion)\n-   and NAMELEN is its length in characters.\n-   \n-   Note that comments, backslash-newlines, and leading white space\n-   have already been deleted from the argument.  */\n+/* Read a replacement list for a macro, and build the DEFINITION\n+   structure.  ARGLIST specifies the formal parameters to look for in\n+   the text of the definition.  If ARGLIST is null, this is an\n+   object-like macro; if it points to an empty arglist, this is a\n+   function-like macro with no arguments.\n+\n+   A good half of this is devoted to supporting -traditional.\n+   Kill me now.  */\n \n static DEFINITION *\n-collect_expansion (pfile, buf, limit, nargs, arglist)\n+collect_expansion (pfile, arglist)\n      cpp_reader *pfile;\n-     U_CHAR *buf, *limit;\n-     int nargs;\n      struct arglist *arglist;\n {\n   DEFINITION *defn;\n-  register U_CHAR *p, *lastp, *exp_p;\n-  struct reflist *endpat = NULL;\n-  /* Pointer to first nonspace after last ## seen.  */\n-  U_CHAR *concat = 0;\n-  /* Pointer to first nonspace after last single-# seen.  */\n-  U_CHAR *stringify = 0;\n-  int maxsize;\n-  int expected_delimiter = '\\0';\n-\n-  /* Scan thru the replacement list, ignoring comments and quoted\n-     strings, picking up on the macro calls.  It does a linear search\n-     thru the arg list on every potential symbol.  Profiling might say\n-     that something smarter should happen.  */\n-\n-  if (limit < buf)\n+  struct reflist *pat = 0, *endpat = 0;\n+  enum cpp_token token;\n+  long start, here, last;\n+  int i;\n+  int argc;\n+  size_t len;\n+  struct arg *argv;\n+  U_CHAR *tok, *exp;\n+  enum { START = 0, NORM, ARG, STRIZE, PASTE } last_token = START;\n+\n+  if (arglist)\n     {\n-      cpp_ice (pfile, \"limit < buf in collect_expansion\");\n-      limit = buf; /* treat it like a null defn */\n+      argv = arglist->argv;\n+      argc = arglist->argc;\n     }\n-\n-  /* Find the beginning of the trailing whitespace.  */\n-  p = buf;\n-  while (p < limit && is_space(limit[-1]))\n-    limit--;\n-\n-  /* Allocate space for the text in the macro definition.\n-     Leading and trailing whitespace chars need 2 bytes each.\n-     Each other input char may or may not need 1 byte,\n-     so this is an upper bound.  The extra 5 are for invented\n-     leading and trailing escape-marker and final null.  */\n-  maxsize = (sizeof (DEFINITION)\n-\t     + (limit - p) + 5);\n-  defn = (DEFINITION *) xcalloc (1, maxsize);\n-\n-  defn->nargs = nargs;\n-  exp_p = defn->expansion = (U_CHAR *) defn + sizeof (DEFINITION);\n-  lastp = exp_p;\n-\n-  p = buf;\n-\n-  /* Add one initial space escape-marker to prevent accidental\n-     token-pasting (often removed by macroexpand).  */\n-  *exp_p++ = '\\r';\n-  *exp_p++ = ' ';\n-\n-  if (limit - p >= 2 && p[0] == '#' && p[1] == '#')\n+  else\n     {\n-      cpp_error (pfile, \"`##' at start of macro definition\");\n-      p += 2;\n+      argv = 0;\n+      argc = 0;\n     }\n \n-  /* Process the main body of the definition.  */\n-  while (p < limit)\n+  last = start = CPP_WRITTEN (pfile);\n+  last -= 2;  /* two extra chars for the leading escape */\n+  for (;;)\n     {\n-      int skipped_arg = 0;\n-      register U_CHAR c = *p++;\n+      /* We use cpp_get_token because get_directive_token would\n+\t discard whitespace and we can't cope with that yet.  Macro\n+\t expansion is off, so we are guaranteed not to see POP or EOF.  */\n \n-      *exp_p++ = c;\n-\n-      if (!CPP_TRADITIONAL (pfile))\n+      while (PEEKC () == '\\r')\n \t{\n-\t  switch (c)\n-\t    {\n-\t    case '\\'':\n-\t    case '\\\"':\n-\t      if (expected_delimiter != '\\0')\n-\t\t{\n-\t\t  if (c == expected_delimiter)\n-\t\t    expected_delimiter = '\\0';\n-\t\t}\n-\t      else\n-\t\texpected_delimiter = c;\n-\t      break;\n-\n-\t    case '\\\\':\n-\t      if (p < limit && expected_delimiter)\n-\t\t{\n-\t\t  /* In a string, backslash goes through\n-\t\t     and makes next char ordinary.  */\n-\t\t  *exp_p++ = *p++;\n-\t\t}\n-\t      break;\n-\n-\t    case '#':\n-\t      /* # is ordinary inside a string.  */\n-\t      if (expected_delimiter)\n-\t\tbreak;\n-\t      if (p < limit && *p == '#')\n-\t\t{\n-\t\t  /* ##: concatenate preceding and following tokens.  */\n-\t\t  /* Take out the first #, discard preceding whitespace.  */\n-\t\t  exp_p--;\n-\t\t  while (exp_p > lastp && is_hspace(exp_p[-1]))\n-\t\t    --exp_p;\n-\t\t  /* Skip the second #.  */\n-\t\t  p++;\n-\t\t  /* Discard following whitespace.  */\n-\t\t  SKIP_WHITE_SPACE (p);\n-\t\t  concat = p;\n-\t\t  if (p == limit)\n-\t\t    cpp_error (pfile, \"`##' at end of macro definition\");\n-\t\t}\n-\t      else if (nargs >= 0)\n-\t\t{\n-\t\t  /* Single #: stringify following argument ref.\n-\t\t     Don't leave the # in the expansion.  */\n-\t\t  exp_p--;\n-\t\t  SKIP_WHITE_SPACE (p);\n-\t\t  if (p == limit || !is_idstart(*p)\n-\t\t      || (*p == 'L' && p + 1 < limit && (p[1] == '\\'' ||\n-\t\t\t\t\t\t\t p[1] == '\"')))\n-\t\t    cpp_error (pfile,\n-\t\t\"`#' operator is not followed by a macro argument name\");\n-\t\t  else\n-\t\t    stringify = p;\n-\t\t}\n-\t      break;\n-\t    }\n+\t  FORWARD (1);\n+\t  CPP_BUMP_LINE (pfile);\n \t}\n-      else\n+      if (PEEKC () == '\\n')\n+\tgoto done;\n+      here = CPP_WRITTEN (pfile);\n+      token = cpp_get_token (pfile);\n+      tok = pfile->token_buffer + here;\n+      switch (token)\n \t{\n-\t  /* In -traditional mode, recognize arguments inside strings and\n-\t     character constants, and ignore special properties of #.\n-\t     Arguments inside strings are considered \"stringified\", but no\n-\t     extra quote marks are supplied.  */\n-\t  switch (c)\n-\t    {\n-\t    case '\\'':\n-\t    case '\\\"':\n-\t      if (expected_delimiter != '\\0')\n-\t\t{\n-\t\t  if (c == expected_delimiter)\n-\t\t    expected_delimiter = '\\0';\n-\t\t}\n-\t      else\n-\t\texpected_delimiter = c;\n-\t      break;\n+\tcase CPP_POP:\n+\tcase CPP_EOF:\n+\tcase CPP_VSPACE:\n+\t  cpp_ice (pfile, \"EOF or VSPACE in collect_expansion\");\n+\t  goto done;\n+\n+\tcase CPP_HSPACE:\n+\t  if (last_token == STRIZE || last_token == PASTE\n+\t      || last_token == START)\n+\t    CPP_SET_WRITTEN (pfile, here);\n+\t  break;\n \n-\t    case '\\\\':\n-\t      /* Backslash quotes delimiters and itself,\n-\t\t but not macro args.  */\n-\t      if (expected_delimiter != 0 && p < limit\n-\t\t  && (*p == expected_delimiter || *p == '\\\\'))\n-\t\t{\n-\t\t  *exp_p++ = *p++;\n-\t\t  continue;\n-\t\t}\n-\t      break;\n+\tcase CPP_STRINGIZE:\n+\t  if (last_token == PASTE)\n+\t    /* Not really a stringifier.  */\n+\t    goto norm;\n+\t  last_token = STRIZE;\n+\t  CPP_SET_WRITTEN (pfile, here);  /* delete from replacement text */\n+\t  break;\n \n-\t    case '/':\n-\t      if (expected_delimiter != '\\0')\n-\t\t/* No comments inside strings.  */\n-\t\tbreak;\n-\t      if (*p == '*')\n-\t\t{\n-\t\t  /* If we find a comment that wasn't removed by\n-\t\t     handle_directive, this must be -traditional.\n-\t\t     So replace the comment with nothing at all.  */\n-\t\t  exp_p--;\n-\t\t  p += 1;\n-\t\t  while (p < limit && !(p[-2] == '*' && p[-1] == '/'))\n-\t\t    p++;\n-\t\t}\n+\tcase CPP_TOKPASTE:\n+\t  /* If the last token was an argument, discard this token and\n+\t     any hspace between it and the argument's position.  Then\n+\t     mark the arg raw_after.  */\n+\t  if (last_token == ARG)\n+\t    {\n+\t      endpat->raw_after = 1;\n+\t      last_token = PASTE;\n+\t      CPP_SET_WRITTEN (pfile, last);\n \t      break;\n \t    }\n-\t}\n+\t  else if (last_token == PASTE)\n+\t    /* ## ## - the second ## is ordinary.  */\n+\t    goto norm;\n+\t  \n+\t  /* Discard the token and any hspace before it.  */\n+\t  while (is_hspace (pfile->token_buffer[here-1]))\n+\t    here--;\n+\t  CPP_SET_WRITTEN (pfile, here);\n+\n+\t  if (last_token == STRIZE)\n+\t    /* Oops - that wasn't a stringify operator.  */\n+\t    CPP_PUTC (pfile, '#');\n+\t  last_token = PASTE;\n+\t  break;\n \n-      /* Handle the start of a symbol.  */\n-      if (is_idchar(c) && nargs > 0)\n-\t{\n-\t  U_CHAR *id_beg = p - 1;\n-\t  int id_len;\n+\tcase CPP_COMMENT:\n+\t  /* We must be in -traditional mode.  Pretend this was a\n+\t     token paste, but only if there was no leading or\n+\t     trailing space.  */\n+\t  CPP_SET_WRITTEN (pfile, here);\n+\t  if (is_hspace (pfile->token_buffer[here-1]))\n+\t    break;\n+\t  if (is_hspace (PEEKC ()))\n+\t    break;\n+\t  if (last_token == ARG)\n+\t    endpat->raw_after = 1;\n+\t  last_token = PASTE;\n+\t  break;\n \n-\t  --exp_p;\n-\t  while (p != limit && is_idchar(*p))\n-\t    p++;\n-\t  id_len = p - id_beg;\n+\tcase CPP_STRING:\n+\tcase CPP_CHAR:\n+\t  if (last_token == STRIZE)\n+\t    cpp_error (pfile, \"`#' is not followed by a macro argument name\");\n \n-\t  if (is_idstart(c)\n-\t      && !(id_len == 1 && c == 'L' && (*p == '\\'' || *p == '\"')))\n-\t    {\n-\t      register struct arglist *arg;\n+\t  if (CPP_TRADITIONAL (pfile) || CPP_OPTIONS (pfile)->warn_stringify)\n+\t    goto maybe_trad_stringify;\n+\t  else\n+\t    goto norm;\n+\t  \n+\tcase CPP_NAME:\n+\t  for (i = 0; i < argc; i++)\n+\t    if (!strncmp (tok, argv[i].name, argv[i].len)\n+\t\t&& ! is_idchar (tok[argv[i].len]))\n+\t      goto addref;\n+\n+\t  /* fall through */\n+\tdefault:\n+\tnorm:\n+\t  if (last_token == STRIZE)\n+\t    cpp_error (pfile, \"`#' is not followed by a macro argument name\");\n+\t  last_token = NORM;\n+\t  break;\n+\t}\n+      continue;\n \n-\t      for (arg = arglist; arg != NULL; arg = arg->next)\n-\t\t{\n-\t\t  struct reflist *tpat;\n+    addref:\n+      {\n+\tstruct reflist *tpat;\n+\t\n+\t/* Make a pat node for this arg and add it to the pat list */\n+\ttpat = (struct reflist *) xmalloc (sizeof (struct reflist));\n+\ttpat->next = NULL;\n+\ttpat->raw_before = (last_token == PASTE);\n+\ttpat->raw_after = 0;\n+\ttpat->stringify = (last_token == STRIZE);\n+\ttpat->rest_args = argv[i].rest_arg;\n+\ttpat->argno = i;\n+\ttpat->nchars = here - last;\n+\n+\tif (endpat == NULL)\n+\t  pat = tpat;\n+\telse\n+\t  endpat->next = tpat;\n+\tendpat = tpat;\n+\tlast = here;\n+      }\n+      CPP_SET_WRITTEN (pfile, here);  /* discard arg name */\n+      last_token = ARG;\n+      continue;\n \n-\t\t  if (arg->name[0] == c\n-\t\t      && arg->length == id_len\n-\t\t      && strncmp (arg->name, id_beg, id_len) == 0)\n-\t\t    {\n-\t\t      if (expected_delimiter && CPP_OPTIONS\n-\t\t\t(pfile)->warn_stringify)\n-\t\t\t{\n-\t\t\t  if (CPP_TRADITIONAL (pfile))\n-\t\t\t    {\n-\t\t\t      cpp_warning (pfile,\n-\t\t\t\t       \"macro argument `%.*s' is stringified.\",\n-\t\t\t\t\t   id_len, arg->name);\n-\t\t\t    }\n-\t\t\t  else\n-\t\t\t    {\n-\t\t\t      cpp_warning (pfile,\n-\t\t    \"macro arg `%.*s' would be stringified with -traditional.\",\n-\t\t\t\t\t   id_len, arg->name);\n-\t\t\t    }\n-\t\t\t}\n-\t\t      /* If ANSI, don't actually substitute\n-\t\t\t inside a string.  */\n-\t\t      if (!CPP_TRADITIONAL (pfile) && expected_delimiter)\n-\t\t\tbreak;\n-\t\t      /* make a pat node for this arg and append it\n-\t\t\t to the end of the pat list */\n-\t\t      tpat = (struct reflist *)\n-\t\t\txmalloc (sizeof (struct reflist));\n-\t\t      tpat->next = NULL;\n-\t\t      tpat->raw_before = concat == id_beg;\n-\t\t      tpat->raw_after = 0;\n-\t\t      tpat->rest_args = arg->rest_args;\n-\t\t      tpat->stringify = (CPP_TRADITIONAL (pfile)\n-\t\t\t\t\t ? expected_delimiter != '\\0'\n-\t\t\t\t\t : stringify == id_beg);\n-\n-\t\t      if (endpat == NULL)\n-\t\t\tdefn->pattern = tpat;\n-\t\t      else\n-\t\t\tendpat->next = tpat;\n-\t\t      endpat = tpat;\n-\n-\t\t      tpat->argno = arg->argno;\n-\t\t      tpat->nchars = exp_p - lastp;\n-\t\t      {\n-\t\t\tregister U_CHAR *p1 = p;\n-\t\t\tSKIP_WHITE_SPACE (p1);\n-\t\t\tif (p1 + 2 <= limit && p1[0] == '#' && p1[1] == '#')\n-\t\t\t  tpat->raw_after = 1;\n-\t\t      }\n-\t\t      lastp = exp_p;\n-\t\t      skipped_arg = 1;\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t    }\n+    maybe_trad_stringify:\n+      {\n+\tU_CHAR *base, *p, *limit;\n+\tstruct reflist *tpat;\n \n-\t  /* If this was not a macro arg, copy it into the expansion.  */\n-\t  if (!skipped_arg)\n-\t    {\n-\t      register U_CHAR *lim1 = p;\n-\t      p = id_beg;\n-\t      while (p != lim1)\n-\t\t*exp_p++ = *p++;\n-\t      if (stringify == id_beg)\n-\t\tcpp_error (pfile,\n-\t\t\"`#' operator should be followed by a macro argument name\");\n-\t    }\n+\tbase = p = pfile->token_buffer + here;\n+\tlimit = CPP_PWRITTEN (pfile);\n+\n+\twhile (++p < limit)\n+\t  {\n+\t    if (is_idstart (*p))\n+\t      continue;\n+\t    for (i = 0; i < argc; i++)\n+\t      if (!strncmp (tok, argv[i].name, argv[i].len)\n+\t\t  && ! is_idchar (tok[argv[i].len]))\n+\t\tgoto mts_addref;\n+\t    continue;\n+\n+\t  mts_addref:\n+\t    if (!CPP_TRADITIONAL (pfile))\n+\t      {\n+\t\t/* Must have got here because of -Wtraditional.  */\n+\t\tcpp_warning (pfile,\n+\t     \"macro argument `%.*s' would be stringified with -traditional\",\n+\t\t\t     (int) argv[i].len, argv[i].name);\n+\t\tcontinue;\n+\t      }\n+\t    if (CPP_OPTIONS (pfile)->warn_stringify)\n+\t      cpp_warning (pfile, \"macro argument `%.*s' is stringified\",\n+\t\t\t     (int) argv[i].len, argv[i].name);\n+\n+\t    /* Remove the argument from the string.  */\n+\t    memmove (p, p + argv[i].len, limit - (p + argv[i].len));\n+\t    limit -= argv[i].len;\n+\t\n+\t    /* Make a pat node for this arg and add it to the pat list */\n+\t    tpat = (struct reflist *) xmalloc (sizeof (struct reflist));\n+\t    tpat->next = NULL;\n+\n+\t    /* Don't attempt to paste this with anything.  */\n+\t    tpat->raw_before = 0;\n+\t    tpat->raw_after = 0;\n+\t    tpat->stringify = 1;\n+\t    tpat->rest_args = argv[i].rest_arg;\n+\t    tpat->argno = i;\n+\t    tpat->nchars = (p - base) + here - last;\n+\n+\t    if (endpat == NULL)\n+\t      pat = tpat;\n+\t    else\n+\t      endpat->next = tpat;\n+\t    endpat = tpat;\n+\t    last = (p - base) + here;\n+\t  }\n+\tCPP_ADJUST_WRITTEN (pfile, CPP_PWRITTEN (pfile) - limit);\n+      }\n+    }\n+ done:\n+\n+  if (last_token == STRIZE)\n+    cpp_error (pfile, \"`#' is not followed by a macro argument name\");\n+  else if (last_token == PASTE)\n+    cpp_error (pfile, \"`##' at end of macro definition\");\n+\n+  CPP_NUL_TERMINATE (pfile);\n+  len = CPP_WRITTEN (pfile) - start + 1;\n+  exp = xmalloc (len + 4); /* space for no-concat markers at either end */\n+  exp[0] = '\\r';\n+  exp[1] = ' ';\n+  exp[len + 1] = '\\r';\n+  exp[len + 2] = ' ';\n+  exp[len + 3] = '\\0';\n+  memcpy (&exp[2], pfile->token_buffer + start, len - 1);\n+  CPP_SET_WRITTEN (pfile, start);\n+\n+  defn = (DEFINITION *) xmalloc (sizeof (DEFINITION));\n+  defn->length = len + 3;\n+  defn->expansion = exp;\n+  defn->pattern = pat;\n+  defn->rest_args = 0;\n+  if (arglist)\n+    {\n+      defn->nargs = argc;\n+      defn->argnames = arglist->namebuf;\n+      if (argv)\n+\t{\n+\t  defn->rest_args = argv[argc - 1].rest_arg;\n+\t  free (argv);\n \t}\n+      free (arglist);\n     }\n-\n-  if (!CPP_TRADITIONAL (pfile) && expected_delimiter == 0)\n+  else\n     {\n-      /* If ANSI, put in a \"\\r \" marker to prevent token pasting.\n-         But not if \"inside a string\" (which in ANSI mode\n-         happens only for -D option).  */\n-      *exp_p++ = '\\r';\n-      *exp_p++ = ' ';\n+      defn->nargs = -1;\n+      defn->argnames = 0;\n+      defn->rest_args = 0;\n     }\n-\n-  *exp_p = '\\0';\n-\n-  defn->length = exp_p - defn->expansion;\n-\n-  /* Crash now if we overrun the allocated size.  */\n-  if (defn->length + 1 > maxsize)\n-    abort ();\n-\n-#if 0\n-/* This isn't worth the time it takes.  */\n-  /* give back excess storage */\n-  defn->expansion = (U_CHAR *) xrealloc (defn->expansion, defn->length + 1);\n-#endif\n-\n   return defn;\n }\n \n-/*\n- * special extension string that can be added to the last macro argument to \n- * allow it to absorb the \"rest\" of the arguments when expanded.  Ex:\n- * \t\t#define wow(a, b...)\t\tprocess (b, a, b)\n- *\t\t{ wow (1, 2, 3); }\t->\t{ process (2, 3, 1, 2, 3); }\n- *\t\t{ wow (one, two); }\t->\t{ process (two, one, two); }\n- * if this \"rest_arg\" is used with the concat token '##' and if it is not\n- * supplied then the token attached to with ## will not be outputted.  Ex:\n- * \t\t#define wow (a, b...)\t\tprocess (b ## , a, ## b)\n- *\t\t{ wow (1, 2); }\t\t->\t{ process (2, 1, 2); }\n- *\t\t{ wow (one); }\t\t->\t{ process (one); {\n- */\n-static char rest_extension[] = \"...\";\n-#define REST_EXTENSION_LENGTH\t(sizeof (rest_extension) - 1)\n-\n-/* Create a DEFINITION node from a #define directive.  Arguments are \n-   as for do_define.  */\n-\n-MACRODEF\n-create_definition (buf, limit, pfile)\n-     U_CHAR *buf, *limit;\n+static struct arglist *\n+collect_formal_parameters (pfile)\n      cpp_reader *pfile;\n {\n-  U_CHAR *bp;\t\t\t/* temp ptr into input buffer */\n-  U_CHAR *symname;\t\t/* remember where symbol name starts */\n-  int sym_length;\t\t/* and how long it is */\n-  int rest_args = 0;\n-  long line, col;\n-  const char *file =\n-    CPP_BUFFER (pfile) ? CPP_BUFFER (pfile)->nominal_fname : \"\";\n-  DEFINITION *defn;\n-  int arglengths = 0;\t\t/* Accumulate lengths of arg names\n-\t\t\t\t   plus number of args.  */\n-  MACRODEF mdef;\n-  cpp_buf_line_and_col (CPP_BUFFER (pfile), &line, &col);\n-\n-  bp = buf;\n+  struct arglist *result = 0;\n+  struct arg *argv = 0;\n+  U_CHAR *namebuf = xstrdup (\"\");\n \n-  while (is_hspace(*bp))\n-    bp++;\n+  U_CHAR *name, *tok;\n+  size_t argslen = 1;\n+  int len;\n+  int argc = 0;\n+  int i;\n+  enum cpp_token token;\n+  long old_written;\n \n-  symname = bp;\t\t\t/* remember where it starts */\n+  old_written = CPP_WRITTEN (pfile);\n+  token = get_directive_token (pfile);\n+  if (token != CPP_LPAREN)\n+    {\n+      cpp_ice (pfile, \"first token = %d not %d in collect_formal_parameters\",\n+\t       token, CPP_LPAREN);\n+      goto invalid;\n+    }\n \n-  sym_length = check_macro_name (pfile, bp);\n-  bp += sym_length;\n+  argv = (struct arg *) xmalloc (sizeof (struct arg));\n+  argv[argc].len = 0;\n+  argv[argc].rest_arg = 0;\n+  for (;;)\n+    {\n+      CPP_SET_WRITTEN (pfile, old_written);\n+      token = get_directive_token (pfile);\n+      switch (token)\n+\t{\n+\tcase CPP_NAME:\n+\t  tok = pfile->token_buffer + old_written;\n+\t  len = CPP_PWRITTEN (pfile) - tok;\n+\t  if (namebuf\n+\t      && (name = strstr (namebuf, tok))\n+\t      && name[len] == ','\n+\t      && (name == namebuf || name[-1] == ','))\n+\t    {\n+\t      cpp_error (pfile, \"duplicate macro argument name `%s'\", tok);\n+\t      continue;\n+\t    }\n+\t  namebuf = xrealloc (namebuf, argslen + len + 1);\n+\t  name = &namebuf[argslen - 1];\n+\t  argslen += len + 1;\n+\n+\t  memcpy (name, tok, len);\n+\t  name[len] = ',';\n+\t  name[len+1] = '\\0';\n+\t  argv[argc].len = len;\n+\t  argv[argc].rest_arg = 0;\n+\t  break;\n \n-  /* Lossage will occur if identifiers or control keywords are broken\n-     across lines using backslash.  This is not the right place to take\n-     care of that.  */\n+\tcase CPP_COMMA:\n+\t  argc++;\n+\t  argv = xrealloc (argv, (argc + 1)*sizeof(struct arg));\n+\t  argv[argc].len = 0;\n+\t  break;\n \n-  if (*bp == '(')\n-    {\n-      struct arglist *arg_ptrs = NULL;\n-      int argno = 0;\n+\tcase CPP_RPAREN:\n+\t  goto done;\n \n-      bp++;\t\t\t/* skip '(' */\n-      SKIP_WHITE_SPACE (bp);\n+\tcase CPP_3DOTS:\n+\t  goto rest_arg;\n \n-      /* Loop over macro argument names.  */\n-      while (*bp != ')')\n-\t{\n-\t  struct arglist *temp;\n+\tcase CPP_VSPACE:\n+\t  cpp_error (pfile, \"missing right paren in macro argument list\");\n+\t  goto invalid;\n \n-\t  temp = (struct arglist *) alloca (sizeof (struct arglist));\n-\t  temp->name = bp;\n-\t  temp->next = arg_ptrs;\n-\t  temp->argno = argno++;\n-\t  temp->rest_args = 0;\n-\t  arg_ptrs = temp;\n+\tdefault:\n+\t  cpp_error (pfile, \"syntax error in #define\");\n+\t  goto invalid;\n+\t}\n+    }\n \n-\t  if (rest_args)\n-\t    cpp_pedwarn (pfile, \"another parameter follows `%s'\",\n-\t\t\t rest_extension);\n+ rest_arg:\n+  /* There are two possible styles for a vararg macro:\n+     the C99 way:  #define foo(a, ...) a, __VA_ARGS__\n+     the gnu way:  #define foo(a, b...) a, b\n+     The C99 way can be considered a special case of the gnu way.\n+     There are also some constraints to worry about, but we'll handle\n+     those elsewhere.  */\n+  if (argv[argc].len == 0)\n+    {\n+      if (CPP_PEDANTIC (pfile) && ! CPP_OPTIONS (pfile)->c99)\n+\tcpp_pedwarn (pfile, \"C89 does not permit varargs macros\");\n \n-\t  if (!is_idstart(*bp))\n-\t    cpp_pedwarn (pfile, \"invalid character in macro parameter name\");\n+      len = sizeof \"__VA_ARGS__\" - 1;\n+      namebuf = xrealloc (namebuf, argslen + len + 1);\n+      name = &namebuf[argslen - 1];\n+      argslen += len;\n+      memcpy (name, \"__VA_ARGS__\", len);\n \n-\t  /* Find the end of the arg name.  */\n-\t  while (is_idchar(*bp))\n-\t    {\n-\t      bp++;\n-\t      /* do we have a \"special\" rest-args extension here? */\n-\t      if ((size_t) (limit - bp) > REST_EXTENSION_LENGTH\n-\t\t  && !strncmp (rest_extension, bp, REST_EXTENSION_LENGTH))\n-\t\t{\n-\t\t  rest_args = 1;\n-\t\t  temp->rest_args = 1;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  temp->length = bp - temp->name;\n-\t  if (rest_args == 1)\n-\t    bp += REST_EXTENSION_LENGTH;\n-\t  arglengths += temp->length + 2;\n-\t  SKIP_WHITE_SPACE (bp);\n-\t  if (temp->length == 0 || (*bp != ',' && *bp != ')'))\n-\t    {\n-\t      cpp_error (pfile,\n-\t\t\t \"badly punctuated parameter list in `#define'\");\n-\t      goto nope;\n-\t    }\n-\t  if (*bp == ',')\n-\t    {\n-\t      bp++;\n-\t      SKIP_WHITE_SPACE (bp);\n-\t    }\n-\t  if (bp >= limit)\n-\t    {\n-\t      cpp_error (pfile, \"unterminated parameter list in `#define'\");\n-\t      goto nope;\n-\t    }\n-\t  {\n-\t    struct arglist *otemp;\n+      argslen += len + 1;\n+      argv[argc].len = len;\n+    }\n+  else\n+    if (CPP_PEDANTIC (pfile))\n+      cpp_pedwarn (pfile, \"ISO C does not permit named varargs macros\");\n+\n+  argv[argc].rest_arg = 1;\n+  namebuf = xrealloc (namebuf, argslen + 3);\n+  memcpy (&namebuf[argslen - 1], \"...\", 4);\n+  argslen += 3;\n+  \n+  token = get_directive_token (pfile);\n+  if (token != CPP_RPAREN)\n+    {\n+      cpp_error (pfile, \"another parameter follows `...'\");\n+      goto invalid;\n+    }\n \n-\t    for (otemp = temp->next; otemp != NULL; otemp = otemp->next)\n-\t      if (temp->length == otemp->length\n-\t\t  && strncmp (temp->name, otemp->name, temp->length) == 0)\n-\t\t{\n-\t\t  U_CHAR *name;\n-\n-\t\t  name = (U_CHAR *) alloca (temp->length + 1);\n-\t\t  (void) strncpy (name, temp->name, temp->length);\n-\t\t  name[temp->length] = '\\0';\n-\t\t  cpp_error (pfile,\n-\t\t\t     \"duplicate argument name `%s' in `#define'\",\n-\t\t\t     name);\n-\t\t  goto nope;\n-\t\t}\n-\t  }\n-\t}\n+ done:\n+  /* Go through argv and fix up the pointers.  */\n+  len = 0;\n+  for (i = 0; i <= argc; i++)\n+    {\n+      argv[i].name = namebuf + len;\n+      len += argv[i].len + 1;\n+    }\n \n-      ++bp;\t\t\t/* skip paren */\n-      SKIP_WHITE_SPACE (bp);\n-      /* now everything from bp before limit is the definition.  */\n-      defn = collect_expansion (pfile, bp, limit, argno, arg_ptrs);\n-      defn->rest_args = rest_args;\n+  CPP_SET_WRITTEN (pfile, old_written);\n \n-      /* Now set defn->argnames to the result of concatenating\n-         the argument names in reverse order\n-         with comma-space between them.  */\n-      defn->argnames = (U_CHAR *) xmalloc (arglengths + 1);\n-      {\n-\tstruct arglist *temp;\n-\tint i = 0;\n-\tfor (temp = arg_ptrs; temp; temp = temp->next)\n-\t  {\n-\t    bcopy (temp->name, &defn->argnames[i], temp->length);\n-\t    i += temp->length;\n-\t    if (temp->next != 0)\n-\t      {\n-\t\tdefn->argnames[i++] = ',';\n-\t\tdefn->argnames[i++] = ' ';\n-\t      }\n-\t  }\n-\tdefn->argnames[i] = 0;\n-      }\n+  result = (struct arglist *) xmalloc (sizeof (struct arglist));\n+  if (namebuf[0] != '\\0')\n+    {\n+      result->namebuf = namebuf;\n+      result->argc = argc + 1;\n+      result->argv = argv;\n     }\n   else\n     {\n-      /* Simple expansion or empty definition.  */\n+      free (namebuf);\n+      result->namebuf = 0;\n+      result->argc = 0;\n+      result->argv = 0;\n+    }\n \n-      if (bp < limit)\n-\t{\n-\t  if (is_hspace(*bp))\n-\t    {\n-\t      bp++;\n-\t      SKIP_WHITE_SPACE (bp);\n-\t    }\n-\t  else\n-\t    /* Per C9x, missing white space after the name in a #define\n-\t       of an object-like macro is always a constraint violation. */\n-\t    cpp_pedwarn (pfile,\n-\t\t\t \"missing white space after `#define %.*s'\",\n-\t\t\t sym_length, symname);\n-\t}\n-      /* now everything from bp before limit is the definition.  */\n-      defn = collect_expansion (pfile, bp, limit, -1, NULL_PTR);\n-      defn->argnames = (U_CHAR *) \"\";\n+  return result;\n+\n+ invalid:\n+  if (argv)\n+    free (argv);\n+  if (namebuf)\n+    free (namebuf);\n+  return 0;\n+}\n+\n+/* Create a DEFINITION node for a macro.  The reader's point is just\n+   after the macro name.  If FUNLIKE is true, this is a function-like\n+   macro.  */\n+\n+DEFINITION *\n+create_definition (pfile, funlike)\n+     cpp_reader *pfile;\n+     int funlike;\n+{\n+  struct arglist *args = 0;\n+  long line, col;\n+  const char *file;\n+  DEFINITION *defn;\n+\n+  cpp_buf_line_and_col (CPP_BUFFER (pfile), &line, &col);\n+  file = CPP_BUFFER (pfile)->nominal_fname;\n+\n+  pfile->no_macro_expand++;\n+  pfile->parsing_define_directive++;\n+  CPP_OPTIONS (pfile)->discard_comments++;\n+  \n+  if (funlike)\n+    {\n+      args = collect_formal_parameters (pfile);\n+      if (args == 0)\n+\tgoto err;\n     }\n \n+  defn = collect_expansion (pfile, args);\n+  if (defn == 0)\n+    goto err;\n+\n   defn->line = line;\n   defn->file = file;\n+  defn->col  = col;\n \n-  mdef.defn = defn;\n-  mdef.symnam = symname;\n-  mdef.symlen = sym_length;\n-\n-  return mdef;\n+  pfile->no_macro_expand--;\n+  pfile->parsing_define_directive--;\n+  CPP_OPTIONS (pfile)->discard_comments--;\n+  return defn;\n \n-nope:\n-  mdef.defn = 0;\n-  return mdef;\n+ err:\n+  pfile->no_macro_expand--;\n+  pfile->parsing_define_directive--;\n+  CPP_OPTIONS (pfile)->discard_comments--;\n+  return 0;\n }\n \n /*\n@@ -987,7 +960,7 @@ macroexpand (pfile, hp)\n       xbuf_len = CPP_WRITTEN (pfile) - old_written;\n       xbuf = (U_CHAR *) xmalloc (xbuf_len + 1);\n       CPP_SET_WRITTEN (pfile, old_written);\n-      bcopy (CPP_PWRITTEN (pfile), xbuf, xbuf_len + 1);\n+      memcpy (xbuf, CPP_PWRITTEN (pfile), xbuf_len + 1);\n       push_macro_expansion (pfile, xbuf, xbuf_len, hp);\n       CPP_BUFFER (pfile)->has_escapes = 1;\n       return;\n@@ -1244,8 +1217,10 @@ macroexpand (pfile, hp)\n \t  int count_before = totlen;\n \n \t  /* Add chars to XBUF.  */\n-\t  for (i = 0; i < ap->nchars; i++, offset++)\n-\t    xbuf[totlen++] = exp[offset];\n+\t  i = ap->nchars;\n+\t  memcpy (&xbuf[totlen], &exp[offset], i);\n+\t  totlen += i;\n+\t  offset += i;\n \n \t  /* If followed by an empty rest arg with concatenation,\n \t     delete the last run of nonwhite chars.  */\n@@ -1265,8 +1240,8 @@ macroexpand (pfile, hp)\n \n \t  if (ap->stringify != 0)\n \t    {\n-\t      bcopy (ARG_BASE + arg->stringified,\n-\t\t     xbuf + totlen, arg->stringified_length);\n+\t      memcpy (xbuf + totlen, ARG_BASE + arg->stringified,\n+\t\t      arg->stringified_length);\n \t      totlen += arg->stringified_length;\n \t    }\n \t  else if (ap->raw_before || ap->raw_after || CPP_TRADITIONAL (pfile))\n@@ -1314,7 +1289,7 @@ macroexpand (pfile, hp)\n \t      if (p1[0] == '\\r' && p1[1] == '-')\n \t\tp1 += 2;\n \n-\t      bcopy (p1, xbuf + totlen, l1 - p1);\n+\t      memcpy (xbuf + totlen, p1, l1 - p1);\n \t      totlen += l1 - p1;\n \t    }\n \t  else\n@@ -1328,7 +1303,7 @@ macroexpand (pfile, hp)\n \t\t  xbuf[totlen++] = ' ';\n \t\t}\n \n-\t      bcopy (expanded, xbuf + totlen, arg->expand_length);\n+\t      memcpy (xbuf + totlen, expanded, arg->expand_length);\n \t      totlen += arg->expand_length;\n \n \t      if (!ap->raw_after && totlen > 0 && offset < defn->length\n@@ -1493,6 +1468,7 @@ compare_defs (pfile, d1, d2)\n   if (d1->nargs != d2->nargs)\n     return 1;\n   if (CPP_PEDANTIC (pfile)\n+      && d1->argnames && d2->argnames\n       && strcmp ((char *) d1->argnames, (char *) d2->argnames))\n     return 1;\n   for (a1 = d1->pattern, a2 = d2->pattern; a1 && a2;"}, {"sha": "278ad24de64a07ddc9f62cafe3e53e93dd34c2a2", "filename": "gcc/cpphash.h", "status": "modified", "additions": 24, "deletions": 29, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=ba412f14ad13a1e71af1aebe1ee97c6591e1f12e", "patch": "@@ -18,15 +18,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #ifndef __GCC_CPPHASH__\n #define __GCC_CPPHASH__\n \n-/* Structure returned by create_definition */\n-typedef struct macrodef MACRODEF;\n-struct macrodef\n-{\n-  struct definition *defn;\n-  const U_CHAR *symnam;\n-  int symlen;\n-};\n-\n /* Structure allocated for every #define.  For a simple replacement\n    such as\n    \t#define foo bar ,\n@@ -48,30 +39,35 @@ struct macrodef\n      { (0, 1), (1, 1), (1, 1), ..., (1, 1), NULL }\n    where (x, y) means (nchars, argno). */\n \n+struct reflist\n+{\n+  struct reflist *next;\n+  char stringify;\t\t/* nonzero if this arg was preceded by a\n+\t\t\t\t   # operator. */\n+  char raw_before;\t\t/* Nonzero if a ## operator before arg. */\n+  char raw_after;\t\t/* Nonzero if a ## operator after arg. */\n+  char rest_args;\t\t/* Nonzero if this arg. absorbs the rest */\n+  int nchars;\t\t\t/* Number of literal chars to copy before\n+\t\t\t\t   this arg occurrence.  */\n+  int argno;\t\t\t/* Number of arg to substitute (origin-0) */\n+};\n+\n typedef struct definition DEFINITION;\n-struct definition {\n+struct definition\n+{\n   int nargs;\n   int length;\t\t\t/* length of expansion string */\n-  unsigned char *expansion;\n+  U_CHAR *expansion;\n   int line;\t\t\t/* Line number of definition */\n+  int col;\n   const char *file;\t\t/* File of definition */\n   char rest_args;\t\t/* Nonzero if last arg. absorbs the rest */\n-  struct reflist {\n-    struct reflist *next;\n-    char stringify;\t\t/* nonzero if this arg was preceded by a\n-\t\t\t\t   # operator. */\n-    char raw_before;\t\t/* Nonzero if a ## operator before arg. */\n-    char raw_after;\t\t/* Nonzero if a ## operator after arg. */\n-    char rest_args;\t\t/* Nonzero if this arg. absorbs the rest */\n-    int nchars;\t\t\t/* Number of literal chars to copy before\n-\t\t\t\t   this arg occurrence.  */\n-    int argno;\t\t\t/* Number of arg to substitute (origin-0) */\n-  } *pattern;\n-  /* Names of macro args, concatenated in reverse order\n-     with comma-space between them.\n-     The only use of this is that we warn on redefinition\n-     if this differs between the old and new definitions.  */\n-  unsigned char *argnames;\n+  struct reflist *pattern;\n+\n+  /* Names of macro args, concatenated in order with commas between\n+     them.  The only use of this is that we warn on redefinition if\n+     this differs between the old and new definitions.  */\n+  U_CHAR *argnames;\n };\n \n /* different kinds of things that can appear in the value field\n@@ -102,8 +98,7 @@ extern HASHNODE *cpp_lookup\t  PARAMS ((cpp_reader *, const U_CHAR *, int));\n extern void free_definition\t  PARAMS ((DEFINITION *));\n extern void delete_macro\t  PARAMS ((HASHNODE *));\n \n-extern MACRODEF create_definition PARAMS ((U_CHAR *, U_CHAR *,\n-\t\t\t\t\t   cpp_reader *));\n+extern DEFINITION *create_definition PARAMS ((cpp_reader *, int));\n extern int compare_defs\t\t  PARAMS ((cpp_reader *, DEFINITION *,\n \t\t\t\t\t   DEFINITION *));\n extern void macroexpand\t\t  PARAMS ((cpp_reader *, HASHNODE *));"}, {"sha": "d6fbad2247e1c2056972e8139c2bbb700059edef", "filename": "gcc/cppinit.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=ba412f14ad13a1e71af1aebe1ee97c6591e1f12e", "patch": "@@ -1256,9 +1256,6 @@ cpp_handle_option (pfile, argc, argv)\n \t\topts->include_prefix_len = strlen (argv[i]);\n \t      }\n \t  }\n-\telse if (!strcmp (argv[i], \"-ifoutput\"))\n-\t  opts->output_conditionals = 1;\n-\n \tbreak;\n       \n       case 'o':\n@@ -1736,7 +1733,6 @@ Switches:\\n\\\n   -dD                       Preserve macro definitions in output\\n\\\n   -dN                       As -dD except that only the names are preserved\\n\\\n   -dI                       Include #include directives in the output\\n\\\n-  -ifoutput                 Describe skipped code blocks in output \\n\\\n   -P                        Do not generate #line directives\\n\\\n   -$                        Do not allow '$' in identifiers\\n\\\n   -remap                    Remap file names when including files.\\n\\"}, {"sha": "8cdc241573ecf112485d111cd4855d24c3fb26a3", "filename": "gcc/cpplib.c", "status": "modified", "additions": 157, "deletions": 183, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=ba412f14ad13a1e71af1aebe1ee97c6591e1f12e", "patch": "@@ -46,7 +46,8 @@ extern HOST_WIDEST_INT cpp_parse_expr PARAMS ((cpp_reader *));\n \n /* `struct directive' defines one #-directive, including how to handle it.  */\n \n-struct directive {\n+struct directive\n+{\n   int length;\t\t\t/* Length of name */\n   int (*func)\t\t\t/* Function to handle directive */\n     PARAMS ((cpp_reader *, const struct directive *));\n@@ -93,7 +94,7 @@ static enum cpp_token null_underflow\tPARAMS ((cpp_reader *));\n static int null_cleanup\t\t\tPARAMS ((cpp_buffer *, cpp_reader *));\n static int skip_comment\t\t\tPARAMS ((cpp_reader *, int));\n static int copy_comment\t\t\tPARAMS ((cpp_reader *, int));\n-static void copy_rest_of_line\t\tPARAMS ((cpp_reader *));\n+static void skip_string\t\t\tPARAMS ((cpp_reader *, int));\n static void skip_rest_of_line\t\tPARAMS ((cpp_reader *));\n static void cpp_skip_hspace\t\tPARAMS ((cpp_reader *));\n static int handle_directive\t\tPARAMS ((cpp_reader *));\n@@ -108,6 +109,7 @@ static void skip_block_comment\t\tPARAMS ((cpp_reader *));\n static void skip_line_comment\t\tPARAMS ((cpp_reader *));\n static void parse_set_mark\t\tPARAMS ((cpp_reader *));\n static void parse_goto_mark\t\tPARAMS ((cpp_reader *));\n+static int get_macro_name\t\tPARAMS ((cpp_reader *));\n \n /* Here is the actual list of #-directives.\n    This table is ordered by frequency of occurrence; the numbers\n@@ -410,10 +412,13 @@ copy_comment (pfile, m)\n   if (skip_comment (pfile, m) == m)\n     return m;\n \n-  CPP_PUTC (pfile, m);\n-  for (limit = CPP_BUFFER (pfile)->cur; start <= limit; start++)\n+  limit = CPP_BUFFER (pfile)->cur;\n+  CPP_RESERVE (pfile, limit - start + 2);\n+  CPP_PUTC_Q (pfile, m);\n+  for (; start <= limit; start++)\n     if (*start != '\\r')\n-      CPP_PUTC (pfile, *start);\n+      CPP_PUTC_Q (pfile, *start);\n+\n   return ' ';\n }\n \n@@ -447,7 +452,7 @@ cpp_skip_hspace (pfile)\n \t\tbreak;\n \t    }\n \t  else\n-\t    CPP_BUFFER (pfile)->lineno++;\n+\t    CPP_BUMP_LINE (pfile);\n \t}\n       else if (c == '/' || c == '-')\n \t{\n@@ -461,11 +466,10 @@ cpp_skip_hspace (pfile)\n   FORWARD(-1);\n }\n \n-/* Read the rest of the current line.\n-   The line is appended to PFILE's output buffer.  */\n+/* Read and discard the rest of the current line.  */\n \n static void\n-copy_rest_of_line (pfile)\n+skip_rest_of_line (pfile)\n      cpp_reader *pfile;\n {\n   for (;;)\n@@ -476,32 +480,21 @@ copy_rest_of_line (pfile)\n \tcase '\\n':\n \t  FORWARD(-1);\n \tcase EOF:\n-\t  CPP_NUL_TERMINATE (pfile);\n \t  return;\n \n \tcase '\\r':\n-\t  if (CPP_BUFFER (pfile)->has_escapes)\n-\t    break;\n-\t  else\n-\t    {\n-\t      CPP_BUFFER (pfile)->lineno++;\n-\t      continue;\n-\t    }\n+\t  if (! CPP_BUFFER (pfile)->has_escapes)\n+\t    CPP_BUMP_LINE (pfile);\n+\t  break;\n+\t  \n \tcase '\\'':\n \tcase '\\\"':\n-\t  parse_string (pfile, c);\n-\t  continue;\n+\t  skip_string (pfile, c);\n+\t  break;\n+\n \tcase '/':\n-\t  if (PEEKC() == '*')\n-\t    {\n-\t      if (CPP_TRADITIONAL (pfile))\n-\t\tCPP_PUTS (pfile, \"/**/\", 4);\n-\t      skip_block_comment (pfile);\n-\t      continue;\n-\t    }\n-\t  /* else fall through */\n \tcase '-':\n-\t  c = skip_comment (pfile, c);\n+\t  skip_comment (pfile, c);\n \t  break;\n \n \tcase '\\f':\n@@ -512,23 +505,9 @@ copy_rest_of_line (pfile)\n \t  break;\n \n \t}\n-      CPP_PUTC (pfile, c);\n     }\n }\n \n-/* FIXME: It is almost definitely a performance win to make this do\n-   the scan itself.  >75% of calls to copy_r_o_l are from here or\n-   skip_if_group, which means the common case is to copy stuff into the\n-   token_buffer only to discard it.  */\n-static void\n-skip_rest_of_line (pfile)\n-     cpp_reader *pfile;\n-{\n-  long old = CPP_WRITTEN (pfile);\n-  copy_rest_of_line (pfile);\n-  CPP_SET_WRITTEN (pfile, old);\n-}\n-\n /* Handle a possible # directive.\n    '#' has already been read.  */\n \n@@ -542,6 +521,12 @@ handle_directive (pfile)\n   U_CHAR *ident;\n   long old_written = CPP_WRITTEN (pfile);\n \n+  if (CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n+    {\n+      cpp_ice (pfile, \"handle_directive called on macro buffer\");\n+      return 0;\n+    }\n+\n   cpp_skip_hspace (pfile);\n \n   c = PEEKC ();\n@@ -629,71 +614,88 @@ pass_thru_directive (buf, len, pfile, keyword)\n   CPP_PUTS_Q (pfile, buf, len);\n }\n \n-/* Check a purported macro name SYMNAME, and yield its length.  */\n+/* Subroutine of do_define: determine the name of the macro to be\n+   defined.  */\n \n-int\n-check_macro_name (pfile, symname)\n+static int\n+get_macro_name (pfile)\n      cpp_reader *pfile;\n-     const U_CHAR *symname;\n {\n-  const U_CHAR *p;\n-  int sym_length;\n-\n-  for (p = symname; is_idchar(*p); p++)\n-    ;\n-  sym_length = p - symname;\n-  if (sym_length == 0\n-      || (sym_length == 1 && *symname == 'L' && (*p == '\\'' || *p == '\"')))\n-    cpp_error (pfile, \"invalid macro name\");\n-  else if (!is_idstart(*symname)\n-\t   || (! strncmp (symname, \"defined\", 7) && sym_length == 7)) {\n-    U_CHAR *msg;\t\t\t/* what pain...  */\n-    msg = (U_CHAR *) alloca (sym_length + 1);\n-    bcopy (symname, msg, sym_length);\n-    msg[sym_length] = 0;\n-    cpp_error (pfile, \"invalid macro name `%s'\", msg);\n-  }\n-  return sym_length;\n+  long here, len;\n+\n+  here = CPP_WRITTEN (pfile);\n+  pfile->no_macro_expand++;\n+  if (get_directive_token (pfile) != CPP_NAME)\n+    {\n+      cpp_error (pfile, \"`#define' must be followed by an identifier\");\n+      goto invalid;\n+    }\n+\n+  len = CPP_WRITTEN (pfile) - here;\n+  if (len == 7 && !strncmp (pfile->token_buffer + here, \"defined\", 7))\n+    {\n+      cpp_error (pfile, \"`defined' is not a legal macro name\");\n+      goto invalid;\n+    }\n+\n+  pfile->no_macro_expand--;\n+  return len;\n+\n+ invalid:\n+  skip_rest_of_line (pfile);\n+  pfile->no_macro_expand--;\n+  return 0;\n }\n \n /* Process a #define command.\n    KEYWORD is the keyword-table entry for #define,\n-   or NULL for a \"predefined\" macro,\n-   or the keyword-table entry for #pragma in the case of a #pragma poison.  */\n+   or NULL for a \"predefined\" macro.  */\n \n static int\n do_define (pfile, keyword)\n      cpp_reader *pfile;\n      const struct directive *keyword;\n {\n-  MACRODEF mdef;\n   HASHNODE *hp;\n+  DEFINITION *def;\n   long here;\n-  U_CHAR *macro, *buf, *end;\n+  int len, c;\n+  int funlike = 0;\n+  U_CHAR *sym;\n \n   here = CPP_WRITTEN (pfile);\n-  copy_rest_of_line (pfile);\n-\n-  /* Copy out the line so we can pop the token buffer. */\n-  buf = pfile->token_buffer + here;\n-  end = CPP_PWRITTEN (pfile);\n-  macro = (U_CHAR *) alloca (end - buf + 1);\n-  memcpy (macro, buf, end - buf + 1);\n-  end = macro + (end - buf);\n+  len = get_macro_name (pfile);\n+  if (len == 0)\n+    return 0;\n \n+  /* Copy out the name so we can pop the token buffer.  */\n+  len = CPP_WRITTEN (pfile) - here;\n+  sym = (U_CHAR *) alloca (len + 1);\n+  memcpy (sym, pfile->token_buffer + here, len);\n+  sym[len] = '\\0';\n   CPP_SET_WRITTEN (pfile, here);\n \n-  mdef = create_definition (macro, end, pfile);\n-  if (mdef.defn == 0)\n+  /* If the next character, with no intervening whitespace, is '(',\n+     then this is a function-like macro.  */\n+  c = PEEKC ();\n+  if (c == '(')\n+    funlike = 1;\n+  else if (c != '\\n' && !is_hspace (c))\n+    /* Otherwise, C99 requires white space after the name.  We treat it\n+       as an object-like macro if this happens, with a warning.  */\n+    cpp_pedwarn (pfile, \"missing white space after `#define %.*s'\", len, sym);\n+\n+  def = create_definition (pfile, funlike);\n+  if (def == 0)\n     return 0;\n \n-  if ((hp = cpp_lookup (pfile, mdef.symnam, mdef.symlen)) != NULL)\n+  if ((hp = cpp_lookup (pfile, sym, len)) != NULL)\n     {\n       int ok;\n \n       /* Redefining a macro is ok if the definitions are the same.  */\n       if (hp->type == T_MACRO)\n-\tok = ! compare_defs (pfile, mdef.defn, hp->value.defn);\n+\tok = ! compare_defs (pfile, def, hp->value.defn);\n       /* Redefining a constant is ok with -D.  */\n       else if (hp->type == T_CONST || hp->type == T_STDC)\n         ok = ! CPP_OPTIONS (pfile)->done_initializing;\n@@ -704,34 +706,35 @@ do_define (pfile, keyword)\n       if (! ok)\n \t{\n \t  if (hp->type == T_POISON)\n-\t    cpp_error (pfile, \"redefining poisoned `%.*s'\", \n-\t\t       mdef.symlen, mdef.symnam);\n+\t    cpp_error (pfile, \"redefining poisoned `%.*s'\", len, sym);\n \t  else\n-\t    cpp_pedwarn (pfile, \"`%.*s' redefined\", mdef.symlen, mdef.symnam);\n+\t    cpp_pedwarn (pfile, \"`%.*s' redefined\", len, sym);\n \t  if (hp->type == T_MACRO && CPP_OPTIONS (pfile)->done_initializing)\n-\t    cpp_pedwarn_with_file_and_line (pfile, hp->value.defn->file,\n-\t\t\t\t\t    hp->value.defn->line, -1,\n+\t    {\n+\t      DEFINITION *d = hp->value.defn;\n+\t      cpp_pedwarn_with_file_and_line (pfile, d->file, d->line, d->col,\n \t\t\t\"this is the location of the previous definition\");\n+\t    }\n \t}\n       if (hp->type != T_POISON)\n \t{\n \t  /* Replace the old definition.  */\n \t  if (hp->type == T_MACRO)\n \t    free_definition (hp->value.defn);\n \t  hp->type = T_MACRO;\n-\t  hp->value.defn = mdef.defn;\n+\t  hp->value.defn = def;\n \t}\n     }\n   else\n-    cpp_install (pfile, mdef.symnam, mdef.symlen, T_MACRO, (char *)mdef.defn);\n+    cpp_install (pfile, sym, len, T_MACRO, (char *) def);\n \n   if (keyword != NULL && keyword->type == T_DEFINE)\n     {\n       if (CPP_OPTIONS (pfile)->debug_output\n \t  || CPP_OPTIONS (pfile)->dump_macros == dump_definitions)\n-\tdump_definition (pfile, mdef.symnam, mdef.symlen, mdef.defn);\n+\tdump_definition (pfile, sym, len, def);\n       else if (CPP_OPTIONS (pfile)->dump_macros == dump_names)\n-\tpass_thru_directive (mdef.symnam, mdef.symlen, pfile, keyword);\n+\tpass_thru_directive (sym, len, pfile, keyword);\n     }\n \n   return 0;\n@@ -766,6 +769,7 @@ cpp_push_buffer (pfile, buffer, length)\n   new->alimit = new->rlimit = buffer + length;\n   new->prev = buf;\n   new->mark = -1;\n+  new->line_base = NULL;\n \n   CPP_BUFFER (pfile) = new;\n   return new;\n@@ -1309,7 +1313,7 @@ read_line_number (pfile, num)\n     }\n   else\n     {\n-      if (token != CPP_VSPACE && token != CPP_EOF && token != CPP_POP)\n+      if (token != CPP_VSPACE && token != CPP_EOF)\n \tcpp_error (pfile, \"invalid format `#line' command\");\n       return 0;\n     }\n@@ -1467,15 +1471,14 @@ do_undef (pfile, keyword)\n   len = limit - buf;\n   name = (U_CHAR *) alloca (len + 1);\n   memcpy (name, buf, len);\n-  name[limit - buf] = '\\0';\n+  name[len] = '\\0';\n \n   token = get_directive_token (pfile);\n-  if (token != CPP_VSPACE && token != CPP_POP)\n+  if (token != CPP_VSPACE)\n   {\n       cpp_pedwarn (pfile, \"junk on line after #undef\");\n       skip_rest_of_line (pfile);\n   }\n-\n   CPP_SET_WRITTEN (pfile, here);\n \n   while ((hp = cpp_lookup (pfile, name, len)) != NULL)\n@@ -1950,11 +1953,9 @@ eval_if_expression (pfile)\n   HOST_WIDEST_INT value;\n   long old_written = CPP_WRITTEN (pfile);\n \n-  /* Work around bug in cpp_get_token where it may mistake an\n-     assertion for a directive.  */\n-  pfile->only_seen_white = 0;\n-\n+  pfile->parsing_if_directive++;\n   value = cpp_parse_expr (pfile);\n+  pfile->parsing_if_directive--;\n \n   skip_rest_of_line (pfile);\n   CPP_SET_WRITTEN (pfile, old_written); /* Pop */\n@@ -2148,13 +2149,6 @@ skip_if_group (pfile)\n   U_CHAR *beg_of_line;\n   long old_written;\n \n-  if (CPP_OPTIONS (pfile)->output_conditionals)\n-    {\n-      CPP_PUTS (pfile, \"#failed\\n\", 8);\n-      pfile->lineno++;\n-      output_line_command (pfile, same_file);\n-    }\n-\n   old_written = CPP_WRITTEN (pfile);\n   \n   for (;;)\n@@ -2166,8 +2160,6 @@ skip_if_group (pfile)\n       c = GETC();\n       if (c == '\\n')\n \t{\n-\t  if (CPP_OPTIONS (pfile)->output_conditionals)\n-\t    CPP_PUTC (pfile, c);\n \t  CPP_BUMP_LINE (pfile);\n \t  continue;\n \t}\n@@ -2180,41 +2172,19 @@ skip_if_group (pfile)\n \treturn;\t /* Caller will issue error. */\n \n       FORWARD(-1);\n-      if (CPP_OPTIONS (pfile)->output_conditionals)\n-\t{\n-\t  CPP_PUTS (pfile, beg_of_line, CPP_BUFFER (pfile)->cur - beg_of_line);\n-\t  copy_rest_of_line (pfile);\n-\t}\n-      else\n-\t{\n-\t  copy_rest_of_line (pfile);\n-\t  CPP_SET_WRITTEN (pfile, old_written);\t /* discard it */\n-\t}\n+      skip_rest_of_line (pfile);\n \n       c = GETC();\n       if (c == EOF)\n \treturn;\t /* Caller will issue error. */\n       else\n-\t{\n-\t  /* \\n */\n-\t  if (CPP_OPTIONS (pfile)->output_conditionals)\n-\t    {\n-\t      CPP_PUTC (pfile, c);\n-\t      pfile->lineno++;\n-\t    }\n-\t  CPP_BUMP_LINE (pfile);\n-\t}\n+\tCPP_BUMP_LINE (pfile);\n     }\t  \n \n   /* Back up to the beginning of this line.  Caller will process the\n      directive. */\n   CPP_BUFFER (pfile)->cur = beg_of_line;\n   pfile->only_seen_white = 1;\n-  if (CPP_OPTIONS (pfile)->output_conditionals)\n-    {\n-      CPP_PUTS (pfile, \"#endfailed\\n\", 11);\n-      pfile->lineno++;\n-    }\n }\n \n /*\n@@ -2443,6 +2413,27 @@ cpp_get_token (pfile)\n \t    }\n \n \tcase '#':\n+\t  if (pfile->parsing_if_directive)\n+\t    {\n+\t      cpp_skip_hspace (pfile);\n+\t      parse_assertion (pfile);\n+\t      return CPP_ASSERTION;\n+\t    }\n+\n+\t  if (pfile->parsing_define_directive && ! CPP_TRADITIONAL (pfile))\n+\t    {\n+\t      CPP_RESERVE (pfile, 3);\n+\t      CPP_PUTC_Q (pfile, '#');\n+\t      CPP_NUL_TERMINATE_Q (pfile);\n+\t      if (PEEKC () != '#')\n+\t\treturn CPP_STRINGIZE;\n+\t      \n+\t      FORWARD (1);\n+\t      CPP_PUTC_Q (pfile, '#');\n+\t      CPP_NUL_TERMINATE_Q (pfile);\n+\t      return CPP_TOKPASTE;\n+\t    }\n+\n \t  if (!pfile->only_seen_white)\n \t    goto randomchar;\n \t  /* -traditional directives are recognized only with the # in\n@@ -2886,35 +2877,24 @@ parse_name (pfile, c)\n   return;\n }\n \n-/* Parse a string starting with C.  A single quoted string is treated\n-   like a double -- some programs (e.g., troff) are perverse this way.\n-   (However, a single quoted string is not allowed to extend over\n-   multiple lines.)  */\n+/* Parse and skip over a string starting with C.  A single quoted\n+   string is treated like a double -- some programs (e.g., troff) are\n+   perverse this way.  (However, a single quoted string is not allowed\n+   to extend over multiple lines.)  */\n static void\n-parse_string (pfile, c)\n+skip_string (pfile, c)\n      cpp_reader *pfile;\n      int c;\n {\n   long start_line, start_column;\n-  \n   cpp_buf_line_and_col (cpp_file_buffer (pfile), &start_line, &start_column);\n \n-  CPP_PUTC (pfile, c);\n   while (1)\n     {\n       int cc = GETC();\n-      if (cc == EOF)\n+      switch (cc)\n \t{\n-\t  if (CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n-\t    {\n-\t      /* try harder: this string crosses a macro expansion\n-\t\t boundary.  This can happen naturally if -traditional.\n-\t\t Otherwise, only -D can make a macro with an unmatched\n-\t\t quote.  */\n-\t      cpp_pop_buffer (pfile);\n-\t      continue;\n-\t    }\n-\n+\tcase EOF:\n \t  cpp_error_with_line (pfile, start_line, start_column,\n \t\t\t       \"unterminated string or character constant\");\n \t  if (pfile->multiline_string_line != start_line\n@@ -2923,29 +2903,28 @@ parse_string (pfile, c)\n \t\t\t\t pfile->multiline_string_line, -1,\n \t\t\t \"possible real start of unterminated constant\");\n \t  pfile->multiline_string_line = 0;\n-\t  break;\n-\t}\n-      CPP_PUTC (pfile, cc);\n-      switch (cc)\n-\t{\n+\t  return;\n+\n \tcase '\\n':\n \t  CPP_BUMP_LINE (pfile);\n-\t  pfile->lineno++;\n-\n \t  /* In Fortran and assembly language, silently terminate\n \t     strings of either variety at end of line.  This is a\n \t     kludge around not knowing where comments are in these\n \t     languages.  */\n \t  if (CPP_OPTIONS (pfile)->lang_fortran\n \t      || CPP_OPTIONS (pfile)->lang_asm)\n-\t    return;\n+\t    {\n+\t      FORWARD(-1);\n+\t      return;\n+\t    }\n \t  /* Character constants may not extend over multiple lines.\n \t     In Standard C, neither may strings.  We accept multiline\n \t     strings as an extension.  */\n \t  if (c == '\\'')\n \t    {\n \t      cpp_error_with_line (pfile, start_line, start_column,\n \t\t\t\t   \"unterminated character constant\");\n+\t      FORWARD(-1);\n \t      return;\n \t    }\n \t  if (CPP_PEDANTIC (pfile) && pfile->multiline_string_line == 0)\n@@ -2956,7 +2935,6 @@ parse_string (pfile, c)\n \t  break;\n \n \tcase '\\r':\n-\t  CPP_ADJUST_WRITTEN (pfile, -1);\n \t  if (CPP_BUFFER (pfile)->has_escapes)\n \t    {\n \t      cpp_ice (pfile, \"\\\\r escape inside string constant\");\n@@ -2968,9 +2946,7 @@ parse_string (pfile, c)\n \t  break;\n \n \tcase '\\\\':\n-\t  cc = GETC();\n-\t  if (cc != EOF)\n-\t    CPP_PUTC (pfile, cc);\n+\t  FORWARD(1);\n \t  break;\n \n \tcase '\\\"':\n@@ -2982,6 +2958,26 @@ parse_string (pfile, c)\n     }\n }\n \n+/* Parse a string and copy it to the output.  */\n+\n+static void\n+parse_string (pfile, c)\n+     cpp_reader *pfile;\n+     int c;\n+{\n+  U_CHAR *start = CPP_BUFFER (pfile)->cur;  /* XXX Layering violation */\n+  U_CHAR *limit;\n+\n+  skip_string (pfile, c);\n+\n+  limit = CPP_BUFFER (pfile)->cur;\n+  CPP_RESERVE (pfile, limit - start + 2);\n+  CPP_PUTC_Q (pfile, c);\n+  for (; start < limit; start++)\n+    if (*start != '\\r')\n+      CPP_PUTC_Q (pfile, *start);\n+}\n+\n /* Read an assertion into the token buffer, converting to\n    canonical form: `#predicate(a n swe r)'  The next non-whitespace\n    character to read should be the first letter of the predicate.\n@@ -3199,33 +3195,11 @@ cpp_unassert (pfile, str)\n {\n   if (cpp_push_buffer (pfile, str, strlen (str)) != NULL)\n     {\n-      do_assert (pfile, NULL);\n+      do_unassert (pfile, NULL);\n       cpp_pop_buffer (pfile);\n     }\n }  \n \n-int\n-cpp_read_check_assertion (pfile)\n-     cpp_reader *pfile;\n-{\n-  U_CHAR *name;\n-  int result;\n-  long written = CPP_WRITTEN (pfile);\n-  \n-  FORWARD (1);  /* Skip '#' */\n-  cpp_skip_hspace (pfile);\n-  if (! parse_assertion (pfile))\n-    result = 0;\n-  else\n-    {\n-      name = pfile->token_buffer + written;\n-      result = cpp_defined (pfile, name, CPP_PWRITTEN (pfile) - name);\n-    }\n-\n-  CPP_SET_WRITTEN (pfile, written);\n-  return result;\n-}\n-\n /* Remember the current position of PFILE so it may be returned to\n    after looking ahead a bit.\n "}, {"sha": "6c16494ddfc250c49cb67bee8dba3ada737a0ec1", "filename": "gcc/cpplib.h", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=ba412f14ad13a1e71af1aebe1ee97c6591e1f12e", "patch": "@@ -47,14 +47,17 @@ enum cpp_token {\n   CPP_STRING,\n   CPP_WSTRING,\n   CPP_DIRECTIVE,\n-  CPP_LPAREN,   /* \"(\" */\n-  CPP_RPAREN,   /* \")\" */\n-  CPP_LBRACE,   /* \"{\" */\n-  CPP_RBRACE,   /* \"}\" */\n-  CPP_COMMA,    /* \",\" */\n-  CPP_SEMICOLON,/* \";\" */\n-  CPP_3DOTS,    /* \"...\" */\n-  CPP_POP\t/* We're about to pop the buffer stack.  */\n+  CPP_ASSERTION,\t/* #machine(a29k) */\n+  CPP_STRINGIZE,\t/* stringize macro argument */\n+  CPP_TOKPASTE,\t\t/* paste macro arg with next/prev token */\n+  CPP_LPAREN,\t\t/* \"(\" */\n+  CPP_RPAREN,\t\t/* \")\" */\n+  CPP_LBRACE,\t\t/* \"{\" */\n+  CPP_RBRACE,\t\t/* \"}\" */\n+  CPP_COMMA,\t\t/* \",\" */\n+  CPP_SEMICOLON,\t/* \";\" */\n+  CPP_3DOTS,\t\t/* \"...\" */\n+  CPP_POP\t\t/* We're about to pop the buffer stack.  */\n };\n \n typedef enum cpp_token (*parse_underflow_t) PARAMS((cpp_reader *));\n@@ -193,7 +196,6 @@ struct cpp_reader\n \n   /* If non-zero, directives cause a hard error.  Used when parsing\n      macro arguments.  */\n-\n   char no_directives;\n \n   /* Print column number in error messages. */\n@@ -205,6 +207,12 @@ struct cpp_reader\n   /* If true, character between '<' and '>' are a single (string) token. */\n   char parsing_include_directive;\n \n+  /* If true, # introduces an assertion (see do_assert) */\n+  char parsing_if_directive;\n+\n+  /* If true, # and ## are the STRINGIZE and TOKPASTE operators */\n+  char parsing_define_directive;\n+\n   /* True if escape sequences (as described for has_escapes in\n      parse_buffer) should be emitted. */\n   char output_escapes;\n@@ -217,7 +225,7 @@ struct cpp_reader\n   /* Nonzero means this file was included with a -imacros or -include\n      command line and should not be recorded as an include file.  */\n \n-  int no_record_file;\n+  char no_record_file;\n \n   long lineno;\n \n@@ -427,11 +435,6 @@ struct cpp_options {\n \n   char no_line_commands;\n \n-/* Nonzero means output the text in failing conditionals,\n-   inside #failed ... #endfailed.  */\n-\n-  char output_conditionals;\n-\n   /* Nonzero means -I- has been seen,\n      so don't look for #include \"foo\" the source-file directory.  */\n   char ignore_srcdir;\n@@ -689,14 +692,12 @@ extern int cpp_defined PARAMS ((cpp_reader *, const U_CHAR *, int));\n extern void cpp_reader_init PARAMS ((cpp_reader *));\n extern void cpp_options_init PARAMS ((cpp_options *));\n extern int cpp_start_read PARAMS ((cpp_reader *, char *));\n-extern int cpp_read_check_assertion PARAMS ((cpp_reader *));\n extern void cpp_finish PARAMS ((cpp_reader *));\n \n extern void quote_string\t\tPARAMS ((cpp_reader *, const char *));\n extern void cpp_expand_to_buffer\tPARAMS ((cpp_reader *, const U_CHAR *,\n \t\t\t\t\t\t int));\n extern void cpp_scan_buffer\t\tPARAMS ((cpp_reader *));\n-extern int check_macro_name\t\tPARAMS ((cpp_reader *, const U_CHAR *));\n \n /* Last arg to output_line_command.  */\n enum file_change_code {same_file, rename_file, enter_file, leave_file};"}, {"sha": "6a9198f6496e7c33b8acfa50fb7cff936aeb0d27", "filename": "gcc/testsuite/gcc.dg/20000209-2.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e/gcc%2Ftestsuite%2Fgcc.dg%2F20000209-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e/gcc%2Ftestsuite%2Fgcc.dg%2F20000209-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20000209-2.c?ref=ba412f14ad13a1e71af1aebe1ee97c6591e1f12e", "patch": "@@ -1,5 +1,7 @@\n /* { dg-do compile } */\n-/* Distilled from glibc sources.  Tests preprocessor corner cases.  */\n+/* { dg-options \"-Wall\" } */\n+/* Distilled from glibc sources.  Tests preprocessor corner cases.\n+   Since it uses rest args, we must turn off -pedantic-errors.  */\n \n #define NO_PAREN(rest...) rest\n #define DEFINE_CATEGORY(category, items) \\"}, {"sha": "d1fcd91824dcd49e3427be2f79ab9a161c4de37e", "filename": "gcc/testsuite/gcc.dg/strpaste-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e/gcc%2Ftestsuite%2Fgcc.dg%2Fstrpaste-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba412f14ad13a1e71af1aebe1ee97c6591e1f12e/gcc%2Ftestsuite%2Fgcc.dg%2Fstrpaste-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrpaste-2.c?ref=ba412f14ad13a1e71af1aebe1ee97c6591e1f12e", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do run } */\n+\n+/* Test for odd corner cases in stringizing/pasting.\n+   Taken more or less verbatim from C99 section 6.10.3.3.  */\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#define hash_hash # ## #\n+#define mkstr(a) # a\n+#define in_between(a) mkstr(a)\n+#define join(c, d) in_between(c hash_hash d)\n+\n+const char p[] = join(x, y);\n+const char q[] = \"x ## y\";\n+\n+int\n+main (void)\n+{\n+  if (strcmp (p, q))\n+    abort ();\n+  return 0;\n+}"}]}