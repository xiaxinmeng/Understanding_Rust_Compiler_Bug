{"sha": "c22cacf346343c87823813e73734aa7d728553c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzIyY2FjZjM0NjM0M2M4NzgyMzgxM2U3MzczNGFhN2Q3Mjg1NTNjNg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2006-05-18T22:16:23Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2006-05-18T22:16:23Z"}, "message": "Whitespace fixups\n\nFrom-SVN: r113893", "tree": {"sha": "3ae25fdc8c96c858e654f50a244ec03375560ecb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ae25fdc8c96c858e654f50a244ec03375560ecb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c22cacf346343c87823813e73734aa7d728553c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c22cacf346343c87823813e73734aa7d728553c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c22cacf346343c87823813e73734aa7d728553c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c22cacf346343c87823813e73734aa7d728553c6/comments", "author": null, "committer": null, "parents": [{"sha": "e836620206f1e96d7dac7c3b91c00e01b39e39f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e836620206f1e96d7dac7c3b91c00e01b39e39f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e836620206f1e96d7dac7c3b91c00e01b39e39f3"}], "stats": {"total": 2994, "additions": 1496, "deletions": 1498}, "files": [{"sha": "7c51ad79dd6066f9af3b7f43581ca41ccb742662", "filename": "gcc/alias.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -49,7 +49,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n /* The aliasing API provided here solves related but different problems:\n \n-   Say there exists (in c) \n+   Say there exists (in c)\n \n    struct X {\n      struct Y y1;\n@@ -87,7 +87,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    this may be too conservative for some C++ types.\n \n    The pass ipa-type-escape does this analysis for the types whose\n-   instances do not escape across the compilation boundary.  \n+   instances do not escape across the compilation boundary.\n \n    Historically in GCC, these two problems were combined and a single\n    data structure was used to represent the solution to these\n@@ -109,11 +109,11 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    `double'.  (However, a store to an `int' cannot alias a `double'\n    and vice versa.)  We indicate this via a tree structure that looks\n    like:\n-           struct S\n-            /   \\\n+\t   struct S\n+\t    /   \\\n \t   /     \\\n-         |/_     _\\|\n-         int    double\n+\t |/_     _\\|\n+\t int    double\n \n    (The arrows are directed and point downwards.)\n     In this situation we say the alias set for `struct S' is the\n@@ -730,7 +730,7 @@ record_component_aliases (tree type)\n \t{\n \t  int i;\n \t  tree binfo, base_binfo;\n-\t  \n+\n \t  for (binfo = TYPE_BINFO (type), i = 0;\n \t       BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n \t    record_alias_subset (superset,\n@@ -1023,7 +1023,7 @@ record_set (rtx dest, rtx set, void *data ATTRIBUTE_UNUSED)\n      If neither case holds, reject the original base value as invalid.\n      Note that the following situation is not detected:\n \n-         extern int x, y;  int *p = &x; p += (&y-&x);\n+\t extern int x, y;  int *p = &x; p += (&y-&x);\n \n      ANSI C does not allow computing the difference of addresses\n      of distinct top level objects.  */\n@@ -1091,7 +1091,7 @@ clear_reg_alias_info (rtx reg)\n \n /* If a value is known for REGNO, return it.  */\n \n-rtx \n+rtx\n get_reg_known_value (unsigned int regno)\n {\n   if (regno >= FIRST_PSEUDO_REGISTER)\n@@ -1620,7 +1620,7 @@ addr_side_effect_eval (rtx addr, int size, int n_refs)\n \n   if (offset)\n     addr = gen_rtx_PLUS (GET_MODE (addr), XEXP (addr, 0),\n-\t\t         GEN_INT (offset));\n+\t\t\t GEN_INT (offset));\n   else\n     addr = XEXP (addr, 0);\n   addr = canon_rtx (addr);\n@@ -2001,14 +2001,14 @@ nonoverlapping_memrefs_p (rtx x, rtx y)\n   /* Unless both have exprs, we can't tell anything.  */\n   if (exprx == 0 || expry == 0)\n     return 0;\n-  \n+\n   /* If both are field references, we may be able to determine something.  */\n   if (TREE_CODE (exprx) == COMPONENT_REF\n       && TREE_CODE (expry) == COMPONENT_REF\n       && nonoverlapping_component_refs_p (exprx, expry))\n     return 1;\n \n-  \n+\n   /* If the field reference test failed, look at the DECLs involved.  */\n   moffsetx = MEM_OFFSET (x);\n   if (TREE_CODE (exprx) == COMPONENT_REF)\n@@ -2020,7 +2020,7 @@ nonoverlapping_memrefs_p (rtx x, rtx y)\n \t tree fieldcontext = DECL_FIELD_CONTEXT (field);\n \t if (ipa_type_escape_field_does_not_clobber_p (fieldcontext,\n \t\t\t\t\t\t       TREE_TYPE (field)))\n-\t   return 1;\t \n+\t   return 1;\n \t}\n       {\n \ttree t = decl_for_component_ref (exprx);\n@@ -2048,7 +2048,7 @@ nonoverlapping_memrefs_p (rtx x, rtx y)\n \t tree fieldcontext = DECL_FIELD_CONTEXT (field);\n \t if (ipa_type_escape_field_does_not_clobber_p (fieldcontext,\n \t\t\t\t\t\t       TREE_TYPE (field)))\n-\t   return 1;\t \n+\t   return 1;\n \t}\n       {\n \ttree t = decl_for_component_ref (expry);\n@@ -2506,8 +2506,8 @@ init_alias_analysis (void)\n #endif\n \n \t      /* If this insn has a noalias note, process it,  Otherwise,\n-\t         scan for sets.  A simple set will have no side effects\n-\t         which could change the base value of any other register.  */\n+\t\t scan for sets.  A simple set will have no side effects\n+\t\t which could change the base value of any other register.  */\n \n \t      if (GET_CODE (PATTERN (insn)) == SET\n \t\t  && REG_NOTES (insn) != 0\n@@ -2564,7 +2564,7 @@ init_alias_analysis (void)\n \n       /* Now propagate values from new_reg_base_value to reg_base_value.  */\n       gcc_assert (maxreg == (unsigned int) max_reg_num());\n-      \n+\n       for (ui = 0; ui < maxreg; ui++)\n \t{\n \t  if (new_reg_base_value[ui]"}, {"sha": "17d4073cee5bc4f63fea1a0cdc0d3499448d903a", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -103,7 +103,7 @@ alloc_pool_descriptor (const char *name)\n \n   slot = (struct alloc_pool_descriptor **)\n     htab_find_slot_with_hash (alloc_pool_hash, name,\n-\t\t    \t      htab_hash_pointer (name),\n+\t\t\t      htab_hash_pointer (name),\n \t\t\t      1);\n   if (*slot)\n     return *slot;\n@@ -248,12 +248,12 @@ pool_alloc (alloc_pool pool)\n \t/* Mark the element to be free.  */\n \t((allocation_object *) block)->id = 0;\n #endif\n-        header = (alloc_pool_list) USER_PTR_FROM_ALLOCATION_OBJECT_PTR (block);\n-        header->next = pool->free_list;\n-        pool->free_list = header;\n+\theader = (alloc_pool_list) USER_PTR_FROM_ALLOCATION_OBJECT_PTR (block);\n+\theader->next = pool->free_list;\n+\tpool->free_list = header;\n       }\n       /* Also update the number of elements we have free/allocated, and\n-         increment the allocated block count.  */\n+\t increment the allocated block count.  */\n       pool->elts_allocated += pool->elts_per_block;\n       pool->elts_free += pool->elts_per_block;\n       pool->blocks_allocated += 1;"}, {"sha": "3ecc473d694537a76015b5e8099cd45bf0628ffd", "filename": "gcc/attribs.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fattribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fattribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fattribs.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -77,21 +77,21 @@ init_attributes (void)\n \t  /* The name must not begin and end with __.  */\n \t  const char *name = attribute_tables[i][j].name;\n \t  int len = strlen (name);\n-\t  \n+\n \t  gcc_assert (!(name[0] == '_' && name[1] == '_'\n \t\t\t&& name[len - 1] == '_' && name[len - 2] == '_'));\n-\t  \n+\n \t  /* The minimum and maximum lengths must be consistent.  */\n \t  gcc_assert (attribute_tables[i][j].min_length >= 0);\n-\t  \n+\n \t  gcc_assert (attribute_tables[i][j].max_length == -1\n \t\t      || (attribute_tables[i][j].max_length\n \t\t\t  >= attribute_tables[i][j].min_length));\n-\t  \n+\n \t  /* An attribute cannot require both a DECL and a TYPE.  */\n \t  gcc_assert (!attribute_tables[i][j].decl_required\n \t\t      || !attribute_tables[i][j].type_required);\n-\t  \n+\n \t  /* If an attribute requires a function type, in particular\n \t     it requires a type.  */\n \t  gcc_assert (!attribute_tables[i][j].function_type_required\n@@ -227,8 +227,8 @@ decl_attributes (tree *node, tree attributes, int flags)\n \t\t pull out the target type now, frob it as appropriate, and\n \t\t rebuild the pointer type later.\n \n-\t         This would all be simpler if attributes were part of the\n-\t         declarator, grumble grumble.  */\n+\t\t This would all be simpler if attributes were part of the\n+\t\t declarator, grumble grumble.  */\n \t      fn_ptr_tmp = TREE_TYPE (*anode);\n \t      anode = &fn_ptr_tmp;\n \t      flags &= ~(int) ATTR_FLAG_TYPE_IN_PLACE;"}, {"sha": "a252ccc0e8c57c673c07855101829451f7b3ad6a", "filename": "gcc/basic-block.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -516,7 +516,7 @@ extern void brief_dump_cfg (FILE *);\n extern void clear_edges (void);\n extern rtx first_insn_after_basic_block_note (basic_block);\n extern void scale_bbs_frequencies_int (basic_block *, int, int, int);\n-extern void scale_bbs_frequencies_gcov_type (basic_block *, int, gcov_type, \n+extern void scale_bbs_frequencies_gcov_type (basic_block *, int, gcov_type,\n \t\t\t\t\t     gcov_type);\n \n /* Structure to group all of the information to process IF-THEN and\n@@ -765,7 +765,7 @@ ei_cond (edge_iterator ei, edge *p)\n    an element might be removed during the traversal, otherwise\n    elements will be missed.  Instead, use a for-loop like that shown\n    in the following pseudo-code:\n-   \n+\n    FOR (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n      {\n \tIF (e != taken_edge)\n@@ -970,7 +970,7 @@ extern void calculate_dominance_info (enum cdi_direction);\n extern void free_dominance_info (enum cdi_direction);\n extern basic_block nearest_common_dominator (enum cdi_direction,\n \t\t\t\t\t     basic_block, basic_block);\n-extern basic_block nearest_common_dominator_for_set (enum cdi_direction, \n+extern basic_block nearest_common_dominator_for_set (enum cdi_direction,\n \t\t\t\t\t\t     bitmap);\n extern void set_immediate_dominator (enum cdi_direction, basic_block,\n \t\t\t\t     basic_block);"}, {"sha": "bf8c6afe05f247baf54f9c27b5a3378220c558fe", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 226, "deletions": 226, "changes": 452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -95,7 +95,7 @@\n #define N_ROUNDS 5\n \n /* Stubs in case we don't have a return insn.\n-   We have to check at runtime too, not only compiletime.  */  \n+   We have to check at runtime too, not only compiletime.  */\n \n #ifndef HAVE_return\n #define HAVE_return 0\n@@ -178,7 +178,7 @@ static void connect_traces (int, struct trace *);\n static bool copy_bb_p (basic_block, int);\n static int get_uncond_jump_length (void);\n static bool push_to_next_round_p (basic_block, int, int, int, gcov_type);\n-static void find_rarely_executed_basic_blocks_and_crossing_edges (edge *, \n+static void find_rarely_executed_basic_blocks_and_crossing_edges (edge *,\n \t\t\t\t\t\t\t\t  int *,\n \t\t\t\t\t\t\t\t  int *);\n static void add_labels_and_missing_jumps (edge *, int);\n@@ -205,14 +205,14 @@ push_to_next_round_p (basic_block bb, int round, int number_of_rounds,\n \n   there_exists_another_round = round < number_of_rounds - 1;\n \n-  block_not_hot_enough = (bb->frequency < exec_th \n+  block_not_hot_enough = (bb->frequency < exec_th\n \t\t\t  || bb->count < count_th\n \t\t\t  || probably_never_executed_bb_p (bb));\n \n   if (there_exists_another_round\n       && block_not_hot_enough)\n     return true;\n-  else \n+  else\n     return false;\n }\n \n@@ -387,7 +387,7 @@ rotate_loop (edge back_edge, struct trace *trace, int trace_n)\n \t      /* Duplicate HEADER if it is a small block containing cond jump\n \t\t in the end.  */\n \t      if (any_condjump_p (BB_END (header)) && copy_bb_p (header, 0)\n-\t\t  && !find_reg_note (BB_END (header), REG_CROSSING_JUMP, \n+\t\t  && !find_reg_note (BB_END (header), REG_CROSSING_JUMP,\n \t\t\t\t     NULL_RTX))\n \t\tcopy_bb (header, single_succ_edge (prev_bb), prev_bb, trace_n);\n \t    }\n@@ -449,11 +449,11 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \tfprintf (dump_file, \"Getting bb %d\\n\", bb->index);\n \n       /* If the BB's frequency is too low send BB to the next round.  When\n-         partitioning hot/cold blocks into separate sections, make sure all\n-         the cold blocks (and ONLY the cold blocks) go into the (extra) final\n-         round.  */\n+\t partitioning hot/cold blocks into separate sections, make sure all\n+\t the cold blocks (and ONLY the cold blocks) go into the (extra) final\n+\t round.  */\n \n-      if (push_to_next_round_p (bb, round, number_of_rounds, exec_th, \n+      if (push_to_next_round_p (bb, round, number_of_rounds, exec_th,\n \t\t\t\tcount_th))\n \t{\n \t  int key = bb_to_key (bb);\n@@ -491,7 +491,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t    fprintf (dump_file, \"Basic block %d was visited in trace %d\\n\",\n \t\t     bb->index, *n_traces - 1);\n \n-          ends_in_call = block_ends_with_call_p (bb);\n+\t  ends_in_call = block_ends_with_call_p (bb);\n \n \t  /* Select the successor that will be placed after BB.  */\n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -593,7 +593,7 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t\t the cold blocks (and only the cold blocks) all get\n \t\t\t pushed to the last round of trace collection.  */\n \n-\t\t      if (push_to_next_round_p (e->dest, round, \n+\t\t      if (push_to_next_round_p (e->dest, round,\n \t\t\t\t\t\tnumber_of_rounds,\n \t\t\t\t\t\texec_th, count_th))\n \t\t\twhich_heap = new_heap;\n@@ -637,8 +637,8 @@ find_traces_1_round (int branch_th, int exec_th, gcov_type count_th,\n \t\t\t\t\t   best_edge->dest->index, bb->index);\n \t\t\t\t}\n \t\t\t      bb->aux = best_edge->dest;\n-\t\t\t      bbd[best_edge->dest->index].in_trace = \n-\t\t\t\t                             (*n_traces) - 1;\n+\t\t\t      bbd[best_edge->dest->index].in_trace =\n+\t\t\t\t\t\t\t     (*n_traces) - 1;\n \t\t\t      bb = rotate_loop (best_edge, trace, *n_traces);\n \t\t\t    }\n \t\t\t}\n@@ -882,8 +882,8 @@ better_edge_p (basic_block bb, edge e, int prob, int freq, int best_prob,\n      non-crossing edges over crossing edges.  */\n \n   if (!is_better_edge\n-      && flag_reorder_blocks_and_partition \n-      && cur_best_edge \n+      && flag_reorder_blocks_and_partition\n+      && cur_best_edge\n       && (cur_best_edge->flags & EDGE_CROSSING)\n       && !(e->flags & EDGE_CROSSING))\n     is_better_edge = true;\n@@ -919,7 +919,7 @@ connect_traces (int n_traces, struct trace *traces)\n \n   if (flag_reorder_blocks_and_partition)\n     for (i = 0; i < n_traces && !two_passes; i++)\n-      if (BB_PARTITION (traces[0].first) \n+      if (BB_PARTITION (traces[0].first)\n \t  != BB_PARTITION (traces[i].first))\n \ttwo_passes = true;\n \n@@ -941,11 +941,11 @@ connect_traces (int n_traces, struct trace *traces)\n \t  else\n \t    current_partition = BB_HOT_PARTITION;\n \t}\n-      \n+\n       if (connected[t])\n \tcontinue;\n \n-      if (two_passes \n+      if (two_passes\n \t  && BB_PARTITION (traces[t].first) != current_partition)\n \tcontinue;\n \n@@ -1217,8 +1217,8 @@ get_uncond_jump_length (void)\n    cache locality).  */\n \n static void\n-find_rarely_executed_basic_blocks_and_crossing_edges (edge *crossing_edges, \n-\t\t\t\t\t\t      int *n_crossing_edges, \n+find_rarely_executed_basic_blocks_and_crossing_edges (edge *crossing_edges,\n+\t\t\t\t\t\t      int *n_crossing_edges,\n \t\t\t\t\t\t      int *max_idx)\n {\n   basic_block bb;\n@@ -1228,7 +1228,7 @@ find_rarely_executed_basic_blocks_and_crossing_edges (edge *crossing_edges,\n   edge_iterator ei;\n \n   /* Mark which partition (hot/cold) each basic block belongs in.  */\n-  \n+\n   FOR_EACH_BB (bb)\n     {\n       if (probably_never_executed_bb_p (bb))\n@@ -1269,7 +1269,7 @@ find_rarely_executed_basic_blocks_and_crossing_edges (edge *crossing_edges,\n    Convert any fall-through crossing edges (for blocks that do not contain\n    a jump) to unconditional jumps.  */\n \n-static void \n+static void\n add_labels_and_missing_jumps (edge *crossing_edges, int n_crossing_edges)\n {\n   int i;\n@@ -1278,45 +1278,45 @@ add_labels_and_missing_jumps (edge *crossing_edges, int n_crossing_edges)\n   rtx label;\n   rtx barrier;\n   rtx new_jump;\n-  \n-  for (i=0; i < n_crossing_edges; i++) \n+\n+  for (i=0; i < n_crossing_edges; i++)\n     {\n-      if (crossing_edges[i]) \n-  \t{\n-  \t  src = crossing_edges[i]->src; \n-  \t  dest = crossing_edges[i]->dest;\n- \t  \n-  \t  /* Make sure dest has a label.  */\n-  \t  \n-  \t  if (dest && (dest != EXIT_BLOCK_PTR))\n-  \t    {\n+      if (crossing_edges[i])\n+\t{\n+\t  src = crossing_edges[i]->src;\n+\t  dest = crossing_edges[i]->dest;\n+\n+\t  /* Make sure dest has a label.  */\n+\n+\t  if (dest && (dest != EXIT_BLOCK_PTR))\n+\t    {\n \t      label = block_label (dest);\n-\t      \n- \t      /* Make sure source block ends with a jump.  */\n-\t      \n- \t      if (src && (src != ENTRY_BLOCK_PTR)) \n- \t\t{\n+\n+\t      /* Make sure source block ends with a jump.  */\n+\n+\t      if (src && (src != ENTRY_BLOCK_PTR))\n+\t\t{\n \t\t  if (!JUMP_P (BB_END (src)))\n- \t\t    /* bb just falls through.  */\n- \t\t    {\n- \t\t      /* make sure there's only one successor */\n+\t\t    /* bb just falls through.  */\n+\t\t    {\n+\t\t      /* make sure there's only one successor */\n \t\t      gcc_assert (single_succ_p (src));\n-\t\t      \n+\n \t\t      /* Find label in dest block.  */\n \t\t      label = block_label (dest);\n-\t\t      \n-\t\t      new_jump = emit_jump_insn_after (gen_jump (label), \n+\n+\t\t      new_jump = emit_jump_insn_after (gen_jump (label),\n \t\t\t\t\t\t       BB_END (src));\n \t\t      barrier = emit_barrier_after (new_jump);\n \t\t      JUMP_LABEL (new_jump) = label;\n \t\t      LABEL_NUSES (label) += 1;\n \t\t      src->il.rtl->footer = unlink_insn_chain (barrier, barrier);\n \t\t      /* Mark edge as non-fallthru.  */\n \t\t      crossing_edges[i]->flags &= ~EDGE_FALLTHRU;\n- \t\t    } /* end: 'if (GET_CODE ... '  */\n- \t\t} /* end: 'if (src && src->index...'  */\n-  \t    } /* end: 'if (dest && dest->index...'  */\n-  \t} /* end: 'if (crossing_edges[i]...'  */\n+\t\t    } /* end: 'if (GET_CODE ... '  */\n+\t\t} /* end: 'if (src && src->index...'  */\n+\t    } /* end: 'if (dest && dest->index...'  */\n+\t} /* end: 'if (crossing_edges[i]...'  */\n     } /* end for loop  */\n }\n \n@@ -1329,7 +1329,7 @@ add_labels_and_missing_jumps (edge *crossing_edges, int n_crossing_edges)\n    unconditional jump (crossing edge) to the original fall through\n    destination.  */\n \n-static void \n+static void\n fix_up_fall_thru_edges (void)\n {\n   basic_block cur_bb;\n@@ -1344,7 +1344,7 @@ fix_up_fall_thru_edges (void)\n   rtx old_jump;\n   rtx fall_thru_label;\n   rtx barrier;\n-  \n+\n   FOR_EACH_BB (cur_bb)\n     {\n       fall_thru = NULL;\n@@ -1354,114 +1354,114 @@ fix_up_fall_thru_edges (void)\n \tsucc1 = NULL;\n \n       if (EDGE_COUNT (cur_bb->succs) > 1)\n-  \tsucc2 = EDGE_SUCC (cur_bb, 1);\n+\tsucc2 = EDGE_SUCC (cur_bb, 1);\n       else\n-  \tsucc2 = NULL;\n-      \n+\tsucc2 = NULL;\n+\n       /* Find the fall-through edge.  */\n-      \n-      if (succ1 \n- \t  && (succ1->flags & EDGE_FALLTHRU))\n- \t{\n- \t  fall_thru = succ1;\n- \t  cond_jump = succ2;\n- \t}\n-      else if (succ2 \n- \t       && (succ2->flags & EDGE_FALLTHRU))\n- \t{\n- \t  fall_thru = succ2;\n- \t  cond_jump = succ1;\n- \t}\n-      \n+\n+      if (succ1\n+\t  && (succ1->flags & EDGE_FALLTHRU))\n+\t{\n+\t  fall_thru = succ1;\n+\t  cond_jump = succ2;\n+\t}\n+      else if (succ2\n+\t       && (succ2->flags & EDGE_FALLTHRU))\n+\t{\n+\t  fall_thru = succ2;\n+\t  cond_jump = succ1;\n+\t}\n+\n       if (fall_thru && (fall_thru->dest != EXIT_BLOCK_PTR))\n-  \t{\n-  \t  /* Check to see if the fall-thru edge is a crossing edge.  */\n-\t\n+\t{\n+\t  /* Check to see if the fall-thru edge is a crossing edge.  */\n+\n \t  if (fall_thru->flags & EDGE_CROSSING)\n-  \t    {\n+\t    {\n \t      /* The fall_thru edge crosses; now check the cond jump edge, if\n-\t         it exists.  */\n-\t      \n- \t      cond_jump_crosses = true;\n- \t      invert_worked  = 0;\n+\t\t it exists.  */\n+\n+\t      cond_jump_crosses = true;\n+\t      invert_worked  = 0;\n \t      old_jump = BB_END (cur_bb);\n-\t      \n- \t      /* Find the jump instruction, if there is one.  */\n-\t      \n- \t      if (cond_jump)\n- \t\t{\n+\n+\t      /* Find the jump instruction, if there is one.  */\n+\n+\t      if (cond_jump)\n+\t\t{\n \t\t  if (!(cond_jump->flags & EDGE_CROSSING))\n- \t\t    cond_jump_crosses = false;\n-\t\t  \n- \t\t  /* We know the fall-thru edge crosses; if the cond\n- \t\t     jump edge does NOT cross, and its destination is the\n+\t\t    cond_jump_crosses = false;\n+\n+\t\t  /* We know the fall-thru edge crosses; if the cond\n+\t\t     jump edge does NOT cross, and its destination is the\n \t\t     next block in the bb order, invert the jump\n- \t\t     (i.e. fix it so the fall thru does not cross and\n- \t\t     the cond jump does).  */\n- \t\t  \n+\t\t     (i.e. fix it so the fall thru does not cross and\n+\t\t     the cond jump does).  */\n+\n \t\t  if (!cond_jump_crosses\n \t\t      && cur_bb->aux == cond_jump->dest)\n- \t\t    {\n- \t\t      /* Find label in fall_thru block. We've already added\n- \t\t         any missing labels, so there must be one.  */\n- \t\t      \n- \t\t      fall_thru_label = block_label (fall_thru->dest);\n-\n- \t\t      if (old_jump && fall_thru_label)\n- \t\t\tinvert_worked = invert_jump (old_jump, \n- \t\t\t\t\t\t     fall_thru_label,0);\n- \t\t      if (invert_worked)\n- \t\t\t{\n- \t\t\t  fall_thru->flags &= ~EDGE_FALLTHRU;\n- \t\t\t  cond_jump->flags |= EDGE_FALLTHRU;\n- \t\t\t  update_br_prob_note (cur_bb);\n- \t\t\t  e = fall_thru;\n- \t\t\t  fall_thru = cond_jump;\n- \t\t\t  cond_jump = e;\n+\t\t    {\n+\t\t      /* Find label in fall_thru block. We've already added\n+\t\t\t any missing labels, so there must be one.  */\n+\n+\t\t      fall_thru_label = block_label (fall_thru->dest);\n+\n+\t\t      if (old_jump && fall_thru_label)\n+\t\t\tinvert_worked = invert_jump (old_jump,\n+\t\t\t\t\t\t     fall_thru_label,0);\n+\t\t      if (invert_worked)\n+\t\t\t{\n+\t\t\t  fall_thru->flags &= ~EDGE_FALLTHRU;\n+\t\t\t  cond_jump->flags |= EDGE_FALLTHRU;\n+\t\t\t  update_br_prob_note (cur_bb);\n+\t\t\t  e = fall_thru;\n+\t\t\t  fall_thru = cond_jump;\n+\t\t\t  cond_jump = e;\n \t\t\t  cond_jump->flags |= EDGE_CROSSING;\n \t\t\t  fall_thru->flags &= ~EDGE_CROSSING;\n- \t\t\t}\n- \t\t    }\n- \t\t}\n-\t      \n- \t      if (cond_jump_crosses || !invert_worked)\n- \t\t{\n- \t\t  /* This is the case where both edges out of the basic\n- \t\t     block are crossing edges. Here we will fix up the\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\n+\t      if (cond_jump_crosses || !invert_worked)\n+\t\t{\n+\t\t  /* This is the case where both edges out of the basic\n+\t\t     block are crossing edges. Here we will fix up the\n \t\t     fall through edge. The jump edge will be taken care\n \t\t     of later.  */\n-\t\t  \n- \t\t  new_bb = force_nonfallthru (fall_thru);  \n-\t\t  \n- \t\t  if (new_bb)\n- \t\t    {\n- \t\t      new_bb->aux = cur_bb->aux;\n- \t\t      cur_bb->aux = new_bb;\n-\t\t      \n- \t\t      /* Make sure new fall-through bb is in same \n+\n+\t\t  new_bb = force_nonfallthru (fall_thru);\n+\n+\t\t  if (new_bb)\n+\t\t    {\n+\t\t      new_bb->aux = cur_bb->aux;\n+\t\t      cur_bb->aux = new_bb;\n+\n+\t\t      /* Make sure new fall-through bb is in same\n \t\t\t partition as bb it's falling through from.  */\n \n \t\t      BB_COPY_PARTITION (new_bb, cur_bb);\n \t\t      single_succ_edge (new_bb)->flags |= EDGE_CROSSING;\n- \t\t    }\n-\t\t  \n- \t\t  /* Add barrier after new jump */\n-\t\t  \n- \t\t  if (new_bb)\n- \t\t    {\n- \t\t      barrier = emit_barrier_after (BB_END (new_bb));\n- \t\t      new_bb->il.rtl->footer = unlink_insn_chain (barrier, \n- \t\t\t\t\t\t\t       barrier);\n- \t\t    }\n- \t\t  else\n- \t\t    {\n- \t\t      barrier = emit_barrier_after (BB_END (cur_bb));\n- \t\t      cur_bb->il.rtl->footer = unlink_insn_chain (barrier,\n- \t\t\t\t\t\t\t       barrier);\n- \t\t    }\n- \t\t}\n-  \t    }\n-  \t}\n+\t\t    }\n+\n+\t\t  /* Add barrier after new jump */\n+\n+\t\t  if (new_bb)\n+\t\t    {\n+\t\t      barrier = emit_barrier_after (BB_END (new_bb));\n+\t\t      new_bb->il.rtl->footer = unlink_insn_chain (barrier,\n+\t\t\t\t\t\t\t       barrier);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      barrier = emit_barrier_after (BB_END (cur_bb));\n+\t\t      cur_bb->il.rtl->footer = unlink_insn_chain (barrier,\n+\t\t\t\t\t\t\t       barrier);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n     }\n }\n \n@@ -1472,9 +1472,9 @@ fix_up_fall_thru_edges (void)\n    contain unconditional jumps to the same destination).  */\n \n static basic_block\n-find_jump_block (basic_block jump_dest) \n-{ \n-  basic_block source_bb = NULL; \n+find_jump_block (basic_block jump_dest)\n+{\n+  basic_block source_bb = NULL;\n   edge e;\n   rtx insn;\n   edge_iterator ei;\n@@ -1483,13 +1483,13 @@ find_jump_block (basic_block jump_dest)\n     if (e->flags & EDGE_CROSSING)\n       {\n \tbasic_block src = e->src;\n-\t\n+\n \t/* Check each predecessor to see if it has a label, and contains\n \t   only one executable instruction, which is an unconditional jump.\n \t   If so, we can use it.  */\n-\t\n+\n \tif (LABEL_P (BB_HEAD (src)))\n-\t  for (insn = BB_HEAD (src); \n+\t  for (insn = BB_HEAD (src);\n \t       !INSN_P (insn) && insn != NEXT_INSN (BB_END (src));\n \t       insn = NEXT_INSN (insn))\n \t    {\n@@ -1502,7 +1502,7 @@ find_jump_block (basic_block jump_dest)\n \t\t  break;\n \t\t}\n \t    }\n-\t\n+\n \tif (source_bb)\n \t  break;\n       }\n@@ -1536,35 +1536,35 @@ fix_crossing_conditional_branches (void)\n   rtx barrier;\n \n  last_bb = EXIT_BLOCK_PTR->prev_bb;\n-  \n+\n   FOR_EACH_BB (cur_bb)\n     {\n       crossing_edge = NULL;\n       if (EDGE_COUNT (cur_bb->succs) > 0)\n \tsucc1 = EDGE_SUCC (cur_bb, 0);\n       else\n \tsucc1 = NULL;\n-    \n+\n       if (EDGE_COUNT (cur_bb->succs) > 1)\n \tsucc2 = EDGE_SUCC (cur_bb, 1);\n       else\n \tsucc2 = NULL;\n-      \n+\n       /* We already took care of fall-through edges, so only one successor\n \t can be a crossing edge.  */\n-      \n+\n       if (succ1 && (succ1->flags & EDGE_CROSSING))\n \tcrossing_edge = succ1;\n       else if (succ2 && (succ2->flags & EDGE_CROSSING))\n- \tcrossing_edge = succ2;\n-      \n-      if (crossing_edge) \n- \t{\n+\tcrossing_edge = succ2;\n+\n+      if (crossing_edge)\n+\t{\n \t  old_jump = BB_END (cur_bb);\n-\t  \n+\n \t  /* Check to make sure the jump instruction is a\n \t     conditional jump.  */\n-\t  \n+\n \t  set_src = NULL_RTX;\n \n \t  if (any_condjump_p (old_jump))\n@@ -1587,89 +1587,89 @@ fix_crossing_conditional_branches (void)\n \t\told_label = XEXP (set_src, 2);\n \t      else if (GET_CODE (XEXP (set_src, 2)) == PC)\n \t\told_label = XEXP (set_src, 1);\n-\t      \n+\n \t      /* Check to see if new bb for jumping to that dest has\n \t\t already been created; if so, use it; if not, create\n \t\t a new one.  */\n \n \t      new_bb = find_jump_block (crossing_edge->dest);\n-\t      \n+\n \t      if (new_bb)\n \t\tnew_label = block_label (new_bb);\n \t      else\n \t\t{\n \t\t  /* Create new basic block to be dest for\n \t\t     conditional jump.  */\n-\t\t  \n+\n \t\t  new_bb = create_basic_block (NULL, NULL, last_bb);\n \t\t  new_bb->aux = last_bb->aux;\n \t\t  last_bb->aux = new_bb;\n \t\t  prev_bb = last_bb;\n \t\t  last_bb = new_bb;\n-\t\t  \n+\n \t\t  /* Update register liveness information.  */\n-\t\t  \n+\n \t\t  new_bb->il.rtl->global_live_at_start = ALLOC_REG_SET (&reg_obstack);\n \t\t  new_bb->il.rtl->global_live_at_end = ALLOC_REG_SET (&reg_obstack);\n \t\t  COPY_REG_SET (new_bb->il.rtl->global_live_at_end,\n \t\t\t\tprev_bb->il.rtl->global_live_at_end);\n \t\t  COPY_REG_SET (new_bb->il.rtl->global_live_at_start,\n \t\t\t\tprev_bb->il.rtl->global_live_at_end);\n-\t\t  \n+\n \t\t  /* Put appropriate instructions in new bb.  */\n-\t\t  \n+\n \t\t  new_label = gen_label_rtx ();\n \t\t  emit_label_before (new_label, BB_HEAD (new_bb));\n \t\t  BB_HEAD (new_bb) = new_label;\n-\t\t  \n+\n \t\t  if (GET_CODE (old_label) == LABEL_REF)\n \t\t    {\n \t\t      old_label = JUMP_LABEL (old_jump);\n-\t\t      new_jump = emit_jump_insn_after (gen_jump \n-\t\t\t\t\t\t       (old_label), \n+\t\t      new_jump = emit_jump_insn_after (gen_jump\n+\t\t\t\t\t\t       (old_label),\n \t\t\t\t\t\t       BB_END (new_bb));\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      gcc_assert (HAVE_return\n \t\t\t\t  && GET_CODE (old_label) == RETURN);\n-\t\t      new_jump = emit_jump_insn_after (gen_return (), \n+\t\t      new_jump = emit_jump_insn_after (gen_return (),\n \t\t\t\t\t\t       BB_END (new_bb));\n \t\t    }\n-\t\t  \n+\n \t\t  barrier = emit_barrier_after (new_jump);\n \t\t  JUMP_LABEL (new_jump) = old_label;\n-\t\t  new_bb->il.rtl->footer = unlink_insn_chain (barrier, \n+\t\t  new_bb->il.rtl->footer = unlink_insn_chain (barrier,\n \t\t\t\t\t\t\t   barrier);\n-\t\t  \n+\n \t\t  /* Make sure new bb is in same partition as source\n \t\t     of conditional branch.  */\n \t\t  BB_COPY_PARTITION (new_bb, cur_bb);\n \t\t}\n-\t      \n+\n \t      /* Make old jump branch to new bb.  */\n-\t      \n+\n \t      redirect_jump (old_jump, new_label, 0);\n-\t      \n+\n \t      /* Remove crossing_edge as predecessor of 'dest'.  */\n-\t      \n+\n \t      dest = crossing_edge->dest;\n-\t      \n+\n \t      redirect_edge_succ (crossing_edge, new_bb);\n-\t      \n+\n \t      /* Make a new edge from new_bb to old dest; new edge\n \t\t will be a successor for new_bb and a predecessor\n \t\t for 'dest'.  */\n-\t      \n+\n \t      if (EDGE_COUNT (new_bb->succs) == 0)\n \t\tnew_edge = make_edge (new_bb, dest, 0);\n \t      else\n \t\tnew_edge = EDGE_SUCC (new_bb, 0);\n-\t      \n+\n \t      crossing_edge->flags &= ~EDGE_CROSSING;\n \t      new_edge->flags |= EDGE_CROSSING;\n \t    }\n- \t}\n+\t}\n     }\n }\n \n@@ -1699,7 +1699,7 @@ fix_crossing_unconditional_branches (void)\n       succ = EDGE_SUCC (cur_bb, 0);\n \n       /* Check to see if bb ends in a crossing (unconditional) jump.  At\n-         this point, no crossing jumps should be conditional.  */\n+\t this point, no crossing jumps should be conditional.  */\n \n       if (JUMP_P (last_insn)\n \t  && (succ->flags & EDGE_CROSSING))\n@@ -1716,26 +1716,26 @@ fix_crossing_unconditional_branches (void)\n \t      /* We have found a \"crossing\" unconditional branch.  Now\n \t\t we must convert it to an indirect jump.  First create\n \t\t reference of label, as target for jump.  */\n-\t      \n+\n \t      label = JUMP_LABEL (last_insn);\n \t      label_addr = gen_rtx_LABEL_REF (Pmode, label);\n \t      LABEL_NUSES (label) += 1;\n-\t      \n+\n \t      /* Get a register to use for the indirect jump.  */\n-\t      \n+\n \t      new_reg = gen_reg_rtx (Pmode);\n-\t      \n+\n \t      /* Generate indirect the jump sequence.  */\n-\t      \n+\n \t      start_sequence ();\n \t      emit_move_insn (new_reg, label_addr);\n \t      emit_indirect_jump (new_reg);\n \t      indirect_jump_sequence = get_insns ();\n \t      end_sequence ();\n-\t      \n+\n \t      /* Make sure every instruction in the new jump sequence has\n \t\t its basic block set to be cur_bb.  */\n-\t      \n+\n \t      for (cur_insn = indirect_jump_sequence; cur_insn;\n \t\t   cur_insn = NEXT_INSN (cur_insn))\n \t\t{\n@@ -1744,16 +1744,16 @@ fix_crossing_unconditional_branches (void)\n \t\t  if (JUMP_P (cur_insn))\n \t\t    jump_insn = cur_insn;\n \t\t}\n-\t      \n+\n \t      /* Insert the new (indirect) jump sequence immediately before\n \t\t the unconditional jump, then delete the unconditional jump.  */\n-\t      \n+\n \t      emit_insn_before (indirect_jump_sequence, last_insn);\n \t      delete_insn (last_insn);\n-\t      \n+\n \t      /* Make BB_END for cur_bb be the jump instruction (NOT the\n \t\t barrier instruction at the end of the sequence...).  */\n-\t      \n+\n \t      BB_END (cur_bb) = jump_insn;\n \t    }\n \t}\n@@ -1773,9 +1773,9 @@ add_reg_crossing_jump_notes (void)\n     FOR_EACH_EDGE (e, ei, bb->succs)\n       if ((e->flags & EDGE_CROSSING)\n \t  && JUMP_P (BB_END (e->src)))\n-\tREG_NOTES (BB_END (e->src)) = gen_rtx_EXPR_LIST (REG_CROSSING_JUMP, \n-\t\t\t\t\t\t\t NULL_RTX, \n-\t\t\t\t\t\t         REG_NOTES (BB_END \n+\tREG_NOTES (BB_END (e->src)) = gen_rtx_EXPR_LIST (REG_CROSSING_JUMP,\n+\t\t\t\t\t\t\t NULL_RTX,\n+\t\t\t\t\t\t\t REG_NOTES (BB_END\n \t\t\t\t\t\t\t\t  (e->src)));\n }\n \n@@ -1793,57 +1793,57 @@ add_reg_crossing_jump_notes (void)\n    sections are converted to indirect jumps.\n \n    The code for fixing up fall_thru edges that cross between hot and\n-   cold basic blocks does so by creating new basic blocks containing \n-   unconditional branches to the appropriate label in the \"other\" \n+   cold basic blocks does so by creating new basic blocks containing\n+   unconditional branches to the appropriate label in the \"other\"\n    section.  The new basic block is then put in the same (hot or cold)\n    section as the original conditional branch, and the fall_thru edge\n    is modified to fall into the new basic block instead.  By adding\n    this level of indirection we end up with only unconditional branches\n-   crossing between hot and cold sections.  \n-   \n+   crossing between hot and cold sections.\n+\n    Conditional branches are dealt with by adding a level of indirection.\n-   A new basic block is added in the same (hot/cold) section as the \n+   A new basic block is added in the same (hot/cold) section as the\n    conditional branch, and the conditional branch is retargeted to the\n    new basic block.  The new basic block contains an unconditional branch\n    to the original target of the conditional branch (in the other section).\n \n    Unconditional branches are dealt with by converting them into\n    indirect jumps.  */\n \n-static void \n-fix_edges_for_rarely_executed_code (edge *crossing_edges, \n+static void\n+fix_edges_for_rarely_executed_code (edge *crossing_edges,\n \t\t\t\t    int n_crossing_edges)\n {\n   /* Make sure the source of any crossing edge ends in a jump and the\n      destination of any crossing edge has a label.  */\n-  \n+\n   add_labels_and_missing_jumps (crossing_edges, n_crossing_edges);\n-  \n+\n   /* Convert all crossing fall_thru edges to non-crossing fall\n      thrus to unconditional jumps (that jump to the original fall\n      thru dest).  */\n-  \n+\n   fix_up_fall_thru_edges ();\n-  \n+\n   /* If the architecture does not have conditional branches that can\n      span all of memory, convert crossing conditional branches into\n      crossing unconditional branches.  */\n-  \n+\n   if (!HAS_LONG_COND_BRANCH)\n     fix_crossing_conditional_branches ();\n-  \n+\n   /* If the architecture does not have unconditional branches that\n      can span all of memory, convert crossing unconditional branches\n      into indirect jumps.  Since adding an indirect jump also adds\n      a new register usage, update the register usage information as\n      well.  */\n-  \n+\n   if (!HAS_LONG_UNCOND_BRANCH)\n     {\n       fix_crossing_unconditional_branches ();\n       reg_scan (get_insns(), max_reg_num ());\n     }\n-  \n+\n   add_reg_crossing_jump_notes ();\n }\n \n@@ -1860,7 +1860,7 @@ verify_hot_cold_block_grouping (void)\n   int err = 0;\n   bool switched_sections = false;\n   int current_partition = 0;\n-  \n+\n   FOR_EACH_BB (bb)\n     {\n       if (!current_partition)\n@@ -1880,7 +1880,7 @@ verify_hot_cold_block_grouping (void)\n \t    }\n \t}\n     }\n-  \n+\n   gcc_assert(!err);\n }\n \n@@ -1951,7 +1951,7 @@ insert_section_boundary_note (void)\n   basic_block bb;\n   rtx new_note;\n   int first_partition = 0;\n-  \n+\n   if (flag_reorder_blocks_and_partition)\n     FOR_EACH_BB (bb)\n     {\n@@ -2061,7 +2061,7 @@ duplicate_computed_gotos (void)\n       bb->il.rtl->visited = 1;\n \n       /* BB must have one outgoing edge.  That edge must not lead to\n-         the exit block or the next block.\n+\t the exit block or the next block.\n \t The destination must have more than one predecessor.  */\n       if (!single_succ_p (bb)\n \t  || single_succ (bb) == EXIT_BLOCK_PTR\n@@ -2169,26 +2169,26 @@ partition_hot_cold_basic_blocks (void)\n   edge *crossing_edges;\n   int n_crossing_edges;\n   int max_edges = 2 * last_basic_block;\n-  \n+\n   if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n     return;\n-  \n+\n   crossing_edges = XCNEWVEC (edge, max_edges);\n \n   cfg_layout_initialize (0);\n-  \n+\n   FOR_EACH_BB (cur_bb)\n     if (cur_bb->index >= NUM_FIXED_BLOCKS\n- \t&& cur_bb->next_bb->index >= NUM_FIXED_BLOCKS)\n+\t&& cur_bb->next_bb->index >= NUM_FIXED_BLOCKS)\n       cur_bb->aux = cur_bb->next_bb;\n-  \n-  find_rarely_executed_basic_blocks_and_crossing_edges (crossing_edges, \n-\t\t\t\t\t\t\t&n_crossing_edges, \n+\n+  find_rarely_executed_basic_blocks_and_crossing_edges (crossing_edges,\n+\t\t\t\t\t\t\t&n_crossing_edges,\n \t\t\t\t\t\t\t&max_edges);\n \n   if (n_crossing_edges > 0)\n     fix_edges_for_rarely_executed_code (crossing_edges, n_crossing_edges);\n-  \n+\n   free (crossing_edges);\n \n   cfg_layout_finalize();\n@@ -2231,7 +2231,7 @@ rest_of_handle_reorder_blocks (void)\n      but should not be terribly bad.  */\n   if (changed && HAVE_conditional_execution)\n     update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n-                      PROP_DEATH_NOTES);\n+\t\t      PROP_DEATH_NOTES);\n \n   /* Add NOTE_INSN_SWITCH_TEXT_SECTIONS notes.  */\n   insert_section_boundary_note ();\n@@ -2264,8 +2264,8 @@ gate_handle_partition_blocks (void)\n      arises.  */\n \n   return (flag_reorder_blocks_and_partition\n-          && !DECL_ONE_ONLY (current_function_decl)\n-          && !user_defined_section_attribute);\n+\t  && !DECL_ONE_ONLY (current_function_decl)\n+\t  && !user_defined_section_attribute);\n }\n \n /* Partition hot and cold basic blocks.  */\n@@ -2276,7 +2276,7 @@ rest_of_handle_partition_blocks (void)\n   partition_hot_cold_basic_blocks ();\n   allocate_reg_life_data ();\n   update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n-                    PROP_LOG_LINKS | PROP_REG_INFO | PROP_DEATH_NOTES);\n+\t\t    PROP_LOG_LINKS | PROP_REG_INFO | PROP_DEATH_NOTES);\n   no_new_pseudos = 1;\n   return 0;\n }"}, {"sha": "efc789a3211a4c9c5e3cb92b9126e8e3c3430f37", "filename": "gcc/bitmap.c", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -50,7 +50,7 @@ static inline void\n bitmap_elem_to_freelist (bitmap head, bitmap_element *elt)\n {\n   bitmap_obstack *bit_obstack = head->obstack;\n-  \n+\n   elt->next = NULL;\n   if (bit_obstack)\n     {\n@@ -89,7 +89,7 @@ bitmap_element_free (bitmap head, bitmap_element *elt)\n       head->current = next != 0 ? next : prev;\n       if (head->current)\n \thead->indx = head->current->indx;\n-      else \n+      else\n \thead->indx = 0;\n     }\n   bitmap_elem_to_freelist (head, elt);\n@@ -102,11 +102,11 @@ bitmap_element_allocate (bitmap head)\n {\n   bitmap_element *element;\n   bitmap_obstack *bit_obstack = head->obstack;\n-      \n+\n   if (bit_obstack)\n     {\n       element = bit_obstack->elements;\n-      \n+\n       if (element)\n \t/* Use up the inner list first before looking at the next\n \t   element of the outer list.  */\n@@ -163,18 +163,18 @@ bitmap_elt_clear_from (bitmap head, bitmap_element *elt)\n \t  head->current = prev;\n \t  head->indx = prev->indx;\n \t}\n-    } \n+    }\n   else\n     {\n       head->first = NULL;\n       head->current = NULL;\n       head->indx = 0;\n     }\n \n-  /* Put the entire list onto the free list in one operation. */ \n+  /* Put the entire list onto the free list in one operation. */\n   if (bit_obstack)\n     {\n-      elt->prev = bit_obstack->elements; \n+      elt->prev = bit_obstack->elements;\n       bit_obstack->elements = elt;\n     }\n   else\n@@ -222,7 +222,7 @@ bitmap_obstack_release (bitmap_obstack *bit_obstack)\n {\n   if (!bit_obstack)\n     bit_obstack = &bitmap_default_obstack;\n-  \n+\n   bit_obstack->elements = NULL;\n   bit_obstack->heads = NULL;\n   obstack_free (&bit_obstack->obstack, NULL);\n@@ -529,7 +529,7 @@ bitmap_bit_p (bitmap head, int bit)\n \f\n #if GCC_VERSION < 3400\n /* Table of number of set bits in a character, indexed by value of char.  */\n-static unsigned char popcount_table[] = \n+static unsigned char popcount_table[] =\n {\n     0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,\n     1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,\n@@ -571,13 +571,13 @@ bitmap_count_bits (bitmap a)\n \t of BITMAP_WORD is not material.  */\n \t  count += __builtin_popcountl (elt->bits[ix]);\n #else\n-\t  count += bitmap_popcount (elt->bits[ix]);\t  \n+\t  count += bitmap_popcount (elt->bits[ix]);\n #endif\n \t}\n     }\n   return count;\n }\n-      \n+\n \n \n /* Return the bit number of the first set bit in the bitmap.  The\n@@ -590,7 +590,7 @@ bitmap_first_set_bit (bitmap a)\n   unsigned bit_no;\n   BITMAP_WORD word;\n   unsigned ix;\n-  \n+\n   gcc_assert (elt);\n   bit_no = elt->indx * BITMAP_ELEMENT_ALL_BITS;\n   for (ix = 0; ix != BITMAP_ELEMENT_WORDS; ix++)\n@@ -625,7 +625,7 @@ bitmap_first_set_bit (bitmap a)\n     word >>= 2, bit_no += 2;\n   if (!(word & 0x1))\n     word >>= 1, bit_no += 1;\n-  \n+\n  gcc_assert (word & 1);\n #endif\n  return bit_no;\n@@ -664,7 +664,7 @@ bitmap_and (bitmap dst, bitmap a, bitmap b)\n \n \t  if (!dst_elt)\n \t    dst_elt = bitmap_elt_insert_after (dst, dst_prev, a_elt->indx);\n-\t  else \n+\t  else\n \t    dst_elt->indx = a_elt->indx;\n \t  for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n \t    {\n@@ -697,7 +697,7 @@ bitmap_and_into (bitmap a, bitmap b)\n   bitmap_element *b_elt = b->first;\n   bitmap_element *next;\n \n-  if (a == b) \n+  if (a == b)\n     return;\n \n   while (a_elt && b_elt)\n@@ -746,7 +746,7 @@ bitmap_and_compl (bitmap dst, bitmap a, bitmap b)\n   bitmap_element *dst_prev = NULL;\n \n   gcc_assert (dst != a && dst != b);\n-  \n+\n   if (a == b)\n     {\n       bitmap_clear (dst);\n@@ -777,7 +777,7 @@ bitmap_and_compl (bitmap dst, bitmap a, bitmap b)\n \n \t  if (!dst_elt)\n \t    dst_elt = bitmap_elt_insert_after (dst, dst_prev, a_elt->indx);\n-\t  else \n+\t  else\n \t    dst_elt->indx = a_elt->indx;\n \t  for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n \t    {\n@@ -869,7 +869,7 @@ bitmap_clear_range (bitmap head, unsigned int start, unsigned int count)\n      to the result.  If the current is less than first index, find the\n      next one.  Otherwise, just set elt to be current.  */\n   if (!elt)\n-    { \n+    {\n       if (head->current)\n \t{\n \t  if (head->indx < first_index)\n@@ -878,7 +878,7 @@ bitmap_clear_range (bitmap head, unsigned int start, unsigned int count)\n \t      if (!elt)\n \t\treturn;\n \t    }\n-\t  else \n+\t  else\n \t    elt = head->current;\n \t}\n       else\n@@ -895,11 +895,11 @@ bitmap_clear_range (bitmap head, unsigned int start, unsigned int count)\n       if (elt_start_bit >= start && elt_end_bit_plus1 <= end_bit_plus1)\n \t/* Get rid of the entire elt and go to the next one.  */\n \tbitmap_element_free (head, elt);\n-      else \n+      else\n \t{\n \t  /* Going to have to knock out some bits in this elt.  */\n-\t  unsigned int first_word_to_mod; \n-\t  BITMAP_WORD first_mask; \n+\t  unsigned int first_word_to_mod;\n+\t  BITMAP_WORD first_mask;\n \t  unsigned int last_word_to_mod;\n \t  BITMAP_WORD last_mask;\n \t  unsigned int i;\n@@ -912,7 +912,7 @@ bitmap_clear_range (bitmap head, unsigned int start, unsigned int count)\n \t      first_word_to_mod = (start - elt_start_bit) / BITMAP_WORD_BITS;\n \n \t      /* This mask should have 1s in all bits >= start position. */\n-\t      first_mask = \n+\t      first_mask =\n \t\t(((BITMAP_WORD) 1) << ((start % BITMAP_WORD_BITS))) - 1;\n \t      first_mask = ~first_mask;\n \t    }\n@@ -922,8 +922,8 @@ bitmap_clear_range (bitmap head, unsigned int start, unsigned int count)\n \t      first_word_to_mod = 0;\n \t      first_mask = 0;\n \t      first_mask = ~first_mask;\n-\t    }\t      \n-\t    \n+\t    }\n+\n \t  if (elt_end_bit_plus1 <= end_bit_plus1)\n \t    {\n \t      /* The last bit to turn off is beyond this elt.  */\n@@ -934,11 +934,11 @@ bitmap_clear_range (bitmap head, unsigned int start, unsigned int count)\n \t  else\n \t    {\n \t      /* The last bit to turn off is inside to this elt.  */\n-\t      last_word_to_mod = \n+\t      last_word_to_mod =\n \t\t(end_bit_plus1 - elt_start_bit) / BITMAP_WORD_BITS;\n \n \t      /* The last mask should have 1s below the end bit.  */\n-\t      last_mask = \n+\t      last_mask =\n \t\t(((BITMAP_WORD) 1) << (((end_bit_plus1) % BITMAP_WORD_BITS))) - 1;\n \t    }\n \n@@ -967,7 +967,7 @@ bitmap_clear_range (bitmap head, unsigned int start, unsigned int count)\n \t}\n       elt = next_elt;\n     }\n-  \n+\n   if (elt)\n     {\n       head->current = elt;\n@@ -1053,7 +1053,7 @@ bitmap_ior (bitmap dst, bitmap a, bitmap b)\n   bitmap_element *a_elt = a->first;\n   bitmap_element *b_elt = b->first;\n   bitmap_element *dst_prev = NULL;\n-  bool changed = false;  \n+  bool changed = false;\n \n   gcc_assert (dst != a && dst != b);\n \n@@ -1063,7 +1063,7 @@ bitmap_ior (bitmap dst, bitmap a, bitmap b)\n \t{\n \t  /* Matching elts, generate A | B.  */\n \t  unsigned ix;\n-\t      \n+\n \t  if (!changed && dst_elt && dst_elt->indx == a_elt->indx)\n \t    {\n \t      for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n@@ -1082,12 +1082,12 @@ bitmap_ior (bitmap dst, bitmap a, bitmap b)\n \t      changed = true;\n \t      if (!dst_elt)\n \t\tdst_elt = bitmap_elt_insert_after (dst, dst_prev, a_elt->indx);\n-\t      else \n+\t      else\n \t\tdst_elt->indx = a_elt->indx;\n \t      for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n \t\t{\n \t\t  BITMAP_WORD r = a_elt->bits[ix] | b_elt->bits[ix];\n-\t\t  \n+\n \t\t  dst_elt->bits[ix] = r;\n \t\t}\n \t    }\n@@ -1115,7 +1115,7 @@ bitmap_ior (bitmap dst, bitmap a, bitmap b)\n \t  if (!changed && dst_elt && dst_elt->indx == src->indx)\n \t    {\n \t      unsigned ix;\n-\t      \n+\n \t      for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n \t\tif (src->bits[ix] != dst_elt->bits[ix])\n \t\t  {\n@@ -1128,11 +1128,11 @@ bitmap_ior (bitmap dst, bitmap a, bitmap b)\n \t      changed = true;\n \t      if (!dst_elt)\n \t\tdst_elt = bitmap_elt_insert_after (dst, dst_prev, src->indx);\n-\t      else \n+\t      else\n \t\tdst_elt->indx = src->indx;\n \t      memcpy (dst_elt->bits, src->bits, sizeof (dst_elt->bits));\n \t    }\n-\t  \n+\n \t  dst_prev = dst_elt;\n \t  dst_elt = dst_elt->next;\n \t}\n@@ -1187,7 +1187,7 @@ bitmap_ior_into (bitmap a, bitmap b)\n \t    for (ix = BITMAP_ELEMENT_WORDS; ix--;)\n \t      {\n \t\tBITMAP_WORD r = a_elt->bits[ix] | b_elt->bits[ix];\n-\t\t\n+\n \t\ta_elt->bits[ix] = r;\n \t      }\n \t  else\n@@ -1274,7 +1274,7 @@ bitmap_xor (bitmap dst, bitmap a, bitmap b)\n \n \t  if (!dst_elt)\n \t    dst_elt = bitmap_elt_insert_after (dst, dst_prev, src->indx);\n-\t  else \n+\t  else\n \t    dst_elt->indx = src->indx;\n \t  memcpy (dst_elt->bits, src->bits, sizeof (dst_elt->bits));\n \t  dst_prev = dst_elt;\n@@ -1354,7 +1354,7 @@ bitmap_equal_p (bitmap a, bitmap b)\n   bitmap_element *a_elt;\n   bitmap_element *b_elt;\n   unsigned ix;\n-  \n+\n   for (a_elt = a->first, b_elt = b->first;\n        a_elt && b_elt;\n        a_elt = a_elt->next, b_elt = b_elt->next)\n@@ -1376,7 +1376,7 @@ bitmap_intersect_p (bitmap a, bitmap b)\n   bitmap_element *a_elt;\n   bitmap_element *b_elt;\n   unsigned ix;\n-  \n+\n   for (a_elt = a->first, b_elt = b->first;\n        a_elt && b_elt;)\n     {\n@@ -1447,7 +1447,7 @@ bitmap_ior_and_compl_into (bitmap a, bitmap from1, bitmap from2)\n {\n   bitmap_head tmp;\n   bool changed;\n-  \n+\n   bitmap_initialize (&tmp, &bitmap_default_obstack);\n   bitmap_and_compl (&tmp, from1, from2);\n   changed = bitmap_ior_into (a, &tmp);"}, {"sha": "d11fa46243bbe68ec45fc15960f9b5d8469ea2cc", "filename": "gcc/bitmap.h", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -49,7 +49,7 @@ typedef struct bitmap_obstack GTY (())\n \n /* Bitmap set element.  We use a linked list to hold only the bits that\n    are set.  This allows for use to grow the bitset dynamically without\n-   having to realloc and copy a giant bit array.  \n+   having to realloc and copy a giant bit array.\n \n    The free list is implemented as a list of lists.  There is one\n    outer list connected together by prev fields.  Each element of that\n@@ -172,21 +172,21 @@ extern unsigned bitmap_first_set_bit (bitmap);\n \n /* Do any cleanup needed on a bitmap when it is no longer used.  */\n #define BITMAP_FREE(BITMAP)\t\t\t\\\n-      \t((void)(bitmap_obstack_free (BITMAP), (BITMAP) = NULL))\n+\t((void)(bitmap_obstack_free (BITMAP), (BITMAP) = NULL))\n \n /* Iterator for bitmaps.  */\n \n typedef struct\n {\n   /* Pointer to the current bitmap element.  */\n   bitmap_element *elt1;\n-  \n+\n   /* Pointer to 2nd bitmap element when two are involved.  */\n   bitmap_element *elt2;\n \n   /* Word within the current element.  */\n   unsigned word_no;\n-  \n+\n   /* Contents of the actually processed word.  When finding next bit\n      it is shifted right, so that the actual bit is always the least\n      significant bit of ACTUAL.  */\n@@ -211,7 +211,7 @@ bmp_iter_set_init (bitmap_iterator *bi, bitmap map,\n \t  bi->elt1 = &bitmap_zero_bits;\n \t  break;\n \t}\n-      \n+\n       if (bi->elt1->indx >= start_bit / BITMAP_ELEMENT_ALL_BITS)\n \tbreak;\n       bi->elt1 = bi->elt1->next;\n@@ -220,7 +220,7 @@ bmp_iter_set_init (bitmap_iterator *bi, bitmap map,\n   /* We might have gone past the start bit, so reinitialize it.  */\n   if (bi->elt1->indx != start_bit / BITMAP_ELEMENT_ALL_BITS)\n     start_bit = bi->elt1->indx * BITMAP_ELEMENT_ALL_BITS;\n-  \n+\n   /* Initialize for what is now start_bit.  */\n   bi->word_no = start_bit / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\n   bi->bits = bi->elt1->bits[bi->word_no];\n@@ -231,7 +231,7 @@ bmp_iter_set_init (bitmap_iterator *bi, bitmap map,\n      will fail.  It won't matter if this increment moves us into the\n      next word.  */\n   start_bit += !bi->bits;\n-  \n+\n   *bit_no = start_bit;\n }\n \n@@ -254,12 +254,12 @@ bmp_iter_and_init (bitmap_iterator *bi, bitmap map1, bitmap map2,\n \t  bi->elt2 = NULL;\n \t  break;\n \t}\n-      \n+\n       if (bi->elt1->indx >= start_bit / BITMAP_ELEMENT_ALL_BITS)\n \tbreak;\n       bi->elt1 = bi->elt1->next;\n     }\n-  \n+\n   /* Advance elt2 until it is not before elt1.  */\n   while (1)\n     {\n@@ -268,7 +268,7 @@ bmp_iter_and_init (bitmap_iterator *bi, bitmap map1, bitmap map2,\n \t  bi->elt1 = bi->elt2 = &bitmap_zero_bits;\n \t  break;\n \t}\n-      \n+\n       if (bi->elt2->indx >= bi->elt1->indx)\n \tbreak;\n       bi->elt2 = bi->elt2->next;\n@@ -278,10 +278,10 @@ bmp_iter_and_init (bitmap_iterator *bi, bitmap map1, bitmap map2,\n   if (bi->elt1->indx == bi->elt2->indx)\n     {\n       /* We might have advanced beyond the start_bit, so reinitialize\n-     \t for that.  */\n+\t for that.  */\n       if (bi->elt1->indx != start_bit / BITMAP_ELEMENT_ALL_BITS)\n \tstart_bit = bi->elt1->indx * BITMAP_ELEMENT_ALL_BITS;\n-      \n+\n       bi->word_no = start_bit / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\n       bi->bits = bi->elt1->bits[bi->word_no] & bi->elt2->bits[bi->word_no];\n       bi->bits >>= start_bit % BITMAP_WORD_BITS;\n@@ -293,13 +293,13 @@ bmp_iter_and_init (bitmap_iterator *bi, bitmap map1, bitmap map2,\n       bi->word_no = BITMAP_ELEMENT_WORDS - 1;\n       bi->bits = 0;\n     }\n-  \n+\n   /* If this word is zero, we must make sure we're not pointing at the\n      first bit, otherwise our incrementing to the next word boundary\n      will fail.  It won't matter if this increment moves us into the\n      next word.  */\n   start_bit += !bi->bits;\n-  \n+\n   *bit_no = start_bit;\n }\n \n@@ -321,7 +321,7 @@ bmp_iter_and_compl_init (bitmap_iterator *bi, bitmap map1, bitmap map2,\n \t  bi->elt1 = &bitmap_zero_bits;\n \t  break;\n \t}\n-      \n+\n       if (bi->elt1->indx >= start_bit / BITMAP_ELEMENT_ALL_BITS)\n \tbreak;\n       bi->elt1 = bi->elt1->next;\n@@ -335,19 +335,19 @@ bmp_iter_and_compl_init (bitmap_iterator *bi, bitmap map1, bitmap map2,\n      that.  */\n   if (bi->elt1->indx != start_bit / BITMAP_ELEMENT_ALL_BITS)\n     start_bit = bi->elt1->indx * BITMAP_ELEMENT_ALL_BITS;\n-  \n+\n   bi->word_no = start_bit / BITMAP_WORD_BITS % BITMAP_ELEMENT_WORDS;\n   bi->bits = bi->elt1->bits[bi->word_no];\n   if (bi->elt2 && bi->elt1->indx == bi->elt2->indx)\n     bi->bits &= ~bi->elt2->bits[bi->word_no];\n   bi->bits >>= start_bit % BITMAP_WORD_BITS;\n-  \n+\n   /* If this word is zero, we must make sure we're not pointing at the\n      first bit, otherwise our incrementing to the next word boundary\n      will fail.  It won't matter if this increment moves us into the\n      next word.  */\n   start_bit += !bi->bits;\n-  \n+\n   *bit_no = start_bit;\n }\n \n@@ -398,7 +398,7 @@ bmp_iter_set (bitmap_iterator *bi, unsigned *bit_no)\n \t  *bit_no += BITMAP_WORD_BITS;\n \t  bi->word_no++;\n \t}\n-  \n+\n       /* Advance to the next element.  */\n       bi->elt1 = bi->elt1->next;\n       if (!bi->elt1)\n@@ -433,7 +433,7 @@ bmp_iter_and (bitmap_iterator *bi, unsigned *bit_no)\n   *bit_no = ((*bit_no + BITMAP_WORD_BITS - 1)\n \t     / BITMAP_WORD_BITS * BITMAP_WORD_BITS);\n   bi->word_no++;\n-  \n+\n   while (1)\n     {\n       /* Find the next nonzero word in this elt.  */\n@@ -445,7 +445,7 @@ bmp_iter_and (bitmap_iterator *bi, unsigned *bit_no)\n \t  *bit_no += BITMAP_WORD_BITS;\n \t  bi->word_no++;\n \t}\n-  \n+\n       /* Advance to the next identical element.  */\n       do\n \t{\n@@ -458,7 +458,7 @@ bmp_iter_and (bitmap_iterator *bi, unsigned *bit_no)\n \t\treturn false;\n \t    }\n \t  while (bi->elt1->indx < bi->elt2->indx);\n-\t\n+\n \t  /* Advance elt2 to be no less than elt1.  This might not\n \t     advance.  */\n \t  while (bi->elt2->indx < bi->elt1->indx)\n@@ -469,7 +469,7 @@ bmp_iter_and (bitmap_iterator *bi, unsigned *bit_no)\n \t    }\n \t}\n       while (bi->elt1->indx != bi->elt2->indx);\n-  \n+\n       *bit_no = bi->elt1->indx * BITMAP_ELEMENT_ALL_BITS;\n       bi->word_no = 0;\n     }\n@@ -514,7 +514,7 @@ bmp_iter_and_compl (bitmap_iterator *bi, unsigned *bit_no)\n \t  *bit_no += BITMAP_WORD_BITS;\n \t  bi->word_no++;\n \t}\n-  \n+\n       /* Advance to the next element of elt1.  */\n       bi->elt1 = bi->elt1->next;\n       if (!bi->elt1)\n@@ -523,7 +523,7 @@ bmp_iter_and_compl (bitmap_iterator *bi, unsigned *bit_no)\n       /* Advance elt2 until it is no less than elt1.  */\n       while (bi->elt2 && bi->elt2->indx < bi->elt1->indx)\n \tbi->elt2 = bi->elt2->next;\n-      \n+\n       *bit_no = bi->elt1->indx * BITMAP_ELEMENT_ALL_BITS;\n       bi->word_no = 0;\n     }\n@@ -545,7 +545,7 @@ bmp_iter_and_compl (bitmap_iterator *bi, unsigned *bit_no)\n    loop state.  */\n \n #define EXECUTE_IF_AND_IN_BITMAP(BITMAP1, BITMAP2, MIN, BITNUM, ITER)\t\\\n-  for (bmp_iter_and_init (&(ITER), (BITMAP1), (BITMAP2), (MIN), \t\\\n+  for (bmp_iter_and_init (&(ITER), (BITMAP1), (BITMAP2), (MIN),\t\t\\\n \t\t\t  &(BITNUM));\t\t\t\t\t\\\n        bmp_iter_and (&(ITER), &(BITNUM));\t\t\t\t\\\n        bmp_iter_next (&(ITER), &(BITNUM)))\n@@ -557,7 +557,7 @@ bmp_iter_and_compl (bitmap_iterator *bi, unsigned *bit_no)\n \n #define EXECUTE_IF_AND_COMPL_IN_BITMAP(BITMAP1, BITMAP2, MIN, BITNUM, ITER) \\\n   for (bmp_iter_and_compl_init (&(ITER), (BITMAP1), (BITMAP2), (MIN),\t\\\n-\t\t\t\t&(BITNUM)); \t\t\t\t\\\n+\t\t\t\t&(BITNUM));\t\t\t\t\\\n        bmp_iter_and_compl (&(ITER), &(BITNUM));\t\t\t\t\\\n        bmp_iter_next (&(ITER), &(BITNUM)))\n "}, {"sha": "bd1761616c973a36fa3dfcb3afd175bffeea84b4", "filename": "gcc/bt-load.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -241,7 +241,7 @@ insn_sets_btr_p (rtx insn, int check_const, int *regno)\n \t  && TEST_HARD_REG_BIT (all_btrs, REGNO (dest)))\n \t{\n \t  gcc_assert (!btr_referenced_p (src, NULL));\n-\t  \n+\n \t  if (!check_const || CONSTANT_P (src))\n \t    {\n \t      if (regno)\n@@ -924,12 +924,12 @@ augment_live_range (bitmap live_range, HARD_REG_SET *btrs_live_in_range,\n       int new_block = new_bb->index;\n \n       gcc_assert (dominated_by_p (CDI_DOMINATORS, head_bb, new_bb));\n-  \n+\n       IOR_HARD_REG_SET (*btrs_live_in_range, btrs_live[head_bb->index]);\n       bitmap_set_bit (live_range, new_block);\n       /* A previous btr migration could have caused a register to be\n-        live just at the end of new_block which we need in full, so\n-        use trs_live_at_end even if full_range is set.  */\n+\tlive just at the end of new_block which we need in full, so\n+\tuse trs_live_at_end even if full_range is set.  */\n       IOR_HARD_REG_SET (*btrs_live_in_range, btrs_live_at_end[new_block]);\n       if (full_range)\n \tIOR_HARD_REG_SET (*btrs_live_in_range, btrs_live[new_block]);\n@@ -1192,7 +1192,7 @@ move_btr_def (basic_block new_def_bb, int btr, btr_def def, bitmap live_range,\n       insp = BB_END (b);\n       for (insp = BB_END (b); ! INSN_P (insp); insp = PREV_INSN (insp))\n \tgcc_assert (insp != BB_HEAD (b));\n-      \n+\n       if (JUMP_P (insp) || can_throw_internal (insp))\n \tinsp = PREV_INSN (insp);\n     }\n@@ -1513,7 +1513,7 @@ rest_of_handle_branch_target_load_optimize (void)\n       && !warned)\n     {\n       warning (0, \"branch target register load optimization is not intended \"\n-                  \"to be run twice\");\n+\t\t  \"to be run twice\");\n \n       warned = 1;\n     }\n@@ -1530,7 +1530,7 @@ struct tree_opt_pass pass_branch_target_load_optimize =\n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */\n-  0,\t\t                        /* tv_id */\n+  0,\t\t\t\t\t/* tv_id */\n   0,                                    /* properties_required */\n   0,                                    /* properties_provided */\n   0,                                    /* properties_destroyed */"}, {"sha": "b4d5a48e1ce36cc915052084cb787b8891a27b97", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -58,7 +58,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n        DEF_FUNCTION_TYPE_VAR_1 (BT_INT_DOUBLE_VAR, BT_INT, BT_DOUBLE)\n \n      describes the type `int ()(double, ...)'.\n- \n+\n   DEF_POINTER_TYPE (ENUM, TYPE)\n \n     This macro describes a pointer type.  ENUM is as above; TYPE is\n@@ -142,20 +142,20 @@ DEF_FUNCTION_TYPE_1 (BT_FN_LONGLONG_LONGLONG, BT_LONGLONG, BT_LONGLONG)\n DEF_FUNCTION_TYPE_1 (BT_FN_INTMAX_INTMAX, BT_INTMAX, BT_INTMAX)\n DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT_FLOAT, BT_FLOAT, BT_FLOAT)\n DEF_FUNCTION_TYPE_1 (BT_FN_DOUBLE_DOUBLE, BT_DOUBLE, BT_DOUBLE)\n-DEF_FUNCTION_TYPE_1 (BT_FN_LONGDOUBLE_LONGDOUBLE, \n-\t             BT_LONGDOUBLE, BT_LONGDOUBLE)\n-DEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT, \n+DEF_FUNCTION_TYPE_1 (BT_FN_LONGDOUBLE_LONGDOUBLE,\n+\t\t     BT_LONGDOUBLE, BT_LONGDOUBLE)\n+DEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT,\n \t\t     BT_COMPLEX_FLOAT, BT_COMPLEX_FLOAT)\n-DEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE, \n+DEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE,\n \t\t     BT_COMPLEX_DOUBLE, BT_COMPLEX_DOUBLE)\n-DEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, \n-\t             BT_COMPLEX_LONGDOUBLE, BT_COMPLEX_LONGDOUBLE)\n-DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT_COMPLEX_FLOAT, \n-                     BT_FLOAT, BT_COMPLEX_FLOAT)\n+DEF_FUNCTION_TYPE_1 (BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE,\n+\t\t     BT_COMPLEX_LONGDOUBLE, BT_COMPLEX_LONGDOUBLE)\n+DEF_FUNCTION_TYPE_1 (BT_FN_FLOAT_COMPLEX_FLOAT,\n+\t\t     BT_FLOAT, BT_COMPLEX_FLOAT)\n DEF_FUNCTION_TYPE_1 (BT_FN_DOUBLE_COMPLEX_DOUBLE,\n-                     BT_DOUBLE, BT_COMPLEX_DOUBLE)\n+\t\t     BT_DOUBLE, BT_COMPLEX_DOUBLE)\n DEF_FUNCTION_TYPE_1 (BT_FN_LONGDOUBLE_COMPLEX_LONGDOUBLE,\n-                     BT_LONGDOUBLE, BT_COMPLEX_LONGDOUBLE)\n+\t\t     BT_LONGDOUBLE, BT_COMPLEX_LONGDOUBLE)\n DEF_FUNCTION_TYPE_1 (BT_FN_PTR_UINT, BT_PTR, BT_UINT)\n DEF_FUNCTION_TYPE_1 (BT_FN_PTR_SIZE, BT_PTR, BT_SIZE)\n DEF_FUNCTION_TYPE_1 (BT_FN_INT_INT, BT_INT, BT_INT)\n@@ -207,25 +207,25 @@ DEF_FUNCTION_TYPE_1 (BT_FN_UINT_UINT, BT_UINT, BT_UINT)\n DEF_POINTER_TYPE (BT_PTR_FN_VOID_PTR, BT_FN_VOID_PTR)\n \n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTR_INT, BT_VOID, BT_PTR, BT_INT)\n-DEF_FUNCTION_TYPE_2 (BT_FN_STRING_STRING_CONST_STRING, \n-                     BT_STRING, BT_STRING, BT_CONST_STRING)\n+DEF_FUNCTION_TYPE_2 (BT_FN_STRING_STRING_CONST_STRING,\n+\t\t     BT_STRING, BT_STRING, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_2 (BT_FN_INT_CONST_STRING_CONST_STRING,\n-\t             BT_INT, BT_CONST_STRING, BT_CONST_STRING)\n+\t\t     BT_INT, BT_CONST_STRING, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_2 (BT_FN_STRING_CONST_STRING_CONST_STRING,\n \t\t     BT_STRING, BT_CONST_STRING, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_2 (BT_FN_SIZE_CONST_STRING_CONST_STRING,\n-\t             BT_SIZE, BT_CONST_STRING, BT_CONST_STRING)\n+\t\t     BT_SIZE, BT_CONST_STRING, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_2 (BT_FN_STRING_CONST_STRING_INT,\n-\t             BT_STRING, BT_CONST_STRING, BT_INT)\n+\t\t     BT_STRING, BT_CONST_STRING, BT_INT)\n DEF_FUNCTION_TYPE_2 (BT_FN_STRING_CONST_STRING_SIZE,\n-\t             BT_STRING, BT_CONST_STRING, BT_SIZE)\n+\t\t     BT_STRING, BT_CONST_STRING, BT_SIZE)\n DEF_FUNCTION_TYPE_2 (BT_FN_INT_CONST_STRING_FILEPTR,\n \t\t     BT_INT, BT_CONST_STRING, BT_FILEPTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_INT_INT_FILEPTR,\n \t\t     BT_INT, BT_INT, BT_FILEPTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTRMODE_PTR,\n \t\t     BT_VOID, BT_PTRMODE, BT_PTR)\n-DEF_FUNCTION_TYPE_2 (BT_FN_VOID_VALIST_REF_VALIST_ARG, \n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_VALIST_REF_VALIST_ARG,\n \t\t     BT_VOID, BT_VALIST_REF, BT_VALIST_ARG)\n DEF_FUNCTION_TYPE_2 (BT_FN_LONG_LONG_LONG,\n \t\t     BT_LONG, BT_LONG, BT_LONG)\n@@ -277,12 +277,12 @@ DEF_FUNCTION_TYPE_2 (BT_FN_INT_CONST_STRING_VALIST_ARG,\n \t\t     BT_INT, BT_CONST_STRING, BT_VALIST_ARG)\n DEF_FUNCTION_TYPE_2 (BT_FN_PTR_SIZE_SIZE,\n \t\t     BT_PTR, BT_SIZE, BT_SIZE)\n-DEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT_COMPLEX_FLOAT, \n+DEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_FLOAT_COMPLEX_FLOAT_COMPLEX_FLOAT,\n \t\t     BT_COMPLEX_FLOAT, BT_COMPLEX_FLOAT, BT_COMPLEX_FLOAT)\n-DEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE_COMPLEX_DOUBLE, \n+DEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE_COMPLEX_DOUBLE,\n \t\t     BT_COMPLEX_DOUBLE, BT_COMPLEX_DOUBLE, BT_COMPLEX_DOUBLE)\n-DEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, \n-\t             BT_COMPLEX_LONGDOUBLE, BT_COMPLEX_LONGDOUBLE, BT_COMPLEX_LONGDOUBLE)\n+DEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE,\n+\t\t     BT_COMPLEX_LONGDOUBLE, BT_COMPLEX_LONGDOUBLE, BT_COMPLEX_LONGDOUBLE)\n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTR_PTR, BT_VOID, BT_PTR, BT_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_INT_CONST_STRING_PTR_CONST_STRING,\n \t\t     BT_INT, BT_CONST_STRING, BT_PTR_CONST_STRING)\n@@ -302,9 +302,9 @@ DEF_FUNCTION_TYPE_3 (BT_FN_INT_CONST_STRING_CONST_STRING_SIZE,\n DEF_FUNCTION_TYPE_3 (BT_FN_PTR_PTR_CONST_PTR_SIZE,\n \t\t     BT_PTR, BT_PTR, BT_CONST_PTR, BT_SIZE)\n DEF_FUNCTION_TYPE_3 (BT_FN_INT_CONST_PTR_CONST_PTR_SIZE,\n-\t             BT_INT, BT_CONST_PTR, BT_CONST_PTR, BT_SIZE)\n+\t\t     BT_INT, BT_CONST_PTR, BT_CONST_PTR, BT_SIZE)\n DEF_FUNCTION_TYPE_3 (BT_FN_PTR_PTR_INT_SIZE,\n-\t             BT_PTR, BT_PTR, BT_INT, BT_SIZE)\n+\t\t     BT_PTR, BT_PTR, BT_INT, BT_SIZE)\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_PTR_INT_INT,\n \t\t     BT_VOID, BT_PTR, BT_INT, BT_INT)\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_CONST_PTR_PTR_SIZE,\n@@ -401,15 +401,15 @@ DEF_FUNCTION_TYPE_VAR_0 (BT_FN_VOID_VAR, BT_VOID)\n DEF_FUNCTION_TYPE_VAR_0 (BT_FN_INT_VAR, BT_INT)\n DEF_FUNCTION_TYPE_VAR_0 (BT_FN_PTR_VAR, BT_PTR)\n \n-DEF_FUNCTION_TYPE_VAR_1 (BT_FN_VOID_VALIST_REF_VAR, \n+DEF_FUNCTION_TYPE_VAR_1 (BT_FN_VOID_VALIST_REF_VAR,\n \t\t\t BT_VOID, BT_VALIST_REF)\n DEF_FUNCTION_TYPE_VAR_1 (BT_FN_VOID_CONST_PTR_VAR,\n \t\t\t BT_VOID, BT_CONST_PTR)\n DEF_FUNCTION_TYPE_VAR_1 (BT_FN_INT_CONST_STRING_VAR,\n-\t                 BT_INT, BT_CONST_STRING)\n+\t\t\t BT_INT, BT_CONST_STRING)\n \n DEF_FUNCTION_TYPE_VAR_2 (BT_FN_INT_FILEPTR_CONST_STRING_VAR,\n-\t                 BT_INT, BT_FILEPTR, BT_CONST_STRING)\n+\t\t\t BT_INT, BT_FILEPTR, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_VAR_2 (BT_FN_INT_STRING_CONST_STRING_VAR,\n \t\t\t BT_INT, BT_STRING, BT_CONST_STRING)\n DEF_FUNCTION_TYPE_VAR_2 (BT_FN_INT_CONST_STRING_CONST_STRING_VAR,"}, {"sha": "181f7c1cc5d24241e306b019b1b9a5a6d4a91aa8", "filename": "gcc/builtins.c", "status": "modified", "additions": 104, "deletions": 104, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -279,7 +279,7 @@ get_pointer_alignment (tree exp, unsigned int max_align)\n \t  while (handled_component_p (exp))\n \t    {\n \t      /* Fields in a structure can be packed, honor DECL_ALIGN\n-\t\t of the FIELD_DECL.  For all other references the conservative \n+\t\t of the FIELD_DECL.  For all other references the conservative\n \t\t alignment is the element type alignment.  */\n \t      if (TREE_CODE (exp) == COMPONENT_REF)\n \t\tinner = MIN (inner, DECL_ALIGN (TREE_OPERAND (exp, 1)));\n@@ -517,7 +517,7 @@ expand_builtin_return_addr (enum built_in_function fndecl_code, int count)\n      we must disable frame pointer elimination.  */\n   if (count == 0)\n     tem = frame_pointer_rtx;\n-  else \n+  else\n     {\n       tem = hard_frame_pointer_rtx;\n \n@@ -2470,7 +2470,7 @@ expand_powi_1 (enum machine_mode mode, unsigned HOST_WIDE_INT n, rtx *cache)\n   if (n < POWI_TABLE_SIZE)\n     {\n       if (cache[n])\n-        return cache[n];\n+\treturn cache[n];\n \n       target = gen_reg_rtx (mode);\n       cache[n] = target;\n@@ -2864,7 +2864,7 @@ expand_builtin_memcpy (tree exp, rtx target, enum machine_mode mode)\n \treturn 0;\n \n       /* If either SRC is not a pointer type, don't do this\n-         operation in-line.  */\n+\t operation in-line.  */\n       if (src_align == 0)\n \treturn 0;\n \n@@ -2947,9 +2947,9 @@ expand_builtin_mempcpy (tree arglist, tree type, rtx target, enum machine_mode m\n \n       if (result)\n \treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n-      \n+\n       /* If either SRC or DEST is not a pointer type, don't do this\n-         operation in-line.  */\n+\t operation in-line.  */\n       if (dest_align == 0 || src_align == 0)\n \treturn 0;\n \n@@ -3027,14 +3027,14 @@ expand_builtin_memmove (tree arglist, tree type, rtx target,\n \treturn 0;\n \n       /* If either SRC is not a pointer type, don't do this\n-         operation in-line.  */\n+\t operation in-line.  */\n       if (src_align == 0)\n \treturn 0;\n \n       /* If src is categorized for a readonly section we can use\n \t normal memcpy.  */\n       if (readonly_data_expr (src))\n-        {\n+\t{\n \t  tree fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n \t  if (!fn)\n \t    return 0;\n@@ -3047,12 +3047,12 @@ expand_builtin_memmove (tree arglist, tree type, rtx target,\n       /* If length is 1 and we can expand memcpy call inline,\n \t it is ok to use memcpy as well.  */\n       if (integer_onep (len))\n-        {\n+\t{\n \t  rtx ret = expand_builtin_mempcpy (arglist, type, target, mode,\n \t\t\t\t\t    /*endp=*/0);\n \t  if (ret)\n \t    return ret;\n-        }\n+\t}\n \n       /* Otherwise, call the normal function.  */\n       return 0;\n@@ -3206,9 +3206,9 @@ expand_builtin_stpcpy (tree exp, rtx target, enum machine_mode mode)\n       rtx ret;\n \n       /* Ensure we get an actual string whose length can be evaluated at\n-         compile-time, not an expression containing a string.  This is\n-         because the latter will potentially produce pessimized code\n-         when used to produce the return value.  */\n+\t compile-time, not an expression containing a string.  This is\n+\t because the latter will potentially produce pessimized code\n+\t when used to produce the return value.  */\n       src = TREE_VALUE (TREE_CHAIN (arglist));\n       if (! c_getstr (src) || ! (len = c_strlen (src, 0)))\n \treturn expand_movstr (TREE_VALUE (arglist),\n@@ -3232,7 +3232,7 @@ expand_builtin_stpcpy (tree exp, rtx target, enum machine_mode mode)\n \n \t  if (GET_CODE (len_rtx) == CONST_INT)\n \t    {\n-\t      ret = expand_builtin_strcpy (get_callee_fndecl (exp), \n+\t      ret = expand_builtin_strcpy (get_callee_fndecl (exp),\n \t\t\t\t\t   arglist, target, mode);\n \n \t      if (ret)\n@@ -3292,7 +3292,7 @@ expand_builtin_strncpy (tree exp, rtx target, enum machine_mode mode)\n       tree slen = c_strlen (TREE_VALUE (TREE_CHAIN (arglist)), 1);\n       tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n       tree result = fold_builtin_strncpy (fndecl, arglist, slen);\n-      \n+\n       if (result)\n \treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n \n@@ -3303,7 +3303,7 @@ expand_builtin_strncpy (tree exp, rtx target, enum machine_mode mode)\n       slen = size_binop (PLUS_EXPR, slen, ssize_int (1));\n \n       /* We're required to pad with trailing zeros if the requested\n-         len is greater than strlen(s2)+1.  In that case try to\n+\t len is greater than strlen(s2)+1.  In that case try to\n \t use store_by_pieces, if it fails, punt.  */\n       if (tree_int_cst_lt (slen, len))\n \t{\n@@ -3436,12 +3436,12 @@ expand_builtin_memset (tree arglist, rtx target, enum machine_mode mode,\n \t      && can_store_by_pieces (tree_low_cst (len, 1),\n \t\t\t\t      builtin_memset_read_str, &c, dest_align))\n \t    {\n-\t      val_rtx = force_reg (TYPE_MODE (unsigned_char_type_node), \n+\t      val_rtx = force_reg (TYPE_MODE (unsigned_char_type_node),\n \t\t\t\t   val_rtx);\n \t      store_by_pieces (dest_mem, tree_low_cst (len, 1),\n \t\t\t       builtin_memset_gen_str, val_rtx, dest_align, 0);\n \t    }\n-\t  else if (!set_storage_via_setmem (dest_mem, len_rtx, val_rtx, \n+\t  else if (!set_storage_via_setmem (dest_mem, len_rtx, val_rtx,\n \t\t\t\t\t    dest_align))\n \t    goto do_libcall;\n \n@@ -3660,7 +3660,7 @@ expand_builtin_strcmp (tree exp, rtx target, enum machine_mode mode)\n       rtx arg1_rtx, arg2_rtx;\n       rtx result, insn = NULL_RTX;\n       tree fndecl, fn;\n-      \n+\n       tree arg1 = TREE_VALUE (arglist);\n       tree arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n       int arg1_align\n@@ -3683,7 +3683,7 @@ expand_builtin_strcmp (tree exp, rtx target, enum machine_mode mode)\n       /* Try to call cmpstrsi.  */\n       if (HAVE_cmpstrsi)\n \t{\n-\t  enum machine_mode insn_mode \n+\t  enum machine_mode insn_mode\n \t    = insn_data[(int) CODE_FOR_cmpstrsi].operand[0].mode;\n \n \t  /* Make a place to write the result of the instruction.  */\n@@ -3699,12 +3699,12 @@ expand_builtin_strcmp (tree exp, rtx target, enum machine_mode mode)\n #endif\n #ifdef HAVE_cmpstrnsi\n       /* Try to determine at least one length and call cmpstrnsi.  */\n-      if (!insn && HAVE_cmpstrnsi) \n+      if (!insn && HAVE_cmpstrnsi)\n \t{\n \t  tree len;\n \t  rtx arg3_rtx;\n \n-\t  enum machine_mode insn_mode \n+\t  enum machine_mode insn_mode\n \t    = insn_data[(int) CODE_FOR_cmpstrnsi].operand[0].mode;\n \t  tree len1 = c_strlen (arg1, 1);\n \t  tree len2 = c_strlen (arg2, 1);\n@@ -3933,9 +3933,9 @@ expand_builtin_strcat (tree fndecl, tree arglist, rtx target, enum machine_mode\n       const char *p = c_getstr (src);\n \n       /* If the string length is zero, return the dst parameter.  */\n-      if (p && *p == '\\0')\t  \n+      if (p && *p == '\\0')\n \treturn expand_expr (dst, target, mode, EXPAND_NORMAL);\n-      \n+\n       if (!optimize_size)\n \t{\n \t  /* See if we can store by pieces into (dst + strlen(dst)).  */\n@@ -3947,7 +3947,7 @@ expand_builtin_strcat (tree fndecl, tree arglist, rtx target, enum machine_mode\n \t  newsrc = builtin_save_expr (src);\n \t  if (newsrc != src)\n \t    arglist = build_tree_list (NULL_TREE, newsrc);\n-\t  else \n+\t  else\n \t    arglist = TREE_CHAIN (arglist); /* Reusing arglist if safe.  */\n \n \t  dst = builtin_save_expr (dst);\n@@ -3970,12 +3970,12 @@ expand_builtin_strcat (tree fndecl, tree arglist, rtx target, enum machine_mode\n \t      end_sequence (); /* Stop sequence.  */\n \t      return 0;\n \t    }\n-\t  \n+\n \t  /* Output the entire sequence.  */\n \t  insns = get_insns ();\n \t  end_sequence ();\n \t  emit_insn (insns);\n-\t  \n+\n \t  return expand_expr (dst, target, mode, EXPAND_NORMAL);\n \t}\n \n@@ -4344,7 +4344,7 @@ gimplify_va_arg_expr (tree *expr_p, tree *pre_p, tree *post_p)\n     {\n       /* If va_list is an array type, the argument may have decayed\n \t to a pointer type, e.g. by being passed to another function.\n-         In that case, unwrap both types so that we can compare the\n+\t In that case, unwrap both types so that we can compare the\n \t underlying records.  */\n       if (TREE_CODE (have_va_type) == ARRAY_TYPE\n \t  || POINTER_TYPE_P (have_va_type))\n@@ -4394,7 +4394,7 @@ gimplify_va_arg_expr (tree *expr_p, tree *pre_p, tree *post_p)\n   else\n     {\n       /* Make it easier for the backends by protecting the valist argument\n-         from multiple evaluations.  */\n+\t from multiple evaluations.  */\n       if (TREE_CODE (va_list_type_node) == ARRAY_TYPE)\n \t{\n \t  /* For this case, the backends will be expecting a pointer to\n@@ -4750,7 +4750,7 @@ expand_builtin_expect_jump (tree exp, rtx if_false_label, rtx if_true_label)\n \t\t     probabilities.  */\n \t\t  if (integer_zerop (arg1))\n \t\t    taken = 1 - taken;\n-\t          predict_insn_def (insn, PRED_BUILTIN_EXPECT, taken);\n+\t\t  predict_insn_def (insn, PRED_BUILTIN_EXPECT, taken);\n \t\t}\n \t    }\n \n@@ -4881,12 +4881,12 @@ expand_builtin_printf (tree exp, rtx target, enum machine_mode mode,\n \n   if (!init_target_chars())\n     return 0;\n-  \n+\n   /* If the format specifier was \"%s\\n\", call __builtin_puts(arg).  */\n   if (strcmp (fmt_str, target_percent_s_newline) == 0)\n     {\n       if (! arglist\n-          || ! POINTER_TYPE_P (TREE_TYPE (TREE_VALUE (arglist)))\n+\t  || ! POINTER_TYPE_P (TREE_TYPE (TREE_VALUE (arglist)))\n \t  || TREE_CHAIN (arglist))\n \treturn 0;\n       fn = fn_puts;\n@@ -4904,7 +4904,7 @@ expand_builtin_printf (tree exp, rtx target, enum machine_mode mode,\n     {\n       /* We can't handle anything else with % args or %% ... yet.  */\n       if (strchr (fmt_str, target_percent))\n-        return 0;\n+\treturn 0;\n \n       if (arglist)\n \treturn 0;\n@@ -4960,7 +4960,7 @@ expand_builtin_printf (tree exp, rtx target, enum machine_mode mode,\n    call.  */\n static rtx\n expand_builtin_fprintf (tree exp, rtx target, enum machine_mode mode,\n-\t\t        bool unlocked)\n+\t\t\tbool unlocked)\n {\n   tree arglist = TREE_OPERAND (exp, 1);\n   /* If we're using an unlocked function, assume the other unlocked\n@@ -4997,12 +4997,12 @@ expand_builtin_fprintf (tree exp, rtx target, enum machine_mode mode,\n \n   if (!init_target_chars())\n     return 0;\n-  \n+\n   /* If the format specifier was \"%s\", call __builtin_fputs(arg,fp).  */\n   if (strcmp (fmt_str, target_percent_s) == 0)\n     {\n       if (! arglist\n-          || ! POINTER_TYPE_P (TREE_TYPE (TREE_VALUE (arglist)))\n+\t  || ! POINTER_TYPE_P (TREE_TYPE (TREE_VALUE (arglist)))\n \t  || TREE_CHAIN (arglist))\n \treturn 0;\n       arg = TREE_VALUE (arglist);\n@@ -5026,7 +5026,7 @@ expand_builtin_fprintf (tree exp, rtx target, enum machine_mode mode,\n     {\n       /* We can't handle anything else with % args or %% ... yet.  */\n       if (strchr (fmt_str, target_percent))\n-        return 0;\n+\treturn 0;\n \n       if (arglist)\n \treturn 0;\n@@ -5296,9 +5296,9 @@ expand_builtin_signbit (tree exp, rtx target)\n       imode = word_mode;\n       /* Handle targets with different FP word orders.  */\n       if (FLOAT_WORDS_BIG_ENDIAN)\n-        word = (GET_MODE_BITSIZE (fmode) - bitpos) / BITS_PER_WORD;\n+\tword = (GET_MODE_BITSIZE (fmode) - bitpos) / BITS_PER_WORD;\n       else\n-        word = bitpos / BITS_PER_WORD;\n+\tword = bitpos / BITS_PER_WORD;\n       temp = operand_subword_force (temp, word, fmode);\n       bitpos = bitpos % BITS_PER_WORD;\n     }\n@@ -5334,7 +5334,7 @@ expand_builtin_signbit (tree exp, rtx target)\n   else\n     {\n       /* Perform a logical right shift to place the signbit in the least\n-         significant bit, then truncate the result to the desired mode\n+\t significant bit, then truncate the result to the desired mode\n \t and mask just this bit.  */\n       temp = expand_shift (RSHIFT_EXPR, imode, temp,\n \t\t\t   build_int_cst (NULL_TREE, bitpos), NULL_RTX, 1);\n@@ -5451,7 +5451,7 @@ get_builtin_sync_mem (tree loc, enum machine_mode mode)\n }\n \n /* Expand the __sync_xxx_and_fetch and __sync_fetch_and_xxx intrinsics.\n-   ARGLIST is the operands list to the function.  CODE is the rtx code \n+   ARGLIST is the operands list to the function.  CODE is the rtx code\n    that corresponds to the arithmetic or logical operation from the name;\n    an exception here is that NOT actually means NAND.  TARGET is an optional\n    place for us to store the results; AFTER is true if this is the\n@@ -5650,7 +5650,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n     CASE_FLT_FN (BUILT_IN_FABS):\n       target = expand_builtin_fabs (arglist, target, subtarget);\n       if (target)\n-        return target;\n+\treturn target;\n       break;\n \n     CASE_FLT_FN (BUILT_IN_COPYSIGN):\n@@ -5794,7 +5794,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n       /* Return the address of the first anonymous stack arg.  */\n     case BUILT_IN_NEXT_ARG:\n       if (fold_builtin_next_arg (arglist))\n-        return const0_rtx;\n+\treturn const0_rtx;\n       return expand_builtin_next_arg ();\n \n     case BUILT_IN_CLASSIFY_TYPE:\n@@ -6660,7 +6660,7 @@ integer_valued_real_p (tree t)\n     case REAL_CST:\n       if (! TREE_CONSTANT_OVERFLOW (t))\n       {\n-        REAL_VALUE_TYPE c, cint;\n+\tREAL_VALUE_TYPE c, cint;\n \n \tc = TREE_REAL_CST (t);\n \treal_trunc (&cint, TYPE_MODE (TREE_TYPE (t)), &c);\n@@ -6958,7 +6958,7 @@ fold_builtin_cbrt (tree arglist, tree type)\n     {\n       /* Optimize cbrt(expN(x)) -> expN(x/3).  */\n       if (BUILTIN_EXPONENT_P (fcode))\n-        {\n+\t{\n \t  tree expfn = TREE_OPERAND (TREE_OPERAND (arg, 0), 0);\n \t  const REAL_VALUE_TYPE third_trunc =\n \t    real_value_truncate (TYPE_MODE (type), dconstthird);\n@@ -6971,7 +6971,7 @@ fold_builtin_cbrt (tree arglist, tree type)\n \n       /* Optimize cbrt(sqrt(x)) -> pow(x,1/6).  */\n       if (BUILTIN_SQRT_P (fcode))\n-        {\n+\t{\n \t  tree powfn = mathfn_built_in (type, BUILT_IN_POW);\n \n \t  if (powfn)\n@@ -6991,17 +6991,17 @@ fold_builtin_cbrt (tree arglist, tree type)\n \n       /* Optimize cbrt(cbrt(x)) -> pow(x,1/9) iff x is nonnegative.  */\n       if (BUILTIN_CBRT_P (fcode))\n-        {\n+\t{\n \t  tree arg0 = TREE_VALUE (TREE_OPERAND (arg, 1));\n \t  if (tree_expr_nonnegative_p (arg0))\n \t    {\n \t      tree powfn = mathfn_built_in (type, BUILT_IN_POW);\n \n \t      if (powfn)\n-\t        {\n+\t\t{\n \t\t  tree tree_root;\n \t\t  REAL_VALUE_TYPE dconstroot;\n-\t      \n+\n \t\t  real_arithmetic (&dconstroot, MULT_EXPR, &dconstthird, &dconstthird);\n \t\t  dconstroot = real_value_truncate (TYPE_MODE (type), dconstroot);\n \t\t  tree_root = build_real (type, dconstroot);\n@@ -7011,11 +7011,11 @@ fold_builtin_cbrt (tree arglist, tree type)\n \t\t}\n \t    }\n \t}\n-      \n+\n       /* Optimize cbrt(pow(x,y)) -> pow(x,y/3) iff x is nonnegative.  */\n       if (fcode == BUILT_IN_POW || fcode == BUILT_IN_POWF\n \t  || fcode == BUILT_IN_POWL)\n-        {\n+\t{\n \t  tree arg00 = TREE_VALUE (TREE_OPERAND (arg, 1));\n \t  tree arg01 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg, 1)));\n \t  if (tree_expr_nonnegative_p (arg00))\n@@ -7408,11 +7408,11 @@ real_dconstp (tree expr, const REAL_VALUE_TYPE *value)\n   STRIP_NOPS (expr);\n \n   return ((TREE_CODE (expr) == REAL_CST\n-           && ! TREE_CONSTANT_OVERFLOW (expr)\n-           && REAL_VALUES_EQUAL (TREE_REAL_CST (expr), *value))\n-          || (TREE_CODE (expr) == COMPLEX_CST\n-              && real_dconstp (TREE_REALPART (expr), value)\n-              && real_zerop (TREE_IMAGPART (expr))));\n+\t   && ! TREE_CONSTANT_OVERFLOW (expr)\n+\t   && REAL_VALUES_EQUAL (TREE_REAL_CST (expr), *value))\n+\t  || (TREE_CODE (expr) == COMPLEX_CST\n+\t      && real_dconstp (TREE_REALPART (expr), value)\n+\t      && real_zerop (TREE_IMAGPART (expr))));\n }\n \n /* A subroutine of fold_builtin to fold the various logarithmic\n@@ -7434,10 +7434,10 @@ fold_builtin_logarithm (tree fndecl, tree arglist,\n \treturn build_real (type, dconst0);\n \n       /* Optimize logN(N) = 1.0.  If N can't be truncated to MODE\n-         exactly, then only do this if flag_unsafe_math_optimizations.  */\n+\t exactly, then only do this if flag_unsafe_math_optimizations.  */\n       if (exact_real_truncate (TYPE_MODE (type), value)\n \t  || flag_unsafe_math_optimizations)\n-        {\n+\t{\n \t  const REAL_VALUE_TYPE value_truncate =\n \t    real_value_truncate (TYPE_MODE (type), *value);\n \t  if (real_dconstp (arg, &value_truncate))\n@@ -7458,10 +7458,10 @@ fold_builtin_logarithm (tree fndecl, tree arglist,\n \treturn fold_convert (type, TREE_VALUE (TREE_OPERAND (arg, 1)));\n \n       /* Optimize logN(func()) for various exponential functions.  We\n-         want to determine the value \"x\" and the power \"exponent\" in\n-         order to transform logN(x**exponent) into exponent*logN(x).  */\n+\t want to determine the value \"x\" and the power \"exponent\" in\n+\t order to transform logN(x**exponent) into exponent*logN(x).  */\n       if (flag_unsafe_math_optimizations)\n-        {\n+\t{\n \t  tree exponent = 0, x = 0;\n \n \t  switch (fcode)\n@@ -7606,7 +7606,7 @@ fold_builtin_pow (tree fndecl, tree arglist, tree type)\n \n       /* Optimize pow(expN(x),y) = expN(x*y).  */\n       if (BUILTIN_EXPONENT_P (fcode))\n-        {\n+\t{\n \t  tree expfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n \t  tree arg = TREE_VALUE (TREE_OPERAND (arg0, 1));\n \t  arg = fold_build2 (MULT_EXPR, type, arg, arg1);\n@@ -7616,7 +7616,7 @@ fold_builtin_pow (tree fndecl, tree arglist, tree type)\n \n       /* Optimize pow(sqrt(x),y) = pow(x,y*0.5).  */\n       if (BUILTIN_SQRT_P (fcode))\n-        {\n+\t{\n \t  tree narg0 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n \t  tree narg1 = fold_build2 (MULT_EXPR, type, arg1,\n \t\t\t\t    build_real (type, dconsthalf));\n@@ -7628,7 +7628,7 @@ fold_builtin_pow (tree fndecl, tree arglist, tree type)\n \n       /* Optimize pow(cbrt(x),y) = pow(x,y/3) iff x is nonnegative.  */\n       if (BUILTIN_CBRT_P (fcode))\n-        {\n+\t{\n \t  tree arg = TREE_VALUE (TREE_OPERAND (arg0, 1));\n \t  if (tree_expr_nonnegative_p (arg))\n \t    {\n@@ -7641,11 +7641,11 @@ fold_builtin_pow (tree fndecl, tree arglist, tree type)\n \t      return build_function_call_expr (fndecl, arglist);\n \t    }\n \t}\n-      \n+\n       /* Optimize pow(pow(x,y),z) = pow(x,y*z).  */\n       if (fcode == BUILT_IN_POW || fcode == BUILT_IN_POWF\n \t   || fcode == BUILT_IN_POWL)\n-        {\n+\t{\n \t  tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n \t  tree arg01 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg0, 1)));\n \t  tree narg1 = fold_build2 (MULT_EXPR, type, arg01, arg1);\n@@ -7724,7 +7724,7 @@ fold_builtin_exponent (tree fndecl, tree arglist,\n \n       /* Optimize expN(1.0) = N.  */\n       if (real_onep (arg))\n-        {\n+\t{\n \t  REAL_VALUE_TYPE cst;\n \n \t  real_convert (&cst, TYPE_MODE (type), value);\n@@ -7735,7 +7735,7 @@ fold_builtin_exponent (tree fndecl, tree arglist,\n       if (flag_unsafe_math_optimizations\n \t  && TREE_CODE (arg) == REAL_CST\n \t  && ! TREE_CONSTANT_OVERFLOW (arg))\n-        {\n+\t{\n \t  REAL_VALUE_TYPE cint;\n \t  REAL_VALUE_TYPE c;\n \t  HOST_WIDE_INT n;\n@@ -7755,7 +7755,7 @@ fold_builtin_exponent (tree fndecl, tree arglist,\n \n       /* Optimize expN(logN(x)) = x.  */\n       if (flag_unsafe_math_optimizations)\n-        {\n+\t{\n \t  const enum built_in_function fcode = builtin_mathfn_code (arg);\n \n \t  if ((value == &dconste\n@@ -7823,14 +7823,14 @@ fold_builtin_mempcpy (tree arglist, tree type, int endp)\n \n       /* If SRC and DEST are the same (and not volatile), return DEST+LEN.  */\n       if (operand_equal_p (src, dest, 0))\n-        {\n+\t{\n \t  if (endp == 0)\n \t    return omit_one_operand (type, dest, len);\n \n \t  if (endp == 2)\n \t    len = fold_build2 (MINUS_EXPR, TREE_TYPE (len), len,\n \t\t\t       ssize_int (1));\n-      \n+\n \t  len = fold_convert (TREE_TYPE (dest), len);\n \t  len = fold_build2 (PLUS_EXPR, TREE_TYPE (dest), dest, len);\n \t  return fold_convert (type, len);\n@@ -8289,9 +8289,9 @@ fold_builtin_isascii (tree arglist)\n \t\t\t arg, integer_zero_node);\n \n       if (in_gimple_form && !TREE_CONSTANT (arg))\n-        return NULL_TREE;\n+\treturn NULL_TREE;\n       else\n-        return arg;\n+\treturn arg;\n     }\n }\n \n@@ -8337,9 +8337,9 @@ fold_builtin_isdigit (tree arglist)\n       arg = fold_build2 (LE_EXPR, integer_type_node, arg,\n \t\t\t build_int_cst (unsigned_type_node, 9));\n       if (in_gimple_form && !TREE_CONSTANT (arg))\n-        return NULL_TREE;\n+\treturn NULL_TREE;\n       else\n-        return arg;\n+\treturn arg;\n     }\n }\n \n@@ -8415,7 +8415,7 @@ fold_builtin_classify (tree fndecl, tree arglist, int builtin_index)\n     {\n     case BUILT_IN_ISINF:\n       if (!MODE_HAS_INFINITIES (TYPE_MODE (TREE_TYPE (arg))))\n-        return omit_one_operand (type, integer_zero_node, arg);\n+\treturn omit_one_operand (type, integer_zero_node, arg);\n \n       if (TREE_CODE (arg) == REAL_CST)\n \t{\n@@ -8431,8 +8431,8 @@ fold_builtin_classify (tree fndecl, tree arglist, int builtin_index)\n \n     case BUILT_IN_FINITE:\n       if (!MODE_HAS_NANS (TYPE_MODE (TREE_TYPE (arg)))\n-          && !MODE_HAS_INFINITIES (TYPE_MODE (TREE_TYPE (arg))))\n-        return omit_one_operand (type, integer_zero_node, arg);\n+\t  && !MODE_HAS_INFINITIES (TYPE_MODE (TREE_TYPE (arg))))\n+\treturn omit_one_operand (type, integer_zero_node, arg);\n \n       if (TREE_CODE (arg) == REAL_CST)\n \t{\n@@ -8445,7 +8445,7 @@ fold_builtin_classify (tree fndecl, tree arglist, int builtin_index)\n \n     case BUILT_IN_ISNAN:\n       if (!MODE_HAS_NANS (TYPE_MODE (TREE_TYPE (arg))))\n-        return omit_one_operand (type, integer_zero_node, arg);\n+\treturn omit_one_operand (type, integer_zero_node, arg);\n \n       if (TREE_CODE (arg) == REAL_CST)\n \t{\n@@ -8500,13 +8500,13 @@ fold_builtin_unordered_cmp (tree fndecl, tree arglist,\n \n   arg0 = TREE_VALUE (arglist);\n   arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n-  \n+\n   type0 = TREE_TYPE (arg0);\n   type1 = TREE_TYPE (arg1);\n-  \n+\n   code0 = TREE_CODE (type0);\n   code1 = TREE_CODE (type1);\n-  \n+\n   if (code0 == REAL_TYPE && code1 == REAL_TYPE)\n     /* Choose the wider of two real types.  */\n     cmp_type = TYPE_PRECISION (type0) >= TYPE_PRECISION (type1)\n@@ -8521,7 +8521,7 @@ fold_builtin_unordered_cmp (tree fndecl, tree arglist,\n \t\t IDENTIFIER_POINTER (DECL_NAME (fndecl)));\n       return error_mark_node;\n     }\n-  \n+\n   arg0 = fold_convert (cmp_type, arg0);\n   arg1 = fold_convert (cmp_type, arg1);\n \n@@ -8645,13 +8645,13 @@ fold_builtin_1 (tree fndecl, tree arglist, bool ignore)\n \n     CASE_FLT_FN (BUILT_IN_CREAL):\n       if (validate_arglist (arglist, COMPLEX_TYPE, VOID_TYPE))\n-        return non_lvalue (fold_build1 (REALPART_EXPR, type,\n+\treturn non_lvalue (fold_build1 (REALPART_EXPR, type,\n \t\t\t\t\tTREE_VALUE (arglist)));\n       break;\n \n     CASE_FLT_FN (BUILT_IN_CIMAG):\n       if (validate_arglist (arglist, COMPLEX_TYPE, VOID_TYPE))\n-        return non_lvalue (fold_build1 (IMAGPART_EXPR, type,\n+\treturn non_lvalue (fold_build1 (IMAGPART_EXPR, type,\n \t\t\t\t\tTREE_VALUE (arglist)));\n       break;\n \n@@ -8739,7 +8739,7 @@ fold_builtin_1 (tree fndecl, tree arglist, bool ignore)\n     CASE_FLT_FN (BUILT_IN_LLCEIL):\n     CASE_FLT_FN (BUILT_IN_LFLOOR):\n     CASE_FLT_FN (BUILT_IN_LLFLOOR):\n-    CASE_FLT_FN (BUILT_IN_LROUND):   \n+    CASE_FLT_FN (BUILT_IN_LROUND):\n     CASE_FLT_FN (BUILT_IN_LLROUND):\n       return fold_builtin_int_roundingfn (fndecl, arglist);\n \n@@ -9320,10 +9320,10 @@ fold_builtin_strncat (tree arglist)\n       /* If the requested length is zero, or the src parameter string\n \t length is zero, return the dst parameter.  */\n       if (integer_zerop (len) || (p && *p == '\\0'))\n-        return omit_two_operands (TREE_TYPE (dst), dst, src, len);\n+\treturn omit_two_operands (TREE_TYPE (dst), dst, src, len);\n \n       /* If the requested len is greater than or equal to the string\n-         length, call strcat.  */\n+\t length, call strcat.  */\n       if (TREE_CODE (len) == INTEGER_CST && p\n \t  && compare_tree_int (len, strlen (p)) >= 0)\n \t{\n@@ -9561,18 +9561,18 @@ fold_builtin_next_arg (tree arglist)\n   /* We use __builtin_va_start (ap, 0, 0) or __builtin_next_arg (0, 0)\n      when we checked the arguments and if needed issued a warning.  */\n   else if (!TREE_CHAIN (arglist)\n-           || !integer_zerop (TREE_VALUE (arglist))\n-           || !integer_zerop (TREE_VALUE (TREE_CHAIN (arglist)))\n-           || TREE_CHAIN (TREE_CHAIN (arglist)))\n+\t   || !integer_zerop (TREE_VALUE (arglist))\n+\t   || !integer_zerop (TREE_VALUE (TREE_CHAIN (arglist)))\n+\t   || TREE_CHAIN (TREE_CHAIN (arglist)))\n     {\n       tree last_parm = tree_last (DECL_ARGUMENTS (current_function_decl));\n       tree arg = TREE_VALUE (arglist);\n \n       if (TREE_CHAIN (arglist))\n-        {\n-          error (\"%<va_start%> used with too many arguments\");\n-          return true;\n-        }\n+\t{\n+\t  error (\"%<va_start%> used with too many arguments\");\n+\t  return true;\n+\t}\n \n       /* Strip off all nops for the sake of the comparison.  This\n \t is not quite the same as STRIP_NOPS.  It does more.\n@@ -9584,7 +9584,7 @@ fold_builtin_next_arg (tree arglist)\n \t     || TREE_CODE (arg) == INDIRECT_REF)\n \targ = TREE_OPERAND (arg, 0);\n       if (arg != last_parm)\n-        {\n+\t{\n \t  /* FIXME: Sometimes with the tree optimizers we can get the\n \t     not the last argument even though the user used the last\n \t     argument.  We just warn and set the arg to be the last\n@@ -9593,10 +9593,10 @@ fold_builtin_next_arg (tree arglist)\n \t  warning (0, \"second parameter of %<va_start%> not last named argument\");\n \t}\n       /* We want to verify the second parameter just once before the tree\n-         optimizers are run and then avoid keeping it in the tree,\n-         as otherwise we could warn even for correct code like:\n-         void foo (int i, ...)\n-         { va_list ap; i++; va_start (ap, i); va_end (ap); }  */\n+\t optimizers are run and then avoid keeping it in the tree,\n+\t as otherwise we could warn even for correct code like:\n+\t void foo (int i, ...)\n+\t { va_list ap; i++; va_start (ap, i); va_end (ap); }  */\n       TREE_VALUE (arglist) = integer_zero_node;\n       TREE_CHAIN (arglist) = build_tree_list (NULL, integer_zero_node);\n     }\n@@ -10167,7 +10167,7 @@ fold_builtin_stxcpy_chk (tree fndecl, tree arglist, tree maxlen, bool ignore,\n   /* If SRC and DEST are the same (and not volatile), return DEST.  */\n   if (fcode == BUILT_IN_STRCPY_CHK && operand_equal_p (src, dest, 0))\n     return fold_convert (TREE_TYPE (TREE_TYPE (fndecl)), dest);\n- \n+\n   if (! host_integerp (size, 1))\n     return 0;\n \n@@ -10628,7 +10628,7 @@ fold_builtin_printf (tree fndecl, tree arglist, bool ignore,\n \n   if (!init_target_chars())\n     return 0;\n-  \n+\n   if (strcmp (fmt_str, target_percent_s) == 0 || strchr (fmt_str, target_percent) == NULL)\n     {\n       const char *str;\n@@ -10789,7 +10789,7 @@ fold_builtin_fprintf (tree fndecl, tree arglist, bool ignore,\n \n   if (!init_target_chars())\n     return 0;\n-  \n+\n   /* If the format doesn't contain % args or %%, use strcpy.  */\n   if (strchr (fmt_str, target_percent) == NULL)\n     {\n@@ -10881,7 +10881,7 @@ init_target_chars (void)\n       target_percent_s_newline[1] = target_s;\n       target_percent_s_newline[2] = target_newline;\n       target_percent_s_newline[3] = '\\0';\n-      \n+\n       init = true;\n     }\n   return true;"}, {"sha": "2dcbd39d6d580fb9428fbd9643bfa4f09483e51a", "filename": "gcc/builtins.def", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -54,7 +54,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    exist when compiling in ANSI conformant mode.\n \n    ATTRs is an attribute list as defined in builtin-attrs.def that\n-   describes the attributes of this builtin function.  \n+   describes the attributes of this builtin function.\n \n    IMPLICIT specifies condition when the builtin can be produced by\n    compiler.  For instance C90 reserves floorf function, but does not\n@@ -71,21 +71,21 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #undef DEF_GCC_BUILTIN\n #define DEF_GCC_BUILTIN(ENUM, NAME, TYPE, ATTRS)\t\t\\\n   DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, BT_LAST,\t\\\n-               false, false, false, ATTRS, true, true)\n+\t       false, false, false, ATTRS, true, true)\n \n /* Like DEF_GCC_BUILTIN, except we don't prepend \"__builtin_\".  */\n #undef DEF_SYNC_BUILTIN\n #define DEF_SYNC_BUILTIN(ENUM, NAME, TYPE, ATTRS)\t\t\\\n   DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, TYPE, BT_LAST,\t\\\n-               false, false, false, ATTRS, true, true)\n+\t       false, false, false, ATTRS, true, true)\n \n /* A library builtin (like __builtin_strchr) is a builtin equivalent\n    of an ANSI/ISO standard library function.  In addition to the\n    `__builtin' version, we will create an ordinary version (e.g,\n    `strchr') as well.  If we cannot compute the answer using the\n    builtin function, we will fall back to the standard library\n    version.  */\n-#undef DEF_LIB_BUILTIN\t\t\t\t\t\n+#undef DEF_LIB_BUILTIN\n #define DEF_LIB_BUILTIN(ENUM, NAME, TYPE, ATTRS)\t\\\n   DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,\t\\\n \t       true, true, false, ATTRS, true, true)\n@@ -94,39 +94,39 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n    specified by ANSI/ISO C.  So, when we're being fully conformant we\n    ignore the version of these builtins that does not begin with\n    __builtin.  */\n-#undef DEF_EXT_LIB_BUILTIN\t\t\t\t\n+#undef DEF_EXT_LIB_BUILTIN\n #define DEF_EXT_LIB_BUILTIN(ENUM, NAME, TYPE, ATTRS)\t\\\n   DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,\t\\\n-   \t       true, true, true, ATTRS, false, true)\n+\t       true, true, true, ATTRS, false, true)\n \n /* Like DEF_LIB_BUILTIN, except that the function is only a part of\n    the standard in C94 or above.  */\n-#undef DEF_C94_BUILTIN\t\t\t\t\t\n+#undef DEF_C94_BUILTIN\n #define DEF_C94_BUILTIN(ENUM, NAME, TYPE, ATTRS)\t\\\n   DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,\t\\\n-   \t       true, true, !flag_isoc94, ATTRS, TARGET_C99_FUNCTIONS, true)\n+\t       true, true, !flag_isoc94, ATTRS, TARGET_C99_FUNCTIONS, true)\n \n /* Like DEF_LIB_BUILTIN, except that the function is only a part of\n    the standard in C99 or above.  */\n-#undef DEF_C99_BUILTIN\t\t\t\t\t\n+#undef DEF_C99_BUILTIN\n #define DEF_C99_BUILTIN(ENUM, NAME, TYPE, ATTRS)\t\\\n   DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,\t\\\n-   \t       true, true, !flag_isoc99, ATTRS, TARGET_C99_FUNCTIONS, true)\n+\t       true, true, !flag_isoc99, ATTRS, TARGET_C99_FUNCTIONS, true)\n \n /* Builtin that is specified by C99 and C90 reserve the name for future use.\n    We can still recognize the builtin in C90 mode but we can't produce it\n    implicitly.  */\n-#undef DEF_C99_C90RES_BUILTIN\t\t\t\t\t\n+#undef DEF_C99_C90RES_BUILTIN\n #define DEF_C99_C90RES_BUILTIN(ENUM, NAME, TYPE, ATTRS)\t\\\n   DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,\t\\\n-   \t       true, true, !flag_isoc99, ATTRS, TARGET_C99_FUNCTIONS, true)\n+\t       true, true, !flag_isoc99, ATTRS, TARGET_C99_FUNCTIONS, true)\n \n /* Builtin that C99 reserve the name for future use. We can still recognize\n    the builtin in C99 mode but we can't produce it implicitly.  */\n #undef DEF_EXT_C99RES_BUILTIN\n #define DEF_EXT_C99RES_BUILTIN(ENUM, NAME, TYPE, ATTRS)        \\\n   DEF_BUILTIN (ENUM, \"__builtin_\" NAME, BUILT_IN_NORMAL, TYPE, TYPE,   \\\n-              true, true, true, ATTRS, false, true)\n+\t      true, true, true, ATTRS, false, true)\n \n /* Allocate the enum and the name for a builtin, but do not actually\n    define it here at all.  */"}, {"sha": "b7267b2a850d830627e3edcbfb2a010ef6ed0a15", "filename": "gcc/c-aux-info.c", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-aux-info.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-aux-info.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-aux-info.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -75,15 +75,15 @@ affix_data_type (const char *param)\n   for (;;)\n     {\n       if (!strncmp (p, \"volatile \", 9))\n-        {\n-          p += 9;\n-          continue;\n-        }\n+\t{\n+\t  p += 9;\n+\t  continue;\n+\t}\n       if (!strncmp (p, \"const \", 6))\n-        {\n-          p += 6;\n-          continue;\n-        }\n+\t{\n+\t  p += 6;\n+\t  continue;\n+\t}\n       break;\n     }\n \n@@ -123,7 +123,7 @@ gen_formal_list_for_type (tree fntype, formals_style style)\n       const char *this_type;\n \n       if (*formal_list)\n-        formal_list = concat (formal_list, \", \", NULL);\n+\tformal_list = concat (formal_list, \", \", NULL);\n \n       this_type = gen_type (\"\", TREE_VALUE (formal_type), ansi);\n       formal_list\n@@ -167,18 +167,18 @@ gen_formal_list_for_type (tree fntype, formals_style style)\n   if (!*formal_list)\n     {\n       if (TYPE_ARG_TYPES (fntype))\n-        /* assert (TREE_VALUE (TYPE_ARG_TYPES (fntype)) == void_type_node);  */\n-        formal_list = \"void\";\n+\t/* assert (TREE_VALUE (TYPE_ARG_TYPES (fntype)) == void_type_node);  */\n+\tformal_list = \"void\";\n       else\n-        formal_list = \"/* ??? */\";\n+\tformal_list = \"/* ??? */\";\n     }\n   else\n     {\n       /* If there were at least some parameters, and if the formals-types-list\n-         petered out to a NULL (i.e. without being terminated by a\n-         void_type_node) then we need to tack on an ellipsis.  */\n+\t petered out to a NULL (i.e. without being terminated by a\n+\t void_type_node) then we need to tack on an ellipsis.  */\n       if (!formal_type)\n-        formal_list = concat (formal_list, \", ...\", NULL);\n+\tformal_list = concat (formal_list, \", ...\", NULL);\n     }\n \n   return concat (\" (\", formal_list, \")\", NULL);\n@@ -237,20 +237,20 @@ gen_formal_list_for_func_def (tree fndecl, formals_style style)\n       const char *this_formal;\n \n       if (*formal_list && ((style == ansi) || (style == k_and_r_names)))\n-        formal_list = concat (formal_list, \", \", NULL);\n+\tformal_list = concat (formal_list, \", \", NULL);\n       this_formal = gen_decl (formal_decl, 0, style);\n       if (style == k_and_r_decls)\n-        formal_list = concat (formal_list, this_formal, \"; \", NULL);\n+\tformal_list = concat (formal_list, this_formal, \"; \", NULL);\n       else\n-        formal_list = concat (formal_list, this_formal, NULL);\n+\tformal_list = concat (formal_list, this_formal, NULL);\n       formal_decl = TREE_CHAIN (formal_decl);\n     }\n   if (style == ansi)\n     {\n       if (!DECL_ARGUMENTS (fndecl))\n-        formal_list = concat (formal_list, \"void\", NULL);\n+\tformal_list = concat (formal_list, \"void\", NULL);\n       if (deserves_ellipsis (TREE_TYPE (fndecl)))\n-        formal_list = concat (formal_list, \", ...\", NULL);\n+\tformal_list = concat (formal_list, \", ...\", NULL);\n     }\n   if ((style == ansi) || (style == k_and_r_names))\n     formal_list = concat (\" (\", formal_list, \")\", NULL);\n@@ -309,23 +309,23 @@ gen_type (const char *ret_val, tree t, formals_style style)\n   else\n     {\n       switch (TREE_CODE (t))\n-        {\n-        case POINTER_TYPE:\n-          if (TYPE_READONLY (t))\n-            ret_val = concat (\"const \", ret_val, NULL);\n-          if (TYPE_VOLATILE (t))\n-            ret_val = concat (\"volatile \", ret_val, NULL);\n+\t{\n+\tcase POINTER_TYPE:\n+\t  if (TYPE_READONLY (t))\n+\t    ret_val = concat (\"const \", ret_val, NULL);\n+\t  if (TYPE_VOLATILE (t))\n+\t    ret_val = concat (\"volatile \", ret_val, NULL);\n \n-          ret_val = concat (\"*\", ret_val, NULL);\n+\t  ret_val = concat (\"*\", ret_val, NULL);\n \n \t  if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE || TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n \t    ret_val = concat (\"(\", ret_val, \")\", NULL);\n \n-          ret_val = gen_type (ret_val, TREE_TYPE (t), style);\n+\t  ret_val = gen_type (ret_val, TREE_TYPE (t), style);\n \n-          return ret_val;\n+\t  return ret_val;\n \n-        case ARRAY_TYPE:\n+\tcase ARRAY_TYPE:\n \t  if (!COMPLETE_TYPE_P (t) || TREE_CODE (TYPE_SIZE (t)) != INTEGER_CST)\n \t    ret_val = gen_type (concat (ret_val, \"[]\", NULL),\n \t\t\t\tTREE_TYPE (t), style);\n@@ -340,31 +340,31 @@ gen_type (const char *ret_val, tree t, formals_style style)\n \t      ret_val = gen_type (concat (ret_val, buff, NULL),\n \t\t\t\t  TREE_TYPE (t), style);\n \t    }\n-          break;\n+\t  break;\n \n-        case FUNCTION_TYPE:\n-          ret_val = gen_type (concat (ret_val,\n+\tcase FUNCTION_TYPE:\n+\t  ret_val = gen_type (concat (ret_val,\n \t\t\t\t      gen_formal_list_for_type (t, style),\n \t\t\t\t      NULL),\n \t\t\t      TREE_TYPE (t), style);\n-          break;\n+\t  break;\n \n-        case IDENTIFIER_NODE:\n-          data_type = IDENTIFIER_POINTER (t);\n-          break;\n+\tcase IDENTIFIER_NODE:\n+\t  data_type = IDENTIFIER_POINTER (t);\n+\t  break;\n \n \t/* The following three cases are complicated by the fact that a\n-           user may do something really stupid, like creating a brand new\n-           \"anonymous\" type specification in a formal argument list (or as\n-           part of a function return type specification).  For example:\n+\t   user may do something really stupid, like creating a brand new\n+\t   \"anonymous\" type specification in a formal argument list (or as\n+\t   part of a function return type specification).  For example:\n \n \t\tint f (enum { red, green, blue } color);\n \n \t   In such cases, we have no name that we can put into the prototype\n \t   to represent the (anonymous) type.  Thus, we have to generate the\n \t   whole darn type specification.  Yuck!  */\n \n-        case RECORD_TYPE:\n+\tcase RECORD_TYPE:\n \t  if (TYPE_NAME (t))\n \t    data_type = IDENTIFIER_POINTER (TYPE_NAME (t));\n \t  else\n@@ -383,7 +383,7 @@ gen_type (const char *ret_val, tree t, formals_style style)\n \t  data_type = concat (\"struct \", data_type, NULL);\n \t  break;\n \n-        case UNION_TYPE:\n+\tcase UNION_TYPE:\n \t  if (TYPE_NAME (t))\n \t    data_type = IDENTIFIER_POINTER (TYPE_NAME (t));\n \t  else\n@@ -402,7 +402,7 @@ gen_type (const char *ret_val, tree t, formals_style style)\n \t  data_type = concat (\"union \", data_type, NULL);\n \t  break;\n \n-        case ENUMERAL_TYPE:\n+\tcase ENUMERAL_TYPE:\n \t  if (TYPE_NAME (t))\n \t    data_type = IDENTIFIER_POINTER (TYPE_NAME (t));\n \t  else\n@@ -422,33 +422,33 @@ gen_type (const char *ret_val, tree t, formals_style style)\n \t  data_type = concat (\"enum \", data_type, NULL);\n \t  break;\n \n-        case TYPE_DECL:\n-          data_type = IDENTIFIER_POINTER (DECL_NAME (t));\n-          break;\n+\tcase TYPE_DECL:\n+\t  data_type = IDENTIFIER_POINTER (DECL_NAME (t));\n+\t  break;\n \n-        case INTEGER_TYPE:\n-          data_type = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (t)));\n-          /* Normally, `unsigned' is part of the deal.  Not so if it comes\n+\tcase INTEGER_TYPE:\n+\t  data_type = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (t)));\n+\t  /* Normally, `unsigned' is part of the deal.  Not so if it comes\n \t     with a type qualifier.  */\n-          if (TYPE_UNSIGNED (t) && TYPE_QUALS (t))\n+\t  if (TYPE_UNSIGNED (t) && TYPE_QUALS (t))\n \t    data_type = concat (\"unsigned \", data_type, NULL);\n \t  break;\n \n-        case REAL_TYPE:\n-          data_type = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (t)));\n-          break;\n+\tcase REAL_TYPE:\n+\t  data_type = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (t)));\n+\t  break;\n \n-        case VOID_TYPE:\n-          data_type = \"void\";\n-          break;\n+\tcase VOID_TYPE:\n+\t  data_type = \"void\";\n+\t  break;\n \n \tcase ERROR_MARK:\n \t  data_type = \"[ERROR]\";\n \t  break;\n \n-        default:\n-          gcc_unreachable ();\n-        }\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n     }\n   if (TYPE_READONLY (t))\n     ret_val = concat (\"const \", ret_val, NULL);\n@@ -518,11 +518,11 @@ gen_decl (tree decl, int is_func_definition, formals_style style)\n \t\t\tNULL);\n \n       /* Since we have already added in the formals list stuff, here we don't\n-         add the whole \"type\" of the function we are considering (which\n-         would include its parameter-list info), rather, we only add in\n-         the \"type\" of the \"type\" of the function, which is really just\n-         the return-type of the function (and does not include the parameter\n-         list info).  */\n+\t add the whole \"type\" of the function we are considering (which\n+\t would include its parameter-list info), rather, we only add in\n+\t the \"type\" of the \"type\" of the function, which is really just\n+\t the return-type of the function (and does not include the parameter\n+\t list info).  */\n \n       ret_val = gen_type (ret_val, TREE_TYPE (TREE_TYPE (decl)), style);\n     }"}, {"sha": "ea8985f3dde45c6dc82030274d5376baadb4d0ca", "filename": "gcc/c-common.c", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -574,7 +574,7 @@ const struct attribute_spec c_common_attribute_table[] =\n   { \"always_inline\",          0, 0, true,  false, false,\n \t\t\t      handle_always_inline_attribute },\n   { \"flatten\",                0, 0, true,  false, false,\n-                              handle_flatten_attribute },\n+\t\t\t      handle_flatten_attribute },\n   { \"used\",                   0, 0, true,  false, false,\n \t\t\t      handle_used_attribute },\n   { \"unused\",                 0, 0, false, false, false,\n@@ -773,10 +773,10 @@ c_expand_decl (tree decl)\n     {\n       /* Let the back-end know about this variable.  */\n       if (!anon_aggr_type_p (TREE_TYPE (decl)))\n-        emit_local_var (decl);\n+\temit_local_var (decl);\n       else\n-        expand_anon_union_decl (decl, NULL_TREE,\n-                                DECL_ANON_UNION_ELEMS (decl));\n+\texpand_anon_union_decl (decl, NULL_TREE,\n+\t\t\t\tDECL_ANON_UNION_ELEMS (decl));\n     }\n   else\n     return 0;\n@@ -1060,8 +1060,8 @@ vector_types_convertible_p (tree t1, tree t2)\n {\n   return targetm.vector_opaque_p (t1)\n \t || targetm.vector_opaque_p (t2)\n-         || (tree_int_cst_equal (TYPE_SIZE (t1), TYPE_SIZE (t2))\n-\t     && (TREE_CODE (TREE_TYPE (t1)) != REAL_TYPE || \n+\t || (tree_int_cst_equal (TYPE_SIZE (t1), TYPE_SIZE (t2))\n+\t     && (TREE_CODE (TREE_TYPE (t1)) != REAL_TYPE ||\n \t\t TYPE_PRECISION (t1) == TYPE_PRECISION (t2))\n \t     && INTEGRAL_TYPE_P (TREE_TYPE (t1))\n \t\t== INTEGRAL_TYPE_P (TREE_TYPE (t2)));\n@@ -1445,7 +1445,7 @@ verify_tree (tree x, struct tlist **pbefore_sp, struct tlist **pno_sp,\n \n     default:\n       /* For other expressions, simply recurse on their operands.\n-         Manual tail recursion for unary expressions.\n+\t Manual tail recursion for unary expressions.\n \t Other non-expressions need not be processed.  */\n       if (cl == tcc_unary)\n \t{\n@@ -2798,9 +2798,9 @@ c_common_get_alias_set (tree t)\n \t But, the standard is wrong.  In particular, this code is\n \t legal C++:\n \n-            int *ip;\n-            int **ipp = &ip;\n-            const int* const* cipp = ipp;\n+\t    int *ip;\n+\t    int **ipp = &ip;\n+\t    const int* const* cipp = ipp;\n \n \t And, it doesn't make sense for that to be legal unless you\n \t can dereference IPP and CIPP.  So, we ignore cv-qualifiers on\n@@ -3357,10 +3357,10 @@ c_common_nodes_and_builtins (void)\n \t\t    NONANSI_P, ATTRS, IMPLICIT, COND)\t\t\t\\\n   if (NAME && COND)\t\t\t\t\t\t\t\\\n     def_builtin_1 (ENUM, NAME, CLASS,                                   \\\n-                   builtin_types[(int) TYPE],                           \\\n-                   builtin_types[(int) LIBTYPE],                        \\\n-                   BOTH_P, FALLBACK_P, NONANSI_P,                       \\\n-                   built_in_attributes[(int) ATTRS], IMPLICIT);\n+\t\t   builtin_types[(int) TYPE],                           \\\n+\t\t   builtin_types[(int) LIBTYPE],                        \\\n+\t\t   BOTH_P, FALLBACK_P, NONANSI_P,                       \\\n+\t\t   built_in_attributes[(int) ATTRS], IMPLICIT);\n #include \"builtins.def\"\n #undef DEF_BUILTIN\n \n@@ -3659,8 +3659,8 @@ c_add_case_label (splay_tree cases, tree cond, tree orig_type,\n   if (low_value && high_value)\n     {\n       /* If the LOW_VALUE and HIGH_VALUE are the same, then this isn't\n-         really a case range, even though it was written that way.\n-         Remove the HIGH_VALUE to simplify later processing.  */\n+\t really a case range, even though it was written that way.\n+\t Remove the HIGH_VALUE to simplify later processing.  */\n       if (tree_int_cst_equal (low_value, high_value))\n \thigh_value = NULL_TREE;\n       else if (!tree_int_cst_lt (low_value, high_value))\n@@ -3877,9 +3877,9 @@ c_do_switch_warnings (splay_tree cases, location_t switch_location,\n \t\t\t\t\t\t  (splay_tree_key) low_value);\n \t      high_bound = splay_tree_successor (cases,\n \t\t\t\t\t\t (splay_tree_key) low_value);\n-\t      \n+\n \t      /* It is smaller than the LOW_VALUE, so there is no need to check\n-\t         unless the LOW_BOUND is in fact itself a case range.  */\n+\t\t unless the LOW_BOUND is in fact itself a case range.  */\n \t      if (low_bound\n \t\t  && CASE_HIGH ((tree) low_bound->value)\n \t\t  && tree_int_cst_compare (CASE_HIGH ((tree) low_bound->value),\n@@ -4079,7 +4079,7 @@ handle_packed_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n       if (TYPE_MAIN_VARIANT (*node) == *node)\n \t{\n \t  /* If it is the main variant, then pack the other variants\n-   \t     too. This happens in,\n+\t     too. This happens in,\n \n \t     struct Foo {\n \t       struct Foo const *ptr; // creates a variant w/o packed flag\n@@ -4224,8 +4224,8 @@ handle_always_inline_attribute (tree *node, tree name,\n \n static tree\n handle_flatten_attribute (tree *node, tree name,\n-                          tree args ATTRIBUTE_UNUSED,\n-                          int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)\n+\t\t\t  tree args ATTRIBUTE_UNUSED,\n+\t\t\t  int flags ATTRIBUTE_UNUSED, bool *no_add_attrs)\n {\n   if (TREE_CODE (*node) == FUNCTION_DECL)\n     /* Do nothing else, just set the attribute.  We'll get at\n@@ -4567,14 +4567,14 @@ handle_mode_attribute (tree *node, tree name, tree args,\n \t      return NULL_TREE;\n \t    }\n \n-          if (TREE_CODE (type) == POINTER_TYPE)\n+\t  if (TREE_CODE (type) == POINTER_TYPE)\n \t    fn = build_pointer_type_for_mode;\n \t  else\n \t    fn = build_reference_type_for_mode;\n \t  typefm = fn (TREE_TYPE (type), mode, false);\n \t}\n       else\n-        typefm = lang_hooks.types.type_for_mode (mode, TYPE_UNSIGNED (type));\n+\ttypefm = lang_hooks.types.type_for_mode (mode, TYPE_UNSIGNED (type));\n \n       if (typefm == NULL_TREE)\n \t{\n@@ -4881,9 +4881,9 @@ handle_visibility_attribute (tree *node, tree name, tree args,\n     {\n       if (TREE_CODE (*node) != RECORD_TYPE && TREE_CODE (*node) != UNION_TYPE)\n        {\n-         warning (OPT_Wattributes, \"%qE attribute ignored on non-class types\",\n+\t warning (OPT_Wattributes, \"%qE attribute ignored on non-class types\",\n \t\t  name);\n-         return NULL_TREE;\n+\t return NULL_TREE;\n        }\n     }\n   else if (decl_function_context (decl) != 0 || !TREE_PUBLIC (decl))\n@@ -4903,7 +4903,7 @@ handle_visibility_attribute (tree *node, tree name, tree args,\n     {\n       decl = TYPE_NAME (decl);\n       if (!decl)\n-        return NULL_TREE;\n+\treturn NULL_TREE;\n       if (TREE_CODE (decl) == IDENTIFIER_NODE)\n \t{\n \t   warning (OPT_Wattributes, \"%qE attribute ignored on types\",\n@@ -5387,15 +5387,15 @@ check_function_sentinel (tree attrs, tree params, tree typelist)\n \ttypelist = TREE_CHAIN (typelist);\n \tparams = TREE_CHAIN (params);\n       }\n-      \n+\n       if (typelist || !params)\n \twarning (OPT_Wformat,\n \t\t \"not enough variable arguments to fit a sentinel\");\n       else\n-        {\n+\t{\n \t  tree sentinel, end;\n \t  unsigned pos = 0;\n-\t  \n+\n \t  if (TREE_VALUE (attr))\n \t    {\n \t      tree p = TREE_VALUE (TREE_VALUE (attr));\n@@ -5432,7 +5432,7 @@ check_function_sentinel (tree attrs, tree params, tree typelist)\n \t\t as wide as a pointer, and we don't want to force\n \t\t users to cast the NULL they have written there.\n \t\t We warn with -Wstrict-null-sentinel, though.  */\n-              && (warn_strict_null_sentinel\n+\t      && (warn_strict_null_sentinel\n \t\t  || null_node != TREE_VALUE (sentinel)))\n \t    warning (OPT_Wformat, \"missing sentinel in function call\");\n \t}\n@@ -5596,32 +5596,32 @@ handle_sentinel_attribute (tree *node, tree name, tree args,\n \tparams = TREE_CHAIN (params);\n \n       if (VOID_TYPE_P (TREE_VALUE (params)))\n-        {\n+\t{\n \t  warning (OPT_Wattributes,\n \t\t   \"%qE attribute only applies to variadic functions\", name);\n \t  *no_add_attrs = true;\n \t}\n     }\n-  \n+\n   if (args)\n     {\n       tree position = TREE_VALUE (args);\n \n       if (TREE_CODE (position) != INTEGER_CST)\n-        {\n+\t{\n \t  warning (0, \"requested position is not an integer constant\");\n \t  *no_add_attrs = true;\n \t}\n       else\n-        {\n+\t{\n \t  if (tree_int_cst_lt (position, integer_zero_node))\n \t    {\n \t      warning (0, \"requested position is less than zero\");\n \t      *no_add_attrs = true;\n \t    }\n \t}\n     }\n-  \n+\n   return NULL_TREE;\n }\n \f\n@@ -5826,9 +5826,9 @@ c_parse_error (const char *gmsgid, enum cpp_ttype token, tree value)\n       unsigned int val = TREE_INT_CST_LOW (value);\n       const char *const ell = (token == CPP_CHAR) ? \"\" : \"L\";\n       if (val <= UCHAR_MAX && ISGRAPH (val))\n-        message = catenate_messages (gmsgid, \" before %s'%c'\");\n+\tmessage = catenate_messages (gmsgid, \" before %s'%c'\");\n       else\n-        message = catenate_messages (gmsgid, \" before %s'\\\\x%x'\");\n+\tmessage = catenate_messages (gmsgid, \" before %s'\\\\x%x'\");\n \n       error (message, ell, val);\n       free (message);\n@@ -5864,7 +5864,7 @@ c_parse_error (const char *gmsgid, enum cpp_ttype token, tree value)\n       error (message);\n       free (message);\n     }\n-#undef catenate_messages  \n+#undef catenate_messages\n }\n \n /* Walk a gimplified function and warn for functions whose return value is\n@@ -6196,7 +6196,7 @@ sync_resolve_size (tree function, tree params)\n   return 0;\n }\n \n-/* A helper function for resolve_overloaded_builtin.  Adds casts to \n+/* A helper function for resolve_overloaded_builtin.  Adds casts to\n    PARAMS to make arguments match up with those of FUNCTION.  Drops\n    the variadic arguments at the end.  Returns false if some error\n    was encountered; true on success.  */\n@@ -6249,7 +6249,7 @@ sync_resolve_params (tree orig_function, tree function, tree params)\n   return true;\n }\n \n-/* A helper function for resolve_overloaded_builtin.  Adds a cast to \n+/* A helper function for resolve_overloaded_builtin.  Adds a cast to\n    RESULT to make it match the type of the first pointer argument in\n    PARAMS.  */\n \n@@ -6280,13 +6280,13 @@ resolve_overloaded_builtin (tree function, tree params)\n       break;\n     case BUILT_IN_MD:\n       if (targetm.resolve_overloaded_builtin)\n-        return targetm.resolve_overloaded_builtin (function, params);\n+\treturn targetm.resolve_overloaded_builtin (function, params);\n       else\n-        return NULL_TREE;\n+\treturn NULL_TREE;\n     default:\n       return NULL_TREE;\n     }\n-    \n+\n   /* Handle BUILT_IN_NORMAL here.  */\n   switch (orig_code)\n     {"}, {"sha": "b26e811a90230ecd360e4f9e13d27a9699b09ad4", "filename": "gcc/c-common.h", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -82,9 +82,9 @@ enum rid\n   RID_PUBLIC,   RID_PRIVATE,  RID_PROTECTED,\n   RID_TEMPLATE, RID_NULL,     RID_CATCH,\n   RID_DELETE,   RID_FALSE,    RID_NAMESPACE,\n-  RID_NEW,      RID_OFFSETOF, RID_OPERATOR, \n-  RID_THIS,     RID_THROW,    RID_TRUE,     \n-  RID_TRY,      RID_TYPENAME, RID_TYPEID,   \n+  RID_NEW,      RID_OFFSETOF, RID_OPERATOR,\n+  RID_THIS,     RID_THROW,    RID_TRUE,\n+  RID_TRY,      RID_TYPENAME, RID_TYPEID,\n   RID_USING,\n \n   /* casts */\n@@ -94,7 +94,7 @@ enum rid\n   RID_AT_ENCODE,   RID_AT_END,\n   RID_AT_CLASS,    RID_AT_ALIAS,     RID_AT_DEFS,\n   RID_AT_PRIVATE,  RID_AT_PROTECTED, RID_AT_PUBLIC,\n-  RID_AT_PROTOCOL, RID_AT_SELECTOR,  \n+  RID_AT_PROTOCOL, RID_AT_SELECTOR,\n   RID_AT_THROW,\t   RID_AT_TRY,       RID_AT_CATCH,\n   RID_AT_FINALLY,  RID_AT_SYNCHRONIZED,\n   RID_AT_INTERFACE,\n@@ -156,7 +156,7 @@ enum c_tree_index\n     CTI_PRETTY_FUNCTION_NAME_DECL,\n     CTI_C99_FUNCTION_NAME_DECL,\n     CTI_SAVED_FUNCTION_NAME_DECLS,\n-    \n+\n     CTI_VOID_ZERO,\n \n     CTI_NULL,\n@@ -304,8 +304,8 @@ extern tree build_indirect_ref (tree, const char *);\n extern int c_expand_decl (tree);\n \n extern int field_decl_cmp (const void *, const void *);\n-extern void resort_sorted_fields (void *, void *, gt_pointer_operator, \n-                                  void *);\n+extern void resort_sorted_fields (void *, void *, gt_pointer_operator,\n+\t\t\t\t  void *);\n extern bool has_c_linkage (tree decl);\n \f\n /* Switches common to the C front ends.  */\n@@ -406,9 +406,9 @@ extern int flag_const_strings;\n \n extern int flag_signed_bitfields;\n \n-/* Warn about #pragma directives that are not recognized.  */      \n+/* Warn about #pragma directives that are not recognized.  */\n \n-extern int warn_unknown_pragmas; /* Tri state variable.  */  \n+extern int warn_unknown_pragmas; /* Tri state variable.  */\n \n /* Warn about format/argument anomalies in calls to formatted I/O functions\n    (*printf, *scanf, strftime, strfmon, etc.).  */"}, {"sha": "c6e5c6d34f8662c6e6962b92da19b6bf7de749e2", "filename": "gcc/c-cppbuiltin.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-cppbuiltin.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -231,7 +231,7 @@ builtin_define_float_constants (const char *name_prefix,\n     /* This is an IBM extended double format, so 1.0 + any double is\n        representable precisely.  */\n       sprintf (buf, \"0x1p%d\", (fmt->emin - fmt->p) * fmt->log2_b);\n-    else      \n+    else\n       sprintf (buf, \"0x1p%d\", (1 - fmt->p) * fmt->log2_b);\n   builtin_define_with_hex_fp_value (name, type, decimal_dig, buf, fp_suffix, fp_cast);\n \n@@ -351,7 +351,7 @@ define__GNUC__ (void)\n     builtin_define_with_value_n (\"__GNUG__\", q, v - q);\n \n   gcc_assert (*v == '.' && ISDIGIT (v[1]));\n-  \n+\n   q = ++v;\n   while (ISDIGIT (*v))\n     v++;\n@@ -403,7 +403,7 @@ c_cpp_builtins (cpp_reader *pfile)\n \n   if (c_dialect_cxx ())\n     {\n-      if (flag_weak && SUPPORTS_ONE_ONLY) \n+      if (flag_weak && SUPPORTS_ONE_ONLY)\n \tcpp_define (pfile, \"__GXX_WEAK__=1\");\n       else\n \tcpp_define (pfile, \"__GXX_WEAK__=0\");\n@@ -420,7 +420,7 @@ c_cpp_builtins (cpp_reader *pfile)\n   if (flag_abi_version == 0)\n     /* Use a very large value so that:\n \n-         #if __GXX_ABI_VERSION >= <value for version X>\n+\t #if __GXX_ABI_VERSION >= <value for version X>\n \n        will work whether the user explicitly says \"-fabi-version=x\" or\n        \"-fabi-version=0\".  Do not use INT_MAX because that will be\n@@ -432,7 +432,7 @@ c_cpp_builtins (cpp_reader *pfile)\n     builtin_define_with_int_value (\"__GXX_ABI_VERSION\", 102);\n   else\n     /* Newer versions have values 1002, 1003, ....  */\n-    builtin_define_with_int_value (\"__GXX_ABI_VERSION\", \n+    builtin_define_with_int_value (\"__GXX_ABI_VERSION\",\n \t\t\t\t   1000 + flag_abi_version);\n \n   /* libgcc needs to know this.  */"}, {"sha": "9ece1ce764d633b6f7c165d6eeb55955587f14f3", "filename": "gcc/c-decl.c", "status": "modified", "additions": 107, "deletions": 107, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -770,8 +770,8 @@ pop_scope (void)\n \t  TREE_CHAIN (p) = BLOCK_VARS (block);\n \t  BLOCK_VARS (block) = p;\n \t  gcc_assert (I_LABEL_BINDING (b->id) == b);\n- \t  I_LABEL_BINDING (b->id) = b->shadowed;\n- \t  break;\n+\t  I_LABEL_BINDING (b->id) = b->shadowed;\n+\t  break;\n \n \tcase ENUMERAL_TYPE:\n \tcase UNION_TYPE:\n@@ -785,7 +785,7 @@ pop_scope (void)\n \t      gcc_assert (I_TAG_BINDING (b->id) == b);\n \t      I_TAG_BINDING (b->id) = b->shadowed;\n \t    }\n-  \t  break;\n+\t  break;\n \n \tcase FUNCTION_DECL:\n \t  /* Propagate TREE_ADDRESSABLE from nested functions to their\n@@ -812,7 +812,7 @@ pop_scope (void)\n \t      && DECL_NAME (p)\n \t      && !DECL_ARTIFICIAL (p)\n \t      && scope != file_scope\n-\t      && scope != external_scope) \n+\t      && scope != external_scope)\n \t    warning (OPT_Wunused_variable, \"unused variable %q+D\", p);\n \n \t  if (b->inner_comp)\n@@ -1484,7 +1484,7 @@ diagnose_mismatched_decls (tree newdecl, tree olddecl,\n \n   /* warnings */\n   /* All decls must agree on a visibility.  */\n-  if (CODE_CONTAINS_STRUCT (TREE_CODE (newdecl), TS_DECL_WITH_VIS) \n+  if (CODE_CONTAINS_STRUCT (TREE_CODE (newdecl), TS_DECL_WITH_VIS)\n       && DECL_VISIBILITY_SPECIFIED (newdecl) && DECL_VISIBILITY_SPECIFIED (olddecl)\n       && DECL_VISIBILITY (newdecl) != DECL_VISIBILITY (olddecl))\n     {\n@@ -1704,7 +1704,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t  are assigned.  */\n        if (DECL_SECTION_NAME (newdecl) == NULL_TREE)\n \t DECL_SECTION_NAME (newdecl) = DECL_SECTION_NAME (olddecl);\n-       \n+\n        /* Copy the assembler name.\n \t  Currently, it can only be defined in the prototype.  */\n        COPY_DECL_ASSEMBLER_NAME (olddecl, newdecl);\n@@ -1715,7 +1715,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t   DECL_VISIBILITY (newdecl) = DECL_VISIBILITY (olddecl);\n \t   DECL_VISIBILITY_SPECIFIED (newdecl) = 1;\n \t }\n-       \n+\n        if (TREE_CODE (newdecl) == FUNCTION_DECL)\n \t {\n \t   DECL_STATIC_CONSTRUCTOR(newdecl) |= DECL_STATIC_CONSTRUCTOR(olddecl);\n@@ -1729,7 +1729,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t   DECL_IS_PURE (newdecl) |= DECL_IS_PURE (olddecl);\n \t   DECL_IS_NOVOPS (newdecl) |= DECL_IS_NOVOPS (olddecl);\n \t }\n-       \n+\n        /* Merge the storage class information.  */\n        merge_weak (newdecl, olddecl);\n \n@@ -1745,7 +1745,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t     TREE_PUBLIC (DECL_NAME (olddecl)) = 0;\n \t }\n      }\n-   \n+\n    if (DECL_EXTERNAL (newdecl))\n      {\n        TREE_STATIC (newdecl) = TREE_STATIC (olddecl);\n@@ -1764,8 +1764,8 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n        TREE_STATIC (olddecl) = TREE_STATIC (newdecl);\n        TREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);\n      }\n-   \n-   if (TREE_CODE (newdecl) == FUNCTION_DECL) \n+\n+   if (TREE_CODE (newdecl) == FUNCTION_DECL)\n      {\n        /* If we're redefining a function previously defined as extern\n \t  inline, make sure we emit debug info for the inline before we\n@@ -1837,13 +1837,13 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t     DECL_INLINE (newdecl) = 1;\n \t }\n      }\n-   \n+\n    /* Copy most of the decl-specific fields of NEWDECL into OLDDECL.\n      But preserve OLDDECL's DECL_UID and DECL_CONTEXT.  */\n   {\n     unsigned olddecl_uid = DECL_UID (olddecl);\n     tree olddecl_context = DECL_CONTEXT (olddecl);\n-    \n+\n     memcpy ((char *) olddecl + sizeof (struct tree_common),\n \t    (char *) newdecl + sizeof (struct tree_common),\n \t    sizeof (struct tree_decl_common) - sizeof (struct tree_common));\n@@ -1863,7 +1863,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \tbreak;\n \n       default:\n-\t\n+\n \tmemcpy ((char *) olddecl + sizeof (struct tree_decl_common),\n \t\t(char *) newdecl + sizeof (struct tree_decl_common),\n \t\tsizeof (struct tree_decl_non_common) - sizeof (struct tree_decl_common));\n@@ -1972,7 +1972,7 @@ warn_if_shadowing (tree new_decl)\n    translation and get back the corresponding typedef name.  For\n    example, given:\n \n-        typedef struct S MY_TYPE;\n+\ttypedef struct S MY_TYPE;\n \tMY_TYPE object;\n \n    Later parts of the compiler might only know that `object' was of\n@@ -2456,7 +2456,7 @@ undeclared_variable (tree id, location_t loc)\n \t}\n \n       /* If we are parsing old-style parameter decls, current_function_decl\n-         will be nonnull but current_function_scope will be null.  */\n+\t will be nonnull but current_function_scope will be null.  */\n       scope = current_function_scope ? current_function_scope : current_scope;\n     }\n   bind (id, error_mark_node, scope, /*invisible=*/false, /*nested=*/false);\n@@ -2595,7 +2595,7 @@ define_label (location_t location, tree name)\n \n   if (!in_system_header && lookup_name (name))\n     warning (OPT_Wtraditional, \"%Htraditional C lacks a separate namespace \"\n-             \"for labels, identifier %qE conflicts\", &location, name);\n+\t     \"for labels, identifier %qE conflicts\", &location, name);\n \n   nlist_se = XOBNEW (&parser_obstack, struct c_label_list);\n   nlist_se->next = label_context_stack_se->labels_def;\n@@ -2670,7 +2670,7 @@ pending_xref_error (void)\n {\n   if (pending_invalid_xref != 0)\n     error (\"%H%qE defined as wrong kind of tag\",\n-           &pending_invalid_xref_location, pending_invalid_xref);\n+\t   &pending_invalid_xref_location, pending_invalid_xref);\n   pending_invalid_xref = 0;\n }\n \n@@ -3460,8 +3460,8 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n   maybe_apply_pragma_weak (decl);\n \n   /* If this is a variable definition, determine its ELF visibility.  */\n-  if (TREE_CODE (decl) == VAR_DECL \n-      && TREE_STATIC (decl) \n+  if (TREE_CODE (decl) == VAR_DECL\n+      && TREE_STATIC (decl)\n       && !DECL_EXTERNAL (decl))\n     c_determine_visibility (decl);\n \n@@ -3475,7 +3475,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n       if (c_dialect_objc ())\n \tobjc_check_decl (decl);\n \n-      if (asmspec) \n+      if (asmspec)\n \t{\n \t  /* If this is not a static variable, issue a warning.\n \t     It doesn't make any sense to give an ASMSPEC for an\n@@ -3491,7 +3491,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t  else\n \t    set_user_assembler_name (decl, asmspec);\n \t}\n-      \n+\n       if (DECL_FILE_SCOPE_P (decl))\n \t{\n \t  if (DECL_INITIAL (decl) == NULL_TREE\n@@ -3537,7 +3537,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t      add_stmt (build_stmt (DECL_EXPR, decl));\n \t    }\n \t}\n-  \n+\n \n       if (!DECL_FILE_SCOPE_P (decl))\n \t{\n@@ -3821,7 +3821,7 @@ check_bitfield_type_and_width (tree *type, tree *width, const char *orig_name)\n     {\n       struct lang_type *lt = TYPE_LANG_SPECIFIC (*type);\n       if (!lt\n-          || w < min_precision (lt->enum_min, TYPE_UNSIGNED (*type))\n+\t  || w < min_precision (lt->enum_min, TYPE_UNSIGNED (*type))\n \t  || w < min_precision (lt->enum_max, TYPE_UNSIGNED (*type)))\n \twarning (0, \"%qs is narrower than values of its type\", name);\n     }\n@@ -4156,25 +4156,25 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    declarator = declarator->declarator;\n \n \t    /* Check for some types that there cannot be arrays of.  */\n-\t    \n+\n \t    if (VOID_TYPE_P (type))\n \t      {\n \t\terror (\"declaration of %qs as array of voids\", name);\n \t\ttype = error_mark_node;\n \t      }\n-\t    \n+\n \t    if (TREE_CODE (type) == FUNCTION_TYPE)\n \t      {\n \t\terror (\"declaration of %qs as array of functions\", name);\n \t\ttype = error_mark_node;\n \t      }\n-\t    \n+\n \t    if (pedantic && !in_system_header && flexible_array_type_p (type))\n \t      pedwarn (\"invalid use of structure with flexible array member\");\n-\t    \n+\n \t    if (size == error_mark_node)\n \t      type = error_mark_node;\n-\t    \n+\n \t    if (type == error_mark_node)\n \t      continue;\n \n@@ -4187,16 +4187,16 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t/* Strip NON_LVALUE_EXPRs since we aren't using as an\n \t\t   lvalue.  */\n \t\tSTRIP_TYPE_NOPS (size);\n-\t\t\n+\n \t\tif (!INTEGRAL_TYPE_P (TREE_TYPE (size)))\n \t\t  {\n \t\t    error (\"size of array %qs has non-integer type\", name);\n \t\t    size = integer_one_node;\n \t\t  }\n-\t\t\n+\n \t\tif (pedantic && integer_zerop (size))\n \t\t  pedwarn (\"ISO C forbids zero-size array %qs\", name);\n-\t\t\n+\n \t\tif (TREE_CODE (size) == INTEGER_CST)\n \t\t  {\n \t\t    constant_expression_warning (size);\n@@ -4212,7 +4212,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t       nonconstant even if it is (eg) a const variable\n \t\t       with known value.  */\n \t\t    size_varies = 1;\n-\t\t    \n+\n \t\t    if (!flag_isoc99 && pedantic)\n \t\t      {\n \t\t\tif (TREE_CONSTANT (size))\n@@ -4227,10 +4227,10 @@ grokdeclarator (const struct c_declarator *declarator,\n \n \t\tif (integer_zerop (size))\n \t\t  {\n-\t\t    /* \tA zero-length array cannot be represented with\n-\t\t        an unsigned index type, which is what we'll\n-\t\t        get with build_index_type.  Create an\n-\t\t        open-ended range instead.  */\n+\t\t    /* A zero-length array cannot be represented with\n+\t\t       an unsigned index type, which is what we'll\n+\t\t       get with build_index_type.  Create an\n+\t\t       open-ended range instead.  */\n \t\t    itype = build_range_type (sizetype, size, NULL_TREE);\n \t\t  }\n \t\telse\n@@ -4250,7 +4250,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t\t\t\t convert (index_type,\n \t\t\t\t\t\t  size_one_node));\n \n-\t\t    /* If that overflowed, the array is too big.  ??? \n+\t\t    /* If that overflowed, the array is too big.  ???\n \t\t       While a size of INT_MAX+1 technically shouldn't\n \t\t       cause an overflow (because we subtract 1), the\n \t\t       overflow is recorded during the conversion to\n@@ -4264,7 +4264,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t\ttype = error_mark_node;\n \t\t\tcontinue;\n \t\t      }\n-\t\t    \n+\n \t\t    itype = build_index_type (itype);\n \t\t  }\n \t      }\n@@ -4296,7 +4296,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    if (!COMPLETE_TYPE_P (type))\n \t      {\n \t\terror (\"array type has incomplete element type\");\n-\t        type = error_mark_node;\n+\t\ttype = error_mark_node;\n \t      }\n \t    else\n \t      type = build_array_type (type, itype);\n@@ -4353,7 +4353,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t       type for the function to return.  */\n \t    if (type == error_mark_node)\n \t      continue;\n-\t    \n+\n \t    size_varies = 0;\n \n \t    /* Warn about some types functions can't return.  */\n@@ -4377,7 +4377,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t       qualify the return type, not the function type.  */\n \t    if (type_quals)\n \t      {\n-\t        /* Type qualifiers on a function return type are\n+\t\t/* Type qualifiers on a function return type are\n \t\t   normally permitted by the standard but have no\n \t\t   effect, so give a warning at -Wreturn-type.\n \t\t   Qualifiers on a void return type are banned on\n@@ -4388,20 +4388,20 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\telse\n \t\t  warning (OPT_Wreturn_type,\n \t\t\t   \"type qualifiers ignored on function return type\");\n-\t\t\n+\n \t\ttype = c_build_qualified_type (type, type_quals);\n \t      }\n \t    type_quals = TYPE_UNQUALIFIED;\n-\t    \n+\n \t    type = build_function_type (type, arg_types);\n \t    declarator = declarator->declarator;\n-\t    \n+\n \t    /* Set the TYPE_CONTEXTs for each tagged type which is local to\n \t       the formal parameter list of this FUNCTION_TYPE to point to\n \t       the FUNCTION_TYPE node itself.  */\n \t    {\n \t      tree link;\n-\t      \n+\n \t      for (link = arg_info->tags;\n \t\t   link;\n \t\t   link = TREE_CHAIN (link))\n@@ -4422,7 +4422,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    size_varies = 0;\n \n \t    type = build_pointer_type (type);\n-\t    \n+\n \t    /* Process type qualifiers (such as const or volatile)\n \t       that were given inside the `*'.  */\n \t    type_quals = declarator->u.pointer_quals;\n@@ -4608,7 +4608,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t    type = build_pointer_type (type);\n \t  }\n \telse if (TREE_CODE (type) != ERROR_MARK\n-\t         && !COMPLETE_OR_UNBOUND_ARRAY_TYPE_P (type))\n+\t\t && !COMPLETE_OR_UNBOUND_ARRAY_TYPE_P (type))\n \t  {\n \t    error (\"field %qs has incomplete type\", name);\n \t    type = error_mark_node;\n@@ -4640,8 +4640,8 @@ grokdeclarator (const struct c_declarator *declarator,\n \t      }\n \t    else if (storage_class == csc_static)\n \t      {\n-\t        error (\"invalid storage class for function %qs\", name);\n-\t        if (funcdef_flag)\n+\t\terror (\"invalid storage class for function %qs\", name);\n+\t\tif (funcdef_flag)\n \t\t  storage_class = declspecs->storage_class = csc_none;\n \t\telse\n \t\t  return 0;\n@@ -4963,7 +4963,7 @@ get_parm_info (bool ellipsis)\n      (by 'const' or 'volatile'), or has a storage class specifier\n      ('register'), then the behavior is undefined; issue an error.\n      Typedefs for 'void' are OK (see DR#157).  */\n-  if (b->prev == 0\t\t            /* one binding */\n+  if (b->prev == 0\t\t\t    /* one binding */\n       && TREE_CODE (b->decl) == PARM_DECL   /* which is a parameter */\n       && !DECL_NAME (b->decl)               /* anonymous */\n       && VOID_TYPE_P (TREE_TYPE (b->decl))) /* of void type */\n@@ -5188,17 +5188,17 @@ start_struct (enum tree_code code, tree name)\n   if (ref && TREE_CODE (ref) == code)\n     {\n       if (TYPE_SIZE (ref))\n-        {\n+\t{\n \t  if (code == UNION_TYPE)\n \t    error (\"redefinition of %<union %E%>\", name);\n-          else\n+\t  else\n \t    error (\"redefinition of %<struct %E%>\", name);\n \t}\n       else if (C_TYPE_BEING_DEFINED (ref))\n \t{\n \t  if (code == UNION_TYPE)\n \t    error (\"nested redefinition of %<union %E%>\", name);\n-          else\n+\t  else\n \t    error (\"nested redefinition of %<struct %E%>\", name);\n \t}\n     }\n@@ -5507,46 +5507,46 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \n     for (x = fieldlist; x; x = TREE_CHAIN (x))\n       {\n-        if (len > 15 || DECL_NAME (x) == NULL)\n-          break;\n-        len += 1;\n+\tif (len > 15 || DECL_NAME (x) == NULL)\n+\t  break;\n+\tlen += 1;\n       }\n \n     if (len > 15)\n       {\n-        tree *field_array;\n-        struct lang_type *space;\n-        struct sorted_fields_type *space2;\n+\ttree *field_array;\n+\tstruct lang_type *space;\n+\tstruct sorted_fields_type *space2;\n \n-        len += list_length (x);\n+\tlen += list_length (x);\n \n-        /* Use the same allocation policy here that make_node uses, to\n-          ensure that this lives as long as the rest of the struct decl.\n-          All decls in an inline function need to be saved.  */\n+\t/* Use the same allocation policy here that make_node uses, to\n+\t  ensure that this lives as long as the rest of the struct decl.\n+\t  All decls in an inline function need to be saved.  */\n \n-        space = GGC_CNEW (struct lang_type);\n-        space2 = GGC_NEWVAR (struct sorted_fields_type,\n+\tspace = GGC_CNEW (struct lang_type);\n+\tspace2 = GGC_NEWVAR (struct sorted_fields_type,\n \t\t\t     sizeof (struct sorted_fields_type) + len * sizeof (tree));\n \n-        len = 0;\n+\tlen = 0;\n \tspace->s = space2;\n \tfield_array = &space2->elts[0];\n-        for (x = fieldlist; x; x = TREE_CHAIN (x))\n-          {\n-            field_array[len++] = x;\n-\n-            /* If there is anonymous struct or union, break out of the loop.  */\n-            if (DECL_NAME (x) == NULL)\n-              break;\n-          }\n-        /* Found no anonymous struct/union.  Add the TYPE_LANG_SPECIFIC.  */\n-        if (x == NULL)\n-          {\n-            TYPE_LANG_SPECIFIC (t) = space;\n-            TYPE_LANG_SPECIFIC (t)->s->len = len;\n-            field_array = TYPE_LANG_SPECIFIC (t)->s->elts;\n-            qsort (field_array, len, sizeof (tree), field_decl_cmp);\n-          }\n+\tfor (x = fieldlist; x; x = TREE_CHAIN (x))\n+\t  {\n+\t    field_array[len++] = x;\n+\n+\t    /* If there is anonymous struct or union, break out of the loop.  */\n+\t    if (DECL_NAME (x) == NULL)\n+\t      break;\n+\t  }\n+\t/* Found no anonymous struct/union.  Add the TYPE_LANG_SPECIFIC.  */\n+\tif (x == NULL)\n+\t  {\n+\t    TYPE_LANG_SPECIFIC (t) = space;\n+\t    TYPE_LANG_SPECIFIC (t)->s->len = len;\n+\t    field_array = TYPE_LANG_SPECIFIC (t)->s->elts;\n+\t    qsort (field_array, len, sizeof (tree), field_decl_cmp);\n+\t  }\n       }\n   }\n \n@@ -6100,7 +6100,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n \t\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n \t\t      != char_type_node))\n \t\tpedwarn (\"second argument of %q+D should be %<char **%>\",\n-                         decl1);\n+\t\t\t decl1);\n \t      break;\n \n \t    case 3:\n@@ -6109,7 +6109,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n \t\t  || (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (type)))\n \t\t      != char_type_node))\n \t\tpedwarn (\"third argument of %q+D should probably be \"\n-                         \"%<char **%>\", decl1);\n+\t\t\t \"%<char **%>\", decl1);\n \t      break;\n \t    }\n \t}\n@@ -6573,12 +6573,12 @@ finish_function (void)\n     {\n       tree args = DECL_ARGUMENTS (fndecl);\n       for (; args; args = TREE_CHAIN (args))\n- \t{\n- \t  tree type = TREE_TYPE (args);\n- \t  if (INTEGRAL_TYPE_P (type)\n- \t      && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))\n- \t    DECL_ARG_TYPE (args) = integer_type_node;\n- \t}\n+\t{\n+\t  tree type = TREE_TYPE (args);\n+\t  if (INTEGRAL_TYPE_P (type)\n+\t      && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))\n+\t    DECL_ARG_TYPE (args) = integer_type_node;\n+\t}\n     }\n \n   if (DECL_INITIAL (fndecl) && DECL_INITIAL (fndecl) != error_mark_node)\n@@ -6677,9 +6677,9 @@ finish_function (void)\n       && !undef_nested_function)\n     {\n       if (!decl_function_context (fndecl))\n-        {\n-          c_genericize (fndecl);\n-          c_gimple_diagnostics_recursively (fndecl);\n+\t{\n+\t  c_genericize (fndecl);\n+\t  c_gimple_diagnostics_recursively (fndecl);\n \n \t  /* ??? Objc emits functions after finalizing the compilation unit.\n \t     This should be cleaned up later and this conditional removed.  */\n@@ -6690,14 +6690,14 @@ finish_function (void)\n \t    }\n \n \t  cgraph_finalize_function (fndecl, false);\n-        }\n+\t}\n       else\n-        {\n-          /* Register this function with cgraph just far enough to get it\n-            added to our parent's nested function list.  Handy, since the\n-            C front end doesn't have such a list.  */\n-          (void) cgraph_node (fndecl);\n-        }\n+\t{\n+\t  /* Register this function with cgraph just far enough to get it\n+\t    added to our parent's nested function list.  Handy, since the\n+\t    C front end doesn't have such a list.  */\n+\t  (void) cgraph_node (fndecl);\n+\t}\n     }\n \n   if (!decl_function_context (fndecl))\n@@ -6725,11 +6725,11 @@ c_expand_body (tree fndecl)\n   if (DECL_STATIC_CONSTRUCTOR (fndecl)\n       && targetm.have_ctors_dtors)\n     targetm.asm_out.constructor (XEXP (DECL_RTL (fndecl), 0),\n-                                 DEFAULT_INIT_PRIORITY);\n+\t\t\t\t DEFAULT_INIT_PRIORITY);\n   if (DECL_STATIC_DESTRUCTOR (fndecl)\n       && targetm.have_ctors_dtors)\n     targetm.asm_out.destructor (XEXP (DECL_RTL (fndecl), 0),\n-                                DEFAULT_INIT_PRIORITY);\n+\t\t\t\tDEFAULT_INIT_PRIORITY);\n }\n \f\n /* Check the declarations given in a for-loop for satisfying the C99\n@@ -7815,10 +7815,10 @@ c_write_global_declarations (void)\n       int flags;\n       FILE * stream = dump_begin (TDI_tu, &flags);\n       if (stream && tmp)\n-        {\n-          dump_node (tmp, flags & ~TDF_SLIM, stream);\n-          dump_end (TDI_tu, stream);\n-        }\n+\t{\n+\t  dump_node (tmp, flags & ~TDF_SLIM, stream);\n+\t  dump_end (TDI_tu, stream);\n+\t}\n     }\n \n   /* Process all file scopes in this compilation, and the external_scope,"}, {"sha": "7654239d4bbe19a8711624ca4edb802f038fe7ec", "filename": "gcc/c-errors.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-errors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-errors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-errors.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -36,10 +36,10 @@ pedwarn_c99 (const char *gmsgid, ...)\n {\n   diagnostic_info diagnostic;\n   va_list ap;\n-  \n+\n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap, input_location,\n-                       flag_isoc99 ? pedantic_error_kind () : DK_WARNING);\n+\t\t       flag_isoc99 ? pedantic_error_kind () : DK_WARNING);\n   report_diagnostic (&diagnostic);\n   va_end (ap);\n }\n@@ -57,7 +57,7 @@ pedwarn_c90 (const char *gmsgid, ...)\n \n   va_start (ap, gmsgid);\n   diagnostic_set_info (&diagnostic, gmsgid, &ap, input_location,\n-                       flag_isoc99 ? DK_WARNING : pedantic_error_kind ());\n+\t\t       flag_isoc99 ? DK_WARNING : pedantic_error_kind ());\n   report_diagnostic (&diagnostic);\n   va_end (ap);\n }"}, {"sha": "403724e5e110931d5f0c4e4a354e52bb55ba6756", "filename": "gcc/c-format.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -670,20 +670,20 @@ static const format_char_info time_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n   { \"ABZab\",\t\t0, STD_C89, NOLENGTHS, \"^#\",     \"\",   NULL },\n-  { \"cx\", \t\t0, STD_C89, NOLENGTHS, \"E\",      \"3\",  NULL },\n+  { \"cx\",\t\t0, STD_C89, NOLENGTHS, \"E\",      \"3\",  NULL },\n   { \"HIMSUWdmw\",\t0, STD_C89, NOLENGTHS, \"-_0Ow\",  \"\",   NULL },\n   { \"j\",\t\t0, STD_C89, NOLENGTHS, \"-_0Ow\",  \"o\",  NULL },\n   { \"p\",\t\t0, STD_C89, NOLENGTHS, \"#\",      \"\",   NULL },\n   { \"X\",\t\t0, STD_C89, NOLENGTHS, \"E\",      \"\",   NULL },\n-  { \"y\", \t\t0, STD_C89, NOLENGTHS, \"EO-_0w\", \"4\",  NULL },\n+  { \"y\",\t\t0, STD_C89, NOLENGTHS, \"EO-_0w\", \"4\",  NULL },\n   { \"Y\",\t\t0, STD_C89, NOLENGTHS, \"-_0EOw\", \"o\",  NULL },\n   { \"%\",\t\t0, STD_C89, NOLENGTHS, \"\",       \"\",   NULL },\n   /* C99 conversion specifiers.  */\n   { \"C\",\t\t0, STD_C99, NOLENGTHS, \"-_0EOw\", \"o\",  NULL },\n-  { \"D\", \t\t0, STD_C99, NOLENGTHS, \"\",       \"2\",  NULL },\n+  { \"D\",\t\t0, STD_C99, NOLENGTHS, \"\",       \"2\",  NULL },\n   { \"eVu\",\t\t0, STD_C99, NOLENGTHS, \"-_0Ow\",  \"\",   NULL },\n   { \"FRTnrt\",\t\t0, STD_C99, NOLENGTHS, \"\",       \"\",   NULL },\n-  { \"g\", \t\t0, STD_C99, NOLENGTHS, \"O-_0w\",  \"2o\", NULL },\n+  { \"g\",\t\t0, STD_C99, NOLENGTHS, \"O-_0w\",  \"2o\", NULL },\n   { \"G\",\t\t0, STD_C99, NOLENGTHS, \"-_0Ow\",  \"o\",  NULL },\n   { \"h\",\t\t0, STD_C99, NOLENGTHS, \"^#\",     \"\",   NULL },\n   { \"z\",\t\t0, STD_C99, NOLENGTHS, \"O\",      \"o\",  NULL },\n@@ -702,49 +702,49 @@ static const format_char_info monetary_char_table[] =\n /* This must be in the same order as enum format_type.  */\n static const format_kind_info format_types_orig[] =\n {\n-  { \"printf\",   printf_length_specs,  print_char_table, \" +#0-'I\", NULL, \n+  { \"printf\",   printf_length_specs,  print_char_table, \" +#0-'I\", NULL,\n     printf_flag_specs, printf_flag_pairs,\n     FMT_FLAG_ARG_CONVERT|FMT_FLAG_DOLLAR_MULTIPLE|FMT_FLAG_USE_DOLLAR|FMT_FLAG_EMPTY_PREC_OK,\n     'w', 0, 'p', 0, 'L',\n     &integer_type_node, &integer_type_node\n   },\n-  { \"asm_fprintf\",   asm_fprintf_length_specs,  asm_fprintf_char_table, \" +#0-\", NULL, \n+  { \"asm_fprintf\",   asm_fprintf_length_specs,  asm_fprintf_char_table, \" +#0-\", NULL,\n     asm_fprintf_flag_specs, asm_fprintf_flag_pairs,\n     FMT_FLAG_ARG_CONVERT|FMT_FLAG_EMPTY_PREC_OK,\n     'w', 0, 'p', 0, 'L',\n     NULL, NULL\n   },\n-  { \"gcc_diag\",   gcc_diag_length_specs,  gcc_diag_char_table, \"q+\", NULL, \n+  { \"gcc_diag\",   gcc_diag_length_specs,  gcc_diag_char_table, \"q+\", NULL,\n     gcc_diag_flag_specs, gcc_diag_flag_pairs,\n     FMT_FLAG_ARG_CONVERT,\n     0, 0, 'p', 0, 'L',\n     NULL, &integer_type_node\n   },\n-  { \"gcc_tdiag\",   gcc_tdiag_length_specs,  gcc_tdiag_char_table, \"q+\", NULL, \n+  { \"gcc_tdiag\",   gcc_tdiag_length_specs,  gcc_tdiag_char_table, \"q+\", NULL,\n     gcc_tdiag_flag_specs, gcc_tdiag_flag_pairs,\n     FMT_FLAG_ARG_CONVERT,\n     0, 0, 'p', 0, 'L',\n     NULL, &integer_type_node\n   },\n-  { \"gcc_cdiag\",   gcc_cdiag_length_specs,  gcc_cdiag_char_table, \"q+\", NULL, \n+  { \"gcc_cdiag\",   gcc_cdiag_length_specs,  gcc_cdiag_char_table, \"q+\", NULL,\n     gcc_cdiag_flag_specs, gcc_cdiag_flag_pairs,\n     FMT_FLAG_ARG_CONVERT,\n     0, 0, 'p', 0, 'L',\n     NULL, &integer_type_node\n   },\n-  { \"gcc_cxxdiag\",   gcc_cxxdiag_length_specs,  gcc_cxxdiag_char_table, \"q+#\", NULL, \n+  { \"gcc_cxxdiag\",   gcc_cxxdiag_length_specs,  gcc_cxxdiag_char_table, \"q+#\", NULL,\n     gcc_cxxdiag_flag_specs, gcc_cxxdiag_flag_pairs,\n     FMT_FLAG_ARG_CONVERT,\n     0, 0, 'p', 0, 'L',\n     NULL, &integer_type_node\n   },\n-  { \"gcc_gfc\", NULL, gcc_gfc_char_table, \"\", NULL, \n+  { \"gcc_gfc\", NULL, gcc_gfc_char_table, \"\", NULL,\n     NULL, gcc_gfc_flag_pairs,\n     FMT_FLAG_ARG_CONVERT,\n     0, 0, 0, 0, 0,\n     NULL, NULL\n   },\n-  { \"scanf\",    scanf_length_specs,   scan_char_table,  \"*'I\", NULL, \n+  { \"scanf\",    scanf_length_specs,   scan_char_table,  \"*'I\", NULL,\n     scanf_flag_specs, scanf_flag_pairs,\n     FMT_FLAG_ARG_CONVERT|FMT_FLAG_SCANF_A_KLUDGE|FMT_FLAG_USE_DOLLAR|FMT_FLAG_ZERO_WIDTH_BAD|FMT_FLAG_DOLLAR_GAP_POINTER_OK,\n     'w', 0, 0, '*', 'L',\n@@ -755,7 +755,7 @@ static const format_kind_info format_types_orig[] =\n     FMT_FLAG_FANCY_PERCENT_OK, 'w', 0, 0, 0, 0,\n     NULL, NULL\n   },\n-  { \"strfmon\",  strfmon_length_specs, monetary_char_table, \"=^+(!-\", NULL, \n+  { \"strfmon\",  strfmon_length_specs, monetary_char_table, \"=^+(!-\", NULL,\n     strfmon_flag_specs, strfmon_flag_pairs,\n     FMT_FLAG_ARG_CONVERT, 'w', '#', 'p', 0, 'L',\n     NULL, NULL\n@@ -1366,7 +1366,7 @@ check_format_arg (void *ctx, tree format_tree,\n     {\n       /* Variable length arrays can't be initialized.  */\n       gcc_assert (TREE_CODE (array_size) == INTEGER_CST);\n-      \n+\n       if (host_integerp (array_size, 0))\n \t{\n \t  HOST_WIDE_INT array_size_value = TREE_INT_CST_LOW (array_size);\n@@ -1820,7 +1820,7 @@ check_format_info_main (format_check_results *res,\n \t  ++fci;\n       if (fci->format_chars == 0)\n \t{\n-          if (ISGRAPH (format_char))\n+\t  if (ISGRAPH (format_char))\n \t    warning (OPT_Wformat, \"unknown conversion type character %qc in format\",\n \t\t     format_char);\n \t  else\n@@ -2337,7 +2337,7 @@ find_char_info_specifier_index (const format_char_info *fci, int c)\n   for (i = 0; fci->format_chars; i++, fci++)\n     if (strchr (fci->format_chars, c))\n       return i;\n-  \n+\n   /* We shouldn't be looking for a non-existent specifier.  */\n   gcc_unreachable ();\n }\n@@ -2353,7 +2353,7 @@ find_length_info_modifier_index (const format_length_info *fli, int c)\n   for (i = 0; fli->name; i++, fli++)\n     if (strchr (fli->name, c))\n       return i;\n-  \n+\n   /* We shouldn't be looking for a non-existent modifier.  */\n   gcc_unreachable ();\n }\n@@ -2370,7 +2370,7 @@ init_dynamic_asm_fprintf_info (void)\n     {\n       format_length_info *new_asm_fprintf_length_specs;\n       unsigned int i;\n-\t  \n+\n       /* Find the underlying type for HOST_WIDE_INT.  For the %w\n \t length modifier to work, one must have issued: \"typedef\n \t HOST_WIDE_INT __gcc_host_wide_int__;\" in one's source code\n@@ -2424,7 +2424,7 @@ static void\n init_dynamic_gfc_info (void)\n {\n   static tree locus;\n-  \n+\n   if (!locus)\n     {\n       static format_char_info *gfc_fci;\n@@ -2458,7 +2458,7 @@ init_dynamic_gfc_info (void)\n \t\t\t      sizeof (gcc_gfc_char_table),\n \t\t\t      sizeof (gcc_gfc_char_table));\n       if (locus)\n-        {\n+\t{\n \t  const unsigned i = find_char_info_specifier_index (gfc_fci, 'L');\n \t  gfc_fci[i].types[0].type = &locus;\n \t  gfc_fci[i].pointer_count = 1;\n@@ -2522,7 +2522,7 @@ init_dynamic_diag_info (void)\n \t\tt = TREE_TYPE (TREE_TYPE (t));\n \t    }\n \t}\n-    \n+\n       /* Find the underlying type for HOST_WIDE_INT.  For the %w\n \t length modifier to work, one must have issued: \"typedef\n \t HOST_WIDE_INT __gcc_host_wide_int__;\" in one's source code\n@@ -2551,7 +2551,7 @@ init_dynamic_diag_info (void)\n \t\t}\n \t    }\n \t}\n-      \n+\n       /* Assign the new data for use.  */\n \n       /* All the GCC diag formats use the same length specs.  */\n@@ -2563,9 +2563,9 @@ init_dynamic_diag_info (void)\n \t  diag_ls = (format_length_info *)\n \t\t    xmemdup (gcc_diag_length_specs,\n \t\t\t     sizeof (gcc_diag_length_specs),\n-\t\t\t     sizeof (gcc_diag_length_specs)); \n+\t\t\t     sizeof (gcc_diag_length_specs));\n       if (hwi)\n-        {\n+\t{\n \t  /* HOST_WIDE_INT must be one of 'long' or 'long long'.  */\n \t  i = find_length_info_modifier_index (diag_ls, 'w');\n \t  if (hwi == long_integer_type_node)\n@@ -2584,13 +2584,13 @@ init_dynamic_diag_info (void)\n \t\t\t      sizeof (gcc_diag_char_table),\n \t\t\t      sizeof (gcc_diag_char_table));\n       if (loc)\n-        {\n+\t{\n \t  i = find_char_info_specifier_index (diag_fci, 'H');\n \t  diag_fci[i].types[0].type = &loc;\n \t  diag_fci[i].pointer_count = 1;\n \t}\n       if (t)\n-        {\n+\t{\n \t  i = find_char_info_specifier_index (diag_fci, 'J');\n \t  diag_fci[i].types[0].type = &t;\n \t  diag_fci[i].pointer_count = 1;\n@@ -2604,13 +2604,13 @@ init_dynamic_diag_info (void)\n \t\t\t       sizeof (gcc_tdiag_char_table),\n \t\t\t       sizeof (gcc_tdiag_char_table));\n       if (loc)\n-        {\n+\t{\n \t  i = find_char_info_specifier_index (tdiag_fci, 'H');\n \t  tdiag_fci[i].types[0].type = &loc;\n \t  tdiag_fci[i].pointer_count = 1;\n \t}\n       if (t)\n-        {\n+\t{\n \t  /* All specifiers taking a tree share the same struct.  */\n \t  i = find_char_info_specifier_index (tdiag_fci, 'D');\n \t  tdiag_fci[i].types[0].type = &t;\n@@ -2628,13 +2628,13 @@ init_dynamic_diag_info (void)\n \t\t\t       sizeof (gcc_cdiag_char_table),\n \t\t\t       sizeof (gcc_cdiag_char_table));\n       if (loc)\n-        {\n+\t{\n \t  i = find_char_info_specifier_index (cdiag_fci, 'H');\n \t  cdiag_fci[i].types[0].type = &loc;\n \t  cdiag_fci[i].pointer_count = 1;\n \t}\n       if (t)\n-        {\n+\t{\n \t  /* All specifiers taking a tree share the same struct.  */\n \t  i = find_char_info_specifier_index (cdiag_fci, 'D');\n \t  cdiag_fci[i].types[0].type = &t;\n@@ -2652,13 +2652,13 @@ init_dynamic_diag_info (void)\n \t\t\t\t sizeof (gcc_cxxdiag_char_table),\n \t\t\t\t sizeof (gcc_cxxdiag_char_table));\n       if (loc)\n-        {\n+\t{\n \t  i = find_char_info_specifier_index (cxxdiag_fci, 'H');\n \t  cxxdiag_fci[i].types[0].type = &loc;\n \t  cxxdiag_fci[i].pointer_count = 1;\n \t}\n       if (t)\n-        {\n+\t{\n \t  /* All specifiers taking a tree share the same struct.  */\n \t  i = find_char_info_specifier_index (cxxdiag_fci, 'D');\n \t  cxxdiag_fci[i].types[0].type = &t;\n@@ -2750,22 +2750,22 @@ handle_format_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n       || info.format_type == gcc_cxxdiag_format_type)\n     {\n       /* Our first time through, we have to make sure that our\n-         format_type data is allocated dynamically and is modifiable.  */\n+\t format_type data is allocated dynamically and is modifiable.  */\n       if (!dynamic_format_types)\n \tformat_types = dynamic_format_types = (format_kind_info *)\n \t  xmemdup (format_types_orig, sizeof (format_types_orig),\n \t\t   sizeof (format_types_orig));\n \n       /* If this is format __asm_fprintf__, we have to initialize\n-         GCC's notion of HOST_WIDE_INT for checking %wd.  */\n+\t GCC's notion of HOST_WIDE_INT for checking %wd.  */\n       if (info.format_type == asm_fprintf_format_type)\n \tinit_dynamic_asm_fprintf_info ();\n       /* If this is format __gcc_gfc__, we have to initialize GCC's\n \t notion of 'locus' at runtime for %L.  */\n       else if (info.format_type == gcc_gfc_format_type)\n \tinit_dynamic_gfc_info ();\n       /* If this is one of the diagnostic attributes, then we have to\n-         initialize 'location_t' and 'tree' at runtime.  */\n+\t initialize 'location_t' and 'tree' at runtime.  */\n       else if (info.format_type == gcc_diag_format_type\n \t       || info.format_type == gcc_tdiag_format_type\n \t       || info.format_type == gcc_cdiag_format_type"}, {"sha": "60ef914159fb2c6928f336a30da38a6bda23edc3", "filename": "gcc/c-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-gimplify.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -216,7 +216,7 @@ c_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p ATTRIBUTE_UNUSED)\n \t  && !warn_init_self)\n \tTREE_NO_WARNING (DECL_EXPR_DECL (*expr_p)) = 1;\n       return GS_UNHANDLED;\n-      \n+\n     case COMPOUND_LITERAL_EXPR:\n       return gimplify_compound_literal_expr (expr_p, pre_p);\n "}, {"sha": "0e534dd2337833a59ff64a80656a1ba910b996b0", "filename": "gcc/c-incpath.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-incpath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-incpath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-incpath.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -220,25 +220,25 @@ remove_duplicates (cpp_reader *pfile, struct cpp_dir *head,\n \t  /* Remove this one if it is in the system chain.  */\n \t  reason = REASON_DUP_SYS;\n \t  for (tmp = system; tmp; tmp = tmp->next)\n-           if (INO_T_EQ (tmp->ino, cur->ino) && tmp->dev == cur->dev\n-               && cur->construct == tmp->construct)\n+\t   if (INO_T_EQ (tmp->ino, cur->ino) && tmp->dev == cur->dev\n+\t       && cur->construct == tmp->construct)\n \t      break;\n \n \t  if (!tmp)\n \t    {\n \t      /* Duplicate of something earlier in the same chain?  */\n \t      reason = REASON_DUP;\n \t      for (tmp = head; tmp != cur; tmp = tmp->next)\n-               if (INO_T_EQ (cur->ino, tmp->ino) && cur->dev == tmp->dev\n-                   && cur->construct == tmp->construct)\n+\t       if (INO_T_EQ (cur->ino, tmp->ino) && cur->dev == tmp->dev\n+\t\t   && cur->construct == tmp->construct)\n \t\t  break;\n \n \t      if (tmp == cur\n \t\t  /* Last in the chain and duplicate of JOIN?  */\n \t\t  && !(cur->next == NULL && join\n \t\t       && INO_T_EQ (cur->ino, join->ino)\n-                      && cur->dev == join->dev\n-                      && cur->construct == join->construct))\n+\t\t      && cur->dev == join->dev\n+\t\t      && cur->construct == join->construct))\n \t\t{\n \t\t  /* Unique, so keep this directory.  */\n \t\t  pcur = &cur->next;\n@@ -384,7 +384,7 @@ register_include_chains (cpp_reader *pfile, const char *sysroot,\n      include chain.  */\n   add_env_var_paths (\"CPATH\", BRACKET);\n   add_env_var_paths (lang_env_vars[idx], SYSTEM);\n-  \n+\n   target_c_incpath.extra_pre_includes (sysroot, iprefix, stdinc);\n \n   /* Finally chain on the standard directories.  */"}, {"sha": "ce231ddc4bcf003e66123e5f2cd431da1ebef340", "filename": "gcc/c-lex.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -102,7 +102,7 @@ init_c_lex (void)\n   /* Set the debug callbacks if we can use them.  */\n   if (debug_info_level == DINFO_LEVEL_VERBOSE\n       && (write_symbols == DWARF2_DEBUG\n-          || write_symbols == VMS_AND_DWARF2_DEBUG))\n+\t  || write_symbols == VMS_AND_DWARF2_DEBUG))\n     {\n       cb->define = cb_define;\n       cb->undef = cb_undef;\n@@ -223,12 +223,12 @@ fe_file_change (const struct line_map *new_map)\n       if (!MAIN_FILE_P (new_map))\n \t{\n #ifdef USE_MAPPED_LOCATION\n-          int included_at = LAST_SOURCE_LINE_LOCATION (new_map - 1);\n+\t  int included_at = LAST_SOURCE_LINE_LOCATION (new_map - 1);\n \n \t  input_location = included_at;\n \t  push_srcloc (new_map->start_location);\n #else\n-          int included_at = LAST_SOURCE_LINE (new_map - 1);\n+\t  int included_at = LAST_SOURCE_LINE (new_map - 1);\n \n \t  input_line = included_at;\n \t  push_srcloc (new_map->to_file, 1);\n@@ -339,7 +339,7 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags)\n  retry:\n   tok = cpp_get_token (parse_in);\n   type = tok->type;\n-  \n+\n  retry_after_at:\n #ifdef USE_MAPPED_LOCATION\n   *loc = tok->src_loc;\n@@ -350,7 +350,7 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags)\n     {\n     case CPP_PADDING:\n       goto retry;\n-      \n+\n     case CPP_NAME:\n       *value = HT_IDENT_TO_GCC_IDENT (HT_NODE (tok->val.node));\n       break;\n@@ -389,15 +389,15 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags)\n       if (c_dialect_objc ())\n \t{\n \t  location_t atloc = input_location;\n-\t  \n+\n \tretry_at:\n \t  tok = cpp_get_token (parse_in);\n \t  type = tok->type;\n \t  switch (type)\n \t    {\n \t    case CPP_PADDING:\n \t      goto retry_at;\n-\t      \n+\n \t    case CPP_STRING:\n \t    case CPP_WSTRING:\n \t      type = lex_string (tok, value, true);\n@@ -425,12 +425,12 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags)\n     case CPP_PASTE:\n       {\n \tunsigned char name[4];\n-\t\n+\n \t*cpp_spell_token (parse_in, tok, name, true) = 0;\n-\t\n+\n \terror (\"stray %qs in program\", name);\n       }\n-      \n+\n       goto retry;\n \n     case CPP_OTHER:\n@@ -484,9 +484,9 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags)\n       no_more_pch = true;\n       c_common_no_more_pch ();\n     }\n-  \n+\n   timevar_pop (TV_CPP);\n-  \n+\n   return type;\n }\n \n@@ -539,7 +539,7 @@ narrowest_signed_type (unsigned HOST_WIDE_INT low,\n   for (; itk < itk_none; itk += 2 /* skip signed types */)\n     {\n       tree upper = TYPE_MAX_VALUE (integer_types[itk]);\n-      \n+\n       if ((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (upper) > high\n \t  || ((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (upper) == high\n \t      && TREE_INT_CST_LOW (upper) >= low))\n@@ -740,21 +740,21 @@ lex_string (const cpp_token *tok, tree *valp, bool objc_string)\n \t  goto retry;\n \t}\n       /* FALLTHROUGH */\n-      \n+\n     default:\n       break;\n-      \n+\n     case CPP_WSTRING:\n       wide = true;\n       /* FALLTHROUGH */\n-      \n+\n     case CPP_STRING:\n       if (!concats)\n \t{\n \t  gcc_obstack_init (&str_ob);\n \t  obstack_grow (&str_ob, &str, sizeof (cpp_string));\n \t}\n-\t\n+\n       concats++;\n       obstack_grow (&str_ob, &tok->val.str, sizeof (cpp_string));\n       goto retry;\n@@ -784,7 +784,7 @@ lex_string (const cpp_token *tok, tree *valp, bool objc_string)\n \t  /* Assume that, if we managed to translate the string above,\n \t     then the untranslated parsing will always succeed.  */\n \t  gcc_assert (xlated);\n-\t  \n+\n \t  if (TREE_STRING_LENGTH (value) != (int) istr.len\n \t      || 0 != strncmp (TREE_STRING_POINTER (value), (char *) istr.text,\n \t\t\t       istr.len))"}, {"sha": "d4ad1f89f26849ab2c9c8cc89fee83894c28c29c", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -198,7 +198,7 @@ c_tree_printer (pretty_printer *pp, text_info *text, const char *spec,\n     case 'T':\n       gcc_assert (TYPE_P (t));\n       name = TYPE_NAME (t);\n-      \n+\n       if (name && TREE_CODE (name) == TYPE_DECL)\n \t{\n \t  if (DECL_NAME (name))"}, {"sha": "ea631b0530af7dc1550c748ad9ef6ef966f19ac8", "filename": "gcc/c-opts.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -741,7 +741,7 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n     case OPT_freplace_objc_classes:\n       flag_replace_objc_classes = value;\n       break;\n-      \n+\n     case OPT_frepo:\n       flag_use_repository = value;\n       if (value)\n@@ -789,7 +789,7 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n     case OPT_fuse_cxa_get_exception_ptr:\n       flag_use_cxa_get_exception_ptr = value;\n       break;\n-      \n+\n     case OPT_fvisibility_inlines_hidden:\n       visibility_options.inlines_hidden = value;\n       break;\n@@ -1173,7 +1173,7 @@ c_common_parse_file (int set_yydebug)\n       this_input_filename\n \t= cpp_read_main_file (parse_in, in_fnames[i]);\n       /* If an input file is missing, abandon further compilation.\n-         cpplib has issued a diagnostic.  */\n+\t cpplib has issued a diagnostic.  */\n       if (!this_input_filename)\n \tbreak;\n     }"}, {"sha": "eeb0ce90a830171362471104be704339289edfa1", "filename": "gcc/c-parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -2229,7 +2229,7 @@ c_parser_typeof_specifier (c_parser *parser)\n \t\t\t parameter-type-list[opt] )\n \n    direct-abstract-declarator:\n-     direct-abstract-declarator[opt] ( parameter-forward-declarations \n+     direct-abstract-declarator[opt] ( parameter-forward-declarations\n \t\t\t\t       parameter-type-list[opt] )\n \n    parameter-forward-declarations:"}, {"sha": "76e40fb0a2686c96841931ff95914894112f0f1a", "filename": "gcc/c-pch.c", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-pch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-pch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pch.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -39,7 +39,7 @@ Boston, MA 02110-1301, USA.  */\n    names for the error message.  The possible values for *flag_var must\n    fit in a 'signed char'.  */\n \n-static const struct c_pch_matching \n+static const struct c_pch_matching\n {\n   int *flag_var;\n   const char *flag_name;\n@@ -69,7 +69,7 @@ struct c_pch_validity\n   size_t target_data_length;\n };\n \n-struct c_pch_header \n+struct c_pch_header\n {\n   unsigned long asm_size;\n };\n@@ -95,15 +95,15 @@ get_ident (void)\n   static char result[IDENT_LENGTH];\n   static const char template[IDENT_LENGTH] = \"gpch.013\";\n   static const char c_language_chars[] = \"Co+O\";\n-  \n+\n   memcpy (result, template, IDENT_LENGTH);\n   result[4] = c_language_chars[c_language];\n \n   return result;\n }\n \n /* Prepare to write a PCH file, if one is being written.  This is\n-   called at the start of compilation.  \n+   called at the start of compilation.\n \n    Also, print out the executable checksum if -fverbose-asm is in effect.  */\n \n@@ -114,7 +114,7 @@ pch_init (void)\n   struct c_pch_validity v;\n   void *target_validity;\n   static const char partial_pch[IDENT_LENGTH] = \"gpcWrite\";\n-  \n+\n #ifdef ASM_COMMENT_START\n   if (flag_verbose_asm)\n     {\n@@ -123,17 +123,17 @@ pch_init (void)\n       fputc ('\\n', asm_out_file);\n     }\n #endif\n-  \n+\n   if (!pch_file)\n     return;\n-  \n+\n   f = fopen (pch_file, \"w+b\");\n   if (f == NULL)\n     fatal_error (\"can%'t create precompiled header %s: %m\", pch_file);\n   pch_outfile = f;\n \n   gcc_assert (memcmp (executable_checksum, no_checksum, 16) != 0);\n-  \n+\n   v.debug_info_type = write_symbols;\n   {\n     size_t i;\n@@ -145,7 +145,7 @@ pch_init (void)\n   }\n   v.pch_init = &pch_init;\n   target_validity = targetm.get_pch_validity (&v.target_data_length);\n-  \n+\n   if (fwrite (partial_pch, IDENT_LENGTH, 1, f) != 1\n       || fwrite (executable_checksum, 16, 1, f) != 1\n       || fwrite (&v, sizeof (v), 1, f) != 1\n@@ -157,12 +157,12 @@ pch_init (void)\n   if (asm_file_name == NULL\n       || strcmp (asm_file_name, \"-\") == 0)\n     fatal_error (\"%qs is not a valid output file\", asm_file_name);\n-  \n+\n   asm_file_startpos = ftell (asm_out_file);\n-  \n+\n   /* Let the debugging format deal with the PCHness.  */\n   (*debug_hooks->handle_pch) (0);\n-  \n+\n   cpp_save_state (parse_in, f);\n }\n \n@@ -183,10 +183,10 @@ c_common_write_pch (void)\n \n   asm_file_end = ftell (asm_out_file);\n   h.asm_size = asm_file_end - asm_file_startpos;\n-  \n+\n   if (fwrite (&h, sizeof (h), 1, pch_outfile) != 1)\n     fatal_error (\"can%'t write %s: %m\", pch_file);\n-  \n+\n   buf = XNEWVEC (char, 16384);\n \n   if (fseek (asm_out_file, asm_file_startpos, SEEK_SET) != 0)\n@@ -247,7 +247,7 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n \t\t name);\n       return 2;\n     }\n-  \n+\n   pch_ident = get_ident();\n   if (memcmp (ident, pch_ident, IDENT_LENGTH) != 0)\n     {\n@@ -256,13 +256,13 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n \t  if (memcmp (ident, pch_ident, 5) == 0)\n \t    /* It's a PCH, for the right language, but has the wrong version.\n \t     */\n-\t    cpp_error (pfile, CPP_DL_WARNING, \n+\t    cpp_error (pfile, CPP_DL_WARNING,\n \t\t       \"%s: not compatible with this GCC version\", name);\n \t  else if (memcmp (ident, pch_ident, 4) == 0)\n \t    /* It's a PCH for the wrong language.  */\n \t    cpp_error (pfile, CPP_DL_WARNING, \"%s: not for %s\", name,\n \t\t       lang_hooks.name);\n-\t  else \n+\t  else\n \t    /* Not any kind of PCH.  */\n \t    cpp_error (pfile, CPP_DL_WARNING, \"%s: not a PCH file\", name);\n \t}\n@@ -289,7 +289,7 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n       && write_symbols != NO_DEBUG)\n     {\n       if (cpp_get_options (pfile)->warn_invalid_pch)\n-\tcpp_error (pfile, CPP_DL_WARNING, \n+\tcpp_error (pfile, CPP_DL_WARNING,\n \t\t   \"%s: created with -g%s, but used with -g%s\", name,\n \t\t   debug_type_names[v.debug_info_type],\n \t\t   debug_type_names[write_symbols]);\n@@ -303,7 +303,7 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n       if (*pch_matching[i].flag_var != v.match[i])\n \t{\n \t  if (cpp_get_options (pfile)->warn_invalid_pch)\n-\t    cpp_error (pfile, CPP_DL_WARNING, \n+\t    cpp_error (pfile, CPP_DL_WARNING,\n \t\t       \"%s: settings for %s do not match\", name,\n \t\t       pch_matching[i].flag_name);\n \t  return 2;\n@@ -313,13 +313,13 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n   /* If the text segment was not loaded at the same address as it was\n      when the PCH file was created, function pointers loaded from the\n      PCH will not be valid.  We could in theory remap all the function\n-     pointers, but no support for that exists at present.  \n+     pointers, but no support for that exists at present.\n      Since we have the same executable, it should only be necessary to\n      check one function.  */\n   if (v.pch_init != &pch_init)\n     {\n       if (cpp_get_options (pfile)->warn_invalid_pch)\n-\tcpp_error (pfile, CPP_DL_WARNING, \n+\tcpp_error (pfile, CPP_DL_WARNING,\n \t\t   \"%s: had text segment at different address\", name);\n       return 2;\n     }\n@@ -328,7 +328,7 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n   {\n     void *this_file_data = xmalloc (v.target_data_length);\n     const char *msg;\n-    \n+\n     if ((size_t) read (fd, this_file_data, v.target_data_length)\n \t!= v.target_data_length)\n       fatal_error (\"can%'t read %s: %m\", name);\n@@ -344,7 +344,7 @@ c_common_valid_pch (cpp_reader *pfile, const char *name, int fd)\n \n   /* Check the preprocessor macros are the same as when the PCH was\n      generated.  */\n-  \n+\n   result = cpp_valid_state (pfile, name, fd);\n   if (result == -1)\n     return 2;\n@@ -366,7 +366,7 @@ c_common_read_pch (cpp_reader *pfile, const char *name,\n   FILE *f;\n   struct c_pch_header h;\n   struct save_macro_data *smd;\n-  \n+\n   f = fdopen (fd, \"rb\");\n   if (f == NULL)\n     {\n@@ -415,7 +415,7 @@ c_common_read_pch (cpp_reader *pfile, const char *name,\n     return;\n \n   fclose (f);\n-  \n+\n   /* Give the front end a chance to take action after a PCH file has\n      been loaded.  */\n   if (lang_post_pch_load)\n@@ -455,16 +455,16 @@ c_common_pch_pragma (cpp_reader *pfile, const char *name)\n   fd = open (name, O_RDONLY | O_BINARY, 0666);\n   if (fd == -1)\n     fatal_error (\"%s: couldn%'t open PCH file: %m\", name);\n-  \n+\n   if (c_common_valid_pch (pfile, name, fd) != 1)\n     {\n       if (!cpp_get_options (pfile)->warn_invalid_pch)\n \tinform (\"use -Winvalid-pch for more information\");\n       fatal_error (\"%s: PCH file was invalid\", name);\n     }\n-  \n+\n   c_common_read_pch (pfile, name, fd, name);\n-  \n+\n   close (fd);\n }\n "}, {"sha": "2c4640cc460b5e6c1993f771de6e38994560e959", "filename": "gcc/c-ppoutput.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-ppoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-ppoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-ppoutput.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -451,7 +451,7 @@ cb_read_pch (cpp_reader *pfile, const char *name,\n \t     int fd, const char *orig_name ATTRIBUTE_UNUSED)\n {\n   c_common_read_pch (pfile, name, fd, orig_name);\n-  \n+\n   fprintf (print.outf, \"#pragma GCC pch_preprocess \\\"%s\\\"\\n\", name);\n   print.src_line++;\n }"}, {"sha": "e71ab07a16f40aaea9ef3b31b98598a8e0930504", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -46,8 +46,8 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n typedef struct align_stack GTY(())\n {\n-  int                  alignment;\n-  tree                 id;\n+  int\t\t       alignment;\n+  tree\t\t       id;\n   struct align_stack * prev;\n } align_stack;\n \n@@ -58,8 +58,8 @@ static void handle_pragma_pack (cpp_reader *);\n \n #ifdef HANDLE_PRAGMA_PACK_PUSH_POP\n /* If we have a \"global\" #pragma pack(<n>) in effect when the first\n-   #pragma pack(push,<n>) is encountered, this stores the value of \n-   maximum_field_alignment in effect.  When the final pop_alignment() \n+   #pragma pack(push,<n>) is encountered, this stores the value of\n+   maximum_field_alignment in effect.  When the final pop_alignment()\n    happens, we restore the value to this, not to a value of 0 for\n    maximum_field_alignment.  Value is in bits.  */\n static int default_alignment;\n@@ -79,15 +79,15 @@ push_alignment (int alignment, tree id)\n   entry = GGC_NEW (align_stack);\n \n   entry->alignment  = alignment;\n-  entry->id         = id;\n-  entry->prev       = alignment_stack;\n-       \n-  /* The current value of maximum_field_alignment is not necessarily \n-     0 since there may be a #pragma pack(<n>) in effect; remember it \n+  entry->id\t    = id;\n+  entry->prev\t    = alignment_stack;\n+\n+  /* The current value of maximum_field_alignment is not necessarily\n+     0 since there may be a #pragma pack(<n>) in effect; remember it\n      so that we can restore it after the final #pragma pop().  */\n   if (alignment_stack == NULL)\n     default_alignment = maximum_field_alignment;\n- \n+\n   alignment_stack = entry;\n \n   maximum_field_alignment = alignment;\n@@ -98,7 +98,7 @@ static void\n pop_alignment (tree id)\n {\n   align_stack * entry;\n-      \n+\n   if (alignment_stack == NULL)\n     GCC_BAD (\"#pragma pack (pop) encountered without matching #pragma pack (push)\");\n \n@@ -134,7 +134,7 @@ pop_alignment (tree id)\n \n /* #pragma pack ()\n    #pragma pack (N)\n-   \n+\n    #pragma pack (push)\n    #pragma pack (push, N)\n    #pragma pack (push, ID)\n@@ -236,7 +236,7 @@ handle_pragma_pack (cpp_reader * ARG_UNUSED (dummy))\n     {\n     case set:   SET_GLOBAL_ALIGNMENT (align);  break;\n     case push:  push_alignment (align, id);    break;\n-    case pop:   pop_alignment (id);            break;\n+    case pop:   pop_alignment (id);\t       break;\n     }\n }\n #endif  /* HANDLE_PRAGMA_PACK */\n@@ -263,7 +263,7 @@ apply_pragma_weak (tree decl, tree value)\n       && !DECL_WEAK (decl) /* Don't complain about a redundant #pragma.  */\n       && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n     warning (OPT_Wpragmas, \"applying #pragma weak %q+D after first use \"\n-             \"results in unspecified behavior\", decl);\n+\t     \"results in unspecified behavior\", decl);\n \n   declare_weak (decl);\n }\n@@ -468,7 +468,7 @@ add_to_renaming_pragma_list (tree oldname, tree newname)\n \t\t \"conflict with previous #pragma redefine_extname\");\n       return;\n     }\n-  \n+\n   pending_redefine_extname\n     = tree_cons (oldname, newname, pending_redefine_extname);\n }\n@@ -545,7 +545,7 @@ maybe_apply_renaming_pragma (tree decl, tree asmname)\n \t*p = TREE_CHAIN (t);\n \n \t/* If we already have an asmname, #pragma redefine_extname is\n- \t   ignored (with a warning if it conflicts).  */\n+\t   ignored (with a warning if it conflicts).  */\n \tif (asmname)\n \t  {\n \t    if (strcmp (TREE_STRING_POINTER (asmname),\n@@ -573,7 +573,7 @@ maybe_apply_renaming_pragma (tree decl, tree asmname)\n \n       const char *id = IDENTIFIER_POINTER (DECL_NAME (decl));\n       size_t ilen = IDENTIFIER_LENGTH (DECL_NAME (decl));\n-\t\n+\n       char *newname = (char *) alloca (plen + ilen + 1);\n \n       memcpy (newname,        prefix, plen);\n@@ -608,7 +608,7 @@ push_visibility (const char *str)\n   else if (!strcmp (str, \"internal\"))\n     default_visibility = VISIBILITY_INTERNAL;\n   else if (!strcmp (str, \"hidden\"))\n-    default_visibility = VISIBILITY_HIDDEN;  \n+    default_visibility = VISIBILITY_HIDDEN;\n   else if (!strcmp (str, \"protected\"))\n     default_visibility = VISIBILITY_PROTECTED;\n   else\n@@ -624,7 +624,7 @@ pop_visibility (void)\n   default_visibility = VEC_pop (visibility, visstack);\n   visibility_options.inpragma\n     = VEC_length (visibility, visstack) != 0;\n-}  \n+}\n \n /* Sets the default visibility for symbols to something other than that\n    specified on the command line.  */\n@@ -636,39 +636,39 @@ handle_pragma_visibility (cpp_reader *dummy ATTRIBUTE_UNUSED)\n   tree x;\n   enum cpp_ttype token;\n   enum { bad, push, pop } action = bad;\n- \n+\n   token = pragma_lex (&x);\n   if (token == CPP_NAME)\n     {\n       const char *op = IDENTIFIER_POINTER (x);\n       if (!strcmp (op, \"push\"))\n-        action = push;\n+\taction = push;\n       else if (!strcmp (op, \"pop\"))\n-        action = pop;\n+\taction = pop;\n     }\n   if (bad == action)\n     GCC_BAD (\"#pragma GCC visibility must be followed by push or pop\");\n   else\n     {\n       if (pop == action)\n-        {\n-          if (!VEC_length (visibility, visstack))\n+\t{\n+\t  if (!VEC_length (visibility, visstack))\n \t    GCC_BAD (\"no matching push for %<#pragma GCC visibility pop%>\");\n-          else\n+\t  else\n \t    pop_visibility ();\n-        }\n+\t}\n       else\n-        {\n-          if (pragma_lex (&x) != CPP_OPEN_PAREN)\n-            GCC_BAD (\"missing %<(%> after %<#pragma GCC visibility push%> - ignored\");\n-          token = pragma_lex (&x);\n-          if (token != CPP_NAME)\n+\t{\n+\t  if (pragma_lex (&x) != CPP_OPEN_PAREN)\n+\t    GCC_BAD (\"missing %<(%> after %<#pragma GCC visibility push%> - ignored\");\n+\t  token = pragma_lex (&x);\n+\t  if (token != CPP_NAME)\n \t    GCC_BAD (\"malformed #pragma GCC visibility push\");\n-          else\n+\t  else\n \t    push_visibility (IDENTIFIER_POINTER (x));\n-          if (pragma_lex (&x) != CPP_CLOSE_PAREN)\n-            GCC_BAD (\"missing %<(%> after %<#pragma GCC visibility push%> - ignored\");\n-        }\n+\t  if (pragma_lex (&x) != CPP_CLOSE_PAREN)\n+\t    GCC_BAD (\"missing %<(%> after %<#pragma GCC visibility push%> - ignored\");\n+\t}\n     }\n   if (pragma_lex (&x) != CPP_EOF)\n     warning (OPT_Wpragmas, \"junk at end of %<#pragma GCC visibility%>\");"}, {"sha": "a38d95aececd28cd7d17b6f4b645f6c55bd98cd1", "filename": "gcc/c-pragma.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.h?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -99,7 +99,7 @@ extern enum cpp_ttype pragma_lex (tree *);\n    having enum cpp_ttype declared.  */\n extern enum cpp_ttype c_lex_with_flags (tree *, location_t *, unsigned char *);\n \n-/* If 1, then lex strings into the execution character set.  \n+/* If 1, then lex strings into the execution character set.\n    If 0, lex strings into the host character set.\n    If -1, lex both, and chain them together, such that the former\n    is the TREE_CHAIN of the latter.  */"}, {"sha": "4f1dbbc00dbaec66b945e5eac72fdc965d3c07aa", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 98, "deletions": 98, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -199,8 +199,8 @@ pp_c_space_for_pointer_operator (c_pretty_printer *pp, tree t)\n     {\n       tree pointee = strip_pointer_operator (TREE_TYPE (t));\n       if (TREE_CODE (pointee) != ARRAY_TYPE\n-          && TREE_CODE (pointee) != FUNCTION_TYPE)\n-        pp_c_whitespace (pp);\n+\t  && TREE_CODE (pointee) != FUNCTION_TYPE)\n+\tpp_c_whitespace (pp);\n     }\n }\n \n@@ -253,11 +253,11 @@ pp_c_pointer (c_pretty_printer *pp, tree t)\n       /* It is easier to handle C++ reference types here.  */\n     case REFERENCE_TYPE:\n       if (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE)\n-        pp_c_pointer (pp, TREE_TYPE (t));\n+\tpp_c_pointer (pp, TREE_TYPE (t));\n       if (TREE_CODE (t) == POINTER_TYPE)\n-        pp_c_star (pp);\n+\tpp_c_star (pp);\n       else\n-        pp_c_ampersand (pp);\n+\tpp_c_ampersand (pp);\n       pp_c_type_qualifier_list (pp, t);\n       break;\n \n@@ -406,18 +406,18 @@ pp_c_specifier_qualifier_list (c_pretty_printer *pp, tree t)\n     case REFERENCE_TYPE:\n     case POINTER_TYPE:\n       {\n-        /* Get the types-specifier of this type.  */\n-        tree pointee = strip_pointer_operator (TREE_TYPE (t));\n-        pp_c_specifier_qualifier_list (pp, pointee);\n-        if (TREE_CODE (pointee) == ARRAY_TYPE\n-            || TREE_CODE (pointee) == FUNCTION_TYPE)\n-          {\n-            pp_c_whitespace (pp);\n-            pp_c_left_paren (pp);\n-          }\n+\t/* Get the types-specifier of this type.  */\n+\ttree pointee = strip_pointer_operator (TREE_TYPE (t));\n+\tpp_c_specifier_qualifier_list (pp, pointee);\n+\tif (TREE_CODE (pointee) == ARRAY_TYPE\n+\t    || TREE_CODE (pointee) == FUNCTION_TYPE)\n+\t  {\n+\t    pp_c_whitespace (pp);\n+\t    pp_c_left_paren (pp);\n+\t  }\n \telse if (!c_dialect_cxx ())\n \t  pp_c_whitespace (pp);\n-        pp_ptr_operator (pp, t);\n+\tpp_ptr_operator (pp, t);\n       }\n       break;\n \n@@ -430,9 +430,9 @@ pp_c_specifier_qualifier_list (c_pretty_printer *pp, tree t)\n     case COMPLEX_TYPE:\n       pp_c_specifier_qualifier_list (pp, TREE_TYPE (t));\n       if (code == COMPLEX_TYPE)\n-        pp_c_identifier (pp, flag_isoc99 ? \"_Complex\" : \"__complex__\");\n+\tpp_c_identifier (pp, flag_isoc99 ? \"_Complex\" : \"__complex__\");\n       else if (code == VECTOR_TYPE)\n-        pp_c_identifier (pp, \"__vector__\");\n+\tpp_c_identifier (pp, \"__vector__\");\n       break;\n \n     default:\n@@ -465,17 +465,17 @@ pp_c_parameter_type_list (c_pretty_printer *pp, tree t)\n     {\n       bool first = true;\n       for ( ; parms && parms != void_list_node; parms = TREE_CHAIN (parms))\n-        {\n-          if (!first)\n-            pp_separate_with (pp, ',');\n-          first = false;\n-          pp_declaration_specifiers\n-            (pp, want_parm_decl ? parms : TREE_VALUE (parms));\n-          if (want_parm_decl)\n-            pp_declarator (pp, parms);\n-          else\n-            pp_abstract_declarator (pp, TREE_VALUE (parms));\n-        }\n+\t{\n+\t  if (!first)\n+\t    pp_separate_with (pp, ',');\n+\t  first = false;\n+\t  pp_declaration_specifiers\n+\t    (pp, want_parm_decl ? parms : TREE_VALUE (parms));\n+\t  if (want_parm_decl)\n+\t    pp_declarator (pp, parms);\n+\t  else\n+\t    pp_abstract_declarator (pp, TREE_VALUE (parms));\n+\t}\n     }\n   pp_c_right_paren (pp);\n }\n@@ -490,8 +490,8 @@ pp_c_abstract_declarator (c_pretty_printer *pp, tree t)\n   if (TREE_CODE (t) == POINTER_TYPE)\n     {\n       if (TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE\n-          || TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n-        pp_c_right_paren (pp);\n+\t  || TREE_CODE (TREE_TYPE (t)) == FUNCTION_TYPE)\n+\tpp_c_right_paren (pp);\n       t = TREE_TYPE (t);\n     }\n \n@@ -579,9 +579,9 @@ pp_c_storage_class_specifier (c_pretty_printer *pp, tree t)\n   else if (DECL_P (t))\n     {\n       if (DECL_REGISTER (t))\n-        pp_c_identifier (pp, \"register\");\n+\tpp_c_identifier (pp, \"register\");\n       else if (TREE_STATIC (t) && TREE_CODE (t) == VAR_DECL)\n-        pp_c_identifier (pp, \"static\");\n+\tpp_c_identifier (pp, \"static\");\n     }\n }\n \n@@ -647,12 +647,12 @@ pp_c_direct_declarator (c_pretty_printer *pp, tree t)\n       pp_c_space_for_pointer_operator (pp, TREE_TYPE (TREE_TYPE (t)));\n       pp_c_tree_decl_identifier (pp, t);\n       if (pp_c_base (pp)->flags & pp_c_flag_abstract)\n-        pp_abstract_declarator (pp, TREE_TYPE (t));\n+\tpp_abstract_declarator (pp, TREE_TYPE (t));\n       else\n-        {\n-          pp_parameter_list (pp, t);\n-          pp_abstract_declarator (pp, TREE_TYPE (TREE_TYPE (t)));\n-        }\n+\t{\n+\t  pp_parameter_list (pp, t);\n+\t  pp_abstract_declarator (pp, TREE_TYPE (TREE_TYPE (t)));\n+\t}\n       break;\n \n     case INTEGER_TYPE:\n@@ -726,7 +726,7 @@ pp_c_attributes (c_pretty_printer *pp, tree attributes)\n     {\n       pp_tree_identifier (pp, TREE_PURPOSE (attributes));\n       if (TREE_VALUE (attributes))\n-        pp_c_call_argument_list (pp, TREE_VALUE (attributes));\n+\tpp_c_call_argument_list (pp, TREE_VALUE (attributes));\n \n       if (TREE_CHAIN (attributes))\n \tpp_separate_with (pp, ',');\n@@ -811,24 +811,24 @@ pp_c_integer_constant (c_pretty_printer *pp, tree i)\n   else\n     {\n       if (tree_int_cst_sgn (i) < 0)\n-        {\n-          pp_character (pp, '-');\n-          i = build_int_cst_wide (NULL_TREE,\n+\t{\n+\t  pp_character (pp, '-');\n+\t  i = build_int_cst_wide (NULL_TREE,\n \t\t\t\t  -TREE_INT_CST_LOW (i),\n \t\t\t\t  ~TREE_INT_CST_HIGH (i)\n \t\t\t\t  + !TREE_INT_CST_LOW (i));\n-        }\n+\t}\n       sprintf (pp_buffer (pp)->digit_buffer,\n-               HOST_WIDE_INT_PRINT_DOUBLE_HEX,\n-               TREE_INT_CST_HIGH (i), TREE_INT_CST_LOW (i));\n+\t       HOST_WIDE_INT_PRINT_DOUBLE_HEX,\n+\t       TREE_INT_CST_HIGH (i), TREE_INT_CST_LOW (i));\n       pp_string (pp, pp_buffer (pp)->digit_buffer);\n     }\n   if (TYPE_UNSIGNED (type))\n     pp_character (pp, 'u');\n   if (type == long_integer_type_node || type == long_unsigned_type_node)\n     pp_character (pp, 'l');\n   else if (type == long_long_integer_type_node\n-           || type == long_long_unsigned_type_node)\n+\t   || type == long_long_unsigned_type_node)\n     pp_string (pp, \"ll\");\n }\n \n@@ -967,16 +967,16 @@ pp_c_constant (c_pretty_printer *pp, tree e)\n     {\n     case INTEGER_CST:\n       {\n-        tree type = TREE_TYPE (e);\n-        if (type == boolean_type_node)\n-          pp_c_bool_constant (pp, e);\n-        else if (type == char_type_node)\n-          pp_c_character_constant (pp, e);\n-        else if (TREE_CODE (type) == ENUMERAL_TYPE\n-                 && pp_c_enumeration_constant (pp, e))\n-          ;\n-        else\n-          pp_c_integer_constant (pp, e);\n+\ttree type = TREE_TYPE (e);\n+\tif (type == boolean_type_node)\n+\t  pp_c_bool_constant (pp, e);\n+\telse if (type == char_type_node)\n+\t  pp_c_character_constant (pp, e);\n+\telse if (TREE_CODE (type) == ENUMERAL_TYPE\n+\t\t && pp_c_enumeration_constant (pp, e))\n+\t  ;\n+\telse\n+\t  pp_c_integer_constant (pp, e);\n       }\n       break;\n \n@@ -1097,22 +1097,22 @@ pp_c_init_declarator (c_pretty_printer *pp, tree t)\n     {\n       tree init = DECL_INITIAL (t);\n       /* This C++ bit is handled here because it is easier to do so.\n-         In templates, the C++ parser builds a TREE_LIST for a\n-         direct-initialization; the TREE_PURPOSE is the variable to\n-         initialize and the TREE_VALUE is the initializer.  */\n+\t In templates, the C++ parser builds a TREE_LIST for a\n+\t direct-initialization; the TREE_PURPOSE is the variable to\n+\t initialize and the TREE_VALUE is the initializer.  */\n       if (TREE_CODE (init) == TREE_LIST)\n-        {\n-          pp_c_left_paren (pp);\n-          pp_expression (pp, TREE_VALUE (init));\n-          pp_right_paren (pp);\n-        }\n+\t{\n+\t  pp_c_left_paren (pp);\n+\t  pp_expression (pp, TREE_VALUE (init));\n+\t  pp_right_paren (pp);\n+\t}\n       else\n-        {\n-          pp_space (pp);\n-          pp_equal (pp);\n-          pp_space (pp);\n-          pp_c_initializer (pp, init);\n-        }\n+\t{\n+\t  pp_space (pp);\n+\t  pp_equal (pp);\n+\t  pp_space (pp);\n+\t  pp_c_initializer (pp, init);\n+\t}\n     }\n }\n \n@@ -1143,38 +1143,38 @@ pp_c_initializer_list (c_pretty_printer *pp, tree e)\n     case UNION_TYPE:\n     case ARRAY_TYPE:\n       {\n-        tree init = TREE_OPERAND (e, 0);\n-        for (; init != NULL_TREE; init = TREE_CHAIN (init))\n-          {\n-            if (code == RECORD_TYPE || code == UNION_TYPE)\n-              {\n-                pp_c_dot (pp);\n-                pp_c_primary_expression (pp, TREE_PURPOSE (init));\n-              }\n-            else\n-              {\n-                pp_c_left_bracket (pp);\n-                if (TREE_PURPOSE (init))\n-                  pp_c_constant (pp, TREE_PURPOSE (init));\n-                pp_c_right_bracket (pp);\n-              }\n-            pp_c_whitespace (pp);\n-            pp_equal (pp);\n-            pp_c_whitespace (pp);\n-            pp_initializer (pp, TREE_VALUE (init));\n-            if (TREE_CHAIN (init))\n-              pp_separate_with (pp, ',');\n-          }\n+\ttree init = TREE_OPERAND (e, 0);\n+\tfor (; init != NULL_TREE; init = TREE_CHAIN (init))\n+\t  {\n+\t    if (code == RECORD_TYPE || code == UNION_TYPE)\n+\t      {\n+\t\tpp_c_dot (pp);\n+\t\tpp_c_primary_expression (pp, TREE_PURPOSE (init));\n+\t      }\n+\t    else\n+\t      {\n+\t\tpp_c_left_bracket (pp);\n+\t\tif (TREE_PURPOSE (init))\n+\t\t  pp_c_constant (pp, TREE_PURPOSE (init));\n+\t\tpp_c_right_bracket (pp);\n+\t      }\n+\t    pp_c_whitespace (pp);\n+\t    pp_equal (pp);\n+\t    pp_c_whitespace (pp);\n+\t    pp_initializer (pp, TREE_VALUE (init));\n+\t    if (TREE_CHAIN (init))\n+\t      pp_separate_with (pp, ',');\n+\t  }\n       }\n       return;\n \n     case VECTOR_TYPE:\n       if (TREE_CODE (e) == VECTOR_CST)\n-        pp_c_expression_list (pp, TREE_VECTOR_CST_ELTS (e));\n+\tpp_c_expression_list (pp, TREE_VECTOR_CST_ELTS (e));\n       else if (TREE_CODE (e) == CONSTRUCTOR)\n-        pp_c_constructor_elts (pp, CONSTRUCTOR_ELTS (e));\n+\tpp_c_constructor_elts (pp, CONSTRUCTOR_ELTS (e));\n       else\n-        break;\n+\tbreak;\n       return;\n \n     case COMPLEX_TYPE:\n@@ -1379,10 +1379,10 @@ pp_c_postfix_expression (c_pretty_printer *pp, tree e)\n \n     case ADDR_EXPR:\n       if (TREE_CODE (TREE_OPERAND (e, 0)) == FUNCTION_DECL)\n-        {\n-          pp_c_id_expression (pp, TREE_OPERAND (e, 0));\n-          break;\n-        }\n+\t{\n+\t  pp_c_id_expression (pp, TREE_OPERAND (e, 0));\n+\t  break;\n+\t}\n       /* else fall through.  */\n \n     default:"}, {"sha": "6a4086b4fc2c6f3f389e83f314999869310eea07", "filename": "gcc/c-pretty-print.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.h?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -30,7 +30,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n typedef enum\n   {\n      pp_c_flag_abstract = 1 << 1,\n-     pp_c_flag_last_bit = 2    \n+     pp_c_flag_last_bit = 2\n   } pp_c_pretty_print_flags;\n \n \n@@ -60,7 +60,7 @@ struct c_pretty_print_info\n   int *offset_list;\n \n   pp_flags flags;\n-   \n+\n   /* These must be overridden by each of the C and C++ front-end to\n      reflect their understanding of syntactic productions when they differ.  */\n   c_pretty_print_fn declaration;"}, {"sha": "2dda9b03a668eee900923ef98a90de9fa2371680", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -79,7 +79,7 @@ pop_stmt_list (tree t)\n   cur_stmt_list = chain;\n \n   /* If the statement list is completely empty, just return it.  This is\n-     just as good small as build_empty_stmt, with the advantage that \n+     just as good small as build_empty_stmt, with the advantage that\n      statement lists are merged when they appended to one another.  So\n      using the STATEMENT_LIST avoids pathological buildup of EMPTY_STMT_P\n      statements.  */\n@@ -132,7 +132,7 @@ build_stmt (enum tree_code code, ...)\n     {\n       tree t = va_arg (p, tree);\n       if (t && !TYPE_P (t))\n-        side_effects |= TREE_SIDE_EFFECTS (t);\n+\tside_effects |= TREE_SIDE_EFFECTS (t);\n       TREE_OPERAND (ret, i) = t;\n     }\n "}, {"sha": "7a8cdc40e2398101928150a69195ab40bc3384e1", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 115, "deletions": 116, "changes": 231, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -1,6 +1,6 @@\n /* Build expressions with type checking for C compiler.\n    Copyright (C) 1987, 1988, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006  \n+   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -236,8 +236,8 @@ c_type_promotes_to (tree type)\n     {\n       /* Preserve unsignedness if not really getting any wider.  */\n       if (TYPE_UNSIGNED (type)\n-          && (TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node)))\n-        return unsigned_type_node;\n+\t  && (TYPE_PRECISION (type) == TYPE_PRECISION (integer_type_node)))\n+\treturn unsigned_type_node;\n       return integer_type_node;\n     }\n \n@@ -331,7 +331,7 @@ composite_type (tree t1, tree t2)\n \n \t/* We should not have any type quals on arrays at all.  */\n \tgcc_assert (!TYPE_QUALS (t1) && !TYPE_QUALS (t2));\n-\t\n+\n \td1_zero = d1 == 0 || !TYPE_MAX_VALUE (d1);\n \td2_zero = d2 == 0 || !TYPE_MAX_VALUE (d2);\n \n@@ -351,12 +351,12 @@ composite_type (tree t1, tree t2)\n \tif (elt == TREE_TYPE (t2) && TYPE_DOMAIN (t2)\n \t    && (d1_variable || d1_zero || !d2_variable))\n \t  return build_type_attribute_variant (t2, attributes);\n-\t\n+\n \tif (elt == TREE_TYPE (t1) && !TYPE_DOMAIN (t2) && !TYPE_DOMAIN (t1))\n \t  return build_type_attribute_variant (t1, attributes);\n \tif (elt == TREE_TYPE (t2) && !TYPE_DOMAIN (t2) && !TYPE_DOMAIN (t1))\n \t  return build_type_attribute_variant (t2, attributes);\n-\t\n+\n \t/* Merge the element types, and have a size if either arg has\n \t   one.  We may have qualifiers on the element types.  To set\n \t   up TYPE_MAIN_VARIANT correctly, we need to form the\n@@ -530,7 +530,7 @@ common_pointer_type (tree t1, tree t2)\n     return t1;\n \n   gcc_assert (TREE_CODE (t1) == POINTER_TYPE\n- \t      && TREE_CODE (t2) == POINTER_TYPE);\n+\t      && TREE_CODE (t2) == POINTER_TYPE);\n \n   /* Merge the attributes.  */\n   attributes = targetm.merge_type_attributes (t1, t2);\n@@ -667,7 +667,7 @@ c_common_type (tree t1, tree t2)\n       if (TYPE_UNSIGNED (t1) || TYPE_UNSIGNED (t2))\n \treturn long_long_unsigned_type_node;\n       else\n-        return long_long_integer_type_node;\n+\treturn long_long_integer_type_node;\n     }\n \n   if (TYPE_MAIN_VARIANT (t1) == long_unsigned_type_node\n@@ -737,9 +737,10 @@ comptypes (tree type1, tree type2)\n \n   val = comptypes_internal (type1, type2);\n   free_all_tagged_tu_seen_up_to (tagged_tu_seen_base1);\n-  \n+\n   return val;\n-}\f\n+}\n+\f\n /* Return 1 if TYPE1 and TYPE2 are compatible types for assignment\n    or various other operations.  Return 2 if they are compatible\n    but a warning may be needed if you use them together.  This\n@@ -859,14 +860,14 @@ comptypes_internal (tree type1, tree type2)\n \t    || !tree_int_cst_equal (TYPE_MAX_VALUE (d1), TYPE_MAX_VALUE (d2)))\n \t  val = 0;\n \n-        break;\n+\tbreak;\n       }\n \n     case ENUMERAL_TYPE:\n     case RECORD_TYPE:\n     case UNION_TYPE:\n       if (val != 1 && !same_translation_unit_p (t1, t2))\n-        {\n+\t{\n \t  if (attrval != 2)\n \t    return tagged_types_tu_compatible_p (t1, t2);\n \t  val = tagged_types_tu_compatible_p (t1, t2);\n@@ -953,9 +954,9 @@ alloc_tagged_tu_seen_cache (tree t1, tree t2)\n   tu->next = tagged_tu_seen_base;\n   tu->t1 = t1;\n   tu->t2 = t2;\n-  \n+\n   tagged_tu_seen_base = tu;\n-  \n+\n   /* The C standard says that two structures in different translation\n      units are compatible with each other only if the types of their\n      fields are compatible (among other things).  We assume that they\n@@ -1038,31 +1039,31 @@ tagged_types_tu_compatible_p (tree t1, tree t2)\n     case ENUMERAL_TYPE:\n       {\n \tstruct tagged_tu_seen_cache *tu = alloc_tagged_tu_seen_cache (t1, t2);\n-        /* Speed up the case where the type values are in the same order.  */\n-        tree tv1 = TYPE_VALUES (t1);\n-        tree tv2 = TYPE_VALUES (t2);\n+\t/* Speed up the case where the type values are in the same order.  */\n+\ttree tv1 = TYPE_VALUES (t1);\n+\ttree tv2 = TYPE_VALUES (t2);\n \n-        if (tv1 == tv2)\n+\tif (tv1 == tv2)\n \t  {\n \t    return 1;\n \t  }\n \n-        for (;tv1 && tv2; tv1 = TREE_CHAIN (tv1), tv2 = TREE_CHAIN (tv2))\n-          {\n-            if (TREE_PURPOSE (tv1) != TREE_PURPOSE (tv2))\n-              break;\n-            if (simple_cst_equal (TREE_VALUE (tv1), TREE_VALUE (tv2)) != 1)\n+\tfor (;tv1 && tv2; tv1 = TREE_CHAIN (tv1), tv2 = TREE_CHAIN (tv2))\n+\t  {\n+\t    if (TREE_PURPOSE (tv1) != TREE_PURPOSE (tv2))\n+\t      break;\n+\t    if (simple_cst_equal (TREE_VALUE (tv1), TREE_VALUE (tv2)) != 1)\n \t      {\n-\t        tu->val = 0;\n+\t\ttu->val = 0;\n \t\treturn 0;\n \t      }\n-          }\n+\t  }\n \n-        if (tv1 == NULL_TREE && tv2 == NULL_TREE)\n+\tif (tv1 == NULL_TREE && tv2 == NULL_TREE)\n \t  {\n \t    return 1;\n \t  }\n-        if (tv1 == NULL_TREE || tv2 == NULL_TREE)\n+\tif (tv1 == NULL_TREE || tv2 == NULL_TREE)\n \t  {\n \t    tu->val = 0;\n \t    return 0;\n@@ -1095,16 +1096,16 @@ tagged_types_tu_compatible_p (tree t1, tree t2)\n \t    tu->val = 0;\n \t    return 0;\n \t  }\n-\t\n+\n \t/*  Speed up the common case where the fields are in the same order. */\n \tfor (s1 = TYPE_FIELDS (t1), s2 = TYPE_FIELDS (t2); s1 && s2;\n \t     s1 = TREE_CHAIN (s1), s2 = TREE_CHAIN (s2))\n \t  {\n \t    int result;\n-\t    \n-\t    \n+\n+\n \t    if (DECL_NAME (s1) == NULL\n-\t        || DECL_NAME (s1) != DECL_NAME (s2))\n+\t\t|| DECL_NAME (s1) != DECL_NAME (s2))\n \t      break;\n \t    result = comptypes_internal (TREE_TYPE (s1), TREE_TYPE (s2));\n \t    if (result == 0)\n@@ -1167,7 +1168,7 @@ tagged_types_tu_compatible_p (tree t1, tree t2)\n \n     case RECORD_TYPE:\n       {\n-        struct tagged_tu_seen_cache *tu = alloc_tagged_tu_seen_cache (t1, t2);\n+\tstruct tagged_tu_seen_cache *tu = alloc_tagged_tu_seen_cache (t1, t2);\n \n \tfor (s1 = TYPE_FIELDS (t1), s2 = TYPE_FIELDS (t2);\n \t     s1 && s2;\n@@ -1962,7 +1963,7 @@ build_array_ref (tree array, tree index)\n \ttype = TYPE_MAIN_VARIANT (type);\n       rval = build4 (ARRAY_REF, type, array, index, NULL_TREE, NULL_TREE);\n       /* Array ref is const/volatile if the array elements are\n-         or if the array is.  */\n+\t or if the array is.  */\n       TREE_READONLY (rval)\n \t|= (TYPE_READONLY (TREE_TYPE (TREE_TYPE (array)))\n \t    | TREE_READONLY (array));\n@@ -2268,7 +2269,7 @@ build_function_call (tree function, tree params)\n   if (require_constant_value)\n     {\n       result = fold_build3_initializer (CALL_EXPR, TREE_TYPE (fntype),\n-\t\t      \t\t\tfunction, coerced_params, NULL_TREE);\n+\t\t\t\t\tfunction, coerced_params, NULL_TREE);\n \n       if (TREE_CONSTANT (result)\n \t  && (name == NULL_TREE\n@@ -2277,7 +2278,7 @@ build_function_call (tree function, tree params)\n     }\n   else\n     result = fold_build3 (CALL_EXPR, TREE_TYPE (fntype),\n-\t\t      \t  function, coerced_params, NULL_TREE);\n+\t\t\t  function, coerced_params, NULL_TREE);\n \n   if (VOID_TYPE_P (TREE_TYPE (result)))\n     return result;\n@@ -2419,16 +2420,16 @@ convert_arguments (tree typelist, tree values, tree function, tree fundecl)\n  \t\t      else if (type != TREE_TYPE (val)\n \t\t\t       && (type == dfloat32_type_node\n \t\t\t\t   || type == dfloat64_type_node\n-\t\t\t\t   || type == dfloat128_type_node \n+\t\t\t\t   || type == dfloat128_type_node\n \t\t\t\t   || TREE_TYPE (val) == dfloat32_type_node\n \t\t\t\t   || TREE_TYPE (val) == dfloat64_type_node\n \t\t\t\t   || TREE_TYPE (val) == dfloat128_type_node)\n-\t\t\t       && (formal_prec \n+\t\t\t       && (formal_prec\n \t\t\t\t   <= TYPE_PRECISION (TREE_TYPE (val))\n \t\t\t\t   || (type == dfloat128_type_node\n \t\t\t\t       && (TREE_TYPE (val)\n-\t\t\t\t\t   != dfloat64_type_node \n-\t\t\t\t\t   && (TREE_TYPE (val) \n+\t\t\t\t\t   != dfloat64_type_node\n+\t\t\t\t\t   && (TREE_TYPE (val)\n \t\t\t\t\t       != dfloat32_type_node)))\n \t\t\t\t   || (type == dfloat64_type_node\n \t\t\t\t       && (TREE_TYPE (val)\n@@ -2498,16 +2499,16 @@ convert_arguments (tree typelist, tree values, tree function, tree fundecl)\n \t  result = tree_cons (NULL_TREE, parmval, result);\n \t}\n       else if (TREE_CODE (TREE_TYPE (val)) == REAL_TYPE\n-               && (TYPE_PRECISION (TREE_TYPE (val))\n-\t           < TYPE_PRECISION (double_type_node))\n+\t       && (TYPE_PRECISION (TREE_TYPE (val))\n+\t\t   < TYPE_PRECISION (double_type_node))\n \t       && !DECIMAL_FLOAT_MODE_P (TYPE_MODE (TREE_TYPE (val))))\n \t/* Convert `float' to `double'.  */\n \tresult = tree_cons (NULL_TREE, convert (double_type_node, val), result);\n-      else if ((invalid_func_diag = \n-\t        targetm.calls.invalid_arg_for_unprototyped_fn (typelist, fundecl, val)))\n+      else if ((invalid_func_diag =\n+\t\ttargetm.calls.invalid_arg_for_unprototyped_fn (typelist, fundecl, val)))\n \t{\n \t  error (invalid_func_diag);\n-\t  return error_mark_node; \n+\t  return error_mark_node;\n \t}\n       else\n \t/* Convert `short' and `char' to full-size `int'.  */\n@@ -2895,9 +2896,9 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t  && typecode != INTEGER_TYPE && typecode != REAL_TYPE)\n \t{\n \t  if (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n-            error (\"wrong type argument to increment\");\n-          else\n-            error (\"wrong type argument to decrement\");\n+\t    error (\"wrong type argument to increment\");\n+\t  else\n+\t    error (\"wrong type argument to decrement\");\n \n \t  return error_mark_node;\n \t}\n@@ -2925,7 +2926,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t    else if ((pedantic || warn_pointer_arith)\n \t\t     && (TREE_CODE (TREE_TYPE (result_type)) == FUNCTION_TYPE\n \t\t\t || TREE_CODE (TREE_TYPE (result_type)) == VOID_TYPE))\n-              {\n+\t      {\n \t\tif (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n \t\t  pedwarn (\"wrong type argument to increment\");\n \t\telse\n@@ -3002,7 +3003,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n       argtype = TREE_TYPE (arg);\n \n       /* If the lvalue is const or volatile, merge that into the type\n-         to which the address will point.  Note that you can't get a\n+\t to which the address will point.  Note that you can't get a\n \t restricted pointer by taking the address of something, so we\n \t only have to deal with `const' and `volatile' here.  */\n       if ((DECL_P (arg) || REFERENCE_CLASS_P (arg))\n@@ -3042,7 +3043,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n   if (argtype == 0)\n     argtype = TREE_TYPE (arg);\n   return require_constant_value ? fold_build1_initializer (code, argtype, arg)\n-\t  \t\t\t: fold_build1 (code, argtype, arg);\n+\t\t\t\t: fold_build1 (code, argtype, arg);\n }\n \n /* Return nonzero if REF is an lvalue valid for this language.\n@@ -3093,7 +3094,7 @@ readonly_error (tree arg, enum lvalue_use use)\n      ensures that all the format strings are checked at compile\n      time.  */\n #define READONLY_MSG(A, I, D, AS) (use == lv_assign ? (A)\t\t\\\n-\t\t\t           : (use == lv_increment ? (I)\t\t\\\n+\t\t\t\t   : (use == lv_increment ? (I)\t\t\\\n \t\t\t\t   : (use == lv_decrement ? (D) : (AS))))\n   if (TREE_CODE (arg) == COMPONENT_REF)\n     {\n@@ -3249,9 +3250,9 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n \tresult_type = TYPE_MAIN_VARIANT (type1);\n     }\n   else if ((code1 == INTEGER_TYPE || code1 == REAL_TYPE\n-            || code1 == COMPLEX_TYPE)\n-           && (code2 == INTEGER_TYPE || code2 == REAL_TYPE\n-               || code2 == COMPLEX_TYPE))\n+\t    || code1 == COMPLEX_TYPE)\n+\t   && (code2 == INTEGER_TYPE || code2 == REAL_TYPE\n+\t       || code2 == COMPLEX_TYPE))\n     {\n       result_type = c_common_type (type1, type2);\n \n@@ -3374,7 +3375,7 @@ build_compound_expr (tree expr1, tree expr2)\n   if (!TREE_SIDE_EFFECTS (expr1))\n     {\n       /* The left-hand operand of a comma expression is like an expression\n-         statement: with -Wextra or -Wunused, we should warn if it doesn't have\n+\t statement: with -Wextra or -Wunused, we should warn if it doesn't have\n \t any side-effects, unless it was explicitly cast to (void).  */\n       if (warn_unused_value)\n \t{\n@@ -3535,10 +3536,10 @@ build_c_cast (tree type, tree expr)\n       if (TREE_CODE (type) == INTEGER_TYPE\n \t  && TREE_CODE (otype) == POINTER_TYPE\n \t  && TYPE_PRECISION (type) != TYPE_PRECISION (otype))\n-      /* Unlike conversion of integers to pointers, where the \n-         warning is disabled for converting constants because \n-         of cases such as SIG_*, warn about converting constant \n-         pointers to integers. In some cases it may cause unwanted \n+      /* Unlike conversion of integers to pointers, where the\n+         warning is disabled for converting constants because\n+         of cases such as SIG_*, warn about converting constant\n+         pointers to integers. In some cases it may cause unwanted\n          sign extension, and a warning is appropriate.  */\n \twarning (OPT_Wpointer_to_int_cast,\n \t\t \"cast from pointer to integer of different size\");\n@@ -3621,7 +3622,6 @@ c_cast_expr (struct c_type_name *type_name, tree expr)\n \n   return build_c_cast (type, expr);\n }\n-\n \f\n /* Build an assignment expression of lvalue LHS from value RHS.\n    MODIFYCODE is the code for a binary operator that we use\n@@ -3871,7 +3871,7 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n     }\n   /* Some types can interconvert without explicit casts.  */\n   else if (codel == VECTOR_TYPE && coder == VECTOR_TYPE\n-           && vector_types_convertible_p (type, TREE_TYPE (rhs)))\n+\t   && vector_types_convertible_p (type, TREE_TYPE (rhs)))\n     return convert (type, rhs);\n   /* Arithmetic types all interconvert, and enum is treated like int.  */\n   else if ((codel == INTEGER_TYPE || codel == REAL_TYPE\n@@ -4005,26 +4005,26 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \tmvr = TYPE_MAIN_VARIANT (mvr);\n       /* Opaque pointers are treated like void pointers.  */\n       is_opaque_pointer = (targetm.vector_opaque_p (type)\n-                           || targetm.vector_opaque_p (rhstype))\n-        && TREE_CODE (ttl) == VECTOR_TYPE\n-        && TREE_CODE (ttr) == VECTOR_TYPE;\n-      \n+\t\t\t   || targetm.vector_opaque_p (rhstype))\n+\t&& TREE_CODE (ttl) == VECTOR_TYPE\n+\t&& TREE_CODE (ttr) == VECTOR_TYPE;\n+\n       /* C++ does not allow the implicit conversion void* -> T*.  However,\n-         for the purpose of reducing the number of false positives, we\n-         tolerate the special case of\n+\t for the purpose of reducing the number of false positives, we\n+\t tolerate the special case of\n \n-                int *p = NULL;\n+\t\tint *p = NULL;\n \n-         where NULL is typically defined in C to be '(void *) 0'.  */\n+\t where NULL is typically defined in C to be '(void *) 0'.  */\n       if (VOID_TYPE_P (ttr) && rhs != null_pointer_node && !VOID_TYPE_P (ttl))\n-        warning (OPT_Wc___compat, \"request for implicit conversion from \"\n-                 \"%qT to %qT not permitted in C++\", rhstype, type);\n+\twarning (OPT_Wc___compat, \"request for implicit conversion from \"\n+\t\t \"%qT to %qT not permitted in C++\", rhstype, type);\n \n       /* Check if the right-hand side has a format attribute but the\n \t left-hand side doesn't.  */\n       if (warn_missing_format_attribute\n \t  && check_missing_format_attribute (type, rhstype))\n-        {\n+\t{\n \t  switch (errtype)\n \t  {\n \t  case ic_argpass:\n@@ -4053,7 +4053,7 @@ convert_for_assignment (tree type, tree rhs, enum impl_conv errtype,\n \t    gcc_unreachable ();\n \t  }\n \t}\n-      \n+\n       /* Any non-function converts to a [const][volatile] void *\n \t and vice versa; otherwise, targets must be the same.\n \t Meanwhile, the lhs target must have all the qualifiers of the rhs.  */\n@@ -5359,7 +5359,7 @@ pop_init_level (int implicit)\n       else\n \t{\n \t  gcc_assert (!TYPE_SIZE (constructor_type));\n-\t  \n+\n \t  if (constructor_depth > 2)\n \t    error_init (\"initialization of flexible array member in a nested context\");\n \t  else if (pedantic)\n@@ -5969,7 +5969,7 @@ set_nonincremental_init_from_string (tree str)\n \t  else if (bitpos == HOST_BITS_PER_WIDE_INT)\n \t    {\n \t      if (val[1] < 0)\n-\t        val[0] = -1;\n+\t\tval[0] = -1;\n \t    }\n \t  else if (val[0] & (((HOST_WIDE_INT) 1)\n \t\t\t     << (bitpos - 1 - HOST_BITS_PER_WIDE_INT)))\n@@ -6375,7 +6375,7 @@ process_init_element (struct c_expr value)\n       && integer_zerop (constructor_unfilled_index))\n     {\n       if (constructor_stack->replacement_value.value)\n-        error_init (\"excess elements in char array initializer\");\n+\terror_init (\"excess elements in char array initializer\");\n       constructor_stack->replacement_value = value;\n       return;\n     }\n@@ -6478,10 +6478,10 @@ process_init_element (struct c_expr value)\n \t    {\n \t      /* For a record, keep track of end position of last field.  */\n \t      if (DECL_SIZE (constructor_fields))\n-\t        constructor_bit_index\n+\t\tconstructor_bit_index\n \t\t  = size_binop (PLUS_EXPR,\n-\t\t\t        bit_position (constructor_fields),\n-\t\t\t        DECL_SIZE (constructor_fields));\n+\t\t\t\tbit_position (constructor_fields),\n+\t\t\t\tDECL_SIZE (constructor_fields));\n \n \t      /* If the current field was the first one not yet written out,\n \t\t it isn't now, so update.  */\n@@ -6624,8 +6624,8 @@ process_init_element (struct c_expr value)\n \t{\n \t  tree elttype = TYPE_MAIN_VARIANT (TREE_TYPE (constructor_type));\n \n-         /* Do a basic check of initializer size.  Note that vectors\n-            always have a fixed size derived from their type.  */\n+\t /* Do a basic check of initializer size.  Note that vectors\n+\t    always have a fixed size derived from their type.  */\n \t  if (tree_int_cst_lt (constructor_max_index, constructor_index))\n \t    {\n \t      pedwarn_init (\"excess elements in vector initializer\");\n@@ -6788,7 +6788,7 @@ build_asm_expr (tree string, tree outputs, tree inputs, tree clobbers,\n \t    output = error_mark_node;\n \t}\n       else\n-        output = error_mark_node;\n+\toutput = error_mark_node;\n \n       TREE_VALUE (tail) = output;\n     }\n@@ -6966,7 +6966,7 @@ c_finish_return (tree retval)\n \t      inner = TREE_OPERAND (inner, 0);\n \n \t      while (REFERENCE_CLASS_P (inner)\n-\t             && TREE_CODE (inner) != INDIRECT_REF)\n+\t\t     && TREE_CODE (inner) != INDIRECT_REF)\n \t\tinner = TREE_OPERAND (inner, 0);\n \n \t      if (DECL_P (inner)\n@@ -7229,41 +7229,41 @@ c_finish_loop (location_t start_locus, tree cond, tree incr, tree body,\n   else\n     {\n       tree top = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n- \n+\n       /* If we have an exit condition, then we build an IF with gotos either\n-         out of the loop, or to the top of it.  If there's no exit condition,\n-         then we just build a jump back to the top.  */\n+\t out of the loop, or to the top of it.  If there's no exit condition,\n+\t then we just build a jump back to the top.  */\n       exit = build_and_jump (&LABEL_EXPR_LABEL (top));\n- \n+\n       if (cond && !integer_nonzerop (cond))\n-        {\n-          /* Canonicalize the loop condition to the end.  This means\n-             generating a branch to the loop condition.  Reuse the\n-             continue label, if possible.  */\n-          if (cond_is_first)\n-            {\n-              if (incr || !clab)\n-                {\n-                  entry = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n-                  t = build_and_jump (&LABEL_EXPR_LABEL (entry));\n-                }\n-              else\n-                t = build1 (GOTO_EXPR, void_type_node, clab);\n+\t{\n+\t  /* Canonicalize the loop condition to the end.  This means\n+\t     generating a branch to the loop condition.  Reuse the\n+\t     continue label, if possible.  */\n+\t  if (cond_is_first)\n+\t    {\n+\t      if (incr || !clab)\n+\t\t{\n+\t\t  entry = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n+\t\t  t = build_and_jump (&LABEL_EXPR_LABEL (entry));\n+\t\t}\n+\t      else\n+\t\tt = build1 (GOTO_EXPR, void_type_node, clab);\n \t      SET_EXPR_LOCATION (t, start_locus);\n-              add_stmt (t);\n-            }\n- \n+\t      add_stmt (t);\n+\t    }\n+\n \t  t = build_and_jump (&blab);\n-          exit = fold_build3 (COND_EXPR, void_type_node, cond, exit, t);\n+\t  exit = fold_build3 (COND_EXPR, void_type_node, cond, exit, t);\n \t  if (cond_is_first)\n-            SET_EXPR_LOCATION (exit, start_locus);\n+\t    SET_EXPR_LOCATION (exit, start_locus);\n \t  else\n-            SET_EXPR_LOCATION (exit, input_location);\n-        }\n- \n+\t    SET_EXPR_LOCATION (exit, input_location);\n+\t}\n+\n       add_stmt (top);\n     }\n- \n+\n   if (body)\n     add_stmt (body);\n   if (clab)\n@@ -7306,7 +7306,7 @@ c_finish_bc_stmt (tree *label_p, bool is_break)\n       if (is_break)\n \terror (\"break statement not within loop or switch\");\n       else\n-        error (\"continue statement not within a loop\");\n+\terror (\"continue statement not within a loop\");\n       return NULL_TREE;\n \n     case 1:\n@@ -7994,15 +7994,15 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       else if (code0 == POINTER_TYPE && null_pointer_constant_p (orig_op1))\n \t{\n \t  if (TREE_CODE (op0) == ADDR_EXPR\n-\t      && DECL_P (TREE_OPERAND (op0, 0)) \n+\t      && DECL_P (TREE_OPERAND (op0, 0))\n \t      && !DECL_WEAK (TREE_OPERAND (op0, 0)))\n \t    warning (OPT_Walways_true, \"the address of %qD will never be NULL\",\n \t\t     TREE_OPERAND (op0, 0));\n \t  result_type = type0;\n \t}\n       else if (code1 == POINTER_TYPE && null_pointer_constant_p (orig_op0))\n \t{\n-\t  if (TREE_CODE (op1) == ADDR_EXPR \n+\t  if (TREE_CODE (op1) == ADDR_EXPR\n \t      && DECL_P (TREE_OPERAND (op1, 0))\n \t      && !DECL_WEAK (TREE_OPERAND (op1, 0)))\n \t    warning (OPT_Walways_true, \"the address of %qD will never be NULL\",\n@@ -8273,9 +8273,9 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t\t all the values of the unsigned type.  */\n \t      if (!TYPE_UNSIGNED (result_type))\n \t\t/* OK */;\n-              /* Do not warn if both operands are the same signedness.  */\n-              else if (op0_signed == op1_signed)\n-                /* OK */;\n+\t      /* Do not warn if both operands are the same signedness.  */\n+\t      else if (op0_signed == op1_signed)\n+\t\t/* OK */;\n \t      else\n \t\t{\n \t\t  tree sop, uop;\n@@ -8465,7 +8465,6 @@ c_expr_to_decl (tree expr, bool *tc ATTRIBUTE_UNUSED,\n   else\n     return expr;\n }\n-\n \f\n /* Like c_begin_compound_stmt, except force the retention of the BLOCK.  */\n "}, {"sha": "12510d9697f452b789c3df750cab09306c6e1493", "filename": "gcc/c.opt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc.opt?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -7,12 +7,12 @@\n ; the terms of the GNU General Public License as published by the Free\n ; Software Foundation; either version 2, or (at your option) any later\n ; version.\n-; \n+;\n ; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n ; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n ; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n ; for more details.\n-; \n+;\n ; You should have received a copy of the GNU General Public License\n ; along with GCC; see the file COPYING.  If not, write to the Free\n ; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n@@ -691,7 +691,7 @@ C ObjC C++ ObjC++ Joined RejectNegative UInteger\n -ftabstop=<number>\tDistance between tab stops for column reporting\n \n ftemplate-depth-\n-C++ ObjC++ Joined RejectNegative UInteger \n+C++ ObjC++ Joined RejectNegative UInteger\n -ftemplate-depth-<number>\tSpecify maximum template instantiation depth\n \n fthis-is-variable"}, {"sha": "c81c72c49b684987d17a78cced20c459eee873c6", "filename": "gcc/caller-save.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -195,7 +195,7 @@ init_caller_save (void)\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     for (mode = 0 ; mode < MAX_MACHINE_MODE; mode++)\n       if (HARD_REGNO_MODE_OK (i, mode))\n-        {\n+\t{\n \t  int ok;\n \n \t  /* Update the register number and modes of the register\n@@ -212,7 +212,7 @@ init_caller_save (void)\n \t  reg_restore_code[i][mode] = recog_memoized (restinsn);\n \n \t  /* Now extract both insns and see if we can meet their\n-             constraints.  */\n+\t     constraints.  */\n \t  ok = (reg_save_code[i][mode] != -1\n \t\t&& reg_restore_code[i][mode] != -1);\n \t  if (ok)\n@@ -228,7 +228,7 @@ init_caller_save (void)\n \t      reg_save_code[i][mode] = -1;\n \t      reg_restore_code[i][mode] = -1;\n \t    }\n-        }\n+\t}\n       else\n \t{\n \t  reg_save_code[i][mode] = -1;\n@@ -847,7 +847,7 @@ insert_one_insn (struct insn_chain *chain, int before_p, int code, rtx pat)\n \t registers from the live sets, and observe REG_UNUSED notes.  */\n       COPY_REG_SET (&new->live_throughout, &chain->live_throughout);\n       /* Registers that are set in CHAIN->INSN live in the new insn.\n-         (Unless there is a REG_UNUSED note for them, but we don't\n+\t (Unless there is a REG_UNUSED note for them, but we don't\n \t  look for them here.) */\n       note_stores (PATTERN (chain->insn), add_stored_regs,\n \t\t   &new->live_throughout);"}, {"sha": "7c71eed0502a44ee7c296c34da5b1ec4691aaf99", "filename": "gcc/calls.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -399,7 +399,7 @@ emit_call_1 (rtx funexp, tree fntree, tree fndecl ATTRIBUTE_UNUSED,\n   if (ecf_flags & ECF_RETURNS_TWICE)\n     {\n       REG_NOTES (call_insn) = gen_rtx_EXPR_LIST (REG_SETJMP, const0_rtx,\n-\t\t\t\t\t         REG_NOTES (call_insn));\n+\t\t\t\t\t\t REG_NOTES (call_insn));\n       current_function_calls_setjmp = 1;\n     }\n \n@@ -476,10 +476,10 @@ special_function_p (tree fndecl, int flags)\n       /* Exclude functions not at the file scope, or not `extern',\n \t since they are not the magic functions we would otherwise\n \t think they are.\n-         FIXME: this should be handled with attributes, not with this\n-         hacky imitation of DECL_ASSEMBLER_NAME.  It's (also) wrong\n-         because you can declare fork() inside a function if you\n-         wish.  */\n+\t FIXME: this should be handled with attributes, not with this\n+\t hacky imitation of DECL_ASSEMBLER_NAME.  It's (also) wrong\n+\t because you can declare fork() inside a function if you\n+\t wish.  */\n       && (DECL_CONTEXT (fndecl) == NULL_TREE\n \t  || TREE_CODE (DECL_CONTEXT (fndecl)) == TRANSLATION_UNIT_DECL)\n       && TREE_PUBLIC (fndecl))\n@@ -2169,12 +2169,12 @@ expand_call (tree exp, rtx target, int ignore)\n \t into a sibcall.  */\n       || !targetm.function_ok_for_sibcall (fndecl, exp)\n       /* Functions that do not return exactly once may not be sibcall\n-         optimized.  */\n+\t optimized.  */\n       || (flags & (ECF_RETURNS_TWICE | ECF_NORETURN))\n       || TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (addr)))\n       /* If the called function is nested in the current one, it might access\n-         some of the caller's arguments, but could clobber them beforehand if\n-         the argument areas are shared.  */\n+\t some of the caller's arguments, but could clobber them beforehand if\n+\t the argument areas are shared.  */\n       || (fndecl && decl_function_context (fndecl) == current_function_decl)\n       /* If this function requires more stack slots than the current\n \t function, we cannot change it into a sibling call.\n@@ -2287,7 +2287,7 @@ expand_call (tree exp, rtx target, int ignore)\n       old_stack_allocated = stack_pointer_delta - pending_stack_adjust;\n \n       /* The argument block when performing a sibling call is the\n-         incoming argument block.  */\n+\t incoming argument block.  */\n       if (pass == 0)\n \t{\n \t  argblock = virtual_incoming_args_rtx;\n@@ -2696,7 +2696,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t  rtx insn;\n \t  bool failed = valreg == 0 || GET_CODE (valreg) == PARALLEL;\n \n-          insns = get_insns ();\n+\t  insns = get_insns ();\n \n \t  /* Expansion of block moves possibly introduced a loop that may\n \t     not appear inside libcall block.  */\n@@ -2922,11 +2922,11 @@ expand_call (tree exp, rtx target, int ignore)\n \t      int unsignedp = TYPE_UNSIGNED (type);\n \t      int offset = 0;\n \t      enum machine_mode pmode;\n-\t      \n+\n \t      pmode = promote_mode (type, TYPE_MODE (type), &unsignedp, 1);\n \t      /* If we don't promote as expected, something is wrong.  */\n \t      gcc_assert (GET_MODE (target) == pmode);\n-\t      \n+\n \t      if ((WORDS_BIG_ENDIAN || BYTES_BIG_ENDIAN)\n \t\t  && (GET_MODE_SIZE (GET_MODE (target))\n \t\t      > GET_MODE_SIZE (TYPE_MODE (type))))\n@@ -3122,7 +3122,7 @@ split_complex_values (tree values)\n       tree type = TREE_TYPE (TREE_VALUE (p));\n       if (type && TREE_CODE (type) == COMPLEX_TYPE\n \t  && targetm.calls.split_complex_arg (type))\n-        goto found;\n+\tgoto found;\n     }\n   return values;\n \n@@ -3176,7 +3176,7 @@ split_complex_types (tree types)\n       tree type = TREE_VALUE (p);\n       if (TREE_CODE (type) == COMPLEX_TYPE\n \t  && targetm.calls.split_complex_arg (type))\n-        goto found;\n+\tgoto found;\n     }\n   return types;\n \n@@ -3367,7 +3367,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   if (mem_value && struct_value == 0 && ! pcc_struct_value)\n     {\n       rtx addr = XEXP (mem_value, 0);\n-      \n+\n       nargs++;\n \n       /* Make sure it is a reasonable operand for a move or push insn.  */\n@@ -3385,7 +3385,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \n       locate_and_pad_parm (Pmode, NULL_TREE,\n #ifdef STACK_PARMS_IN_REG_PARM_AREA\n-                           1,\n+\t\t\t   1,\n #else\n \t\t\t   argvec[count].reg != 0,\n #endif\n@@ -3552,7 +3552,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n       needed = 0;\n \n       /* We must be careful to use virtual regs before they're instantiated,\n-         and real regs afterwards.  Loop optimization, for example, can create\n+\t and real regs afterwards.  Loop optimization, for example, can create\n \t new libcalls after we've instantiated the virtual regs, and if we\n \t use virtuals anyway, they won't match the rtl patterns.  */\n \n@@ -3649,11 +3649,11 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t\t    {\n \t\t      argvec[argnum].save_area\n \t\t\t= assign_stack_temp (BLKmode,\n-\t\t\t\t             argvec[argnum].locate.size.constant,\n+\t\t\t\t\t     argvec[argnum].locate.size.constant,\n \t\t\t\t\t     0);\n \n \t\t      emit_block_move (validize_mem (argvec[argnum].save_area),\n-\t\t\t  \t       stack_area,\n+\t\t\t\t       stack_area,\n \t\t\t\t       GEN_INT (argvec[argnum].locate.size.constant),\n \t\t\t\t       BLOCK_OP_CALL_PARM);\n \t\t    }\n@@ -3694,7 +3694,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t\t   auto-increment causes confusion.  So we merely indicate\n \t\t   that we access something with a known mode somewhere on\n \t\t   the stack.  */\n-\t        use = gen_rtx_PLUS (Pmode, virtual_outgoing_args_rtx,\n+\t\tuse = gen_rtx_PLUS (Pmode, virtual_outgoing_args_rtx,\n \t\t\t\t    gen_rtx_SCRATCH (Pmode));\n \t      use = gen_rtx_MEM (argvec[argnum].mode, use);\n \t      use = gen_rtx_USE (VOIDmode, use);\n@@ -3905,7 +3905,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \n \t    if (save_mode == BLKmode)\n \t      emit_block_move (stack_area,\n-\t\t  \t       validize_mem (argvec[count].save_area),\n+\t\t\t       validize_mem (argvec[count].save_area),\n \t\t\t       GEN_INT (argvec[count].locate.size.constant),\n \t\t\t       BLOCK_OP_CALL_PARM);\n \t    else\n@@ -4083,7 +4083,7 @@ store_one_arg (struct arg_data *arg, rtx argblock, int flags,\n   /* Being passed entirely in a register.  We shouldn't be called in\n      this case.  */\n   gcc_assert (reg == 0 || partial != 0);\n-  \n+\n   /* If this arg needs special alignment, don't load the registers\n      here.  */\n   if (arg->n_aligned_regs != 0)"}, {"sha": "aa8eaca9eec3acdf790c638586b2666cfe061b88", "filename": "gcc/cfg.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -683,7 +683,7 @@ alloc_aux_for_blocks (int size)\n   else\n     /* Check whether AUX data are still allocated.  */\n     gcc_assert (!first_block_aux_obj);\n-  \n+\n   first_block_aux_obj = obstack_alloc (&block_aux_obstack, 0);\n   if (size)\n     {\n@@ -861,7 +861,7 @@ brief_dump_cfg (FILE *file)\n \n /* An edge originally destinating BB of FREQUENCY and COUNT has been proved to\n    leave the block by TAKEN_EDGE.  Update profile of BB such that edge E can be\n-   redirected to destination of TAKEN_EDGE. \n+   redirected to destination of TAKEN_EDGE.\n \n    This function may leave the profile inconsistent in the case TAKEN_EDGE\n    frequency or count is believed to be lower than FREQUENCY or COUNT\n@@ -972,8 +972,8 @@ scale_bbs_frequencies_int (basic_block *bbs, int nbbs, int num, int den)\n    by NUM/DEN, in gcov_type arithmetic.  More accurate than previous\n    function but considerably slower.  */\n void\n-scale_bbs_frequencies_gcov_type (basic_block *bbs, int nbbs, gcov_type num, \n-\t\t\t         gcov_type den)\n+scale_bbs_frequencies_gcov_type (basic_block *bbs, int nbbs, gcov_type num,\n+\t\t\t\t gcov_type den)\n {\n   int i;\n   edge e;"}, {"sha": "835703fe8cf76c69456187174512e34287ac4818", "filename": "gcc/cfganal.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -981,23 +981,23 @@ dfs_enumerate_from (basic_block bb, int reverse,\n       edge_iterator ei;\n       lbb = st[--sp];\n       if (reverse)\n-        {\n+\t{\n \t  FOR_EACH_EDGE (e, ei, lbb->preds)\n \t    if (!VISITED_P (e->src) && predicate (e->src, data))\n \t      {\n-\t        gcc_assert (tv != rslt_max);\n-\t        rslt[tv++] = st[sp++] = e->src;\n-\t        MARK_VISITED (e->src);\n+\t\tgcc_assert (tv != rslt_max);\n+\t\trslt[tv++] = st[sp++] = e->src;\n+\t\tMARK_VISITED (e->src);\n \t      }\n-        }\n+\t}\n       else\n-        {\n+\t{\n \t  FOR_EACH_EDGE (e, ei, lbb->succs)\n \t    if (!VISITED_P (e->dest) && predicate (e->dest, data))\n \t      {\n-\t        gcc_assert (tv != rslt_max);\n-\t        rslt[tv++] = st[sp++] = e->dest;\n-\t        MARK_VISITED (e->dest);\n+\t\tgcc_assert (tv != rslt_max);\n+\t\trslt[tv++] = st[sp++] = e->dest;\n+\t\tMARK_VISITED (e->dest);\n \t      }\n \t}\n     }\n@@ -1012,24 +1012,24 @@ dfs_enumerate_from (basic_block bb, int reverse,\n \n \n /* Compute dominance frontiers, ala Harvey, Ferrante, et al.\n-   \n+\n    This algorithm can be found in Timothy Harvey's PhD thesis, at\n    http://www.cs.rice.edu/~harv/dissertation.pdf in the section on iterative\n    dominance algorithms.\n \n    First, we identify each join point, j (any node with more than one\n-   incoming edge is a join point). \n+   incoming edge is a join point).\n \n    We then examine each predecessor, p, of j and walk up the dominator tree\n-   starting at p. \n-   \n+   starting at p.\n+\n    We stop the walk when we reach j's immediate dominator - j is in the\n    dominance frontier of each of  the nodes in the walk, except for j's\n    immediate dominator. Intuitively, all of the rest of j's dominators are\n    shared by j's predecessors as well.\n    Since they dominate j, they will not have j in their dominance frontiers.\n \n-   The number of nodes touched by this algorithm is equal to the size \n+   The number of nodes touched by this algorithm is equal to the size\n    of the dominance frontiers, no more, no less.\n */\n \n@@ -1050,20 +1050,20 @@ compute_dominance_frontiers_1 (bitmap *frontiers)\n \t      basic_block domsb;\n \t      if (runner == ENTRY_BLOCK_PTR)\n \t\tcontinue;\n-\t      \n+\n \t      domsb = get_immediate_dominator (CDI_DOMINATORS, b);\n \t      while (runner != domsb)\n \t\t{\n-\t\t  bitmap_set_bit (frontiers[runner->index], \n+\t\t  bitmap_set_bit (frontiers[runner->index],\n \t\t\t\t  b->index);\n \t\t  runner = get_immediate_dominator (CDI_DOMINATORS,\n \t\t\t\t\t\t    runner);\n \t\t}\n \t    }\n \t}\n     }\n-}\t      \n-  \n+}\n+\n \n void\n compute_dominance_frontiers (bitmap *frontiers)"}, {"sha": "967aa6cb7fc2d4feef4e48f037b38049e2a6a1f9", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -28,7 +28,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n    Available functionality:\n      - CFG construction\n-         find_basic_blocks  */\n+\t find_basic_blocks  */\n \f\n #include \"config.h\"\n #include \"system.h\"\n@@ -124,8 +124,8 @@ control_flow_insn_p (rtx insn)\n \n     case BARRIER:\n       /* It is nonsense to reach barrier when looking for the\n-         end of basic block, but before dead code is eliminated\n-         this may happen.  */\n+\t end of basic block, but before dead code is eliminated\n+\t this may happen.  */\n       return false;\n \n     default:\n@@ -145,7 +145,7 @@ count_basic_blocks (rtx f)\n   for (insn = f; insn; insn = NEXT_INSN (insn))\n     {\n       /* Code labels and barriers causes current basic block to be\n-         terminated at previous real insn.  */\n+\t terminated at previous real insn.  */\n       if ((LABEL_P (insn) || BARRIER_P (insn))\n \t  && saw_insn)\n \tcount++, saw_insn = false;\n@@ -612,13 +612,13 @@ purge_dead_tablejump_edges (basic_block bb, rtx table)\n   for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n     {\n       if (FULL_STATE (e->dest) & BLOCK_USED_BY_TABLEJUMP)\n-        SET_STATE (e->dest, FULL_STATE (e->dest)\n-                            & ~(size_t) BLOCK_USED_BY_TABLEJUMP);\n+\tSET_STATE (e->dest, FULL_STATE (e->dest)\n+\t\t\t    & ~(size_t) BLOCK_USED_BY_TABLEJUMP);\n       else if (!(e->flags & (EDGE_ABNORMAL | EDGE_EH)))\n-        {\n-          remove_edge (e);\n-          continue;\n-        }\n+\t{\n+\t  remove_edge (e);\n+\t  continue;\n+\t}\n       ei_next (&ei);\n     }\n }"}, {"sha": "39e34694e0bfc4f028aec47dca66459b591a07fe", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -55,7 +55,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"expr.h\"\n \n #define FORWARDER_BLOCK_P(BB) ((BB)->flags & BB_FORWARDER_BLOCK)\n-  \n+\n /* Set to true when we are running first pass of try_optimize_cfg loop.  */\n static bool first_pass;\n static bool try_crossjump_to_edge (int, edge, edge);\n@@ -134,12 +134,12 @@ try_simplify_condjump (basic_block cbranch_block)\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n-     and cold sections. \n+     and cold sections.\n \n      Basic block partitioning may result in some jumps that appear to\n-     be optimizable (or blocks that appear to be mergeable), but which really \n-     must be left untouched (they are required to make it safely across \n-     partition boundaries).  See the comments at the top of \n+     be optimizable (or blocks that appear to be mergeable), but which really\n+     must be left untouched (they are required to make it safely across\n+     partition boundaries).  See the comments at the top of\n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n   if (BB_PARTITION (jump_block) != BB_PARTITION (jump_dest_block)\n@@ -192,7 +192,7 @@ mark_effect (rtx exp, regset nonequal)\n   switch (GET_CODE (exp))\n     {\n       /* In case we do clobber the register, mark it as equal, as we know the\n-         value is dead so it don't have to match.  */\n+\t value is dead so it don't have to match.  */\n     case CLOBBER:\n       if (REG_P (XEXP (exp, 0)))\n \t{\n@@ -413,12 +413,12 @@ try_forward_edges (int mode, basic_block b)\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n-     and cold sections. \n-  \n+     and cold sections.\n+\n      Basic block partitioning may result in some jumps that appear to\n      be optimizable (or blocks that appear to be mergeable), but which really m\n-     ust be left untouched (they are required to make it safely across \n-     partition boundaries).  See the comments at the top of \n+     ust be left untouched (they are required to make it safely across\n+     partition boundaries).  See the comments at the top of\n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n   if (find_reg_note (BB_END (b), REG_CROSSING_JUMP, NULL_RTX))\n@@ -434,9 +434,9 @@ try_forward_edges (int mode, basic_block b)\n \n       /* Skip complex edges because we don't know how to update them.\n \n-         Still handle fallthru edges, as we can succeed to forward fallthru\n-         edge to the same place as the branch edge of conditional branch\n-         and turn conditional branch to an unconditional branch.  */\n+\t Still handle fallthru edges, as we can succeed to forward fallthru\n+\t edge to the same place as the branch edge of conditional branch\n+\t and turn conditional branch to an unconditional branch.  */\n       if (e->flags & EDGE_COMPLEX)\n \t{\n \t  ei_next (&ei);\n@@ -450,8 +450,8 @@ try_forward_edges (int mode, basic_block b)\n \t up jumps that cross between hot/cold sections.\n \n \t Basic block partitioning may result in some jumps that appear\n-\t to be optimizable (or blocks that appear to be mergeable), but which \n-\t really must be left untouched (they are required to make it safely \n+\t to be optimizable (or blocks that appear to be mergeable), but which\n+\t really must be left untouched (they are required to make it safely\n \t across partition boundaries).  See the comments at the top of\n \t bb-reorder.c:partition_hot_cold_basic_blocks for complete\n \t details.  */\n@@ -467,7 +467,7 @@ try_forward_edges (int mode, basic_block b)\n \t  may_thread |= target->flags & BB_DIRTY;\n \n \t  if (FORWARDER_BLOCK_P (target)\n-  \t      && !(single_succ_edge (target)->flags & EDGE_CROSSING)\n+\t      && !(single_succ_edge (target)->flags & EDGE_CROSSING)\n \t      && single_succ (target) != EXIT_BLOCK_PTR)\n \t    {\n \t      /* Bypass trivial infinite loops.  */\n@@ -627,11 +627,11 @@ merge_blocks_move_predecessor_nojumps (basic_block a, basic_block b)\n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n      and cold sections.\n-  \n+\n      Basic block partitioning may result in some jumps that appear to\n-     be optimizable (or blocks that appear to be mergeable), but which really \n-     must be left untouched (they are required to make it safely across \n-     partition boundaries).  See the comments at the top of \n+     be optimizable (or blocks that appear to be mergeable), but which really\n+     must be left untouched (they are required to make it safely across\n+     partition boundaries).  See the comments at the top of\n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n   if (BB_PARTITION (a) != BB_PARTITION (b))\n@@ -682,12 +682,12 @@ merge_blocks_move_successor_nojumps (basic_block a, basic_block b)\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n-     and cold sections. \n-  \n+     and cold sections.\n+\n      Basic block partitioning may result in some jumps that appear to\n-     be optimizable (or blocks that appear to be mergeable), but which really \n-     must be left untouched (they are required to make it safely across \n-     partition boundaries).  See the comments at the top of \n+     be optimizable (or blocks that appear to be mergeable), but which really\n+     must be left untouched (they are required to make it safely across\n+     partition boundaries).  See the comments at the top of\n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n   if (BB_PARTITION (a) != BB_PARTITION (b))\n@@ -717,7 +717,7 @@ merge_blocks_move_successor_nojumps (basic_block a, basic_block b)\n      necessary.  */\n   only_notes = squeeze_notes (&BB_HEAD (b), &BB_END (b));\n   gcc_assert (!only_notes);\n-  \n+\n \n   /* Scramble the insn chain.  */\n   reorder_insns_nobb (BB_HEAD (b), BB_END (b), BB_END (a));\n@@ -752,18 +752,18 @@ merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n-     and cold sections. \n-  \n+     and cold sections.\n+\n      Basic block partitioning may result in some jumps that appear to\n-     be optimizable (or blocks that appear to be mergeable), but which really \n-     must be left untouched (they are required to make it safely across \n-     partition boundaries).  See the comments at the top of \n+     be optimizable (or blocks that appear to be mergeable), but which really\n+     must be left untouched (they are required to make it safely across\n+     partition boundaries).  See the comments at the top of\n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n   if (BB_PARTITION (b) != BB_PARTITION (c))\n     return NULL;\n-      \n-    \n+\n+\n \n   /* If B has a fallthru edge to C, no need to move anything.  */\n   if (e->flags & EDGE_FALLTHRU)\n@@ -789,7 +789,7 @@ merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n       edge_iterator ei;\n \n       /* Avoid overactive code motion, as the forwarder blocks should be\n-         eliminated by edge redirection instead.  One exception might have\n+\t eliminated by edge redirection instead.  One exception might have\n \t been if B is a forwarder block and C has no fallthru edge, but\n \t that should be cleaned up by bb-reorder instead.  */\n       if (FORWARDER_BLOCK_P (b) || FORWARDER_BLOCK_P (c))\n@@ -821,7 +821,7 @@ merge_blocks_move (edge e, basic_block b, basic_block c, int mode)\n       if (! c_has_outgoing_fallthru)\n \t{\n \t  merge_blocks_move_successor_nojumps (b, c);\n-          return next == ENTRY_BLOCK_PTR ? next->next_bb : next;\n+\t  return next == ENTRY_BLOCK_PTR ? next->next_bb : next;\n \t}\n \n       /* If B does not have an incoming fallthru, then it can be moved\n@@ -878,7 +878,7 @@ merge_memattrs (rtx x, rtx y)\n \tMEM_ATTRS (y) = 0;\n       else if (! MEM_ATTRS (y))\n \tMEM_ATTRS (x) = 0;\n-      else \n+      else\n \t{\n \t  rtx mem_size;\n \n@@ -887,7 +887,7 @@ merge_memattrs (rtx x, rtx y)\n \t      set_mem_alias_set (x, 0);\n \t      set_mem_alias_set (y, 0);\n \t    }\n-\t  \n+\n \t  if (! mem_expr_equal_p (MEM_EXPR (x), MEM_EXPR (y)))\n \t    {\n \t      set_mem_expr (x, 0);\n@@ -900,7 +900,7 @@ merge_memattrs (rtx x, rtx y)\n \t      set_mem_offset (x, 0);\n \t      set_mem_offset (y, 0);\n \t    }\n-\t \n+\n \t  if (!MEM_SIZE (x))\n \t    mem_size = NULL_RTX;\n \t  else if (!MEM_SIZE (y))\n@@ -915,7 +915,7 @@ merge_memattrs (rtx x, rtx y)\n \t  set_mem_align (y, MEM_ALIGN (x));\n \t}\n     }\n-  \n+\n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n@@ -968,7 +968,7 @@ old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx i1, rtx i2)\n \n   if (CALL_P (i1)\n       && (!rtx_equal_p (CALL_INSN_FUNCTION_USAGE (i1),\n-\t\t        CALL_INSN_FUNCTION_USAGE (i2))\n+\t\t\tCALL_INSN_FUNCTION_USAGE (i2))\n \t  || SIBLING_CALL_P (i1) != SIBLING_CALL_P (i2)))\n     return false;\n \n@@ -980,8 +980,8 @@ old_insns_match_p (int mode ATTRIBUTE_UNUSED, rtx i1, rtx i2)\n   if ((mode & CLEANUP_POST_REGSTACK) && stack_regs_mentioned (i1))\n     {\n       /* If register stack conversion has already been done, then\n-         death notes must also be compared before it is certain that\n-         the two instruction streams match.  */\n+\t death notes must also be compared before it is certain that\n+\t the two instruction streams match.  */\n \n       rtx note;\n       HARD_REG_SET i1_regset, i2_regset;\n@@ -1334,7 +1334,7 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n       f2 = FALLTHRU_EDGE (bb2);\n \n       /* Get around possible forwarders on fallthru edges.  Other cases\n-         should be optimized out already.  */\n+\t should be optimized out already.  */\n       if (FORWARDER_BLOCK_P (f1->dest))\n \tf1 = single_succ_edge (f1->dest);\n \n@@ -1513,7 +1513,7 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n   FOR_EACH_EDGE (e1, ei, bb1->succs)\n     {\n       e2 = EDGE_SUCC (bb2, ei.index);\n-      \n+\n       if (e1->flags & EDGE_EH)\n \tnehedges1++;\n \n@@ -1609,12 +1609,12 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n   newpos1 = newpos2 = NULL_RTX;\n \n   /* If we have partitioned hot/cold basic blocks, it is a bad idea\n-     to try this optimization. \n+     to try this optimization.\n \n      Basic block partitioning may result in some jumps that appear to\n-     be optimizable (or blocks that appear to be mergeable), but which really \n-     must be left untouched (they are required to make it safely across \n-     partition boundaries).  See the comments at the top of \n+     be optimizable (or blocks that appear to be mergeable), but which really\n+     must be left untouched (they are required to make it safely across\n+     partition boundaries).  See the comments at the top of\n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n   if (flag_reorder_blocks_and_partition && no_new_pseudos)\n@@ -1758,8 +1758,8 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n       s->count += s2->count;\n \n       /* Take care to update possible forwarder blocks.  We verified\n-         that there is no more than one in the chain, so we can't run\n-         into infinite loop.  */\n+\t that there is no more than one in the chain, so we can't run\n+\t into infinite loop.  */\n       if (FORWARDER_BLOCK_P (s->dest))\n \t{\n \t  single_succ_edge (s->dest)->count += s2->count;\n@@ -1839,16 +1839,16 @@ try_crossjump_bb (int mode, basic_block bb)\n \n   /* If we are partitioning hot/cold basic blocks, we don't want to\n      mess up unconditional or indirect jumps that cross between hot\n-     and cold sections. \n-  \n+     and cold sections.\n+\n      Basic block partitioning may result in some jumps that appear to\n-     be optimizable (or blocks that appear to be mergeable), but which really \n-     must be left untouched (they are required to make it safely across \n-     partition boundaries).  See the comments at the top of \n+     be optimizable (or blocks that appear to be mergeable), but which really\n+     must be left untouched (they are required to make it safely across\n+     partition boundaries).  See the comments at the top of\n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n-  if (BB_PARTITION (EDGE_PRED (bb, 0)->src) != \n-                                        BB_PARTITION (EDGE_PRED (bb, 1)->src)\n+  if (BB_PARTITION (EDGE_PRED (bb, 0)->src) !=\n+\t\t\t\t\tBB_PARTITION (EDGE_PRED (bb, 1)->src)\n       || (EDGE_PRED (bb, 0)->flags & EDGE_CROSSING))\n     return false;\n \n@@ -1864,7 +1864,7 @@ try_crossjump_bb (int mode, basic_block bb)\n   FOR_EACH_EDGE (e, ei, bb->preds)\n     {\n       if (e->flags & EDGE_FALLTHRU)\n-        fallthru = e;\n+\tfallthru = e;\n     }\n \n   changed = false;\n@@ -2075,7 +2075,7 @@ try_optimize_cfg (int mode)\n \t\t     does not fit merge_blocks interface and is kept here in\n \t\t     hope that it will become useless once more of compiler\n \t\t     is transformed to use cfg_layout mode.  */\n-\t\t     \n+\n \t\t  if ((mode & CLEANUP_CFGLAYOUT)\n \t\t      && can_merge_blocks_p (b, c))\n \t\t    {\n@@ -2247,7 +2247,7 @@ cleanup_cfg (int mode)\n \t\t\t\t\t\t PROP_DEATH_NOTES\n \t\t\t\t\t\t | PROP_SCAN_DEAD_CODE\n \t\t\t\t\t\t | PROP_KILL_DEAD_CODE\n-\t\t\t  \t\t\t | ((mode & CLEANUP_LOG_LINKS)\n+\t\t\t\t\t\t | ((mode & CLEANUP_LOG_LINKS)\n \t\t\t\t\t\t    ? PROP_LOG_LINKS : 0)))\n \t    break;\n \t}\n@@ -2281,8 +2281,8 @@ rest_of_handle_jump (void)\n struct tree_opt_pass pass_jump =\n {\n   \"sibling\",                            /* name */\n-  NULL,                                 /* gate */   \n-  rest_of_handle_jump,\t\t\t/* execute */       \n+  NULL,                                 /* gate */\n+  rest_of_handle_jump,\t\t\t/* execute */\n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */\n@@ -2310,7 +2310,7 @@ rest_of_handle_jump2 (void)\n   if (dump_file)\n     dump_flow_info (dump_file, dump_flags);\n   cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0)\n-               | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n+\t       | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n \n   purge_line_number_notes ();\n \n@@ -2330,8 +2330,8 @@ rest_of_handle_jump2 (void)\n struct tree_opt_pass pass_jump2 =\n {\n   \"jump\",                               /* name */\n-  NULL,                                 /* gate */   \n-  rest_of_handle_jump2,\t\t\t/* execute */       \n+  NULL,                                 /* gate */\n+  rest_of_handle_jump2,\t\t\t/* execute */\n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */"}, {"sha": "4822ed8b3cd6d2dc13e111b8a16ac85215db418b", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -513,7 +513,7 @@ expand_one_stack_var_at (tree decl, HOST_WIDE_INT offset)\n {\n   HOST_WIDE_INT align;\n   rtx x;\n-  \n+\n   /* If this fails, we've overflowed the stack frame.  Error nicely?  */\n   gcc_assert (offset == trunc_int_for_mode (offset, Pmode));\n \n@@ -557,7 +557,7 @@ expand_stack_vars (bool (*pred) (tree))\n       if (DECL_RTL (stack_vars[i].decl) != pc_rtx)\n \tcontinue;\n \n-      /* Check the predicate to see whether this variable should be \n+      /* Check the predicate to see whether this variable should be\n \t allocated in this pass.  */\n       if (pred && !pred (stack_vars[i].decl))\n \tcontinue;\n@@ -674,7 +674,7 @@ expand_one_error_var (tree var)\n   SET_DECL_RTL (var, x);\n }\n \n-/* A subroutine of expand_one_var.  VAR is a variable that will be \n+/* A subroutine of expand_one_var.  VAR is a variable that will be\n    allocated to the local stack frame.  Return true if we wish to\n    add VAR to STACK_VARS so that it will be coalesced with other\n    variables.  Return false to allocate VAR immediately.\n@@ -699,7 +699,7 @@ defer_stack_allocation (tree var, bool toplevel)\n \n   /* Without optimization, *most* variables are allocated from the\n      stack, which makes the quadratic problem large exactly when we\n-     want compilation to proceed as quickly as possible.  On the \n+     want compilation to proceed as quickly as possible.  On the\n      other hand, we don't want the function's stack frame size to\n      get completely out of hand.  So we avoid adding scalars and\n      \"small\" aggregates to the list at all.  */\n@@ -1001,16 +1001,16 @@ expand_used_vars (void)\n   if (stack_vars_num > 0)\n     {\n       /* Due to the way alias sets work, no variables with non-conflicting\n-\t alias sets may be assigned the same address.  Add conflicts to \n+\t alias sets may be assigned the same address.  Add conflicts to\n \t reflect this.  */\n       add_alias_set_conflicts ();\n \n-      /* If stack protection is enabled, we don't share space between \n+      /* If stack protection is enabled, we don't share space between\n \t vulnerable data and non-vulnerable data.  */\n       if (flag_stack_protect)\n \tadd_stack_protection_conflicts ();\n \n-      /* Now that we have collected all stack variables, and have computed a \n+      /* Now that we have collected all stack variables, and have computed a\n \t minimal interference graph, attempt to save some stack space.  */\n       partition_stack_vars ();\n       if (dump_file)\n@@ -1029,7 +1029,7 @@ expand_used_vars (void)\n     {\n       /* Reorder decls to be protected by iterating over the variables\n \t array multiple times, and allocating out of each phase in turn.  */\n-      /* ??? We could probably integrate this into the qsort we did \n+      /* ??? We could probably integrate this into the qsort we did\n \t earlier, such that we naturally see these variables first,\n \t and thus naturally allocate things in the right order.  */\n       if (has_protected_decls)\n@@ -1158,7 +1158,7 @@ expand_gimple_cond_expr (basic_block bb, tree stmt)\n   update_bb_for_insn (new_bb);\n \n   maybe_dump_rtl_for_tree_stmt (stmt, last2);\n-  \n+\n   if (EXPR_LOCUS (else_exp))\n     emit_line_note (*(EXPR_LOCUS (else_exp)));\n \n@@ -1221,9 +1221,9 @@ expand_gimple_tailcall (basic_block bb, tree stmt, bool *can_fallthru)\n \t      e->dest->count -= e->count;\n \t      e->dest->frequency -= EDGE_FREQUENCY (e);\n \t      if (e->dest->count < 0)\n-\t        e->dest->count = 0;\n+\t\te->dest->count = 0;\n \t      if (e->dest->frequency < 0)\n-\t        e->dest->frequency = 0;\n+\t\te->dest->frequency = 0;\n \t    }\n \t  count += e->count;\n \t  probability += e->probability;\n@@ -1303,7 +1303,7 @@ expand_gimple_basic_block (basic_block bb)\n       expand_expr_stmt (stmt);\n \n       /* Java emits line number notes in the top of labels.\n-         ??? Make this go away once line number notes are obsoleted.  */\n+\t ??? Make this go away once line number notes are obsoleted.  */\n       BB_HEAD (bb) = NEXT_INSN (last);\n       if (NOTE_P (BB_HEAD (bb)))\n \tBB_HEAD (bb) = NEXT_INSN (BB_HEAD (bb));\n@@ -1323,8 +1323,8 @@ expand_gimple_basic_block (basic_block bb)\n       e->flags &= ~EDGE_EXECUTABLE;\n \n       /* At the moment not all abnormal edges match the RTL representation.\n-         It is safe to remove them here as find_many_sub_basic_blocks will\n-         rediscover them.  In the future we should get this fixed properly.  */\n+\t It is safe to remove them here as find_many_sub_basic_blocks will\n+\t rediscover them.  In the future we should get this fixed properly.  */\n       if (e->flags & EDGE_ABNORMAL)\n \tremove_edge (e);\n       else\n@@ -1492,7 +1492,7 @@ construct_exit_block (void)\n   FOR_EACH_EDGE (e2, ei, EXIT_BLOCK_PTR->preds)\n     if (e2 != e)\n       {\n-        e->count -= e2->count;\n+\te->count -= e2->count;\n \texit_block->count -= e2->count;\n \texit_block->frequency -= EDGE_FREQUENCY (e2);\n       }\n@@ -1505,7 +1505,7 @@ construct_exit_block (void)\n   update_bb_for_insn (exit_block);\n }\n \n-/* Helper function for discover_nonconstant_array_refs. \n+/* Helper function for discover_nonconstant_array_refs.\n    Look for ARRAY_REF nodes with non-constant indexes and mark them\n    addressable.  */\n \n@@ -1668,15 +1668,15 @@ tree_expand_cfg (void)\n \n   /* If we're emitting a nested function, make sure its parent gets\n      emitted as well.  Doing otherwise confuses debug info.  */\n-  {   \n+  {\n     tree parent;\n     for (parent = DECL_CONTEXT (current_function_decl);\n-         parent != NULL_TREE;\n-         parent = get_containing_scope (parent))\n+\t parent != NULL_TREE;\n+\t parent = get_containing_scope (parent))\n       if (TREE_CODE (parent) == FUNCTION_DECL)\n-        TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (parent)) = 1;\n+\tTREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (parent)) = 1;\n   }\n-    \n+\n   /* We are now committed to emitting code for this function.  Do any\n      preparation, such as emitting abstract debug info for the inline\n      before it gets mangled by optimization.  */\n@@ -1693,13 +1693,13 @@ tree_expand_cfg (void)\n \n struct tree_opt_pass pass_expand =\n {\n-  \"expand\",\t\t                /* name */\n+  \"expand\",\t\t\t\t/* name */\n   NULL,                                 /* gate */\n-  tree_expand_cfg,\t                /* execute */\n+  tree_expand_cfg,\t\t\t/* execute */\n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */\n-  TV_EXPAND,\t\t                /* tv_id */\n+  TV_EXPAND,\t\t\t\t/* tv_id */\n   /* ??? If TER is enabled, we actually receive GENERIC.  */\n   PROP_gimple_leh | PROP_cfg,           /* properties_required */\n   PROP_rtl,                             /* properties_provided */"}, {"sha": "a4cc31c8b6173d8eae36edd403966db6304671d9", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -111,13 +111,13 @@ verify_flow_info (void)\n       if (bb->count < 0)\n \t{\n \t  error (\"verify_flow_info: Wrong count of block %i %i\",\n-\t         bb->index, (int)bb->count);\n+\t\t bb->index, (int)bb->count);\n \t  err = 1;\n \t}\n       if (bb->frequency < 0)\n \t{\n \t  error (\"verify_flow_info: Wrong frequency of block %i %i\",\n-\t         bb->index, bb->frequency);\n+\t\t bb->index, bb->frequency);\n \t  err = 1;\n \t}\n       FOR_EACH_EDGE (e, ei, bb->succs)\n@@ -238,7 +238,7 @@ dump_bb (basic_block bb, FILE *outf, int indent)\n   edge e;\n   edge_iterator ei;\n   char *s_indent;\n- \n+\n   s_indent = alloca ((size_t) indent + 1);\n   memset (s_indent, ' ', (size_t) indent);\n   s_indent[indent] = '\\0';\n@@ -767,7 +767,7 @@ duplicate_block (basic_block bb, edge e, basic_block after)\n /* Return 1 if BB ends with a call, possibly followed by some\n    instructions that must stay with the call, 0 otherwise.  */\n \n-bool \n+bool\n block_ends_with_call_p (basic_block bb)\n {\n   if (!cfg_hooks->block_ends_with_call_p)\n@@ -778,7 +778,7 @@ block_ends_with_call_p (basic_block bb)\n \n /* Return 1 if BB ends with a conditional branch, 0 otherwise.  */\n \n-bool \n+bool\n block_ends_with_condjump_p (basic_block bb)\n {\n   if (!cfg_hooks->block_ends_with_condjump_p)\n@@ -800,7 +800,7 @@ int\n flow_call_edges_add (sbitmap blocks)\n {\n   if (!cfg_hooks->flow_call_edges_add)\n-    internal_error (\"%s does not support flow_call_edges_add\", \n+    internal_error (\"%s does not support flow_call_edges_add\",\n \t\t    cfg_hooks->name);\n \n   return (cfg_hooks->flow_call_edges_add) (blocks);\n@@ -826,8 +826,8 @@ execute_on_shrinking_pred (edge e)\n     cfg_hooks->execute_on_shrinking_pred (e);\n }\n \n-/* This is used inside loop versioning when we want to insert \n-   stmts/insns on the edges, which have a different behavior \n+/* This is used inside loop versioning when we want to insert\n+   stmts/insns on the edges, which have a different behavior\n    in tree's and in RTL, so we made a CFG hook.  */\n void\n lv_flush_pending_stmts (edge e)\n@@ -851,7 +851,7 @@ cfg_hook_duplicate_loop_to_header_edge (struct loop *loop, edge e,\n \t\t\t\t\tunsigned int *n_to_remove, int flags)\n {\n   gcc_assert (cfg_hooks->cfg_hook_duplicate_loop_to_header_edge);\n-  return cfg_hooks->cfg_hook_duplicate_loop_to_header_edge (loop, e, loops, \t\t\t\t\t\t\t    \n+  return cfg_hooks->cfg_hook_duplicate_loop_to_header_edge (loop, e, loops,\n \t\t\t\t\t\t\t    ndupl, wont_exit,\n \t\t\t\t\t\t\t    orig, to_remove,\n \t\t\t\t\t\t\t    n_to_remove, flags);\n@@ -887,4 +887,4 @@ lv_add_condition_to_bb (basic_block first, basic_block second,\n {\n   gcc_assert (cfg_hooks->lv_add_condition_to_bb);\n   cfg_hooks->lv_add_condition_to_bb (first, second, new, cond);\n-}  \n+}"}, {"sha": "fcdc23f4048d1706f758c8438e4d79eb871642e8", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -122,16 +122,16 @@ struct cfg_hooks\n   /* Add condition to new basic block and update CFG used in loop\n      versioning.  */\n   void (*lv_add_condition_to_bb) (basic_block, basic_block, basic_block,\n-  \t\t\t\t  void *);\n+\t\t\t\t  void *);\n   /* Update the PHI nodes in case of loop versioning.  */\n   void (*lv_adjust_loop_header_phi) (basic_block, basic_block,\n \t\t\t\t     basic_block, edge);\n-\t\t\t\t    \n+\n   /* Given a condition BB extract the true/false taken/not taken edges\n      (depending if we are on tree's or RTL). */\n   void (*extract_cond_bb_edges) (basic_block, edge *, edge *);\n \n-  \n+\n   /* Add PHI arguments queued in PENDINT_STMT list on edge E to edge\n      E->dest (only in tree-ssa loop versioning.  */\n   void (*flush_pending_stmts) (edge);"}, {"sha": "cddb0daa5ce156058b1ee130219ad3a2bb845da0", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -117,7 +117,7 @@ skip_insns_after_block (basic_block bb)\n \t  if (NEXT_INSN (insn)\n \t      && JUMP_P (NEXT_INSN (insn))\n \t      && (GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_VEC\n-\t          || GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_DIFF_VEC))\n+\t\t  || GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_DIFF_VEC))\n \t    {\n \t      insn = NEXT_INSN (insn);\n \t      last_insn = insn;\n@@ -196,7 +196,7 @@ record_effective_endpoints (void)\n     continue;\n   /* No basic blocks at all?  */\n   gcc_assert (insn);\n-  \n+\n   if (PREV_INSN (insn))\n     cfg_layout_function_header =\n \t    unlink_insn_chain (get_insns (), PREV_INSN (insn));\n@@ -264,7 +264,7 @@ insn_locators_initialize (void)\n   for (insn = get_insns (); insn; insn = next)\n     {\n       int active = 0;\n-      \n+\n       next = NEXT_INSN (insn);\n \n       if (NOTE_P (insn))\n@@ -283,7 +283,7 @@ insn_locators_initialize (void)\n \tactive = (active_insn_p (insn)\n \t\t  && GET_CODE (PATTERN (insn)) != ADDR_VEC\n \t\t  && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC);\n-      \n+\n       check_block_change (insn, &block);\n \n       if (active\n@@ -331,8 +331,8 @@ insn_locators_initialize (void)\n struct tree_opt_pass pass_insn_locators_initialize =\n {\n   \"locators\",                           /* name */\n-  NULL,                                 /* gate */   \n-  insn_locators_initialize,             /* execute */       \n+  NULL,                                 /* gate */\n+  insn_locators_initialize,             /* execute */\n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */\n@@ -549,7 +549,7 @@ reemit_insn_block_notes (void)\n \n       this_block = insn_scope (insn);\n       /* For sequences compute scope resulting from merging all scopes\n-         of instructions nested inside.  */\n+\t of instructions nested inside.  */\n       if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n \t{\n \t  int i;\n@@ -673,7 +673,7 @@ fixup_reorder_chain (void)\n \t    {\n \t      /* If the old fallthru is still next, nothing to do.  */\n \t      if (bb->aux == e_fall->dest\n-\t          || e_fall->dest == EXIT_BLOCK_PTR)\n+\t\t  || e_fall->dest == EXIT_BLOCK_PTR)\n \t\tcontinue;\n \n \t      /* The degenerated case of conditional jump jumping to the next\n@@ -767,7 +767,7 @@ fixup_reorder_chain (void)\n \t  bb->aux = nb;\n \t  /* Don't process this new block.  */\n \t  bb = nb;\n-\t  \n+\n \t  /* Make sure new bb is tagged for correct section (same as\n \t     fall-thru source, since you cannot fall-throu across\n \t     section boundaries).  */\n@@ -979,7 +979,7 @@ duplicate_insn_chain (rtx from, rtx to)\n \t  switch (NOTE_LINE_NUMBER (insn))\n \t    {\n \t      /* In case prologue is empty and function contain label\n-\t         in first BB, we may want to copy the block.  */\n+\t\t in first BB, we may want to copy the block.  */\n \t    case NOTE_INSN_PROLOGUE_END:\n \n \t    case NOTE_INSN_DELETED:\n@@ -988,9 +988,9 @@ duplicate_insn_chain (rtx from, rtx to)\n \t    case NOTE_INSN_EPILOGUE_BEG:\n \t    case NOTE_INSN_FUNCTION_END:\n \t      /* Debug code expect these notes to exist just once.\n-\t         Keep them in the master copy.\n-\t         ??? It probably makes more sense to duplicate them for each\n-\t         epilogue copy.  */\n+\t\t Keep them in the master copy.\n+\t\t ??? It probably makes more sense to duplicate them for each\n+\t\t epilogue copy.  */\n \t    case NOTE_INSN_FUNCTION_BEG:\n \t      /* There is always just single entry to function.  */\n \t    case NOTE_INSN_BASIC_BLOCK:\n@@ -1005,9 +1005,9 @@ duplicate_insn_chain (rtx from, rtx to)\n \t      /* All other notes should have already been eliminated.\n \t       */\n \t      gcc_assert (NOTE_LINE_NUMBER (insn) >= 0);\n-\t      \n+\n \t      /* It is possible that no_line_number is set and the note\n-\t         won't be emitted.  */\n+\t\t won't be emitted.  */\n \t      emit_note_copy (insn);\n \t    }\n \t  break;\n@@ -1209,7 +1209,7 @@ can_copy_bbs_p (basic_block *bbs, unsigned n)\n \n    Created copies of N_EDGES edges in array EDGES are stored in array NEW_EDGES,\n    also in the same order.\n-   \n+\n    Newly created basic blocks are put after the basic block AFTER in the\n    instruction stream, and the order of the blocks in BBS array is preserved.  */\n "}, {"sha": "9afd48ba21790f887ec6cc46a5e136cb65b23d5d", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -885,31 +885,31 @@ get_loop_body_in_bfs_order (const struct loop *loop)\n     {\n       edge e;\n       edge_iterator ei;\n-      \n+\n       if (!bitmap_bit_p (visited, bb->index))\n-        { \n-          /* This basic block is now visited */\n-          bitmap_set_bit (visited, bb->index);\n-          blocks[i++] = bb;\n-        }\n-      \n+\t{\n+\t  /* This basic block is now visited */\n+\t  bitmap_set_bit (visited, bb->index);\n+\t  blocks[i++] = bb;\n+\t}\n+\n       FOR_EACH_EDGE (e, ei, bb->succs)\n-        { \n-          if (flow_bb_inside_loop_p (loop, e->dest))\n-            { \n-              if (!bitmap_bit_p (visited, e->dest->index))\n-                { \n-                  bitmap_set_bit (visited, e->dest->index);\n-                  blocks[i++] = e->dest;\n-                }\n-            }\n-        }\n-      \n+\t{\n+\t  if (flow_bb_inside_loop_p (loop, e->dest))\n+\t    {\n+\t      if (!bitmap_bit_p (visited, e->dest->index))\n+\t\t{\n+\t\t  bitmap_set_bit (visited, e->dest->index);\n+\t\t  blocks[i++] = e->dest;\n+\t\t}\n+\t    }\n+\t}\n+\n       gcc_assert (i >= vc);\n-      \n+\n       bb = blocks[vc++];\n     }\n-  \n+\n   BITMAP_FREE (visited);\n   return blocks;\n }\n@@ -1072,7 +1072,7 @@ verify_loop_structure (struct loops *loops)\n   for (i = 0; i < loops->num; i++)\n     {\n       if (!loops->parray[i])\n-        continue;\n+\tcontinue;\n \n       if (loops->parray[i]->num_nodes != sizes[i])\n \t{"}, {"sha": "6838677011ea3ad148ba68a3e801ae7fea25413c", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -270,7 +270,7 @@ extern bool remove_path (struct loops *, edge);\n \n    If first_special is true, the value in the first iteration is\n      delta + mult * base\n-     \n+\n    If extend = UNKNOWN, first_special must be false, delta 0, mult 1 and value is\n      subreg_{mode} (base + i * step)\n "}, {"sha": "060c9c2ddd81e201f73f10b750bd530ff012cd28", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -178,7 +178,7 @@ dfs (struct graph *g, int *qs, int nq, int *qt, bool forward)\n \t    {\n \t      if (qt)\n \t\tqt[tick] = v;\n- \t      g->vertices[v].post = tick++;\n+\t      g->vertices[v].post = tick++;\n \n \t      if (!top)\n \t\tbreak;\n@@ -257,7 +257,7 @@ free_graph (struct graph *g)\n    for parts of cycles that only \"pass\" through some loop -- i.e. for\n    each cycle, we want to mark blocks that belong directly to innermost\n    loop containing the whole cycle.\n-   \n+\n    LOOPS is the loop tree.  */\n \n #define LOOP_REPR(LOOP) ((LOOP)->num + last_basic_block)\n@@ -290,8 +290,8 @@ mark_irreducible_loops (struct loops *loops)\n   FOR_BB_BETWEEN (act, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR, next_bb)\n     FOR_EACH_EDGE (e, ei, act->succs)\n       {\n-        /* Ignore edges to exit.  */\n-        if (e->dest == EXIT_BLOCK_PTR)\n+\t/* Ignore edges to exit.  */\n+\tif (e->dest == EXIT_BLOCK_PTR)\n \t  continue;\n \n \t/* And latch edges.  */\n@@ -433,9 +433,9 @@ expected_loop_iterations (const struct loop *loop)\n \t  count_in += e->count;\n \n       if (count_in == 0)\n-        expected = count_latch * 2;\n+\texpected = count_latch * 2;\n       else\n-        expected = (count_latch + count_in - 1) / count_in;\n+\texpected = (count_latch + count_in - 1) / count_in;\n \n       /* Avoid overflows.  */\n       return (expected > REG_BR_PROB_BASE ? REG_BR_PROB_BASE : expected);\n@@ -526,7 +526,7 @@ init_set_costs (void)\n   target_res_regs = 3;\n \n   /* These are really just heuristic values.  */\n-  \n+\n   start_sequence ();\n   emit_move_insn (reg1, reg2);\n   seq = get_insns ();\n@@ -572,7 +572,7 @@ mark_loop_exit_edges (struct loops *loops)\n {\n   basic_block bb;\n   edge e;\n- \n+\n   if (loops->num <= 1)\n     return;\n "}, {"sha": "5f5869b76e474a12c8da3b433ab6c8589b5de9fa", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -455,7 +455,7 @@ scale_loop_frequencies (struct loop *loop, int num, int den)\n    Returns newly created loop.  */\n \n struct loop *\n-loopify (struct loops *loops, edge latch_edge, edge header_edge, \n+loopify (struct loops *loops, edge latch_edge, edge header_edge,\n \t basic_block switch_bb, edge true_edge, edge false_edge,\n \t bool redirect_all_edges)\n {\n@@ -490,8 +490,8 @@ loopify (struct loops *loops, edge latch_edge, edge header_edge,\n   if (redirect_all_edges)\n     {\n       loop_redirect_edge (header_edge, switch_bb);\n-      loop_redirect_edge (false_edge, loop->header); \n-     \n+      loop_redirect_edge (false_edge, loop->header);\n+\n       /* Update dominators.  */\n       set_immediate_dominator (CDI_DOMINATORS, switch_bb, pred_bb);\n       set_immediate_dominator (CDI_DOMINATORS, loop->header, switch_bb);\n@@ -652,7 +652,7 @@ fix_loop_placements (struct loops *loops, struct loop *loop)\n     {\n       outer = loop->outer;\n       if (!fix_loop_placement (loop))\n-        break;\n+\tbreak;\n \n       /* Changing the placement of a loop in the loop tree may alter the\n \t validity of condition 2) of the description of fix_bb_placement\n@@ -746,7 +746,7 @@ loop_delete_branch_edge (edge e, int really_delete)\n   edge snd;\n \n   gcc_assert (EDGE_COUNT (src->succs) > 1);\n-  \n+\n   /* Cannot handle more than two exit edges.  */\n   if (EDGE_COUNT (src->succs) > 2)\n     return false;\n@@ -770,7 +770,7 @@ loop_delete_branch_edge (edge e, int really_delete)\n     return false;\n   single_succ_edge (src)->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n   single_succ_edge (src)->flags |= irr;\n-  \n+\n   return true;\n }\n \n@@ -783,7 +783,7 @@ can_duplicate_loop_p (struct loop *loop)\n \n   ret = can_copy_bbs_p (bbs, loop->num_nodes);\n   free (bbs);\n-  \n+\n   return ret;\n }\n \n@@ -902,7 +902,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n \t\t\t\t: prob_pass_thru;\n \n       /* Complete peeling is special as the probability of exit in last\n-         copy becomes 1.  */\n+\t copy becomes 1.  */\n       if (flags & DLTHE_FLAG_COMPLETTE_PEEL)\n \t{\n \t  int wanted_freq = EDGE_FREQUENCY (e);\n@@ -919,7 +919,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n \t  /* Now simulate the duplication adjustments and compute header\n \t     frequency of the last copy.  */\n \t  for (i = 0; i < ndupl; i++)\n-            wanted_freq = RDIV (wanted_freq * scale_step[i], REG_BR_PROB_BASE);\n+\t    wanted_freq = RDIV (wanted_freq * scale_step[i], REG_BR_PROB_BASE);\n \t  scale_main = RDIV (wanted_freq * REG_BR_PROB_BASE, freq_in);\n \t}\n       else if (is_latch)\n@@ -1061,7 +1061,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n     }\n   free (new_bbs);\n   free (orig_loops);\n-  \n+\n   /* Update the original loop.  */\n   if (!is_latch)\n     set_immediate_dominator (CDI_DOMINATORS, e->dest, e->src);\n@@ -1088,7 +1088,7 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n \t    continue;\n \t  dom_bb = nearest_common_dominator (\n \t\t\tCDI_DOMINATORS, first_active[i], first_active_latch);\n-          set_immediate_dominator (CDI_DOMINATORS, dominated, dom_bb);\n+\t  set_immediate_dominator (CDI_DOMINATORS, dominated, dom_bb);\n \t}\n       free (dom_bbs);\n     }\n@@ -1286,8 +1286,8 @@ loop_split_edge_with (edge e, rtx insns)\n    Split it and insert new conditional expression and adjust edges.\n \n     --- edge e ---> [cond expr] ---> [first_head]\n-                        |\n-                        +---------> [second_head]\n+\t\t\t|\n+\t\t\t+---------> [second_head]\n */\n \n static basic_block\n@@ -1321,7 +1321,7 @@ lv_adjust_loop_entry_edge (basic_block first_head,\n }\n \n /* Main entry point for Loop Versioning transformation.\n-   \n+\n    This transformation given a condition and a loop, creates\n    -if (condition) { loop_copy1 } else { loop_copy2 },\n    where loop_copy1 is the loop transformed in one way, and loop_copy2\n@@ -1333,7 +1333,7 @@ lv_adjust_loop_entry_edge (basic_block first_head,\n    instruction stream, otherwise it is placed before LOOP.  */\n \n struct loop *\n-loop_version (struct loops *loops, struct loop * loop, \n+loop_version (struct loops *loops, struct loop * loop,\n \t      void *cond_expr, basic_block *condition_bb,\n \t      bool place_after)\n {\n@@ -1351,13 +1351,13 @@ loop_version (struct loops *loops, struct loop * loop,\n   entry = loop_preheader_edge (loop);\n   irred_flag = entry->flags & EDGE_IRREDUCIBLE_LOOP;\n   entry->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n-  \n+\n   /* Note down head of loop as first_head.  */\n   first_head = entry->dest;\n \n   /* Duplicate loop.  */\n   if (!cfg_hook_duplicate_loop_to_header_edge (loop, entry, loops, 1,\n-  \t\t\t\t\t       NULL, NULL, NULL, NULL, 0))\n+\t\t\t\t\t       NULL, NULL, NULL, NULL, 0))\n     return NULL;\n \n   /* After duplication entry edge now points to new loop head block.\n@@ -1377,7 +1377,7 @@ loop_version (struct loops *loops, struct loop * loop,\n     }\n \n   latch_edge = single_succ_edge (get_bb_copy (loop->latch));\n-  \n+\n   extract_cond_bb_edges (cond_bb, &true_edge, &false_edge);\n   nloop = loopify (loops,\n \t\t   latch_edge,\n@@ -1389,10 +1389,10 @@ loop_version (struct loops *loops, struct loop * loop,\n   if (exit)\n     nloop->single_exit = find_edge (get_bb_copy (exit->src), exit->dest);\n \n-  /* loopify redirected latch_edge. Update its PENDING_STMTS.  */ \n+  /* loopify redirected latch_edge. Update its PENDING_STMTS.  */\n   lv_flush_pending_stmts (latch_edge);\n \n-  /* loopify redirected condition_bb's succ edge. Update its PENDING_STMTS.  */ \n+  /* loopify redirected condition_bb's succ edge. Update its PENDING_STMTS.  */\n   extract_cond_bb_edges (cond_bb, &true_edge, &false_edge);\n   lv_flush_pending_stmts (false_edge);\n   /* Adjust irreducible flag.  */\n@@ -1419,8 +1419,8 @@ loop_version (struct loops *loops, struct loop * loop,\n       free (bbs);\n     }\n \n-  /* At this point condition_bb is loop predheader with two successors, \n-     first_head and second_head.   Make sure that loop predheader has only \n+  /* At this point condition_bb is loop predheader with two successors,\n+     first_head and second_head.   Make sure that loop predheader has only\n      one successor.  */\n   loop_split_edge_with (loop_preheader_edge (loop), NULL);\n   loop_split_edge_with (loop_preheader_edge (nloop), NULL);\n@@ -1435,7 +1435,7 @@ loop_version (struct loops *loops, struct loop * loop,\n    to be correct).  But still for the remaining loops the header dominates\n    the latch, and loops did not get new subloobs (new loops might possibly\n    get created, but we are not interested in them).  Fix up the mess.\n- \n+\n    If CHANGED_BBS is not NULL, basic blocks whose loop has changed are\n    marked in it.  */\n \n@@ -1454,7 +1454,7 @@ fix_loop_structure (struct loops *loops, bitmap changed_bbs)\n     }\n \n   /* Remove the dead loops from structures.  */\n-  loops->tree_root->num_nodes = n_basic_blocks; \n+  loops->tree_root->num_nodes = n_basic_blocks;\n   for (i = 1; i < loops->num; i++)\n     {\n       loop = loops->parray[i];"}, {"sha": "723e323ef26fd499a1c28beb39b96886b546a9cb", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -112,8 +112,8 @@ delete_insn (rtx insn)\n   if (LABEL_P (insn))\n     {\n       /* Some labels can't be directly removed from the INSN chain, as they\n-         might be references via variables, constant pool etc.\n-         Convert them to the special NOTE_INSN_DELETED_LABEL note.  */\n+\t might be references via variables, constant pool etc.\n+\t Convert them to the special NOTE_INSN_DELETED_LABEL note.  */\n       if (! can_delete_label_p (insn))\n \t{\n \t  const char *name = LABEL_NAME (insn);\n@@ -442,7 +442,7 @@ struct tree_opt_pass pass_free_cfg =\n rtx\n entry_of_function (void)\n {\n-  return (n_basic_blocks > NUM_FIXED_BLOCKS ? \n+  return (n_basic_blocks > NUM_FIXED_BLOCKS ?\n \t  BB_HEAD (ENTRY_BLOCK_PTR->next_bb) : get_insns ());\n }\n \n@@ -545,7 +545,7 @@ rtl_merge_blocks (basic_block a, basic_block b)\n       /* This might have been an EH label that no longer has incoming\n \t EH edges.  Update data structures to match.  */\n       maybe_remove_eh_handler (b_head);\n- \n+\n       /* Detect basic blocks with nothing but a label.  This can happen\n \t in particular at the end of a function.  */\n       if (b_head == b_end)\n@@ -631,9 +631,9 @@ rtl_can_merge_blocks (basic_block a,basic_block b)\n      and cold sections.\n \n      Basic block partitioning may result in some jumps that appear to\n-     be optimizable (or blocks that appear to be mergeable), but which really \n-     must be left untouched (they are required to make it safely across \n-     partition boundaries).  See  the comments at the top of \n+     be optimizable (or blocks that appear to be mergeable), but which really\n+     must be left untouched (they are required to make it safely across\n+     partition boundaries).  See  the comments at the top of\n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n   if (BB_PARTITION (a) != BB_PARTITION (b))\n@@ -690,11 +690,11 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n      and cold sections.\n \n      Basic block partitioning may result in some jumps that appear to\n-     be optimizable (or blocks that appear to be mergeable), but which really \n-     must be left untouched (they are required to make it safely across \n-     partition boundaries).  See  the comments at the top of \n+     be optimizable (or blocks that appear to be mergeable), but which really\n+     must be left untouched (they are required to make it safely across\n+     partition boundaries).  See  the comments at the top of\n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n-  \n+\n   if (find_reg_note (insn, REG_CROSSING_JUMP, NULL_RTX)\n       || BB_PARTITION (src) != BB_PARTITION (target))\n     return NULL;\n@@ -739,7 +739,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \t{\n \t  rtx insn = src->il.rtl->footer;\n \n-          delete_insn_chain (kill_from, BB_END (src));\n+\t  delete_insn_chain (kill_from, BB_END (src));\n \n \t  /* Remove barriers but keep jumptables.  */\n \t  while (insn)\n@@ -759,7 +759,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n \t    }\n \t}\n       else\n-        delete_insn_chain (kill_from, PREV_INSN (BB_HEAD (target)));\n+\tdelete_insn_chain (kill_from, PREV_INSN (BB_HEAD (target)));\n     }\n \n   /* If this already is simplejump, redirect it.  */\n@@ -1002,7 +1002,7 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n \n       redirected = redirect_jump (BB_END (e->src), block_label (target), 0);\n       gcc_assert (redirected);\n-      \n+\n       note = find_reg_note (BB_END (e->src), REG_BR_PROB, NULL_RTX);\n       if (note)\n \t{\n@@ -1041,9 +1041,9 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n \t  edge tmp;\n \t  edge_iterator ei;\n \t  bool found = false;\n-\t  \n+\n \t  basic_block bb = create_basic_block (BB_HEAD (e->dest), NULL, ENTRY_BLOCK_PTR);\n-\t  \n+\n \t  /* Change the existing edge's source to be the new block, and add\n \t     a new edge from the entry block to the new block.  */\n \t  e->src = bb;\n@@ -1058,9 +1058,9 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n \t      else\n \t\tei_next (&ei);\n \t    }\n-\t  \n+\n \t  gcc_assert (found);\n-\t  \n+\n \t  VEC_safe_push (edge, gc, bb->succs, e);\n \t  make_single_succ_edge (ENTRY_BLOCK_PTR, bb, EDGE_FALLTHRU);\n \t}\n@@ -1104,8 +1104,8 @@ force_nonfallthru_and_redirect (edge e, basic_block target)\n \t\t\t\t\t\t\t     NULL_RTX,\n \t\t\t\t\t\t\t     REG_NOTES\n \t\t\t\t\t\t\t     (BB_END\n-                                                              (jump_block)));\n-      \n+\t\t\t\t\t\t\t      (jump_block)));\n+\n       /* Wire edge in.  */\n       new_edge = make_edge (e->src, jump_block, EDGE_FALLTHRU);\n       new_edge->probability = e->probability;\n@@ -1370,7 +1370,7 @@ commit_one_edge_insertion (edge e, int watch_calls)\n   if (!before && !after)\n     {\n       /* Figure out where to put these things.  If the destination has\n-         one predecessor, insert there.  Except for the exit block.  */\n+\t one predecessor, insert there.  Except for the exit block.  */\n       if (single_pred_p (e->dest) && e->dest != EXIT_BLOCK_PTR)\n \t{\n \t  bb = e->dest;\n@@ -1391,7 +1391,7 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \t}\n \n       /* If the source has one successor and the edge is not abnormal,\n-         insert there.  Except for the entry block.  */\n+\t insert there.  Except for the entry block.  */\n       else if ((e->flags & EDGE_ABNORMAL) == 0\n \t       && single_succ_p (e->src)\n \t       && e->src != ENTRY_BLOCK_PTR)\n@@ -1441,8 +1441,8 @@ commit_one_edge_insertion (edge e, int watch_calls)\n \n \t      if (JUMP_P (BB_END (bb))\n \t\t  && !any_condjump_p (BB_END (bb))\n-  \t\t  && (single_succ_edge (bb)->flags & EDGE_CROSSING))\n-\t\tREG_NOTES (BB_END (bb)) = gen_rtx_EXPR_LIST \n+\t\t  && (single_succ_edge (bb)->flags & EDGE_CROSSING))\n+\t\tREG_NOTES (BB_END (bb)) = gen_rtx_EXPR_LIST\n \t\t  (REG_CROSSING_JUMP, NULL_RTX, REG_NOTES (BB_END (bb)));\n \t    }\n \t}\n@@ -1461,9 +1461,9 @@ commit_one_edge_insertion (edge e, int watch_calls)\n   if (returnjump_p (last))\n     {\n       /* ??? Remove all outgoing edges from BB and add one for EXIT.\n-         This is not currently a problem because this only happens\n-         for the (single) epilogue, which already has a fallthru edge\n-         to EXIT.  */\n+\t This is not currently a problem because this only happens\n+\t for the (single) epilogue, which already has a fallthru edge\n+\t to EXIT.  */\n \n       e = single_succ_edge (bb);\n       gcc_assert (e->dest == EXIT_BLOCK_PTR\n@@ -1516,7 +1516,7 @@ commit_edge_insertions (void)\n   FOR_EACH_BB (bb)\n     if (bb->aux)\n       {\n-        SET_BIT (blocks, bb->index);\n+\tSET_BIT (blocks, bb->index);\n \t/* Check for forgotten bb->aux values before commit_edge_insertions\n \t   call.  */\n \tgcc_assert (bb->aux == &bb->aux);\n@@ -1561,7 +1561,7 @@ commit_edge_insertions_watch_calls (void)\n   FOR_EACH_BB (bb)\n     if (bb->aux)\n       {\n-        SET_BIT (blocks, bb->index);\n+\tSET_BIT (blocks, bb->index);\n \t/* Check for forgotten bb->aux values before commit_edge_insertions\n \t   call.  */\n \tgcc_assert (bb->aux == &bb->aux);\n@@ -1806,7 +1806,7 @@ rtl_verify_flow_info_1 (void)\n \t\t  || (BB_PARTITION (e->src) != BB_PARTITION (e->dest)\n \t\t      && e->src != ENTRY_BLOCK_PTR\n \t\t      && e->dest != EXIT_BLOCK_PTR))\n-\t    { \n+\t    {\n \t\t  error (\"fallthru edge crosses section boundary (bb %i)\",\n \t\t\t e->src->index);\n \t\t  err = 1;\n@@ -1894,7 +1894,7 @@ rtl_verify_flow_info_1 (void)\n \t  }\n \n       /* OK pointers are correct.  Now check the header of basic\n-         block.  It ought to contain optional CODE_LABEL followed\n+\t block.  It ought to contain optional CODE_LABEL followed\n \t by NOTE_BASIC_BLOCK.  */\n       x = BB_HEAD (bb);\n       if (LABEL_P (x))\n@@ -1996,7 +1996,7 @@ rtl_verify_flow_info (void)\n \t}\n       else if (e->src != ENTRY_BLOCK_PTR\n \t       && e->dest != EXIT_BLOCK_PTR)\n-        {\n+\t{\n \t  rtx insn;\n \n \t  if (e->src->next_bb != e->dest)\n@@ -2016,7 +2016,7 @@ rtl_verify_flow_info (void)\n \t\t  fatal_insn (\"wrong insn in the fallthru edge\", insn);\n \t\t  err = 1;\n \t\t}\n-        }\n+\t}\n     }\n \n   num_bb_notes = 0;\n@@ -2371,7 +2371,7 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n \t\t\t\t     BB_END (src)))\n \t{\n \t  edge redirected;\n-\t  \n+\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Fallthru edge unified with branch \"\n \t\t     \"%i->%i redirected to %i\\n\",\n@@ -2380,11 +2380,11 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n \t  redirected = redirect_branch_edge (e, dest);\n \t  gcc_assert (redirected);\n \t  e->flags |= EDGE_FALLTHRU;\n-          e->src->flags |= BB_DIRTY;\n+\t  e->src->flags |= BB_DIRTY;\n \t  return e;\n \t}\n       /* In case we are redirecting fallthru edge to the branch edge\n-         of conditional jump, remove it.  */\n+\t of conditional jump, remove it.  */\n       if (EDGE_COUNT (src->succs) == 2)\n \t{\n \t  /* Find the edge that is different from E.  */\n@@ -2512,9 +2512,9 @@ cfg_layout_can_merge_blocks_p (basic_block a, basic_block b)\n      and cold sections.\n \n      Basic block partitioning may result in some jumps that appear to\n-     be optimizable (or blocks that appear to be mergeable), but which really \n-     must be left untouched (they are required to make it safely across \n-     partition boundaries).  See  the comments at the top of \n+     be optimizable (or blocks that appear to be mergeable), but which really\n+     must be left untouched (they are required to make it safely across\n+     partition boundaries).  See  the comments at the top of\n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n   if (BB_PARTITION (a) != BB_PARTITION (b))\n@@ -2550,7 +2550,7 @@ cfg_layout_merge_blocks (basic_block a, basic_block b)\n       /* This might have been an EH label that no longer has incoming\n \t EH edges.  Update data structures to match.  */\n       maybe_remove_eh_handler (BB_HEAD (b));\n- \n+\n       delete_insn (BB_HEAD (b));\n     }\n \n@@ -2790,14 +2790,14 @@ rtl_flow_call_edges_add (sbitmap blocks)\n \t      rtx split_at_insn = insn;\n \n \t      /* Don't split the block between a call and an insn that should\n-\t         remain in the same block as the call.  */\n+\t\t remain in the same block as the call.  */\n \t      if (CALL_P (insn))\n \t\twhile (split_at_insn != BB_END (bb)\n \t\t       && keep_with_call_p (NEXT_INSN (split_at_insn)))\n \t\t  split_at_insn = NEXT_INSN (split_at_insn);\n \n \t      /* The handling above of the final block before the epilogue\n-\t         should be enough to verify that there is no edge to the exit\n+\t\t should be enough to verify that there is no edge to the exit\n \t\t block in CFG already.  Calling make_edge in such case would\n \t\t cause us to mark that edge as fake and remove it later.  */\n \n@@ -2839,8 +2839,8 @@ rtl_flow_call_edges_add (sbitmap blocks)\n    in trees, and this should be of the same type since it is a hook.  */\n static void\n rtl_lv_add_condition_to_bb (basic_block first_head ,\n-\t\t\t    basic_block second_head ATTRIBUTE_UNUSED, \n-\t\t\t    basic_block cond_bb, void *comp_rtx)  \n+\t\t\t    basic_block second_head ATTRIBUTE_UNUSED,\n+\t\t\t    basic_block cond_bb, void *comp_rtx)\n {\n   rtx label, seq, jump;\n   rtx op0 = XEXP ((rtx)comp_rtx, 0);\n@@ -3015,7 +3015,7 @@ struct cfg_hooks rtl_cfg_hooks = {\n   NULL, /* lv_add_condition_to_bb */\n   NULL, /* lv_adjust_loop_header_phi*/\n   NULL, /* extract_cond_bb_edges */\n-  NULL \t\t/* flush_pending_stmts */\n+  NULL\t\t/* flush_pending_stmts */\n };\n \n /* Implementation of CFG manipulation for cfg layout RTL, where\n@@ -3058,5 +3058,5 @@ struct cfg_hooks cfg_layout_rtl_cfg_hooks = {\n   rtl_lv_add_condition_to_bb, /* lv_add_condition_to_bb */\n   NULL, /* lv_adjust_loop_header_phi*/\n   rtl_extract_cond_bb_edges, /* extract_cond_bb_edges */\n-  NULL \t\t/* flush_pending_stmts */  \n+  NULL\t\t/* flush_pending_stmts */\n };"}, {"sha": "04ff09452cdd2ae53b0faf9dd5833e665c8236df", "filename": "gcc/cgraph.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -20,7 +20,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n 02110-1301, USA.  */\n \n /*  This file contains basic routines manipulating call graph and variable pool\n-  \n+\n The callgraph:\n \n     The call-graph is data structure designed for intra-procedural optimization\n@@ -37,7 +37,7 @@ The callgraph:\n     not change once the declaration is inserted into the call-graph.\n     The call-graph nodes are created lazily using cgraph_node function when\n     called for unknown declaration.\n-    \n+\n     When built, there is one edge for each direct call.  It is possible that\n     the reference will be later optimized out.  The call-graph is built\n     conservatively in order to make conservative data flow analysis possible.\n@@ -65,7 +65,7 @@ The callgraph:\n       Each inlined call gets a unique corresponding clone node of the callee\n       and the data structure is updated while inlining is performed, so\n       the clones are eliminated and their callee edges redirected to the\n-      caller. \n+      caller.\n \n       Each edge has \"inline_failed\" field.  When the field is set to NULL,\n       the call will be inlined.  When it is non-NULL it contains a reason\n@@ -477,26 +477,26 @@ cgraph_remove_node (struct cgraph_node *node)\n \tstruct cgraph_node *n;\n \n \t/* Make the next clone be the master clone */\n-\tfor (n = new_node; n; n = n->next_clone) \n+\tfor (n = new_node; n; n = n->next_clone)\n \t  n->master_clone = new_node;\n-\t\n+\n \t*slot = new_node;\n \tnode->next_clone->prev_clone = NULL;\n       }\n       else\n \t{\n-          htab_clear_slot (cgraph_hash, slot);\n+\t  htab_clear_slot (cgraph_hash, slot);\n \t  kill_body = true;\n \t}\n     }\n   else\n     {\n       node->prev_clone->next_clone = node->next_clone;\n       if (node->next_clone)\n-        node->next_clone->prev_clone = node->prev_clone;\n+\tnode->next_clone->prev_clone = node->prev_clone;\n     }\n \n-  /* While all the clones are removed after being proceeded, the function \n+  /* While all the clones are removed after being proceeded, the function\n      itself is kept in the cgraph even after it is compiled.  Check whether\n      we are done with this body and reclaim it proactively if this is the case.\n      */\n@@ -551,7 +551,7 @@ struct cgraph_local_info *\n cgraph_local_info (tree decl)\n {\n   struct cgraph_node *node;\n-  \n+\n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n   node = cgraph_node (decl);\n   return &node->local;\n@@ -563,7 +563,7 @@ struct cgraph_global_info *\n cgraph_global_info (tree decl)\n {\n   struct cgraph_node *node;\n-  \n+\n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL && cgraph_global_info_ready);\n   node = cgraph_node (decl);\n   return &node->global;\n@@ -575,7 +575,7 @@ struct cgraph_rtl_info *\n cgraph_rtl_info (tree decl)\n {\n   struct cgraph_node *node;\n-  \n+\n   gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n   node = cgraph_node (decl);\n   if (decl != current_function_decl\n@@ -599,7 +599,7 @@ cgraph_varpool_node_name (struct cgraph_varpool_node *node)\n }\n \n /* Names used to print out the availability enum.  */\n-static const char * const availability_names[] = \n+static const char * const availability_names[] =\n   {\"unset\", \"not_available\", \"overwrittable\", \"available\", \"local\"};\n \n /* Dump given cgraph node.  */\n@@ -613,7 +613,7 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \t     cgraph_node_name (node->global.inlined_to),\n \t     node->global.inlined_to->uid);\n   if (cgraph_function_flags_ready)\n-    fprintf (f, \" availability:%s\", \n+    fprintf (f, \" availability:%s\",\n \t     availability_names [cgraph_function_body_availability (node)]);\n   if (node->master_clone && node->master_clone->uid != node->uid)\n     fprintf (f, \"(%i)\", node->master_clone->uid);\n@@ -753,7 +753,7 @@ cgraph_varpool_node (tree decl)\n \n   if (!cgraph_varpool_hash)\n     cgraph_varpool_hash = htab_create_ggc (10, hash_varpool_node,\n-\t\t\t\t           eq_varpool_node, NULL);\n+\t\t\t\t\t   eq_varpool_node, NULL);\n   key.decl = decl;\n   slot = (struct cgraph_varpool_node **)\n     htab_find_slot (cgraph_varpool_hash, &key, INSERT);\n@@ -879,7 +879,7 @@ void\n cgraph_varpool_finalize_decl (tree decl)\n {\n   struct cgraph_varpool_node *node = cgraph_varpool_node (decl);\n- \n+\n   /* The first declaration of a variable that comes through this function\n      decides whether it is global (in C, has external linkage)\n      or local (in C, has internal linkage).  So do nothing more\n@@ -942,8 +942,8 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n   struct cgraph_edge *new;\n \n   new = cgraph_create_edge (n, e->callee, call_stmt,\n-                            e->count * count_scale / REG_BR_PROB_BASE,\n-\t\t            e->loop_nest + loop_nest);\n+\t\t\t    e->count * count_scale / REG_BR_PROB_BASE,\n+\t\t\t    e->loop_nest + loop_nest);\n \n   new->inline_failed = e->inline_failed;\n   if (update_original)\n@@ -956,7 +956,7 @@ cgraph_clone_edge (struct cgraph_edge *e, struct cgraph_node *n,\n }\n \n /* Create node representing clone of N executed COUNT times.  Decrease\n-   the execution counts from original node too. \n+   the execution counts from original node too.\n \n    When UPDATE_ORIGINAL is true, the counts are subtracted from the original\n    function's profile to reflect the fact that part of execution is handled\n@@ -1018,13 +1018,13 @@ struct cgraph_node *\n cgraph_master_clone (struct cgraph_node *n)\n {\n   enum availability avail = cgraph_function_body_availability (n);\n-   \n+\n   if (avail == AVAIL_NOT_AVAILABLE || avail == AVAIL_OVERWRITABLE)\n     return NULL;\n \n-  if (!n->master_clone) \n+  if (!n->master_clone)\n     n->master_clone = cgraph_node (n->decl);\n-  \n+\n   return n->master_clone;\n }\n \n@@ -1069,7 +1069,7 @@ cgraph_function_body_availability (struct cgraph_node *node)\n      document the requirement of both versions of function (extern\n      inline and offline) having same side effect characteristics as\n      good optimization is what this optimization is about.  */\n-  \n+\n   else if (!(*targetm.binds_local_p) (node->decl)\n \t   && !DECL_COMDAT (node->decl) && !DECL_EXTERNAL (node->decl))\n     avail = AVAIL_OVERWRITABLE;"}, {"sha": "e761fbc27f2c3570c402b169f5e64e786ddf74ef", "filename": "gcc/cgraph.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -133,13 +133,13 @@ struct cgraph_node GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\")))\n   /* Pointer to a single unique cgraph node for this function.  If the\n      function is to be output, this is the copy that will survive.  */\n   struct cgraph_node *master_clone;\n- \n+\n   PTR GTY ((skip)) aux;\n \n   struct cgraph_local_info local;\n   struct cgraph_global_info global;\n   struct cgraph_rtl_info rtl;\n-  \n+\n   /* Expected number of executions: calculated in profile.c.  */\n   gcov_type count;\n   /* Unique id of the node.  */\n@@ -262,7 +262,7 @@ void cgraph_remove_node (struct cgraph_node *);\n void cgraph_node_remove_callees (struct cgraph_node *node);\n struct cgraph_edge *cgraph_create_edge (struct cgraph_node *,\n \t\t\t\t\tstruct cgraph_node *,\n-\t\t\t\t        tree, gcov_type, int);\n+\t\t\t\t\ttree, gcov_type, int);\n struct cgraph_node *cgraph_node (tree);\n struct cgraph_node *cgraph_node_for_asm (tree asmname);\n struct cgraph_edge *cgraph_edge (struct cgraph_node *, tree);\n@@ -271,8 +271,8 @@ struct cgraph_global_info *cgraph_global_info (tree);\n struct cgraph_rtl_info *cgraph_rtl_info (tree);\n const char * cgraph_node_name (struct cgraph_node *);\n struct cgraph_edge * cgraph_clone_edge (struct cgraph_edge *,\n-\t\t\t\t        struct cgraph_node *,\n-\t\t\t\t        tree, gcov_type, int, bool);\n+\t\t\t\t\tstruct cgraph_node *,\n+\t\t\t\t\ttree, gcov_type, int, bool);\n struct cgraph_node * cgraph_clone_node (struct cgraph_node *, gcov_type,\n \t\t\t\t\tint, bool);\n \n@@ -312,7 +312,7 @@ void cgraph_build_static_cdtor (char which, tree body, int priority);\n void cgraph_reset_static_var_maps (void);\n void init_cgraph (void);\n struct cgraph_node *cgraph_function_versioning (struct cgraph_node *,\n-                                                VEC(cgraph_edge_p,heap)*,\n+\t\t\t\t\t\tVEC(cgraph_edge_p,heap)*,\n \t\t\t\t\t\tvarray_type);\n void cgraph_analyze_function (struct cgraph_node *);\n struct cgraph_node *save_inline_function_body (struct cgraph_node *);"}, {"sha": "5ff4fffa85449a6f70e26dead4af884fc1fb999e", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -216,7 +216,7 @@ decide_is_function_needed (struct cgraph_node *node, tree decl)\n     return true;\n \n   /* Externally visible functions must be output.  The exception is\n-     COMDAT functions that must be output only when they are needed. \n+     COMDAT functions that must be output only when they are needed.\n \n      When not optimizing, also output the static functions. (see\n      PR25962), but don't do so for always_inline functions.\n@@ -254,7 +254,7 @@ decide_is_function_needed (struct cgraph_node *node, tree decl)\n       || (!node->local.disregard_inline_limits\n \t  /* When declared inline, defer even the uninlinable functions.\n \t     This allows them to be eliminated when unused.  */\n-\t  && !DECL_DECLARED_INLINE_P (decl) \n+\t  && !DECL_DECLARED_INLINE_P (decl)\n \t  && (!node->local.inlinable || !cgraph_default_inline_p (node, NULL))))\n     return true;\n \n@@ -280,7 +280,7 @@ cgraph_varpool_analyze_pending_decls (void)\n       if (DECL_INITIAL (decl))\n \t{\n \t  visited_nodes = pointer_set_create ();\n-          walk_tree (&DECL_INITIAL (decl), record_reference, NULL, visited_nodes);\n+\t  walk_tree (&DECL_INITIAL (decl), record_reference, NULL, visited_nodes);\n \t  pointer_set_destroy (visited_nodes);\n \t  visited_nodes = NULL;\n \t}\n@@ -318,7 +318,7 @@ cgraph_varpool_remove_unreferenced_decls (void)\n \t       && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n \t      || node->force_output\n \t      || decide_is_variable_needed (node, decl)\n-\t      /* ??? Cgraph does not yet rule the world with an iron hand, \n+\t      /* ??? Cgraph does not yet rule the world with an iron hand,\n \t\t and does not control the emission of debug information.\n \t\t After a variable has its DECL_RTL set, we must assume that\n \t\t it may be referenced by the debug information, and we can\n@@ -394,7 +394,7 @@ cgraph_reset_node (struct cgraph_node *node)\n   /* If node->output is set, then this is a unit-at-a-time compilation\n      and we have already begun whole-unit analysis.  This is *not*\n      testing for whether we've already emitted the function.  That\n-     case can be sort-of legitimately seen with real function \n+     case can be sort-of legitimately seen with real function\n      redefinition errors.  I would argue that the front end should\n      never present us with such a case, but don't enforce that for now.  */\n   gcc_assert (!node->output);\n@@ -512,7 +512,7 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n \t{\n \t  cgraph_varpool_mark_needed_node (cgraph_varpool_node (t));\n \t  if (lang_hooks.callgraph.analyze_expr)\n-\t    return lang_hooks.callgraph.analyze_expr (tp, walk_subtrees, \n+\t    return lang_hooks.callgraph.analyze_expr (tp, walk_subtrees,\n \t\t\t\t\t\t      data);\n \t}\n       break;\n@@ -558,7 +558,7 @@ cgraph_create_edges (struct cgraph_node *node, tree body)\n   tree step;\n   visited_nodes = pointer_set_create ();\n \n-  /* Reach the trees by walking over the CFG, and note the \n+  /* Reach the trees by walking over the CFG, and note the\n      enclosing basic-blocks in the call edges.  */\n   FOR_EACH_BB_FN (bb, this_cfun)\n     for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n@@ -578,7 +578,7 @@ cgraph_create_edges (struct cgraph_node *node, tree body)\n \t      walk_tree (&TREE_OPERAND (stmt, 0),\n \t\t\t record_reference, node, visited_nodes);\n \t  }\n-\telse \n+\telse\n \t  walk_tree (bsi_stmt_ptr (bsi), record_reference, node, visited_nodes);\n       }\n \n@@ -595,7 +595,7 @@ cgraph_create_edges (struct cgraph_node *node, tree body)\n       else if (TREE_CODE (decl) == VAR_DECL && DECL_INITIAL (decl))\n \twalk_tree (&DECL_INITIAL (decl), record_reference, node, visited_nodes);\n     }\n-    \n+\n   pointer_set_destroy (visited_nodes);\n   visited_nodes = NULL;\n }\n@@ -742,7 +742,7 @@ verify_cgraph_node (struct cgraph_node *node)\n       error (\"node not found in cgraph_hash\");\n       error_found = true;\n     }\n-  \n+\n   if (node->analyzed\n       && DECL_SAVED_TREE (node->decl) && !TREE_ASM_WRITTEN (node->decl)\n       && (!DECL_EXTERNAL (node->decl) || node->global.inlined_to))\n@@ -844,7 +844,7 @@ cgraph_varpool_assemble_decl (struct cgraph_varpool_node *node)\n       assemble_variable (decl, 0, 1, 0);\n       /* Local static variables are never seen by check_global_declarations\n \t so we need to output debug info by hand.  */\n-      if (DECL_CONTEXT (decl) \n+      if (DECL_CONTEXT (decl)\n \t  && (TREE_CODE (DECL_CONTEXT (decl)) == BLOCK\n \t      || TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)\n \t  && errorcount == 0 && sorrycount == 0)\n@@ -867,7 +867,7 @@ cgraph_varpool_assemble_pending_decls (void)\n \n   if (errorcount || sorrycount)\n     return false;\n- \n+\n   /* EH might mark decls as needed during expansion.  This should be safe since\n      we don't create references to new function, but it should not be used\n      elsewhere.  */\n@@ -1019,7 +1019,7 @@ cgraph_finalize_compilation_unit (void)\n       tree decl = node->decl;\n \n       if (node->local.finalized && !DECL_SAVED_TREE (decl))\n-        cgraph_reset_node (node);\n+\tcgraph_reset_node (node);\n \n       if (!node->reachable && DECL_SAVED_TREE (decl))\n \t{\n@@ -1053,7 +1053,7 @@ cgraph_mark_functions_to_output (void)\n     {\n       tree decl = node->decl;\n       struct cgraph_edge *e;\n-      \n+\n       gcc_assert (!node->output);\n \n       for (e = node->callers; e; e = e->next_caller)\n@@ -1085,7 +1085,7 @@ cgraph_mark_functions_to_output (void)\n \t\t      || DECL_EXTERNAL (decl));\n \n \t}\n-      \n+\n     }\n }\n \n@@ -1283,7 +1283,7 @@ cgraph_output_in_order (void)\n }\n \n /* Mark visibility of all functions.\n-   \n+\n    A local function is one whose calls can occur only in the current\n    compilation unit and all its calls are explicit, so we can change\n    its calling convention.  We simply mark all static functions whose\n@@ -1395,7 +1395,7 @@ cgraph_optimize (void)\n     }\n \n   process_pending_assemble_externals ();\n-  \n+\n   /* Frontend may output common variables after the unit has been finalized.\n      It is safe to deal with them here as they are always zero initialized.  */\n   cgraph_varpool_analyze_pending_decls ();\n@@ -1463,19 +1463,19 @@ cgraph_optimize (void)\n       for (node = cgraph_nodes; node; node = node->next)\n \tif (node->analyzed\n \t    && (node->global.inlined_to\n-\t        || DECL_SAVED_TREE (node->decl)))\n+\t\t|| DECL_SAVED_TREE (node->decl)))\n \t  {\n \t    error_found = true;\n \t    dump_cgraph_node (stderr, node);\n- \t  }\n+\t  }\n       if (error_found)\n \tinternal_error (\"nodes with no released memory found\");\n     }\n #endif\n }\n \n /* Generate and emit a static constructor or destructor.  WHICH must be\n-   one of 'I' or 'D'.  BODY should be a STATEMENT_LIST containing \n+   one of 'I' or 'D'.  BODY should be a STATEMENT_LIST containing\n    GENERIC statements.  */\n \n void\n@@ -1536,7 +1536,7 @@ cgraph_build_static_cdtor (char which, tree body, int priority)\n     }\n   else\n     cgraph_finalize_function (decl, 0);\n-  \n+\n   if (targetm.have_ctors_dtors)\n     {\n       void (*fn) (rtx, int);\n@@ -1555,7 +1555,7 @@ init_cgraph (void)\n   cgraph_dump_file = dump_begin (TDI_cgraph, NULL);\n }\n \n-/* The edges representing the callers of the NEW_VERSION node were \n+/* The edges representing the callers of the NEW_VERSION node were\n    fixed by cgraph_function_versioning (), now the call_expr in their\n    respective tree code should be updated to call the NEW_VERSION.  */\n \n@@ -1590,7 +1590,7 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n    unsigned i;\n \n    gcc_assert (old_version);\n-   \n+\n    new_version = cgraph_node (new_decl);\n \n    new_version->analyzed = true;\n@@ -1617,7 +1617,7 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n        next_callee = e->next_callee;\n        if (e->callee == old_version)\n \t cgraph_redirect_edge_callee (e, new_version);\n-         \n+\n        if (!next_callee)\n \t break;\n      }\n@@ -1632,7 +1632,7 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n  }\n \n  /* Perform function versioning.\n-    Function versioning includes copying of the tree and \n+    Function versioning includes copying of the tree and\n     a callgraph update (creating a new cgraph node and updating\n     its callees and callers).\n \n@@ -1671,9 +1671,9 @@ cgraph_function_versioning (struct cgraph_node *old_version_node,\n   /* Update the call_expr on the edges to call the new version node. */\n   update_call_expr (new_version_node);\n \n-  /* Update the new version's properties.  \n+  /* Update the new version's properties.\n      Make The new version visible only within this translation unit.\n-     ??? We cannot use COMDAT linkage because there is no \n+     ??? We cannot use COMDAT linkage because there is no\n      ABI support for this.  */\n   DECL_EXTERNAL (new_version_node->decl) = 0;\n   DECL_ONE_ONLY (new_version_node->decl) = 0;"}, {"sha": "02edde835d5a9b8d8fd14a7584ade51be1852d5c", "filename": "gcc/collect2.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -161,7 +161,7 @@ struct head\n enum pass {\n   PASS_FIRST,\t\t\t\t/* without constructors */\n   PASS_OBJ,\t\t\t\t/* individual objects */\n-  PASS_LIB,\t\t\t        /* looking for shared libraries */\n+  PASS_LIB,\t\t\t\t/* looking for shared libraries */\n   PASS_SECOND\t\t\t\t/* with constructors linked in */\n };\n \n@@ -177,12 +177,12 @@ static int aixrtl_flag;\t\t\t/* true if -brtl */\n \n int debug;\t\t\t\t/* true if -debug */\n \n-static int shared_obj;\t\t        /* true if -shared */\n+static int shared_obj;\t\t\t/* true if -shared */\n \n static const char *c_file;\t\t/* <xxx>.c for constructor/destructor list.  */\n static const char *o_file;\t\t/* <xxx>.o for constructor/destructor list.  */\n #ifdef COLLECT_EXPORT_LIST\n-static const char *export_file;\t        /* <xxx>.x for AIX export list.  */\n+static const char *export_file;\t\t/* <xxx>.x for AIX export list.  */\n #endif\n const char *ldout;\t\t\t/* File for ld stdout.  */\n const char *lderrout;\t\t\t/* File for ld stderr.  */\n@@ -192,7 +192,7 @@ static const char *nm_file_name;\t/* pathname of nm */\n static const char *ldd_file_name;\t/* pathname of ldd (or equivalent) */\n #endif\n static const char *strip_file_name;\t\t/* pathname of strip */\n-const char *c_file_name;\t        /* pathname of gcc */\n+const char *c_file_name;\t\t/* pathname of gcc */\n static char *initname, *fininame;\t/* names of init and fini funcs */\n \n static struct head constructors;\t/* list of constructors found */\n@@ -1062,7 +1062,7 @@ main (int argc, char **argv)\n \t       explicitly puts an export list in command line */\n \t    case 'b':\n \t      if (arg[2] == 'E' || strncmp (&arg[2], \"export\", 6) == 0)\n-                export_flag = 1;\n+\t\texport_flag = 1;\n \t      else if (arg[2] == '6' && arg[3] == '4')\n \t\taix64_flag = 1;\n \t      else if (arg[2] == 'r' && arg[3] == 't' && arg[4] == 'l')\n@@ -1078,7 +1078,7 @@ main (int argc, char **argv)\n \t\t  ld2--;\n \t\t}\n \t      if (!strcmp (arg, \"-dynamic-linker\") && argv[1])\n-\t        {\n+\t\t{\n \t\t  ++argv;\n \t\t  *ld1++ = *ld2++ = *argv;\n \t\t}\n@@ -1095,7 +1095,7 @@ main (int argc, char **argv)\n \t\t}\n #ifdef COLLECT_EXPORT_LIST\n \t      {\n-\t        /* Resolving full library name.  */\n+\t\t/* Resolving full library name.  */\n \t\tconst char *s = resolve_lib_name (arg+2);\n \n \t\t/* Saving a full library name.  */\n@@ -1205,8 +1205,8 @@ main (int argc, char **argv)\n \t  else\n \t    {\n \t      /* Saving a full library name.  */\n-              add_to_list (&libs, arg);\n-            }\n+\t      add_to_list (&libs, arg);\n+\t    }\n #endif\n \t}\n     }\n@@ -1670,7 +1670,7 @@ sort_ids (struct head *head_ptr)\n \t    || id->sequence > (*id_ptr)->sequence\n \t    /* Hack: do lexical compare, too.\n \t    || (id->sequence == (*id_ptr)->sequence\n-\t        && strcmp (id->name, (*id_ptr)->name) > 0) */\n+\t\t&& strcmp (id->name, (*id_ptr)->name) > 0) */\n \t    )\n \t  {\n \t    id->next = *id_ptr;\n@@ -2246,7 +2246,7 @@ scan_libraries (const char *prog_name)\n       *end = '\\0';\n \n       if (access (name, R_OK) == 0)\n-        add_to_list (&libraries, name);\n+\tadd_to_list (&libraries, name);\n       else\n \tfatal (\"unable to open dynamic dependency '%s'\", buf);\n \n@@ -2296,20 +2296,20 @@ scan_libraries (const char *prog_name)\n #   if defined (C_WEAKEXT)\n #     define GCC_OK_SYMBOL(X) \\\n        (((X).n_sclass == C_EXT || (X).n_sclass == C_WEAKEXT) && \\\n-        ((X).n_scnum > N_UNDEF) && \\\n-        (aix64_flag \\\n-         || (((X).n_type & N_TMASK) == (DT_NON << N_BTSHFT) \\\n-             || ((X).n_type & N_TMASK) == (DT_FCN << N_BTSHFT))))\n+\t((X).n_scnum > N_UNDEF) && \\\n+\t(aix64_flag \\\n+\t || (((X).n_type & N_TMASK) == (DT_NON << N_BTSHFT) \\\n+\t     || ((X).n_type & N_TMASK) == (DT_FCN << N_BTSHFT))))\n #     define GCC_UNDEF_SYMBOL(X) \\\n        (((X).n_sclass == C_EXT || (X).n_sclass == C_WEAKEXT) && \\\n-        ((X).n_scnum == N_UNDEF))\n+\t((X).n_scnum == N_UNDEF))\n #   else\n #     define GCC_OK_SYMBOL(X) \\\n        (((X).n_sclass == C_EXT) && \\\n-        ((X).n_scnum > N_UNDEF) && \\\n-        (aix64_flag \\\n-         || (((X).n_type & N_TMASK) == (DT_NON << N_BTSHFT) \\\n-             || ((X).n_type & N_TMASK) == (DT_FCN << N_BTSHFT))))\n+\t((X).n_scnum > N_UNDEF) && \\\n+\t(aix64_flag \\\n+\t || (((X).n_type & N_TMASK) == (DT_NON << N_BTSHFT) \\\n+\t     || ((X).n_type & N_TMASK) == (DT_FCN << N_BTSHFT))))\n #     define GCC_UNDEF_SYMBOL(X) \\\n        (((X).n_sclass == C_EXT) && ((X).n_scnum == N_UNDEF))\n #   endif\n@@ -2398,9 +2398,9 @@ scan_prog_file (const char *prog_name, enum pass which_pass)\n     {\n #endif\n       /* Some platforms (e.g. OSF4) declare ldopen as taking a\n-         non-const char * filename parameter, even though it will not\n-         modify that string.  So we must cast away const-ness here,\n-         which will cause -Wcast-qual to burp.  */\n+\t non-const char * filename parameter, even though it will not\n+\t modify that string.  So we must cast away const-ness here,\n+\t which will cause -Wcast-qual to burp.  */\n       if ((ldptr = ldopen ((char *)prog_name, ldptr)) != NULL)\n \t{\n \t  if (! MY_ISCOFF (HEADER (ldptr).f_magic))"}, {"sha": "255672ea1ab673ab82ab27bd2b83adfb1bee262f", "filename": "gcc/combine.c", "status": "modified", "additions": 80, "deletions": 81, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -161,7 +161,7 @@ struct reg_stat {\n \n      (1) We do not want to reinitialize at each label.\n      (2) It is useful, but not critical, to know the actual value assigned\n-         to a register.  Often just its form is helpful.\n+\t to a register.  Often just its form is helpful.\n \n      Therefore, we maintain the following fields:\n \n@@ -249,7 +249,7 @@ struct reg_stat {\n      truncation if we know that value already contains a truncated\n      value.  */\n \n-  ENUM_BITFIELD(machine_mode)\ttruncated_to_mode : 8; \n+  ENUM_BITFIELD(machine_mode)\ttruncated_to_mode : 8;\n };\n \n static struct reg_stat *reg_stat;\n@@ -791,7 +791,7 @@ combine_instructions (rtx f, unsigned int nregs)\n   FOR_EACH_BB (this_basic_block)\n     {\n       for (insn = BB_HEAD (this_basic_block);\n-           insn != NEXT_INSN (BB_END (this_basic_block));\n+\t   insn != NEXT_INSN (BB_END (this_basic_block));\n \t   insn = next ? next : NEXT_INSN (insn))\n \t{\n \t  next = 0;\n@@ -1040,7 +1040,7 @@ set_nonzero_bits_and_sign_copies (rtx x, rtx set,\n       /* If this register is undefined at the start of the file, we can't\n \t say what its contents were.  */\n       && ! REGNO_REG_SET_P\n-         (ENTRY_BLOCK_PTR->next_bb->il.rtl->global_live_at_start, REGNO (x))\n+\t (ENTRY_BLOCK_PTR->next_bb->il.rtl->global_live_at_start, REGNO (x))\n       && GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT)\n     {\n       if (set == 0 || GET_CODE (set) == CLOBBER)\n@@ -1327,7 +1327,7 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n     for (i = XVECLEN (PATTERN (i3), 0) - 1; i >= 0; i--)\n       if (GET_CODE (XVECEXP (PATTERN (i3), 0, i)) == CLOBBER)\n \t{\n-          /* Don't substitute for a register intended as a clobberable\n+\t  /* Don't substitute for a register intended as a clobberable\n \t     operand.  */\n \t  rtx reg = XEXP (XVECEXP (PATTERN (i3), 0, i), 0);\n \t  if (rtx_equal_p (reg, dest))\n@@ -1354,10 +1354,10 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n     {\n       /* Make sure succ doesn't contain a volatile reference.  */\n       if (succ != 0 && volatile_refs_p (PATTERN (succ)))\n-        return 0;\n+\treturn 0;\n \n       for (p = NEXT_INSN (insn); p != i3; p = NEXT_INSN (p))\n-        if (INSN_P (p) && p != succ && volatile_refs_p (PATTERN (p)))\n+\tif (INSN_P (p) && p != succ && volatile_refs_p (PATTERN (p)))\n \t  return 0;\n     }\n \n@@ -1428,12 +1428,12 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n \n    Consider:\n \n-         (set (reg:DI 101) (reg:DI 100))\n+\t (set (reg:DI 101) (reg:DI 100))\n \t (set (subreg:SI (reg:DI 101) 0) <foo>)\n \n    This is NOT equivalent to:\n \n-         (parallel [(set (subreg:SI (reg:DI 100) 0) <foo>)\n+\t (parallel [(set (subreg:SI (reg:DI 100) 0) <foo>)\n \t\t    (set (reg:DI 101) (reg:DI 100))])\n \n    Not only does this modify 100 (in which case it might still be valid\n@@ -2073,7 +2073,7 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n      make up a dummy I1 that is\n \t(set Y OP)\n      and change I2 to be\n-        (set (reg:CC X) (compare:CC Y (const_int 0)))\n+\t(set (reg:CC X) (compare:CC Y (const_int 0)))\n \n      (We can ignore any trailing CLOBBERs.)\n \n@@ -3013,12 +3013,12 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n       rtx ni2dest;\n \n       /* I3 now uses what used to be its destination and which is now\n-         I2's destination.  This requires us to do a few adjustments.  */\n+\t I2's destination.  This requires us to do a few adjustments.  */\n       PATTERN (i3) = newpat;\n       adjust_for_new_dest (i3);\n \n       /* We need a LOG_LINK from I3 to I2.  But we used to have one,\n-         so we still will.\n+\t so we still will.\n \n \t However, some later insn might be using I2's dest and have\n \t a LOG_LINK pointing at I3.  We must remove this link.\n@@ -3431,7 +3431,6 @@ undo_commit (void)\n     }\n   undobuf.undos = 0;\n }\n-\n \f\n /* Find the innermost point within the rtx at LOC, possibly LOC itself,\n    where we have an arithmetic expression and return that point.  LOC will\n@@ -3604,7 +3603,7 @@ find_split_point (rtx *loc, rtx insn)\n \t      rtx negmask = gen_int_mode (~(mask << pos), mode);\n \t      SUBST (SET_SRC (x),\n \t\t     simplify_gen_binary (IOR, mode,\n-\t\t\t\t          simplify_gen_binary (AND, mode,\n+\t\t\t\t\t  simplify_gen_binary (AND, mode,\n \t\t\t\t\t\t\t       dest, negmask),\n \t\t\t\t\t  or_mask));\n \t    }\n@@ -4157,7 +4156,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t       && ! (GET_CODE (XEXP (x, 1)) == SUBREG\n \t\t     && OBJECT_P (SUBREG_REG (XEXP (x, 1)))))))\n       || (UNARY_P (x)\n-          && (!OBJECT_P (XEXP (x, 0))\n+\t  && (!OBJECT_P (XEXP (x, 0))\n \t       && ! (GET_CODE (XEXP (x, 0)) == SUBREG\n \t\t     && OBJECT_P (SUBREG_REG (XEXP (x, 0)))))))\n     {\n@@ -4201,7 +4200,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t      else if (true_rtx == const0_rtx && false_rtx == const_true_rtx\n \t\t       && ((reversed = reversed_comparison_code_parts\n \t\t\t\t\t(cond_code, cond, cop1, NULL))\n-\t\t           != UNKNOWN))\n+\t\t\t   != UNKNOWN))\n \t\tx = simplify_gen_relational (reversed, mode, VOIDmode,\n \t\t\t\t\t     cond, cop1);\n \n@@ -4220,7 +4219,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \t\t       && true_rtx == const0_rtx\n \t\t       && ((reversed = reversed_comparison_code_parts\n \t\t\t\t\t(cond_code, cond, cop1, NULL))\n-\t\t           != UNKNOWN))\n+\t\t\t   != UNKNOWN))\n \t\tx = simplify_gen_unary (NEG, mode,\n \t\t\t\t\tsimplify_gen_relational (reversed,\n \t\t\t\t\t\t\t\t mode, VOIDmode,\n@@ -4364,7 +4363,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest)\n \treturn gen_lowpart (mode, SUBREG_REG (x));\n \n       if (GET_MODE_CLASS (GET_MODE (SUBREG_REG (x))) == MODE_CC)\n-        break;\n+\tbreak;\n       {\n \trtx temp;\n \ttemp = simplify_subreg (mode, SUBREG_REG (x), op0_mode,\n@@ -5186,13 +5185,13 @@ simplify_set (rtx x)\n       tmp = simplify_relational_operation (old_code, compare_mode, VOIDmode,\n \t\t\t\t\t   op0, op1);\n       if (!tmp)\n-        new_code = old_code;\n+\tnew_code = old_code;\n       else if (!CONSTANT_P (tmp))\n-        {\n-          new_code = GET_CODE (tmp);\n-          op0 = XEXP (tmp, 0);\n-          op1 = XEXP (tmp, 1);\n-        }\n+\t{\n+\t  new_code = GET_CODE (tmp);\n+\t  op0 = XEXP (tmp, 0);\n+\t  op1 = XEXP (tmp, 1);\n+\t}\n       else\n \t{\n \t  rtx pat = PATTERN (other_insn);\n@@ -5317,7 +5316,7 @@ simplify_set (rtx x)\n \t{\n \t  SUBST(SET_SRC (x), op0);\n \t  src = SET_SRC (x);\n-        }\n+\t}\n       else\n \t{\n \t  /* Otherwise, update the COMPARE if needed.  */\n@@ -5353,7 +5352,7 @@ simplify_set (rtx x)\n \t       + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD))\n #ifndef WORD_REGISTER_OPERATIONS\n       && (GET_MODE_SIZE (GET_MODE (src))\n-        < GET_MODE_SIZE (GET_MODE (SUBREG_REG (src))))\n+\t< GET_MODE_SIZE (GET_MODE (SUBREG_REG (src))))\n #endif\n #ifdef CANNOT_CHANGE_MODE_CLASS\n       && ! (REG_P (dest) && REGNO (dest) < FIRST_PSEUDO_REGISTER\n@@ -5682,8 +5681,8 @@ expand_compound_operation (rtx x)\n   if (GET_CODE (x) == ZERO_EXTEND)\n     {\n       /* (zero_extend:DI (truncate:SI foo:DI)) is just foo:DI if we\n-         know that the last value didn't have any inappropriate bits\n-         set.  */\n+\t know that the last value didn't have any inappropriate bits\n+\t set.  */\n       if (GET_CODE (XEXP (x, 0)) == TRUNCATE\n \t  && GET_MODE (XEXP (XEXP (x, 0), 0)) == GET_MODE (x)\n \t  && GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT\n@@ -5701,9 +5700,9 @@ expand_compound_operation (rtx x)\n \treturn SUBREG_REG (XEXP (x, 0));\n \n       /* (zero_extend:DI (truncate:SI foo:DI)) is just foo:DI when foo\n-         is a comparison and STORE_FLAG_VALUE permits.  This is like\n-         the first case, but it works even when GET_MODE (x) is larger\n-         than HOST_WIDE_INT.  */\n+\t is a comparison and STORE_FLAG_VALUE permits.  This is like\n+\t the first case, but it works even when GET_MODE (x) is larger\n+\t than HOST_WIDE_INT.  */\n       if (GET_CODE (XEXP (x, 0)) == TRUNCATE\n \t  && GET_MODE (XEXP (XEXP (x, 0), 0)) == GET_MODE (x)\n \t  && COMPARISON_P (XEXP (XEXP (x, 0), 0))\n@@ -6168,7 +6167,7 @@ make_extraction (enum machine_mode mode, rtx inner, HOST_WIDE_INT pos,\n   else\n     {\n       /* Be careful not to go beyond the extracted object and maintain the\n-\t natural alignment of the memory.  */ \n+\t natural alignment of the memory.  */\n       wanted_inner_mode = smallest_mode_for_size (len, MODE_INT);\n       while (pos % GET_MODE_BITSIZE (wanted_inner_mode) + len\n \t     > GET_MODE_BITSIZE (wanted_inner_mode))\n@@ -6599,12 +6598,12 @@ make_compound_operation (rtx x, enum rtx_code in_code)\n \t  {\n \t    rtx newer = force_to_mode (tem, mode, ~(HOST_WIDE_INT) 0,\n \t\t\t\t       0);\n-\t    \n+\n \t    /* If we have something other than a SUBREG, we might have\n \t       done an expansion, so rerun ourselves.  */\n \t    if (GET_CODE (newer) != SUBREG)\n \t      newer = make_compound_operation (newer, in_code);\n-\t    \n+\n \t    return newer;\n \t  }\n \n@@ -6733,9 +6732,9 @@ canon_reg_for_combine (rtx x, rtx reg)\n       fmt = GET_RTX_FORMAT (code);\n       copied = false;\n       for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-        if (fmt[i] == 'e')\n-          {\n-            rtx op = canon_reg_for_combine (XEXP (x, i), reg);\n+\tif (fmt[i] == 'e')\n+\t  {\n+\t    rtx op = canon_reg_for_combine (XEXP (x, i), reg);\n \t    if (op != XEXP (x, i))\n \t      {\n \t\tif (!copied)\n@@ -6744,23 +6743,23 @@ canon_reg_for_combine (rtx x, rtx reg)\n \t\t    x = copy_rtx (x);\n \t\t  }\n \t\tXEXP (x, i) = op;\n-              }\n-          }\n-        else if (fmt[i] == 'E')\n-          {\n-            int j;\n-            for (j = 0; j < XVECLEN (x, i); j++)\n+\t      }\n+\t  }\n+\telse if (fmt[i] == 'E')\n+\t  {\n+\t    int j;\n+\t    for (j = 0; j < XVECLEN (x, i); j++)\n \t      {\n-\t        rtx op = canon_reg_for_combine (XVECEXP (x, i, j), reg);\n-\t        if (op != XVECEXP (x, i, j))\n+\t\trtx op = canon_reg_for_combine (XVECEXP (x, i, j), reg);\n+\t\tif (op != XVECEXP (x, i, j))\n \t\t  {\n \t\t    if (!copied)\n \t\t      {\n \t\t\tcopied = true;\n \t\t\tx = copy_rtx (x);\n \t\t      }\n \t\t    XVECEXP (x, i, j) = op;\n-\t          }\n+\t\t  }\n \t      }\n \t  }\n \n@@ -6856,7 +6855,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n   if (GET_CODE (x) == CONST_INT)\n     {\n       if (SCALAR_INT_MODE_P (mode))\n-        return gen_int_mode (INTVAL (x) & mask, mode);\n+\treturn gen_int_mode (INTVAL (x) & mask, mode);\n       else\n \t{\n \t  x = GEN_INT (INTVAL (x) & mask);\n@@ -7391,7 +7390,7 @@ if_then_else_cond (rtx x, rtx *ptrue, rtx *pfalse)\n \t      *ptrue = simplify_gen_relational (code, mode, VOIDmode,\n \t\t\t\t\t\ttrue0, true1);\n \t      *pfalse = simplify_gen_relational (code, mode, VOIDmode,\n-\t\t\t\t\t         false0, false1);\n+\t\t\t\t\t\t false0, false1);\n \t     }\n \t  else\n \t    {\n@@ -7668,7 +7667,7 @@ known_cond (rtx x, enum rtx_code cond, rtx reg, rtx val)\n       if (XEXP (x, 0) != r)\n \t{\n \t  /* We must simplify the zero_extend here, before we lose\n-             track of the original inner_mode.  */\n+\t     track of the original inner_mode.  */\n \t  new = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),\n \t\t\t\t\t  r, inner_mode);\n \t  if (new)\n@@ -8033,7 +8032,7 @@ apply_distributive_law (rtx x)\n    expanding a bit field assignment.  When we apply the distributive\n    law to this, we get (ior (and (A (not B))) (and (B (not B)))),\n    which then simplifies to (and (A (not B))).\n- \n+\n    Note that no checks happen on the validity of applying the inverse\n    distributive law.  This is pointless since we can do it in the\n    few places where this routine is called.\n@@ -8247,13 +8246,13 @@ reg_nonzero_bits_for_combine (rtx x, enum machine_mode mode,\n \n   if (reg_stat[REGNO (x)].last_set_value != 0\n       && (reg_stat[REGNO (x)].last_set_mode == mode\n-          || (GET_MODE_CLASS (reg_stat[REGNO (x)].last_set_mode) == MODE_INT\n+\t  || (GET_MODE_CLASS (reg_stat[REGNO (x)].last_set_mode) == MODE_INT\n \t      && GET_MODE_CLASS (mode) == MODE_INT))\n       && (reg_stat[REGNO (x)].last_set_label == label_tick\n \t  || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t      && REG_N_SETS (REGNO (x)) == 1\n \t      && ! REGNO_REG_SET_P\n-\t         (ENTRY_BLOCK_PTR->next_bb->il.rtl->global_live_at_start,\n+\t\t (ENTRY_BLOCK_PTR->next_bb->il.rtl->global_live_at_start,\n \t\t  REGNO (x))))\n       && INSN_CUID (reg_stat[REGNO (x)].last_set) < subst_low_cuid)\n     {\n@@ -8267,13 +8266,13 @@ reg_nonzero_bits_for_combine (rtx x, enum machine_mode mode,\n     {\n #ifdef SHORT_IMMEDIATES_SIGN_EXTEND\n       /* If X is narrower than MODE and TEM is a non-negative\n-         constant that would appear negative in the mode of X,\n-         sign-extend it for use in reg_nonzero_bits because some\n-         machines (maybe most) will actually do the sign-extension\n-         and this is the conservative approach.\n+\t constant that would appear negative in the mode of X,\n+\t sign-extend it for use in reg_nonzero_bits because some\n+\t machines (maybe most) will actually do the sign-extension\n+\t and this is the conservative approach.\n \n-         ??? For 2.5, try to tighten up the MD files in this regard\n-         instead of this kludge.  */\n+\t ??? For 2.5, try to tighten up the MD files in this regard\n+\t instead of this kludge.  */\n \n       if (GET_MODE_BITSIZE (GET_MODE (x)) < GET_MODE_BITSIZE (mode)\n \t  && GET_CODE (tem) == CONST_INT\n@@ -8292,8 +8291,8 @@ reg_nonzero_bits_for_combine (rtx x, enum machine_mode mode,\n       unsigned HOST_WIDE_INT mask = reg_stat[REGNO (x)].nonzero_bits;\n \n       if (GET_MODE_BITSIZE (GET_MODE (x)) < GET_MODE_BITSIZE (mode))\n-        /* We don't know anything about the upper bits.  */\n-        mask |= GET_MODE_MASK (mode) ^ GET_MODE_MASK (GET_MODE (x));\n+\t/* We don't know anything about the upper bits.  */\n+\tmask |= GET_MODE_MASK (mode) ^ GET_MODE_MASK (GET_MODE (x));\n       *nonzero &= mask;\n     }\n \n@@ -8318,10 +8317,10 @@ reg_num_sign_bit_copies_for_combine (rtx x, enum machine_mode mode,\n   if (reg_stat[REGNO (x)].last_set_value != 0\n       && reg_stat[REGNO (x)].last_set_mode == mode\n       && (reg_stat[REGNO (x)].last_set_label == label_tick\n-          || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n+\t  || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t      && REG_N_SETS (REGNO (x)) == 1\n \t      && ! REGNO_REG_SET_P\n-\t         (ENTRY_BLOCK_PTR->next_bb->il.rtl->global_live_at_start,\n+\t\t (ENTRY_BLOCK_PTR->next_bb->il.rtl->global_live_at_start,\n \t\t  REGNO (x))))\n       && INSN_CUID (reg_stat[REGNO (x)].last_set) < subst_low_cuid)\n     {\n@@ -8336,7 +8335,7 @@ reg_num_sign_bit_copies_for_combine (rtx x, enum machine_mode mode,\n   if (nonzero_sign_valid && reg_stat[REGNO (x)].sign_bit_copies != 0\n       && GET_MODE_BITSIZE (GET_MODE (x)) == GET_MODE_BITSIZE (mode))\n     *result = reg_stat[REGNO (x)].sign_bit_copies;\n-      \n+\n   return NULL;\n }\n \f\n@@ -8940,8 +8939,8 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t\t   && 0 > trunc_int_for_mode (INTVAL (XEXP (varop, 1)),\n \t\t\t\t\t      shift_mode))\n \t      && (new = simplify_const_binary_operation (code, result_mode,\n-\t\t\t\t\t\t         XEXP (varop, 1),\n-\t\t\t\t\t\t         GEN_INT (count))) != 0\n+\t\t\t\t\t\t\t XEXP (varop, 1),\n+\t\t\t\t\t\t\t GEN_INT (count))) != 0\n \t      && GET_CODE (new) == CONST_INT\n \t      && merge_outer_ops (&outer_op, &outer_const, GET_CODE (varop),\n \t\t\t\t  INTVAL (new), result_mode, &complement_p))\n@@ -8956,7 +8955,7 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t     for some (ashiftrt (xor)).  */\n \t  if (GET_CODE (XEXP (varop, 1)) == CONST_INT\n \t     && !(code == ASHIFTRT && GET_CODE (varop) == XOR\n-\t          && 0 > trunc_int_for_mode (INTVAL (XEXP (varop, 1)),\n+\t\t  && 0 > trunc_int_for_mode (INTVAL (XEXP (varop, 1)),\n \t\t\t\t\t     shift_mode)))\n \t    {\n \t      rtx lhs = simplify_shift_const (NULL_RTX, code, shift_mode,\n@@ -8969,7 +8968,7 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t      varop = apply_distributive_law (varop);\n \n \t      count = 0;\n-\t      continue; \n+\t      continue;\n \t    }\n \t  break;\n \n@@ -9068,8 +9067,8 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t  if (code == ASHIFT\n \t      && GET_CODE (XEXP (varop, 1)) == CONST_INT\n \t      && (new = simplify_const_binary_operation (ASHIFT, result_mode,\n-\t\t\t\t\t\t         XEXP (varop, 1),\n-\t\t\t\t\t\t         GEN_INT (count))) != 0\n+\t\t\t\t\t\t\t XEXP (varop, 1),\n+\t\t\t\t\t\t\t GEN_INT (count))) != 0\n \t      && GET_CODE (new) == CONST_INT\n \t      && merge_outer_ops (&outer_op, &outer_const, PLUS,\n \t\t\t\t  INTVAL (new), result_mode, &complement_p))\n@@ -9087,8 +9086,8 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t      && GET_CODE (XEXP (varop, 1)) == CONST_INT\n \t      && mode_signbit_p (result_mode, XEXP (varop, 1))\n \t      && (new = simplify_const_binary_operation (code, result_mode,\n-\t\t\t\t\t\t         XEXP (varop, 1),\n-\t\t\t\t\t\t         GEN_INT (count))) != 0\n+\t\t\t\t\t\t\t XEXP (varop, 1),\n+\t\t\t\t\t\t\t GEN_INT (count))) != 0\n \t      && GET_CODE (new) == CONST_INT\n \t      && merge_outer_ops (&outer_op, &outer_const, XOR,\n \t\t\t\t  INTVAL (new), result_mode, &complement_p))\n@@ -10025,7 +10024,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      && ! unsigned_comparison_p\n \t      && (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n \t      && ((unsigned HOST_WIDE_INT) const_op\n-\t\t  < (((unsigned HOST_WIDE_INT) 1 \n+\t\t  < (((unsigned HOST_WIDE_INT) 1\n \t\t      << (GET_MODE_BITSIZE (mode) - 1))))\n \t      && cmp_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n \t    {\n@@ -10066,7 +10065,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t      HOST_WIDE_INT c1 = -INTVAL (XEXP (SUBREG_REG (op0), 1));\n \n \t      if ((c1 > 0\n-\t           && (unsigned HOST_WIDE_INT) c1\n+\t\t   && (unsigned HOST_WIDE_INT) c1\n \t\t       < (unsigned HOST_WIDE_INT) 1 << (mode_width - 1)\n \t\t   && (equality_comparison_p || unsigned_comparison_p)\n \t\t   /* (A - C1) zero-extends if it is positive and sign-extends\n@@ -10089,7 +10088,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t\t{\n \t\t  op0 = SUBREG_REG (op0);\n \t\t  continue;\n-\t        }\n+\t\t}\n \t    }\n \n \t  /* If the inner mode is narrower and we are extracting the low part,\n@@ -10197,7 +10196,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \tcase UNEQ:  case LTGT:\n \tcase LT:  case LTU:  case UNLT:  case LE:  case LEU:  case UNLE:\n \tcase GT:  case GTU:  case UNGT:  case GE:  case GEU:  case UNGE:\n-        case UNORDERED: case ORDERED:\n+\tcase UNORDERED: case ORDERED:\n \t  /* We can't do anything if OP0 is a condition code value, rather\n \t     than an actual data value.  */\n \t  if (const_op != 0\n@@ -10259,8 +10258,8 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t    {\n \t      op0 = simplify_and_const_int\n \t\t(NULL_RTX, mode, gen_rtx_LSHIFTRT (mode,\n-\t\t\t\t\t           XEXP (op0, 1),\n-\t\t\t\t\t           XEXP (XEXP (op0, 0), 1)),\n+\t\t\t\t\t\t   XEXP (op0, 1),\n+\t\t\t\t\t\t   XEXP (XEXP (op0, 0), 1)),\n \t\t (HOST_WIDE_INT) 1);\n \t      continue;\n \t    }\n@@ -10606,7 +10605,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t{\n \t  /* For paradoxical subregs, allow case 1 as above.  Case 3 isn't\n \t     implemented.  */\n-          if (REG_P (SUBREG_REG (op0)))\n+\t  if (REG_P (SUBREG_REG (op0)))\n \t    {\n \t      op0 = SUBREG_REG (op0);\n \t      op1 = gen_lowpart (GET_MODE (op0), op1);\n@@ -11111,7 +11110,7 @@ static void\n record_truncated_value (rtx x)\n {\n   enum machine_mode truncated_mode;\n-  \n+\n   if (GET_CODE (x) == SUBREG && REG_P (SUBREG_REG (x)))\n     {\n       enum machine_mode original_mode = GET_MODE (SUBREG_REG (x));\n@@ -12017,7 +12016,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t  if (place && JUMP_P (place))\n \t    {\n \t      rtx label = JUMP_LABEL (place);\n-\t      \n+\n \t      if (!label)\n \t\tJUMP_LABEL (place) = XEXP (note, 0);\n \t      else\n@@ -12031,7 +12030,7 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t  if (place2 && JUMP_P (place2))\n \t    {\n \t      rtx label = JUMP_LABEL (place2);\n-\t      \n+\n \t      if (!label)\n \t\tJUMP_LABEL (place2) = XEXP (note, 0);\n \t      else"}, {"sha": "3c5fc0ea544c2b60a76ff951829ba13fc9fa7eff", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c22cacf346343c87823813e73734aa7d728553c6/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=c22cacf346343c87823813e73734aa7d728553c6", "patch": "@@ -8,12 +8,12 @@\n ; the terms of the GNU General Public License as published by the Free\n ; Software Foundation; either version 2, or (at your option) any later\n ; version.\n-; \n+;\n ; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n ; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n ; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n ; for more details.\n-; \n+;\n ; You should have received a copy of the GNU General Public License\n ; along with GCC; see the file COPYING.  If not, write to the Free\n ; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n@@ -786,7 +786,7 @@ Common Report Var(flag_sched_stalled_insns)\n Allow premature scheduling of queued insns\n \n fsched-stalled-insns=\n-Common RejectNegative Joined UInteger \n+Common RejectNegative Joined UInteger\n -fsched-stalled-insns=<number>\tSet number of queued insns that can be prematurely scheduled\n \n ; sched_stalled_insns_dep controls how many recently scheduled cycles will\n@@ -830,7 +830,7 @@ Common Report Var(flag_split_ivs_in_unroller) Init(1)\n Split lifetimes of induction variables when loops are unrolled\n \n fvariable-expansion-in-unroller\n-Common Report Var(flag_variable_expansion_in_unroller) \n+Common Report Var(flag_variable_expansion_in_unroller)\n Apply variable expansion when loops are unrolled\n \n ; Emit code to probe the stack, to help detect stack overflow; also"}]}