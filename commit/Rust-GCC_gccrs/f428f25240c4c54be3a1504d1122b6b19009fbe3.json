{"sha": "f428f25240c4c54be3a1504d1122b6b19009fbe3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQyOGYyNTI0MGM0YzU0YmUzYTE1MDRkMTEyMmI2YjE5MDA5ZmJlMw==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1999-10-06T14:48:41Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "1999-10-06T14:48:41Z"}, "message": "collect2.c (scan_prog_file, [...]): Prototype function pointers and casts for `int_handler' and `quit_handler'.\n\n       * collect2.c (scan_prog_file, scan_libraries): Prototype function\n       pointers and casts for `int_handler' and `quit_handler'.\n\n       * flow.c (verify_flow_info, split_hard_reg_notes,\n       find_insn_with_note, sets_reg_or_subreg_1, prepend_reg_notes,\n       remove_edge, remove_fake_successors): Add static prototypes.\n       (verify_flow_info): Wrap with macro ENABLE_CHECKING.\n       (mark_set_1): Initialize variable `regno'.\n       (unlink_insn_chain): Likewise for variable `curr'.\n       (remove_fake_edges): Remove unused variables `e', `tmp' and `last'.\n\n       * loop.c (strength_reduce): Initialize variable\n       `unrolled_insn_copies'.\n       (cmp_combine_givs_stats, cmp_recombine_givs_stats): Add static\n       prototypes.  Change these functions to take const PTR parameters\n       to avoid prototype conflict when used as the comparson argument\n       for qsort.\n       (check_dbra_loop): Initialize variable `comparison_val'.\n\n       * reload.c (debug_reload_to_stream, debug_reload): Add prototypes.\n       (get_secondary_mem): Mark parameter `x' with ATTRIBUTE_UNUSED.\n       (find_valid_class): Initialize variable `best_class'.\n       (find_reloads): Call memcpy, not bcopy.\n\n       * reload1.c (gen_mode_int, dump_needs): Add prototypes.\n       (hard_reg_use_compare): Don't needlessly cast away const.\n       (reload_reg_class_lower): Likewise.\n       (choose_reload_regs): Initialize variable `regno'.\n\nFrom-SVN: r29840", "tree": {"sha": "9130a8d0694e0c7e16fedf58621b0487a85a2847", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9130a8d0694e0c7e16fedf58621b0487a85a2847"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f428f25240c4c54be3a1504d1122b6b19009fbe3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f428f25240c4c54be3a1504d1122b6b19009fbe3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f428f25240c4c54be3a1504d1122b6b19009fbe3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f428f25240c4c54be3a1504d1122b6b19009fbe3/comments", "author": null, "committer": null, "parents": [{"sha": "1e0a44093bf44af9de6a2d71198436d606f012ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e0a44093bf44af9de6a2d71198436d606f012ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e0a44093bf44af9de6a2d71198436d606f012ca"}], "stats": {"total": 125, "additions": 90, "deletions": 35}, "files": [{"sha": "2bba07cb8a7df51a9bd1a2e5ee97ab80b0f0a531", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f428f25240c4c54be3a1504d1122b6b19009fbe3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f428f25240c4c54be3a1504d1122b6b19009fbe3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f428f25240c4c54be3a1504d1122b6b19009fbe3", "patch": "@@ -1,3 +1,34 @@\n+Wed Oct  6 10:41:56 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* collect2.c (scan_prog_file, scan_libraries): Prototype function\n+\tpointers and casts for `int_handler' and `quit_handler'.\n+\n+\t* flow.c (verify_flow_info, split_hard_reg_notes,\n+\tfind_insn_with_note, sets_reg_or_subreg_1, prepend_reg_notes,\n+\tremove_edge, remove_fake_successors): Add static prototypes.\n+\t(verify_flow_info): Wrap with macro ENABLE_CHECKING.\n+\t(mark_set_1): Initialize variable `regno'.\n+\t(unlink_insn_chain): Likewise for variable `curr'.\n+\t(remove_fake_edges): Remove unused variables `e', `tmp' and `last'.\n+\n+\t* loop.c (strength_reduce): Initialize variable\n+\t`unrolled_insn_copies'.\n+\t(cmp_combine_givs_stats, cmp_recombine_givs_stats): Add static\n+\tprototypes.  Change these functions to take const PTR parameters\n+\tto avoid prototype conflict when used as the comparson argument\n+\tfor qsort.\n+\t(check_dbra_loop): Initialize variable `comparison_val'.\n+\n+\t* reload.c (debug_reload_to_stream, debug_reload): Add prototypes.\n+\t(get_secondary_mem): Mark parameter `x' with ATTRIBUTE_UNUSED.\n+\t(find_valid_class): Initialize variable `best_class'.\n+\t(find_reloads): Call memcpy, not bcopy.\n+\n+\t* reload1.c (gen_mode_int, dump_needs): Add prototypes.\n+\t(hard_reg_use_compare): Don't needlessly cast away const.\n+\t(reload_reg_class_lower): Likewise.\n+\t(choose_reload_regs): Initialize variable `regno'.\n+\n Tue Oct  5 16:34:12 1999  Paul Burchard <burchard@pobox.com>\n \n \t* ggc-page.c (GGC_ALWAYS_COLLECT): Fix typo when undef'ing."}, {"sha": "de2976e59b50a9ad6d9c2e3615cac1f034acb194", "filename": "gcc/collect2.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f428f25240c4c54be3a1504d1122b6b19009fbe3/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f428f25240c4c54be3a1504d1122b6b19009fbe3/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=f428f25240c4c54be3a1504d1122b6b19009fbe3", "patch": "@@ -2094,8 +2094,8 @@ scan_prog_file (prog_name, which_pass)\n      const char *prog_name;\n      enum pass which_pass;\n {\n-  void (*int_handler) ();\n-  void (*quit_handler) ();\n+  void (*int_handler) PROTO ((int));\n+  void (*quit_handler) PROTO ((int));\n   char *real_nm_argv[4];\n   const char **nm_argv = (const char **) real_nm_argv;\n   int pid;\n@@ -2162,9 +2162,9 @@ scan_prog_file (prog_name, which_pass)\n     }\n \n   /* Parent context from here on.  */\n-  int_handler  = (void (*) ())signal (SIGINT,  SIG_IGN);\n+  int_handler  = (void (*) PROTO ((int))) signal (SIGINT,  SIG_IGN);\n #ifdef SIGQUIT\n-  quit_handler = (void (*) ())signal (SIGQUIT, SIG_IGN);\n+  quit_handler = (void (*) PROTO ((int))) signal (SIGQUIT, SIG_IGN);\n #endif\n \n   if (close (pipe_fd[1]) < 0)\n@@ -2539,8 +2539,8 @@ scan_libraries (prog_name)\n {\n   static struct head libraries;\t\t/* list of shared libraries found */\n   struct id *list;\n-  void (*int_handler) ();\n-  void (*quit_handler) ();\n+  void (*int_handler) PROTO ((int));\n+  void (*quit_handler) PROTO ((int));\n   char *real_ldd_argv[4];\n   const char **ldd_argv = (const char **) real_ldd_argv;\n   int pid;\n@@ -2604,9 +2604,9 @@ scan_libraries (prog_name)\n     }\n \n   /* Parent context from here on.  */\n-  int_handler  = (void (*) ()) signal (SIGINT,  SIG_IGN);\n+  int_handler  = (void (*) PROTO ((int))) signal (SIGINT,  SIG_IGN);\n #ifdef SIGQUIT\n-  quit_handler = (void (*) ()) signal (SIGQUIT, SIG_IGN);\n+  quit_handler = (void (*) PROTO ((int))) signal (SIGQUIT, SIG_IGN);\n #endif\n \n   if (close (pipe_fd[1]) < 0)"}, {"sha": "8dbc07e0a5eb8c28efb3a64d727651c84cd1aca9", "filename": "gcc/flow.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f428f25240c4c54be3a1504d1122b6b19009fbe3/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f428f25240c4c54be3a1504d1122b6b19009fbe3/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=f428f25240c4c54be3a1504d1122b6b19009fbe3", "patch": "@@ -354,7 +354,15 @@ static int maybe_add_dead_note\t\tPROTO ((rtx, rtx, rtx));\n static int sets_reg_or_subreg\t\tPROTO ((rtx, rtx));\n static void update_n_sets \t\tPROTO ((rtx, int));\n static void new_insn_dead_notes\t\tPROTO ((rtx, rtx, rtx, rtx, rtx, rtx));\n-void verify_flow_info\t\t\tPROTO ((void));\n+#ifdef ENABLE_CHECKING\n+static void verify_flow_info\t\tPROTO ((void));\n+#endif\n+static void split_hard_reg_notes\tPROTO ((rtx, rtx, rtx, rtx));\n+static rtx find_insn_with_note\t\tPROTO ((rtx, rtx, rtx));\n+static void sets_reg_or_subreg_1\tPROTO ((rtx, rtx));\n+static rtx prepend_reg_notes\t\tPROTO ((rtx, rtx));\n+static void remove_edge\t\t\tPROTO ((edge));\n+static void remove_fake_successors\tPROTO ((basic_block));\n \f\n /* Find basic blocks of the current function.\n    F is the first insn of the function and NREGS the number of register\n@@ -3529,7 +3537,7 @@ mark_set_1 (needed, dead, x, insn, significant)\n      rtx insn;\n      regset significant;\n {\n-  register int regno;\n+  register int regno = -1;\n   register rtx reg = SET_DEST (x);\n \n   /* Some targets place small structures in registers for\n@@ -5419,7 +5427,7 @@ unlink_insn_chain (start, finish)\n      rtx start, finish;\n {\n   rtx insert_point = PREV_INSN (start);\n-  rtx chain = NULL_RTX, curr;\n+  rtx chain = NULL_RTX, curr = NULL_RTX;\n \n   /* Unchain the insns one by one.  It would be quicker to delete all\n      of these with a single unchaining, rather than one at a time, but\n@@ -5625,7 +5633,7 @@ maybe_add_dead_note_use (insn, dest)\n \n /* Find the first insn in the set of insns from FIRST to LAST inclusive\n    that contains the note NOTE. */\n-rtx\n+static rtx\n find_insn_with_note (note, first, last)\n      rtx note, first, last;\n {\n@@ -6472,7 +6480,8 @@ replace_insns (first, last, first_new, notes)\n    In future it can be extended check a lot of other stuff as well\n    (reachability of basic blocks, life information, etc. etc.).  */\n \n-void\n+#ifdef ENABLE_CHECKING\n+static void\n verify_flow_info ()\n {\n   const int max_uid = get_max_uid ();\n@@ -6675,6 +6684,7 @@ verify_flow_info ()\n       x = NEXT_INSN (x);\n     }\n }\n+#endif\n \f\n /* Functions to access an edge list with a vector representation.\n    Enough data is kept such that given an index number, the \n@@ -6998,12 +7008,10 @@ void\n remove_fake_edges ()\n {\n   int x;\n-  edge e;\n   basic_block bb;\n \n   for (x = 0; x < n_basic_blocks; x++)\n     {\n-      edge tmp, last = NULL;\n       bb = BASIC_BLOCK (x);\n       remove_fake_successors (bb);\n     }"}, {"sha": "40ed922a783b399a1a46faf30b56ad3780188f7a", "filename": "gcc/loop.c", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f428f25240c4c54be3a1504d1122b6b19009fbe3/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f428f25240c4c54be3a1504d1122b6b19009fbe3/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=f428f25240c4c54be3a1504d1122b6b19009fbe3", "patch": "@@ -3714,7 +3714,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   rtx end_insert_before;\n   int loop_depth = 0;\n   int n_extra_increment;\n-  int unrolled_insn_copies;\n+  int unrolled_insn_copies = 0;\n \n   /* If scan_start points to the loop exit test, we have to be wary of\n      subversive use of gotos inside expression statements.  */\n@@ -6268,8 +6268,10 @@ general_induction_var (x, src_reg, add_val, mult_val, is_addr, pbenefit)\n \n    *BENEFIT will be incremented by the benefit of any sub-giv encountered.  */\n \n-static rtx sge_plus PROTO ((enum machine_mode, rtx, rtx));\n-static rtx sge_plus_constant PROTO ((rtx, rtx));\n+static rtx sge_plus PARAMS ((enum machine_mode, rtx, rtx));\n+static rtx sge_plus_constant PARAMS ((rtx, rtx));\n+static int cmp_combine_givs_stats PARAMS ((const PTR, const PTR));\n+static int cmp_recombine_givs_stats PARAMS ((const PTR, const PTR));\n \n static rtx\n simplify_giv_expr (x, benefit)\n@@ -7015,9 +7017,14 @@ struct combine_givs_stats\n };\n \n static int\n-cmp_combine_givs_stats (x, y)\n-     struct combine_givs_stats *x, *y;\n+cmp_combine_givs_stats (xp, yp)\n+     const PTR xp;\n+     const PTR yp;\n {\n+  const struct combine_givs_stats * const x =\n+    (const struct combine_givs_stats *) xp;\n+  const struct combine_givs_stats * const y =\n+    (const struct combine_givs_stats *) yp;\n   int d;\n   d = y->total_benefit - x->total_benefit;\n   /* Stabilize the sort.  */\n@@ -7202,9 +7209,14 @@ struct recombine_givs_stats\n    when scanning the array starting at the end, thus the arguments are\n    used in reverse.  */\n static int\n-cmp_recombine_givs_stats (x, y)\n-     struct recombine_givs_stats *x, *y;\n+cmp_recombine_givs_stats (xp, yp)\n+     const PTR xp;\n+     const PTR yp;\n {\n+  const struct recombine_givs_stats * const x =\n+    (const struct recombine_givs_stats *) xp;\n+  const struct recombine_givs_stats * const y =\n+    (const struct recombine_givs_stats *) yp;\n   int d;\n   d = y->start_luid - x->start_luid;\n   /* Stabilize the sort.  */\n@@ -7994,7 +8006,7 @@ check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n \t\t  || (GET_CODE (comparison) == LE\n \t\t      && no_use_except_counting)))\n \t    {\n-\t      HOST_WIDE_INT add_val, add_adjust, comparison_val;\n+\t      HOST_WIDE_INT add_val, add_adjust, comparison_val = 0;\n \t      rtx initial_value, comparison_value;\n \t      int nonneg = 0;\n \t      enum rtx_code cmp_code;"}, {"sha": "011d0a904e13fbcf55cc4f77d302798bb6e2e1b7", "filename": "gcc/reload.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f428f25240c4c54be3a1504d1122b6b19009fbe3/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f428f25240c4c54be3a1504d1122b6b19009fbe3/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=f428f25240c4c54be3a1504d1122b6b19009fbe3", "patch": "@@ -272,6 +272,8 @@ static rtx find_reloads_subreg_address PROTO((rtx, int, int, enum reload_type,\n \t\t\t\t\t      int, rtx));\n static int find_inc_amount\tPROTO((rtx, rtx));\n static int loc_mentioned_in_p\tPROTO((rtx *, rtx));\n+extern void debug_reload_to_stream PROTO((FILE *));\n+extern void debug_reload PROTO((void));\n \f\n #ifdef HAVE_SECONDARY_RELOADS\n \n@@ -571,7 +573,7 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n \n rtx\n get_secondary_mem (x, mode, opnum, type)\n-     rtx x;\n+     rtx x ATTRIBUTE_UNUSED;\n      enum machine_mode mode;\n      int opnum;\n      enum reload_type type;\n@@ -658,7 +660,7 @@ find_valid_class (m1, n)\n {\n   int class;\n   int regno;\n-  enum reg_class best_class;\n+  enum reg_class best_class = NO_REGS;\n   int best_size = 0;\n \n   for (class = 1; class < N_REG_CLASSES; class++)\n@@ -2452,10 +2454,9 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   insn_code_number = INSN_CODE (insn);\n   this_insn_is_asm = insn_code_number < 0;\n \n-  bcopy ((char *) recog_data.operand_mode, (char *) operand_mode,\n-\t noperands * sizeof (enum machine_mode));\n-  bcopy ((char *) recog_data.constraints, (char *) constraints,\n-\t noperands * sizeof (char *));\n+  memcpy (operand_mode, recog_data.operand_mode,\n+\t  noperands * sizeof (enum machine_mode));\n+  memcpy (constraints, recog_data.constraints, noperands * sizeof (char *));\n \n   commutative = -1;\n \n@@ -3433,8 +3434,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  pref_or_nothing[commutative] = pref_or_nothing[commutative + 1];\n \t  pref_or_nothing[commutative + 1] = t;\n \n-\t  bcopy ((char *) recog_data.constraints, (char *) constraints,\n-\t\t noperands * sizeof (char *));\n+\t  memcpy (constraints, recog_data.constraints,\n+\t\t  noperands * sizeof (char *));\n \t  goto try_swapped;\n \t}\n       else"}, {"sha": "caa7c1048ec0e0ea625c01b1637e7c8cfc690b4f", "filename": "gcc/reload1.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f428f25240c4c54be3a1504d1122b6b19009fbe3/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f428f25240c4c54be3a1504d1122b6b19009fbe3/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=f428f25240c4c54be3a1504d1122b6b19009fbe3", "patch": "@@ -449,6 +449,9 @@ static void move2add_note_store PROTO((rtx, rtx));\n #ifdef AUTO_INC_DEC\n static void add_auto_inc_notes PROTO((rtx, rtx));\n #endif\n+static rtx gen_mode_int\t\t\tPROTO((enum machine_mode,\n+\t\t\t\t\t       HOST_WIDE_INT));\n+extern void dump_needs\t\t\tPROTO((struct insn_chain *, FILE *));\n \f\n /* Initialize the reload pass once per compilation.  */\n \n@@ -4023,8 +4026,8 @@ hard_reg_use_compare (p1p, p2p)\n      const PTR p1p;\n      const PTR p2p;\n {\n-  struct hard_reg_n_uses *p1 = (struct hard_reg_n_uses *)p1p;\n-  struct hard_reg_n_uses *p2 = (struct hard_reg_n_uses *)p2p;\n+  const struct hard_reg_n_uses *p1 = (const struct hard_reg_n_uses *)p1p;\n+  const struct hard_reg_n_uses *p2 = (const struct hard_reg_n_uses *)p2p;\n   int bad1 = TEST_HARD_REG_BIT (bad_spill_regs, p1->regno);\n   int bad2 = TEST_HARD_REG_BIT (bad_spill_regs, p2->regno);\n   if (bad1 && bad2)\n@@ -4519,7 +4522,7 @@ reload_reg_class_lower (r1p, r2p)\n      const PTR r1p;\n      const PTR r2p;\n {\n-  register int r1 = *(short *)r1p, r2 = *(short *)r2p;\n+  register int r1 = *(const short *)r1p, r2 = *(const short *)r2p;\n   register int t;\n \n   /* Consider required reloads before optional ones.  */\n@@ -6014,7 +6017,7 @@ choose_reload_regs (chain)\n \t      register rtx equiv\n \t\t= find_equiv_reg (search_equiv, insn, rld[r].class,\n \t\t\t\t  -1, NULL_PTR, 0, reload_mode[r]);\n-\t      int regno;\n+\t      int regno = 0;\n \n \t      if (equiv != 0)\n \t\t{"}]}