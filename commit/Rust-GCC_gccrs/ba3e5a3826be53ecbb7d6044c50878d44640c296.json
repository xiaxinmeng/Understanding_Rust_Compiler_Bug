{"sha": "ba3e5a3826be53ecbb7d6044c50878d44640c296", "node_id": "C_kwDOANBUbNoAKGJhM2U1YTM4MjZiZTUzZWNiYjdkNjA0NGM1MDg3OGQ0NDY0MGMyOTY", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2022-10-04T02:50:22Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@kernel.crashing.org", "date": "2022-10-05T19:12:28Z"}, "message": "rs6000: Rework vsx_extract_<mode>\n\nExtracting the left and right halfs of a vector are entirely different\noperations.  Things are simpler if they are separate define_insns, and\nit is easy to get rid of the \"wD\" constraint use then.\n\nThis also give the variant that is a no-op copy its own alternative, of\nlength 0 (and this, cost 0, making it more likely RA will choose it.\n\n2022-10-05  Segher Boessenkool  <segher@kernel.crashing.org>\n\n\t* config/rs6000/vsx.md (vsx_extract_<mode>): Replace define_insn by a\n\tdefine_expand.  Split the contents to...\n\t(*vsx_extract_<mode>_0): ... this.  Rewrite.\n\t(*vsx_extract_<mode>_1): ... and this.  Rewrite.", "tree": {"sha": "947f82a71a3109e10ff9f55af684b47f9346c244", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/947f82a71a3109e10ff9f55af684b47f9346c244"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba3e5a3826be53ecbb7d6044c50878d44640c296", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba3e5a3826be53ecbb7d6044c50878d44640c296", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba3e5a3826be53ecbb7d6044c50878d44640c296", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba3e5a3826be53ecbb7d6044c50878d44640c296/comments", "author": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "committer": {"login": "segher", "id": 417629, "node_id": "MDQ6VXNlcjQxNzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/417629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/segher", "html_url": "https://github.com/segher", "followers_url": "https://api.github.com/users/segher/followers", "following_url": "https://api.github.com/users/segher/following{/other_user}", "gists_url": "https://api.github.com/users/segher/gists{/gist_id}", "starred_url": "https://api.github.com/users/segher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/segher/subscriptions", "organizations_url": "https://api.github.com/users/segher/orgs", "repos_url": "https://api.github.com/users/segher/repos", "events_url": "https://api.github.com/users/segher/events{/privacy}", "received_events_url": "https://api.github.com/users/segher/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3d131531a23c71e09c032d6222d0b5ff0eb8162", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3d131531a23c71e09c032d6222d0b5ff0eb8162", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3d131531a23c71e09c032d6222d0b5ff0eb8162"}], "stats": {"total": 80, "additions": 37, "deletions": 43}, "files": [{"sha": "e0e34a78bca1c1a5539f2381dd98b72f992033b2", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 37, "deletions": 43, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba3e5a3826be53ecbb7d6044c50878d44640c296/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba3e5a3826be53ecbb7d6044c50878d44640c296/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=ba3e5a3826be53ecbb7d6044c50878d44640c296", "patch": "@@ -3388,59 +3388,53 @@\n ;; Optimize cases were we can do a simple or direct move.\n ;; Or see if we can avoid doing the move at all\n \n-(define_insn \"vsx_extract_<mode>\"\n-  [(set (match_operand:<VEC_base> 0 \"gpc_reg_operand\" \"=wa, wa, wr, wr\")\n+(define_expand \"vsx_extract_<mode>\"\n+  [(set (match_operand:<VEC_base> 0 \"gpc_reg_operand\")\n \t(vec_select:<VEC_base>\n-\t (match_operand:VSX_D 1 \"gpc_reg_operand\"       \"wa, wa, wa, wa\")\n+\t (match_operand:VSX_D 1 \"gpc_reg_operand\")\n \t (parallel\n-\t  [(match_operand:QI 2 \"const_0_to_1_operand\"   \"wD, n,  wD, n\")])))]\n+\t  [(match_operand:QI 2 \"const_0_to_1_operand\")])))]\n   \"VECTOR_MEM_VSX_P (<MODE>mode)\"\n-{\n-  int element = INTVAL (operands[2]);\n-  int op0_regno = REGNO (operands[0]);\n-  int op1_regno = REGNO (operands[1]);\n-  int fldDM;\n-\n-  gcc_assert (IN_RANGE (element, 0, 1));\n-  gcc_assert (VSX_REGNO_P (op1_regno));\n-\n-  if (element == VECTOR_ELEMENT_SCALAR_64BIT)\n-    {\n-      if (op0_regno == op1_regno)\n-\treturn ASM_COMMENT_START \" vec_extract to same register\";\n-\n-      else if (INT_REGNO_P (op0_regno) && TARGET_DIRECT_MOVE\n-\t       && TARGET_POWERPC64)\n-\treturn \"mfvsrd %0,%x1\";\n+  \"\")\n \n-      else if (FP_REGNO_P (op0_regno) && FP_REGNO_P (op1_regno))\n-\treturn \"fmr %0,%1\";\n+(define_insn \"*vsx_extract_<mode>_0\"\n+  [(set (match_operand:<VEC_base> 0 \"gpc_reg_operand\" \"=wa,wa,wr\")\n+\t(vec_select:<VEC_base>\n+\t (match_operand:VSX_D 1 \"gpc_reg_operand\" \"0,wa,wa\")\n+\t (parallel\n+\t  [(match_operand:QI 2 \"const_0_to_1_operand\" \"n,n,n\")])))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode)\n+   && INTVAL (operands[2]) == (BYTES_BIG_ENDIAN ? 0 : 1)\"\n+{\n+  if (which_alternative == 0)\n+    return ASM_COMMENT_START \" vec_extract to same register\";\n \n-      else if (VSX_REGNO_P (op0_regno))\n-\treturn \"xxlor %x0,%x1,%x1\";\n+  if (which_alternative == 2)\n+    return \"mfvsrd %0,%x1\";\n \n-      else\n-\tgcc_unreachable ();\n-    }\n+  return \"xxlor %x0,%x1,%x1\";\n+}\n+  [(set_attr \"type\" \"*,veclogical,mfvsr\")\n+   (set_attr \"isa\" \"*,*,p8v\")\n+   (set_attr \"length\" \"0,*,*\")])\n \n-  else if (element == VECTOR_ELEMENT_MFVSRLD_64BIT && INT_REGNO_P (op0_regno)\n-\t   && TARGET_P9_VECTOR && TARGET_POWERPC64 && TARGET_DIRECT_MOVE)\n+(define_insn \"*vsx_extract_<mode>_1\"\n+  [(set (match_operand:<VEC_base> 0 \"gpc_reg_operand\" \"=wa,wr\")\n+\t(vec_select:<VEC_base>\n+\t (match_operand:VSX_D 1 \"gpc_reg_operand\" \"wa,wa\")\n+\t (parallel\n+\t  [(match_operand:QI 2 \"const_0_to_1_operand\" \"n,n\")])))]\n+  \"VECTOR_MEM_VSX_P (<MODE>mode)\n+   && INTVAL (operands[2]) == (BYTES_BIG_ENDIAN ? 1 : 0)\"\n+{\n+  if (which_alternative == 1)\n     return \"mfvsrld %0,%x1\";\n \n-  else if (VSX_REGNO_P (op0_regno))\n-    {\n-      fldDM = element << 1;\n-      if (!BYTES_BIG_ENDIAN)\n-\tfldDM = 3 - fldDM;\n-      operands[3] = GEN_INT (fldDM);\n-      return \"xxpermdi %x0,%x1,%x1,%3\";\n-    }\n-\n-  else\n-    gcc_unreachable ();\n+  operands[3] = GEN_INT (BYTES_BIG_ENDIAN ? 2 : 3);\n+  return \"xxpermdi %x0,%x1,%x1,%3\";\n }\n-  [(set_attr \"type\" \"veclogical,mfvsr,mfvsr,vecperm\")\n-   (set_attr \"isa\" \"*,*,p8v,p9v\")])\n+  [(set_attr \"type\" \"mfvsr,vecperm\")\n+   (set_attr \"isa\" \"*,p9v\")])\n \n ;; Optimize extracting a single scalar element from memory.\n (define_insn_and_split \"*vsx_extract_<P:mode>_<VSX_D:mode>_load\""}]}