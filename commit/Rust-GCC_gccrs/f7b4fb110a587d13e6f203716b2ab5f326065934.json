{"sha": "f7b4fb110a587d13e6f203716b2ab5f326065934", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdiNGZiMTEwYTU4N2QxM2U2ZjIwMzcxNmIyYWI1ZjMyNjA2NTkzNA==", "commit": {"author": {"name": "Kresten Krab Thorup", "email": "krab@samam.daimi.au.dk", "date": "1999-08-20T11:40:35Z"}, "committer": {"name": "Kresten Krab Thorup", "email": "krab@gcc.gnu.org", "date": "1999-08-20T11:40:35Z"}, "message": "interpret.cc (continue1): Implement explicit dispatch table.\n\n        * interpret.cc (continue1): Implement explicit dispatch table.\n\tinsn_target: Explicit interpreter switch table.\n\tSAVE_PC: New macro, moves pc saving code into instructions that\n\trequire so.\n\tNEXT_INSN: New macro, replaces `goto next_insn' in all insns.\n\tPC_REGISTER_ASM: New macro.\n\tINLINE_SWITCH: New macro.  Constrols dispatching strategy.\n\topcode: Remove local variable.\n\t{i,l,f,d}{load,store}_{0,1,2,3}: Expand definitions.\n\t(POKEI): Use _Jv_word.\n\t(iinc): Use _Jv_word.\n\t(dupx): Change reference argument (sp) to pointer.\n\t(jvdump): Remove\n\n\t* interpret.cc: Remove instruction timing instrumentation.\n\n\t* java/lang/natClassLoader.cc (_Jv_PrepareCompiledClass): Changed\n\tcomment.  Don't use _Jv_ClassNameSamePackage.\n\n\t* gnu/gcj/util/path/{SearchPath,ZipFileEntry,DirectoryPathEntry,\n\tURLPathEntry, CacheEntry}: Removed.\n\n\t* Makefile.am (ordinary_java_source_files): Remove gnu/gcj/util/path\n\tpackage.\n\t(.java.lo): Rule removed.\n\n\t* Makefile.in: Rebuilt.\n\nFrom-SVN: r28777", "tree": {"sha": "beb23951cf42ff30c1b42c1220cc8506ad04f7e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/beb23951cf42ff30c1b42c1220cc8506ad04f7e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7b4fb110a587d13e6f203716b2ab5f326065934", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7b4fb110a587d13e6f203716b2ab5f326065934", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7b4fb110a587d13e6f203716b2ab5f326065934", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7b4fb110a587d13e6f203716b2ab5f326065934/comments", "author": null, "committer": null, "parents": [{"sha": "ad69db4af5b5de7e8b8df977be78131adf375511", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad69db4af5b5de7e8b8df977be78131adf375511", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad69db4af5b5de7e8b8df977be78131adf375511"}], "stats": {"total": 1734, "additions": 983, "deletions": 751}, "files": [{"sha": "56160dffe74dfaa6fadd3aaee2c806389bf5fae7", "filename": "libjava/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b4fb110a587d13e6f203716b2ab5f326065934/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b4fb110a587d13e6f203716b2ab5f326065934/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=f7b4fb110a587d13e6f203716b2ab5f326065934", "patch": "@@ -1,3 +1,33 @@\n+1999-08-20  Kresten Krab Thorup  <krab@samam.daimi.au.dk>\n+\n+\t* interpret.cc (continue1): Implement explicit dispatch table.\n+\tinsn_target: Explicit interpreter switch table.  \n+\tSAVE_PC: New macro, moves pc saving code into instructions that\n+\trequire so.\n+\tNEXT_INSN: New macro, replaces `goto next_insn' in all insns.\n+\tPC_REGISTER_ASM: New macro.\n+\tINLINE_SWITCH: New macro.  Constrols dispatching strategy.\n+\topcode: Remove local variable.\n+\t{i,l,f,d}{load,store}_{0,1,2,3}: Expand definitions.\n+\t(POKEI): Use _Jv_word.\n+\t(iinc): Use _Jv_word.\n+\t(dupx): Change reference argument (sp) to pointer.  \n+\t(jvdump): Remove\n+\t\n+\t* interpret.cc: Remove instruction timing instrumentation.  \n+\n+\t* java/lang/natClassLoader.cc (_Jv_PrepareCompiledClass): Changed\n+\tcomment.  Don't use _Jv_ClassNameSamePackage. \n+\n+\t* gnu/gcj/util/path/{SearchPath,ZipFileEntry,DirectoryPathEntry,\n+\tURLPathEntry, CacheEntry}: Removed.\n+\t\n+\t* Makefile.am (ordinary_java_source_files): Remove gnu/gcj/util/path\n+\tpackage.\n+\t(.java.lo): Rule removed.\n+\n+\t* Makefile.in: Rebuilt.\n+\n 1999-08-19  Tom Tromey  <tromey@cygnus.com>\n \n \t* java/lang/natThread.cc (class locker): New class."}, {"sha": "17258d26257516bdf6951f7a5d4b70ff926cf5da", "filename": "libjava/Makefile.am", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b4fb110a587d13e6f203716b2ab5f326065934/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b4fb110a587d13e6f203716b2ab5f326065934/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=f7b4fb110a587d13e6f203716b2ab5f326065934", "patch": "@@ -161,9 +161,6 @@ SUFFIXES = .class .java .h\n .class.lo:\n \t$(GCJCOMPILE) -o $@ $<\n \n-.java.lo:\n-\t$(GCJCOMPILE) -o $@ $<\n-\n ## This is GNU make specific.  For the .o files in subdirs, use a\n ## special rule.  The standard automake rule can't be overridden (this\n ## is a bug in automake), and it also won't put the .o files into\n@@ -484,12 +481,6 @@ built_java_source_files = java/lang/ConcreteProcess.java\n ordinary_java_source_files =  $(convert_source_files) \\\n gnu/gcj/runtime/MethodInvocation.java \\\n gnu/gcj/runtime/VMClassLoader.java \\\n-gnu/gcj/util/path/SearchPath.java \\\n-gnu/gcj/util/path/PathEntry.java \\\n-gnu/gcj/util/path/DirectoryPathEntry.java \\\n-gnu/gcj/util/path/ZipPathEntry.java \\\n-gnu/gcj/util/path/URLPathEntry.java \\\n-gnu/gcj/util/path/CacheEntry.java \\\n gnu/gcj/text/BaseBreakIterator.java \\\n gnu/gcj/text/CharacterBreakIterator.java \\\n gnu/gcj/text/LineBreakIterator.java \\"}, {"sha": "41a9f8840fffdadb845fe57f9c6de2974250f1b4", "filename": "libjava/Makefile.in", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b4fb110a587d13e6f203716b2ab5f326065934/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b4fb110a587d13e6f203716b2ab5f326065934/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=f7b4fb110a587d13e6f203716b2ab5f326065934", "patch": "@@ -298,12 +298,6 @@ built_java_source_files = java/lang/ConcreteProcess.java\n ordinary_java_source_files = $(convert_source_files) \\\n gnu/gcj/runtime/MethodInvocation.java \\\n gnu/gcj/runtime/VMClassLoader.java \\\n-gnu/gcj/util/path/SearchPath.java \\\n-gnu/gcj/util/path/PathEntry.java \\\n-gnu/gcj/util/path/DirectoryPathEntry.java \\\n-gnu/gcj/util/path/ZipPathEntry.java \\\n-gnu/gcj/util/path/URLPathEntry.java \\\n-gnu/gcj/util/path/CacheEntry.java \\\n gnu/gcj/text/BaseBreakIterator.java \\\n gnu/gcj/text/CharacterBreakIterator.java \\\n gnu/gcj/text/LineBreakIterator.java \\\n@@ -746,13 +740,7 @@ DEP_FILES =  .deps/boehm.P .deps/defineclass.P .deps/dtoa.P \\\n .deps/gnu/gcj/text/LocaleData_en_US.P \\\n .deps/gnu/gcj/text/SentenceBreakIterator.P \\\n .deps/gnu/gcj/text/WordBreakIterator.P \\\n-.deps/gnu/gcj/util/EnumerationChain.P \\\n-.deps/gnu/gcj/util/path/CacheEntry.P \\\n-.deps/gnu/gcj/util/path/DirectoryPathEntry.P \\\n-.deps/gnu/gcj/util/path/PathEntry.P \\\n-.deps/gnu/gcj/util/path/SearchPath.P \\\n-.deps/gnu/gcj/util/path/URLPathEntry.P \\\n-.deps/gnu/gcj/util/path/ZipPathEntry.P .deps/interpret.P \\\n+.deps/gnu/gcj/util/EnumerationChain.P .deps/interpret.P \\\n .deps/java/io/BufferedInputStream.P \\\n .deps/java/io/BufferedOutputStream.P .deps/java/io/BufferedReader.P \\\n .deps/java/io/BufferedWriter.P .deps/java/io/ByteArrayInputStream.P \\\n@@ -1087,25 +1075,6 @@ gnu/gcj/runtime/MethodInvocation.lo: \\\n \t.deps/gnu/gcj/runtime/.dirstamp\n gnu/gcj/runtime/VMClassLoader.lo: gnu/gcj/runtime/VMClassLoader.java \\\n \tgnu/gcj/runtime/.dirstamp .deps/gnu/gcj/runtime/.dirstamp\n-gnu/gcj/util/path/.dirstamp:\n-\t@$(mkinstalldirs) gnu/gcj/util/path\n-\t@: > gnu/gcj/util/path/.dirstamp\n-.deps/gnu/gcj/util/path/.dirstamp:\n-\t@$(mkinstalldirs) .deps/gnu/gcj/util/path\n-\t@: > .deps/gnu/gcj/util/path/.dirstamp\n-gnu/gcj/util/path/SearchPath.lo: gnu/gcj/util/path/SearchPath.java \\\n-\tgnu/gcj/util/path/.dirstamp .deps/gnu/gcj/util/path/.dirstamp\n-gnu/gcj/util/path/PathEntry.lo: gnu/gcj/util/path/PathEntry.java \\\n-\tgnu/gcj/util/path/.dirstamp .deps/gnu/gcj/util/path/.dirstamp\n-gnu/gcj/util/path/DirectoryPathEntry.lo: \\\n-\tgnu/gcj/util/path/DirectoryPathEntry.java \\\n-\tgnu/gcj/util/path/.dirstamp .deps/gnu/gcj/util/path/.dirstamp\n-gnu/gcj/util/path/ZipPathEntry.lo: gnu/gcj/util/path/ZipPathEntry.java \\\n-\tgnu/gcj/util/path/.dirstamp .deps/gnu/gcj/util/path/.dirstamp\n-gnu/gcj/util/path/URLPathEntry.lo: gnu/gcj/util/path/URLPathEntry.java \\\n-\tgnu/gcj/util/path/.dirstamp .deps/gnu/gcj/util/path/.dirstamp\n-gnu/gcj/util/path/CacheEntry.lo: gnu/gcj/util/path/CacheEntry.java \\\n-\tgnu/gcj/util/path/.dirstamp .deps/gnu/gcj/util/path/.dirstamp\n gnu/gcj/text/.dirstamp:\n \t@$(mkinstalldirs) gnu/gcj/text\n \t@: > gnu/gcj/text/.dirstamp\n@@ -2214,9 +2183,6 @@ clean-local:\n .class.lo:\n \t$(GCJCOMPILE) -o $@ $<\n \n-.java.lo:\n-\t$(GCJCOMPILE) -o $@ $<\n-\n $(nat_files): %.lo: %.cc\n \t$(LTCXXCOMPILE) -c -o $@ $<\n "}, {"sha": "c9f3dc7fa2eb98908260b6d5a8fc97a6d7508e05", "filename": "libjava/include/java-insns.h", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b4fb110a587d13e6f203716b2ab5f326065934/libjava%2Finclude%2Fjava-insns.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b4fb110a587d13e6f203716b2ab5f326065934/libjava%2Finclude%2Fjava-insns.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-insns.h?ref=f7b4fb110a587d13e6f203716b2ab5f326065934", "patch": "@@ -215,32 +215,30 @@ static const int op_jsr_w = 0xc9;\n \n static const int op_putfield_1 = 0xca;\n static const int op_putfield_2 = 0xcb;\n-static const int op_putfield_4 = 0xcd;\n-static const int op_putfield_8 = 0xce;\n-static const int op_putfield_a = 0xcf;\n+static const int op_putfield_4 = 0xcc;\n+static const int op_putfield_8 = 0xcd;\n+static const int op_putfield_a = 0xce;\n \n-static const int op_putstatic_1 = 0xd0;\n-static const int op_putstatic_2 = 0xd1;\n-static const int op_putstatic_4 = 0xd2;\n-static const int op_putstatic_8 = 0xd3;\n-static const int op_putstatic_a = 0xd4;\n+static const int op_putstatic_1 = 0xcf;\n+static const int op_putstatic_2 = 0xd0;\n+static const int op_putstatic_4 = 0xd1;\n+static const int op_putstatic_8 = 0xd2;\n+static const int op_putstatic_a = 0xd3;\n \n-static const int op_getfield_1 = 0xd5;\n-static const int op_getfield_2s = 0xd6;\n-static const int op_getfield_2u = 0xd7;\n-static const int op_getfield_4 = 0xd8;\n-static const int op_getfield_8 = 0xd9;\n-static const int op_getfield_a = 0xda;\n+static const int op_getfield_1 = 0xd4;\n+static const int op_getfield_2s = 0xd5;\n+static const int op_getfield_2u = 0xd6;\n+static const int op_getfield_4 = 0xd7;\n+static const int op_getfield_8 = 0xd8;\n+static const int op_getfield_a = 0xd9;\n \n-static const int op_getstatic_1 = 0xdb;\n-static const int op_getstatic_2s = 0xdc;\n-static const int op_getstatic_2u = 0xdd;\n-static const int op_getstatic_4 = 0xde;\n-static const int op_getstatic_8 = 0xdf;\n-static const int op_getstatic_a = 0xe0;\n+static const int op_getstatic_1 = 0xda;\n+static const int op_getstatic_2s = 0xdb;\n+static const int op_getstatic_2u = 0xdc;\n+static const int op_getstatic_4 = 0xdd;\n+static const int op_getstatic_8 = 0xde;\n+static const int op_getstatic_a = 0xdf;\n \n-static const int op_invokefinal  = 0xe1;\n-static const int op_invokevtable = 0xe2;\n \n \n "}, {"sha": "7ea7cbfedb3aec6c55107c2ba1d7702001e63959", "filename": "libjava/interpret.cc", "status": "modified", "additions": 928, "deletions": 672, "changes": 1600, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b4fb110a587d13e6f203716b2ab5f326065934/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b4fb110a587d13e6f203716b2ab5f326065934/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=f7b4fb110a587d13e6f203716b2ab5f326065934", "patch": "@@ -10,9 +10,6 @@ details.  */\n \n /* Author: Kresten Krab Thorup <krab@gnu.org>  */\n \n-/* define this to get instruction timings.  */\n-/* #define TIME_MAINLOOP  */\n-\n #include <config.h>\n \n #pragma implementation \"java-interp.h\"\n@@ -38,10 +35,6 @@ details.  */\n #include <java/lang/IncompatibleClassChangeError.h>\n #include <java-insns.h>\n #include <java-signal.h>\n-#ifdef TIME_MAINLOOP\n-#include <sys/time.h>\n-#include <stdio.h>\n-#endif\n \n #ifndef INTERPRETER\n \n@@ -89,7 +82,7 @@ static void throw_arithmetic_exception ()\n #endif\n \n \n-static inline void dupx (_Jv_word *&sp, int n, int x)\n+static inline void dupx (_Jv_word *sp, int n, int x)\n {\n   // first \"slide\" n+x elements n to the right\n   int top = n-1;\n@@ -104,8 +97,6 @@ static inline void dupx (_Jv_word *&sp, int n, int x)\n       sp[top-(n+x)-i] = sp[top-i];\n     }\n   \n-  // the net effect\n-  sp += n;\n };\n \n \n@@ -151,7 +142,7 @@ static inline void dupx (_Jv_word *&sp, int n, int x)\n #define PEEKI(I)  (locals+(I))->i\n #define PEEKA(I)  (locals+(I))->o\n \n-#define POKEI(I,V)  (*(jint*) (locals+(I)) = (V))\n+#define POKEI(I,V)  ((locals+(I))->i = (V))\n \n \n #define BINOPI(OP) { \\\n@@ -418,7 +409,7 @@ gnu::gcj::runtime::MethodInvocation::continue1 (gnu::gcj::RawData *meth,\n /*\n   This proceeds execution, as designated in \"inv\".  If an exception\n   happens, then it is simply thrown, and handled in Java.  Thus, the pc\n-  needs to be stored in the invocation at all times, so we can figure\n+  needs to be stored in the inv->pc at all times, so we can figure\n   out which handler (if any) to invoke.\n \n   One design issue, which I have not completely considered, is if it\n@@ -427,146 +418,325 @@ gnu::gcj::runtime::MethodInvocation::continue1 (gnu::gcj::RawData *meth,\n */\n \n \n-#ifdef TIME_MAINLOOP\n-static jlong insn_time [256] = { 0 };\n-static jlong insn_count[256] = { 0 };\n-\n-static void\n-dump_time ()\n-{\n-  double total_all = 0;\n-  for (int i = 0; i < 256; i++)\n-    {\n-      total_all += insn_time[i];\n-    }\n-\n-  for (int i = 0; i < 256; i++)\n-    {\n-      jlong total  = insn_time[i];\n-      jlong count  = insn_count[i];\n-\n-      if (count == 0) continue;\n-\n-      jlong amount = total/count;\n-\n-      printf (\"in 0x%02x: %7Li %7Li %7Li %2.1f%%\\n\", i,\n-\t      (long long)count, (long long)total, (long long)amount,\n-\t      (float) (100.0*(double)total/total_all)\n-\t      );\n-    }\n-}\n+#ifdef __i386__\n+#define PC_REGISTER_ASM  asm(\"%esi\")\n+#else\n+#define PC_REGISTER_ASM\n #endif\n-  \n+\n void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n {\n-  _Jv_word      *sp     = inv->sp;\n-  unsigned char *pc     = inv->pc;\n-  _Jv_word      *locals = inv->local_base ();\n-  int            opcode;\n+  register _Jv_word      *sp                  = inv->sp;\n+  register unsigned char *pc PC_REGISTER_ASM  = inv->pc;\n+  _Jv_word               *locals              = inv->local_base ();\n \n-  jclass defining_class = this->defining_class;\n   _Jv_word *pool_data   = defining_class->constants.data;\n   \n   /* these two are used in the invokeXXX instructions */\n   void (*fun)(...);\n   _Jv_ResolvedMethod* rmeth;\n \n-#ifdef TIME_MAINLOOP\n-  struct timeval tv;\n-  int   last_opcode;\n-  jlong last_time;\n-  static jlong time_warp = 0;\n-\n-#define USEC(TV) \\\n-   ((jlong) (TV).tv_sec * 1000000LL + (jlong)(TV).tv_usec)\n-\n-\n-  if (time_warp == 0) \n-    {\n-      struct timeval tv2;\n-\n-      gettimeofday (&tv, 0); \n-      for (int i = 0; i < 100; i++)\n-\tgettimeofday (&tv2, 0); \n-      \n-      jlong then = USEC(tv); \n-      jlong now = USEC(tv2);\n-      time_warp = (now - then) / 100;\n-\n-      if (time_warp == 0)\n-\ttime_warp = 1;\n-    }    \n-\n-#define TIME_SUSPEND do { \\\n-  gettimeofday (&tv, 0); \\\n-  jlong now = USEC(tv); \\\n-  insn_time[last_opcode] += (now - last_time) - time_warp; \\\n-} while(0)\n-\n-#define TIME_RESUME do { \\\n-  gettimeofday (&tv, 0); \\\n-  last_time = USEC(tv); \\\n-} while(0)\n-\n-  last_opcode = 0; \n-  gettimeofday (&tv, 0); \n-  last_time = (jlong)tv.tv_sec * 1000000LL + (jlong)tv.tv_usec; \n-\n+#define INSN_LABEL(op) &&insn_##op\n+#define GOTO_INSN(op) goto *(insn_target[op])\n+\n+  static const void *const insn_target[] = \n+  {\n+    INSN_LABEL(nop),\n+    INSN_LABEL(aconst_null),\n+    INSN_LABEL(iconst_m1),\n+    INSN_LABEL(iconst_0),\n+    INSN_LABEL(iconst_1),\n+    INSN_LABEL(iconst_2),\n+    INSN_LABEL(iconst_3),\n+    INSN_LABEL(iconst_4),\n+    INSN_LABEL(iconst_5),\n+    INSN_LABEL(lconst_0),\n+    INSN_LABEL(lconst_1),\n+    INSN_LABEL(fconst_0),\n+    INSN_LABEL(fconst_1),\n+    INSN_LABEL(fconst_2),\n+    INSN_LABEL(dconst_0),\n+    INSN_LABEL(dconst_1),\n+    INSN_LABEL(bipush),\n+    INSN_LABEL(sipush),\n+    INSN_LABEL(ldc),\n+    INSN_LABEL(ldc_w),\n+    INSN_LABEL(ldc2_w),\n+    INSN_LABEL(iload),\n+    INSN_LABEL(lload),\n+    INSN_LABEL(fload),\n+    INSN_LABEL(dload),\n+    INSN_LABEL(aload),\n+    INSN_LABEL(iload_0),\n+    INSN_LABEL(iload_1),\n+    INSN_LABEL(iload_2),\n+    INSN_LABEL(iload_3),\n+    INSN_LABEL(lload_0),\n+    INSN_LABEL(lload_1),\n+    INSN_LABEL(lload_2),\n+    INSN_LABEL(lload_3),\n+    INSN_LABEL(fload_0),\n+    INSN_LABEL(fload_1),\n+    INSN_LABEL(fload_2),\n+    INSN_LABEL(fload_3),\n+    INSN_LABEL(dload_0),\n+    INSN_LABEL(dload_1),\n+    INSN_LABEL(dload_2),\n+    INSN_LABEL(dload_3),\n+    INSN_LABEL(aload_0),\n+    INSN_LABEL(aload_1),\n+    INSN_LABEL(aload_2),\n+    INSN_LABEL(aload_3),\n+    INSN_LABEL(iaload),\n+    INSN_LABEL(laload),\n+    INSN_LABEL(faload),\n+    INSN_LABEL(daload),\n+    INSN_LABEL(aaload),\n+    INSN_LABEL(baload),\n+    INSN_LABEL(caload),\n+    INSN_LABEL(saload),\n+    INSN_LABEL(istore),\n+    INSN_LABEL(lstore),\n+    INSN_LABEL(fstore),\n+    INSN_LABEL(dstore),\n+    INSN_LABEL(astore),\n+    INSN_LABEL(istore_0),\n+    INSN_LABEL(istore_1),\n+    INSN_LABEL(istore_2),\n+    INSN_LABEL(istore_3),\n+    INSN_LABEL(lstore_0),\n+    INSN_LABEL(lstore_1),\n+    INSN_LABEL(lstore_2),\n+    INSN_LABEL(lstore_3),\n+    INSN_LABEL(fstore_0),\n+    INSN_LABEL(fstore_1),\n+    INSN_LABEL(fstore_2),\n+    INSN_LABEL(fstore_3),\n+    INSN_LABEL(dstore_0),\n+    INSN_LABEL(dstore_1),\n+    INSN_LABEL(dstore_2),\n+    INSN_LABEL(dstore_3),\n+    INSN_LABEL(astore_0),\n+    INSN_LABEL(astore_1),\n+    INSN_LABEL(astore_2),\n+    INSN_LABEL(astore_3),\n+    INSN_LABEL(iastore),\n+    INSN_LABEL(lastore),\n+    INSN_LABEL(fastore),\n+    INSN_LABEL(dastore),\n+    INSN_LABEL(aastore),\n+    INSN_LABEL(bastore),\n+    INSN_LABEL(castore),\n+    INSN_LABEL(sastore),\n+    INSN_LABEL(pop),\n+    INSN_LABEL(pop2),\n+    INSN_LABEL(dup),\n+    INSN_LABEL(dup_x1),\n+    INSN_LABEL(dup_x2),\n+    INSN_LABEL(dup2),\n+    INSN_LABEL(dup2_x1),\n+    INSN_LABEL(dup2_x2),\n+    INSN_LABEL(swap),\n+    INSN_LABEL(iadd),\n+    INSN_LABEL(ladd),\n+    INSN_LABEL(fadd),\n+    INSN_LABEL(dadd),\n+    INSN_LABEL(isub),\n+    INSN_LABEL(lsub),\n+    INSN_LABEL(fsub),\n+    INSN_LABEL(dsub),\n+    INSN_LABEL(imul),\n+    INSN_LABEL(lmul),\n+    INSN_LABEL(fmul),\n+    INSN_LABEL(dmul),\n+    INSN_LABEL(idiv),\n+    INSN_LABEL(ldiv),\n+    INSN_LABEL(fdiv),\n+    INSN_LABEL(ddiv),\n+    INSN_LABEL(irem),\n+    INSN_LABEL(lrem),\n+    INSN_LABEL(frem),\n+    INSN_LABEL(drem),\n+    INSN_LABEL(ineg),\n+    INSN_LABEL(lneg),\n+    INSN_LABEL(fneg),\n+    INSN_LABEL(dneg),\n+    INSN_LABEL(ishl),\n+    INSN_LABEL(lshl),\n+    INSN_LABEL(ishr),\n+    INSN_LABEL(lshr),\n+    INSN_LABEL(iushr),\n+    INSN_LABEL(lushr),\n+    INSN_LABEL(iand),\n+    INSN_LABEL(land),\n+    INSN_LABEL(ior),\n+    INSN_LABEL(lor),\n+    INSN_LABEL(ixor),\n+    INSN_LABEL(lxor),\n+    INSN_LABEL(iinc),\n+    INSN_LABEL(i2l),\n+    INSN_LABEL(i2f),\n+    INSN_LABEL(i2d),\n+    INSN_LABEL(l2i),\n+    INSN_LABEL(l2f),\n+    INSN_LABEL(l2d),\n+    INSN_LABEL(f2i),\n+    INSN_LABEL(f2l),\n+    INSN_LABEL(f2d),\n+    INSN_LABEL(d2i),\n+    INSN_LABEL(d2l),\n+    INSN_LABEL(d2f),\n+    INSN_LABEL(i2b),\n+    INSN_LABEL(i2c),\n+    INSN_LABEL(i2s),\n+    INSN_LABEL(lcmp),\n+    INSN_LABEL(fcmpl),\n+    INSN_LABEL(fcmpg),\n+    INSN_LABEL(dcmpl),\n+    INSN_LABEL(dcmpg),\n+    INSN_LABEL(ifeq),\n+    INSN_LABEL(ifne),\n+    INSN_LABEL(iflt),\n+    INSN_LABEL(ifge),\n+    INSN_LABEL(ifgt),\n+    INSN_LABEL(ifle),\n+    INSN_LABEL(if_icmpeq),\n+    INSN_LABEL(if_icmpne),\n+    INSN_LABEL(if_icmplt),\n+    INSN_LABEL(if_icmpge),\n+    INSN_LABEL(if_icmpgt),\n+    INSN_LABEL(if_icmple),\n+    INSN_LABEL(if_acmpeq),\n+    INSN_LABEL(if_acmpne),\n+    INSN_LABEL(goto), \n+    INSN_LABEL(jsr),\n+    INSN_LABEL(ret),\n+    INSN_LABEL(tableswitch),\n+    INSN_LABEL(lookupswitch),\n+    INSN_LABEL(ireturn),\n+    INSN_LABEL(lreturn),\n+    INSN_LABEL(freturn),\n+    INSN_LABEL(dreturn),\n+    INSN_LABEL(areturn),\n+    INSN_LABEL(return),\n+    INSN_LABEL(getstatic),\n+    INSN_LABEL(putstatic),\n+    INSN_LABEL(getfield),\n+    INSN_LABEL(putfield),\n+    INSN_LABEL(invokevirtual),\n+    INSN_LABEL(invokespecial),\n+    INSN_LABEL(invokestatic),\n+    INSN_LABEL(invokeinterface),\n+    0, /* op_xxxunusedxxx1, */\n+    INSN_LABEL(new),\n+    INSN_LABEL(newarray),\n+    INSN_LABEL(anewarray),\n+    INSN_LABEL(arraylength),\n+    INSN_LABEL(athrow),\n+    INSN_LABEL(checkcast),\n+    INSN_LABEL(instanceof),\n+    INSN_LABEL(monitorenter),\n+    INSN_LABEL(monitorexit),\n+    INSN_LABEL(wide),\n+    INSN_LABEL(multianewarray),\n+    INSN_LABEL(ifnull),\n+    INSN_LABEL(ifnonnull),\n+    INSN_LABEL(goto_w),\n+    INSN_LABEL(jsr_w),\n+\n+    INSN_LABEL(putfield_1),\n+    INSN_LABEL(putfield_2),\n+    INSN_LABEL(putfield_4),\n+    INSN_LABEL(putfield_8),\n+    INSN_LABEL(putfield_a),\n+\n+    INSN_LABEL(putstatic_1),\n+    INSN_LABEL(putstatic_2),\n+    INSN_LABEL(putstatic_4),\n+    INSN_LABEL(putstatic_8),\n+    INSN_LABEL(putstatic_a),\n+\n+    INSN_LABEL(getfield_1),\n+    INSN_LABEL(getfield_2s),\n+    INSN_LABEL(getfield_2u),\n+    INSN_LABEL(getfield_4),\n+    INSN_LABEL(getfield_8),\n+    INSN_LABEL(getfield_a),\n+\n+    INSN_LABEL(getstatic_1),\n+    INSN_LABEL(getstatic_2s),\n+    INSN_LABEL(getstatic_2u),\n+    INSN_LABEL(getstatic_4),\n+    INSN_LABEL(getstatic_8),\n+    INSN_LABEL(getstatic_a),\n+  };\n+\n+#define SAVE_PC   inv->pc = pc-1\n+\n+  /* If the macro INLINE_SWITCH is not defined, then the main loop\n+     operates as one big (normal) switch statement.  If it is defined,\n+     then the case selection is performed `inline' in the end of the\n+     code for each case.  The latter saves a native branch instruction\n+     for each java-instruction, but expands the code size somewhat.\n+\n+     NOTE: On i386 defining INLINE_SWITCH improves over all\n+     performance approximately seven percent, but it may be different\n+     for other machines.  At some point, this may be made into a proper\n+     configuration parameter.  */\n+\n+#define INLINE_SWITCH \n+\n+#ifdef  INLINE_SWITCH\n+\n+#define NEXT_INSN GOTO_INSN(*pc++)\n+  NEXT_INSN;\n #else\n \n-#define TIME_SUSPEND \n-#define TIME_RESUME\n-\n-#endif\n+#define NEXT_INSN goto next_insn\n \n  next_insn:\n-  inv->pc = pc;\n-\n-#ifdef TIME_MAINLOOP\n-\n-  gettimeofday (&tv, 0); \n-  jlong now = USEC(tv); \n-  insn_time[last_opcode] += (now - last_time) - time_warp; \n-  last_time = now; \n-  last_opcode = *pc; \n-  insn_count[last_opcode] += 1;\n+  GOTO_INSN (*pc++);\n \n #endif\n-  opcode = *pc++;\n \n-  switch (opcode)\n-    {\n-    case op_aload_0:\t\t// 0x2a\n+  /* The first few instructions here are ordered according to their\n+     frequency, in the hope that this will improve code locality a\n+     little.  */\n+\n+     insn_aload_0:\t\t// 0x2a\n       LOADA(0);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_iload:\t\t// 0x15\n+     insn_iload:\t\t// 0x15\n       LOADI (get1u (pc++));\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_getfield_4:\t\t// 0xd8\n+     insn_getfield_4:\t\t// 0xd8\n+      SAVE_PC;\n       {\n \tjobject obj   = POPA();\n \tNULLCHECK(obj);\n \tjint field_offset = get2u (pc); pc += 2;\n \tPUSHI (*(jint*) ((char*)obj + field_offset));\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_iload_1:\t\t// 0x1b\n+     insn_iload_1:\t\t// 0x1b\n       LOADI (1);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_getfield_a:\t\t// 0xda\n+     insn_getfield_a:\t\t// 0xda\n+      SAVE_PC;\n       {\n \tjobject obj   = POPA();\n \tNULLCHECK(obj);\n \tjint field_offset = get2u (pc); pc += 2;\n \tPUSHA(*(jobject*) ((char*)obj + field_offset));\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_invokevirtual:\t// 0xb6\n+     insn_invokevirtual:\t// 0xb6\n+      SAVE_PC;\n       {\n \tint index = get2u (pc); pc += 2;\n \n@@ -596,17 +766,15 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n       }\n       goto perform_invoke;\n \n-    perform_invoke:\n+     perform_invoke:\n       {\n \t/* here goes the magic again... */\n \tffi_cif *cif = &rmeth->cif;\n \tffi_raw *raw = (ffi_raw*) sp;\n \n \tjdouble rvalue;\n \n-\tTIME_SUSPEND;\n \tffi_raw_call (cif, fun, (void*)&rvalue, raw);\n-\tTIME_RESUME;\n \n \tint rtype = cif->rtype->type;\n \n@@ -658,756 +826,878 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \t  case FFI_TYPE_SINT64:\n \t    PUSHL (*(jlong*)&rvalue);\n \t    break;\n-\t\n+\n \t  default:\n \t    throw_internal_error (\"unknown return type in invokeXXX\");\n \t  }\n-\t\n+\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n \n-    case op_nop:\n-      goto next_insn;\n+     insn_nop:\n+      NEXT_INSN;\n \n-    case op_aconst_null:\n+     insn_aconst_null:\n       PUSHA (NULL);\n-      goto next_insn;\n-\n-    case op_iconst_m1:\n-    case op_iconst_0:\n-    case op_iconst_1:\n-    case op_iconst_2:\n-    case op_iconst_3:\n-    case op_iconst_4:\n-    case op_iconst_5:\n-      PUSHI (opcode-op_iconst_0);\n-      goto next_insn;\n-\n-    case op_lconst_0:\n-    case op_lconst_1:\n-      PUSHL ((jlong) (opcode-op_lconst_0));\n-      goto next_insn;\n-      \n-    case op_fconst_0:\n-    case op_fconst_1:\n-    case op_fconst_2:\n-      PUSHF ((jfloat) (opcode-op_fconst_0));\n-      goto next_insn;\n-\n-    case op_dconst_0:\n-    case op_dconst_1:\n-      PUSHD ((jdouble) (opcode-op_dconst_0));\n-      goto next_insn;\n-\n-    case op_bipush:\n+      NEXT_INSN;\n+\n+     insn_iconst_m1:\n+      PUSHI (-1);\n+      NEXT_INSN;\n+\n+     insn_iconst_0:\n+      PUSHI (0);\n+      NEXT_INSN;\n+\n+     insn_iconst_1:\n+      PUSHI (1);\n+      NEXT_INSN;\n+\n+     insn_iconst_2:\n+      PUSHI (2);\n+      NEXT_INSN;\n+\n+     insn_iconst_3:\n+      PUSHI (3);\n+      NEXT_INSN;\n+\n+     insn_iconst_4:\n+      PUSHI (4);\n+      NEXT_INSN;\n+\n+     insn_iconst_5:\n+      PUSHI (5);\n+      NEXT_INSN;\n+\n+     insn_lconst_0:\n+      PUSHL (0);\n+      NEXT_INSN;\n+\n+     insn_lconst_1:\n+      PUSHL (1);\n+      NEXT_INSN;\n+\n+     insn_fconst_0:\n+      PUSHF (0);\n+      NEXT_INSN;\n+\n+     insn_fconst_1:\n+      PUSHF (1);\n+      NEXT_INSN;\n+\n+     insn_fconst_2:\n+      PUSHF (2);\n+      NEXT_INSN;\n+\n+     insn_dconst_0:\n+      PUSHD (0);\n+      NEXT_INSN;\n+\n+     insn_dconst_1:\n+      PUSHD (1);\n+      NEXT_INSN;\n+\n+     insn_bipush:\n       PUSHI (get1s(pc++));\n-      goto next_insn;\n-      \n-    case op_sipush:\n+      NEXT_INSN;\n+\n+     insn_sipush:\n       PUSHI (get2s(pc)); pc += 2;\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_ldc:\n+     insn_ldc:\n       {\n \tint index = get1u (pc++);\n \tPUSHA(pool_data[index].o);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_ldc_w:\n+     insn_ldc_w:\n       {\n \tint index = get2u (pc); pc += 2;\n \tPUSHA(pool_data[index].o);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_ldc2_w:\n+     insn_ldc2_w:\n       {\n \tint index = get2u (pc); pc += 2;\n \tmemcpy (sp, &pool_data[index], 2*sizeof (_Jv_word));\n \tsp += 2;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_lload:\n+     insn_lload:\n       LOADL (get1u (pc++));\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_fload:\n+     insn_fload:\n       LOADF (get1u (pc++));\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_dload:\n+     insn_dload:\n       LOADD (get1u (pc++));\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_aload:\n+     insn_aload:\n       LOADA (get1u (pc++));\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_iload_0:\n+     insn_iload_0:\n       LOADI (0);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_iload_2:\n+     insn_iload_2:\n       LOADI (2);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_iload_3:\n+     insn_iload_3:\n       LOADI (3);\n-      goto next_insn;\n-\n-    case op_lload_0:\n-    case op_lload_1:\n-    case op_lload_2:\n-    case op_lload_3:\n-      LOADL (opcode-op_lload_0);\n-      goto next_insn;\n-\n-    case op_fload_0:\n-    case op_fload_1:\n-    case op_fload_2:\n-    case op_fload_3:\n-      LOADF (opcode-op_fload_0);\n-      goto next_insn;\n-\n-    case op_dload_0:\n-    case op_dload_1:\n-    case op_dload_2:\n-    case op_dload_3:\n-      LOADD (opcode-op_dload_0);\n-      goto next_insn;\n-\n-    case op_aload_1:\n+      NEXT_INSN;\n+\n+     insn_lload_0:\n+      LOADL (0);\n+      NEXT_INSN;\n+\n+     insn_lload_1:\n+      LOADL (1);\n+      NEXT_INSN;\n+\n+     insn_lload_2:\n+      LOADL (2);\n+      NEXT_INSN;\n+\n+     insn_lload_3:\n+      LOADL (3);\n+      NEXT_INSN;\n+\n+     insn_fload_0:\n+      LOADF (0);\n+      NEXT_INSN;\n+\n+     insn_fload_1:\n+      LOADF (1);\n+      NEXT_INSN;\n+\n+     insn_fload_2:\n+      LOADF (2);\n+      NEXT_INSN;\n+\n+     insn_fload_3:\n+      LOADF (3);\n+      NEXT_INSN;\n+\n+     insn_dload_0:\n+      LOADD (0);\n+      NEXT_INSN;\n+\n+     insn_dload_1:\n+      LOADD (1);\n+      NEXT_INSN;\n+\n+     insn_dload_2:\n+      LOADD (2);\n+      NEXT_INSN;\n+\n+     insn_dload_3:\n+      LOADD (3);\n+      NEXT_INSN;\n+\n+     insn_aload_1:\n       LOADA(1);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_aload_2:\n+     insn_aload_2:\n       LOADA(2);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_aload_3:\n+     insn_aload_3:\n       LOADA(3);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_iaload:\n+     insn_iaload:\n+      SAVE_PC;\n       {\n \tjint index = POPI();\n \tjintArray arr = (jintArray) POPA();\n \tNULLCHECK (arr);\n \tif (index < 0 || index >= arr->length)\n- \t  {\n-\t    TIME_SUSPEND;\n+\t  {\n \t    _Jv_ThrowBadArrayIndex (index);\n \t  }\n \tPUSHI( elements(arr)[index] );\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_laload:\n+     insn_laload:\n+      SAVE_PC;\n       {\n \tjint index = POPI();\n \tjlongArray arr = (jlongArray) POPA();\n \tNULLCHECK (arr);\n \tif (index < 0 || index >= arr->length)\n- \t  {\n-\t    TIME_SUSPEND;\n+\t  {\n \t    _Jv_ThrowBadArrayIndex (index);\n \t  }\n \tPUSHL( elements(arr)[index] );\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_faload:\n+     insn_faload:\n+      SAVE_PC;\n       {\n \tjint index = POPI();\n \tjfloatArray arr = (jfloatArray) POPA();\n \tNULLCHECK (arr);\n \tif (index < 0 || index >= arr->length)\n- \t  {\n-\t    TIME_SUSPEND;\n+\t  {\n \t    _Jv_ThrowBadArrayIndex (index);\n \t  }\n \tPUSHF( elements(arr)[index] );\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_daload:\n+     insn_daload:\n+      SAVE_PC;\n       {\n \tjint index = POPI();\n \tjdoubleArray arr = (jdoubleArray) POPA();\n \tNULLCHECK (arr);\n \tif (index < 0 || index >= arr->length)\n- \t  {\n-\t    TIME_SUSPEND;\n+\t  {\n \t    _Jv_ThrowBadArrayIndex (index);\n \t  }\n \tPUSHD( elements(arr)[index] );\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_aaload:\n+     insn_aaload:\n+      SAVE_PC;\n       {\n \tjint index = POPI();\n \tjobjectArray arr = (jobjectArray) POPA();\n \tNULLCHECK (arr);\n \tif (index < 0 || index >= arr->length)\n- \t  {\n-\t    TIME_SUSPEND;\n+\t  {\n \t    _Jv_ThrowBadArrayIndex (index);\n \t  }\n \tPUSHA( elements(arr)[index] );\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_baload:\n+     insn_baload:\n+      SAVE_PC;\n       {\n \tjint index = POPI();\n \tjbyteArray arr = (jbyteArray) POPA();\n \tNULLCHECK (arr);\n \tif (index < 0 || index >= arr->length)\n- \t  {\n-\t    TIME_SUSPEND;\n+\t  {\n \t    _Jv_ThrowBadArrayIndex (index);\n \t  }\n \tPUSHI( elements(arr)[index] );\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_caload:\n+     insn_caload:\n+      SAVE_PC;\n       {\n \tjint index = POPI();\n \tjcharArray arr = (jcharArray) POPA();\n \tNULLCHECK (arr);\n \tif (index < 0 || index >= arr->length)\n- \t  {\n-\t    TIME_SUSPEND;\n+\t  {\n \t    _Jv_ThrowBadArrayIndex (index);\n \t  }\n \tPUSHI( elements(arr)[index] );\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_saload:\n+     insn_saload:\n+      SAVE_PC;\n       {\n \tjint index = POPI();\n \tjshortArray arr = (jshortArray) POPA();\n \tNULLCHECK (arr);\n \tif (index < 0 || index >= arr->length)\n- \t  {\n-\t    TIME_SUSPEND;\n+\t  {\n \t    _Jv_ThrowBadArrayIndex (index);\n \t  }\n \tPUSHI( elements(arr)[index] );\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_istore:\n+     insn_istore:\n       STOREI (get1u (pc++));\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_lstore:\n+     insn_lstore:\n       STOREL (get1u (pc++));\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_fstore:\n+     insn_fstore:\n       STOREF (get1u (pc++));\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_dstore:\n+     insn_dstore:\n       STORED (get1u (pc++));\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_astore:\n+     insn_astore:\n       STOREI (get1u (pc++));\n-      goto next_insn;\n-\n-    case op_istore_0:\n-    case op_istore_1:\n-    case op_istore_2:\n-    case op_istore_3:\n-      STOREI (opcode-op_istore_0);\n-      goto next_insn;\n-\n-    case op_lstore_0:\n-    case op_lstore_1:\n-    case op_lstore_2:\n-    case op_lstore_3:\n-      STOREL (opcode-op_lstore_0);\n-      goto next_insn;\n-\n-    case op_fstore_0:\n-    case op_fstore_1:\n-    case op_fstore_2:\n-    case op_fstore_3:\n-      STOREF (opcode-op_fstore_0);\n-      goto next_insn;\n-\n-    case op_dstore_0:\n-    case op_dstore_1:\n-    case op_dstore_2:\n-    case op_dstore_3:\n-      STORED (opcode-op_dstore_0);\n-      goto next_insn;\n-\n-    case op_astore_0:\n-    case op_astore_1:\n-    case op_astore_2:\n-    case op_astore_3:\n-      STOREA (opcode-op_astore_0);\n-      goto next_insn;\n-\n-    case op_iastore:\n+      NEXT_INSN;\n+\n+     insn_istore_0:\n+      STOREI (0);\n+      NEXT_INSN;\n+\n+     insn_istore_1:\n+      STOREI (1);\n+      NEXT_INSN;\n+\n+     insn_istore_2:\n+      STOREI (2);\n+      NEXT_INSN;\n+\n+     insn_istore_3:\n+      STOREI (3);\n+      NEXT_INSN;\n+\n+     insn_lstore_0:\n+      STOREL (0);\n+      NEXT_INSN;\n+\n+     insn_lstore_1:\n+      STOREL (1);\n+      NEXT_INSN;\n+\n+     insn_lstore_2:\n+      STOREL (2);\n+      NEXT_INSN;\n+\n+     insn_lstore_3:\n+      STOREL (3);\n+      NEXT_INSN;\n+\n+     insn_fstore_0:\n+      STOREF (0);\n+      NEXT_INSN;\n+\n+     insn_fstore_1:\n+      STOREF (1);\n+      NEXT_INSN;\n+\n+     insn_fstore_2:\n+      STOREF (2);\n+      NEXT_INSN;\n+\n+     insn_fstore_3:\n+      STOREF (3);\n+      NEXT_INSN;\n+\n+     insn_dstore_0:\n+      STORED (0);\n+      NEXT_INSN;\n+\n+     insn_dstore_1:\n+      STORED (1);\n+      NEXT_INSN;\n+\n+     insn_dstore_2:\n+      STORED (2);\n+      NEXT_INSN;\n+\n+     insn_dstore_3:\n+      STORED (3);\n+      NEXT_INSN;\n+\n+     insn_astore_0:\n+      STOREA(0);\n+      NEXT_INSN;\n+\n+     insn_astore_1:\n+      STOREA(1);\n+      NEXT_INSN;\n+\n+     insn_astore_2:\n+      STOREA(2);\n+      NEXT_INSN;\n+\n+     insn_astore_3:\n+      STOREA(3);\n+      NEXT_INSN;\n+\n+     insn_iastore:\n+      SAVE_PC;\n       {\n \tjint value = POPI();\n \tjint index  = POPI();\n \tjintArray arr = (jintArray) POPA();\n \tNULLCHECK (arr);\n \tif (index < 0 || index >= arr->length)\n- \t  {\n-\t    TIME_SUSPEND;\n+\t  {\n \t    _Jv_ThrowBadArrayIndex (index);\n \t  }\n \telements(arr)[index] = value;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_lastore:\n+     insn_lastore:\n+      SAVE_PC;\n       {\n \tjlong value = POPL();\n \tjint index  = POPI();\n \tjlongArray arr = (jlongArray) POPA();\n \tNULLCHECK (arr);\n \tif (index < 0 || index >= arr->length)\n- \t  {\n-\t    TIME_SUSPEND;\n+\t  {\n \t    _Jv_ThrowBadArrayIndex (index);\n \t  }\n \telements(arr)[index] = value;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_fastore:\n+     insn_fastore:\n+      SAVE_PC;\n       {\n \tjfloat value = POPF();\n \tjint index  = POPI();\n \tjfloatArray arr = (jfloatArray) POPA();\n \tNULLCHECK (arr);\n \tif (index < 0 || index >= arr->length)\n- \t  {\n-\t    TIME_SUSPEND;\n+\t  {\n \t    _Jv_ThrowBadArrayIndex (index);\n \t  }\n \telements(arr)[index] = value;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_dastore:\n+     insn_dastore:\n+      SAVE_PC;\n       {\n \tjdouble value = POPD();\n \tjint index  = POPI();\n \tjdoubleArray arr = (jdoubleArray) POPA();\n \tNULLCHECK (arr);\n \tif (index < 0 || index >= arr->length)\n- \t  {\n-\t    TIME_SUSPEND;\n+\t  {\n \t    _Jv_ThrowBadArrayIndex (index);\n \t  }\n \telements(arr)[index] = value;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_aastore:\n+     insn_aastore:\n+      SAVE_PC;\n       {\n \tjobject value = POPA();\n \tjint index  = POPI();\n \tjobjectArray arr = (jobjectArray) POPA();\n \tNULLCHECK (arr);\n \tif (index < 0 || index >= arr->length)\n- \t  {\n-\t    TIME_SUSPEND;\n+\t  {\n \t    _Jv_ThrowBadArrayIndex (index);\n \t  }\n \t_Jv_CheckArrayStore (arr, value);\n \telements(arr)[index] = value;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_bastore:\n+     insn_bastore:\n+      SAVE_PC;\n       {\n \tjbyte value = (jbyte) POPI();\n \tjint index  = POPI();\n \tjbyteArray arr = (jbyteArray) POPA();\n \tNULLCHECK (arr);\n \tif (index < 0 || index >= arr->length)\n- \t  {\n-\t    TIME_SUSPEND;\n+\t  {\n \t    _Jv_ThrowBadArrayIndex (index);\n \t  }\n \telements(arr)[index] = value;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_castore:\n+     insn_castore:\n+      SAVE_PC;\n       {\n \tjchar value = (jchar) POPI();\n \tjint index  = POPI();\n \tjcharArray arr = (jcharArray) POPA();\n \tNULLCHECK (arr);\n \tif (index < 0 || index >= arr->length)\n- \t  {\n-\t    TIME_SUSPEND;\n+\t  {\n \t    _Jv_ThrowBadArrayIndex (index);\n \t  }\n \telements(arr)[index] = value;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_sastore:\n+     insn_sastore:\n+      SAVE_PC;\n       {\n \tjshort value = (jshort) POPI();\n \tjint index  = POPI();\n \tjshortArray arr = (jshortArray) POPA();\n \tNULLCHECK (arr);\n \tif (index < 0 || index >= arr->length)\n- \t  {\n-\t    TIME_SUSPEND;\n+\t  {\n \t    _Jv_ThrowBadArrayIndex (index);\n \t  }\n \telements(arr)[index] = value;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_pop:\n+     insn_pop:\n       sp -= 1;\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_pop2:\n+     insn_pop2:\n       sp -= 2;\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_dup:\n+     insn_dup:\n       sp[0] = sp[-1];\n       sp += 1;\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_dup_x1:\n-      dupx (sp, 1, 1);\n-      goto next_insn;\n+     insn_dup_x1:\n+      dupx (sp, 1, 1); sp+=1;\n+      NEXT_INSN;\n \n-    case op_dup_x2:\n-      dupx (sp, 1, 2);\n-      goto next_insn;\n+     insn_dup_x2:\n+      dupx (sp, 1, 2); sp+=1;\n+      NEXT_INSN;\n \n-    case op_dup2:\n+     insn_dup2:\n       sp[0] = sp[-2];\n       sp[1] = sp[-1];\n       sp += 2;\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_dup2_x1:\n-      dupx (sp, 2, 1);\n-      goto next_insn;\n+     insn_dup2_x1:\n+      dupx (sp, 2, 1); sp+=2;\n+      NEXT_INSN;\n \n-    case op_dup2_x2:\n-      dupx (sp, 2, 2);\n-      goto next_insn;\n+     insn_dup2_x2:\n+      dupx (sp, 2, 2); sp+=2;\n+      NEXT_INSN;\n \n-    case op_swap:\n+     insn_swap:\n       {\n \tjobject tmp1 = POPA();\n \tjobject tmp2 = POPA();\n \tPUSHA (tmp1);\n \tPUSHA (tmp2);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_iadd:\n+     insn_iadd:\n       BINOPI(+);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_ladd:\n+     insn_ladd:\n       BINOPL(+);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_fadd:\n+     insn_fadd:\n       BINOPF(+);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_dadd:\n+     insn_dadd:\n       BINOPD(+);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_isub:\n+     insn_isub:\n       BINOPI(-);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_lsub:\n+     insn_lsub:\n       BINOPL(-);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_fsub:\n+     insn_fsub:\n       BINOPF(-);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_dsub:\n+     insn_dsub:\n       BINOPD(-);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_imul:\n+     insn_imul:\n       BINOPI(*);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_lmul:\n+     insn_lmul:\n       BINOPL(*);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_fmul:\n+     insn_fmul:\n       BINOPF(*);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_dmul:\n+     insn_dmul:\n       BINOPD(*);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_idiv:\n+     insn_idiv:\n+      SAVE_PC;\n       {\n \tjint value2 = POPI();\n \tjint value1 = POPI();\n \tZEROCHECK (value2);\n \tjint res = value1 / value2;\n \tPUSHI (res);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_ldiv:\n-       {\n+     insn_ldiv:\n+      SAVE_PC;\n+      {\n \tjlong value2 = POPL();\n \tjlong value1 = POPL();\n \tZEROCHECK (value2);\n \tjlong res = value1 / value2;\n \tPUSHL (res);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_fdiv:\n+     insn_fdiv:\n+      SAVE_PC;\n       {\n \tjfloat value2 = POPF();\n \tjfloat value1 = POPF();\n \tZEROCHECK (value2);\n \tjfloat res = value1 / value2;\n \tPUSHF (res);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_ddiv:\n+     insn_ddiv:\n+      SAVE_PC;\n       {\n \tjdouble value2 = POPD();\n \tjdouble value1 = POPD();\n \tZEROCHECK (value2);\n \tjdouble res = value1 / value2;\n \tPUSHD (res);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_irem:\n+     insn_irem:\n+      SAVE_PC;\n       {\n \tjint value2 = POPI();\n \tjint value1 = POPI();\n \tZEROCHECK (value2);\t\n \tjint res = value1 % value2;\n \tPUSHI (res);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_lrem:\n-       {\n+     insn_lrem:\n+      SAVE_PC;\n+      {\n \tjlong value2 = POPL();\n \tjlong value1 = POPL();\n \tZEROCHECK (value2);\n \tjlong res = value1 % value2;\n \tPUSHL (res);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_frem:\n+     insn_frem:\n+      SAVE_PC;\n       {\n \tjfloat value2 = POPF();\n \tjfloat value1 = POPF();\n \tZEROCHECK (value2);\n \tjfloat res    = __ieee754_fmod (value1, value2);\n \tPUSHF (res);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_drem:\n+     insn_drem:\n+      SAVE_PC;\n       {\n \tjdouble value2 = POPD();\n \tjdouble value1 = POPD();\n \tZEROCHECK (value2);\n \tjdouble res    = __ieee754_fmod (value1, value2);\n \tPUSHD (res);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_ineg:\n-      *(jint*) (sp-1) *= -1;\n-      goto next_insn;\n+     insn_ineg:\n+      {\n+\tjint value = POPI();\n+\tPUSHI (value * -1);\n+      }\n+      NEXT_INSN;\n \n-    case op_lneg:\n-      *(jlong*) (sp-1) *= -1;\n-      goto next_insn;\n+     insn_lneg:\n+      {\n+\tjlong value = POPL();\n+\tPUSHL (value * -1);\n+      }\n+      NEXT_INSN;\n \n-    case op_fneg:\n-      *(jfloat*) (sp-1) *= -1;\n-      goto next_insn;\n+     insn_fneg:\n+      {\n+\tjfloat value = POPF();\n+\tPUSHF (value * -1);\n+      }\n+      NEXT_INSN;\n \n-    case op_dneg:\n-      *(jdouble*) (sp-1) *= -1;\n-      goto next_insn;\n+     insn_dneg:\n+      {\n+\tjdouble value = POPD();\n+\tPUSHD (value * -1);\n+      }\n+      NEXT_INSN;\n \n-    case op_ishl:\n+     insn_ishl:\n       {\n \tjint shift = (POPI() & 0x1f);\n \tjint value = POPI();\n \tPUSHI (value << shift);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_lshl:\n+     insn_lshl:\n       {\n \tjint shift = (POPI() & 0x3f);\n \tjlong value = POPL();\n \tPUSHL (value << shift);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_ishr:\n+     insn_ishr:\n       {\n \tjint shift = (POPI() & 0x1f);\n \tjint value = POPI();\n \tPUSHI (value >> shift);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_lshr:\n+     insn_lshr:\n       {\n \tjint shift = (POPI() & 0x3f);\n \tjlong value = POPL();\n \tPUSHL (value >> shift);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_iushr:\n+     insn_iushr:\n       {\n \tjint shift = (POPI() & 0x1f);\n \tunsigned long value = POPI();\n \tPUSHI ((jint) (value >> shift));\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_lushr:\n+     insn_lushr:\n       {\n \tjint shift = (POPI() & 0x3f);\n \tUINT64 value = (UINT64) POPL();\n \tPUSHL ((value >> shift));\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_iand:\n+     insn_iand:\n       BINOPI (&);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_land:\n+     insn_land:\n       BINOPL (&);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_ior:\n+     insn_ior:\n       BINOPI (|);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_lor:\n+     insn_lor:\n       BINOPL (|);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_ixor:\n+     insn_ixor:\n       BINOPI (^);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_lxor:\n+     insn_lxor:\n       BINOPL (^);\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_iinc:\n+     insn_iinc:\n       {\n \tjint index  = get1u (pc++);\n \tjint amount = get1s (pc++);\n-\t*(jint*) (locals + index) += amount;\n+\tlocals[index].i += amount;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_i2l:\n+     insn_i2l:\n       {jlong value = POPI(); PUSHL (value);}\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_i2f:\n+     insn_i2f:\n       {jfloat value = POPI(); PUSHF (value);}\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_i2d:\n+     insn_i2d:\n       {jdouble value = POPI(); PUSHD (value);}\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_l2i:\n+     insn_l2i:\n       {jint value = POPL(); PUSHI (value);}\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_l2f:\n+     insn_l2f:\n       {jfloat value = POPL(); PUSHF (value);}\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_l2d:\n+     insn_l2d:\n       {jdouble value = POPL(); PUSHD (value);}\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_f2i:\n+     insn_f2i:\n       { jint value = (jint)POPF (); PUSHI(value); }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_f2l:\n+     insn_f2l:\n       { jlong value = (jlong)POPF (); PUSHL(value); }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_f2d:\n+     insn_f2d:\n       { jdouble value = POPF (); PUSHD(value); }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_d2i:\n+     insn_d2i:\n       { jint value = (jint)POPD (); PUSHI(value); }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_d2l:\n+     insn_d2l:\n       { jlong value = (jlong)POPD (); PUSHL(value); }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_d2f:\n+     insn_d2f:\n       { jfloat value = POPD (); PUSHF(value); }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_i2b:\n+     insn_i2b:\n       { jbyte value = POPI (); PUSHI(value); }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_i2c:\n+     insn_i2c:\n       { jchar value = POPI (); PUSHI(value); }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_i2s:\n+     insn_i2s:\n       { jshort value = POPI (); PUSHI(value); }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_lcmp:\n+     insn_lcmp:\n       {\n \tjlong value2 = POPL ();\n \tjlong value1 = POPL ();\n@@ -1418,10 +1708,10 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \telse\n \t  { PUSHI (-1); }\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_fcmpl:\n-    case op_fcmpg:\n+     insn_fcmpl:\n+     insn_fcmpg:\n       {\n \tjfloat value2 = POPF ();\n \tjfloat value1 = POPF ();\n@@ -1431,15 +1721,15 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \t  PUSHI (0);\n \telse if (value1 < value2)\n \t  PUSHI (-1);\n-\telse if (opcode == op_fcmpg)\n+\telse if ((*(pc-1)) == op_fcmpg)\n \t  PUSHI (1);\n \telse\n \t  PUSHI (-1);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_dcmpl:\n-    case op_dcmpg:\n+     insn_dcmpl:\n+     insn_dcmpg:\n       {\n \tjdouble value2 = POPD ();\n \tjdouble value1 = POPD ();\n@@ -1449,74 +1739,74 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \t  PUSHI (0);\n \telse if (value1 < value2)\n \t  PUSHI (-1);\n-\telse if (opcode == op_dcmpg)\n+\telse if ((*(pc-1)) == op_dcmpg)\n \t  PUSHI (1);\n \telse\n \t  PUSHI (-1);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_ifeq:\n+     insn_ifeq:\n       {\n \tjint offset = get2s (pc); \n \tif (POPI() == 0)\n \t  pc = pc-1+offset;\n \telse\n \t  pc = pc+2;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_ifne:\n+     insn_ifne:\n       {\n \tjint offset = get2s (pc); \n \tif (POPI() != 0)\n \t  pc = pc-1+offset;\n \telse\n \t  pc = pc+2;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_iflt:\n+     insn_iflt:\n       {\n \tjint offset = get2s (pc); \n \tif (POPI() < 0)\n \t  pc = pc-1+offset;\n \telse\n \t  pc = pc+2;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_ifge:\n+     insn_ifge:\n       {\n \tjint offset = get2s (pc); \n \tif (POPI() >= 0)\n \t  pc = pc-1+offset;\n \telse\n \t  pc = pc+2;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_ifgt:\n+     insn_ifgt:\n       {\n \tjint offset = get2s (pc); \n \tif (POPI() > 0)\n \t  pc = pc-1+offset;\n \telse\n \t  pc = pc+2;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_ifle:\n+     insn_ifle:\n       {\n \tjint offset = get2s (pc); \n \tif (POPI() <= 0)\n \t  pc = pc-1+offset;\n \telse\n \t  pc = pc+2;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_if_icmpeq:\n+     insn_if_icmpeq:\n       {\n \tjint offset = get2s (pc); \n \tjint value2 = POPI();\n@@ -1526,9 +1816,9 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \telse\n \t  pc = pc+2;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_if_icmpne:\n+     insn_if_icmpne:\n       {\n \tjint offset = get2s (pc); \n \tjint value2 = POPI();\n@@ -1538,9 +1828,9 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \telse\n \t  pc = pc+2;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_if_icmplt:\n+     insn_if_icmplt:\n       {\n \tjint offset = get2s (pc); \n \tjint value2 = POPI();\n@@ -1550,9 +1840,9 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \telse\n \t  pc = pc+2;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_if_icmpge:\n+     insn_if_icmpge:\n       {\n \tjint offset = get2s (pc); \n \tjint value2 = POPI();\n@@ -1562,9 +1852,9 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \telse\n \t  pc = pc+2;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_if_icmpgt:\n+     insn_if_icmpgt:\n       {\n \tjint offset = get2s (pc); \n \tjint value2 = POPI();\n@@ -1574,9 +1864,9 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \telse\n \t  pc = pc+2;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_if_icmple:\n+     insn_if_icmple:\n       {\n \tjint offset = get2s (pc); \n \tjint value2 = POPI();\n@@ -1586,9 +1876,9 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \telse\n \t  pc = pc+2;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_if_acmpeq:\n+     insn_if_acmpeq:\n       {\n \tjint offset = get2s (pc); \n \tjobject value2 = POPA();\n@@ -1598,9 +1888,9 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \telse\n \t  pc = pc+2;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_if_acmpne:\n+     insn_if_acmpne:\n       {\n \tjint offset = get2s (pc); \n \tjobject value2 = POPA();\n@@ -1610,36 +1900,36 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \telse\n \t  pc = pc+2;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_goto: \n+     insn_goto: \n       {\n \tjint offset = get2s (pc);\n \tpc = pc-1+offset;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_jsr:\n+     insn_jsr:\n       {\n \tunsigned char *base_pc = pc-1;\n \tjint offset = get2s (pc); pc += 2;\n \tPUSHA ((jobject)pc);\n \tpc = base_pc+offset;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_ret:\n+     insn_ret:\n       {\n \tjint index = get1u (pc);\n \tpc = (unsigned char*) PEEKA (index);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_tableswitch:\n+     insn_tableswitch:\n       {\n \tunsigned char *base_pc = pc-1;\n \tint index = POPI();\n-\t\n+\n \tunsigned char* base = bytecode ();\n \twhile ((pc-base) % 4 != 0)\n \t  pc++;\n@@ -1653,20 +1943,20 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \telse\n \t  pc = base_pc + get4 (pc+4*(index-low+3));\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_lookupswitch:\n+     insn_lookupswitch:\n       {\n \tunsigned char *base_pc = pc-1;\n \tint index = POPI();\n-\t\n+\n \tunsigned char* base = bytecode ();\n \twhile ((pc-base) % 4 != 0)\n \t  pc++;\n-\t\n+\n \tjint def     = get4 (pc);\n \tjint npairs  = get4 (pc+4);\n-\t\n+\n \tint max = npairs-1;\n \tint min = 0;\n \n@@ -1681,30 +1971,30 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \n \t    else if (index < match)\n \t      max = half-1;\n-\t    \n+\n \t    else\n \t      min = half+1;\n \t  }\n-\t\n+\n \tif (index == get4 (pc+ 4*(2 + 2*min)))\n \t  pc = base_pc + get4 (pc+ 4*(2 + 2*min + 1));\n \telse\n \t  pc = base_pc + def;    \n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n       /* on return, just save the sp and return to caller */\n-    case op_ireturn:\n-    case op_lreturn:\n-    case op_freturn:\n-    case op_dreturn:\n-    case op_areturn:\n-    case op_return:\n+     insn_ireturn:\n+     insn_lreturn:\n+     insn_freturn:\n+     insn_dreturn:\n+     insn_areturn:\n+     insn_return:\n       inv->sp = sp;\n-      TIME_SUSPEND;\n       return;\n \n-    case op_getstatic:\n+     insn_getstatic:\n+      SAVE_PC;\n       {\n \tunsigned char *base_pc = pc-1;\n \tjint fieldref_index = get2u (pc); pc += 2;\n@@ -1724,7 +2014,7 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \t      case 1:\n \t\t*base_pc = op_getstatic_1;\n \t\tbreak;\n-\t    \n+\n \t      case 2:\n \t\tif (type == JvPrimClass (char))\n \t\t  *base_pc = op_getstatic_2u;\n@@ -1745,12 +2035,13 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \t  {\n \t    *base_pc = op_getstatic_a;\n \t  }\n-\t\n+\n \tpc = base_pc;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_getfield:\n+     insn_getfield:\n+      SAVE_PC;\n       {\n \tunsigned char *base_pc = pc-1;\n \tjint fieldref_index = get2u (pc); pc += 2;\n@@ -1770,7 +2061,7 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \t      case 1:\n \t\t*base_pc = op_getfield_1;\n \t\tbreak;\n-\t    \n+\n \t      case 2:\n \t\tif (type == JvPrimClass (char))\n \t\t  *base_pc = op_getfield_2u;\n@@ -1791,7 +2082,7 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \t  {\n \t    *base_pc = op_getfield_a;\n \t  }\n-\t\n+\n \tif (field->u.boffset > 0xffff)\n \t  JvThrow (new java::lang::VirtualMachineError);\n \n@@ -1800,9 +2091,10 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \n \tpc = base_pc;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_putstatic:\n+     insn_putstatic:\n+      SAVE_PC;\n       {\n \tunsigned char* base_pc = pc-1;\n \tjint fieldref_index = get2u (pc); pc += 2;\n@@ -1830,11 +2122,11 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \t      case 2:\n \t\t*base_pc = op_putstatic_2;\n \t\tbreak;\n-\t\t\n+\n \t      case 4:\n \t\t*base_pc = op_putstatic_4;\n \t\tbreak;\n-\t\t\n+\n \t      case 8:\n \t\t*base_pc = op_putstatic_8;\n \t\tbreak;\n@@ -1848,10 +2140,11 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \t// do the instruction again!\n \tpc = base_pc;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n \n-    case op_putfield:\n+     insn_putfield:\n+      SAVE_PC;\n       {\n \tunsigned char* base_pc = pc-1;\n \tjint fieldref_index = get2u (pc); pc += 2;\n@@ -1899,216 +2192,228 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \t// do the instruction again!\n \tpc = base_pc;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n \n-    case op_getfield_1:\n+     insn_getfield_1:\n+      SAVE_PC;\n       {\n \tjobject obj   = POPA();\n \tNULLCHECK(obj);\n \tjint field_offset = get2u (pc); pc += 2;\n \tPUSHI (*(jbyte*) ((char*)obj + field_offset));\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_getfield_2s:\n+     insn_getfield_2s:\n+      SAVE_PC;\n       {\n \tjobject obj   = POPA();\n \tNULLCHECK(obj);\n \tjint field_offset = get2u (pc); pc += 2;\n \tPUSHI (*(jshort*) ((char*)obj + field_offset));\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_getfield_2u:\n+     insn_getfield_2u:\n+      SAVE_PC;\n       {\n \tjobject obj   = POPA();\n \tNULLCHECK(obj);\n \tjint field_offset = get2u (pc); pc += 2;\n \tPUSHI (*(jchar*) ((char*)obj + field_offset));\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_getfield_8:\n+     insn_getfield_8:\n+      SAVE_PC;\n       {\n \tjobject obj   = POPA();\n \tNULLCHECK(obj);\n \tjint field_offset = get2u (pc); pc += 2;\n \tPUSHL(*(jlong*) ((char*)obj + field_offset));\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_getstatic_1:\n+     insn_getstatic_1:\n       {\n \tjint fieldref_index = get2u (pc); pc += 2;\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n \tPUSHI (*(jbyte*) (field->u.addr));\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_getstatic_2s:\n+     insn_getstatic_2s:\n       {\n \tjint fieldref_index = get2u (pc); pc += 2;\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n \tPUSHI(*(jshort*) (field->u.addr));\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_getstatic_2u:\n+     insn_getstatic_2u:\n       {\n \tjint fieldref_index = get2u (pc); pc += 2;\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n \tPUSHI(*(jchar*) (field->u.addr));\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_getstatic_4:\n+     insn_getstatic_4:\n       {\n \tjint fieldref_index = get2u (pc); pc += 2;\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n \tPUSHI(*(jint*) (field->u.addr));\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_getstatic_8:\n+     insn_getstatic_8:\n       {\n \tjint fieldref_index = get2u (pc); pc += 2;\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n \tPUSHL(*(jlong*) (field->u.addr));\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_getstatic_a:\n+     insn_getstatic_a:\n       {\n \tjint fieldref_index = get2u (pc); pc += 2;\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n \tPUSHA(*(jobject*) (field->u.addr));\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_putfield_1:\n+     insn_putfield_1:\n+      SAVE_PC;\n       {\n \tjint    value = POPI();\n \tjobject obj   = POPA();\n \tNULLCHECK(obj);\n \tjint field_offset = get2u (pc); pc += 2;\n \t*(jbyte*) ((char*)obj + field_offset) = value;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_putfield_2:\n+     insn_putfield_2:\n+      SAVE_PC;\n       {\n \tjint    value = POPI();\n \tjobject obj   = POPA();\n \tNULLCHECK(obj);\n \tjint field_offset = get2u (pc); pc += 2;\n \t*(jchar*) ((char*)obj + field_offset) = value;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_putfield_4:\n+     insn_putfield_4:\n+      SAVE_PC;\n       {\n \tjint    value = POPI();\n \tjobject obj   = POPA();\n \tNULLCHECK(obj);\n \tjint field_offset = get2u (pc); pc += 2;\n \t*(jint*) ((char*)obj + field_offset) = value;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_putfield_8:\n+     insn_putfield_8:\n+      SAVE_PC;\n       {\n \tjlong   value = POPL();\n \tjobject obj   = POPA();\n \tNULLCHECK(obj);\n \tjint field_offset = get2u (pc); pc += 2;\n \t*(jlong*) ((char*)obj + field_offset) = value;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_putfield_a:\n+     insn_putfield_a:\n+      SAVE_PC;\n       {\n \tjobject value = POPA();\n \tjobject obj   = POPA();\n \tNULLCHECK(obj);\n \tjint field_offset = get2u (pc); pc += 2;\n \t*(jobject*) ((char*)obj + field_offset) = value;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_putstatic_1:\n+     insn_putstatic_1:\n       {\n \tjint    value = POPI();\n \tjint fieldref_index = get2u (pc); pc += 2;\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n \t*(jbyte*) (field->u.addr) = value;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_putstatic_2:\n+     insn_putstatic_2:\n       {\n \tjint    value = POPI();\n \tjint fieldref_index = get2u (pc); pc += 2;\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n \t*(jchar*) (field->u.addr) = value;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_putstatic_4:\n+     insn_putstatic_4:\n       {\n \tjint    value = POPI();\n \tjint fieldref_index = get2u (pc); pc += 2;\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n \t*(jint*) (field->u.addr) = value;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_putstatic_8:\n+     insn_putstatic_8:\n       {\n \tjlong    value = POPL();\n \tjint fieldref_index = get2u (pc); pc += 2;\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n \t*(jlong*) (field->u.addr) = value;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_putstatic_a:\n+     insn_putstatic_a:\n       {\n \tjobject value = POPA();\n \tjint fieldref_index = get2u (pc); pc += 2;\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n \t*(jobject*) (field->u.addr) = value;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_invokespecial:\n+     insn_invokespecial:\n+      SAVE_PC;\n       {\n \tint index = get2u (pc); pc += 2;\n \n \trmeth = (_Jv_ResolvePoolEntry (defining_class, index)).rmethod;\n \n \tsp -= rmeth->stack_item_count;\n-\t\n+\n \tNULLCHECK(sp[0]);\n \n \tfun = (void (*) (...))rmeth->method->ncode;\n       }\n       goto perform_invoke;\n \n-    case op_invokestatic:\n+     insn_invokestatic:\n+      SAVE_PC;\n       {\n \tint index = get2u (pc); pc += 2;\n \n \trmeth = (_Jv_ResolvePoolEntry (defining_class, index)).rmethod;\n \n \tsp -= rmeth->stack_item_count;\n-\t\n+\n \t_Jv_InitClass (rmeth->klass);\n \tfun = (void (*) (...))rmeth->method->ncode;\n       }\n       goto perform_invoke;\n \n-    case op_invokeinterface:\n+     insn_invokeinterface:\n+      SAVE_PC;\n       {\n \tint index = get2u (pc); pc += 2;\n \n@@ -2119,7 +2424,7 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \n \tsp -= rmeth->stack_item_count;\n \tNULLCHECK(sp[0]);\n-\t\n+\n \tjobject rcv = sp[0].o;\n \n \tfun = (void (*) (...))\n@@ -2130,26 +2435,29 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n       goto perform_invoke;\n \n \n-    case op_new:\n+     insn_new:\n+      SAVE_PC;\n       {\n \tint index = get2u (pc); pc += 2;\n \tjclass klass = (_Jv_ResolvePoolEntry (defining_class, index)).clazz;\n \t_Jv_InitClass (klass);\n \tjobject res = _Jv_AllocObject (klass, klass->size_in_bytes);\n \tPUSHA (res);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_newarray:\n+     insn_newarray:\n+      SAVE_PC;\n       {\n \tint atype = get1u (pc++);\n \tint size  = POPI();\n \tjobject result = _Jv_NewArray (atype, size);\n \tPUSHA (result);\n       }\n-      goto next_insn;\n-      \n-    case op_anewarray:\n+      NEXT_INSN;\n+\n+     insn_anewarray:\n+      SAVE_PC;\n       {\n \tint index = get2u (pc); pc += 2;\n \tjclass klass = (_Jv_ResolvePoolEntry (defining_class, index)).clazz;\n@@ -2158,86 +2466,91 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \tjobject result = _Jv_NewObjectArray (size, klass, 0);\n \tPUSHA (result);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_arraylength:\n+     insn_arraylength:\n+      SAVE_PC;\n       {\n \t__JArray *arr = (__JArray*)POPA();\n \tPUSHI (arr->length);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_athrow:\n+     insn_athrow:\n+      SAVE_PC;\n       {\n \tjobject value = POPA();\n-\tTIME_SUSPEND;\n \tJvThrow (value);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_checkcast:\n+     insn_checkcast:\n+      SAVE_PC;\n       {\n \tjobject value = POPA();\n \tjint index = get2u (pc); pc += 2;\n \tjclass to = (_Jv_ResolvePoolEntry (defining_class, index)).clazz;\n \n \tif (value != NULL && ! to->isInstance (value))\n \t  {\n-\t    TIME_SUSPEND;\n \t    JvThrow (new java::lang::ClassCastException\n \t\t     (to->getName()));\n \t  }\n \n \tPUSHA (value);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_instanceof:\n+     insn_instanceof:\n+      SAVE_PC;\n       {\n \tjobject value = POPA();\n \tjint index = get2u (pc); pc += 2;\n \tjclass to = (_Jv_ResolvePoolEntry (defining_class, index)).clazz;\n \tPUSHI (to->isInstance (value));\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_monitorenter:\n+     insn_monitorenter:\n+      SAVE_PC;\n       {\n \tjobject value = POPA();\n \tNULLCHECK(value);\n \t_Jv_MonitorEnter (value);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_monitorexit:\n+     insn_monitorexit:\n+      SAVE_PC;\n       {\n \tjobject value = POPA();\n \tNULLCHECK(value);\n \t_Jv_MonitorExit (value);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_ifnull:\n+     insn_ifnull:\n       {\n \tunsigned char* base_pc = pc-1;\n \tjint offset = get2s (pc); pc += 2;\n \tjobject val = POPA();\n \tif (val == NULL)\n \t  pc = base_pc+offset;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_ifnonnull:\n+     insn_ifnonnull:\n       {\n \tunsigned char* base_pc = pc-1;\n \tjint offset = get2s (pc); pc += 2;\n \tjobject val = POPA();\n \tif (val != NULL)\n \t  pc = base_pc+offset;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_wide:\n+     insn_wide:\n+      SAVE_PC;\n       {\n \tjint the_mod_op = get1u (pc++);\n \tjint wide       = get2u (pc); pc += 2;\n@@ -2246,59 +2559,60 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \t  {\n \t  case op_istore:\n \t    STOREI (wide);\n-\t    goto next_insn;\n+\t    NEXT_INSN;\n \n \t  case op_fstore:\n \t    STOREF (wide);\n-\t    goto next_insn;\n+\t    NEXT_INSN;\n \n \t  case op_astore:\n \t    STOREA (wide);\n-\t    goto next_insn;\n+\t    NEXT_INSN;\n \n \t  case op_lload:\n \t    LOADL (wide);\n-\t    goto next_insn;\n+\t    NEXT_INSN;\n \n \t  case op_dload:\n \t    LOADD (wide);\n-\t    goto next_insn;\n+\t    NEXT_INSN;\n \n \t  case op_iload:\n \t    LOADI (wide);\n-\t    goto next_insn;\n+\t    NEXT_INSN;\n \n \t  case op_aload:\n \t    LOADA (wide);\n-\t    goto next_insn;\n+\t    NEXT_INSN;\n \n \t  case op_lstore:\n \t    STOREL (wide);\n-\t    goto next_insn;\n+\t    NEXT_INSN;\n \n \t  case op_dstore:\n \t    STORED (wide);\n-\t    goto next_insn;\n+\t    NEXT_INSN;\n \n \t  case op_ret:\n \t    pc = (unsigned char*) PEEKA (wide);\n-\t    goto next_insn;\n+\t    NEXT_INSN;\n \n \t  case op_iinc:\n \t    {\n \t      jint amount = get2s (pc); pc += 2;\n \t      jint value = PEEKI (wide);\n \t      POKEI (wide, value+amount);\n \t    }\n-\t    goto next_insn;\n+\t    NEXT_INSN;\n \n \t  default:\n \t    throw_internal_error (\"illegal bytecode modified by wide\");\n \t  }\n \n       }\n \n-    case op_multianewarray:\n+     insn_multianewarray:\n+      SAVE_PC;\n       {\n \tint kind_index = get2u (pc); pc += 2;\n \tint dim        = get1u (pc); pc += 1;\n@@ -2312,35 +2626,29 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \t  {\n \t    sizes[i] = POPI ();\n \t  }\n-\t\n+\n \tjobject res    = _Jv_NewMultiArray (type,dim, sizes);\n-\t\n+\n \tPUSHA (res);\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_goto_w:\n+     insn_goto_w:\n       {\n \tunsigned char* base_pc = pc-1;\n \tint offset = get4 (pc); pc += 4;\n \tpc = base_pc+offset;\n       }\n-      goto next_insn;\n+      NEXT_INSN;\n \n-    case op_jsr_w:\n+     insn_jsr_w:\n       {\n \tunsigned char* base_pc = pc-1;\n \tint offset = get4 (pc); pc += 4;\n \tPUSHA((jobject)pc);\n \tpc = base_pc+offset;\n       }\n-      goto next_insn;\n-\n-    default:\n-      throw_internal_error (\"opcode not implemented\");\n-\n-    }\n-  goto next_insn;\n+      NEXT_INSN;\n }\n \n \n@@ -2381,57 +2689,5 @@ throw_arithmetic_exception ()\n }\n #endif\n \n-void\n-jvdump(jobject o)\n-{\n-  _Jv_InterpMethod::dump_object(o);\n-}\n-\n-/* FIXME: This is not finished! */\n-void\n-_Jv_InterpMethod::dump_object(jobject o)\n-{\n-  java::io::PrintStream *out = java::lang::System::out;\n-\n-  if (o == NULL)\n-    {\n-      out->println (JvNewStringLatin1 (\"<null>\"));\n-      return;\n-    }\n-\n-  jclass klass = o->getClass ();\n-\n-  out->print (klass->getName ());\n-  out->print (JvNewStringLatin1 (\"@0x\"));\n-  out->print (java::lang::Integer::toHexString ((jint)o));\n-  out->print (JvNewStringLatin1 (\"{\"));\n-#if 0\n-  while (klass && klass != &ObjectClass)\n-    {\n-      _Jv_Field *fields = klass->fields;\n-      int max           = klass->field_count;\n-      \n-      for (int i = 0; i < max; ++i)\n-\t{\n-\t  out->print (_Jv_NewStringUTF (field->name->data));\n-\t  out->print (JvNewStringLatin1 (\"=\"));\n-\n-\t  if (JvFieldIsRef (field))\n-\t    {\n-\t      if (field->flags & STATIC)\n-\t\tout->print (JvGetSt)\n-\t    }\n-\t  field = field->getNextInstanceField ();\n-\n-\t  if (i+1 < max && klass->getSuperclass () != null)\n-\t    out->print (JvNewStringLatin1 (\"; \"));\n-\t}\n-\n-      klass = klass->getSuperclass();\n-    }\n-#endif\n-  out->print (JvNewStringLatin1 (\"}\\n\"));\n-\n-}\n \n #endif // INTERPRETER"}, {"sha": "28a70e7b7e4fe84de3c22332dcef7af4be921fef", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7b4fb110a587d13e6f203716b2ab5f326065934/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7b4fb110a587d13e6f203716b2ab5f326065934/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=f7b4fb110a587d13e6f203716b2ab5f326065934", "patch": "@@ -220,9 +220,9 @@ static const int ALL_FLAGS    = 0x7FF;\n \n \n /** This function does class-preparation for compiled classes.  \n-    NOTE: This function replicates functionality from\n+    NOTE: It contains replicated functionality from\n     _Jv_ResolvePoolEntry, and this is intentional, since that function\n-    is \n+    lives in resolve.cc which is entirely conditionally compiled.\n  */\n void\n _Jv_PrepareCompiledClass(jclass klass)\n@@ -253,17 +253,8 @@ _Jv_PrepareCompiledClass(jclass klass)\n \t      JvThrow (new java::lang::ClassNotFoundException (str));\n \t    }\n \n-\t  if ((found->accflags & PUBLIC) == PUBLIC\n-\t      || (_Jv_ClassNameSamePackage (found->name,\n-\t\t\t\t\t    klass->name)))\n-\t    {\n-\t      pool->data[index].clazz = found;\n-\t      pool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n-\t    }\n-\t  else\n-\t    {\n-\t      JvThrow (new java::lang::IllegalAccessError (found->getName()));\n-\t    }\n+\t  pool->data[index].clazz = found;\n+\t  pool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n \t}\n \t    \n       else if (pool->tags[index] == JV_CONSTANT_String)"}]}