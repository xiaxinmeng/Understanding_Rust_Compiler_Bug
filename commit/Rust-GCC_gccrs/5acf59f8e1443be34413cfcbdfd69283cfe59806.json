{"sha": "5acf59f8e1443be34413cfcbdfd69283cfe59806", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFjZjU5ZjhlMTQ0M2JlMzQ0MTNjZmNiZGZkNjkyODNjZmU1OTgwNg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2002-07-04T07:25:19Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2002-07-04T07:25:19Z"}, "message": "std_memory.h: Fix formatting.\n\n\n2002-07-03  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/std/std_memory.h: Fix formatting.\n\t* testsuite/20_util/auto_ptr_neg.cc: New.\n\t* testsuite/20_util/auto_ptr.cc: Tweaks.\n\t* testsuite/23_containers/map_operators.cc (test01): Split into..\n\t* testsuite/23_containers/map_operators_neg.cc (test01): ...this. New.\n\t* testsuite/23_containers/set_operators.cc: Move to...\n\t* testsuite/23_containers/set_operators_neg.cc: ...here.\n\t* testsuite/README: Add some more naming rules.\n\nFrom-SVN: r55241", "tree": {"sha": "60350f86dc3036055250c2a58694a248890ea633", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/60350f86dc3036055250c2a58694a248890ea633"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5acf59f8e1443be34413cfcbdfd69283cfe59806", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5acf59f8e1443be34413cfcbdfd69283cfe59806", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5acf59f8e1443be34413cfcbdfd69283cfe59806", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5acf59f8e1443be34413cfcbdfd69283cfe59806/comments", "author": null, "committer": null, "parents": [{"sha": "7c0f8bc1f452111b4d14282790fe2887550aaffd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c0f8bc1f452111b4d14282790fe2887550aaffd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c0f8bc1f452111b4d14282790fe2887550aaffd"}], "stats": {"total": 746, "additions": 401, "deletions": 345}, "files": [{"sha": "d2ddff24217551881df727788f625f16494111dd", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5acf59f8e1443be34413cfcbdfd69283cfe59806/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5acf59f8e1443be34413cfcbdfd69283cfe59806/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5acf59f8e1443be34413cfcbdfd69283cfe59806", "patch": "@@ -1,3 +1,14 @@\n+2002-07-03  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/std/std_memory.h: Fix formatting.\n+\t* testsuite/20_util/auto_ptr_neg.cc: New.\n+\t* testsuite/20_util/auto_ptr.cc: Tweaks.\n+\t* testsuite/23_containers/map_operators.cc (test01): Split into..\n+\t* testsuite/23_containers/map_operators_neg.cc (test01): ...this. New.\n+\t* testsuite/23_containers/set_operators.cc: Move to...\n+\t* testsuite/23_containers/set_operators_neg.cc: ...here.\t\n+\t* testsuite/README: Add some more naming rules.\n+\t\n 2002-07-03  Steev Wilcox  <steev@paradigmds.com>\n \t \n \tPR libstdc++/7057"}, {"sha": "47c3ede8995d477a3658f7d1244d40eb19345fe5", "filename": "libstdc++-v3/include/std/std_memory.h", "status": "modified", "additions": 271, "deletions": 284, "changes": 555, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5acf59f8e1443be34413cfcbdfd69283cfe59806/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5acf59f8e1443be34413cfcbdfd69283cfe59806/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_memory.h?ref=5acf59f8e1443be34413cfcbdfd69283cfe59806", "patch": "@@ -58,314 +58,301 @@\n #include <bits/stl_uninitialized.h>\n #include <bits/stl_raw_storage_iter.h>\n \n-// Since this entire file is within namespace std, there's no reason to\n-// waste two spaces along the left column.  Thus the leading indentation is\n-// slightly violated from here on.\n namespace std\n {\n-/**\n- *  @if maint\n- *  This is a helper function.  The unused second parameter exists to\n- *  permit the real get_temporary_buffer to use template parameter deduction.\n- *\n- *  XXX This should perhaps use the pool.\n- *  @endif\n-*/\n-template <typename _Tp>\n-pair<_Tp*, ptrdiff_t>\n-__get_temporary_buffer(ptrdiff_t __len, _Tp*)\n-{\n-  if (__len > ptrdiff_t(INT_MAX / sizeof(_Tp)))\n-    __len = INT_MAX / sizeof(_Tp);\n-\n-  while (__len > 0) {\n-    _Tp* __tmp = (_Tp*) std::malloc((std::size_t)__len * sizeof(_Tp));\n-    if (__tmp != 0)\n-      return pair<_Tp*, ptrdiff_t>(__tmp, __len);\n-    __len /= 2;\n-  }\n-\n-  return pair<_Tp*, ptrdiff_t>((_Tp*)0, 0);\n-}\n-\n-/**\n- *  @brief This is a mostly-useless wrapper around malloc().\n- *  @param  len  The number of objects of type Tp.\n- *  @return   See full description.\n- *\n- *  Reinventing the wheel, but this time with prettier spokes!\n- *\n- *  This function tries to obtain storage for @c len adjacent Tp objects.\n- *  The objects themselves are not constructed, of course.  A pair<> is\n- *  returned containing \"the buffer s address and capacity (in the units of\n- *  sizeof(Tp)), or a pair of 0 values if no storage can be obtained.\"\n- *  Note that the capacity obtained may be less than that requested if the\n- *  memory is unavailable; you should compare len with the .second return\n- *  value.\n-*/\n-template<typename _Tp>\n-  inline pair<_Tp*,ptrdiff_t>\n-  get_temporary_buffer(ptrdiff_t __len)\n-  {\n-    return __get_temporary_buffer(__len, (_Tp*) 0);\n-  }\n-\n-/**\n- *  @brief The companion to get_temporary_buffer().\n- *  @param  p  A buffer previously allocated by get_temporary_buffer.\n- *  @return   None.\n- *\n- *  Frees the memory pointed to by p.\n- */\n-template<typename _Tp>\n-  void\n-  return_temporary_buffer(_Tp* __p)\n-  {\n-    std::free(__p);\n-  }\n-\n-\n-/**\n- *  A wrapper class to provide auto_ptr with reference semantics.  For\n- *  example, an auto_ptr can be assigned (or constructed from) the result of\n- *  a function which returns an auto_ptr by value.\n- *\n- *  All the auto_ptr_ref stuff should happen behind the scenes.\n-*/\n-template<typename _Tp1>\n-  struct auto_ptr_ref\n-{\n-   _Tp1* _M_ptr;\n-\n-   explicit\n-   auto_ptr_ref(_Tp1* __p)\n-   : _M_ptr(__p) {}\n-};\n-\n-\n-/**\n- *  @brief  A simple smart pointer providing strict ownership semantics.\n- *\n- *  The Standard says:\n- *  <pre>\n- *  An @c auto_ptr owns the object it holds a pointer to.  Copying an\n- *  @c auto_ptr copies the pointer and transfers ownership to the destination.\n- *  If more than one @c auto_ptr owns the same object at the same time the\n- *  behavior of the program is undefined.\n- *\n- *  The uses of @c auto_ptr include providing temporary exception-safety for\n- *  dynamically allocated memory, passing ownership of dynamically allocated\n- *  memory to a function, and returning dynamically allocated memory from a\n- *  function.  @c auto_ptr does not meet the CopyConstructible and Assignable\n- *  requirements for Standard Library <a href=\"tables.html#65\">container</a>\n- *  elements and thus instantiating a Standard Library container with an\n- *  @c auto_ptr results in undefined behavior.\n- *  </pre>\n- *  Quoted from [20.4.5]/3.\n- *\n- *  Good examples of what can and cannot be done with auto_ptr can be found\n- *  in the libstdc++ testsuite.\n- *\n- *  @if maint\n- *  _GLIBCPP_RESOLVE_LIB_DEFECTS\n- *  127.  auto_ptr<> conversion issues\n- *  These resolutions have all been incorporated.\n- *  @endif\n-*/\n-template<typename _Tp>\n-  class auto_ptr\n-{\n-private:\n-  _Tp* _M_ptr;\n-\n-public:\n-  /// The pointed-to type.\n-  typedef _Tp element_type;\n-\n   /**\n-   *  @brief  An %auto_ptr is usually constructed from a raw pointer.\n-   *  @param  p  A pointer (defaults to NULL).\n-   *\n-   *  This object now @e owns the object pointed to by @a p.\n-  */\n-  explicit\n-  auto_ptr(element_type* __p = 0) throw()\n-  : _M_ptr(__p) { }\n-\n-  /**\n-   *  @brief  An %auto_ptr can be constructed from another %auto_ptr.\n-   *  @param  a  Another %auto_ptr of the same type.\n-   *\n-   *  This object now @e owns the object previously owned by @a a, which has\n-   *  given up ownsership.\n-  */\n-  auto_ptr(auto_ptr& __a) throw()\n-  : _M_ptr(__a.release()) { }\n-\n-  /**\n-   *  @brief  An %auto_ptr can be constructed from another %auto_ptr.\n-   *  @param  a  Another %auto_ptr of a different but related type.\n-   *\n-   *  A pointer-to-Tp1 must be convertible to a pointer-to-Tp/element_type.\n-   *\n-   *  This object now @e owns the object previously owned by @a a, which has\n-   *  given up ownsership.\n-  */\n-  template<typename _Tp1>\n-    auto_ptr(auto_ptr<_Tp1>& __a) throw()\n-    : _M_ptr(__a.release()) { }\n-\n-  /**\n-   *  @brief  %auto_ptr assignment operator.\n-   *  @param  a  Another %auto_ptr of the same type.\n+   *  @if maint\n+   *  This is a helper function.  The unused second parameter exists to\n+   *  permit the real get_temporary_buffer to use template parameter deduction.\n    *\n-   *  This object now @e owns the object previously owned by @a a, which has\n-   *  given up ownsership.  The object that this one @e used to own and\n-   *  track has been deleted.\n-  */\n-  auto_ptr&\n-  operator=(auto_ptr& __a) throw()\n+   *  XXX This should perhaps use the pool.\n+   *  @endif\n+   */\n+  template<typename _Tp>\n+    pair<_Tp*, ptrdiff_t>\n+    __get_temporary_buffer(ptrdiff_t __len, _Tp*)\n     {\n-      reset(__a.release());\n-      return *this;\n+      if (__len > ptrdiff_t(INT_MAX / sizeof(_Tp)))\n+\t__len = INT_MAX / sizeof(_Tp);\n+      \n+      while (__len > 0) \n+\t{\n+\t  _Tp* __tmp = (_Tp*) std::malloc((std::size_t)__len * sizeof(_Tp));\n+\t  if (__tmp != 0)\n+\t    return pair<_Tp*, ptrdiff_t>(__tmp, __len);\n+\t  __len /= 2;\n+\t}\n+      return pair<_Tp*, ptrdiff_t>((_Tp*)0, 0);\n     }\n \n   /**\n-   *  @brief  %auto_ptr assignment operator.\n-   *  @param  a  Another %auto_ptr of a different but related type.\n+   *  @brief This is a mostly-useless wrapper around malloc().\n+   *  @param  len  The number of objects of type Tp.\n+   *  @return   See full description.\n    *\n-   *  A pointer-to-Tp1 must be convertible to a pointer-to-Tp/element_type.\n+   *  Reinventing the wheel, but this time with prettier spokes!\n    *\n-   *  This object now @e owns the object previously owned by @a a, which has\n-   *  given up ownsership.  The object that this one @e used to own and\n-   *  track has been deleted.\n-  */\n-  template <typename _Tp1>\n-    auto_ptr&\n-    operator=(auto_ptr<_Tp1>& __a) throw()\n-    {\n-      reset(__a.release());\n-      return *this;\n-    }\n+   *  This function tries to obtain storage for @c len adjacent Tp objects.\n+   *  The objects themselves are not constructed, of course.  A pair<> is\n+   *  returned containing \"the buffer s address and capacity (in the units of\n+   *  sizeof(Tp)), or a pair of 0 values if no storage can be obtained.\"\n+   *  Note that the capacity obtained may be less than that requested if the\n+   *  memory is unavailable; you should compare len with the .second return\n+   *  value.\n+   */\n+  template<typename _Tp>\n+    inline pair<_Tp*,ptrdiff_t>\n+    get_temporary_buffer(ptrdiff_t __len)\n+    { return __get_temporary_buffer(__len, (_Tp*) 0); }\n \n   /**\n-   *  When the %auto_ptr goes out of scope, the object it owns is deleted.\n-   *  If it no longer owns anything (i.e., @c get() is @c NULL), then this\n-   *  has no effect.\n+   *  @brief The companion to get_temporary_buffer().\n+   *  @param  p  A buffer previously allocated by get_temporary_buffer.\n+   *  @return   None.\n    *\n-   *  @if maint\n-   *  The C++ standard says there is supposed to be an empty throw\n-   *  specification here, but omitting it is standard conforming.  Its\n-   *  presence can be detected only if _Tp::~_Tp() throws, but this is\n-   *  prohibited.  [17.4.3.6]/2\n-   *  @end maint\n-  */\n-  ~auto_ptr() { delete _M_ptr; }\n+   *  Frees the memory pointed to by p.\n+   */\n+  template<typename _Tp>\n+    void\n+    return_temporary_buffer(_Tp* __p)\n+    { std::free(__p); }\n \n   /**\n-   *  @brief  Smart pointer dereferencing.\n+   *  A wrapper class to provide auto_ptr with reference semantics.  For\n+   *  example, an auto_ptr can be assigned (or constructed from) the result of\n+   *  a function which returns an auto_ptr by value.\n    *\n-   *  If this %auto_ptr no longer owns anything, then this operation will\n-   *  crash.  (For a smart pointer, \"no longer owns anything\" is the same as\n-   *  being a null pointer, and you know what happens when you dereference\n-   *  one of those...)\n-  */\n-  element_type&\n-  operator*() const throw() { return *_M_ptr; }\n+   *  All the auto_ptr_ref stuff should happen behind the scenes.\n+   */\n+  template<typename _Tp1>\n+    struct auto_ptr_ref\n+    {\n+      _Tp1* _M_ptr;\n+      \n+      explicit\n+      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }\n+    };\n \n-  /**\n-   *  @brief  Smart pointer dereferencing.\n-   *\n-   *  This returns the pointer itself, which the language then will\n-   *  automatically cause to be dereferenced.\n-  */\n-  element_type*\n-  operator->() const throw() { return _M_ptr; }\n \n   /**\n-   *  @brief  Bypassing the smart pointer.\n-   *  @return  The raw pointer being managed.\n+   *  @brief  A simple smart pointer providing strict ownership semantics.\n    *\n-   *  You can get a copy of the pointer that this object owns, for\n-   *  situations such as passing to a function which only accepts a raw\n-   *  pointer.\n+   *  The Standard says:\n+   *  <pre>\n+   *  An @c auto_ptr owns the object it holds a pointer to.  Copying an\n+   *  @c auto_ptr copies the pointer and transfers ownership to the destination.\n+   *  If more than one @c auto_ptr owns the same object at the same time the\n+   *  behavior of the program is undefined.\n    *\n-   *  @note  This %auto_ptr still owns the memory.\n-  */\n-  element_type*\n-  get() const throw() { return _M_ptr; }\n-\n-  /**\n-   *  @brief  Bypassing the smart pointer.\n-   *  @return  The raw pointer being managed.\n+   *  The uses of @c auto_ptr include providing temporary exception-safety for\n+   *  dynamically allocated memory, passing ownership of dynamically allocated\n+   *  memory to a function, and returning dynamically allocated memory from a\n+   *  function.  @c auto_ptr does not meet the CopyConstructible and Assignable\n+   *  requirements for Standard Library <a href=\"tables.html#65\">container</a>\n+   *  elements and thus instantiating a Standard Library container with an\n+   *  @c auto_ptr results in undefined behavior.\n+   *  </pre>\n+   *  Quoted from [20.4.5]/3.\n    *\n-   *  You can get a copy of the pointer that this object owns, for\n-   *  situations such as passing to a function which only accepts a raw\n-   *  pointer.\n+   *  Good examples of what can and cannot be done with auto_ptr can be found\n+   *  in the libstdc++ testsuite.\n    *\n-   *  @note  This %auto_ptr no longer owns the memory.  When this object\n-   *  goes out of scope, nothing will happen.\n-  */\n-  element_type*\n-  release() throw()\n-    {\n-      element_type* __tmp = _M_ptr;\n-      _M_ptr = 0;\n-      return __tmp;\n-    }\n-\n-  /**\n-   *  @brief  Forcibly deletes the managed object.\n-   *  @param  p  A pointer (defaults to NULL).\n-   *\n-   *  This object now @e owns the object pointed to by @a p.  The previous\n-   *  object has been deleted.\n-  */\n-  void\n-  reset(element_type* __p = 0) throw()\n-    {\n-      if (__p != _M_ptr)\n-        {\n-          delete _M_ptr;\n-          _M_ptr = __p;\n-        }\n-    }\n-\n-  /** @{\n-   *  @brief  Automatic conversions\n-   *\n-   *  These operations convert an %auto_ptr into and from an auto_ptr_ref\n-   *  automatically as needed.  This allows constructs such as\n-   *  @code\n-   *    auto_ptr<Derived>  func_returning_auto_ptr(.....);\n-   *    ...\n-   *    auto_ptr<Base> ptr = func_returning_auto_ptr(.....);\n-   *  @endcode\n-  */\n-  auto_ptr(auto_ptr_ref<element_type> __ref) throw()\n-    : _M_ptr(__ref._M_ptr) {}\n-\n-  auto_ptr&\n-  operator=(auto_ptr_ref<element_type> __ref) throw()\n+   *  @if maint\n+   *  _GLIBCPP_RESOLVE_LIB_DEFECTS\n+   *  127.  auto_ptr<> conversion issues\n+   *  These resolutions have all been incorporated.\n+   *  @endif\n+   */\n+  template<typename _Tp>\n+    class auto_ptr\n     {\n-      if (__ref._M_ptr != this->get())\n+    private:\n+      _Tp* _M_ptr;\n+      \n+    public:\n+      /// The pointed-to type.\n+      typedef _Tp element_type;\n+      \n+      /**\n+       *  @brief  An %auto_ptr is usually constructed from a raw pointer.\n+       *  @param  p  A pointer (defaults to NULL).\n+       *\n+       *  This object now @e owns the object pointed to by @a p.\n+       */\n+      explicit\n+      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }\n+\n+      /**\n+       *  @brief  An %auto_ptr can be constructed from another %auto_ptr.\n+       *  @param  a  Another %auto_ptr of the same type.\n+       *\n+       *  This object now @e owns the object previously owned by @a a,\n+       *  which has given up ownsership.\n+       */\n+      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }\n+\n+      /**\n+       *  @brief  An %auto_ptr can be constructed from another %auto_ptr.\n+       *  @param  a  Another %auto_ptr of a different but related type.\n+       *\n+       *  A pointer-to-Tp1 must be convertible to a pointer-to-Tp/element_type.\n+       *\n+       *  This object now @e owns the object previously owned by @a a,\n+       *  which has given up ownsership.\n+       */\n+      template<typename _Tp1>\n+        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }\n+\n+      /**\n+       *  @brief  %auto_ptr assignment operator.\n+       *  @param  a  Another %auto_ptr of the same type.\n+       *\n+       *  This object now @e owns the object previously owned by @a a,\n+       *  which has given up ownsership.  The object that this one @e\n+       *  used to own and track has been deleted.\n+       */\n+      auto_ptr&\n+      operator=(auto_ptr& __a) throw()\n+      {\n+\treset(__a.release());\n+\treturn *this;\n+      }\n+\n+      /**\n+       *  @brief  %auto_ptr assignment operator.\n+       *  @param  a  Another %auto_ptr of a different but related type.\n+       *\n+       *  A pointer-to-Tp1 must be convertible to a pointer-to-Tp/element_type.\n+       *\n+       *  This object now @e owns the object previously owned by @a a,\n+       *  which has given up ownsership.  The object that this one @e\n+       *  used to own and track has been deleted.\n+       */\n+      template<typename _Tp1>\n+        auto_ptr&\n+        operator=(auto_ptr<_Tp1>& __a) throw()\n         {\n-          delete _M_ptr;\n-          _M_ptr = __ref._M_ptr;\n-        }\n-      return *this;\n-    }\n-\n-  template<typename _Tp1>\n-    operator auto_ptr_ref<_Tp1>() throw()\n-      { return auto_ptr_ref<_Tp1>(this->release()); }\n-\n-  template<typename _Tp1>\n-    operator auto_ptr<_Tp1>() throw()\n-      { return auto_ptr<_Tp1>(this->release()); }\n-  /** @}  */\n-};\n-\n+\t  reset(__a.release());\n+\t  return *this;\n+\t}\n+\n+      /**\n+       *  When the %auto_ptr goes out of scope, the object it owns is deleted.\n+       *  If it no longer owns anything (i.e., @c get() is @c NULL), then this\n+       *  has no effect.\n+       *\n+       *  @if maint\n+       *  The C++ standard says there is supposed to be an empty throw\n+       *  specification here, but omitting it is standard conforming.  Its\n+       *  presence can be detected only if _Tp::~_Tp() throws, but this is\n+       *  prohibited.  [17.4.3.6]/2\n+       *  @end maint\n+       */\n+      ~auto_ptr() { delete _M_ptr; }\n+      \n+      /**\n+       *  @brief  Smart pointer dereferencing.\n+       *\n+       *  If this %auto_ptr no longer owns anything, then this\n+       *  operation will crash.  (For a smart pointer, \"no longer owns\n+       *  anything\" is the same as being a null pointer, and you know\n+       *  what happens when you dereference one of those...)\n+       */\n+      element_type&\n+      operator*() const throw() { return *_M_ptr; }\n+      \n+      /**\n+       *  @brief  Smart pointer dereferencing.\n+       *\n+       *  This returns the pointer itself, which the language then will\n+       *  automatically cause to be dereferenced.\n+       */\n+      element_type*\n+      operator->() const throw() { return _M_ptr; }\n+      \n+      /**\n+       *  @brief  Bypassing the smart pointer.\n+       *  @return  The raw pointer being managed.\n+       *\n+       *  You can get a copy of the pointer that this object owns, for\n+       *  situations such as passing to a function which only accepts a raw\n+       *  pointer.\n+       *\n+       *  @note  This %auto_ptr still owns the memory.\n+       */\n+      element_type*\n+      get() const throw() { return _M_ptr; }\n+      \n+      /**\n+       *  @brief  Bypassing the smart pointer.\n+       *  @return  The raw pointer being managed.\n+       *\n+       *  You can get a copy of the pointer that this object owns, for\n+       *  situations such as passing to a function which only accepts a raw\n+       *  pointer.\n+       *\n+       *  @note  This %auto_ptr no longer owns the memory.  When this object\n+       *  goes out of scope, nothing will happen.\n+       */\n+      element_type*\n+      release() throw()\n+      {\n+\telement_type* __tmp = _M_ptr;\n+\t_M_ptr = 0;\n+\treturn __tmp;\n+      }\n+      \n+      /**\n+       *  @brief  Forcibly deletes the managed object.\n+       *  @param  p  A pointer (defaults to NULL).\n+       *\n+       *  This object now @e owns the object pointed to by @a p.  The previous\n+       *  object has been deleted.\n+       */\n+      void\n+      reset(element_type* __p = 0) throw()\n+      {\n+\tif (__p != _M_ptr)\n+\t  {\n+\t    delete _M_ptr;\n+\t    _M_ptr = __p;\n+\t  }\n+      }\n+      \n+      /** @{\n+       *  @brief  Automatic conversions\n+       *\n+       *  These operations convert an %auto_ptr into and from an auto_ptr_ref\n+       *  automatically as needed.  This allows constructs such as\n+       *  @code\n+       *    auto_ptr<Derived>  func_returning_auto_ptr(.....);\n+       *    ...\n+       *    auto_ptr<Base> ptr = func_returning_auto_ptr(.....);\n+       *  @endcode\n+       */\n+      auto_ptr(auto_ptr_ref<element_type> __ref) throw()\n+      : _M_ptr(__ref._M_ptr) { }\n+      \n+      auto_ptr&\n+      operator=(auto_ptr_ref<element_type> __ref) throw()\n+      {\n+\tif (__ref._M_ptr != this->get())\n+\t  {\n+\t    delete _M_ptr;\n+\t    _M_ptr = __ref._M_ptr;\n+\t  }\n+\treturn *this;\n+      }\n+      \n+      template<typename _Tp1>\n+        operator auto_ptr_ref<_Tp1>() throw()\n+        { return auto_ptr_ref<_Tp1>(this->release()); }\n+\n+      template<typename _Tp1>\n+        operator auto_ptr<_Tp1>() throw()\n+        { return auto_ptr<_Tp1>(this->release()); }\n+      /** @}  */\n+  };\n } // namespace std\n \n-#endif /* _CPP_MEMORY */\n+#endif "}, {"sha": "a6dd1c699918921bda974383f5bd0e8b1affa5ea", "filename": "libstdc++-v3/testsuite/20_util/auto_ptr.cc", "status": "modified", "additions": 6, "deletions": 36, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5acf59f8e1443be34413cfcbdfd69283cfe59806/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5acf59f8e1443be34413cfcbdfd69283cfe59806/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr.cc?ref=5acf59f8e1443be34413cfcbdfd69283cfe59806", "patch": "@@ -84,10 +84,6 @@ test01()\n   VERIFY( B::ctor_count == 1 );\n   VERIFY( B::dtor_count == 0 );\n \n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n-\n   return 0;\n }\n \n@@ -112,10 +108,6 @@ test02()\n   VERIFY( B::ctor_count == 1 );\n   VERIFY( B::dtor_count == 0 );\n \n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n-\n   return 0;\n }\n \n@@ -142,10 +134,6 @@ test03()\n   VERIFY( B::ctor_count == 1 );\n   VERIFY( B::dtor_count == 0 );\n \n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n-\n   return 0;\n }\n \n@@ -167,10 +155,6 @@ test04()\n   VERIFY( B::ctor_count == 2 );\n   VERIFY( B::dtor_count == 2 );\n \n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n-\n   return 0;\n }\n \n@@ -196,11 +180,6 @@ test05()\n   VERIFY( A::dtor_count == 2 );\n   VERIFY( B::ctor_count == 1 );\n   VERIFY( B::dtor_count == 1 );\n-\n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n-\n   return 0;\n }\n \n@@ -232,11 +211,6 @@ test06()\n   VERIFY( A_from_A_ptr.get() != A_ptr );\n   VERIFY( A_from_A_ptr->ctor_count == 2 );\n   VERIFY( (*A_from_A_ptr).dtor_count == 1 );\n-\n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n-\n   return 0;\n }\n \n@@ -268,20 +242,16 @@ test07()\n   VERIFY( A::dtor_count == 2 );\n   VERIFY( B::ctor_count == 1 );\n   VERIFY( B::dtor_count == 1 );\n-\n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n-\n   return 0;\n }\n \n-\n+// libstdc++/3946\n // http://gcc.gnu.org/ml/libstdc++/2002-07/msg00024.html\n-struct Base{};\n-struct Derived : public Base {};\n-std::auto_ptr<Derived> conversiontest08()\n-  { return std::auto_ptr<Derived>(new Derived); }\n+struct Base { };\n+struct Derived : public Base { };\n+\n+std::auto_ptr<Derived> \n+conversiontest08() { return std::auto_ptr<Derived>(new Derived); }\n \n void\n test08()"}, {"sha": "ff39a0d24d57056576f619c7c195211d7bb12f12", "filename": "libstdc++-v3/testsuite/20_util/auto_ptr_neg.cc", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5acf59f8e1443be34413cfcbdfd69283cfe59806/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5acf59f8e1443be34413cfcbdfd69283cfe59806/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr_neg.cc?ref=5acf59f8e1443be34413cfcbdfd69283cfe59806", "patch": "@@ -0,0 +1,50 @@\n+// Copyright (C) 2002 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.5 Template class auto_ptr negative tests [lib.auto.ptr]\n+\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+// { dg-do compile }\n+// { dg-excess-errors \"\" }\n+\n+// via Jack Reeves <jack_reeves@hispeed.ch>\n+// libstdc++/3946\n+// http://gcc.gnu.org/ml/libstdc++/2002-07/msg00024.html\n+struct Base { };\n+struct Derived : public Base { };\n+\n+std::auto_ptr<Derived> \n+foo() { return std::auto_ptr<Derived>(new Derived); }\n+\n+int\n+test01()\n+{\n+  std::auto_ptr<Base> ptr2;\n+  ptr2 = new Base; // { dg-error \"no\" \"candidates\" \"auto_ptr\"} \n+  return 0;\n+}\n+\n+int \n+main()\n+{\n+  test01();\n+\n+  return 0;\n+}"}, {"sha": "47604deb4a867ad65b5421bef9bcc8e875b9d13c", "filename": "libstdc++-v3/testsuite/23_containers/map_operators.cc", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5acf59f8e1443be34413cfcbdfd69283cfe59806/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap_operators.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5acf59f8e1443be34413cfcbdfd69283cfe59806/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap_operators.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap_operators.cc?ref=5acf59f8e1443be34413cfcbdfd69283cfe59806", "patch": "@@ -24,25 +24,7 @@\n #include <string>\n #include <iostream>\n \n-// { dg-do compile }\n-\n-// libstdc++/86: map & set iterator comparisons are not type-safe\n-void test01()\n-{\n-  bool test = true;\n-  std::map<unsigned int, int> mapByIndex;\n-  std::map<std::string, unsigned> mapByName;\n-  \n-  mapByIndex.insert(std::pair<unsigned, int>(0, 1));\n-  mapByIndex.insert(std::pair<unsigned, int>(6, 5));\n-  \n-  std::map<unsigned, int>::iterator itr(mapByIndex.begin());\n-\n-  // NB: notice, it's not mapByIndex!!\n-  test &= itr != mapByName.end(); // { dg-error \"no\" } \n-  test &= itr == mapByName.end(); // { dg-error \"no\" } \n-}\n- \n+// libstdc++/737\n // http://gcc.gnu.org/ml/libstdc++/2000-11/msg00093.html\n void test02()\n {\n@@ -53,17 +35,15 @@ void test02()\n   for (unsigned i=0;i<10;++i)\n     m.insert(MapInt::value_type(i,i));\n   \n-  for (MapInt::const_iterator i=m.begin();i!=m.end();++i)\n+  for (MapInt::const_iterator i = m.begin(); i != m.end(); ++i)\n     std::cerr << i->second << ' ';\n   \n-  for (MapInt::const_iterator i=m.begin();m.end()!=i;++i)\n+  for (MapInt::const_iterator i = m.begin(); m.end() != i; ++i)\n     std::cerr << i->second << ' ';\n }\n \n int main()\n {\n-  test01();\n   test02();\n-\n   return 0;\n }"}, {"sha": "75b604c80c24dbb86a86250d71e1f047714dea6f", "filename": "libstdc++-v3/testsuite/23_containers/map_operators_neg.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5acf59f8e1443be34413cfcbdfd69283cfe59806/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap_operators_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5acf59f8e1443be34413cfcbdfd69283cfe59806/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap_operators_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap_operators_neg.cc?ref=5acf59f8e1443be34413cfcbdfd69283cfe59806", "patch": "@@ -0,0 +1,49 @@\n+// 2000-09-07 bgarcia@laurelnetworks.com\n+\n+// Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.3.4 template class multiset negative tests\n+\n+#include <map>\n+#include <string>\n+\n+// { dg-do compile }\n+\n+// libstdc++/86: map & set iterator comparisons are not type-safe\n+void test01()\n+{\n+  bool test = true;\n+  std::map<unsigned int, int> mapByIndex;\n+  std::map<std::string, unsigned> mapByName;\n+  \n+  mapByIndex.insert(std::pair<unsigned, int>(0, 1));\n+  mapByIndex.insert(std::pair<unsigned, int>(6, 5));\n+  \n+  std::map<unsigned, int>::iterator itr(mapByIndex.begin());\n+\n+  // NB: notice, it's not mapByIndex!!\n+  test &= itr != mapByName.end(); // { dg-error \"no\" } \n+  test &= itr == mapByName.end(); // { dg-error \"no\" } \n+}\n+ \n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "c3c23741e2e6e32fafab9c2e82f4cbc47c9970e8", "filename": "libstdc++-v3/testsuite/23_containers/set_operators_neg.cc", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5acf59f8e1443be34413cfcbdfd69283cfe59806/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset_operators_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5acf59f8e1443be34413cfcbdfd69283cfe59806/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset_operators_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset_operators_neg.cc?ref=5acf59f8e1443be34413cfcbdfd69283cfe59806", "patch": "@@ -1,6 +1,6 @@\n // 2000-09-07 bgarcia@laurelnetworks.com\n \n-// Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -18,7 +18,7 @@\n // Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n // USA.\n \n-// 23.3.4 template class multiset\n+// 23.3.4 template class multiset negative tests\n \n #include <set>\n #include <string>", "previous_filename": "libstdc++-v3/testsuite/23_containers/set_operators.cc"}, {"sha": "07ff9fef4f888d4cef1ec7e402c3e343747fde9b", "filename": "libstdc++-v3/testsuite/README", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5acf59f8e1443be34413cfcbdfd69283cfe59806/libstdc%2B%2B-v3%2Ftestsuite%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5acf59f8e1443be34413cfcbdfd69283cfe59806/libstdc%2B%2B-v3%2Ftestsuite%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2FREADME?ref=5acf59f8e1443be34413cfcbdfd69283cfe59806", "patch": "@@ -24,6 +24,15 @@ that, the naming seems mostly consistent. If the file exists, add a\n test to it. If it does not, then create a new file. All files are\n copyright the FSF, and GPL'd: this is very important. \n \n+In addition, some of the locale and io code tests different\n+instantiating types: thus, 'char' or 'wchar_t' is appended to the name\n+as constructed above.\n+\n+Also, some test files are negative tests. That is, they are supposed\n+to fail (usually this involves making sure some kind of construct gets\n+an error when it's compiled.) These test files have 'neg' appended to\n+the name as constructed above.\n+\n Inside a test file, the plan is to test the relevant parts of the\n standard, and then add specific regressions as additional test\n functions, ie test04() can represent a specific regression noted in"}]}