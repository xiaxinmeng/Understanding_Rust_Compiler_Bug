{"sha": "f877b3adba2d9442752721d87c96f93beccd4c40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg3N2IzYWRiYTJkOTQ0Mjc1MjcyMWQ4N2M5NmY5M2JlY2NkNGM0MA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-02-13T08:54:02Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-02-13T08:54:02Z"}, "message": "isl.m4: Remove support for ISL 0.14.\n\n2017-02-13  Richard Biener  <rguenther@suse.de>\n\n\tconfig/\n\t* isl.m4: Remove support for ISL 0.14.\n\n\t* configure: Re-generate.\n\n\tgcc/\n\t* configure.ac (HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS):\n\tRemove.\n\t* configure: Re-generate.\n\t* config.in: Likewise.\n\t* graphite-dependences.c: Simplify as if\n\tHAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS was defined.\n\t* graphite-isl-ast-to-gimple.c: Likewise.\n\t* graphite-optimize-isl.c: Likewise.\n\t* graphite-poly.c: Likewise.\n\t* graphite-sese-to-poly.c: Likewise.\n\t* graphite.h: Likewise.\n\t* toplev.c: Include isl/version.h and use isl_version () for\n\tprinting the ISL version.\n\t* doc/install.texi: Update ISL requirement.\n\nFrom-SVN: r245382", "tree": {"sha": "4a2ee5ee6c3f117960b3f1a517bbaa4fb3747ef6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a2ee5ee6c3f117960b3f1a517bbaa4fb3747ef6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f877b3adba2d9442752721d87c96f93beccd4c40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f877b3adba2d9442752721d87c96f93beccd4c40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f877b3adba2d9442752721d87c96f93beccd4c40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f877b3adba2d9442752721d87c96f93beccd4c40/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c0d46793e8e05b2e68395512383f688eeea8dae2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0d46793e8e05b2e68395512383f688eeea8dae2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0d46793e8e05b2e68395512383f688eeea8dae2"}], "stats": {"total": 1018, "additions": 41, "deletions": 977}, "files": [{"sha": "071a281b142ce2729d7c0c92d8fe9a867d3a28a8", "filename": "ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f877b3adba2d9442752721d87c96f93beccd4c40/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f877b3adba2d9442752721d87c96f93beccd4c40/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=f877b3adba2d9442752721d87c96f93beccd4c40", "patch": "@@ -1,3 +1,7 @@\n+2017-02-13  Richard Biener  <rguenther@suse.de>\n+\n+\t* configure: Re-generate.\n+\n 2017-02-07  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* MAINTAINERS: Adjust bug reporting URL."}, {"sha": "020032b62fa5f69b103b32951317c340e8aeb1b5", "filename": "config/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f877b3adba2d9442752721d87c96f93beccd4c40/config%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f877b3adba2d9442752721d87c96f93beccd4c40/config%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2FChangeLog?ref=f877b3adba2d9442752721d87c96f93beccd4c40", "patch": "@@ -1,3 +1,7 @@\n+2017-02-13  Richard Biener  <rguenther@suse.de>\n+\n+\t* isl.m4: Remove support for ISL 0.14.\n+\n 2017-01-19  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/78478"}, {"sha": "bbb973e023b1dd2c5e610a98ceb2d7cfcff70229", "filename": "config/isl.m4", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f877b3adba2d9442752721d87c96f93beccd4c40/config%2Fisl.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f877b3adba2d9442752721d87c96f93beccd4c40/config%2Fisl.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/config%2Fisl.m4?ref=f877b3adba2d9442752721d87c96f93beccd4c40", "patch": "@@ -106,27 +106,15 @@ AC_DEFUN([ISL_CHECK_VERSION],\n     LDFLAGS=\"${_isl_saved_LDFLAGS} ${isllibs} ${gmplibs}\"\n     LIBS=\"${_isl_saved_LIBS} -lisl -lgmp\"\n \n-    AC_MSG_CHECKING([for isl 0.16, 0.15, or deprecated 0.14])\n-    AC_TRY_LINK([#include <isl/ctx.h>],\n-                [isl_ctx_get_max_operations (isl_ctx_alloc ());],\n+    AC_MSG_CHECKING([for isl 0.15 or later])\n+    AC_TRY_LINK([#include <isl/schedule.h>],\n+                [isl_options_set_schedule_serialize_sccs (NULL, 0);],\n                 [gcc_cv_isl=yes],\n                 [gcc_cv_isl=no])\n     AC_MSG_RESULT([$gcc_cv_isl])\n \n     if test \"${gcc_cv_isl}\" = no ; then\n-      AC_MSG_RESULT([recommended isl version is 0.16 or 0.15, the minimum required isl version 0.14 is deprecated])\n-    fi\n-\n-    AC_MSG_CHECKING([for isl 0.16 or 0.15])\n-    AC_TRY_LINK([#include <isl/schedule.h>],\n-                [isl_options_set_schedule_serialize_sccs (NULL, 0);],\n-                [ac_has_isl_options_set_schedule_serialize_sccs=yes],\n-                [ac_has_isl_options_set_schedule_serialize_sccs=no])\n-    AC_MSG_RESULT($ac_has_isl_options_set_schedule_serialize_sccs)\n-\n-    if test x\"$ac_has_isl_options_set_schedule_serialize_sccs\" = x\"yes\"; then\n-      islver=\"0.15\"\n-      AC_SUBST([islver])\n+      AC_MSG_RESULT([required isl version is 0.15 or later])\n     fi\n \n     CFLAGS=$_isl_saved_CFLAGS"}, {"sha": "3ff18d3105a5c8879a5c2e8a2e89356e554effa1", "filename": "configure", "status": "modified", "additions": 6, "deletions": 35, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f877b3adba2d9442752721d87c96f93beccd4c40/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f877b3adba2d9442752721d87c96f93beccd4c40/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=f877b3adba2d9442752721d87c96f93beccd4c40", "patch": "@@ -649,7 +649,6 @@ extra_linker_plugin_flags\n extra_linker_plugin_configure_flags\n islinc\n isllibs\n-islver\n poststage1_ldflags\n poststage1_libs\n stage1_ldflags\n@@ -5939,15 +5938,15 @@ $as_echo \"$as_me: WARNING: using in-tree isl, disabling version check\" >&2;}\n     LDFLAGS=\"${_isl_saved_LDFLAGS} ${isllibs} ${gmplibs}\"\n     LIBS=\"${_isl_saved_LIBS} -lisl -lgmp\"\n \n-    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for isl 0.16, 0.15, or deprecated 0.14\" >&5\n-$as_echo_n \"checking for isl 0.16, 0.15, or deprecated 0.14... \" >&6; }\n+    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for isl 0.15 or later\" >&5\n+$as_echo_n \"checking for isl 0.15 or later... \" >&6; }\n     cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n /* end confdefs.h.  */\n-#include <isl/ctx.h>\n+#include <isl/schedule.h>\n int\n main ()\n {\n-isl_ctx_get_max_operations (isl_ctx_alloc ());\n+isl_options_set_schedule_serialize_sccs (NULL, 0);\n   ;\n   return 0;\n }\n@@ -5963,36 +5962,8 @@ rm -f core conftest.err conftest.$ac_objext \\\n $as_echo \"$gcc_cv_isl\" >&6; }\n \n     if test \"${gcc_cv_isl}\" = no ; then\n-      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: recommended isl version is 0.16 or 0.15, the minimum required isl version 0.14 is deprecated\" >&5\n-$as_echo \"recommended isl version is 0.16 or 0.15, the minimum required isl version 0.14 is deprecated\" >&6; }\n-    fi\n-\n-    { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for isl 0.16 or 0.15\" >&5\n-$as_echo_n \"checking for isl 0.16 or 0.15... \" >&6; }\n-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-#include <isl/schedule.h>\n-int\n-main ()\n-{\n-isl_options_set_schedule_serialize_sccs (NULL, 0);\n-  ;\n-  return 0;\n-}\n-_ACEOF\n-if ac_fn_c_try_link \"$LINENO\"; then :\n-  ac_has_isl_options_set_schedule_serialize_sccs=yes\n-else\n-  ac_has_isl_options_set_schedule_serialize_sccs=no\n-fi\n-rm -f core conftest.err conftest.$ac_objext \\\n-    conftest$ac_exeext conftest.$ac_ext\n-    { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_has_isl_options_set_schedule_serialize_sccs\" >&5\n-$as_echo \"$ac_has_isl_options_set_schedule_serialize_sccs\" >&6; }\n-\n-    if test x\"$ac_has_isl_options_set_schedule_serialize_sccs\" = x\"yes\"; then\n-      islver=\"0.15\"\n-\n+      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: required isl version is 0.15 or later\" >&5\n+$as_echo \"required isl version is 0.15 or later\" >&6; }\n     fi\n \n     CFLAGS=$_isl_saved_CFLAGS"}, {"sha": "7ba091e8367156d9966b3c41c6f75c2c7bddbab9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f877b3adba2d9442752721d87c96f93beccd4c40", "patch": "@@ -1,3 +1,20 @@\n+2017-02-13  Richard Biener  <rguenther@suse.de>\n+\n+\t* configure.ac (HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS):\n+\tRemove.\n+\t* configure: Re-generate.\n+\t* config.in: Likewise.\n+\t* graphite-dependences.c: Simplify as if\n+\tHAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS was defined.\n+\t* graphite-isl-ast-to-gimple.c: Likewise.\n+\t* graphite-optimize-isl.c: Likewise.\n+\t* graphite-poly.c: Likewise.\n+\t* graphite-sese-to-poly.c: Likewise.\n+\t* graphite.h: Likewise.\n+\t* toplev.c: Include isl/version.h and use isl_version () for\n+\tprinting the ISL version.\n+\t* doc/install.texi: Update ISL requirement.\n+\n 2017-02-12  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* doc/standards.texi (Standards): Update reference to"}, {"sha": "d87cb3c9fab0499137702be24085e6f61d7f89e4", "filename": "gcc/config.in", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=f877b3adba2d9442752721d87c96f93beccd4c40", "patch": "@@ -1423,12 +1423,6 @@\n #endif\n \n \n-/* Define if isl_options_set_schedule_serialize_sccs exists. */\n-#ifndef USED_FOR_TARGET\n-#undef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n-#endif\n-\n-\n /* Define to 1 if you have the `kill' function. */\n #ifndef USED_FOR_TARGET\n #undef HAVE_KILL"}, {"sha": "ea73b151a4e1797983665a7f5437136dc8dcb46e", "filename": "gcc/configure", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=f877b3adba2d9442752721d87c96f93beccd4c40", "patch": "@@ -29432,47 +29432,6 @@ $as_echo \"#define HAVE_isl 1\" >>confdefs.h\n \n fi\n \n-# Check whether isl_options_set_schedule_serialize_sccs is available;\n-# it's new in isl 0.15.\n-if test \"x${ISLLIBS}\" != \"x\" ; then\n-  saved_CXXFLAGS=\"$CXXFLAGS\"\n-  CXXFLAGS=\"$CXXFLAGS $ISLINC $GMPINC\"\n-  saved_LIBS=\"$LIBS\"\n-  LIBS=\"$LIBS $ISLLIBS $GMPLIBS\"\n-\n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking Checking for isl_options_set_schedule_serialize_sccs\" >&5\n-$as_echo_n \"checking Checking for isl_options_set_schedule_serialize_sccs... \" >&6; }\n-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-#include <isl/schedule.h>\n-int\n-main ()\n-{\n-isl_options_set_schedule_serialize_sccs (NULL, 0);\n-  ;\n-  return 0;\n-}\n-_ACEOF\n-if ac_fn_cxx_try_link \"$LINENO\"; then :\n-  ac_has_isl_options_set_schedule_serialize_sccs=yes\n-else\n-  ac_has_isl_options_set_schedule_serialize_sccs=no\n-fi\n-rm -f core conftest.err conftest.$ac_objext \\\n-    conftest$ac_exeext conftest.$ac_ext\n-  { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_has_isl_options_set_schedule_serialize_sccs\" >&5\n-$as_echo \"$ac_has_isl_options_set_schedule_serialize_sccs\" >&6; }\n-\n-  LIBS=\"$saved_LIBS\"\n-  CXXFLAGS=\"$saved_CXXFLAGS\"\n-\n-  if test x\"$ac_has_isl_options_set_schedule_serialize_sccs\" = x\"yes\"; then\n-\n-$as_echo \"#define HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS 1\" >>confdefs.h\n-\n-  fi\n-fi\n-\n # Check for plugin support\n    # Check whether --enable-plugin was given.\n if test \"${enable_plugin+set}\" = set; then :"}, {"sha": "9d4c792a33f4e4da79d80a7676f22684f45df47b", "filename": "gcc/configure.ac", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=f877b3adba2d9442752721d87c96f93beccd4c40", "patch": "@@ -6193,30 +6193,6 @@ if test \"x${ISLLIBS}\" != \"x\" ; then\n    AC_DEFINE(HAVE_isl, 1, [Define if isl is in use.])\n fi\n \n-# Check whether isl_options_set_schedule_serialize_sccs is available;\n-# it's new in isl 0.15.\n-if test \"x${ISLLIBS}\" != \"x\" ; then\n-  saved_CXXFLAGS=\"$CXXFLAGS\"\n-  CXXFLAGS=\"$CXXFLAGS $ISLINC $GMPINC\"\n-  saved_LIBS=\"$LIBS\"\n-  LIBS=\"$LIBS $ISLLIBS $GMPLIBS\"\n-\n-  AC_MSG_CHECKING([Checking for isl_options_set_schedule_serialize_sccs])\n-  AC_TRY_LINK([#include <isl/schedule.h>],\n-              [isl_options_set_schedule_serialize_sccs (NULL, 0);],\n-              [ac_has_isl_options_set_schedule_serialize_sccs=yes],\n-              [ac_has_isl_options_set_schedule_serialize_sccs=no])\n-  AC_MSG_RESULT($ac_has_isl_options_set_schedule_serialize_sccs)\n-\n-  LIBS=\"$saved_LIBS\"\n-  CXXFLAGS=\"$saved_CXXFLAGS\"\n-\n-  if test x\"$ac_has_isl_options_set_schedule_serialize_sccs\" = x\"yes\"; then\n-     AC_DEFINE(HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS, 1,\n-               [Define if isl_options_set_schedule_serialize_sccs exists.])\n-  fi\n-fi\n-\n GCC_ENABLE_PLUGINS\n AC_SUBST(pluginlibs)\n AC_SUBST(enable_plugin)"}, {"sha": "7d5fca8ba5bb9b964f9c6162e79f5bc66bf606e3", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=f877b3adba2d9442752721d87c96f93beccd4c40", "patch": "@@ -385,7 +385,7 @@ installed but it is not in your default library search path, the\n The in-tree build is only supported with the MPC version that\n download_prerequisites installs.\n \n-@item isl Library version 0.16, 0.15, or 0.14.\n+@item isl Library version 0.15 or later.\n \n Necessary to build GCC with the Graphite loop optimizations.\n It can be downloaded from @uref{ftp://gcc.gnu.org/pub/gcc/infrastructure/}."}, {"sha": "4ed9d00b2fd0abfb5c518482923cd30baed80f52", "filename": "gcc/graphite-dependences.c", "status": "modified", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Fgraphite-dependences.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Fgraphite-dependences.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-dependences.c?ref=f877b3adba2d9442752721d87c96f93beccd4c40", "patch": "@@ -168,28 +168,6 @@ scop_get_may_writes (scop_p scop)\n   return isl_union_map_coalesce (res);\n }\n \n-#ifndef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n-/* Returns all the original schedules in SCOP.  */\n-\n-static isl_union_map *\n-scop_get_original_schedule (scop_p scop, vec<poly_bb_p> pbbs)\n-{\n-  int i;\n-  poly_bb_p pbb;\n-  isl_space *space = isl_set_get_space (scop->param_context);\n-  isl_union_map *res = isl_union_map_empty (space);\n-\n-  FOR_EACH_VEC_ELT (pbbs, i, pbb)\n-    {\n-      res = isl_union_map_add_map\n-\t(res, constrain_domain (isl_map_copy (pbb->schedule),\n-\t\t\t\tisl_set_copy (pbb->domain)));\n-    }\n-\n-  return isl_union_map_coalesce (res);\n-}\n-#endif\n-\n /* Helper function used on each MAP of a isl_union_map.  Computes the\n    maximal output dimension.  */\n \n@@ -311,7 +289,6 @@ carries_deps (__isl_keep isl_union_map *schedule,\n   return res;\n }\n \n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n /* Compute the dependence relations for the SCOP:\n    RAW are read after write dependences,\n    WAR are write after read dependences,\n@@ -398,133 +375,4 @@ scop_get_dependences (scop_p scop)\n   scop->dependence = dependences;\n }\n \n-#else\n-\n-/* Compute the original data dependences in SCOP for all the reads and\n-   writes in PBBS.  */\n-\n-static void\n-compute_deps (scop_p scop, vec<poly_bb_p> pbbs,\n-\t      isl_union_map **must_raw,\n-\t      isl_union_map **may_raw,\n-\t      isl_union_map **must_raw_no_source,\n-\t      isl_union_map **may_raw_no_source,\n-\t      isl_union_map **must_war,\n-\t      isl_union_map **may_war,\n-\t      isl_union_map **must_war_no_source,\n-\t      isl_union_map **may_war_no_source,\n-\t      isl_union_map **must_waw,\n-\t      isl_union_map **may_waw,\n-\t      isl_union_map **must_waw_no_source,\n-\t      isl_union_map **may_waw_no_source)\n-{\n-  isl_union_map *reads = scop_get_reads (scop);\n-  isl_union_map *must_writes = scop_get_must_writes (scop);\n-  isl_union_map *may_writes = scop_get_may_writes (scop);\n-  isl_union_map *all_writes = isl_union_map_union\n-    (isl_union_map_copy (must_writes), isl_union_map_copy (may_writes));\n-  all_writes = isl_union_map_coalesce (all_writes);\n-\n-  isl_space *space = isl_union_map_get_space (all_writes);\n-  isl_union_map *empty = isl_union_map_empty (space);\n-  isl_union_map *original = scop_get_original_schedule (scop, pbbs);\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"\\n--- Documentation for datarefs dump: ---\\n\");\n-      fprintf (dump_file, \"Statements on the iteration domain are mapped to\"\n-\t       \" array references.\\n\");\n-      fprintf (dump_file, \"  To read the following data references:\\n\\n\");\n-      fprintf (dump_file, \"  S_5[i0] -> [106] : i0 >= 0 and i0 <= 3\\n\");\n-      fprintf (dump_file, \"  S_8[i0] -> [1, i0] : i0 >= 0 and i0 <= 3\\n\\n\");\n-\n-      fprintf (dump_file, \"  S_5[i0] is the dynamic instance of statement\"\n-\t       \" bb_5 in a loop that accesses all iterations 0 <= i0 <= 3.\\n\");\n-      fprintf (dump_file, \"  [1, i0] is a 'memref' with alias set 1\"\n-\t       \" and first subscript access i0.\\n\");\n-      fprintf (dump_file, \"  [106] is a 'scalar reference' which is the sum of\"\n-\t       \" SSA_NAME_VERSION 6\"\n-\t       \" and --param graphite-max-arrays-per-scop=100\\n\");\n-      fprintf (dump_file, \"-----------------------\\n\\n\");\n-\n-      fprintf (dump_file, \"data references (\\n\");\n-      fprintf (dump_file, \"  reads: \");\n-      print_isl_union_map (dump_file, reads);\n-      fprintf (dump_file, \"  must_writes: \");\n-      print_isl_union_map (dump_file, must_writes);\n-      fprintf (dump_file, \"  may_writes: \");\n-      print_isl_union_map (dump_file, may_writes);\n-      fprintf (dump_file, \"  all_writes: \");\n-      print_isl_union_map (dump_file, all_writes);\n-      fprintf (dump_file, \")\\n\");\n-    }\n-\n-  isl_union_map_compute_flow (isl_union_map_copy (reads),\n-\t\t\t      isl_union_map_copy (must_writes),\n-\t\t\t      isl_union_map_copy (may_writes),\n-\t\t\t      isl_union_map_copy (original),\n-\t\t\t      must_raw, may_raw, must_raw_no_source,\n-\t\t\t      may_raw_no_source);\n-  isl_union_map_compute_flow (isl_union_map_copy (all_writes),\n-\t\t\t      reads, empty,\n-\t\t\t      isl_union_map_copy (original),\n-\t\t\t      must_war, may_war, must_war_no_source,\n-\t\t\t      may_war_no_source);\n-  isl_union_map_compute_flow (all_writes, must_writes, may_writes,\n-\t\t\t      original,\n-\t\t\t      must_waw, may_waw, must_waw_no_source,\n-\t\t\t      may_waw_no_source);\n-}\n-\n-isl_union_map *\n-scop_get_dependences (scop_p scop)\n-{\n-  if (scop->dependence)\n-    return scop->dependence;\n-\n-  /* The original dependence relations:\n-     RAW are read after write dependences,\n-     WAR are write after read dependences,\n-     WAW are write after write dependences.  */\n-  isl_union_map *must_raw = NULL, *may_raw = NULL, *must_raw_no_source = NULL,\n-      *may_raw_no_source = NULL, *must_war = NULL, *may_war = NULL,\n-      *must_war_no_source = NULL, *may_war_no_source = NULL, *must_waw = NULL,\n-      *may_waw = NULL, *must_waw_no_source = NULL, *may_waw_no_source = NULL;\n-\n-  compute_deps (scop, scop->pbbs,\n-\t\t  &must_raw, &may_raw,\n-\t\t  &must_raw_no_source, &may_raw_no_source,\n-\t\t  &must_war, &may_war,\n-\t\t  &must_war_no_source, &may_war_no_source,\n-\t\t  &must_waw, &may_waw,\n-\t\t  &must_waw_no_source, &may_waw_no_source);\n-\n-  isl_union_map *dependences = must_raw;\n-  dependences = isl_union_map_union (dependences, must_war);\n-  dependences = isl_union_map_union (dependences, must_waw);\n-  dependences = isl_union_map_union (dependences, may_raw);\n-  dependences = isl_union_map_union (dependences, may_war);\n-  dependences = isl_union_map_union (dependences, may_waw);\n-  dependences = isl_union_map_coalesce (dependences);\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"data dependences (\\n\");\n-      print_isl_union_map (dump_file, dependences);\n-      fprintf (dump_file, \")\\n\");\n-    }\n-\n-  isl_union_map_free (must_raw_no_source);\n-  isl_union_map_free (may_raw_no_source);\n-  isl_union_map_free (must_war_no_source);\n-  isl_union_map_free (may_war_no_source);\n-  isl_union_map_free (must_waw_no_source);\n-  isl_union_map_free (may_waw_no_source);\n-\n-  scop->dependence = dependences;\n-  return dependences;\n-}\n-\n-#endif /* HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS */\n-\n #endif /* HAVE_isl */"}, {"sha": "dbdae7a7c155dc133d66843e0a24abef8c5eeb8a", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 0, "deletions": 162, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=f877b3adba2d9442752721d87c96f93beccd4c40", "patch": "@@ -115,8 +115,6 @@ static void ivs_params_clear (ivs_params &ip)\n     }\n }\n \n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n-\n /* Set the \"separate\" option for the schedule node.  */\n \n static isl_schedule_node *\n@@ -157,8 +155,6 @@ debug_schedule_ast (__isl_keep isl_schedule *s, scop_p scop)\n   print_schedule_ast (stderr, s, scop);\n }\n \n-#endif\n-\n enum phi_node_kind\n {\n   unknown_phi,\n@@ -227,17 +223,7 @@ class translate_isl_ast_to_gimple\n   void add_parameters_to_ivs_params (scop_p scop, ivs_params &ip);\n   __isl_give isl_ast_build *generate_isl_context (scop_p scop);\n \n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n   __isl_give isl_ast_node * scop_to_isl_ast (scop_p scop);\n-#else\n-  int get_max_schedule_dimensions (scop_p scop);\n-  __isl_give isl_map *extend_schedule (__isl_take isl_map *schedule,\n-\t\t\t\t       int nb_schedule_dims);\n-  __isl_give isl_union_map *generate_isl_schedule (scop_p scop);\n-  __isl_give isl_ast_build *set_options (__isl_take isl_ast_build *control,\n-\t\t\t\t\t __isl_keep isl_union_map *schedule);\n-  __isl_give isl_ast_node *scop_to_isl_ast (scop_p scop, ivs_params &ip);\n-#endif\n \n   bool is_valid_rename (tree rename, basic_block def_bb, basic_block use_bb,\n \t\t\tphi_node_kind, tree old_name, basic_block old_bb) const;\n@@ -400,10 +386,7 @@ binary_op_to_tree (tree type, __isl_take isl_ast_expr *expr, ivs_params &ip)\n \t}\n       return fold_build2 (TRUNC_DIV_EXPR, type, tree_lhs_expr, tree_rhs_expr);\n \n-#if HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n-    /* isl 0.15 or later.  */\n     case isl_ast_op_zdiv_r:\n-#endif\n     case isl_ast_op_pdiv_r:\n       /* As isl operates on arbitrary precision numbers, we may end up with\n \t division by 2^64 that is folded to 0.  */\n@@ -568,10 +551,7 @@ gcc_expression_from_isl_expr_op (tree type, __isl_take isl_ast_expr *expr,\n     case isl_ast_op_pdiv_q:\n     case isl_ast_op_pdiv_r:\n     case isl_ast_op_fdiv_q:\n-#if HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n-    /* isl 0.15 or later.  */\n     case isl_ast_op_zdiv_r:\n-#endif\n     case isl_ast_op_and:\n     case isl_ast_op_or:\n     case isl_ast_op_eq:\n@@ -1043,15 +1023,13 @@ translate_isl_ast (loop_p context_loop, __isl_keep isl_ast_node *node,\n       return translate_isl_ast_node_block (context_loop, node,\n \t\t\t\t\t   next_e, ip);\n \n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n     case isl_ast_node_mark:\n       {\n \tisl_ast_node *n = isl_ast_node_mark_get_node (node);\n \tedge e = translate_isl_ast (context_loop, n, next_e, ip);\n \tisl_ast_node_free (n);\n \treturn e;\n       }\n-#endif\n \n     default:\n       gcc_unreachable ();\n@@ -2912,8 +2890,6 @@ ast_build_before_for (__isl_keep isl_ast_build *build, void *user)\n   return id;\n }\n \n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n-\n /* Generate isl AST from schedule of SCOP.  */\n \n __isl_give isl_ast_node *translate_isl_ast_to_gimple::\n@@ -2940,138 +2916,6 @@ scop_to_isl_ast (scop_p scop)\n   return ast_isl;\n }\n \n-#else\n-/* Get the maximal number of schedule dimensions in the scop SCOP.  */\n-\n-int translate_isl_ast_to_gimple::\n-get_max_schedule_dimensions (scop_p scop)\n-{\n-  int i;\n-  poly_bb_p pbb;\n-  int schedule_dims = 0;\n-\n-  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n-    {\n-      int pbb_schedule_dims = isl_map_dim (pbb->transformed, isl_dim_out);\n-      if (pbb_schedule_dims > schedule_dims)\n-\tschedule_dims = pbb_schedule_dims;\n-    }\n-\n-  return schedule_dims;\n-}\n-\n-/* Extend the schedule to NB_SCHEDULE_DIMS schedule dimensions.\n-\n-   For schedules with different dimensionality, the isl AST generator can not\n-   define an order and will just randomly choose an order.  The solution to this\n-   problem is to extend all schedules to the maximal number of schedule\n-   dimensions (using '0's for the remaining values).  */\n-\n-__isl_give isl_map *translate_isl_ast_to_gimple::\n-extend_schedule (__isl_take isl_map *schedule, int nb_schedule_dims)\n-{\n-  int tmp_dims = isl_map_dim (schedule, isl_dim_out);\n-  schedule =\n-    isl_map_add_dims (schedule, isl_dim_out, nb_schedule_dims - tmp_dims);\n-  isl_val *zero =\n-    isl_val_int_from_si (isl_map_get_ctx (schedule), 0);\n-  int i;\n-  for (i = tmp_dims; i < nb_schedule_dims; i++)\n-    {\n-      schedule\n-\t= isl_map_fix_val (schedule, isl_dim_out, i, isl_val_copy (zero));\n-    }\n-  isl_val_free (zero);\n-  return schedule;\n-}\n-\n-/* Generates a schedule, which specifies an order used to\n-   visit elements in a domain.  */\n-\n-__isl_give isl_union_map *translate_isl_ast_to_gimple::\n-generate_isl_schedule (scop_p scop)\n-{\n-  int nb_schedule_dims = get_max_schedule_dimensions (scop);\n-  int i;\n-  poly_bb_p pbb;\n-  isl_union_map *schedule_isl =\n-    isl_union_map_empty (isl_set_get_space (scop->param_context));\n-\n-  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n-    {\n-      /* Dead code elimination: when the domain of a PBB is empty,\n-\t don't generate code for the PBB.  */\n-      if (isl_set_is_empty (pbb->domain))\n-\tcontinue;\n-\n-      isl_map *bb_schedule = isl_map_copy (pbb->transformed);\n-      bb_schedule = isl_map_intersect_domain (bb_schedule,\n-\t\t\t\t\t      isl_set_copy (pbb->domain));\n-      bb_schedule = extend_schedule (bb_schedule, nb_schedule_dims);\n-      bb_schedule = isl_map_coalesce (bb_schedule);\n-      schedule_isl\n-\t= isl_union_map_union (schedule_isl,\n-\t\t\t       isl_union_map_from_map (bb_schedule));\n-      schedule_isl = isl_union_map_coalesce (schedule_isl);\n-    }\n-  return schedule_isl;\n-}\n-\n-/* Set the separate option for all dimensions.\n-   This helps to reduce control overhead.  */\n-\n-__isl_give isl_ast_build *translate_isl_ast_to_gimple::\n-set_options (__isl_take isl_ast_build *control,\n-\t     __isl_keep isl_union_map *schedule)\n-{\n-  isl_ctx *ctx = isl_union_map_get_ctx (schedule);\n-  isl_space *range_space = isl_space_set_alloc (ctx, 0, 1);\n-  range_space =\n-    isl_space_set_tuple_name (range_space, isl_dim_set, \"separate\");\n-  isl_union_set *range =\n-    isl_union_set_from_set (isl_set_universe (range_space));\n-  isl_union_set *domain = isl_union_map_range (isl_union_map_copy (schedule));\n-  domain = isl_union_set_universe (domain);\n-  isl_union_map *options = isl_union_map_from_domain_and_range (domain, range);\n-  return isl_ast_build_set_options (control, options);\n-}\n-\n-/* Generate isl AST from schedule of SCOP.  Also, collects IVS_PARAMS in IP.  */\n-\n-__isl_give isl_ast_node *translate_isl_ast_to_gimple::\n-scop_to_isl_ast (scop_p scop, ivs_params &ip)\n-{\n-  /* Generate loop upper bounds that consist of the current loop iterator, an\n-     operator (< or <=) and an expression not involving the iterator.  If this\n-     option is not set, then the current loop iterator may appear several times\n-     in the upper bound.  See the isl manual for more details.  */\n-  isl_options_set_ast_build_atomic_upper_bound (scop->isl_context, true);\n-\n-  add_parameters_to_ivs_params (scop, ip);\n-  isl_union_map *schedule_isl = generate_isl_schedule (scop);\n-  isl_ast_build *context_isl = generate_isl_context (scop);\n-  context_isl = set_options (context_isl, schedule_isl);\n-  if (flag_loop_parallelize_all)\n-    {\n-      isl_union_map *dependence = scop_get_dependences (scop);\n-      context_isl =\n-\tisl_ast_build_set_before_each_for (context_isl, ast_build_before_for,\n-\t\t\t\t\t   dependence);\n-    }\n-\n-  isl_ast_node *ast_isl = isl_ast_build_ast_from_schedule (context_isl,\n-\t\t\t\t\t\t\t   schedule_isl);\n-  if (scop->schedule)\n-    {\n-      isl_schedule_free (scop->schedule);\n-      scop->schedule = NULL;\n-    }\n-\n-  isl_ast_build_free (context_isl);\n-  return ast_isl;\n-}\n-#endif\n-\n /* Copy def from sese REGION to the newly created TO_REGION. TR is defined by\n    DEF_STMT. GSI points to entry basic block of the TO_REGION.  */\n \n@@ -3150,24 +2994,18 @@ graphite_regenerate_ast_isl (scop_p scop)\n   ivs_params ip;\n \n   timevar_push (TV_GRAPHITE_CODE_GEN);\n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n   t.add_parameters_to_ivs_params (scop, ip);\n   root_node = t.scop_to_isl_ast (scop);\n-#else\n-  root_node = t.scop_to_isl_ast (scop, ip);\n-#endif\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n       fprintf (dump_file, \"[scheduler] original schedule:\\n\");\n       print_isl_schedule (dump_file, scop->original_schedule);\n       fprintf (dump_file, \"[scheduler] isl transformed schedule:\\n\");\n       print_isl_schedule (dump_file, scop->transformed_schedule);\n \n       fprintf (dump_file, \"[scheduler] original ast:\\n\");\n       print_schedule_ast (dump_file, scop->original_schedule, scop);\n-#endif\n       fprintf (dump_file, \"[scheduler] AST generated by isl:\\n\");\n       print_isl_ast (dump_file, root_node);\n     }"}, {"sha": "467503e1b62f8edf44ae2f4acf7b1581852c3290", "filename": "gcc/graphite-optimize-isl.c", "status": "modified", "additions": 0, "deletions": 320, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Fgraphite-optimize-isl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Fgraphite-optimize-isl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-optimize-isl.c?ref=f877b3adba2d9442752721d87c96f93beccd4c40", "patch": "@@ -39,8 +39,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dumpfile.h\"\n #include \"graphite.h\"\n \n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n-/* isl 0.15 or later.  */\n \n /* get_schedule_for_node_st - Improve schedule for the schedule node.\n    Only Simple loop tiling is considered.  */\n@@ -206,322 +204,4 @@ apply_poly_transforms (scop_p scop)\n   return true;\n }\n \n-#else\n-\n-/* get_tile_map - Create a map that describes a n-dimensonal tiling.\n-\n-   get_tile_map creates a map from a n-dimensional scattering space into an\n-   2*n-dimensional scattering space. The map describes a rectangular tiling.\n-\n-   Example:\n-     SCHEDULE_DIMENSIONS = 2, PARAMETER_DIMENSIONS = 1, TILE_SIZE = 32\n-\n-    tile_map := [p0] -> {[s0, s1] -> [t0, t1, s0, s1]:\n-\t\t\t t0 % 32 = 0 and t0 <= s0 < t0 + 32 and\n-\t\t\t t1 % 32 = 0 and t1 <= s1 < t1 + 32}\n-\n-   Before tiling:\n-\n-   for (i = 0; i < N; i++)\n-     for (j = 0; j < M; j++)\n-\tS(i,j)\n-\n-   After tiling:\n-\n-   for (t_i = 0; t_i < N; i+=32)\n-     for (t_j = 0; t_j < M; j+=32)\n-\tfor (i = t_i; i < min(t_i + 32, N); i++)  | Unknown that N % 32 = 0\n-\t  for (j = t_j; j < t_j + 32; j++)        |   Known that M % 32 = 0\n-\t    S(i,j)\n-  */\n-\n-static isl_basic_map *\n-get_tile_map (isl_ctx *ctx, int schedule_dimensions, int tile_size)\n-{\n-  /* We construct\n-\n-     tile_map := [p0] -> {[s0, s1] -> [t0, t1, p0, p1, a0, a1]:\n-\t\t\ts0 = a0 * 32 and s0 = p0 and t0 <= p0 < t0 + 32 and\n-\t\t\ts1 = a1 * 32 and s1 = p1 and t1 <= p1 < t1 + 32}\n-\n-     and project out the auxilary dimensions a0 and a1.  */\n-  isl_space *space\n-    = isl_space_alloc (ctx, 0, schedule_dimensions, schedule_dimensions * 3);\n-  isl_basic_map *tile_map = isl_basic_map_universe (isl_space_copy (space));\n-\n-  isl_local_space *local_space = isl_local_space_from_space (space);\n-\n-  for (int x = 0; x < schedule_dimensions; x++)\n-    {\n-      int sX = x;\n-      int tX = x;\n-      int pX = schedule_dimensions + x;\n-      int aX = 2 * schedule_dimensions + x;\n-\n-      isl_constraint *c;\n-\n-      /* sX = aX * tile_size; */\n-      c = isl_equality_alloc (isl_local_space_copy (local_space));\n-      isl_constraint_set_coefficient_si (c, isl_dim_out, sX, 1);\n-      isl_constraint_set_coefficient_si (c, isl_dim_out, aX, -tile_size);\n-      tile_map = isl_basic_map_add_constraint (tile_map, c);\n-\n-      /* pX = sX; */\n-      c = isl_equality_alloc (isl_local_space_copy (local_space));\n-      isl_constraint_set_coefficient_si (c, isl_dim_out, pX, 1);\n-      isl_constraint_set_coefficient_si (c, isl_dim_in, sX, -1);\n-      tile_map = isl_basic_map_add_constraint (tile_map, c);\n-\n-      /* tX <= pX */\n-      c = isl_inequality_alloc (isl_local_space_copy (local_space));\n-      isl_constraint_set_coefficient_si (c, isl_dim_out, pX, 1);\n-      isl_constraint_set_coefficient_si (c, isl_dim_out, tX, -1);\n-      tile_map = isl_basic_map_add_constraint (tile_map, c);\n-\n-      /* pX <= tX + (tile_size - 1) */\n-      c = isl_inequality_alloc (isl_local_space_copy (local_space));\n-      isl_constraint_set_coefficient_si (c, isl_dim_out, tX, 1);\n-      isl_constraint_set_coefficient_si (c, isl_dim_out, pX, -1);\n-      isl_constraint_set_constant_si (c, tile_size - 1);\n-      tile_map = isl_basic_map_add_constraint (tile_map, c);\n-    }\n-\n-  /* Project out auxiliary dimensions.\n-\n-     The auxiliary dimensions are transformed into existentially quantified\n-     ones.\n-     This reduces the number of visible scattering dimensions and allows isl\n-     to produces better code.  */\n-  tile_map =\n-      isl_basic_map_project_out (tile_map, isl_dim_out,\n-\t\t\t\t 2 * schedule_dimensions, schedule_dimensions);\n-  isl_local_space_free (local_space);\n-  return tile_map;\n-}\n-\n-/* get_schedule_for_band - Get the schedule for this BAND.\n-\n-   Polly applies transformations like tiling on top of the isl calculated\n-   value.\n-   This can influence the number of scheduling dimension. The number of\n-   schedule dimensions is returned in DIMENSIONS.  */\n-\n-static isl_union_map *\n-get_schedule_for_band (isl_band *band, int *dimensions)\n-{\n-  isl_union_map *partial_schedule;\n-  isl_ctx *ctx;\n-  isl_space *space;\n-  isl_basic_map *tile_map;\n-  isl_union_map *tile_umap;\n-\n-  partial_schedule = isl_band_get_partial_schedule (band);\n-  *dimensions = isl_band_n_member (band);\n-\n-  /* It does not make any sense to tile a band with just one dimension.  */\n-  if (*dimensions == 1)\n-    {\n-      if (dump_file && dump_flags)\n-\tfprintf (dump_file, \"not tiled\\n\");\n-      return partial_schedule;\n-    }\n-\n-  if (dump_file && dump_flags)\n-    fprintf (dump_file, \"tiled by %d\\n\",\n-\t     PARAM_VALUE (PARAM_LOOP_BLOCK_TILE_SIZE));\n-\n-  ctx = isl_union_map_get_ctx (partial_schedule);\n-  space = isl_union_map_get_space (partial_schedule);\n-\n-  tile_map = get_tile_map (ctx, *dimensions,\n-\t\t\t   PARAM_VALUE (PARAM_LOOP_BLOCK_TILE_SIZE));\n-  tile_umap = isl_union_map_from_map (isl_map_from_basic_map (tile_map));\n-  tile_umap = isl_union_map_align_params (tile_umap, space);\n-  tile_umap = isl_union_map_coalesce (tile_umap);\n-  *dimensions = 2 * *dimensions;\n-\n-  return isl_union_map_apply_range (partial_schedule, tile_umap);\n-}\n-\n-\n-/* get_schedule_for_band_list - Get the scheduling map for a list of bands.\n-\n-   We walk recursively the forest of bands to combine the schedules of the\n-   individual bands to the overall schedule.  In case tiling is requested,\n-   the individual bands are tiled.  */\n-\n-static isl_union_map *\n-get_schedule_for_band_list (isl_band_list *band_list)\n-{\n-  int num_bands, i;\n-  isl_union_map *schedule;\n-  isl_ctx *ctx;\n-\n-  ctx = isl_band_list_get_ctx (band_list);\n-  num_bands = isl_band_list_n_band (band_list);\n-  schedule = isl_union_map_empty (isl_space_params_alloc (ctx, 0));\n-\n-  for (i = 0; i < num_bands; i++)\n-    {\n-      isl_band *band;\n-      isl_union_map *partial_schedule;\n-      int schedule_dimensions;\n-      isl_space *space;\n-\n-      band = isl_band_list_get_band (band_list, i);\n-      partial_schedule = get_schedule_for_band (band, &schedule_dimensions);\n-      space = isl_union_map_get_space (partial_schedule);\n-\n-      if (isl_band_has_children (band))\n-\t{\n-\t  isl_band_list *children = isl_band_get_children (band);\n-\t  isl_union_map *suffixSchedule\n-\t    = get_schedule_for_band_list (children);\n-\t  partial_schedule\n-\t    = isl_union_map_flat_range_product (partial_schedule,\n-\t\t\t\t\t\tsuffixSchedule);\n-\t  isl_band_list_free (children);\n-\t}\n-\n-      schedule = isl_union_map_union (schedule, partial_schedule);\n-\n-      isl_band_free (band);\n-      isl_space_free (space);\n-    }\n-\n-  return isl_union_map_coalesce (schedule);\n-}\n-\n-static isl_union_map *\n-get_schedule_map (isl_schedule *schedule)\n-{\n-  isl_band_list *band_list = isl_schedule_get_band_forest (schedule);\n-  isl_union_map *schedule_map = get_schedule_for_band_list (band_list);\n-  isl_band_list_free (band_list);\n-  return schedule_map;\n-}\n-\n-static isl_stat\n-get_single_map (__isl_take isl_map *map, void *user)\n-{\n-  isl_map **single_map = (isl_map **)user;\n-  *single_map = map;\n-  return isl_stat_ok;\n-}\n-\n-static void\n-apply_schedule_map_to_scop (scop_p scop, isl_union_map *schedule_map)\n-{\n-  int i;\n-  poly_bb_p pbb;\n-\n-  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n-    {\n-      isl_set *domain = isl_set_copy (pbb->domain);\n-      isl_map *stmt_schedule;\n-\n-      isl_union_map *stmt_band\n-\t= isl_union_map_intersect_domain (isl_union_map_copy (schedule_map),\n-\t\t\t\t\t  isl_union_set_from_set (domain));\n-      stmt_band = isl_union_map_coalesce (stmt_band);\n-      isl_union_map_foreach_map (stmt_band, get_single_map, &stmt_schedule);\n-      isl_map_free (pbb->transformed);\n-      pbb->transformed = isl_map_coalesce (stmt_schedule);\n-      isl_union_map_free (stmt_band);\n-    }\n-}\n-\n-static isl_union_set *\n-scop_get_domains (scop_p scop)\n-{\n-  int i;\n-  poly_bb_p pbb;\n-  isl_space *space = isl_set_get_space (scop->param_context);\n-  isl_union_set *res = isl_union_set_empty (space);\n-\n-  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n-    res = isl_union_set_add_set (res, isl_set_copy (pbb->domain));\n-\n-  return res;\n-}\n-\n-/* Compute the schedule for SCOP based on its parameters, domain and set of\n-   constraints.  Then apply the schedule to SCOP.  */\n-\n-static bool\n-optimize_isl (scop_p scop)\n-{\n-  int old_max_operations = isl_ctx_get_max_operations (scop->isl_context);\n-  int max_operations = PARAM_VALUE (PARAM_MAX_ISL_OPERATIONS);\n-  if (max_operations)\n-    isl_ctx_set_max_operations (scop->isl_context, max_operations);\n-  isl_options_set_on_error (scop->isl_context, ISL_ON_ERROR_CONTINUE);\n-\n-  isl_union_set *domain = scop_get_domains (scop);\n-  scop_get_dependences (scop);\n-  scop->dependence\n-    = isl_union_map_gist_domain (scop->dependence, isl_union_set_copy (domain));\n-  scop->dependence\n-    = isl_union_map_gist_range (scop->dependence, isl_union_set_copy (domain));\n-  isl_union_map *validity = isl_union_map_copy (scop->dependence);\n-  isl_union_map *proximity = isl_union_map_copy (validity);\n-\n-  isl_options_set_schedule_fuse (scop->isl_context, ISL_SCHEDULE_FUSE_MIN);\n-  isl_schedule *schedule\n-    = isl_union_set_compute_schedule (domain, validity, proximity);\n-\n-  isl_options_set_on_error (scop->isl_context, ISL_ON_ERROR_ABORT);\n-\n-  isl_ctx_reset_operations (scop->isl_context);\n-  isl_ctx_set_max_operations (scop->isl_context, old_max_operations);\n-  if (!schedule || isl_ctx_last_error (scop->isl_context) == isl_error_quota)\n-    {\n-      if (dump_file && dump_flags)\n-\t{\n-\t  if (!schedule)\n-\t    fprintf (dump_file, \"isl did not return any schedule.\\n\");\n-\t  else\n-\t    fprintf (dump_file, \"isl timed out --param max-isl-operations=%d\\n\",\n-\t\t     max_operations);\n-\t}\n-\n-      if (schedule)\n-\tisl_schedule_free (schedule);\n-      return false;\n-    }\n-\n-  scop->schedule = schedule;\n-\n-  isl_union_map *schedule_map = get_schedule_map (schedule);\n-  apply_schedule_map_to_scop (scop, schedule_map);\n-  isl_union_map_free (schedule_map);\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"isl end schedule:\\n\");\n-      print_isl_schedule (dump_file, scop->schedule);\n-    }\n-\n-  return true;\n-}\n-\n-/* Apply graphite transformations to all the basic blocks of SCOP.  */\n-\n-bool\n-apply_poly_transforms (scop_p scop)\n-{\n-  if (flag_loop_nest_optimize)\n-    return optimize_isl (scop);\n-\n-  if (!flag_graphite_identity && !flag_loop_parallelize_all)\n-    return false;\n-\n-  /* Generate code even if we did not apply any real transformation.\n-     This also allows to check the performance for the identity\n-     transformation: GIMPLE -> GRAPHITE -> GIMPLE.  */\n-  return true;\n-}\n-\n-#endif /* HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS */\n-\n #endif /* HAVE_isl */"}, {"sha": "5089cd80c104df8ffa79f74e38e7d4ab16b787cb", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=f877b3adba2d9442752721d87c96f93beccd4c40", "patch": "@@ -136,13 +136,7 @@ new_poly_bb (scop_p scop, gimple_poly_bb_p black_box)\n   poly_bb_p pbb = XNEW (struct poly_bb);\n \n   pbb->domain = NULL;\n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n   pbb->iterators = NULL;\n-#else\n-  pbb->schedule = NULL;\n-  pbb->transformed = NULL;\n-  pbb->saved = NULL;\n-#endif\n   PBB_SCOP (pbb) = scop;\n   pbb_set_black_box (pbb, black_box);\n   PBB_DRS (pbb).create (3);\n@@ -161,17 +155,8 @@ free_poly_bb (poly_bb_p pbb)\n \n   isl_set_free (pbb->domain);\n   pbb->domain = NULL;\n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n   isl_set_free (pbb->iterators);\n   pbb->iterators = NULL;\n-#else\n-  isl_map_free (pbb->schedule);\n-  pbb->schedule = NULL;\n-  isl_map_free (pbb->transformed);\n-  pbb->transformed = NULL;\n-  isl_map_free (pbb->saved);\n-  pbb->saved = NULL;\n-#endif\n \n   if (PBB_DRS (pbb).exists ())\n     FOR_EACH_VEC_ELT (PBB_DRS (pbb), i, pdr)\n@@ -273,12 +258,8 @@ new_scop (edge entry, edge exit)\n   sese_info_p region = new_sese_info (entry, exit);\n   scop_p s = XNEW (struct scop);\n \n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n   s->original_schedule = NULL;\n   s->transformed_schedule = NULL;\n-#else\n-  s->schedule = NULL;\n-#endif\n   s->param_context = NULL;\n   scop_set_region (s, region);\n   s->pbbs.create (3);\n@@ -308,14 +289,10 @@ free_scop (scop_p scop)\n   scop->param_context = NULL;\n   isl_union_map_free (scop->dependence);\n   scop->dependence = NULL;\n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n   isl_schedule_free (scop->original_schedule);\n   scop->original_schedule = NULL;\n   isl_schedule_free (scop->transformed_schedule);\n   scop->transformed_schedule = NULL;\n-#else\n-\n-#endif\n   XDELETE (scop);\n }\n \n@@ -543,9 +520,7 @@ void\n print_isl_set (FILE *f, __isl_keep isl_set *set)\n {\n   isl_printer *p = isl_printer_to_file (the_isl_ctx, f);\n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n   p = isl_printer_set_yaml_style (p, ISL_YAML_STYLE_BLOCK);\n-#endif\n   p = isl_printer_print_set (p, set);\n   p = isl_printer_print_str (p, \"\\n\");\n   isl_printer_free (p);\n@@ -561,9 +536,7 @@ void\n print_isl_map (FILE *f, __isl_keep isl_map *map)\n {\n   isl_printer *p = isl_printer_to_file (the_isl_ctx, f);\n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n   p = isl_printer_set_yaml_style (p, ISL_YAML_STYLE_BLOCK);\n-#endif\n   p = isl_printer_print_map (p, map);\n   p = isl_printer_print_str (p, \"\\n\");\n   isl_printer_free (p);\n@@ -579,9 +552,7 @@ void\n print_isl_union_map (FILE *f, __isl_keep isl_union_map *map)\n {\n   isl_printer *p = isl_printer_to_file (the_isl_ctx, f);\n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n   p = isl_printer_set_yaml_style (p, ISL_YAML_STYLE_BLOCK);\n-#endif\n   p = isl_printer_print_union_map (p, map);\n   p = isl_printer_print_str (p, \"\\n\");\n   isl_printer_free (p);\n@@ -627,9 +598,7 @@ void\n print_isl_schedule (FILE *f, __isl_keep isl_schedule *s)\n {\n   isl_printer *p = isl_printer_to_file (the_isl_ctx, f);\n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n   p = isl_printer_set_yaml_style (p, ISL_YAML_STYLE_BLOCK);\n-#endif\n   p = isl_printer_print_schedule (p, s);\n   p = isl_printer_print_str (p, \"\\n\");\n   isl_printer_free (p);"}, {"sha": "ede96e5a3c299663600360b83e15fded5e551a54", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 0, "deletions": 157, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=f877b3adba2d9442752721d87c96f93beccd4c40", "patch": "@@ -77,153 +77,6 @@ isl_id_for_pbb (scop_p s, poly_bb_p pbb)\n   return isl_id_alloc (s->isl_context, name, pbb);\n }\n \n-#ifndef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n-/* Converts the STATIC_SCHEDULE of PBB into a scattering polyhedron.\n-   We generate SCATTERING_DIMENSIONS scattering dimensions.\n-\n-   The scattering polyhedron consists of these dimensions: scattering,\n-   loop_iterators, parameters.\n-\n-   Example:\n-\n-   | scattering_dimensions = 5\n-   | nb_iterators = 1\n-   | scop_nb_params = 2\n-   |\n-   | Schedule:\n-   |   i\n-   | 4 5\n-   |\n-   | Scattering polyhedron:\n-   |\n-   | scattering: {s1, s2, s3, s4, s5}\n-   | loop_iterators: {i}\n-   | parameters: {p1, p2}\n-   |\n-   | s1  s2  s3  s4  s5  i   p1  p2  1\n-   | 1   0   0   0   0   0   0   0  -4  = 0\n-   | 0   1   0   0   0  -1   0   0   0  = 0\n-   | 0   0   1   0   0   0   0   0  -5  = 0  */\n-\n-static void\n-build_pbb_scattering_polyhedrons (isl_aff *static_sched,\n-\t\t\t\t  poly_bb_p pbb)\n-{\n-  isl_val *val;\n-\n-  int scattering_dimensions = isl_set_dim (pbb->domain, isl_dim_set) * 2 + 1;\n-\n-  isl_space *dc = isl_set_get_space (pbb->domain);\n-  isl_space *dm = isl_space_add_dims (isl_space_from_domain (dc),\n-\t\t\t\t      isl_dim_out, scattering_dimensions);\n-  pbb->schedule = isl_map_universe (dm);\n-\n-  for (int i = 0; i < scattering_dimensions; i++)\n-    {\n-      /* Textual order inside this loop.  */\n-      if ((i % 2) == 0)\n-\t{\n-\t  isl_constraint *c = isl_equality_alloc\n-\t      (isl_local_space_from_space (isl_map_get_space (pbb->schedule)));\n-\n-\t  val = isl_aff_get_coefficient_val (static_sched, isl_dim_in, i / 2);\n-\t  gcc_assert (val && isl_val_is_int (val));\n-\n-\t  val = isl_val_neg (val);\n-\t  c = isl_constraint_set_constant_val (c, val);\n-\t  c = isl_constraint_set_coefficient_si (c, isl_dim_out, i, 1);\n-\t  pbb->schedule = isl_map_add_constraint (pbb->schedule, c);\n-\t}\n-\n-      /* Iterations of this loop.  */\n-      else /* if ((i % 2) == 1) */\n-\t{\n-\t  int loop = (i - 1) / 2;\n-\t  pbb->schedule = isl_map_equate (pbb->schedule, isl_dim_in, loop,\n-\t\t\t\t\t  isl_dim_out, i);\n-\t}\n-    }\n-\n-  /* Simplify the original schedule.  */\n-  pbb->schedule = isl_map_coalesce (pbb->schedule);\n-\n-  /* At the beginning, set the transformed schedule to the original.  */\n-  pbb->transformed = isl_map_copy (pbb->schedule);\n-}\n-\n-/* Build for BB the static schedule.\n-\n-   The static schedule is a Dewey numbering of the abstract syntax\n-   tree: http://en.wikipedia.org/wiki/Dewey_Decimal_Classification\n-\n-   The following example informally defines the static schedule:\n-\n-   A\n-   for (i: ...)\n-     {\n-       for (j: ...)\n-         {\n-           B\n-           C\n-         }\n-\n-       for (k: ...)\n-         {\n-           D\n-           E\n-         }\n-     }\n-   F\n-\n-   Static schedules for A to F:\n-\n-     DEPTH\n-     0 1 2\n-   A 0\n-   B 1 0 0\n-   C 1 0 1\n-   D 1 1 0\n-   E 1 1 1\n-   F 2\n-*/\n-\n-static void\n-build_scop_scattering (scop_p scop)\n-{\n-  gimple_poly_bb_p previous_gbb = NULL;\n-  isl_space *dc = isl_set_get_space (scop->param_context);\n-  isl_aff *static_sched;\n-\n-  dc = isl_space_add_dims (dc, isl_dim_set, number_of_loops (cfun));\n-  static_sched = isl_aff_zero_on_domain (isl_local_space_from_space (dc));\n-\n-  /* We have to start schedules at 0 on the first component and\n-     because we cannot compare_prefix_loops against a previous loop,\n-     prefix will be equal to zero, and that index will be\n-     incremented before copying.  */\n-  static_sched = isl_aff_add_coefficient_si (static_sched, isl_dim_in, 0, -1);\n-\n-  int i;\n-  poly_bb_p pbb;\n-  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n-    {\n-      gimple_poly_bb_p gbb = PBB_BLACK_BOX (pbb);\n-      int prefix = 0;\n-\n-      if (previous_gbb)\n-\tprefix = nb_common_loops (scop->scop_info->region, previous_gbb, gbb);\n-\n-      previous_gbb = gbb;\n-\n-      static_sched = isl_aff_add_coefficient_si (static_sched, isl_dim_in,\n-\t\t\t\t\t\t prefix, 1);\n-      build_pbb_scattering_polyhedrons (static_sched, pbb);\n-    }\n-\n-  isl_aff_free (static_sched);\n-}\n-#endif\n-\n static isl_pw_aff *extract_affine (scop_p, tree, __isl_take isl_space *space);\n \n /* Extract an affine expression from the chain of recurrence E.  */\n@@ -1009,9 +862,7 @@ build_iteration_domains (scop_p scop, __isl_keep isl_set *context,\n       loop_p loop = pbb_loop (pbb);\n       if (current == loop)\n \t{\n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n \t  pbb->iterators = isl_set_copy (domain);\n-#endif\n \t  pbb->domain = isl_set_copy (domain);\n \t  pbb->domain = isl_set_set_tuple_id (pbb->domain,\n \t\t\t\t\t      isl_id_for_pbb (scop, pbb));\n@@ -1069,8 +920,6 @@ build_scop_context (scop_p scop)\n     add_param_constraints (scop, p);\n }\n \n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n-\n /* Return true when loop A is nested in loop B.  */\n \n static bool\n@@ -1350,8 +1199,6 @@ build_original_schedule (scop_p scop)\n   return true;\n }\n \n-#endif\n-\n /* Builds the polyhedral representation for a SESE region.  */\n \n bool\n@@ -1365,11 +1212,7 @@ build_poly_scop (scop_p scop)\n     i = build_iteration_domains (scop, scop->param_context, i, NULL);\n \n   build_scop_drs (scop);\n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n   build_original_schedule (scop);\n-#else\n-  build_scop_scattering (scop);\n-#endif\n   return true;\n }\n #endif  /* HAVE_isl */"}, {"sha": "5103c614ff140da0e320570f99ddba0d53c72dd2", "filename": "gcc/graphite.h", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Fgraphite.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Fgraphite.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.h?ref=f877b3adba2d9442752721d87c96f93beccd4c40", "patch": "@@ -36,17 +36,8 @@ along with GCC; see the file COPYING3.  If not see\n #include <isl/ilp.h>\n #include <isl/schedule.h>\n #include <isl/ast_build.h>\n-\n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n-/* isl 0.15 or later.  */\n #include <isl/schedule_node.h>\n \n-#else\n-/* isl 0.14 or 0.13.  */\n-# define isl_stat int\n-# define isl_stat_ok 0\n-#endif\n-\n typedef struct poly_dr *poly_dr_p;\n \n typedef struct poly_bb *poly_bb_p;\n@@ -267,18 +258,7 @@ struct poly_bb\n      The number of variables in the DOMAIN may change and is not\n      related to the number of loops in the original code.  */\n   isl_set *domain;\n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n   isl_set *iterators;\n-#else\n-  /* The original scattering.  */\n-  isl_map *schedule;\n-\n-  /* The transformed scattering.  */\n-  isl_map *transformed;\n-\n-  /* A copy of the transformed scattering.  */\n-  isl_map *saved;\n-#endif\n \n   /* The data references we access.  */\n   vec<poly_dr_p> drs;\n@@ -425,16 +405,11 @@ struct scop\n   /* The context used internally by isl.  */\n   isl_ctx *isl_context;\n \n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n   /* SCoP original schedule.  */\n   isl_schedule *original_schedule;\n \n   /* SCoP transformed schedule.  */\n   isl_schedule *transformed_schedule;\n-#else\n-  /* SCoP final schedule.  */\n-  isl_schedule *schedule;\n-#endif\n \n   /* The data dependence relation among the data references in this scop.  */\n   isl_union_map *dependence;\n@@ -470,11 +445,7 @@ scop_set_nb_params (scop_p scop, graphite_dim_t nb_params)\n   scop->nb_params = nb_params;\n }\n \n-#ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n extern void scop_get_dependences (scop_p scop);\n-#else\n-extern isl_union_map *scop_get_dependences (scop_p scop);\n-#endif\n \n bool\n carries_deps (__isl_keep isl_union_map *schedule,"}, {"sha": "beb581aba559840d4989da35ff78dfa2cad9410f", "filename": "gcc/toplev.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f877b3adba2d9442752721d87c96f93beccd4c40/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=f877b3adba2d9442752721d87c96f93beccd4c40", "patch": "@@ -92,6 +92,10 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"selftest.h\"\n \n+#ifdef HAVE_isl\n+#include <isl/version.h>\n+#endif\n+\n static void general_init (const char *, bool);\n static void do_compile ();\n static void process_options (void);\n@@ -678,10 +682,8 @@ print_version (FILE *file, const char *indent, bool show_global_state)\n \t   GCC_GMP_STRINGIFY_VERSION, MPFR_VERSION_STRING, MPC_VERSION_STRING,\n #ifndef HAVE_isl\n \t   \"none\"\n-#elif HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n-\t   \"0.15\"\n #else\n-\t   \"0.14 or 0.13\"\n+\t   isl_version ()\n #endif\n \t   );\n   if (strcmp (GCC_GMP_STRINGIFY_VERSION, gmp_version))"}]}