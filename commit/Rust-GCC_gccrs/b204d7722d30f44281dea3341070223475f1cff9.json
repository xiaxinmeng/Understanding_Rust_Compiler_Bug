{"sha": "b204d7722d30f44281dea3341070223475f1cff9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjIwNGQ3NzIyZDMwZjQ0MjgxZGVhMzM0MTA3MDIyMzQ3NWYxY2ZmOQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-19T13:36:15Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-19T13:36:15Z"}, "message": "libstdc++: Move std::thread to a new header\n\nThis makes it possible to use std::thread without including the whole of\n<thread>. It also makes this_thread::get_id() and this_thread::yield()\navailable even when there is no gthreads support (e.g. when GCC is built\nwith --disable-threads or --enable-threads=single).\n\nIn order for the std::thread::id return type of this_thread::get_id() to\nbe defined, std:thread itself is defined unconditionally. However the\nconstructor that creates new threads is not defined for single-threaded\nbuilds. The thread::join() and thread::detach() member functions are\ndefined inline for single-threaded builds and just throw an exception\n(because we know the thread cannot be joinable if the constructor that\ncreates joinable threads doesn't exit).\n\nThe thread::hardware_concurrency() member function is also defined\ninline and returns 0 (as suggested by the standard when the value \"is\nnot computable or well-defined\").\n\nThe main benefit for most targets is that other headers such as <future>\ndo not need to include the whole of <thread> just to be able to create a\nstd::thread. That avoids including <stop_token> and std::jthread where\nnot required. This is another partial fix for PR 92546.\n\nThis also means we can use this_thread::get_id() and this_thread::yield()\nin <stop_token> instead of using the gthread functions directly. This\nremoves some preprocessor conditionals, simplifying the code.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/92546\n\t* include/Makefile.am: Add new <bits/std_thread.h> header.\n\t* include/Makefile.in: Regenerate.\n\t* include/std/future: Include new header instead of <thread>.\n\t* include/std/stop_token: Include new header instead of\n\t<bits/gthr.h>.\n\t(stop_token::_S_yield()): Use this_thread::yield().\n\t(_Stop_state_t::_M_requester): Change type to std::thread::id.\n\t(_Stop_state_t::_M_request_stop()): Use this_thread::get_id().\n\t(_Stop_state_t::_M_remove_callback(_Stop_cb*)): Likewise.\n\tUse __is_single_threaded() to decide whether to synchronize.\n\t* include/std/thread (thread, operator==, this_thread::get_id)\n\t(this_thread::yield): Move to new header.\n\t(operator<=>, operator!=, operator<, operator<=, operator>)\n\t(operator>=, hash<thread::id>, operator<<): Define even when\n\tgthreads not available.\n\t* src/c++11/thread.cc: Include <memory>.\n\t* include/bits/std_thread.h: New file.\n\t(thread, operator==, this_thread::get_id, this_thread::yield):\n\tDefine even when gthreads not available.\n\t[!_GLIBCXX_HAS_GTHREADS] (thread::join, thread::detach)\n\t(thread::hardware_concurrency): Define inline.", "tree": {"sha": "daaee15e0f5b59f0985c723f7e6cbe8a2ddba2ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/daaee15e0f5b59f0985c723f7e6cbe8a2ddba2ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b204d7722d30f44281dea3341070223475f1cff9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b204d7722d30f44281dea3341070223475f1cff9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b204d7722d30f44281dea3341070223475f1cff9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b204d7722d30f44281dea3341070223475f1cff9/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b108faa9400e13a3d00dd7f71cff0ac45e29c5c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b108faa9400e13a3d00dd7f71cff0ac45e29c5c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b108faa9400e13a3d00dd7f71cff0ac45e29c5c9"}], "stats": {"total": 645, "additions": 362, "deletions": 283}, "files": [{"sha": "7979f1c589d600981d532825daa724a969a7e649", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b204d7722d30f44281dea3341070223475f1cff9/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b204d7722d30f44281dea3341070223475f1cff9/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=b204d7722d30f44281dea3341070223475f1cff9", "patch": "@@ -187,6 +187,7 @@ bits_headers = \\\n \t${bits_srcdir}/std_abs.h \\\n \t${bits_srcdir}/std_function.h \\\n \t${bits_srcdir}/std_mutex.h \\\n+\t${bits_srcdir}/std_thread.h \\\n \t${bits_srcdir}/stl_algo.h \\\n \t${bits_srcdir}/stl_algobase.h \\\n \t${bits_srcdir}/stl_bvector.h \\"}, {"sha": "dfa72b95547c413dd8ffda33c0cce09a1de557b3", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b204d7722d30f44281dea3341070223475f1cff9/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b204d7722d30f44281dea3341070223475f1cff9/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=b204d7722d30f44281dea3341070223475f1cff9", "patch": "@@ -533,6 +533,7 @@ bits_headers = \\\n \t${bits_srcdir}/std_abs.h \\\n \t${bits_srcdir}/std_function.h \\\n \t${bits_srcdir}/std_mutex.h \\\n+\t${bits_srcdir}/std_thread.h \\\n \t${bits_srcdir}/stl_algo.h \\\n \t${bits_srcdir}/stl_algobase.h \\\n \t${bits_srcdir}/stl_bvector.h \\"}, {"sha": "96c8d1bb19ff0b93e29a19c20d611a4cf191b027", "filename": "libstdc++-v3/include/bits/std_thread.h", "status": "added", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b204d7722d30f44281dea3341070223475f1cff9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b204d7722d30f44281dea3341070223475f1cff9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_thread.h?ref=b204d7722d30f44281dea3341070223475f1cff9", "patch": "@@ -0,0 +1,337 @@\n+// std::thread declarations -*- C++ -*-\n+\n+// Copyright (C) 2008-2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/std_thread.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{thread}\n+ */\n+\n+#ifndef _GLIBCXX_THREAD_H\n+#define _GLIBCXX_THREAD_H 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus >= 201103L\n+#include <bits/c++config.h>\n+\n+#include <exception>\t\t// std::terminate\n+#include <iosfwd>\t\t// std::basic_ostream\n+#include <tuple>\t\t// std::tuple\n+#include <bits/invoke.h>\t// std::__invoke\n+#include <bits/refwrap.h>       // not required, but helpful to users\n+#include <bits/unique_ptr.h>\t// std::unique_ptr\n+\n+#ifdef _GLIBCXX_HAS_GTHREADS\n+# include <bits/gthr.h>\n+#else\n+# include <errno.h>\n+# include <bits/functexcept.h>\n+#endif\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /** @addtogroup threads\n+   *  @{\n+   */\n+\n+  /// thread\n+  class thread\n+  {\n+  public:\n+#ifdef _GLIBCXX_HAS_GTHREADS\n+    // Abstract base class for types that wrap arbitrary functors to be\n+    // invoked in the new thread of execution.\n+    struct _State\n+    {\n+      virtual ~_State();\n+      virtual void _M_run() = 0;\n+    };\n+    using _State_ptr = unique_ptr<_State>;\n+\n+    using native_handle_type = __gthread_t;\n+#else\n+    using native_handle_type = int;\n+#endif\n+\n+    /// thread::id\n+    class id\n+    {\n+      native_handle_type\t_M_thread;\n+\n+    public:\n+      id() noexcept : _M_thread() { }\n+\n+      explicit\n+      id(native_handle_type __id) : _M_thread(__id) { }\n+\n+    private:\n+      friend class thread;\n+      friend struct hash<id>;\n+\n+      friend bool\n+      operator==(id __x, id __y) noexcept;\n+\n+#if __cpp_lib_three_way_comparison\n+      friend strong_ordering\n+      operator<=>(id __x, id __y) noexcept;\n+#else\n+      friend bool\n+      operator<(id __x, id __y) noexcept;\n+#endif\n+\n+      template<class _CharT, class _Traits>\n+\tfriend basic_ostream<_CharT, _Traits>&\n+\toperator<<(basic_ostream<_CharT, _Traits>& __out, id __id);\n+    };\n+\n+  private:\n+    id\t\t\t\t_M_id;\n+\n+    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+    // 2097.  packaged_task constructors should be constrained\n+    // 3039. Unnecessary decay in thread and packaged_task\n+    template<typename _Tp>\n+      using __not_same = __not_<is_same<__remove_cvref_t<_Tp>, thread>>;\n+\n+  public:\n+    thread() noexcept = default;\n+\n+#ifdef _GLIBCXX_HAS_GTHREADS\n+    template<typename _Callable, typename... _Args,\n+\t     typename = _Require<__not_same<_Callable>>>\n+      explicit\n+      thread(_Callable&& __f, _Args&&... __args)\n+      {\n+\tstatic_assert( __is_invocable<typename decay<_Callable>::type,\n+\t\t\t\t      typename decay<_Args>::type...>::value,\n+\t  \"std::thread arguments must be invocable after conversion to rvalues\"\n+\t  );\n+\n+#ifdef GTHR_ACTIVE_PROXY\n+\t// Create a reference to pthread_create, not just the gthr weak symbol.\n+\tauto __depend = reinterpret_cast<void(*)()>(&pthread_create);\n+#else\n+\tauto __depend = nullptr;\n+#endif\n+\tusing _Wrapper = _Call_wrapper<_Callable, _Args...>;\n+\t// Create a call wrapper with DECAY_COPY(__f) as its target object\n+\t// and DECAY_COPY(__args)... as its bound argument entities.\n+\t_M_start_thread(_State_ptr(new _State_impl<_Wrapper>(\n+\t      std::forward<_Callable>(__f), std::forward<_Args>(__args)...)),\n+\t    __depend);\n+      }\n+#endif // _GLIBCXX_HAS_GTHREADS\n+\n+    ~thread()\n+    {\n+      if (joinable())\n+\tstd::terminate();\n+    }\n+\n+    thread(const thread&) = delete;\n+\n+    thread(thread&& __t) noexcept\n+    { swap(__t); }\n+\n+    thread& operator=(const thread&) = delete;\n+\n+    thread& operator=(thread&& __t) noexcept\n+    {\n+      if (joinable())\n+\tstd::terminate();\n+      swap(__t);\n+      return *this;\n+    }\n+\n+    void\n+    swap(thread& __t) noexcept\n+    { std::swap(_M_id, __t._M_id); }\n+\n+    bool\n+    joinable() const noexcept\n+    { return !(_M_id == id()); }\n+\n+    void\n+    join();\n+\n+    void\n+    detach();\n+\n+    id\n+    get_id() const noexcept\n+    { return _M_id; }\n+\n+    /** @pre thread is joinable\n+     */\n+    native_handle_type\n+    native_handle()\n+    { return _M_id._M_thread; }\n+\n+    // Returns a value that hints at the number of hardware thread contexts.\n+    static unsigned int\n+    hardware_concurrency() noexcept;\n+\n+#ifdef _GLIBCXX_HAS_GTHREADS\n+  private:\n+    template<typename _Callable>\n+      struct _State_impl : public _State\n+      {\n+\t_Callable\t\t_M_func;\n+\n+\ttemplate<typename... _Args>\n+\t  _State_impl(_Args&&... __args)\n+\t  : _M_func{{std::forward<_Args>(__args)...}}\n+\t  { }\n+\n+\tvoid\n+\t_M_run() { _M_func(); }\n+      };\n+\n+    void\n+    _M_start_thread(_State_ptr, void (*)());\n+\n+#if _GLIBCXX_THREAD_ABI_COMPAT\n+  public:\n+    struct _Impl_base;\n+    typedef shared_ptr<_Impl_base>\t__shared_base_type;\n+    struct _Impl_base\n+    {\n+      __shared_base_type\t_M_this_ptr;\n+      virtual ~_Impl_base() = default;\n+      virtual void _M_run() = 0;\n+    };\n+\n+  private:\n+    void\n+    _M_start_thread(__shared_base_type, void (*)());\n+\n+    void\n+    _M_start_thread(__shared_base_type);\n+#endif\n+\n+  private:\n+    // A call wrapper that does INVOKE(forwarded tuple elements...)\n+    template<typename _Tuple>\n+      struct _Invoker\n+      {\n+\t_Tuple _M_t;\n+\n+\ttemplate<typename>\n+\t  struct __result;\n+\ttemplate<typename _Fn, typename... _Args>\n+\t  struct __result<tuple<_Fn, _Args...>>\n+\t  : __invoke_result<_Fn, _Args...>\n+\t  { };\n+\n+\ttemplate<size_t... _Ind>\n+\t  typename __result<_Tuple>::type\n+\t  _M_invoke(_Index_tuple<_Ind...>)\n+\t  { return std::__invoke(std::get<_Ind>(std::move(_M_t))...); }\n+\n+\ttypename __result<_Tuple>::type\n+\toperator()()\n+\t{\n+\t  using _Indices\n+\t    = typename _Build_index_tuple<tuple_size<_Tuple>::value>::__type;\n+\t  return _M_invoke(_Indices());\n+\t}\n+      };\n+\n+  public:\n+    template<typename... _Tp>\n+      using _Call_wrapper = _Invoker<tuple<typename decay<_Tp>::type...>>;\n+#endif // _GLIBCXX_HAS_GTHREADS\n+  };\n+\n+#ifndef _GLIBCXX_HAS_GTHREADS\n+  inline void thread::join() { std::__throw_system_error(EINVAL); }\n+  inline void thread::detach() { std::__throw_system_error(EINVAL); }\n+  inline unsigned int thread::hardware_concurrency() { return 0; }\n+#endif\n+\n+  inline void\n+  swap(thread& __x, thread& __y) noexcept\n+  { __x.swap(__y); }\n+\n+  inline bool\n+  operator==(thread::id __x, thread::id __y) noexcept\n+  {\n+    // pthread_equal is undefined if either thread ID is not valid, so we\n+    // can't safely use __gthread_equal on default-constructed values (nor\n+    // the non-zero value returned by this_thread::get_id() for\n+    // single-threaded programs using GNU libc). Assume EqualityComparable.\n+    return __x._M_thread == __y._M_thread;\n+  }\n+\n+  // N.B. other comparison operators are defined in <thread>\n+\n+  namespace this_thread\n+  {\n+    /// this_thread::get_id\n+    inline thread::id\n+    get_id() noexcept\n+    {\n+#ifdef _GLIBCXX_HAS_GTHREADS\n+\n+#ifdef __GLIBC__\n+      // For the GNU C library pthread_self() is usable without linking to\n+      // libpthread, but prior to version 2.27 the version in libc returns 0,\n+      // which breaks the invariant this_thread::get_id() != thread::id{}.\n+      //\n+      // We know that pthread_t is a scalar type in the GNU C library,\n+      // so just use (__gthread_t)1 as the ID of the main (and only) thread.\n+      //\n+      // This uses __gthread_active_p not __gnu_cxx::__is_single_threaded\n+      // because we don't want the thread::id of the main thread to change\n+      // if additional threads are created later.\n+      if (!__gthread_active_p())\n+\treturn thread::id((__gthread_t)1);\n+#endif\n+\n+      return thread::id(__gthread_self());\n+#else\n+      return thread::id(1);\n+#endif\n+    }\n+\n+    /// this_thread::yield\n+    inline void\n+    yield() noexcept\n+    {\n+#if defined _GLIBCXX_HAS_GTHREADS && defined _GLIBCXX_USE_SCHED_YIELD\n+      __gthread_yield();\n+#endif\n+    }\n+\n+  } // namespace this_thread\n+\n+  /// @}\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace\n+#endif // C++11\n+\n+#endif // _GLIBCXX_THREAD_H"}, {"sha": "77b6f930f00afc1b6a49c8e6ca1cdc90f270a2a4", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b204d7722d30f44281dea3341070223475f1cff9/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b204d7722d30f44281dea3341070223475f1cff9/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=b204d7722d30f44281dea3341070223475f1cff9", "patch": "@@ -36,7 +36,6 @@\n #else\n \n #include <mutex>\t      // call_once\n-#include <thread>\n #include <condition_variable> // __at_thread_exit_elt\n #include <system_error>\n #include <atomic>\n@@ -46,6 +45,7 @@\n #include <bits/unique_ptr.h>\n #include <bits/shared_ptr.h>\n #include <bits/std_function.h>\n+#include <bits/std_thread.h>\n #include <bits/uses_allocator.h>\n #include <ext/aligned_buffer.h>\n "}, {"sha": "5b2d5a0427c7d75ee57795c71b02e337926f20cb", "filename": "libstdc++-v3/include/std/stop_token", "status": "modified", "additions": 12, "deletions": 25, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b204d7722d30f44281dea3341070223475f1cff9/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstop_token", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b204d7722d30f44281dea3341070223475f1cff9/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstop_token", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstop_token?ref=b204d7722d30f44281dea3341070223475f1cff9", "patch": "@@ -32,15 +32,14 @@\n #if __cplusplus > 201703L\n \n #include <atomic>\n+#include <bits/std_thread.h>\n \n-#ifdef _GLIBCXX_HAS_GTHREADS\n-# define __cpp_lib_jthread 201911L\n-# include <bits/gthr.h>\n-# if __has_include(<semaphore>)\n-#  include <semaphore>\n-# endif\n+#if __has_include(<semaphore>)\n+# include <semaphore>\n #endif\n \n+#define __cpp_lib_jthread 201911L\n+\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n@@ -105,9 +104,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n #if defined __i386__ || defined __x86_64__\n       __builtin_ia32_pause();\n-#elif defined _GLIBCXX_HAS_GTHREADS && defined _GLIBCXX_USE_SCHED_YIELD\n-      __gthread_yield();\n #endif\n+      this_thread::yield();\n     }\n \n #ifndef __cpp_lib_semaphore\n@@ -162,18 +160,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       std::atomic<value_type> _M_owners{1};\n       std::atomic<value_type> _M_value{_S_ssrc_counter_inc};\n       _Stop_cb* _M_head = nullptr;\n-      struct\n-      {\n-#ifdef _GLIBCXX_HAS_GTHREADS\n-\t__gthread_t _M_id;\n-\tvoid _M_set() { _M_id = __gthread_self(); }\n-\tbool _M_is_current_thread() const\n-\t{ return __gthread_equal(_M_id, __gthread_self()); }\n-#else\n-\tvoid _M_set() { }\n-\tconstexpr bool _M_is_current_thread() const { return true; }\n-#endif\n-      } _M_requester;\n+      std::thread::id _M_requester;\n \n       _Stop_state_t() = default;\n \n@@ -246,7 +233,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  }\n \twhile (!_M_try_lock_and_stop(__old));\n \n-\t_M_requester._M_set();\n+\t_M_requester = this_thread::get_id();\n \n \twhile (_M_head)\n \t  {\n@@ -273,10 +260,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    if (!__destroyed)\n \t      {\n \t\t__cb->_M_destroyed = nullptr;\n-#ifdef _GLIBCXX_HAS_GTHREADS\n+\n \t\t// synchronize with destructor of stop_callback that owns *__cb\n-\t\t__cb->_M_done.release();\n-#endif\n+\t\tif (!__gnu_cxx::__is_single_threaded())\n+\t\t  __cb->_M_done.release();\n \t      }\n \n \t    // Avoid relocking if we already know there are no more callbacks.\n@@ -353,7 +340,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t// Despite appearances there is no data race on _M_requester. The only\n \t// write to it happens before the callback is removed from the list,\n \t// and removing it from the list happens before this read.\n-\tif (!_M_requester._M_is_current_thread())\n+\tif (!(_M_requester == this_thread::get_id()))\n \t  {\n \t    // Synchronize with completion of callback.\n \t    __cb->_M_done.acquire();"}, {"sha": "6ea8a51c0cf88cfecf8dd7c7cefb9cd9cdba99c7", "filename": "libstdc++-v3/include/std/thread", "status": "modified", "additions": 9, "deletions": 257, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b204d7722d30f44281dea3341070223475f1cff9/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b204d7722d30f44281dea3341070223475f1cff9/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fthread?ref=b204d7722d30f44281dea3341070223475f1cff9", "patch": "@@ -37,26 +37,18 @@\n \n #include <chrono> // std::chrono::*\n \n-#ifdef _GLIBCXX_USE_NANOSLEEP\n-# include <cerrno>  // errno, EINTR\n-# include <time.h>  // nanosleep\n-#endif\n-\n-#if defined(_GLIBCXX_HAS_GTHREADS)\n-#include <bits/gthr.h>\n-\n-#include <memory> // std::unique_ptr\n-#include <tuple>  // std::tuple\n-\n #if __cplusplus > 201703L\n # include <compare>\t// std::strong_ordering\n # include <stop_token>\t// std::stop_source, std::stop_token, std::nostopstate\n #endif\n \n+#include <bits/std_thread.h> // std::thread, get_id, yield\n #include <bits/functional_hash.h> // std::hash\n-#include <bits/invoke.h>\t  // std::__invoke\n \n-#endif // _GLIBCXX_HAS_GTHREADS\n+#ifdef _GLIBCXX_USE_NANOSLEEP\n+# include <cerrno>  // errno, EINTR\n+# include <time.h>  // nanosleep\n+#endif\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n@@ -70,221 +62,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * @{\n    */\n \n-#if defined(_GLIBCXX_HAS_GTHREADS)\n-  /// thread\n-  class thread\n-  {\n-  public:\n-    // Abstract base class for types that wrap arbitrary functors to be\n-    // invoked in the new thread of execution.\n-    struct _State\n-    {\n-      virtual ~_State();\n-      virtual void _M_run() = 0;\n-    };\n-    using _State_ptr = unique_ptr<_State>;\n-\n-    typedef __gthread_t\t\t\tnative_handle_type;\n-\n-    /// thread::id\n-    class id\n-    {\n-      native_handle_type\t_M_thread;\n-\n-    public:\n-      id() noexcept : _M_thread() { }\n-\n-      explicit\n-      id(native_handle_type __id) : _M_thread(__id) { }\n-\n-    private:\n-      friend class thread;\n-      friend struct hash<id>;\n-\n-      friend bool\n-      operator==(id __x, id __y) noexcept;\n-\n-#if __cpp_lib_three_way_comparison\n-      friend strong_ordering\n-      operator<=>(id __x, id __y) noexcept;\n-#else\n-      friend bool\n-      operator<(id __x, id __y) noexcept;\n-#endif\n-\n-      template<class _CharT, class _Traits>\n-\tfriend basic_ostream<_CharT, _Traits>&\n-\toperator<<(basic_ostream<_CharT, _Traits>& __out, id __id);\n-    };\n-\n-  private:\n-    id\t\t\t\t_M_id;\n-\n-    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-    // 2097.  packaged_task constructors should be constrained\n-    // 3039. Unnecessary decay in thread and packaged_task\n-    template<typename _Tp>\n-      using __not_same = __not_<is_same<__remove_cvref_t<_Tp>, thread>>;\n-\n-  public:\n-    thread() noexcept = default;\n-\n-    template<typename _Callable, typename... _Args,\n-\t     typename = _Require<__not_same<_Callable>>>\n-      explicit\n-      thread(_Callable&& __f, _Args&&... __args)\n-      {\n-\tstatic_assert( __is_invocable<typename decay<_Callable>::type,\n-\t\t\t\t      typename decay<_Args>::type...>::value,\n-\t  \"std::thread arguments must be invocable after conversion to rvalues\"\n-\t  );\n-\n-#ifdef GTHR_ACTIVE_PROXY\n-\t// Create a reference to pthread_create, not just the gthr weak symbol.\n-\tauto __depend = reinterpret_cast<void(*)()>(&pthread_create);\n-#else\n-\tauto __depend = nullptr;\n-#endif\n-\tusing _Wrapper = _Call_wrapper<_Callable, _Args...>;\n-\t// Create a call wrapper with DECAY_COPY(__f) as its target object\n-\t// and DECAY_COPY(__args)... as its bound argument entities.\n-\t_M_start_thread(_State_ptr(new _State_impl<_Wrapper>(\n-\t      std::forward<_Callable>(__f), std::forward<_Args>(__args)...)),\n-\t    __depend);\n-      }\n-\n-    ~thread()\n-    {\n-      if (joinable())\n-\tstd::terminate();\n-    }\n-\n-    thread(const thread&) = delete;\n-\n-    thread(thread&& __t) noexcept\n-    { swap(__t); }\n-\n-    thread& operator=(const thread&) = delete;\n-\n-    thread& operator=(thread&& __t) noexcept\n-    {\n-      if (joinable())\n-\tstd::terminate();\n-      swap(__t);\n-      return *this;\n-    }\n-\n-    void\n-    swap(thread& __t) noexcept\n-    { std::swap(_M_id, __t._M_id); }\n-\n-    bool\n-    joinable() const noexcept\n-    { return !(_M_id == id()); }\n-\n-    void\n-    join();\n-\n-    void\n-    detach();\n-\n-    id\n-    get_id() const noexcept\n-    { return _M_id; }\n-\n-    /** @pre thread is joinable\n-     */\n-    native_handle_type\n-    native_handle()\n-    { return _M_id._M_thread; }\n-\n-    // Returns a value that hints at the number of hardware thread contexts.\n-    static unsigned int\n-    hardware_concurrency() noexcept;\n-\n-  private:\n-    template<typename _Callable>\n-      struct _State_impl : public _State\n-      {\n-\t_Callable\t\t_M_func;\n-\n-\ttemplate<typename... _Args>\n-\t  _State_impl(_Args&&... __args)\n-\t  : _M_func{{std::forward<_Args>(__args)...}}\n-\t  { }\n-\n-\tvoid\n-\t_M_run() { _M_func(); }\n-      };\n-\n-    void\n-    _M_start_thread(_State_ptr, void (*)());\n-\n-#if _GLIBCXX_THREAD_ABI_COMPAT\n-  public:\n-    struct _Impl_base;\n-    typedef shared_ptr<_Impl_base>\t__shared_base_type;\n-    struct _Impl_base\n-    {\n-      __shared_base_type\t_M_this_ptr;\n-      virtual ~_Impl_base() = default;\n-      virtual void _M_run() = 0;\n-    };\n-\n-  private:\n-    void\n-    _M_start_thread(__shared_base_type, void (*)());\n-\n-    void\n-    _M_start_thread(__shared_base_type);\n-#endif\n-\n-  private:\n-    // A call wrapper that does INVOKE(forwarded tuple elements...)\n-    template<typename _Tuple>\n-      struct _Invoker\n-      {\n-\t_Tuple _M_t;\n-\n-\ttemplate<typename>\n-\t  struct __result;\n-\ttemplate<typename _Fn, typename... _Args>\n-\t  struct __result<tuple<_Fn, _Args...>>\n-\t  : __invoke_result<_Fn, _Args...>\n-\t  { };\n-\n-\ttemplate<size_t... _Ind>\n-\t  typename __result<_Tuple>::type\n-\t  _M_invoke(_Index_tuple<_Ind...>)\n-\t  { return std::__invoke(std::get<_Ind>(std::move(_M_t))...); }\n-\n-\ttypename __result<_Tuple>::type\n-\toperator()()\n-\t{\n-\t  using _Indices\n-\t    = typename _Build_index_tuple<tuple_size<_Tuple>::value>::__type;\n-\t  return _M_invoke(_Indices());\n-\t}\n-      };\n-\n-  public:\n-    template<typename... _Tp>\n-      using _Call_wrapper = _Invoker<tuple<typename decay<_Tp>::type...>>;\n-  };\n-\n-  inline void\n-  swap(thread& __x, thread& __y) noexcept\n-  { __x.swap(__y); }\n-\n-  inline bool\n-  operator==(thread::id __x, thread::id __y) noexcept\n-  {\n-    // pthread_equal is undefined if either thread ID is not valid, so we\n-    // can't safely use __gthread_equal on default-constructed values (nor\n-    // the non-zero value returned by this_thread::get_id() for\n-    // single-threaded programs using GNU libc). Assume EqualityComparable.\n-    return __x._M_thread == __y._M_thread;\n-  }\n+  // std::thread is defined in <bits/std_thread.h>\n \n #if __cpp_lib_three_way_comparison\n   inline strong_ordering\n@@ -336,7 +114,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       else\n \treturn __out << __id._M_thread;\n     }\n-#endif // _GLIBCXX_HAS_GTHREADS\n \n   /** @namespace std::this_thread\n    *  @brief ISO C++ 2011 namespace for interacting with the current thread\n@@ -345,36 +122,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    */\n   namespace this_thread\n   {\n-#if defined _GLIBCXX_HAS_GTHREADS\n-    /// get_id\n-    inline thread::id\n-    get_id() noexcept\n-    {\n-#ifdef __GLIBC__\n-      // For the GNU C library pthread_self() is usable without linking to\n-      // libpthread.so but returns 0, so we cannot use it in single-threaded\n-      // programs, because this_thread::get_id() != thread::id{} must be true.\n-      // We know that pthread_t is an integral type in the GNU C library.\n-      if (!__gthread_active_p())\n-\treturn thread::id(1);\n-#endif\n-      return thread::id(__gthread_self());\n-    }\n-#endif // _GLIBCXX_HAS_GTHREADS\n-\n-    /// yield\n-    inline void\n-    yield() noexcept\n-    {\n-#if defined _GLIBCXX_HAS_GTHREADS && defined _GLIBCXX_USE_SCHED_YIELD\n-      __gthread_yield();\n-#endif\n-    }\n-\n     void\n     __sleep_for(chrono::seconds, chrono::nanoseconds);\n \n-    /// sleep_for\n+    /// this_thread::sleep_for\n     template<typename _Rep, typename _Period>\n       inline void\n       sleep_for(const chrono::duration<_Rep, _Period>& __rtime)\n@@ -396,7 +147,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #endif\n       }\n \n-    /// sleep_until\n+    /// this_thread::sleep_until\n     template<typename _Clock, typename _Duration>\n       inline void\n       sleep_until(const chrono::time_point<_Clock, _Duration>& __atime)\n@@ -421,6 +172,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n #ifdef __cpp_lib_jthread\n \n+  /// A thread that can be requested to stop and automatically joined.\n   class jthread\n   {\n   public:"}, {"sha": "e4dd1687a4b25f3106f1233d5af697b90461bf1d", "filename": "libstdc++-v3/src/c++11/thread.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b204d7722d30f44281dea3341070223475f1cff9/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fthread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b204d7722d30f44281dea3341070223475f1cff9/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fthread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fthread.cc?ref=b204d7722d30f44281dea3341070223475f1cff9", "patch": "@@ -24,6 +24,7 @@\n \n \n #define _GLIBCXX_THREAD_ABI_COMPAT 1\n+#include <memory> // include this first so <thread> can use shared_ptr\n #include <thread>\n #include <system_error>\n #include <cerrno>"}]}