{"sha": "10861e9a234fde12c33432d7744940526560a5e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTA4NjFlOWEyMzRmZGUxMmMzMzQzMmQ3NzQ0OTQwNTI2NTYwYTVlOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-26T21:24:01Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-04-26T21:24:01Z"}, "message": "(finish_struct): Add ATTRIBUTES argument, call decl_attributes and set DECL_PACKED from TYPE_PACKED.\n\n(finish_struct): Add ATTRIBUTES argument, call decl_attributes and set\nDECL_PACKED from TYPE_PACKED.\n(finish_enum): Add ATTRIBUTES argument, call decl_attributes, and make enum\nnarrow if TYPE_PACKED.\n\nFrom-SVN: r9486", "tree": {"sha": "7eda7c7a370250752d1a818c16c63956f941818c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7eda7c7a370250752d1a818c16c63956f941818c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10861e9a234fde12c33432d7744940526560a5e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10861e9a234fde12c33432d7744940526560a5e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10861e9a234fde12c33432d7744940526560a5e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10861e9a234fde12c33432d7744940526560a5e9/comments", "author": null, "committer": null, "parents": [{"sha": "a89ca5c67eea6e16f22b4325be029484ab8ebcc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a89ca5c67eea6e16f22b4325be029484ab8ebcc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a89ca5c67eea6e16f22b4325be029484ab8ebcc2"}], "stats": {"total": 24, "additions": 18, "deletions": 6}, "files": [{"sha": "06dff74c57cb416d64c9347e1580d39a58831361", "filename": "gcc/c-decl.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10861e9a234fde12c33432d7744940526560a5e9/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10861e9a234fde12c33432d7744940526560a5e9/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=10861e9a234fde12c33432d7744940526560a5e9", "patch": "@@ -5383,12 +5383,15 @@ field_decl_cmp (x, y)\n \n /* Fill in the fields of a RECORD_TYPE or UNION_TYPE node, T.\n    FIELDLIST is a chain of FIELD_DECL nodes for the fields.\n+   ATTRIBUTES are attributes to be applied to the structure.\n \n    We also do a pop_obstacks to match the push in start_struct.  */\n \n tree\n-finish_struct (t, fieldlist)\n-     register tree t, fieldlist;\n+finish_struct (t, fieldlist, attributes)\n+     tree t;\n+     tree fieldlist;\n+     tree attributes;\n {\n   register tree x;\n   int old_momentary;\n@@ -5399,6 +5402,8 @@ finish_struct (t, fieldlist)\n \n   TYPE_SIZE (t) = 0;\n \n+  decl_attributes (t, attributes, NULL_TREE);\n+\n   /* Nameless union parm types are useful as GCC extension.  */\n   if (! (TREE_CODE (t) == UNION_TYPE && TYPE_NAME (t) == 0) && !pedantic)\n     /* Otherwise, warn about any struct or union def. in parmlist.  */\n@@ -5428,6 +5433,7 @@ finish_struct (t, fieldlist)\n   for (x = fieldlist; x; x = TREE_CHAIN (x))\n     {\n       DECL_CONTEXT (x) = t;\n+      DECL_PACKED (x) = TYPE_PACKED (t);\n       DECL_FIELD_SIZE (x) = 0;\n \n       /* If any field is const, the structure type is pseudo-const.  */\n@@ -5763,12 +5769,15 @@ start_enum (name)\n \n /* After processing and defining all the values of an enumeration type,\n    install their decls in the enumeration type and finish it off.\n-   ENUMTYPE is the type object and VALUES a list of decl-value pairs.\n+   ENUMTYPE is the type object, VALUES a list of decl-value pairs,\n+   and ATTRIBUTES are the specified attributes.\n    Returns ENUMTYPE.  */\n \n tree\n-finish_enum (enumtype, values)\n-     register tree enumtype, values;\n+finish_enum (enumtype, values, attributes)\n+     tree enumtype;\n+     tree values;\n+     tree attributes;\n {\n   register tree pair, tem;\n   tree minnode = 0, maxnode = 0;\n@@ -5778,6 +5787,8 @@ finish_enum (enumtype, values)\n   if (in_parm_level_p ())\n     warning (\"enum defined inside parms\");\n \n+  decl_attributes (enumtype, attributes, NULL_TREE);\n+\n   /* Calculate the maximum value of any enumerator in this type.  */\n \n   if (values == error_mark_node)\n@@ -5809,7 +5820,8 @@ finish_enum (enumtype, values)\n   highprec = min_precision (maxnode, TREE_UNSIGNED (enumtype));\n   precision = MAX (lowprec, highprec);\n \n-  if (flag_short_enums || precision > TYPE_PRECISION (integer_type_node))\n+  if (flag_short_enums || TYPE_PACKED (enumtype)\n+      || precision > TYPE_PRECISION (integer_type_node))\n     /* Use the width of the narrowest normal C type which is wide enough.  */\n     TYPE_PRECISION (enumtype) = TYPE_PRECISION (type_for_size (precision, 1));\n   else"}]}