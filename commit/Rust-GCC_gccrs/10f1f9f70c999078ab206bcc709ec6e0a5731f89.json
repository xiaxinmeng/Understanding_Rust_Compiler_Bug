{"sha": "10f1f9f70c999078ab206bcc709ec6e0a5731f89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBmMWY5ZjcwYzk5OTA3OGFiMjA2YmNjNzA5ZWM2ZTBhNTczMWY4OQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2007-01-10T23:44:46Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2007-01-10T23:44:46Z"}, "message": "* HACKING: Various updates.\n\nFrom-SVN: r120653", "tree": {"sha": "b3dc88f199c1b7d30c32c7650a8d4e14d2de6614", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3dc88f199c1b7d30c32c7650a8d4e14d2de6614"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10f1f9f70c999078ab206bcc709ec6e0a5731f89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10f1f9f70c999078ab206bcc709ec6e0a5731f89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10f1f9f70c999078ab206bcc709ec6e0a5731f89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10f1f9f70c999078ab206bcc709ec6e0a5731f89/comments", "author": null, "committer": null, "parents": [{"sha": "ea517ca550bf8a1bed19dda72e731d717465850c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea517ca550bf8a1bed19dda72e731d717465850c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea517ca550bf8a1bed19dda72e731d717465850c"}], "stats": {"total": 41, "additions": 35, "deletions": 6}, "files": [{"sha": "05b62253cdaf0053b5a5c00f3ec7870c428ce4f4", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f1f9f70c999078ab206bcc709ec6e0a5731f89/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f1f9f70c999078ab206bcc709ec6e0a5731f89/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=10f1f9f70c999078ab206bcc709ec6e0a5731f89", "patch": "@@ -1,3 +1,7 @@\n+2007-01-10  Tom Tromey  <tromey@redhat.com>\n+\n+\t* HACKING: Various updates.\n+\n 2007-01-10  Tom Tromey  <tromey@redhat.com>\n \n \t* java/lang/natDouble.cc (toString): Added parens."}, {"sha": "f32a3a577d9a5c703e9b7b06515b57c358158a6d", "filename": "libjava/HACKING", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10f1f9f70c999078ab206bcc709ec6e0a5731f89/libjava%2FHACKING", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10f1f9f70c999078ab206bcc709ec6e0a5731f89/libjava%2FHACKING", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FHACKING?ref=10f1f9f70c999078ab206bcc709ec6e0a5731f89", "patch": "@@ -7,6 +7,33 @@ explained in this HACKING file. Please add them if you discover them :)\n \n --\n \n+If you plan to modify a .java file, you will need to configure with\n+--enable-java-maintainer-mode.  In order to make this work properly,\n+you will need to have 'ecj1' and 'gjavah' executables in your PATH at\n+build time.\n+\n+One way to do this is to download ecj.jar (see contrib/download_ecj)\n+and write a simple wrapper script like:\n+\n+    #! /bin/sh\n+    gij -cp /home/tromey/gnu/Generics/trunk/ecj.jar \\\n+       org.eclipse.jdt.internal.compiler.batch.GCCMain \\\n+       ${1+\"$@\"}\n+\n+For gjavah, you can make a tools.zip from the classes in\n+classpath/lib/tools/ and write a gjavah script like:\n+\n+    #! /bin/sh\n+    dir=/home/tromey/gnu/Generics/Gcjh\n+    gij -cp $dir/tools.zip \\\n+       gnu.classpath.tools.javah.Main \\\n+       ${1+\"$@\"}\n+\n+Another way to get a version of gjavah is to first do a\n+non-maintainer-mode build and use the newly installed gjavah.\n+\n+--\n+\n libgcj uses GNU Classpath as an upstream provider.  Snapshots of\n Classpath are imported into the libgcj source tree.  Some classes are\n overridden by local versions; these files still appear in the libgcj\n@@ -81,7 +108,7 @@ before running automake.\n \n In general you should not make any changes in the classpath/\n directory.  Changes here should come via imports from upstream.\n-However, there are two (known) exceptions to this rule:\n+However, there are three (known) exceptions to this rule:\n \n * In an emergency, such as a bootstrap breakage, it is ok to commit a\n   patch provided that the problem is resolved (by fixing a compiler\n@@ -91,6 +118,9 @@ However, there are two (known) exceptions to this rule:\n * On a release branch to fix a bug, where a full-scale import of\n   Classpath is not advisable.\n \n+* We maintain a fair number of divergences in the build system.\n+  This is a pain but they don't seem suitable for upstream.\n+\n --\n \n You can develop in a GCC tree using a CVS checkout of Classpath, most\n@@ -129,8 +159,3 @@ If you add a class to java.lang, java.io, or java.util\n   at that point.  This must be run from the build tree, in\n   <build>/classpath/lib; it uses the .class file name to determine\n   what to print.\n-\n-If you're generating a patch there is a program you can get to do an\n-offline `cvs add' (it will fake an `add' if you don't have write\n-permission yet).  Then you can use `cvs diff -N' to generate the\n-patch.  See http://www.red-bean.com/cvsutils/"}]}