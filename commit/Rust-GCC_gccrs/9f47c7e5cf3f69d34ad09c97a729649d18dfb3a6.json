{"sha": "9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY0N2M3ZTVjZjNmNjlkMzRhZDA5Yzk3YTcyOTY0OWQxOGRmYjNhNg==", "commit": {"author": {"name": "Ilya Enkovich", "email": "enkovich.gnu@gmail.com", "date": "2015-10-21T16:01:43Z"}, "committer": {"name": "Ilya Enkovich", "email": "ienkovich@gcc.gnu.org", "date": "2015-10-21T16:01:43Z"}, "message": "tm.texi: Regenerated.\n\ngcc/\n\n\t* doc/tm.texi: Regenerated.\n\t* doc/tm.texi.in (TARGET_VECTORIZE_GET_MASK_MODE): New.\n\t* stor-layout.c (layout_type): Use mode to get vector mask size.\n\t* target.def (get_mask_mode): New.\n\t* targhooks.c (default_get_mask_mode): New.\n\t* targhooks.h (default_get_mask_mode): New.\n\t* gcc/tree-vect-stmts.c (get_same_sized_vectype): Add special case\n\tfor boolean vector.\n\t* tree.c (MAX_BOOL_CACHED_PREC): New.\n\t(nonstandard_boolean_type_cache): New.\n\t(build_nonstandard_boolean_type): New.\n\t(make_vector_type): Vector mask has no canonical type.\n\t(build_truth_vector_type): New.\n\t(build_same_sized_truth_vector_type): New.\n\t(truth_type_for): Support vector masks.\n\t* tree.h (VECTOR_BOOLEAN_TYPE_P): New.\n\t(build_truth_vector_type): New.\n\t(build_same_sized_truth_vector_type): New.\n\t(build_nonstandard_boolean_type): New.\n\t* tree-cfg.c (verify_gimple_comparison) Require boolean\n\tvector type for vector comparison.\n\t(verify_gimple_assign_ternary): Likewise.\n\t* optabs.c (expand_vec_cond_expr): Accept boolean vector as\n\tcondition operand.\n\t* tree-vect-stmts.c (vectorizable_condition): Use boolean\n\tvector type for vector comparison.\n\t* tree-vect-generic.c (elem_op_func): Add new operand to hold\n\tvector type.\n\t(do_unop): Adjust to modified function type.\n\t(do_binop): Likewise.\n\t(do_plus_minus): Likewise.\n\t(do_negate); Likewise.\n\t(expand_vector_piecewise): Likewise.\n\t(do_cond): Likewise.\n\t(do_compare): Use comparison instead of condition.\n\t(expand_vector_divmod): Use boolean vector type for comparison.\n\t(expand_vector_operations_1): Skip scalar mask operations.\n\ngcc/c\n\n\t* c-typeck.c (build_conditional_expr): Use boolean vector\n\ttype for vector comparison.\n\t(build_vec_cmp): New.\n\t(build_binary_op): Use build_vec_cmp for comparison.\n\ngcc/cp\n\n\t* call.c (build_conditional_expr_1): Use boolean vector\n\ttype for vector comparison.\n\t* typeck.c (build_vec_cmp): New.\n\t(cp_build_binary_op): Use build_vec_cmp for comparison.\n\ngcc/testsuite/\n\n\t* g++.dg/ext/vector22.C: Allow VEC_COND_EXPR.\n\nFrom-SVN: r229128", "tree": {"sha": "c0078faec62f54a6b5b518102c489b0e7cd1f459", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0078faec62f54a6b5b518102c489b0e7cd1f459"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/comments", "author": null, "committer": null, "parents": [{"sha": "6f9045f4e16df8791ae67e0508b61accc4c982c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f9045f4e16df8791ae67e0508b61accc4c982c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f9045f4e16df8791ae67e0508b61accc4c982c2"}], "stats": {"total": 343, "additions": 287, "deletions": 56}, "files": [{"sha": "d5296ae5db451a8a1ed9adcc676bb47652e11b94", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "patch": "@@ -1,3 +1,43 @@\n+2015-10-21  Ilya Enkovich  <enkovich.gnu@gmail.com>\n+\n+\t* doc/tm.texi: Regenerated.\n+\t* doc/tm.texi.in (TARGET_VECTORIZE_GET_MASK_MODE): New.\n+\t* stor-layout.c (layout_type): Use mode to get vector mask size.\n+\t* target.def (get_mask_mode): New.\n+\t* targhooks.c (default_get_mask_mode): New.\n+\t* targhooks.h (default_get_mask_mode): New.\n+\t* gcc/tree-vect-stmts.c (get_same_sized_vectype): Add special case\n+\tfor boolean vector.\n+\t* tree.c (MAX_BOOL_CACHED_PREC): New.\n+\t(nonstandard_boolean_type_cache): New.\n+\t(build_nonstandard_boolean_type): New.\n+\t(make_vector_type): Vector mask has no canonical type.\n+\t(build_truth_vector_type): New.\n+\t(build_same_sized_truth_vector_type): New.\n+\t(truth_type_for): Support vector masks.\n+\t* tree.h (VECTOR_BOOLEAN_TYPE_P): New.\n+\t(build_truth_vector_type): New.\n+\t(build_same_sized_truth_vector_type): New.\n+\t(build_nonstandard_boolean_type): New.\n+\t* tree-cfg.c (verify_gimple_comparison) Require boolean\n+\tvector type for vector comparison.\n+\t(verify_gimple_assign_ternary): Likewise.\n+\t* optabs.c (expand_vec_cond_expr): Accept boolean vector as\n+\tcondition operand.\n+\t* tree-vect-stmts.c (vectorizable_condition): Use boolean\n+\tvector type for vector comparison.\n+\t* tree-vect-generic.c (elem_op_func): Add new operand to hold\n+\tvector type.\n+\t(do_unop): Adjust to modified function type.\n+\t(do_binop): Likewise.\n+\t(do_plus_minus): Likewise.\n+\t(do_negate); Likewise.\n+\t(expand_vector_piecewise): Likewise.\n+\t(do_cond): Likewise.\n+\t(do_compare): Use comparison instead of condition.\n+\t(expand_vector_divmod): Use boolean vector type for comparison.\n+\t(expand_vector_operations_1): Skip scalar mask operations.\n+\n 2015-10-21  Ilya Enkovich  <enkovich.gnu@gmail.com>\n \n \t* omp-low.c (simd_clone_create): Set in_other_partition"}, {"sha": "34aafc2c59d92a6a72d3c0a74b905bf91ee84ef5", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "patch": "@@ -1,3 +1,10 @@\n+2015-10-21  Ilya Enkovich  <enkovich.gnu@gmail.com>\n+\n+\t* c-typeck.c (build_conditional_expr): Use boolean vector\n+\ttype for vector comparison.\n+\t(build_vec_cmp): New.\n+\t(build_binary_op): Use build_vec_cmp for comparison.\n+\n 2015-10-20  Marek Polacek  <polacek@redhat.com>\n \n \t* c-parser.c (is_cilkplus_vector_p): Don't define here."}, {"sha": "6b32781c03bef9312823bb96d5e1f6aaae7511e7", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "patch": "@@ -4771,6 +4771,18 @@ build_conditional_expr (location_t colon_loc, tree ifexp, bool ifexp_bcp,\n \t\t       && TREE_CODE (orig_op2) == INTEGER_CST\n \t\t       && !TREE_OVERFLOW (orig_op2)));\n     }\n+\n+  /* Need to convert condition operand into a vector mask.  */\n+  if (VECTOR_TYPE_P (TREE_TYPE (ifexp)))\n+    {\n+      tree vectype = TREE_TYPE (ifexp);\n+      tree elem_type = TREE_TYPE (vectype);\n+      tree zero = build_int_cst (elem_type, 0);\n+      tree zero_vec = build_vector_from_val (vectype, zero);\n+      tree cmp_type = build_same_sized_truth_vector_type (vectype);\n+      ifexp = build2 (NE_EXPR, cmp_type, ifexp, zero_vec);\n+    }\n+\n   if (int_const || (ifexp_bcp && TREE_CODE (ifexp) == INTEGER_CST))\n     ret = fold_build3_loc (colon_loc, COND_EXPR, result_type, ifexp, op1, op2);\n   else\n@@ -10237,6 +10249,20 @@ push_cleanup (tree decl, tree cleanup, bool eh_only)\n   STATEMENT_LIST_STMT_EXPR (list) = stmt_expr;\n }\n \f\n+/* Build a vector comparison of ARG0 and ARG1 using CODE opcode\n+   into a value of TYPE type.  Comparison is done via VEC_COND_EXPR.  */\n+\n+static tree\n+build_vec_cmp (tree_code code, tree type,\n+\t       tree arg0, tree arg1)\n+{\n+  tree zero_vec = build_zero_cst (type);\n+  tree minus_one_vec = build_minus_one_cst (type);\n+  tree cmp_type = build_same_sized_truth_vector_type (type);\n+  tree cmp = build2 (code, cmp_type, arg0, arg1);\n+  return build3 (VEC_COND_EXPR, type, cmp, minus_one_vec, zero_vec);\n+}\n+\n /* Build a binary-operation expression without default conversions.\n    CODE is the kind of expression to build.\n    LOCATION is the operator's location.\n@@ -10803,7 +10829,8 @@ build_binary_op (location_t location, enum tree_code code,\n           result_type = build_opaque_vector_type (intt,\n \t\t\t\t\t\t  TYPE_VECTOR_SUBPARTS (type0));\n           converted = 1;\n-          break;\n+\t  ret = build_vec_cmp (resultcode, result_type, op0, op1);\n+\t  goto return_build_binary_op;\n         }\n       if (FLOAT_TYPE_P (type0) || FLOAT_TYPE_P (type1))\n \twarning_at (location,\n@@ -10955,7 +10982,8 @@ build_binary_op (location_t location, enum tree_code code,\n           result_type = build_opaque_vector_type (intt,\n \t\t\t\t\t\t  TYPE_VECTOR_SUBPARTS (type0));\n           converted = 1;\n-          break;\n+\t  ret = build_vec_cmp (resultcode, result_type, op0, op1);\n+\t  goto return_build_binary_op;\n         }\n       build_type = integer_type_node;\n       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE"}, {"sha": "2a9e873320d8ee694f1d2934810cb8fc6ed7555a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "patch": "@@ -1,3 +1,10 @@\n+2015-10-21  Ilya Enkovich  <enkovich.gnu@gmail.com>\n+\n+\t* call.c (build_conditional_expr_1): Use boolean vector\n+\ttype for vector comparison.\n+\t* typeck.c (build_vec_cmp): New.\n+\t(cp_build_binary_op): Use build_vec_cmp for comparison.\n+\n 2015-10-20  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/66583"}, {"sha": "55b3c8c88bb92ac5113525d85b5316007d6b4c0a", "filename": "gcc/cp/call.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "patch": "@@ -4627,6 +4627,15 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n \n   if (VECTOR_INTEGER_TYPE_P (TREE_TYPE (arg1)))\n     {\n+      /* If arg1 is another cond_expr choosing between -1 and 0,\n+\t then we can use its comparison.  It may help to avoid\n+\t additional comparison, produce more accurate diagnostics\n+\t and enables folding.  */\n+      if (TREE_CODE (arg1) == VEC_COND_EXPR\n+\t  && integer_minus_onep (TREE_OPERAND (arg1, 1))\n+\t  && integer_zerop (TREE_OPERAND (arg1, 2)))\n+\targ1 = TREE_OPERAND (arg1, 0);\n+\n       arg1 = force_rvalue (arg1, complain);\n       arg2 = force_rvalue (arg2, complain);\n       arg3 = force_rvalue (arg3, complain);\n@@ -4739,8 +4748,10 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n \t}\n \n       if (!COMPARISON_CLASS_P (arg1))\n-\targ1 = cp_build_binary_op (loc, NE_EXPR, arg1,\n-\t\t\t\t   build_zero_cst (arg1_type), complain);\n+\t{\n+\t  tree cmp_type = build_same_sized_truth_vector_type (arg1_type);\n+\t  arg1 = build2 (NE_EXPR, cmp_type, arg1, build_zero_cst (arg1_type));\n+\t}\n       return fold_build3 (VEC_COND_EXPR, arg2_type, arg1, arg2, arg3);\n     }\n "}, {"sha": "3147609d427f054c3a7b6b18a8418cd6e345df49", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "patch": "@@ -3916,6 +3916,20 @@ build_binary_op (location_t location, enum tree_code code, tree op0, tree op1,\n   return cp_build_binary_op (location, code, op0, op1, tf_warning_or_error);\n }\n \n+/* Build a vector comparison of ARG0 and ARG1 using CODE opcode\n+   into a value of TYPE type.  Comparison is done via VEC_COND_EXPR.  */\n+\n+static tree\n+build_vec_cmp (tree_code code, tree type,\n+\t       tree arg0, tree arg1)\n+{\n+  tree zero_vec = build_zero_cst (type);\n+  tree minus_one_vec = build_minus_one_cst (type);\n+  tree cmp_type = build_same_sized_truth_vector_type(type);\n+  tree cmp = build2 (code, cmp_type, arg0, arg1);\n+  cmp = fold_if_not_in_template (cmp);\n+  return build3 (VEC_COND_EXPR, type, cmp, minus_one_vec, zero_vec);\n+}\n \n /* Build a binary-operation expression without default conversions.\n    CODE is the kind of expression to build.\n@@ -4785,7 +4799,7 @@ cp_build_binary_op (location_t location,\n \t  result_type = build_opaque_vector_type (intt,\n \t\t\t\t\t\t  TYPE_VECTOR_SUBPARTS (type0));\n \t  converted = 1;\n-\t  break;\n+\t  return build_vec_cmp (resultcode, result_type, op0, op1);\n \t}\n       build_type = boolean_type_node;\n       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE"}, {"sha": "4a12ad6f42928f629500a5ed3418108a8b4ebf2f", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "patch": "@@ -5688,6 +5688,12 @@ mode returned by @code{TARGET_VECTORIZE_PREFERRED_SIMD_MODE}.\n The default is zero which means to not iterate over other vector sizes.\n @end deftypefn\n \n+@deftypefn {Target Hook} machine_mode TARGET_VECTORIZE_GET_MASK_MODE (unsigned @var{nunits}, unsigned @var{length})\n+This hook returns mode to be used for a mask to be used for a vector\n+of specified @var{length} with @var{nunits} elements.  By default an integer\n+vector mode of a proper size is returned.\n+@end deftypefn\n+\n @deftypefn {Target Hook} {void *} TARGET_VECTORIZE_INIT_COST (struct loop *@var{loop_info})\n This hook should initialize target-specific data structures in preparation for modeling the costs of vectorizing a loop or basic block.  The default allocates three unsigned integers for accumulating costs for the prologue, body, and epilogue of the loop or basic block.  If @var{loop_info} is non-NULL, it identifies the loop being vectorized; otherwise a single block is being vectorized.\n @end deftypefn"}, {"sha": "6f0c252bf172b788341a1ac57c13e2d48a6b6109", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "patch": "@@ -4225,6 +4225,8 @@ address;  but often a machine-dependent strategy can generate better code.\n \n @hook TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES\n \n+@hook TARGET_VECTORIZE_GET_MASK_MODE\n+\n @hook TARGET_VECTORIZE_INIT_COST\n \n @hook TARGET_VECTORIZE_ADD_STMT_COST"}, {"sha": "82a1ee6c28d893dfb0066f078ae8f0d9410ee474", "filename": "gcc/optabs.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "patch": "@@ -5365,16 +5365,17 @@ expand_vec_cond_expr (tree vec_cond_type, tree op0, tree op1, tree op2,\n       op0a = TREE_OPERAND (op0, 0);\n       op0b = TREE_OPERAND (op0, 1);\n       tcode = TREE_CODE (op0);\n+      unsignedp = TYPE_UNSIGNED (TREE_TYPE (op0a));\n     }\n   else\n     {\n       /* Fake op0 < 0.  */\n-      gcc_assert (!TYPE_UNSIGNED (TREE_TYPE (op0)));\n+      gcc_assert (VECTOR_BOOLEAN_TYPE_P (TREE_TYPE (op0)));\n       op0a = op0;\n       op0b = build_zero_cst (TREE_TYPE (op0));\n       tcode = LT_EXPR;\n+      unsignedp = false;\n     }\n-  unsignedp = TYPE_UNSIGNED (TREE_TYPE (op0a));\n   cmp_op_mode = TYPE_MODE (TREE_TYPE (op0a));\n \n "}, {"sha": "58ecd7ba35beec8382fac98407da501ed1b71022", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "patch": "@@ -2184,10 +2184,16 @@ layout_type (tree type)\n \n \tTYPE_SATURATING (type) = TYPE_SATURATING (TREE_TYPE (type));\n         TYPE_UNSIGNED (type) = TYPE_UNSIGNED (TREE_TYPE (type));\n-\tTYPE_SIZE_UNIT (type) = int_const_binop (MULT_EXPR,\n-\t\t\t\t\t         TYPE_SIZE_UNIT (innertype),\n-\t\t\t\t\t         size_int (nunits));\n-\tTYPE_SIZE (type) = int_const_binop (MULT_EXPR, TYPE_SIZE (innertype),\n+\t/* Several boolean vector elements may fit in a single unit.  */\n+\tif (VECTOR_BOOLEAN_TYPE_P (type))\n+\t  TYPE_SIZE_UNIT (type)\n+\t    = size_int (GET_MODE_SIZE (type->type_common.mode));\n+\telse\n+\t  TYPE_SIZE_UNIT (type) = int_const_binop (MULT_EXPR,\n+\t\t\t\t\t\t   TYPE_SIZE_UNIT (innertype),\n+\t\t\t\t\t\t   size_int (nunits));\n+\tTYPE_SIZE (type) = int_const_binop (MULT_EXPR,\n+\t\t\t\t\t    TYPE_SIZE (innertype),\n \t\t\t\t\t    bitsize_int (nunits));\n \n \t/* For vector types, we do not default to the mode's alignment."}, {"sha": "93478e8aeeaf71ded57875751409519e4ee58bdf", "filename": "gcc/target.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "patch": "@@ -1810,6 +1810,16 @@ The default is zero which means to not iterate over other vector sizes.\",\n  (void),\n  default_autovectorize_vector_sizes)\n \n+/* Function to get a target mode for a vector mask.  */\n+DEFHOOK\n+(get_mask_mode,\n+ \"This hook returns mode to be used for a mask to be used for a vector\\n\\\n+of specified @var{length} with @var{nunits} elements.  By default an integer\\n\\\n+vector mode of a proper size is returned.\",\n+ machine_mode,\n+ (unsigned nunits, unsigned length),\n+ default_get_mask_mode)\n+\n /* Target builtin that implements vector gather operation.  */\n DEFHOOK\n (builtin_gather,"}, {"sha": "01aaed07e6988f3ae8dd9cd04738e38c92245635", "filename": "gcc/targhooks.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "patch": "@@ -1087,6 +1087,20 @@ default_autovectorize_vector_sizes (void)\n   return 0;\n }\n \n+/* By defaults a vector of integers is used as a mask.  */\n+\n+machine_mode\n+default_get_mask_mode (unsigned nunits, unsigned vector_size)\n+{\n+  unsigned elem_size = vector_size / nunits;\n+  machine_mode elem_mode\n+    = smallest_mode_for_size (elem_size * BITS_PER_UNIT, MODE_INT);\n+\n+  gcc_assert (elem_size * nunits == vector_size);\n+\n+  return mode_for_vector (elem_mode, nunits);\n+}\n+\n /* By default, the cost model accumulates three separate costs (prologue,\n    loop body, and epilogue) for a vectorized loop or block.  So allocate an\n    array of three unsigned ints, set it to zero, and return its address.  */"}, {"sha": "e13e0874834ac29fc37dbab228936a895ecf67ac", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "patch": "@@ -100,6 +100,7 @@ default_builtin_support_vector_misalignment (machine_mode mode,\n \t\t\t\t\t     int, bool);\n extern machine_mode default_preferred_simd_mode (machine_mode mode);\n extern unsigned int default_autovectorize_vector_sizes (void);\n+extern machine_mode default_get_mask_mode (unsigned, unsigned);\n extern void *default_init_cost (struct loop *);\n extern unsigned default_add_stmt_cost (void *, int, enum vect_cost_for_stmt,\n \t\t\t\t       struct _stmt_vec_info *, int,"}, {"sha": "3f325b9ad3c8ef08f03c131461c21df284d5dc22", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "patch": "@@ -1,3 +1,7 @@\n+2015-10-21  Ilya Enkovich  <enkovich.gnu@gmail.com>\n+\n+\t* g++.dg/ext/vector22.C: Allow VEC_COND_EXPR.\n+\n 2015-10-21  Ilya Enkovich  <enkovich.gnu@gmail.com>\n \n \t* gcc.dg/lto/simd-function_0.c: New test."}, {"sha": "5d28637f82715cd13942c7b711fe720912f09c21", "filename": "gcc/testsuite/g++.dg/ext/vector22.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvector22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvector22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fvector22.C?ref=9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "patch": "@@ -18,4 +18,3 @@ void h(vec*a){\n }\n \n /* { dg-final { scan-tree-dump-not \"~\" \"gimple\" } } */\n-/* { dg-final { scan-tree-dump-not \"VEC_COND_EXPR\" \"gimple\" } } */"}, {"sha": "8e3e810cf894dc667b9b1682d31da85e88fde2d6", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "patch": "@@ -3465,10 +3465,10 @@ verify_gimple_comparison (tree type, tree op0, tree op1)\n           return true;\n         }\n     }\n-  /* Or an integer vector type with the same size and element count\n+  /* Or a boolean vector type with the same element count\n      as the comparison operand types.  */\n   else if (TREE_CODE (type) == VECTOR_TYPE\n-\t   && TREE_CODE (TREE_TYPE (type)) == INTEGER_TYPE)\n+\t   && TREE_CODE (TREE_TYPE (type)) == BOOLEAN_TYPE)\n     {\n       if (TREE_CODE (op0_type) != VECTOR_TYPE\n \t  || TREE_CODE (op1_type) != VECTOR_TYPE)\n@@ -3479,12 +3479,7 @@ verify_gimple_comparison (tree type, tree op0, tree op1)\n           return true;\n         }\n \n-      if (TYPE_VECTOR_SUBPARTS (type) != TYPE_VECTOR_SUBPARTS (op0_type)\n-\t  || (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (type)))\n-\t      != GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (op0_type))))\n-\t  /* The result of a vector comparison is of signed\n-\t     integral type.  */\n-\t  || TYPE_UNSIGNED (TREE_TYPE (type)))\n+      if (TYPE_VECTOR_SUBPARTS (type) != TYPE_VECTOR_SUBPARTS (op0_type))\n         {\n           error (\"invalid vector comparison resulting type\");\n           debug_generic_expr (type);\n@@ -3971,15 +3966,13 @@ verify_gimple_assign_ternary (gassign *stmt)\n       break;\n \n     case VEC_COND_EXPR:\n-      if (!VECTOR_INTEGER_TYPE_P (rhs1_type)\n-\t  || TYPE_SIGN (rhs1_type) != SIGNED\n-\t  || TYPE_SIZE (rhs1_type) != TYPE_SIZE (lhs_type)\n+      if (!VECTOR_BOOLEAN_TYPE_P (rhs1_type)\n \t  || TYPE_VECTOR_SUBPARTS (rhs1_type)\n \t     != TYPE_VECTOR_SUBPARTS (lhs_type))\n \t{\n-\t  error (\"the first argument of a VEC_COND_EXPR must be of a signed \"\n-\t\t \"integral vector type of the same size and number of \"\n-\t\t \"elements as the result\");\n+\t  error (\"the first argument of a VEC_COND_EXPR must be of a \"\n+\t\t \"boolean vector type of the same number of elements \"\n+\t\t \"as the result\");\n \t  debug_generic_expr (lhs_type);\n \t  debug_generic_expr (rhs1_type);\n \t  return true;"}, {"sha": "a20b9afedba43e7ceb8fe077d44a59ad48fd4e50", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 36, "deletions": 21, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "patch": "@@ -105,30 +105,44 @@ build_word_mode_vector_type (int nunits)\n }\n \n typedef tree (*elem_op_func) (gimple_stmt_iterator *,\n-\t\t\t      tree, tree, tree, tree, tree, enum tree_code);\n+\t\t\t      tree, tree, tree, tree, tree, enum tree_code,\n+\t\t\t      tree);\n \n static inline tree\n tree_vec_extract (gimple_stmt_iterator *gsi, tree type,\n \t\t  tree t, tree bitsize, tree bitpos)\n {\n   if (bitpos)\n-    return gimplify_build3 (gsi, BIT_FIELD_REF, type, t, bitsize, bitpos);\n+    {\n+      if (TREE_CODE (type) == BOOLEAN_TYPE)\n+\t{\n+\t  tree itype\n+\t    = build_nonstandard_integer_type (tree_to_uhwi (bitsize), 0);\n+\t  tree field = gimplify_build3 (gsi, BIT_FIELD_REF, itype, t,\n+\t\t\t\t\tbitsize, bitpos);\n+\t  return gimplify_build2 (gsi, NE_EXPR, type, field,\n+\t\t\t\t  build_zero_cst (itype));\n+\t}\n+      else\n+\treturn gimplify_build3 (gsi, BIT_FIELD_REF, type, t, bitsize, bitpos);\n+    }\n   else\n     return gimplify_build1 (gsi, VIEW_CONVERT_EXPR, type, t);\n }\n \n static tree\n do_unop (gimple_stmt_iterator *gsi, tree inner_type, tree a,\n \t tree b ATTRIBUTE_UNUSED, tree bitpos, tree bitsize,\n-\t enum tree_code code)\n+\t enum tree_code code, tree type ATTRIBUTE_UNUSED)\n {\n   a = tree_vec_extract (gsi, inner_type, a, bitsize, bitpos);\n   return gimplify_build1 (gsi, code, inner_type, a);\n }\n \n static tree\n do_binop (gimple_stmt_iterator *gsi, tree inner_type, tree a, tree b,\n-\t  tree bitpos, tree bitsize, enum tree_code code)\n+\t  tree bitpos, tree bitsize, enum tree_code code,\n+\t  tree type ATTRIBUTE_UNUSED)\n {\n   if (TREE_CODE (TREE_TYPE (a)) == VECTOR_TYPE)\n     a = tree_vec_extract (gsi, inner_type, a, bitsize, bitpos);\n@@ -145,20 +159,12 @@ do_binop (gimple_stmt_iterator *gsi, tree inner_type, tree a, tree b,\n    size equal to the size of INNER_TYPE.  */\n static tree\n do_compare (gimple_stmt_iterator *gsi, tree inner_type, tree a, tree b,\n-\t  tree bitpos, tree bitsize, enum tree_code code)\n+\t    tree bitpos, tree bitsize, enum tree_code code, tree type)\n {\n-  tree comp_type;\n-\n   a = tree_vec_extract (gsi, inner_type, a, bitsize, bitpos);\n   b = tree_vec_extract (gsi, inner_type, b, bitsize, bitpos);\n \n-  comp_type = build_nonstandard_integer_type\n-\t\t      (GET_MODE_BITSIZE (TYPE_MODE (inner_type)), 0);\n-\n-  return gimplify_build3 (gsi, COND_EXPR, comp_type,\n-\t\t\t  fold_build2 (code, boolean_type_node, a, b),\n-\t\t\t  build_int_cst (comp_type, -1),\n-\t\t\t  build_int_cst (comp_type, 0));\n+  return gimplify_build2 (gsi, code, TREE_TYPE (type), a, b);\n }\n \n /* Expand vector addition to scalars.  This does bit twiddling\n@@ -177,7 +183,7 @@ do_compare (gimple_stmt_iterator *gsi, tree inner_type, tree a, tree b,\n static tree\n do_plus_minus (gimple_stmt_iterator *gsi, tree word_type, tree a, tree b,\n \t       tree bitpos ATTRIBUTE_UNUSED, tree bitsize ATTRIBUTE_UNUSED,\n-\t       enum tree_code code)\n+\t       enum tree_code code, tree type ATTRIBUTE_UNUSED)\n {\n   tree inner_type = TREE_TYPE (TREE_TYPE (a));\n   unsigned HOST_WIDE_INT max;\n@@ -209,7 +215,8 @@ static tree\n do_negate (gimple_stmt_iterator *gsi, tree word_type, tree b,\n \t   tree unused ATTRIBUTE_UNUSED, tree bitpos ATTRIBUTE_UNUSED,\n \t   tree bitsize ATTRIBUTE_UNUSED,\n-\t   enum tree_code code ATTRIBUTE_UNUSED)\n+\t   enum tree_code code ATTRIBUTE_UNUSED,\n+\t   tree type ATTRIBUTE_UNUSED)\n {\n   tree inner_type = TREE_TYPE (TREE_TYPE (b));\n   HOST_WIDE_INT max;\n@@ -255,7 +262,7 @@ expand_vector_piecewise (gimple_stmt_iterator *gsi, elem_op_func f,\n   for (i = 0; i < nunits;\n        i += delta, index = int_const_binop (PLUS_EXPR, index, part_width))\n     {\n-      tree result = f (gsi, inner_type, a, b, index, part_width, code);\n+      tree result = f (gsi, inner_type, a, b, index, part_width, code, type);\n       constructor_elt ce = {NULL_TREE, result};\n       v->quick_push (ce);\n     }\n@@ -298,7 +305,7 @@ expand_vector_parallel (gimple_stmt_iterator *gsi, elem_op_func f, tree type,\n       /* Use a single scalar operation with a mode no wider than word_mode.  */\n       mode = mode_for_size (tree_to_uhwi (TYPE_SIZE (type)), MODE_INT, 0);\n       compute_type = lang_hooks.types.type_for_mode (mode, 1);\n-      result = f (gsi, compute_type, a, b, NULL_TREE, NULL_TREE, code);\n+      result = f (gsi, compute_type, a, b, NULL_TREE, NULL_TREE, code, type);\n       warning_at (loc, OPT_Wvector_operation_performance,\n \t          \"vector operation will be expanded with a \"\n \t\t  \"single scalar operation\");\n@@ -615,11 +622,12 @@ expand_vector_divmod (gimple_stmt_iterator *gsi, tree type, tree op0,\n \t  if (addend == NULL_TREE\n \t      && expand_vec_cond_expr_p (type, type))\n \t    {\n-\t      tree zero, cst, cond;\n+\t      tree zero, cst, cond, mask_type;\n \t      gimple *stmt;\n \n+\t      mask_type = build_same_sized_truth_vector_type (type);\n \t      zero = build_zero_cst (type);\n-\t      cond = build2 (LT_EXPR, type, op0, zero);\n+\t      cond = build2 (LT_EXPR, mask_type, op0, zero);\n \t      for (i = 0; i < nunits; i++)\n \t\tvec[i] = build_int_cst (TREE_TYPE (type),\n \t\t\t\t\t((unsigned HOST_WIDE_INT) 1\n@@ -1386,7 +1394,8 @@ count_type_subparts (tree type)\n \n static tree\n do_cond (gimple_stmt_iterator *gsi, tree inner_type, tree a, tree b,\n-\t tree bitpos, tree bitsize, enum tree_code code)\n+\t tree bitpos, tree bitsize, enum tree_code code,\n+\t tree type ATTRIBUTE_UNUSED)\n {\n   if (TREE_CODE (TREE_TYPE (a)) == VECTOR_TYPE)\n     a = tree_vec_extract (gsi, inner_type, a, bitsize, bitpos);\n@@ -1496,6 +1505,12 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n   if (TREE_CODE (type) != VECTOR_TYPE)\n     return;\n \n+  /* A scalar operation pretending to be a vector one.  */\n+  if (VECTOR_BOOLEAN_TYPE_P (type)\n+      && !VECTOR_MODE_P (TYPE_MODE (type))\n+      && TYPE_MODE (type) != BLKmode)\n+    return;\n+\n   if (CONVERT_EXPR_CODE_P (code)\n       || code == FLOAT_EXPR\n       || code == FIX_TRUNC_EXPR"}, {"sha": "19f62d00337dcc599a942c223ec74248799723d1", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "patch": "@@ -7254,10 +7254,7 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (!vect_is_simple_use (else_clause, stmt_info->vinfo, &def_stmt, &dt))\n     return false;\n \n-  unsigned int prec = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (vectype)));\n-  /* The result of a vector comparison should be signed type.  */\n-  tree cmp_type = build_nonstandard_integer_type (prec, 0);\n-  vec_cmp_type = get_same_sized_vectype (cmp_type, vectype);\n+  vec_cmp_type = build_same_sized_truth_vector_type (comp_vectype);\n   if (vec_cmp_type == NULL_TREE)\n     return false;\n \n@@ -8067,6 +8064,9 @@ get_vectype_for_scalar_type (tree scalar_type)\n tree\n get_same_sized_vectype (tree scalar_type, tree vector_type)\n {\n+  if (TREE_CODE (scalar_type) == BOOLEAN_TYPE)\n+    return build_same_sized_truth_vector_type (vector_type);\n+\n   return get_vectype_for_scalar_type_and_size\n \t   (scalar_type, GET_MODE_SIZE (TYPE_MODE (vector_type)));\n }"}, {"sha": "6c75699b36de440250d118b0ecf3e1f413dcedfc", "filename": "gcc/tree.c", "status": "modified", "additions": 69, "deletions": 5, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "patch": "@@ -8041,6 +8041,34 @@ build_nonstandard_integer_type (unsigned HOST_WIDE_INT precision,\n   return ret;\n }\n \n+#define MAX_BOOL_CACHED_PREC \\\n+  (HOST_BITS_PER_WIDE_INT > 64 ? HOST_BITS_PER_WIDE_INT : 64)\n+static GTY(()) tree nonstandard_boolean_type_cache[MAX_BOOL_CACHED_PREC + 1];\n+\n+/* Builds a boolean type of precision PRECISION.\n+   Used for boolean vectors to choose proper vector element size.  */\n+tree\n+build_nonstandard_boolean_type (unsigned HOST_WIDE_INT precision)\n+{\n+  tree type;\n+\n+  if (precision <= MAX_BOOL_CACHED_PREC)\n+    {\n+      type = nonstandard_boolean_type_cache[precision];\n+      if (type)\n+\treturn type;\n+    }\n+\n+  type = make_node (BOOLEAN_TYPE);\n+  TYPE_PRECISION (type) = precision;\n+  fixup_unsigned_type (type);\n+\n+  if (precision <= MAX_INT_CACHED_PREC)\n+    nonstandard_boolean_type_cache[precision] = type;\n+\n+  return type;\n+}\n+\n /* Create a range of some discrete type TYPE (an INTEGER_TYPE, ENUMERAL_TYPE\n    or BOOLEAN_TYPE) with low bound LOWVAL and high bound HIGHVAL.  If SHARED\n    is true, reuse such a type that has already been constructed.  */\n@@ -9791,8 +9819,9 @@ make_vector_type (tree innertype, int nunits, machine_mode mode)\n \n   if (TYPE_STRUCTURAL_EQUALITY_P (innertype))\n     SET_TYPE_STRUCTURAL_EQUALITY (t);\n-  else if (TYPE_CANONICAL (innertype) != innertype\n-\t   || mode != VOIDmode)\n+  else if ((TYPE_CANONICAL (innertype) != innertype\n+\t    || mode != VOIDmode)\n+\t   && !VECTOR_BOOLEAN_TYPE_P (t))\n     TYPE_CANONICAL (t)\n       = make_vector_type (TYPE_CANONICAL (innertype), nunits, VOIDmode);\n \n@@ -10617,6 +10646,40 @@ build_vector_type (tree innertype, int nunits)\n   return make_vector_type (innertype, nunits, VOIDmode);\n }\n \n+/* Build truth vector with specified length and number of units.  */\n+\n+tree\n+build_truth_vector_type (unsigned nunits, unsigned vector_size)\n+{\n+  machine_mode mask_mode = targetm.vectorize.get_mask_mode (nunits,\n+\t\t\t\t\t\t\t    vector_size);\n+\n+  gcc_assert (mask_mode != VOIDmode);\n+\n+  unsigned HOST_WIDE_INT esize = GET_MODE_BITSIZE (mask_mode) / nunits;\n+  gcc_assert (esize * nunits == GET_MODE_BITSIZE (mask_mode));\n+\n+  tree bool_type = build_nonstandard_boolean_type (esize);\n+\n+  return make_vector_type (bool_type, nunits, mask_mode);\n+}\n+\n+/* Returns a vector type corresponding to a comparison of VECTYPE.  */\n+\n+tree\n+build_same_sized_truth_vector_type (tree vectype)\n+{\n+  if (VECTOR_BOOLEAN_TYPE_P (vectype))\n+    return vectype;\n+\n+  unsigned HOST_WIDE_INT size = GET_MODE_SIZE (TYPE_MODE (vectype));\n+\n+  if (!size)\n+    size = tree_to_uhwi (TYPE_SIZE_UNIT (vectype));\n+\n+  return build_truth_vector_type (TYPE_VECTOR_SUBPARTS (vectype), size);\n+}\n+\n /* Similarly, but builds a variant type with TYPE_VECTOR_OPAQUE set.  */\n \n tree\n@@ -11103,9 +11166,10 @@ truth_type_for (tree type)\n {\n   if (TREE_CODE (type) == VECTOR_TYPE)\n     {\n-      tree elem = lang_hooks.types.type_for_size\n-        (GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (type))), 0);\n-      return build_opaque_vector_type (elem, TYPE_VECTOR_SUBPARTS (type));\n+      if (VECTOR_BOOLEAN_TYPE_P (type))\n+\treturn type;\n+      return build_truth_vector_type (TYPE_VECTOR_SUBPARTS (type),\n+\t\t\t\t      GET_MODE_SIZE (TYPE_MODE (type)));\n     }\n   else\n     return boolean_type_node;"}, {"sha": "300077cac05a8bbb785efc342c71295b605ca0a2", "filename": "gcc/tree.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=9f47c7e5cf3f69d34ad09c97a729649d18dfb3a6", "patch": "@@ -470,6 +470,12 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n \n #define VECTOR_TYPE_P(TYPE) (TREE_CODE (TYPE) == VECTOR_TYPE)\n \n+/* Nonzero if TYPE represents a vector of booleans.  */\n+\n+#define VECTOR_BOOLEAN_TYPE_P(TYPE)\t\t\t\t\\\n+  (TREE_CODE (TYPE) == VECTOR_TYPE\t\t\t\\\n+   && TREE_CODE (TREE_TYPE (TYPE)) == BOOLEAN_TYPE)\n+\n /* Nonzero if TYPE represents an integral type.  Note that we do not\n    include COMPLEX types here.  Keep these checks in ascending code\n    order.  */\n@@ -3895,6 +3901,8 @@ extern tree build_reference_type_for_mode (tree, machine_mode, bool);\n extern tree build_reference_type (tree);\n extern tree build_vector_type_for_mode (tree, machine_mode);\n extern tree build_vector_type (tree innertype, int nunits);\n+extern tree build_truth_vector_type (unsigned, unsigned);\n+extern tree build_same_sized_truth_vector_type (tree vectype);\n extern tree build_opaque_vector_type (tree innertype, int nunits);\n extern tree build_index_type (tree);\n extern tree build_array_type (tree, tree);\n@@ -4615,6 +4623,7 @@ extern void init_ttree (void);\n extern void build_common_tree_nodes (bool, bool);\n extern void build_common_builtin_nodes (void);\n extern tree build_nonstandard_integer_type (unsigned HOST_WIDE_INT, int);\n+extern tree build_nonstandard_boolean_type (unsigned HOST_WIDE_INT);\n extern tree build_range_type (tree, tree, tree);\n extern tree build_nonshared_range_type (tree, tree, tree);\n extern bool subrange_type_for_debug_p (const_tree, tree *, tree *);"}]}