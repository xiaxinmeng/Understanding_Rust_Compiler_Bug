{"sha": "32500433ce102db43dc4c43ce97820e0d2615fb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI1MDA0MzNjZTEwMmRiNDNkYzRjNDNjZTk3ODIwZTBkMjYxNWZiMw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-01-17T14:40:11Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-01-17T14:40:11Z"}, "message": "re PR tree-optimization/46590 (long compile time with -O2 and many loops)\n\n2014-01-17  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/46590\n\t* vec.h (vec<>::bseach): New member function implementing\n\tbinary search according to C89 bsearch.\n\t(vec<>::qsort): Avoid calling ::qsort for vectors with sizes 0 or 1.\n\t* tree-ssa-loop-im.c (struct mem_ref): Make stored member a\n\tbitmap pointer again.  Make accesses_in_loop a flat array.\n\t(mem_ref_obstack): New global.\n\t(outermost_indep_loop): Adjust for mem_ref->stored changes.\n\t(mark_ref_stored): Likewise.\n\t(ref_indep_loop_p_2): Likewise.\n\t(set_ref_stored_in_loop): New helper function.\n\t(mem_ref_alloc): Allocate mem_refs on the mem_ref_obstack obstack.\n\t(memref_free): Adjust.\n\t(record_mem_ref_loc): Simplify.\n\t(gather_mem_refs_stmt): Adjust.\n\t(sort_locs_in_loop_postorder_cmp): New function.\n\t(analyze_memory_references): Sort accesses_in_loop after\n\tloop postorder number.\n\t(find_ref_loc_in_loop_cmp): New function.\n\t(for_all_locs_in_loop): Find relevant cluster of locs in\n\taccesses_in_loop and iterate without recursion.\n\t(execute_sm): Avoid uninit warning.\n\t(struct ref_always_accessed): Simplify.\n\t(ref_always_accessed::operator ()): Likewise.\n\t(ref_always_accessed_p): Likewise.\n\t(tree_ssa_lim_initialize): Initialize mem_ref_obstack, compute\n\tloop postorder numbers here.\n\t(tree_ssa_lim_finalize): Free mem_ref_obstack and loop postorder\n\tnumbers.\n\nFrom-SVN: r206709", "tree": {"sha": "2287fbea3d96ba177cef06d334d06ad153958a8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2287fbea3d96ba177cef06d334d06ad153958a8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32500433ce102db43dc4c43ce97820e0d2615fb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32500433ce102db43dc4c43ce97820e0d2615fb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32500433ce102db43dc4c43ce97820e0d2615fb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32500433ce102db43dc4c43ce97820e0d2615fb3/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "24fcf4bc0c6ac701e9c2e1ae1f92908c50afd11f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24fcf4bc0c6ac701e9c2e1ae1f92908c50afd11f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24fcf4bc0c6ac701e9c2e1ae1f92908c50afd11f"}], "stats": {"total": 247, "additions": 194, "deletions": 53}, "files": [{"sha": "0402a4d30e25ea23362a5ce6e30da885ba34f8b0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32500433ce102db43dc4c43ce97820e0d2615fb3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32500433ce102db43dc4c43ce97820e0d2615fb3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32500433ce102db43dc4c43ce97820e0d2615fb3", "patch": "@@ -1,3 +1,35 @@\n+2014-01-17  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/46590\n+\t* vec.h (vec<>::bseach): New member function implementing\n+\tbinary search according to C89 bsearch.\n+\t(vec<>::qsort): Avoid calling ::qsort for vectors with sizes 0 or 1.\n+\t* tree-ssa-loop-im.c (struct mem_ref): Make stored member a\n+\tbitmap pointer again.  Make accesses_in_loop a flat array.\n+\t(mem_ref_obstack): New global.\n+\t(outermost_indep_loop): Adjust for mem_ref->stored changes.\n+\t(mark_ref_stored): Likewise.\n+\t(ref_indep_loop_p_2): Likewise.\n+\t(set_ref_stored_in_loop): New helper function.\n+\t(mem_ref_alloc): Allocate mem_refs on the mem_ref_obstack obstack.\n+\t(memref_free): Adjust.\n+\t(record_mem_ref_loc): Simplify.\n+\t(gather_mem_refs_stmt): Adjust.\n+\t(sort_locs_in_loop_postorder_cmp): New function.\n+\t(analyze_memory_references): Sort accesses_in_loop after\n+\tloop postorder number.\n+\t(find_ref_loc_in_loop_cmp): New function.\n+\t(for_all_locs_in_loop): Find relevant cluster of locs in\n+\taccesses_in_loop and iterate without recursion.\n+\t(execute_sm): Avoid uninit warning.\n+\t(struct ref_always_accessed): Simplify.\n+\t(ref_always_accessed::operator ()): Likewise.\n+\t(ref_always_accessed_p): Likewise.\n+\t(tree_ssa_lim_initialize): Initialize mem_ref_obstack, compute\n+\tloop postorder numbers here.\n+\t(tree_ssa_lim_finalize): Free mem_ref_obstack and loop postorder\n+\tnumbers.\n+\n 2014-01-17  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR c++/57945"}, {"sha": "c75f25749aeab0aa6b6a4df607515196758f3352", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 109, "deletions": 52, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32500433ce102db43dc4c43ce97820e0d2615fb3/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32500433ce102db43dc4c43ce97820e0d2615fb3/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=32500433ce102db43dc4c43ce97820e0d2615fb3", "patch": "@@ -126,9 +126,9 @@ typedef struct mem_ref\n      query meta-data.  */\n   ao_ref mem;\n \n-  bitmap_head stored;\t\t/* The set of loops in that this memory location\n+  bitmap stored;\t\t/* The set of loops in that this memory location\n \t\t\t\t   is stored to.  */\n-  vec<vec<mem_ref_loc> > accesses_in_loop;\n+  vec<mem_ref_loc>\t\taccesses_in_loop;\n \t\t\t\t/* The locations of the accesses.  Vector\n \t\t\t\t   indexed by the loop number.  */\n \n@@ -204,6 +204,7 @@ static struct\n \n /* Obstack for the bitmaps in the above data structures.  */\n static bitmap_obstack lim_bitmap_obstack;\n+static obstack mem_ref_obstack;\n \n static bool ref_indep_loop_p (struct loop *, mem_ref_p);\n \n@@ -546,13 +547,13 @@ outermost_indep_loop (struct loop *outer, struct loop *loop, mem_ref_p ref)\n {\n   struct loop *aloop;\n \n-  if (bitmap_bit_p (&ref->stored, loop->num))\n+  if (ref->stored && bitmap_bit_p (ref->stored, loop->num))\n     return NULL;\n \n   for (aloop = outer;\n        aloop != loop;\n        aloop = superloop_at_depth (loop, loop_depth (aloop) + 1))\n-    if (!bitmap_bit_p (&ref->stored, aloop->num)\n+    if ((!ref->stored || !bitmap_bit_p (ref->stored, aloop->num))\n \t&& ref_indep_loop_p (aloop, ref))\n       return aloop;\n \n@@ -1383,14 +1384,7 @@ force_move_till (tree ref, tree *index, void *data)\n static void\n memref_free (struct mem_ref *mem)\n {\n-  unsigned i;\n-  vec<mem_ref_loc> *accs;\n-\n-  FOR_EACH_VEC_ELT (mem->accesses_in_loop, i, accs)\n-    accs->release ();\n   mem->accesses_in_loop.release ();\n-\n-  free (mem);\n }\n \n /* Allocates and returns a memory reference description for MEM whose hash\n@@ -1399,14 +1393,14 @@ memref_free (struct mem_ref *mem)\n static mem_ref_p\n mem_ref_alloc (tree mem, unsigned hash, unsigned id)\n {\n-  mem_ref_p ref = XNEW (struct mem_ref);\n+  mem_ref_p ref = XOBNEW (&mem_ref_obstack, struct mem_ref);\n   ao_ref_init (&ref->mem, mem);\n   ref->id = id;\n   ref->hash = hash;\n-  bitmap_initialize (&ref->stored, &lim_bitmap_obstack);\n+  ref->stored = NULL;\n   bitmap_initialize (&ref->indep_loop, &lim_bitmap_obstack);\n   bitmap_initialize (&ref->dep_loop, &lim_bitmap_obstack);\n-  ref->accesses_in_loop.create (0);\n+  ref->accesses_in_loop.create (1);\n \n   return ref;\n }\n@@ -1415,17 +1409,23 @@ mem_ref_alloc (tree mem, unsigned hash, unsigned id)\n    description REF.  The reference occurs in statement STMT.  */\n \n static void\n-record_mem_ref_loc (mem_ref_p ref, struct loop *loop, gimple stmt, tree *loc)\n+record_mem_ref_loc (mem_ref_p ref, gimple stmt, tree *loc)\n {\n   mem_ref_loc aref;\n-\n-  if (ref->accesses_in_loop.length ()\n-      <= (unsigned) loop->num)\n-    ref->accesses_in_loop.safe_grow_cleared (loop->num + 1);\n-\n   aref.stmt = stmt;\n   aref.ref = loc;\n-  ref->accesses_in_loop[loop->num].safe_push (aref);\n+  ref->accesses_in_loop.safe_push (aref);\n+}\n+\n+/* Set the LOOP bit in REF stored bitmap and allocate that if\n+   necessary.  Return whether a bit was changed.  */\n+\n+static bool\n+set_ref_stored_in_loop (mem_ref_p ref, struct loop *loop)\n+{\n+  if (!ref->stored)\n+    ref->stored = BITMAP_ALLOC (&lim_bitmap_obstack);\n+  return bitmap_set_bit (ref->stored, loop->num);\n }\n \n /* Marks reference REF as stored in LOOP.  */\n@@ -1434,7 +1434,7 @@ static void\n mark_ref_stored (mem_ref_p ref, struct loop *loop)\n {\n   while (loop != current_loops->tree_root\n-\t && bitmap_set_bit (&ref->stored, loop->num))\n+\t && set_ref_stored_in_loop (ref, loop))\n     loop = loop_outer (loop);\n }\n \n@@ -1493,7 +1493,7 @@ gather_mem_refs_stmt (struct loop *loop, gimple stmt)\n \t    }\n \t}\n \n-      record_mem_ref_loc (ref, loop, stmt, mem);\n+      record_mem_ref_loc (ref, stmt, mem);\n     }\n   bitmap_set_bit (&memory_accesses.refs_in_loop[loop->num], ref->id);\n   if (is_stored)\n@@ -1520,6 +1520,20 @@ sort_bbs_in_loop_postorder_cmp (const void *bb1_, const void *bb2_)\n   return bb_loop_postorder[loop1->num] < bb_loop_postorder[loop2->num] ? -1 : 1;\n }\n \n+/* qsort sort function to sort ref locs after their loop fathers postorder.  */\n+\n+static int\n+sort_locs_in_loop_postorder_cmp (const void *loc1_, const void *loc2_)\n+{\n+  mem_ref_loc *loc1 = (mem_ref_loc *)const_cast<void *>(loc1_);\n+  mem_ref_loc *loc2 = (mem_ref_loc *)const_cast<void *>(loc2_);\n+  struct loop *loop1 = gimple_bb (loc1->stmt)->loop_father;\n+  struct loop *loop2 = gimple_bb (loc2->stmt)->loop_father;\n+  if (loop1->num == loop2->num)\n+    return 0;\n+  return bb_loop_postorder[loop1->num] < bb_loop_postorder[loop2->num] ? -1 : 1;\n+}\n+\n /* Gathers memory references in loops.  */\n \n static void\n@@ -1530,12 +1544,15 @@ analyze_memory_references (void)\n   struct loop *loop, *outer;\n   unsigned i, n;\n \n+#if 0\n   /* Initialize bb_loop_postorder with a mapping from loop->num to\n      its postorder index.  */\n   i = 0;\n   bb_loop_postorder = XNEWVEC (unsigned, number_of_loops (cfun));\n   FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n     bb_loop_postorder[loop->num] = i++;\n+#endif\n+\n   /* Collect all basic-blocks in loops and sort them after their\n      loops postorder.  */\n   i = 0;\n@@ -1545,7 +1562,6 @@ analyze_memory_references (void)\n       bbs[i++] = bb;\n   n = i;\n   qsort (bbs, n, sizeof (basic_block), sort_bbs_in_loop_postorder_cmp);\n-  free (bb_loop_postorder);\n \n   /* Visit blocks in loop postorder and assign mem-ref IDs in that order.\n      That results in better locality for all the bitmaps.  */\n@@ -1556,7 +1572,14 @@ analyze_memory_references (void)\n         gather_mem_refs_stmt (bb->loop_father, gsi_stmt (bsi));\n     }\n \n+  /* Sort the location list of gathered memory references after their\n+     loop postorder number.  */\n+  mem_ref *ref;\n+  FOR_EACH_VEC_ELT (memory_accesses.refs_list, i, ref)\n+    ref->accesses_in_loop.qsort (sort_locs_in_loop_postorder_cmp);\n+\n   free (bbs);\n+//  free (bb_loop_postorder);\n \n   /* Propagate the information about accessed memory references up\n      the loop hierarchy.  */\n@@ -1612,6 +1635,22 @@ mem_refs_may_alias_p (mem_ref_p mem1, mem_ref_p mem2,\n   return true;\n }\n \n+/* Compare function for bsearch searching for reference locations\n+   in a loop.  */\n+\n+static int\n+find_ref_loc_in_loop_cmp (const void *loop_, const void *loc_)\n+{\n+  struct loop *loop = (struct loop *)const_cast<void *>(loop_);\n+  mem_ref_loc *loc = (mem_ref_loc *)const_cast<void *>(loc_);\n+  struct loop *loc_loop = gimple_bb (loc->stmt)->loop_father;\n+  if (loop->num  == loc_loop->num\n+      || flow_loop_nested_p (loop, loc_loop))\n+    return 0;\n+  return (bb_loop_postorder[loop->num] < bb_loop_postorder[loc_loop->num]\n+\t  ? -1 : 1);\n+}\n+\n /* Iterates over all locations of REF in LOOP and its subloops calling\n    fn.operator() with the location as argument.  When that operator\n    returns true the iteration is stopped and true is returned.\n@@ -1623,16 +1662,34 @@ for_all_locs_in_loop (struct loop *loop, mem_ref_p ref, FN fn)\n {\n   unsigned i;\n   mem_ref_loc_p loc;\n-  struct loop *subloop;\n \n-  if (ref->accesses_in_loop.length () > (unsigned) loop->num)\n-    FOR_EACH_VEC_ELT (ref->accesses_in_loop[loop->num], i, loc)\n-      if (fn (loc))\n-\treturn true;\n+  /* Search for the cluster of locs in the accesses_in_loop vector\n+     which is sorted after postorder index of the loop father.  */\n+  loc = ref->accesses_in_loop.bsearch (loop, find_ref_loc_in_loop_cmp);\n+  if (!loc)\n+    return false;\n \n-  for (subloop = loop->inner; subloop != NULL; subloop = subloop->next)\n-    if (for_all_locs_in_loop (subloop, ref, fn))\n-      return true;\n+  /* We have found one location inside loop or its sub-loops.  Iterate\n+     both forward and backward to cover the whole cluster.  */\n+  i = loc - ref->accesses_in_loop.address ();\n+  while (i > 0)\n+    {\n+      --i;\n+      mem_ref_loc_p l = &ref->accesses_in_loop[i];\n+      if (!flow_bb_inside_loop_p (loop, gimple_bb (l->stmt)))\n+\tbreak;\n+      if (fn (l))\n+\treturn true;\n+    }\n+  for (i = loc - ref->accesses_in_loop.address ();\n+       i < ref->accesses_in_loop.length (); ++i)\n+    {\n+      mem_ref_loc_p l = &ref->accesses_in_loop[i];\n+      if (!flow_bb_inside_loop_p (loop, gimple_bb (l->stmt)))\n+\tbreak;\n+      if (fn (l))\n+\treturn true;\n+    }\n \n   return false;\n }\n@@ -1871,7 +1928,7 @@ execute_sm_if_changed_flag_set (struct loop *loop, mem_ref_p ref)\n static void\n execute_sm (struct loop *loop, vec<edge> exits, mem_ref_p ref)\n {\n-  tree tmp_var, store_flag;\n+  tree tmp_var, store_flag = NULL_TREE;\n   unsigned i;\n   gimple load;\n   struct fmt_data fmt_data;\n@@ -1958,11 +2015,10 @@ hoist_memory_references (struct loop *loop, bitmap mem_refs,\n \n struct ref_always_accessed\n {\n-  ref_always_accessed (struct loop *loop_, tree base_, bool stored_p_)\n-      : loop (loop_), base (base_), stored_p (stored_p_) {}\n+  ref_always_accessed (struct loop *loop_, bool stored_p_)\n+      : loop (loop_), stored_p (stored_p_) {}\n   bool operator () (mem_ref_loc_p loc);\n   struct loop *loop;\n-  tree base;\n   bool stored_p;\n };\n \n@@ -1978,16 +2034,9 @@ ref_always_accessed::operator () (mem_ref_loc_p loc)\n      stores to the reference.  */\n   if (stored_p)\n     {\n-      tree lhs;\n-      if (!gimple_get_lhs (loc->stmt))\n-\treturn false;\n-      lhs = get_base_address (gimple_get_lhs (loc->stmt));\n-      if (!lhs)\n-\treturn false;\n-      if (INDIRECT_REF_P (lhs)\n-\t  || TREE_CODE (lhs) == MEM_REF)\n-\tlhs = TREE_OPERAND (lhs, 0);\n-      if (lhs != base)\n+      tree lhs = gimple_get_lhs (loc->stmt);\n+      if (!lhs\n+\t  || lhs != *loc->ref)\n \treturn false;\n     }\n \n@@ -2008,12 +2057,8 @@ ref_always_accessed::operator () (mem_ref_loc_p loc)\n static bool\n ref_always_accessed_p (struct loop *loop, mem_ref_p ref, bool stored_p)\n {\n-  tree base = ao_ref_base (&ref->mem);\n-  if (TREE_CODE (base) == MEM_REF)\n-    base = TREE_OPERAND (base, 0);\n-\n   return for_all_locs_in_loop (loop, ref,\n-\t\t\t       ref_always_accessed (loop, base, stored_p));\n+\t\t\t       ref_always_accessed (loop, stored_p));\n }\n \n /* Returns true if REF1 and REF2 are independent.  */\n@@ -2090,7 +2135,7 @@ ref_indep_loop_p_1 (struct loop *loop, mem_ref_p ref, bool stored_p)\n static bool\n ref_indep_loop_p_2 (struct loop *loop, mem_ref_p ref, bool stored_p)\n {\n-  stored_p |= bitmap_bit_p (&ref->stored, loop->num);\n+  stored_p |= (ref->stored && bitmap_bit_p (ref->stored, loop->num));\n \n   if (bitmap_bit_p (&ref->indep_loop, LOOP_DEP_BIT (loop->num, stored_p)))\n     return true;\n@@ -2370,9 +2415,11 @@ fill_always_executed_in (void)\n static void\n tree_ssa_lim_initialize (void)\n {\n+  struct loop *loop;\n   unsigned i;\n \n   bitmap_obstack_initialize (&lim_bitmap_obstack);\n+  gcc_obstack_init (&mem_ref_obstack);\n   lim_aux_data_map = pointer_map_create ();\n \n   if (flag_tm)\n@@ -2404,6 +2451,13 @@ tree_ssa_lim_initialize (void)\n     }\n \n   memory_accesses.ttae_cache = NULL;\n+\n+  /* Initialize bb_loop_postorder with a mapping from loop->num to\n+     its postorder index.  */\n+  i = 0;\n+  bb_loop_postorder = XNEWVEC (unsigned, number_of_loops (cfun));\n+  FOR_EACH_LOOP (loop, LI_FROM_INNERMOST)\n+    bb_loop_postorder[loop->num] = i++;\n }\n \n /* Cleans up after the invariant motion pass.  */\n@@ -2428,13 +2482,16 @@ tree_ssa_lim_finalize (void)\n   FOR_EACH_VEC_ELT (memory_accesses.refs_list, i, ref)\n     memref_free (ref);\n   memory_accesses.refs_list.release ();\n+  obstack_free (&mem_ref_obstack, NULL);\n \n   memory_accesses.refs_in_loop.release ();\n   memory_accesses.refs_stored_in_loop.release ();\n   memory_accesses.all_refs_stored_in_loop.release ();\n \n   if (memory_accesses.ttae_cache)\n     free_affine_expand_cache (&memory_accesses.ttae_cache);\n+\n+  free (bb_loop_postorder);\n }\n \n /* Moves invariants from loops.  Only \"expensive\" invariants are moved out --"}, {"sha": "4e8e3b877d47e7884fe1789abd12b719466f9ab2", "filename": "gcc/vec.h", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32500433ce102db43dc4c43ce97820e0d2615fb3/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32500433ce102db43dc4c43ce97820e0d2615fb3/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=32500433ce102db43dc4c43ce97820e0d2615fb3", "patch": "@@ -476,6 +476,7 @@ struct GTY((user)) vec<T, A, vl_embed>\n   void unordered_remove (unsigned);\n   void block_remove (unsigned, unsigned);\n   void qsort (int (*) (const void *, const void *));\n+  T *bsearch (const void *key, int (*compar)(const void *, const void *));\n   unsigned lower_bound (T, bool (*)(const T &, const T &)) const;\n   static size_t embedded_size (unsigned);\n   void embedded_init (unsigned, unsigned = 0);\n@@ -938,7 +939,43 @@ template<typename T, typename A>\n inline void\n vec<T, A, vl_embed>::qsort (int (*cmp) (const void *, const void *))\n {\n-  ::qsort (address (), length (), sizeof (T), cmp);\n+  if (length () > 1)\n+    ::qsort (address (), length (), sizeof (T), cmp);\n+}\n+\n+\n+/* Search the contents of the sorted vector with a binary search.\n+   CMP is the comparison function to pass to bsearch.  */\n+\n+template<typename T, typename A>\n+inline T *\n+vec<T, A, vl_embed>::bsearch (const void *key,\n+\t\t\t      int (*compar) (const void *, const void *))\n+{\n+  const void *base = this->address ();\n+  size_t nmemb = this->length ();\n+  size_t size = sizeof (T);\n+  /* The following is a copy of glibc stdlib-bsearch.h.  */\n+  size_t l, u, idx;\n+  const void *p;\n+  int comparison;\n+\n+  l = 0;\n+  u = nmemb;\n+  while (l < u)\n+    {\n+      idx = (l + u) / 2;\n+      p = (const void *) (((const char *) base) + (idx * size));\n+      comparison = (*compar) (key, p);\n+      if (comparison < 0)\n+\tu = idx;\n+      else if (comparison > 0)\n+\tl = idx + 1;\n+      else\n+\treturn (T *)const_cast<void *>(p);\n+    }\n+\n+  return NULL;\n }\n \n \n@@ -1174,6 +1211,7 @@ struct vec<T, va_heap, vl_ptr>\n   void unordered_remove (unsigned);\n   void block_remove (unsigned, unsigned);\n   void qsort (int (*) (const void *, const void *));\n+  T *bsearch (const void *key, int (*compar)(const void *, const void *));\n   unsigned lower_bound (T, bool (*)(const T &, const T &)) const;\n \n   bool using_auto_storage () const;\n@@ -1635,6 +1673,20 @@ vec<T, va_heap, vl_ptr>::qsort (int (*cmp) (const void *, const void *))\n }\n \n \n+/* Search the contents of the sorted vector with a binary search.\n+   CMP is the comparison function to pass to bsearch.  */\n+\n+template<typename T>\n+inline T *\n+vec<T, va_heap, vl_ptr>::bsearch (const void *key,\n+\t\t\t\t  int (*cmp) (const void *, const void *))\n+{\n+  if (m_vec)\n+    return m_vec->bsearch (key, cmp);\n+  return NULL;\n+}\n+\n+\n /* Find and return the first position in which OBJ could be inserted\n    without changing the ordering of this vector.  LESSTHAN is a\n    function that returns true if the first argument is strictly less"}]}