{"sha": "672d9f8eab3e81bd80098fc5b16eac116eec7658", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjcyZDlmOGVhYjNlODFiZDgwMDk4ZmM1YjE2ZWFjMTE2ZWVjNzY1OA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-03-27T07:35:44Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-03-27T07:35:44Z"}, "message": "re PR tree-optimization/80171 (ICE (Segmentation fault) with optimization)\n\n2017-03-27  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/80171\n\t* gimple-fold.c (fold_ctor_reference): Properly guard against\n\tNULL return value from canonicalize_constructor_val.\n\n\t* g++.dg/torture/pr80171.C: New testcase.\n\nFrom-SVN: r246490", "tree": {"sha": "fa108e9fd723010fb2d03e321b4ca9fc93c720fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa108e9fd723010fb2d03e321b4ca9fc93c720fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/672d9f8eab3e81bd80098fc5b16eac116eec7658", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/672d9f8eab3e81bd80098fc5b16eac116eec7658", "html_url": "https://github.com/Rust-GCC/gccrs/commit/672d9f8eab3e81bd80098fc5b16eac116eec7658", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/672d9f8eab3e81bd80098fc5b16eac116eec7658/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fbede6f9c01ab4d8dd7648ab681f364c35a983ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbede6f9c01ab4d8dd7648ab681f364c35a983ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbede6f9c01ab4d8dd7648ab681f364c35a983ad"}], "stats": {"total": 201, "additions": 199, "deletions": 2}, "files": [{"sha": "3ef30163ab9c390bb07dfd91757c41e147cd2c06", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672d9f8eab3e81bd80098fc5b16eac116eec7658/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672d9f8eab3e81bd80098fc5b16eac116eec7658/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=672d9f8eab3e81bd80098fc5b16eac116eec7658", "patch": "@@ -1,3 +1,9 @@\n+2017-03-27  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/80171\n+\t* gimple-fold.c (fold_ctor_reference): Properly guard against\n+\tNULL return value from canonicalize_constructor_val.\n+\n 2017-03-25  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/80180"}, {"sha": "3094b54c109d06d1b0d98b6afd30d69d2f0ba19b", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672d9f8eab3e81bd80098fc5b16eac116eec7658/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672d9f8eab3e81bd80098fc5b16eac116eec7658/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=672d9f8eab3e81bd80098fc5b16eac116eec7658", "patch": "@@ -6239,9 +6239,12 @@ fold_ctor_reference (tree type, tree ctor, unsigned HOST_WIDE_INT offset,\n       && !compare_tree_int (TYPE_SIZE (TREE_TYPE (ctor)), size))\n     {\n       ret = canonicalize_constructor_val (unshare_expr (ctor), from_decl);\n-      ret = fold_unary (VIEW_CONVERT_EXPR, type, ret);\n       if (ret)\n-\tSTRIP_USELESS_TYPE_CONVERSION (ret);\n+\t{\n+\t  ret = fold_unary (VIEW_CONVERT_EXPR, type, ret);\n+\t  if (ret)\n+\t    STRIP_USELESS_TYPE_CONVERSION (ret);\n+\t}\n       return ret;\n     }\n   /* For constants and byte-aligned/sized reads try to go through"}, {"sha": "65c8310a7f9a555b91e65106262973173c769edc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672d9f8eab3e81bd80098fc5b16eac116eec7658/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672d9f8eab3e81bd80098fc5b16eac116eec7658/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=672d9f8eab3e81bd80098fc5b16eac116eec7658", "patch": "@@ -1,3 +1,8 @@\n+2017-03-27  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/80171\n+\t* g++.dg/torture/pr80171.C: New testcase.\n+\n 2017-03-26  John David Anglin  <danglin@gcc.gnu.org>\n \n \t* gcc.dg/torture/pr79732.c: Require alias support."}, {"sha": "81f272583c5dd8bbd07ee109d265c04312eac36a", "filename": "gcc/testsuite/g++.dg/torture/pr80171.C", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/672d9f8eab3e81bd80098fc5b16eac116eec7658/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr80171.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/672d9f8eab3e81bd80098fc5b16eac116eec7658/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr80171.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr80171.C?ref=672d9f8eab3e81bd80098fc5b16eac116eec7658", "patch": "@@ -0,0 +1,183 @@\n+// { dg-do compile }\n+\n+template <typename> struct remove_reference;\n+template <typename _Tp> struct remove_reference<_Tp &> { typedef _Tp type; };\n+template <typename _Tp> typename remove_reference<_Tp>::type move(_Tp &&p1) {\n+  return static_cast<typename remove_reference<_Tp>::type &&>(p1);\n+}\n+void *operator new(__SIZE_TYPE__, void *p2) { return p2; }\n+struct Trans_NS__v1_GenericTlv {\n+  virtual int getMinimumValueLength();\n+  virtual unsigned long getValueLength() const;\n+};\n+struct IPv4NeighborAddressSubTlv;\n+struct Trans_NS__v1_GenericTlvBase : Trans_NS__v1_GenericTlv {\n+  virtual bool operator==(const IPv4NeighborAddressSubTlv &) const;\n+};\n+struct Trans_NS__v1_GenericUnsupportedTlv;\n+template <typename> struct backup_holder {\n+  Trans_NS__v1_GenericUnsupportedTlv *backup_;\n+  Trans_NS__v1_GenericUnsupportedTlv &get() { return *backup_; }\n+};\n+template <typename> struct make_reference_content {\n+  typedef IPv4NeighborAddressSubTlv type;\n+};\n+template <typename> struct unwrap_recursive {\n+  typedef IPv4NeighborAddressSubTlv type;\n+};\n+template <typename> struct begin_impl;\n+template <typename Sequence> struct begin {\n+  typedef typename Sequence::tag tag_;\n+  typedef typename begin_impl<tag_>::template apply<Sequence>::type type;\n+};\n+struct long_ {\n+  static const int value = 0;\n+};\n+template <typename> struct O1_size_impl;\n+template <typename Sequence>\n+struct O1_size\n+    : O1_size_impl<typename Sequence::tag>::template apply<Sequence> {};\n+template <typename F, typename T2>\n+struct apply_wrap2 : F::template apply<int, T2> {};\n+template <int, typename, typename> struct iter_fold_impl;\n+template <typename First, typename ForwardOp>\n+struct iter_fold_impl<0, First, ForwardOp> {\n+  typedef typename apply_wrap2<ForwardOp, First>::type state;\n+};\n+template <typename Sequence, typename ForwardOp> struct iter_fold {\n+  typedef\n+      typename iter_fold_impl<O1_size<Sequence>::value,\n+                              typename begin<Sequence>::type, ForwardOp>::state\n+          type;\n+};\n+template <typename> struct deref;\n+template <typename T1> struct pair { typedef T1 first; };\n+struct make_initializer_node {\n+  template <typename, typename Iterator> struct apply {\n+    struct initializer_node {\n+      typedef typename deref<Iterator>::type recursive_enabled_T;\n+      static int\n+      initialize(void *p1,\n+                 typename unwrap_recursive<recursive_enabled_T>::type) {\n+        new (p1) typename make_reference_content<recursive_enabled_T>::type;\n+      }\n+    };\n+    typedef pair<initializer_node> type;\n+  };\n+};\n+struct l_item {\n+  typedef int tag;\n+  typedef l_item type;\n+  typedef long_ size;\n+  typedef int item;\n+};\n+template <> struct O1_size_impl<int> {\n+  template <typename List> struct apply : List::size {};\n+};\n+template <typename> struct l_iter;\n+template <typename Node> struct deref<l_iter<Node>> {\n+  typedef typename Node::item type;\n+};\n+template <> struct begin_impl<int> {\n+  template <typename List> struct apply {\n+    typedef l_iter<typename List::type> type;\n+  };\n+};\n+template <typename, typename, typename, typename, typename, typename, typename>\n+struct list : l_item {};\n+template <typename... T> struct make_variant_list { typedef list<T...> type; };\n+template <typename T> T cast_storage(void *p1) { return *static_cast<T *>(p1); }\n+struct visitation_impl_step {\n+  typedef Trans_NS__v1_GenericUnsupportedTlv type;\n+};\n+template <typename Visitor, typename VoidPtrCV, typename T>\n+void visitation_impl_invoke_impl(Visitor p1, VoidPtrCV p2, T *) {\n+  backup_holder<Trans_NS__v1_GenericUnsupportedTlv> __trans_tmp_8 =\n+      cast_storage<backup_holder<T>>(p2);\n+  p1.internal_visit(__trans_tmp_8, 0);\n+}\n+template <typename Visitor, typename VoidPtrCV, typename T,\n+          typename NoBackupFlag>\n+void visitation_impl_invoke(Visitor p1, VoidPtrCV p2, T p3, NoBackupFlag) {\n+  visitation_impl_invoke_impl(p1, p2, p3);\n+}\n+template <typename Which, typename step0, typename Visitor, typename VoidPtrCV,\n+          typename NoBackupFlag>\n+void visitation_impl(Visitor p1, VoidPtrCV p2, NoBackupFlag, Which, step0 *) {\n+  visitation_impl_invoke(p1, p2, static_cast<typename step0::type *>(0), 0);\n+}\n+struct move_into {\n+  move_into(void *);\n+  template <typename T> void internal_visit(backup_holder<T> p1, int) {\n+    T __trans_tmp_2 = p1.get();\n+    new (0) T(__trans_tmp_2);\n+  }\n+};\n+template <typename, typename... TN> struct variant {\n+  struct initializer : iter_fold<typename make_variant_list<int, TN...>::type,\n+                                 make_initializer_node>::type::first {};\n+  template <typename T> void convert_construct(T p1, int) {\n+    void *__trans_tmp_9 = this;\n+    initializer::initialize(__trans_tmp_9, p1);\n+  }\n+  template <typename T> variant(T p1) { convert_construct(p1, 0); }\n+  variant(variant &&p1) {\n+    move_into visitor(0);\n+    p1.internal_apply_visitor(visitor);\n+  }\n+  template <typename Visitor> void internal_apply_visitor(Visitor p1) {\n+    void *__trans_tmp_10 = this;\n+    visitation_impl(p1, __trans_tmp_10, 0, 0,\n+                    static_cast<visitation_impl_step *>(0));\n+  }\n+};\n+template <class...> struct generic_element_tlvs;\n+template <typename TlvConfig, class UnsupportedTlvClass, class TlvF,\n+          class... TlvR>\n+struct generic_element_tlvs<TlvConfig, UnsupportedTlvClass, TlvF, TlvR...> {\n+  typedef variant<UnsupportedTlvClass, TlvF, TlvR...> variant_type;\n+};\n+template <typename, typename> struct Trans_NS__v1_GenericTlvContainer {\n+  template <class TlvClass> void addTlv(const TlvClass &);\n+};\n+template <typename TlvConfig, typename ElementTlvs>\n+template <class TlvClass>\n+void Trans_NS__v1_GenericTlvContainer<TlvConfig, ElementTlvs>::addTlv(\n+    const TlvClass &p1) {\n+  typename ElementTlvs::variant_type wrap(p1);\n+  move(wrap);\n+}\n+template <typename ElementTlvs>\n+struct Trans_NS__v1_GenericContainerEntryBase\n+    : Trans_NS__v1_GenericTlvContainer<int, ElementTlvs> {};\n+template <class>\n+struct Trans_NS__v1_GenericFixedLengthTlvBase : Trans_NS__v1_GenericTlvBase {\n+  unsigned long getValueLength() const;\n+};\n+struct Trans_NS__v1_GenericUnsupportedTlv : Trans_NS__v1_GenericTlv {\n+  long getHeaderLengthconst;\n+};\n+using isis_tlv_config = int;\n+template <class... TlvClasses>\n+using isis_element_tlvs =\n+    generic_element_tlvs<isis_tlv_config, Trans_NS__v1_GenericUnsupportedTlv,\n+                         TlvClasses...>;\n+template <int, class, typename ElementTlvs>\n+using ContainerEntryBase = Trans_NS__v1_GenericContainerEntryBase<ElementTlvs>;\n+template <int, class ImplClass, int>\n+using FixedLengthTlvBase = Trans_NS__v1_GenericFixedLengthTlvBase<ImplClass>;\n+struct IPv4NeighborAddressSubTlv\n+    : FixedLengthTlvBase<0, IPv4NeighborAddressSubTlv, 0> {\n+  bool operator==(const IPv4NeighborAddressSubTlv &) const;\n+};\n+void test() {\n+  ContainerEntryBase<\n+      0, int,\n+      isis_element_tlvs<\n+          FixedLengthTlvBase<0, int, 0>, FixedLengthTlvBase<0, int, 0>,\n+          IPv4NeighborAddressSubTlv, FixedLengthTlvBase<0, int, 0>,\n+          FixedLengthTlvBase<0, int, 0>, FixedLengthTlvBase<0, int, 0>>>\n+      isEntry;\n+  IPv4NeighborAddressSubTlv nbAddressSubTlv;\n+  isEntry.addTlv(nbAddressSubTlv);\n+}"}]}