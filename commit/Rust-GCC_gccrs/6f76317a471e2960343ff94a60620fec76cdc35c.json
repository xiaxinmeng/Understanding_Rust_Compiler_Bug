{"sha": "6f76317a471e2960343ff94a60620fec76cdc35c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY3NjMxN2E0NzFlMjk2MDM0M2ZmOTRhNjA2MjBmZWM3NmNkYzM1Yw==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-03-11T20:28:00Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2018-03-11T20:28:00Z"}, "message": "re PR fortran/66128 (ICE for some intrinsics with zero sized array parameter)\n\n2018-03-11  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/66128\n\t* simplify.c (simplify_transformation): Return default result for\n\tempty array argument.\n\t(gfc_simplify_all): Remove special-case handling for zerosize.\n\t(gfc_simplify_any): Likewise.\n\t(gfc_simplify_count): Likewise.\n\t(gfc_simplify_iall): Likewise.\n\t(gfc_simplify_iany): Likewise.\n\t(gfc_simplify_iparity): Likewise.\n\t(gfc_simplify_minval): Likewise.\n\t(gfc_simplify_maxval): Likewise.\n\t(gfc_simplify_norm2): Likewise.\n\t(gfc_simplify_product): Likewise.\n\t(gfc_simplify_sum): Likewise.\n\n2018-03-11  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR fortran/66128\n\t* gfortran.dg/zero_sized_9.f90: New test.\n\nFrom-SVN: r258435", "tree": {"sha": "12fb00fb1d72af63187d841668ec88eab41d869e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12fb00fb1d72af63187d841668ec88eab41d869e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f76317a471e2960343ff94a60620fec76cdc35c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f76317a471e2960343ff94a60620fec76cdc35c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f76317a471e2960343ff94a60620fec76cdc35c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f76317a471e2960343ff94a60620fec76cdc35c/comments", "author": null, "committer": null, "parents": [{"sha": "cd5437ab5d98cf95cc6686a533b7d3582bcb1706", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd5437ab5d98cf95cc6686a533b7d3582bcb1706", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd5437ab5d98cf95cc6686a533b7d3582bcb1706"}], "stats": {"total": 230, "additions": 72, "deletions": 158}, "files": [{"sha": "fe8947e61a5680de32fa0f8c11af3d2972899c1e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f76317a471e2960343ff94a60620fec76cdc35c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f76317a471e2960343ff94a60620fec76cdc35c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6f76317a471e2960343ff94a60620fec76cdc35c", "patch": "@@ -1,3 +1,20 @@\n+2017-06-11  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/66128\n+\t* simplify.c (simplify_transformation): Return default result for\n+\tempty array argument.\n+\t(gfc_simplify_all): Remove special-case handling for zerosize.\n+\t(gfc_simplify_any): Likewise.\n+\t(gfc_simplify_count): Likewise.\n+\t(gfc_simplify_iall): Likewise.\n+\t(gfc_simplify_iany): Likewise.\n+\t(gfc_simplify_iparity): Likewise.\n+\t(gfc_simplify_minval): Likewise.\n+\t(gfc_simplify_maxval): Likewise.\n+\t(gfc_simplify_norm2): Likewise.\n+\t(gfc_simplify_product): Likewise.\n+\t(gfc_simplify_sum): Likewise.\n+\n 2018-03-10  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/84734"}, {"sha": "680e625c13056d71c979931ef7e42c27e6117351", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 19, "deletions": 158, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f76317a471e2960343ff94a60620fec76cdc35c/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f76317a471e2960343ff94a60620fec76cdc35c/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=6f76317a471e2960343ff94a60620fec76cdc35c", "patch": "@@ -689,8 +689,11 @@ simplify_transformation (gfc_expr *array, gfc_expr *dim, gfc_expr *mask,\n \t\t\t int init_val, transformational_op op)\n {\n   gfc_expr *result;\n+  bool size_zero;\n \n-  if (!is_constant_array_expr (array)\n+  size_zero = gfc_is_size_zero_array (array);\n+\n+  if (!(is_constant_array_expr (array) || size_zero)\n       || !gfc_is_constant_expr (dim))\n     return NULL;\n \n@@ -703,6 +706,9 @@ simplify_transformation (gfc_expr *array, gfc_expr *dim, gfc_expr *mask,\n \t\t\t\t    array->ts.kind, &array->where);\n   init_result_expr (result, init_val, array);\n \n+  if (size_zero)\n+    return result;\n+\n   return !dim || array->rank == 1 ?\n     simplify_transformation_to_scalar (result, array, mask, op) :\n     simplify_transformation_to_array (result, array, dim, mask, op, NULL);\n@@ -976,9 +982,6 @@ gfc_simplify_aint (gfc_expr *e, gfc_expr *k)\n gfc_expr *\n gfc_simplify_all (gfc_expr *mask, gfc_expr *dim)\n {\n-  if (gfc_is_size_zero_array (mask))\n-    return gfc_get_logical_expr (mask->ts.kind, &mask->where, true);\n-\n   return simplify_transformation (mask, dim, NULL, true, gfc_and);\n }\n \n@@ -1068,9 +1071,6 @@ gfc_simplify_and (gfc_expr *x, gfc_expr *y)\n gfc_expr *\n gfc_simplify_any (gfc_expr *mask, gfc_expr *dim)\n {\n-  if (gfc_is_size_zero_array (mask))\n-    return gfc_get_logical_expr (mask->ts.kind, &mask->where, false);\n-\n   return simplify_transformation (mask, dim, NULL, false, gfc_or);\n }\n \n@@ -1966,15 +1966,11 @@ gfc_expr *\n gfc_simplify_count (gfc_expr *mask, gfc_expr *dim, gfc_expr *kind)\n {\n   gfc_expr *result;\n+  bool size_zero;\n \n-  if (gfc_is_size_zero_array (mask))\n-    {\n-      int k;\n-      k = kind ? mpz_get_si (kind->value.integer) : gfc_default_integer_kind;\n-      return gfc_get_int_expr (k, NULL, 0);\n-    }\n+  size_zero = gfc_is_size_zero_array (mask);\n \n-  if (!is_constant_array_expr (mask)\n+  if (!(is_constant_array_expr (mask) || size_zero)\n       || !gfc_is_constant_expr (dim)\n       || !gfc_is_constant_expr (kind))\n     return NULL;\n@@ -1987,6 +1983,9 @@ gfc_simplify_count (gfc_expr *mask, gfc_expr *dim, gfc_expr *kind)\n \n   init_result_expr (result, 0, NULL);\n \n+  if (size_zero)\n+    return result;\n+\n   /* Passing MASK twice, once as data array, once as mask.\n      Whenever gfc_count is called, '1' is added to the result.  */\n   return !dim || mask->rank == 1 ?\n@@ -3265,9 +3264,6 @@ do_bit_and (gfc_expr *result, gfc_expr *e)\n gfc_expr *\n gfc_simplify_iall (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n {\n-  if (gfc_is_size_zero_array (array))\n-    return gfc_get_int_expr (array->ts.kind, NULL, -1);\n-\n   return simplify_transformation (array, dim, mask, -1, do_bit_and);\n }\n \n@@ -3287,9 +3283,6 @@ do_bit_ior (gfc_expr *result, gfc_expr *e)\n gfc_expr *\n gfc_simplify_iany (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n {\n-  if (gfc_is_size_zero_array (array))\n-    return gfc_get_int_expr (array->ts.kind, NULL, 0);\n-\n   return simplify_transformation (array, dim, mask, 0, do_bit_ior);\n }\n \n@@ -3730,9 +3723,6 @@ do_bit_xor (gfc_expr *result, gfc_expr *e)\n gfc_expr *\n gfc_simplify_iparity (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n {\n-  if (gfc_is_size_zero_array (array))\n-    return gfc_get_int_expr (array->ts.kind, NULL, 0);\n-\n   return simplify_transformation (array, dim, mask, 0, do_bit_xor);\n }\n \n@@ -5040,43 +5030,6 @@ gfc_min (gfc_expr *op1, gfc_expr *op2)\n gfc_expr *\n gfc_simplify_minval (gfc_expr *array, gfc_expr* dim, gfc_expr *mask)\n {\n-  if (gfc_is_size_zero_array (array))\n-    {\n-      gfc_expr *result;\n-      int i;\n-\n-      i = gfc_validate_kind (array->ts.type, array->ts.kind, false);\n-      result = gfc_get_constant_expr (array->ts.type, array->ts.kind,\n-\t\t\t\t      &array->where);\n-      switch (array->ts.type)\n-\t{\n-\t  case BT_INTEGER:\n-\t    mpz_set (result->value.integer, gfc_integer_kinds[i].huge);\n-\t    break;\n-\n-\t  case BT_REAL:\n-\t    mpfr_set (result->value.real, gfc_real_kinds[i].huge, GFC_RND_MODE);\n-\t    break;\n-\n-\t  case BT_CHARACTER:\n-\t    /* If ARRAY has size zero and type character, the result has the\n-\t       value of a string of characters of length LEN (ARRAY), with\n-\t       each character equal to CHAR(n - 1, KIND (ARRAY)), where n is\n-\t       the number of characters in the collating sequence for\n-\t       characters with the kind type parameter of ARRAY.  */\n-\t    gfc_error (\"MINVAL(string) at %L is not implemented, yet!\",\n-\t\t\t&array->where);\n-\t    gfc_free_expr (result);\n-\t    return &gfc_bad_expr;\n-\t    break;\n-\n-\t  default:\n-\t    gcc_unreachable ();\n-    \t}\n-\n-      return result;\n-    }\n-\n   return simplify_transformation (array, dim, mask, INT_MAX, gfc_min);\n }\n \n@@ -5096,42 +5049,6 @@ gfc_max (gfc_expr *op1, gfc_expr *op2)\n gfc_expr *\n gfc_simplify_maxval (gfc_expr *array, gfc_expr* dim, gfc_expr *mask)\n {\n-  if (gfc_is_size_zero_array (array))\n-    {\n-      gfc_expr *result;\n-      int i;\n-\n-      i = gfc_validate_kind (array->ts.type, array->ts.kind, false);\n-      result = gfc_get_constant_expr (array->ts.type, array->ts.kind,\n-\t\t\t\t      &array->where);\n-      switch (array->ts.type)\n-\t{\n-\t  case BT_INTEGER:\n-\t    mpz_set (result->value.integer, gfc_integer_kinds[i].min_int);\n-\t    break;\n-\n-\t  case BT_REAL:\n-\t    mpfr_set (result->value.real, gfc_real_kinds[i].huge, GFC_RND_MODE);\n-\t    mpfr_neg (result->value.real, result->value.real,  GFC_RND_MODE);\n-\t    break;\n-\n-\t  case BT_CHARACTER:\n-\t    /* If ARRAY has size zero and type character, the result has the\n-               value of a string of characters of length LEN (ARRAY), with\n-               each character equal to CHAR (0, KIND (ARRAY)).  */\n-\t    gfc_error (\"MAXVAL(string) at %L is not implemented, yet!\",\n-\t\t\t&array->where);\n-\t    gfc_free_expr (result);\n-\t    return &gfc_bad_expr;\n-\t    break;\n-\n-\t  default:\n-\t    gcc_unreachable ();\n-    \t}\n-\n-      return result;\n-    }\n-\n   return simplify_transformation (array, dim, mask, INT_MIN, gfc_max);\n }\n \n@@ -5777,22 +5694,20 @@ gfc_expr *\n gfc_simplify_norm2 (gfc_expr *e, gfc_expr *dim)\n {\n   gfc_expr *result;\n+  bool size_zero;\n \n-  if (gfc_is_size_zero_array (e))\n-    {\n-      gfc_expr *result;\n-      result = gfc_get_constant_expr (e->ts.type, e->ts.kind, &e->where);\n-      mpfr_set_ui (result->value.real, 0, GFC_RND_MODE);\n-      return result;\n-    }\n+  size_zero = gfc_is_size_zero_array (e);\n \n-  if (!is_constant_array_expr (e)\n+  if (!(is_constant_array_expr (e) || size_zero)\n       || (dim != NULL && !gfc_is_constant_expr (dim)))\n     return NULL;\n \n   result = transformational_result (e, dim, e->ts.type, e->ts.kind, &e->where);\n   init_result_expr (result, 0, NULL);\n \n+  if (size_zero)\n+    return result;\n+\n   if (!dim || e->rank == 1)\n     {\n       result = simplify_transformation_to_scalar (result, e, NULL,\n@@ -6042,33 +5957,6 @@ gfc_simplify_precision (gfc_expr *e)\n gfc_expr *\n gfc_simplify_product (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n {\n-  if (gfc_is_size_zero_array (array))\n-    {\n-      gfc_expr *result;\n-\n-      result = gfc_get_constant_expr (array->ts.type, array->ts.kind,\n-\t\t\t\t      &array->where);\n-      switch (array->ts.type)\n-\t{\n-\t  case BT_INTEGER:\n-\t    mpz_set_ui (result->value.integer, 1);\n-\t    break;\n-\n-\t  case BT_REAL:\n-\t    mpfr_set_ui (result->value.real, 1, GFC_RND_MODE);\n-\t    break;\n-\n-\t  case BT_COMPLEX:\n-\t    mpc_set_ui (result->value.complex, 1, GFC_MPC_RND_MODE);\n-\t    break;\n-\n-\t  default:\n-\t    gcc_unreachable ();\n-    \t}\n-\n-      return result;\n-    }\n-\n   return simplify_transformation (array, dim, mask, 1, gfc_multiply);\n }\n \n@@ -7386,33 +7274,6 @@ gfc_simplify_sqrt (gfc_expr *e)\n gfc_expr *\n gfc_simplify_sum (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n {\n-  if (gfc_is_size_zero_array (array))\n-    {\n-      gfc_expr *result;\n-\n-      result = gfc_get_constant_expr (array->ts.type, array->ts.kind,\n-\t\t\t\t      &array->where);\n-      switch (array->ts.type)\n-\t{\n-\t  case BT_INTEGER:\n-\t    mpz_set_ui (result->value.integer, 0);\n-\t    break;\n-\n-\t  case BT_REAL:\n-\t    mpfr_set_ui (result->value.real, 0, GFC_RND_MODE);\n-\t    break;\n-\n-\t  case BT_COMPLEX:\n-\t    mpc_set_ui (result->value.complex, 0, GFC_MPC_RND_MODE);\n-\t    break;\n-\n-\t  default:\n-\t    gcc_unreachable ();\n-    \t}\n-\n-      return result;\n-    }\n-\n   return simplify_transformation (array, dim, mask, 0, gfc_add);\n }\n "}, {"sha": "4f7a81663e637d3763459c04ad1e159e0aa11e21", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f76317a471e2960343ff94a60620fec76cdc35c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f76317a471e2960343ff94a60620fec76cdc35c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6f76317a471e2960343ff94a60620fec76cdc35c", "patch": "@@ -1,3 +1,8 @@\n+2018-03-11  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR fortran/66128\n+\t* gfortran.dg/zero_sized_9.f90: New test.\n+\n 2018-03-11  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/58150"}, {"sha": "891a0138cea8f487f85f9a3a668a0a326cc564e8", "filename": "gcc/testsuite/gfortran.dg/zero_sized_9.f90", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f76317a471e2960343ff94a60620fec76cdc35c/gcc%2Ftestsuite%2Fgfortran.dg%2Fzero_sized_9.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f76317a471e2960343ff94a60620fec76cdc35c/gcc%2Ftestsuite%2Fgfortran.dg%2Fzero_sized_9.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fzero_sized_9.f90?ref=6f76317a471e2960343ff94a60620fec76cdc35c", "patch": "@@ -0,0 +1,31 @@\n+! { dg-do  run }\n+program main\n+  implicit none\n+  integer, parameter :: a(0,3) = 0\n+  integer, parameter :: b(3,0) = -42\n+  integer, parameter, dimension(3) :: a1 = minval(a,dim=1)\n+  integer, parameter, dimension(0) :: a2 = minval(a,dim=2)\n+  integer, parameter, dimension(0) :: b1 = minval(b,dim=1)\n+  integer, parameter, dimension(3) :: b2 = minval(b,dim=2)\n+  logical, parameter :: c(0,3) = .false.\n+  logical, parameter :: d(3,0) = .false.\n+  logical, parameter, dimension(3) :: tr = all(c,dim=1)\n+  logical, parameter, dimension(3) :: fa = any(c,dim=1)\n+  integer, parameter, dimension(3) :: ze = count(d,dim=2)\n+  integer, parameter, dimension(3) :: ze2 = iany(b,dim=2)\n+  integer, parameter, dimension(3) :: ze3 = iparity(a,dim=1)\n+  real, parameter, dimension(0,3) :: r = 1.0\n+  real, parameter, dimension(3) :: n2 = norm2(r,dim=1)\n+  integer, parameter, dimension(3) :: one = product(b,dim=2)\n+  integer, parameter, dimension(3) :: ze4 = sum(a,dim=1)\n+  if (any(a1 /= huge(0))) stop 1\n+  if (any(b2 /= huge(b2))) stop 2\n+  if (any(.not.tr)) stop 3\n+  if (any(fa)) stop 3\n+  if (any(ze /= 0)) stop 4\n+  if (any(ze2 /= 0)) stop 5\n+  if (any(ze3 /= 0)) stop 6\n+  if (any(n2 /= 0.0)) stop 7\n+  if (any(one /= 1)) stop 8\n+  if (any(ze4 /= 0)) stop 9\n+end program main"}]}