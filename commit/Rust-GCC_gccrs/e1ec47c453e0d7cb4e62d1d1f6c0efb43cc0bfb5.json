{"sha": "e1ec47c453e0d7cb4e62d1d1f6c0efb43cc0bfb5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFlYzQ3YzQ1M2UwZDdjYjRlNjJkMWQxZjZjMGVmYjQzY2MwYmZiNQ==", "commit": {"author": {"name": "Thomas Preud'homme", "email": "thomas.preudhomme@arm.com", "date": "2014-05-08T01:20:17Z"}, "committer": {"name": "Joey Ye", "email": "jye2@gcc.gnu.org", "date": "2014-05-08T01:20:17Z"}, "message": "re PR middle-end/39246 (FAIL: gcc.dg/uninit-13.c)\n\n2014-05-07  Thomas Preud'homme  <thomas.preudhomme@arm.com>\n\n        PR middle-end/39246\n        * tree-complex.c (expand_complex_move): Keep line info when expanding\n        complex move.\n        * tree-ssa-uninit.c (warn_uninit): New argument. Ignore assignment \n        of complex expression. Use new argument to display correct location \n        for values coming from phi statement.\n        (warn_uninitialized_vars): Adapt to new signature of warn_uninit.\n        (warn_uninitialized_phi): Pass location of phi argument to \n        warn_uninit.\n        * tree-ssa.c (ssa_undefined_value_p): For SSA_NAME initialized by a\n        COMPLEX_EXPR, recurse on each part of the COMPLEX_EXPR.\n\ntestsuite:\n\n        * gcc.dg/uninit-13.c: Move warning on the actual source line where\n        the uninitialized complex is used.\n        * gcc.dg/uninit-17.c: New test to check partial initialization of\n        complex with branches.\n        * gcc.dg/uninit-17-O0.c: Likewise.\n\nFrom-SVN: r210199", "tree": {"sha": "9c87b46e418e3508e38a27583c76e3829a43b781", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c87b46e418e3508e38a27583c76e3829a43b781"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1ec47c453e0d7cb4e62d1d1f6c0efb43cc0bfb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1ec47c453e0d7cb4e62d1d1f6c0efb43cc0bfb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1ec47c453e0d7cb4e62d1d1f6c0efb43cc0bfb5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1ec47c453e0d7cb4e62d1d1f6c0efb43cc0bfb5/comments", "author": {"login": "RoboTux", "id": 272327, "node_id": "MDQ6VXNlcjI3MjMyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/272327?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RoboTux", "html_url": "https://github.com/RoboTux", "followers_url": "https://api.github.com/users/RoboTux/followers", "following_url": "https://api.github.com/users/RoboTux/following{/other_user}", "gists_url": "https://api.github.com/users/RoboTux/gists{/gist_id}", "starred_url": "https://api.github.com/users/RoboTux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RoboTux/subscriptions", "organizations_url": "https://api.github.com/users/RoboTux/orgs", "repos_url": "https://api.github.com/users/RoboTux/repos", "events_url": "https://api.github.com/users/RoboTux/events{/privacy}", "received_events_url": "https://api.github.com/users/RoboTux/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "10e08855d74dc3f35bb295ac2747f48dd037bee6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10e08855d74dc3f35bb295ac2747f48dd037bee6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10e08855d74dc3f35bb295ac2747f48dd037bee6"}], "stats": {"total": 70, "additions": 54, "deletions": 16}, "files": [{"sha": "5e88a8a945437227a8654056443d5207d41a30a5", "filename": "gcc/testsuite/gcc.dg/uninit-13.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1ec47c453e0d7cb4e62d1d1f6c0efb43cc0bfb5/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1ec47c453e0d7cb4e62d1d1f6c0efb43cc0bfb5/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-13.c?ref=e1ec47c453e0d7cb4e62d1d1f6c0efb43cc0bfb5", "patch": "@@ -5,6 +5,6 @@ typedef _Complex float C;\n C foo()\n {\n   C f;\n-  __imag__ f = 0;\t/* { dg-warning \"is used\" \"unconditional\" } */\n-  return f;\n+  __imag__ f = 0;\n+  return f;\t/* { dg-warning \"is used\" \"unconditional\" } */\n }"}, {"sha": "cf542fd230c943a77ec57b620f9ce66a62585ff6", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1ec47c453e0d7cb4e62d1d1f6c0efb43cc0bfb5/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1ec47c453e0d7cb4e62d1d1f6c0efb43cc0bfb5/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=e1ec47c453e0d7cb4e62d1d1f6c0efb43cc0bfb5", "patch": "@@ -831,12 +831,15 @@ expand_complex_move (gimple_stmt_iterator *gsi, tree type)\n     {\n       tree x;\n       gimple t;\n+      location_t loc;\n \n+      loc = gimple_location (stmt);\n       r = extract_component (gsi, rhs, 0, false);\n       i = extract_component (gsi, rhs, 1, false);\n \n       x = build1 (REALPART_EXPR, inner_type, unshare_expr (lhs));\n       t = gimple_build_assign (x, r);\n+      gimple_set_location (t, loc);\n       gsi_insert_before (gsi, t, GSI_SAME_STMT);\n \n       if (stmt == gsi_stmt (*gsi))\n@@ -849,6 +852,7 @@ expand_complex_move (gimple_stmt_iterator *gsi, tree type)\n \t{\n \t  x = build1 (IMAGPART_EXPR, inner_type, unshare_expr (lhs));\n \t  t = gimple_build_assign (x, i);\n+\t  gimple_set_location (t, loc);\n \t  gsi_insert_before (gsi, t, GSI_SAME_STMT);\n \n \t  stmt = gsi_stmt (*gsi);"}, {"sha": "8b298faeb5c4faad9aff3cd5778bd125dabb8772", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 31, "deletions": 13, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1ec47c453e0d7cb4e62d1d1f6c0efb43cc0bfb5/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1ec47c453e0d7cb4e62d1d1f6c0efb43cc0bfb5/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=e1ec47c453e0d7cb4e62d1d1f6c0efb43cc0bfb5", "patch": "@@ -123,17 +123,25 @@ uninit_undefined_value_p (tree t) {\n \n /* Emit a warning for EXPR based on variable VAR at the point in the\n    program T, an SSA_NAME, is used being uninitialized.  The exact\n-   warning text is in MSGID and LOCUS may contain a location or be null.\n-   WC is the warning code.  */\n+   warning text is in MSGID and DATA is the gimple stmt with info about\n+   the location in source code. When DATA is a GIMPLE_PHI, PHIARG_IDX\n+   gives which argument of the phi node to take the location from.  WC\n+   is the warning code.  */\n \n static void\n-warn_uninit (enum opt_code wc, tree t,\n-\t     tree expr, tree var, const char *gmsgid, void *data)\n+warn_uninit (enum opt_code wc, tree t, tree expr, tree var,\n+\t     const char *gmsgid, void *data, location_t phiarg_loc)\n {\n   gimple context = (gimple) data;\n   location_t location, cfun_loc;\n   expanded_location xloc, floc;\n \n+  /* Ignore COMPLEX_EXPR as initializing only a part of a complex\n+     turns in a COMPLEX_EXPR with the not initialized part being\n+     set to its previous (undefined) value.  */\n+  if (is_gimple_assign (context)\n+      && gimple_assign_rhs_code (context) == COMPLEX_EXPR)\n+    return;\n   if (!has_undefined_value_p (t))\n     return;\n \n@@ -146,9 +154,12 @@ warn_uninit (enum opt_code wc, tree t,\n       || TREE_NO_WARNING (expr))\n     return;\n \n-  location = (context != NULL && gimple_has_location (context))\n-\t     ? gimple_location (context)\n-\t     : DECL_SOURCE_LOCATION (var);\n+  if (context != NULL && gimple_has_location (context))\n+    location = gimple_location (context);\n+  else if (phiarg_loc != UNKNOWN_LOCATION)\n+    location = phiarg_loc;\n+  else\n+    location = DECL_SOURCE_LOCATION (var);\n   location = linemap_resolve_location (line_table, location,\n \t\t\t\t       LRK_SPELLING_LOCATION,\n \t\t\t\t       NULL);\n@@ -200,12 +211,12 @@ warn_uninitialized_vars (bool warn_possibly_uninitialized)\n \t\twarn_uninit (OPT_Wuninitialized, use,\n \t\t\t     SSA_NAME_VAR (use), SSA_NAME_VAR (use),\n \t\t\t     \"%qD is used uninitialized in this function\",\n-\t\t\t     stmt);\n+\t\t\t     stmt, UNKNOWN_LOCATION);\n \t      else if (warn_possibly_uninitialized)\n \t\twarn_uninit (OPT_Wmaybe_uninitialized, use,\n \t\t\t     SSA_NAME_VAR (use), SSA_NAME_VAR (use),\n \t\t\t     \"%qD may be used uninitialized in this function\",\n-\t\t\t     stmt);\n+\t\t\t     stmt, UNKNOWN_LOCATION);\n \t    }\n \n \t  /* For memory the only cheap thing we can do is see if we\n@@ -236,12 +247,12 @@ warn_uninitialized_vars (bool warn_possibly_uninitialized)\n \t\twarn_uninit (OPT_Wuninitialized, use,\n \t\t\t     gimple_assign_rhs1 (stmt), base,\n \t\t\t     \"%qE is used uninitialized in this function\",\n-\t\t\t     stmt);\n+\t\t\t     stmt, UNKNOWN_LOCATION);\n \t      else if (warn_possibly_uninitialized)\n \t\twarn_uninit (OPT_Wmaybe_uninitialized, use,\n \t\t\t     gimple_assign_rhs1 (stmt), base,\n \t\t\t     \"%qE may be used uninitialized in this function\",\n-\t\t\t     stmt);\n+\t\t\t     stmt, UNKNOWN_LOCATION);\n \t    }\n \t}\n     }\n@@ -2246,6 +2257,8 @@ warn_uninitialized_phi (gimple phi, vec<gimple> *worklist,\n   unsigned uninit_opnds;\n   gimple uninit_use_stmt = 0;\n   tree uninit_op;\n+  int phiarg_index;\n+  location_t loc;\n \n   /* Don't look at virtual operands.  */\n   if (virtual_operand_p (gimple_phi_result (phi)))\n@@ -2270,13 +2283,18 @@ warn_uninitialized_phi (gimple phi, vec<gimple> *worklist,\n   if (!uninit_use_stmt)\n     return;\n \n-  uninit_op = gimple_phi_arg_def (phi, MASK_FIRST_SET_BIT (uninit_opnds));\n+  phiarg_index = MASK_FIRST_SET_BIT (uninit_opnds);\n+  uninit_op = gimple_phi_arg_def (phi, phiarg_index);\n   if (SSA_NAME_VAR (uninit_op) == NULL_TREE)\n     return;\n+  if (gimple_phi_arg_has_location (phi, phiarg_index))\n+    loc = gimple_phi_arg_location (phi, phiarg_index);\n+  else\n+    loc = UNKNOWN_LOCATION;\n   warn_uninit (OPT_Wmaybe_uninitialized, uninit_op, SSA_NAME_VAR (uninit_op),\n \t       SSA_NAME_VAR (uninit_op),\n                \"%qD may be used uninitialized in this function\",\n-               uninit_use_stmt);\n+               uninit_use_stmt, loc);\n \n }\n "}, {"sha": "42a2783e31b01cc46f609554e853291cf0cbc344", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1ec47c453e0d7cb4e62d1d1f6c0efb43cc0bfb5/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1ec47c453e0d7cb4e62d1d1f6c0efb43cc0bfb5/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=e1ec47c453e0d7cb4e62d1d1f6c0efb43cc0bfb5", "patch": "@@ -1246,6 +1246,7 @@ tree_ssa_strip_useless_type_conversions (tree exp)\n bool\n ssa_undefined_value_p (tree t)\n {\n+  gimple def_stmt;\n   tree var = SSA_NAME_VAR (t);\n \n   if (!var)\n@@ -1262,7 +1263,22 @@ ssa_undefined_value_p (tree t)\n     return false;\n \n   /* The value is undefined iff its definition statement is empty.  */\n-  return gimple_nop_p (SSA_NAME_DEF_STMT (t));\n+  def_stmt = SSA_NAME_DEF_STMT (t);\n+  if (gimple_nop_p (def_stmt))\n+    return true;\n+\n+  /* Check if the complex was not only partially defined.  */\n+  if (is_gimple_assign (def_stmt)\n+      && gimple_assign_rhs_code (def_stmt) == COMPLEX_EXPR)\n+    {\n+      tree rhs1, rhs2;\n+\n+      rhs1 = gimple_assign_rhs1 (def_stmt);\n+      rhs2 = gimple_assign_rhs2 (def_stmt);\n+      return (TREE_CODE (rhs1) == SSA_NAME && ssa_undefined_value_p (rhs1))\n+\t     || (TREE_CODE (rhs2) == SSA_NAME && ssa_undefined_value_p (rhs2));\n+    }\n+  return false;\n }\n \n "}]}