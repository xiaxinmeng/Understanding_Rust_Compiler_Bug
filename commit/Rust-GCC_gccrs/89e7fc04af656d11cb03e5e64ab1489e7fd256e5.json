{"sha": "89e7fc04af656d11cb03e5e64ab1489e7fd256e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODllN2ZjMDRhZjY1NmQxMWNiMDNlNWU2NGFiMTQ4OWU3ZmQyNTZlNQ==", "commit": {"author": {"name": "Sofiane Naci", "email": "sofiane.naci@arm.com", "date": "2013-06-19T13:05:14Z"}, "committer": {"name": "Sofiane Naci", "email": "sofiane@gcc.gnu.org", "date": "2013-06-19T13:05:14Z"}, "message": "vfp.md: Move VFP instruction classification documentation to ...\n\n\t* config/arm/vfp.md: Move VFP instruction classification documentation\n\tto ...\n\t* config/arm/arm.md: ... here.  Update instruction classification\n\tdocumentation.\n\nFrom-SVN: r200199", "tree": {"sha": "0f3623095eae0f712b4aa57d809e1871900d2f28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f3623095eae0f712b4aa57d809e1871900d2f28"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89e7fc04af656d11cb03e5e64ab1489e7fd256e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89e7fc04af656d11cb03e5e64ab1489e7fd256e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89e7fc04af656d11cb03e5e64ab1489e7fd256e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89e7fc04af656d11cb03e5e64ab1489e7fd256e5/comments", "author": null, "committer": null, "parents": [{"sha": "5e7f6aaaaf131cab3d427045a70c32e5dbb5f74f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e7f6aaaaf131cab3d427045a70c32e5dbb5f74f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e7f6aaaaf131cab3d427045a70c32e5dbb5f74f"}], "stats": {"total": 155, "additions": 88, "deletions": 67}, "files": [{"sha": "bf364b9f764b7204eca1086b539c143bdf936079", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e7fc04af656d11cb03e5e64ab1489e7fd256e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e7fc04af656d11cb03e5e64ab1489e7fd256e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=89e7fc04af656d11cb03e5e64ab1489e7fd256e5", "patch": "@@ -1,3 +1,10 @@\n+2013-06-19  Sofiane Naci  <sofiane.naci@arm.com>\n+\n+\t* config/arm/vfp.md: Move VFP instruction classification documentation\n+\tto ...\n+\t* config/arm/arm.md: ... here.  Update instruction classification\n+\tdocumentation.\n+\n 2013-06-19  Richard Earnshaw  <rearnsha@arm.com>\n \n \tarm.md (split for eq(reg, 0)): Add variants for ARMv5 and Thumb2."}, {"sha": "a342c5ef9b9943ea84b587956d8f43889883eb03", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 81, "deletions": 42, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e7fc04af656d11cb03e5e64ab1489e7fd256e5/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e7fc04af656d11cb03e5e64ab1489e7fd256e5/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=89e7fc04af656d11cb03e5e64ab1489e7fd256e5", "patch": "@@ -253,49 +253,88 @@\n         \"mov,mvn,clz,mrs,msr,xtab,sat,other\"\n         (const_string \"other\"))\n \n-; TYPE attribute is used to detect floating point instructions which, if\n-; running on a co-processor can run in parallel with other, basic instructions\n-; If write-buffer scheduling is enabled then it can also be used in the\n-; scheduling of writes.\n-\n-; Classification of each insn\n-; Note: vfp.md has different meanings for some of these, and some further\n-; types as well.  See that file for details.\n-; simple_alu_imm  a simple alu instruction that doesn't hit memory or fp\n-;               regs or have a shifted source operand and has an immediate\n-;               operand. This currently only tracks very basic immediate\n-;               alu operations.\n-; alu_reg       any alu instruction that doesn't hit memory or fp\n-;               regs or have a shifted source operand\n-;               and does not have an immediate operand. This is\n-;               also the default\n-; simple_alu_shift covers UXTH, UXTB, SXTH, SXTB\n-; alu_shift\tany data instruction that doesn't hit memory or fp\n-;\t\tregs, but has a source operand shifted by a constant\n-; alu_shift_reg\tany data instruction that doesn't hit memory or fp\n-;\t\tregs, but has a source operand shifted by a register value\n-; block\t\tblockage insn, this blocks all functional units\n-; float\t\ta floating point arithmetic operation (subject to expansion)\n-; fdivd\t\tDFmode floating point division\n-; fdivs\t\tSFmode floating point division\n-; f_load[sd]\tA single/double load from memory. Used for VFP unit.\n-; f_store[sd]\tA single/double store to memory. Used for VFP unit.\n-; f_flag\ta transfer of co-processor flags to the CPSR\n-; f_2_r\t\ttransfer float to core (no memory needed)\n-; r_2_f\t\ttransfer core to float\n-; f_cvt\t\tconvert floating<->integral\n-; branch\ta branch\n-; call\t\ta subroutine call\n-; load_byte\tload byte(s) from memory to arm registers\n-; load1\t\tload 1 word from memory to arm registers\n-; load2         load 2 words from memory to arm registers\n-; load3         load 3 words from memory to arm registers\n-; load4         load 4 words from memory to arm registers\n-; store\t\tstore 1 word to memory from arm registers\n-; store2\tstore 2 words\n-; store3\tstore 3 words\n-; store4\tstore 4 (or more) words\n+; TYPE attribute is used to classify instructions for use in scheduling.\n ;\n+; Instruction classification:\n+;\n+; alu_reg            any alu instruction that doesn't hit memory or fp\n+;                    regs or have a shifted source operand and does not have\n+;                    an immediate operand.  This is also the default.\n+; alu_shift          any data instruction that doesn't hit memory or fp.\n+;                    regs, but has a source operand shifted by a constant.\n+; alu_shift_reg      any data instruction that doesn't hit memory or fp.\n+; block              blockage insn, this blocks all functional units.\n+; branch             branch.\n+; call               subroutine call.\n+; f_2_r              transfer from float to core (no memory needed).\n+; f_cvt              conversion between float and integral.\n+; f_flag             transfer of co-processor flags to the CPSR.\n+; f_load[d,s]        double/single load from memory.  Used for VFP unit.\n+; f_minmax[d,s]      double/single floating point minimum/maximum.\n+; f_rint[d,s]        double/single floating point rount to integral.\n+; f_sel[d,s]         double/single floating byte select.\n+; f_store[d,s]       double/single store to memory.  Used for VFP unit.\n+; fadd[d,s]          double/single floating-point scalar addition.\n+; fcmp[d,s]          double/single floating-point compare.\n+; fconst[d,s]        double/single load immediate.\n+; fcpys              single precision floating point cpy.\n+; fdiv[d,s]          double/single precision floating point division.\n+; ffarith[d,s]       double/single floating point abs/neg/cpy.\n+; ffma[d,s]          double/single floating point fused multiply-accumulate.\n+; float              floating point arithmetic operation.\n+; fmac[d,s]          double/single floating point multiply-accumulate.\n+; fmul[d,s]          double/single floating point multiply.\n+; load_byte          load byte(s) from memory to arm registers.\n+; load1              load 1 word from memory to arm registers.\n+; load2              load 2 words from memory to arm registers.\n+; load3              load 3 words from memory to arm registers.\n+; load4              load 4 words from memory to arm registers.\n+; mla                integer multiply accumulate.\n+; mlas               integer multiply accumulate, flag setting.\n+; mov                integer move.\n+; mul                integer multiply.\n+; muls               integer multiply, flag setting.\n+; r_2_f              transfer from core to float.\n+; sdiv               signed division.\n+; simple_alu_imm     simple alu instruction that doesn't hit memory or fp\n+;                    regs or have a shifted source operand and has an\n+;                    immediate operand.  This currently only tracks very basic\n+;                    immediate alu operations.\n+; simple_alu_shift   simple alu instruction with a shifted source operand.\n+; smlad              signed multiply accumulate dual.\n+; smladx             signed multiply accumulate dual reverse.\n+; smlal              signed multiply accumulate long.\n+; smlald             signed multiply accumulate long dual.\n+; smlals             signed multiply accumulate long, flag setting.\n+; smlalxy            signed multiply accumulate, 16x16-bit, 64-bit accumulate.\n+; smlawx             signed multiply accumulate, 32x16-bit, 32-bit accumulate.\n+; smlawy             signed multiply accumulate wide, 32x16-bit,\n+;                    32-bit accumulate.\n+; smlaxy             signed multiply accumulate, 16x16-bit, 32-bit accumulate.\n+; smlsd              signed multiply subtract dual.\n+; smlsdx             signed multiply subtract dual reverse.\n+; smlsld             signed multiply subtract long dual.\n+; smmla              signed most significant word multiply accumulate.\n+; smmul              signed most significant word multiply.\n+; smmulr             signed most significant word multiply, rounded.\n+; smuad              signed dual multiply add.\n+; smuadx             signed dual multiply add reverse.\n+; smull              signed multiply long.\n+; smulls             signed multiply long, flag setting.\n+; smulwy             signed multiply wide, 32x16-bit, 32-bit accumulate.\n+; smulxy             signed multiply, 16x16-bit, 32-bit accumulate.\n+; smusd              signed dual multiply subtract.\n+; smusdx             signed dual multiply subtract reverse.\n+; store1             store 1 word to memory from arm registers.\n+; store2             store 2 words to memory from arm registers.\n+; store3             store 3 words to memory from arm registers.\n+; store4             store 4 (or more) words to memory from arm registers.\n+; udiv               unsigned division.\n+; umaal              unsigned multiply accumulate accumulate long.\n+; umlal              unsigned multiply accumulate long.\n+; umlals             unsigned multiply accumulate long, flag setting.\n+; umull              unsigned multiply long.\n+; umulls             unsigned multiply long, flag setting.\n \n (define_attr \"type\"\n  \"simple_alu_imm,\\"}, {"sha": "918db1758b551c9c7a108718a1a3871d796d64d9", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89e7fc04af656d11cb03e5e64ab1489e7fd256e5/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89e7fc04af656d11cb03e5e64ab1489e7fd256e5/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=89e7fc04af656d11cb03e5e64ab1489e7fd256e5", "patch": "@@ -18,31 +18,6 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.  */\n \n-;; The VFP \"type\" attributes differ from those used in the FPA model.\n-;; fcpys\tSingle precision cpy.\n-;; ffariths\tSingle precision abs, neg.\n-;; ffarithd\tDouble precision abs, neg, cpy.\n-;; fadds\tSingle precision add/sub.\n-;; faddd\tDouble precision add/sub.\n-;; fconsts\tSingle precision load immediate.\n-;; fconstd\tDouble precision load immediate.\n-;; fcmps\tSingle precision comparison.\n-;; fcmpd\tDouble precision comparison.\n-;; fmuls\tSingle precision multiply.\n-;; fmuld\tDouble precision multiply.\n-;; fmacs\tSingle precision multiply-accumulate.\n-;; fmacd\tDouble precision multiply-accumulate.\n-;; ffmas\tSingle precision fused multiply-accumulate.\n-;; ffmad\tDouble precision fused multiply-accumulate.\n-;; fdivs\tSingle precision sqrt or division.\n-;; fdivd\tDouble precision sqrt or division.\n-;; f_flag\tfmstat operation\n-;; f_load[sd]\tFloating point load from memory.\n-;; f_store[sd]\tFloating point store to memory.\n-;; f_2_r\tTransfer vfp to arm reg.\n-;; r_2_f\tTransfer arm to vfp reg.\n-;; f_cvt\tConvert floating<->integral\n-\n ;; SImode moves\n ;; ??? For now do not allow loading constants into vfp regs.  This causes\n ;; problems because small constants get converted into adds."}]}