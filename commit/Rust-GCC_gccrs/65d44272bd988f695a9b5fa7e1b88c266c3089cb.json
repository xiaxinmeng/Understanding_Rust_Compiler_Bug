{"sha": "65d44272bd988f695a9b5fa7e1b88c266c3089cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVkNDQyNzJiZDk4OGY2OTVhOWI1ZmE3ZTFiODhjMjY2YzMwODljYg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-05-05T16:40:44Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-05-17T09:05:30Z"}, "message": "Move array bounds checking out of vrp_prop and into its own class.", "tree": {"sha": "685a314db1e2c35f4d4d18fb4a1b9e42356ff2bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/685a314db1e2c35f4d4d18fb4a1b9e42356ff2bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65d44272bd988f695a9b5fa7e1b88c266c3089cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65d44272bd988f695a9b5fa7e1b88c266c3089cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65d44272bd988f695a9b5fa7e1b88c266c3089cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65d44272bd988f695a9b5fa7e1b88c266c3089cb/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "add058cf93ae8241ca25e9cbce1e1d898eeedd9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/add058cf93ae8241ca25e9cbce1e1d898eeedd9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/add058cf93ae8241ca25e9cbce1e1d898eeedd9d"}], "stats": {"total": 110, "additions": 73, "deletions": 37}, "files": [{"sha": "64681dd97fe5f19641a23ee10984de2bbd6e8f2f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d44272bd988f695a9b5fa7e1b88c266c3089cb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d44272bd988f695a9b5fa7e1b88c266c3089cb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65d44272bd988f695a9b5fa7e1b88c266c3089cb", "patch": "@@ -1,3 +1,15 @@\n+2020-05-17  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* tree-vrp.c (class vrp_prop): Move check_all_array_refs,\n+\tcheck_array_ref, check_mem_ref, and search_for_addr_array\n+\tinto new class...\n+\t(class array_bounds_checker): ...here.\n+\t(class check_array_bounds_dom_walker): Adjust to use\n+\tarray_bounds_checker.\n+\t(check_all_array_refs): Move into array_bounds_checker and rename\n+\tto check.\n+\t(class vrp_folder): Make fold_predicate_in private.\n+\n 2020-05-15 Jeff Law  <law@redhat.com>\n \n \t* config/h8300/h8300.md (SFI iterator): New iterator for"}, {"sha": "6e3510856a5611d1d1bf86e2abde3a1ec5b39d05", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 61, "deletions": 37, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d44272bd988f695a9b5fa7e1b88c266c3089cb/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d44272bd988f695a9b5fa7e1b88c266c3089cb/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=65d44272bd988f695a9b5fa7e1b88c266c3089cb", "patch": "@@ -3521,20 +3521,18 @@ vrp_insert::insert_range_assertions (void)\n \n class vrp_prop : public ssa_propagation_engine\n {\n- public:\n+public:\n   enum ssa_prop_result visit_stmt (gimple *, edge *, tree *) FINAL OVERRIDE;\n   enum ssa_prop_result visit_phi (gphi *) FINAL OVERRIDE;\n \n   struct function *fun;\n \n   void vrp_initialize (struct function *);\n   void vrp_finalize (bool);\n-  void check_all_array_refs (void);\n-  bool check_array_ref (location_t, tree, bool);\n-  bool check_mem_ref (location_t, tree, bool);\n-  void search_for_addr_array (tree, location_t);\n \n   class vr_values vr_values;\n+\n+private:\n   /* Temporary delegator to minimize code churn.  */\n   const value_range_equiv *get_value_range (const_tree op)\n     { return vr_values.get_value_range (op); }\n@@ -3552,6 +3550,29 @@ class vrp_prop : public ssa_propagation_engine\n   void extract_range_from_phi_node (gphi *phi, value_range_equiv *vr)\n     { vr_values.extract_range_from_phi_node (phi, vr); }\n };\n+\n+/* Array bounds checking pass.  */\n+\n+class array_bounds_checker\n+{\n+  friend class check_array_bounds_dom_walker;\n+\n+public:\n+  array_bounds_checker (struct function *fun, class vr_values *v)\n+    : fun (fun), ranges (v) { }\n+  void check ();\n+\n+private:\n+  static tree check_array_bounds (tree *tp, int *walk_subtree, void *data);\n+  bool check_array_ref (location_t, tree, bool ignore_off_by_one);\n+  bool check_mem_ref (location_t, tree, bool ignore_off_by_one);\n+  void check_addr_expr (location_t, tree);\n+  const value_range_equiv *get_value_range (const_tree op)\n+    { return ranges->get_value_range (op); }\n+  struct function *fun;\n+  class vr_values *ranges;\n+};\n+\n /* Checks one ARRAY_REF in REF, located at LOCUS. Ignores flexible arrays\n    and \"struct\" hacks. If VRP can determine that the\n    array subscript is a constant, check if it is outside valid\n@@ -3561,8 +3582,8 @@ class vrp_prop : public ssa_propagation_engine\n    Returns true if a warning has been issued.  */\n \n bool\n-vrp_prop::check_array_ref (location_t location, tree ref,\n-\t\t\t   bool ignore_off_by_one)\n+array_bounds_checker::check_array_ref (location_t location, tree ref,\n+\t\t\t\t       bool ignore_off_by_one)\n {\n   if (TREE_NO_WARNING (ref))\n     return false;\n@@ -3760,8 +3781,8 @@ vrp_prop::check_array_ref (location_t location, tree ref,\n    Returns true if a warning has been issued.  */\n \n bool\n-vrp_prop::check_mem_ref (location_t location, tree ref,\n-\t\t\t bool ignore_off_by_one)\n+array_bounds_checker::check_mem_ref (location_t location, tree ref,\n+\t\t\t\t     bool ignore_off_by_one)\n {\n   if (TREE_NO_WARNING (ref))\n     return false;\n@@ -4038,7 +4059,7 @@ vrp_prop::check_mem_ref (location_t location, tree ref,\n    address of an ARRAY_REF, and call check_array_ref on it.  */\n \n void\n-vrp_prop::search_for_addr_array (tree t, location_t location)\n+array_bounds_checker::check_addr_expr (location_t location, tree t)\n {\n   /* Check each ARRAY_REF and MEM_REF in the reference chain. */\n   do\n@@ -4122,14 +4143,12 @@ vrp_prop::search_for_addr_array (tree t, location_t location)\n     }\n }\n \n-/* walk_tree() callback that checks if *TP is\n-   an ARRAY_REF inside an ADDR_EXPR (in which an array\n-   subscript one outside the valid range is allowed). Call\n-   check_array_ref for each ARRAY_REF found. The location is\n-   passed in DATA.  */\n+/* Callback for walk_tree to check a tree for out of bounds array\n+   accesses.  The array_bounds_checker class is passed in DATA.  */\n \n-static tree\n-check_array_bounds (tree *tp, int *walk_subtree, void *data)\n+tree\n+array_bounds_checker::check_array_bounds (tree *tp, int *walk_subtree,\n+\t\t\t\t\t  void *data)\n {\n   tree t = *tp;\n   struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n@@ -4143,14 +4162,16 @@ check_array_bounds (tree *tp, int *walk_subtree, void *data)\n   *walk_subtree = TRUE;\n \n   bool warned = false;\n-  vrp_prop *vrp_prop = (class vrp_prop *)wi->info;\n+  array_bounds_checker *checker = (array_bounds_checker *) wi->info;\n   if (TREE_CODE (t) == ARRAY_REF)\n-    warned = vrp_prop->check_array_ref (location, t, false/*ignore_off_by_one*/);\n+    warned = checker->check_array_ref (location, t,\n+\t\t\t\t       false/*ignore_off_by_one*/);\n   else if (TREE_CODE (t) == MEM_REF)\n-    warned = vrp_prop->check_mem_ref (location, t, false /*ignore_off_by_one*/);\n+    warned = checker->check_mem_ref (location, t,\n+\t\t\t\t     false /*ignore_off_by_one*/);\n   else if (TREE_CODE (t) == ADDR_EXPR)\n     {\n-      vrp_prop->search_for_addr_array (t, location);\n+      checker->check_addr_expr (location, t);\n       *walk_subtree = FALSE;\n     }\n   /* Propagate the no-warning bit to the outer expression.  */\n@@ -4160,26 +4181,26 @@ check_array_bounds (tree *tp, int *walk_subtree, void *data)\n   return NULL_TREE;\n }\n \n-/* A dom_walker subclass for use by vrp_prop::check_all_array_refs,\n-   to walk over all statements of all reachable BBs and call\n-   check_array_bounds on them.  */\n+/* A dom_walker subclass for use by check_all_array_refs, to walk over\n+   all statements of all reachable BBs and call check_array_bounds on\n+   them.  */\n \n class check_array_bounds_dom_walker : public dom_walker\n {\n- public:\n-  check_array_bounds_dom_walker (vrp_prop *prop)\n+public:\n+  check_array_bounds_dom_walker (array_bounds_checker *checker)\n     : dom_walker (CDI_DOMINATORS,\n \t\t  /* Discover non-executable edges, preserving EDGE_EXECUTABLE\n \t\t     flags, so that we can merge in information on\n \t\t     non-executable edges from vrp_folder .  */\n \t\t  REACHABLE_BLOCKS_PRESERVING_FLAGS),\n-      m_prop (prop) {}\n+    checker (checker) { }\n   ~check_array_bounds_dom_walker () {}\n \n   edge before_dom_children (basic_block) FINAL OVERRIDE;\n \n- private:\n-  vrp_prop *m_prop;\n+private:\n+  array_bounds_checker *checker;\n };\n \n /* Implementation of dom_walker::before_dom_children.\n@@ -4201,9 +4222,9 @@ check_array_bounds_dom_walker::before_dom_children (basic_block bb)\n \n       memset (&wi, 0, sizeof (wi));\n \n-      wi.info = m_prop;\n+      wi.info = checker;\n \n-      walk_gimple_op (stmt, check_array_bounds, &wi);\n+      walk_gimple_op (stmt, array_bounds_checker::check_array_bounds, &wi);\n     }\n \n   /* Determine if there's a unique successor edge, and if so, return\n@@ -4213,11 +4234,10 @@ check_array_bounds_dom_walker::before_dom_children (basic_block bb)\n   return find_taken_edge (bb, NULL_TREE);\n }\n \n-/* Walk over all statements of all reachable BBs and call check_array_bounds\n-   on them.  */\n+/* Entry point into array bounds checking pass.  */\n \n void\n-vrp_prop::check_all_array_refs ()\n+array_bounds_checker::check ()\n {\n   check_array_bounds_dom_walker w (this);\n   w.walk (ENTRY_BLOCK_PTR_FOR_FN (fun));\n@@ -4851,14 +4871,15 @@ vrp_prop::visit_phi (gphi *phi)\n \n class vrp_folder : public substitute_and_fold_engine\n {\n- public:\n+public:\n   vrp_folder () : substitute_and_fold_engine (/* Fold all stmts.  */ true) {  }\n   tree get_value (tree) FINAL OVERRIDE;\n   bool fold_stmt (gimple_stmt_iterator *) FINAL OVERRIDE;\n-  bool fold_predicate_in (gimple_stmt_iterator *);\n \n   class vr_values *vr_values;\n \n+private:\n+  bool fold_predicate_in (gimple_stmt_iterator *);\n   /* Delegators.  */\n   tree vrp_evaluate_conditional (tree_code code, tree op0,\n \t\t\t\t tree op1, gimple *stmt)\n@@ -5293,7 +5314,10 @@ vrp_prop::vrp_finalize (bool warn_array_bounds_p)\n   vrp_folder.substitute_and_fold ();\n \n   if (warn_array_bounds && warn_array_bounds_p)\n-    check_all_array_refs ();\n+    {\n+      array_bounds_checker array_checker (fun, &vr_values);\n+      array_checker.check ();\n+    }\n }\n \n /* Main entry point to VRP (Value Range Propagation).  This pass is"}]}