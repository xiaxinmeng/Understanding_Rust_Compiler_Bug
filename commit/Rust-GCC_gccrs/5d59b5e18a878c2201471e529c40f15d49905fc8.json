{"sha": "5d59b5e18a878c2201471e529c40f15d49905fc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ1OWI1ZTE4YTg3OGMyMjAxNDcxZTUyOWM0MGYxNWQ0OTkwNWZjOA==", "commit": {"author": {"name": "Lawrence Crowl", "email": "crowl@google.com", "date": "2012-10-31T23:15:10Z"}, "committer": {"name": "Lawrence Crowl", "email": "crowl@gcc.gnu.org", "date": "2012-10-31T23:15:10Z"}, "message": "This patch implements generic type query and conversion functions,\n\nand applies them to the use of cgraph_node, varpool_node, and symtab_node.\n\nThe functions are:\n\nbool is_a <TYPE> (pointer)\n  Tests whether the pointer actually points to a more derived TYPE.\n\nTYPE *as_a <TYPE> (pointer)\n  Converts pointer to a TYPE*.\n\nTYPE *dyn_cast <TYPE> (pointer)\n  Converts pointer to TYPE* if and only if \"is_a <TYPE> pointer\".\n  Otherwise, returns NULL.\n  This function is essentially a checked down cast.\n\nThese functions reduce compile time and increase type safety when treating a\ngeneric item as a more specific item.  In essence, the code change is from\n\n  if (symtab_function_p (node))\n    {\n      struct cgraph_node *cnode = cgraph (node);\n      ....\n    }\n\nto\n\n  if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n    {\n      ....\n    }\n\nThe necessary conditional test defines a variable that holds a known good\npointer to the specific item and avoids subsequent conversion calls and\nthe assertion checks that may come with them.\n\nWhen, the property test is embedded within a larger condition, the variable\ndeclaration gets pulled out of the condition.  (This leaves some room for\nusing the variable inappropriately.)\n\n  if (symtab_variable_p (node)\n      && varpool (node)->finalized)\n    varpool_analyze_node (varpool (node));\n\nbecomes\n\n  varpool_node *vnode = dyn_cast <varpool_node> (node);\n  if (vnode && vnode->finalized)\n    varpool_analyze_node (vnode);\n\nNote that we have converted two sets of assertions in the calls to varpool\ninto safe and efficient use of a variable.\n\n\nThere are remaining calls to symtab_function_p and symtab_variable_p that\ndo not involve a pointer to a more specific type.  These have been converted\nto calls to a functions is_a <cgraph_node> and is_a <varpool_node>.  The\noriginal predicate functions have been removed.\n\nThe cgraph.h header defined both a struct and a function with the name\nvarpool_node.  This name overloading can cause some unintuitive error messages\nwhen, as is common in C++, one omits the struct keyword when using the type.\nI have renamed the function to varpool_node_for_decl.\n\nTested on x86_64.\n\n\nIndex: gcc/ChangeLog\n\n2012-10-31  Lawrence Crowl  <crowl@google.com>\n\n\t* is-a.h: New.\n\t(is_a <T> (U*)): New.  Test for is-a relationship.\n\t(as_a <T> (U*)): New.  Treat as a derived type.\n\t(dyn_cast <T> (U*)): New.  Conditionally cast based on is_a.\n\t* cgraph.h (varpool_node): Rename to varpool_node_for_decl.\n\tAdjust callers to match.\n\t(is_a_helper <cgraph_node>::test (symtab_node_def *)): New.\n\t(is_a_helper <varpool_node>::test (symtab_node_def *)): New.\n\t(symtab_node_def::try_function): New.  Change most calls to\n\tsymtab_function_p with calls to dyn_cast <cgraph_node> (p).\n\t(symtab_node_def::try_variable): New.  Change most calls to\n\tsymtab_variable_p with calls to dyn_cast <varpool_node> (p).\n\t(symtab_function_p): Remove.  Change callers to use\n        is_a <cgraph_node> (p) instead.\n\t(symtab_variable_p): Remove.  Change callers to use\n        is_a <varpool_node> (p) instead.\n\t* cgraph.c (cgraph_node_for_asm): Remove redundant call to\n\tsymtab_node_for_asm.\n\t* cgraphunit.c (symbol_finalized_and_needed): New.\n\t(symbol_finalized): New.\n\t(cgraph_analyze_functions): Split complicated conditionals out into\n\tabove new functions.\n\t* Makefile.in (CGRAPH_H): Add is-a.h as used by cgraph.h.\n\nFrom-SVN: r193051", "tree": {"sha": "7209857044c64b9be2543946aeb701d483464efa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7209857044c64b9be2543946aeb701d483464efa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d59b5e18a878c2201471e529c40f15d49905fc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d59b5e18a878c2201471e529c40f15d49905fc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d59b5e18a878c2201471e529c40f15d49905fc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d59b5e18a878c2201471e529c40f15d49905fc8/comments", "author": null, "committer": null, "parents": [{"sha": "2a381a57f3061e171923a14083ac37d957c9c98d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a381a57f3061e171923a14083ac37d957c9c98d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a381a57f3061e171923a14083ac37d957c9c98d"}], "stats": {"total": 738, "additions": 499, "deletions": 239}, "files": [{"sha": "ead3e1ae632ad7cd5a2c4e75615289b1f7330438", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -1,3 +1,29 @@\n+2012-10-31  Lawrence Crowl  <crowl@google.com>\n+\n+\t* is-a.h: New.\n+\t(is_a <T> (U*)): New.  Test for is-a relationship.\n+\t(as_a <T> (U*)): New.  Treat as a derived type.\n+\t(dyn_cast <T> (U*)): New.  Conditionally cast based on is_a.\n+\t* cgraph.h (varpool_node): Rename to varpool_node_for_decl.\n+\tAdjust callers to match.\n+\t(is_a_helper <cgraph_node>::test (symtab_node_def *)): New.\n+\t(is_a_helper <varpool_node>::test (symtab_node_def *)): New.\n+\t(symtab_node_def::try_function): New.  Change most calls to\n+\tsymtab_function_p with calls to dyn_cast <cgraph_node> (p).\n+\t(symtab_node_def::try_variable): New.  Change most calls to\n+\tsymtab_variable_p with calls to dyn_cast <varpool_node> (p).\n+\t(symtab_function_p): Remove.  Change callers to use\n+        is_a <cgraph_node> (p) instead.\n+\t(symtab_variable_p): Remove.  Change callers to use\n+        is_a <varpool_node> (p) instead.\n+\t* cgraph.c (cgraph_node_for_asm): Remove redundant call to\n+\tsymtab_node_for_asm.\n+\t* cgraphunit.c (symbol_finalized_and_needed): New.\n+\t(symbol_finalized): New.\n+\t(cgraph_analyze_functions): Split complicated conditionals out into\n+\tabove new functions.\n+\t* Makefile.in (CGRAPH_H): Add is-a.h as used by cgraph.h.\n+\n 2012-10-31  Steven Bosscher  <steven@gcc.gnu.org>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "3a8ffbea6d8f5f425ef62f10db0b8e059b647259", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -886,7 +886,7 @@ CFGLOOP_H = cfgloop.h $(BASIC_BLOCK_H) vecprim.h double-int.h \\\n IPA_UTILS_H = ipa-utils.h $(TREE_H) $(CGRAPH_H)\n IPA_REFERENCE_H = ipa-reference.h $(BITMAP_H) $(TREE_H)\n CGRAPH_H = cgraph.h $(VEC_H) $(TREE_H) $(BASIC_BLOCK_H) $(FUNCTION_H) \\\n-\tcif-code.def ipa-ref.h ipa-ref-inline.h $(LINKER_PLUGIN_API_H)\n+\tcif-code.def ipa-ref.h ipa-ref-inline.h $(LINKER_PLUGIN_API_H) is-a.h\n DF_H = df.h $(BITMAP_H) $(REGSET_H) sbitmap.h $(BASIC_BLOCK_H) \\\n \talloc-pool.h $(TIMEVAR_H)\n VALTRACK_H = valtrack.h $(BITMAP_H) $(DF_H) $(RTL_H) $(BASIC_BLOCK_H) \\"}, {"sha": "43a835647d26922e2ccb39a55b948d641406e2dd", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -5586,7 +5586,7 @@ gnat_write_global_declarations (void)\n \t\t      void_type_node);\n       TREE_STATIC (dummy_global) = 1;\n       TREE_ASM_WRITTEN (dummy_global) = 1;\n-      node = varpool_node (dummy_global);\n+      node = varpool_node_for_decl (dummy_global);\n       node->symbol.force_output = 1;\n \n       while (!VEC_empty (tree, types_used_by_cur_var_decl))"}, {"sha": "766609b5366e8817e1bbde9aa362e4288f4c43f3", "filename": "gcc/cgraph.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -503,12 +503,15 @@ cgraph_add_thunk (struct cgraph_node *decl_node ATTRIBUTE_UNUSED,\n struct cgraph_node *\n cgraph_node_for_asm (tree asmname)\n {\n-  symtab_node node = symtab_node_for_asm (asmname);\n-\n   /* We do not want to look at inline clones.  */\n-  for (node = symtab_node_for_asm (asmname); node; node = node->symbol.next_sharing_asm_name)\n-    if (symtab_function_p (node) && !cgraph(node)->global.inlined_to)\n-      return cgraph (node);\n+  for (symtab_node node = symtab_node_for_asm (asmname);\n+       node;\n+       node = node->symbol.next_sharing_asm_name)\n+    {\n+      cgraph_node *cn = dyn_cast <cgraph_node> (node);\n+      if (cn && !cn->global.inlined_to)\n+\treturn cn;\n+    }\n   return NULL;\n }\n "}, {"sha": "f276512df312fceb324f258508b7774a5446c353", "filename": "gcc/cgraph.h", "status": "modified", "additions": 59, "deletions": 55, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_CGRAPH_H\n #define GCC_CGRAPH_H\n \n+#include \"is-a.h\"\n #include \"plugin-api.h\"\n #include \"vec.h\"\n #include \"tree.h\"\n@@ -457,12 +458,32 @@ struct GTY(()) asm_node {\n union GTY((desc (\"%h.symbol.type\"), chain_next (\"%h.symbol.next\"),\n \t   chain_prev (\"%h.symbol.previous\"))) symtab_node_def {\n   struct symtab_node_base GTY ((tag (\"SYMTAB_SYMBOL\"))) symbol;\n-  /* Use cgraph (symbol) accessor to get cgraph_node.  */\n+  /* To access the following fields,\n+     use the use dyn_cast or as_a to obtain the concrete type.  */\n   struct cgraph_node GTY ((tag (\"SYMTAB_FUNCTION\"))) x_function;\n-  /* Use varpool (symbol) accessor to get varpool_node.  */\n   struct varpool_node GTY ((tag (\"SYMTAB_VARIABLE\"))) x_variable;\n };\n \n+/* Report whether or not THIS symtab node is a function, aka cgraph_node.  */\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <cgraph_node>::test (symtab_node_def *p)\n+{\n+  return p->symbol.type == SYMTAB_FUNCTION;\n+}\n+\n+/* Report whether or not THIS symtab node is a vriable, aka varpool_node.  */\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <varpool_node>::test (symtab_node_def *p)\n+{\n+  return p->symbol.type == SYMTAB_VARIABLE;\n+}\n+\n extern GTY(()) symtab_node symtab_nodes;\n extern GTY(()) int cgraph_n_nodes;\n extern GTY(()) int cgraph_max_uid;\n@@ -685,7 +706,7 @@ bool cgraph_maybe_hot_edge_p (struct cgraph_edge *e);\n bool cgraph_optimize_for_size_p (struct cgraph_node *);\n \n /* In varpool.c  */\n-struct varpool_node *varpool_node (tree);\n+struct varpool_node *varpool_node_for_decl (tree);\n struct varpool_node *varpool_node_for_asm (tree asmname);\n void varpool_mark_needed_node (struct varpool_node *);\n void debug_varpool (void);\n@@ -715,19 +736,6 @@ void varpool_add_new_variable (tree);\n void symtab_initialize_asm_name_hash (void);\n void symtab_prevail_in_asm_name_hash (symtab_node node);\n \n-/* Return true when NODE is function.  */\n-static inline bool\n-symtab_function_p (symtab_node node)\n-{\n-  return node->symbol.type == SYMTAB_FUNCTION;\n-}\n-\n-/* Return true when NODE is variable.  */\n-static inline bool\n-symtab_variable_p (symtab_node node)\n-{\n-  return node->symbol.type == SYMTAB_VARIABLE;\n-}\n \n /* Return callgraph node for given symbol and check it is a function. */\n static inline struct cgraph_node *\n@@ -800,10 +808,8 @@ varpool_first_variable (void)\n {\n   symtab_node node;\n   for (node = symtab_nodes; node; node = node->symbol.next)\n-    {\n-      if (symtab_variable_p (node))\n-\treturn varpool (node);\n-    }\n+    if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n+      return vnode;\n   return NULL;\n }\n \n@@ -813,10 +819,8 @@ varpool_next_variable (struct varpool_node *node)\n {\n   symtab_node node1 = (symtab_node) node->symbol.next;\n   for (; node1; node1 = node1->symbol.next)\n-    {\n-      if (symtab_variable_p (node1))\n-\treturn varpool (node1);\n-    }\n+    if (varpool_node *vnode1 = dyn_cast <varpool_node> (node1))\n+      return vnode1;\n   return NULL;\n }\n /* Walk all variables.  */\n@@ -832,9 +836,9 @@ varpool_first_static_initializer (void)\n   symtab_node node;\n   for (node = symtab_nodes; node; node = node->symbol.next)\n     {\n-      if (symtab_variable_p (node)\n-\t  && DECL_INITIAL (node->symbol.decl))\n-\treturn varpool (node);\n+      varpool_node *vnode = dyn_cast <varpool_node> (node);\n+      if (vnode && DECL_INITIAL (node->symbol.decl))\n+\treturn vnode;\n     }\n   return NULL;\n }\n@@ -846,9 +850,9 @@ varpool_next_static_initializer (struct varpool_node *node)\n   symtab_node node1 = (symtab_node) node->symbol.next;\n   for (; node1; node1 = node1->symbol.next)\n     {\n-      if (symtab_variable_p (node1)\n-\t  && DECL_INITIAL (node1->symbol.decl))\n-\treturn varpool (node1);\n+      varpool_node *vnode1 = dyn_cast <varpool_node> (node1);\n+      if (vnode1 && DECL_INITIAL (node1->symbol.decl))\n+\treturn vnode1;\n     }\n   return NULL;\n }\n@@ -865,8 +869,9 @@ varpool_first_defined_variable (void)\n   symtab_node node;\n   for (node = symtab_nodes; node; node = node->symbol.next)\n     {\n-      if (symtab_variable_p (node) && varpool (node)->analyzed)\n-\treturn varpool (node);\n+      varpool_node *vnode = dyn_cast <varpool_node> (node);\n+      if (vnode && vnode->analyzed)\n+\treturn vnode;\n     }\n   return NULL;\n }\n@@ -878,8 +883,9 @@ varpool_next_defined_variable (struct varpool_node *node)\n   symtab_node node1 = (symtab_node) node->symbol.next;\n   for (; node1; node1 = node1->symbol.next)\n     {\n-      if (symtab_variable_p (node1) && varpool (node1)->analyzed)\n-\treturn varpool (node1);\n+      varpool_node *vnode1 = dyn_cast <varpool_node> (node1);\n+      if (vnode1 && vnode1->analyzed)\n+\treturn vnode1;\n     }\n   return NULL;\n }\n@@ -895,8 +901,9 @@ cgraph_first_defined_function (void)\n   symtab_node node;\n   for (node = symtab_nodes; node; node = node->symbol.next)\n     {\n-      if (symtab_function_p (node) && cgraph (node)->analyzed)\n-\treturn cgraph (node);\n+      cgraph_node *cn = dyn_cast <cgraph_node> (node);\n+      if (cn && cn->analyzed)\n+\treturn cn;\n     }\n   return NULL;\n }\n@@ -908,8 +915,9 @@ cgraph_next_defined_function (struct cgraph_node *node)\n   symtab_node node1 = (symtab_node) node->symbol.next;\n   for (; node1; node1 = node1->symbol.next)\n     {\n-      if (symtab_function_p (node1) && cgraph (node1)->analyzed)\n-\treturn cgraph (node1);\n+      cgraph_node *cn1 = dyn_cast <cgraph_node> (node1);\n+      if (cn1 && cn1->analyzed)\n+\treturn cn1;\n     }\n   return NULL;\n }\n@@ -925,10 +933,8 @@ cgraph_first_function (void)\n {\n   symtab_node node;\n   for (node = symtab_nodes; node; node = node->symbol.next)\n-    {\n-      if (symtab_function_p (node))\n-\treturn cgraph (node);\n-    }\n+    if (cgraph_node *cn = dyn_cast <cgraph_node> (node))\n+      return cn;\n   return NULL;\n }\n \n@@ -938,10 +944,8 @@ cgraph_next_function (struct cgraph_node *node)\n {\n   symtab_node node1 = (symtab_node) node->symbol.next;\n   for (; node1; node1 = node1->symbol.next)\n-    {\n-      if (symtab_function_p (node1))\n-\treturn cgraph (node1);\n-    }\n+    if (cgraph_node *cn1 = dyn_cast <cgraph_node> (node1))\n+      return cn1;\n   return NULL;\n }\n /* Walk all functions.  */\n@@ -968,9 +972,9 @@ cgraph_first_function_with_gimple_body (void)\n   symtab_node node;\n   for (node = symtab_nodes; node; node = node->symbol.next)\n     {\n-      if (symtab_function_p (node)\n-\t  && cgraph_function_with_gimple_body_p (cgraph (node)))\n-\treturn cgraph (node);\n+      cgraph_node *cn = dyn_cast <cgraph_node> (node);\n+      if (cn && cgraph_function_with_gimple_body_p (cn))\n+\treturn cn;\n     }\n   return NULL;\n }\n@@ -982,9 +986,9 @@ cgraph_next_function_with_gimple_body (struct cgraph_node *node)\n   symtab_node node1 = node->symbol.next;\n   for (; node1; node1 = node1->symbol.next)\n     {\n-      if (symtab_function_p (node1)\n-\t  && cgraph_function_with_gimple_body_p (cgraph (node1)))\n-\treturn cgraph (node1);\n+      cgraph_node *cn1 = dyn_cast <cgraph_node> (node1);\n+      if (cn1 && cgraph_function_with_gimple_body_p (cn1))\n+\treturn cn1;\n     }\n   return NULL;\n }\n@@ -1183,7 +1187,7 @@ cgraph_alias_aliased_node (struct cgraph_node *n)\n \n   ipa_ref_list_reference_iterate (&n->symbol.ref_list, 0, ref);\n   gcc_checking_assert (ref->use == IPA_REF_ALIAS);\n-  if (symtab_function_p (ref->referred))\n+  if (is_a <cgraph_node> (ref->referred))\n     return ipa_ref_node (ref);\n   return NULL;\n }\n@@ -1197,7 +1201,7 @@ varpool_alias_aliased_node (struct varpool_node *n)\n \n   ipa_ref_list_reference_iterate (&n->symbol.ref_list, 0, ref);\n   gcc_checking_assert (ref->use == IPA_REF_ALIAS);\n-  if (symtab_variable_p (ref->referred))\n+  if (is_a <varpool_node> (ref->referred))\n     return ipa_ref_varpool_node (ref);\n   return NULL;\n }\n@@ -1328,7 +1332,7 @@ symtab_real_symbol_p (symtab_node node)\n   struct cgraph_node *cnode;\n   struct ipa_ref *ref;\n \n-  if (!symtab_function_p (node))\n+  if (!is_a <cgraph_node> (node))\n     return true;\n   cnode = cgraph (node);\n   if (cnode->global.inlined_to)"}, {"sha": "57167fd001d761cc0722f43588bee457aabca1e3", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -84,7 +84,7 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n \n       if (TREE_CODE (decl) == VAR_DECL)\n \t{\n-\t  struct varpool_node *vnode = varpool_node (decl);\n+\t  struct varpool_node *vnode = varpool_node_for_decl (decl);\n \t  ipa_record_reference ((symtab_node)ctx->varpool_node,\n \t\t\t\t(symtab_node)vnode,\n \t\t\t\tIPA_REF_ADDR, NULL);\n@@ -123,7 +123,7 @@ record_type_list (struct cgraph_node *node, tree list)\n \t  type = TREE_OPERAND (type, 0);\n \t  if (TREE_CODE (type) == VAR_DECL)\n \t    {\n-\t      struct varpool_node *vnode = varpool_node (type);\n+\t      struct varpool_node *vnode = varpool_node_for_decl (type);\n \t      ipa_record_reference ((symtab_node)node,\n \t\t\t\t    (symtab_node)vnode,\n \t\t\t\t    IPA_REF_ADDR, NULL);\n@@ -233,7 +233,7 @@ mark_address (gimple stmt, tree addr, void *data)\n   else if (addr && TREE_CODE (addr) == VAR_DECL\n \t   && (TREE_STATIC (addr) || DECL_EXTERNAL (addr)))\n     {\n-      struct varpool_node *vnode = varpool_node (addr);\n+      struct varpool_node *vnode = varpool_node_for_decl (addr);\n \n       ipa_record_reference ((symtab_node)data,\n \t\t\t    (symtab_node)vnode,\n@@ -262,7 +262,7 @@ mark_load (gimple stmt, tree t, void *data)\n   else if (t && TREE_CODE (t) == VAR_DECL\n \t   && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n     {\n-      struct varpool_node *vnode = varpool_node (t);\n+      struct varpool_node *vnode = varpool_node_for_decl (t);\n \n       ipa_record_reference ((symtab_node)data,\n \t\t\t    (symtab_node)vnode,\n@@ -280,7 +280,7 @@ mark_store (gimple stmt, tree t, void *data)\n   if (t && TREE_CODE (t) == VAR_DECL\n       && (TREE_STATIC (t) || DECL_EXTERNAL (t)))\n     {\n-      struct varpool_node *vnode = varpool_node (t);\n+      struct varpool_node *vnode = varpool_node_for_decl (t);\n \n       ipa_record_reference ((symtab_node)data,\n \t\t\t    (symtab_node)vnode,\n@@ -392,7 +392,7 @@ void\n record_references_in_initializer (tree decl, bool only_vars)\n {\n   struct pointer_set_t *visited_nodes = pointer_set_create ();\n-  struct varpool_node *node = varpool_node (decl);\n+  struct varpool_node *node = varpool_node_for_decl (decl);\n   struct record_reference_ctx ctx = {false, NULL};\n \n   ctx.varpool_node = node;"}, {"sha": "230125c4a69aadb4ac75271accc637a2226aec25", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 56, "deletions": 35, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -386,7 +386,8 @@ referred_to_p (symtab_node node)\n   if (ipa_ref_list_referring_iterate (&node->symbol.ref_list, 0, ref))\n     return true;\n   /* For functions check also calls.  */\n-  if (symtab_function_p (node) && cgraph (node)->callers)\n+  cgraph_node *cn = dyn_cast <cgraph_node> (node);\n+  if (cn && cn->callers)\n     return true;\n   return false;\n }\n@@ -809,7 +810,7 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n void\n varpool_finalize_decl (tree decl)\n {\n-  struct varpool_node *node = varpool_node (decl);\n+  struct varpool_node *node = varpool_node_for_decl (decl);\n \n   gcc_assert (TREE_STATIC (decl) || DECL_EXTERNAL (decl));\n \n@@ -836,6 +837,35 @@ varpool_finalize_decl (tree decl)\n     varpool_assemble_decl (node);\n }\n \n+\n+/* Determine if a symbol NODE is finalized and needed.  */\n+\n+inline static bool\n+symbol_finalized_and_needed (symtab_node node)\n+{\n+  if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n+    return cnode->local.finalized\n+\t   && cgraph_decide_is_function_needed (cnode, cnode->symbol.decl);\n+  if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n+    return vnode->finalized\n+\t   && !DECL_EXTERNAL (vnode->symbol.decl)\n+\t   && decide_is_variable_needed (vnode, vnode->symbol.decl);\n+  return false;\n+}\n+\n+/* Determine if a symbol NODE is finalized.  */\n+\n+inline static bool\n+symbol_finalized (symtab_node node)\n+{\n+  if (cgraph_node *cnode= dyn_cast <cgraph_node> (node))\n+    return cnode->local.finalized;\n+  if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n+    return vnode->finalized;\n+  return false;\n+}\n+\n+\n /* Discover all functions and variables that are trivially needed, analyze\n    them as well as all functions and variables referred by them  */\n \n@@ -870,13 +900,7 @@ cgraph_analyze_functions (void)\n \t   node != (symtab_node)first_analyzed\n \t   && node != (symtab_node)first_analyzed_var; node = node->symbol.next)\n \t{\n-\t  if ((symtab_function_p (node)\n-\t       && cgraph (node)->local.finalized\n-\t       && cgraph_decide_is_function_needed (cgraph (node), node->symbol.decl))\n-\t      || (symtab_variable_p (node)\n-\t\t  && varpool (node)->finalized\n-\t\t  && !DECL_EXTERNAL (node->symbol.decl)\n-\t\t  && decide_is_variable_needed (varpool (node), node->symbol.decl)))\n+\t  if (symbol_finalized_and_needed (node))\n \t    {\n \t      enqueue_node (node);\n \t      if (!changed && cgraph_dump_file)\n@@ -903,18 +927,15 @@ cgraph_analyze_functions (void)\n \t  changed = true;\n \t  node = first;\n \t  first = (symtab_node)first->symbol.aux;\n-\t  if (symtab_function_p (node) && cgraph (node)->local.finalized)\n+\t  cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n+\t  if (cnode && cnode->local.finalized)\n \t    {\n \t      struct cgraph_edge *edge;\n-\t      struct cgraph_node *cnode;\n-\t      tree decl;\n-\n-\t      cnode = cgraph (node);\n-\t      decl = cnode->symbol.decl;\n+\t      tree decl = cnode->symbol.decl;\n \n-\t      /* ??? It is possible to create extern inline function and later using\n-\t\t weak alias attribute to kill its body. See\n-\t\t gcc.c-torture/compile/20011119-1.c  */\n+\t      /* ??? It is possible to create extern inline function\n+\t      and later using weak alias attribute to kill its body.\n+\t      See gcc.c-torture/compile/20011119-1.c  */\n \t      if (!DECL_STRUCT_FUNCTION (decl)\n \t\t  && (!cnode->alias || !cnode->thunk.alias)\n \t\t  && !cnode->thunk.thunk_p)\n@@ -929,23 +950,25 @@ cgraph_analyze_functions (void)\n \n \t      for (edge = cnode->callees; edge; edge = edge->next_callee)\n \t\tif (edge->callee->local.finalized)\n-\t\t  enqueue_node ((symtab_node)edge->callee);\n+\t\t   enqueue_node ((symtab_node)edge->callee);\n \n-\t      /* If decl is a clone of an abstract function, mark that abstract\n-\t\t function so that we don't release its body. The DECL_INITIAL() of that\n-\t\t abstract function declaration will be later needed to output debug\n-\t\t info.  */\n+\t      /* If decl is a clone of an abstract function,\n+\t      mark that abstract function so that we don't release its body.\n+\t      The DECL_INITIAL() of that abstract function declaration\n+\t      will be later needed to output debug info.  */\n \t      if (DECL_ABSTRACT_ORIGIN (decl))\n \t\t{\n-\t\t  struct cgraph_node *origin_node;\n-\t\t  origin_node = cgraph_get_node (DECL_ABSTRACT_ORIGIN (decl));\n+\t\t  struct cgraph_node *origin_node\n+\t    \t  = cgraph_get_node (DECL_ABSTRACT_ORIGIN (decl));\n \t\t  origin_node->abstract_and_needed = true;\n \t\t}\n-\n \t    }\n-\t  else if (symtab_variable_p (node)\n-\t\t   && varpool (node)->finalized)\n-\t    varpool_analyze_node (varpool (node));\n+\t  else\n+\t    {\n+\t      varpool_node *vnode = dyn_cast <varpool_node> (node);\n+\t      if (vnode && vnode->finalized)\n+\t\tvarpool_analyze_node (vnode);\n+\t    }\n \n \t  if (node->symbol.same_comdat_group)\n \t    {\n@@ -956,8 +979,7 @@ cgraph_analyze_functions (void)\n \t\tenqueue_node (next);\n \t    }\n \t  for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list, i, ref); i++)\n-\t    if ((symtab_function_p (ref->referred) && cgraph (ref->referred)->local.finalized)\n-\t\t|| (symtab_variable_p (ref->referred) && varpool (ref->referred)->finalized))\n+\t    if (symbol_finalized (ref->referred))\n \t      enqueue_node (ref->referred);\n           cgraph_process_new_functions ();\n \t}\n@@ -985,10 +1007,9 @@ cgraph_analyze_functions (void)\n \t  symtab_remove_node (node);\n \t  continue;\n \t}\n-      if (symtab_function_p (node))\n+      if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n \t{\n \t  tree decl = node->symbol.decl;\n-\t  struct cgraph_node *cnode = cgraph (node);\n \n \t  if (cnode->local.finalized && !gimple_has_body_p (decl)\n \t      && (!cnode->alias || !cnode->thunk.alias)\n@@ -1070,7 +1091,7 @@ handle_alias_pairs (void)\n \t}\n \n       if (TREE_CODE (p->decl) == FUNCTION_DECL\n-          && target_node && symtab_function_p (target_node))\n+          && target_node && is_a <cgraph_node> (target_node))\n \t{\n \t  struct cgraph_node *src_node = cgraph_get_node (p->decl);\n \t  if (src_node && src_node->local.finalized)\n@@ -1079,7 +1100,7 @@ handle_alias_pairs (void)\n \t  VEC_unordered_remove (alias_pair, alias_pairs, i);\n \t}\n       else if (TREE_CODE (p->decl) == VAR_DECL\n-\t       && target_node && symtab_variable_p (target_node))\n+\t       && target_node && is_a <varpool_node> (target_node))\n \t{\n \t  varpool_create_variable_alias (p->decl, target_node->symbol.decl);\n \t  VEC_unordered_remove (alias_pair, alias_pairs, i);"}, {"sha": "f3ce643e12e32e176851122370fe9861302473f4", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -1775,7 +1775,7 @@ import_export_class (tree ctype)\n static bool\n var_finalized_p (tree var)\n {\n-  return varpool_node (var)->finalized;\n+  return varpool_node_for_decl (var)->finalized;\n }\n \n /* DECL is a VAR_DECL or FUNCTION_DECL which, for whatever reason,\n@@ -1893,7 +1893,7 @@ maybe_emit_vtables (tree ctype)\n \tTREE_ASM_WRITTEN (vtbl) = 1;\n       else if (DECL_ONE_ONLY (vtbl))\n \t{\n-\t  current = varpool_node (vtbl);\n+\t  current = varpool_node_for_decl (vtbl);\n \t  if (last)\n \t    symtab_add_to_same_comdat_group ((symtab_node) current, (symtab_node) last);\n \t  last = current;"}, {"sha": "3de1439ab523138a2d0273e49ee8144c30a00096", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -3855,30 +3855,33 @@ void\n inline_write_summary (void)\n {\n   struct cgraph_node *node;\n-  symtab_node snode;\n   struct output_block *ob = create_output_block (LTO_section_inline_summary);\n   lto_symtab_encoder_t encoder = ob->decl_state->symtab_node_encoder;\n   unsigned int count = 0;\n   int i;\n \n   for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n-    if (symtab_function_p (snode = lto_symtab_encoder_deref (encoder, i))\n-\t&& cgraph (snode)->analyzed)\n-      count++;\n+    {\n+      symtab_node snode = lto_symtab_encoder_deref (encoder, i);\n+      cgraph_node *cnode = dyn_cast <cgraph_node> (snode);\n+      if (cnode && cnode->analyzed)\n+\tcount++;\n+    }\n   streamer_write_uhwi (ob, count);\n \n   for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n-      if (symtab_function_p (snode = lto_symtab_encoder_deref (encoder, i))\n-\t  && (node = cgraph (snode))->analyzed)\n+      symtab_node snode = lto_symtab_encoder_deref (encoder, i);\n+      cgraph_node *cnode = dyn_cast <cgraph_node> (snode);\n+      if (cnode && (node = cnode)->analyzed)\n \t{\n \t  struct inline_summary *info = inline_summary (node);\n \t  struct bitpack_d bp;\n \t  struct cgraph_edge *edge;\n \t  int i;\n \t  size_time_entry *e;\n \t  struct condition *c;\n-\n+  \n \t  streamer_write_uhwi (ob, lto_symtab_encoder_encode (encoder, (symtab_node)node));\n \t  streamer_write_hwi (ob, info->estimated_self_stack_size);\n \t  streamer_write_hwi (ob, info->self_size);\n@@ -3897,7 +3900,7 @@ inline_write_summary (void)\n \t      bp_pack_value (&bp, c->by_ref, 1);\n \t      streamer_write_bitpack (&bp);\n \t      if (c->agg_contents)\n-\t\tstreamer_write_uhwi (ob, c->offset);\n+\t        streamer_write_uhwi (ob, c->offset);\n \t    }\n \t  streamer_write_uhwi (ob, VEC_length (size_time_entry, info->entry));\n \t  for (i = 0;"}, {"sha": "52850c6f872fd4ff8960806693871db04074d4cd", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -42,7 +42,7 @@ ipa_record_reference (symtab_node referring_node,\n   struct ipa_ref_list *list, *list2;\n   VEC(ipa_ref_t,gc) *old_references;\n \n-  gcc_checking_assert (!stmt || symtab_function_p (referring_node));\n+  gcc_checking_assert (!stmt || is_a <cgraph_node> (referring_node));\n   gcc_checking_assert (use_type != IPA_REF_ALIAS || !stmt);\n \n   list = &referring_node->symbol.ref_list;"}, {"sha": "a17d75b890a989d24a574845279565fb6bddeee4", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -482,7 +482,7 @@ analyze_function (struct cgraph_node *fn)\n   local = init_function_info (fn);\n   for (i = 0; ipa_ref_list_reference_iterate (&fn->symbol.ref_list, i, ref); i++)\n     {\n-      if (!symtab_variable_p (ref->referred))\n+      if (!is_a <varpool_node> (ref->referred))\n \tcontinue;\n       var = ipa_ref_varpool_node (ref)->symbol.decl;\n       if (!is_proper_for_analysis (var))\n@@ -979,8 +979,6 @@ stream_out_bitmap (struct lto_simple_output_block *ob,\n static void\n ipa_reference_write_optimization_summary (void)\n {\n-  struct cgraph_node *node;\n-  symtab_node snode;\n   struct lto_simple_output_block *ob\n     = lto_create_simple_output_block (LTO_section_ipa_reference);\n   unsigned int count = 0;\n@@ -994,12 +992,10 @@ ipa_reference_write_optimization_summary (void)\n   /* See what variables we are interested in.  */\n   for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n-      struct varpool_node *vnode;\n-      snode = lto_symtab_encoder_deref (encoder, i);\n-      if (!symtab_variable_p (snode))\n-\tcontinue;\n-      vnode = varpool (snode);\n-      if (bitmap_bit_p (all_module_statics, DECL_UID (vnode->symbol.decl))\n+      symtab_node snode = lto_symtab_encoder_deref (encoder, i);\n+      varpool_node *vnode = dyn_cast <varpool_node> (snode);\n+      if (vnode\n+\t  && bitmap_bit_p (all_module_statics, DECL_UID (vnode->symbol.decl))\n \t  && referenced_from_this_partition_p (&vnode->symbol.ref_list, encoder))\n \t{\n \t  tree decl = vnode->symbol.decl;\n@@ -1013,10 +1009,12 @@ ipa_reference_write_optimization_summary (void)\n \n   if (ltrans_statics_bitcount)\n     for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n-      if (symtab_function_p (snode = lto_symtab_encoder_deref (encoder, i))\n-\t  && write_node_summary_p (cgraph (snode),\n-\t\t\t\t   encoder, ltrans_statics))\n+      {\n+\tsymtab_node snode = lto_symtab_encoder_deref (encoder, i);\n+\tcgraph_node *cnode = dyn_cast <cgraph_node> (snode);\n+\tif (cnode && write_node_summary_p (cnode, encoder, ltrans_statics))\n \t  count++;\n+      }\n \n   streamer_write_uhwi_stream (ob->main_stream, count);\n   if (count)\n@@ -1027,17 +1025,15 @@ ipa_reference_write_optimization_summary (void)\n   if (ltrans_statics_bitcount)\n     for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n       {\n-\tsnode = lto_symtab_encoder_deref (encoder, i);\n-\tif (!symtab_function_p (snode))\n-\t  continue;\n-\tnode = cgraph (snode);\n-\tif (write_node_summary_p (node, encoder, ltrans_statics))\n+\tsymtab_node snode = lto_symtab_encoder_deref (encoder, i);\n+\tcgraph_node *cnode = dyn_cast <cgraph_node> (snode);\n+\tif (cnode && write_node_summary_p (cnode, encoder, ltrans_statics))\n \t  {\n \t    ipa_reference_optimization_summary_t info;\n \t    int node_ref;\n \n-\t    info = get_reference_optimization_summary (node);\n-\t    node_ref = lto_symtab_encoder_encode (encoder, (symtab_node) node);\n+\t    info = get_reference_optimization_summary (cnode);\n+\t    node_ref = lto_symtab_encoder_encode (encoder, snode);\n \t    streamer_write_uhwi_stream (ob->main_stream, node_ref);\n \n \t    stream_out_bitmap (ob, info->statics_not_read, ltrans_statics,"}, {"sha": "e5737f4d027237344838658c6e326e389d96a79c", "filename": "gcc/ipa.c", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -84,7 +84,7 @@ process_references (struct ipa_ref_list *list,\n   struct ipa_ref *ref;\n   for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)\n     {\n-      if (symtab_function_p (ref->referred))\n+      if (is_a <cgraph_node> (ref->referred))\n \t{\n \t  struct cgraph_node *node = ipa_ref_node (ref);\n \n@@ -290,10 +290,8 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t\t      before_inlining_p, reachable);\n \t}\n \n-      if (symtab_function_p (node))\n+      if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n \t{\n-\t  struct cgraph_node *cnode = cgraph (node);\n-\n \t  /* Mark the callees reachable unless they are direct calls to extern\n  \t     inline functions we decided to not inline.  */\n \t  if (!in_boundary_p)\n@@ -332,18 +330,18 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t    }\n \t}\n       /* When we see constructor of external variable, keep referred nodes in the\n-\t boundary.  This will also hold initializers of the external vars NODE\n-\t reffers to.  */\n-      if (symtab_variable_p (node)\n+\tboundary.  This will also hold initializers of the external vars NODE\n+\trefers to.  */\n+      varpool_node *vnode = dyn_cast <varpool_node> (node);\n+      if (vnode\n \t  && DECL_EXTERNAL (node->symbol.decl)\n-\t  && !varpool (node)->alias\n+\t  && !vnode->alias\n \t  && in_boundary_p)\n-        {\n-\t  int i;\n+\t{\n \t  struct ipa_ref *ref;\n-\t  for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list, i, ref); i++)\n+\t  for (int i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list, i, ref); i++)\n \t    enqueue_node (ref->referred, &first, reachable);\n-        }\n+\t}\n     }\n \n   /* Remove unreachable functions.   */\n@@ -526,7 +524,7 @@ cgraph_address_taken_from_non_vtable_p (struct cgraph_node *node)\n     if (ref->use == IPA_REF_ADDR)\n       {\n \tstruct varpool_node *node;\n-\tif (symtab_function_p (ref->referring))\n+\tif (is_a <cgraph_node> (ref->referring))\n \t  return true;\n \tnode = ipa_ref_referring_varpool_node (ref);\n \tif (!DECL_VIRTUAL_P (node->symbol.decl))"}, {"sha": "c5c75b4bc870db6bba124bc83aff8c953c35a250", "filename": "gcc/is-a.h", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fis-a.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fis-a.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fis-a.h?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -0,0 +1,201 @@\n+/* Dynamic testing for abstract is-a relationships.\n+   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Contributed by Lawrence Crowl.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+/* This header generic type query and conversion functions.\n+\n+\n+USING THE GENERIC TYPE FACILITY\n+\n+\n+The user functions are:\n+\n+bool is_a <TYPE> (pointer)\n+\n+    Tests whether the pointer actually points to a more derived TYPE.\n+\n+    Suppose you have a symtab_node_def *ptr, AKA symtab_node ptr.  You can test\n+    whether it points to a 'derived' cgraph_node as follows.\n+\n+      if (is_a <cgraph_node> (ptr))\n+        ....\n+\n+\n+TYPE *as_a <TYPE> (pointer)\n+\n+    Converts pointer to a TYPE*.\n+\n+    You can just assume that it is such a node.\n+\n+      do_something_with (as_a <cgraph_node> *ptr);\n+\n+TYPE *dyn_cast <TYPE> (pointer)\n+\n+    Converts pointer to TYPE* if and only if \"is_a <TYPE> pointer\".  Otherwise,\n+    returns NULL.  This function is essentially a checked down cast.\n+\n+    This functions reduce compile time and increase type safety when treating a\n+    generic item as a more specific item.\n+\n+    You can test and obtain a pointer to the 'derived' type in one indivisible\n+    operation.\n+\n+      if (cgraph_node *cptr = dyn_cast <cgraph_node> (ptr))\n+        ....\n+\n+    As an example, the code change is from\n+\n+      if (symtab_function_p (node))\n+        {\n+          struct cgraph_node *cnode = cgraph (node);\n+          ....\n+        }\n+\n+    to\n+\n+      if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n+        {\n+          ....\n+        }\n+\n+    The necessary conditional test defines a variable that holds a known good\n+    pointer to the specific item and avoids subsequent conversion calls and\n+    the assertion checks that may come with them.\n+\n+    When, the property test is embedded within a larger condition, the\n+    variable declaration gets pulled out of the condition.  (This approach\n+    leaves some room for using the variable inappropriately.)\n+\n+      if (symtab_variable_p (node) && varpool (node)->finalized)\n+        varpool_analyze_node (varpool (node));\n+\n+    becomes\n+\n+      varpool_node *vnode = dyn_cast <varpool_node> (node);\n+      if (vnode && vnode->finalized)\n+        varpool_analyze_node (vnode);\n+\n+    Note that we have converted two sets of assertions in the calls to varpool\n+    into safe and efficient use of a variable.\n+\n+\n+If you use these functions and get a 'inline function not defined' or a\n+'missing symbol' error message for 'is_a_helper<....>::test', it means that\n+the connection between the types has not been made.  See below.\n+\n+\n+EXTENDING THE GENERIC TYPE FACILITY\n+\n+Each connection between types must be made by defining a specialization of the\n+template member function 'test' of the template class 'is_a_helper'.  For\n+example,\n+\n+  template <>\n+  template <>\n+  inline bool\n+  is_a_helper <cgraph_node>::test (symtab_node_def *p)\n+  {\n+    return p->symbol.type == SYMTAB_FUNCTION;\n+  }\n+\n+If a simple reinterpret_cast between the pointer types is incorrect, then you\n+must also specialize the template member function 'cast'.  Failure to do so\n+when needed may result in a crash.  For example,\n+\n+  template <>\n+  template <>\n+  inline bool\n+  is_a_helper <cgraph_node>::cast (symtab_node_def *p)\n+  {\n+    return &p->x_function;\n+  }\n+\n+*/\n+\n+#ifndef GCC_IS_A_H\n+#define GCC_IS_A_H\n+\n+/* A generic type conversion internal helper class.  */\n+\n+template <typename T>\n+struct is_a_helper\n+{\n+  template <typename U>\n+  static inline bool test (U *p);\n+  template <typename U>\n+  static inline T *cast (U *p);\n+};\n+\n+/* Note that we deliberately do not define the 'test' member template.  Not\n+   doing so will result in a build-time error for type relationships that have\n+   not been defined, rather than a run-time error.  See the discussion above\n+   for when to define this member.  */\n+\n+/* This is the generic implementation for casting from one type to another.\n+   Do not use this routine directly; it is an internal function.  See the\n+   discussion above for when to define this member.  */\n+\n+template <typename T>\n+template <typename U>\n+inline T *\n+is_a_helper <T>::cast (U *p)\n+{\n+  return reinterpret_cast <T *> (p);\n+}\n+\n+\n+/* The public interface.  */\n+\n+/* A generic test for a type relationship.  See the discussion above for when\n+   to use this function.  The question answered is \"Is type T a derived type of\n+   type U?\".  */\n+\n+template <typename T, typename U>\n+inline bool\n+is_a (U *p)\n+{\n+  return is_a_helper<T>::test (p);\n+}\n+\n+/* A generic conversion from a base type U to a derived type T.  See the\n+   discussion above for when to use this function.  */\n+\n+template <typename T, typename U>\n+inline T *\n+as_a (U *p)\n+{\n+  gcc_assert (is_a <T> (p));\n+  return is_a_helper <T>::cast (p);\n+}\n+\n+/* A generic checked conversion from a base type U to a derived type T.  See\n+   the discussion above for when to use this function.  */\n+\n+template <typename T, typename U>\n+inline T *\n+dyn_cast (U *p)\n+{\n+  if (is_a <T> (p))\n+    return is_a_helper <T>::cast (p);\n+  else\n+    return static_cast <T *> (0);\n+}\n+\n+#endif  /* GCC_IS_A_H  */"}, {"sha": "e8f171824a11610a717887921f56d55071ec2631", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -679,7 +679,7 @@ add_references (lto_symtab_encoder_t encoder,\n   int i;\n   struct ipa_ref *ref;\n   for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)\n-    if (symtab_function_p (ref->referred))\n+    if (is_a <cgraph_node> (ref->referred))\n       add_node_to (encoder, ipa_ref_node (ref), false);\n     else\n       lto_symtab_encoder_encode (encoder, ref->referred);\n@@ -730,9 +730,8 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n   for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n       symtab_node node = lto_symtab_encoder_deref (encoder, i);\n-      if (symtab_variable_p (node))\n+      if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n \t{\n-\t  struct varpool_node *vnode = varpool (node);\n \t  if (DECL_INITIAL (vnode->symbol.decl)\n \t      && !lto_symtab_encoder_encode_initializer_p (encoder,\n \t\t\t\t\t\t\t   vnode)\n@@ -796,8 +795,8 @@ output_symtab (void)\n   for (i = 0; i < n_nodes; i++)\n     {\n       symtab_node node = lto_symtab_encoder_deref (encoder, i);\n-      if (symtab_function_p (node))\n-        lto_output_node (ob, cgraph (node), encoder);\n+      if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n+        lto_output_node (ob, cnode, encoder);\n       else\n         lto_output_varpool_node (ob, varpool (node), encoder);\n \t\n@@ -983,7 +982,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   order = streamer_read_hwi (ib) + order_base;\n   decl_index = streamer_read_uhwi (ib);\n   var_decl = lto_file_decl_data_get_var_decl (file_data, decl_index);\n-  node = varpool_node (var_decl);\n+  node = varpool_node_for_decl (var_decl);\n   node->symbol.order = order;\n   if (order >= symtab_order)\n     symtab_order = order + 1;\n@@ -1144,14 +1143,14 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n   /* AUX pointers should be all non-zero for function nodes read from the stream.  */\n #ifdef ENABLE_CHECKING\n   FOR_EACH_VEC_ELT (symtab_node, nodes, i, node)\n-    gcc_assert (node->symbol.aux || !symtab_function_p (node));\n+    gcc_assert (node->symbol.aux || !is_a <cgraph_node> (node));\n #endif\n   FOR_EACH_VEC_ELT (symtab_node, nodes, i, node)\n     {\n       int ref;\n-      if (symtab_function_p (node))\n+      if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n \t{\n-\t  ref = (int) (intptr_t) cgraph (node)->global.inlined_to;\n+\t  ref = (int) (intptr_t) cnode->global.inlined_to;\n \n \t  /* We share declaration of builtins, so we may read same node twice.  */\n \t  if (!node->symbol.aux)\n@@ -1160,9 +1159,9 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n \n \t  /* Fixup inlined_to from reference to pointer.  */\n \t  if (ref != LCC_NOT_FOUND)\n-\t    cgraph (node)->global.inlined_to = cgraph (VEC_index (symtab_node, nodes, ref));\n+\t    cnode->global.inlined_to = cgraph (VEC_index (symtab_node, nodes, ref));\n \t  else\n-\t    cgraph (node)->global.inlined_to = NULL;\n+\t    cnode->global.inlined_to = NULL;\n \t}\n \n       ref = (int) (intptr_t) node->symbol.same_comdat_group;\n@@ -1174,7 +1173,7 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n \tnode->symbol.same_comdat_group = NULL;\n     }\n   FOR_EACH_VEC_ELT (symtab_node, nodes, i, node)\n-    node->symbol.aux = symtab_function_p (node) ? (void *)1 : NULL;\n+    node->symbol.aux = is_a <cgraph_node> (node) ? (void *)1 : NULL;\n   return nodes;\n }\n \n@@ -1449,7 +1448,6 @@ output_node_opt_summary (struct output_block *ob,\n static void\n output_cgraph_opt_summary (void)\n {\n-  symtab_node node;\n   int i, n_nodes;\n   lto_symtab_encoder_t encoder;\n   struct output_block *ob = create_output_block (LTO_section_cgraph_opt_sum);\n@@ -1459,18 +1457,21 @@ output_cgraph_opt_summary (void)\n   encoder = ob->decl_state->symtab_node_encoder;\n   n_nodes = lto_symtab_encoder_size (encoder);\n   for (i = 0; i < n_nodes; i++)\n-    if (symtab_function_p (node = lto_symtab_encoder_deref (encoder, i))\n-\t&& output_cgraph_opt_summary_p (cgraph (node)))\n-      count++;\n+    {\n+      symtab_node node = lto_symtab_encoder_deref (encoder, i);\n+      cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n+      if (cnode && output_cgraph_opt_summary_p (cnode))\n+\tcount++;\n+    }\n   streamer_write_uhwi (ob, count);\n   for (i = 0; i < n_nodes; i++)\n     {\n-      node = lto_symtab_encoder_deref (encoder, i);\n-      if (symtab_function_p (node)\n-\t  && output_cgraph_opt_summary_p (cgraph (node)))\n+      symtab_node node = lto_symtab_encoder_deref (encoder, i);\n+      cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n+      if (cnode && output_cgraph_opt_summary_p (cnode))\n \t{\n \t  streamer_write_uhwi (ob, i);\n-\t  output_node_opt_summary (ob, cgraph (node), encoder);\n+\t  output_node_opt_summary (ob, cnode, encoder);\n \t}\n     }\n   produce_asm (ob, NULL);"}, {"sha": "4467eb49e5aba28679ed73ba64a3a771f4c79104", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -956,7 +956,6 @@ copy_function (struct cgraph_node *node)\n static void\n lto_output (void)\n {\n-  struct cgraph_node *node;\n   struct lto_out_decl_state *decl_state;\n #ifdef ENABLE_CHECKING\n   bitmap output = lto_bitmap_alloc ();\n@@ -972,10 +971,9 @@ lto_output (void)\n   for (i = 0; i < n_nodes; i++)\n     {\n       symtab_node snode = lto_symtab_encoder_deref (encoder, i);\n-      if (!symtab_function_p (snode))\n-\tcontinue;\n-      node = cgraph (snode);\n-      if (lto_symtab_encoder_encode_body_p (encoder, node)\n+      cgraph_node *node = dyn_cast <cgraph_node> (snode);\n+      if (node\n+\t  && lto_symtab_encoder_encode_body_p (encoder, node)\n \t  && !node->alias\n \t  && !node->thunk.thunk_p)\n \t{"}, {"sha": "b45def709271a1cd3d41c7272e31e12f68614ee8", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -1115,7 +1115,7 @@ lsei_next_function_in_partition (lto_symtab_encoder_iterator *lsei)\n {\n   lsei_next (lsei);\n   while (!lsei_end_p (*lsei)\n-\t && (!symtab_function_p (lsei_node (*lsei))\n+\t && (!is_a <cgraph_node> (lsei_node (*lsei))\n \t     || !lto_symtab_encoder_in_partition_p (lsei->encoder, lsei_node (*lsei))))\n     lsei_next (lsei);\n }\n@@ -1128,7 +1128,7 @@ lsei_start_function_in_partition (lto_symtab_encoder_t encoder)\n \n   if (lsei_end_p (lsei))\n     return lsei;\n-  if (!symtab_function_p (lsei_node (lsei))\n+  if (!is_a <cgraph_node> (lsei_node (lsei))\n       || !lto_symtab_encoder_in_partition_p (encoder, lsei_node (lsei)))\n     lsei_next_function_in_partition (&lsei);\n \n@@ -1141,7 +1141,7 @@ lsei_next_variable_in_partition (lto_symtab_encoder_iterator *lsei)\n {\n   lsei_next (lsei);\n   while (!lsei_end_p (*lsei)\n-\t && (!symtab_variable_p (lsei_node (*lsei))\n+\t && (!is_a <varpool_node> (lsei_node (*lsei))\n \t     || !lto_symtab_encoder_in_partition_p (lsei->encoder, lsei_node (*lsei))))\n     lsei_next (lsei);\n }\n@@ -1154,7 +1154,7 @@ lsei_start_variable_in_partition (lto_symtab_encoder_t encoder)\n \n   if (lsei_end_p (lsei))\n     return lsei;\n-  if (!symtab_variable_p (lsei_node (lsei))\n+  if (!is_a <varpool_node> (lsei_node (lsei))\n       || !lto_symtab_encoder_in_partition_p (encoder, lsei_node (lsei)))\n     lsei_next_variable_in_partition (&lsei);\n "}, {"sha": "737c38b0f39904afea54494a364d7495617fc289", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -532,11 +532,11 @@ lto_symtab_merge_cgraph_nodes_1 (symtab_node prevailing)\n \n       if (!symtab_real_symbol_p (e))\n \tcontinue;\n-      if (symtab_function_p (e)\n-\t  && !DECL_BUILT_IN (e->symbol.decl))\n-\tlto_cgraph_replace_node (cgraph (e), cgraph (prevailing));\n-      if (symtab_variable_p (e))\n-\tlto_varpool_replace_node (varpool (e), varpool (prevailing));\n+      cgraph_node *ce = dyn_cast <cgraph_node> (e);\n+      if (ce && !DECL_BUILT_IN (e->symbol.decl))\n+\tlto_cgraph_replace_node (ce, cgraph (prevailing));\n+      if (varpool_node *ve = dyn_cast <varpool_node> (e))\n+\tlto_varpool_replace_node (ve, varpool (prevailing));\n     }\n \n   return;"}, {"sha": "a642a6c5f1759f68f08af0c262cd0e541ca4f87c", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -55,22 +55,22 @@ get_symbol_class (symtab_node node)\n {\n   /* Inline clones are always duplicated.\n      This include external delcarations.   */\n-  if (symtab_function_p (node)\n-      && cgraph (node)->global.inlined_to)\n+  cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n+  if (cnode && cnode->global.inlined_to)\n     return SYMBOL_DUPLICATE;\n \n   /* External declarations are external.  */\n   if (DECL_EXTERNAL (node->symbol.decl))\n     return SYMBOL_EXTERNAL;\n \n-  if (symtab_variable_p (node))\n+  if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n     {\n       /* Constant pool references use local symbol names that can not\n          be promoted global.  We should never put into a constant pool\n          objects that can not be duplicated across partitions.  */\n       if (DECL_IN_CONSTANT_POOL (node->symbol.decl))\n \treturn SYMBOL_DUPLICATE;\n-      gcc_checking_assert (varpool (node)->analyzed);\n+      gcc_checking_assert (vnode->analyzed);\n     }\n   /* Functions that are cloned may stay in callgraph even if they are unused.\n      Handle them as external; compute_ltrans_boundary take care to make\n@@ -145,7 +145,7 @@ add_references_to_partition (ltrans_partition part, symtab_node node)\n     /* References to a readonly variable may be constant foled into its value.\n        Recursively look into the initializers of the constant variable and add\n        references, too.  */\n-    else if (symtab_variable_p (ref->referred)\n+    else if (is_a <varpool_node> (ref->referred)\n \t     && const_value_known_p (ref->referred->symbol.decl)\n \t     && !lto_symtab_encoder_in_partition_p (part->encoder, ref->referred))\n       {\n@@ -196,9 +196,8 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node node)\n     }\n   node->symbol.aux = (void *)((size_t)node->symbol.aux + 1);\n \n-  if (symtab_function_p (node))\n+  if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n     {\n-      struct cgraph_node *cnode = cgraph (node);\n       struct cgraph_edge *e;\n       part->insns += inline_summary (cnode)->self_size;\n \n@@ -247,15 +246,15 @@ contained_in_symbol (symtab_node node)\n   if (lookup_attribute (\"weakref\",\n \t\t\tDECL_ATTRIBUTES (node->symbol.decl)))\n     return node;\n-  if (symtab_function_p (node))\n+  if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n     {\n-      struct cgraph_node *cnode = cgraph_function_node (cgraph (node), NULL);\n+      cnode = cgraph_function_node (cnode, NULL);\n       if (cnode->global.inlined_to)\n \tcnode = cnode->global.inlined_to;\n       return (symtab_node) cnode;\n     }\n-  else if (symtab_variable_p (node))\n-    return (symtab_node) varpool_variable_node (varpool (node), NULL);\n+  else if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n+    return (symtab_node) varpool_variable_node (vnode, NULL);\n   return node;\n }\n \n@@ -302,8 +301,8 @@ undo_partition (ltrans_partition partition, unsigned int n_nodes)\n \tpointer_set_destroy (partition->initializers_visited);\n       partition->initializers_visited = NULL;\n \n-      if (symtab_function_p (node))\n-        partition->insns -= inline_summary (cgraph (node))->self_size;\n+      if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n+        partition->insns -= inline_summary (cnode)->self_size;\n       lto_symtab_encoder_delete_node (partition->encoder, node);\n       node->symbol.aux = (void *)((size_t)node->symbol.aux - 1);\n     }\n@@ -555,11 +554,10 @@ lto_balanced_map (void)\n \t  symtab_node snode = lto_symtab_encoder_deref (partition->encoder,\n \t\t\t\t\t\t\tlast_visited_node);\n \n-\t  if (symtab_function_p (snode))\n+\t  if (cgraph_node *node = dyn_cast <cgraph_node> (snode))\n \t    {\n \t      struct cgraph_edge *edge;\n \n-\t      node = cgraph (snode);\n \t      refs = &node->symbol.ref_list;\n \n \t      last_visited_node++;\n@@ -611,7 +609,7 @@ lto_balanced_map (void)\n \t  /* Compute boundary cost of IPA REF edges and at the same time look into\n \t     variables referenced from current partition and try to add them.  */\n \t  for (j = 0; ipa_ref_list_reference_iterate (refs, j, ref); j++)\n-\t    if (symtab_variable_p (ref->referred))\n+\t    if (is_a <varpool_node> (ref->referred))\n \t      {\n \t\tint index;\n \n@@ -645,7 +643,7 @@ lto_balanced_map (void)\n \t\t  cost++;\n \t      }\n \t  for (j = 0; ipa_ref_list_referring_iterate (refs, j, ref); j++)\n-\t    if (symtab_variable_p (ref->referring))\n+\t    if (is_a <varpool_node> (ref->referring))\n \t      {\n \t\tint index;\n "}, {"sha": "857e8f6032bd7b7f53c454b61cd37c7af94c6d6e", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -2671,12 +2671,17 @@ lto_wpa_write_files (void)\n \t      if (!lto_symtab_encoder_in_partition_p (part->encoder, node))\n \t\t{\n \t          fprintf (cgraph_dump_file, \"%s \", symtab_node_asm_name (node));\n-\t\t  if (symtab_function_p (node)\n-\t\t      && lto_symtab_encoder_encode_body_p (part->encoder, cgraph (node)))\n+\t\t  cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n+\t\t  if (cnode\n+\t\t      && lto_symtab_encoder_encode_body_p (part->encoder, cnode))\n \t\t    fprintf (cgraph_dump_file, \"(body included)\");\n-\t\t  else if (symtab_variable_p (node)\n-\t\t           && lto_symtab_encoder_encode_initializer_p (part->encoder, varpool (node)))\n-\t\t    fprintf (cgraph_dump_file, \"(initializer included)\");\n+\t\t  else\n+\t\t    {\n+\t\t      varpool_node *vnode = dyn_cast <varpool_node> (node);\n+\t\t      if (vnode\n+\t\t\t  && lto_symtab_encoder_encode_initializer_p (part->encoder, vnode))\n+\t\t\tfprintf (cgraph_dump_file, \"(initializer included)\");\n+\t\t    }\n \t\t}\n \t    }\n \t  fprintf (cgraph_dump_file, \"\\n\");"}, {"sha": "7ab58aa381bacede67dd0c020827f76270b9d8c5", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -201,7 +201,7 @@ rest_of_decl_compilation (tree decl,\n     ;\n   else if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl)\n \t   && TREE_STATIC (decl))\n-    varpool_node (decl);\n+    varpool_node_for_decl (decl);\n }\n \n /* Called after finishing a record, union or enumeral type.  */"}, {"sha": "39753e2204dbdc1b5751fe8b7184e4dec8cfcf3c", "filename": "gcc/symtab.c", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -104,7 +104,7 @@ eq_assembler_name (const void *p1, const void *p2)\n static void\n insert_to_assembler_name_hash (symtab_node node)\n {\n-  if (symtab_variable_p (node) && DECL_HARD_REGISTER (node->symbol.decl))\n+  if (is_a <varpool_node> (node) && DECL_HARD_REGISTER (node->symbol.decl))\n     return;\n   gcc_checking_assert (!node->symbol.previous_sharing_asm_name\n \t\t       && !node->symbol.next_sharing_asm_name);\n@@ -252,8 +252,8 @@ symtab_unregister_node (symtab_node node)\n   if (*slot == node)\n     {\n       symtab_node replacement_node = NULL;\n-      if (symtab_function_p (node))\n-\treplacement_node = (symtab_node)cgraph_find_replacement_node (cgraph (node));\n+      if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n+\treplacement_node = (symtab_node)cgraph_find_replacement_node (cnode);\n       if (!replacement_node)\n \thtab_clear_slot (symtab_hash, slot);\n       else\n@@ -294,10 +294,10 @@ symtab_get_node (const_tree decl)\n void\n symtab_remove_node (symtab_node node)\n {\n-  if (symtab_function_p (node))\n-    cgraph_remove_node (cgraph (node));\n-  else if (symtab_variable_p (node))\n-    varpool_remove_node (varpool (node));\n+  if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n+    cgraph_remove_node (cnode);\n+  else if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n+    varpool_remove_node (vnode);\n }\n \n /* Initalize asm name hash unless.  */\n@@ -538,10 +538,10 @@ dump_symtab_base (FILE *f, symtab_node node)\n void\n dump_symtab_node (FILE *f, symtab_node node)\n {\n-  if (symtab_function_p (node))\n-    dump_cgraph_node (f, cgraph (node));\n-  else if (symtab_variable_p (node))\n-    dump_varpool_node (f, varpool (node));\n+  if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n+    dump_cgraph_node (f, cnode);\n+  else if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n+    dump_varpool_node (f, vnode);\n }\n \n /* Dump symbol table.  */\n@@ -579,15 +579,15 @@ verify_symtab_base (symtab_node node)\n   bool error_found = false;\n   symtab_node hashed_node;\n \n-  if (symtab_function_p (node))\n+  if (is_a <cgraph_node> (node))\n     {\n       if (TREE_CODE (node->symbol.decl) != FUNCTION_DECL)\n \t{\n           error (\"function symbol is not function\");\n           error_found = true;\n \t}\n     }\n-  else if (symtab_variable_p (node))\n+  else if (is_a <varpool_node> (node))\n     {\n       if (TREE_CODE (node->symbol.decl) != VAR_DECL)\n \t{\n@@ -622,7 +622,8 @@ verify_symtab_base (symtab_node node)\n \t  hashed_node = hashed_node->symbol.next_sharing_asm_name;\n \t}\n       if (!hashed_node\n-          && !(symtab_variable_p (node) || DECL_HARD_REGISTER (node->symbol.decl)))\n+          && !(is_a <varpool_node> (node)\n+\t       || DECL_HARD_REGISTER (node->symbol.decl)))\n \t{\n           error (\"node not found in symtab assembler name hash\");\n           error_found = true;\n@@ -676,8 +677,8 @@ verify_symtab_node (symtab_node node)\n     return;\n \n   timevar_push (TV_CGRAPH_VERIFY);\n-  if (symtab_function_p (node))\n-    verify_cgraph_node (cgraph (node));\n+  if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n+    verify_cgraph_node (cnode);\n   else\n     if (verify_symtab_base (node))\n       {"}, {"sha": "d2cd4ea79465741b434c1d1c279248271c6aac21", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -260,7 +260,7 @@ get_emutls_init_templ_addr (tree decl)\n   /* Create varpool node for the new variable and finalize it if it is\n      not external one.  */\n   if (DECL_EXTERNAL (to))\n-    varpool_node (to);\n+    varpool_node_for_decl (to);\n   else\n     varpool_add_new_variable (to);\n   return build_fold_addr_expr (to);\n@@ -332,7 +332,7 @@ new_emutls_decl (tree decl, tree alias_of)\n   /* Create varpool node for the new variable and finalize it if it is\n      not external one.  */\n   if (DECL_EXTERNAL (to))\n-    varpool_node (to);\n+    varpool_node_for_decl (to);\n   else if (!alias_of)\n     varpool_add_new_variable (to);\n   else "}, {"sha": "b300348542314c09d5128c61401e7097c41e6cc5", "filename": "gcc/varasm.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -2221,7 +2221,7 @@ mark_decl_referenced (tree decl)\n     }\n   else if (TREE_CODE (decl) == VAR_DECL)\n     {\n-      struct varpool_node *node = varpool_node (decl);\n+      struct varpool_node *node = varpool_node_for_decl (decl);\n       /* C++ frontend use mark_decl_references to force COMDAT variables\n          to be output that might appear dead otherwise.  */\n       node->symbol.force_output = true;\n@@ -5549,7 +5549,7 @@ assemble_alias (tree decl, tree target)\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     cgraph_get_create_node (decl)->alias = true;\n   else\n-    varpool_node (decl)->alias = true;\n+    varpool_node_for_decl (decl)->alias = true;\n \n   /* If the target has already been emitted, we don't have to queue the\n      alias.  This saves a tad of memory.  */"}, {"sha": "b88ec613ff64befdd74be0aef709d8a9b28516b5", "filename": "gcc/varpool.c", "status": "modified", "additions": 21, "deletions": 16, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d59b5e18a878c2201471e529c40f15d49905fc8/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=5d59b5e18a878c2201471e529c40f15d49905fc8", "patch": "@@ -39,7 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Return varpool node assigned to DECL.  Create new one when needed.  */\n struct varpool_node *\n-varpool_node (tree decl)\n+varpool_node_for_decl (tree decl)\n {\n   struct varpool_node *node = varpool_get_node (decl);\n   gcc_assert (TREE_CODE (decl) == VAR_DECL\n@@ -114,9 +114,9 @@ debug_varpool (void)\n struct varpool_node *\n varpool_node_for_asm (tree asmname)\n {\n-  symtab_node node = symtab_node_for_asm (asmname);\n-  if (node && symtab_variable_p (node))\n-    return varpool (node);\n+  if (symtab_node node = symtab_node_for_asm (asmname))\n+    if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n+      return vnode;\n   return NULL;\n }\n \n@@ -192,7 +192,7 @@ varpool_add_new_variable (tree decl)\n {\n   struct varpool_node *node;\n   varpool_finalize_decl (decl);\n-  node = varpool_node (decl);\n+  node = varpool_node_for_decl (decl);\n   if (varpool_externally_visible_p (node, false))\n     node->symbol.externally_visible = true;\n }\n@@ -232,7 +232,7 @@ varpool_analyze_node (struct varpool_node *node)\n     }\n   if (node->alias && node->alias_of)\n     {\n-      struct varpool_node *tgt = varpool_node (node->alias_of);\n+      struct varpool_node *tgt = varpool_node_for_decl (node->alias_of);\n       struct varpool_node *n;\n \n       for (n = tgt; n && n->alias;\n@@ -378,16 +378,21 @@ varpool_remove_unreferenced_decls (void)\n \t  for (next = node->symbol.same_comdat_group;\n \t       next != (symtab_node)node;\n \t       next = next->symbol.same_comdat_group)\n-\t    if (symtab_variable_p (next)\n-\t\t&& varpool (next)->analyzed)\n-\t      enqueue_node (varpool (next), &first);\n+\t    {\n+\t      varpool_node *vnext = dyn_cast <varpool_node> (next);\n+\t      if (vnext && vnext->analyzed)\n+\t\tenqueue_node (vnext, &first);\n+\t    }\n \t}\n       for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list, i, ref); i++)\n-\tif (symtab_variable_p (ref->referred)\n-\t    && (!DECL_EXTERNAL (ref->referred->symbol.decl)\n-\t\t|| varpool (ref->referred)->alias)\n-\t    && varpool (ref->referred)->analyzed)\n-\t  enqueue_node (varpool (ref->referred), &first);\n+\t{\n+\t  varpool_node *vnode = dyn_cast <varpool_node> (ref->referred);\n+\t  if (vnode\n+\t      && (!DECL_EXTERNAL (ref->referred->symbol.decl)\n+\t\t  || vnode->alias)\n+\t      && vnode->analyzed)\n+\t    enqueue_node (vnode, &first);\n+\t}\n     }\n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file, \"\\nRemoving variables:\");\n@@ -461,7 +466,7 @@ add_new_static_var (tree type)\n   DECL_CONTEXT (new_decl) = NULL_TREE;\n   DECL_ABSTRACT (new_decl) = 0;\n   lang_hooks.dup_lang_specific_decl (new_decl);\n-  new_node = varpool_node (new_decl);\n+  new_node = varpool_node_for_decl (new_decl);\n   varpool_finalize_decl (new_decl);\n \n   return new_node->symbol.decl;\n@@ -477,7 +482,7 @@ varpool_create_variable_alias (tree alias, tree decl)\n \n   gcc_assert (TREE_CODE (decl) == VAR_DECL);\n   gcc_assert (TREE_CODE (alias) == VAR_DECL);\n-  alias_node = varpool_node (alias);\n+  alias_node = varpool_node_for_decl (alias);\n   alias_node->alias = 1;\n   alias_node->finalized = 1;\n   alias_node->alias_of = decl;"}]}