{"sha": "7525bb7d7fe6d44c4634401e7468c408cee94d81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzUyNWJiN2Q3ZmU2ZDQ0YzQ2MzQ0MDFlNzQ2OGM0MDhjZWU5NGQ4MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-11-17T18:52:28Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-11-17T18:52:28Z"}, "message": "predict.c (maybe_hot_frequency_p): Use opt_for_fn.\n\n\n\t* predict.c (maybe_hot_frequency_p): Use opt_for_fn.\n\t(optimize_function_for_size_p): Likewise.\n\t(probably_never_executed): Likewise; replace cfun by fun.\n\nFrom-SVN: r217666", "tree": {"sha": "608fe72fb5db2fc9a6874350ecb351ceba0df42e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/608fe72fb5db2fc9a6874350ecb351ceba0df42e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7525bb7d7fe6d44c4634401e7468c408cee94d81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7525bb7d7fe6d44c4634401e7468c408cee94d81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7525bb7d7fe6d44c4634401e7468c408cee94d81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7525bb7d7fe6d44c4634401e7468c408cee94d81/comments", "author": null, "committer": null, "parents": [{"sha": "960ceebc9352b0d90cfa9b8af614a7a60cef8578", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/960ceebc9352b0d90cfa9b8af614a7a60cef8578", "html_url": "https://github.com/Rust-GCC/gccrs/commit/960ceebc9352b0d90cfa9b8af614a7a60cef8578"}], "stats": {"total": 32, "additions": 18, "deletions": 14}, "files": [{"sha": "6e717d746884934f20bb448ba3a52b216028809b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7525bb7d7fe6d44c4634401e7468c408cee94d81/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7525bb7d7fe6d44c4634401e7468c408cee94d81/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7525bb7d7fe6d44c4634401e7468c408cee94d81", "patch": "@@ -1,3 +1,9 @@\n+2014-11-17  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* predict.c (maybe_hot_frequency_p): Use opt_for_fn.\n+\t(optimize_function_for_size_p): Likewise.\n+\t(probably_never_executed): Likewise; replace cfun by fun.\n+\n 2014-11-17  Alan Lawrence  <alan.lawrence@arm.com>\n \n \t* config/aarch64/aarch64-simd.md (aarch64_simd_vec_set<mode>): Add"}, {"sha": "b21f6860e413bc7d6c1ac27bf20c78dcffec022e", "filename": "gcc/predict.c", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7525bb7d7fe6d44c4634401e7468c408cee94d81/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7525bb7d7fe6d44c4634401e7468c408cee94d81/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=7525bb7d7fe6d44c4634401e7468c408cee94d81", "patch": "@@ -125,7 +125,8 @@ static inline bool\n maybe_hot_frequency_p (struct function *fun, int freq)\n {\n   struct cgraph_node *node = cgraph_node::get (fun->decl);\n-  if (!profile_info || !flag_branch_probabilities)\n+  if (!profile_info\n+      || !opt_for_fn (fun->decl, flag_branch_probabilities))\n     {\n       if (node->frequency == NODE_FREQUENCY_UNLIKELY_EXECUTED)\n         return false;\n@@ -214,42 +215,42 @@ probably_never_executed (struct function *fun,\n                          gcov_type count, int frequency)\n {\n   gcc_checking_assert (fun);\n-  if (profile_status_for_fn (cfun) == PROFILE_READ)\n+  if (profile_status_for_fn (fun) == PROFILE_READ)\n     {\n       int unlikely_count_fraction = PARAM_VALUE (UNLIKELY_BB_COUNT_FRACTION);\n       if (count * unlikely_count_fraction >= profile_info->runs)\n \treturn false;\n       if (!frequency)\n \treturn true;\n-      if (!ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency)\n+      if (!ENTRY_BLOCK_PTR_FOR_FN (fun)->frequency)\n \treturn false;\n-      if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count)\n+      if (ENTRY_BLOCK_PTR_FOR_FN (fun)->count)\n \t{\n           gcov_type computed_count;\n           /* Check for possibility of overflow, in which case entry bb count\n              is large enough to do the division first without losing much\n              precision.  */\n-\t  if (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count < REG_BR_PROB_BASE *\n+\t  if (ENTRY_BLOCK_PTR_FOR_FN (fun)->count < REG_BR_PROB_BASE *\n \t      REG_BR_PROB_BASE)\n             {\n               gcov_type scaled_count\n-\t\t  = frequency * ENTRY_BLOCK_PTR_FOR_FN (cfun)->count *\n+\t\t  = frequency * ENTRY_BLOCK_PTR_FOR_FN (fun)->count *\n \t     unlikely_count_fraction;\n \t      computed_count = RDIV (scaled_count,\n-\t\t\t\t     ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency);\n+\t\t\t\t     ENTRY_BLOCK_PTR_FOR_FN (fun)->frequency);\n             }\n           else\n             {\n-\t      computed_count = RDIV (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count,\n-\t\t\t\t     ENTRY_BLOCK_PTR_FOR_FN (cfun)->frequency);\n+\t      computed_count = RDIV (ENTRY_BLOCK_PTR_FOR_FN (fun)->count,\n+\t\t\t\t     ENTRY_BLOCK_PTR_FOR_FN (fun)->frequency);\n               computed_count *= frequency * unlikely_count_fraction;\n             }\n           if (computed_count >= profile_info->runs)\n             return false;\n \t}\n       return true;\n     }\n-  if ((!profile_info || !flag_branch_probabilities)\n+  if ((!profile_info || !(opt_for_fn (fun->decl, flag_branch_probabilities)))\n       && (cgraph_node::get (fun->decl)->frequency\n \t  == NODE_FREQUENCY_UNLIKELY_EXECUTED))\n     return true;\n@@ -279,11 +280,8 @@ probably_never_executed_edge_p (struct function *fun, edge e)\n bool\n optimize_function_for_size_p (struct function *fun)\n {\n-  if (optimize_size)\n-    return true;\n   if (!fun || !fun->decl)\n-    return false;\n-\n+    return optimize_size;\n   cgraph_node *n = cgraph_node::get (fun->decl);\n   return n && n->optimize_for_size_p ();\n }"}]}