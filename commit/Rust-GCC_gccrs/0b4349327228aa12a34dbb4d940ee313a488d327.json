{"sha": "0b4349327228aa12a34dbb4d940ee313a488d327", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI0MzQ5MzI3MjI4YWExMmEzNGRiYjRkOTQwZWUzMTNhNDg4ZDMyNw==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2004-11-16T21:37:29Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-11-16T21:37:29Z"}, "message": "Object.java: Added javadocs all over (merged from GNU classpath).\n\n2004-11-16  Michael Koch  <konqueror@gmx.de>\n\n\t* java/lang/Object.java: Added javadocs all over (merged from GNU\n\tclasspath).\n\nFrom-SVN: r90766", "tree": {"sha": "3f2ad7baa30a31e53debd7f104bd3849847b54ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f2ad7baa30a31e53debd7f104bd3849847b54ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b4349327228aa12a34dbb4d940ee313a488d327", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b4349327228aa12a34dbb4d940ee313a488d327", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b4349327228aa12a34dbb4d940ee313a488d327", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b4349327228aa12a34dbb4d940ee313a488d327/comments", "author": null, "committer": null, "parents": [{"sha": "fd9065b2ef6a6d36c98b0a2a1db25a0dfc9180ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd9065b2ef6a6d36c98b0a2a1db25a0dfc9180ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd9065b2ef6a6d36c98b0a2a1db25a0dfc9180ce"}], "stats": {"total": 454, "additions": 435, "deletions": 19}, "files": [{"sha": "dace13d9a53a2fb3fec3f813defb0937138a59d9", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4349327228aa12a34dbb4d940ee313a488d327/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4349327228aa12a34dbb4d940ee313a488d327/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=0b4349327228aa12a34dbb4d940ee313a488d327", "patch": "@@ -1,3 +1,8 @@\n+2004-11-16  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/lang/Object.java: Added javadocs all over (merged from GNU\n+\tclasspath).\n+\n 2004-11-16  Andreas Tobler  <a.tobler@schweiz.ch>\n \n \t* java/security/Security.java (Security): Silence the warning about no"}, {"sha": "4eee4510f45e0b9130d7e33d3160fc79c0d1b2a3", "filename": "libjava/java/lang/Object.java", "status": "modified", "additions": 430, "deletions": 19, "changes": 449, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b4349327228aa12a34dbb4d940ee313a488d327/libjava%2Fjava%2Flang%2FObject.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b4349327228aa12a34dbb4d940ee313a488d327/libjava%2Fjava%2Flang%2FObject.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FObject.java?ref=0b4349327228aa12a34dbb4d940ee313a488d327", "patch": "@@ -39,61 +39,472 @@\n \n package java.lang;\n \n-/**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date September 30, 1998 \n- */\n-\n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n  * plus gcj compiler sources (to determine object layout)\n  * Status:  Complete to version 1.1\n  */\n \n+/**\n+ * Object is the ultimate superclass of every class\n+ * (excepting interfaces).  When you define a class that\n+ * does not extend any other class, it implicitly extends\n+ * java.lang.Object.  Also, an anonymous class based on\n+ * an interface will extend Object.\n+ *\n+ * <p>It provides general-purpose methods that every single\n+ * Object, regardless of race, sex or creed, implements.\n+ * All of the public methods may be invoked on arrays or\n+ * interfaces.  The protected methods <code>clone</code>\n+ * and <code>finalize</code> are not accessible on arrays\n+ * or interfaces, but all array types have a public version\n+ * of <code>clone</code> which is accessible.\n+ *\n+ * @author John Keiser\n+ * @author Eric Blake (ebb9@email.byu.edu)\n+ * @author Tom Tromey (tromey@cygnus.com)\n+ */\n public class Object\n {\n+  /**\n+   * Called on an object by the Virtual Machine at most once,\n+   * at some point after the Object is determined unreachable\n+   * but before it is destroyed. You would think that this\n+   * means it eventually is called on every Object, but this is\n+   * not necessarily the case.  If execution terminates\n+   * abnormally, garbage collection does not always happen.\n+   * Thus you cannot rely on this method to always work.\n+   * For finer control over garbage collection, use references\n+   * from the {@link java.lang.ref} package.\n+   *\n+   * <p>Virtual Machines are free to not call this method if\n+   * they can determine that it does nothing important; for\n+   * example, if your class extends Object and overrides\n+   * finalize to do simply <code>super.finalize()</code>.\n+   *\n+   * <p>finalize() will be called by a {@link Thread} that has no\n+   * locks on any Objects, and may be called concurrently.\n+   * There are no guarantees on the order in which multiple\n+   * objects are finalized.  This means that finalize() is\n+   * usually unsuited for performing actions that must be\n+   * thread-safe, and that your implementation must be\n+   * use defensive programming if it is to always work.\n+   *\n+   * <p>If an Exception is thrown from finalize() during garbage\n+   * collection, it will be patently ignored and the Object will\n+   * still be destroyed.\n+   *\n+   * <p>It is allowed, although not typical, for user code to call\n+   * finalize() directly.  User invocation does not affect whether\n+   * automatic invocation will occur.  It is also permitted,\n+   * although not recommended, for a finalize() method to \"revive\"\n+   * an object by making it reachable from normal code again.\n+   *\n+   * <p>Unlike constructors, finalize() does not get called\n+   * for an object's superclass unless the implementation\n+   * specifically calls <code>super.finalize()</code>.\n+   *\n+   * <p>The default implementation does nothing.\n+   *\n+   * @throws Throwable permits a subclass to throw anything in an\n+   *         overridden version; but the default throws nothing\n+   * @see System#gc()\n+   * @see System#runFinalizersOnExit(boolean)\n+   * @see java.lang.ref\n+   */\n   // This must come first.  See _JvObjectPrefix in Object.h.\n   protected void finalize () throws Throwable\n   {\n   }\n \n-  public final native Class getClass ();\n-  public native int hashCode ();\n-  public final native void notify ();\n-  public final native void notifyAll ();\n-  public final native void wait (long timeout, int nanos)\n+  /**\n+   * Returns the runtime {@link Class} of this Object.\n+   *\n+   * <p>The class object can also be obtained without a runtime\n+   * instance by using the class literal, as in:\n+   * <code>Foo.class</code>.  Notice that the class literal\n+   * also works on primitive types, making it useful for\n+   * reflection purposes.\n+   *\n+   * @return the class of this Object\n+   */\n+  public final native Class getClass();\n+\n+  /**\n+   * Get a value that represents this Object, as uniquely as\n+   * possible within the confines of an int.\n+   *\n+   * <p>There are some requirements on this method which\n+   * subclasses must follow:<br>\n+   *\n+   * <ul>\n+   * <li>Semantic equality implies identical hashcodes.  In other\n+   *     words, if <code>a.equals(b)</code> is true, then\n+   *     <code>a.hashCode() == b.hashCode()</code> must be as well.\n+   *     However, the reverse is not necessarily true, and two\n+   *     objects may have the same hashcode without being equal.</li>\n+   * <li>It must be consistent.  Whichever value o.hashCode()\n+   *     returns on the first invocation must be the value\n+   *     returned on all later invocations as long as the object\n+   *     exists.  Notice, however, that the result of hashCode may\n+   *     change between separate executions of a Virtual Machine,\n+   *     because it is not invoked on the same object.</li>\n+   * </ul>\n+   *\n+   * <p>Notice that since <code>hashCode</code> is used in\n+   * {@link java.util.Hashtable} and other hashing classes,\n+   * a poor implementation will degrade the performance of hashing\n+   * (so don't blindly implement it as returning a constant!). Also,\n+   * if calculating the hash is time-consuming, a class may consider\n+   * caching the results.\n+   *\n+   * <p>The default implementation returns\n+   * <code>System.identityHashCode(this)</code>\n+   *\n+   * @return the hash code for this Object\n+   * @see #equals(Object)\n+   * @see System#identityHashCode(Object)\n+   */\n+  public native int hashCode();\n+\n+  /**\n+   * Wakes up one of the {@link Thread}s that has called\n+   * <code>wait</code> on this Object.  Only the owner\n+   * of a lock on this Object may call this method.  This lock\n+   * is obtained by a <code>synchronized</code> method or statement.\n+   *\n+   * <p>The Thread to wake up is chosen arbitrarily.  The\n+   * awakened thread is not guaranteed to be the next thread\n+   * to actually obtain the lock on this object.\n+   *\n+   * <p>This thread still holds a lock on the object, so it is\n+   * typical to release the lock by exiting the synchronized\n+   * code, calling wait(), or calling {@link Thread#sleep()}, so\n+   * that the newly awakened thread can actually resume.  The\n+   * awakened thread will most likely be awakened with an\n+   * {@link InterruptedException}, but that is not guaranteed.\n+   *\n+   * @throws IllegalMonitorStateException if this Thread\n+   *         does not own the lock on the Object\n+   * @see #notifyAll()\n+   * @see #wait()\n+   * @see #wait(long)\n+   * @see #wait(long, int)\n+   * @see Thread\n+   */\n+  public final native void notify();\n+  \n+  /**\n+   * Wakes up all of the {@link Thread}s that have called\n+   * <code>wait</code> on this Object.  Only the owner\n+   * of a lock on this Object may call this method.  This lock\n+   * is obtained by a <code>synchronized</code> method or statement.\n+   *\n+   * <p>There are no guarantees as to which thread will next\n+   * obtain the lock on the object.\n+   *\n+   * <p>This thread still holds a lock on the object, so it is\n+   * typical to release the lock by exiting the synchronized\n+   * code, calling wait(), or calling {@link Thread#sleep()}, so\n+   * that one of the newly awakened threads can actually resume.\n+   * The resuming thread will most likely be awakened with an\n+   * {@link InterruptedException}, but that is not guaranteed.\n+   *\n+   * @throws IllegalMonitorStateException if this Thread\n+   *         does not own the lock on the Object\n+   * @see #notify()\n+   * @see #wait()\n+   * @see #wait(long)\n+   * @see #wait(long, int)\n+   * @see Thread\n+   */\n+  public final native void notifyAll();\n+\n+  /**\n+   * Waits a specified amount of time (or indefinitely if\n+   * the time specified is 0) for someone to call notify()\n+   * or notifyAll() on this Object, waking up this Thread.\n+   *\n+   * <p>The Thread that calls wait must have a lock on this Object,\n+   * obtained by a <code>synchronized</code> method or statement.\n+   * After calling wait, the thread loses the lock on this\n+   * object until the method completes (abruptly or normally),\n+   * at which time it regains the lock.  All locks held on\n+   * other objects remain in force, even though the thread is\n+   * inactive. Therefore, caution must be used to avoid deadlock.\n+   *\n+   * <p>Usually, this call will complete normally if the time\n+   * expires, or abruptly with {@link InterruptedException}\n+   * if another thread called notify, but neither result\n+   * is guaranteed.\n+   *\n+   * <p>The waiting period is nowhere near as precise as\n+   * nanoseconds; considering that even wait(int) is inaccurate,\n+   * how much can you expect?  But on supporting\n+   * implementations, this offers somewhat more granularity\n+   * than milliseconds.\n+   *\n+   * @param ms the number of milliseconds to wait (1,000\n+   *        milliseconds = 1 second)\n+   * @param ns the number of nanoseconds to wait over and\n+   *        above ms (1,000,000 nanoseconds = 1 millisecond)\n+   * @throws IllegalArgumentException if ms &lt; 0 or ns is not\n+   *         in the range 0 to 999,999\n+   * @throws IllegalMonitorStateException if this Thread\n+   *         does not own a lock on this Object\n+   * @throws InterruptedException if some other Thread\n+   *         interrupts this Thread\n+   * @see #notify()\n+   * @see #notifyAll()\n+   * @see #wait()\n+   * @see #wait(long)\n+   * @see Thread\n+   */\n+  public final native void wait(long timeout, int nanos)\n     throws InterruptedException;\n \n-  public boolean equals (Object obj)\n+  /**\n+   * Determine whether this Object is semantically equal\n+   * to another Object.\n+   *\n+   * <p>There are some fairly strict requirements on this\n+   * method which subclasses must follow:<br>\n+   * <ul>\n+   * <li>It must be transitive.  If <code>a.equals(b)</code> and\n+   *     <code>b.equals(c)</code>, then <code>a.equals(c)</code>\n+   *     must be true as well.</li>\n+   * <li>It must be symmetric.  <code>a.equals(b)</code> and\n+   *     <code>b.equals(a)</code> must have the same value.</li>\n+   * <li>It must be reflexive.  <code>a.equals(a)</code> must\n+   *     always be true.</li>\n+   * <li>It must be consistent.  Whichever value a.equals(b)\n+   *     returns on the first invocation must be the value\n+   *     returned on all later invocations.</li>\n+   * <li><code>a.equals(null)</code> must be false.</li>\n+   * <li>It must be consistent with hashCode().  That is,\n+   *     <code>a.equals(b)</code> must imply\n+   *     <code>a.hashCode() == b.hashCode()</code>.\n+   *     The reverse is not true; two objects that are not\n+   *     equal may have the same hashcode, but that has\n+   *     the potential to harm hashing performance.</li>\n+   * </ul>\n+   *\n+   * <p>This is typically overridden to throw a {@link ClassCastException}\n+   * if the argument is not comparable to the class performing\n+   * the comparison, but that is not a requirement.  It is legal\n+   * for <code>a.equals(b)</code> to be true even though\n+   * <code>a.getClass() != b.getClass()</code>.  Also, it\n+   * is typical to never cause a {@link NullPointerException}.\n+   *\n+   * <p>In general, the Collections API ({@link java.util}) use the\n+   * <code>equals</code> method rather than the <code>==</code>\n+   * operator to compare objects.  However, {@link java.util.IdentityHashMap}\n+   * is an exception to this rule, for its own good reasons.\n+   *\n+   * <p>The default implementation returns <code>this == o</code>.\n+   *\n+   * @param obj the Object to compare to\n+   * @return whether this Object is semantically equal to another\n+   * @see #hashCode()\n+   */\n+  public boolean equals(Object obj)\n   {\n     return this == obj;\n   }\n \n-  public Object ()\n+  /**\n+   * The basic constructor.  Object is special, because it has no\n+   * superclass, so there is no call to super().\n+   *\n+   * @throws OutOfMemoryError Technically, this constructor never\n+   *         throws an OutOfMemoryError, because the memory has\n+   *         already been allocated by this point.  But as all\n+   *         instance creation expressions eventually trace back\n+   *         to this constructor, and creating an object allocates\n+   *         memory, we list that possibility here.\n+   */\n+  public Object()\n   {\n   }\n \n-  public String toString ()\n+  /**\n+   * Convert this Object to a human-readable String.\n+   * There are no limits placed on how long this String\n+   * should be or what it should contain.  We suggest you\n+   * make it as intuitive as possible to be able to place\n+   * it into {@link java.io.PrintStream#println() System.out.println()}\n+   * and such.\n+   *\n+   * <p>It is typical, but not required, to ensure that this method\n+   * never completes abruptly with a {@link RuntimeException}.\n+   *\n+   * <p>This method will be called when performing string\n+   * concatenation with this object.  If the result is\n+   * <code>null</code>, string concatenation will instead\n+   * use <code>\"null\"</code>.\n+   *\n+   * <p>The default implementation returns\n+   * <code>getClass().getName() + \"@\" +\n+   *      Integer.toHexString(hashCode())</code>.\n+   *\n+   * @return the String representing this Object, which may be null\n+   * @throws OutOfMemoryError The default implementation creates a new\n+   *         String object, therefore it must allocate memory\n+   * @see #getClass()\n+   * @see #hashCode()\n+   * @see Class#getName()\n+   * @see Integer#toHexString(int)\n+   */\n+  public String toString()\n   {\n     return getClass().getName() + '@' + Integer.toHexString(hashCode());\n   }\n \n-  public final void wait () throws InterruptedException\n+  /**\n+   * Waits indefinitely for notify() or notifyAll() to be\n+   * called on the Object in question.  Implementation is\n+   * identical to wait(0).\n+   *\n+   * <p>The Thread that calls wait must have a lock on this Object,\n+   * obtained by a <code>synchronized</code> method or statement.\n+   * After calling wait, the thread loses the lock on this\n+   * object until the method completes (abruptly or normally),\n+   * at which time it regains the lock.  All locks held on\n+   * other objects remain in force, even though the thread is\n+   * inactive. Therefore, caution must be used to avoid deadlock.\n+   *\n+   * <p>While it is typical that this method will complete abruptly\n+   * with an {@link InterruptedException}, it is not guaranteed.  So,\n+   * it is typical to call wait inside an infinite loop:<br>\n+   *\n+   * <pre>\n+   * try\n+   *   {\n+   *     while (true)\n+   *       lock.wait();\n+   *   }\n+   * catch (InterruptedException e)\n+   *   {\n+   *   }\n+   * </pre>\n+   *\n+   * @throws IllegalMonitorStateException if this Thread\n+   *         does not own a lock on this Object\n+   * @throws InterruptedException if some other Thread\n+   *         interrupts this Thread\n+   * @see #notify()\n+   * @see #notifyAll()\n+   * @see #wait(long)\n+   * @see #wait(long, int)\n+   * @see Thread\n+   */\n+  public final void wait() throws InterruptedException\n   {\n-    wait (0, 0);\n+    wait(0, 0);\n   }\n \n-  public final void wait (long timeout) throws InterruptedException\n+  /**\n+   * Waits a specified amount of time (or indefinitely if\n+   * the time specified is 0) for someone to call notify()\n+   * or notifyAll() on this Object, waking up this Thread.\n+   *\n+   * <p>The Thread that calls wait must have a lock on this Object,\n+   * obtained by a <code>synchronized</code> method or statement.\n+   * After calling wait, the thread loses the lock on this\n+   * object until the method completes (abruptly or normally),\n+   * at which time it regains the lock.  All locks held on\n+   * other objects remain in force, even though the thread is\n+   * inactive. Therefore, caution must be used to avoid deadlock.\n+   *\n+   * <p>Usually, this call will complete normally if the time\n+   * expires, or abruptly with {@link InterruptedException}\n+   * if another thread called notify, but neither result\n+   * is guaranteed.\n+   *\n+   * <p>The waiting period is only *roughly* the amount of time\n+   * you requested.  It cannot be exact because of the overhead\n+   * of the call itself.  Most Virtual Machiness treat the\n+   * argument as a lower limit on the time spent waiting, but\n+   * even that is not guaranteed.  Besides, some other thread\n+   * may hold the lock on the object when the time expires, so\n+   * the current thread may still have to wait to reobtain the\n+   * lock.\n+   *\n+   * @param timeout the minimum number of milliseconds to wait (1000\n+   *        milliseconds = 1 second), or 0 for an indefinite wait\n+   * @throws IllegalArgumentException if ms &lt; 0\n+   * @throws IllegalMonitorStateException if this Thread\n+   *         does not own a lock on this Object\n+   * @throws InterruptedException if some other Thread\n+   *         interrupts this Thread\n+   * @see #notify()\n+   * @see #notifyAll()\n+   * @see #wait()\n+   * @see #wait(long, int)\n+   * @see Thread\n+   */\n+  public final void wait(long timeout) throws InterruptedException\n   {\n-    wait (timeout, 0);\n+    wait(timeout, 0);\n   }\n \n-  protected native Object clone () throws CloneNotSupportedException;\n+  /**\n+   * This method may be called to create a new copy of the\n+   * Object.  The typical behavior is as follows:<br>\n+   * <ul>\n+   *  <li><code>o == o.clone()</code> is false</li>\n+   *  <li><code>o.getClass() == o.clone().getClass()</code>\n+   *      is true</li>\n+   *  <li><code>o.equals(o)</code> is true</li>\n+   * </ul>\n+   *\n+   * <p>However, these are not strict requirements, and may\n+   * be violated if necessary.  Of the three requirements, the\n+   * last is the most commonly violated, particularly if the\n+   * subclass does not override {@link #equals(Object)}.\n+   *\n+   * <p>If the Object you call clone() on does not implement\n+   * {@link Cloneable} (which is a placeholder interface), then\n+   * a CloneNotSupportedException is thrown.  Notice that\n+   * Object does not implement Cloneable; this method exists\n+   * as a convenience for subclasses that do.\n+   *\n+   * <p>Object's implementation of clone allocates space for the\n+   * new Object using the correct class, without calling any\n+   * constructors, and then fills in all of the new field values\n+   * with the old field values.  Thus, it is a shallow copy.\n+   * However, subclasses are permitted to make a deep copy.\n+   *\n+   * <p>All array types implement Cloneable, and override\n+   * this method as follows (it should never fail):<br>\n+   * <pre>\n+   * public Object clone()\n+   * {\n+   *   try\n+   *     {\n+   *       super.clone();\n+   *     }\n+   *   catch (CloneNotSupportedException e)\n+   *     {\n+   *       throw new InternalError(e.getMessage());\n+   *     }\n+   * }\n+   * </pre>\n+   *\n+   * @return a copy of the Object\n+   * @throws CloneNotSupportedException If this Object does not\n+   *         implement Cloneable\n+   * @throws OutOfMemoryError Since cloning involves memory allocation,\n+   *         even though it may bypass constructors, you might run\n+   *         out of memory\n+   * @see Cloneable\n+   */\n+  protected native Object clone() throws CloneNotSupportedException;\n \n   // This initializes the sync_info member.  It is here for\n   // completeness (some day we'll be able to auto-generate Object.h).\n-  private final native void sync_init ();\n+  private final native void sync_init();\n \n   // Note that we don't mention the sync_info field here.  If we do,\n   // jc1 will not work correctly."}]}