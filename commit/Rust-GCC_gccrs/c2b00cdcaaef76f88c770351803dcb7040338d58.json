{"sha": "c2b00cdcaaef76f88c770351803dcb7040338d58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJiMDBjZGNhYWVmNzZmODhjNzcwMzUxODAzZGNiNzA0MDMzOGQ1OA==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2008-08-14T18:31:32Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2008-08-14T18:31:32Z"}, "message": "re PR libfortran/36886 (misaligment for cshift of character)\n\n2008-08-14  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/36886\n\t* Makefile.am:  Added $(i_cshift0_c).\n\tAdded $(i_cshift0_c) to gfor_built_specific_src.\n\tAdd rule to build from cshift0.m4.\n\t* Makefile.in:  Regenerated.\n\t* libgfortran.h:  Addedd prototypes for cshift0_i1,\n\tcshift0_i2, cshift0_i4, cshift0_i8, cshift0_i16,\n\tcshift0_r4, cshift0_r8, cshift0_r10, cshift0_r16,\n\tcshift0_c4, cshift0_c8, cshift0_c10, cshift0_c16.\n\tDefine Macros GFC_UNALIGNED_C4 and GFC_UNALIGNED_C8.\n\t* intrinsics/cshift0.c:  Remove helper functions for\n\tthe innter shift loop.\n\t(cshift0):  Call specific functions depending on type\n\tof array argument.  Only call specific functions for\n\tcorrect alignment for other types.\n\t* m4/cshift0.m4:  New file.\n\t* generated/cshift0_i1.c:  New file.\n\t* generated/cshift0_i2.c:  New file.\n\t* generated/cshift0_i4.c:  New file.\n\t* generated/cshift0_i8:.c  New file.\n\t* generated/cshift0_i16.c:  New file.\n\t* generated/cshift0_r4.c:  New file.\n\t* generated/cshift0_r8.c:  New file.\n\t* generated/cshift0_r10.c:  New file.\n\t* generated/cshift0_r16.c:  New file.\n\t* generated/cshift0_c4.c:  New file.\n\t* generated/cshift0_c8.c:  New file.\n\t* generated/cshift0_c10.c:  New file.\n\t* generated/cshift0_c16.c:  New file.\n\n2008-08-14  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/36886\n\t* gfortran.dg/cshift_char_3.f90:  New test case.\n\t* gfortran.dg/cshift_nan_1.f90:  New test case.\n\nFrom-SVN: r139111", "tree": {"sha": "85eb8b641f01c373a1ab8b4253e57f255f52349f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85eb8b641f01c373a1ab8b4253e57f255f52349f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2b00cdcaaef76f88c770351803dcb7040338d58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2b00cdcaaef76f88c770351803dcb7040338d58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2b00cdcaaef76f88c770351803dcb7040338d58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2b00cdcaaef76f88c770351803dcb7040338d58/comments", "author": null, "committer": null, "parents": [{"sha": "6eefb96d4696ef15f07639bb232c1d3acfb20ea9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eefb96d4696ef15f07639bb232c1d3acfb20ea9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6eefb96d4696ef15f07639bb232c1d3acfb20ea9"}], "stats": {"total": 3090, "additions": 2957, "deletions": 133}, "files": [{"sha": "1947b43aee80d104203731b1f78c08944570cb5d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -1,3 +1,9 @@\n+2008-08-14  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/36886\n+\t* gfortran.dg/cshift_char_3.f90:  New test case.\n+\t* gfortran.dg/cshift_nan_1.f90:  New test case.\n+\n 2008-08-14  Rafael Avila de Espindola  <espindola@google.com>\n \n \t* gcc.dg/visibility-14.c: New test."}, {"sha": "80c0ede3a27d613a8e8b76f412167d88187f19e8", "filename": "gcc/testsuite/gfortran.dg/char_cshift_3.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_cshift_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_cshift_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_cshift_3.f90?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do run }\n+! PR 36886 - misalignment of characters for cshift could cause\n+! problems on some architectures.\n+program main\n+  character(len=2) :: c2\n+  character(len=4), dimension(2,2) :: a, b, c, d\n+  ! Force misalignment of a or b\n+  common /foo/ a, c, c2, b, d\n+  a = 'aa'\n+  b = 'bb'\n+  d = cshift(b,1)\n+  c = cshift(a,1)\n+end program main"}, {"sha": "896ecb3a4e11b29f0732587a2cbd117fa277c4c7", "filename": "gcc/testsuite/gfortran.dg/cshift_nan_1.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_nan_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_nan_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcshift_nan_1.f90?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -0,0 +1,24 @@\n+! { dg-do run }\n+! Test cshift where the values are eight bytes,\n+! but are aligned on a four-byte boundary.  The\n+! integers correspond to NaN values.\n+program main\n+  implicit none\n+  integer :: i\n+  type t\n+     sequence\n+     integer :: a,b\n+  end type t\n+  type(t), dimension(4) :: u,v\n+  common /foo/ u, i, v\n+\n+  u(1)%a = 2142240768\n+  u(2)%a = 2144337920\n+  u(3)%a = -5242880\n+  u(4)%a = -3145728\n+  u%b = (/(i,i=-1,-4,-1)/)\n+  v(1:3:2) = cshift(u(1:3:2),1)\n+  v(2:4:2) = cshift(u(2:4:2),-1)\n+  if (any(v%a /= (/-5242880, -3145728, 2142240768, 2144337920 /))) call abort\n+  if (any(v%b /= (/-3, -4, -1, -2/))) call abort\n+end program main"}, {"sha": "3131fa3ceb5a6f19f5f1388a3fa4a2affc86454b", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -1,3 +1,35 @@\n+2008-08-14  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/36886\n+\t* Makefile.am:  Added $(i_cshift0_c).\n+\tAdded $(i_cshift0_c) to gfor_built_specific_src.\n+\tAdd rule to build from cshift0.m4.\n+\t* Makefile.in:  Regenerated.\n+\t* libgfortran.h:  Addedd prototypes for cshift0_i1,\n+\tcshift0_i2, cshift0_i4, cshift0_i8, cshift0_i16,\n+\tcshift0_r4, cshift0_r8, cshift0_r10, cshift0_r16,\n+\tcshift0_c4, cshift0_c8, cshift0_c10, cshift0_c16.\n+\tDefine Macros GFC_UNALIGNED_C4 and GFC_UNALIGNED_C8.\n+\t* intrinsics/cshift0.c:  Remove helper functions for\n+\tthe innter shift loop.\n+\t(cshift0):  Call specific functions depending on type\n+\tof array argument.  Only call specific functions for\n+\tcorrect alignment for other types.\n+\t* m4/cshift0.m4:  New file.\n+\t* generated/cshift0_i1.c:  New file.\n+\t* generated/cshift0_i2.c:  New file.\n+\t* generated/cshift0_i4.c:  New file.\n+\t* generated/cshift0_i8:.c  New file.\n+\t* generated/cshift0_i16.c:  New file.\n+\t* generated/cshift0_r4.c:  New file.\n+\t* generated/cshift0_r8.c:  New file.\n+\t* generated/cshift0_r10.c:  New file.\n+\t* generated/cshift0_r16.c:  New file.\n+\t* generated/cshift0_c4.c:  New file.\n+\t* generated/cshift0_c8.c:  New file.\n+\t* generated/cshift0_c10.c:  New file.\n+\t* generated/cshift0_c16.c:  New file.\n+\n 2008-07-27  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/36132"}, {"sha": "2223d61fcf2ba6de062f6e120f790715f19cb769", "filename": "libgfortran/Makefile.am", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.am?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -379,6 +379,22 @@ $(srcdir)/generated/eoshift3_4.c \\\n $(srcdir)/generated/eoshift3_8.c \\\n $(srcdir)/generated/eoshift3_16.c\n \n+i_cshift0_c= \\\n+$(srcdir)/generated/cshift0_i1.c \\\n+$(srcdir)/generated/cshift0_i2.c \\\n+$(srcdir)/generated/cshift0_i4.c \\\n+$(srcdir)/generated/cshift0_i8.c \\\n+$(srcdir)/generated/cshift0_i16.c \\\n+$(srcdir)/generated/cshift0_r4.c \\\n+$(srcdir)/generated/cshift0_r8.c \\\n+$(srcdir)/generated/cshift0_r10.c \\\n+$(srcdir)/generated/cshift0_r16.c \\\n+$(srcdir)/generated/cshift0_c4.c \\\n+$(srcdir)/generated/cshift0_c8.c \\\n+$(srcdir)/generated/cshift0_c10.c \\\n+$(srcdir)/generated/cshift0_c16.c\n+ \n+\n i_cshift1_c= \\\n $(srcdir)/generated/cshift1_4.c \\\n $(srcdir)/generated/cshift1_8.c \\\n@@ -545,7 +561,7 @@ gfor_built_src= $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_exponent_c) $(i_fraction_c) $(i_nearest_c) $(i_set_exponent_c) \\\n     $(i_pow_c) $(i_rrspacing_c) $(i_spacing_c) $(i_pack_c) $(i_unpack_c) \\\n     $(i_spread_c) selected_int_kind.inc selected_real_kind.inc kinds.h \\\n-    kinds.inc c99_protos.inc fpu-target.h\n+    $(i_cshift0_c) kinds.inc c99_protos.inc fpu-target.h\n \n # Machine generated specifics\n gfor_built_specific_src= \\\n@@ -829,6 +845,9 @@ $(i_eoshift1_c): m4/eoshift1.m4 $(I_M4_DEPS)\n $(i_eoshift3_c): m4/eoshift3.m4 $(I_M4_DEPS)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 eoshift3.m4 > $@\n \n+$(i_cshift0_c): m4/cshift0.m4 $(I_M4_DEPS)\n+\t$(M4) -Dfile=$@ -I$(srcdir)/m4 cshift0.m4 > $@\n+\n $(i_cshift1_c): m4/cshift1.m4 $(I_M4_DEPS)\n \t$(M4) -Dfile=$@ -I$(srcdir)/m4 cshift1.m4 > $@\n "}, {"sha": "4f5183016215051b81052b62fb19a1f1750e3822", "filename": "libgfortran/Makefile.in", "status": "modified", "additions": 153, "deletions": 14, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FMakefile.in?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -397,7 +397,20 @@ am__libgfortran_la_SOURCES_DIST = runtime/backtrace.c \\\n \t$(srcdir)/generated/spread_c8.c \\\n \t$(srcdir)/generated/spread_c10.c \\\n \t$(srcdir)/generated/spread_c16.c selected_int_kind.inc \\\n-\tselected_real_kind.inc kinds.h kinds.inc c99_protos.inc \\\n+\tselected_real_kind.inc kinds.h \\\n+\t$(srcdir)/generated/cshift0_i1.c \\\n+\t$(srcdir)/generated/cshift0_i2.c \\\n+\t$(srcdir)/generated/cshift0_i4.c \\\n+\t$(srcdir)/generated/cshift0_i8.c \\\n+\t$(srcdir)/generated/cshift0_i16.c \\\n+\t$(srcdir)/generated/cshift0_r4.c \\\n+\t$(srcdir)/generated/cshift0_r8.c \\\n+\t$(srcdir)/generated/cshift0_r10.c \\\n+\t$(srcdir)/generated/cshift0_r16.c \\\n+\t$(srcdir)/generated/cshift0_c4.c \\\n+\t$(srcdir)/generated/cshift0_c8.c \\\n+\t$(srcdir)/generated/cshift0_c10.c \\\n+\t$(srcdir)/generated/cshift0_c16.c kinds.inc c99_protos.inc \\\n \tfpu-target.h io/close.c io/file_pos.c io/format.c io/inquire.c \\\n \tio/intrinsics.c io/list_read.c io/lock.c io/open.c io/read.c \\\n \tio/size_from_kind.c io/transfer.c io/unit.c io/unix.c \\\n@@ -679,7 +692,11 @@ am__objects_32 = spread_i1.lo spread_i2.lo spread_i4.lo spread_i8.lo \\\n \tspread_i16.lo spread_r4.lo spread_r8.lo spread_r10.lo \\\n \tspread_r16.lo spread_c4.lo spread_c8.lo spread_c10.lo \\\n \tspread_c16.lo\n-am__objects_33 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \\\n+am__objects_33 = cshift0_i1.lo cshift0_i2.lo cshift0_i4.lo \\\n+\tcshift0_i8.lo cshift0_i16.lo cshift0_r4.lo cshift0_r8.lo \\\n+\tcshift0_r10.lo cshift0_r16.lo cshift0_c4.lo cshift0_c8.lo \\\n+\tcshift0_c10.lo cshift0_c16.lo\n+am__objects_34 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \\\n \t$(am__objects_5) $(am__objects_6) $(am__objects_7) \\\n \t$(am__objects_8) $(am__objects_9) $(am__objects_10) \\\n \t$(am__objects_11) $(am__objects_12) $(am__objects_13) \\\n@@ -689,11 +706,11 @@ am__objects_33 = $(am__objects_2) $(am__objects_3) $(am__objects_4) \\\n \t$(am__objects_23) $(am__objects_24) $(am__objects_25) \\\n \t$(am__objects_26) $(am__objects_27) $(am__objects_28) \\\n \t$(am__objects_29) $(am__objects_30) $(am__objects_31) \\\n-\t$(am__objects_32)\n-am__objects_34 = close.lo file_pos.lo format.lo inquire.lo \\\n+\t$(am__objects_32) $(am__objects_33)\n+am__objects_35 = close.lo file_pos.lo format.lo inquire.lo \\\n \tintrinsics.lo list_read.lo lock.lo open.lo read.lo \\\n \tsize_from_kind.lo transfer.lo unit.lo unix.lo write.lo fbuf.lo\n-am__objects_35 = associated.lo abort.lo access.lo args.lo \\\n+am__objects_36 = associated.lo abort.lo access.lo args.lo \\\n \tc99_functions.lo chdir.lo chmod.lo clock.lo cpu_time.lo \\\n \tcshift0.lo ctime.lo date_and_time.lo dtime.lo env.lo \\\n \teoshift0.lo eoshift2.lo erfc_scaled.lo etime.lo exit.lo \\\n@@ -707,8 +724,8 @@ am__objects_35 = associated.lo abort.lo access.lo args.lo \\\n \tstat.lo symlnk.lo system_clock.lo time.lo transpose_generic.lo \\\n \tumask.lo unlink.lo unpack_generic.lo in_pack_generic.lo \\\n \tin_unpack_generic.lo\n-am__objects_36 =\n-am__objects_37 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n+am__objects_37 =\n+am__objects_38 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_abs_i4.lo _abs_i8.lo _abs_i16.lo _abs_r4.lo _abs_r8.lo \\\n \t_abs_r10.lo _abs_r16.lo _aimag_c4.lo _aimag_c8.lo \\\n \t_aimag_c10.lo _aimag_c16.lo _exp_r4.lo _exp_r8.lo _exp_r10.lo \\\n@@ -732,18 +749,18 @@ am__objects_37 = _abs_c4.lo _abs_c8.lo _abs_c10.lo _abs_c16.lo \\\n \t_conjg_c4.lo _conjg_c8.lo _conjg_c10.lo _conjg_c16.lo \\\n \t_aint_r4.lo _aint_r8.lo _aint_r10.lo _aint_r16.lo _anint_r4.lo \\\n \t_anint_r8.lo _anint_r10.lo _anint_r16.lo\n-am__objects_38 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n+am__objects_39 = _sign_i4.lo _sign_i8.lo _sign_i16.lo _sign_r4.lo \\\n \t_sign_r8.lo _sign_r10.lo _sign_r16.lo _dim_i4.lo _dim_i8.lo \\\n \t_dim_i16.lo _dim_r4.lo _dim_r8.lo _dim_r10.lo _dim_r16.lo \\\n \t_atan2_r4.lo _atan2_r8.lo _atan2_r10.lo _atan2_r16.lo \\\n \t_mod_i4.lo _mod_i8.lo _mod_i16.lo _mod_r4.lo _mod_r8.lo \\\n \t_mod_r10.lo _mod_r16.lo\n-am__objects_39 = misc_specifics.lo\n-am__objects_40 = $(am__objects_37) $(am__objects_38) $(am__objects_39) \\\n+am__objects_40 = misc_specifics.lo\n+am__objects_41 = $(am__objects_38) $(am__objects_39) $(am__objects_40) \\\n \tdprod_r8.lo f2c_specifics.lo\n-am__objects_41 = $(am__objects_1) $(am__objects_33) $(am__objects_34) \\\n-\t$(am__objects_35) $(am__objects_36) $(am__objects_40)\n-@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_41)\n+am__objects_42 = $(am__objects_1) $(am__objects_34) $(am__objects_35) \\\n+\t$(am__objects_36) $(am__objects_37) $(am__objects_41)\n+@onestep_FALSE@am_libgfortran_la_OBJECTS = $(am__objects_42)\n @onestep_TRUE@am_libgfortran_la_OBJECTS = libgfortran_c.lo\n libgfortran_la_OBJECTS = $(am_libgfortran_la_OBJECTS)\n libgfortranbegin_la_LIBADD =\n@@ -1279,6 +1296,21 @@ $(srcdir)/generated/eoshift3_4.c \\\n $(srcdir)/generated/eoshift3_8.c \\\n $(srcdir)/generated/eoshift3_16.c\n \n+i_cshift0_c = \\\n+$(srcdir)/generated/cshift0_i1.c \\\n+$(srcdir)/generated/cshift0_i2.c \\\n+$(srcdir)/generated/cshift0_i4.c \\\n+$(srcdir)/generated/cshift0_i8.c \\\n+$(srcdir)/generated/cshift0_i16.c \\\n+$(srcdir)/generated/cshift0_r4.c \\\n+$(srcdir)/generated/cshift0_r8.c \\\n+$(srcdir)/generated/cshift0_r10.c \\\n+$(srcdir)/generated/cshift0_r16.c \\\n+$(srcdir)/generated/cshift0_c4.c \\\n+$(srcdir)/generated/cshift0_c8.c \\\n+$(srcdir)/generated/cshift0_c10.c \\\n+$(srcdir)/generated/cshift0_c16.c\n+\n i_cshift1_c = \\\n $(srcdir)/generated/cshift1_4.c \\\n $(srcdir)/generated/cshift1_8.c \\\n@@ -1445,7 +1477,7 @@ gfor_built_src = $(i_all_c) $(i_any_c) $(i_count_c) $(i_maxloc0_c) \\\n     $(i_exponent_c) $(i_fraction_c) $(i_nearest_c) $(i_set_exponent_c) \\\n     $(i_pow_c) $(i_rrspacing_c) $(i_spacing_c) $(i_pack_c) $(i_unpack_c) \\\n     $(i_spread_c) selected_int_kind.inc selected_real_kind.inc kinds.h \\\n-    kinds.inc c99_protos.inc fpu-target.h\n+    $(i_cshift0_c) kinds.inc c99_protos.inc fpu-target.h\n \n \n # Machine generated specifics\n@@ -1771,6 +1803,19 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/count_8_l.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cpu_time.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift0.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift0_c10.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift0_c16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift0_c4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift0_c8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift0_i1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift0_i16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift0_i2.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift0_i4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift0_i8.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift0_r10.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift0_r16.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift0_r4.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift0_r8.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_16.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_4.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cshift1_8.Plo@am__quote@\n@@ -5038,6 +5083,97 @@ spread_c16.lo: $(srcdir)/generated/spread_c16.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o spread_c16.lo `test -f '$(srcdir)/generated/spread_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/spread_c16.c\n \n+cshift0_i1.lo: $(srcdir)/generated/cshift0_i1.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift0_i1.lo -MD -MP -MF \"$(DEPDIR)/cshift0_i1.Tpo\" -c -o cshift0_i1.lo `test -f '$(srcdir)/generated/cshift0_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_i1.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/cshift0_i1.Tpo\" \"$(DEPDIR)/cshift0_i1.Plo\"; else rm -f \"$(DEPDIR)/cshift0_i1.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift0_i1.c' object='cshift0_i1.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift0_i1.lo `test -f '$(srcdir)/generated/cshift0_i1.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_i1.c\n+\n+cshift0_i2.lo: $(srcdir)/generated/cshift0_i2.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift0_i2.lo -MD -MP -MF \"$(DEPDIR)/cshift0_i2.Tpo\" -c -o cshift0_i2.lo `test -f '$(srcdir)/generated/cshift0_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_i2.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/cshift0_i2.Tpo\" \"$(DEPDIR)/cshift0_i2.Plo\"; else rm -f \"$(DEPDIR)/cshift0_i2.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift0_i2.c' object='cshift0_i2.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift0_i2.lo `test -f '$(srcdir)/generated/cshift0_i2.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_i2.c\n+\n+cshift0_i4.lo: $(srcdir)/generated/cshift0_i4.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift0_i4.lo -MD -MP -MF \"$(DEPDIR)/cshift0_i4.Tpo\" -c -o cshift0_i4.lo `test -f '$(srcdir)/generated/cshift0_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_i4.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/cshift0_i4.Tpo\" \"$(DEPDIR)/cshift0_i4.Plo\"; else rm -f \"$(DEPDIR)/cshift0_i4.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift0_i4.c' object='cshift0_i4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift0_i4.lo `test -f '$(srcdir)/generated/cshift0_i4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_i4.c\n+\n+cshift0_i8.lo: $(srcdir)/generated/cshift0_i8.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift0_i8.lo -MD -MP -MF \"$(DEPDIR)/cshift0_i8.Tpo\" -c -o cshift0_i8.lo `test -f '$(srcdir)/generated/cshift0_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_i8.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/cshift0_i8.Tpo\" \"$(DEPDIR)/cshift0_i8.Plo\"; else rm -f \"$(DEPDIR)/cshift0_i8.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift0_i8.c' object='cshift0_i8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift0_i8.lo `test -f '$(srcdir)/generated/cshift0_i8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_i8.c\n+\n+cshift0_i16.lo: $(srcdir)/generated/cshift0_i16.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift0_i16.lo -MD -MP -MF \"$(DEPDIR)/cshift0_i16.Tpo\" -c -o cshift0_i16.lo `test -f '$(srcdir)/generated/cshift0_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_i16.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/cshift0_i16.Tpo\" \"$(DEPDIR)/cshift0_i16.Plo\"; else rm -f \"$(DEPDIR)/cshift0_i16.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift0_i16.c' object='cshift0_i16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift0_i16.lo `test -f '$(srcdir)/generated/cshift0_i16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_i16.c\n+\n+cshift0_r4.lo: $(srcdir)/generated/cshift0_r4.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift0_r4.lo -MD -MP -MF \"$(DEPDIR)/cshift0_r4.Tpo\" -c -o cshift0_r4.lo `test -f '$(srcdir)/generated/cshift0_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_r4.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/cshift0_r4.Tpo\" \"$(DEPDIR)/cshift0_r4.Plo\"; else rm -f \"$(DEPDIR)/cshift0_r4.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift0_r4.c' object='cshift0_r4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift0_r4.lo `test -f '$(srcdir)/generated/cshift0_r4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_r4.c\n+\n+cshift0_r8.lo: $(srcdir)/generated/cshift0_r8.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift0_r8.lo -MD -MP -MF \"$(DEPDIR)/cshift0_r8.Tpo\" -c -o cshift0_r8.lo `test -f '$(srcdir)/generated/cshift0_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_r8.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/cshift0_r8.Tpo\" \"$(DEPDIR)/cshift0_r8.Plo\"; else rm -f \"$(DEPDIR)/cshift0_r8.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift0_r8.c' object='cshift0_r8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift0_r8.lo `test -f '$(srcdir)/generated/cshift0_r8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_r8.c\n+\n+cshift0_r10.lo: $(srcdir)/generated/cshift0_r10.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift0_r10.lo -MD -MP -MF \"$(DEPDIR)/cshift0_r10.Tpo\" -c -o cshift0_r10.lo `test -f '$(srcdir)/generated/cshift0_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_r10.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/cshift0_r10.Tpo\" \"$(DEPDIR)/cshift0_r10.Plo\"; else rm -f \"$(DEPDIR)/cshift0_r10.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift0_r10.c' object='cshift0_r10.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift0_r10.lo `test -f '$(srcdir)/generated/cshift0_r10.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_r10.c\n+\n+cshift0_r16.lo: $(srcdir)/generated/cshift0_r16.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift0_r16.lo -MD -MP -MF \"$(DEPDIR)/cshift0_r16.Tpo\" -c -o cshift0_r16.lo `test -f '$(srcdir)/generated/cshift0_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_r16.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/cshift0_r16.Tpo\" \"$(DEPDIR)/cshift0_r16.Plo\"; else rm -f \"$(DEPDIR)/cshift0_r16.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift0_r16.c' object='cshift0_r16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift0_r16.lo `test -f '$(srcdir)/generated/cshift0_r16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_r16.c\n+\n+cshift0_c4.lo: $(srcdir)/generated/cshift0_c4.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift0_c4.lo -MD -MP -MF \"$(DEPDIR)/cshift0_c4.Tpo\" -c -o cshift0_c4.lo `test -f '$(srcdir)/generated/cshift0_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_c4.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/cshift0_c4.Tpo\" \"$(DEPDIR)/cshift0_c4.Plo\"; else rm -f \"$(DEPDIR)/cshift0_c4.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift0_c4.c' object='cshift0_c4.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift0_c4.lo `test -f '$(srcdir)/generated/cshift0_c4.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_c4.c\n+\n+cshift0_c8.lo: $(srcdir)/generated/cshift0_c8.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift0_c8.lo -MD -MP -MF \"$(DEPDIR)/cshift0_c8.Tpo\" -c -o cshift0_c8.lo `test -f '$(srcdir)/generated/cshift0_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_c8.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/cshift0_c8.Tpo\" \"$(DEPDIR)/cshift0_c8.Plo\"; else rm -f \"$(DEPDIR)/cshift0_c8.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift0_c8.c' object='cshift0_c8.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift0_c8.lo `test -f '$(srcdir)/generated/cshift0_c8.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_c8.c\n+\n+cshift0_c10.lo: $(srcdir)/generated/cshift0_c10.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift0_c10.lo -MD -MP -MF \"$(DEPDIR)/cshift0_c10.Tpo\" -c -o cshift0_c10.lo `test -f '$(srcdir)/generated/cshift0_c10.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_c10.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/cshift0_c10.Tpo\" \"$(DEPDIR)/cshift0_c10.Plo\"; else rm -f \"$(DEPDIR)/cshift0_c10.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift0_c10.c' object='cshift0_c10.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift0_c10.lo `test -f '$(srcdir)/generated/cshift0_c10.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_c10.c\n+\n+cshift0_c16.lo: $(srcdir)/generated/cshift0_c16.c\n+@am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT cshift0_c16.lo -MD -MP -MF \"$(DEPDIR)/cshift0_c16.Tpo\" -c -o cshift0_c16.lo `test -f '$(srcdir)/generated/cshift0_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_c16.c; \\\n+@am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/cshift0_c16.Tpo\" \"$(DEPDIR)/cshift0_c16.Plo\"; else rm -f \"$(DEPDIR)/cshift0_c16.Tpo\"; exit 1; fi\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$(srcdir)/generated/cshift0_c16.c' object='cshift0_c16.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o cshift0_c16.lo `test -f '$(srcdir)/generated/cshift0_c16.c' || echo '$(srcdir)/'`$(srcdir)/generated/cshift0_c16.c\n+\n close.lo: io/close.c\n @am__fastdepCC_TRUE@\tif $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT close.lo -MD -MP -MF \"$(DEPDIR)/close.Tpo\" -c -o close.lo `test -f 'io/close.c' || echo '$(srcdir)/'`io/close.c; \\\n @am__fastdepCC_TRUE@\tthen mv -f \"$(DEPDIR)/close.Tpo\" \"$(DEPDIR)/close.Plo\"; else rm -f \"$(DEPDIR)/close.Tpo\"; exit 1; fi\n@@ -5973,6 +6109,9 @@ fpu-target.h: $(srcdir)/$(FPU_HOST_HEADER)\n @MAINTAINER_MODE_TRUE@$(i_eoshift3_c): m4/eoshift3.m4 $(I_M4_DEPS)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 eoshift3.m4 > $@\n \n+@MAINTAINER_MODE_TRUE@$(i_cshift0_c): m4/cshift0.m4 $(I_M4_DEPS)\n+@MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 cshift0.m4 > $@\n+\n @MAINTAINER_MODE_TRUE@$(i_cshift1_c): m4/cshift1.m4 $(I_M4_DEPS)\n @MAINTAINER_MODE_TRUE@\t$(M4) -Dfile=$@ -I$(srcdir)/m4 cshift1.m4 > $@\n "}, {"sha": "9f0997044d2fa88d7ba064788fa7d2097924bd02", "filename": "libgfortran/generated/cshift0_c10.c", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_c10.c?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -0,0 +1,176 @@\n+/* Helper function for cshift functions.\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_10)\n+\n+void\n+cshift0_c10 (gfc_array_c10 *ret, const gfc_array_c10 *array, ssize_t shift,\n+\t\t     int which)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_COMPLEX_10 *rptr;\n+\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_COMPLEX_10 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+\n+  which = which - 1;\n+  sstride[0] = 0;\n+  rstride[0] = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = ret->dim[dim].stride;\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = array->dim[dim].stride;\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          rstride[n] = ret->dim[dim].stride;\n+          sstride[n] = array->dim[dim].stride;\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  rptr = ret->data;\n+  sptr = array->data;\n+\n+  shift = len == 0 ? 0 : shift % (ssize_t)len;\n+  if (shift < 0)\n+    shift += len;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+\n+      /* If elements are contiguous, perform the operation\n+\t in two block moves.  */\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = shift * sizeof (GFC_COMPLEX_10);\n+\t  size_t len2 = (len - shift) * sizeof (GFC_COMPLEX_10);\n+\t  memcpy (rptr, sptr + shift, len2);\n+\t  memcpy (rptr + (len - shift), sptr, len1);\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, we will have to perform the copy one element at\n+\t     a time.  */\n+\t  GFC_COMPLEX_10 *dest = rptr;\n+\t  const GFC_COMPLEX_10 *src = &sptr[shift * soffset];\n+\n+\t  for (n = 0; n < len - shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          sptr -= sstride[n] * extent[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+            }\n+        }\n+    }\n+\n+  return;\n+}\n+\n+#endif"}, {"sha": "deabe262937ac375c80e7f298d2c91034ef72c13", "filename": "libgfortran/generated/cshift0_c16.c", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_c16.c?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -0,0 +1,176 @@\n+/* Helper function for cshift functions.\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_16)\n+\n+void\n+cshift0_c16 (gfc_array_c16 *ret, const gfc_array_c16 *array, ssize_t shift,\n+\t\t     int which)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_COMPLEX_16 *rptr;\n+\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_COMPLEX_16 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+\n+  which = which - 1;\n+  sstride[0] = 0;\n+  rstride[0] = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = ret->dim[dim].stride;\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = array->dim[dim].stride;\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          rstride[n] = ret->dim[dim].stride;\n+          sstride[n] = array->dim[dim].stride;\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  rptr = ret->data;\n+  sptr = array->data;\n+\n+  shift = len == 0 ? 0 : shift % (ssize_t)len;\n+  if (shift < 0)\n+    shift += len;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+\n+      /* If elements are contiguous, perform the operation\n+\t in two block moves.  */\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = shift * sizeof (GFC_COMPLEX_16);\n+\t  size_t len2 = (len - shift) * sizeof (GFC_COMPLEX_16);\n+\t  memcpy (rptr, sptr + shift, len2);\n+\t  memcpy (rptr + (len - shift), sptr, len1);\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, we will have to perform the copy one element at\n+\t     a time.  */\n+\t  GFC_COMPLEX_16 *dest = rptr;\n+\t  const GFC_COMPLEX_16 *src = &sptr[shift * soffset];\n+\n+\t  for (n = 0; n < len - shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          sptr -= sstride[n] * extent[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+            }\n+        }\n+    }\n+\n+  return;\n+}\n+\n+#endif"}, {"sha": "462169f9a267c19d6cd249e642e490c804929cfd", "filename": "libgfortran/generated/cshift0_c4.c", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_c4.c?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -0,0 +1,176 @@\n+/* Helper function for cshift functions.\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_4)\n+\n+void\n+cshift0_c4 (gfc_array_c4 *ret, const gfc_array_c4 *array, ssize_t shift,\n+\t\t     int which)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_COMPLEX_4 *rptr;\n+\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_COMPLEX_4 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+\n+  which = which - 1;\n+  sstride[0] = 0;\n+  rstride[0] = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = ret->dim[dim].stride;\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = array->dim[dim].stride;\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          rstride[n] = ret->dim[dim].stride;\n+          sstride[n] = array->dim[dim].stride;\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  rptr = ret->data;\n+  sptr = array->data;\n+\n+  shift = len == 0 ? 0 : shift % (ssize_t)len;\n+  if (shift < 0)\n+    shift += len;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+\n+      /* If elements are contiguous, perform the operation\n+\t in two block moves.  */\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = shift * sizeof (GFC_COMPLEX_4);\n+\t  size_t len2 = (len - shift) * sizeof (GFC_COMPLEX_4);\n+\t  memcpy (rptr, sptr + shift, len2);\n+\t  memcpy (rptr + (len - shift), sptr, len1);\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, we will have to perform the copy one element at\n+\t     a time.  */\n+\t  GFC_COMPLEX_4 *dest = rptr;\n+\t  const GFC_COMPLEX_4 *src = &sptr[shift * soffset];\n+\n+\t  for (n = 0; n < len - shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          sptr -= sstride[n] * extent[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+            }\n+        }\n+    }\n+\n+  return;\n+}\n+\n+#endif"}, {"sha": "0653e1d3f0d6e52ad128fa6f766e9059719ba8b0", "filename": "libgfortran/generated/cshift0_c8.c", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_c8.c?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -0,0 +1,176 @@\n+/* Helper function for cshift functions.\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_COMPLEX_8)\n+\n+void\n+cshift0_c8 (gfc_array_c8 *ret, const gfc_array_c8 *array, ssize_t shift,\n+\t\t     int which)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_COMPLEX_8 *rptr;\n+\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_COMPLEX_8 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+\n+  which = which - 1;\n+  sstride[0] = 0;\n+  rstride[0] = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = ret->dim[dim].stride;\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = array->dim[dim].stride;\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          rstride[n] = ret->dim[dim].stride;\n+          sstride[n] = array->dim[dim].stride;\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  rptr = ret->data;\n+  sptr = array->data;\n+\n+  shift = len == 0 ? 0 : shift % (ssize_t)len;\n+  if (shift < 0)\n+    shift += len;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+\n+      /* If elements are contiguous, perform the operation\n+\t in two block moves.  */\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = shift * sizeof (GFC_COMPLEX_8);\n+\t  size_t len2 = (len - shift) * sizeof (GFC_COMPLEX_8);\n+\t  memcpy (rptr, sptr + shift, len2);\n+\t  memcpy (rptr + (len - shift), sptr, len1);\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, we will have to perform the copy one element at\n+\t     a time.  */\n+\t  GFC_COMPLEX_8 *dest = rptr;\n+\t  const GFC_COMPLEX_8 *src = &sptr[shift * soffset];\n+\n+\t  for (n = 0; n < len - shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          sptr -= sstride[n] * extent[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+            }\n+        }\n+    }\n+\n+  return;\n+}\n+\n+#endif"}, {"sha": "c21d75ebe5e1d53c5bd444b30138603c2b77a5a3", "filename": "libgfortran/generated/cshift0_i1.c", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_i1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_i1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_i1.c?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -0,0 +1,176 @@\n+/* Helper function for cshift functions.\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_1)\n+\n+void\n+cshift0_i1 (gfc_array_i1 *ret, const gfc_array_i1 *array, ssize_t shift,\n+\t\t     int which)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_INTEGER_1 *rptr;\n+\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_INTEGER_1 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+\n+  which = which - 1;\n+  sstride[0] = 0;\n+  rstride[0] = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = ret->dim[dim].stride;\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = array->dim[dim].stride;\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          rstride[n] = ret->dim[dim].stride;\n+          sstride[n] = array->dim[dim].stride;\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  rptr = ret->data;\n+  sptr = array->data;\n+\n+  shift = len == 0 ? 0 : shift % (ssize_t)len;\n+  if (shift < 0)\n+    shift += len;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+\n+      /* If elements are contiguous, perform the operation\n+\t in two block moves.  */\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = shift * sizeof (GFC_INTEGER_1);\n+\t  size_t len2 = (len - shift) * sizeof (GFC_INTEGER_1);\n+\t  memcpy (rptr, sptr + shift, len2);\n+\t  memcpy (rptr + (len - shift), sptr, len1);\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, we will have to perform the copy one element at\n+\t     a time.  */\n+\t  GFC_INTEGER_1 *dest = rptr;\n+\t  const GFC_INTEGER_1 *src = &sptr[shift * soffset];\n+\n+\t  for (n = 0; n < len - shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          sptr -= sstride[n] * extent[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+            }\n+        }\n+    }\n+\n+  return;\n+}\n+\n+#endif"}, {"sha": "e2c88f461af48c740f078efe063262b1dbeebc60", "filename": "libgfortran/generated/cshift0_i16.c", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_i16.c?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -0,0 +1,176 @@\n+/* Helper function for cshift functions.\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_16)\n+\n+void\n+cshift0_i16 (gfc_array_i16 *ret, const gfc_array_i16 *array, ssize_t shift,\n+\t\t     int which)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_INTEGER_16 *rptr;\n+\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_INTEGER_16 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+\n+  which = which - 1;\n+  sstride[0] = 0;\n+  rstride[0] = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = ret->dim[dim].stride;\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = array->dim[dim].stride;\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          rstride[n] = ret->dim[dim].stride;\n+          sstride[n] = array->dim[dim].stride;\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  rptr = ret->data;\n+  sptr = array->data;\n+\n+  shift = len == 0 ? 0 : shift % (ssize_t)len;\n+  if (shift < 0)\n+    shift += len;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+\n+      /* If elements are contiguous, perform the operation\n+\t in two block moves.  */\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = shift * sizeof (GFC_INTEGER_16);\n+\t  size_t len2 = (len - shift) * sizeof (GFC_INTEGER_16);\n+\t  memcpy (rptr, sptr + shift, len2);\n+\t  memcpy (rptr + (len - shift), sptr, len1);\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, we will have to perform the copy one element at\n+\t     a time.  */\n+\t  GFC_INTEGER_16 *dest = rptr;\n+\t  const GFC_INTEGER_16 *src = &sptr[shift * soffset];\n+\n+\t  for (n = 0; n < len - shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          sptr -= sstride[n] * extent[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+            }\n+        }\n+    }\n+\n+  return;\n+}\n+\n+#endif"}, {"sha": "ec2ea1d8b6bcdb5d09a01dc2f91e1190fbf5664c", "filename": "libgfortran/generated/cshift0_i2.c", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_i2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_i2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_i2.c?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -0,0 +1,176 @@\n+/* Helper function for cshift functions.\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_2)\n+\n+void\n+cshift0_i2 (gfc_array_i2 *ret, const gfc_array_i2 *array, ssize_t shift,\n+\t\t     int which)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_INTEGER_2 *rptr;\n+\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_INTEGER_2 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+\n+  which = which - 1;\n+  sstride[0] = 0;\n+  rstride[0] = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = ret->dim[dim].stride;\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = array->dim[dim].stride;\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          rstride[n] = ret->dim[dim].stride;\n+          sstride[n] = array->dim[dim].stride;\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  rptr = ret->data;\n+  sptr = array->data;\n+\n+  shift = len == 0 ? 0 : shift % (ssize_t)len;\n+  if (shift < 0)\n+    shift += len;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+\n+      /* If elements are contiguous, perform the operation\n+\t in two block moves.  */\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = shift * sizeof (GFC_INTEGER_2);\n+\t  size_t len2 = (len - shift) * sizeof (GFC_INTEGER_2);\n+\t  memcpy (rptr, sptr + shift, len2);\n+\t  memcpy (rptr + (len - shift), sptr, len1);\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, we will have to perform the copy one element at\n+\t     a time.  */\n+\t  GFC_INTEGER_2 *dest = rptr;\n+\t  const GFC_INTEGER_2 *src = &sptr[shift * soffset];\n+\n+\t  for (n = 0; n < len - shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          sptr -= sstride[n] * extent[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+            }\n+        }\n+    }\n+\n+  return;\n+}\n+\n+#endif"}, {"sha": "c2dc7b83764138ba3a23fbb69ad70f7490ee8c9d", "filename": "libgfortran/generated/cshift0_i4.c", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_i4.c?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -0,0 +1,176 @@\n+/* Helper function for cshift functions.\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_4)\n+\n+void\n+cshift0_i4 (gfc_array_i4 *ret, const gfc_array_i4 *array, ssize_t shift,\n+\t\t     int which)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_INTEGER_4 *rptr;\n+\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_INTEGER_4 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+\n+  which = which - 1;\n+  sstride[0] = 0;\n+  rstride[0] = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = ret->dim[dim].stride;\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = array->dim[dim].stride;\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          rstride[n] = ret->dim[dim].stride;\n+          sstride[n] = array->dim[dim].stride;\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  rptr = ret->data;\n+  sptr = array->data;\n+\n+  shift = len == 0 ? 0 : shift % (ssize_t)len;\n+  if (shift < 0)\n+    shift += len;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+\n+      /* If elements are contiguous, perform the operation\n+\t in two block moves.  */\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = shift * sizeof (GFC_INTEGER_4);\n+\t  size_t len2 = (len - shift) * sizeof (GFC_INTEGER_4);\n+\t  memcpy (rptr, sptr + shift, len2);\n+\t  memcpy (rptr + (len - shift), sptr, len1);\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, we will have to perform the copy one element at\n+\t     a time.  */\n+\t  GFC_INTEGER_4 *dest = rptr;\n+\t  const GFC_INTEGER_4 *src = &sptr[shift * soffset];\n+\n+\t  for (n = 0; n < len - shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          sptr -= sstride[n] * extent[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+            }\n+        }\n+    }\n+\n+  return;\n+}\n+\n+#endif"}, {"sha": "b4e386591726803084dc9a6eb673ebb43a5b32b9", "filename": "libgfortran/generated/cshift0_i8.c", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_i8.c?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -0,0 +1,176 @@\n+/* Helper function for cshift functions.\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_INTEGER_8)\n+\n+void\n+cshift0_i8 (gfc_array_i8 *ret, const gfc_array_i8 *array, ssize_t shift,\n+\t\t     int which)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_INTEGER_8 *rptr;\n+\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_INTEGER_8 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+\n+  which = which - 1;\n+  sstride[0] = 0;\n+  rstride[0] = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = ret->dim[dim].stride;\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = array->dim[dim].stride;\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          rstride[n] = ret->dim[dim].stride;\n+          sstride[n] = array->dim[dim].stride;\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  rptr = ret->data;\n+  sptr = array->data;\n+\n+  shift = len == 0 ? 0 : shift % (ssize_t)len;\n+  if (shift < 0)\n+    shift += len;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+\n+      /* If elements are contiguous, perform the operation\n+\t in two block moves.  */\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = shift * sizeof (GFC_INTEGER_8);\n+\t  size_t len2 = (len - shift) * sizeof (GFC_INTEGER_8);\n+\t  memcpy (rptr, sptr + shift, len2);\n+\t  memcpy (rptr + (len - shift), sptr, len1);\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, we will have to perform the copy one element at\n+\t     a time.  */\n+\t  GFC_INTEGER_8 *dest = rptr;\n+\t  const GFC_INTEGER_8 *src = &sptr[shift * soffset];\n+\n+\t  for (n = 0; n < len - shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          sptr -= sstride[n] * extent[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+            }\n+        }\n+    }\n+\n+  return;\n+}\n+\n+#endif"}, {"sha": "1eb9169e93a4b013765e11e90e103a13608dba3b", "filename": "libgfortran/generated/cshift0_r10.c", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_r10.c?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -0,0 +1,176 @@\n+/* Helper function for cshift functions.\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_10)\n+\n+void\n+cshift0_r10 (gfc_array_r10 *ret, const gfc_array_r10 *array, ssize_t shift,\n+\t\t     int which)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_REAL_10 *rptr;\n+\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_REAL_10 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+\n+  which = which - 1;\n+  sstride[0] = 0;\n+  rstride[0] = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = ret->dim[dim].stride;\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = array->dim[dim].stride;\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          rstride[n] = ret->dim[dim].stride;\n+          sstride[n] = array->dim[dim].stride;\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  rptr = ret->data;\n+  sptr = array->data;\n+\n+  shift = len == 0 ? 0 : shift % (ssize_t)len;\n+  if (shift < 0)\n+    shift += len;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+\n+      /* If elements are contiguous, perform the operation\n+\t in two block moves.  */\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = shift * sizeof (GFC_REAL_10);\n+\t  size_t len2 = (len - shift) * sizeof (GFC_REAL_10);\n+\t  memcpy (rptr, sptr + shift, len2);\n+\t  memcpy (rptr + (len - shift), sptr, len1);\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, we will have to perform the copy one element at\n+\t     a time.  */\n+\t  GFC_REAL_10 *dest = rptr;\n+\t  const GFC_REAL_10 *src = &sptr[shift * soffset];\n+\n+\t  for (n = 0; n < len - shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          sptr -= sstride[n] * extent[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+            }\n+        }\n+    }\n+\n+  return;\n+}\n+\n+#endif"}, {"sha": "c4e229bdaa77fbdd80a07992d8dff29f84bfc4fb", "filename": "libgfortran/generated/cshift0_r16.c", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_r16.c?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -0,0 +1,176 @@\n+/* Helper function for cshift functions.\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_16)\n+\n+void\n+cshift0_r16 (gfc_array_r16 *ret, const gfc_array_r16 *array, ssize_t shift,\n+\t\t     int which)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_REAL_16 *rptr;\n+\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_REAL_16 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+\n+  which = which - 1;\n+  sstride[0] = 0;\n+  rstride[0] = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = ret->dim[dim].stride;\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = array->dim[dim].stride;\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          rstride[n] = ret->dim[dim].stride;\n+          sstride[n] = array->dim[dim].stride;\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  rptr = ret->data;\n+  sptr = array->data;\n+\n+  shift = len == 0 ? 0 : shift % (ssize_t)len;\n+  if (shift < 0)\n+    shift += len;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+\n+      /* If elements are contiguous, perform the operation\n+\t in two block moves.  */\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = shift * sizeof (GFC_REAL_16);\n+\t  size_t len2 = (len - shift) * sizeof (GFC_REAL_16);\n+\t  memcpy (rptr, sptr + shift, len2);\n+\t  memcpy (rptr + (len - shift), sptr, len1);\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, we will have to perform the copy one element at\n+\t     a time.  */\n+\t  GFC_REAL_16 *dest = rptr;\n+\t  const GFC_REAL_16 *src = &sptr[shift * soffset];\n+\n+\t  for (n = 0; n < len - shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          sptr -= sstride[n] * extent[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+            }\n+        }\n+    }\n+\n+  return;\n+}\n+\n+#endif"}, {"sha": "112ff97e5d3c240e1aad9ae22a5fa8dfd2c2fce3", "filename": "libgfortran/generated/cshift0_r4.c", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_r4.c?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -0,0 +1,176 @@\n+/* Helper function for cshift functions.\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_4)\n+\n+void\n+cshift0_r4 (gfc_array_r4 *ret, const gfc_array_r4 *array, ssize_t shift,\n+\t\t     int which)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_REAL_4 *rptr;\n+\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_REAL_4 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+\n+  which = which - 1;\n+  sstride[0] = 0;\n+  rstride[0] = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = ret->dim[dim].stride;\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = array->dim[dim].stride;\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          rstride[n] = ret->dim[dim].stride;\n+          sstride[n] = array->dim[dim].stride;\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  rptr = ret->data;\n+  sptr = array->data;\n+\n+  shift = len == 0 ? 0 : shift % (ssize_t)len;\n+  if (shift < 0)\n+    shift += len;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+\n+      /* If elements are contiguous, perform the operation\n+\t in two block moves.  */\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = shift * sizeof (GFC_REAL_4);\n+\t  size_t len2 = (len - shift) * sizeof (GFC_REAL_4);\n+\t  memcpy (rptr, sptr + shift, len2);\n+\t  memcpy (rptr + (len - shift), sptr, len1);\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, we will have to perform the copy one element at\n+\t     a time.  */\n+\t  GFC_REAL_4 *dest = rptr;\n+\t  const GFC_REAL_4 *src = &sptr[shift * soffset];\n+\n+\t  for (n = 0; n < len - shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          sptr -= sstride[n] * extent[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+            }\n+        }\n+    }\n+\n+  return;\n+}\n+\n+#endif"}, {"sha": "a167fd3306aa34846f012c4475ec07a6c7982288", "filename": "libgfortran/generated/cshift0_r8.c", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fgenerated%2Fcshift0_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Fcshift0_r8.c?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -0,0 +1,176 @@\n+/* Helper function for cshift functions.\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>\n+\n+\n+#if defined (HAVE_GFC_REAL_8)\n+\n+void\n+cshift0_r8 (gfc_array_r8 *ret, const gfc_array_r8 *array, ssize_t shift,\n+\t\t     int which)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  GFC_REAL_8 *rptr;\n+\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const GFC_REAL_8 *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+\n+  which = which - 1;\n+  sstride[0] = 0;\n+  rstride[0] = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = ret->dim[dim].stride;\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = array->dim[dim].stride;\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          rstride[n] = ret->dim[dim].stride;\n+          sstride[n] = array->dim[dim].stride;\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  rptr = ret->data;\n+  sptr = array->data;\n+\n+  shift = len == 0 ? 0 : shift % (ssize_t)len;\n+  if (shift < 0)\n+    shift += len;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+\n+      /* If elements are contiguous, perform the operation\n+\t in two block moves.  */\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = shift * sizeof (GFC_REAL_8);\n+\t  size_t len2 = (len - shift) * sizeof (GFC_REAL_8);\n+\t  memcpy (rptr, sptr + shift, len2);\n+\t  memcpy (rptr + (len - shift), sptr, len1);\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, we will have to perform the copy one element at\n+\t     a time.  */\n+\t  GFC_REAL_8 *dest = rptr;\n+\t  const GFC_REAL_8 *src = &sptr[shift * soffset];\n+\n+\t  for (n = 0; n < len - shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          sptr -= sstride[n] * extent[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+            }\n+        }\n+    }\n+\n+  return;\n+}\n+\n+#endif"}, {"sha": "fa55b50482081f37449296edf1d608816218fb1a", "filename": "libgfortran/intrinsics/cshift0.c", "status": "modified", "additions": 187, "deletions": 118, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fintrinsics%2Fcshift0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fintrinsics%2Fcshift0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fcshift0.c?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -33,48 +33,6 @@ Boston, MA 02110-1301, USA.  */\n #include <assert.h>\n #include <string.h>\n \n-\n-/* \"Templatized\" helper function for the inner shift loop.  */\n-\n-#define DEF_COPY_LOOP(NAME, TYPE)\t\t\t\t\t\\\n-static inline void\t\t\t\t\t\t\t\\\n-copy_loop_##NAME (void *xdest, const void *xsrc,\t\t\t\\\n-\t\t  size_t roff, size_t soff,\t\t\t\t\\\n-\t\t  index_type len, index_type shift)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  TYPE *dest = xdest;\t\t\t\t\t\t\t\\\n-  const TYPE *src;\t\t\t\t\t\t\t\\\n-  index_type i;\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  roff /= sizeof (TYPE);\t\t\t\t\t\t\\\n-  soff /= sizeof (TYPE);\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  src = xsrc;\t\t\t\t\t\t\t\t\\\n-  src += shift * soff;\t\t\t\t\t\t\t\\\n-  for (i = 0; i < len - shift; ++i)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      *dest = *src;\t\t\t\t\t\t\t\\\n-      dest += roff;\t\t\t\t\t\t\t\\\n-      src += soff;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  src = xsrc;\t\t\t\t\t\t\t\t\\\n-  for (i = 0; i < shift; ++i)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      *dest = *src;\t\t\t\t\t\t\t\\\n-      dest += roff;\t\t\t\t\t\t\t\\\n-      src += soff;\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-DEF_COPY_LOOP(int, int)\n-DEF_COPY_LOOP(long, long)\n-DEF_COPY_LOOP(double, double)\n-DEF_COPY_LOOP(ldouble, long double)\n-DEF_COPY_LOOP(cfloat, _Complex float)\n-DEF_COPY_LOOP(cdouble, _Complex double)\n-\n-\n static void\n cshift0 (gfc_array_char * ret, const gfc_array_char * array,\n \t ssize_t shift, int which, index_type size)\n@@ -96,9 +54,10 @@ cshift0 (gfc_array_char * ret, const gfc_array_char * array,\n   index_type dim;\n   index_type len;\n   index_type n;\n-  int whichloop;\n   index_type arraysize;\n \n+  index_type type_size;\n+\n   if (which < 1 || which > GFC_DESCRIPTOR_RANK (array))\n     runtime_error (\"Argument 'DIM' is out of range in call to 'CSHIFT'\");\n \n@@ -133,43 +92,188 @@ cshift0 (gfc_array_char * ret, const gfc_array_char * array,\n   \n   if (arraysize == 0)\n     return;\n+  type_size = GFC_DTYPE_TYPE_SIZE (array);\n \n-  which = which - 1;\n-  sstride[0] = 0;\n-  rstride[0] = 0;\n+  switch(type_size)\n+    {\n+    case GFC_DTYPE_LOGICAL_1:\n+    case GFC_DTYPE_INTEGER_1:\n+    case GFC_DTYPE_DERIVED_1:\n+      cshift0_i1 ((gfc_array_i1 *)ret, (gfc_array_i1 *) array, shift, which);\n+      return;\n+\n+    case GFC_DTYPE_LOGICAL_2:\n+    case GFC_DTYPE_INTEGER_2:\n+      cshift0_i2 ((gfc_array_i2 *)ret, (gfc_array_i2 *) array, shift, which);\n+      return;\n+\n+    case GFC_DTYPE_LOGICAL_4:\n+    case GFC_DTYPE_INTEGER_4:\n+      cshift0_i4 ((gfc_array_i4 *)ret, (gfc_array_i4 *) array, shift, which);\n+      return;\n+\n+    case GFC_DTYPE_LOGICAL_8:\n+    case GFC_DTYPE_INTEGER_8:\n+      cshift0_i8 ((gfc_array_i8 *)ret, (gfc_array_i8 *) array, shift, which);\n+      return;\n \n-  extent[0] = 1;\n-  count[0] = 0;\n-  n = 0;\n+#ifdef HAVE_GFC_INTEGER_16\n+    case GFC_DTYPE_LOGICAL_16:\n+    case GFC_DTYPE_INTEGER_16:\n+      cshift0_i16 ((gfc_array_i8 *)ret, (gfc_array_i16 *) array, shift,\n+\t\t   which);\n+      return;\n+#endif\n \n-  /* The values assigned here must match the cases in the inner loop.  */\n-  whichloop = 0;\n-  switch (GFC_DESCRIPTOR_TYPE (array))\n-    {\n-    case GFC_DTYPE_LOGICAL:\n-    case GFC_DTYPE_INTEGER:\n-    case GFC_DTYPE_REAL:\n-      if (size == sizeof (int))\n-\twhichloop = 1;\n-      else if (size == sizeof (long))\n-\twhichloop = 2;\n-      else if (size == sizeof (double))\n-\twhichloop = 3;\n-      else if (size == sizeof (long double))\n-\twhichloop = 4;\n+    case GFC_DTYPE_REAL_4:\n+      cshift0_r4 ((gfc_array_r4 *)ret, (gfc_array_r4 *) array, shift, which);\n+      return;\n+\n+    case GFC_DTYPE_REAL_8:\n+      cshift0_r8 ((gfc_array_r8 *)ret, (gfc_array_r8 *) array, shift, which);\n+      return;\n+\n+#ifdef HAVE_GFC_REAL_10\n+    case GFC_DTYPE_REAL_10:\n+      cshift0_r10 ((gfc_array_r10 *)ret, (gfc_array_r10 *) array, shift,\n+\t\t   which);\n+      return;\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+    case GFC_DTYPE_REAL_16:\n+      cshift0_r16 ((gfc_array_r16 *)ret, (gfc_array_r16 *) array, shift,\n+\t\t   which);\n+      return;\n+#endif\n+\n+    case GFC_DTYPE_COMPLEX_4:\n+      cshift0_c4 ((gfc_array_c4 *)ret, (gfc_array_c4 *) array, shift, which);\n+      return;\n+\n+    case GFC_DTYPE_COMPLEX_8:\n+      cshift0_c8 ((gfc_array_c8 *)ret, (gfc_array_c8 *) array, shift, which);\n+      return;\n+\n+#ifdef HAVE_GFC_COMPLEX_10\n+    case GFC_DTYPE_COMPLEX_10:\n+      cshift0_c10 ((gfc_array_c10 *)ret, (gfc_array_c10 *) array, shift,\n+\t\t   which);\n+      return;\n+#endif\n+\n+#ifdef HAVE_GFC_COMPLEX_16\n+    case GFC_DTYPE_COMPLEX_16:\n+      cshift0_c16 ((gfc_array_c16 *)ret, (gfc_array_c16 *) array, shift,\n+\t\t   which);\n+      return;\n+#endif\n+\n+    default:\n       break;\n+    }\n \n-    case GFC_DTYPE_COMPLEX:\n-      if (size == sizeof (_Complex float))\n-\twhichloop = 5;\n-      else if (size == sizeof (_Complex double))\n-\twhichloop = 6;\n+  switch (size)\n+    {\n+      /* Let's check the actual alignment of the data pointers.  If they\n+\t are suitably aligned, we can safely call the unpack functions.  */\n+\n+    case sizeof (GFC_INTEGER_1):\n+      cshift0_i1 ((gfc_array_i1 *) ret, (gfc_array_i1 *) array, shift,\n+\t\t  which);\n       break;\n \n+    case sizeof (GFC_INTEGER_2):\n+      if (GFC_UNALIGNED_2(ret->data) || GFC_UNALIGNED_2(array->data))\n+\tbreak;\n+      else\n+\t{\n+\t  cshift0_i2 ((gfc_array_i2 *) ret, (gfc_array_i2 *) array, shift,\n+\t\t      which);\n+\t  return;\n+\t}\n+\n+    case sizeof (GFC_INTEGER_4):\n+      if (GFC_UNALIGNED_4(ret->data) || GFC_UNALIGNED_4(array->data))\n+\tbreak;\n+      else\n+\t{\n+\t  cshift0_i4 ((gfc_array_i4 *)ret, (gfc_array_i4 *) array, shift,\n+\t\t      which);\n+\t  return;\n+\t}\n+\n+    case sizeof (GFC_INTEGER_8):\n+      if (GFC_UNALIGNED_8(ret->data) || GFC_UNALIGNED_8(array->data))\n+\t{\n+\t  /* Let's try to use the complex routines.  First, a sanity\n+\t     check that the sizes match; this should be optimized to\n+\t     a no-op.  */\n+\t  if (sizeof(GFC_INTEGER_8) != sizeof(GFC_COMPLEX_4))\n+\t    break;\n+\n+\t  if (GFC_UNALIGNED_C4(ret->data) || GFC_UNALIGNED_C4(array->data))\n+\t    break;\n+\n+\t  cshift0_c4 ((gfc_array_c4 *) ret, (gfc_array_c4 *) array, shift,\n+\t\t      which);\n+\t      return;\n+\t}\n+      else\n+\t{\n+\t  cshift0_i8 ((gfc_array_i8 *)ret, (gfc_array_i8 *) array, shift,\n+\t\t      which);\n+\t  return;\n+\t}\n+\n+#ifdef HAVE_GFC_INTEGER_16\n+    case sizeof (GFC_INTEGER_16):\n+      if (GFC_UNALIGNED_16(ret->data) || GFC_UNALIGNED_16(array->data))\n+\t{\n+\t  /* Let's try to use the complex routines.  First, a sanity\n+\t     check that the sizes match; this should be optimized to\n+\t     a no-op.  */\n+\t  if (sizeof(GFC_INTGER_16) != sizeof(GFC_COMPLEX_8))\n+\t    break;\n+\n+\t  if (GFC_UNALIGNED_C8(ret->data) || GFC_UNALIGNED_C8(array->data))\n+\t    break;\n+\n+\t  cshift0_c8 ((gfc_array_c8 *) ret, (gfc_array_c8 *) array, shift,\n+\t\t      which);\n+\t      return;\n+\t}\n+      else\n+\t{\n+\t  cshift0_i16 ((gfc_array_i16 *) ret, (gfc_array_i16 *) array,\n+\t\t       shift, which);\n+\t  return;\n+\t}\n+#else\n+    case sizeof (GFC_COMPLEX_8):\n+\n+      if (GFC_UNALIGNED_C8(ret->data) || GFC_UNALIGNED_C8(array->data))\n+\tbreak;\n+      else\n+\t{\n+\t  cshift0_c8 ((gfc_array_c8 *) ret, (gfc_array_c8 *) array, shift,\n+\t\t      which);\n+\t  return;\n+\t}\n+#endif\n+\n     default:\n       break;\n     }\n \n+\n+  which = which - 1;\n+  sstride[0] = 0;\n+  rstride[0] = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n   /* Initialized for avoiding compiler warnings.  */\n   roffset = size;\n   soffset = size;\n@@ -227,56 +331,21 @@ cshift0 (gfc_array_char * ret, const gfc_array_char * array,\n       else\n \t{\n \t  /* Otherwise, we'll have to perform the copy one element at\n-\t     a time.  We can speed this up a tad for common cases of \n-\t     fundamental types.  */\n-\t  switch (whichloop)\n+\t     a time.  */\n+\t  char *dest = rptr;\n+\t  const char *src = &sptr[shift * soffset];\n+\n+\t  for (n = 0; n < len - shift; n++)\n+\t    {\n+\t      memcpy (dest, src, size);\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < shift; n++)\n \t    {\n-\t    case 0:\n-\t      {\n-\t\tchar *dest = rptr;\n-\t\tconst char *src = &sptr[shift * soffset];\n-\n-\t\tfor (n = 0; n < len - shift; n++)\n-\t\t  {\n-\t\t    memcpy (dest, src, size);\n-\t\t    dest += roffset;\n-\t\t    src += soffset;\n-\t\t  }\n-\t\tfor (src = sptr, n = 0; n < shift; n++)\n-\t\t  {\n-\t\t    memcpy (dest, src, size);\n-\t\t    dest += roffset;\n-\t\t    src += soffset;\n-\t\t  }\n-\t      }\n-\t      break;\n-\n-\t    case 1:\n-\t      copy_loop_int (rptr, sptr, roffset, soffset, len, shift);\n-\t      break;\n-\n-\t    case 2:\n-\t      copy_loop_long (rptr, sptr, roffset, soffset, len, shift);\n-\t      break;\n-\n-\t    case 3:\n-\t      copy_loop_double (rptr, sptr, roffset, soffset, len, shift);\n-\t      break;\n-\n-\t    case 4:\n-\t      copy_loop_ldouble (rptr, sptr, roffset, soffset, len, shift);\n-\t      break;\n-\n-\t    case 5:\n-\t      copy_loop_cfloat (rptr, sptr, roffset, soffset, len, shift);\n-\t      break;\n-\t      \n-\t    case 6:\n-\t      copy_loop_cdouble (rptr, sptr, roffset, soffset, len, shift);\n-\t      break;\n-\n-\t    default:\n-\t      abort ();\n+\t      memcpy (dest, src, size);\n+\t      dest += roffset;\n+\t      src += soffset;\n \t    }\n \t}\n "}, {"sha": "a055483e4ce68000bf4a035f92f3cd7b2dad1083", "filename": "libgfortran/libgfortran.h", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Flibgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Flibgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Flibgfortran.h?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -437,6 +437,12 @@ typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, GFC_LOGICAL_16) gfc_array_l16;\n \t\t\t     (__alignof__(GFC_INTEGER_16) - 1))\n #endif\n \n+#define GFC_UNALIGNED_C4(x) (((uintptr_t)(x)) & \\\n+\t\t\t     (__alignof__(GFC_COMPLEX_4) - 1))\n+\n+#define GFC_UNALIGNED_C8(x) (((uintptr_t)(x)) & \\\n+\t\t\t     (__alignof__(GFC_COMPLEX_8) - 1))\n+\n /* Runtime library include.  */\n #define stringize(x) expand_macro(x)\n #define expand_macro(x) # x\n@@ -1210,4 +1216,55 @@ typedef GFC_ARRAY_DESCRIPTOR (GFC_MAX_DIMENSIONS, void) array_t;\n extern index_type size0 (const array_t * array); \n iexport_proto(size0);\n \n+/* Internal auxiliary functions for cshift */\n+\n+void cshift0_i1 (gfc_array_i1 *, const gfc_array_i1 *, ssize_t, int);\n+internal_proto(cshift0_i1);\n+\n+void cshift0_i2 (gfc_array_i2 *, const gfc_array_i2 *, ssize_t, int);\n+internal_proto(cshift0_i2);\n+\n+void cshift0_i4 (gfc_array_i4 *, const gfc_array_i4 *, ssize_t, int);\n+internal_proto(cshift0_i4);\n+\n+void cshift0_i8 (gfc_array_i8 *, const gfc_array_i8 *, ssize_t, int);\n+internal_proto(cshift0_i8);\n+\n+#ifdef HAVE_GFC_INTEGER_16\n+void cshift0_i16 (gfc_array_i16 *, const gfc_array_i16 *, ssize_t, int);\n+internal_proto(cshift0_i16);\n+#endif\n+\n+void cshift0_r4 (gfc_array_r4 *, const gfc_array_r4 *, ssize_t, int);\n+internal_proto(cshift0_r4);\n+\n+void cshift0_r8 (gfc_array_r8 *, const gfc_array_r8 *, ssize_t, int);\n+internal_proto(cshift0_r8);\n+\n+#ifdef HAVE_GFC_REAL_10\n+void cshift0_r10 (gfc_array_r10 *, const gfc_array_r10 *, ssize_t, int);\n+internal_proto(cshift0_r10);\n+#endif\n+\n+#ifdef HAVE_GFC_REAL_16\n+void cshift0_r16 (gfc_array_r16 *, const gfc_array_r16 *, ssize_t, int);\n+internal_proto(cshift0_r16);\n+#endif\n+\n+void cshift0_c4 (gfc_array_c4 *, const gfc_array_c4 *, ssize_t, int);\n+internal_proto(cshift0_c4);\n+\n+void cshift0_c8 (gfc_array_c8 *, const gfc_array_c8 *, ssize_t, int);\n+internal_proto(cshift0_c8);\n+\n+#ifdef HAVE_GFC_COMPLEX_10\n+void cshift0_c10 (gfc_array_c10 *, const gfc_array_c10 *, ssize_t, int);\n+internal_proto(cshift0_c10);\n+#endif\n+\n+#ifdef HAVE_GFC_COMPLEX_16\n+void cshift0_c16 (gfc_array_c16 *, const gfc_array_c16 *, ssize_t, int);\n+internal_proto(cshift0_c16);\n+#endif\n+\n #endif  /* LIBGFOR_H  */"}, {"sha": "b633169ae519ed02fad841480447788d466b2eec", "filename": "libgfortran/m4/cshift0.m4", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fm4%2Fcshift0.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2b00cdcaaef76f88c770351803dcb7040338d58/libgfortran%2Fm4%2Fcshift0.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Fcshift0.m4?ref=c2b00cdcaaef76f88c770351803dcb7040338d58", "patch": "@@ -0,0 +1,177 @@\n+`/* Helper function for cshift functions.\n+   Copyright 2008 Free Software Foundation, Inc.\n+   Contributed by Thomas Koenig <tkoenig@gcc.gnu.org>\n+\n+This file is part of the GNU Fortran 95 runtime library (libgfortran).\n+\n+Libgfortran is free software; you can redistribute it and/or\n+modify it under the terms of the GNU General Public\n+License as published by the Free Software Foundation; either\n+version 2 of the License, or (at your option) any later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+Libgfortran is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public\n+License along with libgfortran; see the file COPYING.  If not,\n+write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+#include \"libgfortran.h\"\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <string.h>'\n+\n+include(iparm.m4)dnl\n+\n+`#if defined (HAVE_'rtype_name`)\n+\n+void\n+cshift0_'rtype_code` ('rtype` *ret, const 'rtype` *array, ssize_t shift,\n+\t\t     int which)\n+{\n+  /* r.* indicates the return array.  */\n+  index_type rstride[GFC_MAX_DIMENSIONS];\n+  index_type rstride0;\n+  index_type roffset;\n+  'rtype_name` *rptr;\n+\n+  /* s.* indicates the source array.  */\n+  index_type sstride[GFC_MAX_DIMENSIONS];\n+  index_type sstride0;\n+  index_type soffset;\n+  const 'rtype_name` *sptr;\n+\n+  index_type count[GFC_MAX_DIMENSIONS];\n+  index_type extent[GFC_MAX_DIMENSIONS];\n+  index_type dim;\n+  index_type len;\n+  index_type n;\n+\n+  which = which - 1;\n+  sstride[0] = 0;\n+  rstride[0] = 0;\n+\n+  extent[0] = 1;\n+  count[0] = 0;\n+  n = 0;\n+  /* Initialized for avoiding compiler warnings.  */\n+  roffset = 1;\n+  soffset = 1;\n+  len = 0;\n+\n+  for (dim = 0; dim < GFC_DESCRIPTOR_RANK (array); dim++)\n+    {\n+      if (dim == which)\n+        {\n+          roffset = ret->dim[dim].stride;\n+          if (roffset == 0)\n+            roffset = 1;\n+          soffset = array->dim[dim].stride;\n+          if (soffset == 0)\n+            soffset = 1;\n+          len = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+        }\n+      else\n+        {\n+          count[n] = 0;\n+          extent[n] = array->dim[dim].ubound + 1 - array->dim[dim].lbound;\n+          rstride[n] = ret->dim[dim].stride;\n+          sstride[n] = array->dim[dim].stride;\n+          n++;\n+        }\n+    }\n+  if (sstride[0] == 0)\n+    sstride[0] = 1;\n+  if (rstride[0] == 0)\n+    rstride[0] = 1;\n+\n+  dim = GFC_DESCRIPTOR_RANK (array);\n+  rstride0 = rstride[0];\n+  sstride0 = sstride[0];\n+  rptr = ret->data;\n+  sptr = array->data;\n+\n+  shift = len == 0 ? 0 : shift % (ssize_t)len;\n+  if (shift < 0)\n+    shift += len;\n+\n+  while (rptr)\n+    {\n+      /* Do the shift for this dimension.  */\n+\n+      /* If elements are contiguous, perform the operation\n+\t in two block moves.  */\n+      if (soffset == 1 && roffset == 1)\n+\t{\n+\t  size_t len1 = shift * sizeof ('rtype_name`);\n+\t  size_t len2 = (len - shift) * sizeof ('rtype_name`);\n+\t  memcpy (rptr, sptr + shift, len2);\n+\t  memcpy (rptr + (len - shift), sptr, len1);\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise, we will have to perform the copy one element at\n+\t     a time.  */\n+\t  'rtype_name` *dest = rptr;\n+\t  const 'rtype_name` *src = &sptr[shift * soffset];\n+\n+\t  for (n = 0; n < len - shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t  for (src = sptr, n = 0; n < shift; n++)\n+\t    {\n+\t      *dest = *src;\n+\t      dest += roffset;\n+\t      src += soffset;\n+\t    }\n+\t}\n+\n+      /* Advance to the next section.  */\n+      rptr += rstride0;\n+      sptr += sstride0;\n+      count[0]++;\n+      n = 0;\n+      while (count[n] == extent[n])\n+        {\n+          /* When we get to the end of a dimension, reset it and increment\n+             the next dimension.  */\n+          count[n] = 0;\n+          /* We could precalculate these products, but this is a less\n+             frequently used path so probably not worth it.  */\n+          rptr -= rstride[n] * extent[n];\n+          sptr -= sstride[n] * extent[n];\n+          n++;\n+          if (n >= dim - 1)\n+            {\n+              /* Break out of the loop.  */\n+              rptr = NULL;\n+              break;\n+            }\n+          else\n+            {\n+              count[n]++;\n+              rptr += rstride[n];\n+              sptr += sstride[n];\n+            }\n+        }\n+    }\n+\n+  return;\n+}\n+\n+#endif'"}]}