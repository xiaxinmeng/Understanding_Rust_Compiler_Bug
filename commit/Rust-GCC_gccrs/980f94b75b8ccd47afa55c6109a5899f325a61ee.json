{"sha": "980f94b75b8ccd47afa55c6109a5899f325a61ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTgwZjk0Yjc1YjhjY2Q0N2FmYTU1YzYxMDlhNTg5OWYzMjVhNjFlZQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2018-07-17T08:06:24Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-07-17T08:06:24Z"}, "message": "[Ada] New ignored Ghost code removal mechanism\n\nThis patch reimplements the mechanism which removes ignored Ghost code from the\ntree.\n\nThe previous mechanism proved to be unreliable because it assumed that no new\nscoping constructs would be created after some ignored Ghost code had already\nnotified its enclosing scoping constructs that they contain such code. The\nassumption can be broken by having a call to an ignored Ghost procedure within\nthe extended return statement of a function. The procedure call would signal\nthe enclosing function that it contains ignored Ghost code, however the return\nstatement would introduce an extra block, effectively hiding the procedure call\nfrom the ignored Ghost code elimination pass.\n\nThe new mechanism implemented in this patch forgoes directed tree pruning in\nfavor of storing the actual ignored Ghost code, and later directly eliminating\nit from the tree.\n\nFor this approach to operate efficiently, only \"top level\" ignored Ghost\nconstructs are stored. The top level constructs are essentially nodes which can\nappear within a declarative or statement list and be safely rewritten into null\nstatements. This ensures that only \"root\" ignored Ghost construct need to be\nprocessed, as opposed to all ignored Ghost nodes within a subtree.\n\nThe approach has one drawback however. Due to the generation and analysis of\nignored Ghost code, a construct may be recorded multiple times (usually twice).\nThe mechanism simply deals with this artefact instead of employing expensive\nsolutions such as hash tables or a common flag shared by all nodes to eliminate\nthe duplicates.\n\n------------\n-- Source --\n------------\n\n--  main.adb\n\nwith Ada.Text_IO; use Ada.Text_IO;\n\nprocedure Main is\n   procedure Ghost_Proc with Ghost;\n   procedure Ghost_Proc is\n   begin\n      Put_Line (\"ERROR: Ghost_Proc called\");\n   end Ghost_Proc;\n\n   function Func return Integer is\n   begin\n      return Res : Integer := 123 do\n         Ghost_Proc;\n      end return;\n   end Func;\n\n   Val : Integer with Ghost;\n\nbegin\n   Val := Func;\nend Main;\n\n----------------------------\n-- Compilation and output --\n----------------------------\n\n$ gcc -c -gnatDG main.adb\n$ grep -c \"ghost\" main.adb.dg\n0\n\n2018-07-17  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* alloc.ads: Update the allocation metrics of the ignored Ghost nodes\n\ttable.\n\t* atree.adb: Add a soft link for a procedure which is invoked whenever\n\tan ignored Ghost node or entity is created.\n\t(Change_Node): Preserve relevant attributes which come from the Flags\n\ttable.\n\t(Mark_New_Ghost_Node): Record a newly created ignored Ghost node or\n\tentity.\n\t(Rewrite): Preserve relevant attributes which come from the Flags\n\ttable.\n\t(Set_Ignored_Ghost_Recording_Proc): New routine.\n\t* atree.ads: Define an access-to-suprogram type for a soft link which\n\trecords a newly created ignored Ghost node or entity.\n\t(Set_Ignored_Ghost_Recording_Proc): New routine.\n\t* ghost.adb: Remove with and use clause for Lib.  Remove table\n\tIgnored_Ghost_Units.  Add new table Ignored_Ghost_Nodes.\n\t(Add_Ignored_Ghost_Unit): Removed.\n\t(Initialize): Initialize the table which stores ignored Ghost nodes.\n\tSet the soft link which allows Atree.Mark_New_Ghost_Node to record an\n\tignored Ghost node.\n\t(Is_Ignored_Ghost_Unit): Use the ultimate original node when checking\n\tan eliminated ignored Ghost unit.\n\t(Lock): Release and lock the table which stores ignored Ghost nodes.\n\t(Mark_And_Set_Ghost_Assignment): Record rather than propagate ignored\n\tGhost nodes.\n\t(Mark_And_Set_Ghost_Procedure_Call): Record rather than propagate\n\tignored Ghost nodes.\n\t(Mark_Ghost_Clause): Record rather than propagate ignored Ghost nodes.\n\t(Mark_Ghost_Declaration_Or_Body): Record rather than propagate ignored\n\tGhost nodes.\n\t(Mark_Ghost_Pragma): Record rather than propagate ignored Ghost nodes.\n\t(Propagate_Ignored_Ghost_Code): Removed.\n\t(Record_Ignored_Ghost_Node): New routine.\n\t(Remove_Ignored_Ghost_Code): Reimplemented.\n\t(Remove_Ignored_Ghost_Node): New routine.\n\t(Ultimate_Original_Node): New routine.\n\t* ghost.ads (Check_Ghost_Completion): Removed.\n\t* sem_ch8.adb (Analyze_Use_Package): Remove obsolete code. Mark a use\n\tpackage clause as ignored Ghost if applicable.\n\t* sem_util.adb (Is_Body_Or_Package_Declaration): Reimplemented.\n\nFrom-SVN: r262775", "tree": {"sha": "536002f95a4bbf2667c82ef74652e1dc6d85712b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/536002f95a4bbf2667c82ef74652e1dc6d85712b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/980f94b75b8ccd47afa55c6109a5899f325a61ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/980f94b75b8ccd47afa55c6109a5899f325a61ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/980f94b75b8ccd47afa55c6109a5899f325a61ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/980f94b75b8ccd47afa55c6109a5899f325a61ee/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e8427749a9c5ad6ec2c0653dcc4edea5b41efc31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8427749a9c5ad6ec2c0653dcc4edea5b41efc31", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8427749a9c5ad6ec2c0653dcc4edea5b41efc31"}], "stats": {"total": 509, "additions": 249, "deletions": 260}, "files": [{"sha": "df414ccb5fb51251e87746d0abbc8ec8144d2f84", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f94b75b8ccd47afa55c6109a5899f325a61ee/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f94b75b8ccd47afa55c6109a5899f325a61ee/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=980f94b75b8ccd47afa55c6109a5899f325a61ee", "patch": "@@ -1,3 +1,46 @@\n+2018-07-17  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* alloc.ads: Update the allocation metrics of the ignored Ghost nodes\n+\ttable.\n+\t* atree.adb: Add a soft link for a procedure which is invoked whenever\n+\tan ignored Ghost node or entity is created.\n+\t(Change_Node): Preserve relevant attributes which come from the Flags\n+\ttable.\n+\t(Mark_New_Ghost_Node): Record a newly created ignored Ghost node or\n+\tentity.\n+\t(Rewrite): Preserve relevant attributes which come from the Flags\n+\ttable.\n+\t(Set_Ignored_Ghost_Recording_Proc): New routine.\n+\t* atree.ads: Define an access-to-suprogram type for a soft link which\n+\trecords a newly created ignored Ghost node or entity.\n+\t(Set_Ignored_Ghost_Recording_Proc): New routine.\n+\t* ghost.adb: Remove with and use clause for Lib.  Remove table\n+\tIgnored_Ghost_Units.  Add new table Ignored_Ghost_Nodes.\n+\t(Add_Ignored_Ghost_Unit): Removed.\n+\t(Initialize): Initialize the table which stores ignored Ghost nodes.\n+\tSet the soft link which allows Atree.Mark_New_Ghost_Node to record an\n+\tignored Ghost node.\n+\t(Is_Ignored_Ghost_Unit): Use the ultimate original node when checking\n+\tan eliminated ignored Ghost unit.\n+\t(Lock): Release and lock the table which stores ignored Ghost nodes.\n+\t(Mark_And_Set_Ghost_Assignment): Record rather than propagate ignored\n+\tGhost nodes.\n+\t(Mark_And_Set_Ghost_Procedure_Call): Record rather than propagate\n+\tignored Ghost nodes.\n+\t(Mark_Ghost_Clause): Record rather than propagate ignored Ghost nodes.\n+\t(Mark_Ghost_Declaration_Or_Body): Record rather than propagate ignored\n+\tGhost nodes.\n+\t(Mark_Ghost_Pragma): Record rather than propagate ignored Ghost nodes.\n+\t(Propagate_Ignored_Ghost_Code): Removed.\n+\t(Record_Ignored_Ghost_Node): New routine.\n+\t(Remove_Ignored_Ghost_Code): Reimplemented.\n+\t(Remove_Ignored_Ghost_Node): New routine.\n+\t(Ultimate_Original_Node): New routine.\n+\t* ghost.ads (Check_Ghost_Completion): Removed.\n+\t* sem_ch8.adb (Analyze_Use_Package): Remove obsolete code. Mark a use\n+\tpackage clause as ignored Ghost if applicable.\n+\t* sem_util.adb (Is_Body_Or_Package_Declaration): Reimplemented.\n+\n 2018-07-17  Javier Miranda  <miranda@adacore.com>\n \n \t* sem_ch5.adb (Has_Call_Using_Secondary_Stack): Moved to library level"}, {"sha": "96e67edd826d0269865e962cfbd82982f6832ded", "filename": "gcc/ada/alloc.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f94b75b8ccd47afa55c6109a5899f325a61ee/gcc%2Fada%2Falloc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f94b75b8ccd47afa55c6109a5899f325a61ee/gcc%2Fada%2Falloc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Falloc.ads?ref=980f94b75b8ccd47afa55c6109a5899f325a61ee", "patch": "@@ -67,8 +67,8 @@ package Alloc is\n    In_Out_Warnings_Initial          : constant := 100;        -- Sem_Warn\n    In_Out_Warnings_Increment        : constant := 100;\n \n-   Ignored_Ghost_Units_Initial      : constant := 20;         -- Sem_Util\n-   Ignored_Ghost_Units_Increment    : constant := 50;\n+   Ignored_Ghost_Nodes_Initial      : constant := 100;        -- Ghost\n+   Ignored_Ghost_Nodes_Increment    : constant := 100;\n \n    Inlined_Initial                  : constant := 100;        -- Inline\n    Inlined_Increment                : constant := 100;"}, {"sha": "102d7f6a08aa13d9dae40a3cc8635235d5db8b0c", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 60, "deletions": 15, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f94b75b8ccd47afa55c6109a5899f325a61ee/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f94b75b8ccd47afa55c6109a5899f325a61ee/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=980f94b75b8ccd47afa55c6109a5899f325a61ee", "patch": "@@ -48,6 +48,10 @@ with GNAT.Heap_Sort_G;\n \n package body Atree is\n \n+   Ignored_Ghost_Recording_Proc : Ignored_Ghost_Record_Proc := null;\n+   --  This soft link captures the procedure invoked during the creation of an\n+   --  ignored Ghost node or entity.\n+\n    Locked : Boolean := False;\n    --  Compiling with assertions enabled, node contents modifications are\n    --  permitted only when this switch is set to False; compiling without\n@@ -683,12 +687,21 @@ package body Atree is\n    -----------------\n \n    procedure Change_Node (N : Node_Id; New_Node_Kind : Node_Kind) is\n-      Save_Sloc    : constant Source_Ptr := Sloc (N);\n+\n+      --  Flags table attributes\n+\n+      Save_CA     : constant Boolean := Flags.Table (N).Check_Actuals;\n+      Save_Is_IGN : constant Boolean := Flags.Table (N).Is_Ignored_Ghost_Node;\n+\n+      --  Nodes table attributes\n+\n+      Save_CFS     : constant Boolean    := Nodes.Table (N).Comes_From_Source;\n       Save_In_List : constant Boolean    := Nodes.Table (N).In_List;\n       Save_Link    : constant Union_Id   := Nodes.Table (N).Link;\n-      Save_CFS     : constant Boolean    := Nodes.Table (N).Comes_From_Source;\n       Save_Posted  : constant Boolean    := Nodes.Table (N).Error_Posted;\n-      Par_Count    : Nat                 := 0;\n+      Save_Sloc    : constant Source_Ptr := Sloc (N);\n+\n+      Par_Count : Nat := 0;\n \n    begin\n       if Nkind (N) in N_Subexpr then\n@@ -703,7 +716,9 @@ package body Atree is\n       Nodes.Table (N).Nkind             := New_Node_Kind;\n       Nodes.Table (N).Error_Posted      := Save_Posted;\n \n-      Flags.Table (N) := Default_Flags;\n+      Flags.Table (N)                       := Default_Flags;\n+      Flags.Table (N).Check_Actuals         := Save_CA;\n+      Flags.Table (N).Is_Ignored_Ghost_Node := Save_Is_IGN;\n \n       if New_Node_Kind in N_Subexpr then\n          Set_Paren_Count (N, Par_Count);\n@@ -1606,6 +1621,13 @@ package body Atree is\n          end if;\n \n          Set_Is_Ignored_Ghost_Node (N);\n+\n+         --  Record the ignored Ghost node or entity in order to eliminate it\n+         --  from the tree later.\n+\n+         if Ignored_Ghost_Recording_Proc /= null then\n+            Ignored_Ghost_Recording_Proc.all (N);\n+         end if;\n       end if;\n    end Mark_New_Ghost_Node;\n \n@@ -1629,8 +1651,8 @@ package body Atree is\n       if Source > Empty_Or_Error then\n          New_Id := Allocate_Initialize_Node (Source, Has_Extension (Source));\n \n-         Nodes.Table (New_Id).Link := Empty_List_Or_Node;\n          Nodes.Table (New_Id).In_List := False;\n+         Nodes.Table (New_Id).Link    := Empty_List_Or_Node;\n \n          --  If the original is marked as a rewrite insertion, then unmark the\n          --  copy, since we inserted the original, not the copy.\n@@ -2218,16 +2240,24 @@ package body Atree is\n    -------------\n \n    procedure Rewrite (Old_Node, New_Node : Node_Id) is\n-      Old_Error_P : constant Boolean  := Nodes.Table (Old_Node).Error_Posted;\n-      --  This field is always preserved in the new node\n \n-      Old_Has_Aspects : constant Boolean := Nodes.Table (Old_Node).Has_Aspects;\n-      --  This field is always preserved in the new node\n+      --  Flags table attributes\n+\n+      Old_CA     : constant Boolean := Flags.Table (Old_Node).Check_Actuals;\n+      Old_Is_IGN : constant Boolean :=\n+                     Flags.Table (Old_Node).Is_Ignored_Ghost_Node;\n+\n+      --  Nodes table attributes\n+\n+      Old_Error_Posted : constant Boolean :=\n+                           Nodes.Table (Old_Node).Error_Posted;\n+      Old_Has_Aspects  : constant Boolean :=\n+                           Nodes.Table (Old_Node).Has_Aspects;\n \n-      Old_Paren_Count     : Nat;\n       Old_Must_Not_Freeze : Boolean;\n-      --  These fields are preserved in the new node only if the new node\n-      --  and the old node are both subexpression nodes.\n+      Old_Paren_Count     : Nat;\n+      --  These fields are preserved in the new node only if the new node and\n+      --  the old node are both subexpression nodes.\n \n       --  Note: it is a violation of abstraction levels for Must_Not_Freeze\n       --  to be referenced like this. ???\n@@ -2244,11 +2274,11 @@ package body Atree is\n       pragma Debug (New_Node_Debugging_Output (New_Node));\n \n       if Nkind (Old_Node) in N_Subexpr then\n-         Old_Paren_Count     := Paren_Count (Old_Node);\n          Old_Must_Not_Freeze := Must_Not_Freeze (Old_Node);\n+         Old_Paren_Count     := Paren_Count (Old_Node);\n       else\n-         Old_Paren_Count     := 0;\n          Old_Must_Not_Freeze := False;\n+         Old_Paren_Count     := 0;\n       end if;\n \n       --  Allocate a new node, to be used to preserve the original contents\n@@ -2274,9 +2304,12 @@ package body Atree is\n       --  Copy substitute node into place, preserving old fields as required\n \n       Copy_Node (Source => New_Node, Destination => Old_Node);\n-      Nodes.Table (Old_Node).Error_Posted := Old_Error_P;\n+      Nodes.Table (Old_Node).Error_Posted := Old_Error_Posted;\n       Nodes.Table (Old_Node).Has_Aspects  := Old_Has_Aspects;\n \n+      Flags.Table (Old_Node).Check_Actuals         := Old_CA;\n+      Flags.Table (Old_Node).Is_Ignored_Ghost_Node := Old_Is_IGN;\n+\n       if Nkind (New_Node) in N_Subexpr then\n          Set_Paren_Count     (Old_Node, Old_Paren_Count);\n          Set_Must_Not_Freeze (Old_Node, Old_Must_Not_Freeze);\n@@ -2369,6 +2402,18 @@ package body Atree is\n       Nodes.Table (N).Has_Aspects := Val;\n    end Set_Has_Aspects;\n \n+   --------------------------------------\n+   -- Set_Ignored_Ghost_Recording_Proc --\n+   --------------------------------------\n+\n+   procedure Set_Ignored_Ghost_Recording_Proc\n+     (Proc : Ignored_Ghost_Record_Proc)\n+   is\n+   begin\n+      pragma Assert (Ignored_Ghost_Recording_Proc = null);\n+      Ignored_Ghost_Recording_Proc := Proc;\n+   end Set_Ignored_Ghost_Recording_Proc;\n+\n    -------------------------------\n    -- Set_Is_Ignored_Ghost_Node --\n    -------------------------------"}, {"sha": "b0a0334be4e2318094c563beb444e712deef2cf5", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f94b75b8ccd47afa55c6109a5899f325a61ee/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f94b75b8ccd47afa55c6109a5899f325a61ee/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=980f94b75b8ccd47afa55c6109a5899f325a61ee", "patch": "@@ -570,6 +570,13 @@ package Atree is\n    --  are appropriately updated. This function is used only by Sinfo.CN to\n    --  change nodes into their corresponding entities.\n \n+   type Ignored_Ghost_Record_Proc is access procedure (N : Node_Or_Entity_Id);\n+\n+   procedure Set_Ignored_Ghost_Recording_Proc\n+     (Proc : Ignored_Ghost_Record_Proc);\n+   --  Register a procedure that is invoked when an ignored Ghost node or\n+   --  entity is created.\n+\n    type Report_Proc is access procedure (Target : Node_Id; Source : Node_Id);\n \n    procedure Set_Reporting_Proc (Proc : Report_Proc);"}, {"sha": "47912aa4685f21d09bc1a67ef0a8d1731df20c27", "filename": "gcc/ada/ghost.adb", "status": "modified", "additions": 133, "deletions": 215, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f94b75b8ccd47afa55c6109a5899f325a61ee/gcc%2Fada%2Fghost.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f94b75b8ccd47afa55c6109a5899f325a61ee/gcc%2Fada%2Fghost.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fghost.adb?ref=980f94b75b8ccd47afa55c6109a5899f325a61ee", "patch": "@@ -29,7 +29,6 @@ with Atree;    use Atree;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n-with Lib;      use Lib;\n with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n@@ -50,18 +49,16 @@ package body Ghost is\n    -- Data strictures --\n    ---------------------\n \n-   --  The following table contains the N_Compilation_Unit node for a unit that\n-   --  is either subject to pragma Ghost with policy Ignore or contains ignored\n-   --  Ghost code. The table is used in the removal of ignored Ghost code from\n-   --  units.\n+   --  The following table contains all ignored Ghost nodes that must be\n+   --  eliminated from the tree by routine Remove_Ignored_Ghost_Code.\n \n-   package Ignored_Ghost_Units is new Table.Table (\n+   package Ignored_Ghost_Nodes is new Table.Table (\n      Table_Component_Type => Node_Id,\n      Table_Index_Type     => Int,\n      Table_Low_Bound      => 0,\n-     Table_Initial        => Alloc.Ignored_Ghost_Units_Initial,\n-     Table_Increment      => Alloc.Ignored_Ghost_Units_Increment,\n-     Table_Name           => \"Ignored_Ghost_Units\");\n+     Table_Initial        => Alloc.Ignored_Ghost_Nodes_Initial,\n+     Table_Increment      => Alloc.Ignored_Ghost_Nodes_Increment,\n+     Table_Name           => \"Ignored_Ghost_Nodes\");\n \n    -----------------------\n    -- Local subprograms --\n@@ -98,37 +95,9 @@ package body Ghost is\n    --  Convert a Ghost mode denoted by name Mode into its respective enumerated\n    --  value.\n \n-   procedure Propagate_Ignored_Ghost_Code (N : Node_Id);\n-   --  Signal all enclosing scopes that they now contain at least one ignored\n-   --  Ghost node denoted by N. Add the compilation unit containing N to table\n-   --  Ignored_Ghost_Units for post processing.\n-\n-   ----------------------------\n-   -- Add_Ignored_Ghost_Unit --\n-   ----------------------------\n-\n-   procedure Add_Ignored_Ghost_Unit (Unit : Node_Id) is\n-   begin\n-      pragma Assert (Nkind (Unit) = N_Compilation_Unit);\n-\n-      --  Avoid duplicates in the table as pruning the same unit more than once\n-      --  is wasteful. Since ignored Ghost code tends to be grouped up, check\n-      --  the contents of the table in reverse.\n-\n-      for Index in reverse Ignored_Ghost_Units.First ..\n-                           Ignored_Ghost_Units.Last\n-      loop\n-         --  If the unit is already present in the table, do not add it again\n-\n-         if Unit = Ignored_Ghost_Units.Table (Index) then\n-            return;\n-         end if;\n-      end loop;\n-\n-      --  If we get here, then this is the first time the unit is being added\n-\n-      Ignored_Ghost_Units.Append (Unit);\n-   end Add_Ignored_Ghost_Unit;\n+   procedure Record_Ignored_Ghost_Node (N : Node_Or_Entity_Id);\n+   --  Save ignored Ghost node or entity N in table Ignored_Ghost_Nodes for\n+   --  later elimination.\n \n    ----------------------------\n    -- Check_Ghost_Completion --\n@@ -913,7 +882,12 @@ package body Ghost is\n \n    procedure Initialize is\n    begin\n-      Ignored_Ghost_Units.Init;\n+      Ignored_Ghost_Nodes.Init;\n+\n+      --  Set the soft link which enables Atree.Mark_New_Ghost_Node to record\n+      --  an ignored Ghost node or entity.\n+\n+      Set_Ignored_Ghost_Recording_Proc (Record_Ignored_Ghost_Node'Access);\n    end Initialize;\n \n    ------------------------\n@@ -1030,14 +1004,36 @@ package body Ghost is\n    ---------------------------\n \n    function Is_Ignored_Ghost_Unit (N : Node_Id) return Boolean is\n+      function Ultimate_Original_Node (Nod : Node_Id) return Node_Id;\n+      --  Obtain the original node of arbitrary node Nod following a potential\n+      --  chain of rewritings.\n+\n+      ----------------------------\n+      -- Ultimate_Original_Node --\n+      ----------------------------\n+\n+      function Ultimate_Original_Node (Nod : Node_Id) return Node_Id is\n+         Res : Node_Id;\n+\n+      begin\n+         Res := Nod;\n+         while Original_Node (Res) /= Res loop\n+            Res := Original_Node (Res);\n+         end loop;\n+\n+         return Res;\n+      end Ultimate_Original_Node;\n+\n+   --  Start of processing for Is_Ignored_Ghost_Unit\n+\n    begin\n       --  Inspect the original node of the unit in case removal of ignored\n       --  Ghost code has already taken place.\n \n       return\n         Nkind (N) = N_Compilation_Unit\n           and then Is_Ignored_Ghost_Entity\n-                     (Defining_Entity (Original_Node (Unit (N))));\n+                     (Defining_Entity (Ultimate_Original_Node (Unit (N))));\n    end Is_Ignored_Ghost_Unit;\n \n    -------------------------\n@@ -1176,8 +1172,8 @@ package body Ghost is\n \n    procedure Lock is\n    begin\n-      Ignored_Ghost_Units.Release;\n-      Ignored_Ghost_Units.Locked := True;\n+      Ignored_Ghost_Nodes.Release;\n+      Ignored_Ghost_Nodes.Locked := True;\n    end Lock;\n \n    -----------------------------------\n@@ -1201,7 +1197,7 @@ package body Ghost is\n             Install_Ghost_Region (Ignore, N);\n \n             Set_Is_Ignored_Ghost_Node (N);\n-            Propagate_Ignored_Ghost_Code (N);\n+            Record_Ignored_Ghost_Node (N);\n          end if;\n       end if;\n    end Mark_And_Set_Ghost_Assignment;\n@@ -1472,11 +1468,39 @@ package body Ghost is\n             Install_Ghost_Region (Ignore, N);\n \n             Set_Is_Ignored_Ghost_Node (N);\n-            Propagate_Ignored_Ghost_Code (N);\n+            Record_Ignored_Ghost_Node (N);\n          end if;\n       end if;\n    end Mark_And_Set_Ghost_Procedure_Call;\n \n+   -----------------------\n+   -- Mark_Ghost_Clause --\n+   -----------------------\n+\n+   procedure Mark_Ghost_Clause (N : Node_Id) is\n+      Nam : Node_Id := Empty;\n+\n+   begin\n+      if Nkind (N) = N_Use_Package_Clause then\n+         Nam := Name (N);\n+\n+      elsif Nkind (N) = N_Use_Type_Clause then\n+         Nam := Subtype_Mark (N);\n+\n+      elsif Nkind (N) = N_With_Clause then\n+         Nam := Name (N);\n+      end if;\n+\n+      if Present (Nam)\n+        and then Is_Entity_Name (Nam)\n+        and then Present (Entity (Nam))\n+        and then Is_Ignored_Ghost_Entity (Entity (Nam))\n+      then\n+         Set_Is_Ignored_Ghost_Node (N);\n+         Record_Ignored_Ghost_Node (N);\n+      end if;\n+   end Mark_Ghost_Clause;\n+\n    ------------------------------------\n    -- Mark_Ghost_Declaration_Or_Body --\n    ------------------------------------\n@@ -1502,7 +1526,7 @@ package body Ghost is\n          Mark_Formals := True;\n          Set_Is_Ignored_Ghost_Entity (Id);\n          Set_Is_Ignored_Ghost_Node (N);\n-         Propagate_Ignored_Ghost_Code (N);\n+         Record_Ignored_Ghost_Node (N);\n       end if;\n \n       --  Mark all formal parameters when the related node denotes a subprogram\n@@ -1537,34 +1561,6 @@ package body Ghost is\n       end if;\n    end Mark_Ghost_Declaration_Or_Body;\n \n-   -----------------------\n-   -- Mark_Ghost_Clause --\n-   -----------------------\n-\n-   procedure Mark_Ghost_Clause (N : Node_Id) is\n-      Nam : Node_Id := Empty;\n-\n-   begin\n-      if Nkind (N) = N_Use_Package_Clause then\n-         Nam := Name (N);\n-\n-      elsif Nkind (N) = N_Use_Type_Clause then\n-         Nam := Subtype_Mark (N);\n-\n-      elsif Nkind (N) = N_With_Clause then\n-         Nam := Name (N);\n-      end if;\n-\n-      if Present (Nam)\n-        and then Is_Entity_Name (Nam)\n-        and then Present (Entity (Nam))\n-        and then Is_Ignored_Ghost_Entity (Entity (Nam))\n-      then\n-         Set_Is_Ignored_Ghost_Node (N);\n-         Propagate_Ignored_Ghost_Code (N);\n-      end if;\n-   end Mark_Ghost_Clause;\n-\n    -----------------------\n    -- Mark_Ghost_Pragma --\n    -----------------------\n@@ -1583,7 +1579,7 @@ package body Ghost is\n       elsif Is_Ignored_Ghost_Entity (Id) then\n          Set_Is_Ignored_Ghost_Pragma (N);\n          Set_Is_Ignored_Ghost_Node (N);\n-         Propagate_Ignored_Ghost_Code (N);\n+         Record_Ignored_Ghost_Node (N);\n       end if;\n    end Mark_Ghost_Pragma;\n \n@@ -1635,168 +1631,90 @@ package body Ghost is\n       end if;\n    end Name_To_Ghost_Mode;\n \n-   ----------------------------------\n-   -- Propagate_Ignored_Ghost_Code --\n-   ----------------------------------\n-\n-   procedure Propagate_Ignored_Ghost_Code (N : Node_Id) is\n-      Nod  : Node_Id;\n-      Scop : Entity_Id;\n+   -------------------------------\n+   -- Record_Ignored_Ghost_Node --\n+   -------------------------------\n \n+   procedure Record_Ignored_Ghost_Node (N : Node_Or_Entity_Id) is\n    begin\n-      --  Traverse the parent chain looking for blocks, packages, and\n-      --  subprograms or their respective bodies.\n-\n-      Nod := Parent (N);\n-      while Present (Nod) loop\n-         Scop := Empty;\n-\n-         if Nkind (Nod) = N_Block_Statement\n-           and then Present (Identifier (Nod))\n-         then\n-            Scop := Entity (Identifier (Nod));\n-\n-         elsif Nkind_In (Nod, N_Package_Body,\n-                              N_Package_Declaration,\n-                              N_Subprogram_Body,\n-                              N_Subprogram_Declaration)\n-         then\n-            Scop := Defining_Entity (Nod);\n-         end if;\n-\n-         --  The current node denotes a scoping construct\n-\n-         if Present (Scop) then\n-\n-            --  Stop the traversal when the scope already contains ignored\n-            --  Ghost code as all enclosing scopes have already been marked.\n-\n-            if Contains_Ignored_Ghost_Code (Scop) then\n-               exit;\n-\n-            --  Otherwise mark this scope and keep climbing\n-\n-            else\n-               Set_Contains_Ignored_Ghost_Code (Scop);\n-            end if;\n-         end if;\n-\n-         Nod := Parent (Nod);\n-      end loop;\n-\n-      --  The unit containing the ignored Ghost code must be post processed\n-      --  before invoking the back end.\n+      --  Save all \"top level\" ignored Ghost nodes which can be safely replaced\n+      --  with a null statement. Note that there is need to save other kinds of\n+      --  nodes because those will always be enclosed by some top level ignored\n+      --  Ghost node.\n+\n+      if Is_Body (N)\n+        or else Is_Declaration (N)\n+        or else Nkind (N) in N_Generic_Instantiation\n+        or else Nkind (N) in N_Push_Pop_xxx_Label\n+        or else Nkind (N) in N_Raise_xxx_Error\n+        or else Nkind (N) in N_Representation_Clause\n+        or else Nkind_In (N, N_Assignment_Statement,\n+                             N_Call_Marker,\n+                             N_Freeze_Entity,\n+                             N_Freeze_Generic_Entity,\n+                             N_Itype_Reference,\n+                             N_Pragma,\n+                             N_Procedure_Call_Statement,\n+                             N_Use_Package_Clause,\n+                             N_Use_Type_Clause,\n+                             N_Variable_Reference_Marker,\n+                             N_With_Clause)\n+      then\n+         --  Only ignored Ghost nodes must be recorded in the table\n \n-      Add_Ignored_Ghost_Unit (Cunit (Get_Code_Unit (N)));\n-   end Propagate_Ignored_Ghost_Code;\n+         pragma Assert (Is_Ignored_Ghost_Node (N));\n+         Ignored_Ghost_Nodes.Append (N);\n+      end if;\n+   end Record_Ignored_Ghost_Node;\n \n    -------------------------------\n    -- Remove_Ignored_Ghost_Code --\n    -------------------------------\n \n    procedure Remove_Ignored_Ghost_Code is\n-      procedure Prune_Tree (Root : Node_Id);\n-      --  Remove all code marked as ignored Ghost from the tree of denoted by\n-      --  Root.\n-\n-      ----------------\n-      -- Prune_Tree --\n-      ----------------\n-\n-      procedure Prune_Tree (Root : Node_Id) is\n-         procedure Prune (N : Node_Id);\n-         --  Remove a given node from the tree by rewriting it into null\n-\n-         function Prune_Node (N : Node_Id) return Traverse_Result;\n-         --  Determine whether node N denotes an ignored Ghost construct. If\n-         --  this is the case, rewrite N as a null statement. See the body for\n-         --  special cases.\n-\n-         -----------\n-         -- Prune --\n-         -----------\n-\n-         procedure Prune (N : Node_Id) is\n-         begin\n-            --  Destroy any aspects that may be associated with the node\n-\n-            if Permits_Aspect_Specifications (N) and then Has_Aspects (N) then\n-               Remove_Aspects (N);\n-            end if;\n-\n-            Rewrite (N, Make_Null_Statement (Sloc (N)));\n-         end Prune;\n-\n-         ----------------\n-         -- Prune_Node --\n-         ----------------\n-\n-         function Prune_Node (N : Node_Id) return Traverse_Result is\n-            Id : Entity_Id;\n-\n-         begin\n-            --  Do not prune compilation unit nodes because many mechanisms\n-            --  depend on their presence. Note that context items are still\n-            --  being processed.\n+      procedure Remove_Ignored_Ghost_Node (N : Node_Id);\n+      --  Eliminate ignored Ghost node N from the tree\n \n-            if Nkind (N) = N_Compilation_Unit then\n-               return OK;\n+      -------------------------------\n+      -- Remove_Ignored_Ghost_Node --\n+      -------------------------------\n \n-            --  The node is either declared as ignored Ghost or is a byproduct\n-            --  of expansion. Destroy it and stop the traversal on this branch.\n-\n-            elsif Is_Ignored_Ghost_Node (N) then\n-               Prune (N);\n-               return Skip;\n-\n-            --  Scoping constructs such as blocks, packages, subprograms and\n-            --  bodies offer some flexibility with respect to pruning.\n-\n-            elsif Nkind_In (N, N_Block_Statement,\n-                               N_Package_Body,\n-                               N_Package_Declaration,\n-                               N_Subprogram_Body,\n-                               N_Subprogram_Declaration)\n-            then\n-               if Nkind (N) = N_Block_Statement then\n-                  Id := Entity (Identifier (N));\n-               else\n-                  Id := Defining_Entity (N);\n-               end if;\n-\n-               --  The scoping construct contains both living and ignored Ghost\n-               --  code, let the traversal prune all relevant nodes.\n+      procedure Remove_Ignored_Ghost_Node (N : Node_Id) is\n+      begin\n+         --  The generation and processing of ignored Ghost nodes may cause the\n+         --  same node to be saved multiple times. Reducing the number of saves\n+         --  to one involves costly solutions such as a hash table or the use\n+         --  of a flag shared by all nodes. To solve this problem, the removal\n+         --  machinery allows for multiple saves, but does not eliminate a node\n+         --  which has already been eliminated.\n \n-               if Contains_Ignored_Ghost_Code (Id) then\n-                  return OK;\n+         if Nkind (N) = N_Null_Statement then\n+            null;\n \n-               --  Otherwise the construct contains only living code and should\n-               --  not be pruned.\n+         --  Otherwise the ignored Ghost node must be eliminated\n \n-               else\n-                  return Skip;\n-               end if;\n+         else\n+            --  Only ignored Ghost nodes must be eliminated from the tree\n \n-            --  Otherwise keep searching for ignored Ghost nodes\n+            pragma Assert (Is_Ignored_Ghost_Node (N));\n \n-            else\n-               return OK;\n-            end if;\n-         end Prune_Node;\n+            --  Eliminate the node by rewriting it into null. Another option\n+            --  is to remove it from the tree, however multiple corner cases\n+            --  emerge which have be dealt individually.\n \n-         procedure Prune_Nodes is new Traverse_Proc (Prune_Node);\n+            Rewrite (N, Make_Null_Statement (Sloc (N)));\n \n-      --  Start of processing for Prune_Tree\n+            --  Eliminate any aspects hanging off the ignored Ghost node\n \n-      begin\n-         Prune_Nodes (Root);\n-      end Prune_Tree;\n+            Remove_Aspects (N);\n+         end if;\n+      end Remove_Ignored_Ghost_Node;\n \n    --  Start of processing for Remove_Ignored_Ghost_Code\n \n    begin\n-      for Index in Ignored_Ghost_Units.First .. Ignored_Ghost_Units.Last loop\n-         Prune_Tree (Ignored_Ghost_Units.Table (Index));\n+      for Index in Ignored_Ghost_Nodes.First .. Ignored_Ghost_Nodes.Last loop\n+         Remove_Ignored_Ghost_Node (Ignored_Ghost_Nodes.Table (Index));\n       end loop;\n    end Remove_Ignored_Ghost_Code;\n "}, {"sha": "c079595f6c50efcf2275904b59d5faf83978074b", "filename": "gcc/ada/ghost.ads", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f94b75b8ccd47afa55c6109a5899f325a61ee/gcc%2Fada%2Fghost.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f94b75b8ccd47afa55c6109a5899f325a61ee/gcc%2Fada%2Fghost.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fghost.ads?ref=980f94b75b8ccd47afa55c6109a5899f325a61ee", "patch": "@@ -31,10 +31,6 @@ with Types; use Types;\n \n package Ghost is\n \n-   procedure Add_Ignored_Ghost_Unit (Unit : Node_Id);\n-   --  Add a single ignored Ghost compilation unit to the internal table for\n-   --  post processing.\n-\n    procedure Check_Ghost_Completion\n      (Prev_Id  : Entity_Id;\n       Compl_Id : Entity_Id);"}, {"sha": "f5381447b32867266247a9ed17edb0c3a22bbdf1", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f94b75b8ccd47afa55c6109a5899f325a61ee/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f94b75b8ccd47afa55c6109a5899f325a61ee/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=980f94b75b8ccd47afa55c6109a5899f325a61ee", "patch": "@@ -3782,9 +3782,7 @@ package body Sem_Ch8 is\n \n       --  Local variables\n \n-      Ghost_Id  : Entity_Id := Empty;\n-      Living_Id : Entity_Id := Empty;\n-      Pack      : Entity_Id;\n+      Pack : Entity_Id;\n \n    --  Start of processing for Analyze_Use_Package\n \n@@ -3870,22 +3868,9 @@ package body Sem_Ch8 is\n          end if;\n \n          Use_One_Package (N, Name (N));\n-\n-         --  Capture the first Ghost package and the first living package\n-\n-         if Is_Entity_Name (Name (N)) then\n-            Pack := Entity (Name (N));\n-\n-            if Is_Ghost_Entity (Pack) then\n-               if No (Ghost_Id) then\n-                  Ghost_Id := Pack;\n-               end if;\n-\n-            elsif No (Living_Id) then\n-               Living_Id := Pack;\n-            end if;\n-         end if;\n       end if;\n+\n+      Mark_Ghost_Clause (N);\n    end Analyze_Use_Package;\n \n    ----------------------"}, {"sha": "bc44cd35dccc1974d4d253404960831f14660e7b", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/980f94b75b8ccd47afa55c6109a5899f325a61ee/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/980f94b75b8ccd47afa55c6109a5899f325a61ee/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=980f94b75b8ccd47afa55c6109a5899f325a61ee", "patch": "@@ -13401,12 +13401,7 @@ package body Sem_Util is\n \n    function Is_Body_Or_Package_Declaration (N : Node_Id) return Boolean is\n    begin\n-      return Nkind_In (N, N_Entry_Body,\n-                          N_Package_Body,\n-                          N_Package_Declaration,\n-                          N_Protected_Body,\n-                          N_Subprogram_Body,\n-                          N_Task_Body);\n+      return Is_Body (N) or else Nkind (N) = N_Package_Declaration;\n    end Is_Body_Or_Package_Declaration;\n \n    -----------------------"}]}