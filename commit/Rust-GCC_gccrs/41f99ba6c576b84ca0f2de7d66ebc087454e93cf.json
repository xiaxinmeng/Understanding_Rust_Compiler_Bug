{"sha": "41f99ba6c576b84ca0f2de7d66ebc087454e93cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFmOTliYTZjNTc2Yjg0Y2EwZjJkZTdkNjZlYmMwODc0NTRlOTNjZg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-03-05T17:06:58Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-03-06T21:37:36Z"}, "message": "analyzer: improvements to state dumping\n\nThis patch fixes a bug in which summarized state dumps involving a\nnon-NULL pointer to a region for which get_representative_path_var\nreturned NULL were erroneously dumped as \"NULL\".\n\nIt also extends sm-state dumps so that they show representative tree\nvalues, where available.\n\nFinally, it adds some selftest coverage for such dumps.  Doing so\nrequires replacing some %qE with a dump_quoted_tree, to avoid\nC vs C++ differences between \"make selftest-c\" and \"make selftest-c++\".\n\ngcc/analyzer/ChangeLog:\n\t* analyzer.h (dump_quoted_tree): New decl.\n\t* engine.cc (exploded_node::dump_dot): Pass region model to\n\tsm_state_map::print.\n\t* program-state.cc: Include diagnostic-core.h.\n\t(sm_state_map::print): Add \"model\" param and use it to print\n\trepresentative trees.  Only print origin information if non-null.\n\t(sm_state_map::dump): Pass NULL for model to print call.\n\t(program_state::print): Pass region model to sm_state_map::print.\n\t(program_state::dump_to_pp): Use spaces rather than newlines when\n\tsummarizing.  Pass region_model to sm_state_map::print.\n\t(ana::selftest::assert_dump_eq): New function.\n\t(ASSERT_DUMP_EQ): New macro.\n\t(ana::selftest::test_program_state_dumping): New function.\n\t(ana::selftest::analyzer_program_state_cc_tests): Call it.\n\t* program-state.h (program_state::print): Add model param.\n\t* region-model.cc (dump_quoted_tree): New function.\n\t(map_region::print_fields): Use dump_quoted_tree rather than\n\t%qE to avoid lang-dependent output.\n\t(map_region::dump_child_label): Likewise.\n\t(region_model::dump_summary_of_map): For SK_REGION, when\n\tget_representative_path_var fails, print the region id rather than\n\terroneously printing NULL.\n\t* sm.cc (state_machine::get_state_by_name): New function.\n\t* sm.h (state_machine::get_state_by_name): New decl.", "tree": {"sha": "d154bf8465be154a7a5df5673bf4925b8161ff52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d154bf8465be154a7a5df5673bf4925b8161ff52"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41f99ba6c576b84ca0f2de7d66ebc087454e93cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41f99ba6c576b84ca0f2de7d66ebc087454e93cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41f99ba6c576b84ca0f2de7d66ebc087454e93cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41f99ba6c576b84ca0f2de7d66ebc087454e93cf/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "191bcd0f30dd37dec773efb0125afdcae9bd90ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/191bcd0f30dd37dec773efb0125afdcae9bd90ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/191bcd0f30dd37dec773efb0125afdcae9bd90ef"}], "stats": {"total": 214, "additions": 188, "deletions": 26}, "files": [{"sha": "84c619e40c444a00f9ede6863ba053c6ddacbd94", "filename": "gcc/analyzer/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f99ba6c576b84ca0f2de7d66ebc087454e93cf/gcc%2Fanalyzer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f99ba6c576b84ca0f2de7d66ebc087454e93cf/gcc%2Fanalyzer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2FChangeLog?ref=41f99ba6c576b84ca0f2de7d66ebc087454e93cf", "patch": "@@ -1,3 +1,30 @@\n+2020-03-06  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* analyzer.h (dump_quoted_tree): New decl.\n+\t* engine.cc (exploded_node::dump_dot): Pass region model to\n+\tsm_state_map::print.\n+\t* program-state.cc: Include diagnostic-core.h.\n+\t(sm_state_map::print): Add \"model\" param and use it to print\n+\trepresentative trees.  Only print origin information if non-null.\n+\t(sm_state_map::dump): Pass NULL for model to print call.\n+\t(program_state::print): Pass region model to sm_state_map::print.\n+\t(program_state::dump_to_pp): Use spaces rather than newlines when\n+\tsummarizing.  Pass region_model to sm_state_map::print.\n+\t(ana::selftest::assert_dump_eq): New function.\n+\t(ASSERT_DUMP_EQ): New macro.\n+\t(ana::selftest::test_program_state_dumping): New function.\n+\t(ana::selftest::analyzer_program_state_cc_tests): Call it.\n+\t* program-state.h (program_state::print): Add model param.\n+\t* region-model.cc (dump_quoted_tree): New function.\n+\t(map_region::print_fields): Use dump_quoted_tree rather than\n+\t%qE to avoid lang-dependent output.\n+\t(map_region::dump_child_label): Likewise.\n+\t(region_model::dump_summary_of_map): For SK_REGION, when\n+\tget_representative_path_var fails, print the region id rather than\n+\terroneously printing NULL.\n+\t* sm.cc (state_machine::get_state_by_name): New function.\n+\t* sm.h (state_machine::get_state_by_name): New decl.\n+\n 2020-03-04  David Malcolm  <dmalcolm@redhat.com>\n \n \t* region-model.cc (region::validate): Convert model param from ptr"}, {"sha": "78d6009e8a3ace8af8e859f9891df6088cde7dc1", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f99ba6c576b84ca0f2de7d66ebc087454e93cf/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f99ba6c576b84ca0f2de7d66ebc087454e93cf/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=41f99ba6c576b84ca0f2de7d66ebc087454e93cf", "patch": "@@ -21,12 +21,12 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_ANALYZER_ANALYZER_H\n #define GCC_ANALYZER_ANALYZER_H\n \n-/* Forward decls of common types, with indentation to show inheritance.  */\n-\n class graphviz_out;\n \n namespace ana {\n \n+/* Forward decls of common types, with indentation to show inheritance.  */\n+\n class supergraph;\n class supernode;\n class superedge;\n@@ -71,6 +71,10 @@ class state_purge_per_ssa_name;\n class state_change;\n class rewind_info_t;\n \n+/* Forward decls of functions.  */\n+\n+extern void dump_quoted_tree (pretty_printer *pp, tree t);\n+\n } // namespace ana\n \n extern bool is_special_named_call_p (const gcall *call, const char *funcname,"}, {"sha": "2431ae344741f5391d2acbff36469aa6c01817fe", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f99ba6c576b84ca0f2de7d66ebc087454e93cf/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f99ba6c576b84ca0f2de7d66ebc087454e93cf/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=41f99ba6c576b84ca0f2de7d66ebc087454e93cf", "patch": "@@ -869,7 +869,7 @@ exploded_node::dump_dot (graphviz_out *gv, const dump_args_t &args) const\n \tif (!smap->is_empty_p ())\n \t  {\n \t    pp_printf (pp, \"%s: \", ext_state.get_name (i));\n-\t    smap->print (ext_state.get_sm (i), pp);\n+\t    smap->print (ext_state.get_sm (i), state.m_region_model, pp);\n \t    pp_newline (pp);\n \t  }\n       }"}, {"sha": "804800f65fe991073552e990ac594e4bbba2815b", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 116, "deletions": 12, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f99ba6c576b84ca0f2de7d66ebc087454e93cf/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f99ba6c576b84ca0f2de7d66ebc087454e93cf/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=41f99ba6c576b84ca0f2de7d66ebc087454e93cf", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tree.h\"\n+#include \"diagnostic-core.h\"\n #include \"diagnostic.h\"\n #include \"function.h\"\n #include \"analyzer/analyzer.h\"\n@@ -147,10 +148,13 @@ sm_state_map::clone_with_remapping (const one_way_svalue_id_map &id_map) const\n   return result;\n }\n \n-/* Print this sm_state_map (for SM) to PP.  */\n+/* Print this sm_state_map (for SM) to PP.\n+   If MODEL is non-NULL, print representative tree values where\n+   available.  */\n \n void\n-sm_state_map::print (const state_machine &sm, pretty_printer *pp) const\n+sm_state_map::print (const state_machine &sm, const region_model *model,\n+\t\t     pretty_printer *pp) const\n {\n   bool first = true;\n   pp_string (pp, \"{\");\n@@ -170,10 +174,27 @@ sm_state_map::print (const state_machine &sm, pretty_printer *pp) const\n       sid.print (pp);\n \n       entry_t e = (*iter).second;\n-      pp_printf (pp, \": %s (origin: \",\n-\t\t sm.get_state_name (e.m_state));\n-      e.m_origin.print (pp);\n-      pp_string (pp, \")\");\n+      pp_printf (pp, \": %s\", sm.get_state_name (e.m_state));\n+      if (model)\n+\tif (tree rep = model->get_representative_tree (sid))\n+\t  {\n+\t    pp_string (pp, \" (\");\n+\t    dump_quoted_tree (pp, rep);\n+\t    pp_character (pp, ')');\n+\t  }\n+      if (!e.m_origin.null_p ())\n+\t{\n+\t  pp_string (pp, \" (origin: \");\n+\t  e.m_origin.print (pp);\n+\t  if (model)\n+\t    if (tree rep = model->get_representative_tree (e.m_origin))\n+\t      {\n+\t\tpp_string (pp, \" (\");\n+\t\tdump_quoted_tree (pp, rep);\n+\t\tpp_character (pp, ')');\n+\t      }\n+\t  pp_string (pp, \")\");\n+\t}\n     }\n   pp_string (pp, \"}\");\n }\n@@ -186,7 +207,7 @@ sm_state_map::dump (const state_machine &sm) const\n   pretty_printer pp;\n   pp_show_color (&pp) = pp_show_color (global_dc->printer);\n   pp.buffer->stream = stderr;\n-  print (sm, &pp);\n+  print (sm, NULL, &pp);\n   pp_newline (&pp);\n   pp_flush (&pp);\n }\n@@ -696,7 +717,7 @@ program_state::print (const extrinsic_state &ext_state,\n       if (!smap->is_empty_p ())\n \t{\n \t  pp_printf (pp, \"%s: \", ext_state.get_name (i));\n-\t  smap->print (ext_state.get_sm (i), pp);\n+\t  smap->print (ext_state.get_sm (i), m_region_model, pp);\n \t  pp_newline (pp);\n \t}\n     }\n@@ -707,7 +728,9 @@ program_state::print (const extrinsic_state &ext_state,\n     }\n }\n \n-/* Dump a multiline representation of this state to PP.  */\n+/* Dump a representation of this state to PP.\n+   If SUMMARIZE is true, print a one-line summary;\n+   if false, print a detailed multiline representation.  */\n \n void\n program_state::dump_to_pp (const extrinsic_state &ext_state,\n@@ -723,16 +746,22 @@ program_state::dump_to_pp (const extrinsic_state &ext_state,\n     {\n       if (!smap->is_empty_p ())\n \t{\n+\t  if (summarize)\n+\t    pp_space (pp);\n \t  pp_printf (pp, \"%s: \", ext_state.get_name (i));\n-\t  smap->print (ext_state.get_sm (i), pp);\n-\t  pp_newline (pp);\n+\t  smap->print (ext_state.get_sm (i), m_region_model, pp);\n+\t  if (!summarize)\n+\t    pp_newline (pp);\n \t}\n     }\n \n   if (!m_valid)\n     {\n+      if (summarize)\n+\tpp_space (pp);\n       pp_printf (pp, \"invalid state\");\n-      pp_newline (pp);\n+      if (!summarize)\n+\tpp_newline (pp);\n     }\n }\n \n@@ -1231,6 +1260,30 @@ state_change::validate (const program_state &new_state,\n \n namespace selftest {\n \n+/* Implementation detail of ASSERT_DUMP_EQ.  */\n+\n+static void\n+assert_dump_eq (const location &loc,\n+\t\tconst program_state &state,\n+\t\tconst extrinsic_state &ext_state,\n+\t\tbool summarize,\n+\t\tconst char *expected)\n+{\n+  auto_fix_quotes sentinel;\n+  pretty_printer pp;\n+  pp_format_decoder (&pp) = default_tree_printer;\n+  state.dump_to_pp (ext_state, summarize, &pp);\n+  ASSERT_STREQ_AT (loc, pp_formatted_text (&pp), expected);\n+}\n+\n+/* Assert that STATE.dump_to_pp (SUMMARIZE) is EXPECTED.  */\n+\n+#define ASSERT_DUMP_EQ(STATE, EXT_STATE, SUMMARIZE, EXPECTED)\t\t\\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n+  assert_dump_eq ((SELFTEST_LOCATION), (STATE), (EXT_STATE), (SUMMARIZE), \\\n+\t\t  (EXPECTED));\t\t\t\t\t\t\\\n+  SELFTEST_END_STMT\n+\n /* Tests for sm_state_map.  */\n \n static void\n@@ -1364,6 +1417,56 @@ test_sm_state_map ()\n   // TODO: coverage for purging\n }\n \n+/* Verify that program_state::dump_to_pp works as expected.  */\n+\n+static void\n+test_program_state_dumping ()\n+{\n+  /* Create a program_state for a global ptr \"p\" that has\n+     malloc sm-state, pointing to a region on the heap.  */\n+  tree p = build_global_decl (\"p\", ptr_type_node);\n+\n+  state_machine *sm = make_malloc_state_machine (NULL);\n+  const state_machine::state_t UNCHECKED_STATE\n+    = sm->get_state_by_name (\"unchecked\");\n+  auto_delete_vec <state_machine> checkers;\n+  checkers.safe_push (sm);\n+  extrinsic_state ext_state (checkers);\n+\n+  program_state s (ext_state);\n+  region_model *model = s.m_region_model;\n+  region_id new_rid = model->add_new_malloc_region ();\n+  svalue_id ptr_sid\n+      = model->get_or_create_ptr_svalue (ptr_type_node, new_rid);\n+  model->set_value (model->get_lvalue (p, NULL),\n+\t\t    ptr_sid, NULL);\n+  sm_state_map *smap = s.m_checker_states[0];\n+\n+  smap->impl_set_state (ptr_sid, UNCHECKED_STATE, svalue_id::null ());\n+  ASSERT_EQ (smap->get_state (ptr_sid), UNCHECKED_STATE);\n+\n+  ASSERT_DUMP_EQ\n+    (s, ext_state, false,\n+     \"rmodel: r0: {kind: `root', parent: null, sval: null}\\n\"\n+     \"|-heap: r1: {kind: `heap', parent: r0, sval: sv0}\\n\"\n+     \"|  |: sval: sv0: {poisoned: uninit}\\n\"\n+     \"|  `-r2: {kind: `symbolic', parent: r1, sval: null}\\n\"\n+     \"`-globals: r3: {kind: `globals', parent: r0, sval: null, map: {`p': r4}}\\n\"\n+     \"  `-`p': r4: {kind: `primitive', parent: r3, sval: sv1, type: `void *'}\\n\"\n+     \"    |: sval: sv1: {type: `void *', &r2}\\n\"\n+     \"    |: type: `void *'\\n\"\n+     \"svalues:\\n\"\n+     \"  sv0: {poisoned: uninit}\\n\"\n+     \"  sv1: {type: `void *', &r2}\\n\"\n+     \"constraint manager:\\n\"\n+     \"  equiv classes:\\n\"\n+     \"  constraints:\\n\"\n+     \"malloc: {sv1: unchecked (`p')}\\n\");\n+\n+  ASSERT_DUMP_EQ (s, ext_state, true,\n+\t\t  \"rmodel: p: &r2 malloc: {sv1: unchecked (`p')}\");\n+}\n+\n /* Verify that program_states with identical sm-state can be merged,\n    and that the merged program_state preserves the sm-state.  */\n \n@@ -1466,6 +1569,7 @@ void\n analyzer_program_state_cc_tests ()\n {\n   test_sm_state_map ();\n+  test_program_state_dumping ();\n   test_program_state_merging ();\n   test_program_state_merging_2 ();\n }"}, {"sha": "3637516ec1bcee05b3a3edd9d2fd01e9270aa382", "filename": "gcc/analyzer/program-state.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f99ba6c576b84ca0f2de7d66ebc087454e93cf/gcc%2Fanalyzer%2Fprogram-state.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f99ba6c576b84ca0f2de7d66ebc087454e93cf/gcc%2Fanalyzer%2Fprogram-state.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.h?ref=41f99ba6c576b84ca0f2de7d66ebc087454e93cf", "patch": "@@ -146,7 +146,8 @@ class sm_state_map\n   sm_state_map *\n   clone_with_remapping (const one_way_svalue_id_map &id_map) const;\n \n-  void print (const state_machine &sm, pretty_printer *pp) const;\n+  void print (const state_machine &sm, const region_model *model,\n+\t      pretty_printer *pp) const;\n   void dump (const state_machine &sm) const;\n \n   bool is_empty_p () const;"}, {"sha": "e7e517ade15e21019b4fbcd3d2f918ac9926fbe0", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f99ba6c576b84ca0f2de7d66ebc087454e93cf/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f99ba6c576b84ca0f2de7d66ebc087454e93cf/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=41f99ba6c576b84ca0f2de7d66ebc087454e93cf", "patch": "@@ -73,6 +73,17 @@ dump_tree (pretty_printer *pp, tree t)\n   dump_generic_node (pp, t, 0, TDF_SLIM, 0);\n }\n \n+/* Dump T to PP in language-independent form in quotes, for\n+   debugging/logging/dumping purposes.  */\n+\n+void\n+dump_quoted_tree (pretty_printer *pp, tree t)\n+{\n+  pp_begin_quote (pp, pp_show_color (pp));\n+  dump_tree (pp, t);\n+  pp_end_quote (pp, pp_show_color (pp));\n+}\n+\n /* Equivalent to pp_printf (pp, \"%qT\", t), to avoid nesting pp_printf\n    calls within other pp_printf calls.\n \n@@ -1595,7 +1606,8 @@ map_region::print_fields (const region_model &model,\n \tpp_string (pp, \", \");\n       tree expr = (*iter).first;\n       region_id child_rid = (*iter).second;\n-      pp_printf (pp, \"%qE: \", expr);\n+      dump_quoted_tree (pp, expr);\n+      pp_string (pp, \": \");\n       child_rid.print (pp);\n     }\n   pp_string (pp, \"}\");\n@@ -1665,10 +1677,8 @@ map_region::dump_child_label (const region_model &model,\n       if (child_rid == (*iter).second)\n \t{\n \t  tree key = (*iter).first;\n-\t  if (DECL_P (key))\n-\t    pp_printf (pp, \"%qD: \", key);\n-\t  else\n-\t    pp_printf (pp, \"%qE: \", key);\n+\t  dump_quoted_tree (pp, key);\n+\t  pp_string (pp, \": \");\n \t}\n     }\n }\n@@ -3706,17 +3716,16 @@ region_model::dump_summary_of_map (pretty_printer *pp,\n \t  {\n \t    region_svalue *region_sval = as_a <region_svalue *> (sval);\n \t    region_id pointee_rid = region_sval->get_pointee ();\n+\t    gcc_assert (!pointee_rid.null_p ());\n \t    tree pointee = get_representative_path_var (pointee_rid).m_tree;\n \t    dump_separator (pp, is_first);\n \t    dump_tree (pp, key);\n \t    pp_string (pp, \": \");\n+\t    pp_character (pp, '&');\n \t    if (pointee)\n-\t      {\n-\t\tpp_character (pp, '&');\n-\t\tdump_tree (pp, pointee);\n-\t      }\n+\t      dump_tree (pp, pointee);\n \t    else\n-\t      pp_string (pp, \"NULL\");\n+\t      pointee_rid.print (pp);\n \t  }\n \t  break;\n \tcase SK_CONSTANT:"}, {"sha": "affb5aa07db831ab894d053865f3312c38ee6a30", "filename": "gcc/analyzer/sm.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f99ba6c576b84ca0f2de7d66ebc087454e93cf/gcc%2Fanalyzer%2Fsm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f99ba6c576b84ca0f2de7d66ebc087454e93cf/gcc%2Fanalyzer%2Fsm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.cc?ref=41f99ba6c576b84ca0f2de7d66ebc087454e93cf", "patch": "@@ -84,6 +84,21 @@ state_machine::get_state_name (state_t s) const\n   return m_state_names[s];\n }\n \n+/* Get the state with name NAME, which must exist.\n+   This is purely intended for use in selftests.  */\n+\n+state_machine::state_t\n+state_machine::get_state_by_name (const char *name)\n+{\n+  unsigned i;\n+  const char *iter_name;\n+  FOR_EACH_VEC_ELT (m_state_names, i, iter_name)\n+    if (!strcmp (name, iter_name))\n+      return i;\n+  /* Name not found.  */\n+  gcc_unreachable ();\n+}\n+\n /* Assert that S is a valid state for this state_machine.  */\n \n void"}, {"sha": "ebd067a4541e32c9c2383d0e61f2a56dd41b6530", "filename": "gcc/analyzer/sm.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41f99ba6c576b84ca0f2de7d66ebc087454e93cf/gcc%2Fanalyzer%2Fsm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41f99ba6c576b84ca0f2de7d66ebc087454e93cf/gcc%2Fanalyzer%2Fsm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.h?ref=41f99ba6c576b84ca0f2de7d66ebc087454e93cf", "patch": "@@ -57,6 +57,8 @@ class state_machine : public log_user\n \n   const char *get_state_name (state_t s) const;\n \n+  state_t get_state_by_name (const char *name);\n+\n   /* Return true if STMT is a function call recognized by this sm.  */\n   virtual bool on_stmt (sm_context *sm_ctxt,\n \t\t\tconst supernode *node,"}]}