{"sha": "4d9192b50c325156ab000884a57a3d7cfe4f79c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ5MTkyYjUwYzMyNTE1NmFiMDAwODg0YTU3YTNkN2NmZTRmNzljNg==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2013-09-18T02:39:50Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-09-18T02:39:50Z"}, "message": "compare-elim.c (find_comparison_dom_walker): New class\n\n\t* compare-elim.c (find_comparison_dom_walker): New class\n\t(find_comparisons_in_bb): Rename to\n\tfind_comparison_dom_walker::before_dom_children\n\t(find_comparisons): Adjust\n\t* domwalk.c (walk_dominator_tree): Rename to dom_walker::walk, and\n\tadjust.\n\t(init_walk_dominator_tree, fini_walk_dominator_tree): Remove\n\t* domwalk.h (dom_walk_data): Convert it To a class dom_walker.\n\t(init_walk_dominator_tree): Remove declaration.\n\t(fini_walk_dominator_tree): Remove declaration.\n\t* fwprop.c (single_def_use_dom_walker): New class\n\t(single_def_use_enter_block): Convert to\n\tsingle_def_use_dom_walker::before_dom_children.\n\t(single_def_use_leave_block): Convert to\n\tsingle_def_use_dom_walker::after_dom_children.\n\t(build_single_def_use_links): Adjust.\n\t* gimple-ssa-strength-reduction.c (find_candidates_dom_walker): New\n\tclass.\n\t(find_candidates_in_block): Convert to\n\tfind_candidates_dom_walker::before_dom_children.\n\t(execute_strength_reduction): Adjust.\n\t* graphite-sese-to-poly.c (struct bsc, build_sese_conditions): Remove.\n\t(sese_dom_walker): New class.\n\t(sese_dom_walker::sese_dom_walker): New constructor.\n\t(sese_dom_walker::~sese_dom_walker): New destructor.\n\t(build_sese_conditions_before): Convert to\n\tsese_dom_walker::before_dom_children.\n\t(build_sese_conditions_after): Convert to\n\tsese_dom_walker::after_dom_children.\n\t(build_poly_scop): Adjust\n\t* tree-into-ssa.c (rewrite_dom_walker): New class\n\t(rewrite_enter_block): Convert to\n\trewrite_dom_walker::before_dom_children.\n\t(rewrite_leave_block): Convert to\n\trewrite_dom_walker::after_dom_children.\n\t(rewrite_update_dom_walker): New class.\n\t(rewrite_update_enter_block): Convert to\n\trewrite_update_dom_walker::before_dom_children.\n\t(rewrite_update_leave_block): Convert to\n\trewrite_update_dom_walker::after_dom_children.\n\t(rewrite_blocks, rewrite_into_ssa): Adjust.\n\t(mark_def_dom_walker): New class.\n\t(mark_def_dom_walker::mark_def_dom_walker): New constructor.\n\t(mark_def_dom_walker::~mark_def_dom_walker): New destructor.\n\t(mark_def_sites_blocks): Convert to\n\tmark_def_dom_walker::before_dom_children.\n\t(mark_def_site_blocks): Remove.\n\t* tree-ssa-dom.c (dom_opt_dom_walker): New class.\n\t(tree_ssa_dominator_optimize): Adjust.\n\t(dom_thread_across_edge): Convert to method\n\tdom_opt_dom_walker::thread_across_edge.\n\t(dom_opt_enter_block): Convert to member function\n\tdom_opt_dom_walker::before_dom_children.\n\t(dom_opt_leave_block): Convert to member function\n\tdom_opt_dom_walker::after_dom_children.\n\t* tree-ssa-dse.c (dse_dom_walker): New class.\n\t(dse_enter_block): Convert to member function\n\tdse_dom_walker::before_dom_children.\n\t(tree_ssa_dse): Adjust.\n\t* tree-ssa-loop-im.c (invariantness_dom_walker): New class.\n\t(determine_invariantness_stmt): Convert to method\n\tinvariantness_dom_walker::before_dom_children.\n\t(determine_invariantness): Remove\n\t(move_computations_dom_walker): New class.\n\t(move_computations_stmt): Convert to method\n\tmove_computations_dom_walker::before_dom_children.\n\t(move_computations, tree_ssa_lim): Adjust.\n\t* tree-ssa-phiopt.c (nontrapping_dom_walker): new class\n\t(nt_init_block): Make method\n\tnotrappping_dom_walker::before_dom_children.\n\t(nt_fini_block): Make\n\tmethod nontrapping_dom_walker::after_dom_children.\n\t(get_non_trapping): Adjust.\n\t* tree-ssa-pre.c (eliminate_dom_walker): New class.\n\t(eliminate_bb): Make method eliminate_dom_walker::before_dom_children.\n\t(eliminate_leave_block): Make method.\n\teliminate_dom_walker::after_dom_children.\n\t(eliminate): Adjust\n\t* tree-ssa-strlen.c (strlen_dom_walker): New class.\n\t(strlen_enter_block): Make method\n\tstrlen_dom_walker::before_dom_children.\n\t(strlen_leave_block): Make\n\tmethod strlen_dom_walker::after_dom_children.\n\t(tree_ssa_strlen): Adjust.\n\t* tree-ssa-uncprop.c (uncprop_dom_walker): New class.\n\t(tree_ssa_uncprop): Adjust.\n\t(uncprop_leave_block): Make method\n\tuncprop_dom_walker::after_dom_children.\n\t(uncprop_leave_block): Make method\n\tuncprop_dom_walker::before_dom_children.\n\nFrom-SVN: r202679", "tree": {"sha": "20df7a9ff9e90aef22efdbedc2005fb546209870", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20df7a9ff9e90aef22efdbedc2005fb546209870"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d9192b50c325156ab000884a57a3d7cfe4f79c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d9192b50c325156ab000884a57a3d7cfe4f79c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d9192b50c325156ab000884a57a3d7cfe4f79c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d9192b50c325156ab000884a57a3d7cfe4f79c6/comments", "author": null, "committer": null, "parents": [{"sha": "3b3cc26bcc127eceeb6d257313555fc2149cf6d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b3cc26bcc127eceeb6d257313555fc2149cf6d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b3cc26bcc127eceeb6d257313555fc2149cf6d4"}], "stats": {"total": 941, "additions": 424, "deletions": 517}, "files": [{"sha": "c28bd10e6a60b6a2e04b7047c1214c700e4f057c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d9192b50c325156ab000884a57a3d7cfe4f79c6", "patch": "@@ -1,3 +1,96 @@\n+2013-09-17  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* compare-elim.c (find_comparison_dom_walker): New class\n+\t(find_comparisons_in_bb): Rename to\n+\tfind_comparison_dom_walker::before_dom_children\n+\t(find_comparisons): Adjust\n+\t* domwalk.c (walk_dominator_tree): Rename to dom_walker::walk, and\n+\tadjust.\n+\t(init_walk_dominator_tree, fini_walk_dominator_tree): Remove\n+\t* domwalk.h (dom_walk_data): Convert it To a class dom_walker.\n+\t(init_walk_dominator_tree): Remove declaration.\n+\t(fini_walk_dominator_tree): Remove declaration.\n+\t* fwprop.c (single_def_use_dom_walker): New class\n+\t(single_def_use_enter_block): Convert to\n+\tsingle_def_use_dom_walker::before_dom_children.\n+\t(single_def_use_leave_block): Convert to\n+\tsingle_def_use_dom_walker::after_dom_children.\n+\t(build_single_def_use_links): Adjust.\n+\t* gimple-ssa-strength-reduction.c (find_candidates_dom_walker): New\n+\tclass.\n+\t(find_candidates_in_block): Convert to\n+\tfind_candidates_dom_walker::before_dom_children.\n+\t(execute_strength_reduction): Adjust.\n+\t* graphite-sese-to-poly.c (struct bsc, build_sese_conditions): Remove.\n+\t(sese_dom_walker): New class.\n+\t(sese_dom_walker::sese_dom_walker): New constructor.\n+\t(sese_dom_walker::~sese_dom_walker): New destructor.\n+\t(build_sese_conditions_before): Convert to\n+\tsese_dom_walker::before_dom_children.\n+\t(build_sese_conditions_after): Convert to\n+\tsese_dom_walker::after_dom_children.\n+\t(build_poly_scop): Adjust\n+\t* tree-into-ssa.c (rewrite_dom_walker): New class\n+\t(rewrite_enter_block): Convert to\n+\trewrite_dom_walker::before_dom_children.\n+\t(rewrite_leave_block): Convert to\n+\trewrite_dom_walker::after_dom_children.\n+\t(rewrite_update_dom_walker): New class.\n+\t(rewrite_update_enter_block): Convert to\n+\trewrite_update_dom_walker::before_dom_children.\n+\t(rewrite_update_leave_block): Convert to\n+\trewrite_update_dom_walker::after_dom_children.\n+\t(rewrite_blocks, rewrite_into_ssa): Adjust.\n+\t(mark_def_dom_walker): New class.\n+\t(mark_def_dom_walker::mark_def_dom_walker): New constructor.\n+\t(mark_def_dom_walker::~mark_def_dom_walker): New destructor.\n+\t(mark_def_sites_blocks): Convert to\n+\tmark_def_dom_walker::before_dom_children.\n+\t(mark_def_site_blocks): Remove.\n+\t* tree-ssa-dom.c (dom_opt_dom_walker): New class.\n+\t(tree_ssa_dominator_optimize): Adjust.\n+\t(dom_thread_across_edge): Convert to method\n+\tdom_opt_dom_walker::thread_across_edge.\n+\t(dom_opt_enter_block): Convert to member function\n+\tdom_opt_dom_walker::before_dom_children.\n+\t(dom_opt_leave_block): Convert to member function\n+\tdom_opt_dom_walker::after_dom_children.\n+\t* tree-ssa-dse.c (dse_dom_walker): New class.\n+\t(dse_enter_block): Convert to member function\n+\tdse_dom_walker::before_dom_children.\n+\t(tree_ssa_dse): Adjust.\n+\t* tree-ssa-loop-im.c (invariantness_dom_walker): New class.\n+\t(determine_invariantness_stmt): Convert to method\n+\tinvariantness_dom_walker::before_dom_children.\n+\t(determine_invariantness): Remove\n+\t(move_computations_dom_walker): New class.\n+\t(move_computations_stmt): Convert to method\n+\tmove_computations_dom_walker::before_dom_children.\n+\t(move_computations, tree_ssa_lim): Adjust.\n+\t* tree-ssa-phiopt.c (nontrapping_dom_walker): new class\n+\t(nt_init_block): Make method\n+\tnotrappping_dom_walker::before_dom_children.\n+\t(nt_fini_block): Make\n+\tmethod nontrapping_dom_walker::after_dom_children.\n+\t(get_non_trapping): Adjust.\n+\t* tree-ssa-pre.c (eliminate_dom_walker): New class.\n+\t(eliminate_bb): Make method eliminate_dom_walker::before_dom_children.\n+\t(eliminate_leave_block): Make method.\n+\teliminate_dom_walker::after_dom_children.\n+\t(eliminate): Adjust\n+\t* tree-ssa-strlen.c (strlen_dom_walker): New class.\n+\t(strlen_enter_block): Make method\n+\tstrlen_dom_walker::before_dom_children.\n+\t(strlen_leave_block): Make\n+\tmethod strlen_dom_walker::after_dom_children.\n+\t(tree_ssa_strlen): Adjust.\n+\t* tree-ssa-uncprop.c (uncprop_dom_walker): New class.\n+\t(tree_ssa_uncprop): Adjust.\n+\t(uncprop_leave_block): Make method\n+\tuncprop_dom_walker::after_dom_children.\n+\t(uncprop_leave_block): Make method\n+\tuncprop_dom_walker::before_dom_children.\n+\n 2013-09-18  Bin Cheng  <bin.cheng@arm.com>\n \n \t* config/arm/arm.c (thumb1_reorg): Search for flag setting insn"}, {"sha": "19cf524b1f97528301ed7f9b44fca2a5b58d4aea", "filename": "gcc/compare-elim.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Fcompare-elim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Fcompare-elim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcompare-elim.c?ref=4d9192b50c325156ab000884a57a3d7cfe4f79c6", "patch": "@@ -243,13 +243,21 @@ find_flags_uses_in_insn (struct comparison *cmp, rtx insn)\n   cmp->missing_uses = true;\n }\n \n+class find_comparison_dom_walker : public dom_walker\n+{\n+public:\n+  find_comparison_dom_walker (cdi_direction direction)\n+    : dom_walker(direction) {}\n+\n+  virtual void before_dom_children (basic_block);\n+};\n+\n /* Identify comparison instructions within BB.  If the flags from the last\n    compare in the BB is live at the end of the block, install the compare\n-   in BB->AUX.  Called via walk_dominators_tree.  */\n+   in BB->AUX.  Called via dom_walker.walk ().  */\n \n-static void\n-find_comparisons_in_bb (struct dom_walk_data *data ATTRIBUTE_UNUSED,\n-\t\t\tbasic_block bb)\n+void\n+find_comparison_dom_walker::before_dom_children (basic_block bb)\n {\n   struct comparison *last_cmp;\n   rtx insn, next, last_clobber;\n@@ -403,17 +411,10 @@ find_comparisons_in_bb (struct dom_walk_data *data ATTRIBUTE_UNUSED,\n static void\n find_comparisons (void)\n {\n-  struct dom_walk_data data;\n-\n-  memset (&data, 0, sizeof(data));\n-  data.dom_direction = CDI_DOMINATORS;\n-  data.before_dom_children = find_comparisons_in_bb;\n-\n   calculate_dominance_info (CDI_DOMINATORS);\n \n-  init_walk_dominator_tree (&data);\n-  walk_dominator_tree (&data, ENTRY_BLOCK_PTR);\n-  fini_walk_dominator_tree (&data);\n+  find_comparison_dom_walker (CDI_DOMINATORS)\n+    .walk (cfun->cfg->x_entry_block_ptr);\n \n   clear_aux_for_blocks ();\n   free_dominance_info (CDI_DOMINATORS);"}, {"sha": "bffa4aa485166c4c8cebf3a05535f97078266bb0", "filename": "gcc/domwalk.c", "status": "modified", "additions": 12, "deletions": 75, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Fdomwalk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Fdomwalk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.c?ref=4d9192b50c325156ab000884a57a3d7cfe4f79c6", "patch": "@@ -144,23 +144,17 @@ cmp_bb_postorder (const void *a, const void *b)\n }\n \n /* Recursively walk the dominator tree.\n-\n-   WALK_DATA contains a set of callbacks to perform pass-specific\n-   actions during the dominator walk as well as a stack of block local\n-   data maintained during the dominator walk.\n-\n    BB is the basic block we are currently visiting.  */\n \n void\n-walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n+dom_walker::walk (basic_block bb)\n {\n-  void *bd = NULL;\n   basic_block dest;\n   basic_block *worklist = XNEWVEC (basic_block, n_basic_blocks * 2);\n   int sp = 0;\n   int *postorder, postorder_num;\n \n-  if (walk_data->dom_direction == CDI_DOMINATORS)\n+  if (dom_direction_ == CDI_DOMINATORS)\n     {\n       postorder = XNEWVEC (int, n_basic_blocks);\n       postorder_num = inverted_post_order_compute (postorder);\n@@ -177,48 +171,20 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n \t  || bb == ENTRY_BLOCK_PTR\n \t  || bb == EXIT_BLOCK_PTR)\n \t{\n-\t  /* Callback to initialize the local data structure.  */\n-\t  if (walk_data->initialize_block_local_data)\n-\t    {\n-\t      bool recycled;\n-\n-\t      /* First get some local data, reusing any local data\n-\t\t pointer we may have saved.  */\n-\t      if (walk_data->free_block_data.length () > 0)\n-\t\t{\n-\t\t  bd = walk_data->free_block_data.pop ();\n-\t\t  recycled = 1;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  bd = xcalloc (1, walk_data->block_local_data_size);\n-\t\t  recycled = 0;\n-\t\t}\n-\n-\t      /* Push the local data into the local data stack.  */\n-\t      walk_data->block_data_stack.safe_push (bd);\n-\n-\t      /* Call the initializer.  */\n-\t      walk_data->initialize_block_local_data (walk_data, bb,\n-\t\t\t\t\t\t      recycled);\n-\n-\t    }\n-\n-\t  /* Callback for operations to execute before we have walked the\n-\t     dominator children, but before we walk statements.  */\n-\t  if (walk_data->before_dom_children)\n-\t    (*walk_data->before_dom_children) (walk_data, bb);\n+\t  /* Callback for subclasses to do custom things before we have walked\n+\t     the dominator children, but before we walk statements.  */\n+\t  before_dom_children (bb);\n \n \t  /* Mark the current BB to be popped out of the recursion stack\n \t     once children are processed.  */\n \t  worklist[sp++] = bb;\n \t  worklist[sp++] = NULL;\n \n \t  int saved_sp = sp;\n-\t  for (dest = first_dom_son (walk_data->dom_direction, bb);\n-\t       dest; dest = next_dom_son (walk_data->dom_direction, dest))\n+\t  for (dest = first_dom_son (dom_direction_, bb);\n+\t       dest; dest = next_dom_son (dom_direction_, dest))\n \t    worklist[sp++] = dest;\n-\t  if (walk_data->dom_direction == CDI_DOMINATORS)\n+\t  if (dom_direction_ == CDI_DOMINATORS)\n \t    switch (sp - saved_sp)\n \t      {\n \t      case 0:\n@@ -235,48 +201,19 @@ walk_dominator_tree (struct dom_walk_data *walk_data, basic_block bb)\n \t  --sp;\n \t  bb = worklist[--sp];\n \n-\t  /* Callback for operations to execute after we have walked the\n-\t     dominator children, but before we walk statements.  */\n-\t  if (walk_data->after_dom_children)\n-\t    (*walk_data->after_dom_children) (walk_data, bb);\n-\n-\t  if (walk_data->initialize_block_local_data)\n-\t    {\n-\t      /* And finally pop the record off the block local data stack.  */\n-\t      bd = walk_data->block_data_stack.pop ();\n-\t      /* And save the block data so that we can re-use it.  */\n-\t      walk_data->free_block_data.safe_push (bd);\n-\t    }\n+\t  /* Callback allowing subclasses to do custom things after we have\n+\t     walked dominator children, but before we walk statements.  */\n+\t  after_dom_children (bb);\n \t}\n       if (sp)\n \tbb = worklist[--sp];\n       else\n \tbreak;\n     }\n-  if (walk_data->dom_direction == CDI_DOMINATORS)\n+  if (dom_direction_ == CDI_DOMINATORS)\n     {\n       free (bb_postorder);\n       bb_postorder = NULL;\n     }\n   free (worklist);\n }\n-\n-void\n-init_walk_dominator_tree (struct dom_walk_data *walk_data)\n-{\n-  walk_data->free_block_data.create (0);\n-  walk_data->block_data_stack.create (0);\n-}\n-\n-void\n-fini_walk_dominator_tree (struct dom_walk_data *walk_data)\n-{\n-  if (walk_data->initialize_block_local_data)\n-    {\n-      while (walk_data->free_block_data.length () > 0)\n-\tfree (walk_data->free_block_data.pop ());\n-    }\n-\n-  walk_data->free_block_data.release ();\n-  walk_data->block_data_stack.release ();\n-}"}, {"sha": "b33d70eda237e8ffe44432d106a438fe737328f1", "filename": "gcc/domwalk.h", "status": "modified", "additions": 23, "deletions": 45, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Fdomwalk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Fdomwalk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.h?ref=4d9192b50c325156ab000884a57a3d7cfe4f79c6", "patch": "@@ -18,57 +18,35 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-typedef void *void_p;\n-\n-/* This is the main data structure for the dominator walker.  It provides\n-   the callback hooks as well as a convenient place to hang block local\n-   data and pass-global data.  */\n-\n-struct dom_walk_data\n+#ifndef GCC_DOM_WALK_H\n+#define GCC_DOM_WALK_H\n+\n+/**\n+ * This is the main class for the dominator walker. It is expected that\n+ * consumers will have a custom class inheriting from it, which will over ride\n+ * at least one of before_dom_children and after_dom_children to implement the\n+ * custom behavior.\n+ */\n+class dom_walker\n {\n-  /* This is the direction of the dominator tree we want to walk.  i.e.,\n-     if it is set to CDI_DOMINATORS, then we walk the dominator tree,\n-     if it is set to CDI_POST_DOMINATORS, then we walk the post\n-     dominator tree.  */\n-  ENUM_BITFIELD (cdi_direction) dom_direction : 2;\n-\n-  /* Function to initialize block local data.\n+public:\n+  dom_walker (cdi_direction direction) : dom_direction_ (direction) {}\n \n-     Note that the dominator walker infrastructure may provide a new\n-     fresh, and zero'd block local data structure, or it may re-use an\n-     existing block local data structure.\n-\n-     If the block local structure has items such as virtual arrays, then\n-     that allows your optimizer to re-use those arrays rather than\n-     creating new ones.  */\n-  void (*initialize_block_local_data) (struct dom_walk_data *,\n-\t\t\t\t       basic_block, bool);\n+  /* Walk the dominator tree.  */\n+  void walk (basic_block);\n \n   /* Function to call before the recursive walk of the dominator children.  */\n-  void (*before_dom_children) (struct dom_walk_data *, basic_block);\n+  virtual void before_dom_children (basic_block) {}\n \n   /* Function to call after the recursive walk of the dominator children.  */\n-  void (*after_dom_children) (struct dom_walk_data *, basic_block);\n-\n-  /* Global data for a walk through the dominator tree.  */\n-  void *global_data;\n+  virtual void after_dom_children (basic_block) {}\n \n-  /* Stack of any data we need to keep on a per-block basis.\n-\n-     If you have no local data, then BLOCK_DATA_STACK will be NULL.  */\n-  vec<void_p> block_data_stack;\n-\n-  /* Size of the block local data.   If this is zero, then it is assumed\n-     you have no local data and thus no BLOCK_DATA_STACK as well.  */\n-  size_t block_local_data_size;\n-\n-  /* From here below are private data.  Please do not use this\n-     information/data outside domwalk.c.  */\n-\n-  /* Stack of available block local structures.  */\n-  vec<void_p> free_block_data;\n+private:\n+  /* This is the direction of the dominator tree we want to walk.  i.e.,\n+     if it is set to CDI_DOMINATORS, then we walk the dominator tree,\n+     if it is set to CDI_POST_DOMINATORS, then we walk the post\n+     dominator tree.  */\n+  const ENUM_BITFIELD (cdi_direction) dom_direction_ : 2;\n };\n \n-void walk_dominator_tree (struct dom_walk_data *, basic_block);\n-void init_walk_dominator_tree (struct dom_walk_data *);\n-void fini_walk_dominator_tree (struct dom_walk_data *);\n+#endif"}, {"sha": "137011d3324b00132ea52973bb5bba1fd3b07219", "filename": "gcc/fwprop.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=4d9192b50c325156ab000884a57a3d7cfe4f79c6", "patch": "@@ -205,10 +205,17 @@ process_uses (df_ref *use_rec, int top_flag)\n       }\n }\n \n+class single_def_use_dom_walker : public dom_walker\n+{\n+public:\n+  single_def_use_dom_walker (cdi_direction direction)\n+    : dom_walker (direction) {}\n+  virtual void before_dom_children (basic_block);\n+  virtual void after_dom_children (basic_block);\n+};\n \n-static void\n-single_def_use_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t\t    basic_block bb)\n+void\n+single_def_use_dom_walker::before_dom_children (basic_block bb)\n {\n   int bb_index = bb->index;\n   struct df_md_bb_info *md_bb_info = df_md_get_bb_info (bb_index);\n@@ -245,9 +252,8 @@ single_def_use_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n /* Pop the definitions created in this basic block when leaving its\n    dominated parts.  */\n \n-static void\n-single_def_use_leave_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t\t    basic_block bb ATTRIBUTE_UNUSED)\n+void\n+single_def_use_dom_walker::after_dom_children (basic_block bb ATTRIBUTE_UNUSED)\n {\n   df_ref saved_def;\n   while ((saved_def = reg_defs_stack.pop ()) != NULL)\n@@ -269,8 +275,6 @@ single_def_use_leave_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n static void\n build_single_def_use_links (void)\n {\n-  struct dom_walk_data walk_data;\n-\n   /* We use the multiple definitions problem to compute our restricted\n      use-def chains.  */\n   df_set_flags (DF_EQ_NOTES);\n@@ -291,14 +295,8 @@ build_single_def_use_links (void)\n \n   /* Walk the dominator tree looking for single reaching definitions\n      dominating the uses.  This is similar to how SSA form is built.  */\n-  walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.initialize_block_local_data = NULL;\n-  walk_data.before_dom_children = single_def_use_enter_block;\n-  walk_data.after_dom_children = single_def_use_leave_block;\n-\n-  init_walk_dominator_tree (&walk_data);\n-  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n-  fini_walk_dominator_tree (&walk_data);\n+  single_def_use_dom_walker (CDI_DOMINATORS)\n+    .walk (cfun->cfg->x_entry_block_ptr);\n \n   BITMAP_FREE (local_lr);\n   BITMAP_FREE (local_md);"}, {"sha": "8d48adde01d4f530ff2dd88732c00fb828582f28", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=4d9192b50c325156ab000884a57a3d7cfe4f79c6", "patch": "@@ -1571,11 +1571,18 @@ slsr_process_copy (gimple gs, tree rhs1, bool speed)\n   add_cand_for_stmt (gs, c);\n }\n \f\n+class find_candidates_dom_walker : public dom_walker\n+{\n+public:\n+  find_candidates_dom_walker (cdi_direction direction)\n+    : dom_walker (direction) {}\n+  virtual void before_dom_children (basic_block);\n+};\n+\n /* Find strength-reduction candidates in block BB.  */\n \n-static void\n-find_candidates_in_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t\t  basic_block bb)\n+void\n+find_candidates_dom_walker::before_dom_children (basic_block bb)\n {\n   bool speed = optimize_bb_for_speed_p (bb);\n   gimple_stmt_iterator gsi;\n@@ -3488,8 +3495,6 @@ analyze_candidates_and_replace (void)\n static unsigned\n execute_strength_reduction (void)\n {\n-  struct dom_walk_data walk_data;\n-\n   /* Create the obstack where candidates will reside.  */\n   gcc_obstack_init (&cand_obstack);\n \n@@ -3509,18 +3514,10 @@ execute_strength_reduction (void)\n      back edges, and this gives us dominator information as well.  */\n   loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n \n-  /* Set up callbacks for the generic dominator tree walker.  */\n-  walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.initialize_block_local_data = NULL;\n-  walk_data.before_dom_children = find_candidates_in_block;\n-  walk_data.after_dom_children = NULL;\n-  walk_data.global_data = NULL;\n-  walk_data.block_local_data_size = 0;\n-  init_walk_dominator_tree (&walk_data);\n-\n   /* Walk the CFG in predominator order looking for strength reduction\n      candidates.  */\n-  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n+  find_candidates_dom_walker (CDI_DOMINATORS)\n+    .walk (cfun->cfg->x_entry_block_ptr);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n@@ -3531,8 +3528,6 @@ execute_strength_reduction (void)\n   /* Analyze costs and make appropriate replacements.  */\n   analyze_candidates_and_replace ();\n \n-  /* Free resources.  */\n-  fini_walk_dominator_tree (&walk_data);\n   loop_optimizer_finalize ();\n   base_cand_map.dispose ();\n   obstack_free (&chain_obstack, NULL);"}, {"sha": "49856914782262a4b340209d4aa0be197b835f7f", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 42, "deletions": 62, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=4d9192b50c325156ab000884a57a3d7cfe4f79c6", "patch": "@@ -1191,14 +1191,6 @@ add_conditions_to_constraints (scop_p scop)\n     add_conditions_to_domain (pbb);\n }\n \n-/* Structure used to pass data to dom_walk.  */\n-\n-struct bsc\n-{\n-  vec<gimple> *conditions, *cases;\n-  sese region;\n-};\n-\n /* Returns a COND_EXPR statement when BB has a single predecessor, the\n    edge between BB and its predecessor is not a loop exit edge, and\n    the last statement of the single predecessor is a COND_EXPR.  */\n@@ -1224,20 +1216,43 @@ single_pred_cond_non_loop_exit (basic_block bb)\n   return NULL;\n }\n \n+class sese_dom_walker : public dom_walker\n+{\n+public:\n+  sese_dom_walker (cdi_direction, sese);\n+  ~sese_dom_walker ();\n+\n+  virtual void before_dom_children (basic_block);\n+  virtual void after_dom_children (basic_block);\n+\n+private:\n+  vec<gimple> conditions_, cases_;\n+  sese region_;\n+};\n+\n+sese_dom_walker::sese_dom_walker (cdi_direction direction, sese region)\n+  : dom_walker (direction), region_ (region)\n+{\n+  conditions_.create (3);\n+  cases_.create (3);\n+}\n+\n+sese_dom_walker::~sese_dom_walker ()\n+{\n+  conditions_.release ();\n+  cases_.release ();\n+}\n+\n /* Call-back for dom_walk executed before visiting the dominated\n    blocks.  */\n \n-static void\n-build_sese_conditions_before (struct dom_walk_data *dw_data,\n-\t\t\t      basic_block bb)\n+void\n+sese_dom_walker::before_dom_children (basic_block bb)\n {\n-  struct bsc *data = (struct bsc *) dw_data->global_data;\n-  vec<gimple> *conditions = data->conditions;\n-  vec<gimple> *cases = data->cases;\n   gimple_bb_p gbb;\n   gimple stmt;\n \n-  if (!bb_in_sese_p (bb, data->region))\n+  if (!bb_in_sese_p (bb, region_))\n     return;\n \n   stmt = single_pred_cond_non_loop_exit (bb);\n@@ -1246,75 +1261,39 @@ build_sese_conditions_before (struct dom_walk_data *dw_data,\n     {\n       edge e = single_pred_edge (bb);\n \n-      conditions->safe_push (stmt);\n+      conditions_.safe_push (stmt);\n \n       if (e->flags & EDGE_TRUE_VALUE)\n-\tcases->safe_push (stmt);\n+\tcases_.safe_push (stmt);\n       else\n-\tcases->safe_push (NULL);\n+\tcases_.safe_push (NULL);\n     }\n \n   gbb = gbb_from_bb (bb);\n \n   if (gbb)\n     {\n-      GBB_CONDITIONS (gbb) = conditions->copy ();\n-      GBB_CONDITION_CASES (gbb) = cases->copy ();\n+      GBB_CONDITIONS (gbb) = conditions_.copy ();\n+      GBB_CONDITION_CASES (gbb) = cases_.copy ();\n     }\n }\n \n /* Call-back for dom_walk executed after visiting the dominated\n    blocks.  */\n \n-static void\n-build_sese_conditions_after (struct dom_walk_data *dw_data,\n-\t\t\t     basic_block bb)\n+void\n+sese_dom_walker::after_dom_children (basic_block bb)\n {\n-  struct bsc *data = (struct bsc *) dw_data->global_data;\n-  vec<gimple> *conditions = data->conditions;\n-  vec<gimple> *cases = data->cases;\n-\n-  if (!bb_in_sese_p (bb, data->region))\n+  if (!bb_in_sese_p (bb, region_))\n     return;\n \n   if (single_pred_cond_non_loop_exit (bb))\n     {\n-      conditions->pop ();\n-      cases->pop ();\n+      conditions_.pop ();\n+      cases_.pop ();\n     }\n }\n \n-/* Record all conditions in REGION.  */\n-\n-static void\n-build_sese_conditions (sese region)\n-{\n-  struct dom_walk_data walk_data;\n-  vec<gimple> conditions;\n-  conditions.create (3);\n-  vec<gimple> cases;\n-  cases.create (3);\n-  struct bsc data;\n-\n-  data.conditions = &conditions;\n-  data.cases = &cases;\n-  data.region = region;\n-\n-  walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.initialize_block_local_data = NULL;\n-  walk_data.before_dom_children = build_sese_conditions_before;\n-  walk_data.after_dom_children = build_sese_conditions_after;\n-  walk_data.global_data = &data;\n-  walk_data.block_local_data_size = 0;\n-\n-  init_walk_dominator_tree (&walk_data);\n-  walk_dominator_tree (&walk_data, SESE_ENTRY_BB (region));\n-  fini_walk_dominator_tree (&walk_data);\n-\n-  conditions.release ();\n-  cases.release ();\n-}\n-\n /* Add constraints on the possible values of parameter P from the type\n    of P.  */\n \n@@ -3179,7 +3158,8 @@ build_poly_scop (scop_p scop)\n     rewrite_commutative_reductions_out_of_ssa (scop);\n \n   build_sese_loop_nests (region);\n-  build_sese_conditions (region);\n+  /* Record all conditions in REGION.  */\n+  sese_dom_walker (CDI_DOMINATORS, region).walk (cfun->cfg->x_entry_block_ptr);\n   find_scop_parameters (scop);\n \n   max_dim = PARAM_VALUE (PARAM_GRAPHITE_MAX_NB_SCOP_PARAMS);"}, {"sha": "384d3b33cff6d5ad94ac94fbfaa718e63c264e6b", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 57, "deletions": 91, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=4d9192b50c325156ab000884a57a3d7cfe4f79c6", "patch": "@@ -1399,14 +1399,22 @@ rewrite_add_phi_arguments (basic_block bb)\n     }\n }\n \n+class rewrite_dom_walker : public dom_walker\n+{\n+public:\n+  rewrite_dom_walker (cdi_direction direction) : dom_walker (direction) {}\n+\n+  virtual void before_dom_children (basic_block);\n+  virtual void after_dom_children (basic_block);\n+};\n+\n /* SSA Rewriting Step 1.  Initialization, create a block local stack\n    of reaching definitions for new SSA names produced in this block\n    (BLOCK_DEFS).  Register new definitions for every PHI node in the\n    block.  */\n \n-static void\n-rewrite_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t     basic_block bb)\n+void\n+rewrite_dom_walker::before_dom_children (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n \n@@ -1444,9 +1452,8 @@ rewrite_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n /* Called after visiting all the statements in basic block BB and all\n    of its dominator children.  Restore CURRDEFS to its original value.  */\n \n-static void\n-rewrite_leave_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t     basic_block bb ATTRIBUTE_UNUSED)\n+void\n+rewrite_dom_walker::after_dom_children (basic_block bb ATTRIBUTE_UNUSED)\n {\n   /* Restore CURRDEFS to its original state.  */\n   while (block_defs_stack.length () > 0)\n@@ -2065,15 +2072,22 @@ rewrite_update_phi_arguments (basic_block bb)\n     }\n }\n \n+class rewrite_update_dom_walker : public dom_walker\n+{\n+public:\n+  rewrite_update_dom_walker (cdi_direction direction) : dom_walker (direction) {}\n+\n+  virtual void before_dom_children (basic_block);\n+  virtual void after_dom_children (basic_block);\n+};\n \n /* Initialization of block data structures for the incremental SSA\n    update pass.  Create a block local stack of reaching definitions\n    for new SSA names produced in this block (BLOCK_DEFS).  Register\n    new definitions for every PHI node in the block.  */\n \n-static void\n-rewrite_update_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t            basic_block bb)\n+void\n+rewrite_update_dom_walker::before_dom_children (basic_block bb)\n {\n   bool is_abnormal_phi;\n   gimple_stmt_iterator gsi;\n@@ -2146,9 +2160,8 @@ rewrite_update_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n    unwinding must be done in the opposite order to what is done in\n    register_new_update_set.  */\n \n-static void\n-rewrite_update_leave_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t\t    basic_block bb ATTRIBUTE_UNUSED)\n+void\n+rewrite_update_dom_walker::after_dom_children (basic_block bb ATTRIBUTE_UNUSED)\n {\n   while (block_defs_stack.length () > 0)\n     {\n@@ -2183,41 +2196,20 @@ rewrite_update_leave_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n static void\n rewrite_blocks (basic_block entry, enum rewrite_mode what)\n {\n-  struct dom_walk_data walk_data;\n-\n   /* Rewrite all the basic blocks in the program.  */\n   timevar_push (TV_TREE_SSA_REWRITE_BLOCKS);\n \n-  /* Setup callbacks for the generic dominator tree walker.  */\n-  memset (&walk_data, 0, sizeof (walk_data));\n-\n-  walk_data.dom_direction = CDI_DOMINATORS;\n+  block_defs_stack.create (10);\n \n+  /* Recursively walk the dominator tree rewriting each statement in\n+     each basic block.  */\n   if (what == REWRITE_ALL)\n-    {\n-      walk_data.before_dom_children = rewrite_enter_block;\n-      walk_data.after_dom_children = rewrite_leave_block;\n-    }\n+      rewrite_dom_walker (CDI_DOMINATORS).walk (entry);\n   else if (what == REWRITE_UPDATE)\n-    {\n-      walk_data.before_dom_children = rewrite_update_enter_block;\n-      walk_data.after_dom_children = rewrite_update_leave_block;\n-    }\n+      rewrite_update_dom_walker (CDI_DOMINATORS).walk (entry);\n   else\n     gcc_unreachable ();\n \n-  block_defs_stack.create (10);\n-\n-  /* Initialize the dominator walker.  */\n-  init_walk_dominator_tree (&walk_data);\n-\n-  /* Recursively walk the dominator tree rewriting each statement in\n-     each basic block.  */\n-  walk_dominator_tree (&walk_data, entry);\n-\n-  /* Finalize the dominator walker.  */\n-  fini_walk_dominator_tree (&walk_data);\n-\n   /* Debugging dumps.  */\n   if (dump_file && (dump_flags & TDF_STATS))\n     {\n@@ -2231,69 +2223,44 @@ rewrite_blocks (basic_block entry, enum rewrite_mode what)\n   timevar_pop (TV_TREE_SSA_REWRITE_BLOCKS);\n }\n \n-\n-/* Block processing routine for mark_def_sites.  Clear the KILLS bitmap\n-   at the start of each block, and call mark_def_sites for each statement.  */\n-\n-static void\n-mark_def_sites_block (struct dom_walk_data *walk_data, basic_block bb)\n+class mark_def_dom_walker : public dom_walker\n {\n-  struct mark_def_sites_global_data *gd;\n-  bitmap kills;\n-  gimple_stmt_iterator gsi;\n-\n-  gd = (struct mark_def_sites_global_data *) walk_data->global_data;\n-  kills = gd->kills;\n-\n-  bitmap_clear (kills);\n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    mark_def_sites (bb, gsi_stmt (gsi), kills);\n-}\n-\n-\n-/* Mark the definition site blocks for each variable, so that we know\n-   where the variable is actually live.\n-\n-   The INTERESTING_BLOCKS global will be filled in with all the blocks\n-   that should be processed by the renamer.  It is assumed that the\n-   caller has already initialized and zeroed it.  */\n-\n-static void\n-mark_def_site_blocks (void)\n-{\n-  struct dom_walk_data walk_data;\n-  struct mark_def_sites_global_data mark_def_sites_global_data;\n+public:\n+  mark_def_dom_walker (cdi_direction direction);\n+  ~mark_def_dom_walker ();\n \n-  /* Setup callbacks for the generic dominator tree walker to find and\n-     mark definition sites.  */\n-  walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.initialize_block_local_data = NULL;\n-  walk_data.before_dom_children = mark_def_sites_block;\n-  walk_data.after_dom_children = NULL;\n+  virtual void before_dom_children (basic_block);\n \n+private:\n   /* Notice that this bitmap is indexed using variable UIDs, so it must be\n      large enough to accommodate all the variables referenced in the\n      function, not just the ones we are renaming.  */\n-  mark_def_sites_global_data.kills = BITMAP_ALLOC (NULL);\n-  walk_data.global_data = &mark_def_sites_global_data;\n+  bitmap kills_;\n+};\n \n-  /* We do not have any local data.  */\n-  walk_data.block_local_data_size = 0;\n+mark_def_dom_walker::mark_def_dom_walker (cdi_direction direction)\n+  : dom_walker (direction), kills_ (BITMAP_ALLOC (NULL))\n+{\n+}\n \n-  /* Initialize the dominator walker.  */\n-  init_walk_dominator_tree (&walk_data);\n+mark_def_dom_walker::~mark_def_dom_walker ()\n+{\n+  BITMAP_FREE (kills_);\n+}\n \n-  /* Recursively walk the dominator tree.  */\n-  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n+/* Block processing routine for mark_def_sites.  Clear the KILLS bitmap\n+   at the start of each block, and call mark_def_sites for each statement.  */\n \n-  /* Finalize the dominator walker.  */\n-  fini_walk_dominator_tree (&walk_data);\n+void\n+mark_def_dom_walker::before_dom_children (basic_block bb)\n+{\n+  gimple_stmt_iterator gsi;\n \n-  /* We no longer need this bitmap, clear and free it.  */\n-  BITMAP_FREE (mark_def_sites_global_data.kills);\n+  bitmap_clear (kills_);\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    mark_def_sites (bb, gsi_stmt (gsi), kills_);\n }\n \n-\n /* Initialize internal data needed during renaming.  */\n \n static void\n@@ -2331,8 +2298,7 @@ fini_ssa_renamer (void)\n       insert PHI nodes and rename the function in dominator tree\n       order.\n \n-   2- Find and mark all the blocks that define variables\n-      (mark_def_site_blocks).\n+   2- Find and mark all the blocks that define variables.\n \n    3- Insert PHI nodes at dominance frontiers (insert_phi_nodes).\n \n@@ -2370,7 +2336,7 @@ rewrite_into_ssa (void)\n   compute_dominance_frontiers (dfs);\n \n   /* 2- Find and mark definition sites.  */\n-  mark_def_site_blocks ();\n+  mark_def_dom_walker (CDI_DOMINATORS).walk (cfun->cfg->x_entry_block_ptr);\n \n   /* 3- Insert PHI nodes at dominance frontiers of definition blocks.  */\n   insert_phi_nodes (dfs);"}, {"sha": "aac7aa496bb28eacb9a5afcd821c33c7e1c9ae4d", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 30, "deletions": 41, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=4d9192b50c325156ab000884a57a3d7cfe4f79c6", "patch": "@@ -244,9 +244,6 @@ static void record_equivalences_from_phis (basic_block);\n static void record_equivalences_from_incoming_edge (basic_block);\n static void eliminate_redundant_computations (gimple_stmt_iterator *);\n static void record_equivalences_from_stmt (gimple, int);\n-static void dom_thread_across_edge (struct dom_walk_data *, edge);\n-static void dom_opt_leave_block (struct dom_walk_data *, basic_block);\n-static void dom_opt_enter_block (struct dom_walk_data *, basic_block);\n static void remove_local_expressions_from_table (void);\n static void restore_vars_to_original_value (void);\n static edge single_incoming_edge_ignoring_loop_edges (basic_block);\n@@ -773,6 +770,21 @@ free_all_edge_infos (void)\n     }\n }\n \n+class dom_opt_dom_walker : public dom_walker\n+{\n+public:\n+  dom_opt_dom_walker (cdi_direction direction)\n+    : dom_walker (direction), dummy_cond_ (NULL) {}\n+\n+  virtual void before_dom_children (basic_block);\n+  virtual void after_dom_children (basic_block);\n+\n+private:\n+  void thread_across_edge (edge);\n+\n+  gimple dummy_cond_;\n+};\n+\n /* Jump threading, redundancy elimination and const/copy propagation.\n \n    This pass may expose new symbols that need to be renamed into SSA.  For\n@@ -782,8 +794,6 @@ free_all_edge_infos (void)\n static unsigned int\n tree_ssa_dominator_optimize (void)\n {\n-  struct dom_walk_data walk_data;\n-\n   memset (&opt_stats, 0, sizeof (opt_stats));\n \n   /* Create our hash tables.  */\n@@ -792,20 +802,6 @@ tree_ssa_dominator_optimize (void)\n   const_and_copies_stack.create (20);\n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n \n-  /* Setup callbacks for the generic dominator tree walker.  */\n-  walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.initialize_block_local_data = NULL;\n-  walk_data.before_dom_children = dom_opt_enter_block;\n-  walk_data.after_dom_children = dom_opt_leave_block;\n-  /* Right now we only attach a dummy COND_EXPR to the global data pointer.\n-     When we attach more stuff we'll need to fill this out with a real\n-     structure.  */\n-  walk_data.global_data = NULL;\n-  walk_data.block_local_data_size = 0;\n-\n-  /* Now initialize the dominator walker.  */\n-  init_walk_dominator_tree (&walk_data);\n-\n   calculate_dominance_info (CDI_DOMINATORS);\n   cfg_altered = false;\n \n@@ -824,7 +820,7 @@ tree_ssa_dominator_optimize (void)\n   mark_dfs_back_edges ();\n \n   /* Recursively walk the dominator tree optimizing statements.  */\n-  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n+  dom_opt_dom_walker (CDI_DOMINATORS).walk (cfun->cfg->x_entry_block_ptr);\n \n   {\n     gimple_stmt_iterator gsi;\n@@ -897,9 +893,6 @@ tree_ssa_dominator_optimize (void)\n   /* Delete our main hashtable.  */\n   avail_exprs.dispose ();\n \n-  /* And finalize the dominator walker.  */\n-  fini_walk_dominator_tree (&walk_data);\n-\n   /* Free asserted bitmaps and stacks.  */\n   BITMAP_FREE (need_eh_cleanup);\n \n@@ -1081,21 +1074,18 @@ simplify_stmt_for_jump_threading (gimple stmt,\n    it handles lazily building the dummy condition and the bookkeeping\n    when jump threading is successful.  */\n \n-static void\n-dom_thread_across_edge (struct dom_walk_data *walk_data, edge e)\n+void\n+dom_opt_dom_walker::thread_across_edge (edge e)\n {\n-  if (! walk_data->global_data)\n-  {\n-    gimple dummy_cond =\n+  if (! dummy_cond_)\n+    dummy_cond_ =\n         gimple_build_cond (NE_EXPR,\n                            integer_zero_node, integer_zero_node,\n                            NULL, NULL);\n-    walk_data->global_data = dummy_cond;\n-  }\n \n-  thread_across_edge ((gimple) walk_data->global_data, e, false,\n-\t\t      &const_and_copies_stack,\n-\t\t      simplify_stmt_for_jump_threading);\n+  ::thread_across_edge (dummy_cond_, e, false,\n+\t\t        &const_and_copies_stack,\n+\t\t        simplify_stmt_for_jump_threading);\n }\n \n /* PHI nodes can create equivalences too.\n@@ -1864,9 +1854,8 @@ record_edge_info (basic_block bb)\n     }\n }\n \n-static void\n-dom_opt_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t     basic_block bb)\n+void\n+dom_opt_dom_walker::before_dom_children (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n \n@@ -1903,8 +1892,8 @@ dom_opt_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n    any finalization actions in preparation for leaving this node in\n    the dominator tree.  */\n \n-static void\n-dom_opt_leave_block (struct dom_walk_data *walk_data, basic_block bb)\n+void\n+dom_opt_dom_walker::after_dom_children (basic_block bb)\n {\n   gimple last;\n \n@@ -1919,7 +1908,7 @@ dom_opt_leave_block (struct dom_walk_data *walk_data, basic_block bb)\n       /* Push a marker on the stack, which thread_across_edge expects\n \t and will remove.  */\n       const_and_copies_stack.safe_push (NULL_TREE);\n-      dom_thread_across_edge (walk_data, single_succ_edge (bb));\n+      thread_across_edge (single_succ_edge (bb));\n     }\n   else if ((last = last_stmt (bb))\n \t   && gimple_code (last) == GIMPLE_COND\n@@ -1964,7 +1953,7 @@ dom_opt_leave_block (struct dom_walk_data *walk_data, basic_block bb)\n \t\trecord_cond (eq);\n \t    }\n \n-\t  dom_thread_across_edge (walk_data, true_edge);\n+\t  thread_across_edge (true_edge);\n \n \t  /* And restore the various tables to their state before\n \t     we threaded this edge.  */\n@@ -1999,7 +1988,7 @@ dom_opt_leave_block (struct dom_walk_data *walk_data, basic_block bb)\n \t    }\n \n \t  /* Now thread the edge.  */\n-\t  dom_thread_across_edge (walk_data, false_edge);\n+\t  thread_across_edge (false_edge);\n \n \t  /* No need to remove local expressions from our tables\n \t     or restore vars to their original value as that will"}, {"sha": "d06695043257b5d9c88f7abd350cc83ac14f52a3", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=4d9192b50c325156ab000884a57a3d7cfe4f79c6", "patch": "@@ -68,7 +68,6 @@ static bitmap need_eh_cleanup;\n \n static bool gate_dse (void);\n static unsigned int tree_ssa_dse (void);\n-static void dse_enter_block (struct dom_walk_data *, basic_block);\n \n \n /* A helper of dse_optimize_stmt.\n@@ -292,9 +291,16 @@ dse_optimize_stmt (gimple_stmt_iterator *gsi)\n     }\n }\n \n-static void\n-dse_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t basic_block bb)\n+class dse_dom_walker : public dom_walker\n+{\n+public:\n+  dse_dom_walker (cdi_direction direction) : dom_walker (direction) {}\n+\n+  virtual void before_dom_children (basic_block);\n+};\n+\n+void\n+dse_dom_walker::before_dom_children (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n \n@@ -313,8 +319,6 @@ dse_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n static unsigned int\n tree_ssa_dse (void)\n {\n-  struct dom_walk_data walk_data;\n-\n   need_eh_cleanup = BITMAP_ALLOC (NULL);\n \n   renumber_gimple_stmt_uids ();\n@@ -328,22 +332,7 @@ tree_ssa_dse (void)\n \n   /* Dead store elimination is fundamentally a walk of the post-dominator\n      tree and a backwards walk of statements within each block.  */\n-  walk_data.dom_direction = CDI_POST_DOMINATORS;\n-  walk_data.initialize_block_local_data = NULL;\n-  walk_data.before_dom_children = dse_enter_block;\n-  walk_data.after_dom_children = NULL;\n-\n-  walk_data.block_local_data_size = 0;\n-  walk_data.global_data = NULL;\n-\n-  /* Initialize the dominator walker.  */\n-  init_walk_dominator_tree (&walk_data);\n-\n-  /* Recursively walk the dominator tree.  */\n-  walk_dominator_tree (&walk_data, EXIT_BLOCK_PTR);\n-\n-  /* Finalize the dominator walker.  */\n-  fini_walk_dominator_tree (&walk_data);\n+  dse_dom_walker (CDI_POST_DOMINATORS).walk (cfun->cfg->x_exit_block_ptr);\n \n   /* Removal of stores may make some EH edges dead.  Purge such edges from\n      the CFG as needed.  */"}, {"sha": "c12ed7fb59010d41ef41541d5a6a72e24742142b", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 30, "deletions": 36, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=4d9192b50c325156ab000884a57a3d7cfe4f79c6", "patch": "@@ -1040,14 +1040,25 @@ rewrite_bittest (gimple_stmt_iterator *bsi)\n   return stmt;\n }\n \n+/* For each statement determines the outermost loop in that it is invariant,\n+   -   statements on whose motion it depends and the cost of the computation.\n+   -   This information is stored to the LIM_DATA structure associated with\n+   -   each statement.  */\n+class invariantness_dom_walker : public dom_walker\n+{\n+public:\n+  invariantness_dom_walker (cdi_direction direction)\n+    : dom_walker (direction) {}\n+\n+  virtual void before_dom_children (basic_block);\n+};\n \n /* Determine the outermost loops in that statements in basic block BB are\n    invariant, and record them to the LIM_DATA associated with the statements.\n-   Callback for walk_dominator_tree.  */\n+   Callback for dom_walker.  */\n \n-static void\n-determine_invariantness_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n-\t\t\t      basic_block bb)\n+void\n+invariantness_dom_walker::before_dom_children (basic_block bb)\n {\n   enum move_pos pos;\n   gimple_stmt_iterator bsi;\n@@ -1177,32 +1188,23 @@ determine_invariantness_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n     }\n }\n \n-/* For each statement determines the outermost loop in that it is invariant,\n-   statements on whose motion it depends and the cost of the computation.\n-   This information is stored to the LIM_DATA structure associated with\n-   each statement.  */\n-\n-static void\n-determine_invariantness (void)\n+class move_computations_dom_walker : public dom_walker\n {\n-  struct dom_walk_data walk_data;\n+public:\n+  move_computations_dom_walker (cdi_direction direction)\n+    : dom_walker (direction), todo_ (0) {}\n \n-  memset (&walk_data, 0, sizeof (struct dom_walk_data));\n-  walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.before_dom_children = determine_invariantness_stmt;\n+  virtual void before_dom_children (basic_block);\n \n-  init_walk_dominator_tree (&walk_data);\n-  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n-  fini_walk_dominator_tree (&walk_data);\n-}\n+  unsigned int todo_;\n+};\n \n /* Hoist the statements in basic block BB out of the loops prescribed by\n    data stored in LIM_DATA structures associated with each statement.  Callback\n    for walk_dominator_tree.  */\n \n-static void\n-move_computations_stmt (struct dom_walk_data *dw_data,\n-\t\t\tbasic_block bb)\n+void\n+move_computations_dom_walker::before_dom_children (basic_block bb)\n {\n   struct loop *level;\n   gimple_stmt_iterator bsi;\n@@ -1266,7 +1268,7 @@ move_computations_stmt (struct dom_walk_data *dw_data,\n \t\t\t\t\t\t   gimple_phi_result (stmt),\n \t\t\t\t\t\t   t, arg0, arg1);\n \t  SSA_NAME_DEF_STMT (gimple_phi_result (stmt)) = new_stmt;\n-\t  *((unsigned int *)(dw_data->global_data)) |= TODO_cleanup_cfg;\n+\t  todo_ |= TODO_cleanup_cfg;\n \t}\n       gsi_insert_on_edge (loop_preheader_edge (level), new_stmt);\n       remove_phi_node (&bsi, false);\n@@ -1337,23 +1339,14 @@ move_computations_stmt (struct dom_walk_data *dw_data,\n static unsigned int\n move_computations (void)\n {\n-  struct dom_walk_data walk_data;\n-  unsigned int todo = 0;\n-\n-  memset (&walk_data, 0, sizeof (struct dom_walk_data));\n-  walk_data.global_data = &todo;\n-  walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.before_dom_children = move_computations_stmt;\n-\n-  init_walk_dominator_tree (&walk_data);\n-  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n-  fini_walk_dominator_tree (&walk_data);\n+  move_computations_dom_walker walker (CDI_DOMINATORS);\n+  walker.walk (cfun->cfg->x_entry_block_ptr);\n \n   gsi_commit_edge_inserts ();\n   if (need_ssa_update_p (cfun))\n     rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n \n-  return todo;\n+  return walker.todo_;\n }\n \n /* Checks whether the statement defining variable *INDEX can be hoisted\n@@ -2632,7 +2625,8 @@ tree_ssa_lim (void)\n \n   /* For each statement determine the outermost loop in that it is\n      invariant and cost for computing the invariant.  */\n-  determine_invariantness ();\n+  invariantness_dom_walker (CDI_DOMINATORS)\n+    .walk (cfun->cfg->x_entry_block_ptr);\n \n   /* Execute store motion.  Force the necessary invariants to be moved\n      out of the loops as well.  */"}, {"sha": "39d04ab2801b578858709bcf927612b67980cfff", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=4d9192b50c325156ab000884a57a3d7cfe4f79c6", "patch": "@@ -1264,9 +1264,6 @@ struct ssa_names_hasher : typed_free_remove <name_to_bb>\n    Hash entries with phase < nt_call_phase are invalid.  */\n static unsigned int nt_call_phase;\n \n-/* The set of MEM_REFs which can't trap.  */\n-static struct pointer_set_t *nontrap_set;\n-\n /* The hash function.  */\n \n inline hashval_t\n@@ -1378,9 +1375,22 @@ nonfreeing_call_p (gimple call)\n   return false;\n }\n \n+class nontrapping_dom_walker : public dom_walker\n+{\n+public:\n+  nontrapping_dom_walker (cdi_direction direction, pointer_set_t *ps)\n+    : dom_walker (direction), nontrapping_ (ps) {}\n+\n+  virtual void before_dom_children (basic_block);\n+  virtual void after_dom_children (basic_block);\n+\n+private:\n+  pointer_set_t *nontrapping_;\n+};\n+\n /* Called by walk_dominator_tree, when entering the block BB.  */\n-static void\n-nt_init_block (struct dom_walk_data *data ATTRIBUTE_UNUSED, basic_block bb)\n+void\n+nontrapping_dom_walker::before_dom_children (basic_block bb)\n {\n   edge e;\n   edge_iterator ei;\n@@ -1406,15 +1416,15 @@ nt_init_block (struct dom_walk_data *data ATTRIBUTE_UNUSED, basic_block bb)\n \tnt_call_phase++;\n       else if (gimple_assign_single_p (stmt) && !gimple_has_volatile_ops (stmt))\n \t{\n-\t  add_or_mark_expr (bb, gimple_assign_lhs (stmt), nontrap_set, true);\n-\t  add_or_mark_expr (bb, gimple_assign_rhs1 (stmt), nontrap_set, false);\n+\t  add_or_mark_expr (bb, gimple_assign_lhs (stmt), nontrapping_, true);\n+\t  add_or_mark_expr (bb, gimple_assign_rhs1 (stmt), nontrapping_, false);\n \t}\n     }\n }\n \n /* Called by walk_dominator_tree, when basic block BB is exited.  */\n-static void\n-nt_fini_block (struct dom_walk_data *data ATTRIBUTE_UNUSED, basic_block bb)\n+void\n+nontrapping_dom_walker::after_dom_children (basic_block bb)\n {\n   /* This BB isn't on the path to dominator root anymore.  */\n   bb->aux = (void*)2;\n@@ -1427,28 +1437,16 @@ nt_fini_block (struct dom_walk_data *data ATTRIBUTE_UNUSED, basic_block bb)\n static struct pointer_set_t *\n get_non_trapping (void)\n {\n-  struct pointer_set_t *nontrap;\n-  struct dom_walk_data walk_data;\n-\n   nt_call_phase = 0;\n-  nontrap = pointer_set_create ();\n+  pointer_set_t *nontrap = pointer_set_create ();\n   seen_ssa_names.create (128);\n   /* We're going to do a dominator walk, so ensure that we have\n      dominance information.  */\n   calculate_dominance_info (CDI_DOMINATORS);\n \n-  /* Setup callbacks for the generic dominator tree walker.  */\n-  nontrap_set = nontrap;\n-  walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.initialize_block_local_data = NULL;\n-  walk_data.before_dom_children = nt_init_block;\n-  walk_data.after_dom_children = nt_fini_block;\n-  walk_data.global_data = NULL;\n-  walk_data.block_local_data_size = 0;\n-\n-  init_walk_dominator_tree (&walk_data);\n-  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n-  fini_walk_dominator_tree (&walk_data);\n+  nontrapping_dom_walker (CDI_DOMINATORS, nontrap)\n+    .walk (cfun->cfg->x_entry_block_ptr);\n+\n   seen_ssa_names.dispose ();\n \n   clear_aux_for_blocks ();"}, {"sha": "c53ec44913ab1075fcf6b0d2587d20fa6630f710", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=4d9192b50c325156ab000884a57a3d7cfe4f79c6", "patch": "@@ -4051,10 +4051,19 @@ eliminate_insert (gimple_stmt_iterator *gsi, tree val)\n   return res;\n }\n \n+class eliminate_dom_walker : public dom_walker\n+{\n+public:\n+  eliminate_dom_walker (cdi_direction direction) : dom_walker (direction) {}\n+\n+  virtual void before_dom_children (basic_block);\n+  virtual void after_dom_children (basic_block);\n+};\n+\n /* Perform elimination for the basic-block B during the domwalk.  */\n \n-static void\n-eliminate_bb (dom_walk_data *, basic_block b)\n+void\n+eliminate_dom_walker::before_dom_children (basic_block b)\n {\n   gimple_stmt_iterator gsi;\n   gimple stmt;\n@@ -4403,8 +4412,8 @@ eliminate_bb (dom_walk_data *, basic_block b)\n \n /* Make no longer available leaders no longer available.  */\n \n-static void\n-eliminate_leave_block (dom_walk_data *, basic_block)\n+void\n+eliminate_dom_walker::after_dom_children (basic_block)\n {\n   tree entry;\n   while ((entry = el_avail_stack.pop ()) != NULL_TREE)\n@@ -4416,7 +4425,6 @@ eliminate_leave_block (dom_walk_data *, basic_block)\n static unsigned int\n eliminate (void)\n {\n-  struct dom_walk_data walk_data;\n   gimple_stmt_iterator gsi;\n   gimple stmt;\n   unsigned i;\n@@ -4430,15 +4438,7 @@ eliminate (void)\n   el_avail.create (0);\n   el_avail_stack.create (0);\n \n-  walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.initialize_block_local_data = NULL;\n-  walk_data.before_dom_children = eliminate_bb;\n-  walk_data.after_dom_children = eliminate_leave_block;\n-  walk_data.global_data = NULL;\n-  walk_data.block_local_data_size = 0;\n-  init_walk_dominator_tree (&walk_data);\n-  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n-  fini_walk_dominator_tree (&walk_data);\n+  eliminate_dom_walker (CDI_DOMINATORS).walk (cfun->cfg->x_entry_block_ptr);\n \n   el_avail.release ();\n   el_avail_stack.release ();"}, {"sha": "c30ab33ef28870caceb6d26fdf0d30481e864ddd", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=4d9192b50c325156ab000884a57a3d7cfe4f79c6", "patch": "@@ -1926,12 +1926,20 @@ do_invalidate (basic_block dombb, gimple phi, bitmap visited, int *count)\n     }\n }\n \n+class strlen_dom_walker : public dom_walker\n+{\n+public:\n+  strlen_dom_walker (cdi_direction direction) : dom_walker (direction) {}\n+\n+  virtual void before_dom_children (basic_block);\n+  virtual void after_dom_children (basic_block);\n+};\n+\n /* Callback for walk_dominator_tree.  Attempt to optimize various\n    string ops by remembering string lenths pointed by pointer SSA_NAMEs.  */\n \n-static void\n-strlen_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t    basic_block bb)\n+void\n+strlen_dom_walker::before_dom_children (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n   basic_block dombb = get_immediate_dominator (CDI_DOMINATORS, bb);\n@@ -2014,9 +2022,8 @@ strlen_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n /* Callback for walk_dominator_tree.  Free strinfo vector if it is\n    owned by the current bb, clear bb->aux.  */\n \n-static void\n-strlen_leave_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t    basic_block bb)\n+void\n+strlen_dom_walker::after_dom_children (basic_block bb)\n {\n   if (bb->aux)\n     {\n@@ -2040,8 +2047,6 @@ strlen_leave_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n static unsigned int\n tree_ssa_strlen (void)\n {\n-  struct dom_walk_data walk_data;\n-\n   ssa_ver_to_stridx.safe_grow_cleared (num_ssa_names);\n   max_stridx = 1;\n   strinfo_pool = create_alloc_pool (\"strinfo_struct pool\",\n@@ -2051,21 +2056,7 @@ tree_ssa_strlen (void)\n \n   /* String length optimization is implemented as a walk of the dominator\n      tree and a forward walk of statements within each block.  */\n-  walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.initialize_block_local_data = NULL;\n-  walk_data.before_dom_children = strlen_enter_block;\n-  walk_data.after_dom_children = strlen_leave_block;\n-  walk_data.block_local_data_size = 0;\n-  walk_data.global_data = NULL;\n-\n-  /* Initialize the dominator walker.  */\n-  init_walk_dominator_tree (&walk_data);\n-\n-  /* Recursively walk the dominator tree.  */\n-  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n-\n-  /* Finalize the dominator walker.  */\n-  fini_walk_dominator_tree (&walk_data);\n+  strlen_dom_walker (CDI_DOMINATORS).walk (cfun->cfg->x_entry_block_ptr);\n \n   ssa_ver_to_stridx.release ();\n   free_alloc_pool (strinfo_pool);"}, {"sha": "a13ccf011354768b8500469888af93d12aae6fe1", "filename": "gcc/tree-ssa-uncprop.c", "status": "modified", "additions": 35, "deletions": 37, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Ftree-ssa-uncprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d9192b50c325156ab000884a57a3d7cfe4f79c6/gcc%2Ftree-ssa-uncprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uncprop.c?ref=4d9192b50c325156ab000884a57a3d7cfe4f79c6", "patch": "@@ -259,11 +259,6 @@ associate_equivalences_with_edges (void)\n    so with each value we have a list of SSA_NAMEs that have the\n    same value.  */\n \n-/* As we enter each block we record the value for any edge equivalency\n-   leading to this block.  If no such edge equivalency exists, then we\n-   record NULL.  These equivalences are live until we leave the dominator\n-   subtree rooted at the block where we record the equivalency.  */\n-static vec<tree> equiv_stack;\n \n /* Main structure for recording equivalences into our hash table.  */\n struct equiv_hash_elt\n@@ -316,8 +311,6 @@ val_ssa_equiv_hasher::remove (value_type *elt)\n    able to reuse tree-vn for this code.  */\n static hash_table <val_ssa_equiv_hasher> val_ssa_equiv;\n \n-static void uncprop_enter_block (struct dom_walk_data *, basic_block);\n-static void uncprop_leave_block (struct dom_walk_data *, basic_block);\n static void uncprop_into_successor_phis (basic_block);\n \n /* Remove the most recently recorded equivalency for VALUE.  */\n@@ -361,47 +354,54 @@ record_equiv (tree value, tree equivalence)\n   an_equiv_elt_p->equivalences.safe_push (equivalence);\n }\n \n+class uncprop_dom_walker : public dom_walker\n+{\n+public:\n+  uncprop_dom_walker (cdi_direction direction)\n+    : dom_walker (direction)\n+  {\n+    equiv_stack_.create (2);\n+  }\n+  ~uncprop_dom_walker ()\n+  {\n+    equiv_stack_.release ();\n+  }\n+\n+  virtual void before_dom_children (basic_block);\n+  virtual void after_dom_children (basic_block);\n+\n+private:\n+\n+/* As we enter each block we record the value for any edge equivalency\n+   leading to this block.  If no such edge equivalency exists, then we\n+   record NULL.  These equivalences are live until we leave the dominator\n+   subtree rooted at the block where we record the equivalency.  */\n+  vec<tree> equiv_stack_;\n+};\n+\n /* Main driver for un-cprop.  */\n \n static unsigned int\n tree_ssa_uncprop (void)\n {\n-  struct dom_walk_data walk_data;\n   basic_block bb;\n \n   associate_equivalences_with_edges ();\n \n   /* Create our global data structures.  */\n   val_ssa_equiv.create (1024);\n-  equiv_stack.create (2);\n \n   /* We're going to do a dominator walk, so ensure that we have\n      dominance information.  */\n   calculate_dominance_info (CDI_DOMINATORS);\n \n-  /* Setup callbacks for the generic dominator tree walker.  */\n-  walk_data.dom_direction = CDI_DOMINATORS;\n-  walk_data.initialize_block_local_data = NULL;\n-  walk_data.before_dom_children = uncprop_enter_block;\n-  walk_data.after_dom_children = uncprop_leave_block;\n-  walk_data.global_data = NULL;\n-  walk_data.block_local_data_size = 0;\n-\n-  /* Now initialize the dominator walker.  */\n-  init_walk_dominator_tree (&walk_data);\n-\n   /* Recursively walk the dominator tree undoing unprofitable\n      constant/copy propagations.  */\n-  walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n-\n-  /* Finalize and clean up.  */\n-  fini_walk_dominator_tree (&walk_data);\n+  uncprop_dom_walker (CDI_DOMINATORS).walk (cfun->cfg->x_entry_block_ptr);\n \n-  /* EQUIV_STACK should already be empty at this point, so we just\n-     need to empty elements out of the hash table, free EQUIV_STACK,\n-     and cleanup the AUX field on the edges.  */\n+  /* we just need to empty elements out of the hash table, and cleanup the\n+    AUX field on the edges.  */\n   val_ssa_equiv.dispose ();\n-  equiv_stack.release ();\n   FOR_EACH_BB (bb)\n     {\n       edge e;\n@@ -424,12 +424,11 @@ tree_ssa_uncprop (void)\n    any finalization actions in preparation for leaving this node in\n    the dominator tree.  */\n \n-static void\n-uncprop_leave_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t     basic_block bb ATTRIBUTE_UNUSED)\n+void\n+uncprop_dom_walker::after_dom_children (basic_block bb ATTRIBUTE_UNUSED)\n {\n   /* Pop the topmost value off the equiv stack.  */\n-  tree value = equiv_stack.pop ();\n+  tree value = equiv_stack_.pop ();\n \n   /* If that value was non-null, then pop the topmost equivalency off\n      its equivalency stack.  */\n@@ -547,9 +546,8 @@ single_incoming_edge_ignoring_loop_edges (basic_block bb)\n   return retval;\n }\n \n-static void\n-uncprop_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n-\t\t     basic_block bb)\n+void\n+uncprop_dom_walker::before_dom_children (basic_block bb)\n {\n   basic_block parent;\n   edge e;\n@@ -568,13 +566,13 @@ uncprop_enter_block (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \t  struct edge_equivalency *equiv = (struct edge_equivalency *) e->aux;\n \n \t  record_equiv (equiv->rhs, equiv->lhs);\n-\t  equiv_stack.safe_push (equiv->rhs);\n+\t  equiv_stack_.safe_push (equiv->rhs);\n \t  recorded = true;\n \t}\n     }\n \n   if (!recorded)\n-    equiv_stack.safe_push (NULL_TREE);\n+    equiv_stack_.safe_push (NULL_TREE);\n \n   uncprop_into_successor_phis (bb);\n }"}]}