{"sha": "98906124e3aa4cb17695d900fe19498e5bde63e4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg5MDYxMjRlM2FhNGNiMTc2OTVkOTAwZmUxOTQ5OGU1YmRlNjNlNA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-10-26T10:14:34Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-10-26T10:14:34Z"}, "message": "Makefile.def (target_modules): Remove libmudflap\n\n\t* Makefile.def (target_modules): Remove libmudflap\n\t(languages): Remove check-target-libmudflap).\n\t* Makefile.in: Rebuilt.\n\t* Makefile.tpl (check-target-libmudflap-c++): Remove.\n\t* configure.ac (target_libraries): Remove target-libmudflap.\n\tRemove checks which disabled libmudflap on some systems.\n\t* configure: Rebuilt.\n\t* libmudflap: Directory removed.\n\n\t* Makefile.in (C_COMMON_OBJS): Remove tree-mudflap.\n\t(OBJS): Remove tree-nomudflap.o\n\t(GTFILES): Remove tree-mudflap.c\n\t* builtins.c (expand_builtin_alloc): Remove mudflap support.\n\t* gcc.c (MFWRAP_SPEC, MFLIB_SPEC): Likewise.\n\t(mfwrap_spec, mflib_spec): Likewise.\n\t(cpp_unique_options, cc1_options, static_specs): Likewise.\n\t* gimplify (gimplify_vla_decl, build_va_arg_indirect_ref): Likewise.\n\t* passes.def: Likewise.\n\t* toplev.c (compile_file, process_options): Likewise.\n\t* tree-inline.c (copy_tree_r): Likewise.\n\t* tree-pass.,h (make_pass_mudflap_1, make_pass_mudflap_2): Likewise.\n\t* varasm.c (make_decl_rtl, make_decl_rtl_for_debug): Likewise.\n\t(build_constant_desc, output_constant_def_contents): Likewise.\n\t(categorize_decl_for_section): Likewise.\n\t* tree-mudflap.c: Removed.\n\t* tree-mudflap.h: Removed.\n\t* tree-nomudflap.c: Removed.\n\t* bfin/uclinux.h (MFWRAP_SPEC): Remove.\n\t* moxie/uclinux.h (MFWRAP_SPEC): Likewise.\n\t* rs6000/aix.h (MFWRAP_SPEC, MFLIB_SPEC): Likewise.\n\t* config/sol2.h (MFLIB_SPEC): Likewise.\n\t* doc/install.texi: Remove mudflap references.\n\t* doc/passes.texi: Similarly.\n\t* doc/sourcebuild.texi: Similarly.\n\t* doc/invoke.texi: Remove mudlfap related options.\n\n\t* c-family/c-common.c (c_define_builtins): Remove mudflap support.\n\t* c-family/c.opt: Ignore and warn for mudflap options.\n\n\t* g++.dg/torture/pr49309.C: Removed.\n\t* gcc.dg/dfp/pr35739.c: Removed.\n\nFrom-SVN: r204090", "tree": {"sha": "db4fb2e3b3425e4080112ab6c0fa8e4922a5a2d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db4fb2e3b3425e4080112ab6c0fa8e4922a5a2d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98906124e3aa4cb17695d900fe19498e5bde63e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98906124e3aa4cb17695d900fe19498e5bde63e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98906124e3aa4cb17695d900fe19498e5bde63e4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98906124e3aa4cb17695d900fe19498e5bde63e4/comments", "author": null, "committer": null, "parents": [{"sha": "19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19b632c6dd5e1e901ae1bac3fc92164a724ccab5"}], "stats": {"total": 31820, "additions": 70, "deletions": 31750}, "files": [{"sha": "2b27bce672643e2514b86f290c70b3c413b84691", "filename": "ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -1,3 +1,14 @@\n+2013-10-26  Jeff Law  <law@redhat.com>\n+\n+\t* Makefile.def (target_modules): Remove libmudflap\n+\t(languages): Remove check-target-libmudflap).\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.tpl (check-target-libmudflap-c++): Remove.\n+\t* configure.ac (target_libraries): Remove target-libmudflap.\n+\tRemove checks which disabled libmudflap on some systems.\n+\t* configure: Rebuilt.\n+\t* libmudflap: Directory removed.\n+\n 2013-10-21  Cong Hou  <congh@google.com>\n \n \t* MAINTAINERS (Write After Approval): Add myself."}, {"sha": "bf1697249e82579c3132823d81c13ff6ca8aaa75", "filename": "MAINTAINERS", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -239,7 +239,6 @@ tree-ssa\t\tDiego Novillo\t\tdnovillo@google.com\n tree-ssa\t\tAndrew MacLeod\t\tamacleod@redhat.com\n PRE\t\t\tDaniel Berlin\t\tdberlin@dberlin.org\n code sinking\t\tDaniel Berlin\t\tdberlin@dberlin.org\n-mudflap\t\t\tFrank Ch. Eigler\tfche@redhat.com\n tree browser/unparser\tSebastian Pop\t\tsebastian.pop@amd.com\n scev, data dependence\tDaniel Berlin\t\tdberlin@dberlin.org\n scev, data dependence\tSebastian Pop\t\tsebastian.pop@amd.com"}, {"sha": "df4b2242e9670cb05bf245917daa04df45999204", "filename": "Makefile.def", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -117,7 +117,6 @@ target_modules = { module= libstdc++-v3;\n \t\t   bootstrap=true;\n \t\t   lib_path=src/.libs;\n \t\t   raw_cxx=true; };\n-target_modules = { module= libmudflap; lib_path=.libs; };\n target_modules = { module= libsanitizer;\n \t\t   bootstrap=true;\n \t\t   lib_path=.libs;\n@@ -551,7 +550,6 @@ dependencies = { module=configure-target-libgfortran; on=all-target-libquadmath;\n languages = { language=c;\tgcc-check-target=check-gcc; };\n languages = { language=c++;\tgcc-check-target=check-c++;\n \t\t\t\tlib-check-target=check-target-libstdc++-v3;\n-\t\t\t\tlib-check-target=check-target-libmudflap-c++;\n \t\t\t\tlib-check-target=check-target-libitm-c++;\n \t\t\t\tlib-check-target=check-target-libgomp-c++; };\n languages = { language=fortran;\tgcc-check-target=check-fortran;"}, {"sha": "ff434fed3151ef071e617f9fbce28eadfa365451", "filename": "Makefile.in", "status": "modified", "additions": 2, "deletions": 493, "changes": 495, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -575,16 +575,12 @@ all:\n \n # This is the list of directories that may be needed in RPATH_ENVVAR\n # so that programs built for the target machine work.\n-TARGET_LIB_PATH = $(TARGET_LIB_PATH_libstdc++-v3)$(TARGET_LIB_PATH_libmudflap)$(TARGET_LIB_PATH_libsanitizer)$(TARGET_LIB_PATH_libvtv)$(TARGET_LIB_PATH_libssp)$(TARGET_LIB_PATH_libgomp)$(TARGET_LIB_PATH_libitm)$(TARGET_LIB_PATH_libatomic)$(HOST_LIB_PATH_gcc)\n+TARGET_LIB_PATH = $(TARGET_LIB_PATH_libstdc++-v3)$(TARGET_LIB_PATH_libsanitizer)$(TARGET_LIB_PATH_libvtv)$(TARGET_LIB_PATH_libssp)$(TARGET_LIB_PATH_libgomp)$(TARGET_LIB_PATH_libitm)$(TARGET_LIB_PATH_libatomic)$(HOST_LIB_PATH_gcc)\n \n @if target-libstdc++-v3\n TARGET_LIB_PATH_libstdc++-v3 = $$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs:\n @endif target-libstdc++-v3\n \n-@if target-libmudflap\n-TARGET_LIB_PATH_libmudflap = $$r/$(TARGET_SUBDIR)/libmudflap/.libs:\n-@endif target-libmudflap\n-\n @if target-libsanitizer\n TARGET_LIB_PATH_libsanitizer = $$r/$(TARGET_SUBDIR)/libsanitizer/.libs:\n @endif target-libsanitizer\n@@ -927,7 +923,6 @@ configure-host:  \\\n .PHONY: configure-target\n configure-target:  \\\n     maybe-configure-target-libstdc++-v3 \\\n-    maybe-configure-target-libmudflap \\\n     maybe-configure-target-libsanitizer \\\n     maybe-configure-target-libvtv \\\n     maybe-configure-target-libssp \\\n@@ -1077,7 +1072,6 @@ all-host: maybe-all-lto-plugin\n @if target-libstdc++-v3-no-bootstrap\n all-target: maybe-all-target-libstdc++-v3\n @endif target-libstdc++-v3-no-bootstrap\n-all-target: maybe-all-target-libmudflap\n @if target-libsanitizer-no-bootstrap\n all-target: maybe-all-target-libsanitizer\n @endif target-libsanitizer-no-bootstrap\n@@ -1173,7 +1167,6 @@ info-host: maybe-info-lto-plugin\n .PHONY: info-target\n \n info-target: maybe-info-target-libstdc++-v3\n-info-target: maybe-info-target-libmudflap\n info-target: maybe-info-target-libsanitizer\n info-target: maybe-info-target-libvtv\n info-target: maybe-info-target-libssp\n@@ -1256,7 +1249,6 @@ dvi-host: maybe-dvi-lto-plugin\n .PHONY: dvi-target\n \n dvi-target: maybe-dvi-target-libstdc++-v3\n-dvi-target: maybe-dvi-target-libmudflap\n dvi-target: maybe-dvi-target-libsanitizer\n dvi-target: maybe-dvi-target-libvtv\n dvi-target: maybe-dvi-target-libssp\n@@ -1339,7 +1331,6 @@ pdf-host: maybe-pdf-lto-plugin\n .PHONY: pdf-target\n \n pdf-target: maybe-pdf-target-libstdc++-v3\n-pdf-target: maybe-pdf-target-libmudflap\n pdf-target: maybe-pdf-target-libsanitizer\n pdf-target: maybe-pdf-target-libvtv\n pdf-target: maybe-pdf-target-libssp\n@@ -1422,7 +1413,6 @@ html-host: maybe-html-lto-plugin\n .PHONY: html-target\n \n html-target: maybe-html-target-libstdc++-v3\n-html-target: maybe-html-target-libmudflap\n html-target: maybe-html-target-libsanitizer\n html-target: maybe-html-target-libvtv\n html-target: maybe-html-target-libssp\n@@ -1505,7 +1495,6 @@ TAGS-host: maybe-TAGS-lto-plugin\n .PHONY: TAGS-target\n \n TAGS-target: maybe-TAGS-target-libstdc++-v3\n-TAGS-target: maybe-TAGS-target-libmudflap\n TAGS-target: maybe-TAGS-target-libsanitizer\n TAGS-target: maybe-TAGS-target-libvtv\n TAGS-target: maybe-TAGS-target-libssp\n@@ -1588,7 +1577,6 @@ install-info-host: maybe-install-info-lto-plugin\n .PHONY: install-info-target\n \n install-info-target: maybe-install-info-target-libstdc++-v3\n-install-info-target: maybe-install-info-target-libmudflap\n install-info-target: maybe-install-info-target-libsanitizer\n install-info-target: maybe-install-info-target-libvtv\n install-info-target: maybe-install-info-target-libssp\n@@ -1671,7 +1659,6 @@ install-pdf-host: maybe-install-pdf-lto-plugin\n .PHONY: install-pdf-target\n \n install-pdf-target: maybe-install-pdf-target-libstdc++-v3\n-install-pdf-target: maybe-install-pdf-target-libmudflap\n install-pdf-target: maybe-install-pdf-target-libsanitizer\n install-pdf-target: maybe-install-pdf-target-libvtv\n install-pdf-target: maybe-install-pdf-target-libssp\n@@ -1754,7 +1741,6 @@ install-html-host: maybe-install-html-lto-plugin\n .PHONY: install-html-target\n \n install-html-target: maybe-install-html-target-libstdc++-v3\n-install-html-target: maybe-install-html-target-libmudflap\n install-html-target: maybe-install-html-target-libsanitizer\n install-html-target: maybe-install-html-target-libvtv\n install-html-target: maybe-install-html-target-libssp\n@@ -1837,7 +1823,6 @@ installcheck-host: maybe-installcheck-lto-plugin\n .PHONY: installcheck-target\n \n installcheck-target: maybe-installcheck-target-libstdc++-v3\n-installcheck-target: maybe-installcheck-target-libmudflap\n installcheck-target: maybe-installcheck-target-libsanitizer\n installcheck-target: maybe-installcheck-target-libvtv\n installcheck-target: maybe-installcheck-target-libssp\n@@ -1920,7 +1905,6 @@ mostlyclean-host: maybe-mostlyclean-lto-plugin\n .PHONY: mostlyclean-target\n \n mostlyclean-target: maybe-mostlyclean-target-libstdc++-v3\n-mostlyclean-target: maybe-mostlyclean-target-libmudflap\n mostlyclean-target: maybe-mostlyclean-target-libsanitizer\n mostlyclean-target: maybe-mostlyclean-target-libvtv\n mostlyclean-target: maybe-mostlyclean-target-libssp\n@@ -2003,7 +1987,6 @@ clean-host: maybe-clean-lto-plugin\n .PHONY: clean-target\n \n clean-target: maybe-clean-target-libstdc++-v3\n-clean-target: maybe-clean-target-libmudflap\n clean-target: maybe-clean-target-libsanitizer\n clean-target: maybe-clean-target-libvtv\n clean-target: maybe-clean-target-libssp\n@@ -2086,7 +2069,6 @@ distclean-host: maybe-distclean-lto-plugin\n .PHONY: distclean-target\n \n distclean-target: maybe-distclean-target-libstdc++-v3\n-distclean-target: maybe-distclean-target-libmudflap\n distclean-target: maybe-distclean-target-libsanitizer\n distclean-target: maybe-distclean-target-libvtv\n distclean-target: maybe-distclean-target-libssp\n@@ -2169,7 +2151,6 @@ maintainer-clean-host: maybe-maintainer-clean-lto-plugin\n .PHONY: maintainer-clean-target\n \n maintainer-clean-target: maybe-maintainer-clean-target-libstdc++-v3\n-maintainer-clean-target: maybe-maintainer-clean-target-libmudflap\n maintainer-clean-target: maybe-maintainer-clean-target-libsanitizer\n maintainer-clean-target: maybe-maintainer-clean-target-libvtv\n maintainer-clean-target: maybe-maintainer-clean-target-libssp\n@@ -2307,7 +2288,6 @@ check-host:  \\\n .PHONY: check-target\n check-target:  \\\n     maybe-check-target-libstdc++-v3 \\\n-    maybe-check-target-libmudflap \\\n     maybe-check-target-libsanitizer \\\n     maybe-check-target-libvtv \\\n     maybe-check-target-libssp \\\n@@ -2463,7 +2443,6 @@ install-host:  \\\n .PHONY: install-target\n install-target:  \\\n     maybe-install-target-libstdc++-v3 \\\n-    maybe-install-target-libmudflap \\\n     maybe-install-target-libsanitizer \\\n     maybe-install-target-libvtv \\\n     maybe-install-target-libssp \\\n@@ -2566,7 +2545,6 @@ install-strip-host:  \\\n .PHONY: install-strip-target\n install-strip-target:  \\\n     maybe-install-strip-target-libstdc++-v3 \\\n-    maybe-install-strip-target-libmudflap \\\n     maybe-install-strip-target-libsanitizer \\\n     maybe-install-strip-target-libvtv \\\n     maybe-install-strip-target-libssp \\\n@@ -31745,463 +31723,6 @@ maintainer-clean-target-libstdc++-v3:\n \n \n \n-.PHONY: configure-target-libmudflap maybe-configure-target-libmudflap\n-maybe-configure-target-libmudflap:\n-@if gcc-bootstrap\n-configure-target-libmudflap: stage_current\n-@endif gcc-bootstrap\n-@if target-libmudflap\n-maybe-configure-target-libmudflap: configure-target-libmudflap\n-configure-target-libmudflap: \n-\t@: $(MAKE); $(unstage)\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\techo \"Checking multilib configuration for libmudflap...\"; \\\n-\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libmudflap ; \\\n-\t$(CC_FOR_TARGET) --print-multi-lib > $(TARGET_SUBDIR)/libmudflap/multilib.tmp 2> /dev/null ; \\\n-\tif test -r $(TARGET_SUBDIR)/libmudflap/multilib.out; then \\\n-\t  if cmp -s $(TARGET_SUBDIR)/libmudflap/multilib.tmp $(TARGET_SUBDIR)/libmudflap/multilib.out; then \\\n-\t    rm -f $(TARGET_SUBDIR)/libmudflap/multilib.tmp; \\\n-\t  else \\\n-\t    rm -f $(TARGET_SUBDIR)/libmudflap/Makefile; \\\n-\t    mv $(TARGET_SUBDIR)/libmudflap/multilib.tmp $(TARGET_SUBDIR)/libmudflap/multilib.out; \\\n-\t  fi; \\\n-\telse \\\n-\t  mv $(TARGET_SUBDIR)/libmudflap/multilib.tmp $(TARGET_SUBDIR)/libmudflap/multilib.out; \\\n-\tfi; \\\n-\ttest ! -f $(TARGET_SUBDIR)/libmudflap/Makefile || exit 0; \\\n-\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libmudflap ; \\\n-\t$(NORMAL_TARGET_EXPORTS)  \\\n-\techo Configuring in $(TARGET_SUBDIR)/libmudflap; \\\n-\tcd \"$(TARGET_SUBDIR)/libmudflap\" || exit 1; \\\n-\tcase $(srcdir) in \\\n-\t  /* | [A-Za-z]:[\\\\/]*) topdir=$(srcdir) ;; \\\n-\t  *) topdir=`echo $(TARGET_SUBDIR)/libmudflap/ | \\\n-\t\tsed -e 's,\\./,,g' -e 's,[^/]*/,../,g' `$(srcdir) ;; \\\n-\tesac; \\\n-\tsrcdiroption=\"--srcdir=$${topdir}/libmudflap\"; \\\n-\tlibsrcdir=\"$$s/libmudflap\"; \\\n-\trm -f no-such-file || : ; \\\n-\tCONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \\\n-\t  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \\\n-\t  --target=${target_alias} $${srcdiroption}  \\\n-\t  || exit 1\n-@endif target-libmudflap\n-\n-\n-\n-\n-\n-.PHONY: all-target-libmudflap maybe-all-target-libmudflap\n-maybe-all-target-libmudflap:\n-@if gcc-bootstrap\n-all-target-libmudflap: stage_current\n-@endif gcc-bootstrap\n-@if target-libmudflap\n-TARGET-target-libmudflap=all\n-maybe-all-target-libmudflap: all-target-libmudflap\n-all-target-libmudflap: configure-target-libmudflap\n-\t@: $(MAKE); $(unstage)\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS)  \\\n-\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) $(EXTRA_TARGET_FLAGS)   \\\n-\t\t$(TARGET-target-libmudflap))\n-@endif target-libmudflap\n-\n-\n-\n-\n-\n-.PHONY: check-target-libmudflap maybe-check-target-libmudflap\n-maybe-check-target-libmudflap:\n-@if target-libmudflap\n-maybe-check-target-libmudflap: check-target-libmudflap\n-\n-check-target-libmudflap:\n-\t@: $(MAKE); $(unstage)\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n-\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)   check)\n-\n-@endif target-libmudflap\n-\n-.PHONY: install-target-libmudflap maybe-install-target-libmudflap\n-maybe-install-target-libmudflap:\n-@if target-libmudflap\n-maybe-install-target-libmudflap: install-target-libmudflap\n-\n-install-target-libmudflap: installdirs\n-\t@: $(MAKE); $(unstage)\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n-\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install)\n-\n-@endif target-libmudflap\n-\n-.PHONY: install-strip-target-libmudflap maybe-install-strip-target-libmudflap\n-maybe-install-strip-target-libmudflap:\n-@if target-libmudflap\n-maybe-install-strip-target-libmudflap: install-strip-target-libmudflap\n-\n-install-strip-target-libmudflap: installdirs\n-\t@: $(MAKE); $(unstage)\n-\t@r=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n-\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  install-strip)\n-\n-@endif target-libmudflap\n-\n-# Other targets (info, dvi, pdf, etc.)\n-\n-.PHONY: maybe-info-target-libmudflap info-target-libmudflap\n-maybe-info-target-libmudflap:\n-@if target-libmudflap\n-maybe-info-target-libmudflap: info-target-libmudflap\n-\n-info-target-libmudflap: \\\n-    configure-target-libmudflap \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing info in $(TARGET_SUBDIR)/libmudflap\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           info) \\\n-\t  || exit 1\n-\n-@endif target-libmudflap\n-\n-.PHONY: maybe-dvi-target-libmudflap dvi-target-libmudflap\n-maybe-dvi-target-libmudflap:\n-@if target-libmudflap\n-maybe-dvi-target-libmudflap: dvi-target-libmudflap\n-\n-dvi-target-libmudflap: \\\n-    configure-target-libmudflap \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing dvi in $(TARGET_SUBDIR)/libmudflap\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           dvi) \\\n-\t  || exit 1\n-\n-@endif target-libmudflap\n-\n-.PHONY: maybe-pdf-target-libmudflap pdf-target-libmudflap\n-maybe-pdf-target-libmudflap:\n-@if target-libmudflap\n-maybe-pdf-target-libmudflap: pdf-target-libmudflap\n-\n-pdf-target-libmudflap: \\\n-    configure-target-libmudflap \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing pdf in $(TARGET_SUBDIR)/libmudflap\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           pdf) \\\n-\t  || exit 1\n-\n-@endif target-libmudflap\n-\n-.PHONY: maybe-html-target-libmudflap html-target-libmudflap\n-maybe-html-target-libmudflap:\n-@if target-libmudflap\n-maybe-html-target-libmudflap: html-target-libmudflap\n-\n-html-target-libmudflap: \\\n-    configure-target-libmudflap \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing html in $(TARGET_SUBDIR)/libmudflap\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           html) \\\n-\t  || exit 1\n-\n-@endif target-libmudflap\n-\n-.PHONY: maybe-TAGS-target-libmudflap TAGS-target-libmudflap\n-maybe-TAGS-target-libmudflap:\n-@if target-libmudflap\n-maybe-TAGS-target-libmudflap: TAGS-target-libmudflap\n-\n-TAGS-target-libmudflap: \\\n-    configure-target-libmudflap \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing TAGS in $(TARGET_SUBDIR)/libmudflap\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           TAGS) \\\n-\t  || exit 1\n-\n-@endif target-libmudflap\n-\n-.PHONY: maybe-install-info-target-libmudflap install-info-target-libmudflap\n-maybe-install-info-target-libmudflap:\n-@if target-libmudflap\n-maybe-install-info-target-libmudflap: install-info-target-libmudflap\n-\n-install-info-target-libmudflap: \\\n-    configure-target-libmudflap \\\n-    info-target-libmudflap \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing install-info in $(TARGET_SUBDIR)/libmudflap\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           install-info) \\\n-\t  || exit 1\n-\n-@endif target-libmudflap\n-\n-.PHONY: maybe-install-pdf-target-libmudflap install-pdf-target-libmudflap\n-maybe-install-pdf-target-libmudflap:\n-@if target-libmudflap\n-maybe-install-pdf-target-libmudflap: install-pdf-target-libmudflap\n-\n-install-pdf-target-libmudflap: \\\n-    configure-target-libmudflap \\\n-    pdf-target-libmudflap \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing install-pdf in $(TARGET_SUBDIR)/libmudflap\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           install-pdf) \\\n-\t  || exit 1\n-\n-@endif target-libmudflap\n-\n-.PHONY: maybe-install-html-target-libmudflap install-html-target-libmudflap\n-maybe-install-html-target-libmudflap:\n-@if target-libmudflap\n-maybe-install-html-target-libmudflap: install-html-target-libmudflap\n-\n-install-html-target-libmudflap: \\\n-    configure-target-libmudflap \\\n-    html-target-libmudflap \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing install-html in $(TARGET_SUBDIR)/libmudflap\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           install-html) \\\n-\t  || exit 1\n-\n-@endif target-libmudflap\n-\n-.PHONY: maybe-installcheck-target-libmudflap installcheck-target-libmudflap\n-maybe-installcheck-target-libmudflap:\n-@if target-libmudflap\n-maybe-installcheck-target-libmudflap: installcheck-target-libmudflap\n-\n-installcheck-target-libmudflap: \\\n-    configure-target-libmudflap \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing installcheck in $(TARGET_SUBDIR)/libmudflap\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           installcheck) \\\n-\t  || exit 1\n-\n-@endif target-libmudflap\n-\n-.PHONY: maybe-mostlyclean-target-libmudflap mostlyclean-target-libmudflap\n-maybe-mostlyclean-target-libmudflap:\n-@if target-libmudflap\n-maybe-mostlyclean-target-libmudflap: mostlyclean-target-libmudflap\n-\n-mostlyclean-target-libmudflap: \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing mostlyclean in $(TARGET_SUBDIR)/libmudflap\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           mostlyclean) \\\n-\t  || exit 1\n-\n-@endif target-libmudflap\n-\n-.PHONY: maybe-clean-target-libmudflap clean-target-libmudflap\n-maybe-clean-target-libmudflap:\n-@if target-libmudflap\n-maybe-clean-target-libmudflap: clean-target-libmudflap\n-\n-clean-target-libmudflap: \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing clean in $(TARGET_SUBDIR)/libmudflap\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           clean) \\\n-\t  || exit 1\n-\n-@endif target-libmudflap\n-\n-.PHONY: maybe-distclean-target-libmudflap distclean-target-libmudflap\n-maybe-distclean-target-libmudflap:\n-@if target-libmudflap\n-maybe-distclean-target-libmudflap: distclean-target-libmudflap\n-\n-distclean-target-libmudflap: \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing distclean in $(TARGET_SUBDIR)/libmudflap\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           distclean) \\\n-\t  || exit 1\n-\n-@endif target-libmudflap\n-\n-.PHONY: maybe-maintainer-clean-target-libmudflap maintainer-clean-target-libmudflap\n-maybe-maintainer-clean-target-libmudflap:\n-@if target-libmudflap\n-maybe-maintainer-clean-target-libmudflap: maintainer-clean-target-libmudflap\n-\n-maintainer-clean-target-libmudflap: \n-\t@: $(MAKE); $(unstage)\n-\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n-\tr=`${PWD_COMMAND}`; export r; \\\n-\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n-\t$(NORMAL_TARGET_EXPORTS) \\\n-\techo \"Doing maintainer-clean in $(TARGET_SUBDIR)/libmudflap\" ; \\\n-\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n-\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n-\tdone; \\\n-\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n-\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n-\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n-\t          \"RANLIB=$${RANLIB}\" \\\n-\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \"WINDMC=$${WINDMC}\" \\\n-\t           maintainer-clean) \\\n-\t  || exit 1\n-\n-@endif target-libmudflap\n-\n-\n-\n-\n-\n .PHONY: configure-target-libsanitizer maybe-configure-target-libsanitizer\n maybe-configure-target-libsanitizer:\n @if gcc-bootstrap\n@@ -44237,13 +43758,6 @@ maintainer-clean-target-libatomic:\n \n \n \n-@if target-libmudflap\n-.PHONY: check-target-libmudflap-c++\n-check-target-libmudflap-c++:\n-\t$(MAKE) RUNTESTFLAGS=\"$(RUNTESTFLAGS) c++frags.exp\" check-target-libmudflap\n-\n-@endif target-libmudflap\n-\n @if target-libgomp\n .PHONY: check-target-libgomp-c++\n check-target-libgomp-c++:\n@@ -44292,7 +43806,7 @@ check-gcc-c++:\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(HOST_EXPORTS) \\\n \t(cd gcc && $(MAKE) $(GCC_FLAGS_TO_PASS) check-c++);\n-check-c++: check-gcc-c++ check-target-libstdc++-v3 check-target-libmudflap-c++ check-target-libitm-c++ check-target-libgomp-c++\n+check-c++: check-gcc-c++ check-target-libstdc++-v3 check-target-libitm-c++ check-target-libgomp-c++\n \n .PHONY: check-gcc-fortran check-fortran\n check-gcc-fortran:\n@@ -46375,7 +45889,6 @@ configure-stage3-target-libstdc++-v3: maybe-all-stage3-gcc\n configure-stage4-target-libstdc++-v3: maybe-all-stage4-gcc\n configure-stageprofile-target-libstdc++-v3: maybe-all-stageprofile-gcc\n configure-stagefeedback-target-libstdc++-v3: maybe-all-stagefeedback-gcc\n-configure-target-libmudflap: stage_last\n configure-stage1-target-libsanitizer: maybe-all-stage1-gcc\n configure-stage2-target-libsanitizer: maybe-all-stage2-gcc\n configure-stage3-target-libsanitizer: maybe-all-stage3-gcc\n@@ -46422,7 +45935,6 @@ configure-target-libatomic: stage_last\n \n @if gcc-no-bootstrap\n configure-target-libstdc++-v3: maybe-all-gcc\n-configure-target-libmudflap: maybe-all-gcc\n configure-target-libsanitizer: maybe-all-gcc\n configure-target-libvtv: maybe-all-gcc\n configure-target-libssp: maybe-all-gcc\n@@ -47268,7 +46780,6 @@ configure-stagefeedback-target-libgomp: maybe-all-stagefeedback-target-libgcc\n \n @if gcc-no-bootstrap\n configure-target-libstdc++-v3: maybe-all-target-libgcc\n-configure-target-libmudflap: maybe-all-target-libgcc\n configure-target-libsanitizer: maybe-all-target-libgcc\n configure-target-libvtv: maybe-all-target-libgcc\n configure-target-libssp: maybe-all-target-libgcc\n@@ -47295,8 +46806,6 @@ configure-target-libatomic: maybe-all-target-libgcc\n \n configure-target-libstdc++-v3: maybe-all-target-newlib maybe-all-target-libgloss\n \n-configure-target-libmudflap: maybe-all-target-newlib maybe-all-target-libgloss\n-\n configure-target-libsanitizer: maybe-all-target-newlib maybe-all-target-libgloss\n \n configure-target-libvtv: maybe-all-target-newlib maybe-all-target-libgloss"}, {"sha": "3e187e1b9dce81091856a72cdec287358134d74c", "filename": "Makefile.tpl", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/Makefile.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/Makefile.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.tpl?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -1404,13 +1404,6 @@ ENDIF raw_cxx +]\n [+ ENDFOR recursive_targets +]\n [+ ENDFOR target_modules +]\n \n-@if target-libmudflap\n-.PHONY: check-target-libmudflap-c++\n-check-target-libmudflap-c++:\n-\t$(MAKE) RUNTESTFLAGS=\"$(RUNTESTFLAGS) c++frags.exp\" check-target-libmudflap\n-\n-@endif target-libmudflap\n-\n @if target-libgomp\n .PHONY: check-target-libgomp-c++\n check-target-libgomp-c++:"}, {"sha": "7bc49f74aef7932950df13485a9ffecf807b94a4", "filename": "configure", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -2775,7 +2775,6 @@ target_libraries=\"target-libgcc \\\n \t\ttarget-libatomic \\\n \t\ttarget-libitm \\\n \t\ttarget-libstdc++-v3 \\\n-\t\ttarget-libmudflap \\\n \t\ttarget-libsanitizer \\\n \t\ttarget-libvtv \\\n \t\ttarget-libssp \\\n@@ -3128,22 +3127,6 @@ if test x$enable_static_libjava != xyes ; then\n fi\n \n \n-# Disable libmudflap on some systems.\n-if test x$enable_libmudflap = x ; then\n-    case \"${target}\" in\n-    *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu | bfin*-*-uclinux* | *-*-kopensolaris*-gnu)\n-        # Enable libmudflap by default in GNU and friends.\n-\t;;\n-    *-*-freebsd*)\n-        # Enable libmudflap by default in FreeBSD.\n-\t;;\n-    *)\n-        # Disable it by default everywhere else.\n-\tnoconfigdirs=\"$noconfigdirs target-libmudflap\"\n-\t;;\n-    esac\n-fi\n-\n # Disable libgomp on non POSIX hosted systems.\n if test x$enable_libgomp = x ; then\n     # Enable libgomp by default on hosted POSIX systems."}, {"sha": "595b2b921546376efb0c9f1a9e4d42a420376168", "filename": "configure.ac", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -159,7 +159,6 @@ target_libraries=\"target-libgcc \\\n \t\ttarget-libatomic \\\n \t\ttarget-libitm \\\n \t\ttarget-libstdc++-v3 \\\n-\t\ttarget-libmudflap \\\n \t\ttarget-libsanitizer \\\n \t\ttarget-libvtv \\\n \t\ttarget-libssp \\\n@@ -473,22 +472,6 @@ if test x$enable_static_libjava != xyes ; then\n fi\n AC_SUBST(EXTRA_CONFIGARGS_LIBJAVA)\n \n-# Disable libmudflap on some systems.\n-if test x$enable_libmudflap = x ; then\n-    case \"${target}\" in\n-    *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu | bfin*-*-uclinux* | *-*-kopensolaris*-gnu)\n-        # Enable libmudflap by default in GNU and friends.\n-\t;;\n-    *-*-freebsd*)\n-        # Enable libmudflap by default in FreeBSD.\n-\t;;\n-    *)\n-        # Disable it by default everywhere else.\n-\tnoconfigdirs=\"$noconfigdirs target-libmudflap\"\n-\t;;\n-    esac\n-fi\n-\n # Disable libgomp on non POSIX hosted systems.\n if test x$enable_libgomp = x ; then\n     # Enable libgomp by default on hosted POSIX systems."}, {"sha": "2e90a39a067bf098900ed943aa8eb55303951fbb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -1,3 +1,32 @@\n+2013-10-26  Jeff Law  <law@redhat.com>\n+\n+\t* Makefile.in (C_COMMON_OBJS): Remove tree-mudflap.\n+\t(OBJS): Remove tree-nomudflap.o\n+\t(GTFILES): Remove tree-mudflap.c\n+\t* builtins.c (expand_builtin_alloc): Remove mudflap support.\n+\t* gcc.c (MFWRAP_SPEC, MFLIB_SPEC): Likewise.\n+\t(mfwrap_spec, mflib_spec): Likewise.\n+\t(cpp_unique_options, cc1_options, static_specs): Likewise.\n+\t* gimplify (gimplify_vla_decl, build_va_arg_indirect_ref): Likewise.\n+\t* passes.def: Likewise.\n+\t* toplev.c (compile_file, process_options): Likewise.\n+\t* tree-inline.c (copy_tree_r): Likewise.\n+\t* tree-pass.,h (make_pass_mudflap_1, make_pass_mudflap_2): Likewise.\n+\t* varasm.c (make_decl_rtl, make_decl_rtl_for_debug): Likewise.\n+\t(build_constant_desc, output_constant_def_contents): Likewise.\n+\t(categorize_decl_for_section): Likewise.\n+\t* tree-mudflap.c: Removed.\n+\t* tree-mudflap.h: Removed.\n+\t* tree-nomudflap.c: Removed.\n+\t* bfin/uclinux.h (MFWRAP_SPEC): Remove.\n+\t* moxie/uclinux.h (MFWRAP_SPEC): Likewise.\n+\t* rs6000/aix.h (MFWRAP_SPEC, MFLIB_SPEC): Likewise.\n+\t* config/sol2.h (MFLIB_SPEC): Likewise.\n+\t* doc/install.texi: Remove mudflap references.\n+\t* doc/passes.texi: Similarly.\n+\t* doc/sourcebuild.texi: Similarly.\n+\t* doc/invoke.texi: Remove mudlfap related options.\n+\n 2013-10-25  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/58759"}, {"sha": "29609fd1f1de22dd97714400f9078f464fdbe813", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -1132,14 +1132,11 @@ GCC_OBJS = gcc.o ggc-none.o\n c-family-warn = $(STRICT_WARN)\n \n # Language-specific object files shared by all C-family front ends.\n-# FIXME: tree-mudflap is C-family only, but it is also part of the middle-end.\n-# The mudflap machinery should be properly separated from the front ends, and\n-# perhaps turned into a plugin.\n C_COMMON_OBJS = c-family/c-common.o c-family/c-cppbuiltin.o c-family/c-dump.o \\\n   c-family/c-format.o c-family/c-gimplify.o c-family/c-lex.o \\\n   c-family/c-omp.o c-family/c-opts.o c-family/c-pch.o \\\n   c-family/c-ppoutput.o c-family/c-pragma.o c-family/c-pretty-print.o \\\n-  c-family/c-semantics.o c-family/c-ada-spec.o tree-mudflap.o \\\n+  c-family/c-semantics.o c-family/c-ada-spec.o \\\n   c-family/array-notation-common.o c-family/c-ubsan.o\n \n # Language-independent object files.\n@@ -1388,7 +1385,6 @@ OBJS = \\\n \ttree-iterator.o \\\n \ttree-loop-distribution.o \\\n \ttree-nested.o \\\n-\ttree-nomudflap.o \\\n \ttree-nrv.o \\\n \ttree-object-size.o \\\n \ttree-outof-ssa.o \\\n@@ -2252,7 +2248,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/sdbout.c $(srcdir)/stor-layout.c \\\n   $(srcdir)/stringpool.c $(srcdir)/tree.c $(srcdir)/varasm.c \\\n   $(srcdir)/gimple.h \\\n-  $(srcdir)/tree-mudflap.c $(srcdir)/gimple-ssa.h \\\n+  $(srcdir)/gimple-ssa.h \\\n   $(srcdir)/tree-ssanames.c $(srcdir)/tree-eh.c $(srcdir)/tree-ssa-address.c \\\n   $(srcdir)/tree-cfg.c \\\n   $(srcdir)/tree-dfa.c \\"}, {"sha": "10758cac2c40260704d03478599e82d0fb7e3976", "filename": "gcc/builtins.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -4362,10 +4362,6 @@ expand_builtin_alloca (tree exp, bool cannot_accumulate)\n   bool alloca_with_align = (DECL_FUNCTION_CODE (get_callee_fndecl (exp))\n \t\t\t    == BUILT_IN_ALLOCA_WITH_ALIGN);\n \n-  /* Emit normal call if we use mudflap.  */\n-  if (flag_mudflap)\n-    return NULL_RTX;\n-\n   valid_arglist\n     = (alloca_with_align\n        ? validate_arglist (exp, INTEGER_TYPE, INTEGER_TYPE, VOID_TYPE)"}, {"sha": "1fab5a8f890bb8ccb3bc2589b0aea664735a9bc9", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -1,3 +1,8 @@\n+2013-10-26  Jeff Law  <law@redhat.com>\n+\n+\t* c-family/c-common.c (c_define_builtins): Remove mudflap support.\n+\t* c-family/c.opt: Ignore and warn for mudflap options.\n+\n 2013-10-24  Tobias Burnus  <burnus@net-b.de>\n \n \tPR other/33426"}, {"sha": "b20fdd6a1eafe2885299580c238664bc3dd8f84e", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -39,7 +39,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic.h\"\n #include \"tree-iterator.h\"\n #include \"hashtab.h\"\n-#include \"tree-mudflap.h\"\n #include \"opts.h\"\n #include \"cgraph.h\"\n #include \"target-def.h\"\n@@ -5220,9 +5219,6 @@ c_define_builtins (tree va_list_ref_type_node, tree va_list_arg_type_node)\n   targetm.init_builtins ();\n \n   build_common_builtin_nodes ();\n-\n-  if (flag_mudflap)\n-    mudflap_init ();\n }\n \n /* Like get_identifier, but avoid warnings about null arguments when"}, {"sha": "b862eb9e27608c83b49895d16cfb319a7a20d0ab", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -538,8 +538,7 @@ C ObjC Var(warn_missing_prototypes) Warning\n Warn about global functions without prototypes\n \n Wmudflap\n-C ObjC C++ ObjC++ Var(warn_mudflap) Init(1) Warning\n-Warn about constructs not instrumented by -fmudflap\n+C ObjC C++ ObjC++ Ignore Warn(switch %qs is no longer supported)\n \n Wmultichar\n C ObjC C++ ObjC++ Warning\n@@ -997,16 +996,13 @@ C ObjC C++ ObjC++ Var(flag_ms_extensions)\n Don't warn about uses of Microsoft extensions\n \n fmudflap\n-C ObjC C++ ObjC++ RejectNegative Report Var(flag_mudflap)\n-Add mudflap bounds-checking instrumentation for single-threaded program\n+C ObjC C++ ObjC++ Ignore Warn(switch %qs is no longer supported)\n \n fmudflapth\n-C ObjC C++ ObjC++ RejectNegative Report Var(flag_mudflap,2)\n-Add mudflap bounds-checking instrumentation for multi-threaded program\n+C ObjC C++ ObjC++ Ignore Warn(switch %qs is no longer supported)\n \n fmudflapir\n-C ObjC C++ ObjC++ RejectNegative Report Var(flag_mudflap_ignore_reads)\n-Ignore read operations when inserting mudflap instrumentation\n+C ObjC C++ ObjC++ Ignore Warn(switch %qs is no longer supported)\n \n fname-mangling-version-\n C++ ObjC++ Joined Ignore Warn(switch %qs is no longer supported)"}, {"sha": "848515c1bbc138351d31acda43d56daa13e37c0c", "filename": "gcc/config/bfin/uclinux.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fconfig%2Fbfin%2Fuclinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fconfig%2Fbfin%2Fuclinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fuclinux.h?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -32,14 +32,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n   %{mfast-fp:-lbffastfp} %G %L %{mfast-fp:-lbffastfp} %G \\\n \"\n \n-/* Like the definition in gcc.c, but for purposes of uClinux, every link is\n-   static.  */\n-#define MFWRAP_SPEC \" %{fmudflap|fmudflapth: \\\n- --wrap=malloc --wrap=free --wrap=calloc --wrap=realloc\\\n- --wrap=mmap --wrap=munmap --wrap=alloca\\\n- %{fmudflapth: --wrap=pthread_create\\\n-}} %{fmudflap|fmudflapth: --wrap=main}\"\n-\n #undef TARGET_SUPPORTS_SYNC_CALLS\n #define TARGET_SUPPORTS_SYNC_CALLS 1\n "}, {"sha": "fb8c92542b569dcb631b96fc33397b71ab5352a4", "filename": "gcc/config/moxie/uclinux.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fconfig%2Fmoxie%2Fuclinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fconfig%2Fmoxie%2Fuclinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmoxie%2Fuclinux.h?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -30,13 +30,5 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n #define TARGET_OS_CPP_BUILTINS() GNU_USER_TARGET_OS_CPP_BUILTINS()\n \n-/* Like the definition in gcc.c, but for purposes of uClinux, every link is\n-   static.  */\n-#define MFWRAP_SPEC \" %{fmudflap|fmudflapth: \\\n- --wrap=malloc --wrap=free --wrap=calloc --wrap=realloc\\\n- --wrap=mmap --wrap=munmap --wrap=alloca\\\n- %{fmudflapth: --wrap=pthread_create\\\n-}} %{fmudflap|fmudflapth: --wrap=main}\"\n-\n #undef TARGET_LIBC_HAS_FUNCTION\n #define TARGET_LIBC_HAS_FUNCTION no_c99_libc_has_function"}, {"sha": "a11bd57284d4646c341c30a83da263ca8ad00275", "filename": "gcc/config/rs6000/aix.h", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fconfig%2Frs6000%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fconfig%2Frs6000%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix.h?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -66,30 +66,6 @@\n /* Because of the above, we must have gcc search itself to find libgcc.a.  */\n #define LINK_LIBGCC_SPECIAL_1\n \n-#define MFWRAP_SPEC \" %{static: %{fmudflap|fmudflapth: \\\n- -brename:malloc,__wrap_malloc -brename:__real_malloc,malloc \\\n- -brename:free,__wrap_free -brename:__real_free,free \\\n- -brename:calloc,__wrap_calloc -brename:__real_calloc,calloc \\\n- -brename:realloc,__wrap_realloc -brename:__real_realloc,realloc \\\n- -brename:mmap,__wrap_mmap -brename:__real_mmap,mmap \\\n- -brename:munmap,__wrap_munmap -brename:__real_munmap,munmap \\\n- -brename:alloca,__wrap_alloca -brename:__real_alloca,alloca \\\n-} %{fmudflapth: \\\n- -brename:pthread_create,__wrap_pthread_create \\\n- -brename:__real_pthread_create,pthread_create \\\n- -brename:pthread_join,__wrap_pthread_join \\\n- -brename:__real_pthread_join,pthread_join \\\n- -brename:pthread_exit,__wrap_pthread_exit \\\n- -brename:__real_pthread_exit,pthread_exit \\\n-}} %{fmudflap|fmudflapth: \\\n- -brename:main,__wrap_main -brename:__real_main,main \\\n-}\"\n-\n-#define MFLIB_SPEC \" %{fmudflap: -lmudflap \\\n- %{static:%(link_gcc_c_sequence) -lmudflap}} \\\n- %{fmudflapth: -lmudflapth -lpthread \\\n- %{static:%(link_gcc_c_sequence) -lmudflapth}} \"\n-\n /* Names to predefine in the preprocessor for this target machine.  */\n #define TARGET_OS_AIX_CPP_BUILTINS()\t\t\\\n   do\t\t\t\t\t\t\\"}, {"sha": "749e16830e3f85eb457af13cf26a8d9fba18d405", "filename": "gcc/config/sol2.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fconfig%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fconfig%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsol2.h?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -194,11 +194,6 @@ along with GCC; see the file COPYING3.  If not see\n #endif /* HAVE_LD_EH_FRAME && TARGET_DL_ITERATE_PHDR */\n #endif\n \n-#ifndef USE_GLD\n-/* The default MFLIB_SPEC is GNU ld specific.  */\n-#define MFLIB_SPEC \"\"\n-#endif\n-\n /* collect2.c can only parse GNU nm -n output.  Solaris nm needs -png to\n    produce the same format.  */\n #define NM_FLAGS \"-png\""}, {"sha": "308f3e8d3b1a2f40e2ab7de159806672ea8f88bb", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -1391,7 +1391,7 @@ addition, @samp{libstdc++}'s include files will be installed into\n @option{--with-gxx-include-dir=@var{dirname}}.  Using this option is\n particularly useful if you intend to use several versions of GCC in\n parallel.  This is currently supported by @samp{libgfortran},\n-@samp{libjava}, @samp{libmudflap}, @samp{libstdc++}, and @samp{libobjc}.\n+@samp{libjava}, @samp{libstdc++}, and @samp{libobjc}.\n \n @item --enable-languages=@var{lang1},@var{lang2},@dots{}\n Specify that only a particular subset of compilers and"}, {"sha": "ab259225574463692f2114462be99fab47b190b9", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 39, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -256,7 +256,6 @@ Objective-C and Objective-C++ Dialects}.\n -Wlogical-op -Wlong-long @gol\n -Wmain -Wmaybe-uninitialized -Wmissing-braces  -Wmissing-field-initializers @gol\n -Wmissing-include-dirs @gol\n--Wno-mudflap @gol\n -Wno-multichar  -Wnonnull  -Wno-overflow @gol\n -Woverlength-strings  -Wpacked  -Wpacked-bitfield-compat  -Wpadded @gol\n -Wparentheses  -Wpedantic-ms-format -Wno-pedantic-ms-format @gol\n@@ -308,7 +307,7 @@ Objective-C and Objective-C++ Dialects}.\n -fdump-tree-ch @gol\n -fdump-tree-ssa@r{[}-@var{n}@r{]} -fdump-tree-pre@r{[}-@var{n}@r{]} @gol\n -fdump-tree-ccp@r{[}-@var{n}@r{]} -fdump-tree-dce@r{[}-@var{n}@r{]} @gol\n--fdump-tree-gimple@r{[}-raw@r{]} -fdump-tree-mudflap@r{[}-@var{n}@r{]} @gol\n+-fdump-tree-gimple@r{[}-raw@r{]} @gol\n -fdump-tree-dom@r{[}-@var{n}@r{]} @gol\n -fdump-tree-dse@r{[}-@var{n}@r{]} @gol\n -fdump-tree-phiprop@r{[}-@var{n}@r{]} @gol\n@@ -384,7 +383,7 @@ Objective-C and Objective-C++ Dialects}.\n -floop-parallelize-all -flto -flto-compression-level @gol\n -flto-partition=@var{alg} -flto-report -flto-report-wpa -fmerge-all-constants @gol\n -fmerge-constants -fmodulo-sched -fmodulo-sched-allow-regmoves @gol\n--fmove-loop-invariants fmudflap -fmudflapir -fmudflapth -fno-branch-count-reg @gol\n+-fmove-loop-invariants -fno-branch-count-reg @gol\n -fno-defer-pop -fno-function-cse -fno-guess-branch-probability @gol\n -fno-inline -fno-math-errno -fno-peephole -fno-peephole2 @gol\n -fno-sched-interblock -fno-sched-spec -fno-signed-zeros @gol\n@@ -4991,11 +4990,6 @@ This option is only supported for C and Objective-C@.  It is implied by\n This option is only active when @option{-fstack-protector} is active.  It\n warns about functions that are not protected against stack smashing.\n \n-@item -Wno-mudflap\n-@opindex Wno-mudflap\n-Suppress warnings about constructs that cannot be instrumented by\n-@option{-fmudflap}.\n-\n @item -Woverlength-strings\n @opindex Woverlength-strings\n @opindex Wno-overlength-strings\n@@ -6200,11 +6194,6 @@ by appending @file{.store_copyprop} to the source file name.\n Dump each function after dead code elimination.  The file name is made by\n appending @file{.dce} to the source file name.\n \n-@item mudflap\n-@opindex fdump-tree-mudflap\n-Dump each function after adding mudflap instrumentation.  The file name is\n-made by appending @file{.mudflap} to the source file name.\n-\n @item sra\n @opindex fdump-tree-sra\n Dump each function after performing scalar replacement of aggregates.  The\n@@ -7071,32 +7060,6 @@ assumptions based on that.\n \n The default is @option{-fzero-initialized-in-bss}.\n \n-@item -fmudflap -fmudflapth -fmudflapir\n-@opindex fmudflap\n-@opindex fmudflapth\n-@opindex fmudflapir\n-@cindex bounds checking\n-@cindex mudflap\n-For front-ends that support it (C and C++), instrument all risky\n-pointer/array dereferencing operations, some standard library\n-string/heap functions, and some other associated constructs with\n-range/validity tests.  Modules so instrumented should be immune to\n-buffer overflows, invalid heap use, and some other classes of C/C++\n-programming errors.  The instrumentation relies on a separate runtime\n-library (@file{libmudflap}), which is linked into a program if\n-@option{-fmudflap} is given at link time.  Run-time behavior of the\n-instrumented program is controlled by the @env{MUDFLAP_OPTIONS}\n-environment variable.  See @code{env MUDFLAP_OPTIONS=-help a.out}\n-for its options.\n-\n-Use @option{-fmudflapth} instead of @option{-fmudflap} to compile and to\n-link if your program is multi-threaded.  Use @option{-fmudflapir}, in\n-addition to @option{-fmudflap} or @option{-fmudflapth}, if\n-instrumentation should ignore pointer reads.  This produces less\n-instrumentation (and therefore faster execution) and still provides\n-some protection against outright memory corrupting writes, but allows\n-erroneously read data to propagate within a program.\n-\n @item -fthread-jumps\n @opindex fthread-jumps\n Perform optimizations that check to see if a jump branches to a"}, {"sha": "d8e4315d74c8cf2e07332c5777b0bf3cb5c41e66", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -225,20 +225,6 @@ stuff quickly rather than wait until later when it's more work to get\n rid of it.  This pass is located in @file{tree-cfg.c} and described by\n @code{pass_remove_useless_stmts}.\n \n-@item Mudflap declaration registration\n-\n-If mudflap (@pxref{Optimize Options,,-fmudflap -fmudflapth\n--fmudflapir,gcc,Using the GNU Compiler Collection (GCC)}) is\n-enabled, we generate code to register some variable declarations with\n-the mudflap runtime.  Specifically, the runtime tracks the lifetimes of\n-those variable declarations that have their addresses taken, or whose\n-bounds are unknown at compile time (@code{extern}).  This pass generates\n-new exception handling constructs (@code{try}/@code{finally}), and so\n-must run before those are lowered.  In addition, the pass enqueues\n-declarations of static variables whose lifetimes extend to the entire\n-program.  The pass is located in @file{tree-mudflap.c} and is described\n-by @code{pass_mudflap_1}.\n-\n @item OpenMP lowering\n \n If OpenMP generation (@option{-fopenmp}) is enabled, this pass lowers\n@@ -576,18 +562,6 @@ run last so that we have as much time as possible to prove that the\n statement is not reachable.  It is located in @file{tree-cfg.c} and\n is described by @code{pass_warn_function_return}.\n \n-@item Mudflap statement annotation\n-\n-If mudflap is enabled, we rewrite some memory accesses with code to\n-validate that the memory access is correct.  In particular, expressions\n-involving pointer dereferences (@code{INDIRECT_REF}, @code{ARRAY_REF},\n-etc.) are replaced by code that checks the selected address range\n-against the mudflap runtime's database of valid regions.  This check\n-includes an inline lookup into a direct-mapped cache, based on\n-shift/mask operations of the pointer value, with a fallback function\n-call into the runtime.  The pass is located in @file{tree-mudflap.c} and\n-is described by @code{pass_mudflap_2}.\n-\n @item Leave static single assignment form\n \n This pass rewrites the function such that it is in normal form.  At\n@@ -968,10 +942,7 @@ This pass outputs the assembler code for the function.  The source files\n are @file{final.c} plus @file{insn-output.c}; the latter is generated\n automatically from the machine description by the tool @file{genoutput}.\n The header file @file{conditions.h} is used for communication between\n-these files.  If mudflap is enabled, the queue of deferred declarations\n-and any addressed constants (e.g., string literals) is processed by\n-@code{mudflap_finish_file} into a synthetic constructor function\n-containing calls into the mudflap runtime.\n+these files.\n \n @item Debugging information output\n "}, {"sha": "1a7091684585851a0fca4805f3da861fb5187bf5", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -103,10 +103,6 @@ The runtime support library for transactional memory.\n @item libjava\n The Java runtime library.\n \n-@item libmudflap\n-The @code{libmudflap} library, used for instrumenting pointer and array\n-dereferencing operations.\n-\n @item libobjc\n The Objective-C and Objective-C++ runtime library.\n "}, {"sha": "22982497a3b3bd6eeb00b3bdeb5c09756c537ea7", "filename": "gcc/gcc.c", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -523,28 +523,12 @@ proper position among the other output files.  */\n #define LIB_SPEC \"%{!shared:%{g*:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p}}\"\n #endif\n \n-/* mudflap specs */\n-#ifndef MFWRAP_SPEC\n-/* XXX: valid only for GNU ld */\n-/* XXX: should exactly match hooks provided by libmudflap.a */\n-#define MFWRAP_SPEC \" %{static: %{fmudflap|fmudflapth: \\\n- --wrap=malloc --wrap=free --wrap=calloc --wrap=realloc\\\n- --wrap=mmap --wrap=mmap64 --wrap=munmap --wrap=alloca\\\n-} %{fmudflapth: --wrap=pthread_create\\\n-}} %{fmudflap|fmudflapth: --wrap=main}\"\n-#endif\n-#ifndef MFLIB_SPEC\n-#define MFLIB_SPEC \"%{fmudflap|fmudflapth: -export-dynamic}\"\n-#endif\n-\n /* When using -fsplit-stack we need to wrap pthread_create, in order\n    to initialize the stack guard.  We always use wrapping, rather than\n    shared library ordering, and we keep the wrapper function in\n    libgcc.  This is not yet a real spec, though it could become one;\n    it is currently just stuffed into LINK_SPEC.  FIXME: This wrapping\n-   only works with GNU ld and gold.  FIXME: This is incompatible with\n-   -fmudflap when linking statically, which wants to do its own\n-   wrapping.  */\n+   only works with GNU ld and gold.  */\n #define STACK_SPLIT_SPEC \" %{fsplit-stack: --wrap=pthread_create}\"\n \n #ifndef LIBASAN_SPEC\n@@ -820,8 +804,6 @@ static const char *asm_spec = ASM_SPEC;\n static const char *asm_final_spec = ASM_FINAL_SPEC;\n static const char *link_spec = LINK_SPEC;\n static const char *lib_spec = LIB_SPEC;\n-static const char *mfwrap_spec = MFWRAP_SPEC;\n-static const char *mflib_spec = MFLIB_SPEC;\n static const char *link_gomp_spec = \"\";\n static const char *libgcc_spec = LIBGCC_SPEC;\n static const char *endfile_spec = ENDFILE_SPEC;\n@@ -862,8 +844,6 @@ static const char *cpp_unique_options =\n  %{remap} %{g3|ggdb3|gstabs3|gcoff3|gxcoff3|gvms3:-dD}\\\n  %{!iplugindir*:%{fplugin*:%:find-plugindir()}}\\\n  %{H} %C %{D*&U*&A*} %{i*} %Z %i\\\n- %{fmudflap:-D_MUDFLAP -include mf-runtime.h}\\\n- %{fmudflapth:-D_MUDFLAP -D_MUDFLAPTH -include mf-runtime.h}\\\n  %{E|M|MM:%W{o*}}\";\n \n /* This contains cpp options which are common with cc1_options and are passed\n@@ -895,7 +875,6 @@ static const char *cc1_options =\n  %{-help=*:--help=%*}\\\n  %{!fsyntax-only:%{S:%W{o*}%{!o*:-o %b.s}}}\\\n  %{fsyntax-only:-o %j} %{-param*}\\\n- %{fmudflap|fmudflapth:-fno-builtin -fno-merge-constants}\\\n  %{coverage:-fprofile-arcs -ftest-coverage}\";\n \n static const char *asm_options =\n@@ -1309,8 +1288,6 @@ static struct spec_list static_specs[] =\n   INIT_STATIC_SPEC (\"endfile\",\t\t\t&endfile_spec),\n   INIT_STATIC_SPEC (\"link\",\t\t\t&link_spec),\n   INIT_STATIC_SPEC (\"lib\",\t\t\t&lib_spec),\n-  INIT_STATIC_SPEC (\"mfwrap\",\t\t\t&mfwrap_spec),\n-  INIT_STATIC_SPEC (\"mflib\",\t\t\t&mflib_spec),\n   INIT_STATIC_SPEC (\"link_gomp\",\t\t&link_gomp_spec),\n   INIT_STATIC_SPEC (\"libgcc\",\t\t\t&libgcc_spec),\n   INIT_STATIC_SPEC (\"startfile\",\t\t&startfile_spec),"}, {"sha": "4b4eb4cafd7a142039b0783c5fbbead113255bf6", "filename": "gcc/gimplify.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -51,7 +51,6 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"langhooks-def.h\"\t/* FIXME: for lhd_set_decl_assembler_name */\n #include \"tree-pass.h\"\t\t/* FIXME: only for PROP_gimple_any */\n-#include \"tree-mudflap.h\"\n #include \"expr.h\"\n #include \"tm_p.h\"\n \n@@ -1236,8 +1235,7 @@ gimplify_bind_expr (tree *expr_p, gimple_seq *pre_p)\n       gimple stack_restore;\n \n       /* Save stack on entry and restore it on exit.  Add a try_finally\n-\t block to achieve this.  Note that mudflap depends on the\n-\t format of the emitted code: see mx_register_decls().  */\n+\t block to achieve this.  */\n       build_stack_save_restore (&stack_save, &stack_restore);\n \n       gimplify_seq_add_stmt (&cleanup, stack_restore);\n@@ -1395,8 +1393,7 @@ static void\n gimplify_vla_decl (tree decl, gimple_seq *seq_p)\n {\n   /* This is a variable-sized decl.  Simplify its size and mark it\n-     for deferred expansion.  Note that mudflap depends on the format\n-     of the emitted code: see mx_register_decls().  */\n+     for deferred expansion.  */\n   tree t, addr, ptr_type;\n \n   gimplify_one_sizepos (&DECL_SIZE (decl), seq_p);"}, {"sha": "404b7901cfa78874117441cd4f22c7d03922dfe0", "filename": "gcc/passes.def", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -34,7 +34,6 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_warn_unused_result);\n   NEXT_PASS (pass_diagnose_omp_blocks);\n   NEXT_PASS (pass_diagnose_tm_blocks);\n-  NEXT_PASS (pass_mudflap_1);\n   NEXT_PASS (pass_lower_omp);\n   NEXT_PASS (pass_lower_cf);\n   NEXT_PASS (pass_lower_tm);\n@@ -305,7 +304,6 @@ along with GCC; see the file COPYING3.  If not see\n   NEXT_PASS (pass_cleanup_eh);\n   NEXT_PASS (pass_lower_resx);\n   NEXT_PASS (pass_nrv);\n-  NEXT_PASS (pass_mudflap_2);\n   NEXT_PASS (pass_cleanup_cfg_post_optimizing);\n   NEXT_PASS (pass_warn_function_noreturn);\n "}, {"sha": "9a979e266c92d1cbad04a3eca6897600e664b091", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -1,3 +1,8 @@\n+2013-10-26  Jeff Law  <law@redhat.com>\n+\n+\t* g++.dg/torture/pr49309.C: Removed.\n+\t* gcc.dg/dfp/pr35739.c: Removed.\n+\n 2013-10-25  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR rtl-optimization/58759"}, {"sha": "f96967ddd34504b0e8a9d88483eaa6f14a7e5d18", "filename": "gcc/testsuite/g++.dg/torture/pr49309.C", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr49309.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr49309.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr49309.C?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,16 +0,0 @@\n-// PR tree-optimization/49309\n-// { dg-do compile }\n-// { dg-skip-if \"\" { *-*-* } { \"-flto\" } { \"\" } }\n-// { dg-options \"-fpreprocessed -fmudflap\" }\n-\n-struct A\n-{\n-  int i;\n-\n-  A();\n-  A(const A&);\n-};\n-\n-inline void foo(A a) { a = A(); }\n-\n-void bar() { foo(A()); }"}, {"sha": "0fc9d478f5f2f0de642f7d66d4c60ea6dc2ef769", "filename": "gcc/testsuite/gcc.dg/dfp/pr35739.c", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fpr35739.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fpr35739.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdfp%2Fpr35739.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,16 +0,0 @@\n-/* PR c/35739 */\n-/* { dg-do compile { target *-*-linux* *-*-gnu* } } */\n-/* { dg-options \"-O -fpreprocessed -fmudflap\" } */\n-\n-_Decimal128\n-foo (int n, ...)\n-{\n-  int i;\n-  _Decimal128 j = 0;\n-  __builtin_va_list ap;\n-  __builtin_va_start (ap, n);\n-  for (i = 0; i < n; i++)\n-    j += __builtin_va_arg (ap, _Decimal128);\n-  __builtin_va_end (ap);\n-  return j;\n-}"}, {"sha": "db269b79e67a6a03b7b5e815d388cb8fedd5d148", "filename": "gcc/toplev.c", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -68,7 +68,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coverage.h\"\n #include \"value-prof.h\"\n #include \"alloc-pool.h\"\n-#include \"tree-mudflap.h\"\n #include \"asan.h\"\n #include \"tsan.h\"\n #include \"gimple.h\"\n@@ -568,10 +567,6 @@ compile_file (void)\n      basically finished.  */\n   if (in_lto_p || !flag_lto || flag_fat_lto_objects)\n     {\n-      /* Likewise for mudflap static object registrations.  */\n-      if (flag_mudflap)\n-\tmudflap_finish_file ();\n-\n       /* File-scope initialization for AddressSanitizer.  */\n       if (flag_sanitize & SANITIZE_ADDRESS)\n         asan_finish_file ();\n@@ -1287,9 +1282,6 @@ process_options (void)\n \t   \"and -ftree-loop-linear)\");\n #endif\n \n-  if (flag_mudflap && flag_lto)\n-    sorry (\"mudflap cannot be used together with link-time optimization\");\n-\n   /* One region RA really helps to decrease the code size.  */\n   if (flag_ira_region == IRA_REGION_AUTODETECT)\n     flag_ira_region"}, {"sha": "a20e73b6d30fe73add30e2485fa45395f65a5016", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -34,7 +34,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"basic-block.h\"\n #include \"tree-iterator.h\"\n #include \"intl.h\"\n-#include \"tree-mudflap.h\"\n #include \"gimple.h\"\n #include \"gimple-ssa.h\"\n #include \"tree-cfg.h\"\n@@ -4592,10 +4591,6 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n       /* Copy the node.  */\n       new_tree = copy_node (*tp);\n \n-      /* Propagate mudflap marked-ness.  */\n-      if (flag_mudflap && mf_marked_p (*tp))\n-        mf_mark (new_tree);\n-\n       *tp = new_tree;\n \n       /* Now, restore the chain, if appropriate.  That will cause\n@@ -4617,11 +4612,6 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n       tree new_tree;\n \n       new_tree = copy_node (*tp);\n-\n-      /* Propagate mudflap marked-ness.  */\n-      if (flag_mudflap && mf_marked_p (*tp))\n-        mf_mark (new_tree);\n-\n       CONSTRUCTOR_ELTS (new_tree) = vec_safe_copy (CONSTRUCTOR_ELTS (*tp));\n       *tp = new_tree;\n     }"}, {"sha": "a1503118af8408a0cb941bed174d18105ab30e94", "filename": "gcc/tree-mudflap.c", "status": "removed", "additions": 0, "deletions": 1450, "changes": 1450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,1450 +0,0 @@\n-/* Mudflap: narrow-pointer bounds-checking by tree rewriting.\n-   Copyright (C) 2002-2013 Free Software Foundation, Inc.\n-   Contributed by Frank Ch. Eigler <fche@redhat.com>\n-   and Graydon Hoare <graydon@redhat.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"tm_p.h\"\n-#include \"basic-block.h\"\n-#include \"flags.h\"\n-#include \"function.h\"\n-#include \"tree-inline.h\"\n-#include \"gimple.h\"\n-#include \"tree-iterator.h\"\n-#include \"cgraph.h\"\n-#include \"tree-cfg.h\"\n-#include \"tree-mudflap.h\"\n-#include \"tree-pass.h\"\n-#include \"hashtab.h\"\n-#include \"diagnostic.h\"\n-#include \"demangle.h\"\n-#include \"langhooks.h\"\n-#include \"ggc.h\"\n-#include \"tree-ssa-address.h\"\n-\n-extern void add_bb_to_loop (basic_block, struct loop *);\n-\n-/* Internal function decls */\n-\n-\n-/* Options.  */\n-#define flag_mudflap_threads (flag_mudflap == 2)\n-\n-/* Helpers.  */\n-static tree mf_build_string (const char *string);\n-static tree mf_varname_tree (tree);\n-static tree mf_file_function_line_tree (location_t);\n-\n-/* Indirection-related instrumentation.  */\n-static void mf_decl_cache_locals (void);\n-static void mf_decl_clear_locals (void);\n-static void mf_xform_statements (void);\n-static unsigned int execute_mudflap_function_ops (void);\n-\n-/* Addressable variables instrumentation.  */\n-static void mf_xform_decls (gimple_seq, tree);\n-static tree mx_xfn_xform_decls (gimple_stmt_iterator *, bool *,\n-\t\t\t\tstruct walk_stmt_info *);\n-static gimple_seq mx_register_decls (tree, gimple_seq, location_t);\n-static unsigned int execute_mudflap_function_decls (void);\n-\n-/* Return true if DECL is artificial stub that shouldn't be instrumented by\n-   mf.  We should instrument clones of non-artificial functions.  */\n-static inline bool\n-mf_artificial (const_tree decl)\n-{\n-  return DECL_ARTIFICIAL (DECL_ORIGIN (decl));\n-}\n-\n-/* ------------------------------------------------------------------------ */\n-/* Some generally helpful functions for mudflap instrumentation.  */\n-\n-/* Build a reference to a literal string.  */\n-static tree\n-mf_build_string (const char *string)\n-{\n-  size_t len = strlen (string);\n-  tree result = mf_mark (build_string (len + 1, string));\n-\n-  TREE_TYPE (result) = build_array_type\n-    (char_type_node, build_index_type (size_int (len)));\n-  TREE_CONSTANT (result) = 1;\n-  TREE_READONLY (result) = 1;\n-  TREE_STATIC (result) = 1;\n-\n-  result = build1 (ADDR_EXPR, build_pointer_type (char_type_node), result);\n-\n-  return mf_mark (result);\n-}\n-\n-/* Create a properly typed STRING_CST node that describes the given\n-   declaration.  It will be used as an argument for __mf_register().\n-   Try to construct a helpful string, including file/function/variable\n-   name.  */\n-\n-static tree\n-mf_varname_tree (tree decl)\n-{\n-  const char *buf_contents;\n-  tree result;\n-\n-  gcc_assert (decl);\n-\n-  pretty_printer buf;\n-\n-  /* Add FILENAME[:LINENUMBER[:COLUMNNUMBER]].  */\n-  {\n-    expanded_location xloc = expand_location (DECL_SOURCE_LOCATION (decl));\n-    const char *sourcefile;\n-    unsigned sourceline = xloc.line;\n-    unsigned sourcecolumn = 0;\n-    sourcecolumn = xloc.column;\n-    sourcefile = xloc.file;\n-    if (sourcefile == NULL && current_function_decl != NULL_TREE)\n-      sourcefile = DECL_SOURCE_FILE (current_function_decl);\n-    if (sourcefile == NULL)\n-      sourcefile = \"<unknown file>\";\n-\n-    pp_string (&buf, sourcefile);\n-\n-    if (sourceline != 0)\n-      {\n-        pp_colon (&buf);\n-        pp_decimal_int (&buf, sourceline);\n-\n-        if (sourcecolumn != 0)\n-          {\n-            pp_colon (&buf);\n-            pp_decimal_int (&buf, sourcecolumn);\n-          }\n-      }\n-  }\n-\n-  if (current_function_decl != NULL_TREE)\n-    {\n-      /* Add (FUNCTION) */\n-      pp_string (&buf, \" (\");\n-      {\n-        const char *funcname = NULL;\n-        if (DECL_NAME (current_function_decl))\n-          funcname = lang_hooks.decl_printable_name (current_function_decl, 1);\n-        if (funcname == NULL)\n-          funcname = \"anonymous fn\";\n-\n-        pp_string (&buf, funcname);\n-      }\n-      pp_string (&buf, \") \");\n-    }\n-  else\n-    pp_space (&buf);\n-\n-  /* Add <variable-declaration>, possibly demangled.  */\n-  {\n-    const char *declname = NULL;\n-\n-    if (DECL_NAME (decl) != NULL)\n-      {\n-\tif (strcmp (\"GNU C++\", lang_hooks.name) == 0)\n-\t  {\n-\t    /* The gcc/cp decl_printable_name hook doesn't do as good a job as\n-\t       the libiberty demangler.  */\n-\t    declname = cplus_demangle (IDENTIFIER_POINTER (DECL_NAME (decl)),\n-\t\t\t\t       DMGL_AUTO | DMGL_VERBOSE);\n-\t  }\n-\tif (declname == NULL)\n-\t  declname = lang_hooks.decl_printable_name (decl, 3);\n-      }\n-    if (declname == NULL)\n-      declname = \"<unnamed variable>\";\n-\n-    pp_string (&buf, declname);\n-  }\n-\n-  /* Return the lot as a new STRING_CST.  */\n-  buf_contents = ggc_strdup (pp_formatted_text (&buf));\n-  result = mf_build_string (buf_contents);\n-  pp_clear_output_area (&buf);\n-\n-  return result;\n-}\n-\n-\n-/* And another friend, for producing a simpler message.  */\n-\n-static tree\n-mf_file_function_line_tree (location_t location)\n-{\n-  expanded_location xloc = expand_location (location);\n-  const char *file = NULL, *colon, *line, *op, *name, *cp;\n-  char linecolbuf[30]; /* Enough for two decimal numbers plus a colon.  */\n-  char *string;\n-  tree result;\n-\n-  /* Add FILENAME[:LINENUMBER[:COLUMNNUMBER]].  */\n-  file = xloc.file;\n-  if (file == NULL && current_function_decl != NULL_TREE)\n-    file = DECL_SOURCE_FILE (current_function_decl);\n-  if (file == NULL)\n-    file = \"<unknown file>\";\n-\n-  if (xloc.line > 0)\n-    {\n-      if (xloc.column > 0)\n-        sprintf (linecolbuf, \"%d:%d\", xloc.line, xloc.column);\n-      else\n-        sprintf (linecolbuf, \"%d\", xloc.line);\n-      colon = \":\";\n-      line = linecolbuf;\n-    }\n-  else\n-    colon = line = \"\";\n-\n-  /* Add (FUNCTION).  */\n-  name = lang_hooks.decl_printable_name (current_function_decl, 1);\n-  if (name)\n-    {\n-      op = \" (\";\n-      cp = \")\";\n-    }\n-  else\n-    op = name = cp = \"\";\n-\n-  string = concat (file, colon, line, op, name, cp, NULL);\n-  result = mf_build_string (string);\n-  free (string);\n-\n-  return result;\n-}\n-\n-\n-/* global tree nodes */\n-\n-/* Global tree objects for global variables and functions exported by\n-   mudflap runtime library.  mf_init_extern_trees must be called\n-   before using these.  */\n-\n-/* uintptr_t (usually \"unsigned long\") */\n-static GTY (()) tree mf_uintptr_type;\n-\n-/* struct __mf_cache { uintptr_t low; uintptr_t high; }; */\n-static GTY (()) tree mf_cache_struct_type;\n-\n-/* struct __mf_cache * const */\n-static GTY (()) tree mf_cache_structptr_type;\n-\n-/* extern struct __mf_cache __mf_lookup_cache []; */\n-static GTY (()) tree mf_cache_array_decl;\n-\n-/* extern unsigned char __mf_lc_shift; */\n-static GTY (()) tree mf_cache_shift_decl;\n-\n-/* extern uintptr_t __mf_lc_mask; */\n-static GTY (()) tree mf_cache_mask_decl;\n-\n-/* Their function-scope local shadows, used in single-threaded mode only.  */\n-\n-/* auto const unsigned char __mf_lc_shift_l; */\n-static GTY (()) tree mf_cache_shift_decl_l;\n-\n-/* auto const uintptr_t __mf_lc_mask_l; */\n-static GTY (()) tree mf_cache_mask_decl_l;\n-\n-/* extern void __mf_check (void *ptr, size_t sz, int type, const char *); */\n-static GTY (()) tree mf_check_fndecl;\n-\n-/* extern void __mf_register (void *ptr, size_t sz, int type, const char *); */\n-static GTY (()) tree mf_register_fndecl;\n-\n-/* extern void __mf_unregister (void *ptr, size_t sz, int type); */\n-static GTY (()) tree mf_unregister_fndecl;\n-\n-/* extern void __mf_init (); */\n-static GTY (()) tree mf_init_fndecl;\n-\n-/* extern int __mf_set_options (const char*); */\n-static GTY (()) tree mf_set_options_fndecl;\n-\n-\n-/* Helper for mudflap_init: construct a decl with the given category,\n-   name, and type, mark it an external reference, and pushdecl it.  */\n-static inline tree\n-mf_make_builtin (enum tree_code category, const char *name, tree type)\n-{\n-  tree decl = mf_mark (build_decl (UNKNOWN_LOCATION,\n-\t\t\t\t   category, get_identifier (name), type));\n-  TREE_PUBLIC (decl) = 1;\n-  DECL_EXTERNAL (decl) = 1;\n-  lang_hooks.decls.pushdecl (decl);\n-  /* The decl was declared by the compiler.  */\n-  DECL_ARTIFICIAL (decl) = 1;\n-  /* And we don't want debug info for it.  */\n-  DECL_IGNORED_P (decl) = 1;\n-  return decl;\n-}\n-\n-/* Helper for mudflap_init: construct a tree corresponding to the type\n-     struct __mf_cache { uintptr_t low; uintptr_t high; };\n-     where uintptr_t is the FIELD_TYPE argument.  */\n-static inline tree\n-mf_make_mf_cache_struct_type (tree field_type)\n-{\n-  /* There is, abominably, no language-independent way to construct a\n-     RECORD_TYPE.  So we have to call the basic type construction\n-     primitives by hand.  */\n-  tree fieldlo = build_decl (UNKNOWN_LOCATION,\n-\t\t\t     FIELD_DECL, get_identifier (\"low\"), field_type);\n-  tree fieldhi = build_decl (UNKNOWN_LOCATION,\n-\t\t\t     FIELD_DECL, get_identifier (\"high\"), field_type);\n-\n-  tree struct_type = make_node (RECORD_TYPE);\n-  DECL_CONTEXT (fieldlo) = struct_type;\n-  DECL_CONTEXT (fieldhi) = struct_type;\n-  DECL_CHAIN (fieldlo) = fieldhi;\n-  TYPE_FIELDS (struct_type) = fieldlo;\n-  TYPE_NAME (struct_type) = get_identifier (\"__mf_cache\");\n-  layout_type (struct_type);\n-\n-  return struct_type;\n-}\n-\n-/* Initialize the global tree nodes that correspond to mf-runtime.h\n-   declarations.  */\n-void\n-mudflap_init (void)\n-{\n-  static bool done = false;\n-  tree mf_const_string_type;\n-  tree mf_cache_array_type;\n-  tree mf_check_register_fntype;\n-  tree mf_unregister_fntype;\n-  tree mf_init_fntype;\n-  tree mf_set_options_fntype;\n-\n-  if (done)\n-    return;\n-  done = true;\n-\n-  mf_uintptr_type = lang_hooks.types.type_for_mode (ptr_mode,\n-                                                    /*unsignedp=*/true);\n-  mf_const_string_type\n-    = build_pointer_type (build_qualified_type\n-                          (char_type_node, TYPE_QUAL_CONST));\n-\n-  mf_cache_struct_type = mf_make_mf_cache_struct_type (mf_uintptr_type);\n-  mf_cache_structptr_type = build_pointer_type (mf_cache_struct_type);\n-  mf_cache_array_type = build_array_type (mf_cache_struct_type, 0);\n-  mf_check_register_fntype =\n-    build_function_type_list (void_type_node, ptr_type_node, size_type_node,\n-\t\t\t      integer_type_node, mf_const_string_type, NULL_TREE);\n-  mf_unregister_fntype =\n-    build_function_type_list (void_type_node, ptr_type_node, size_type_node,\n-\t\t\t      integer_type_node, NULL_TREE);\n-  mf_init_fntype =\n-    build_function_type_list (void_type_node, NULL_TREE);\n-  mf_set_options_fntype =\n-    build_function_type_list (integer_type_node, mf_const_string_type, NULL_TREE);\n-\n-  mf_cache_array_decl = mf_make_builtin (VAR_DECL, \"__mf_lookup_cache\",\n-                                         mf_cache_array_type);\n-  mf_cache_shift_decl = mf_make_builtin (VAR_DECL, \"__mf_lc_shift\",\n-                                         unsigned_char_type_node);\n-  mf_cache_mask_decl = mf_make_builtin (VAR_DECL, \"__mf_lc_mask\",\n-                                        mf_uintptr_type);\n-  /* Don't process these in mudflap_enqueue_decl, should they come by\n-     there for some reason.  */\n-  mf_mark (mf_cache_array_decl);\n-  mf_mark (mf_cache_shift_decl);\n-  mf_mark (mf_cache_mask_decl);\n-  mf_check_fndecl = mf_make_builtin (FUNCTION_DECL, \"__mf_check\",\n-                                     mf_check_register_fntype);\n-  mf_register_fndecl = mf_make_builtin (FUNCTION_DECL, \"__mf_register\",\n-                                        mf_check_register_fntype);\n-  mf_unregister_fndecl = mf_make_builtin (FUNCTION_DECL, \"__mf_unregister\",\n-                                          mf_unregister_fntype);\n-  mf_init_fndecl = mf_make_builtin (FUNCTION_DECL, \"__mf_init\",\n-                                    mf_init_fntype);\n-  mf_set_options_fndecl = mf_make_builtin (FUNCTION_DECL, \"__mf_set_options\",\n-                                           mf_set_options_fntype);\n-}\n-\n-\n-/* ------------------------------------------------------------------------ */\n-/* This is the second part of the mudflap instrumentation.  It works on\n-   low-level GIMPLE using the CFG, because we want to run this pass after\n-   tree optimizations have been performed, but we have to preserve the CFG\n-   for expansion from trees to RTL.\n-   Below is the list of transformations performed on statements in the\n-   current function.\n-\n- 1)  Memory reference transforms: Perform the mudflap indirection-related\n-    tree transforms on memory references.\n-\n- 2) Mark BUILTIN_ALLOCA calls not inlineable.\n-\n- */\n-\n-static unsigned int\n-execute_mudflap_function_ops (void)\n-{\n-  struct gimplify_ctx gctx;\n-\n-  /* Don't instrument functions such as the synthetic constructor\n-     built during mudflap_finish_file.  */\n-  if (mf_marked_p (current_function_decl)\n-      || mf_artificial (current_function_decl))\n-    return 0;\n-\n-  push_gimplify_context (&gctx);\n-\n-  /* In multithreaded mode, don't cache the lookup cache parameters.  */\n-  if (! flag_mudflap_threads)\n-    mf_decl_cache_locals ();\n-\n-  mf_xform_statements ();\n-\n-  if (! flag_mudflap_threads)\n-    mf_decl_clear_locals ();\n-\n-  pop_gimplify_context (NULL);\n-  return 0;\n-}\n-\n-/* Insert a gimple_seq SEQ on all the outgoing edges out of BB.  Note that\n-   if BB has more than one edge, STMT will be replicated for each edge.\n-   Also, abnormal edges will be ignored.  */\n-\n-static void\n-insert_edge_copies_seq (gimple_seq seq, basic_block bb)\n-{\n-  edge e;\n-  edge_iterator ei;\n-  unsigned n_copies = -1;\n-\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (!(e->flags & EDGE_ABNORMAL))\n-      n_copies++;\n-\n-  FOR_EACH_EDGE (e, ei, bb->succs)\n-    if (!(e->flags & EDGE_ABNORMAL))\n-      gsi_insert_seq_on_edge (e, n_copies-- > 0 ? gimple_seq_copy (seq) : seq);\n-}\n-\n-/* Create and initialize local shadow variables for the lookup cache\n-   globals.  Put their decls in the *_l globals for use by\n-   mf_build_check_statement_for.  */\n-\n-static void\n-mf_decl_cache_locals (void)\n-{\n-  gimple g;\n-  gimple_seq seq = NULL;\n-\n-  /* Build the cache vars.  */\n-  mf_cache_shift_decl_l\n-    = mf_mark (create_tmp_reg (TREE_TYPE (mf_cache_shift_decl),\n-                               \"__mf_lookup_shift_l\"));\n-\n-  mf_cache_mask_decl_l\n-    = mf_mark (create_tmp_reg (TREE_TYPE (mf_cache_mask_decl),\n-                               \"__mf_lookup_mask_l\"));\n-\n-  /* Build initialization nodes for the cache vars.  We just load the\n-     globals into the cache variables.  */\n-  g = gimple_build_assign (mf_cache_shift_decl_l, mf_cache_shift_decl);\n-  gimple_set_location (g, DECL_SOURCE_LOCATION (current_function_decl));\n-  gimple_seq_add_stmt (&seq, g);\n-\n-  g = gimple_build_assign (mf_cache_mask_decl_l, mf_cache_mask_decl);\n-  gimple_set_location (g, DECL_SOURCE_LOCATION (current_function_decl));\n-  gimple_seq_add_stmt (&seq, g);\n-\n-  insert_edge_copies_seq (seq, ENTRY_BLOCK_PTR);\n-\n-  gsi_commit_edge_inserts ();\n-}\n-\n-\n-static void\n-mf_decl_clear_locals (void)\n-{\n-  /* Unset local shadows.  */\n-  mf_cache_shift_decl_l = NULL_TREE;\n-  mf_cache_mask_decl_l = NULL_TREE;\n-}\n-\n-static void\n-mf_build_check_statement_for (tree base, tree limit,\n-                              gimple_stmt_iterator *instr_gsi,\n-                              location_t location, tree dirflag)\n-{\n-  gimple_stmt_iterator gsi;\n-  basic_block cond_bb, then_bb, join_bb;\n-  edge e;\n-  tree cond, t, u, v;\n-  tree mf_base;\n-  tree mf_elem;\n-  tree mf_limit;\n-  gimple g;\n-  gimple_seq seq, stmts;\n-\n-  /* We first need to split the current basic block, and start altering\n-     the CFG.  This allows us to insert the statements we're about to\n-     construct into the right basic blocks.  */\n-\n-  cond_bb = gimple_bb (gsi_stmt (*instr_gsi));\n-  gsi = *instr_gsi;\n-  gsi_prev (&gsi);\n-  if (! gsi_end_p (gsi))\n-    e = split_block (cond_bb, gsi_stmt (gsi));\n-  else\n-    e = split_block_after_labels (cond_bb);\n-  cond_bb = e->src;\n-  join_bb = e->dest;\n-\n-  /* A recap at this point: join_bb is the basic block at whose head\n-     is the gimple statement for which this check expression is being\n-     built.  cond_bb is the (possibly new, synthetic) basic block the\n-     end of which will contain the cache-lookup code, and a\n-     conditional that jumps to the cache-miss code or, much more\n-     likely, over to join_bb.  */\n-\n-  /* Create the bb that contains the cache-miss fallback block (mf_check).  */\n-  then_bb = create_empty_bb (cond_bb);\n-  make_edge (cond_bb, then_bb, EDGE_TRUE_VALUE);\n-  make_single_succ_edge (then_bb, join_bb, EDGE_FALLTHRU);\n-\n-  /* Mark the pseudo-fallthrough edge from cond_bb to join_bb.  */\n-  e = find_edge (cond_bb, join_bb);\n-  e->flags = EDGE_FALSE_VALUE;\n-  e->count = cond_bb->count;\n-  e->probability = REG_BR_PROB_BASE;\n-\n-  /* Update dominance info.  Note that bb_join's data was\n-     updated by split_block.  */\n-  if (dom_info_available_p (CDI_DOMINATORS))\n-    {\n-      set_immediate_dominator (CDI_DOMINATORS, then_bb, cond_bb);\n-      set_immediate_dominator (CDI_DOMINATORS, join_bb, cond_bb);\n-    }\n-\n-  /* Update loop info.  */\n-  if (current_loops)\n-    add_bb_to_loop (then_bb, cond_bb->loop_father);\n-\n-  /* Build our local variables.  */\n-  mf_elem = create_tmp_reg (mf_cache_structptr_type, \"__mf_elem\");\n-  mf_base = create_tmp_reg (mf_uintptr_type, \"__mf_base\");\n-  mf_limit = create_tmp_reg (mf_uintptr_type, \"__mf_limit\");\n-\n-  /* Build: __mf_base = (uintptr_t) <base address expression>.  */\n-  seq = NULL;\n-  t = fold_convert_loc (location, mf_uintptr_type,\n-\t\t\tunshare_expr (base));\n-  t = force_gimple_operand (t, &stmts, false, NULL_TREE);\n-  gimple_seq_add_seq (&seq, stmts);\n-  g = gimple_build_assign (mf_base, t);\n-  gimple_set_location (g, location);\n-  gimple_seq_add_stmt (&seq, g);\n-\n-  /* Build: __mf_limit = (uintptr_t) <limit address expression>.  */\n-  t = fold_convert_loc (location, mf_uintptr_type,\n-\t\t\tunshare_expr (limit));\n-  t = force_gimple_operand (t, &stmts, false, NULL_TREE);\n-  gimple_seq_add_seq (&seq, stmts);\n-  g = gimple_build_assign (mf_limit, t);\n-  gimple_set_location (g, location);\n-  gimple_seq_add_stmt (&seq, g);\n-\n-  /* Build: __mf_elem = &__mf_lookup_cache [(__mf_base >> __mf_shift)\n-                                            & __mf_mask].  */\n-  t = build2 (RSHIFT_EXPR, mf_uintptr_type, mf_base,\n-              flag_mudflap_threads ? mf_cache_shift_decl\n-\t       : mf_cache_shift_decl_l);\n-  t = build2 (BIT_AND_EXPR, mf_uintptr_type, t,\n-              flag_mudflap_threads ? mf_cache_mask_decl\n-\t       : mf_cache_mask_decl_l);\n-  t = build4 (ARRAY_REF,\n-              TREE_TYPE (TREE_TYPE (mf_cache_array_decl)),\n-              mf_cache_array_decl, t, NULL_TREE, NULL_TREE);\n-  t = build1 (ADDR_EXPR, mf_cache_structptr_type, t);\n-  t = force_gimple_operand (t, &stmts, false, NULL_TREE);\n-  gimple_seq_add_seq (&seq, stmts);\n-  g = gimple_build_assign (mf_elem, t);\n-  gimple_set_location (g, location);\n-  gimple_seq_add_stmt (&seq, g);\n-\n-  /* Quick validity check.\n-\n-     if (__mf_elem->low > __mf_base\n-         || (__mf_elem_high < __mf_limit))\n-        {\n-          __mf_check ();\n-          ... and only if single-threaded:\n-          __mf_lookup_shift_1 = f...;\n-          __mf_lookup_mask_l = ...;\n-        }\n-\n-     It is expected that this body of code is rarely executed so we mark\n-     the edge to the THEN clause of the conditional jump as unlikely.  */\n-\n-  /* Construct t <-- '__mf_elem->low  > __mf_base'.  */\n-  t = build3 (COMPONENT_REF, mf_uintptr_type,\n-              build1 (INDIRECT_REF, mf_cache_struct_type, mf_elem),\n-              TYPE_FIELDS (mf_cache_struct_type), NULL_TREE);\n-  t = build2 (GT_EXPR, boolean_type_node, t, mf_base);\n-\n-  /* Construct '__mf_elem->high < __mf_limit'.\n-\n-     First build:\n-        1) u <--  '__mf_elem->high'\n-        2) v <--  '__mf_limit'.\n-\n-     Then build 'u <-- (u < v).  */\n-\n-  u = build3 (COMPONENT_REF, mf_uintptr_type,\n-              build1 (INDIRECT_REF, mf_cache_struct_type, mf_elem),\n-              DECL_CHAIN (TYPE_FIELDS (mf_cache_struct_type)), NULL_TREE);\n-\n-  v = mf_limit;\n-\n-  u = build2 (LT_EXPR, boolean_type_node, u, v);\n-\n-  /* Build the composed conditional: t <-- 't || u'.  Then store the\n-     result of the evaluation of 't' in a temporary variable which we\n-     can use as the condition for the conditional jump.  */\n-  t = build2 (TRUTH_OR_EXPR, boolean_type_node, t, u);\n-  t = force_gimple_operand (t, &stmts, false, NULL_TREE);\n-  gimple_seq_add_seq (&seq, stmts);\n-  cond = create_tmp_reg (boolean_type_node, \"__mf_unlikely_cond\");\n-  g = gimple_build_assign  (cond, t);\n-  gimple_set_location (g, location);\n-  gimple_seq_add_stmt (&seq, g);\n-\n-  /* Build the conditional jump.  'cond' is just a temporary so we can\n-     simply build a void COND_EXPR.  We do need labels in both arms though.  */\n-  g = gimple_build_cond (NE_EXPR, cond, boolean_false_node, NULL_TREE,\n-\t\t\t NULL_TREE);\n-  gimple_set_location (g, location);\n-  gimple_seq_add_stmt (&seq, g);\n-\n-  /* At this point, after so much hard work, we have only constructed\n-     the conditional jump,\n-\n-     if (__mf_elem->low > __mf_base\n-         || (__mf_elem_high < __mf_limit))\n-\n-     The lowered GIMPLE tree representing this code is in the statement\n-     list starting at 'head'.\n-\n-     We can insert this now in the current basic block, i.e. the one that\n-     the statement we're instrumenting was originally in.  */\n-  gsi = gsi_last_bb (cond_bb);\n-  gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n-\n-  /*  Now build up the body of the cache-miss handling:\n-\n-     __mf_check();\n-     refresh *_l vars.\n-\n-     This is the body of the conditional.  */\n-\n-  seq = NULL;\n-  /* u is a string, so it is already a gimple value.  */\n-  u = mf_file_function_line_tree (location);\n-  /* NB: we pass the overall [base..limit] range to mf_check.  */\n-  v = fold_build2_loc (location, PLUS_EXPR, mf_uintptr_type,\n-\t\t   fold_build2_loc (location,\n-\t\t\t\tMINUS_EXPR, mf_uintptr_type, mf_limit, mf_base),\n-\t\t   build_int_cst (mf_uintptr_type, 1));\n-  v = force_gimple_operand (v, &stmts, true, NULL_TREE);\n-  gimple_seq_add_seq (&seq, stmts);\n-  g = gimple_build_call (mf_check_fndecl, 4, mf_base, v, dirflag, u);\n-  gimple_seq_add_stmt (&seq, g);\n-\n-  if (! flag_mudflap_threads)\n-    {\n-      if (stmt_ends_bb_p (g))\n-\t{\n-\t  gsi = gsi_start_bb (then_bb);\n-\t  gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n-\t  e = split_block (then_bb, g);\n-\t  then_bb = e->dest;\n-\t  seq = NULL;\n-\t}\n-\n-      g = gimple_build_assign (mf_cache_shift_decl_l, mf_cache_shift_decl);\n-      gimple_seq_add_stmt (&seq, g);\n-\n-      g = gimple_build_assign (mf_cache_mask_decl_l, mf_cache_mask_decl);\n-      gimple_seq_add_stmt (&seq, g);\n-    }\n-\n-  /* Insert the check code in the THEN block.  */\n-  gsi = gsi_start_bb (then_bb);\n-  gsi_insert_seq_after (&gsi, seq, GSI_CONTINUE_LINKING);\n-\n-  *instr_gsi = gsi_start_bb (join_bb);\n-}\n-\n-\n-/* Check whether the given decl, generally a VAR_DECL or PARM_DECL, is\n-   eligible for instrumentation.  For the mudflap1 pass, this implies\n-   that it should be registered with the libmudflap runtime.  For the\n-   mudflap2 pass this means instrumenting an indirection operation with\n-   respect to the object.\n-*/\n-static int\n-mf_decl_eligible_p (tree decl)\n-{\n-  return ((TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL)\n-          /* The decl must have its address taken.  In the case of\n-             arrays, this flag is also set if the indexes are not\n-             compile-time known valid constants.  */\n-\t  /* XXX: not sufficient: return-by-value structs! */\n-          && TREE_ADDRESSABLE (decl)\n-          /* The type of the variable must be complete.  */\n-          && COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (decl))\n-\t  /* The decl hasn't been decomposed somehow.  */\n-\t  && !DECL_HAS_VALUE_EXPR_P (decl));\n-}\n-\n-\n-static void\n-mf_xform_derefs_1 (gimple_stmt_iterator *iter, tree *tp,\n-                   location_t location, tree dirflag)\n-{\n-  tree type, base, limit, addr, size, t;\n-\n-  /* Don't instrument read operations.  */\n-  if (dirflag == integer_zero_node && flag_mudflap_ignore_reads)\n-    return;\n-\n-  /* Don't instrument marked nodes.  */\n-  if (mf_marked_p (*tp))\n-    return;\n-\n-  t = *tp;\n-  type = TREE_TYPE (t);\n-\n-  if (type == error_mark_node)\n-    return;\n-\n-  size = TYPE_SIZE_UNIT (type);\n-\n-  switch (TREE_CODE (t))\n-    {\n-    case ARRAY_REF:\n-    case COMPONENT_REF:\n-      {\n-        /* This is trickier than it may first appear.  The reason is\n-           that we are looking at expressions from the \"inside out\" at\n-           this point.  We may have a complex nested aggregate/array\n-           expression (e.g. \"a.b[i].c\"), maybe with an indirection as\n-           the leftmost operator (\"p->a.b.d\"), where instrumentation\n-           is necessary.  Or we may have an innocent \"a.b.c\"\n-           expression that must not be instrumented.  We need to\n-           recurse all the way down the nesting structure to figure it\n-           out: looking just at the outer node is not enough.  */\n-        tree var;\n-        int component_ref_only = (TREE_CODE (t) == COMPONENT_REF);\n-\t/* If we have a bitfield component reference, we must note the\n-\t   innermost addressable object in ELT, from which we will\n-\t   construct the byte-addressable bounds of the bitfield.  */\n-\ttree elt = NULL_TREE;\n-\tint bitfield_ref_p = (TREE_CODE (t) == COMPONENT_REF\n-\t\t\t      && DECL_BIT_FIELD_TYPE (TREE_OPERAND (t, 1)));\n-\n-        /* Iterate to the top of the ARRAY_REF/COMPONENT_REF\n-           containment hierarchy to find the outermost VAR_DECL.  */\n-        var = TREE_OPERAND (t, 0);\n-        while (1)\n-          {\n-\t    if (bitfield_ref_p && elt == NULL_TREE\n-\t\t&& (TREE_CODE (var) == ARRAY_REF\n-\t\t    || TREE_CODE (var) == COMPONENT_REF))\n-\t      elt = var;\n-\n-            if (TREE_CODE (var) == ARRAY_REF)\n-              {\n-                component_ref_only = 0;\n-                var = TREE_OPERAND (var, 0);\n-              }\n-            else if (TREE_CODE (var) == COMPONENT_REF)\n-              var = TREE_OPERAND (var, 0);\n-            else if (INDIRECT_REF_P (var)\n-\t\t     || TREE_CODE (var) == MEM_REF)\n-              {\n-\t\tbase = TREE_OPERAND (var, 0);\n-                break;\n-              }\n-            else if (TREE_CODE (var) == VIEW_CONVERT_EXPR)\n-\t      {\n-\t\tvar = TREE_OPERAND (var, 0);\n-\t\tif (CONSTANT_CLASS_P (var)\n-\t\t    && TREE_CODE (var) != STRING_CST)\n-\t\t  return;\n-\t      }\n-            else\n-              {\n-                gcc_assert (TREE_CODE (var) == VAR_DECL\n-                            || TREE_CODE (var) == PARM_DECL\n-                            || TREE_CODE (var) == RESULT_DECL\n-                            || TREE_CODE (var) == STRING_CST);\n-                /* Don't instrument this access if the underlying\n-                   variable is not \"eligible\".  This test matches\n-                   those arrays that have only known-valid indexes,\n-                   and thus are not labeled TREE_ADDRESSABLE.  */\n-                if (! mf_decl_eligible_p (var) || component_ref_only)\n-                  return;\n-                else\n-\t\t  {\n-\t\t    base = build1 (ADDR_EXPR,\n-\t\t\t\t   build_pointer_type (TREE_TYPE (var)), var);\n-\t\t    break;\n-\t\t  }\n-              }\n-          }\n-\n-        /* Handle the case of ordinary non-indirection structure\n-           accesses.  These have only nested COMPONENT_REF nodes (no\n-           INDIRECT_REF), but pass through the above filter loop.\n-           Note that it's possible for such a struct variable to match\n-           the eligible_p test because someone else might take its\n-           address sometime.  */\n-\n-        /* We need special processing for bitfield components, because\n-           their addresses cannot be taken.  */\n-        if (bitfield_ref_p)\n-          {\n-            tree field = TREE_OPERAND (t, 1);\n-\n-            if (TREE_CODE (DECL_SIZE_UNIT (field)) == INTEGER_CST)\n-              size = DECL_SIZE_UNIT (field);\n-\n-\t    if (elt)\n-\t      elt = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (elt)),\n-\t\t\t    elt);\n-            addr = fold_convert_loc (location, ptr_type_node, elt ? elt : base);\n-            addr = fold_build_pointer_plus_loc (location,\n-\t\t\t\t\t\taddr, byte_position (field));\n-          }\n-        else\n-          addr = build1 (ADDR_EXPR, build_pointer_type (type), t);\n-\n-        limit = fold_build2_loc (location, MINUS_EXPR, mf_uintptr_type,\n-                             fold_build2_loc (location, PLUS_EXPR, mf_uintptr_type,\n-\t\t\t\t\t  fold_convert (mf_uintptr_type, addr),\n-\t\t\t\t\t  size),\n-                             integer_one_node);\n-      }\n-      break;\n-\n-    case INDIRECT_REF:\n-      addr = TREE_OPERAND (t, 0);\n-      base = addr;\n-      limit = fold_build_pointer_plus_hwi_loc\n-\t(location, fold_build_pointer_plus_loc (location, base, size), -1);\n-      break;\n-\n-    case MEM_REF:\n-      if (addr_expr_of_non_mem_decl_p (TREE_OPERAND (t, 0)))\n-\treturn;\n-\n-      addr = fold_build_pointer_plus_loc (location, TREE_OPERAND (t, 0),\n-\t\t\t\t\t  TREE_OPERAND (t, 1));\n-      base = addr;\n-      limit = fold_build_pointer_plus_hwi_loc (location,\n-\t\t\t   fold_build_pointer_plus_loc (location,\n-\t\t\t\t\t\t\tbase, size), -1);\n-      break;\n-\n-    case TARGET_MEM_REF:\n-      if (addr_expr_of_non_mem_decl_p (TMR_BASE (t)))\n-\treturn;\n-\n-      addr = tree_mem_ref_addr (ptr_type_node, t);\n-      base = addr;\n-      limit = fold_build_pointer_plus_hwi_loc (location,\n-\t\t\t   fold_build_pointer_plus_loc (location,\n-\t\t\t\t\t\t\tbase, size), -1);\n-      break;\n-\n-    case ARRAY_RANGE_REF:\n-      warning (OPT_Wmudflap,\n-\t       \"mudflap checking not yet implemented for ARRAY_RANGE_REF\");\n-      return;\n-\n-    case BIT_FIELD_REF:\n-      /* ??? merge with COMPONENT_REF code above? */\n-      {\n-        tree ofs, rem, bpu;\n-\n-        /* If we're not dereferencing something, then the access\n-           must be ok.  */\n-        if (TREE_CODE (TREE_OPERAND (t, 0)) != INDIRECT_REF)\n-          return;\n-\n-        bpu = bitsize_int (BITS_PER_UNIT);\n-        ofs = fold_convert (bitsizetype, TREE_OPERAND (t, 2));\n-        rem = size_binop_loc (location, TRUNC_MOD_EXPR, ofs, bpu);\n-        ofs = size_binop_loc (location, TRUNC_DIV_EXPR, ofs, bpu);\n-\n-        size = fold_convert (bitsizetype, TREE_OPERAND (t, 1));\n-        size = size_binop_loc (location, PLUS_EXPR, size, rem);\n-        size = size_binop_loc (location, CEIL_DIV_EXPR, size, bpu);\n-        size = fold_convert (sizetype, size);\n-\n-        addr = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n-        addr = fold_convert (ptr_type_node, addr);\n-        addr = fold_build_pointer_plus_loc (location, addr, ofs);\n-\n-        base = addr;\n-        limit = fold_build_pointer_plus_hwi_loc (location,\n-                             fold_build_pointer_plus_loc (location,\n-\t\t\t\t\t\t\t  base, size), -1);\n-      }\n-      break;\n-\n-    default:\n-      return;\n-    }\n-\n-  mf_build_check_statement_for (base, limit, iter, location, dirflag);\n-}\n-/* Transform\n-   1) Memory references.\n-*/\n-static void\n-mf_xform_statements (void)\n-{\n-  basic_block bb, next;\n-  gimple_stmt_iterator i;\n-  int saved_last_basic_block = last_basic_block;\n-  enum gimple_rhs_class grhs_class;\n-\n-  bb = ENTRY_BLOCK_PTR ->next_bb;\n-  do\n-    {\n-      next = bb->next_bb;\n-      for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n-        {\n-          gimple s = gsi_stmt (i);\n-\n-          /* Only a few GIMPLE statements can reference memory.  */\n-          switch (gimple_code (s))\n-            {\n-            case GIMPLE_ASSIGN:\n-\t      mf_xform_derefs_1 (&i, gimple_assign_lhs_ptr (s),\n-\t\t  \t\t gimple_location (s), integer_one_node);\n-\t      mf_xform_derefs_1 (&i, gimple_assign_rhs1_ptr (s),\n-\t\t  \t\t gimple_location (s), integer_zero_node);\n-\t      grhs_class = get_gimple_rhs_class (gimple_assign_rhs_code (s));\n-\t      if (grhs_class == GIMPLE_BINARY_RHS)\n-\t\tmf_xform_derefs_1 (&i, gimple_assign_rhs2_ptr (s),\n-\t\t\t\t   gimple_location (s), integer_zero_node);\n-              break;\n-\n-            case GIMPLE_RETURN:\n-              if (gimple_return_retval (s) != NULL_TREE)\n-                {\n-                  mf_xform_derefs_1 (&i, gimple_return_retval_ptr (s),\n-\t\t\t\t     gimple_location (s),\n-\t\t\t\t     integer_zero_node);\n-                }\n-              break;\n-\n-            default:\n-              ;\n-            }\n-        }\n-      bb = next;\n-    }\n-  while (bb && bb->index <= saved_last_basic_block);\n-}\n-\n-/* ------------------------------------------------------------------------ */\n-/* ADDR_EXPR transforms.  Perform the declaration-related mudflap tree\n-   transforms on the current function.\n-\n-   This is the first part of the mudflap instrumentation.  It works on\n-   high-level GIMPLE because after lowering, all variables are moved out\n-   of their BIND_EXPR binding context, and we lose liveness information\n-   for the declarations we wish to instrument.  */\n-\n-static unsigned int\n-execute_mudflap_function_decls (void)\n-{\n-  struct gimplify_ctx gctx;\n-\n-  /* Don't instrument functions such as the synthetic constructor\n-     built during mudflap_finish_file.  */\n-  if (mf_marked_p (current_function_decl)\n-      || mf_artificial (current_function_decl))\n-    return 0;\n-\n-  push_gimplify_context (&gctx);\n-\n-  mf_xform_decls (gimple_body (current_function_decl),\n-                  DECL_ARGUMENTS (current_function_decl));\n-\n-  pop_gimplify_context (NULL);\n-  return 0;\n-}\n-\n-/* This struct is passed between mf_xform_decls to store state needed\n-   during the traversal searching for objects that have their\n-   addresses taken.  */\n-struct mf_xform_decls_data\n-{\n-  tree param_decls;\n-};\n-\n-\n-/* Synthesize a CALL_EXPR and a TRY_FINALLY_EXPR, for this chain of\n-   _DECLs if appropriate.  Arrange to call the __mf_register function\n-   now, and the __mf_unregister function later for each.  Return the\n-   gimple sequence after synthesis.  */\n-gimple_seq\n-mx_register_decls (tree decl, gimple_seq seq, location_t location)\n-{\n-  gimple_seq finally_stmts = NULL;\n-  gimple_stmt_iterator initially_stmts = gsi_start (seq);\n-\n-  while (decl != NULL_TREE)\n-    {\n-      if (mf_decl_eligible_p (decl)\n-          /* Not already processed.  */\n-          && ! mf_marked_p (decl)\n-          /* Automatic variable.  */\n-          && ! DECL_EXTERNAL (decl)\n-          && ! TREE_STATIC (decl))\n-        {\n-          tree size = NULL_TREE, variable_name;\n-          gimple unregister_fncall, register_fncall;\n-\t  tree unregister_fncall_param, register_fncall_param;\n-\n-\t  /* Variable-sized objects should have sizes already been\n-\t     gimplified when we got here. */\n-\t  size = fold_convert (size_type_node,\n-\t\t\t       TYPE_SIZE_UNIT (TREE_TYPE (decl)));\n-\t  gcc_assert (is_gimple_val (size));\n-\n-\n-          unregister_fncall_param =\n-\t    mf_mark (build1 (ADDR_EXPR,\n-\t\t\t     build_pointer_type (TREE_TYPE (decl)),\n-\t\t\t     decl));\n-          /* __mf_unregister (&VARIABLE, sizeof (VARIABLE), __MF_TYPE_STACK) */\n-          unregister_fncall = gimple_build_call (mf_unregister_fndecl, 3,\n-\t\t\t\t\t\t unregister_fncall_param,\n-\t\t\t\t\t\t size,\n-\t\t\t\t\t\t integer_three_node);\n-\n-\n-          variable_name = mf_varname_tree (decl);\n-          register_fncall_param =\n-\t    mf_mark (build1 (ADDR_EXPR,\n-\t\t\t     build_pointer_type (TREE_TYPE (decl)),\n-\t\t\t     decl));\n-          /* __mf_register (&VARIABLE, sizeof (VARIABLE), __MF_TYPE_STACK,\n-\t                    \"name\") */\n-\t  register_fncall = gimple_build_call (mf_register_fndecl, 4,\n-\t\t\t\t\t       register_fncall_param,\n-\t\t\t\t\t       size,\n-\t\t\t\t\t       integer_three_node,\n-\t\t\t\t\t       variable_name);\n-\n-\n-          /* Accumulate the two calls.  */\n-\t  gimple_set_location (register_fncall, location);\n-\t  gimple_set_location (unregister_fncall, location);\n-\n-          /* Add the __mf_register call at the current appending point.  */\n-          if (gsi_end_p (initially_stmts))\n-\t    {\n-\t      if (!mf_artificial (decl))\n-\t\twarning (OPT_Wmudflap,\n-\t\t\t \"mudflap cannot track %qE in stub function\",\n-\t\t\t DECL_NAME (decl));\n-\t    }\n-\t  else\n-\t    {\n-\t      gsi_insert_before (&initially_stmts, register_fncall,\n-\t\t\t\t GSI_SAME_STMT);\n-\n-\t      /* Accumulate the FINALLY piece.  */\n-\t      gimple_seq_add_stmt (&finally_stmts, unregister_fncall);\n-\t    }\n-          mf_mark (decl);\n-        }\n-\n-      decl = DECL_CHAIN (decl);\n-    }\n-\n-  /* Actually, (initially_stmts!=NULL) <=> (finally_stmts!=NULL) */\n-  if (finally_stmts != NULL)\n-    {\n-      gimple stmt = gimple_build_try (seq, finally_stmts, GIMPLE_TRY_FINALLY);\n-      gimple_seq new_seq = NULL;\n-\n-      gimple_seq_add_stmt (&new_seq, stmt);\n-      return new_seq;\n-    }\n-   else\n-    return seq;\n-}\n-\n-\n-/* Process every variable mentioned in BIND_EXPRs.  */\n-static tree\n-mx_xfn_xform_decls (gimple_stmt_iterator *gsi,\n-\t\t    bool *handled_operands_p ATTRIBUTE_UNUSED,\n-\t\t    struct walk_stmt_info *wi)\n-{\n-  struct mf_xform_decls_data *d = (struct mf_xform_decls_data *) wi->info;\n-  gimple stmt = gsi_stmt (*gsi);\n-\n-  switch (gimple_code (stmt))\n-    {\n-    case GIMPLE_BIND:\n-      {\n-        /* Process function parameters now (but only once).  */\n-\tif (d->param_decls)\n-\t  {\n-\t    gimple_bind_set_body (stmt,\n-\t\t\t\t  mx_register_decls (d->param_decls,\n-\t\t\t\t\t\t     gimple_bind_body (stmt),\n-\t\t\t\t\t\t     gimple_location (stmt)));\n-\t    d->param_decls = NULL_TREE;\n-\t  }\n-\n-\tgimple_bind_set_body (stmt,\n-\t\t\t      mx_register_decls (gimple_bind_vars (stmt),\n-\t\t\t\t\t\t gimple_bind_body (stmt),\n-\t\t\t\t\t\t gimple_location (stmt)));\n-      }\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* Perform the object lifetime tracking mudflap transform on the given function\n-   tree.  The tree is mutated in place, with possibly copied subtree nodes.\n-\n-   For every auto variable declared, if its address is ever taken\n-   within the function, then supply its lifetime to the mudflap\n-   runtime with the __mf_register and __mf_unregister calls.\n-*/\n-\n-static void\n-mf_xform_decls (gimple_seq fnbody, tree fnparams)\n-{\n-  struct mf_xform_decls_data d;\n-  struct walk_stmt_info wi;\n-  struct pointer_set_t *pset = pointer_set_create ();\n-\n-  d.param_decls = fnparams;\n-  memset (&wi, 0, sizeof (wi));\n-  wi.info = (void*) &d;\n-  wi.pset = pset;\n-  walk_gimple_seq (fnbody, mx_xfn_xform_decls, NULL, &wi);\n-  pointer_set_destroy (pset);\n-}\n-\n-\n-/* ------------------------------------------------------------------------ */\n-/* Externally visible mudflap functions.  */\n-\n-\n-/* Mark and return the given tree node to prevent further mudflap\n-   transforms.  */\n-static GTY ((param_is (union tree_node))) htab_t marked_trees = NULL;\n-\n-tree\n-mf_mark (tree t)\n-{\n-  void **slot;\n-\n-  if (marked_trees == NULL)\n-    marked_trees = htab_create_ggc (31, htab_hash_pointer, htab_eq_pointer,\n-\t\t\t\t    NULL);\n-\n-  slot = htab_find_slot (marked_trees, t, INSERT);\n-  *slot = t;\n-  return t;\n-}\n-\n-int\n-mf_marked_p (tree t)\n-{\n-  void *entry;\n-\n-  if (marked_trees == NULL)\n-    return 0;\n-\n-  entry = htab_find (marked_trees, t);\n-  return (entry != NULL);\n-}\n-\n-/* Remember given node as a static of some kind: global data,\n-   function-scope static, or an anonymous constant.  Its assembler\n-   label is given.  */\n-\n-/* A list of globals whose incomplete declarations we encountered.\n-   Instead of emitting the __mf_register call for them here, it's\n-   delayed until program finish time.  If they're still incomplete by\n-   then, warnings are emitted.  */\n-\n-static GTY (()) vec<tree, va_gc> *deferred_static_decls;\n-\n-/* A list of statements for calling __mf_register() at startup time.  */\n-static GTY (()) tree enqueued_call_stmt_chain;\n-\n-static void\n-mudflap_register_call (tree obj, tree object_size, tree varname)\n-{\n-  tree arg, call_stmt;\n-\n-  arg = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (obj)), obj);\n-  arg = fold_convert (ptr_type_node, arg);\n-\n-  call_stmt = build_call_expr (mf_register_fndecl, 4,\n-\t\t\t       arg,\n-\t\t\t       fold_convert (size_type_node, object_size),\n-\t\t\t       /* __MF_TYPE_STATIC */\n-\t\t\t       build_int_cst (integer_type_node, 4),\n-\t\t\t       varname);\n-\n-  append_to_statement_list (call_stmt, &enqueued_call_stmt_chain);\n-}\n-\n-void\n-mudflap_enqueue_decl (tree obj)\n-{\n-  if (mf_marked_p (obj))\n-    return;\n-\n-  /* We don't need to process variable decls that are internally\n-     generated extern.  If we did, we'd end up with warnings for them\n-     during mudflap_finish_file ().  That would confuse the user,\n-     since the text would refer to variables that don't show up in the\n-     user's source code.  */\n-  if (DECL_P (obj) && DECL_EXTERNAL (obj) && mf_artificial (obj))\n-    return;\n-\n-  vec_safe_push (deferred_static_decls, obj);\n-}\n-\n-\n-void\n-mudflap_enqueue_constant (tree obj)\n-{\n-  tree object_size, varname;\n-\n-  if (mf_marked_p (obj))\n-    return;\n-\n-  if (TREE_CODE (obj) == STRING_CST)\n-    object_size = size_int (TREE_STRING_LENGTH (obj));\n-  else\n-    object_size = size_in_bytes (TREE_TYPE (obj));\n-\n-  if (TREE_CODE (obj) == STRING_CST)\n-    varname = mf_build_string (\"string literal\");\n-  else\n-    varname = mf_build_string (\"constant\");\n-\n-  mudflap_register_call (obj, object_size, varname);\n-}\n-\n-\n-/* Emit any file-wide instrumentation.  */\n-void\n-mudflap_finish_file (void)\n-{\n-  tree ctor_statements = NULL_TREE;\n-\n-  /* No need to continue when there were errors.  */\n-  if (seen_error ())\n-    return;\n-\n-  /* Insert a call to __mf_init.  */\n-  {\n-    tree call2_stmt = build_call_expr (mf_init_fndecl, 0);\n-    append_to_statement_list (call2_stmt, &ctor_statements);\n-  }\n-\n-  /* If appropriate, call __mf_set_options to pass along read-ignore mode.  */\n-  if (flag_mudflap_ignore_reads)\n-    {\n-      tree arg = mf_build_string (\"-ignore-reads\");\n-      tree call_stmt = build_call_expr (mf_set_options_fndecl, 1, arg);\n-      append_to_statement_list (call_stmt, &ctor_statements);\n-    }\n-\n-  /* Process all enqueued object decls.  */\n-  if (deferred_static_decls)\n-    {\n-      size_t i;\n-      tree obj;\n-      FOR_EACH_VEC_ELT (*deferred_static_decls, i, obj)\n-        {\n-          gcc_assert (DECL_P (obj));\n-\n-          if (mf_marked_p (obj))\n-            continue;\n-\n-          /* Omit registration for static unaddressed objects.  NB:\n-             Perform registration for non-static objects regardless of\n-             TREE_USED or TREE_ADDRESSABLE, because they may be used\n-             from other compilation units.  */\n-          if (! TREE_PUBLIC (obj) && ! TREE_ADDRESSABLE (obj))\n-            continue;\n-\n-\t  /* If we're neither emitting nor referencing the symbol,\n-\t     don't register it.  We have to register external symbols\n-\t     if they happen to be in other files not compiled with\n-\t     mudflap (say system libraries), and we must not register\n-\t     internal symbols that we don't emit or they'll become\n-\t     dangling references or force symbols to be emitted that\n-\t     didn't have to.  */\n-\t  if (!symtab_get_node (obj))\n-\t    continue;\n-\n-          if (! COMPLETE_TYPE_P (TREE_TYPE (obj)))\n-            {\n-              warning (OPT_Wmudflap,\n-\t\t       \"mudflap cannot track unknown size extern %qE\",\n-                       DECL_NAME (obj));\n-              continue;\n-            }\n-\n-          mudflap_register_call (obj,\n-                                 size_in_bytes (TREE_TYPE (obj)),\n-                                 mf_varname_tree (obj));\n-        }\n-\n-      deferred_static_decls->truncate (0);\n-    }\n-\n-  /* Append all the enqueued registration calls.  */\n-  if (enqueued_call_stmt_chain)\n-    {\n-      append_to_statement_list (enqueued_call_stmt_chain, &ctor_statements);\n-      enqueued_call_stmt_chain = NULL_TREE;\n-    }\n-\n-  cgraph_build_static_cdtor ('I', ctor_statements,\n-                             MAX_RESERVED_INIT_PRIORITY-1);\n-}\n-\n-\n-static bool\n-gate_mudflap (void)\n-{\n-  return flag_mudflap != 0;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_mudflap_1 =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"mudflap1\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_gate */\n-  true, /* has_execute */\n-  TV_NONE, /* tv_id */\n-  PROP_gimple_any, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_mudflap_1 : public gimple_opt_pass\n-{\n-public:\n-  pass_mudflap_1 (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_mudflap_1, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  bool gate () { return gate_mudflap (); }\n-  unsigned int execute () { return execute_mudflap_function_decls (); }\n-\n-}; // class pass_mudflap_1\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_mudflap_1 (gcc::context *ctxt)\n-{\n-  return new pass_mudflap_1 (ctxt);\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_mudflap_2 =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"mudflap2\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_gate */\n-  true, /* has_execute */\n-  TV_NONE, /* tv_id */\n-  ( PROP_ssa | PROP_cfg | PROP_gimple_leh ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_verify_flow | TODO_verify_stmts\n-    | TODO_update_ssa ), /* todo_flags_finish */\n-};\n-\n-class pass_mudflap_2 : public gimple_opt_pass\n-{\n-public:\n-  pass_mudflap_2 (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_mudflap_2, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  bool gate () { return gate_mudflap (); }\n-  unsigned int execute () { return execute_mudflap_function_ops (); }\n-\n-}; // class pass_mudflap_2\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_mudflap_2 (gcc::context *ctxt)\n-{\n-  return new pass_mudflap_2 (ctxt);\n-}\n-\n-#include \"gt-tree-mudflap.h\""}, {"sha": "96f38c40c16152f5cb72839f53b5dccd0a2e8911", "filename": "gcc/tree-mudflap.h", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/gcc%2Ftree-mudflap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/gcc%2Ftree-mudflap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.h?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,34 +0,0 @@\n-/* Mudflap: narrow-pointer bounds-checking by tree rewriting.\n-   Copyright (C) 2001-2013 Free Software Foundation, Inc.\n-   Contributed by Frank Ch. Eigler <fche@redhat.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef TREE_MUDFLAP_H\n-#define TREE_MUDFLAP_H\n-\n-/* Instrumentation.  */\n-extern void mudflap_init (void);\n-extern void mudflap_enqueue_decl (tree);\n-extern void mudflap_enqueue_constant (tree);\n-extern void mudflap_finish_file (void);\n-\n-/* Tree node marking.  */\n-extern int mf_marked_p (tree);\n-extern tree mf_mark (tree);\n-\n-#endif /* TREE_MUDFLAP_H */"}, {"sha": "fe9ea6058bd1bb16767c56b13b91de523492cd4a", "filename": "gcc/tree-nomudflap.c", "status": "removed", "additions": 0, "deletions": 169, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/gcc%2Ftree-nomudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/gcc%2Ftree-nomudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nomudflap.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,169 +0,0 @@\n-/* Mudflap: narrow-pointer bounds-checking by tree rewriting.\n-   Copyright (C) 2001-2013 Free Software Foundation, Inc.\n-   Contributed by Frank Ch. Eigler <fche@redhat.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"tree-inline.h\"\n-#include \"gimple.h\"\n-#include \"hashtab.h\"\n-#include \"langhooks.h\"\n-#include \"tree-mudflap.h\"\n-#include \"tree-pass.h\"\n-#include \"ggc.h\"\n-#include \"diagnostic-core.h\"\n-\n-\n-\n-/* This file contains placeholder functions, to be used only for\n-   language processors that cannot handle tree-mudflap.c directly.\n-   (e.g. Fortran).  */\n-\n-static void\n-nogo (void)\n-{\n-  sorry (\"mudflap: this language is not supported\");\n-}\n-\n-void\n-mudflap_enqueue_decl (tree obj ATTRIBUTE_UNUSED)\n-{\n-  nogo ();\n-}\n-\n-void\n-mudflap_enqueue_constant (tree obj ATTRIBUTE_UNUSED)\n-{\n-  nogo ();\n-}\n-\n-void\n-mudflap_finish_file (void)\n-{\n-  nogo ();\n-}\n-\n-int\n-mf_marked_p (tree t ATTRIBUTE_UNUSED)\n-{\n-  nogo ();\n-  return 0;\n-}\n-\n-tree\n-mf_mark (tree t ATTRIBUTE_UNUSED)\n-{\n-  nogo ();\n-  return NULL;\n-}\n-\n-/* The pass structures must exist, but need not do anything.  */\n-\n-static bool\n-gate_mudflap (void)\n-{\n-  return flag_mudflap != 0;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_mudflap_1 =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"mudflap1\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_gate */\n-  false, /* has_execute */\n-  TV_NONE, /* tv_id */\n-  0, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_mudflap_1 : public gimple_opt_pass\n-{\n-public:\n-  pass_mudflap_1 (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_mudflap_1, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  bool gate () { return gate_mudflap (); }\n-\n-}; // class pass_mudflap_1\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_mudflap_1 (gcc::context *ctxt)\n-{\n-  return new pass_mudflap_1 (ctxt);\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_mudflap_2 =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"mudflap2\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  true, /* has_gate */\n-  false, /* has_execute */\n-  TV_NONE, /* tv_id */\n-  0, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_mudflap_2 : public gimple_opt_pass\n-{\n-public:\n-  pass_mudflap_2 (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_mudflap_2, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  bool gate () { return gate_mudflap (); }\n-\n-}; // class pass_mudflap_2\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_mudflap_2 (gcc::context *ctxt)\n-{\n-  return new pass_mudflap_2 (ctxt);\n-}\n-\n-/* Instead of:\n-#include \"gt-tree-mudflap.h\"\n-We prepare a little dummy struct here.\n-*/\n-\n-EXPORTED_CONST struct ggc_root_tab gt_ggc_r_gt_tree_mudflap_h[] = {\n-  LAST_GGC_ROOT_TAB\n-};"}, {"sha": "523743803a7aa85fbb0013fec0c08aa45075bed3", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -338,8 +338,6 @@ extern void register_pass (register_pass_info *);\n extern void register_pass (opt_pass* pass, pass_positioning_ops pos,\n \t\t\t   const char* ref_pass_name, int ref_pass_inst_number);\n \n-extern gimple_opt_pass *make_pass_mudflap_1 (gcc::context *ctxt);\n-extern gimple_opt_pass *make_pass_mudflap_2 (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_asan (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_asan_O0 (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_tsan (gcc::context *ctxt);"}, {"sha": "e56ca1bbbd5d0d4240e043822acf0d58cf93e0db", "filename": "gcc/varasm.c", "status": "modified", "additions": 5, "deletions": 26, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98906124e3aa4cb17695d900fe19498e5bde63e4/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=98906124e3aa4cb17695d900fe19498e5bde63e4", "patch": "@@ -46,7 +46,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"common/common-target.h\"\n #include \"targhooks.h\"\n-#include \"tree-mudflap.h\"\n #include \"cgraph.h\"\n #include \"pointer-set.h\"\n #include \"asan.h\"\n@@ -1247,10 +1246,6 @@ make_decl_rtl (tree decl)\n \t  && SYMBOL_REF_HAS_BLOCK_INFO_P (XEXP (x, 0)))\n \tchange_symbol_block (XEXP (x, 0), get_block_for_decl (decl));\n \n-      /* Make this function static known to the mudflap runtime.  */\n-      if (flag_mudflap && TREE_CODE (decl) == VAR_DECL)\n-\tmudflap_enqueue_decl (decl);\n-\n       return;\n     }\n \n@@ -1387,10 +1382,6 @@ make_decl_rtl (tree decl)\n      If the name is changed, the macro ASM_OUTPUT_LABELREF\n      will have to know how to strip this information.  */\n   targetm.encode_section_info (decl, DECL_RTL (decl), true);\n-\n-  /* Make this function static known to the mudflap runtime.  */\n-  if (flag_mudflap && TREE_CODE (decl) == VAR_DECL)\n-    mudflap_enqueue_decl (decl);\n }\n \n /* Like make_decl_rtl, but inhibit creation of new alias sets when\n@@ -1400,7 +1391,7 @@ make_decl_rtl (tree decl)\n rtx\n make_decl_rtl_for_debug (tree decl)\n {\n-  unsigned int save_aliasing_flag, save_mudflap_flag;\n+  unsigned int save_aliasing_flag;\n   rtx rtl;\n \n   if (DECL_RTL_SET_P (decl))\n@@ -1411,21 +1402,16 @@ make_decl_rtl_for_debug (tree decl)\n      we do not want to create alias sets that will throw the alias\n      numbers off in the comparison dumps.  So... clearing\n      flag_strict_aliasing will keep new_alias_set() from creating a\n-     new set.  It is undesirable to register decl with mudflap\n-     in this case as well.  */\n+     new set.  */\n   save_aliasing_flag = flag_strict_aliasing;\n   flag_strict_aliasing = 0;\n-  save_mudflap_flag = flag_mudflap;\n-  flag_mudflap = 0;\n \n   rtl = DECL_RTL (decl);\n   /* Reset DECL_RTL back, as various parts of the compiler expects\n      DECL_RTL set meaning it is actually going to be output.  */\n   SET_DECL_RTL (decl, NULL);\n \n   flag_strict_aliasing = save_aliasing_flag;\n-  flag_mudflap = save_mudflap_flag;\n-\n   return rtl;\n }\n \f\n@@ -3206,10 +3192,6 @@ build_constant_desc (tree exp)\n   desc = ggc_alloc_constant_descriptor_tree ();\n   desc->value = copy_constant (exp);\n \n-  /* Propagate marked-ness to copied constant.  */\n-  if (flag_mudflap && mf_marked_p (exp))\n-    mf_mark (desc->value);\n-\n   /* Create a string containing the label name, in LABEL.  */\n   labelno = const_labelno++;\n   ASM_GENERATE_INTERNAL_LABEL (label, \"LC\", labelno);\n@@ -3405,8 +3387,6 @@ output_constant_def_contents (rtx symbol)\n \t  assemble_zeros (asan_red_zone_size (size));\n \t}\n     }\n-  if (flag_mudflap)\n-    mudflap_enqueue_constant (exp);\n }\n \n /* Look up EXP in the table of constant descriptors.  Return the rtl\n@@ -6294,9 +6274,8 @@ categorize_decl_for_section (const_tree decl, int reloc)\n     return SECCAT_TEXT;\n   else if (TREE_CODE (decl) == STRING_CST)\n     {\n-      if (flag_mudflap\n-\t  || ((flag_sanitize & SANITIZE_ADDRESS)\n-\t      && asan_protect_global (CONST_CAST_TREE (decl))))\n+      if ((flag_sanitize & SANITIZE_ADDRESS)\n+\t  && asan_protect_global (CONST_CAST_TREE (decl)))\n       /* or !flag_merge_constants */\n         return SECCAT_RODATA;\n       else\n@@ -6321,7 +6300,7 @@ categorize_decl_for_section (const_tree decl, int reloc)\n \t}\n       else if (reloc & targetm.asm_out.reloc_rw_mask ())\n \tret = reloc == 1 ? SECCAT_DATA_REL_RO_LOCAL : SECCAT_DATA_REL_RO;\n-      else if (reloc || flag_merge_constants < 2 || flag_mudflap\n+      else if (reloc || flag_merge_constants < 2\n \t       || ((flag_sanitize & SANITIZE_ADDRESS)\n \t\t   && asan_protect_global (CONST_CAST_TREE (decl))))\n \t/* C and C++ don't allow different variables to share the same"}, {"sha": "17ce18de21d7c7dcf691fac9328a71a3b05102ce", "filename": "libmudflap/ChangeLog", "status": "removed", "additions": 0, "deletions": 2069, "changes": 2069, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2FChangeLog?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,2069 +0,0 @@\n-2013-10-17  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n-\n-\tPR libmudflap/58230\n-\t* testsuite/lib/mfdg.exp: Use C locale.\n-\n-2013-09-20  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR testsuite/57605\n-\t* testsuite/lib/libmudflap.exp (libmudflap-init): Append\n-\t-fdiagnostics-color=never to cxxflags.\n-\n-2013-09-20  Alan Modra  <amodra@gmail.com>\n-\n-\t* configure: Regenerate.\n-\n-2013-03-14  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR tree-optimization/53265\n-\t* testsuite/libmudflap.c/fail37-frag.c: Add optimization barrier.\n-\n-2013-02-03  Richard Sandiford  <rdsandiford@googlemail.com>\n-\n-\tUpdate copyright years.\n-\n-2013-01-03  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* mf-runtime.c (__mf_usage): Update copyright notice dates.\n-\n-2012-12-15  Alexandre Oliva <aoliva@redhat.com>\n-\n-\t* mf-hooks1.c (free): Return on NULL before any logging.\n-\n-2012-09-14  David Edelsohn  <dje.gcc@gmail.com>\n-\n-\t* configure: Regenerated.\n-\n-2012-07-13  Richard Guenther  <rguenther@suse.de>\n-\n-\t* testsuite/libmudflap.c++/ctors.exp: Explicitely specify -O0.\n-\t* testsuite/libmudflap.c++/c++frags.exp: Likewise.\n-\t* testsuite/libmudflap.cth/cthfrags.exp: Likewise.\n-\t* testsuite/libmudflap.c/cfrags.exp: Likewise.\n-\t* testsuite/libmudflap.c/externs.exp: Likewise.\n-\n-2012-07-13  Richard Guenther  <rguenther@suse.de>\n-\n-\t* testsuite/libmudflap.c/fail11-frag.c: Adjust to not look like memset.\n-\t* testsuite/libmudflap.c/fail12-frag.c: Likewise.\n-\n-2012-05-29  Joseph Myers  <joseph@codesourcery.com>\n-\n-\t* mf-impl.h: Fix typo.\n-\n-2012-05-16  H.J. Lu  <hongjiu.lu@intel.com>\n-\n-\t* configure: Regenerated.\n-\n-2012-04-11  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n-\n-\tPR 24985\n-\t* testsuite/lib/libmudflap.exp: Handle caret.\n-\n-2012-01-19  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR libmudflap/40778\n-\t* testsuite/libmudflap.c/fail68-frag.c: New test.\n-\n-2012-01-01  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* mf-runtime.c (__mf_usage): Update copyright notice dates.\n-\n-2011-11-21  Andreas Tobler  <andreast@fgznet.ch>\n-\n-\t* configure: Regenerate.\n-\n-2011-07-31  Tom de Vries  <tom@codesourcery.com>\n-\n-\tPR middle-end/43513\n-\t* testsuite/libmudflap.c/fail31-frag.c: Adapt testcase to prevent\n-\tfolding of alloca.\n-\n-2011-07-25  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\tRevert:\n-\t2011-07-15  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR testsuite/49753\n-\tPR tree-optimization/49309\n-\t* testsuite/libmudflap.c++/pass68-frag.cxx: New test.\n-\n-2011-07-15  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR testsuite/49753\n-\tPR tree-optimization/49309\n-\t* testsuite/libmudflap.c++/pass68-frag.cxx: New test.\n-\n-2011-07-13  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\t* configure.ac: Don't create pth.\n-\tCheck for library containing sched_yield.\n-\t* configure: Regenerate.\n-\t* config.h.in: Regenerate.\n-\n-\t* testsuite/lib/libmudflap.exp (libmudflap-init): Use\n-\tmfconfig_libs in -static check.\n-\n-2011-07-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\tPR libmudflap/49550\n-\t* mf-runtime.c (__wrap_main) [__sun__ && __svr4__]: Don't register\n-\tstdin, stdout, stderr.\n-\tRegister __ctype, __ctype_mask.\n-\n-\t* configure.ac: Check for mmap64.\n-\tCheck for rawmemchr, stpcpy, mempcpy.\n-\t* configure: Regenerate.\n-\t* config.h.in: Regenerate.\n-\t* mf-hooks1.c [HAVE_MMAP64] (__mf_0fn_mmap64): New function.\n-\t(mmap64): New wrapper function.\n-\t* mf-impl.h (__mf_dynamic_index) [HAVE_MMAP64]: Add dyn_mmap64.\n-\t* mf-runtime.c (__mf_dynamic) [HAVE_MMAP64]: Handle mmap64.\n-\n-\t* mf-hooks2.c [HAVE_GETMNTENT && HAVE_SYS_MNTTAB_H]: Implement\n-\tgetmntent wrapper.\n-\n-\t* mf-hooks3.c (_REENTRANT): Define.\n-\n-\t* testsuite/libmudflap.c/heap-scalestress.c (SCALE): Reduce to 10000.\n-\n-\t* testsuite/libmudflap.c/pass-stratcliff.c: Include ../config.h.\n-\t(MIN): Define.\n-\tUse HAVE_RAWMEMCHR, HAVE_STPCPY, HAVE_MEMPCPY as guards.\n-\n-\t* testsuite/libmudflap.c/pass47-frag.c: Expect __ctype warning on\n-\t*-*-solaris2.*.\n-\n-2011-07-01  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\tPR libmudflap/49549\n-\t* testsuite/lib/libmudflap.exp (load_gcc_lib): Load\n-\ttarget-supports.exp.\n-\t* testsuite/libmudflap.cth/cthfrags.exp: Only pass\n-\t--noinhibit-exec to GNU ld.\n-\n-2011-06-27  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n-\n-\tPR libmudflap/38738\n-\t* configure.ac: Check for sys/mnttab.h.\n-\tCheck for library containing connect.\n-\t* configure: Regenerate.\n-\t* config.h.in: Regenerate.\n-\t* mf-hooks2.c [HAVE_SYS_MNTTAB_H]: Include <sys/mnttab.h>.\n-\t* testsuite/libmudflap.c/pass-stratcliff.c (main) [__sun__ &&\n-\t__svr4__]: Disable rawmemchr, stpcpy, mempcpy tests.\n-\n-2011-02-13  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* configure: Regenerate.\n-\n-2011-01-03  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* mf-runtime.c (__mf_usage): Update copyright notice dates.\n-\n-2010-10-31  Jason Merrill  <jason@redhat.com>\n-\n-\tPR testsuite/20003\n-\t* testsuite/libmudflap.cth/pass40-frag.c: Increase timeout to 30.\n-\n-2010-08-20  Uros Bizjak  <ubizjak@gmail.com>\n-\n-\t* testsuite/libmudflap.c++/pass41-frag.cxx (dg-prune-output):\n-\tNew dg directive.\n-\n-2010-06-09  Iain Sandoe  <iains@gcc.gnu.org>\n-\n-\tPR bootstrap/43170\n-\t* configure: Regenerate.\n-\n-2010-05-16  Uros Bizjak  <ubizjak@gmail.com>\n-\n-\t* testsuite/libmudflap.c/pass46-frag.c (dg-options): Remove -Wall.\n-\n-2010-05-15  Uros Bizjak  <ubizjak@gmail.com>\n-\n-\t* testsuite/lib/mfdg.exp (additional_prunes): New global.\n-\t(dg-test): Clear additional_prunes before test is run.\n-\t(dg-prune-output): New procedure.\n-\t* testsuite/lib/libmudflap.exp (libmudflap-dg-test): Do not call\n-\tprune_gcc_output.\n-\t(libmudflap-dg-prune): New procedure.\n-\t* testsuite/libmudflap.c++/pass57-frag.cxx (dg-prune-output):\n-\tNew dg directive.\n-\n-2010-05-04  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\tPR other/43620\n-\t* configure.ac (AM_INIT_AUTOMAKE): Add no-dist.\n-\t* Makefile.in: Regenerate.\n-\t* testsuite/Makefile.in: Regenerate.\n-\n-2010-04-02  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* Makefile.in: Regenerate.\n-\t* aclocal.m4: Regenerate.\n-\t* testsuite/Makefile.in: Regenerate.\n-\n-2010-03-15  David S. Miller  <davem@davemloft.net>\n-\n-\t* testsuite/libmudflap.c/pass54-frag.c: Add explicit return from\n-\tmain.\n-\n-2010-01-09  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* mf-runtime.c (__mf_usage): Update copyright notice dates.\n-\n-2009-12-05  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* Makefile.in: Regenerate.\n-\t* configure: Regenerate.\n-\t* testsuite/Makefile.in: Regenerate.\n-\n-2009-09-22  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tPR libmudflap/41433\n-\t* mf-runtime.c (__mf_init): Ignore $MUDFLAP_OPTIONS if\n-\trunning setuid or setgid.\n-\n-2009-09-01  Loren J. Rittle  <ljrittle@acm.org>\n-\n-\t* mf-runtime.c (__mf_init): Support FreeBSD.\n-\tPrime mutex which calls calloc upon first lock to avoid deadlock.\n-\t* mf-hooks1.c (__mf_0fn_mmap): Support FreeBSD.\n-\tIgnore red zone allocation request for initial thread's stack.\n-\n-2009-09-01  Loren J. Rittle  <ljrittle@acm.org>\n-\t    Andreas Schwab  <schwab@linux-m68k.org>\n-\n-\t* testsuite/libmudflap.c/pass51-frag.c (MAP_FAILED): Define,\n-\tif not in system header; use it.  On FreeBSD, must pass fd==-1\n-\twith MAP_ANON flag.  Correct mmap error check.\n-\t* testsuite/libmudflap.c/fail40-frag.c: Ditto.\n-\n-2009-08-24  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* configure.ac (AC_PREREQ): Bump to 2.64.\n-\n-2009-08-22  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* Makefile.am (install-html, install-pdf): Remove.\n-\t* Makefile.in: Regenerate.\n-\n-\t* Makefile.in: Regenerate.\n-\t* aclocal.m4: Regenerate.\n-\t* config.h.in: Regenerate.\n-\t* configure: Regenerate.\n-\t* testsuite/Makefile.in: Regenerate.\n-\n-2009-07-30  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* configure.ac (_AC_ARG_VAR_PRECIOUS): Use m4_rename_force.\n-\n-2009-07-16  Joseph Myers  <joseph@codesourcery.com>\n-\n-\t* configure: Regenerate.\n-\n-2009-07-11  Richard Sandiford  <rdsandiford@googlemail.com>\n-\n-\tPR testsuite/40699\n-\tPR testsuite/40707\n-\tPR testsuite/40709\n-\t* testsuite/lib/libmudflap.exp: Revert 2009-06-30 commit.\n-\n-2009-07-01  Richard Guenther  <rguenther@suse.de>\n-\n-\tPR tree-optimization/19831\n-\t* testsuite/libmudflap.c/fail11-frag.c: Make allocated memory\n-\tescape.\n-\t* testsuite/libmudflap.c/fail12-frag.c: Likewise.\n-\t* testsuite/libmudflap.c/fail16-frag.c: Likewise.\n-\t* testsuite/libmudflap.c/fail31-frag.c: Likewise.\n-\n-2009-06-30  Richard Sandiford  <r.sandiford@uk.ibm.com>\n-\n-\t* testsuite/lib/libmudflap.exp (libmudflap-init): Don't add \".\"\n-\tto ld_library_path.  Use add_path.  Add just find_libgcc_s to\n-\tld_library_path, not every libgcc multilib directory.\n-\n-2009-04-09  Nick Clifton  <nickc@redhat.com>\n-\n-\t* mf-hooks1.c: Change copyright header to refer to version 3\n-\tof the GNU General Public License with version 3.1 of the GCC\n-\tRuntime Library Exception and to point readers at the COPYING3\n-\tand COPYING3.RUNTIME files and the FSF's license web page.\n-\t* mf-heuristics.c: Likewise.\n-\t* mf-hooks2.c: Likewise.\n-\t* mf-hooks3.c: Likewise.\n-\t* mf-impl.h: Likewise.\n-\t* mf-runtime.c: Likewise.\n-\t* mf-runtime.h: Likewise.\n-\n-2009-04-09  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* testsuite/lib/mfdg.exp: Change copyright header to refer to\n-\tversion 3 of the GNU General Public License and to point readers\n-\tat the COPYING3 file and the FSF's license web page.\n-\t* testsuite/lib/libmudflap.exp: Likewise.\n-\n-2009-03-31  Ben Elliston  <bje@au.ibm.com>\n-\n-\tPR libmudflap/38462\n-\t* testsuite/libmudflap.c/fail27-frag.c: Match `mudflap dead\n-\tobject', not `mudflap object'.\n-\n-2009-03-01  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* configure: Regenerate.\n-\n-2009-02-03  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* mf-runtime.c (__mf_usage): Update copyright notice dates.\n-\n-2009-01-23  Jie Zhang  <jie.zhang@analog.com>\n-\n-\t* mf-impl.h (__mf_get_state, __mf_set_state): Don't use\n-\t__thread when TLS support is emulated.\n-\t* mf-hooks3.c (__mf_get_state, __mf_set_state): Likewise.\n-\t* mf-runtime.c (__mf_state_1): Likewise.\n-\t* configure.ac: Use GCC_CHECK_EMUTLS.\n-\t* configure: Regenerate.\n-\t* config.h.in: Regenerate.\n-\n-2008-12-18  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* configure: Regenerate.\n-\n-2008-11-26  Janis Johnson  <janis187@us.ibm.com>\n-\n-\tPR testsuite/28870\n-\t* testsuite/lib/mfdg.exp (dg-test): Use new timeout support.\n-\t(dg-timeout): Remove.\n-\t(standard-wait): Remove.\n-\t* testsuite/lib/libmudflap.exp: Include new timeout library files.\n-\t(libmudflap_target_compile): Set timeout value from new proc.\n-\n-2008-11-10  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR middle-end/35314\n-\t* testsuite/libmudflap.c/pass67-frag.c: New test.\n-\n-2008-10-09  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR c++/37568\n-\t* testsuite/libmudflap.c++/pass66-frag.cxx: New test.\n-\n-2008-09-26  Peter O'Gorman  <pogma@thewrittenword.com>\n-            Steve Ellcey  <sje@cup.hp.com>\n-\n-\t* configure: Regenerate for new libtool.\n-\t* Makefile.in: Ditto.\n-\t* testsuite/Makefile.in: Ditto.\n-\n-2008-09-15  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR libmudflap/36397\n-\t* testsuite/libmudflap.c/pass64-frag.c: New test.\n-\n-2008-06-17  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* Makefile.in: Regenerate.\n-\t* config.h.in: Regenerate.\n-\t* configure: Regenerate.\n-\t* testsuite/Makefile.in: Regenerate.\n-\n-2008-04-18  Paolo Bonzini  <bonzini@gnu.org>\n-\n-\tPR bootstrap/35457\n-\t* aclocal.m4: Regenerate.\n-\t* configure: Regenerate.\n-\n-2008-03-20  Volker Reichelt  <v.reichelt@netcologne.de>\n-\n-\t* testsuite/libmudflap.c/pass63-frag.c: New test.\n-\n-2008-03-16  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n-\n-\t* aclocal.m4: Regenerate.\n-\t* configure: Likewise.\n-\t* Makefile.in: Likewise.\n-\t* testsuite/Makefile.in: Likewise.\n-\n-2008-03-02  Jakub Jelinek  <jakub@redhat.com>\n-\n-\t* mf-runtime.c (__mf_usage): Update copyright notice dates.\n-\n-2008-02-21  Uros Bizjak  <ubizjak@gmail.com>\n-\n-\t* testsuite/libmudflap.c/fail8-frag.c: Adjust scan pattern for\n-\tmudflap dead object.\n-\t* testsuite/libmudflap.c/fail9-frag.c: Ditto.\n-\n-2008-01-24  David Edelsohn  <edelsohn@gnu.org>\n-\n-\t* configure: Regenerate.\n-\n-2008-01-05  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR tree-optimization/34618\n-\t* testsuite/libmudflap.c/pass62-frag.c: New test.\n-\n-2008-01-03  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR c++/34619\n-\t* testsuite/libmudflap.c++/pass61-frag.cxx: New test.\n-\n-2008-01-01  Volker Reichelt  <v.reichelt@netcologne.de>\n-\n-\tPR libmudflap/26442\n-\t* testsuite/libmudflap.c++/pass60-frag.cxx: New test.\n-\n-2007-10-15  Maciej W. Rozycki  <macro@linux-mips.org>\n-\n-\t* configure: Regenerate following changes to ../config/tls.m4.\n-\n-2007-07-26  Tom Tromey  <tromey@redhat.com>\n-\n-\t* Makefile.in: Rebuilt.\n-\t* Makefile.am (clean-local): Removed.\n-\t(pth/mf-runtime.lo, pth/mf-heuristics.lo, pth/mf-hooks1.lo,\n-\tpth/mf-hooks2.lo, pth/mf-hooks3.lo): Likewise.\n-\t(libmudflapth_la_SOURCES): List sources.\n-\t(libmudflapth_la_LIBADD): Clear.\n-\t(libmudflapth_la_CFLAGS): New variable.\n-\n-2007-07-05  H.J. Lu  <hongjiu.lu@intel.com>\n-\n-\t* aclocal.m4: Regenerated.\n-\n-2007-06-02  Paolo Bonzini  <bonzini@gnu.org>\n-\n-\t* configure: Regenerate.\n-\n-2007-05-31  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tFrom Andi Kleen <ak@suse.de>:\n-\t* mf-runtime.c (options): Rename structure for compatibility with\n-\tglibc getopt_long.\n-\n-2007-05-23  Steve Ellcey  <sje@cup.hp.com>\n-\n-\t* Makefile.in: Regenerate.\n-\t* configure: Regenerate.\n-\t* aclocal.m4: Regenerate.\n-\t* testsuite/Makefile.in: Regenerate.\n-\n-2007-03-14  Uros Bizjak  <ubizjak@gmail.com>\n-\n-\t* testsuite/libmudflap.cth/pass59-frag.c (main): Fix casting of arg.\n-\n-2007-03-01  Brooks Moses  <brooks.moses@codesourcery.com>\n-\n-\t* Makefile.am: Add dummy install-pdf target.\n-\t* Makefile.in: Regenerate\n-\n-2007-02-07  Jakub Jelinek  <jakub@redhat.com>\n-\n-\tPR libgomp/28468\n-\t* configure: Regenerate.\n-\n-2006-12-04  Eric Botcazou  <ebotcazou@libertysurf.fr>\n-\n-\t* configure: Regenerate.\n-\n-2006-11-13  Daniel Jacobowitz  <dan@codesourcery.com>\n-\n-\t* configure: Regenerated.\n-\n-2006-11-10  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tPR libmudflap/28578\n-\t* mf-hooks1.c (__mf_0fn_malloc): Make the bootstrap buffers\n-\tstatic but not function scope static.\n-\t(free): Skip deallocation attempts for objects placed into\n-\tbootstrap buffers.\n-\t* testsuite/libmudflap.cth/pass59-frag.c: New test.\n-\n-2006-11-06  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tFrom Herman ten Brugge <hermantenbrugge@home.nl>:\n-\t* mf-runtime.c (__mf_uncache_object): Optimize the code so that\n-\tsmall and large objects are handled a lot faster.\n-\n-2006-11-06  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* configure.ac (__libc_freeres): Look for it.\n-\t* mf-impl.h (call_libc_freeres): New configuration flag.\n-\t* mf-runtime.c (__mf_set_default_options): Set it by default.\n-\t(__mfu_report): Call it if needed.\n-\t(__mfu_unregister): Remove \"unaccessed registered object\" warning.\n-\t* configure, config.h.in: Regenerated.\n-\n-2006-09-18  Tom Tromey  <tromey@redhat.com>\n-\n-\t* configure: Rebuilt.\n-\n-2006-06-21  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tPR 21274\n-\tmf-runtime.h installation based on ssp patch for PR 26473 from\n-\tMark Mitchell  <mark@codesourcery.com>.\n-\t* configure.ac (ACX_NONCANONICAL_TARGET): Use it.\n-\t* Makefile.am (target_noncanonical): Define.\n-\t(libsubincludedir): New variable.\n-\t(nobase_libsubinclude_HEADERS): Add mf-runtime.h.\n-\t(include_HEADERS): Remove.\n-\t* configure, aclocal.m4, config.h.in: Regenerated.\n-\t* Makefile.in, testsuite/Makefile.in: Likewise.\n-\t* mf-runtime.h: Add #ifndef protection for conflicting _REENTRANT\n-\tand _THREAD_SAFE redefinition values.\n-\n-2006-05-23  Carlos O'Donell  <carlos@codesourcery.com>\n-\n-\t* Makefile.am: Add install-html target. Add install-html to .PHONY\n-\t* Makefile.in: Regenerate.\n-\n-2006-04-19  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n-\n-\tPR mudflap/26789\n-\t* testsuite/libmudflap.c++/error1-frag.cxx: New test.\n-\n-\tPR mudflap/26790\n-\t* testsuite/libmudflap.c++/error2-frag.cxx: New test.\n-\n-2006-04-10  Matthias Klose  <doko@debian.org>\n-\n-\t* testsuite/lib/libmudflap.exp (libmudflap-init): Recognize multilib\n-\tdirectory names containing underscores.\n-\n-2005-11-22  Janis Johnson  <janis187@us.ibm.com>\n-\n-\t* testsuite/lib/libmudflap.exp (libmudflap-init): Remove -static from\n-\tMUDFLAP_FLAGS if static library not supported.\n-\t* testsuite/libmudflap.c/cfrags.exp (MUDFLAP_FLAGS): new.\n-\t* testsuite/libmudflap.c/externs.exp: Ditto.\n-\t* testsuite/libmudflap.c++/ctors.exp: Ditto.\n-\t* testsuite/libmudflap.c++/c++frags.exp: Ditto.\n-\t* testsuite/libmudflap.cth/cthfrags.exp: Ditto.\n-\n-2005-10-04  James E Wilson  <wilson@specifix.com>\n-\n-\t* configure.ac (mudflap_cv_entry_point): Use quadrigraphs to declare\n-\t$name as array of characters with unknown bound.  Also store into the\n-\tarray.\n-\t* configure: Regenerate.\n-\n-2005-09-30  James E. Wilson  <wilson@specifix.com>\n-\n-\t* configure.ac (pthread.h): Use AC_CHECK_HEADERS instead of\n-\tAC_CHECK_HEADER.\n-\t(target_thread_file): New.  Set from sed'ed gcc output.\n-\t(posix_threads): New.  Set from target_thread_file.  Use instead of\n-\tac_have_pthread_h.\n-\t(pthread_create_version): Move initialization before code using it.\n-\t* configure: Regenerate.\n-\n-\t* mf-heuristics.c (_end, ENTRY_POINT): Make them arrays with unknown\n-\tbounds.\n-\n-2005-09-29  James E. Wilson  <wilson@specifix.com>\n-\n-\t* mf-hooks1.c (__mf_0fn_mmap, mmap, __mf_0fn_munmap, munmap): Protect\n-\twith HAVE_MMAP ifdef.\n-\n-2005-09-23  Frank Ch. Eigler  <fche@elastic.org>\n-\n-\tPR 23084.\n-\t* mf-hooks2.c (accept): Tolerate NULL sockaddr* parameter.\n-\n-2005-09-23  Frank Ch. Eigler  <fche@elastic.org>\n-\n-\t* testsuite/libmudflap.c++/pass58-frag.cxx: New test for heisenbug 19319.\n-\n-2005-09-23  Tom Tromey  <tromey@redhat.com>\n-\n-\t* aclocal.m4, configure: Rebuilt.\n-\t* configure.ac: Use GCC_CHECK_TLS.\n-\t* acinclude.m4 (LIBMUDFLAP_CHECK_TLS, LIBMUDFLAP_ENABLE): Moved\n-\tto ../config.\n-\n-2005-08-22  Jim Wilson  <wilson@specifix.com>\n-\n-\t* mf-hooks2.c (MF_REGISTER_fopen): Define to __MF_TYPE_STATIC when\n-\t__FreeBSD__ is defined.\n-\n-2005-08-17  Jim Wilson  <wilson@specifix.com>\n-\n-\t* mf-hooks1.c (malloc, calloc, realloc, free,\n-\t__mf_wrap_alloca_indirect): Call BEGIN_MALLOC_PROTECT before calling\n-\tthe real routines, and END_MALLOC_PROTECT afterwards.\n-\t* mf-impl.h (enum __mf_state_enum): Expand comment.  Add in_malloc.\n-\t(BEGIN_PROTECT): Handle in_malloc state.\n-\t(BEGIN_MALLOC_PROTECT, END_MALLOC_PROTECT): New.\n-\t* testsuite/libmudflap.c/hook2-allocstuff.c: New.\n-\n-2005-08-17  Kelley Cook  <kcook@gcc.gnu.org>\n-\n-\t* All files: Update FSF address.\n-\n-2005-08-15  Ulrich Weigand  <weigand@informatik.uni-erlangen.de>\n-\n-\t* mf-hooks3.c (main_seen_p): Remove.\n-\t(__mf_get_state): Remove attempt to recognize the main thread.\n-\n-2005-08-15  Maciej W. Rozycki  <macro@linux-mips.org>\n-\n-\t* configure.ac: Test for the name of the symbol used for the entry\n-\tpoint; define ENTRY_POINT to the result.\n-\t* configure: Regenerate.\n-\t* config.h.in: Regenerate.\n-\t* mf-heuristics.c: Replace _start with ENTRY_POINT throughout.\n-\n-2005-08-14  Ulrich Weigand  <weigand@informatik.uni-erlangen.de>\n-\n-\t* mf-runtime.c (__mf_state_1): Initialize to reentrant.\n-\t(__mf_init): Set thread state active.\n-\t* mf-hooks3.c (__mf_pthread_spawner): Always set thread\n-\tstate active.\n-\t(pthread_create wrapper): Always use thread spawner.\n-\n-\t* testsuite/libmudflap.cth/pass37-frag.c: Increase timeout.\n-\t* testsuite/libmudflap.cth/pass39-frag.c: Likewise.\n-\n-2005-07-16  Richard Henderson  <rth@redhat.com>\n-\n-\t* acinclude.m4: New file.\n-\t* configure.ac: Invoke LIBMUDFLAP_CHECK_TLS.\n-\t* configure, config.h.in, Makefile.in, testsuite/Makefile.in: Rebuild.\n-\t* mf-hooks1.c (__mf_0fn_malloc): Move body from ...\n-\t(__mf_0fn_calloc): ... here.\n-\t* mf-hooks3.c (struct pthread_info): Remove.\n-\t(__mf_pthread_info, __mf_pthread_info_idx): Remove.\n-\t(LIBMUDFLAPTH_THREADS_MAX): Set to 1021.\n-\t(struct mf_thread_data): New.\n-\t(mf_thread_data, mf_thread_data_lock): New.\n-\t(__mf_allocate_blank_threadinfo): Remove.\n-\t(__mf_find_threadinfo): Rewrite and simplify.  Only use if TLS is\n-\tnot available.\n-\t(__mf_state_perthread): Remove.\n-\t(__mf_get_state, __mf_set_state): New.\n-\t(__mf_pthread_cleanup): Use &errno, rather than saved pointer.\n-\tUpdate mf_thread_data killing procedure.\n-\t(__mf_pthread_spawner): Similarly.\n-\t(__mf_0fn_pthread_create): Only use wrapper if necessary.  Remove\n-\tcode to allocate thread stack space.\n-\t(__mf_0fn_pthread_join, pthread_join): Remove.\n-\t(__mf_0fn_pthread_exit, pthread_exit): Remove.\n-\t* mf-impl.h (dyn_pthread_join, dyn_pthread_exit): Remove.\n-\t(__mf_state_1): Rename from __mf_state; use TLS when available.\n-\t(__mf_get_state, __mf_set_state): New.  Update all users.\n-\t* mf-runtime.c (begin_recursion_protect1): New.\n-\t(BEGIN_RECURSION_PROTECT): Use it.\n-\t(__mf_state_1): Rename from __mf_state; use TLS when available.\n-\t(threads_active_p): Remove.\n-\t(__mf_usage): Compute it directly.\n-\n-2005-06-19  Ulrich Weigand  <uweigand@de.ibm.com>\n-\n-\t* testsuite/libmudflap.c/externs-1.c (main): Add return statement.\n-\n-2005-06-15  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tFix for uncaching bug reported by Herman ten Brugge.\n-\t* mf-runtime.c (__mf_uncache_object): Search whole cache.\n-\t* testsuite/libmudflap.c/fail40-frag.c: New test.\n-\n-2005-05-23  Alfred M. Szmidt  <ams@gnu.org>\n-\n-\tPR libmudflap/21724\n-\t* Makefile.am (AM_MAKEFLAGS): Pass includedir.\n-\t* Makefile.in: Amend.\n-\n-2005-06-14  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tPR mudflap/21023\n-\t* testsuite/libmudflap.c/externs.exp, externs-{1,2}.c: New test files.\n-\t* testsuite/libmudflap.c/cfrags.exp: Bypass new sources.\n-\n-2005-06-14  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tPR libmudflap/21094\n-\t* testsuite/libmudflap.c++/*.exp: Assert build tree g++.\n-\n-2005-06-14  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tPR mudflap/22064\n-\t* mf-impl.h (mudflap_mode, violation_mode): Make these ordinary\n-\tunsigned vars with #defines instead of enums.\n-\n-2005-05-09  Mike Stump  <mrs@apple.com>\n-\n-\t* configure: Regenerate.\n-\n-2005-04-12  Mike Stump  <mrs@apple.com>\n-\n-\t* configure: Regenerate.\n-\n-2005-04-12  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tPR mudflap/19266\n-\t* testsuite/libmudflap.c++/c++frags.exp: Also test -O permutation.\n-\t* testsuite/libmudflap.c++/pass57-frag.cxx: New test.\n-\n-2005-04-04  Alan Modra  <amodra@bigpond.net.au>\n-\n-\t* mf-runtime.c (__mfu_unregister): Warning fix for char unsigned.\n-\n-2005-03-31  Mike Stump  <mrs@apple.com>\n-\n-\t* mf-runtime.h: Add libmudflap copyright clause.\n-\n-2005-03-21  Mike Stump  <mrs@apple.com>\n-\n-\t* mf-heuristics.c: Fix whitespace at end of line.\n-\t* mf-hooks1.c: Likewise.\n-\t* mf-hooks2.c: Likewise.\n-\t* mf-hooks3.c: Likewise.\n-\t* mf-impl.h: Likewise.\n-\t* mf-runtime.c: Likewise.\n-\t* mf-runtime.h: Likewise.\n-\n-2005-03-21  Zack Weinberg  <zack@codesourcery.com>\n-\n-\t* configure.ac: Do not invoke TL_AC_GCC_VERSION.\n-\tIn all substitutions, expand gcc_version in Makefile.\n-\t* aclocal.m4, configure: Regenerate.\n-\t* Makefile.am: Set gcc_version.\n-\t* Makefile.in, testsuite/Makefile.in: Regenerate.\n-\n-2005-03-17  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-runtime.c (__mfu_check): Respect ignore_reads configuration.\n-\t* testsuite/libmudflap.c/{pass56,fail39}-frag.c: New tests.\n-\n-2005-02-13  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tPR mudflap/19319\n-\t* testsuite/libmudflap.c++/pass55-frag.c: New test.\n-\n-2005-01-05  Richard Henderson  <rth@redhat.com>\n-\n-\t* testsuite/libmudflap.c/pass32-frag.c: Fix typo.\n-\n-2005-01-02  Greg McGary  <greg@mcgary.org>\n-\n-\t* mf-impl.h (uintptr_t): Get typedef via stdint.h or define explicitly.\n-\t* mf-runtime.h: New file, replaces mf-runtime.h.in.\n-\t* configure.ac (AC_CONFIG_FILES): mf-runtime.h is no longer generated.\n-\t* Makefile.in: Ditto.\n-\t* testsuite/lib/libmudflap.exp: Add -I${srcdir}/.. to get mf-runtime.h\n-\t* testsuite/libmudflap.c/pass32-frag.c: s/uintptr_t/__mf_uintptr_t/\n-\t* testsuite/libmudflap.c/fail36-frag.c: New test.\n-\t* testsuite/libmudflap.c/fail37-frag.c: New test.\n-\t* testsuite/libmudflap.c/fail38-frag.c: New test.\n-\n-2004-12-08  Kelley Cook  <kcook@gcc.gnu.org>\n-\n-\t* Makefile.am: Add ../config to ACLOCAL_AMFLAGS.\n-\t* aclocal.m4, Makefile.in, testsuite/Makefile.in: Regenerate.\n-\n-2004-12-02  Richard Sandiford  <rsandifo@redhat.com>\n-\n-\t* configure.ac: Use TL_AC_GCC_VERSION to set gcc_version.\n-\t* aclocal.m4: Include ../config/gcc-version.m4.\n-\t* configure, Makefile.in, testsuite/Makefile.in: Regenerate.\n-\n-2004-11-29  Kelley Cook  <kcook@gcc.gnu.org>\n-\n-\t* Makefile.am: Define ACLOCAL_AMFLAGS.\n-\t* acinclude.m4: Remove.\n-\t* stamp-h.in: Remove superfluous stamp file.\n-\t* aclocal.m4, configure, Makefile.in: Regenerate.\n-\t* testsuite/Makefile.in: Likewise.\n-\n-2004-11-24  Kelley Cook  <kcook@gcc.gnu.org>\n-\n-\t* Makefile.am: Revert previous.\n-\t* acinclude.m4: Restore.\n-\t* aclocal.m4, configure, Makefile.in: Regenerate.\n-\t* testsuite/Makefile.in: Likewise.\n-\n-2004-11-24  Kelley Cook  <kcook@gcc.gnu.org>\n-\n-\t* Makefile.am: Define ACLOCAL_AMFLAGS.\n-\t* acinclude.m4: Remove.\n-\t* aclocal.m4, configure, Makefile.in: Regenerate.\n-\t* testsuite/Makefile.in: Likewise.\n-\n-2004-11-23  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n-\n-\t* testsuite/lib/libmudflap.exp: Use new procs in target-libpath.exp.\n-\n-2004-11-23  Kelley Cook  <kcook@gcc.gnu.org>\n-\n-\t* Makefile.in, configure, aclocal.m4: Regenerate with automake 1.9.3.\n-\t* testsuite/Makefile.in: Likewise.\n-\n-2004-11-01  Andreas Schwab  <schwab@suse.de>\n-\n-\t* configure.ac: (target_alias): Default to $host_alias, not\n-\t$target.\n-\t* configure: Regenerated.\n-\n-2004-10-28  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* testsuite/libmudflap.c/fail35-,pass53-,pass54-frag.c: New tests.\n-\t* testsuite/libmudflap.c/pass35-frag.c: Correct embedded warning\n-\tmessage.\n-\n-2004-10-25  Eric Botcazou  <ebotcazou@libertysurf.fr>\n-\n-\tPR other/18138\n-\t* testsuite/lib/libmudflap.exp: Accept more than one multilib libgcc.\n-\n-2004-10-12  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* configure.ac: Check for more headers, functions.\n-\t* mf-hooks2.c (mkbuffer, unmkbuffer): New helper functions for\n-\ttracking overridden FILE buffers.\n-\t(fopen, setvbuf): New/revised hook functions for buffer overriding.\n-\t(setbuf,setlinebuf,fdopen,freopen,fopen64,freopen64,fclose): Ditto.\n-\t(fflush): Accept given NULL stream (means \"all streams\").\n-\t* mf-runtime.h.in:\n-\t* mf-runtime.c (__mfu_check): Accept accesses that span adjacent\n-\tHEAP/GUESS objects.\n-\t(LOOKUP_CACHE_SIZE_MAX): Raise to 64K entries tentatively.\n-\t(__mf_adapt_cache): Use them all.\n-\t* testsuite/libmudflap.c/pass35-frag.c: Update warning message.\n-\t* testsuite/libmudflap.c++/ctors.exp: Ditto.\n-\t* testsuite/libmudflap.c/{pass51,pass52}-frag.c: New tests.\n-\t* configure, config.h.in: Regenerated.\n-\n-2004-10-05  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* configure.ac: Checking for sys/socket.h once is enough.\n-\t* configure: Regenerated.\n-\n-2004-10-04  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* configure.ac: Look for more headers & functions.\n-\t* mf-hooks2.c (getmntent, inet_ntoa, getproto*): New wrapper functions.\n-\t* mf-runtime.h.in: Add new \"#pragma redefine_extname\"s for them.\n-\t* mf-runtime.c (options): Clean up integer signedness warnings.\n-\t(main): Add a declaration to fix a warning.\n-\t* mf-hooks3.c (pthread_exit): Add not-reached exit() to wrapper.\n-\t* configure, config.h.in: Regenerated.\n-\n-2004-10-02  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* testsuite/libmudflap.c/pass50-frag.c, fail33-frag.c, fail34-frag.c:\n-\tNew tests for proper base/limit checking for aggregates.\n-\n-2004-09-15  Joseph S. Myers  <jsm@polyomino.org.uk>\n-\n-\t* testsuite/libmudflap.c/pass35-frag.c: Update expected message.\n-\n-2004-09-07  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* configure.ac: Look for pwd.h, grp.h, netdb.h headers and functions.\n-\t* mf-hooks2.c (strerror): Unregister previous string returned by\n-\tprevious strerror.\n-\t(getlogin,cuserid,getpwnam,getpwuid,getgrnam,getgrgid): New wrappers.\n-\t(getservent,getservbyname,getservbyport,gai_strerror): Ditto.\n-\t* mf-runtime.h.in: Add redefine_extname pragmas for them all.\n-\t* mf-runtime.c (__mf_describe_object): Clarify object life status.\n-\t* testsuite/libmudflap.c/pass48-frag.c, pass49-frag.c, fail32-frag.c:\n-\tNew tests.\n-\t* configure, config.h.in: Regenerated.\n-\n-2004-08-03  Dale Johannesen  <dalej@apple.com>\n-\n-\t * mf-runtime.c: Conditionalize POSIX_SOURCE for Darwin.\n-\n-2004-08-03  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-runtime.c (compare_uintptr_t): Remove function.  Inline\n-\tsimplified contents in all former callers.\n-\n-2004-07-27  Ulrich Weigand  <weigand@informatik.uni-erlangen.de>\n-\n-\t* mf-runtime.c (__mf_fini): Set mudflap_mode to mode_nop in\n-\tthe statically linked case.\n-\n-2004-07-27  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* splay-tree.[ch]: Remove.  Merge contents into ...\n-\t* mf-runtime.c: ... here, renaming symbols and making all functions\n-\tstatic.  Remove unused min/max functions.\n-\t* Makefile.am: Forget about splay-tree.[ch].\n-\t* Makefile.in, testsuite/Makefile.in: Regenerated.\n-\n-2004-07-21  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-runtime.c (__mfu_check): Remove mistaken mode-nop handling.\n-\t(__mfu_usage): Include (C) 2004.\n-\t* mf-hooks3.c (__mf_find_threadinfo): Don't call tracing functions\n-\there.  Include a comment explaining why.\n-\n-2004-07-20  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-impl.h (__mf_options): Add ignore_reads and timestamps fields.\n-\t* mf-runtime.c (options): Give them a name.\n-\t(__mf_set_default_options): Set them.\n-\t(__mf_insert_new_object, __mfu_unregister): Optionalize timestamps.\n-\t(__mf_violation): Warning cleanup.\n-\t* mf-impl.h (MF_VALIDATE_EXTENT): Support ignore_reads option.\n-\t* splay-tree.c (splay_tree_delete_helper): Remove obsolete decl.\n-\n-2004-07-15  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tg++/15861\n-\t* mf-runtime.c (__mf_init): Make it non-static.  Tolerate\n-\trepeated invocation.\n-\n-2004-07-09  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tTest case for g++/15861\n-\t* testsuite/libmudflap.c++/ctors-[12].cxx: New test case halves.\n-\t* testsuite/libmudflap.c++/ctors.exp: Driver.\n-\t* testsuite/libmudflap.c++/c++frags.exp: Elide redundant default.\n-\tLook only for *frag* test cases.\n-\n-2004-07-08  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tANSI C conversion, libmudflap specialization, recursion limiting.\n-\t* splay-tree.h (splay_tree_{de,}allocate_fn): Remove allocation_data\n-\targument and indirection function pointers, update callers.\n-\t(splay_tree_s): Add statistics and recursion control fields\n-\tnum_keys, max_depth, depth, rebalance_p.\n-\t* splay-tree.c (splay_tree_splay_helper): Track recursion depth.\n-\tBack out of search if it exceeds limit.\n-\t(splay_tree_splay): Manage recursion limiting with rebalancing as\n-\tneeded.\n-\t(splay_tree_new): More initialization.\n-\t(splay_tree_rebalance): New function.\n-\t(splay_tree_foreach): Rewrite using nonrecursive logic.\n-\t(splay_tree_xmalloc_allocate, splay_tree_xmalloc_deallocate):\n-\tRemove.  Point indirect calls to mf-runtime.c's routines.\n-\t(splay_tree_compare_ints, splay_tree_compare_pointers): Remove unused\n-\tfunctions.\n-\t(splay_tree_delete, splay_tree_delete_helper): Ditto.\n-\t* testsuite/heap-scalestress.c: New test based on one from\n-\tEyal Lebedinsky <eyal@eyal.emu.id.au>:\n-\n-2004-07-05  Matthias Klose  <doko@debian.org>\n-\n-\t* libtool-version: New.\n-\t* Makefile.am (libmudflap_la_LDFLAGS, libmudflapth_la_LDFLAGS):\n-\tUse -version-info for soname.\n-\t* Makefile.in: Regenerate.\n-\t* configure.ac: Remove libtool_VERSION macro\n-\t* configure: Regenerate\n-\n-2004-07-05  Zack Weinberg  <zack@codesourcery.com>\n-\n-\t* mf-runtime.h.in: Wrap declarations of struct __mf_cache,\n-\t__mf_lookup_cache, __mf_lc_mask, or __mf_lc_shift in\n-\t#ifndef _MUDFLAP.\n-\n-2004-06-29  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tSplay tree implementation fork.\n-\t* splay-tree.c, splay-tree.h: Copied & modified from libiberty.\n-\tUse hard-coded comparison function for uintptr_t.  Remove key/value\n-\tdeallocation logic.  Cache last splayed key for consecutive lookups.\n-\t* Makefile.am, Makefile.in: Use them, don't link to them.\n-\t* mf-runtime.c (__mf_object_tree): Adapt to simpler splay_tree_new.\n-\t(__mf_find_objects2): Flip successor/predecessor search sequence.\n-\t* ansidecl.h, libiberty.h: Removed dummy files.\n-\n-2004-06-29  Nick Clifton  <nickc@redhat.com>\n-\n-\t* configure.ac (AC_CHECK_HEADERS): Add dirent.h\n-\t* configure: Regenerate.\n-\t* mf-hooks2.c: Surround uses of dirent.h with #ifdef\n-\tHAVE_DIRENT_H.\n-\tRemove spurious inclusion of <strings.h>.\n-\n-2004-06-29  Nick Clifton  <nickc@redhat.com>\n-\n-\t* mf-runtime.c (pthread_join): Only apply the weak pragma if the\n-\tfunction actually exists.\n-\n-2004-06-25  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* ansidecl.h, libiberty.h: New dummy files for building splay-tree.\n-\t* config.h.in: Regenerated.\n-\n-2004-06-24  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tAdopt splay trees for object database.\n-\t* Makefile.am: Copy splay-tree.* from libiberty.\n-\t* Makefile.in, testsuite/Makefile.in: Regenerated.\n-\t* mf-runtime.h.in (__mf_unregister): Add third parameter (type).\n-\t* mf-hooks[123].c (*): Add new third parameter to mf_unregister.\n-\t* mf-impl.h (BEGIN_PROTECT): Remove some trace text.\n-\t* mf-runtime.c: Rewrite code dealing with object database to use\n-\tlibiberty splay trees.  Remove tree liveness aging option.\n-\t* testsuite/libmudflap.c/fail18-frag.c: Add volatile flag.\n-\n-2004-06-15  Paolo Bonzini  <bonzini@gnu.org>\n-\n-\t* configure.ac: New name of configure.in.  Update\n-\tAC_INIT, AC_CONFIG_SRCDIR, AC_CONFIG_HEADERS, AC_CONFIG_FILES,\n-\tAC_OUTPUT, AM_INIT_AUTOMAKE to the preferred style for\n-\tAutoconf 2.5x and Automake 1.7 or later.\n-\t* configure.in: Remove.\n-\t* configure: Regenerate.\n-\n-\t* Makefile.am: Remove useless multilib rules.\n-\t* Makefile.in: Regenerate.\n-\n-2004-06-15  Paolo Bonzini  <bonzini@gnu.org>\n-\n-\t* .cvsignore: New file.\n-\n-2004-06-10  Stephen Crowley  <stephen.crowley@sbcglobal.net>\n-\n-\tPR libmudflap/13505\n-\t* mf-hooks2.c (semctl): Add cygwin porting hack.\n-\n-2004-06-09  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tctype support.\n-\t* configure.in: Look for ctype header and glibc implementation.\n-\t* mf-hooks2.c (__ctype_{b,toupper,tolower}_loc): Sample ctype\n-\tarray hooks for glibc 2.3.\n-\t* mf-runtime.h.in: Wrap them.\n-\t* mf-runtime.c (__mf_init): Leave marker regarding other ctype\n-\timplementations.\n-\t* testsuite/libmudflap.c/pass47-frag.c: New test.\n-\t* configure, config.h.in: Regenerated.\n-\n-2004-06-04  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tPortability improvements, e.g., libmudflap/15293.\n-\t* configure.in: Look for glibc extension functions.  Look for\n-\tsupport of -f{function,data}-sections.  Look for more headers.\n-\tCreate testsuite/mfconfig.exp.  Correct more \"test x..\" thinkos.\n-\t* Makefile.am: Use $(SECTION_FLAGS).  Collapse piecemeal-compiled\n-\tmf-hooks* into usual single object per source.\n-\t* mf-hooks*.c: Remove all #if WRAP_foo conditionals.\n-\t* mf-hooks2.c: #include a bunch more system headers.  Define strnlen\n-\tif system doesn't provide one.\n-\t* mf-hooks3.c (struct pthread_info): Add stack_*_alloc fields.\n-\t(pthread_create): Use it to properly GC dead thread stacks.\n-\t* mf-runtime.c (__mf_violation): Correct snprintf type warning.\n-\t* testsuite/Makefile.am: Stop generating site.exp.\n-\t* testsuite/mfconfig.exp.in: New file.\n-\t* testsuite/config/default.exp: Load new mfconfig.exp.\n-\t* testsuite/lib/libmudflap.exp (libmudflap-init): Add extra libraries.\n-\t(prune_gcc_output): Add glibc static linking warnings.\n-\t* testsuite/libmudflap.*/*frags.exp: Enumerate needed -lmudflap* libs.\n-\t* testsuite/libmudflap.c/pass46-frag.c: Ditto.\n-\t* configure, Makefile, aclocal.m4, config.h.in, testsuite/Makefile.in:\n-\tRegenerated with autoconf 2.57 and automake 1.7.\n-\n-2004-06-04  Per Bothner  <per@bothner.com>\n-\n-\t* configure.in (LIBMUDFLAPTH):  Fix thinko.\n-\n-\t* configure.in:  Check for more headers.\n-\t* mf-hooks2.c:  Conditionalize on HAVE_SYS_SOCKET_H etc.\n-\n-\t* mf-runtime.c:  In two places conditionalize on SIUSR1 rather than\n-\tHAVE_SIGNAL as mingw has signal.h but not SIUSR1.\n-\n-2004-06-01  Andreas Jaeger  <aj@suse.de>\n-\n-\t* configure.in: Handle multilibs, support\n-\t--enable-version-specific-runtime-libs.\n-\t* Makefile.am (lib_LTLIBRARIES): Rename to ...\n-\t(toolexeclib_LTLIBRARIES): this for multilib support.\n-\t* Makefile.in: Regenerated.\n-\t* configure: Regenerated.\n-\t* aclocal.m4: Regenerated.\n-\t* config.h.in: Regenerated.\n-\t* testsuite/Makefile.in: Regenerated.\n-\n-2004-06-01  Andreas Jaeger  <aj@suse.de>\n-\n-\t* testsuite/lib/libmudflap.exp (libmudflap-init): Handle\n-\tmultilibs, using multilib directory instead of hardcoded path.\n-\tSet LD_RUN_PATH.\n-\n-2004-05-21  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* Makefile.am (AM_MAKEFLAGS): Pass RUNTESTFLAGS.\n-\t* Makefile.in: Ditto.\n-\n-2004-05-18  Kaz Kojima  <kkojima@gcc.gnu.org>\n-\n-\t* acinclude.m4 (lt_cv_deplibs_check_method): Use pass_all on sh*.\n-\t* aclocal.m4, configure: Rebuilt.\n-\n-2004-05-17  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* lib/libmudflap.exp (libmudflap-init): For C++ test cases only,\n-\timport some build settings from libstdc++-v3 testsuite_flags.\n-\t* .../cfrags.exp, .../c++frags.exp, .../cthfrags.exp: Corresponding\n-\tchanges to pass test language.\n-\n-\t* mf-runtime.c (__mfu_check): Poison the cache with antidote for\n-\tquicker mode-nop handling.\n-\n-2004-03-25  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-impl.h: Added libgcc license header.\n-\n-2004-03-20  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-hooks[123].c, mf-runtime.c, mf-heuristics.c:\n-\tAdded libgcc license header.\n-\t* mf-hooks3.c (__mf_0fn_pthread_create): Correct arg constness.\n-\t(pthread_create): Simplify stack allocation syntax.\n-\n-2004-03-08  Loren J. Rittle  <ljrittle@acm.org>\n-\n-\t* mf-hooks2.c: Support FreeBSD.\n-\t(WRAP_gets): Avoid gets().\n-\t* testsuite/libmudflap.c/pass-stratcliff.c: Do not\n-\ttest unimplemented mem/str calls on FreeBSD.\n-\t* testsuite/libmudflap.c/pass21-frag.c: Do not include\n-\t<alloca.h> on FreeBSD.\n-\n-2004-01-30  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* testsuite/libmudflap.c/pass36-frag.c: Add missing free() call.\n-\t* testsuite/libmudflap.c/pass46-frag.c: New test for -fmudflapir.\n-\t* testsuite/libmudflap.cth/cthfrags.exp: Add -DSTATIC to compiler\n-\tflags for static linking permutation.\n-\t* testsuite/libmudflap.cth/pass40-frag.c: When -DSTATIC, avoid\n-\tsome pthreads code that croaks on linux glibc tls.\n-\n-2004-01-27  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* testsuite/libmudflap.c/fail31-frag.c, pass45-frag.c: New tests.\n-\n-2004-01-15  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* testsuite/libmudflap.c/pass44-frag.c: New test.\n-\n-2004-01-12  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* testsuite/libmudflap.c/fail{28,29,30}-frag.c: New tests.\n-\n-2004-01-08  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* testsuite/libmudflap.c/pass43-frag.c: Added missing program rc.\n-\n-2003-12-11  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* testsuite/libmudflap.c/pass42-frag.c, pass43-frag.c: New tests.\n-\n-2003-12-08  Andrew Pinski  <pinskia@physics.uc.edu>\n-\n-\tPR libmudflap/12670\n-\t* configure.in: Add check for see if\n-\tsocklen_t typedef is in sys/socket.h.\n-\t* mf-hooks1.c: Add define if socklen_t\n-\tis not typedef.\n-\t* mf-hooks2.c: Likewise.\n-\t* mf-hooks3.c: Likewise.\n-\t* config.h.in: Regen.\n-\t* configure: Regen.\n-\n-2003-12-08  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-runtime.c (__mf_watch_or_not): Tweak tracing message.\n-\t* testsuite/libmudflap.c/fail21-frag.c: Defeat aliasing\n-\toptimizations.\n-\t* testsuite/libmudflap.c/pass25-frag.c: Ditto.\n-\t* testsuite/libmudflap.c/pass26-frag.c: Tolerate non-overlapping\n-\t(unoptimized) allocation of stack space.\n-\n-2003-12-07  Richard Henderson  <rth@redhat.com>\n-\n-\t* testsuite/libmudflap.c/fail23-frag.c (main): Adjust addend to 11.\n-\t* testsuite/libmudflap.c/fail27-frag.c (foo): Mark noinline.\n-\n-2003-12-06  Andrew Pinski <apinski@apple.com>\n-\n-\tpartial PR libmudflap/12670\n-\t* mf-hooks1.c: Respect Darwin checks.  Conditionalize POSIX_SOURCE.\n-\t* mf-hooks2.c: Likewise.\n-\t* mf-hooks3.c: Likewise.\n-\n-2003-11-19  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tlibstdc++/11696\n-\t* mf-runtime.h.in: Switch to #pragma redefine_extname for\n-\tsymbols interposed at compile time.\n-\t* testsuite/libmudflap.c++/pass41-frag.cxx: New test.\n-\n-\tlibmudflap/12939\n-\t* mf-hooks2.c (semctl): Tolerate FreeBSD.\n-\n-\t* configure.in: Reorganize check for <pthread.h>.\n-\t* configure: Regenerated.\n-\n-2003-11-04  David Edelsohn  <edelsohn@gnu.org>\n-\n-\t* mf-runtime.c (_ALL_SOURCE): Define for AIX.\n-\t(_LARGE_FILE_API): Define for AIX.\n-\t* mf-hooks[123]: Same.\n-\t(_XOPEN_SOURCE_EXTENDED): Define to 1 for AIX.\n-\n-2003-10-21  David Edelsohn  <edelsohn@gnu.org>\n-\n-\t* mf-runtime.c (_XOPEN_SOURCE_EXTENDED): Define to 1 for AIX.\n-\n-2003-07-29  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t2003-07-29  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n-\n-\t* configure.in: Update check for union semun.\n-\n-2003-07-29  Gerald Pfeifer  <pfeifer@dbai.tuwien.ac.at>\n-\n-\tPR other/11673\n-\t* mf-hooks2.c [WRAP_semctl]: Fix check for HAVE_UNION_SEMUN.\n-\n-2003-07-29  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tPR other/11673\n-\t* configure.in: Add checks for 64-bit LFS functions, struct semun\n-\tdefinition, for BSD compatibility.\n-\t* mf-hooks1.c: Respect BSD checks.  Conditionalize POSIX_SOURCE.\n-\t* mf-hooks2.c: Ditto.  Include <strings.h> for bcmp* decls.\n-\t* mf-hooks3.c: Ditto.\n-\t(pthread_create): Try MAP_ANON on platforms without the MAP_ANONYMOUS\n-\tmmap flag.\n-\t* configure, config.h.in: Regenerated.\n-\n-2003-07-23  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tMultithreading fixes:\n-\t* mf-runtime.c (__mf_object): Store allocating/deallocating\n-\tthread id.\n-\t(options): Support new \"-thread-stack\" option.\n-\tRename \"-heur-argv-environ\" option to \"-heur-stdlib\".\n-\tDisable \"-lc-mask\" and \"-lc-shift\" options.\n-\t(__mf_dynamic): Add function pointers for pthread_join/_exit.\n-\t(__assert_fail): New self-contained function for glibc.\n-\t* mf-hooks3.c: Essentially rewritten, particularly related to\n-\tuse of __mf_pthread_info array.\n-\t(pthread_join, _exit): New hook functions.\n-\t* mf-impl.h (BEGIN_PROTECT): Handle starting_p case.\n-\t* testsuite/libmudflap.cth/pass40-frag.c: New test.\n-\n-\tWarning cleanups:\n-\t* mf-heuristics.c: Add type casts for tracing, sub calls.\n-\t* mf-impl.h (BEGIN_PROTECT): Redefine to omit result type.\n-\tUpdate all callers to declare explicit result holder.\n-\t(END_PROTECT): Removed.\n-\t* testsuite/*/*frags.exp: Clean up default MUDFLAP_OPTIONS.\n-\n-2003-07-15  Diego Novillo  <dnovillo@redhat.com>\n-\n-\t* testsuite/libmudflap.c/fail21-frag.c: Add volatile modifiers.\n-\t* testsuite/libmudflap.c/fail15-frag.c: Likewise.\n-\t* testsuite/libmudflap.c/fail13-frag.c: Likewise.\n-\n-2003-07-04  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-hooks1.c, 2.c, 3.c: New file, splits up content from old ...\n-\t* mf-hooks: Removed.\n-\t* mf-impl.h (MF_VALIDATE_EXTENT, BEGIN_PROTECT, END_PROTECT):\n-\tMove these macros from old mf-hooks.c here.\n-\t* Makefile.am: Adapt to split-up hook sources for faster builds.\n-\t* Makefile.in: Regenerated.\n-\n-\t* mf-heuristics.c: Remove #if-0 block.\n-\n-\t* mf-impl.h (__mf_state): Reorganize declaration and implementation.\n-\t(__mf_starting_p): New state only for use while dlsym bootstrapping.\n-\t(CALL_REAL, __mf_init): Corresponding changes.\n-\t(TRACE, VERBOSE_TRACE): Include thread id and \"mf:\" prefix.  Update\n-\tall callers to remove redundant \"mf:\" prefix.\n-\t* mf-runtime.h.in: #define a few reentrancy macros for libmudflapth.\n-\t* mf-hooks3.c: Rewrite chunks to support per-thread __mf_state value.\n-\t(__mf_pthread_info): Become a hash table.\n-\n-\t* testsuite/lib/mfdg.exp: Support new \"dg-timeout\" and\n-\t\"dg-repetitions\" directives to control test case execution.\n-\t* testsuite/libmudflap.cth/pass37-frag.c: Add timeout and repeat\n-\toptions.\n-\t* testsuite/libmudflap.cth/pass39-frag.c: Ditto for this new test.\n-\n-2003-06-25  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-hooks.c (alloca): Separate into stub.\n-\t(__mf_wrap_alloca_indirect): New function.  Use CALL_REAL\n-\tmalloc/free for alloca blocks.\n-\t(pthread_create): Tolerate failing pthread_attr_get* calls.\n-\t* mf-runtime.c (__mf_fini): Call __mf_wrap_alloca_indirect.\n-\t* mf-impl.h (CALL_WRAP): Remove macro.\n-\t* testsuite/libmudflap.c/pass21-frag.c: Include <alloca.h>.\n-\t* testsuite/libmudflap.c/pass23-frag.c: Include more struct\n-\tpadding for ia64 BIT_FIELD_REF constructs.\n-\n-2003-06-19  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-hooks.c (struct pthread_info): Add \"thread_errno\" field.\n-\t(__mf_pthread_spawner, __mf_pthread_cleanup): Use it with GUESS\n-\tlibmudflap object type.\n-\t* mf-runtime.c (__mfu_unregister): Correct cemetary logic to avoid\n-\tcrashes on unregistering STATIC objects.\n-\n-2003-06-17  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tBased on patch from Eyal Lebedinsky <eyal@eyal.emu.id.au>:\n-\t* mf-hooks.c (__mf_pthread_spawner): Register thread errno.\n-\t(time, strerror, fopen, fopen64, fclose, fread): New hooks.\n-\t(fwrite, fgetc, fgets, getc, gets, ungetc, fputc): New hooks.\n-\t(fputs, putc, puts, clearerr, feof, ferror, fileno): New hooks.\n-\t(printf, fprintf, sprintf, snprintf, vprintf, vfprintf): New hooks.\n-\t(vsprintf, vsnprintf, access, remove, fflush, fseek): New hooks.\n-\t(fseeko64, ftell, ftello64, rewind, fgetpos, fsetpos): New hooks.\n-\t(stat, stat64, fstat, lstat, mkfifo, setvbuf, setbuf): New hooks.\n-\t(setvbuf, opendir, closedir, readdir, recv, recvfrom): New hooks.\n-\t(recvmsg, send, sendto, sendmsg, setsockopt, getsockopt): New hooks.\n-\t(accept, bind, connect, gethostname, sethostname): New hooks.\n-\t(gethostbyname, wait, waitpid, popen, pclose, execve): New hooks.\n-\t(execv, execvp, system, dlopen, dlclose, dlerror, dlsym): New hooks.\n-\t(semop, semctl, shmctl, shmat, shmdt): New hooks.\n-\t* mf-runtime.h.in: Corresponding changes.\n-\t* mf-runtime.c (__mf_ini): Register stdio objects.  Use STATIC type.\n-\t(opts) Rename heur_argv_environ\tto heur_std_data.\n-\t(__mf_wrap_main): Use STATIC type for argv/environ strings.\n-\t* Makefile.am: Corresponding changes.\n-\t* Makefile.in: Regenerated.\n-\n-2003-06-11  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-heuristics.c (__mf_heuristic_check): Disable stack_bounds\n-\theuristic for threaded case, and for non-x86-linux targets.\n-\t* mf-hooks.c (__mf_0fn_calloc): Provide a working dummy implementation\n-\tfor use during pre-main() program startup.\n-\t(__mf_0fn_*): Make these functions non-static.\n-\t* mf-impl.h (DECLARE, CALL_REAL): Support calls to 0fn backup hook\n-\tfunctions.\n-\t* mf-runtime.c (__mf_state): Set initial state to \"starting\".\n-\t(__mf_resolve_single_dynamic): Tolerate repeated calls for same symbol.\n-\t(__wrap_main): New function to register argv[] and environ[] strings.\n-\t(__mf_ini): Call it.\n-\t(*): In all trace functions, use \"%p\" as formatter for uintptr_t.\n-\n-\t* testsuite/libmudflap.c/pass38-frag.c: New test case.\n-\t* testsuite/libmudflap.cth/pass37-frag.c: Improved test.\n-\n-\t* acinclude.m4: Add comments with aoliva's concerns about x86_64\n-\tpass_all.\n-\t* aclocal.m4, configure: Regenerated.\n-\n-2003-06-04  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* acinclude.m4: Correct typo in AC_MSG_CHECKING.\n-\t* aclocal.m4, configure: Regenerated.\n-\n-2003-06-03  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* acinclude.m4: Force \"pass_all\" deplibs_check_method for libtool\n-\tfor x86_64 target.  Disable caching for this value.\n-\t* aclocal.m4, configure: Regenerated.\n-\n-2003-06-02  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* testsuite/libmudflap.c/pass38-frag.c: Deleted.  -fwritable-strings\n-\tis about to become deprecated, and its present handling bugs are\n-\tunworthy of fixing.\n-\n-2003-05-30  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* testsuite/libmudflap.c/pass38-frag.c: New test for\n-\t-fwritable-strings.\n-\n-2003-05-23  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-runtime.c (__mf_sigusr1_handle): Call unlocked variant of\n-\t__mf_report, asserting reentrant calling context.\n-\n-2003-05-23  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-hooks.c (realloc): Correct reentrancy logic.\n-\t* testsuite/libmudflap.c/hook-allocstuff.c: New test case.\n-\n-2003-05-20  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-hooks.c (LIBMUDFLAPTH_THREADS_MAX): New macro, replaces\n-\tPTHREAD_THREADS_MAX.  Update users.\n-\t* mf-runtime.c (__mf_usage): Print [active] instead of [default]\n-\tfor active options.\n-\t* testsuite/Makefile.am (all-local): Prime dejagnu site.exp file\n-\twith libmudflapth presence indicator.\n-\t* testsuite/Makefile.in: Regenerated.\n-\n-2003-05-16  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* Makefile.am (AM_CFLAGS): Remove \"-ansi\".\n-\t* configure.in: Remove silly no-pthreads => no-shared logic.\n-\t* Makefile.in, configure: Regenerated.\n-\t* mf-heuristics.c (__mf_heuristic_check): Remove reentrancy hacks.\n-\t* mf-hooks.c (BEGIN_PROTECT, END_PROTECT): Reorganize reentrancy\n-\tcode.  Count reentrancy events.\n-\t(all hook functions): Don't directly manipulate __mf_state variable.\n-\tAdd TRACE calls to hook functions without them.\n-\t* mf-impl.h (LOCKTH): Try to count lock contention events.\n-\t(VERBOSE_TRACE, TRACE): Remove reentrancy hacks.\n-\t* mf-runtime.c (BEGIN_RECURSION_PROTECT, END_RECURSION_PROTECT):\n-\tReorganize reentrancy code.\n-\t(external __mf_ entry points): Use RECURSION_PROTECT mechanism to\n-\tidentify reentrancy with mutex holding times.\n-\t(internal __mfu_ entry points): Remove internal reentrancy code.\n-\t(__mf_init): Use ordinary locked calls.\n-\t(__mfu_report): Print the two new counts.\n-\t* testsuite/lib/libmudflap.exp:\tFilter out junk ld/pthreads messages.\n-\t* testsuite/libmudfap.cth/cthfrags.exp: New test driver.\n-\t* testsuite/libmudflap.cth/pass37-frag.c: New pthreads test.\n-\t* testsuite/libmudfap.cth/cfrags.exp: Adapt to new libmudflap\n-\toption defaults.\n-\n-2003-05-09  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* configure.in: Add pthread support, plus glibc and porting hacks.\n-\t* Makefile.am (LIBMUDFLAPTH): New conditional, to build -lmudflapth\n-\tfrom objects built into ./pth/.\n-\t* mf-runtime.c (__mfu_watch,register,...): Fork new unlocked\n-\tfunctions for internal entry points.  Update callers to pick\n-\tlocked vs. unlocked variants.\n-\t(__mf_resolve_single_dynamic): Extend to support symbol versioning\n-\tinfo coming in from a static data structure.\n-\t(*): Reorder miscellaneous declarations to group data vs functions.\n-\t(__mf_set_default_options): Simplify.\n-\t(__mf_usage): Mention threading status of host executable.\n-\t* mf-impl.h: Move max/min decls here.  Reorganize __mf_dynamic\n-\tdecls to match above.\n-\t(LOCKTH, UNLOCKTH): New macros for Big Libmudflap Lock management.\n-\t* mf-heuristics.c: Choose between locked/unlocked calls.  Add\n-\tsome lock/unlock markers.  Remove some unused code.\n-\t* mf-hooks: Ditto.\n-\t(pthread_create): New hook function.\n-\t(__mf_pthread_cleanup, _spawner): New helper functions.\n-\t* configure. aclocal.m4, config.h.in, Makefile.in: Regenerated.\n-\n-2003-05-02  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* testsuite/libmudflap.c/fail27-frag.c: Add more volatile flags.\n-\n-2002-04-28  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* Makefile.am (HOOKOBJS): Add *time related hooks.\n-\t* configure.in: Look for pthreads.h header.\n-\t* mf-hooks.c (asctime, ctime, gmtime, localtime): New wrappers.\n-\t* mf-runtime.c: Begin sketching some pthreads support.\n-\t(__mf_usage): Check for -lpthread presence.\n-\t(__mf_unregister): Confirm matching unregistration base.\n-\t(__mf_find_objects_rec): Reduce unnecessary recursion.\n-\t* mf-runtime.h.in: Add \"nothrow\" attribute to functions.  Add\n-\t#defines for new hook functions.\n-\t* mf-impl.h: Corresponding changes.\n-\t* config.h.in, configure, Makefile.in: Regenerated.\n-\n-2002-04-27  Diego Novillo  <dnovillo@redhat.com>\n-\n-\t* testsuite/libmudflap.c/fail1-frag.c: Add volatile\n-\tmodifiers to prevent being optimized away.\n-\t* testsuite/libmudflap.c/fail10-frag.c: Likewise.\n-\t* testsuite/libmudflap.c/fail13-frag.c: Likewise.\n-\t* testsuite/libmudflap.c/fail14-frag.c: Likewise.\n-\t* testsuite/libmudflap.c/fail15-frag.c: Likewise.\n-\t* testsuite/libmudflap.c/fail2-frag.c: Likewise.\n-\t* testsuite/libmudflap.c/fail20-frag.c: Likewise.\n-\t* testsuite/libmudflap.c/fail3-frag.c: Likewise.\n-\n-2003-04-15  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* Makefile.am (libmudflap_la_LIBADD): Remove -ldl.\n-\t* configure.in: Look for uintptr_t and -ldl on target.\n-\t* mf-runtime.h.in: Adjust uintptr_t declaration logic.\n-\t* Makefile.in, aclocal.m4, configure, config.h.in: Regenerated.\n-\t* testsuite/Makefile.in: Regenerated.\n-\t* mf-runtime.c (__mf_sigusr1_respond): Tweak declaration and calls\n-\tfor better C compliance.\n-\n-2003-04-15  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-hooks.c (MF_VALIDATE_EXTENT): Remove unnecessary reentrancy\n-\tprevention code.\n-\t* mf-runtime.c (__mf_set_default_options): Turn off\n-\tcheck-initialization.\n-\t(__mf_describe_object): Shorten description.\n-\t* testsuite/libmudflap.c/fail25-frag.c: Turn on check-initialization.\n-\n-2003-04-07  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-hooks.c (__mf_0fn_mmap): Correct return value, as per <rth>.\n-\n-2003-04-02  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-hooks.c (BEGIN_PROTECT): Handle startup-time reentrant\n-\tcalls specially.\n-\t(__mf_0fn_malloc ... _munmap): New dummy backup calls.\n-\t* mf-impl.h (CALL_BACKUP): New macros.\n-\t* mf-runtime.c (__mf_init): Tweak __mf_state during startup.\n-\n-2003-03-31  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* Makefile.am (AM_CFLAGS): Remove optimization flags.\n-\t(HOOKOBJS): Remove dlopen hook.\n-\t(libmudflap_la_LIBADD): Add -ldl.\n-\t* mf-hooks.c (dlopen): Remove hook.\n-\t* mf-impl.h (__mf_dynamic): Ditto.\n-\t* mf-runtime.c (__mf_resolve_dynamics): Ditto.\n-\t* Makefile.in: Regenerated.\n-\n-2003-03-28  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* configure.in: Check for target gettimeofday, signal, some headers.\n-\t* mf-impl.h (__mf_opts): Add new \"sigusr1_report\" field.  Comment\n-\tout inop multi_threaded field.\n-\t* mf-runtime.c (options): Handle new \"-sigusr1-report\" option.\n-\t(__mf_set_options): Correct handling of \"-help\".\n-\t(__mf_sigusr1_respond): New function to manage SIGUSR1 response.\n-\t(__mf_check, __mf_register, __mf_unregister): Call it.\n-\t(__mf_insert_new_object, __mf_unregister): Respect HAVE_GETTIMEOFDAY.\n-\t(__mf_report_leaks): Make callable\n-\t(__mf_tree_analyze): Traverse in-order.  Accumulate address bit\n-\tdistribution statistics.\n-\t(__mf_adapt_cache): Rewrite shift guessing logic based on address\n-\tbit distributions.\n-\t* config.h.in, configure: Regenerated.\n-\t* testsuite/libmudflap.c/fail27-frag.c: New test.\n-\t* testsuite/libmudflap.c/pass36-frag.c: New test.\n-\n-2003-03-11  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-runtime.h.in: Tweak.\n-\t* Makefile.am, configure.in: Tweak mf-runtime.h generation some more.\n-\tDon't use intermediate files nor AC_OUTPUT-time postprocessing.\n-\t* Makefile.in, testsuite/Makefile.in, configure: Regenerated.\n-\n-2003-03-10  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* configure.in: Tweak generation of mf-runtime.h some more.  It\n-\tneeds to work from both config.status and configure.\n-\t* configure: Regenerated.\n-\n-2003-03-10  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* Makefile.am: Reorganize hook file building.  Add auto dependencies.\n-\t* configure.in: Tweak generation of mf-runtime.h.\n-\t* mf-runtime.h.in: Add new __MF_TYPE_HEAP_I.\n-\t* mf-hooks.c (*): Adapt to initialized-heap object type.\n-\t* mf-impl.h: Tweak cemetary boundaries.\n-\t* mf-runtime.c (__mf_check): Adapt to new initialized-heap object\n-\ttype.\n-\t(__mf_insert_new_object, __mf_register, __mf_unregister): Ditto.\n-\t(__mf_describe_object, __mf_report_leaks, __mf_violation): Ditto.\n-\t* testsuite/lib/libmudflap.exp (includes): Include build tree.\n-\t* testsuite/libmudflap.c/pass{26,5}: Further adapt to initialization\n-\tchecking.\n-\t* testsuite/.../fail{25,26}-frag.c: New tests.\n-\t* testsuite/.../pass{32,33,34,35}-frag.c: New tests.\n-\t* Makefile.in, configure: Regenerated.\n-\n-2003-03-05  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-runtime.c (__mf_set_default_options): Turn on initialization\n-\tchecking by default.\n-\t(__mf_insert_new_object): As a temporary hack, assume that new\n-\tobjects registered on the stack start out initialized.\n-\t* testsuite/libmudflap.c/fail9,pass23,pass[6789]-*: Initialize\n-\theap objects by hand.\n-\n-2003-03-05  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tSwitch to macro-style hooks for str*/mem*/b* functions.\n-\t* mf-runtime.h.in (__MF_TYPE_*): Moved some internal values out.\n-\t(mem*, str*, b*): Added macro-style hooks for _MUDFLAP case.\n-\t* mf-runtime.c: #include config.h to enable glibc backtraces again.\n-\t(__mf_set_default_options): Turn off heur_proc_map.\n-\t(*): Adapt to to macro-style hook functions.\n-\t(__mf_object_dead_head, __mf_object_cemetary): Correct bounds.\n-\t(__mf_check, __mf_register, __mf_unregister): Tweak tracing message.\n-\t(__mf_violation): Handle __MF_VIOL_WATCH.\n-\t* mf-impl.h (__MF_TYPE_*): Moved these internal values here.\n-\t(__mf_dynamic): Removed mem*/str*/b* functions.\n-\t(TRACE, VERBOSE_TRACE): Add reentrancy locking.\n-\t(WRAPPER2): New macro for macro-style hooks.\n-\t* mf-hooks.c: Convert mem*/str*/b* functions to simpler\n-\tmacro-style hooks.\n-\t(BEGIN_PROTECT): Tweak tracing vs reentrancy-lock ordering.\n-\t* mf-heuristics.c: Adapt to macro-style hook functions.\n-\tCorrect some comments.\n-\t* testsuite/lib/mfdg.exp (dg-test): Simplify result string for\n-\toutput pattern tests.\n-\t* testsuite/libmudflap.c/fail[89]-frag.c: Elaborate output test.\n-\t* testsuite/libmudflap.c++/c++frags.exp: Enable non-static tests.\n-\n-2003-02-28  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* testsuite/libmudflap.c/fail23-frag.c, pass30-frag.c: New tests\n-\tfor global array registration.\n-\t* testsuite/libmudflap.c++/fail24-frag.cxx, pass31-frag.cxx: Ditto.\n-\t* testsuite/libmudflap.c++/c++frags.exp: Tweak -static multilib hack.\n-\n-2003-02-27  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* Makefile.am: Add gross make bug workarounds.  Tweaked\n-\tSUBDIRS and AM_CFLAGS.\n-\t* Makefile.in: Regenerated.\n-\n-2003-02-26  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tSwitch to dejagnu.\n-\t* configure.in (AC_PROG_CXX): Don't look for C++ any more.\n-\t* Makefile.am (TESTS): Remove simple automake testing.\n-\t* configure, Makefile.in: Regenerated.\n-\t(SUBDIRS): Include new testsuite/ directory.\n-\t* tests/*: Removed all files; moved bulk under:\n-\t* testsuite/*: New subdirectory tree.\n-\t* testsuite/libmudflap.c/cfrags.exp: New file, C test driver.\n-\t* testsuite/libmudflap.c++/c++frags.exp: New file, C++ test driver.\n-\t* testsuite/lib/libmudflap.exp: New file, derived from libstdc++.\n-\t* testsuite/lib/mfdg.exp: New file, derived from dejagnu.\n-\t* testsuite/config/default.exp: New file.\n-\t* testsuite/Makefile.am, Makefile.in: New files.\n-\n-2003-01-29  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* Makefile.am (TESTS_ENVIRONMENT): Remove redundant \"-mode-check\".\n-\t(TESTS): Add fail22 and pass29 tests.\n-\t* mf-runtime.h.in: Change API to take void*/size_t region parameters.\n-\tAdd new access-type parameter for __mf_check.  Move __MF_VIOL* out.\n-\t* mf-impl.h: Corresponding changes.  Update CLAMP* macros for void*\n-\tvalues.  Move __MF_VIOL* here.\n-\t* mf-runtime.c (*): Adapt to void*/size_t API in mf-runtime.h.\n-\t(check_initialization): New field in __mf_opts.  Default off.\n-\t(read_count,write_count): New fields in __mf_object.\n-\t(__mf_check): Implement basic initialization checking.\n-\t(__mf_insert_new_object): Assume STATIC|GUESS regions are initialized.\n-\t(__mf_describe_object): Print new fields.\n-\t(__mf_violation): Identify check/read vs. check/write in messages.\n-\t* test/pass29-frag.c, test/fail22-frag.c: Basic tests for new\n-\t\"-check-initialized\" mudflap option.\n-\t* test/pass25-frag.c, test/fail21-frag.c: Adapt to API changes.\n-\t* mf-hooks.c (MF_VALIDATE_EXTENT): Add new access-type parameter.\n-\tDrop __FILE__/__LINE__ hack.  Update callers.\n-\t(*): Adapt to new mf-runtime.h API.\n-\t* Makefile.in: regenerated.\n-\n-2003-01-24  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* configure.in: Build mf-runtime.h a more proper way.\n-\t* mf-hooks.c (strdup, strndup): Correct reentrancy logic.\n-\t* mf-runtime.c (verbose_violations): Turn on by default.\n-\t* mf-runtime.h.in: Remove some miscellaneous stuff ...\n-\t* mf-impl.h: ... and move it here.\n-\t* configure: Regenerated.\n-\n-2003-01-22  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* configure.in: Look for C++ compiler.\n-\t* test/*-frag.c, mf-driver.c: Reformatted with GNU indent and\n-\tfixed type warnings when built with C++.\n-\t* test/pass27-frag.cxx, pass28-frag.cxx: New C++ tests.\n-\t* Makefile.am (TESTS): Run them.\n-\t(*) Add new rules for building and running C++ tests.\n-\t(TESTFLAGS): Set new default to avoid libstdc++-v3 shlib issues.\n-\t* mf-runtime.h.in: Protect with extern \"C\".\n-\t* Makefile, configure: Regenerated.\n-\n-2003-01-06  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tPortability improvements.\n-\t* configure.in: Look for glibc backtrace headers/functions.\n-\t* mf-hooks.c: Don't include <execinfo.h> any more.\n-\t* mf-runtime.c (__mf_set_options): Call more stdlib functions\n-\tvia CALL_REAL.\n-\t(__mf_backtrace): Provide alternate baby implementation in\n-\tabsence of glibc.\n-\t* test/mf-driver.c: Portability tweaks.\n-\t* acinclude.m4: New file, containing top level libtool.m4.\n-\t* aclocal.m4, configure, Makefile.in, config.h.in: Regenerated.\n-\n-2002-12-19  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-runtime.h.in (HAVE_UINTPTR_T): Define unconditionally.\n-\n-2002-11-08  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-runtime.c (options): Add new \"wipe-heap\", \"wipe-stack\"\n-\toptions.\n-\t(__mf_unregister): Implement stack/heap object wiping.\n-\t(__mf_set_options): Renamed from __mf_process_opts.\n-\t(__mf_uncache_object): Change arg type, correct callers.\n-\t* mf-impl.h: Corresponding changes.\n-\t* mf-hooks.c (realloc): Save/restore heap-wiping flag.\n-\t* mf-runtime.h.in (__mf_set_options): Extend public API.\n-\t* test/pass26-frag.c: New test for stack wiping.\n-\t* Makefile.am (TESTS): Run it.\n-\t* Makefile.in: Regenerated.\n-\n-2002-11-07  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-runtime.h.in (__mf_watch, __mf_unwatch): Extend public API.\n-\t* mf-runtime.c (__mf_object_t): Add watching_p field.\n-\t(__mf_watch_or_not): New function to implement\n-\tobject watch flagging.\n-\t(__mf_watch, __mf_unwatch): New wrappers for above.\n-\t(__mf_check, __mf_describe_object): Handle objects with watching_p.\n-\t(__mf_count_violation): Enlarge array.\n-\t(__mf_uncache_object): Renamed from __mf_remove_old_object.  Don't\n-\tunlink object.  Clear cache properly.\n-\t(__mf_unregister): Unlink object explicitly before uncaching.\n-\t* test/fail21-frag.c, pass25-frag.c: New tests.\n-\t* Makefile.in, aclocal.m4: Regenerated.\n-\n-2002-11-05  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* test/fail20-frag.c: New test for NULL pointer dereferencing.\n-\t* Makefile.am (TESTS): Add it.\n-\t* test/pass-stratcliff.c: Add decls of stpcpy.\n-\t* configure.in: Test for <stdint.h>.  Generate mf-runtime.h in\n-\tbuild tree from config.h and new file mf-runtime.h.in.\n-\t* mf-runtime.h.in: Renamed from mf-runtime.h.  Tweak uintptr_t decl.\n-\t* Makefile.in, configure, config.h.in: Regenerated.\n-\t* mf-hooks.c: Add #undef for wrapped glibc str*/mem* macros.\n-\t* mf-runtime.c (options, __mf_set_default_options): Support new\n-\tdefault \"abbreviate\" option.\n-\t(__mf_object.description_epoch): New field.\n-\t(__mf_describe_object): Conditionally abbreviate objects already\n-\tdisplayed in current epoch.  Accept NULL input to increment epoch.\n-\t(__mf_fini, __mf_ini): Reset description epoch.\n-\t(__mf_register, __mf_unregister, __mf_adapt_cache, __mf_init): Ensure\n-\tthat NULL pointer slot in lookup cache is invalidated.  Register a\n-\tNOACCESS region around NULL.\n-\t* mf-impl.h: Corresponding changes.\n-\n-2002-10-16  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* test/fail19-frag.c, pass24-frag.c, pass-stratcliff.c: New tests.\n-\t* Makefile.am: Run them.  Install mf-runtime.h.\n-\t* Makefile.in: Regenerated.\n-\t* mf-hooks.c: Add some markers for more missing functions.\n-\t* mf-runtime.c (__mf_adapt_cache): Experiment with a utilization-based\n-\tstatistic to tune tune cache size (mask).\n-\n-2002-10-01  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* test/pass23-frag.c: New test for bit_field_ref expressions.\n-\t* Makefile.am, Makefile.in: Add new test.\n-\t* mf-hooks.c (mmap, munmap): Rewrite to track individual pages.\n-\t(MF_VALIDATE_EXTENT): Accept zero-size mem/str operations.\n-\t* mf-runtime.c (__mf_init): Register errno global.\n-\t(__mf_find_object): Removed function.\n-\t(__mf_check): Rewrite logic to support accesses across some\n-\tcontiguous but distinctly registered objects.\n-\t(__mf_remove_old_object): Tolerate cache entries that span\n-\tcontiguous objects.\n-\n-2002-09-30  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* test/pass21-frag.c, pass22-frag.c: New tests: alloca, bitfields.\n-\t* Makefile.am, Makefile.in: Run new tests.\n-\t* mf-hooks.c (alloca): Correct stack direction logic.\n-\n-2002-09-26  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-impl.h (adapt_cache): New option.\n-\t* mf-runtime.c (__mf_set_default_options): Set its default value.\n-\tTweak the tree_aging parameter down.\n-\t(__mf_check): Maintain separate counter for cache-adaptation.\n-\t(__mf_tree_analyze): New function to collect object tree stats.\n-\t(__mf_adapt_cache): New function to automate cache parameters.\n-\n-2002-09-24  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-heuristics.c (__init_misc, __mf_heuristic_check): Add\n-\thypothetical #if-0'd argv/envp region registration.\n-\t* mf-runtime.c (__mf_init): Add kludged form of above.\n-\t(*) Add \"heur_argv_environ\" flag, default on, to govern this.\n-\t* mf-impl.h: Corresponding changes.\n-\n-2002-09-20  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* test/fail18-frag.c: New test file for NOACCESS regions.\n-\t* Makefile.am (TESTS): Add new test.\n-\t* Makefile.in: Regenerated.\n-\n-\t* mf-heuristics.c (__mf_heuristics_check): Correct deja_vu logic.\n-\t* mf-impl.h (tree_aging): Add new mudflap_option, default 1000000.\n-\t(optimize_object_tree): Remove unused mudflap_option.\n-\t* mf-runtime.h (__MF_TYPE_NOACCESS): New region type.  Add printing\n-\tsupport throughout.  Use .._MAX_CEM for cemetary upper bound.\n-\t* mf-runtime.c (__mf_init): Register __mf_* globals as NOACCESS\n-\tregions.\n-\t(__mf_object): Add new liveness field for use by tree aging.\n-\t(__mf_check): Trigger tree aging when needed.\n-\t(__mf_age_tree): New function to decay liveness field.\n-\t(__mf_find_objects_rec): Use liveness field to rotate tree.\n-\t(__mf_insert_new_object): Only provide backtrace for HEAP objects.\n-\t(__mf_unregister): Ditto.\n-\t(__mf_register): Tweak duplicate-static message.\n-\t(__mf_violation: Tweak nearby-object counter printing.\n-\n-2002-09-16  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* test/pass20-frag.c: New test file.\n-\t* Makefile.am (TESTS): Reorganize.  Add pass20 test.\n-\t* Makefile.in: Regenerated.\n-\n-\t* mf-impl.h (TRACE_IN, TRACE_OUT): Remove macros.  Update callers.\n-\t* mf-hooks.c (BEGIN_PROTECT): Add hook tracing here.\n-\t* mf-heuristic.c (__mf_heuristic_check): Track seen /proc/self/map\n-\tentries to avoid repeat registration.\n-\t* mf-runtime.c (__mf_object_cemetary): Don't bother bury GUESS regions.\n-\t(__mf_register, __mf_unregister): Rewrite GUESS handling logic.\n-\n-2002-09-09  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* Makefile.am: Create test sources with #include, not cat>>.\n-\t* Makefile.in: Regenerated.\n-\t* test/buildtest.sh: Removed.\n-\t* test/driver.c (abort_handler, main): Be quiet.\n-\n-2002-09-06  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* test/pass18-frag.c, pass19-frag.c: New tests.\n-\t* Makefile.am (check): Run them.  Rebuild test programs each time.\n-\t* Makefile.in: Regenerated.\n-\n-2002-09-06  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-runtime.c (__mf_register): Correct SEGV-inducing error in\n-\toverlapping object search.\n-\t(__mf_violation): Likewise for nearby objects.\n-\tImprove nearby-object listing.\n-\n-\tcleanup:\n-\t* mf-runtime.c, mf-hooks.c: Remove \"{{{\"/\"}}}\" folding marks.\n-\t* mf-heuristics.c (__mf_heuristic_check): Tweak message.\n-\n-2002-09-03  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\talloca support:\n-\t* Makefile.am (AM_CFLAGS): New definition of needed settings.\n-\t(HOOKOBJS): Add alloca-hook.o.\n-\t* mf-hooks.c (alloca): New function to implement alloca in libiberty\n-\tstyle.\n-\t* mf-runtime.c (__mf_report): Call alloca(0) to flush remaining blocks.\n-\t(__mf_backtrace): Reimplement without using alloca.\n-\t* Makefile.in: Regenerated.\n-\n-\tcleanup:\n-\t* mf-hooks.c: Use VERBOSE_TRACE throughout instead of fprintf(stderr).\n-\tCorrect signedness bugs in length-tracking variables.\n-\t* mf-impl.h: Make options unsigned.\n-\t(CALL_WRAP): New macro to parallel CALL_REAL().\n-\t(DECLARE): Remove erroneous \";\" at end.\n-\t* mf-runtime.c, mf-hooks.c, mf-heuristics.c: Replace remaining %p\n-\tformatting specs with %08lx.  Correct several compiler warnings.\n-\n-2002-08-28  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-runtime.c (__mf_violation): Try harder to locate nearby objects.\n-\n-2002-08-27  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tlibmudflap hook breakup:\n-\t* Makefile.am (TESTS_ENVIRONMENT): Add ../../gcc to LD_LIBRARY_PATH\n-\tfor libgcc_s.\n-\t(TESTS): Make dependent on libmudflap.\n-\t(HOOKOBJS): Break up mf-hooks.o into many little hook objects,\n-\tcompiled from segments of mf-hooks.c.\n-\t* mf-hooks.c: Corresponding changes: wrap each function in\n-\t#ifdef/#endif.\n-\t* Makefile.in: Regenerated.\n-\n-\tHeuristics reorganization:\n-\t* mf-heuristics.c (__mf_register_ro_sections, __mf_init_heuristics):\n-\tRemove these functions.  Update callers.\n-\t(__mf_heuristic_check): Incorporate all the various heuristics.\n-\tEncode cacheability/retry judgement into trinary return value.\n-\tSeparate start-end logic into a separate fallback heuristic.  Only\n-\tregister relevant /proc/self/map segments.\n-\t* mf-impl.h: Corresponding changes.\n-\t* mf-runtime.c (__mf_check): Reorganize heuristics fallback logic.\n-\t(__mf_init): Don't call __mf_init_heuristics.\n-\n-\tTracing cleanup:\n-\t* mf-heuristics.c, mf-runtime.c: Use new MUDFLAP_OPTION\n-\t\"-verbose-trace\" to emit all tracing messages other than those of\n-\tbasic public api.  Eliminate some duplicate/excessive messages.\n-\t* mf-runtime.h: Corresponding changes.\n-\n-2002-08-27  Graydon Hoare  <graydon@redhat.com>\n-\n-\t* mf-impl.h (WRAPPER): Change to create linker aliases for __wrap\n-\tand __real when compiled with -DPIC.\n-\t* mf-hooks.c (WRAPPER): Change all uses of WRAPPER macro slightly.\n-\t* Makefile.am (AUTOMAKE_OPTIONS): Fix LD_LIBRARY_PATH for tests.\n-\t* Makefile.in: Regenerate.\n-\n-2002-08-26  Graydon Hoare  <graydon@redhat.com>\n-\n-\t* mf-impl.h: New file, private implementation header.\n-\t* mf-runtime.h: Reorganize a bit.\n-\t(CLAMPSZ): Fix arithmetic.\n-\t(__MF_CACHE_MISS_P): Fix arithmetic.\n-\t* mf-runtime.c: Reorganize a bit.\n-\t(__mf_dynamic): New structure.\n-\t(resolve_single_dynamic): New function.\n-\t(__mf_resolve_dynamics): New function.\n-\t(__mf_init): Initialize dynamic wrappers.\n-\t* mf-hooks.c: Macro-ize __real calls.\n-\tClamp various bits of arithmetic.\n-\tAdd explicit __mf_check call contexts.\n-\t* Makefile.am: Add dependencies on mf-impl.h\n-\t* Makefile.in: Regenerate.\n-\t* configure.in: Comment out shared override.\n-\t* configure: Regenerate.\n-\n-2002-08-22  Graydon Hoare  <graydon@redhat.com>\n-\n-\t* mf-runtime.c (__mf_process_opts): Sanity-check free_queue_length.\n-\t(__mf_check): Re-inialize and check heuristics before violation.\n-\t(__mf_register): Permit updating pure-guess regions.\n-\t* mf-hooks.c (__wrap_free): Correct some free queue logic.\n-\t(__wrap_dlopen): New wrapper function.\n-\t(__wrap_mmap): New wrapper function.\n-\t(__wrap_munmap): New wrapper function.\n-\t* mf-heuristics.c (__mf_register_ro_sections): Register *all* regions\n-\twhich are not stack addresses.\n-\t(is_stack_address): New function.\n-\t(__mf_init_heuristics): Save and restore state, always initialize with\n-\t\"starting\" state.\n-\n-2002-08-21  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-hooks.c (MF_VALIDATE_EXTENT): Rewrite to correct off-by-one\n-\terror.  Pass location string.\n-\t(wrap_strcpy, wrap_strncpy): Remove extra %s in trace strings.\n-\t* mf-runtime.c (options): Add lc-mask, lc-shift options.\n-\t(__mf_process_opts): Apply some sanity checking for lc-mask.\n-\t(__mf_check, __mf_violation): Take new location-string argument.\n-\tUpdate callers to pass NULL if necessary.\n-\t(__mf_backtrace): New smart backtracer function.  Calls replace\n-\tseveral ad-hoc blocks elsewhere.\n-\t(__mf_describe_object): Remove bad reentrancy test.  Improve\n-\ttracing message.\n-\t* mf-runtime.h: Corresponding changes.  Public/private markup.\n-\t(__MF_CACHE_MISS_P): New macro.\n-\n-2002-08-20  Graydon Hoare  <graydon@redhat.com>\n-\n-\t* mf-runtime.h: New option: stack_bound (heuristic).\n-\tMove some macros out of implementation files.\n-\t* mf-runtime.c: New option string: -stack-bound.\n-\tUnify recursion protection with hooks.\n-\tAdd more logging.\n-\t(__mf_check): Call __mf_heuristic_check.\n-\t(__mf_process_opts): Fix \"no-\" processing.\n-\t* mf-heuristics.c (__mf_heuristic_check): New function.\n-\t* mf-hooks.c: Much off-by-one fixing, recursion protection.\n-\n-2002-08-20  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\tOption parsing improvements, region splitting bug fixes:\n-\t* mf-heuristics.c (__mf_register_ro_sections): Add warned casts.\n-\t* mf-runtime.h (heur_proc_map): New libmudflap option.\n-\t* mf-runtime.c (__mf_set_default_options): Set it.\n-\t(__mf_usage): Print default values/status.\n-\t(__mf_process_opts): Support general \"no-\" option string prefix.\n-\t(__mf_init): Print __mf_usage on unknown-option error.\n-\t(__mf_register): Print trace message up front.\n-\tCorrect region splitting logic for case where a subregion disappears.\n-\tCorrect memory leak.\n-\t(__mf_violation): Make even basic message conditional on option.\n-\n-\tBuild cleanup:\n-\t* Makefile.am (TESTS_ENVIRONMENT): Add -no-heur-proc-map.\n-\t(clean-local): New target.\n-\t(test/*x rules): Add -g CFLAGS.\n-\t(CFLAGS): Add -freorder-blocks.\n-\t(MFCONFIG_CFLAGS, INCLUDE): Remove unneeded settings.\n-\t* Makefile.in: Regenerated.\n-\t* Makefile, mf-config.h: Removed files.\n-\n-2002-08-16  Graydon Hoare  <graydon@redhat.com>\n-\n-\t* mf-runtime.c (__mf_insert_new_object): Factor out of\n-\t__mf_register.\n-\t(__mf_remove_old_object): Factor out of __mf_unregister.\n-\t(__mf_register): Handle guessed regions, splitting\n-\tguesses when new registrations arrive.\n-\t(__mf_unregister): Do not unregister guesses.\n-\t* mf-runtime.h: Move convenience macros around,\n-\tdeclare new option fields. Add __MF_TYPE_GUESS.\n-\t* mf-hooks.c (__wrap_*alloc): Use crumple zones.\n-\t(__wrap_free): Call __real_free for deferred frees.\n-\t* Makefile.am: Add more tests, fix dependency.\n-\t* Makefile.in: Regenerate.\n-\t* test/pass[13..17]-frag.c: New testcases.\n-\t* test/fail[13..17]-frag.c: New testcases.\n-\n-2002-08-15  Graydon Hoare  <graydon@redhat.com>\n-\n-\t* mf-heuristics.c: New file.\n-\t* mf-runtime.c (options): Add -trace-calls option.\n-\t(__mf_init): Call __mf_init_heuristics.\n-\n-2002-08-14  Graydon Hoare  <graydon@redhat.com>\n-\n-\t* Makefile.am (TESTS): Add testsuite support.\n-\t* Makefile.in: Regenerate.\n-\t* test/mf-driver.c: New file.\n-\t* test/buildtest.sh: New file.\n-\t* test/passNN-frag.c: New testcases.\n-\t* test/failNN-frag.c: New testcases.\n-\n-2002-08-14  Graydon Hoare  <graydon@redhat.com>\n-\n-\t* mf-hooks.c: Change __real_strlen() to __real_strlen()+1 when\n-\tverifying non-size-limited string extents.\n-\n-2002-08-14  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-hooks.c: Make __wrap string* functions use __real_str[n]len\n-\tinstead of plain str[n]len for internal checks.\n-\t* mf-runtime.c (__mf_violation): Print optional stack traceback.\n-\n-2002-08-14  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* mf-hooks.c: Remove #if-0 around hooks that are now ld-wrapped.\n-\n-2002-08-13  Graydon Hoare  <graydon@redhat.com>\n-\n-\t* mf-runtime.c: Rework configuration to operate on\n-\tenvironment variable options rather than #defines\n-\t(__mf_violation): Add simple fork-a-gdb violaiton mode.\n-\t(__mf_init): Set static __mf_active_p flag on startup,\n-\tto inhibit mudflap wrap-based checking during crt0.s.\n-\t* mf-runtime.h: Declare options structure.\n-\t* mf-hooks.c: New wrappings for mem*, b*, str*\n-\tlibc functions (temporarily #if 0-ed out).\n-\n-2002-08-12  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* Makefile.am, configure.in: New files.\n-\t* Makefile.in, Makefile, configure, config.h.in: New generated files.\n-\t* stamp-h.in, aclocal.m4: Ditto.\n-\n-2002-08-08  Frank Ch. Eigler  <fche@redhat.com>\n-\n-\t* Makefile: New file.\n-\t* mf-config.h: New file: runtime configuration.\n-\t* mf-hooks.c: New file: interposed libc functions.\n-\t* mf-runtime.c: New file: bulk of runtime.\n-\t* mf-runtime.h: New file: public functions."}, {"sha": "40a70aead9b84da1543ce0326d8b88ba28877d9a", "filename": "libmudflap/Makefile.am", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2FMakefile.am?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,97 +0,0 @@\n-## Makefile for the toplevel directory of the mudflap library.\n-##\n-## Copyright (C) 2002-2013 Free Software Foundation, Inc.\n-##\n-\n-AUTOMAKE_OPTIONS = 1.8 foreign\n-ACLOCAL_AMFLAGS = -I .. -I ../config\n-MAINT_CHARSET = latin1\n-SUBDIRS = testsuite\n-\n-# May be used by various substitution variables.\n-gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n-\n-SECTION_FLAGS = @SECTION_FLAGS@\n-AM_CFLAGS = -Wall $(SECTION_FLAGS)\n-\n-if LIBMUDFLAPTH\n-libmudflapth = libmudflapth.la\n-else\n-libmudflapth =\n-endif\n-\n-toolexeclib_LTLIBRARIES = libmudflap.la $(libmudflapth)\n-target_noncanonical = @target_noncanonical@\n-libsubincludedir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version)/include\n-nobase_libsubinclude_HEADERS = mf-runtime.h\n-\n-\n-libmudflap_la_SOURCES = \\\n-\tmf-runtime.c \\\n-\tmf-heuristics.c \\\n-\tmf-hooks1.c \\\n-\tmf-hooks2.c\n-libmudflap_la_LIBADD = \n-libmudflap_la_DEPENDENCIES = $(libmudflap_la_LIBADD)\n-libmudflap_la_LDFLAGS = -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n-\n-\n-libmudflapth_la_SOURCES = \\\n-\tmf-runtime.c \\\n-\tmf-heuristics.c \\\n-\tmf-hooks1.c \\\n-\tmf-hooks2.c \\\n-\tmf-hooks3.c\n-libmudflapth_la_CFLAGS = -DLIBMUDFLAPTH\n-libmudflapth_la_LIBADD =\n-libmudflapth_la_DEPENDENCIES = $(libmudflapth_la_LIBADD)\n-libmudflapth_la_LDFLAGS = -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n-\n-\n-# XXX hack alert\n-# From libffi/Makefile.am\n-\n-# Work around what appears to be a GNU make bug handling MAKEFLAGS\n-# values defined in terms of make variables, as is the case for CC and\n-# friends when we are called from the top level Makefile.\n-AM_MAKEFLAGS = \\\n-\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n-\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n-\t\"CFLAGS=$(CFLAGS)\" \\\n-\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n-\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n-\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n-\t\"INSTALL=$(INSTALL)\" \\\n-\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n-\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n-\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n-\t\"JC1FLAGS=$(JC1FLAGS)\" \\\n-\t\"LDFLAGS=$(LDFLAGS)\" \\\n-\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\"MAKE=$(MAKE)\" \\\n-\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n-\t\"PICFLAG=$(PICFLAG)\" \\\n-\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n-\t\"SHELL=$(SHELL)\" \\\n-\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n-\t\"exec_prefix=$(exec_prefix)\" \\\n-\t\"infodir=$(infodir)\" \\\n-\t\"libdir=$(libdir)\" \\\n-\t\"prefix=$(prefix)\" \\\n-\t\"includedir=$(includedir)\" \\\n-\t\"AR=$(AR)\" \\\n-\t\"AS=$(AS)\" \\\n-\t\"CC=$(CC)\" \\\n-\t\"CXX=$(CXX)\" \\\n-\t\"LD=$(LD)\" \\\n-\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-\t\"NM=$(NM)\" \\\n-\t\"PICFLAG=$(PICFLAG)\" \\\n-\t\"RANLIB=$(RANLIB)\" \\\n-\t\"DESTDIR=$(DESTDIR)\"\n-\n-MAKEOVERRIDES=\n-\n-## ################################################################\n-"}, {"sha": "ae342cf80738d95ef3e3e0fccf3fb1b701b83a40", "filename": "libmudflap/Makefile.in", "status": "removed", "additions": 0, "deletions": 822, "changes": 822, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2FMakefile.in?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,822 +0,0 @@\n-# Makefile.in generated by automake 1.11.1 from Makefile.am.\n-# @configure_input@\n-\n-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n-# Inc.\n-# This Makefile.in is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-@SET_MAKE@\n-\n-\n-VPATH = @srcdir@\n-pkgdatadir = $(datadir)/@PACKAGE@\n-pkgincludedir = $(includedir)/@PACKAGE@\n-pkglibdir = $(libdir)/@PACKAGE@\n-pkglibexecdir = $(libexecdir)/@PACKAGE@\n-am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n-install_sh_DATA = $(install_sh) -c -m 644\n-install_sh_PROGRAM = $(install_sh) -c\n-install_sh_SCRIPT = $(install_sh) -c\n-INSTALL_HEADER = $(INSTALL_DATA)\n-transform = $(program_transform_name)\n-NORMAL_INSTALL = :\n-PRE_INSTALL = :\n-POST_INSTALL = :\n-NORMAL_UNINSTALL = :\n-PRE_UNINSTALL = :\n-POST_UNINSTALL = :\n-build_triplet = @build@\n-host_triplet = @host@\n-target_triplet = @target@\n-subdir = .\n-DIST_COMMON = ChangeLog $(srcdir)/Makefile.in $(srcdir)/Makefile.am \\\n-\t$(top_srcdir)/configure $(am__configure_deps) \\\n-\t$(srcdir)/config.h.in $(srcdir)/../mkinstalldirs \\\n-\t$(srcdir)/../depcomp $(nobase_libsubinclude_HEADERS)\n-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n-am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n-\t$(top_srcdir)/../config/depstand.m4 \\\n-\t$(top_srcdir)/../config/enable.m4 \\\n-\t$(top_srcdir)/../config/lead-dot.m4 \\\n-\t$(top_srcdir)/../config/multi.m4 \\\n-\t$(top_srcdir)/../config/override.m4 \\\n-\t$(top_srcdir)/../config/tls.m4 $(top_srcdir)/../ltoptions.m4 \\\n-\t$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \\\n-\t$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/acinclude.m4 \\\n-\t$(top_srcdir)/../libtool.m4 $(top_srcdir)/configure.ac\n-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n-\t$(ACLOCAL_M4)\n-am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \\\n- configure.lineno config.status.lineno\n-mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n-CONFIG_HEADER = config.h\n-CONFIG_CLEAN_FILES =\n-CONFIG_CLEAN_VPATH_FILES =\n-am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n-am__vpath_adj = case $$p in \\\n-    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n-    *) f=$$p;; \\\n-  esac;\n-am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;\n-am__install_max = 40\n-am__nobase_strip_setup = \\\n-  srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*|]/\\\\\\\\&/g'`\n-am__nobase_strip = \\\n-  for p in $$list; do echo \"$$p\"; done | sed -e \"s|$$srcdirstrip/||\"\n-am__nobase_list = $(am__nobase_strip_setup); \\\n-  for p in $$list; do echo \"$$p $$p\"; done | \\\n-  sed \"s| $$srcdirstrip/| |;\"' / .*\\//!s/ .*/ ./; s,\\( .*\\)/[^/]*$$,\\1,' | \\\n-  $(AWK) 'BEGIN { files[\".\"] = \"\" } { files[$$2] = files[$$2] \" \" $$1; \\\n-    if (++n[$$2] == $(am__install_max)) \\\n-      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = \"\" } } \\\n-    END { for (dir in files) print dir, files[dir] }'\n-am__base_list = \\\n-  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n-  sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n-am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n-\t\"$(DESTDIR)$(libsubincludedir)\"\n-LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n-am_libmudflap_la_OBJECTS = mf-runtime.lo mf-heuristics.lo mf-hooks1.lo \\\n-\tmf-hooks2.lo\n-libmudflap_la_OBJECTS = $(am_libmudflap_la_OBJECTS)\n-libmudflap_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\\n-\t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \\\n-\t$(libmudflap_la_LDFLAGS) $(LDFLAGS) -o $@\n-am_libmudflapth_la_OBJECTS = libmudflapth_la-mf-runtime.lo \\\n-\tlibmudflapth_la-mf-heuristics.lo libmudflapth_la-mf-hooks1.lo \\\n-\tlibmudflapth_la-mf-hooks2.lo libmudflapth_la-mf-hooks3.lo\n-libmudflapth_la_OBJECTS = $(am_libmudflapth_la_OBJECTS)\n-libmudflapth_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\\n-\t$(LIBTOOLFLAGS) --mode=link $(CCLD) $(libmudflapth_la_CFLAGS) \\\n-\t$(CFLAGS) $(libmudflapth_la_LDFLAGS) $(LDFLAGS) -o $@\n-@LIBMUDFLAPTH_TRUE@am_libmudflapth_la_rpath = -rpath $(toolexeclibdir)\n-DEFAULT_INCLUDES = -I.@am__isrc@\n-depcomp = $(SHELL) $(top_srcdir)/../depcomp\n-am__depfiles_maybe = depfiles\n-am__mv = mv -f\n-COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n-\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n-LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n-\t--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n-\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n-CCLD = $(CC)\n-LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n-\t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n-\t$(LDFLAGS) -o $@\n-SOURCES = $(libmudflap_la_SOURCES) $(libmudflapth_la_SOURCES)\n-MULTISRCTOP = \n-MULTIBUILDTOP = \n-MULTIDIRS = \n-MULTISUBDIR = \n-MULTIDO = true\n-MULTICLEAN = true\n-RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \\\n-\thtml-recursive info-recursive install-data-recursive \\\n-\tinstall-dvi-recursive install-exec-recursive \\\n-\tinstall-html-recursive install-info-recursive \\\n-\tinstall-pdf-recursive install-ps-recursive install-recursive \\\n-\tinstallcheck-recursive installdirs-recursive pdf-recursive \\\n-\tps-recursive uninstall-recursive\n-HEADERS = $(nobase_libsubinclude_HEADERS)\n-RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n-  distclean-recursive maintainer-clean-recursive\n-AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n-\t$(RECURSIVE_CLEAN_TARGETS:-recursive=) tags TAGS ctags CTAGS\n-ETAGS = etags\n-CTAGS = ctags\n-DIST_SUBDIRS = $(SUBDIRS)\n-ACLOCAL = @ACLOCAL@\n-AMTAR = @AMTAR@\n-AR = @AR@\n-AUTOCONF = @AUTOCONF@\n-AUTOHEADER = @AUTOHEADER@\n-AUTOMAKE = @AUTOMAKE@\n-AWK = @AWK@\n-CC = @CC@\n-CCDEPMODE = @CCDEPMODE@\n-CFLAGS = @CFLAGS@\n-CPP = @CPP@\n-CPPFLAGS = @CPPFLAGS@\n-CYGPATH_W = @CYGPATH_W@\n-DEFS = @DEFS@\n-DEPDIR = @DEPDIR@\n-DSYMUTIL = @DSYMUTIL@\n-DUMPBIN = @DUMPBIN@\n-ECHO_C = @ECHO_C@\n-ECHO_N = @ECHO_N@\n-ECHO_T = @ECHO_T@\n-EGREP = @EGREP@\n-EXEEXT = @EXEEXT@\n-FGREP = @FGREP@\n-GREP = @GREP@\n-INSTALL = @INSTALL@\n-INSTALL_DATA = @INSTALL_DATA@\n-INSTALL_PROGRAM = @INSTALL_PROGRAM@\n-INSTALL_SCRIPT = @INSTALL_SCRIPT@\n-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n-LD = @LD@\n-LDFLAGS = @LDFLAGS@\n-LIBOBJS = @LIBOBJS@\n-LIBS = @LIBS@\n-LIBTOOL = @LIBTOOL@\n-LIPO = @LIPO@\n-LN_S = @LN_S@\n-LTLIBOBJS = @LTLIBOBJS@\n-MAINT = @MAINT@\n-MAKEINFO = @MAKEINFO@\n-MF_HAVE_STDINT_H = @MF_HAVE_STDINT_H@\n-MF_HAVE_UINTPTR_T = @MF_HAVE_UINTPTR_T@\n-MKDIR_P = @MKDIR_P@\n-NM = @NM@\n-NMEDIT = @NMEDIT@\n-OBJDUMP = @OBJDUMP@\n-OBJEXT = @OBJEXT@\n-OTOOL = @OTOOL@\n-OTOOL64 = @OTOOL64@\n-PACKAGE = @PACKAGE@\n-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n-PACKAGE_NAME = @PACKAGE_NAME@\n-PACKAGE_STRING = @PACKAGE_STRING@\n-PACKAGE_TARNAME = @PACKAGE_TARNAME@\n-PACKAGE_URL = @PACKAGE_URL@\n-PACKAGE_VERSION = @PACKAGE_VERSION@\n-PATH_SEPARATOR = @PATH_SEPARATOR@\n-RANLIB = @RANLIB@\n-SECTION_FLAGS = @SECTION_FLAGS@\n-SED = @SED@\n-SET_MAKE = @SET_MAKE@\n-SHELL = @SHELL@\n-STRIP = @STRIP@\n-VERSION = @VERSION@\n-abs_builddir = @abs_builddir@\n-abs_srcdir = @abs_srcdir@\n-abs_top_builddir = @abs_top_builddir@\n-abs_top_srcdir = @abs_top_srcdir@\n-ac_ct_CC = @ac_ct_CC@\n-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n-am__include = @am__include@\n-am__leading_dot = @am__leading_dot@\n-am__quote = @am__quote@\n-am__tar = @am__tar@\n-am__untar = @am__untar@\n-bindir = @bindir@\n-build = @build@\n-build_alias = @build_alias@\n-build_cpu = @build_cpu@\n-build_libmudflapth = @build_libmudflapth@\n-build_os = @build_os@\n-build_vendor = @build_vendor@\n-builddir = @builddir@\n-datadir = @datadir@\n-datarootdir = @datarootdir@\n-docdir = @docdir@\n-dvidir = @dvidir@\n-enable_shared = @enable_shared@\n-enable_static = @enable_static@\n-exec_prefix = @exec_prefix@\n-host = @host@\n-host_alias = @host_alias@\n-host_cpu = @host_cpu@\n-host_os = @host_os@\n-host_vendor = @host_vendor@\n-htmldir = @htmldir@\n-includedir = @includedir@\n-infodir = @infodir@\n-install_sh = @install_sh@\n-libdir = @libdir@\n-libexecdir = @libexecdir@\n-localedir = @localedir@\n-localstatedir = @localstatedir@\n-mandir = @mandir@\n-mkdir_p = @mkdir_p@\n-multi_basedir = @multi_basedir@\n-oldincludedir = @oldincludedir@\n-pdfdir = @pdfdir@\n-prefix = @prefix@\n-program_transform_name = @program_transform_name@\n-psdir = @psdir@\n-sbindir = @sbindir@\n-sharedstatedir = @sharedstatedir@\n-srcdir = @srcdir@\n-sysconfdir = @sysconfdir@\n-target = @target@\n-target_alias = @target_alias@\n-target_cpu = @target_cpu@\n-target_noncanonical = @target_noncanonical@\n-target_os = @target_os@\n-target_vendor = @target_vendor@\n-toolexecdir = @toolexecdir@\n-toolexeclibdir = @toolexeclibdir@\n-top_build_prefix = @top_build_prefix@\n-top_builddir = @top_builddir@\n-top_srcdir = @top_srcdir@\n-AUTOMAKE_OPTIONS = 1.8 foreign\n-ACLOCAL_AMFLAGS = -I .. -I ../config\n-MAINT_CHARSET = latin1\n-SUBDIRS = testsuite\n-\n-# May be used by various substitution variables.\n-gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)\n-AM_CFLAGS = -Wall $(SECTION_FLAGS)\n-@LIBMUDFLAPTH_FALSE@libmudflapth = \n-@LIBMUDFLAPTH_TRUE@libmudflapth = libmudflapth.la\n-toolexeclib_LTLIBRARIES = libmudflap.la $(libmudflapth)\n-libsubincludedir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version)/include\n-nobase_libsubinclude_HEADERS = mf-runtime.h\n-libmudflap_la_SOURCES = \\\n-\tmf-runtime.c \\\n-\tmf-heuristics.c \\\n-\tmf-hooks1.c \\\n-\tmf-hooks2.c\n-\n-libmudflap_la_LIBADD = \n-libmudflap_la_DEPENDENCIES = $(libmudflap_la_LIBADD)\n-libmudflap_la_LDFLAGS = -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n-libmudflapth_la_SOURCES = \\\n-\tmf-runtime.c \\\n-\tmf-heuristics.c \\\n-\tmf-hooks1.c \\\n-\tmf-hooks2.c \\\n-\tmf-hooks3.c\n-\n-libmudflapth_la_CFLAGS = -DLIBMUDFLAPTH\n-libmudflapth_la_LIBADD = \n-libmudflapth_la_DEPENDENCIES = $(libmudflapth_la_LIBADD)\n-libmudflapth_la_LDFLAGS = -version-info `grep -v '^\\#' $(srcdir)/libtool-version`\n-\n-# XXX hack alert\n-# From libffi/Makefile.am\n-\n-# Work around what appears to be a GNU make bug handling MAKEFLAGS\n-# values defined in terms of make variables, as is the case for CC and\n-# friends when we are called from the top level Makefile.\n-AM_MAKEFLAGS = \\\n-\t\"AR_FLAGS=$(AR_FLAGS)\" \\\n-\t\"CC_FOR_BUILD=$(CC_FOR_BUILD)\" \\\n-\t\"CFLAGS=$(CFLAGS)\" \\\n-\t\"CXXFLAGS=$(CXXFLAGS)\" \\\n-\t\"CFLAGS_FOR_BUILD=$(CFLAGS_FOR_BUILD)\" \\\n-\t\"CFLAGS_FOR_TARGET=$(CFLAGS_FOR_TARGET)\" \\\n-\t\"INSTALL=$(INSTALL)\" \\\n-\t\"INSTALL_DATA=$(INSTALL_DATA)\" \\\n-\t\"INSTALL_PROGRAM=$(INSTALL_PROGRAM)\" \\\n-\t\"INSTALL_SCRIPT=$(INSTALL_SCRIPT)\" \\\n-\t\"JC1FLAGS=$(JC1FLAGS)\" \\\n-\t\"LDFLAGS=$(LDFLAGS)\" \\\n-\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-\t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n-\t\"MAKE=$(MAKE)\" \\\n-\t\"MAKEINFO=$(MAKEINFO) $(MAKEINFOFLAGS)\" \\\n-\t\"PICFLAG=$(PICFLAG)\" \\\n-\t\"PICFLAG_FOR_TARGET=$(PICFLAG_FOR_TARGET)\" \\\n-\t\"SHELL=$(SHELL)\" \\\n-\t\"RUNTESTFLAGS=$(RUNTESTFLAGS)\" \\\n-\t\"exec_prefix=$(exec_prefix)\" \\\n-\t\"infodir=$(infodir)\" \\\n-\t\"libdir=$(libdir)\" \\\n-\t\"prefix=$(prefix)\" \\\n-\t\"includedir=$(includedir)\" \\\n-\t\"AR=$(AR)\" \\\n-\t\"AS=$(AS)\" \\\n-\t\"CC=$(CC)\" \\\n-\t\"CXX=$(CXX)\" \\\n-\t\"LD=$(LD)\" \\\n-\t\"LIBCFLAGS=$(LIBCFLAGS)\" \\\n-\t\"NM=$(NM)\" \\\n-\t\"PICFLAG=$(PICFLAG)\" \\\n-\t\"RANLIB=$(RANLIB)\" \\\n-\t\"DESTDIR=$(DESTDIR)\"\n-\n-MAKEOVERRIDES = \n-all: config.h\n-\t$(MAKE) $(AM_MAKEFLAGS) all-recursive\n-\n-.SUFFIXES:\n-.SUFFIXES: .c .lo .o .obj\n-am--refresh:\n-\t@:\n-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n-\t@for dep in $?; do \\\n-\t  case '$(am__configure_deps)' in \\\n-\t    *$$dep*) \\\n-\t      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \\\n-\t      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \\\n-\t\t&& exit 0; \\\n-\t      exit 1;; \\\n-\t  esac; \\\n-\tdone; \\\n-\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \\\n-\t$(am__cd) $(top_srcdir) && \\\n-\t  $(AUTOMAKE) --foreign Makefile\n-.PRECIOUS: Makefile\n-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n-\t@case '$?' in \\\n-\t  *config.status*) \\\n-\t    echo ' $(SHELL) ./config.status'; \\\n-\t    $(SHELL) ./config.status;; \\\n-\t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__depfiles_maybe);; \\\n-\tesac;\n-\n-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n-\t$(SHELL) ./config.status --recheck\n-\n-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n-\t$(am__cd) $(srcdir) && $(AUTOCONF)\n-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n-\t$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)\n-$(am__aclocal_m4_deps):\n-\n-config.h: stamp-h1\n-\t@if test ! -f $@; then \\\n-\t  rm -f stamp-h1; \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \\\n-\telse :; fi\n-\n-stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status\n-\t@rm -f stamp-h1\n-\tcd $(top_builddir) && $(SHELL) ./config.status config.h\n-$(srcdir)/config.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps) \n-\t($(am__cd) $(top_srcdir) && $(AUTOHEADER))\n-\trm -f stamp-h1\n-\ttouch $@\n-\n-distclean-hdr:\n-\t-rm -f config.h stamp-h1\n-install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)\n-\t@$(NORMAL_INSTALL)\n-\ttest -z \"$(toolexeclibdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\"\n-\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n-\tlist2=; for p in $$list; do \\\n-\t  if test -f $$p; then \\\n-\t    list2=\"$$list2 $$p\"; \\\n-\t  else :; fi; \\\n-\tdone; \\\n-\ttest -z \"$$list2\" || { \\\n-\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(toolexeclibdir)'\"; \\\n-\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 \"$(DESTDIR)$(toolexeclibdir)\"; \\\n-\t}\n-\n-uninstall-toolexeclibLTLIBRARIES:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(toolexeclib_LTLIBRARIES)'; test -n \"$(toolexeclibdir)\" || list=; \\\n-\tfor p in $$list; do \\\n-\t  $(am__strip_dir) \\\n-\t  echo \" $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(toolexeclibdir)/$$f'\"; \\\n-\t  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f \"$(DESTDIR)$(toolexeclibdir)/$$f\"; \\\n-\tdone\n-\n-clean-toolexeclibLTLIBRARIES:\n-\t-test -z \"$(toolexeclib_LTLIBRARIES)\" || rm -f $(toolexeclib_LTLIBRARIES)\n-\t@list='$(toolexeclib_LTLIBRARIES)'; for p in $$list; do \\\n-\t  dir=\"`echo $$p | sed -e 's|/[^/]*$$||'`\"; \\\n-\t  test \"$$dir\" != \"$$p\" || dir=.; \\\n-\t  echo \"rm -f \\\"$${dir}/so_locations\\\"\"; \\\n-\t  rm -f \"$${dir}/so_locations\"; \\\n-\tdone\n-libmudflap.la: $(libmudflap_la_OBJECTS) $(libmudflap_la_DEPENDENCIES) \n-\t$(libmudflap_la_LINK) -rpath $(toolexeclibdir) $(libmudflap_la_OBJECTS) $(libmudflap_la_LIBADD) $(LIBS)\n-libmudflapth.la: $(libmudflapth_la_OBJECTS) $(libmudflapth_la_DEPENDENCIES) \n-\t$(libmudflapth_la_LINK) $(am_libmudflapth_la_rpath) $(libmudflapth_la_OBJECTS) $(libmudflapth_la_LIBADD) $(LIBS)\n-\n-mostlyclean-compile:\n-\t-rm -f *.$(OBJEXT)\n-\n-distclean-compile:\n-\t-rm -f *.tab.c\n-\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmudflapth_la-mf-heuristics.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmudflapth_la-mf-hooks1.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmudflapth_la-mf-hooks2.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmudflapth_la-mf-hooks3.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmudflapth_la-mf-runtime.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mf-heuristics.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mf-hooks1.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mf-hooks2.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mf-runtime.Plo@am__quote@\n-\n-.c.o:\n-@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(COMPILE) -c $<\n-\n-.c.obj:\n-@am__fastdepCC_TRUE@\t$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(COMPILE) -c `$(CYGPATH_W) '$<'`\n-\n-.c.lo:\n-@am__fastdepCC_TRUE@\t$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LTCOMPILE) -c -o $@ $<\n-\n-libmudflapth_la-mf-runtime.lo: mf-runtime.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmudflapth_la_CFLAGS) $(CFLAGS) -MT libmudflapth_la-mf-runtime.lo -MD -MP -MF $(DEPDIR)/libmudflapth_la-mf-runtime.Tpo -c -o libmudflapth_la-mf-runtime.lo `test -f 'mf-runtime.c' || echo '$(srcdir)/'`mf-runtime.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/libmudflapth_la-mf-runtime.Tpo $(DEPDIR)/libmudflapth_la-mf-runtime.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='mf-runtime.c' object='libmudflapth_la-mf-runtime.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmudflapth_la_CFLAGS) $(CFLAGS) -c -o libmudflapth_la-mf-runtime.lo `test -f 'mf-runtime.c' || echo '$(srcdir)/'`mf-runtime.c\n-\n-libmudflapth_la-mf-heuristics.lo: mf-heuristics.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmudflapth_la_CFLAGS) $(CFLAGS) -MT libmudflapth_la-mf-heuristics.lo -MD -MP -MF $(DEPDIR)/libmudflapth_la-mf-heuristics.Tpo -c -o libmudflapth_la-mf-heuristics.lo `test -f 'mf-heuristics.c' || echo '$(srcdir)/'`mf-heuristics.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/libmudflapth_la-mf-heuristics.Tpo $(DEPDIR)/libmudflapth_la-mf-heuristics.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='mf-heuristics.c' object='libmudflapth_la-mf-heuristics.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmudflapth_la_CFLAGS) $(CFLAGS) -c -o libmudflapth_la-mf-heuristics.lo `test -f 'mf-heuristics.c' || echo '$(srcdir)/'`mf-heuristics.c\n-\n-libmudflapth_la-mf-hooks1.lo: mf-hooks1.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmudflapth_la_CFLAGS) $(CFLAGS) -MT libmudflapth_la-mf-hooks1.lo -MD -MP -MF $(DEPDIR)/libmudflapth_la-mf-hooks1.Tpo -c -o libmudflapth_la-mf-hooks1.lo `test -f 'mf-hooks1.c' || echo '$(srcdir)/'`mf-hooks1.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/libmudflapth_la-mf-hooks1.Tpo $(DEPDIR)/libmudflapth_la-mf-hooks1.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='mf-hooks1.c' object='libmudflapth_la-mf-hooks1.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmudflapth_la_CFLAGS) $(CFLAGS) -c -o libmudflapth_la-mf-hooks1.lo `test -f 'mf-hooks1.c' || echo '$(srcdir)/'`mf-hooks1.c\n-\n-libmudflapth_la-mf-hooks2.lo: mf-hooks2.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmudflapth_la_CFLAGS) $(CFLAGS) -MT libmudflapth_la-mf-hooks2.lo -MD -MP -MF $(DEPDIR)/libmudflapth_la-mf-hooks2.Tpo -c -o libmudflapth_la-mf-hooks2.lo `test -f 'mf-hooks2.c' || echo '$(srcdir)/'`mf-hooks2.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/libmudflapth_la-mf-hooks2.Tpo $(DEPDIR)/libmudflapth_la-mf-hooks2.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='mf-hooks2.c' object='libmudflapth_la-mf-hooks2.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmudflapth_la_CFLAGS) $(CFLAGS) -c -o libmudflapth_la-mf-hooks2.lo `test -f 'mf-hooks2.c' || echo '$(srcdir)/'`mf-hooks2.c\n-\n-libmudflapth_la-mf-hooks3.lo: mf-hooks3.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmudflapth_la_CFLAGS) $(CFLAGS) -MT libmudflapth_la-mf-hooks3.lo -MD -MP -MF $(DEPDIR)/libmudflapth_la-mf-hooks3.Tpo -c -o libmudflapth_la-mf-hooks3.lo `test -f 'mf-hooks3.c' || echo '$(srcdir)/'`mf-hooks3.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/libmudflapth_la-mf-hooks3.Tpo $(DEPDIR)/libmudflapth_la-mf-hooks3.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='mf-hooks3.c' object='libmudflapth_la-mf-hooks3.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmudflapth_la_CFLAGS) $(CFLAGS) -c -o libmudflapth_la-mf-hooks3.lo `test -f 'mf-hooks3.c' || echo '$(srcdir)/'`mf-hooks3.c\n-\n-mostlyclean-libtool:\n-\t-rm -f *.lo\n-\n-clean-libtool:\n-\t-rm -rf .libs _libs\n-\n-distclean-libtool:\n-\t-rm -f libtool config.lt\n-\n-# GNU Make needs to see an explicit $(MAKE) variable in the command it\n-# runs to enable its job server during parallel builds.  Hence the\n-# comments below.\n-all-multi:\n-\t$(MULTIDO) $(AM_MAKEFLAGS) DO=all multi-do # $(MAKE)\n-install-multi:\n-\t$(MULTIDO) $(AM_MAKEFLAGS) DO=install multi-do # $(MAKE)\n-\n-mostlyclean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=mostlyclean multi-clean # $(MAKE)\n-clean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=clean multi-clean # $(MAKE)\n-distclean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=distclean multi-clean # $(MAKE)\n-maintainer-clean-multi:\n-\t$(MULTICLEAN) $(AM_MAKEFLAGS) DO=maintainer-clean multi-clean # $(MAKE)\n-install-nobase_libsubincludeHEADERS: $(nobase_libsubinclude_HEADERS)\n-\t@$(NORMAL_INSTALL)\n-\ttest -z \"$(libsubincludedir)\" || $(MKDIR_P) \"$(DESTDIR)$(libsubincludedir)\"\n-\t@list='$(nobase_libsubinclude_HEADERS)'; test -n \"$(libsubincludedir)\" || list=; \\\n-\t$(am__nobase_list) | while read dir files; do \\\n-\t  xfiles=; for file in $$files; do \\\n-\t    if test -f \"$$file\"; then xfiles=\"$$xfiles $$file\"; \\\n-\t    else xfiles=\"$$xfiles $(srcdir)/$$file\"; fi; done; \\\n-\t  test -z \"$$xfiles\" || { \\\n-\t    test \"x$$dir\" = x. || { \\\n-\t      echo \"$(MKDIR_P) '$(DESTDIR)$(libsubincludedir)/$$dir'\"; \\\n-\t      $(MKDIR_P) \"$(DESTDIR)$(libsubincludedir)/$$dir\"; }; \\\n-\t    echo \" $(INSTALL_HEADER) $$xfiles '$(DESTDIR)$(libsubincludedir)/$$dir'\"; \\\n-\t    $(INSTALL_HEADER) $$xfiles \"$(DESTDIR)$(libsubincludedir)/$$dir\" || exit $$?; }; \\\n-\tdone\n-\n-uninstall-nobase_libsubincludeHEADERS:\n-\t@$(NORMAL_UNINSTALL)\n-\t@list='$(nobase_libsubinclude_HEADERS)'; test -n \"$(libsubincludedir)\" || list=; \\\n-\t$(am__nobase_strip_setup); files=`$(am__nobase_strip)`; \\\n-\ttest -n \"$$files\" || exit 0; \\\n-\techo \" ( cd '$(DESTDIR)$(libsubincludedir)' && rm -f\" $$files \")\"; \\\n-\tcd \"$(DESTDIR)$(libsubincludedir)\" && rm -f $$files\n-\n-# This directory's subdirectories are mostly independent; you can cd\n-# into them and run `make' without going through this Makefile.\n-# To change the values of `make' variables: instead of editing Makefiles,\n-# (1) if the variable is set in `config.status', edit `config.status'\n-#     (which will cause the Makefiles to be regenerated when you run `make');\n-# (2) otherwise, pass the desired values on the `make' command line.\n-$(RECURSIVE_TARGETS):\n-\t@fail= failcom='exit 1'; \\\n-\tfor f in x $$MAKEFLAGS; do \\\n-\t  case $$f in \\\n-\t    *=* | --[!k]*);; \\\n-\t    *k*) failcom='fail=yes';; \\\n-\t  esac; \\\n-\tdone; \\\n-\tdot_seen=no; \\\n-\ttarget=`echo $@ | sed s/-recursive//`; \\\n-\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n-\t  echo \"Making $$target in $$subdir\"; \\\n-\t  if test \"$$subdir\" = \".\"; then \\\n-\t    dot_seen=yes; \\\n-\t    local_target=\"$$target-am\"; \\\n-\t  else \\\n-\t    local_target=\"$$target\"; \\\n-\t  fi; \\\n-\t  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n-\t  || eval $$failcom; \\\n-\tdone; \\\n-\tif test \"$$dot_seen\" = \"no\"; then \\\n-\t  $(MAKE) $(AM_MAKEFLAGS) \"$$target-am\" || exit 1; \\\n-\tfi; test -z \"$$fail\"\n-\n-$(RECURSIVE_CLEAN_TARGETS):\n-\t@fail= failcom='exit 1'; \\\n-\tfor f in x $$MAKEFLAGS; do \\\n-\t  case $$f in \\\n-\t    *=* | --[!k]*);; \\\n-\t    *k*) failcom='fail=yes';; \\\n-\t  esac; \\\n-\tdone; \\\n-\tdot_seen=no; \\\n-\tcase \"$@\" in \\\n-\t  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \\\n-\t  *) list='$(SUBDIRS)' ;; \\\n-\tesac; \\\n-\trev=''; for subdir in $$list; do \\\n-\t  if test \"$$subdir\" = \".\"; then :; else \\\n-\t    rev=\"$$subdir $$rev\"; \\\n-\t  fi; \\\n-\tdone; \\\n-\trev=\"$$rev .\"; \\\n-\ttarget=`echo $@ | sed s/-recursive//`; \\\n-\tfor subdir in $$rev; do \\\n-\t  echo \"Making $$target in $$subdir\"; \\\n-\t  if test \"$$subdir\" = \".\"; then \\\n-\t    local_target=\"$$target-am\"; \\\n-\t  else \\\n-\t    local_target=\"$$target\"; \\\n-\t  fi; \\\n-\t  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n-\t  || eval $$failcom; \\\n-\tdone && test -z \"$$fail\"\n-tags-recursive:\n-\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n-\t  test \"$$subdir\" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \\\n-\tdone\n-ctags-recursive:\n-\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n-\t  test \"$$subdir\" = . || ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \\\n-\tdone\n-\n-ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n-\tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n-\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n-\tmkid -fID $$unique\n-tags: TAGS\n-\n-TAGS: tags-recursive $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \\\n-\t\t$(TAGS_FILES) $(LISP)\n-\tset x; \\\n-\there=`pwd`; \\\n-\tif ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \\\n-\t  include_option=--etags-include; \\\n-\t  empty_fix=.; \\\n-\telse \\\n-\t  include_option=--include; \\\n-\t  empty_fix=; \\\n-\tfi; \\\n-\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n-\t  if test \"$$subdir\" = .; then :; else \\\n-\t    test ! -f $$subdir/TAGS || \\\n-\t      set \"$$@\" \"$$include_option=$$here/$$subdir/TAGS\"; \\\n-\t  fi; \\\n-\tdone; \\\n-\tlist='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n-\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n-\tshift; \\\n-\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n-\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n-\t  if test $$# -gt 0; then \\\n-\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n-\t      \"$$@\" $$unique; \\\n-\t  else \\\n-\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n-\t      $$unique; \\\n-\t  fi; \\\n-\tfi\n-ctags: CTAGS\n-CTAGS: ctags-recursive $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \\\n-\t\t$(TAGS_FILES) $(LISP)\n-\tlist='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \\\n-\tunique=`for i in $$list; do \\\n-\t    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n-\t  done | \\\n-\t  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \\\n-\t      END { if (nonempty) { for (i in files) print i; }; }'`; \\\n-\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n-\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n-\t     $$unique\n-\n-GTAGS:\n-\there=`$(am__cd) $(top_builddir) && pwd` \\\n-\t  && $(am__cd) $(top_srcdir) \\\n-\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\n-\n-distclean-tags:\n-\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n-check-am: all-am\n-check: check-recursive\n-all-am: Makefile $(LTLIBRARIES) all-multi $(HEADERS) config.h\n-installdirs: installdirs-recursive\n-installdirs-am:\n-\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(libsubincludedir)\"; do \\\n-\t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n-\tdone\n-install: install-recursive\n-install-exec: install-exec-recursive\n-install-data: install-data-recursive\n-uninstall: uninstall-recursive\n-\n-install-am: all-am\n-\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n-\n-installcheck: installcheck-recursive\n-install-strip:\n-\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t  `test -z '$(STRIP)' || \\\n-\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n-mostlyclean-generic:\n-\n-clean-generic:\n-\n-distclean-generic:\n-\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n-\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n-\n-maintainer-clean-generic:\n-\t@echo \"This command is intended for maintainers to use\"\n-\t@echo \"it deletes files that may require special tools to rebuild.\"\n-clean: clean-multi clean-recursive\n-\n-clean-am: clean-generic clean-libtool clean-toolexeclibLTLIBRARIES \\\n-\tmostlyclean-am\n-\n-distclean: distclean-multi distclean-recursive\n-\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf ./$(DEPDIR)\n-\t-rm -f Makefile\n-distclean-am: clean-am distclean-compile distclean-generic \\\n-\tdistclean-hdr distclean-libtool distclean-tags\n-\n-dvi: dvi-recursive\n-\n-dvi-am:\n-\n-html: html-recursive\n-\n-html-am:\n-\n-info: info-recursive\n-\n-info-am:\n-\n-install-data-am: install-nobase_libsubincludeHEADERS\n-\n-install-dvi: install-dvi-recursive\n-\n-install-dvi-am:\n-\n-install-exec-am: install-multi install-toolexeclibLTLIBRARIES\n-\n-install-html: install-html-recursive\n-\n-install-html-am:\n-\n-install-info: install-info-recursive\n-\n-install-info-am:\n-\n-install-man:\n-\n-install-pdf: install-pdf-recursive\n-\n-install-pdf-am:\n-\n-install-ps: install-ps-recursive\n-\n-install-ps-am:\n-\n-installcheck-am:\n-\n-maintainer-clean: maintainer-clean-multi maintainer-clean-recursive\n-\t-rm -f $(am__CONFIG_DISTCLEAN_FILES)\n-\t-rm -rf $(top_srcdir)/autom4te.cache\n-\t-rm -rf ./$(DEPDIR)\n-\t-rm -f Makefile\n-maintainer-clean-am: distclean-am maintainer-clean-generic\n-\n-mostlyclean: mostlyclean-multi mostlyclean-recursive\n-\n-mostlyclean-am: mostlyclean-compile mostlyclean-generic \\\n-\tmostlyclean-libtool\n-\n-pdf: pdf-recursive\n-\n-pdf-am:\n-\n-ps: ps-recursive\n-\n-ps-am:\n-\n-uninstall-am: uninstall-nobase_libsubincludeHEADERS \\\n-\tuninstall-toolexeclibLTLIBRARIES\n-\n-.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) all all-multi \\\n-\tclean-multi ctags-recursive distclean-multi install-am \\\n-\tinstall-multi install-strip maintainer-clean-multi \\\n-\tmostlyclean-multi tags-recursive\n-\n-.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \\\n-\tall all-am all-multi am--refresh check check-am clean \\\n-\tclean-generic clean-libtool clean-multi \\\n-\tclean-toolexeclibLTLIBRARIES ctags ctags-recursive distclean \\\n-\tdistclean-compile distclean-generic distclean-hdr \\\n-\tdistclean-libtool distclean-multi distclean-tags dvi dvi-am \\\n-\thtml html-am info info-am install install-am install-data \\\n-\tinstall-data-am install-dvi install-dvi-am install-exec \\\n-\tinstall-exec-am install-html install-html-am install-info \\\n-\tinstall-info-am install-man install-multi \\\n-\tinstall-nobase_libsubincludeHEADERS install-pdf install-pdf-am \\\n-\tinstall-ps install-ps-am install-strip \\\n-\tinstall-toolexeclibLTLIBRARIES installcheck installcheck-am \\\n-\tinstalldirs installdirs-am maintainer-clean \\\n-\tmaintainer-clean-generic maintainer-clean-multi mostlyclean \\\n-\tmostlyclean-compile mostlyclean-generic mostlyclean-libtool \\\n-\tmostlyclean-multi pdf pdf-am ps ps-am tags tags-recursive \\\n-\tuninstall uninstall-am uninstall-nobase_libsubincludeHEADERS \\\n-\tuninstall-toolexeclibLTLIBRARIES\n-\n-\n-# Tell versions [3.59,3.63) of GNU make to not export all variables.\n-# Otherwise a system limit (for SysV at least) may be exceeded.\n-.NOEXPORT:"}, {"sha": "38e0808ad933ea3560b68635887ffadc4f9ec6a3", "filename": "libmudflap/acinclude.m4", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Facinclude.m4?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,12 +0,0 @@\n-dnl ----------------------------------------------------------------------\n-dnl This whole bit snagged from libgfortran.\n-\n-sinclude(../libtool.m4)\n-dnl The lines below arrange for aclocal not to bring an installed\n-dnl libtool.m4 into aclocal.m4, while still arranging for automake to\n-dnl add a definition of LIBTOOL to Makefile.in.\n-ifelse(,,,[AC_SUBST(LIBTOOL)\n-AC_DEFUN([AM_PROG_LIBTOOL])\n-AC_DEFUN([AC_LIBTOOL_DLOPEN])\n-AC_DEFUN([AC_PROG_LD])\n-])"}, {"sha": "b62d573c1103234a4c346d5e3409101cf28acf5a", "filename": "libmudflap/aclocal.m4", "status": "removed", "additions": 0, "deletions": 982, "changes": 982, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Faclocal.m4?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,982 +0,0 @@\n-# generated automatically by aclocal 1.11.1 -*- Autoconf -*-\n-\n-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-# 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-m4_ifndef([AC_AUTOCONF_VERSION],\n-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n-m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.64],,\n-[m4_warning([this file was generated for autoconf 2.64.\n-You have another version of autoconf.  It may work, but is not guaranteed to.\n-If you have problems, you may need to regenerate the build system entirely.\n-To do so, use the procedure documented by the package, typically `autoreconf'.])])\n-\n-# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_AUTOMAKE_VERSION(VERSION)\n-# ----------------------------\n-# Automake X.Y traces this macro to ensure aclocal.m4 has been\n-# generated from the m4 files accompanying Automake X.Y.\n-# (This private macro should not be called outside this file.)\n-AC_DEFUN([AM_AUTOMAKE_VERSION],\n-[am__api_version='1.11'\n-dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\n-dnl require some minimum version.  Point them to the right macro.\n-m4_if([$1], [1.11.1], [],\n-      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n-])\n-\n-# _AM_AUTOCONF_VERSION(VERSION)\n-# -----------------------------\n-# aclocal traces this macro to find the Autoconf version.\n-# This is a private macro too.  Using m4_define simplifies\n-# the logic in aclocal, which can simply ignore this definition.\n-m4_define([_AM_AUTOCONF_VERSION], [])\n-\n-# AM_SET_CURRENT_AUTOMAKE_VERSION\n-# -------------------------------\n-# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n-# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\n-AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n-[AM_AUTOMAKE_VERSION([1.11.1])dnl\n-m4_ifndef([AC_AUTOCONF_VERSION],\n-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n-_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n-\n-# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n-\n-# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n-# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to\n-# `$srcdir', `$srcdir/..', or `$srcdir/../..'.\n-#\n-# Of course, Automake must honor this variable whenever it calls a\n-# tool from the auxiliary directory.  The problem is that $srcdir (and\n-# therefore $ac_aux_dir as well) can be either absolute or relative,\n-# depending on how configure is run.  This is pretty annoying, since\n-# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n-# source directory, any form will work fine, but in subdirectories a\n-# relative path needs to be adjusted first.\n-#\n-# $ac_aux_dir/missing\n-#    fails when called from a subdirectory if $ac_aux_dir is relative\n-# $top_srcdir/$ac_aux_dir/missing\n-#    fails if $ac_aux_dir is absolute,\n-#    fails when called from a subdirectory in a VPATH build with\n-#          a relative $ac_aux_dir\n-#\n-# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n-# are both prefixed by $srcdir.  In an in-source build this is usually\n-# harmless because $srcdir is `.', but things will broke when you\n-# start a VPATH build or use an absolute $srcdir.\n-#\n-# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n-# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n-#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n-# and then we would define $MISSING as\n-#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n-# This will work as long as MISSING is not called from configure, because\n-# unfortunately $(top_srcdir) has no meaning in configure.\n-# However there are other variables, like CC, which are often used in\n-# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n-#\n-# Another solution, used here, is to always expand $ac_aux_dir to an\n-# absolute PATH.  The drawback is that using absolute paths prevent a\n-# configured tree to be moved without reconfiguration.\n-\n-AC_DEFUN([AM_AUX_DIR_EXPAND],\n-[dnl Rely on autoconf to set up CDPATH properly.\n-AC_PREREQ([2.50])dnl\n-# expand $ac_aux_dir to an absolute path\n-am_aux_dir=`cd $ac_aux_dir && pwd`\n-])\n-\n-# AM_CONDITIONAL                                            -*- Autoconf -*-\n-\n-# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 9\n-\n-# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n-# -------------------------------------\n-# Define a conditional.\n-AC_DEFUN([AM_CONDITIONAL],\n-[AC_PREREQ(2.52)dnl\n- ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n-\t[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\n-AC_SUBST([$1_TRUE])dnl\n-AC_SUBST([$1_FALSE])dnl\n-_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n-_AM_SUBST_NOTMAKE([$1_FALSE])dnl\n-m4_define([_AM_COND_VALUE_$1], [$2])dnl\n-if $2; then\n-  $1_TRUE=\n-  $1_FALSE='#'\n-else\n-  $1_TRUE='#'\n-  $1_FALSE=\n-fi\n-AC_CONFIG_COMMANDS_PRE(\n-[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n-  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n-Usually this means the macro was only invoked conditionally.]])\n-fi])])\n-\n-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 10\n-\n-# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be\n-# written in clear, in which case automake, when reading aclocal.m4,\n-# will think it sees a *use*, and therefore will trigger all it's\n-# C support machinery.  Also note that it means that autoscan, seeing\n-# CC etc. in the Makefile, will ask for an AC_PROG_CC use...\n-\n-\n-# _AM_DEPENDENCIES(NAME)\n-# ----------------------\n-# See how the compiler implements dependency checking.\n-# NAME is \"CC\", \"CXX\", \"GCJ\", or \"OBJC\".\n-# We try a few techniques and use that to set a single cache variable.\n-#\n-# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was\n-# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular\n-# dependency, and given that the user is not expected to run this macro,\n-# just rely on AC_PROG_CC.\n-AC_DEFUN([_AM_DEPENDENCIES],\n-[AC_REQUIRE([AM_SET_DEPDIR])dnl\n-AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl\n-AC_REQUIRE([AM_MAKE_INCLUDE])dnl\n-AC_REQUIRE([AM_DEP_TRACK])dnl\n-\n-ifelse([$1], CC,   [depcc=\"$CC\"   am_compiler_list=],\n-       [$1], CXX,  [depcc=\"$CXX\"  am_compiler_list=],\n-       [$1], OBJC, [depcc=\"$OBJC\" am_compiler_list='gcc3 gcc'],\n-       [$1], UPC,  [depcc=\"$UPC\"  am_compiler_list=],\n-       [$1], GCJ,  [depcc=\"$GCJ\"  am_compiler_list='gcc3 gcc'],\n-                   [depcc=\"$$1\"   am_compiler_list=])\n-\n-AC_CACHE_CHECK([dependency style of $depcc],\n-               [am_cv_$1_dependencies_compiler_type],\n-[if test -z \"$AMDEP_TRUE\" && test -f \"$am_depcomp\"; then\n-  # We make a subdir and do the tests there.  Otherwise we can end up\n-  # making bogus files that we don't know about and never remove.  For\n-  # instance it was reported that on HP-UX the gcc test will end up\n-  # making a dummy file named `D' -- because `-MD' means `put the output\n-  # in D'.\n-  mkdir conftest.dir\n-  # Copy depcomp to subdir because otherwise we won't find it if we're\n-  # using a relative directory.\n-  cp \"$am_depcomp\" conftest.dir\n-  cd conftest.dir\n-  # We will build objects and dependencies in a subdirectory because\n-  # it helps to detect inapplicable dependency modes.  For instance\n-  # both Tru64's cc and ICC support -MD to output dependencies as a\n-  # side effect of compilation, but ICC will put the dependencies in\n-  # the current directory while Tru64 will put them in the object\n-  # directory.\n-  mkdir sub\n-\n-  am_cv_$1_dependencies_compiler_type=none\n-  if test \"$am_compiler_list\" = \"\"; then\n-     am_compiler_list=`sed -n ['s/^#*\\([a-zA-Z0-9]*\\))$/\\1/p'] < ./depcomp`\n-  fi\n-  am__universal=false\n-  m4_case([$1], [CC],\n-    [case \" $depcc \" in #(\n-     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n-     esac],\n-    [CXX],\n-    [case \" $depcc \" in #(\n-     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n-     esac])\n-\n-  for depmode in $am_compiler_list; do\n-    # Setup a source with many dependencies, because some compilers\n-    # like to wrap large dependency lists on column 80 (with \\), and\n-    # we should not choose a depcomp mode which is confused by this.\n-    #\n-    # We need to recreate these files for each test, as the compiler may\n-    # overwrite some of them when testing with obscure command lines.\n-    # This happens at least with the AIX C compiler.\n-    : > sub/conftest.c\n-    for i in 1 2 3 4 5 6; do\n-      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with\n-      # Solaris 8's {/usr,}/bin/sh.\n-      touch sub/conftst$i.h\n-    done\n-    echo \"${am__include} ${am__quote}sub/conftest.Po${am__quote}\" > confmf\n-\n-    # We check with `-c' and `-o' for the sake of the \"dashmstdout\"\n-    # mode.  It turns out that the SunPro C++ compiler does not properly\n-    # handle `-M -o', and we need to detect this.  Also, some Intel\n-    # versions had trouble with output in subdirs\n-    am__obj=sub/conftest.${OBJEXT-o}\n-    am__minus_obj=\"-o $am__obj\"\n-    case $depmode in\n-    gcc)\n-      # This depmode causes a compiler race in universal mode.\n-      test \"$am__universal\" = false || continue\n-      ;;\n-    nosideeffect)\n-      # after this tag, mechanisms are not by side-effect, so they'll\n-      # only be used when explicitly requested\n-      if test \"x$enable_dependency_tracking\" = xyes; then\n-\tcontinue\n-      else\n-\tbreak\n-      fi\n-      ;;\n-    msvisualcpp | msvcmsys)\n-      # This compiler won't grok `-c -o', but also, the minuso test has\n-      # not run yet.  These depmodes are late enough in the game, and\n-      # so weak that their functioning should not be impacted.\n-      am__obj=conftest.${OBJEXT-o}\n-      am__minus_obj=\n-      ;;\n-    none) break ;;\n-    esac\n-    if depmode=$depmode \\\n-       source=sub/conftest.c object=$am__obj \\\n-       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n-       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \\\n-         >/dev/null 2>conftest.err &&\n-       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&\n-       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&\n-       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&\n-       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then\n-      # icc doesn't choke on unknown options, it will just issue warnings\n-      # or remarks (even with -Werror).  So we grep stderr for any message\n-      # that says an option was ignored or not supported.\n-      # When given -MP, icc 7.0 and 7.1 complain thusly:\n-      #   icc: Command line warning: ignoring option '-M'; no argument required\n-      # The diagnosis changed in icc 8.0:\n-      #   icc: Command line remark: option '-MP' not supported\n-      if (grep 'ignoring option' conftest.err ||\n-          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n-        am_cv_$1_dependencies_compiler_type=$depmode\n-        break\n-      fi\n-    fi\n-  done\n-\n-  cd ..\n-  rm -rf conftest.dir\n-else\n-  am_cv_$1_dependencies_compiler_type=none\n-fi\n-])\n-AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])\n-AM_CONDITIONAL([am__fastdep$1], [\n-  test \"x$enable_dependency_tracking\" != xno \\\n-  && test \"$am_cv_$1_dependencies_compiler_type\" = gcc3])\n-])\n-\n-\n-# AM_SET_DEPDIR\n-# -------------\n-# Choose a directory name for dependency files.\n-# This macro is AC_REQUIREd in _AM_DEPENDENCIES\n-AC_DEFUN([AM_SET_DEPDIR],\n-[AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n-AC_SUBST([DEPDIR], [\"${am__leading_dot}deps\"])dnl\n-])\n-\n-\n-# AM_DEP_TRACK\n-# ------------\n-AC_DEFUN([AM_DEP_TRACK],\n-[AC_ARG_ENABLE(dependency-tracking,\n-[  --disable-dependency-tracking  speeds up one-time build\n-  --enable-dependency-tracking   do not reject slow dependency extractors])\n-if test \"x$enable_dependency_tracking\" != xno; then\n-  am_depcomp=\"$ac_aux_dir/depcomp\"\n-  AMDEPBACKSLASH='\\'\n-fi\n-AM_CONDITIONAL([AMDEP], [test \"x$enable_dependency_tracking\" != xno])\n-AC_SUBST([AMDEPBACKSLASH])dnl\n-_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl\n-])\n-\n-# Generate code to set up dependency tracking.              -*- Autoconf -*-\n-\n-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-#serial 5\n-\n-# _AM_OUTPUT_DEPENDENCY_COMMANDS\n-# ------------------------------\n-AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n-[{\n-  # Autoconf 2.62 quotes --file arguments for eval, but not when files\n-  # are listed without --file.  Let's play safe and only enable the eval\n-  # if we detect the quoting.\n-  case $CONFIG_FILES in\n-  *\\'*) eval set x \"$CONFIG_FILES\" ;;\n-  *)   set x $CONFIG_FILES ;;\n-  esac\n-  shift\n-  for mf\n-  do\n-    # Strip MF so we end up with the name of the file.\n-    mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n-    # Check whether this is an Automake generated Makefile or not.\n-    # We used to match only the files named `Makefile.in', but\n-    # some people rename them; so instead we look at the file content.\n-    # Grep'ing the first line is not enough: some people post-process\n-    # each Makefile.in and add a new line on top of each file to say so.\n-    # Grep'ing the whole file is not good either: AIX grep has a line\n-    # limit of 2048, but all sed's we know have understand at least 4000.\n-    if sed -n 's,^#.*generated by automake.*,X,p' \"$mf\" | grep X >/dev/null 2>&1; then\n-      dirpart=`AS_DIRNAME(\"$mf\")`\n-    else\n-      continue\n-    fi\n-    # Extract the definition of DEPDIR, am__include, and am__quote\n-    # from the Makefile without running `make'.\n-    DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n-    test -z \"$DEPDIR\" && continue\n-    am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n-    test -z \"am__include\" && continue\n-    am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n-    # When using ansi2knr, U may be empty or an underscore; expand it\n-    U=`sed -n 's/^U = //p' < \"$mf\"`\n-    # Find all dependency output files, they are included files with\n-    # $(DEPDIR) in their names.  We invoke sed twice because it is the\n-    # simplest approach to changing $(DEPDIR) to its actual value in the\n-    # expansion.\n-    for file in `sed -n \"\n-      s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n-\t sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g' -e 's/\\$U/'\"$U\"'/g'`; do\n-      # Make sure the directory exists.\n-      test -f \"$dirpart/$file\" && continue\n-      fdir=`AS_DIRNAME([\"$file\"])`\n-      AS_MKDIR_P([$dirpart/$fdir])\n-      # echo \"creating $dirpart/$file\"\n-      echo '# dummy' > \"$dirpart/$file\"\n-    done\n-  done\n-}\n-])# _AM_OUTPUT_DEPENDENCY_COMMANDS\n-\n-\n-# AM_OUTPUT_DEPENDENCY_COMMANDS\n-# -----------------------------\n-# This macro should only be invoked once -- use via AC_REQUIRE.\n-#\n-# This code is only required when automatic dependency tracking\n-# is enabled.  FIXME.  This creates each `.P' file that we will\n-# need in order to bootstrap the dependency handling code.\n-AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n-[AC_CONFIG_COMMANDS([depfiles],\n-     [test x\"$AMDEP_TRUE\" != x\"\" || _AM_OUTPUT_DEPENDENCY_COMMANDS],\n-     [AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"])\n-])\n-\n-# Do all the work for Automake.                             -*- Autoconf -*-\n-\n-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n-# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 16\n-\n-# This macro actually does too much.  Some checks are only needed if\n-# your package does certain things.  But this isn't really a big deal.\n-\n-# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n-# AM_INIT_AUTOMAKE([OPTIONS])\n-# -----------------------------------------------\n-# The call with PACKAGE and VERSION arguments is the old style\n-# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n-# and VERSION should now be passed to AC_INIT and removed from\n-# the call to AM_INIT_AUTOMAKE.\n-# We support both call styles for the transition.  After\n-# the next Automake release, Autoconf can make the AC_INIT\n-# arguments mandatory, and then we can depend on a new Autoconf\n-# release and drop the old call support.\n-AC_DEFUN([AM_INIT_AUTOMAKE],\n-[AC_PREREQ([2.62])dnl\n-dnl Autoconf wants to disallow AM_ names.  We explicitly allow\n-dnl the ones we care about.\n-m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\n-AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\n-AC_REQUIRE([AC_PROG_INSTALL])dnl\n-if test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n-  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n-  # is not polluted with repeated \"-I.\"\n-  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl\n-  # test to see if srcdir already configured\n-  if test -f $srcdir/config.status; then\n-    AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n-  fi\n-fi\n-\n-# test whether we have cygpath\n-if test -z \"$CYGPATH_W\"; then\n-  if (cygpath --version) >/dev/null 2>/dev/null; then\n-    CYGPATH_W='cygpath -w'\n-  else\n-    CYGPATH_W=echo\n-  fi\n-fi\n-AC_SUBST([CYGPATH_W])\n-\n-# Define the identity of the package.\n-dnl Distinguish between old-style and new-style calls.\n-m4_ifval([$2],\n-[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n- AC_SUBST([PACKAGE], [$1])dnl\n- AC_SUBST([VERSION], [$2])],\n-[_AM_SET_OPTIONS([$1])dnl\n-dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.\n-m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,\n-  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl\n- AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n- AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n-\n-_AM_IF_OPTION([no-define],,\n-[AC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\", [Name of package])\n- AC_DEFINE_UNQUOTED(VERSION, \"$VERSION\", [Version number of package])])dnl\n-\n-# Some tools Automake needs.\n-AC_REQUIRE([AM_SANITY_CHECK])dnl\n-AC_REQUIRE([AC_ARG_PROGRAM])dnl\n-AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})\n-AM_MISSING_PROG(AUTOCONF, autoconf)\n-AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})\n-AM_MISSING_PROG(AUTOHEADER, autoheader)\n-AM_MISSING_PROG(MAKEINFO, makeinfo)\n-AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n-AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\n-AC_REQUIRE([AM_PROG_MKDIR_P])dnl\n-# We need awk for the \"check\" target.  The system \"awk\" is bad on\n-# some platforms.\n-AC_REQUIRE([AC_PROG_AWK])dnl\n-AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n-AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n-_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n-\t      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n-\t\t\t     [_AM_PROG_TAR([v7])])])\n-_AM_IF_OPTION([no-dependencies],,\n-[AC_PROVIDE_IFELSE([AC_PROG_CC],\n-\t\t  [_AM_DEPENDENCIES(CC)],\n-\t\t  [define([AC_PROG_CC],\n-\t\t\t  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl\n-AC_PROVIDE_IFELSE([AC_PROG_CXX],\n-\t\t  [_AM_DEPENDENCIES(CXX)],\n-\t\t  [define([AC_PROG_CXX],\n-\t\t\t  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl\n-AC_PROVIDE_IFELSE([AC_PROG_OBJC],\n-\t\t  [_AM_DEPENDENCIES(OBJC)],\n-\t\t  [define([AC_PROG_OBJC],\n-\t\t\t  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl\n-])\n-_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl\n-dnl The `parallel-tests' driver may need to know about EXEEXT, so add the\n-dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro\n-dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.\n-AC_CONFIG_COMMANDS_PRE(dnl\n-[m4_provide_if([_AM_COMPILER_EXEEXT],\n-  [AM_CONDITIONAL([am__EXEEXT], [test -n \"$EXEEXT\"])])])dnl\n-])\n-\n-dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not\n-dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further\n-dnl mangled by Autoconf and run in a shell conditional statement.\n-m4_define([_AC_COMPILER_EXEEXT],\n-m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])\n-\n-\n-# When config.status generates a header, we must update the stamp-h file.\n-# This file resides in the same directory as the config header\n-# that is generated.  The stamp files are numbered to have different names.\n-\n-# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n-# loop where config.status creates the headers, so we can generate\n-# our stamp files there.\n-AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n-[# Compute $1's index in $config_headers.\n-_am_arg=$1\n-_am_stamp_count=1\n-for _am_header in $config_headers :; do\n-  case $_am_header in\n-    $_am_arg | $_am_arg:* )\n-      break ;;\n-    * )\n-      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n-  esac\n-done\n-echo \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n-\n-# Copyright (C) 2001, 2003, 2005, 2008  Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_PROG_INSTALL_SH\n-# ------------------\n-# Define $install_sh.\n-AC_DEFUN([AM_PROG_INSTALL_SH],\n-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-if test x\"${install_sh}\" != xset; then\n-  case $am_aux_dir in\n-  *\\ * | *\\\t*)\n-    install_sh=\"\\${SHELL} '$am_aux_dir/install-sh'\" ;;\n-  *)\n-    install_sh=\"\\${SHELL} $am_aux_dir/install-sh\"\n-  esac\n-fi\n-AC_SUBST(install_sh)])\n-\n-# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n-# From Jim Meyering\n-\n-# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 5\n-\n-# AM_MAINTAINER_MODE([DEFAULT-MODE])\n-# ----------------------------------\n-# Control maintainer-specific portions of Makefiles.\n-# Default is to disable them, unless `enable' is passed literally.\n-# For symmetry, `disable' may be passed as well.  Anyway, the user\n-# can override the default with the --enable/--disable switch.\n-AC_DEFUN([AM_MAINTAINER_MODE],\n-[m4_case(m4_default([$1], [disable]),\n-       [enable], [m4_define([am_maintainer_other], [disable])],\n-       [disable], [m4_define([am_maintainer_other], [enable])],\n-       [m4_define([am_maintainer_other], [enable])\n-        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])\n-AC_MSG_CHECKING([whether to am_maintainer_other maintainer-specific portions of Makefiles])\n-  dnl maintainer-mode's default is 'disable' unless 'enable' is passed\n-  AC_ARG_ENABLE([maintainer-mode],\n-[  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful\n-\t\t\t  (and sometimes confusing) to the casual installer],\n-      [USE_MAINTAINER_MODE=$enableval],\n-      [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))\n-  AC_MSG_RESULT([$USE_MAINTAINER_MODE])\n-  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])\n-  MAINT=$MAINTAINER_MODE_TRUE\n-  AC_SUBST([MAINT])dnl\n-]\n-)\n-\n-AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])\n-\n-# Check to see how 'make' treats includes.\t            -*- Autoconf -*-\n-\n-# Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 4\n-\n-# AM_MAKE_INCLUDE()\n-# -----------------\n-# Check to see how make treats includes.\n-AC_DEFUN([AM_MAKE_INCLUDE],\n-[am_make=${MAKE-make}\n-cat > confinc << 'END'\n-am__doit:\n-\t@echo this is the am__doit target\n-.PHONY: am__doit\n-END\n-# If we don't find an include directive, just comment out the code.\n-AC_MSG_CHECKING([for style of include used by $am_make])\n-am__include=\"#\"\n-am__quote=\n-_am_result=none\n-# First try GNU make style include.\n-echo \"include confinc\" > confmf\n-# Ignore all kinds of additional output from `make'.\n-case `$am_make -s -f confmf 2> /dev/null` in #(\n-*the\\ am__doit\\ target*)\n-  am__include=include\n-  am__quote=\n-  _am_result=GNU\n-  ;;\n-esac\n-# Now try BSD make style include.\n-if test \"$am__include\" = \"#\"; then\n-   echo '.include \"confinc\"' > confmf\n-   case `$am_make -s -f confmf 2> /dev/null` in #(\n-   *the\\ am__doit\\ target*)\n-     am__include=.include\n-     am__quote=\"\\\"\"\n-     _am_result=BSD\n-     ;;\n-   esac\n-fi\n-AC_SUBST([am__include])\n-AC_SUBST([am__quote])\n-AC_MSG_RESULT([$_am_result])\n-rm -f confinc confmf\n-])\n-\n-# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n-\n-# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 6\n-\n-# AM_MISSING_PROG(NAME, PROGRAM)\n-# ------------------------------\n-AC_DEFUN([AM_MISSING_PROG],\n-[AC_REQUIRE([AM_MISSING_HAS_RUN])\n-$1=${$1-\"${am_missing_run}$2\"}\n-AC_SUBST($1)])\n-\n-\n-# AM_MISSING_HAS_RUN\n-# ------------------\n-# Define MISSING if not defined so far and test if it supports --run.\n-# If it does, set am_missing_run to use it, otherwise, to nothing.\n-AC_DEFUN([AM_MISSING_HAS_RUN],\n-[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n-AC_REQUIRE_AUX_FILE([missing])dnl\n-if test x\"${MISSING+set}\" != xset; then\n-  case $am_aux_dir in\n-  *\\ * | *\\\t*)\n-    MISSING=\"\\${SHELL} \\\"$am_aux_dir/missing\\\"\" ;;\n-  *)\n-    MISSING=\"\\${SHELL} $am_aux_dir/missing\" ;;\n-  esac\n-fi\n-# Use eval to expand $SHELL\n-if eval \"$MISSING --run true\"; then\n-  am_missing_run=\"$MISSING --run \"\n-else\n-  am_missing_run=\n-  AC_MSG_WARN([`missing' script is too old or missing])\n-fi\n-])\n-\n-# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_PROG_MKDIR_P\n-# ---------------\n-# Check for `mkdir -p'.\n-AC_DEFUN([AM_PROG_MKDIR_P],\n-[AC_PREREQ([2.60])dnl\n-AC_REQUIRE([AC_PROG_MKDIR_P])dnl\n-dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,\n-dnl while keeping a definition of mkdir_p for backward compatibility.\n-dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.\n-dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of\n-dnl Makefile.ins that do not define MKDIR_P, so we do our own\n-dnl adjustment using top_builddir (which is defined more often than\n-dnl MKDIR_P).\n-AC_SUBST([mkdir_p], [\"$MKDIR_P\"])dnl\n-case $mkdir_p in\n-  [[\\\\/$]]* | ?:[[\\\\/]]*) ;;\n-  */*) mkdir_p=\"\\$(top_builddir)/$mkdir_p\" ;;\n-esac\n-])\n-\n-# Helper functions for option handling.                     -*- Autoconf -*-\n-\n-# Copyright (C) 2001, 2002, 2003, 2005, 2008  Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 4\n-\n-# _AM_MANGLE_OPTION(NAME)\n-# -----------------------\n-AC_DEFUN([_AM_MANGLE_OPTION],\n-[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n-\n-# _AM_SET_OPTION(NAME)\n-# ------------------------------\n-# Set option NAME.  Presently that only means defining a flag for this option.\n-AC_DEFUN([_AM_SET_OPTION],\n-[m4_define(_AM_MANGLE_OPTION([$1]), 1)])\n-\n-# _AM_SET_OPTIONS(OPTIONS)\n-# ----------------------------------\n-# OPTIONS is a space-separated list of Automake options.\n-AC_DEFUN([_AM_SET_OPTIONS],\n-[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n-\n-# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n-# -------------------------------------------\n-# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\n-AC_DEFUN([_AM_IF_OPTION],\n-[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n-\n-# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n-\n-# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008\n-# Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 5\n-\n-# AM_SANITY_CHECK\n-# ---------------\n-AC_DEFUN([AM_SANITY_CHECK],\n-[AC_MSG_CHECKING([whether build environment is sane])\n-# Just in case\n-sleep 1\n-echo timestamp > conftest.file\n-# Reject unsafe characters in $srcdir or the absolute working directory\n-# name.  Accept space and tab only in the latter.\n-am_lf='\n-'\n-case `pwd` in\n-  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]]*)\n-    AC_MSG_ERROR([unsafe absolute working directory name]);;\n-esac\n-case $srcdir in\n-  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]]*)\n-    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;\n-esac\n-\n-# Do `set' in a subshell so we don't clobber the current shell's\n-# arguments.  Must try -L first in case configure is actually a\n-# symlink; some systems play weird games with the mod time of symlinks\n-# (eg FreeBSD returns the mod time of the symlink's containing\n-# directory).\n-if (\n-   set X `ls -Lt \"$srcdir/configure\" conftest.file 2> /dev/null`\n-   if test \"$[*]\" = \"X\"; then\n-      # -L didn't work.\n-      set X `ls -t \"$srcdir/configure\" conftest.file`\n-   fi\n-   rm -f conftest.file\n-   if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n-      && test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n-\n-      # If neither matched, then we have a broken ls.  This can happen\n-      # if, for instance, CONFIG_SHELL is bash and it inherits a\n-      # broken ls alias from the environment.  This has actually\n-      # happened.  Such a system could not be considered \"sane\".\n-      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\n-alias in your environment])\n-   fi\n-\n-   test \"$[2]\" = conftest.file\n-   )\n-then\n-   # Ok.\n-   :\n-else\n-   AC_MSG_ERROR([newly created file is older than distributed files!\n-Check your system clock])\n-fi\n-AC_MSG_RESULT(yes)])\n-\n-# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# AM_PROG_INSTALL_STRIP\n-# ---------------------\n-# One issue with vendor `install' (even GNU) is that you can't\n-# specify the program used to strip binaries.  This is especially\n-# annoying in cross-compiling environments, where the build's strip\n-# is unlikely to handle the host's binaries.\n-# Fortunately install-sh will honor a STRIPPROG variable, so we\n-# always use install-sh in `make install-strip', and initialize\n-# STRIPPROG with the value of the STRIP variable (set by the user).\n-AC_DEFUN([AM_PROG_INSTALL_STRIP],\n-[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n-# Installed binaries are usually stripped using `strip' when the user\n-# run `make install-strip'.  However `strip' might not be the right\n-# tool to use in cross-compilation environments, therefore Automake\n-# will honor the `STRIP' environment variable to overrule this program.\n-dnl Don't test for $cross_compiling = yes, because it might be `maybe'.\n-if test \"$cross_compiling\" != no; then\n-  AC_CHECK_TOOL([STRIP], [strip], :)\n-fi\n-INSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n-AC_SUBST([INSTALL_STRIP_PROGRAM])])\n-\n-# Copyright (C) 2006, 2008  Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 2\n-\n-# _AM_SUBST_NOTMAKE(VARIABLE)\n-# ---------------------------\n-# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n-# This macro is traced by Automake.\n-AC_DEFUN([_AM_SUBST_NOTMAKE])\n-\n-# AM_SUBST_NOTMAKE(VARIABLE)\n-# ---------------------------\n-# Public sister of _AM_SUBST_NOTMAKE.\n-AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n-\n-# Check how to create a tarball.                            -*- Autoconf -*-\n-\n-# Copyright (C) 2004, 2005  Free Software Foundation, Inc.\n-#\n-# This file is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# serial 2\n-\n-# _AM_PROG_TAR(FORMAT)\n-# --------------------\n-# Check how to create a tarball in format FORMAT.\n-# FORMAT should be one of `v7', `ustar', or `pax'.\n-#\n-# Substitute a variable $(am__tar) that is a command\n-# writing to stdout a FORMAT-tarball containing the directory\n-# $tardir.\n-#     tardir=directory && $(am__tar) > result.tar\n-#\n-# Substitute a variable $(am__untar) that extract such\n-# a tarball read from stdin.\n-#     $(am__untar) < result.tar\n-AC_DEFUN([_AM_PROG_TAR],\n-[# Always define AMTAR for backward compatibility.\n-AM_MISSING_PROG([AMTAR], [tar])\n-m4_if([$1], [v7],\n-     [am__tar='${AMTAR} chof - \"$$tardir\"'; am__untar='${AMTAR} xf -'],\n-     [m4_case([$1], [ustar],, [pax],,\n-              [m4_fatal([Unknown tar format])])\n-AC_MSG_CHECKING([how to create a $1 tar archive])\n-# Loop over all known methods to create a tar archive until one works.\n-_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n-_am_tools=${am_cv_prog_tar_$1-$_am_tools}\n-# Do not fold the above two line into one, because Tru64 sh and\n-# Solaris sh will not grok spaces in the rhs of `-'.\n-for _am_tool in $_am_tools\n-do\n-  case $_am_tool in\n-  gnutar)\n-    for _am_tar in tar gnutar gtar;\n-    do\n-      AM_RUN_LOG([$_am_tar --version]) && break\n-    done\n-    am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n-    am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n-    am__untar=\"$_am_tar -xf -\"\n-    ;;\n-  plaintar)\n-    # Must skip GNU tar: if it does not support --format= it doesn't create\n-    # ustar tarball either.\n-    (tar --version) >/dev/null 2>&1 && continue\n-    am__tar='tar chf - \"$$tardir\"'\n-    am__tar_='tar chf - \"$tardir\"'\n-    am__untar='tar xf -'\n-    ;;\n-  pax)\n-    am__tar='pax -L -x $1 -w \"$$tardir\"'\n-    am__tar_='pax -L -x $1 -w \"$tardir\"'\n-    am__untar='pax -r'\n-    ;;\n-  cpio)\n-    am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n-    am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n-    am__untar='cpio -i -H $1 -d'\n-    ;;\n-  none)\n-    am__tar=false\n-    am__tar_=false\n-    am__untar=false\n-    ;;\n-  esac\n-\n-  # If the value was cached, stop now.  We just wanted to have am__tar\n-  # and am__untar set.\n-  test -n \"${am_cv_prog_tar_$1}\" && break\n-\n-  # tar/untar a dummy directory, and stop if the command works\n-  rm -rf conftest.dir\n-  mkdir conftest.dir\n-  echo GrepMe > conftest.dir/file\n-  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n-  rm -rf conftest.dir\n-  if test -s conftest.tar; then\n-    AM_RUN_LOG([$am__untar <conftest.tar])\n-    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n-  fi\n-done\n-rm -rf conftest.dir\n-\n-AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\n-AC_MSG_RESULT([$am_cv_prog_tar_$1])])\n-AC_SUBST([am__tar])\n-AC_SUBST([am__untar])\n-]) # _AM_PROG_TAR\n-\n-m4_include([../config/acx.m4])\n-m4_include([../config/depstand.m4])\n-m4_include([../config/enable.m4])\n-m4_include([../config/lead-dot.m4])\n-m4_include([../config/multi.m4])\n-m4_include([../config/override.m4])\n-m4_include([../config/tls.m4])\n-m4_include([../ltoptions.m4])\n-m4_include([../ltsugar.m4])\n-m4_include([../ltversion.m4])\n-m4_include([../lt~obsolete.m4])\n-m4_include([acinclude.m4])"}, {"sha": "ffdd6721c01f4669d00dc0460296cb603004fd2b", "filename": "libmudflap/config.h.in", "status": "removed", "additions": 0, "deletions": 308, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fconfig.h.in?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,308 +0,0 @@\n-/* config.h.in.  Generated from configure.ac by autoheader.  */\n-\n-/* Define to the name of the symbol used for the entry point. */\n-#undef ENTRY_POINT\n-\n-/* Define to 1 if you have the `addmntent' function. */\n-#undef HAVE_ADDMNTENT\n-\n-/* Define to 1 if you have the <arpa/inet.h> header file. */\n-#undef HAVE_ARPA_INET_H\n-\n-/* Define to 1 if you have the `backtrace' function. */\n-#undef HAVE_BACKTRACE\n-\n-/* Define to 1 if you have the `backtrace_symbols' function. */\n-#undef HAVE_BACKTRACE_SYMBOLS\n-\n-/* Define to 1 if the target assembler supports thread-local storage. */\n-#undef HAVE_CC_TLS\n-\n-/* Define to 1 if you have the <ctype.h> header file. */\n-#undef HAVE_CTYPE_H\n-\n-/* Define to 1 if you have the `cuserid' function. */\n-#undef HAVE_CUSERID\n-\n-/* Define to 1 if you have the <dirent.h> header file. */\n-#undef HAVE_DIRENT_H\n-\n-/* Define to 1 if you have the <dlfcn.h> header file. */\n-#undef HAVE_DLFCN_H\n-\n-/* Define to 1 if you have the `dlvsym' function. */\n-#undef HAVE_DLVSYM\n-\n-/* Define to 1 if you have the <execinfo.h> header file. */\n-#undef HAVE_EXECINFO_H\n-\n-/* Define to 1 if you have the `fopen64' function. */\n-#undef HAVE_FOPEN64\n-\n-/* Define to 1 if you have the `freopen64' function. */\n-#undef HAVE_FREOPEN64\n-\n-/* Define to 1 if you have the `fseeko64' function. */\n-#undef HAVE_FSEEKO64\n-\n-/* Define to 1 if you have the `ftello64' function. */\n-#undef HAVE_FTELLO64\n-\n-/* Define to 1 if you have the `gai_strerror' function. */\n-#undef HAVE_GAI_STRERROR\n-\n-/* Define to 1 if you have the `getaddrinfo' function. */\n-#undef HAVE_GETADDRINFO\n-\n-/* Define to 1 if you have the `getgrent' function. */\n-#undef HAVE_GETGRENT\n-\n-/* Define to 1 if you have the `getgrgid' function. */\n-#undef HAVE_GETGRGID\n-\n-/* Define to 1 if you have the `getgrgid_r' function. */\n-#undef HAVE_GETGRGID_R\n-\n-/* Define to 1 if you have the `getgrnam' function. */\n-#undef HAVE_GETGRNAM\n-\n-/* Define to 1 if you have the `getgrnam_r' function. */\n-#undef HAVE_GETGRNAM_R\n-\n-/* Define to 1 if you have the `getlogin' function. */\n-#undef HAVE_GETLOGIN\n-\n-/* Define to 1 if you have the `getlogin_r' function. */\n-#undef HAVE_GETLOGIN_R\n-\n-/* Define to 1 if you have the `getmntent' function. */\n-#undef HAVE_GETMNTENT\n-\n-/* Define to 1 if you have the `getprotobyname' function. */\n-#undef HAVE_GETPROTOBYNAME\n-\n-/* Define to 1 if you have the `getprotobynumber' function. */\n-#undef HAVE_GETPROTOBYNUMBER\n-\n-/* Define to 1 if you have the `getprotoent' function. */\n-#undef HAVE_GETPROTOENT\n-\n-/* Define to 1 if you have the `getpwent' function. */\n-#undef HAVE_GETPWENT\n-\n-/* Define to 1 if you have the `getpwnam' function. */\n-#undef HAVE_GETPWNAM\n-\n-/* Define to 1 if you have the `getpwnam_r' function. */\n-#undef HAVE_GETPWNAM_R\n-\n-/* Define to 1 if you have the `getpwuid' function. */\n-#undef HAVE_GETPWUID\n-\n-/* Define to 1 if you have the `getpwuid_r' function. */\n-#undef HAVE_GETPWUID_R\n-\n-/* Define to 1 if you have the `getservbyname' function. */\n-#undef HAVE_GETSERVBYNAME\n-\n-/* Define to 1 if you have the `getservbyport' function. */\n-#undef HAVE_GETSERVBYPORT\n-\n-/* Define to 1 if you have the `getservent' function. */\n-#undef HAVE_GETSERVENT\n-\n-/* Define to 1 if you have the `gettimeofday' function. */\n-#undef HAVE_GETTIMEOFDAY\n-\n-/* Define to 1 if you have the <grp.h> header file. */\n-#undef HAVE_GRP_H\n-\n-/* Define to 1 if you have the `inet_ntoa' function. */\n-#undef HAVE_INET_NTOA\n-\n-/* Define to 1 if you have the <inttypes.h> header file. */\n-#undef HAVE_INTTYPES_H\n-\n-/* Define to 1 if you have the `dl' library (-ldl). */\n-#undef HAVE_LIBDL\n-\n-/* Define to 1 if you have the `rt' library (-lrt). */\n-#undef HAVE_LIBRT\n-\n-/* Define to 1 if you have the `socket' library (-lsocket). */\n-#undef HAVE_LIBSOCKET\n-\n-/* Define to 1 if you have the `memmem' function. */\n-#undef HAVE_MEMMEM\n-\n-/* Define to 1 if you have the <memory.h> header file. */\n-#undef HAVE_MEMORY_H\n-\n-/* Define to 1 if you have the `mempcpy' function. */\n-#undef HAVE_MEMPCPY\n-\n-/* Define to 1 if you have the `memrchr' function. */\n-#undef HAVE_MEMRCHR\n-\n-/* Define to 1 if you have the `mmap' function. */\n-#undef HAVE_MMAP\n-\n-/* Define to 1 if you have the `mmap64' function. */\n-#undef HAVE_MMAP64\n-\n-/* Define to 1 if you have the <mntent.h> header file. */\n-#undef HAVE_MNTENT_H\n-\n-/* Define to 1 if you have the `munmap' function. */\n-#undef HAVE_MUNMAP\n-\n-/* Define to 1 if you have the <netdb.h> header file. */\n-#undef HAVE_NETDB_H\n-\n-/* Define to 1 if you have the <netinet/in.h> header file. */\n-#undef HAVE_NETINET_IN_H\n-\n-/* Define to 1 if you have the <pthread.h> header file. */\n-#undef HAVE_PTHREAD_H\n-\n-/* Define to 1 if you have the <pwd.h> header file. */\n-#undef HAVE_PWD_H\n-\n-/* Define to 1 if you have the `rawmemchr' function. */\n-#undef HAVE_RAWMEMCHR\n-\n-/* Define to 1 if you have the `setbuf' function. */\n-#undef HAVE_SETBUF\n-\n-/* Define to 1 if you have the `setbuffer' function. */\n-#undef HAVE_SETBUFFER\n-\n-/* Define to 1 if you have the `sethostname' function. */\n-#undef HAVE_SETHOSTNAME\n-\n-/* Define to 1 if you have the `setlinebuf' function. */\n-#undef HAVE_SETLINEBUF\n-\n-/* Define to 1 if you have the `setmntent' function. */\n-#undef HAVE_SETMNTENT\n-\n-/* Define to 1 if you have the `setvbuf' function. */\n-#undef HAVE_SETVBUF\n-\n-/* Define to 1 if you have the `signal' function. */\n-#undef HAVE_SIGNAL\n-\n-/* Define to 1 if you have the <signal.h> header file. */\n-#undef HAVE_SIGNAL_H\n-\n-/* Define it socklen_t typedef is in sys/socket.h. */\n-#undef HAVE_SOCKLEN_T\n-\n-/* Define to 1 if you have the `stat64' function. */\n-#undef HAVE_STAT64\n-\n-/* Define to 1 if you have the <stdint.h> header file. */\n-#undef HAVE_STDINT_H\n-\n-/* Define to 1 if you have the <stdlib.h> header file. */\n-#undef HAVE_STDLIB_H\n-\n-/* Define to 1 if you have the `stpcpy' function. */\n-#undef HAVE_STPCPY\n-\n-/* Define to 1 if you have the <strings.h> header file. */\n-#undef HAVE_STRINGS_H\n-\n-/* Define to 1 if you have the <string.h> header file. */\n-#undef HAVE_STRING_H\n-\n-/* Define to 1 if you have the `strncpy' function. */\n-#undef HAVE_STRNCPY\n-\n-/* Define to 1 if you have the `strnlen' function. */\n-#undef HAVE_STRNLEN\n-\n-/* Define to 1 if you have the <sys/ipc.h> header file. */\n-#undef HAVE_SYS_IPC_H\n-\n-/* Define to 1 if you have the <sys/mman.h> header file. */\n-#undef HAVE_SYS_MMAN_H\n-\n-/* Define to 1 if you have the <sys/mnttab.h> header file. */\n-#undef HAVE_SYS_MNTTAB_H\n-\n-/* Define to 1 if you have the <sys/sem.h> header file. */\n-#undef HAVE_SYS_SEM_H\n-\n-/* Define to 1 if you have the <sys/shm.h> header file. */\n-#undef HAVE_SYS_SHM_H\n-\n-/* Define to 1 if you have the <sys/socket.h> header file. */\n-#undef HAVE_SYS_SOCKET_H\n-\n-/* Define to 1 if you have the <sys/stat.h> header file. */\n-#undef HAVE_SYS_STAT_H\n-\n-/* Define to 1 if you have the <sys/types.h> header file. */\n-#undef HAVE_SYS_TYPES_H\n-\n-/* Define to 1 if you have the <sys/wait.h> header file. */\n-#undef HAVE_SYS_WAIT_H\n-\n-/* Define to 1 if the target supports thread-local storage. */\n-#undef HAVE_TLS\n-\n-/* union semun defined in sys/ipc.h or sys/sem.h */\n-#undef HAVE_UNION_SEMUN\n-\n-/* Define to 1 if you have the <unistd.h> header file. */\n-#undef HAVE_UNISTD_H\n-\n-/* Define to 1 if you have the `__ctype_b_loc' function. */\n-#undef HAVE___CTYPE_B_LOC\n-\n-/* Define to 1 if you have the `__ctype_tolower_loc' function. */\n-#undef HAVE___CTYPE_TOLOWER_LOC\n-\n-/* Define to 1 if you have the `__ctype_toupper_loc' function. */\n-#undef HAVE___CTYPE_TOUPPER_LOC\n-\n-/* Define to 1 if you have the `__libc_freeres' function. */\n-#undef HAVE___LIBC_FREERES\n-\n-/* Define to the sub-directory in which libtool stores uninstalled libraries.\n-   */\n-#undef LT_OBJDIR\n-\n-/* Name of package */\n-#undef PACKAGE\n-\n-/* Define to the address where bug reports for this package should be sent. */\n-#undef PACKAGE_BUGREPORT\n-\n-/* Define to the full name of this package. */\n-#undef PACKAGE_NAME\n-\n-/* Define to the full name and version of this package. */\n-#undef PACKAGE_STRING\n-\n-/* Define to the one symbol short name of this package. */\n-#undef PACKAGE_TARNAME\n-\n-/* Define to the home page for this package. */\n-#undef PACKAGE_URL\n-\n-/* Define to the version of this package. */\n-#undef PACKAGE_VERSION\n-\n-/* pthread_create symbol version */\n-#undef PTHREAD_CREATE_VERSION\n-\n-/* Define to 1 if you have the ANSI C header files. */\n-#undef STDC_HEADERS\n-\n-/* Define to 1 if the target use emutls for thread-local storage. */\n-#undef USE_EMUTLS\n-\n-/* Version number of package */\n-#undef VERSION"}, {"sha": "1e91dbb3a6a92c760f82ea24527854e74ad01dbd", "filename": "libmudflap/configure", "status": "removed", "additions": 0, "deletions": 14050, "changes": 14050, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fconfigure?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5"}, {"sha": "83aba5a5ba87750a8c52ec39bdf5176d6da78511", "filename": "libmudflap/configure.ac", "status": "removed", "additions": 0, "deletions": 270, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fconfigure.ac?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,270 +0,0 @@\n-# Process this file with autoconf to produce a configure script, like so:\n-# aclocal -I .. -I ../config && autoconf && autoheader && automake\n-\n-AC_PREREQ(2.64)\n-AC_INIT(libmudflap, 1.0)\n-AC_CONFIG_SRCDIR(mf-runtime.c)\n-AC_CANONICAL_SYSTEM\n-ACX_NONCANONICAL_TARGET\n-\n-AM_INIT_AUTOMAKE([no-dist])\n-\n-AC_MSG_CHECKING([for --enable-version-specific-runtime-libs])\n-AC_ARG_ENABLE(version-specific-runtime-libs,\n-[  --enable-version-specific-runtime-libs    Specify that runtime libraries should be installed in a compiler-specific directory ],\n-[case \"$enableval\" in\n- yes) version_specific_libs=yes ;;\n- no)  version_specific_libs=no ;;\n- *)   AC_MSG_ERROR([Unknown argument to enable/disable version-specific libs]);;\n- esac],\n-[version_specific_libs=no])\n-AC_MSG_RESULT($version_specific_libs)\n-\n-AM_MAINTAINER_MODE\n-AC_EXEEXT\n-\n-AM_ENABLE_MULTILIB(, ..)\n-\n-target_alias=${target_alias-$host_alias}\n-AC_SUBST(target_alias)\n-\n-AC_CONFIG_HEADERS(config.h)\n-\n-AC_LANG_C\n-# The same as in boehm-gc and libstdc++. Have to borrow it from there.\n-# We must force CC to /not/ be precious variables; otherwise\n-# the wrong, non-multilib-adjusted value will be used in multilibs.\n-# As a side effect, we have to subst CFLAGS ourselves.\n-\n-m4_rename([_AC_ARG_VAR_PRECIOUS],[real_PRECIOUS])\n-m4_define([_AC_ARG_VAR_PRECIOUS],[])\n-AC_PROG_CC\n-m4_rename_force([real_PRECIOUS],[_AC_ARG_VAR_PRECIOUS])\n-\n-AC_SUBST(CFLAGS)\n-\n-if test \"x$GCC\" != \"xyes\"; then\n-  AC_MSG_ERROR([libmudflap must be built with GCC])\n-fi\n-AC_PROG_CPP\n-\n-# Some hosts don't have dlsym(RTLD_NEXT, \"symbol\") for use in\n-# symbol interposition.  We disable shared libraries for these.\n-AC_MSG_CHECKING([whether dlsym(RTLD_NEXT,...) is available])\n-AC_TRY_COMPILE([\n-#define _GNU_SOURCE\n-#include <dlfcn.h>\n-],\n-[void *foo = dlsym (RTLD_NEXT, \"exit\");],\n-[AC_MSG_RESULT(yes)],\n-[AC_MSG_RESULT(no)\n-enable_shared=no])\n-\n-AC_CHECK_HEADERS(stdint.h execinfo.h signal.h dlfcn.h dirent.h pwd.h grp.h \\\n-  netdb.h sys/ipc.h sys/sem.h sys/shm.h sys/wait.h ctype.h mntent.h \\\n-  sys/mnttab.h sys/socket.h netinet/in.h arpa/inet.h dlfcn.h sys/mman.h)\n-\n-AC_CHECK_FUNCS(backtrace backtrace_symbols gettimeofday signal)\n-AC_CHECK_FUNCS(fopen64 fseeko64 ftello64 stat64 freopen64)\n-AC_CHECK_FUNCS(setbuf setbuffer setlinebuf setvbuf)\n-AC_CHECK_FUNCS(strnlen memrchr strncpy memmem sethostname)\n-AC_CHECK_FUNCS(__ctype_b_loc __ctype_tolower_loc __ctype_toupper_loc)\n-AC_CHECK_FUNCS(getlogin cuserid getpwnam getpwuid getpwent getgrnam getgrgid getgrent)\n-AC_CHECK_FUNCS(getlogin_r getpwnam_r getpwuid_r getgrnam_r getgrgid_r)\n-AC_CHECK_FUNCS(getservent getservbyname getservbyport getaddrinfo gai_strerror)\n-AC_CHECK_FUNCS(getprotoent getprotobyname getprotobynumber)\n-AC_CHECK_FUNCS(getmntent setmntent addmntent)\n-AC_CHECK_FUNCS(inet_ntoa mmap munmap)\n-AC_CHECK_FUNCS(mmap64)\n-AC_CHECK_FUNCS(__libc_freeres)\n-AC_CHECK_FUNCS(rawmemchr stpcpy mempcpy)\n-\n-AC_TRY_COMPILE([#include <sys/types.h>\n-#include <sys/ipc.h>\n-#include <sys/sem.h>],[union semun foo;], [mf_have_semun=1], [mf_have_semun=0])\n-if test $mf_have_semun = 1\n-then\n-  AC_DEFINE(HAVE_UNION_SEMUN, 1, [union semun defined in sys/ipc.h or sys/sem.h])\n-fi\n-\n-\n-AC_MSG_CHECKING([for socklen_t in sys/socket.h])\n-AC_TRY_COMPILE([#define _POSIX_PII_SOCKET\n-#include <sys/types.h>\n-#include <sys/socket.h>], [socklen_t x = 5;],\n-  [AC_DEFINE(HAVE_SOCKLEN_T, 1, [Define it socklen_t typedef is in sys/socket.h.])\n-   AC_MSG_RESULT(yes)],\n-  [AC_MSG_RESULT(no)])\n-\n-AC_LIBTOOL_DLOPEN\n-AM_PROG_LIBTOOL\n-AC_SUBST(enable_shared)\n-AC_SUBST(enable_static)\n-\n-AC_CHECK_HEADER(stdint.h, [MF_HAVE_STDINT_H=1], [MF_HAVE_STDINT_H=0])\n-AC_SUBST(MF_HAVE_STDINT_H)\n-if test $MF_HAVE_STDINT_H = 1\n-then\n-   MF_HAVE_UINTPTR_T=1\n-else\n-   AC_TRY_COMPILE([#include <sys/types.h>], [uintptr_t k = 0;],\n-\t[MF_HAVE_UINTPTR_T=1], [MF_HAVE_UINTPTR_T=0])\n-fi\n-AC_SUBST(MF_HAVE_UINTPTR_T)\n-\n-AC_CHECK_HEADERS(pthread.h)\n-\n-AC_MSG_CHECKING([for thread model used by GCC])\n-target_thread_file=`$CC -v 2>&1 | sed -n 's/^Thread model: //p'`\n-AC_MSG_RESULT([$target_thread_file])\n-\n-# We only support posix threads, or no threads at all.\n-posix_threads=\n-case ${target_thread_file} in\n-  posix)\n-    posix_threads=yes\n-    ;;\n-  single)\n-    ;;\n-  *)\n-    echo \"${target_thread_file} is an unsupported thread package\" 1>&2\n-    exit 1\n-    ;;\n-esac\n-\n-AM_CONDITIONAL(LIBMUDFLAPTH, [test \"x$posix_threads\" != \"x\"])\n-if test \"x$posix_threads\" != \"x\"\n-then\n-        build_libmudflapth=1\n-else\n-        build_libmudflapth=0\n-fi\n-AC_SUBST(build_libmudflapth)\n-\n-AC_CHECK_LIB(dl, dlsym)\n-\n-AC_CHECK_FUNC(connect,, AC_CHECK_LIB(socket, connect))\n-AC_CHECK_FUNC(sched_yield,, AC_CHECK_LIB(rt, sched_yield))\n-\n-# Calculate toolexeclibdir\n-# Also toolexecdir, though it's only used in toolexeclibdir\n-case ${version_specific_libs} in\n-  yes)\n-    # Need the gcc compiler version to know where to install libraries\n-    # and header files if --enable-version-specific-runtime-libs option\n-    # is selected.\n-    toolexecdir='$(libdir)/gcc/$(target_alias)'\n-    toolexeclibdir='$(toolexecdir)/$(gcc_version)$(MULTISUBDIR)'\n-    ;;\n-  no)\n-    if test -n \"$with_cross_host\" &&\n-       test x\"$with_cross_host\" != x\"no\"; then\n-      # Install a library built with a cross compiler in tooldir, not libdir.\n-      toolexecdir='$(exec_prefix)/$(target_alias)'\n-      toolexeclibdir='$(toolexecdir)/lib'\n-    else\n-      toolexecdir='$(libdir)/gcc-lib/$(target_alias)'\n-      toolexeclibdir='$(libdir)'\n-    fi\n-    multi_os_directory=`$CC -print-multi-os-directory`\n-    case $multi_os_directory in\n-      .) ;; # Avoid trailing /.\n-      *) toolexeclibdir=$toolexeclibdir/$multi_os_directory ;;\n-    esac\n-    ;;\n-esac\n-AC_SUBST(toolexecdir)\n-AC_SUBST(toolexeclibdir)\n-\n-includedir=${toolexecdir}/include\n-AC_SUBST(includedir)\n-\n-pthread_create_version='\"\"'\n-if test \"x$enable_shared\" = \"xyes\" && test \"x$posix_threads\" != \"x\"; then\n-  # NB: don't check for -lpthread here, because then it would be\n-  # added to LIBS.  For the thread-unaware libmudflap.la, we don't\n-  # want it there.\n-\n-  # glibc-related hacks.  dlsym() may pick the wrong version of\n-  # interposed functions like pthread_create on modern glibc.\n-  # We need to find the proper symbol version string, and use\n-  # the nonstandard dlvsym().\n-  AC_CHECK_FUNCS(dlvsym)\n-  AC_CHECK_TOOL(NM, nm)\n-  if test \"x$ac_cv_have_dlvsym\" != \"x\"; then\n-    # Try compiling a simple pthreads program.  Find the shared libraries it\n-    # ends up with.  Then use \"nm\" on those libraries to extract the\n-    # default symbol versioning suffix (\"@@\"), if any.  But that's tricky.\n-    # Rather, run nm on the resulting executable.  Unfortunately, autoconf\n-    # doesn't appear to have a macro that builds a test executable for\n-    # subsequent analysis ... so we do it by hand here.\n-    cat >> conftest.c << EOF\n-#include <pthread.h>\n-int main () { void *p = (void *) & pthread_create; return (int) p; }\n-EOF\n-    oldLIBS=\"$LIBS\"\n-    LIBS=\"$LIBS -lpthread\"\n-    pthread_create_version=\"\\\"\\\"\"\n-    AC_MSG_CHECKING(pthread_create symbol version)\n-    if eval $ac_link 2>&5 && test -s conftest${ac_exeext}; then\n-      version=`$NM conftest${ac_exeect} | grep 'pthread_create@@' | sed -e 's/^.*@@//'`\n-      if test \"x$version\" != \"x\"; then\n-        pthread_create_version=\"\\\"$version\\\"\"\n-      fi\n-    fi\n-    AC_MSG_RESULT($pthread_create_version)\n-    LIBS=\"$oldLIBS\"\n-  fi\n-fi\n-AC_DEFINE_UNQUOTED(PTHREAD_CREATE_VERSION, $pthread_create_version, [pthread_create symbol version])\n-\n-\n-# Figure out whether the compiler supports \"-ffunction-sections -fdata-sections\",\n-# similarly to how libstdc++ does it\n-ac_test_CFLAGS=\"${CFLAGS+set}\"\n-ac_save_CFLAGS=\"$CFLAGS\"\n-\n-# Check for -ffunction-sections -fdata-sections\n-AC_MSG_CHECKING([for gcc that supports -ffunction-sections -fdata-sections])\n-CFLAGS='-Werror -ffunction-sections -fdata-sections'\n-AC_TRY_COMPILE(, [int foo;], [ac_fdsections=yes], [ac_fdsections=no])\n-if test \"$ac_test_CFLAGS\" = set; then\n-  CFLAGS=\"$ac_save_CFLAGS\"\n-else\n-  # this is the suspicious part\n-  CFLAGS=\"\"\n-fi\n-if test x\"$ac_fdsections\" = x\"yes\"; then\n-  SECTION_FLAGS='-ffunction-sections -fdata-sections'\n-fi\n-AC_MSG_RESULT($ac_fdsections)\n-AC_SUBST(SECTION_FLAGS)\n-\n-\n-# Check for the name of the symbol used for the entry point.\n-AC_CACHE_CHECK([for the name of the symbol used for the entry point],\n-  [mudflap_cv_entry_point], [\n-for name in _start __start unknown; do\n-  AC_LINK_IFELSE([AC_LANG_PROGRAM([extern char $name@<:@@:>@;], [$name@<:@0@:>@ = 0;])],\n-\t\t [break])\n-done\n-mudflap_cv_entry_point=\"$name\"])\n-if test \"$mudflap_cv_entry_point\" = unknown; then\n-  AC_MSG_ERROR([none of the known symbol names works])\n-fi\n-AC_DEFINE_UNQUOTED([ENTRY_POINT], [$mudflap_cv_entry_point],\n-  [Define to the name of the symbol used for the entry point.])\n-\n-\n-if test ${multilib} = yes; then\n-  multilib_arg=\"--enable-multilib\"\n-else\n-  multilib_arg=\n-fi\n-\n-# See if we support thread-local storage.\n-GCC_CHECK_TLS\n-GCC_CHECK_EMUTLS\n-\n-AC_CONFIG_FILES([Makefile testsuite/Makefile testsuite/mfconfig.exp])\n-AC_OUTPUT"}, {"sha": "204fdd2d8e5fe21a5a9f9e23d6a6cf17d353362a", "filename": "libmudflap/libtool-version", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Flibtool-version", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Flibtool-version", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Flibtool-version?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,6 +0,0 @@\n-# This file is used to maintain libtool version info for libmudflap.  See\n-# the libtool manual to understand the meaning of the fields.  This is\n-# a separate file so that version updates don't involve re-running\n-# automake.\n-# CURRENT:REVISION:AGE\n-0:0:0"}, {"sha": "fa2dacb6abd65eaec2221f57f0cbe0a5419558bd", "filename": "libmudflap/mf-heuristics.c", "status": "removed", "additions": 0, "deletions": 169, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Fmf-heuristics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Fmf-heuristics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-heuristics.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,169 +0,0 @@\n-/* Mudflap: narrow-pointer bounds-checking by tree rewriting.\n-   Copyright (C) 2002-2013 Free Software Foundation, Inc.\n-   Contributed by Frank Ch. Eigler <fche@redhat.com>\n-   and Graydon Hoare <graydon@redhat.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-\n-#include <stdio.h>\n-\n-#include \"mf-runtime.h\"\n-#include \"mf-impl.h\"\n-\n-#ifdef _MUDFLAP\n-#error \"Do not compile this file with -fmudflap!\"\n-#endif\n-\n-\n-extern char _end[];\n-extern char ENTRY_POINT[];\n-\n-\n-/* Run some quick validation of the given region.\n-   Return -1 / 0 / 1 if the access known-invalid, possibly-valid, or known-valid.\n-*/\n-int\n-__mf_heuristic_check (uintptr_t ptr, uintptr_t ptr_high)\n-{\n-  VERBOSE_TRACE (\"mf: heuristic check\\n\");\n-\n-  /* XXX: Disable the stack bounding check for libmudflapth.  We do\n-     actually have enough information to track stack bounds (see\n-     __mf_pthread_info in mf-hooks.c), so with a bit of future work,\n-     this heuristic can be turned on.  */\n-#ifndef LIBMUDFLAPTH\n-\n-  /* The first heuristic is to check stack bounds.  This is a\n-     transient condition and quick to check. */\n-  if (__mf_opts.heur_stack_bound)\n-    {\n-      uintptr_t stack_top_guess = (uintptr_t)__builtin_frame_address(0);\n-#if defined(__i386__) && defined (__linux__)\n-      uintptr_t stack_segment_base = 0xC0000000; /* XXX: Bad assumption. */\n-#else\n-      /* Cause tests to fail. */\n-      uintptr_t stack_segment_base = 0;\n-#endif\n-\n-      VERBOSE_TRACE (\"mf: stack estimated as %p-%p\\n\",\n-\t\t     (void *) stack_top_guess, (void *) stack_segment_base);\n-\n-      if (ptr_high <= stack_segment_base &&\n-\t  ptr >= stack_top_guess &&\n-\t  ptr_high >= ptr)\n-\t{\n-\t  return 1;\n-\t}\n-    }\n-#endif\n-\n-\n-  /* The second heuristic is to scan the range of memory regions\n-     listed in /proc/self/maps, a special file provided by the Linux\n-     kernel.  Its results may be cached, and in fact, a GUESS object\n-     may as well be recorded for interesting matching sections.  */\n-  if (__mf_opts.heur_proc_map)\n-    {\n-      /* Keep a record of seen records from /proc/self/map.  */\n-      enum { max_entries = 500 };\n-      struct proc_self_map_entry\n-      {\n-\tuintptr_t low;\n-\tuintptr_t high;\n-      };\n-      static struct proc_self_map_entry entry [max_entries];\n-      static unsigned entry_used [max_entries];\n-\n-      /* Look for a known proc_self_map entry that may cover this\n-\t region.  If one exists, then this heuristic has already run,\n-\t and should not be run again.  The check should be allowed to\n-\t fail.  */\n-      unsigned i;\n-      unsigned deja_vu = 0;\n-      for (i=0; i<max_entries; i++)\n-\t{\n-\t  if (entry_used[i] &&\n-\t      (entry[i].low <= ptr) &&\n-\t      (entry[i].high >= ptr_high))\n-\t    deja_vu = 1;\n-\t}\n-\n-      if (! deja_vu)\n-\t{\n-\t  /* Time to run the heuristic.  Rescan /proc/self/maps; update the\n-\t     entry[] array; XXX: remove expired entries, add new ones.\n-\t     XXX: Consider entries that have grown (e.g., stack).  */\n-\t  char buf[512];\n-\t  char flags[4];\n-\t  void *low, *high;\n-\t  FILE *fp;\n-\n-\t  fp = fopen (\"/proc/self/maps\", \"r\");\n-\t  if (fp)\n-\t    {\n-\t      while (fgets (buf, sizeof(buf), fp))\n-\t\t{\n-\t\t  if (sscanf (buf, \"%p-%p %4c\", &low, &high, flags) == 3)\n-\t\t    {\n-\t\t      if ((uintptr_t) low <= ptr &&\n-\t\t\t  (uintptr_t) high >= ptr_high)\n-\t\t\t{\n-\t\t\t  for (i=0; i<max_entries; i++)\n-\t\t\t    {\n-\t\t\t      if (! entry_used[i])\n-\t\t\t\t{\n-\t\t\t\t  entry[i].low = (uintptr_t) low;\n-\t\t\t\t  entry[i].high = (uintptr_t) high;\n-\t\t\t\t  entry_used[i] = 1;\n-\t\t\t\t  break;\n-\t\t\t\t}\n-\t\t\t    }\n-\n-\t\t\t  VERBOSE_TRACE (\"mf: registering region #%d \"\n-\t\t\t\t\t \"%p-%p given %s\",\n-\t\t\t\t\t i, (void *) low, (void *) high, buf);\n-\n-\t\t\t  __mfu_register ((void *) low, (size_t) (high-low),\n-\t\t\t\t\t  __MF_TYPE_GUESS,\n-\t\t\t\t\t  \"/proc/self/maps segment\");\n-\n-\t\t\t  return 0; /* undecided (tending to cachable) */\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-\t      fclose (fp);\n-\t    }\n-\t}\n-    }\n-\n-\n-  /* The third heuristic is to approve all accesses between _start (or its\n-     equivalent for the given target) and _end, which should include all\n-     text and initialized data.  */\n-  if (__mf_opts.heur_start_end)\n-    if (ptr >= (uintptr_t) & ENTRY_POINT && ptr_high <= (uintptr_t) & _end)\n-      return 1; /* uncacheable */\n-\n-  return 0; /* unknown */\n-}"}, {"sha": "474c8356577ac11f42db8ca820621c9a44a91d4d", "filename": "libmudflap/mf-hooks1.c", "status": "removed", "additions": 0, "deletions": 555, "changes": 555, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Fmf-hooks1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Fmf-hooks1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-hooks1.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,555 +0,0 @@\n-/* Mudflap: narrow-pointer bounds-checking by tree rewriting.\n-   Copyright (C) 2002-2013 Free Software Foundation, Inc.\n-   Contributed by Frank Ch. Eigler <fche@redhat.com>\n-   and Graydon Hoare <graydon@redhat.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-\n-#ifndef HAVE_SOCKLEN_T\n-#define socklen_t int\n-#endif\n-\n-\n-/* These attempt to coax various unix flavours to declare all our\n-   needed tidbits in the system headers.  */\n-#if !defined(__FreeBSD__)  && !defined(__APPLE__)\n-#define _POSIX_SOURCE\n-#endif /* Some BSDs break <sys/socket.h> if this is defined. */\n-#define _GNU_SOURCE\n-#define _XOPEN_SOURCE\n-#define _BSD_TYPES\n-#define __EXTENSIONS__\n-#define _ALL_SOURCE\n-#define _LARGE_FILE_API\n-#define _XOPEN_SOURCE_EXTENDED 1\n-\n-#include <string.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <sys/time.h>\n-#include <sys/types.h>\n-#include <unistd.h>\n-#include <assert.h>\n-#include <errno.h>\n-#include <limits.h>\n-#include <time.h>\n-\n-#include \"mf-runtime.h\"\n-#include \"mf-impl.h\"\n-\n-#ifdef _MUDFLAP\n-#error \"Do not compile this file with -fmudflap!\"\n-#endif\n-\n-\n-/* Memory allocation related hook functions.  Some of these are\n-   intercepted via linker wrapping or symbol interposition.  Others\n-   use plain macros in mf-runtime.h.  */\n-\n-\n-#if PIC\n-\n-enum { BS = 4096, NB=10 };\n-static char __mf_0fn_bufs[NB][BS];\n-static unsigned __mf_0fn_bufs_used[NB];\n-\n-\n-/* A special bootstrap variant. */\n-void *\n-__mf_0fn_malloc (size_t c)\n-{\n-  unsigned i;\n-\n-  for (i=0; i<NB; i++)\n-    {\n-      if (! __mf_0fn_bufs_used[i] && c < BS)\n-\t{\n-\t  __mf_0fn_bufs_used[i] = 1;\n-\t  return & __mf_0fn_bufs[i][0];\n-\t}\n-    }\n-  return NULL;\n-}\n-#endif\n-\n-\n-#undef malloc\n-WRAPPER(void *, malloc, size_t c)\n-{\n-  size_t size_with_crumple_zones;\n-  DECLARE(void *, malloc, size_t c);\n-  void *result;\n-  BEGIN_PROTECT (malloc, c);\n-\n-  size_with_crumple_zones =\n-    CLAMPADD(c,CLAMPADD(__mf_opts.crumple_zone,\n-\t\t\t__mf_opts.crumple_zone));\n-  BEGIN_MALLOC_PROTECT ();\n-  result = (char *) CALL_REAL (malloc, size_with_crumple_zones);\n-  END_MALLOC_PROTECT ();\n-\n-  if (LIKELY(result))\n-    {\n-      result += __mf_opts.crumple_zone;\n-      __mf_register (result, c, __MF_TYPE_HEAP, \"malloc region\");\n-      /* XXX: register __MF_TYPE_NOACCESS for crumple zones.  */\n-    }\n-\n-  return result;\n-}\n-\n-\n-#ifdef PIC\n-/* A special bootstrap variant. */\n-void *\n-__mf_0fn_calloc (size_t c, size_t n)\n-{\n-  return __mf_0fn_malloc (c * n);\n-}\n-#endif\n-\n-\n-#undef calloc\n-WRAPPER(void *, calloc, size_t c, size_t n)\n-{\n-  size_t size_with_crumple_zones;\n-  DECLARE(void *, calloc, size_t, size_t);\n-  DECLARE(void *, malloc, size_t);\n-  DECLARE(void *, memset, void *, int, size_t);\n-  char *result;\n-  BEGIN_PROTECT (calloc, c, n);\n-\n-  size_with_crumple_zones =\n-    CLAMPADD((c * n), /* XXX: CLAMPMUL */\n-\t     CLAMPADD(__mf_opts.crumple_zone,\n-\t\t      __mf_opts.crumple_zone));\n-  BEGIN_MALLOC_PROTECT ();\n-  result = (char *) CALL_REAL (malloc, size_with_crumple_zones);\n-  END_MALLOC_PROTECT ();\n-\n-  if (LIKELY(result))\n-    memset (result, 0, size_with_crumple_zones);\n-\n-  if (LIKELY(result))\n-    {\n-      result += __mf_opts.crumple_zone;\n-      __mf_register (result, c*n /* XXX: clamp */, __MF_TYPE_HEAP_I, \"calloc region\");\n-      /* XXX: register __MF_TYPE_NOACCESS for crumple zones.  */\n-    }\n-\n-  return result;\n-}\n-\n-\n-#if PIC\n-/* A special bootstrap variant. */\n-void *\n-__mf_0fn_realloc (void *buf, size_t c)\n-{\n-  return NULL;\n-}\n-#endif\n-\n-\n-#undef realloc\n-WRAPPER(void *, realloc, void *buf, size_t c)\n-{\n-  DECLARE(void * , realloc, void *, size_t);\n-  size_t size_with_crumple_zones;\n-  char *base = buf;\n-  unsigned saved_wipe_heap;\n-  char *result;\n-  BEGIN_PROTECT (realloc, buf, c);\n-\n-  if (LIKELY(buf))\n-    base -= __mf_opts.crumple_zone;\n-\n-  size_with_crumple_zones =\n-    CLAMPADD(c, CLAMPADD(__mf_opts.crumple_zone,\n-\t\t\t __mf_opts.crumple_zone));\n-  BEGIN_MALLOC_PROTECT ();\n-  result = (char *) CALL_REAL (realloc, base, size_with_crumple_zones);\n-  END_MALLOC_PROTECT ();\n-\n-  /* Ensure heap wiping doesn't occur during this peculiar\n-     unregister/reregister pair.  */\n-  LOCKTH ();\n-  __mf_set_state (reentrant);\n-  saved_wipe_heap = __mf_opts.wipe_heap;\n-  __mf_opts.wipe_heap = 0;\n-\n-  if (LIKELY(buf))\n-    __mfu_unregister (buf, 0, __MF_TYPE_HEAP_I);\n-  /* NB: underlying region may have been __MF_TYPE_HEAP. */\n-\n-  if (LIKELY(result))\n-    {\n-      result += __mf_opts.crumple_zone;\n-      __mfu_register (result, c, __MF_TYPE_HEAP_I, \"realloc region\");\n-      /* XXX: register __MF_TYPE_NOACCESS for crumple zones.  */\n-    }\n-\n-  /* Restore previous setting.  */\n-  __mf_opts.wipe_heap = saved_wipe_heap;\n-\n-  __mf_set_state (active);\n-  UNLOCKTH ();\n-\n-  return result;\n-}\n-\n-\n-#if PIC\n-/* A special bootstrap variant. */\n-void\n-__mf_0fn_free (void *buf)\n-{\n-  return;\n-}\n-#endif\n-\n-#undef free\n-WRAPPER(void, free, void *buf)\n-{\n-  /* Use a circular queue to delay some number (__mf_opts.free_queue_length) of free()s.  */\n-  static void *free_queue [__MF_FREEQ_MAX];\n-  static unsigned free_ptr = 0;\n-  static int freeq_initialized = 0;\n-  DECLARE(void, free, void *);\n-\n-  if (UNLIKELY(buf == NULL))\n-    return;\n-\n-  BEGIN_PROTECT (free, buf);\n-\n-#if PIC\n-  /* Check whether the given buffer might have come from a\n-     __mf_0fn_malloc/calloc call that for whatever reason was not\n-     redirected back to __mf_0fn_free.  If so, we just ignore the\n-     call. */\n-  if (UNLIKELY((uintptr_t) buf >= (uintptr_t) __mf_0fn_bufs &&\n-               (uintptr_t) buf < ((uintptr_t) __mf_0fn_bufs + sizeof(__mf_0fn_bufs))))\n-  {\n-    VERBOSE_TRACE (\"skipping free of boot (0fn) alloc buffer %p\\n\", buf);\n-    return;\n-  }\n-#endif\n-\n-  LOCKTH ();\n-  if (UNLIKELY(!freeq_initialized))\n-    {\n-      memset (free_queue, 0,\n-\t\t     __MF_FREEQ_MAX * sizeof (void *));\n-      freeq_initialized = 1;\n-    }\n-  UNLOCKTH ();\n-\n-  __mf_unregister (buf, 0, __MF_TYPE_HEAP_I);\n-  /* NB: underlying region may have been __MF_TYPE_HEAP. */\n-\n-  if (UNLIKELY(__mf_opts.free_queue_length > 0))\n-    {\n-      char *freeme = NULL;\n-      LOCKTH ();\n-      if (free_queue [free_ptr] != NULL)\n-\t{\n-\t  freeme = free_queue [free_ptr];\n-\t  freeme -= __mf_opts.crumple_zone;\n-\t}\n-      free_queue [free_ptr] = buf;\n-      free_ptr = (free_ptr == (__mf_opts.free_queue_length-1) ? 0 : free_ptr + 1);\n-      UNLOCKTH ();\n-      if (freeme)\n-\t{\n-\t  if (__mf_opts.trace_mf_calls)\n-\t    {\n-\t      VERBOSE_TRACE (\"freeing deferred pointer %p (crumple %u)\\n\",\n-\t\t\t     (void *) freeme,\n-\t\t\t     __mf_opts.crumple_zone);\n-\t    }\n-\t  BEGIN_MALLOC_PROTECT ();\n-\t  CALL_REAL (free, freeme);\n-\t  END_MALLOC_PROTECT ();\n-\t}\n-    }\n-  else\n-    {\n-      /* back pointer up a bit to the beginning of crumple zone */\n-      char *base = (char *)buf;\n-      base -= __mf_opts.crumple_zone;\n-      if (__mf_opts.trace_mf_calls)\n-\t{\n-\t  VERBOSE_TRACE (\"freeing pointer %p = %p - %u\\n\",\n-\t\t\t (void *) base,\n-\t\t\t (void *) buf,\n-\t\t\t __mf_opts.crumple_zone);\n-\t}\n-      BEGIN_MALLOC_PROTECT ();\n-      CALL_REAL (free, base);\n-      END_MALLOC_PROTECT ();\n-    }\n-}\n-\n-\n-/* We can only wrap mmap if the target supports it.  Likewise for munmap.\n-   We assume we have both if we have mmap.  */\n-#ifdef HAVE_MMAP\n-\n-#if PIC\n-/* A special bootstrap variant. */\n-void *\n-__mf_0fn_mmap (void *start, size_t l, int prot, int f, int fd, off_t off)\n-{\n-#if defined(__FreeBSD__)\n-  if (f == 0x1000 && fd == -1 && prot == 0 && off == 0)\n-    return 0;\n-#endif /* Ignore red zone allocation request for initial thread's stack. */\n-\n-  return (void *) -1;\n-}\n-#endif\n-\n-\n-#undef mmap\n-WRAPPER(void *, mmap,\n-\tvoid  *start,  size_t length, int prot,\n-\tint flags, int fd, off_t offset)\n-{\n-  DECLARE(void *, mmap, void *, size_t, int,\n-\t\t\t    int, int, off_t);\n-  void *result;\n-  BEGIN_PROTECT (mmap, start, length, prot, flags, fd, offset);\n-\n-  result = CALL_REAL (mmap, start, length, prot,\n-\t\t\tflags, fd, offset);\n-\n-  /*\n-  VERBOSE_TRACE (\"mmap (%08lx, %08lx, ...) => %08lx\\n\",\n-\t\t (uintptr_t) start, (uintptr_t) length,\n-\t\t (uintptr_t) result);\n-  */\n-\n-  if (result != (void *)-1)\n-    {\n-      /* Register each page as a heap object.  Why not register it all\n-\t as a single segment?  That's so that a later munmap() call\n-\t can unmap individual pages.  XXX: would __MF_TYPE_GUESS make\n-\t this more automatic?  */\n-      size_t ps = getpagesize ();\n-      uintptr_t base = (uintptr_t) result;\n-      uintptr_t offset;\n-\n-      for (offset=0; offset<length; offset+=ps)\n-\t{\n-\t  /* XXX: We could map PROT_NONE to __MF_TYPE_NOACCESS. */\n-\t  /* XXX: Unaccessed HEAP pages are reported as leaks.  Is this\n-\t     appropriate for unaccessed mmap pages? */\n-\t  __mf_register ((void *) CLAMPADD (base, offset), ps,\n-\t\t\t __MF_TYPE_HEAP_I, \"mmap page\");\n-\t}\n-    }\n-\n-  return result;\n-}\n-\n-\n-#if PIC\n-/* A special bootstrap variant. */\n-int\n-__mf_0fn_munmap (void *start, size_t length)\n-{\n-  return -1;\n-}\n-#endif\n-\n-\n-#undef munmap\n-WRAPPER(int , munmap, void *start, size_t length)\n-{\n-  DECLARE(int, munmap, void *, size_t);\n-  int result;\n-  BEGIN_PROTECT (munmap, start, length);\n-\n-  result = CALL_REAL (munmap, start, length);\n-\n-  /*\n-  VERBOSE_TRACE (\"munmap (%08lx, %08lx, ...) => %08lx\\n\",\n-\t\t (uintptr_t) start, (uintptr_t) length,\n-\t\t (uintptr_t) result);\n-  */\n-\n-  if (result == 0)\n-    {\n-      /* Unregister each page as a heap object.  */\n-      size_t ps = getpagesize ();\n-      uintptr_t base = (uintptr_t) start & (~ (ps - 1)); /* page align */\n-      uintptr_t offset;\n-\n-      for (offset=0; offset<length; offset+=ps)\n-\t__mf_unregister ((void *) CLAMPADD (base, offset), ps, __MF_TYPE_HEAP_I);\n-    }\n-  return result;\n-}\n-#endif /* HAVE_MMAP */\n-\n-\n-#ifdef HAVE_MMAP64\n-#if PIC\n-/* A special bootstrap variant. */\n-void *\n-__mf_0fn_mmap64 (void *start, size_t l, int prot, int f, int fd, off64_t off)\n-{\n-  return (void *) -1;\n-}\n-#endif\n-\n-\n-#undef mmap\n-WRAPPER(void *, mmap64,\n-\tvoid  *start,  size_t length, int prot,\n-\tint flags, int fd, off64_t offset)\n-{\n-  DECLARE(void *, mmap64, void *, size_t, int,\n-\t\t\t    int, int, off64_t);\n-  void *result;\n-  BEGIN_PROTECT (mmap64, start, length, prot, flags, fd, offset);\n-\n-  result = CALL_REAL (mmap64, start, length, prot,\n-\t\t\tflags, fd, offset);\n-\n-  /*\n-  VERBOSE_TRACE (\"mmap64 (%08lx, %08lx, ...) => %08lx\\n\",\n-\t\t (uintptr_t) start, (uintptr_t) length,\n-\t\t (uintptr_t) result);\n-  */\n-\n-  if (result != (void *)-1)\n-    {\n-      /* Register each page as a heap object.  Why not register it all\n-\t as a single segment?  That's so that a later munmap() call\n-\t can unmap individual pages.  XXX: would __MF_TYPE_GUESS make\n-\t this more automatic?  */\n-      size_t ps = getpagesize ();\n-      uintptr_t base = (uintptr_t) result;\n-      uintptr_t offset;\n-\n-      for (offset=0; offset<length; offset+=ps)\n-\t{\n-\t  /* XXX: We could map PROT_NONE to __MF_TYPE_NOACCESS. */\n-\t  /* XXX: Unaccessed HEAP pages are reported as leaks.  Is this\n-\t     appropriate for unaccessed mmap pages? */\n-\t  __mf_register ((void *) CLAMPADD (base, offset), ps,\n-\t\t\t __MF_TYPE_HEAP_I, \"mmap64 page\");\n-\t}\n-    }\n-\n-  return result;\n-}\n-#endif /* HAVE_MMAP64 */\n-\n-\n-/* This wrapper is a little different, as it's called indirectly from\n-   __mf_fini also to clean up pending allocations.  */\n-void *\n-__mf_wrap_alloca_indirect (size_t c)\n-{\n-  DECLARE (void *, malloc, size_t);\n-  DECLARE (void, free, void *);\n-\n-  /* This struct, a linked list, tracks alloca'd objects.  The newest\n-     object is at the head of the list.  If we detect that we've\n-     popped a few levels of stack, then the listed objects are freed\n-     as needed.  NB: The tracking struct is allocated with\n-     real_malloc; the user data with wrap_malloc.\n-  */\n-  struct alloca_tracking { void *ptr; void *stack; struct alloca_tracking* next; };\n-  static struct alloca_tracking *alloca_history = NULL;\n-\n-  void *stack = __builtin_frame_address (0);\n-  void *result;\n-  struct alloca_tracking *track;\n-\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  VERBOSE_TRACE (\"alloca stack level %p\\n\", (void *) stack);\n-\n-  /* XXX: thread locking! */\n-\n-  /* Free any previously alloca'd blocks that belong to deeper-nested functions,\n-     which must therefore have exited by now.  */\n-\n-#define DEEPER_THAN < /* XXX: for x86; steal find_stack_direction() from libiberty/alloca.c */\n-\n-  while (alloca_history &&\n-\t ((uintptr_t) alloca_history->stack DEEPER_THAN (uintptr_t) stack))\n-    {\n-      struct alloca_tracking *next = alloca_history->next;\n-      __mf_unregister (alloca_history->ptr, 0, __MF_TYPE_HEAP);\n-      BEGIN_MALLOC_PROTECT ();\n-      CALL_REAL (free, alloca_history->ptr);\n-      CALL_REAL (free, alloca_history);\n-      END_MALLOC_PROTECT ();\n-      alloca_history = next;\n-    }\n-\n-  /* Allocate new block.  */\n-  result = NULL;\n-  if (LIKELY (c > 0)) /* alloca(0) causes no allocation.  */\n-    {\n-      BEGIN_MALLOC_PROTECT ();\n-      track = (struct alloca_tracking *) CALL_REAL (malloc,\n-\t\t\t\t\t\t    sizeof (struct alloca_tracking));\n-      END_MALLOC_PROTECT ();\n-      if (LIKELY (track != NULL))\n-\t{\n-\t  BEGIN_MALLOC_PROTECT ();\n-\t  result = CALL_REAL (malloc, c);\n-\t  END_MALLOC_PROTECT ();\n-\t  if (UNLIKELY (result == NULL))\n-\t    {\n-\t      BEGIN_MALLOC_PROTECT ();\n-\t      CALL_REAL (free, track);\n-\t      END_MALLOC_PROTECT ();\n-\t      /* Too bad.  XXX: What about errno?  */\n-\t    }\n-\t  else\n-\t    {\n-\t      __mf_register (result, c, __MF_TYPE_HEAP, \"alloca region\");\n-\t      track->ptr = result;\n-\t      track->stack = stack;\n-\t      track->next = alloca_history;\n-\t      alloca_history = track;\n-\t    }\n-\t}\n-    }\n-\n-  return result;\n-}\n-\n-\n-#undef alloca\n-WRAPPER(void *, alloca, size_t c)\n-{\n-  return __mf_wrap_alloca_indirect (c);\n-}\n-"}, {"sha": "4af17df221476467b2f0a8cd2df3913078cb6fa5", "filename": "libmudflap/mf-hooks2.c", "status": "removed", "additions": 0, "deletions": 2198, "changes": 2198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Fmf-hooks2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Fmf-hooks2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-hooks2.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,2198 +0,0 @@\n-/* Mudflap: narrow-pointer bounds-checking by tree rewriting.\n-   Copyright (C) 2002-2013 Free Software Foundation, Inc.\n-   Contributed by Frank Ch. Eigler <fche@redhat.com>\n-   and Graydon Hoare <graydon@redhat.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-\n-#ifndef HAVE_SOCKLEN_T\n-#define socklen_t int\n-#endif\n-\n-/* These attempt to coax various unix flavours to declare all our\n-   needed tidbits in the system headers.  */\n-#if !defined(__FreeBSD__) && !defined(__APPLE__)\n-#define _POSIX_SOURCE\n-#endif /* Some BSDs break <sys/socket.h> if this is defined. */\n-#define _GNU_SOURCE\n-#define _XOPEN_SOURCE\n-#define _BSD_TYPES\n-#define __EXTENSIONS__\n-#define _ALL_SOURCE\n-#define _LARGE_FILE_API\n-#define _LARGEFILE64_SOURCE\n-#define _XOPEN_SOURCE_EXTENDED 1\n-\n-#include <string.h>\n-#include <stdarg.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <sys/stat.h>\n-#include <sys/time.h>\n-#include <sys/types.h>\n-#include <unistd.h>\n-#include <assert.h>\n-#include <errno.h>\n-#include <limits.h>\n-#include <time.h>\n-#include <ctype.h>\n-#ifdef HAVE_DLFCN_H\n-#include <dlfcn.h>\n-#endif\n-#ifdef HAVE_DIRENT_H\n-#include <dirent.h>\n-#endif\n-#ifdef HAVE_SYS_SOCKET_H\n-#include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETDB_H\n-#include <netdb.h>\n-#endif\n-#ifdef HAVE_SYS_WAIT_H\n-#include <sys/wait.h>\n-#endif\n-#ifdef HAVE_SYS_IPC_H\n-#include <sys/ipc.h>\n-#endif\n-#ifdef HAVE_SYS_SEM_H\n-#include <sys/sem.h>\n-#endif\n-#ifdef HAVE_SYS_SHM_H\n-#include <sys/shm.h>\n-#endif\n-#ifdef HAVE_PWD_H\n-#include <pwd.h>\n-#endif\n-#ifdef HAVE_GRP_H\n-#include <grp.h>\n-#endif\n-#ifdef HAVE_MNTENT_H\n-#include <mntent.h>\n-#endif\n-#ifdef HAVE_SYS_MNTTAB_H\n-#include <sys/mnttab.h>\n-#endif\n-#ifdef HAVE_SYS_SOCKET_H\n-#include <sys/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#include <netinet/in.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#include <arpa/inet.h>\n-#endif\n-\n-#include \"mf-runtime.h\"\n-#include \"mf-impl.h\"\n-\n-#ifdef _MUDFLAP\n-#error \"Do not compile this file with -fmudflap!\"\n-#endif\n-\n-\n-/* A bunch of independent stdlib/unistd hook functions, all\n-   intercepted by mf-runtime.h macros.  */\n-\n-#ifndef HAVE_STRNLEN\n-static inline size_t (strnlen) (const char* str, size_t n)\n-{\n-  const char *s;\n-\n-  for (s = str; n && *s; ++s, --n)\n-    ;\n-  return (s - str);\n-}\n-#endif\n-\n-\n-/* str*,mem*,b* */\n-\n-WRAPPER2(void *, memcpy, void *dest, const void *src, size_t n)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(src, n, __MF_CHECK_READ, \"memcpy source\");\n-  MF_VALIDATE_EXTENT(dest, n, __MF_CHECK_WRITE, \"memcpy dest\");\n-  return memcpy (dest, src, n);\n-}\n-\n-\n-WRAPPER2(void *, memmove, void *dest, const void *src, size_t n)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(src, n, __MF_CHECK_READ, \"memmove src\");\n-  MF_VALIDATE_EXTENT(dest, n, __MF_CHECK_WRITE, \"memmove dest\");\n-  return memmove (dest, src, n);\n-}\n-\n-\n-WRAPPER2(void *, memset, void *s, int c, size_t n)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(s, n, __MF_CHECK_WRITE, \"memset dest\");\n-  return memset (s, c, n);\n-}\n-\n-\n-WRAPPER2(int, memcmp, const void *s1, const void *s2, size_t n)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(s1, n, __MF_CHECK_READ, \"memcmp 1st arg\");\n-  MF_VALIDATE_EXTENT(s2, n, __MF_CHECK_READ, \"memcmp 2nd arg\");\n-  return memcmp (s1, s2, n);\n-}\n-\n-\n-WRAPPER2(void *, memchr, const void *s, int c, size_t n)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(s, n, __MF_CHECK_READ, \"memchr region\");\n-  return memchr (s, c, n);\n-}\n-\n-\n-#ifdef HAVE_MEMRCHR\n-WRAPPER2(void *, memrchr, const void *s, int c, size_t n)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(s, n, __MF_CHECK_READ, \"memrchr region\");\n-  return memrchr (s, c, n);\n-}\n-#endif\n-\n-\n-WRAPPER2(char *, strcpy, char *dest, const char *src)\n-{\n-  /* nb: just because strlen(src) == n doesn't mean (src + n) or (src + n +\n-     1) are valid pointers. the allocated object might have size < n.\n-     check anyways. */\n-\n-  size_t n = strlen (src);\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(src, CLAMPADD(n, 1), __MF_CHECK_READ, \"strcpy src\");\n-  MF_VALIDATE_EXTENT(dest, CLAMPADD(n, 1), __MF_CHECK_WRITE, \"strcpy dest\");\n-  return strcpy (dest, src);\n-}\n-\n-\n-#ifdef HAVE_STRNCPY\n-WRAPPER2(char *, strncpy, char *dest, const char *src, size_t n)\n-{\n-  size_t len = strnlen (src, n);\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(src, len, __MF_CHECK_READ, \"strncpy src\");\n-  MF_VALIDATE_EXTENT(dest, len, __MF_CHECK_WRITE, \"strncpy dest\"); /* nb: strNcpy */\n-  return strncpy (dest, src, n);\n-}\n-#endif\n-\n-\n-WRAPPER2(char *, strcat, char *dest, const char *src)\n-{\n-  size_t dest_sz;\n-  size_t src_sz;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  dest_sz = strlen (dest);\n-  src_sz = strlen (src);\n-  MF_VALIDATE_EXTENT(src, CLAMPADD(src_sz, 1), __MF_CHECK_READ, \"strcat src\");\n-  MF_VALIDATE_EXTENT(dest, CLAMPADD(dest_sz, CLAMPADD(src_sz, 1)),\n-\t\t     __MF_CHECK_WRITE, \"strcat dest\");\n-  return strcat (dest, src);\n-}\n-\n-\n-WRAPPER2(char *, strncat, char *dest, const char *src, size_t n)\n-{\n-\n-  /* nb: validating the extents (s,n) might be a mistake for two reasons.\n-\n-  (1) the string s might be shorter than n chars, and n is just a\n-  poor choice by the programmer. this is not a \"true\" error in the\n-  sense that the call to strncat would still be ok.\n-\n-  (2) we could try to compensate for case (1) by calling strlen(s) and\n-  using that as a bound for the extent to verify, but strlen might fall off\n-  the end of a non-terminated string, leading to a false positive.\n-\n-  so we will call strnlen(s,n) and use that as a bound.\n-\n-  if strnlen returns a length beyond the end of the registered extent\n-  associated with s, there is an error: the programmer's estimate for n is\n-  too large _AND_ the string s is unterminated, in which case they'd be\n-  about to touch memory they don't own while calling strncat.\n-\n-  this same logic applies to further uses of strnlen later down in this\n-  file. */\n-\n-  size_t src_sz;\n-  size_t dest_sz;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  src_sz = strnlen (src, n);\n-  dest_sz = strnlen (dest, n);\n-  MF_VALIDATE_EXTENT(src, src_sz, __MF_CHECK_READ, \"strncat src\");\n-  MF_VALIDATE_EXTENT(dest, (CLAMPADD(dest_sz, CLAMPADD(src_sz, 1))),\n-\t\t     __MF_CHECK_WRITE, \"strncat dest\");\n-  return strncat (dest, src, n);\n-}\n-\n-\n-WRAPPER2(int, strcmp, const char *s1, const char *s2)\n-{\n-  size_t s1_sz;\n-  size_t s2_sz;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  s1_sz = strlen (s1);\n-  s2_sz = strlen (s2);\n-  MF_VALIDATE_EXTENT(s1, CLAMPADD(s1_sz, 1), __MF_CHECK_READ, \"strcmp 1st arg\");\n-  MF_VALIDATE_EXTENT(s2, CLAMPADD(s2_sz, 1), __MF_CHECK_WRITE, \"strcmp 2nd arg\");\n-  return strcmp (s1, s2);\n-}\n-\n-\n-WRAPPER2(int, strcasecmp, const char *s1, const char *s2)\n-{\n-  size_t s1_sz;\n-  size_t s2_sz;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  s1_sz = strlen (s1);\n-  s2_sz = strlen (s2);\n-  MF_VALIDATE_EXTENT(s1, CLAMPADD(s1_sz, 1), __MF_CHECK_READ, \"strcasecmp 1st arg\");\n-  MF_VALIDATE_EXTENT(s2, CLAMPADD(s2_sz, 1), __MF_CHECK_READ, \"strcasecmp 2nd arg\");\n-  return strcasecmp (s1, s2);\n-}\n-\n-\n-WRAPPER2(int, strncmp, const char *s1, const char *s2, size_t n)\n-{\n-  size_t s1_sz;\n-  size_t s2_sz;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  s1_sz = strnlen (s1, n);\n-  s2_sz = strnlen (s2, n);\n-  MF_VALIDATE_EXTENT(s1, s1_sz, __MF_CHECK_READ, \"strncmp 1st arg\");\n-  MF_VALIDATE_EXTENT(s2, s2_sz, __MF_CHECK_READ, \"strncmp 2nd arg\");\n-  return strncmp (s1, s2, n);\n-}\n-\n-\n-WRAPPER2(int, strncasecmp, const char *s1, const char *s2, size_t n)\n-{\n-  size_t s1_sz;\n-  size_t s2_sz;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  s1_sz = strnlen (s1, n);\n-  s2_sz = strnlen (s2, n);\n-  MF_VALIDATE_EXTENT(s1, s1_sz, __MF_CHECK_READ, \"strncasecmp 1st arg\");\n-  MF_VALIDATE_EXTENT(s2, s2_sz, __MF_CHECK_READ, \"strncasecmp 2nd arg\");\n-  return strncasecmp (s1, s2, n);\n-}\n-\n-\n-WRAPPER2(char *, strdup, const char *s)\n-{\n-  DECLARE(void *, malloc, size_t sz);\n-  char *result;\n-  size_t n = strlen (s);\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(s, CLAMPADD(n,1), __MF_CHECK_READ, \"strdup region\");\n-  result = (char *)CALL_REAL(malloc,\n-\t\t\t     CLAMPADD(CLAMPADD(n,1),\n-\t\t\t\t      CLAMPADD(__mf_opts.crumple_zone,\n-\t\t\t\t\t       __mf_opts.crumple_zone)));\n-\n-  if (UNLIKELY(! result)) return result;\n-\n-  result += __mf_opts.crumple_zone;\n-  memcpy (result, s, n);\n-  result[n] = '\\0';\n-\n-  __mf_register (result, CLAMPADD(n,1), __MF_TYPE_HEAP_I, \"strdup region\");\n-  return result;\n-}\n-\n-\n-WRAPPER2(char *, strndup, const char *s, size_t n)\n-{\n-  DECLARE(void *, malloc, size_t sz);\n-  char *result;\n-  size_t sz = strnlen (s, n);\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(s, sz, __MF_CHECK_READ, \"strndup region\"); /* nb: strNdup */\n-\n-  /* note: strndup still adds a \\0, even with the N limit! */\n-  result = (char *)CALL_REAL(malloc,\n-\t\t\t     CLAMPADD(CLAMPADD(n,1),\n-\t\t\t\t      CLAMPADD(__mf_opts.crumple_zone,\n-\t\t\t\t\t       __mf_opts.crumple_zone)));\n-\n-  if (UNLIKELY(! result)) return result;\n-\n-  result += __mf_opts.crumple_zone;\n-  memcpy (result, s, n);\n-  result[n] = '\\0';\n-\n-  __mf_register (result, CLAMPADD(n,1), __MF_TYPE_HEAP_I, \"strndup region\");\n-  return result;\n-}\n-\n-\n-WRAPPER2(char *, strchr, const char *s, int c)\n-{\n-  size_t n;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  n = strlen (s);\n-  MF_VALIDATE_EXTENT(s, CLAMPADD(n,1), __MF_CHECK_READ, \"strchr region\");\n-  return strchr (s, c);\n-}\n-\n-\n-WRAPPER2(char *, strrchr, const char *s, int c)\n-{\n-  size_t n;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  n = strlen (s);\n-  MF_VALIDATE_EXTENT(s, CLAMPADD(n,1), __MF_CHECK_READ, \"strrchr region\");\n-  return strrchr (s, c);\n-}\n-\n-\n-WRAPPER2(char *, strstr, const char *haystack, const char *needle)\n-{\n-  size_t haystack_sz;\n-  size_t needle_sz;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  haystack_sz = strlen (haystack);\n-  needle_sz = strlen (needle);\n-  MF_VALIDATE_EXTENT(haystack, CLAMPADD(haystack_sz, 1), __MF_CHECK_READ, \"strstr haystack\");\n-  MF_VALIDATE_EXTENT(needle, CLAMPADD(needle_sz, 1), __MF_CHECK_READ, \"strstr needle\");\n-  return strstr (haystack, needle);\n-}\n-\n-\n-#ifdef HAVE_MEMMEM\n-WRAPPER2(void *, memmem,\n-\tconst void *haystack, size_t haystacklen,\n-\tconst void *needle, size_t needlelen)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(haystack, haystacklen, __MF_CHECK_READ, \"memmem haystack\");\n-  MF_VALIDATE_EXTENT(needle, needlelen, __MF_CHECK_READ, \"memmem needle\");\n-  return memmem (haystack, haystacklen, needle, needlelen);\n-}\n-#endif\n-\n-\n-WRAPPER2(size_t, strlen, const char *s)\n-{\n-  size_t result = strlen (s);\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(s, CLAMPADD(result, 1), __MF_CHECK_READ, \"strlen region\");\n-  return result;\n-}\n-\n-\n-WRAPPER2(size_t, strnlen, const char *s, size_t n)\n-{\n-  size_t result = strnlen (s, n);\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(s, result, __MF_CHECK_READ, \"strnlen region\");\n-  return result;\n-}\n-\n-\n-WRAPPER2(void, bzero, void *s, size_t n)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(s, n, __MF_CHECK_WRITE, \"bzero region\");\n-  bzero (s, n);\n-}\n-\n-\n-#undef bcopy\n-WRAPPER2(void, bcopy, const void *src, void *dest, size_t n)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(src, n, __MF_CHECK_READ, \"bcopy src\");\n-  MF_VALIDATE_EXTENT(dest, n, __MF_CHECK_WRITE, \"bcopy dest\");\n-  bcopy (src, dest, n);\n-}\n-\n-\n-#undef bcmp\n-WRAPPER2(int, bcmp, const void *s1, const void *s2, size_t n)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(s1, n, __MF_CHECK_READ, \"bcmp 1st arg\");\n-  MF_VALIDATE_EXTENT(s2, n, __MF_CHECK_READ, \"bcmp 2nd arg\");\n-  return bcmp (s1, s2, n);\n-}\n-\n-\n-WRAPPER2(char *, index, const char *s, int c)\n-{\n-  size_t n = strlen (s);\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(s, CLAMPADD(n, 1), __MF_CHECK_READ, \"index region\");\n-  return index (s, c);\n-}\n-\n-\n-WRAPPER2(char *, rindex, const char *s, int c)\n-{\n-  size_t n = strlen (s);\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(s, CLAMPADD(n, 1), __MF_CHECK_READ, \"rindex region\");\n-  return rindex (s, c);\n-}\n-\n-/* XXX:  stpcpy, memccpy */\n-\n-/* XXX: *printf,*scanf */\n-\n-/* XXX: setjmp, longjmp */\n-\n-WRAPPER2(char *, asctime, struct tm *tm)\n-{\n-  static char *reg_result = NULL;\n-  char *result;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(tm, sizeof (struct tm), __MF_CHECK_READ, \"asctime tm\");\n-  result = asctime (tm);\n-  if (reg_result == NULL)\n-    {\n-      __mf_register (result, strlen (result)+1, __MF_TYPE_STATIC, \"asctime string\");\n-      reg_result = result;\n-    }\n-  return result;\n-}\n-\n-\n-WRAPPER2(char *, ctime, const time_t *timep)\n-{\n-  static char *reg_result = NULL;\n-  char *result;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(timep, sizeof (time_t), __MF_CHECK_READ, \"ctime time\");\n-  result = ctime (timep);\n-  if (reg_result == NULL)\n-    {\n-      /* XXX: what if asctime and ctime return the same static ptr? */\n-      __mf_register (result, strlen (result)+1, __MF_TYPE_STATIC, \"ctime string\");\n-      reg_result = result;\n-    }\n-  return result;\n-}\n-\n-\n-WRAPPER2(struct tm*, localtime, const time_t *timep)\n-{\n-  static struct tm *reg_result = NULL;\n-  struct tm *result;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(timep, sizeof (time_t), __MF_CHECK_READ, \"localtime time\");\n-  result = localtime (timep);\n-  if (reg_result == NULL)\n-    {\n-      __mf_register (result, sizeof (struct tm), __MF_TYPE_STATIC, \"localtime tm\");\n-      reg_result = result;\n-    }\n-  return result;\n-}\n-\n-\n-WRAPPER2(struct tm*, gmtime, const time_t *timep)\n-{\n-  static struct tm *reg_result = NULL;\n-  struct tm *result;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT(timep, sizeof (time_t), __MF_CHECK_READ, \"gmtime time\");\n-  result = gmtime (timep);\n-  if (reg_result == NULL)\n-    {\n-      __mf_register (result, sizeof (struct tm), __MF_TYPE_STATIC, \"gmtime tm\");\n-      reg_result = result;\n-    }\n-  return result;\n-}\n-\n-\n-/* EL start */\n-\n-/* The following indicate if the result of the corresponding function\n- * should be explicitly un/registered by the wrapper\n-*/\n-\n-#ifdef __FreeBSD__\n-#define MF_REGISTER_fopen\t\t__MF_TYPE_STATIC\n-#else\n-#undef  MF_REGISTER_fopen\n-#endif\n-#define MF_RESULT_SIZE_fopen\t\t(sizeof (FILE))\n-\n-#undef  MF_REGISTER_opendir\n-#define MF_RESULT_SIZE_opendir\t\t0\t/* (sizeof (DIR)) */\n-#undef  MF_REGISTER_readdir\n-#define MF_REGISTER_gethostbyname\t__MF_TYPE_STATIC\n-#undef  MF_REGISTER_gethostbyname_items\n-#undef  MF_REGISTER_dlopen\n-#undef  MF_REGISTER_dlerror\n-#undef  MF_REGISTER_dlsym\n-#define MF_REGISTER_shmat\t\t__MF_TYPE_GUESS\n-\n-\n-#include <time.h>\n-WRAPPER2(time_t, time, time_t *timep)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  if (NULL != timep)\n-    MF_VALIDATE_EXTENT (timep, sizeof (*timep), __MF_CHECK_WRITE,\n-      \"time timep\");\n-  return time (timep);\n-}\n-\n-\n-WRAPPER2(char *, strerror, int errnum)\n-{\n-  char *p;\n-  static char * last_strerror = NULL;\n-\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  p = strerror (errnum);\n-  if (last_strerror != NULL)\n-    __mf_unregister (last_strerror, 0, __MF_TYPE_STATIC);\n-  if (NULL != p)\n-    __mf_register (p, strlen (p) + 1, __MF_TYPE_STATIC, \"strerror result\");\n-  last_strerror = p;\n-  return p;\n-}\n-\n-\n-\n-/* An auxiliary data structure for tracking the hand-made stdio\n-   buffers we generate during the fopen/fopen64 hooks.  In a civilized\n-   language, this would be a simple dynamically sized FILE*->char*\n-   lookup table, but this is C and we get to do it by hand.  */\n-struct mf_filebuffer\n-{\n-  FILE *file;\n-  char *buffer;\n-  struct mf_filebuffer *next;\n-};\n-static struct mf_filebuffer *mf_filebuffers = NULL;\n-\n-static void\n-mkbuffer (FILE *f)\n-{\n-  /* Reset any buffer automatically provided by libc, since this may\n-     have been done via mechanisms that libmudflap couldn't\n-     intercept.  */\n-  int rc;\n-  size_t bufsize = BUFSIZ;\n-  int bufmode;\n-  char *buffer = malloc (bufsize);\n-  struct mf_filebuffer *b = malloc (sizeof (struct mf_filebuffer));\n-  assert ((buffer != NULL) && (b != NULL));\n-\n-  /* Link it into list.  */\n-  b->file = f;\n-  b->buffer = buffer;\n-  b->next = mf_filebuffers;\n-  mf_filebuffers = b;\n-\n-  /* Determine how the file is supposed to be buffered at the moment.  */\n-  bufmode = fileno (f) == 2 ? _IONBF : (isatty (fileno (f)) ? _IOLBF : _IOFBF);\n-\n-  rc = setvbuf (f, buffer, bufmode, bufsize);\n-  assert (rc == 0);\n-}\n-\n-static void\n-unmkbuffer (FILE *f)\n-{\n-  struct mf_filebuffer *b = mf_filebuffers;\n-  struct mf_filebuffer **pb = & mf_filebuffers;\n-  while (b != NULL)\n-    {\n-      if (b->file == f)\n-        {\n-          *pb = b->next;\n-          free (b->buffer);\n-          free (b);\n-          return;\n-        }\n-      pb = & b->next;\n-      b = b->next;\n-    }\n-}\n-\n-\n-\n-WRAPPER2(FILE *, fopen, const char *path, const char *mode)\n-{\n-  size_t n;\n-  FILE *p;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-\n-  n = strlen (path);\n-  MF_VALIDATE_EXTENT (path, CLAMPADD(n, 1), __MF_CHECK_READ, \"fopen path\");\n-\n-  n = strlen (mode);\n-  MF_VALIDATE_EXTENT (mode, CLAMPADD(n, 1), __MF_CHECK_READ, \"fopen mode\");\n-\n-  p = fopen (path, mode);\n-  if (NULL != p) {\n-#ifdef MF_REGISTER_fopen\n-    __mf_register (p, sizeof (*p), MF_REGISTER_fopen, \"fopen result\");\n-#endif\n-    MF_VALIDATE_EXTENT (p, sizeof (*p), __MF_CHECK_WRITE, \"fopen result\");\n-\n-    mkbuffer (p);\n-  }\n-\n-  return p;\n-}\n-\n-\n-WRAPPER2(int, setvbuf, FILE *stream, char *buf, int mode, size_t size)\n-{\n-  int rc = 0;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE, \"setvbuf stream\");\n-\n-  unmkbuffer (stream);\n-\n-  if (buf != NULL)\n-    MF_VALIDATE_EXTENT (buf, size, __MF_CHECK_WRITE, \"setvbuf buffer\");\n-\n-  /* Override the user only if it's an auto-allocated buffer request.  Otherwise\n-     assume that the supplied buffer is already known to libmudflap.  */\n-  if ((buf == NULL) && ((mode == _IOFBF) || (mode == _IOLBF)))\n-    mkbuffer (stream);\n-  else\n-    rc = setvbuf (stream, buf, mode, size);\n-\n-  return rc;\n-}\n-\n-\n-#ifdef HAVE_SETBUF\n-WRAPPER2(int, setbuf, FILE* stream, char *buf)\n-{\n-  return __mfwrap_setvbuf (stream, buf, buf ? _IOFBF : _IONBF, BUFSIZ);\n-}\n-#endif\n-\n-#ifdef HAVE_SETBUFFER\n-WRAPPER2(int, setbuffer, FILE* stream, char *buf, size_t sz)\n-{\n-  return __mfwrap_setvbuf (stream, buf, buf ? _IOFBF : _IONBF, sz);\n-}\n-#endif\n-\n-#ifdef HAVE_SETLINEBUF\n-WRAPPER2(int, setlinebuf, FILE* stream)\n-{\n-  return __mfwrap_setvbuf(stream, NULL, _IOLBF, 0);\n-}\n-#endif\n-\n-\n-\n-WRAPPER2(FILE *, fdopen, int fd, const char *mode)\n-{\n-  size_t n;\n-  FILE *p;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-\n-  n = strlen (mode);\n-  MF_VALIDATE_EXTENT (mode, CLAMPADD(n, 1), __MF_CHECK_READ, \"fdopen mode\");\n-\n-  p = fdopen (fd, mode);\n-  if (NULL != p) {\n-#ifdef MF_REGISTER_fopen\n-    __mf_register (p, sizeof (*p), MF_REGISTER_fopen, \"fdopen result\");\n-#endif\n-    MF_VALIDATE_EXTENT (p, sizeof (*p), __MF_CHECK_WRITE, \"fdopen result\");\n-\n-    mkbuffer (p);\n-  }\n-\n-  return p;\n-}\n-\n-\n-WRAPPER2(FILE *, freopen, const char *path, const char *mode, FILE *s)\n-{\n-  size_t n;\n-  FILE *p;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-\n-  n = strlen (path);\n-  MF_VALIDATE_EXTENT (path, CLAMPADD(n, 1), __MF_CHECK_READ, \"freopen path\");\n-\n-  MF_VALIDATE_EXTENT (s, (sizeof (*s)), __MF_CHECK_WRITE, \"freopen stream\");\n-  unmkbuffer (s);\n-\n-  n = strlen (mode);\n-  MF_VALIDATE_EXTENT (mode, CLAMPADD(n, 1), __MF_CHECK_READ, \"freopen mode\");\n-\n-  p = freopen (path, mode, s);\n-  if (NULL != p) {\n-#ifdef MF_REGISTER_fopen\n-    __mf_register (p, sizeof (*p), MF_REGISTER_fopen, \"freopen result\");\n-#endif\n-    MF_VALIDATE_EXTENT (p, sizeof (*p), __MF_CHECK_WRITE, \"freopen result\");\n-\n-    mkbuffer (p);\n-  }\n-\n-  return p;\n-}\n-\n-\n-#ifdef HAVE_FOPEN64\n-WRAPPER2(FILE *, fopen64, const char *path, const char *mode)\n-{\n-  size_t n;\n-  FILE *p;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-\n-  n = strlen (path);\n-  MF_VALIDATE_EXTENT (path, CLAMPADD(n, 1), __MF_CHECK_READ, \"fopen64 path\");\n-\n-  n = strlen (mode);\n-  MF_VALIDATE_EXTENT (mode, CLAMPADD(n, 1), __MF_CHECK_READ, \"fopen64 mode\");\n-\n-  p = fopen64 (path, mode);\n-  if (NULL != p) {\n-#ifdef MF_REGISTER_fopen\n-    __mf_register (p, sizeof (*p), MF_REGISTER_fopen, \"fopen64 result\");\n-#endif\n-    MF_VALIDATE_EXTENT (p, sizeof (*p), __MF_CHECK_WRITE, \"fopen64 result\");\n-\n-    mkbuffer (p);\n-  }\n-\n-  return p;\n-}\n-#endif\n-\n-\n-#ifdef HAVE_FREOPEN64\n-WRAPPER2(FILE *, freopen64, const char *path, const char *mode, FILE *s)\n-{\n-  size_t n;\n-  FILE *p;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-\n-  n = strlen (path);\n-  MF_VALIDATE_EXTENT (path, CLAMPADD(n, 1), __MF_CHECK_READ, \"freopen64 path\");\n-\n-  MF_VALIDATE_EXTENT (s, (sizeof (*s)), __MF_CHECK_WRITE, \"freopen64 stream\");\n-  unmkbuffer (s);\n-\n-  n = strlen (mode);\n-  MF_VALIDATE_EXTENT (mode, CLAMPADD(n, 1), __MF_CHECK_READ, \"freopen64 mode\");\n-\n-  p = freopen (path, mode, s);\n-  if (NULL != p) {\n-#ifdef MF_REGISTER_fopen\n-    __mf_register (p, sizeof (*p), MF_REGISTER_fopen, \"freopen64 result\");\n-#endif\n-    MF_VALIDATE_EXTENT (p, sizeof (*p), __MF_CHECK_WRITE, \"freopen64 result\");\n-\n-    mkbuffer (p);\n-  }\n-\n-  return p;\n-}\n-#endif\n-\n-\n-WRAPPER2(int, fclose, FILE *stream)\n-{\n-  int resp;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"fclose stream\");\n-  resp = fclose (stream);\n-#ifdef MF_REGISTER_fopen\n-  __mf_unregister (stream, sizeof (*stream), MF_REGISTER_fopen);\n-#endif\n-  unmkbuffer (stream);\n-\n-  return resp;\n-}\n-\n-\n-WRAPPER2(size_t, fread, void *ptr, size_t size, size_t nmemb, FILE *stream)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"fread stream\");\n-  MF_VALIDATE_EXTENT (ptr, size * nmemb, __MF_CHECK_WRITE, \"fread buffer\");\n-  return fread (ptr, size, nmemb, stream);\n-}\n-\n-\n-WRAPPER2(size_t, fwrite, const void *ptr, size_t size, size_t nmemb,\n-\tFILE *stream)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"fwrite stream\");\n-  MF_VALIDATE_EXTENT (ptr, size * nmemb, __MF_CHECK_READ, \"fwrite buffer\");\n-  return fwrite (ptr, size, nmemb, stream);\n-}\n-\n-\n-WRAPPER2(int, fgetc, FILE *stream)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"fgetc stream\");\n-  return fgetc (stream);\n-}\n-\n-\n-WRAPPER2(char *, fgets, char *s, int size, FILE *stream)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"fgets stream\");\n-  MF_VALIDATE_EXTENT (s, size, __MF_CHECK_WRITE, \"fgets buffer\");\n-  return fgets (s, size, stream);\n-}\n-\n-\n-WRAPPER2(int, getc, FILE *stream)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"getc stream\");\n-  return getc (stream);\n-}\n-\n-\n-WRAPPER2(char *, gets, char *s)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (s, 1, __MF_CHECK_WRITE, \"gets buffer\");\n-  /* Avoid link-time warning... */\n-  s = fgets (s, INT_MAX, stdin);\n-  if (NULL != s) {\t/* better late than never */\n-    size_t n = strlen (s);\n-    MF_VALIDATE_EXTENT (s, CLAMPADD(n, 1), __MF_CHECK_WRITE, \"gets buffer\");\n-  }\n-  return s;\n-}\n-\n-\n-WRAPPER2(int, ungetc, int c, FILE *stream)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-     \"ungetc stream\");\n-  return ungetc (c, stream);\n-}\n-\n-\n-WRAPPER2(int, fputc, int c, FILE *stream)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"fputc stream\");\n-  return fputc (c, stream);\n-}\n-\n-\n-WRAPPER2(int, fputs, const char *s, FILE *stream)\n-{\n-  size_t n;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  n = strlen (s);\n-  MF_VALIDATE_EXTENT (s, CLAMPADD(n, 1), __MF_CHECK_READ, \"fputs buffer\");\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"fputs stream\");\n-  return fputs (s, stream);\n-}\n-\n-\n-WRAPPER2(int, putc, int c, FILE *stream)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"putc stream\");\n-  return putc (c, stream);\n-}\n-\n-\n-WRAPPER2(int, puts, const char *s)\n-{\n-  size_t n;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  n = strlen (s);\n-  MF_VALIDATE_EXTENT (s, CLAMPADD(n, 1), __MF_CHECK_READ, \"puts buffer\");\n-  return puts (s);\n-}\n-\n-\n-WRAPPER2(void, clearerr, FILE *stream)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"clearerr stream\");\n-  clearerr (stream);\n-}\n-\n-\n-WRAPPER2(int, feof, FILE *stream)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"feof stream\");\n-  return feof (stream);\n-}\n-\n-\n-WRAPPER2(int, ferror, FILE *stream)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"ferror stream\");\n-  return ferror (stream);\n-}\n-\n-\n-WRAPPER2(int, fileno, FILE *stream)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"fileno stream\");\n-  return fileno (stream);\n-}\n-\n-\n-WRAPPER2(int, printf, const char *format, ...)\n-{\n-  size_t n;\n-  va_list ap;\n-  int result;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  n = strlen (format);\n-  MF_VALIDATE_EXTENT (format, CLAMPADD(n, 1), __MF_CHECK_READ,\n-    \"printf format\");\n-  va_start (ap, format);\n-  result = vprintf (format, ap);\n-  va_end (ap);\n-  return result;\n-}\n-\n-\n-WRAPPER2(int, fprintf, FILE *stream, const char *format, ...)\n-{\n-  size_t n;\n-  va_list ap;\n-  int result;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"fprintf stream\");\n-  n = strlen (format);\n-  MF_VALIDATE_EXTENT (format, CLAMPADD(n, 1), __MF_CHECK_READ,\n-    \"fprintf format\");\n-  va_start (ap, format);\n-  result = vfprintf (stream, format, ap);\n-  va_end (ap);\n-  return result;\n-}\n-\n-\n-WRAPPER2(int, sprintf, char *str, const char *format, ...)\n-{\n-  size_t n;\n-  va_list ap;\n-  int result;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (str, 1, __MF_CHECK_WRITE, \"sprintf str\");\n-  n = strlen (format);\n-  MF_VALIDATE_EXTENT (format, CLAMPADD(n, 1), __MF_CHECK_READ,\n-    \"sprintf format\");\n-  va_start (ap, format);\n-  result = vsprintf (str, format, ap);\n-  va_end (ap);\n-  n = strlen (str);\n-  MF_VALIDATE_EXTENT (str, CLAMPADD(n, 1), __MF_CHECK_WRITE, \"sprintf str\");\n-  return result;\n-}\n-\n-\n-WRAPPER2(int, snprintf, char *str, size_t size, const char *format, ...)\n-{\n-  size_t n;\n-  va_list ap;\n-  int result;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (str, size, __MF_CHECK_WRITE, \"snprintf str\");\n-  n = strlen (format);\n-  MF_VALIDATE_EXTENT (format, CLAMPADD(n, 1), __MF_CHECK_READ,\n-    \"snprintf format\");\n-  va_start (ap, format);\n-  result = vsnprintf (str, size, format, ap);\n-  va_end (ap);\n-  return result;\n-}\n-\n-\n-WRAPPER2(int, vprintf,  const char *format, va_list ap)\n-{\n-  size_t n;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  n = strlen (format);\n-  MF_VALIDATE_EXTENT (format, CLAMPADD(n, 1), __MF_CHECK_READ,\n-    \"vprintf format\");\n-  return vprintf (format, ap);\n-}\n-\n-\n-WRAPPER2(int, vfprintf, FILE *stream, const char *format, va_list ap)\n-{\n-  size_t n;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"vfprintf stream\");\n-  n = strlen (format);\n-  MF_VALIDATE_EXTENT (format, CLAMPADD(n, 1), __MF_CHECK_READ,\n-    \"vfprintf format\");\n-  return vfprintf (stream, format, ap);\n-}\n-\n-\n-WRAPPER2(int, vsprintf, char *str, const char *format, va_list ap)\n-{\n-  size_t n;\n-  int result;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (str, 1, __MF_CHECK_WRITE, \"vsprintf str\");\n-  n = strlen (format);\n-  MF_VALIDATE_EXTENT (format, CLAMPADD(n, 1), __MF_CHECK_READ,\n-    \"vsprintf format\");\n-  result = vsprintf (str, format, ap);\n-  n = strlen (str);\n-  MF_VALIDATE_EXTENT (str, CLAMPADD(n, 1), __MF_CHECK_WRITE, \"vsprintf str\");\n-  return result;\n-}\n-\n-\n-WRAPPER2(int, vsnprintf, char *str, size_t size, const char *format,\n-\tva_list ap)\n-{\n-  size_t n;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (str, size, __MF_CHECK_WRITE, \"vsnprintf str\");\n-  n = strlen (format);\n-  MF_VALIDATE_EXTENT (format, CLAMPADD(n, 1), __MF_CHECK_READ,\n-    \"vsnprintf format\");\n-  return vsnprintf (str, size, format, ap);\n-}\n-\n-\n-WRAPPER2(int , access, const char *path, int mode)\n-{\n-  size_t n;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  n = strlen (path);\n-  MF_VALIDATE_EXTENT (path, CLAMPADD(n, 1), __MF_CHECK_READ, \"access path\");\n-  return access (path, mode);\n-}\n-\n-\n-WRAPPER2(int , remove, const char *path)\n-{\n-  size_t n;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  n = strlen (path);\n-  MF_VALIDATE_EXTENT (path, CLAMPADD(n, 1), __MF_CHECK_READ, \"remove path\");\n-  return remove (path);\n-}\n-\n-\n-WRAPPER2(int, fflush, FILE *stream)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  if (stream != NULL)\n-    MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-                        \"fflush stream\");\n-  return fflush (stream);\n-}\n-\n-\n-WRAPPER2(int, fseek, FILE *stream, long offset, int whence)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"fseek stream\");\n-  return fseek (stream, offset, whence);\n-}\n-\n-\n-#ifdef HAVE_FSEEKO64\n-WRAPPER2(int, fseeko64, FILE *stream, off64_t offset, int whence)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"fseeko64 stream\");\n-  return fseeko64 (stream, offset, whence);\n-}\n-#endif\n-\n-\n-WRAPPER2(long, ftell, FILE *stream)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"ftell stream\");\n-  return ftell (stream);\n-}\n-\n-\n-#ifdef HAVE_FTELLO64\n-WRAPPER2(off64_t, ftello64, FILE *stream)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"ftello64 stream\");\n-  return ftello64 (stream);\n-}\n-#endif\n-\n-\n-WRAPPER2(void, rewind, FILE *stream)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"rewind stream\");\n-  rewind (stream);\n-}\n-\n-\n-WRAPPER2(int, fgetpos, FILE *stream, fpos_t *pos)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"fgetpos stream\");\n-  MF_VALIDATE_EXTENT (pos, sizeof (*pos), __MF_CHECK_WRITE, \"fgetpos pos\");\n-  return fgetpos (stream, pos);\n-}\n-\n-\n-WRAPPER2(int, fsetpos, FILE *stream, fpos_t *pos)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"fsetpos stream\");\n-  MF_VALIDATE_EXTENT (pos, sizeof (*pos), __MF_CHECK_READ, \"fsetpos pos\");\n-  return fsetpos (stream, pos);\n-}\n-\n-\n-WRAPPER2(int , stat, const char *path, struct stat *buf)\n-{\n-  size_t n;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  n = strlen (path);\n-  MF_VALIDATE_EXTENT (path, CLAMPADD(n, 1), __MF_CHECK_READ, \"stat path\");\n-  MF_VALIDATE_EXTENT (buf, sizeof (*buf), __MF_CHECK_READ, \"stat buf\");\n-  return stat (path, buf);\n-}\n-\n-\n-#ifdef HAVE_STAT64\n-WRAPPER2(int , stat64, const char *path, struct stat64 *buf)\n-{\n-  size_t n;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  n = strlen (path);\n-  MF_VALIDATE_EXTENT (path, CLAMPADD(n, 1), __MF_CHECK_READ, \"stat64 path\");\n-  MF_VALIDATE_EXTENT (buf, sizeof (*buf), __MF_CHECK_READ, \"stat64 buf\");\n-  return stat64 (path, buf);\n-}\n-#endif\n-\n-\n-WRAPPER2(int , fstat, int filedes, struct stat *buf)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (buf, sizeof (*buf), __MF_CHECK_READ, \"fstat buf\");\n-  return fstat (filedes, buf);\n-}\n-\n-\n-WRAPPER2(int , lstat, const char *path, struct stat *buf)\n-{\n-  size_t n;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  n = strlen (path);\n-  MF_VALIDATE_EXTENT (path, CLAMPADD(n, 1), __MF_CHECK_READ, \"lstat path\");\n-  MF_VALIDATE_EXTENT (buf, sizeof (*buf), __MF_CHECK_READ, \"lstat buf\");\n-  return lstat (path, buf);\n-}\n-\n-\n-WRAPPER2(int , mkfifo, const char *path, mode_t mode)\n-{\n-  size_t n;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  n = strlen (path);\n-  MF_VALIDATE_EXTENT (path, CLAMPADD(n, 1), __MF_CHECK_READ, \"mkfifo path\");\n-  return mkfifo (path, mode);\n-}\n-\n-\n-#ifdef HAVE_DIRENT_H\n-WRAPPER2(DIR *, opendir, const char *path)\n-{\n-  DIR *p;\n-  size_t n;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  n = strlen (path);\n-  MF_VALIDATE_EXTENT (path, CLAMPADD(n, 1), __MF_CHECK_READ, \"opendir path\");\n-\n-  p = opendir (path);\n-  if (NULL != p) {\n-#ifdef MF_REGISTER_opendir\n-    __mf_register (p, MF_RESULT_SIZE_opendir, MF_REGISTER_opendir,\n-      \"opendir result\");\n-#endif\n-    MF_VALIDATE_EXTENT (p, MF_RESULT_SIZE_opendir, __MF_CHECK_WRITE,\n-      \"opendir result\");\n-  }\n-  return p;\n-}\n-\n-\n-WRAPPER2(int, closedir, DIR *dir)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (dir, 0, __MF_CHECK_WRITE, \"closedir dir\");\n-#ifdef MF_REGISTER_opendir\n-  __mf_unregister (dir, MF_RESULT_SIZE_opendir, MF_REGISTER_opendir);\n-#endif\n-  return closedir (dir);\n-}\n-\n-\n-WRAPPER2(struct dirent *, readdir, DIR *dir)\n-{\n-  struct dirent *p;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (dir, 0, __MF_CHECK_READ, \"readdir dir\");\n-  p = readdir (dir);\n-  if (NULL != p) {\n-#ifdef MF_REGISTER_readdir\n-    __mf_register (p, sizeof (*p), MF_REGISTER_readdir, \"readdir result\");\n-#endif\n-    MF_VALIDATE_EXTENT (p, sizeof (*p), __MF_CHECK_WRITE, \"readdir result\");\n-  }\n-  return p;\n-}\n-#endif\n-\n-\n-#ifdef HAVE_SYS_SOCKET_H\n-\n-WRAPPER2(int, recv, int s, void *buf, size_t len, int flags)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (buf, len, __MF_CHECK_WRITE, \"recv buf\");\n-  return recv (s, buf, len, flags);\n-}\n-\n-\n-WRAPPER2(int, recvfrom, int s, void *buf, size_t len, int flags,\n-\t\tstruct sockaddr *from, socklen_t *fromlen)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (buf, len, __MF_CHECK_WRITE, \"recvfrom buf\");\n-  MF_VALIDATE_EXTENT (from, (size_t)*fromlen, __MF_CHECK_WRITE,\n-    \"recvfrom from\");\n-  return recvfrom (s, buf, len, flags, from, fromlen);\n-}\n-\n-\n-WRAPPER2(int, recvmsg, int s, struct msghdr *msg, int flags)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (msg, sizeof (*msg), __MF_CHECK_WRITE, \"recvmsg msg\");\n-  return recvmsg (s, msg, flags);\n-}\n-\n-\n-WRAPPER2(int, send, int s, const void *msg, size_t len, int flags)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (msg, len, __MF_CHECK_READ, \"send msg\");\n-  return send (s, msg, len, flags);\n-}\n-\n-\n-WRAPPER2(int, sendto, int s, const void *msg, size_t len, int flags,\n-\t\tconst struct sockaddr *to, socklen_t tolen)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (msg, len, __MF_CHECK_READ, \"sendto msg\");\n-  MF_VALIDATE_EXTENT (to, (size_t)tolen, __MF_CHECK_WRITE, \"sendto to\");\n-  return sendto (s, msg, len, flags, to, tolen);\n-}\n-\n-\n-WRAPPER2(int, sendmsg, int s, const void *msg, int flags)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (msg, sizeof (*msg), __MF_CHECK_READ, \"sendmsg msg\");\n-  return sendmsg (s, msg, flags);\n-}\n-\n-\n-WRAPPER2(int, setsockopt, int s, int level, int optname, const void *optval,\n-\tsocklen_t optlen)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (optval, (size_t)optlen, __MF_CHECK_READ,\n-    \"setsockopt optval\");\n-  return setsockopt (s, level, optname, optval, optlen);\n-}\n-\n-\n-WRAPPER2(int, getsockopt, int s, int level, int optname, void *optval,\n-\t\tsocklen_t *optlen)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (optval, (size_t)*optlen, __MF_CHECK_WRITE,\n-    \"getsockopt optval\");\n-  return getsockopt (s, level, optname, optval, optlen);\n-}\n-\n-\n-WRAPPER2(int, accept, int s, struct  sockaddr *addr, socklen_t *addrlen)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  if (addr != NULL)\n-    MF_VALIDATE_EXTENT (addr, (size_t)*addrlen, __MF_CHECK_WRITE, \"accept addr\");\n-  return accept (s, addr, addrlen);\n-}\n-\n-\n-WRAPPER2(int, bind, int sockfd, struct  sockaddr *addr, socklen_t addrlen)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (addr, (size_t)addrlen, __MF_CHECK_WRITE, \"bind addr\");\n-  return bind (sockfd, addr, addrlen);\n-}\n-\n-\n-WRAPPER2(int, connect, int sockfd, const struct sockaddr  *addr,\n-\tsocklen_t addrlen)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (addr, (size_t)addrlen, __MF_CHECK_READ,\n-    \"connect addr\");\n-  return connect (sockfd, addr, addrlen);\n-}\n-\n-#endif /* HAVE_SYS_SOCKET_H */\n-\n-\n-WRAPPER2(int, gethostname, char *name, size_t len)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (name, len, __MF_CHECK_WRITE, \"gethostname name\");\n-  return gethostname (name, len);\n-}\n-\n-\n-#ifdef HAVE_SETHOSTNAME\n-WRAPPER2(int, sethostname, const char *name, size_t len)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (name, len, __MF_CHECK_READ, \"sethostname name\");\n-  return sethostname (name, len);\n-}\n-#endif\n-\n-\n-#ifdef HAVE_NETDB_H\n-\n-WRAPPER2(struct hostent *, gethostbyname, const char *name)\n-{\n-  struct hostent *p;\n-  char **ss;\n-  char *s;\n-  size_t n;\n-  int nreg;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  n = strlen (name);\n-  MF_VALIDATE_EXTENT (name, CLAMPADD(n, 1), __MF_CHECK_READ,\n-    \"gethostbyname name\");\n-  p = gethostbyname (name);\n-  if (NULL != p) {\n-#ifdef MF_REGISTER_gethostbyname\n-    __mf_register (p, sizeof (*p), MF_REGISTER_gethostbyname,\n-      \"gethostbyname result\");\n-#endif\n-    MF_VALIDATE_EXTENT (p, sizeof (*p), __MF_CHECK_WRITE,\n-      \"gethostbyname result\");\n-    if (NULL != (s = p->h_name)) {\n-      n = strlen (s);\n-      n = CLAMPADD(n, 1);\n-#ifdef MF_REGISTER_gethostbyname_items\n-      __mf_register (s, n, MF_REGISTER_gethostbyname_items,\n-        \"gethostbyname result->h_name\");\n-#endif\n-      MF_VALIDATE_EXTENT (s, n, __MF_CHECK_WRITE,\n-        \"gethostbyname result->h_name\");\n-    }\n-\n-    if (NULL != (ss = p->h_aliases)) {\n-      for (nreg = 1;; ++nreg) {\n-        s = *ss++;\n-        if (NULL == s)\n-          break;\n-        n = strlen (s);\n-        n = CLAMPADD(n, 1);\n-#ifdef MF_REGISTER_gethostbyname_items\n-        __mf_register (s, n, MF_REGISTER_gethostbyname_items,\n-          \"gethostbyname result->h_aliases[]\");\n-#endif\n-        MF_VALIDATE_EXTENT (s, n, __MF_CHECK_WRITE,\n-          \"gethostbyname result->h_aliases[]\");\n-      }\n-      nreg *= sizeof (*p->h_aliases);\n-#ifdef MF_REGISTER_gethostbyname_items\n-      __mf_register (p->h_aliases, nreg, MF_REGISTER_gethostbyname_items,\n-        \"gethostbyname result->h_aliases\");\n-#endif\n-      MF_VALIDATE_EXTENT (p->h_aliases, nreg, __MF_CHECK_WRITE,\n-        \"gethostbyname result->h_aliases\");\n-    }\n-\n-    if (NULL != (ss = p->h_addr_list)) {\n-      for (nreg = 1;; ++nreg) {\n-        s = *ss++;\n-        if (NULL == s)\n-          break;\n-#ifdef MF_REGISTER_gethostbyname_items\n-        __mf_register (s, p->h_length, MF_REGISTER_gethostbyname_items,\n-          \"gethostbyname result->h_addr_list[]\");\n-#endif\n-        MF_VALIDATE_EXTENT (s, p->h_length, __MF_CHECK_WRITE,\n-          \"gethostbyname result->h_addr_list[]\");\n-      }\n-      nreg *= sizeof (*p->h_addr_list);\n-#ifdef MF_REGISTER_gethostbyname_items\n-      __mf_register (p->h_addr_list, nreg, MF_REGISTER_gethostbyname_items,\n-        \"gethostbyname result->h_addr_list\");\n-#endif\n-      MF_VALIDATE_EXTENT (p->h_addr_list, nreg, __MF_CHECK_WRITE,\n-        \"gethostbyname result->h_addr_list\");\n-    }\n-  }\n-  return p;\n-}\n-\n-#endif /* HAVE_NETDB_H */\n-\n-\n-#ifdef HAVE_SYS_WAIT_H\n-\n-WRAPPER2(pid_t, wait, int *status)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  if (NULL != status)\n-    MF_VALIDATE_EXTENT (status, sizeof (*status), __MF_CHECK_WRITE,\n-      \"wait status\");\n-  return wait (status);\n-}\n-\n-\n-WRAPPER2(pid_t, waitpid, pid_t pid, int *status, int options)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  if (NULL != status)\n-    MF_VALIDATE_EXTENT (status, sizeof (*status), __MF_CHECK_WRITE,\n-      \"waitpid status\");\n-  return waitpid (pid, status, options);\n-}\n-\n-#endif /* HAVE_SYS_WAIT_H */\n-\n-\n-WRAPPER2(FILE *, popen, const char *command, const char *mode)\n-{\n-  size_t n;\n-  FILE *p;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-\n-  n = strlen (command);\n-  MF_VALIDATE_EXTENT (command, CLAMPADD(n, 1), __MF_CHECK_READ, \"popen path\");\n-\n-  n = strlen (mode);\n-  MF_VALIDATE_EXTENT (mode, CLAMPADD(n, 1), __MF_CHECK_READ, \"popen mode\");\n-\n-  p = popen (command, mode);\n-  if (NULL != p) {\n-#ifdef MF_REGISTER_fopen\n-    __mf_register (p, sizeof (*p), MF_REGISTER_fopen, \"popen result\");\n-#endif\n-    MF_VALIDATE_EXTENT (p, sizeof (*p), __MF_CHECK_WRITE, \"popen result\");\n-  }\n-  return p;\n-}\n-\n-\n-WRAPPER2(int, pclose, FILE *stream)\n-{\n-  int resp;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (stream, sizeof (*stream), __MF_CHECK_WRITE,\n-    \"pclose stream\");\n-  resp = pclose (stream);\n-#ifdef MF_REGISTER_fopen\n-  __mf_unregister (stream, sizeof (*stream), MF_REGISTER_fopen);\n-#endif\n-  return resp;\n-}\n-\n-\n-WRAPPER2(int, execve, const char *path, char *const argv [],\n-\tchar *const envp[])\n-{\n-  size_t n;\n-  char *const *p;\n-  const char *s;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-\n-  n = strlen (path);\n-  MF_VALIDATE_EXTENT (path, CLAMPADD(n, 1), __MF_CHECK_READ, \"execve path\");\n-\n-  for (p = argv;;) {\n-    MF_VALIDATE_EXTENT (p, sizeof (*p), __MF_CHECK_READ, \"execve *argv\");\n-    s = *p++;\n-    if (NULL == s)\n-      break;\n-    n = strlen (s);\n-    MF_VALIDATE_EXTENT (s, CLAMPADD(n, 1), __MF_CHECK_READ, \"execve **argv\");\n-  }\n-\n-  for (p = envp;;) {\n-    MF_VALIDATE_EXTENT (p, sizeof (*p), __MF_CHECK_READ, \"execve *envp\");\n-    s = *p++;\n-    if (NULL == s)\n-      break;\n-    n = strlen (s);\n-    MF_VALIDATE_EXTENT (s, CLAMPADD(n, 1), __MF_CHECK_READ, \"execve **envp\");\n-  }\n-  return execve (path, argv, envp);\n-}\n-\n-\n-WRAPPER2(int, execv, const char *path, char *const argv [])\n-{\n-  size_t n;\n-  char *const *p;\n-  const char *s;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-\n-  n = strlen (path);\n-  MF_VALIDATE_EXTENT (path, CLAMPADD(n, 1), __MF_CHECK_READ, \"execv path\");\n-\n-  for (p = argv;;) {\n-    MF_VALIDATE_EXTENT (p, sizeof (*p), __MF_CHECK_READ, \"execv *argv\");\n-    s = *p++;\n-    if (NULL == s)\n-      break;\n-    n = strlen (s);\n-    MF_VALIDATE_EXTENT (s, CLAMPADD(n, 1), __MF_CHECK_READ, \"execv **argv\");\n-  }\n-  return execv (path, argv);\n-}\n-\n-\n-WRAPPER2(int, execvp, const char *path, char *const argv [])\n-{\n-  size_t n;\n-  char *const *p;\n-  const char *s;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-\n-  n = strlen (path);\n-  MF_VALIDATE_EXTENT (path, CLAMPADD(n, 1), __MF_CHECK_READ, \"execvp path\");\n-\n-  for (p = argv;;) {\n-    MF_VALIDATE_EXTENT (p, sizeof (*p), __MF_CHECK_READ, \"execvp *argv\");\n-    s = *p++;\n-    if (NULL == s)\n-      break;\n-    n = strlen (s);\n-    MF_VALIDATE_EXTENT (s, CLAMPADD(n, 1), __MF_CHECK_READ, \"execvp **argv\");\n-  }\n-  return execvp (path, argv);\n-}\n-\n-\n-WRAPPER2(int, system, const char *string)\n-{\n-  size_t n;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  n = strlen (string);\n-  MF_VALIDATE_EXTENT (string, CLAMPADD(n, 1), __MF_CHECK_READ,\n-    \"system string\");\n-  return system (string);\n-}\n-\n-\n-WRAPPER2(void *, dlopen, const char *path, int flags)\n-{\n-  void *p;\n-  size_t n;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  n = strlen (path);\n-  MF_VALIDATE_EXTENT (path, CLAMPADD(n, 1), __MF_CHECK_READ, \"dlopen path\");\n-  p = dlopen (path, flags);\n-  if (NULL != p) {\n-#ifdef MF_REGISTER_dlopen\n-    __mf_register (p, 0, MF_REGISTER_dlopen, \"dlopen result\");\n-#endif\n-    MF_VALIDATE_EXTENT (p, 0, __MF_CHECK_WRITE, \"dlopen result\");\n-  }\n-  return p;\n-}\n-\n-\n-WRAPPER2(int, dlclose, void *handle)\n-{\n-  int resp;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (handle, 0, __MF_CHECK_READ, \"dlclose handle\");\n-  resp = dlclose (handle);\n-#ifdef MF_REGISTER_dlopen\n-  __mf_unregister (handle, 0, MF_REGISTER_dlopen);\n-#endif\n-  return resp;\n-}\n-\n-\n-WRAPPER2(char *, dlerror)\n-{\n-  char *p;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  p = dlerror ();\n-  if (NULL != p) {\n-    size_t n;\n-    n = strlen (p);\n-    n = CLAMPADD(n, 1);\n-#ifdef MF_REGISTER_dlerror\n-    __mf_register (p, n, MF_REGISTER_dlerror, \"dlerror result\");\n-#endif\n-    MF_VALIDATE_EXTENT (p, n, __MF_CHECK_WRITE, \"dlerror result\");\n-  }\n-  return p;\n-}\n-\n-\n-WRAPPER2(void *, dlsym, void *handle, char *symbol)\n-{\n-  size_t n;\n-  void *p;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (handle, 0, __MF_CHECK_READ, \"dlsym handle\");\n-  n = strlen (symbol);\n-  MF_VALIDATE_EXTENT (symbol, CLAMPADD(n, 1), __MF_CHECK_READ, \"dlsym symbol\");\n-  p = dlsym (handle, symbol);\n-  if (NULL != p) {\n-#ifdef MF_REGISTER_dlsym\n-    __mf_register (p, 0, MF_REGISTER_dlsym, \"dlsym result\");\n-#endif\n-    MF_VALIDATE_EXTENT (p, 0, __MF_CHECK_WRITE, \"dlsym result\");\n-  }\n-  return p;\n-}\n-\n-\n-#if defined (HAVE_SYS_IPC_H) && defined (HAVE_SYS_SEM_H) && defined (HAVE_SYS_SHM_H)\n-\n-WRAPPER2(int, semop, int semid, struct sembuf *sops, unsigned nsops)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  MF_VALIDATE_EXTENT (sops, sizeof (*sops) * nsops, __MF_CHECK_READ,\n-    \"semop sops\");\n-  return semop (semid, sops, nsops);\n-}\n-\n-\n-#ifndef HAVE_UNION_SEMUN\n-union semun {\n-\tint val;\t\t\t/* value for SETVAL */\n-\tstruct semid_ds *buf;\t\t/* buffer for IPC_STAT, IPC_SET */\n-\tunsigned short int *array;\t/* array for GETALL, SETALL */\n-\tstruct seminfo *__buf;\t\t/* buffer for IPC_INFO */\n-};\n-#endif\n-WRAPPER2(int, semctl, int semid, int semnum, int cmd, union semun arg)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  switch (cmd) {\n-  case IPC_STAT:\n-    MF_VALIDATE_EXTENT (arg.buf, sizeof (*arg.buf), __MF_CHECK_WRITE,\n-      \"semctl buf\");\n-    break;\n-  case IPC_SET:\n-    MF_VALIDATE_EXTENT (arg.buf, sizeof (*arg.buf), __MF_CHECK_READ,\n-      \"semctl buf\");\n-    break;\n-  case GETALL:\n-    MF_VALIDATE_EXTENT (arg.array, sizeof (*arg.array), __MF_CHECK_WRITE,\n-      \"semctl array\");\n-  case SETALL:\n-    MF_VALIDATE_EXTENT (arg.array, sizeof (*arg.array), __MF_CHECK_READ,\n-      \"semctl array\");\n-    break;\n-#ifdef IPC_INFO\n-  /* FreeBSD 5.1 And Cygwin headers include IPC_INFO but not the __buf field.  */\n-#if !defined(__FreeBSD__) && !defined(__CYGWIN__)\n-  case IPC_INFO:\n-    MF_VALIDATE_EXTENT (arg.__buf, sizeof (*arg.__buf), __MF_CHECK_WRITE,\n-      \"semctl __buf\");\n-    break;\n-#endif\n-#endif\n-  default:\n-    break;\n-  }\n-  return semctl (semid, semnum, cmd, arg);\n-}\n-\n-\n-WRAPPER2(int, shmctl, int shmid, int cmd, struct shmid_ds *buf)\n-{\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  switch (cmd) {\n-  case IPC_STAT:\n-    MF_VALIDATE_EXTENT (buf, sizeof (*buf), __MF_CHECK_WRITE,\n-      \"shmctl buf\");\n-    break;\n-  case IPC_SET:\n-    MF_VALIDATE_EXTENT (buf, sizeof (*buf), __MF_CHECK_READ,\n-      \"shmctl buf\");\n-    break;\n-  default:\n-    break;\n-  }\n-  return shmctl (shmid, cmd, buf);\n-}\n-\n-\n-WRAPPER2(void *, shmat, int shmid, const void *shmaddr, int shmflg)\n-{\n-  void *p;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  p = shmat (shmid, shmaddr, shmflg);\n-#ifdef MF_REGISTER_shmat\n-  if (NULL != p) {\n-    struct shmid_ds buf;\n-    __mf_register (p, shmctl (shmid, IPC_STAT, &buf) ? 0 : buf.shm_segsz,\n-      MF_REGISTER_shmat, \"shmat result\");\n-  }\n-#endif\n-  return p;\n-}\n-\n-\n-WRAPPER2(int, shmdt, const void *shmaddr)\n-{\n-  int resp;\n-  TRACE (\"%s\\n\", __PRETTY_FUNCTION__);\n-  resp = shmdt (shmaddr);\n-#ifdef MF_REGISTER_shmat\n-  __mf_unregister ((void *)shmaddr, 0, MF_REGISTER_shmat);\n-#endif\n-  return resp;\n-}\n-\n-\n-#endif /* HAVE_SYS_IPC/SEM/SHM_H */\n-\n-\n-\n-/* ctype stuff.  This is host-specific by necessity, as the arrays\n-   that is used by most is*()/to*() macros are implementation-defined.  */\n-\n-/* GLIBC 2.3 */\n-#ifdef HAVE___CTYPE_B_LOC\n-WRAPPER2(unsigned short **, __ctype_b_loc, void)\n-{\n-  static unsigned short * last_buf = (void *) 0;\n-  static unsigned short ** last_ptr = (void *) 0;\n-  unsigned short ** ptr = (unsigned short **) __ctype_b_loc ();\n-  unsigned short * buf = * ptr;\n-  if (ptr != last_ptr)\n-    {\n-      /* XXX: unregister last_ptr? */\n-      last_ptr = ptr;\n-      __mf_register (last_ptr, sizeof(last_ptr), __MF_TYPE_STATIC, \"ctype_b_loc **\");\n-    }\n-  if (buf != last_buf)\n-    {\n-      last_buf = buf;\n-      __mf_register ((void *) (last_buf - 128), 384 * sizeof(unsigned short), __MF_TYPE_STATIC,\n-                     \"ctype_b_loc []\");\n-    }\n-  return ptr;\n-}\n-#endif\n-\n-#ifdef HAVE___CTYPE_TOUPPER_LOC\n-WRAPPER2(int **, __ctype_toupper_loc, void)\n-{\n-  static int * last_buf = (void *) 0;\n-  static int ** last_ptr = (void *) 0;\n-  int ** ptr = (int **) __ctype_toupper_loc ();\n-  int * buf = * ptr;\n-  if (ptr != last_ptr)\n-    {\n-      /* XXX: unregister last_ptr? */\n-      last_ptr = ptr;\n-      __mf_register (last_ptr, sizeof(last_ptr), __MF_TYPE_STATIC, \"ctype_toupper_loc **\");\n-    }\n-  if (buf != last_buf)\n-    {\n-      last_buf = buf;\n-      __mf_register ((void *) (last_buf - 128), 384 * sizeof(int), __MF_TYPE_STATIC,\n-                     \"ctype_toupper_loc []\");\n-    }\n-  return ptr;\n-}\n-#endif\n-\n-#ifdef HAVE___CTYPE_TOLOWER_LOC\n-WRAPPER2(int **, __ctype_tolower_loc, void)\n-{\n-  static int * last_buf = (void *) 0;\n-  static int ** last_ptr = (void *) 0;\n-  int ** ptr = (int **) __ctype_tolower_loc ();\n-  int * buf = * ptr;\n-  if (ptr != last_ptr)\n-    {\n-      /* XXX: unregister last_ptr? */\n-      last_ptr = ptr;\n-      __mf_register (last_ptr, sizeof(last_ptr), __MF_TYPE_STATIC, \"ctype_tolower_loc **\");\n-    }\n-  if (buf != last_buf)\n-    {\n-      last_buf = buf;\n-      __mf_register ((void *) (last_buf - 128), 384 * sizeof(int), __MF_TYPE_STATIC,\n-                     \"ctype_tolower_loc []\");\n-    }\n-  return ptr;\n-}\n-#endif\n-\n-\n-/* passwd/group related functions.  These register every (static) pointer value returned,\n-   and rely on libmudflap's quiet toleration of duplicate static registrations.  */\n-\n-#ifdef HAVE_GETLOGIN\n-WRAPPER2(char *, getlogin, void)\n-{\n-  char *buf = getlogin ();\n-  if (buf != NULL)\n-    __mf_register (buf, sizeof(*buf), __MF_TYPE_STATIC,\n-                   \"getlogin() return\");\n-  return buf;\n-}\n-#endif\n-\n-\n-#ifdef HAVE_CUSERID\n-WRAPPER2(char *, cuserid, char * buf)\n-{\n-  if (buf != NULL)\n-    {\n-      MF_VALIDATE_EXTENT(buf, L_cuserid, __MF_CHECK_WRITE,\n-                         \"cuserid destination\");\n-      return cuserid (buf);\n-    }\n-  buf = cuserid (NULL);\n-  if (buf != NULL)\n-    __mf_register (buf, sizeof(*buf), __MF_TYPE_STATIC,\n-                   \"getcuserid() return\");\n-  return buf;\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GETPWNAM\n-WRAPPER2(struct passwd *, getpwnam, const char *name)\n-{\n-  struct passwd *buf;\n-  MF_VALIDATE_EXTENT(name, strlen(name)+1, __MF_CHECK_READ,\n-                     \"getpwnam name\");\n-  buf = getpwnam (name);\n-  if (buf != NULL)\n-    __mf_register (buf, sizeof(*buf), __MF_TYPE_STATIC,\n-                   \"getpw*() return\");\n-  return buf;\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GETPWUID\n-WRAPPER2(struct passwd *, getpwuid, uid_t uid)\n-{\n-  struct passwd *buf;\n-  buf = getpwuid (uid);\n-  if (buf != NULL)\n-    __mf_register (buf, sizeof(*buf), __MF_TYPE_STATIC,\n-                   \"getpw*() return\");\n-  return buf;\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GETGRNAM\n-WRAPPER2(struct group *, getgrnam, const char *name)\n-{\n-  struct group *buf;\n-  MF_VALIDATE_EXTENT(name, strlen(name)+1, __MF_CHECK_READ,\n-                     \"getgrnam name\");\n-  buf = getgrnam (name);\n-  if (buf != NULL)\n-    __mf_register (buf, sizeof(*buf), __MF_TYPE_STATIC,\n-                   \"getgr*() return\");\n-  return buf;\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GETGRGID\n-WRAPPER2(struct group *, getgrgid, uid_t uid)\n-{\n-  struct group *buf;\n-  buf = getgrgid (uid);\n-  if (buf != NULL)\n-    __mf_register (buf, sizeof(*buf), __MF_TYPE_STATIC,\n-                   \"getgr*() return\");\n-  return buf;\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GETSERVENT\n-WRAPPER2(struct servent *, getservent, void)\n-{\n-  struct servent *buf;\n-  buf = getservent ();\n-  if (buf != NULL)\n-    __mf_register (buf, sizeof(*buf), __MF_TYPE_STATIC,\n-                   \"getserv*() return\");\n-  return buf;\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GETSERVBYNAME\n-WRAPPER2(struct servent *, getservbyname, const char *name, const char *proto)\n-{\n-  struct servent *buf;\n-  MF_VALIDATE_EXTENT(name, strlen(name)+1, __MF_CHECK_READ,\n-                     \"getservbyname name\");\n-  MF_VALIDATE_EXTENT(proto, strlen(proto)+1, __MF_CHECK_READ,\n-                     \"getservbyname proto\");\n-  buf = getservbyname (name, proto);\n-  if (buf != NULL)\n-    __mf_register (buf, sizeof(*buf), __MF_TYPE_STATIC,\n-                   \"getserv*() return\");\n-  return buf;\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GETSERVBYPORT\n-WRAPPER2(struct servent *, getservbyport, int port, const char *proto)\n-{\n-  struct servent *buf;\n-  MF_VALIDATE_EXTENT(proto, strlen(proto)+1, __MF_CHECK_READ,\n-                     \"getservbyport proto\");\n-  buf = getservbyport (port, proto);\n-  if (buf != NULL)\n-    __mf_register (buf, sizeof(*buf), __MF_TYPE_STATIC,\n-                   \"getserv*() return\");\n-  return buf;\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GAI_STRERROR\n-WRAPPER2(const char *, gai_strerror, int errcode)\n-{\n-  const char *buf;\n-  buf = gai_strerror (errcode);\n-  if (buf != NULL)\n-    __mf_register ((void *) buf, strlen(buf)+1, __MF_TYPE_STATIC,\n-                   \"gai_strerror() return\");\n-  return buf;\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GETMNTENT\n-#ifdef HAVE_MNTENT_H\n-WRAPPER2(struct mntent *, getmntent, FILE *filep)\n-{\n-  struct mntent *m;\n-  static struct mntent *last = NULL;\n-\n-  MF_VALIDATE_EXTENT (filep, sizeof (*filep), __MF_CHECK_WRITE,\n-    \"getmntent stream\");\n-#define UR(field) __mf_unregister(last->field, strlen (last->field)+1, __MF_TYPE_STATIC)\n-  if (last)\n-    {\n-      UR (mnt_fsname);\n-      UR (mnt_dir);\n-      UR (mnt_type);\n-      UR (mnt_opts);\n-      __mf_unregister (last, sizeof (*last), __MF_TYPE_STATIC);\n-    }\n-#undef UR\n-\n-  m = getmntent (filep);\n-  last = m;\n-\n-#define R(field) __mf_register(last->field, strlen (last->field)+1, __MF_TYPE_STATIC, \"mntent \" #field)\n-  if (m)\n-    {\n-      R (mnt_fsname);\n-      R (mnt_dir);\n-      R (mnt_type);\n-      R (mnt_opts);\n-      __mf_register (last, sizeof (*last), __MF_TYPE_STATIC, \"getmntent result\");\n-    }\n-#undef R\n-\n-  return m;\n-}\n-#elif defined HAVE_SYS_MNTTAB_H\n-WRAPPER2(int, getmntent, FILE *filep, struct mnttab *mp)\n-{\n-  static struct mnttab *last = NULL;\n-  int res;\n-\n-  MF_VALIDATE_EXTENT (filep, sizeof (*filep), __MF_CHECK_WRITE,\n-    \"getmntent stream\");\n-#define UR(field) __mf_unregister(last->field, strlen (last->field)+1, __MF_TYPE_STATIC)\n-  if (last)\n-    {\n-      UR (mnt_special);\n-      UR (mnt_mountp);\n-      UR (mnt_fstype);\n-      UR (mnt_mntopts);\n-      UR (mnt_time);\n-      __mf_unregister (last, sizeof (*last), __MF_TYPE_STATIC);\n-    }\n-#undef UR\n-\n-  res = getmntent (filep, mp);\n-  last = mp;\n-\n-#define R(field) __mf_register(last->field, strlen (last->field)+1, __MF_TYPE_STATIC, \"mntent \" #field)\n-  if (mp)\n-    {\n-      R (mnt_special);\n-      R (mnt_mountp);\n-      R (mnt_fstype);\n-      R (mnt_mntopts);\n-      R (mnt_time);\n-      __mf_register (last, sizeof (*last), __MF_TYPE_STATIC, \"getmntent result\");\n-    }\n-#undef R\n-\n-  return res;\n-}\n-#endif\n-#endif\n-\n-\n-#ifdef HAVE_INET_NTOA\n-WRAPPER2(char *, inet_ntoa, struct in_addr in)\n-{\n-  static char *last_buf = NULL;\n-  char *buf;\n-  if (last_buf)\n-    __mf_unregister (last_buf, strlen (last_buf)+1, __MF_TYPE_STATIC);\n-  buf = inet_ntoa (in);\n-  last_buf = buf;\n-  if (buf)\n-    __mf_register (last_buf, strlen (last_buf)+1, __MF_TYPE_STATIC, \"inet_ntoa result\");\n-  return buf;\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GETPROTOENT\n-WRAPPER2(struct protoent *, getprotoent, void)\n-{\n-  struct protoent *buf;\n-  buf = getprotoent ();\n-  if (buf != NULL)\n-    __mf_register (buf, sizeof(*buf), __MF_TYPE_STATIC, \"getproto*() return\");\n-  return buf;\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GETPROTOBYNAME\n-WRAPPER2(struct protoent *, getprotobyname, const char *name)\n-{\n-  struct protoent *buf;\n-  MF_VALIDATE_EXTENT(name, strlen(name)+1, __MF_CHECK_READ,\n-                     \"getprotobyname name\");\n-  buf = getprotobyname (name);\n-  if (buf != NULL)\n-    __mf_register (buf, sizeof(*buf), __MF_TYPE_STATIC,\n-                   \"getproto*() return\");\n-  return buf;\n-}\n-#endif\n-\n-\n-#ifdef HAVE_GETPROTOBYNUMBER\n-WRAPPER2(struct protoent *, getprotobynumber, int port)\n-{\n-  struct protoent *buf;\n-  buf = getprotobynumber (port);\n-  if (buf != NULL)\n-    __mf_register (buf, sizeof(*buf), __MF_TYPE_STATIC,\n-                   \"getproto*() return\");\n-  return buf;\n-}\n-#endif"}, {"sha": "552cbb598d842b1608ab2efcd6360c8e43f44576", "filename": "libmudflap/mf-hooks3.c", "status": "removed", "additions": 0, "deletions": 284, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Fmf-hooks3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Fmf-hooks3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-hooks3.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,284 +0,0 @@\n-/* Mudflap: narrow-pointer bounds-checking by tree rewriting.\n-   Copyright (C) 2002-2013 Free Software Foundation, Inc.\n-   Contributed by Frank Ch. Eigler <fche@redhat.com>\n-   and Graydon Hoare <graydon@redhat.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-\n-#include \"config.h\"\n-\n-#ifndef HAVE_SOCKLEN_T\n-#define socklen_t int\n-#endif\n-\n-/* These attempt to coax various unix flavours to declare all our\n-   needed tidbits in the system headers.  */\n-#if !defined(__FreeBSD__) && !defined(__APPLE__)\n-#define _POSIX_SOURCE\n-#endif /* Some BSDs break <sys/socket.h> if this is defined. */\n-#define _GNU_SOURCE\n-#define _XOPEN_SOURCE\n-#define _BSD_TYPES\n-#define __EXTENSIONS__\n-#define _ALL_SOURCE\n-#define _LARGE_FILE_API\n-#define _XOPEN_SOURCE_EXTENDED 1\n-#define _REENTRANT\n-\n-#include <string.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <unistd.h>\n-#include <assert.h>\n-#include <errno.h>\n-#include <stdbool.h>\n-\n-#include \"mf-runtime.h\"\n-#include \"mf-impl.h\"\n-\n-#ifdef _MUDFLAP\n-#error \"Do not compile this file with -fmudflap!\"\n-#endif\n-\n-#ifndef LIBMUDFLAPTH\n-#error \"pthreadstuff is to be included only in libmudflapth\"\n-#endif\n-\n-/* ??? Why isn't this done once in the header files.  */\n-DECLARE(void *, malloc, size_t sz);\n-DECLARE(void, free, void *ptr);\n-DECLARE(int, pthread_create, pthread_t *thr, const pthread_attr_t *attr,\n-\tvoid * (*start) (void *), void *arg);\n-\n-\n-/* Multithreading support hooks.  */\n-\n-\n-#if !defined(HAVE_TLS) || defined(USE_EMUTLS)\n-/* We don't have TLS.  Ordinarily we could use pthread keys, but since we're\n-   commandeering malloc/free that presents a few problems.  The first is that\n-   we'll recurse from __mf_get_state to pthread_setspecific to malloc back to\n-   __mf_get_state during thread startup.  This can be solved with clever uses\n-   of a mutex.  The second problem is that thread shutdown is indistinguishable\n-   from thread startup, since libpthread is deallocating our state variable.\n-   I've no good solution for this.\n-\n-   Which leaves us to handle this mess by totally by hand.  */\n-\n-/* Yes, we want this prime.  If pthread_t is a pointer, it's almost always\n-   page aligned, and if we use a smaller power of 2, this results in \"%N\"\n-   being the worst possible hash -- all threads hash to zero.  */\n-#define LIBMUDFLAPTH_THREADS_MAX 1021\n-\n-struct mf_thread_data\n-{\n-  pthread_t self;\n-  unsigned char used_p;\n-  unsigned char state;\n-};\n-\n-static struct mf_thread_data mf_thread_data[LIBMUDFLAPTH_THREADS_MAX];\n-static pthread_mutex_t mf_thread_data_lock = PTHREAD_MUTEX_INITIALIZER;\n-\n-#define PTHREAD_HASH(p) ((unsigned long) (p) % LIBMUDFLAPTH_THREADS_MAX)\n-\n-static struct mf_thread_data *\n-__mf_find_threadinfo (int alloc)\n-{\n-  pthread_t self = pthread_self ();\n-  unsigned long hash = PTHREAD_HASH (self);\n-  unsigned long rehash;\n-\n-#ifdef __alpha__\n-  /* Alpha has the loosest memory ordering rules of all.  We need a memory\n-     barrier to flush the reorder buffer before considering a *read* of a\n-     shared variable.  Since we're not always taking a lock, we have to do\n-     this by hand.  */\n-  __sync_synchronize ();\n-#endif\n-\n-  rehash = hash;\n-  while (1)\n-    {\n-      if (mf_thread_data[rehash].used_p && mf_thread_data[rehash].self == self)\n-\treturn &mf_thread_data[rehash];\n-\n-      rehash += 7;\n-      if (rehash >= LIBMUDFLAPTH_THREADS_MAX)\n-\trehash -= LIBMUDFLAPTH_THREADS_MAX;\n-      if (rehash == hash)\n-\tbreak;\n-    }\n-\n-  if (alloc)\n-    {\n-      pthread_mutex_lock (&mf_thread_data_lock);\n-\n-      rehash = hash;\n-      while (1)\n-\t{\n-\t  if (!mf_thread_data[rehash].used_p)\n-\t    {\n-\t      mf_thread_data[rehash].self = self;\n-\t      __sync_synchronize ();\n-\t      mf_thread_data[rehash].used_p = 1;\n-\n-\t      pthread_mutex_unlock (&mf_thread_data_lock);\n-\t      return &mf_thread_data[rehash];\n-\t    }\n-\n-\t  rehash += 7;\n-\t  if (rehash >= LIBMUDFLAPTH_THREADS_MAX)\n-\t    rehash -= LIBMUDFLAPTH_THREADS_MAX;\n-\t  if (rehash == hash)\n-\t    break;\n-\t}\n-\n-      pthread_mutex_unlock (&mf_thread_data_lock);\n-    }\n-\n-  return NULL;\n-}\n-\n-enum __mf_state_enum\n-__mf_get_state (void)\n-{\n-  struct mf_thread_data *data = __mf_find_threadinfo (0);\n-  if (data)\n-    return data->state;\n-\n-  /* If we've never seen this thread before, consider it to be in the\n-     reentrant state.  The state gets reset to active for the main thread\n-     in __mf_init, and for child threads in __mf_pthread_spawner.\n-\n-     The trickiest bit here is that the LinuxThreads pthread_manager thread\n-     should *always* be considered to be reentrant, so that none of our \n-     hooks actually do anything.  Why?  Because that thread isn't a real\n-     thread from the point of view of the thread library, and so lots of\n-     stuff isn't initialized, leading to SEGV very quickly.  Even calling\n-     pthread_self is a bit suspect, but it happens to work.  */\n-\n-  return reentrant;\n-}\n-\n-void\n-__mf_set_state (enum __mf_state_enum new_state)\n-{\n-  struct mf_thread_data *data = __mf_find_threadinfo (1);\n-  data->state = new_state;\n-}\n-#endif\n-\n-/* The following two functions are used only with __mf_opts.heur_std_data.\n-   We're interested in recording the location of the thread-local errno\n-   variable.\n-\n-   Note that this doesn't handle TLS references in general; we have no\n-   visibility into __tls_get_data for when that memory is allocated at\n-   runtime.  Hopefully we get to see the malloc or mmap operation that\n-   eventually allocates the backing store.  */\n-\n-/* Describe the startup information for a new user thread.  */\n-struct mf_thread_start_info\n-{\n-  /* The user's thread entry point and argument.  */\n-  void * (*user_fn)(void *);\n-  void *user_arg;\n-};\n-\n-\n-static void\n-__mf_pthread_cleanup (void *arg)\n-{\n-  if (__mf_opts.heur_std_data)\n-    __mf_unregister (&errno, sizeof (errno), __MF_TYPE_GUESS);\n-\n-#if !defined(HAVE_TLS) || defined(USE_EMUTLS)\n-  struct mf_thread_data *data = __mf_find_threadinfo (0);\n-  if (data)\n-    data->used_p = 0;\n-#endif\n-}\n-\n-\n-static void *\n-__mf_pthread_spawner (void *arg)\n-{\n-  void *result = NULL;\n-\n-  __mf_set_state (active);\n-\n-  /* NB: We could use __MF_TYPE_STATIC here, but we guess that the thread\n-     errno is coming out of some dynamically allocated pool that we already\n-     know of as __MF_TYPE_HEAP. */\n-  if (__mf_opts.heur_std_data)\n-    __mf_register (&errno, sizeof (errno), __MF_TYPE_GUESS,\n-\t\t   \"errno area (thread)\");\n-\n-  /* We considered using pthread_key_t objects instead of these\n-     cleanup stacks, but they were less cooperative with the\n-     interposed malloc hooks in libmudflap.  */\n-  /* ??? The pthread_key_t problem is solved above...  */\n-  pthread_cleanup_push (__mf_pthread_cleanup, NULL);\n-\n-  /* Extract given entry point and argument.  */\n-  struct mf_thread_start_info *psi = arg;\n-  void * (*user_fn)(void *) = psi->user_fn;\n-  void *user_arg = psi->user_arg;\n-  CALL_REAL (free, arg);\n-\n-  result = (*user_fn)(user_arg);\n-\n-  pthread_cleanup_pop (1 /* execute */);\n-\n-  return result;\n-}\n-\n-\n-#if PIC\n-/* A special bootstrap variant. */\n-int\n-__mf_0fn_pthread_create (pthread_t *thr, const pthread_attr_t *attr,\n-\t\t\t void * (*start) (void *), void *arg)\n-{\n-  return -1;\n-}\n-#endif\n-\n-\n-#undef pthread_create\n-WRAPPER(int, pthread_create, pthread_t *thr, const pthread_attr_t *attr,\n-\t void * (*start) (void *), void *arg)\n-{\n-  struct mf_thread_start_info *si;\n-\n-  TRACE (\"pthread_create\\n\");\n-\n-  /* Fill in startup-control fields.  */\n-  si = CALL_REAL (malloc, sizeof (*si));\n-  si->user_fn = start;\n-  si->user_arg = arg;\n-\n-  /* Actually create the thread.  */\n-  return CALL_REAL (pthread_create, thr, attr, __mf_pthread_spawner, si);\n-}"}, {"sha": "107ed40f6644c6e111f6446a57eb0a5d60f36d1a", "filename": "libmudflap/mf-impl.h", "status": "removed", "additions": 0, "deletions": 419, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Fmf-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Fmf-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-impl.h?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,419 +0,0 @@\n-/* Implementation header for mudflap runtime library.\n-   Mudflap: narrow-pointer bounds-checking by tree rewriting.\n-   Copyright (C) 2002-2013 Free Software Foundation, Inc.\n-   Contributed by Frank Ch. Eigler <fche@redhat.com>\n-   and Graydon Hoare <graydon@redhat.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#ifndef __MF_IMPL_H\n-#define __MF_IMPL_H\n-\n-#ifdef _MUDFLAP\n-#error \"Do not compile this file with -fmudflap!\"\n-#endif\n-\n-#if HAVE_PTHREAD_H\n-#include <pthread.h>\n-#elif LIBMUDFLAPTH\n-#error \"Cannot build libmudflapth without pthread.h.\"\n-#endif\n-\n-#if HAVE_STDINT_H\n-#include <stdint.h>\n-#else\n-typedef __mf_uintptr_t uintptr_t;\n-#endif\n-\n-/* Private definitions related to mf-runtime.h  */\n-\n-#define __MF_TYPE_MAX_CEM  __MF_TYPE_STACK  /* largest type# for the cemetery */\n-#define __MF_TYPE_MAX __MF_TYPE_GUESS\n-\n-\n-#ifndef max\n-#define max(a,b) ((a) > (b) ? (a) : (b))\n-#endif\n-\n-#ifndef min\n-#define min(a,b) ((a) < (b) ? (a) : (b))\n-#endif\n-\n-/* Address calculation macros.  */\n-\n-#define MINPTR ((uintptr_t) 0)\n-#define MAXPTR (~ (uintptr_t) 0)\n-\n-/* Clamp the addition/subtraction of uintptr_t's to [MINPTR,MAXPTR] */\n-#define CLAMPSUB(ptr,offset) (((uintptr_t) ptr) >= (offset) ? ((uintptr_t) ptr)-((uintptr_t) offset) : MINPTR)\n-#define CLAMPADD(ptr,offset) (((uintptr_t) ptr) <= MAXPTR-(offset) ? ((uintptr_t) ptr)+((uintptr_t) offset) : MAXPTR)\n-#define CLAMPSZ(ptr,size) ((size) ? (((uintptr_t) ptr) <= MAXPTR-(size)+1 ? ((uintptr_t) ptr)+((uintptr_t) size) - 1 : MAXPTR) : ((uintptr_t) ptr))\n-\n-#define __MF_CACHE_INDEX(ptr) ((((uintptr_t) (ptr)) >> __mf_lc_shift) & __mf_lc_mask)\n-#define __MF_CACHE_MISS_P(ptr,sz) ({ \\\n-             struct __mf_cache *elem = & __mf_lookup_cache[__MF_CACHE_INDEX((ptr))]; \\\n-             ((elem->low > (uintptr_t) (ptr)) ||                  \\\n-\t      (elem->high < (CLAMPADD((uintptr_t) (ptr), (uintptr_t) CLAMPSUB(sz,1) )))); })\n-/* XXX: the above should use CLAMPSZ () */\n-\n-\n-\n-/* Private functions. */\n-\n-extern void __mf_violation (void *ptr, size_t sz,\n-\t\t\t    uintptr_t pc, const char *location,\n-\t\t\t    int type);\n-extern size_t __mf_backtrace (char ***, void *, unsigned);\n-extern int __mf_heuristic_check (uintptr_t, uintptr_t);\n-\n-/* ------------------------------------------------------------------------ */\n-/* Type definitions. */\n-/* ------------------------------------------------------------------------ */\n-\n-/* The mf_state type codes describe recursion and initialization order.\n-\n-   reentrant means we are inside a mf-runtime support routine, such as\n-   __mf_register, and thus there should be no calls to any wrapped functions,\n-   such as the wrapped malloc.  This indicates a bug if it occurs.\n-   in_malloc means we are inside a real malloc call inside a wrapped malloc\n-   call, and thus there should be no calls to any wrapped functions like the\n-   wrapped mmap.  This happens on some systems due to how the system libraries\n-   are constructed.  */\n-\n-enum __mf_state_enum { active, reentrant, in_malloc }; \n-\n-/* The __mf_options structure records optional or tunable aspects of the\n- mudflap library's behavior. There is a single global instance of this\n- structure which is populated from user input (in an environment variable)\n- when the library initializes. */\n-\n-struct __mf_options\n-{\n-  /* Emit a trace message for each call. */\n-  unsigned trace_mf_calls;\n-\n-  /* Collect and emit statistics. */\n-  unsigned collect_stats;\n-\n-  /* Set up a SIGUSR1 -> __mf_report handler. */\n-  unsigned sigusr1_report;\n-\n-  /* Execute internal checking code. */\n-  unsigned internal_checking;\n-\n-  /* Age object liveness periodically. */\n-  unsigned tree_aging;\n-\n-  /* Adapt the lookup cache to working set. */\n-  unsigned adapt_cache;\n-\n-  /* Print list of leaked heap objects on shutdown. */\n-  unsigned print_leaks;\n-\n-#ifdef HAVE___LIBC_FREERES\n-  /* Call __libc_freeres before leak analysis. */\n-  unsigned call_libc_freeres;\n-#endif\n-\n-  /* Detect reads of uninitialized objects. */\n-  unsigned check_initialization;\n-\n-  /* Print verbose description of violations. */\n-  unsigned verbose_violations;\n-\n-  /* Abbreviate duplicate object descriptions.  */\n-  unsigned abbreviate;\n-\n-  /* Emit internal tracing message. */\n-  unsigned verbose_trace;\n-\n-  /* Wipe stack/heap objects upon unwind.  */\n-  unsigned wipe_stack;\n-  unsigned wipe_heap;\n-\n-  /* Maintain a queue of this many deferred free()s,\n-     to trap use of freed memory. */\n-  unsigned free_queue_length;\n-\n-  /* Maintain a history of this many past unregistered objects. */\n-  unsigned persistent_count;\n-\n-  /* Pad allocated extents by this many bytes on either side. */\n-  unsigned crumple_zone;\n-\n-  /* Maintain this many stack frames for contexts. */\n-  unsigned backtrace;\n-\n-  /* Ignore read operations even if mode_check is in effect.  */\n-  unsigned ignore_reads;\n-\n-  /* Collect register/unregister timestamps.  */\n-  unsigned timestamps;\n-\n-#ifdef LIBMUDFLAPTH\n-  /* Thread stack size.  */\n-  unsigned thread_stack;\n-#endif\n-\n-  /* Major operation mode */\n-#define mode_nop 0      /* Do nothing.  */\n-#define mode_populate 1 /* Populate tree but do not check for violations.  */\n-#define mode_check 2    /* Populate and check for violations (normal).  */\n-#define mode_violate 3  /* Trigger a violation on every call (diagnostic).  */\n-  unsigned mudflap_mode;\n-\n-  /* How to handle a violation. */\n-#define viol_nop 0   /* Return control to application. */\n-#define viol_segv 1  /* Signal self with segv. */\n-#define viol_abort 2 /* Call abort (). */\n-#define viol_gdb 3   /* Fork a debugger on self */\n-  unsigned violation_mode;\n-\n-  /* Violation heuristics selection. */\n-  unsigned heur_stack_bound; /* allow current stack region */\n-  unsigned heur_proc_map;  /* allow & cache /proc/self/map regions.  */\n-  unsigned heur_start_end; /* allow _start .. _end */\n-  unsigned heur_std_data; /* allow & cache stdlib data */\n-};\n-\n-\n-#ifdef PIC\n-\n-/* This is a table of dynamically resolved function pointers. */\n-\n-struct __mf_dynamic_entry\n-{\n-  void *pointer;\n-  char *name;\n-  char *version;\n-};\n-\n-/* The definition of the array (mf-runtime.c) must match the enums!  */\n-extern struct __mf_dynamic_entry __mf_dynamic[];\n-enum __mf_dynamic_index\n-{\n-  dyn_calloc, dyn_free, dyn_malloc, dyn_mmap,\n-#ifdef HAVE_MMAP64\n-  dyn_mmap64,\n-#endif\n-  dyn_munmap, dyn_realloc,\n-  dyn_INITRESOLVE,  /* Marker for last init-time resolution. */\n-#ifdef LIBMUDFLAPTH\n-  dyn_pthread_create\n-#endif\n-};\n-\n-#endif /* PIC */\n-\n-/* ------------------------------------------------------------------------ */\n-/* Private global variables. */\n-/* ------------------------------------------------------------------------ */\n-\n-#ifdef LIBMUDFLAPTH\n-extern pthread_mutex_t __mf_biglock;\n-#define LOCKTH() do { extern unsigned long __mf_lock_contention; \\\n-                      int rc = pthread_mutex_trylock (& __mf_biglock); \\\n-                      if (rc) { __mf_lock_contention ++; \\\n-                                rc = pthread_mutex_lock (& __mf_biglock); } \\\n-                      assert (rc==0); } while (0)\n-#define UNLOCKTH() do { int rc = pthread_mutex_unlock (& __mf_biglock); \\\n-                        assert (rc==0); } while (0)\n-#else\n-#define LOCKTH() do {} while (0)\n-#define UNLOCKTH() do {} while (0)\n-#endif\n-\n-#if defined(LIBMUDFLAPTH) && (!defined(HAVE_TLS) || defined(USE_EMUTLS))\n-extern enum __mf_state_enum __mf_get_state (void);\n-extern void __mf_set_state (enum __mf_state_enum);\n-#else\n-# ifdef LIBMUDFLAPTH\n-extern __thread enum __mf_state_enum __mf_state_1;\n-# else\n-extern enum __mf_state_enum __mf_state_1;\n-# endif\n-static inline enum __mf_state_enum __mf_get_state (void)\n-{\n-  return __mf_state_1;\n-}\n-static inline void __mf_set_state (enum __mf_state_enum s)\n-{\n-  __mf_state_1 = s;\n-}\n-#endif\n-\n-extern int __mf_starting_p;\n-extern struct __mf_options __mf_opts;\n-\n-/* ------------------------------------------------------------------------ */\n-/* Utility macros. */\n-/* ------------------------------------------------------------------------ */\n-\n-#define UNLIKELY(e) (__builtin_expect (!!(e), 0))\n-#define LIKELY(e) (__builtin_expect (!!(e), 1))\n-#define STRINGIFY2(e) #e\n-#define STRINGIFY(e) STRINGIFY2(e)\n-\n-#ifdef LIBMUDFLAPTH\n-#define VERBOSE_TRACE(...) \\\n-  do { if (UNLIKELY (__mf_opts.verbose_trace)) {  \\\n-      fprintf (stderr, \"mf(%u): \", (unsigned) pthread_self ()); \\\n-      fprintf (stderr, __VA_ARGS__); \\\n-    } } while (0)\n-#define TRACE(...) \\\n-  do { if (UNLIKELY (__mf_opts.trace_mf_calls)) { \\\n-      fprintf (stderr, \"mf(%u): \", (unsigned) pthread_self ()); \\\n-      fprintf (stderr, __VA_ARGS__); \\\n-    } } while (0)\n-#else\n-#define VERBOSE_TRACE(...) \\\n-  do { if (UNLIKELY (__mf_opts.verbose_trace)) {  \\\n-      fprintf (stderr, \"mf: \"); \\\n-      fprintf (stderr, __VA_ARGS__); \\\n-    } } while (0)\n-#define TRACE(...) \\\n-  do { if (UNLIKELY (__mf_opts.trace_mf_calls)) { \\\n-      fprintf (stderr, \"mf: \"); \\\n-      fprintf (stderr, __VA_ARGS__); \\\n-    } } while (0)\n-#endif\n-\n-\n-#define __MF_PERSIST_MAX 256\n-#define __MF_FREEQ_MAX 256\n-\n-/*\n-   Wrapping and redirection:\n-\n-   Mudflap redirects a number of libc functions into itself, for \"cheap\"\n-   verification (eg. strcpy, bzero, memcpy) and also to register /\n-   unregister regions of memory as they are manipulated by the program\n-   (eg. malloc/free, mmap/munmap).\n-\n-   There are two methods of wrapping.\n-\n-   (1) The static method involves a list of -wrap=foo flags being passed to\n-   the linker, which then links references to \"foo\" to the symbol\n-   \"__wrap_foo\", and links references to \"__real_foo\" to the symbol \"foo\".\n-   When compiled without -DPIC, libmudflap.a contains such __wrap_foo\n-   functions which delegate to __real_foo functions in libc to get their\n-   work done.\n-\n-   (2) The dynamic method involves providing a definition of symbol foo in\n-   libmudflap.so and linking it earlier in the compiler command line,\n-   before libc.so. The function \"foo\" in libmudflap must then call\n-   dlsym(RTLD_NEXT, \"foo\") to acquire a pointer to the \"real\" libc foo, or\n-   at least the \"next\" foo in the dynamic link resolution order.\n-\n-   We switch between these two techniques by the presence of the -DPIC\n-   #define passed in by libtool when building libmudflap.\n-*/\n-\n-\n-#ifdef PIC\n-\n-extern void __mf_resolve_single_dynamic (struct __mf_dynamic_entry *);\n-\n-#define _GNU_SOURCE\n-#include <dlfcn.h>\n-\n-#define WRAPPER(ret, fname, ...)                      \\\n-ret __wrap_ ## fname (__VA_ARGS__)                    \\\n-    __attribute__ (( alias  (#fname)  ));             \\\n-ret __real_ ## fname (__VA_ARGS__)                    \\\n-    __attribute__ (( alias  (#fname)  ));             \\\n-ret fname (__VA_ARGS__)\n-#define DECLARE(ty, fname, ...)                       \\\n- typedef ty (*__mf_fn_ ## fname) (__VA_ARGS__);       \\\n- extern ty __mf_0fn_ ## fname (__VA_ARGS__);\n-#define CALL_REAL(fname, ...)                         \\\n-  ({__mf_starting_p \\\n-     ? __mf_0fn_ ## fname (__VA_ARGS__) \\\n-    : (__mf_resolve_single_dynamic (& __mf_dynamic[dyn_ ## fname]), \\\n-       (((__mf_fn_ ## fname)(__mf_dynamic[dyn_ ## fname].pointer)) (__VA_ARGS__)));})\n-#define CALL_BACKUP(fname, ...)                       \\\n-  __mf_0fn_ ## fname(__VA_ARGS__)\n-\n-#else /* not PIC --> static library */\n-\n-#define WRAPPER(ret, fname, ...)            \\\n-ret __wrap_ ## fname (__VA_ARGS__)\n-#define DECLARE(ty, fname, ...)             \\\n- extern ty __real_ ## fname (__VA_ARGS__)\n-#define CALL_REAL(fname, ...)               \\\n- __real_ ## fname (__VA_ARGS__)\n-#define CALL_BACKUP(fname, ...)             \\\n-  __real_ ## fname(__VA_ARGS__)\n-\n-#endif /* PIC */\n-\n-/* WRAPPER2 is for functions intercepted via macros at compile time. */\n-#define WRAPPER2(ret, fname, ...)                     \\\n-ret __mfwrap_ ## fname (__VA_ARGS__)\n-\n-\n-/* Utility macros for mf-hooks*.c */\n-\n-#define MF_VALIDATE_EXTENT(value,size,acc,context) \\\n- do { \\\n-  if (UNLIKELY (size > 0 && __MF_CACHE_MISS_P (value, size))) \\\n-    if (acc == __MF_CHECK_WRITE || ! __mf_opts.ignore_reads) \\\n-    __mf_check ((void *) (value), (size), acc, \"(\" context \")\"); \\\n- } while (0)\n-#define BEGIN_PROTECT(fname, ...)       \\\n-  if (UNLIKELY (__mf_starting_p)) \\\n-  {                                         \\\n-    return CALL_BACKUP(fname, __VA_ARGS__); \\\n-  }                                         \\\n-  else if (UNLIKELY (__mf_get_state () == reentrant))   \\\n-  {                                         \\\n-    extern unsigned long __mf_reentrancy;   \\\n-    __mf_reentrancy ++; \\\n-    return CALL_REAL(fname, __VA_ARGS__);   \\\n-  }                                         \\\n-  else if (UNLIKELY (__mf_get_state () == in_malloc))   \\\n-  {                                         \\\n-    return CALL_REAL(fname, __VA_ARGS__);   \\\n-  }                                         \\\n-  else                                      \\\n-  {                                         \\\n-    TRACE (\"%s\\n\", __PRETTY_FUNCTION__); \\\n-  }\n-\n-/* There is an assumption here that these will only be called in routines\n-   that call BEGIN_PROTECT at the start, and hence the state must always\n-   be active when BEGIN_MALLOC_PROTECT is called.  */\n-#define BEGIN_MALLOC_PROTECT() \\\n-  __mf_set_state (in_malloc)\n-\n-#define END_MALLOC_PROTECT() \\\n-  __mf_set_state (active)\n-\n-/* Unlocked variants of main entry points from mf-runtime.h.  */\n-extern void __mfu_check (void *ptr, size_t sz, int type, const char *location);\n-extern void __mfu_register (void *ptr, size_t sz, int type, const char *name);\n-extern void __mfu_unregister (void *ptr, size_t sz, int type);\n-extern void __mfu_report ();\n-extern int __mfu_set_options (const char *opts);\n-\n-\n-#endif /* __MF_IMPL_H */"}, {"sha": "96a396ef3199674a09ae1dfd3832a221ff553604", "filename": "libmudflap/mf-runtime.c", "status": "removed", "additions": 0, "deletions": 2886, "changes": 2886, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Fmf-runtime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Fmf-runtime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-runtime.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,2886 +0,0 @@\n-/* Mudflap: narrow-pointer bounds-checking by tree rewriting.\n-   Copyright (C) 2002-2013 Free Software Foundation, Inc.\n-   Contributed by Frank Ch. Eigler <fche@redhat.com>\n-   and Graydon Hoare <graydon@redhat.com>\n-   Splay Tree code originally by Mark Mitchell <mark@markmitchell.com>,\n-   adapted from libiberty.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-\n-/* These attempt to coax various unix flavours to declare all our\n-   needed tidbits in the system headers.  */\n-#if !defined(__FreeBSD__) && !defined(__APPLE__)\n-#define _POSIX_SOURCE\n-#endif /* Some BSDs break <sys/socket.h> if this is defined. */\n-#define _GNU_SOURCE\n-#define _XOPEN_SOURCE\n-#define _BSD_TYPES\n-#define __EXTENSIONS__\n-#define _ALL_SOURCE\n-#define _LARGE_FILE_API\n-#define _XOPEN_SOURCE_EXTENDED 1\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <sys/types.h>\n-#include <sys/time.h>\n-#include <time.h>\n-#include <unistd.h>\n-#ifdef HAVE_EXECINFO_H\n-#include <execinfo.h>\n-#endif\n-#ifdef HAVE_SIGNAL_H\n-#include <signal.h>\n-#endif\n-#include <assert.h>\n-\n-#include <string.h>\n-#include <limits.h>\n-#include <sys/types.h>\n-#include <signal.h>\n-#include <errno.h>\n-#include <ctype.h>\n-\n-#include \"mf-runtime.h\"\n-#include \"mf-impl.h\"\n-\n-\n-/* ------------------------------------------------------------------------ */\n-/* Splay-tree implementation.  */\n-\n-typedef uintptr_t mfsplay_tree_key;\n-typedef void *mfsplay_tree_value;\n-\n-/* Forward declaration for a node in the tree.  */\n-typedef struct mfsplay_tree_node_s *mfsplay_tree_node;\n-\n-/* The type of a function used to iterate over the tree.  */\n-typedef int (*mfsplay_tree_foreach_fn) (mfsplay_tree_node, void *);\n-\n-/* The nodes in the splay tree.  */\n-struct mfsplay_tree_node_s\n-{\n-  /* Data.  */\n-  mfsplay_tree_key key;\n-  mfsplay_tree_value value;\n-  /* Children.  */\n-  mfsplay_tree_node left;\n-  mfsplay_tree_node right;\n-  /* XXX: The addition of a parent pointer may eliminate some recursion.  */\n-};\n-\n-/* The splay tree itself.  */\n-struct mfsplay_tree_s\n-{\n-  /* The root of the tree.  */\n-  mfsplay_tree_node root;\n-\n-  /* The last key value for which the tree has been splayed, but not\n-     since modified.  */\n-  mfsplay_tree_key last_splayed_key;\n-  int last_splayed_key_p;\n-\n-  /* Statistics.  */\n-  unsigned num_keys;\n-\n-  /* Traversal recursion control flags.  */\n-  unsigned max_depth;\n-  unsigned depth;\n-  unsigned rebalance_p;\n-};\n-typedef struct mfsplay_tree_s *mfsplay_tree;\n-\n-static mfsplay_tree mfsplay_tree_new (void);\n-static mfsplay_tree_node mfsplay_tree_insert (mfsplay_tree, mfsplay_tree_key, mfsplay_tree_value);\n-static void mfsplay_tree_remove (mfsplay_tree, mfsplay_tree_key);\n-static mfsplay_tree_node mfsplay_tree_lookup (mfsplay_tree, mfsplay_tree_key);\n-static mfsplay_tree_node mfsplay_tree_predecessor (mfsplay_tree, mfsplay_tree_key);\n-static mfsplay_tree_node mfsplay_tree_successor (mfsplay_tree, mfsplay_tree_key);\n-static int mfsplay_tree_foreach (mfsplay_tree, mfsplay_tree_foreach_fn, void *);\n-static void mfsplay_tree_rebalance (mfsplay_tree sp);\n-\n-/* ------------------------------------------------------------------------ */\n-/* Utility macros */\n-\n-#define CTOR  __attribute__ ((constructor))\n-#define DTOR  __attribute__ ((destructor))\n-\n-\n-/* Codes to describe the context in which a violation occurs. */\n-#define __MF_VIOL_UNKNOWN 0\n-#define __MF_VIOL_READ 1\n-#define __MF_VIOL_WRITE 2\n-#define __MF_VIOL_REGISTER 3\n-#define __MF_VIOL_UNREGISTER 4\n-#define __MF_VIOL_WATCH 5\n-\n-/* Protect against recursive calls. */\n-\n-static void\n-begin_recursion_protect1 (const char *pf)\n-{\n-  if (__mf_get_state () == reentrant)\n-    {\n-      write (2, \"mf: erroneous reentrancy detected in `\", 38);\n-      write (2, pf, strlen(pf));\n-      write (2, \"'\\n\", 2); \\\n-      abort ();\n-    }\n-  __mf_set_state (reentrant);\n-}\n-\n-#define BEGIN_RECURSION_PROTECT() \\\n-  begin_recursion_protect1 (__PRETTY_FUNCTION__)\n-\n-#define END_RECURSION_PROTECT() \\\n-  __mf_set_state (active)\n-\n-/* ------------------------------------------------------------------------ */\n-/* Required globals.  */\n-\n-#define LOOKUP_CACHE_MASK_DFL 1023\n-#define LOOKUP_CACHE_SIZE_MAX 65536 /* Allows max CACHE_MASK 0xFFFF */\n-#define LOOKUP_CACHE_SHIFT_DFL 2\n-\n-struct __mf_cache __mf_lookup_cache [LOOKUP_CACHE_SIZE_MAX];\n-uintptr_t __mf_lc_mask = LOOKUP_CACHE_MASK_DFL;\n-unsigned char __mf_lc_shift = LOOKUP_CACHE_SHIFT_DFL;\n-#define LOOKUP_CACHE_SIZE (__mf_lc_mask + 1)\n-\n-struct __mf_options __mf_opts;\n-int __mf_starting_p = 1;\n-\n-#ifdef LIBMUDFLAPTH\n-#if defined(HAVE_TLS) && !defined(USE_EMUTLS)\n-__thread enum __mf_state_enum __mf_state_1 = reentrant;\n-#endif\n-#else\n-enum __mf_state_enum __mf_state_1 = reentrant;\n-#endif\n-\n-#ifdef LIBMUDFLAPTH\n-pthread_mutex_t __mf_biglock =\n-#ifdef PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP\n-       PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;\n-#else\n-       PTHREAD_MUTEX_INITIALIZER;\n-#endif\n-#endif\n-\n-/* Use HAVE_PTHREAD_H here instead of LIBMUDFLAPTH, so that even\n-   the libmudflap.la (no threading support) can diagnose whether\n-   the application is linked with -lpthread.  See __mf_usage() below.  */\n-#if HAVE_PTHREAD_H\n-#ifdef _POSIX_THREADS\n-#pragma weak pthread_join\n-#else\n-#define pthread_join NULL\n-#endif\n-#endif\n-\n-\n-/* ------------------------------------------------------------------------ */\n-/* stats-related globals.  */\n-\n-static unsigned long __mf_count_check;\n-static unsigned long __mf_lookup_cache_reusecount [LOOKUP_CACHE_SIZE_MAX];\n-static unsigned long __mf_count_register;\n-static unsigned long __mf_total_register_size [__MF_TYPE_MAX+1];\n-static unsigned long __mf_count_unregister;\n-static unsigned long __mf_total_unregister_size;\n-static unsigned long __mf_count_violation [__MF_VIOL_WATCH+1];\n-static unsigned long __mf_sigusr1_received;\n-static unsigned long __mf_sigusr1_handled;\n-/* not static */ unsigned long __mf_reentrancy;\n-#ifdef LIBMUDFLAPTH\n-/* not static */ unsigned long __mf_lock_contention;\n-#endif\n-\n-\n-/* ------------------------------------------------------------------------ */\n-/* mode-check-related globals.  */\n-\n-typedef struct __mf_object\n-{\n-  uintptr_t low, high; /* __mf_register parameters */\n-  const char *name;\n-  char type; /* __MF_TYPE_something */\n-  char watching_p; /* Trigger a VIOL_WATCH on access? */\n-  unsigned read_count; /* Number of times __mf_check/read was called on this object.  */\n-  unsigned write_count; /* Likewise for __mf_check/write.  */\n-  unsigned liveness; /* A measure of recent checking activity.  */\n-  unsigned description_epoch; /* Last epoch __mf_describe_object printed this.  */\n-\n-  uintptr_t alloc_pc;\n-  struct timeval alloc_time;\n-  char **alloc_backtrace;\n-  size_t alloc_backtrace_size;\n-#ifdef LIBMUDFLAPTH\n-  pthread_t alloc_thread;\n-#endif\n-\n-  int deallocated_p;\n-  uintptr_t dealloc_pc;\n-  struct timeval dealloc_time;\n-  char **dealloc_backtrace;\n-  size_t dealloc_backtrace_size;\n-#ifdef LIBMUDFLAPTH\n-  pthread_t dealloc_thread;\n-#endif\n-} __mf_object_t;\n-\n-/* Live objects: splay trees, separated by type, ordered on .low (base address).  */\n-/* Actually stored as static vars within lookup function below.  */\n-\n-/* Dead objects: circular arrays; _MIN_CEM .. _MAX_CEM only */\n-static unsigned __mf_object_dead_head[__MF_TYPE_MAX_CEM+1]; /* next empty spot */\n-static __mf_object_t *__mf_object_cemetary[__MF_TYPE_MAX_CEM+1][__MF_PERSIST_MAX];\n-\n-\n-/* ------------------------------------------------------------------------ */\n-/* Forward function declarations */\n-\n-void __mf_init () CTOR;\n-static void __mf_sigusr1_respond ();\n-static unsigned __mf_find_objects (uintptr_t ptr_low, uintptr_t ptr_high,\n-                                   __mf_object_t **objs, unsigned max_objs);\n-static unsigned __mf_find_objects2 (uintptr_t ptr_low, uintptr_t ptr_high,\n-                                    __mf_object_t **objs, unsigned max_objs, int type);\n-static unsigned __mf_find_dead_objects (uintptr_t ptr_low, uintptr_t ptr_high,\n-                                        __mf_object_t **objs, unsigned max_objs);\n-static void __mf_adapt_cache ();\n-static void __mf_describe_object (__mf_object_t *obj);\n-static unsigned __mf_watch_or_not (void *ptr, size_t sz, char flag);\n-static mfsplay_tree __mf_object_tree (int type);\n-static void __mf_link_object (__mf_object_t *node);\n-static void __mf_unlink_object (__mf_object_t *node);\n-\n-\n-/* ------------------------------------------------------------------------ */\n-/* Configuration engine */\n-\n-static void\n-__mf_set_default_options ()\n-{\n-  memset (& __mf_opts, 0, sizeof (__mf_opts));\n-\n-  __mf_opts.adapt_cache = 1000003;\n-  __mf_opts.abbreviate = 1;\n-  __mf_opts.verbose_violations = 1;\n-  __mf_opts.free_queue_length = 4;\n-  __mf_opts.persistent_count = 100;\n-  __mf_opts.crumple_zone = 32;\n-  __mf_opts.backtrace = 4;\n-  __mf_opts.timestamps = 1;\n-  __mf_opts.mudflap_mode = mode_check;\n-  __mf_opts.violation_mode = viol_nop;\n-#ifdef HAVE___LIBC_FREERES\n-  __mf_opts.call_libc_freeres = 1;\n-#endif\n-  __mf_opts.heur_std_data = 1;\n-#ifdef LIBMUDFLAPTH\n-  __mf_opts.thread_stack = 0;\n-#endif\n-\n-  /* PR41443: Beware that the above flags will be applied to\n-     setuid/setgid binaries, and cannot be overriden with\n-     $MUDFLAP_OPTIONS.  So the defaults must be non-exploitable. \n-\n-     Should we consider making the default violation_mode something\n-     harsher than viol_nop?  OTOH, glibc's MALLOC_CHECK_ is disabled\n-     by default for these same programs. */\n-}\n-\n-static struct mudoption\n-{\n-  char *name;\n-  char *description;\n-  enum\n-    {\n-      set_option,\n-      read_integer_option,\n-    } type;\n-  unsigned value;\n-  unsigned *target;\n-}\n-options [] =\n-  {\n-    {\"mode-nop\",\n-     \"mudflaps do nothing\",\n-     set_option, (unsigned)mode_nop, (unsigned *)&__mf_opts.mudflap_mode},\n-    {\"mode-populate\",\n-     \"mudflaps populate object tree\",\n-     set_option, (unsigned)mode_populate, (unsigned *)&__mf_opts.mudflap_mode},\n-    {\"mode-check\",\n-     \"mudflaps check for memory violations\",\n-     set_option, (unsigned)mode_check, (unsigned *)&__mf_opts.mudflap_mode},\n-    {\"mode-violate\",\n-     \"mudflaps always cause violations (diagnostic)\",\n-     set_option, (unsigned)mode_violate, (unsigned *)&__mf_opts.mudflap_mode},\n-\n-    {\"viol-nop\",\n-     \"violations do not change program execution\",\n-     set_option, (unsigned)viol_nop, (unsigned *)&__mf_opts.violation_mode},\n-    {\"viol-abort\",\n-     \"violations cause a call to abort()\",\n-     set_option, (unsigned)viol_abort, (unsigned *)&__mf_opts.violation_mode},\n-    {\"viol-segv\",\n-     \"violations are promoted to SIGSEGV signals\",\n-     set_option, (unsigned)viol_segv, (unsigned *)&__mf_opts.violation_mode},\n-    {\"viol-gdb\",\n-     \"violations fork a gdb process attached to current program\",\n-     set_option, (unsigned)viol_gdb, (unsigned *)&__mf_opts.violation_mode},\n-    {\"trace-calls\",\n-     \"trace calls to mudflap runtime library\",\n-     set_option, 1, &__mf_opts.trace_mf_calls},\n-    {\"verbose-trace\",\n-     \"trace internal events within mudflap runtime library\",\n-     set_option, 1, &__mf_opts.verbose_trace},\n-    {\"collect-stats\",\n-     \"collect statistics on mudflap's operation\",\n-     set_option, 1, &__mf_opts.collect_stats},\n-#ifdef SIGUSR1\n-    {\"sigusr1-report\",\n-     \"print report upon SIGUSR1\",\n-     set_option, 1, &__mf_opts.sigusr1_report},\n-#endif\n-    {\"internal-checking\",\n-     \"perform more expensive internal checking\",\n-     set_option, 1, &__mf_opts.internal_checking},\n-    {\"print-leaks\",\n-     \"print any memory leaks at program shutdown\",\n-     set_option, 1, &__mf_opts.print_leaks},\n-#ifdef HAVE___LIBC_FREERES\n-    {\"libc-freeres\",\n-     \"call glibc __libc_freeres at shutdown for better leak data\",\n-     set_option, 1, &__mf_opts.call_libc_freeres},\n-#endif\n-    {\"check-initialization\",\n-     \"detect uninitialized object reads\",\n-     set_option, 1, &__mf_opts.check_initialization},\n-    {\"verbose-violations\",\n-     \"print verbose messages when memory violations occur\",\n-     set_option, 1, &__mf_opts.verbose_violations},\n-    {\"abbreviate\",\n-     \"abbreviate repetitive listings\",\n-     set_option, 1, &__mf_opts.abbreviate},\n-    {\"timestamps\",\n-     \"track object lifetime timestamps\",\n-     set_option, 1, &__mf_opts.timestamps},\n-    {\"ignore-reads\",\n-     \"ignore read accesses - assume okay\",\n-     set_option, 1, &__mf_opts.ignore_reads},\n-    {\"wipe-stack\",\n-     \"wipe stack objects at unwind\",\n-     set_option, 1, &__mf_opts.wipe_stack},\n-    {\"wipe-heap\",\n-     \"wipe heap objects at free\",\n-     set_option, 1, &__mf_opts.wipe_heap},\n-    {\"heur-proc-map\",\n-     \"support /proc/self/map heuristics\",\n-     set_option, 1, &__mf_opts.heur_proc_map},\n-    {\"heur-stack-bound\",\n-     \"enable a simple upper stack bound heuristic\",\n-     set_option, 1, &__mf_opts.heur_stack_bound},\n-    {\"heur-start-end\",\n-     \"support _start.._end heuristics\",\n-     set_option, 1, &__mf_opts.heur_start_end},\n-    {\"heur-stdlib\",\n-     \"register standard library data (argv, errno, stdin, ...)\",\n-     set_option, 1, &__mf_opts.heur_std_data},\n-    {\"free-queue-length\",\n-     \"queue N deferred free() calls before performing them\",\n-     read_integer_option, 0, &__mf_opts.free_queue_length},\n-    {\"persistent-count\",\n-     \"keep a history of N unregistered regions\",\n-     read_integer_option, 0, &__mf_opts.persistent_count},\n-    {\"crumple-zone\",\n-     \"surround allocations with crumple zones of N bytes\",\n-     read_integer_option, 0, &__mf_opts.crumple_zone},\n-    /* XXX: not type-safe.\n-    {\"lc-mask\",\n-     \"set lookup cache size mask to N (2**M - 1)\",\n-     read_integer_option, 0, (int *)(&__mf_lc_mask)},\n-    {\"lc-shift\",\n-     \"set lookup cache pointer shift\",\n-     read_integer_option, 0, (int *)(&__mf_lc_shift)},\n-    */\n-    {\"lc-adapt\",\n-     \"adapt mask/shift parameters after N cache misses\",\n-     read_integer_option, 1, &__mf_opts.adapt_cache},\n-    {\"backtrace\",\n-     \"keep an N-level stack trace of each call context\",\n-     read_integer_option, 0, &__mf_opts.backtrace},\n-#ifdef LIBMUDFLAPTH\n-    {\"thread-stack\",\n-     \"override thread stacks allocation: N kB\",\n-     read_integer_option, 0, &__mf_opts.thread_stack},\n-#endif\n-    {0, 0, set_option, 0, NULL}\n-  };\n-\n-static void\n-__mf_usage ()\n-{\n-  struct mudoption *opt;\n-\n-  fprintf (stderr,\n-           \"This is a %s%sGCC \\\"mudflap\\\" memory-checked binary.\\n\"\n-           \"Mudflap is Copyright (C) 2002-2013 Free Software Foundation, Inc.\\n\"\n-           \"\\n\"\n-           \"Unless setuid, a program's mudflap options be set by an environment variable:\\n\"\n-           \"\\n\"\n-           \"$ export MUDFLAP_OPTIONS='<options>'\\n\"\n-           \"$ <mudflapped_program>\\n\"\n-           \"\\n\"\n-           \"where <options> is a space-separated list of \\n\"\n-           \"any of the following options.  Use `-no-OPTION' to disable options.\\n\"\n-           \"\\n\",\n-#if HAVE_PTHREAD_H\n-           (pthread_join ? \"multi-threaded \" : \"single-threaded \"),\n-#else\n-           \"\",\n-#endif\n-#if LIBMUDFLAPTH\n-           \"thread-aware \"\n-#else\n-           \"thread-unaware \"\n-#endif\n-            );\n-  /* XXX: The multi-threaded thread-unaware combination is bad.  */\n-\n-  for (opt = options; opt->name; opt++)\n-    {\n-      int default_p = (opt->value == * opt->target);\n-\n-      switch (opt->type)\n-        {\n-          char buf[128];\n-        case set_option:\n-          fprintf (stderr, \"-%-23.23s %s\", opt->name, opt->description);\n-          if (default_p)\n-            fprintf (stderr, \" [active]\\n\");\n-          else\n-            fprintf (stderr, \"\\n\");\n-          break;\n-        case read_integer_option:\n-          strncpy (buf, opt->name, 128);\n-          strncpy (buf + strlen (opt->name), \"=N\", 2);\n-          fprintf (stderr, \"-%-23.23s %s\", buf, opt->description);\n-          fprintf (stderr, \" [%d]\\n\", * opt->target);\n-          break;\n-        default: abort();\n-        }\n-    }\n-\n-  fprintf (stderr, \"\\n\");\n-}\n-\n-\n-int\n-__mf_set_options (const char *optstr)\n-{\n-  int rc;\n-  LOCKTH ();\n-  BEGIN_RECURSION_PROTECT ();\n-  rc = __mfu_set_options (optstr);\n-  /* XXX: It's not really that easy.  A change to a bunch of parameters\n-     can require updating auxiliary state or risk crashing:\n-     free_queue_length, crumple_zone ... */\n-  END_RECURSION_PROTECT ();\n-  UNLOCKTH ();\n-  return rc;\n-}\n-\n-\n-int\n-__mfu_set_options (const char *optstr)\n-{\n-  struct mudoption *opts = 0;\n-  char *nxt = 0;\n-  long tmp = 0;\n-  int rc = 0;\n-  const char *saved_optstr = optstr;\n-\n-  /* XXX: bounds-check for optstr! */\n-\n-  while (*optstr)\n-    {\n-      switch (*optstr) {\n-      case ' ':\n-      case '\\t':\n-      case '\\n':\n-        optstr++;\n-        break;\n-\n-      case '-':\n-        if (*optstr+1)\n-          {\n-            int negate = 0;\n-            optstr++;\n-\n-            if (*optstr == '?' ||\n-                strncmp (optstr, \"help\", 4) == 0)\n-              {\n-                /* Caller will print help and exit.  */\n-                return -1;\n-              }\n-\n-            if (strncmp (optstr, \"no-\", 3) == 0)\n-              {\n-                negate = 1;\n-                optstr = & optstr[3];\n-              }\n-\n-            for (opts = options; opts->name; opts++)\n-              {\n-                if (strncmp (optstr, opts->name, strlen (opts->name)) == 0)\n-                  {\n-                    optstr += strlen (opts->name);\n-                    assert (opts->target);\n-                    switch (opts->type)\n-                      {\n-                      case set_option:\n-                        if (negate)\n-                          *(opts->target) = 0;\n-                        else\n-                          *(opts->target) = opts->value;\n-                        break;\n-                      case read_integer_option:\n-                        if (! negate && (*optstr == '=' && *(optstr+1)))\n-                          {\n-                            optstr++;\n-                            tmp = strtol (optstr, &nxt, 10);\n-                            if ((optstr != nxt) && (tmp != LONG_MAX))\n-                              {\n-                                optstr = nxt;\n-                                *(opts->target) = (int)tmp;\n-                              }\n-                          }\n-                        else if (negate)\n-                          * opts->target = 0;\n-                        break;\n-                      }\n-                  }\n-              }\n-          }\n-        break;\n-\n-      default:\n-        fprintf (stderr,\n-                 \"warning: unrecognized string '%s' in mudflap options\\n\",\n-                 optstr);\n-        optstr += strlen (optstr);\n-        rc = -1;\n-        break;\n-      }\n-    }\n-\n-  /* Special post-processing: bound __mf_lc_mask and free_queue_length for security. */\n-  __mf_lc_mask &= (LOOKUP_CACHE_SIZE_MAX - 1);\n-  __mf_opts.free_queue_length &= (__MF_FREEQ_MAX - 1);\n-\n-  /* Clear the lookup cache, in case the parameters got changed.  */\n-  /* XXX: race */\n-  memset (__mf_lookup_cache, 0, sizeof(__mf_lookup_cache));\n-  /* void slot 0 */\n-  __mf_lookup_cache[0].low = MAXPTR;\n-\n-  TRACE (\"set options from `%s'\\n\", saved_optstr);\n-\n-  /* Call this unconditionally, in case -sigusr1-report was toggled. */\n-  __mf_sigusr1_respond ();\n-\n-  return rc;\n-}\n-\n-\n-#ifdef PIC\n-\n-void\n-__mf_resolve_single_dynamic (struct __mf_dynamic_entry *e)\n-{\n-  char *err;\n-\n-  assert (e);\n-  if (e->pointer) return;\n-\n-#if HAVE_DLVSYM\n-  if (e->version != NULL && e->version[0] != '\\0') /* non-null/empty */\n-    e->pointer = dlvsym (RTLD_NEXT, e->name, e->version);\n-  else\n-#endif\n-    e->pointer = dlsym (RTLD_NEXT, e->name);\n-\n-  err = dlerror ();\n-\n-  if (err)\n-    {\n-      fprintf (stderr, \"mf: error in dlsym(\\\"%s\\\"): %s\\n\",\n-               e->name, err);\n-      abort ();\n-    }\n-  if (! e->pointer)\n-    {\n-      fprintf (stderr, \"mf: dlsym(\\\"%s\\\") = NULL\\n\", e->name);\n-      abort ();\n-    }\n-}\n-\n-\n-static void\n-__mf_resolve_dynamics ()\n-{\n-  int i;\n-  for (i = 0; i < dyn_INITRESOLVE; i++)\n-    __mf_resolve_single_dynamic (& __mf_dynamic[i]);\n-}\n-\n-\n-/* NB: order must match enums in mf-impl.h */\n-struct __mf_dynamic_entry __mf_dynamic [] =\n-{\n-  {NULL, \"calloc\", NULL},\n-  {NULL, \"free\", NULL},\n-  {NULL, \"malloc\", NULL},\n-  {NULL, \"mmap\", NULL},\n-#ifdef HAVE_MMAP64\n-  {NULL, \"mmap64\", NULL},\n-#endif\n-  {NULL, \"munmap\", NULL},\n-  {NULL, \"realloc\", NULL},\n-  {NULL, \"DUMMY\", NULL}, /* dyn_INITRESOLVE */\n-#ifdef LIBMUDFLAPTH\n-  {NULL, \"pthread_create\", PTHREAD_CREATE_VERSION},\n-  {NULL, \"pthread_join\", NULL},\n-  {NULL, \"pthread_exit\", NULL}\n-#endif\n-};\n-\n-#endif /* PIC */\n-\n-\n-\n-/* ------------------------------------------------------------------------ */\n-\n-/* Lookup & manage automatic initialization of the five or so splay trees.  */\n-static mfsplay_tree\n-__mf_object_tree (int type)\n-{\n-  static mfsplay_tree trees [__MF_TYPE_MAX+1];\n-  assert (type >= 0 && type <= __MF_TYPE_MAX);\n-  if (UNLIKELY (trees[type] == NULL))\n-    trees[type] = mfsplay_tree_new ();\n-  return trees[type];\n-}\n-\n-\n-/* not static */void\n-__mf_init ()\n-{\n-  char *ov = 0;\n-\n-  /* Return if initialization has already been done. */\n-  if (LIKELY (__mf_starting_p == 0))\n-    return;\n-\n-#if defined(__FreeBSD__) && defined(LIBMUDFLAPTH)\n-  pthread_self();\n-  LOCKTH ();\n-  UNLOCKTH ();\n-#endif /* Prime mutex which calls calloc upon first lock to avoid deadlock. */\n-\n-  /* This initial bootstrap phase requires that __mf_starting_p = 1. */\n-#ifdef PIC\n-  __mf_resolve_dynamics ();\n-#endif\n-  __mf_starting_p = 0;\n-\n-  __mf_set_state (active);\n-\n-  __mf_set_default_options ();\n-\n-  if (getuid () == geteuid () && getgid () == getegid ()) /* PR41433, not setuid */\n-    ov = getenv (\"MUDFLAP_OPTIONS\");\n-  if (ov)\n-    {\n-      int rc = __mfu_set_options (ov);\n-      if (rc < 0)\n-        {\n-          __mf_usage ();\n-          exit (1);\n-        }\n-    }\n-\n-  /* Initialize to a non-zero description epoch. */\n-  __mf_describe_object (NULL);\n-\n-#define REG_RESERVED(obj) \\\n-  __mf_register (& obj, sizeof(obj), __MF_TYPE_NOACCESS, # obj)\n-\n-  REG_RESERVED (__mf_lookup_cache);\n-  REG_RESERVED (__mf_lc_mask);\n-  REG_RESERVED (__mf_lc_shift);\n-  /* XXX: others of our statics?  */\n-\n-  /* Prevent access to *NULL. */\n-  __mf_register (MINPTR, 1, __MF_TYPE_NOACCESS, \"NULL\");\n-  __mf_lookup_cache[0].low = (uintptr_t) -1;\n-}\n-\n-\n-\n-int\n-__wrap_main (int argc, char* argv[])\n-{\n-  extern char **environ;\n-  extern int main ();\n-  extern int __real_main ();\n-  static int been_here = 0;\n-\n-  if (__mf_opts.heur_std_data && ! been_here)\n-    {\n-      unsigned i;\n-\n-      been_here = 1;\n-      __mf_register (argv, sizeof(char *)*(argc+1), __MF_TYPE_STATIC, \"argv[]\");\n-      for (i=0; i<argc; i++)\n-        {\n-          unsigned j = strlen (argv[i]);\n-          __mf_register (argv[i], j+1, __MF_TYPE_STATIC, \"argv element\");\n-        }\n-\n-      for (i=0; ; i++)\n-        {\n-          char *e = environ[i];\n-          unsigned j;\n-          if (e == NULL) break;\n-          j = strlen (environ[i]);\n-          __mf_register (environ[i], j+1, __MF_TYPE_STATIC, \"environ element\");\n-        }\n-      __mf_register (environ, sizeof(char *)*(i+1), __MF_TYPE_STATIC, \"environ[]\");\n-\n-      __mf_register (& errno, sizeof (errno), __MF_TYPE_STATIC, \"errno area\");\n-\n-#if !(defined(__sun__) && defined(__svr4__))\n-      /* Conflicts with the automatic registration of __iob[].  */\n-      __mf_register (stdin,  sizeof (*stdin),  __MF_TYPE_STATIC, \"stdin\");\n-      __mf_register (stdout, sizeof (*stdout), __MF_TYPE_STATIC, \"stdout\");\n-      __mf_register (stderr, sizeof (*stderr), __MF_TYPE_STATIC, \"stderr\");\n-#endif\n-\n-      /* Make some effort to register ctype.h static arrays.  */\n-#if defined(__sun__) && defined(__svr4__)\n-      /* __ctype[] is declared without size, but MB_CUR_MAX is the last\n-\t member.  There seems to be no proper way to determine the size.  */\n-      __mf_register (__ctype, &MB_CUR_MAX - &__ctype[0] + 1, __MF_TYPE_STATIC, \"__ctype\");\n-      /* __ctype_mask points at _C_masks[1].  The size can only determined\n-\t using nm on libc.so.1.  */\n-      __mf_register (__ctype_mask - 1, 1028, __MF_TYPE_STATIC, \"_C_masks\");\n-#endif\n-      /* On modern Linux GLIBC, these are thread-specific and changeable, and are dealt\n-         with in mf-hooks2.c.  */\n-    }\n-\n-#ifdef PIC\n-  return main (argc, argv, environ);\n-#else\n-  return __real_main (argc, argv, environ);\n-#endif\n-}\n-\n-\n-\n-extern void __mf_fini () DTOR;\n-void __mf_fini ()\n-{\n-  TRACE (\"__mf_fini\\n\");\n-  __mfu_report ();\n-\n-#ifndef PIC\n-/* Since we didn't populate the tree for allocations in constructors\n-   before __mf_init, we cannot check destructors after __mf_fini.  */\n-  __mf_opts.mudflap_mode = mode_nop;\n-#endif\n-}\n-\n-\n-\n-/* ------------------------------------------------------------------------ */\n-/* __mf_check */\n-\n-void __mf_check (void *ptr, size_t sz, int type, const char *location)\n-{\n-  LOCKTH ();\n-  BEGIN_RECURSION_PROTECT ();\n-  __mfu_check (ptr, sz, type, location);\n-  END_RECURSION_PROTECT ();\n-  UNLOCKTH ();\n-}\n-\n-\n-void __mfu_check (void *ptr, size_t sz, int type, const char *location)\n-{\n-  unsigned entry_idx = __MF_CACHE_INDEX (ptr);\n-  struct __mf_cache *entry = & __mf_lookup_cache [entry_idx];\n-  int judgement = 0; /* 0=undecided; <0=violation; >0=okay */\n-  uintptr_t ptr_low = (uintptr_t) ptr;\n-  uintptr_t ptr_high = CLAMPSZ (ptr, sz);\n-  struct __mf_cache old_entry = *entry;\n-\n-  if (UNLIKELY (__mf_opts.sigusr1_report))\n-    __mf_sigusr1_respond ();\n-  if (UNLIKELY (__mf_opts.ignore_reads && type == 0))\n-    return;\n-\n-  TRACE (\"check ptr=%p b=%u size=%lu %s location=`%s'\\n\",\n-         ptr, entry_idx, (unsigned long)sz,\n-         (type == 0 ? \"read\" : \"write\"), location);\n-\n-  switch (__mf_opts.mudflap_mode)\n-    {\n-    case mode_nop:\n-      /* It is tempting to poison the cache here similarly to\n-         mode_populate.  However that eliminates a valuable\n-         distinction between these two modes.  mode_nop is useful to\n-         let a user count & trace every single check / registration\n-         call.  mode_populate is useful to let a program run fast\n-         while unchecked.\n-      */\n-      judgement = 1;\n-      break;\n-\n-    case mode_populate:\n-      entry->low = ptr_low;\n-      entry->high = ptr_high;\n-      judgement = 1;\n-      break;\n-\n-    case mode_check:\n-      {\n-        unsigned heuristics = 0;\n-\n-        /* Advance aging/adaptation counters.  */\n-        static unsigned adapt_count;\n-        adapt_count ++;\n-        if (UNLIKELY (__mf_opts.adapt_cache > 0 &&\n-                      adapt_count > __mf_opts.adapt_cache))\n-          {\n-            adapt_count = 0;\n-            __mf_adapt_cache ();\n-          }\n-\n-        /* Looping only occurs if heuristics were triggered.  */\n-        while (judgement == 0)\n-          {\n-            DECLARE (void, free, void *p);\n-            __mf_object_t* ovr_obj[1];\n-            unsigned obj_count;\n-            __mf_object_t** all_ovr_obj = NULL;\n-            __mf_object_t** dealloc_me = NULL;\n-            unsigned i;\n-\n-            /* Find all overlapping objects.  Be optimistic that there is just one.  */\n-            obj_count = __mf_find_objects (ptr_low, ptr_high, ovr_obj, 1);\n-            if (UNLIKELY (obj_count > 1))\n-              {\n-                /* Allocate a real buffer and do the search again.  */\n-                DECLARE (void *, malloc, size_t c);\n-                unsigned n;\n-                all_ovr_obj = CALL_REAL (malloc, (sizeof (__mf_object_t *) *\n-                                                   obj_count));\n-                if (all_ovr_obj == NULL) abort ();\n-                n = __mf_find_objects (ptr_low, ptr_high, all_ovr_obj, obj_count);\n-                assert (n == obj_count);\n-                dealloc_me = all_ovr_obj;\n-              }\n-            else\n-              {\n-                all_ovr_obj = ovr_obj;\n-                dealloc_me = NULL;\n-              }\n-\n-            /* Update object statistics.  */\n-            for (i = 0; i < obj_count; i++)\n-              {\n-                __mf_object_t *obj = all_ovr_obj[i];\n-                assert (obj != NULL);\n-                if (type == __MF_CHECK_READ)\n-                  obj->read_count ++;\n-                else\n-                  obj->write_count ++;\n-                obj->liveness ++;\n-              }\n-\n-            /* Iterate over the various objects.  There are a number of special cases.  */\n-            for (i = 0; i < obj_count; i++)\n-              {\n-                  __mf_object_t *obj = all_ovr_obj[i];\n-\n-                /* Any __MF_TYPE_NOACCESS hit is bad.  */\n-                if (UNLIKELY (obj->type == __MF_TYPE_NOACCESS))\n-                  judgement = -1;\n-\n-                /* Any object with a watch flag is bad.  */\n-                if (UNLIKELY (obj->watching_p))\n-                  judgement = -2; /* trigger VIOL_WATCH */\n-\n-                /* A read from an uninitialized object is bad. */\n-                if (UNLIKELY (__mf_opts.check_initialization\n-                              /* reading */\n-                              && type == __MF_CHECK_READ\n-                              /* not written */\n-                              && obj->write_count == 0\n-                              /* uninitialized (heap) */\n-                              && obj->type == __MF_TYPE_HEAP))\n-                  judgement = -1;\n-              }\n-\n-            /* We now know that the access spans no invalid objects.  */\n-            if (LIKELY (judgement >= 0))\n-              for (i = 0; i < obj_count; i++)\n-                {\n-                  __mf_object_t *obj = all_ovr_obj[i];\n-\n-                  /* Is this access entirely contained within this object?  */\n-                  if (LIKELY (ptr_low >= obj->low && ptr_high <= obj->high))\n-                    {\n-                      /* Valid access.  */\n-                      entry->low = obj->low;\n-                      entry->high = obj->high;\n-                      judgement = 1;\n-                    }\n-                }\n-\n-            /* This access runs off the end of one valid object.  That\n-                could be okay, if other valid objects fill in all the\n-                holes.  We allow this only for HEAP and GUESS type\n-                objects.  Accesses to STATIC and STACK variables\n-                should not be allowed to span.  */\n-            if (UNLIKELY ((judgement == 0) && (obj_count > 1)))\n-              {\n-                unsigned uncovered = 0;\n-                for (i = 0; i < obj_count; i++)\n-                  {\n-                    __mf_object_t *obj = all_ovr_obj[i];\n-                    int j, uncovered_low_p, uncovered_high_p;\n-                    uintptr_t ptr_lower, ptr_higher;\n-\n-                    uncovered_low_p = ptr_low < obj->low;\n-                    ptr_lower = CLAMPSUB (obj->low, 1);\n-                    uncovered_high_p = ptr_high > obj->high;\n-                    ptr_higher = CLAMPADD (obj->high, 1);\n-\n-                    for (j = 0; j < obj_count; j++)\n-                      {\n-                        __mf_object_t *obj2 = all_ovr_obj[j];\n-\n-                        if (i == j) continue;\n-\n-                        /* Filter out objects that cannot be spanned across.  */\n-                        if (obj2->type == __MF_TYPE_STACK\n-                            || obj2->type == __MF_TYPE_STATIC)\n-                          continue;\n-\n-                          /* Consider a side \"covered\" if obj2 includes\n-                             the next byte on that side.  */\n-                          if (uncovered_low_p\n-                              && (ptr_lower >= obj2->low && ptr_lower <= obj2->high))\n-                            uncovered_low_p = 0;\n-                          if (uncovered_high_p\n-                              && (ptr_high >= obj2->low && ptr_higher <= obj2->high))\n-                            uncovered_high_p = 0;\n-                      }\n-\n-                    if (uncovered_low_p || uncovered_high_p)\n-                      uncovered ++;\n-                  }\n-\n-                /* Success if no overlapping objects are uncovered.  */\n-                if (uncovered == 0)\n-                  judgement = 1;\n-                }\n-\n-\n-            if (dealloc_me != NULL)\n-              CALL_REAL (free, dealloc_me);\n-\n-            /* If the judgment is still unknown at this stage, loop\n-               around at most one more time.  */\n-            if (judgement == 0)\n-              {\n-                if (heuristics++ < 2) /* XXX parametrize this number? */\n-                  judgement = __mf_heuristic_check (ptr_low, ptr_high);\n-                else\n-                  judgement = -1;\n-              }\n-          }\n-\n-      }\n-      break;\n-\n-    case mode_violate:\n-      judgement = -1;\n-      break;\n-    }\n-\n-  if (__mf_opts.collect_stats)\n-    {\n-      __mf_count_check ++;\n-\n-      if (LIKELY (old_entry.low != entry->low || old_entry.high != entry->high))\n-        /* && (old_entry.low != 0) && (old_entry.high != 0)) */\n-        __mf_lookup_cache_reusecount [entry_idx] ++;\n-    }\n-\n-  if (UNLIKELY (judgement < 0))\n-    __mf_violation (ptr, sz,\n-                    (uintptr_t) __builtin_return_address (0), location,\n-                    ((judgement == -1) ?\n-                     (type == __MF_CHECK_READ ? __MF_VIOL_READ : __MF_VIOL_WRITE) :\n-                     __MF_VIOL_WATCH));\n-}\n-\n-\n-static __mf_object_t *\n-__mf_insert_new_object (uintptr_t low, uintptr_t high, int type,\n-                        const char *name, uintptr_t pc)\n-{\n-  DECLARE (void *, calloc, size_t c, size_t n);\n-\n-  __mf_object_t *new_obj;\n-  new_obj = CALL_REAL (calloc, 1, sizeof(__mf_object_t));\n-  new_obj->low = low;\n-  new_obj->high = high;\n-  new_obj->type = type;\n-  new_obj->name = name;\n-  new_obj->alloc_pc = pc;\n-#if HAVE_GETTIMEOFDAY\n-  if (__mf_opts.timestamps)\n-    gettimeofday (& new_obj->alloc_time, NULL);\n-#endif\n-#if LIBMUDFLAPTH\n-  new_obj->alloc_thread = pthread_self ();\n-#endif\n-\n-  if (__mf_opts.backtrace > 0 && (type == __MF_TYPE_HEAP || type == __MF_TYPE_HEAP_I))\n-    new_obj->alloc_backtrace_size =\n-      __mf_backtrace (& new_obj->alloc_backtrace,\n-                      (void *) pc, 2);\n-\n-  __mf_link_object (new_obj);\n-  return new_obj;\n-}\n-\n-\n-static void\n-__mf_uncache_object (__mf_object_t *old_obj)\n-{\n-  /* Remove any low/high pointers for this object from the lookup cache.  */\n-\n-  /* Can it possibly exist in the cache?  */\n-  if (LIKELY (old_obj->read_count + old_obj->write_count))\n-    {\n-      uintptr_t low = old_obj->low;\n-      uintptr_t high = old_obj->high;\n-      struct __mf_cache *entry;\n-      unsigned i;\n-      if ((high - low) >= (__mf_lc_mask << __mf_lc_shift))\n-\t{\n-\t  /* For large objects (>= cache size - 1) check the whole cache.  */\n-          entry = & __mf_lookup_cache [0];\n-          for (i = 0; i <= __mf_lc_mask; i++, entry++)\n-            {\n-              /* NB: the \"||\" in the following test permits this code to\n-                 tolerate the situation introduced by __mf_check over\n-                 contiguous objects, where a cache entry spans several\n-                 objects.  */\n-              if (entry->low == low || entry->high == high)\n-                {\n-                  entry->low = MAXPTR;\n-                  entry->high = MINPTR;\n-                }\n-            }\n-        }\n-      else\n-\t{\n-\t  /* Object is now smaller then cache size.  */\n-          unsigned entry_low_idx = __MF_CACHE_INDEX (low);\n-          unsigned entry_high_idx = __MF_CACHE_INDEX (high);\n-          if (entry_low_idx <= entry_high_idx)\n-\t    {\n-              entry = & __mf_lookup_cache [entry_low_idx];\n-              for (i = entry_low_idx; i <= entry_high_idx; i++, entry++)\n-                {\n-                  /* NB: the \"||\" in the following test permits this code to\n-                     tolerate the situation introduced by __mf_check over\n-                     contiguous objects, where a cache entry spans several\n-                     objects.  */\n-                  if (entry->low == low || entry->high == high)\n-                    {\n-                      entry->low = MAXPTR;\n-                      entry->high = MINPTR;\n-                    }\n-                }\n-            }\n-          else\n-\t    {\n-\t      /* Object wrapped around the end of the cache. First search\n-\t\t from low to end of cache and then from 0 to high.  */\n-              entry = & __mf_lookup_cache [entry_low_idx];\n-              for (i = entry_low_idx; i <= __mf_lc_mask; i++, entry++)\n-                {\n-                  /* NB: the \"||\" in the following test permits this code to\n-                     tolerate the situation introduced by __mf_check over\n-                     contiguous objects, where a cache entry spans several\n-                     objects.  */\n-                  if (entry->low == low || entry->high == high)\n-                    {\n-                      entry->low = MAXPTR;\n-                      entry->high = MINPTR;\n-                    }\n-                }\n-              entry = & __mf_lookup_cache [0];\n-              for (i = 0; i <= entry_high_idx; i++, entry++)\n-                {\n-                  /* NB: the \"||\" in the following test permits this code to\n-                     tolerate the situation introduced by __mf_check over\n-                     contiguous objects, where a cache entry spans several\n-                     objects.  */\n-                  if (entry->low == low || entry->high == high)\n-                    {\n-                      entry->low = MAXPTR;\n-                      entry->high = MINPTR;\n-                    }\n-                }\n-\t    }\n-\t}\n-    }\n-}\n-\n-\n-void\n-__mf_register (void *ptr, size_t sz, int type, const char *name)\n-{\n-  LOCKTH ();\n-  BEGIN_RECURSION_PROTECT ();\n-  __mfu_register (ptr, sz, type, name);\n-  END_RECURSION_PROTECT ();\n-  UNLOCKTH ();\n-}\n-\n-\n-void\n-__mfu_register (void *ptr, size_t sz, int type, const char *name)\n-{\n-  TRACE (\"register ptr=%p size=%lu type=%x name='%s'\\n\",\n-         ptr, (unsigned long) sz, type, name ? name : \"\");\n-\n-  if (__mf_opts.collect_stats)\n-    {\n-      __mf_count_register ++;\n-      __mf_total_register_size [(type < 0) ? 0 :\n-                                (type > __MF_TYPE_MAX) ? 0 :\n-                                type] += sz;\n-    }\n-\n-  if (UNLIKELY (__mf_opts.sigusr1_report))\n-    __mf_sigusr1_respond ();\n-\n-  switch (__mf_opts.mudflap_mode)\n-    {\n-    case mode_nop:\n-      break;\n-\n-    case mode_violate:\n-      __mf_violation (ptr, sz, (uintptr_t) __builtin_return_address (0), NULL,\n-                      __MF_VIOL_REGISTER);\n-      break;\n-\n-    case mode_populate:\n-      /* Clear the cache.  */\n-      /* XXX: why the entire cache? */\n-      /* XXX: race */\n-      memset (__mf_lookup_cache, 0, sizeof(__mf_lookup_cache));\n-      /* void slot 0 */\n-      __mf_lookup_cache[0].low = MAXPTR;\n-      break;\n-\n-    case mode_check:\n-      {\n-        __mf_object_t *ovr_objs [1];\n-        unsigned num_overlapping_objs;\n-        uintptr_t low = (uintptr_t) ptr;\n-        uintptr_t high = CLAMPSZ (ptr, sz);\n-        uintptr_t pc = (uintptr_t) __builtin_return_address (0);\n-\n-        /* Treat unknown size indication as 1.  */\n-        if (UNLIKELY (sz == 0)) sz = 1;\n-\n-        /* Look for objects only of the same type.  This will e.g. permit a registration\n-           of a STATIC overlapping with a GUESS, and a HEAP with a NOACCESS.  At\n-           __mf_check time however harmful overlaps will be detected. */\n-        num_overlapping_objs = __mf_find_objects2 (low, high, ovr_objs, 1, type);\n-\n-        /* Handle overlaps.  */\n-        if (UNLIKELY (num_overlapping_objs > 0))\n-          {\n-            __mf_object_t *ovr_obj = ovr_objs[0];\n-\n-            /* Accept certain specific duplication pairs.  */\n-            if (((type == __MF_TYPE_STATIC) || (type == __MF_TYPE_GUESS))\n-                && ovr_obj->low == low\n-                && ovr_obj->high == high\n-                && ovr_obj->type == type)\n-              {\n-                /* Duplicate registration for static objects may come\n-                   from distinct compilation units.  */\n-                VERBOSE_TRACE (\"harmless duplicate reg %p-%p `%s'\\n\",\n-                               (void *) low, (void *) high,\n-                               (ovr_obj->name ? ovr_obj->name : \"\"));\n-                break;\n-              }\n-\n-            /* Alas, a genuine violation.  */\n-            else\n-              {\n-                /* Two or more *real* mappings here. */\n-                __mf_violation ((void *) ptr, sz,\n-                                (uintptr_t) __builtin_return_address (0), NULL,\n-                                __MF_VIOL_REGISTER);\n-              }\n-          }\n-        else /* No overlapping objects: AOK.  */\n-          __mf_insert_new_object (low, high, type, name, pc);\n-\n-        /* We could conceivably call __mf_check() here to prime the cache,\n-           but then the read_count/write_count field is not reliable.  */\n-        break;\n-      }\n-    } /* end switch (__mf_opts.mudflap_mode) */\n-}\n-\n-\n-void\n-__mf_unregister (void *ptr, size_t sz, int type)\n-{\n-  LOCKTH ();\n-  BEGIN_RECURSION_PROTECT ();\n-  __mfu_unregister (ptr, sz, type);\n-  END_RECURSION_PROTECT ();\n-  UNLOCKTH ();\n-}\n-\n-\n-void\n-__mfu_unregister (void *ptr, size_t sz, int type)\n-{\n-  DECLARE (void, free, void *ptr);\n-\n-  if (UNLIKELY (__mf_opts.sigusr1_report))\n-    __mf_sigusr1_respond ();\n-\n-  TRACE (\"unregister ptr=%p size=%lu type=%x\\n\", ptr, (unsigned long) sz, type);\n-\n-  switch (__mf_opts.mudflap_mode)\n-    {\n-    case mode_nop:\n-      break;\n-\n-    case mode_violate:\n-      __mf_violation (ptr, sz,\n-                      (uintptr_t) __builtin_return_address (0), NULL,\n-                      __MF_VIOL_UNREGISTER);\n-      break;\n-\n-    case mode_populate:\n-      /* Clear the cache.  */\n-      /* XXX: race */\n-      memset (__mf_lookup_cache, 0, sizeof(__mf_lookup_cache));\n-      /* void slot 0 */\n-      __mf_lookup_cache[0].low = MAXPTR;\n-      break;\n-\n-    case mode_check:\n-      {\n-        __mf_object_t *old_obj = NULL;\n-        __mf_object_t *del_obj = NULL;  /* Object to actually delete. */\n-        __mf_object_t *objs[1] = {NULL};\n-        unsigned num_overlapping_objs;\n-\n-        num_overlapping_objs = __mf_find_objects2 ((uintptr_t) ptr,\n-                                                   CLAMPSZ (ptr, sz), objs, 1, type);\n-\n-        /* Special case for HEAP_I - see free & realloc hook.  They don't\n-           know whether the input region was HEAP or HEAP_I before\n-           unmapping it.  Here we give HEAP a try in case HEAP_I\n-           failed.  */\n-        if ((type == __MF_TYPE_HEAP_I) && (num_overlapping_objs == 0))\n-          {\n-            num_overlapping_objs = __mf_find_objects2 ((uintptr_t) ptr,\n-                                                       CLAMPSZ (ptr, sz), objs, 1, __MF_TYPE_HEAP);\n-          }\n-\n-        old_obj = objs[0];\n-        if (UNLIKELY ((num_overlapping_objs != 1) /* more than one overlap */\n-                      || ((sz == 0) ? 0 : (sz != (old_obj->high - old_obj->low + 1))) /* size mismatch */\n-                      || ((uintptr_t) ptr != old_obj->low))) /* base mismatch */\n-          {\n-            __mf_violation (ptr, sz,\n-                            (uintptr_t) __builtin_return_address (0), NULL,\n-                            __MF_VIOL_UNREGISTER);\n-            break;\n-          }\n-\n-        __mf_unlink_object (old_obj);\n-        __mf_uncache_object (old_obj);\n-\n-        /* Wipe buffer contents if desired.  */\n-        if ((__mf_opts.wipe_stack && old_obj->type == __MF_TYPE_STACK)\n-            || (__mf_opts.wipe_heap && (old_obj->type == __MF_TYPE_HEAP\n-                                        || old_obj->type == __MF_TYPE_HEAP_I)))\n-          {\n-            memset ((void *) old_obj->low,\n-                    0,\n-                    (size_t) (old_obj->high - old_obj->low + 1));\n-          }\n-\n-        /* Manage the object cemetary.  */\n-        if (__mf_opts.persistent_count > 0\n-\t    && (unsigned) old_obj->type <= __MF_TYPE_MAX_CEM)\n-          {\n-            old_obj->deallocated_p = 1;\n-            old_obj->dealloc_pc = (uintptr_t) __builtin_return_address (0);\n-#if HAVE_GETTIMEOFDAY\n-            if (__mf_opts.timestamps)\n-              gettimeofday (& old_obj->dealloc_time, NULL);\n-#endif\n-#ifdef LIBMUDFLAPTH\n-            old_obj->dealloc_thread = pthread_self ();\n-#endif\n-\n-            if (__mf_opts.backtrace > 0 && old_obj->type == __MF_TYPE_HEAP)\n-              old_obj->dealloc_backtrace_size =\n-                __mf_backtrace (& old_obj->dealloc_backtrace,\n-                                NULL, 2);\n-\n-            /* Encourage this object to be displayed again in current epoch.  */\n-            old_obj->description_epoch --;\n-\n-            /* Put this object into the cemetary.  This may require this plot to\n-               be recycled, and the previous resident to be designated del_obj.  */\n-            {\n-              unsigned row = old_obj->type;\n-              unsigned plot = __mf_object_dead_head [row];\n-\n-              del_obj = __mf_object_cemetary [row][plot];\n-              __mf_object_cemetary [row][plot] = old_obj;\n-              plot ++;\n-              if (plot == __mf_opts.persistent_count) plot = 0;\n-              __mf_object_dead_head [row] = plot;\n-            }\n-          }\n-        else\n-          del_obj = old_obj;\n-\n-        if (__mf_opts.print_leaks)\n-          {\n-            if ((old_obj->read_count + old_obj->write_count) == 0 &&\n-                (old_obj->type == __MF_TYPE_HEAP\n-                 || old_obj->type == __MF_TYPE_HEAP_I))\n-              {\n-\t\t/* The problem with a warning message here is that we may not\n-\t\t   be privy to accesses to such objects that occur within\n-\t\t   uninstrumented libraries.  */\n-#if 0\n-                fprintf (stderr,\n-                         \"*******\\n\"\n-                         \"mudflap warning: unaccessed registered object:\\n\");\n-                __mf_describe_object (old_obj);\n-#endif\n-              }\n-          }\n-\n-        if (del_obj != NULL) /* May or may not equal old_obj.  */\n-          {\n-            if (__mf_opts.backtrace > 0)\n-              {\n-                CALL_REAL(free, del_obj->alloc_backtrace);\n-                if (__mf_opts.persistent_count > 0)\n-                  {\n-                    CALL_REAL(free, del_obj->dealloc_backtrace);\n-                  }\n-              }\n-            CALL_REAL(free, del_obj);\n-          }\n-\n-        break;\n-      }\n-    } /* end switch (__mf_opts.mudflap_mode) */\n-\n-\n-  if (__mf_opts.collect_stats)\n-    {\n-      __mf_count_unregister ++;\n-      __mf_total_unregister_size += sz;\n-    }\n-}\n-\n-\n-\n-struct tree_stats\n-{\n-  unsigned obj_count;\n-  unsigned long total_size;\n-  unsigned live_obj_count;\n-  double total_weight;\n-  double weighted_size;\n-  unsigned long weighted_address_bits [sizeof (uintptr_t) * 8][2];\n-};\n-\n-\n-\n-static int\n-__mf_adapt_cache_fn (mfsplay_tree_node n, void *param)\n-{\n-  __mf_object_t *obj = (__mf_object_t *) n->value;\n-  struct tree_stats *s = (struct tree_stats *) param;\n-\n-  assert (obj != NULL && s != NULL);\n-\n-  /* Exclude never-accessed objects.  */\n-  if (obj->read_count + obj->write_count)\n-    {\n-      s->obj_count ++;\n-      s->total_size += (obj->high - obj->low + 1);\n-\n-      if (obj->liveness)\n-        {\n-          unsigned i;\n-          uintptr_t addr;\n-\n-          /* VERBOSE_TRACE (\"analyze low=%p live=%u name=`%s'\\n\",\n-             (void *) obj->low, obj->liveness, obj->name); */\n-\n-          s->live_obj_count ++;\n-          s->total_weight += (double) obj->liveness;\n-          s->weighted_size +=\n-            (double) (obj->high - obj->low + 1) *\n-            (double) obj->liveness;\n-\n-          addr = obj->low;\n-          for (i=0; i<sizeof(uintptr_t) * 8; i++)\n-            {\n-              unsigned bit = addr & 1;\n-              s->weighted_address_bits[i][bit] += obj->liveness;\n-              addr = addr >> 1;\n-            }\n-\n-          /* Age the liveness value.  */\n-          obj->liveness >>= 1;\n-        }\n-    }\n-\n-  return 0;\n-}\n-\n-\n-static void\n-__mf_adapt_cache ()\n-{\n-  struct tree_stats s;\n-  uintptr_t new_mask = 0;\n-  unsigned char new_shift;\n-  float cache_utilization;\n-  float max_value;\n-  static float smoothed_new_shift = -1.0;\n-  unsigned i;\n-\n-  memset (&s, 0, sizeof (s));\n-\n-  mfsplay_tree_foreach (__mf_object_tree (__MF_TYPE_HEAP), __mf_adapt_cache_fn, (void *) & s);\n-  mfsplay_tree_foreach (__mf_object_tree (__MF_TYPE_HEAP_I), __mf_adapt_cache_fn, (void *) & s);\n-  mfsplay_tree_foreach (__mf_object_tree (__MF_TYPE_STACK), __mf_adapt_cache_fn, (void *) & s);\n-  mfsplay_tree_foreach (__mf_object_tree (__MF_TYPE_STATIC), __mf_adapt_cache_fn, (void *) & s);\n-  mfsplay_tree_foreach (__mf_object_tree (__MF_TYPE_GUESS), __mf_adapt_cache_fn, (void *) & s);\n-\n-  /* Maybe we're dealing with funny aging/adaptation parameters, or an\n-     empty tree.  Just leave the cache alone in such cases, rather\n-     than risk dying by division-by-zero.  */\n-  if (! (s.obj_count > 0) && (s.live_obj_count > 0) && (s.total_weight > 0.0))\n-    return;\n-\n-  /* Guess a good value for the shift parameter by finding an address bit that is a\n-     good discriminant of lively objects.  */\n-  max_value = 0.0;\n-  for (i=0; i<sizeof (uintptr_t)*8; i++)\n-    {\n-      float value = (float) s.weighted_address_bits[i][0] * (float) s.weighted_address_bits[i][1];\n-      if (max_value < value) max_value = value;\n-    }\n-  for (i=0; i<sizeof (uintptr_t)*8; i++)\n-    {\n-      float shoulder_factor = 0.7;  /* Include slightly less popular bits too.  */\n-      float value = (float) s.weighted_address_bits[i][0] * (float) s.weighted_address_bits[i][1];\n-      if (value >= max_value * shoulder_factor)\n-        break;\n-    }\n-  if (smoothed_new_shift < 0) smoothed_new_shift = __mf_lc_shift;\n-  /* Converge toward this slowly to reduce flapping. */\n-  smoothed_new_shift = 0.9*smoothed_new_shift + 0.1*i;\n-  new_shift = (unsigned) (smoothed_new_shift + 0.5);\n-  assert (new_shift < sizeof (uintptr_t)*8);\n-\n-  /* Count number of used buckets.  */\n-  cache_utilization = 0.0;\n-  for (i = 0; i < (1 + __mf_lc_mask); i++)\n-    if (__mf_lookup_cache[i].low != 0 || __mf_lookup_cache[i].high != 0)\n-      cache_utilization += 1.0;\n-  cache_utilization /= (1 + __mf_lc_mask);\n-\n-  new_mask |= 0xffff; /* XXX: force a large cache.  */\n-  new_mask &= (LOOKUP_CACHE_SIZE_MAX - 1);\n-\n-  VERBOSE_TRACE (\"adapt cache obj=%u/%u sizes=%lu/%.0f/%.0f => \"\n-                 \"util=%u%% m=%p s=%u\\n\",\n-                 s.obj_count, s.live_obj_count, s.total_size, s.total_weight, s.weighted_size,\n-                 (unsigned)(cache_utilization*100.0), (void *) new_mask, new_shift);\n-\n-  /* We should reinitialize cache if its parameters have changed.  */\n-  if (new_mask != __mf_lc_mask ||\n-      new_shift != __mf_lc_shift)\n-    {\n-      __mf_lc_mask = new_mask;\n-      __mf_lc_shift = new_shift;\n-      /* XXX: race */\n-      memset (__mf_lookup_cache, 0, sizeof(__mf_lookup_cache));\n-      /* void slot 0 */\n-      __mf_lookup_cache[0].low = MAXPTR;\n-    }\n-}\n-\n-\n-\n-/* __mf_find_object[s] */\n-\n-/* Find overlapping live objecs between [low,high].  Return up to\n-   max_objs of their pointers in objs[].  Return total count of\n-   overlaps (may exceed max_objs). */\n-\n-unsigned\n-__mf_find_objects2 (uintptr_t ptr_low, uintptr_t ptr_high,\n-                    __mf_object_t **objs, unsigned max_objs, int type)\n-{\n-  unsigned count = 0;\n-  mfsplay_tree t = __mf_object_tree (type);\n-  mfsplay_tree_key k = (mfsplay_tree_key) ptr_low;\n-  int direction;\n-\n-  mfsplay_tree_node n = mfsplay_tree_lookup (t, k);\n-  /* An exact match for base address implies a hit.  */\n-  if (n != NULL)\n-    {\n-      if (count < max_objs)\n-        objs[count] = (__mf_object_t *) n->value;\n-      count ++;\n-    }\n-\n-  /* Iterate left then right near this key value to find all overlapping objects. */\n-  for (direction = 0; direction < 2; direction ++)\n-    {\n-      /* Reset search origin.  */\n-      k = (mfsplay_tree_key) ptr_low;\n-\n-      while (1)\n-        {\n-          __mf_object_t *obj;\n-\n-          n = (direction == 0 ? mfsplay_tree_successor (t, k) : mfsplay_tree_predecessor (t, k));\n-          if (n == NULL) break;\n-          obj = (__mf_object_t *) n->value;\n-\n-          if (! (obj->low <= ptr_high && obj->high >= ptr_low)) /* No overlap? */\n-            break;\n-\n-          if (count < max_objs)\n-            objs[count] = (__mf_object_t *) n->value;\n-          count ++;\n-\n-          k = (mfsplay_tree_key) obj->low;\n-        }\n-    }\n-\n-  return count;\n-}\n-\n-\n-unsigned\n-__mf_find_objects (uintptr_t ptr_low, uintptr_t ptr_high,\n-                   __mf_object_t **objs, unsigned max_objs)\n-{\n-  int type;\n-  unsigned count = 0;\n-\n-  /* Search each splay tree for overlaps.  */\n-  for (type = __MF_TYPE_NOACCESS; type <= __MF_TYPE_GUESS; type++)\n-    {\n-      unsigned c = __mf_find_objects2 (ptr_low, ptr_high, objs, max_objs, type);\n-      if (c > max_objs)\n-        {\n-          max_objs = 0;\n-          objs = NULL;\n-        }\n-      else /* NB: C may equal 0 */\n-        {\n-          max_objs -= c;\n-          objs += c;\n-        }\n-      count += c;\n-    }\n-\n-  return count;\n-}\n-\n-\n-\n-/* __mf_link_object */\n-\n-static void\n-__mf_link_object (__mf_object_t *node)\n-{\n-  mfsplay_tree t = __mf_object_tree (node->type);\n-  mfsplay_tree_insert (t, (mfsplay_tree_key) node->low, (mfsplay_tree_value) node);\n-}\n-\n-/* __mf_unlink_object */\n-\n-static void\n-__mf_unlink_object (__mf_object_t *node)\n-{\n-  mfsplay_tree t = __mf_object_tree (node->type);\n-  mfsplay_tree_remove (t, (mfsplay_tree_key) node->low);\n-}\n-\n-/* __mf_find_dead_objects */\n-\n-/* Find overlapping dead objecs between [low,high].  Return up to\n-   max_objs of their pointers in objs[].  Return total count of\n-   overlaps (may exceed max_objs).  */\n-\n-static unsigned\n-__mf_find_dead_objects (uintptr_t low, uintptr_t high,\n-                        __mf_object_t **objs, unsigned max_objs)\n-{\n-  if (__mf_opts.persistent_count > 0)\n-    {\n-      unsigned count = 0;\n-      unsigned recollection = 0;\n-      unsigned row = 0;\n-\n-      assert (low <= high);\n-      assert (max_objs == 0 || objs != NULL);\n-\n-      /* Widen the search from the most recent plots in each row, looking\n-         backward in time.  */\n-      recollection = 0;\n-      while (recollection < __mf_opts.persistent_count)\n-        {\n-          count = 0;\n-\n-          for (row = 0; row <= __MF_TYPE_MAX_CEM; row ++)\n-            {\n-              unsigned plot;\n-              unsigned i;\n-\n-              plot = __mf_object_dead_head [row];\n-              for (i = 0; i <= recollection; i ++)\n-                {\n-                  __mf_object_t *obj;\n-\n-                  /* Look backward through row: it's a circular buffer.  */\n-                  if (plot > 0) plot --;\n-                  else plot = __mf_opts.persistent_count - 1;\n-\n-                  obj = __mf_object_cemetary [row][plot];\n-                  if (obj && obj->low <= high && obj->high >= low)\n-                    {\n-                      /* Found an overlapping dead object!  */\n-                      if (count < max_objs)\n-                        objs [count] = obj;\n-                      count ++;\n-                    }\n-                }\n-            }\n-\n-          if (count)\n-            break;\n-\n-          /* Look farther back in time.  */\n-          recollection = (recollection * 2) + 1;\n-        }\n-\n-      return count;\n-    } else {\n-      return 0;\n-    }\n-}\n-\n-/* __mf_describe_object */\n-\n-static void\n-__mf_describe_object (__mf_object_t *obj)\n-{\n-  static unsigned epoch = 0;\n-  if (obj == NULL)\n-    {\n-      epoch ++;\n-      return;\n-    }\n-\n-  if (__mf_opts.abbreviate && obj->description_epoch == epoch)\n-    {\n-      fprintf (stderr,\n-               \"mudflap %sobject %p: name=`%s'\\n\",\n-               (obj->deallocated_p ? \"dead \" : \"\"),\n-               (void *) obj, (obj->name ? obj->name : \"\"));\n-      return;\n-    }\n-  else\n-    obj->description_epoch = epoch;\n-\n-  fprintf (stderr,\n-           \"mudflap %sobject %p: name=`%s'\\n\"\n-           \"bounds=[%p,%p] size=%lu area=%s check=%ur/%uw liveness=%u%s\\n\"\n-           \"alloc time=%lu.%06lu pc=%p\"\n-#ifdef LIBMUDFLAPTH\n-           \" thread=%u\"\n-#endif\n-           \"\\n\",\n-           (obj->deallocated_p ? \"dead \" : \"\"),\n-           (void *) obj, (obj->name ? obj->name : \"\"),\n-           (void *) obj->low, (void *) obj->high,\n-           (unsigned long) (obj->high - obj->low + 1),\n-           (obj->type == __MF_TYPE_NOACCESS ? \"no-access\" :\n-            obj->type == __MF_TYPE_HEAP ? \"heap\" :\n-            obj->type == __MF_TYPE_HEAP_I ? \"heap-init\" :\n-            obj->type == __MF_TYPE_STACK ? \"stack\" :\n-            obj->type == __MF_TYPE_STATIC ? \"static\" :\n-            obj->type == __MF_TYPE_GUESS ? \"guess\" :\n-            \"unknown\"),\n-           obj->read_count, obj->write_count, obj->liveness,\n-           obj->watching_p ? \" watching\" : \"\",\n-           obj->alloc_time.tv_sec, obj->alloc_time.tv_usec,\n-           (void *) obj->alloc_pc\n-#ifdef LIBMUDFLAPTH\n-           , (unsigned) obj->alloc_thread\n-#endif\n-           );\n-\n-  if (__mf_opts.backtrace > 0)\n-  {\n-    unsigned i;\n-    for (i=0; i<obj->alloc_backtrace_size; i++)\n-      fprintf (stderr, \"      %s\\n\", obj->alloc_backtrace[i]);\n-  }\n-\n-  if (__mf_opts.persistent_count > 0)\n-    {\n-      if (obj->deallocated_p)\n-        {\n-          fprintf (stderr, \"dealloc time=%lu.%06lu pc=%p\"\n-#ifdef LIBMUDFLAPTH\n-                   \" thread=%u\"\n-#endif\n-                   \"\\n\",\n-                   obj->dealloc_time.tv_sec, obj->dealloc_time.tv_usec,\n-                   (void *) obj->dealloc_pc\n-#ifdef LIBMUDFLAPTH\n-                   , (unsigned) obj->dealloc_thread\n-#endif\n-                   );\n-\n-\n-          if (__mf_opts.backtrace > 0)\n-          {\n-            unsigned i;\n-            for (i=0; i<obj->dealloc_backtrace_size; i++)\n-              fprintf (stderr, \"      %s\\n\", obj->dealloc_backtrace[i]);\n-          }\n-        }\n-    }\n-}\n-\n-\n-static int\n-__mf_report_leaks_fn (mfsplay_tree_node n, void *param)\n-{\n-  __mf_object_t *node = (__mf_object_t *) n->value;\n-  unsigned *count = (unsigned *) param;\n-\n-  if (count != NULL)\n-    (*count) ++;\n-\n-  fprintf (stderr, \"Leaked object %u:\\n\", (*count));\n-  __mf_describe_object (node);\n-\n-  return 0;\n-}\n-\n-\n-static unsigned\n-__mf_report_leaks ()\n-{\n-  unsigned count = 0;\n-\n-  (void) mfsplay_tree_foreach (__mf_object_tree (__MF_TYPE_HEAP),\n-                             __mf_report_leaks_fn, & count);\n-  (void) mfsplay_tree_foreach (__mf_object_tree (__MF_TYPE_HEAP_I),\n-                             __mf_report_leaks_fn, & count);\n-\n-  return count;\n-}\n-\n-/* ------------------------------------------------------------------------ */\n-/* __mf_report */\n-\n-void\n-__mf_report ()\n-{\n-  LOCKTH ();\n-  BEGIN_RECURSION_PROTECT ();\n-  __mfu_report ();\n-  END_RECURSION_PROTECT ();\n-  UNLOCKTH ();\n-}\n-\n-void\n-__mfu_report ()\n-{\n-  if (__mf_opts.collect_stats)\n-    {\n-      fprintf (stderr,\n-               \"*******\\n\"\n-               \"mudflap stats:\\n\"\n-               \"calls to __mf_check: %lu\\n\"\n-               \"         __mf_register: %lu [%luB, %luB, %luB, %luB, %luB]\\n\"\n-               \"         __mf_unregister: %lu [%luB]\\n\"\n-               \"         __mf_violation: [%lu, %lu, %lu, %lu, %lu]\\n\",\n-               __mf_count_check,\n-               __mf_count_register,\n-               __mf_total_register_size[0], __mf_total_register_size[1],\n-               __mf_total_register_size[2], __mf_total_register_size[3],\n-               __mf_total_register_size[4], /* XXX */\n-               __mf_count_unregister, __mf_total_unregister_size,\n-               __mf_count_violation[0], __mf_count_violation[1],\n-               __mf_count_violation[2], __mf_count_violation[3],\n-               __mf_count_violation[4]);\n-\n-      fprintf (stderr,\n-               \"calls with reentrancy: %lu\\n\", __mf_reentrancy);\n-#ifdef LIBMUDFLAPTH\n-      fprintf (stderr,\n-               \"           lock contention: %lu\\n\", __mf_lock_contention);\n-#endif\n-\n-      /* Lookup cache stats.  */\n-      {\n-        unsigned i;\n-        unsigned max_reuse = 0;\n-        unsigned num_used = 0;\n-        unsigned num_unused = 0;\n-\n-        for (i = 0; i < LOOKUP_CACHE_SIZE; i++)\n-          {\n-            if (__mf_lookup_cache_reusecount[i])\n-              num_used ++;\n-            else\n-              num_unused ++;\n-            if (max_reuse < __mf_lookup_cache_reusecount[i])\n-              max_reuse = __mf_lookup_cache_reusecount[i];\n-          }\n-        fprintf (stderr, \"lookup cache slots used: %u  unused: %u  peak-reuse: %u\\n\",\n-                 num_used, num_unused, max_reuse);\n-      }\n-\n-      {\n-        unsigned live_count;\n-        live_count = __mf_find_objects (MINPTR, MAXPTR, NULL, 0);\n-        fprintf (stderr, \"number of live objects: %u\\n\", live_count);\n-      }\n-\n-      if (__mf_opts.persistent_count > 0)\n-        {\n-          unsigned dead_count = 0;\n-          unsigned row, plot;\n-          for (row = 0; row <= __MF_TYPE_MAX_CEM; row ++)\n-            for (plot = 0 ; plot < __mf_opts.persistent_count; plot ++)\n-              if (__mf_object_cemetary [row][plot] != 0)\n-                dead_count ++;\n-          fprintf (stderr, \"          zombie objects: %u\\n\", dead_count);\n-        }\n-    }\n-  if (__mf_opts.print_leaks && (__mf_opts.mudflap_mode == mode_check))\n-    {\n-      unsigned l;\n-      extern void * __mf_wrap_alloca_indirect (size_t c);\n-\n-      /* Free up any remaining alloca()'d blocks.  */\n-      __mf_wrap_alloca_indirect (0);\n-#ifdef HAVE___LIBC_FREERES\n-      if (__mf_opts.call_libc_freeres)\n-        {\n-          extern void __libc_freeres (void);\n-          __libc_freeres ();\n-        }\n-#endif\n-\n-      __mf_describe_object (NULL); /* Reset description epoch.  */\n-      l = __mf_report_leaks ();\n-      fprintf (stderr, \"number of leaked objects: %u\\n\", l);\n-    }\n-}\n-\n-/* __mf_backtrace */\n-\n-size_t\n-__mf_backtrace (char ***symbols, void *guess_pc, unsigned guess_omit_levels)\n-{\n-  void ** pc_array;\n-  unsigned pc_array_size = __mf_opts.backtrace + guess_omit_levels;\n-  unsigned remaining_size;\n-  unsigned omitted_size = 0;\n-  unsigned i;\n-  DECLARE (void, free, void *ptr);\n-  DECLARE (void *, calloc, size_t c, size_t n);\n-  DECLARE (void *, malloc, size_t n);\n-\n-  pc_array = CALL_REAL (calloc, pc_array_size, sizeof (void *) );\n-#ifdef HAVE_BACKTRACE\n-  pc_array_size = backtrace (pc_array, pc_array_size);\n-#else\n-#define FETCH(n) do { if (pc_array_size >= n) { \\\n-                 pc_array[n] = __builtin_return_address(n); \\\n-                 if (pc_array[n] == 0) pc_array_size = n; } } while (0)\n-\n-  /* Unroll some calls __builtin_return_address because this function\n-     only takes a literal integer parameter.  */\n-  FETCH (0);\n-#if 0\n-  /* XXX: __builtin_return_address sometimes crashes (!) on >0 arguments,\n-     rather than simply returning 0.  :-(  */\n-  FETCH (1);\n-  FETCH (2);\n-  FETCH (3);\n-  FETCH (4);\n-  FETCH (5);\n-  FETCH (6);\n-  FETCH (7);\n-  FETCH (8);\n-  if (pc_array_size > 8) pc_array_size = 9;\n-#else\n-  if (pc_array_size > 0) pc_array_size = 1;\n-#endif\n-\n-#undef FETCH\n-#endif\n-\n-  /* We want to trim the first few levels of the stack traceback,\n-     since they contain libmudflap wrappers and junk.  If pc_array[]\n-     ends up containing a non-NULL guess_pc, then trim everything\n-     before that.  Otherwise, omit the first guess_omit_levels\n-     entries. */\n-\n-  if (guess_pc != NULL)\n-    for (i=0; i<pc_array_size; i++)\n-      if (pc_array [i] == guess_pc)\n-        omitted_size = i;\n-\n-  if (omitted_size == 0) /* No match? */\n-    if (pc_array_size > guess_omit_levels)\n-      omitted_size = guess_omit_levels;\n-\n-  remaining_size = pc_array_size - omitted_size;\n-\n-#ifdef HAVE_BACKTRACE_SYMBOLS\n-  *symbols = backtrace_symbols (pc_array + omitted_size, remaining_size);\n-#else\n-  {\n-    /* Let's construct a buffer by hand.  It will have <remaining_size>\n-       char*'s at the front, pointing at individual strings immediately\n-       afterwards.  */\n-    void *buffer;\n-    char *chars;\n-    char **pointers;\n-    enum { perline = 30 };\n-    buffer = CALL_REAL (malloc, remaining_size * (perline + sizeof(char *)));\n-    pointers = (char **) buffer;\n-    chars = (char *)buffer + (remaining_size * sizeof (char *));\n-    for (i = 0; i < remaining_size; i++)\n-      {\n-        pointers[i] = chars;\n-        sprintf (chars, \"[0x%p]\", pc_array [omitted_size + i]);\n-        chars = chars + perline;\n-      }\n-    *symbols = pointers;\n-  }\n-#endif\n-  CALL_REAL (free, pc_array);\n-\n-  return remaining_size;\n-}\n-\n-/* ------------------------------------------------------------------------ */\n-/* __mf_violation */\n-\n-void\n-__mf_violation (void *ptr, size_t sz, uintptr_t pc,\n-                const char *location, int type)\n-{\n-  char buf [128];\n-  static unsigned violation_number;\n-  DECLARE(void, free, void *ptr);\n-\n-  TRACE (\"violation pc=%p location=%s type=%d ptr=%p size=%lu\\n\",\n-         (void *) pc,\n-         (location != NULL ? location : \"\"), type, ptr, (unsigned long) sz);\n-\n-  if (__mf_opts.collect_stats)\n-    __mf_count_violation [(type < 0) ? 0 :\n-                          (type > __MF_VIOL_WATCH) ? 0 :\n-                          type] ++;\n-\n-  /* Print out a basic warning message.  */\n-  if (__mf_opts.verbose_violations)\n-  {\n-    unsigned dead_p;\n-    unsigned num_helpful = 0;\n-    struct timeval now = { 0, 0 };\n-#if HAVE_GETTIMEOFDAY\n-    gettimeofday (& now, NULL);\n-#endif\n-\n-    violation_number ++;\n-    fprintf (stderr,\n-             \"*******\\n\"\n-             \"mudflap violation %u (%s): time=%lu.%06lu \"\n-             \"ptr=%p size=%lu\\npc=%p%s%s%s\\n\",\n-             violation_number,\n-             ((type == __MF_VIOL_READ) ? \"check/read\" :\n-              (type == __MF_VIOL_WRITE) ? \"check/write\" :\n-              (type == __MF_VIOL_REGISTER) ? \"register\" :\n-              (type == __MF_VIOL_UNREGISTER) ? \"unregister\" :\n-              (type == __MF_VIOL_WATCH) ? \"watch\" : \"unknown\"),\n-             now.tv_sec, now.tv_usec,\n-             (void *) ptr, (unsigned long)sz, (void *) pc,\n-             (location != NULL ? \" location=`\" : \"\"),\n-             (location != NULL ? location : \"\"),\n-             (location != NULL ? \"'\" : \"\"));\n-\n-    if (__mf_opts.backtrace > 0)\n-      {\n-        char ** symbols;\n-        unsigned i, num;\n-\n-        num = __mf_backtrace (& symbols, (void *) pc, 2);\n-        /* Note: backtrace_symbols calls malloc().  But since we're in\n-           __mf_violation and presumably __mf_check, it'll detect\n-           recursion, and not put the new string into the database.  */\n-\n-        for (i=0; i<num; i++)\n-          fprintf (stderr, \"      %s\\n\", symbols[i]);\n-\n-        /* Calling free() here would trigger a violation.  */\n-        CALL_REAL(free, symbols);\n-      }\n-\n-\n-    /* Look for nearby objects.  For this, we start with s_low/s_high\n-       pointing to the given area, looking for overlapping objects.\n-       If none show up, widen the search area and keep looking. */\n-\n-    if (sz == 0) sz = 1;\n-\n-    for (dead_p = 0; dead_p <= 1; dead_p ++) /* for dead_p in 0 1 */\n-      {\n-        enum {max_objs = 3}; /* magic */\n-        __mf_object_t *objs[max_objs];\n-        unsigned num_objs = 0;\n-        uintptr_t s_low, s_high;\n-        unsigned tries = 0;\n-        unsigned i;\n-\n-        s_low = (uintptr_t) ptr;\n-        s_high = CLAMPSZ (ptr, sz);\n-\n-        while (tries < 16) /* magic */\n-          {\n-            if (dead_p)\n-              num_objs = __mf_find_dead_objects (s_low, s_high, objs, max_objs);\n-            else\n-              num_objs = __mf_find_objects (s_low, s_high, objs, max_objs);\n-\n-            if (num_objs) /* good enough */\n-              break;\n-\n-            tries ++;\n-\n-            /* XXX: tune this search strategy.  It's too dependent on\n-             sz, which can vary from 1 to very big (when array index\n-             checking) numbers. */\n-            s_low = CLAMPSUB (s_low, (sz * tries * tries));\n-            s_high = CLAMPADD (s_high, (sz * tries * tries));\n-          }\n-\n-        for (i = 0; i < min (num_objs, max_objs); i++)\n-          {\n-            __mf_object_t *obj = objs[i];\n-            uintptr_t low = (uintptr_t) ptr;\n-            uintptr_t high = CLAMPSZ (ptr, sz);\n-            unsigned before1 = (low < obj->low) ? obj->low - low : 0;\n-            unsigned after1 = (low > obj->high) ? low - obj->high : 0;\n-            unsigned into1 = (high >= obj->low && low <= obj->high) ? low - obj->low : 0;\n-            unsigned before2 = (high < obj->low) ? obj->low - high : 0;\n-            unsigned after2 = (high > obj->high) ? high - obj->high : 0;\n-            unsigned into2 = (high >= obj->low && low <= obj->high) ? high - obj->low : 0;\n-\n-            fprintf (stderr, \"Nearby object %u: checked region begins %uB %s and ends %uB %s\\n\",\n-                     num_helpful + i + 1,\n-                     (before1 ? before1 : after1 ? after1 : into1),\n-                     (before1 ? \"before\" : after1 ? \"after\" : \"into\"),\n-                     (before2 ? before2 : after2 ? after2 : into2),\n-                     (before2 ? \"before\" : after2 ? \"after\" : \"into\"));\n-            __mf_describe_object (obj);\n-          }\n-        num_helpful += num_objs;\n-      }\n-\n-    fprintf (stderr, \"number of nearby objects: %u\\n\", num_helpful);\n-  }\n-\n-  /* How to finally handle this violation?  */\n-  switch (__mf_opts.violation_mode)\n-    {\n-    case viol_nop:\n-      break;\n-    case viol_segv:\n-      kill (getpid(), SIGSEGV);\n-      break;\n-    case viol_abort:\n-      abort ();\n-      break;\n-    case viol_gdb:\n-\n-      snprintf (buf, 128, \"gdb --pid=%u\", (unsigned) getpid ());\n-      system (buf);\n-      /* XXX: should probably fork() && sleep(GDB_WAIT_PARAMETER)\n-      instead, and let the forked child execlp() gdb.  That way, this\n-      subject process can be resumed under the supervision of gdb.\n-      This can't happen now, since system() only returns when gdb\n-      dies.  In that case, we need to beware of starting a second\n-      concurrent gdb child upon the next violation.  (But if the first\n-      gdb dies, then starting a new one is appropriate.)  */\n-      break;\n-    }\n-}\n-\n-/* ------------------------------------------------------------------------ */\n-\n-\n-unsigned __mf_watch (void *ptr, size_t sz)\n-{\n-  unsigned rc;\n-  LOCKTH ();\n-  BEGIN_RECURSION_PROTECT ();\n-  rc = __mf_watch_or_not (ptr, sz, 1);\n-  END_RECURSION_PROTECT ();\n-  UNLOCKTH ();\n-  return rc;\n-}\n-\n-unsigned __mf_unwatch (void *ptr, size_t sz)\n-{\n-  unsigned rc;\n-  LOCKTH ();\n-  rc = __mf_watch_or_not (ptr, sz, 0);\n-  UNLOCKTH ();\n-  return rc;\n-}\n-\n-\n-static unsigned\n-__mf_watch_or_not (void *ptr, size_t sz, char flag)\n-{\n-  uintptr_t ptr_high = CLAMPSZ (ptr, sz);\n-  uintptr_t ptr_low = (uintptr_t) ptr;\n-  unsigned count = 0;\n-\n-  TRACE (\"%s ptr=%p size=%lu\\n\",\n-         (flag ? \"watch\" : \"unwatch\"), ptr, (unsigned long) sz);\n-\n-  switch (__mf_opts.mudflap_mode)\n-    {\n-    case mode_nop:\n-    case mode_populate:\n-    case mode_violate:\n-      count = 0;\n-      break;\n-\n-    case mode_check:\n-      {\n-        __mf_object_t **all_ovr_objs;\n-        unsigned obj_count;\n-        unsigned n;\n-        DECLARE (void *, malloc, size_t c);\n-        DECLARE (void, free, void *p);\n-\n-        obj_count = __mf_find_objects (ptr_low, ptr_high, NULL, 0);\n-        VERBOSE_TRACE (\" %u:\", obj_count);\n-\n-        all_ovr_objs = CALL_REAL (malloc, (sizeof (__mf_object_t *) * obj_count));\n-        if (all_ovr_objs == NULL) abort ();\n-        n = __mf_find_objects (ptr_low, ptr_high, all_ovr_objs, obj_count);\n-        assert (n == obj_count);\n-\n-        for (n = 0; n < obj_count; n ++)\n-          {\n-            __mf_object_t *obj = all_ovr_objs[n];\n-\n-            VERBOSE_TRACE (\" [%p]\", (void *) obj);\n-            if (obj->watching_p != flag)\n-              {\n-                obj->watching_p = flag;\n-                count ++;\n-\n-                /* Remove object from cache, to ensure next access\n-                   goes through __mf_check().  */\n-                if (flag)\n-                  __mf_uncache_object (obj);\n-              }\n-          }\n-        CALL_REAL (free, all_ovr_objs);\n-      }\n-      break;\n-    }\n-\n-  return count;\n-}\n-\n-\n-void\n-__mf_sigusr1_handler (int num)\n-{\n-  __mf_sigusr1_received ++;\n-}\n-\n-/* Install or remove SIGUSR1 handler as necessary.\n-   Also, respond to a received pending SIGUSR1.  */\n-void\n-__mf_sigusr1_respond ()\n-{\n-  static int handler_installed;\n-\n-#ifdef SIGUSR1\n-  /* Manage handler */\n-  if (__mf_opts.sigusr1_report && ! handler_installed)\n-    {\n-      signal (SIGUSR1, __mf_sigusr1_handler);\n-      handler_installed = 1;\n-    }\n-  else if(! __mf_opts.sigusr1_report && handler_installed)\n-    {\n-      signal (SIGUSR1, SIG_DFL);\n-      handler_installed = 0;\n-    }\n-#endif\n-\n-  /* Manage enqueued signals */\n-  if (__mf_sigusr1_received > __mf_sigusr1_handled)\n-    {\n-      __mf_sigusr1_handled ++;\n-      assert (__mf_get_state () == reentrant);\n-      __mfu_report ();\n-      handler_installed = 0; /* We may need to re-enable signal; this might be a SysV library. */\n-    }\n-}\n-\n-\n-/* XXX: provide an alternative __assert_fail function that cannot\n-   fail due to libmudflap infinite recursion.  */\n-#ifndef NDEBUG\n-\n-static void\n-write_itoa (int fd, unsigned n)\n-{\n-  enum x { bufsize = sizeof(n)*4 };\n-  char buf [bufsize];\n-  unsigned i;\n-\n-  for (i=0; i<bufsize-1; i++)\n-    {\n-      unsigned digit = n % 10;\n-      buf[bufsize-2-i] = digit + '0';\n-      n /= 10;\n-      if (n == 0)\n-        {\n-          char *m = & buf [bufsize-2-i];\n-          buf[bufsize-1] = '\\0';\n-          write (fd, m, strlen(m));\n-          break;\n-        }\n-    }\n-}\n-\n-\n-void\n-__assert_fail (const char *msg, const char *file, unsigned line, const char *func)\n-{\n-#define write2(string) write (2, (string), strlen ((string)));\n-  write2(\"mf\");\n-#ifdef LIBMUDFLAPTH\n-  write2(\"(\");\n-  write_itoa (2, (unsigned) pthread_self ());\n-  write2(\")\");\n-#endif\n-  write2(\": assertion failure: `\");\n-  write (2, msg, strlen (msg));\n-  write2(\"' in \");\n-  write (2, func, strlen (func));\n-  write2(\" at \");\n-  write (2, file, strlen (file));\n-  write2(\":\");\n-  write_itoa (2, line);\n-  write2(\"\\n\");\n-#undef write2\n-  abort ();\n-}\n-\n-\n-#endif\n-\n-\n-\n-/* Adapted splay tree code, originally from libiberty.  It has been\n-   specialized for libmudflap as requested by RMS.  */\n-\n-static void\n-mfsplay_tree_free (void *p)\n-{\n-  DECLARE (void, free, void *p);\n-  CALL_REAL (free, p);\n-}\n-\n-static void *\n-mfsplay_tree_xmalloc (size_t s)\n-{\n-  DECLARE (void *, malloc, size_t s);\n-  return CALL_REAL (malloc, s);\n-}\n-\n-\n-static void mfsplay_tree_splay (mfsplay_tree, mfsplay_tree_key);\n-static mfsplay_tree_node mfsplay_tree_splay_helper (mfsplay_tree,\n-                                                mfsplay_tree_key,\n-                                                mfsplay_tree_node *,\n-                                                mfsplay_tree_node *,\n-                                                mfsplay_tree_node *);\n-\n-\n-/* Help splay SP around KEY.  PARENT and GRANDPARENT are the parent\n-   and grandparent, respectively, of NODE.  */\n-\n-static mfsplay_tree_node\n-mfsplay_tree_splay_helper (mfsplay_tree sp,\n-                         mfsplay_tree_key key,\n-                         mfsplay_tree_node * node,\n-                         mfsplay_tree_node * parent,\n-                         mfsplay_tree_node * grandparent)\n-{\n-  mfsplay_tree_node *next;\n-  mfsplay_tree_node n;\n-  int comparison;\n-\n-  n = *node;\n-\n-  if (!n)\n-    return *parent;\n-\n-  comparison = ((key > n->key) ? 1 : ((key < n->key) ? -1 : 0));\n-\n-  if (comparison == 0)\n-    /* We've found the target.  */\n-    next = 0;\n-  else if (comparison < 0)\n-    /* The target is to the left.  */\n-    next = &n->left;\n-  else\n-    /* The target is to the right.  */\n-    next = &n->right;\n-\n-  if (next)\n-    {\n-      /* Check whether our recursion depth is too high.  Abort this search,\n-         and signal that a rebalance is required to continue.  */\n-      if (sp->depth > sp->max_depth)\n-        {\n-          sp->rebalance_p = 1;\n-          return n;\n-         }\n-\n-      /* Continue down the tree.  */\n-      sp->depth ++;\n-      n = mfsplay_tree_splay_helper (sp, key, next, node, parent);\n-      sp->depth --;\n-\n-      /* The recursive call will change the place to which NODE\n-         points.  */\n-      if (*node != n || sp->rebalance_p)\n-        return n;\n-    }\n-\n-  if (!parent)\n-    /* NODE is the root.  We are done.  */\n-    return n;\n-\n-  /* First, handle the case where there is no grandparent (i.e.,\n-   *PARENT is the root of the tree.)  */\n-  if (!grandparent)\n-    {\n-      if (n == (*parent)->left)\n-        {\n-          *node = n->right;\n-          n->right = *parent;\n-        }\n-      else\n-        {\n-          *node = n->left;\n-          n->left = *parent;\n-        }\n-      *parent = n;\n-      return n;\n-    }\n-\n-  /* Next handle the cases where both N and *PARENT are left children,\n-     or where both are right children.  */\n-  if (n == (*parent)->left && *parent == (*grandparent)->left)\n-    {\n-      mfsplay_tree_node p = *parent;\n-\n-      (*grandparent)->left = p->right;\n-      p->right = *grandparent;\n-      p->left = n->right;\n-      n->right = p;\n-      *grandparent = n;\n-      return n;\n-    }\n-  else if (n == (*parent)->right && *parent == (*grandparent)->right)\n-    {\n-      mfsplay_tree_node p = *parent;\n-\n-      (*grandparent)->right = p->left;\n-      p->left = *grandparent;\n-      p->right = n->left;\n-      n->left = p;\n-      *grandparent = n;\n-      return n;\n-    }\n-\n-  /* Finally, deal with the case where N is a left child, but *PARENT\n-     is a right child, or vice versa.  */\n-  if (n == (*parent)->left)\n-    {\n-      (*parent)->left = n->right;\n-      n->right = *parent;\n-      (*grandparent)->right = n->left;\n-      n->left = *grandparent;\n-      *grandparent = n;\n-      return n;\n-    }\n-  else\n-    {\n-      (*parent)->right = n->left;\n-      n->left = *parent;\n-      (*grandparent)->left = n->right;\n-      n->right = *grandparent;\n-      *grandparent = n;\n-      return n;\n-    }\n-}\n-\n-\n-\n-static int\n-mfsplay_tree_rebalance_helper1 (mfsplay_tree_node n, void *array_ptr)\n-{\n-  mfsplay_tree_node **p = array_ptr;\n-  *(*p) = n;\n-  (*p)++;\n-  return 0;\n-}\n-\n-\n-static mfsplay_tree_node\n-mfsplay_tree_rebalance_helper2 (mfsplay_tree_node * array, unsigned low,\n-                              unsigned high)\n-{\n-  unsigned middle = low + (high - low) / 2;\n-  mfsplay_tree_node n = array[middle];\n-\n-  /* Note that since we're producing a balanced binary tree, it is not a problem\n-     that this function is recursive.  */\n-  if (low + 1 <= middle)\n-    n->left = mfsplay_tree_rebalance_helper2 (array, low, middle - 1);\n-  else\n-    n->left = NULL;\n-\n-  if (middle + 1 <= high)\n-    n->right = mfsplay_tree_rebalance_helper2 (array, middle + 1, high);\n-  else\n-    n->right = NULL;\n-\n-  return n;\n-}\n-\n-\n-/* Rebalance the entire tree.  Do this by copying all the node\n-   pointers into an array, then cleverly re-linking them.  */\n-static void\n-mfsplay_tree_rebalance (mfsplay_tree sp)\n-{\n-  mfsplay_tree_node *all_nodes, *all_nodes_1;\n-\n-  if (sp->num_keys <= 2)\n-    return;\n-\n-  all_nodes = mfsplay_tree_xmalloc (sizeof (mfsplay_tree_node) * sp->num_keys);\n-\n-  /* Traverse all nodes to copy their addresses into this array.  */\n-  all_nodes_1 = all_nodes;\n-  mfsplay_tree_foreach (sp, mfsplay_tree_rebalance_helper1,\n-                      (void *) &all_nodes_1);\n-\n-  /* Relink all the nodes.  */\n-  sp->root = mfsplay_tree_rebalance_helper2 (all_nodes, 0, sp->num_keys - 1);\n-\n-  mfsplay_tree_free (all_nodes);\n-}\n-\n-\n-/* Splay SP around KEY.  */\n-static void\n-mfsplay_tree_splay (mfsplay_tree sp, mfsplay_tree_key key)\n-{\n-  if (sp->root == 0)\n-    return;\n-\n-  /* If we just splayed the tree with the same key, do nothing.  */\n-  if (sp->last_splayed_key_p &&\n-      (sp->last_splayed_key == key))\n-    return;\n-\n-  /* Compute a maximum recursion depth for a splay tree with NUM nodes.\n-     The idea is to limit excessive stack usage if we're facing\n-     degenerate access patterns.  Unfortunately such patterns can occur\n-     e.g. during static initialization, where many static objects might\n-     be registered in increasing address sequence, or during a case where\n-     large tree-like heap data structures are allocated quickly.\n-\n-     On x86, this corresponds to roughly 200K of stack usage.\n-     XXX: For libmudflapth, this could be a function of __mf_opts.thread_stack.  */\n-  sp->max_depth = 2500;\n-  sp->rebalance_p = sp->depth = 0;\n-\n-  mfsplay_tree_splay_helper (sp, key, &sp->root, NULL, NULL);\n-  if (sp->rebalance_p)\n-    {\n-      mfsplay_tree_rebalance (sp);\n-\n-      sp->rebalance_p = sp->depth = 0;\n-      mfsplay_tree_splay_helper (sp, key, &sp->root, NULL, NULL);\n-\n-      if (sp->rebalance_p)\n-        abort ();\n-    }\n-\n-\n-  /* Cache this splay key. */\n-  sp->last_splayed_key = key;\n-  sp->last_splayed_key_p = 1;\n-}\n-\n-\n-\n-/* Allocate a new splay tree.  */\n-static mfsplay_tree\n-mfsplay_tree_new ()\n-{\n-  mfsplay_tree sp = mfsplay_tree_xmalloc (sizeof (struct mfsplay_tree_s));\n-  sp->root = NULL;\n-  sp->last_splayed_key_p = 0;\n-  sp->num_keys = 0;\n-\n-  return sp;\n-}\n-\n-\n-\n-/* Insert a new node (associating KEY with DATA) into SP.  If a\n-   previous node with the indicated KEY exists, its data is replaced\n-   with the new value.  Returns the new node.  */\n-static mfsplay_tree_node\n-mfsplay_tree_insert (mfsplay_tree sp, mfsplay_tree_key key, mfsplay_tree_value value)\n-{\n-  int comparison = 0;\n-\n-  mfsplay_tree_splay (sp, key);\n-\n-  if (sp->root)\n-    comparison = ((sp->root->key > key) ? 1 :\n-                  ((sp->root->key < key) ? -1 : 0));\n-\n-  if (sp->root && comparison == 0)\n-    {\n-      /* If the root of the tree already has the indicated KEY, just\n-         replace the value with VALUE.  */\n-      sp->root->value = value;\n-    }\n-  else\n-    {\n-      /* Create a new node, and insert it at the root.  */\n-      mfsplay_tree_node node;\n-\n-      node = mfsplay_tree_xmalloc (sizeof (struct mfsplay_tree_node_s));\n-      node->key = key;\n-      node->value = value;\n-      sp->num_keys++;\n-      if (!sp->root)\n-        node->left = node->right = 0;\n-      else if (comparison < 0)\n-        {\n-          node->left = sp->root;\n-          node->right = node->left->right;\n-          node->left->right = 0;\n-        }\n-      else\n-        {\n-          node->right = sp->root;\n-          node->left = node->right->left;\n-          node->right->left = 0;\n-        }\n-\n-      sp->root = node;\n-      sp->last_splayed_key_p = 0;\n-    }\n-\n-  return sp->root;\n-}\n-\n-/* Remove KEY from SP.  It is not an error if it did not exist.  */\n-\n-static void\n-mfsplay_tree_remove (mfsplay_tree sp, mfsplay_tree_key key)\n-{\n-  mfsplay_tree_splay (sp, key);\n-  sp->last_splayed_key_p = 0;\n-  if (sp->root && (sp->root->key == key))\n-    {\n-      mfsplay_tree_node left, right;\n-      left = sp->root->left;\n-      right = sp->root->right;\n-      /* Delete the root node itself.  */\n-      mfsplay_tree_free (sp->root);\n-      sp->num_keys--;\n-      /* One of the children is now the root.  Doesn't matter much\n-         which, so long as we preserve the properties of the tree.  */\n-      if (left)\n-        {\n-          sp->root = left;\n-          /* If there was a right child as well, hang it off the\n-             right-most leaf of the left child.  */\n-          if (right)\n-            {\n-              while (left->right)\n-                left = left->right;\n-              left->right = right;\n-            }\n-        }\n-      else\n-        sp->root = right;\n-    }\n-}\n-\n-/* Lookup KEY in SP, returning VALUE if present, and NULL\n-   otherwise.  */\n-\n-static mfsplay_tree_node\n-mfsplay_tree_lookup (mfsplay_tree sp, mfsplay_tree_key key)\n-{\n-  mfsplay_tree_splay (sp, key);\n-  if (sp->root && (sp->root->key == key))\n-    return sp->root;\n-  else\n-    return 0;\n-}\n-\n-\n-/* Return the immediate predecessor KEY, or NULL if there is no\n-   predecessor.  KEY need not be present in the tree.  */\n-\n-static mfsplay_tree_node\n-mfsplay_tree_predecessor (mfsplay_tree sp, mfsplay_tree_key key)\n-{\n-  int comparison;\n-  mfsplay_tree_node node;\n-  /* If the tree is empty, there is certainly no predecessor.  */\n-  if (!sp->root)\n-    return NULL;\n-  /* Splay the tree around KEY.  That will leave either the KEY\n-     itself, its predecessor, or its successor at the root.  */\n-  mfsplay_tree_splay (sp, key);\n-  comparison = ((sp->root->key > key) ? 1 :\n-                ((sp->root->key < key) ? -1 : 0));\n-\n-  /* If the predecessor is at the root, just return it.  */\n-  if (comparison < 0)\n-    return sp->root;\n-  /* Otherwise, find the rightmost element of the left subtree.  */\n-  node = sp->root->left;\n-  if (node)\n-    while (node->right)\n-      node = node->right;\n-  return node;\n-}\n-\n-/* Return the immediate successor KEY, or NULL if there is no\n-   successor.  KEY need not be present in the tree.  */\n-\n-static mfsplay_tree_node\n-mfsplay_tree_successor (mfsplay_tree sp, mfsplay_tree_key key)\n-{\n-  int comparison;\n-  mfsplay_tree_node node;\n-  /* If the tree is empty, there is certainly no successor.  */\n-  if (!sp->root)\n-    return NULL;\n-  /* Splay the tree around KEY.  That will leave either the KEY\n-     itself, its predecessor, or its successor at the root.  */\n-  mfsplay_tree_splay (sp, key);\n-  comparison = ((sp->root->key > key) ? 1 :\n-                ((sp->root->key < key) ? -1 : 0));\n-  /* If the successor is at the root, just return it.  */\n-  if (comparison > 0)\n-    return sp->root;\n-  /* Otherwise, find the leftmost element of the right subtree.  */\n-  node = sp->root->right;\n-  if (node)\n-    while (node->left)\n-      node = node->left;\n-  return node;\n-}\n-\n-/* Call FN, passing it the DATA, for every node in SP, following an\n-   in-order traversal.  If FN every returns a non-zero value, the\n-   iteration ceases immediately, and the value is returned.\n-   Otherwise, this function returns 0.\n-\n-   This function simulates recursion using dynamically allocated\n-   arrays, since it may be called from mfsplay_tree_rebalance(), which\n-   in turn means that the tree is already uncomfortably deep for stack\n-   space limits.  */\n-static int\n-mfsplay_tree_foreach (mfsplay_tree st, mfsplay_tree_foreach_fn fn, void *data)\n-{\n-  mfsplay_tree_node *stack1;\n-  char *stack2;\n-  unsigned sp;\n-  int val = 0;\n-  enum s { s_left, s_here, s_right, s_up };\n-\n-  if (st->root == NULL) /* => num_keys == 0 */\n-    return 0;\n-\n-  stack1 = mfsplay_tree_xmalloc (sizeof (mfsplay_tree_node) * st->num_keys);\n-  stack2 = mfsplay_tree_xmalloc (sizeof (char) * st->num_keys);\n-\n-  sp = 0;\n-  stack1 [sp] = st->root;\n-  stack2 [sp] = s_left;\n-\n-  while (1)\n-    {\n-      mfsplay_tree_node n;\n-      enum s s;\n-\n-      n = stack1 [sp];\n-      s = stack2 [sp];\n-\n-      /* Handle each of the four possible states separately.  */\n-\n-      /* 1: We're here to traverse the left subtree (if any).  */\n-      if (s == s_left)\n-        {\n-          stack2 [sp] = s_here;\n-          if (n->left != NULL)\n-            {\n-              sp ++;\n-              stack1 [sp] = n->left;\n-              stack2 [sp] = s_left;\n-            }\n-        }\n-\n-      /* 2: We're here to traverse this node.  */\n-      else if (s == s_here)\n-        {\n-          stack2 [sp] = s_right;\n-          val = (*fn) (n, data);\n-          if (val) break;\n-        }\n-\n-      /* 3: We're here to traverse the right subtree (if any).  */\n-      else if (s == s_right)\n-        {\n-          stack2 [sp] = s_up;\n-          if (n->right != NULL)\n-            {\n-              sp ++;\n-              stack1 [sp] = n->right;\n-              stack2 [sp] = s_left;\n-            }\n-        }\n-\n-      /* 4: We're here after both subtrees (if any) have been traversed.  */\n-      else if (s == s_up)\n-        {\n-          /* Pop the stack.  */\n-          if (sp == 0) break; /* Popping off the root note: we're finished!  */\n-          sp --;\n-        }\n-\n-      else\n-        abort ();\n-    }\n-\n-  mfsplay_tree_free (stack1);\n-  mfsplay_tree_free (stack2);\n-  return val;\n-}"}, {"sha": "cea01df098b051424de9dc728905819caacc93bb", "filename": "libmudflap/mf-runtime.h", "status": "removed", "additions": 0, "deletions": 244, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Fmf-runtime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Fmf-runtime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-runtime.h?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,244 +0,0 @@\n-/* Implementation header for mudflap runtime library.\n-   Mudflap: narrow-pointer bounds-checking by tree rewriting.\n-   Copyright (C) 2002-2013 Free Software Foundation, Inc.\n-   Contributed by Frank Ch. Eigler <fche@redhat.com>\n-   and Graydon Hoare <graydon@redhat.com>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* Public libmudflap declarations -*- C -*- */\n-\n-#ifndef MF_RUNTIME_H\n-#define MF_RUNTIME_H\n-\n-typedef void *__mf_ptr_t;\n-typedef unsigned int __mf_uintptr_t __attribute__ ((__mode__ (__pointer__)));\n-typedef __SIZE_TYPE__ __mf_size_t;\n-\n-/* Global declarations used by instrumentation.  When _MUDFLAP is\n-   defined, these have been auto-declared by the compiler and we\n-   should not declare them again (ideally we *would* declare them\n-   again, to verify that the compiler's declarations match the\n-   library's, but the C++ front end has no mechanism for allowing\n-   the re-definition of a structure type).  */\n-#ifndef _MUDFLAP\n-struct __mf_cache { __mf_uintptr_t low; __mf_uintptr_t high; };\n-extern struct __mf_cache __mf_lookup_cache [];\n-extern __mf_uintptr_t __mf_lc_mask;\n-extern unsigned char __mf_lc_shift;\n-#endif\n-\n-/* Multithreading support.  */\n-#ifdef _MUDFLAPTH\n-/* extern pthread_mutex_t __mf_biglock; */\n-#ifndef _REENTRANT\n-#define _REENTRANT\n-#endif\n-#ifndef _THREAD_SAFE\n-#define _THREAD_SAFE\n-#endif\n-#endif\n-\n-/* Codes to describe the type of access to check: __mf_check arg 3 */\n-\n-#define __MF_CHECK_READ 0\n-#define __MF_CHECK_WRITE 1\n-\n-\n-/* Codes to describe a region of memory being registered: __mf_*register arg 3 */\n-\n-#define __MF_TYPE_NOACCESS 0\n-#define __MF_TYPE_HEAP 1\n-#define __MF_TYPE_HEAP_I 2\n-#define __MF_TYPE_STACK 3\n-#define __MF_TYPE_STATIC 4\n-#define __MF_TYPE_GUESS 5\n-\n-\n-/* The public mudflap API */\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-extern void __mf_check (void *ptr, __mf_size_t sz, int type, const char *location)\n-       __attribute((nothrow));\n-extern void __mf_register (void *ptr, __mf_size_t sz, int type, const char *name)\n-       __attribute((nothrow));\n-extern void __mf_unregister (void *ptr, __mf_size_t sz, int type)\n-       __attribute((nothrow));\n-extern unsigned __mf_watch (void *ptr, __mf_size_t sz);\n-extern unsigned __mf_unwatch (void *ptr, __mf_size_t sz);\n-extern void __mf_report ();\n-extern int __mf_set_options (const char *opts);\n-\n-\n-/* Redirect some standard library functions to libmudflap.  These are\n-   done by simple #define rather than linker wrapping, since only\n-   instrumented modules are meant to be affected.  */\n-\n-#ifdef _MUDFLAP\n-#pragma redefine_extname memcpy __mfwrap_memcpy\n-#pragma redefine_extname memmove __mfwrap_memmove\n-#pragma redefine_extname memset __mfwrap_memset\n-#pragma redefine_extname memcmp __mfwrap_memcmp\n-#pragma redefine_extname memchr __mfwrap_memchr\n-#pragma redefine_extname memrchr __mfwrap_memrchr\n-#pragma redefine_extname strcpy __mfwrap_strcpy\n-#pragma redefine_extname strncpy __mfwrap_strncpy\n-#pragma redefine_extname strcat __mfwrap_strcat\n-#pragma redefine_extname strncat __mfwrap_strncat\n-#pragma redefine_extname strcmp __mfwrap_strcmp\n-#pragma redefine_extname strcasecmp __mfwrap_strcasecmp\n-#pragma redefine_extname strncmp __mfwrap_strncmp\n-#pragma redefine_extname strncasecmp __mfwrap_strncasecmp\n-#pragma redefine_extname strdup __mfwrap_strdup\n-#pragma redefine_extname strndup __mfwrap_strndup\n-#pragma redefine_extname strchr __mfwrap_strchr\n-#pragma redefine_extname strrchr __mfwrap_strrchr\n-#pragma redefine_extname strstr __mfwrap_strstr\n-#pragma redefine_extname memmem __mfwrap_memmem\n-#pragma redefine_extname strlen __mfwrap_strlen\n-#pragma redefine_extname strnlen __mfwrap_strnlen\n-#pragma redefine_extname bzero __mfwrap_bzero\n-#pragma redefine_extname bcopy __mfwrap_bcopy\n-#pragma redefine_extname bcmp __mfwrap_bcmp\n-#pragma redefine_extname index __mfwrap_index\n-#pragma redefine_extname rindex __mfwrap_rindex\n-#pragma redefine_extname asctime __mfwrap_asctime\n-#pragma redefine_extname ctime __mfwrap_ctime\n-#pragma redefine_extname gmtime __mfwrap_gmtime\n-#pragma redefine_extname localtime __mfwrap_localtime\n-#pragma redefine_extname time __mfwrap_time\n-#pragma redefine_extname strerror __mfwrap_strerror\n-#pragma redefine_extname fopen __mfwrap_fopen\n-#pragma redefine_extname fdopen __mfwrap_fdopen\n-#pragma redefine_extname freopen __mfwrap_freopen\n-#pragma redefine_extname fclose __mfwrap_fclose\n-#pragma redefine_extname fread __mfwrap_fread\n-#pragma redefine_extname fwrite __mfwrap_fwrite\n-#pragma redefine_extname fgetc __mfwrap_fgetc\n-#pragma redefine_extname fgets __mfwrap_fgets\n-#pragma redefine_extname getc __mfwrap_getc\n-#pragma redefine_extname gets __mfwrap_gets\n-#pragma redefine_extname ungetc __mfwrap_ungetc\n-#pragma redefine_extname fputc __mfwrap_fputc\n-#pragma redefine_extname fputs __mfwrap_fputs\n-#pragma redefine_extname putc __mfwrap_putc\n-#pragma redefine_extname puts __mfwrap_puts\n-#pragma redefine_extname clearerr __mfwrap_clearerr\n-#pragma redefine_extname feof __mfwrap_feof\n-#pragma redefine_extname ferror __mfwrap_ferror\n-#pragma redefine_extname fileno __mfwrap_fileno\n-#pragma redefine_extname printf __mfwrap_printf\n-#pragma redefine_extname fprintf __mfwrap_fprintf\n-#pragma redefine_extname sprintf __mfwrap_sprintf\n-#pragma redefine_extname snprintf __mfwrap_snprintf\n-#pragma redefine_extname vprintf __mfwrap_vprintf\n-#pragma redefine_extname vfprintf __mfwrap_vfprintf\n-#pragma redefine_extname vsprintf __mfwrap_vsprintf\n-#pragma redefine_extname vsnprintf __mfwrap_vsnprintf\n-#pragma redefine_extname access __mfwrap_access\n-#pragma redefine_extname remove __mfwrap_remove\n-#pragma redefine_extname fflush __mfwrap_fflush\n-#pragma redefine_extname fseek __mfwrap_fseek\n-#pragma redefine_extname ftell __mfwrap_ftell\n-#pragma redefine_extname rewind __mfwrap_rewind\n-#pragma redefine_extname fgetpos __mfwrap_fgetpos\n-#pragma redefine_extname fsetpos __mfwrap_fsetpos\n-#pragma redefine_extname stat __mfwrap_stat\n-#pragma redefine_extname fstat __mfwrap_fstat\n-#pragma redefine_extname lstat __mfwrap_lstat\n-#pragma redefine_extname mkfifo __mfwrap_mkfifo\n-#pragma redefine_extname setvbuf __mfwrap_setvbuf\n-#pragma redefine_extname setbuf __mfwrap_setbuf\n-#pragma redefine_extname setbuffer __mfwrap_setbuffer\n-#pragma redefine_extname setlinebuf __mfwrap_setlinebuf\n-#pragma redefine_extname opendir __mfwrap_opendir\n-#pragma redefine_extname closedir __mfwrap_closedir\n-#pragma redefine_extname readdir __mfwrap_readdir\n-#pragma redefine_extname recv __mfwrap_recv\n-#pragma redefine_extname recvfrom __mfwrap_recvfrom\n-#pragma redefine_extname recvmsg __mfwrap_recvmsg\n-#pragma redefine_extname send __mfwrap_send\n-#pragma redefine_extname sendto __mfwrap_sendto\n-#pragma redefine_extname sendmsg __mfwrap_sendmsg\n-#pragma redefine_extname setsockopt __mfwrap_setsockopt\n-#pragma redefine_extname getsockopt __mfwrap_getsockopt\n-#pragma redefine_extname accept __mfwrap_accept\n-#pragma redefine_extname bind __mfwrap_bind\n-#pragma redefine_extname connect __mfwrap_connect\n-#pragma redefine_extname gethostname __mfwrap_gethostname\n-#pragma redefine_extname sethostname __mfwrap_sethostname\n-#pragma redefine_extname gethostbyname __mfwrap_gethostbyname\n-#pragma redefine_extname wait __mfwrap_wait\n-#pragma redefine_extname waitpid __mfwrap_waitpid\n-#pragma redefine_extname popen __mfwrap_popen\n-#pragma redefine_extname pclose __mfwrap_pclose\n-#pragma redefine_extname execve __mfwrap_execve\n-#pragma redefine_extname execv __mfwrap_execv\n-#pragma redefine_extname execvp __mfwrap_execvp\n-#pragma redefine_extname system __mfwrap_system\n-#pragma redefine_extname dlopen __mfwrap_dlopen\n-#pragma redefine_extname dlerror __mfwrap_dlerror\n-#pragma redefine_extname dlsym __mfwrap_dlsym\n-#pragma redefine_extname dlclose __mfwrap_dlclose\n-#pragma redefine_extname fopen64 __mfwrap_fopen64\n-#pragma redefine_extname freopen64 __mfwrap_freopen64\n-#pragma redefine_extname stat64 __mfwrap_stat64\n-#pragma redefine_extname fseeko64 __mfwrap_fseeko64\n-#pragma redefine_extname ftello64 __mfwrap_ftello64\n-#pragma redefine_extname semop __mfwrap_semop\n-#pragma redefine_extname semctl __mfwrap_semctl\n-#pragma redefine_extname shmctl __mfwrap_shmctl\n-#pragma redefine_extname shmat __mfwrap_shmat\n-#pragma redefine_extname shmdt __mfwrap_shmdt\n-#pragma redefine_extname __ctype_b_loc __mfwrap___ctype_b_loc\n-#pragma redefine_extname __ctype_toupper_loc __mfwrap___ctype_toupper_loc\n-#pragma redefine_extname __ctype_tolower_loc __mfwrap___ctype_tolower_loc\n-#pragma redefine_extname getlogin __mfwrap_getlogin\n-#pragma redefine_extname cuserid __mfwrap_cuserid\n-#pragma redefine_extname getpwnam __mfwrap_getpwnam\n-#pragma redefine_extname getpwuid __mfwrap_getpwuid\n-#pragma redefine_extname getgrnam __mfwrap_getgrnam\n-#pragma redefine_extname getgrgid __mfwrap_getgrgid\n-#pragma redefine_extname getservent __mfwrap_getservent\n-#pragma redefine_extname getservbyname __mfwrap_getservbyname\n-#pragma redefine_extname getservbyport __mfwrap_getservbyport\n-#pragma redefine_extname gai_strerror __mfwrap_gai_strerror\n-#pragma redefine_extname getmntent __mfwrap_getmntent\n-#pragma redefine_extname inet_ntoa __mfwrap_inet_ntoa\n-#pragma redefine_extname getprotoent __mfwrap_getprotoent\n-#pragma redefine_extname getprotobyname __mfwrap_getprotobyname\n-#pragma redefine_extname getprotobynumber __mfwrap_getprotobynumber\n-\n-/* Disable glibc macros.  */\n-#define __NO_STRING_INLINES\n-\n-#endif /* _MUDFLAP */\n-\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-#endif /* MF_RUNTIME_H */"}, {"sha": "a2c1e9f4ea311e7ad5489a26137a95be8c5ba771", "filename": "libmudflap/testsuite/Makefile.am", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2FMakefile.am?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,11 +0,0 @@\n-## Process this with automake to create Makefile.in\n-\n-AUTOMAKE_OPTIONS = foreign dejagnu\n-\n-EXPECT = `if [ -f ../../expect/expect ] ; then \\\n-\t  echo ../../expect/expect ; \\\n-\t  else echo expect ; fi`\n-\n-RUNTEST = `if [ -f ${srcdir}/../../dejagnu/runtest ] ; then \\\n-\t   echo ${srcdir}/../../dejagnu/runtest ; \\\n-\t   else echo runtest ;  fi`"}, {"sha": "73411bdd10807c08e40a090d047c8c786a81664c", "filename": "libmudflap/testsuite/Makefile.in", "status": "removed", "additions": 0, "deletions": 392, "changes": 392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2FMakefile.in?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,392 +0,0 @@\n-# Makefile.in generated by automake 1.11.1 from Makefile.am.\n-# @configure_input@\n-\n-# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n-# Inc.\n-# This Makefile.in is free software; the Free Software Foundation\n-# gives unlimited permission to copy and/or distribute it,\n-# with or without modifications, as long as this notice is preserved.\n-\n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n-# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n-# PARTICULAR PURPOSE.\n-\n-@SET_MAKE@\n-VPATH = @srcdir@\n-pkgdatadir = $(datadir)/@PACKAGE@\n-pkgincludedir = $(includedir)/@PACKAGE@\n-pkglibdir = $(libdir)/@PACKAGE@\n-pkglibexecdir = $(libexecdir)/@PACKAGE@\n-am__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\n-install_sh_DATA = $(install_sh) -c -m 644\n-install_sh_PROGRAM = $(install_sh) -c\n-install_sh_SCRIPT = $(install_sh) -c\n-INSTALL_HEADER = $(INSTALL_DATA)\n-transform = $(program_transform_name)\n-NORMAL_INSTALL = :\n-PRE_INSTALL = :\n-POST_INSTALL = :\n-NORMAL_UNINSTALL = :\n-PRE_UNINSTALL = :\n-POST_UNINSTALL = :\n-build_triplet = @build@\n-host_triplet = @host@\n-target_triplet = @target@\n-subdir = testsuite\n-DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \\\n-\t$(srcdir)/mfconfig.exp.in\n-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n-am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \\\n-\t$(top_srcdir)/../config/depstand.m4 \\\n-\t$(top_srcdir)/../config/enable.m4 \\\n-\t$(top_srcdir)/../config/lead-dot.m4 \\\n-\t$(top_srcdir)/../config/multi.m4 \\\n-\t$(top_srcdir)/../config/override.m4 \\\n-\t$(top_srcdir)/../config/tls.m4 $(top_srcdir)/../ltoptions.m4 \\\n-\t$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \\\n-\t$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/acinclude.m4 \\\n-\t$(top_srcdir)/../libtool.m4 $(top_srcdir)/configure.ac\n-am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n-\t$(ACLOCAL_M4)\n-mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n-CONFIG_HEADER = $(top_builddir)/config.h\n-CONFIG_CLEAN_FILES = mfconfig.exp\n-CONFIG_CLEAN_VPATH_FILES =\n-SOURCES =\n-DEJATOOL = $(PACKAGE)\n-RUNTESTDEFAULTFLAGS = --tool $$tool --srcdir $$srcdir\n-ACLOCAL = @ACLOCAL@\n-AMTAR = @AMTAR@\n-AR = @AR@\n-AUTOCONF = @AUTOCONF@\n-AUTOHEADER = @AUTOHEADER@\n-AUTOMAKE = @AUTOMAKE@\n-AWK = @AWK@\n-CC = @CC@\n-CCDEPMODE = @CCDEPMODE@\n-CFLAGS = @CFLAGS@\n-CPP = @CPP@\n-CPPFLAGS = @CPPFLAGS@\n-CYGPATH_W = @CYGPATH_W@\n-DEFS = @DEFS@\n-DEPDIR = @DEPDIR@\n-DSYMUTIL = @DSYMUTIL@\n-DUMPBIN = @DUMPBIN@\n-ECHO_C = @ECHO_C@\n-ECHO_N = @ECHO_N@\n-ECHO_T = @ECHO_T@\n-EGREP = @EGREP@\n-EXEEXT = @EXEEXT@\n-FGREP = @FGREP@\n-GREP = @GREP@\n-INSTALL = @INSTALL@\n-INSTALL_DATA = @INSTALL_DATA@\n-INSTALL_PROGRAM = @INSTALL_PROGRAM@\n-INSTALL_SCRIPT = @INSTALL_SCRIPT@\n-INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\n-LD = @LD@\n-LDFLAGS = @LDFLAGS@\n-LIBOBJS = @LIBOBJS@\n-LIBS = @LIBS@\n-LIBTOOL = @LIBTOOL@\n-LIPO = @LIPO@\n-LN_S = @LN_S@\n-LTLIBOBJS = @LTLIBOBJS@\n-MAINT = @MAINT@\n-MAKEINFO = @MAKEINFO@\n-MF_HAVE_STDINT_H = @MF_HAVE_STDINT_H@\n-MF_HAVE_UINTPTR_T = @MF_HAVE_UINTPTR_T@\n-MKDIR_P = @MKDIR_P@\n-NM = @NM@\n-NMEDIT = @NMEDIT@\n-OBJDUMP = @OBJDUMP@\n-OBJEXT = @OBJEXT@\n-OTOOL = @OTOOL@\n-OTOOL64 = @OTOOL64@\n-PACKAGE = @PACKAGE@\n-PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\n-PACKAGE_NAME = @PACKAGE_NAME@\n-PACKAGE_STRING = @PACKAGE_STRING@\n-PACKAGE_TARNAME = @PACKAGE_TARNAME@\n-PACKAGE_URL = @PACKAGE_URL@\n-PACKAGE_VERSION = @PACKAGE_VERSION@\n-PATH_SEPARATOR = @PATH_SEPARATOR@\n-RANLIB = @RANLIB@\n-SECTION_FLAGS = @SECTION_FLAGS@\n-SED = @SED@\n-SET_MAKE = @SET_MAKE@\n-SHELL = @SHELL@\n-STRIP = @STRIP@\n-VERSION = @VERSION@\n-abs_builddir = @abs_builddir@\n-abs_srcdir = @abs_srcdir@\n-abs_top_builddir = @abs_top_builddir@\n-abs_top_srcdir = @abs_top_srcdir@\n-ac_ct_CC = @ac_ct_CC@\n-ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n-am__include = @am__include@\n-am__leading_dot = @am__leading_dot@\n-am__quote = @am__quote@\n-am__tar = @am__tar@\n-am__untar = @am__untar@\n-bindir = @bindir@\n-build = @build@\n-build_alias = @build_alias@\n-build_cpu = @build_cpu@\n-build_libmudflapth = @build_libmudflapth@\n-build_os = @build_os@\n-build_vendor = @build_vendor@\n-builddir = @builddir@\n-datadir = @datadir@\n-datarootdir = @datarootdir@\n-docdir = @docdir@\n-dvidir = @dvidir@\n-enable_shared = @enable_shared@\n-enable_static = @enable_static@\n-exec_prefix = @exec_prefix@\n-host = @host@\n-host_alias = @host_alias@\n-host_cpu = @host_cpu@\n-host_os = @host_os@\n-host_vendor = @host_vendor@\n-htmldir = @htmldir@\n-includedir = @includedir@\n-infodir = @infodir@\n-install_sh = @install_sh@\n-libdir = @libdir@\n-libexecdir = @libexecdir@\n-localedir = @localedir@\n-localstatedir = @localstatedir@\n-mandir = @mandir@\n-mkdir_p = @mkdir_p@\n-multi_basedir = @multi_basedir@\n-oldincludedir = @oldincludedir@\n-pdfdir = @pdfdir@\n-prefix = @prefix@\n-program_transform_name = @program_transform_name@\n-psdir = @psdir@\n-sbindir = @sbindir@\n-sharedstatedir = @sharedstatedir@\n-srcdir = @srcdir@\n-sysconfdir = @sysconfdir@\n-target = @target@\n-target_alias = @target_alias@\n-target_cpu = @target_cpu@\n-target_noncanonical = @target_noncanonical@\n-target_os = @target_os@\n-target_vendor = @target_vendor@\n-toolexecdir = @toolexecdir@\n-toolexeclibdir = @toolexeclibdir@\n-top_build_prefix = @top_build_prefix@\n-top_builddir = @top_builddir@\n-top_srcdir = @top_srcdir@\n-AUTOMAKE_OPTIONS = foreign dejagnu\n-EXPECT = `if [ -f ../../expect/expect ] ; then \\\n-\t  echo ../../expect/expect ; \\\n-\t  else echo expect ; fi`\n-\n-RUNTEST = `if [ -f ${srcdir}/../../dejagnu/runtest ] ; then \\\n-\t   echo ${srcdir}/../../dejagnu/runtest ; \\\n-\t   else echo runtest ;  fi`\n-\n-all: all-am\n-\n-.SUFFIXES:\n-$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n-\t@for dep in $?; do \\\n-\t  case '$(am__configure_deps)' in \\\n-\t    *$$dep*) \\\n-\t      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \\\n-\t        && { if test -f $@; then exit 0; else break; fi; }; \\\n-\t      exit 1;; \\\n-\t  esac; \\\n-\tdone; \\\n-\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign testsuite/Makefile'; \\\n-\t$(am__cd) $(top_srcdir) && \\\n-\t  $(AUTOMAKE) --foreign testsuite/Makefile\n-.PRECIOUS: Makefile\n-Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n-\t@case '$?' in \\\n-\t  *config.status*) \\\n-\t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n-\t  *) \\\n-\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n-\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n-\tesac;\n-\n-$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n-\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n-\n-$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n-\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n-$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n-\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n-$(am__aclocal_m4_deps):\n-mfconfig.exp: $(top_builddir)/config.status $(srcdir)/mfconfig.exp.in\n-\tcd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@\n-\n-mostlyclean-libtool:\n-\t-rm -f *.lo\n-\n-clean-libtool:\n-\t-rm -rf .libs _libs\n-tags: TAGS\n-TAGS:\n-\n-ctags: CTAGS\n-CTAGS:\n-\n-\n-check-DEJAGNU: site.exp\n-\tsrcdir=`$(am__cd) $(srcdir) && pwd`; export srcdir; \\\n-\tEXPECT=$(EXPECT); export EXPECT; \\\n-\truntest=$(RUNTEST); \\\n-\tif $(SHELL) -c \"$$runtest --version\" > /dev/null 2>&1; then \\\n-\t  exit_status=0; l='$(DEJATOOL)'; for tool in $$l; do \\\n-\t    if $$runtest $(AM_RUNTESTFLAGS) $(RUNTESTDEFAULTFLAGS) $(RUNTESTFLAGS); \\\n-\t    then :; else exit_status=1; fi; \\\n-\t  done; \\\n-\telse echo \"WARNING: could not find \\`runtest'\" 1>&2; :;\\\n-\tfi; \\\n-\texit $$exit_status\n-site.exp: Makefile\n-\t@echo 'Making a new site.exp file...'\n-\t@echo '## these variables are automatically generated by make ##' >site.tmp\n-\t@echo '# Do not edit here.  If you wish to override these values' >>site.tmp\n-\t@echo '# edit the last section' >>site.tmp\n-\t@echo 'set srcdir $(srcdir)' >>site.tmp\n-\t@echo \"set objdir `pwd`\" >>site.tmp\n-\t@echo 'set build_alias \"$(build_alias)\"' >>site.tmp\n-\t@echo 'set build_triplet $(build_triplet)' >>site.tmp\n-\t@echo 'set host_alias \"$(host_alias)\"' >>site.tmp\n-\t@echo 'set host_triplet $(host_triplet)' >>site.tmp\n-\t@echo 'set target_alias \"$(target_alias)\"' >>site.tmp\n-\t@echo 'set target_triplet $(target_triplet)' >>site.tmp\n-\t@echo '## All variables above are generated by configure. Do Not Edit ##' >>site.tmp\n-\t@test ! -f site.exp || \\\n-\t  sed '1,/^## All variables above are.*##/ d' site.exp >> site.tmp\n-\t@-rm -f site.bak\n-\t@test ! -f site.exp || mv site.exp site.bak\n-\t@mv site.tmp site.exp\n-\n-distclean-DEJAGNU:\n-\t-rm -f site.exp site.bak\n-\t-l='$(DEJATOOL)'; for tool in $$l; do \\\n-\t  rm -f $$tool.sum $$tool.log; \\\n-\tdone\n-check-am: all-am\n-\t$(MAKE) $(AM_MAKEFLAGS) check-DEJAGNU\n-check: check-am\n-all-am: Makefile\n-installdirs:\n-install: install-am\n-install-exec: install-exec-am\n-install-data: install-data-am\n-uninstall: uninstall-am\n-\n-install-am: all-am\n-\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n-\n-installcheck: installcheck-am\n-install-strip:\n-\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t  `test -z '$(STRIP)' || \\\n-\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n-mostlyclean-generic:\n-\n-clean-generic:\n-\n-distclean-generic:\n-\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n-\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n-\n-maintainer-clean-generic:\n-\t@echo \"This command is intended for maintainers to use\"\n-\t@echo \"it deletes files that may require special tools to rebuild.\"\n-clean: clean-am\n-\n-clean-am: clean-generic clean-libtool mostlyclean-am\n-\n-distclean: distclean-am\n-\t-rm -f Makefile\n-distclean-am: clean-am distclean-DEJAGNU distclean-generic\n-\n-dvi: dvi-am\n-\n-dvi-am:\n-\n-html: html-am\n-\n-html-am:\n-\n-info: info-am\n-\n-info-am:\n-\n-install-data-am:\n-\n-install-dvi: install-dvi-am\n-\n-install-dvi-am:\n-\n-install-exec-am:\n-\n-install-html: install-html-am\n-\n-install-html-am:\n-\n-install-info: install-info-am\n-\n-install-info-am:\n-\n-install-man:\n-\n-install-pdf: install-pdf-am\n-\n-install-pdf-am:\n-\n-install-ps: install-ps-am\n-\n-install-ps-am:\n-\n-installcheck-am:\n-\n-maintainer-clean: maintainer-clean-am\n-\t-rm -f Makefile\n-maintainer-clean-am: distclean-am maintainer-clean-generic\n-\n-mostlyclean: mostlyclean-am\n-\n-mostlyclean-am: mostlyclean-generic mostlyclean-libtool\n-\n-pdf: pdf-am\n-\n-pdf-am:\n-\n-ps: ps-am\n-\n-ps-am:\n-\n-uninstall-am:\n-\n-.MAKE: check-am install-am install-strip\n-\n-.PHONY: all all-am check check-DEJAGNU check-am clean clean-generic \\\n-\tclean-libtool distclean distclean-DEJAGNU distclean-generic \\\n-\tdistclean-libtool dvi dvi-am html html-am info info-am install \\\n-\tinstall-am install-data install-data-am install-dvi \\\n-\tinstall-dvi-am install-exec install-exec-am install-html \\\n-\tinstall-html-am install-info install-info-am install-man \\\n-\tinstall-pdf install-pdf-am install-ps install-ps-am \\\n-\tinstall-strip installcheck installcheck-am installdirs \\\n-\tmaintainer-clean maintainer-clean-generic mostlyclean \\\n-\tmostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \\\n-\tuninstall uninstall-am\n-\n-\n-# Tell versions [3.59,3.63) of GNU make to not export all variables.\n-# Otherwise a system limit (for SysV at least) may be exceeded.\n-.NOEXPORT:"}, {"sha": "0dafaa123d3da946687cfd225e560211d0b27722", "filename": "libmudflap/testsuite/config/default.exp", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Fconfig%2Fdefault.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Fconfig%2Fdefault.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Fconfig%2Fdefault.exp?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,3 +0,0 @@\n-load_lib standard.exp\n-load_lib libmudflap.exp\n-load_lib mfconfig.exp"}, {"sha": "9927ba1745a7f027631095735b3ace6cae095ce9", "filename": "libmudflap/testsuite/lib/libmudflap.exp", "status": "removed", "additions": 0, "deletions": 311, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flib%2Flibmudflap.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flib%2Flibmudflap.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flib%2Flibmudflap.exp?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,311 +0,0 @@\n-# Copyright (C) 2001-2013 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-# \n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-# \n-# You should have received a copy of the GNU General Public License\n-# along with this program; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-# Define libmudflap callbacks for dg.exp.\n-# This file is a copy of libstdc++-v3's dejagnu driver, with minor changes.\n-\n-# Useful hook:  if ${hostname}_init exists, it will be called, almost\n-# the last thing before testing begins.  This can be defined in, e.g.,\n-# ~/.dejagnurc or $DEJAGNU.\n-\n-proc load_gcc_lib { filename } {\n-    global srcdir\n-    load_file $srcdir/../../gcc/testsuite/lib/$filename\n-}\n-\n-load_lib mfdg.exp\n-load_lib libgloss.exp\n-load_gcc_lib target-libpath.exp\n-load_gcc_lib target-supports.exp\n-load_gcc_lib timeout.exp\n-load_gcc_lib timeout-dg.exp\n-\n-proc libmudflap-init { language } {\n-    global env\n-    global srcdir outdir blddir objdir tool_root_dir\n-    global cxx cxxflags\n-    global includes\n-    global libs\n-    global gluefile wrap_flags\n-    global ld_library_path\n-\n-    switch $language {\n-        \"c\" { set cxx [find_gcc] }\n-        \"c++\" { set cxx [find_g++] }\n-        default { error \"bad language code $language\"; return }\n-    }\n-\n-    verbose -log \"libmudflap-init $cxx\"\n-\n-    set blddir [lookfor_file [get_multilibs] libmudflap]\n-    set cxxblddir [lookfor_file [get_multilibs] libstdc++-v3]\n-    set cxxflags_file \"${cxxblddir}/scripts/testsuite_flags\"\n-\n-    # By default, we assume we want to run program images.\n-    global dg-do-what-default\n-    set dg-do-what-default run\n-\n-    # set LD_LIBRARY_PATH so that libgcc_s, libstdc++ binaries can be found.\n-    # locate libgcc.a so we don't need to account for different values of\n-    # SHLIB_EXT on different platforms\n-    set gccdir [lookfor_file $tool_root_dir gcc/libgcc.a]\n-    if {$gccdir != \"\"} {\n-\tset gccdir [file dirname $gccdir]\n-    }\n-\n-    set ld_library_path \".\"\n-    append ld_library_path \":${gccdir}\"\n-    append ld_library_path \":${cxxblddir}/src/.libs\"\n-    if {[is_remote host] == 0} {\n-\tforeach i \"[exec ${gccdir}/xgcc --print-multi-lib]\" {\n-\t    set mldir \"\"\n-\t    regexp -- \"\\[a-z0-9=_/\\.-\\]*;\" $i mldir\n-\t    set mldir [string trimright $mldir \"\\;@\"]\n-\t    if { \"$mldir\" == \".\" } {\n-\t\tcontinue\n-\t    }\n-\t    if { [llength [glob -nocomplain ${gccdir}/${mldir}/libgcc_s*.so.*]] >= 1 } {\n-\t\tappend ld_library_path \":${gccdir}/${mldir}\"\n-\t    }\n-\t}\n-    }\n-    append ld_library_path \":${blddir}/.libs\"\n-\n-    set libs \"-L${blddir}/.libs\"\n-    set cxxflags \"-ggdb3 -DDEBUG_ASSERT -fdiagnostics-color=never\"\n-    set includes \"-I${srcdir} -I${srcdir}/.. -I..\"\n-\n-    if {$language == \"c++\"} {\n-        if {[file exists $cxxflags_file]} then {\n-            set includes \"${includes} [exec sh $cxxflags_file --build-includes]\"\n-            set cxxflags \"${cxxflags} [exec sh $cxxflags_file --cxxflags]\"\n-            # c++ libs are included by --build-cxx below\n-            set cxx \"[exec sh $cxxflags_file --build-cxx]\"\n-        } else {\n-            lappend libs \"-L${cxxblddir}src/.libs\"\n-            lappend includes \"-I../../libstdc++-v3/include\"\n-        }\n-    }\n-\n-    global mfconfig_libs\n-    global add_flags\n-    append add_flags \" $mfconfig_libs\"\n-\n-    set_ld_library_path_env_vars\n-    if [info exists env(LD_LIBRARY_PATH)] {\n-\tverbose -log \"LD_LIBRARY_PATH = $env(LD_LIBRARY_PATH)\"\n-    }\n-\n-    if { [target_info needs_status_wrapper]!=\"\"} {\n-      file delete ${objdir}/testglue.o;\n-      set gluefile ${objdir}/testglue.o;\n-      set result [build_wrapper $gluefile];\n-      if { $result != \"\" } {\n-          set gluefile [lindex $result 0];\n-          set wrap_flags [lindex $result 1];\n-      } else {\n-          unset gluefile\n-      }\n-    }\n-\n-    # If there is no static library then don't run tests with -static.\n-    global tool\n-    global mfconfig_libs\n-    set opts \"additional_flags=-static\"\n-    lappend opts \"additional_flags=-fmudflap\"\n-    lappend opts \"additional_flags=-lmudflap\"\n-    lappend opts \"libs=$mfconfig_libs\"\n-    set src stlm[pid].c\n-    set exe stlm[pid].x\n-\n-    set f [open $src \"w\"]\n-    puts $f \"int main () { }\"\n-    close $f\n-    set lines [${tool}_target_compile $src $exe executable \"$opts\"]\n-    file delete $src\n-    remote_file build delete $exe\n-\n-    if { ![string match \"\" $lines] } {\n-\t# Compilation failed; assume static library is not available.\n-\tglobal MUDFLAP_FLAGS\n-\tset i [lsearch $MUDFLAP_FLAGS \"*static*\"]\n-\tset MUDFLAP_FLAGS [lreplace $MUDFLAP_FLAGS $i $i]\n-    }\n-}\n-\n-proc libmudflap-dg-test { prog do_what extra_tool_flags } {\n-    # Set up the compiler flags, based on what we're going to do.\n-\n-    switch $do_what {\n-\t\"preprocess\" {\n-\t    set compile_type \"preprocess\"\n-\t    set output_file \"[file rootname [file tail $prog]].i\"\n-\t}\n-\t\"compile\" {\n-\t    set compile_type \"assembly\"\n-\t    set output_file \"[file rootname [file tail $prog]].s\"\n-\t}\n-\t\"assemble\" {\n-\t    set compile_type \"object\"\n-\t    set output_file \"[file rootname [file tail $prog]].o\"\n-\t}\n-\t\"link\" {\n-\t    set compile_type \"executable\"\n-\t    set output_file \"./[file rootname [file tail $prog]].exe\"\n-\t}\n-\t\"run\" {\n-\t    set compile_type \"executable\"\n-\t    # FIXME: \"./\" is to cope with \".\" not being in $PATH.\n-\t    # Should this be handled elsewhere?\n-\t    # YES.\n-\t    set output_file \"./[file rootname [file tail $prog]].exe\"\n-\t    # This is the only place where we care if an executable was\n-\t    # created or not.  If it was, dg.exp will try to run it.\n-\t    remote_file build delete $output_file;\n-\t}\n-\tdefault {\n-\t    perror \"$do_what: not a valid dg-do keyword\"\n-\t    return \"\"\n-\t}\n-    }\n-    set options \"\"\n-    if { $extra_tool_flags != \"\" } {\n-\tlappend options \"additional_flags=$extra_tool_flags\"\n-    }\n-\n-    global mfconfig_libs\n-    lappend options \"libs=$mfconfig_libs\"\n-\n-    set comp_output [libmudflap_target_compile \"$prog\" \"$output_file\" \"$compile_type\" $options];\n-\n-    return [list $comp_output $output_file]\n-}\n-\n-\n-proc libmudflap_target_compile { source dest type options } {\n-    global gluefile \n-    global wrap_flags\n-    global cxx\n-    global cxxflags\n-    global includes\n-    global libs\n-    global blddir\n-\n-    if { [target_info needs_status_wrapper] != \"\" && [info exists gluefile] } {\n-\tlappend options \"libs=${gluefile}\"\n-\tlappend options \"ldflags=${wrap_flags}\"\n-    }\n-\n-    set cxx_final $cxx\n-    set cxxlibglossflags  [libgloss_link_flags]\n-    set cxx_final [concat $cxx_final $cxxlibglossflags]\n-    set cxx_final [concat $cxx_final $cxxflags]\n-    set cxx_final [concat $cxx_final $includes]\n-    set cxx_final [concat $cxx_final $libs]\n-\n-    lappend options \"compiler=$cxx_final\"\n-    lappend options \"timeout=[timeout_value]\"\n-\n-    # Picks up the freshly-built testsuite library corresponding to the\n-    # multilib under test.\n-    lappend options \"ldflags=-L${blddir}/testsuite\"\n-\n-    return [target_compile $source $dest $type $options]\n-}\n-\n-\n-# A bit sloppy...  Returns a list of source files (full pathnames) to\n-# compile.  We mimic the mkcheck script in that the first time this is run,\n-# all existing files are listed in \"testsuite_files\" in the output\n-# directory.  Subsequent runs pull the list from that file, allowing users\n-# to trim the list down to problematic tests.\n-### This is supposed to be done via RUNTESTFLAGS, but that doesn't work.\n-proc libmudflap-list-sourcefiles { } {\n-    global srcdir\n-    global outdir\n-\n-    set files_file \"${outdir}/testsuite_files\"\n-    set sfiles \"\"\n-    if { [file exists $files_file] } {\n-\tset f [open $files_file]\n-\twhile { ! [eof $f] } {\n-\t    set t [gets $f]\n-\t    if { [string length \"$t\"] != 0 } {\n-\t\tlappend sfiles ${srcdir}/${t}\n-\t    }\n-\t}\n-    } else {\n-\tset f [open $files_file \"w\"]\n-\tset where_we_were [pwd]\n-\tcd $srcdir\n-\tforeach s [lsort [glob -nocomplain \"*/*.cc\" \"*/*/*.cc\" \"{,*/}*/*/*/*.cc\" ]] {\n-\t    lappend sfiles ${srcdir}/${s}\n-\t    puts $f $s\n-\t}\n-\tcd $where_we_were\n-    }\n-    close $f\n-\n-    # Disable wchar_t tests if library not configured to support\n-    # wchar_t testing. \n-    set wchar_file \"${outdir}/testsuite_wchar_t\"    \n-    if { [file exists $wchar_file] } {\n-\treturn $sfiles\n-    } else {\n-\t# Remove wchar_t tests files from list.\n-\tset res {}\n-\tforeach w $sfiles {\n-\t    if [regexp \"wchar_t\" $w] {\n-\t\tverbose -log \"element out list is $w\"\n-\t    } else {\n-\t\tverbose -log \"element in list is $w\"\n-\t\tlappend res $w\n-\t    }\n-\t}\n-\treturn $res\n-    }\n-}\n-\n-\n-proc libmudflap-dg-prune { system text } {\n-    global additional_prunes\n-\n-    set text [prune_gcc_output $text]\n-\n-    foreach p $additional_prunes {\n-\tif { [string length $p] > 0 } {\n-\t    # Following regexp matches a complete line containing $p.\n-\t    regsub -all \"(^|\\n)\\[^\\n\\]*$p\\[^\\n\\]*\" $text \"\" text\n-\t}\n-    }\n-\n-    return $text\n-}\n-\n-\n-proc prune_gcc_output { text } {\n-    # Ignore caret diagnostics. Unfortunately dejaGNU trims leading\n-    # spaces, so one cannot rely on them being present.\n-    regsub -all \"(^|\\n)\\[^\\n\\]+\\n *\\\\^\\n\" $text \"\\n\" text\n-    regsub -all {(^|\\n)[^\\n]*ld: warning: libgcc_s[^\\n]*not found[^\\n]*try using[^\\n]*} $text \"\" text\n-    regsub -all {(^|\\n)[^\\n]*In function.*pthread_create[^\\n]*} $text \"\" text\n-    regsub -all {(^|\\n)[^\\n]*the use of .pthread.*is deprecated[^\\n]*} $text \"\" text\n-    regsub -all {(^|\\n)[^\\n]*Dwarf Error:.*FORM value: 14[^\\n]*} $text \"\" text\n-    regsub -all {(^|\\n)[^\\n]*In function[^\\n]*} $text \"\" text\n-    regsub -all {(^|\\n)[^\\n]*Using.*in statically linked applications requires[^\\n]*} $text \"\" text\n-\n-    return $text\n-}"}, {"sha": "1984b313cc9233699e064cd73da35a22a8b5ee9e", "filename": "libmudflap/testsuite/lib/mfdg.exp", "status": "removed", "additions": 0, "deletions": 375, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flib%2Fmfdg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flib%2Fmfdg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flib%2Fmfdg.exp?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,375 +0,0 @@\n-# `mfdg' - overrides parts of general purpose testcase driver.\n-# Copyright (C) 1994-2013 Free Software Foundation, Inc.\n-\n-# This program is free software; you can redistribute it and/or modify\n-# it under the terms of the GNU General Public License as published by\n-# the Free Software Foundation; either version 3 of the License, or\n-# (at your option) any later version.\n-# \n-# This program is distributed in the hope that it will be useful,\n-# but WITHOUT ANY WARRANTY; without even the implied warranty of\n-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-# GNU General Public License for more details.\n-# \n-# You should have received a copy of the GNU General Public License\n-# along with this program; see the file COPYING3.  If not see\n-# <http://www.gnu.org/licenses/>.\n-\n-\n-# This is a modified excerpt of dejagnu/lib/dg.exp.\n-\n-load_lib dg.exp\n-\n-# We set LC_ALL and LANG to C so that we get the same error messages as expected.\n-setenv LC_ALL C\n-setenv LANG C\n-\n-# Many hosts now default to a non-ASCII C locale, however, so\n-# they can set a charset encoding here if they need.\n-if { [ishost \"*-*-cygwin*\"] } {\n-  setenv LC_ALL C.ASCII\n-  setenv LANG C.ASCII\n-}\n-\n-# dg-test -- runs a new style DejaGnu test\n-#\n-# Syntax: dg-test [-keep-output] prog tool_flags default_extra_tool_flags\n-#\n-# PROG is the full path name of the file to pass to the tool (eg: compiler).\n-# TOOL_FLAGS is a set of options to always pass.\n-# DEFAULT_EXTRA_TOOL_FLAGS are additional options if the testcase has none.\n-\n-#proc dg-test { prog tool_flags default_extra_tool_flags } {\n-proc dg-test { args } {\n-    global dg-do-what-default dg-interpreter-batch-mode dg-linenum-format\n-    global errorCode errorInfo\n-    global additional_prunes\n-    global tool\n-    global srcdir\t\t;# eg: /calvin/dje/build/gcc/./testsuite/\n-    global host_triplet target_triplet\n-\n-    set keep 0\n-    set i 0\n-    set dg-repetitions 1 ;# may be overridden by { dg-repetitions N }\n-    unset_timeout_vars\n-\n-    if { [string index [lindex $args 0] 0] == \"-\" } {\n-\tfor { set i 0 } { $i < [llength $args] } { incr i } {\n-\t    if { [lindex $args $i] == \"--\" } {\n-\t\tincr i\n-\t\tbreak\n-\t    } elseif { [lindex $args $i] == \"-keep-output\" } {\n-\t\tset keep 1\n-\t    } elseif { [string index [lindex $args $i] 0] == \"-\" } {\n-\t\tclone_output \"ERROR: dg-test: illegal argument: [lindex $args $i]\"\n-\t\treturn\n-\t    } else {\n-\t\tbreak\n-\t    }\n-\t}\n-    }\n-\n-    if { $i + 3 != [llength $args] } {\n-\tclone_output \"ERROR: dg-test: missing arguments in call\"\n-\treturn\n-    }\n-    set prog [lindex $args $i]\n-    set tool_flags [lindex $args [expr $i + 1]]\n-    set default_extra_tool_flags [lindex $args [expr $i + 2]]\n-\n-    set text \"\\[- A-Za-z0-9\\.\\;\\\"\\_\\:\\'\\`\\(\\)\\!\\#\\=\\+\\?\\&\\*]*\"\n-\n-    set name [dg-trim-dirname $srcdir $prog]\n-    # If we couldn't rip $srcdir out of `prog' then just do the best we can.\n-    # The point is to reduce the unnecessary noise in the logs.  Don't strip\n-    # out too much because different testcases with the same name can confuse\n-    # `test-tool'.\n-    if [string match \"/*\" $name] {\n-\tset name \"[file tail [file dirname $prog]]/[file tail $prog]\"\n-    }\n-\n-    if {$tool_flags != \"\"} {\n-\tappend name \" ($tool_flags)\"\n-    }\n-\n-    # Process any embedded dg options in the testcase.\n-\n-    # Use \"\" for the second element of dg-do-what so we can tell if it's been\n-    # explicitly set to \"S\".\n-    set dg-do-what [list ${dg-do-what-default} \"\" P]\n-    set dg-excess-errors-flag 0\n-    set dg-messages \"\"\n-    set dg-extra-tool-flags $default_extra_tool_flags\n-    set dg-final-code \"\"\n-\n-    set additional_prunes \"\"\n-\n-    # `dg-output-text' is a list of two elements: pass/fail and text.\n-    # Leave second element off for now (indicates \"don't perform test\")\n-    set dg-output-text \"P\"\n-\n-    # Define our own \"special function\" `unknown' so we catch spelling errors.\n-    # But first rename the existing one so we can restore it afterwards.\n-    catch {rename dg-save-unknown \"\"}\n-    rename unknown dg-save-unknown\n-    proc unknown { args } {\n-\treturn -code error \"unknown dg option: $args\"\n-    }\n-\n-    set tmp [dg-get-options $prog]\n-    foreach op $tmp {\n-\tverbose \"Processing option: $op\" 3\n-\tset status [catch \"$op\" errmsg]\n-\tif { $status != 0 } {\n-\t    if { 0 && [info exists errorInfo] } {\n-\t\t# This also prints a backtrace which will just confuse\n-\t\t# testcase writers, so it's disabled.\n-\t\tperror \"$name: $errorInfo\\n\"\n-\t    } else {\n-\t\tperror \"$name: $errmsg for \\\"$op\\\"\\n\"\n-\t    }\n-\t    # ??? The call to unresolved here is necessary to clear `errcnt'.\n-\t    # What we really need is a proc like perror that doesn't set errcnt.\n-\t    # It should also set exit_status to 1.\n-\t    unresolved \"$name: $errmsg for \\\"$op\\\"\"\n-\t    return\n-\t}\n-    }\n-\n-    # Restore normal error handling.\n-    rename unknown \"\"\n-    rename dg-save-unknown unknown\n-\n-    # If we're not supposed to try this test on this target, we're done.\n-    if { [lindex ${dg-do-what} 1] == \"N\" } {\n-\tunsupported \"$name\"\n-\tverbose \"$name not supported on this target, skipping it\" 3\n-\treturn\n-    }\n-\n-    # Run the tool and analyze the results.\n-    # The result of ${tool}-dg-test is in a bit of flux.\n-    # Currently it is the name of the output file (or \"\" if none).\n-    # If we need more than this it will grow into a list of things.\n-    # No intention is made (at this point) to preserve upward compatibility\n-    # (though at some point we'll have to).\n-\n-    set results [${tool}-dg-test $prog [lindex ${dg-do-what} 0] \"$tool_flags ${dg-extra-tool-flags}\"];\n-\n-    set comp_output [lindex $results 0];\n-    set output_file [lindex $results 1];\n-\n-    #send_user \"\\nold_dejagnu.exp: comp_output1 = :$comp_output:\\n\\n\"\n-    #send_user \"\\nold_dejagnu.exp: message = :$message:\\n\\n\"\n-    #send_user \"\\nold_dejagnu.exp: message length = [llength $message]\\n\\n\"\n-\n-    foreach i ${dg-messages} {\n-\tverbose \"Scanning for message: $i\" 4\n-\n-\t# Remove all error messages for the line [lindex $i 0]\n-\t# in the source file.  If we find any, success!\n-\tset line [lindex $i 0]\n-\tset pattern [lindex $i 2]\n-\tset comment [lindex $i 3]\n-\t#send_user \"Before:\\n$comp_output\\n\"\n-\tif [regsub -all \"(^|\\n)(\\[^\\n\\]+$line\\[^\\n\\]*($pattern)\\[^\\n\\]*\\n?)+\" $comp_output \"\\n\" comp_output] {\n-            set comp_output [string trimleft $comp_output]\n-\t    set ok pass\n-\t    set uhoh fail\n-\t} else {\n-\t    set ok fail\n-\t    set uhoh pass\n-\t}\n-\t#send_user \"After:\\n$comp_output\\n\"\n-\n-\t# $line will either be a formatted line number or a number all by\n-\t# itself.  Delete the formatting.\n-\tscan $line ${dg-linenum-format} line\n-\tswitch [lindex $i 1] {\n-\t    \"ERROR\" {\n-\t\t$ok \"$name $comment (test for errors, line $line)\"\n-\t    }\n-\t    \"XERROR\" {\n-\t\tx$ok \"$name $comment (test for errors, line $line)\"\n-\t    }\n-\t    \"WARNING\" {\n-\t\t$ok \"$name $comment (test for warnings, line $line)\"\n-\t    }\n-\t    \"XWARNING\" {\n-\t\tx$ok \"$name $comment (test for warnings, line $line)\"\n-\t    }\n-\t    \"BOGUS\" {\n-\t\t$uhoh \"$name $comment (test for bogus messages, line $line)\"\n-\t    }\n-\t    \"XBOGUS\" {\n-\t\tx$uhoh \"$name $comment (test for bogus messages, line $line)\"\n-\t    }\n-\t    \"BUILD\" {\n-\t\t$uhoh \"$name $comment (test for build failure, line $line)\"\n-\t    }\n-\t    \"XBUILD\" {\n-\t\tx$uhoh \"$name $comment (test for build failure, line $line)\"\n-\t    }\n-\t    \"EXEC\" { }\n-\t    \"XEXEC\" { }\n-\t}\n-\t#send_user \"\\nold_dejagnu.exp: comp_output2= :$comp_output:\\n\\n\"\n-    }\n-    #send_user \"\\nold_dejagnu.exp: comp_output3 = :$comp_output:\\n\\n\"\n-\n-    # Remove messages from the tool that we can ignore.\n-    #send_user \"comp_output: $comp_output\\n\"\n-    set comp_output [prune_warnings $comp_output]\n-\n-    if { [info proc ${tool}-dg-prune] != \"\" } {\n-\tset comp_output [${tool}-dg-prune $target_triplet $comp_output]\n-\tswitch -glob $comp_output {\n-\t    \"::untested::*\" {\n-\t\tregsub \"::untested::\" $comp_output \"\" message\n-\t\tuntested \"$name: $message\"\n-\t\treturn\n-\t    }\n-\t    \"::unresolved::*\" {\n-\t\tregsub \"::unresolved::\" $comp_output \"\" message\n-\t\tunresolved \"$name: $message\"\n-\t\treturn\n-\t    }\n-\t    \"::unsupported::*\" {\n-\t\tregsub \"::unsupported::\" $comp_output \"\" message\n-\t\tunsupported \"$name: $message\"\n-\t\treturn\n-\t    }\n-\t}\n-    }\n-\n-    # See if someone forgot to delete the extra lines.\n-    regsub -all \"\\n+\" $comp_output \"\\n\" comp_output\n-    regsub \"^\\n+\" $comp_output \"\" comp_output\n-    #send_user \"comp_output: $comp_output\\n\"\n-\n-    # Don't do this if we're testing an interpreter.\n-    # FIXME: why?\n-    if { ${dg-interpreter-batch-mode} == 0 } {\n-\t# Catch excess errors (new bugs or incomplete testcases).\n-\tif ${dg-excess-errors-flag} {\n-\t    setup_xfail \"*-*-*\"\n-\t}\n-\tif ![string match \"\" $comp_output] {\n-\t    fail \"$name (test for excess errors)\"\n-\t    send_log \"Excess errors:\\n$comp_output\\n\"\n-\t} else {\n-\t    pass \"$name (test for excess errors)\"\n-\t}\n-    }\n-\n-    # Run the executable image if asked to do so.\n-    # FIXME: This is the only place where we assume a standard meaning to\n-    # the `keyword' argument of dg-do.  This could be cleaned up.\n-    if { [lindex ${dg-do-what} 0] == \"run\" } {\n-\tif ![file exists $output_file] {\n-\t    warning \"$name compilation failed to produce executable\"\n-\t} else {\n-\t    set testname $name\n-\t    for {set rep 0} {$rep < ${dg-repetitions}} {incr rep} {\n-\t\t# include repetition number in test name\n-\t\tif {$rep > 0} { set name \"$testname (rerun $rep)\" }\n-\n-\t\tset status -1\n-\t\tset result [${tool}_load $output_file]\n-\t\tset status [lindex $result 0];\n-\t\tset output [lindex $result 1];\n-\t\t#send_user \"After exec, status: $status\\n\"\n-\n-\t\tif { \"$status\" == \"pass\" } {\n-\t\t    verbose \"Exec succeeded.\" 3\n-\t\t} elseif { \"$status\" == \"fail\" } {\n-\t\t    # It would be nice to get some info out of errorCode.\n-\t\t    if [info exists errorCode] {\n-\t\t\tverbose \"Exec failed, errorCode: $errorCode\" 3\n-\t\t    } else {\n-\t\t\tverbose \"Exec failed, errorCode not defined!\" 3\n-\t\t    }\n-\t\t}\n-\t\t\n-\t\tif { [lindex ${dg-do-what} 2] == \"F\" } {\n-\t\t    # Instead of modelling this as an xfail (via setup_xfail), \n-\t\t    # treat an expected crash as a success.\n-\t\t    if { $status == \"pass\" } then { set status fail } else { set status pass }\n-\t\t    set testtype \"crash\"\n-\t\t} else { set testtype \"execution\" }\n-\t\t\n-\t\t$status \"$name $testtype test\"\n-\t\t\n-\t\tif { [llength ${dg-output-text}] > 1 } {\n-\t\t    #send_user \"${dg-output-text}\\n\"\n-\t\t    if { [lindex ${dg-output-text} 0] == \"F\" } {\n-\t\t\tsetup_xfail \"*-*-*\"\n-\t\t    }\n-\t\t    set texttmp [lindex ${dg-output-text} 1]\n-\t\t    if { ![regexp $texttmp ${output}] } {\n-\t\t\tfail \"$name output pattern test\"\n-\t\t    } else {\n-\t\t\tpass \"$name output pattern test\"\n-\t\t    }\n-\t\t    verbose -log \"Output pattern $texttmp\"\n-\t\t    unset texttmp\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-    # Are there any further tests to perform?\n-    # Note that if the program has special run-time requirements, running\n-    # of the program can be delayed until here.  Ditto for other situations.\n-    # It would be a bit cumbersome though.\n-\n-    if ![string match ${dg-final-code} \"\"] {\n-\tregsub -all \"\\\\\\\\(\\[{}\\])\" ${dg-final-code} \"\\\\1\" dg-final-code\n-\t# Note that the use of `args' here makes this a varargs proc.\n-\tproc dg-final-proc { args } ${dg-final-code}\n-\tverbose \"Running dg-final tests.\" 3\n-\tverbose \"dg-final-proc:\\n[info body dg-final-proc]\" 4\n-\tif [catch \"dg-final-proc $prog\" errmsg] {\n-\t    perror \"$name: error executing dg-final: $errmsg\"\n-\t    # ??? The call to unresolved here is necessary to clear `errcnt'.\n-\t    # What we really need is a proc like perror that doesn't set errcnt.\n-\t    # It should also set exit_status to 1.\n-\t    unresolved \"$name: error executing dg-final: $errmsg\"\n-\t}\n-    }\n-\n-    # Do some final clean up.\n-    # When testing an interpreter, we don't compile something and leave an\n-    # output file.\n-    if { ! ${keep} && ${dg-interpreter-batch-mode} == 0 } {\n-\tcatch \"exec rm -f $output_file\"\n-    }\n-}\n-\n-\n-# \n-# Indicate that this test case is to be rerun several times.  This\n-# is useful if it is nondeterministic.  This applies to rerunning the\n-# test program only, not rebuilding it.\n-# The embedded format is \"{ dg-repetitions N }\", where N is the number\n-# of repetitions.  It better be greater than zero.\n-#\n-proc dg-repetitions { line value } {\n-    upvar dg-repetitions repetitions\n-    set repetitions $value\n-}\n-\n-\n-# Prune any messages matching ARGS[1] (a regexp) from test output.\n-proc dg-prune-output { args } {\n-    global additional_prunes\n-\n-    if { [llength $args] != 2 } {\n-\terror \"[lindex $args 1]: need one argument\"\n-\treturn\n-    }\n-\n-    lappend additional_prunes [lindex $args 1]\n-}\n-\n-set additional_prunes \"\""}, {"sha": "4e3d244fd1a5922a5355ce687feb463721a59e4a", "filename": "libmudflap/testsuite/libmudflap.c++/c++frags.exp", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fc%2B%2Bfrags.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fc%2B%2Bfrags.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fc%2B%2Bfrags.exp?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,22 +0,0 @@\n-global MUDFLAP_FLAGS\n-set MUDFLAP_FLAGS [list {-O0} {-static} { -O} {-O2} {-O3}]\n-\n-libmudflap-init c++\n-if {$cxx == \"g++\"} then {\n-    unsupported \"g++ not found\"\n-    return\n-}\n-\n-dg-init\n-\n-global srcdir\n-\n-foreach flags $MUDFLAP_FLAGS {\n-    foreach srcfile [lsort [glob -nocomplain ${srcdir}/libmudflap.c++/*frag.cxx]] {\n-\tset bsrc [file tail $srcfile]\n-\tsetenv MUDFLAP_OPTIONS \"-viol-segv\"\n-\tdg-runtest $srcfile $flags \"-fmudflap -lmudflap\"\n-    }\n-}\n-\n-dg-finish"}, {"sha": "7717c805ca58ea6b7279668e66d6c70a7e1e37f0", "filename": "libmudflap/testsuite/libmudflap.c++/ctors-1.cxx", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fctors-1.cxx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fctors-1.cxx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fctors-1.cxx?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,20 +0,0 @@\n-#include <iostream>\n-\n-\n-extern char k [];\n-\n-class foo\n-{\n- public:\n-  foo (char *m) { m [40] = 20; }\n-};\n-\n-\n-foo f1 (k);\n-foo f2 (k);\n-foo f3 (k);\n-\n-int main ()\n-{\n-  return 0;\n-}"}, {"sha": "c1a501979bf75331a04713b7521c0342ff618b88", "filename": "libmudflap/testsuite/libmudflap.c++/ctors-2.cxx", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fctors-2.cxx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fctors-2.cxx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fctors-2.cxx?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1 +0,0 @@\n-char k [500];"}, {"sha": "df7293dc91c5765af7f8d93eb4ac648b183a1f08", "filename": "libmudflap/testsuite/libmudflap.c++/ctors.exp", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fctors.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fctors.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fctors.exp?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,48 +0,0 @@\n-global MUDFLAP_FLAGS\n-set MUDFLAP_FLAGS [list {-O0} {-static} {-O2} {-O3}]\n-\n-libmudflap-init c++\n-if {$cxx == \"g++\"} then {\n-    unsupported \"g++ not found\"\n-    return\n-}\n-\n-dg-init\n-\n-global srcdir subdir\n-\n-foreach flags $MUDFLAP_FLAGS {\n-    set l1 [libmudflap_target_compile \"$srcdir/$subdir/ctors-1.cxx\" \"ctors-1.o\" object {additional_flags=-fmudflap}]\n-    set test \"ctors-1 compilation ${flags}\"\n-    if [string match \"*mudflap cannot track unknown size extern *k*\" $l1] { pass $test } { fail $test }\n-\n-    set l2 [libmudflap_target_compile \"$srcdir/$subdir/ctors-2.cxx\" \"ctors-2.o\" object {additional_flags=-fmudflap}]\n-    set test \"ctors-2 compilation ${flags}\"\n-    if [string match \"\" $l2]  { pass $test } { fail $test }\n-\n-    set l3 [libmudflap_target_compile \"ctors-1.o ctors-2.o\" \"ctors-12.exe\" executable {additional_flags=-fmudflap additional_flags=-lmudflap additional_flags=-lstdc++}]\n-    set test \"ctors-12 linkage ${flags}\"\n-    if [string match \"\" $l3]  { pass $test } { fail $test }\n-\n-    set l4 [libmudflap_target_compile \"ctors-2.o ctors-1.o\" \"ctors-21.exe\" executable {additional_flags=-fmudflap additional_flags=-lmudflap additional_flags=-lstdc++}]\n-    set test \"ctors-21 linkage ${flags}\"\n-    if [string match \"\" $l3]  { pass $test } { fail $test }\n-\n-    setenv MUDFLAP_OPTIONS \"-viol-segv\"\n-\n-    remote_spawn host \"./ctors-12.exe\"\n-    set l5 [remote_wait host 10]\n-    set test \"ctors-12 execution ${flags}\"\n-    if {[lindex $l5 0] == 0}  { pass $test } { fail $test }\n-\n-    remote_spawn host \"./ctors-21.exe\"\n-    set l6 [remote_wait host 10]\n-    set test \"ctors-21 execution ${flags}\"\n-    if {[lindex $l6 0] == 0}  { pass $test } { fail $test }\n-\n-    foreach f [glob -nocomplain \"ctors-*\"] {\n-       remote_file build delete $f\n-    }\n-}\n-\n-dg-finish"}, {"sha": "8bfe85328302f0a635b3e27ca0aee05d73304b0a", "filename": "libmudflap/testsuite/libmudflap.c++/error1-frag.cxx", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Ferror1-frag.cxx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Ferror1-frag.cxx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Ferror1-frag.cxx?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,5 +0,0 @@\n-// PR 26789\n-// { dg-do compile }\n-\n-struct A;\n-A a; // { dg-error \"incomplete\" }"}, {"sha": "0e89e117fbf6db19ccba708b0f1bb42ffbf977b3", "filename": "libmudflap/testsuite/libmudflap.c++/error2-frag.cxx", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Ferror2-frag.cxx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Ferror2-frag.cxx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Ferror2-frag.cxx?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,10 +0,0 @@\n-// PR 26790\n-// { dg-do compile }\n-\n-struct A;\n-\n-A foo()  // { dg-error \"incomplete\" }\n-{\n-    A a; // { dg-error \"incomplete\" }\n-    return a;\n-}"}, {"sha": "e3467ddaf1a1a3c1112e57f055371cecdc9eb082", "filename": "libmudflap/testsuite/libmudflap.c++/fail24-frag.cxx", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Ffail24-frag.cxx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Ffail24-frag.cxx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Ffail24-frag.cxx?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,16 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-char zoo [10];\n-\n-int main ()\n-{\n-int i = strlen (\"twelve\") + strlen (\"zero\") + strlen (\"seventeen\");\n-zoo[i] = 'a';\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object.*\" } */\n-/* { dg-output \"mudflap object.*zoo.*static.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "aca2ea3a3b67941696aaaa1089c923168b458ea9", "filename": "libmudflap/testsuite/libmudflap.c++/pass27-frag.cxx", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass27-frag.cxx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass27-frag.cxx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass27-frag.cxx?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,12 +0,0 @@\n-class foo {\n-  char z [10];\n-public:\n-  char *get_z () { return & this->z[0]; }\n-};\n-\n-int main ()\n-{\n-foo x;\n-x.get_z()[9] = 'a';\n-return 0;\n-}"}, {"sha": "75e14ba1460069e79a5f0e26313e5b25c0b9d00e", "filename": "libmudflap/testsuite/libmudflap.c++/pass28-frag.cxx", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass28-frag.cxx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass28-frag.cxx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass28-frag.cxx?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,20 +0,0 @@\n-class foo {\n-  char z [10];\n-public:\n-  virtual char *get_z () { return & this->z[0]; }\n-};\n-\n-class bar: public foo {\n-  char q [20];\n-public:\n-  char *get_z () { return & this->q[0]; }\n-};\n-\n-int main () {\n-foo *x = new bar ();\n-\n-x->get_z()[9] = 'a';\n-\n-delete x;\n-return 0;\n-}"}, {"sha": "6c4b9f9a7f8b8298b7f900343b90ad4e301e8c42", "filename": "libmudflap/testsuite/libmudflap.c++/pass31-frag.cxx", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass31-frag.cxx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass31-frag.cxx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass31-frag.cxx?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,12 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-char zoo [10];\n-\n-int main ()\n-{\n-int i = strlen (\"eight\") + strlen (\"one\");\n-zoo[i] = 'a';\n-return 0;\n-}"}, {"sha": "06896c7f6e75936cbc01b8a3cc029afe22bdcf25", "filename": "libmudflap/testsuite/libmudflap.c++/pass41-frag.cxx", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass41-frag.cxx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass41-frag.cxx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass41-frag.cxx?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,13 +0,0 @@\n-#include <string>\n-#include <iostream>\n-\n-int\n-main (int argc, char *argv[])\n-{\n-    std::string myStr = \"Hello, World!\";\n-    std::cout << myStr << std::endl;\n-    return 0;\n-}\n-\n-/* Ignore a warning that is irrelevant to the purpose of this test.  */\n-/* { dg-prune-output \".*mudflap cannot track unknown size extern.*\" } */"}, {"sha": "e83c12461e2945f77a85a2f11e95abb11670717e", "filename": "libmudflap/testsuite/libmudflap.c++/pass55-frag.cxx", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass55-frag.cxx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass55-frag.cxx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass55-frag.cxx?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,7 +0,0 @@\n-#include <vector>\n-\n-int main() {\n-  std::vector<int> v;\n-  v.push_back(1);\n-  return 0;\n-} "}, {"sha": "8be1a2d1113d19707ef6f59905d0bd00cdc96551", "filename": "libmudflap/testsuite/libmudflap.c++/pass57-frag.cxx", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass57-frag.cxx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass57-frag.cxx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass57-frag.cxx?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,28 +0,0 @@\n-#include <vector>\n-#include <string>\n-\n-class fitscolumn\n-  {\n-  private:\n-    std::string name_, unit_;\n-   int i, t;\n-  public:\n-    fitscolumn (const std::string &nm, const std::string &un,int i1,int t1)\n-      : name_(nm), unit_(un), i(i1), t(t1){}\n-  };\n-\n-void init_bintab(std::vector<fitscolumn> & columns_)\n-{\n-  char ttype[81], tunit[81], tform[81];\n-  long repc;\n-  int typecode;\n-  columns_.push_back (fitscolumn (ttype,tunit,1,typecode));\n-}\n-\n-int main ()\n-{\n-  return 0;\n-}\n-\n-/* Ignore a warning that is irrelevant to the purpose of this test.  */\n-/* { dg-prune-output \".*mudflap cannot track unknown size extern.*\" } */"}, {"sha": "96da05fca07baea80042657b8b2d162475af554e", "filename": "libmudflap/testsuite/libmudflap.c++/pass58-frag.cxx", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass58-frag.cxx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass58-frag.cxx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass58-frag.cxx?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,12 +0,0 @@\n-// PR 19319\n-struct k {\n-  int data;\n-  k(int j): data(j) {}\n-};\n-k make_k () { return k(1); }\n-\n-int main ()\n-{\n-  k foo = make_k ();\n-  return 0;\n-}"}, {"sha": "35989d122b1318d69ca476a47025a0f2239f8a3d", "filename": "libmudflap/testsuite/libmudflap.c++/pass60-frag.cxx", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass60-frag.cxx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass60-frag.cxx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass60-frag.cxx?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,13 +0,0 @@\n-// PR 26442\n-\n-struct A\n-{\n-  A();\n-};\n-\n-int main()\n-{\n-  if (0)\n-    A();\n-  return 0;\n-}"}, {"sha": "03046112c46d2a530fb0d4e5408db7c7f36719d6", "filename": "libmudflap/testsuite/libmudflap.c++/pass61-frag.cxx", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass61-frag.cxx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass61-frag.cxx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass61-frag.cxx?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,20 +0,0 @@\n-// PR c++/34619\n-// { dg-do compile }\n-\n-template <typename> struct A\n-{\n-  typedef int X;\n-  static const int N = 1;\n-};\n-\n-template <typename T> struct B\n-{\n-  typedef typename A <int [A <T>::N]>::X Y;\n-  template <typename U> B (Y, U) {}\n-};\n-\n-int main ()\n-{\n-}\n-\n-B <int>b (0, 0);"}, {"sha": "989c7ca6f1c0c316f0f5691a27b9ba1bad0417e6", "filename": "libmudflap/testsuite/libmudflap.c++/pass66-frag.cxx", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass66-frag.cxx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass66-frag.cxx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2B%2B%2Fpass66-frag.cxx?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,17 +0,0 @@\n-// PR c++/37568\n-// { dg-do compile }\n-// { dg-options \"-fmudflap -O\" }\n-\n-struct A\n-{\n-  int i;\n-};\n-\n-A\n-foo ()\n-{\n-  A a = { 1 };\n-  return a;\n-}\n-\n-A a = foo ();"}, {"sha": "ebd67c4ff72d17fa5b1539bd41a0428118f8867b", "filename": "libmudflap/testsuite/libmudflap.c/cfrags.exp", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fcfrags.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fcfrags.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fcfrags.exp?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,21 +0,0 @@\n-global MUDFLAP_FLAGS\n-set MUDFLAP_FLAGS [list {-O0} {-static} {-O2} {-O3}]\n-\n-libmudflap-init c\n-\n-dg-init\n-\n-global srcdir\n-foreach flags $MUDFLAP_FLAGS {\n-    foreach srcfile [lsort [glob -nocomplain \\\n-                            ${srcdir}/libmudflap.c/*frag.c \\\n-                            ${srcdir}/libmudflap.c/heap*.c \\\n-                            ${srcdir}/libmudflap.c/hook*.c \\\n-                            ${srcdir}/libmudflap.c/pass*.c]] {\n-\tset bsrc [file tail $srcfile]\n-\tsetenv MUDFLAP_OPTIONS \"-viol-segv\"\n-\tdg-runtest $srcfile $flags \"-fmudflap -lmudflap\"\n-    }\n-}\n-\n-dg-finish"}, {"sha": "028f5eb5a4844916780e3311412dd23c75117dbc", "filename": "libmudflap/testsuite/libmudflap.c/externs-1.c", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fexterns-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fexterns-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fexterns-1.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,16 +0,0 @@\n-typedef struct { char *name; } dummy;\n-extern dummy d[];\n-\n-int\n-main (void)\n-{\n-  dummy *pd = d;\n-\n-  while (pd->name)\n-    {\n-      printf (\"%s\\n\", pd->name);\n-      pd++;\n-    }\n-\n-  return 0;\n-}"}, {"sha": "cecf6253a6aa83b325806ab35eef1def0eb6e223", "filename": "libmudflap/testsuite/libmudflap.c/externs-2.c", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fexterns-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fexterns-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fexterns-2.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,2 +0,0 @@\n-typedef struct { char *name; } dummy;\n-dummy d[] = { {\"a\"}, {0} };"}, {"sha": "5a0297f2ed44614fef08fd7f0bda704f3f784f63", "filename": "libmudflap/testsuite/libmudflap.c/externs.exp", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fexterns.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fexterns.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fexterns.exp?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,43 +0,0 @@\n-global MUDFLAP_FLAGS\n-set MUDFLAP_FLAGS [list {-O0} {-static} {-O2} {-O3}]\n-\n-libmudflap-init c\n-dg-init\n-\n-global srcdir subdir\n-\n-foreach flags $MUDFLAP_FLAGS {\n-    set l1 [libmudflap_target_compile \"$srcdir/$subdir/externs-1.c\" \"externs-1.o\" object {additional_flags=-fmudflap}]\n-    set test \"externs-1 compilation ${flags}\"\n-    if [string match \"*mudflap cannot track unknown size extern *d*\" $l1] { pass $test } { fail $test }\n-\n-    set l2 [libmudflap_target_compile \"$srcdir/$subdir/externs-2.c\" \"externs-2.o\" object {additional_flags=-fmudflap}]\n-    set test \"externs-2 compilation ${flags}\"\n-    if [string match \"\" $l2]  { pass $test } { fail $test }\n-\n-    set l3 [libmudflap_target_compile \"externs-1.o externs-2.o\" \"externs-12.exe\" executable {additional_flags=-fmudflap additional_flags=-lmudflap}]\n-    set test \"externs-12 linkage ${flags}\"\n-    if [string match \"\" $l3]  { pass $test } { fail $test }\n-\n-    set l4 [libmudflap_target_compile \"externs-2.o externs-1.o\" \"externs-21.exe\" executable {additional_flags=-fmudflap additional_flags=-lmudflap}]\n-    set test \"externs-21 linkage ${flags}\"\n-    if [string match \"\" $l3]  { pass $test } { fail $test }\n-\n-    setenv MUDFLAP_OPTIONS \"-viol-segv\"\n-\n-    remote_spawn host \"./externs-12.exe\"\n-    set l5 [remote_wait host 10]\n-    set test \"externs-12 execution ${flags}\"\n-    if {[lindex $l5 0] == 0}  { pass $test } { fail $test }\n-\n-    remote_spawn host \"./externs-21.exe\"\n-    set l6 [remote_wait host 10]\n-    set test \"externs-21 execution ${flags}\"\n-    if {[lindex $l6 0] == 0}  { pass $test } { fail $test }\n-\n-    foreach f [glob -nocomplain \"externs-*\"] {\n-       remote_file build delete $f\n-    }\n-}\n-\n-dg-finish"}, {"sha": "1e48fff8771d12a819f4ebb52a171cfb9e503ae3", "filename": "libmudflap/testsuite/libmudflap.c/fail1-frag.c", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail1-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail1-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail1-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,13 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-volatile int foo [10];\n-foo[10] = 0;\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*.main. foo.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "db135d5c45133e395baa9a44649b5440aa95e068", "filename": "libmudflap/testsuite/libmudflap.c/fail10-frag.c", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail10-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail10-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail10-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,16 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-volatile int foo[10];\n-int sz = sizeof (int);\n-\n-volatile char *bar = (char *)foo;\n-bar [sz * 10] = 0;\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*.main. foo.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "8cd4a5329dec39517aed43bdc66db914f42ff0db", "filename": "libmudflap/testsuite/libmudflap.c/fail11-frag.c", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail11-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail11-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail11-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,20 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-char *y;\n-int main ()\n-{\n-int i = 10;\n-char *x = (char *) malloc (i * sizeof (char));\n-y = x;\n-while (i--)\n-{\n-  ++x;\n-  *x = i;\n-}\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*malloc region.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "7491fed7c1f2faf24ccc0019afaa7879f5f7dccc", "filename": "libmudflap/testsuite/libmudflap.c/fail12-frag.c", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail12-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail12-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail12-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,20 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int *y;\n-int main ()\n-{\n-int i = 10;\n-int *x = (int *) malloc (i * sizeof (int));\n-y = x;\n-while (i--)\n-{\n-  ++x;\n-  *x = i;\n-}\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*malloc region.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "9fd3e255712986460b46e4a36dd4a007e9250105", "filename": "libmudflap/testsuite/libmudflap.c/fail13-frag.c", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail13-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail13-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail13-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,26 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-struct a {\n-  int x;\n-  int y;\n-  char z;\n-};\n-\n-struct b {\n-  int x;\n-  int y;\n-};\n-\n-struct b k;\n-\n-(*((volatile struct a *) &k)).z = 'q';\n-\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1..check/write.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*.main. k.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "e66cc94c49b730a712055e33a384c48243870427", "filename": "libmudflap/testsuite/libmudflap.c/fail14-frag.c", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail14-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail14-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail14-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,29 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-struct a {\n-  int x;\n-  int y;\n-  char z;\n-};\n-\n-struct b {\n-  int x;\n-  int y;\n-};\n-\n-volatile struct b k;\n-volatile struct a *p;\n-\n-p = (struct a*) &k;\n-\n-p->z = 'q';\n-\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*.main. k.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "5d7ae744973a71b1f083f89644bb0ad450f55bf9", "filename": "libmudflap/testsuite/libmudflap.c/fail15-frag.c", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail15-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail15-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail15-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,27 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-struct base {\n-  int basic;\n-}; \n-\n-struct derived { \n-  struct base common;\n-  char extra;\n-};\n-\n-volatile struct base b;\n-volatile struct base *bp;\n-\n-bp = (struct base *)&b;\n-\n-bp->basic = 10;\n-((struct derived volatile *)bp)->extra = 'x';\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*.main. b.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "6ac6187e2ad4919df1680f7bbc236625ed4edd05", "filename": "libmudflap/testsuite/libmudflap.c/fail16-frag.c", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail16-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail16-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail16-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,27 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-void *p;\n-int main ()\n-{\n-struct base {\n-  int basic;\n-}; \n-\n-struct derived { \n-  struct base common;\n-  char extra;\n-};\n-\n-struct base *bp;\n-\n-bp = (struct base *) malloc (sizeof (struct base));;\n-p = bp;\n-bp->basic = 10;\n-((struct derived *)bp)->extra = 'x';\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*.malloc region.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "5af67f13858b9b2d1c00b065f343cb3479f46c43", "filename": "libmudflap/testsuite/libmudflap.c/fail17-frag.c", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail17-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail17-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail17-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,18 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-\n-char * x;\n-int foo;\n-x = (char *) malloc (10);\n-strcpy (x, \"123456789\");\n-foo = strlen (x+10);\n-x [foo] = 1; /* we just just use foo to force execution of strlen */\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*.malloc region.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "a7b62ddb7c7355480657ce3b5025919b7f306e7f", "filename": "libmudflap/testsuite/libmudflap.c/fail18-frag.c", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail18-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail18-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail18-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,16 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-/* One cannot redeclare __mf_lc_mask in proper C from instrumented\n-   code, because of the way the instrumentation code emits its decls.  */\n-extern unsigned foo __asm__ (\"__mf_lc_mask\");\n-unsigned * volatile bar = &foo;\n-*bar = 4;\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*.__mf_lc_mask.*no-access.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "7e446b40503dc8303af70d035a3e3f310a32c880", "filename": "libmudflap/testsuite/libmudflap.c/fail19-frag.c", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail19-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail19-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail19-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,18 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-struct foo {\n-  int bar [10];\n-};\n-\n-struct foo *k = (struct foo *) malloc (2 * sizeof(int));\n-k->bar[5] = 9;\n-free (k);\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*.malloc region.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "7672e60c6029dab130bb4c27a5b30b4584fcfdc0", "filename": "libmudflap/testsuite/libmudflap.c/fail2-frag.c", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail2-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail2-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail2-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,13 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-volatile int foo [10][10];\n-foo[10][0] = 0;\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*.main. foo.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "0dd8bb7f9832018bf31b0a6705fe760bc263baa6", "filename": "libmudflap/testsuite/libmudflap.c/fail20-frag.c", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail20-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail20-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail20-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,13 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-volatile char *p = (char *) 0;\n-*p = 5;\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*.NULL.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "4ab4a09f3b00e9675a6c745b4980fe53b930e10a", "filename": "libmudflap/testsuite/libmudflap.c/fail21-frag.c", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail21-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail21-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail21-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,18 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n- int *bar = (int *) malloc (sizeof (int));\n-/* Make an access here to get &foo into the lookup cache.  */\n-*bar = 5;\n-__mf_watch (bar, sizeof(int));\n-/* This access should trigger the watch violation.  */\n-*bar = 10;\n-/* NOTREACHED */\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*watch.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*malloc region.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "7dd7103d359e6cb1bbd080e04270ac5c04489731", "filename": "libmudflap/testsuite/libmudflap.c/fail22-frag.c", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail22-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail22-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail22-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,17 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-struct boo { int a; };\n-int c;\n-struct boo *b = malloc (sizeof (struct boo));\n-__mf_set_options (\"-check-initialization\");\n-c = b->a;\n-(void) malloc (c); /* some dummy use of c */\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*.malloc region.*1r/0w.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "bb1b52ec7e08a9459f0f52d68e3f21ad272bdc13", "filename": "libmudflap/testsuite/libmudflap.c/fail23-frag.c", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail23-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail23-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail23-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,16 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-char zoo [10];\n-\n-int main ()\n-{\n-int i = strlen (\"012345\") + strlen (\"6789\") + strlen (\"01\"); /* 11 */\n-zoo[i] = 'a';\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object.*\" } */\n-/* { dg-output \"mudflap object.*zoo.*static.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "acac5236b42ce462005e3aa24dafa4de1f2b397e", "filename": "libmudflap/testsuite/libmudflap.c/fail25-frag.c", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail25-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail25-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail25-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,18 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-char *foo;\n-char *bar;\n-__mf_set_options (\"-check-initialization\");\n-foo = (char *)malloc (10);\n-bar = (char *)malloc (10);\n-/* bar[2] = 'z'; */ /* don't touch memcpy source */\n-memcpy(foo+1, bar+1, 9);\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*check.read.*memcpy source.*\" } */\n-/* { dg-output \"Nearby object.*\" } */\n-/* { dg-output \"mudflap object.*malloc region.*alloc time.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "88484d6adc44e51688ce990aab4ef41d5b50fefc", "filename": "libmudflap/testsuite/libmudflap.c/fail26-frag.c", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail26-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail26-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail26-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,24 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-char *foo;\n-\n-__mf_set_options (\"-check-initialization\");\n-foo = (char *)malloc (1);\n-\n-/* These two operations each expand to a read-modify-write.\n- * Even though the end result is that every bit of foo[0] is\n- * eventually written to deterministically, the first read\n- * triggers an uninit error.  Ideally, it shouldn't, so this\n- * should be treated more like a regular XFAIL.  */\n-foo[0] &= 0xfe;\n-foo[0] |= 0x01;\n-\n-return foo[0];\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object.*\" } */\n-/* { dg-output \"mudflap object.*malloc region.*1r/0w.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "547c5e7a6ade1f1bd48b7a3e55c9dc74b24da436", "filename": "libmudflap/testsuite/libmudflap.c/fail27-frag.c", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail27-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail27-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail27-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,24 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-char volatile *\n-__attribute__((noinline))\n-foo (unsigned i)\n-{\n-  char volatile buffer[10];\n-  char volatile *k = i ? & buffer[i] : NULL; /* defeat addr-of-local-returned warning */\n-  return k;\n-}\n-\n-int main ()\n-{\n-char volatile *f = foo (5);\n-f[0] = 'b';\n-\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object.*\" } */\n-/* { dg-output \"mudflap dead object.*buffer.*alloc.*dealloc\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "7d61c57f34b66eaba67dbb6afa13ba429500b07c", "filename": "libmudflap/testsuite/libmudflap.c/fail28-frag.c", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail28-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail28-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail28-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,18 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-int foo (int *u, int i)\n-{\n-   return u[i];  /* this dereference should be instrumented */\n-}\n-\n-int main ()\n-{\n-int *k = malloc (6);\n-return foo (k, 8);\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object.*\" } */\n-/* { dg-output \"mudflap object.*malloc region.*alloc\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "2024064dc73e9eadcf91d20a3a4835146c90fa8b", "filename": "libmudflap/testsuite/libmudflap.c/fail29-frag.c", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail29-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail29-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail29-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,17 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-\n-int foo (int u[10])\n-{\n-   return u[8];  /* this dereference should be instrumented */\n-}\n-\n-int main ()\n-{\n-int *k = malloc (6);\n-return foo (k);\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object.*\" } */\n-/* { dg-output \"mudflap object.*malloc region.*alloc\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "98c1dbae165e55a59bcd1757f91472adec7c1194", "filename": "libmudflap/testsuite/libmudflap.c/fail3-frag.c", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail3-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail3-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail3-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,13 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-volatile int foo [10][10][10];\n-foo[9][10][0] = 0;\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*.main. foo.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "8bfea61cbb2aa83747a148d4830b35a3200d39b3", "filename": "libmudflap/testsuite/libmudflap.c/fail30-frag.c", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail30-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail30-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail30-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,18 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-\n-int foo (int u)\n-{\n-   return u*u;\n-}\n-\n-int main ()\n-{\n-int *k = malloc(5);\n-int j = foo (k[8]);  /* this call argument should be instrumented */\n-return j;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object.*\" } */\n-/* { dg-output \"mudflap object.*malloc region.*alloc\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "138c8ccba1cea4d93e029a92ffcb391ed341f409", "filename": "libmudflap/testsuite/libmudflap.c/fail31-frag.c", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail31-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail31-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail31-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,24 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-\n-extern int h (int i, int j);\n-\n-int main ()\n-{\n-  int z = h (4, 10);\n-  return 0;\n-}\n-int *p;\n-__attribute__((noinline))\n-int h (int i, int j)\n-{\n-  int k[i];\n-  k[j] = i;\n-  p = k;\n-  return j;\n-}\n-\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object.*\" } */\n-/* { dg-output \"mudflap object.*\\(h\\).*k\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "2a38237b678c80eafb02a1006be30a44fd828e65", "filename": "libmudflap/testsuite/libmudflap.c/fail32-frag.c", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail32-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail32-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail32-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,16 +0,0 @@\n-void foo (int k)\n-{\n-  volatile int *b = & k;\n-  b++;\n-  *b = 5;\n-}\n-\n-int main ()\n-{\n-  foo (5);\n-  return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object.*\" } */\n-/* { dg-output \"mudflap object.*k\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "ac7c617a4ebb72bf828da10ecb4d291e76a43594", "filename": "libmudflap/testsuite/libmudflap.c/fail33-frag.c", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail33-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail33-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail33-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,25 +0,0 @@\n-#include <stdlib.h>\n-\n-#define SIZE 16\n-\n-char b[SIZE];\n-char a[SIZE];\n-\n-int main ()\n-{\n-  int i, j=0, k;\n-  int a_before_b = (& a[0] < & b[0]);\n-  /* Rather than iterating linearly, which would allow loop unrolling\n-     and mapping to pointer manipulation, we traverse the \"joined\"\n-     arrays in some random order.  */\n-  for (i=0; i<SIZE*2; i++)\n-    {\n-      k = rand() % (SIZE*2);\n-      j += (a_before_b ? a[k] : b[k]);\n-    }\n-  return j;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object.*\" } */\n-/* { dg-output \"mudflap object.*\\[ab\\]\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "f6572b019a4f382055857d09a2685b79dfa7ec91", "filename": "libmudflap/testsuite/libmudflap.c/fail34-frag.c", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail34-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail34-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail34-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,22 +0,0 @@\n-#include <stdlib.h>\n-\n-struct s\n-{\n-  int a1[4];\n-};\n-\n-struct s a, b;\n-int idx = 7; /* should pass to the next object */\n-\n-int\n-main ()\n-{\n-  int i, j=0;\n-  int a_before_b = (& a < & b);\n-  j = (a_before_b ? a.a1[idx] : b.a1[idx]);\n-  return j;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object.*\" } */\n-/* { dg-output \"mudflap object.*\\[ab\\]\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "101fe293b2bc6df5c3efde4d4295c30b664cec9f", "filename": "libmudflap/testsuite/libmudflap.c/fail35-frag.c", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail35-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail35-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail35-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,23 +0,0 @@\n-#include <stdlib.h>\n-\n-struct k\n-{\n-  int p;\n-  struct {\n-    int m;\n-  } q;\n-};\n-\n-int\n-main ()\n-{\n-  volatile struct k *l = malloc (sizeof (int)); /* make it only big enough for k.p */\n-  /* Confirm that we instrument this nested construct\n-     COMPONENT_REF(COMPONENT_REF(INDIRECT_REF)). */\n-  l->q.m = 5;\n-  return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object.*\" } */\n-/* { dg-output \"mudflap object.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "af6851c1d237d05e34575e2af39857cfaabe9a45", "filename": "libmudflap/testsuite/libmudflap.c/fail36-frag.c", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail36-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail36-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail36-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,23 +0,0 @@\n-#include <stdlib.h>\n-\n-struct k\n-{\n-  int p;\n-  struct {\n-    int m : 31;\n-  } q;\n-};\n-\n-int\n-main ()\n-{\n-  volatile struct k *l = malloc (sizeof (int)); /* make it only big enough for k.p */\n-  /* Confirm that we instrument this nested construct\n-     BIT_FIELD_REF(COMPONENT_REF(INDIRECT_REF)). */\n-  l->q.m = 5;\n-  return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object.*\" } */\n-/* { dg-output \"mudflap object.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "38dbde56a814c3edfa234363637ef4ac29efcbc0", "filename": "libmudflap/testsuite/libmudflap.c/fail37-frag.c", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail37-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail37-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail37-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,26 +0,0 @@\n-typedef struct\n-{\n-  short f : 3;\n-} small;\n-\n-struct\n-{\n-  int i;\n-  small s[4];\n-} x;\n-\n-main ()\n-{\n-  int i;\n-  for (i = 0; i < 5; i++)\n-    {\n-      /* Optimization barrier.  Prevent gcc from seeing the undefined behavior.  */\n-      __asm (\"\" : \"+r\" (i));\n-      x.s[i].f = 0;\n-    }\n-  exit (0);\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object.*\" } */\n-/* { dg-output \"mudflap object.* x.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "9667e213418aa41ca59aef696973eacaa490160b", "filename": "libmudflap/testsuite/libmudflap.c/fail38-frag.c", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail38-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail38-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail38-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,29 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-struct a {\n-  int x;\n-  int y;\n-  int z : 10;\n-};\n-\n-struct b {\n-  int x;\n-  int y;\n-};\n-\n-volatile struct b k;\n-volatile struct a *p;\n-\n-p = (struct a*) &k;\n-\n-p->z = 'q';\n-\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*.main. k.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "4e74ea5cd5eb3762251d419e7f2cfb4fc8cea100", "filename": "libmudflap/testsuite/libmudflap.c/fail39-frag.c", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail39-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail39-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail39-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,20 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-\n-int main ()\n-{\n-  volatile int *k = (int *) malloc (sizeof (int));\n-  volatile int l;\n-  if (k == NULL) abort ();\n-  *k = 5;\n-  free ((void *) k);\n-  __mf_set_options (\"-ignore-reads\");\n-  l = *k; /* Should not trip, even though memory region just freed.  */\n-  __mf_set_options (\"-no-ignore-reads\");\n-  l = *k; /* Should trip now.  */\n-  return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*check/read.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap dead object.*malloc region.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "a3423e6c36b7592e9c4b570fb039533718902d0b", "filename": "libmudflap/testsuite/libmudflap.c/fail4-frag.c", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail4-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail4-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail4-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,13 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-char foo [10];\n-strcpy(foo, \"1234567890\");\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*.main. foo.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "fbeb6fd21d38699c064cd674ab10d12fc5871494", "filename": "libmudflap/testsuite/libmudflap.c/fail40-frag.c", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail40-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail40-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail40-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,59 +0,0 @@\n-/* Test proper lookup-uncaching of large objects */\n-#include \"../config.h\"\n-\n-#include <unistd.h>\n-#include <string.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#ifdef HAVE_SYS_MMAN_H\n-#include <sys/mman.h>\n-#endif\n-\n-int main ()\n-{\n-#ifndef MAP_ANONYMOUS\n-#define MAP_ANONYMOUS MAP_ANON\n-#endif\n-#ifndef MAP_FAILED\n-#define MAP_FAILED ((void *)-1)\n-#endif\n-#ifdef HAVE_MMAP\n-  volatile unsigned char *p;\n-  unsigned num = getpagesize ();\n-  unsigned i;\n-  int rc;\n-\n-  /* Get a bit of usable address space.  We really want an 2**N+1-sized object,\n-     so the low/high addresses wrap when hashed into the lookup cache.  So we\n-     will manually unregister the entire mmap, then re-register a slice.  */\n-  p = mmap (NULL, num, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n-  if (p == MAP_FAILED)\n-    return 1;\n-  /* Now unregister it, as if munmap was called.  But don't actually munmap, so\n-     we can write into the memory.  */\n-  __mf_unregister ((void *) p, num, __MF_TYPE_HEAP_I);\n-\n-  /* Now register it under a slightly inflated, 2**N+1 size.  */\n-  __mf_register ((void *) p, num+1, __MF_TYPE_HEAP_I, \"fake mmap registration\");\n-\n-  /* Traverse array to ensure that entire lookup cache is made to point at it.  */\n-  for (i=0; i<num; i++)\n-    p[i] = 0;\n-\n-  /* Unregister it.  This should clear the entire lookup cache, even though\n-     hash(low) == hash (high)  (and probably == 0) */\n-  __mf_unregister ((void *) p, num+1, __MF_TYPE_HEAP_I);\n-\n-  /* Now touch the middle portion of the ex-array.  If the lookup cache was\n-     well and truly cleaned, then this access should trap.  */\n-  p[num/2] = 1;\n-\n-  return 0;\n-#else\n-  return 1;\n-#endif\n-}\n-/* { dg-output \"mudflap violation 1.*check/write.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap dead object.*fake mmap registration.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "a08569fe7739b68fda3a76bef99fe59de39b5ed3", "filename": "libmudflap/testsuite/libmudflap.c/fail5-frag.c", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail5-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail5-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail5-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,14 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-char foo [15];\n-char bar [10];\n-memcpy(foo, bar, 11);\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*.main. bar.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "1904a88711ae1355db9c3319d698e039f064bd58", "filename": "libmudflap/testsuite/libmudflap.c/fail6-frag.c", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail6-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail6-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail6-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,17 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-char *foo;\n-char *bar;\n-foo = (char *)malloc (10);\n-bar = (char *)malloc (15);\n-\n-memcpy(foo, bar, 11);\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*malloc region.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "7b2f8cf2cb04aeb4a3e0c4448958dc60b2878849", "filename": "libmudflap/testsuite/libmudflap.c/fail68-frag.c", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail68-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail68-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail68-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,27 +0,0 @@\n-/* PR libmudflap/40778 */\n-\n-char p[32];\n-static int j;\n-\n-__attribute__((noinline))\n-static void foo (int i)\n-{\n-  if (j++ == 0)\n-    p[i + 4] = 12;\n-  else\n-    p[i - 4] = 13;\n-}\n-\n-int\n-main ()\n-{\n-  foo (30);\n-  foo (30);\n-  foo (30);\n-  return 0;\n-}\n-\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*name.*p\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "580d045386d8dcd48c07250e3361240104b4afd4", "filename": "libmudflap/testsuite/libmudflap.c/fail7-frag.c", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail7-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail7-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail7-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,17 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-char *foo;\n-char *bar;\n-foo = (char *)malloc (12);\n-bar = (char *)malloc (10);\n-\n-memcpy(foo+1, bar+1, 10);\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*\" } */\n-/* { dg-output \"Nearby object 1.*\" } */\n-/* { dg-output \"mudflap object.*malloc region.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "8309068df474f94f9e3805bcdc595b4c7defd434", "filename": "libmudflap/testsuite/libmudflap.c/fail8-frag.c", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail8-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail8-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail8-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,19 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-char *foo;\n-char *bar;\n-foo = (char *)malloc (10);\n-bar = (char *)malloc (10);\n-\n-free(bar);\n-\n-memcpy(foo, bar, 10);\n-return 0;\n-}\n-/* { dg-output \"mudflap violation 1.*memcpy source.*\" } */\n-/* { dg-output \"Nearby object.*\" } */\n-/* { dg-output \"mudflap dead object.*malloc region.*alloc time.*dealloc time.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "9bbd860a898e8e5b3efa40e5ee362b7b844d0190", "filename": "libmudflap/testsuite/libmudflap.c/fail9-frag.c", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail9-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail9-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Ffail9-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,21 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-char *foo;\n-char *bar;\n-foo = (char *)malloc (10);\n-bar = (char *)malloc (10);\n-\n-free(foo);\n-\n-bar[4] = 'a'; /* touch source buffer */\n-memcpy(foo, bar, 10);\n-return 0;\n-}\n-\n-/* { dg-output \"mudflap violation 1.*memcpy dest.*\" } */\n-/* { dg-output \"Nearby object.*\" } */\n-/* { dg-output \"mudflap dead object.*malloc region.*alloc time.*dealloc time.*\" } */\n-/* { dg-do run { xfail *-*-* } } */"}, {"sha": "6e7813ba2aca0b976c13367e632e6fee78419d24", "filename": "libmudflap/testsuite/libmudflap.c/heap-scalestress.c", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fheap-scalestress.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fheap-scalestress.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fheap-scalestress.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,79 +0,0 @@\n-/* zz30\n- *\n- * demonstrate a splay-tree depth problem\n-*/\n-\n-#include <stdlib.h>\n-#include <stdio.h>\n-#include <unistd.h>\n-\n-#ifndef SCALE\n-#define SCALE 10000\n-#endif\n-\n-\n-struct list\n-{\n-  struct list *next;\n-};\n-\n-\n-int\n-main ()\n-{\n-  struct list *head = NULL;\n-  struct list *tail = NULL;\n-  struct list *p;\n-  long n;\n-  int direction;\n-\n-  for (direction = 0; direction < 2; direction++)\n-    {\n-      fprintf (stdout, \"allocating\\n\");\n-      fflush (stdout);\n-\n-      for (n = 0; n < SCALE; ++n)\n-\t{\n-\t  p = malloc (sizeof *p);\n-\t  if (NULL == p)\n-\t    {\n-\t      fprintf (stdout, \"malloc failed\\n\");\n-\t      break;\n-\t    }\n-\t  if (direction == 0)\n-\t    {\t\t\t/* add at tail */\n-\t      p->next = NULL;\n-\t      if (NULL != tail)\n-\t\ttail->next = p;\n-\t      else\n-\t\thead = p;\n-\t      tail = p;\n-\t    }\n-\t  else\n-\t    {\t\t\t/* add at head */\n-\t      p->next = head;\n-\t      if (NULL == tail)\n-\t\ttail = p;\n-\t      head = p;\n-\t    }\n-\t}\n-\n-      fprintf (stdout, \"freeing\\n\");\n-      fflush (stdout);\n-\n-      while (NULL != head)\n-\t{\n-\t  p = head;\n-\t  head = head->next;\n-\t  free (p);\n-\t}\n-\n-    }\n-\n-  fprintf (stdout, \"done\\n\");\n-  fflush (stdout);\n-\n-  return (0);\n-}\n-\n-/* { dg-output \"allocating.*freeing.*allocating.*freeing.*done\" } */"}, {"sha": "dc25375488d1b120898046fc244ab950ce072ffb", "filename": "libmudflap/testsuite/libmudflap.c/hook-allocstuff.c", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fhook-allocstuff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fhook-allocstuff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fhook-allocstuff.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,16 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-\n-int main ()\n-{\n-  char *foo = (char *) malloc (10);\n-  strcpy (foo, \"hello\");\n-  foo = (char *) realloc (foo, 20);\n-  printf (\"%s\", foo);\n-  if (strcmp (foo, \"hello\"))\n-    abort ();\n-  free (foo);\n-  printf (\" world\\n\");\n-  return 0;\n-}\n-/* { dg-output \"hello world\" } */"}, {"sha": "d8fbec4676da55c4d04111800a8222591357171c", "filename": "libmudflap/testsuite/libmudflap.c/hook2-allocstuff.c", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fhook2-allocstuff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fhook2-allocstuff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fhook2-allocstuff.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,9 +0,0 @@\n-/* Generates recursive malloc call on i386-freebsd4.10 with -fmudflap.  */\n-#include <stdlib.h>\n-\n-int\n-main (void)\n-{\n-  char *p = malloc (1<<24);\n-  return 0;\n-}"}, {"sha": "cf5430657ff949dba2052e937359e1f9282076fd", "filename": "libmudflap/testsuite/libmudflap.c/pass-stratcliff.c", "status": "removed", "additions": 0, "deletions": 326, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass-stratcliff.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass-stratcliff.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass-stratcliff.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,326 +0,0 @@\n-/* Test for string function add boundaries of usable memory.\n-   Copyright (C) 1996, 1997, 1999, 2000, 2001, 2002, 2011\n-   Free Software Foundation, Inc.\n-   This file is part of the GNU C Library.\n-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.\n-\n-   The GNU C Library is free software; you can redistribute it and/or\n-   modify it under the terms of the GNU Lesser General Public\n-   License as published by the Free Software Foundation; either\n-   version 2.1 of the License, or (at your option) any later version.\n-\n-   The GNU C Library is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-   Lesser General Public License for more details.\n-\n-   You should have received a copy of the GNU Lesser General Public\n-   License along with the GNU C Library; if not, write to the Free\n-   Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-   02110-1301 USA.  */\n-\n-#define _GNU_SOURCE 1\n-#define __USE_GNU\n-\n-/* Make sure we don't test the optimized inline functions if we want to\n-   test the real implementation.  */\n-#undef __USE_STRING_INLINES\n-\n-#include \"../config.h\"\n-\n-#include <errno.h>\n-#include <stdio.h>\n-#include <string.h>\n-#include <unistd.h>\n-#include <sys/mman.h>\n-#include <sys/param.h>\n-\n-#ifndef MAX\n-#define MAX(a, b) ((a) > (b) ? (a) : (b))\n-#endif\n-\n-#ifndef MIN\n-#define MIN(a, b) ((a) < (b) ? (a) : (b))\n-#endif\n-\n-int\n-main (int argc, char *argv[])\n-{\n-  int size = sysconf (_SC_PAGESIZE);\n-  char *adr, *dest;\n-  int result = 0;\n-\n-  adr = (char *) mmap (NULL, 3 * size, PROT_READ | PROT_WRITE,\n-\t\t       MAP_PRIVATE | MAP_ANON, -1, 0);\n-  dest = (char *) mmap (NULL, 3 * size, PROT_READ | PROT_WRITE,\n-\t\t\tMAP_PRIVATE | MAP_ANON, -1, 0);\n-  if (adr == MAP_FAILED || dest == MAP_FAILED)\n-    {\n-      if (errno == ENOSYS)\n-        puts (\"No test, mmap not available.\");\n-      else\n-        {\n-          printf (\"mmap failed: %m\");\n-          result = 1;\n-        }\n-    }\n-  else\n-    {\n-      int inner, middle, outer;\n-\n-      mprotect(adr, size, PROT_NONE);\n-      mprotect(adr + 2 * size, size, PROT_NONE);\n-      adr += size;\n-\n-      mprotect(dest, size, PROT_NONE);\n-      mprotect(dest + 2 * size, size, PROT_NONE);\n-      dest += size;\n-\n-      memset (adr, 'T', size);\n-\n-      /* strlen test */\n-      for (outer = size - 1; outer >= MAX (0, size - 128); --outer)\n-        {\n-          for (inner = MAX (outer, size - 64); inner < size; ++inner)\n-\t    {\n-\t      adr[inner] = '\\0';\n-\n-\t      if (strlen (&adr[outer]) != (size_t) (inner - outer))\n-\t\t{\n-\t\t  printf (\"strlen flunked for outer = %d, inner = %d\\n\",\n-\t\t\t  outer, inner);\n-\t\t  result = 1;\n-\t\t}\n-\n-\t      adr[inner] = 'T';\n-\t    }\n-        }\n-\n-      /* strchr test */\n-      for (outer = size - 1; outer >= MAX (0, size - 128); --outer)\n-        {\n-\t  for (middle = MAX (outer, size - 64); middle < size; ++middle)\n-\t    {\n-\t      for (inner = middle; inner < size; ++inner)\n-\t\t{\n-\t\t  char *cp;\n-\t\t  adr[middle] = 'V';\n-\t\t  adr[inner] = '\\0';\n-\n-\t\t  cp = strchr (&adr[outer], 'V');\n-\n-\t\t  if ((inner == middle && cp != NULL)\n-\t\t      || (inner != middle\n-\t\t\t  && (cp - &adr[outer]) != middle - outer))\n-\t\t    {\n-\t\t      printf (\"strchr flunked for outer = %d, middle = %d, \"\n-\t\t\t      \"inner = %d\\n\", outer, middle, inner);\n-\t\t      result = 1;\n-\t\t    }\n-\n-\t\t  adr[inner] = 'T';\n-\t\t  adr[middle] = 'T';\n-\t\t}\n-\t    }\n-        }\n-\n-      /* Special test.  */\n-      adr[size - 1] = '\\0';\n-      if (strchr (&adr[size - 1], '\\n') != NULL)\n-\t{\n-\t  puts (\"strchr flunked for test of empty string at end of page\");\n-\t  result = 1;\n-\t}\n-\n-      /* strrchr test */\n-      for (outer = size - 1; outer >= MAX (0, size - 128); --outer)\n-        {\n-\t  for (middle = MAX (outer, size - 64); middle < size; ++middle)\n-\t    {\n-\t      for (inner = middle; inner < size; ++inner)\n-\t\t{\n-\t\t  char *cp;\n-\t\t  adr[middle] = 'V';\n-\t\t  adr[inner] = '\\0';\n-\n-\t\t  cp = strrchr (&adr[outer], 'V');\n-\n-\t\t  if ((inner == middle && cp != NULL)\n-\t\t      || (inner != middle\n-\t\t\t  && (cp - &adr[outer]) != middle - outer))\n-\t\t    {\n-\t\t      printf (\"strrchr flunked for outer = %d, middle = %d, \"\n-\t\t\t      \"inner = %d\\n\", outer, middle, inner);\n-\t\t      result = 1;\n-\t\t    }\n-\n-\t\t  adr[inner] = 'T';\n-\t\t  adr[middle] = 'T';\n-\t\t}\n-\t    }\n-        }\n-\n-#ifdef HAVE_RAWMEMCHR\n-      /* rawmemchr test */\n-      for (outer = size - 1; outer >= MAX (0, size - 128); --outer)\n-        {\n-\t  for (middle = MAX (outer, size - 64); middle < size; ++middle)\n-\t    {\n-\t      char *cp;\n-\t      adr[middle] = 'V';\n-\n-\t      cp = (char *) rawmemchr (&adr[outer], 'V');\n-\n-\t      if (cp - &adr[outer] != middle - outer)\n-\t\t{\n-\t\t  printf (\"rawmemchr flunked for outer = %d, middle = %d\\n\",\n-\t\t\t  outer, middle);\n-\t\t  result = 1;\n-\t\t}\n-\n-\t      adr[middle] = 'T';\n-\t    }\n-        }\n-#endif\n-\n-      /* strcpy test */\n-      for (outer = size - 1; outer >= MAX (0, size - 128); --outer)\n-        {\n-          for (inner = MAX (outer, size - 64); inner < size; ++inner)\n-\t    {\n-\t      adr[inner] = '\\0';\n-\n-\t      if (strcpy (dest, &adr[outer]) != dest\n-\t\t  || strlen (dest) != (size_t) (inner - outer))\n-\t\t{\n-\t\t  printf (\"strcpy flunked for outer = %d, inner = %d\\n\",\n-\t\t\t  outer, inner);\n-\t\t  result = 1;\n-\t\t}\n-\n-\t      adr[inner] = 'T';\n-\t    }\n-        }\n-\n-      /* strncpy tests */\n-      adr[size-1] = 'T';\n-      for (outer = size - 1; outer >= MAX (0, size - 128); --outer)\n-\t{\n-\t  size_t len;\n-\n-\t  for (len = 0; len < size - outer; ++len)\n-\t    {\n-\t      if (strncpy (dest, &adr[outer], len) != dest\n-\t\t  || memcmp (dest, &adr[outer], len) != 0)\n-\t\t{\n-\t\t  printf (\"outer strncpy flunked for outer = %d, len = %Zd\\n\",\n-\t\t\t  outer, len);\n-\t\t  result = 1;\n-\t\t}\n-\t    }\n-        }\n-      adr[size-1] = '\\0';\n-\n-      for (outer = size - 1; outer >= MAX (0, size - 128); --outer)\n-        {\n-          for (inner = MAX (outer, size - 64); inner < size; ++inner)\n-\t    {\n-\t      size_t len;\n-\n-\t      adr[inner] = '\\0';\n-\n-\t      for (len = 0; len < size - outer + 64; ++len)\n-\t\t{\n-\t\t  if (strncpy (dest, &adr[outer], len) != dest\n-\t\t      || memcmp (dest, &adr[outer],\n-\t\t\t\t MIN (inner - outer, len)) != 0\n-\t\t      || (inner - outer < len\n-\t\t\t  && strlen (dest) != (inner - outer)))\n-\t\t    {\n-\t\t      printf (\"strncpy flunked for outer = %d, inner = %d, len = %Zd\\n\",\n-\t\t\t      outer, inner, len);\n-\t\t      result = 1;\n-\t\t    }\n-\t\t  if (strncpy (dest + 1, &adr[outer], len) != dest + 1\n-\t\t      || memcmp (dest + 1, &adr[outer],\n-\t\t\t\t MIN (inner - outer, len)) != 0\n-\t\t      || (inner - outer < len\n-\t\t\t  && strlen (dest + 1) != (inner - outer)))\n-\t\t    {\n-\t\t      printf (\"strncpy+1 flunked for outer = %d, inner = %d, len = %Zd\\n\",\n-\t\t\t      outer, inner, len);\n-\t\t      result = 1;\n-\t\t    }\n-\t\t}\n-\n-\t      adr[inner] = 'T';\n-\t    }\n-        }\n-\n-#ifdef HAVE_STPCPY\n-      /* stpcpy test */\n-      for (outer = size - 1; outer >= MAX (0, size - 128); --outer)\n-        {\n-          for (inner = MAX (outer, size - 64); inner < size; ++inner)\n-\t    {\n-\t      adr[inner] = '\\0';\n-\n-\t      if ((stpcpy (dest, &adr[outer]) - dest) != inner - outer)\n-\t\t{\n-\t\t  printf (\"stpcpy flunked for outer = %d, inner = %d\\n\",\n-\t\t\t  outer, inner);\n-\t\t  result = 1;\n-\t\t}\n-\n-\t      adr[inner] = 'T';\n-\t    }\n-        }\n-\n-      /* stpncpy test */\n-      for (outer = size - 1; outer >= MAX (0, size - 128); --outer)\n-        {\n-          for (middle = MAX (outer, size - 64); middle < size; ++middle)\n-\t    {\n-\t      adr[middle] = '\\0';\n-\n-\t      for (inner = 0; inner < size - outer; ++ inner)\n-\t\t{\n-\t\t  if ((stpncpy (dest, &adr[outer], inner) - dest)\n-\t\t      != MIN (inner, middle - outer))\n-\t\t    {\n-\t\t      printf (\"stpncpy flunked for outer = %d, middle = %d, \"\n-\t\t\t      \"inner = %d\\n\", outer, middle, inner);\n-\t\t      result = 1;\n-\t\t    }\n-\t\t}\n-\n-\t      adr[middle] = 'T';\n-\t    }\n-        }\n-#endif\n-\n-      /* memcpy test */\n-      for (outer = size - 1; outer >= MAX (0, size - 128); --outer)\n-\tfor (inner = 0; inner < size - outer; ++inner)\n-\t  if (memcpy (dest, &adr[outer], inner) !=  dest)\n-\t    {\n-\t      printf (\"memcpy flunked for outer = %d, inner = %d\\n\",\n-\t\t      outer, inner);\n-\t      result = 1;\n-\t    }\n-\n-#ifdef HAVE_MEMPCPY\n-      /* mempcpy test */\n-      for (outer = size - 1; outer >= MAX (0, size - 128); --outer)\n-\tfor (inner = 0; inner < size - outer; ++inner)\n-\t  if (mempcpy (dest, &adr[outer], inner) !=  dest + inner)\n-\t    {\n-\t      printf (\"mempcpy flunked for outer = %d, inner = %d\\n\",\n-\t\t      outer, inner);\n-\t      result = 1;\n-\t    }\n-#endif\n-    }\n-\n-  return result;\n-}"}, {"sha": "40f629b56da062869702be7b0084f1c92873e1bc", "filename": "libmudflap/testsuite/libmudflap.c/pass1-frag.c", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass1-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass1-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass1-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,9 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-int foo [10];\n-foo[9] = 0;\n-return 0;\n-}"}, {"sha": "f05650da5150ece8348ae5f8b8d924782bf61bce", "filename": "libmudflap/testsuite/libmudflap.c/pass10-frag.c", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass10-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass10-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass10-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,12 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-int foo[10];\n-int sz = sizeof (int);\n-\n-char *bar = (char *)foo;\n-bar [sz * 9] = 0;\n-return 0;\n-}"}, {"sha": "ab7ee38c4f8b4757d7f8621791e92ad5aec80469", "filename": "libmudflap/testsuite/libmudflap.c/pass11-frag.c", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass11-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass11-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass11-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,15 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-int i = 10;\n-char *x = (char *) malloc (i * sizeof (char));\n-\n-while (--i)\n-{\n-  ++x;\n-  *x = 0;\n-}\n-return 0;\n-}"}, {"sha": "53630d9971d6b0f185d07b8e9157b01f1371cab3", "filename": "libmudflap/testsuite/libmudflap.c/pass12-frag.c", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass12-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass12-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass12-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,15 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-int i = 10;\n-int *x = (int *) malloc (i * sizeof (int));\n-\n-while (--i)\n-{\n-  ++x;\n-  *x = 0;\n-}\n-return 0;\n-}"}, {"sha": "c2b820d0f43ffa9af080931e1b3bbd2dc80b788d", "filename": "libmudflap/testsuite/libmudflap.c/pass13-frag.c", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass13-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass13-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass13-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,17 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-struct a {\n-  int x;\n-  int y;\n-  char z;\n-};\n-\n-struct a k;\n-\n-k.z = 'q';\n-\n-return 0;\n-}"}, {"sha": "264564329798ccbe3df615d39b487da8ec5210ad", "filename": "libmudflap/testsuite/libmudflap.c/pass14-frag.c", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass14-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass14-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass14-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,20 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-struct a {\n-  int x;\n-  int y;\n-  char z;\n-};\n-\n-struct a k;\n-struct a *p;\n-\n-p = &k;\n-\n-p->z = 'q';\n-\n-return 0;\n-}"}, {"sha": "5e1fee8eb9c9aa5675cf92566d0f3efe5d3f2b6d", "filename": "libmudflap/testsuite/libmudflap.c/pass15-frag.c", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass15-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass15-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass15-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,23 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-struct base {\n-  int basic;\n-}; \n-\n-struct derived { \n-  struct base common;\n-  char extra;\n-};\n-\n-struct derived d;\n-struct base *bp;\n-\n-bp = (struct base *)&d;\n-\n-bp->basic = 10;\n-((struct derived *)bp)->extra = 'x';\n-return 0;\n-}"}, {"sha": "99ede3f2138c79ff6e06d81ef71c1dfa004fee79", "filename": "libmudflap/testsuite/libmudflap.c/pass16-frag.c", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass16-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass16-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass16-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,22 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-struct base {\n-  int basic;\n-}; \n-\n-struct derived { \n-  struct base common;\n-  char extra;\n-};\n-\n-struct base *bp;\n-\n-bp = (struct base *) malloc (sizeof (struct derived));\n-\n-bp->basic = 10;\n-((struct derived *)bp)->extra = 'x';\n-return 0;\n-}"}, {"sha": "b840dc9874648c602df13488d9eddfb900bb8e43", "filename": "libmudflap/testsuite/libmudflap.c/pass17-frag.c", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass17-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass17-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass17-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,9 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-\n-strlen(\"123456789\");\n-return 0;\n-}"}, {"sha": "c5d5af0fe120f34a630000a55d29d7569e303534", "filename": "libmudflap/testsuite/libmudflap.c/pass18-frag.c", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass18-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass18-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass18-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,27 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-int t;\n-char foo[3] = { 'b', 'c', 'd' };\n-int bar[3] = {1, 2, 0};\n-t = 1;\n-\n-/* These tests check expression evaluation rules, such as\n-   ensuring that side-effect expression (++) get executed the\n-   right number of times; that array lookup checks nest correctly. */\n-foo[t++] = 'a';\n-if (foo[0] != 'b' || foo[1] != 'a' || foo[2] != 'd' || t != 2) abort ();\n-if (bar[0] != 1 || bar[1] != 2 || bar[2] != 0) abort();\n-\n-foo[bar[t--]] = 'e';\n-if (foo[0] != 'e' || foo[1] != 'a' || foo[2] != 'd' || t != 1) abort ();\n-if (bar[0] != 1 || bar[1] != 2 || bar[2] != 0) abort();\n-\n-foo[bar[++t]--] = 'g';\n-if (foo[0] != 'g' || foo[1] != 'a' || foo[2] != 'd' || t != 2) abort ();\n-if (bar[0] != 1 || bar[1] != 2 || bar[2] != -1) abort();\n-\n-return 0;\n-}"}, {"sha": "0b00845d412c3bfc7266c3dc34876b546d09287f", "filename": "libmudflap/testsuite/libmudflap.c/pass19-frag.c", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass19-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass19-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass19-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,11 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-struct foo {int base; char variable[1]; }; /* a common idiom for variable-size structs */\n-\n-struct foo * b = (struct foo *) malloc (sizeof (int)); /* enough for base */\n-b->base = 4;\n-return 0;\n-}"}, {"sha": "7e71e0cd7b5e309da972442d3ddbb6369dd652bb", "filename": "libmudflap/testsuite/libmudflap.c/pass2-frag.c", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass2-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass2-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass2-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,9 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-int foo [10][10];\n-foo[9][0] = 0;\n-return 0;\n-}"}, {"sha": "984311685486c8dfa58d0f04bfcc528e26db13d7", "filename": "libmudflap/testsuite/libmudflap.c/pass20-frag.c", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass20-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass20-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass20-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,13 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-struct bar {int stuff; int array[10]; };\n-\n-struct bar *foo = (struct bar *) malloc (sizeof (struct bar));\n-foo->array[5] = 4;\n-free (foo);\n-\n-return 0;\n-}"}, {"sha": "231055a236f19cb18ada5fdc868ffd91614e22cc", "filename": "libmudflap/testsuite/libmudflap.c/pass21-frag.c", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass21-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass21-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass21-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,15 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#ifndef __FreeBSD__\n-#include <alloca.h>\n-#endif\n-int main ()\n-{\n-char *boo, *foo;\n-boo = (char *) alloca (100);\n-boo[99] = 'a';\n-foo = (char *) __builtin_alloca (200);\n-foo[44] = 'b';\n-return 0;\n-}"}, {"sha": "b092ea0b277db01278e041d0e4c4fd443a600740", "filename": "libmudflap/testsuite/libmudflap.c/pass22-frag.c", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass22-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass22-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass22-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,23 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-struct foo {\n-  unsigned base:8;\n-  unsigned flag1:1;\n-  unsigned flag2:3;\n-  unsigned flag3:4;\n-  char nothing[0];\n-};\n-\n-#define offsetof(TYPE, MEMBER)\t((size_t) &((TYPE *) 0)->MEMBER)\n-\n-struct foo* f = (struct foo *) malloc (offsetof (struct foo, nothing));\n-f->base = 1;\n-f->flag1 = 1;\n-free (f);\n-\n-\n-return 0;\n-}"}, {"sha": "f27c223614b0f4d6ef18498b3e46706154eda577", "filename": "libmudflap/testsuite/libmudflap.c/pass23-frag.c", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass23-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass23-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass23-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,29 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-struct foo {\n-  int part1: 8;\n-  int nothing : 1;\n-  int part2 : 5;\n-  int lots_more_nothing : 3;\n-  int some_padding; /* for 64-bit hosts */\n-  float some_more_nothing;\n-  double yet_more_nothing;\n-};\n-\n-#define offsetof(TYPE, MEMBER)\t((size_t) &((TYPE *) 0)->MEMBER)\n-\n-struct foo* q = (struct foo *) malloc (offsetof (struct foo, some_more_nothing));\n-q->nothing = 1; /* touch q */ \n-/* The RHS of the following expression is meant to trigger a\n-   fold-const.c mapping the expression to a BIT_FIELD_REF.  It glues\n-   together the accesses to the two non-neighbouring bitfields into a\n-   single bigger boolean test. */\n-q->lots_more_nothing = (q->part1 == 13 && q->part2 == 7);\n-free (q);\n-\n-\n-return 0;\n-}"}, {"sha": "0038582213083a4525c95e8032f8ee628ebea387", "filename": "libmudflap/testsuite/libmudflap.c/pass24-frag.c", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass24-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass24-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass24-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,18 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-struct foo {\n-  int zoo;\n-  int bar [10];\n-  float baz;\n-};\n-\n-#define offsetof(S,F) ((size_t) & (((S *) 0)->F))\n-\n-struct foo *k = (struct foo *) malloc (offsetof (struct foo, bar[4]));\n-k->bar[1] = 9;\n-free (k);\n-return 0;\n-}"}, {"sha": "c5a75e3338e46372e294a0023b9c671b6869231a", "filename": "libmudflap/testsuite/libmudflap.c/pass25-frag.c", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass25-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass25-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass25-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,15 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-int *foo = malloc (10 * sizeof(int));\n-int *bar = & foo[3];\n-/* Watching occurs at the object granularity, which is in this case\n-   the entire array.  */\n-__mf_watch (& foo[1], sizeof(foo[1]));\n-__mf_unwatch (& foo[6], sizeof(foo[6]));\n-*bar = 10;\n-free (foo); \n-return 0;\n-}"}, {"sha": "5a72f5b790c5464371c4e4a191592961120e76c6", "filename": "libmudflap/testsuite/libmudflap.c/pass26-frag.c", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass26-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass26-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass26-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,52 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-volatile int *p;\n-\n-__mf_set_options (\"-wipe-stack -no-check-initialization\");\n-\n-{\n-  volatile int array [10];\n-  p = & array[0];\n-\n-  array[0] = 2;\n-  array[9] = 5;\n-\n-  /* Array[] should be wiped clean at this point.  */\n-}\n-\n-__mf_set_options (\"-no-wipe-stack\");\n-\n-{ \n-  volatile int array2[10];\n-\n- /* hope that this is allocated on top of old array[] */  \n-  if (p != & array2[0])\n-    exit (0);  /* Test is not applicable. */\n-\n-  array2[5] = 6;\n-\n-  /* Old values shouldn't still be around; the new one should.  */\n-  if (p[0] == 2 || p[9] == 5 || p[5] != 6)\n-    abort() ;\n-\n-  /* array2[] should not be wiped at this point! */\n-}\n-\n-{ \n-  volatile int array3[10];\n-\n- /* hope that this is allocated on top of old array[] and array2[]*/  \n-  if (p != & array3[0])\n-    exit (0);  /* Test is not applicable. */\n-\n-  array3[1] = 2;\n-\n-  /* Check that old assignment is still around.  */\n-  if (p[5] != 6 || p[1] != 2)\n-    abort() ;\n-}\n-return 0;\n-}"}, {"sha": "97bed6eb373aec8da1be421a58f3c0f936ac8c01", "filename": "libmudflap/testsuite/libmudflap.c/pass29-frag.c", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass29-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass29-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass29-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,15 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-struct boo { int a; };\n-int c;\n-struct boo *b = malloc (sizeof (struct boo));\n-__mf_set_options (\"-check-initialization\");\n-b->a = 0;\n-/* That __mf_set_options call could be here instead. */\n-c = b->a;\n-(void) malloc (c); /* some dummy use of c */\n-return 0;\n-}"}, {"sha": "4e950a2c5d833c5366dc5581faa56ed2f434ffa2", "filename": "libmudflap/testsuite/libmudflap.c/pass3-frag.c", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass3-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass3-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass3-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,9 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-int foo [10][10][10];\n-foo[9][9][0] = 0;\n-return 0;\n-}"}, {"sha": "6c4b9f9a7f8b8298b7f900343b90ad4e301e8c42", "filename": "libmudflap/testsuite/libmudflap.c/pass30-frag.c", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass30-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass30-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass30-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,12 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-char zoo [10];\n-\n-int main ()\n-{\n-int i = strlen (\"eight\") + strlen (\"one\");\n-zoo[i] = 'a';\n-return 0;\n-}"}, {"sha": "d7f223279761cdd68d598c2b0f56daf7fd3f4a3d", "filename": "libmudflap/testsuite/libmudflap.c/pass32-frag.c", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass32-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass32-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass32-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,18 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-struct foo { char z[10]; };\n-\n-char * get_z (struct foo *this)\n-{\n-  return & this->z[0] /* the `this' pointer is not dereferenced! */;\n-}\n-\n-int main ()\n-{\n-struct foo k;\n-char *n = get_z (& k);\n-srand ((int)(__mf_uintptr_t) n); /* use the pointer value */\n-return 0;\n-}"}, {"sha": "95d762cc1aae1851432dadf321867466c10a6d6d", "filename": "libmudflap/testsuite/libmudflap.c/pass33-frag.c", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass33-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass33-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass33-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,17 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-void test (int *k)\n-{\n-  if (*k > 5) { *k --; }\n-}\n-\n-int main ()\n-{\n-int z;\n-/* z is initialized, but not via a pointer, so not instrumented */\n-z = rand (); \n-test (& z);\n-return 0;\n-}"}, {"sha": "2dfd0ca2113c0c0cbba05034f54bacf954665c2a", "filename": "libmudflap/testsuite/libmudflap.c/pass34-frag.c", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass34-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass34-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass34-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,18 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-void test (int *k)\n-{\n-  if (*k > 5) { *k --; }\n-}\n-\n-int z;\n-\n-int main ()\n-{\n-/* z is initialized, but not via a pointer, so not instrumented */\n-z = rand (); \n-test (& z);\n-return 0;\n-}"}, {"sha": "14d2c94a9bb5a6519a1e41a1a7f33fce07e6698e", "filename": "libmudflap/testsuite/libmudflap.c/pass35-frag.c", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass35-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass35-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass35-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,14 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-extern char end [];   /* Any old symbol we're sure will be defined. */\n-/* { dg-warning \"cannot track unknown size extern\" \"cannot track unknown size extern\" { target *-*-* } 0 } */\n-\n-int main ()\n-{\n-/* dummy register */\n-__mf_register ((void *) end, 1, __MF_TYPE_GUESS, \"end\");\n-char z = end[0];\n-return z & 0;\n-}"}, {"sha": "68d1a7f80805494eb58e05808332df58fb55ff5f", "filename": "libmudflap/testsuite/libmudflap.c/pass36-frag.c", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass36-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass36-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass36-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,15 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <signal.h>\n-\n-int main ()\n-{\n-char *k;\n-__mf_set_options (\"-sigusr1-report -print-leaks\");\n-k = (char *) malloc (100);\n-raise (SIGUSR1);\n-free (k);\n-return 0;\n-}\n-/* { dg-output \"Leaked object.*name=.malloc region.*objects: 1\" } */"}, {"sha": "a250234da8a9b7868efa4a4036d2ab4d22543128", "filename": "libmudflap/testsuite/libmudflap.c/pass38-frag.c", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass38-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass38-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass38-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,9 +0,0 @@\n-/* Test an odd construct for compilability.  */\n-static void *fwd;\n-void *bwd = &fwd;\n-static void *fwd = &bwd;\n-\n-int main ()\n-{\n-  return 0;\n-}"}, {"sha": "0a40d1c425a1b8bd65773ce9f634fc5d5c68cb68", "filename": "libmudflap/testsuite/libmudflap.c/pass4-frag.c", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass4-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass4-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass4-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,9 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-char foo[10];\n-strcpy (foo, \"123456789\");\n-return 0;\n-}"}, {"sha": "1045c47c37a4410d432cbae8821ac85222ad7ebc", "filename": "libmudflap/testsuite/libmudflap.c/pass42-frag.c", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass42-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass42-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass42-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,17 +0,0 @@\n-#include <stdio.h>\n-\n-void\n-foo ()\n-{\n-  putc ('h', stdout);\n-  putc ('i', stdout);\n-  putc ('\\n', stdout);\n-}\n-\n-int\n-main (int argc, char *argv[])\n-{\n-  foo ();\n-  return 0;\n-}\n-/* { dg-output \"hi\" } */"}, {"sha": "4fec3306eb17496648ce50590a52176bb77caeb4", "filename": "libmudflap/testsuite/libmudflap.c/pass43-frag.c", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass43-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass43-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass43-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,11 +0,0 @@\n-void\n-foo ()\n-{\n-}\n-\n-int\n-main (int argc, char *argv[])\n-{\n-  foo ();\n-  return 0;\n-}"}, {"sha": "338d6da63bf4ffb3166bd0eb6d63aafb09e37d11", "filename": "libmudflap/testsuite/libmudflap.c/pass44-frag.c", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass44-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass44-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass44-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,14 +0,0 @@\n-#include <stdio.h>\n-\n-void\n-foo ()\n-{\n-  return; /* accept value-less return statement */\n-}\n-\n-int\n-main (int argc, char *argv[])\n-{\n-  foo ();\n-  return 0;\n-}"}, {"sha": "c6bfeb5048c3da804a8304eb1c31704f9789f41a", "filename": "libmudflap/testsuite/libmudflap.c/pass45-frag.c", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass45-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass45-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass45-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,31 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-extern void h (const char *p, const char *f);\n-int\n-main (void)\n-{\n-  h (0, \"foo\");\n-  return 0;\n-}\n-\n-void\n-h (const char *p, const char *f)\n-{\n-  size_t pl = p == NULL ? 0 : strlen (p);\n-  size_t fl = strlen (f) + 1;\n-  char a[pl + 1 + fl];\n-  char *cp = a;\n-  char b[pl + 5 + fl * 2];\n-  char *cccp = b;\n-  if (p != NULL)\n-    {\n-      cp = memcpy (cp, p, pl);\n-      *cp++ = ':';\n-    }\n-  memcpy (cp, f, fl);\n-  strcpy (b, a);\n-  puts (a);\n-}\n-/* { dg-output \"foo\" } */"}, {"sha": "904868af0d1dd9c54856f2fc5ad1ac7cf52e2bfd", "filename": "libmudflap/testsuite/libmudflap.c/pass46-frag.c", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass46-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass46-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass46-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,18 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-int foo (int *u, int i)\n-{\n-   return u[i];  /* this dereference should not be instrumented */\n-}\n-\n-int main ()\n-{\n-  int *k = malloc (6);\n- int l = foo (k, 8);\n- int boo [8];\n- int m = boo [l % 2 + 12]; /* should not be instrumented */\n- return m & strlen (\"\"); /* a fancy way of saying \"0\" */\n-}\n-/* { dg-options \"-fmudflap -fmudflapir -lmudflap\" } */"}, {"sha": "71175827209f9521415057ab5ace9f76cf66c4de", "filename": "libmudflap/testsuite/libmudflap.c/pass47-frag.c", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass47-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass47-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass47-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,12 +0,0 @@\n-#include <stdlib.h>\n-#include <ctype.h>\n-\n-int main ()\n-{\n-  char* buf = \"hello\"; \n-  return ! ((toupper (buf[0]) == 'H' && toupper ('z') == 'Z' &&\n-             tolower (buf[4]) == 'o' && tolower ('X') == 'x' &&\n-             isdigit (buf[3])) == 0 && isalnum ('4'));\n-}\n-\n-/* { dg-warning \"cannot track unknown size extern .__ctype.\" \"Solaris __ctype declared without size\" { target *-*-solaris2.* } 0 } */"}, {"sha": "3059762a82c31222eb4df6f0063248d892fe60d1", "filename": "libmudflap/testsuite/libmudflap.c/pass48-frag.c", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass48-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass48-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass48-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,11 +0,0 @@\n-void foo (int k)\n-{\n-  volatile int *b = & k;\n-  *b = 5;\n-}\n-\n-int main ()\n-{\n-  foo (5);\n-  return 0;\n-}"}, {"sha": "db7453079a0fae6fb5a887bfd4e33a4f0674e760", "filename": "libmudflap/testsuite/libmudflap.c/pass49-frag.c", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass49-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass49-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass49-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,35 +0,0 @@\n-#include <stdlib.h>\n-#include <ctype.h>\n-#include <stdarg.h>\n-\n-int foo (int a, ...)\n-{\n-  va_list args;\n-  char *a1;\n-  int a2;\n-  int k;\n-\n-  va_start (args, a);\n-  for (k = 0; k < a; k++)\n-    {\n-      if ((k % 2) == 0)\n-        {\n-          char *b = va_arg (args, char *);\n-          printf (\"%s\", b);\n-        }\n-      else\n-        {\n-          int b = va_arg (args, int);\n-          printf (\"%d\", b);\n-        }\n-    }\n-  va_end (args);\n-  return a;\n-}\n-\n-int main ()\n-{\n-  foo (7, \"hello \", 5, \" \", 3, \" world \", 9, \"\\n\");\n-  return 0;\n-}\n-/* { dg-output \"hello 5 3 world 9\" } */"}, {"sha": "6d3408a4e521233713d3a89393f71dc01c2a5c57", "filename": "libmudflap/testsuite/libmudflap.c/pass5-frag.c", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass5-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass5-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass5-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,11 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-char foo [10];\n-char bar [10];\n-bar[4] = 'k'; /* touch memcpy source */\n-memcpy(foo, bar, 10);\n-return 0;\n-}"}, {"sha": "ac9ee090950e42ec432e8bcda48e731d98b6be0c", "filename": "libmudflap/testsuite/libmudflap.c/pass50-frag.c", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass50-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass50-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass50-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,29 +0,0 @@\n-#include <stdlib.h>\n-\n-struct a\n-{\n-  int a1[5];\n-  union\n-  {\n-    int b1[5];\n-    struct\n-    {\n-      int c1;\n-      int c2;\n-    } b2[4];\n-  } a2[8];\n-};\n-\n-int i1 = 5;\n-int i2 = 2;\n-int i3 = 6;\n-int i4 = 0;\n-\n-int\n-main ()\n-{\n-  volatile struct a *k = calloc (1, sizeof (struct a));\n-  k->a2[i1].b1[i2] = k->a2[i3].b2[i4].c2;\n-  free ((void *) k);\n-  return 0;\n-}"}, {"sha": "2780ffd72a02582b67f3b71a650eec0b969827e4", "filename": "libmudflap/testsuite/libmudflap.c/pass51-frag.c", "status": "removed", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass51-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass51-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass51-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,44 +0,0 @@\n-/* Test object-spanning accesses.  This is most conveniently done with\n-   mmap, thus the config.h specificity here.  */\n-#include \"../config.h\"\n-\n-#include <unistd.h>\n-#include <string.h>\n-#ifdef HAVE_SYS_MMAN_H\n-#include <sys/mman.h>\n-#endif\n-\n-int main ()\n-{\n-#ifndef MAP_ANONYMOUS\n-#define MAP_ANONYMOUS MAP_ANON\n-#endif\n-#ifndef MAP_FAILED\n-#define MAP_FAILED ((void *)-1)\n-#endif\n-#ifdef HAVE_MMAP\n-  void *p;\n-  unsigned pg = getpagesize ();\n-  int rc;\n-\n-  p = mmap (NULL, 4 * pg, PROT_READ|PROT_WRITE, \n-            MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n-  if (p == MAP_FAILED)\n-    return 1;\n-\n-  memset (p, 0, 4*pg);\n-  rc = munmap (p, pg);\n-  if (rc < 0) return 1;\n-  memset (p+pg, 0, 3*pg);\n-  rc = munmap (p+pg, pg);\n-  if (rc < 0) return 1;\n-  memset (p+2*pg, 0, 2*pg);\n-  rc = munmap (p+2*pg, pg);\n-  if (rc < 0) return 1;\n-  memset (p+3*pg, 0, pg);\n-  rc = munmap (p+3*pg, pg);\n-  if (rc < 0) return 1;\n-#endif\n-\n-  return 0;\n-}"}, {"sha": "7ff9d577ba7497d12ac78c8989b08d4d563fb5d8", "filename": "libmudflap/testsuite/libmudflap.c/pass52-frag.c", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass52-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass52-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass52-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,36 +0,0 @@\n-#include <stdio.h>\n-\n-\n-void writestuff (FILE *f)\n-{\n-  fprintf (f, \"hello world\\n\");\n-  fputc ('y', f);\n-  putc ('e', f);\n-}\n-\n-void readstuff (FILE *f)\n-{\n-  int c, d;\n-  char stuff[100], *s;\n-  c = fgetc (f);\n-  ungetc (c, f);\n-  d = fgetc (f);\n-  s = fgets (stuff, sizeof(stuff), f);\n-}\n-\n-int main ()\n-{\n-  FILE *f;\n-  writestuff (stdout);\n-  writestuff (stderr);\n-  f = fopen (\"/dev/null\", \"w\");\n-  writestuff (f);\n-  fclose (f);\n-  f = fopen (\"/dev/zero\", \"r\");\n-  readstuff (f);\n-  f = freopen (\"/dev/null\", \"w\", f);\n-  writestuff (f);\n-  fclose (f);\n-\n-  return 0;\n-}"}, {"sha": "6afb2931e349343e142bedde0ee4604fc84b7b46", "filename": "libmudflap/testsuite/libmudflap.c/pass53-frag.c", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass53-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass53-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass53-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,41 +0,0 @@\n-int foo1 ()\n-{\n-  union { int l; char c[sizeof (int)]; } k1;\n-  char *m;\n-  k1.l = 0;\n-  /* This test variant triggers ADDR_EXPR of k explicitly in order to\n-     ensure it's registered with the runtime.  */\n-  m = k1.c;\n-  k1.c [sizeof (int)-1] = m[sizeof (int)-2];\n-}\n-\n-int foo2 ()\n-{\n-  union { int l; char c[sizeof (int)]; } k2;\n-  k2.l = 0;\n-  /* Since this access is known-in-range, k need not be registered\n-     with the runtime, but then this access better not be instrumented\n-     either.  */\n-  k2.c [sizeof (int)-1] ++;\n-  return k2.l;\n-}\n-\n-int foo3idx = sizeof (int)-1;\n-\n-int foo3 ()\n-{\n-  union { int l; char c[sizeof (int)]; } k3;\n-  k3.l = 0;\n-  /* NB this test uses foo3idx, an extern variable, to defeat mudflap\n-     known-in-range-index optimizations.  */\n-  k3.c [foo3idx] ++;\n-  return k3.l;\n-}\n-\n-int main ()\n-{\n-  foo1 ();\n-  foo2 ();\n-  foo3 ();\n-  return 0;\n-}"}, {"sha": "5eebb4515fc33cfb9b7f51dc1c478f3a4b8a99e2", "filename": "libmudflap/testsuite/libmudflap.c/pass54-frag.c", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass54-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass54-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass54-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,34 +0,0 @@\n-struct k \n-{\n-  struct {\n-    int b;\n-    int c;\n-  } a;\n-};\n-\n-static struct k l;\n-static struct k m;\n-\n-void foo ()\n-{\n-  /* This should not be instrumented. */ \n-  l.a.b = 5;\n-}\n-\n-void bar ()\n-{\n-  /* This should not be instrumented. */ \n-  m.a.b = 5;\n-}\n-\n-int main ()\n-{\n-  /* Force TREE_ADDRESSABLE on \"l\" only.  */\n-  volatile int *k = & l.a.c;\n-  *k = 8;\n-  __mf_set_options (\"-mode-violate\");\n-  foo ();\n-  bar ();\n-  __mf_set_options (\"-mode-check\");\n-  return 0;\n-}"}, {"sha": "e22fc8dbfd61be27f7db8b17a220f11f6e5af272", "filename": "libmudflap/testsuite/libmudflap.c/pass56-frag.c", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass56-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass56-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass56-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,14 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-\n-int main ()\n-{\n-  volatile int *k = (int *) malloc (sizeof (int));\n-  volatile int l;\n-  if (k == NULL) abort ();\n-  *k = 5;\n-  free ((void *) k);\n-  __mf_set_options (\"-ignore-reads\");\n-  l = *k; /* Should not trip, even though memory region just freed.  */\n-  return 0;\n-}"}, {"sha": "9b07fe2de222437ccf8ce597b29f8fa2772919d8", "filename": "libmudflap/testsuite/libmudflap.c/pass6-frag.c", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass6-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass6-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass6-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,14 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-char *foo;\n-char *bar;\n-\n-foo = (char *)malloc (10);\n-bar = (char *)malloc (10);\n-bar[2] = 'z'; /* touch memcpy source */\n-memcpy(foo, bar, 10);\n-return 0;\n-}"}, {"sha": "8e64b2b0e43cd146ff39d1e422adec237e2ce143", "filename": "libmudflap/testsuite/libmudflap.c/pass62-frag.c", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass62-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass62-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass62-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,13 +0,0 @@\n-/* PR tree-optimization/34618 */\n-/* { dg-do compile } */\n-/* { dg-options \"-O3 -fmudflap\" } */\n-\n-int a[16];\n-\n-void\n-foo ()\n-{\n-  int i;\n-  for (i = 0; i < 16; i++)\n-    a[i] = i;\n-}"}, {"sha": "a5ad8f26b08f3058854a03e63167ce35b1f2f766", "filename": "libmudflap/testsuite/libmudflap.c/pass63-frag.c", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass63-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass63-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass63-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,6 +0,0 @@\n-/* Check -Wno-mudflap flag */\n-/* { dg-do compile } */\n-/* { dg-options \"-fmudflap -Wno-mudflap\" } */\n-\n-extern char x[];\n-int main() { return x[3]; }  /* { dg-bogus \"mudflap cannot track\" } */"}, {"sha": "856eec0fa7e01f4d10e7bec74c881e191507e765", "filename": "libmudflap/testsuite/libmudflap.c/pass64-frag.c", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass64-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass64-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass64-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,38 +0,0 @@\n-/* PR libmudflap/36397 */\n-/* { dg-do run } */\n-/* { dg-options \"-O -fmudflap -fno-strict-aliasing -lmudflap\" } */\n-\n-struct A\n-{\n-  int a[2];\n-};\n-\n-long long int x;\n-\n-int __attribute__ ((noinline))\n-baz (long long int *x)\n-{\n-  return *x;\n-}\n-\n-int __attribute__ ((noinline))\n-foo (int i)\n-{\n-  if (i > 10)\n-    return baz (&x);\n-  return ((struct A *) &x)->a[i];\n-}\n-\n-int\n-main (void)\n-{\n-  if (sizeof (long long) == 2 * sizeof (int)\n-      && sizeof (long long) == sizeof (struct A))\n-    {\n-      struct A a = { .a[0] = 10, .a[1] = 20 };\n-      __builtin_memcpy (&x, &a, sizeof (x));\n-      if (foo (0) != 10 || foo (1) != 20)\n-        __builtin_abort ();\n-    }\n-  return 0;\n-}"}, {"sha": "0c2f81a1705452a71ec4d92e30d76894a82c3999", "filename": "libmudflap/testsuite/libmudflap.c/pass67-frag.c", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass67-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass67-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass67-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,14 +0,0 @@\n-/* PR middle-end/35314 */\n-/* { dg-do compile } */\n-/* { dg-options \"-fmudflap\" } */\n-\n-#include <setjmp.h>\n-\n-jmp_buf buf;\n-\n-void\n-foo (volatile char *p)\n-{\n-  if (__builtin_setjmp (buf))\n-    *p;\n-}"}, {"sha": "36197339e880d14e468d4fedddb067e77e1f06fe", "filename": "libmudflap/testsuite/libmudflap.c/pass7-frag.c", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass7-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass7-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass7-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,13 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-char *foo;\n-char *bar;\n-foo = (char *)malloc (10);\n-bar = (char *)malloc (10);\n-bar[2] = 'z'; /* touch memcpy source */\n-memcpy(foo+1, bar+1, 9);\n-return 0;\n-}"}, {"sha": "6be4e93f000b28c986364dfb68c88625de3998c3", "filename": "libmudflap/testsuite/libmudflap.c/pass8-frag.c", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass8-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass8-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass8-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,16 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-char *foo;\n-char *bar;\n-foo = (char *)malloc (10);\n-bar = (char *)malloc (10);\n-\n-free(bar);\n-bar = (char *)malloc (10);\n-bar[6] = 'k'; /* touch memcpy source */\n-memcpy(foo, bar, 10);\n-return 0;\n-}"}, {"sha": "9186e062ff8af7617b7dc2f755bad5b680852636", "filename": "libmudflap/testsuite/libmudflap.c/pass9-frag.c", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass9-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass9-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.c%2Fpass9-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,16 +0,0 @@\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-int main ()\n-{\n-char *foo;\n-char *bar;\n-foo = (char *)malloc (10);\n-bar = (char *)malloc (10);\n-\n-free(foo);\n-foo = (char *)malloc (10);\n-bar[3] = 'w'; /* touch memcpy source */\n-memcpy(foo, bar, 10);\n-return 0;\n-}"}, {"sha": "75d444768384d65fad230070e1952713a85cb978", "filename": "libmudflap/testsuite/libmudflap.cth/cthfrags.exp", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.cth%2Fcthfrags.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.cth%2Fcthfrags.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.cth%2Fcthfrags.exp?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,30 +0,0 @@\n-global MUDFLAP_FLAGS\n-set MUDFLAP_FLAGS [list {-O0} {-static -DSTATIC} {-O2} {-O3}]\n-\n-libmudflap-init c\n-\n-dg-init\n-\n-global srcdir\n-foreach flags $MUDFLAP_FLAGS {\n-    foreach srcfile [lsort [glob -nocomplain ${srcdir}/libmudflap.cth/*.c]] {\n-\tset bsrc [file tail $srcfile]\n-\tsetenv MUDFLAP_OPTIONS \"-viol-segv\"\n-\tif {$libmudflapth} then {\n-\t    if [check_effective_target_gld] {\n-\t\t# --noinhibit-exec works around a ld problem that causes\n-\t\t# \"Dwarf Error: Invalid or unhandled FORM value: 14\"\n-\t\t# to fail builds unnecessarily.\n-\t\tset noie_option \" -Wl,--noinhibit-exec\"\n-\t    } else {\n-\t\tset noie_option \"\"\n-\t    }\n-\t    dg-runtest $srcfile $flags \"-fmudflapth -lmudflapth -lpthread $noie_option\"\n-\t} else {\n-\t    if {$flags != \"\"} {set f \" ($flags)\"} {set f \"\"}\n-            untested \"libmudflap.cth/$bsrc$f\"\n-\t}\n-    }\n-}\n-\n-dg-finish"}, {"sha": "877803c1ea028489384c8fdbf08e04bf9e9fb070", "filename": "libmudflap/testsuite/libmudflap.cth/pass37-frag.c", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.cth%2Fpass37-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.cth%2Fpass37-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.cth%2Fpass37-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,58 +0,0 @@\n-#include <stdlib.h>\n-#include <stdio.h>\n-#include <pthread.h>\n-#include <sched.h>\n-\n-static void *\n-func (void *p)\n-{\n-  int *counter = (int *) p;\n-  unsigned i;\n-  \n-  for (i=0; i<100; i++)\n-    {\n-      (*counter) ++;\n-      {\n-\tint array[17];\n-\tunsigned x = i % (sizeof(array)/sizeof(array[0]));\n-\t/* VRP could prove that x is within [0,16], but until then, the\n-\t   following access will ensure that array[] is registered to\n-\t   libmudflap. */\n-\tarray[x] = i;\n-      }\n-      sched_yield (); /* sleep (1); */\n-    }\n-\n-  return (NULL);\n-}\n-\n-\n-int main ()\n-{\n-  int rc;\n-  unsigned i;\n-  enum foo { NT=10 };\n-  pthread_t threads[NT];\n-  int counts[NT];\n-\n-\n-  for (i=0; i<NT; i++)\n-    {\n-      counts[i] = 0;\n-      rc = pthread_create (& threads[i], NULL, func, (void *) & counts[i]);\n-      if (rc) abort();\n-    }\n-\n-  for (i=0; i<NT; i++)\n-    {\n-      rc = pthread_join (threads[i], NULL);\n-      if (rc) abort();      \n-      printf (\"%d%s\", counts[i], (i==NT-1) ? \"\\n\" : \" \");\n-    }\n-\n-  return 0;\n-}\n-\n-/* { dg-output \"100 100 100 100 100 100 100 100 100 100\" } */\n-/* { dg-repetitions 20 } */\n-/* { dg-timeout 10 } */"}, {"sha": "cd3eb5abdafb61b03733c9c1a3a7663c03ee1feb", "filename": "libmudflap/testsuite/libmudflap.cth/pass39-frag.c", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.cth%2Fpass39-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.cth%2Fpass39-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.cth%2Fpass39-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,57 +0,0 @@\n-#include <stdlib.h>\n-#include <stdio.h>\n-#include <pthread.h>\n-#include <sched.h>\n-#include <assert.h>\n-\n-static void *\n-func (void *p)\n-{\n-  int *counter = (int *) p;\n-  unsigned i;\n-  enum { numarrays = 100, numels = 17 };\n-  char *arrays [numarrays];\n-\n-  for (i=0; i<numarrays; i++)\n-    {\n-      (*counter) ++;\n-      unsigned x = i % numels;\n-      arrays[i] = calloc (numels, sizeof(arrays[i][0]));\n-      assert (arrays[i] != NULL);\n-      arrays[i][x] = i;\n-      free (arrays[i]);\n-      sched_yield (); /* sleep (1); */\n-    }\n-\n-  return (NULL);\n-}\n-\n-\n-int main ()\n-{\n-  int rc;\n-  unsigned i;\n-  enum foo { NT=10 };\n-  pthread_t threads[NT];\n-  int counts[NT];\n-\n-\n-  for (i=0; i<NT; i++)\n-    {\n-      counts[i] = 0;\n-      rc = pthread_create (& threads[i], NULL, func, (void *) & counts[i]);\n-      if (rc) abort();\n-    }\n-\n-  for (i=0; i<NT; i++)\n-    {\n-      rc = pthread_join (threads[i], NULL);\n-      if (rc) abort();       \n-     printf (\"%d%s\", counts[i], (i==NT-1) ? \"\\n\" : \" \");\n-    }\n-\n-  return 0;\n-}\n-/* { dg-output \"100 100 100 100 100 100 100 100 100 100\" } */\n-/* { dg-repetitions 20 } */\n-/* { dg-timeout 10 } */"}, {"sha": "007cb1607de4298f47a2deb331f3a93ca047fa9e", "filename": "libmudflap/testsuite/libmudflap.cth/pass40-frag.c", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.cth%2Fpass40-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.cth%2Fpass40-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.cth%2Fpass40-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,59 +0,0 @@\n-#include <stdlib.h>\n-#include <stdio.h>\n-#include <pthread.h>\n-\n-static void *\n-func (void *p)  \n-{\n-        return (NULL);\n-}               \n-\n-static void\n-test (void)\n-{\n-        int             rc;\n-        pthread_attr_t  my_pthread_attr;\n-        pthread_t       h;\n-        long            i;\n-\n-        rc = pthread_attr_init (&my_pthread_attr);\n-\n-        for (i = 1; i <= 10000; ++i) {\n-                if (i%100 == 0) fprintf (stderr, \"%i \", i);\n-                if (i%1000 == 0) fprintf (stderr, \"\\n\");\n-#ifndef STATIC \n-\t  /* Some glibc versions don't like static multithreaded programs doing this. */\n-                if (i==5000) __mf_set_options (\"-thread-stack=192\");\n-#endif\n-                rc = pthread_create (&h, &my_pthread_attr,\n-                        func, NULL);\n-                if (rc)\n-                        break;\n-\n-                rc = pthread_join (h, NULL);\n-                if (rc)\n-                        break;\n-        }\n-        \n-        rc = pthread_attr_destroy (&my_pthread_attr);\n-}\n-                \n-int main ()\n-{\n-        test ();\n-                \n-        return (0);\n-}\n-\n-/* { dg-timeout 30 } */\n-/* { dg-output \"100 200 300 400 500 600 700 800 900 1000 \\n\" } */\n-/* { dg-output \"1100 1200 1300 1400 1500 1600 1700 1800 1900 2000 \\n\" } */\n-/* { dg-output \"2100 2200 2300 2400 2500 2600 2700 2800 2900 3000 \\n\" } */\n-/* { dg-output \"3100 3200 3300 3400 3500 3600 3700 3800 3900 4000 \\n\" } */\n-/* { dg-output \"4100 4200 4300 4400 4500 4600 4700 4800 4900 5000 \\n\" } */\n-/* { dg-output \"5100 5200 5300 5400 5500 5600 5700 5800 5900 6000 \\n\" } */\n-/* { dg-output \"6100 6200 6300 6400 6500 6600 6700 6800 6900 7000 \\n\" } */\n-/* { dg-output \"7100 7200 7300 7400 7500 7600 7700 7800 7900 8000 \\n\" } */\n-/* { dg-output \"8100 8200 8300 8400 8500 8600 8700 8800 8900 9000 \\n\" } */\n-/* { dg-output \"9100 9200 9300 9400 9500 9600 9700 9800 9900 10000 \\n\" } */\n-"}, {"sha": "49013067705af3162f004b6f8cf1e8038d2d07f5", "filename": "libmudflap/testsuite/libmudflap.cth/pass59-frag.c", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.cth%2Fpass59-frag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Flibmudflap.cth%2Fpass59-frag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Flibmudflap.cth%2Fpass59-frag.c?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,39 +0,0 @@\n-#include <stdio.h>\n-#include <pthread.h>\n-\n-/* PR 28578 */\n-\n-void* test_thread(void* arg)\n-{\n-  printf(\"Hello from thread!\\n\");\n-  pthread_exit(NULL);\n-  return 0;\n-}\n-\n-int main()\n-{\n-  pthread_t thread;\n-  void *arg = NULL;\n-  pthread_create(&thread, NULL, test_thread, arg);\n-  pthread_join(thread, NULL);\n-  pthread_exit(NULL);\n-  return 0;\n-}\n-\n-/* { dg-output \"Hello from thread!\\n\" } */\n-\n-#if 0\n-\n-/* Even this test case replicates the problem.  However, when built in\n-   static mode, it blows up during __mf_init (?!?!?!) with a\n-   pthread_mutex_lock deadlock error. */\n-\n-#include <stdio.h>\n-#include <pthread.h>\n-\n-int main ()\n-{\n-      pthread_exit(NULL);\n-      return 0;\n-}\n-#endif"}, {"sha": "bed16542cad4c9921f0aceef4da0048d31ea99af", "filename": "libmudflap/testsuite/mfconfig.exp.in", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Fmfconfig.exp.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19b632c6dd5e1e901ae1bac3fc92164a724ccab5/libmudflap%2Ftestsuite%2Fmfconfig.exp.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Ftestsuite%2Fmfconfig.exp.in?ref=19b632c6dd5e1e901ae1bac3fc92164a724ccab5", "patch": "@@ -1,4 +0,0 @@\n-global mfconfig_libs\n-set mfconfig_libs \"@LIBS@\"\n-global libmudflapth\n-set libmudflapth \"@build_libmudflapth@\""}]}