{"sha": "b51024fc8996b47f30f3bf277cf1338a24c49953", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUxMDI0ZmM4OTk2YjQ3ZjMwZjNiZjI3N2NmMTMzOGEyNGM0OTk1Mw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-04-24T05:52:07Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-04-24T05:52:07Z"}, "message": "* sort.c (sort_pointers): Fix endianness bugs.\n\nFrom-SVN: r33368", "tree": {"sha": "09ab302f144a8ef34de4d48bebf060cdc0aba25c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/09ab302f144a8ef34de4d48bebf060cdc0aba25c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b51024fc8996b47f30f3bf277cf1338a24c49953", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b51024fc8996b47f30f3bf277cf1338a24c49953", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b51024fc8996b47f30f3bf277cf1338a24c49953", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b51024fc8996b47f30f3bf277cf1338a24c49953/comments", "author": null, "committer": null, "parents": [{"sha": "a3fbf5c38363e2e40869f2a5d06e09930b29ae13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3fbf5c38363e2e40869f2a5d06e09930b29ae13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3fbf5c38363e2e40869f2a5d06e09930b29ae13"}], "stats": {"total": 20, "additions": 12, "deletions": 8}, "files": [{"sha": "cfc03e33f9c60ec38a4677bdb5871b64c55eb361", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b51024fc8996b47f30f3bf277cf1338a24c49953/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b51024fc8996b47f30f3bf277cf1338a24c49953/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=b51024fc8996b47f30f3bf277cf1338a24c49953", "patch": "@@ -1,5 +1,7 @@\n 2000-04-23  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* sort.c (sort_pointers): Fix endianness bugs.\n+\n \t* sort.c: New file.\n \t* Makefile.in (CFILES): Add sort.c\n \t(REQUIRED_OFILES): Add sort.o."}, {"sha": "4fd3ef9b98ee40bc5fbc22ee344bd79339d90780", "filename": "libiberty/sort.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b51024fc8996b47f30f3bf277cf1338a24c49953/libiberty%2Fsort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b51024fc8996b47f30f3bf277cf1338a24c49953/libiberty%2Fsort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsort.c?ref=b51024fc8996b47f30f3bf277cf1338a24c49953", "patch": "@@ -29,9 +29,8 @@ Boston, MA 02111-1307, USA.  */\n #include <stdlib.h>\n #endif\n \n-/* POINTERSP and WORKP both point to arrays of N pointers.  When\n-   this function returns POINTERSP will point to a sorted version of\n-   the original array pointed to by POINTERSP.  */\n+/* POINTERS and WORK are both arrays of N pointers.  When this\n+   function returns POINTERS will be sorted in ascending order.  */\n \n void sort_pointers (n, pointers, work)\n      size_t n;\n@@ -63,8 +62,11 @@ void sort_pointers (n, pointers, work)\n     abort ();\n \n   /* Figure out the endianness of the machine.  */\n-  for (i = 0; i < sizeof (size_t); ++i)\n-    ((char *)&j)[i] = i;\n+  for (i = 0, j = 0; i < sizeof (size_t); ++i)\n+    {\n+      j *= (UCHAR_MAX + 1);\n+      j += i;\n+    }\n   big_endian_p = (((char *)&j)[0] == 0);\n \n   /* Move through the pointer values from least significant to most\n@@ -91,8 +93,8 @@ void sort_pointers (n, pointers, work)\n       /* Compute the address of the appropriate digit in the first and\n \t one-past-the-end elements of the array.  On a little-endian\n \t machine, the least-significant digit is closest to the front.  */\n-      bias = ((digit_t *) pointers) + i;\n-      top = ((digit_t *) (pointers + n)) + i;\n+      bias = ((digit_t *) pointers) + j;\n+      top = ((digit_t *) (pointers + n)) + j;\n \n       /* Count how many there are of each value.  At the end of this\n \t loop, COUNT[K] will contain the number of pointers whose Ith\n@@ -109,7 +111,7 @@ void sort_pointers (n, pointers, work)\n \n       /* Now, drop the pointers into their correct locations.  */\n       for (pointerp = pointers + n - 1; pointerp >= pointers; --pointerp)\n-\twork[--count[((digit_t *) pointerp)[i]]] = *pointerp;\n+\twork[--count[((digit_t *) pointerp)[j]]] = *pointerp;\n \n       /* Swap WORK and POINTERS so that POINTERS contains the sorted\n \t array.  */"}]}