{"sha": "05227b51acefa0cd8bf2583ff46978f5667d8fc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDUyMjdiNTFhY2VmYTBjZDhiZjI1ODNmZjQ2OTc4ZjU2NjdkOGZjOA==", "commit": {"author": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1993-10-12T22:58:40Z"}, "committer": {"name": "Per Bothner", "email": "bothner@gcc.gnu.org", "date": "1993-10-12T22:58:40Z"}, "message": "Re-write , to use scan_decls as a sub-routine.\n\nFrom-SVN: r5763", "tree": {"sha": "5d52c985da676ebb17e1e7eb93237580d4b35fb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d52c985da676ebb17e1e7eb93237580d4b35fb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05227b51acefa0cd8bf2583ff46978f5667d8fc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05227b51acefa0cd8bf2583ff46978f5667d8fc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05227b51acefa0cd8bf2583ff46978f5667d8fc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05227b51acefa0cd8bf2583ff46978f5667d8fc8/comments", "author": null, "committer": null, "parents": [{"sha": "d79438193b176aa2c0ae47311ff5ba0f90e89934", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d79438193b176aa2c0ae47311ff5ba0f90e89934", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d79438193b176aa2c0ae47311ff5ba0f90e89934"}], "stats": {"total": 434, "additions": 279, "deletions": 155}, "files": [{"sha": "d0437298561c801b38185a7c5654efe6ae56e6fc", "filename": "gcc/fix-header.c", "status": "modified", "additions": 279, "deletions": 155, "changes": 434, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05227b51acefa0cd8bf2583ff46978f5667d8fc8/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05227b51acefa0cd8bf2583ff46978f5667d8fc8/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=05227b51acefa0cd8bf2583ff46978f5667d8fc8", "patch": "@@ -19,7 +19,7 @@ Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    into a form more conformant with ANSI/POSIX, and more suitable for C++:\n \n    * extern \"C\" { ... } braces are added (inside #ifndef __cplusplus),\n-   if they seem to be needed.  These prevcnt C++ compilers from name\n+   if they seem to be needed.  These prevent C++ compilers from name\n    mangling the functions inside the braces.\n \n    * If an old-style incomplete function declaration is seen (without\n@@ -73,6 +73,11 @@ Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #include <stdio.h>\n #include <ctype.h>\n+#include <sys/stat.h>\n+#include <sys/types.h>\n+#ifndef O_RDONLY\n+#define O_RDONLY 0\n+#endif\n #include \"obstack.h\"\n #include \"scan.h\"\n \n@@ -85,6 +90,11 @@ int missing_extra_stuff = 0;\n \n #include \"xsys-protos.h\"\n \n+char *inf_buffer;\n+char *inf_limit;\n+char *inf_ptr;\n+long int inf_size;\n+\n /* Certain standard files get extra treatment */\n \n enum special_file\n@@ -186,144 +196,136 @@ struct partial_proto required_dummy_proto;\n #define CLEAR_REQUIRED(FN) ((FN)->partial = 0)\n \n void\n-read_scan_file (scan_file)\n-     FILE *scan_file;\n+recognized_macro (fname)\n+     char *fname;\n {\n-  char **rptr;\n-  int i;\n-  obstack_init(&scan_file_obstack); \n+  /* The original include file defines fname as a macro. */\n+  struct fn_decl *fn = lookup_std_proto (fname);\n \n-  for (;;)\n+  /* Since fname is a macro, don't require a prototype for it. */\n+  if (fn && REQUIRED (fn))\n     {\n-      struct partial_proto *partial;\n-      struct fn_decl *fn;\n-      int ch;\n-      char *ptr, *fname, *kind, *rtype, *args, *file_seen, *line_seen;\n-      line.ptr = line.base;\n-      ch = read_upto (scan_file, &line, '\\n');\n-      if (ch == EOF)\n-\tbreak;\n-\n-      fname = line.base;\n-      for (ptr = fname; *ptr != ';'; ) ptr++;\n-      *ptr = 0;\n-      kind = ptr + 1;\n-      for (ptr = kind; *ptr != ';'; ) ptr++;\n-      *ptr = 0;\n+      CLEAR_REQUIRED(fn);\n+      required_unseen_count--;\n+    }\n \n-      if (*kind == 'X')\n+  switch (special_file_handling)\n+    {\n+    case errno_special:\n+      if (strcmp (fname, \"errno\") == 0) seen_errno++;\n+      break;\n+    case sys_stat_special:\n+      if (fname[0] == 'S' && fname[1] == '_')\n \t{\n-\t  switch (special_file_handling)\n-\t    {\n-\t    case errno_special:\n-\t      if (strcmp (fname, \"errno\") == 0) seen_errno++;\n-\t      break;\n-\t    }\n-\t  continue;\n+\t  if (strcmp (fname, \"S_IFBLK\") == 0) seen_S_IFBLK++;\n+\t  else if (strcmp (fname, \"S_ISBLK\") == 0) seen_S_ISBLK++;\n+\t  else if (strcmp (fname, \"S_IFCHR\") == 0) seen_S_IFCHR++;\n+\t  else if (strcmp (fname, \"S_ISCHR\") == 0) seen_S_ISCHR++;\n+\t  else if (strcmp (fname, \"S_IFDIR\") == 0) seen_S_IFDIR++;\n+\t  else if (strcmp (fname, \"S_ISDIR\") == 0) seen_S_ISDIR++;\n+\t  else if (strcmp (fname, \"S_IFIFO\") == 0) seen_S_IFIFO++;\n+\t  else if (strcmp (fname, \"S_ISFIFO\") == 0) seen_S_ISFIFO++;\n+\t  else if (strcmp (fname, \"S_IFLNK\") == 0) seen_S_IFLNK++;\n+\t  else if (strcmp (fname, \"S_ISLNK\") == 0) seen_S_ISLNK++;\n+\t  else if (strcmp (fname, \"S_IFREG\") == 0) seen_S_IFREG++;\n+\t  else if (strcmp (fname, \"S_ISREG\") == 0) seen_S_ISREG++;\n \t}\n+    }\n+}\n \n-      if (*kind == 'M')\n-\t{\n-\t  /* The original include file defines fname as a macro. */\n-\t  fn = lookup_std_proto (fname);\n+void\n+recognized_extern (name, type)\n+     char *name;\n+     char *type;\n+{\n+  switch (special_file_handling)\n+    {\n+    case errno_special:\n+      if (strcmp (name, \"errno\") == 0) seen_errno++;\n+      break;\n+    }\n+}\n \n-\t  /* Since fname is a macro, don't require a prototype for it. */\n-\t  if (fn && REQUIRED (fn))\n-\t    {\n-\t      CLEAR_REQUIRED(fn);\n-\t      required_unseen_count--;\n-\t    }\n+/* Called by scan_decls if it saw a function definition for a function\n+   named FNAME, with return type RTYPE, and argument list ARGS,\n+   in source file FILE_SEEN on line LINE_SEEN.\n+   KIND is 'I' for an inline function;\n+   'F' if a normal function declaration preceded by 'extern \"C\"'\n+   (or nested inside 'extern \"C\"' braces); or\n+   'f' for other function declarations. */\n \n-\t  switch (special_file_handling)\n-\t    {\n-\t    case errno_special:\n-\t      if (strcmp (fname, \"errno\") == 0) seen_errno++;\n-\t      break;\n-\t    case sys_stat_special:\n-\t      if (fname[0] == 'S' && fname[1] == '_')\n-\t\t{\n-\t\t  if (strcmp (fname, \"S_IFBLK\") == 0) seen_S_IFBLK++;\n-\t\t  else if (strcmp (fname, \"S_ISBLK\") == 0) seen_S_ISBLK++;\n-\t\t  else if (strcmp (fname, \"S_IFCHR\") == 0) seen_S_IFCHR++;\n-\t\t  else if (strcmp (fname, \"S_ISCHR\") == 0) seen_S_ISCHR++;\n-\t\t  else if (strcmp (fname, \"S_IFDIR\") == 0) seen_S_IFDIR++;\n-\t\t  else if (strcmp (fname, \"S_ISDIR\") == 0) seen_S_ISDIR++;\n-\t\t  else if (strcmp (fname, \"S_IFIFO\") == 0) seen_S_IFIFO++;\n-\t\t  else if (strcmp (fname, \"S_ISFIFO\") == 0) seen_S_ISFIFO++;\n-\t\t  else if (strcmp (fname, \"S_IFLNK\") == 0) seen_S_IFLNK++;\n-\t\t  else if (strcmp (fname, \"S_ISLNK\") == 0) seen_S_ISLNK++;\n-\t\t  else if (strcmp (fname, \"S_IFREG\") == 0) seen_S_IFREG++;\n-\t\t  else if (strcmp (fname, \"S_ISREG\") == 0) seen_S_ISREG++;\n-\t\t}\n-\t      break;\n-\t    }\n-\t  continue;\n-\t}\n+void\n+recognized_function (fname, kind, rtype, args, file_seen, line_seen)\n+     char *fname;\n+     int kind; /* One of 'f' 'F' or 'I' */\n+     char *rtype;\n+     char *args;\n+     char *file_seen;\n+     int line_seen;\n+{\n+  struct partial_proto *partial;\n+  int i;\n+  struct fn_decl *fn;\n+  if (kind == 'f')\n+    missing_extern_C_count++;\n \n-      rtype = ptr + 1;\n-      for (ptr = rtype; *ptr != ';'; ) ptr++;\n-      *ptr = 0;\n-      args = ptr + 1;\n-      for (ptr = args; *ptr != ';'; ) ptr++;\n-      *ptr = 0;\n-      file_seen = ptr + 1;\n-      for (ptr = file_seen; *ptr != ';'; ) ptr++;\n-      *ptr = 0;\n-      line_seen = ptr + 1;\n-      for (ptr = line_seen; *ptr != ';'; ) ptr++;\n-      *ptr = 0;\n-\n-      if (kind[0] == 'f')\n-\tmissing_extern_C_count++;\n-\n-      fn = lookup_std_proto (fname);\n-\n-      /* Remove the function from the list of required function. */\n-      if (fn && REQUIRED (fn))\n-\t{\n-\t  CLEAR_REQUIRED(fn);\n-\t  required_unseen_count--;\n-\t}\n+  fn = lookup_std_proto (fname);\n \n-      /* If we have a full prototype, we're done. */\n-      if (args[0] != '\\0')\n-\tcontinue;\n-      \n-      if (kind[0] == 'I')  /* don't edit inline function */\n-\tcontinue;\n+  /* Remove the function from the list of required function. */\n+  if (fn && REQUIRED (fn))\n+    {\n+      CLEAR_REQUIRED(fn);\n+      required_unseen_count--;\n+    }\n \n-      /* If the partial prototype was included from some other file,\n-\t we don't need to patch it up (in this run). */\n-      i = strlen (file_seen);\n-      if (i < inc_filename_length\n-\t  || strcmp (inc_filename, file_seen + (i - inc_filename_length)) != 0)\n-\tcontinue;\n+  /* If we have a full prototype, we're done. */\n+  if (args[0] != '\\0')\n+    return;\n+      \n+  if (kind == 'I')  /* don't edit inline function */\n+    return;\n+\n+  /* If the partial prototype was included from some other file,\n+     we don't need to patch it up (in this run). */\n+  i = strlen (file_seen);\n+  if (i < inc_filename_length\n+      || strcmp (inc_filename, file_seen + (i - inc_filename_length)) != 0)\n+    return;\n+\n+  if (fn == NULL)\n+    return;\n+  if (fn->params[0] == '\\0' || strcmp(fn->params, \"void\") == 0)\n+    return;\n+\n+  /* We only have a partial function declaration,\n+     so remember that we have to add a complete prototype. */\n+  partial_count++;\n+  partial = (struct partial_proto*)\n+    obstack_alloc (&scan_file_obstack, sizeof(struct partial_proto));\n+  partial->fname = obstack_alloc (&scan_file_obstack, strlen(fname) + 1);\n+  strcpy (partial->fname, fname);\n+  partial->rtype = obstack_alloc (&scan_file_obstack, strlen(rtype) + 1);\n+  strcpy (partial->rtype, rtype);\n+  partial->line_seen = line_seen;\n+  partial->fn = fn;\n+  fn->partial = partial;\n+  partial->next = partial_proto_list;\n+  partial_proto_list = partial;\n+  if (verbose)\n+    {\n+      fprintf (stderr, \"(%s: %s non-prototype function declaration.)\\n\",\n+\t       inc_filename, fname);\n+    }\n+}\n \n-      if (fn == NULL)\n-\tcontinue;\n-      if (fn->params[0] == '\\0' || strcmp(fn->params, \"void\") == 0)\n-\tcontinue;\n+void\n+read_scan_file (scan_file)\n+     FILE *scan_file;\n+{\n+  char **rptr;\n+  obstack_init(&scan_file_obstack); \n \n-      /* We only have a partial function declaration,\n-\t so remember that we have to add a complete prototype. */\n-      partial_count++;\n-      partial = (struct partial_proto*)\n-\tobstack_alloc (&scan_file_obstack, sizeof(struct partial_proto));\n-      partial->fname = obstack_alloc (&scan_file_obstack, strlen(fname) + 1);\n-      strcpy (partial->fname, fname);\n-      partial->rtype = obstack_alloc (&scan_file_obstack, strlen(rtype) + 1);\n-      strcpy (partial->rtype, rtype);\n-      partial->line_seen = atoi(line_seen);\n-      partial->fn = fn;\n-      fn->partial = partial;\n-      partial->next = partial_proto_list;\n-      partial_proto_list = partial;\n-      if (verbose)\n-\t{\n-\t  fprintf (stderr, \"(%s: %s non-prototype function declaration.)\\n\",\n-\t\t   inc_filename, fname);\n-\t}\n-    }\n+  scan_decls (scan_file);\n \n   if (missing_extern_C_count + required_unseen_count + partial_count\n       + missing_extra_stuff == 0)\n@@ -417,9 +419,94 @@ strdup (str)\n \n  */\n \n+#define INF_GET() (inf_ptr < inf_limit ? *(unsigned char*)inf_ptr++ : EOF)\n+#define INF_UNGET() inf_ptr--\n+\n+int\n+inf_skip_spaces (c)\n+     int c;\n+{\n+  for (;;)\n+    {\n+      if (c == ' ' || c == '\\t')\n+\tc = INF_GET();\n+      else if (c == '/')\n+\t{\n+\t  c = INF_GET();\n+\t  if (c != '*')\n+\t    {\n+\t      INF_UNGET();\n+\t      return '/';\n+\t    }\n+\t  c = INF_GET();\n+\t  for (;;)\n+\t    {\n+\t      if (c == EOF)\n+\t\treturn EOF;\n+\t      else if (c != '*')\n+\t\t{\n+\t\t  if (c == '\\n')\n+\t\t    source_lineno++, lineno++;\n+\t\t  c = INF_GET ();\n+\t\t}\n+\t      else if ((c = INF_GET()) == '/')\n+\t\treturn INF_GET();\n+\t    }\n+\t}\n+      else\n+\tbreak;\n+    }\n+  return c;\n+}\n+\n+/* Read into STR from inf_buffer upto DELIM. */\n+\n+int\n+inf_read_upto (str, delim)\n+     sstring *str;\n+     int delim;\n+{\n+  int ch;\n+  for (;;)\n+    {\n+      ch = INF_GET ();\n+      if (ch == EOF || ch == delim)\n+\tbreak;\n+      SSTRING_PUT(str, ch);\n+    }\n+  MAKE_SSTRING_SPACE(str, 1);\n+  *str->ptr = 0;\n+  return ch;\n+}\n+\n int\n-check_protection (inf, ifndef_line, endif_line)\n-     FILE *inf;\n+inf_scan_ident (s, c)\n+     register sstring *s;\n+     int c;\n+{\n+  s->ptr = s->base;\n+  if (isalpha(c) || c == '_')\n+    {\n+      for (;;)\n+\t{\n+\t  SSTRING_PUT(s, c);\n+\t  c = INF_GET ();\n+\t  if (c == EOF || !(isalnum(c) || c == '_'))\n+\t    break;\n+\t}\n+    }\n+  MAKE_SSTRING_SPACE(s, 1);\n+  *s->ptr = 0;\n+  return c;\n+}\n+\n+/* Returns 1 if the file is correctly protected against multiple\n+   inclusion, setting *ifndef_line to the line number of the initial #ifndef\n+   and setting *endif_line to the final #endif.\n+   Otherwise return 0. */\n+\n+int\n+check_protection (ifndef_line, endif_line)\n      int *ifndef_line, *endif_line;\n {\n   int c;\n@@ -430,34 +517,34 @@ check_protection (inf, ifndef_line, endif_line)\n   /* Skip initial white space (including comments). */\n   for (;; lineno++)\n     {\n-      c = skip_spaces (inf, ' ');\n+      c = inf_skip_spaces (' ');\n       if (c == EOF)\n \treturn 0;\n       if (c != '\\n')\n \tbreak;\n     }\n   if (c != '#')\n     return 0;\n-  c = scan_ident (inf, &buf, skip_spaces (inf, ' '));\n+  c = inf_scan_ident (&buf, inf_skip_spaces (' '));\n   if (SSTRING_LENGTH(&buf) == 0 || strcmp (buf.base, \"ifndef\") != 0)\n     return 0;\n \n   /* So far so good: We've seen an initial #ifndef. */\n   *ifndef_line = lineno;\n-  c = scan_ident (inf, &buf, skip_spaces (inf, c));\n+  c = inf_scan_ident (&buf, inf_skip_spaces (c));\n   if (SSTRING_LENGTH(&buf) == 0 || c == EOF)\n     return 0;\n   protect_name = strdup (buf.base);\n \n-  ungetc (c, inf);\n-  c = read_upto (inf, &buf, '\\n');\n+  INF_UNGET();\n+  c = inf_read_upto (&buf, '\\n');\n   if (c == EOF)\n     return 0;\n   lineno++;\n \n   for (;;)\n     {\n-      c = skip_spaces(inf, ' ');\n+      c = inf_skip_spaces(' ');\n       if (c == EOF)\n \treturn 0;\n       if (c == '\\n')\n@@ -467,7 +554,7 @@ check_protection (inf, ifndef_line, endif_line)\n \t}\n       if (c != '#')\n \tgoto skip_to_eol;\n-      c = scan_ident (inf, &buf, skip_spaces (inf, ' '));\n+      c = inf_scan_ident (&buf, inf_skip_spaces (' '));\n       if (SSTRING_LENGTH(&buf) == 0)\n \t;\n       else if (!strcmp (buf.base, \"ifndef\")\n@@ -490,8 +577,8 @@ check_protection (inf, ifndef_line, endif_line)\n \t{\n \t  if (if_nesting != 1)\n \t    goto skip_to_eol;\n-\t  c = skip_spaces (inf, c);\n-\t  c = scan_ident (inf, &buf, c);\n+\t  c = inf_skip_spaces (c);\n+\t  c = inf_scan_ident (&buf, c);\n \t  if (buf.base[0] > 0 && strcmp(buf.base, protect_name) == 0)\n \t    define_seen = 1;\n \t}\n@@ -500,7 +587,7 @@ check_protection (inf, ifndef_line, endif_line)\n \t{\n \t  if (c == '\\n' || c == EOF)\n \t    break;\n-\t  c = getc (inf);\n+\t  c = INF_GET();\n \t}\n       if (c == EOF)\n \treturn 0;\n@@ -513,7 +600,7 @@ check_protection (inf, ifndef_line, endif_line)\n   /* Skip final white space (including comments). */\n   for (;;)\n     {\n-      c = skip_spaces (inf, ' ');\n+      c = inf_skip_spaces (' ');\n       if (c == EOF)\n \tbreak;\n       if (c != '\\n')\n@@ -528,12 +615,14 @@ main(argc, argv)\n      int argc;\n      char **argv;\n {\n-  FILE *inf;\n+  int inf_fd;\n+  struct stat sbuf;\n   int c;\n   int i, done;\n   char *cptr, *cptr0, **pptr;\n   int ifndef_line;\n-  int endif_line;;\n+  int endif_line;\n+  long to_read;\n \n \n   if (argv[0] && argv[0][0])\n@@ -583,14 +672,46 @@ main(argc, argv)\n \n   read_scan_file (stdin);\n \n-  inf = fopen (argv[2], \"r\");\n-  if (inf == NULL)\n+  inf_fd = open (argv[2], O_RDONLY, 0666);\n+  if (inf_fd < 0)\n     {\n       fprintf (stderr, \"%s: Cannot open '%s' for reading -\",\n \t       progname, argv[2]);\n       perror (NULL);\n       exit (-1);\n     }\n+  if (fstat (inf_fd, &sbuf) < 0)\n+    {\n+      fprintf (stderr, \"%s: Cannot get size of '%s' -\", progname, argv[2]);\n+      perror (NULL);\n+      exit (-1);\n+    }\n+  inf_size = sbuf.st_size;\n+  inf_buffer = (char*) xmalloc (inf_size + 2);\n+  inf_buffer[inf_size] = '\\n';\n+  inf_buffer[inf_size + 1] = '\\0';\n+  inf_limit = inf_buffer + inf_size;\n+  inf_ptr = inf_buffer;\n+\n+  to_read = inf_size;\n+  while (to_read > 0)\n+    {\n+      long i = read (inf_fd, inf_buffer + inf_size - to_read, to_read);\n+      if (i < 0)\n+\t{\n+\t  fprintf (stderr, \"%s: Failed to read '%s' -\", progname, argv[2]);\n+\t  perror (NULL);\n+\t  exit (-1);\n+\t}\n+      if (i == 0)\n+\t{\n+\t  inf_size -= to_read;\n+\t  break;\n+\t}\n+      to_read -= i;\n+    }\n+\n+  close (inf_fd);\n \n   outf = fopen (argv[3], \"w\");\n   if (outf == NULL)\n@@ -601,7 +722,9 @@ main(argc, argv)\n       exit (-1);\n     }\n \n-  if (check_protection (inf, &ifndef_line, &endif_line))\n+  lineno = 1;\n+\n+  if (check_protection (&ifndef_line, &endif_line))\n     {\n #if 0\n       fprintf(stderr, \"#ifndef %s on line %d; #endif on line %d\\n\",\n@@ -616,7 +739,8 @@ main(argc, argv)\n       rbrac_line = -1;\n     }\n \n-  fseek(inf, 0, 0);\n+  /* Reset input file. */\n+  inf_ptr = inf_buffer;\n   lineno = 1;\n \n   for (;;)\n@@ -628,46 +752,47 @@ main(argc, argv)\n       for (;;)\n \t{\n \t  struct fn_decl *fn;\n-\t  c = getc (inf);\n+\t  c = INF_GET();\n \t  if (c == EOF)\n \t    break;\n \t  if (isalpha (c) || c == '_')\n \t    {\n \t      struct partial_proto *partial;\n-\t      ungetc (c, inf);\n-\t      if (get_token (inf, &buf) != IDENTIFIER_TOKEN)\n-\t\tabort ();\n+\t      c = inf_scan_ident (&buf, c);\n+\t      INF_UNGET();\n \t      fputs (buf.base, outf);\n \t      fn = lookup_std_proto (buf.base);\n \t      /* We only want to edit the declaration matching the one\n \t\t seen by scan-decls, as there can be multiple\n \t\t declarations, selected by #ifdef __STDC__ or whatever. */\n \t      if (fn && fn->partial && fn->partial->line_seen == lineno)\n \t\t{\n-\t\t  c = skip_spaces (inf, ' ');\n+\t\t  c = inf_skip_spaces (' ');\n \t\t  if (c == EOF)\n \t\t    break;\n \t\t  if (c == '(')\n \t\t    {\n-\t\t      c = skip_spaces (inf, ' ');\n+\t\t      c = inf_skip_spaces (' ');\n \t\t      if (c == ')')\n \t\t\t{\n \t\t\t  fprintf (outf, \" _PARAMS((%s))\", fn->params);\n \t\t\t}\n \t\t      else\n \t\t\t{\n \t\t\t  putc ('(', outf);\n-\t\t\t  ungetc (c, inf);\n+\t\t\t  INF_UNGET();\n \t\t\t}\n \t\t    }\n \t\t  else\n \t\t    fprintf (outf, \" %c\", c);\n \t\t}\n \t    }\n \t  else\n-\t    putc (c, outf);\n-\t  if (c == '\\n')\n-\t    break;\n+\t    {\n+\t      putc (c, outf);\n+\t      if (c == '\\n')\n+\t\tbreak;\n+\t    }\n \t}\n       if (c == EOF)\n \tbreak;\n@@ -676,7 +801,6 @@ main(argc, argv)\n   if (rbrac_line < 0)\n     write_rbrac ();\n \n-  fclose (inf);\n   fclose (outf);\n \n   return 0;"}]}