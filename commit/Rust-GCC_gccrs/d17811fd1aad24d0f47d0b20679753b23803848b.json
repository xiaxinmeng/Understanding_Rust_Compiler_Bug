{"sha": "d17811fd1aad24d0f47d0b20679753b23803848b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE3ODExZmQxYWFkMjRkMGY0N2QwYjIwNjc5NzUzYjIzODAzODQ4Yg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-07-09T08:48:08Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-07-09T08:48:08Z"}, "message": "fold-const.c (make_range): Do not access operand 1 for a zero-operand operator.\n\n\t* fold-const.c (make_range): Do not access operand 1 for a\n\tzero-operand operator.\n\n2003-07-08  Mark Mitchell  <mark@codesourcery.com>\n\n\t* cp-tree.def (NON_DEPENDENT_EXPR): New node.\n\t* cp-tree.h (build_call_from_tree): Remove.\n\t(build_member_call): Likewise.\n\t(dependent_template_arg_p): Remove.\n\t(any_dependent_template_arguments_p): New function.\n\t(dependent_template_id_p): Likewise.\n\t(any_type_dependent_arguments_p): Likewise.\n\t(build_non_dependent_expr): Likewise.\n\t(build_non_dependent_args): Likewise.\n\t(build_x_compound_expr): Adjust prototype.\n\t* call.c (build_new_method_call): Handle non-dependent expressions\n\tcorrectly.\n\t* decl2.c (grok_array_decl): Likewise.\n\t(build_offset_ref_call_from_tree): Likewise.\n\t(build_call_from_tree): Remove.\n\t* error.c (dump_decl): Handle NON_DEPENDENT_EXPR.\n\t(dump_expr): Likewise.\n\t* init.c (build_member_call): Remove.\n\t* mangle.c (write_expression): Update handling for template-ids.\n\t* parser.c (cp_parser_primary_expression): Use\n\tany_dependent_template_arguments_p.  Update constant-expression\n\thandling.\n\t(cp_parser_postfix_expression): Use\n\tany_type_dependent_arguments_p.  Simplify call processing.\n\t(cp_parser_unary_expression): Simplify.\n\t(cp_parser_expression): Adjust for changes to\n\tbuild_x_compound_expr.\n\t(cp_parser_template_argument): Implement standard-conforming\n\tparsing of non-type template arguments.\n\t(cp_parser_direct_declarator): Use\n\tcp_parser_fold_non_dependent_expr.\n\t(cp_parser_fold_non_dependent_expr): New function.\n\t(cp_parser_next_token_ends_template_argument_p): Likewise.\n\t* pt.c (convert_template_argument): Do not call\n\tmaybe_fold_nontype_arg.\n\t(tsubst_baselink): Likewise.\n\t(tsubst_copy_and_build): Share common code.  Make sizeof/alignof\n\tprocessing work correctly for non-dependent expressions.  Adjust\n\thandling of COMPOUND_EXPR.  Simplify call processing.\n\t(value_dependent_expression_p): Deal with functional casts and\n\tsizeof/alignof correctly.\n\t(type_dependent_expression_p): Handle overloaded functions.\n\t(any_type_dependent_arguments_p): New function.\n\t(any_dependent_template_arguments_p): Likewise.\n\t(dependent_template_p): Treat SCOPE_REFs as dependent.\n\t(dependent_template_id_p): Simplify.\n\t(build_non_dependent_expr): New function.\n\t(build_non_dependent_args): Likewise.\n\t* semantics.c (finish_stmt_expr): Don't make dependent\n\tstatement-expresions have void type.\n\t(finish_call_expr): Handle non-dependent expressions\n\tcorrectly.\n\t* tree.c (lvalue_p_1): Treat NON_DEPENDENT_EXPRs as lvalues.\n\t* typeck.c (cxx_sizeof_or_alignof_type): Give the expression\n\ttype size_t, even in templates.\n\t(expr_sizeof): Likewise.\n\t(finish_class_member_access_expr): Handle non-dependent expressions\n\tcorrectly.\n\t(build_x_indirect_ref): Likewise.\n\t(build_x_binary_op): Likewise.\n\t(build_x_unary_op): Likewise.\n\t(build_x_conditional_expr): Likewise.\n\t(build_x_compound_expr): Likewise.\n\t* typeck2.c (build_x_arrow): Likewise.\n\n2003-07-08  Mark Mitchell  <mark@codesourcery.com>\n\n\t* g++.dg/abi/mangle17.C: Make sure template expressions are\n\tdependent.\n\t* g++.dg/abi/mangle4.C: Mark erroneous casts.\n\t* g++.dg/debug/debug7.C: Mark erronous new-declarator.\n\t* g++.dg/opt/stack1.C: Remove erroneous code.\n\t* g++.dg/parse/template7.C: New test.\n\t* g++.dg/template/dependent-expr1.C: Mark erroneous code.\n\t* g++.old-deja/g++.pt/crash4.C: Likewise.\n\n2003-07-09  Mark Mitchell  <mark@codesourcery.com>\n\n\t* gcj/array.h (JvPrimClass): Don't parenthesize the output.\n\nFrom-SVN: r69130", "tree": {"sha": "1246373b84fbf4bb96eed29b458823d826bd18da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1246373b84fbf4bb96eed29b458823d826bd18da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d17811fd1aad24d0f47d0b20679753b23803848b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d17811fd1aad24d0f47d0b20679753b23803848b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d17811fd1aad24d0f47d0b20679753b23803848b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d17811fd1aad24d0f47d0b20679753b23803848b/comments", "author": null, "committer": null, "parents": [{"sha": "844c00ed1626fba3304289f5f8c3531620b24d5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/844c00ed1626fba3304289f5f8c3531620b24d5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/844c00ed1626fba3304289f5f8c3531620b24d5f"}], "stats": {"total": 1777, "additions": 941, "deletions": 836}, "files": [{"sha": "e5cf6bba07802019c6266c76359a64e839a73152", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -1,3 +1,8 @@\n+2003-07-08  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* fold-const.c (make_range): Do not access operand 1 for a\n+\tzero-operand operator.\n+\n 2003-07-09  Neil Booth  <neil@daikokuya.co.uk>\n \n \t* toplev.c (warn_dummy, W_options): Die."}, {"sha": "8d83247f636e82c44293007f22ff0e59a53f7ce3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 70, "deletions": 3, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -1,3 +1,70 @@\n+2003-07-08  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.def (NON_DEPENDENT_EXPR): New node.\n+\t* cp-tree.h (build_call_from_tree): Remove.\n+\t(build_member_call): Likewise.\n+\t(dependent_template_arg_p): Remove.\n+\t(any_dependent_template_arguments_p): New function.\n+\t(dependent_template_id_p): Likewise.\n+\t(any_type_dependent_arguments_p): Likewise.\n+\t(build_non_dependent_expr): Likewise.\n+\t(build_non_dependent_args): Likewise.\n+\t(build_x_compound_expr): Adjust prototype.\n+\t* call.c (build_new_method_call): Handle non-dependent expressions\n+\tcorrectly.\n+\t* decl2.c (grok_array_decl): Likewise.\n+\t(build_offset_ref_call_from_tree): Likewise.\n+\t(build_call_from_tree): Remove.\n+\t* error.c (dump_decl): Handle NON_DEPENDENT_EXPR.\n+\t(dump_expr): Likewise.\n+\t* init.c (build_member_call): Remove.\n+\t* mangle.c (write_expression): Update handling for template-ids.\n+\t* parser.c (cp_parser_primary_expression): Use\n+\tany_dependent_template_arguments_p.  Update constant-expression\n+\thandling.\n+\t(cp_parser_postfix_expression): Use\n+\tany_type_dependent_arguments_p.  Simplify call processing.\n+\t(cp_parser_unary_expression): Simplify.\n+\t(cp_parser_expression): Adjust for changes to\n+\tbuild_x_compound_expr.\n+\t(cp_parser_template_argument): Implement standard-conforming\n+\tparsing of non-type template arguments.\n+\t(cp_parser_direct_declarator): Use\n+\tcp_parser_fold_non_dependent_expr.\n+\t(cp_parser_fold_non_dependent_expr): New function.\n+\t(cp_parser_next_token_ends_template_argument_p): Likewise.\n+\t* pt.c (convert_template_argument): Do not call\n+\tmaybe_fold_nontype_arg.\n+\t(tsubst_baselink): Likewise.\n+\t(tsubst_copy_and_build): Share common code.  Make sizeof/alignof\n+\tprocessing work correctly for non-dependent expressions.  Adjust\n+\thandling of COMPOUND_EXPR.  Simplify call processing.\n+\t(value_dependent_expression_p): Deal with functional casts and\n+\tsizeof/alignof correctly.\n+\t(type_dependent_expression_p): Handle overloaded functions.\n+\t(any_type_dependent_arguments_p): New function.\n+\t(any_dependent_template_arguments_p): Likewise.\n+\t(dependent_template_p): Treat SCOPE_REFs as dependent.\n+\t(dependent_template_id_p): Simplify.\n+\t(build_non_dependent_expr): New function.\n+\t(build_non_dependent_args): Likewise.\n+\t* semantics.c (finish_stmt_expr): Don't make dependent\n+\tstatement-expresions have void type.\n+\t(finish_call_expr): Handle non-dependent expressions\n+\tcorrectly.\n+\t* tree.c (lvalue_p_1): Treat NON_DEPENDENT_EXPRs as lvalues.\n+\t* typeck.c (cxx_sizeof_or_alignof_type): Give the expression\n+\ttype size_t, even in templates.\n+\t(expr_sizeof): Likewise.\n+\t(finish_class_member_access_expr): Handle non-dependent expressions\n+\tcorrectly.\n+\t(build_x_indirect_ref): Likewise.\n+\t(build_x_binary_op): Likewise.\n+\t(build_x_unary_op): Likewise.\n+\t(build_x_conditional_expr): Likewise.\n+\t(build_x_compound_expr): Likewise.\n+\t* typeck2.c (build_x_arrow): Likewise.\n+\n Wed Jul  9 02:28:39 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* cp-lang.c (LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS): New.\n@@ -210,13 +277,13 @@ Wed Jul  9 02:28:39 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \t(build_conditional_expr): Likewise.\n \t(build_new_method_call): Likewise.\n \t* cp-tree.def (OFFSET_REF): Update documentation.\n-\t(cp_convert_to_pointer): Update handling of conversions from\n+\t* cvt.c (cp_convert_to_pointer): Update handling of conversions from\n \tpointers to members to pointers.\n \t(ocp_convert): Do not call resolve_offset_ref.\n \t(convert_to_void): Likewise.\n \t(build_expr_type_conversion): Likewise.\n-\t(delete_sanity): Likewise.\n-\t(resolve_offset_ref): Simplify greatly.\n+\t* decl2.c (delete_sanity): Likewise.\n+\t* init.c (resolve_offset_ref): Simplify greatly.\n \t(build_vec_delete): Do not call resolve_offset_ref.\n \t* parser.c (cp_parser_postfix_expression): Call resolve_offset_ref\n \tif appropriate."}, {"sha": "6659592b22dcd3f602abf0bf84db6089770ef633", "filename": "gcc/cp/call.c", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -325,8 +325,7 @@ build_call (tree function, tree parms)\n \n    BASETYPE_PATH, if non-NULL, contains a chain from the type of INSTANCE\n    down to the real instance type to use for access checking.  We need this\n-   information to get protected accesses correct.  This parameter is used\n-   by build_member_call.\n+   information to get protected accesses correct.\n \n    FLAGS is the logical disjunction of zero or more LOOKUP_\n    flags.  See cp-tree.h for more info.\n@@ -4883,6 +4882,9 @@ build_new_method_call (tree instance, tree fns, tree args,\n   tree class_type;\n   int template_only = 0;\n   bool any_viable_p;\n+  tree orig_instance;\n+  tree orig_fns;\n+  tree orig_args;\n \n   my_friendly_assert (instance != NULL_TREE, 20020729);\n \n@@ -4891,6 +4893,20 @@ build_new_method_call (tree instance, tree fns, tree args,\n       || args == error_mark_node)\n     return error_mark_node;\n \n+  orig_instance = instance;\n+  orig_fns = fns;\n+  orig_args = args;\n+\n+  if (processing_template_decl)\n+    {\n+      instance = build_non_dependent_expr (instance);\n+      if (!BASELINK_P (fns)\n+\t  && TREE_CODE (fns) != PSEUDO_DTOR_EXPR\n+\t  && TREE_TYPE (fns) != unknown_type_node)\n+\tfns = build_non_dependent_expr (fns);\n+      args = build_non_dependent_args (orig_args);\n+    }\n+\n   /* Process the argument list.  */\n   user_args = args;\n   args = resolve_args (args);\n@@ -5068,6 +5084,13 @@ build_new_method_call (tree instance, tree fns, tree args,\n \tcall = build (COMPOUND_EXPR, TREE_TYPE (call), instance, call);\n     }\n \n+  if (processing_template_decl && call != error_mark_node)\n+    return build_min (CALL_EXPR,\n+\t\t      TREE_TYPE (call),\n+\t\t      build_min_nt (COMPONENT_REF,\n+\t\t\t\t    orig_instance, \n+\t\t\t\t    orig_fns),\n+\t\t      orig_args);\n   return call;\n }\n "}, {"sha": "f9819ec1cad020606b55aa6381f07f0bb83e37cd", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -238,6 +238,16 @@ DEFTREECODE (DOTSTAR_EXPR, \"dotstar_expr\", 'e', 2)\n DEFTREECODE (TYPEID_EXPR, \"typeid_expr\", 'e', 1)\n DEFTREECODE (PSEUDO_DTOR_EXPR, \"pseudo_dtor_expr\", 'e', 3)\n \n+/* A placeholder for an expression that is not type-dependent, but\n+   does occur in a template.  When an expression that is not\n+   type-dependent appears in a larger expression, we must compute the\n+   type of that larger expression.  That computation would normally\n+   modify the original expression, which would change the mangling of\n+   that expression if it appeared in a template argument list.  In\n+   that situation, we create a NON_DEPENDENT_EXPR to take the place of\n+   the original expression.  */\n+DEFTREECODE (NON_DEPENDENT_EXPR, \"non_dependent_expr\", 'e', 0)\n+\n /* CTOR_INITIALIZER is a placeholder in template code for a call to\n    setup_vtbl_pointer (and appears in all functions, not just ctors).  */\n DEFTREECODE (CTOR_INITIALIZER, \"ctor_initializer\", 'e', 1)"}, {"sha": "58eabc3a396afb3d99d8ec03919fc8e65be834da", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -215,6 +215,7 @@ struct diagnostic_context;\n \n #define abi_version_at_least(N) \\\n   (flag_abi_version == 0 || flag_abi_version >= (N))\n+\n \f\n /* Language-dependent contents of an identifier.  */\n \n@@ -3775,7 +3776,6 @@ extern void import_export_tinfo\t(tree, tree, bool);\n extern void finish_file\t\t\t\t(void);\n extern tree build_cleanup\t\t\t(tree);\n extern tree build_offset_ref_call_from_tree     (tree, tree);\n-extern tree build_call_from_tree                (tree, tree, bool);\n extern void set_decl_namespace (tree, tree, bool);\n extern tree current_decl_namespace              (void);\n extern void push_decl_namespace                 (tree);\n@@ -3853,7 +3853,6 @@ extern int is_aggr_type\t\t\t\t(tree, int);\n extern tree get_aggr_from_typedef\t\t(tree, int);\n extern tree get_type_value\t\t\t(tree);\n extern tree build_zero_init       \t\t(tree, tree, bool);\n-extern tree build_member_call\t\t\t(tree, tree, tree);\n extern tree build_offset_ref\t\t\t(tree, tree);\n extern tree resolve_offset_ref\t\t\t(tree);\n extern tree build_new\t\t\t\t(tree, tree, tree, int);\n@@ -3974,12 +3973,16 @@ extern tree current_instantiation               (void);\n extern tree maybe_get_template_decl_from_type_decl (tree);\n extern int processing_template_parmlist;\n extern bool dependent_type_p                    (tree);\n-extern bool dependent_template_arg_p            (tree);\n+extern bool any_dependent_template_arguments_p  (tree);\n extern bool dependent_template_p                (tree);\n+extern bool dependent_template_id_p             (tree, tree);\n extern bool type_dependent_expression_p         (tree);\n+extern bool any_type_dependent_arguments_p      (tree);\n extern bool value_dependent_expression_p        (tree);\n extern tree resolve_typename_type               (tree, bool);\n extern tree template_for_substitution           (tree);\n+extern tree build_non_dependent_expr            (tree);\n+extern tree build_non_dependent_args            (tree);\n \n /* in repo.c */\n extern void repo_template_used (tree);\n@@ -4267,7 +4270,7 @@ extern tree build_x_binary_op\t\t\t(enum tree_code, tree, tree);\n extern tree build_x_unary_op\t\t\t(enum tree_code, tree);\n extern tree unary_complex_lvalue\t\t(enum tree_code, tree);\n extern tree build_x_conditional_expr\t\t(tree, tree, tree);\n-extern tree build_x_compound_expr\t\t(tree);\n+extern tree build_x_compound_expr\t\t(tree, tree);\n extern tree build_compound_expr\t\t\t(tree);\n extern tree build_static_cast\t\t\t(tree, tree);\n extern tree build_reinterpret_cast\t\t(tree, tree);"}, {"sha": "c77e5039fb9a9d5a709907cbc3198b9c743266d8", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 89, "deletions": 103, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -398,59 +398,77 @@ grokclassfn (tree ctype, tree function, enum overload_flags flags, tree quals)\n tree\n grok_array_decl (tree array_expr, tree index_exp)\n {\n-  tree type = TREE_TYPE (array_expr);\n-  tree p1, p2, i1, i2;\n+  tree type;\n+  tree expr;\n+  tree orig_array_expr = array_expr;\n+  tree orig_index_exp = index_exp;\n \n-  if (type == error_mark_node || index_exp == error_mark_node)\n+  if (error_operand_p (array_expr) || error_operand_p (index_exp))\n     return error_mark_node;\n+\n   if (processing_template_decl)\n-    return build_min (ARRAY_REF, type ? TREE_TYPE (type) : NULL_TREE,\n-\t\t      array_expr, index_exp);\n+    {\n+      if (type_dependent_expression_p (array_expr)\n+\t  || type_dependent_expression_p (index_exp))\n+\treturn build_min_nt (ARRAY_REF, array_expr, index_exp);\n+      array_expr = build_non_dependent_expr (array_expr);\n+      index_exp = build_non_dependent_expr (index_exp);\n+    }\n \n+  type = TREE_TYPE (array_expr);\n   my_friendly_assert (type, 20030626);\n-\n   type = non_reference (type);\n \n   /* If they have an `operator[]', use that.  */\n   if (IS_AGGR_TYPE (type) || IS_AGGR_TYPE (TREE_TYPE (index_exp)))\n-    return build_new_op (ARRAY_REF, LOOKUP_NORMAL,\n+    expr = build_new_op (ARRAY_REF, LOOKUP_NORMAL,\n \t\t\t array_expr, index_exp, NULL_TREE);\n-\n-  /* Otherwise, create an ARRAY_REF for a pointer or array type.  It\n-     is a little-known fact that, if `a' is an array and `i' is an\n-     int, you can write `i[a]', which means the same thing as `a[i]'.  */\n-\n-  if (TREE_CODE (type) == ARRAY_TYPE)\n-    p1 = array_expr;\n   else\n-    p1 = build_expr_type_conversion (WANT_POINTER, array_expr, false);\n+    {\n+      tree p1, p2, i1, i2;\n+\n+      /* Otherwise, create an ARRAY_REF for a pointer or array type.\n+\t It is a little-known fact that, if `a' is an array and `i' is\n+\t an int, you can write `i[a]', which means the same thing as\n+\t `a[i]'.  */\n+      if (TREE_CODE (type) == ARRAY_TYPE)\n+\tp1 = array_expr;\n+      else\n+\tp1 = build_expr_type_conversion (WANT_POINTER, array_expr, false);\n \n-  if (TREE_CODE (TREE_TYPE (index_exp)) == ARRAY_TYPE)\n-    p2 = index_exp;\n-  else\n-    p2 = build_expr_type_conversion (WANT_POINTER, index_exp, false);\n+      if (TREE_CODE (TREE_TYPE (index_exp)) == ARRAY_TYPE)\n+\tp2 = index_exp;\n+      else\n+\tp2 = build_expr_type_conversion (WANT_POINTER, index_exp, false);\n \n-  i1 = build_expr_type_conversion (WANT_INT | WANT_ENUM, array_expr, false);\n-  i2 = build_expr_type_conversion (WANT_INT | WANT_ENUM, index_exp, false);\n+      i1 = build_expr_type_conversion (WANT_INT | WANT_ENUM, array_expr, \n+\t\t\t\t       false);\n+      i2 = build_expr_type_conversion (WANT_INT | WANT_ENUM, index_exp, \n+\t\t\t\t       false);\n \n-  if ((p1 && i2) && (i1 && p2))\n-    error (\"ambiguous conversion for array subscript\");\n+      if ((p1 && i2) && (i1 && p2))\n+\terror (\"ambiguous conversion for array subscript\");\n \n-  if (p1 && i2)\n-    array_expr = p1, index_exp = i2;\n-  else if (i1 && p2)\n-    array_expr = p2, index_exp = i1;\n-  else\n-    {\n-      error (\"invalid types `%T[%T]' for array subscript\",\n-\t\ttype, TREE_TYPE (index_exp));\n-      return error_mark_node;\n-    }\n+      if (p1 && i2)\n+\tarray_expr = p1, index_exp = i2;\n+      else if (i1 && p2)\n+\tarray_expr = p2, index_exp = i1;\n+      else\n+\t{\n+\t  error (\"invalid types `%T[%T]' for array subscript\",\n+\t\t    type, TREE_TYPE (index_exp));\n+\t  return error_mark_node;\n+\t}\n \n-  if (array_expr == error_mark_node || index_exp == error_mark_node)\n-    error (\"ambiguous conversion for array subscript\");\n+      if (array_expr == error_mark_node || index_exp == error_mark_node)\n+\terror (\"ambiguous conversion for array subscript\");\n \n-  return build_array_ref (array_expr, index_exp);\n+      expr = build_array_ref (array_expr, index_exp);\n+    }\n+  if (processing_template_decl && expr != error_mark_node)\n+    return build_min (ARRAY_REF, TREE_TYPE (expr), orig_array_expr, \n+\t\t      orig_index_exp);\n+  return expr;\n }\n \n /* Given the cast expression EXP, checking out its validity.   Either return\n@@ -2949,88 +2967,56 @@ tree\n build_offset_ref_call_from_tree (tree fn, tree args)\n {\n   tree object_addr;\n+  tree orig_fn;\n+  tree orig_args;\n+  tree expr;\n+\n+  orig_fn = fn;\n+  orig_args = args;\n \n-  my_friendly_assert (TREE_CODE (fn) == OFFSET_REF, 20020725);\n+  if (processing_template_decl)\n+    {\n+      tree object;\n+      tree object_type;\n+\n+      my_friendly_assert (TREE_CODE (fn) == DOTSTAR_EXPR\n+\t\t\t  || TREE_CODE (fn) == MEMBER_REF,\n+\t\t\t  20030708);\n+      if (type_dependent_expression_p (fn)\n+\t  || any_type_dependent_arguments_p (args))\n+\treturn build_min_nt (CALL_EXPR, fn, args);\n+\n+      /* Transform the arguments and add the implicit \"this\"\n+\t parameter.  That must be done before the FN is transformed\n+\t because we depend on the form of FN.  */\n+      args = build_non_dependent_args (args);\n+      object_type = TREE_TYPE (TREE_OPERAND (fn, 0));\n+      if (TREE_CODE (fn) == DOTSTAR_EXPR)\n+\tobject_type = build_pointer_type (non_reference (object_type));\n+      object = build (NON_DEPENDENT_EXPR, object_type);\n+      args = tree_cons (NULL_TREE, object, args);\n+      /* Now that the arguments are done, transform FN.  */\n+      fn = build_non_dependent_expr (fn);\n+    }\n \n   /* A qualified name corresponding to a bound pointer-to-member is\n      represented as an OFFSET_REF:\n \n \tstruct B { void g(); };\n \tvoid (B::*p)();\n \tvoid B::g() { (this->*p)(); }  */\n-  if (TREE_CODE (TREE_OPERAND (fn, 1)) == FIELD_DECL)\n-    /* This case should now be handled elsewhere.  */\n-    abort ();\n-  else\n+  if (TREE_CODE (fn) == OFFSET_REF)\n     {\n       object_addr = build_unary_op (ADDR_EXPR, TREE_OPERAND (fn, 0), 0);\n       fn = TREE_OPERAND (fn, 1);\n       fn = get_member_function_from_ptrfunc (&object_addr, fn);\n       args = tree_cons (NULL_TREE, object_addr, args);\n     }\n-  return build_function_call (fn, args);\n-}\n-\n-/* FN indicates the function to call.  Name resolution has been\n-   performed on FN.  ARGS are the arguments to the function.  They\n-   have already been semantically analyzed.  DISALLOW_VIRTUAL is true\n-   if the function call should be determined at compile time, even if\n-   FN is virtual.  */\n-\n-tree\n-build_call_from_tree (tree fn, tree args, bool disallow_virtual)\n-{\n-  tree template_args;\n-  tree template_id;\n-  tree f;\n-  \n-  /* Check to see that name lookup has already been performed.  */\n-  my_friendly_assert (TREE_CODE (fn) != OFFSET_REF, 20020725);\n-  my_friendly_assert (TREE_CODE (fn) != SCOPE_REF, 20020725);\n-\n-  /* In the future all of this should be eliminated.  Instead,\n-     name-lookup for a member function should simply return a\n-     baselink, instead of a FUNCTION_DECL, TEMPLATE_DECL, or\n-     TEMPLATE_ID_EXPR.  */\n-\n-  if (TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n-    {\n-      template_id = fn;\n-      template_args = TREE_OPERAND (fn, 1);\n-      fn = TREE_OPERAND (fn, 0);\n-    }\n-  else\n-    {\n-      template_id = NULL_TREE;\n-      template_args = NULL_TREE;\n-    }\n-\n-  f = (TREE_CODE (fn) == OVERLOAD) ? get_first_fn (fn) : fn;\n-  /* Make sure we have a baselink (rather than simply a\n-     FUNCTION_DECL) for a member function.  */\n-  if (current_class_type\n-      && ((TREE_CODE (f) == FUNCTION_DECL\n-\t   && DECL_FUNCTION_MEMBER_P (f))\n-\t  || (DECL_FUNCTION_TEMPLATE_P (f) \n-\t      && DECL_FUNCTION_MEMBER_P (f))))\n-    {\n-      f = lookup_member (current_class_type, DECL_NAME (f), \n-\t\t\t /*protect=*/1, /*want_type=*/false);\n-      if (f)\n-\tfn = f;\n-    }\n-\n-  if (template_id)\n-    {\n-      if (BASELINK_P (fn))\n-\t  BASELINK_FUNCTIONS (fn) = build_nt (TEMPLATE_ID_EXPR, \n-\t\t\t\t\t      BASELINK_FUNCTIONS (fn),\n-\t\t\t\t\t      template_args);\n-      else\n-\tfn = template_id;\n-    }\n \n-  return finish_call_expr (fn, args, disallow_virtual);\n+  expr = build_function_call (fn, args);\n+  if (processing_template_decl && expr != error_mark_node)\n+    return build_min (CALL_EXPR, TREE_TYPE (expr), orig_fn, orig_args);\n+  return expr;\n }\n \n /* Returns true if ROOT (a namespace, class, or function) encloses"}, {"sha": "79803d2dfff91ed38ad13b59088a0d565f82a6ec", "filename": "gcc/cp/error.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -988,6 +988,10 @@ dump_decl (tree t, int flags)\n       dump_decl (BASELINK_FUNCTIONS (t), flags);\n       break;\n \n+    case NON_DEPENDENT_EXPR:\n+      dump_expr (t, flags);\n+      break;\n+\n     default:\n       sorry_for_unsupported_tree (t);\n       /* Fallthrough to error.  */\n@@ -2028,7 +2032,11 @@ dump_expr (tree t, int flags)\n       dump_expr (get_first_fn (t), flags & ~TFF_EXPR_IN_PARENS);\n       break;\n \n-      /* else fall through */\n+    case NON_DEPENDENT_EXPR:\n+      output_add_string (scratch_buffer, \"<expression of type \");\n+      dump_type (TREE_TYPE (t), flags);\n+      output_add_character (scratch_buffer, '>');\n+      break;\n \n       /*  This list is incomplete, but should suffice for now.\n \t  It is very important that `sorry' does not call"}, {"sha": "4a11b4319fa32e2ca9bb9d576f90b765909c352a", "filename": "gcc/cp/init.c", "status": "modified", "additions": 0, "deletions": 151, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -1337,157 +1337,6 @@ get_type_value (tree name)\n     return NULL_TREE;\n }\n \n-\f\n-/* This code could just as well go in `class.c', but is placed here for\n-   modularity.  */\n-\n-/* For an expression of the form TYPE :: NAME (PARMLIST), build\n-   the appropriate function call.  */\n-\n-tree\n-build_member_call (tree type, tree name, tree parmlist)\n-{\n-  tree t;\n-  tree method_name;\n-  tree fns;\n-  int dtor = 0;\n-  tree basetype_path, decl;\n-\n-  if (TREE_CODE (name) == TEMPLATE_ID_EXPR\n-      && TREE_CODE (type) == NAMESPACE_DECL)\n-    {\n-      /* 'name' already refers to the decls from the namespace, since we\n-\t hit do_identifier for template_ids.  */\n-      method_name = TREE_OPERAND (name, 0);\n-      /* FIXME: Since we don't do independent names right yet, the\n-\t name might also be a LOOKUP_EXPR. Once we resolve this to a\n-\t real decl earlier, this can go. This may happen during\n-\t tsubst'ing.  */\n-      if (TREE_CODE (method_name) == LOOKUP_EXPR)\n-\t{\n-\t  method_name = lookup_namespace_name \n-\t    (type, TREE_OPERAND (method_name, 0));\n-\t  TREE_OPERAND (name, 0) = method_name;\n-\t}\n-      my_friendly_assert (is_overloaded_fn (method_name), 980519);\n-      return finish_call_expr (name, parmlist, /*disallow_virtual=*/true);\n-    }\n-\n-  if (DECL_P (name))\n-    name = DECL_NAME (name);\n-\n-  if (TREE_CODE (type) == NAMESPACE_DECL)\n-    return finish_call_expr (lookup_namespace_name (type, name),\n-\t\t\t     parmlist,\n-\t\t\t     /*disallow_virtual=*/true);\n-\n-  if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n-    {\n-      method_name = TREE_OPERAND (name, 0);\n-      if (TREE_CODE (method_name) == COMPONENT_REF)\n-\tmethod_name = TREE_OPERAND (method_name, 1);\n-      if (is_overloaded_fn (method_name))\n-\tmethod_name = DECL_NAME (OVL_CURRENT (method_name));\n-      TREE_OPERAND (name, 0) = method_name;\n-    }\n-  else\n-    method_name = name;\n-\n-  if (TREE_CODE (method_name) == BIT_NOT_EXPR)\n-    {\n-      method_name = TREE_OPERAND (method_name, 0);\n-      dtor = 1;\n-    }\n-\n-  /* This shouldn't be here, and build_member_call shouldn't appear in\n-     parse.y!  (mrs)  */\n-  if (type && TREE_CODE (type) == IDENTIFIER_NODE\n-      && get_aggr_from_typedef (type, 0) == 0)\n-    {\n-      tree ns = lookup_name (type, 0);\n-      if (ns && TREE_CODE (ns) == NAMESPACE_DECL)\n-\treturn finish_call_expr (lookup_namespace_name (ns, name),\n-\t\t\t\t parmlist,\n-\t\t\t\t /*disallow_virtual=*/true);\n-    }\n-\n-  if (type == NULL_TREE || ! is_aggr_type (type, 1))\n-    return error_mark_node;\n-\n-  /* An operator we did not like.  */\n-  if (name == NULL_TREE)\n-    return error_mark_node;\n-\n-  if (dtor)\n-    {\n-      error (\"cannot call destructor `%T::~%T' without object\", type,\n-\t\tmethod_name);\n-      return error_mark_node;\n-    }\n-\n-  decl = maybe_dummy_object (type, &basetype_path);\n-\n-  fns = lookup_fnfields (basetype_path, method_name, 0);\n-  if (fns)\n-    {\n-      if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n-\tBASELINK_FUNCTIONS (fns) = build_nt (TEMPLATE_ID_EXPR,\n-\t\t\t\t\t     BASELINK_FUNCTIONS (fns),\n-\t\t\t\t\t     TREE_OPERAND (name, 1));\n-      return build_new_method_call (decl, fns, parmlist,\n-\t\t\t\t    /*conversion_path=*/NULL_TREE,\n-\t\t\t\t    LOOKUP_NORMAL|LOOKUP_NONVIRTUAL);\n-    }\n-\n-  /* Convert 'this' to the specified type to disambiguate conversion\n-     to the function's context.  */\n-  if (decl == current_class_ref\n-      /* ??? this is wrong, but if this conversion is invalid we need to\n-\t defer it until we know whether we are calling a static or\n-\t non-static member function.  Be conservative for now.  */\n-      && ACCESSIBLY_UNIQUELY_DERIVED_P (type, current_class_type))\n-    {\n-      basetype_path = NULL_TREE;\n-      decl = build_scoped_ref (decl, type, &basetype_path);\n-      if (decl == error_mark_node)\n-\treturn error_mark_node;\n-    }\n-\n-  if (constructor_name_p (method_name, type))\n-    return build_functional_cast (type, parmlist);\n-  if (TREE_CODE (name) == IDENTIFIER_NODE\n-      && ((t = lookup_field (TYPE_BINFO (type), name, 1, false))))\n-    {\n-      if (t == error_mark_node)\n-\treturn error_mark_node;\n-      if (TREE_CODE (t) == FIELD_DECL)\n-\t{\n-\t  if (is_dummy_object (decl))\n-\t    {\n-\t      error (\"invalid use of non-static field `%D'\", t);\n-\t      return error_mark_node;\n-\t    }\n-\t  decl = build (COMPONENT_REF, TREE_TYPE (t), decl, t);\n-\t}\n-      else if (TREE_CODE (t) == VAR_DECL)\n-\tdecl = t;\n-      else\n-\t{\n-\t  error (\"invalid use of member `%D'\", t);\n-\t  return error_mark_node;\n-\t}\n-      if (TYPE_LANG_SPECIFIC (TREE_TYPE (decl)))\n-\treturn build_new_op (CALL_EXPR, LOOKUP_NORMAL, decl,\n-\t\t\t     parmlist, NULL_TREE);\n-      return build_function_call (decl, parmlist);\n-    }\n-  else\n-    {\n-      error (\"no method `%T::%D'\", type, name);\n-      return error_mark_node;\n-    }\n-}\n-\n /* Build a reference to a member of an aggregate.  This is not a\n    C++ `&', but really something which can have its address taken,\n    and then act as a pointer to member, for example TYPE :: FIELD"}, {"sha": "29fd523c7271d113f2f7ac803019baa4f5a4f30e", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -2019,6 +2019,19 @@ write_expression (tree expr)\n \t  write_type (TREE_OPERAND (expr, 0));\n \t  if (TREE_CODE (TREE_OPERAND (expr, 1)) == IDENTIFIER_NODE)\n \t    write_source_name (TREE_OPERAND (expr, 1));\n+\t  else if (TREE_CODE (TREE_OPERAND (expr, 1)) == TEMPLATE_ID_EXPR)\n+\t    {\n+\t      tree template_id;\n+\t      tree name;\n+\n+\t      template_id = TREE_OPERAND (expr, 1);\n+\t      name = TREE_OPERAND (template_id, 0);\n+\t      /* FIXME: What about operators?  */\n+\t      my_friendly_assert (TREE_CODE (name) == IDENTIFIER_NODE,\n+\t\t\t\t  20030707);\n+\t      write_source_name (TREE_OPERAND (template_id, 0));\n+\t      write_template_args (TREE_OPERAND (template_id, 1));\n+\t    }\n \t  else\n \t    {\n \t      /* G++ 3.2 incorrectly put out both the \"sr\" code and"}, {"sha": "19f55f40a8e706b83b66da520698991cbb751ef3", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 221, "deletions": 138, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -1651,6 +1651,8 @@ static tree cp_parser_sizeof_operand\n   (cp_parser *, enum rid);\n static bool cp_parser_declares_only_class_p\n   (cp_parser *);\n+static tree cp_parser_fold_non_dependent_expr\n+  (tree);\n static bool cp_parser_friend_p\n   (tree);\n static cp_token *cp_parser_require\n@@ -1661,6 +1663,8 @@ static bool cp_parser_token_starts_function_definition_p\n   (cp_token *);\n static bool cp_parser_next_token_starts_class_definition_p\n   (cp_parser *);\n+static bool cp_parser_next_token_ends_template_argument_p\n+  (cp_parser *);\n static enum tag_types cp_parser_token_is_class_key\n   (cp_token *);\n static void cp_parser_check_class_key\n@@ -2381,7 +2385,6 @@ cp_parser_primary_expression (cp_parser *parser,\n \t  cp_parser_error (parser, \"expected primary-expression\");\n \t  return error_mark_node;\n \t}\n-      /* Fall through.  */\n \n       /* An id-expression can start with either an identifier, a\n \t `::' as the beginning of a qualified-id, or the \"operator\"\n@@ -2600,30 +2603,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\tif (TREE_CODE (fns) == TEMPLATE_ID_EXPR)\n \t\t  {\n \t\t    tree args = TREE_OPERAND (fns, 1);\n-\n-\t\t    if (args && TREE_CODE (args) == TREE_LIST)\n-\t\t      {\n-\t\t\twhile (args)\n-\t\t\t  {\n-\t\t\t    if (dependent_template_arg_p (TREE_VALUE (args)))\n-\t\t\t      {\n-\t\t\t\tdependent_p = true;\n-\t\t\t\tbreak;\n-\t\t\t      }\n-\t\t\t    args = TREE_CHAIN (args);\n-\t\t\t  }\n-\t\t      }\n-\t\t    else if (args && TREE_CODE (args) == TREE_VEC)\n-\t\t      {\n-\t\t\tint i; \n-\t\t\tfor (i = 0; i < TREE_VEC_LENGTH (args); ++i)\n-\t\t\t  if (dependent_template_arg_p (TREE_VEC_ELT (args, i)))\n-\t\t\t    {\n-\t\t\t      dependent_p = true;\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t      }\n-\n+\t\t    dependent_p = any_dependent_template_arguments_p (args);\n \t\t    /* The functions are those referred to by the\n \t\t       template-id.  */\n \t\t    fns = TREE_OPERAND (fns, 0);\n@@ -2687,27 +2667,34 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    /* Only certain kinds of names are allowed in constant\n \t       expression.  Enumerators have already been handled\n \t       above.  */\n-\t    if (parser->constant_expression_p\n+\t    if (parser->constant_expression_p)\n+\t      {\n \t\t/* Non-type template parameters of integral or\n-\t\t   enumeration type.  */\n-\t\t&& !(TREE_CODE (decl) == TEMPLATE_PARM_INDEX\n-\t\t     && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (decl)))\n+\t\t   enumeration type are OK.  */\n+\t\tif (TREE_CODE (decl) == TEMPLATE_PARM_INDEX\n+\t\t    && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (decl)))\n+\t\t  ;\n \t\t/* Const variables or static data members of integral\n \t\t   or enumeration types initialized with constant\n-                   expressions (or dependent expressions - in this case\n-                   the check will be done at instantiation time).  */\n-\t\t&& !(TREE_CODE (decl) == VAR_DECL\n-\t\t     && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (decl))\n-\t\t     && DECL_INITIAL (decl)\n-                     && (TREE_CONSTANT (DECL_INITIAL (decl))\n-                         || type_dependent_expression_p \n-                         (DECL_INITIAL (decl))\n-                         || value_dependent_expression_p \n-                         (DECL_INITIAL (decl)))))\n-\t      {\n-\t\tif (!parser->allow_non_constant_expression_p)\n-\t\t  return cp_parser_non_constant_id_expression (decl);\n-\t\tparser->non_constant_expression_p = true;\n+                   expressions are OK.  We also accept dependent\n+\t\t   initializers; they may turn out to be constant at\n+\t\t   instantiation-time.  */\n+\t\telse if (TREE_CODE (decl) == VAR_DECL\n+\t\t\t && CP_TYPE_CONST_P (TREE_TYPE (decl))\n+\t\t\t && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (decl))\n+\t\t\t && DECL_INITIAL (decl)\n+\t\t\t && (TREE_CONSTANT (DECL_INITIAL (decl))\n+\t\t\t     || type_dependent_expression_p (DECL_INITIAL \n+\t\t\t\t\t\t\t     (decl))\n+\t\t\t     || value_dependent_expression_p (DECL_INITIAL \n+\t\t\t\t\t\t\t      (decl))))\n+\t\t  ;\n+\t\telse\n+\t\t  {\n+\t\t    if (!parser->allow_non_constant_expression_p)\n+\t\t      return cp_parser_non_constant_id_expression (decl);\n+\t\t    parser->non_constant_expression_p = true;\n+\t\t  }\n \t      }\n \n \t    if (parser->scope)\n@@ -3792,7 +3779,6 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t\t    || TREE_CODE (postfix_expression) == IDENTIFIER_NODE)\n \t\t&& args)\n \t      {\n-\t\ttree arg;\n \t\ttree identifier = NULL_TREE;\n \t\ttree functions = NULL_TREE;\n \n@@ -3815,10 +3801,7 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \n \t\t   Do Koenig lookup -- unless any of the arguments are\n \t\t   type-dependent.  */\n-\t\tfor (arg = args; arg; arg = TREE_CHAIN (arg))\n-\t\t  if (type_dependent_expression_p (TREE_VALUE (arg)))\n-\t\t      break;\n-\t\tif (!arg)\n+\t\tif (!any_type_dependent_arguments_p (args))\n \t\t  {\n \t\t    postfix_expression \n \t\t      = lookup_arg_dependent (identifier, functions, args);\n@@ -3827,14 +3810,12 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t\t\t/* The unqualified name could not be resolved.  */\n \t\t\tunqualified_name_lookup_error (identifier);\n \t\t\tpostfix_expression = error_mark_node;\n+\t\t\tbreak;\n \t\t      }\n-\t\t    postfix_expression\n-\t\t      = build_call_from_tree (postfix_expression, args, \n-\t\t\t\t\t      /*diallow_virtual=*/false);\n-\t\t    break;\n \t\t  }\n-\t\tpostfix_expression = build_min_nt (LOOKUP_EXPR,\n-\t\t\t\t\t\t   identifier);\n+\t\telse\n+\t\t  postfix_expression = build_min_nt (LOOKUP_EXPR,\n+\t\t\t\t\t\t     identifier);\n \t      }\n \t    else if (idk == CP_PARSER_ID_KIND_UNQUALIFIED \n \t\t     && TREE_CODE (postfix_expression) == IDENTIFIER_NODE)\n@@ -3845,25 +3826,31 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t\tbreak;\n \t      }\n \n-\t    /* In the body of a template, no further processing is\n-\t       required.  */\n-\t    if (processing_template_decl)\n+\t    if (TREE_CODE (postfix_expression) == COMPONENT_REF)\n \t      {\n-\t\tpostfix_expression = build_nt (CALL_EXPR,\n-\t\t\t\t\t       postfix_expression, \n-\t\t\t\t\t       args);\n-\t\tbreak;\n+\t\ttree instance = TREE_OPERAND (postfix_expression, 0);\n+\t\ttree fn = TREE_OPERAND (postfix_expression, 1);\n+\n+\t\tif (processing_template_decl\n+\t\t    && (type_dependent_expression_p (instance)\n+\t\t\t|| (!BASELINK_P (fn)\n+\t\t\t    && TREE_CODE (fn) != FIELD_DECL)\n+\t\t\t|| any_type_dependent_arguments_p (args)))\n+\t\t  {\n+\t\t    postfix_expression\n+\t\t      = build_min_nt (CALL_EXPR, postfix_expression, args);\n+\t\t    break;\n+\t\t  }\n+\t\t  \n+\t\tpostfix_expression\n+\t\t  = (build_new_method_call \n+\t\t     (instance, fn, args, NULL_TREE, \n+\t\t      (idk == CP_PARSER_ID_KIND_QUALIFIED \n+\t\t       ? LOOKUP_NONVIRTUAL : LOOKUP_NORMAL)));\n \t      }\n-\n-\t    if (TREE_CODE (postfix_expression) == COMPONENT_REF)\n-\t      postfix_expression\n-\t\t= (build_new_method_call \n-\t\t   (TREE_OPERAND (postfix_expression, 0),\n-\t\t    TREE_OPERAND (postfix_expression, 1),\n-\t\t    args, NULL_TREE, \n-\t\t    (idk == CP_PARSER_ID_KIND_QUALIFIED \n-\t\t     ? LOOKUP_NONVIRTUAL : LOOKUP_NORMAL)));\n-\t    else if (TREE_CODE (postfix_expression) == OFFSET_REF)\n+\t    else if (TREE_CODE (postfix_expression) == OFFSET_REF\n+\t\t     || TREE_CODE (postfix_expression) == MEMBER_REF\n+\t\t     || TREE_CODE (postfix_expression) == DOTSTAR_EXPR)\n \t      postfix_expression = (build_offset_ref_call_from_tree\n \t\t\t\t    (postfix_expression, args));\n \t    else if (idk == CP_PARSER_ID_KIND_QUALIFIED)\n@@ -3967,8 +3954,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n                      struct X { void f(); };\n                      template <typename T> void f(T* t) { t->X::f(); }\n  \n-                   Even though \"t\" is dependent, \"X::f\" is not and has \n-\t\t   except that for a BASELINK there is no need to\n+                   Even though \"t\" is dependent, \"X::f\" is not and has\n+\t\t   been resolved to a BASELINK; there is no need to\n \t\t   include scope information.  */\n \n \t\t/* But we do need to remember that there was an explicit\n@@ -4336,7 +4323,8 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p)\n \t  return build_x_indirect_ref (cast_expression, \"unary *\");\n \t  \n \tcase ADDR_EXPR:\n-\t  return build_x_unary_op (ADDR_EXPR, cast_expression);\n+\tcase BIT_NOT_EXPR:\n+\t  return build_x_unary_op (unary_operator, cast_expression);\n \t  \n \tcase PREINCREMENT_EXPR:\n \tcase PREDECREMENT_EXPR:\n@@ -4354,9 +4342,6 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p)\n \tcase TRUTH_NOT_EXPR:\n \t  return finish_unary_op_expr (unary_operator, cast_expression);\n \n-\tcase BIT_NOT_EXPR:\n-\t  return build_x_unary_op (BIT_NOT_EXPR, cast_expression);\n-\n \tdefault:\n \t  abort ();\n \t  return error_mark_node;\n@@ -5293,7 +5278,6 @@ static tree\n cp_parser_expression (cp_parser* parser)\n {\n   tree expression = NULL_TREE;\n-  bool saw_comma_p = false;\n \n   while (true)\n     {\n@@ -5306,45 +5290,23 @@ cp_parser_expression (cp_parser* parser)\n \t save it away.  */\n       if (!expression)\n \texpression = assignment_expression;\n-      /* Otherwise, chain the expressions together.  It is unclear why\n-\t we do not simply build COMPOUND_EXPRs as we go.  */\n       else\n-\texpression = tree_cons (NULL_TREE, \n-\t\t\t\tassignment_expression,\n-\t\t\t\texpression);\n+\texpression = build_x_compound_expr (expression,\n+\t\t\t\t\t    assignment_expression);\n       /* If the next token is not a comma, then we are done with the\n \t expression.  */\n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA))\n \tbreak;\n       /* Consume the `,'.  */\n       cp_lexer_consume_token (parser->lexer);\n-      /* The first time we see a `,', we must take special action\n-\t because the representation used for a single expression is\n-\t different from that used for a list containing the single\n-\t expression.  */\n-      if (!saw_comma_p)\n-\t{\n-\t  /* Remember that this expression has a `,' in it.  */\n-\t  saw_comma_p = true;\n-\t  /* Turn the EXPRESSION into a TREE_LIST so that we can link\n-\t     additional expressions to it.  */\n-\t  expression = build_tree_list (NULL_TREE, expression);\n-\t}\n-    }\n-\n-  /* Build a COMPOUND_EXPR to represent the entire expression, if\n-     necessary.  We built up the list in reverse order, so we must\n-     straighten it out here.  */\n-  if (saw_comma_p)\n-    {\n       /* A comma operator cannot appear in a constant-expression.  */\n       if (parser->constant_expression_p)\n \t{\n \t  if (!parser->allow_non_constant_expression_p)\n-\t    return cp_parser_non_constant_expression (\"a comma operator\");\n+\t    expression \n+\t      = cp_parser_non_constant_expression (\"a comma operator\");\n \t  parser->non_constant_expression_p = true;\n \t}\n-      expression = build_x_compound_expr (nreverse (expression));\n     }\n \n   return expression;\n@@ -5356,8 +5318,9 @@ cp_parser_expression (cp_parser* parser)\n      conditional-expression  \n \n   If ALLOW_NON_CONSTANT_P a non-constant expression is silently\n-  accepted.  In that case *NON_CONSTANT_P is set to TRUE.  If\n-  ALLOW_NON_CONSTANT_P is false, NON_CONSTANT_P should be NULL.  */\n+  accepted.  If ALLOW_NON_CONSTANT_P is true and the expression is not\n+  constant, *NON_CONSTANT_P is set to TRUE.  If ALLOW_NON_CONSTANT_P\n+  is false, NON_CONSTANT_P should be NULL.  */\n \n static tree\n cp_parser_constant_expression (cp_parser* parser, \n@@ -5547,7 +5510,7 @@ cp_parser_labeled_statement (cp_parser* parser)\n \tcp_lexer_consume_token (parser->lexer);\n \t/* Parse the constant-expression.  */\n \texpr = cp_parser_constant_expression (parser, \n-\t\t\t\t\t      /*allow_non_constant=*/false,\n+\t\t\t\t\t      /*allow_non_constant_p=*/false,\n \t\t\t\t\t      NULL);\n \t/* Create the label.  */\n \tstatement = finish_case_label (expr, NULL_TREE);\n@@ -8051,13 +8014,21 @@ cp_parser_template_argument_list (cp_parser* parser)\n    The representation is that of an assignment-expression, type-id, or\n    id-expression -- except that the qualified id-expression is\n    evaluated, so that the value returned is either a DECL or an\n-   OVERLOAD.  */\n+   OVERLOAD.  \n+\n+   Although the standard says \"assignment-expression\", it forbids\n+   throw-expressions or assignments in the template argument.\n+   Therefore, we use \"conditional-expression\" instead.  */\n \n static tree\n cp_parser_template_argument (cp_parser* parser)\n {\n   tree argument;\n   bool template_p;\n+  bool address_p;\n+  cp_token *token;\n+  cp_parser_id_kind idk;\n+  tree qualifying_class;\n \n   /* There's really no way to know what we're looking at, so we just\n      try each alternative in order.  \n@@ -8073,8 +8044,7 @@ cp_parser_template_argument (cp_parser* parser)\n   argument = cp_parser_type_id (parser);\n   /* If the next token isn't a `,' or a `>', then this argument wasn't\n      really finished.  */\n-  if (cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA)\n-      && cp_lexer_next_token_is_not (parser->lexer, CPP_GREATER))\n+  if (!cp_parser_next_token_ends_template_argument_p (parser))\n     cp_parser_error (parser, \"expected template-argument\");\n   /* If that worked, we're done.  */\n   if (cp_parser_parse_definitely (parser))\n@@ -8088,8 +8058,7 @@ cp_parser_template_argument (cp_parser* parser)\n \t\t\t\t      &template_p);\n   /* If the next token isn't a `,' or a `>', then this argument wasn't\n      really finished.  */\n-  if (cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA)\n-      && cp_lexer_next_token_is_not (parser->lexer, CPP_GREATER))\n+  if (!cp_parser_next_token_ends_template_argument_p (parser))\n     cp_parser_error (parser, \"expected template-argument\");\n   if (!cp_parser_error_occurred (parser))\n     {\n@@ -8104,8 +8073,101 @@ cp_parser_template_argument (cp_parser* parser)\n     }\n   if (cp_parser_parse_definitely (parser))\n     return argument;\n-  /* It must be an assignment-expression.  */\n-  return cp_parser_assignment_expression (parser);\n+  /* It must be a non-type argument.  There permitted cases are given\n+     in [temp.arg.nontype]:\n+\n+     -- an integral constant-expression of integral or enumeration\n+        type; or\n+\n+     -- the name of a non-type template-parameter; or\n+\n+     -- the name of an object or function with external linkage...\n+\n+     -- the address of an object or function with external linkage...\n+\n+     -- a pointer to member... */\n+  /* Look for a non-type template parameter.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+    {\n+      cp_parser_parse_tentatively (parser);\n+      argument = cp_parser_primary_expression (parser,\n+\t\t\t\t\t       &idk,\n+\t\t\t\t\t       &qualifying_class);\n+      if (TREE_CODE (argument) != TEMPLATE_PARM_INDEX\n+\t  || !cp_parser_next_token_ends_template_argument_p (parser))\n+\tcp_parser_simulate_error (parser);\n+      if (cp_parser_parse_definitely (parser))\n+\treturn argument;\n+    }\n+  /* If the next token is \"&\", the argument must be the address of an\n+     object or function with external linkage.  */\n+  address_p = cp_lexer_next_token_is (parser->lexer, CPP_AND);\n+  if (address_p)\n+    cp_lexer_consume_token (parser->lexer);\n+  /* See if we might have an id-expression.  */\n+  token = cp_lexer_peek_token (parser->lexer);\n+  if (token->type == CPP_NAME\n+      || token->keyword == RID_OPERATOR\n+      || token->type == CPP_SCOPE\n+      || token->type == CPP_TEMPLATE_ID\n+      || token->type == CPP_NESTED_NAME_SPECIFIER)\n+    {\n+      cp_parser_parse_tentatively (parser);\n+      argument = cp_parser_primary_expression (parser,\n+\t\t\t\t\t       &idk,\n+\t\t\t\t\t       &qualifying_class);\n+      if (cp_parser_error_occurred (parser)\n+\t  || !cp_parser_next_token_ends_template_argument_p (parser))\n+\tcp_parser_abort_tentative_parse (parser);\n+      else\n+\t{\n+\t  if (qualifying_class)\n+\t    argument = finish_qualified_id_expr (qualifying_class,\n+\t\t\t\t\t\t argument,\n+\t\t\t\t\t\t /*done=*/true,\n+\t\t\t\t\t\t address_p);\n+\t  if (TREE_CODE (argument) == VAR_DECL)\n+\t    {\n+\t      /* A variable without external linkage might still be a\n+\t\t valid constant-expression, so no error is issued here\n+\t\t if the external-linkage check fails.  */\n+\t      if (!DECL_EXTERNAL_LINKAGE_P (argument))\n+\t\tcp_parser_simulate_error (parser);\n+\t    }\n+\t  else if (is_overloaded_fn (argument))\n+\t    /* All overloaded functions are allowed; if the external\n+\t       linkage test does not pass, an error will be issued\n+\t       later.  */\n+\t    ;\n+\t  else if (address_p\n+\t\t   && (TREE_CODE (argument) == OFFSET_REF \n+\t\t       || TREE_CODE (argument) == SCOPE_REF))\n+\t    /* A pointer-to-member.  */\n+\t    ;\n+\t  else\n+\t    cp_parser_simulate_error (parser);\n+\n+\t  if (cp_parser_parse_definitely (parser))\n+\t    {\n+\t      if (address_p)\n+\t\targument = build_x_unary_op (ADDR_EXPR, argument);\n+\t      return argument;\n+\t    }\n+\t}\n+    }\n+  /* If the argument started with \"&\", there are no other valid\n+     alternatives at this point.  */\n+  if (address_p)\n+    {\n+      cp_parser_error (parser, \"invalid non-type template argument\");\n+      return error_mark_node;\n+    }\n+  /* The argument must be a constant-expression. */\n+  argument = cp_parser_constant_expression (parser, \n+\t\t\t\t\t    /*allow_non_constant_p=*/false,\n+\t\t\t\t\t    /*non_constant_p=*/NULL);\n+  /* If it's non-dependent, simplify it.  */\n+  return cp_parser_fold_non_dependent_expr (argument);\n }\n \n /* Parse an explicit-instantiation.\n@@ -8914,7 +8976,7 @@ cp_parser_enumerator_definition (cp_parser* parser, tree type)\n       cp_lexer_consume_token (parser->lexer);\n       /* Parse the value.  */\n       value = cp_parser_constant_expression (parser, \n-\t\t\t\t\t     /*allow_non_constant=*/false,\n+\t\t\t\t\t     /*allow_non_constant_p=*/false,\n \t\t\t\t\t     NULL);\n     }\n   else\n@@ -9919,29 +9981,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t= cp_parser_constant_expression (parser,\n \t\t\t\t\t\t /*allow_non_constant=*/true,\n \t\t\t\t\t\t &non_constant_p);\n-\t      /* If we're in a template, but the constant-expression\n-\t\t isn't value dependent, simplify it.  We're supposed\n-\t\t to treat:\n-\n-\t\t   template <typename T> void f(T[1 + 1]);\n-\t\t   template <typename T> void f(T[2]);\n-\t\t   \n-\t\t as two declarations of the same function, for\n-\t\t example.  */\n-\t      if (processing_template_decl\n-\t\t  && !non_constant_p\n-\t\t  && !value_dependent_expression_p (bounds))\n-\t\t{\n-\t\t  HOST_WIDE_INT saved_processing_template_decl;\n-\n-\t\t  saved_processing_template_decl = processing_template_decl;\n-\t\t  processing_template_decl = 0;\n-\t\t  bounds = tsubst_copy_and_build (bounds, \n-\t\t\t\t\t\t  /*args=*/NULL_TREE,\n-\t\t\t\t\t\t  tf_error,\n-\t\t\t\t\t\t  /*in_decl=*/NULL_TREE);\n-\t\t  processing_template_decl = saved_processing_template_decl;\n-\t\t}\n+\t      if (!non_constant_p)\n+\t\tbounds = cp_parser_fold_non_dependent_expr (bounds);\n \t    }\n \t  else\n \t    bounds = NULL_TREE;\n@@ -14129,6 +14170,36 @@ cp_parser_declares_only_class_p (cp_parser *parser)\n \t  || cp_lexer_next_token_is (parser->lexer, CPP_COMMA));\n }\n \n+/* Simplify EXPR if it is a non-dependent expression.  Returns the\n+   (possibly simplified) expression.  */\n+\n+static tree\n+cp_parser_fold_non_dependent_expr (tree expr)\n+{\n+  /* If we're in a template, but EXPR isn't value dependent, simplify\n+     it.  We're supposed to treat:\n+     \n+       template <typename T> void f(T[1 + 1]);\n+       template <typename T> void f(T[2]);\n+\t\t   \n+     as two declarations of the same function, for example.  */\n+  if (processing_template_decl\n+      && !type_dependent_expression_p (expr)\n+      && !value_dependent_expression_p (expr))\n+    {\n+      HOST_WIDE_INT saved_processing_template_decl;\n+\n+      saved_processing_template_decl = processing_template_decl;\n+      processing_template_decl = 0;\n+      expr = tsubst_copy_and_build (expr,\n+\t\t\t\t    /*args=*/NULL_TREE,\n+\t\t\t\t    tf_error,\n+\t\t\t\t    /*in_decl=*/NULL_TREE);\n+      processing_template_decl = saved_processing_template_decl;\n+    }\n+  return expr;\n+}\n+\n /* DECL_SPECIFIERS is the representation of a decl-specifier-seq.\n    Returns TRUE iff `friend' appears among the DECL_SPECIFIERS.  */\n \n@@ -14274,6 +14345,18 @@ cp_parser_next_token_starts_class_definition_p (cp_parser *parser)\n   return (token->type == CPP_OPEN_BRACE || token->type == CPP_COLON);\n }\n \n+/* Returns TRUE iff the next token is the \",\" or \">\" ending a\n+   template-argument.  */\n+\n+static bool\n+cp_parser_next_token_ends_template_argument_p (cp_parser *parser)\n+{\n+  cp_token *token;\n+\n+  token = cp_lexer_peek_token (parser->lexer);\n+  return (token->type == CPP_COMMA || token->type == CPP_GREATER);\n+}\n+ \n /* Returns the kind of tag indicated by TOKEN, if it is a class-key,\n    or none_type otherwise.  */\n "}, {"sha": "4d650c5e23d030153b57036f052f2adc1ecddef1", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 225, "deletions": 104, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -167,7 +167,6 @@ static void copy_default_args_to_explicit_spec (tree);\n static int invalid_nontype_parm_type_p (tree, tsubst_flags_t);\n static int eq_local_specializations (const void *, const void *);\n static bool dependent_type_p_r (tree);\n-static bool dependent_template_id_p (tree, tree);\n static tree tsubst (tree, tree, tsubst_flags_t, tree);\n static tree tsubst_expr\t(tree, tree, tsubst_flags_t, tree);\n static tree tsubst_copy\t(tree, tree, tsubst_flags_t, tree);\n@@ -3594,9 +3593,6 @@ convert_template_argument (tree parm,\n       if (invalid_nontype_parm_type_p (t, complain))\n         return error_mark_node;\n       \n-      if (processing_template_decl)\n-\targ = maybe_fold_nontype_arg (arg);\n-\n       if (!uses_template_parms (arg) && !uses_template_parms (t))\n \t/* We used to call digest_init here.  However, digest_init\n \t   will report errors, which we don't want when complain\n@@ -7108,9 +7104,8 @@ tsubst_baselink (tree baselink, tree object_type,\n \ttemplate_id_p = true;\n \ttemplate_args = TREE_OPERAND (fns, 1);\n \tfns = TREE_OPERAND (fns, 0);\n-\ttemplate_args = tsubst_copy (template_args, args,\n-\t\t\t\t     complain, in_decl);\n-\tmaybe_fold_nontype_args (template_args);\n+\ttemplate_args = tsubst_copy_and_build (template_args, args,\n+\t\t\t\t\t       complain, in_decl);\n       }\n     name = DECL_NAME (get_first_fn (fns));\n     baselink = lookup_fnfields (qualifying_scope, name, /*protect=*/1);\n@@ -8003,30 +7998,17 @@ tsubst_copy_and_build (tree t,\n \n     case PREDECREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n-      if (TREE_TYPE (t))\n-\treturn tsubst_copy (t, args, complain, in_decl);\n-      else\n-\treturn build_x_unary_op\n-\t  (TREE_CODE (t),\n-\t   tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain,\n-\t\t\t\t  in_decl));\n-\n     case NEGATE_EXPR:\n     case BIT_NOT_EXPR:\n-      if (TREE_TYPE (t))\n-\treturn tsubst_copy (t, args, complain, in_decl);\n-      else\n-\treturn build_x_unary_op\n-\t  (TREE_CODE (t),\n-\t   tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain,\n-\t\t\t\t  in_decl));\n-\n     case ABS_EXPR:\n-      if (TREE_TYPE (t))\n-\treturn t;\n-      return build_x_unary_op\n-\t(TREE_CODE (t),\n-\t tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl));\n+    case TRUTH_NOT_EXPR:\n+    case CONVERT_EXPR:  /* Unary + */\n+    case REALPART_EXPR:\n+    case IMAGPART_EXPR:\n+      return (build_x_unary_op\n+\t      (TREE_CODE (t),\n+\t       tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain,\n+\t\t\t\t      in_decl)));\n \n     case ADDR_EXPR:\n       op1 = TREE_OPERAND (t, 0);\n@@ -8037,18 +8019,6 @@ tsubst_copy_and_build (tree t,\n \top1 = tsubst_copy_and_build (op1, args, complain, in_decl);\n       return build_x_unary_op (ADDR_EXPR, op1);\n \n-    case TRUTH_NOT_EXPR:\n-    case CONVERT_EXPR:  /* Unary + */\n-    case REALPART_EXPR:\n-    case IMAGPART_EXPR:\n-      if (TREE_TYPE (t))\n-\treturn tsubst_copy (t, args, complain, in_decl);\n-      else\n-\treturn build_x_unary_op\n-\t  (TREE_CODE (t),\n-\t   tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain,\n-\t\t\t\t  in_decl));\n-\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n     case MULT_EXPR:\n@@ -8119,15 +8089,25 @@ tsubst_copy_and_build (tree t,\n \n     case SIZEOF_EXPR:\n     case ALIGNOF_EXPR:\n-      {\n-\ttree r =\n-\t  tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, in_decl);\n-\tif (!TYPE_P (r))\n-\t  return TREE_CODE (t) == SIZEOF_EXPR ?\n-\t    expr_sizeof (r) : c_alignof_expr (r);\n-\telse\n-\t  return cxx_sizeof_or_alignof_type (r, TREE_CODE (t), true);\n-      }\n+      op1 = TREE_OPERAND (t, 0);\n+      if (!args)\n+\t{\n+\t  /* When there are no ARGS, we are trying to evaluate a\n+\t     non-dependent expression from the parser.  Trying to do\n+\t     the substitutions may not work.  */\n+\t  if (!TYPE_P (op1))\n+\t    op1 = TREE_TYPE (op1);\n+\t}\n+      else\n+\t{\n+\t  ++skip_evaluation;\n+\t  op1 = tsubst_copy_and_build (op1, args, complain, in_decl);\n+\t  --skip_evaluation;\n+\t}\n+      if (TREE_CODE (t) == SIZEOF_EXPR)\n+\treturn finish_sizeof (op1);\n+      else\n+\treturn finish_alignof (op1);\n \n     case MODOP_EXPR:\n       return build_x_modify_expr\n@@ -8162,15 +8142,11 @@ tsubst_copy_and_build (tree t,\n \tDELETE_EXPR_USE_GLOBAL (t));\n \n     case COMPOUND_EXPR:\n-      {\n-\tif (tsubst_copy (TREE_OPERAND (t, 1), args, complain, in_decl)\n-\t    == NULL_TREE)\n-\t  return build_x_compound_expr\n-\t    (tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain,\n-\t\t\t\t    in_decl));\n-\telse\n-\t  abort ();\n-      }\n+      return (build_x_compound_expr\n+\t      (tsubst_copy_and_build (TREE_OPERAND (t, 0), args, complain, \n+\t\t\t\t      in_decl),\n+\t       tsubst_copy_and_build (TREE_OPERAND (t, 1), args, complain, \n+\t\t\t\t      in_decl)));\n \n     case CALL_EXPR:\n       {\n@@ -8210,25 +8186,23 @@ tsubst_copy_and_build (tree t,\n \t\t\t\t\t   complain, in_decl);\n \t  \n \tif (BASELINK_P (function))\n-\t  return build_call_from_tree (function, call_args, 1);\n-\telse\n-\t  {\n-\t    if (call_args != NULL_TREE && koenig_name)\n-\t      function = lookup_arg_dependent (koenig_name,\n-\t\t\t\t\t       function, \n-\t\t\t\t\t       call_args);\n-\n-\t    if (TREE_CODE (function) == OFFSET_REF)\n-\t      return build_offset_ref_call_from_tree (function, call_args);\n-\t    if (TREE_CODE (function) == COMPONENT_REF)\n-\t      return (build_new_method_call \n-\t\t      (TREE_OPERAND (function, 0),\n-\t\t       TREE_OPERAND (function, 1),\n-\t\t       call_args, NULL_TREE, \n-\t\t       qualified_p ? LOOKUP_NONVIRTUAL : LOOKUP_NORMAL));\n-\t    return finish_call_expr (function, call_args, \n-\t\t\t\t     /*disallow_virtual=*/qualified_p);\n-\t  }\n+\t  qualified_p = 1;\n+\n+\tif (call_args != NULL_TREE && koenig_name)\n+\t  function = lookup_arg_dependent (koenig_name,\n+\t\t\t\t\t   function, \n+\t\t\t\t\t   call_args);\n+\n+\tif (TREE_CODE (function) == OFFSET_REF)\n+\t  return build_offset_ref_call_from_tree (function, call_args);\n+\tif (TREE_CODE (function) == COMPONENT_REF)\n+\t  return (build_new_method_call \n+\t\t  (TREE_OPERAND (function, 0),\n+\t\t   TREE_OPERAND (function, 1),\n+\t\t   call_args, NULL_TREE, \n+\t\t   qualified_p ? LOOKUP_NONVIRTUAL : LOOKUP_NORMAL));\n+\treturn finish_call_expr (function, call_args, \n+\t\t\t\t /*disallow_virtual=*/qualified_p);\n       }\n \n     case COND_EXPR:\n@@ -8389,6 +8363,11 @@ tsubst_copy_and_build (tree t,\n     case VAR_DECL:\n       if (args)\n \tt = tsubst_copy (t, args, complain, in_decl);\n+      else\n+\t/* If there are no ARGS, then we are evaluating a\n+\t   non-dependent expression.  If the expression is\n+\t   non-dependent, the variable must be a constant.  */\n+\tt = DECL_INITIAL (t);\n       return convert_from_reference (t);\n \n     case VA_ARG_EXPR:\n@@ -11491,26 +11470,46 @@ value_dependent_expression_p (tree expression)\n      with an expression that is value-dependent.  */\n   if (TREE_CODE (expression) == VAR_DECL\n       && DECL_INITIAL (expression)\n-      && INTEGRAL_OR_ENUMERATION_TYPE_P (expression)\n+      && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (expression))\n       && value_dependent_expression_p (DECL_INITIAL (expression)))\n     return true;\n   /* These expressions are value-dependent if the type to which the\n      cast occurs is dependent or the expression being casted is\n      value-dependent.  */\n-  if ((TREE_CODE (expression) == DYNAMIC_CAST_EXPR\n-       || TREE_CODE (expression) == STATIC_CAST_EXPR\n-       || TREE_CODE (expression) == CONST_CAST_EXPR\n-       || TREE_CODE (expression) == REINTERPRET_CAST_EXPR\n-       || TREE_CODE (expression) == CAST_EXPR)\n-      && (dependent_type_p (TREE_TYPE (expression))\n-   || value_dependent_expression_p (TREE_OPERAND (expression, 0))))\n-    return true;\n-  /* A `sizeof' expression where the sizeof operand is a type is\n-     value-dependent if the type is dependent.  If the type was not\n-     dependent, we would no longer have a SIZEOF_EXPR, so any\n-     SIZEOF_EXPR is dependent.  */\n-  if (TREE_CODE (expression) == SIZEOF_EXPR)\n-    return true;\n+  if (TREE_CODE (expression) == DYNAMIC_CAST_EXPR\n+      || TREE_CODE (expression) == STATIC_CAST_EXPR\n+      || TREE_CODE (expression) == CONST_CAST_EXPR\n+      || TREE_CODE (expression) == REINTERPRET_CAST_EXPR\n+      || TREE_CODE (expression) == CAST_EXPR)\n+    {\n+      if (dependent_type_p (TREE_TYPE (expression)))\n+\treturn true;\n+      /* A functional cast has a list of operands.  */\n+      expression = TREE_OPERAND (expression, 0);\n+      if (TREE_CODE (expression) == TREE_LIST)\n+\t{\n+\t  do\n+\t    {\n+\t      if (value_dependent_expression_p (TREE_VALUE (expression)))\n+\t\treturn true;\n+\t      expression = TREE_CHAIN (expression);\n+\t    }\n+\t  while (expression);\n+\t  return false;\n+\t}\n+      else\n+\treturn value_dependent_expression_p (expression);\n+    }\n+  /* A `sizeof' expression is value-dependent if the operand is\n+     type-dependent.  */\n+  if (TREE_CODE (expression) == SIZEOF_EXPR\n+      || TREE_CODE (expression) == ALIGNOF_EXPR)\n+    {\n+      expression = TREE_OPERAND (expression, 0);\n+      if (TYPE_P (expression))\n+\treturn dependent_type_p (expression);\n+      return type_dependent_expression_p (expression);\n+    }\n   /* A constant expression is value-dependent if any subexpression is\n      value-dependent.  */\n   if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (expression))))\n@@ -11574,10 +11573,11 @@ type_dependent_expression_p (tree expression)\n       || TREE_CODE (expression) == REINTERPRET_CAST_EXPR\n       || TREE_CODE (expression) == CAST_EXPR)\n     return dependent_type_p (TREE_TYPE (expression));\n+\n   /* The types of these expressions depends only on the type created\n      by the expression.  */\n-  else if (TREE_CODE (expression) == NEW_EXPR\n-\t   || TREE_CODE (expression) == VEC_NEW_EXPR)\n+  if (TREE_CODE (expression) == NEW_EXPR\n+      || TREE_CODE (expression) == VEC_NEW_EXPR)\n     {\n       /* For NEW_EXPR tree nodes created inside a template, either\n \t the object type itself or a TREE_LIST may appear as the\n@@ -11601,12 +11601,53 @@ type_dependent_expression_p (tree expression)\n \t   INNERMOST_TEMPLATE_ARGS (DECL_TI_ARGS (expression)))))\n     return true;\n \n+  if (TREE_TYPE (expression) == unknown_type_node)\n+    {\n+      if (TREE_CODE (expression) == ADDR_EXPR)\n+\treturn type_dependent_expression_p (TREE_OPERAND (expression, 0));\n+      if (TREE_CODE (expression) == BASELINK)\n+\texpression = BASELINK_FUNCTIONS (expression);\n+      if (TREE_CODE (expression) == TEMPLATE_ID_EXPR)\n+\t{\n+\t  if (any_dependent_template_arguments_p (TREE_OPERAND (expression, \n+\t\t\t\t\t\t\t\t1)))\n+\t    return true;\n+\t  expression = TREE_OPERAND (expression, 0);\n+\t}\n+      if (TREE_CODE (expression) == OVERLOAD)\n+\t{\n+\t  while (expression)\n+\t    {\n+\t      if (type_dependent_expression_p (OVL_CURRENT (expression)))\n+\t\treturn true;\n+\t      expression = OVL_NEXT (expression);\n+\t    }\n+\t  return false;\n+\t}\n+      abort ();\n+    }\n+  \n   return (dependent_type_p (TREE_TYPE (expression)));\n }\n \n-/* Returns TRUE if the ARG (a template argument) is dependent.  */\n+/* Returns TRUE if ARGS (a TREE_LIST of arguments to a function call)\n+   contains a type-dependent expression.  */\n \n bool\n+any_type_dependent_arguments_p (tree args)\n+{\n+  while (args)\n+    {\n+      if (type_dependent_expression_p (TREE_VALUE (args)))\n+\treturn true;\n+      args = TREE_CHAIN (args);\n+    }\n+  return false;\n+}\n+\n+/* Returns TRUE if the ARG (a template argument) is dependent.  */\n+\n+static bool\n dependent_template_arg_p (tree arg)\n {\n   if (!processing_template_decl)\n@@ -11622,18 +11663,36 @@ dependent_template_arg_p (tree arg)\n \t    || value_dependent_expression_p (arg));\n }\n \n-/* Returns TRUE if the specialization TMPL<ARGS> is dependent.  */\n+/* Returns true if ARGS (a collection of template arguments) contains\n+   any dependent arguments.  */\n \n-static bool\n-dependent_template_id_p (tree tmpl, tree args)\n+bool\n+any_dependent_template_arguments_p (tree args)\n {\n-  int i;\n+  if (!args)\n+    return false;\n+\n+  my_friendly_assert (TREE_CODE (args) == TREE_LIST\n+\t\t      || TREE_CODE (args) == TREE_VEC,\n+\t\t      20030707);\n+\n+  if (TREE_CODE (args) == TREE_LIST)\n+    {\n+      while (args)\n+\t{\n+\t  if (dependent_template_arg_p (TREE_VALUE (args)))\n+\t    return true;\n+\t  args = TREE_CHAIN (args);\n+\t}\n+    }\n+  else\n+    {\n+      int i; \n+      for (i = 0; i < TREE_VEC_LENGTH (args); ++i)\n+\tif (dependent_template_arg_p (TREE_VEC_ELT (args, i)))\n+\t  return true;\n+    }\n \n-  if (dependent_template_p (tmpl))\n-    return true;\n-  for (i = 0; i < TREE_VEC_LENGTH (args); ++i)\n-    if (dependent_template_arg_p (TREE_VEC_ELT (args, i)))\n-      return true;\n   return false;\n }\n \n@@ -11646,12 +11705,24 @@ dependent_template_p (tree tmpl)\n   if (DECL_TEMPLATE_TEMPLATE_PARM_P (tmpl)\n       || TREE_CODE (tmpl) == TEMPLATE_TEMPLATE_PARM)\n     return true;\n+  /* So are qualified names that have not been looked up.  */\n+  if (TREE_CODE (tmpl) == SCOPE_REF)\n+    return true;\n   /* So are member templates of dependent classes.  */\n   if (TYPE_P (CP_DECL_CONTEXT (tmpl)))\n     return dependent_type_p (DECL_CONTEXT (tmpl));\n   return false;\n }\n \n+/* Returns TRUE if the specialization TMPL<ARGS> is dependent.  */\n+\n+bool\n+dependent_template_id_p (tree tmpl, tree args)\n+{\n+  return (dependent_template_p (tmpl)\n+\t  || any_dependent_template_arguments_p (args));\n+}\n+\n /* TYPE is a TYPENAME_TYPE.  Returns the ordinary TYPE to which the\n    TYPENAME_TYPE corresponds.  Returns ERROR_MARK_NODE if no such TYPE\n    can be found.  Note that this function peers inside uninstantiated\n@@ -11730,4 +11801,54 @@ resolve_typename_type (tree type, bool only_current_p)\n   return type;\n }\n \n+/* EXPR is an expression which is not type-dependent.  Return a proxy\n+   for EXPR that can be used to compute the types of larger\n+   expressions containing EXPR.  */\n+\n+tree\n+build_non_dependent_expr (tree expr)\n+{\n+  /* Preserve null pointer constants so that the type of things like \n+     \"p == 0\" where \"p\" is a pointer can be determined.  */\n+  if (null_ptr_cst_p (expr))\n+    return expr;\n+  /* Preserve OVERLOADs; the functions must be available to resolve\n+     types.  */\n+  if (TREE_CODE (expr) == OVERLOAD)\n+    return expr;\n+  /* Otherwise, build a NON_DEPENDENT_EXPR.  \n+\n+     REFERENCE_TYPEs are not stripped for expressions in templates\n+     because doing so would play havoc with mangling.  Consider, for\n+     example:\n+\n+       template <typename T> void f<T& g>() { g(); } \n+\n+     In the body of \"f\", the expression for \"g\" will have\n+     REFERENCE_TYPE, even though the standard says that it should\n+     not.  The reason is that we must preserve the syntactic form of\n+     the expression so that mangling (say) \"f<g>\" inside the body of\n+     \"f\" works out correctly.  Therefore, the REFERENCE_TYPE is\n+     stripped here.  */\n+  return build (NON_DEPENDENT_EXPR, non_reference (TREE_TYPE (expr)));\n+}\n+\n+/* ARGS is a TREE_LIST of expressions as arguments to a function call.\n+   Return a new TREE_LIST with the various arguments replaced with\n+   equivalent non-dependent expressions.  */\n+\n+tree\n+build_non_dependent_args (tree args)\n+{\n+  tree a;\n+  tree new_args;\n+\n+  new_args = NULL_TREE;\n+  for (a = args; a; a = TREE_CHAIN (a))\n+    new_args = tree_cons (NULL_TREE, \n+\t\t\t  build_non_dependent_expr (TREE_VALUE (a)),\n+\t\t\t  new_args);\n+  return nreverse (new_args);\n+}\n+\n #include \"gt-cp-pt.h\""}, {"sha": "db9e4d2791b6e9b565e5d085f08ffb20e581acfd", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 46, "deletions": 22, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -1449,8 +1449,12 @@ finish_stmt_expr (tree rtl_expr)\n   tree result;\n \n   /* If the last thing in the statement-expression was not an\n-     expression-statement, then it has type `void'.  */\n-  if (!last_expr_type)\n+     expression-statement, then it has type `void'.  In a template, we\n+     cannot distinguish the case where the last expression-statement\n+     had a dependent type from the case where the last statement was\n+     not an expression-statement.  Therefore, we (incorrectly) treat\n+     the STMT_EXPR as dependent in that case.  */\n+  if (!last_expr_type && !processing_template_decl)\n     last_expr_type = void_type_node;\n   result = build_min (STMT_EXPR, last_expr_type, last_tree);\n   TREE_SIDE_EFFECTS (result) = 1;\n@@ -1482,16 +1486,32 @@ finish_stmt_expr (tree rtl_expr)\n tree \n finish_call_expr (tree fn, tree args, bool disallow_virtual)\n {\n+  tree result;\n+  tree orig_fn;\n+  tree orig_args;\n+\n   if (fn == error_mark_node || args == error_mark_node)\n     return error_mark_node;\n \n-  if (processing_template_decl)\n-    return build_nt (CALL_EXPR, fn, args, NULL_TREE);\n-\n   /* ARGS should be a list of arguments.  */\n   my_friendly_assert (!args || TREE_CODE (args) == TREE_LIST,\n \t\t      20020712);\n \n+  orig_fn = fn;\n+  orig_args = args;\n+\n+  if (processing_template_decl)\n+    {\n+      if (type_dependent_expression_p (fn)\n+\t  || any_type_dependent_arguments_p (args))\n+\treturn build_nt (CALL_EXPR, fn, args);\n+      if (!BASELINK_P (fn)\n+\t  && TREE_CODE (fn) != PSEUDO_DTOR_EXPR\n+\t  && TREE_TYPE (fn) != unknown_type_node)\n+\tfn = build_non_dependent_expr (fn);\n+      args = build_non_dependent_args (orig_args);\n+    }\n+\n   /* A reference to a member function will appear as an overloaded\n      function (rather than a BASELINK) if an unqualified name was used\n      to refer to it.  */\n@@ -1512,6 +1532,7 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual)\n \t}\n     }\n \n+  result = NULL_TREE;\n   if (BASELINK_P (fn))\n     {\n       tree object;\n@@ -1551,17 +1572,22 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual)\n \t  object = build_dummy_object (DECL_CONTEXT (representative_fn));\n \t}\n \n-      return build_new_method_call (object, fn, args, NULL_TREE,\n-\t\t\t\t    (disallow_virtual \n-\t\t\t\t     ? LOOKUP_NONVIRTUAL : 0));\n+      if (processing_template_decl)\n+\t{\n+\t  if (type_dependent_expression_p (object))\n+\t    return build_nt (CALL_EXPR, orig_fn, orig_args);\n+\t  object = build_non_dependent_expr (object);\n+\t}\n+\n+      result = build_new_method_call (object, fn, args, NULL_TREE,\n+\t\t\t\t      (disallow_virtual \n+\t\t\t\t       ? LOOKUP_NONVIRTUAL : 0));\n     }\n   else if (is_overloaded_fn (fn))\n     /* A call to a namespace-scope function.  */\n-    return build_new_function_call (fn, args);\n+    result = build_new_function_call (fn, args);\n   else if (TREE_CODE (fn) == PSEUDO_DTOR_EXPR)\n     {\n-      tree result;\n-\n       if (args)\n \terror (\"arguments to destructor are not allowed\");\n       /* Mark the pseudo-destructor call as having side-effects so\n@@ -1570,20 +1596,18 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual)\n \t\t       void_type_node,\n \t\t       TREE_OPERAND (fn, 0));\n       TREE_SIDE_EFFECTS (result) = 1;\n-      return result;\n     }\n   else if (CLASS_TYPE_P (TREE_TYPE (fn)))\n-    {\n-      /* If the \"function\" is really an object of class type, it might\n-\t have an overloaded `operator ()'.  */\n-      tree result;\n-      result = build_new_op (CALL_EXPR, LOOKUP_NORMAL, fn, args, NULL_TREE);\n-      if (result)\n-\treturn result;\n-    }\n+    /* If the \"function\" is really an object of class type, it might\n+       have an overloaded `operator ()'.  */\n+    result = build_new_op (CALL_EXPR, LOOKUP_NORMAL, fn, args, NULL_TREE);\n+  if (!result)\n+    /* A call where the function is unknown.  */\n+    result = build_function_call (fn, args);\n \n-  /* A call where the function is unknown.  */\n-  return build_function_call (fn, args);\n+  if (processing_template_decl)\n+    return build (CALL_EXPR, TREE_TYPE (result), orig_fn, orig_args);\n+  return result;\n }\n \n /* Finish a call to a postfix increment or decrement or EXPR.  (Which"}, {"sha": "366ea3ab01a88e89a3c945d91a7b7e374a241735", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -174,6 +174,14 @@ lvalue_p_1 (tree ref,\n       return (DECL_NONSTATIC_MEMBER_FUNCTION_P (ref) \n \t      ? clk_none : clk_ordinary);\n \n+    case NON_DEPENDENT_EXPR:\n+      /* We must consider NON_DEPENDENT_EXPRs to be lvalues so that\n+\t things like \"&E\" where \"E\" is an expression with a\n+\t non-dependent type work. It is safe to be lenient because an\n+\t error will be issued when the template is instantiated if \"E\"\n+\t is not an lvalue.  */\n+      return clk_ordinary;\n+\n     default:\n       break;\n     }"}, {"sha": "6d499d6c35f6c1a238eb94cb0843517764920043", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 148, "deletions": 274, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -1417,7 +1417,7 @@ cxx_sizeof_or_alignof_type (tree type, enum tree_code op, int complain)\n \n   my_friendly_assert (op == SIZEOF_EXPR || op == ALIGNOF_EXPR, 20020720);\n   if (processing_template_decl)\n-    return build_min_nt (op, type);\n+    return build_min (op, size_type_node, type);\n   \n   op_name = operator_name_info[(int) op].name;\n \n@@ -1446,7 +1446,7 @@ tree\n expr_sizeof (tree e)\n {\n   if (processing_template_decl)\n-    return build_min_nt (SIZEOF_EXPR, e);\n+    return build_min (SIZEOF_EXPR, size_type_node, e);\n \n   if (TREE_CODE (e) == COMPONENT_REF\n       && DECL_C_BIT_FIELD (TREE_OPERAND (e, 1)))\n@@ -2015,17 +2015,36 @@ lookup_destructor (tree object, tree scope, tree dtor_name)\n tree\n finish_class_member_access_expr (tree object, tree name)\n {\n+  tree expr;\n   tree object_type;\n   tree member;\n   tree access_path = NULL_TREE;\n+  tree orig_object = object;\n+  tree orig_name = name;\n \n   if (object == error_mark_node || name == error_mark_node)\n     return error_mark_node;\n \n+  object_type = TREE_TYPE (object);\n+\n   if (processing_template_decl)\n-    return build_min_nt (COMPONENT_REF, object, name);\n+    {\n+      if (/* If OBJECT_TYPE is dependent, so is OBJECT.NAME.  */\n+\t  dependent_type_p (object_type)\n+\t  /* If NAME is \"f<args>\", where either 'f' or 'args' is\n+\t     dependent, then the expression is dependent.  */\n+\t  || (TREE_CODE (name) == TEMPLATE_ID_EXPR\n+\t      && dependent_template_id_p (TREE_OPERAND (name, 0),\n+\t\t\t\t\t  TREE_OPERAND (name, 1)))\n+\t  /* If NAME is \"T::X\" where \"T\" is dependent, then the\n+\t     expression is dependent.  */\n+\t  || (TREE_CODE (name) == SCOPE_REF\n+\t      && TYPE_P (TREE_OPERAND (name, 0))\n+\t      && dependent_type_p (TREE_OPERAND (name, 0))))\n+\treturn build_min_nt (COMPONENT_REF, object, name);\n+      object = build_non_dependent_expr (object);\n+    }\n   \n-  object_type = TREE_TYPE (object);\n   if (TREE_CODE (object_type) == REFERENCE_TYPE)\n     {\n       object = convert_from_reference (object);\n@@ -2057,6 +2076,7 @@ finish_class_member_access_expr (tree object, tree name)\n     {\n       bool is_template_id = false;\n       tree template_args = NULL_TREE;\n+      tree scope;\n \n       if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n \t{\n@@ -2067,8 +2087,6 @@ finish_class_member_access_expr (tree object, tree name)\n \n       if (TREE_CODE (name) == SCOPE_REF)\n \t{\n-\t  tree scope;\n-\n \t  /* A qualified name.  The qualifying class or namespace `S' has\n \t     already been looked up; it is either a TYPE or a\n \t     NAMESPACE_DECL.  The member name is either an IDENTIFIER_NODE\n@@ -2095,57 +2113,35 @@ finish_class_member_access_expr (tree object, tree name)\n \t  access_path = lookup_base (object_type, scope, ba_check, NULL);\n \t  if (!access_path || access_path == error_mark_node)\n \t    return error_mark_node;\n-\n-\t  if (TREE_CODE (name) == BIT_NOT_EXPR)\n-\t    member = lookup_destructor (object, scope, name);\n-\t  else\n-\t    {\n-\t      /* Look up the member.  */\n-\t      member = lookup_member (access_path, name, /*protect=*/1, \n-\t\t\t\t      /*want_type=*/false);\n-\t      if (member == NULL_TREE)\n-\t\t{\n-\t\t  error (\"'%D' has no member named '%E'\", object_type, name);\n-\t\t  return error_mark_node;\n-\t\t}\n-\t      if (member == error_mark_node)\n-\t\treturn error_mark_node;\n-\t    }\n \t}\n-      else if (TREE_CODE (name) == BIT_NOT_EXPR)\n-\tmember = lookup_destructor (object, /*scope=*/NULL_TREE, name);\n-      else if (TREE_CODE (name) == IDENTIFIER_NODE)\n+      else\n+\t{\n+\t  scope = NULL_TREE;\n+\t  access_path = object_type;\n+\t}\n+\n+      if (TREE_CODE (name) == BIT_NOT_EXPR)\n+\tmember = lookup_destructor (object, scope, name);\n+      else\n \t{\n-\t  /* An unqualified name.  */\n-\t  member = lookup_member (object_type, name, /*protect=*/1, \n+\t  /* Look up the member.  */\n+\t  member = lookup_member (access_path, name, /*protect=*/1, \n \t\t\t\t  /*want_type=*/false);\n \t  if (member == NULL_TREE)\n \t    {\n \t      error (\"'%D' has no member named '%E'\", object_type, name);\n \t      return error_mark_node;\n \t    }\n-\t  else if (member == error_mark_node)\n+\t  if (member == error_mark_node)\n \t    return error_mark_node;\n \t}\n-      else\n-\t{\n-\t  /* The YACC parser sometimes gives us things that are not names.\n-\t     These always indicate errors.  The recursive-descent parser\n-\t     does not do this, so this code can go away once that parser\n-\t     replaces the YACC parser.  */\n-\t  error (\"invalid use of `%D'\", name);\n-\t  return error_mark_node;\n-\t}\n       \n       if (is_template_id)\n \t{\n \t  tree template = member;\n \t  \n \t  if (BASELINK_P (template))\n-\t    BASELINK_FUNCTIONS (template) \n-\t      = build_nt (TEMPLATE_ID_EXPR,\n-\t\t\t  BASELINK_FUNCTIONS (template),\n-\t\t\t  template_args);\n+\t    template = lookup_template_function (template, template_args);\n \t  else\n \t    {\n \t      error (\"`%D' is not a member template function\", name);\n@@ -2157,8 +2153,12 @@ finish_class_member_access_expr (tree object, tree name)\n   if (TREE_DEPRECATED (member))\n     warn_deprecated_use (member);\n \n-  return build_class_member_access_expr (object, member, access_path,\n+  expr = build_class_member_access_expr (object, member, access_path,\n \t\t\t\t\t /*preserve_reference=*/false);\n+  if (processing_template_decl && expr != error_mark_node)\n+    return build_min (COMPONENT_REF, TREE_TYPE (expr), orig_object, \n+\t\t      orig_name);\n+  return expr;\n }\n \n /* Return an expression for the MEMBER_NAME field in the internal\n@@ -2196,18 +2196,27 @@ build_ptrmemfunc_access_expr (tree ptrmem, tree member_name)\n    Must also handle REFERENCE_TYPEs for C++.  */\n \n tree\n-build_x_indirect_ref (tree ptr, const char *errorstring)\n+build_x_indirect_ref (tree expr, const char *errorstring)\n {\n+  tree orig_expr = expr;\n   tree rval;\n \n   if (processing_template_decl)\n-    return build_min_nt (INDIRECT_REF, ptr);\n+    {\n+      if (type_dependent_expression_p (expr))\n+\treturn build_min_nt (INDIRECT_REF, expr);\n+      expr = build_non_dependent_expr (expr);\n+    }\n \n-  rval = build_new_op (INDIRECT_REF, LOOKUP_NORMAL, ptr, NULL_TREE,\n+  rval = build_new_op (INDIRECT_REF, LOOKUP_NORMAL, expr, NULL_TREE,\n \t\t       NULL_TREE);\n-  if (rval)\n+  if (!rval)\n+    rval = build_indirect_ref (expr, errorstring);\n+\n+  if (processing_template_decl && rval != error_mark_node)\n+    return build_min (INDIRECT_REF, TREE_TYPE (rval), orig_expr);\n+  else\n     return rval;\n-  return build_indirect_ref (ptr, errorstring);\n }\n \n tree\n@@ -2826,192 +2835,33 @@ convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n tree\n build_x_binary_op (enum tree_code code, tree arg1, tree arg2)\n {\n-  if (processing_template_decl)\n-    return build_min_nt (code, arg1, arg2);\n-\n-  if (code == DOTSTAR_EXPR)\n-    return build_m_component_ref (arg1, arg2);\n-\n-  return build_new_op (code, LOOKUP_NORMAL, arg1, arg2, NULL_TREE);\n-}\n-\n-#if 0\n+  tree orig_arg1;\n+  tree orig_arg2;\n+  tree expr;\n \n-tree\n-build_template_expr (enum tree_code code, tree op0, tree op1, tree op2)\n-{\n-  tree type;\n+  orig_arg1 = arg1;\n+  orig_arg2 = arg2;\n \n-  /* If any of the operands is erroneous the result is erroneous too.  */\n-  if (error_operand_p (op0)\n-      || (op1 && error_operand_p (op1))\n-      || (op2 && error_operand_p (op2)))\n-    return error_mark_node;\n-      \n-  if (dependent_type_p (TREE_TYPE (op0))\n-      || (op1 && dependent_type_p (TREE_TYPE (op1)))\n-      || (op2 && dependent_type_p (TREE_TYPE (op2))))\n-    /* If at least one operand has a dependent type, we cannot\n-       determine the type of the expression until instantiation time.  */\n-    type = NULL_TREE;\n-  else\n+  if (processing_template_decl)\n     {\n-      struct z_candidate *cand;\n-      tree op0_type;\n-      tree op1_type;\n-      tree op2_type;\n-\n-      /* None of the operands is dependent, so we can compute the type\n-\t of the expression at this point.  We must compute the type so\n-\t that in things like:\n-\n-\t   template <int I>\n-\t   void f() { S<sizeof(I + 3)> s; ... }\n+      if (type_dependent_expression_p (arg1)\n+\t  || type_dependent_expression_p (arg2))\n+\treturn build_min_nt (code, arg1, arg2);\n+      arg1 = build_non_dependent_expr (arg1);\n+      arg2 = build_non_dependent_expr (arg2);\n+    }\n \n-\t we can tell that the type of \"s\" is non-dependent.\n+  if (code == DOTSTAR_EXPR)\n+    expr = build_m_component_ref (arg1, arg2);\n+  else\n+    expr = build_new_op (code, LOOKUP_NORMAL, arg1, arg2, NULL_TREE);\n \n-\t If we're processing a template argument, we do not want to\n-\t actually change the operands in any way.  Adding conversions,\n-\t performing constant folding, etc., would all change mangled\n-\t names.  For example, in:\n-\t \n-\t   template <int I>\n-\t   void f(S<sizeof(3 + 4 + I)>);\n-\t \n-\t we need to determine that \"3 + 4 + I\" has type \"int\", without\n-\t actually turning the expression into \"7 + I\".  */\n-      cand = find_overloaded_op (code, op0, op1, op2);\n-      if (cand) \n-\t/* If an overloaded operator was found, the expression will\n-\t   have the type returned by the function.  */\n-\ttype = non_reference (TREE_TYPE (cand->fn));\n-      else\n-\t{\n-\t  /* There is no overloaded operator so we can just use the\n-\t     default rules for determining the type of the operand.  */\n-\t  op0_type = TREE_TYPE (op0);\n-\t  op1_type = op1 ? TREE_TYPE (op1) : NULL_TREE;\n-\t  op2_type = op2 ? TREE_TYPE (op2) : NULL_TREE;\n-\t  type = NULL_TREE;\n-\n-\t  switch (code)\n-\t    {\n-\t    case MODIFY_EXPR:\n-\t      /* [expr.ass]\n-\n-\t\t The result of the assignment operation is the value\n-\t\t stored in the left operand.  */\n-\t      type = op0_type;\n-\t      break;\n-\t    case COMPONENT_REF:\n-\t      /* Implement this case.  */\n-\t      break;\n-\t    case POSTINCREMENT_EXPR:\n-\t    case POSTDECREMENT_EXPR:\n-\t      /* [expr.post.incr]\n-\n-\t\t The type of the result is the cv-unqualified version\n-\t\t of the type of the operand.  */\n-\t      type = TYPE_MAIN_VARIANT (op0_type);\n-\t      break;\n-\t    case PREINCREMENT_EXPR:\n-\t    case PREDECREMENT_EXPR:\n-\t      /* [expr.pre.incr]\n-\n-\t\t The value is the new value of the operand.  */\n-\t      type = op0_type;\n-\t      break;\n-\t    case INDIRECT_REF:\n-\t      /* [expr.unary.op]\n-\n-\t\t If the type of the expression is \"pointer to T\", the\n-\t\t type of the result is \"T\".  */\n-\t      type = TREE_TYPE (op0_type);\n-\t      break;\n-\t    case ADDR_EXPR:\n-\t      /* [expr.unary.op]\n-\n-\t\t If the type of the expression is \"T\", the type of the\n-\t\t result is \"pointer to T\".  */\n-\t      /* FIXME: Handle the pointer-to-member case.  */\n-\t      break;\n-\t    case MEMBER_REF:\n-\t      /* FIXME: Implement this case.  */\n-\t      break;\n-\t    case LSHIFT_EXPR:\n-\t    case RSHIFT_EXPR:\n-\t      /* [expr.shift]\n-\n-\t\t The type of the result is that of the promoted left\n-\t\t operand.  */\n-\t      break;\n-\t    case PLUS_EXPR:\n-\t    case MINUS_EXPR:\n-\t      /* FIXME: Be careful of special pointer-arithmetic\n-\t\t cases.  */\n-\t      /* Fall through.  */\n-\t    case MAX_EXPR:\n-\t    case MIN_EXPR:\n-\t      /* These are GNU extensions; the result type is computed\n-\t\t as it would be for other arithmetic operators.  */\n-\t      /* Fall through.  */\n-\t    case BIT_AND_EXPR:\n-\t    case BIT_XOR_EXPR:\n-\t    case BIT_IOR_EXPR:\n-\t    case MULT_EXPR:\n-\t    case TRUNC_DIV_EXPR:\n-\t    case TRUNC_MOD_EXPR:\n-\t      /* [expr.bit.and], [expr.xor], [expr.or], [expr.mul]\n-\n-\t\t The usual arithmetic conversions are performed on the\n-\t\t operands and determine the type of the result.  */\n-\t      /* FIXME: Check that this is possible.  */\n-\t      type = type_after_usual_arithmetic_conversions (t1, t2);\n-\t      break;\n-\t    case GT_EXPR:\n-\t    case LT_EXPR:\n-\t    case GE_EXPR:\n-\t    case LE_EXPR:\n-\t    case EQ_EXPR:\n-\t    case NE_EXPR:\n-\t      /* [expr.rel]\n-\n-\t\t The type of the result is bool.  */\n-\t      type = boolean_type_node;\n-\t      break;\n-\t    case TRUTH_ANDIF_EXPR:\n-\t    case TRUTH_ORIF_EXPR:\n-\t      /* [expr.log.and], [expr.log.org]\n-\t\t \n-\t\t The result is a bool.  */\n-\t      type = boolean_type_node;\n-\t      break;\n-\t    case COND_EXPR:\n-\t      /* FIXME: Handle special rules for conditional\n-\t\t expressions.  */\n-\t      break;\n-\t    case COMPOUND_EXPR:\n-\t      type = op1_type;\n-\t      break;\n-\t    default:\n-\t      abort ();\n-\t    }\n-\t  /* If the type of the expression could not be determined,\n-\t     something is wrong.  */\n-\t  if (!type)\n-\t    abort ();\n-\t  /* If the type is erroneous, the expression is erroneous\n-\t     too.  */\n-\t  if (type == error_mark_node)\n-\t    return error_mark_node;\n-\t}\n-    }\n+  if (processing_template_decl && expr != error_mark_node)\n+    return build_min (code, TREE_TYPE (expr), orig_arg1, orig_arg2);\n   \n-  return build_min (code, type, op0, op1, op2, NULL_TREE);\n+  return expr;\n }\n \n-#endif\n-\n /* Build a binary-operation expression without default conversions.\n    CODE is the kind of expression to build.\n    This function differs from `build' in several ways:\n@@ -3839,11 +3689,18 @@ pointer_diff (register tree op0, register tree op1, register tree ptrtype)\n tree\n build_x_unary_op (enum tree_code code, tree xarg)\n {\n+  tree orig_expr = xarg;\n   tree exp;\n   int ptrmem = 0;\n   \n   if (processing_template_decl)\n-    return build_min_nt (code, xarg, NULL_TREE);\n+    {\n+      if (type_dependent_expression_p (xarg))\n+\treturn build_min_nt (code, xarg, NULL_TREE);\n+      xarg = build_non_dependent_expr (xarg);\n+    }\n+\n+  exp = NULL_TREE;\n \n   /* & rec, on incomplete RECORD_TYPEs is the simple opr &, not an\n      error message.  */\n@@ -3854,15 +3711,8 @@ build_x_unary_op (enum tree_code code, tree xarg)\n \t  || (TREE_CODE (xarg) == OFFSET_REF)))\n     /* don't look for a function */;\n   else\n-    {\n-      tree rval;\n-\n-      rval = build_new_op (code, LOOKUP_NORMAL, xarg,\n-\t\t\t   NULL_TREE, NULL_TREE);\n-      if (rval || code != ADDR_EXPR)\n-\treturn rval;\n-    }\n-  if (code == ADDR_EXPR)\n+    exp = build_new_op (code, LOOKUP_NORMAL, xarg, NULL_TREE, NULL_TREE);\n+  if (!exp && code == ADDR_EXPR)\n     {\n       /*  A pointer to member-function can be formed only by saying\n \t  &X::mf.  */\n@@ -3896,16 +3746,17 @@ build_x_unary_op (enum tree_code code, tree xarg)\n \t\t\t    TREE_OPERAND (xarg, 0),\n \t\t\t    ovl_cons (TREE_OPERAND (xarg, 1), NULL_TREE));\n \t      PTRMEM_OK_P (xarg) = ptrmem;\n-\t    }\n-\t      \n+\t    }\t      \n         }\n       else if (TREE_CODE (xarg) == TARGET_EXPR)\n \twarning (\"taking address of temporary\");\n+      exp = build_unary_op (ADDR_EXPR, xarg, 0);\n+      if (TREE_CODE (exp) == ADDR_EXPR)\n+\tPTRMEM_OK_P (exp) = ptrmem;\n     }\n-  exp = build_unary_op (code, xarg, 0);\n-  if (TREE_CODE (exp) == ADDR_EXPR)\n-    PTRMEM_OK_P (exp) = ptrmem;\n \n+  if (processing_template_decl && exp != error_mark_node)\n+    return build_min (code, TREE_TYPE (exp), orig_expr);\n   return exp;\n }\n \n@@ -4631,53 +4482,76 @@ cxx_mark_addressable (tree exp)\n tree\n build_x_conditional_expr (tree ifexp, tree op1, tree op2)\n {\n-  if (processing_template_decl)\n-    return build_min_nt (COND_EXPR, ifexp, op1, op2);\n+  tree orig_ifexp = ifexp;\n+  tree orig_op1 = op1;\n+  tree orig_op2 = op2;\n+  tree expr;\n \n-  return build_conditional_expr (ifexp, op1, op2);\n+  if (processing_template_decl)\n+    {\n+      /* The standard says that the expression is type-dependent if\n+\t IFEXP is type-dependent, even though the eventual type of the\n+\t expression doesn't dependent on IFEXP.  */\n+      if (type_dependent_expression_p (ifexp)\n+\t  || type_dependent_expression_p (op1)\n+\t  || type_dependent_expression_p (op2))\n+\treturn build_min_nt (COND_EXPR, ifexp, op1, op2);\n+      ifexp = build_non_dependent_expr (ifexp);\n+      op1 = build_non_dependent_expr (op1);\n+      op2 = build_non_dependent_expr (op2);\n+    }\n+\n+  expr = build_conditional_expr (ifexp, op1, op2);\n+  if (processing_template_decl && expr != error_mark_node)\n+    return build_min (COND_EXPR, TREE_TYPE (expr), \n+\t\t      orig_ifexp, orig_op1, orig_op2);\n+  return expr;\n }\n \f\n /* Handle overloading of the ',' operator when needed.  Otherwise,\n    this function just builds an expression list.  */\n \n tree\n-build_x_compound_expr (tree list)\n+build_x_compound_expr (tree op1, tree op2)\n {\n-  tree rest = TREE_CHAIN (list);\n   tree result;\n+  tree orig_op1 = op1;\n+  tree orig_op2 = op2;\n \n   if (processing_template_decl)\n-    return build_min_nt (COMPOUND_EXPR, list, NULL_TREE);\n-\n-  if (rest == NULL_TREE)\n-    return build_compound_expr (list);\n+    {\n+      if (type_dependent_expression_p (op1)\n+\t  || type_dependent_expression_p (op2))\n+\treturn build_min_nt (COMPOUND_EXPR, op1, op2);\n+      op1 = build_non_dependent_expr (op1);\n+      op2 = build_non_dependent_expr (op2);\n+    }\n \n-  result = build_new_op (COMPOUND_EXPR, LOOKUP_NORMAL,\n-\t\t\t TREE_VALUE (list), TREE_VALUE (rest), NULL_TREE);\n-  if (result)\n-    return build_x_compound_expr (tree_cons (NULL_TREE, result,\n-\t\t\t\t\t\t  TREE_CHAIN (rest)));\n-\n-  if (! TREE_SIDE_EFFECTS (TREE_VALUE (list)))\n-    {\n-      /* FIXME: This test should be in the implicit cast to void of the LHS.  */\n-      /* the left-hand operand of a comma expression is like an expression\n-         statement: we should warn if it doesn't have any side-effects,\n-         unless it was explicitly cast to (void).  */\n-      if (warn_unused_value\n-           && !(TREE_CODE (TREE_VALUE(list)) == CONVERT_EXPR\n-                && VOID_TYPE_P (TREE_TYPE (TREE_VALUE(list)))))\n-        warning(\"left-hand operand of comma expression has no effect\");\n-    }\n-#if 0 /* this requires a gcc backend patch to export warn_if_unused_value */\n-  else if (warn_unused_value)\n-    warn_if_unused_value (TREE_VALUE(list));\n-#endif\n+  result = build_new_op (COMPOUND_EXPR, LOOKUP_NORMAL, op1, op2, NULL_TREE);\n+  if (!result)\n+    {\n+      if (! TREE_SIDE_EFFECTS (op1))\n+\t{\n+\t  /* FIXME: This test should be in the implicit cast to void\n+\t     of the LHS.  */\n+\t  /* the left-hand operand of a comma expression is like an expression\n+\t     statement: we should warn if it doesn't have any side-effects,\n+\t     unless it was explicitly cast to (void).  */\n+\t  if (warn_unused_value\n+\t      && !(TREE_CODE (op1) == CONVERT_EXPR\n+\t\t   && VOID_TYPE_P (TREE_TYPE (op1))))\n+\t    warning(\"left-hand operand of comma expression has no effect\");\n+\t}\n+      result = build_compound_expr (tree_cons (NULL_TREE,\n+\t\t\t\t\t       op1,\n+\t\t\t\t\t       build_tree_list (NULL_TREE,\n+\t\t\t\t\t\t\t\top2)));\n+    }\n \n-  return build_compound_expr\n-    (tree_cons (NULL_TREE, TREE_VALUE (list),\n-\t\t     build_tree_list (NULL_TREE,\n-\t\t\t\t      build_x_compound_expr (rest))));\n+  if (processing_template_decl && result != error_mark_node)\n+    return build_min (COMPOUND_EXPR, TREE_TYPE (result), \n+\t\t      orig_op1, orig_op2);\n+  return result;\n }\n \n /* Given a list of expressions, return a compound expression"}, {"sha": "6a14fecb4a99f51c7ba8661cb75c2c4184f88092", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -980,44 +980,48 @@ build_scoped_ref (tree datum, tree basetype, tree* binfo_p)\n    delegation is detected.  */\n \n tree\n-build_x_arrow (tree datum)\n+build_x_arrow (tree expr)\n {\n+  tree orig_expr = expr;\n   tree types_memoized = NULL_TREE;\n-  register tree rval = datum;\n-  tree type = TREE_TYPE (rval);\n+  tree type = TREE_TYPE (expr);\n   tree last_rval = NULL_TREE;\n \n   if (type == error_mark_node)\n     return error_mark_node;\n \n   if (processing_template_decl)\n-    return build_min_nt (ARROW_EXPR, rval);\n+    {\n+      if (type_dependent_expression_p (expr))\n+\treturn build_min_nt (ARROW_EXPR, expr);\n+      expr = build_non_dependent_expr (expr);\n+    }\n \n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     {\n-      rval = convert_from_reference (rval);\n-      type = TREE_TYPE (rval);\n+      expr = convert_from_reference (expr);\n+      type = TREE_TYPE (expr);\n     }\n \n   if (IS_AGGR_TYPE (type))\n     {\n-      while ((rval = build_new_op (COMPONENT_REF, LOOKUP_NORMAL, rval,\n+      while ((expr = build_new_op (COMPONENT_REF, LOOKUP_NORMAL, expr,\n \t\t\t\t   NULL_TREE, NULL_TREE)))\n \t{\n-\t  if (rval == error_mark_node)\n+\t  if (expr == error_mark_node)\n \t    return error_mark_node;\n \n-\t  if (value_member (TREE_TYPE (rval), types_memoized))\n+\t  if (value_member (TREE_TYPE (expr), types_memoized))\n \t    {\n \t      error (\"circular pointer delegation detected\");\n \t      return error_mark_node;\n \t    }\n \t  else\n \t    {\n-\t      types_memoized = tree_cons (NULL_TREE, TREE_TYPE (rval),\n+\t      types_memoized = tree_cons (NULL_TREE, TREE_TYPE (expr),\n \t\t\t\t\t  types_memoized);\n \t    }\n-\t  last_rval = rval;\n+\t  last_rval = expr;\n \t}     \n \n       if (last_rval == NULL_TREE)\n@@ -1030,10 +1034,17 @@ build_x_arrow (tree datum)\n \tlast_rval = convert_from_reference (last_rval);\n     }\n   else\n-    last_rval = decay_conversion (rval);\n+    last_rval = decay_conversion (expr);\n \n   if (TREE_CODE (TREE_TYPE (last_rval)) == POINTER_TYPE)\n-    return build_indirect_ref (last_rval, NULL);\n+    {\n+      if (processing_template_decl)\n+\treturn build_min (ARROW_EXPR, \n+\t\t\t  TREE_TYPE (TREE_TYPE (last_rval)), \n+\t\t\t  orig_expr);\n+\n+      return build_indirect_ref (last_rval, NULL);\n+    }\n \n   if (types_memoized)\n     error (\"result of `operator->()' yields non-pointer result\");"}, {"sha": "e268055cb8e30d9f669022667ef743a72a4dae6c", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -2908,7 +2908,8 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \n       if (IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code)))\n \t{\n-\t  arg0 = TREE_OPERAND (exp, 0);\n+\t  if (first_rtl_op (code) > 0)\n+\t    arg0 = TREE_OPERAND (exp, 0);\n \t  if (TREE_CODE_CLASS (code) == '<'\n \t      || TREE_CODE_CLASS (code) == '1'\n \t      || TREE_CODE_CLASS (code) == '2')"}, {"sha": "859e8a5059a5860503e4ce429a733204553c455e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -1,3 +1,14 @@\n+2003-07-08  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/abi/mangle17.C: Make sure template expressions are\n+\tdependent.\n+\t* g++.dg/abi/mangle4.C: Mark erroneous casts.\n+\t* g++.dg/debug/debug7.C: Mark erronous new-declarator.\n+\t* g++.dg/opt/stack1.C: Remove erroneous code.\n+\t* g++.dg/parse/template7.C: New test.\n+\t* g++.dg/template/dependent-expr1.C: Mark erroneous code.\n+\t* g++.old-deja/g++.pt/crash4.C: Likewise.\n+\n 2003-07-09  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* gcc.dg/const-elim-1.c (dg-final): Change regexp to match labels"}, {"sha": "6f8e387e1d7ecef648c4b16e2360db2dbb2bad80", "filename": "gcc/testsuite/g++.dg/abi/mangle17.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle17.C?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -4,8 +4,8 @@ enum E { e = 3 };\n \n template <int I> struct S {};\n \n-template <int I> void f (S<e + int (3.7)>) {}\n-template void f<7>(S<e + int (3.7)>);  // { dg-warning \"mangle\" }\n+template <int I> void f (S<I + e + int (3.7)>) {}\n+template void f<7>(S<7 + e + int (3.7)>);  // { dg-warning \"mangle\" }\n \n-template <int I> void g (S<e + int (3.7)>) {}\n-template void g<7>(S<e + int (3.7)>); // { dg-warning \"mangle\" }\n+template <int I> void g (S<I + e + int (3.7)>) {}\n+template void g<7>(S<7 + e + int (3.7)>); // { dg-warning \"mangle\" }"}, {"sha": "d4b5936825ccf4eab9bdd4b43db40c2a17601ddc", "filename": "gcc/testsuite/g++.dg/abi/mangle4.C", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fabi%2Fmangle4.C?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -8,19 +8,17 @@ template<const A* a> class C {};\n template<const B* b> class D {};\n template<B* b> class E {};\n \n-template<const B* b> void f(D<b> &, C<static_cast<const A*>(b)> &) {}\n-template<const B* b> void g(D<b> &, E<const_cast<B*>(b)> &) {}\n+template<const B* b> void f(D<b> &, C<static_cast<const A*>(b)> &) {} // { dg-error \"\" }\n+template<const B* b> void g(D<b> &, E<const_cast<B*>(b)> &) {} // { dg-error \"\" }\n \n B b;\n \n int main()\n {\n-  C<static_cast<const A*>(&b)> c;\n+  C<static_cast<const A*>(&b)> c; // { dg-error \"\" }\n   D<&b> d;\n-  E<const_cast<B*>(&b)> e;\n-  f(d, c);\n-  g(d, e);\n+  E<const_cast<B*>(&b)> e; // { dg-error \"\" }\n+  f(d, c); // { dg-error \"\" }\n+  g(d, e); // { dg-error \"\" }\n }\n \n-// { dg-final { scan-assembler \"\\n_?_Z1fIXadL_Z1bEEEvR1DIXT_EER1CIXcvPK1AT_EE\\[: \\t\\n\\]\" } }\n-// { dg-final { scan-assembler \"\\n_?_Z1gIXadL_Z1bEEEvR1DIXT_EER1EIXcvP1BT_EE\\[: \\t\\n\\]\" } }"}, {"sha": "31d47eda78f4178b62fdaa03432692d017260fe1", "filename": "gcc/testsuite/g++.dg/debug/debug7.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdebug7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdebug7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fdebug%2Fdebug7.C?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -7,7 +7,7 @@ main() {\n \n   int a = 4;\n   int b = 5;\n-  int (*x)[b] = new int[a][b];\n+  int (*x)[b] = new int[a][b]; // { dg-error \"\" }\n \n   x[2][1] = 7;\n "}, {"sha": "7fac18dac03d22629a51347e2aa3a223542c6684", "filename": "gcc/testsuite/g++.dg/opt/stack1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fstack1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fstack1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fstack1.C?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -68,7 +68,7 @@ template<typename=void>\n struct adaptor {\n     adaptor (matrix<> &m) : m(&m), upper_ (1) {}\n \n-    int size1 () const     { return m->size1 (); }\n+    int size1 () const;\n     int size2 () const     { return 3; }\n     int lower () const     { return 1; }\n     int upper () const     { return upper_; }"}, {"sha": "b13e3eccde43c4f40d657a00f0adfc830cd37aa2", "filename": "gcc/testsuite/g++.dg/parse/template7.C", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate7.C?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -0,0 +1,4 @@\n+template <int I>\n+void f();\n+\n+void g() { f<(3, 2)>(); } // { dg-error \"\" }"}, {"sha": "e29b76d42d0699623513b8c4641b52d033f5e249", "filename": "gcc/testsuite/g++.dg/template/dependent-expr1.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-expr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-expr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-expr1.C?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -21,9 +21,9 @@ namespace std\n     Foo (__alignof__ (x));\n     Foo (x->~I ());\n     //    Foo (typeid (I));\n-    Foo (delete x);\n-    Foo (delete[] x);\n-    Foo (throw x);\n+    Foo (delete x); // { dg-error \"\" }\n+    Foo (delete[] x); // { dg-error \"\" }\n+    Foo (throw x); // { dg-error \"\" }\n   }\n \n }"}, {"sha": "fc7f7b51497c0d559555917b89a7dc295d133d70", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash41.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash41.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash41.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash41.C?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -1,4 +1,4 @@\n-// { dg-do assemble  }\n+// { dg-do compile  }\n // Origin: Mark Mitchell <mark@codesourcery.com>\n \n template <int> struct S1{};\n@@ -7,5 +7,5 @@ struct S2 { int i; };\n \n template <class T>\n void f(S2 s2) {\n-  S1<s2.i> s1;\n+  S1<s2.i> s1; // { dg-error \"\" }\n }"}, {"sha": "f1cdea21ff8d73efb485007d98d512bdf4cbffb4", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -1,3 +1,7 @@\n+2003-07-09  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* gcj/array.h (JvPrimClass): Don't parenthesize the output.\n+\n 2003-07-09  Michael Koch  <konqueror@gmx.de>\n \n \t* gnu/java/awt/peer/gtk/GtkComponentPeer.java,"}, {"sha": "4f134f33c5ccb49f1646e36fa0dd90eca0298efd", "filename": "libjava/gcj/array.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d17811fd1aad24d0f47d0b20679753b23803848b/libjava%2Fgcj%2Farray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d17811fd1aad24d0f47d0b20679753b23803848b/libjava%2Fgcj%2Farray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Farray.h?ref=d17811fd1aad24d0f47d0b20679753b23803848b", "patch": "@@ -71,7 +71,9 @@ typedef JArray<jstring> *jstringArray;\n extern java::lang::Class _Jv_byteClass, _Jv_shortClass, _Jv_intClass,\n   _Jv_longClass, _Jv_booleanClass, _Jv_charClass, _Jv_floatClass,\n   _Jv_doubleClass, _Jv_voidClass;\n-#define JvPrimClass(TYPE) (& _Jv_##TYPE##Class)\n+/* The definition of this macro cannot be enclosed in parentheses\n+   because \"JvPrimClass(x)\" is used as a template argument.  */\n+#define JvPrimClass(TYPE) & _Jv_##TYPE##Class\n \n extern \"C\" jobjectArray _Jv_NewObjectArray(jsize length, jclass, jobject init);\n extern \"C\" jobject _Jv_NewPrimArray (jclass eltype, jint count);"}]}