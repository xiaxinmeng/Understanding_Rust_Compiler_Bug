{"sha": "9a30c7c4092fa2e7f46ee54883404a3fe34f2919", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWEzMGM3YzQwOTJmYTJlN2Y0NmVlNTQ4ODM0MDRhM2ZlMzRmMjkxOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-01T14:45:26Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-08-01T14:45:26Z"}, "message": "[multiple changes]\n\n2014-08-01  Olivier Hainque  <hainque@adacore.com>\n\n\t* gcc-interface/Make-lang.in (ADA_TOOLS_FLAGS_TO_PASS, native): use\n\t$(CXX) instead of ../../xg++ to feed CXX.\n\t(CXX_LFLAGS): Remove. Now unused as the proper flags\n\tare expected to be included in the CXX variable.\n\n2014-08-01  Pierre-Marie Derodat  <derodat@adacore.com>\n\n\t* gcc-interface/decl.c (elaborate_expression_1): Return the new\n\tvariable when debug info is needed and the expression is not\n\tconstant.  Tag as external only new variables that are global.\n\t(gnat_to_gnu_entity): Call it after the GNU declaration is saved.\n\t* gcc-interface/trans.c (Attribute_to_gnu): Do not cache\n\tattributes for IN array parameters when their actual subtype\n\tneeds debug info.\n\t(Compilation_Unit_to_gnu): Call it to process all remaining nodes.\n\t* gcc-interface/gigi.h (process_deferred_decl_context): New.\n\t* gcc-interface/utils.c (gnat_write_global_declarations): Do not\n\temit debug info for ignored global declarations.\n\t(struct deferred_decl_context_node,\n\tadd_deferred_decl_context, add_deferred_type_context,\n\tcompute_deferred_decl_context, defer_or_set_type_context,\n\tdeferred_decl_context_queue, get_debug_scope,\n\tget_global_context, process_deferred_decl_context): New.\n\t(gnat_pushdecl): Re-implement the DECL_CONTEXT and TYPE_CONTEXT\n\tcomputation machinery to rely on the GNAT Scope attribute.\n\n2014-08-01  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* gcc-interface/utils2.c (build_simple_component_ref): Add guard.\n\nFrom-SVN: r213482", "tree": {"sha": "514c0aecb2430f2b39147e8bf572fd6c5dc59617", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/514c0aecb2430f2b39147e8bf572fd6c5dc59617"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a30c7c4092fa2e7f46ee54883404a3fe34f2919", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a30c7c4092fa2e7f46ee54883404a3fe34f2919", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a30c7c4092fa2e7f46ee54883404a3fe34f2919", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a30c7c4092fa2e7f46ee54883404a3fe34f2919/comments", "author": null, "committer": null, "parents": [{"sha": "88b1a3221d1a03211d78dec931d0cc8d84b180cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88b1a3221d1a03211d78dec931d0cc8d84b180cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88b1a3221d1a03211d78dec931d0cc8d84b180cb"}], "stats": {"total": 415, "additions": 383, "deletions": 32}, "files": [{"sha": "30c5d35a5d63a5c10e83dc2366bfcb9556a24bf9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a30c7c4092fa2e7f46ee54883404a3fe34f2919/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a30c7c4092fa2e7f46ee54883404a3fe34f2919/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9a30c7c4092fa2e7f46ee54883404a3fe34f2919", "patch": "@@ -1,3 +1,35 @@\n+2014-08-01  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* gcc-interface/Make-lang.in (ADA_TOOLS_FLAGS_TO_PASS, native): use\n+\t$(CXX) instead of ../../xg++ to feed CXX.\n+\t(CXX_LFLAGS): Remove. Now unused as the proper flags\n+\tare expected to be included in the CXX variable.\n+\n+2014-08-01  Pierre-Marie Derodat  <derodat@adacore.com>\n+\n+\t* gcc-interface/decl.c (elaborate_expression_1): Return the new\n+\tvariable when debug info is needed and the expression is not\n+\tconstant.  Tag as external only new variables that are global.\n+\t(gnat_to_gnu_entity): Call it after the GNU declaration is saved.\n+\t* gcc-interface/trans.c (Attribute_to_gnu): Do not cache\n+\tattributes for IN array parameters when their actual subtype\n+\tneeds debug info.\n+\t(Compilation_Unit_to_gnu): Call it to process all remaining nodes.\n+\t* gcc-interface/gigi.h (process_deferred_decl_context): New.\n+\t* gcc-interface/utils.c (gnat_write_global_declarations): Do not\n+\temit debug info for ignored global declarations.\n+\t(struct deferred_decl_context_node,\n+\tadd_deferred_decl_context, add_deferred_type_context,\n+\tcompute_deferred_decl_context, defer_or_set_type_context,\n+\tdeferred_decl_context_queue, get_debug_scope,\n+\tget_global_context, process_deferred_decl_context): New.\n+\t(gnat_pushdecl): Re-implement the DECL_CONTEXT and TYPE_CONTEXT\n+\tcomputation machinery to rely on the GNAT Scope attribute.\n+\n+2014-08-01  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/utils2.c (build_simple_component_ref): Add guard.\n+\n 2014-08-01  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_ch8.adb, opt.ads Minor comment updates."}, {"sha": "478272fac7b3106e60cd431a1fbf3c7e16f01144", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a30c7c4092fa2e7f46ee54883404a3fe34f2919/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a30c7c4092fa2e7f46ee54883404a3fe34f2919/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=9a30c7c4092fa2e7f46ee54883404a3fe34f2919", "patch": "@@ -128,11 +128,12 @@ ada: gnat1$(exeext) gnatbind$(exeext)\n # Tell GNU Make to ignore these, if they exist.\n .PHONY: ada\n \n-CXX_LFLAGS = \\\n- -B../../../$(target_noncanonical)/libstdc++-v3/src/.libs \\\n- -B../../../$(target_noncanonical)/libstdc++-v3/libsupc++/.libs \\\n- -L../../../$(target_noncanonical)/libstdc++-v3/src/.libs \\\n- -L../../../$(target_noncanonical)/libstdc++-v3/libsupc++/.libs\n+# Compute the FLAGS to pass for gnattools, now linked with a C++ driver as\n+# we're linking against at least libcommon which contains C++ compiled code.\n+# We need to use the same driver to link as the one that was used to produce\n+# the objects, which depends on whether we're bootstrapping or not.  The CXX\n+# variable conveys what we need for this, set to \"g++\" if not bootstrapping,\n+# \".../xg++\" otherwise.\n \n # There are too many Ada sources to check against here.  Let's\n # always force the recursive make.\n@@ -142,7 +143,7 @@ ifeq ($(build), $(host))\n     # tree.\n     ADA_TOOLS_FLAGS_TO_PASS=\\\n         CC=\"../../xgcc -B../../\" \\\n-        CXX=\"../../xg++ -B../../ $(CXX_LFLAGS)\" \\\n+        CXX=\"$(CXX)\" \\\n         $(COMMON_FLAGS_TO_PASS) $(ADA_FLAGS_TO_PASS) \\\n         ADA_INCLUDES=\"-I- -I../rts\" \\\n         GNATMAKE=\"../../gnatmake\" \\"}, {"sha": "1e390ef59bd77f754cd2e758855f31dfec8c3491", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a30c7c4092fa2e7f46ee54883404a3fe34f2919/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a30c7c4092fa2e7f46ee54883404a3fe34f2919/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=9a30c7c4092fa2e7f46ee54883404a3fe34f2919", "patch": "@@ -5190,6 +5190,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n   if (!saved)\n     save_gnu_tree (gnat_entity, gnu_decl, false);\n \n+  /* Now we are sure gnat_entity has a corresponding ..._DECL node,\n+     eliminate as many deferred computations as possible.  */\n+  process_deferred_decl_context (false);\n+\n   /* If this is an enumeration or floating-point type, we were not able to set\n      the bounds since they refer to the type.  These are always static.  */\n   if ((kind == E_Enumeration_Type && Present (First_Literal (gnat_entity)))\n@@ -6184,14 +6188,30 @@ elaborate_expression_1 (tree gnu_expr, Entity_Id gnat_entity, tree gnu_name,\n   /* Now create it, possibly only for debugging purposes.  */\n   if (use_variable || need_debug)\n     {\n+      /* The following variable creation can happen when processing the body of\n+\t subprograms that are defined out of the extended main unit and\n+\t inlined. In this case, we are not at the global scope, and thus the\n+\t new variable must not be tagged \"external\", as we used to do here as\n+\t long as definition == 0.  */\n+      const bool external_flag = !definition && expr_global_p;\n       tree gnu_decl\n \t= create_var_decl_1\n \t  (create_concat_name (gnat_entity, IDENTIFIER_POINTER (gnu_name)),\n \t   NULL_TREE, TREE_TYPE (gnu_expr), gnu_expr, true, expr_public_p,\n-\t   !definition, expr_global_p, !need_debug, NULL, gnat_entity);\n+\t   external_flag, expr_global_p, !need_debug, NULL, gnat_entity);\n \n       DECL_ARTIFICIAL (gnu_decl) = 1;\n-      if (use_variable)\n+\n+      /* Using this variable at debug time (if need_debug is true) requires a\n+\t proper location.  The back-end will compute a location for this\n+\t variable only if the variable is used by the generated code.\n+\t Returning the variable ensures the caller will use it in generated\n+\t code.  Note that there is no need for a location if the debug info\n+\t contains an integer constant.\n+\t FIXME: when the encoding-based debug scheme is dropped, move this\n+\t condition to the top-level IF block: we will not need to create a\n+\t variable anymore in such cases, then.  */\n+      if (use_variable || (need_debug && !TREE_CONSTANT (gnu_expr)))\n \treturn gnu_decl;\n     }\n "}, {"sha": "6cee20b7304872582234353291500cca68a4ba44", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a30c7c4092fa2e7f46ee54883404a3fe34f2919/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a30c7c4092fa2e7f46ee54883404a3fe34f2919/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=9a30c7c4092fa2e7f46ee54883404a3fe34f2919", "patch": "@@ -999,6 +999,12 @@ extern int fp_size_to_prec (int size);\n    initialization is likely to disturb debugging.  */\n extern bool renaming_from_generic_instantiation_p (Node_Id gnat_node);\n \n+/* Try to process all nodes in the deferred context queue.  Keep in the queue\n+   the ones that cannot be processed yet, remove the other ones.  If FORCE is\n+   true, force the processing for all nodes, use the global context when nodes\n+   don't have a GNU translation.  */\n+extern void process_deferred_decl_context (bool force);\n+\n #ifdef __cplusplus\n extern \"C\" {\n #endif"}, {"sha": "3323a5658579007d61f004a52e89d82131b27303", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a30c7c4092fa2e7f46ee54883404a3fe34f2919/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a30c7c4092fa2e7f46ee54883404a3fe34f2919/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=9a30c7c4092fa2e7f46ee54883404a3fe34f2919", "patch": "@@ -1975,8 +1975,16 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \tgcc_assert (TREE_CODE (gnu_type) == ARRAY_TYPE);\n \n \t/* When not optimizing, look up the slot associated with the parameter\n-\t   and the dimension in the cache and create a new one on failure.  */\n-\tif (!optimize && Present (gnat_param))\n+\t   and the dimension in the cache and create a new one on failure.\n+\t   Don't do this when the actual subtype needs debug info (this happens\n+\t   with -gnatD): in elaborate_expression_1, we create variables that\n+\t   hold the bounds, so caching attributes isn't very interesting and\n+\t   causes dependency issues between these variables and cached\n+\t   expressions.  */\n+\tif (!optimize\n+\t    && Present (gnat_param)\n+\t    && !(Present (Actual_Subtype (gnat_param))\n+\t\t && Needs_Debug_Info (Actual_Subtype (gnat_param))))\n \t  {\n \t    FOR_EACH_VEC_SAFE_ELT (f_parm_attr_cache, i, pa)\n \t      if (pa->id == gnat_param && pa->dim == Dimension)\n@@ -4978,6 +4986,9 @@ Compilation_Unit_to_gnu (Node_Id gnat_node)\n      stabilization of the renamed entities may create SAVE_EXPRs which\n      have been tied to a specific elaboration routine just above.  */\n   invalidate_global_renaming_pointers ();\n+\n+  /* Force the processing for all nodes that remain in the queue.  */\n+  process_deferred_decl_context (true);\n }\n \f\n /* Subroutine of gnat_to_gnu to translate gnat_node, an N_Raise_xxx_Error,"}, {"sha": "918b6cc021cc3da68ef60db79aa62930edefdaf0", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 301, "deletions": 21, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a30c7c4092fa2e7f46ee54883404a3fe34f2919/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a30c7c4092fa2e7f46ee54883404a3fe34f2919/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=9a30c7c4092fa2e7f46ee54883404a3fe34f2919", "patch": "@@ -244,6 +244,32 @@ static tree float_type_for_precision (int, enum machine_mode);\n static tree convert_to_fat_pointer (tree, tree);\n static unsigned int scale_by_factor_of (tree, unsigned int);\n static bool potential_alignment_gap (tree, tree, tree);\n+\n+/* A linked list used as a queue to defer the initialization of the\n+   DECL_CONTEXT attribute of ..._DECL nodes and of the TYPE_CONTEXT attribute\n+   of ..._TYPE nodes.  */\n+struct deferred_decl_context_node\n+{\n+  tree decl;\t\t    /* The ..._DECL node to work on.  */\n+  Entity_Id gnat_scope;     /* The corresponding entity's Scope attribute.  */\n+  int force_global;\t    /* force_global value when pushing DECL. */\n+  vec<tree, va_heap, vl_ptr> types;\t    /* A list of ..._TYPE nodes to propagate the\n+\t\t\t       context to.  */\n+  struct deferred_decl_context_node *next;  /* The next queue item.  */\n+};\n+\n+static struct deferred_decl_context_node *deferred_decl_context_queue = NULL;\n+\n+/* Defer the initialization of DECL's DECL_CONTEXT attribute, scheduling to\n+   feed it with the elaboration of GNAT_SCOPE.  */\n+static struct deferred_decl_context_node *\n+add_deferred_decl_context (tree decl, Entity_Id gnat_scope, int force_global);\n+\n+/* Defer the initialization of TYPE's TYPE_CONTEXT attribute, scheduling to\n+   feed it with the DECL_CONTEXT computed as part of N as soon as it is\n+   computed.  */\n+static void add_deferred_type_context (struct deferred_decl_context_node *n,\n+\t\t\t\t       tree type);\n \f\n /* Initialize data structures of the utils.c module.  */\n \n@@ -554,31 +580,139 @@ gnat_set_type_context (tree type, tree context)\n     }\n }\n \n+/* Return the innermost scope, starting at GNAT_NODE, we are be interested in\n+   the debug info, or Empty if there is no such scope.  If not NULL, set\n+   IS_SUBPROGRAM to whether the returned entity is a subprogram.  */\n+\n+static Entity_Id\n+get_debug_scope (Node_Id gnat_node, bool *is_subprogram)\n+{\n+  Entity_Id gnat_entity;\n+\n+  if (is_subprogram)\n+    *is_subprogram = false;\n+\n+  if (Nkind (gnat_node) == N_Defining_Identifier)\n+    gnat_entity = Scope (gnat_node);\n+  else\n+    return Empty;\n+\n+  while (Present (gnat_entity))\n+    {\n+      switch (Ekind (gnat_entity))\n+\t{\n+\tcase E_Function:\n+\tcase E_Procedure:\n+\t  if (Present (Protected_Body_Subprogram (gnat_entity)))\n+\t    gnat_entity = Protected_Body_Subprogram (gnat_entity);\n+\n+\t  /* If the scope is a subprogram, then just rely on\n+\t     current_function_decl, so that we don't have to defer\n+\t     anything.  This is needed because other places rely on the\n+\t     validity of the DECL_CONTEXT attribute of FUNCTION_DECL nodes. */\n+\t  if (is_subprogram)\n+\t    *is_subprogram = true;\n+\t  return gnat_entity;\n+\n+\tcase E_Record_Type:\n+\tcase E_Record_Subtype:\n+\t  return gnat_entity;\n+\n+\tdefault:\n+\t  /* By default, we are not interested in this particular scope: go to\n+\t     the outer one.  */\n+\t  break;\n+\t}\n+      gnat_entity = Scope (gnat_entity);\n+    }\n+  return Empty;\n+}\n+\n+/* If N is NULL, set TYPE's context to CONTEXT. Defer this to the processing of\n+   N otherwise.  */\n+\n+static void\n+defer_or_set_type_context (tree type,\n+\t\t\t   tree context,\n+\t\t\t   struct deferred_decl_context_node *n)\n+{\n+  if (n)\n+    add_deferred_type_context (n, type);\n+  else\n+    gnat_set_type_context (type, context);\n+}\n+\n+/* Return global_context.  Create it if needed, first.  */\n+\n+static tree\n+get_global_context (void)\n+{\n+  if (!global_context)\n+    global_context = build_translation_unit_decl (NULL_TREE);\n+  return global_context;\n+}\n+\n /* Record DECL as belonging to the current lexical scope and use GNAT_NODE\n    for location information and flag propagation.  */\n \n void\n gnat_pushdecl (tree decl, Node_Id gnat_node)\n {\n-  /* If DECL is public external or at top level, it has global context.  */\n-  if ((TREE_PUBLIC (decl) && DECL_EXTERNAL (decl)) || global_bindings_p ())\n-    {\n-      if (!global_context)\n-\tglobal_context = build_translation_unit_decl (NULL_TREE);\n-      DECL_CONTEXT (decl) = global_context;\n-   }\n-  else\n+  tree context = NULL_TREE;\n+  struct deferred_decl_context_node *deferred_decl_context = NULL;\n+\n+  /* If explicitely asked to make DECL global or if it's an imported nested\n+     object, short-circuit the regular Scope-based context computation.  */\n+  if (!((TREE_PUBLIC (decl) && DECL_EXTERNAL (decl)) || force_global == 1))\n     {\n-      DECL_CONTEXT (decl) = current_function_decl;\n-\n-      /* Functions imported in another function are not really nested.\n-\t For really nested functions mark them initially as needing\n-\t a static chain for uses of that flag before unnesting;\n-\t lower_nested_functions will then recompute it.  */\n-      if (TREE_CODE (decl) == FUNCTION_DECL && !TREE_PUBLIC (decl))\n-\tDECL_STATIC_CHAIN (decl) = 1;\n+      /* Rely on the GNAT scope, or fallback to the current_function_decl if\n+\t the GNAT scope reached the global scope, if it reached a subprogram\n+\t or the declaration is a subprogram or a variable (for them we skip\n+\t intermediate context types because the subprogram body elaboration\n+\t machinery and the inliner both expect a subprogram context).\n+\n+\t Falling back to current_function_decl is necessary for implicit\n+\t subprograms created by gigi, such as the elaboration subprograms.  */\n+      bool context_is_subprogram = false;\n+      const Entity_Id gnat_scope\n+        = get_debug_scope (gnat_node, &context_is_subprogram);\n+\n+      if (Present (gnat_scope)\n+\t  && !context_is_subprogram\n+\t  && TREE_CODE (decl) != FUNCTION_DECL\n+\t  && TREE_CODE (decl) != VAR_DECL)\n+\t/* Always assume the scope has not been elaborated, thus defer the\n+\t   context propagation to the time its elaboration will be\n+\t   available.  */\n+\tdeferred_decl_context\n+\t  = add_deferred_decl_context (decl, gnat_scope, force_global);\n+\n+      /* External declarations (when force_global > 0) may not be in a\n+\t local context.  */\n+      else if (current_function_decl != NULL_TREE && force_global == 0)\n+\tcontext = current_function_decl;\n     }\n \n+  /* If either we are forced to be in global mode or if both the GNAT scope and\n+     the current_function_decl did not help determining the context, use the\n+     global scope.  */\n+  if (!deferred_decl_context && context == NULL_TREE)\n+    context = get_global_context ();\n+\n+  /* Functions imported in another function are not really nested.\n+     For really nested functions mark them initially as needing\n+     a static chain for uses of that flag before unnesting;\n+     lower_nested_functions will then recompute it.  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL\n+      && !TREE_PUBLIC (decl)\n+      && context != NULL_TREE\n+      && (TREE_CODE (context) == FUNCTION_DECL\n+\t  || decl_function_context (context) != NULL_TREE))\n+    DECL_STATIC_CHAIN (decl) = 1;\n+\n+  if (!deferred_decl_context)\n+    DECL_CONTEXT (decl) = context;\n+\n   TREE_NO_WARNING (decl) = (No (gnat_node) || Warnings_Off (gnat_node));\n \n   /* Set the location of DECL and emit a declaration for it.  */\n@@ -635,7 +769,9 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \t      if (TREE_CODE (t) == POINTER_TYPE)\n \t\tTYPE_NEXT_PTR_TO (t) = tt;\n \t      TYPE_NAME (tt) = DECL_NAME (decl);\n-\t      gnat_set_type_context (tt, DECL_CONTEXT (decl));\n+\t      defer_or_set_type_context (tt,\n+\t\t\t\t\t DECL_CONTEXT (decl),\n+\t\t\t\t\t deferred_decl_context);\n \t      TYPE_STUB_DECL (tt) = TYPE_STUB_DECL (t);\n \t      DECL_ORIGINAL_TYPE (decl) = tt;\n \t    }\n@@ -645,7 +781,9 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \t  /* We need a variant for the placeholder machinery to work.  */\n \t  tree tt = build_variant_type_copy (t);\n \t  TYPE_NAME (tt) = decl;\n-\t  gnat_set_type_context (tt, DECL_CONTEXT (decl));\n+\t  defer_or_set_type_context (tt,\n+\t\t\t\t     DECL_CONTEXT (decl),\n+\t\t\t\t     deferred_decl_context);\n \t  TREE_USED (tt) = TREE_USED (t);\n \t  TREE_TYPE (decl) = tt;\n \t  if (DECL_ORIGINAL_TYPE (TYPE_NAME (t)))\n@@ -667,7 +805,9 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \t  if (!(TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL))\n \t    {\n \t      TYPE_NAME (t) = decl;\n-\t      gnat_set_type_context (t, DECL_CONTEXT (decl));\n+\t      defer_or_set_type_context (t,\n+\t\t\t\t\t DECL_CONTEXT (decl),\n+\t\t\t\t\t deferred_decl_context);\n \t    }\n     }\n }\n@@ -2590,6 +2730,146 @@ renaming_from_generic_instantiation_p (Node_Id gnat_node)\n     && Present (Corresponding_Generic_Association (gnat_node)));\n }\n \n+/* Defer the initialization of DECL's DECL_CONTEXT attribute, scheduling to\n+   feed it with the elaboration of GNAT_SCOPE.  */\n+\n+static struct deferred_decl_context_node *\n+add_deferred_decl_context (tree decl, Entity_Id gnat_scope, int force_global)\n+{\n+  struct deferred_decl_context_node *new_node;\n+\n+  new_node\n+    = (struct deferred_decl_context_node * ) xmalloc (sizeof (*new_node));\n+  new_node->decl = decl;\n+  new_node->gnat_scope = gnat_scope;\n+  new_node->force_global = force_global;\n+  new_node->types.create (1);\n+  new_node->next = deferred_decl_context_queue;\n+  deferred_decl_context_queue = new_node;\n+  return new_node;\n+}\n+\n+/* Defer the initialization of TYPE's TYPE_CONTEXT attribute, scheduling to\n+   feed it with the DECL_CONTEXT computed as part of N as soon as it is\n+   computed.  */\n+\n+static void\n+add_deferred_type_context (struct deferred_decl_context_node *n, tree type)\n+{\n+  n->types.safe_push (type);\n+}\n+\n+/* Get the GENERIC node corresponding to GNAT_SCOPE, if available.  Return\n+   NULL_TREE if it is not available.  */\n+\n+static tree\n+compute_deferred_decl_context (Entity_Id gnat_scope)\n+{\n+  tree context;\n+\n+  if (present_gnu_tree (gnat_scope))\n+    context = get_gnu_tree (gnat_scope);\n+  else\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (context) == TYPE_DECL)\n+    {\n+      const tree context_type = TREE_TYPE (context);\n+\n+      /* Skip dummy types: only the final ones can appear in the context\n+\t chain.  */\n+      if (TYPE_DUMMY_P (context_type))\n+\treturn NULL_TREE;\n+\n+      /* ..._TYPE nodes are more useful than TYPE_DECL nodes in the context\n+\t chain.  */\n+      else\n+\tcontext = context_type;\n+    }\n+\n+  return context;\n+}\n+\n+/* Try to process all deferred nodes in the queue.  Keep in the queue the ones\n+   that cannot be processed yet, remove the other ones.  If FORCE is true,\n+   force the processing for all nodes, use the global context when nodes don't\n+   have a GNU translation.  */\n+\n+void\n+process_deferred_decl_context (bool force)\n+{\n+  struct deferred_decl_context_node **it = &deferred_decl_context_queue;\n+  struct deferred_decl_context_node *node;\n+\n+  while (*it != NULL)\n+    {\n+      bool processed = false;\n+      tree context = NULL_TREE;\n+      Entity_Id gnat_scope;\n+\n+      node = *it;\n+\n+      /* If FORCE, get the innermost elaborated scope. Otherwise, just try to\n+\t get the first scope.  */\n+      gnat_scope = node->gnat_scope;\n+      while (Present (gnat_scope))\n+\t{\n+\t  context = compute_deferred_decl_context (gnat_scope);\n+\t  if (!force || context != NULL_TREE)\n+\t    break;\n+\t  gnat_scope = get_debug_scope (gnat_scope, NULL);\n+\t}\n+\n+      /* Imported declarations must not be in a local context (i.e. not inside\n+\t a function).  */\n+      if (context != NULL_TREE && node->force_global > 0)\n+\t{\n+\t  tree ctx = context;\n+\n+\t  while (ctx != NULL_TREE)\n+\t    {\n+\t      gcc_assert (TREE_CODE (ctx) != FUNCTION_DECL);\n+\t      ctx = (DECL_P (ctx))\n+\t\t    ? DECL_CONTEXT (ctx)\n+\t\t    : TYPE_CONTEXT (ctx);\n+\t    }\n+\t}\n+\n+      /* If FORCE, we want to get rid of all nodes in the queue: in case there\n+\t was no elaborated scope, use the global context.  */\n+      if (force && context == NULL_TREE)\n+\tcontext = get_global_context ();\n+\n+      if (context != NULL_TREE)\n+\t{\n+\t  tree t;\n+\t  int i;\n+\n+\t  DECL_CONTEXT (node->decl) = context;\n+\n+\t  /* Propagate it to the TYPE_CONTEXT attributes of the requested\n+\t     ..._TYPE nodes.  */\n+\t  FOR_EACH_VEC_ELT (node->types, i, t)\n+\t    {\n+\t      TYPE_CONTEXT (t) = context;\n+\t    }\n+\t  processed = true;\n+\t}\n+\n+      /* If this node has been successfuly processed, remove it from the\n+\t queue.  Then move to the next node.  */\n+      if (processed)\n+\t{\n+\t  *it = node->next;\n+\t  node->types.release ();\n+\t  free (node);\n+\t}\n+      else\n+\tit = &node->next;\n+    }\n+}\n+\n+\n /* Return VALUE scaled by the biggest power-of-2 factor of EXPR.  */\n \n static unsigned int\n@@ -4868,7 +5148,7 @@ gnat_write_global_declarations (void)\n      for example pointers to Taft amendment types, have their compilation\n      finalized in the right context.  */\n   FOR_EACH_VEC_SAFE_ELT (global_decls, i, iter)\n-    if (TREE_CODE (iter) == TYPE_DECL)\n+    if (TREE_CODE (iter) == TYPE_DECL && !DECL_IGNORED_P (iter))\n       debug_hooks->global_decl (iter);\n \n   /* Proceed to optimize and emit assembly. */\n@@ -4880,7 +5160,7 @@ gnat_write_global_declarations (void)\n     {\n       timevar_push (TV_SYMOUT);\n       FOR_EACH_VEC_SAFE_ELT (global_decls, i, iter)\n-\tif (TREE_CODE (iter) != TYPE_DECL)\n+\tif (TREE_CODE (iter) != TYPE_DECL && !DECL_IGNORED_P (iter))\n \t  debug_hooks->global_decl (iter);\n       timevar_pop (TV_SYMOUT);\n     }"}, {"sha": "8297c068dbc1eeb8b7337bb47e7b4dd947b680ac", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a30c7c4092fa2e7f46ee54883404a3fe34f2919/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a30c7c4092fa2e7f46ee54883404a3fe34f2919/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=9a30c7c4092fa2e7f46ee54883404a3fe34f2919", "patch": "@@ -2002,7 +2002,8 @@ build_simple_component_ref (tree record_variable, tree component, tree field,\n \n       /* Look through a conversion between original and packable version, but\n \t the field needs to be adjusted in this case.  */\n-      else if (TYPE_NAME (inner_type) == TYPE_NAME (record_type))\n+      else if (RECORD_OR_UNION_TYPE_P (inner_type)\n+\t       && TYPE_NAME (inner_type) == TYPE_NAME (record_type))\n \t{\n \t  tree new_field;\n "}]}