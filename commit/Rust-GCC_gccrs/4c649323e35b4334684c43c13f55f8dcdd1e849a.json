{"sha": "4c649323e35b4334684c43c13f55f8dcdd1e849a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM2NDkzMjNlMzViNDMzNDY4NGM0M2MxM2Y1NWY4ZGNkZDFlODQ5YQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-06-27T15:51:49Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-06-27T15:51:49Z"}, "message": "flow.c (count_reg_sets): New function.\n\n        * flow.c (count_reg_sets): New function.\n        (count_reg_sets_1, count_ref_references): Likewise.\n        (recompute_reg_usage): Likewise.\n        * rtl.h (recompute_reg_usage): Add prototype.\n        * toplev.c (rest_of_compilation): Call recompute_reg_usage just\n        before local register allocation.\n\nFrom-SVN: r20756", "tree": {"sha": "8bda5f9b49d90febefd96ece8be5e8acfc5d4e62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bda5f9b49d90febefd96ece8be5e8acfc5d4e62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c649323e35b4334684c43c13f55f8dcdd1e849a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c649323e35b4334684c43c13f55f8dcdd1e849a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c649323e35b4334684c43c13f55f8dcdd1e849a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c649323e35b4334684c43c13f55f8dcdd1e849a/comments", "author": null, "committer": null, "parents": [{"sha": "ea56ab2ae0a87ddabb867ef8d4ad47205cee1f3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea56ab2ae0a87ddabb867ef8d4ad47205cee1f3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea56ab2ae0a87ddabb867ef8d4ad47205cee1f3a"}], "stats": {"total": 293, "additions": 293, "deletions": 0}, "files": [{"sha": "d3cb6c1fdf1dfa38f1d0d8203bd792ab38b12963", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c649323e35b4334684c43c13f55f8dcdd1e849a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c649323e35b4334684c43c13f55f8dcdd1e849a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4c649323e35b4334684c43c13f55f8dcdd1e849a", "patch": "@@ -1,3 +1,12 @@\n+Sat Jun 27 16:45:42 1998  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* flow.c (count_reg_sets): New function.\n+\t(count_reg_sets_1, count_ref_references): Likewise.\n+\t(recompute_reg_usage): Likewise.\n+\t* rtl.h (recompute_reg_usage): Add prototype.\n+\t* toplev.c (rest_of_compilation): Call recompute_reg_usage just\n+\tbefore local register allocation.\n+\n Sat Jun 27 13:15:30 1998  Richard Henderson  <rth@cygnus.com>\n \n \t* alpha.md (negsf, negdf): Revert Jan 22 change."}, {"sha": "f78e171e0e5ef4f60eb7be5092a90090c5804a56", "filename": "gcc/flow.c", "status": "modified", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c649323e35b4334684c43c13f55f8dcdd1e849a/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c649323e35b4334684c43c13f55f8dcdd1e849a/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=4c649323e35b4334684c43c13f55f8dcdd1e849a", "patch": "@@ -284,6 +284,9 @@ static int_list_ptr add_int_list_node   PROTO ((int_list_block **,\n \t\t\t\t\t\tint_list **, int));\n static void init_regset_vector\t\tPROTO ((regset *, int,\n \t\t\t\t\t\tstruct obstack *));\n+static void count_reg_sets_1\t\tPROTO ((rtx));\n+static void count_reg_sets\t\tPROTO ((rtx));\n+static void count_reg_references\tPROTO ((rtx));\n \f\n /* Find basic blocks of the current function.\n    F is the first insn of the function and NREGS the number of register numbers\n@@ -3997,3 +4000,281 @@ compute_dominators (dominators, post_dominators, s_preds, s_succs)\n \n   free (temp_bitmap);\n }\n+\n+/* Count for a single SET rtx, X.  */\n+\n+static void\n+count_reg_sets_1 (x)\n+     rtx x;\n+{\n+  register int regno;\n+  register rtx reg = SET_DEST (x);\n+\n+  /* Find the register that's set/clobbered.  */\n+  while (GET_CODE (reg) == SUBREG || GET_CODE (reg) == ZERO_EXTRACT\n+\t || GET_CODE (reg) == SIGN_EXTRACT\n+\t || GET_CODE (reg) == STRICT_LOW_PART)\n+    reg = XEXP (reg, 0);\n+\n+  if (GET_CODE (reg) == REG)\n+    {\n+      regno = REGNO (reg);\n+      if (regno >= FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  /* Count (weighted) references, stores, etc.  This counts a\n+\t     register twice if it is modified, but that is correct.  */\n+\t  REG_N_SETS (regno)++;\n+\n+\t  REG_N_REFS (regno) += loop_depth;\n+\t}\n+    }\n+}\n+\n+/* Increment REG_N_SETS for each SET or CLOBBER found in X; also increment\n+   REG_N_REFS by the current loop depth for each SET or CLOBBER found.  */\n+\n+static void\n+count_reg_sets  (x)\n+     rtx x;\n+{\n+  register RTX_CODE code = GET_CODE (x);\n+\n+  if (code == SET || code == CLOBBER)\n+    count_reg_sets_1 (x);\n+  else if (code == PARALLEL)\n+    {\n+      register int i;\n+      for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n+\t{\n+\t  code = GET_CODE (XVECEXP (x, 0, i));\n+\t  if (code == SET || code == CLOBBER)\n+\t    count_reg_sets_1 (XVECEXP (x, 0, i));\n+\t}\n+    }\n+}\n+\n+/* Increment REG_N_REFS by the current loop depth each register reference\n+   found in X.  */\n+\n+static void\n+count_reg_references (x)\n+     rtx x;\n+{\n+  register RTX_CODE code;\n+  register int regno;\n+  int i;\n+\n+ retry:\n+  code = GET_CODE (x);\n+  switch (code)\n+    {\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST_INT:\n+    case CONST:\n+    case CONST_DOUBLE:\n+    case PC:\n+    case ADDR_VEC:\n+    case ADDR_DIFF_VEC:\n+    case ASM_INPUT:\n+      return;\n+\n+#ifdef HAVE_cc0\n+    case CC0:\n+      return;\n+#endif\n+\n+    case CLOBBER:\n+      /* If we are clobbering a MEM, mark any registers inside the address\n+\t as being used.  */\n+      if (GET_CODE (XEXP (x, 0)) == MEM)\n+\tcount_reg_references (XEXP (XEXP (x, 0), 0));\n+      return;\n+\n+    case SUBREG:\n+      /* While we're here, optimize this case.  */\n+      x = SUBREG_REG (x);\n+\n+      /* In case the SUBREG is not of a register, don't optimize */\n+      if (GET_CODE (x) != REG)\n+\t{\n+\t  count_reg_references (x);\n+\t  return;\n+\t}\n+\n+      /* ... fall through ...  */\n+\n+    case REG:\n+      if (REGNO (x) >= FIRST_PSEUDO_REGISTER)\n+\tREG_N_REFS (REGNO (x)) += loop_depth;\n+      return;\n+\n+    case SET:\n+      {\n+\tregister rtx testreg = SET_DEST (x);\n+\tint mark_dest = 0;\n+\n+\t/* If storing into MEM, don't show it as being used.  But do\n+\t   show the address as being used.  */\n+\tif (GET_CODE (testreg) == MEM)\n+\t  {\n+\t    count_reg_references (XEXP (testreg, 0));\n+\t    count_reg_references (SET_SRC (x));\n+\t    return;\n+\t  }\n+\t    \n+\t/* Storing in STRICT_LOW_PART is like storing in a reg\n+\t   in that this SET might be dead, so ignore it in TESTREG.\n+\t   but in some other ways it is like using the reg.\n+\n+\t   Storing in a SUBREG or a bit field is like storing the entire\n+\t   register in that if the register's value is not used\n+\t   then this SET is not needed.  */\n+\twhile (GET_CODE (testreg) == STRICT_LOW_PART\n+\t       || GET_CODE (testreg) == ZERO_EXTRACT\n+\t       || GET_CODE (testreg) == SIGN_EXTRACT\n+\t       || GET_CODE (testreg) == SUBREG)\n+\t  {\n+\t    /* Modifying a single register in an alternate mode\n+\t       does not use any of the old value.  But these other\n+\t       ways of storing in a register do use the old value.  */\n+\t    if (GET_CODE (testreg) == SUBREG\n+\t\t&& !(REG_SIZE (SUBREG_REG (testreg)) > REG_SIZE (testreg)))\n+\t      ;\n+\t    else\n+\t      mark_dest = 1;\n+\n+\t    testreg = XEXP (testreg, 0);\n+\t  }\n+\n+\t/* If this is a store into a register,\n+\t   recursively scan the value being stored.  */\n+\n+\tif (GET_CODE (testreg) == REG)\n+\t  {\n+\t    count_reg_references (SET_SRC (x));\n+\t    if (mark_dest)\n+\t      count_reg_references (SET_DEST (x));\n+\t    return;\n+\t  }\n+      }\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Recursively scan the operands of this expression.  */\n+\n+  {\n+    register char *fmt = GET_RTX_FORMAT (code);\n+    register int i;\n+    \n+    for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+      {\n+\tif (fmt[i] == 'e')\n+\t  {\n+\t    /* Tail recursive case: save a function call level.  */\n+\t    if (i == 0)\n+\t      {\n+\t\tx = XEXP (x, 0);\n+\t\tgoto retry;\n+\t      }\n+\t    count_reg_references (XEXP (x, i));\n+\t  }\n+\telse if (fmt[i] == 'E')\n+\t  {\n+\t    register int j;\n+\t    for (j = 0; j < XVECLEN (x, i); j++)\n+\t      count_reg_references (XVECEXP (x, i, j));\n+\t  }\n+      }\n+  }\n+}\n+\n+/* Recompute register set/reference counts immediately prior to register\n+   allocation.\n+\n+   This avoids problems with set/reference counts changing to/from values\n+   which have special meanings to the register allocators.\n+\n+   Additionally, the reference counts are the primary component used by the\n+   register allocators to prioritize pseudos for allocation to hard regs.\n+   More accurate reference counts generally lead to better register allocation.\n+\n+   It might be worthwhile to update REG_LIVE_LENGTH, REG_BASIC_BLOCK and\n+   possibly other information which is used by the register allocators.  */\n+\n+int\n+recompute_reg_usage (f)\n+     rtx f;\n+{\n+  rtx insn;\n+  int i, max_reg;\n+\n+  /* Clear out the old data.  */\n+  max_reg = max_reg_num ();\n+  for (i = FIRST_PSEUDO_REGISTER; i < max_reg; i++)\n+    {\n+      REG_N_SETS (i) = 0;\n+      REG_N_REFS (i) = 0;\n+    }\n+\n+  /* Scan each insn in the chain and count how many times each register is\n+     set/used.  */\n+  loop_depth = 1;\n+  for (insn = f; insn; insn = NEXT_INSN (insn))\n+    {\n+      /* Keep track of loop depth.  */\n+      if (GET_CODE (insn) == NOTE)\n+\t{\n+\t  /* Look for loop boundaries.  */\n+\t  if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n+\t    loop_depth--;\n+\t  else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n+\t    loop_depth++;\n+\n+\t  /* If we have LOOP_DEPTH == 0, there has been a bookkeeping error. \n+\t     Abort now rather than setting register status incorrectly.  */\n+\t  if (loop_depth == 0)\n+\t    abort ();\n+\t}\n+      else if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\t{\n+\t  rtx links;\n+\n+\t  /* This call will increment REG_N_SETS for each SET or CLOBBER\n+\t     of a register in INSN.  It will also increment REG_N_REFS\n+\t     by the loop depth for each set of a register in INSN.  */\n+\t  count_reg_sets (PATTERN (insn));\n+\n+\t  /* count_reg_sets does not detect autoincrement address modes, so\n+\t     detect them here by looking at the notes attached to INSN.  */\n+\t  for (links = REG_NOTES (insn); links; links = XEXP (links, 1))\n+\t    {\n+\t      if (REG_NOTE_KIND (links) == REG_INC)\n+\t\t/* Count (weighted) references, stores, etc.  This counts a\n+\t\t   register twice if it is modified, but that is correct.  */\n+\t\tREG_N_SETS (REGNO (XEXP (links, 0)))++;\n+\t    }\n+\n+\t  /* This call will increment REG_N_REFS by the current loop depth for\n+\t     each reference to a register in INSN.  */\n+\t  count_reg_references (PATTERN (insn));\n+\n+\t  /* count_reg_references will not include counts for arguments to\n+\t     function calls, so detect them here by examining the\n+\t     CALL_INSN_FUNCTION_USAGE data.  */\n+\t  if (GET_CODE (insn) == CALL_INSN)\n+\t    {\n+\t      rtx note;\n+\n+\t      for (note = CALL_INSN_FUNCTION_USAGE (insn);\n+\t\t   note;\n+\t\t   note = XEXP (note, 1))\n+\t\tif (GET_CODE (XEXP (note, 0)) == USE)\n+\t\t  count_reg_references (SET_DEST (XEXP (note, 0)));\n+\t    }\n+\t}\n+    }\n+}"}, {"sha": "d281cbef2d1ccf97ffe0129fab3ad73fd0fba3f1", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c649323e35b4334684c43c13f55f8dcdd1e849a/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c649323e35b4334684c43c13f55f8dcdd1e849a/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=4c649323e35b4334684c43c13f55f8dcdd1e849a", "patch": "@@ -1407,6 +1407,7 @@ extern void stupid_life_analysis\tPROTO ((rtx, int, FILE *));\n \n /* In flow.c */\n extern void allocate_for_life_analysis\tPROTO ((void));\n+extern int recompute_reg_usage\t\tPROTO ((rtx));\n #ifdef BUFSIZ\n extern void dump_flow_info\t\tPROTO ((FILE *));\n #endif\n@@ -1543,4 +1544,5 @@ extern void init_alias_analysis\t\tPROTO ((void));\n extern void end_alias_analysis\t\tPROTO ((void));\n \n extern void record_base_value\t\tPROTO ((int, rtx, int));\n+\n #endif /* _RTL_H */"}, {"sha": "b1987336cb1e3dab9b72e3efada92a4fc84234e1", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c649323e35b4334684c43c13f55f8dcdd1e849a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c649323e35b4334684c43c13f55f8dcdd1e849a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=4c649323e35b4334684c43c13f55f8dcdd1e849a", "patch": "@@ -3481,6 +3481,7 @@ rest_of_compilation (decl)\n   if (!obey_regdecls)\n     TIMEVAR (local_alloc_time,\n \t     {\n+\t       recompute_reg_usage (insns);\n \t       regclass (insns, max_reg_num ());\n \t       local_alloc ();\n \t     });"}]}