{"sha": "4eac9c2b0207ed53bc35898af9586987ee7733c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVhYzljMmIwMjA3ZWQ1M2JjMzU4OThhZjk1ODY5ODdlZTc3MzNjOQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2014-10-12T23:14:07Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2014-10-12T23:14:07Z"}, "message": "re PR target/59401 ([SH] GBR addressing mode optimization produces wrong code)\n\ngcc/\n\tPR target/59401\n\t* config/sh/sh-protos (sh_find_equiv_gbr_addr): Use rtx_insn* instead\n\tof rtx.\n\t* config/sh/sh.c (sh_find_equiv_gbr_addr): Use def chains instead of\n\tinsn walking.\n\t(sh_find_equiv_gbr_addr): Do nothing if input mem is already a GBR\n\taddress.  Use def chains to handle GBR clobbering call insns.\n\ngcc/testsuite/\n\tPR target/59401\n\tPR target/54760\n\t* gcc.target/pr54760-5.c: New.\n\t* gcc.target/pr54760-6.c: New.\n\t* gcc.target/sh/pr59401-1.c: New.\n\nFrom-SVN: r216128", "tree": {"sha": "610e90d2b517f700340fd9cb8457211a19491af4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/610e90d2b517f700340fd9cb8457211a19491af4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4eac9c2b0207ed53bc35898af9586987ee7733c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eac9c2b0207ed53bc35898af9586987ee7733c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4eac9c2b0207ed53bc35898af9586987ee7733c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4eac9c2b0207ed53bc35898af9586987ee7733c9/comments", "author": null, "committer": null, "parents": [{"sha": "2a22f99cb12d82712dd93cfef808b1cef543601b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a22f99cb12d82712dd93cfef808b1cef543601b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a22f99cb12d82712dd93cfef808b1cef543601b"}], "stats": {"total": 172, "additions": 144, "deletions": 28}, "files": [{"sha": "2ce1ca6823a963469c174d65577cf7db592953d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eac9c2b0207ed53bc35898af9586987ee7733c9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eac9c2b0207ed53bc35898af9586987ee7733c9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4eac9c2b0207ed53bc35898af9586987ee7733c9", "patch": "@@ -1,6 +1,16 @@\n+2014-10-12  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/59401\n+\t* config/sh/sh-protos (sh_find_equiv_gbr_addr): Use rtx_insn* instead\n+\tof rtx.\n+\t* config/sh/sh.c (sh_find_equiv_gbr_addr): Use def chains instead of\n+\tinsn walking.\n+\t(sh_find_equiv_gbr_addr): Do nothing if input mem is already a GBR\n+\taddress.  Use def chains to handle GBR clobbering call insns.\n+\n 2014-10-12  Trevor Saunders  <tsaunders@mozilla.com>\n \n-* asan.c, cfgloop.c, cfgloop.h, cgraph.c, cgraph.h,\n+\t* asan.c, cfgloop.c, cfgloop.h, cgraph.c, cgraph.h,\n \tconfig/darwin.c, config/m32c/m32c.c, config/mep/mep.c,\n \tconfig/mips/mips.c, config/rs6000/rs6000.c, dwarf2out.c,\n \tfunction.c, function.h, gimple-ssa.h, libfuncs.h, optabs.c,\n@@ -32,7 +42,7 @@\n \n 2014-10-11  Martin Liska  <mliska@suse.cz>\n \n-\tPR/63376\n+\tPR middle-end/63376\n \t* cgraphunit.c (symbol_table::process_new_functions): Missing call\n \tfor call_cgraph_insertion_hooks added.\n "}, {"sha": "0839e94317bdc41115fdb30c010212c0075a681a", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eac9c2b0207ed53bc35898af9586987ee7733c9/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eac9c2b0207ed53bc35898af9586987ee7733c9/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=4eac9c2b0207ed53bc35898af9586987ee7733c9", "patch": "@@ -162,7 +162,7 @@ extern bool sh_expand_t_scc (rtx *);\n extern rtx sh_gen_truncate (enum machine_mode, rtx, int);\n extern bool sh_vector_mode_supported_p (enum machine_mode);\n extern bool sh_cfun_trap_exit_p (void);\n-extern rtx sh_find_equiv_gbr_addr (rtx cur_insn, rtx mem);\n+extern rtx sh_find_equiv_gbr_addr (rtx_insn* cur_insn, rtx mem);\n extern int sh_eval_treg_value (rtx op);\n extern HOST_WIDE_INT sh_disp_addr_displacement (rtx mem_op);\n extern int sh_max_mov_insn_displacement (machine_mode mode, bool consider_sh2a);"}, {"sha": "fdf61de3c630b58e50d314ce22fc4ff2c91e2d01", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 58, "deletions": 25, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eac9c2b0207ed53bc35898af9586987ee7733c9/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eac9c2b0207ed53bc35898af9586987ee7733c9/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=4eac9c2b0207ed53bc35898af9586987ee7733c9", "patch": "@@ -13421,11 +13421,10 @@ base_reg_disp::disp (void) const\n }\n \n /* Find the base register and calculate the displacement for a given\n-   address rtx 'x'.\n-   This is done by walking the insn list backwards and following SET insns\n-   that set the value of the specified reg 'x'.  */\n+   address rtx 'x'.  */\n static base_reg_disp\n-sh_find_base_reg_disp (rtx insn, rtx x, disp_t disp = 0, rtx base_reg = NULL)\n+sh_find_base_reg_disp (rtx_insn* insn, rtx x, disp_t disp = 0,\n+\t\t       rtx base_reg = NULL)\n {\n   if (REG_P (x))\n     {\n@@ -13439,31 +13438,37 @@ sh_find_base_reg_disp (rtx insn, rtx x, disp_t disp = 0, rtx base_reg = NULL)\n       if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n \treturn base_reg_disp (base_reg != NULL ? base_reg : x, disp);\n \n-      /* Try to find the previous insn that sets the reg.  */\n-      for (rtx i = prev_nonnote_insn (insn); i != NULL;\n-\t   i = prev_nonnote_insn (i))\n+      /* Find the def of the reg and trace it.  If there are more than one\n+\t defs and they are not the same, assume it's not safe to proceed.  */\n+      rtx_insn* last_i = NULL;\n+      rtx last_set = NULL;\n+      for (df_ref d = DF_REG_DEF_CHAIN (REGNO (x)); d != NULL;\n+\t   d = DF_REF_NEXT_REG (d))\n \t{\n-\t  if (REGNO_REG_SET_P (regs_invalidated_by_call_regset, GBR_REG)\n-\t      && CALL_P (i))\n-\t    break;\n-\n-\t  if (!NONJUMP_INSN_P (i))\n-\t    continue;\n+\t  rtx set = const_cast<rtx> (set_of (x, DF_REF_INSN (d)));\n \n-\t  rtx p = PATTERN (i);\n-\t  if (p != NULL && GET_CODE (p) == SET && REG_P (XEXP (p, 0))\n-\t      && REGNO (XEXP (p, 0)) == REGNO (x))\n+\t  /* Accept multiple defs, as long as they are equal.  */\n+\t  if (last_set == NULL || rtx_equal_p (last_set, set))\n+\t    {\n+\t      last_i = DF_REF_INSN (d);\n+\t      last_set = set;\n+\t    }\n+\t  else\n \t    {\n-\t      /* If the recursion can't find out any more details about the\n-\t\t source of the set, then this reg becomes our new base reg.  */\n-\t      return sh_find_base_reg_disp (i, XEXP (p, 1), disp, XEXP (p, 0));\n+\t      last_i = NULL;\n+\t      last_set = NULL;\n+\t      break;\n \t    }\n \t}\n \n-    /* When here, no previous insn was found that sets the reg.\n-       The input reg is already the base reg.  */\n-    return base_reg_disp (x, disp);\n-  }\n+      if (last_set != NULL && last_i != NULL)\n+\treturn sh_find_base_reg_disp (last_i, XEXP (last_set, 1), disp,\n+\t\t\t\t      XEXP (last_set, 0));\n+\n+      /* When here, no previous insn was found that sets the reg.\n+\t The input reg is already the base reg.  */\n+      return base_reg_disp (x, disp);\n+    }\n \n   else if (GET_CODE (x) == PLUS)\n     {\n@@ -13493,19 +13498,47 @@ sh_find_base_reg_disp (rtx insn, rtx x, disp_t disp = 0, rtx base_reg = NULL)\n    based memory address and return the corresponding new memory address.\n    Return NULL_RTX if not found.  */\n rtx\n-sh_find_equiv_gbr_addr (rtx insn, rtx mem)\n+sh_find_equiv_gbr_addr (rtx_insn* insn, rtx mem)\n {\n-  if (!MEM_P (mem))\n+  if (!MEM_P (mem) || gbr_address_mem (mem, GET_MODE (mem)))\n     return NULL_RTX;\n \n   /* Leave post/pre inc/dec or any other side effect addresses alone.  */\n   if (side_effects_p (XEXP (mem, 0)))\n     return NULL_RTX;\n \n+  /* When not optimizing there might be no dataflow available.  */\n+  if (df == NULL)\n+    return NULL_RTX;\n+\n   base_reg_disp gbr_disp = sh_find_base_reg_disp (insn, XEXP (mem, 0));\n \n   if (gbr_disp.is_reg () && REGNO (gbr_disp.reg ()) == GBR_REG)\n     {\n+      /* If GBR is marked as call clobbered we bail out if we see a call.\n+\t FIXME: Actually should check if this mem refers to the gbr value\n+\t before or after the call.  If there is a store_gbr preceeding this\n+\t mem, it's safe to use GBR for this mem.\n+\n+\t If GBR is not marked as call clobbered, but there is some other\n+\t def than a call, it's probably a load_gbr upon which we also\n+\t bail out to be on the safe side.\n+\t FIXME: Should check if we have a use-after-def case, such as\n+\t the call case above.  */\n+      for (df_ref d = DF_REG_DEF_CHAIN (GBR_REG); d != NULL;\n+\t   d = DF_REF_NEXT_REG (d))\n+\t{\n+\t  if (CALL_P (DF_REF_INSN (d)))\n+\t    {\n+\t      if (REGNO_REG_SET_P (regs_invalidated_by_call_regset, GBR_REG))\n+\t\treturn NULL_RTX;\n+\t      else\n+\t\tcontinue;\n+\t    }\n+\t  else\n+\t    return NULL_RTX;\n+\t}\n+\n       rtx disp = GEN_INT (gbr_disp.disp ());\n       if (gbr_displacement (disp, GET_MODE (mem)))\n \treturn gen_rtx_PLUS (SImode, gen_rtx_REG (SImode, GBR_REG), disp);"}, {"sha": "f34d55f8a754e143a995a06e9b395f05a1a70ce0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eac9c2b0207ed53bc35898af9586987ee7733c9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eac9c2b0207ed53bc35898af9586987ee7733c9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4eac9c2b0207ed53bc35898af9586987ee7733c9", "patch": "@@ -1,3 +1,11 @@\n+2014-10-12  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/59401\n+\tPR target/54760\n+\t* gcc.target/pr54760-5.c: New.\n+\t* gcc.target/pr54760-6.c: New.\n+\t* gcc.target/sh/pr59401-1.c: New.\n+\n 2014-10-11  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \tPR fortran/48979"}, {"sha": "30dfd314e751deee5ddff1ba722478020f11231d", "filename": "gcc/testsuite/gcc.target/sh/pr54760-5.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eac9c2b0207ed53bc35898af9586987ee7733c9/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54760-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eac9c2b0207ed53bc35898af9586987ee7733c9/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54760-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54760-5.c?ref=4eac9c2b0207ed53bc35898af9586987ee7733c9", "patch": "@@ -0,0 +1,26 @@\n+/* Check that the GBR address optimization works when there are multiple\n+   GBR register definitions and function calls, if the GBR is marked as a\n+   call saved register.  */\n+/* { dg-do compile }  */\n+/* { dg-options \"-O1 -fcall-saved-gbr\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } }  */\n+/* { dg-final { scan-assembler-not \"stc\\tgbr\" } } */\n+\n+typedef struct\n+{\n+  int x, y, z, w;\n+} tcb_t;\n+\n+extern void test_00 (void);\n+\n+int\n+test_01 (int x, volatile int* y, int a)\n+{\n+  if (a)\n+    test_00 ();\n+\n+  y[0] = 1;\n+\n+  tcb_t* tcb = (tcb_t*)__builtin_thread_pointer ();\n+  return (a & 5) ? tcb->x : tcb->w;\n+}"}, {"sha": "4bf94c32ec6205f853e4bac78695c810cdc2af6c", "filename": "gcc/testsuite/gcc.target/sh/pr54760-6.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eac9c2b0207ed53bc35898af9586987ee7733c9/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54760-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eac9c2b0207ed53bc35898af9586987ee7733c9/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54760-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54760-6.c?ref=4eac9c2b0207ed53bc35898af9586987ee7733c9", "patch": "@@ -0,0 +1,19 @@\n+/* Check that the GBR address optimization works when the GBR register\n+   definition is not in the same basic block where the GBR memory accesses\n+   are.  */\n+/* { dg-do compile }  */\n+/* { dg-options \"-O1\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } }  */\n+/* { dg-final { scan-assembler-not \"stc\\tgbr\" } } */\n+\n+typedef struct\n+{\n+  int x, y, z, w;\n+} tcb_t;\n+\n+int\n+test_00 (int a, tcb_t* b, int c)\n+{\n+  tcb_t* tcb = (tcb_t*)__builtin_thread_pointer ();\n+  return (a & 5) ? tcb->x : tcb->w;\n+}"}, {"sha": "a2afe1ae6f7def7f379440fd5bd6b5ab1ecd2ff6", "filename": "gcc/testsuite/gcc.target/sh/pr59401-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4eac9c2b0207ed53bc35898af9586987ee7733c9/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr59401-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4eac9c2b0207ed53bc35898af9586987ee7733c9/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr59401-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr59401-1.c?ref=4eac9c2b0207ed53bc35898af9586987ee7733c9", "patch": "@@ -0,0 +1,20 @@\n+/* Check that the GBR address optimization does not produce wrong memory\n+   accesses.  In this case the GBR value must be stored to a normal register\n+   and a GBR memory access must not be done.  */\n+/* { dg-do compile }  */\n+/* { dg-options \"-O1\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\"} { \"\" } }  */\n+/* { dg-final { scan-assembler \"stc\\tgbr\" } } */\n+/* { dg-final { scan-assembler \"bf|bt\" } } */\n+\n+typedef struct\n+{\n+  int x, y, z, w;\n+} tcb_t;\n+\n+int\n+test_00 (int a, tcb_t* b)\n+{\n+  tcb_t* tcb = (a & 5) ? (tcb_t*)__builtin_thread_pointer () : b;\n+  return tcb->w + tcb->x;\n+}"}]}