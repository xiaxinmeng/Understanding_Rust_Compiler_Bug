{"sha": "3306eb80e9693133e9a7c5e37ab59e8d8405ea4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzMwNmViODBlOTY5MzEzM2U5YTdjNWUzN2FiNTllOGQ4NDA1ZWE0ZQ==", "commit": {"author": {"name": "Geoff Keating", "email": "geoffk@cygnus.com", "date": "1999-10-26T06:48:38Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-10-26T06:48:38Z"}, "message": "expmed.c (extract_bit_field): Allow for the case of non-integer objects that are smaller than a word (like...\n\n        * expmed.c (extract_bit_field): Allow for the case of non-integer\n        objects that are smaller than a word (like SFmode on a 64-bit\n        machine).\n\nFrom-SVN: r30185", "tree": {"sha": "18f833dbd6567db4a4f6a65c35f9a900a031ab95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18f833dbd6567db4a4f6a65c35f9a900a031ab95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3306eb80e9693133e9a7c5e37ab59e8d8405ea4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3306eb80e9693133e9a7c5e37ab59e8d8405ea4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3306eb80e9693133e9a7c5e37ab59e8d8405ea4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3306eb80e9693133e9a7c5e37ab59e8d8405ea4e/comments", "author": null, "committer": null, "parents": [{"sha": "543c94cc93c326c0892fb36f248f7d8b11dc2f83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/543c94cc93c326c0892fb36f248f7d8b11dc2f83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/543c94cc93c326c0892fb36f248f7d8b11dc2f83"}], "stats": {"total": 34, "additions": 24, "deletions": 10}, "files": [{"sha": "24f2e3e3d2107386e020976ec323a2d367bc4edb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3306eb80e9693133e9a7c5e37ab59e8d8405ea4e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3306eb80e9693133e9a7c5e37ab59e8d8405ea4e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3306eb80e9693133e9a7c5e37ab59e8d8405ea4e", "patch": "@@ -6,6 +6,10 @@ Tue Oct 26 00:41:54 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n \n Mon Oct 25 23:54:45 1999  Geoff Keating  <geoffk@cygnus.com>\n \n+\t* expmed.c (extract_bit_field): Allow for the case of non-integer\n+\tobjects that are smaller than a word (like SFmode on a 64-bit\n+\tmachine).\n+\n \t* loop.c (basic_induction_var): A non-integer variable which is\n \tbeing set by a paradoxical subreg is probably not a biv.\n "}, {"sha": "be458ce8d05724ed8c8cea33a1426f3bbc295c64", "filename": "gcc/expmed.c", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3306eb80e9693133e9a7c5e37ab59e8d8405ea4e/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3306eb80e9693133e9a7c5e37ab59e8d8405ea4e/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=3306eb80e9693133e9a7c5e37ab59e8d8405ea4e", "patch": "@@ -963,6 +963,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n   register rtx op0 = str_rtx;\n   rtx spec_target = target;\n   rtx spec_target_subreg = 0;\n+  enum machine_mode int_mode;\n #ifdef HAVE_extv\n   int extv_bitsize;\n   enum machine_mode extv_mode;\n@@ -1168,10 +1169,19 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t\t\t   NULL_RTX, 0);\n     }\n   \n-  /* From here on we know the desired field is smaller than a word\n-     so we can assume it is an integer.  So we can safely extract it as one\n-     size of integer, if necessary, and then truncate or extend\n-     to the size that is wanted.  */\n+  /* From here on we know the desired field is smaller than a word.  */\n+\n+  /* Check if there is a correspondingly-sized integer field, so we can\n+     safely extract it as one size of integer, if necessary; then\n+     truncate or extend to the size that is wanted; then use SUBREGs or\n+     convert_to_mode to get one of the modes we really wanted.  */\n+  \n+  int_mode = int_mode_for_mode (tmode);\n+  if (int_mode == BLKmode)\n+    int_mode = int_mode_for_mode (mode);\n+  if (int_mode == BLKmode)\n+    abort();    /* Should probably push op0 out to memory and then\n+\t\t   do a load.  */\n \n   /* OFFSET is the number of words or bytes (UNIT says which)\n      from STR_RTX to the first word or byte containing part of the field.  */\n@@ -1326,15 +1336,15 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t  else\n \t    {\n \t      delete_insns_since (last);\n-\t      target = extract_fixed_bit_field (tmode, op0, offset, bitsize,\n+\t      target = extract_fixed_bit_field (int_mode, op0, offset, bitsize,\n \t\t\t\t\t\tbitpos, target, 1, align);\n \t    }\n \t}\n       else\n         extzv_loses:\n #endif\n-\ttarget = extract_fixed_bit_field (tmode, op0, offset, bitsize, bitpos,\n-\t\t\t\t\t  target, 1, align);\n+      target = extract_fixed_bit_field (int_mode, op0, offset, bitsize, \n+\t\t\t\t\tbitpos, target, 1, align);\n     }\n   else\n     {\n@@ -1462,15 +1472,15 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n \t  else\n \t    {\n \t      delete_insns_since (last);\n-\t      target = extract_fixed_bit_field (tmode, op0, offset, bitsize,\n+\t      target = extract_fixed_bit_field (int_mode, op0, offset, bitsize,\n \t\t\t\t\t\tbitpos, target, 0, align);\n \t    }\n \t} \n       else\n \textv_loses:\n #endif\n-\ttarget = extract_fixed_bit_field (tmode, op0, offset, bitsize, bitpos,\n-\t\t\t\t\t  target, 0, align);\n+      target = extract_fixed_bit_field (int_mode, op0, offset, bitsize, \n+\t\t\t\t\tbitpos, target, 0, align);\n     }\n   if (target == spec_target)\n     return target;"}]}