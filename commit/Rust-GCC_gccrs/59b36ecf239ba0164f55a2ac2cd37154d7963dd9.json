{"sha": "59b36ecf239ba0164f55a2ac2cd37154d7963dd9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTliMzZlY2YyMzliYTAxNjRmNTVhMmFjMmNkMzcxNTRkNzk2M2RkOQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-11-22T20:04:45Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-11-22T20:04:45Z"}, "message": "sanitizer.def (BUILT_IN_ASAN_BEFORE_DYNAMIC_INIT, [...]): New.\n\n\t* sanitizer.def (BUILT_IN_ASAN_BEFORE_DYNAMIC_INIT,\n\tBUILT_IN_ASAN_AFTER_DYNAMIC_INIT): New.\n\t* asan.c (instrument_derefs): Handle also VAR_DECL loads/stores.\n\tDon't instrument accesses to VAR_DECLs which are known to fit\n\tinto their bounds and the vars are known to have shadow bytes\n\tindicating allowed access.\n\t(asan_dynamic_init_call): New function.\n\t(asan_add_global): If vnode->dynamically_initialized,\n\tset __has_dynamic_init to 1 instead of 0.\n\t(initialize_sanitizer_builtins): Add BT_FN_VOID_CONST_PTR var.\n\t* asan.h (asan_dynamic_init_call): New prototype.\n\t* cgraph.h (varpool_node): Add dynamically_initialized bitfield.\ncp/\n\t* decl2.c: Include asan.h.\n\t(one_static_initialization_or_destruction): If -fsanitize=address,\n\tinit is non-NULL and guard is NULL, set\n\tvnode->dynamically_initialized.\n\t(do_static_initialization_or_destruction): Call\n\t__asan_{before,after}_dynamic_init around the static initialization.\ntestsuite/\n\t* c-c++-common/asan/no-redundant-instrumentation-1.c: Tweak to avoid\n\toptimizing away some __asan_report* calls.\n\nFrom-SVN: r205282", "tree": {"sha": "d11dfc57c47e4f7387f7f22a57a8e10b78aab3e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d11dfc57c47e4f7387f7f22a57a8e10b78aab3e1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59b36ecf239ba0164f55a2ac2cd37154d7963dd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59b36ecf239ba0164f55a2ac2cd37154d7963dd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59b36ecf239ba0164f55a2ac2cd37154d7963dd9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59b36ecf239ba0164f55a2ac2cd37154d7963dd9/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3e749749392a1d8e0db2ddc311239ccbc200a09f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e749749392a1d8e0db2ddc311239ccbc200a09f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e749749392a1d8e0db2ddc311239ccbc200a09f"}], "stats": {"total": 151, "additions": 140, "deletions": 11}, "files": [{"sha": "334d082d9dca2721299ae3944e61113deb87f51f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b36ecf239ba0164f55a2ac2cd37154d7963dd9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b36ecf239ba0164f55a2ac2cd37154d7963dd9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=59b36ecf239ba0164f55a2ac2cd37154d7963dd9", "patch": "@@ -1,3 +1,18 @@\n+2013-11-22  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* sanitizer.def (BUILT_IN_ASAN_BEFORE_DYNAMIC_INIT,\n+\tBUILT_IN_ASAN_AFTER_DYNAMIC_INIT): New.\n+\t* asan.c (instrument_derefs): Handle also VAR_DECL loads/stores.\n+\tDon't instrument accesses to VAR_DECLs which are known to fit\n+\tinto their bounds and the vars are known to have shadow bytes\n+\tindicating allowed access.\n+\t(asan_dynamic_init_call): New function.\n+\t(asan_add_global): If vnode->dynamically_initialized,\n+\tset __has_dynamic_init to 1 instead of 0.\n+\t(initialize_sanitizer_builtins): Add BT_FN_VOID_CONST_PTR var.\n+\t* asan.h (asan_dynamic_init_call): New prototype.\n+\t* cgraph.h (varpool_node): Add dynamically_initialized bitfield.\n+\n 2013-11-22  Martin Jambor  <mjambor@suse.cz>\n \n \tPR rtl-optimization/10474"}, {"sha": "677435e05aed34cdfc96749f4e20046174da9b81", "filename": "gcc/asan.c", "status": "modified", "additions": 67, "deletions": 4, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b36ecf239ba0164f55a2ac2cd37154d7963dd9/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b36ecf239ba0164f55a2ac2cd37154d7963dd9/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=59b36ecf239ba0164f55a2ac2cd37154d7963dd9", "patch": "@@ -224,7 +224,7 @@ along with GCC; see the file COPYING3.  If not see\n        // Name of the module where the global variable is declared.\n        const void *__module_name;\n \n-       // This is always set to NULL for now.\n+       // 1 if it has dynamic initialization, 0 otherwise.\n        uptr __has_dynamic_init;\n      }\n \n@@ -1471,7 +1471,9 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n     case COMPONENT_REF:\n     case INDIRECT_REF:\n     case MEM_REF:\n+    case VAR_DECL:\n       break;\n+      /* FALLTHRU */\n     default:\n       return;\n     }\n@@ -1485,8 +1487,8 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n   tree offset;\n   enum machine_mode mode;\n   int volatilep = 0, unsignedp = 0;\n-  get_inner_reference (t, &bitsize, &bitpos, &offset,\n-\t\t       &mode, &unsignedp, &volatilep, false);\n+  tree inner = get_inner_reference (t, &bitsize, &bitpos, &offset,\n+\t\t\t\t    &mode, &unsignedp, &volatilep, false);\n   if (bitpos % (size_in_bytes * BITS_PER_UNIT)\n       || bitsize != size_in_bytes * BITS_PER_UNIT)\n     {\n@@ -1501,6 +1503,34 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n       return;\n     }\n \n+  if (TREE_CODE (inner) == VAR_DECL\n+      && offset == NULL_TREE\n+      && bitpos >= 0\n+      && DECL_SIZE (inner)\n+      && tree_fits_shwi_p (DECL_SIZE (inner))\n+      && bitpos + bitsize <= tree_to_shwi (DECL_SIZE (inner)))\n+    {\n+      if (DECL_THREAD_LOCAL_P (inner))\n+\treturn;\n+      if (!TREE_STATIC (inner))\n+\t{\n+\t  /* Automatic vars in the current function will be always\n+\t     accessible.  */\n+\t  if (decl_function_context (inner) == current_function_decl)\n+\t    return;\n+\t}\n+      /* Always instrument external vars, they might be dynamically\n+\t initialized.  */\n+      else if (!DECL_EXTERNAL (inner))\n+\t{\n+\t  /* For static vars if they are known not to be dynamically\n+\t     initialized, they will be always accessible.  */\n+\t  struct varpool_node *vnode = varpool_get_node (inner);\n+\t  if (vnode && !vnode->dynamically_initialized)\n+\t    return;\n+\t}\n+    }\n+\n   base = build_fold_addr_expr (t);\n   if (!has_mem_ref_been_instrumented (base, size_in_bytes))\n     {\n@@ -1958,6 +1988,34 @@ transform_statements (void)\n   free_mem_ref_resources ();\n }\n \n+/* Build\n+   __asan_before_dynamic_init (module_name)\n+   or\n+   __asan_after_dynamic_init ()\n+   call.  */\n+\n+tree\n+asan_dynamic_init_call (bool after_p)\n+{\n+  tree fn = builtin_decl_implicit (after_p\n+\t\t\t\t   ? BUILT_IN_ASAN_AFTER_DYNAMIC_INIT\n+\t\t\t\t   : BUILT_IN_ASAN_BEFORE_DYNAMIC_INIT);\n+  tree module_name_cst = NULL_TREE;\n+  if (!after_p)\n+    {\n+      pretty_printer module_name_pp;\n+      pp_string (&module_name_pp, main_input_filename);\n+\n+      if (shadow_ptr_types[0] == NULL_TREE)\n+\tasan_init_shadow_ptr_types ();\n+      module_name_cst = asan_pp_string (&module_name_pp);\n+      module_name_cst = fold_convert (const_ptr_type_node,\n+\t\t\t\t      module_name_cst);\n+    }\n+\n+  return build_call_expr (fn, after_p ? 0 : 1, module_name_cst);\n+}\n+\n /* Build\n    struct __asan_global\n    {\n@@ -2047,7 +2105,10 @@ asan_add_global (tree decl, tree type, vec<constructor_elt, va_gc> *v)\n \t\t\t  fold_convert (const_ptr_type_node, str_cst));\n   CONSTRUCTOR_APPEND_ELT (vinner, NULL_TREE,\n \t\t\t  fold_convert (const_ptr_type_node, module_name_cst));\n-  CONSTRUCTOR_APPEND_ELT (vinner, NULL_TREE, build_int_cst (uptr, 0));\n+  struct varpool_node *vnode = varpool_get_node (decl);\n+  int has_dynamic_init = vnode ? vnode->dynamically_initialized : 0;\n+  CONSTRUCTOR_APPEND_ELT (vinner, NULL_TREE,\n+\t\t\t  build_int_cst (uptr, has_dynamic_init));\n   init = build_constructor (type, vinner);\n   CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, init);\n }\n@@ -2064,6 +2125,8 @@ initialize_sanitizer_builtins (void)\n   tree BT_FN_VOID = build_function_type_list (void_type_node, NULL_TREE);\n   tree BT_FN_VOID_PTR\n     = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n+  tree BT_FN_VOID_CONST_PTR\n+    = build_function_type_list (void_type_node, const_ptr_type_node, NULL_TREE);\n   tree BT_FN_VOID_PTR_PTR\n     = build_function_type_list (void_type_node, ptr_type_node,\n \t\t\t\tptr_type_node, NULL_TREE);"}, {"sha": "89cb5bbca31eaad663a5cf4ef4ae113c717eca7d", "filename": "gcc/asan.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b36ecf239ba0164f55a2ac2cd37154d7963dd9/gcc%2Fasan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b36ecf239ba0164f55a2ac2cd37154d7963dd9/gcc%2Fasan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.h?ref=59b36ecf239ba0164f55a2ac2cd37154d7963dd9", "patch": "@@ -26,6 +26,7 @@ extern void asan_finish_file (void);\n extern rtx asan_emit_stack_protection (rtx, HOST_WIDE_INT *, tree *, int);\n extern bool asan_protect_global (tree);\n extern void initialize_sanitizer_builtins (void);\n+extern tree asan_dynamic_init_call (bool);\n \n /* Alias set for accessing the shadow memory.  */\n extern alias_set_type asan_shadow_set;"}, {"sha": "c6b35f9cfc425c9c145391a607081352633f543d", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b36ecf239ba0164f55a2ac2cd37154d7963dd9/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b36ecf239ba0164f55a2ac2cd37154d7963dd9/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=59b36ecf239ba0164f55a2ac2cd37154d7963dd9", "patch": "@@ -532,6 +532,10 @@ class GTY((tag (\"SYMTAB_VARIABLE\"))) varpool_node : public symtab_node {\n   /* Set when variable has statically initialized pointer\n      or is a static bounds variable and needs initalization.  */\n   unsigned need_bounds_init : 1;\n+\n+  /* Set if the variable is dynamically initialized, except for\n+     function local statics.   */\n+  unsigned dynamically_initialized : 1;\n };\n \n /* Every top level asm statement is put into a asm_node.  */"}, {"sha": "479d919b73be3e8e1e75fe8d8b00fe6022fb7ce0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b36ecf239ba0164f55a2ac2cd37154d7963dd9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b36ecf239ba0164f55a2ac2cd37154d7963dd9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=59b36ecf239ba0164f55a2ac2cd37154d7963dd9", "patch": "@@ -1,3 +1,12 @@\n+2013-11-22  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* decl2.c: Include asan.h.\n+\t(one_static_initialization_or_destruction): If -fsanitize=address,\n+\tinit is non-NULL and guard is NULL, set\n+\tvnode->dynamically_initialized.\n+\t(do_static_initialization_or_destruction): Call\n+\t__asan_{before,after}_dynamic_init around the static initialization.\n+\n 2013-11-22  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* class.c: Add required include files from gimple.h."}, {"sha": "0e37a5d246c4649026f9e8705b12b89e21640dc7", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b36ecf239ba0164f55a2ac2cd37154d7963dd9/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b36ecf239ba0164f55a2ac2cd37154d7963dd9/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=59b36ecf239ba0164f55a2ac2cd37154d7963dd9", "patch": "@@ -54,6 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"splay-tree.h\"\n #include \"langhooks.h\"\n #include \"c-family/c-ada-spec.h\"\n+#include \"asan.h\"\n \n extern cpp_reader *parse_in;\n \n@@ -3461,7 +3462,15 @@ one_static_initialization_or_destruction (tree decl, tree init, bool initp)\n   if (initp)\n     {\n       if (init)\n-\tfinish_expr_stmt (init);\n+\t{\n+\t  finish_expr_stmt (init);\n+\t  if (flag_sanitize & SANITIZE_ADDRESS)\n+\t    {\n+\t      struct varpool_node *vnode = varpool_get_node (decl);\n+\t      if (vnode)\n+\t\tvnode->dynamically_initialized = 1;\n+\t    }\n+\t}\n \n       /* If we're using __cxa_atexit, register a function that calls the\n \t destructor for the object.  */\n@@ -3503,6 +3512,16 @@ do_static_initialization_or_destruction (tree vars, bool initp)\n \t\t\t     tf_warning_or_error);\n   finish_if_stmt_cond (cond, init_if_stmt);\n \n+  /* To make sure dynamic construction doesn't access globals from other\n+     compilation units where they might not be yet constructed, for\n+     -fsanitize=address insert __asan_before_dynamic_init call that\n+     prevents access to either all global variables that need construction\n+     in other compilation units, or at least those that haven't been\n+     initialized yet.  Variables that need dynamic construction in\n+     the current compilation unit are kept accessible.  */\n+  if (flag_sanitize & SANITIZE_ADDRESS)\n+    finish_expr_stmt (asan_dynamic_init_call (/*after_p=*/false));\n+\n   node = vars;\n   do {\n     tree decl = TREE_VALUE (node);\n@@ -3551,6 +3570,11 @@ do_static_initialization_or_destruction (tree vars, bool initp)\n \n   } while (node);\n \n+  /* Revert what __asan_before_dynamic_init did by calling\n+     __asan_after_dynamic_init.  */\n+  if (flag_sanitize & SANITIZE_ADDRESS)\n+    finish_expr_stmt (asan_dynamic_init_call (/*after_p=*/true));\n+\n   /* Finish up the init/destruct if-stmt body.  */\n   finish_then_clause (init_if_stmt);\n   finish_if_stmt (init_if_stmt);"}, {"sha": "ad1248dd999fe17ebcbb6befd2974562210f14e0", "filename": "gcc/sanitizer.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b36ecf239ba0164f55a2ac2cd37154d7963dd9/gcc%2Fsanitizer.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b36ecf239ba0164f55a2ac2cd37154d7963dd9/gcc%2Fsanitizer.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanitizer.def?ref=59b36ecf239ba0164f55a2ac2cd37154d7963dd9", "patch": "@@ -60,6 +60,12 @@ DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_UNREGISTER_GLOBALS,\n DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_HANDLE_NO_RETURN,\n \t\t      \"__asan_handle_no_return\",\n \t\t      BT_FN_VOID, ATTR_TMPURE_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_BEFORE_DYNAMIC_INIT,\n+\t\t      \"__asan_before_dynamic_init\",\n+\t\t      BT_FN_VOID_CONST_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_ASAN_AFTER_DYNAMIC_INIT,\n+\t\t      \"__asan_after_dynamic_init\",\n+\t\t      BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n \n /* Thread Sanitizer */\n DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_INIT, \"__tsan_init\", "}, {"sha": "a98a7b97a135f44291847b785b59ff44d9d527ff", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b36ecf239ba0164f55a2ac2cd37154d7963dd9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b36ecf239ba0164f55a2ac2cd37154d7963dd9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=59b36ecf239ba0164f55a2ac2cd37154d7963dd9", "patch": "@@ -1,3 +1,8 @@\n+2013-11-22  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-c++-common/asan/no-redundant-instrumentation-1.c: Tweak to avoid\n+\toptimizing away some __asan_report* calls.\n+\n 2013-11-22  Martin Jambor  <mjambor@suse.cz>\n \n \t* gcc.dg/pr10474.c: Also test ppc64."}, {"sha": "fa52e0ca85dad7a45146ffa6198f86a711463604", "filename": "gcc/testsuite/c-c++-common/asan/no-redundant-instrumentation-1.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59b36ecf239ba0164f55a2ac2cd37154d7963dd9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59b36ecf239ba0164f55a2ac2cd37154d7963dd9/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fasan%2Fno-redundant-instrumentation-1.c?ref=59b36ecf239ba0164f55a2ac2cd37154d7963dd9", "patch": "@@ -6,7 +6,7 @@\n /* { dg-do compile } */\n /* { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-O0\" } } */\n \n-static char tab[4] = {0};\n+extern char tab[4];\n \n static int\n test0 ()\n@@ -27,12 +27,14 @@ test0 ()\n   return t0 + t1;\n }\n \n-static int\n-test1 ()\n+__attribute__((noinline, noclone)) static int\n+test1 (int i)\n {\n+  char foo[4] = {};\n+  \n   /*__builtin___asan_report_store1 called 1 time here to instrument\n     the initialization.  */\n-  char foo[4] = {1}; \n+  foo[i] = 1;\n \n   /*__builtin___asan_report_store1 called 2 times here to instrument\n     the store to the memory region of tab.  */\n@@ -45,7 +47,7 @@ test1 ()\n   /* There are 2 calls to __builtin___asan_report_store1 and 2 calls\n      to __builtin___asan_report_load1 to instrument the store to\n      (subset of) the memory region of tab.  */\n-  __builtin_memcpy (&tab[1], foo, 3);\n+  __builtin_memcpy (&tab[1], foo + i, 3);\n \n   /* This should not generate a __builtin___asan_report_load1 because\n      the reference to tab[1] has been already instrumented above.  */\n@@ -58,7 +60,7 @@ test1 ()\n int\n main ()\n {\n-  return test0 () && test1 ();\n+  return test0 () && test1 (0);\n }\n \n /* { dg-final { scan-tree-dump-times \"__builtin___asan_report_store1\" 7 \"asan0\" } } */"}]}