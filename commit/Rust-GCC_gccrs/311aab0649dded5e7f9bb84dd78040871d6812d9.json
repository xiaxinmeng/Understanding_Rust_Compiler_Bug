{"sha": "311aab0649dded5e7f9bb84dd78040871d6812d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzExYWFiMDY0OWRkZWQ1ZTdmOWJiODRkZDc4MDQwODcxZDY4MTJkOQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2009-01-06T03:50:07Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2009-01-06T03:50:07Z"}, "message": "re PR rtl-optimization/38583 (huge test case makes register allocator run out of memory while constructing the conflict graph)\n\n2009-01-05  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR rtl-optimization/38583\n\t* params.h (IRA_MAX_CONFLICT_TABLE_SIZE): New macro.\n\n\t* params.def (ira-max-conflict-table-size): New.\n\n\t* doc/invoke.texi (ira-max-conflict-table-size): Decribe.\n\t\n\t* ira.h (ira_conflicts_p): New external definition.\n\t\n\t* ira-conflicts.c (build_conflict_bit_table): Do not build too big\n\ttable.  Report this.  Return result of building.\n\t(ira_build_conflicts): Use ira_conflicts_p.  Check result of\n\tbuilding conflict table.\n\n\t* ira-color.c (fast_allocation): Use num instead of\n\tira_allocnos_num.\n\t(ira_color): Use ira_conflicts_p.\n\t\n\t* global.c: Include ira.h.\n\t(pseudo_for_reload_consideration_p, build_insn_chain): Use\n\tira_conflicts_p.\n\n\t* Makefile.in (global.o): Add ira.h.\n\t\n\t* ira-build.c (mark_all_loops_for_removal,\n\tpropagate_some_info_from_allocno): New.\n\t(remove_unnecessary_allocnos): Call\n\tpropagate_some_info_from_allocno.\n\t(remove_low_level_allocnos): New.\n\t(remove_unnecessary_regions): Add parameter.  Call\n\tmark_all_loops_for_removal and remove_low_level_allocnos.  Pass\n\tparameter to remove_unnecessary_regions.\n\t(ira_build): Remove all regions but root if the conflict table was\n\tnot built.  Update conflict hard regs for allocnos crossing calls.\n\n\t* ira.c (ira_conflicts_p): New global.\n\t(ira): Define and use ira_conflicts_p.\n\n\t* reload1.c (compute_use_by_pseudos, reload, count_pseudo,\n\tcount_spilled_pseudo, find_reg, alter_reg, finish_spills,\n\temit_input_reload_insns, delete_output_reload): Use\n\tira_conflicts_p.\n\nFrom-SVN: r143112", "tree": {"sha": "3ab87fe84116bf920cb2e70b665eec2ced158fdf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ab87fe84116bf920cb2e70b665eec2ced158fdf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/311aab0649dded5e7f9bb84dd78040871d6812d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/311aab0649dded5e7f9bb84dd78040871d6812d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/311aab0649dded5e7f9bb84dd78040871d6812d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/311aab0649dded5e7f9bb84dd78040871d6812d9/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9bfea41b05947073cce682a8a6cf14924064fbde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bfea41b05947073cce682a8a6cf14924064fbde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bfea41b05947073cce682a8a6cf14924064fbde"}], "stats": {"total": 416, "additions": 324, "deletions": 92}, "files": [{"sha": "0fda2b414dc6698fdd8d08c5e29042e73a6cd720", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=311aab0649dded5e7f9bb84dd78040871d6812d9", "patch": "@@ -1,3 +1,48 @@\n+2009-01-05  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR rtl-optimization/38583\n+\t* params.h (IRA_MAX_CONFLICT_TABLE_SIZE): New macro.\n+\n+\t* params.def (ira-max-conflict-table-size): New.\n+\n+\t* doc/invoke.texi (ira-max-conflict-table-size): Decribe.\n+\t\n+\t* ira.h (ira_conflicts_p): New external definition.\n+\t\n+\t* ira-conflicts.c (build_conflict_bit_table): Do not build too big\n+\ttable.  Report this.  Return result of building.\n+\t(ira_build_conflicts): Use ira_conflicts_p.  Check result of\n+\tbuilding conflict table.\n+\n+\t* ira-color.c (fast_allocation): Use num instead of\n+\tira_allocnos_num.\n+\t(ira_color): Use ira_conflicts_p.\n+\t\n+\t* global.c: Include ira.h.\n+\t(pseudo_for_reload_consideration_p, build_insn_chain): Use\n+\tira_conflicts_p.\n+\n+\t* Makefile.in (global.o): Add ira.h.\n+\t\n+\t* ira-build.c (mark_all_loops_for_removal,\n+\tpropagate_some_info_from_allocno): New.\n+\t(remove_unnecessary_allocnos): Call\n+\tpropagate_some_info_from_allocno.\n+\t(remove_low_level_allocnos): New.\n+\t(remove_unnecessary_regions): Add parameter.  Call\n+\tmark_all_loops_for_removal and remove_low_level_allocnos.  Pass\n+\tparameter to remove_unnecessary_regions.\n+\t(ira_build): Remove all regions but root if the conflict table was\n+\tnot built.  Update conflict hard regs for allocnos crossing calls.\n+\n+\t* ira.c (ira_conflicts_p): New global.\n+\t(ira): Define and use ira_conflicts_p.\n+\n+\t* reload1.c (compute_use_by_pseudos, reload, count_pseudo,\n+\tcount_spilled_pseudo, find_reg, alter_reg, finish_spills,\n+\temit_input_reload_insns, delete_output_reload): Use\n+\tira_conflicts_p.\n+\t\n 2009-01-06  Ben Elliston  <bje@au.ibm.com>\n \n \t* gengtype-lex.l (YY_NO_INPUT): Define."}, {"sha": "83c503621ae13e8283c4c9bf5ba09fa9e004c593", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=311aab0649dded5e7f9bb84dd78040871d6812d9", "patch": "@@ -2860,7 +2860,7 @@ bitmap.o : bitmap.c $(CONFIG_H) $(SYSTEM_H)  coretypes.h $(TM_H) $(RTL_H) \\\n global.o : global.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) reload.h $(FUNCTION_H) $(RECOG_H) $(REGS_H) hard-reg-set.h \\\n    insn-config.h output.h $(TOPLEV_H) $(TM_P_H) $(MACHMODE_H) tree-pass.h \\\n-   $(TIMEVAR_H) vecprim.h $(DF_H) $(DBGCNT_H) $(RA_H)\n+   $(TIMEVAR_H) vecprim.h $(DF_H) $(DBGCNT_H) $(RA_H) ira.h\n ra-conflict.o : ra-conflict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(FLAGS_H) reload.h $(FUNCTION_H) $(RECOG_H) $(REGS_H) hard-reg-set.h \\\n    insn-config.h output.h $(TOPLEV_H) $(TM_P_H) $(MACHMODE_H) tree-pass.h \\"}, {"sha": "47e718b1a20f8a7e03d2299e862c313e593e7771", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=311aab0649dded5e7f9bb84dd78040871d6812d9", "patch": "@@ -7617,6 +7617,15 @@ given number of the most frequently executed loops will form regions\n for the regional register allocation.  The default value of the\n parameter is 100.\n \n+@item ira-max-conflict-table-size\n+Although IRA uses a sophisticated algorithm of compression conflict\n+table, the table can be still big for huge functions.  If the conflict\n+table for a function could be more than size in MB given by the\n+parameter, the conflict table is not built and faster, simpler, and\n+lower quality register allocation algorithm will be used.  The\n+algorithm do not use pseudo-register conflicts.  The default value of\n+the parameter is 2000.\n+\n @end table\n @end table\n "}, {"sha": "abf070d91c27dd2cc080e248a6372300d0f48a7c", "filename": "gcc/global.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=311aab0649dded5e7f9bb84dd78040871d6812d9", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vecprim.h\"\n #include \"dbgcnt.h\"\n #include \"ra.h\"\n+#include \"ira.h\"\n \n /* This pass of the compiler performs global register allocation.\n    It assigns hard register numbers to all the pseudo registers\n@@ -1394,7 +1395,7 @@ pseudo_for_reload_consideration_p (int regno)\n   /* Consider spilled pseudos too for IRA because they still have a\n      chance to get hard-registers in the reload when IRA is used.  */\n   return (reg_renumber[regno] >= 0\n-\t  || (flag_ira && optimize && flag_ira_share_spill_slots));\n+\t  || (flag_ira && ira_conflicts_p && flag_ira_share_spill_slots));\n }\n \n /* Walk the insns of the current function and build reload_insn_chain,\n@@ -1483,7 +1484,7 @@ build_insn_chain (void)\n \n \t\t    if ((regno < FIRST_PSEUDO_REGISTER\n \t\t\t || reg_renumber[regno] >= 0\n-\t\t\t || (flag_ira && optimize))\n+\t\t\t || (flag_ira && ira_conflicts_p))\n \t\t\t&& (!DF_REF_FLAGS_IS_SET (def, DF_REF_CONDITIONAL)))\n \t\t      {\n \t\t\trtx reg = DF_REF_REG (def);"}, {"sha": "00df69c6d2e67554b3fdbbdba2ea4d7f278781e2", "filename": "gcc/ira-build.c", "status": "modified", "additions": 177, "deletions": 48, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=311aab0649dded5e7f9bb84dd78040871d6812d9", "patch": "@@ -1751,6 +1751,33 @@ mark_loops_for_removal (void)\n   ira_free (sorted_loops);\n }\n \n+/* Mark all loops but root for removing.  */\n+static void\n+mark_all_loops_for_removal (void)\n+{\n+  int i;\n+  loop_p loop;\n+\n+  for (i = 0; VEC_iterate (loop_p, ira_loops.larray, i, loop); i++)\n+    if (ira_loop_nodes[i].regno_allocno_map != NULL)\n+      {\n+\tif (ira_loop_nodes[i].parent == NULL)\n+\t  {\n+\t    /* Don't remove the root.  */\n+\t    ira_loop_nodes[i].to_remove_p = false;\n+\t    continue;\n+\t  }\n+\tira_loop_nodes[i].to_remove_p = true;\n+\tif (internal_flag_ira_verbose > 1 && ira_dump_file != NULL)\n+\t  fprintf\n+\t    (ira_dump_file,\n+\t     \"  Mark loop %d (header %d, freq %d, depth %d) for removal\\n\",\n+\t     ira_loop_nodes[i].loop->num,\n+\t     ira_loop_nodes[i].loop->header->index,\n+\t     ira_loop_nodes[i].loop->header->frequency,\n+\t     loop_depth (ira_loop_nodes[i].loop));\n+      }\n+}\n \n /* Definition of vector of loop tree nodes.  */\n DEF_VEC_P(ira_loop_tree_node_t);\n@@ -1856,14 +1883,50 @@ ira_rebuild_regno_allocno_list (int regno)\n     fprintf (ira_dump_file, \" Rebuilding regno allocno list for %d\\n\", regno);\n }\n \n+/* Propagate info from allocno FROM_A to allocno A.  */\n+static void\n+propagate_some_info_from_allocno (ira_allocno_t a, ira_allocno_t from_a)\n+{\n+  enum reg_class cover_class;\n+\n+  IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (a),\n+\t\t    ALLOCNO_CONFLICT_HARD_REGS (from_a));\n+#ifdef STACK_REGS\n+  if (ALLOCNO_NO_STACK_REG_P (from_a))\n+    ALLOCNO_NO_STACK_REG_P (a) = true;\n+#endif\n+  ALLOCNO_NREFS (a) += ALLOCNO_NREFS (from_a);\n+  ALLOCNO_FREQ (a) += ALLOCNO_FREQ (from_a);\n+  ALLOCNO_CALL_FREQ (a) += ALLOCNO_CALL_FREQ (from_a);\n+  IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a),\n+\t\t    ALLOCNO_TOTAL_CONFLICT_HARD_REGS (from_a));\n+  ALLOCNO_CALLS_CROSSED_NUM (a) += ALLOCNO_CALLS_CROSSED_NUM (from_a);\n+  ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a)\n+    += ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (from_a);\n+  if (! ALLOCNO_BAD_SPILL_P (from_a))\n+    ALLOCNO_BAD_SPILL_P (a) = false;\n+#ifdef STACK_REGS\n+  if (ALLOCNO_TOTAL_NO_STACK_REG_P (from_a))\n+    ALLOCNO_TOTAL_NO_STACK_REG_P (a) = true;\n+#endif\n+  cover_class = ALLOCNO_COVER_CLASS (from_a);\n+  ira_assert (cover_class == ALLOCNO_COVER_CLASS (a));\n+  ira_allocate_and_accumulate_costs (&ALLOCNO_HARD_REG_COSTS (a), cover_class,\n+\t\t\t\t     ALLOCNO_HARD_REG_COSTS (from_a));\n+  ira_allocate_and_accumulate_costs (&ALLOCNO_CONFLICT_HARD_REG_COSTS (a),\n+\t\t\t\t     cover_class,\n+\t\t\t\t     ALLOCNO_CONFLICT_HARD_REG_COSTS (from_a));\n+  ALLOCNO_COVER_CLASS_COST (a) += ALLOCNO_COVER_CLASS_COST (from_a);\n+  ALLOCNO_MEMORY_COST (a) += ALLOCNO_MEMORY_COST (from_a);\n+}\n+\n /* Remove allocnos from loops removed from the allocation\n    consideration.  */\n static void\n remove_unnecessary_allocnos (void)\n {\n   int regno;\n   bool merged_p, rebuild_p;\n-  enum reg_class cover_class;\n   ira_allocno_t a, prev_a, next_a, parent_a;\n   ira_loop_tree_node_t a_node, parent;\n   allocno_live_range_t r;\n@@ -1890,9 +1953,9 @@ remove_unnecessary_allocnos (void)\n \t\t;\n \t      if (parent_a == NULL)\n \t\t{\n-\t\t/* There are no allocnos with the same regno in upper\n-\t\t   region -- just move the allocno to the upper\n-\t\t   region.  */\n+\t\t  /* There are no allocnos with the same regno in\n+\t\t     upper region -- just move the allocno to the\n+\t\t     upper region.  */\n \t\t  prev_a = a;\n \t\t  ALLOCNO_LOOP_TREE_NODE (a) = parent;\n \t\t  parent->regno_allocno_map[regno] = a;\n@@ -1911,43 +1974,10 @@ remove_unnecessary_allocnos (void)\n \t\t  change_allocno_in_range_list (r, parent_a);\n \t\t  ALLOCNO_LIVE_RANGES (parent_a)\n \t\t    = ira_merge_allocno_live_ranges\n-\t\t    (r, ALLOCNO_LIVE_RANGES (parent_a));\n+\t\t      (r, ALLOCNO_LIVE_RANGES (parent_a));\n \t\t  merged_p = true;\n \t\t  ALLOCNO_LIVE_RANGES (a) = NULL;\n-\t\t  IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (parent_a),\n-\t\t\t\t    ALLOCNO_CONFLICT_HARD_REGS (a));\n-#ifdef STACK_REGS\n-\t\t  if (ALLOCNO_NO_STACK_REG_P (a))\n-\t\t    ALLOCNO_NO_STACK_REG_P (parent_a) = true;\n-#endif\n-\t\t  ALLOCNO_NREFS (parent_a) += ALLOCNO_NREFS (a);\n-\t\t  ALLOCNO_FREQ (parent_a) += ALLOCNO_FREQ (a);\n-\t\t  ALLOCNO_CALL_FREQ (parent_a) += ALLOCNO_CALL_FREQ (a);\n-\t\t  IOR_HARD_REG_SET\n-\t\t    (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (parent_a),\n-\t\t     ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a));\n-\t\t  ALLOCNO_CALLS_CROSSED_NUM (parent_a)\n-\t\t    += ALLOCNO_CALLS_CROSSED_NUM (a);\n-\t\t  ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (parent_a)\n-\t\t    += ALLOCNO_EXCESS_PRESSURE_POINTS_NUM (a);\n-\t\t  if (! ALLOCNO_BAD_SPILL_P (a))\n-\t\t    ALLOCNO_BAD_SPILL_P (parent_a) = false;\n-#ifdef STACK_REGS\n-\t\t  if (ALLOCNO_TOTAL_NO_STACK_REG_P (a))\n-\t\t    ALLOCNO_TOTAL_NO_STACK_REG_P (parent_a) = true;\n-#endif\n-\t\t  cover_class = ALLOCNO_COVER_CLASS (a);\n-\t\t  ira_assert (cover_class == ALLOCNO_COVER_CLASS (parent_a));\n-\t\t  ira_allocate_and_accumulate_costs\n-\t\t    (&ALLOCNO_HARD_REG_COSTS (parent_a), cover_class,\n-\t\t     ALLOCNO_HARD_REG_COSTS (a));\n-\t\t  ira_allocate_and_accumulate_costs\n-\t\t    (&ALLOCNO_CONFLICT_HARD_REG_COSTS (parent_a),\n-\t\t     cover_class,\n-\t\t     ALLOCNO_CONFLICT_HARD_REG_COSTS (a));\n-\t\t  ALLOCNO_COVER_CLASS_COST (parent_a)\n-\t\t    += ALLOCNO_COVER_CLASS_COST (a);\n-\t\t  ALLOCNO_MEMORY_COST (parent_a) += ALLOCNO_MEMORY_COST (a);\n+\t\t  propagate_some_info_from_allocno (parent_a, a);\n \t\t  finish_allocno (a);\n \t\t}\n \t    }\n@@ -1968,15 +1998,88 @@ remove_unnecessary_allocnos (void)\n     ira_free (regno_allocnos);\n }\n \n-/* Remove loops from consideration.  We remove loops for which a\n-   separate allocation will not improve the result.  We have to do\n-   this after allocno creation and their costs and cover class\n-   evaluation because only after that the register pressure can be\n-   known and is calculated.  */\n+/* Remove allocnos from all loops but the root.  */\n static void\n-remove_unnecessary_regions (void)\n+remove_low_level_allocnos (void)\n {\n-  mark_loops_for_removal ();\n+  int regno;\n+  bool merged_p, propagate_p;\n+  ira_allocno_t a, top_a;\n+  ira_loop_tree_node_t a_node, parent;\n+  allocno_live_range_t r;\n+  ira_allocno_iterator ai;\n+\n+  merged_p = false;\n+  FOR_EACH_ALLOCNO (a, ai)\n+    {\n+      a_node = ALLOCNO_LOOP_TREE_NODE (a);\n+      if (a_node == ira_loop_tree_root || ALLOCNO_CAP_MEMBER (a) != NULL)\n+\tcontinue;\n+      regno = ALLOCNO_REGNO (a);\n+      if ((top_a = ira_loop_tree_root->regno_allocno_map[regno]) == NULL)\n+\t{\n+\t  ALLOCNO_LOOP_TREE_NODE (a) = ira_loop_tree_root;\n+\t  ira_loop_tree_root->regno_allocno_map[regno] = a;\n+\t  continue;\n+\t}\n+      propagate_p = a_node->parent->regno_allocno_map[regno] == NULL;\n+      /* Remove the allocno and update info of allocno in the upper\n+\t region.  */\n+      r = ALLOCNO_LIVE_RANGES (a);\n+      change_allocno_in_range_list (r, top_a);\n+      ALLOCNO_LIVE_RANGES (top_a)\n+\t= ira_merge_allocno_live_ranges (r, ALLOCNO_LIVE_RANGES (top_a));\n+      merged_p = true;\n+      ALLOCNO_LIVE_RANGES (a) = NULL;\n+      if (propagate_p)\n+\tpropagate_some_info_from_allocno (top_a, a);\n+    }\n+  FOR_EACH_ALLOCNO (a, ai)\n+    {\n+      a_node = ALLOCNO_LOOP_TREE_NODE (a);\n+      if (a_node == ira_loop_tree_root)\n+\tcontinue;\n+      parent = a_node->parent;\n+      regno = ALLOCNO_REGNO (a);\n+      if (ALLOCNO_CAP_MEMBER (a) != NULL)\n+\tira_assert (ALLOCNO_CAP (a) != NULL);\n+      else if (ALLOCNO_CAP (a) == NULL)\n+ \tira_assert (parent->regno_allocno_map[regno] != NULL);\n+    }\n+  FOR_EACH_ALLOCNO (a, ai)\n+    {\n+      regno = ALLOCNO_REGNO (a);\n+      if (ira_loop_tree_root->regno_allocno_map[regno] == a)\n+\t{\n+\t  ira_regno_allocno_map[regno] = a;\n+\t  ALLOCNO_NEXT_REGNO_ALLOCNO (a) = NULL;\n+\t  ALLOCNO_CAP_MEMBER (a) = NULL;\n+\t  COPY_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (a),\n+\t\t\t     ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a));\n+#ifdef STACK_REGS\n+\t  if (ALLOCNO_TOTAL_NO_STACK_REG_P (a))\n+\t    ALLOCNO_NO_STACK_REG_P (a) = true;\n+#endif\n+\t}\n+      else\n+\tfinish_allocno (a);\n+    }\n+  if (merged_p)\n+    ira_rebuild_start_finish_chains ();\n+}\n+\n+/* Remove loops from consideration.  We remove all loops except for\n+   root if ALL_P or loops for which a separate allocation will not\n+   improve the result.  We have to do this after allocno creation and\n+   their costs and cover class evaluation because only after that the\n+   register pressure can be known and is calculated.  */\n+static void\n+remove_unnecessary_regions (bool all_p)\n+{\n+  if (all_p)\n+    mark_all_loops_for_removal ();\n+  else\n+    mark_loops_for_removal ();\n   children_vec\n     = VEC_alloc (ira_loop_tree_node_t, heap,\n \t\t last_basic_block + VEC_length (loop_p, ira_loops.larray));\n@@ -1985,7 +2088,10 @@ remove_unnecessary_regions (void)\n \t\t last_basic_block + VEC_length (loop_p, ira_loops.larray));\n   remove_uneccesary_loop_nodes_from_loop_tree (ira_loop_tree_root) ;\n   VEC_free (ira_loop_tree_node_t, heap, children_vec);\n-  remove_unnecessary_allocnos ();\n+  if (all_p)\n+    remove_low_level_allocnos ();\n+  else\n+    remove_unnecessary_allocnos ();\n   while (VEC_length (ira_loop_tree_node_t, removed_loop_vec) > 0)\n     finish_loop_tree_node (VEC_pop (ira_loop_tree_node_t, removed_loop_vec));\n   VEC_free (ira_loop_tree_node_t, heap, removed_loop_vec);\n@@ -2668,7 +2774,7 @@ ira_build (bool loops_p)\n   create_allocnos ();\n   ira_costs ();\n   ira_create_allocno_live_ranges ();\n-  remove_unnecessary_regions ();\n+  remove_unnecessary_regions (false);\n   ira_compress_allocno_live_ranges ();\n   update_bad_spill_attribute ();\n   loops_p = more_one_region_p ();\n@@ -2685,6 +2791,29 @@ ira_build (bool loops_p)\n   sort_conflict_id_allocno_map ();\n   setup_min_max_conflict_allocno_ids ();\n   ira_build_conflicts ();\n+  if (! ira_conflicts_p)\n+    {\n+      ira_allocno_t a;\n+      ira_allocno_iterator ai;\n+\n+      /* Remove all regions but root one.  */\n+      if (loops_p)\n+\t{\n+\t  remove_unnecessary_regions (true);\n+\t  loops_p = false;\n+\t}\n+      /* We don't save hard registers around calls for fast allocation\n+\t -- add caller clobbered registers as conflicting ones to\n+\t allocno crossing calls.  */\n+      FOR_EACH_ALLOCNO (a, ai)\n+\tif (ALLOCNO_CALLS_CROSSED_NUM (a) != 0)\n+\t  {\n+\t    IOR_HARD_REG_SET (ALLOCNO_TOTAL_CONFLICT_HARD_REGS (a),\n+\t\t\t      call_used_reg_set);\n+\t    IOR_HARD_REG_SET (ALLOCNO_CONFLICT_HARD_REGS (a),\n+\t\t\t      call_used_reg_set);\n+\t  }\n+    }\n   if (internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n     print_copies (ira_dump_file);\n   if (internal_flag_ira_verbose > 0 && ira_dump_file != NULL)"}, {"sha": "c7c600bc41c58aafc99ea642fd92977bd79bbfd1", "filename": "gcc/ira-color.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2Fira-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2Fira-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-color.c?ref=311aab0649dded5e7f9bb84dd78040871d6812d9", "patch": "@@ -3267,7 +3267,7 @@ fast_allocation (void)\n \t\t\t\t\t\t  * ira_max_point);\n   for (i = 0; i < ira_max_point; i++)\n     CLEAR_HARD_REG_SET (used_hard_regs[i]);\n-  qsort (sorted_allocnos, ira_allocnos_num, sizeof (ira_allocno_t), \n+  qsort (sorted_allocnos, num, sizeof (ira_allocno_t),\n \t allocno_priority_compare_func);\n   for (i = 0; i < num; i++)\n     {\n@@ -3329,7 +3329,7 @@ ira_color (void)\n       ALLOCNO_UPDATED_MEMORY_COST (a) = ALLOCNO_MEMORY_COST (a);\n       ALLOCNO_UPDATED_COVER_CLASS_COST (a) = ALLOCNO_COVER_CLASS_COST (a);\n     }\n-  if (optimize)\n+  if (ira_conflicts_p)\n     color ();\n   else\n     fast_allocation ();"}, {"sha": "244d3bc9b3ef2ecc299e5ee5a962a9b4becc5df0", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 47, "deletions": 18, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=311aab0649dded5e7f9bb84dd78040871d6812d9", "patch": "@@ -60,8 +60,10 @@ static IRA_INT_TYPE **conflicts;\n \n \f\n \n-/* Build allocno conflict table by processing allocno live ranges.  */\n-static void\n+/* Build allocno conflict table by processing allocno live ranges.\n+   Return true if the table was built.  The table is not built if it\n+   is too big.  */\n+static bool\n build_conflict_bit_table (void)\n {\n   int i, num, id, allocated_words_num, conflict_bit_vec_words_num;\n@@ -74,6 +76,26 @@ build_conflict_bit_table (void)\n   int allocno_set_words;\n \n   allocno_set_words = (ira_allocnos_num + IRA_INT_BITS - 1) / IRA_INT_BITS;\n+  allocated_words_num = 0;\n+  FOR_EACH_ALLOCNO (allocno, ai)\n+    {\n+      if (ALLOCNO_MAX (allocno) < ALLOCNO_MIN (allocno))\n+\t  continue;\n+      conflict_bit_vec_words_num\n+\t= ((ALLOCNO_MAX (allocno) - ALLOCNO_MIN (allocno) + IRA_INT_BITS)\n+\t   / IRA_INT_BITS);\n+      allocated_words_num += conflict_bit_vec_words_num;\n+      if ((unsigned long long) allocated_words_num * sizeof (IRA_INT_TYPE)\n+\t  > (unsigned long long) IRA_MAX_CONFLICT_TABLE_SIZE * 1024 * 1024)\n+\t{\n+\t  if (internal_flag_ira_verbose > 0 && ira_dump_file != NULL)\n+\t    fprintf\n+\t      (ira_dump_file,\n+\t       \"+++Conflict table will be too big(>%dMB) -- don't use it\\n\",\n+\t       IRA_MAX_CONFLICT_TABLE_SIZE);\n+\t  return false;\n+\t}\n+    }\n   allocnos_live = sparseset_alloc (ira_allocnos_num);\n   conflicts = (IRA_INT_TYPE **) ira_allocate (sizeof (IRA_INT_TYPE *)\n \t\t\t\t\t      * ira_allocnos_num);\n@@ -134,6 +156,7 @@ build_conflict_bit_table (void)\n \tsparseset_clear_bit (allocnos_live, ALLOCNO_NUM (r->allocno));\n     }\n   sparseset_free (allocnos_live);\n+  return true;\n }\n \n \f\n@@ -743,29 +766,34 @@ ira_build_conflicts (void)\n   ira_allocno_iterator ai;\n   HARD_REG_SET temp_hard_reg_set;\n \n-  if (optimize)\n+  if (ira_conflicts_p)\n     {\n-      build_conflict_bit_table ();\n-      build_conflicts ();\n-      ira_traverse_loop_tree (true, ira_loop_tree_root, NULL, add_copies);\n-      /* We need finished conflict table for the subsequent call.  */\n-      if (flag_ira_region == IRA_REGION_ALL\n-\t  || flag_ira_region == IRA_REGION_MIXED)\n-\tpropagate_copies ();\n-      /* Now we can free memory for the conflict table (see function\n-\t build_allocno_conflicts for details).  */\n-      FOR_EACH_ALLOCNO (a, ai)\n+      ira_conflicts_p = build_conflict_bit_table ();\n+      if (ira_conflicts_p)\n \t{\n-\t  if (ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a) != conflicts[ALLOCNO_NUM (a)])\n-\t    ira_free (conflicts[ALLOCNO_NUM (a)]);\n+\t  build_conflicts ();\n+\t  ira_traverse_loop_tree (true, ira_loop_tree_root, NULL, add_copies);\n+\t  /* We need finished conflict table for the subsequent call.  */\n+\t  if (flag_ira_region == IRA_REGION_ALL\n+\t      || flag_ira_region == IRA_REGION_MIXED)\n+\t    propagate_copies ();\n+\t  /* Now we can free memory for the conflict table (see function\n+\t     build_allocno_conflicts for details).  */\n+\t  FOR_EACH_ALLOCNO (a, ai)\n+\t    {\n+\t      if (ALLOCNO_CONFLICT_ALLOCNO_ARRAY (a)\n+\t\t  != conflicts[ALLOCNO_NUM (a)])\n+\t\tira_free (conflicts[ALLOCNO_NUM (a)]);\n+\t    }\n+\t  ira_free (conflicts);\n \t}\n-      ira_free (conflicts);\n     }\n   if (! CLASS_LIKELY_SPILLED_P (BASE_REG_CLASS))\n     CLEAR_HARD_REG_SET (temp_hard_reg_set);\n   else\n     {\n-      COPY_HARD_REG_SET (temp_hard_reg_set, reg_class_contents[BASE_REG_CLASS]);\n+      COPY_HARD_REG_SET (temp_hard_reg_set,\n+\t\t\t reg_class_contents[BASE_REG_CLASS]);\n       AND_COMPL_HARD_REG_SET (temp_hard_reg_set, ira_no_alloc_regs);\n       AND_HARD_REG_SET (temp_hard_reg_set, call_used_reg_set);\n     }\n@@ -796,6 +824,7 @@ ira_build_conflicts (void)\n \t    }\n \t}\n     }\n-  if (optimize && internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n+  if (optimize && ira_conflicts_p\n+      && internal_flag_ira_verbose > 2 && ira_dump_file != NULL)\n     print_conflicts (ira_dump_file, false);\n }"}, {"sha": "2273512ec23d415dd28008ade8e1ed51a8af9d17", "filename": "gcc/ira.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=311aab0649dded5e7f9bb84dd78040871d6812d9", "patch": "@@ -1827,6 +1827,10 @@ too_high_register_pressure_p (void)\n /* All natural loops.  */\n struct loops ira_loops;\n \n+/* True if we have allocno conflicts.  It is false for non-optimized\n+   mode or when the conflict table is too big.  */\n+bool ira_conflicts_p;\n+\n /* This is the main entry of IRA.  */\n static void\n ira (FILE *f)\n@@ -1851,6 +1855,7 @@ ira (FILE *f)\n       ira_dump_file = stderr;\n     }\n \n+  ira_conflicts_p = optimize > 0;\n   setup_prohibited_mode_move_regs ();\n \n   df_note_add_problem ();\n@@ -1916,6 +1921,8 @@ ira (FILE *f)\n   loops_p = ira_build (optimize\n \t\t       && (flag_ira_region == IRA_REGION_ALL\n \t\t\t   || flag_ira_region == IRA_REGION_MIXED));\n+  \n+  ira_assert (ira_conflicts_p || !loops_p);\n \n   saved_flag_ira_share_spill_slots = flag_ira_share_spill_slots;\n   if (too_high_register_pressure_p ())\n@@ -1929,7 +1936,7 @@ ira (FILE *f)\n       \n   ira_emit (loops_p);\n   \n-  if (optimize)\n+  if (ira_conflicts_p)\n     {\n       max_regno = max_reg_num ();\n       \n@@ -1963,7 +1970,7 @@ ira (FILE *f)\n   calculate_allocation_cost ();\n   \n #ifdef ENABLE_IRA_CHECKING\n-  if (optimize)\n+  if (ira_conflicts_p)\n     check_allocation ();\n #endif\n       \n@@ -1992,7 +1999,7 @@ ira (FILE *f)\n   allocate_initial_values (reg_equiv_memory_loc);\n \n   overall_cost_before = ira_overall_cost;\n-  if (optimize)\n+  if (ira_conflicts_p)\n     {\n       fix_reg_equiv_init ();\n       \n@@ -2015,13 +2022,13 @@ ira (FILE *f)\n   df_set_flags (DF_NO_INSN_RESCAN);\n   build_insn_chain ();\n \n-  reload_completed = !reload (get_insns (), optimize > 0);\n+  reload_completed = !reload (get_insns (), ira_conflicts_p);\n \n   timevar_pop (TV_RELOAD);\n \n   timevar_push (TV_IRA);\n \n-  if (optimize)\n+  if (ira_conflicts_p)\n     {\n       ira_free (ira_spilled_reg_stack_slots);\n       "}, {"sha": "165274d95f70187c843b4b8d2d6ef21a4b92560a", "filename": "gcc/ira.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2Fira.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2Fira.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.h?ref=311aab0649dded5e7f9bb84dd78040871d6812d9", "patch": "@@ -20,6 +20,10 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+/* True if we have allocno conflicts.  It is false for non-optimized\n+   mode or when the conflict table is too big.  */\n+extern bool ira_conflicts_p;\n+\n extern void ira_init_once (void);\n extern void ira_init (void);\n extern void ira_finish_once (void);"}, {"sha": "d09a8581e330d2b7fceea7b29e40a3b48ffc9344", "filename": "gcc/params.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=311aab0649dded5e7f9bb84dd78040871d6812d9", "patch": "@@ -750,6 +750,11 @@ DEFPARAM (PARAM_IRA_MAX_LOOPS_NUM,\n \t  \"max loops number for regional RA\",\n \t  100, 0, 0)\n \n+DEFPARAM (PARAM_IRA_MAX_CONFLICT_TABLE_SIZE,\n+\t  \"ira-max-conflict-table-size\",\n+\t  \"max size of conflict table in MB\",\n+\t  2000, 0, 0)\n+\n /* Switch initialization conversion will refuse to create arrays that are\n    bigger than this parameter times the number of switch branches.  */\n "}, {"sha": "501259c78e14a088021a3b93e675139d5a94fafd", "filename": "gcc/params.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=311aab0649dded5e7f9bb84dd78040871d6812d9", "patch": "@@ -169,6 +169,8 @@ typedef enum compiler_param\n   PARAM_VALUE (PARAM_USE_CANONICAL_TYPES)\n #define IRA_MAX_LOOPS_NUM \\\n   PARAM_VALUE (PARAM_IRA_MAX_LOOPS_NUM)\n+#define IRA_MAX_CONFLICT_TABLE_SIZE \\\n+  PARAM_VALUE (PARAM_IRA_MAX_CONFLICT_TABLE_SIZE)\n #define SWITCH_CONVERSION_BRANCH_RATIO \\\n   PARAM_VALUE (PARAM_SWITCH_CONVERSION_BRANCH_RATIO)\n #endif /* ! GCC_PARAMS_H */"}, {"sha": "bbffad0b98dc4a0d5081a8104168222e91d2dae1", "filename": "gcc/reload1.c", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/311aab0649dded5e7f9bb84dd78040871d6812d9/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=311aab0649dded5e7f9bb84dd78040871d6812d9", "patch": "@@ -557,7 +557,7 @@ compute_use_by_pseudos (HARD_REG_SET *to, regset from)\n \t     which might still contain registers that have not\n \t     actually been allocated since they have an\n \t     equivalence.  */\n-\t  gcc_assert ((flag_ira && optimize) || reload_completed);\n+\t  gcc_assert ((flag_ira && ira_conflicts_p) || reload_completed);\n \t}\n       else\n \tadd_to_hard_reg_set (to, PSEUDO_REGNO_MODE (regno), r);\n@@ -901,7 +901,7 @@ reload (rtx first, int global)\n   for (n = 0, i = LAST_VIRTUAL_REGISTER + 1; i < max_regno; i++)\n     temp_pseudo_reg_arr[n++] = i;\n   \n-  if (flag_ira && optimize)\n+  if (flag_ira && ira_conflicts_p)\n     /* Ask IRA to order pseudo-registers for better stack slot\n        sharing.  */\n     ira_sort_regnos_for_alter_reg (temp_pseudo_reg_arr, n, reg_max_ref_width);\n@@ -1055,7 +1055,7 @@ reload (rtx first, int global)\n \n       calculate_needs_all_insns (global);\n \n-      if (! flag_ira || ! optimize)\n+      if (! flag_ira || ! ira_conflicts_p)\n \t/* Don't do it for IRA.  We need this info because we don't\n \t   change live_throughout and dead_or_set for chains when IRA\n \t   is used.  */\n@@ -1614,7 +1614,7 @@ calculate_needs_all_insns (int global)\n \t\t\t\t       reg_equiv_memory_loc\n \t\t\t\t       [REGNO (SET_DEST (set))]))))\n \t\t{\n-\t\t  if (flag_ira && optimize)\n+\t\t  if (flag_ira && ira_conflicts_p)\n \t\t    /* Inform IRA about the insn deletion.  */\n \t\t    ira_mark_memory_move_deletion (REGNO (SET_DEST (set)),\n \t\t\t\t\t\t   REGNO (SET_SRC (set)));\n@@ -1723,7 +1723,7 @@ count_pseudo (int reg)\n       || REGNO_REG_SET_P (&spilled_pseudos, reg)\n       /* Ignore spilled pseudo-registers which can be here only if IRA\n \t is used.  */\n-      || (flag_ira && optimize && r < 0))\n+      || (flag_ira && ira_conflicts_p && r < 0))\n     return;\n \n   SET_REGNO_REG_SET (&pseudos_counted, reg);\n@@ -1804,7 +1804,7 @@ count_spilled_pseudo (int spilled, int spilled_nregs, int reg)\n \n   /* Ignore spilled pseudo-registers which can be here only if IRA is\n      used.  */\n-  if ((flag_ira && optimize && r < 0)\n+  if ((flag_ira && ira_conflicts_p && r < 0)\n       || REGNO_REG_SET_P (&spilled_pseudos, reg)\n       || spilled + spilled_nregs <= r || r + nregs <= spilled)\n     return;\n@@ -1876,7 +1876,7 @@ find_reg (struct insn_chain *chain, int order)\n \t  if (! ok)\n \t    continue;\n \n-\t  if (flag_ira && optimize)\n+\t  if (flag_ira && ira_conflicts_p)\n \t    {\n \t      /* Ask IRA to find a better pseudo-register for\n \t\t spilling.  */\n@@ -2158,7 +2158,7 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n       unsigned int min_align = reg_max_ref_width[i] * BITS_PER_UNIT;\n       int adjust = 0;\n \n-      if (flag_ira && optimize)\n+      if (flag_ira && ira_conflicts_p)\n \t{\n \t  /* Mark the spill for IRA.  */\n \t  SET_REGNO_REG_SET (&spilled_pseudos, i);\n@@ -2177,7 +2177,8 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n \t enough inherent space and enough total space.\n \t Otherwise, we allocate a new slot, making sure that it has no less\n \t inherent space, and no less total space, then the previous slot.  */\n-      else if (from_reg == -1 || (!dont_share_p && flag_ira && optimize))\n+      else if (from_reg == -1\n+\t       || (!dont_share_p && flag_ira && ira_conflicts_p))\n \t{\n \t  rtx stack_slot;\n \n@@ -2202,7 +2203,7 @@ alter_reg (int i, int from_reg, bool dont_share_p)\n \t\t\t\t       adjust);\n \t    }\n \n-\t  if (! dont_share_p && flag_ira && optimize)\n+\t  if (! dont_share_p && flag_ira && ira_conflicts_p)\n \t    /* Inform IRA about allocation a new stack slot.  */\n \t    ira_mark_new_stack_slot (stack_slot, i, total_size);\n \t}\n@@ -3904,7 +3905,7 @@ finish_spills (int global)\n       spill_reg_order[i] = -1;\n \n   EXECUTE_IF_SET_IN_REG_SET (&spilled_pseudos, FIRST_PSEUDO_REGISTER, i, rsi)\n-    if (! flag_ira || ! optimize || reg_renumber[i] >= 0)\n+    if (! flag_ira || ! ira_conflicts_p || reg_renumber[i] >= 0)\n       {\n \t/* Record the current hard register the pseudo is allocated to\n \t   in pseudo_previous_regs so we avoid reallocating it to the\n@@ -3914,7 +3915,7 @@ finish_spills (int global)\n \tSET_HARD_REG_BIT (pseudo_previous_regs[i], reg_renumber[i]);\n \t/* Mark it as no longer having a hard register home.  */\n \treg_renumber[i] = -1;\n-\tif (flag_ira && optimize)\n+\tif (flag_ira && ira_conflicts_p)\n \t  /* Inform IRA about the change.  */\n \t  ira_mark_allocation_change (i);\n \t/* We will need to scan everything again.  */\n@@ -3944,7 +3945,7 @@ finish_spills (int global)\n \t    }\n \t}\n \n-      if (! flag_ira || ! optimize)\n+      if (! flag_ira || ! ira_conflicts_p)\n \t{\n \t  /* Retry allocating the spilled pseudos.  For each reg,\n \t     merge the various reg sets that indicate which hard regs\n@@ -3996,7 +3997,7 @@ finish_spills (int global)\n       HARD_REG_SET used_by_pseudos;\n       HARD_REG_SET used_by_pseudos2;\n \n-      if (! flag_ira || ! optimize)\n+      if (! flag_ira || ! ira_conflicts_p)\n \t{\n \t  /* Don't do it for IRA because IRA and the reload still can\n \t     assign hard registers to the spilled pseudos on next\n@@ -6999,7 +7000,7 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t\t  && REG_N_SETS (REGNO (old)) == 1)\n \t\t{\n \t\t  reg_renumber[REGNO (old)] = REGNO (reloadreg);\n-\t\t  if (flag_ira && optimize)\n+\t\t  if (flag_ira && ira_conflicts_p)\n \t\t    /* Inform IRA about the change.  */\n \t\t    ira_mark_allocation_change (REGNO (old));\n \t\t  alter_reg (REGNO (old), -1, false);\n@@ -8540,7 +8541,7 @@ delete_output_reload (rtx insn, int j, int last_reload_reg, rtx new_reload_reg)\n \n       /* For the debugging info, say the pseudo lives in this reload reg.  */\n       reg_renumber[REGNO (reg)] = REGNO (new_reload_reg);\n-      if (flag_ira && optimize)\n+      if (flag_ira && ira_conflicts_p)\n \t/* Inform IRA about the change.  */\n \tira_mark_allocation_change (REGNO (reg));\n       alter_reg (REGNO (reg), -1, false);"}]}