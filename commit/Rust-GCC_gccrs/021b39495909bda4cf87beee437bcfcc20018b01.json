{"sha": "021b39495909bda4cf87beee437bcfcc20018b01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIxYjM5NDk1OTA5YmRhNGNmODdiZWVlNDM3YmNmY2MyMDAxOGIwMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "1999-12-09T01:00:45Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1999-12-09T01:00:45Z"}, "message": "longlong.h: Merge in changes from glibc.\n\n\t* longlong.h: Merge in changes from glibc.\n\tAlso don't clobber %g2 register in 32bit SPARC assembly, so that\n\t-mno-app-regs libgcc can be compiled.\n\t* libgcc2.c: Add defines so that the updated longlong.h\n\tcan be used in libgcc2.a. Also, make sure on most architectures\n\t(at least on all which have optimized code in longlong.h defined\n\tfor) {SI,W}_TYPE_SIZE is suitable for preprocessor tests.\n\nFrom-SVN: r30836", "tree": {"sha": "f54db85fad203a719b01ed22bdc2363afcc3034a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f54db85fad203a719b01ed22bdc2363afcc3034a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/021b39495909bda4cf87beee437bcfcc20018b01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/021b39495909bda4cf87beee437bcfcc20018b01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/021b39495909bda4cf87beee437bcfcc20018b01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/021b39495909bda4cf87beee437bcfcc20018b01/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cd8998a31a6d93f850510f2392831e871670c069", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd8998a31a6d93f850510f2392831e871670c069", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd8998a31a6d93f850510f2392831e871670c069"}], "stats": {"total": 411, "additions": 326, "deletions": 85}, "files": [{"sha": "58e22dda9b93f64ba194d8bf487f956914ca01cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/021b39495909bda4cf87beee437bcfcc20018b01/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/021b39495909bda4cf87beee437bcfcc20018b01/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=021b39495909bda4cf87beee437bcfcc20018b01", "patch": "@@ -10,6 +10,14 @@\n \t* config/sparc/sparc.h (SPARC_SETHI_P): Don't look at topmost 32 bits\n \tif TARGET_ARCH32.\n \n+\t* longlong.h: Merge in changes from glibc.\n+\tAlso don't clobber %g2 register in 32bit SPARC assembly, so that\n+\t-mno-app-regs libgcc can be compiled.\n+\t* libgcc2.c: Add defines so that the updated longlong.h\n+\tcan be used in libgcc2.a. Also, make sure on most architectures\n+\t(at least on all which have optimized code in longlong.h defined\n+\tfor) {SI,W}_TYPE_SIZE is suitable for preprocessor tests.\n+\n 1999-12-08  Alexandre Oliva  <oliva@lsd.ic.unicamp.br>\n \n \t* config/sparc/sol2-64.h: Same as sol2-sld-64.h, except that"}, {"sha": "158f374cb39cf6f7946eebd56cda0019957832bd", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/021b39495909bda4cf87beee437bcfcc20018b01/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/021b39495909bda4cf87beee437bcfcc20018b01/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=021b39495909bda4cf87beee437bcfcc20018b01", "patch": "@@ -127,7 +127,15 @@ typedef int word_type __attribute__ ((mode (__word__)));\n #define float bogus_type\n #define double bogus_type\n \n+#if BITS_PER_UNIT == 8\n+#define SI_TYPE_SIZE 32\n+#else\n #define SI_TYPE_SIZE (sizeof (SItype) * BITS_PER_UNIT)\n+#endif\n+#define W_TYPE_SIZE SI_TYPE_SIZE\n+#define UWtype\tUSItype\n+#define UHWtype\tUSItype\n+#define UDWtype\tUDItype\n \n /* DIstructs are pairs of SItype values in the order determined by\n    LIBGCC2_WORDS_BIG_ENDIAN.  */"}, {"sha": "f76f4799c71fb7de17612b7b7f3290911cb10334", "filename": "gcc/longlong.h", "status": "modified", "additions": 310, "deletions": 85, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/021b39495909bda4cf87beee437bcfcc20018b01/gcc%2Flonglong.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/021b39495909bda4cf87beee437bcfcc20018b01/gcc%2Flonglong.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flonglong.h?ref=021b39495909bda4cf87beee437bcfcc20018b01", "patch": "@@ -1,5 +1,5 @@\n /* longlong.h -- definitions for mixed size 32/64 bit arithmetic.\n-   Copyright (C) 1991, 92, 94, 95, 96, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1991,92,94,95,96,97,98,99 Free Software Foundation, Inc.\n \n    This definition file is free software; you can redistribute it\n    and/or modify it under the terms of the GNU General Public\n@@ -16,54 +16,73 @@\n    Foundation, Inc., 59 Temple Place - Suite 330,\n    Boston, MA 02111-1307, USA.  */\n \n-#ifndef SI_TYPE_SIZE\n-#define SI_TYPE_SIZE 32\n-#endif\n+/* You have to define the following before including this file:\n+\n+   UWtype -- An unsigned type, default type for operations (typically a \"word\")\n+   UHWtype -- An unsigned type, at least half the size of UWtype.\n+   UDWtype -- An unsigned type, at least twice as large a UWtype\n+   W_TYPE_SIZE -- size in bits of UWtype\n+\n+   UQItype -- Unsigned 8 bit type.\n+   SItype, USItype -- Signed and unsigned 32 bit types.\n+   DItype, UDItype -- Signed and unsigned 64 bit types.\n \n-#define __BITS4 (SI_TYPE_SIZE / 4)\n-#define __ll_B (1L << (SI_TYPE_SIZE / 2))\n-#define __ll_lowpart(t) ((USItype) (t) % __ll_B)\n-#define __ll_highpart(t) ((USItype) (t) / __ll_B)\n+   On a 32 bit machine UWtype should typically be USItype;\n+   on a 64 bit machine, UWtype should typically be UDItype.\n+*/\n+\n+#define __BITS4 (W_TYPE_SIZE / 4)\n+#define __ll_B ((UWtype) 1 << (W_TYPE_SIZE / 2))\n+#define __ll_lowpart(t) ((UWtype) (t) & (__ll_B - 1))\n+#define __ll_highpart(t) ((UWtype) (t) >> (W_TYPE_SIZE / 2))\n+\n+#ifndef W_TYPE_SIZE\n+#define W_TYPE_SIZE\t32\n+#define UWtype\t\tUSItype\n+#define UHWtype\t\tUSItype\n+#define UDWtype\t\tUDItype\n+#endif\n \n /* Define auxiliary asm macros.\n \n-   1) umul_ppmm(high_prod, low_prod, multipler, multiplicand)\n-   multiplies two USItype integers MULTIPLER and MULTIPLICAND,\n-   and generates a two-part USItype product in HIGH_PROD and\n-   LOW_PROD.\n+   1) umul_ppmm(high_prod, low_prod, multipler, multiplicand) multiplies two\n+   UWtype integers MULTIPLER and MULTIPLICAND, and generates a two UWtype\n+   word product in HIGH_PROD and LOW_PROD.\n \n-   2) __umulsidi3(a,b) multiplies two USItype integers A and B,\n-   and returns a UDItype product.  This is just a variant of umul_ppmm.\n+   2) __umulsidi3(a,b) multiplies two UWtype integers A and B, and returns a\n+   UDWtype product.  This is just a variant of umul_ppmm.\n \n    3) udiv_qrnnd(quotient, remainder, high_numerator, low_numerator,\n-   denominator) divides a two-word unsigned integer, composed by the\n-   integers HIGH_NUMERATOR and LOW_NUMERATOR, by DENOMINATOR and\n-   places the quotient in QUOTIENT and the remainder in REMAINDER.\n-   HIGH_NUMERATOR must be less than DENOMINATOR for correct operation.\n-   If, in addition, the most significant bit of DENOMINATOR must be 1,\n-   then the pre-processor symbol UDIV_NEEDS_NORMALIZATION is defined to 1.\n+   denominator) divides a UDWtype, composed by the UWtype integers\n+   HIGH_NUMERATOR and LOW_NUMERATOR, by DENOMINATOR and places the quotient\n+   in QUOTIENT and the remainder in REMAINDER.  HIGH_NUMERATOR must be less\n+   than DENOMINATOR for correct operation.  If, in addition, the most\n+   significant bit of DENOMINATOR must be 1, then the pre-processor symbol\n+   UDIV_NEEDS_NORMALIZATION is defined to 1.\n \n    4) sdiv_qrnnd(quotient, remainder, high_numerator, low_numerator,\n-   denominator).  Like udiv_qrnnd but the numbers are signed.  The\n-   quotient is rounded towards 0.\n-\n-   5) count_leading_zeros(count, x) counts the number of zero-bits from\n-   the msb to the first non-zero bit.  This is the number of steps X\n-   needs to be shifted left to set the msb.  Undefined for X == 0.\n-\n-   6) add_ssaaaa(high_sum, low_sum, high_addend_1, low_addend_1,\n-   high_addend_2, low_addend_2) adds two two-word unsigned integers,\n-   composed by HIGH_ADDEND_1 and LOW_ADDEND_1, and HIGH_ADDEND_2 and\n-   LOW_ADDEND_2 respectively.  The result is placed in HIGH_SUM and\n-   LOW_SUM.  Overflow (i.e. carry out) is not stored anywhere, and is\n-   lost.\n-\n-   7) sub_ddmmss(high_difference, low_difference, high_minuend,\n-   low_minuend, high_subtrahend, low_subtrahend) subtracts two\n-   two-word unsigned integers, composed by HIGH_MINUEND_1 and\n-   LOW_MINUEND_1, and HIGH_SUBTRAHEND_2 and LOW_SUBTRAHEND_2\n-   respectively.  The result is placed in HIGH_DIFFERENCE and\n-   LOW_DIFFERENCE.  Overflow (i.e. carry out) is not stored anywhere,\n+   denominator).  Like udiv_qrnnd but the numbers are signed.  The quotient\n+   is rounded towards 0.\n+\n+   5) count_leading_zeros(count, x) counts the number of zero-bits from the\n+   msb to the first non-zero bit in the UWtype X.  This is the number of\n+   steps X needs to be shifted left to set the msb.  Undefined for X == 0,\n+   unless the symbol COUNT_LEADING_ZEROS_0 is defined to some value.\n+\n+   6) count_trailing_zeros(count, x) like count_leading_zeros, but counts\n+   from the least significant end.\n+\n+   7) add_ssaaaa(high_sum, low_sum, high_addend_1, low_addend_1,\n+   high_addend_2, low_addend_2) adds two UWtype integers, composed by\n+   HIGH_ADDEND_1 and LOW_ADDEND_1, and HIGH_ADDEND_2 and LOW_ADDEND_2\n+   respectively.  The result is placed in HIGH_SUM and LOW_SUM.  Overflow\n+   (i.e. carry out) is not stored anywhere, and is lost.\n+\n+   8) sub_ddmmss(high_difference, low_difference, high_minuend, low_minuend,\n+   high_subtrahend, low_subtrahend) subtracts two two-word UWtype integers,\n+   composed by HIGH_MINUEND_1 and LOW_MINUEND_1, and HIGH_SUBTRAHEND_2 and\n+   LOW_SUBTRAHEND_2 respectively.  The result is placed in HIGH_DIFFERENCE\n+   and LOW_DIFFERENCE.  Overflow (i.e. carry out) is not stored anywhere,\n    and is lost.\n \n    If any of these macros are left undefined for a particular CPU,\n@@ -87,7 +106,7 @@\n #define __AND_CLOBBER_CC , \"cc\"\n #endif /* __GNUC__ < 2 */\n \n-#if defined (__a29k__) || defined (_AM29K)\n+#if (defined (__a29k__) || defined (_AM29K)) && W_TYPE_SIZE == 32\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"add %1,%4,%5\n \taddc %0,%2,%3\"\t\t\t\t\t\t\t\\\n@@ -129,9 +148,32 @@\n     __asm__ (\"clz %0,%1\"\t\t\t\t\t\t\\\n \t     : \"=r\" ((USItype) (count))\t\t\t\t\t\\\n \t     : \"r\" ((USItype) (x)))\n+#define COUNT_LEADING_ZEROS_0 32\n #endif /* __a29k__ */\n \n-#if defined (__arc__)\n+#if defined (__alpha) && W_TYPE_SIZE == 64\n+#define umul_ppmm(ph, pl, m0, m1) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    UDItype __m0 = (m0), __m1 = (m1);\t\t\t\t\t\\\n+    __asm__ (\"umulh %r1,%2,%0\"\t\t\t\t\t\t\\\n+\t     : \"=r\" ((UDItype) ph)\t\t\t\t\t\\\n+\t     : \"%rJ\" (__m0),\t\t\t\t\t\t\\\n+\t       \"rI\" (__m1));\t\t\t\t\t\t\\\n+    (pl) = __m0 * __m1;\t\t\t\t\t\t\t\\\n+  } while (0)\n+#define UMUL_TIME 46\n+#ifndef LONGLONG_STANDALONE\n+#define udiv_qrnnd(q, r, n1, n0, d) \\\n+  do { UDItype __r;\t\t\t\t\t\t\t\\\n+    (q) = __udiv_qrnnd (&__r, (n1), (n0), (d));\t\t\t\t\\\n+    (r) = __r;\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+extern UDItype __udiv_qrnnd __P ((UDItype *, UDItype, UDItype, UDItype));\n+#define UDIV_TIME 220\n+#endif /* LONGLONG_STANDALONE */\n+#endif /* __alpha */\n+\n+#if defined (__arc__) && W_TYPE_SIZE == 32\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"add.f\t%1, %4, %5\n \tadc\t%0, %2, %3\"\t\t\t\t\t\t\\\n@@ -162,7 +204,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n UDItype __umulsidi3 (USItype, USItype);\n #endif\n \n-#if defined (__arm__)\n+#if defined (__arm__) && W_TYPE_SIZE == 32\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"adds\t%1, %4, %5\n \tadc\t%0, %2, %3\"\t\t\t\t\t\t\\\n@@ -205,7 +247,7 @@ UDItype __umulsidi3 (USItype, USItype);\n #define UDIV_TIME 100\n #endif /* __arm__ */\n \n-#if defined (__clipper__)\n+#if defined (__clipper__) && W_TYPE_SIZE == 32\n #define umul_ppmm(w1, w0, u, v) \\\n   ({union {UDItype __ll;\t\t\t\t\t\t\\\n \t   struct {USItype __l, __h;} __i;\t\t\t\t\\\n@@ -233,7 +275,7 @@ UDItype __umulsidi3 (USItype, USItype);\n     __w; })\n #endif /* __clipper__ */\n \n-#if defined (__gmicro__)\n+#if defined (__gmicro__) && W_TYPE_SIZE == 32\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"add.w %5,%1\n \taddx %3,%0\"\t\t\t\t\t\t\t\\\n@@ -272,7 +314,7 @@ UDItype __umulsidi3 (USItype, USItype);\n \t     \"0\" ((USItype) 0))\n #endif\n \n-#if defined (__hppa)\n+#if defined (__hppa) && W_TYPE_SIZE == 32\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"add %4,%5,%1\n \taddc %2,%3,%0\"\t\t\t\t\t\t\t\\\n@@ -334,7 +376,48 @@ UDItype __umulsidi3 (USItype, USItype);\n   } while (0)\n #endif\n \n-#if defined (__i386__) || defined (__i486__)\n+#if (defined (__i370__) || defined (__mvs__)) && W_TYPE_SIZE == 32\n+#define umul_ppmm(xh, xl, m0, m1) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    union {UDItype __ll;\t\t\t\t\t\t\\\n+\t   struct {USItype __h, __l;} __i;\t\t\t\t\\\n+\t  } __xx;\t\t\t\t\t\t\t\\\n+    USItype __m0 = (m0), __m1 = (m1);\t\t\t\t\t\\\n+    __asm__ (\"mr %0,%3\"\t\t\t\t\t\t\t\\\n+\t     : \"=r\" (__xx.__i.__h),\t\t\t\t\t\\\n+\t       \"=r\" (__xx.__i.__l)\t\t\t\t\t\\\n+\t     : \"%1\" (__m0),\t\t\t\t\t\t\\\n+\t       \"r\" (__m1));\t\t\t\t\t\t\\\n+    (xh) = __xx.__i.__h; (xl) = __xx.__i.__l;\t\t\t\t\\\n+    (xh) += ((((SItype) __m0 >> 31) & __m1)\t\t\t\t\\\n+\t     + (((SItype) __m1 >> 31) & __m0));\t\t\t\t\\\n+  } while (0)\n+#define smul_ppmm(xh, xl, m0, m1) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    union {DItype __ll;\t\t\t\t\t\t\t\\\n+\t   struct {USItype __h, __l;} __i;\t\t\t\t\\\n+\t  } __xx;\t\t\t\t\t\t\t\\\n+    __asm__ (\"mr %0,%3\"\t\t\t\t\t\t\t\\\n+\t     : \"=r\" (__xx.__i.__h),\t\t\t\t\t\\\n+\t       \"=r\" (__xx.__i.__l)\t\t\t\t\t\\\n+\t     : \"%1\" (m0),\t\t\t\t\t\t\\\n+\t       \"r\" (m1));\t\t\t\t\t\t\\\n+    (xh) = __xx.__i.__h; (xl) = __xx.__i.__l;\t\t\t\t\\\n+  } while (0)\n+#define sdiv_qrnnd(q, r, n1, n0, d) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    union {DItype __ll;\t\t\t\t\t\t\t\\\n+\t   struct {USItype __h, __l;} __i;\t\t\t\t\\\n+\t  } __xx;\t\t\t\t\t\t\t\\\n+    __xx.__i.__h = n1; __xx.__i.__l = n0;\t\t\t\t\\\n+    __asm__ (\"dr %0,%2\"\t\t\t\t\t\t\t\\\n+\t     : \"=r\" (__xx.__ll)\t\t\t\t\t\t\\\n+\t     : \"0\" (__xx.__ll), \"r\" (d));\t\t\t\t\\\n+    (q) = __xx.__i.__l; (r) = __xx.__i.__h;\t\t\t\t\\\n+  } while (0)\n+#endif\n+\n+#if (defined (__i386__) || defined (__i486__)) && W_TYPE_SIZE == 32\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"addl %5,%1\n \tadcl %3,%0\"\t\t\t\t\t\t\t\\\n@@ -373,11 +456,13 @@ UDItype __umulsidi3 (USItype, USItype);\n \t     : \"=r\" (__cbtmp) : \"rm\" ((USItype) (x)));\t\t\t\\\n     (count) = __cbtmp ^ 31;\t\t\t\t\t\t\\\n   } while (0)\n+#define count_trailing_zeros(count, x) \\\n+  __asm__ (\"bsfl %1,%0\" : \"=r\" (count) : \"rm\" ((USItype)(x)))\n #define UMUL_TIME 40\n #define UDIV_TIME 40\n #endif /* 80x86 */\n \n-#if defined (__i860__)\n+#if defined (__i860__) && W_TYPE_SIZE == 32\n #if 0\n /* Make sure these patterns really improve the code before\n    switching them on.  */\n@@ -418,7 +503,7 @@ UDItype __umulsidi3 (USItype, USItype);\n #endif\n #endif /* __i860__ */\n \n-#if defined (__i960__)\n+#if defined (__i960__) && W_TYPE_SIZE == 32\n #define umul_ppmm(w1, w0, u, v) \\\n   ({union {UDItype __ll;\t\t\t\t\t\t\\\n \t   struct {USItype __l, __h;} __i;\t\t\t\t\\\n@@ -434,10 +519,10 @@ UDItype __umulsidi3 (USItype, USItype);\n \t     : \"=d\" (__w)\t\t\t\t\t\t\\\n \t     : \"%dI\" ((USItype) (u)),\t\t\t\t\t\\\n \t       \"dI\" ((USItype) (v)));\t\t\t\t\t\\\n-    __w; })  \n+    __w; })\n #endif /* __i960__ */\n \n-#if defined (__M32R__)\n+#if defined (__M32R__) && W_TYPE_SIZE == 32\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   /* The cmp clears the condition bit.  */ \\\n   __asm__ (\"cmp %0,%0\n@@ -464,7 +549,7 @@ UDItype __umulsidi3 (USItype, USItype);\n \t   : \"cbit\")\n #endif /* __M32R__ */\n \n-#if defined (__mc68000__)\n+#if defined (__mc68000__) && W_TYPE_SIZE == 32\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"add%.l %5,%1\n \taddx%.l %3,%0\"\t\t\t\t\t\t\t\\\n@@ -566,7 +651,7 @@ UDItype __umulsidi3 (USItype, USItype);\n #endif\n #endif /* mc68000 */\n \n-#if defined (__m88000__)\n+#if defined (__m88000__) && W_TYPE_SIZE == 32\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"addu.co %1,%r4,%r5\n \taddu.ci %0,%r2,%r3\"\t\t\t\t\t\t\\\n@@ -593,6 +678,7 @@ UDItype __umulsidi3 (USItype, USItype);\n \t     : \"r\" ((USItype) (x)));\t\t\t\t\t\\\n     (count) = __cbtmp ^ 31;\t\t\t\t\t\t\\\n   } while (0)\n+#define COUNT_LEADING_ZEROS_0 63 /* sic */\n #if defined (__mc88110__)\n #define umul_ppmm(wh, wl, u, v) \\\n   do {\t\t\t\t\t\t\t\t\t\\\n@@ -625,7 +711,7 @@ UDItype __umulsidi3 (USItype, USItype);\n #endif /* __mc88110__ */\n #endif /* __m88000__ */\n \n-#if defined (__mips__)\n+#if defined (__mips__) && W_TYPE_SIZE == 32\n #define umul_ppmm(w1, w0, u, v) \\\n   __asm__ (\"multu %2,%3\"\t\t\t\t\t\t\\\n \t   : \"=l\" ((USItype) (w0)),\t\t\t\t\t\\\n@@ -636,7 +722,7 @@ UDItype __umulsidi3 (USItype, USItype);\n #define UDIV_TIME 100\n #endif /* __mips__ */\n \n-#if defined (__ns32000__)\n+#if defined (__ns32000__) && W_TYPE_SIZE == 32\n #define umul_ppmm(w1, w0, u, v) \\\n   ({union {UDItype __ll;\t\t\t\t\t\t\\\n \t   struct {USItype __l, __h;} __i;\t\t\t\t\\\n@@ -663,6 +749,13 @@ UDItype __umulsidi3 (USItype, USItype);\n \t   : \"0\" (__xx.__ll),\t\t\t\t\t\t\\\n \t     \"g\" ((USItype) (d)));\t\t\t\t\t\\\n   (r) = __xx.__i.__l; (q) = __xx.__i.__h; })\n+#define count_trailing_zeros(count,x) \\\n+  do {\n+    __asm__ (\"ffsd     %2,%0\"                                          \\\n+            : \"=r\" ((USItype) (count))                                 \\\n+            : \"0\" ((USItype) 0),                                       \\\n+              \"r\" ((USItype) (x)));                                    \\\n+  } while (0)\n #endif /* __ns32000__ */\n \n #if (defined (_ARCH_PPC) || defined (_IBMR2)) && W_TYPE_SIZE == 32\n@@ -734,6 +827,7 @@ UDItype __umulsidi3 (USItype, USItype);\n   __asm__ (\"{cntlz|cntlzw} %0,%1\"\t\t\t\t\t\\\n \t   : \"=r\" ((USItype) (count))\t\t\t\t\t\\\n \t   : \"r\" ((USItype) (x)))\n+#define COUNT_LEADING_ZEROS_0 32\n #if defined (_ARCH_PPC)\n #define umul_ppmm(ph, pl, m0, m1) \\\n   do {\t\t\t\t\t\t\t\t\t\\\n@@ -784,7 +878,7 @@ UDItype __umulsidi3 (USItype, USItype);\n #endif\n #endif /* Power architecture variants.  */\n \n-#if defined (__pyr__)\n+#if defined (__pyr__) && W_TYPE_SIZE == 32\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"addw\t%5,%1\n \taddwc\t%3,%0\"\t\t\t\t\t\t\t\\\n@@ -816,7 +910,7 @@ UDItype __umulsidi3 (USItype, USItype);\n   (w1) = __xx.__i.__h; (w0) = __xx.__i.__l;})\n #endif /* __pyr__ */\n \n-#if defined (__ibm032__) /* RT/ROMP */\n+#if defined (__ibm032__) /* RT/ROMP */ && W_TYPE_SIZE == 32\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"a %1,%5\n \tae %0,%3\"\t\t\t\t\t\t\t\\\n@@ -885,7 +979,22 @@ UDItype __umulsidi3 (USItype, USItype);\n   } while (0)\n #endif\n \n-#if defined (__sparc__)\n+#if defined (__sh2__) && W_TYPE_SIZE == 32\n+#define umul_ppmm(w1, w0, u, v) \\\n+  __asm__ (\t\t\t\t\t\t\t\t\\\n+       \"dmulu.l\t%2,%3\n+\tsts\tmacl,%1\n+\tsts\tmach,%0\"\t\t\t\t\t\t\\\n+\t   : \"=r\" ((USItype)(w1)),\t\t\t\t\t\\\n+\t     \"=r\" ((USItype)(w0))\t\t\t\t\t\\\n+\t   : \"r\" ((USItype)(u)),\t\t\t\t\t\\\n+\t     \"r\" ((USItype)(v))\t\t\t\t\t\t\\\n+\t   : \"macl\", \"mach\")\n+#define UMUL_TIME 5\n+#endif\n+\n+#if defined (__sparc__) && !defined (__sparc_v9__) && !defined(__arch64__) \\\n+    && !defined(__sparc_v9) && W_TYPE_SIZE == 32\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"addcc %r4,%5,%1\n \taddx %r2,%3,%0\"\t\t\t\t\t\t\t\\\n@@ -982,15 +1091,18 @@ UDItype __umulsidi3 (USItype, USItype);\n   __asm__ (\"scan %1,1,%0\"                                               \\\n            : \"=r\" ((USItype) (count))                                   \\\n            : \"r\" ((USItype) (x)));\t\t\t\t\t\\\n-  } while (0)    \n+  } while (0)\n+/* Early sparclites return 63 for an argument of 0, but they warn that future\n+   implementations might change this.  Therefore, leave COUNT_LEADING_ZEROS_0\n+   undefined.  */\n #else\n /* SPARC without integer multiplication and divide instructions.\n    (i.e. at least Sun4/20,40,60,65,75,110,260,280,330,360,380,470,490) */\n #define umul_ppmm(w1, w0, u, v) \\\n   __asm__ (\"! Inlined umul_ppmm\n \twr\t%%g0,%2,%%y\t! SPARC has 0-3 delay insn after a wr\n-\tsra\t%3,31,%%g2\t! Don't move this insn\n-\tand\t%2,%%g2,%%g2\t! Don't move this insn\n+\tsra\t%3,31,%%o5\t! Don't move this insn\n+\tand\t%2,%%o5,%%o5\t! Don't move this insn\n \tandcc\t%%g0,0,%%g1\t! Don't move this insn\n \tmulscc\t%%g1,%3,%%g1\n \tmulscc\t%%g1,%3,%%g1\n@@ -1025,13 +1137,13 @@ UDItype __umulsidi3 (USItype, USItype);\n \tmulscc\t%%g1,%3,%%g1\n \tmulscc\t%%g1,%3,%%g1\n \tmulscc\t%%g1,0,%%g1\n-\tadd\t%%g1,%%g2,%0\n+\tadd\t%%g1,%%o5,%0\n \trd\t%%y,%1\"\t\t\t\t\t\t\t\\\n \t   : \"=r\" ((USItype) (w1)),\t\t\t\t\t\\\n \t     \"=r\" ((USItype) (w0))\t\t\t\t\t\\\n \t   : \"%rI\" ((USItype) (u)),\t\t\t\t\t\\\n \t     \"r\" ((USItype) (v))\t\t\t\t\t\t\\\n-\t   : \"g1\", \"g2\" __AND_CLOBBER_CC)\n+\t   : \"g1\", \"o5\" __AND_CLOBBER_CC)\n #define UMUL_TIME 39\t\t/* 39 instructions */\n /* It's quite necessary to add this much assembler for the sparc.\n    The default udiv_qrnnd (in C) is more than 10 times slower!  */\n@@ -1070,7 +1182,73 @@ UDItype __umulsidi3 (USItype, USItype);\n #endif /* __sparc_v8__ */\n #endif /* __sparc__ */\n \n-#if defined (__vax__)\n+#if (defined (__sparc_v9__) || (defined (__sparc__) && defined (__arch64__)) \\\n+    || defined (__sparcv9)) && W_TYPE_SIZE == 64\n+#define add_ssaaaa(sh, sl, ah, al, bh, bl)\t\t\t\t\\\n+  __asm__ (\"addcc %4,%5,%1\n+  \t    add %2,%3,%0\n+  \t    bcs,a,pn %%xcc, 1f\n+  \t    add %0, 1, %0\n+  \t    1:\"\t\t\t\t\t\t\t\t\\\n+\t   : \"=r\" ((UDItype)(sh)),\t\t\t\t      \t\\\n+\t     \"=&r\" ((UDItype)(sl))\t\t\t\t      \t\\\n+\t   : \"%rJ\" ((UDItype)(ah)),\t\t\t\t     \t\\\n+\t     \"rI\" ((UDItype)(bh)),\t\t\t\t      \t\\\n+\t     \"%rJ\" ((UDItype)(al)),\t\t\t\t     \t\\\n+\t     \"rI\" ((UDItype)(bl))\t\t\t\t       \t\\\n+\t   __CLOBBER_CC)\n+\n+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \t\t\t\t\\\n+  __asm__ (\"subcc %4,%5,%1\n+  \t    sub %2,%3,%0\n+  \t    bcs,a,pn %%xcc, 1f\n+  \t    sub %0, 1, %0\n+  \t    1:\"\t\t\t\t\t\t\t\t\\\n+\t   : \"=r\" ((UDItype)(sh)),\t\t\t\t      \t\\\n+\t     \"=&r\" ((UDItype)(sl))\t\t\t\t      \t\\\n+\t   : \"rJ\" ((UDItype)(ah)),\t\t\t\t     \t\\\n+\t     \"rI\" ((UDItype)(bh)),\t\t\t\t      \t\\\n+\t     \"rJ\" ((UDItype)(al)),\t\t\t\t     \t\\\n+\t     \"rI\" ((UDItype)(bl))\t\t\t\t       \t\\\n+\t   __CLOBBER_CC)\n+\n+#define umul_ppmm(wh, wl, u, v)\t\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+\t  UDItype tmp1, tmp2, tmp3, tmp4;\t\t\t\t\\\n+\t  __asm__ __volatile__ (\t\t\t\t\t\\\n+\t\t   \"srl %7,0,%3\n+\t\t    mulx %3,%6,%1\n+\t\t    srlx %6,32,%2\n+\t\t    mulx %2,%3,%4\n+\t\t    sllx %4,32,%5\n+\t\t    srl %6,0,%3\n+\t\t    sub %1,%5,%5\n+\t\t    srlx %5,32,%5\n+\t\t    addcc %4,%5,%4\n+\t\t    srlx %7,32,%5\n+\t\t    mulx %3,%5,%3\n+\t\t    mulx %2,%5,%5\n+\t\t    sethi %%hi(0x80000000),%2\n+\t\t    addcc %4,%3,%4\n+\t\t    srlx %4,32,%4\n+\t\t    add %2,%2,%2\n+\t\t    movcc %%xcc,%%g0,%2\n+\t\t    addcc %5,%4,%5\n+\t\t    sllx %3,32,%3\n+\t\t    add %1,%3,%1\n+\t\t    add %5,%2,%0\"\t\t\t\t\t\\\n+\t   : \"=r\" ((UDItype)(wh)),\t\t\t\t\t\\\n+\t     \"=&r\" ((UDItype)(wl)),\t\t\t\t\t\\\n+\t     \"=&r\" (tmp1), \"=&r\" (tmp2), \"=&r\" (tmp3), \"=&r\" (tmp4)\t\\\n+\t   : \"r\" ((UDItype)(u)),\t\t\t\t\t\\\n+\t     \"r\" ((UDItype)(v))\t\t\t\t\t\t\\\n+\t   __CLOBBER_CC);\t\t\t\t\t\t\\\n+  } while (0)\n+#define UMUL_TIME 96\n+#define UDIV_TIME 230\n+#endif /* __sparc_v9__ */\n+\n+#if defined (__vax__) && W_TYPE_SIZE == 32\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   __asm__ (\"addl2 %5,%1\n \tadwc %3,%0\"\t\t\t\t\t\t\t\\\n@@ -1117,14 +1295,48 @@ UDItype __umulsidi3 (USItype, USItype);\n   } while (0)\n #endif /* __vax__ */\n \n+#if defined (__z8000__) && W_TYPE_SIZE == 16\n+#define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"add\t%H1,%H5\\n\\tadc\t%H0,%H3\"\t\t\t\t\\\n+\t   : \"=r\" ((unsigned int)(sh)),\t\t\t\t\t\\\n+\t     \"=&r\" ((unsigned int)(sl))\t\t\t\t\t\\\n+\t   : \"%0\" ((unsigned int)(ah)),\t\t\t\t\t\\\n+\t     \"r\" ((unsigned int)(bh)),\t\t\t\t\t\\\n+\t     \"%1\" ((unsigned int)(al)),\t\t\t\t\t\\\n+\t     \"rQR\" ((unsigned int)(bl)))\n+#define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n+  __asm__ (\"sub\t%H1,%H5\\n\\tsbc\t%H0,%H3\"\t\t\t\t\\\n+\t   : \"=r\" ((unsigned int)(sh)),\t\t\t\t\t\\\n+\t     \"=&r\" ((unsigned int)(sl))\t\t\t\t\t\\\n+\t   : \"0\" ((unsigned int)(ah)),\t\t\t\t\t\\\n+\t     \"r\" ((unsigned int)(bh)),\t\t\t\t\t\\\n+\t     \"1\" ((unsigned int)(al)),\t\t\t\t\t\\\n+\t     \"rQR\" ((unsigned int)(bl)))\n+#define umul_ppmm(xh, xl, m0, m1) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    union {long int __ll;\t\t\t\t\t\t\\\n+\t   struct {unsigned int __h, __l;} __i;\t\t\t\t\\\n+\t  } __xx;\t\t\t\t\t\t\t\\\n+    unsigned int __m0 = (m0), __m1 = (m1);\t\t\t\t\\\n+    __asm__ (\"mult\t%S0,%H3\"\t\t\t\t\t\\\n+\t     : \"=r\" (__xx.__i.__h),\t\t\t\t\t\\\n+\t       \"=r\" (__xx.__i.__l)\t\t\t\t\t\\\n+\t     : \"%1\" (__m0),\t\t\t\t\t\t\\\n+\t       \"rQR\" (__m1));\t\t\t\t\t\t\\\n+    (xh) = __xx.__i.__h; (xl) = __xx.__i.__l;\t\t\t\t\\\n+    (xh) += ((((signed int) __m0 >> 15) & __m1)\t\t\t\t\\\n+\t     + (((signed int) __m1 >> 15) & __m0));\t\t\t\\\n+  } while (0)\n+#endif /* __z8000__ */\n+\n #endif /* __GNUC__ */\n \n /* If this machine has no inline assembler, use C macros.  */\n \n #if !defined (add_ssaaaa)\n #define add_ssaaaa(sh, sl, ah, al, bh, bl) \\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    USItype __x;\t\t\t\t\t\t\t\\\n+    UWtype __x;\t\t\t\t\t\t\t\t\\\n     __x = (al) + (bl);\t\t\t\t\t\t\t\\\n     (sh) = (ah) + (bh) + (__x < (al));\t\t\t\t\t\\\n     (sl) = __x;\t\t\t\t\t\t\t\t\\\n@@ -1134,7 +1346,7 @@ UDItype __umulsidi3 (USItype, USItype);\n #if !defined (sub_ddmmss)\n #define sub_ddmmss(sh, sl, ah, al, bh, bl) \\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    USItype __x;\t\t\t\t\t\t\t\\\n+    UWtype __x;\t\t\t\t\t\t\t\t\\\n     __x = (al) - (bl);\t\t\t\t\t\t\t\\\n     (sh) = (ah) - (bh) - (__x > (al));\t\t\t\t\t\\\n     (sl) = __x;\t\t\t\t\t\t\t\t\\\n@@ -1144,18 +1356,18 @@ UDItype __umulsidi3 (USItype, USItype);\n #if !defined (umul_ppmm)\n #define umul_ppmm(w1, w0, u, v)\t\t\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    USItype __x0, __x1, __x2, __x3;\t\t\t\t\t\\\n-    USItype __ul, __vl, __uh, __vh;\t\t\t\t\t\\\n+    UWtype __x0, __x1, __x2, __x3;\t\t\t\t\t\\\n+    UHWtype __ul, __vl, __uh, __vh;\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     __ul = __ll_lowpart (u);\t\t\t\t\t\t\\\n     __uh = __ll_highpart (u);\t\t\t\t\t\t\\\n     __vl = __ll_lowpart (v);\t\t\t\t\t\t\\\n     __vh = __ll_highpart (v);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    __x0 = (USItype) __ul * __vl;\t\t\t\t\t\\\n-    __x1 = (USItype) __ul * __vh;\t\t\t\t\t\\\n-    __x2 = (USItype) __uh * __vl;\t\t\t\t\t\\\n-    __x3 = (USItype) __uh * __vh;\t\t\t\t\t\\\n+    __x0 = (UWtype) __ul * __vl;\t\t\t\t\t\\\n+    __x1 = (UWtype) __ul * __vh;\t\t\t\t\t\\\n+    __x2 = (UWtype) __uh * __vl;\t\t\t\t\t\\\n+    __x3 = (UWtype) __uh * __vh;\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     __x1 += __ll_highpart (__x0);/* this can't give carry */\t\t\\\n     __x1 += __x2;\t\t/* but this indeed can */\t\t\\\n@@ -1177,14 +1389,14 @@ UDItype __umulsidi3 (USItype, USItype);\n /* Define this unconditionally, so it can be used for debugging.  */\n #define __udiv_qrnnd_c(q, r, n1, n0, d) \\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    USItype __d1, __d0, __q1, __q0;\t\t\t\t\t\\\n-    USItype __r1, __r0, __m;\t\t\t\t\t\t\\\n+    UWtype __d1, __d0, __q1, __q0;\t\t\t\t\t\\\n+    UWtype __r1, __r0, __m;\t\t\t\t\t\t\\\n     __d1 = __ll_highpart (d);\t\t\t\t\t\t\\\n     __d0 = __ll_lowpart (d);\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     __r1 = (n1) % __d1;\t\t\t\t\t\t\t\\\n     __q1 = (n1) / __d1;\t\t\t\t\t\t\t\\\n-    __m = (USItype) __q1 * __d0;\t\t\t\t\t\\\n+    __m = (UWtype) __q1 * __d0;\t\t\t\t\t\t\\\n     __r1 = __r1 * __ll_B | __ll_highpart (n0);\t\t\t\t\\\n     if (__r1 < __m)\t\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n@@ -1197,7 +1409,7 @@ UDItype __umulsidi3 (USItype, USItype);\n \t\t\t\t\t\t\t\t\t\\\n     __r0 = __r1 % __d1;\t\t\t\t\t\t\t\\\n     __q0 = __r1 / __d1;\t\t\t\t\t\t\t\\\n-    __m = (USItype) __q0 * __d0;\t\t\t\t\t\\\n+    __m = (UWtype) __q0 * __d0;\t\t\t\t\t\t\\\n     __r0 = __r0 * __ll_B | __ll_lowpart (n0);\t\t\t\t\\\n     if (__r0 < __m)\t\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n@@ -1208,7 +1420,7 @@ UDItype __umulsidi3 (USItype, USItype);\n       }\t\t\t\t\t\t\t\t\t\\\n     __r0 -= __m;\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    (q) = (USItype) __q1 * __ll_B | __q0;\t\t\t\t\\\n+    (q) = (UWtype) __q1 * __ll_B | __q0;\t\t\t\t\\\n     (r) = __r0;\t\t\t\t\t\t\t\t\\\n   } while (0)\n \n@@ -1233,23 +1445,36 @@ UDItype __umulsidi3 (USItype, USItype);\n extern const UQItype __clz_tab[];\n #define count_leading_zeros(count, x) \\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    USItype __xr = (x);\t\t\t\t\t\t\t\\\n-    USItype __a;\t\t\t\t\t\t\t\\\n+    UWtype __xr = (x);\t\t\t\t\t\t\t\\\n+    UWtype __a;\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    if (SI_TYPE_SIZE <= 32)\t\t\t\t\t\t\\\n+    if (W_TYPE_SIZE <= 32)\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n-\t__a = __xr < ((USItype)1<<2*__BITS4)\t\t\t\t\\\n-\t  ? (__xr < ((USItype)1<<__BITS4) ? 0 : __BITS4)\t\t\\\n-\t  : (__xr < ((USItype)1<<3*__BITS4) ?  2*__BITS4 : 3*__BITS4);\t\\\n+\t__a = __xr < ((UWtype)1<<2*__BITS4)\t\t\t\t\\\n+\t  ? (__xr < ((UWtype)1<<__BITS4) ? 0 : __BITS4)\t\t\t\\\n+\t  : (__xr < ((UWtype)1<<3*__BITS4) ?  2*__BITS4 : 3*__BITS4);\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n     else\t\t\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\t\\\n-\tfor (__a = SI_TYPE_SIZE - 8; __a > 0; __a -= 8)\t\t\t\\\n+\tfor (__a = W_TYPE_SIZE - 8; __a > 0; __a -= 8)\t\t\t\\\n \t  if (((__xr >> __a) & 0xff) != 0)\t\t\t\t\\\n \t    break;\t\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-    (count) = SI_TYPE_SIZE - (__clz_tab[__xr >> __a] + __a);\t\t\\\n+    (count) = W_TYPE_SIZE - (__clz_tab[__xr >> __a] + __a);\t\t\\\n+  } while (0)\n+#define COUNT_LEADING_ZEROS_0 W_TYPE_SIZE\n+#endif\n+\n+#if !defined (count_trailing_zeros)\n+/* Define count_trailing_zeros using count_leading_zeros.  The latter might be\n+   defined in asm, but if it is not, the C version above is good enough.  */\n+#define count_trailing_zeros(count, x) \\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    UWtype __ctz_x = (x);\t\t\t\t\t\t\\\n+    UWtype __ctz_c;\t\t\t\t\t\t\t\\\n+    count_leading_zeros (__ctz_c, __ctz_x & -__ctz_x);\t\t\t\\\n+    (count) = W_TYPE_SIZE - 1 - __ctz_c;\t\t\t\t\\\n   } while (0)\n #endif\n "}]}