{"sha": "374001cbeedd6e59a21bad4b62e40c5657e79645", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzc0MDAxY2JlZWRkNmU1OWEyMWJhZDRiNjJlNDBjNTY1N2U3OTY0NQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-03-25T12:53:57Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-03-25T12:53:57Z"}, "message": "tree-ssa-loop-im.c (struct mem_ref): Use bitmap_head instead of bitmap.\n\n2013-03-25  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-loop-im.c (struct mem_ref): Use bitmap_head instead\n\tof bitmap.\n\t(memory_references): Likewise.\n\t(outermost_indep_loop, mem_ref_alloc, mark_ref_stored,\n\tgather_mem_refs_stmt, record_dep_loop, ref_indep_loop_p_1,\n\tref_indep_loop_p_2, find_refs_for_sm): Adjust.\n\t(gather_mem_refs_in_loops): Fold into ...\n\t(analyze_memory_references): ... this.  Move initialization\n\tto tree_ssa_lim_initialize.\n\t(fill_always_executed_in): Rename to ...\n\t(fill_always_executed_in_1): ... this.\n\t(fill_always_executed_in): Move contains_call computation to\n\tthis new function from ...\n\t(tree_ssa_lim_initialize): ... here.\n\t(tree_ssa_lim): Call fill_always_executed_in.\n\nFrom-SVN: r197038", "tree": {"sha": "c6e9c7f8cbc84b75af278e6a553950a24af122ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6e9c7f8cbc84b75af278e6a553950a24af122ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/374001cbeedd6e59a21bad4b62e40c5657e79645", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/374001cbeedd6e59a21bad4b62e40c5657e79645", "html_url": "https://github.com/Rust-GCC/gccrs/commit/374001cbeedd6e59a21bad4b62e40c5657e79645", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/374001cbeedd6e59a21bad4b62e40c5657e79645/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5789594736ea2fae7b4d45a5486560fd2f8d9aea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5789594736ea2fae7b4d45a5486560fd2f8d9aea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5789594736ea2fae7b4d45a5486560fd2f8d9aea"}], "stats": {"total": 175, "additions": 98, "deletions": 77}, "files": [{"sha": "3abf8781e7dc42226f0e41507069b974ebecd305", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/374001cbeedd6e59a21bad4b62e40c5657e79645/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/374001cbeedd6e59a21bad4b62e40c5657e79645/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=374001cbeedd6e59a21bad4b62e40c5657e79645", "patch": "@@ -1,3 +1,21 @@\n+2013-03-25  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-loop-im.c (struct mem_ref): Use bitmap_head instead\n+\tof bitmap.\n+\t(memory_references): Likewise.\n+\t(outermost_indep_loop, mem_ref_alloc, mark_ref_stored,\n+\tgather_mem_refs_stmt, record_dep_loop, ref_indep_loop_p_1,\n+\tref_indep_loop_p_2, find_refs_for_sm): Adjust.\n+\t(gather_mem_refs_in_loops): Fold into ...\n+\t(analyze_memory_references): ... this.  Move initialization\n+\tto tree_ssa_lim_initialize.\n+\t(fill_always_executed_in): Rename to ...\n+\t(fill_always_executed_in_1): ... this.\n+\t(fill_always_executed_in): Move contains_call computation to\n+\tthis new function from ...\n+\t(tree_ssa_lim_initialize): ... here.\n+\t(tree_ssa_lim): Call fill_always_executed_in.\n+\n 2013-03-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* postreload.c (reload_combine): Fix code detecting returns."}, {"sha": "085789165a2e8effbca97dff0b4cd411b2f51f02", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 80, "deletions": 77, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/374001cbeedd6e59a21bad4b62e40c5657e79645/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/374001cbeedd6e59a21bad4b62e40c5657e79645/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=374001cbeedd6e59a21bad4b62e40c5657e79645", "patch": "@@ -108,7 +108,7 @@ typedef struct mem_ref\n      query meta-data.  */\n   ao_ref mem;\n \n-  bitmap stored;\t\t/* The set of loops in that this memory location\n+  bitmap_head stored;\t\t/* The set of loops in that this memory location\n \t\t\t\t   is stored to.  */\n   vec<vec<mem_ref_loc> > accesses_in_loop;\n \t\t\t\t/* The locations of the accesses.  Vector\n@@ -117,14 +117,14 @@ typedef struct mem_ref\n   /* The following sets are computed on demand.  We keep both set and\n      its complement, so that we know whether the information was\n      already computed or not.  */\n-  bitmap indep_loop;\t\t/* The set of loops in that the memory\n+  bitmap_head indep_loop;\t/* The set of loops in that the memory\n \t\t\t\t   reference is independent, meaning:\n \t\t\t\t   If it is stored in the loop, this store\n \t\t\t\t     is independent on all other loads and\n \t\t\t\t     stores.\n \t\t\t\t   If it is only loaded, then it is independent\n \t\t\t\t     on all stores in the loop.  */\n-  bitmap dep_loop;\t\t/* The complement of INDEP_LOOP.  */\n+  bitmap_head dep_loop;\t\t/* The complement of INDEP_LOOP.  */\n } *mem_ref_p;\n \n /* We use two bits per loop in the ref->{in,}dep_loop bitmaps, the first\n@@ -146,13 +146,13 @@ static struct\n   vec<mem_ref_p> refs_list;\n \n   /* The set of memory references accessed in each loop.  */\n-  vec<bitmap> refs_in_loop;\n+  vec<bitmap_head> refs_in_loop;\n \n   /* The set of memory references stored in each loop.  */\n-  vec<bitmap> refs_stored_in_loop;\n+  vec<bitmap_head> refs_stored_in_loop;\n \n   /* The set of memory references stored in each loop, including subloops .  */\n-  vec<bitmap> all_refs_stored_in_loop;\n+  vec<bitmap_head> all_refs_stored_in_loop;\n \n   /* Cache for expanding memory addresses.  */\n   struct pointer_map_t *ttae_cache;\n@@ -584,13 +584,13 @@ outermost_indep_loop (struct loop *outer, struct loop *loop, mem_ref_p ref)\n {\n   struct loop *aloop;\n \n-  if (bitmap_bit_p (ref->stored, loop->num))\n+  if (bitmap_bit_p (&ref->stored, loop->num))\n     return NULL;\n \n   for (aloop = outer;\n        aloop != loop;\n        aloop = superloop_at_depth (loop, loop_depth (aloop) + 1))\n-    if (!bitmap_bit_p (ref->stored, aloop->num)\n+    if (!bitmap_bit_p (&ref->stored, aloop->num)\n \t&& ref_indep_loop_p (aloop, ref))\n       return aloop;\n \n@@ -1457,9 +1457,9 @@ mem_ref_alloc (tree mem, unsigned hash, unsigned id)\n   ao_ref_init (&ref->mem, mem);\n   ref->id = id;\n   ref->hash = hash;\n-  ref->stored = BITMAP_ALLOC (&lim_bitmap_obstack);\n-  ref->indep_loop = BITMAP_ALLOC (&lim_bitmap_obstack);\n-  ref->dep_loop = BITMAP_ALLOC (&lim_bitmap_obstack);\n+  bitmap_initialize (&ref->stored, &lim_bitmap_obstack);\n+  bitmap_initialize (&ref->indep_loop, &lim_bitmap_obstack);\n+  bitmap_initialize (&ref->dep_loop, &lim_bitmap_obstack);\n   ref->accesses_in_loop.create (0);\n \n   return ref;\n@@ -1487,11 +1487,9 @@ record_mem_ref_loc (mem_ref_p ref, struct loop *loop, gimple stmt, tree *loc)\n static void\n mark_ref_stored (mem_ref_p ref, struct loop *loop)\n {\n-  for (;\n-       loop != current_loops->tree_root\n-       && !bitmap_bit_p (ref->stored, loop->num);\n-       loop = loop_outer (loop))\n-    bitmap_set_bit (ref->stored, loop->num);\n+  while (loop != current_loops->tree_root\n+\t && bitmap_set_bit (&ref->stored, loop->num))\n+    loop = loop_outer (loop);\n }\n \n /* Gathers memory references in statement STMT in LOOP, storing the\n@@ -1552,10 +1550,10 @@ gather_mem_refs_stmt (struct loop *loop, gimple stmt)\n \n       record_mem_ref_loc (ref, loop, stmt, mem);\n     }\n-  bitmap_set_bit (memory_accesses.refs_in_loop[loop->num], ref->id);\n+  bitmap_set_bit (&memory_accesses.refs_in_loop[loop->num], ref->id);\n   if (is_stored)\n     {\n-      bitmap_set_bit (memory_accesses.refs_stored_in_loop[loop->num], ref->id);\n+      bitmap_set_bit (&memory_accesses.refs_stored_in_loop[loop->num], ref->id);\n       mark_ref_stored (ref, loop);\n     }\n   return;\n@@ -1580,7 +1578,7 @@ sort_bbs_in_loop_postorder_cmp (const void *bb1_, const void *bb2_)\n /* Gathers memory references in loops.  */\n \n static void\n-gather_mem_refs_in_loops (void)\n+analyze_memory_references (void)\n {\n   gimple_stmt_iterator bsi;\n   basic_block bb, *bbs;\n@@ -1621,51 +1619,18 @@ gather_mem_refs_in_loops (void)\n   FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n     {\n       /* Finalize the overall touched references (including subloops).  */\n-      bitmap_ior_into (memory_accesses.all_refs_stored_in_loop[loop->num],\n-\t\t       memory_accesses.refs_stored_in_loop[loop->num]);\n+      bitmap_ior_into (&memory_accesses.all_refs_stored_in_loop[loop->num],\n+\t\t       &memory_accesses.refs_stored_in_loop[loop->num]);\n \n       /* Propagate the information about accessed memory references up\n \t the loop hierarchy.  */\n       outer = loop_outer (loop);\n       if (outer == current_loops->tree_root)\n \tcontinue;\n \n-      bitmap_ior_into (memory_accesses.all_refs_stored_in_loop[outer->num],\n-\t\t       memory_accesses.all_refs_stored_in_loop[loop->num]);\n-    }\n-}\n-\n-/* Gathers information about memory accesses in the loops.  */\n-\n-static void\n-analyze_memory_references (void)\n-{\n-  unsigned i;\n-  bitmap empty;\n-\n-  memory_accesses.refs = htab_create (100, memref_hash, memref_eq, NULL);\n-  memory_accesses.refs_list.create (100);\n-  /* Allocate a special, unanalyzable mem-ref with ID zero.  */\n-  memory_accesses.refs_list.quick_push\n-    (mem_ref_alloc (error_mark_node, 0, UNANALYZABLE_MEM_ID));\n-\n-  memory_accesses.refs_in_loop.create (number_of_loops ());\n-  memory_accesses.refs_stored_in_loop.create (number_of_loops ());\n-  memory_accesses.all_refs_stored_in_loop.create (number_of_loops ());\n-\n-  for (i = 0; i < number_of_loops (); i++)\n-    {\n-      empty = BITMAP_ALLOC (&lim_bitmap_obstack);\n-      memory_accesses.refs_in_loop.quick_push (empty);\n-      empty = BITMAP_ALLOC (&lim_bitmap_obstack);\n-      memory_accesses.refs_stored_in_loop.quick_push (empty);\n-      empty = BITMAP_ALLOC (&lim_bitmap_obstack);\n-      memory_accesses.all_refs_stored_in_loop.quick_push (empty);\n+      bitmap_ior_into (&memory_accesses.all_refs_stored_in_loop[outer->num],\n+\t\t       &memory_accesses.all_refs_stored_in_loop[loop->num]);\n     }\n-\n-  memory_accesses.ttae_cache = NULL;\n-\n-  gather_mem_refs_in_loops ();\n }\n \n /* Returns true if MEM1 and MEM2 may alias.  TTAE_CACHE is used as a cache in\n@@ -2231,7 +2196,7 @@ record_dep_loop (struct loop *loop, mem_ref_p ref, bool stored_p)\n   /* We can propagate dependent-in-loop bits up the loop\n      hierarchy to all outer loops.  */\n   while (loop != current_loops->tree_root\n-\t && bitmap_set_bit (ref->dep_loop, LOOP_DEP_BIT (loop->num, stored_p)))\n+\t && bitmap_set_bit (&ref->dep_loop, LOOP_DEP_BIT (loop->num, stored_p)))\n     loop = loop_outer (loop);\n }\n \n@@ -2247,9 +2212,9 @@ ref_indep_loop_p_1 (struct loop *loop, mem_ref_p ref, bool stored_p)\n   mem_ref_p aref;\n \n   if (stored_p)\n-    refs_to_check = memory_accesses.refs_in_loop[loop->num];\n+    refs_to_check = &memory_accesses.refs_in_loop[loop->num];\n   else\n-    refs_to_check = memory_accesses.refs_stored_in_loop[loop->num];\n+    refs_to_check = &memory_accesses.refs_stored_in_loop[loop->num];\n \n   if (bitmap_bit_p (refs_to_check, UNANALYZABLE_MEM_ID))\n     return false;\n@@ -2270,11 +2235,11 @@ ref_indep_loop_p_1 (struct loop *loop, mem_ref_p ref, bool stored_p)\n static bool\n ref_indep_loop_p_2 (struct loop *loop, mem_ref_p ref, bool stored_p)\n {\n-  stored_p |= bitmap_bit_p (ref->stored, loop->num);\n+  stored_p |= bitmap_bit_p (&ref->stored, loop->num);\n \n-  if (bitmap_bit_p (ref->indep_loop, LOOP_DEP_BIT (loop->num, stored_p)))\n+  if (bitmap_bit_p (&ref->indep_loop, LOOP_DEP_BIT (loop->num, stored_p)))\n     return true;\n-  if (bitmap_bit_p (ref->dep_loop, LOOP_DEP_BIT (loop->num, stored_p)))\n+  if (bitmap_bit_p (&ref->dep_loop, LOOP_DEP_BIT (loop->num, stored_p)))\n     return false;\n \n   struct loop *inner = loop->inner;\n@@ -2294,12 +2259,12 @@ ref_indep_loop_p_2 (struct loop *loop, mem_ref_p ref, bool stored_p)\n   /* Record the computed result in the cache.  */\n   if (indep_p)\n     {\n-      if (bitmap_set_bit (ref->indep_loop, LOOP_DEP_BIT (loop->num, stored_p))\n+      if (bitmap_set_bit (&ref->indep_loop, LOOP_DEP_BIT (loop->num, stored_p))\n \t  && stored_p)\n \t{\n \t  /* If it's independend against all refs then it's independent\n \t     against stores, too.  */\n-\t  bitmap_set_bit (ref->indep_loop, LOOP_DEP_BIT (loop->num, false));\n+\t  bitmap_set_bit (&ref->indep_loop, LOOP_DEP_BIT (loop->num, false));\n \t}\n     }\n   else\n@@ -2373,7 +2338,7 @@ can_sm_ref_p (struct loop *loop, mem_ref_p ref)\n static void\n find_refs_for_sm (struct loop *loop, bitmap sm_executed, bitmap refs_to_sm)\n {\n-  bitmap refs = memory_accesses.all_refs_stored_in_loop[loop->num];\n+  bitmap refs = &memory_accesses.all_refs_stored_in_loop[loop->num];\n   unsigned i;\n   bitmap_iterator bi;\n   mem_ref_p ref;\n@@ -2451,7 +2416,7 @@ store_motion (void)\n    blocks that contain a nonpure call.  */\n \n static void\n-fill_always_executed_in (struct loop *loop, sbitmap contains_call)\n+fill_always_executed_in_1 (struct loop *loop, sbitmap contains_call)\n {\n   basic_block bb = NULL, *bbs, last = NULL;\n   unsigned i;\n@@ -2510,45 +2475,80 @@ fill_always_executed_in (struct loop *loop, sbitmap contains_call)\n     }\n \n   for (loop = loop->inner; loop; loop = loop->next)\n-    fill_always_executed_in (loop, contains_call);\n+    fill_always_executed_in_1 (loop, contains_call);\n }\n \n-/* Compute the global information needed by the loop invariant motion pass.  */\n+/* Fills ALWAYS_EXECUTED_IN information for basic blocks, i.e.\n+   for each such basic block bb records the outermost loop for that execution\n+   of its header implies execution of bb.  */\n \n static void\n-tree_ssa_lim_initialize (void)\n+fill_always_executed_in (void)\n {\n   sbitmap contains_call = sbitmap_alloc (last_basic_block);\n-  gimple_stmt_iterator bsi;\n-  struct loop *loop;\n   basic_block bb;\n-\n-  bitmap_obstack_initialize (&lim_bitmap_obstack);\n+  struct loop *loop;\n \n   bitmap_clear (contains_call);\n   FOR_EACH_BB (bb)\n     {\n-      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+      gimple_stmt_iterator gsi;\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n-\t  if (nonpure_call_p (gsi_stmt (bsi)))\n+\t  if (nonpure_call_p (gsi_stmt (gsi)))\n \t    break;\n \t}\n \n-      if (!gsi_end_p (bsi))\n+      if (!gsi_end_p (gsi))\n \tbitmap_set_bit (contains_call, bb->index);\n     }\n \n   for (loop = current_loops->tree_root->inner; loop; loop = loop->next)\n-    fill_always_executed_in (loop, contains_call);\n+    fill_always_executed_in_1 (loop, contains_call);\n \n   sbitmap_free (contains_call);\n+}\n+\n+\n+/* Compute the global information needed by the loop invariant motion pass.  */\n \n+static void\n+tree_ssa_lim_initialize (void)\n+{\n+  unsigned i;\n+\n+  bitmap_obstack_initialize (&lim_bitmap_obstack);\n   lim_aux_data_map = pointer_map_create ();\n \n   if (flag_tm)\n     compute_transaction_bits ();\n \n   alloc_aux_for_edges (0);\n+\n+  memory_accesses.refs = htab_create (100, memref_hash, memref_eq, NULL);\n+  memory_accesses.refs_list.create (100);\n+  /* Allocate a special, unanalyzable mem-ref with ID zero.  */\n+  memory_accesses.refs_list.quick_push\n+    (mem_ref_alloc (error_mark_node, 0, UNANALYZABLE_MEM_ID));\n+\n+  memory_accesses.refs_in_loop.create (number_of_loops ());\n+  memory_accesses.refs_in_loop.quick_grow (number_of_loops ());\n+  memory_accesses.refs_stored_in_loop.create (number_of_loops ());\n+  memory_accesses.refs_stored_in_loop.quick_grow (number_of_loops ());\n+  memory_accesses.all_refs_stored_in_loop.create (number_of_loops ());\n+  memory_accesses.all_refs_stored_in_loop.quick_grow (number_of_loops ());\n+\n+  for (i = 0; i < number_of_loops (); i++)\n+    {\n+      bitmap_initialize (&memory_accesses.refs_in_loop[i],\n+\t\t\t &lim_bitmap_obstack);\n+      bitmap_initialize (&memory_accesses.refs_stored_in_loop[i],\n+\t\t\t &lim_bitmap_obstack);\n+      bitmap_initialize (&memory_accesses.all_refs_stored_in_loop[i],\n+\t\t\t &lim_bitmap_obstack);\n+    }\n+\n+  memory_accesses.ttae_cache = NULL;\n }\n \n /* Cleans up after the invariant motion pass.  */\n@@ -2595,6 +2595,9 @@ tree_ssa_lim (void)\n   /* Gathers information about memory accesses in the loops.  */\n   analyze_memory_references ();\n \n+  /* Fills ALWAYS_EXECUTED_IN information for basic blocks.  */\n+  fill_always_executed_in ();\n+\n   /* For each statement determine the outermost loop in that it is\n      invariant and cost for computing the invariant.  */\n   determine_invariantness ();"}]}