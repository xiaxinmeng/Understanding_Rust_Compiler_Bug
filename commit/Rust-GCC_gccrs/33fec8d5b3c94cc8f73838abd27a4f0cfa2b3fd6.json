{"sha": "33fec8d5b3c94cc8f73838abd27a4f0cfa2b3fd6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzNmZWM4ZDViM2M5NGNjOGY3MzgzOGFiZDI3YTRmMGNmYTJiM2ZkNg==", "commit": {"author": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2016-05-19T22:17:53Z"}, "committer": {"name": "Segher Boessenkool", "email": "segher@gcc.gnu.org", "date": "2016-05-19T22:17:53Z"}, "message": "function: Restructure *logue insertion\n\nThis patch restructures how the prologues/epilogues are inserted.  Sibcalls\nthat run without prologue are now handled in shrink-wrap.c; it communicates\nwhat is already handled by setting the EDGE_IGNORE flag.  The\ntry_shrink_wrapping function then doesn't need to be passed the bb_flags\nanymore.\n\n\n\t* function.c (make_epilogue_seq): Remove epilogue_end parameter.\n\t(thread_prologue_and_epilogue_insns): Remove bb_flags.  Restructure\n\tcode.  Ignore sibcalls on EDGE_IGNORE edges.\n\t* shrink-wrap.c (handle_simple_exit): New function.  Set EDGE_IGNORE\n\ton edges for sibcalls that run without prologue.  The rest of the\n\tfunction is combined from...\n\t(fix_fake_fallthrough_edge): ... this, and ...\n\t(try_shrink_wrapping): ... a part of this.  Remove the bb_with\n\tfunction argument, make it a local variable.\n\nFrom-SVN: r236491", "tree": {"sha": "925e8358e6a8300855c5228c2a225afc376e6b67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/925e8358e6a8300855c5228c2a225afc376e6b67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33fec8d5b3c94cc8f73838abd27a4f0cfa2b3fd6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33fec8d5b3c94cc8f73838abd27a4f0cfa2b3fd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33fec8d5b3c94cc8f73838abd27a4f0cfa2b3fd6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33fec8d5b3c94cc8f73838abd27a4f0cfa2b3fd6/comments", "author": null, "committer": null, "parents": [{"sha": "6befaff6662e3a750c8de2239ded13032994baf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6befaff6662e3a750c8de2239ded13032994baf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6befaff6662e3a750c8de2239ded13032994baf4"}], "stats": {"total": 269, "additions": 124, "deletions": 145}, "files": [{"sha": "fed248d32e81c40ea61ad6d0ed553069e51d4da1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33fec8d5b3c94cc8f73838abd27a4f0cfa2b3fd6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33fec8d5b3c94cc8f73838abd27a4f0cfa2b3fd6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=33fec8d5b3c94cc8f73838abd27a4f0cfa2b3fd6", "patch": "@@ -1,3 +1,15 @@\n+2016-05-19  Segher Boessenkool  <segher@kernel.crashing.org>\n+\n+\t* function.c (make_epilogue_seq): Remove epilogue_end parameter.\n+\t(thread_prologue_and_epilogue_insns): Remove bb_flags.  Restructure\n+\tcode.  Ignore sibcalls on EDGE_IGNORE edges.\n+\t* shrink-wrap.c (handle_simple_exit): New function.  Set EDGE_IGNORE\n+\ton edges for sibcalls that run without prologue.  The rest of the\n+\tfunction is combined from...\n+\t(fix_fake_fallthrough_edge): ... this, and ...\n+\t(try_shrink_wrapping): ... a part of this.  Remove the bb_with\n+\tfunction argument, make it a local variable.\n+\n 2016-05-19  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* config/i386/cygming.h (DWARF2_UNWIND_INFO): Allow \n@@ -6,7 +18,7 @@\n \t* config/i386/mingw32.h (SHARED_LIBGCC_UNDEFS_SPEC): Handle\n \tTARGET_64BIT_DEFAULT.\n \n-2016-05-16  Ryan Burn  <contact@rnburn.com>\n+2016-05-19  Ryan Burn  <contact@rnburn.com>\n \n \t* Makefile.in (GTFILES): Add cilk.h and cilk-common.c.\n \t* gengtype.c (open_base_files): Add cilk.h to ifiles."}, {"sha": "5ff17c75b2682b4bdd7615f59a49ffffe5ca1733", "filename": "gcc/function.c", "status": "modified", "additions": 66, "deletions": 98, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33fec8d5b3c94cc8f73838abd27a4f0cfa2b3fd6/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33fec8d5b3c94cc8f73838abd27a4f0cfa2b3fd6/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=33fec8d5b3c94cc8f73838abd27a4f0cfa2b3fd6", "patch": "@@ -5828,13 +5828,13 @@ make_prologue_seq (void)\n    or NULL.  */\n \n static rtx_insn *\n-make_epilogue_seq (rtx_insn **epilogue_end)\n+make_epilogue_seq (void)\n {\n   if (!targetm.have_epilogue ())\n     return NULL;\n \n   start_sequence ();\n-  *epilogue_end = emit_note (NOTE_INSN_EPILOGUE_BEG);\n+  emit_note (NOTE_INSN_EPILOGUE_BEG);\n   rtx_insn *seq = targetm.gen_epilogue ();\n   if (seq)\n     emit_jump_insn (seq);\n@@ -5905,61 +5905,29 @@ make_epilogue_seq (rtx_insn **epilogue_end)\n void\n thread_prologue_and_epilogue_insns (void)\n {\n-  bool inserted;\n-  bitmap_head bb_flags;\n-  rtx_insn *epilogue_end ATTRIBUTE_UNUSED;\n-  edge e, entry_edge, orig_entry_edge, exit_fallthru_edge;\n-  edge_iterator ei;\n-\n   df_analyze ();\n \n-  rtl_profile_for_bb (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n-\n-  inserted = false;\n-  epilogue_end = NULL;\n-\n   /* Can't deal with multiple successors of the entry block at the\n      moment.  Function should always have at least one entry\n      point.  */\n   gcc_assert (single_succ_p (ENTRY_BLOCK_PTR_FOR_FN (cfun)));\n-  entry_edge = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n-  orig_entry_edge = entry_edge;\n+\n+  edge entry_edge = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+  edge orig_entry_edge = entry_edge;\n \n   rtx_insn *split_prologue_seq = make_split_prologue_seq ();\n   rtx_insn *prologue_seq = make_prologue_seq ();\n-  rtx_insn *epilogue_seq = make_epilogue_seq (&epilogue_end);\n-\n-  bitmap_initialize (&bb_flags, &bitmap_default_obstack);\n+  rtx_insn *epilogue_seq = make_epilogue_seq ();\n \n   /* Try to perform a kind of shrink-wrapping, making sure the\n      prologue/epilogue is emitted only around those parts of the\n      function that require it.  */\n \n-  try_shrink_wrapping (&entry_edge, &bb_flags, prologue_seq);\n+  try_shrink_wrapping (&entry_edge, prologue_seq);\n \n-  if (split_prologue_seq != NULL_RTX)\n-    {\n-      insert_insn_on_edge (split_prologue_seq, orig_entry_edge);\n-      inserted = true;\n-    }\n-  if (prologue_seq != NULL_RTX)\n-    {\n-      insert_insn_on_edge (prologue_seq, entry_edge);\n-      inserted = true;\n-    }\n-\n-  /* If the exit block has no non-fake predecessors, we don't need\n-     an epilogue.  */\n-  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n-    if ((e->flags & EDGE_FAKE) == 0)\n-      break;\n-  if (e == NULL)\n-    goto epilogue_done;\n \n   rtl_profile_for_bb (EXIT_BLOCK_PTR_FOR_FN (cfun));\n \n-  exit_fallthru_edge = find_fallthru_edge (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds);\n-\n   /* A small fib -- epilogue is not yet completed, but we wish to re-use\n      this marker for the splits of EH_RETURN patterns, and nothing else\n      uses the flag in the meantime.  */\n@@ -5970,6 +5938,8 @@ thread_prologue_and_epilogue_insns (void)\n      code.  In order to be able to properly annotate these with unwind\n      info, try to split them now.  If we get a valid split, drop an\n      EPILOGUE_BEG note and mark the insns as epilogue insns.  */\n+  edge e;\n+  edge_iterator ei;\n   FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n     {\n       rtx_insn *prev, *last, *trial;\n@@ -5989,83 +5959,84 @@ thread_prologue_and_epilogue_insns (void)\n       emit_note_after (NOTE_INSN_EPILOGUE_BEG, prev);\n     }\n \n-  /* If nothing falls through into the exit block, we don't need an\n-     epilogue.  */\n-  if (exit_fallthru_edge == NULL)\n-    goto epilogue_done;\n+  edge exit_fallthru_edge = find_fallthru_edge (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds);\n \n-  if (epilogue_seq)\n+  if (exit_fallthru_edge)\n     {\n-      insert_insn_on_edge (epilogue_seq, exit_fallthru_edge);\n-      inserted = true;\n-    }\n-  else\n-    {\n-      basic_block cur_bb;\n+      if (epilogue_seq)\n+\t{\n+\t  insert_insn_on_edge (epilogue_seq, exit_fallthru_edge);\n \n-      if (! next_active_insn (BB_END (exit_fallthru_edge->src)))\n-\tgoto epilogue_done;\n-      /* We have a fall-through edge to the exit block, the source is not\n-         at the end of the function, and there will be an assembler epilogue\n-         at the end of the function.\n-         We can't use force_nonfallthru here, because that would try to\n-\t use return.  Inserting a jump 'by hand' is extremely messy, so\n-\t we take advantage of cfg_layout_finalize using\n-\t fixup_fallthru_exit_predecessor.  */\n-      cfg_layout_initialize (0);\n-      FOR_EACH_BB_FN (cur_bb, cfun)\n-\tif (cur_bb->index >= NUM_FIXED_BLOCKS\n-\t    && cur_bb->next_bb->index >= NUM_FIXED_BLOCKS)\n-\t  cur_bb->aux = cur_bb->next_bb;\n-      cfg_layout_finalize ();\n+\t  /* The epilogue insns we inserted may cause the exit edge to no longer\n+\t     be fallthru.  */\n+\t  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n+\t    {\n+\t      if (((e->flags & EDGE_FALLTHRU) != 0)\n+\t\t  && returnjump_p (BB_END (e->src)))\n+\t\te->flags &= ~EDGE_FALLTHRU;\n+\t    }\n+\t}\n+      else if (next_active_insn (BB_END (exit_fallthru_edge->src)))\n+\t{\n+\t  /* We have a fall-through edge to the exit block, the source is not\n+\t     at the end of the function, and there will be an assembler epilogue\n+\t     at the end of the function.\n+\t     We can't use force_nonfallthru here, because that would try to\n+\t     use return.  Inserting a jump 'by hand' is extremely messy, so\n+\t     we take advantage of cfg_layout_finalize using\n+\t     fixup_fallthru_exit_predecessor.  */\n+\t  cfg_layout_initialize (0);\n+\t  basic_block cur_bb;\n+\t  FOR_EACH_BB_FN (cur_bb, cfun)\n+\t    if (cur_bb->index >= NUM_FIXED_BLOCKS\n+\t\t&& cur_bb->next_bb->index >= NUM_FIXED_BLOCKS)\n+\t      cur_bb->aux = cur_bb->next_bb;\n+\t  cfg_layout_finalize ();\n+\t}\n     }\n \n-epilogue_done:\n+  /* Insert the prologue.  */\n \n-  default_rtl_profile ();\n+  rtl_profile_for_bb (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n \n-  if (inserted)\n+  if (split_prologue_seq || prologue_seq)\n     {\n-      sbitmap blocks;\n+      if (split_prologue_seq)\n+\tinsert_insn_on_edge (split_prologue_seq, orig_entry_edge);\n+\n+      if (prologue_seq)\n+\tinsert_insn_on_edge (prologue_seq, entry_edge);\n \n       commit_edge_insertions ();\n \n       /* Look for basic blocks within the prologue insns.  */\n-      blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+      sbitmap blocks = sbitmap_alloc (last_basic_block_for_fn (cfun));\n       bitmap_clear (blocks);\n       bitmap_set_bit (blocks, entry_edge->dest->index);\n       bitmap_set_bit (blocks, orig_entry_edge->dest->index);\n       find_many_sub_basic_blocks (blocks);\n       sbitmap_free (blocks);\n-\n-      /* The epilogue insns we inserted may cause the exit edge to no longer\n-\t be fallthru.  */\n-      FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)->preds)\n-\t{\n-\t  if (((e->flags & EDGE_FALLTHRU) != 0)\n-\t      && returnjump_p (BB_END (e->src)))\n-\t    e->flags &= ~EDGE_FALLTHRU;\n-\t}\n     }\n \n+  default_rtl_profile ();\n+\n   /* Emit sibling epilogues before any sibling call sites.  */\n-  for (ei = ei_start (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds); (e =\n-\t\t\t\t\t\t\t     ei_safe_edge (ei));\n-\t\t\t\t\t\t\t     )\n-    {\n-      basic_block bb = e->src;\n-      rtx_insn *insn = BB_END (bb);\n-\n-      if (!CALL_P (insn)\n-\t  || ! SIBLING_CALL_P (insn)\n-\t  || (targetm.have_simple_return ()\n-\t      && entry_edge != orig_entry_edge\n-\t      && !bitmap_bit_p (&bb_flags, bb->index)))\n+  for (ei = ei_start (EXIT_BLOCK_PTR_FOR_FN (cfun)->preds);\n+       (e = ei_safe_edge (ei));\n+       ei_next (&ei))\n+    {\n+      /* Skip those already handled, the ones that run without prologue.  */\n+      if (e->flags & EDGE_IGNORE)\n \t{\n-\t  ei_next (&ei);\n+\t  e->flags &= ~EDGE_IGNORE;\n \t  continue;\n \t}\n \n+      rtx_insn *insn = BB_END (e->src);\n+\n+      if (!(CALL_P (insn) && SIBLING_CALL_P (insn)))\n+\tcontinue;\n+\n       if (rtx_insn *ep_seq = targetm.gen_sibcall_epilogue ())\n \t{\n \t  start_sequence ();\n@@ -6082,10 +6053,9 @@ thread_prologue_and_epilogue_insns (void)\n \n \t  emit_insn_before (seq, insn);\n \t}\n-      ei_next (&ei);\n     }\n \n-  if (epilogue_end)\n+  if (epilogue_seq)\n     {\n       rtx_insn *insn, *next;\n \n@@ -6094,17 +6064,15 @@ thread_prologue_and_epilogue_insns (void)\n \t of such a note.  Also possibly move\n \t NOTE_INSN_FUNCTION_BEG notes, as those can be relevant for debug\n \t info generation.  */\n-      for (insn = epilogue_end; insn; insn = next)\n+      for (insn = epilogue_seq; insn; insn = next)\n \t{\n \t  next = NEXT_INSN (insn);\n \t  if (NOTE_P (insn)\n \t      && (NOTE_KIND (insn) == NOTE_INSN_FUNCTION_BEG))\n-\t    reorder_insns (insn, insn, PREV_INSN (epilogue_end));\n+\t    reorder_insns (insn, insn, PREV_INSN (epilogue_seq));\n \t}\n     }\n \n-  bitmap_clear (&bb_flags);\n-\n   /* Threading the prologue and epilogue changes the artificial refs\n      in the entry and exit blocks.  */\n   epilogue_completed = 1;"}, {"sha": "b85b1c3b3497c6c1b8d7ee80930cb123025fb23f", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33fec8d5b3c94cc8f73838abd27a4f0cfa2b3fd6/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33fec8d5b3c94cc8f73838abd27a4f0cfa2b3fd6/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=33fec8d5b3c94cc8f73838abd27a4f0cfa2b3fd6", "patch": "@@ -529,30 +529,49 @@ can_dup_for_shrink_wrapping (basic_block bb, basic_block pro, unsigned max_size)\n   return true;\n }\n \n-/* If the source of edge E has more than one successor, the verifier for\n-   branch probabilities gets confused by the fake edges we make where\n-   simple_return statements will be inserted later (because those are not\n-   marked as fallthrough edges).  Fix this by creating an extra block just\n-   for that fallthrough.  */\n+/* Do whatever needs to be done for exits that run without prologue.\n+   Sibcalls need nothing done.  Normal exits get a simple_return inserted.  */\n \n-static edge\n-fix_fake_fallthrough_edge (edge e)\n+static void\n+handle_simple_exit (edge e)\n {\n-  if (EDGE_COUNT (e->src->succs) <= 1)\n-    return e;\n \n-  basic_block old_bb = e->src;\n-  rtx_insn *end = BB_END (old_bb);\n-  rtx_note *note = emit_note_after (NOTE_INSN_DELETED, end);\n-  basic_block new_bb = create_basic_block (note, note, old_bb);\n-  BB_COPY_PARTITION (new_bb, old_bb);\n-  BB_END (old_bb) = end;\n+  if (e->flags & EDGE_SIBCALL)\n+    {\n+      /* Tell function.c to take no further action on this edge.  */\n+      e->flags |= EDGE_IGNORE;\n+\n+      e->flags &= ~EDGE_FALLTHRU;\n+      emit_barrier_after_bb (e->src);\n+      return;\n+    }\n+\n+  /* If the basic block the edge comes from has multiple successors,\n+     split the edge.  */\n+  if (EDGE_COUNT (e->src->succs) > 1)\n+    {\n+      basic_block old_bb = e->src;\n+      rtx_insn *end = BB_END (old_bb);\n+      rtx_note *note = emit_note_after (NOTE_INSN_DELETED, end);\n+      basic_block new_bb = create_basic_block (note, note, old_bb);\n+      BB_COPY_PARTITION (new_bb, old_bb);\n+      BB_END (old_bb) = end;\n+\n+      redirect_edge_succ (e, new_bb);\n+      e->flags |= EDGE_FALLTHRU;\n+\n+      e = make_edge (new_bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n+    }\n \n-  redirect_edge_succ (e, new_bb);\n-  e->flags |= EDGE_FALLTHRU;\n-  e->flags &= ~EDGE_FAKE;\n+  e->flags &= ~EDGE_FALLTHRU;\n+  rtx_jump_insn *ret = emit_jump_insn_after (targetm.gen_simple_return (),\n+\t\t\t\t\t     BB_END (e->src));\n+  JUMP_LABEL (ret) = simple_return_rtx;\n+  emit_barrier_after_bb (e->src);\n \n-  return make_edge (new_bb, EXIT_BLOCK_PTR_FOR_FN (cfun), EDGE_FAKE);\n+  if (dump_file)\n+    fprintf (dump_file, \"Made simple_return with UID %d in bb %d\\n\",\n+\t     INSN_UID (ret), e->src->index);\n }\n \n /* Try to perform a kind of shrink-wrapping, making sure the\n@@ -610,13 +629,10 @@ fix_fake_fallthrough_edge (edge e)\n    (bb 4 is duplicated to 5; the prologue is inserted on the edge 5->3).\n \n    ENTRY_EDGE is the edge where the prologue will be placed, possibly\n-   changed by this function.  BB_WITH is a bitmap that, if we do shrink-\n-   wrap, will on return contain the interesting blocks that run with\n-   prologue.  PROLOGUE_SEQ is the prologue we will insert.  */\n+   changed by this function.  PROLOGUE_SEQ is the prologue we will insert.  */\n \n void\n-try_shrink_wrapping (edge *entry_edge, bitmap_head *bb_with,\n-\t\t     rtx_insn *prologue_seq)\n+try_shrink_wrapping (edge *entry_edge, rtx_insn *prologue_seq)\n {\n   /* If we cannot shrink-wrap, are told not to shrink-wrap, or it makes\n      no sense to shrink-wrap: then do not shrink-wrap!  */\n@@ -739,6 +755,7 @@ try_shrink_wrapping (edge *entry_edge, bitmap_head *bb_with,\n      reachable from PRO that we already found, and in VEC a stack of\n      those we still need to consider (to find successors).  */\n \n+  bitmap bb_with = BITMAP_ALLOC (NULL);\n   bitmap_set_bit (bb_with, pro->index);\n \n   vec<basic_block> vec;\n@@ -851,6 +868,7 @@ try_shrink_wrapping (edge *entry_edge, bitmap_head *bb_with,\n \n   if (pro == entry)\n     {\n+      BITMAP_FREE (bb_with);\n       free_dominance_info (CDI_DOMINATORS);\n       return;\n     }\n@@ -952,26 +970,7 @@ try_shrink_wrapping (edge *entry_edge, bitmap_head *bb_with,\n     if (!bitmap_bit_p (bb_with, bb->index))\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n-\t  {\n-\t    e = fix_fake_fallthrough_edge (e);\n-\n-\t    e->flags &= ~EDGE_FALLTHRU;\n-\t    if (!(e->flags & EDGE_SIBCALL))\n-\t      {\n-\t\trtx_insn *ret = targetm.gen_simple_return ();\n-\t\trtx_insn *end = BB_END (e->src);\n-\t\trtx_jump_insn *start = emit_jump_insn_after (ret, end);\n-\t\tJUMP_LABEL (start) = simple_return_rtx;\n-\t\te->flags &= ~EDGE_FAKE;\n-\n-\t\tif (dump_file)\n-\t\t  fprintf (dump_file,\n-\t\t\t   \"Made simple_return with UID %d in bb %d\\n\",\n-\t\t\t   INSN_UID (start), e->src->index);\n-\t      }\n-\n-\t    emit_barrier_after_bb (e->src);\n-\t  }\n+\t  handle_simple_exit (e);\n \n   /* Finally, we want a single edge to put the prologue on.  Make a new\n      block before the PRO block; the edge beteen them is the edge we want.\n@@ -1004,5 +1003,6 @@ try_shrink_wrapping (edge *entry_edge, bitmap_head *bb_with,\n   *entry_edge = make_single_succ_edge (new_bb, pro, EDGE_FALLTHRU);\n   force_nonfallthru (*entry_edge);\n \n+  BITMAP_FREE (bb_with);\n   free_dominance_info (CDI_DOMINATORS);\n }"}, {"sha": "e06ab37952f545ba4b59c391263f7a6a8b35119e", "filename": "gcc/shrink-wrap.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33fec8d5b3c94cc8f73838abd27a4f0cfa2b3fd6/gcc%2Fshrink-wrap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33fec8d5b3c94cc8f73838abd27a4f0cfa2b3fd6/gcc%2Fshrink-wrap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.h?ref=33fec8d5b3c94cc8f73838abd27a4f0cfa2b3fd6", "patch": "@@ -24,8 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* In shrink-wrap.c.  */\n extern bool requires_stack_frame_p (rtx_insn *, HARD_REG_SET, HARD_REG_SET);\n-extern void try_shrink_wrapping (edge *entry_edge, bitmap_head *bb_flags,\n-\t\t\t\t rtx_insn *prologue_seq);\n+extern void try_shrink_wrapping (edge *entry_edge, rtx_insn *prologue_seq);\n #define SHRINK_WRAPPING_ENABLED \\\n   (flag_shrink_wrap && targetm.have_simple_return ())\n "}]}