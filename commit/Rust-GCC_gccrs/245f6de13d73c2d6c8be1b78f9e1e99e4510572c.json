{"sha": "245f6de13d73c2d6c8be1b78f9e1e99e4510572c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQ1ZjZkZTEzZDczYzJkNmM4YmUxYjc4ZjllMWU5OWU0NTEwNTcyYw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-11-03T19:08:25Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-11-03T19:08:25Z"}, "message": "re PR tree-optimization/78821 (GCC7: Copying whole 32 bits structure field by field not optimised into copying whole 32 bits at once)\n\n\tPR tree-optimization/78821\n\t* gimple-ssa-store-merging.c: Update the file comment.\n\t(MAX_STORE_ALIAS_CHECKS): Define.\n\t(struct store_operand_info): New type.\n\t(store_operand_info::store_operand_info): New constructor.\n\t(struct store_immediate_info): Add rhs_code and ops data members.\n\t(store_immediate_info::store_immediate_info): Add rhscode, op0r\n\tand op1r arguments to the ctor, initialize corresponding data members.\n\t(struct merged_store_group): Add load_align_base and load_align\n\tdata members.\n\t(merged_store_group::merged_store_group): Initialize them.\n\t(merged_store_group::do_merge): Update them.\n\t(merged_store_group::apply_stores): Pick the constant for\n\tencode_tree_to_bitpos from one of the two operands, or skip\n\tencode_tree_to_bitpos if neither operand is a constant.\n\t(class pass_store_merging): Add process_store method decl.  Remove\n\tbool argument from terminate_all_aliasing_chains method decl.\n\t(pass_store_merging::terminate_all_aliasing_chains): Remove\n\tvar_offset_p argument and corresponding handling.\n\t(stmts_may_clobber_ref_p): New function.\n\t(compatible_load_p): New function.\n\t(imm_store_chain_info::coalesce_immediate_stores): Terminate group\n\tif there is overlap and rhs_code is not INTEGER_CST.  For\n\tnon-overlapping stores terminate group if rhs is not mergeable.\n\t(get_alias_type_for_stmts): Change first argument from\n\tauto_vec<gimple *> & to vec<gimple *> &.  Add IS_LOAD, CLIQUEP and\n\tBASEP arguments.  If IS_LOAD is true, look at rhs1 of the stmts\n\tinstead of lhs.  Compute *CLIQUEP and *BASEP in addition to the\n\talias type.\n\t(get_location_for_stmts): Change first argument from\n\tauto_vec<gimple *> & to vec<gimple *> &.\n\t(struct split_store): Remove orig_stmts data member, add orig_stores.\n\t(split_store::split_store): Create orig_stores rather than orig_stmts.\n\t(find_constituent_stmts): Renamed to ...\n\t(find_constituent_stores): ... this.  Change second argument from\n\tvec<gimple *> * to vec<store_immediate_info *> *, push pointers\n\tto info structures rather than the statements.\n\t(split_group): Rename ALLOW_UNALIGNED argument to\n\tALLOW_UNALIGNED_STORE, add ALLOW_UNALIGNED_LOAD argument and handle\n\tit.  Adjust find_constituent_stores caller.\n\t(imm_store_chain_info::output_merged_store): Handle rhs_code other\n\tthan INTEGER_CST, adjust split_group, get_alias_type_for_stmts and\n\tget_location_for_stmts callers.  Set MR_DEPENDENCE_CLIQUE and\n\tMR_DEPENDENCE_BASE on the MEM_REFs if they are the same in all stores.\n\t(mem_valid_for_store_merging): New function.\n\t(handled_load): New function.\n\t(pass_store_merging::process_store): New method.\n\t(pass_store_merging::execute): Use process_store method.  Adjust\n\tterminate_all_aliasing_chains caller.\n\n\t* gcc.dg/store_merging_13.c: New test.\n\t* gcc.dg/store_merging_14.c: New test.\n\nFrom-SVN: r254391", "tree": {"sha": "bf77f3cfbecea3d66abdfbbebfdbf1e3ddf5d837", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf77f3cfbecea3d66abdfbbebfdbf1e3ddf5d837"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/245f6de13d73c2d6c8be1b78f9e1e99e4510572c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/245f6de13d73c2d6c8be1b78f9e1e99e4510572c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/245f6de13d73c2d6c8be1b78f9e1e99e4510572c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/245f6de13d73c2d6c8be1b78f9e1e99e4510572c/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "248b06ba7dcc46498fca20a62b727515863062d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/248b06ba7dcc46498fca20a62b727515863062d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/248b06ba7dcc46498fca20a62b727515863062d0"}], "stats": {"total": 1520, "additions": 1230, "deletions": 290}, "files": [{"sha": "98cd5a41b65f2cadacc81adff27eccf055e79320", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245f6de13d73c2d6c8be1b78f9e1e99e4510572c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245f6de13d73c2d6c8be1b78f9e1e99e4510572c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=245f6de13d73c2d6c8be1b78f9e1e99e4510572c", "patch": "@@ -1,3 +1,55 @@\n+2017-11-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/78821\n+\t* gimple-ssa-store-merging.c: Update the file comment.\n+\t(MAX_STORE_ALIAS_CHECKS): Define.\n+\t(struct store_operand_info): New type.\n+\t(store_operand_info::store_operand_info): New constructor.\n+\t(struct store_immediate_info): Add rhs_code and ops data members.\n+\t(store_immediate_info::store_immediate_info): Add rhscode, op0r\n+\tand op1r arguments to the ctor, initialize corresponding data members.\n+\t(struct merged_store_group): Add load_align_base and load_align\n+\tdata members.\n+\t(merged_store_group::merged_store_group): Initialize them.\n+\t(merged_store_group::do_merge): Update them.\n+\t(merged_store_group::apply_stores): Pick the constant for\n+\tencode_tree_to_bitpos from one of the two operands, or skip\n+\tencode_tree_to_bitpos if neither operand is a constant.\n+\t(class pass_store_merging): Add process_store method decl.  Remove\n+\tbool argument from terminate_all_aliasing_chains method decl.\n+\t(pass_store_merging::terminate_all_aliasing_chains): Remove\n+\tvar_offset_p argument and corresponding handling.\n+\t(stmts_may_clobber_ref_p): New function.\n+\t(compatible_load_p): New function.\n+\t(imm_store_chain_info::coalesce_immediate_stores): Terminate group\n+\tif there is overlap and rhs_code is not INTEGER_CST.  For\n+\tnon-overlapping stores terminate group if rhs is not mergeable.\n+\t(get_alias_type_for_stmts): Change first argument from\n+\tauto_vec<gimple *> & to vec<gimple *> &.  Add IS_LOAD, CLIQUEP and\n+\tBASEP arguments.  If IS_LOAD is true, look at rhs1 of the stmts\n+\tinstead of lhs.  Compute *CLIQUEP and *BASEP in addition to the\n+\talias type.\n+\t(get_location_for_stmts): Change first argument from\n+\tauto_vec<gimple *> & to vec<gimple *> &.\n+\t(struct split_store): Remove orig_stmts data member, add orig_stores.\n+\t(split_store::split_store): Create orig_stores rather than orig_stmts.\n+\t(find_constituent_stmts): Renamed to ...\n+\t(find_constituent_stores): ... this.  Change second argument from\n+\tvec<gimple *> * to vec<store_immediate_info *> *, push pointers\n+\tto info structures rather than the statements.\n+\t(split_group): Rename ALLOW_UNALIGNED argument to\n+\tALLOW_UNALIGNED_STORE, add ALLOW_UNALIGNED_LOAD argument and handle\n+\tit.  Adjust find_constituent_stores caller.\n+\t(imm_store_chain_info::output_merged_store): Handle rhs_code other\n+\tthan INTEGER_CST, adjust split_group, get_alias_type_for_stmts and\n+\tget_location_for_stmts callers.  Set MR_DEPENDENCE_CLIQUE and\n+\tMR_DEPENDENCE_BASE on the MEM_REFs if they are the same in all stores.\n+\t(mem_valid_for_store_merging): New function.\n+\t(handled_load): New function.\n+\t(pass_store_merging::process_store): New method.\n+\t(pass_store_merging::execute): Use process_store method.  Adjust\n+\tterminate_all_aliasing_chains caller.\n+\n 2017-11-03  Wilco Dijkstra  <wdijkstr@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_legitimate_constant_p):"}, {"sha": "5366a9b6e2907b88dbdac60711644721cc699a87", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 858, "deletions": 290, "changes": 1148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245f6de13d73c2d6c8be1b78f9e1e99e4510572c/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245f6de13d73c2d6c8be1b78f9e1e99e4510572c/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=245f6de13d73c2d6c8be1b78f9e1e99e4510572c", "patch": "@@ -19,7 +19,8 @@\n    <http://www.gnu.org/licenses/>.  */\n \n /* The purpose of this pass is to combine multiple memory stores of\n-   constant values to consecutive memory locations into fewer wider stores.\n+   constant values, values loaded from memory or bitwise operations\n+   on those to consecutive memory locations into fewer wider stores.\n    For example, if we have a sequence peforming four byte stores to\n    consecutive memory locations:\n    [p     ] := imm1;\n@@ -29,21 +30,49 @@\n    we can transform this into a single 4-byte store if the target supports it:\n   [p] := imm1:imm2:imm3:imm4 //concatenated immediates according to endianness.\n \n+   Or:\n+   [p     ] := [q     ];\n+   [p + 1B] := [q + 1B];\n+   [p + 2B] := [q + 2B];\n+   [p + 3B] := [q + 3B];\n+   if there is no overlap can be transformed into a single 4-byte\n+   load followed by single 4-byte store.\n+\n+   Or:\n+   [p     ] := [q     ] ^ imm1;\n+   [p + 1B] := [q + 1B] ^ imm2;\n+   [p + 2B] := [q + 2B] ^ imm3;\n+   [p + 3B] := [q + 3B] ^ imm4;\n+   if there is no overlap can be transformed into a single 4-byte\n+   load, xored with imm1:imm2:imm3:imm4 and stored using a single 4-byte store.\n+\n    The algorithm is applied to each basic block in three phases:\n \n-   1) Scan through the basic block recording constant assignments to\n+   1) Scan through the basic block recording assignments to\n    destinations that can be expressed as a store to memory of a certain size\n-   at a certain bit offset.  Record store chains to different bases in a\n-   hash_map (m_stores) and make sure to terminate such chains when appropriate\n-   (for example when when the stored values get used subsequently).\n+   at a certain bit offset from expressions we can handle.  For bit-fields\n+   we also note the surrounding bit region, bits that could be stored in\n+   a read-modify-write operation when storing the bit-field.  Record store\n+   chains to different bases in a hash_map (m_stores) and make sure to\n+   terminate such chains when appropriate (for example when when the stored\n+   values get used subsequently).\n    These stores can be a result of structure element initializers, array stores\n    etc.  A store_immediate_info object is recorded for every such store.\n    Record as many such assignments to a single base as possible until a\n    statement that interferes with the store sequence is encountered.\n+   Each store has up to 2 operands, which can be an immediate constant\n+   or a memory load, from which the value to be stored can be computed.\n+   At most one of the operands can be a constant.  The operands are recorded\n+   in store_operand_info struct.\n \n    2) Analyze the chain of stores recorded in phase 1) (i.e. the vector of\n    store_immediate_info objects) and coalesce contiguous stores into\n-   merged_store_group objects.\n+   merged_store_group objects.  For bit-fields stores, we don't need to\n+   require the stores to be contiguous, just their surrounding bit regions\n+   have to be contiguous.  If the expression being stored is different\n+   between adjacent stores, such as one store storing a constant and\n+   following storing a value loaded from memory, or if the loaded memory\n+   objects are not adjacent, a new merged_store_group is created as well.\n \n    For example, given the stores:\n    [p     ] := 0;\n@@ -134,8 +163,35 @@\n #define MAX_STORE_BITSIZE (BITS_PER_WORD)\n #define MAX_STORE_BYTES (MAX_STORE_BITSIZE / BITS_PER_UNIT)\n \n+/* Limit to bound the number of aliasing checks for loads with the same\n+   vuse as the corresponding store.  */\n+#define MAX_STORE_ALIAS_CHECKS 64\n+\n namespace {\n \n+/* Struct recording one operand for the store, which is either a constant,\n+   then VAL represents the constant and all the other fields are zero,\n+   or a memory load, then VAL represents the reference, BASE_ADDR is non-NULL\n+   and the other fields also reflect the memory load.  */\n+\n+struct store_operand_info\n+{\n+  tree val;\n+  tree base_addr;\n+  unsigned HOST_WIDE_INT bitsize;\n+  unsigned HOST_WIDE_INT bitpos;\n+  unsigned HOST_WIDE_INT bitregion_start;\n+  unsigned HOST_WIDE_INT bitregion_end;\n+  gimple *stmt;\n+  store_operand_info ();\n+};\n+\n+store_operand_info::store_operand_info ()\n+  : val (NULL_TREE), base_addr (NULL_TREE), bitsize (0), bitpos (0),\n+    bitregion_start (0), bitregion_end (0), stmt (NULL)\n+{\n+}\n+\n /* Struct recording the information about a single store of an immediate\n    to memory.  These are created in the first phase and coalesced into\n    merged_store_group objects in the second phase.  */\n@@ -149,21 +205,40 @@ struct store_immediate_info\n   unsigned HOST_WIDE_INT bitregion_end;\n   gimple *stmt;\n   unsigned int order;\n+  /* INTEGER_CST for constant stores, MEM_REF for memory copy or\n+     BIT_*_EXPR for logical bitwise operation.  */\n+  enum tree_code rhs_code;\n+  /* Operands.  For BIT_*_EXPR rhs_code both operands are used, otherwise\n+     just the first one.  */\n+  store_operand_info ops[2];\n   store_immediate_info (unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n \t\t\tunsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n-\t\t\tgimple *, unsigned int);\n+\t\t\tgimple *, unsigned int, enum tree_code,\n+\t\t\tconst store_operand_info &,\n+\t\t\tconst store_operand_info &);\n };\n \n store_immediate_info::store_immediate_info (unsigned HOST_WIDE_INT bs,\n \t\t\t\t\t    unsigned HOST_WIDE_INT bp,\n \t\t\t\t\t    unsigned HOST_WIDE_INT brs,\n \t\t\t\t\t    unsigned HOST_WIDE_INT bre,\n \t\t\t\t\t    gimple *st,\n-\t\t\t\t\t    unsigned int ord)\n+\t\t\t\t\t    unsigned int ord,\n+\t\t\t\t\t    enum tree_code rhscode,\n+\t\t\t\t\t    const store_operand_info &op0r,\n+\t\t\t\t\t    const store_operand_info &op1r)\n   : bitsize (bs), bitpos (bp), bitregion_start (brs), bitregion_end (bre),\n-    stmt (st), order (ord)\n+    stmt (st), order (ord), rhs_code (rhscode)\n+#if __cplusplus >= 201103L\n+    , ops { op0r, op1r }\n+{\n+}\n+#else\n {\n+  ops[0] = op0r;\n+  ops[1] = op1r;\n }\n+#endif\n \n /* Struct representing a group of stores to contiguous memory locations.\n    These are produced by the second phase (coalescing) and consumed in the\n@@ -178,8 +253,10 @@ struct merged_store_group\n   /* The size of the allocated memory for val and mask.  */\n   unsigned HOST_WIDE_INT buf_size;\n   unsigned HOST_WIDE_INT align_base;\n+  unsigned HOST_WIDE_INT load_align_base[2];\n \n   unsigned int align;\n+  unsigned int load_align[2];\n   unsigned int first_order;\n   unsigned int last_order;\n \n@@ -576,6 +653,20 @@ merged_store_group::merged_store_group (store_immediate_info *info)\n   get_object_alignment_1 (gimple_assign_lhs (info->stmt),\n \t\t\t  &align, &align_bitpos);\n   align_base = start - align_bitpos;\n+  for (int i = 0; i < 2; ++i)\n+    {\n+      store_operand_info &op = info->ops[i];\n+      if (op.base_addr == NULL_TREE)\n+\t{\n+\t  load_align[i] = 0;\n+\t  load_align_base[i] = 0;\n+\t}\n+      else\n+\t{\n+\t  get_object_alignment_1 (op.val, &load_align[i], &align_bitpos);\n+\t  load_align_base[i] = op.bitpos - align_bitpos;\n+\t}\n+    }\n   stores.create (1);\n   stores.safe_push (info);\n   last_stmt = info->stmt;\n@@ -608,6 +699,19 @@ merged_store_group::do_merge (store_immediate_info *info)\n       align = this_align;\n       align_base = info->bitpos - align_bitpos;\n     }\n+  for (int i = 0; i < 2; ++i)\n+    {\n+      store_operand_info &op = info->ops[i];\n+      if (!op.base_addr)\n+\tcontinue;\n+\n+      get_object_alignment_1 (op.val, &this_align, &align_bitpos);\n+      if (this_align > load_align[i])\n+\t{\n+\t  load_align[i] = this_align;\n+\t  load_align_base[i] = op.bitpos - align_bitpos;\n+\t}\n+    }\n \n   gimple *stmt = info->stmt;\n   stores.safe_push (info);\n@@ -682,16 +786,21 @@ merged_store_group::apply_stores ()\n   FOR_EACH_VEC_ELT (stores, i, info)\n     {\n       unsigned int pos_in_buffer = info->bitpos - bitregion_start;\n-      bool ret = encode_tree_to_bitpos (gimple_assign_rhs1 (info->stmt),\n-\t\t\t\t\tval, info->bitsize,\n-\t\t\t\t\tpos_in_buffer, buf_size);\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n+      tree cst = NULL_TREE;\n+      if (info->ops[0].val && info->ops[0].base_addr == NULL_TREE)\n+\tcst = info->ops[0].val;\n+      else if (info->ops[1].val && info->ops[1].base_addr == NULL_TREE)\n+\tcst = info->ops[1].val;\n+      bool ret = true;\n+      if (cst)\n+\tret = encode_tree_to_bitpos (cst, val, info->bitsize,\n+\t\t\t\t     pos_in_buffer, buf_size);\n+      if (cst && dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  if (ret)\n \t    {\n \t      fprintf (dump_file, \"After writing \");\n-\t      print_generic_expr (dump_file,\n-\t\t\t\t  gimple_assign_rhs1 (info->stmt), 0);\n+\t      print_generic_expr (dump_file, cst, 0);\n \t      fprintf (dump_file, \" of size \" HOST_WIDE_INT_PRINT_DEC\n \t\t\t\" at position %d the merged region contains:\\n\",\n \t\t\tinfo->bitsize, pos_in_buffer);\n@@ -799,9 +908,10 @@ class pass_store_merging : public gimple_opt_pass\n      decisions when going out of SSA).  */\n   imm_store_chain_info *m_stores_head;\n \n+  void process_store (gimple *);\n   bool terminate_and_process_all_chains ();\n   bool terminate_all_aliasing_chains (imm_store_chain_info **,\n-\t\t\t\t      bool, gimple *);\n+\t\t\t\t      gimple *);\n   bool terminate_and_release_chain (imm_store_chain_info *);\n }; // class pass_store_merging\n \n@@ -831,7 +941,6 @@ pass_store_merging::terminate_and_process_all_chains ()\n bool\n pass_store_merging::terminate_all_aliasing_chains (imm_store_chain_info\n \t\t\t\t\t\t     **chain_info,\n-\t\t\t\t\t\t   bool var_offset_p,\n \t\t\t\t\t\t   gimple *stmt)\n {\n   bool ret = false;\n@@ -845,37 +954,21 @@ pass_store_merging::terminate_all_aliasing_chains (imm_store_chain_info\n      of a chain.  */\n   if (chain_info)\n     {\n-      /* We have a chain at BASE and we're writing to [BASE + <variable>].\n-\t This can interfere with any of the stores so terminate\n-\t the chain.  */\n-      if (var_offset_p)\n+      store_immediate_info *info;\n+      unsigned int i;\n+      FOR_EACH_VEC_ELT ((*chain_info)->m_store_info, i, info)\n \t{\n-\t  terminate_and_release_chain (*chain_info);\n-\t  ret = true;\n-\t}\n-      /* Otherwise go through every store in the chain to see if it\n-\t aliases with any of them.  */\n-      else\n-\t{\n-\t  store_immediate_info *info;\n-\t  unsigned int i;\n-\t  FOR_EACH_VEC_ELT ((*chain_info)->m_store_info, i, info)\n+\t  if (ref_maybe_used_by_stmt_p (stmt, gimple_assign_lhs (info->stmt))\n+\t      || stmt_may_clobber_ref_p (stmt, gimple_assign_lhs (info->stmt)))\n \t    {\n-\t      if (ref_maybe_used_by_stmt_p (stmt,\n-\t\t\t\t\t    gimple_assign_lhs (info->stmt))\n-\t\t  || stmt_may_clobber_ref_p (stmt,\n-\t\t\t\t\t     gimple_assign_lhs (info->stmt)))\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t{\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    {\n-\t\t      fprintf (dump_file,\n-\t\t\t       \"stmt causes chain termination:\\n\");\n-\t\t      print_gimple_stmt (dump_file, stmt, 0);\n-\t\t    }\n-\t\t  terminate_and_release_chain (*chain_info);\n-\t\t  ret = true;\n-\t\t  break;\n+\t\t  fprintf (dump_file, \"stmt causes chain termination:\\n\");\n+\t\t  print_gimple_stmt (dump_file, stmt, 0);\n \t\t}\n+\t      terminate_and_release_chain (*chain_info);\n+\t      ret = true;\n+\t      break;\n \t    }\n \t}\n     }\n@@ -920,6 +1013,125 @@ pass_store_merging::terminate_and_release_chain (imm_store_chain_info *chain_inf\n   return ret;\n }\n \n+/* Return true if stmts in between FIRST (inclusive) and LAST (exclusive)\n+   may clobber REF.  FIRST and LAST must be in the same basic block and\n+   have non-NULL vdef.  */\n+\n+bool\n+stmts_may_clobber_ref_p (gimple *first, gimple *last, tree ref)\n+{\n+  ao_ref r;\n+  ao_ref_init (&r, ref);\n+  unsigned int count = 0;\n+  tree vop = gimple_vdef (last);\n+  gimple *stmt;\n+\n+  gcc_checking_assert (gimple_bb (first) == gimple_bb (last));\n+  do\n+    {\n+      stmt = SSA_NAME_DEF_STMT (vop);\n+      if (stmt_may_clobber_ref_p_1 (stmt, &r))\n+\treturn true;\n+      /* Avoid quadratic compile time by bounding the number of checks\n+\t we perform.  */\n+      if (++count > MAX_STORE_ALIAS_CHECKS)\n+\treturn true;\n+      vop = gimple_vuse (stmt);\n+    }\n+  while (stmt != first);\n+  return false;\n+}\n+\n+/* Return true if INFO->ops[IDX] is mergeable with the\n+   corresponding loads already in MERGED_STORE group.\n+   BASE_ADDR is the base address of the whole store group.  */\n+\n+bool\n+compatible_load_p (merged_store_group *merged_store,\n+\t\t   store_immediate_info *info,\n+\t\t   tree base_addr, int idx)\n+{\n+  store_immediate_info *infof = merged_store->stores[0];\n+  if (!info->ops[idx].base_addr\n+      || (info->ops[idx].bitpos - infof->ops[idx].bitpos\n+\t  != info->bitpos - infof->bitpos)\n+      || !operand_equal_p (info->ops[idx].base_addr,\n+\t\t\t   infof->ops[idx].base_addr, 0))\n+    return false;\n+\n+  store_immediate_info *infol = merged_store->stores.last ();\n+  tree load_vuse = gimple_vuse (info->ops[idx].stmt);\n+  /* In this case all vuses should be the same, e.g.\n+     _1 = s.a; _2 = s.b; _3 = _1 | 1; t.a = _3; _4 = _2 | 2; t.b = _4;\n+     or\n+     _1 = s.a; _2 = s.b; t.a = _1; t.b = _2;\n+     and we can emit the coalesced load next to any of those loads.  */\n+  if (gimple_vuse (infof->ops[idx].stmt) == load_vuse\n+      && gimple_vuse (infol->ops[idx].stmt) == load_vuse)\n+    return true;\n+\n+  /* Otherwise, at least for now require that the load has the same\n+     vuse as the store.  See following examples.  */\n+  if (gimple_vuse (info->stmt) != load_vuse)\n+    return false;\n+\n+  if (gimple_vuse (infof->stmt) != gimple_vuse (infof->ops[idx].stmt)\n+      || (infof != infol\n+\t  && gimple_vuse (infol->stmt) != gimple_vuse (infol->ops[idx].stmt)))\n+    return false;\n+\n+  /* If the load is from the same location as the store, already\n+     the construction of the immediate chain info guarantees no intervening\n+     stores, so no further checks are needed.  Example:\n+     _1 = s.a; _2 = _1 & -7; s.a = _2; _3 = s.b; _4 = _3 & -7; s.b = _4;  */\n+  if (info->ops[idx].bitpos == info->bitpos\n+      && operand_equal_p (info->ops[idx].base_addr, base_addr, 0))\n+    return true;\n+\n+  /* Otherwise, we need to punt if any of the loads can be clobbered by any\n+     of the stores in the group, or any other stores in between those.\n+     Previous calls to compatible_load_p ensured that for all the\n+     merged_store->stores IDX loads, no stmts starting with\n+     merged_store->first_stmt and ending right before merged_store->last_stmt\n+     clobbers those loads.  */\n+  gimple *first = merged_store->first_stmt;\n+  gimple *last = merged_store->last_stmt;\n+  unsigned int i;\n+  store_immediate_info *infoc;\n+  /* The stores are sorted by increasing store bitpos, so if info->stmt store\n+     comes before the so far first load, we'll be changing\n+     merged_store->first_stmt.  In that case we need to give up if\n+     any of the earlier processed loads clobber with the stmts in the new\n+     range.  */\n+  if (info->order < merged_store->first_order)\n+    {\n+      FOR_EACH_VEC_ELT (merged_store->stores, i, infoc)\n+\tif (stmts_may_clobber_ref_p (info->stmt, first, infoc->ops[idx].val))\n+\t  return false;\n+      first = info->stmt;\n+    }\n+  /* Similarly, we could change merged_store->last_stmt, so ensure\n+     in that case no stmts in the new range clobber any of the earlier\n+     processed loads.  */\n+  else if (info->order > merged_store->last_order)\n+    {\n+      FOR_EACH_VEC_ELT (merged_store->stores, i, infoc)\n+\tif (stmts_may_clobber_ref_p (last, info->stmt, infoc->ops[idx].val))\n+\t  return false;\n+      last = info->stmt;\n+    }\n+  /* And finally, we'd be adding a new load to the set, ensure it isn't\n+     clobbered in the new range.  */\n+  if (stmts_may_clobber_ref_p (first, last, info->ops[idx].val))\n+    return false;\n+\n+  /* Otherwise, we are looking for:\n+     _1 = s.a; _2 = _1 ^ 15; t.a = _2; _3 = s.b; _4 = _3 ^ 15; t.b = _4;\n+     or\n+     _1 = s.a; t.a = _1; _2 = s.b; t.b = _2;  */\n+  return true;\n+}\n+\n /* Go through the candidate stores recorded in m_store_info and merge them\n    into merged_store_group objects recorded into m_merged_store_groups\n    representing the widened stores.  Return true if coalescing was successful\n@@ -967,32 +1179,56 @@ imm_store_chain_info::coalesce_immediate_stores ()\n       if (IN_RANGE (start, merged_store->start,\n \t\t    merged_store->start + merged_store->width - 1))\n \t{\n-\t  merged_store->merge_overlapping (info);\n-\t  continue;\n+\t  /* Only allow overlapping stores of constants.  */\n+\t  if (info->rhs_code == INTEGER_CST\n+\t      && merged_store->stores[0]->rhs_code == INTEGER_CST)\n+\t    {\n+\t      merged_store->merge_overlapping (info);\n+\t      continue;\n+\t    }\n \t}\n-\n-      /* |---store 1---| <gap> |---store 2---|.\n-\t Gap between stores.  Start a new group if there are any gaps\n-\t between bitregions.  */\n-      if (info->bitregion_start > merged_store->bitregion_end)\n+      /* |---store 1---||---store 2---|\n+\t This store is consecutive to the previous one.\n+\t Merge it into the current store group.  There can be gaps in between\n+\t the stores, but there can't be gaps in between bitregions.  */\n+      else if (info->bitregion_start <= merged_store->bitregion_end\n+\t       && info->rhs_code == merged_store->stores[0]->rhs_code)\n \t{\n-\t  /* Try to apply all the stores recorded for the group to determine\n-\t     the bitpattern they write and discard it if that fails.\n-\t     This will also reject single-store groups.  */\n-\t  if (!merged_store->apply_stores ())\n-\t    delete merged_store;\n-\t  else\n-\t    m_merged_store_groups.safe_push (merged_store);\n+\t  store_immediate_info *infof = merged_store->stores[0];\n+\n+\t  /* All the rhs_code ops that take 2 operands are commutative,\n+\t     swap the operands if it could make the operands compatible.  */\n+\t  if (infof->ops[0].base_addr\n+\t      && infof->ops[1].base_addr\n+\t      && info->ops[0].base_addr\n+\t      && info->ops[1].base_addr\n+\t      && (info->ops[1].bitpos - infof->ops[0].bitpos\n+\t\t  == info->bitpos - infof->bitpos)\n+\t      && operand_equal_p (info->ops[1].base_addr,\n+\t\t\t\t  infof->ops[0].base_addr, 0))\n+\t    std::swap (info->ops[0], info->ops[1]);\n+\t  if ((!infof->ops[0].base_addr\n+\t       || compatible_load_p (merged_store, info, base_addr, 0))\n+\t      && (!infof->ops[1].base_addr\n+\t\t  || compatible_load_p (merged_store, info, base_addr, 1)))\n+\t    {\n+\t      merged_store->merge_into (info);\n+\t      continue;\n+\t    }\n+\t}\n \n-\t  merged_store = new merged_store_group (info);\n+      /* |---store 1---| <gap> |---store 2---|.\n+\t Gap between stores or the rhs not compatible.  Start a new group.  */\n \n-\t  continue;\n-\t}\n+      /* Try to apply all the stores recorded for the group to determine\n+\t the bitpattern they write and discard it if that fails.\n+\t This will also reject single-store groups.  */\n+      if (!merged_store->apply_stores ())\n+\tdelete merged_store;\n+      else\n+\tm_merged_store_groups.safe_push (merged_store);\n \n-      /* |---store 1---||---store 2---|\n-\t This store is consecutive to the previous one.\n-\t Merge it into the current store group.  */\n-       merged_store->merge_into (info);\n+      merged_store = new merged_store_group (info);\n     }\n \n   /* Record or discard the last store group.  */\n@@ -1014,35 +1250,57 @@ imm_store_chain_info::coalesce_immediate_stores ()\n   return success;\n }\n \n-/* Return the type to use for the merged stores described by STMTS.\n-   This is needed to get the alias sets right.  */\n+/* Return the type to use for the merged stores or loads described by STMTS.\n+   This is needed to get the alias sets right.  If IS_LOAD, look for rhs,\n+   otherwise lhs.  Additionally set *CLIQUEP and *BASEP to MR_DEPENDENCE_*\n+   of the MEM_REFs if any.  */\n \n static tree\n-get_alias_type_for_stmts (auto_vec<gimple *> &stmts)\n+get_alias_type_for_stmts (vec<gimple *> &stmts, bool is_load,\n+\t\t\t  unsigned short *cliquep, unsigned short *basep)\n {\n   gimple *stmt;\n   unsigned int i;\n-  tree lhs = gimple_assign_lhs (stmts[0]);\n-  tree type = reference_alias_ptr_type (lhs);\n+  tree type = NULL_TREE;\n+  tree ret = NULL_TREE;\n+  *cliquep = 0;\n+  *basep = 0;\n \n   FOR_EACH_VEC_ELT (stmts, i, stmt)\n     {\n-      if (i == 0)\n-\tcontinue;\n+      tree ref = is_load ? gimple_assign_rhs1 (stmt)\n+\t\t\t : gimple_assign_lhs (stmt);\n+      tree type1 = reference_alias_ptr_type (ref);\n+      tree base = get_base_address (ref);\n \n-      lhs = gimple_assign_lhs (stmt);\n-      tree type1 = reference_alias_ptr_type (lhs);\n+      if (i == 0)\n+\t{\n+\t  if (TREE_CODE (base) == MEM_REF)\n+\t    {\n+\t      *cliquep = MR_DEPENDENCE_CLIQUE (base);\n+\t      *basep = MR_DEPENDENCE_BASE (base);\n+\t    }\n+\t  ret = type = type1;\n+\t  continue;\n+\t}\n       if (!alias_ptr_types_compatible_p (type, type1))\n-\treturn ptr_type_node;\n+\tret = ptr_type_node;\n+      if (TREE_CODE (base) != MEM_REF\n+\t  || *cliquep != MR_DEPENDENCE_CLIQUE (base)\n+\t  || *basep != MR_DEPENDENCE_BASE (base))\n+\t{\n+\t  *cliquep = 0;\n+\t  *basep = 0;\n+\t}\n     }\n-  return type;\n+  return ret;\n }\n \n /* Return the location_t information we can find among the statements\n    in STMTS.  */\n \n static location_t\n-get_location_for_stmts (auto_vec<gimple *> &stmts)\n+get_location_for_stmts (vec<gimple *> &stmts)\n {\n   gimple *stmt;\n   unsigned int i;\n@@ -1062,7 +1320,7 @@ struct split_store\n   unsigned HOST_WIDE_INT bytepos;\n   unsigned HOST_WIDE_INT size;\n   unsigned HOST_WIDE_INT align;\n-  auto_vec<gimple *> orig_stmts;\n+  auto_vec<store_immediate_info *> orig_stores;\n   /* True if there is a single orig stmt covering the whole split store.  */\n   bool orig;\n   split_store (unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n@@ -1076,21 +1334,20 @@ split_store::split_store (unsigned HOST_WIDE_INT bp,\n \t\t\t  unsigned HOST_WIDE_INT al)\n \t\t\t  : bytepos (bp), size (sz), align (al), orig (false)\n {\n-  orig_stmts.create (0);\n+  orig_stores.create (0);\n }\n \n-/* Record all statements corresponding to stores in GROUP that write to\n-   the region starting at BITPOS and is of size BITSIZE.  Record such\n-   statements in STMTS if non-NULL.  The stores in GROUP must be sorted by\n-   bitposition.  Return INFO if there is exactly one original store\n-   in the range.  */\n+/* Record all stores in GROUP that write to the region starting at BITPOS and\n+   is of size BITSIZE.  Record infos for such statements in STORES if\n+   non-NULL.  The stores in GROUP must be sorted by bitposition.  Return INFO\n+   if there is exactly one original store in the range.  */\n \n static store_immediate_info *\n-find_constituent_stmts (struct merged_store_group *group,\n-\t\t\tvec<gimple *> *stmts,\n-\t\t\tunsigned int *first,\n-\t\t\tunsigned HOST_WIDE_INT bitpos,\n-\t\t\tunsigned HOST_WIDE_INT bitsize)\n+find_constituent_stores (struct merged_store_group *group,\n+\t\t\t vec<store_immediate_info *> *stores,\n+\t\t\t unsigned int *first,\n+\t\t\t unsigned HOST_WIDE_INT bitpos,\n+\t\t\t unsigned HOST_WIDE_INT bitsize)\n {\n   store_immediate_info *info, *ret = NULL;\n   unsigned int i;\n@@ -1119,9 +1376,9 @@ find_constituent_stmts (struct merged_store_group *group,\n       if (stmt_start >= end)\n \treturn ret;\n \n-      if (stmts)\n+      if (stores)\n \t{\n-\t  stmts->safe_push (info->stmt);\n+\t  stores->safe_push (info);\n \t  if (ret)\n \t    {\n \t      ret = NULL;\n@@ -1143,28 +1400,37 @@ find_constituent_stmts (struct merged_store_group *group,\n    This is to separate the splitting strategy from the statement\n    building/emission/linking done in output_merged_store.\n    Return number of new stores.\n+   If ALLOW_UNALIGNED_STORE is false, then all stores must be aligned.\n+   If ALLOW_UNALIGNED_LOAD is false, then all loads must be aligned.\n    If SPLIT_STORES is NULL, it is just a dry run to count number of\n    new stores.  */\n \n static unsigned int\n-split_group (merged_store_group *group, bool allow_unaligned,\n+split_group (merged_store_group *group, bool allow_unaligned_store,\n+\t     bool allow_unaligned_load,\n \t     vec<struct split_store *> *split_stores)\n {\n   unsigned HOST_WIDE_INT pos = group->bitregion_start;\n   unsigned HOST_WIDE_INT size = group->bitregion_end - pos;\n   unsigned HOST_WIDE_INT bytepos = pos / BITS_PER_UNIT;\n   unsigned HOST_WIDE_INT group_align = group->align;\n   unsigned HOST_WIDE_INT align_base = group->align_base;\n+  unsigned HOST_WIDE_INT group_load_align = group_align;\n \n   gcc_assert ((size % BITS_PER_UNIT == 0) && (pos % BITS_PER_UNIT == 0));\n \n   unsigned int ret = 0, first = 0;\n   unsigned HOST_WIDE_INT try_pos = bytepos;\n   group->stores.qsort (sort_by_bitpos);\n \n+  if (!allow_unaligned_load)\n+    for (int i = 0; i < 2; ++i)\n+      if (group->load_align[i])\n+\tgroup_load_align = MIN (group_load_align, group->load_align[i]);\n+\n   while (size > 0)\n     {\n-      if ((allow_unaligned || group_align <= BITS_PER_UNIT)\n+      if ((allow_unaligned_store || group_align <= BITS_PER_UNIT)\n \t  && group->mask[try_pos - bytepos] == (unsigned char) ~0U)\n \t{\n \t  /* Skip padding bytes.  */\n@@ -1180,19 +1446,43 @@ split_group (merged_store_group *group, bool allow_unaligned,\n       unsigned HOST_WIDE_INT align = group_align;\n       if (align_bitpos)\n \talign = least_bit_hwi (align_bitpos);\n-      if (!allow_unaligned)\n+      if (!allow_unaligned_store)\n \ttry_size = MIN (try_size, align);\n+      if (!allow_unaligned_load)\n+\t{\n+\t  /* If we can't do or don't want to do unaligned stores\n+\t     as well as loads, we need to take the loads into account\n+\t     as well.  */\n+\t  unsigned HOST_WIDE_INT load_align = group_load_align;\n+\t  align_bitpos = (try_bitpos - align_base) & (load_align - 1);\n+\t  if (align_bitpos)\n+\t    load_align = least_bit_hwi (align_bitpos);\n+\t  for (int i = 0; i < 2; ++i)\n+\t    if (group->load_align[i])\n+\t      {\n+\t\talign_bitpos = try_bitpos - group->stores[0]->bitpos;\n+\t\talign_bitpos += group->stores[0]->ops[i].bitpos;\n+\t\talign_bitpos -= group->load_align_base[i];\n+\t\talign_bitpos &= (group_load_align - 1);\n+\t\tif (align_bitpos)\n+\t\t  {\n+\t\t    unsigned HOST_WIDE_INT a = least_bit_hwi (align_bitpos);\n+\t\t    load_align = MIN (load_align, a);\n+\t\t  }\n+\t      }\n+\t  try_size = MIN (try_size, load_align);\n+\t}\n       store_immediate_info *info\n-\t= find_constituent_stmts (group, NULL, &first, try_bitpos, try_size);\n+\t= find_constituent_stores (group, NULL, &first, try_bitpos, try_size);\n       if (info)\n \t{\n \t  /* If there is just one original statement for the range, see if\n \t     we can just reuse the original store which could be even larger\n \t     than try_size.  */\n \t  unsigned HOST_WIDE_INT stmt_end\n \t    = ROUND_UP (info->bitpos + info->bitsize, BITS_PER_UNIT);\n-\t  info = find_constituent_stmts (group, NULL, &first, try_bitpos,\n-\t\t\t\t\t stmt_end - try_bitpos);\n+\t  info = find_constituent_stores (group, NULL, &first, try_bitpos,\n+\t\t\t\t\t  stmt_end - try_bitpos);\n \t  if (info && info->bitpos >= try_bitpos)\n \t    {\n \t      try_size = stmt_end - try_bitpos;\n@@ -1221,7 +1511,7 @@ split_group (merged_store_group *group, bool allow_unaligned,\n       nonmasked *= BITS_PER_UNIT;\n       while (nonmasked <= try_size / 2)\n \ttry_size /= 2;\n-      if (!allow_unaligned && group_align > BITS_PER_UNIT)\n+      if (!allow_unaligned_store && group_align > BITS_PER_UNIT)\n \t{\n \t  /* Now look for whole padding bytes at the start of that bitsize.  */\n \t  unsigned int try_bytesize = try_size / BITS_PER_UNIT, masked;\n@@ -1252,8 +1542,8 @@ split_group (merged_store_group *group, bool allow_unaligned,\n \t{\n \t  struct split_store *store\n \t    = new split_store (try_pos, try_size, align);\n-\t  info = find_constituent_stmts (group, &store->orig_stmts,\n-\t  \t\t\t\t &first, try_bitpos, try_size);\n+\t  info = find_constituent_stores (group, &store->orig_stores,\n+\t\t\t\t\t  &first, try_bitpos, try_size);\n \t  if (info\n \t      && info->bitpos >= try_bitpos\n \t      && info->bitpos + info->bitsize <= try_bitpos + try_size)\n@@ -1288,19 +1578,23 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \n   auto_vec<struct split_store *, 32> split_stores;\n   split_stores.create (0);\n-  bool allow_unaligned\n+  bool allow_unaligned_store\n     = !STRICT_ALIGNMENT && PARAM_VALUE (PARAM_STORE_MERGING_ALLOW_UNALIGNED);\n-  if (allow_unaligned)\n+  bool allow_unaligned_load = allow_unaligned_store;\n+  if (allow_unaligned_store)\n     {\n       /* If unaligned stores are allowed, see how many stores we'd emit\n \t for unaligned and how many stores we'd emit for aligned stores.\n \t Only use unaligned stores if it allows fewer stores than aligned.  */\n-      unsigned aligned_cnt = split_group (group, false, NULL);\n-      unsigned unaligned_cnt = split_group (group, true, NULL);\n+      unsigned aligned_cnt\n+\t= split_group (group, false, allow_unaligned_load, NULL);\n+      unsigned unaligned_cnt\n+\t= split_group (group, true, allow_unaligned_load, NULL);\n       if (aligned_cnt <= unaligned_cnt)\n-\tallow_unaligned = false;\n+\tallow_unaligned_store = false;\n     }\n-  split_group (group, allow_unaligned, &split_stores);\n+  split_group (group, allow_unaligned_store, allow_unaligned_load,\n+\t       &split_stores);\n \n   if (split_stores.length () >= orig_num_stmts)\n     {\n@@ -1323,9 +1617,37 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n   gimple *stmt = NULL;\n   split_store *split_store;\n   unsigned int i;\n-\n+  auto_vec<gimple *, 32> orig_stmts;\n   tree addr = force_gimple_operand_1 (unshare_expr (base_addr), &seq,\n \t\t\t\t      is_gimple_mem_ref_addr, NULL_TREE);\n+\n+  tree load_addr[2] = { NULL_TREE, NULL_TREE };\n+  gimple_seq load_seq[2] = { NULL, NULL };\n+  gimple_stmt_iterator load_gsi[2] = { gsi_none (), gsi_none () };\n+  for (int j = 0; j < 2; ++j)\n+    {\n+      store_operand_info &op = group->stores[0]->ops[j];\n+      if (op.base_addr == NULL_TREE)\n+\tcontinue;\n+\n+      store_immediate_info *infol = group->stores.last ();\n+      if (gimple_vuse (op.stmt) == gimple_vuse (infol->ops[j].stmt))\n+\t{\n+\t  load_gsi[j] = gsi_for_stmt (op.stmt);\n+\t  load_addr[j]\n+\t    = force_gimple_operand_1 (unshare_expr (op.base_addr),\n+\t\t\t\t      &load_seq[j], is_gimple_mem_ref_addr,\n+\t\t\t\t      NULL_TREE);\n+\t}\n+      else if (operand_equal_p (base_addr, op.base_addr, 0))\n+\tload_addr[j] = addr;\n+      else\n+\tload_addr[j]\n+\t  = force_gimple_operand_1 (unshare_expr (op.base_addr),\n+\t\t\t\t    &seq, is_gimple_mem_ref_addr,\n+\t\t\t\t    NULL_TREE);\n+    }\n+\n   FOR_EACH_VEC_ELT (split_stores, i, split_store)\n     {\n       unsigned HOST_WIDE_INT try_size = split_store->size;\n@@ -1337,27 +1659,144 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \t{\n \t  /* If there is just a single constituent store which covers\n \t     the whole area, just reuse the lhs and rhs.  */\n-\t  dest = gimple_assign_lhs (split_store->orig_stmts[0]);\n-\t  src = gimple_assign_rhs1 (split_store->orig_stmts[0]);\n-\t  loc = gimple_location (split_store->orig_stmts[0]);\n+\t  gimple *orig_stmt = split_store->orig_stores[0]->stmt;\n+\t  dest = gimple_assign_lhs (orig_stmt);\n+\t  src = gimple_assign_rhs1 (orig_stmt);\n+\t  loc = gimple_location (orig_stmt);\n \t}\n       else\n \t{\n+\t  store_immediate_info *info;\n+\t  unsigned short clique, base;\n+\t  unsigned int k;\n+\t  FOR_EACH_VEC_ELT (split_store->orig_stores, k, info)\n+\t    orig_stmts.safe_push (info->stmt);\n \t  tree offset_type\n-\t    = get_alias_type_for_stmts (split_store->orig_stmts);\n-\t  loc = get_location_for_stmts (split_store->orig_stmts);\n+\t    = get_alias_type_for_stmts (orig_stmts, false, &clique, &base);\n+\t  loc = get_location_for_stmts (orig_stmts);\n+\t  orig_stmts.truncate (0);\n \n \t  tree int_type = build_nonstandard_integer_type (try_size, UNSIGNED);\n \t  int_type = build_aligned_type (int_type, align);\n \t  dest = fold_build2 (MEM_REF, int_type, addr,\n \t\t\t      build_int_cst (offset_type, try_pos));\n-\t  src = native_interpret_expr (int_type,\n-\t\t\t\t       group->val + try_pos - start_byte_pos,\n-\t\t\t\t       group->buf_size);\n+\t  if (TREE_CODE (dest) == MEM_REF)\n+\t    {\n+\t      MR_DEPENDENCE_CLIQUE (dest) = clique;\n+\t      MR_DEPENDENCE_BASE (dest) = base;\n+\t    }\n+\n \t  tree mask\n \t    = native_interpret_expr (int_type,\n \t\t\t\t     group->mask + try_pos - start_byte_pos,\n \t\t\t\t     group->buf_size);\n+\n+\t  tree ops[2];\n+\t  for (int j = 0;\n+\t       j < 1 + (split_store->orig_stores[0]->ops[1].val != NULL_TREE);\n+\t       ++j)\n+\t    {\n+\t      store_operand_info &op = split_store->orig_stores[0]->ops[j];\n+\t      if (op.base_addr)\n+\t\t{\n+\t\t  FOR_EACH_VEC_ELT (split_store->orig_stores, k, info)\n+\t\t    orig_stmts.safe_push (info->ops[j].stmt);\n+\n+\t\t  offset_type = get_alias_type_for_stmts (orig_stmts, true,\n+\t\t\t\t\t\t\t  &clique, &base);\n+\t\t  location_t load_loc = get_location_for_stmts (orig_stmts);\n+\t\t  orig_stmts.truncate (0);\n+\n+\t\t  unsigned HOST_WIDE_INT load_align = group->load_align[j];\n+\t\t  unsigned HOST_WIDE_INT align_bitpos\n+\t\t    = (try_pos * BITS_PER_UNIT\n+\t\t       - split_store->orig_stores[0]->bitpos\n+\t\t       + op.bitpos) & (load_align - 1);\n+\t\t  if (align_bitpos)\n+\t\t    load_align = least_bit_hwi (align_bitpos);\n+\n+\t\t  tree load_int_type\n+\t\t    = build_nonstandard_integer_type (try_size, UNSIGNED);\n+\t\t  load_int_type\n+\t\t    = build_aligned_type (load_int_type, load_align);\n+\n+\t\t  unsigned HOST_WIDE_INT load_pos\n+\t\t    = (try_pos * BITS_PER_UNIT\n+\t\t       - split_store->orig_stores[0]->bitpos\n+\t\t       + op.bitpos) / BITS_PER_UNIT;\n+\t\t  ops[j] = fold_build2 (MEM_REF, load_int_type, load_addr[j],\n+\t\t\t\t\tbuild_int_cst (offset_type, load_pos));\n+\t\t  if (TREE_CODE (ops[j]) == MEM_REF)\n+\t\t    {\n+\t\t      MR_DEPENDENCE_CLIQUE (ops[j]) = clique;\n+\t\t      MR_DEPENDENCE_BASE (ops[j]) = base;\n+\t\t    }\n+\t\t  if (!integer_zerop (mask))\n+\t\t    /* The load might load some bits (that will be masked off\n+\t\t       later on) uninitialized, avoid -W*uninitialized\n+\t\t       warnings in that case.  */\n+\t\t    TREE_NO_WARNING (ops[j]) = 1;\n+\n+\t\t  stmt = gimple_build_assign (make_ssa_name (int_type),\n+\t\t\t\t\t      ops[j]);\n+\t\t  gimple_set_location (stmt, load_loc);\n+\t\t  if (gsi_bb (load_gsi[j]))\n+\t\t    {\n+\t\t      gimple_set_vuse (stmt, gimple_vuse (op.stmt));\n+\t\t      gimple_seq_add_stmt_without_update (&load_seq[j], stmt);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      gimple_set_vuse (stmt, new_vuse);\n+\t\t      gimple_seq_add_stmt_without_update (&seq, stmt);\n+\t\t    }\n+\t\t  ops[j] = gimple_assign_lhs (stmt);\n+\t\t}\n+\t      else\n+\t\tops[j] = native_interpret_expr (int_type,\n+\t\t\t\t\t\tgroup->val + try_pos\n+\t\t\t\t\t\t- start_byte_pos,\n+\t\t\t\t\t\tgroup->buf_size);\n+\t    }\n+\n+\t  switch (split_store->orig_stores[0]->rhs_code)\n+\t    {\n+\t    case BIT_AND_EXPR:\n+\t    case BIT_IOR_EXPR:\n+\t    case BIT_XOR_EXPR:\n+\t      FOR_EACH_VEC_ELT (split_store->orig_stores, k, info)\n+\t\t{\n+\t\t  tree rhs1 = gimple_assign_rhs1 (info->stmt);\n+\t\t  orig_stmts.safe_push (SSA_NAME_DEF_STMT (rhs1));\n+\t\t}\n+\t      location_t bit_loc;\n+\t      bit_loc = get_location_for_stmts (orig_stmts);\n+\t      orig_stmts.truncate (0);\n+\n+\t      stmt\n+\t\t= gimple_build_assign (make_ssa_name (int_type),\n+\t\t\t\t       split_store->orig_stores[0]->rhs_code,\n+\t\t\t\t       ops[0], ops[1]);\n+\t      gimple_set_location (stmt, bit_loc);\n+\t      /* If there is just one load and there is a separate\n+\t\t load_seq[0], emit the bitwise op right after it.  */\n+\t      if (load_addr[1] == NULL_TREE && gsi_bb (load_gsi[0]))\n+\t\tgimple_seq_add_stmt_without_update (&load_seq[0], stmt);\n+\t      /* Otherwise, if at least one load is in seq, we need to\n+\t\t emit the bitwise op right before the store.  If there\n+\t\t are two loads and are emitted somewhere else, it would\n+\t\t be better to emit the bitwise op as early as possible;\n+\t\t we don't track where that would be possible right now\n+\t\t though.  */\n+\t      else\n+\t\tgimple_seq_add_stmt_without_update (&seq, stmt);\n+\t      src = gimple_assign_lhs (stmt);\n+\t      break;\n+\t    default:\n+\t      src = ops[0];\n+\t      break;\n+\t    }\n+\n \t  if (!integer_zerop (mask))\n \t    {\n \t      tree tem = make_ssa_name (int_type);\n@@ -1382,9 +1821,21 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \t      gimple_seq_add_stmt_without_update (&seq, stmt);\n \t      tem = gimple_assign_lhs (stmt);\n \n-\t      src = wide_int_to_tree (int_type,\n-\t\t\t\t      wi::bit_and_not (wi::to_wide (src),\n-\t\t\t\t\t\t       wi::to_wide (mask)));\n+\t      if (TREE_CODE (src) == INTEGER_CST)\n+\t\tsrc = wide_int_to_tree (int_type,\n+\t\t\t\t\twi::bit_and_not (wi::to_wide (src),\n+\t\t\t\t\t\t\t wi::to_wide (mask)));\n+\t      else\n+\t\t{\n+\t\t  tree nmask\n+\t\t    = wide_int_to_tree (int_type,\n+\t\t\t\t\twi::bit_not (wi::to_wide (mask)));\n+\t\t  stmt = gimple_build_assign (make_ssa_name (int_type),\n+\t\t\t\t\t      BIT_AND_EXPR, src, nmask);\n+\t\t  gimple_set_location (stmt, loc);\n+\t\t  gimple_seq_add_stmt_without_update (&seq, stmt);\n+\t\t  src = gimple_assign_lhs (stmt);\n+\t\t}\n \t      stmt = gimple_build_assign (make_ssa_name (int_type),\n \t\t\t\t\t  BIT_IOR_EXPR, tem, src);\n \t      gimple_set_location (stmt, loc);\n@@ -1422,6 +1873,9 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \tprint_gimple_seq (dump_file, seq, 0, TDF_VOPS | TDF_MEMSYMS);\n     }\n   gsi_insert_seq_after (&last_gsi, seq, GSI_SAME_STMT);\n+  for (int j = 0; j < 2; ++j)\n+    if (load_seq[j])\n+      gsi_insert_seq_after (&load_gsi[j], load_seq[j], GSI_SAME_STMT);\n \n   return true;\n }\n@@ -1520,10 +1974,290 @@ rhs_valid_for_store_merging_p (tree rhs)\n \t\t\t     GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (rhs)))) != 0;\n }\n \n+/* If MEM is a memory reference usable for store merging (either as\n+   store destination or for loads), return the non-NULL base_addr\n+   and set *PBITSIZE, *PBITPOS, *PBITREGION_START and *PBITREGION_END.\n+   Otherwise return NULL, *PBITPOS should be still valid even for that\n+   case.  */\n+\n+static tree\n+mem_valid_for_store_merging (tree mem, unsigned HOST_WIDE_INT *pbitsize,\n+\t\t\t     unsigned HOST_WIDE_INT *pbitpos,\n+\t\t\t     unsigned HOST_WIDE_INT *pbitregion_start,\n+\t\t\t     unsigned HOST_WIDE_INT *pbitregion_end)\n+{\n+  HOST_WIDE_INT bitsize;\n+  HOST_WIDE_INT bitpos;\n+  unsigned HOST_WIDE_INT bitregion_start = 0;\n+  unsigned HOST_WIDE_INT bitregion_end = 0;\n+  machine_mode mode;\n+  int unsignedp = 0, reversep = 0, volatilep = 0;\n+  tree offset;\n+  tree base_addr = get_inner_reference (mem, &bitsize, &bitpos, &offset, &mode,\n+\t\t\t\t\t&unsignedp, &reversep, &volatilep);\n+  *pbitsize = bitsize;\n+  if (bitsize == 0)\n+    return NULL_TREE;\n+\n+  if (TREE_CODE (mem) == COMPONENT_REF\n+      && DECL_BIT_FIELD_TYPE (TREE_OPERAND (mem, 1)))\n+    {\n+      get_bit_range (&bitregion_start, &bitregion_end, mem, &bitpos, &offset);\n+      if (bitregion_end)\n+\t++bitregion_end;\n+    }\n+\n+  if (reversep)\n+    return NULL_TREE;\n+\n+  /* We do not want to rewrite TARGET_MEM_REFs.  */\n+  if (TREE_CODE (base_addr) == TARGET_MEM_REF)\n+    return NULL_TREE;\n+  /* In some cases get_inner_reference may return a\n+     MEM_REF [ptr + byteoffset].  For the purposes of this pass\n+     canonicalize the base_addr to MEM_REF [ptr] and take\n+     byteoffset into account in the bitpos.  This occurs in\n+     PR 23684 and this way we can catch more chains.  */\n+  else if (TREE_CODE (base_addr) == MEM_REF)\n+    {\n+      offset_int bit_off, byte_off = mem_ref_offset (base_addr);\n+      bit_off = byte_off << LOG2_BITS_PER_UNIT;\n+      bit_off += bitpos;\n+      if (!wi::neg_p (bit_off) && wi::fits_shwi_p (bit_off))\n+\t{\n+\t  bitpos = bit_off.to_shwi ();\n+\t  if (bitregion_end)\n+\t    {\n+\t      bit_off = byte_off << LOG2_BITS_PER_UNIT;\n+\t      bit_off += bitregion_start;\n+\t      if (wi::fits_uhwi_p (bit_off))\n+\t\t{\n+\t\t  bitregion_start = bit_off.to_uhwi ();\n+\t\t  bit_off = byte_off << LOG2_BITS_PER_UNIT;\n+\t\t  bit_off += bitregion_end;\n+\t\t  if (wi::fits_uhwi_p (bit_off))\n+\t\t    bitregion_end = bit_off.to_uhwi ();\n+\t\t  else\n+\t\t    bitregion_end = 0;\n+\t\t}\n+\t      else\n+\t\tbitregion_end = 0;\n+\t    }\n+\t}\n+      else\n+\treturn NULL_TREE;\n+      base_addr = TREE_OPERAND (base_addr, 0);\n+    }\n+  /* get_inner_reference returns the base object, get at its\n+     address now.  */\n+  else\n+    {\n+      if (bitpos < 0)\n+\treturn NULL_TREE;\n+      base_addr = build_fold_addr_expr (base_addr);\n+    }\n+\n+  if (!bitregion_end)\n+    {\n+      bitregion_start = ROUND_DOWN (bitpos, BITS_PER_UNIT);\n+      bitregion_end = ROUND_UP (bitpos + bitsize, BITS_PER_UNIT);\n+    }\n+\n+  if (offset != NULL_TREE)\n+    {\n+      /* If the access is variable offset then a base decl has to be\n+\t address-taken to be able to emit pointer-based stores to it.\n+\t ???  We might be able to get away with re-using the original\n+\t base up to the first variable part and then wrapping that inside\n+\t a BIT_FIELD_REF.  */\n+      tree base = get_base_address (base_addr);\n+      if (! base\n+\t  || (DECL_P (base) && ! TREE_ADDRESSABLE (base)))\n+\treturn NULL_TREE;\n+\n+      base_addr = build2 (POINTER_PLUS_EXPR, TREE_TYPE (base_addr),\n+\t\t\t  base_addr, offset);\n+    }\n+\n+  *pbitsize = bitsize;\n+  *pbitpos = bitpos;\n+  *pbitregion_start = bitregion_start;\n+  *pbitregion_end = bitregion_end;\n+  return base_addr;\n+}\n+\n+/* Return true if STMT is a load that can be used for store merging.\n+   In that case fill in *OP.  BITSIZE, BITPOS, BITREGION_START and\n+   BITREGION_END are properties of the corresponding store.  */\n+\n+static bool\n+handled_load (gimple *stmt, store_operand_info *op,\n+\t      unsigned HOST_WIDE_INT bitsize, unsigned HOST_WIDE_INT bitpos,\n+\t      unsigned HOST_WIDE_INT bitregion_start,\n+\t      unsigned HOST_WIDE_INT bitregion_end)\n+{\n+  if (!is_gimple_assign (stmt) || !gimple_vuse (stmt))\n+    return false;\n+  if (gimple_assign_load_p (stmt)\n+      && !stmt_can_throw_internal (stmt)\n+      && !gimple_has_volatile_ops (stmt))\n+    {\n+      tree mem = gimple_assign_rhs1 (stmt);\n+      op->base_addr\n+\t= mem_valid_for_store_merging (mem, &op->bitsize, &op->bitpos,\n+\t\t\t\t       &op->bitregion_start,\n+\t\t\t\t       &op->bitregion_end);\n+      if (op->base_addr != NULL_TREE\n+\t  && op->bitsize == bitsize\n+\t  && ((op->bitpos - bitpos) % BITS_PER_UNIT) == 0\n+\t  && op->bitpos - op->bitregion_start >= bitpos - bitregion_start\n+\t  && op->bitregion_end - op->bitpos >= bitregion_end - bitpos)\n+\t{\n+\t  op->stmt = stmt;\n+\t  op->val = mem;\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+/* Record the store STMT for store merging optimization if it can be\n+   optimized.  */\n+\n+void\n+pass_store_merging::process_store (gimple *stmt)\n+{\n+  tree lhs = gimple_assign_lhs (stmt);\n+  tree rhs = gimple_assign_rhs1 (stmt);\n+  unsigned HOST_WIDE_INT bitsize, bitpos;\n+  unsigned HOST_WIDE_INT bitregion_start;\n+  unsigned HOST_WIDE_INT bitregion_end;\n+  tree base_addr\n+    = mem_valid_for_store_merging (lhs, &bitsize, &bitpos,\n+\t\t\t\t   &bitregion_start, &bitregion_end);\n+  if (bitsize == 0)\n+    return;\n+\n+  bool invalid = (base_addr == NULL_TREE\n+\t\t  || ((bitsize > MAX_BITSIZE_MODE_ANY_INT)\n+\t\t       && (TREE_CODE (rhs) != INTEGER_CST)));\n+  enum tree_code rhs_code = ERROR_MARK;\n+  store_operand_info ops[2];\n+  if (invalid)\n+    ;\n+  else if (rhs_valid_for_store_merging_p (rhs))\n+    {\n+      rhs_code = INTEGER_CST;\n+      ops[0].val = rhs;\n+    }\n+  else if (TREE_CODE (rhs) != SSA_NAME || !has_single_use (rhs))\n+    invalid = true;\n+  else\n+    {\n+      gimple *def_stmt = SSA_NAME_DEF_STMT (rhs), *def_stmt1, *def_stmt2;\n+      if (!is_gimple_assign (def_stmt))\n+\tinvalid = true;\n+      else if (handled_load (def_stmt, &ops[0], bitsize, bitpos,\n+\t\t\t     bitregion_start, bitregion_end))\n+\trhs_code = MEM_REF;\n+      else\n+\tswitch ((rhs_code = gimple_assign_rhs_code (def_stmt)))\n+\t  {\n+\t  case BIT_AND_EXPR:\n+\t  case BIT_IOR_EXPR:\n+\t  case BIT_XOR_EXPR:\n+\t    tree rhs1, rhs2;\n+\t    rhs1 = gimple_assign_rhs1 (def_stmt);\n+\t    rhs2 = gimple_assign_rhs2 (def_stmt);\n+\t    invalid = true;\n+\t    if (TREE_CODE (rhs1) != SSA_NAME || !has_single_use (rhs1))\n+\t      break;\n+\t    def_stmt1 = SSA_NAME_DEF_STMT (rhs1);\n+\t    if (!is_gimple_assign (def_stmt1)\n+\t\t|| !handled_load (def_stmt1, &ops[0], bitsize, bitpos,\n+\t\t\t\t  bitregion_start, bitregion_end))\n+\t      break;\n+\t    if (rhs_valid_for_store_merging_p (rhs2))\n+\t      ops[1].val = rhs2;\n+\t    else if (TREE_CODE (rhs2) != SSA_NAME || !has_single_use (rhs2))\n+\t      break;\n+\t    else\n+\t      {\n+\t\tdef_stmt2 = SSA_NAME_DEF_STMT (rhs2);\n+\t\tif (!is_gimple_assign (def_stmt2))\n+\t\t  break;\n+\t\telse if (!handled_load (def_stmt2, &ops[1], bitsize, bitpos,\n+\t\t\t\t\tbitregion_start, bitregion_end))\n+\t\t  break;\n+\t      }\n+\t    invalid = false;\n+\t    break;\n+\t  default:\n+\t    invalid = true;\n+\t    break;\n+\t  }\n+    }\n+\n+  struct imm_store_chain_info **chain_info = NULL;\n+  if (base_addr)\n+    chain_info = m_stores.get (base_addr);\n+\n+  if (invalid)\n+    {\n+      terminate_all_aliasing_chains (chain_info, stmt);\n+      return;\n+    }\n+\n+  store_immediate_info *info;\n+  if (chain_info)\n+    {\n+      unsigned int ord = (*chain_info)->m_store_info.length ();\n+      info = new store_immediate_info (bitsize, bitpos, bitregion_start,\n+\t\t\t\t       bitregion_end, stmt, ord, rhs_code,\n+\t\t\t\t       ops[0], ops[1]);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Recording immediate store from stmt:\\n\");\n+\t  print_gimple_stmt (dump_file, stmt, 0);\n+\t}\n+      (*chain_info)->m_store_info.safe_push (info);\n+      /* If we reach the limit of stores to merge in a chain terminate and\n+\t process the chain now.  */\n+      if ((*chain_info)->m_store_info.length ()\n+\t  == (unsigned int) PARAM_VALUE (PARAM_MAX_STORES_TO_MERGE))\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file,\n+\t\t     \"Reached maximum number of statements to merge:\\n\");\n+\t  terminate_and_release_chain (*chain_info);\n+\t}\n+      return;\n+    }\n+\n+  /* Store aliases any existing chain?  */\n+  terminate_all_aliasing_chains (chain_info, stmt);\n+  /* Start a new chain.  */\n+  struct imm_store_chain_info *new_chain\n+    = new imm_store_chain_info (m_stores_head, base_addr);\n+  info = new store_immediate_info (bitsize, bitpos, bitregion_start,\n+\t\t\t\t   bitregion_end, stmt, 0, rhs_code,\n+\t\t\t\t   ops[0], ops[1]);\n+  new_chain->m_store_info.safe_push (info);\n+  m_stores.put (base_addr, new_chain);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Starting new chain with statement:\\n\");\n+      print_gimple_stmt (dump_file, stmt, 0);\n+      fprintf (dump_file, \"The base object is:\\n\");\n+      print_generic_expr (dump_file, base_addr);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+}\n+\n /* Entry point for the pass.  Go over each basic block recording chains of\n-  immediate stores.  Upon encountering a terminating statement (as defined\n-  by stmt_terminates_chain_p) process the recorded stores and emit the widened\n-  variants.  */\n+   immediate stores.  Upon encountering a terminating statement (as defined\n+   by stmt_terminates_chain_p) process the recorded stores and emit the widened\n+   variants.  */\n \n unsigned int\n pass_store_merging::execute (function *fun)\n@@ -1573,175 +2307,9 @@ pass_store_merging::execute (function *fun)\n \t  if (gimple_assign_single_p (stmt) && gimple_vdef (stmt)\n \t      && !stmt_can_throw_internal (stmt)\n \t      && lhs_valid_for_store_merging_p (gimple_assign_lhs (stmt)))\n-\t    {\n-\t      tree lhs = gimple_assign_lhs (stmt);\n-\t      tree rhs = gimple_assign_rhs1 (stmt);\n-\n-\t      HOST_WIDE_INT bitsize, bitpos;\n-\t      unsigned HOST_WIDE_INT bitregion_start = 0;\n-\t      unsigned HOST_WIDE_INT bitregion_end = 0;\n-\t      machine_mode mode;\n-\t      int unsignedp = 0, reversep = 0, volatilep = 0;\n-\t      tree offset, base_addr;\n-\t      base_addr\n-\t\t= get_inner_reference (lhs, &bitsize, &bitpos, &offset, &mode,\n-\t\t\t\t       &unsignedp, &reversep, &volatilep);\n-\t      if (TREE_CODE (lhs) == COMPONENT_REF\n-\t\t  && DECL_BIT_FIELD_TYPE (TREE_OPERAND (lhs, 1)))\n-\t\t{\n-\t\t  get_bit_range (&bitregion_start, &bitregion_end, lhs,\n-\t\t\t\t &bitpos, &offset);\n-\t\t  if (bitregion_end)\n-\t\t    ++bitregion_end;\n-\t\t}\n-\t      if (bitsize == 0)\n-\t\tcontinue;\n-\n-\t      /* As a future enhancement we could handle stores with the same\n-\t\t base and offset.  */\n-\t      bool invalid = reversep\n-\t\t\t     || ((bitsize > MAX_BITSIZE_MODE_ANY_INT)\n-\t\t\t\t  && (TREE_CODE (rhs) != INTEGER_CST))\n-\t\t\t     || !rhs_valid_for_store_merging_p (rhs);\n-\n-\t      /* We do not want to rewrite TARGET_MEM_REFs.  */\n-\t      if (TREE_CODE (base_addr) == TARGET_MEM_REF)\n-\t\tinvalid = true;\n-\t      /* In some cases get_inner_reference may return a\n-\t\t MEM_REF [ptr + byteoffset].  For the purposes of this pass\n-\t\t canonicalize the base_addr to MEM_REF [ptr] and take\n-\t\t byteoffset into account in the bitpos.  This occurs in\n-\t\t PR 23684 and this way we can catch more chains.  */\n-\t      else if (TREE_CODE (base_addr) == MEM_REF)\n-\t\t{\n-\t\t  offset_int bit_off, byte_off = mem_ref_offset (base_addr);\n-\t\t  bit_off = byte_off << LOG2_BITS_PER_UNIT;\n-\t\t  bit_off += bitpos;\n-\t\t  if (!wi::neg_p (bit_off) && wi::fits_shwi_p (bit_off))\n-\t\t    {\n-\t\t      bitpos = bit_off.to_shwi ();\n-\t\t      if (bitregion_end)\n-\t\t\t{\n-\t\t\t  bit_off = byte_off << LOG2_BITS_PER_UNIT;\n-\t\t\t  bit_off += bitregion_start;\n-\t\t\t  if (wi::fits_uhwi_p (bit_off))\n-\t\t\t    {\n-\t\t\t      bitregion_start = bit_off.to_uhwi ();\n-\t\t\t      bit_off = byte_off << LOG2_BITS_PER_UNIT;\n-\t\t\t      bit_off += bitregion_end;\n-\t\t\t      if (wi::fits_uhwi_p (bit_off))\n-\t\t\t\tbitregion_end = bit_off.to_uhwi ();\n-\t\t\t      else\n-\t\t\t\tbitregion_end = 0;\n-\t\t\t    }\n-\t\t\t  else\n-\t\t\t    bitregion_end = 0;\n-\t\t\t}\n-\t\t    }\n-\t\t  else\n-\t\t    invalid = true;\n-\t\t  base_addr = TREE_OPERAND (base_addr, 0);\n-\t\t}\n-\t      /* get_inner_reference returns the base object, get at its\n-\t         address now.  */\n-\t      else\n-\t\t{\n-\t\t  if (bitpos < 0)\n-\t\t    invalid = true;\n-\t\t  base_addr = build_fold_addr_expr (base_addr);\n-\t\t}\n-\n-\t      if (!bitregion_end)\n-\t\t{\n-\t\t  bitregion_start = ROUND_DOWN (bitpos, BITS_PER_UNIT);\n-\t\t  bitregion_end = ROUND_UP (bitpos + bitsize, BITS_PER_UNIT);\n-\t\t}\n-\n-\t      if (! invalid\n-\t\t  && offset != NULL_TREE)\n-\t\t{\n-\t\t  /* If the access is variable offset then a base\n-\t\t     decl has to be address-taken to be able to\n-\t\t     emit pointer-based stores to it.\n-\t\t     ???  We might be able to get away with\n-\t\t     re-using the original base up to the first\n-\t\t     variable part and then wrapping that inside\n-\t\t     a BIT_FIELD_REF.  */\n-\t\t  tree base = get_base_address (base_addr);\n-\t\t  if (! base\n-\t\t      || (DECL_P (base)\n-\t\t\t  && ! TREE_ADDRESSABLE (base)))\n-\t\t    invalid = true;\n-\t\t  else\n-\t\t    base_addr = build2 (POINTER_PLUS_EXPR,\n-\t\t\t\t\tTREE_TYPE (base_addr),\n-\t\t\t\t\tbase_addr, offset);\n-\t\t}\n-\n-\t      struct imm_store_chain_info **chain_info\n-\t\t= m_stores.get (base_addr);\n-\n-\t      if (!invalid)\n-\t\t{\n-\t\t  store_immediate_info *info;\n-\t\t  if (chain_info)\n-\t\t    {\n-\t\t      unsigned int ord = (*chain_info)->m_store_info.length ();\n-\t\t      info = new store_immediate_info (bitsize, bitpos,\n-\t\t\t\t\t\t       bitregion_start,\n-\t\t\t\t\t\t       bitregion_end,\n-\t\t\t\t\t\t       stmt, ord);\n-\t\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\t{\n-\t\t\t  fprintf (dump_file,\n-\t\t\t\t   \"Recording immediate store from stmt:\\n\");\n-\t\t\t  print_gimple_stmt (dump_file, stmt, 0);\n-\t\t\t}\n-\t\t      (*chain_info)->m_store_info.safe_push (info);\n-\t\t      /* If we reach the limit of stores to merge in a chain\n-\t\t\t terminate and process the chain now.  */\n-\t\t      if ((*chain_info)->m_store_info.length ()\n-\t\t\t   == (unsigned int)\n-\t\t\t      PARAM_VALUE (PARAM_MAX_STORES_TO_MERGE))\n-\t\t\t{\n-\t\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\t    fprintf (dump_file,\n-\t\t\t\t \"Reached maximum number of statements\"\n-\t\t\t\t \" to merge:\\n\");\n-\t\t\t  terminate_and_release_chain (*chain_info);\n-\t\t\t}\n-\t\t      continue;\n-\t\t    }\n-\n-\t\t  /* Store aliases any existing chain?  */\n-\t\t  terminate_all_aliasing_chains (chain_info, false, stmt);\n-\t\t  /* Start a new chain.  */\n-\t\t  struct imm_store_chain_info *new_chain\n-\t\t    = new imm_store_chain_info (m_stores_head, base_addr);\n-\t\t  info = new store_immediate_info (bitsize, bitpos,\n-\t\t\t\t\t\t   bitregion_start,\n-\t\t\t\t\t\t   bitregion_end,\n-\t\t\t\t\t\t   stmt, 0);\n-\t\t  new_chain->m_store_info.safe_push (info);\n-\t\t  m_stores.put (base_addr, new_chain);\n-\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t    {\n-\t\t      fprintf (dump_file,\n-\t\t\t       \"Starting new chain with statement:\\n\");\n-\t\t      print_gimple_stmt (dump_file, stmt, 0);\n-\t\t      fprintf (dump_file, \"The base object is:\\n\");\n-\t\t      print_generic_expr (dump_file, base_addr);\n-\t\t      fprintf (dump_file, \"\\n\");\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\tterminate_all_aliasing_chains (chain_info,\n-\t\t\t\t\t       offset != NULL_TREE, stmt);\n-\n-\t      continue;\n-\t    }\n-\n-\t  terminate_all_aliasing_chains (NULL, false, stmt);\n+\t    process_store (stmt);\n+\t  else\n+\t    terminate_all_aliasing_chains (NULL, stmt);\n \t}\n       terminate_and_process_all_chains ();\n     }"}, {"sha": "69d8b6b510d77c7913625ed6ea75b34ec9639d88", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245f6de13d73c2d6c8be1b78f9e1e99e4510572c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245f6de13d73c2d6c8be1b78f9e1e99e4510572c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=245f6de13d73c2d6c8be1b78f9e1e99e4510572c", "patch": "@@ -1,3 +1,9 @@\n+2017-11-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/78821\n+\t* gcc.dg/store_merging_13.c: New test.\n+\t* gcc.dg/store_merging_14.c: New test.\n+\n 2017-11-03  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \t* gfortran.dg/large_real_kind_2.F90: Test passes on FreeBSD.  Remove"}, {"sha": "d4e9ad2d2603d59be318126420ea6e557a1c0d84", "filename": "gcc/testsuite/gcc.dg/store_merging_13.c", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245f6de13d73c2d6c8be1b78f9e1e99e4510572c/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245f6de13d73c2d6c8be1b78f9e1e99e4510572c/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_13.c?ref=245f6de13d73c2d6c8be1b78f9e1e99e4510572c", "patch": "@@ -0,0 +1,157 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target store_merge } */\n+/* { dg-options \"-O2 -fdump-tree-store-merging\" } */\n+\n+struct S { unsigned char a, b; unsigned short c; unsigned char d, e, f, g; unsigned long long h; };\n+\n+__attribute__((noipa)) void\n+f1 (struct S *p)\n+{\n+  p->a = 1;\n+  p->b = 2;\n+  p->c = 3;\n+  p->d = 4;\n+  p->e = 5;\n+  p->f = 6;\n+  p->g = 7;\n+}\n+\n+__attribute__((noipa)) void\n+f2 (struct S *__restrict p, struct S *__restrict q)\n+{\n+  p->a = q->a;\n+  p->b = q->b;\n+  p->c = q->c;\n+  p->d = q->d;\n+  p->e = q->e;\n+  p->f = q->f;\n+  p->g = q->g;\n+}\n+\n+__attribute__((noipa)) void\n+f3 (struct S *p, struct S *q)\n+{\n+  unsigned char pa = q->a;\n+  unsigned char pb = q->b;\n+  unsigned short pc = q->c;\n+  unsigned char pd = q->d;\n+  unsigned char pe = q->e;\n+  unsigned char pf = q->f;\n+  unsigned char pg = q->g;\n+  p->a = pa;\n+  p->b = pb;\n+  p->c = pc;\n+  p->d = pd;\n+  p->e = pe;\n+  p->f = pf;\n+  p->g = pg;\n+}\n+\n+__attribute__((noipa)) void\n+f4 (struct S *p, struct S *q)\n+{\n+  unsigned char pa = p->a | q->a;\n+  unsigned char pb = p->b | q->b;\n+  unsigned short pc = p->c | q->c;\n+  unsigned char pd = p->d | q->d;\n+  unsigned char pe = p->e | q->e;\n+  unsigned char pf = p->f | q->f;\n+  unsigned char pg = p->g | q->g;\n+  p->a = pa;\n+  p->b = pb;\n+  p->c = pc;\n+  p->d = pd;\n+  p->e = pe;\n+  p->f = pf;\n+  p->g = pg;\n+}\n+\n+__attribute__((noipa)) void\n+f5 (struct S *p, struct S *q)\n+{\n+  unsigned char pa = p->a & q->a;\n+  unsigned char pb = p->b & q->b;\n+  unsigned short pc = p->c & q->c;\n+  unsigned char pd = p->d & q->d;\n+  unsigned char pe = p->e & q->e;\n+  unsigned char pf = p->f & q->f;\n+  unsigned char pg = p->g & q->g;\n+  p->a = pa;\n+  p->b = pb;\n+  p->c = pc;\n+  p->d = pd;\n+  p->e = pe;\n+  p->f = pf;\n+  p->g = pg;\n+}\n+\n+__attribute__((noipa)) void\n+f6 (struct S *p, struct S *q)\n+{\n+  unsigned char pa = p->a ^ q->a;\n+  unsigned char pb = p->b ^ q->b;\n+  unsigned short pc = p->c ^ q->c;\n+  unsigned char pd = p->d ^ q->d;\n+  unsigned char pe = p->e ^ q->e;\n+  unsigned char pf = p->f ^ q->f;\n+  unsigned char pg = p->g ^ q->g;\n+  p->a = pa;\n+  p->b = pb;\n+  p->c = pc;\n+  p->d = pd;\n+  p->e = pe;\n+  p->f = pf;\n+  p->g = pg;\n+}\n+\n+struct S s = { 20, 21, 22, 23, 24, 25, 26, 27 };\n+struct S t = { 0x71, 0x72, 0x7f04, 0x78, 0x31, 0x32, 0x34, 0xf1f2f3f4f5f6f7f8ULL };\n+struct S u = { 28, 29, 30, 31, 32, 33, 34, 35 };\n+struct S v = { 36, 37, 38, 39, 40, 41, 42, 43 };\n+\n+int\n+main ()\n+{\n+  asm volatile (\"\" : : : \"memory\");\n+  f1 (&s);\n+  asm volatile (\"\" : : : \"memory\");\n+  if (s.a != 1 || s.b != 2 || s.c != 3 || s.d != 4\n+      || s.e != 5 || s.f != 6 || s.g != 7 || s.h != 27)\n+    __builtin_abort ();\n+  f2 (&s, &u);\n+  asm volatile (\"\" : : : \"memory\");\n+  if (s.a != 28 || s.b != 29 || s.c != 30 || s.d != 31\n+      || s.e != 32 || s.f != 33 || s.g != 34 || s.h != 27)\n+    __builtin_abort ();\n+  f3 (&s, &v);\n+  asm volatile (\"\" : : : \"memory\");\n+  if (s.a != 36 || s.b != 37 || s.c != 38 || s.d != 39\n+      || s.e != 40 || s.f != 41 || s.g != 42 || s.h != 27)\n+    __builtin_abort ();\n+  f4 (&s, &t);\n+  asm volatile (\"\" : : : \"memory\");\n+  if (s.a != (36 | 0x71) || s.b != (37 | 0x72)\n+      || s.c != (38 | 0x7f04) || s.d != (39 | 0x78)\n+      || s.e != (40 | 0x31) || s.f != (41 | 0x32)\n+      || s.g != (42 | 0x34) || s.h != 27)\n+    __builtin_abort ();\n+  f3 (&s, &u);\n+  f5 (&s, &t);\n+  asm volatile (\"\" : : : \"memory\");\n+  if (s.a != (28 & 0x71) || s.b != (29 & 0x72)\n+      || s.c != (30 & 0x7f04) || s.d != (31 & 0x78)\n+      || s.e != (32 & 0x31) || s.f != (33 & 0x32)\n+      || s.g != (34 & 0x34) || s.h != 27)\n+    __builtin_abort ();\n+  f2 (&s, &v);\n+  f6 (&s, &t);\n+  asm volatile (\"\" : : : \"memory\");\n+  if (s.a != (36 ^ 0x71) || s.b != (37 ^ 0x72)\n+      || s.c != (38 ^ 0x7f04) || s.d != (39 ^ 0x78)\n+      || s.e != (40 ^ 0x31) || s.f != (41 ^ 0x32)\n+      || s.g != (42 ^ 0x34) || s.h != 27)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Merging successful\" 6 \"store-merging\" } } */"}, {"sha": "49af24951cb6a435297c26ca29d43877d6cece8f", "filename": "gcc/testsuite/gcc.dg/store_merging_14.c", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/245f6de13d73c2d6c8be1b78f9e1e99e4510572c/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/245f6de13d73c2d6c8be1b78f9e1e99e4510572c/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_14.c?ref=245f6de13d73c2d6c8be1b78f9e1e99e4510572c", "patch": "@@ -0,0 +1,157 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target store_merge } */\n+/* { dg-options \"-O2 -fdump-tree-store-merging\" } */\n+\n+struct S { unsigned int i : 8, a : 7, b : 7, j : 10, c : 15, d : 7, e : 10, f : 7, g : 9, k : 16; unsigned long long h; };\n+\n+__attribute__((noipa)) void\n+f1 (struct S *p)\n+{\n+  p->a = 1;\n+  p->b = 2;\n+  p->c = 3;\n+  p->d = 4;\n+  p->e = 5;\n+  p->f = 6;\n+  p->g = 7;\n+}\n+\n+__attribute__((noipa)) void\n+f2 (struct S *__restrict p, struct S *__restrict q)\n+{\n+  p->a = q->a;\n+  p->b = q->b;\n+  p->c = q->c;\n+  p->d = q->d;\n+  p->e = q->e;\n+  p->f = q->f;\n+  p->g = q->g;\n+}\n+\n+__attribute__((noipa)) void\n+f3 (struct S *p, struct S *q)\n+{\n+  unsigned char pa = q->a;\n+  unsigned char pb = q->b;\n+  unsigned short pc = q->c;\n+  unsigned char pd = q->d;\n+  unsigned short pe = q->e;\n+  unsigned char pf = q->f;\n+  unsigned short pg = q->g;\n+  p->a = pa;\n+  p->b = pb;\n+  p->c = pc;\n+  p->d = pd;\n+  p->e = pe;\n+  p->f = pf;\n+  p->g = pg;\n+}\n+\n+__attribute__((noipa)) void\n+f4 (struct S *p, struct S *q)\n+{\n+  unsigned char pa = p->a | q->a;\n+  unsigned char pb = p->b | q->b;\n+  unsigned short pc = p->c | q->c;\n+  unsigned char pd = p->d | q->d;\n+  unsigned short pe = p->e | q->e;\n+  unsigned char pf = p->f | q->f;\n+  unsigned short pg = p->g | q->g;\n+  p->a = pa;\n+  p->b = pb;\n+  p->c = pc;\n+  p->d = pd;\n+  p->e = pe;\n+  p->f = pf;\n+  p->g = pg;\n+}\n+\n+__attribute__((noipa)) void\n+f5 (struct S *p, struct S *q)\n+{\n+  unsigned char pa = p->a & q->a;\n+  unsigned char pb = p->b & q->b;\n+  unsigned short pc = p->c & q->c;\n+  unsigned char pd = p->d & q->d;\n+  unsigned short pe = p->e & q->e;\n+  unsigned char pf = p->f & q->f;\n+  unsigned short pg = p->g & q->g;\n+  p->a = pa;\n+  p->b = pb;\n+  p->c = pc;\n+  p->d = pd;\n+  p->e = pe;\n+  p->f = pf;\n+  p->g = pg;\n+}\n+\n+__attribute__((noipa)) void\n+f6 (struct S *p, struct S *q)\n+{\n+  unsigned char pa = p->a ^ q->a;\n+  unsigned char pb = p->b ^ q->b;\n+  unsigned short pc = p->c ^ q->c;\n+  unsigned char pd = p->d ^ q->d;\n+  unsigned short pe = p->e ^ q->e;\n+  unsigned char pf = p->f ^ q->f;\n+  unsigned short pg = p->g ^ q->g;\n+  p->a = pa;\n+  p->b = pb;\n+  p->c = pc;\n+  p->d = pd;\n+  p->e = pe;\n+  p->f = pf;\n+  p->g = pg;\n+}\n+\n+struct S s = { 72, 20, 21, 73, 22, 23, 24, 25, 26, 74, 27 };\n+struct S t = { 75, 0x71, 0x72, 76, 0x7f04, 0x78, 0x31, 0x32, 0x34, 77, 0xf1f2f3f4f5f6f7f8ULL };\n+struct S u = { 78, 28, 29, 79, 30, 31, 32, 33, 34, 80, 35 };\n+struct S v = { 81, 36, 37, 82, 38, 39, 40, 41, 42, 83, 43 };\n+\n+int\n+main ()\n+{\n+  asm volatile (\"\" : : : \"memory\");\n+  f1 (&s);\n+  asm volatile (\"\" : : : \"memory\");\n+  if (s.i != 72 || s.a != 1 || s.b != 2 || s.j != 73 || s.c != 3 || s.d != 4\n+      || s.e != 5 || s.f != 6 || s.g != 7 || s.k != 74 || s.h != 27)\n+    __builtin_abort ();\n+  f2 (&s, &u);\n+  asm volatile (\"\" : : : \"memory\");\n+  if (s.i != 72 || s.a != 28 || s.b != 29 || s.j != 73 || s.c != 30 || s.d != 31\n+      || s.e != 32 || s.f != 33 || s.g != 34 || s.k != 74 || s.h != 27)\n+    __builtin_abort ();\n+  f3 (&s, &v);\n+  asm volatile (\"\" : : : \"memory\");\n+  if (s.i != 72 || s.a != 36 || s.b != 37 || s.j != 73 || s.c != 38 || s.d != 39\n+      || s.e != 40 || s.f != 41 || s.g != 42 || s.k != 74 || s.h != 27)\n+    __builtin_abort ();\n+  f4 (&s, &t);\n+  asm volatile (\"\" : : : \"memory\");\n+  if (s.i != 72 || s.a != (36 | 0x71) || s.b != (37 | 0x72) || s.j != 73\n+      || s.c != (38 | 0x7f04) || s.d != (39 | 0x78)\n+      || s.e != (40 | 0x31) || s.f != (41 | 0x32)\n+      || s.g != (42 | 0x34) || s.k != 74 || s.h != 27)\n+    __builtin_abort ();\n+  f3 (&s, &u);\n+  f5 (&s, &t);\n+  asm volatile (\"\" : : : \"memory\");\n+  if (s.i != 72 || s.a != (28 & 0x71) || s.b != (29 & 0x72) || s.j != 73\n+      || s.c != (30 & 0x7f04) || s.d != (31 & 0x78)\n+      || s.e != (32 & 0x31) || s.f != (33 & 0x32)\n+      || s.g != (34 & 0x34) || s.k != 74 || s.h != 27)\n+    __builtin_abort ();\n+  f2 (&s, &v);\n+  f6 (&s, &t);\n+  asm volatile (\"\" : : : \"memory\");\n+  if (s.i != 72 || s.a != (36 ^ 0x71) || s.b != (37 ^ 0x72) || s.j != 73\n+      || s.c != (38 ^ 0x7f04) || s.d != (39 ^ 0x78)\n+      || s.e != (40 ^ 0x31) || s.f != (41 ^ 0x32)\n+      || s.g != (42 ^ 0x34) || s.k != 74 || s.h != 27)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Merging successful\" 6 \"store-merging\" } } */"}]}