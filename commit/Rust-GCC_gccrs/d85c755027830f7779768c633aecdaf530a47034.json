{"sha": "d85c755027830f7779768c633aecdaf530a47034", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDg1Yzc1NTAyNzgzMGY3Nzc5NzY4YzYzM2FlY2RhZjUzMGE0NzAzNA==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2007-01-18T13:06:57Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2007-01-18T13:06:57Z"}, "message": "reg-stack.c (subst_stack_regs_pat): Use generic code for instructions that operate on the top of stack.\n\n\t* reg-stack.c (subst_stack_regs_pat) [UNSPEC_SINCOS_COS,\n\tUNSPEC_XTRACT_FRACT]: Use generic code for instructions that\n\toperate on the top of stack.\n\t[UNSPEC_SINCOS_SIN, UNSPEC_XTRACT_EXP, UNSPEC_TAN]: Rewrite\n\tregister handling of instructions that output to the second\n\tstack slot.\n\t[UNSPEC_TAN_ONE, UNSPEC_TAN_TAN]: Remove.\n\t(move_for_stack_reg): Special-case check for dead destination\n\tstack slot for constant load of 1.0 inside UNSPEC_TAN.\n\n\t* config/i386/i386.md (UNSPEC_TAN): New constant.\n\t(UNSPEC_TAN_ONE, UNSPEC_TAN_TAN): Remove.\n\t(fptanxf4_i387, fptan_extend<mode>xf4_i387): New patterns\n\tto correctly model move of constant 1.0 to top stack slot.\n\t(*tandf3_1, *tansf3_1, *tanxf3_1): Remove insn patterns.\n\t(unnamed peephole2 pattern): Remove corresponding peephole2\n\tpattern that optimizes tan insn and loading of constant 1.0.\n\t(tanxf2): Use fptanxf4_i387.\n\t(tan<mode>2): Rename from tansf2 and tandf2 and macroize insn\n\tpatterns using X87MODEF12 mode macro.  Use fptan_extend<mode>xf4_i387\n\tand truncate result to requested mode.  Use SSE_FLOAT_MODE_P to\n\tdisable patterns for SSE math.\n\t(sincos<mode>3): Use truncxf<mode>2_i387_noop for truncation.\n\t(fyl2x_extend<mode>xf3_i387): Use X87MODEF12 for operand 1.\n\ntestsuite/ChangeLog:\n\n\t* gcc.target/i386/387-8.c: Update comment about optimizing\n\tinherent load of 1.0 of fptan instruction.\n\nFrom-SVN: r120899", "tree": {"sha": "b09549c3db8a84ccbaeffdb31e9f328b4e85b663", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b09549c3db8a84ccbaeffdb31e9f328b4e85b663"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d85c755027830f7779768c633aecdaf530a47034", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d85c755027830f7779768c633aecdaf530a47034", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d85c755027830f7779768c633aecdaf530a47034", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d85c755027830f7779768c633aecdaf530a47034/comments", "author": null, "committer": null, "parents": [{"sha": "590b1f2d1f60b909e45e9b47f8a3e71a608dee20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/590b1f2d1f60b909e45e9b47f8a3e71a608dee20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/590b1f2d1f60b909e45e9b47f8a3e71a608dee20"}], "stats": {"total": 341, "additions": 146, "deletions": 195}, "files": [{"sha": "7edc6df8bfad78577aa180c2c6655227b6ae47da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d85c755027830f7779768c633aecdaf530a47034/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d85c755027830f7779768c633aecdaf530a47034/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d85c755027830f7779768c633aecdaf530a47034", "patch": "@@ -1,25 +1,52 @@\n+2007-01-18  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* reg-stack.c (subst_stack_regs_pat) [UNSPEC_SINCOS_COS,\n+\tUNSPEC_XTRACT_FRACT]: Use generic code for instructions that\n+\toperate on the top of stack.\n+\t[UNSPEC_SINCOS_SIN, UNSPEC_XTRACT_EXP, UNSPEC_TAN]: Rewrite\n+\tregister handling of instructions that output to the second\n+\tstack slot.\n+\t[UNSPEC_TAN_ONE, UNSPEC_TAN_TAN]: Remove.\n+\t(move_for_stack_reg): Special-case check for dead destination\n+\tstack slot for constant load of 1.0 inside UNSPEC_TAN.\n+\n+\t* config/i386/i386.md (UNSPEC_TAN): New constant.\n+\t(UNSPEC_TAN_ONE, UNSPEC_TAN_TAN): Remove.\n+\t(fptanxf4_i387, fptan_extend<mode>xf4_i387): New patterns\n+\tto correctly model move of constant 1.0 to top stack slot.\n+\t(*tandf3_1, *tansf3_1, *tanxf3_1): Remove insn patterns.\n+\t(unnamed peephole2 pattern): Remove corresponding peephole2\n+\tpattern that optimizes tan insn and loading of constant 1.0.\n+\t(tanxf2): Use fptanxf4_i387.\n+\t(tan<mode>2): Rename from tansf2 and tandf2 and macroize insn\n+\tpatterns using X87MODEF12 mode macro.  Use fptan_extend<mode>xf4_i387\n+\tand truncate result to requested mode.  Use SSE_FLOAT_MODE_P to\n+\tdisable patterns for SSE math.\n+\t(sincos<mode>3): Use truncxf<mode>2_i387_noop for truncation.\n+\t(fyl2x_extend<mode>xf3_i387): Use X87MODEF12 for operand 1.\n+\n 2007-01-18  Dirk Mueller  <dmueller@suse.de>\n-\ufffd           Richard Guenther <rguenther@suse.de>\n+\t    Richard Guenther <rguenther@suse.de>\n \n-\ufffd       PR diagnostic/8268\n-\ufffd       * doc/invoke.texi (Warray-bounds): Document -Warray-bounds.\n-\ufffd       * common.opt (Warray-bounds): Add new warning option.\n-\ufffd       * c-opts.c (c_common_handle_option): Define -Warray-bounds\n-\ufffd       if -Wall is given.\n+\tPR diagnostic/8268\n+\t* doc/invoke.texi (Warray-bounds): Document -Warray-bounds.\n+\t* common.opt (Warray-bounds): Add new warning option.\n+\t* c-opts.c (c_common_handle_option): Define -Warray-bounds\n+\tif -Wall is given.\n \t* Makefile.in: make tree-vrp.o depend on toplev.h\n-\ufffd       * tree-vrp.c (vrp_finalize): Call check_array_refs if -Warray-bounds\n-\ufffd       is enabled.\n-\ufffd       (check_array_refs, check_array_bounds, check_array_ref): New.\n+\t* tree-vrp.c (vrp_finalize): Call check_array_refs if -Warray-bounds\n+\tis enabled.\n+\t(check_array_refs, check_array_bounds, check_array_ref): New.\n \n-18-01-2007  Jan Hubicka  <jh@suse.cz>\n+2007-01-18  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-ssa-ccp.c (ccp_finalize): Return if something changed.\n \t(execute_ssa_ccp): Return flags conditionally.\n \t* tree-ssa-propagate.c (substitue_and_fold): Return if something was\n \tchanged.\n \t* tree-ssa-propagate.h (substitute_and_fold): Update prototype.\n \n-18-01-2007  Steven Bosscher  <steven@gcc.gnu.org>\n+2007-01-18  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* cfgcleanup.c (cleanup_cfg): Detect cfglayout mode and set\n \tthe CLEANUP_CFGLAYOUT flag when in cfglayout mode.\n@@ -256,7 +283,7 @@\n \t* config/i386/i386.md (fyl2xxf3_i387): Rename from fyl2x_xf3.\n \t(fyl2x_extend<mode>xf3_i387): New insn pattern.\n \t(log<mode>2): Rename from logsf2 and logdf2 and macroize insn\n-\tinsn patterns using X87MODEF12 mode macro.  Extend operand 1\n+\tpatterns using X87MODEF12 mode macro.  Extend operand 1\n \tto XFmode. Use SSE_FLOAT_MODE_P to disable patterns for SSE math.\n \t(log10<mode>2): Ditto.\n \t(log2<mode>2): Ditto.\n@@ -267,7 +294,6 @@\n \t(*fxtractxf3_i387): Rename from *fxtractxf3.\n \t(fxtract_extend<mode>xf3_i387): New insn pattern.\n \t(ilogbsi2): Use match_dup 3, not match_operand:XF 3.\n-\n \t* config/i386/i386.c (ix86_emit_i387_log1p): Use gen_fyl2xp1xf3_i387()\n \tand gen_fyl2xxf3_i387().\n "}, {"sha": "0e535ba5b1f59a8f7e2adf798b47741bc40bbbc5", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 46, "deletions": 116, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d85c755027830f7779768c633aecdaf530a47034/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d85c755027830f7779768c633aecdaf530a47034/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=d85c755027830f7779768c633aecdaf530a47034", "patch": "@@ -121,6 +121,7 @@\n    (UNSPEC_FRNDINT\t\t65)\n    (UNSPEC_FIST\t\t\t66)\n    (UNSPEC_F2XM1\t\t67)\n+   (UNSPEC_TAN\t\t\t68)\n \n    ; x87 Rounding\n    (UNSPEC_FRNDINT_FLOOR\t70)\n@@ -133,8 +134,6 @@\n    ; x87 Double output FP\n    (UNSPEC_SINCOS_COS\t\t80)\n    (UNSPEC_SINCOS_SIN\t\t81)\n-   (UNSPEC_TAN_ONE\t\t82)\n-   (UNSPEC_TAN_TAN\t\t83)\n    (UNSPEC_XTRACT_FRACT\t\t84)\n    (UNSPEC_XTRACT_EXP\t\t85)\n    (UNSPEC_FSCALE_FRACT\t\t86)\n@@ -15862,139 +15861,70 @@\n   rtx op1 = gen_reg_rtx (XFmode);\n \n   emit_insn (gen_sincos_extend<mode>xf3_i387 (op0, op1, operands[2]));\n-  emit_insn (gen_truncxf<mode>2_i387_noop_unspec (operands[0], op0));\n-  emit_insn (gen_truncxf<mode>2_i387_noop_unspec (operands[1], op1));\n+  emit_insn (gen_truncxf<mode>2_i387_noop (operands[0], op0));\n+  emit_insn (gen_truncxf<mode>2_i387_noop (operands[1], op1));\n   DONE;\n })\n \n-(define_insn \"*tandf3_1\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(unspec:DF [(match_operand:DF 2 \"register_operand\" \"0\")]\n-\t\t   UNSPEC_TAN_ONE))\n-   (set (match_operand:DF 1 \"register_operand\" \"=u\")\n-        (unspec:DF [(match_dup 2)] UNSPEC_TAN_TAN))]\n+(define_insn \"fptanxf4_i387\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n+\t(match_operand:XF 3 \"const_double_operand\" \"F\"))\n+   (set (match_operand:XF 1 \"register_operand\" \"=u\")\n+        (unspec:XF [(match_operand:XF 2 \"register_operand\" \"0\")]\n+\t\t   UNSPEC_TAN))]\n   \"TARGET_USE_FANCY_MATH_387\n-   && (!(TARGET_SSE2 && TARGET_SSE_MATH) || TARGET_MIX_SSE_I387)\n-   && flag_unsafe_math_optimizations\"\n+   && flag_unsafe_math_optimizations\n+   && standard_80387_constant_p (operands[3]) == 2\"\n   \"fptan\"\n   [(set_attr \"type\" \"fpspc\")\n-   (set_attr \"mode\" \"DF\")])\n-\n-;; optimize sequence: fptan\n-;;\t\t      fstp    %st(0)\n-;;\t\t      fld1\n-;; into fptan insn.\n-\n-(define_peephole2\n-  [(parallel[(set (match_operand:DF 0 \"register_operand\" \"\")\n-\t\t  (unspec:DF [(match_operand:DF 2 \"register_operand\" \"\")]\n-\t\t\t     UNSPEC_TAN_ONE))\n-\t     (set (match_operand:DF 1 \"register_operand\" \"\")\n-\t\t  (unspec:DF [(match_dup 2)] UNSPEC_TAN_TAN))])\n-   (set (match_dup 0)\n-        (match_operand:DF 3 \"immediate_operand\" \"\"))]\n-  \"standard_80387_constant_p (operands[3]) == 2\"\n-  [(parallel[(set (match_dup 0) (unspec:DF [(match_dup 2)] UNSPEC_TAN_ONE))\n-   \t     (set (match_dup 1) (unspec:DF [(match_dup 2)] UNSPEC_TAN_TAN))])]\n-  \"\")\n-\n-(define_expand \"tandf2\"\n-  [(parallel [(set (match_dup 2)\n-\t\t   (unspec:DF [(match_operand:DF 1 \"register_operand\" \"\")]\n-\t\t\t      UNSPEC_TAN_ONE))\n-\t      (set (match_operand:DF 0 \"register_operand\" \"\")\n-\t\t   (unspec:DF [(match_dup 1)] UNSPEC_TAN_TAN))])]\n-  \"TARGET_USE_FANCY_MATH_387\n-   && (!(TARGET_SSE2 && TARGET_SSE_MATH) || TARGET_MIX_SSE_I387)\n-   && flag_unsafe_math_optimizations\"\n-{\n-  operands[2] = gen_reg_rtx (DFmode);\n-})\n+   (set_attr \"mode\" \"XF\")])\n \n-(define_insn \"*tansf3_1\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(unspec:SF [(match_operand:SF 2 \"register_operand\" \"0\")]\n-\t\t   UNSPEC_TAN_ONE))\n-   (set (match_operand:SF 1 \"register_operand\" \"=u\")\n-        (unspec:SF [(match_dup 2)] UNSPEC_TAN_TAN))]\n+(define_insn \"fptan_extend<mode>xf4_i387\"\n+  [(set (match_operand:X87MODEF12 0 \"register_operand\" \"=f\")\n+\t(match_operand:X87MODEF12 3 \"const_double_operand\" \"F\"))\n+   (set (match_operand:XF 1 \"register_operand\" \"=u\")\n+        (unspec:XF [(float_extend:XF\n+\t\t      (match_operand:X87MODEF12 2 \"register_operand\" \"0\"))]\n+\t\t   UNSPEC_TAN))]\n   \"TARGET_USE_FANCY_MATH_387\n-   && (!TARGET_SSE_MATH || TARGET_MIX_SSE_I387)\n-   && flag_unsafe_math_optimizations\"\n+   && (!(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n+       || TARGET_MIX_SSE_I387)\n+   && flag_unsafe_math_optimizations\n+   && standard_80387_constant_p (operands[3]) == 2\"\n   \"fptan\"\n   [(set_attr \"type\" \"fpspc\")\n-   (set_attr \"mode\" \"SF\")])\n-\n-;; optimize sequence: fptan\n-;;\t\t      fstp    %st(0)\n-;;\t\t      fld1\n-;; into fptan insn.\n-\n-(define_peephole2\n-  [(parallel[(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t\t  (unspec:SF [(match_operand:SF 2 \"register_operand\" \"\")]\n-\t\t\t     UNSPEC_TAN_ONE))\n-\t     (set (match_operand:SF 1 \"register_operand\" \"\")\n-\t\t  (unspec:SF [(match_dup 2)] UNSPEC_TAN_TAN))])\n-   (set (match_dup 0)\n-        (match_operand:SF 3 \"immediate_operand\" \"\"))]\n-  \"standard_80387_constant_p (operands[3]) == 2\"\n-  [(parallel[(set (match_dup 0) (unspec:SF [(match_dup 2)] UNSPEC_TAN_ONE))\n-   \t     (set (match_dup 1) (unspec:SF [(match_dup 2)] UNSPEC_TAN_TAN))])]\n-  \"\")\n+   (set_attr \"mode\" \"XF\")])\n \n-(define_expand \"tansf2\"\n-  [(parallel [(set (match_dup 2)\n-\t\t   (unspec:SF [(match_operand:SF 1 \"register_operand\" \"\")]\n-\t\t\t      UNSPEC_TAN_ONE))\n-\t      (set (match_operand:SF 0 \"register_operand\" \"\")\n-\t\t   (unspec:SF [(match_dup 1)] UNSPEC_TAN_TAN))])]\n+(define_expand \"tanxf2\"\n+  [(use (match_operand:XF 0 \"register_operand\" \"\"))\n+   (use (match_operand:XF 1 \"register_operand\" \"\"))]\n   \"TARGET_USE_FANCY_MATH_387\n-   && (!TARGET_SSE_MATH || TARGET_MIX_SSE_I387)\n    && flag_unsafe_math_optimizations\"\n {\n-  operands[2] = gen_reg_rtx (SFmode);\n+  rtx one = gen_reg_rtx (XFmode);\n+  operands[2] = CONST1_RTX (XFmode); /* fld1 */\n+\n+  emit_insn (gen_fptanxf4_i387 (one, operands[0], operands[1], operands[2]));\n+  DONE;\n })\n \n-(define_insn \"*tanxf3_1\"\n-  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n-\t(unspec:XF [(match_operand:XF 2 \"register_operand\" \"0\")]\n-\t\t   UNSPEC_TAN_ONE))\n-   (set (match_operand:XF 1 \"register_operand\" \"=u\")\n-        (unspec:XF [(match_dup 2)] UNSPEC_TAN_TAN))]\n+(define_expand \"tan<mode>2\"\n+  [(use (match_operand:X87MODEF12 0 \"register_operand\" \"\"))\n+   (use (match_operand:X87MODEF12 1 \"register_operand\" \"\"))]\n   \"TARGET_USE_FANCY_MATH_387\n+   && (!(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n+       || TARGET_MIX_SSE_I387)\n    && flag_unsafe_math_optimizations\"\n-  \"fptan\"\n-  [(set_attr \"type\" \"fpspc\")\n-   (set_attr \"mode\" \"XF\")])\n+{\n+  rtx op0 = gen_reg_rtx (XFmode);\n \n-;; optimize sequence: fptan\n-;;\t\t      fstp    %st(0)\n-;;\t\t      fld1\n-;; into fptan insn.\n+  rtx one = gen_reg_rtx (<MODE>mode);\n+  operands[2] = CONST1_RTX (<MODE>mode); /* fld1 */\n \n-(define_peephole2\n-  [(parallel[(set (match_operand:XF 0 \"register_operand\" \"\")\n-\t\t  (unspec:XF [(match_operand:XF 2 \"register_operand\" \"\")]\n-\t\t\t     UNSPEC_TAN_ONE))\n-\t     (set (match_operand:XF 1 \"register_operand\" \"\")\n-\t\t  (unspec:XF [(match_dup 2)] UNSPEC_TAN_TAN))])\n-   (set (match_dup 0)\n-        (match_operand:XF 3 \"immediate_operand\" \"\"))]\n-  \"standard_80387_constant_p (operands[3]) == 2\"\n-  [(parallel[(set (match_dup 0) (unspec:XF [(match_dup 2)] UNSPEC_TAN_ONE))\n-   \t     (set (match_dup 1) (unspec:XF [(match_dup 2)] UNSPEC_TAN_TAN))])]\n-  \"\")\n-\n-(define_expand \"tanxf2\"\n-  [(parallel [(set (match_dup 2)\n-\t\t   (unspec:XF [(match_operand:XF 1 \"register_operand\" \"\")]\n-\t\t\t      UNSPEC_TAN_ONE))\n-\t      (set (match_operand:XF 0 \"register_operand\" \"\")\n-\t\t   (unspec:XF [(match_dup 1)] UNSPEC_TAN_TAN))])]\n-  \"TARGET_USE_FANCY_MATH_387\n-   && flag_unsafe_math_optimizations\"\n-{\n-  operands[2] = gen_reg_rtx (XFmode);\n+  emit_insn (gen_fptan_extend<mode>xf4_i387 (one, op0,\n+\t\t\t\t\t     operands[1], operands[2]));\n+  emit_insn (gen_truncxf<mode>2_i387_noop (operands[0], op0));\n+  DONE;\n })\n \n (define_insn \"atan2df3_1\"\n@@ -16270,7 +16200,7 @@\n (define_insn \"fyl2x_extend<mode>xf3_i387\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n         (unspec:XF [(float_extend:XF\n-\t\t      (match_operand:X87MODEF 1 \"register_operand\" \"0\"))\n+\t\t      (match_operand:X87MODEF12 1 \"register_operand\" \"0\"))\n \t\t    (match_operand:XF 2 \"register_operand\" \"u\")]\n \t           UNSPEC_FYL2X))\n    (clobber (match_scratch:XF 3 \"=2\"))]"}, {"sha": "0df425eebebd49a6b6015cf5fc10532c544d449b", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 50, "deletions": 61, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d85c755027830f7779768c633aecdaf530a47034/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d85c755027830f7779768c633aecdaf530a47034/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=d85c755027830f7779768c633aecdaf530a47034", "patch": "@@ -1059,15 +1059,25 @@ move_for_stack_reg (rtx insn, stack regstack, rtx pat)\n     }\n   else\n     {\n+      rtx pat = PATTERN (insn);\n+\n       gcc_assert (STACK_REG_P (dest));\n \n       /* Load from MEM, or possibly integer REG or constant, into the\n \t stack regs.  The actual target is always the top of the\n \t stack. The stack mapping is changed to reflect that DEST is\n \t now at top of stack.  */\n \n-      /* The destination ought to be dead.  */\n-      gcc_assert (get_hard_regnum (regstack, dest) < FIRST_STACK_REG);\n+      /* The destination ought to be dead.  However, there is a\n+\t special case with i387 UNSPEC_TAN, where destination is live\n+\t (an argument to fptan) but inherent load of 1.0 is modelled\n+\t as a load from a constant.  */\n+      if (! (GET_CODE (pat) == PARALLEL\n+\t     && XVECLEN (pat, 0) == 2\n+\t     && GET_CODE (XVECEXP (pat, 0, 1)) == SET\n+\t     && GET_CODE (SET_SRC (XVECEXP (pat, 0, 1))) == UNSPEC\n+\t     && XINT (SET_SRC (XVECEXP (pat, 0, 1)), 1) == UNSPEC_TAN))\n+\tgcc_assert (get_hard_regnum (regstack, dest) < FIRST_STACK_REG);\n \n       gcc_assert (regstack->top < REG_STACK_SIZE);\n \n@@ -1629,14 +1639,19 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t      case UNSPEC_FRNDINT_TRUNC:\n \t      case UNSPEC_FRNDINT_MASK_PM:\n \n-\t\t/* These insns only operate on the top of the stack.  */\n+\t\t/* Above insns operate on the top of the stack.  */\n+\n+\t      case UNSPEC_SINCOS_COS:\n+\t      case UNSPEC_XTRACT_FRACT:\n+\n+\t\t/* Above insns operate on the top two stack slots,\n+\t\t   first part of one input, double output insn.  */\n \n \t\tsrc1 = get_true_reg (&XVECEXP (pat_src, 0, 0));\n \n \t\temit_swap_insn (insn, regstack, *src1);\n \n-\t\t/* Input should never die, it is\n-\t\t   replaced with output.  */\n+\t\t/* Input should never die, it is replaced with output.  */\n \t\tsrc1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n \t\tgcc_assert (!src1_note);\n \n@@ -1646,6 +1661,36 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t\treplace_reg (src1, FIRST_STACK_REG);\n \t\tbreak;\n \n+\t      case UNSPEC_SINCOS_SIN:\n+\t      case UNSPEC_XTRACT_EXP:\n+\n+\t\t/* These insns operate on the top two stack slots,\n+\t\t   second part of one input, double output insn.  */\n+\n+\t\tregstack->top++;\n+\t\t/* FALLTHRU */\n+\n+\t      case UNSPEC_TAN:\n+\n+\t\t/* For UNSPEC_TAN, regstack->top is already increased\n+\t\t   by inherent load of constant 1.0.  */\n+\n+\t\t/* Output value is generated in the second stack slot.\n+\t\t   Move current value from second slot to the top.  */\n+\t\tregstack->reg[regstack->top]\n+\t\t  = regstack->reg[regstack->top - 1];\n+\n+\t\tgcc_assert (STACK_REG_P (*dest));\n+\n+\t\tregstack->reg[regstack->top - 1] = REGNO (*dest);\n+\t\tSET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n+\t\treplace_reg (dest, FIRST_STACK_REG + 1);\n+\n+\t\tsrc1 = get_true_reg (&XVECEXP (pat_src, 0, 0));\n+\n+\t\treplace_reg (src1, FIRST_STACK_REG);\n+\t\tbreak;\n+\n \t      case UNSPEC_FPATAN:\n \t      case UNSPEC_FYL2X:\n \t      case UNSPEC_FYL2XP1:\n@@ -1744,62 +1789,6 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t\treplace_reg (src2, FIRST_STACK_REG + 1);\n \t\tbreak;\n \n-\t      case UNSPEC_SINCOS_COS:\n-\t      case UNSPEC_TAN_ONE:\n-\t      case UNSPEC_XTRACT_FRACT:\n-\t\t/* These insns operate on the top two stack slots,\n-\t\t   first part of one input, double output insn.  */\n-\n-\t\tsrc1 = get_true_reg (&XVECEXP (pat_src, 0, 0));\n-\n-\t\temit_swap_insn (insn, regstack, *src1);\n-\n-\t\t/* Input should never die, it is\n-\t\t   replaced with output.  */\n-\t\tsrc1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n-\t\tgcc_assert (!src1_note);\n-\n-\t\t/* Push the result back onto stack. Empty stack slot\n-\t\t   will be filled in second part of insn.  */\n-\t\tif (STACK_REG_P (*dest))\n-\t\t  {\n-\t\t    regstack->reg[regstack->top + 1] = REGNO (*dest);\n-\t\t    SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n-\t\t    replace_reg (dest, FIRST_STACK_REG);\n-\t\t  }\n-\n-\t\treplace_reg (src1, FIRST_STACK_REG);\n-\t\tbreak;\n-\n-\t      case UNSPEC_SINCOS_SIN:\n-\t      case UNSPEC_TAN_TAN:\n-\t      case UNSPEC_XTRACT_EXP:\n-\t\t/* These insns operate on the top two stack slots,\n-\t\t   second part of one input, double output insn.  */\n-\n-\t\tsrc1 = get_true_reg (&XVECEXP (pat_src, 0, 0));\n-\n-\t\temit_swap_insn (insn, regstack, *src1);\n-\n-\t\t/* Input should never die, it is\n-\t\t   replaced with output.  */\n-\t\tsrc1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n-\t\tgcc_assert (!src1_note);\n-\n-\t\t/* Push the result back onto stack. Fill empty slot from\n-\t\t   first part of insn and fix top of stack pointer.  */\n-\t\tif (STACK_REG_P (*dest))\n-\t\t  {\n-\t\t    regstack->reg[regstack->top] = REGNO (*dest);\n-\t\t    SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n-\t\t    replace_reg (dest, FIRST_STACK_REG + 1);\n-\n-\t\t    regstack->top++;\n-\t\t  }\n-\n-\t\treplace_reg (src1, FIRST_STACK_REG);\n-\t\tbreak;\n-\n \t      case UNSPEC_SAHF:\n \t\t/* (unspec [(unspec [(compare)] UNSPEC_FNSTSW)] UNSPEC_SAHF)\n \t\t   The combination matches the PPRO fcomi instruction.  */"}, {"sha": "9171b0d01b16f2c4dc680ff9538674abbc6d0db4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d85c755027830f7779768c633aecdaf530a47034/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d85c755027830f7779768c633aecdaf530a47034/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d85c755027830f7779768c633aecdaf530a47034", "patch": "@@ -1,8 +1,13 @@\n+2007-01-18  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* gcc.target/i386/387-8.c: Update comment about optimizing\n+\tinherent load of 1.0 of fptan instruction.\n+\n 2007-01-18  Dirk Mueller  <dmueller@suse.de>\n-\ufffd           Richard Guenther <rguenther@suse.de>\n+\t    Richard Guenther <rguenther@suse.de>\n \n-\ufffd       PR diagnostic/8268\n-\ufffd       * gcc.dg/Warray-bounds.c: New testcase.\n+\tPR diagnostic/8268\n+\t* gcc.dg/Warray-bounds.c: New testcase.\n \t* gcc.dg/Warray-bounds-2.c: New testcase.\n \t* g++.dg/warn/Warray-bounds.C: New testcase.\n \t* g++.dg/warn/Warray-bounds-2.C: New testcase."}, {"sha": "578e0a38b5f198aeb4c9bb4f6d7a4c1c978a76c5", "filename": "gcc/testsuite/gcc.target/i386/387-8.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d85c755027830f7779768c633aecdaf530a47034/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F387-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d85c755027830f7779768c633aecdaf530a47034/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F387-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F387-8.c?ref=d85c755027830f7779768c633aecdaf530a47034", "patch": "@@ -1,5 +1,6 @@\n-/* Verify that 387 fptan instruction is generated. Also check fptan\n-   peephole2 optimizer.  */\n+/* Verify that 387 fptan instruction is generated. Also check that\n+   inherent load of 1.0 is used in further calculations.  */\n+\n /* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n /* { dg-require-effective-target ilp32 } */\n /* { dg-options \"-O2 -ffast-math -march=i686\" } */"}]}