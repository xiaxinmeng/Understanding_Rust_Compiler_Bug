{"sha": "16a51cf5491b642639b60ea12c0fff12a5403934", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZhNTFjZjU0OTFiNjQyNjM5YjYwZWExMmMwZmZmMTJhNTQwMzkzNA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-04-22T06:50:33Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-04-22T06:50:33Z"}, "message": "re PR fortran/57284 ([OOP] ICE with find_array_spec for polymorphic arrays)\n\n2019-04-22  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/57284\n\t* resolve.c (find_array_spec): If this is a class expression\n\tand the symbol and component array specs are the same, this is\n\tnot an error.\n\t*trans-intrinsic.c (gfc_conv_intrinsic_size): If a class symbol\n\targument, has no namespace, it has come from the interface\n\tmapping and the _data component must be accessed directly.\n\n2019-04-22  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/57284\n\t* gfortran.dg/class_70.f03\n\nFrom-SVN: r270489", "tree": {"sha": "3df2343a26f4954033b65ca19113ed070fefedfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3df2343a26f4954033b65ca19113ed070fefedfd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16a51cf5491b642639b60ea12c0fff12a5403934", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16a51cf5491b642639b60ea12c0fff12a5403934", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16a51cf5491b642639b60ea12c0fff12a5403934", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16a51cf5491b642639b60ea12c0fff12a5403934/comments", "author": null, "committer": null, "parents": [{"sha": "76a86e861665f8fc9595969112eb5a08590b5a29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76a86e861665f8fc9595969112eb5a08590b5a29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76a86e861665f8fc9595969112eb5a08590b5a29"}], "stats": {"total": 86, "additions": 82, "deletions": 4}, "files": [{"sha": "6a11bf5514bc79ae0523e7db1fe98d6599373b50", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a51cf5491b642639b60ea12c0fff12a5403934/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a51cf5491b642639b60ea12c0fff12a5403934/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=16a51cf5491b642639b60ea12c0fff12a5403934", "patch": "@@ -1,3 +1,13 @@\n+2019-04-22  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/57284\n+\t* resolve.c (find_array_spec): If this is a class expression\n+\tand the symbol and component array specs are the same, this is\n+\tnot an error.\n+\t*trans-intrinsic.c (gfc_conv_intrinsic_size): If a class symbol\n+\targument, has no namespace, it has come from the interface\n+\tmapping and the _data component must be accessed directly.\n+\n 2019-04-17  Thomas Schwinge  <thomas@codesourcery.com>\n \n \tPR fortran/90048"}, {"sha": "8232deb81704b8cea92e1a6064870b7cbc801046", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a51cf5491b642639b60ea12c0fff12a5403934/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a51cf5491b642639b60ea12c0fff12a5403934/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=16a51cf5491b642639b60ea12c0fff12a5403934", "patch": "@@ -4712,9 +4712,13 @@ find_array_spec (gfc_expr *e)\n   gfc_array_spec *as;\n   gfc_component *c;\n   gfc_ref *ref;\n+  bool class_as = false;\n \n   if (e->symtree->n.sym->ts.type == BT_CLASS)\n-    as = CLASS_DATA (e->symtree->n.sym)->as;\n+    {\n+      as = CLASS_DATA (e->symtree->n.sym)->as;\n+      class_as = true;\n+    }\n   else\n     as = e->symtree->n.sym->as;\n \n@@ -4733,7 +4737,7 @@ find_array_spec (gfc_expr *e)\n \tc = ref->u.c.component;\n \tif (c->attr.dimension)\n \t  {\n-\t    if (as != NULL)\n+\t    if (as != NULL && !(class_as && as == c->as))\n \t      gfc_internal_error (\"find_array_spec(): unused as(1)\");\n \t    as = c->as;\n \t  }"}, {"sha": "e0a4c6709de541c331a815f9dcae9a74fdf1ab6e", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a51cf5491b642639b60ea12c0fff12a5403934/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a51cf5491b642639b60ea12c0fff12a5403934/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=16a51cf5491b642639b60ea12c0fff12a5403934", "patch": "@@ -7446,19 +7446,40 @@ gfc_conv_intrinsic_size (gfc_se * se, gfc_expr * expr)\n   tree fncall0;\n   tree fncall1;\n   gfc_se argse;\n+  gfc_expr *e;\n+  gfc_symbol *sym = NULL;\n \n   gfc_init_se (&argse, NULL);\n   actual = expr->value.function.actual;\n \n   if (actual->expr->ts.type == BT_CLASS)\n     gfc_add_class_array_ref (actual->expr);\n \n+  e = actual->expr;\n+\n+  /* These are emerging from the interface mapping, when a class valued\n+     function appears as the rhs in a realloc on assign statement, where\n+     the size of the result is that of one of the actual arguments.  */\n+  if (e->expr_type == EXPR_VARIABLE\n+      && e->symtree->n.sym->ns == NULL /* This is distinctive!  */\n+      && e->symtree->n.sym->ts.type == BT_CLASS\n+      && e->ref && e->ref->type == REF_COMPONENT\n+      && strcmp (e->ref->u.c.component->name, \"_data\") == 0)\n+    sym = e->symtree->n.sym;\n+\n   argse.data_not_needed = 1;\n-  if (gfc_is_class_array_function (actual->expr))\n+  if (gfc_is_class_array_function (e))\n     {\n       /* For functions that return a class array conv_expr_descriptor is not\n \t able to get the descriptor right.  Therefore this special case.  */\n-      gfc_conv_expr_reference (&argse, actual->expr);\n+      gfc_conv_expr_reference (&argse, e);\n+      argse.expr = gfc_build_addr_expr (NULL_TREE,\n+\t\t\t\t\tgfc_class_data_get (argse.expr));\n+    }\n+  else if (sym && sym->backend_decl)\n+    {\n+      gcc_assert (GFC_CLASS_TYPE_P (TREE_TYPE (sym->backend_decl)));\n+      argse.expr = sym->backend_decl;\n       argse.expr = gfc_build_addr_expr (NULL_TREE,\n \t\t\t\t\tgfc_class_data_get (argse.expr));\n     }"}, {"sha": "4d10bfd0b0838704a18a5d52619c9078e358c11c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a51cf5491b642639b60ea12c0fff12a5403934/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a51cf5491b642639b60ea12c0fff12a5403934/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=16a51cf5491b642639b60ea12c0fff12a5403934", "patch": "@@ -1,3 +1,8 @@\n+2019-04-22  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/57284\n+\t* gfortran.dg/class_70.f03\n+\n 2019-04-21  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/90178"}, {"sha": "b689563916d30d2740338a2a1d6e0451da7ca8e2", "filename": "gcc/testsuite/gfortran.dg/class_70.f03", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16a51cf5491b642639b60ea12c0fff12a5403934/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_70.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16a51cf5491b642639b60ea12c0fff12a5403934/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_70.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_70.f03?ref=16a51cf5491b642639b60ea12c0fff12a5403934", "patch": "@@ -0,0 +1,38 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR57284 - [OOP] ICE with find_array_spec for polymorphic\n+! arrays. Once thw ICE was fixed, work was needed to fix a segfault while\n+! determining the size of 'z'.\n+!\n+! Contributed by Lorenz Huedepohl  <bugs@stellardeath.org>\n+!\n+module testmod\n+  type type_t\n+    integer :: idx\n+  end type type_t\n+  type type_u\n+     type(type_t), allocatable :: cmp(:)\n+  end type\n+contains\n+  function foo(a, b) result(add)\n+    class(type_t), intent(in) :: a(:), b(size(a))\n+    type(type_t) :: add(size(a))\n+    add%idx = a%idx + b%idx\n+  end function\n+end module testmod\n+program p\n+  use testmod\n+  class(type_t), allocatable, dimension(:) :: x, y, z\n+  class(type_u), allocatable :: w\n+  allocate (x, y, source = [type_t (1), type_t(2)])\n+  z = foo (x, y)\n+  if (any (z%idx .ne. [2, 4])) stop 1\n+\n+! Try something a bit more complicated than the original.\n+\n+  allocate (w)\n+  allocate (w%cmp, source = [type_t (2), type_t(3)])\n+  z = foo (w%cmp, y)\n+  if (any (z%idx .ne. [3, 5])) stop 2\n+  deallocate (w, x, y, z)\n+end program"}]}