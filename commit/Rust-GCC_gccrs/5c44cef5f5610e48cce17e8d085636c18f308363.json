{"sha": "5c44cef5f5610e48cce17e8d085636c18f308363", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWM0NGNlZjVmNTYxMGU0OGNjZTE3ZThkMDg1NjM2YzE4ZjMwODM2Mw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2019-11-12T21:21:13Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2019-11-12T21:21:13Z"}, "message": "[C++ PATCH] Merge some using-decl handling\n\nhttps://gcc.gnu.org/ml/gcc-patches/2019-11/msg00971.html\n\tgcc/cp/\n\t* name-lookup.c (lookup_using_decl): New function, merged from ...\n\t(do_class_using_decl): ... here.  Call it.  And ...\n\t(finish_nonmember_using_decl): ... here.  Call it.\n\n\tgcc/testsuite/\n\t* g++.dg/cpp0x/using-enum-2.C: Adjust expected error text.\n\t* g++.dg/cpp0x/using-enum-3.C: Likewise.\n\t* g++.dg/lookup/using4.C: Likewise.\n\t* g++.dg/lookup/using7.C: Likewise.\n\t* g++.dg/template/using12.C: Likewise.\n\t* g++.dg/template/using18.C: Likewise.\n\t* g++.dg/template/using22.C: Likewise.\n\nFrom-SVN: r278106", "tree": {"sha": "c4bf6c5ddc18d6176e8364d4344586e831cd3a7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4bf6c5ddc18d6176e8364d4344586e831cd3a7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c44cef5f5610e48cce17e8d085636c18f308363", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c44cef5f5610e48cce17e8d085636c18f308363", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c44cef5f5610e48cce17e8d085636c18f308363", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c44cef5f5610e48cce17e8d085636c18f308363/comments", "author": null, "committer": null, "parents": [{"sha": "3c72b04bf1b21ef6256844d06fd7e7b2db318eab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c72b04bf1b21ef6256844d06fd7e7b2db318eab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c72b04bf1b21ef6256844d06fd7e7b2db318eab"}], "stats": {"total": 291, "additions": 172, "deletions": 119}, "files": [{"sha": "bf50b1bcfa97d569e0a730c9fc551b90abaa2e46", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c44cef5f5610e48cce17e8d085636c18f308363/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c44cef5f5610e48cce17e8d085636c18f308363/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5c44cef5f5610e48cce17e8d085636c18f308363", "patch": "@@ -1,13 +1,19 @@\n+2019-11-12  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* name-lookup.c (lookup_using_decl): New function, merged from ...\n+\t(do_class_using_decl): ... here.  Call it.  And ...\n+\t(finish_nonmember_using_decl): ... here.  Call it.\n+\n 2019-11-12  Martin Liska  <mliska@suse.cz>\n \n \t* name-lookup.c: Do not include params.h.\n \t* typeck.c: Likewise.\n \n 2019-11-12  Martin Liska  <mliska@suse.cz>\n \n-\t* name-lookup.c (namespace_hints::namespace_hints): Replace old parameter syntax\n-\twith the new one, include opts.h if needed.  Use SET_OPTION_IF_UNSET\n-\tmacro.\n+\t* name-lookup.c (namespace_hints::namespace_hints): Replace old\n+\tparameter syntax with the new one, include opts.h if needed.  Use\n+\tSET_OPTION_IF_UNSET macro.\n \t* typeck.c (comptypes): Likewise.\n \n 2019-11-12  Maciej W. Rozycki  <macro@codesourcery.com>"}, {"sha": "b399b4ed39dbd0bf9a9d74d47d628aadddf71024", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 141, "deletions": 103, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c44cef5f5610e48cce17e8d085636c18f308363/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c44cef5f5610e48cce17e8d085636c18f308363/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=5c44cef5f5610e48cce17e8d085636c18f308363", "patch": "@@ -4584,102 +4584,166 @@ push_class_level_binding (tree name, tree x)\n   return ret;\n }\n \n-/* Process \"using SCOPE::NAME\" in a class scope.  Return the\n-   USING_DECL created.  */\n+/* Process and lookup a using decl SCOPE::lookup.name, filling in\n+   lookup.values & lookup.type.  Return true if ok.  */\n \n-tree\n-do_class_using_decl (tree scope, tree name)\n+static bool\n+lookup_using_decl (tree scope, name_lookup &lookup)\n {\n-  if (name == error_mark_node)\n-    return NULL_TREE;\n+  tree current = current_scope ();\n+  bool dependent_p = false;\n \n-  if (!scope || !TYPE_P (scope))\n+  if (TREE_CODE (scope) == NAMESPACE_DECL)\n     {\n-      error (\"using-declaration for non-member at class scope\");\n-      return NULL_TREE;\n-    }\n+      /* Naming a namespace member.  */\n+      if (TYPE_P (current))\n+\t{\n+\t  error (\"using-declaration for non-member at class scope\");\n+\t  return false;\n+\t}\n \n-  /* Make sure the name is not invalid */\n-  if (TREE_CODE (name) == BIT_NOT_EXPR)\n-    {\n-      error (\"%<%T::%D%> names destructor\", scope, name);\n-      return NULL_TREE;\n+      qualified_namespace_lookup (scope, &lookup);\n     }\n-\n-  /* Using T::T declares inheriting ctors, even if T is a typedef.  */\n-  if (MAYBE_CLASS_TYPE_P (scope)\n-      && (name == TYPE_IDENTIFIER (scope)\n-\t  || constructor_name_p (name, scope)))\n+  else if (TREE_CODE (scope) == ENUMERAL_TYPE)\n     {\n-      maybe_warn_cpp0x (CPP0X_INHERITING_CTORS);\n-      name = ctor_identifier;\n-      CLASSTYPE_NON_AGGREGATE (current_class_type) = true;\n-      TYPE_HAS_USER_CONSTRUCTOR (current_class_type) = true;\n+      error (\"using-declaration may not name enumerator %<%E::%D%>\",\n+\t     scope, lookup.name);\n+      return false;\n     }\n-\n-  /* Cannot introduce a constructor name.  */\n-  if (constructor_name_p (name, current_class_type))\n+  else\n     {\n-      error (\"%<%T::%D%> names constructor in %qT\",\n-\t     scope, name, current_class_type);\n-      return NULL_TREE;\n-    }\n+      /* Naming a class member.  */\n+      if (!TYPE_P (current))\n+\t{\n+\t  error (\"using-declaration for member at non-class scope\");\n+\t  return false;\n+\t}\n \n-  /* From [namespace.udecl]:\n+      /* Make sure the name is not invalid */\n+      if (TREE_CODE (lookup.name) == BIT_NOT_EXPR)\n+\t{\n+\t  error (\"%<%T::%D%> names destructor\", scope, lookup.name);\n+\t  return false;\n+\t}\n \n-       A using-declaration used as a member-declaration shall refer to a\n-       member of a base class of the class being defined.\n+      /* Using T::T declares inheriting ctors, even if T is a typedef.  */\n+      if (MAYBE_CLASS_TYPE_P (scope)\n+\t  && (lookup.name == TYPE_IDENTIFIER (scope)\n+\t      || constructor_name_p (lookup.name, scope)))\n+\t{\n+\t  maybe_warn_cpp0x (CPP0X_INHERITING_CTORS);\n+\t  lookup.name = ctor_identifier;\n+\t  CLASSTYPE_NON_AGGREGATE (current) = true;\n+\t  TYPE_HAS_USER_CONSTRUCTOR (current) = true;\n+    \t}\n+\n+      /* Cannot introduce a constructor name.  */\n+      if (constructor_name_p (lookup.name, current))\n+\t{\n+\t  error (\"%<%T::%D%> names constructor in %qT\",\n+\t\t scope, lookup.name, current);\n+\t  return false;\n+\t}\n \n-     In general, we cannot check this constraint in a template because\n-     we do not know the entire set of base classes of the current\n-     class type. Morover, if SCOPE is dependent, it might match a\n-     non-dependent base.  */\n+      /* Member using decls finish processing when completing the\n+\t class.  */\n+      /* From [namespace.udecl]:\n \n-  tree decl = NULL_TREE;\n-  if (!dependent_scope_p (scope))\n-    {\n-      base_kind b_kind;\n-      tree binfo = lookup_base (current_class_type, scope, ba_any, &b_kind,\n-\t\t\t\ttf_warning_or_error);\n-      if (b_kind < bk_proper_base)\n+         A using-declaration used as a member-declaration shall refer\n+         to a member of a base class of the class being defined.\n+\n+         In general, we cannot check this constraint in a template\n+         because we do not know the entire set of base classes of the\n+         current class type. Morover, if SCOPE is dependent, it might\n+         match a non-dependent base.  */\n+\n+      dependent_p = dependent_scope_p (scope);\n+      if (!dependent_p)\n \t{\n-\t  /* If there are dependent bases, scope might resolve at\n-\t     instantiation time, even if it isn't exactly one of the\n-\t     dependent bases.  */\n-\t  if (b_kind == bk_same_type || !any_dependent_bases_p ())\n+\t  base_kind b_kind;\n+\t  tree binfo = lookup_base (current, scope, ba_any, &b_kind,\n+\t\t\t\t    tf_warning_or_error);\n+\t  if (b_kind < bk_proper_base)\n+\t    {\n+\t      /* If there are dependent bases, scope might resolve at\n+\t\t instantiation time, even if it isn't exactly one of\n+\t\t the dependent bases.  */\n+\t      if (b_kind == bk_same_type || !any_dependent_bases_p ())\n+\t\t{\n+\t\t  error_not_base_type (scope, current);\n+\t\t  return false;\n+\t\t}\n+\t      /* Treat as-if dependent.  */\n+\t      dependent_p = true;\n+\t    }\n+\t  else if (lookup.name == ctor_identifier && !binfo_direct_p (binfo))\n \t    {\n-\t      error_not_base_type (scope, current_class_type);\n-\t      return NULL_TREE;\n+\t      error (\"cannot inherit constructors from indirect base %qT\",\n+\t\t     scope);\n+\t      return false;\n \t    }\n+\t  else if (IDENTIFIER_CONV_OP_P (lookup.name)\n+\t\t   && dependent_type_p (TREE_TYPE (lookup.name)))\n+\t    dependent_p = true;\n+\t  else\n+\t    lookup.value = lookup_member (binfo, lookup.name, 0,\n+\t\t\t\t\t  false, tf_warning_or_error);\n \t}\n-      else if (name == ctor_identifier && !binfo_direct_p (binfo))\n+    }\n+\n+  if (!dependent_p)\n+    {\n+      if (!lookup.value)\n \t{\n-\t  error (\"cannot inherit constructors from indirect base %qT\", scope);\n-\t  return NULL_TREE;\n+\t  error (\"%qD has not been declared in %qE\", lookup.name, scope);\n+\t  return false;\n \t}\n-      else if (!IDENTIFIER_CONV_OP_P (name)\n-\t       || !dependent_type_p (TREE_TYPE (name)))\n+\n+      if (TREE_CODE (lookup.value) == TREE_LIST\n+\t  /* We can (independently) have ambiguous implicit typedefs.  */\n+\t  || (lookup.type && TREE_CODE (lookup.type) == TREE_LIST))\n \t{\n-\t  decl = lookup_member (binfo, name, 0, false, tf_warning_or_error);\n-\t  if (!decl)\n-\t    {\n-\t      error (\"no members matching %<%T::%D%> in %q#T\", scope, name,\n-\t\t     scope);\n-\t      return NULL_TREE;\n-\t    }\n+\t  error (\"reference to %qD is ambiguous\", lookup.name);\n+\t  print_candidates (TREE_CODE (lookup.value) == TREE_LIST\n+\t\t\t    ? lookup.value : lookup.type);\n+\t  return false;\n+\t}\n \n-\t  /* The binfo from which the functions came does not matter.  */\n-\t  if (BASELINK_P (decl))\n-\t    decl = BASELINK_FUNCTIONS (decl);\n+      if (TREE_CODE (lookup.value) == NAMESPACE_DECL)\n+\t{\n+\t  error (\"using-declaration may not name namespace %qD\", lookup.value);\n+\t  return false;\n \t}\n     }\n \n-  tree value = build_lang_decl (USING_DECL, name, NULL_TREE);\n-  USING_DECL_DECLS (value) = decl;\n-  USING_DECL_SCOPE (value) = scope;\n-  DECL_DEPENDENT_P (value) = !decl;\n+  return true;\n+}\n+\n+/* Process \"using SCOPE::NAME\" in a class scope.  Return the\n+   USING_DECL created.  */\n+\n+tree\n+do_class_using_decl (tree scope, tree name)\n+{\n+  if (name == error_mark_node\n+      || scope == error_mark_node)\n+    return NULL_TREE;\n+\n+  name_lookup lookup (name, 0);\n+  if (!lookup_using_decl (scope, lookup))\n+    return NULL_TREE;\n+\n+  tree found = lookup.value;\n+  if (found && BASELINK_P (found))\n+    /* The binfo from which the functions came does not matter.  */\n+    found = BASELINK_FUNCTIONS (found);\n+\n+  tree using_decl = build_lang_decl (USING_DECL, lookup.name, NULL_TREE);\n+  USING_DECL_SCOPE (using_decl) = scope;\n+  USING_DECL_DECLS (using_decl) = found;\n+  DECL_DEPENDENT_P (using_decl) = !found;\n \n-  return value;\n+  return using_decl;\n }\n \n \f\n@@ -5046,39 +5110,14 @@ void\n finish_nonmember_using_decl (tree scope, tree name)\n {\n   gcc_checking_assert (current_binding_level->kind != sk_class);\n-  gcc_checking_assert (identifier_p (name));\n \n-  name_lookup lookup (name, 0);\n-\n-  if (TREE_CODE (scope) != NAMESPACE_DECL)\n-    {\n-      error (\"%qE is not a namespace or unscoped enum\", scope);\n-      return;\n-    }\n-\n-  qualified_namespace_lookup (scope, &lookup);\n-\n-  if (!lookup.value)\n-    {\n-      error (\"%qD has not been declared in %qE\", name, scope);\n-      return;\n-    }\n+  if (scope == error_mark_node || name == error_mark_node)\n+    return;\n \n-  if (TREE_CODE (lookup.value) == TREE_LIST\n-      /* But we can (independently) have ambiguous implicit typedefs.  */\n-      || (lookup.type && TREE_CODE (lookup.type) == TREE_LIST))\n-    {\n-      error (\"reference to %qD is ambiguous\", name);\n-      print_candidates (TREE_CODE (lookup.value) == TREE_LIST\n-\t\t\t? lookup.value : lookup.type);\n-      return;\n-    }\n+  name_lookup lookup (name, 0);\n \n-  if (TREE_CODE (lookup.value) == NAMESPACE_DECL)\n-    {\n-      error (\"using-declaration may not name namespace %qD\", lookup.value);\n-      return;\n-    }\n+  if (!lookup_using_decl (scope, lookup))\n+    return;\n \n   /* Emit debug info.  */\n   if (!processing_template_decl)\n@@ -5106,7 +5145,7 @@ finish_nonmember_using_decl (tree scope, tree name)\n     }\n   else\n     {\n-      tree using_decl = build_lang_decl (USING_DECL, name, NULL_TREE);\n+      tree using_decl = build_lang_decl (USING_DECL, lookup.name, NULL_TREE);\n       USING_DECL_SCOPE (using_decl) = scope;\n       add_decl_expr (using_decl);\n \n@@ -5147,7 +5186,6 @@ finish_nonmember_using_decl (tree scope, tree name)\n \t  set_identifier_type_value (name, type);\n \t}\n     }\n-\n }\n \n /* Return the declarations that are members of the namespace NS.  */"}, {"sha": "a03b6844d290ee437a58c7606b94b0d0be193734", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c44cef5f5610e48cce17e8d085636c18f308363/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c44cef5f5610e48cce17e8d085636c18f308363/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5c44cef5f5610e48cce17e8d085636c18f308363", "patch": "@@ -1,3 +1,13 @@\n+2019-11-12  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* g++.dg/cpp0x/using-enum-2.C: Adjust expected error text.\n+\t* g++.dg/cpp0x/using-enum-3.C: Likewise.\n+\t* g++.dg/lookup/using4.C: Likewise.\n+\t* g++.dg/lookup/using7.C: Likewise.\n+\t* g++.dg/template/using12.C: Likewise.\n+\t* g++.dg/template/using18.C: Likewise.\n+\t* g++.dg/template/using22.C: Likewise.\n+\n 2019-11-12  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR target/92449"}, {"sha": "faa381793055fd851509b628b5b10f2e03dd1afd", "filename": "gcc/testsuite/g++.dg/cpp0x/using-enum-2.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c44cef5f5610e48cce17e8d085636c18f308363/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fusing-enum-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c44cef5f5610e48cce17e8d085636c18f308363/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fusing-enum-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fusing-enum-2.C?ref=5c44cef5f5610e48cce17e8d085636c18f308363", "patch": "@@ -5,16 +5,16 @@ namespace A\n {\n   enum class E { V };\n \n-  using E::V;        // { dg-error \"not a namespace or unscoped enum\" }\n+  using E::V;        // { dg-error \"name enumerator\" }\n }\n \n void foo()\n {\n-  using A::E::V;     // { dg-error \"not a namespace or unscoped enum\" }\n+  using A::E::V;     // { dg-error \"name enumerator\" }\n }\n \n-using A::E::V;       // { dg-error \"not a namespace or unscoped enum\" }\n+using A::E::V;       // { dg-error \"name enumerator\" }\n \n enum class F { U };\n \n-using F::U;          // { dg-error \"not a namespace or unscoped enum\" }\n+using F::U;          // { dg-error \"name enumerator\" }"}, {"sha": "ecc4ddcccd86a38553113f1a26e726e733be886e", "filename": "gcc/testsuite/g++.dg/cpp0x/using-enum-3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c44cef5f5610e48cce17e8d085636c18f308363/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fusing-enum-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c44cef5f5610e48cce17e8d085636c18f308363/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fusing-enum-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fusing-enum-3.C?ref=5c44cef5f5610e48cce17e8d085636c18f308363", "patch": "@@ -4,7 +4,7 @@\n void f ()\n {\n   enum e { a };\n-  using e::a; // { dg-error \"not a namespace or unscoped enum\" }\n+  using e::a; // { dg-error \"name enumerator\" }\n }\n \n struct S {"}, {"sha": "facb2b4fd31d981a4b8db3a732bc7c711381769b", "filename": "gcc/testsuite/g++.dg/lookup/using4.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c44cef5f5610e48cce17e8d085636c18f308363/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c44cef5f5610e48cce17e8d085636c18f308363/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing4.C?ref=5c44cef5f5610e48cce17e8d085636c18f308363", "patch": "@@ -10,6 +10,6 @@ template <class T>\n struct Bar : public Foo<T> {\n         void foo()\n         {\n-                using Foo<T>::i;\t// { dg-error \"not a namespace\" }\n+                using Foo<T>::i;\t// { dg-error \"member at non-class scope\" }\n         }\n };"}, {"sha": "d92bf23d71d28ba15f642395a70958803af5c797", "filename": "gcc/testsuite/g++.dg/lookup/using7.C", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c44cef5f5610e48cce17e8d085636c18f308363/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c44cef5f5610e48cce17e8d085636c18f308363/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Fusing7.C?ref=5c44cef5f5610e48cce17e8d085636c18f308363", "patch": "@@ -6,7 +6,6 @@ template <typename T, bool=T::X> struct A\n template <typename T> struct B : A<T> // { dg-error \"incomplete\" }\n {\n   using A<T>::i; // { dg-error \"incomplete\" \"incomplete\" } \n-                 // { dg-error \"using\" \"using\" { target *-*-* } .-1 }\n };\n \n B<void> b; // { dg-message \"required\" }"}, {"sha": "0b652350e2a96d83a3fa8db310b7ee1cfc68ea19", "filename": "gcc/testsuite/g++.dg/template/using12.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c44cef5f5610e48cce17e8d085636c18f308363/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c44cef5f5610e48cce17e8d085636c18f308363/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing12.C?ref=5c44cef5f5610e48cce17e8d085636c18f308363", "patch": "@@ -3,5 +3,5 @@ struct A {\n \n template <typename T>\n struct S : public A {\n-  using A::operator(); // { dg-error \"no member\" }\n+  using A::operator(); // { dg-error \"has not been declared\" }\n };"}, {"sha": "caafdcfe1405d582e93722cac63bd4e76a71c2de", "filename": "gcc/testsuite/g++.dg/template/using18.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c44cef5f5610e48cce17e8d085636c18f308363/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing18.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c44cef5f5610e48cce17e8d085636c18f308363/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing18.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing18.C?ref=5c44cef5f5610e48cce17e8d085636c18f308363", "patch": "@@ -25,7 +25,7 @@ template <class T> struct B2 {};\n template <class T>\n struct C : B1, B2<T>\n {\n-    using B1::x; // { dg-error \"no member\" }\n+    using B1::x; // { dg-error \"has not been declared\" }\n     using B2<T>::y;\n     using typename B2<T>::type;\n };"}, {"sha": "041b5c1348fcde8557160a970490e3a266e020d8", "filename": "gcc/testsuite/g++.dg/template/using22.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c44cef5f5610e48cce17e8d085636c18f308363/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing22.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c44cef5f5610e48cce17e8d085636c18f308363/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing22.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fusing22.C?ref=5c44cef5f5610e48cce17e8d085636c18f308363", "patch": "@@ -16,25 +16,25 @@ struct A\n template <class T>\n struct A<T>::B : A<T>\n {\n-  using A::nonexist; // { dg-error \"no members matching\" }\n+  using A::nonexist; // { dg-error \"has not been declared\" }\n };\n \n template <class T>\n struct A<T>::C : A\n {\n-  using A::nonexist; // { dg-error \"no members matching\" }\n+  using A::nonexist; // { dg-error \"has not been declared\" }\n };\n \n template <class T>\n struct A<T>::D : A<T>\n {\n-  using A<T>::nonexist; // { dg-error \"no members matching\" }\n+  using A<T>::nonexist; // { dg-error \"has not been declared\" }\n };\n \n template <class T>\n struct A<T>::E : A\n {\n-  using A<T>::nonexist; // { dg-error \"no members matching\" }\n+  using A<T>::nonexist; // { dg-error \"has not been declared\" }\n };\n \n template <class T>"}]}