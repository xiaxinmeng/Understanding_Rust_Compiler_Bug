{"sha": "d0d8b5d83614d8f0d0e40c0520d4f40ffa01f8d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDBkOGI1ZDgzNjE0ZDhmMGQwZTQwYzA1MjBkNGY0MGZmYTAxZjhkOQ==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-11-19T22:41:30Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2020-11-19T22:41:30Z"}, "message": "Process only valid shift ranges.\n\nWhen shifting outside the valid range of [0, precision-1], we can\nchoose to process just the valid ones since the rest is undefined.\nthis allows us to produce results for x << [0,2][+INF, +INF] by discarding\nthe invalid ranges and processing just [0,2].\n\n\tgcc/\n\tPR tree-optimization/93781\n\t* range-op.cc (get_shift_range): Rename from\n\tundefined_shift_range_check and now return valid shift ranges.\n\t(operator_lshift::fold_range): Use result from get_shift_range.\n\t(operator_rshift::fold_range): Ditto.\n\tgcc/testsuite/\n\t* gcc.dg/tree-ssa/pr93781-1.c: New.\n\t* gcc.dg/tree-ssa/pr93781-2.c: New.\n\t* gcc.dg/tree-ssa/pr93781-3.c: New.", "tree": {"sha": "b3e41b7114dececa7aad5faf4b314771673d2b2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3e41b7114dececa7aad5faf4b314771673d2b2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d0d8b5d83614d8f0d0e40c0520d4f40ffa01f8d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0d8b5d83614d8f0d0e40c0520d4f40ffa01f8d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0d8b5d83614d8f0d0e40c0520d4f40ffa01f8d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0d8b5d83614d8f0d0e40c0520d4f40ffa01f8d9/comments", "author": null, "committer": null, "parents": [{"sha": "5bba2215c23d71ea08fb81656d93041229f7ea9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bba2215c23d71ea08fb81656d93041229f7ea9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bba2215c23d71ea08fb81656d93041229f7ea9c"}], "stats": {"total": 120, "additions": 92, "deletions": 28}, "files": [{"sha": "5bf37e1ad821f1e718481fcb445f3f8dda7f21f5", "filename": "gcc/range-op.cc", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d8b5d83614d8f0d0e40c0520d4f40ffa01f8d9/gcc%2Frange-op.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d8b5d83614d8f0d0e40c0520d4f40ffa01f8d9/gcc%2Frange-op.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op.cc?ref=d0d8b5d83614d8f0d0e40c0520d4f40ffa01f8d9", "patch": "@@ -80,30 +80,25 @@ empty_range_varying (irange &r, tree type,\n     return false;\n }\n \n-// Return TRUE if shifting by OP is undefined behavior, and set R to\n-// the appropriate range.\n+// Return false if shifting by OP is undefined behavior.  Otherwise, return\n+// true and the range it is to be shifted by.  This allows trimming out of\n+// undefined ranges, leaving only valid ranges if there are any.\n \n static inline bool\n-undefined_shift_range_check (irange &r, tree type, const irange &op)\n+get_shift_range (irange &r, tree type, const irange &op)\n {\n   if (op.undefined_p ())\n-    {\n-      r.set_undefined ();\n-      return true;\n-    }\n+    return false;\n \n-  // Shifting by any values outside [0..prec-1], gets undefined\n-  // behavior from the shift operation.  We cannot even trust\n-  // SHIFT_COUNT_TRUNCATED at this stage, because that applies to rtl\n-  // shifts, and the operation at the tree level may be widened.\n-  if (wi::lt_p (op.lower_bound (), 0, TYPE_SIGN (op.type ()))\n-      || wi::ge_p (op.upper_bound (),\n-\t\t   TYPE_PRECISION (type), TYPE_SIGN (op.type ())))\n-    {\n-      r.set_varying (type);\n-      return true;\n-    }\n-  return false;\n+  // Build valid range and intersect it with the shift range.\n+  r = value_range (build_int_cst_type (op.type (), 0),\n+\t\t   build_int_cst_type (op.type (), TYPE_PRECISION (type) - 1));\n+  r.intersect (op);\n+\n+  // If there are no valid ranges in the shift range, returned false.\n+  if (r.undefined_p ())\n+    return false;\n+  return true;\n }\n \n // Return TRUE if 0 is within [WMIN, WMAX].\n@@ -1465,13 +1460,20 @@ operator_lshift::fold_range (irange &r, tree type,\n \t\t\t     const irange &op1,\n \t\t\t     const irange &op2) const\n {\n-  if (undefined_shift_range_check (r, type, op2))\n-    return true;\n+  int_range_max shift_range;\n+  if (!get_shift_range (shift_range, type, op2))\n+    {\n+      if (op2.undefined_p ())\n+\tr.set_undefined ();\n+      else\n+\tr.set_varying (type);\n+      return true;\n+    }\n \n   // Transform left shifts by constants into multiplies.\n-  if (op2.singleton_p ())\n+  if (shift_range.singleton_p ())\n     {\n-      unsigned shift = op2.lower_bound ().to_uhwi ();\n+      unsigned shift = shift_range.lower_bound ().to_uhwi ();\n       wide_int tmp = wi::set_bit_in_zero (shift, TYPE_PRECISION (type));\n       int_range<1> mult (type, tmp, tmp);\n \n@@ -1487,7 +1489,7 @@ operator_lshift::fold_range (irange &r, tree type,\n     }\n   else\n     // Otherwise, invoke the generic fold routine.\n-    return range_operator::fold_range (r, type, op1, op2);\n+    return range_operator::fold_range (r, type, op1, shift_range);\n }\n \n void\n@@ -1709,11 +1711,17 @@ operator_rshift::fold_range (irange &r, tree type,\n \t\t\t     const irange &op1,\n \t\t\t     const irange &op2) const\n {\n-  // Invoke the generic fold routine if not undefined..\n-  if (undefined_shift_range_check (r, type, op2))\n-    return true;\n+  int_range_max shift;\n+  if (!get_shift_range (shift, type, op2))\n+    {\n+      if (op2.undefined_p ())\n+\tr.set_undefined ();\n+      else\n+\tr.set_varying (type);\n+      return true;\n+    }\n \n-  return range_operator::fold_range (r, type, op1, op2);\n+  return range_operator::fold_range (r, type, op1, shift);\n }\n \n void"}, {"sha": "5ebd8053965926fd30f57fdfb216622906b5e7d4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr93781-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d8b5d83614d8f0d0e40c0520d4f40ffa01f8d9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93781-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d8b5d83614d8f0d0e40c0520d4f40ffa01f8d9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93781-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93781-1.c?ref=d0d8b5d83614d8f0d0e40c0520d4f40ffa01f8d9", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-evrp\" } */\n+\n+void kill (void);\n+\n+void foo (unsigned int arg)\n+{\n+  int a = arg - 3;\n+  unsigned int b = 4;\n+  int x = 0x1 << arg;\n+\n+  if (a < 0)\n+    b = x;\n+\n+  /* In the fullness of time, we will delete this call.  */\n+  if (b >=  5)\n+    kill ();;\n+}"}, {"sha": "c9b28783c1249641ad94b5a05c4b81fd3fb40c90", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr93781-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d8b5d83614d8f0d0e40c0520d4f40ffa01f8d9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93781-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d8b5d83614d8f0d0e40c0520d4f40ffa01f8d9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93781-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93781-2.c?ref=d0d8b5d83614d8f0d0e40c0520d4f40ffa01f8d9", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-evrp\" } */\n+\n+void kill (void);\n+\n+void foo (unsigned int arg)\n+{\n+  unsigned int C000003FE = 4;\n+\n+  if (arg + 1 < 4)  // work for if (arg < 3)\n+     C000003FE = 0x1 << arg;\n+\n+  if (C000003FE >= 5)\n+    kill ();\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"kill\" \"evrp\" } } */"}, {"sha": "e1d2be0ea7fc031de7db5275bb579e66da2afb2f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr93781-3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d0d8b5d83614d8f0d0e40c0520d4f40ffa01f8d9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93781-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d0d8b5d83614d8f0d0e40c0520d4f40ffa01f8d9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93781-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr93781-3.c?ref=d0d8b5d83614d8f0d0e40c0520d4f40ffa01f8d9", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-evrp\" } */\n+\n+void kill (void);\n+\n+void foo (unsigned int arg)\n+{\n+  int a = arg - 3;\n+  unsigned int b = 4;\n+\n+  if (a < 0)\n+    {\n+      int x = 0x1 << arg;\n+      b = x;\n+    }\n+\n+  if (b >=  5)\n+   kill ();\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"kill\" \"evrp\" } } */"}]}