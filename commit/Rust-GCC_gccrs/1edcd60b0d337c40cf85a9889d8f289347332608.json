{"sha": "1edcd60b0d337c40cf85a9889d8f289347332608", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWVkY2Q2MGIwZDMzN2M0MGNmODVhOTg4OWQ4ZjI4OTM0NzMzMjYwOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-11-12T10:15:03Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-11-12T10:15:03Z"}, "message": "* alias.c (nonoverlapping_memrefs_p): Handle DECL_RTL being a CONCAT.\n\nFrom-SVN: r46938", "tree": {"sha": "bcaa88e4d48cf3c7d186f590ed538c6229008cf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcaa88e4d48cf3c7d186f590ed538c6229008cf5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1edcd60b0d337c40cf85a9889d8f289347332608", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1edcd60b0d337c40cf85a9889d8f289347332608", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1edcd60b0d337c40cf85a9889d8f289347332608", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1edcd60b0d337c40cf85a9889d8f289347332608/comments", "author": null, "committer": null, "parents": [{"sha": "769828abaf9a87ba043a0b958c1bb5d1833cf6e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/769828abaf9a87ba043a0b958c1bb5d1833cf6e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/769828abaf9a87ba043a0b958c1bb5d1833cf6e3"}], "stats": {"total": 21, "additions": 13, "deletions": 8}, "files": [{"sha": "60f3e46fbb4923d764fa36e51416fdf81be948f6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1edcd60b0d337c40cf85a9889d8f289347332608/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1edcd60b0d337c40cf85a9889d8f289347332608/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1edcd60b0d337c40cf85a9889d8f289347332608", "patch": "@@ -1,3 +1,7 @@\n+Mon Nov 12 05:18:42 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* alias.c (nonoverlapping_memrefs_p): Handle DECL_RTL being a CONCAT.\n+\n 2001-11-12  Kazu Hirata  <kazu@hxi.com>\n \n \t* config/h8300/h8300.c (shift_alg_qi): New."}, {"sha": "45e82643ad7bacd7ce0c5795b797fd81ba1b76ef", "filename": "gcc/alias.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1edcd60b0d337c40cf85a9889d8f289347332608/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1edcd60b0d337c40cf85a9889d8f289347332608/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=1edcd60b0d337c40cf85a9889d8f289347332608", "patch": "@@ -1780,21 +1780,22 @@ nonoverlapping_memrefs_p (x, y)\n   rtlx = DECL_RTL (MEM_DECL (x));\n   rtly = DECL_RTL (MEM_DECL (y));\n \n-  /* If either RTL is a REG, they can't overlap unless they are the same\n-     because we never reuse that part of the stack frame used for locals for\n-     spilled pseudos.  */\n-  if ((REG_P (rtlx) || REG_P (rtly)) && ! rtx_equal_p (rtlx, rtly))\n+  /* If either RTL is not a MEM, it must be a REG or CONCAT, meaning they\n+     can't overlap unless they are the same because we never reuse that part\n+     of the stack frame used for locals for spilled pseudos.  */\n+  if ((GET_CODE (rtlx) != MEM || GET_CODE (rtly) != MEM)\n+      && ! rtx_equal_p (rtlx, rtly))\n     return 1;\n \n   /* Get the base and offsets of both decls.  If either is a register, we\n      know both are and are the same, so use that as the base.  The only\n      we can avoid overlap is if we can deduce that they are nonoverlapping\n      pieces of that decl, which is very rare.  */\n-  basex = REG_P (rtlx) ? rtlx : XEXP (rtlx, 0);\n+  basex = GET_CODE (rtlx) == MEM ? XEXP (rtlx, 0) : rtlx;\n   if (GET_CODE (basex) == PLUS && GET_CODE (XEXP (basex, 1)) == CONST_INT)\n     offsetx = INTVAL (XEXP (basex, 1)), basex = XEXP (basex, 0);\n \n-  basey = REG_P (rtly) ? rtly : XEXP (rtly, 0);\n+  basey = GET_CODE (rtly) == MEM ? XEXP (rtly, 0) : rtly;\n   if (GET_CODE (basey) == PLUS && GET_CODE (XEXP (basey, 1)) == CONST_INT)\n     offsety = INTVAL (XEXP (basey, 1)), basey = XEXP (basey, 0);\n \n@@ -1809,10 +1810,10 @@ nonoverlapping_memrefs_p (x, y)\n \t      || (CONSTANT_P (basey) && REG_P (basex)\n \t\t  && REGNO (basex) <= LAST_VIRTUAL_REGISTER));\n \n-  sizex = (REG_P (rtlx) ? GET_MODE_SIZE (GET_MODE (rtlx))\n+  sizex = (GET_CODE (rtlx) != MEM ? GET_MODE_SIZE (GET_MODE (rtlx))\n \t   : MEM_SIZE (rtlx) ? INTVAL (MEM_SIZE (rtlx))\n \t   : -1);\n-  sizey = (REG_P (rtly) ? GET_MODE_SIZE (GET_MODE (rtly))\n+  sizey = (GET_CODE (rtly) != MEM ? GET_MODE_SIZE (GET_MODE (rtly))\n \t   : MEM_SIZE (rtly) ? INTVAL (MEM_SIZE (rtly)) :\n \t   -1);\n "}]}