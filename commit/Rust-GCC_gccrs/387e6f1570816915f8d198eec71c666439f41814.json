{"sha": "387e6f1570816915f8d198eec71c666439f41814", "node_id": "C_kwDOANBUbNoAKDM4N2U2ZjE1NzA4MTY5MTVmOGQxOThlZWM3MWM2NjY0MzlmNDE4MTQ", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-08-26T07:45:19Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2022-08-26T07:45:19Z"}, "message": "libgfortran: Use __builtin_issignaling in libgfortran [PR105105]\n\nThe following patch makes use of the new __builtin_issignaling,\nso it no longer needs the fallback implementation and can use\nthe builtin even where glibc provides the macro.\n\n2022-08-26  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR fortran/105105\n\t* ieee/ieee_helper.c: Don't include issignaling_fallback.h.\n\t(CLASSMACRO): Use __builtin_issignaling instead of issignaling.\n\t* ieee/issignaling_fallback.h: Removed.", "tree": {"sha": "5fc7ffef0eb6b614cd2b223bbc26ab949e313ab2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5fc7ffef0eb6b614cd2b223bbc26ab949e313ab2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/387e6f1570816915f8d198eec71c666439f41814", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/387e6f1570816915f8d198eec71c666439f41814", "html_url": "https://github.com/Rust-GCC/gccrs/commit/387e6f1570816915f8d198eec71c666439f41814", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/387e6f1570816915f8d198eec71c666439f41814/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0982edd371d5429d24615442e96e76ba6bc4faa9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0982edd371d5429d24615442e96e76ba6bc4faa9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0982edd371d5429d24615442e96e76ba6bc4faa9"}], "stats": {"total": 260, "additions": 1, "deletions": 259}, "files": [{"sha": "1351b1ff54c77f799ec108d73224d663263283b7", "filename": "libgfortran/ieee/ieee_helper.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/387e6f1570816915f8d198eec71c666439f41814/libgfortran%2Fieee%2Fieee_helper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/387e6f1570816915f8d198eec71c666439f41814/libgfortran%2Fieee%2Fieee_helper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fieee%2Fieee_helper.c?ref=387e6f1570816915f8d198eec71c666439f41814", "patch": "@@ -26,13 +26,6 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"libgfortran.h\"\n \n \n-/* Check support for issignaling macro.  If not, we include our own\n-   fallback implementation.  */\n-#ifndef issignaling\n-# include \"issignaling_fallback.h\"\n-#endif\n-\n-\n /* Prototypes.  */\n \n extern int ieee_class_helper_4 (GFC_REAL_4 *);\n@@ -94,7 +87,7 @@ enum {\n  \\\n     if (res == IEEE_QUIET_NAN) \\\n     { \\\n-      if (issignaling (*value)) \\\n+      if (__builtin_issignaling (*value)) \\\n \treturn IEEE_SIGNALING_NAN; \\\n       else \\\n \treturn IEEE_QUIET_NAN; \\"}, {"sha": "698c3f2edc9313c571aced60c1ab2b9d7612ad53", "filename": "libgfortran/ieee/issignaling_fallback.h", "status": "removed", "additions": 0, "deletions": 251, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0982edd371d5429d24615442e96e76ba6bc4faa9/libgfortran%2Fieee%2Fissignaling_fallback.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0982edd371d5429d24615442e96e76ba6bc4faa9/libgfortran%2Fieee%2Fissignaling_fallback.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fieee%2Fissignaling_fallback.h?ref=0982edd371d5429d24615442e96e76ba6bc4faa9", "patch": "@@ -1,251 +0,0 @@\n-/* Fallback implementation of issignaling macro.\n-   Copyright (C) 2022 Free Software Foundation, Inc.\n-   Contributed by Francois-Xavier Coudert <fxcoudert@gcc.gnu.org>\n-\n-This file is part of the GNU Fortran runtime library (libgfortran).\n-\n-Libgfortran is free software; you can redistribute it and/or\n-modify it under the terms of the GNU General Public\n-License as published by the Free Software Foundation; either\n-version 3 of the License, or (at your option) any later version.\n-\n-Libgfortran is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-Under Section 7 of GPL version 3, you are granted additional\n-permissions described in the GCC Runtime Library Exception, version\n-3.1, as published by the Free Software Foundation.\n-\n-You should have received a copy of the GNU General Public License and\n-a copy of the GCC Runtime Library Exception along with this program;\n-see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"libgfortran.h\"\n-\n-/* This header provides an implementation of the type-generic issignaling macro.\n-   Some points of note:\n-\n-     - This header is only included if the issignaling macro is not defined.\n-     - All targets for which Fortran IEEE modules are supported currently have\n-       the high-order bit of the NaN mantissa clear for signaling (and set\n-       for quiet), as recommended by IEEE.\n-     - We use the __*_IS_IEC_60559__ macros to make sure we only deal with formats\n-       we know. For other floating-point formats, we consider all NaNs as quiet.\n-\n- */\n-\n-typedef union\n-{\n-  float value;\n-  uint32_t word;\n-} ieee_float_shape_type;\n-\n-static inline int\n-__issignalingf (float x)\n-{\n-#if __FLT_IS_IEC_60559__\n-  uint32_t xi;\n-  ieee_float_shape_type u;\n-\n-  u.value = x;\n-  xi = u.word;\n-\n-  xi ^= 0x00400000;\n-  return (xi & 0x7fffffff) > 0x7fc00000;\n-#else\n-  return 0;\n-#endif\n-}\n-\n-\n-typedef union\n-{\n-  double value;\n-  uint64_t word;\n-} ieee_double_shape_type;\n-\n-static inline int\n-__issignaling (double x)\n-{\n-#if __DBL_IS_IEC_60559__\n-  ieee_double_shape_type u;\n-  uint64_t xi;\n-\n-  u.value = x;\n-  xi = u.word;\n-\n-  xi ^= UINT64_C (0x0008000000000000);\n-  return (xi & UINT64_C (0x7fffffffffffffff)) > UINT64_C (0x7ff8000000000000);\n-#else\n-  return 0;\n-#endif\n-}\n-\n-\n-#if __LDBL_DIG__ == __DBL_DIG__\n-\n-/* Long double is the same as double.  */\n-static inline int\n-__issignalingl (long double x)\n-{\n-  return __issignaling (x);\n-}\n-\n-#elif (__LDBL_DIG__ == 18) && __LDBL_IS_IEC_60559__\n-\n-/* Long double is x86 extended type.  */\n-\n-typedef union\n-{\n-  long double value;\n-  struct\n-  {\n-#if __FLOAT_WORD_ORDER__ == __ORDER_BIG_ENDIAN__\n-    int sign_exponent:16;\n-    unsigned int empty:16;\n-    uint32_t msw;\n-    uint32_t lsw;\n-#elif __FLOAT_WORD_ORDER__ == __ORDER_LITTLE_ENDIAN__\n-    uint32_t lsw;\n-    uint32_t msw;\n-    int sign_exponent:16;\n-    unsigned int empty:16;\n-#endif\n-  } parts;\n-} ieee_long_double_shape_type;\n-\n-static inline int\n-__issignalingl (long double x)\n-{\n-  int ret;\n-  uint32_t exi, hxi, lxi;\n-  ieee_long_double_shape_type u;\n-\n-  u.value = x;\n-  exi = u.parts.sign_exponent;\n-  hxi = u.parts.msw;\n-  lxi = u.parts.lsw;\n-\n-  /* Pseudo numbers on x86 are always signaling.  */\n-  ret = (exi & 0x7fff) && ((hxi & 0x80000000) == 0);\n-\n-  hxi ^= 0x40000000;\n-  hxi |= (lxi | -lxi) >> 31;\n-  return ret || (((exi & 0x7fff) == 0x7fff) && (hxi > 0xc0000000));\n-}\n-\n-#elif (__LDBL_DIG__ == 31)\n-\n-/* Long double is 128-bit IBM extended type.  */\n-\n-static inline int\n-__issignalingl (long double x)\n-{\n-  union { long double value; double parts[2]; } u;\n-\n-  u.value = x;\n-  return __issignaling (u.parts[0]);\n-}\n-\n-#elif (__LDBL_DIG__ == 33) && __LDBL_IS_IEC_60559__\n-\n-/* Long double is 128-bit type.  */\n-\n-typedef union\n-{\n-  long double value;\n-  struct\n-  {\n-#if __FLOAT_WORD_ORDER__ == __ORDER_BIG_ENDIAN__\n-    uint64_t msw;\n-    uint64_t lsw;\n-#elif __FLOAT_WORD_ORDER__ == __ORDER_LITTLE_ENDIAN__\n-    uint64_t lsw;\n-    uint64_t msw;\n-#endif\n-  } parts64;\n-} ieee854_long_double_shape_type;\n-\n-static inline int\n-__issignalingl (long double x)\n-{\n-  uint64_t hxi, lxi;\n-  ieee854_long_double_shape_type u;\n-\n-  u.value = x;\n-  hxi = u.parts64.msw;\n-  lxi = u.parts64.lsw;\n-\n-  hxi ^= UINT64_C (0x0000800000000000);\n-  hxi |= (lxi | -lxi) >> 63;\n-  return (hxi & UINT64_C (0x7fffffffffffffff)) > UINT64_C (0x7fff800000000000);\n-}\n-\n-#else\n-\n-static inline int\n-__issignalingl (long double x)\n-{\n-  return 0;\n-}\n-\n-#endif\n-\n-\n-#if defined(GFC_REAL_16_IS_FLOAT128)\n-\n-/* We have a _Float128 type.  */\n-\n-typedef union\n-{\n-  _Float128 value;\n-  struct\n-  {\n-#if __FLOAT_WORD_ORDER__ == __ORDER_BIG_ENDIAN__\n-    uint64_t msw;\n-    uint64_t lsw;\n-#elif __FLOAT_WORD_ORDER__ == __ORDER_LITTLE_ENDIAN__\n-    uint64_t lsw;\n-    uint64_t msw;\n-#endif\n-  } parts64;\n-} ieee854_float128_shape_type;\n-\n-static inline int\n-__issignalingf128 (_Float128 x)\n-{\n-  uint64_t hxi, lxi;\n-  ieee854_float128_shape_type u;\n-\n-  u.value = x;\n-  hxi = u.parts64.msw;\n-  lxi = u.parts64.lsw;\n-\n-  hxi ^= UINT64_C (0x0000800000000000);\n-  hxi |= (lxi | -lxi) >> 63;\n-  return (hxi & UINT64_C (0x7fffffffffffffff)) > UINT64_C (0x7fff800000000000);\n-}\n-\n-#endif\n-\n-\n-/* Define the type-generic macro based on the functions above.  */\n-\n-#if defined(GFC_REAL_16_IS_FLOAT128)\n-# define issignaling(X) \\\n-  _Generic ((X), \\\n-\t    _Float128: __issignalingf128, \\\n-\t    float: __issignalingf, \\\n-\t    double: __issignaling, \\\n-\t    long double: __issignalingl)(X)\n-#else\n-# define issignaling(X) \\\n-  _Generic ((X), \\\n-\t    float: __issignalingf, \\\n-\t    double: __issignaling, \\\n-\t    long double: __issignalingl)(X)\n-#endif\n-"}]}