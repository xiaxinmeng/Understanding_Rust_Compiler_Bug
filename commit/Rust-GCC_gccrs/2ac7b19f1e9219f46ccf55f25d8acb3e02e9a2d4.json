{"sha": "2ac7b19f1e9219f46ccf55f25d8acb3e02e9a2d4", "node_id": "C_kwDOANBUbNoAKDJhYzdiMTlmMWU5MjE5ZjQ2Y2NmNTVmMjVkOGFjYjNlMDJlOWEyZDQ", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-02-10T00:06:15Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-02-10T18:00:58Z"}, "message": "analyzer: handle more casts of string literals [PR98797]\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/98797\n\t* region-model-manager.cc\n\t(region_model_manager::maybe_fold_sub_svalue): Generalize getting\n\tindividual chars of a STRING_CST from element_region to any\n\tsubregion which is a concrete access of a single byte from its\n\tparent region.\n\t* region.cc (region::get_relative_concrete_byte_range): New.\n\t* region.h (region::get_relative_concrete_byte_range): New decl.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/98797\n\t* gcc.dg/analyzer/casts-1.c: Mark xfails as fixed; add further\n\ttest coverage for casts of string literals.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "f0b2beadb7c47003a45bf9cba95784980ed14165", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f0b2beadb7c47003a45bf9cba95784980ed14165"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ac7b19f1e9219f46ccf55f25d8acb3e02e9a2d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ac7b19f1e9219f46ccf55f25d8acb3e02e9a2d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ac7b19f1e9219f46ccf55f25d8acb3e02e9a2d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ac7b19f1e9219f46ccf55f25d8acb3e02e9a2d4/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b32305b41dcafc5fb6974c0da3ce2f62251afdbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b32305b41dcafc5fb6974c0da3ce2f62251afdbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b32305b41dcafc5fb6974c0da3ce2f62251afdbf"}], "stats": {"total": 98, "additions": 84, "deletions": 14}, "files": [{"sha": "d7156c5499fe4c24ba045dfdf25d9ba0e3a4d256", "filename": "gcc/analyzer/region-model-manager.cc", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ac7b19f1e9219f46ccf55f25d8acb3e02e9a2d4/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ac7b19f1e9219f46ccf55f25d8acb3e02e9a2d4/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=2ac7b19f1e9219f46ccf55f25d8acb3e02e9a2d4", "patch": "@@ -782,15 +782,22 @@ region_model_manager::maybe_fold_sub_svalue (tree type,\n   /* Handle getting individual chars from a STRING_CST.  */\n   if (tree cst = parent_svalue->maybe_get_constant ())\n     if (TREE_CODE (cst) == STRING_CST)\n-      if (const element_region *element_reg\n-\t    = subregion->dyn_cast_element_region ())\n-\t{\n-\t  const svalue *idx_sval = element_reg->get_index ();\n-\t  if (tree cst_idx = idx_sval->maybe_get_constant ())\n+      {\n+\t/* If we have a concrete 1-byte access within the parent region... */\n+\tbyte_range subregion_bytes (0, 0);\n+\tif (subregion->get_relative_concrete_byte_range (&subregion_bytes)\n+\t    && subregion_bytes.m_size_in_bytes == 1)\n+\t  {\n+\t    /* ...then attempt to get that char from the STRING_CST.  */\n+\t    HOST_WIDE_INT hwi_start_byte\n+\t      = subregion_bytes.m_start_byte_offset.to_shwi ();\n+\t    tree cst_idx\n+\t      = build_int_cst_type (size_type_node, hwi_start_byte);\n \t    if (const svalue *char_sval\n \t\t= maybe_get_char_from_string_cst (cst, cst_idx))\n \t      return get_or_create_cast (type, char_sval);\n-\t}\n+\t  }\n+      }\n \n   if (const initial_svalue *init_sval\n \t= parent_svalue->dyn_cast_initial_svalue ())"}, {"sha": "5ac24fb9f9be6925966d8321f84bafd9572f1a28", "filename": "gcc/analyzer/region.cc", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ac7b19f1e9219f46ccf55f25d8acb3e02e9a2d4/gcc%2Fanalyzer%2Fregion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ac7b19f1e9219f46ccf55f25d8acb3e02e9a2d4/gcc%2Fanalyzer%2Fregion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.cc?ref=2ac7b19f1e9219f46ccf55f25d8acb3e02e9a2d4", "patch": "@@ -539,6 +539,34 @@ region::get_relative_concrete_offset (bit_offset_t *) const\n   return false;\n }\n \n+/* Attempt to get the position and size of this region expressed as a\n+   concrete range of bytes relative to its parent.\n+   If successful, return true and write to *OUT.\n+   Otherwise return false.  */\n+\n+bool\n+region::get_relative_concrete_byte_range (byte_range *out) const\n+{\n+  /* We must have a concrete offset relative to the parent.  */\n+  bit_offset_t rel_bit_offset;\n+  if (!get_relative_concrete_offset (&rel_bit_offset))\n+    return false;\n+  /* ...which must be a whole number of bytes.  */\n+  if (rel_bit_offset % BITS_PER_UNIT != 0)\n+    return false;\n+  byte_offset_t start_byte_offset = rel_bit_offset / BITS_PER_UNIT;\n+\n+  /* We must have a concrete size, which must be a whole number\n+     of bytes.  */\n+  byte_size_t num_bytes;\n+  if (!get_byte_size (&num_bytes))\n+    return false;\n+\n+  /* Success.  */\n+  *out = byte_range (start_byte_offset, num_bytes);\n+  return true;\n+}\n+\n /* Dump a description of this region to stderr.  */\n \n DEBUG_FUNCTION void"}, {"sha": "2f987e49fa818808931eee46ac00761b8aff3d46", "filename": "gcc/analyzer/region.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ac7b19f1e9219f46ccf55f25d8acb3e02e9a2d4/gcc%2Fanalyzer%2Fregion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ac7b19f1e9219f46ccf55f25d8acb3e02e9a2d4/gcc%2Fanalyzer%2Fregion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.h?ref=2ac7b19f1e9219f46ccf55f25d8acb3e02e9a2d4", "patch": "@@ -182,6 +182,12 @@ class region\n      Otherwise return false.  */\n   virtual bool get_relative_concrete_offset (bit_offset_t *out) const;\n \n+  /* Attempt to get the position and size of this region expressed as a\n+     concrete range of bytes relative to its parent.\n+     If successful, return true and write to *OUT.\n+     Otherwise return false.  */\n+  bool get_relative_concrete_byte_range (byte_range *out) const;\n+\n   void\n   get_subregions_for_binding (region_model_manager *mgr,\n \t\t\t      bit_offset_t start_bit_offset,"}, {"sha": "7e4af3849718583d595a212fd6cdee9a7461bb7d", "filename": "gcc/testsuite/gcc.dg/analyzer/casts-1.c", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ac7b19f1e9219f46ccf55f25d8acb3e02e9a2d4/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcasts-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ac7b19f1e9219f46ccf55f25d8acb3e02e9a2d4/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcasts-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fcasts-1.c?ref=2ac7b19f1e9219f46ccf55f25d8acb3e02e9a2d4", "patch": "@@ -13,6 +13,14 @@ struct s2\n   char arr[4];\n };\n \n+struct s3\n+{\n+  struct inner {\n+    char a;\n+    char b;\n+  } arr[2];\n+};\n+\n void test_1 ()\n {\n   struct s1 x = {'A', 'B', 'C', 'D'};\n@@ -24,10 +32,16 @@ void test_1 ()\n   __analyzer_eval (((struct s2 *)&x)->arr[1] == 'B'); /* { dg-warning \"TRUE\" } */\n   __analyzer_eval (((struct s2 *)&x)->arr[2] == 'C'); /* { dg-warning \"TRUE\" } */\n   __analyzer_eval (((struct s2 *)&x)->arr[3] == 'D'); /* { dg-warning \"TRUE\" } */\n+  struct s3 *p3 = (struct s3 *)&x;\n+  __analyzer_eval (p3->arr[0].a == 'A'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p3->arr[0].b == 'B'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p3->arr[1].a == 'C'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p3->arr[1].b == 'D'); /* { dg-warning \"TRUE\" } */\n \n   ((struct s2 *)&x)->arr[1] = '#';\n   __analyzer_eval (((struct s2 *)&x)->arr[1] == '#'); /* { dg-warning \"TRUE\" } */\n   __analyzer_eval (x.b == '#'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p3->arr[0].b == '#'); /* { dg-warning \"TRUE\" } */\n }\n \n void test_2 ()\n@@ -38,12 +52,27 @@ void test_2 ()\n   __analyzer_eval (x.arr[2] == 'C'); /* { dg-warning \"TRUE\" } */\n   __analyzer_eval (x.arr[3] == 'D'); /* { dg-warning \"TRUE\" } */\n   struct s1 *p = (struct s1 *)&x;\n-  __analyzer_eval (p->a == 'A'); /* { dg-warning \"TRUE\" \"true\" { xfail *-*-* } } */\n-  /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n-  __analyzer_eval (p->b == 'B'); /* { dg-warning \"TRUE\" \"true\" { xfail *-*-* } } */\n-  /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n-  __analyzer_eval (p->c == 'C'); /* { dg-warning \"TRUE\" \"true\" { xfail *-*-* } } */\n-  /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n-  __analyzer_eval (p->d == 'D'); /* { dg-warning \"TRUE\" \"true\" { xfail *-*-* } } */\n-  /* { dg-bogus \"UNKNOWN\" \"unknown\" { xfail *-*-* } .-1 } */\n+  __analyzer_eval (p->a == 'A'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p->b == 'B'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p->c == 'C'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p->d == 'D'); /* { dg-warning \"TRUE\" } */\n+}\n+\n+void test_3 ()\n+{\n+  struct s3 x = {'A', 'B', 'C', 'D'};\n+  __analyzer_eval (x.arr[0].a == 'A'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (x.arr[0].b == 'B'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (x.arr[1].a == 'C'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (x.arr[1].b == 'D'); /* { dg-warning \"TRUE\" } */\n+  struct s1 *p1 = (struct s1 *)&x;\n+  __analyzer_eval (p1->a == 'A'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p1->b == 'B'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p1->c == 'C'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p1->d == 'D'); /* { dg-warning \"TRUE\" } */\n+  struct s2 *p2 = (struct s2 *)&x;\n+  __analyzer_eval (p2->arr[0] == 'A'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p2->arr[1] == 'B'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p2->arr[2] == 'C'); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (p2->arr[3] == 'D'); /* { dg-warning \"TRUE\" } */\n }"}]}