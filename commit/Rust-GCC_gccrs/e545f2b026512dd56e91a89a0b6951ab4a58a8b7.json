{"sha": "e545f2b026512dd56e91a89a0b6951ab4a58a8b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU0NWYyYjAyNjUxMmRkNTZlOTFhODlhMGI2OTUxYWI0YTU4YThiNw==", "commit": {"author": {"name": "Dennis Glatting", "email": "dennisg@gnu.org", "date": "1991-10-24T00:19:24Z"}, "committer": {"name": "Dennis Glatting", "email": "dennisg@gnu.org", "date": "1991-10-24T00:19:24Z"}, "message": "Initial check in.  Preliminary development stage.\n\nFrom-SVN: r45", "tree": {"sha": "bc84a906f7dcc8902a6627be4e7b347d95ea39d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc84a906f7dcc8902a6627be4e7b347d95ea39d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e545f2b026512dd56e91a89a0b6951ab4a58a8b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e545f2b026512dd56e91a89a0b6951ab4a58a8b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e545f2b026512dd56e91a89a0b6951ab4a58a8b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e545f2b026512dd56e91a89a0b6951ab4a58a8b7/comments", "author": null, "committer": null, "parents": [{"sha": "225411cf6b63cba45c04abea00ac9bf242882104", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/225411cf6b63cba45c04abea00ac9bf242882104", "html_url": "https://github.com/Rust-GCC/gccrs/commit/225411cf6b63cba45c04abea00ac9bf242882104"}], "stats": {"total": 344, "additions": 344, "deletions": 0}, "files": [{"sha": "7b1c117f91f7f30124cd71bdf0d02ced6a0ee4d7", "filename": "gcc/objc/objc.h", "status": "added", "additions": 344, "deletions": 0, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e545f2b026512dd56e91a89a0b6951ab4a58a8b7/gcc%2Fobjc%2Fobjc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e545f2b026512dd56e91a89a0b6951ab4a58a8b7/gcc%2Fobjc%2Fobjc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc.h?ref=e545f2b026512dd56e91a89a0b6951ab4a58a8b7", "patch": "@@ -0,0 +1,344 @@\n+/* -*-c-*-\n+ * This file contains declarations used by the run-time system.\n+ *\n+ *  Most of these declarations are defined by virtue of data \n+ *  structures produced by the compiler.\n+ *\n+  $Header$\n+  $Author$\n+  $Date$\n+  $Log$\n+*/\n+ \n+\n+#ifndef _objc_INCLUDE_GNU\n+#define _objc_INCLUDE_GNU\n+\n+                                                /* If someone is using a c++\n+                                                  compiler then adjust the \n+                                                  types in the file back \n+                                                  to C. */\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include  <sys/types.h>\n+#include  <hash.h>\n+\n+\n+#define nil ( id )0                             /* id of Nil instance */\n+#define Nil ( Class_t )0                        /* id of Nil class */\n+typedef char* STR;                              /* String alias */\n+\n+                                                /* Boolean typedefs */\n+typedef char  BOOL;\n+#define YES   (BOOL)1\n+#define NO    (BOOL)0\n+\n+                                                /* Defination of a \n+                                                  selector.  Selectors are \n+                                                  really of type char*. The\n+                                                  run-time uses strcmp() to\n+                                                  locate selectors. */\n+typedef STR   SEL;\n+\n+                                                /* ObjC uses this typedef \n+                                                  for untyped instances. */\n+typedef struct objc_object {\n+  struct objc_class*  isa;\n+} *id;\n+\n+                                                /* Prototype for method \n+                                                  functions. */\n+typedef id  ( *IMP )( \n+#ifdef __STDC__\n+  id, SEL, ...\n+#endif\n+); \n+\n+                                                /* Filer types used to \n+                                                  describe Ivars and \n+                                                  Methods. */\n+#define _C_ID       '@'\n+#define _C_CLASS    '#'\n+#define _C_SEL      ':'\n+#define _C_CHR      'c'\n+#define _C_UCHR     'C'\n+#define _C_SHT      's'\n+#define _C_USHT     'S'\n+#define _C_INT      'i'\n+#define _C_UINT     'I'\n+#define _C_LNG      'l'\n+#define _C_ULNG     'L'\n+#define _C_FLT      'f'\n+#define _C_DBL      'd'\n+#define _C_BFLD     'b'\n+#define _C_VOID     'v'\n+#define _C_UNDEF    '?'\n+#define _C_PTR      '^'\n+#define _C_CHARPTR  '*'\n+#define _C_ARY_B    '['\n+#define _C_ARY_E    ']'\n+#define _C_UNION_B  '('\n+#define _C_UNION_E  ')'\n+#define _C_STRUCT_B '{'\n+#define _C_STRUCT_E '}'\n+\n+/* \n+ * These definitions are masks used with \n+ *  the \"info\" member variable in the class and \n+ *  meta class structures. \n+ */\n+#define CLS_CLASS         0x1L                  /* The structure is of type\n+                                                  class (Class_t). */\n+#define CLS_META          0x2L                  /* The structure is of type\n+                                                  meta class (MetaClass_t). */\n+#define CLS_INITIALIZED   0x4L                  /* Class is initialized. A\n+                                                  +initialize method is the\n+                                                  first message sent to a\n+                                                  class.  It isn't guaranteed\n+                                                  to be sent only once. */\n+#define CLS_POSING        0x8L                  /* Class is posing as another.\n+                                                  Used to fix broken \n+                                                  classes. */\n+#define CLS_MAPPED        0x10L                 /* Unknown. */\n+\n+\n+                                                /* Set this variable to !0 to\n+                                                  have the messager print\n+                                                  messaging operations. */\n+  extern BOOL objc_trace;\n+\n+\n+/* \n+ * Whereas a Module (defined further down) is the \n+ *  root (typically) of a file, a Symtab is the root of the \n+ *  class and category definitions within the module.  \n+ *\n+ * A Symtab contains a variable length array of pointers\n+ *  to classes and categories  defined in the module. \n+ */\n+typedef struct objc_symtab {\n+  u_long    sel_ref_cnt;                        /* Unknown. */\n+  SEL       *refs;                              /* Unknown. */\n+  u_short   cls_def_cnt;                        /* Number of classes compiled\n+                                                  (defined) in the module. */\n+  u_short   cat_def_cnt;                        /* Number of categories \n+                                                  compiled (defined) in the \n+                                                  module. */\n+  void      *defs[1];                           /* Variable array of pointers.\n+                                                  cls_def_cnt of type Class_t \n+                                                  followed by cat_def_cnt of\n+                                                  type Category_t. */\n+} Symtab,   *Symtab_t;\n+\n+\n+/* \n+ * The compiler generates one of these structures for each\n+ *  module that composes the executable (eg main.m).  \n+ *\n+ * This data structure is the root of the definition tree\n+ *  for the module.  \n+ *\n+ * A collect program runs between ld stages and creates \n+ *  a ObjC ctor array.  That array holds a pointer to each\n+ *  module structure of the executable. \n+ */\n+typedef struct objc_module {\n+  u_long    version;                            /* Unknown. */\n+  u_long    size;                               /* Suspect this is \n+                                                  sizeof(Module).  It is always \n+                                                  16. */\n+  char*     name;                               /* Name of the file where the \n+                                                  module was generated.   The \n+                                                  name includes the path. */\n+  Symtab_t  symtab;                             /* Pointer to the Symtab of\n+                                                  the module.  The Symtab\n+                                                  holds an array of pointers to \n+                                                  the classes and categories \n+                                                  defined in the module. */\n+} Module, *Module_t;\n+\n+\n+/* \n+ * The compiler generates one of these structures for a \n+ *  class that has instance variables defined in its \n+ *  specification. \n+ */\n+typedef struct objc_ivar* Ivar_t;\n+typedef struct objc_ivar_list {\n+  int   ivar_count;                             /* Number of structures (Ivar) \n+                                                  contained in the list.  One\n+                                                  structure per instance \n+                                                  variable defined in the\n+                                                  class. */\n+  struct objc_ivar {\n+    char* ivar_name;                            /* Name of the instance\n+                                                  variable as entered in the\n+                                                  class definition. */\n+    char* ivar_type;                            /* Description of the Ivar's\n+                                                  type.  Useful for \n+                                                  debuggers. */\n+    int   ivar_offset;                          /* Byte offset from the base \n+                                                  address of the instance \n+                                                  structure to the variable. */\n+\n+  } ivar_list[1];                               /* Variable length \n+                                                  structure. */\n+} IvarList, *IvarList_t;\n+\n+\n+/* \n+ * The compiler generates one (or more) of these structures \n+ *  for a class that has methods defined in its specification. \n+ *\n+ * The implementation of a class can be broken into separate \n+ *  pieces in a file and categories can break them across modules.\n+ *  To handle this problem is a singly linked list of methods.\n+ */\n+typedef struct objc_method Method;\n+typedef Method* Method_t;\n+typedef struct objc_method_list {\n+  struct objc_method_list*  method_next;      /* This variable is used to link \n+                                                a method list to another.  It \n+                                                is a singly linked list. */\n+  int             method_count;               /* Number of methods defined in \n+                                                this structure. */\n+  struct objc_method {\n+    SEL   method_name;                        /* This variable is the method's \n+                                                name.  It is a char*. \n+                                                  The unique integer passed to \n+                                                objc_msgSend() is a char* too.  \n+                                                It is compared against \n+                                                method_name using strcmp(). */\n+    char* method_types;                       /* Description of the method's\n+                                                parameter list.  Useful for\n+                                                debuggers. */\n+    IMP   method_imp;                         /* Address of the method in the \n+                                                executable. */\n+  } method_list[1];                           /* Variable length \n+                                                structure. */\n+} MethodList, *MethodList_t;\n+\n+\n+/*\n+ * The compiler generates one of these structures for \n+ *  each class.  \n+ *\n+ * This structure is the definition for meta classes.\n+ *  By definition a meta class is the class's class.  Its \n+ *  most relevant contribution is that its method list\n+ *  contain the class's factory methods.\n+ *  \n+ * This structure is generated by the compiler in the\n+ *  executable and used by the run-time during normal\n+ *  messaging operations.  Therefore some definitions \n+ *  don't make sense in some contexts.\n+ */\n+typedef struct objc_metaClass {     \n+  char*         isa;                          /* Always a pointer to the\n+                                                string \"Object\". */\n+  char*         super_class;                  /* Name of the class's super\n+                                                class. */\n+  char*         name;                         /* Name of the meta class. */\n+  long          version;                      /* Unknown. */\n+  long          info;                         /* Bit mask.  See class masks \n+                                                defined above. */\n+  long          instance_size;                /* Always 0 except for Object.\n+                                                Should be ignored. */\n+  IvarList_t    ivars;                        /* Always NULL except for \n+                                                Object.  Should be ignored. */\n+  MethodList_t  methods;                      /* Linked List of factory methods \n+                                                for the class. */\n+  Cache_t       cache;                        /* Used to cache factory methods\n+                                                defined for the class and its \n+                                                super classes.  Entries are\n+                                                made to the cache as the\n+                                                messager receives them. */\n+} MetaClass, *MetaClass_t;\n+\n+\n+/*\n+ * The compiler generates one of these structures for \n+ *  each class.  \n+ *\n+ * This structure is the definition for classes.\n+ *  \n+ * This structure is generated by the compiler in the\n+ *  executable and used by the run-time during normal\n+ *  messaging operations.  Therefore some definitions \n+ *  don't make sense in some contexts.\n+ */\n+typedef struct objc_class {     \n+  MetaClass_t   isa;                          /* Pointer to the class's\n+                                                meta class. */\n+  char*         super_class;                  /* Name of the class's super\n+                                                class. */\n+  char*         name;                         /* Name of the class. */\n+  long          version;                      /* Unknown. */\n+  long          info;                         /* Bit mask.  See class masks \n+                                                defined above. */\n+  long          instance_size;                /* Size in bytes of the class.  \n+                                                The sum of the class definition \n+                                                and all super class \n+                                                definitions. */\n+  IvarList_t    ivars;                        /* Pointer to a structure that\n+                                                describes the instance \n+                                                variables in the class\n+                                                definition.  NULL indicates\n+                                                no instance variables.  Does\n+                                                not include super class\n+                                                variables. */\n+  MethodList_t  methods;                      /* Linked list of instance\n+                                                methods defined for the \n+                                                class. */\n+  Cache_t       cache;                        /* Used to cache instance methods\n+                                                defined for the class and its \n+                                                super classes.  Entries are\n+                                                made to the cache as the\n+                                                messager receives them. */\n+} Class, *Class_t;\n+\n+\n+/*\n+ * The compiler generates one of these structures \n+ *  for each category.  A class may have many \n+ *  categories and contain both instance and \n+ *  factory methods.  \n+ */\n+typedef struct objc_category {\n+  char*         category_name;                /* Name of the category.  Name\n+                                                contained in the () of the\n+                                                category definition. */\n+  char*         class_name;                   /* Name of the class to which\n+                                                the category belongs. */\n+  MethodList_t  instance_methods;             /* Linked list of instance\n+                                                methods defined in the \n+                                                category. NULL indicates no\n+                                                instance methods defined. */\n+  MethodList_t  class_methods;                /* Linked list of factory \n+                                                methods defined in the\n+                                                category.  NULL indicates no\n+                                                class methods defined. */\n+} Category, *Category_t;\n+\n+\n+/* \n+ * Structure used when a message is send to a class's\n+ *  super class.  The compiler generates one of these\n+ *  structures and passes it to objc_msgSuper(). \n+ */\n+typedef struct objc_super {\n+  id    receiver;                             /* Id of the object sending\n+                                                the message. */\n+  char* class;                                /* Name of the object's super\n+                                                class.  Passed to remove a \n+                                                level of indirection? */\n+} Super, *Super_t;\n+\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif"}]}