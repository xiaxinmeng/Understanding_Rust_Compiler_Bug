{"sha": "a37374818c824faeb9ac4db40bcc0229995a84f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM3Mzc0ODE4YzgyNGZhZWI5YWM0ZGI0MGJjYzAyMjk5OTVhODRmNg==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.co.uk", "date": "2002-08-12T17:21:52Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-08-12T17:21:52Z"}, "message": "cpphash.h (struct printer): New from cppmain.c.\n\n\t* cpphash.h (struct printer): New from cppmain.c.\n\t(cpp_reader): New member.\n\t* cppmain.c (struct printer): Move to cpphash.h.\n\t(options, print): Remove.\n\t(account_for_newlines, print_line, maybe_print_line,\n\tcpp_preprocess_file, setup_callbacks, scan_translation_unit,\n\tscan_translation_unit_trad, cb_line_change, cb_ident,\n\tcb_define, cb_undef, cb_include, cb_file_change, dump_macro,\n\tcb_def_pragma): Make reentrant.\n\nFrom-SVN: r56233", "tree": {"sha": "eecda0597667c0067205004c3f73f65340d9b309", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eecda0597667c0067205004c3f73f65340d9b309"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a37374818c824faeb9ac4db40bcc0229995a84f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a37374818c824faeb9ac4db40bcc0229995a84f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a37374818c824faeb9ac4db40bcc0229995a84f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a37374818c824faeb9ac4db40bcc0229995a84f6/comments", "author": {"login": "neilb-xx", "id": 160762, "node_id": "MDQ6VXNlcjE2MDc2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/160762?v=4", "gravatar_id": "", "url": "https://api.github.com/users/neilb-xx", "html_url": "https://github.com/neilb-xx", "followers_url": "https://api.github.com/users/neilb-xx/followers", "following_url": "https://api.github.com/users/neilb-xx/following{/other_user}", "gists_url": "https://api.github.com/users/neilb-xx/gists{/gist_id}", "starred_url": "https://api.github.com/users/neilb-xx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/neilb-xx/subscriptions", "organizations_url": "https://api.github.com/users/neilb-xx/orgs", "repos_url": "https://api.github.com/users/neilb-xx/repos", "events_url": "https://api.github.com/users/neilb-xx/events{/privacy}", "received_events_url": "https://api.github.com/users/neilb-xx/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d71f770043fd525ec3df1d33311f653ecdd80e88", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d71f770043fd525ec3df1d33311f653ecdd80e88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d71f770043fd525ec3df1d33311f653ecdd80e88"}], "stats": {"total": 244, "additions": 133, "deletions": 111}, "files": [{"sha": "c2471425a0580a3ef71e81dbf787b8922ab1b4ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a37374818c824faeb9ac4db40bcc0229995a84f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a37374818c824faeb9ac4db40bcc0229995a84f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a37374818c824faeb9ac4db40bcc0229995a84f6", "patch": "@@ -1,3 +1,15 @@\n+2002-08-12  Neil Booth  <neil@daikokuya.co.uk>\n+\n+\t* cpphash.h (struct printer): New from cppmain.c.\n+\t(cpp_reader): New member.\n+\t* cppmain.c (struct printer): Move to cpphash.h.\n+\t(options, print): Remove.\n+\t(account_for_newlines, print_line, maybe_print_line,\n+\tcpp_preprocess_file, setup_callbacks, scan_translation_unit,\n+\tscan_translation_unit_trad, cb_line_change, cb_ident,\n+\tcb_define, cb_undef, cb_include, cb_file_change, dump_macro,\n+\tcb_def_pragma): Make reentrant.\n+\n 2002-08-12  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* real.c (ieee_64): Always define."}, {"sha": "547a70c2c6001f4e25287481dc06bad22dbe9c44", "filename": "gcc/cpphash.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a37374818c824faeb9ac4db40bcc0229995a84f6/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a37374818c824faeb9ac4db40bcc0229995a84f6/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=a37374818c824faeb9ac4db40bcc0229995a84f6", "patch": "@@ -253,6 +253,18 @@ struct spec_nodes\n   cpp_hashnode *n__VA_ARGS__;\t\t/* C99 vararg macros */\n };\n \n+/* Encapsulates state used to convert a stream of tokens into a text\n+   file.  */\n+struct printer\n+{\n+  FILE *outf;\t\t\t/* Stream to write to.  */\n+  const struct line_map *map;\t/* Logical to physical line mappings.  */\n+  const cpp_token *prev;\t/* Previous token.  */\n+  const cpp_token *source;\t/* Source token for spacing.  */\n+  unsigned int line;\t\t/* Line currently being written.  */\n+  unsigned char printed;\t/* Nonzero if something output at line.  */\n+};\n+\n /* Represents the contents of a file cpplib has read in.  */\n struct cpp_buffer\n {\n@@ -419,6 +431,9 @@ struct cpp_reader\n      preprocessor.  */\n   struct spec_nodes spec_nodes;\n \n+  /* Used when doing preprocessed output.  */\n+  struct printer print;\n+\n   /* Whether cpplib owns the hashtable.  */\n   unsigned char our_hashtable;\n "}, {"sha": "4036bc3b537c03d2a02a50bee4f27485c8c8ec88", "filename": "gcc/cppmain.c", "status": "modified", "additions": 106, "deletions": 111, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a37374818c824faeb9ac4db40bcc0229995a84f6/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a37374818c824faeb9ac4db40bcc0229995a84f6/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=a37374818c824faeb9ac4db40bcc0229995a84f6", "patch": "@@ -26,29 +26,19 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n \n-/* Encapsulates state used to convert the stream of tokens coming from\n-   cpp_get_token back into a text file.  */\n-struct printer\n-{\n-  FILE *outf;\t\t\t/* Stream to write to.  */\n-  const struct line_map *map;\t/* Logical to physical line mappings.  */\n-  const cpp_token *prev;\t/* Previous token.  */\n-  const cpp_token *source;\t/* Source token for spacing.  */\n-  unsigned int line;\t\t/* Line currently being written.  */\n-  unsigned char printed;\t/* Nonzero if something output at line.  */\n-};\n-\n static void setup_callbacks PARAMS ((cpp_reader *));\n \n /* General output routines.  */\n static void scan_translation_unit PARAMS ((cpp_reader *));\n static void scan_translation_unit_trad PARAMS ((cpp_reader *));\n-static void account_for_newlines PARAMS ((const uchar *, size_t));\n+static void account_for_newlines PARAMS ((cpp_reader *, const uchar *,\n+\t\t\t\t\t  size_t));\n static int dump_macro PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n \n-static void print_line PARAMS ((const struct line_map *, unsigned int,\n-\t\t\t\tconst char *));\n-static void maybe_print_line PARAMS ((const struct line_map *, unsigned int));\n+static void print_line PARAMS ((cpp_reader *, const struct line_map *,\n+\t\t\t\tunsigned int, const char *));\n+static void maybe_print_line PARAMS ((cpp_reader *, const struct line_map *,\n+\t\t\t\t      unsigned int));\n \n /* Callback routines for the parser.   Most of these are active only\n    in specific modes.  */\n@@ -62,31 +52,27 @@ static void cb_ident\t  PARAMS ((cpp_reader *, unsigned int,\n static void cb_file_change PARAMS ((cpp_reader *, const struct line_map *));\n static void cb_def_pragma PARAMS ((cpp_reader *, unsigned int));\n \n-static cpp_options *options;\t/* Options of pfile.  */\n-static struct printer print;\n-\n /* Preprocess and output.  */\n void\n cpp_preprocess_file (pfile, in_fname, out_stream)\n      cpp_reader *pfile;\n      const char *in_fname;\n      FILE *out_stream;\n {\n-  options = cpp_get_options (pfile);\n-\n   /* Initialize the printer structure.  Setting print.line to -1 here\n      is a trick to guarantee that the first token of the file will\n      cause a linemarker to be output by maybe_print_line.  */\n-  print.line = (unsigned int) -1;\n-  print.printed = 0;\n-  print.prev = 0;\n-  print.map = 0;\n-  print.outf = out_stream;\n+  pfile->print.line = (unsigned int) -1;\n+  pfile->print.printed = 0;\n+  pfile->print.prev = 0;\n+  pfile->print.map = 0;\n+  pfile->print.outf = out_stream;\n \n   setup_callbacks (pfile);\n \n   if (cpp_read_main_file (pfile, in_fname, NULL))\n     {\n+      cpp_options *options = &pfile->opts;\n       cpp_finish_options (pfile);\n \n       /* A successful cpp_read_main_file guarantees that we can call\n@@ -104,15 +90,16 @@ cpp_preprocess_file (pfile, in_fname, out_stream)\n     }\n \n   /* Flush any pending output.  */\n-  if (print.printed)\n-    putc ('\\n', print.outf);\n+  if (pfile->print.printed)\n+    putc ('\\n', pfile->print.outf);\n }\n \n /* Set up the callbacks as appropriate.  */\n static void\n setup_callbacks (pfile)\n      cpp_reader *pfile;\n {\n+  cpp_options *options = &pfile->opts;\n   cpp_callbacks *cb = cpp_get_callbacks (pfile);\n \n   if (! options->no_output)\n@@ -148,18 +135,18 @@ scan_translation_unit (pfile)\n {\n   bool avoid_paste = false;\n \n-  print.source = NULL;\n+  pfile->print.source = NULL;\n   for (;;)\n     {\n       const cpp_token *token = cpp_get_token (pfile);\n \n       if (token->type == CPP_PADDING)\n \t{\n \t  avoid_paste = true;\n-\t  if (print.source == NULL\n-\t      || (!(print.source->flags & PREV_WHITE)\n+\t  if (pfile->print.source == NULL\n+\t      || (!(pfile->print.source->flags & PREV_WHITE)\n \t\t  && token->val.source == NULL))\n-\t    print.source = token->val.source;\n+\t    pfile->print.source = token->val.source;\n \t  continue;\n \t}\n \n@@ -169,35 +156,37 @@ scan_translation_unit (pfile)\n       /* Subtle logic to output a space if and only if necessary.  */\n       if (avoid_paste)\n \t{\n-\t  if (print.source == NULL)\n-\t    print.source = token;\n-\t  if (print.source->flags & PREV_WHITE\n-\t      || (print.prev && cpp_avoid_paste (pfile, print.prev, token))\n-\t      || (print.prev == NULL && token->type == CPP_HASH))\n-\t    putc (' ', print.outf);\n+\t  if (pfile->print.source == NULL)\n+\t    pfile->print.source = token;\n+\t  if (pfile->print.source->flags & PREV_WHITE\n+\t      || (pfile->print.prev\n+\t\t  && cpp_avoid_paste (pfile, pfile->print.prev, token))\n+\t      || (pfile->print.prev == NULL && token->type == CPP_HASH))\n+\t    putc (' ', pfile->print.outf);\n \t}\n       else if (token->flags & PREV_WHITE)\n-\tputc (' ', print.outf);\n+\tputc (' ', pfile->print.outf);\n \n       avoid_paste = false;\n-      print.source = NULL;\n-      print.prev = token;\n-      cpp_output_token (token, print.outf);\n+      pfile->print.source = NULL;\n+      pfile->print.prev = token;\n+      cpp_output_token (token, pfile->print.outf);\n \n       if (token->type == CPP_COMMENT)\n-\taccount_for_newlines (token->val.str.text, token->val.str.len);\n+\taccount_for_newlines (pfile, token->val.str.text, token->val.str.len);\n     }\n }\n \n-/* Adjust print.line for newlines embedded in output.  */\n+/* Adjust pfile->print.line for newlines embedded in output.  */\n static void\n-account_for_newlines (str, len)\n+account_for_newlines (pfile, str, len)\n+     cpp_reader *pfile;\n      const uchar *str;\n      size_t len;\n {\n   while (len--)\n     if (*str++ == '\\n')\n-      print.line++;\n+      pfile->print.line++;\n }\n \n /* Writes out a traditionally preprocessed file.  */\n@@ -208,57 +197,59 @@ scan_translation_unit_trad (pfile)\n   while (_cpp_read_logical_line_trad (pfile))\n     {\n       size_t len = pfile->out.cur - pfile->out.base;\n-      maybe_print_line (print.map, pfile->out.first_line);\n-      fwrite (pfile->out.base, 1, len, print.outf);\n-      print.printed = 1;\n+      maybe_print_line (pfile, pfile->print.map, pfile->out.first_line);\n+      fwrite (pfile->out.base, 1, len, pfile->print.outf);\n+      pfile->print.printed = 1;\n       if (!CPP_OPTION (pfile, discard_comments))\n-\taccount_for_newlines (pfile->out.base, len);\n+\taccount_for_newlines (pfile, pfile->out.base, len);\n     }\n }\n \n /* If the token read on logical line LINE needs to be output on a\n    different line to the current one, output the required newlines or\n    a line marker, and return 1.  Otherwise return 0.  */\n static void\n-maybe_print_line (map, line)\n+maybe_print_line (pfile, map, line)\n+     cpp_reader *pfile;\n      const struct line_map *map;\n      unsigned int line;\n {\n   /* End the previous line of text.  */\n-  if (print.printed)\n+  if (pfile->print.printed)\n     {\n-      putc ('\\n', print.outf);\n-      print.line++;\n-      print.printed = 0;\n+      putc ('\\n', pfile->print.outf);\n+      pfile->print.line++;\n+      pfile->print.printed = 0;\n     }\n \n-  if (line >= print.line && line < print.line + 8)\n+  if (line >= pfile->print.line && line < pfile->print.line + 8)\n     {\n-      while (line > print.line)\n+      while (line > pfile->print.line)\n \t{\n-\t  putc ('\\n', print.outf);\n-\t  print.line++;\n+\t  putc ('\\n', pfile->print.outf);\n+\t  pfile->print.line++;\n \t}\n     }\n   else\n-    print_line (map, line, \"\");\n+    print_line (pfile, map, line, \"\");\n }\n \n /* Output a line marker for logical line LINE.  Special flags are \"1\"\n    or \"2\" indicating entering or leaving a file.  */\n static void\n-print_line (map, line, special_flags)\n+print_line (pfile, map, line, special_flags)\n+     cpp_reader *pfile;\n      const struct line_map *map;\n      unsigned int line;\n      const char *special_flags;\n {\n   /* End any previous line of text.  */\n-  if (print.printed)\n-    putc ('\\n', print.outf);\n-  print.printed = 0;\n+  if (pfile->print.printed)\n+    putc ('\\n', pfile->print.outf);\n+  pfile->print.printed = 0;\n \n-  print.line = line;\n-  if (! options->no_line_commands)\n+  pfile->print.line = line;\n+  if (! CPP_OPTION (pfile, no_line_commands))\n     {\n       size_t to_file_len = strlen (map->to_file);\n       unsigned char *to_file_quoted = alloca (to_file_len * 4 + 1);\n@@ -269,32 +260,33 @@ print_line (map, line, special_flags)\n       p = cpp_quote_string (to_file_quoted,\n \t\t\t    (unsigned char *)map->to_file, to_file_len);\n       *p = '\\0';\n-      fprintf (print.outf, \"# %u \\\"%s\\\"%s\",\n-\t       SOURCE_LINE (map, print.line), to_file_quoted, special_flags);\n+      fprintf (pfile->print.outf, \"# %u \\\"%s\\\"%s\",\n+\t       SOURCE_LINE (map, pfile->print.line),\n+\t       to_file_quoted, special_flags);\n \n       if (map->sysp == 2)\n-\tfputs (\" 3 4\", print.outf);\n+\tfputs (\" 3 4\", pfile->print.outf);\n       else if (map->sysp == 1)\n-\tfputs (\" 3\", print.outf);\n+\tfputs (\" 3\", pfile->print.outf);\n \n-      putc ('\\n', print.outf);\n+      putc ('\\n', pfile->print.outf);\n     }\n }\n \n /* Called when a line of output is started.  TOKEN is the first token\n    of the line, and at end of file will be CPP_EOF.  */\n static void\n cb_line_change (pfile, token, parsing_args)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     cpp_reader *pfile;\n      const cpp_token *token;\n      int parsing_args;\n {\n   if (token->type == CPP_EOF || parsing_args)\n     return;\n \n-  maybe_print_line (print.map, token->line);\n-  print.prev = 0;\n-  print.source = 0;\n+  maybe_print_line (pfile, pfile->print.map, token->line);\n+  pfile->print.prev = 0;\n+  pfile->print.source = 0;\n \n   /* Supply enough spaces to put this token in its original column,\n      one space per column greater than 2, since scan_translation_unit\n@@ -303,26 +295,26 @@ cb_line_change (pfile, token, parsing_args)\n      ought to care.  Some things do care; the fault lies with them.  */\n   if (!CPP_OPTION (pfile, traditional))\n     {\n-      print.printed = 1;\n+      pfile->print.printed = 1;\n       if (token->col > 2)\n \t{\n \t  unsigned int spaces = token->col - 2;\n \n \t  while (spaces--)\n-\t    putc (' ', print.outf);\n+\t    putc (' ', pfile->print.outf);\n \t}\n     }\n }\n \n static void\n cb_ident (pfile, line, str)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     cpp_reader *pfile;\n      unsigned int line;\n      const cpp_string * str;\n {\n-  maybe_print_line (print.map, line);\n-  fprintf (print.outf, \"#ident \\\"%s\\\"\\n\", str->text);\n-  print.line++;\n+  maybe_print_line (pfile, pfile->print.map, line);\n+  fprintf (pfile->print.outf, \"#ident \\\"%s\\\"\\n\", str->text);\n+  pfile->print.line++;\n }\n \n static void\n@@ -331,28 +323,29 @@ cb_define (pfile, line, node)\n      unsigned int line;\n      cpp_hashnode *node;\n {\n-  maybe_print_line (print.map, line);\n-  fputs (\"#define \", print.outf);\n+  maybe_print_line (pfile, pfile->print.map, line);\n+  fputs (\"#define \", pfile->print.outf);\n \n   /* -dD command line option.  */\n-  if (options->dump_macros == dump_definitions)\n-    fputs ((const char *) cpp_macro_definition (pfile, node), print.outf);\n+  if (CPP_OPTION (pfile, dump_macros) == dump_definitions)\n+    fputs ((const char *) cpp_macro_definition (pfile, node),\n+\t   pfile->print.outf);\n   else\n-    fputs ((const char *) NODE_NAME (node), print.outf);\n+    fputs ((const char *) NODE_NAME (node), pfile->print.outf);\n \n-  putc ('\\n', print.outf);\n-  print.line++;\n+  putc ('\\n', pfile->print.outf);\n+  pfile->print.line++;\n }\n \n static void\n cb_undef (pfile, line, node)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     cpp_reader *pfile;\n      unsigned int line;\n      cpp_hashnode *node;\n {\n-  maybe_print_line (print.map, line);\n-  fprintf (print.outf, \"#undef %s\\n\", NODE_NAME (node));\n-  print.line++;\n+  maybe_print_line (pfile, pfile->print.map, line);\n+  fprintf (pfile->print.outf, \"#undef %s\\n\", NODE_NAME (node));\n+  pfile->print.line++;\n }\n \n static void\n@@ -362,43 +355,44 @@ cb_include (pfile, line, dir, header)\n      const unsigned char *dir;\n      const cpp_token *header;\n {\n-  maybe_print_line (print.map, line);\n-  fprintf (print.outf, \"#%s %s\\n\", dir, cpp_token_as_text (pfile, header));\n-  print.line++;\n+  maybe_print_line (pfile, pfile->print.map, line);\n+  fprintf (pfile->print.outf, \"#%s %s\\n\", dir,\n+\t   cpp_token_as_text (pfile, header));\n+  pfile->print.line++;\n }\n \n /* The file name, line number or system header flags have changed, as\n-   described in MAP.  From this point on, the old print.map might be\n+   described in MAP.  From this point on, the old pfile->print.map might be\n    pointing to freed memory, and so must not be dereferenced.  */\n \n static void\n cb_file_change (pfile, map)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     cpp_reader *pfile;\n      const struct line_map *map;\n {\n   const char *flags = \"\";\n \n   /* First time?  */\n-  if (print.map == NULL)\n+  if (pfile->print.map == NULL)\n     {\n       /* Avoid printing foo.i when the main file is foo.c.  */\n-      if (!options->preprocessed)\n-\tprint_line (map, map->from_line, flags);\n+      if (!CPP_OPTION (pfile, preprocessed))\n+\tprint_line (pfile, map, map->from_line, flags);\n     }\n   else\n     {\n       /* Bring current file to correct line when entering a new file.  */\n       if (map->reason == LC_ENTER)\n-\tmaybe_print_line (map - 1, map->from_line - 1);\n+\tmaybe_print_line (pfile, map - 1, map->from_line - 1);\n \n       if (map->reason == LC_ENTER)\n \tflags = \" 1\";\n       else if (map->reason == LC_LEAVE)\n \tflags = \" 2\";\n-      print_line (map, map->from_line, flags);\n+      print_line (pfile, map, map->from_line, flags);\n     }\n \n-  print.map = map;\n+  pfile->print.map = map;\n }\n \n /* Copy a #pragma directive to the preprocessed output.  */\n@@ -407,10 +401,10 @@ cb_def_pragma (pfile, line)\n      cpp_reader *pfile;\n      unsigned int line;\n {\n-  maybe_print_line (print.map, line);\n-  fputs (\"#pragma \", print.outf);\n-  cpp_output_line (pfile, print.outf);\n-  print.line++;\n+  maybe_print_line (pfile, pfile->print.map, line);\n+  fputs (\"#pragma \", pfile->print.outf);\n+  cpp_output_line (pfile, pfile->print.outf);\n+  pfile->print.line++;\n }\n \n /* Dump out the hash table.  */\n@@ -422,10 +416,11 @@ dump_macro (pfile, node, v)\n {\n   if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN))\n     {\n-      fputs (\"#define \", print.outf);\n-      fputs ((const char *) cpp_macro_definition (pfile, node), print.outf);\n-      putc ('\\n', print.outf);\n-      print.line++;\n+      fputs (\"#define \", pfile->print.outf);\n+      fputs ((const char *) cpp_macro_definition (pfile, node),\n+\t     pfile->print.outf);\n+      putc ('\\n', pfile->print.outf);\n+      pfile->print.line++;\n     }\n \n   return 1;"}]}