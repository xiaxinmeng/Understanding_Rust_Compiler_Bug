{"sha": "386b8a85a66471540a1a75ff8f4138fc5ace6a63", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg2YjhhODVhNjY0NzE1NDBhMWE3NWZmOGY0MTM4ZmM1YWNlNmE2Mw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-09-28T19:16:59Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-09-28T19:16:59Z"}, "message": "[multiple changes]\n\nSat Sep 27 16:22:48 1997  Jason Merrill  <jason@yorick.cygnus.com>\n\n\t* friend.c (do_friend): Disable injection for all template-derived\n \tdecls.\n\t* decl2.c (lang_decode_option): Handle -fguiding-decls.\n\t* parse.y (notype_template_declarator): New nonterminal.\n\t(direct_notype_declarator): Use it.\n\t(complex_direct_notype_declarator): Likewise.\n\t(object_template_id): Accept any kind of identifier after TEMPLATE.\n\t(notype_qualified_id): Don't add template declarators here.\n\nSat Sep 27 16:21:58 1997  Mark Mitchell  <mmitchell@usa.net>\n\n        * call.c (add_template_candidate): Add explicit_targs parameter.\n        (build_scoped_method_call): Use it.\n        (build_overload_call_real): Likewise.\n        (build_user_type_conversion_1): Likewise.\n        (build_new_function_call): Likewise.\n        (build_object_call): Likewise.\n        (build_new_op): Likewise.\n        (build_new_method_call): Likewise.\n        (build_new_function_call): Handle TEMPLATE_ID_EXPR.\n        (build_new_method_call): Likewise.\n\n        * class.c (finish_struct_methods): Add specialization pass to\n        determine which methods were specializing which other methods.\n        (instantiate_type): Handle TEMPLATE_ID_EXPR.\n\n        * cp-tree.def (TEMPLATE_ID_EXPR): New tree code.\n\n        * cp-tree.h (name_mangling_version): New variable.\n\t(flag_guiding_decls): Likewise.\n        (build_template_decl_overload): New function.\n        (begin_specialization): Likewise.\n        (reset_specialization): Likewise.\n        (end_specialization): Likewise.\n        (determine_explicit_specialization): Likewise.\n        (check_explicit_specialization): Likewise.\n        (lookup_template_function): Likewise.\n        (fn_type_unification): Add explicit_targs parameter.\n        (type_unification): Likewise.\n\n        * decl.c (duplicate_decls): Add smarts for explicit\n        specializations.\n        (grokdeclarator): Handle TEMPLATE_ID_EXPR, and function\n        specializations.\n        (grokfndecl): Call check_explicit_specialization.\n\n        * decl2.c (lang_decode_option): Handle -fname-mangling-version.\n        (build_expr_from_tree): Handle TEMPLATE_ID_EXPR.\n        (check_classfn): Handle specializations.\n\n        * error.c (dump_function_name): Print specialization arguments.\n\n\t* friend.c (do_friend): Don't call pushdecl for template\n        instantiations.\n\n        * init.c (build_member_call): Handle TEMPLATE_ID_EXPR.\n\n        * lang-options.h: Add -fname-mangling-version, -fguiding-decls,\n\tand -fno-guiding-decls.\n\n        * lex.c (identifier_type): Return PFUNCNAME for template function\n        names.\n\n        * method.c (build_decl_overload_real): New function.\n        (build_template_parm_names): New function.\n        (build_overload_identifier): Use it.\n        (build_underscore_int): New function.\n        (build_overload_int): Use it.  Add levels for template\n        parameters.\n        (build_overload_name): Likewise.  Also, handle TYPENAME_TYPEs.\n        (build_overload_nested_names): Handle template type parameters.\n        (build_template_decl_overload): New function.\n\n        * parse.y (YYSTYPE): New ntype member.\n        (nested_name_specifier): Use it.\n        (nested_name_specifier_1): Likewise.\n        (PFUNCNAME): New token.\n        (template_id, object_template_id): New non-terminals.\n        (template_parm_list): Note specializations.\n        (template_def): Likewise.\n        (structsp): Likewise.\n        (fn.def2): Handle member template specializations.\n        (component_decl_1): Likewise.\n        (direct_notype_declarator): Handle template-ids.\n        (component_decl_1): Likewise.\n        (direct_notype_declarator): Handle template-ids.\n        (primary): Handle TEMPLATE_ID_EXPR, and template-ids.\n\n        * pt.c (processing_specializations): New variable.\n        (template_header_count): Likewise.\n        (type_unification_real): New function.\n        (processing_explicit_specialization): Likewise.\n        (note_template_header): Likewise.\n        (is_member_template): Handle specializations.\n        (end_template_decl): Call reset_specialization.\n        (push_template_decl): Handle member template specializations.\n        (tsubst): Likewise.\n        (tsubst_copy): Handle TEMPLATE_ID_EXPR.\n        (instantiate_template): Handle specializations.\n        (instantiate_decl): Likewise.\n        (fn_type_unification): Handle explicit_targs.\n        (type_unification): Likewise.  Allow incomplete unification\n        without an error message, if allow_incomplete.\n        (get_bindings): Use new calling sequence for fn_type_unification.\n\n        * spew.c (yylex): Handle PFUNCNAME.\n\n        * tree.c (is_overloaded_fn): Handle TEMPLATE_ID_EXPR.\n        (really_overloaded_fn): Likewise.\n        (get_first_fn): Handle function templates.\n\n        * typeck.c (build_x_function_call): Use really_overloaded_fn.\n        Handle TEMPLATE_ID_EXPR.\n        (build_x_unary_op): Likewise.\n        (build_unary_op): Likewise.\n        (mark_addressable): Templates whose address is taken are marked\n        as used.\n\nFrom-SVN: r15774", "tree": {"sha": "2b2b05c5a921c813db1cbf8462a68424a4fff8d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b2b05c5a921c813db1cbf8462a68424a4fff8d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/386b8a85a66471540a1a75ff8f4138fc5ace6a63", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/386b8a85a66471540a1a75ff8f4138fc5ace6a63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/386b8a85a66471540a1a75ff8f4138fc5ace6a63", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/386b8a85a66471540a1a75ff8f4138fc5ace6a63/comments", "author": null, "committer": null, "parents": [{"sha": "e741306e3c161c6c594db76fe38a3224078201f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e741306e3c161c6c594db76fe38a3224078201f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e741306e3c161c6c594db76fe38a3224078201f7"}], "stats": {"total": 10602, "additions": 6031, "deletions": 4571}, "files": [{"sha": "89e98083b636eaa6088b3f9ca7a754a483b74802", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63", "patch": "@@ -1,3 +1,123 @@\n+Sat Sep 27 16:22:48 1997  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* friend.c (do_friend): Disable injection for all template-derived\n+ \tdecls.\n+\t* decl2.c (lang_decode_option): Handle -fguiding-decls.\n+\t* parse.y (notype_template_declarator): New nonterminal.\n+\t(direct_notype_declarator): Use it.\n+\t(complex_direct_notype_declarator): Likewise.\n+\t(object_template_id): Accept any kind of identifier after TEMPLATE.\n+\t(notype_qualified_id): Don't add template declarators here.\n+\n+Sat Sep 27 16:21:58 1997  Mark Mitchell  <mmitchell@usa.net>\n+\n+        * call.c (add_template_candidate): Add explicit_targs parameter.\n+        (build_scoped_method_call): Use it.\n+        (build_overload_call_real): Likewise.\n+        (build_user_type_conversion_1): Likewise.\n+        (build_new_function_call): Likewise.\n+        (build_object_call): Likewise.\n+        (build_new_op): Likewise.\n+        (build_new_method_call): Likewise.\n+        (build_new_function_call): Handle TEMPLATE_ID_EXPR.\n+        (build_new_method_call): Likewise.\n+\n+        * class.c (finish_struct_methods): Add specialization pass to\n+        determine which methods were specializing which other methods.\n+        (instantiate_type): Handle TEMPLATE_ID_EXPR.\n+\n+        * cp-tree.def (TEMPLATE_ID_EXPR): New tree code.\n+\n+        * cp-tree.h (name_mangling_version): New variable.\n+\t(flag_guiding_decls): Likewise.\n+        (build_template_decl_overload): New function.\n+        (begin_specialization): Likewise.\n+        (reset_specialization): Likewise.\n+        (end_specialization): Likewise.\n+        (determine_explicit_specialization): Likewise.\n+        (check_explicit_specialization): Likewise.\n+        (lookup_template_function): Likewise.\n+        (fn_type_unification): Add explicit_targs parameter.\n+        (type_unification): Likewise.\n+\n+        * decl.c (duplicate_decls): Add smarts for explicit\n+        specializations.\n+        (grokdeclarator): Handle TEMPLATE_ID_EXPR, and function\n+        specializations.\n+        (grokfndecl): Call check_explicit_specialization.\n+\n+        * decl2.c (lang_decode_option): Handle -fname-mangling-version.\n+        (build_expr_from_tree): Handle TEMPLATE_ID_EXPR.\n+        (check_classfn): Handle specializations.\n+\n+        * error.c (dump_function_name): Print specialization arguments.\n+\n+\t* friend.c (do_friend): Don't call pushdecl for template \n+        instantiations. \n+\n+        * init.c (build_member_call): Handle TEMPLATE_ID_EXPR.\n+\n+        * lang-options.h: Add -fname-mangling-version, -fguiding-decls, \n+\tand -fno-guiding-decls.\n+\n+        * lex.c (identifier_type): Return PFUNCNAME for template function\n+        names.\n+\n+        * method.c (build_decl_overload_real): New function.\n+        (build_template_parm_names): New function.\n+        (build_overload_identifier): Use it.\n+        (build_underscore_int): New function.\n+        (build_overload_int): Use it.  Add levels for template\n+        parameters.\n+        (build_overload_name): Likewise.  Also, handle TYPENAME_TYPEs.\n+        (build_overload_nested_names): Handle template type parameters.\n+        (build_template_decl_overload): New function.\n+\n+        * parse.y (YYSTYPE): New ntype member.\n+        (nested_name_specifier): Use it.\n+        (nested_name_specifier_1): Likewise.\n+        (PFUNCNAME): New token.\n+        (template_id, object_template_id): New non-terminals.\n+        (template_parm_list): Note specializations.\n+        (template_def): Likewise.\n+        (structsp): Likewise.\n+        (fn.def2): Handle member template specializations.\n+        (component_decl_1): Likewise.\n+        (direct_notype_declarator): Handle template-ids.\n+        (component_decl_1): Likewise.\n+        (direct_notype_declarator): Handle template-ids.\n+        (primary): Handle TEMPLATE_ID_EXPR, and template-ids.\n+\n+        * pt.c (processing_specializations): New variable.\n+        (template_header_count): Likewise.\n+        (type_unification_real): New function.\n+        (processing_explicit_specialization): Likewise.\n+        (note_template_header): Likewise.\n+        (is_member_template): Handle specializations.\n+        (end_template_decl): Call reset_specialization.\n+        (push_template_decl): Handle member template specializations.\n+        (tsubst): Likewise.\n+        (tsubst_copy): Handle TEMPLATE_ID_EXPR.\n+        (instantiate_template): Handle specializations.\n+        (instantiate_decl): Likewise.\n+        (fn_type_unification): Handle explicit_targs.\n+        (type_unification): Likewise.  Allow incomplete unification\n+        without an error message, if allow_incomplete.\n+        (get_bindings): Use new calling sequence for fn_type_unification.\n+\n+        * spew.c (yylex): Handle PFUNCNAME.\n+\n+        * tree.c (is_overloaded_fn): Handle TEMPLATE_ID_EXPR.\n+        (really_overloaded_fn): Likewise.\n+        (get_first_fn): Handle function templates.\n+\n+        * typeck.c (build_x_function_call): Use really_overloaded_fn.\n+        Handle TEMPLATE_ID_EXPR.\n+        (build_x_unary_op): Likewise.\n+        (build_unary_op): Likewise.\n+        (mark_addressable): Templates whose address is taken are marked  \n+        as used. \n+\n 1997-09-25  Andreas Schwab  <schwab@issan.informatik.uni-dortmund.de>\n \n \t* decl.c (init_decl_processing): Declare __builtin_constant_p as"}, {"sha": "ff2d5124f52764ed281a2193e8c60fdfb5cbe471", "filename": "gcc/cp/NEWS", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FNEWS?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63", "patch": "@@ -23,12 +23,8 @@\n      + Static data member templates work.\n      + Member function templates are now supported.\n      + Partial specialization of class templates is now supported.\n-     + The new 'template <>' specialization syntax is now accepted and\n-       ignored.\n-     + Explicit instantiation of template constructors and destructors is\n-       now supported.  For instance:\n-\n-            template A<int>::A(const A&);\n+     + Explicit specification of template parameters to function templates\n+       is now supported.\n \n   Things you may need to fix in your code:\n \n@@ -43,6 +39,11 @@\n \n             http://www.cygnus.com/misc/wp/dec96pub/template.html#temp.res\n \n+     + Guiding declarations are no longer supported.  Function declarations, \n+       including friend declarations, do not refer to template instantiations.\n+       You can restore the old behavior with -fguiding-decls until you fix\n+       your code.\n+\n   Other features:\n \n      + Default function arguments in templates will not be evaluated (or\n@@ -52,13 +53,16 @@\n      + The -ftemplate-depth-NN flag can be used to increase the maximum\n        recursive template instantiation depth, which defaults to 17. If you\n        need to use this flag, the compiler will tell you.\n+     + Explicit instantiation of template constructors and destructors is\n+       now supported.  For instance:\n+\n+            template A<int>::A(const A&);\n \n   Still not supported:\n \n      + Member class templates.\n      + Template template parameters.\n      + Template friends.\n-     + Explicit qualification of function templates.\n \n * Exception handling support has been significantly improved and is on by\n   default.  This can result in significant runtime overhead.  You can turn\n@@ -163,3 +167,14 @@\n * On the HPPA, some classes that do not define a copy constructor\n   will be passed and returned in memory again so that functions\n   returning those types can be inlined.\n+\n+*** The g++ team thanks everyone that contributed to this release,\n+    but especially:\n+\n+* Joe Buck <jbuck@synopsys.com>, the maintainer of the g++ FAQ.\n+* Brendan Kehoe <brendan@cygnus.com>, who coordinates testing of g++.\n+* Jason Merrill <jason@cygnus.com>, the g++ maintainer.\n+* Mark Mitchell <mmitchell@usa.net>, who implemented member function \n+  templates and explicit qualification of function templates.\n+* Mike Stump <mrs@wrs.com>, the previous g++ maintainer, who did most of\n+  the exception handling work."}, {"sha": "4e8750ce0111c881cf2a89e3bde871d46465770c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 68, "deletions": 35, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63", "patch": "@@ -77,7 +77,7 @@ static tree build_this PROTO((tree));\n static struct z_candidate * splice_viable PROTO((struct z_candidate *));\n static int any_viable PROTO((struct z_candidate *));\n static struct z_candidate * add_template_candidate\n-\tPROTO((struct z_candidate *, tree, tree, tree, int));\n+\tPROTO((struct z_candidate *, tree, tree, tree, tree, int));\n static struct z_candidate * add_template_conv_candidate \n         PROTO((struct z_candidate *, tree, tree, tree, tree));\n static struct z_candidate * add_builtin_candidates\n@@ -2847,7 +2847,7 @@ build_overload_call_real (fnname, parms, flags, final_cp, require_complete)\n \t  i = type_unification (DECL_INNERMOST_TEMPLATE_PARMS (function),\n \t\t\t\t&TREE_VEC_ELT (targs, 0),\n \t\t\t\tTYPE_ARG_TYPES (TREE_TYPE (function)),\n-\t\t\t\tparms, &template_cost, 0, 0);\n+\t\t\t\tparms, NULL_TREE, &template_cost, 0, 0);\n \t  if (i == 0)\n \t    {\n \t      function = instantiate_template (function, targs);\n@@ -4144,10 +4144,19 @@ add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n   return candidates;\n }\n \n+/* If TMPL can be successfully instantiated as indicated by\n+   EXPLICIT_TARGS and ARGLIST, adds the instantiation to CANDIDATES.\n+\n+   TMPL is the template.  EXPLICIT_TARGS are any explicit template arguments.\n+   ARGLIST is the arguments provided at the call-site.  The RETURN_TYPE\n+   is the desired type for conversion operators.  FLAGS are as for\n+   add_function_candidate.  */\n+\n static struct z_candidate *\n-add_template_candidate (candidates, tmpl, arglist, return_type, flags)\n+add_template_candidate (candidates, tmpl, explicit_targs, \n+\t\t\targlist, return_type, flags)\n      struct z_candidate *candidates;\n-     tree tmpl, arglist, return_type;\n+     tree tmpl, explicit_targs, arglist, return_type;\n      int flags;\n {\n   int ntparms = DECL_NTPARMS (tmpl);\n@@ -4156,7 +4165,8 @@ add_template_candidate (candidates, tmpl, arglist, return_type, flags)\n   int i;\n   tree fn;\n \n-  i = fn_type_unification (tmpl, targs, arglist, return_type, 0);\n+  i = fn_type_unification (tmpl, explicit_targs, targs, arglist,\n+\t\t\t   return_type, 0); \n \n   if (i != 0)\n     return candidates;\n@@ -4182,7 +4192,7 @@ add_template_conv_candidate (candidates, tmpl, obj, arglist, return_type)\n   int i;\n   tree fn;\n \n-  i = fn_type_unification (tmpl, targs, arglist, return_type, 0);\n+  i = fn_type_unification (tmpl, NULL_TREE, targs, arglist, return_type, 0);\n \n   if (i != 0)\n     return candidates;\n@@ -4312,7 +4322,7 @@ build_user_type_conversion_1 (totype, expr, flags)\n \t  templates = decl_tree_cons (NULL_TREE, ctors, templates);\n \t  candidates = \n \t    add_template_candidate (candidates, ctors,\n-\t\t\t\t    args, NULL_TREE, flags);\n+\t\t\t\t    NULL_TREE, args, NULL_TREE, flags);\n \t} \n       else \n \tcandidates = add_function_candidate (candidates, ctors,\n@@ -4353,8 +4363,8 @@ build_user_type_conversion_1 (totype, expr, flags)\n \t      {\n \t\ttemplates = decl_tree_cons (NULL_TREE, fn, templates);\n \t\tcandidates = \n-\t\t  add_template_candidate (candidates, fn, args,\n-\t\t\t\t\t  totype, flags);\n+\t\t  add_template_candidate (candidates, fn, NULL_TREE,\n+\t\t\t\t\t  args, totype, flags);\n \t      } \n \t    else \n \t      candidates = add_function_candidate (candidates, fn,\n@@ -4409,9 +4419,10 @@ build_user_type_conversion_1 (totype, expr, flags)\n     p = &(TREE_OPERAND (*p, 0));\n \n   /* Pedantically, normal function declarations are never considered\n-     to refer to template instantiations, but we won't implement that\n-     until we implement full template instantiation syntax.  */\n-  if (templates && ! cand->template && ! DECL_INITIAL (cand->fn)\n+     to refer to template instantiations, so we only do this with\n+     -fguiding-decls.  */ \n+  if (flag_guiding_decls && templates && ! cand->template \n+      && !DECL_INITIAL (cand->fn) \n       && TREE_CODE (TREE_TYPE (cand->fn)) != METHOD_TYPE)\n     add_maybe_template (cand->fn, templates);\n \n@@ -4471,8 +4482,15 @@ build_new_function_call (fn, args, obj)\n      tree fn, args, obj;\n {\n   struct z_candidate *candidates = 0, *cand;\n- \n-  if (obj == NULL_TREE && TREE_CODE (fn) == TREE_LIST)\n+  tree explicit_targs = NULL_TREE;\n+\n+  if (TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n+    {\n+      explicit_targs = TREE_OPERAND (fn, 1);\n+      fn = TREE_OPERAND (fn, 0);\n+    }\n+\n+  if (obj == NULL_TREE && really_overloaded_fn (fn))\n     {\n       tree t;\n       tree templates = NULL_TREE;\n@@ -4488,9 +4506,10 @@ build_new_function_call (fn, args, obj)\n \t    {\n \t      templates = decl_tree_cons (NULL_TREE, t, templates);\n \t      candidates = add_template_candidate\n-\t\t(candidates, t, args, NULL_TREE, LOOKUP_NORMAL);\n+\t\t(candidates, t, explicit_targs, args, NULL_TREE,\n+\t\t LOOKUP_NORMAL);  \n \t    }\n-\t  else\n+\t  else if (explicit_targs == NULL_TREE)\n \t    candidates = add_function_candidate\n \t      (candidates, t, args, LOOKUP_NORMAL);\n \t}\n@@ -4517,9 +4536,10 @@ build_new_function_call (fn, args, obj)\n \t}\n \n       /* Pedantically, normal function declarations are never considered\n-\t to refer to template instantiations, but we won't implement that\n-\t until we implement full template instantiation syntax.  */\n-      if (templates && ! cand->template && ! DECL_INITIAL (cand->fn))\n+\t to refer to template instantiations, so we only do this with\n+\t -fguiding-decls.  */\n+      if (flag_guiding_decls && templates && ! cand->template \n+\t  && ! DECL_INITIAL (cand->fn))\n \tadd_maybe_template (cand->fn, templates);\n \n       return build_over_call (cand->fn, cand->convs, args, LOOKUP_NORMAL);\n@@ -4554,9 +4574,10 @@ build_object_call (obj, args)\n \t  if (TREE_CODE (fn) == TEMPLATE_DECL)\n \t    {\n \t      templates = decl_tree_cons (NULL_TREE, fn, templates);\n-\t      candidates = add_template_candidate (candidates, fn,\n-\t\t\t\t\t\t   mem_args, NULL_TREE, \n-\t\t\t\t\t\t   LOOKUP_NORMAL);\n+\t      candidates \n+\t\t= add_template_candidate (candidates, fn, NULL_TREE,\n+\t\t\t\t\t  mem_args, NULL_TREE, \n+\t\t\t\t\t  LOOKUP_NORMAL);\n \t    }\n \t  else\n \t    candidates = add_function_candidate\n@@ -4804,8 +4825,10 @@ build_new_op (code, flags, arg1, arg2, arg3)\n       if (TREE_CODE (fns) == TEMPLATE_DECL)\n \t{\n \t  templates = decl_tree_cons (NULL_TREE, fns, templates);\n-\t  candidates = add_template_candidate\n-\t    (candidates, fns, arglist, TREE_TYPE (fnname), flags);\n+\t  candidates \n+\t    = add_template_candidate (candidates, fns, NULL_TREE,\n+\t\t\t\t      arglist, TREE_TYPE (fnname),\n+\t\t\t\t      flags); \n \t}\n       else\n \tcandidates = add_function_candidate (candidates, fns, arglist, flags);\n@@ -4833,9 +4856,10 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \t    {\n \t      /* A member template. */\n \t      templates = decl_tree_cons (NULL_TREE, fn, templates);\n-\t      candidates = add_template_candidate\n-\t\t(candidates, fn, this_arglist, \n-\t\t TREE_TYPE (fnname), LOOKUP_NORMAL);\n+\t      candidates \n+\t\t= add_template_candidate (candidates, fn, NULL_TREE,\n+\t\t\t\t\t  this_arglist,  TREE_TYPE\n+\t\t\t\t\t  (fnname), LOOKUP_NORMAL); \n \t    }\n \t  else\n \t    candidates = add_function_candidate\n@@ -4934,9 +4958,10 @@ build_new_op (code, flags, arg1, arg2, arg3)\n \tenforce_access (cand->basetype_path, cand->fn);\n \n       /* Pedantically, normal function declarations are never considered\n-\t to refer to template instantiations, but we won't implement that\n-\t until we implement full template instantiation syntax.  */\n-      if (templates && ! cand->template && ! DECL_INITIAL (cand->fn)\n+\t to refer to template instantiations, so we only do this with\n+\t -fguiding-decls.  */ \n+      if (flag_guiding_decls && templates && ! cand->template \n+\t  && ! DECL_INITIAL (cand->fn)\n \t  && TREE_CODE (TREE_TYPE (cand->fn)) != METHOD_TYPE)\n \tadd_maybe_template (cand->fn, templates);\n \n@@ -5435,11 +5460,18 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n      int flags;\n {\n   struct z_candidate *candidates = 0, *cand;\n+  tree explicit_targs = NULL_TREE;\n   tree basetype, mem_args, fns, instance_ptr;\n   tree pretty_name;\n   tree user_args = args;\n   tree templates = NULL_TREE;\n \n+  if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n+    {\n+      explicit_targs = TREE_OPERAND (name, 1);\n+      name = TREE_OPERAND (name, 0);\n+    }\n+\n   /* If there is an extra argument for controlling virtual bases,\n      remove it for error reporting.  */\n   if (flags & LOOKUP_HAS_IN_CHARGE)\n@@ -5536,12 +5568,12 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n \t      /* A member template. */\n \t      templates = decl_tree_cons (NULL_TREE, t, templates);\n \t      candidates = \n-\t\tadd_template_candidate (candidates, t,\n+\t\tadd_template_candidate (candidates, t, explicit_targs,\n \t\t\t\t\tthis_arglist,\n \t\t\t\t\tTREE_TYPE (name), \n \t\t\t\t\tLOOKUP_NORMAL); \n \t    }\n-\t  else \n+\t  else if (explicit_targs == NULL_TREE) \n \t    candidates = add_function_candidate (candidates, t,\n \t\t\t\t\t\t this_arglist, flags);\n \n@@ -5589,9 +5621,10 @@ build_new_method_call (instance, name, args, basetype_path, flags)\n     flags |= LOOKUP_NONVIRTUAL;\n \n   /* Pedantically, normal function declarations are never considered\n-     to refer to template instantiations, but we won't implement that\n-     until we implement full template instantiation syntax.  */\n-  if (templates && ! cand->template && ! DECL_INITIAL (cand->fn))\n+     to refer to template instantiations, so we only do this with\n+     -fguiding-decls.  */ \n+  if (flag_guiding_decls && templates && ! cand->template \n+      && ! DECL_INITIAL (cand->fn))\n     add_maybe_template (cand->fn, templates);\n \n   return build_over_call"}, {"sha": "9f1aeb01685468bccdec1e2707f880743bb9c2a6", "filename": "gcc/cp/class.c", "status": "modified", "additions": 97, "deletions": 28, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63", "patch": "@@ -2079,6 +2079,53 @@ finish_struct_methods (t, fn_fields, nonprivate_method)\n \tobstack_free (current_obstack, baselink_vec);\n     }\n \n+  /* Now, figure out what any member template specializations were\n+     specializing.  */\n+  for (i = 0; i < TREE_VEC_LENGTH (method_vec); ++i)\n+    {\n+      tree fn;\n+      for (fn = TREE_VEC_ELT (method_vec, i);\n+\t   fn != NULL_TREE;\n+\t   fn = DECL_CHAIN (fn))\n+\tif (DECL_TEMPLATE_SPECIALIZATION (fn))\n+\t  {\n+\t    tree f;\n+\t    tree spec_args;\n+\n+\t    /* If there is a template, and t uses template parms, wer\n+\t       are dealing with a specialization of a member\n+\t       template in a template class, and we must grab the\n+\t       template, rather than the function.  */\n+\t    if (DECL_TI_TEMPLATE (fn) && uses_template_parms (t))\n+\t      f = DECL_TI_TEMPLATE (fn);\n+\t    else\n+\t      f = fn;\n+\n+\t    /* We want the specialization arguments, which will be the\n+\t       innermost ones.  */\n+\t    if (DECL_TI_ARGS (f) \n+\t\t&& TREE_CODE (DECL_TI_ARGS (f)) == TREE_VEC)\n+\t      spec_args \n+\t\t= TREE_VEC_ELT (DECL_TI_ARGS (f), 0);\n+\t    else\n+\t      spec_args = DECL_TI_ARGS (f);\n+\t\t\n+\t    check_explicit_specialization \n+\t      (lookup_template_function (DECL_NAME (f), spec_args),\n+\t       f, 0, 1);\n+\n+\t    /* Now, the assembler name will be correct for fn, so we\n+\t       make its RTL.  */\n+\t    DECL_RTL (f) = 0;\n+\t    make_decl_rtl (f, NULL_PTR, 1);\n+\t    if (f != fn)\n+\t      {\n+\t\tDECL_RTL (fn) = 0;\n+\t\tmake_decl_rtl (fn, NULL_PTR, 1);\n+\t      }\n+\t  }\n+    }\n+\n   return method_vec;\n }\n \n@@ -4877,6 +4924,8 @@ instantiate_type (lhstype, rhs, complain)\n      tree lhstype, rhs;\n      int complain;\n {\n+  tree explicit_targs = NULL_TREE;\n+\n   if (TREE_CODE (lhstype) == UNKNOWN_TYPE)\n     {\n       if (complain)\n@@ -4991,6 +5040,13 @@ instantiate_type (lhstype, rhs, complain)\n \treturn rhs;\n       }\n \n+    case TEMPLATE_ID_EXPR:\n+      {\n+\texplicit_targs = TREE_OPERAND (rhs, 1);\n+\trhs = TREE_OPERAND (rhs, 0);\n+      }\n+    /* fall through */\n+\n     case TREE_LIST:\n       {\n \ttree elem, baselink, name;\n@@ -5025,14 +5081,17 @@ instantiate_type (lhstype, rhs, complain)\n \tif (globals > 0)\n \t  {\n \t    elem = get_first_fn (rhs);\n-\t    while (elem)\n-\t      if (! comptypes (lhstype, TREE_TYPE (elem), 1))\n-\t\telem = DECL_CHAIN (elem);\n-\t      else\n-\t\t{\n-\t\t  mark_used (elem);\n-\t\t  return elem;\n-\t\t}\n+\t    /* If there are explicit_targs, only a template function\n+\t       can match.  */\n+\t    if (explicit_targs == NULL_TREE)\n+\t      while (elem)\n+\t\tif (! comptypes (lhstype, TREE_TYPE (elem), 1))\n+\t\t  elem = DECL_CHAIN (elem);\n+\t\telse\n+\t\t  {\n+\t\t    mark_used (elem);\n+\t\t    return elem;\n+\t\t  }\n \n \t    /* No exact match found, look for a compatible template.  */\n \t    {\n@@ -5046,7 +5105,8 @@ instantiate_type (lhstype, rhs, complain)\n \t\t    i = type_unification\n \t\t      (DECL_INNERMOST_TEMPLATE_PARMS (elem), \n \t\t       &TREE_VEC_ELT (t, 0), TYPE_ARG_TYPES (TREE_TYPE (elem)),\n-\t\t       TYPE_ARG_TYPES (lhstype), &d, 0, 1);\n+\t\t       TYPE_ARG_TYPES (lhstype), explicit_targs, &d,\n+\t\t       1, 1);\n \t\t    if (i == 0)\n \t\t      {\n \t\t\tif (save_elem)\n@@ -5068,38 +5128,47 @@ instantiate_type (lhstype, rhs, complain)\n \t\t}\n \t    }\n \n-\t    /* No match found, look for a compatible function.  */\n-\t    elem = get_first_fn (rhs);\n-\t    while (elem && comp_target_types (lhstype,\n-\t\t\t\t\t      TREE_TYPE (elem), 1) <= 0)\n-\t      elem = DECL_CHAIN (elem);\n-\t    if (elem)\n+\t    /* If there are explicit_targs, only a template function\n+\t       can match.  */\n+\t    if (explicit_targs == NULL_TREE) \n \t      {\n-\t\ttree save_elem = elem;\n-\t\telem = DECL_CHAIN (elem);\n+\t\t/* No match found, look for a compatible function.  */\n+\t\telem = get_first_fn (rhs);\n \t\twhile (elem && comp_target_types (lhstype,\n-\t\t\t\t\t\t  TREE_TYPE (elem), 0) <= 0)\n+\t\t\t\t\t\t  TREE_TYPE (elem), 1) <= 0)\n \t\t  elem = DECL_CHAIN (elem);\n \t\tif (elem)\n \t\t  {\n-\t\t    if (complain)\n+\t\t    tree save_elem = elem;\n+\t\t    elem = DECL_CHAIN (elem);\n+\t\t    while (elem \n+\t\t\t   && comp_target_types (lhstype,\n+\t\t\t\t\t\t TREE_TYPE (elem), 0) <= 0)\n+\t\t      elem = DECL_CHAIN (elem);\n+\t\t    if (elem)\n \t\t      {\n-\t\t\tcp_error (\"cannot resolve overload to target type `%#T'\",\n-\t\t\t\t  lhstype);\n-\t\t\tcp_error_at (\"  ambiguity between `%#D'\", save_elem);\n-\t\t\tcp_error_at (\"  and `%#D', at least\", elem);\n+\t\t\tif (complain)\n+\t\t\t  {\n+\t\t\t    cp_error \n+\t\t\t      (\"cannot resolve overload to target type `%#T'\",\n+\t\t\t       lhstype);\n+\t\t\t    cp_error_at (\"  ambiguity between `%#D'\",\n+\t\t\t\t\t save_elem); \n+\t\t\t    cp_error_at (\"  and `%#D', at least\", elem);\n+\t\t\t  }\n+\t\t\treturn error_mark_node;\n \t\t      }\n-\t\t    return error_mark_node;\n+\t\t    mark_used (save_elem);\n+\t\t    return save_elem;\n \t\t  }\n-\t\tmark_used (save_elem);\n-\t\treturn save_elem;\n \t      }\n \t    if (complain)\n \t      {\n \t\tcp_error (\"cannot resolve overload to target type `%#T'\",\n \t\t\t  lhstype);\n-\t\tcp_error (\"  because no suitable overload of function `%D' exists\",\n-\t\t\t  TREE_PURPOSE (rhs));\n+\t\tcp_error \n+\t\t  (\"  because no suitable overload of function `%D' exists\",\n+\t\t   TREE_PURPOSE (rhs));\n \t      }\n \t    return error_mark_node;\n \t  }"}, {"sha": "65d20a71e5e26b8003f3a208e62aba34beb77a32", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63", "patch": "@@ -113,6 +113,14 @@ DEFTREECODE (USING_DECL, \"using_decl\", \"d\", 0)\n /* An un-parsed default argument.  Looks like an IDENTIFIER_NODE.  */\n DEFTREECODE (DEFAULT_ARG, \"default_arg\", \"c\", 2)\n \n+/* A template-id, like foo<int>.  The first operand is the template.  \n+   The second is the list of explicitly specified arguments.  The \n+   template will be a FUNCTION_DECL, TEMPLATE_DECL, or a list of\n+   overloaded functions and templates if the template-id refers to\n+   a global template.  If the template-id refers to a member template,\n+   the template will will be an IDENTIFIER_NODE.  */\n+DEFTREECODE (TEMPLATE_ID_EXPR, \"template_id_expr\", \"e\", 2)\n+\n /* A whole bunch of tree codes for the initial, superficial parsing of\n    templates.  */\n DEFTREECODE (LOOKUP_EXPR, \"lookup_expr\", \"e\", 2)"}, {"sha": "a44447a60d297c8ac55c169fc5c6a2423b7510f2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63", "patch": "@@ -307,6 +307,14 @@ extern int flag_handle_signatures;\n    inline by default.  */\n \n extern int flag_default_inline;\n+\n+/* The name-mangling scheme to use.  Versions of gcc before 2.8 use\n+   version 0.  */\n+extern int name_mangling_version;\n+\n+/* Nonzero means that guiding declarations are allowed.  */\n+extern int flag_guiding_decls;\n+\n \f\n /* C++ language-specific tree codes.  */\n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) SYM,\n@@ -2295,6 +2303,7 @@ extern void  report_type_mismatch\t\tPROTO((struct candidate *, tree, char *));\n extern char *build_overload_name\t\tPROTO((tree, int, int));\n extern tree build_static_name\t\t\tPROTO((tree, tree));\n extern tree build_decl_overload\t\t\tPROTO((tree, tree, int));\n+extern tree build_template_decl_overload        PROTO((tree, tree, tree, tree, tree, int));\n extern tree build_typename_overload\t\tPROTO((tree));\n extern tree build_overload_with_type\t\tPROTO((tree, tree));\n extern tree build_opfncall\t\t\tPROTO((enum tree_code, int, tree, tree, tree));\n@@ -2312,18 +2321,24 @@ extern tree tsubst_chain\t\t\tPROTO((tree, tree));\n extern void begin_member_template_processing    PROTO((tree));\n extern void end_member_template_processing      PROTO((void));\n extern void begin_template_parm_list\t\tPROTO((void));\n+extern void begin_specialization                PROTO((void));\n+extern void reset_specialization                PROTO((void));\n+extern void end_specialization                  PROTO((void));\n+extern tree determine_explicit_specialization   PROTO((tree, tree, tree *, int, int));\n+extern int check_explicit_specialization       PROTO((tree, tree, int, int));\n extern tree process_template_parm\t\tPROTO((tree, tree));\n extern tree end_template_parm_list\t\tPROTO((tree));\n extern void end_template_decl\t\t\tPROTO((void));\n extern tree current_template_args\t\tPROTO((void));\n extern void push_template_decl\t\t\tPROTO((tree));\n extern tree lookup_template_class\t\tPROTO((tree, tree, tree));\n+extern tree lookup_template_function            PROTO((tree, tree));\n extern int uses_template_parms\t\t\tPROTO((tree));\n extern tree instantiate_class_template\t\tPROTO((tree));\n extern tree instantiate_template\t\tPROTO((tree, tree));\n extern void overload_template_name\t\tPROTO((tree));\n-extern int fn_type_unification                  PROTO((tree, tree, tree, tree, int));\n-extern int type_unification\t\t\tPROTO((tree, tree *, tree, tree, int *, int, int));\n+extern int fn_type_unification                  PROTO((tree, tree, tree, tree, tree, int));\n+extern int type_unification\t\t\tPROTO((tree, tree *, tree, tree, tree, int *, int, int));\n struct tinst_level *tinst_for_decl\t\tPROTO((void));\n extern void mark_decl_instantiated\t\tPROTO((tree, int));\n extern int more_specialized\t\t\tPROTO((tree, tree));"}, {"sha": "71c2dbf22c3fc08a7bfd5896848546dd6d445624", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 100, "deletions": 23, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63", "patch": "@@ -157,9 +157,9 @@ static tree maybe_build_cleanup_1 PROTO((tree, tree));\n static tree lookup_name_real PROTO((tree, int, int));\n static void warn_extern_redeclared_static PROTO((tree, tree));\n static void grok_reference_init PROTO((tree, tree, tree, tree *));\n-static tree grokfndecl PROTO((tree, tree, tree, int,\n+static tree grokfndecl PROTO((tree, tree, tree, tree, int,\n \t\t\t      enum overload_flags,\n-\t\t\t      tree, tree, tree, int, int, int, int));\n+\t\t\t      tree, tree, tree, int, int, int, int, int, int));\n static tree grokvardecl PROTO((tree, tree, RID_BIT_TYPE *, int, int));\n static tree lookup_tag PROTO((enum tree_code, tree,\n \t\t\t      struct binding_level *, int));\n@@ -2563,6 +2563,20 @@ duplicate_decls (newdecl, olddecl)\n \t  cp_error_at (\"previous declaration as `%#D'\", olddecl);\n \t}\n     }\n+  else if ((TREE_CODE (olddecl) == FUNCTION_DECL \n+\t    && DECL_TEMPLATE_SPECIALIZATION (olddecl)\n+\t    && (!DECL_TEMPLATE_SPECIALIZATION (newdecl)\n+\t\t|| (DECL_TI_TEMPLATE (newdecl) \n+\t\t    != DECL_TI_TEMPLATE (olddecl))))\n+\t   || (TREE_CODE (newdecl) == FUNCTION_DECL\n+\t       && DECL_TEMPLATE_SPECIALIZATION (newdecl)\n+\t       && (!DECL_TEMPLATE_SPECIALIZATION (olddecl)\n+\t\t   || (DECL_TI_TEMPLATE (olddecl) != DECL_TI_TEMPLATE\n+\t\t       (newdecl)))))\n+    /* It's OK to have a template specialization and a non-template\n+       with the same type, or to have specializations of two\n+       different templates with the same type. */\n+    return 0;\n   else\n     {\n       char *errmsg = redeclaration_error_message (newdecl, olddecl);\n@@ -3030,7 +3044,9 @@ pushdecl (x)\n       char *file;\n       int line;\n #endif\n-\n+      if (TREE_CODE (name) == TEMPLATE_ID_EXPR)\n+\tname = TREE_OPERAND (name, 0);\n+      \n       t = lookup_name_current_level (name);\n       if (t == error_mark_node)\n \t{\n@@ -7173,14 +7189,16 @@ bad_specifiers (object, type, virtualp, quals, inlinep, friendp, raises)\n    not look, and -1 if we should not call `grokclassfn' at all.  */\n \n static tree\n-grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n-\t    raises, attrlist, check, publicp, inlinep, funcdef_flag)\n+grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n+\t    raises, attrlist, check, friendp, publicp, inlinep, funcdef_flag,\n+\t    template_count)\n      tree ctype, type;\n      tree declarator;\n+     tree orig_declarator;\n      int virtualp;\n      enum overload_flags flags;\n      tree quals, raises, attrlist;\n-     int check, publicp, inlinep, funcdef_flag;\n+     int check, friendp, publicp, inlinep, funcdef_flag, template_count;\n {\n   tree cname, decl;\n   int staticp = ctype && TREE_CODE (type) == FUNCTION_TYPE;\n@@ -7255,6 +7273,11 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n       }\n \n   /* Caller will do the rest of this.  */\n+  check_explicit_specialization (orig_declarator, decl,\n+\t\t\t\t template_count, \n+\t\t\t\t funcdef_flag ? 2 : \n+\t\t\t\t (friendp ? 3 : 0));\n+\n   if (check < 0)\n     return decl;\n \n@@ -7272,6 +7295,7 @@ grokfndecl (ctype, type, declarator, virtualp, flags, quals,\n       DECL_CONSTRUCTOR_P (decl) = 1;\n \n       grokclassfn (ctype, declarator, decl, flags, quals);\n+\n       if (check)\n \t{\n \t  tmp = check_classfn (ctype, decl);\n@@ -7596,6 +7620,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n   enum overload_flags flags = NO_SPECIAL;\n   tree quals = NULL_TREE;\n   tree raises = NULL_TREE;\n+  int template_count = 0;\n \n   RIDBIT_RESET_ALL (specbits);\n   if (decl_context == FUNCDEF)\n@@ -7709,9 +7734,27 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      }\n \t    ctype = NULL_TREE;\n \t    break;\n+\t    \n+\t  case TEMPLATE_ID_EXPR:\n+\t      {\n+\t\ttree fns = TREE_OPERAND (decl, 0);\n+\n+\t\tif (TREE_CODE (fns) == LOOKUP_EXPR)\n+\t\t  fns = TREE_OPERAND (fns, 0);\n+\n+\t\tif (TREE_CODE (fns) == IDENTIFIER_NODE)\n+\t\t  dname = fns;\n+\t\telse if (really_overloaded_fn (fns))\n+\t\t  dname = DECL_NAME (get_first_fn (fns));\n+\t\telse\n+\t\t  dname = DECL_NAME (fns);\n+\t      }\n+\t  /* fall through */\n \n \t  case IDENTIFIER_NODE:\n-\t    dname = decl;\n+\t    if (TREE_CODE (decl) == IDENTIFIER_NODE)\n+\t      dname = decl;\n+\n \t    next = 0;\n \n \t    if (is_rid (dname))\n@@ -8407,7 +8450,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n      Descend through it, creating more complex types, until we reach\n      the declared identifier (or NULL_TREE, in an absolute declarator).  */\n \n-  while (declarator && TREE_CODE (declarator) != IDENTIFIER_NODE)\n+  while (declarator && TREE_CODE (declarator) != IDENTIFIER_NODE\n+\t && TREE_CODE (declarator) != TEMPLATE_ID_EXPR)\n     {\n       /* Each level of DECLARATOR is either an ARRAY_REF (for ...[..]),\n \t an INDIRECT_REF (for *...),\n@@ -8661,6 +8705,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    if (inner_decl && TREE_CODE (inner_decl) == SCOPE_REF)\n \t      inner_decl = TREE_OPERAND (inner_decl, 1);\n \n+\t    if (inner_decl && TREE_CODE (inner_decl) == TEMPLATE_ID_EXPR) \n+\t      inner_decl = dname;\n+\n \t    /* Pick up type qualifiers which should be applied to `this'.  */\n \t    quals = TREE_OPERAND (declarator, 2);\n \n@@ -8670,9 +8717,11 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    /* Say it's a definition only for the CALL_EXPR\n \t       closest to the identifier.  */\n \t    funcdecl_p\n-\t      = inner_decl && (TREE_CODE (inner_decl) == IDENTIFIER_NODE\n-\t\t\t       || TREE_CODE (inner_decl) == BIT_NOT_EXPR);\n-\n+\t      = inner_decl \n+\t      && (TREE_CODE (inner_decl) == IDENTIFIER_NODE\n+\t\t  || TREE_CODE (inner_decl) == TEMPLATE_ID_EXPR \n+\t\t  || TREE_CODE (inner_decl) == BIT_NOT_EXPR);\n+\t    \n \t    if (ctype == NULL_TREE\n \t\t&& decl_context == FIELD\n \t\t&& funcdecl_p\n@@ -8961,6 +9010,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t       resolve to.  The code here just needs to build\n \t       up appropriate member types.  */\n \t    tree sname = TREE_OPERAND (declarator, 1);\n+\t    tree t;\n+\n \t    /* Destructors can have their visibilities changed as well.  */\n \t    if (TREE_CODE (sname) == BIT_NOT_EXPR)\n \t      sname = TREE_OPERAND (sname, 0);\n@@ -9012,6 +9063,18 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      }\n \t    ctype = TREE_OPERAND (declarator, 0);\n \n+\t    t = ctype;\n+\t    while (t != NULL_TREE) \n+\t      {\n+\t\tif (CLASSTYPE_TEMPLATE_INFO (t))\n+\t\t  template_count += 1;\n+\t\tt = TYPE_MAIN_DECL (t);\n+\t\tif (DECL_LANG_SPECIFIC (t))\n+\t\t  t = DECL_CLASS_CONTEXT (t);\n+\t\telse\n+\t\t  t = NULL_TREE;\n+\t      }\n+\n \t    if (sname == NULL_TREE)\n \t      goto done_scoping;\n \n@@ -9430,10 +9493,13 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \t    /* Tell grokfndecl if it needs to set TREE_PUBLIC on the node.  */\n \t    publicp = (! friendp || ! staticp);\n-\t    decl = grokfndecl (ctype, type, declarator,\n+\t    decl = grokfndecl (ctype, type, \n+\t\t\t       TREE_CODE (declarator) != TEMPLATE_ID_EXPR\n+\t\t\t       ? declarator : dname,\n+\t\t\t       declarator,\n \t\t\t       virtualp, flags, quals, raises, attrlist,\n-\t\t\t       friendp ? -1 : 0, publicp, inlinep,\n-\t\t\t       funcdef_flag);\n+\t\t\t       friendp ? -1 : 0, friendp, publicp, inlinep,\n+\t\t\t       funcdef_flag, template_count);\n \t    if (decl == NULL_TREE)\n \t      return NULL_TREE;\n #if 0\n@@ -9451,9 +9517,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t       members of other classes.  */\n \t    /* All method decls are public, so tell grokfndecl to set\n \t       TREE_PUBLIC, also.  */\n-\t    decl = grokfndecl (ctype, type, declarator,\n+\t    decl = grokfndecl (ctype, type, declarator, declarator,\n \t\t\t       virtualp, flags, quals, raises, attrlist,\n-\t\t\t       friendp ? -1 : 0, 1, 0, funcdef_flag);\n+\t\t\t       friendp ? -1 : 0, friendp, 1, 0, funcdef_flag,\n+\t\t\t       template_count);\n \t    if (decl == NULL_TREE)\n \t      return NULL_TREE;\n \t  }\n@@ -9578,12 +9645,17 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n       }\n     else if (TREE_CODE (type) == FUNCTION_TYPE || TREE_CODE (type) == METHOD_TYPE)\n       {\n-\ttree original_name = declarator;\n+\ttree original_name;\n \tint publicp = 0;\n \n \tif (! declarator)\n \t  return NULL_TREE;\n \n+\tif (TREE_CODE (declarator) == TEMPLATE_ID_EXPR)\n+\t  original_name = dname;\n+\telse\n+\t  original_name = declarator;\n+\n \tif (RIDBIT_SETP (RID_AUTO, specbits))\n \t  error (\"storage class `auto' invalid for function `%s'\", name);\n \telse if (RIDBIT_SETP (RID_REGISTER, specbits))\n@@ -9621,7 +9693,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t      && IDENTIFIER_POINTER (original_name)[1] == '_'\n \t\t      && strncmp (IDENTIFIER_POINTER (original_name)+2, \"builtin_\", 8) == 0))\n \t      /* Plain overloading: will not be grok'd by grokclassfn.  */\n-\t      declarator = build_decl_overload (dname, TYPE_ARG_TYPES (type), 0);\n+\t      if (name_mangling_version < 1 \n+\t\t  || TREE_CODE (declarator) != TEMPLATE_ID_EXPR)\n+\t\tdeclarator = build_decl_overload (dname, TYPE_ARG_TYPES (type), 0);\n \t  }\n \telse if (TREE_CODE (type) == FUNCTION_TYPE && staticp < 2)\n \t  type = build_cplus_method_type (build_type_variant (ctype, constp, volatilep),\n@@ -9632,16 +9706,19 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t   || RIDBIT_SETP (RID_EXTERN, specbits)\n \t\t   || !RIDBIT_SETP (RID_STATIC, specbits));\n \n-\tdecl = grokfndecl (ctype, type, original_name,\n+\tdecl = grokfndecl (ctype, type, original_name, declarator,\n \t\t\t   virtualp, flags, quals, raises, attrlist,\n-\t\t\t   friendp ? 2 : 1,\n-\t\t\t   publicp, inlinep, funcdef_flag);\n+\t\t\t   friendp ? 2 : 1, friendp,\n+\t\t\t   publicp, inlinep, funcdef_flag, \n+\t\t\t   template_count);\n \tif (decl == NULL_TREE)\n \t  return NULL_TREE;\n \n-\tif (ctype == NULL_TREE && DECL_LANGUAGE (decl) != lang_c)\n+\tif (ctype == NULL_TREE && DECL_LANGUAGE (decl) != lang_c\n+\t    && (!DECL_TEMPLATE_SPECIALIZATION (decl) ||\n+\t\tname_mangling_version < 1)) \n \t  DECL_ASSEMBLER_NAME (decl) = current_namespace_id (declarator);\n-\n+\t\n \tif (staticp == 1)\n \t  {\n \t    int illegal_static = 0;"}, {"sha": "5b40e2704acc2392069e81877b91b20f9fb028da", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63", "patch": "@@ -406,6 +406,14 @@ int flag_weak = 1;\n \n int max_tinst_depth = 17;\n \n+/* The name-mangling scheme to use.  Must be 1 or greater to support\n+   template functions with identical types, but different template\n+   arguments.  */\n+int name_mangling_version = 1;\n+\n+/* Nonzero means that guiding declarations are allowed.  */\n+int flag_guiding_decls;\n+\n /* Table of language-dependent -f options.\n    STRING is the option name.  VARIABLE is the address of the variable.\n    ON_VALUE is the value to store in VARIABLE\n@@ -526,6 +534,17 @@ lang_decode_option (p)\n \t  flag_implicit_templates = 0;\n \t  found = 1;\n \t}\n+      else if (!strcmp (p, \"guiding-decls\"))\n+\t{\n+\t  flag_guiding_decls = 1;\n+\t  name_mangling_version = 0;\n+\t  found = 1;\n+\t}\n+      else if (!strcmp (p, \"no-guiding-decls\"))\n+\t{\n+\t  flag_guiding_decls = 0;\n+\t  found = 1;\n+\t}\n       else if (!strncmp (p, \"template-depth-\", 15))\n \t{\n \t  char *endp = p + 15;\n@@ -542,6 +561,22 @@ lang_decode_option (p)\n \t  max_tinst_depth = atoi (p + 15);\n \ttemplate_depth_lose: ;\n \t}\n+      else if (!strncmp (p, \"name-mangling-version-\", 22))\n+\t{\n+\t  char *endp = p + 22;\n+\t  while (*endp)\n+\t    {\n+\t      if (*endp >= '0' && *endp <= '9')\n+\t\tendp++;\n+\t      else\n+\t\t{\n+\t\t  error (\"Invalid option `%s'\", p - 2);\n+\t\t  goto mangling_version_lose;\n+\t\t}\n+\t    }\n+\t  name_mangling_version = atoi (p + 22);\n+\tmangling_version_lose:\n+\t}\n       else for (j = 0;\n \t\t!found && j < sizeof (lang_f_options) / sizeof (lang_f_options[0]);\n \t\tj++)\n@@ -1395,10 +1430,15 @@ check_classfn (ctype, function)\n \n \t\t      if (comptypes (TREE_TYPE (TREE_TYPE (function)),\n \t\t\t\t     TREE_TYPE (TREE_TYPE (fndecl)), 1)\n-\t\t\t  && compparms (p1, p2, 3))\n+\t\t\t  && compparms (p1, p2, 3)\n+\t\t\t  && (DECL_TEMPLATE_SPECIALIZATION (function)\n+\t\t\t      == DECL_TEMPLATE_SPECIALIZATION (fndecl))\n+\t\t\t  && (!DECL_TEMPLATE_SPECIALIZATION (function)\n+\t\t\t      || (DECL_TI_TEMPLATE (function) \n+\t\t\t\t  == DECL_TI_TEMPLATE (fndecl))))\n \t\t\treturn fndecl;\n \n-\t\t      if (is_member_template (fndecl)) \n+\t\t      if (is_member_template (fndecl))\n \t\t\t/* This function might be an instantiation\n \t\t\t   or specialization of fndecl.  */\n \t\t\ttemplates = \n@@ -3368,6 +3408,12 @@ build_expr_from_tree (t)\n       else\n \treturn do_identifier (TREE_OPERAND (t, 0), 0);\n \n+    case TEMPLATE_ID_EXPR:\n+      return lookup_template_function (build_expr_from_tree\n+\t\t\t\t       (TREE_OPERAND (t, 0)),\n+\t\t\t\t       build_expr_from_tree\n+\t\t\t\t       (TREE_OPERAND (t, 1)));\n+\n     case INDIRECT_REF:\n       return build_x_indirect_ref\n \t(build_expr_from_tree (TREE_OPERAND (t, 0)), \"unary *\");"}, {"sha": "bec7bfaa1e4d2f8e4089e4c595afc6f2d7b05660", "filename": "gcc/cp/error.c", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63", "patch": "@@ -924,6 +924,71 @@ dump_function_name (t)\n     }\n   else\n     dump_decl (name, 0);\n+\n+  if (DECL_TEMPLATE_SPECIALIZATION (t) || DECL_IMPLICIT_INSTANTIATION (t))\n+    {\n+      tree args = DECL_TEMPLATE_INFO (t) \n+\t? DECL_TI_ARGS (t) : NULL_TREE; \n+\n+      OB_PUTC ('<');\n+\n+      /* Be careful only to print things when we have them, so as not\n+\t to crash producing error messages.  */\n+      if (args)\n+\t{\n+\t  if (TREE_CODE (args) == TREE_LIST)\n+\t    {\n+\t      tree arg;\n+\t      int need_comma = 0;\n+\n+\t      for (arg = args; arg; arg = TREE_CHAIN (arg))\n+\t\t{\n+\t\t  tree a = TREE_VALUE (arg);\n+\n+\t\t  if (need_comma)\n+\t\t    OB_PUTS (\", \");\n+\n+\t\t  if (a)\n+\t\t    {\n+\t\t      if (TREE_CODE_CLASS (TREE_CODE (a)) == 't')\n+\t\t\tdump_type (a, 0);\n+\t\t      else\n+\t\t\tdump_expr (a, 0);\n+\t\t    }\n+\t\t  \n+\t\t  need_comma = 1;\n+\t\t}\n+\t    }\n+\t  else if (TREE_CODE (args) == TREE_VEC)\n+\t    {\n+\t      int i;\n+\t      int need_comma = 0;\n+\n+\t      if (TREE_VEC_LENGTH (args) > 0\n+\t\t  && TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC)\n+\t\targs = TREE_VEC_ELT (args, 0);\n+\n+\t      for (i = 0; i < TREE_VEC_LENGTH (args); i++)\n+\t\t{\n+\t\t  tree a = TREE_VEC_ELT (args, i);\n+\n+\t\t  if (need_comma)\n+\t\t    OB_PUTS (\", \");\n+\n+\t\t  if (a)\n+\t\t    {\n+\t\t      if (TREE_CODE_CLASS (TREE_CODE (a)) == 't')\n+\t\t\tdump_type (a, 0);\n+\t\t      else\n+\t\t\tdump_expr (a, 0);\n+\t\t    }\n+\t\t  \n+\t\t  need_comma = 1;\n+\t\t}\n+\t    }\n+\t}\n+      OB_PUTC ('>');\n+    }\n }\n \n static void"}, {"sha": "fbfffe77f23ac833fed8557e99865e91e74e84f2", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63", "patch": "@@ -380,9 +380,11 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals, funcdef_flag)\n       if (funcdef_flag)\n \tDECL_CLASS_CONTEXT (decl) = current_class_type;\n \n-      /* We can call pushdecl here, because the TREE_CHAIN of this\n-\t FUNCTION_DECL is not needed for other purposes.  */\n-      decl = pushdecl (decl);\n+      if (! DECL_USE_TEMPLATE (decl))\n+\t/* We can call pushdecl here, because the TREE_CHAIN of this\n+\t   FUNCTION_DECL is not needed for other purposes.  Don't do this\n+\t   for a template instantiation. */\n+\tdecl = pushdecl (decl);\n \n       make_decl_rtl (decl, NULL_PTR, 1);\n       add_friend (current_class_type, decl);"}, {"sha": "5b7f9132aca9341549188b3725c873e409cb8e8e", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63", "patch": "@@ -1669,12 +1669,23 @@ For example @code{Foo::\\u0319::Bar} is encoded as\n \n @subsection Templates\n \n-A template instantiation is encoded as the letter @samp{t},\n+A class template instantiation is encoded as the letter @samp{t},\n followed by the encoding of the template name, followed\n the number of template parameters, followed by encoding of the template\n parameters.  If a template parameter is a type, it is written\n as a @samp{Z} followed by the encoding of the type.\n \n+A function template specialization (either an instantiation or an\n+explicit specialization) is encoded by an @samp{H} followed by the\n+encoding of the template parameters, as described above, followed by \n+an @samp{_}, the encoding of the argument types template function (not the\n+specialization), another @samp{_}, and the return type.  (Like the\n+argument types, the return type is the return type of the function\n+template, not the specialization.)  Template parameters in the argument\n+and return types are encoded by an @samp{X} for type parameters, or a\n+@samp{Y} for constant parameters, and an index indicating their position\n+in the template parameter list declaration.\n+\n @subsection Arrays\n \n C++ array types are mangled by emitting @samp{A}, followed by\n@@ -1720,6 +1731,9 @@ Encodes the C++ and Java @code{float} types.\n @item F\n Used to indicate a function type.\n \n+@item H\n+Used to indicate a template function.\n+\n @item i\n Encodes the C++ and Java @code{int} types.\n \n@@ -1775,6 +1789,12 @@ Encodes the C++ @code{wchar_t} type, and the Java @code{char} types.\n @item x\n Encodes the GNU C++ @code{long long} type, and the Java @code{long} type.\n \n+@item X\n+Encodes a template type parameter, when part of a function type.\n+\n+@item Y\n+Encodes a template constant parameter, when part of a function type.\n+\n @item Z\n Used for template type parameters. \n "}, {"sha": "83adadbbc2840005d44fe842ba31d498192f6b86", "filename": "gcc/cp/init.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63", "patch": "@@ -1681,7 +1681,7 @@ build_member_call (type, name, parmlist)\n      tree type, name, parmlist;\n {\n   tree t;\n-  tree method_name = name;\n+  tree method_name;\n   int dtor = 0;\n   int dont_use_this = 0;\n   tree basetype_path, decl;\n@@ -1690,6 +1690,11 @@ build_member_call (type, name, parmlist)\n     return build_x_function_call (do_scoped_id (name, 0), parmlist,\n \t\t\t\t  current_class_ref);\n \n+  if (TREE_CODE (name) != TEMPLATE_ID_EXPR)\n+    method_name = name;\n+  else\n+    method_name = TREE_OPERAND (name, 0);\n+\n   if (TREE_CODE (method_name) == BIT_NOT_EXPR)\n     {\n       method_name = TREE_OPERAND (method_name, 0);\n@@ -1758,7 +1763,10 @@ build_member_call (type, name, parmlist)\n       || method_name == constructor_name_full (type))\n     return build_functional_cast (type, parmlist);\n   if (t = lookup_fnfields (basetype_path, method_name, 0))\n-    return build_method_call (decl, method_name, parmlist, basetype_path,\n+    return build_method_call (decl, \n+\t\t\t      TREE_CODE (name) == TEMPLATE_ID_EXPR\n+\t\t\t      ? name : method_name,\n+\t\t\t      parmlist, basetype_path,\n \t\t\t      LOOKUP_NORMAL|LOOKUP_NONVIRTUAL);\n   if (TREE_CODE (name) == IDENTIFIER_NODE\n       && ((t = lookup_field (TYPE_BINFO (type), name, 1, 0))))"}, {"sha": "6679030ad34746063c6c4a221103de63a774e055", "filename": "gcc/cp/lang-options.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-options.h?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63", "patch": "@@ -48,6 +48,8 @@ Boston, MA 02111-1307, USA.  */\n   \"-fno-external-templates\",\n   \"-ffor-scope\",\n   \"-fno-for-scope\",\n+  \"-fguiding-decls\",\n+  \"-fno-guiding-decls\",\n   \"-fgnu-keywords\",\n   \"-fno-gnu-keywords\",\n   \"-fhandle-exceptions\",\n@@ -64,6 +66,7 @@ Boston, MA 02111-1307, USA.  */\n   \"-fno-labels-ok\",\n   \"-fmemoize-lookups\",\n   \"-fno-memoize-lookups\",\n+  \"-fname-mangling-version-\",\n   \"-fnonnull-objects\",\n   \"-fno-nonnull-objects\",\n   \"-foperator-names\","}, {"sha": "b60c09954eb159db07007268fd9437da10acb7e6", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63", "patch": "@@ -2729,6 +2729,15 @@ identifier_type (decl)\n     {\n       if (TREE_CODE (DECL_RESULT (decl)) == TYPE_DECL)\n \treturn PTYPENAME;\n+      else if (looking_for_template) \n+\treturn PFUNCNAME;\n+    }\n+  if (looking_for_template && really_overloaded_fn (decl))\n+    {\n+      tree t;\n+      for (t = TREE_VALUE (decl); t != NULL_TREE; t = DECL_CHAIN (t))\n+\tif (DECL_FUNCTION_TEMPLATE_P (t)) \n+\t  return PFUNCNAME;\n     }\n   if (TREE_CODE (decl) == NAMESPACE_DECL)\n     return NSNAME;"}, {"sha": "53417b2dbf07b9e1d41d3ba200231f7a3d2a9012", "filename": "gcc/cp/method.c", "status": "modified", "additions": 137, "deletions": 60, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63", "patch": "@@ -71,6 +71,10 @@ static char *thunk_printable_name PROTO((tree));\n static void do_build_assign_ref PROTO((tree));\n static void do_build_copy_constructor PROTO((tree));\n static tree largest_union_member PROTO((tree));\n+static tree build_decl_overload_real PROTO((tree, tree, tree, tree,\n+\t\t\t\t\t    tree, int)); \n+static void build_template_parm_names PROTO((tree, tree));\n+static void build_underscore_int PROTO((int));\n \n # define OB_INIT() (scratch_firstobj ? (obstack_free (&scratch_obstack, scratch_firstobj), 0) : 0)\n # define OB_PUTC(C) (obstack_1grow (&scratch_obstack, (C)))\n@@ -383,9 +387,16 @@ build_overload_nested_name (decl)\n   if (DECL_CONTEXT (decl))\n     {\n       tree context = DECL_CONTEXT (decl);\n-      if (TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n-\tcontext = TYPE_NAME (context);\n-      build_overload_nested_name (context);\n+      /* For a template type parameter, we want to output an 'Xn'\n+\t rather than 'T' or some such. */\n+      if (TREE_CODE (context) == TEMPLATE_TYPE_PARM)\n+\tbuild_overload_name (context, 0, 0);\n+      else\n+\t{\n+\t  if (TREE_CODE_CLASS (TREE_CODE (context)) == 't')\n+\t    context = TYPE_NAME (context);\n+\t  build_overload_nested_name (context);\n+\t}\n     }\n \n   if (TREE_CODE (decl) == FUNCTION_DECL)\n@@ -406,6 +417,16 @@ build_overload_nested_name (decl)\n     build_overload_identifier (decl);\n }\n \n+static void\n+build_underscore_int (int i)\n+{\n+  if (i > 9)\n+    OB_PUTC ('_');\n+  icat (i);\n+  if (i > 9)\n+    OB_PUTS ('_');\n+}\n+\n /* Encoding for an INTEGER_CST value.  */\n \n static void\n@@ -416,11 +437,8 @@ build_overload_int (value, in_template)\n   if (TREE_CODE (value) == TEMPLATE_CONST_PARM)\n     {\n       OB_PUTC ('Y');\n-      if (TEMPLATE_CONST_IDX (value) > 9)\n-\tOB_PUTC ('_');\n-      icat (TEMPLATE_CONST_IDX (value)); \n-      if (TEMPLATE_CONST_IDX (value) > 9)\n-\tOB_PUTC ('_');\n+      build_underscore_int (TEMPLATE_CONST_IDX (value));\n+      build_underscore_int (TEMPLATE_CONST_LEVEL (value));\n       return;\n     }\n   else if (in_template\n@@ -633,6 +651,41 @@ build_overload_value (type, value, in_template)\n     }\n }\n \n+\n+/* Add encodings for the vector of template parameters in PARMLIST,\n+   given the vector of arguments to be substituted in ARGLIST.  */\n+\n+void\n+build_template_parm_names (parmlist, arglist)\n+     tree parmlist;\n+     tree arglist;\n+{\n+  int i, nparms;\n+  \n+  nparms = TREE_VEC_LENGTH (parmlist);\n+  icat (nparms);\n+  for (i = 0; i < nparms; i++)\n+    {\n+      tree parm = TREE_VALUE (TREE_VEC_ELT (parmlist, i));\n+      tree arg = TREE_VEC_ELT (arglist, i);\n+      if (TREE_CODE (parm) == TYPE_DECL)\n+\t{\n+\t  /* This parameter is a type.  */\n+\t  OB_PUTC ('Z');\n+\t  build_overload_name (arg, 0, 0);\n+\t}\n+      else\n+\t{\n+\t  parm = tsubst (parm, arglist,\n+\t\t\t TREE_VEC_LENGTH (arglist), NULL_TREE);\n+\t  /* It's a PARM_DECL.  */\n+\t  build_overload_name (TREE_TYPE (parm), 0, 0);\n+\t  build_overload_value (parm, arg, uses_template_parms (arglist));\n+\t}\n+    }\n+ }\n+\n+\n static void\n build_overload_identifier (name)\n      tree name;\n@@ -643,36 +696,15 @@ build_overload_identifier (name)\n       && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (TREE_TYPE (name))))\n     {\n       tree template, parmlist, arglist, tname;\n-      int i, nparms;\n       template = CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (name));\n       arglist = TREE_VALUE (template);\n       template = TREE_PURPOSE (template);\n       tname = DECL_NAME (template);\n       parmlist = DECL_INNERMOST_TEMPLATE_PARMS (template);\n-      nparms = TREE_VEC_LENGTH (parmlist);\n       OB_PUTC ('t');\n       icat (IDENTIFIER_LENGTH (tname));\n       OB_PUTID (tname);\n-      icat (nparms);\n-      for (i = 0; i < nparms; i++)\n-\t{\n-\t  tree parm = TREE_VALUE (TREE_VEC_ELT (parmlist, i));\n-\t  tree arg = TREE_VEC_ELT (arglist, i);\n-\t  if (TREE_CODE (parm) == TYPE_DECL)\n-\t    {\n-\t      /* This parameter is a type.  */\n-\t      OB_PUTC ('Z');\n-\t      build_overload_name (arg, 0, 0);\n-\t    }\n-\t  else\n-\t    {\n-\t      parm = tsubst (parm, arglist,\n-\t\t\t     TREE_VEC_LENGTH (arglist), NULL_TREE);\n-\t      /* It's a PARM_DECL.  */\n-\t      build_overload_name (TREE_TYPE (parm), 0, 0);\n-\t      build_overload_value (parm, arg, uses_template_parms (arglist));\n-\t    }\n-\t}\n+      build_template_parm_names (parmlist, arglist);\n     }\n   else\n     {\n@@ -1012,22 +1044,18 @@ build_overload_name (parmtypes, begin, end)\n \n \tcase TEMPLATE_TYPE_PARM:\n \t  OB_PUTC ('X');\n-\t  if (TEMPLATE_TYPE_IDX (parmtype) > 9)\n-\t    OB_PUTC ('_');\n-\t  icat (TEMPLATE_TYPE_IDX (parmtype)); \n-\t  if (TEMPLATE_TYPE_IDX (parmtype) > 9)\n-\t    OB_PUTC ('_');\n+\t  build_underscore_int (TEMPLATE_TYPE_IDX (parmtype));\n+\t  build_underscore_int (TEMPLATE_TYPE_LEVEL (parmtype));\n \t  break;\n \t    \n \tcase TYPENAME_TYPE:\n-\t  /* We don't ever want this output, but it's inconvenient not to\n-\t     be able to build the string.  This should cause assembler\n-\t     errors we'll notice.  */\n-\t  {\n-\t    static int n;\n-\t    sprintf (digit_buffer, \" *%d\", n++);\n-\t    OB_PUTCP (digit_buffer);\n-\t  }\n+\t  /* When mangling the type of a function template whose\n+\t     declaration looks like:\n+\n+\t     template <class T> void foo(typename T::U)\n+\t     \n+\t     we have to mangle these.  */\n+\t  build_qualified_name (parmtype);\n \t  break;\n \n \tdefault:\n@@ -1075,19 +1103,14 @@ build_static_name (context, name)\n   return get_identifier ((char *)obstack_base (&scratch_obstack));\n }\n \f\n-/* Change the name of a function definition so that it may be\n-   overloaded. NAME is the name of the function to overload,\n-   PARMS is the parameter list (which determines what name the\n-   final function obtains).\n-\n-   FOR_METHOD is 1 if this overload is being performed\n-   for a method, rather than a function type.  It is 2 if\n-   this overload is being performed for a constructor.  */\n-\n-tree\n-build_decl_overload (dname, parms, for_method)\n+tree \n+build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n+\t\t\t  for_method) \n      tree dname;\n      tree parms;\n+     tree ret_type;\n+     tree tparms;\n+     tree targs;\n      int for_method;\n {\n   char *name = IDENTIFIER_POINTER (dname);\n@@ -1121,6 +1144,8 @@ build_decl_overload (dname, parms, for_method)\n       /* We can get away without doing this.  */\n       OB_PUTC ('M');\n #endif\n+      if (tparms != NULL_TREE)\n+\tOB_PUTC ('H');\n       {\n \ttree this_type = TREE_VALUE (parms);\n \n@@ -1133,12 +1158,18 @@ build_decl_overload (dname, parms, for_method)\n       }\n     }\n   else\n-    OB_PUTC ('F');\n+    OB_PUTC ((tparms != NULL_TREE) ? 'H' : 'F');\n+\n+  if (tparms)\n+    {\n+      build_template_parm_names (tparms, targs);\n+      OB_PUTC ('_');\n+    }\n \n   if (parms == NULL_TREE)\n-    OB_PUTC2 ('e', '\\0');\n+    OB_PUTC ('e');\n   else if (parms == void_list_node)\n-    OB_PUTC2 ('v', '\\0');\n+    OB_PUTC ('v');\n   else\n     {\n       ALLOCATE_TYPEVEC (parms);\n@@ -1151,14 +1182,23 @@ build_decl_overload (dname, parms, for_method)\n \t  TREE_USED (TREE_VALUE (parms)) = 1;\n \n \t  if (TREE_CHAIN (parms))\n-\t    build_overload_name (TREE_CHAIN (parms), 0, 1);\n+\t    build_overload_name (TREE_CHAIN (parms), 0, 0);\n \t  else\n-\t    OB_PUTC2 ('e', '\\0');\n+\t    OB_PUTC ('e');\n \t}\n       else\n-\tbuild_overload_name (parms, 0, 1);\n+\tbuild_overload_name (parms, 0, 0);\n       DEALLOCATE_TYPEVEC (parms);\n     }\n+\n+  if (ret_type != NULL_TREE)\n+    {\n+      /* Add the return type. */\n+      OB_PUTC ('_');\n+      build_overload_name (ret_type, 0, 0);\n+    }\n+\n+  OB_FINISH ();\n   {\n     tree n = get_identifier (obstack_base (&scratch_obstack));\n     if (IDENTIFIER_OPNAME_P (dname))\n@@ -1167,6 +1207,43 @@ build_decl_overload (dname, parms, for_method)\n   }\n }\n \n+/* Change the name of a function definition so that it may be\n+   overloaded. NAME is the name of the function to overload,\n+   PARMS is the parameter list (which determines what name the\n+   final function obtains).\n+\n+   FOR_METHOD is 1 if this overload is being performed\n+   for a method, rather than a function type.  It is 2 if\n+   this overload is being performed for a constructor.  */\n+\n+tree\n+build_decl_overload (dname, parms, for_method)\n+     tree dname;\n+     tree parms;\n+     int for_method;\n+{\n+  return build_decl_overload_real (dname, parms, NULL_TREE, NULL_TREE,\n+\t\t\t\t   NULL_TREE, for_method); \n+}\n+\n+\n+/* Like build_decl_overload, but for template functions. */\n+\n+tree\n+build_template_decl_overload (dname, parms, ret_type, tparms, targs,\n+\t\t\t      for_method) \n+     tree dname;\n+     tree parms;\n+     tree ret_type;\n+     tree tparms;\n+     tree targs;\n+     int for_method;\n+{\n+  return build_decl_overload_real (dname, parms, ret_type, tparms, targs,\n+\t\t\t\t   for_method); \n+}\n+\n+\n /* Build an overload name for the type expression TYPE.  */\n \n tree"}, {"sha": "1e8529d990cfc9b05c132d790c3e076ac94a06de", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 4458, "deletions": 4271, "changes": 8729, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63"}, {"sha": "f45eb6f8604cf1335f281df6fc8ea81cb6d305e5", "filename": "gcc/cp/parse.h", "status": "modified", "additions": 84, "deletions": 83, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.h?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63", "patch": "@@ -2,89 +2,90 @@ typedef union {long itype; tree ttype; char *strtype; enum tree_code code; flagg\n #define\tIDENTIFIER\t258\n #define\tTYPENAME\t259\n #define\tSELFNAME\t260\n-#define\tSCSPEC\t261\n-#define\tTYPESPEC\t262\n-#define\tCV_QUALIFIER\t263\n-#define\tCONSTANT\t264\n-#define\tSTRING\t265\n-#define\tELLIPSIS\t266\n-#define\tSIZEOF\t267\n-#define\tENUM\t268\n-#define\tIF\t269\n-#define\tELSE\t270\n-#define\tWHILE\t271\n-#define\tDO\t272\n-#define\tFOR\t273\n-#define\tSWITCH\t274\n-#define\tCASE\t275\n-#define\tDEFAULT\t276\n-#define\tBREAK\t277\n-#define\tCONTINUE\t278\n-#define\tRETURN\t279\n-#define\tGOTO\t280\n-#define\tASM_KEYWORD\t281\n-#define\tGCC_ASM_KEYWORD\t282\n-#define\tTYPEOF\t283\n-#define\tALIGNOF\t284\n-#define\tSIGOF\t285\n-#define\tATTRIBUTE\t286\n-#define\tEXTENSION\t287\n-#define\tLABEL\t288\n-#define\tREALPART\t289\n-#define\tIMAGPART\t290\n-#define\tAGGR\t291\n-#define\tVISSPEC\t292\n-#define\tDELETE\t293\n-#define\tNEW\t294\n-#define\tTHIS\t295\n-#define\tOPERATOR\t296\n-#define\tCXX_TRUE\t297\n-#define\tCXX_FALSE\t298\n-#define\tNAMESPACE\t299\n-#define\tTYPENAME_KEYWORD\t300\n-#define\tUSING\t301\n-#define\tLEFT_RIGHT\t302\n-#define\tTEMPLATE\t303\n-#define\tTYPEID\t304\n-#define\tDYNAMIC_CAST\t305\n-#define\tSTATIC_CAST\t306\n-#define\tREINTERPRET_CAST\t307\n-#define\tCONST_CAST\t308\n-#define\tSCOPE\t309\n-#define\tEMPTY\t310\n-#define\tPTYPENAME\t311\n-#define\tNSNAME\t312\n-#define\tTHROW\t313\n-#define\tASSIGN\t314\n-#define\tOROR\t315\n-#define\tANDAND\t316\n-#define\tMIN_MAX\t317\n-#define\tEQCOMPARE\t318\n-#define\tARITHCOMPARE\t319\n-#define\tLSHIFT\t320\n-#define\tRSHIFT\t321\n-#define\tPOINTSAT_STAR\t322\n-#define\tDOT_STAR\t323\n-#define\tUNARY\t324\n-#define\tPLUSPLUS\t325\n-#define\tMINUSMINUS\t326\n-#define\tHYPERUNARY\t327\n-#define\tPAREN_STAR_PAREN\t328\n-#define\tPOINTSAT\t329\n-#define\tTRY\t330\n-#define\tCATCH\t331\n-#define\tTYPENAME_ELLIPSIS\t332\n-#define\tPRE_PARSED_FUNCTION_DECL\t333\n-#define\tEXTERN_LANG_STRING\t334\n-#define\tALL\t335\n-#define\tPRE_PARSED_CLASS_DECL\t336\n-#define\tDEFARG\t337\n-#define\tDEFARG_MARKER\t338\n-#define\tTYPENAME_DEFN\t339\n-#define\tIDENTIFIER_DEFN\t340\n-#define\tPTYPENAME_DEFN\t341\n-#define\tEND_OF_LINE\t342\n-#define\tEND_OF_SAVED_INPUT\t343\n+#define\tPFUNCNAME\t261\n+#define\tSCSPEC\t262\n+#define\tTYPESPEC\t263\n+#define\tCV_QUALIFIER\t264\n+#define\tCONSTANT\t265\n+#define\tSTRING\t266\n+#define\tELLIPSIS\t267\n+#define\tSIZEOF\t268\n+#define\tENUM\t269\n+#define\tIF\t270\n+#define\tELSE\t271\n+#define\tWHILE\t272\n+#define\tDO\t273\n+#define\tFOR\t274\n+#define\tSWITCH\t275\n+#define\tCASE\t276\n+#define\tDEFAULT\t277\n+#define\tBREAK\t278\n+#define\tCONTINUE\t279\n+#define\tRETURN\t280\n+#define\tGOTO\t281\n+#define\tASM_KEYWORD\t282\n+#define\tGCC_ASM_KEYWORD\t283\n+#define\tTYPEOF\t284\n+#define\tALIGNOF\t285\n+#define\tSIGOF\t286\n+#define\tATTRIBUTE\t287\n+#define\tEXTENSION\t288\n+#define\tLABEL\t289\n+#define\tREALPART\t290\n+#define\tIMAGPART\t291\n+#define\tAGGR\t292\n+#define\tVISSPEC\t293\n+#define\tDELETE\t294\n+#define\tNEW\t295\n+#define\tTHIS\t296\n+#define\tOPERATOR\t297\n+#define\tCXX_TRUE\t298\n+#define\tCXX_FALSE\t299\n+#define\tNAMESPACE\t300\n+#define\tTYPENAME_KEYWORD\t301\n+#define\tUSING\t302\n+#define\tLEFT_RIGHT\t303\n+#define\tTEMPLATE\t304\n+#define\tTYPEID\t305\n+#define\tDYNAMIC_CAST\t306\n+#define\tSTATIC_CAST\t307\n+#define\tREINTERPRET_CAST\t308\n+#define\tCONST_CAST\t309\n+#define\tSCOPE\t310\n+#define\tEMPTY\t311\n+#define\tPTYPENAME\t312\n+#define\tNSNAME\t313\n+#define\tTHROW\t314\n+#define\tASSIGN\t315\n+#define\tOROR\t316\n+#define\tANDAND\t317\n+#define\tMIN_MAX\t318\n+#define\tEQCOMPARE\t319\n+#define\tARITHCOMPARE\t320\n+#define\tLSHIFT\t321\n+#define\tRSHIFT\t322\n+#define\tPOINTSAT_STAR\t323\n+#define\tDOT_STAR\t324\n+#define\tUNARY\t325\n+#define\tPLUSPLUS\t326\n+#define\tMINUSMINUS\t327\n+#define\tHYPERUNARY\t328\n+#define\tPAREN_STAR_PAREN\t329\n+#define\tPOINTSAT\t330\n+#define\tTRY\t331\n+#define\tCATCH\t332\n+#define\tTYPENAME_ELLIPSIS\t333\n+#define\tPRE_PARSED_FUNCTION_DECL\t334\n+#define\tEXTERN_LANG_STRING\t335\n+#define\tALL\t336\n+#define\tPRE_PARSED_CLASS_DECL\t337\n+#define\tDEFARG\t338\n+#define\tDEFARG_MARKER\t339\n+#define\tTYPENAME_DEFN\t340\n+#define\tIDENTIFIER_DEFN\t341\n+#define\tPTYPENAME_DEFN\t342\n+#define\tEND_OF_LINE\t343\n+#define\tEND_OF_SAVED_INPUT\t344\n \n \n extern YYSTYPE yylval;"}, {"sha": "97c5be780113305762b9a2f5c265bb5a62ef1422", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 100, "deletions": 12, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63", "patch": "@@ -110,6 +110,9 @@ empty_parms ()\n %token TYPENAME\n %token SELFNAME\n \n+/* A template function.  */\n+%token <ttype> PFUNCNAME\n+\n /* Reserved words that specify storage class.\n    yylval contains an IDENTIFIER_NODE which indicates which one.  */\n %token SCSPEC\n@@ -162,7 +165,7 @@ empty_parms ()\n %nonassoc IF\n %nonassoc ELSE\n \n-%left IDENTIFIER TYPENAME SELFNAME PTYPENAME SCSPEC TYPESPEC CV_QUALIFIER ENUM AGGR ELLIPSIS TYPEOF SIGOF OPERATOR NSNAME TYPENAME_KEYWORD\n+%left IDENTIFIER PFUNCNAME TYPENAME SELFNAME PTYPENAME SCSPEC TYPESPEC CV_QUALIFIER ENUM AGGR ELLIPSIS TYPEOF SIGOF OPERATOR NSNAME TYPENAME_KEYWORD\n \n %left '{' ',' ';'\n \n@@ -193,6 +196,7 @@ empty_parms ()\n %type <code> unop\n \n %type <ttype> identifier IDENTIFIER TYPENAME CONSTANT expr nonnull_exprlist\n+%type <ttype> PFUNCNAME\n %type <ttype> paren_expr_or_null nontrivial_exprlist SELFNAME\n %type <ttype> expr_no_commas cast_expr unary_expr primary string STRING\n %type <ttype> reserved_declspecs boolean.literal\n@@ -224,6 +228,7 @@ empty_parms ()\n %type <ttype> fcast_or_absdcl regcast_or_absdcl\n %type <ttype> expr_or_declarator complex_notype_declarator\n %type <ttype> notype_unqualified_id unqualified_id qualified_id\n+%type <ttype> template_id object_template_id notype_template_declarator\n %type <ttype> overqualified_id notype_qualified_id any_id\n %type <ttype> complex_direct_notype_declarator functional_cast\n %type <ttype> complex_parmlist parms_comma\n@@ -431,7 +436,8 @@ template_header:\n \t  template_parm_list '>'\n \t\t{ $$ = end_template_parm_list ($4); }\n \t| TEMPLATE '<' '>'\n-\t\t{ $$ = NULL_TREE; }\n+                { begin_specialization(); \n+\t\t  $$ = NULL_TREE; }\n \t;\n \n template_parm_list:\n@@ -483,10 +489,20 @@ template_parm:\n template_def:\n \t  template_header\n \t  extdef\n-\t\t{ end_template_decl (); }\n+                { \n+                  if ($1) \n+                    end_template_decl (); \n+\t\t  else\n+\t\t    end_specialization ();\n+\t\t}\n \t| template_header\n \t  error  %prec EMPTY\n-\t\t{ end_template_decl (); }\n+\t\t{ \n+                  if ($1) \n+                    end_template_decl ();\n+\t\t  else\n+\t\t    end_specialization (); \n+                }\n \t;\n \n datadef:\n@@ -701,8 +717,13 @@ fn.def2:\n \t\t{ $$ = start_method (NULL_TREE, $$); goto rest_of_mdef; }\n         | template_header fn.def2 \n                 { \n-\t\t  end_template_decl (); \n-\t\t  if ($2 && DECL_TEMPLATE_INFO ($2))\n+                  if ($1)\n+                    end_template_decl (); \n+\t\t  else\n+\t\t    end_specialization ();\n+\n+\t\t  if ($2 && DECL_TEMPLATE_INFO ($2)\n+\t\t      && !DECL_TEMPLATE_SPECIALIZATION ($2))\n \t\t    {\n \t\t      $$ = DECL_TI_TEMPLATE ($2); \n \t\t      check_member_template ($$);\n@@ -1263,12 +1284,35 @@ expr_no_commas:\n notype_unqualified_id:\n \t  '~' see_typename identifier\n \t\t{ $$ = build_parse_node (BIT_NOT_EXPR, $3); }\n+        | template_id\n \t| operator_name\n \t| IDENTIFIER\n \t| PTYPENAME\n \t| NSNAME  %prec EMPTY\n \t;\n \n+template_id:\n+        PFUNCNAME '<' template_arg_list template_close_bracket \n+                { $$ = lookup_template_function ($1, $3); }\n+        | PFUNCNAME '<' template_close_bracket\n+                { $$ = lookup_template_function ($1, NULL_TREE); }\n+        | operator_name '<' template_arg_list template_close_bracket\n+                { $$ = lookup_template_function \n+\t\t    (do_identifier ($1, 1), $3); }\n+        | operator_name '<' template_close_bracket\n+                { $$ = lookup_template_function \n+\t\t    (do_identifier ($1, 1), NULL_TREE); }\n+\t;\n+\n+object_template_id:\n+        TEMPLATE identifier '<' template_arg_list template_close_bracket\n+                { $$ = lookup_template_function ($2, $4); }\n+        | TEMPLATE PFUNCNAME '<' template_arg_list template_close_bracket\n+                { $$ = lookup_template_function (DECL_NAME ($2), $4); }\n+        | TEMPLATE operator_name '<' template_arg_list template_close_bracket\n+                { $$ = lookup_template_function (DECL_NAME ($2), $4); }\n+        ;\n+\n unqualified_id:\n \t  notype_unqualified_id\n \t| TYPENAME\n@@ -1285,9 +1329,17 @@ expr_or_declarator:\n \t\t{ $$ = $2; }\n \t;\n \n+notype_template_declarator:\n+\t  IDENTIFIER '<' template_arg_list template_close_bracket\n+                { $$ = lookup_template_function ($1, $3); }\n+\t| NSNAME '<' template_arg_list template_close_bracket\n+                { $$ = lookup_template_function ($1, $3); }\n+\t;\n+\t\t\n direct_notype_declarator:\n \t  complex_direct_notype_declarator\n \t| notype_unqualified_id\n+\t| notype_template_declarator\n \t| '(' expr_or_declarator ')'\n \t\t{ $$ = finish_decl_parsing ($2); }\n \t;\n@@ -1297,7 +1349,7 @@ primary:\n \t\t{\n \t\t  if (TREE_CODE ($$) == BIT_NOT_EXPR)\n \t\t    $$ = build_x_unary_op (BIT_NOT_EXPR, TREE_OPERAND ($$, 0));\n-\t\t  else\n+\t\t  else if (TREE_CODE ($$) != TEMPLATE_ID_EXPR)\n \t\t    $$ = do_identifier ($$, 1);\n \t\t}\t\t\n \t| CONSTANT\n@@ -1500,6 +1552,20 @@ primary:\n \t\t\t\t       NULL_TREE, NULL_TREE);\n \t\t  else\n \t\t    $$ = build_member_call (OP0 ($$), OP1 ($$), NULL_TREE); }\n+        | object object_template_id %prec UNARY\n+                { \n+\t\t  $$ = build_x_component_ref ($$, $2, NULL_TREE, 1); \n+\t\t}\n+        | object object_template_id '(' nonnull_exprlist ')'\n+                {\n+\t\t  $$ = build_method_call ($1, $2, $4, \n+\t\t\t\t\t  NULL_TREE, LOOKUP_NORMAL); \n+                }\n+\t| object object_template_id LEFT_RIGHT\n+                {\n+\t\t  $$ = build_method_call ($1, $2, NULL_TREE,\n+\t\t\t\t\t  NULL_TREE, LOOKUP_NORMAL); \n+                }\n \t| object unqualified_id  %prec UNARY\n \t\t{ $$ = build_x_component_ref ($$, $2, NULL_TREE, 1); }\n \t| object overqualified_id  %prec UNARY\n@@ -2191,7 +2257,9 @@ structsp:\n \t\t{ $$.t = $2;\n \t\t  $$.new_type_flag = 0; }\n \t/* C++ extensions, merged with C to avoid shift/reduce conflicts */\n-\t| class_head left_curly opt.component_decl_list '}' maybe_attribute\n+\t| class_head left_curly \n+                { reset_specialization(); }\n+          opt.component_decl_list '}' maybe_attribute\n \t\t{\n \t\t  int semi;\n \t\t  tree id;\n@@ -2214,7 +2282,7 @@ structsp:\n \t\t    ;\n \t\t  else\n \t\t    {\n-\t\t      $<ttype>$ = finish_struct ($1, $3, $5, semi);\n+\t\t      $<ttype>$ = finish_struct ($1, $4, $6, semi);\n \t\t      if (semi) note_got_semicolon ($<ttype>$);\n \t\t    }\n \n@@ -2233,7 +2301,7 @@ structsp:\n \t\t}\n \t  pending_inlines\n \t\t{ \n-\t\t  $$.t = $<ttype>6;\n+\t\t  $$.t = $<ttype>7;\n \t\t  $$.new_type_flag = 1; \n \t\t  if (current_class_type == NULL_TREE)\n \t\t    clear_inline_text_obstack (); \n@@ -2721,8 +2789,13 @@ component_decl_1:\n \t\t{ $$ = do_class_using_decl ($1); }\n         | template_header component_decl_1 \n                 { \n-\t\t  end_template_decl (); \n-\t\t  if ($2 && DECL_TEMPLATE_INFO ($2))\n+                  if ($1)\n+\t\t    end_template_decl (); \n+                  else\n+                    end_specialization ();\n+\n+\t\t  if ($2 && DECL_TEMPLATE_INFO ($2)\n+\t\t      && !DECL_TEMPLATE_SPECIALIZATION ($2))\n \t\t    {\n \t\t      $$ = DECL_TI_TEMPLATE ($2); \n \t\t      check_member_template ($$);\n@@ -3047,18 +3120,33 @@ complex_direct_notype_declarator:\n \t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n \t\t    }\n \t\t}\n+        | nested_name_specifier notype_template_declarator\n+                { got_scope = NULL_TREE;\n+\t\t  $$ = build_parse_node (SCOPE_REF, $1, $2);\n+\t\t  if ($1 != current_class_type)\n+\t\t    {\n+\t\t      push_nested_class ($1, 3);\n+\t\t      TREE_COMPLEXITY ($$) = current_class_depth;\n+\t\t    }\n+\t\t}\n \t;\n \n qualified_id:\n \t  nested_name_specifier unqualified_id\n \t\t{ got_scope = NULL_TREE;\n \t\t  $$ = build_parse_node (SCOPE_REF, $$, $2); }\n+        | nested_name_specifier object_template_id\n+                { got_scope = NULL_TREE;\n+ \t\t  $$ = build_parse_node (SCOPE_REF, $1, $2); }\n \t;\n \n notype_qualified_id:\n \t  nested_name_specifier notype_unqualified_id\n \t\t{ got_scope = NULL_TREE;\n \t\t  $$ = build_parse_node (SCOPE_REF, $$, $2); }\n+        | nested_name_specifier object_template_id\n+                { got_scope = NULL_TREE;\n+\t\t  $$ = build_parse_node (SCOPE_REF, $1, $2); }\n \t;\n \n overqualified_id:"}, {"sha": "7ac69c29d078bc60eb37d24befdcf53b198aee50", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 618, "deletions": 38, "changes": 656, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63", "patch": "@@ -63,6 +63,9 @@ static tree *maybe_template_tail = &maybe_templates;\n \n int minimal_parse_mode;\n \n+static int processing_specialization;\n+static int template_header_count;\n+\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n@@ -78,6 +81,10 @@ static tree get_class_bindings PROTO((tree, tree, tree));\n static tree coerce_template_parms PROTO((tree, tree, tree));\n static tree tsubst_enum\tPROTO((tree, tree, int, tree *));\n static tree add_to_template_args PROTO((tree, tree));\n+static int  type_unification_real PROTO((tree, tree *, tree, tree, int*,\n+\t\t\t\t\t int, int, int));\n+static int processing_explicit_specialization PROTO((int));\n+static void note_template_header PROTO((int));\n \n /* Restore the template parameter context. */\n \n@@ -150,9 +157,10 @@ is_member_template (t)\n        certainly not a member template.  */\n     return 0;\n \n-  if (DECL_FUNCTION_MEMBER_P (t) ||\n-      (TREE_CODE (t) == TEMPLATE_DECL && \n-       DECL_FUNCTION_MEMBER_P (DECL_TEMPLATE_RESULT (t))))\n+  if ((DECL_FUNCTION_MEMBER_P (t) \n+       && !DECL_TEMPLATE_SPECIALIZATION (t))\n+      || (TREE_CODE (t) == TEMPLATE_DECL && \n+\t  DECL_FUNCTION_MEMBER_P (DECL_TEMPLATE_RESULT (t))))\n     {\n       tree tmpl = NULL_TREE;\n \n@@ -246,8 +254,391 @@ begin_template_parm_list ()\n   pushlevel (0);\n   declare_pseudo_global_level ();\n   ++processing_template_decl;\n+  note_template_header (0);\n+}\n+\n+\n+/* We've just seen template <>. */\n+\n+void\n+begin_specialization ()\n+{\n+  note_template_header (1);\n+}\n+\n+\n+/* Called at then end of processing a declaration preceeded by\n+   template<>.  */\n+\n+void \n+end_specialization ()\n+{\n+  reset_specialization ();\n+}\n+\n+\n+/* Any template <>'s that we have seen thus far are not referring to a\n+   function specialization. */\n+\n+void\n+reset_specialization ()\n+{\n+  processing_specialization = 0;\n+  template_header_count = 0;\n+}\n+\n+\n+/* We've just seen a template header.  If SPECIALIZATION is non-zero,\n+   it was of the form template <>.  */\n+\n+void \n+note_template_header (specialization)\n+     int specialization;\n+{\n+  processing_specialization = specialization;\n+  template_header_count++;\n+}\n+\n+\n+/* Returns non-zero iff a declarator, in which the number of template\n+   types that appeared was TEMPLATE_COUNT, is an explicit\n+   specialization.  */\n+\n+int\n+processing_explicit_specialization(template_count)\n+     int template_count;\n+{\n+  /* A function declaration is an explicit specialization of a member\n+     template if all of the following conditions hold:\n+     \n+     o There was a template <...> preceeding the declaration.\n+     o The last template <...> was in fact template <>.\n+     o The number of template <...>'s preceeding the declaration, less\n+       the number of template classes with arguments specified used to\n+       qualify the function name, is 1.\n+\n+     For example:\n+\n+     template <> void S<int>::foo(); \n+     template <class T> template <> void S<T>::foo();\n+     template <> struct S<int> { ... template <> void foo(); }\n+\n+     The first of these is not a specialization of S<int>::foo() (it\n+     is instead a specialization of S<T>::foo), while the next two are\n+     specializations of member template functions.  */\n+\n+  return processing_specialization \n+    && template_header_count > template_count; \n+}\n+\n+/* Returns the template function specialized by TEMPLATE_ID, or\n+   NULL_TREE if there is none.\n+\n+   The TEMPLATE_ID is a TEMPLATE_ID_EXPR.  The TYPE is\n+   the type it has been declared to have.  Return the TEMPLATE_DECL\n+   that is being specialized, and put the specialization arguments in\n+   *TARGS.  If no appropriate specialization can be found, NULL_TREE is\n+   returned, and *TARGS is assigned NULL_TREE.  If complain is\n+   non-zero, error messages are printed where appropriate.  */\n+   \n+tree\n+determine_explicit_specialization (template_id, type, targs_out,\n+\t\t\t\t   need_member_template,\n+\t\t\t\t   complain)\n+     tree template_id;\n+     tree type;\n+     tree* targs_out;\n+     int need_member_template;\n+     int complain;\n+{\n+  int i;\n+  int overloaded;\n+  tree fns;\n+  tree matching_fns = NULL_TREE;\n+  tree name = NULL_TREE;\n+  tree result;\n+  tree fn;\n+\n+  my_friendly_assert (TREE_CODE (template_id) == TEMPLATE_ID_EXPR,\n+\t\t      0); \n+\t\t      \n+  fns = TREE_OPERAND (template_id, 0);\n+\n+  overloaded = fns != NULL_TREE && really_overloaded_fn (fns);\n+\n+  for (fn = (fns != NULL_TREE) ? get_first_fn (fns) : NULL_TREE; \n+       fn != NULL_TREE; \n+       fn = overloaded ? DECL_CHAIN (fn) : NULL_TREE)\n+    {\n+      int dummy;\n+      tree targs;\n+\n+      if (name == NULL_TREE)\n+\tname = DECL_NAME (fn);\n+\n+      if (TREE_CODE (fn) != TEMPLATE_DECL\n+\t  || (need_member_template && !is_member_template (fn)))\n+\tcontinue;\n+\n+      if (list_length (TREE_OPERAND (template_id, 1)) > DECL_NTPARMS (fn))\n+\tcontinue;\n+\n+      targs = make_tree_vec (DECL_NTPARMS (fn));\n+\n+      /* We allow incomplete unification here, because we are going to\n+\t check all the functions. */\n+      i = type_unification (DECL_INNERMOST_TEMPLATE_PARMS (fn),\n+\t\t\t    &TREE_VEC_ELT (targs, 0),\n+\t\t\t    type \n+\t\t\t    ? TYPE_ARG_TYPES (TREE_TYPE (fn)) : NULL_TREE, \n+\t\t\t    type ? TYPE_ARG_TYPES (type) : NULL_TREE,\n+\t\t\t    TREE_OPERAND (template_id, 1),\n+\t\t\t    &dummy, 1, 1);\n+      \n+      if (i == 0) \n+\t{\n+\t  /* Unification was successful.  See if the return types\n+\t     match. */\n+\t  if (type != NULL_TREE)\n+\t    {\n+\t      tree tmpl_return_type = tsubst (TREE_TYPE (TREE_TYPE (fn)),\n+\t\t\t\t\t      targs,\n+\t\t\t\t\t      DECL_NTPARMS (fn),\n+\t\t\t\t\t      NULL_TREE);\n+\t      \n+\t      if (tmpl_return_type != TREE_TYPE (type))\n+\t\t{\n+\t\t  /* Always complain about this.  With ambiguity, some\n+\t\t     other context, might resolve things.  But, a\n+\t\t     non-matching return type will always be a\n+\t\t     problem.  */\n+\t\t  cp_error (\"Return type of explicit specialization of\");\n+\t\t  cp_error (\"`%D' is `%T', but should be `%T'.\", \n+\t\t\t    fn, TREE_TYPE (type), tmpl_return_type);\n+\t\t  *targs_out = NULL_TREE;\n+\t\t  return NULL_TREE;\n+\t\t}\n+\t    }\n+\n+\t  matching_fns = tree_cons (fn, targs, matching_fns);\n+\t}\n+    }\n+\n+  if (matching_fns == NULL_TREE)\n+    {\n+      if (complain)\n+\tcp_error (\"Specialization of `%s' does not match any template \"\n+\t\t  \"declaration.\", IDENTIFIER_POINTER (name));\n+      *targs_out = NULL_TREE;\n+      return NULL_TREE;\n+    }\n+\n+  if (TREE_CHAIN (matching_fns) != NULL_TREE) \n+    {\n+      if (complain)\n+\t{\n+\t  tree fn;\n+\t  \n+\t  cp_error (\"Ambiguous explicit specialization.  Candidates are:\");\n+\t  for (fn = matching_fns; fn != NULL_TREE; fn = TREE_CHAIN (fn))\n+\t    cp_error (\"    %D\", TREE_PURPOSE (fn));\n+\t}\n+\n+      *targs_out = NULL_TREE;\n+      return NULL_TREE;\n+    }\n+\n+  /* We have one, and exactly one, match. */\n+  *targs_out = TREE_VALUE (matching_fns);\n+  return TREE_PURPOSE (matching_fns);\n }\n \n+\t\n+/* Check to see if the function just declared, as indicated in\n+   DECLARATOR, and in DECL, is a specialization.  Check that the\n+   specialization is OK.  If FLAGS == 1, we are being called by\n+   finish_struct_methods.  If FLAGS == 2, we are being called by\n+   grokfndecl, and the function has a definition, or is a friend.  If\n+   FLAGS == 3, this is a friend declaration.\n+   Returns 0 if the decl is not an explicit specialization or\n+   instantiation, 1 if it is an explicit specialization, and 2 if it\n+   is an explicit instantiation.  */\n+\n+int\n+check_explicit_specialization(declarator, decl, template_count,\n+\t\t\t      flags)\n+     tree declarator;\n+     tree decl;\n+     int template_count;\n+     int flags;\n+{\n+  int finish_member = flags == 1;\n+  int have_def = flags == 2;\n+  int is_friend = flags == 3;\n+\n+  if (processing_explicit_specialization (template_count)\n+      || finish_member\n+      || TREE_CODE (declarator) == TEMPLATE_ID_EXPR)\n+    {\n+      tree tmpl = NULL_TREE;\n+      tree dname = DECL_NAME (decl);\n+      tree ctype = DECL_CLASS_CONTEXT (decl);\n+      tree targs;\n+\n+      /* We've come across a declarator that looks like: U f<T1,\n+\t T2, ...>(A1, A2, ..).  This is an explicit template\n+\t specialization.  Check that: \n+\t       \n+\t o The explicitly specified parameters together with those\n+\t that can be deduced by template argument deduction\n+\t uniquely determine a particular specialization.  \n+\t       \n+\t See [temp.expl.spec].  */\n+\n+      if (!finish_member\n+\t  && TREE_CODE (declarator) == TEMPLATE_ID_EXPR\n+\t  && !processing_explicit_specialization (template_count)\n+\t  && !is_friend)\n+\t{\n+\t  if (!have_def)\n+\t    /* This is not an explicit specialization.  It must be\n+\t       an explicit instantiation.  */\n+\t    return 2;\n+\t  else if (pedantic)\n+\t    pedwarn (\"Explicit specialization not preceeded by \"\n+\t\t     \"`template <>'\");\n+\t}\n+\n+      if (TREE_CODE (declarator) != TEMPLATE_ID_EXPR)\n+\t{\n+\t  tree fns;\n+\n+\t  my_friendly_assert (TREE_CODE (declarator) == IDENTIFIER_NODE, \n+\t\t\t      0);\n+\t  if (!ctype)\n+\t    fns = IDENTIFIER_GLOBAL_VALUE (dname);\n+\t  else\n+\t    fns = dname;\n+\n+\t  declarator = lookup_template_function (fns, NULL_TREE);\n+\t}\n+\n+      if (TREE_CODE (TREE_OPERAND (declarator, 0)) == LOOKUP_EXPR) \n+\t{\n+\t  /* A friend declaration.  We can't do much, because we don't\n+\t   know what this resolves to, yet.  */\n+\t  my_friendly_assert (is_friend != 0, 0);\n+\t  SET_DECL_IMPLICIT_INSTANTIATION (decl);\n+\t  return 1;\n+\t} \n+\n+      if (ctype \n+\t  && TREE_CODE (TREE_OPERAND (declarator, 0)) == IDENTIFIER_NODE)\n+\t{\n+\t  tree fns;\n+ \n+\t  if (TYPE_BEING_DEFINED (ctype) && !finish_member)\n+\t    {\n+\t      /* Since finish_struct_1 has not been called yet, we\n+\t\t can't call lookup_fnfields.  We note that this\n+\t\t template is a specialization, and proceed, letting\n+\t\t finish_struct_methods fix this up later.  */\n+\t      SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n+\t      DECL_TEMPLATE_INFO (decl) \n+\t\t= perm_tree_cons (NULL_TREE, \n+\t\t\t\t  TREE_OPERAND (declarator, 1),\n+\t\t\t\t  NULL_TREE);\n+\t      return 1;\n+\t    }\n+\n+\t  fns = lookup_fnfields (TYPE_BINFO (ctype), \n+\t\t\t\t TREE_OPERAND (declarator, 0),\n+\t\t\t\t 1);\n+\t  \n+\t  if (fns == NULL_TREE) \n+\t    {\n+\t      cp_error (\"No member template `%s' declared in `%T'\",\n+\t\t\tIDENTIFIER_POINTER (TREE_OPERAND (declarator,\n+\t\t\t\t\t\t\t  0)),\n+\t\t\tctype);\n+\t      return 1;\n+\t    }\n+\t  else\n+\t    TREE_OPERAND (declarator, 0) = fns;\n+\t}\n+\n+      tmpl = \n+\tdetermine_explicit_specialization \n+\t(declarator, TREE_TYPE (decl), &targs, \n+\t TREE_CODE (decl) == TEMPLATE_DECL, 1);\n+\t    \n+      if (tmpl)\n+\t{\n+\t  /* Mangle the function name appropriately.  */\n+\t  if (name_mangling_version >= 1)\n+\t    {\n+\t      tree arg_types = TYPE_ARG_TYPES (TREE_TYPE (tmpl));\n+\n+\t      if (ctype \n+\t\t  && TREE_CODE (TREE_TYPE (tmpl)) == FUNCTION_TYPE)\n+\t\targ_types = \n+\t\t  hash_tree_chain (build_pointer_type (ctype),\n+\t\t\t\t   arg_types);\n+\n+\t      DECL_ASSEMBLER_NAME (decl) \n+\t\t= build_template_decl_overload \n+\t\t(DECL_NAME (decl), \n+\t\t arg_types,\n+\t\t TREE_TYPE (TREE_TYPE (tmpl)),\n+\t\t DECL_INNERMOST_TEMPLATE_PARMS (tmpl),\n+\t\t targs, ctype != NULL_TREE);\n+\t    }\n+\n+\t  if (is_friend && !have_def)\n+\t    {\n+\t      /* This is not really a declaration of a specialization.\n+\t\t It's just the name of an instantiation.  But, it's not\n+\t\t a request for an instantiation, either.  */\n+\t      SET_DECL_IMPLICIT_INSTANTIATION (decl);\n+\t      DECL_TEMPLATE_INFO (decl) \n+\t\t= perm_tree_cons (tmpl, targs, NULL_TREE);\n+\t      return 1;\n+\t    }\n+\n+\t  /* This function declaration is a template specialization.\n+\t     Record that fact.  */\n+\t  SET_DECL_TEMPLATE_SPECIALIZATION (decl);\n+\t  DECL_TEMPLATE_SPECIALIZATIONS (tmpl) \n+\t    = perm_tree_cons (targs, decl, \n+\t\t\t      DECL_TEMPLATE_SPECIALIZATIONS\n+\t\t\t      (tmpl));\n+\t  /* If DECL_TI_TEMPLATE (decl), the decl is an\n+\t     instantiation of a specialization of a member template.\n+\t     (In other words, there was a member template, in a\n+\t     class template.  That member template was specialized.\n+\t     We then instantiated the class, so there is now an\n+\t     instance of that specialization.)  \n+\n+\t     According to the CD2,\n+\n+\t     14.7.3.13 [tmpl.expl.spec]\n+\t       \n+\t     A specialization  of  a member function template or\n+\t     member class template of a non-specialized class\n+\t     template is itself a template.\t        \n+\n+\t     So, we just leave the template info alone in this case.\n+\t     */\n+\t  if (!(DECL_TEMPLATE_INFO (decl) && DECL_TI_TEMPLATE (decl)))\n+\t    DECL_TEMPLATE_INFO (decl)\n+\t      = perm_tree_cons (tmpl, targs, NULL_TREE);\n+\t  return 1;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\t\t\t   \n /* Process information from new template parameter NEXT and append it to the\n    LIST being built.  */\n \n@@ -358,6 +749,8 @@ end_template_parm_list (parms)\n void\n end_template_decl ()\n {\n+  reset_specialization ();\n+\n   if (! processing_template_decl)\n     return;\n \n@@ -465,6 +858,15 @@ push_template_decl (decl)\n \t  DECL_CLASS_CONTEXT (tmpl) = DECL_CLASS_CONTEXT (decl);\n \t  DECL_STATIC_FUNCTION_P (tmpl) = \n \t    DECL_STATIC_FUNCTION_P (decl);\n+\n+\t  if (DECL_TEMPLATE_SPECIALIZATION (decl))\n+\t    {\n+\t      /* A specialization of a member template of a template\n+\t\t class. */\n+\t      SET_DECL_TEMPLATE_SPECIALIZATION (tmpl);\n+\t      DECL_TEMPLATE_INFO (tmpl) = DECL_TEMPLATE_INFO (decl);\n+\t      DECL_TEMPLATE_INFO (decl) = NULL_TREE;\n+\t    }\n \t}\n     }\n   else\n@@ -749,6 +1151,9 @@ comp_template_args (oldargs, newargs)\n {\n   int i;\n \n+  if (TREE_VEC_LENGTH (oldargs) != TREE_VEC_LENGTH (newargs))\n+    return 0;\n+\n   for (i = 0; i < TREE_VEC_LENGTH (oldargs); ++i)\n     {\n       tree nt = TREE_VEC_ELT (newargs, i);\n@@ -895,6 +1300,35 @@ add_pending_template (d)\n   TI_PENDING_TEMPLATE_FLAG (ti) = 1;\n }\n \n+\n+/* Return a TEMPLATE_ID_EXPR corresponding to the indicated FNS (which\n+   may be either a _DECL or an overloaded function or an\n+   IDENTIFIER_NODE), and ARGLIST.  */\n+\n+tree\n+lookup_template_function (fns, arglist)\n+     tree fns, arglist;\n+{\n+  if (fns == NULL_TREE)\n+    {\n+      cp_error (\"non-template used as template\");\n+      return error_mark_node;\n+    }\n+\n+  if (arglist != NULL_TREE && !TREE_PERMANENT (arglist))\n+    {\n+      push_obstacks (&permanent_obstack, &permanent_obstack);\n+      arglist = copy_list (arglist);\n+      pop_obstacks ();\n+    }\n+\n+  return build_min (TEMPLATE_ID_EXPR,\n+\t\t    TREE_TYPE (fns) \n+\t\t    ? TREE_TYPE (fns) : unknown_type_node, \n+\t\t    fns, arglist);  \n+}\n+\n+\n /* Given an IDENTIFIER_NODE (type TEMPLATE_DECL) and a chain of\n    parameters, find the desired type.\n \n@@ -1028,7 +1462,7 @@ lookup_template_class (d1, arglist, in_decl)\n \n       /* We need to set this again after CLASSTYPE_TEMPLATE_INFO is set up.  */\n       DECL_ASSEMBLER_NAME (TYPE_MAIN_DECL (t)) = id;\n-      if (! uses_template_parms (arglist))\n+      /* if (! uses_template_parms (arglist)) */\n \tDECL_ASSEMBLER_NAME (TYPE_MAIN_DECL (t)) \n \t  = get_identifier (build_overload_name (t, 1, 1));\n \n@@ -1746,6 +2180,7 @@ tsubst (t, args, nargs, in_decl)\n \ttree decl = DECL_TEMPLATE_RESULT (t);\n \ttree new_decl;\n \ttree parms;\n+\ttree spec;\n \tint i;\n \n \t/* We might already have an instance of this template. */\n@@ -1788,13 +2223,15 @@ tsubst (t, args, nargs, in_decl)\n \tDECL_TEMPLATE_INSTANTIATIONS (t)\n \t  = perm_tree_cons (NULL_TREE, tmpl,\n \t\t\t    DECL_TEMPLATE_INSTANTIATIONS (t));\n+\n+\tDECL_TEMPLATE_SPECIALIZATIONS (tmpl) = NULL_TREE;\n \treturn tmpl;\n       }\n \n     case FUNCTION_DECL:\n       {\n \ttree r = NULL_TREE;\n-\ttree arg_types, ctx;\n+\ttree ctx;\n \n \tint member;\n \n@@ -1857,12 +2294,6 @@ tsubst (t, args, nargs, in_decl)\n \t    DECL_NAME (r) = build_typename_overload (TREE_TYPE (type));\n \t  }\n \n-\targ_types = TYPE_VALUES (type);\n-\n-\tif (member && TREE_CODE (type) == FUNCTION_TYPE)\n-\t  arg_types = hash_tree_chain\n-\t    (build_pointer_type (DECL_CONTEXT (r)), arg_types);\n-\n \tif (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (t)))\n \t  {\n \t    char *buf, *dbuf = build_overload_name (ctx, 1, 1);\n@@ -1874,9 +2305,72 @@ tsubst (t, args, nargs, in_decl)\n \t    strcat (buf, dbuf);\n \t    DECL_ASSEMBLER_NAME (r) = get_identifier (buf);\n \t  }\n-\telse\n-\t  DECL_ASSEMBLER_NAME (r)\n-\t    = build_decl_overload (DECL_NAME (r), arg_types, member);\n+\telse \n+\t  {\n+\t    /* Instantiations of template functions must be mangled\n+\t       specially, in order to conform to 14.5.5.1\n+\t       [temp.over.link].  We use in_decl below rather than\n+\t       DECL_TI_TEMPLATE (r) because the latter is set to\n+\t       NULL_TREE in instantiate_decl.  */\n+\t    tree tmpl;\n+\t    tree arg_types;\n+\n+\t    if (DECL_TEMPLATE_INFO (r))\n+\t      tmpl = DECL_TI_TEMPLATE (r);\n+\t    else\n+\t      tmpl = in_decl;\n+\n+\t    /* tmpl will be NULL if this is a specialization of a\n+\t       member template of a template class.  */\n+\t    if (name_mangling_version < 1\n+\t\t|| tmpl == NULL_TREE\n+\t\t|| (member && !is_member_template (tmpl)\n+\t\t    && !DECL_TEMPLATE_INFO (tmpl)))\n+\t      {\n+\t\targ_types = TYPE_ARG_TYPES (type);\n+\t\tif (member && TREE_CODE (type) == FUNCTION_TYPE)\n+\t\t  arg_types = hash_tree_chain \n+\t\t    (build_pointer_type (DECL_CONTEXT (r)),\n+\t\t     arg_types); \n+\t\t\n+\t\tDECL_ASSEMBLER_NAME (r) \n+\t\t  = build_decl_overload (DECL_NAME (r), arg_types,\n+\t\t\t\t\t member);\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* We pass the outermost template parameters to\n+\t\t   build_template_decl_overload since the innermost\n+\t\t   template parameters are still just template\n+\t\t   parameters; there are no corresponding subsitution\n+\t\t   arguments.  */\n+\t\ttree tparms = DECL_TEMPLATE_PARMS (tmpl);\n+\n+\t\twhile (tparms && TREE_CHAIN (tparms) != NULL_TREE)\n+\t\t  tparms = TREE_CHAIN (tparms);\n+\n+\t\tmy_friendly_assert (tparms != NULL_TREE\n+\t\t\t\t    && TREE_CODE (tparms) == TREE_LIST,\n+\t\t\t\t    0);\n+\t\ttparms = TREE_VALUE (tparms);\n+\n+\t\targ_types = TYPE_ARG_TYPES (TREE_TYPE (tmpl));\n+\t\tif (member && TREE_CODE (type) == FUNCTION_TYPE)\n+\t\t  arg_types = hash_tree_chain \n+\t\t    (build_pointer_type (DECL_CONTEXT (r)),\n+\t\t     arg_types); \n+\n+\t\tDECL_ASSEMBLER_NAME (r)\n+\t\t  = build_template_decl_overload \n+\t\t  (DECL_NAME (r), arg_types, \n+\t\t   TREE_TYPE (TREE_TYPE (tmpl)),\n+\t\t   tparms,\n+\t\t   TREE_CODE (TREE_VEC_ELT (args, 0)) == TREE_VEC \n+\t\t   ? TREE_VEC_ELT (args, TREE_VEC_LENGTH (args) - 1) :\n+\t\t   args, \n+\t\t   member);\n+\t      }\n+\t  }\n \tDECL_RTL (r) = 0;\n \tmake_decl_rtl (r, NULL_PTR, 1);\n \n@@ -2531,6 +3025,14 @@ tsubst_copy (t, args, nargs, in_decl)\n \treturn r;\n       }\n \n+    case TEMPLATE_ID_EXPR:\n+      {\n+\ttree r = lookup_template_function\n+\t  (tsubst_copy (TREE_OPERAND (t, 0), args, nargs, in_decl),\n+\t   tsubst_copy (TREE_OPERAND (t, 1), args, nargs, in_decl));\n+\treturn r;\n+      }\n+\n     case TREE_LIST:\n       {\n \ttree purpose, value, chain;\n@@ -2897,11 +3399,25 @@ instantiate_template (tmpl, targ_ptr)\n   struct obstack *old_fmp_obstack;\n   extern struct obstack *function_maybepermanent_obstack;\n \n+  my_friendly_assert (TREE_CODE (tmpl) == TEMPLATE_DECL, 283);\n+\n+  if (DECL_FUNCTION_TEMPLATE_P (tmpl))\n+    {\n+      tree specs;\n+      \n+      /* Check to see if there is a matching specialization. */\n+      for (specs = DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n+\t   specs != NULL_TREE;\n+\t   specs = TREE_CHAIN (specs))\n+\tif (comp_template_args (TREE_PURPOSE(specs),\n+\t\t\t\ttarg_ptr))\n+\t  return TREE_VALUE (specs);\n+    }\n+\n   push_obstacks (&permanent_obstack, &permanent_obstack);\n   old_fmp_obstack = function_maybepermanent_obstack;\n   function_maybepermanent_obstack = &permanent_obstack;\n \n-  my_friendly_assert (TREE_CODE (tmpl) == TEMPLATE_DECL, 283);\n   len = DECL_NTPARMS (tmpl);\n \n   i = len;\n@@ -2960,8 +3476,8 @@ overload_template_name (type)\n    operators.  */\n \n int\n-fn_type_unification (fn, targs, args, return_type, strict)\n-     tree fn, targs, args, return_type;\n+fn_type_unification (fn, explicit_targs, targs, args, return_type, strict)\n+     tree fn, explicit_targs, targs, args, return_type;\n      int strict;\n {\n   int i, dummy = 0;\n@@ -2986,7 +3502,8 @@ fn_type_unification (fn, targs, args, return_type, strict)\n \t\t\t&TREE_VEC_ELT (targs, 0), \n \t\t\tfn_arg_types,\n \t\t\tdecl_arg_types,\n-\t\t\t&dummy, 0, strict);\n+\t\t\texplicit_targs,\n+\t\t\t&dummy, strict, 0);\n \n   return i;\n }\n@@ -3016,25 +3533,54 @@ fn_type_unification (fn, targs, args, return_type, strict)\n    addresses, explicit instantiation, and more_specialized).  */\n \n int\n-type_unification (tparms, targs, parms, args, nsubsts, subr, strict)\n+type_unification (tparms, targs, parms, args, targs_in, nsubsts,\n+\t\t  strict, allow_incomplete)\n+     tree tparms, *targs, parms, args, targs_in;\n+     int *nsubsts, strict, allow_incomplete;\n+{\n+  int ntparms = TREE_VEC_LENGTH (tparms);\n+  tree t;\n+  int i;\n+  int r;\n+\n+  bzero ((char *) targs, sizeof (tree) * ntparms);\n+\n+  /* Insert any explicit template arguments.  They are encoded as the\n+     operands of NOP_EXPRs so that unify can tell that they are\n+     explicit arguments.  */\n+  for (i = 0, t = targs_in; t != NULL_TREE; t = TREE_CHAIN (t), ++i)\n+    targs[i] = build1 (NOP_EXPR, NULL_TREE, TREE_VALUE (t));\n+\n+  r = type_unification_real (tparms, targs, parms, args, nsubsts, 0,\n+\t\t\t     strict, allow_incomplete); \n+\n+  for (i = 0, t = targs_in; t != NULL_TREE; t = TREE_CHAIN (t), ++i)\n+    if (TREE_CODE (targs[i]) == NOP_EXPR)\n+      targs[i] = TREE_OPERAND (targs[i], 0);\n+\n+  return r;\n+}\n+\n+\n+int\n+type_unification_real (tparms, targs, parms, args, nsubsts, subr,\n+\t\t       strict, allow_incomplete)\n      tree tparms, *targs, parms, args;\n-     int *nsubsts, subr, strict;\n+     int *nsubsts, subr, strict, allow_incomplete;\n {\n   tree parm, arg;\n   int i;\n   int ntparms = TREE_VEC_LENGTH (tparms);\n \n   my_friendly_assert (TREE_CODE (tparms) == TREE_VEC, 289);\n-  my_friendly_assert (TREE_CODE (parms) == TREE_LIST, 290);\n+  my_friendly_assert (parms == NULL_TREE \n+\t\t      || TREE_CODE (parms) == TREE_LIST, 290);\n   /* ARGS could be NULL (via a call from parse.y to\n      build_x_function_call).  */\n   if (args)\n     my_friendly_assert (TREE_CODE (args) == TREE_LIST, 291);\n   my_friendly_assert (ntparms > 0, 292);\n \n-  if (!subr)\n-    bzero ((char *) targs, sizeof (tree) * ntparms);\n-\n   while (parms\n \t && parms != void_list_node\n \t && args\n@@ -3107,10 +3653,12 @@ type_unification (tparms, targs, parms, args, nsubsts, subr, strict)\n \t      ntparms = DECL_NTPARMS (arg);\n \t      targs = (tree *) alloca (sizeof (tree) * ntparms);\n \t      parm = tree_cons (NULL_TREE, parm, NULL_TREE);\n-\t      return type_unification (DECL_INNERMOST_TEMPLATE_PARMS (arg), \n-\t\t\t\t       targs,\n-\t\t\t\t       TYPE_ARG_TYPES (TREE_TYPE (arg)),\n-\t\t\t\t       parm, &nsubsts, 0, strict);\n+\t      return \n+\t\ttype_unification (DECL_INNERMOST_TEMPLATE_PARMS (arg), \n+\t\t\t\t  targs,\n+\t\t\t\t  TYPE_ARG_TYPES (TREE_TYPE (arg)),\n+\t\t\t\t  parm, NULL_TREE, &nsubsts, strict,\n+\t\t\t\t  allow_incomplete); \n \t    }\n \t  arg = TREE_TYPE (arg);\n \t}\n@@ -3150,7 +3698,8 @@ type_unification (tparms, targs, parms, args, nsubsts, subr, strict)\n     for (i = 0; i < ntparms; i++)\n       if (!targs[i])\n \t{\n-\t  error (\"incomplete type unification\");\n+\t  if (!allow_incomplete)\n+\t    error (\"incomplete type unification\");\n \t  return 2;\n \t}\n   return 0;\n@@ -3190,6 +3739,17 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n     case TEMPLATE_TYPE_PARM:\n       (*nsubsts)++;\n       idx = TEMPLATE_TYPE_IDX (parm);\n+      /* Check for mixed types and values.  */\n+      if (TREE_CODE (TREE_VALUE (TREE_VEC_ELT (tparms, idx))) != TYPE_DECL)\n+\treturn 1;\n+\n+      if (!strict && targs[idx] != NULL_TREE && \n+\t  TREE_CODE (targs[idx]) == NOP_EXPR)\n+\t/* An explicit template argument.  Don't even try to match\n+\t   here; the overload resolution code will manage check to\n+\t   see whether the call is legal.  */ \n+\treturn 0;\n+\n       if (strict && (TYPE_READONLY (arg) < TYPE_READONLY (parm)\n \t\t     || TYPE_VOLATILE (arg) < TYPE_VOLATILE (parm)))\n \treturn 1;\n@@ -3209,13 +3769,13 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n       }\n #endif\n       /* Simple cases: Value already set, does match or doesn't.  */\n-      if (targs[idx] == arg)\n+      if (targs[idx] == arg \n+\t  || (targs[idx] \n+\t      && TREE_CODE (targs[idx]) == NOP_EXPR \n+\t      && TREE_OPERAND (targs[idx], 0) == arg))\n \treturn 0;\n       else if (targs[idx])\n \treturn 1;\n-      /* Check for mixed types and values.  */\n-      if (TREE_CODE (TREE_VALUE (TREE_VEC_ELT (tparms, idx))) != TYPE_DECL)\n-\treturn 1;\n       targs[idx] = arg;\n       return 0;\n     case TEMPLATE_CONST_PARM:\n@@ -3363,8 +3923,9 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n       if (unify (tparms, targs, ntparms, TREE_TYPE (parm),\n \t\t TREE_TYPE (arg), nsubsts, strict))\n \treturn 1;\n-      return type_unification (tparms, targs, TYPE_ARG_TYPES (parm),\n-\t\t\t       TYPE_ARG_TYPES (arg), nsubsts, 1, strict);\n+      return type_unification_real (tparms, targs, TYPE_ARG_TYPES (parm),\n+\t\t\t\t    TYPE_ARG_TYPES (arg), nsubsts, 1, \n+\t\t\t\t    strict, 0);\n \n     case OFFSET_TYPE:\n       if (TREE_CODE (arg) != OFFSET_TYPE)\n@@ -3470,7 +4031,7 @@ get_bindings (fn, decl)\n   tree targs = make_tree_vec (ntparms);\n   int i;\n \n-  i = fn_type_unification (fn, targs, \n+  i = fn_type_unification (fn, NULL_TREE, targs, \n \t\t\t   TYPE_ARG_TYPES (TREE_TYPE (decl)), \n \t\t\t   TREE_TYPE (TREE_TYPE (decl)),\n \t\t\t   1);\n@@ -3872,6 +4433,18 @@ instantiate_decl (d)\n   if (d_defined)\n     return d;\n \n+  if (TREE_CODE (d) == FUNCTION_DECL) \n+    {\n+      tree specs;\n+\n+      /* Check to see if there is a matching specialization. */\n+      for (specs = DECL_TEMPLATE_SPECIALIZATIONS (tmpl);\n+\t   specs != NULL_TREE;\n+\t   specs = TREE_CHAIN (specs))\n+\tif (comp_template_args (TREE_PURPOSE (specs), args))\n+\t  return TREE_VALUE (specs);\n+    }\n+\n   /* This needs to happen before any tsubsting.  */\n   if (! push_tinst_level (d))\n     return d;\n@@ -3950,9 +4523,16 @@ instantiate_decl (d)\n       popclass (1);\n     }\n \n-  /* Convince duplicate_decls to use the DECL_ARGUMENTS from the new decl.  */\n   if (TREE_CODE (d) == FUNCTION_DECL)\n-    DECL_INITIAL (td) = error_mark_node;\n+    {\n+      /* Convince duplicate_decls to use the DECL_ARGUMENTS from the\n+\t new decl.  */ \n+      DECL_INITIAL (td) = error_mark_node;\n+\n+      if (DECL_TEMPLATE_SPECIALIZATION (td) && !DECL_TEMPLATE_INFO (td))\n+\t/* Set up the information about what is being specialized. */\n+\tDECL_TEMPLATE_INFO (td) = DECL_TEMPLATE_INFO (d);\n+    }\n   duplicate_decls (td, d);\n   if (TREE_CODE (d) == FUNCTION_DECL)\n     DECL_INITIAL (td) = 0;"}, {"sha": "b8280a27fa19abf7136961280e2265710136397f", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63", "patch": "@@ -316,6 +316,7 @@ yylex ()\n \t      if (got_scope)\n \t\ttmp_token.yylval.ttype = trrr;\n \t      break;\n+\t    case PFUNCNAME:\n \t    case IDENTIFIER:\n \t      lastiddecl = trrr;\n \t      break;\n@@ -377,6 +378,10 @@ yylex ()\n   if (spew_debug)\n     debug_yychar (yychar);\n #endif\n+\n+  if (yychar == PFUNCNAME)\n+    yylval.ttype = do_identifier (yylval.ttype, 1);\n+\n   return yychar;\n }\n "}, {"sha": "c45745939966ec2e93e85b393f0428af9d96363e", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63", "patch": "@@ -1262,6 +1262,9 @@ is_overloaded_fn (x)\n   if (TREE_CODE (x) == FUNCTION_DECL)\n     return 1;\n \n+  if (TREE_CODE (x) == TEMPLATE_ID_EXPR)\n+    return 1;\n+\n   if (TREE_CODE (x) == TREE_LIST\n       && (TREE_CODE (TREE_VALUE (x)) == FUNCTION_DECL\n \t  || TREE_CODE (TREE_VALUE (x)) == TEMPLATE_DECL))\n@@ -1274,9 +1277,12 @@ int\n really_overloaded_fn (x)\n      tree x;\n {     \n+  if (TREE_CODE (x) == TEMPLATE_ID_EXPR)\n+    return 1;\n+\n   if (TREE_CODE (x) == TREE_LIST\n       && (TREE_CODE (TREE_VALUE (x)) == FUNCTION_DECL\n-\t  || TREE_CODE (TREE_VALUE (x)) == TEMPLATE_DECL))\n+\t  || DECL_FUNCTION_TEMPLATE_P (TREE_VALUE (x))))\n     return 1;\n \n   return 0;\n@@ -1286,7 +1292,8 @@ tree\n get_first_fn (from)\n      tree from;\n {\n-  if (TREE_CODE (from) == FUNCTION_DECL)\n+  if (TREE_CODE (from) == FUNCTION_DECL \n+      || DECL_FUNCTION_TEMPLATE_P (from))\n     return from;\n \n   my_friendly_assert (TREE_CODE (from) == TREE_LIST, 9);"}, {"sha": "2e4f6e2f676a847ff6c267fc32409d07a57f4eb3", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/386b8a85a66471540a1a75ff8f4138fc5ace6a63/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=386b8a85a66471540a1a75ff8f4138fc5ace6a63", "patch": "@@ -2375,7 +2375,7 @@ build_x_function_call (function, params, decl)\n       return build_method_call (decl, function, params,\n \t\t\t\tNULL_TREE, LOOKUP_NORMAL);\n     }\n-  else if (TREE_CODE (function) == TREE_LIST)\n+  else if (really_overloaded_fn (function))\n     {\n       if (TREE_VALUE (function) == NULL_TREE)\n \t{\n@@ -2643,7 +2643,8 @@ build_function_call_real (function, params, require_complete, flags)\n \n   if (!((TREE_CODE (fntype) == POINTER_TYPE\n \t && TREE_CODE (TREE_TYPE (fntype)) == FUNCTION_TYPE)\n-\t|| is_method))\n+\t|| is_method\n+\t|| TREE_CODE (function) == TEMPLATE_ID_EXPR))\n     {\n       cp_error (\"`%E' cannot be used as a function\", function);\n       return error_mark_node;\n@@ -4026,6 +4027,7 @@ build_x_unary_op (code, xarg)\n   /* & rec, on incomplete RECORD_TYPEs is the simple opr &, not an\n      error message.  */\n   if (code == ADDR_EXPR\n+      && TREE_CODE (xarg) != TEMPLATE_ID_EXPR\n       && ((IS_AGGR_TYPE_CODE (TREE_CODE (TREE_TYPE (xarg)))\n \t   && TYPE_SIZE (TREE_TYPE (xarg)) == NULL_TREE)\n \t  || (TREE_CODE (xarg) == OFFSET_REF)))\n@@ -4420,6 +4422,27 @@ build_unary_op (code, xarg, noconvert)\n \t\t\t\t   0);\n \t  return build1 (ADDR_EXPR, unknown_type_node, arg);\n \t}\n+      else if (TREE_CODE (arg) == TEMPLATE_ID_EXPR)\n+\t{\n+\t  tree targs;\n+\t  tree fn;\n+\t  \n+\t  /* We don't require a match here; it's possible that the\n+\t     context (like a cast to a particular type) will resolve\n+\t     the particular choice of template.  */\n+\t  fn = determine_explicit_specialization (arg, NULL_TREE,\n+\t\t\t\t\t\t  &targs,\n+\t\t\t\t\t\t  0, 0);\n+\n+\t  if (fn)\n+\t    {\n+\t      fn = instantiate_template (fn, targs);\n+\t      mark_addressable (fn);\n+\t      return build_unary_op (ADDR_EXPR, fn, 0);\n+\t    }\n+\n+\t  return build1 (ADDR_EXPR, unknown_type_node, arg);\n+\t}\n \n       /* Handle complex lvalues (when permitted)\n \t by reduction to simpler cases.  */\n@@ -4757,6 +4780,8 @@ mark_addressable (exp)\n \t    if (x == current_function_decl)\n \t      DECL_EXTERNAL (x) = 0;\n \t  }\n+\tif (DECL_TEMPLATE_INFO (x) && !DECL_TEMPLATE_SPECIALIZATION (x))\n+\t  mark_used (x);\n \tTREE_ADDRESSABLE (x) = 1;\n \tTREE_USED (x) = 1;\n \tTREE_ADDRESSABLE (DECL_ASSEMBLER_NAME (x)) = 1;"}]}