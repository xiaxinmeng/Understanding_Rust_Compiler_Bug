{"sha": "b258707c7efd72e380f3b95d70208a9d2975a095", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI1ODcwN2M3ZWZkNzJlMzgwZjNiOTVkNzAyMDhhOWQyOTc1YTA5NQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-11-15T02:42:39Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-11-15T02:42:39Z"}, "message": "(expand_expr): For TRUTH_AND_EXPR...\n\n(expand_expr): For TRUTH_AND_EXPR, TRUTH_OR_EXPR\nand TRUTH_XOR_EXPR, if result mode doesn't match operands,\ndon't use subtarget.\n\n(store_expr): Convert constants to proper mode in two places.\n\nFrom-SVN: r6096", "tree": {"sha": "528432373685c8610dc03d613eebab6d4087a506", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/528432373685c8610dc03d613eebab6d4087a506"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b258707c7efd72e380f3b95d70208a9d2975a095", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b258707c7efd72e380f3b95d70208a9d2975a095", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b258707c7efd72e380f3b95d70208a9d2975a095", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b258707c7efd72e380f3b95d70208a9d2975a095/comments", "author": null, "committer": null, "parents": [{"sha": "649f35f1673b77fb7143ef4f37c9add9b00f0630", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/649f35f1673b77fb7143ef4f37c9add9b00f0630", "html_url": "https://github.com/Rust-GCC/gccrs/commit/649f35f1673b77fb7143ef4f37c9add9b00f0630"}], "stats": {"total": 25, "additions": 25, "deletions": 0}, "files": [{"sha": "f82c2abc3967003eff5a212cebf3c22eecbf775c", "filename": "gcc/expr.c", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b258707c7efd72e380f3b95d70208a9d2975a095/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b258707c7efd72e380f3b95d70208a9d2975a095/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b258707c7efd72e380f3b95d70208a9d2975a095", "patch": "@@ -2610,6 +2610,14 @@ store_expr (exp, target, want_value)\n        expression.  */\n     {\n       temp = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n+\n+      /* If TEMP is a VOIDmode constant, use convert_modes to make\n+\t sure that we properly convert it.  */\n+      if (CONSTANT_P (temp) && GET_MODE (temp) == VOIDmode)\n+\ttemp = convert_modes (GET_MODE (SUBREG_REG (target)),\n+\t\t\t      TYPE_MODE (TREE_TYPE (exp)), temp,\n+\t\t\t      SUBREG_PROMOTED_UNSIGNED_P (target));\n+\n       convert_move (SUBREG_REG (target), temp,\n \t\t    SUBREG_PROMOTED_UNSIGNED_P (target));\n       return want_value ? temp : NULL_RTX;\n@@ -2633,6 +2641,15 @@ store_expr (exp, target, want_value)\n \tdont_return_target = 1;\n     }\n \n+  /* If TEMP is a VOIDmode constant and the mode of the type of EXP is not\n+     the same as that of TARGET, adjust the constant.  This is needed, for\n+     example, in case it is a CONST_DOUBLE and we want only a word-sized\n+     value.  */\n+  if (CONSTANT_P (temp) && GET_MODE (temp) == VOIDmode\n+      && GET_MODE (target) != TYPE_MODE (TREE_TYPE (exp)))\n+    temp = convert_modes (GET_MODE (target), TYPE_MODE (TREE_TYPE (exp)),\n+\t\t\t  temp, TREE_UNSIGNED (TREE_TYPE (exp)));\n+\n   /* If value was not generated in the target, store it there.\n      Convert the value to TARGET's type first if nec.  */\n \n@@ -5147,18 +5164,26 @@ expand_expr (exp, target, tmode, modifier)\n    treating TRUTH_AND_EXPR like TRUTH_ANDIF_EXPR;\n    but the question is how to recognize those cases.  */\n \n+      /* TRUTH_AND_EXPR can have a result whose mode doesn't match\n+\t th operands.  If so, don't use our target.  */\n     case TRUTH_AND_EXPR:\n+      if (mode != TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n+\tsubtarget = 0;\n     case BIT_AND_EXPR:\n       this_optab = and_optab;\n       goto binop;\n \n /* See comment above about TRUTH_AND_EXPR; it applies here too.  */\n     case TRUTH_OR_EXPR:\n+      if (mode != TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n+\tsubtarget = 0;\n     case BIT_IOR_EXPR:\n       this_optab = ior_optab;\n       goto binop;\n \n     case TRUTH_XOR_EXPR:\n+      if (mode != TYPE_MODE (TREE_TYPE (TREE_OPERAND (exp, 0))))\n+\tsubtarget = 0;\n     case BIT_XOR_EXPR:\n       this_optab = xor_optab;\n       goto binop;"}]}