{"sha": "61238a798636700375ab418bca76689c36cf434d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjEyMzhhNzk4NjM2NzAwMzc1YWI0MThiY2E3NjY4OWMzNmNmNDM0ZA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2009-03-26T14:36:27Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2009-03-26T14:36:27Z"}, "message": "divv2df3.c: New file.\n\n\t* config/spu/divv2df3.c: New file.\n\t* config/spu/t-spu-elf (LIB2FUNCS_STATIC_EXTRA): Add it.\n\t(DPBIT_FUNCS): Filter out _div_df.\n\nFrom-SVN: r145089", "tree": {"sha": "77d937954c4957d91896d0a3ac44014350bb648b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77d937954c4957d91896d0a3ac44014350bb648b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61238a798636700375ab418bca76689c36cf434d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61238a798636700375ab418bca76689c36cf434d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61238a798636700375ab418bca76689c36cf434d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61238a798636700375ab418bca76689c36cf434d/comments", "author": null, "committer": null, "parents": [{"sha": "d43f68d639c2087936109a454972eaaeeb56553a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d43f68d639c2087936109a454972eaaeeb56553a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d43f68d639c2087936109a454972eaaeeb56553a"}], "stats": {"total": 211, "additions": 210, "deletions": 1}, "files": [{"sha": "877fce3dd1a23d7f04968e994b1e8a60da902b94", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61238a798636700375ab418bca76689c36cf434d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61238a798636700375ab418bca76689c36cf434d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=61238a798636700375ab418bca76689c36cf434d", "patch": "@@ -1,3 +1,9 @@\n+2009-03-26  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* config/spu/divv2df3.c: New file.\n+\t* config/spu/t-spu-elf (LIB2FUNCS_STATIC_EXTRA): Add it.\n+\t(DPBIT_FUNCS): Filter out _div_df.\n+\n 2009-03-26  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* config/bfin/bfin.c (bfin_optimize_loop): If the LSETUP goes before"}, {"sha": "cd7126bb7338a025a1b6617671d4dbd206d9ec3c", "filename": "gcc/config/spu/divv2df3.c", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61238a798636700375ab418bca76689c36cf434d/gcc%2Fconfig%2Fspu%2Fdivv2df3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61238a798636700375ab418bca76689c36cf434d/gcc%2Fconfig%2Fspu%2Fdivv2df3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fdivv2df3.c?ref=61238a798636700375ab418bca76689c36cf434d", "patch": "@@ -0,0 +1,198 @@\n+/* Copyright (C) 2009 Free Software Foundation, Inc.\n+ \n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 2 of the License, or (at your option)\n+   any later version.\n+ \n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+ \n+   You should have received a copy of the GNU General Public License\n+   along with this file; see the file COPYING.  If not, write to the Free\n+   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n+   02110-1301, USA.  */\n+\n+/* As a special exception, if you link this library with files compiled with\n+   GCC to produce an executable, this does not cause the resulting executable\n+   to be covered by the GNU General Public License.  The exception does not\n+   however invalidate any other reasons why the executable file might be covered\n+   by the GNU General Public License. */\n+\n+\n+#include <spu_intrinsics.h>\n+\n+vector double __divv2df3 (vector double a_in, vector double b_in);\n+\n+/* __divv2df3 divides the vector dividend a by the vector divisor b and \n+   returns the resulting vector quotient.  Maximum error about 0.5 ulp \n+   over entire double range including denorms, compared to true result\n+   in round-to-nearest rounding mode.  Handles Inf or NaN operands and \n+   results correctly.  */\n+\n+vector double\n+__divv2df3 (vector double a_in, vector double b_in)\n+{\n+  /* Variables */\n+  vec_int4    exp, exp_bias;\n+  vec_uint4   no_underflow, overflow;\n+  vec_float4  mant_bf, inv_bf;\n+  vec_ullong2 exp_a, exp_b;\n+  vec_ullong2 a_nan, a_zero, a_inf, a_denorm, a_denorm0;\n+  vec_ullong2 b_nan, b_zero, b_inf, b_denorm, b_denorm0;\n+  vec_ullong2 nan;\n+  vec_uint4   a_exp, b_exp;\n+  vec_ullong2 a_mant_0, b_mant_0;\n+  vec_ullong2 a_exp_1s, b_exp_1s;\n+  vec_ullong2 sign_exp_mask;\n+\n+  vec_double2 a, b;\n+  vec_double2 mant_a, mant_b, inv_b, q0, q1, q2, mult;\n+\n+  /* Constants */\n+  vec_uint4   exp_mask_u32 = spu_splats((unsigned int)0x7FF00000);\n+  vec_uchar16 splat_hi = (vec_uchar16){0,1,2,3, 0,1,2,3,  8, 9,10,11, 8,9,10,11};\n+  vec_uchar16 swap_32 = (vec_uchar16){4,5,6,7, 0,1,2,3, 12,13,14,15, 8,9,10,11};\n+  vec_ullong2 exp_mask = spu_splats(0x7FF0000000000000ULL);\n+  vec_ullong2 sign_mask = spu_splats(0x8000000000000000ULL);\n+  vec_float4  onef = spu_splats(1.0f);\n+  vec_double2 one = spu_splats(1.0);\n+  vec_double2 exp_53 = (vec_double2)spu_splats(0x0350000000000000ULL);\n+\n+  sign_exp_mask = spu_or(sign_mask, exp_mask);\n+\n+  /* Extract the floating point components from each of the operands including\n+   * exponent and mantissa.\n+   */\n+  a_exp = (vec_uint4)spu_and((vec_uint4)a_in, exp_mask_u32);\n+  a_exp = spu_shuffle(a_exp, a_exp, splat_hi);\n+  b_exp = (vec_uint4)spu_and((vec_uint4)b_in, exp_mask_u32);\n+  b_exp = spu_shuffle(b_exp, b_exp, splat_hi);\n+\n+  a_mant_0 = (vec_ullong2)spu_cmpeq((vec_uint4)spu_andc((vec_ullong2)a_in, sign_exp_mask), 0);\n+  a_mant_0 = spu_and(a_mant_0, spu_shuffle(a_mant_0, a_mant_0, swap_32));\n+\n+  b_mant_0 = (vec_ullong2)spu_cmpeq((vec_uint4)spu_andc((vec_ullong2)b_in, sign_exp_mask), 0);\n+  b_mant_0 = spu_and(b_mant_0, spu_shuffle(b_mant_0, b_mant_0, swap_32));\n+\n+  a_exp_1s = (vec_ullong2)spu_cmpeq(a_exp, exp_mask_u32);\n+  b_exp_1s = (vec_ullong2)spu_cmpeq(b_exp, exp_mask_u32);\n+\n+  /* Identify all possible special values that must be accomodated including:\n+   * +-denorm, +-0, +-infinity, and NaNs.\n+   */\n+  a_denorm0= (vec_ullong2)spu_cmpeq(a_exp, 0);\n+  a_nan    = spu_andc(a_exp_1s, a_mant_0);\n+  a_zero   = spu_and (a_denorm0, a_mant_0);\n+  a_inf    = spu_and (a_exp_1s, a_mant_0);\n+  a_denorm = spu_andc(a_denorm0, a_zero);\n+\n+  b_denorm0= (vec_ullong2)spu_cmpeq(b_exp, 0);\n+  b_nan    = spu_andc(b_exp_1s, b_mant_0);\n+  b_zero   = spu_and (b_denorm0, b_mant_0);\n+  b_inf    = spu_and (b_exp_1s, b_mant_0);\n+  b_denorm = spu_andc(b_denorm0, b_zero);\n+\n+  /* Scale denorm inputs to into normalized numbers by conditionally scaling the \n+   * input parameters.\n+   */\n+  a = spu_sub(spu_or(a_in, exp_53), spu_sel(exp_53, a_in, sign_mask));\n+  a = spu_sel(a_in, a, a_denorm);\n+\n+  b = spu_sub(spu_or(b_in, exp_53), spu_sel(exp_53, b_in, sign_mask));\n+  b = spu_sel(b_in, b, b_denorm);\n+\n+  /* Extract the divisor and dividend exponent and force parameters into the signed \n+   * range [1.0,2.0) or [-1.0,2.0).\n+   */\n+  exp_a = spu_and((vec_ullong2)a, exp_mask);\n+  exp_b = spu_and((vec_ullong2)b, exp_mask);\n+\n+  mant_a = spu_sel(a, one, (vec_ullong2)exp_mask);\n+  mant_b = spu_sel(b, one, (vec_ullong2)exp_mask);\n+  \n+  /* Approximate the single reciprocal of b by using\n+   * the single precision reciprocal estimate followed by one \n+   * single precision iteration of Newton-Raphson.\n+   */\n+  mant_bf = spu_roundtf(mant_b);\n+  inv_bf = spu_re(mant_bf);\n+  inv_bf = spu_madd(spu_nmsub(mant_bf, inv_bf, onef), inv_bf, inv_bf);\n+\n+  /* Perform 2 more Newton-Raphson iterations in double precision. The\n+   * result (q1) is in the range (0.5, 2.0).\n+   */\n+  inv_b = spu_extend(inv_bf);\n+  inv_b = spu_madd(spu_nmsub(mant_b, inv_b, one), inv_b, inv_b);\n+  q0 = spu_mul(mant_a, inv_b);\n+  q1 = spu_madd(spu_nmsub(mant_b, q0, mant_a), inv_b, q0);\n+\n+  /* Determine the exponent correction factor that must be applied \n+   * to q1 by taking into account the exponent of the normalized inputs\n+   * and the scale factors that were applied to normalize them.\n+   */\n+  exp = spu_rlmaska(spu_sub((vec_int4)exp_a, (vec_int4)exp_b), -20);\n+  exp = spu_add(exp, (vec_int4)spu_add(spu_and((vec_int4)a_denorm, -0x34), spu_and((vec_int4)b_denorm, 0x34)));\n+  \n+  /* Bias the quotient exponent depending on the sign of the exponent correction\n+   * factor so that a single multiplier will ensure the entire double precision\n+   * domain (including denorms) can be achieved.\n+   *\n+   *    exp \t       bias q1     adjust exp\n+   *   =====\t       ========    ==========\n+   *   positive         2^+65         -65\n+   *   negative         2^-64         +64\n+   */\n+  exp_bias = spu_xor(spu_rlmaska(exp, -31), 64);\n+  exp = spu_sub(exp, exp_bias);\n+\n+  q1 = spu_sel(q1, (vec_double2)spu_add((vec_int4)q1, spu_sl(exp_bias, 20)), exp_mask);\n+\n+  /* Compute a multiplier (mult) to applied to the quotient (q1) to produce the \n+   * expected result. On overflow, clamp the multiplier to the maximum non-infinite\n+   * number in case the rounding mode is not round-to-nearest.\n+   */\n+  exp = spu_add(exp, 0x3FF);\n+  no_underflow = spu_cmpgt(exp, 0);\n+  overflow = spu_cmpgt(exp, 0x7FE);\n+  exp = spu_and(spu_sl(exp, 20), (vec_int4)no_underflow);\n+  exp = spu_and(exp, (vec_int4)exp_mask);\n+\n+  mult = spu_sel((vec_double2)exp, (vec_double2)(spu_add((vec_uint4)exp_mask, -1)), (vec_ullong2)overflow);\n+\n+  /* Handle special value conditions. These include:\n+   *\n+   * 1) IF either operand is a NaN OR both operands are 0 or INFINITY THEN a NaN \n+   *    results.\n+   * 2) ELSE IF the dividend is an INFINITY OR the divisor is 0 THEN a INFINITY results.\n+   * 3) ELSE IF the dividend is 0 OR the divisor is INFINITY THEN a 0 results.\n+   */\n+  mult = spu_andc(mult, (vec_double2)spu_or(a_zero, b_inf));\n+  mult = spu_sel(mult, (vec_double2)exp_mask, spu_or(a_inf, b_zero));\n+\n+  nan = spu_or(a_nan, b_nan);\n+  nan = spu_or(nan, spu_and(a_zero, b_zero));\n+  nan = spu_or(nan, spu_and(a_inf, b_inf));\n+\n+  mult = spu_or(mult, (vec_double2)nan);\n+\n+  /* Scale the final quotient */\n+\n+  q2 = spu_mul(q1, mult);\n+\n+  return (q2);\n+}\n+\n+\n+/* We use the same function for vector and scalar division.  Provide the\n+   scalar entry point as an alias.  */\n+double __divdf3 (double a, double b)\n+  __attribute__ ((__alias__ (\"__divv2df3\")));\n+\n+/* Some toolchain builds used the __fast_divdf3 name for this helper function.\n+   Provide this as another alternate entry point for compatibility.  */\n+double __fast_divdf3 (double a, double b)\n+  __attribute__ ((__alias__ (\"__divv2df3\")));\n+"}, {"sha": "f8c5ba5b01db75b0ad2c036e663d653f535bce29", "filename": "gcc/config/spu/t-spu-elf", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61238a798636700375ab418bca76689c36cf434d/gcc%2Fconfig%2Fspu%2Ft-spu-elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61238a798636700375ab418bca76689c36cf434d/gcc%2Fconfig%2Fspu%2Ft-spu-elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Ft-spu-elf?ref=61238a798636700375ab418bca76689c36cf434d", "patch": "@@ -29,6 +29,10 @@ TARGET_LIBGCC2_CFLAGS = -fPIC -mwarn-reloc -D__IN_LIBGCC2\n # own versions below.\n LIB2FUNCS_EXCLUDE = _floatdisf _floatundisf\n \n+# We provide our own version of __divdf3 that performs better and has\n+# better support for non-default rounding modes.\n+DPBIT_FUNCS := $(filter-out _div_df, $(DPBIT_FUNCS))\n+\n LIB2FUNCS_STATIC_EXTRA = $(srcdir)/config/spu/float_unssidf.c \\\n \t\t\t $(srcdir)/config/spu/float_unsdidf.c \\\n \t\t\t $(srcdir)/config/spu/float_unsdisf.c \\\n@@ -39,7 +43,8 @@ LIB2FUNCS_STATIC_EXTRA = $(srcdir)/config/spu/float_unssidf.c \\\n \t\t\t $(srcdir)/config/spu/mfc_multi_tag_reserve.c \\\n \t\t\t $(srcdir)/config/spu/mfc_multi_tag_release.c \\\n \t\t\t $(srcdir)/config/spu/multi3.c \\\n-\t\t\t $(srcdir)/config/spu/divmodti4.c\n+\t\t\t $(srcdir)/config/spu/divmodti4.c \\\n+\t\t\t $(srcdir)/config/spu/divv2df3.c\n \n LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde.c \\\n    $(srcdir)/unwind-sjlj.c $(srcdir)/unwind-c.c"}]}