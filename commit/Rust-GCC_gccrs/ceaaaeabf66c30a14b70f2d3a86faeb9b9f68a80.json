{"sha": "ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VhYWFlYWJmNjZjMzBhMTRiNzBmMmQzYTg2ZmFlYjliOWY2OGE4MA==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2011-04-01T20:08:22Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2011-04-01T20:08:22Z"}, "message": "constraints.md: New file.\n\n\t* config/h8300/constraints.md: New file.\n\t* config/h8300/h8300.md: Include it.  Use satisfies_constraint_J,\n\tsatisfies_constraint_L, and satisfies_constraint_N for peephole2s.\n\t(*tst_extzv_1_n, *tstsi_variable_bit_qi): Use satisfies_constraint_U.\n\t* config/h8300/predicates.md (bit_operand): Likewise.\n\t(incdec_operand): Use satisfies_constraint_M and\n\tsatisfies_constraint_O.  Don't use C code block.\n\t* config/h8300/h8300-protos.h (h8300_reg_class_from_letter): Delete.\n\t* config/h8300/h8300.c (h8300_reg_class_from_letter): Delete.\n\t(compute_mov_length): Use satisfies_constraint_G.\n\t(fix_bit_operand): Use satisfies_constraint_U.\n\t* config/h8300/h8300.h (REG_CLASS_FROM_LETTER): Delete.\n\t(CONST_OK_FOR_I, CONST_OK_FOR_J, CONST_OK_FOR_L): Delete.\n\t(CONST_OK_FOR_M, CONST_OK_FOR_N, CONST_OK_FOR_O): Delete.\n\t(CONST_OK_FOR_Ppositive, CONST_OK_FOR_Pnegative): Delete.\n\t(CONST_OK_FOR_P, CONSTRAINT_LEN_FOR_P): Delete.\n\t(CONST_OK_FOR_CONSTRAINT_P, CONST_OK_FOR_LETTER_P): Delete.\n\t(CONST_DOUBLE_OK_FOR_LETTER_P): Delete.\n\t(OK_FOR_Q, OK_FOR_R, OK_FOR_S, OK_FOR_T, OK_FOR_U, OK_FOR_WU): Delete.\n\t(OK_FOR_W, CONSTRAINT_LEN_FOR_W, OK_FOR_Y2, OK_FOR_Y0): Delete.\n\t(OK_FOR_Y, CONSTRAINT_LEN_FOR_Y, OK_FOR_Z): Delete.\n\t(EXTRA_CONSTRAINT_STR, CONSTRAINT_LEN): Delete.\n\t(EXTRA_MEMORY_CONSTRAINT): Delete.\n\nFrom-SVN: r171851", "tree": {"sha": "abb68412369fc84e728ef673419272773ff02ce8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/abb68412369fc84e728ef673419272773ff02ce8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80/comments", "author": null, "committer": null, "parents": [{"sha": "c1c0e8e1d308828391ab2ff91c1945006a772b2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1c0e8e1d308828391ab2ff91c1945006a772b2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1c0e8e1d308828391ab2ff91c1945006a772b2c"}], "stats": {"total": 534, "additions": 261, "deletions": 273}, "files": [{"sha": "1f03c10f1017d583bf65235208d9022a5e7ae6cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80", "patch": "@@ -1,3 +1,29 @@\n+2011-04-01  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* config/h8300/constraints.md: New file.\n+\t* config/h8300/h8300.md: Include it.  Use satisfies_constraint_J,\n+\tsatisfies_constraint_L, and satisfies_constraint_N for peephole2s.\n+\t(*tst_extzv_1_n, *tstsi_variable_bit_qi): Use satisfies_constraint_U.\n+\t* config/h8300/predicates.md (bit_operand): Likewise.\n+\t(incdec_operand): Use satisfies_constraint_M and\n+\tsatisfies_constraint_O.  Don't use C code block.\n+\t* config/h8300/h8300-protos.h (h8300_reg_class_from_letter): Delete.\n+\t* config/h8300/h8300.c (h8300_reg_class_from_letter): Delete.\n+\t(compute_mov_length): Use satisfies_constraint_G.\n+\t(fix_bit_operand): Use satisfies_constraint_U.\n+\t* config/h8300/h8300.h (REG_CLASS_FROM_LETTER): Delete.\n+\t(CONST_OK_FOR_I, CONST_OK_FOR_J, CONST_OK_FOR_L): Delete.\n+\t(CONST_OK_FOR_M, CONST_OK_FOR_N, CONST_OK_FOR_O): Delete.\n+\t(CONST_OK_FOR_Ppositive, CONST_OK_FOR_Pnegative): Delete.\n+\t(CONST_OK_FOR_P, CONSTRAINT_LEN_FOR_P): Delete.\n+\t(CONST_OK_FOR_CONSTRAINT_P, CONST_OK_FOR_LETTER_P): Delete.\n+\t(CONST_DOUBLE_OK_FOR_LETTER_P): Delete.\n+\t(OK_FOR_Q, OK_FOR_R, OK_FOR_S, OK_FOR_T, OK_FOR_U, OK_FOR_WU): Delete.\n+\t(OK_FOR_W, CONSTRAINT_LEN_FOR_W, OK_FOR_Y2, OK_FOR_Y0): Delete.\n+\t(OK_FOR_Y, CONSTRAINT_LEN_FOR_Y, OK_FOR_Z): Delete.\n+\t(EXTRA_CONSTRAINT_STR, CONSTRAINT_LEN): Delete.\n+\t(EXTRA_MEMORY_CONSTRAINT): Delete.\n+\n 2011-04-01  Andrew Pinski  <pinskia@gmail.com>\n \t    Michael Meissner  <meissner@linux.vnet.ibm.com>\n "}, {"sha": "0654bebc13ee02791d3beed762fe75a8b97c7602", "filename": "gcc/config/h8300/constraints.md", "status": "added", "additions": 214, "deletions": 0, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80/gcc%2Fconfig%2Fh8300%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80/gcc%2Fconfig%2Fh8300%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fconstraints.md?ref=ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80", "patch": "@@ -0,0 +1,214 @@\n+;; Constraint definitions for Renesas H8/300.\n+;; Copyright (C) 2011 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+;; Register constraints.\n+(define_register_constraint \"a\" \"MAC_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"c\" \"COUNTER_REGS\"\n+  \"@internal\")\n+\n+;; Some patterns need to use er6 as a scratch register.  This is\n+;; difficult to arrange since er6 is the frame pointer and usually can't\n+;; be spilled.\n+\n+;; Such patterns should define two alternatives, one which allows only\n+;; er6 and one which allows any general register.  The former\n+;; alternative should have a 'd' constraint while the latter should be\n+;; disparaged and use 'D'.\n+\n+;; Normally, 'd' maps to DESTINATION_REGS and 'D' maps to GENERAL_REGS.\n+;; However, there are cases where they should be NO_REGS:\n+\n+;;   - 'd' should be NO_REGS when reloading a function that uses the\n+;;     frame pointer.  In this case, DESTINATION_REGS won't contain any\n+;;     spillable registers, so the first alternative can't be used.\n+\n+;;   - -fno-omit-frame-pointer means that the frame pointer will\n+;;     always be in use.  It's therefore better to map 'd' to NO_REGS\n+;;     before reload so that register allocator will pick the second\n+;;     alternative.\n+\n+;;   - we would like 'D' to be be NO_REGS when the frame pointer isn't\n+;;     live, but we the frame pointer may turn out to be needed after\n+;;     we start reload, and then we may have already decided we don't\n+;;     have a choice, so we can't do that.  Forcing the register\n+;;     allocator to use er6 if possible might produce better code for\n+;;     small functions: it's more efficient to save and restore er6 in\n+;;     the prologue & epilogue than to do it in a define_split.\n+;;     Hopefully disparaging 'D' will have a similar effect, without\n+;;     forcing a reload failure if the frame pointer is found to be\n+;;     needed too late.\n+\n+(define_register_constraint \"d\"\n+  \"(!flag_omit_frame_pointer && !reload_completed\n+    ? NO_REGS\n+    : (frame_pointer_needed && reload_in_progress\n+       ? NO_REGS\n+       : DESTINATION_REGS))\"\n+  \"@internal\")\n+\n+(define_register_constraint \"D\" \"GENERAL_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"f\" \"SOURCE_REGS\"\n+  \"@internal\")\n+\n+;; Integer constraints.\n+(define_constraint \"I\"\n+  \"Integer zero.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 0\")))\n+\n+(define_constraint \"J\"\n+  \"An integer with its low byte clear.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"(ival & 0xff) == 0\")))\n+\n+(define_constraint \"L\"\n+  \"1, 2 or 4 on the H8300H or S; 1 or 2 otherwise.\"\n+  (and (match_code \"const_int\")\n+       (if_then_else (match_test \"TARGET_H8300H || TARGET_H8300S\")\n+\t\t     (match_test \"ival == 1 || ival == 2 || ival == 4\")\n+\t\t     (match_test \"ival == 1 || ival == 2\"))))\n+\n+(define_constraint \"M\"\n+  \"Integer 1 or 2.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 1 || ival == 2\")))\n+\n+(define_constraint \"N\"\n+  \"-1, -2, or -4 on the H8300H or S; -1 or -2 otherwise.\"\n+  (and (match_code \"const_int\")\n+       (if_then_else (match_test \"TARGET_H8300H || TARGET_H8300S\")\n+\t\t     (match_test \"ival == -1 || ival == -2 || ival == -4\")\n+\t\t     (match_test \"ival == -1 || ival == -2\"))))\n+\n+(define_constraint \"O\"\n+  \"Integer -1 or -2.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == -1 || ival == -2\")))\n+\n+(define_constraint \"P1>X\"\n+  \"A positive, non-zero integer that fits in 1 bits.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"TARGET_H8300SX\")\n+       (match_test \"IN_RANGE (ival, 1, (1 << 1) - 1)\")))\n+\n+(define_constraint \"P3>X\"\n+  \"A positive, non-zero integer that fits in 3 bits.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"TARGET_H8300SX\")\n+       (match_test \"IN_RANGE (ival, 1, (1 << 3) - 1)\")))\n+\n+(define_constraint \"P4>X\"\n+  \"A positive, non-zero integer that fits in 4 bits.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"TARGET_H8300SX\")\n+       (match_test \"IN_RANGE (ival, 1, (1 << 4) - 1)\")))\n+\n+(define_constraint \"P5>X\"\n+  \"A positive, non-zero integer that fits in 5 bits.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"TARGET_H8300SX\")\n+       (match_test \"IN_RANGE (ival, 1, (1 << 5) - 1)\")))\n+\n+(define_constraint \"P8>X\"\n+  \"A positive, non-zero integer that fits in 8 bits.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"TARGET_H8300SX\")\n+       (match_test \"IN_RANGE (ival, 1, (1 << 8) - 1)\")))\n+\n+(define_constraint \"P3<X\"\n+  \"A negative, non-zero integer that fits in 3 bits.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"TARGET_H8300SX\")\n+       (match_test \"IN_RANGE (ival, (-(1 << 3)) + 1, -1)\")))\n+\n+;; Floating-point constraints.\n+(define_constraint \"G\"\n+  \"Single-float zero.\"\n+  (and (match_code \"const_double\")\n+       (match_test \"op == CONST0_RTX (SFmode)\")))\n+\n+;; Extra constraints.\n+(define_constraint \"Q\"\n+  \"@internal\"\n+  (and (match_test \"TARGET_H8300SX\")\n+       (match_operand 0 \"memory_operand\")))\n+\n+(define_constraint \"R\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"!h8300_shift_needs_scratch_p (ival, QImode)\")))\n+\n+(define_constraint \"S\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"!h8300_shift_needs_scratch_p (ival, HImode)\")))\n+\n+(define_constraint \"T\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"!h8300_shift_needs_scratch_p (ival, SImode)\")))\n+\n+(define_constraint \"U\"\n+  \"An operand valid for a bset destination.\"\n+  (ior (and (match_code \"reg\")\n+\t    (match_test \"REG_OK_FOR_BASE_P (op)\"))\n+       (and (match_code \"mem\")\n+\t    (match_code \"reg\" \"0\")\n+\t    (match_test \"REG_OK_FOR_BASE_P (XEXP (op, 0))\"))\n+       (and (match_code \"mem\")\n+\t    (match_code \"symbol_ref\" \"0\")\n+\t    (match_test \"TARGET_H8300S\"))\n+       (and (match_code \"mem\")\n+\t    (match_code \"const\" \"0\")\n+\t    (match_code \"plus\" \"00\")\n+\t    (match_code \"symbol_ref\" \"000\")\n+\t    (match_code \"const_int\" \"001\")\n+\t    (ior (match_test \"TARGET_H8300S\")\n+\t\t (match_test \"SYMBOL_REF_FLAG (XEXP (XEXP (XEXP (op, 0), 0), 0))\")))\n+       (and (match_code \"mem\")\n+\t    (match_test \"h8300_eightbit_constant_address_p (XEXP (op, 0))\"))\n+       (and (match_code \"mem\")\n+\t    (ior (match_test \"TARGET_H8300S\")\n+\t\t (match_test \"TARGET_H8300SX\"))\n+\t    (match_code \"const_int\" \"0\"))))\n+\n+(define_memory_constraint \"WU\"\n+  \"@internal\"\n+  (and (match_code \"mem\")\n+       (match_test \"satisfies_constraint_U (op)\")))\n+\n+(define_constraint \"Y0\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"exact_log2 (~ival & 0xff) != -1\")))\n+\n+(define_constraint \"Y2\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"exact_log2 (ival & 0xff) != -1\")))\n+\n+(define_constraint \"Z\"\n+  \"@internal\"\n+  (and (match_test \"TARGET_H8300SX\")\n+       (match_code \"mem\")\n+       (match_test \"CONSTANT_P (XEXP (op, 0))\")))"}, {"sha": "8c721297c86fee79fe4596c8fbc7b1f36595a33d", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 5, "deletions": 69, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80", "patch": "@@ -41,6 +41,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"c-family/c-pragma.h\"\t/* ??? */\n #include \"tm_p.h\"\n+#include \"tm-constrs.h\"\n #include \"ggc.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n@@ -421,71 +422,6 @@ h8300_option_override (void)\n     flag_strict_volatile_bitfields = 1;\n }\n \n-/* Implement REG_CLASS_FROM_LETTER.\n-\n-   Some patterns need to use er6 as a scratch register.  This is\n-   difficult to arrange since er6 is the frame pointer and usually\n-   can't be spilled.\n-\n-   Such patterns should define two alternatives, one which allows only\n-   er6 and one which allows any general register.  The former alternative\n-   should have a 'd' constraint while the latter should be disparaged and\n-   use 'D'.\n-\n-   Normally, 'd' maps to DESTINATION_REGS and 'D' maps to GENERAL_REGS.\n-   However, there are cases where they should be NO_REGS:\n-\n-     - 'd' should be NO_REGS when reloading a function that uses the\n-       frame pointer.  In this case, DESTINATION_REGS won't contain any\n-       spillable registers, so the first alternative can't be used.\n-\n-     - -fno-omit-frame-pointer means that the frame pointer will\n-       always be in use.  It's therefore better to map 'd' to NO_REGS\n-       before reload so that register allocator will pick the second\n-       alternative.\n-\n-     - we would like 'D' to be be NO_REGS when the frame pointer isn't\n-       live, but we the frame pointer may turn out to be needed after\n-       we start reload, and then we may have already decided we don't\n-       have a choice, so we can't do that.  Forcing the register\n-       allocator to use er6 if possible might produce better code for\n-       small functions: it's more efficient to save and restore er6 in\n-       the prologue & epilogue than to do it in a define_split.\n-       Hopefully disparaging 'D' will have a similar effect, without\n-       forcing a reload failure if the frame pointer is found to be\n-       needed too late.  */\n-\n-enum reg_class\n-h8300_reg_class_from_letter (int c)\n-{\n-  switch (c)\n-    {\n-    case 'a':\n-      return MAC_REGS;\n-\n-    case 'c':\n-      return COUNTER_REGS;\n-\n-    case 'd':\n-      if (!flag_omit_frame_pointer && !reload_completed)\n-\treturn NO_REGS;\n-      if (frame_pointer_needed && reload_in_progress)\n-\treturn NO_REGS;\n-      return DESTINATION_REGS;\n-\n-    case 'D':\n-      /* The meaning of a constraint shouldn't change dynamically, so\n-\t we can't make this NO_REGS.  */\n-      return GENERAL_REGS;\n-\n-    case 'f':\n-      return SOURCE_REGS;\n-\n-    default:\n-      return NO_REGS;\n-    }\n-}\n-\n /* Return the byte register name for a register rtx X.  B should be 0\n    if you want a lower byte register.  B should be 1 if you want an\n    upper byte register.  */\n@@ -2827,7 +2763,7 @@ compute_mov_length (rtx *operands)\n \t      if (REG_P (src))\n \t\treturn 4;\n \n-\t      if (CONST_DOUBLE_OK_FOR_LETTER_P (src, 'G'))\n+\t      if (satisfies_constraint_G (src))\n \t\treturn 4;\n \n \t      return 8;\n@@ -2947,7 +2883,7 @@ compute_mov_length (rtx *operands)\n \t      if (REG_P (src))\n \t\treturn 2;\n \n-\t      if (CONST_DOUBLE_OK_FOR_LETTER_P (src, 'G'))\n+\t      if (satisfies_constraint_G (src))\n \t\treturn 2;\n \n \t      return 6;\n@@ -5186,7 +5122,7 @@ fix_bit_operand (rtx *operands, enum rtx_code code)\n     {\n       /* OK to have a memory dest.  */\n       if (GET_CODE (operands[0]) == MEM\n-\t  && !OK_FOR_U (operands[0]))\n+\t  && !satisfies_constraint_U (operands[0]))\n \t{\n \t  rtx mem = gen_rtx_MEM (GET_MODE (operands[0]),\n \t\t\t\t copy_to_mode_reg (Pmode,\n@@ -5196,7 +5132,7 @@ fix_bit_operand (rtx *operands, enum rtx_code code)\n \t}\n \n       if (GET_CODE (operands[1]) == MEM\n-\t  && !OK_FOR_U (operands[1]))\n+\t  && !satisfies_constraint_U (operands[1]))\n \t{\n \t  rtx mem = gen_rtx_MEM (GET_MODE (operands[1]),\n \t\t\t\t copy_to_mode_reg (Pmode,"}, {"sha": "c135183afdb2facfb382c7497078f703dc772f53", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 0, "deletions": 186, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80", "patch": "@@ -357,76 +357,6 @@ enum reg_class {\n #define INDEX_REG_CLASS (TARGET_H8300SX ? GENERAL_REGS : NO_REGS)\n #define BASE_REG_CLASS  GENERAL_REGS\n \n-/* Get reg_class from a letter such as appears in the machine description.\n-\n-   'a' is the MAC register.  */\n-\n-#define REG_CLASS_FROM_LETTER(C) (h8300_reg_class_from_letter (C))\n-\n-/* The letters I, J, K, L, M, N, O, P in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.  */\n-\n-#define CONST_OK_FOR_I(VALUE) ((VALUE) == 0)\n-#define CONST_OK_FOR_J(VALUE) (((VALUE) & 0xff) == 0)\n-#define CONST_OK_FOR_L(VALUE)\t\t\t\t\\\n-  (TARGET_H8300H || TARGET_H8300S\t\t\t\\\n-   ? (VALUE) == 1 || (VALUE) == 2 || (VALUE) == 4\t\\\n-   : (VALUE) == 1 || (VALUE) == 2)\n-#define CONST_OK_FOR_M(VALUE)\t\t\t\t\\\n-  ((VALUE) == 1 || (VALUE) == 2)\n-#define CONST_OK_FOR_N(VALUE)\t\t\t\t\\\n-  (TARGET_H8300H || TARGET_H8300S\t\t\t\\\n-   ? (VALUE) == -1 || (VALUE) == -2 || (VALUE) == -4\t\\\n-   : (VALUE) == -1 || (VALUE) == -2)\n-#define CONST_OK_FOR_O(VALUE)\t\t\t\t\\\n-  ((VALUE) == -1 || (VALUE) == -2)\n-\n-/* Multi-letter constraints for constant are always started with P\n-   (just because it was the only letter in the range left.  New\n-   constraints for constants should be added here.  */\n-#define CONST_OK_FOR_Ppositive(VALUE, NBITS)\t\t\\\n-  ((VALUE) > 0 && (VALUE) < (1 << (NBITS)))\n-#define CONST_OK_FOR_Pnegative(VALUE, NBITS)\t\t\\\n-  ((VALUE) < 0 && (VALUE) > -(1 << (NBITS)))\n-#define CONST_OK_FOR_P(VALUE, STR) \\\n-  ((STR)[1] >= '1' && (STR)[1] <= '9' && (STR)[2] == '<' \t\\\n-   ? (((STR)[3] == '0' || ((STR)[3] == 'X' && TARGET_H8300SX))\t\\\n-      && CONST_OK_FOR_Pnegative ((VALUE), (STR)[1] - '0'))\t\\\n-   : ((STR)[1] >= '1' && (STR)[1] <= '9' && (STR)[2] == '>')\t\\\n-   ? (((STR)[3] == '0' || ((STR)[3] == 'X' && TARGET_H8300SX))\t\\\n-      && CONST_OK_FOR_Ppositive ((VALUE), (STR)[1] - '0'))\t\\\n-   : 0)\n-#define CONSTRAINT_LEN_FOR_P(STR) \\\n-  ((((STR)[1] >= '1' && (STR)[1] <= '9')\t\t\t\\\n-    && ((STR)[2] == '<' || (STR)[2] == '>')\t\t\t\\\n-    && ((STR)[3] == 'X' || (STR)[3] == '0')) ? 4\t\t\\\n-   : 0)\n-\n-#define CONST_OK_FOR_CONSTRAINT_P(VALUE, C, STR)\t\\\n-  ((C) == 'P' ? CONST_OK_FOR_P ((VALUE), (STR))\t\t\\\n-   : CONST_OK_FOR_LETTER_P ((VALUE), (C)))\n-  \n-#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\\\n-  ((C) == 'I' ? CONST_OK_FOR_I (VALUE) :\t\\\n-   (C) == 'J' ? CONST_OK_FOR_J (VALUE) :\t\\\n-   (C) == 'L' ? CONST_OK_FOR_L (VALUE) :\t\\\n-   (C) == 'M' ? CONST_OK_FOR_M (VALUE) :\t\\\n-   (C) == 'N' ? CONST_OK_FOR_N (VALUE) :\t\\\n-   (C) == 'O' ? CONST_OK_FOR_O (VALUE) :\t\\\n-   0)\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.\n-\n-  `G' is a floating-point zero.  */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\\\n-  ((C) == 'G' ? (VALUE) == CONST0_RTX (SFmode)\t\\\n-   : 0)\n-\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n \n@@ -645,122 +575,6 @@ struct cum_arg\n \n #endif\n \n-/* Extra constraints.  */\n-\n-#define OK_FOR_Q(OP)\t\t\t\t\t\\\n-  (TARGET_H8300SX && memory_operand ((OP), VOIDmode))\n-\n-#define OK_FOR_R(OP)\t\t\t\t\t\\\n-  (GET_CODE (OP) == CONST_INT\t\t\t\t\\\n-   ? !h8300_shift_needs_scratch_p (INTVAL (OP), QImode)\t\\\n-   : 0)\n-\n-#define OK_FOR_S(OP)\t\t\t\t\t\\\n-  (GET_CODE (OP) == CONST_INT\t\t\t\t\\\n-   ? !h8300_shift_needs_scratch_p (INTVAL (OP), HImode)\t\\\n-   : 0)\n-\n-#define OK_FOR_T(OP)\t\t\t\t\t\\\n-  (GET_CODE (OP) == CONST_INT\t\t\t\t\\\n-   ? !h8300_shift_needs_scratch_p (INTVAL (OP), SImode)\t\\\n-   : 0)\n-\n-/* 'U' if valid for a bset destination;\n-   i.e. a register, register indirect, or the eightbit memory region\n-   (a SYMBOL_REF with an SYMBOL_REF_FLAG set).\n-\n-   On the H8S 'U' can also be a 16bit or 32bit absolute.  */\n-#define OK_FOR_U(OP)\t\t\t\t\t\t\t\\\n-  ((GET_CODE (OP) == REG && REG_OK_FOR_BASE_P (OP))\t\t\t\\\n-   || (GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG\t\t\\\n-       && REG_OK_FOR_BASE_P (XEXP (OP, 0)))\t\t\t\t\\\n-   || (GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == SYMBOL_REF\t\\\n-       && TARGET_H8300S)\t\t\t\t\t\t\\\n-   || (GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == CONST\t\t\\\n-       && GET_CODE (XEXP (XEXP (OP, 0), 0)) == PLUS\t\t\t\\\n-       && GET_CODE (XEXP (XEXP (XEXP (OP, 0), 0), 0)) == SYMBOL_REF\t\\\n-       && GET_CODE (XEXP (XEXP (XEXP (OP, 0), 0), 1)) == CONST_INT\t\\\n-       && (TARGET_H8300S\t\t\t\t\t\t\\\n-\t   || SYMBOL_REF_FLAG (XEXP (XEXP (XEXP (OP, 0), 0), 0))))\t\\\n-   || (GET_CODE (OP) == MEM\t\t\t\t\t\t\\\n-       && h8300_eightbit_constant_address_p (XEXP (OP, 0)))\t\t\\\n-   || (GET_CODE (OP) == MEM && (TARGET_H8300S || TARGET_H8300SX)\t\\\n-       && GET_CODE (XEXP (OP, 0)) == CONST_INT))\n-\n-/* Multi-letter constraints starting with W are to be used for\n-   operands that require a memory operand, i.e,. that are never used\n-   along with register constraints (see EXTRA_MEMORY_CONSTRAINTS).  */\n-\n-#define OK_FOR_WU(OP)\t\t\t\t\t\\\n-  (GET_CODE (OP) == MEM && OK_FOR_U (OP))\n-\n-#define OK_FOR_W(OP, STR)\t\t\t\t\\\n-  ((STR)[1] == 'U' ? OK_FOR_WU (OP)\t\t\t\\\n-   : 0)\n-\n-#define CONSTRAINT_LEN_FOR_W(STR)\t\t\t\\\n-  ((STR)[1] == 'U' ? 2\t\t\t\t\t\\\n-   : 0)\n-\n-/* Multi-letter constraints starting with Y are to be used for operands\n-   that are constant immediates and have single 1 or 0 in their binary\n-   representation.  */\n-\n-#define OK_FOR_Y2(OP)                                   \\\n-  ((GET_CODE (OP) == CONST_INT) && (exact_log2 (INTVAL (OP) & 0xff) != -1))\n-\n-#define OK_FOR_Y0(OP)                                   \\\n-  ((GET_CODE (OP) == CONST_INT) && (exact_log2 (~INTVAL (OP) & 0xff) != -1))\n-\n-#define OK_FOR_Y(OP, STR)                               \\\n-  ((STR)[1] == '2' ? OK_FOR_Y2 (OP)                     \\\n-   : (STR)[1] == '0' ? OK_FOR_Y0 (OP)\t\\\n-   : 0)\n-\n-#define CONSTRAINT_LEN_FOR_Y(STR)\t\t\t\\\n-  ((STR)[1] == '2' ? 2                                  \\\n-   : (STR)[1] == '0' ? 2\t\t\\\n-   : 0)\n-\n-#define OK_FOR_Z(OP)\t\t\t\t\t\\\n-  (TARGET_H8300SX\t\t\t\t\t\\\n-   && GET_CODE (OP) == MEM\t\t\t\t\\\n-   && CONSTANT_P (XEXP ((OP), 0)))\n-\n-#define EXTRA_CONSTRAINT_STR(OP, C, STR)\t\\\n-  ((C) == 'Q' ? OK_FOR_Q (OP) :\t\t\t\\\n-   (C) == 'R' ? OK_FOR_R (OP) :\t\t\t\\\n-   (C) == 'S' ? OK_FOR_S (OP) :\t\t\t\\\n-   (C) == 'T' ? OK_FOR_T (OP) :\t\t\t\\\n-   (C) == 'U' ? OK_FOR_U (OP) :\t\t\t\\\n-   (C) == 'W' ? OK_FOR_W ((OP), (STR)) :\t\\\n-   (C) == 'Y' ? OK_FOR_Y ((OP), (STR)) :\t\\\n-   (C) == 'Z' ? OK_FOR_Z (OP) :\t\t\t\\\n-   0)\n-\n-#define CONSTRAINT_LEN(C, STR) \\\n-  ((C) == 'P' ? CONSTRAINT_LEN_FOR_P (STR)\t\\\n-   : (C) == 'W' ? CONSTRAINT_LEN_FOR_W (STR)\t\\\n-   : (C) == 'Y' ? CONSTRAINT_LEN_FOR_Y (STR)\t\\\n-   : DEFAULT_CONSTRAINT_LEN ((C), (STR)))\n-\n-/* Experiments suggest that it's better not add 'Q' or 'U' here.  No\n-   patterns need it for correctness (no patterns use 'Q' and 'U'\n-   without also providing a register alternative).  And defining it\n-   will mean that a spilled pseudo could be replaced by its frame\n-   location in several consecutive insns.\n-\n-   Instead, it seems to be better to force pseudos to be reloaded\n-   into registers and then use peepholes to recombine insns when\n-   beneficial.\n-\n-   Unfortunately, for WU (unlike plain U, that matches regs as well),\n-   we must require a memory address.  In fact, all multi-letter\n-   constraints started with W are supposed to have this property, so\n-   we just test for W here.  */\n-#define EXTRA_MEMORY_CONSTRAINT(C, STR) \\\n-  ((C) == 'W')\n-\n \f\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.  */"}, {"sha": "4797460610e5a04846b486c941bc9025646978a5", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80", "patch": "@@ -177,6 +177,7 @@\n \t      (const_int 14)))])\n \n (include \"predicates.md\")\n+(include \"constraints.md\")\n \f\n ;; ----------------------------------------------------------------------\n ;; MOVE INSTRUCTIONS\n@@ -995,7 +996,7 @@\n    btst\\\\t%Z1,%Y0\n    #\"\n   \"&& reload_completed\n-   && !OK_FOR_U (operands[0])\"\n+   && !satisfies_constraint_U (operands[0])\"\n   [(set (match_dup 2)\n \t(match_dup 0))\n    (parallel [(set (cc0) (compare (zero_extract:SI (match_dup 2)\n@@ -1065,7 +1066,7 @@\n    btst\\\\t%w1,%X0\n    #\"\n   \"&& reload_completed\n-   && !OK_FOR_U (operands[0])\"\n+   && !satisfies_constraint_U (operands[0])\"\n   [(set (match_dup 2)\n \t(match_dup 0))\n    (parallel [(set (cc0) (compare (zero_extract:SI (zero_extend:SI (match_dup 2))\n@@ -4867,9 +4868,9 @@\n \t\t (match_operand:HI 2 \"register_operand\" \"\")))]\n   \"REG_P (operands[0]) && REG_P (operands[2])\n    && REGNO (operands[0]) != REGNO (operands[2])\n-   && (CONST_OK_FOR_J (INTVAL (operands[1]))\n-       || CONST_OK_FOR_L (INTVAL (operands[1]))\n-       || CONST_OK_FOR_N (INTVAL (operands[1])))\"\n+   && (satisfies_constraint_J (operands[1])\n+       || satisfies_constraint_L (operands[1])\n+       || satisfies_constraint_N (operands[1]))\"\n   [(set (match_dup 0)\n \t(match_dup 2))\n    (set (match_dup 0)\n@@ -4897,8 +4898,8 @@\n   \"(TARGET_H8300H || TARGET_H8300S)\n    && REG_P (operands[0]) && REG_P (operands[2])\n    && REGNO (operands[0]) != REGNO (operands[2])\n-   && (CONST_OK_FOR_L (INTVAL (operands[1]))\n-       || CONST_OK_FOR_N (INTVAL (operands[1])))\"\n+   && (satisfies_constraint_L (operands[1])\n+       || satisfies_constraint_N (operands[1]))\"\n   [(set (match_dup 0)\n \t(match_dup 2))\n    (set (match_dup 0)\n@@ -4926,8 +4927,8 @@\n   \"(TARGET_H8300H || TARGET_H8300S)\n    && REG_P (operands[0]) && REG_P (operands[1])\n    && REGNO (operands[0]) != REGNO (operands[1])\n-   && !CONST_OK_FOR_L (INTVAL (operands[2]))\n-   && !CONST_OK_FOR_N (INTVAL (operands[2]))\n+   && !satisfies_constraint_L (operands[2])\n+   && !satisfies_constraint_N (operands[2])\n    && ((INTVAL (operands[2]) & 0xff) == INTVAL (operands[2])\n        || (INTVAL (operands[2]) & 0xff00) == INTVAL (operands[2])\n        || INTVAL (operands[2]) == 0xffff"}, {"sha": "75714b328ac7519c6fb8254bff828d50c16a5b53", "filename": "gcc/config/h8300/predicates.md", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80/gcc%2Fconfig%2Fh8300%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80/gcc%2Fconfig%2Fh8300%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fpredicates.md?ref=ceaaaeabf66c30a14b70f2d3a86faeb9b9f68a80", "patch": "@@ -326,7 +326,7 @@\n {\n   /* We can accept any nonimmediate operand, except that MEM operands must\n      be limited to those that use addresses valid for the 'U' constraint.  */\n-  if (!nonimmediate_operand (op, mode) && !OK_FOR_U (op))\n+  if (!nonimmediate_operand (op, mode) && !satisfies_constraint_U (op))\n     return 0;\n \n   /* H8SX accepts pretty much anything here.  */\n@@ -344,7 +344,7 @@\n   if (GET_CODE (op) == SUBREG)\n     return 1;\n   return (GET_CODE (op) == MEM\n-\t  && OK_FOR_U (op));\n+\t  && satisfies_constraint_U (op));\n })\n \n ;; Return nonzero if OP is a MEM suitable for bit manipulation insns.\n@@ -353,7 +353,7 @@\n   (match_code \"mem\")\n {\n   return (GET_CODE (op) == MEM\n-\t  && OK_FOR_U (op));\n+\t  && satisfies_constraint_U (op));\n })\n \n ;; Return nonzero if OP is indirect register or constant memory\n@@ -416,12 +416,9 @@\n ;; Return nonzero if X is a constant suitable for inc/dec.\n \n (define_predicate \"incdec_operand\"\n-  (match_code \"const_int\")\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && (CONST_OK_FOR_M (INTVAL (op))\n-\t      || CONST_OK_FOR_O (INTVAL (op))));\n-})\n+  (and (match_code \"const_int\")\n+       (ior (match_test \"satisfies_constraint_M (op)\")\n+\t    (match_test \"satisfies_constraint_O (op)\"))))\n \n ;; Recognize valid operators for bit instructions.\n "}]}