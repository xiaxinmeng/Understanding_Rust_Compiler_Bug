{"sha": "a4b07e7ff898a61497d248c67d6540cd7067305b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTRiMDdlN2ZmODk4YTYxNDk3ZDI0OGM2N2Q2NTQwY2Q3MDY3MzA1Yg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-08-08T19:09:11Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-08-08T19:09:11Z"}, "message": "sibcall.c (return_value_pseudo): New static variable.\n\n\t* sibcall.c (return_value_pseudo): New static variable.\n\t(skip_copy_to_return_value): Handle return_value_pseudo.\n\t(call_ends_block_p): Ensure that return_value_pseudo is set.\n\t(optimize_sibling_and_tail_recursive_call): Discover the\n\tload of pseudo return value in alternate exit block.\n\nFrom-SVN: r44723", "tree": {"sha": "263e7633597badb488abf936cf6ada358d5c78e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/263e7633597badb488abf936cf6ada358d5c78e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a4b07e7ff898a61497d248c67d6540cd7067305b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4b07e7ff898a61497d248c67d6540cd7067305b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a4b07e7ff898a61497d248c67d6540cd7067305b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a4b07e7ff898a61497d248c67d6540cd7067305b/comments", "author": null, "committer": null, "parents": [{"sha": "9d98f8f9c4bea7b6ddcc1cb935e3b17d498b4beb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d98f8f9c4bea7b6ddcc1cb935e3b17d498b4beb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d98f8f9c4bea7b6ddcc1cb935e3b17d498b4beb"}], "stats": {"total": 48, "additions": 47, "deletions": 1}, "files": [{"sha": "66fb7a4b29caa22778c439148a1048b66a36d4ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4b07e7ff898a61497d248c67d6540cd7067305b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4b07e7ff898a61497d248c67d6540cd7067305b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a4b07e7ff898a61497d248c67d6540cd7067305b", "patch": "@@ -1,3 +1,11 @@\n+Wed Aug  8 21:08:14 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* sibcall.c (return_value_pseudo): New static variable.\n+\t(skip_copy_to_return_value): Handle return_value_pseudo.\n+\t(call_ends_block_p): Ensure that return_value_pseudo is set.\n+\t(optimize_sibling_and_tail_recursive_call): Discover the\n+\tload of pseudo return value in alternate exit block.\n+\n Wed Aug  8 21:06:43 CEST 2001  Jan Hubicka  <jh@suse.cz>\n \n \t* calls.c (ECF_ALWAYS_RETURN): New constant."}, {"sha": "91cc7485831ffe052acd81e082f3a4bacccbc56c", "filename": "gcc/sibcall.c", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a4b07e7ff898a61497d248c67d6540cd7067305b/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a4b07e7ff898a61497d248c67d6540cd7067305b/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=a4b07e7ff898a61497d248c67d6540cd7067305b", "patch": "@@ -32,6 +32,11 @@ Boston, MA 02111-1307, USA.  */\n #include \"output.h\"\n #include \"except.h\"\n \n+/* In case alternate_exit_block contains copy from pseudo, to return value,\n+   record the pseudo here.  In such case the pseudo must be set to function\n+   return in the sibcall sequence.  */\n+static rtx return_value_pseudo;\n+\n static int identify_call_return_value\tPARAMS ((rtx, rtx *, rtx *));\n static rtx skip_copy_to_return_value\tPARAMS ((rtx));\n static rtx skip_use_of_return_value\tPARAMS ((rtx, enum rtx_code));\n@@ -152,6 +157,13 @@ skip_copy_to_return_value (orig_insn)\n   if (! set)\n     return orig_insn;\n \n+  if (return_value_pseudo)\n+    {\n+      if (SET_DEST (set) == return_value_pseudo)\n+        return insn;\n+      return orig_insn;\n+    }\n+\n   /* The destination must be the same as the called function's return\n      value to ensure that any return value is put in the same place by the\n      current function and the function we're calling. \n@@ -323,6 +335,7 @@ call_ends_block_p (insn, end)\n      rtx insn;\n      rtx end;\n {\n+  rtx new_insn;\n   /* END might be a note, so get the last nonnote insn of the block.  */\n   end = next_nonnote_insn (PREV_INSN (end));\n \n@@ -333,7 +346,15 @@ call_ends_block_p (insn, end)\n   /* Skip over copying from the call's return value pseudo into\n      this function's hard return register and if that's the end\n      of the block, we're OK.  */\n-  insn = skip_copy_to_return_value (insn);\n+  new_insn = skip_copy_to_return_value (insn);\n+\n+  /* In case we return value in pseudo, we must set the pseudo to\n+     return value of called function, otherwise we are returning\n+     something else.  */\n+  if (return_value_pseudo && insn == new_insn)\n+    return 0;\n+  insn = new_insn;\n+\n   if (insn == end)\n     return 1;\n \n@@ -575,6 +596,8 @@ optimize_sibling_and_tail_recursive_calls ()\n   if (n_basic_blocks == 0)\n     return;\n \n+  return_value_pseudo = NULL_RTX;\n+\n   /* Find the exit block.\n \n      It is possible that we have blocks which can reach the exit block\n@@ -595,6 +618,7 @@ optimize_sibling_and_tail_recursive_calls ()\n \t   insn;\n \t   insn = NEXT_INSN (insn))\n \t{\n+\t  rtx set;\n \t  /* This should only happen once, at the start of this block.  */\n \t  if (GET_CODE (insn) == CODE_LABEL)\n \t    continue;\n@@ -606,6 +630,18 @@ optimize_sibling_and_tail_recursive_calls ()\n \t      && GET_CODE (PATTERN (insn)) == USE)\n \t    continue;\n \n+\t  /* Exit block also may contain copy from pseudo containing\n+\t     return value to hard register.  */\n+\t  if (GET_CODE (insn) == INSN\n+\t      && (set = single_set (insn))\n+\t      && SET_DEST (set) == current_function_return_rtx\n+\t      && REG_P (SET_SRC (set))\n+\t      && !return_value_pseudo)\n+\t    {\n+\t      return_value_pseudo = SET_SRC (set);\n+\t      continue;\n+\t    }\n+\n \t  break;\n \t}\n \n@@ -614,6 +650,8 @@ optimize_sibling_and_tail_recursive_calls ()\n \t valid alternate exit block.  */\n       if (insn == NULL)\n \talternate_exit = e->src;\n+      else\n+\treturn_value_pseudo = NULL;\n     }\n \n   /* If the function uses ADDRESSOF, we can't (easily) determine"}]}