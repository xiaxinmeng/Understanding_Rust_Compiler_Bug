{"sha": "76abd4c674a0278f0d75f7bb635f89bf17c3b91a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZhYmQ0YzY3NGEwMjc4ZjBkNzVmN2JiNjM1Zjg5YmYxN2MzYjkxYQ==", "commit": {"author": {"name": "Josef Zlomek", "email": "zlomekj@suse.cz", "date": "2003-05-12T05:16:55Z"}, "committer": {"name": "Josef Zlomek", "email": "zlomek@gcc.gnu.org", "date": "2003-05-12T05:16:55Z"}, "message": "alloc-pool.h (ALLOC_POOL_ID_TYPE): New type.\n\n\t* alloc-pool.h (ALLOC_POOL_ID_TYPE): New type.\n\t(struct alloc_pool_def): New element 'id'.\n\t* alloc-pool.c (fancy_abort): Extern function prototype.\n\t(abort): Macro which uses fancy_abort.\n\t(struct allocation_object_def): New structure.\n\t(ALLOCATION_OBJECT_PTR_FROM_USER_PTR): New macro.\n\t(USER_PTR_FROM_ALLOCATION_OBJECT_PTR): New macro.\n\t(last_id): New variable.\n\t(create_alloc_pool): Add the offset of u.data to size of element,\n\tincrease and use last_id.\n\t(free_alloc_pool): Do the checking only when ENABLE_CHECKING.\n\t(pool_alloc): Likewise. Set ID for elements.\n\t(pool_free): Check whether the PTR was allocated from POOL.\n\nFrom-SVN: r66711", "tree": {"sha": "29d4dc1fdfe78b727f24ca1dd297d829aa75218f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29d4dc1fdfe78b727f24ca1dd297d829aa75218f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76abd4c674a0278f0d75f7bb635f89bf17c3b91a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76abd4c674a0278f0d75f7bb635f89bf17c3b91a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76abd4c674a0278f0d75f7bb635f89bf17c3b91a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76abd4c674a0278f0d75f7bb635f89bf17c3b91a/comments", "author": null, "committer": null, "parents": [{"sha": "66ea6f4ccef91a1d6b86f7feaf524df51a15e36c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66ea6f4ccef91a1d6b86f7feaf524df51a15e36c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66ea6f4ccef91a1d6b86f7feaf524df51a15e36c"}], "stats": {"total": 117, "additions": 113, "deletions": 4}, "files": [{"sha": "59553a756890e11ce6cde0a288a4f43f2f410e2c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76abd4c674a0278f0d75f7bb635f89bf17c3b91a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76abd4c674a0278f0d75f7bb635f89bf17c3b91a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=76abd4c674a0278f0d75f7bb635f89bf17c3b91a", "patch": "@@ -1,3 +1,19 @@\n+2003-05-12  Josef Zlomek  <zlomekj@suse.cz>\n+\n+\t* alloc-pool.h (ALLOC_POOL_ID_TYPE): New type.\n+\t(struct alloc_pool_def): New element 'id'. \n+\t* alloc-pool.c (fancy_abort): Extern function prototype.\n+\t(abort): Macro which uses fancy_abort.\n+\t(struct allocation_object_def): New structure.\n+\t(ALLOCATION_OBJECT_PTR_FROM_USER_PTR): New macro.\n+\t(USER_PTR_FROM_ALLOCATION_OBJECT_PTR): New macro.\n+\t(last_id): New variable.\n+\t(create_alloc_pool): Add the offset of u.data to size of element,\n+\tincrease and use last_id.\n+\t(free_alloc_pool): Do the checking only when ENABLE_CHECKING.\n+\t(pool_alloc): Likewise. Set ID for elements.\n+\t(pool_free): Check whether the PTR was allocated from POOL.\n+\n 2003-05-11  Richard Henderson  <rth@redhat.com>\n \n \tPR c/10675"}, {"sha": "cb25b9ef061ca7e5212078a71068e2afb4d98748", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 89, "deletions": 2, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76abd4c674a0278f0d75f7bb635f89bf17c3b91a/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76abd4c674a0278f0d75f7bb635f89bf17c3b91a/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=76abd4c674a0278f0d75f7bb635f89bf17c3b91a", "patch": "@@ -1,5 +1,6 @@\n /* Functions to support a pool of allocatable objects.\n-   Copyright (C) 1987, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1997, 1998, 1999, 2000, 2001, 2003\n+   Free Software Foundation, Inc.\n    Contributed by Daniel Berlin <dan@cgsoftware.com>\n \n This file is part of GCC.\n@@ -23,9 +24,56 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"system.h\"\n #include \"alloc-pool.h\"\n \n+/* Redefine abort to report an internal error w/o coredump, and\n+   reporting the location of the error in the source file.  This logic\n+   is duplicated in rtl.h and tree.h because every file that needs the\n+   special abort includes one or both.  toplev.h gets too few files,\n+   system.h gets too many.  */\n+\n+extern void fancy_abort PARAMS ((const char *, int, const char *))\n+    ATTRIBUTE_NORETURN;\n+#define abort() fancy_abort (__FILE__, __LINE__, __FUNCTION__)\n+\n #define align_four(x) (((x+3) >> 2) << 2)\n #define align_eight(x) (((x+7) >> 3) << 3)\n \n+/* The internal allocation object.  */\n+typedef struct allocation_object_def\n+{\n+#ifdef ENABLE_CHECKING\n+  /* The ID of alloc pool which the object was allocated from.  */\n+  ALLOC_POOL_ID_TYPE id;\n+#endif\n+\n+  union\n+    {\n+      /* The data of the object.  */\n+      char data[1];\n+\n+      /* Because we want any type of data to be well aligned after the ID,\n+\t the following elements are here.  They are never accessed so\n+\t the allocated object may be even smaller than this structure.  */\n+      char *align_p;\n+      double align_d;\n+      HOST_WIDEST_INT align_i;\n+#ifdef HAVE_LONG_DOUBLE\n+      long double align_ld;\n+#endif\n+    } u;\n+} allocation_object;\n+\n+/* Convert a pointer to allocation_object from a pointer to user data.  */\n+#define ALLOCATION_OBJECT_PTR_FROM_USER_PTR(X)\t\t\t\t\\\n+   ((allocation_object *) (((char *) (X))\t\t\t\t\\\n+\t\t\t   - offsetof (allocation_object, u.data)))\n+\n+/* Convert a pointer to user data from a pointer to allocation_object.  */\n+#define USER_PTR_FROM_ALLOCATION_OBJECT_PTR(X)\t\t\t\t\\\n+   ((void *) (((allocation_object *) (X))->u.data))\n+\n+/* Last used ID.  */\n+static ALLOC_POOL_ID_TYPE last_id;\n+\n /* Create a pool of things of size SIZE, with NUM in each block we\n    allocate.  */\n \n@@ -48,6 +96,11 @@ create_alloc_pool (name, size, num)\n   /* Now align the size to a multiple of 4.  */\n   size = align_four (size);\n \n+#ifdef ENABLE_CHECKING\n+  /* Add the aligned size of ID.  */\n+  size += offsetof (allocation_object, u.data);\n+#endif\n+\n   /* Um, we can't really allocate 0 elements per block.  */\n   if (num == 0)\n     abort ();\n@@ -73,6 +126,16 @@ create_alloc_pool (name, size, num)\n   pool->blocks_allocated = 0;\n   pool->block_list = NULL;\n \n+#ifdef ENABLE_CHECKING\n+  /* Increase the last used ID and use it for this pool.\n+     ID == 0 is used for free elements of pool so skip it.  */\n+  last_id++;\n+  if (last_id == 0)\n+    last_id++;\n+\n+  pool->id = last_id;\n+#endif\n+\n   return (pool);\n }\n \n@@ -83,8 +146,10 @@ free_alloc_pool (pool)\n {\n   alloc_pool_list block, next_block;\n \n+#ifdef ENABLE_CHECKING\n   if (!pool)\n     abort ();\n+#endif\n \n   /* Free each block allocated to the pool.  */\n   for (block = pool->block_list; block != NULL; block = next_block)\n@@ -105,8 +170,10 @@ pool_alloc (pool)\n   alloc_pool_list header;\n   char *block;\n \n+#ifdef ENABLE_CHECKING\n   if (!pool)\n     abort ();\n+#endif\n \n   /* If there are no more free elements, make some more!.  */\n   if (!pool->free_list)\n@@ -126,7 +193,11 @@ pool_alloc (pool)\n       /* Now put the actual block pieces onto the free list.  */\n       for (i = 0; i < pool->elts_per_block; i++, block += pool->elt_size)\n       {\n-        header = (alloc_pool_list) block;\n+#ifdef ENABLE_CHECKING\n+\t/* Mark the element to be free.  */\n+\t((allocation_object *) block)->id = 0;\n+#endif\n+        header = (alloc_pool_list) USER_PTR_FROM_ALLOCATION_OBJECT_PTR (block);\n         header->next = pool->free_list;\n         pool->free_list = header;\n       }\n@@ -141,6 +212,12 @@ pool_alloc (pool)\n   header = pool->free_list;\n   pool->free_list = header->next;\n   pool->elts_free--;\n+\n+#ifdef ENABLE_CHECKING\n+  /* Set the ID for element.  */\n+  ALLOCATION_OBJECT_PTR_FROM_USER_PTR (header)->id = pool->id;\n+#endif\n+\n   return ((void *) header);\n }\n \n@@ -152,12 +229,22 @@ pool_free (pool, ptr)\n {\n   alloc_pool_list header;\n \n+#ifdef ENABLE_CHECKING\n   if (!ptr)\n     abort ();\n \n+  /* Check whether the PTR was allocated from POOL.  */\n+  if (pool->id != ALLOCATION_OBJECT_PTR_FROM_USER_PTR (ptr)->id)\n+    abort ();\n+\n+  /* Mark the element to be free.  */\n+  ALLOCATION_OBJECT_PTR_FROM_USER_PTR (ptr)->id = 0;\n+#else\n   /* Check if we free more than we allocated, which is Bad (TM).  */\n   if (pool->elts_free + 1 > pool->elts_allocated)\n     abort ();\n+#endif\n+\n   header = (alloc_pool_list) ptr;\n   header->next = pool->free_list;\n   pool->free_list = header;"}, {"sha": "0310caf0156eb58a37bd184410dcb2c859b84b90", "filename": "gcc/alloc-pool.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76abd4c674a0278f0d75f7bb635f89bf17c3b91a/gcc%2Falloc-pool.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76abd4c674a0278f0d75f7bb635f89bf17c3b91a/gcc%2Falloc-pool.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.h?ref=76abd4c674a0278f0d75f7bb635f89bf17c3b91a", "patch": "@@ -1,7 +1,8 @@\n-\n /* Functions to support a pool of allocatable objects\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2003\n+   Free Software Foundation, Inc.\n    Contributed by Daniel Berlin <dan@cgsoftware.com>\n+\n This file is part of GCC.\n \n GCC is free software; you can redistribute it and/or modify\n@@ -21,6 +22,8 @@ Boston, MA 02111-1307, USA.  */\n #ifndef ALLOC_POOL_H\n #define ALLOC_POOL_H\n \n+typedef unsigned long ALLOC_POOL_ID_TYPE;\n+\n typedef struct alloc_pool_list_def\n {\n   struct alloc_pool_list_def *next;\n@@ -30,6 +33,9 @@ typedef struct alloc_pool_list_def\n typedef struct alloc_pool_def\n {\n   char *name;\n+#ifdef ENABLE_CHECKING\n+  ALLOC_POOL_ID_TYPE id;\n+#endif\n   size_t elts_per_block;\n   alloc_pool_list free_list;\n   size_t elts_allocated;"}]}