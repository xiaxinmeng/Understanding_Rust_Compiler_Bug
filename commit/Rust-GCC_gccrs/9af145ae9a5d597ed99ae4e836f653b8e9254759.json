{"sha": "9af145ae9a5d597ed99ae4e836f653b8e9254759", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWFmMTQ1YWU5YTVkNTk3ZWQ5OWFlNGU4MzZmNjUzYjhlOTI1NDc1OQ==", "commit": {"author": {"name": "Marek Michalkiewicz", "email": "marekm@amelek.gda.pl", "date": "2002-06-01T23:33:47Z"}, "committer": {"name": "Marek Michalkiewicz", "email": "marekm@gcc.gnu.org", "date": "2002-06-01T23:33:47Z"}, "message": "Support for C++ constructors/destructors.\n\n\t* config/avr/avr.c (avr_output_function_epilogue): Jump to exit()\n\tinstead of looping if main() returns.\n\t(asm_file_start): Output global symbols that cause .data and .bss\n\tinitialization code to be linked in, unconditionally for now.\n\t(avr_asm_out_ctor, avr_asm_out_dtor): New functions.\n\t* config/avr/avr.h (CTORS_SECTION_ASM_OP, DTORS_SECTION_ASM_OP): New.\n\t(TARGET_ASM_CONSTRUCTOR, TARGET_ASM_DESTRUCTOR): New.\n\t(LIBSTDCXX): New.\n\t* config/avr/libgcc.S (_exit): Split in .fini9 and .fini0 sections.\n\t(__tablejump__): New.\n\t(__do_copy_data, __do_clear_bss): New.\n\t(__do_global_ctors, __do_global_dtors): New.\n\t* config/avr/t-avr (LIB1ASMFUNCS): Add _copy_data, _clear_bss,\n\t_ctors, _dtors.\n\nFrom-SVN: r54156", "tree": {"sha": "aa46724eab46edd17324abbef5e7d558302464fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa46724eab46edd17324abbef5e7d558302464fb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9af145ae9a5d597ed99ae4e836f653b8e9254759", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9af145ae9a5d597ed99ae4e836f653b8e9254759", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9af145ae9a5d597ed99ae4e836f653b8e9254759", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9af145ae9a5d597ed99ae4e836f653b8e9254759/comments", "author": null, "committer": null, "parents": [{"sha": "0d66ad572b03eb9d8921c649ba6f4b0cfdf2e8b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d66ad572b03eb9d8921c649ba6f4b0cfdf2e8b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d66ad572b03eb9d8921c649ba6f4b0cfdf2e8b6"}], "stats": {"total": 201, "additions": 192, "deletions": 9}, "files": [{"sha": "391f5514edf75e4703a725c672d2b10aef4dd2d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af145ae9a5d597ed99ae4e836f653b8e9254759/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af145ae9a5d597ed99ae4e836f653b8e9254759/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9af145ae9a5d597ed99ae4e836f653b8e9254759", "patch": "@@ -1,3 +1,21 @@\n+2002-06-02  Marek Michalkiewicz  <marekm@amelek.gda.pl>\n+\n+\tSupport for C++ constructors/destructors.\n+\t* config/avr/avr.c (avr_output_function_epilogue): Jump to exit()\n+\tinstead of looping if main() returns.\n+\t(asm_file_start): Output global symbols that cause .data and .bss\n+\tinitialization code to be linked in, unconditionally for now.\n+\t(avr_asm_out_ctor, avr_asm_out_dtor): New functions.\n+\t* config/avr/avr.h (CTORS_SECTION_ASM_OP, DTORS_SECTION_ASM_OP): New.\n+\t(TARGET_ASM_CONSTRUCTOR, TARGET_ASM_DESTRUCTOR): New.\n+\t(LIBSTDCXX): New.\n+\t* config/avr/libgcc.S (_exit): Split in .fini9 and .fini0 sections.\n+\t(__tablejump__): New.\n+\t(__do_copy_data, __do_clear_bss): New.\n+\t(__do_global_ctors, __do_global_dtors): New.\n+\t* config/avr/t-avr (LIB1ASMFUNCS): Add _copy_data, _clear_bss,\n+\t_ctors, _dtors.\n+\n 2002-06-02  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* c4x/c4x.h (TARGET_CPU_CPP_BUILTINS): New."}, {"sha": "6176801811e3da617581e9889ea6905c6d67002e", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af145ae9a5d597ed99ae4e836f653b8e9254759/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af145ae9a5d597ed99ae4e836f653b8e9254759/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=9af145ae9a5d597ed99ae4e836f653b8e9254759", "patch": "@@ -67,6 +67,9 @@ static void   avr_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n static void   avr_unique_section PARAMS ((tree, int));\n static void   avr_encode_section_info PARAMS ((tree, int));\n \n+static void   avr_asm_out_ctor PARAMS ((rtx, int));\n+static void   avr_asm_out_dtor PARAMS ((rtx, int));\n+\n /* Allocate registers from r25 to r8 for parameters for function calls */\n #define FIRST_CUM_REG 26\n \n@@ -757,8 +760,18 @@ avr_output_function_epilogue (file, size)\n   fprintf (file, \"/* epilogue: frame size=%d */\\n\", size);\n   if (main_p)\n     {\n-      fprintf (file, \"__stop_progIi__:\\n\\trjmp __stop_progIi__\\n\");\n-      ++epilogue_size;\n+      /* Return value from main() is already in the correct registers\n+\t (r25:r24) as the exit() argument.  */\n+      if (AVR_MEGA)\n+\t{\n+\t  fputs (\"\\t\" AS1 (jmp,exit) \"\\n\", file);\n+\t  epilogue_size += 2;\n+\t}\n+      else\n+\t{\n+\t  fputs (\"\\t\" AS1 (rjmp,exit) \"\\n\", file);\n+\t  ++epilogue_size;\n+\t}\n     }\n   else if (minimize && (frame_pointer_needed || live_seq > 4))\n     {\n@@ -4814,7 +4827,13 @@ asm_file_start (file)\n   fputs (\"__tmp_reg__ = 0\\n\" \n \t \"__zero_reg__ = 1\\n\"\n \t \"_PC_ = 2\\n\", file);\n-  \n+\n+  /* FIXME: output these only if there is anything in the .data / .bss\n+     sections - some code size could be saved by not linking in the\n+     initialization code from libgcc if one or both sections are empty.  */\n+  fputs (\"\\t.global __do_copy_data\\n\", file);\n+  fputs (\"\\t.global __do_clear_bss\\n\", file);\n+\n   commands_in_file = 0;\n   commands_in_prologues = 0;\n   commands_in_epilogues = 0;\n@@ -5531,3 +5550,22 @@ avr_out_sbxx_branch (insn, operands)\n     return AS1 (rjmp,%3);\n   return \"\";\n }\n+\n+static void\n+avr_asm_out_ctor (symbol, priority)\n+     rtx symbol;\n+     int priority;\n+{\n+  fputs (\"\\t.global __do_global_ctors\\n\", asm_out_file);\n+  default_ctor_section_asm_out_constructor (symbol, priority);\n+}\n+\n+static void\n+avr_asm_out_dtor (symbol, priority)\n+     rtx symbol;\n+     int priority;\n+{\n+  fputs (\"\\t.global __do_global_dtors\\n\", asm_out_file);\n+  default_dtor_section_asm_out_destructor (symbol, priority);\n+}\n+"}, {"sha": "d26bafdf98ec702076f3667b7ace14c223e86b7e", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af145ae9a5d597ed99ae4e836f653b8e9254759/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af145ae9a5d597ed99ae4e836f653b8e9254759/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=9af145ae9a5d597ed99ae4e836f653b8e9254759", "patch": "@@ -1728,6 +1728,24 @@ do {\t\t\t\t\t\t\t\t\t    \\\n    `-fno-common' is passed, otherwise `ASM_OUTPUT_COMMON' will be\n    used.  */\n \n+/* Define the pseudo-ops used to switch to the .ctors and .dtors sections.\n+   There are no shared libraries on this target, and these sections are\n+   placed in the read-only program memory, so they are not writable.  */\n+\n+#undef CTORS_SECTION_ASM_OP\n+#define CTORS_SECTION_ASM_OP \"\\t.section .ctors,\\\"a\\\",@progbits\"\n+\n+#undef DTORS_SECTION_ASM_OP\n+#define DTORS_SECTION_ASM_OP \"\\t.section .dtors,\\\"a\\\",@progbits\"\n+\n+#define TARGET_ASM_CONSTRUCTOR avr_asm_out_ctor\n+/* If defined, a function that outputs assembler code to arrange to\n+   call the function referenced by SYMBOL at initialization time.  */\n+\n+#define TARGET_ASM_DESTRUCTOR avr_asm_out_dtor\n+/* This is like `TARGET_ASM_CONSTRUCTOR' but used for termination\n+   functions rather than initialization functions.  */\n+\n #define EXTRA_SECTIONS in_progmem\n /* A list of names for sections other than the standard two, which are\n    `in_text' and `in_data'.  You need not define this macro on a\n@@ -2588,6 +2606,9 @@ extern int avr_case_values_threshold;\n    If this macro is not defined, a default is provided that loads the\n    standard C library from the usual place.  See `gcc.c'.  */\n \n+#define LIBSTDCXX \"-lgcc\"\n+/* No libstdc++ for now.  Empty string doesn't work.  */\n+\n #define LIBGCC_SPEC \\\n   \"%{!mmcu=at90s1*:%{!mmcu=attiny1*:%{!mmcu=attiny28: -lgcc }}}\"\n /* Another C string constant that tells the GNU CC driver program how"}, {"sha": "8548a730e5403b61573d3d1f4046b18a452a8222", "filename": "gcc/config/avr/libgcc.S", "status": "modified", "additions": 107, "deletions": 5, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af145ae9a5d597ed99ae4e836f653b8e9254759/gcc%2Fconfig%2Favr%2Flibgcc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af145ae9a5d597ed99ae4e836f653b8e9254759/gcc%2Fconfig%2Favr%2Flibgcc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Flibgcc.S?ref=9af145ae9a5d597ed99ae4e836f653b8e9254759", "patch": "@@ -637,11 +637,19 @@ __epilogue_restores__:\n #endif /* defined (L_epilogue) */\n \n #ifdef L_exit\n-\t.weak\t_exit\n+\t.section .fini9,\"ax\",@progbits\n+\t.global _exit\n \t.func\t_exit\n _exit:\n-\trjmp\t_exit\n-.endfunc\n+\t.weak\texit\n+exit:\n+\n+\t/* Code from .fini8 ... .fini1 sections inserted by ld script.  */\n+\n+\t.section .fini0,\"ax\",@progbits\n+__stop_program:\n+\trjmp\t__stop_program\n+\t.endfunc\n #endif /* defined (L_exit) */\n \n #ifdef L_cleanup\n@@ -658,19 +666,113 @@ _cleanup:\n __tablejump2__:\n \tlsl\tr30\n \trol\tr31\n+\t.global __tablejump__\n+__tablejump__:\n #if defined (__AVR_ENHANCED__)\n \tlpm\t__tmp_reg__, Z+\n \tlpm\tr31, Z\n \tmov\tr30, __tmp_reg__\n \tijmp\n #else\n \tlpm\n+\tadiw\tr30, 1\n \tpush\tr0\n-\tinc\tr30\t; table is word aligned, no carry to high byte\n \tlpm\n \tpush\tr0\n \tret\n #endif\n-.endfunc\n+\t.endfunc\n #endif /* defined (L_tablejump) */\n \n+/* __do_copy_data is only necessary if there is anything in .data section.\n+   Does not use RAMPZ - crt*.o provides a replacement for >64K devices.  */\n+\n+#ifdef L_copy_data\n+\t.section .init4,\"ax\",@progbits\n+\t.global __do_copy_data\n+__do_copy_data:\n+\tldi\tr17, hi8(__data_end)\n+\tldi\tr26, lo8(__data_start)\n+\tldi\tr27, hi8(__data_start)\n+\tldi\tr30, lo8(__data_load_start)\n+\tldi\tr31, hi8(__data_load_start)\n+\trjmp\t.do_copy_data_start\n+.do_copy_data_loop:\n+#if defined (__AVR_ENHANCED__)\n+\tlpm\tr0, Z+\n+#else\n+\tlpm\n+\tadiw\tr30, 1\n+#endif\n+\tst\tX+, r0\n+.do_copy_data_start:\n+\tcpi\tr26, lo8(__data_end)\n+\tcpc\tr27, r17\n+\tbrne\t.do_copy_data_loop\n+#endif /* L_copy_data */\n+\n+/* __do_clear_bss is only necessary if there is anything in .bss section.  */\n+\n+#ifdef L_clear_bss\n+\t.section .init4,\"ax\",@progbits\n+\t.global __do_clear_bss\n+__do_clear_bss:\n+\tldi\tr17, hi8(__bss_end)\n+\tldi\tr26, lo8(__bss_start)\n+\tldi\tr27, hi8(__bss_start)\n+\trjmp\t.do_clear_bss_start\n+.do_clear_bss_loop:\n+\tst\tX+, __zero_reg__\n+.do_clear_bss_start:\n+\tcpi\tr26, lo8(__bss_end)\n+\tcpc\tr27, r17\n+\tbrne\t.do_clear_bss_loop\n+#endif /* L_clear_bss */\n+\n+/* __do_global_ctors and __do_global_dtors are only necessary\n+   if there are any constructors/destructors.  */\n+\n+#if defined (__AVR_MEGA__)\n+#define XCALL call\n+#else\n+#define XCALL rcall\n+#endif\n+\n+#ifdef L_ctors\n+\t.section .init6,\"ax\",@progbits\n+\t.global\t__do_global_ctors\n+__do_global_ctors:\n+\tldi\tr17, hi8(__ctors_start)\n+\tldi\tr28, lo8(__ctors_end)\n+\tldi\tr29, hi8(__ctors_end)\n+\trjmp\t.do_global_ctors_start\n+.do_global_ctors_loop:\n+\tsbiw\tr28, 2\n+\tmov_h\tr31, r29\n+\tmov_l\tr30, r28\n+\tXCALL\t__tablejump__\n+.do_global_ctors_start:\n+\tcpi\tr28, lo8(__ctors_start)\n+\tcpc\tr29, r17\n+\tbrne\t.do_global_ctors_loop\n+#endif /* L_ctors */\n+\n+#ifdef L_dtors\n+\t.section .fini6,\"ax\",@progbits\n+\t.global\t__do_global_dtors\n+__do_global_dtors:\n+\tldi\tr17, hi8(__dtors_end)\n+\tldi\tr28, lo8(__dtors_start)\n+\tldi\tr29, hi8(__dtors_start)\n+\trjmp\t.do_global_dtors_start\n+.do_global_dtors_loop:\n+\tmov_h\tr31, r29\n+\tmov_l\tr30, r28\n+\tXCALL\t__tablejump__\n+\tadiw\tr28, 2\n+.do_global_dtors_start:\n+\tcpi\tr28, lo8(__dtors_end)\n+\tcpc\tr29, r17\n+\tbrne\t.do_global_dtors_loop\n+#endif /* L_dtors */\n+"}, {"sha": "769085ba7d55b5d861680f68c2d92c95b1e0b068", "filename": "gcc/config/avr/t-avr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9af145ae9a5d597ed99ae4e836f653b8e9254759/gcc%2Fconfig%2Favr%2Ft-avr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9af145ae9a5d597ed99ae4e836f653b8e9254759/gcc%2Fconfig%2Favr%2Ft-avr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Ft-avr?ref=9af145ae9a5d597ed99ae4e836f653b8e9254759", "patch": "@@ -17,7 +17,11 @@ LIB1ASMFUNCS = \\\n \t_epilogue \\\n \t_exit \\\n \t_cleanup \\\n-\t_tablejump\n+\t_tablejump \\\n+\t_copy_data \\\n+\t_clear_bss \\\n+\t_ctors \\\n+\t_dtors\n \n # We do not have the DF type.\n # Most of the C functions in libgcc2 use almost all registers,"}]}