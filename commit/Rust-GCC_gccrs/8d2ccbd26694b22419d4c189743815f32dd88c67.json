{"sha": "8d2ccbd26694b22419d4c189743815f32dd88c67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQyY2NiZDI2Njk0YjIyNDE5ZDRjMTg5NzQzODE1ZjMyZGQ4OGM2Nw==", "commit": {"author": {"name": "Sebastian Pop", "email": "s.pop@samsung.com", "date": "2015-07-25T09:29:11Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-07-25T09:29:11Z"}, "message": "remove tree-browser\n\n\t* Makefile.in: Remove use of TREEBROWSER.\n\t* config.in: Regenerated.\n\t* configure: Regenerated.\n\t* configure.ac: Remove definition of TREEBROWSER.\n\t* tree-browser.c: Removed.\n\t* tree-browser.def: Removed.\n\nFrom-SVN: r226214", "tree": {"sha": "7b8dfb3c1829ac78f067e713428dfbaad0e827a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b8dfb3c1829ac78f067e713428dfbaad0e827a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d2ccbd26694b22419d4c189743815f32dd88c67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d2ccbd26694b22419d4c189743815f32dd88c67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d2ccbd26694b22419d4c189743815f32dd88c67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d2ccbd26694b22419d4c189743815f32dd88c67/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33df361a844c44f23ad435960e163ab1732b6d2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33df361a844c44f23ad435960e163ab1732b6d2a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33df361a844c44f23ad435960e163ab1732b6d2a"}], "stats": {"total": 1090, "additions": 15, "deletions": 1075}, "files": [{"sha": "f91b006deaa4552b87880da0b5d43f04ce911292", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2ccbd26694b22419d4c189743815f32dd88c67/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2ccbd26694b22419d4c189743815f32dd88c67/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d2ccbd26694b22419d4c189743815f32dd88c67", "patch": "@@ -1,3 +1,12 @@\n+2015-07-25  Sebastian Pop  <s.pop@samsung.com>\n+\n+\t* Makefile.in: Remove use of TREEBROWSER.\n+\t* config.in: Regenerated.\n+\t* configure: Regenerated.\n+\t* configure.ac: Remove definition of TREEBROWSER.\n+\t* tree-browser.c: Removed.\n+\t* tree-browser.def: Removed.\n+\n 2015-07-25  Sebastian Pop  <s.pop@samsung.com>\n \n \t* graphite-scop-detection.c: Include gimple-pretty-print.h."}, {"sha": "be259e86b2d2f6c5bfee2e56c424aa323d6d8a81", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2ccbd26694b22419d4c189743815f32dd88c67/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2ccbd26694b22419d4c189743815f32dd88c67/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8d2ccbd26694b22419d4c189743815f32dd88c67", "patch": "@@ -1525,7 +1525,7 @@ OBJS-libcommon-target = $(common_out_object_file) prefix.o params.o \\\n ALL_HOST_FRONTEND_OBJS = $(foreach v,$(CONFIG_LANGUAGES),$($(v)_OBJS))\n \n ALL_HOST_BACKEND_OBJS = $(GCC_OBJS) $(OBJS) $(OBJS-libcommon) \\\n-  $(OBJS-libcommon-target) @TREEBROWSER@ main.o c-family/cppspec.o \\\n+  $(OBJS-libcommon-target) main.o c-family/cppspec.o \\\n   $(COLLECT2_OBJS) $(EXTRA_GCC_OBJS) $(GCOV_OBJS) $(GCOV_DUMP_OBJS) \\\n   $(GCOV_TOOL_OBJS) $(GENGTYPE_OBJS) gcc-ar.o gcc-nm.o gcc-ranlib.o \\\n   lto-wrapper.o collect-utils.o\n@@ -1534,7 +1534,7 @@ ALL_HOST_BACKEND_OBJS = $(GCC_OBJS) $(OBJS) $(OBJS-libcommon) \\\n # compilation or not.\n ALL_HOST_OBJS = $(ALL_HOST_FRONTEND_OBJS) $(ALL_HOST_BACKEND_OBJS)\n \n-BACKEND = libbackend.a main.o @TREEBROWSER@ libcommon-target.a libcommon.a \\\n+BACKEND = libbackend.a main.o libcommon-target.a libcommon.a \\\n \t$(CPPLIB) $(LIBDECNUMBER)\n \n # This is defined to \"yes\" if Tree checking is enabled, which roughly means"}, {"sha": "541963a727a23eb1f598263a146760c77e4520bb", "filename": "gcc/config.in", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2ccbd26694b22419d4c189743815f32dd88c67/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2ccbd26694b22419d4c189743815f32dd88c67/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=8d2ccbd26694b22419d4c189743815f32dd88c67", "patch": "@@ -194,8 +194,7 @@\n \n /* Define if you want all operations on trees (the basic data structure of the\n    front ends) to be checked for dynamic type safety at runtime. This is\n-   moderately expensive. The tree browser debugging routines will also be\n-   enabled by this option. */\n+   moderately expensive. */\n #ifndef USED_FOR_TARGET\n #undef ENABLE_TREE_CHECKING\n #endif"}, {"sha": "c8928d821b01441a1cb9987f830264e2b84fcd0f", "filename": "gcc/configure", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2ccbd26694b22419d4c189743815f32dd88c67/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2ccbd26694b22419d4c189743815f32dd88c67/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=8d2ccbd26694b22419d4c189743815f32dd88c67", "patch": "@@ -781,7 +781,6 @@ valgrind_command\n valgrind_path_defines\n valgrind_path\n TREECHECKING\n-TREEBROWSER\n nocommon_flag\n noexception_flags\n warn_cxxflags\n@@ -7085,7 +7084,6 @@ if test x$ac_tree_checking != x ; then\n \n $as_echo \"#define ENABLE_TREE_CHECKING 1\" >>confdefs.h\n \n-  TREEBROWSER=tree-browser.o\n   TREECHECKING=yes\n fi\n if test x$ac_types_checking != x ; then\n@@ -7094,7 +7092,6 @@ $as_echo \"#define ENABLE_TYPES_CHECKING 1\" >>confdefs.h\n \n fi\n \n-\n if test x$ac_rtl_checking != x ; then\n \n $as_echo \"#define ENABLE_RTL_CHECKING 1\" >>confdefs.h\n@@ -18304,7 +18301,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 18307 \"configure\"\n+#line 18304 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -18410,7 +18407,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 18413 \"configure\"\n+#line 18410 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H"}, {"sha": "a192ad92129ac47403523723c8315c69fe497a80", "filename": "gcc/configure.ac", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d2ccbd26694b22419d4c189743815f32dd88c67/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d2ccbd26694b22419d4c189743815f32dd88c67/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=8d2ccbd26694b22419d4c189743815f32dd88c67", "patch": "@@ -569,10 +569,8 @@ if test x$ac_tree_checking != x ; then\n   AC_DEFINE(ENABLE_TREE_CHECKING, 1,\n [Define if you want all operations on trees (the basic data\n    structure of the front ends) to be checked for dynamic type safety\n-   at runtime.  This is moderately expensive.  The tree browser debugging\n-   routines will also be enabled by this option.\n+   at runtime.  This is moderately expensive.\n    ])\n-  TREEBROWSER=tree-browser.o\n   TREECHECKING=yes\n fi\n if test x$ac_types_checking != x ; then\n@@ -581,7 +579,6 @@ if test x$ac_types_checking != x ; then\n    This is cheap.\n    ])\n fi\n-AC_SUBST(TREEBROWSER)\n AC_SUBST(TREECHECKING)\n if test x$ac_rtl_checking != x ; then\n   AC_DEFINE(ENABLE_RTL_CHECKING, 1,"}, {"sha": "a73131d6b6d3cbf1526f42a1c3f6bbc3f7ce603a", "filename": "gcc/tree-browser.c", "status": "removed", "additions": 0, "deletions": 965, "changes": 965, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33df361a844c44f23ad435960e163ab1732b6d2a/gcc%2Ftree-browser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33df361a844c44f23ad435960e163ab1732b6d2a/gcc%2Ftree-browser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-browser.c?ref=33df361a844c44f23ad435960e163ab1732b6d2a", "patch": "@@ -1,965 +0,0 @@\n-/* Tree browser.\n-   Copyright (C) 2002-2015 Free Software Foundation, Inc.\n-   Contributed by Sebastian Pop <s.pop@laposte.net>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"alias.h\"\n-#include \"tree.h\"\n-#include \"options.h\"\n-#include \"tree-pretty-print.h\"\n-#include \"print-tree.h\"\n-\n-#define TB_OUT_FILE stdout\n-#define TB_IN_FILE stdin\n-#define TB_NIY fprintf (TB_OUT_FILE, \"Sorry this command is not yet implemented.\\n\")\n-#define TB_WF fprintf (TB_OUT_FILE, \"Warning, this command failed.\\n\")\n-\n-/* Structures for handling Tree Browser's commands.  */\n-#define DEFTBCODE(COMMAND, STRING, HELP)   COMMAND,\n-enum TB_Comm_code {\n-#include \"tree-browser.def\"\n-  TB_UNUSED_COMMAND\n-};\n-#undef DEFTBCODE\n-typedef enum TB_Comm_code TB_CODE;\n-\n-struct tb_command {\n-  const char *help_msg;\n-  const char *comm_text;\n-  size_t comm_len;\n-  TB_CODE comm_code;\n-};\n-\n-#define DEFTBCODE(code, str, help) { help, str, sizeof (str) - 1, code },\n-static const struct tb_command tb_commands[] =\n-{\n-#include \"tree-browser.def\"\n-};\n-#undef DEFTBCODE\n-\n-#define TB_COMMAND_LEN(N) (tb_commands[N].comm_len)\n-#define TB_COMMAND_TEXT(N) (tb_commands[N].comm_text)\n-#define TB_COMMAND_CODE(N) (tb_commands[N].comm_code)\n-#define TB_COMMAND_HELP(N) (tb_commands[N].help_msg)\n-\n-\n-/* Next structure is for parsing TREE_CODEs.  */\n-struct tb_tree_code {\n-  enum tree_code code;\n-  const char *code_string;\n-  size_t code_string_len;\n-};\n-\n-#define DEFTREECODE(SYM, STRING, TYPE, NARGS) { SYM, STRING, sizeof (STRING) - 1 },\n-#define END_OF_BASE_TREE_CODES \\\n-  { LAST_AND_UNUSED_TREE_CODE, \"@dummy\", sizeof (\"@dummy\") - 1 },\n-static const struct tb_tree_code tb_tree_codes[] =\n-{\n-#include \"all-tree.def\"\n-};\n-#undef DEFTREECODE\n-#undef END_OF_BASE_TREE_CODES\n-\n-#define TB_TREE_CODE(N) (tb_tree_codes[N].code)\n-#define TB_TREE_CODE_TEXT(N) (tb_tree_codes[N].code_string)\n-#define TB_TREE_CODE_LEN(N) (tb_tree_codes[N].code_string_len)\n-\n-\n-/* Function declarations.  */\n-\n-static long TB_getline (char **, long *, FILE *);\n-static TB_CODE TB_get_command (char *);\n-static enum tree_code TB_get_tree_code (char *);\n-static tree find_node_with_code (tree *, int *, void *);\n-static tree store_child_info (tree *, int *, void *);\n-static void TB_update_up (tree);\n-static tree TB_current_chain_node (tree);\n-static tree TB_prev_expr (tree);\n-static tree TB_next_expr (tree);\n-static tree TB_up_expr (tree);\n-static tree TB_first_in_bind (tree);\n-static tree TB_last_in_bind (tree);\n-static tree TB_history_prev (void);\n-\n-/* FIXME: To be declared in a .h file.  */\n-void browse_tree (tree);\n-\n-/* Hashtable helpers.  */\n-struct tree_upper_hasher : nofree_ptr_hash<tree_node>\n-{\n-  static inline bool equal (const value_type &, const compare_type &);\n-};\n-\n-inline bool\n-tree_upper_hasher::equal (const value_type &parent, const compare_type &node)\n-{\n-  if (parent == NULL || node == NULL)\n-    return 0;\n-\n-  if (EXPR_P (parent))\n-    {\n-      int n = TREE_OPERAND_LENGTH (parent);\n-      int i;\n-      for (i = 0; i < n; i++)\n-\tif (node == TREE_OPERAND (parent, i))\n-\t  return true;\n-    }\n-  return false;\n-}\n-\n-/* Static variables.  */\n-static hash_table<tree_upper_hasher> *TB_up_ht;\n-static vec<tree, va_gc> *TB_history_stack;\n-static int TB_verbose = 1;\n-\n-\n-/* Entry point in the Tree Browser.  */\n-\n-void\n-browse_tree (tree begin)\n-{\n-  tree head;\n-  TB_CODE tbc = TB_UNUSED_COMMAND;\n-  ssize_t rd;\n-  char *input = NULL;\n-  long input_size = 0;\n-\n-  fprintf (TB_OUT_FILE, \"\\nTree Browser\\n\");\n-\n-#define TB_SET_HEAD(N) do {                                           \\\n-  vec_safe_push (TB_history_stack, N);                                \\\n-  head = N;                                                           \\\n-  if (TB_verbose)                                                     \\\n-    if (head)                                                         \\\n-      {                                                               \\\n-\tprint_generic_expr (TB_OUT_FILE, head, 0);                    \\\n-\tfprintf (TB_OUT_FILE, \"\\n\");                                  \\\n-      }                                                               \\\n-} while (0)\n-\n-  TB_SET_HEAD (begin);\n-\n-  /* Store in a hashtable information about previous and upper statements.  */\n-  {\n-    TB_up_ht = new hash_table<tree_upper_hasher> (1023);\n-    TB_update_up (head);\n-  }\n-\n-  while (24)\n-    {\n-      fprintf (TB_OUT_FILE, \"TB> \");\n-      rd = TB_getline (&input, &input_size, TB_IN_FILE);\n-\n-      if (rd == -1)\n-\t/* EOF.  */\n-\tgoto ret;\n-\n-      if (rd != 1)\n-\t/* Get a new command.  Otherwise the user just pressed enter, and thus\n-\t   she expects the last command to be reexecuted.  */\n-\ttbc = TB_get_command (input);\n-\n-      switch (tbc)\n-\t{\n-\tcase TB_UPDATE_UP:\n-\t  TB_update_up (head);\n-\t  break;\n-\n-\tcase TB_MAX:\n-\t  if (head && (INTEGRAL_TYPE_P (head)\n-\t\t       || TREE_CODE (head) == REAL_TYPE\n-\t\t       || TREE_CODE (head) == FIXED_POINT_TYPE))\n-\t    TB_SET_HEAD (TYPE_MAX_VALUE (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_MIN:\n-\t  if (head && (INTEGRAL_TYPE_P (head)\n-\t\t       || TREE_CODE (head) == REAL_TYPE\n-\t\t       || TREE_CODE (head) == FIXED_POINT_TYPE))\n-\t    TB_SET_HEAD (TYPE_MIN_VALUE (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_ELT:\n-\t  if (head && TREE_CODE (head) == TREE_VEC)\n-\t    {\n-\t      /* This command takes another argument: the element number:\n-\t\t for example \"elt 1\".  */\n-\t      TB_NIY;\n-\t    }\n-\t  else if (head && TREE_CODE (head) == VECTOR_CST)\n-\t    {\n-\t      /* This command takes another argument: the element number:\n-                 for example \"elt 1\".  */\n-              TB_NIY;\n-\t    }\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_VALUE:\n-\t  if (head && TREE_CODE (head) == TREE_LIST)\n-\t    TB_SET_HEAD (TREE_VALUE (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_PURPOSE:\n-\t  if (head && TREE_CODE (head) == TREE_LIST)\n-\t    TB_SET_HEAD (TREE_PURPOSE (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_IMAG:\n-\t  if (head && TREE_CODE (head) == COMPLEX_CST)\n-\t    TB_SET_HEAD (TREE_IMAGPART (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_REAL:\n-\t  if (head && TREE_CODE (head) == COMPLEX_CST)\n-\t    TB_SET_HEAD (TREE_REALPART (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_BLOCK:\n-\t  if (head && TREE_CODE (head) == BIND_EXPR)\n-\t    TB_SET_HEAD (TREE_OPERAND (head, 2));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_SUBBLOCKS:\n-\t  if (head && TREE_CODE (head) == BLOCK)\n-\t    TB_SET_HEAD (BLOCK_SUBBLOCKS (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_SUPERCONTEXT:\n-\t  if (head && TREE_CODE (head) == BLOCK)\n-\t    TB_SET_HEAD (BLOCK_SUPERCONTEXT (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_VARS:\n-\t  if (head && TREE_CODE (head) == BLOCK)\n-\t    TB_SET_HEAD (BLOCK_VARS (head));\n-\t  else if (head && TREE_CODE (head) == BIND_EXPR)\n-\t    TB_SET_HEAD (TREE_OPERAND (head, 0));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_REFERENCE_TO_THIS:\n-\t  if (head && TYPE_P (head))\n-\t    TB_SET_HEAD (TYPE_REFERENCE_TO (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_POINTER_TO_THIS:\n-\t  if (head && TYPE_P (head))\n-\t    TB_SET_HEAD (TYPE_POINTER_TO (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_BASETYPE:\n-\t  if (head && TREE_CODE (head) == OFFSET_TYPE)\n-\t    TB_SET_HEAD (TYPE_OFFSET_BASETYPE (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_ARG_TYPES:\n-\t  if (head && (TREE_CODE (head) == FUNCTION_TYPE\n-\t\t       || TREE_CODE (head) == METHOD_TYPE))\n-\t    TB_SET_HEAD (TYPE_ARG_TYPES (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_METHOD_BASE_TYPE:\n-\t  if (head && (TREE_CODE (head) == FUNCTION_TYPE\n-\t\t       || TREE_CODE (head) == METHOD_TYPE)\n-\t      && TYPE_METHOD_BASETYPE (head))\n-\t    TB_SET_HEAD (TYPE_METHOD_BASETYPE (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_FIELDS:\n-\t  if (head && (TREE_CODE (head) == RECORD_TYPE\n-\t\t       || TREE_CODE (head) == UNION_TYPE\n-\t\t       || TREE_CODE (head) == QUAL_UNION_TYPE))\n-\t    TB_SET_HEAD (TYPE_FIELDS (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_DOMAIN:\n-\t  if (head && TREE_CODE (head) == ARRAY_TYPE)\n-\t    TB_SET_HEAD (TYPE_DOMAIN (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_VALUES:\n-\t  if (head && TREE_CODE (head) == ENUMERAL_TYPE)\n-\t    TB_SET_HEAD (TYPE_VALUES (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_ARG_TYPE:\n-\t  if (head && TREE_CODE (head) == PARM_DECL)\n-\t    TB_SET_HEAD (DECL_ARG_TYPE (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_INITIAL:\n-\t  if (head && DECL_P (head))\n-\t    TB_SET_HEAD (DECL_INITIAL (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_RESULT:\n-\t  if (head && DECL_P (head))\n-\t    TB_SET_HEAD (DECL_RESULT_FLD (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_ARGUMENTS:\n-\t  if (head && DECL_P (head))\n-\t    TB_SET_HEAD (DECL_ARGUMENTS (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_ABSTRACT_ORIGIN:\n-\t  if (head && DECL_P (head))\n-\t    TB_SET_HEAD (DECL_ABSTRACT_ORIGIN (head));\n-\t  else if (head && TREE_CODE (head) == BLOCK)\n-\t    TB_SET_HEAD (BLOCK_ABSTRACT_ORIGIN (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_ATTRIBUTES:\n-\t  if (head && DECL_P (head))\n-\t    TB_SET_HEAD (DECL_ATTRIBUTES (head));\n-\t  else if (head && TYPE_P (head))\n-\t    TB_SET_HEAD (TYPE_ATTRIBUTES (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_CONTEXT:\n-\t  if (head && DECL_P (head))\n-\t    TB_SET_HEAD (DECL_CONTEXT (head));\n-\t  else if (head && TYPE_P (head)\n-\t\t   && TYPE_CONTEXT (head))\n-\t    TB_SET_HEAD (TYPE_CONTEXT (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_OFFSET:\n-\t  if (head && TREE_CODE (head) == FIELD_DECL)\n-\t    TB_SET_HEAD (DECL_FIELD_OFFSET (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_BIT_OFFSET:\n-\t  if (head && TREE_CODE (head) == FIELD_DECL)\n-\t    TB_SET_HEAD (DECL_FIELD_BIT_OFFSET (head));\n-\t  else\n-\t    TB_WF;\n-          break;\n-\n-\tcase TB_UNIT_SIZE:\n-\t  if (head && DECL_P (head))\n-\t    TB_SET_HEAD (DECL_SIZE_UNIT (head));\n-\t  else if (head && TYPE_P (head))\n-\t    TB_SET_HEAD (TYPE_SIZE_UNIT (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_SIZE:\n-\t  if (head && DECL_P (head))\n-\t    TB_SET_HEAD (DECL_SIZE (head));\n-\t  else if (head && TYPE_P (head))\n-\t    TB_SET_HEAD (TYPE_SIZE (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_TYPE:\n-\t  if (head && TREE_TYPE (head))\n-\t    TB_SET_HEAD (TREE_TYPE (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_DECL_SAVED_TREE:\n-\t  if (head && TREE_CODE (head) == FUNCTION_DECL\n-\t      && DECL_SAVED_TREE (head))\n-\t    TB_SET_HEAD (DECL_SAVED_TREE (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_BODY:\n-\t  if (head && TREE_CODE (head) == BIND_EXPR)\n-\t    TB_SET_HEAD (TREE_OPERAND (head, 1));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_CHILD_0:\n-\t  if (head && EXPR_P (head) && TREE_OPERAND (head, 0))\n-\t    TB_SET_HEAD (TREE_OPERAND (head, 0));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_CHILD_1:\n-          if (head && EXPR_P (head) && TREE_OPERAND (head, 1))\n-\t    TB_SET_HEAD (TREE_OPERAND (head, 1));\n-\t  else\n-\t    TB_WF;\n-          break;\n-\n-\tcase TB_CHILD_2:\n-          if (head && EXPR_P (head) && TREE_OPERAND (head, 2))\n-\t    TB_SET_HEAD (TREE_OPERAND (head, 2));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_CHILD_3:\n-\t  if (head && EXPR_P (head) && TREE_OPERAND (head, 3))\n-\t    TB_SET_HEAD (TREE_OPERAND (head, 3));\n-\t  else\n-\t    TB_WF;\n-          break;\n-\n-\tcase TB_PRINT:\n-\t  if (head)\n-\t    debug_tree (head);\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_PRETTY_PRINT:\n-\t  if (head)\n-\t    {\n-\t      print_generic_stmt (TB_OUT_FILE, head, 0);\n-\t      fprintf (TB_OUT_FILE, \"\\n\");\n-\t    }\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_SEARCH_NAME:\n-\n-\t  break;\n-\n-\tcase TB_SEARCH_CODE:\n-\t  {\n-\t    enum tree_code code;\n-\t    char *arg_text;\n-\n-\t    arg_text = strchr (input, ' ');\n-\t    if (arg_text == NULL)\n-\t      {\n-\t\tfprintf (TB_OUT_FILE, \"First argument is missing.  This isn't a valid search command.  \\n\");\n-\t\tbreak;\n-\t      }\n-\t    code = TB_get_tree_code (arg_text + 1);\n-\n-\t    /* Search in the subtree a node with the given code.  */\n-\t    {\n-\t      tree res;\n-\n-\t      res = walk_tree (&head, find_node_with_code, &code, NULL);\n-\t      if (res == NULL_TREE)\n-\t\t{\n-\t\t  fprintf (TB_OUT_FILE, \"There's no node with this code (reachable via the walk_tree function from this node).\\n\");\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  fprintf (TB_OUT_FILE, \"Achoo!  I got this node in the tree.\\n\");\n-\t\t  TB_SET_HEAD (res);\n-\t\t}\n-\t    }\n-\t    break;\n-\t  }\n-\n-#define TB_MOVE_HEAD(FCT) do {       \\\n-  if (head)                          \\\n-    {                                \\\n-      tree t;                        \\\n-      t = FCT (head);                \\\n-      if (t)                         \\\n-        TB_SET_HEAD (t);             \\\n-      else                           \\\n-\tTB_WF;                       \\\n-    }                                \\\n-  else                               \\\n-    TB_WF;                           \\\n-} while (0)\n-\n-\tcase TB_FIRST:\n-\t  TB_MOVE_HEAD (TB_first_in_bind);\n-          break;\n-\n-        case TB_LAST:\n-          TB_MOVE_HEAD (TB_last_in_bind);\n-          break;\n-\n-\tcase TB_UP:\n-\t  TB_MOVE_HEAD (TB_up_expr);\n-\t  break;\n-\n-\tcase TB_PREV:\n-\t  TB_MOVE_HEAD (TB_prev_expr);\n-\t  break;\n-\n-\tcase TB_NEXT:\n-\t  TB_MOVE_HEAD (TB_next_expr);\n-\t  break;\n-\n-\tcase TB_HPREV:\n-\t  /* This command is a little bit special, since it deals with history\n-\t     stack.  For this reason it should keep the \"head = ...\" statement\n-\t     and not use TB_MOVE_HEAD.  */\n-\t  if (head)\n-\t    {\n-\t      tree t;\n-\t      t = TB_history_prev ();\n-\t      if (t)\n-\t\t{\n-\t\t  head = t;\n-\t\t  if (TB_verbose)\n-\t\t    {\n-\t\t      print_generic_expr (TB_OUT_FILE, head, 0);\n-\t\t      fprintf (TB_OUT_FILE, \"\\n\");\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\tTB_WF;\n-\t    }\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_CHAIN:\n-\t  /* Don't go further if it's the last node in this chain.  */\n-\t  if (head && TREE_CODE (head) == BLOCK)\n-\t    TB_SET_HEAD (BLOCK_CHAIN (head));\n-\t  else if (head && TREE_CHAIN (head))\n-\t    TB_SET_HEAD (TREE_CHAIN (head));\n-\t  else\n-\t    TB_WF;\n-\t  break;\n-\n-\tcase TB_FUN:\n-\t  /* Go up to the current function declaration.  */\n-\t  TB_SET_HEAD (current_function_decl);\n-\t  fprintf (TB_OUT_FILE, \"Current function declaration.\\n\");\n-\t  break;\n-\n-\tcase TB_HELP:\n-\t  /* Display a help message.  */\n-\t  {\n-\t    int i;\n-\t    fprintf (TB_OUT_FILE, \"Possible commands are:\\n\\n\");\n-\t    for (i = 0; i < TB_UNUSED_COMMAND; i++)\n-\t      {\n-\t\tfprintf (TB_OUT_FILE, \"%20s  -  %s\\n\", TB_COMMAND_TEXT (i), TB_COMMAND_HELP (i));\n-\t      }\n-\t  }\n-\t  break;\n-\n-\tcase TB_VERBOSE:\n-\t  if (TB_verbose == 0)\n-\t    {\n-\t      TB_verbose = 1;\n-\t      fprintf (TB_OUT_FILE, \"Verbose on.\\n\");\n-\t    }\n-\t  else\n-\t    {\n-\t      TB_verbose = 0;\n-\t      fprintf (TB_OUT_FILE, \"Verbose off.\\n\");\n-\t    }\n-\t  break;\n-\n-\tcase TB_EXIT:\n-\tcase TB_QUIT:\n-\t  /* Just exit from this function.  */\n-\t  goto ret;\n-\n-\tdefault:\n-\t  TB_NIY;\n-\t}\n-    }\n-\n- ret:;\n-  delete TB_up_ht;\n-  TB_up_ht = NULL;\n-  return;\n-}\n-\n-\n-/* Search the first node in this BIND_EXPR.  */\n-\n-static tree\n-TB_first_in_bind (tree node)\n-{\n-  tree t;\n-\n-  if (node == NULL_TREE)\n-    return NULL_TREE;\n-\n-  while ((t = TB_prev_expr (node)))\n-    node = t;\n-\n-  return node;\n-}\n-\n-/* Search the last node in this BIND_EXPR.  */\n-\n-static tree\n-TB_last_in_bind (tree node)\n-{\n-  tree t;\n-\n-  if (node == NULL_TREE)\n-    return NULL_TREE;\n-\n-  while ((t = TB_next_expr (node)))\n-    node = t;\n-\n-  return node;\n-}\n-\n-/* Search the parent expression for this node.  */\n-\n-static tree\n-TB_up_expr (tree node)\n-{\n-  tree res;\n-  if (node == NULL_TREE)\n-    return NULL_TREE;\n-\n-  res = TB_up_ht->find (node);\n-  return res;\n-}\n-\n-/* Search the previous expression in this BIND_EXPR.  */\n-\n-static tree\n-TB_prev_expr (tree node)\n-{\n-  node = TB_current_chain_node (node);\n-\n-  if (node == NULL_TREE)\n-    return NULL_TREE;\n-\n-  node = TB_up_expr (node);\n-  if (node && TREE_CODE (node) == COMPOUND_EXPR)\n-    return node;\n-  else\n-    return NULL_TREE;\n-}\n-\n-/* Search the next expression in this BIND_EXPR.  */\n-\n-static tree\n-TB_next_expr (tree node)\n-{\n-  node = TB_current_chain_node (node);\n-\n-  if (node == NULL_TREE)\n-    return NULL_TREE;\n-\n-  node = TREE_OPERAND (node, 1);\n-  return node;\n-}\n-\n-static tree\n-TB_current_chain_node (tree node)\n-{\n-  if (node == NULL_TREE)\n-    return NULL_TREE;\n-\n-  if (TREE_CODE (node) == COMPOUND_EXPR)\n-    return node;\n-\n-  node = TB_up_expr (node);\n-  if (node)\n-    {\n-      if (TREE_CODE (node) == COMPOUND_EXPR)\n-\treturn node;\n-\n-      node = TB_up_expr (node);\n-      if (TREE_CODE (node) == COMPOUND_EXPR)\n-\treturn node;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-/* For each node store in its children nodes that the current node is their\n-   parent.  This function is used by walk_tree.  */\n-\n-static tree\n-store_child_info (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n-\t\t  void *data ATTRIBUTE_UNUSED)\n-{\n-  tree node;\n-  tree_node **slot;\n-\n-  node = *tp;\n-\n-  /* 'node' is the parent of 'TREE_OPERAND (node, *)'.  */\n-  if (EXPR_P (node))\n-    {\n-      int n = TREE_OPERAND_LENGTH (node);\n-      int i;\n-      for (i = 0; i < n; i++)\n-\t{\n-\t  tree op = TREE_OPERAND (node, i);\n-\t  slot = TB_up_ht->find_slot (op, INSERT);\n-\t  *slot = node;\n-\t}\n-    }\n-\n-  /* Never stop walk_tree.  */\n-  return NULL_TREE;\n-}\n-\n-/* Update information about upper expressions in the hash table.  */\n-\n-static void\n-TB_update_up (tree node)\n-{\n-  while (node)\n-    {\n-      walk_tree (&node, store_child_info, NULL, NULL);\n-\n-      /* Walk function's body.  */\n-      if (TREE_CODE (node) == FUNCTION_DECL)\n-        if (DECL_SAVED_TREE (node))\n-          walk_tree (&DECL_SAVED_TREE (node), store_child_info, NULL, NULL);\n-\n-      /* Walk rest of the chain.  */\n-      node = TREE_CHAIN (node);\n-    }\n-  fprintf (TB_OUT_FILE, \"Up/prev expressions updated.\\n\");\n-}\n-\n-/* Parse the input string for determining the command the user asked for.  */\n-\n-static TB_CODE\n-TB_get_command (char *input)\n-{\n-  unsigned int mn, size_tok;\n-  int comp;\n-  char *space;\n-\n-  space = strchr (input, ' ');\n-  if (space != NULL)\n-    size_tok = strlen (input) - strlen (space);\n-  else\n-    size_tok = strlen (input) - 1;\n-\n-  for (mn = 0; mn < TB_UNUSED_COMMAND; mn++)\n-    {\n-      if (size_tok != TB_COMMAND_LEN (mn))\n-\tcontinue;\n-\n-      comp = memcmp (input, TB_COMMAND_TEXT (mn), TB_COMMAND_LEN (mn));\n-      if (comp == 0)\n-\t/* Here we just determined the command.  If this command takes\n-\t   an argument, then the argument is determined later.  */\n-\treturn TB_COMMAND_CODE (mn);\n-    }\n-\n-  /* Not a valid command.  */\n-  return TB_UNUSED_COMMAND;\n-}\n-\n-/* Parse the input string for determining the tree code.  */\n-\n-static enum tree_code\n-TB_get_tree_code (char *input)\n-{\n-  unsigned int mn, size_tok;\n-  int comp;\n-  char *space;\n-\n-  space = strchr (input, ' ');\n-  if (space != NULL)\n-    size_tok = strlen (input) - strlen (space);\n-  else\n-    size_tok = strlen (input) - 1;\n-\n-  for (mn = 0; mn < LAST_AND_UNUSED_TREE_CODE; mn++)\n-    {\n-      if (size_tok != TB_TREE_CODE_LEN (mn))\n-\tcontinue;\n-\n-      comp = memcmp (input, TB_TREE_CODE_TEXT (mn), TB_TREE_CODE_LEN (mn));\n-      if (comp == 0)\n-\t{\n-\t  fprintf (TB_OUT_FILE, \"%s\\n\", TB_TREE_CODE_TEXT (mn));\n-\t  return TB_TREE_CODE (mn);\n-\t}\n-    }\n-\n-  /* This isn't a valid code.  */\n-  return LAST_AND_UNUSED_TREE_CODE;\n-}\n-\n-/* Find a node with a given code.  This function is used as an argument to\n-   walk_tree.  */\n-\n-static tree\n-find_node_with_code (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n-\t\t     void *data)\n-{\n-  enum tree_code *code;\n-  code = (enum tree_code *) data;\n-  if (*code == TREE_CODE (*tp))\n-    return *tp;\n-\n-  return NULL_TREE;\n-}\n-\n-/* Returns a pointer to the last visited node.  */\n-\n-static tree\n-TB_history_prev (void)\n-{\n-  if (!vec_safe_is_empty (TB_history_stack))\n-    {\n-      tree last = TB_history_stack->last ();\n-      TB_history_stack->pop ();\n-      return last;\n-    }\n-  return NULL_TREE;\n-}\n-\n-/* Read up to (and including) a '\\n' from STREAM into *LINEPTR\n-   (and null-terminate it). *LINEPTR is a pointer returned from malloc\n-   (or NULL), pointing to *N characters of space.  It is realloc'd as\n-   necessary.  Returns the number of characters read (not including the\n-   null terminator), or -1 on error or EOF.\n-   This function comes from sed (and is supposed to be a portable version\n-   of getline).  */\n-\n-static long\n-TB_getline (char **lineptr, long *n, FILE *stream)\n-{\n-  char *line, *p;\n-  long size, copy;\n-\n-  if (lineptr == NULL || n == NULL)\n-    {\n-      errno = EINVAL;\n-      return -1;\n-    }\n-\n-  if (ferror (stream))\n-    return -1;\n-\n-  /* Make sure we have a line buffer to start with.  */\n-  if (*lineptr == NULL || *n < 2) /* !seen and no buf yet need 2 chars.  */\n-    {\n-#ifndef MAX_CANON\n-#define MAX_CANON       256\n-#endif\n-      line = (char *) xrealloc (*lineptr, MAX_CANON);\n-      if (line == NULL)\n-        return -1;\n-      *lineptr = line;\n-      *n = MAX_CANON;\n-    }\n-\n-  line = *lineptr;\n-  size = *n;\n-\n-  copy = size;\n-  p = line;\n-\n-  while (1)\n-    {\n-      long len;\n-\n-      while (--copy > 0)\n-        {\n-          register int c = getc (stream);\n-          if (c == EOF)\n-            goto lose;\n-          else if ((*p++ = c) == '\\n')\n-            goto win;\n-        }\n-\n-      /* Need to enlarge the line buffer.  */\n-      len = p - line;\n-      size *= 2;\n-      line = (char *) xrealloc (line, size);\n-      if (line == NULL)\n-        goto lose;\n-      *lineptr = line;\n-      *n = size;\n-      p = line + len;\n-      copy = size - len;\n-    }\n-\n- lose:\n-  if (p == *lineptr)\n-    return -1;\n-\n-  /* Return a partial line since we got an error in the middle.  */\n- win:\n-#if defined(WIN32) || defined(_WIN32) || defined(__CYGWIN__) || defined(MSDOS)\n-  if (p - 2 >= *lineptr && p[-2] == '\\r')\n-    p[-2] = p[-1], --p;\n-#endif\n-  *p = '\\0';\n-  return p - *lineptr;\n-}"}, {"sha": "c19393965ae8da7f45aa049c0b277c8fd0d0f427", "filename": "gcc/tree-browser.def", "status": "removed", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33df361a844c44f23ad435960e163ab1732b6d2a/gcc%2Ftree-browser.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33df361a844c44f23ad435960e163ab1732b6d2a/gcc%2Ftree-browser.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-browser.def?ref=33df361a844c44f23ad435960e163ab1732b6d2a", "patch": "@@ -1,97 +0,0 @@\n-/* Definitions and documentation for the codes used by the Tree Browser.\n-   Copyright (C) 2002-2015 Free Software Foundation, Inc.\n-   Contributed by Sebastian Pop <s.pop@laposte.net>\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-/* First field in the following declarations is the code of the command\n-   used by the tree browser.\n-   Second field is what is parsed in order to recognize a command.\n-   Third field is used for printing the help message.  */\n-\n-\n-/* Misc. commands.  */\n-DEFTBCODE (TB_EXIT,\t\t\"x\",\t\"Exits tree-browser.\")\n-DEFTBCODE (TB_QUIT,             \"q\",    \"Exits tree-browser.\")\n-DEFTBCODE (TB_HELP,\t\t\"h\",\t\"Prints this help message.\")\n-DEFTBCODE (TB_UPDATE_UP,        \"update\", \"Update information about parent expressions.\")\n-DEFTBCODE (TB_VERBOSE,          \"verbose\", \"Sets/unsets verbose mode (default is on).\")\n-\n-/* Walking commands.  */\n-DEFTBCODE (TB_FUN,\t\t\"fun\",\t\"Go to the current function declaration.\")\n-DEFTBCODE (TB_NEXT,\t\t\"nx\",\t\"Go to the next expression in a BIND_EXPR.\")\n-DEFTBCODE (TB_PREV,\t\t\"pr\",   \"Go to the previous expression in a BIND_EXPR.\")\n-DEFTBCODE (TB_UP,\t\t\"up\",\t\"Go to the parent tree node.\")\n-DEFTBCODE (TB_LAST,             \"last\", \"Go to the last expression in a BIND_EXPR.\")\n-DEFTBCODE (TB_FIRST,            \"first\",\"Go to the first expression in a BIND_EXPR.\")\n-DEFTBCODE (TB_HPREV,            \"hpr\",  \"Go to the previous visited node (history previous).\")\n-\n-/* Fields accessors.  */\n-DEFTBCODE (TB_CHILD_0,          \"arg0\",  \"Child 0.\")\n-DEFTBCODE (TB_CHILD_1,          \"arg1\",  \"Child 1.\")\n-DEFTBCODE (TB_CHILD_2,          \"arg2\",  \"Child 2.\")\n-DEFTBCODE (TB_CHILD_3,          \"arg3\",  \"Child 3.\")\n-DEFTBCODE (TB_DECL_SAVED_TREE,  \"decl_saved_tree\", \"Body of a function.\")\n-DEFTBCODE (TB_TYPE,             \"type\", \"Field accessor.\")\n-DEFTBCODE (TB_SIZE,             \"size\", \"Field accessor.\")\n-DEFTBCODE (TB_UNIT_SIZE,        \"unit_size\", \"Field accessor.\")\n-DEFTBCODE (TB_OFFSET,           \"offset\", \"Field accessor.\")\n-DEFTBCODE (TB_BIT_OFFSET,       \"bit_offset\", \"Field accessor.\")\n-DEFTBCODE (TB_CONTEXT,          \"context\", \"Field accessor.\")\n-DEFTBCODE (TB_ATTRIBUTES,       \"attributes\", \"Field accessor.\")\n-DEFTBCODE (TB_ABSTRACT_ORIGIN,  \"abstract_origin\", \"Field accessor.\")\n-DEFTBCODE (TB_ARGUMENTS,        \"arguments\", \"Field accessor.\")\n-DEFTBCODE (TB_RESULT,           \"result\", \"Field accessor.\")\n-DEFTBCODE (TB_INITIAL,          \"initial\", \"Field accessor.\")\n-DEFTBCODE (TB_ARG_TYPE,         \"arg-type\", \"Field accessor.\")\n-DEFTBCODE (TB_ARG_TYPE_AS_WRITTEN, \"arg-type-as-written\", \"Field accessor.\")\n-DEFTBCODE (TB_CHAIN,            \"chain\", \"Field accessor.\")\n-DEFTBCODE (TB_VALUES,           \"values\", \"Field accessor.\")\n-DEFTBCODE (TB_DOMAIN,           \"domain\", \"Field accessor.\")\n-DEFTBCODE (TB_METHOD_BASE_TYPE, \"method_basetype\", \"Field accessor.\")\n-DEFTBCODE (TB_FIELDS,           \"fields\", \"Field accessor.\")\n-DEFTBCODE (TB_ARG_TYPES,        \"arg-types\", \"Field accessor.\")\n-DEFTBCODE (TB_BASETYPE,         \"basetype\", \"Field accessor.\")\n-DEFTBCODE (TB_POINTER_TO_THIS,  \"pointer_to_this\", \"Field accessor.\")\n-DEFTBCODE (TB_REFERENCE_TO_THIS,\"reference_to_this\", \"Field accessor.\")\n-DEFTBCODE (TB_VARS,             \"vars\", \"Field accessor.\")\n-DEFTBCODE (TB_SUPERCONTEXT,     \"supercontext\", \"Field accessor.\")\n-DEFTBCODE (TB_BODY,             \"body\", \"Field accessor.\")\n-DEFTBCODE (TB_SUBBLOCKS,        \"subblocks\", \"Field accessor.\")\n-DEFTBCODE (TB_BLOCK,            \"block\", \"Field accessor.\")\n-DEFTBCODE (TB_REAL,             \"real\", \"Field accessor.\")\n-DEFTBCODE (TB_IMAG,             \"imag\", \"Field accessor.\")\n-DEFTBCODE (TB_PURPOSE,          \"purpose\", \"Field accessor.\")\n-DEFTBCODE (TB_VALUE,            \"value\", \"Field accessor.\")\n-DEFTBCODE (TB_ELT,              \"elt\", \"Field accessor.\")\n-DEFTBCODE (TB_MIN,              \"min\", \"Field accessor.\")\n-DEFTBCODE (TB_MAX,              \"max\", \"Field accessor.\")\n-\n-/* Searching commands.  */\n-DEFTBCODE (TB_SEARCH_CODE,\t\"sc\",\t\"Search a node having a TREE_CODE given as a parameter.\")\n-DEFTBCODE (TB_SEARCH_NAME,\t\"sn\",\t\"Search an identifier having a name given as a parameter.\")\n-\n-/* Printing commands.  */\n-DEFTBCODE (TB_PRETTY_PRINT,     \"pp\",   \"Pretty print current node.\")\n-DEFTBCODE (TB_PRINT,            \"p\",    \"Prints the current node.\")\n-\n-\n-/*\n-Local variables:\n-mode:c\n-End:\n-*/"}]}