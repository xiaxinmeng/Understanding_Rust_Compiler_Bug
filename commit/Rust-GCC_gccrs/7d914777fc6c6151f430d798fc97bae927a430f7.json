{"sha": "7d914777fc6c6151f430d798fc97bae927a430f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q5MTQ3NzdmYzZjNjE1MWY0MzBkNzk4ZmM5N2JhZTkyN2E0MzBmNw==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@linux.ibm.com", "date": "2021-07-14T23:23:31Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@linux.ibm.com", "date": "2021-07-14T23:23:31Z"}, "message": "rs6000: Move rs6000_split_multireg_move to later in file\n\nAn upcoming change to rs6000_split_multireg_move requires it to be\nmoved later in the file to fix a declaration issue.\n\n2021-07-14  Peter Bergner  <bergner@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000.c (rs6000_split_multireg_move): Move to later\n\tin the file.", "tree": {"sha": "498ea7095c07db3dc40fd45236b75f057bbc7db1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/498ea7095c07db3dc40fd45236b75f057bbc7db1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d914777fc6c6151f430d798fc97bae927a430f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d914777fc6c6151f430d798fc97bae927a430f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d914777fc6c6151f430d798fc97bae927a430f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d914777fc6c6151f430d798fc97bae927a430f7/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bebd8e9da838c51a7f911985083d5a2b2498a23a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bebd8e9da838c51a7f911985083d5a2b2498a23a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bebd8e9da838c51a7f911985083d5a2b2498a23a"}], "stats": {"total": 1845, "additions": 922, "deletions": 923}, "files": [{"sha": "1d27bb8b58c209f69d37d870b878fc4437fd6cbc", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 922, "deletions": 923, "changes": 1845, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d914777fc6c6151f430d798fc97bae927a430f7/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d914777fc6c6151f430d798fc97bae927a430f7/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=7d914777fc6c6151f430d798fc97bae927a430f7", "patch": "@@ -16690,533 +16690,157 @@ rs6000_expand_atomic_op (enum rtx_code code, rtx mem, rtx val,\n     emit_move_insn (orig_after, after);\n }\n \n-/* Emit instructions to move SRC to DST.  Called by splitters for\n-   multi-register moves.  It will emit at most one instruction for\n-   each register that is accessed; that is, it won't emit li/lis pairs\n-   (or equivalent for 64-bit code).  One of SRC or DST must be a hard\n-   register.  */\n+static GTY(()) alias_set_type TOC_alias_set = -1;\n \n-void\n-rs6000_split_multireg_move (rtx dst, rtx src)\n+alias_set_type\n+get_TOC_alias_set (void)\n {\n-  /* The register number of the first register being moved.  */\n-  int reg;\n-  /* The mode that is to be moved.  */\n-  machine_mode mode;\n-  /* The mode that the move is being done in, and its size.  */\n-  machine_mode reg_mode;\n-  int reg_mode_size;\n-  /* The number of registers that will be moved.  */\n-  int nregs;\n+  if (TOC_alias_set == -1)\n+    TOC_alias_set = new_alias_set ();\n+  return TOC_alias_set;\n+}\n \n-  reg = REG_P (dst) ? REGNO (dst) : REGNO (src);\n-  mode = GET_MODE (dst);\n-  nregs = hard_regno_nregs (reg, mode);\n+/* The mode the ABI uses for a word.  This is not the same as word_mode\n+   for -m32 -mpowerpc64.  This is used to implement various target hooks.  */\n \n-  /* If we have a vector quad register for MMA, and this is a load or store,\n-     see if we can use vector paired load/stores.  */\n-  if (mode == XOmode && TARGET_MMA\n-      && (MEM_P (dst) || MEM_P (src)))\n-    {\n-      reg_mode = OOmode;\n-      nregs /= 2;\n-    }\n-  /* If we have a vector pair/quad mode, split it into two/four separate\n-     vectors.  */\n-  else if (mode == OOmode || mode == XOmode)\n-    reg_mode = V1TImode;\n-  else if (FP_REGNO_P (reg))\n-    reg_mode = DECIMAL_FLOAT_MODE_P (mode) ? DDmode :\n-\t(TARGET_HARD_FLOAT ? DFmode : SFmode);\n-  else if (ALTIVEC_REGNO_P (reg))\n-    reg_mode = V16QImode;\n+static scalar_int_mode\n+rs6000_abi_word_mode (void)\n+{\n+  return TARGET_32BIT ? SImode : DImode;\n+}\n+\n+/* Implement the TARGET_OFFLOAD_OPTIONS hook.  */\n+static char *\n+rs6000_offload_options (void)\n+{\n+  if (TARGET_64BIT)\n+    return xstrdup (\"-foffload-abi=lp64\");\n   else\n-    reg_mode = word_mode;\n-  reg_mode_size = GET_MODE_SIZE (reg_mode);\n+    return xstrdup (\"-foffload-abi=ilp32\");\n+}\n \n-  gcc_assert (reg_mode_size * nregs == GET_MODE_SIZE (mode));\n+\f\n+/* A quick summary of the various types of 'constant-pool tables'\n+   under PowerPC:\n \n-  /* TDmode residing in FP registers is special, since the ISA requires that\n-     the lower-numbered word of a register pair is always the most significant\n-     word, even in little-endian mode.  This does not match the usual subreg\n-     semantics, so we cannnot use simplify_gen_subreg in those cases.  Access\n-     the appropriate constituent registers \"by hand\" in little-endian mode.\n+   Target\tFlags\t\tName\t\tOne table per\n+   AIX\t\t(none)\t\tAIX TOC\t\tobject file\n+   AIX\t\t-mfull-toc\tAIX TOC\t\tobject file\n+   AIX\t\t-mminimal-toc\tAIX minimal TOC\ttranslation unit\n+   SVR4/EABI\t(none)\t\tSVR4 SDATA\tobject file\n+   SVR4/EABI\t-fpic\t\tSVR4 pic\tobject file\n+   SVR4/EABI\t-fPIC\t\tSVR4 PIC\ttranslation unit\n+   SVR4/EABI\t-mrelocatable\tEABI TOC\tfunction\n+   SVR4/EABI\t-maix\t\tAIX TOC\t\tobject file\n+   SVR4/EABI\t-maix -mminimal-toc\n+\t\t\t\tAIX minimal TOC\ttranslation unit\n \n-     Note we do not need to check for destructive overlap here since TDmode\n-     can only reside in even/odd register pairs.  */\n-  if (FP_REGNO_P (reg) && DECIMAL_FLOAT_MODE_P (mode) && !BYTES_BIG_ENDIAN)\n-    {\n-      rtx p_src, p_dst;\n-      int i;\n+   Name\t\t\tReg.\tSet by\tentries\t      contains:\n+\t\t\t\t\tmade by\t addrs?\tfp?\tsum?\n \n-      for (i = 0; i < nregs; i++)\n-\t{\n-\t  if (REG_P (src) && FP_REGNO_P (REGNO (src)))\n-\t    p_src = gen_rtx_REG (reg_mode, REGNO (src) + nregs - 1 - i);\n-\t  else\n-\t    p_src = simplify_gen_subreg (reg_mode, src, mode,\n-\t\t\t\t\t i * reg_mode_size);\n+   AIX TOC\t\t2\tcrt0\tas\t Y\toption\toption\n+   AIX minimal TOC\t30\tprolog\tgcc\t Y\tY\toption\n+   SVR4 SDATA\t\t13\tcrt0\tgcc\t N\tY\tN\n+   SVR4 pic\t\t30\tprolog\tld\t Y\tnot yet\tN\n+   SVR4 PIC\t\t30\tprolog\tgcc\t Y\toption\toption\n+   EABI TOC\t\t30\tprolog\tgcc\t Y\toption\toption\n \n-\t  if (REG_P (dst) && FP_REGNO_P (REGNO (dst)))\n-\t    p_dst = gen_rtx_REG (reg_mode, REGNO (dst) + nregs - 1 - i);\n-\t  else\n-\t    p_dst = simplify_gen_subreg (reg_mode, dst, mode,\n-\t\t\t\t\t i * reg_mode_size);\n+*/\n \n-\t  emit_insn (gen_rtx_SET (p_dst, p_src));\n-\t}\n+/* Hash functions for the hash table.  */\n \n-      return;\n-    }\n+static unsigned\n+rs6000_hash_constant (rtx k)\n+{\n+  enum rtx_code code = GET_CODE (k);\n+  machine_mode mode = GET_MODE (k);\n+  unsigned result = (code << 3) ^ mode;\n+  const char *format;\n+  int flen, fidx;\n \n-  /* The __vector_pair and __vector_quad modes are multi-register\n-     modes, so if we have to load or store the registers, we have to be\n-     careful to properly swap them if we're in little endian mode\n-     below.  This means the last register gets the first memory\n-     location.  We also need to be careful of using the right register\n-     numbers if we are splitting XO to OO.  */\n-  if (mode == OOmode || mode == XOmode)\n+  format = GET_RTX_FORMAT (code);\n+  flen = strlen (format);\n+  fidx = 0;\n+\n+  switch (code)\n     {\n-      nregs = hard_regno_nregs (reg, mode);\n-      int reg_mode_nregs = hard_regno_nregs (reg, reg_mode);\n-      if (MEM_P (dst))\n-\t{\n-\t  unsigned offset = 0;\n-\t  unsigned size = GET_MODE_SIZE (reg_mode);\n+    case LABEL_REF:\n+      return result * 1231 + (unsigned) INSN_UID (XEXP (k, 0));\n \n-\t  /* If we are reading an accumulator register, we have to\n-\t     deprime it before we can access it.  */\n-\t  if (TARGET_MMA\n-\t      && GET_MODE (src) == XOmode && FP_REGNO_P (REGNO (src)))\n-\t    emit_insn (gen_mma_xxmfacc (src, src));\n+    case CONST_WIDE_INT:\n+      {\n+\tint i;\n+\tflen = CONST_WIDE_INT_NUNITS (k);\n+\tfor (i = 0; i < flen; i++)\n+\t  result = result * 613 + CONST_WIDE_INT_ELT (k, i);\n+\treturn result;\n+      }\n \n-\t  for (int i = 0; i < nregs; i += reg_mode_nregs)\n-\t    {\n-\t      unsigned subreg =\n-\t\t(WORDS_BIG_ENDIAN) ? i : (nregs - reg_mode_nregs - i);\n-\t      rtx dst2 = adjust_address (dst, reg_mode, offset);\n-\t      rtx src2 = gen_rtx_REG (reg_mode, reg + subreg);\n-\t      offset += size;\n-\t      emit_insn (gen_rtx_SET (dst2, src2));\n-\t    }\n+    case CONST_DOUBLE:\n+      return real_hash (CONST_DOUBLE_REAL_VALUE (k)) * result;\n \n-\t  return;\n-\t}\n+    case CODE_LABEL:\n+      fidx = 3;\n+      break;\n \n-      if (MEM_P (src))\n+    default:\n+      break;\n+    }\n+\n+  for (; fidx < flen; fidx++)\n+    switch (format[fidx])\n+      {\n+      case 's':\n \t{\n-\t  unsigned offset = 0;\n-\t  unsigned size = GET_MODE_SIZE (reg_mode);\n+\t  unsigned i, len;\n+\t  const char *str = XSTR (k, fidx);\n+\t  len = strlen (str);\n+\t  result = result * 613 + len;\n+\t  for (i = 0; i < len; i++)\n+\t    result = result * 613 + (unsigned) str[i];\n+\t  break;\n+\t}\n+      case 'u':\n+      case 'e':\n+\tresult = result * 1231 + rs6000_hash_constant (XEXP (k, fidx));\n+\tbreak;\n+      case 'i':\n+      case 'n':\n+\tresult = result * 613 + (unsigned) XINT (k, fidx);\n+\tbreak;\n+      case 'w':\n+\tif (sizeof (unsigned) >= sizeof (HOST_WIDE_INT))\n+\t  result = result * 613 + (unsigned) XWINT (k, fidx);\n+\telse\n+\t  {\n+\t    size_t i;\n+\t    for (i = 0; i < sizeof (HOST_WIDE_INT) / sizeof (unsigned); i++)\n+\t      result = result * 613 + (unsigned) (XWINT (k, fidx)\n+\t\t\t\t\t\t  >> CHAR_BIT * i);\n+\t  }\n+\tbreak;\n+      case '0':\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+      }\n \n-\t  for (int i = 0; i < nregs; i += reg_mode_nregs)\n-\t    {\n-\t      unsigned subreg =\n-\t\t(WORDS_BIG_ENDIAN) ? i : (nregs - reg_mode_nregs - i);\n-\t      rtx dst2 = gen_rtx_REG (reg_mode, reg + subreg);\n-\t      rtx src2 = adjust_address (src, reg_mode, offset);\n-\t      offset += size;\n-\t      emit_insn (gen_rtx_SET (dst2, src2));\n-\t    }\n+  return result;\n+}\n \n-\t  /* If we are writing an accumulator register, we have to\n-\t     prime it after we've written it.  */\n-\t  if (TARGET_MMA\n-\t      && GET_MODE (dst) == XOmode && FP_REGNO_P (REGNO (dst)))\n-\t    emit_insn (gen_mma_xxmtacc (dst, dst));\n+hashval_t\n+toc_hasher::hash (toc_hash_struct *thc)\n+{\n+  return rs6000_hash_constant (thc->key) ^ thc->key_mode;\n+}\n \n-\t  return;\n-\t}\n+/* Compare H1 and H2 for equivalence.  */\n \n-      if (GET_CODE (src) == UNSPEC)\n-\t{\n-\t  gcc_assert (XINT (src, 1) == UNSPEC_MMA_ASSEMBLE);\n-\t  gcc_assert (REG_P (dst));\n-\t  if (GET_MODE (src) == XOmode)\n-\t    gcc_assert (FP_REGNO_P (REGNO (dst)));\n-\t  if (GET_MODE (src) == OOmode)\n-\t    gcc_assert (VSX_REGNO_P (REGNO (dst)));\n-\n-\t  reg_mode = GET_MODE (XVECEXP (src, 0, 0));\n-\t  int nvecs = XVECLEN (src, 0);\n-\t  for (int i = 0; i < nvecs; i++)\n-\t    {\n-\t      int index = WORDS_BIG_ENDIAN ? i : nvecs - 1 - i;\n-\t      rtx dst_i = gen_rtx_REG (reg_mode, reg + index);\n-\t      emit_insn (gen_rtx_SET (dst_i, XVECEXP (src, 0, i)));\n-\t    }\n-\n-\t  /* We are writing an accumulator register, so we have to\n-\t     prime it after we've written it.  */\n-\t  if (GET_MODE (src) == XOmode)\n-\t    emit_insn (gen_mma_xxmtacc (dst, dst));\n-\n-\t  return;\n-\t}\n-\n-      /* Register -> register moves can use common code.  */\n-    }\n-\n-  if (REG_P (src) && REG_P (dst) && (REGNO (src) < REGNO (dst)))\n-    {\n-      /* If we are reading an accumulator register, we have to\n-\t deprime it before we can access it.  */\n-      if (TARGET_MMA\n-\t  && GET_MODE (src) == XOmode && FP_REGNO_P (REGNO (src)))\n-\temit_insn (gen_mma_xxmfacc (src, src));\n-\n-      /* Move register range backwards, if we might have destructive\n-\t overlap.  */\n-      int i;\n-      /* XO/OO are opaque so cannot use subregs. */\n-      if (mode == OOmode || mode == XOmode )\n-\t{\n-\t  for (i = nregs - 1; i >= 0; i--)\n-\t    {\n-\t      rtx dst_i = gen_rtx_REG (reg_mode, REGNO (dst) + i);\n-\t      rtx src_i = gen_rtx_REG (reg_mode, REGNO (src) + i);\n-\t      emit_insn (gen_rtx_SET (dst_i, src_i));\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  for (i = nregs - 1; i >= 0; i--)\n-\t    emit_insn (gen_rtx_SET (simplify_gen_subreg (reg_mode, dst, mode,\n-\t\t\t\t\t\t\t i * reg_mode_size),\n-\t\t\t\t    simplify_gen_subreg (reg_mode, src, mode,\n-\t\t\t\t\t\t\t i * reg_mode_size)));\n-\t}\n-\n-      /* If we are writing an accumulator register, we have to\n-\t prime it after we've written it.  */\n-      if (TARGET_MMA\n-\t  && GET_MODE (dst) == XOmode && FP_REGNO_P (REGNO (dst)))\n-\temit_insn (gen_mma_xxmtacc (dst, dst));\n-    }\n-  else\n-    {\n-      int i;\n-      int j = -1;\n-      bool used_update = false;\n-      rtx restore_basereg = NULL_RTX;\n-\n-      if (MEM_P (src) && INT_REGNO_P (reg))\n-\t{\n-\t  rtx breg;\n-\n-\t  if (GET_CODE (XEXP (src, 0)) == PRE_INC\n-\t      || GET_CODE (XEXP (src, 0)) == PRE_DEC)\n-\t    {\n-\t      rtx delta_rtx;\n-\t      breg = XEXP (XEXP (src, 0), 0);\n-\t      delta_rtx = (GET_CODE (XEXP (src, 0)) == PRE_INC\n-\t\t\t   ? GEN_INT (GET_MODE_SIZE (GET_MODE (src)))\n-\t\t\t   : GEN_INT (-GET_MODE_SIZE (GET_MODE (src))));\n-\t      emit_insn (gen_add3_insn (breg, breg, delta_rtx));\n-\t      src = replace_equiv_address (src, breg);\n-\t    }\n-\t  else if (! rs6000_offsettable_memref_p (src, reg_mode, true))\n-\t    {\n-\t      if (GET_CODE (XEXP (src, 0)) == PRE_MODIFY)\n-\t\t{\n-\t\t  rtx basereg = XEXP (XEXP (src, 0), 0);\n-\t\t  if (TARGET_UPDATE)\n-\t\t    {\n-\t\t      rtx ndst = simplify_gen_subreg (reg_mode, dst, mode, 0);\n-\t\t      emit_insn (gen_rtx_SET (ndst,\n-\t\t\t\t\t      gen_rtx_MEM (reg_mode,\n-\t\t\t\t\t\t\t   XEXP (src, 0))));\n-\t\t      used_update = true;\n-\t\t    }\n-\t\t  else\n-\t\t    emit_insn (gen_rtx_SET (basereg,\n-\t\t\t\t\t    XEXP (XEXP (src, 0), 1)));\n-\t\t  src = replace_equiv_address (src, basereg);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  rtx basereg = gen_rtx_REG (Pmode, reg);\n-\t\t  emit_insn (gen_rtx_SET (basereg, XEXP (src, 0)));\n-\t\t  src = replace_equiv_address (src, basereg);\n-\t\t}\n-\t    }\n-\n-\t  breg = XEXP (src, 0);\n-\t  if (GET_CODE (breg) == PLUS || GET_CODE (breg) == LO_SUM)\n-\t    breg = XEXP (breg, 0);\n-\n-\t  /* If the base register we are using to address memory is\n-\t     also a destination reg, then change that register last.  */\n-\t  if (REG_P (breg)\n-\t      && REGNO (breg) >= REGNO (dst)\n-\t      && REGNO (breg) < REGNO (dst) + nregs)\n-\t    j = REGNO (breg) - REGNO (dst);\n-\t}\n-      else if (MEM_P (dst) && INT_REGNO_P (reg))\n-\t{\n-\t  rtx breg;\n-\n-\t  if (GET_CODE (XEXP (dst, 0)) == PRE_INC\n-\t      || GET_CODE (XEXP (dst, 0)) == PRE_DEC)\n-\t    {\n-\t      rtx delta_rtx;\n-\t      breg = XEXP (XEXP (dst, 0), 0);\n-\t      delta_rtx = (GET_CODE (XEXP (dst, 0)) == PRE_INC\n-\t\t\t   ? GEN_INT (GET_MODE_SIZE (GET_MODE (dst)))\n-\t\t\t   : GEN_INT (-GET_MODE_SIZE (GET_MODE (dst))));\n-\n-\t      /* We have to update the breg before doing the store.\n-\t\t Use store with update, if available.  */\n-\n-\t      if (TARGET_UPDATE)\n-\t\t{\n-\t\t  rtx nsrc = simplify_gen_subreg (reg_mode, src, mode, 0);\n-\t\t  emit_insn (TARGET_32BIT\n-\t\t\t     ? (TARGET_POWERPC64\n-\t\t\t\t? gen_movdi_si_update (breg, breg, delta_rtx, nsrc)\n-\t\t\t\t: gen_movsi_si_update (breg, breg, delta_rtx, nsrc))\n-\t\t\t     : gen_movdi_di_update (breg, breg, delta_rtx, nsrc));\n-\t\t  used_update = true;\n-\t\t}\n-\t      else\n-\t\temit_insn (gen_add3_insn (breg, breg, delta_rtx));\n-\t      dst = replace_equiv_address (dst, breg);\n-\t    }\n-\t  else if (!rs6000_offsettable_memref_p (dst, reg_mode, true)\n-\t\t   && GET_CODE (XEXP (dst, 0)) != LO_SUM)\n-\t    {\n-\t      if (GET_CODE (XEXP (dst, 0)) == PRE_MODIFY)\n-\t\t{\n-\t\t  rtx basereg = XEXP (XEXP (dst, 0), 0);\n-\t\t  if (TARGET_UPDATE)\n-\t\t    {\n-\t\t      rtx nsrc = simplify_gen_subreg (reg_mode, src, mode, 0);\n-\t\t      emit_insn (gen_rtx_SET (gen_rtx_MEM (reg_mode,\n-\t\t\t\t\t\t\t   XEXP (dst, 0)),\n-\t\t\t\t\t      nsrc));\n-\t\t      used_update = true;\n-\t\t    }\n-\t\t  else\n-\t\t    emit_insn (gen_rtx_SET (basereg,\n-\t\t\t\t\t    XEXP (XEXP (dst, 0), 1)));\n-\t\t  dst = replace_equiv_address (dst, basereg);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  rtx basereg = XEXP (XEXP (dst, 0), 0);\n-\t\t  rtx offsetreg = XEXP (XEXP (dst, 0), 1);\n-\t\t  gcc_assert (GET_CODE (XEXP (dst, 0)) == PLUS\n-\t\t\t      && REG_P (basereg)\n-\t\t\t      && REG_P (offsetreg)\n-\t\t\t      && REGNO (basereg) != REGNO (offsetreg));\n-\t\t  if (REGNO (basereg) == 0)\n-\t\t    {\n-\t\t      rtx tmp = offsetreg;\n-\t\t      offsetreg = basereg;\n-\t\t      basereg = tmp;\n-\t\t    }\n-\t\t  emit_insn (gen_add3_insn (basereg, basereg, offsetreg));\n-\t\t  restore_basereg = gen_sub3_insn (basereg, basereg, offsetreg);\n-\t\t  dst = replace_equiv_address (dst, basereg);\n-\t\t}\n-\t    }\n-\t  else if (GET_CODE (XEXP (dst, 0)) != LO_SUM)\n-\t    gcc_assert (rs6000_offsettable_memref_p (dst, reg_mode, true));\n-\t}\n-\n-      /* If we are reading an accumulator register, we have to\n-\t deprime it before we can access it.  */\n-      if (TARGET_MMA && REG_P (src)\n-\t  && GET_MODE (src) == XOmode && FP_REGNO_P (REGNO (src)))\n-\temit_insn (gen_mma_xxmfacc (src, src));\n-\n-      for (i = 0; i < nregs; i++)\n-\t{\n-\t  /* Calculate index to next subword.  */\n-\t  ++j;\n-\t  if (j == nregs)\n-\t    j = 0;\n-\n-\t  /* If compiler already emitted move of first word by\n-\t     store with update, no need to do anything.  */\n-\t  if (j == 0 && used_update)\n-\t    continue;\n-\n-\t  /* XO/OO are opaque so cannot use subregs. */\n-\t  if (mode == OOmode || mode == XOmode )\n-\t    {\n-\t      rtx dst_i = gen_rtx_REG (reg_mode, REGNO (dst) + j);\n-\t      rtx src_i = gen_rtx_REG (reg_mode, REGNO (src) + j);\n-\t      emit_insn (gen_rtx_SET (dst_i, src_i));\n-\t    }\n-\t  else\n-\t    emit_insn (gen_rtx_SET (simplify_gen_subreg (reg_mode, dst, mode,\n-\t\t\t\t\t\t\t j * reg_mode_size),\n-\t\t\t\t    simplify_gen_subreg (reg_mode, src, mode,\n-\t\t\t\t\t\t\t j * reg_mode_size)));\n-\t}\n-\n-      /* If we are writing an accumulator register, we have to\n-\t prime it after we've written it.  */\n-      if (TARGET_MMA && REG_P (dst)\n-\t  && GET_MODE (dst) == XOmode && FP_REGNO_P (REGNO (dst)))\n-\temit_insn (gen_mma_xxmtacc (dst, dst));\n-\n-      if (restore_basereg != NULL_RTX)\n-\temit_insn (restore_basereg);\n-    }\n-}\n-\n-static GTY(()) alias_set_type TOC_alias_set = -1;\n-\n-alias_set_type\n-get_TOC_alias_set (void)\n-{\n-  if (TOC_alias_set == -1)\n-    TOC_alias_set = new_alias_set ();\n-  return TOC_alias_set;\n-}\n-\n-/* The mode the ABI uses for a word.  This is not the same as word_mode\n-   for -m32 -mpowerpc64.  This is used to implement various target hooks.  */\n-\n-static scalar_int_mode\n-rs6000_abi_word_mode (void)\n-{\n-  return TARGET_32BIT ? SImode : DImode;\n-}\n-\n-/* Implement the TARGET_OFFLOAD_OPTIONS hook.  */\n-static char *\n-rs6000_offload_options (void)\n-{\n-  if (TARGET_64BIT)\n-    return xstrdup (\"-foffload-abi=lp64\");\n-  else\n-    return xstrdup (\"-foffload-abi=ilp32\");\n-}\n-\n-\f\n-/* A quick summary of the various types of 'constant-pool tables'\n-   under PowerPC:\n-\n-   Target\tFlags\t\tName\t\tOne table per\n-   AIX\t\t(none)\t\tAIX TOC\t\tobject file\n-   AIX\t\t-mfull-toc\tAIX TOC\t\tobject file\n-   AIX\t\t-mminimal-toc\tAIX minimal TOC\ttranslation unit\n-   SVR4/EABI\t(none)\t\tSVR4 SDATA\tobject file\n-   SVR4/EABI\t-fpic\t\tSVR4 pic\tobject file\n-   SVR4/EABI\t-fPIC\t\tSVR4 PIC\ttranslation unit\n-   SVR4/EABI\t-mrelocatable\tEABI TOC\tfunction\n-   SVR4/EABI\t-maix\t\tAIX TOC\t\tobject file\n-   SVR4/EABI\t-maix -mminimal-toc\n-\t\t\t\tAIX minimal TOC\ttranslation unit\n-\n-   Name\t\t\tReg.\tSet by\tentries\t      contains:\n-\t\t\t\t\tmade by\t addrs?\tfp?\tsum?\n-\n-   AIX TOC\t\t2\tcrt0\tas\t Y\toption\toption\n-   AIX minimal TOC\t30\tprolog\tgcc\t Y\tY\toption\n-   SVR4 SDATA\t\t13\tcrt0\tgcc\t N\tY\tN\n-   SVR4 pic\t\t30\tprolog\tld\t Y\tnot yet\tN\n-   SVR4 PIC\t\t30\tprolog\tgcc\t Y\toption\toption\n-   EABI TOC\t\t30\tprolog\tgcc\t Y\toption\toption\n-\n-*/\n-\n-/* Hash functions for the hash table.  */\n-\n-static unsigned\n-rs6000_hash_constant (rtx k)\n-{\n-  enum rtx_code code = GET_CODE (k);\n-  machine_mode mode = GET_MODE (k);\n-  unsigned result = (code << 3) ^ mode;\n-  const char *format;\n-  int flen, fidx;\n-\n-  format = GET_RTX_FORMAT (code);\n-  flen = strlen (format);\n-  fidx = 0;\n-\n-  switch (code)\n-    {\n-    case LABEL_REF:\n-      return result * 1231 + (unsigned) INSN_UID (XEXP (k, 0));\n-\n-    case CONST_WIDE_INT:\n-      {\n-\tint i;\n-\tflen = CONST_WIDE_INT_NUNITS (k);\n-\tfor (i = 0; i < flen; i++)\n-\t  result = result * 613 + CONST_WIDE_INT_ELT (k, i);\n-\treturn result;\n-      }\n-\n-    case CONST_DOUBLE:\n-      return real_hash (CONST_DOUBLE_REAL_VALUE (k)) * result;\n-\n-    case CODE_LABEL:\n-      fidx = 3;\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n-  for (; fidx < flen; fidx++)\n-    switch (format[fidx])\n-      {\n-      case 's':\n-\t{\n-\t  unsigned i, len;\n-\t  const char *str = XSTR (k, fidx);\n-\t  len = strlen (str);\n-\t  result = result * 613 + len;\n-\t  for (i = 0; i < len; i++)\n-\t    result = result * 613 + (unsigned) str[i];\n-\t  break;\n-\t}\n-      case 'u':\n-      case 'e':\n-\tresult = result * 1231 + rs6000_hash_constant (XEXP (k, fidx));\n-\tbreak;\n-      case 'i':\n-      case 'n':\n-\tresult = result * 613 + (unsigned) XINT (k, fidx);\n-\tbreak;\n-      case 'w':\n-\tif (sizeof (unsigned) >= sizeof (HOST_WIDE_INT))\n-\t  result = result * 613 + (unsigned) XWINT (k, fidx);\n-\telse\n-\t  {\n-\t    size_t i;\n-\t    for (i = 0; i < sizeof (HOST_WIDE_INT) / sizeof (unsigned); i++)\n-\t      result = result * 613 + (unsigned) (XWINT (k, fidx)\n-\t\t\t\t\t\t  >> CHAR_BIT * i);\n-\t  }\n-\tbreak;\n-      case '0':\n-\tbreak;\n-      default:\n-\tgcc_unreachable ();\n-      }\n-\n-  return result;\n-}\n-\n-hashval_t\n-toc_hasher::hash (toc_hash_struct *thc)\n-{\n-  return rs6000_hash_constant (thc->key) ^ thc->key_mode;\n-}\n-\n-/* Compare H1 and H2 for equivalence.  */\n-\n-bool\n-toc_hasher::equal (toc_hash_struct *h1, toc_hash_struct *h2)\n-{\n-  rtx r1 = h1->key;\n-  rtx r2 = h2->key;\n+bool\n+toc_hasher::equal (toc_hash_struct *h1, toc_hash_struct *h2)\n+{\n+  rtx r1 = h1->key;\n+  rtx r2 = h2->key;\n \n   if (h1->key_mode != h2->key_mode)\n     return 0;\n@@ -26450,538 +26074,913 @@ prefixed_load_p (rtx_insn *insn)\n   if (non_prefixed == NON_PREFIXED_X && is_lfs_stfs_insn (insn))\n     return address_is_prefixed (XEXP (mem, 0), mem_mode, NON_PREFIXED_DEFAULT);\n   else\n-    return address_is_prefixed (XEXP (mem, 0), mem_mode, non_prefixed);\n+    return address_is_prefixed (XEXP (mem, 0), mem_mode, non_prefixed);\n+}\n+\n+/* Whether a store instruction is a prefixed instruction.  This is called from\n+   the prefixed attribute processing.  */\n+\n+bool\n+prefixed_store_p (rtx_insn *insn)\n+{\n+  /* Validate the insn to make sure it is a normal store insn.  */\n+  extract_insn_cached (insn);\n+  if (recog_data.n_operands < 2)\n+    return false;\n+\n+  rtx mem = recog_data.operand[0];\n+  rtx reg = recog_data.operand[1];\n+\n+  if (!REG_P (reg) && !SUBREG_P (reg))\n+    return false;\n+\n+  if (!MEM_P (mem))\n+    return false;\n+\n+  /* Prefixed store instructions do not support update or indexed forms.  */\n+  if (get_attr_indexed (insn) == INDEXED_YES\n+      || get_attr_update (insn) == UPDATE_YES)\n+    return false;\n+\n+  machine_mode mem_mode = GET_MODE (mem);\n+  rtx addr = XEXP (mem, 0);\n+  enum non_prefixed_form non_prefixed = reg_to_non_prefixed (reg, mem_mode);\n+\n+  /* Need to make sure we aren't looking at a stfs which doesn't look\n+     like the other things reg_to_non_prefixed/address_is_prefixed\n+     looks for.  */\n+  if (non_prefixed == NON_PREFIXED_X && is_lfs_stfs_insn (insn))\n+    return address_is_prefixed (addr, mem_mode, NON_PREFIXED_DEFAULT);\n+  else\n+    return address_is_prefixed (addr, mem_mode, non_prefixed);\n+}\n+\n+/* Whether a load immediate or add instruction is a prefixed instruction.  This\n+   is called from the prefixed attribute processing.  */\n+\n+bool\n+prefixed_paddi_p (rtx_insn *insn)\n+{\n+  rtx set = single_set (insn);\n+  if (!set)\n+    return false;\n+\n+  rtx dest = SET_DEST (set);\n+  rtx src = SET_SRC (set);\n+\n+  if (!REG_P (dest) && !SUBREG_P (dest))\n+    return false;\n+\n+  /* Is this a load immediate that can't be done with a simple ADDI or\n+     ADDIS?  */\n+  if (CONST_INT_P (src))\n+    return (satisfies_constraint_eI (src)\n+\t    && !satisfies_constraint_I (src)\n+\t    && !satisfies_constraint_L (src));\n+\n+  /* Is this a PADDI instruction that can't be done with a simple ADDI or\n+     ADDIS?  */\n+  if (GET_CODE (src) == PLUS)\n+    {\n+      rtx op1 = XEXP (src, 1);\n+\n+      return (CONST_INT_P (op1)\n+\t      && satisfies_constraint_eI (op1)\n+\t      && !satisfies_constraint_I (op1)\n+\t      && !satisfies_constraint_L (op1));\n+    }\n+\n+  /* If not, is it a load of a PC-relative address?  */\n+  if (!TARGET_PCREL || GET_MODE (dest) != Pmode)\n+    return false;\n+\n+  if (!SYMBOL_REF_P (src) && !LABEL_REF_P (src) && GET_CODE (src) != CONST)\n+    return false;\n+\n+  enum insn_form iform = address_to_insn_form (src, Pmode,\n+\t\t\t\t\t       NON_PREFIXED_DEFAULT);\n+\n+  return (iform == INSN_FORM_PCREL_EXTERNAL || iform == INSN_FORM_PCREL_LOCAL);\n+}\n+\n+/* Whether the next instruction needs a 'p' prefix issued before the\n+   instruction is printed out.  */\n+static bool prepend_p_to_next_insn;\n+\n+/* Define FINAL_PRESCAN_INSN if some processing needs to be done before\n+   outputting the assembler code.  On the PowerPC, we remember if the current\n+   insn is a prefixed insn where we need to emit a 'p' before the insn.\n+\n+   In addition, if the insn is part of a PC-relative reference to an external\n+   label optimization, this is recorded also.  */\n+void\n+rs6000_final_prescan_insn (rtx_insn *insn, rtx [], int)\n+{\n+  prepend_p_to_next_insn = (get_attr_maybe_prefixed (insn)\n+\t\t\t    == MAYBE_PREFIXED_YES\n+\t\t\t    && get_attr_prefixed (insn) == PREFIXED_YES);\n+  return;\n+}\n+\n+/* Define ASM_OUTPUT_OPCODE to do anything special before emitting an opcode.\n+   We use it to emit a 'p' for prefixed insns that is set in\n+   FINAL_PRESCAN_INSN.  */\n+void\n+rs6000_asm_output_opcode (FILE *stream)\n+{\n+  if (prepend_p_to_next_insn)\n+    {\n+      fprintf (stream, \"p\");\n+\n+      /* Reset the flag in the case where there are separate insn lines in the\n+\t sequence, so the 'p' is only emitted for the first line.  This shows up\n+\t when we are doing the PCREL_OPT optimization, in that the label created\n+\t with %r<n> would have a leading 'p' printed.  */\n+      prepend_p_to_next_insn = false;\n+    }\n+\n+  return;\n+}\n+\n+/* Emit the relocation to tie the next instruction to a previous instruction\n+   that loads up an external address.  This is used to do the PCREL_OPT\n+   optimization.  Note, the label is generated after the PLD of the got\n+   pc-relative address to allow for the assembler to insert NOPs before the PLD\n+   instruction.  The operand is a constant integer that is the label\n+   number.  */\n+\n+void\n+output_pcrel_opt_reloc (rtx label_num)\n+{\n+  rtx operands[1] = { label_num };\n+  output_asm_insn (\".reloc .Lpcrel%0-8,R_PPC64_PCREL_OPT,.-(.Lpcrel%0-8)\",\n+\t\t   operands);\n+}\n+\n+/* Adjust the length of an INSN.  LENGTH is the currently-computed length and\n+   should be adjusted to reflect any required changes.  This macro is used when\n+   there is some systematic length adjustment required that would be difficult\n+   to express in the length attribute.\n+\n+   In the PowerPC, we use this to adjust the length of an instruction if one or\n+   more prefixed instructions are generated, using the attribute\n+   num_prefixed_insns.  A prefixed instruction is 8 bytes instead of 4, but the\n+   hardware requires that a prefied instruciton does not cross a 64-byte\n+   boundary.  This means the compiler has to assume the length of the first\n+   prefixed instruction is 12 bytes instead of 8 bytes.  Since the length is\n+   already set for the non-prefixed instruction, we just need to udpate for the\n+   difference.  */\n+\n+int\n+rs6000_adjust_insn_length (rtx_insn *insn, int length)\n+{\n+  if (TARGET_PREFIXED && NONJUMP_INSN_P (insn))\n+    {\n+      rtx pattern = PATTERN (insn);\n+      if (GET_CODE (pattern) != USE && GET_CODE (pattern) != CLOBBER\n+\t  && get_attr_prefixed (insn) == PREFIXED_YES)\n+\t{\n+\t  int num_prefixed = get_attr_max_prefixed_insns (insn);\n+\t  length += 4 * (num_prefixed + 1);\n+\t}\n+    }\n+\n+  return length;\n+}\n+\n+\f\n+#ifdef HAVE_GAS_HIDDEN\n+# define USE_HIDDEN_LINKONCE 1\n+#else\n+# define USE_HIDDEN_LINKONCE 0\n+#endif\n+\n+/* Fills in the label name that should be used for a 476 link stack thunk.  */\n+\n+void\n+get_ppc476_thunk_name (char name[32])\n+{\n+  gcc_assert (TARGET_LINK_STACK);\n+\n+  if (USE_HIDDEN_LINKONCE)\n+    sprintf (name, \"__ppc476.get_thunk\");\n+  else\n+    ASM_GENERATE_INTERNAL_LABEL (name, \"LPPC476_\", 0);\n }\n \n-/* Whether a store instruction is a prefixed instruction.  This is called from\n-   the prefixed attribute processing.  */\n+/* This function emits the simple thunk routine that is used to preserve\n+   the link stack on the 476 cpu.  */\n \n-bool\n-prefixed_store_p (rtx_insn *insn)\n+static void rs6000_code_end (void) ATTRIBUTE_UNUSED;\n+static void\n+rs6000_code_end (void)\n {\n-  /* Validate the insn to make sure it is a normal store insn.  */\n-  extract_insn_cached (insn);\n-  if (recog_data.n_operands < 2)\n-    return false;\n+  char name[32];\n+  tree decl;\n \n-  rtx mem = recog_data.operand[0];\n-  rtx reg = recog_data.operand[1];\n+  if (!TARGET_LINK_STACK)\n+    return;\n \n-  if (!REG_P (reg) && !SUBREG_P (reg))\n-    return false;\n+  get_ppc476_thunk_name (name);\n \n-  if (!MEM_P (mem))\n-    return false;\n+  decl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL, get_identifier (name),\n+\t\t     build_function_type_list (void_type_node, NULL_TREE));\n+  DECL_RESULT (decl) = build_decl (BUILTINS_LOCATION, RESULT_DECL,\n+\t\t\t\t   NULL_TREE, void_type_node);\n+  TREE_PUBLIC (decl) = 1;\n+  TREE_STATIC (decl) = 1;\n \n-  /* Prefixed store instructions do not support update or indexed forms.  */\n-  if (get_attr_indexed (insn) == INDEXED_YES\n-      || get_attr_update (insn) == UPDATE_YES)\n-    return false;\n+#if RS6000_WEAK\n+  if (USE_HIDDEN_LINKONCE && !TARGET_XCOFF)\n+    {\n+      cgraph_node::create (decl)->set_comdat_group (DECL_ASSEMBLER_NAME (decl));\n+      targetm.asm_out.unique_section (decl, 0);\n+      switch_to_section (get_named_section (decl, NULL, 0));\n+      DECL_WEAK (decl) = 1;\n+      ASM_WEAKEN_DECL (asm_out_file, decl, name, 0);\n+      targetm.asm_out.globalize_label (asm_out_file, name);\n+      targetm.asm_out.assemble_visibility (decl, VISIBILITY_HIDDEN);\n+      ASM_DECLARE_FUNCTION_NAME (asm_out_file, name, decl);\n+    }\n+  else\n+#endif\n+    {\n+      switch_to_section (text_section);\n+      ASM_OUTPUT_LABEL (asm_out_file, name);\n+    }\n \n-  machine_mode mem_mode = GET_MODE (mem);\n-  rtx addr = XEXP (mem, 0);\n-  enum non_prefixed_form non_prefixed = reg_to_non_prefixed (reg, mem_mode);\n+  DECL_INITIAL (decl) = make_node (BLOCK);\n+  current_function_decl = decl;\n+  allocate_struct_function (decl, false);\n+  init_function_start (decl);\n+  first_function_block_is_cold = false;\n+  /* Make sure unwind info is emitted for the thunk if needed.  */\n+  final_start_function (emit_barrier (), asm_out_file, 1);\n \n-  /* Need to make sure we aren't looking at a stfs which doesn't look\n-     like the other things reg_to_non_prefixed/address_is_prefixed\n-     looks for.  */\n-  if (non_prefixed == NON_PREFIXED_X && is_lfs_stfs_insn (insn))\n-    return address_is_prefixed (addr, mem_mode, NON_PREFIXED_DEFAULT);\n-  else\n-    return address_is_prefixed (addr, mem_mode, non_prefixed);\n+  fputs (\"\\tblr\\n\", asm_out_file);\n+\n+  final_end_function ();\n+  init_insn_lengths ();\n+  free_after_compilation (cfun);\n+  set_cfun (NULL);\n+  current_function_decl = NULL;\n }\n \n-/* Whether a load immediate or add instruction is a prefixed instruction.  This\n-   is called from the prefixed attribute processing.  */\n+/* Add r30 to hard reg set if the prologue sets it up and it is not\n+   pic_offset_table_rtx.  */\n \n-bool\n-prefixed_paddi_p (rtx_insn *insn)\n+static void\n+rs6000_set_up_by_prologue (struct hard_reg_set_container *set)\n {\n-  rtx set = single_set (insn);\n-  if (!set)\n-    return false;\n+  if (!TARGET_SINGLE_PIC_BASE\n+      && TARGET_TOC\n+      && TARGET_MINIMAL_TOC\n+      && !constant_pool_empty_p ())\n+    add_to_hard_reg_set (&set->set, Pmode, RS6000_PIC_OFFSET_TABLE_REGNUM);\n+  if (cfun->machine->split_stack_argp_used)\n+    add_to_hard_reg_set (&set->set, Pmode, 12);\n \n-  rtx dest = SET_DEST (set);\n-  rtx src = SET_SRC (set);\n+  /* Make sure the hard reg set doesn't include r2, which was possibly added\n+     via PIC_OFFSET_TABLE_REGNUM.  */\n+  if (TARGET_TOC)\n+    remove_from_hard_reg_set (&set->set, Pmode, TOC_REGNUM);\n+}\n \n-  if (!REG_P (dest) && !SUBREG_P (dest))\n-    return false;\n+\f\n+/* Helper function for rs6000_split_logical to emit a logical instruction after\n+   spliting the operation to single GPR registers.\n \n-  /* Is this a load immediate that can't be done with a simple ADDI or\n-     ADDIS?  */\n-  if (CONST_INT_P (src))\n-    return (satisfies_constraint_eI (src)\n-\t    && !satisfies_constraint_I (src)\n-\t    && !satisfies_constraint_L (src));\n+   DEST is the destination register.\n+   OP1 and OP2 are the input source registers.\n+   CODE is the base operation (AND, IOR, XOR, NOT).\n+   MODE is the machine mode.\n+   If COMPLEMENT_FINAL_P is true, wrap the whole operation with NOT.\n+   If COMPLEMENT_OP1_P is true, wrap operand1 with NOT.\n+   If COMPLEMENT_OP2_P is true, wrap operand2 with NOT.  */\n \n-  /* Is this a PADDI instruction that can't be done with a simple ADDI or\n-     ADDIS?  */\n-  if (GET_CODE (src) == PLUS)\n+static void\n+rs6000_split_logical_inner (rtx dest,\n+\t\t\t    rtx op1,\n+\t\t\t    rtx op2,\n+\t\t\t    enum rtx_code code,\n+\t\t\t    machine_mode mode,\n+\t\t\t    bool complement_final_p,\n+\t\t\t    bool complement_op1_p,\n+\t\t\t    bool complement_op2_p)\n+{\n+  rtx bool_rtx;\n+\n+  /* Optimize AND of 0/0xffffffff and IOR/XOR of 0.  */\n+  if (op2 && CONST_INT_P (op2)\n+      && (mode == SImode || (mode == DImode && TARGET_POWERPC64))\n+      && !complement_final_p && !complement_op1_p && !complement_op2_p)\n     {\n-      rtx op1 = XEXP (src, 1);\n+      HOST_WIDE_INT mask = GET_MODE_MASK (mode);\n+      HOST_WIDE_INT value = INTVAL (op2) & mask;\n \n-      return (CONST_INT_P (op1)\n-\t      && satisfies_constraint_eI (op1)\n-\t      && !satisfies_constraint_I (op1)\n-\t      && !satisfies_constraint_L (op1));\n+      /* Optimize AND of 0 to just set 0.  Optimize AND of -1 to be a move.  */\n+      if (code == AND)\n+\t{\n+\t  if (value == 0)\n+\t    {\n+\t      emit_insn (gen_rtx_SET (dest, const0_rtx));\n+\t      return;\n+\t    }\n+\n+\t  else if (value == mask)\n+\t    {\n+\t      if (!rtx_equal_p (dest, op1))\n+\t\temit_insn (gen_rtx_SET (dest, op1));\n+\t      return;\n+\t    }\n+\t}\n+\n+      /* Optimize IOR/XOR of 0 to be a simple move.  Split large operations\n+\t into separate ORI/ORIS or XORI/XORIS instrucitons.  */\n+      else if (code == IOR || code == XOR)\n+\t{\n+\t  if (value == 0)\n+\t    {\n+\t      if (!rtx_equal_p (dest, op1))\n+\t\temit_insn (gen_rtx_SET (dest, op1));\n+\t      return;\n+\t    }\n+\t}\n     }\n \n-  /* If not, is it a load of a PC-relative address?  */\n-  if (!TARGET_PCREL || GET_MODE (dest) != Pmode)\n-    return false;\n+  if (code == AND && mode == SImode\n+      && !complement_final_p && !complement_op1_p && !complement_op2_p)\n+    {\n+      emit_insn (gen_andsi3 (dest, op1, op2));\n+      return;\n+    }\n \n-  if (!SYMBOL_REF_P (src) && !LABEL_REF_P (src) && GET_CODE (src) != CONST)\n-    return false;\n+  if (complement_op1_p)\n+    op1 = gen_rtx_NOT (mode, op1);\n \n-  enum insn_form iform = address_to_insn_form (src, Pmode,\n-\t\t\t\t\t       NON_PREFIXED_DEFAULT);\n+  if (complement_op2_p)\n+    op2 = gen_rtx_NOT (mode, op2);\n \n-  return (iform == INSN_FORM_PCREL_EXTERNAL || iform == INSN_FORM_PCREL_LOCAL);\n-}\n+  /* For canonical RTL, if only one arm is inverted it is the first.  */\n+  if (!complement_op1_p && complement_op2_p)\n+    std::swap (op1, op2);\n \n-/* Whether the next instruction needs a 'p' prefix issued before the\n-   instruction is printed out.  */\n-static bool prepend_p_to_next_insn;\n+  bool_rtx = ((code == NOT)\n+\t      ? gen_rtx_NOT (mode, op1)\n+\t      : gen_rtx_fmt_ee (code, mode, op1, op2));\n \n-/* Define FINAL_PRESCAN_INSN if some processing needs to be done before\n-   outputting the assembler code.  On the PowerPC, we remember if the current\n-   insn is a prefixed insn where we need to emit a 'p' before the insn.\n+  if (complement_final_p)\n+    bool_rtx = gen_rtx_NOT (mode, bool_rtx);\n \n-   In addition, if the insn is part of a PC-relative reference to an external\n-   label optimization, this is recorded also.  */\n-void\n-rs6000_final_prescan_insn (rtx_insn *insn, rtx [], int)\n-{\n-  prepend_p_to_next_insn = (get_attr_maybe_prefixed (insn)\n-\t\t\t    == MAYBE_PREFIXED_YES\n-\t\t\t    && get_attr_prefixed (insn) == PREFIXED_YES);\n-  return;\n+  emit_insn (gen_rtx_SET (dest, bool_rtx));\n }\n \n-/* Define ASM_OUTPUT_OPCODE to do anything special before emitting an opcode.\n-   We use it to emit a 'p' for prefixed insns that is set in\n-   FINAL_PRESCAN_INSN.  */\n-void\n-rs6000_asm_output_opcode (FILE *stream)\n+/* Split a DImode AND/IOR/XOR with a constant on a 32-bit system.  These\n+   operations are split immediately during RTL generation to allow for more\n+   optimizations of the AND/IOR/XOR.\n+\n+   OPERANDS is an array containing the destination and two input operands.\n+   CODE is the base operation (AND, IOR, XOR, NOT).\n+   MODE is the machine mode.\n+   If COMPLEMENT_FINAL_P is true, wrap the whole operation with NOT.\n+   If COMPLEMENT_OP1_P is true, wrap operand1 with NOT.\n+   If COMPLEMENT_OP2_P is true, wrap operand2 with NOT.\n+   CLOBBER_REG is either NULL or a scratch register of type CC to allow\n+   formation of the AND instructions.  */\n+\n+static void\n+rs6000_split_logical_di (rtx operands[3],\n+\t\t\t enum rtx_code code,\n+\t\t\t bool complement_final_p,\n+\t\t\t bool complement_op1_p,\n+\t\t\t bool complement_op2_p)\n {\n-  if (prepend_p_to_next_insn)\n+  const HOST_WIDE_INT lower_32bits = HOST_WIDE_INT_C(0xffffffff);\n+  const HOST_WIDE_INT upper_32bits = ~ lower_32bits;\n+  const HOST_WIDE_INT sign_bit = HOST_WIDE_INT_C(0x80000000);\n+  enum hi_lo { hi = 0, lo = 1 };\n+  rtx op0_hi_lo[2], op1_hi_lo[2], op2_hi_lo[2];\n+  size_t i;\n+\n+  op0_hi_lo[hi] = gen_highpart (SImode, operands[0]);\n+  op1_hi_lo[hi] = gen_highpart (SImode, operands[1]);\n+  op0_hi_lo[lo] = gen_lowpart (SImode, operands[0]);\n+  op1_hi_lo[lo] = gen_lowpart (SImode, operands[1]);\n+\n+  if (code == NOT)\n+    op2_hi_lo[hi] = op2_hi_lo[lo] = NULL_RTX;\n+  else\n     {\n-      fprintf (stream, \"p\");\n+      if (!CONST_INT_P (operands[2]))\n+\t{\n+\t  op2_hi_lo[hi] = gen_highpart_mode (SImode, DImode, operands[2]);\n+\t  op2_hi_lo[lo] = gen_lowpart (SImode, operands[2]);\n+\t}\n+      else\n+\t{\n+\t  HOST_WIDE_INT value = INTVAL (operands[2]);\n+\t  HOST_WIDE_INT value_hi_lo[2];\n \n-      /* Reset the flag in the case where there are separate insn lines in the\n-\t sequence, so the 'p' is only emitted for the first line.  This shows up\n-\t when we are doing the PCREL_OPT optimization, in that the label created\n-\t with %r<n> would have a leading 'p' printed.  */\n-      prepend_p_to_next_insn = false;\n-    }\n+\t  gcc_assert (!complement_final_p);\n+\t  gcc_assert (!complement_op1_p);\n+\t  gcc_assert (!complement_op2_p);\n \n-  return;\n-}\n+\t  value_hi_lo[hi] = value >> 32;\n+\t  value_hi_lo[lo] = value & lower_32bits;\n \n-/* Emit the relocation to tie the next instruction to a previous instruction\n-   that loads up an external address.  This is used to do the PCREL_OPT\n-   optimization.  Note, the label is generated after the PLD of the got\n-   pc-relative address to allow for the assembler to insert NOPs before the PLD\n-   instruction.  The operand is a constant integer that is the label\n-   number.  */\n+\t  for (i = 0; i < 2; i++)\n+\t    {\n+\t      HOST_WIDE_INT sub_value = value_hi_lo[i];\n \n-void\n-output_pcrel_opt_reloc (rtx label_num)\n-{\n-  rtx operands[1] = { label_num };\n-  output_asm_insn (\".reloc .Lpcrel%0-8,R_PPC64_PCREL_OPT,.-(.Lpcrel%0-8)\",\n-\t\t   operands);\n-}\n+\t      if (sub_value & sign_bit)\n+\t\tsub_value |= upper_32bits;\n \n-/* Adjust the length of an INSN.  LENGTH is the currently-computed length and\n-   should be adjusted to reflect any required changes.  This macro is used when\n-   there is some systematic length adjustment required that would be difficult\n-   to express in the length attribute.\n+\t      op2_hi_lo[i] = GEN_INT (sub_value);\n \n-   In the PowerPC, we use this to adjust the length of an instruction if one or\n-   more prefixed instructions are generated, using the attribute\n-   num_prefixed_insns.  A prefixed instruction is 8 bytes instead of 4, but the\n-   hardware requires that a prefied instruciton does not cross a 64-byte\n-   boundary.  This means the compiler has to assume the length of the first\n-   prefixed instruction is 12 bytes instead of 8 bytes.  Since the length is\n-   already set for the non-prefixed instruction, we just need to udpate for the\n-   difference.  */\n+\t      /* If this is an AND instruction, check to see if we need to load\n+\t\t the value in a register.  */\n+\t      if (code == AND && sub_value != -1 && sub_value != 0\n+\t\t  && !and_operand (op2_hi_lo[i], SImode))\n+\t\top2_hi_lo[i] = force_reg (SImode, op2_hi_lo[i]);\n+\t    }\n+\t}\n+    }\n \n-int\n-rs6000_adjust_insn_length (rtx_insn *insn, int length)\n-{\n-  if (TARGET_PREFIXED && NONJUMP_INSN_P (insn))\n+  for (i = 0; i < 2; i++)\n     {\n-      rtx pattern = PATTERN (insn);\n-      if (GET_CODE (pattern) != USE && GET_CODE (pattern) != CLOBBER\n-\t  && get_attr_prefixed (insn) == PREFIXED_YES)\n+      /* Split large IOR/XOR operations.  */\n+      if ((code == IOR || code == XOR)\n+\t  && CONST_INT_P (op2_hi_lo[i])\n+\t  && !complement_final_p\n+\t  && !complement_op1_p\n+\t  && !complement_op2_p\n+\t  && !logical_const_operand (op2_hi_lo[i], SImode))\n \t{\n-\t  int num_prefixed = get_attr_max_prefixed_insns (insn);\n-\t  length += 4 * (num_prefixed + 1);\n+\t  HOST_WIDE_INT value = INTVAL (op2_hi_lo[i]);\n+\t  HOST_WIDE_INT hi_16bits = value & HOST_WIDE_INT_C(0xffff0000);\n+\t  HOST_WIDE_INT lo_16bits = value & HOST_WIDE_INT_C(0x0000ffff);\n+\t  rtx tmp = gen_reg_rtx (SImode);\n+\n+\t  /* Make sure the constant is sign extended.  */\n+\t  if ((hi_16bits & sign_bit) != 0)\n+\t    hi_16bits |= upper_32bits;\n+\n+\t  rs6000_split_logical_inner (tmp, op1_hi_lo[i], GEN_INT (hi_16bits),\n+\t\t\t\t      code, SImode, false, false, false);\n+\n+\t  rs6000_split_logical_inner (op0_hi_lo[i], tmp, GEN_INT (lo_16bits),\n+\t\t\t\t      code, SImode, false, false, false);\n \t}\n+      else\n+\trs6000_split_logical_inner (op0_hi_lo[i], op1_hi_lo[i], op2_hi_lo[i],\n+\t\t\t\t    code, SImode, complement_final_p,\n+\t\t\t\t    complement_op1_p, complement_op2_p);\n     }\n \n-  return length;\n+  return;\n }\n \n-\f\n-#ifdef HAVE_GAS_HIDDEN\n-# define USE_HIDDEN_LINKONCE 1\n-#else\n-# define USE_HIDDEN_LINKONCE 0\n-#endif\n+/* Split the insns that make up boolean operations operating on multiple GPR\n+   registers.  The boolean MD patterns ensure that the inputs either are\n+   exactly the same as the output registers, or there is no overlap.\n \n-/* Fills in the label name that should be used for a 476 link stack thunk.  */\n+   OPERANDS is an array containing the destination and two input operands.\n+   CODE is the base operation (AND, IOR, XOR, NOT).\n+   If COMPLEMENT_FINAL_P is true, wrap the whole operation with NOT.\n+   If COMPLEMENT_OP1_P is true, wrap operand1 with NOT.\n+   If COMPLEMENT_OP2_P is true, wrap operand2 with NOT.  */\n \n void\n-get_ppc476_thunk_name (char name[32])\n+rs6000_split_logical (rtx operands[3],\n+\t\t      enum rtx_code code,\n+\t\t      bool complement_final_p,\n+\t\t      bool complement_op1_p,\n+\t\t      bool complement_op2_p)\n {\n-  gcc_assert (TARGET_LINK_STACK);\n-\n-  if (USE_HIDDEN_LINKONCE)\n-    sprintf (name, \"__ppc476.get_thunk\");\n-  else\n-    ASM_GENERATE_INTERNAL_LABEL (name, \"LPPC476_\", 0);\n-}\n+  machine_mode mode = GET_MODE (operands[0]);\n+  machine_mode sub_mode;\n+  rtx op0, op1, op2;\n+  int sub_size, regno0, regno1, nregs, i;\n \n-/* This function emits the simple thunk routine that is used to preserve\n-   the link stack on the 476 cpu.  */\n+  /* If this is DImode, use the specialized version that can run before\n+     register allocation.  */\n+  if (mode == DImode && !TARGET_POWERPC64)\n+    {\n+      rs6000_split_logical_di (operands, code, complement_final_p,\n+\t\t\t       complement_op1_p, complement_op2_p);\n+      return;\n+    }\n \n-static void rs6000_code_end (void) ATTRIBUTE_UNUSED;\n-static void\n-rs6000_code_end (void)\n-{\n-  char name[32];\n-  tree decl;\n+  op0 = operands[0];\n+  op1 = operands[1];\n+  op2 = (code == NOT) ? NULL_RTX : operands[2];\n+  sub_mode = (TARGET_POWERPC64) ? DImode : SImode;\n+  sub_size = GET_MODE_SIZE (sub_mode);\n+  regno0 = REGNO (op0);\n+  regno1 = REGNO (op1);\n \n-  if (!TARGET_LINK_STACK)\n-    return;\n+  gcc_assert (reload_completed);\n+  gcc_assert (IN_RANGE (regno0, FIRST_GPR_REGNO, LAST_GPR_REGNO));\n+  gcc_assert (IN_RANGE (regno1, FIRST_GPR_REGNO, LAST_GPR_REGNO));\n \n-  get_ppc476_thunk_name (name);\n+  nregs = rs6000_hard_regno_nregs[(int)mode][regno0];\n+  gcc_assert (nregs > 1);\n \n-  decl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL, get_identifier (name),\n-\t\t     build_function_type_list (void_type_node, NULL_TREE));\n-  DECL_RESULT (decl) = build_decl (BUILTINS_LOCATION, RESULT_DECL,\n-\t\t\t\t   NULL_TREE, void_type_node);\n-  TREE_PUBLIC (decl) = 1;\n-  TREE_STATIC (decl) = 1;\n+  if (op2 && REG_P (op2))\n+    gcc_assert (IN_RANGE (REGNO (op2), FIRST_GPR_REGNO, LAST_GPR_REGNO));\n \n-#if RS6000_WEAK\n-  if (USE_HIDDEN_LINKONCE && !TARGET_XCOFF)\n-    {\n-      cgraph_node::create (decl)->set_comdat_group (DECL_ASSEMBLER_NAME (decl));\n-      targetm.asm_out.unique_section (decl, 0);\n-      switch_to_section (get_named_section (decl, NULL, 0));\n-      DECL_WEAK (decl) = 1;\n-      ASM_WEAKEN_DECL (asm_out_file, decl, name, 0);\n-      targetm.asm_out.globalize_label (asm_out_file, name);\n-      targetm.asm_out.assemble_visibility (decl, VISIBILITY_HIDDEN);\n-      ASM_DECLARE_FUNCTION_NAME (asm_out_file, name, decl);\n-    }\n-  else\n-#endif\n+  for (i = 0; i < nregs; i++)\n     {\n-      switch_to_section (text_section);\n-      ASM_OUTPUT_LABEL (asm_out_file, name);\n-    }\n-\n-  DECL_INITIAL (decl) = make_node (BLOCK);\n-  current_function_decl = decl;\n-  allocate_struct_function (decl, false);\n-  init_function_start (decl);\n-  first_function_block_is_cold = false;\n-  /* Make sure unwind info is emitted for the thunk if needed.  */\n-  final_start_function (emit_barrier (), asm_out_file, 1);\n+      int offset = i * sub_size;\n+      rtx sub_op0 = simplify_subreg (sub_mode, op0, mode, offset);\n+      rtx sub_op1 = simplify_subreg (sub_mode, op1, mode, offset);\n+      rtx sub_op2 = ((code == NOT)\n+\t\t     ? NULL_RTX\n+\t\t     : simplify_subreg (sub_mode, op2, mode, offset));\n \n-  fputs (\"\\tblr\\n\", asm_out_file);\n+      rs6000_split_logical_inner (sub_op0, sub_op1, sub_op2, code, sub_mode,\n+\t\t\t\t  complement_final_p, complement_op1_p,\n+\t\t\t\t  complement_op2_p);\n+    }\n \n-  final_end_function ();\n-  init_insn_lengths ();\n-  free_after_compilation (cfun);\n-  set_cfun (NULL);\n-  current_function_decl = NULL;\n+  return;\n }\n \n-/* Add r30 to hard reg set if the prologue sets it up and it is not\n-   pic_offset_table_rtx.  */\n+/* Emit instructions to move SRC to DST.  Called by splitters for\n+   multi-register moves.  It will emit at most one instruction for\n+   each register that is accessed; that is, it won't emit li/lis pairs\n+   (or equivalent for 64-bit code).  One of SRC or DST must be a hard\n+   register.  */\n \n-static void\n-rs6000_set_up_by_prologue (struct hard_reg_set_container *set)\n+void\n+rs6000_split_multireg_move (rtx dst, rtx src)\n {\n-  if (!TARGET_SINGLE_PIC_BASE\n-      && TARGET_TOC\n-      && TARGET_MINIMAL_TOC\n-      && !constant_pool_empty_p ())\n-    add_to_hard_reg_set (&set->set, Pmode, RS6000_PIC_OFFSET_TABLE_REGNUM);\n-  if (cfun->machine->split_stack_argp_used)\n-    add_to_hard_reg_set (&set->set, Pmode, 12);\n+  /* The register number of the first register being moved.  */\n+  int reg;\n+  /* The mode that is to be moved.  */\n+  machine_mode mode;\n+  /* The mode that the move is being done in, and its size.  */\n+  machine_mode reg_mode;\n+  int reg_mode_size;\n+  /* The number of registers that will be moved.  */\n+  int nregs;\n \n-  /* Make sure the hard reg set doesn't include r2, which was possibly added\n-     via PIC_OFFSET_TABLE_REGNUM.  */\n-  if (TARGET_TOC)\n-    remove_from_hard_reg_set (&set->set, Pmode, TOC_REGNUM);\n-}\n+  reg = REG_P (dst) ? REGNO (dst) : REGNO (src);\n+  mode = GET_MODE (dst);\n+  nregs = hard_regno_nregs (reg, mode);\n \n-\f\n-/* Helper function for rs6000_split_logical to emit a logical instruction after\n-   spliting the operation to single GPR registers.\n+  /* If we have a vector quad register for MMA, and this is a load or store,\n+     see if we can use vector paired load/stores.  */\n+  if (mode == XOmode && TARGET_MMA\n+      && (MEM_P (dst) || MEM_P (src)))\n+    {\n+      reg_mode = OOmode;\n+      nregs /= 2;\n+    }\n+  /* If we have a vector pair/quad mode, split it into two/four separate\n+     vectors.  */\n+  else if (mode == OOmode || mode == XOmode)\n+    reg_mode = V1TImode;\n+  else if (FP_REGNO_P (reg))\n+    reg_mode = DECIMAL_FLOAT_MODE_P (mode) ? DDmode :\n+\t(TARGET_HARD_FLOAT ? DFmode : SFmode);\n+  else if (ALTIVEC_REGNO_P (reg))\n+    reg_mode = V16QImode;\n+  else\n+    reg_mode = word_mode;\n+  reg_mode_size = GET_MODE_SIZE (reg_mode);\n \n-   DEST is the destination register.\n-   OP1 and OP2 are the input source registers.\n-   CODE is the base operation (AND, IOR, XOR, NOT).\n-   MODE is the machine mode.\n-   If COMPLEMENT_FINAL_P is true, wrap the whole operation with NOT.\n-   If COMPLEMENT_OP1_P is true, wrap operand1 with NOT.\n-   If COMPLEMENT_OP2_P is true, wrap operand2 with NOT.  */\n+  gcc_assert (reg_mode_size * nregs == GET_MODE_SIZE (mode));\n \n-static void\n-rs6000_split_logical_inner (rtx dest,\n-\t\t\t    rtx op1,\n-\t\t\t    rtx op2,\n-\t\t\t    enum rtx_code code,\n-\t\t\t    machine_mode mode,\n-\t\t\t    bool complement_final_p,\n-\t\t\t    bool complement_op1_p,\n-\t\t\t    bool complement_op2_p)\n-{\n-  rtx bool_rtx;\n+  /* TDmode residing in FP registers is special, since the ISA requires that\n+     the lower-numbered word of a register pair is always the most significant\n+     word, even in little-endian mode.  This does not match the usual subreg\n+     semantics, so we cannnot use simplify_gen_subreg in those cases.  Access\n+     the appropriate constituent registers \"by hand\" in little-endian mode.\n \n-  /* Optimize AND of 0/0xffffffff and IOR/XOR of 0.  */\n-  if (op2 && CONST_INT_P (op2)\n-      && (mode == SImode || (mode == DImode && TARGET_POWERPC64))\n-      && !complement_final_p && !complement_op1_p && !complement_op2_p)\n+     Note we do not need to check for destructive overlap here since TDmode\n+     can only reside in even/odd register pairs.  */\n+  if (FP_REGNO_P (reg) && DECIMAL_FLOAT_MODE_P (mode) && !BYTES_BIG_ENDIAN)\n     {\n-      HOST_WIDE_INT mask = GET_MODE_MASK (mode);\n-      HOST_WIDE_INT value = INTVAL (op2) & mask;\n+      rtx p_src, p_dst;\n+      int i;\n \n-      /* Optimize AND of 0 to just set 0.  Optimize AND of -1 to be a move.  */\n-      if (code == AND)\n+      for (i = 0; i < nregs; i++)\n \t{\n-\t  if (value == 0)\n-\t    {\n-\t      emit_insn (gen_rtx_SET (dest, const0_rtx));\n-\t      return;\n-\t    }\n+\t  if (REG_P (src) && FP_REGNO_P (REGNO (src)))\n+\t    p_src = gen_rtx_REG (reg_mode, REGNO (src) + nregs - 1 - i);\n+\t  else\n+\t    p_src = simplify_gen_subreg (reg_mode, src, mode,\n+\t\t\t\t\t i * reg_mode_size);\n \n-\t  else if (value == mask)\n-\t    {\n-\t      if (!rtx_equal_p (dest, op1))\n-\t\temit_insn (gen_rtx_SET (dest, op1));\n-\t      return;\n-\t    }\n-\t}\n+\t  if (REG_P (dst) && FP_REGNO_P (REGNO (dst)))\n+\t    p_dst = gen_rtx_REG (reg_mode, REGNO (dst) + nregs - 1 - i);\n+\t  else\n+\t    p_dst = simplify_gen_subreg (reg_mode, dst, mode,\n+\t\t\t\t\t i * reg_mode_size);\n \n-      /* Optimize IOR/XOR of 0 to be a simple move.  Split large operations\n-\t into separate ORI/ORIS or XORI/XORIS instrucitons.  */\n-      else if (code == IOR || code == XOR)\n-\t{\n-\t  if (value == 0)\n-\t    {\n-\t      if (!rtx_equal_p (dest, op1))\n-\t\temit_insn (gen_rtx_SET (dest, op1));\n-\t      return;\n-\t    }\n+\t  emit_insn (gen_rtx_SET (p_dst, p_src));\n \t}\n-    }\n \n-  if (code == AND && mode == SImode\n-      && !complement_final_p && !complement_op1_p && !complement_op2_p)\n-    {\n-      emit_insn (gen_andsi3 (dest, op1, op2));\n       return;\n     }\n \n-  if (complement_op1_p)\n-    op1 = gen_rtx_NOT (mode, op1);\n-\n-  if (complement_op2_p)\n-    op2 = gen_rtx_NOT (mode, op2);\n-\n-  /* For canonical RTL, if only one arm is inverted it is the first.  */\n-  if (!complement_op1_p && complement_op2_p)\n-    std::swap (op1, op2);\n-\n-  bool_rtx = ((code == NOT)\n-\t      ? gen_rtx_NOT (mode, op1)\n-\t      : gen_rtx_fmt_ee (code, mode, op1, op2));\n+  /* The __vector_pair and __vector_quad modes are multi-register\n+     modes, so if we have to load or store the registers, we have to be\n+     careful to properly swap them if we're in little endian mode\n+     below.  This means the last register gets the first memory\n+     location.  We also need to be careful of using the right register\n+     numbers if we are splitting XO to OO.  */\n+  if (mode == OOmode || mode == XOmode)\n+    {\n+      nregs = hard_regno_nregs (reg, mode);\n+      int reg_mode_nregs = hard_regno_nregs (reg, reg_mode);\n+      if (MEM_P (dst))\n+\t{\n+\t  unsigned offset = 0;\n+\t  unsigned size = GET_MODE_SIZE (reg_mode);\n \n-  if (complement_final_p)\n-    bool_rtx = gen_rtx_NOT (mode, bool_rtx);\n+\t  /* If we are reading an accumulator register, we have to\n+\t     deprime it before we can access it.  */\n+\t  if (TARGET_MMA\n+\t      && GET_MODE (src) == XOmode && FP_REGNO_P (REGNO (src)))\n+\t    emit_insn (gen_mma_xxmfacc (src, src));\n \n-  emit_insn (gen_rtx_SET (dest, bool_rtx));\n-}\n+\t  for (int i = 0; i < nregs; i += reg_mode_nregs)\n+\t    {\n+\t      unsigned subreg =\n+\t\t(WORDS_BIG_ENDIAN) ? i : (nregs - reg_mode_nregs - i);\n+\t      rtx dst2 = adjust_address (dst, reg_mode, offset);\n+\t      rtx src2 = gen_rtx_REG (reg_mode, reg + subreg);\n+\t      offset += size;\n+\t      emit_insn (gen_rtx_SET (dst2, src2));\n+\t    }\n \n-/* Split a DImode AND/IOR/XOR with a constant on a 32-bit system.  These\n-   operations are split immediately during RTL generation to allow for more\n-   optimizations of the AND/IOR/XOR.\n+\t  return;\n+\t}\n \n-   OPERANDS is an array containing the destination and two input operands.\n-   CODE is the base operation (AND, IOR, XOR, NOT).\n-   MODE is the machine mode.\n-   If COMPLEMENT_FINAL_P is true, wrap the whole operation with NOT.\n-   If COMPLEMENT_OP1_P is true, wrap operand1 with NOT.\n-   If COMPLEMENT_OP2_P is true, wrap operand2 with NOT.\n-   CLOBBER_REG is either NULL or a scratch register of type CC to allow\n-   formation of the AND instructions.  */\n+      if (MEM_P (src))\n+\t{\n+\t  unsigned offset = 0;\n+\t  unsigned size = GET_MODE_SIZE (reg_mode);\n \n-static void\n-rs6000_split_logical_di (rtx operands[3],\n-\t\t\t enum rtx_code code,\n-\t\t\t bool complement_final_p,\n-\t\t\t bool complement_op1_p,\n-\t\t\t bool complement_op2_p)\n-{\n-  const HOST_WIDE_INT lower_32bits = HOST_WIDE_INT_C(0xffffffff);\n-  const HOST_WIDE_INT upper_32bits = ~ lower_32bits;\n-  const HOST_WIDE_INT sign_bit = HOST_WIDE_INT_C(0x80000000);\n-  enum hi_lo { hi = 0, lo = 1 };\n-  rtx op0_hi_lo[2], op1_hi_lo[2], op2_hi_lo[2];\n-  size_t i;\n+\t  for (int i = 0; i < nregs; i += reg_mode_nregs)\n+\t    {\n+\t      unsigned subreg =\n+\t\t(WORDS_BIG_ENDIAN) ? i : (nregs - reg_mode_nregs - i);\n+\t      rtx dst2 = gen_rtx_REG (reg_mode, reg + subreg);\n+\t      rtx src2 = adjust_address (src, reg_mode, offset);\n+\t      offset += size;\n+\t      emit_insn (gen_rtx_SET (dst2, src2));\n+\t    }\n \n-  op0_hi_lo[hi] = gen_highpart (SImode, operands[0]);\n-  op1_hi_lo[hi] = gen_highpart (SImode, operands[1]);\n-  op0_hi_lo[lo] = gen_lowpart (SImode, operands[0]);\n-  op1_hi_lo[lo] = gen_lowpart (SImode, operands[1]);\n+\t  /* If we are writing an accumulator register, we have to\n+\t     prime it after we've written it.  */\n+\t  if (TARGET_MMA\n+\t      && GET_MODE (dst) == XOmode && FP_REGNO_P (REGNO (dst)))\n+\t    emit_insn (gen_mma_xxmtacc (dst, dst));\n \n-  if (code == NOT)\n-    op2_hi_lo[hi] = op2_hi_lo[lo] = NULL_RTX;\n-  else\n-    {\n-      if (!CONST_INT_P (operands[2]))\n-\t{\n-\t  op2_hi_lo[hi] = gen_highpart_mode (SImode, DImode, operands[2]);\n-\t  op2_hi_lo[lo] = gen_lowpart (SImode, operands[2]);\n+\t  return;\n \t}\n-      else\n+\n+      if (GET_CODE (src) == UNSPEC)\n \t{\n-\t  HOST_WIDE_INT value = INTVAL (operands[2]);\n-\t  HOST_WIDE_INT value_hi_lo[2];\n+\t  gcc_assert (XINT (src, 1) == UNSPEC_MMA_ASSEMBLE);\n+\t  gcc_assert (REG_P (dst));\n+\t  if (GET_MODE (src) == XOmode)\n+\t    gcc_assert (FP_REGNO_P (REGNO (dst)));\n+\t  if (GET_MODE (src) == OOmode)\n+\t    gcc_assert (VSX_REGNO_P (REGNO (dst)));\n \n-\t  gcc_assert (!complement_final_p);\n-\t  gcc_assert (!complement_op1_p);\n-\t  gcc_assert (!complement_op2_p);\n+\t  reg_mode = GET_MODE (XVECEXP (src, 0, 0));\n+\t  int nvecs = XVECLEN (src, 0);\n+\t  for (int i = 0; i < nvecs; i++)\n+\t    {\n+\t      int index = WORDS_BIG_ENDIAN ? i : nvecs - 1 - i;\n+\t      rtx dst_i = gen_rtx_REG (reg_mode, reg + index);\n+\t      emit_insn (gen_rtx_SET (dst_i, XVECEXP (src, 0, i)));\n+\t    }\n \n-\t  value_hi_lo[hi] = value >> 32;\n-\t  value_hi_lo[lo] = value & lower_32bits;\n+\t  /* We are writing an accumulator register, so we have to\n+\t     prime it after we've written it.  */\n+\t  if (GET_MODE (src) == XOmode)\n+\t    emit_insn (gen_mma_xxmtacc (dst, dst));\n \n-\t  for (i = 0; i < 2; i++)\n-\t    {\n-\t      HOST_WIDE_INT sub_value = value_hi_lo[i];\n+\t  return;\n+\t}\n \n-\t      if (sub_value & sign_bit)\n-\t\tsub_value |= upper_32bits;\n+      /* Register -> register moves can use common code.  */\n+    }\n \n-\t      op2_hi_lo[i] = GEN_INT (sub_value);\n+  if (REG_P (src) && REG_P (dst) && (REGNO (src) < REGNO (dst)))\n+    {\n+      /* If we are reading an accumulator register, we have to\n+\t deprime it before we can access it.  */\n+      if (TARGET_MMA\n+\t  && GET_MODE (src) == XOmode && FP_REGNO_P (REGNO (src)))\n+\temit_insn (gen_mma_xxmfacc (src, src));\n \n-\t      /* If this is an AND instruction, check to see if we need to load\n-\t\t the value in a register.  */\n-\t      if (code == AND && sub_value != -1 && sub_value != 0\n-\t\t  && !and_operand (op2_hi_lo[i], SImode))\n-\t\top2_hi_lo[i] = force_reg (SImode, op2_hi_lo[i]);\n+      /* Move register range backwards, if we might have destructive\n+\t overlap.  */\n+      int i;\n+      /* XO/OO are opaque so cannot use subregs. */\n+      if (mode == OOmode || mode == XOmode )\n+\t{\n+\t  for (i = nregs - 1; i >= 0; i--)\n+\t    {\n+\t      rtx dst_i = gen_rtx_REG (reg_mode, REGNO (dst) + i);\n+\t      rtx src_i = gen_rtx_REG (reg_mode, REGNO (src) + i);\n+\t      emit_insn (gen_rtx_SET (dst_i, src_i));\n \t    }\n \t}\n-    }\n+      else\n+\t{\n+\t  for (i = nregs - 1; i >= 0; i--)\n+\t    emit_insn (gen_rtx_SET (simplify_gen_subreg (reg_mode, dst, mode,\n+\t\t\t\t\t\t\t i * reg_mode_size),\n+\t\t\t\t    simplify_gen_subreg (reg_mode, src, mode,\n+\t\t\t\t\t\t\t i * reg_mode_size)));\n+\t}\n \n-  for (i = 0; i < 2; i++)\n+      /* If we are writing an accumulator register, we have to\n+\t prime it after we've written it.  */\n+      if (TARGET_MMA\n+\t  && GET_MODE (dst) == XOmode && FP_REGNO_P (REGNO (dst)))\n+\temit_insn (gen_mma_xxmtacc (dst, dst));\n+    }\n+  else\n     {\n-      /* Split large IOR/XOR operations.  */\n-      if ((code == IOR || code == XOR)\n-\t  && CONST_INT_P (op2_hi_lo[i])\n-\t  && !complement_final_p\n-\t  && !complement_op1_p\n-\t  && !complement_op2_p\n-\t  && !logical_const_operand (op2_hi_lo[i], SImode))\n+      int i;\n+      int j = -1;\n+      bool used_update = false;\n+      rtx restore_basereg = NULL_RTX;\n+\n+      if (MEM_P (src) && INT_REGNO_P (reg))\n \t{\n-\t  HOST_WIDE_INT value = INTVAL (op2_hi_lo[i]);\n-\t  HOST_WIDE_INT hi_16bits = value & HOST_WIDE_INT_C(0xffff0000);\n-\t  HOST_WIDE_INT lo_16bits = value & HOST_WIDE_INT_C(0x0000ffff);\n-\t  rtx tmp = gen_reg_rtx (SImode);\n+\t  rtx breg;\n \n-\t  /* Make sure the constant is sign extended.  */\n-\t  if ((hi_16bits & sign_bit) != 0)\n-\t    hi_16bits |= upper_32bits;\n+\t  if (GET_CODE (XEXP (src, 0)) == PRE_INC\n+\t      || GET_CODE (XEXP (src, 0)) == PRE_DEC)\n+\t    {\n+\t      rtx delta_rtx;\n+\t      breg = XEXP (XEXP (src, 0), 0);\n+\t      delta_rtx = (GET_CODE (XEXP (src, 0)) == PRE_INC\n+\t\t\t   ? GEN_INT (GET_MODE_SIZE (GET_MODE (src)))\n+\t\t\t   : GEN_INT (-GET_MODE_SIZE (GET_MODE (src))));\n+\t      emit_insn (gen_add3_insn (breg, breg, delta_rtx));\n+\t      src = replace_equiv_address (src, breg);\n+\t    }\n+\t  else if (! rs6000_offsettable_memref_p (src, reg_mode, true))\n+\t    {\n+\t      if (GET_CODE (XEXP (src, 0)) == PRE_MODIFY)\n+\t\t{\n+\t\t  rtx basereg = XEXP (XEXP (src, 0), 0);\n+\t\t  if (TARGET_UPDATE)\n+\t\t    {\n+\t\t      rtx ndst = simplify_gen_subreg (reg_mode, dst, mode, 0);\n+\t\t      emit_insn (gen_rtx_SET (ndst,\n+\t\t\t\t\t      gen_rtx_MEM (reg_mode,\n+\t\t\t\t\t\t\t   XEXP (src, 0))));\n+\t\t      used_update = true;\n+\t\t    }\n+\t\t  else\n+\t\t    emit_insn (gen_rtx_SET (basereg,\n+\t\t\t\t\t    XEXP (XEXP (src, 0), 1)));\n+\t\t  src = replace_equiv_address (src, basereg);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rtx basereg = gen_rtx_REG (Pmode, reg);\n+\t\t  emit_insn (gen_rtx_SET (basereg, XEXP (src, 0)));\n+\t\t  src = replace_equiv_address (src, basereg);\n+\t\t}\n+\t    }\n \n-\t  rs6000_split_logical_inner (tmp, op1_hi_lo[i], GEN_INT (hi_16bits),\n-\t\t\t\t      code, SImode, false, false, false);\n+\t  breg = XEXP (src, 0);\n+\t  if (GET_CODE (breg) == PLUS || GET_CODE (breg) == LO_SUM)\n+\t    breg = XEXP (breg, 0);\n \n-\t  rs6000_split_logical_inner (op0_hi_lo[i], tmp, GEN_INT (lo_16bits),\n-\t\t\t\t      code, SImode, false, false, false);\n+\t  /* If the base register we are using to address memory is\n+\t     also a destination reg, then change that register last.  */\n+\t  if (REG_P (breg)\n+\t      && REGNO (breg) >= REGNO (dst)\n+\t      && REGNO (breg) < REGNO (dst) + nregs)\n+\t    j = REGNO (breg) - REGNO (dst);\n \t}\n-      else\n-\trs6000_split_logical_inner (op0_hi_lo[i], op1_hi_lo[i], op2_hi_lo[i],\n-\t\t\t\t    code, SImode, complement_final_p,\n-\t\t\t\t    complement_op1_p, complement_op2_p);\n-    }\n-\n-  return;\n-}\n-\n-/* Split the insns that make up boolean operations operating on multiple GPR\n-   registers.  The boolean MD patterns ensure that the inputs either are\n-   exactly the same as the output registers, or there is no overlap.\n+      else if (MEM_P (dst) && INT_REGNO_P (reg))\n+\t{\n+\t  rtx breg;\n \n-   OPERANDS is an array containing the destination and two input operands.\n-   CODE is the base operation (AND, IOR, XOR, NOT).\n-   If COMPLEMENT_FINAL_P is true, wrap the whole operation with NOT.\n-   If COMPLEMENT_OP1_P is true, wrap operand1 with NOT.\n-   If COMPLEMENT_OP2_P is true, wrap operand2 with NOT.  */\n+\t  if (GET_CODE (XEXP (dst, 0)) == PRE_INC\n+\t      || GET_CODE (XEXP (dst, 0)) == PRE_DEC)\n+\t    {\n+\t      rtx delta_rtx;\n+\t      breg = XEXP (XEXP (dst, 0), 0);\n+\t      delta_rtx = (GET_CODE (XEXP (dst, 0)) == PRE_INC\n+\t\t\t   ? GEN_INT (GET_MODE_SIZE (GET_MODE (dst)))\n+\t\t\t   : GEN_INT (-GET_MODE_SIZE (GET_MODE (dst))));\n \n-void\n-rs6000_split_logical (rtx operands[3],\n-\t\t      enum rtx_code code,\n-\t\t      bool complement_final_p,\n-\t\t      bool complement_op1_p,\n-\t\t      bool complement_op2_p)\n-{\n-  machine_mode mode = GET_MODE (operands[0]);\n-  machine_mode sub_mode;\n-  rtx op0, op1, op2;\n-  int sub_size, regno0, regno1, nregs, i;\n+\t      /* We have to update the breg before doing the store.\n+\t\t Use store with update, if available.  */\n \n-  /* If this is DImode, use the specialized version that can run before\n-     register allocation.  */\n-  if (mode == DImode && !TARGET_POWERPC64)\n-    {\n-      rs6000_split_logical_di (operands, code, complement_final_p,\n-\t\t\t       complement_op1_p, complement_op2_p);\n-      return;\n-    }\n+\t      if (TARGET_UPDATE)\n+\t\t{\n+\t\t  rtx nsrc = simplify_gen_subreg (reg_mode, src, mode, 0);\n+\t\t  emit_insn (TARGET_32BIT\n+\t\t\t     ? (TARGET_POWERPC64\n+\t\t\t\t? gen_movdi_si_update (breg, breg, delta_rtx, nsrc)\n+\t\t\t\t: gen_movsi_si_update (breg, breg, delta_rtx, nsrc))\n+\t\t\t     : gen_movdi_di_update (breg, breg, delta_rtx, nsrc));\n+\t\t  used_update = true;\n+\t\t}\n+\t      else\n+\t\temit_insn (gen_add3_insn (breg, breg, delta_rtx));\n+\t      dst = replace_equiv_address (dst, breg);\n+\t    }\n+\t  else if (!rs6000_offsettable_memref_p (dst, reg_mode, true)\n+\t\t   && GET_CODE (XEXP (dst, 0)) != LO_SUM)\n+\t    {\n+\t      if (GET_CODE (XEXP (dst, 0)) == PRE_MODIFY)\n+\t\t{\n+\t\t  rtx basereg = XEXP (XEXP (dst, 0), 0);\n+\t\t  if (TARGET_UPDATE)\n+\t\t    {\n+\t\t      rtx nsrc = simplify_gen_subreg (reg_mode, src, mode, 0);\n+\t\t      emit_insn (gen_rtx_SET (gen_rtx_MEM (reg_mode,\n+\t\t\t\t\t\t\t   XEXP (dst, 0)),\n+\t\t\t\t\t      nsrc));\n+\t\t      used_update = true;\n+\t\t    }\n+\t\t  else\n+\t\t    emit_insn (gen_rtx_SET (basereg,\n+\t\t\t\t\t    XEXP (XEXP (dst, 0), 1)));\n+\t\t  dst = replace_equiv_address (dst, basereg);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rtx basereg = XEXP (XEXP (dst, 0), 0);\n+\t\t  rtx offsetreg = XEXP (XEXP (dst, 0), 1);\n+\t\t  gcc_assert (GET_CODE (XEXP (dst, 0)) == PLUS\n+\t\t\t      && REG_P (basereg)\n+\t\t\t      && REG_P (offsetreg)\n+\t\t\t      && REGNO (basereg) != REGNO (offsetreg));\n+\t\t  if (REGNO (basereg) == 0)\n+\t\t    {\n+\t\t      rtx tmp = offsetreg;\n+\t\t      offsetreg = basereg;\n+\t\t      basereg = tmp;\n+\t\t    }\n+\t\t  emit_insn (gen_add3_insn (basereg, basereg, offsetreg));\n+\t\t  restore_basereg = gen_sub3_insn (basereg, basereg, offsetreg);\n+\t\t  dst = replace_equiv_address (dst, basereg);\n+\t\t}\n+\t    }\n+\t  else if (GET_CODE (XEXP (dst, 0)) != LO_SUM)\n+\t    gcc_assert (rs6000_offsettable_memref_p (dst, reg_mode, true));\n+\t}\n \n-  op0 = operands[0];\n-  op1 = operands[1];\n-  op2 = (code == NOT) ? NULL_RTX : operands[2];\n-  sub_mode = (TARGET_POWERPC64) ? DImode : SImode;\n-  sub_size = GET_MODE_SIZE (sub_mode);\n-  regno0 = REGNO (op0);\n-  regno1 = REGNO (op1);\n+      /* If we are reading an accumulator register, we have to\n+\t deprime it before we can access it.  */\n+      if (TARGET_MMA && REG_P (src)\n+\t  && GET_MODE (src) == XOmode && FP_REGNO_P (REGNO (src)))\n+\temit_insn (gen_mma_xxmfacc (src, src));\n \n-  gcc_assert (reload_completed);\n-  gcc_assert (IN_RANGE (regno0, FIRST_GPR_REGNO, LAST_GPR_REGNO));\n-  gcc_assert (IN_RANGE (regno1, FIRST_GPR_REGNO, LAST_GPR_REGNO));\n+      for (i = 0; i < nregs; i++)\n+\t{\n+\t  /* Calculate index to next subword.  */\n+\t  ++j;\n+\t  if (j == nregs)\n+\t    j = 0;\n \n-  nregs = rs6000_hard_regno_nregs[(int)mode][regno0];\n-  gcc_assert (nregs > 1);\n+\t  /* If compiler already emitted move of first word by\n+\t     store with update, no need to do anything.  */\n+\t  if (j == 0 && used_update)\n+\t    continue;\n \n-  if (op2 && REG_P (op2))\n-    gcc_assert (IN_RANGE (REGNO (op2), FIRST_GPR_REGNO, LAST_GPR_REGNO));\n+\t  /* XO/OO are opaque so cannot use subregs. */\n+\t  if (mode == OOmode || mode == XOmode )\n+\t    {\n+\t      rtx dst_i = gen_rtx_REG (reg_mode, REGNO (dst) + j);\n+\t      rtx src_i = gen_rtx_REG (reg_mode, REGNO (src) + j);\n+\t      emit_insn (gen_rtx_SET (dst_i, src_i));\n+\t    }\n+\t  else\n+\t    emit_insn (gen_rtx_SET (simplify_gen_subreg (reg_mode, dst, mode,\n+\t\t\t\t\t\t\t j * reg_mode_size),\n+\t\t\t\t    simplify_gen_subreg (reg_mode, src, mode,\n+\t\t\t\t\t\t\t j * reg_mode_size)));\n+\t}\n \n-  for (i = 0; i < nregs; i++)\n-    {\n-      int offset = i * sub_size;\n-      rtx sub_op0 = simplify_subreg (sub_mode, op0, mode, offset);\n-      rtx sub_op1 = simplify_subreg (sub_mode, op1, mode, offset);\n-      rtx sub_op2 = ((code == NOT)\n-\t\t     ? NULL_RTX\n-\t\t     : simplify_subreg (sub_mode, op2, mode, offset));\n+      /* If we are writing an accumulator register, we have to\n+\t prime it after we've written it.  */\n+      if (TARGET_MMA && REG_P (dst)\n+\t  && GET_MODE (dst) == XOmode && FP_REGNO_P (REGNO (dst)))\n+\temit_insn (gen_mma_xxmtacc (dst, dst));\n \n-      rs6000_split_logical_inner (sub_op0, sub_op1, sub_op2, code, sub_mode,\n-\t\t\t\t  complement_final_p, complement_op1_p,\n-\t\t\t\t  complement_op2_p);\n+      if (restore_basereg != NULL_RTX)\n+\temit_insn (restore_basereg);\n     }\n-\n-  return;\n }\n-\n \f\n /* Return true if the peephole2 can combine a load involving a combination of\n    an addis instruction and a load with an offset that can be fused together on"}]}