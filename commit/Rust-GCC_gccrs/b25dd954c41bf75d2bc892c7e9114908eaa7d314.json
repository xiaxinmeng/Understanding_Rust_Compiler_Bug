{"sha": "b25dd954c41bf75d2bc892c7e9114908eaa7d314", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI1ZGQ5NTRjNDFiZjc1ZDJiYzg5MmM3ZTkxMTQ5MDhlYWE3ZDMxNA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2011-11-04T12:54:08Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-11-04T12:54:08Z"}, "message": "re PR c++/48370 (G++ fails to extend reference temporary lifetime in some situations)\n\n\tPR c++/48370\n\t* call.c (extend_ref_init_temps, extend_ref_init_temps_1): New.\n\t(set_up_extended_ref_temp): Use it.  Change cleanup parm to VEC.\n\t(initialize_reference): Just call convert_like.\n\t* decl.c (grok_reference_init): Just call initialize_reference.\n\t(build_init_list_var_init): Remove.\n\t(check_initializer): Change cleanup parm to VEC.  Handle references\n\tlike other types.  Call perform_implicit_conversion instead\n\tof build_init_list_var_init.  Don't use build_aggr_init for\n\taggregate initialization of arrays.\n\t(cp_finish_decl): Change cleanup to VEC.\n\t* typeck2.c (store_init_value): Call extend_ref_init_temps.\n\tUse build_vec_init for non-constant arrays.\n\t* init.c (expand_aggr_init_1): Adjust.\n\t(build_vec_init): Avoid re-converting an initializer\n\tthat's already digested.\n\t* mangle.c (mangle_ref_init_variable): Add a discriminator.\n\t* cp-tree.h: Adjust.\n\t* typeck.c (convert_for_initialization): Adjust.\n\t* decl2.c (maybe_emit_vtables): Adjust.\n\nFrom-SVN: r180944", "tree": {"sha": "2aea6e5048d38c60ba565aa04710e5fa10eeeadd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2aea6e5048d38c60ba565aa04710e5fa10eeeadd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b25dd954c41bf75d2bc892c7e9114908eaa7d314", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b25dd954c41bf75d2bc892c7e9114908eaa7d314", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b25dd954c41bf75d2bc892c7e9114908eaa7d314", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b25dd954c41bf75d2bc892c7e9114908eaa7d314/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5972791c345f8e0a750ab5e5cde189ba5064d118", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5972791c345f8e0a750ab5e5cde189ba5064d118", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5972791c345f8e0a750ab5e5cde189ba5064d118"}], "stats": {"total": 503, "additions": 310, "deletions": 193}, "files": [{"sha": "6f9d3c951c000a0993eaa5758e6e1bc6e45dbc80", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b25dd954c41bf75d2bc892c7e9114908eaa7d314", "patch": "@@ -1,3 +1,26 @@\n+2011-11-04  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/48370\n+\t* call.c (extend_ref_init_temps, extend_ref_init_temps_1): New.\n+\t(set_up_extended_ref_temp): Use it.  Change cleanup parm to VEC.\n+\t(initialize_reference): Just call convert_like.\n+\t* decl.c (grok_reference_init): Just call initialize_reference.\n+\t(build_init_list_var_init): Remove.\n+\t(check_initializer): Change cleanup parm to VEC.  Handle references\n+\tlike other types.  Call perform_implicit_conversion instead\n+\tof build_init_list_var_init.  Don't use build_aggr_init for\n+\taggregate initialization of arrays.\n+\t(cp_finish_decl): Change cleanup to VEC.\n+\t* typeck2.c (store_init_value): Call extend_ref_init_temps.\n+\tUse build_vec_init for non-constant arrays.\n+\t* init.c (expand_aggr_init_1): Adjust.\n+\t(build_vec_init): Avoid re-converting an initializer\n+\tthat's already digested.\n+\t* mangle.c (mangle_ref_init_variable): Add a discriminator.\n+\t* cp-tree.h: Adjust.\n+\t* typeck.c (convert_for_initialization): Adjust.\n+\t* decl2.c (maybe_emit_vtables): Adjust.\n+\n 2011-11-02  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/50930"}, {"sha": "4d7facc6cda110e8b83ad7232743b8a7ddce1c7f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 112, "deletions": 98, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=b25dd954c41bf75d2bc892c7e9114908eaa7d314", "patch": "@@ -8502,6 +8502,44 @@ perform_direct_initialization_if_possible (tree type,\n   return expr;\n }\n \n+/* When initializing a reference that lasts longer than a full-expression,\n+   this special rule applies:\n+\n+     [class.temporary]\n+\n+     The temporary to which the reference is bound or the temporary\n+     that is the complete object to which the reference is bound\n+     persists for the lifetime of the reference.\n+\n+     The temporaries created during the evaluation of the expression\n+     initializing the reference, except the temporary to which the\n+     reference is bound, are destroyed at the end of the\n+     full-expression in which they are created.\n+\n+   In that case, we store the converted expression into a new\n+   VAR_DECL in a new scope.\n+\n+   However, we want to be careful not to create temporaries when\n+   they are not required.  For example, given:\n+\n+     struct B {};\n+     struct D : public B {};\n+     D f();\n+     const B& b = f();\n+\n+   there is no need to copy the return value from \"f\"; we can just\n+   extend its lifetime.  Similarly, given:\n+\n+     struct S {};\n+     struct T { operator S(); };\n+     T t;\n+     const S& s = t;\n+\n+  we can extend the lifetime of the return value of the conversion\n+  operator.\n+\n+  The next several functions are involved in this lifetime extension.  */\n+\n /* DECL is a VAR_DECL whose type is a REFERENCE_TYPE.  The reference\n    is being bound to a temporary.  Create and return a new VAR_DECL\n    with the indicated TYPE; this variable will store the value to\n@@ -8519,6 +8557,7 @@ make_temporary_var_for_ref_to_temp (tree decl, tree type)\n   if (TREE_STATIC (decl))\n     {\n       /* Namespace-scope or local static; give it a mangled name.  */\n+      /* FIXME share comdat with decl?  */\n       tree name;\n \n       TREE_STATIC (var) = 1;\n@@ -8540,8 +8579,9 @@ make_temporary_var_for_ref_to_temp (tree decl, tree type)\n    cleanup for the new variable is returned through CLEANUP, and the\n    code to initialize the new variable is returned through INITP.  */\n \n-tree\n-set_up_extended_ref_temp (tree decl, tree expr, tree *cleanup, tree *initp)\n+static tree\n+set_up_extended_ref_temp (tree decl, tree expr, VEC(tree,gc) **cleanups,\n+\t\t\t  tree *initp)\n {\n   tree init;\n   tree type;\n@@ -8562,6 +8602,10 @@ set_up_extended_ref_temp (tree decl, tree expr, tree *cleanup, tree *initp)\n   if (TREE_CODE (expr) != TARGET_EXPR)\n     expr = get_target_expr (expr);\n \n+  /* Recursively extend temps in this initializer.  */\n+  TARGET_EXPR_INITIAL (expr)\n+    = extend_ref_init_temps (decl, TARGET_EXPR_INITIAL (expr), cleanups);\n+\n   /* If the initializer is constant, put it in DECL_INITIAL so we get\n      static initialization and use in constant expressions.  */\n   init = maybe_constant_init (expr);\n@@ -8595,7 +8639,11 @@ set_up_extended_ref_temp (tree decl, tree expr, tree *cleanup, tree *initp)\n       if (TREE_STATIC (var))\n \tinit = add_stmt_to_compound (init, register_dtor_fn (var));\n       else\n-\t*cleanup = cxx_maybe_build_cleanup (var, tf_warning_or_error);\n+\t{\n+\t  tree cleanup = cxx_maybe_build_cleanup (var, tf_warning_or_error);\n+\t  if (cleanup)\n+\t    VEC_safe_push (tree, gc, *cleanups, cleanup);\n+\t}\n \n       /* We must be careful to destroy the temporary only\n \t after its initialization has taken place.  If the\n@@ -8629,18 +8677,10 @@ set_up_extended_ref_temp (tree decl, tree expr, tree *cleanup, tree *initp)\n }\n \n /* Convert EXPR to the indicated reference TYPE, in a way suitable for\n-   initializing a variable of that TYPE.  If DECL is non-NULL, it is\n-   the VAR_DECL being initialized with the EXPR.  (In that case, the\n-   type of DECL will be TYPE.)  If DECL is non-NULL, then CLEANUP must\n-   also be non-NULL, and with *CLEANUP initialized to NULL.  Upon\n-   return, if *CLEANUP is no longer NULL, it will be an expression\n-   that should be pushed as a cleanup after the returned expression\n-   is used to initialize DECL.\n-\n-   Return the converted expression.  */\n+   initializing a variable of that TYPE.  */\n \n tree\n-initialize_reference (tree type, tree expr, tree decl, tree *cleanup,\n+initialize_reference (tree type, tree expr,\n \t\t      int flags, tsubst_flags_t complain)\n {\n   conversion *conv;\n@@ -8674,103 +8714,77 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup,\n       return error_mark_node;\n     }\n \n-  /* If DECL is non-NULL, then this special rule applies:\n-\n-       [class.temporary]\n-\n-       The temporary to which the reference is bound or the temporary\n-       that is the complete object to which the reference is bound\n-       persists for the lifetime of the reference.\n+  gcc_assert (conv->kind == ck_ref_bind);\n \n-       The temporaries created during the evaluation of the expression\n-       initializing the reference, except the temporary to which the\n-       reference is bound, are destroyed at the end of the\n-       full-expression in which they are created.\n+  /* Perform the conversion.  */\n+  expr = convert_like (conv, expr, complain);\n \n-     In that case, we store the converted expression into a new\n-     VAR_DECL in a new scope.\n+  /* Free all the conversions we allocated.  */\n+  obstack_free (&conversion_obstack, p);\n \n-     However, we want to be careful not to create temporaries when\n-     they are not required.  For example, given:\n+  return expr;\n+}\n \n-       struct B {};\n-       struct D : public B {};\n-       D f();\n-       const B& b = f();\n+/* Subroutine of extend_ref_init_temps.  Possibly extend one initializer,\n+   which is bound either to a reference or a std::initializer_list.  */\n \n-     there is no need to copy the return value from \"f\"; we can just\n-     extend its lifetime.  Similarly, given:\n+static tree\n+extend_ref_init_temps_1 (tree decl, tree init, VEC(tree,gc) **cleanups)\n+{\n+  tree sub = init;\n+  tree *p;\n+  STRIP_NOPS (sub);\n+  if (TREE_CODE (sub) != ADDR_EXPR)\n+    return init;\n+  /* Deal with binding to a subobject.  */\n+  for (p = &TREE_OPERAND (sub, 0); TREE_CODE (*p) == COMPONENT_REF; )\n+    p = &TREE_OPERAND (*p, 0);\n+  if (TREE_CODE (*p) == TARGET_EXPR)\n+    {\n+      tree subinit = NULL_TREE;\n+      *p = set_up_extended_ref_temp (decl, *p, cleanups, &subinit);\n+      if (subinit)\n+\tinit = build2 (COMPOUND_EXPR, TREE_TYPE (init), subinit, init);\n+    }\n+  return init;\n+}\n \n-       struct S {};\n-       struct T { operator S(); };\n-       T t;\n-       const S& s = t;\n+/* INIT is part of the initializer for DECL.  If there are any\n+   reference or initializer lists being initialized, extend their\n+   lifetime to match that of DECL.  */\n \n-    we can extend the lifetime of the return value of the conversion\n-    operator.  */\n-  gcc_assert (conv->kind == ck_ref_bind);\n-  if (decl)\n+tree\n+extend_ref_init_temps (tree decl, tree init, VEC(tree,gc) **cleanups)\n+{\n+  tree type = TREE_TYPE (init);\n+  if (processing_template_decl)\n+    return init;\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    init = extend_ref_init_temps_1 (decl, init, cleanups);\n+  else if (is_std_init_list (type))\n     {\n-      tree var;\n-      tree base_conv_type;\n-\n-      gcc_assert (complain == tf_warning_or_error);\n-\n-      /* Skip over the REF_BIND.  */\n-      conv = conv->u.next;\n-      /* If the next conversion is a BASE_CONV, skip that too -- but\n-\t remember that the conversion was required.  */\n-      if (conv->kind == ck_base)\n-\t{\n-\t  base_conv_type = conv->type;\n-\t  conv = conv->u.next;\n-\t}\n-      else\n-\tbase_conv_type = NULL_TREE;\n-      /* Perform the remainder of the conversion.  */\n-      expr = convert_like_real (conv, expr,\n-\t\t\t\t/*fn=*/NULL_TREE, /*argnum=*/0,\n-\t\t\t\t/*inner=*/-1,\n-\t\t\t\t/*issue_conversion_warnings=*/true,\n-\t\t\t\t/*c_cast_p=*/false,\n-\t\t\t\tcomplain);\n-      if (error_operand_p (expr))\n-\texpr = error_mark_node;\n-      else\n+      /* The temporary array underlying a std::initializer_list\n+\t is handled like a reference temporary.  */\n+      tree ctor = init;\n+      if (TREE_CODE (ctor) == TARGET_EXPR)\n+\tctor = TARGET_EXPR_INITIAL (ctor);\n+      if (TREE_CODE (ctor) == CONSTRUCTOR)\n \t{\n-\t  if (!lvalue_or_rvalue_with_address_p (expr))\n-\t    {\n-\t      tree init;\n-\t      var = set_up_extended_ref_temp (decl, expr, cleanup, &init);\n-\t      /* Use its address to initialize the reference variable.  */\n-\t      expr = build_address (var);\n-\t      if (base_conv_type)\n-\t\texpr = convert_to_base (expr,\n-\t\t\t\t\tbuild_pointer_type (base_conv_type),\n-\t\t\t\t\t/*check_access=*/true,\n-\t\t\t\t\t/*nonnull=*/true, complain);\n-\t      if (init)\n-\t\texpr = build2 (COMPOUND_EXPR, TREE_TYPE (expr), init, expr);\n-\t    }\n-\t  else\n-\t    /* Take the address of EXPR.  */\n-\t    expr = cp_build_addr_expr (expr, complain);\n-\t  /* If a BASE_CONV was required, perform it now.  */\n-\t  if (base_conv_type)\n-\t    expr = (perform_implicit_conversion\n-\t\t    (build_pointer_type (base_conv_type), expr,\n-\t\t     complain));\n-\t  expr = build_nop (type, expr);\n+\t  tree array = CONSTRUCTOR_ELT (ctor, 0)->value;\n+\t  array = extend_ref_init_temps_1 (decl, array, cleanups);\n+\t  CONSTRUCTOR_ELT (ctor, 0)->value = array;\n \t}\n     }\n-  else\n-    /* Perform the conversion.  */\n-    expr = convert_like (conv, expr, complain);\n-\n-  /* Free all the conversions we allocated.  */\n-  obstack_free (&conversion_obstack, p);\n+  else if (TREE_CODE (init) == CONSTRUCTOR)\n+    {\n+      unsigned i;\n+      constructor_elt *p;\n+      VEC(constructor_elt,gc) *elts = CONSTRUCTOR_ELTS (init);\n+      FOR_EACH_VEC_ELT (constructor_elt, elts, i, p)\n+\tp->value = extend_ref_init_temps (decl, p->value, cleanups);\n+    }\n \n-  return expr;\n+  return init;\n }\n \n /* Returns true iff TYPE is some variant of std::initializer_list.  */"}, {"sha": "dc52d29e5b494f1e7d3c18bee408a4bc29a64fd6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b25dd954c41bf75d2bc892c7e9114908eaa7d314", "patch": "@@ -4810,9 +4810,9 @@ extern tree cxx_type_promotes_to\t\t(tree);\n extern tree type_passed_as\t\t\t(tree);\n extern tree convert_for_arg_passing\t\t(tree, tree);\n extern bool is_properly_derived_from\t\t(tree, tree);\n-extern tree set_up_extended_ref_temp\t\t(tree, tree, tree *, tree *);\n-extern tree initialize_reference\t\t(tree, tree, tree, tree *, int,\n+extern tree initialize_reference\t\t(tree, tree, int,\n \t\t\t\t\t\t tsubst_flags_t);\n+extern tree extend_ref_init_temps\t\t(tree, tree, VEC(tree,gc)**);\n extern tree make_temporary_var_for_ref_to_temp\t(tree, tree);\n extern tree strip_top_quals\t\t\t(tree);\n extern bool reference_related_p\t\t\t(tree, tree);\n@@ -5793,7 +5793,7 @@ extern void complete_type_check_abstract\t(tree);\n extern int abstract_virtuals_error\t\t(tree, tree);\n extern int abstract_virtuals_error_sfinae\t(tree, tree, tsubst_flags_t);\n \n-extern tree store_init_value\t\t\t(tree, tree, int);\n+extern tree store_init_value\t\t\t(tree, tree, VEC(tree,gc)**, int);\n extern void check_narrowing\t\t\t(tree, tree);\n extern tree digest_init\t\t\t\t(tree, tree, tsubst_flags_t);\n extern tree digest_init_flags\t\t\t(tree, tree, int);"}, {"sha": "50c45de863315d70f6fc4efbf0746a20384cd9d9", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 33, "deletions": 81, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b25dd954c41bf75d2bc892c7e9114908eaa7d314", "patch": "@@ -71,7 +71,7 @@ static void require_complete_types_for_parms (tree);\n static int ambi_op_p (enum tree_code);\n static int unary_op_p (enum tree_code);\n static void push_local_name (tree);\n-static tree grok_reference_init (tree, tree, tree, tree *, int);\n+static tree grok_reference_init (tree, tree, tree, int);\n static tree grokvardecl (tree, tree, const cp_decl_specifier_seq *,\n \t\t\t int, int, tree);\n static int check_static_variable_definition (tree, tree);\n@@ -91,7 +91,7 @@ static tree lookup_and_check_tag (enum tag_types, tree, tag_scope, bool);\n static int walk_namespaces_r (tree, walk_namespaces_fn, void *);\n static void maybe_deduce_size_from_array_init (tree, tree);\n static void layout_var_decl (tree);\n-static tree check_initializer (tree, tree, int, tree *);\n+static tree check_initializer (tree, tree, int, VEC(tree,gc) **);\n static void make_rtl_for_nonlocal_decl (tree, tree, const char *);\n static void save_function_data (tree);\n static void copy_type_enum (tree , tree);\n@@ -4611,11 +4611,8 @@ start_decl_1 (tree decl, bool initialized)\n    Quotes on semantics can be found in ARM 8.4.3.  */\n \n static tree\n-grok_reference_init (tree decl, tree type, tree init, tree *cleanup,\n-\t\t     int flags)\n+grok_reference_init (tree decl, tree type, tree init, int flags)\n {\n-  tree tmp;\n-\n   if (init == NULL_TREE)\n     {\n       if ((DECL_LANG_SPECIFIC (decl) == 0\n@@ -4641,62 +4638,8 @@ grok_reference_init (tree decl, tree type, tree init, tree *cleanup,\n      DECL_INITIAL for local references (instead assigning to them\n      explicitly); we need to allow the temporary to be initialized\n      first.  */\n-  tmp = initialize_reference (type, init, decl, cleanup, flags,\n-\t\t\t      tf_warning_or_error);\n-  if (DECL_DECLARED_CONSTEXPR_P (decl))\n-    {\n-      tmp = cxx_constant_value (tmp);\n-      DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl)\n-\t= reduced_constant_expression_p (tmp);\n-    }\n-\n-  if (tmp == error_mark_node)\n-    return NULL_TREE;\n-  else if (tmp == NULL_TREE)\n-    {\n-      error (\"cannot initialize %qT from %qT\", type, TREE_TYPE (init));\n-      return NULL_TREE;\n-    }\n-\n-  if (TREE_STATIC (decl) && !TREE_CONSTANT (tmp))\n-    return tmp;\n-\n-  DECL_INITIAL (decl) = tmp;\n-\n-  return NULL_TREE;\n-}\n-\n-/* Subroutine of check_initializer.  We're initializing a DECL of\n-   std::initializer_list<T> TYPE from a braced-init-list INIT, and need to\n-   extend the lifetime of the underlying array to match that of the decl,\n-   just like for reference initialization.  CLEANUP is as for\n-   grok_reference_init.  */\n-\n-static tree\n-build_init_list_var_init (tree decl, tree type, tree init, tree *array_init,\n-\t\t\t  tree *cleanup)\n-{\n-  tree aggr_init, array, arrtype;\n-  init = perform_implicit_conversion (type, init, tf_warning_or_error);\n-  if (error_operand_p (init))\n-    return error_mark_node;\n-\n-  aggr_init = TARGET_EXPR_INITIAL (init);\n-  array = CONSTRUCTOR_ELT (aggr_init, 0)->value;\n-  arrtype = TREE_TYPE (array);\n-  STRIP_NOPS (array);\n-  gcc_assert (TREE_CODE (array) == ADDR_EXPR);\n-  array = TREE_OPERAND (array, 0);\n-  /* If the array is constant, finish_compound_literal already made it a\n-     static variable and we don't need to do anything here.  */\n-  if (decl && TREE_CODE (array) == TARGET_EXPR)\n-    {\n-      tree var = set_up_extended_ref_temp (decl, array, cleanup, array_init);\n-      var = build_address (var);\n-      var = convert (arrtype, var);\n-      CONSTRUCTOR_ELT (aggr_init, 0)->value = var;\n-    }\n-  return init;\n+  return initialize_reference (type, init, flags,\n+\t\t\t       tf_warning_or_error);\n }\n \n /* Designated initializers in arrays are not supported in GNU C++.\n@@ -5440,7 +5383,7 @@ build_aggr_init_full_exprs (tree decl, tree init, int flags)\n    evaluated dynamically to initialize DECL.  */\n \n static tree\n-check_initializer (tree decl, tree init, int flags, tree *cleanup)\n+check_initializer (tree decl, tree init, int flags, VEC(tree,gc) **cleanups)\n {\n   tree type = TREE_TYPE (decl);\n   tree init_code = NULL;\n@@ -5509,19 +5452,26 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n     }\n   else if (!init && DECL_REALLY_EXTERN (decl))\n     ;\n-  else if (TREE_CODE (type) == REFERENCE_TYPE)\n-    init = grok_reference_init (decl, type, init, cleanup, flags);\n-  else if (init || type_build_ctor_call (type))\n+  else if (init || type_build_ctor_call (type)\n+\t   || TREE_CODE (type) == REFERENCE_TYPE)\n     {\n-      if (!init)\n+      if (TREE_CODE (type) == REFERENCE_TYPE)\n+\t{\n+\t  init = grok_reference_init (decl, type, init, flags);\n+\t  flags |= LOOKUP_ALREADY_DIGESTED;\n+\t}\n+      else if (!init)\n \tcheck_for_uninitialized_const_var (decl);\n       /* Do not reshape constructors of vectors (they don't need to be\n \t reshaped.  */\n       else if (BRACE_ENCLOSED_INITIALIZER_P (init))\n \t{\n \t  if (is_std_init_list (type))\n-\t    init = build_init_list_var_init (decl, type, init,\n-\t\t\t\t\t     &extra_init, cleanup);\n+\t    {\n+\t      init = perform_implicit_conversion (type, init,\n+\t\t\t\t\t\t  tf_warning_or_error);\n+\t      flags |= LOOKUP_ALREADY_DIGESTED;\n+\t    }\n \t  else if (TYPE_NON_AGGREGATE_CLASS (type))\n \t    {\n \t      /* Don't reshape if the class has constructors.  */\n@@ -5550,9 +5500,10 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n       if (type == error_mark_node)\n \treturn NULL_TREE;\n \n-      if (type_build_ctor_call (type)\n-\t  || (CLASS_TYPE_P (type)\n-\t      && !(init && BRACE_ENCLOSED_INITIALIZER_P (init))))\n+      if ((type_build_ctor_call (type) || CLASS_TYPE_P (type))\n+\t  && !(flags & LOOKUP_ALREADY_DIGESTED)\n+\t  && !(init && BRACE_ENCLOSED_INITIALIZER_P (init)\n+\t       && CP_AGGREGATE_TYPE_P (type)))\n \t{\n \t  init_code = build_aggr_init_full_exprs (decl, init, flags);\n \n@@ -5594,7 +5545,7 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n \n       if (init && TREE_CODE (init) != TREE_VEC)\n \t{\n-\t  init_code = store_init_value (decl, init, flags);\n+\t  init_code = store_init_value (decl, init, cleanups, flags);\n \t  if (pedantic && TREE_CODE (type) == ARRAY_TYPE\n \t      && DECL_INITIAL (decl)\n \t      && TREE_CODE (DECL_INITIAL (decl)) == STRING_CST\n@@ -5956,7 +5907,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t\ttree asmspec_tree, int flags)\n {\n   tree type;\n-  tree cleanup;\n+  VEC(tree,gc) *cleanups = NULL;\n   const char *asmspec = NULL;\n   int was_readonly = 0;\n   bool var_definition_p = false;\n@@ -5979,9 +5930,6 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n   if (type == error_mark_node)\n     return;\n \n-  /* Assume no cleanup is required.  */\n-  cleanup = NULL_TREE;\n-\n   /* If a name was specified, get the string.  */\n   if (at_namespace_scope_p ())\n     asmspec_tree = maybe_apply_renaming_pragma (decl, asmspec_tree);\n@@ -6101,7 +6049,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t  /* This variable seems to be a non-dependent constant, so process\n \t     its initializer.  If check_initializer returns non-null the\n \t     initialization wasn't constant after all.  */\n-\t  tree init_code = check_initializer (decl, init, flags, &cleanup);\n+\t  tree init_code = check_initializer (decl, init, flags, &cleanups);\n \t  if (init_code == NULL_TREE)\n \t    init = NULL_TREE;\n \t}\n@@ -6202,7 +6150,7 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \t\terror (\"Java object %qD not allocated with %<new%>\", decl);\n \t      init = NULL_TREE;\n \t    }\n-\t  init = check_initializer (decl, init, flags, &cleanup);\n+\t  init = check_initializer (decl, init, flags, &cleanups);\n \t  /* Thread-local storage cannot be dynamically initialized.  */\n \t  if (DECL_THREAD_LOCAL_P (decl) && init)\n \t    {\n@@ -6367,8 +6315,12 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \n   /* If a CLEANUP_STMT was created to destroy a temporary bound to a\n      reference, insert it in the statement-tree now.  */\n-  if (cleanup)\n-    push_cleanup (decl, cleanup, false);\n+  if (cleanups)\n+    {\n+      unsigned i; tree t;\n+      FOR_EACH_VEC_ELT_REVERSE (tree, cleanups, i, t)\n+\tpush_cleanup (decl, t, false);\n+    }\n \n   if (was_readonly)\n     TREE_READONLY (decl) = 1;"}, {"sha": "32b5c7ee12eebc5c55daf38bf2eb8b0fd47abe2b", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=b25dd954c41bf75d2bc892c7e9114908eaa7d314", "patch": "@@ -1877,10 +1877,12 @@ maybe_emit_vtables (tree ctype)\n \n       if (TREE_TYPE (DECL_INITIAL (vtbl)) == 0)\n \t{\n-\t  tree expr = store_init_value (vtbl, DECL_INITIAL (vtbl), LOOKUP_NORMAL);\n+\t  VEC(tree,gc)* cleanups = NULL;\n+\t  tree expr = store_init_value (vtbl, DECL_INITIAL (vtbl), &cleanups,\n+\t\t\t\t\tLOOKUP_NORMAL);\n \n \t  /* It had better be all done at compile-time.  */\n-\t  gcc_assert (!expr);\n+\t  gcc_assert (!expr && !cleanups);\n \t}\n \n       /* Write it out.  */"}, {"sha": "38812754641e071867d69e21c2464afb51d16f67", "filename": "gcc/cp/init.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=b25dd954c41bf75d2bc892c7e9114908eaa7d314", "patch": "@@ -1597,12 +1597,14 @@ expand_aggr_init_1 (tree binfo, tree true_exp, tree exp, tree init, int flags,\n   if (init && TREE_CODE (exp) == VAR_DECL\n       && COMPOUND_LITERAL_P (init))\n     {\n+      VEC(tree,gc)* cleanups = NULL;\n       /* If store_init_value returns NULL_TREE, the INIT has been\n \t recorded as the DECL_INITIAL for EXP.  That means there's\n \t nothing more we have to do.  */\n-      init = store_init_value (exp, init, flags);\n+      init = store_init_value (exp, init, &cleanups, flags);\n       if (init)\n \tfinish_expr_stmt (init);\n+      gcc_assert (!cleanups);\n       return;\n     }\n \n@@ -3150,6 +3152,9 @@ build_vec_init (tree base, tree maxindex, tree init,\n       bool try_const = (TREE_CODE (atype) == ARRAY_TYPE\n \t\t\t&& (literal_type_p (inner_elt_type)\n \t\t\t    || TYPE_HAS_CONSTEXPR_CTOR (inner_elt_type)));\n+      /* If the constructor already has the array type, it's been through\n+\t digest_init, so we shouldn't try to do anything more.  */\n+      bool digested = same_type_p (atype, TREE_TYPE (init));\n       bool saw_non_const = false;\n       bool saw_const = false;\n       /* If we're initializing a static array, we want to do static\n@@ -3172,7 +3177,9 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t  num_initialized_elts++;\n \n \t  current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n-\t  if (MAYBE_CLASS_TYPE_P (type) || TREE_CODE (type) == ARRAY_TYPE)\n+\t  if (digested)\n+\t    one_init = build2 (INIT_EXPR, type, baseref, elt);\n+\t  else if (MAYBE_CLASS_TYPE_P (type) || TREE_CODE (type) == ARRAY_TYPE)\n \t    one_init = build_aggr_init (baseref, elt, 0, complain);\n \t  else\n \t    one_init = cp_build_modify_expr (baseref, NOP_EXPR,"}, {"sha": "7c907b83394d479220dd6f99ded817d9df4d7ca9", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=b25dd954c41bf75d2bc892c7e9114908eaa7d314", "patch": "@@ -3503,12 +3503,17 @@ mangle_guard_variable (const tree variable)\n    initialize a static reference.  This isn't part of the ABI, but we might\n    as well call them something readable.  */\n \n+static GTY(()) int temp_count;\n+\n tree\n mangle_ref_init_variable (const tree variable)\n {\n   start_mangling (variable);\n   write_string (\"_ZGR\");\n   write_name (variable, /*ignore_local_scope=*/0);\n+  /* Avoid name clashes with aggregate initialization of multiple\n+     references at once.  */\n+  write_unsigned_number (temp_count++);\n   return finish_mangling_get_identifier (/*warn=*/false);\n }\n \f"}, {"sha": "58bb14f66833a7c350f7eb9a0fb30119c522fbf2", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=b25dd954c41bf75d2bc892c7e9114908eaa7d314", "patch": "@@ -7561,8 +7561,7 @@ convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n \n       if (fndecl)\n \tsavew = warningcount, savee = errorcount;\n-      rhs = initialize_reference (type, rhs, /*decl=*/NULL_TREE,\n-\t\t\t\t  /*cleanup=*/NULL, flags, complain);\n+      rhs = initialize_reference (type, rhs, flags, complain);\n       if (fndecl)\n \t{\n \t  if (warningcount > savew)"}, {"sha": "70edc2f5a4df258c974da4cb79d28b92f38f0da6", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=b25dd954c41bf75d2bc892c7e9114908eaa7d314", "patch": "@@ -655,7 +655,7 @@ split_nonconstant_init (tree dest, tree init)\n    for static variable.  In that case, caller must emit the code.  */\n \n tree\n-store_init_value (tree decl, tree init, int flags)\n+store_init_value (tree decl, tree init, VEC(tree,gc)** cleanups, int flags)\n {\n   tree value, type;\n \n@@ -699,6 +699,8 @@ store_init_value (tree decl, tree init, int flags)\n     /* Digest the specified initializer into an expression.  */\n     value = digest_init_flags (type, init, flags);\n \n+  value = extend_ref_init_temps (decl, value, cleanups);\n+\n   /* In C++0x constant expression is a semantic, not syntactic, property.\n      In C++98, make sure that what we thought was a constant expression at\n      template definition time is still constant.  */\n@@ -725,7 +727,16 @@ store_init_value (tree decl, tree init, int flags)\n   if (value != error_mark_node\n       && (TREE_SIDE_EFFECTS (value)\n \t   || ! initializer_constant_valid_p (value, TREE_TYPE (value))))\n-    return split_nonconstant_init (decl, value);\n+    {\n+      if (TREE_CODE (type) == ARRAY_TYPE\n+\t  && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (type)))\n+\t/* For an array, we only need/want a single cleanup region rather\n+\t   than one per element.  */\n+\treturn build_vec_init (decl, NULL_TREE, value, false, 1,\n+\t\t\t       tf_warning_or_error);\n+      else\n+\treturn split_nonconstant_init (decl, value);\n+    }\n   /* If the value is a constant, just put it in DECL_INITIAL.  If DECL\n      is an automatic variable, the middle end will turn this into a\n      dynamic initialization later.  */"}, {"sha": "3fe39899c27744bd6c3a21f386597e524cb575a0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b25dd954c41bf75d2bc892c7e9114908eaa7d314", "patch": "@@ -1,3 +1,11 @@\n+2011-11-04  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/48370\n+\t* g++.dg/cpp0x/initlist-lifetime1.C: New.\n+\t* g++.dg/init/lifetime1.C: New.\n+\t* g++.dg/init/ref21.C: New.\n+\t* g++.dg/eh/array1.C: New.\n+\n 2011-11-04  Tom de Vries  <tom@codesourcery.com>\n \n \tPR tree-optimization/50763"}, {"sha": "e43ce5d62cd60796b6d4d1044289323909ee4dcf", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist-lifetime1.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-lifetime1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-lifetime1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-lifetime1.C?ref=b25dd954c41bf75d2bc892c7e9114908eaa7d314", "patch": "@@ -0,0 +1,34 @@\n+// Test that we properly extend the lifetime of the initializer_list\n+// array even if the initializer_list is a subobject.\n+// { dg-options -std=c++0x }\n+// { dg-do run }\n+\n+#include <initializer_list>\n+\n+extern \"C\" void abort();\n+bool ok;\n+\n+bool do_throw;\n+\n+struct A {\n+  A(int) { if (do_throw) throw 42; }\n+  ~A() { if (!ok) abort(); }\n+};\n+\n+typedef std::initializer_list<A> AL;\n+typedef std::initializer_list<AL> AL2;\n+typedef std::initializer_list<AL2> AL3;\n+\n+struct B {\n+  AL al;\n+  const AL& alr;\n+};\n+\n+int main(int argc, const char** argv)\n+{\n+  do_throw = (argc > 1);\t// always false, but optimizer can't tell\n+  AL ar[] = {{1,2},{3,4}};\n+  B b = {{5,6},{7,8}};\n+  AL3 al3 = {{{1},{2},{3}}};\n+  ok = true;\n+}"}, {"sha": "157450a9592160f8f5177333d83a95b88cede947", "filename": "gcc/testsuite/g++.dg/eh/array1.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Farray1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Farray1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Farray1.C?ref=b25dd954c41bf75d2bc892c7e9114908eaa7d314", "patch": "@@ -0,0 +1,15 @@\n+// Test that we have one EH cleanup region for the whole array\n+// rather than one for each element.\n+// { dg-options -fdump-tree-gimple }\n+// { dg-final { scan-tree-dump-times \"catch\" 1 \"gimple\" } }\n+\n+struct A\n+{\n+  A();\n+  ~A();\n+};\n+\n+void f()\n+{\n+  A a[10] = { };\n+}"}, {"sha": "38e25ec991a00637d5cff75cc55fcb1e04302a75", "filename": "gcc/testsuite/g++.dg/init/lifetime1.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Flifetime1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Flifetime1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Flifetime1.C?ref=b25dd954c41bf75d2bc892c7e9114908eaa7d314", "patch": "@@ -0,0 +1,29 @@\n+// PR c++/48370\n+// { dg-do run }\n+\n+extern \"C\" void abort();\n+bool ok;\n+\n+struct A {\n+  int i;\n+  A(int i): i(i) { }\n+  ~A() { if (!ok) abort(); }\n+};\n+\n+struct D { int i; };\n+\n+struct B: D, A { B(int i): A(i) { } };\n+struct E: D, virtual A { E(int i): A(i) { } };\n+\n+struct C\n+{\n+  const A& ar1;\n+  const A& ar2;\n+  const A& ar3;\n+};\n+\n+int main()\n+{\n+  C c = { 1, B(2), E(3) };\n+  ok = true;\n+}"}, {"sha": "db4ac4a300fdb6768e58fadc3a7999298f62d35b", "filename": "gcc/testsuite/g++.dg/init/ref21.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fref21.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25dd954c41bf75d2bc892c7e9114908eaa7d314/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fref21.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fref21.C?ref=b25dd954c41bf75d2bc892c7e9114908eaa7d314", "patch": "@@ -0,0 +1,7 @@\n+struct A\n+{\n+  const int &i1;\n+  const int &i2;\n+};\n+\n+A a = { 1, 2 };"}, {"sha": "559f0c97341d03efef99f90ac7733bf4fb7ccfbf", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25dd954c41bf75d2bc892c7e9114908eaa7d314/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25dd954c41bf75d2bc892c7e9114908eaa7d314/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=b25dd954c41bf75d2bc892c7e9114908eaa7d314", "patch": "@@ -1,3 +1,9 @@\n+2011-11-04  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/48370\n+\t* cp-demangle.c (d_special_name, d_print_comp): Handle a\n+\tdiscriminator number on DEMANGLE_COMPONENT_REFTEMP.\n+\n 2011-11-02  Doug Evans  <dje@google.com>\n \n \t* Makefile.in (CFILES): Add timeval-utils.c."}, {"sha": "d0f57b7fcce5a667b76f220025bf374cfa716822", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b25dd954c41bf75d2bc892c7e9114908eaa7d314/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b25dd954c41bf75d2bc892c7e9114908eaa7d314/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=b25dd954c41bf75d2bc892c7e9114908eaa7d314", "patch": "@@ -1846,8 +1846,11 @@ d_special_name (struct d_info *di)\n \t  return d_make_comp (di, DEMANGLE_COMPONENT_GUARD, d_name (di), NULL);\n \n \tcase 'R':\n-\t  return d_make_comp (di, DEMANGLE_COMPONENT_REFTEMP, d_name (di),\n-\t\t\t      NULL);\n+\t  {\n+\t    struct demangle_component *name = d_name (di);\n+\t    return d_make_comp (di, DEMANGLE_COMPONENT_REFTEMP, name,\n+\t\t\t\td_number_component (di));\n+\t  }\n \n \tcase 'A':\n \t  return d_make_comp (di, DEMANGLE_COMPONENT_HIDDEN_ALIAS,\n@@ -3921,7 +3924,9 @@ d_print_comp (struct d_print_info *dpi, int options,\n       return;\n \n     case DEMANGLE_COMPONENT_REFTEMP:\n-      d_append_string (dpi, \"reference temporary for \");\n+      d_append_string (dpi, \"reference temporary #\");\n+      d_print_comp (dpi, options, d_right (dc));\n+      d_append_string (dpi, \" for \");\n       d_print_comp (dpi, options, d_left (dc));\n       return;\n "}]}