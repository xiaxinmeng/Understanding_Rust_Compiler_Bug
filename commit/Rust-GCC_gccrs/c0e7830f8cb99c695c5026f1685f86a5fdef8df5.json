{"sha": "c0e7830f8cb99c695c5026f1685f86a5fdef8df5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBlNzgzMGY4Y2I5OWM2OTVjNTAyNmYxNjg1Zjg2YTVmZGVmOGRmNQ==", "commit": {"author": {"name": "DJ Delorie", "email": "dj@redhat.com", "date": "2001-06-21T16:50:56Z"}, "committer": {"name": "DJ Delorie", "email": "dj@gcc.gnu.org", "date": "2001-06-21T16:50:56Z"}, "message": "integrate.c (ggc.h): Include.\n\n* integrate.c (ggc.h): Include.\n(initial_value_pair, initial_value_struct,\nsetup_initial_hard_reg_value_integration): Add prototypes.\n(expand_inline_function): Call\nsetup_initial_hard_reg_value_integration.\n(has_func_hard_reg_initial_val, get_func_hard_reg_initial_val,\nget_hard_reg_initial_val, has_hard_reg_initial_val): New functions\nto keep track of values present at the start of a function.\n(mark_hard_reg_initial_vals): New, for gc.\n(setup_initial_hard_reg_value_integration): New.  Sets up pseudo\nmappings for initial values.\n(emit_initial_value_sets): New.  Emits code to set initial value\npseudos.\n* integrate.h: Add prototypes for new functions.\n* function.h (struct function): Add hard_reg_initial_vals field.\n* function.c (integrate.h): Include.\n(mark_function_status): Call\nmark_hard_reg_initial_vals.\n* toplev.c (integrate.h): Include.\n(rest_of_compilation): Call emit_initial_value_sets.\n\nFrom-SVN: r43486", "tree": {"sha": "38ad78224be3ce9d772ab85dbd0b522179b799d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38ad78224be3ce9d772ab85dbd0b522179b799d5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0e7830f8cb99c695c5026f1685f86a5fdef8df5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e7830f8cb99c695c5026f1685f86a5fdef8df5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0e7830f8cb99c695c5026f1685f86a5fdef8df5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0e7830f8cb99c695c5026f1685f86a5fdef8df5/comments", "author": null, "committer": null, "parents": [{"sha": "2147b1541cb6a841b54cf92f025ddc62857998e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2147b1541cb6a841b54cf92f025ddc62857998e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2147b1541cb6a841b54cf92f025ddc62857998e5"}], "stats": {"total": 192, "additions": 191, "deletions": 1}, "files": [{"sha": "f5f601be078cbc92c712a05c1639052073ff6051", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e7830f8cb99c695c5026f1685f86a5fdef8df5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e7830f8cb99c695c5026f1685f86a5fdef8df5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0e7830f8cb99c695c5026f1685f86a5fdef8df5", "patch": "@@ -1,3 +1,26 @@\n+2001-06-21  DJ Delorie  <dj@redhat.com>\n+\n+\t* integrate.c (ggc.h): Include.\n+\t(initial_value_pair, initial_value_struct,\n+\tsetup_initial_hard_reg_value_integration): Add prototypes.\n+\t(expand_inline_function): Call\n+\tsetup_initial_hard_reg_value_integration.\n+\t(has_func_hard_reg_initial_val, get_func_hard_reg_initial_val,\n+\tget_hard_reg_initial_val, has_hard_reg_initial_val): New functions\n+\tto keep track of values present at the start of a function.\n+\t(mark_hard_reg_initial_vals): New, for gc.\n+\t(setup_initial_hard_reg_value_integration): New.  Sets up pseudo\n+\tmappings for initial values.\n+\t(emit_initial_value_sets): New.  Emits code to set initial value\n+\tpseudos.\n+\t* integrate.h: Add prototypes for new functions.\n+\t* function.h (struct function): Add hard_reg_initial_vals field.\n+\t* function.c (integrate.h): Include.\n+\t(mark_function_status): Call\n+\tmark_hard_reg_initial_vals.\n+\t* toplev.c (integrate.h): Include.\n+\t(rest_of_compilation): Call emit_initial_value_sets.\n+\n 2001-06-21  Stan Shebs  <shebs@apple.com>\n \n \t* doc/contrib.texi, doc/cpp.texi, doc/cppinternals.texi,"}, {"sha": "6ecf09908d6413b98680b25d006ff34a9f326a0f", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e7830f8cb99c695c5026f1685f86a5fdef8df5/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e7830f8cb99c695c5026f1685f86a5fdef8df5/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=c0e7830f8cb99c695c5026f1685f86a5fdef8df5", "patch": "@@ -57,6 +57,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"hash.h\"\n #include \"ggc.h\"\n #include \"tm_p.h\"\n+#include \"integrate.h\"\n \n #ifndef TRAMPOLINE_ALIGNMENT\n #define TRAMPOLINE_ALIGNMENT FUNCTION_BOUNDARY\n@@ -7601,6 +7602,8 @@ mark_function_status (p)\n   ggc_mark_rtx (p->x_nonlocal_goto_handler_labels);\n   ggc_mark_rtx (p->x_nonlocal_goto_stack_level);\n   ggc_mark_tree (p->x_nonlocal_labels);\n+\n+  mark_hard_reg_initial_vals (p);\n }\n \n /* Mark the function chain ARG (which is really a struct function **)"}, {"sha": "3322f43a593014325473b167cb0f40ec274525b8", "filename": "gcc/function.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e7830f8cb99c695c5026f1685f86a5fdef8df5/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e7830f8cb99c695c5026f1685f86a5fdef8df5/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=c0e7830f8cb99c695c5026f1685f86a5fdef8df5", "patch": "@@ -235,6 +235,10 @@ struct function\n      inline.  */\n   const char *cannot_inline;\n \n+  /* Opaque pointer used by get_hard_reg_initial_val and\n+     has_hard_reg_initial_val (see integrate.[hc]). */\n+  struct initial_value_struct *hard_reg_initial_vals;\n+\n   /* Number of function calls seen so far in current function.  */\n   int x_function_call_count;\n "}, {"sha": "7cc6002520cb6a0531727dbf092b9340e49587c8", "filename": "gcc/integrate.c", "status": "modified", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e7830f8cb99c695c5026f1685f86a5fdef8df5/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e7830f8cb99c695c5026f1685f86a5fdef8df5/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=c0e7830f8cb99c695c5026f1685f86a5fdef8df5", "patch": "@@ -40,6 +40,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"intl.h\"\n #include \"loop.h\"\n #include \"params.h\"\n+#include \"ggc.h\"\n \n #include \"obstack.h\"\n #define\tobstack_chunk_alloc\txmalloc\n@@ -68,6 +69,20 @@ extern struct obstack *function_maybepermanent_obstack;\n #define FUNCTION_ATTRIBUTE_INLINABLE_P(FNDECL) 0\n #endif\n \f\n+\n+/* Private type used by {get/has}_func_hard_reg_initial_val. */\n+typedef struct initial_value_pair {\n+  rtx hard_reg;\n+  rtx pseudo;\n+} initial_value_pair;\n+typedef struct initial_value_struct {\n+  int num_entries;\n+  int max_entries;\n+  initial_value_pair *entries;\n+} initial_value_struct;\n+\n+static void setup_initial_hard_reg_value_integration PARAMS ((struct function *, struct inline_remap *));\n+\n static rtvec initialize_for_inline\tPARAMS ((tree));\n static void note_modified_parmregs\tPARAMS ((rtx, rtx, void *));\n static void integrate_parm_decls\tPARAMS ((tree, struct inline_remap *,\n@@ -1159,6 +1174,9 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n   if (inl_f->calls_alloca)\n     emit_stack_save (SAVE_BLOCK, &stack_save, NULL_RTX);\n \n+  /* Map pseudos used for initial hard reg values.  */\n+  setup_initial_hard_reg_value_integration (inl_f, map);\n+\n   /* Now copy the insns one by one.  */\n   copy_insn_list (insns, map, static_chain_value);\n \n@@ -2878,3 +2896,126 @@ output_inline_function (fndecl)\n   current_function_decl = old_cfun ? old_cfun->decl : 0;\n   write_symbols = old_write_symbols;\n }\n+\n+\f\n+/* Functions to keep track of the values hard regs had at the start of\n+   the function.  */\n+\n+rtx\n+has_func_hard_reg_initial_val (fun, reg)\n+     struct function *fun;\n+     rtx reg;\n+{\n+  struct initial_value_struct *ivs = fun->hard_reg_initial_vals;\n+  int i;\n+\n+  if (ivs == 0)\n+    return NULL_RTX;\n+\n+  for (i = 0; i < ivs->num_entries; i++)\n+    if (rtx_equal_p (ivs->entries[i].hard_reg, reg))\n+      return ivs->entries[i].pseudo;\n+\n+  return NULL_RTX;\n+}\n+\n+rtx\n+get_func_hard_reg_initial_val (fun, reg)\n+     struct function *fun;\n+     rtx reg;\n+{\n+  struct initial_value_struct *ivs = fun->hard_reg_initial_vals;\n+  rtx rv = has_func_hard_reg_initial_val (fun, reg);\n+\n+  if (rv)\n+    return rv;\n+\n+  if (ivs == 0)\n+    {\n+      fun->hard_reg_initial_vals = (void *) xmalloc (sizeof (initial_value_struct));\n+      ivs = fun->hard_reg_initial_vals;\n+      ivs->num_entries = 0;\n+      ivs->max_entries = 5;\n+      ivs->entries = (initial_value_pair *) xmalloc (5 * sizeof (initial_value_pair));\n+    }\n+\n+  if (ivs->num_entries >= ivs->max_entries)\n+    {\n+      ivs->max_entries += 5;\n+      ivs->entries = \n+\t(initial_value_pair *) xrealloc (ivs->entries,\n+\t\t\t\t\t ivs->max_entries\n+\t\t\t\t\t * sizeof (initial_value_pair));\n+    }\n+\n+  ivs->entries[ivs->num_entries].hard_reg = reg;\n+  ivs->entries[ivs->num_entries].pseudo = gen_reg_rtx (GET_MODE (reg));\n+\n+  return ivs->entries[ivs->num_entries++].pseudo;\n+}\n+\n+rtx\n+get_hard_reg_initial_val (mode, regno)\n+     enum machine_mode mode;\n+     int regno;\n+{\n+  return get_func_hard_reg_initial_val (cfun, gen_rtx_REG (mode, regno));\n+}\n+\n+rtx\n+has_hard_reg_initial_val (mode, regno)\n+     enum machine_mode mode;\n+     int regno;\n+{\n+  return has_func_hard_reg_initial_val (cfun, gen_rtx_REG (mode, regno));\n+}\n+\n+void\n+mark_hard_reg_initial_vals (fun)\n+     struct function *fun;\n+{\n+  struct initial_value_struct *ivs = fun->hard_reg_initial_vals;\n+  int i;\n+\n+  for (i = 0; i < ivs->num_entries; i ++)\n+    {\n+      ggc_mark_rtx (ivs->entries[i].hard_reg);\n+      ggc_mark_rtx (ivs->entries[i].pseudo);\n+    }\n+}\n+\n+static void\n+setup_initial_hard_reg_value_integration (inl_f, remap)\n+     struct function *inl_f;\n+     struct inline_remap *remap;\n+{\n+  struct initial_value_struct *ivs = inl_f->hard_reg_initial_vals;\n+  int i;\n+\n+  if (ivs == 0)\n+    return;\n+\n+  for (i = 0; i < ivs->num_entries; i ++)\n+    remap->reg_map[REGNO (ivs->entries[i].pseudo)]\n+      = get_func_hard_reg_initial_val (cfun, ivs->entries[i].hard_reg);\n+}\n+\n+\n+void\n+emit_initial_value_sets ()\n+{\n+  struct initial_value_struct *ivs = cfun->hard_reg_initial_vals;\n+  int i;\n+  rtx seq;\n+\n+  if (ivs == 0)\n+    return;\n+\n+  start_sequence ();\n+  for (i = 0; i < ivs->num_entries; i++)\n+    emit_move_insn (ivs->entries[i].pseudo, ivs->entries[i].hard_reg);\n+  seq = get_insns ();\n+  end_sequence ();\n+\n+  emit_insns_after (seq, get_insns ());\n+}"}, {"sha": "04d5bd22e03d89963400dc443d61296621341c1a", "filename": "gcc/integrate.h", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e7830f8cb99c695c5026f1685f86a5fdef8df5/gcc%2Fintegrate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e7830f8cb99c695c5026f1685f86a5fdef8df5/gcc%2Fintegrate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.h?ref=c0e7830f8cb99c695c5026f1685f86a5fdef8df5", "patch": "@@ -129,6 +129,22 @@ struct inline_remap\n    labels, and frame-pointer offsets as necessary.  */\n extern rtx copy_rtx_and_substitute PARAMS ((rtx, struct inline_remap *, int));\n \n+/* Return a pseudo that corresponds to the value in the specified hard\n+   reg as of the start of the function (for inlined functions, the\n+   value at the start of the parent function).  */\n+extern rtx get_hard_reg_initial_val\t\tPARAMS ((enum machine_mode, int));\n+/* Likewise, but for a different than the current function, or\n+   arbitrary expression.  */\n+extern rtx get_func_hard_reg_initial_val\tPARAMS ((struct function *, rtx));\n+/* Likewise, but iff someone else has caused it to become allocated.  */\n+extern rtx has_func_hard_reg_initial_val\tPARAMS ((struct function *, rtx));\n+/* Likewise, but for common cases.  */\n+extern rtx has_hard_reg_initial_val\t\tPARAMS ((enum machine_mode, int));\n+/* This is for GC.  */\n+extern void mark_hard_reg_initial_vals\t\tPARAMS ((struct function *));\n+/* Called from rest_of_compilation.  */\n+extern void emit_initial_value_sets\t\tPARAMS ((void));\n+\n /* Copy a declaration when one function is substituted inline into\n    another.  */\n extern union tree_node *copy_decl_for_inlining PARAMS ((union tree_node *,"}, {"sha": "6e75187c573f1127eb56a7aee4668caaece0c029", "filename": "gcc/toplev.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0e7830f8cb99c695c5026f1685f86a5fdef8df5/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0e7830f8cb99c695c5026f1685f86a5fdef8df5/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=c0e7830f8cb99c695c5026f1685f86a5fdef8df5", "patch": "@@ -65,6 +65,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"params.h\"\n #include \"reload.h\"\n #include \"dwarf2asm.h\"\n+#include \"integrate.h\"\n \n #ifdef DWARF_DEBUGGING_INFO\n #include \"dwarfout.h\"\n@@ -2863,9 +2864,11 @@ rest_of_compilation (decl)\n      distinguish between the return value of this function and the\n      return value of called functions.  Also, we can remove all SETs\n      of subregs of hard registers; they are only here because of\n-     integrate.*/\n+     integrate.  Also, we can now initialize pseudos intended to \n+     carry magic hard reg data throughout the function.  */\n   rtx_equal_function_value_matters = 0;\n   purge_hard_subreg_sets (get_insns ());\n+  emit_initial_value_sets ();\n \n   /* Don't return yet if -Wreturn-type; we need to do jump_optimize.  */\n   if ((rtl_dump_and_exit || flag_syntax_only) && !warn_return_type)"}]}