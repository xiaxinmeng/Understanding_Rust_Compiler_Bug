{"sha": "1fec5f5274d7e232b75fc400321ed64be46766c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWZlYzVmNTI3NGQ3ZTIzMmI3NWZjNDAwMzIxZWQ2NGJlNDY3NjZjMw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-11-04T22:39:30Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-11-04T22:39:30Z"}, "message": "libgo: add s390 support\n\nFrom Dominik Vogt.\n\n* libgo/go/syscall/libcall_linux_s390.go: New file for s390 support.\n* libgo/go/syscall/syscall_linux_s390.go: Ditto.\n* libgo/go/syscall/libcall_linux_s390x.go: New file for s390x support.\n* libgo/go/syscall/syscall_linux_s390x.go: Ditto.\n* libgo/go/runtime/pprof/pprof.go (printStackRecord): Support s390 and\ns390x.\n* libgo/runtime/runtime.c (runtime_cputicks): Add support for s390 and\ns390x\n* libgo/mksysinfo.sh: Ditto.\n(upcase_fields): New helper function\n\n* libgo/go/debug/elf/file.go (applyRelocations): Implement relocations\non s390x.\n(applyRelocationsS390x): Ditto.\n(DWARF): Ditto.\n* libgo/go/debug/elf/elf.go (R_390): New constants for S390 relocations.\n(r390Strings): Ditto.\n(String): Helper function for S390 relocations.\n(GoString): Ditto.\n\n* libgo/go/reflect/makefuncgo_s390.go: New file.\n(S390MakeFuncStubGo): Implementation of s390 abi.\n* libgo/go/reflect/makefuncgo_s390x.go: New file.\n(S390xMakeFuncStubGo): Implementation of s390x abi.\n* libgo/go/reflect/makefunc_s390.c: New file.\n(makeFuncStub): s390 and s390x specific implementation of function.\n* libgo/go/reflect/makefunc.go\n(MakeFunc): Add support for s390 and s390x.\n(makeMethodValue): Ditto.\n(makeValueMethod): Ditto.\n* libgo/Makefile.am (go_reflect_makefunc_s_file): Ditto.\n(go_reflect_makefunc_file): Ditto.\n* libgo/go/reflect/makefunc_dummy.c: Ditto.\n* libgo/runtime/runtime.h (__go_makefunc_can_recover): Export prototype\nfor use in makefunc_s390.c.\n(__go_makefunc_returning): Ditto.\n\n* libgo/go/syscall/exec_linux.go (forkAndExecInChild): Fix order of the\narguments of the clone system call for s390[x].\n\n* libgo/configure.ac (is_s390): New variable.\n(is_s390x): Ditto\n(LIBGO_IS_S390): Ditto.\n(LIBGO_IS_S390X): Ditto.\n(GOARCH): Support s390 and s390x.\n* libgo/go/go/build/build.go (cgoEnabled): Ditto.\n* libgo/go/go/build/syslist.go (goarchList): Ditto.\n\nFrom-SVN: r217106", "tree": {"sha": "770354d65e888c2d5026ac0f9759649f58da3104", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/770354d65e888c2d5026ac0f9759649f58da3104"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1fec5f5274d7e232b75fc400321ed64be46766c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fec5f5274d7e232b75fc400321ed64be46766c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fec5f5274d7e232b75fc400321ed64be46766c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fec5f5274d7e232b75fc400321ed64be46766c3/comments", "author": null, "committer": null, "parents": [{"sha": "f6166a42cc539777393886b6ead213818e8a57af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6166a42cc539777393886b6ead213818e8a57af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6166a42cc539777393886b6ead213818e8a57af"}], "stats": {"total": 1327, "additions": 1309, "deletions": 18}, "files": [{"sha": "79cfdd85fb333616ffaa0b63979f72e3a7da9671", "filename": "libgo/Makefile.am", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=1fec5f5274d7e232b75fc400321ed64be46766c3", "patch": "@@ -943,11 +943,26 @@ go_reflect_makefunc_file = \\\n go_reflect_makefunc_s_file = \\\n \tgo/reflect/makefunc_386.S\n else\n+if LIBGO_IS_S390\n+go_reflect_makefunc_file = \\\n+\tgo/reflect/makefuncgo_s390.go\n+go_reflect_makefunc_s_file = \\\n+\tgo/reflect/makefunc_s390.c\n+else\n+if LIBGO_IS_S390X\n+go_reflect_makefunc_file = \\\n+\tgo/reflect/makefuncgo_s390x.go \\\n+\tgo/reflect/makefuncgo_s390.go\n+go_reflect_makefunc_s_file = \\\n+\tgo/reflect/makefunc_s390.c\n+else\n go_reflect_makefunc_file =\n go_reflect_makefunc_s_file = \\\n \tgo/reflect/makefunc_dummy.c\n endif\n endif\n+endif\n+endif\n \n go_reflect_files = \\\n \tgo/reflect/deepequal.go \\"}, {"sha": "f5b5e70c0071496fb9e3431bde6a046f41d291be", "filename": "libgo/Makefile.in", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=1fec5f5274d7e232b75fc400321ed64be46766c3", "patch": "@@ -1104,15 +1104,28 @@ go_path_files = \\\n \tgo/path/match.go \\\n \tgo/path/path.go\n \n-@LIBGO_IS_386_FALSE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_file = \n+@LIBGO_IS_386_FALSE@@LIBGO_IS_S390X_FALSE@@LIBGO_IS_S390_FALSE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_file = \n+@LIBGO_IS_386_FALSE@@LIBGO_IS_S390X_TRUE@@LIBGO_IS_S390_FALSE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_file = \\\n+@LIBGO_IS_386_FALSE@@LIBGO_IS_S390X_TRUE@@LIBGO_IS_S390_FALSE@@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefuncgo_s390x.go \\\n+@LIBGO_IS_386_FALSE@@LIBGO_IS_S390X_TRUE@@LIBGO_IS_S390_FALSE@@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefuncgo_s390.go\n+\n+@LIBGO_IS_386_FALSE@@LIBGO_IS_S390_TRUE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_file = \\\n+@LIBGO_IS_386_FALSE@@LIBGO_IS_S390_TRUE@@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefuncgo_s390.go\n+\n @LIBGO_IS_386_TRUE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_file = \\\n @LIBGO_IS_386_TRUE@@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefuncgo_386.go\n \n @LIBGO_IS_X86_64_TRUE@go_reflect_makefunc_file = \\\n @LIBGO_IS_X86_64_TRUE@\tgo/reflect/makefuncgo_amd64.go\n \n-@LIBGO_IS_386_FALSE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_s_file = \\\n-@LIBGO_IS_386_FALSE@@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefunc_dummy.c\n+@LIBGO_IS_386_FALSE@@LIBGO_IS_S390X_FALSE@@LIBGO_IS_S390_FALSE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_s_file = \\\n+@LIBGO_IS_386_FALSE@@LIBGO_IS_S390X_FALSE@@LIBGO_IS_S390_FALSE@@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefunc_dummy.c\n+\n+@LIBGO_IS_386_FALSE@@LIBGO_IS_S390X_TRUE@@LIBGO_IS_S390_FALSE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_s_file = \\\n+@LIBGO_IS_386_FALSE@@LIBGO_IS_S390X_TRUE@@LIBGO_IS_S390_FALSE@@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefunc_s390.c\n+\n+@LIBGO_IS_386_FALSE@@LIBGO_IS_S390_TRUE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_s_file = \\\n+@LIBGO_IS_386_FALSE@@LIBGO_IS_S390_TRUE@@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefunc_s390.c\n \n @LIBGO_IS_386_TRUE@@LIBGO_IS_X86_64_FALSE@go_reflect_makefunc_s_file = \\\n @LIBGO_IS_386_TRUE@@LIBGO_IS_X86_64_FALSE@\tgo/reflect/makefunc_386.S"}, {"sha": "68161f6590214a7ba28f27938e49b062b4458fd3", "filename": "libgo/configure", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=1fec5f5274d7e232b75fc400321ed64be46766c3", "patch": "@@ -631,6 +631,10 @@ LIBGO_IS_SPARC64_FALSE\n LIBGO_IS_SPARC64_TRUE\n LIBGO_IS_SPARC_FALSE\n LIBGO_IS_SPARC_TRUE\n+LIBGO_IS_S390X_FALSE\n+LIBGO_IS_S390X_TRUE\n+LIBGO_IS_S390_FALSE\n+LIBGO_IS_S390_TRUE\n LIBGO_IS_PPC64_FALSE\n LIBGO_IS_PPC64_TRUE\n LIBGO_IS_PPC_FALSE\n@@ -11118,7 +11122,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11121 \"configure\"\n+#line 11125 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11224,7 +11228,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 11227 \"configure\"\n+#line 11231 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -13620,6 +13624,8 @@ is_m68k=no\n mips_abi=unknown\n is_ppc=no\n is_ppc64=no\n+is_s390=no\n+is_s390x=no\n is_sparc=no\n is_sparc64=no\n is_x86_64=no\n@@ -13739,6 +13745,26 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n       GOARCH=ppc64\n     fi\n     ;;\n+  s390*-*-*)\n+    cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n+/* end confdefs.h.  */\n+\n+#if defined(__s390x__)\n+#error 64-bit\n+#endif\n+_ACEOF\n+if ac_fn_c_try_compile \"$LINENO\"; then :\n+  is_s390=yes\n+else\n+  is_s390x=yes\n+fi\n+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n+    if test \"$is_s390\" = \"yes\"; then\n+      GOARCH=s390\n+    else\n+      GOARCH=s390x\n+    fi\n+    ;;\n   sparc*-*-*)\n     cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n /* end confdefs.h.  */\n@@ -13856,6 +13882,22 @@ else\n   LIBGO_IS_PPC64_FALSE=\n fi\n \n+ if test $is_s390 = yes; then\n+  LIBGO_IS_S390_TRUE=\n+  LIBGO_IS_S390_FALSE='#'\n+else\n+  LIBGO_IS_S390_TRUE='#'\n+  LIBGO_IS_S390_FALSE=\n+fi\n+\n+ if test $is_s390x = yes; then\n+  LIBGO_IS_S390X_TRUE=\n+  LIBGO_IS_S390X_FALSE='#'\n+else\n+  LIBGO_IS_S390X_TRUE='#'\n+  LIBGO_IS_S390X_FALSE=\n+fi\n+\n  if test $is_sparc = yes; then\n   LIBGO_IS_SPARC_TRUE=\n   LIBGO_IS_SPARC_FALSE='#'\n@@ -15630,6 +15672,14 @@ if test -z \"${LIBGO_IS_PPC64_TRUE}\" && test -z \"${LIBGO_IS_PPC64_FALSE}\"; then\n   as_fn_error \"conditional \\\"LIBGO_IS_PPC64\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${LIBGO_IS_S390_TRUE}\" && test -z \"${LIBGO_IS_S390_FALSE}\"; then\n+  as_fn_error \"conditional \\\"LIBGO_IS_S390\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n+if test -z \"${LIBGO_IS_S390X_TRUE}\" && test -z \"${LIBGO_IS_S390X_FALSE}\"; then\n+  as_fn_error \"conditional \\\"LIBGO_IS_S390X\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n if test -z \"${LIBGO_IS_SPARC_TRUE}\" && test -z \"${LIBGO_IS_SPARC_FALSE}\"; then\n   as_fn_error \"conditional \\\"LIBGO_IS_SPARC\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5"}, {"sha": "d651827fee5c8b2a9e0575152942ac0548f334a1", "filename": "libgo/configure.ac", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=1fec5f5274d7e232b75fc400321ed64be46766c3", "patch": "@@ -194,6 +194,8 @@ is_m68k=no\n mips_abi=unknown\n is_ppc=no\n is_ppc64=no\n+is_s390=no\n+is_s390x=no\n is_sparc=no\n is_sparc64=no\n is_x86_64=no\n@@ -271,6 +273,18 @@ changequote([,])dnl\n       GOARCH=ppc64\n     fi\n     ;;\n+  s390*-*-*)\n+    AC_COMPILE_IFELSE([\n+#if defined(__s390x__)\n+#error 64-bit\n+#endif],\n+[is_s390=yes], [is_s390x=yes])\n+    if test \"$is_s390\" = \"yes\"; then\n+      GOARCH=s390\n+    else\n+      GOARCH=s390x\n+    fi\n+    ;;\n   sparc*-*-*)\n     AC_COMPILE_IFELSE([\n #if defined(__sparcv9) || defined(__arch64__)\n@@ -296,6 +310,8 @@ AM_CONDITIONAL(LIBGO_IS_MIPSN64, test $mips_abi = n64)\n AM_CONDITIONAL(LIBGO_IS_MIPSO64, test $mips_abi = o64)\n AM_CONDITIONAL(LIBGO_IS_PPC, test $is_ppc = yes)\n AM_CONDITIONAL(LIBGO_IS_PPC64, test $is_ppc64 = yes)\n+AM_CONDITIONAL(LIBGO_IS_S390, test $is_s390 = yes)\n+AM_CONDITIONAL(LIBGO_IS_S390X, test $is_s390x = yes)\n AM_CONDITIONAL(LIBGO_IS_SPARC, test $is_sparc = yes)\n AM_CONDITIONAL(LIBGO_IS_SPARC64, test $is_sparc64 = yes)\n AM_CONDITIONAL(LIBGO_IS_X86_64, test $is_x86_64 = yes)"}, {"sha": "a7986a5753512d6837263af516a396b182fce23d", "filename": "libgo/go/debug/elf/elf.go", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Fdebug%2Felf%2Felf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Fdebug%2Felf%2Felf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Felf.go?ref=1fec5f5274d7e232b75fc400321ed64be46766c3", "patch": "@@ -1340,6 +1340,72 @@ var rppc64Strings = []intName{\n func (i R_PPC64) String() string   { return stringName(uint32(i), rppc64Strings, false) }\n func (i R_PPC64) GoString() string { return stringName(uint32(i), rppc64Strings, true) }\n \n+// Relocation types for s390\n+type R_390 int\n+\n+const (\n+\tR_390_NONE     R_390 = 0\n+\tR_390_8        R_390 = 1\n+\tR_390_12       R_390 = 2\n+\tR_390_16       R_390 = 3\n+\tR_390_32       R_390 = 4\n+\tR_390_PC32     R_390 = 5\n+\tR_390_GOT12    R_390 = 6\n+\tR_390_GOT32    R_390 = 7\n+\tR_390_PLT32    R_390 = 8\n+\tR_390_COPY     R_390 = 9\n+\tR_390_GLOB_DAT R_390 = 10\n+\tR_390_JMP_SLOT R_390 = 11\n+\tR_390_RELATIVE R_390 = 12\n+\tR_390_GOTOFF   R_390 = 13\n+\tR_390_GOTPC    R_390 = 14\n+\tR_390_GOT16    R_390 = 15\n+\tR_390_PC16     R_390 = 16\n+\tR_390_PC16DBL  R_390 = 17\n+\tR_390_PLT16DBL R_390 = 18\n+\tR_390_PC32DBL  R_390 = 19\n+\tR_390_PLT32DBL R_390 = 20\n+\tR_390_GOTPCDBL R_390 = 21\n+\tR_390_64       R_390 = 22\n+\tR_390_PC64     R_390 = 23\n+\tR_390_GOT64    R_390 = 24\n+\tR_390_PLT64    R_390 = 25\n+\tR_390_GOTENT   R_390 = 26\n+)\n+\n+var r390Strings = []intName{\n+\t{0, \"R_390_NONE\"},\n+\t{1, \"R_390_8\"},\n+\t{2, \"R_390_12\"},\n+\t{3, \"R_390_16\"},\n+\t{4, \"R_390_32\"},\n+\t{5, \"R_390_PC32\"},\n+\t{6, \"R_390_GOT12\"},\n+\t{7, \"R_390_GOT32\"},\n+\t{8, \"R_390_PLT32\"},\n+\t{9, \"R_390_COPY\"},\n+\t{10, \"R_390_GLOB_DAT\"},\n+\t{11, \"R_390_JMP_SLOT\"},\n+\t{12, \"R_390_RELATIVE\"},\n+\t{13, \"R_390_GOTOFF\"},\n+\t{14, \"R_390_GOTPC\"},\n+\t{15, \"R_390_GOT16\"},\n+\t{16, \"R_390_PC16\"},\n+\t{17, \"R_390_PC16DBL\"},\n+\t{18, \"R_390_PLT16DBL\"},\n+\t{19, \"R_390_PC32DBL\"},\n+\t{20, \"R_390_PLT32DBL\"},\n+\t{21, \"R_390_GOTPCDBL\"},\n+\t{22, \"R_390_64\"},\n+\t{23, \"R_390_PC64\"},\n+\t{24, \"R_390_GOT64\"},\n+\t{25, \"R_390_PLT64\"},\n+\t{26, \"R_390_GOTENT\"},\n+}\n+\n+func (i R_390) String() string   { return stringName(uint32(i), r390Strings, false) }\n+func (i R_390) GoString() string { return stringName(uint32(i), r390Strings, true) }\n+\n // Relocation types for SPARC.\n type R_SPARC int\n "}, {"sha": "0c8dff506f351e633b368c97e61d788089156814", "filename": "libgo/go/debug/elf/file.go", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go?ref=1fec5f5274d7e232b75fc400321ed64be46766c3", "patch": "@@ -528,6 +528,9 @@ func (f *File) applyRelocations(dst []byte, rels []byte) error {\n \tif f.Class == ELFCLASS64 && f.Machine == EM_PPC64 {\n \t\treturn f.applyRelocationsPPC64(dst, rels)\n \t}\n+\tif f.Class == ELFCLASS64 && f.Machine == EM_S390 {\n+\t\treturn f.applyRelocationsS390x(dst, rels)\n+\t}\n \n \treturn errors.New(\"not implemented\")\n }\n@@ -659,6 +662,47 @@ func (f *File) applyRelocationsPPC64(dst []byte, rels []byte) error {\n \treturn nil\n }\n \n+func (f *File) applyRelocationsS390x(dst []byte, rels []byte) error {\n+\t// 24 is the size of Rela64.\n+\tif len(rels)%24 != 0 {\n+\t\treturn errors.New(\"length of relocation section is not a multiple of 24\")\n+\t}\n+\n+\tsymbols, _, err := f.getSymbols(SHT_SYMTAB)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tb := bytes.NewBuffer(rels)\n+\tvar rela Rela64\n+\n+\tfor b.Len() > 0 {\n+\t\tbinary.Read(b, f.ByteOrder, &rela)\n+\t\tsymNo := rela.Info >> 32\n+\t\tt := R_390(rela.Info & 0xffff)\n+\n+\t\tif symNo == 0 || symNo > uint64(len(symbols)) {\n+\t\t\tcontinue\n+\t\t}\n+\t\tsym := &symbols[symNo-1]\n+\n+\t\tswitch t {\n+\t\tcase R_390_64:\n+\t\t\tif rela.Off+8 >= uint64(len(dst)) || rela.Addend < 0 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tf.ByteOrder.PutUint64(dst[rela.Off:rela.Off+8], uint64(rela.Addend)+uint64(sym.Value))\n+\t\tcase R_390_32:\n+\t\t\tif rela.Off+4 >= uint64(len(dst)) || rela.Addend < 0 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tf.ByteOrder.PutUint32(dst[rela.Off:rela.Off+4], uint32(rela.Addend)+uint32(sym.Value))\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}\n+\n func (f *File) DWARF() (*dwarf.Data, error) {\n \t// There are many other DWARF sections, but these\n \t// are the required ones, and the debug/dwarf package\n@@ -681,7 +725,7 @@ func (f *File) DWARF() (*dwarf.Data, error) {\n \t// If there's a relocation table for .debug_info, we have to process it\n \t// now otherwise the data in .debug_info is invalid for x86-64 objects.\n \trela := f.Section(\".rela.debug_info\")\n-\tif rela != nil && rela.Type == SHT_RELA && (f.Machine == EM_X86_64 || f.Machine == EM_PPC64) {\n+\tif rela != nil && rela.Type == SHT_RELA && (f.Machine == EM_X86_64 || f.Machine == EM_PPC64 || f.Machine == EM_S390) {\n \t\tdata, err := rela.Data()\n \t\tif err != nil {\n \t\t\treturn nil, err"}, {"sha": "1032c93c7e278f95517b04979129742878a3e2a5", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=1fec5f5274d7e232b75fc400321ed64be46766c3", "patch": "@@ -268,6 +268,8 @@ var cgoEnabled = map[string]bool{\n \t\"linux/386\":       true,\n \t\"linux/amd64\":     true,\n \t\"linux/arm\":       true,\n+\t\"linux/s390\":      true,\n+\t\"linux/s390x\":     true,\n \t\"netbsd/386\":      true,\n \t\"netbsd/amd64\":    true,\n \t\"netbsd/arm\":      true,"}, {"sha": "84712bd91fceb1f6011534f1c298418f6c9c5f27", "filename": "libgo/go/go/build/syslist.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Fgo%2Fbuild%2Fsyslist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Fgo%2Fbuild%2Fsyslist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fsyslist.go?ref=1fec5f5274d7e232b75fc400321ed64be46766c3", "patch": "@@ -5,4 +5,4 @@\n package build\n \n const goosList = \"darwin dragonfly freebsd linux nacl netbsd openbsd plan9 solaris windows \"\n-const goarchList = \"386 amd64 amd64p32 arm arm64 alpha m68k mipso32 mipsn32 mipsn64 mipso64 ppc ppc64 sparc sparc64 \"\n+const goarchList = \"386 amd64 amd64p32 arm arm64 alpha m68k mipso32 mipsn32 mipsn64 mipso64 ppc ppc64 s390 s390x sparc sparc64 \""}, {"sha": "eb4589c6ce9e7b924eac36368262ec5ad46f3b11", "filename": "libgo/go/reflect/makefunc.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Freflect%2Fmakefunc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Freflect%2Fmakefunc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc.go?ref=1fec5f5274d7e232b75fc400321ed64be46766c3", "patch": "@@ -61,7 +61,7 @@ func MakeFunc(typ Type, fn func(args []Value) (results []Value)) Value {\n \tvar code uintptr\n \tvar ffi *ffiData\n \tswitch runtime.GOARCH {\n-\tcase \"amd64\", \"386\":\n+\tcase \"amd64\", \"386\", \"s390\", \"s390x\":\n \t\t// Indirect Go func value (dummy) to obtain actual\n \t\t// code address. (A Go func value is a pointer to a C\n \t\t// function pointer. http://golang.org/s/go11func.)\n@@ -159,7 +159,7 @@ func makeValueMethod(v Value) Value {\n \t}\n \n \tswitch runtime.GOARCH {\n-\tcase \"amd64\", \"386\":\n+\tcase \"amd64\", \"386\", \"s390\", \"s390x\":\n \t\t// Indirect Go func value (dummy) to obtain actual\n \t\t// code address. (A Go func value is a pointer to a C\n \t\t// function pointer. http://golang.org/s/go11func.)"}, {"sha": "78a960ca2f671d1f1c3c54db2abaf767101eb8be", "filename": "libgo/go/reflect/makefunc_s390.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Freflect%2Fmakefunc_s390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Freflect%2Fmakefunc_s390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc_s390.c?ref=1fec5f5274d7e232b75fc400321ed64be46766c3", "patch": "@@ -0,0 +1,86 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#include \"runtime.h\"\n+#include \"go-panic.h\"\n+\n+#ifdef __s390x__\n+#  define S390_GO_USE_64_BIT_ABI 1\n+#  define S390_GO_S390X_ARGS , double f4, double f6\n+#  define S390_GO_S390X_FIELDS double f4; double f6;\n+   extern void S390xMakeFuncStubGo(void *, void *)\n+\tasm (\"reflect.S390xMakeFuncStubGo\");\n+#  define S390_GO_MakeFuncStubGo(r, c) S390xMakeFuncStubGo((r), (c))\n+#else\n+#  define S390_GO_USE_64_BIT_ABI 0\n+#  define S390_GO_S390X_ARGS\n+#  define S390_GO_S390X_FIELDS\n+   extern void S390MakeFuncStubGo(void *, void *)\n+\tasm (\"reflect.S390MakeFuncStubGo\");\n+#  define S390_GO_MakeFuncStubGo(r, c) S390MakeFuncStubGo((r), (c))\n+   /* Needed to make the unused 64 bit abi conditional code compile.  */\n+#  define f4 f0\n+#  define f6 f2\n+#endif\n+\n+/* Structure to store all registers used for parameter passing.  */\n+typedef struct\n+{\n+\tlong r2;\n+\tlong r3;\n+\tlong r4;\n+\tlong r5;\n+\tlong r6;\n+\t/* Pointer to non-register arguments on the stack.  */\n+\tlong stack_args;\n+\tdouble f0;\n+\tdouble f2;\n+\tS390_GO_S390X_FIELDS\n+} s390Regs;\n+\n+void\n+makeFuncStub(long r2, long r3, long r4, long r5, long r6,\n+\tunsigned long stack_args, double f0, double f2\n+\tS390_GO_S390X_ARGS)\n+\tasm (\"reflect.makeFuncStub\");\n+\n+void\n+makeFuncStub(long r2, long r3, long r4, long r5, long r6,\n+\tunsigned long stack_args, double f0, double f2\n+\tS390_GO_S390X_ARGS)\n+{\n+\ts390Regs regs;\n+\tvoid *closure;\n+\n+\t/* Store the registers in a structure that is passed on to the Go stub\n+\t   function.  */\n+\tregs.r2 = r2;\n+\tregs.r3 = r3;\n+\tregs.r4 = r4;\n+\tregs.r5 = r5;\n+\tregs.r6 = r6;\n+\tregs.stack_args = (long)&stack_args;\n+\tregs.f0 = f0;\n+\tregs.f2 = f2;\n+\tif (S390_GO_USE_64_BIT_ABI) {\n+\t\tregs.f4 = f4;\n+\t\tregs.f6 = f6;\n+\t}\n+\t/* For MakeFunc functions that call recover.  */\n+\t__go_makefunc_can_recover(__builtin_return_address(0));\n+\t/* Call the Go stub function.  */\n+\tclosure = __go_get_closure();\n+\tS390_GO_MakeFuncStubGo(&regs, closure);\n+\t/* MakeFunc functions can no longer call recover.  */\n+\t__go_makefunc_returning();\n+\t/* Restore all possible return registers.  */\n+\tif (S390_GO_USE_64_BIT_ABI) {\n+\t\tasm volatile (\"lg\\t%%r2,0(%0)\" : : \"a\" (&regs.r2) : \"r2\" );\n+\t\tasm volatile (\"ld\\t%%f0,0(%0)\" : : \"a\" (&regs.f0) : \"f0\" );\n+\t} else {\n+\t\tasm volatile (\"l\\t%%r2,0(%0)\" : : \"a\" (&regs.r2) : \"r2\" );\n+\t\tasm volatile (\"l\\t%%r3,0(%0)\" : : \"a\" (&regs.r3) : \"r3\" );\n+\t\tasm volatile (\"ld\\t%%f0,0(%0)\" : : \"a\" (&regs.f0) : \"f0\" );\n+\t}\n+}"}, {"sha": "ff22add81a1254916b782d897d0e43c87b2c2a66", "filename": "libgo/go/reflect/makefuncgo_s390.go", "status": "added", "additions": 453, "deletions": 0, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Freflect%2Fmakefuncgo_s390.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Freflect%2Fmakefuncgo_s390.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefuncgo_s390.go?ref=1fec5f5274d7e232b75fc400321ed64be46766c3", "patch": "@@ -0,0 +1,453 @@\n+// Copyright 2014 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// MakeFunc s390 implementation.\n+\n+package reflect\n+\n+import \"unsafe\"\n+\n+// Convenience types and constants.\n+const s390_arch_stack_slot_align uintptr = 4\n+const s390_num_gr = 5\n+const s390_num_fr = 2\n+\n+type s390_arch_gr_t uint32\n+type s390_arch_fr_t uint64\n+\n+// The assembler stub will pass a pointer to this structure.\n+// This will come in holding all the registers that might hold\n+// function parameters.  On return we will set the registers that\n+// might hold result values.\n+type s390_regs struct {\n+\tr2         s390_arch_gr_t\n+\tr3         s390_arch_gr_t\n+\tr4         s390_arch_gr_t\n+\tr5         s390_arch_gr_t\n+\tr6         s390_arch_gr_t\n+\tstack_args s390_arch_gr_t\n+\tf0         s390_arch_fr_t\n+\tf2         s390_arch_fr_t\n+}\n+\n+// Argument classifications that arise for Go types.\n+type s390_arg_t int\n+\n+const (\n+\ts390_general_reg s390_arg_t = iota\n+\ts390_general_reg_pair\n+\ts390_float_reg\n+\t// Argument passed as a pointer to an in-memory value.\n+\ts390_mem_ptr\n+\ts390_empty\n+)\n+\n+// s390ClassifyParameter returns the register class needed to\n+// pass the value of type TYP.  s390_empty means the register is\n+// not used.  The second and third return values are the offset of\n+// an rtype parameter passed in a register (second) or stack slot\n+// (third).\n+func s390ClassifyParameter(typ *rtype) (s390_arg_t, uintptr, uintptr) {\n+\toffset := s390_arch_stack_slot_align - typ.Size()\n+\tif typ.Size() > s390_arch_stack_slot_align {\n+\t\toffset = 0\n+\t}\n+\tswitch typ.Kind() {\n+\tdefault:\n+\t\tpanic(\"internal error--unknown kind in s390ClassifyParameter\")\n+\tcase Bool, Int, Int8, Int16, Int32, Uint, Uint8, Uint16, Uint32:\n+\t\treturn s390_general_reg, offset, offset\n+\tcase Int64, Uint64:\n+\t\treturn s390_general_reg_pair, 0, 0\n+\tcase Uintptr, Chan, Func, Map, Ptr, UnsafePointer:\n+\t\treturn s390_general_reg, 0, 0\n+\tcase Float32, Float64:\n+\t\treturn s390_float_reg, 0, offset\n+\tcase Complex64, Complex128:\n+\t\t// Complex numbers are passed by reference.\n+\t\treturn s390_mem_ptr, 0, 0\n+\tcase Array, Struct:\n+\t\tvar ityp *rtype\n+\t\tvar length int\n+\n+\t\tif typ.Size() == 0 {\n+\t\t\treturn s390_empty, 0, 0\n+\t\t}\n+\t\tswitch typ.Size() {\n+\t\tdefault:\n+\t\t\t// Pointer to memory.\n+\t\t\treturn s390_mem_ptr, 0, 0\n+\t\tcase 1, 2:\n+\t\t\t// Pass in an integer register.\n+\t\t\treturn s390_general_reg, offset, offset\n+\n+\t\tcase 4, 8:\n+\t\t\t// See below.\n+\t\t}\n+\t\tif typ.Kind() == Array {\n+\t\t\tatyp := (*arrayType)(unsafe.Pointer(typ))\n+\t\t\tlength = atyp.Len()\n+\t\t\tityp = atyp.elem\n+\t\t} else {\n+\t\t\tstyp := (*structType)(unsafe.Pointer(typ))\n+\t\t\tlength = len(styp.fields)\n+\t\t\tityp = styp.fields[0].typ\n+\t\t}\n+\t\tif length == 1 {\n+\t\t\tclass, off_reg, off_slot := s390ClassifyParameter(ityp)\n+\t\t\tif class == s390_float_reg {\n+\t\t\t\t// The array (stored in a structure) or struct\n+\t\t\t\t// is \"equivalent to a floating point type\" as\n+\t\t\t\t// defined in the S390 Abi.  Note that this\n+\t\t\t\t// can only be the case in the case 4 of the\n+\t\t\t\t// switch above.\n+\t\t\t\treturn s390_float_reg, off_reg, off_slot\n+\t\t\t}\n+\t\t}\n+\t\tswitch typ.Size() {\n+\t\tcase 4:\n+\t\t\treturn s390_general_reg, offset, offset\n+\t\tcase 8:\n+\t\t\treturn s390_general_reg_pair, 0, 0\n+\t\tdefault:\n+\t\t\treturn s390_general_reg, 0, 0\n+\t\t}\n+\tcase Interface, String:\n+\t\t// Structure of size 8.\n+\t\treturn s390_general_reg_pair, 0, 0\n+\n+\tcase Slice:\n+\t\treturn s390_mem_ptr, 0, 0\n+\t}\n+}\n+\n+// s390ClassifyReturn returns the register classes needed to\n+// return the value of type TYP.  s390_empty means the register is\n+// not used.  The second value is the offset of an rtype return\n+// parameter if stored in a register.\n+func s390ClassifyReturn(typ *rtype) (s390_arg_t, uintptr) {\n+\toffset := s390_arch_stack_slot_align - typ.Size()\n+\tif typ.Size() > s390_arch_stack_slot_align {\n+\t\toffset = 0\n+\t}\n+\tswitch typ.Kind() {\n+\tdefault:\n+\t\tpanic(\"internal error--unknown kind in s390ClassifyReturn\")\n+\tcase Bool, Int, Int8, Int16, Int32,\n+\t\tUint, Uint8, Uint16, Uint32, Uintptr:\n+\n+\t\treturn s390_general_reg, offset\n+\tcase Int64, Uint64:\n+\t\treturn s390_general_reg_pair, 0\n+\tcase Chan, Func, Map, Ptr, UnsafePointer:\n+\t\treturn s390_general_reg, 0\n+\tcase Float32, Float64:\n+\t\treturn s390_float_reg, 0\n+\tcase Complex64, Complex128:\n+\t\treturn s390_mem_ptr, 0\n+\tcase Interface, Slice, String:\n+\t\treturn s390_mem_ptr, 0\n+\tcase Array, Struct:\n+\t\tif typ.size == 0 {\n+\t\t\treturn s390_empty, 0\n+\t\t}\n+\t\t// No optimization is done for returned structures and arrays.\n+\t\treturn s390_mem_ptr, 0\n+\t}\n+}\n+\n+// Given a value of type *rtype left aligned in an unsafe.Pointer,\n+// reload the value so that it can be stored in a general or\n+// floating point register.  For general registers the value is\n+// sign extend and right aligned.\n+func s390ReloadForRegister(typ *rtype, w uintptr, offset uintptr) uintptr {\n+\tvar do_sign_extend bool = false\n+\tvar gr s390_arch_gr_t\n+\n+\tswitch typ.Kind() {\n+\tcase Int, Int8, Int16, Int32:\n+\t\tdo_sign_extend = true\n+\tdefault:\n+\t\t// Handle all other cases in the next switch.\n+\t}\n+\tswitch typ.size {\n+\tcase 1:\n+\t\tif do_sign_extend == true {\n+\t\t\tse := int32(*(*int8)(unsafe.Pointer(&w)))\n+\t\t\tgr = *(*s390_arch_gr_t)(unsafe.Pointer(&se))\n+\t\t} else {\n+\t\t\te := int32(*(*uint8)(unsafe.Pointer(&w)))\n+\t\t\tgr = *(*s390_arch_gr_t)(unsafe.Pointer(&e))\n+\t\t}\n+\tcase 2:\n+\t\tif do_sign_extend == true {\n+\t\t\tse := int32(*(*int16)(unsafe.Pointer(&w)))\n+\t\t\tgr = *(*s390_arch_gr_t)(unsafe.Pointer(&se))\n+\t\t} else {\n+\t\t\te := int32(*(*uint16)(unsafe.Pointer(&w)))\n+\t\t\tgr = *(*s390_arch_gr_t)(unsafe.Pointer(&e))\n+\t\t}\n+\tdefault:\n+\t\tpanic(\"reflect: bad size in s390ReloadForRegister\")\n+\t}\n+\n+\treturn *(*uintptr)(unsafe.Pointer(&gr))\n+}\n+\n+// MakeFuncStubGo implements the s390 calling convention for\n+// MakeFunc.  This should not be called.  It is exported so that\n+// assembly code can call it.\n+func S390MakeFuncStubGo(regs *s390_regs, c *makeFuncImpl) {\n+\tftyp := c.typ\n+\tgr := 0\n+\tfr := 0\n+\tap := uintptr(regs.stack_args)\n+\n+\t// See if the result requires a struct.  If it does, the first\n+\t// parameter is a pointer to the struct.\n+\tvar ret_class s390_arg_t\n+\tvar ret_off_reg uintptr\n+\tvar ret_type *rtype\n+\n+\tswitch len(ftyp.out) {\n+\tcase 0:\n+\t\tret_type = nil\n+\t\tret_class, ret_off_reg = s390_empty, 0\n+\tcase 1:\n+\t\tret_type = ftyp.out[0]\n+\t\tret_class, ret_off_reg = s390ClassifyReturn(ret_type)\n+\tdefault:\n+\t\tret_type = nil\n+\t\tret_class, ret_off_reg = s390_mem_ptr, 0\n+\t}\n+\tin := make([]Value, 0, len(ftyp.in))\n+\tif ret_class == s390_mem_ptr {\n+\t\t// We are returning a value in memory, which means\n+\t\t// that the first argument is a hidden parameter\n+\t\t// pointing to that return area.\n+\t\tgr++\n+\t}\n+\n+argloop:\n+\tfor _, rt := range ftyp.in {\n+\t\tclass, off_reg, off_slot := s390ClassifyParameter(rt)\n+\t\tfl := flag(rt.Kind()) << flagKindShift\n+\t\tswitch class {\n+\t\tcase s390_empty:\n+\t\t\tv := Value{rt, nil, fl | flagIndir}\n+\t\t\tin = append(in, v)\n+\t\t\tcontinue argloop\n+\t\tcase s390_general_reg:\n+\t\t\t// Values stored in a general register are right\n+\t\t\t// aligned.\n+\t\t\tif gr < s390_num_gr {\n+\t\t\t\tval := s390_general_reg_val(regs, gr)\n+\t\t\t\tiw := unsafe.Pointer(&val)\n+\t\t\t\tk := rt.Kind()\n+\t\t\t\tif k != Ptr && k != UnsafePointer {\n+\t\t\t\t\tix := uintptr(unsafe.Pointer(&val))\n+\t\t\t\t\tix += off_reg\n+\t\t\t\t\tiw = unsafe.Pointer(ix)\n+\t\t\t\t\tfl |= flagIndir\n+\t\t\t\t}\n+\t\t\t\tv := Value{rt, iw, fl}\n+\t\t\t\tin = append(in, v)\n+\t\t\t\tgr++\n+\t\t\t} else {\n+\t\t\t\tin, ap = s390_add_stackreg(\n+\t\t\t\t\tin, ap, rt, off_slot)\n+\t\t\t}\n+\t\t\tcontinue argloop\n+\t\tcase s390_general_reg_pair:\n+\t\t\t// 64-bit integers and structs are passed in a register\n+\t\t\t// pair.\n+\t\t\tif gr+1 < s390_num_gr {\n+\t\t\t\tval := uint64(s390_general_reg_val(regs, gr))<<32 + uint64(s390_general_reg_val(regs, gr+1))\n+\t\t\t\tiw := unsafe.Pointer(&val)\n+\t\t\t\tv := Value{rt, iw, fl | flagIndir}\n+\t\t\t\tin = append(in, v)\n+\t\t\t\tgr += 2\n+\t\t\t} else {\n+\t\t\t\tin, ap = s390_add_stackreg(in, ap, rt, off_slot)\n+\t\t\t\tgr = s390_num_gr\n+\t\t\t}\n+\t\t\tcontinue argloop\n+\t\tcase s390_float_reg:\n+\t\t\t// In a register, floats are left aligned, but in a\n+\t\t\t// stack slot they are right aligned.\n+\t\t\tif fr < s390_num_fr {\n+\t\t\t\tval := s390_float_reg_val(regs, fr)\n+\t\t\t\tix := uintptr(unsafe.Pointer(&val))\n+\t\t\t\tv := Value{\n+\t\t\t\t\trt, unsafe.Pointer(unsafe.Pointer(ix)),\n+\t\t\t\t\tfl | flagIndir,\n+\t\t\t\t}\n+\t\t\t\tin = append(in, v)\n+\t\t\t\tfr++\n+\t\t\t} else {\n+\t\t\t\tin, ap = s390_add_stackreg(\n+\t\t\t\t\tin, ap, rt, off_slot)\n+\t\t\t}\n+\t\t\tcontinue argloop\n+\t\tcase s390_mem_ptr:\n+\t\t\tif gr < s390_num_gr {\n+\t\t\t\t// Register holding a pointer to memory.\n+\t\t\t\tval := s390_general_reg_val(regs, gr)\n+\t\t\t\tv := Value{\n+\t\t\t\t\trt, unsafe.Pointer(uintptr(val)),\n+\t\t\t\t\tfl | flagIndir}\n+\t\t\t\tin = append(in, v)\n+\t\t\t\tgr++\n+\t\t\t} else {\n+\t\t\t\t// Stack slot holding a pointer to memory.\n+\t\t\t\tin, ap = s390_add_memarg(in, ap, rt)\n+\t\t\t}\n+\t\t\tcontinue argloop\n+\t\t}\n+\t\tpanic(\"reflect: argtype not handled in MakeFunc:argloop\")\n+\t}\n+\n+\t// All the real arguments have been found and turned into\n+\t// Values.  Call the real function.\n+\n+\tout := c.call(in)\n+\n+\tif len(out) != len(ftyp.out) {\n+\t\tpanic(\"reflect: wrong return count from function created by MakeFunc\")\n+\t}\n+\n+\tfor i, typ := range ftyp.out {\n+\t\tv := out[i]\n+\t\tif v.typ != typ {\n+\t\t\tpanic(\n+\t\t\t\t\"reflect: function created by MakeFunc using \" +\n+\t\t\t\t\tfuncName(c.fn) + \" returned wrong type: have \" +\n+\t\t\t\t\tout[i].typ.String() + \" for \" + typ.String())\n+\t\t}\n+\t\tif v.flag&flagRO != 0 {\n+\t\t\tpanic(\n+\t\t\t\t\"reflect: function created by MakeFunc using \" +\n+\t\t\t\t\tfuncName(c.fn) + \" returned value obtained \" +\n+\t\t\t\t\t\"from unexported field\")\n+\t\t}\n+\t}\n+\n+\tswitch ret_class {\n+\tcase s390_general_reg, s390_float_reg, s390_general_reg_pair:\n+\t\t// Single return value in a general or floating point register.\n+\t\tv := out[0]\n+\t\tvar w uintptr\n+\t\tif v.Kind() == Ptr || v.Kind() == UnsafePointer {\n+\t\t\tw = uintptr(v.pointer())\n+\t\t} else {\n+\t\t\tw = uintptr(loadScalar(v.ptr, v.typ.size))\n+\t\t\tif ret_off_reg != 0 {\n+\t\t\t\tw = s390ReloadForRegister(\n+\t\t\t\t\tret_type, w, ret_off_reg)\n+\t\t\t}\n+\t\t}\n+\t\tif ret_class == s390_float_reg {\n+\t\t\tregs.f0 = s390_arch_fr_t(uintptr(w))\n+\t\t} else if ret_class == s390_general_reg {\n+\t\t\tregs.r2 = s390_arch_gr_t(uintptr(w))\n+\t\t} else {\n+\t\t\tregs.r2 = s390_arch_gr_t(uintptr(w) >> 32)\n+\t\t\tregs.r3 = s390_arch_gr_t(uintptr(w) & 0xffffffff)\n+\t\t}\n+\n+\tcase s390_mem_ptr:\n+\t\t// The address of the memory area was passed as a hidden\n+\t\t// parameter in %r2.  Multiple return values are always returned\n+\t\t// in an in-memory structure.\n+\t\tptr := unsafe.Pointer(uintptr(regs.r2))\n+\t\toff := uintptr(0)\n+\t\tfor i, typ := range ftyp.out {\n+\t\t\tv := out[i]\n+\t\t\toff = align(off, uintptr(typ.fieldAlign))\n+\t\t\taddr := unsafe.Pointer(uintptr(ptr) + off)\n+\t\t\tif v.flag&flagIndir == 0 && (v.kind() == Ptr || v.kind() == UnsafePointer) {\n+\t\t\t\t*(*unsafe.Pointer)(addr) = v.ptr\n+\t\t\t} else {\n+\t\t\t\tmemmove(addr, v.ptr, typ.size)\n+\t\t\t}\n+\t\t\toff += typ.size\n+\t\t}\n+\n+\tcase s390_empty:\n+\t}\n+\n+\treturn\n+}\n+\n+// The s390_add_stackreg function adds an argument passed on the\n+// stack that could be passed in a register.\n+func s390_add_stackreg(in []Value, ap uintptr, rt *rtype, offset uintptr) ([]Value, uintptr) {\n+\t// If we're not already at the beginning of a stack slot, round up to\n+\t// the beginning of the next one.\n+\tap = align(ap, s390_arch_stack_slot_align)\n+\t// If offset is > 0, the data is right aligned on the stack slot.\n+\tap += offset\n+\n+\t// We have to copy the argument onto the heap in case the\n+\t// function hangs onto the reflect.Value we pass it.\n+\tp := unsafe_New(rt)\n+\tmemmove(p, unsafe.Pointer(ap), rt.size)\n+\n+\tv := Value{rt, p, flag(rt.Kind()<<flagKindShift) | flagIndir}\n+\tin = append(in, v)\n+\tap += rt.size\n+\tap = align(ap, s390_arch_stack_slot_align)\n+\n+\treturn in, ap\n+}\n+\n+// The s390_add_memarg function adds an argument passed in memory.\n+func s390_add_memarg(in []Value, ap uintptr, rt *rtype) ([]Value, uintptr) {\n+\t// If we're not already at the beginning of a stack slot,\n+\t// round up to the beginning of the next one.\n+\tap = align(ap, s390_arch_stack_slot_align)\n+\n+\t// We have to copy the argument onto the heap in case the\n+\t// function hangs onto the reflect.Value we pass it.\n+\tp := unsafe_New(rt)\n+\tmemmove(p, *(*unsafe.Pointer)(unsafe.Pointer(ap)), rt.size)\n+\n+\tv := Value{rt, p, flag(rt.Kind()<<flagKindShift) | flagIndir}\n+\tin = append(in, v)\n+\tap += s390_arch_stack_slot_align\n+\n+\treturn in, ap\n+}\n+\n+// The s390_general_reg_val function returns the value of integer register GR.\n+func s390_general_reg_val(regs *s390_regs, gr int) s390_arch_gr_t {\n+\tswitch gr {\n+\tcase 0:\n+\t\treturn regs.r2\n+\tcase 1:\n+\t\treturn regs.r3\n+\tcase 2:\n+\t\treturn regs.r4\n+\tcase 3:\n+\t\treturn regs.r5\n+\tcase 4:\n+\t\treturn regs.r6\n+\tdefault:\n+\t\tpanic(\"s390_general_reg_val: bad integer register\")\n+\t}\n+}\n+\n+// The s390_float_reg_val function returns the value of float register FR.\n+func s390_float_reg_val(regs *s390_regs, fr int) uintptr {\n+\tvar r s390_arch_fr_t\n+\tswitch fr {\n+\tcase 0:\n+\t\tr = regs.f0\n+\tcase 1:\n+\t\tr = regs.f2\n+\tdefault:\n+\t\tpanic(\"s390_float_reg_val: bad floating point register\")\n+\t}\n+\treturn uintptr(r)\n+}"}, {"sha": "a0a5567f3b971d594658babfaa9661e9acdfa364", "filename": "libgo/go/reflect/makefuncgo_s390x.go", "status": "added", "additions": 435, "deletions": 0, "changes": 435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Freflect%2Fmakefuncgo_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Freflect%2Fmakefuncgo_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefuncgo_s390x.go?ref=1fec5f5274d7e232b75fc400321ed64be46766c3", "patch": "@@ -0,0 +1,435 @@\n+// Copyright 2014 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// MakeFunc s390x implementation.\n+\n+package reflect\n+\n+import \"unsafe\"\n+\n+// Convenience types and constants.\n+const s390x_arch_stack_slot_align uintptr = 8\n+const s390x_num_gr = 5\n+const s390x_num_fr = 4\n+\n+type s390x_arch_gr_t uint64\n+type s390x_arch_fr_t uint64\n+\n+// The assembler stub will pass a pointer to this structure.\n+// This will come in holding all the registers that might hold\n+// function parameters.  On return we will set the registers that\n+// might hold result values.\n+type s390x_regs struct {\n+\tr2         s390x_arch_gr_t\n+\tr3         s390x_arch_gr_t\n+\tr4         s390x_arch_gr_t\n+\tr5         s390x_arch_gr_t\n+\tr6         s390x_arch_gr_t\n+\tstack_args s390x_arch_gr_t\n+\tf0         s390x_arch_fr_t\n+\tf2         s390x_arch_fr_t\n+\tf4         s390x_arch_fr_t\n+\tf6         s390x_arch_fr_t\n+}\n+\n+// Argument classifications that arise for Go types.\n+type s390x_arg_t int\n+\n+const (\n+\ts390x_general_reg s390x_arg_t = iota\n+\ts390x_float_reg\n+\t// Argument passed as a pointer to an in-memory value.\n+\ts390x_mem_ptr\n+\ts390x_empty\n+)\n+\n+// s390xClassifyParameter returns the register class needed to\n+// pass the value of type TYP.  s390x_empty means the register is\n+// not used.  The second and third return values are the offset of\n+// an rtype parameter passed in a register (second) or stack slot\n+// (third).\n+func s390xClassifyParameter(typ *rtype) (s390x_arg_t, uintptr, uintptr) {\n+\toffset := s390x_arch_stack_slot_align - typ.Size()\n+\tswitch typ.Kind() {\n+\tdefault:\n+\t\tpanic(\"internal error--unknown kind in s390xClassifyParameter\")\n+\tcase Bool, Int, Int8, Int16, Int32, Uint, Uint8, Uint16, Uint32:\n+\t\treturn s390x_general_reg, offset, offset\n+\tcase Int64, Uint64, Uintptr, Chan, Func, Map, Ptr, UnsafePointer:\n+\t\treturn s390x_general_reg, 0, 0\n+\tcase Float32, Float64:\n+\t\treturn s390x_float_reg, 0, offset\n+\tcase Complex64, Complex128:\n+\t\t// Complex numbers are passed by reference.\n+\t\treturn s390x_mem_ptr, 0, 0\n+\tcase Array, Struct:\n+\t\tvar ityp *rtype\n+\t\tvar length int\n+\n+\t\tif typ.Size() == 0 {\n+\t\t\treturn s390x_empty, 0, 0\n+\t\t}\n+\t\tswitch typ.Size() {\n+\t\tdefault:\n+\t\t\t// Pointer to memory.\n+\t\t\treturn s390x_mem_ptr, 0, 0\n+\t\tcase 1, 2:\n+\t\t\t// Pass in an integer register.\n+\t\t\treturn s390x_general_reg, offset, offset\n+\n+\t\tcase 4, 8:\n+\t\t\t// See below.\n+\t\t}\n+\t\tif typ.Kind() == Array {\n+\t\t\tatyp := (*arrayType)(unsafe.Pointer(typ))\n+\t\t\tlength = atyp.Len()\n+\t\t\tityp = atyp.elem\n+\t\t} else {\n+\t\t\tstyp := (*structType)(unsafe.Pointer(typ))\n+\t\t\tlength = len(styp.fields)\n+\t\t\tityp = styp.fields[0].typ\n+\t\t}\n+\t\tif length == 1 {\n+\t\t\tclass, off_reg, off_slot := s390xClassifyParameter(ityp)\n+\t\t\tif class == s390x_float_reg {\n+\t\t\t\t// The array (stored in a structure) or struct\n+\t\t\t\t// is \"equivalent to a floating point type\" as\n+\t\t\t\t// defined in the S390x Abi.  Note that this\n+\t\t\t\t// can only be the case in the cases 4 and 8 of\n+\t\t\t\t// the switch above.\n+\t\t\t\treturn s390x_float_reg, off_reg, off_slot\n+\t\t\t}\n+\t\t}\n+\t\t// Otherwise pass in an integer register.\n+\t\tswitch typ.Size() {\n+\t\tcase 4, 8:\n+\t\t\treturn s390x_general_reg, offset, offset\n+\t\tdefault:\n+\t\t\treturn s390x_general_reg, 0, 0\n+\t\t}\n+\tcase Interface, Slice, String:\n+\t\treturn s390x_mem_ptr, 0, 0\n+\t}\n+}\n+\n+// s390xClassifyReturn returns the register classes needed to\n+// return the value of type TYP.  s390_empty means the register is\n+// not used.  The second value is the offset of an rtype return\n+// parameter if stored in a register.\n+func s390xClassifyReturn(typ *rtype) (s390x_arg_t, uintptr) {\n+\toffset := s390x_arch_stack_slot_align - typ.Size()\n+\tswitch typ.Kind() {\n+\tdefault:\n+\t\tpanic(\"internal error--unknown kind in s390xClassifyReturn\")\n+\tcase Bool, Int, Int8, Int16, Int32, Int64,\n+\t\tUint, Uint8, Uint16, Uint32, Uint64, Uintptr:\n+\n+\t\treturn s390x_general_reg, offset\n+\tcase Chan, Func, Map, Ptr, UnsafePointer:\n+\t\treturn s390x_general_reg, 0\n+\tcase Float32, Float64:\n+\t\treturn s390x_float_reg, 0\n+\tcase Complex64, Complex128:\n+\t\treturn s390x_mem_ptr, 0\n+\tcase Interface, Slice, String:\n+\t\treturn s390x_mem_ptr, 0\n+\tcase Array, Struct:\n+\t\tif typ.size == 0 {\n+\t\t\treturn s390x_empty, 0\n+\t\t}\n+\t\t// No optimization is done for returned structures and arrays.\n+\t\treturn s390x_mem_ptr, 0\n+\t}\n+}\n+\n+// Given a value of type *rtype left aligned in an unsafe.Pointer,\n+// reload the value so that it can be stored in a general or\n+// floating point register.  For general registers the value is\n+// sign extend and right aligned.\n+func s390xReloadForRegister(typ *rtype, w uintptr, offset uintptr) uintptr {\n+\tvar do_sign_extend bool = false\n+\tvar gr s390x_arch_gr_t\n+\n+\tswitch typ.Kind() {\n+\tcase Int, Int8, Int16, Int32, Int64:\n+\t\tdo_sign_extend = true\n+\tdefault:\n+\t\t// Handle all other cases in the next switch.\n+\t}\n+\tswitch typ.size {\n+\tcase 1:\n+\t\tif do_sign_extend == true {\n+\t\t\tse := int64(*(*int8)(unsafe.Pointer(&w)))\n+\t\t\tgr = *(*s390x_arch_gr_t)(unsafe.Pointer(&se))\n+\t\t} else {\n+\t\t\te := int64(*(*uint8)(unsafe.Pointer(&w)))\n+\t\t\tgr = *(*s390x_arch_gr_t)(unsafe.Pointer(&e))\n+\t\t}\n+\tcase 2:\n+\t\tif do_sign_extend == true {\n+\t\t\tse := int64(*(*int16)(unsafe.Pointer(&w)))\n+\t\t\tgr = *(*s390x_arch_gr_t)(unsafe.Pointer(&se))\n+\t\t} else {\n+\t\t\te := int64(*(*uint16)(unsafe.Pointer(&w)))\n+\t\t\tgr = *(*s390x_arch_gr_t)(unsafe.Pointer(&e))\n+\t\t}\n+\tcase 4:\n+\t\tif do_sign_extend == true {\n+\t\t\tse := int64(*(*int32)(unsafe.Pointer(&w)))\n+\t\t\tgr = *(*s390x_arch_gr_t)(unsafe.Pointer(&se))\n+\t\t} else {\n+\t\t\te := int64(*(*uint32)(unsafe.Pointer(&w)))\n+\t\t\tgr = *(*s390x_arch_gr_t)(unsafe.Pointer(&e))\n+\t\t}\n+\tdefault:\n+\t\tpanic(\"reflect: bad size in s390xReloadForRegister\")\n+\t}\n+\n+\treturn *(*uintptr)(unsafe.Pointer(&gr))\n+}\n+\n+// MakeFuncStubGo implements the s390x calling convention for\n+// MakeFunc.  This should not be called.  It is exported so that\n+// assembly code can call it.\n+func S390xMakeFuncStubGo(regs *s390x_regs, c *makeFuncImpl) {\n+\tftyp := c.typ\n+\tgr := 0\n+\tfr := 0\n+\tap := uintptr(regs.stack_args)\n+\n+\t// See if the result requires a struct.  If it does, the first\n+\t// parameter is a pointer to the struct.\n+\tvar ret_class s390x_arg_t\n+\tvar ret_off_reg uintptr\n+\tvar ret_type *rtype\n+\n+\tswitch len(ftyp.out) {\n+\tcase 0:\n+\t\tret_type = nil\n+\t\tret_class, ret_off_reg = s390x_empty, 0\n+\tcase 1:\n+\t\tret_type = ftyp.out[0]\n+\t\tret_class, ret_off_reg = s390xClassifyReturn(ret_type)\n+\tdefault:\n+\t\tret_type = nil\n+\t\tret_class, ret_off_reg = s390x_mem_ptr, 0\n+\t}\n+\tin := make([]Value, 0, len(ftyp.in))\n+\tif ret_class == s390x_mem_ptr {\n+\t\t// We are returning a value in memory, which means\n+\t\t// that the first argument is a hidden parameter\n+\t\t// pointing to that return area.\n+\t\tgr++\n+\t}\n+\n+argloop:\n+\tfor _, rt := range ftyp.in {\n+\t\tclass, off_reg, off_slot := s390xClassifyParameter(rt)\n+\t\tfl := flag(rt.Kind()) << flagKindShift\n+\t\tswitch class {\n+\t\tcase s390x_empty:\n+\t\t\tv := Value{rt, nil, fl | flagIndir}\n+\t\t\tin = append(in, v)\n+\t\t\tcontinue argloop\n+\t\tcase s390x_general_reg:\n+\t\t\t// Values stored in a general register are right\n+\t\t\t// aligned.\n+\t\t\tif gr < s390x_num_gr {\n+\t\t\t\tval := s390x_general_reg_val(regs, gr)\n+\t\t\t\tiw := unsafe.Pointer(val)\n+\t\t\t\tk := rt.Kind()\n+\t\t\t\tif k != Ptr && k != UnsafePointer {\n+\t\t\t\t\tix := uintptr(unsafe.Pointer(&val))\n+\t\t\t\t\tix += off_reg\n+\t\t\t\t\tiw = unsafe.Pointer(ix)\n+\t\t\t\t\tfl |= flagIndir\n+\t\t\t\t}\n+\t\t\t\tv := Value{rt, iw, fl}\n+\t\t\t\tin = append(in, v)\n+\t\t\t\tgr++\n+\t\t\t} else {\n+\t\t\t\tin, ap = s390x_add_stackreg(\n+\t\t\t\t\tin, ap, rt, off_slot)\n+\t\t\t}\n+\t\t\tcontinue argloop\n+\t\tcase s390x_float_reg:\n+\t\t\t// In a register, floats are left aligned, but in a\n+\t\t\t// stack slot they are right aligned.\n+\t\t\tif fr < s390x_num_fr {\n+\t\t\t\tval := s390x_float_reg_val(regs, fr)\n+\t\t\t\tix := uintptr(unsafe.Pointer(&val))\n+\t\t\t\tv := Value{\n+\t\t\t\t\trt, unsafe.Pointer(unsafe.Pointer(ix)),\n+\t\t\t\t\tfl | flagIndir,\n+\t\t\t\t}\n+\t\t\t\tin = append(in, v)\n+\t\t\t\tfr++\n+\t\t\t} else {\n+\t\t\t\tin, ap = s390x_add_stackreg(\n+\t\t\t\t\tin, ap, rt, off_slot)\n+\t\t\t}\n+\t\t\tcontinue argloop\n+\t\tcase s390x_mem_ptr:\n+\t\t\tif gr < s390x_num_gr {\n+\t\t\t\t// Register holding a pointer to memory.\n+\t\t\t\tval := s390x_general_reg_val(regs, gr)\n+\t\t\t\tv := Value{\n+\t\t\t\t\trt, unsafe.Pointer(val), fl | flagIndir}\n+\t\t\t\tin = append(in, v)\n+\t\t\t\tgr++\n+\t\t\t} else {\n+\t\t\t\t// Stack slot holding a pointer to memory.\n+\t\t\t\tin, ap = s390x_add_memarg(in, ap, rt)\n+\t\t\t}\n+\t\t\tcontinue argloop\n+\t\t}\n+\t\tpanic(\"reflect: argtype not handled in MakeFunc:argloop\")\n+\t}\n+\n+\t// All the real arguments have been found and turned into\n+\t// Values.  Call the real function.\n+\n+\tout := c.call(in)\n+\n+\tif len(out) != len(ftyp.out) {\n+\t\tpanic(\"reflect: wrong return count from function created by MakeFunc\")\n+\t}\n+\n+\tfor i, typ := range ftyp.out {\n+\t\tv := out[i]\n+\t\tif v.typ != typ {\n+\t\t\tpanic(\n+\t\t\t\t\"reflect: function created by MakeFunc using \" +\n+\t\t\t\t\tfuncName(c.fn) + \" returned wrong type: have \" +\n+\t\t\t\t\tout[i].typ.String() + \" for \" + typ.String())\n+\t\t}\n+\t\tif v.flag&flagRO != 0 {\n+\t\t\tpanic(\n+\t\t\t\t\"reflect: function created by MakeFunc using \" +\n+\t\t\t\t\tfuncName(c.fn) + \" returned value obtained \" +\n+\t\t\t\t\t\"from unexported field\")\n+\t\t}\n+\t}\n+\n+\tswitch ret_class {\n+\tcase s390x_general_reg, s390x_float_reg:\n+\t\t// Single return value in a general or floating point register.\n+\t\tv := out[0]\n+\t\tvar w uintptr\n+\t\tif v.Kind() == Ptr || v.Kind() == UnsafePointer {\n+\t\t\tw = uintptr(v.pointer())\n+\t\t} else {\n+\t\t\tw = uintptr(loadScalar(v.ptr, v.typ.size))\n+\t\t\tif ret_off_reg != 0 {\n+\t\t\t\tw = s390xReloadForRegister(\n+\t\t\t\t\tret_type, w, ret_off_reg)\n+\t\t\t}\n+\t\t}\n+\t\tif ret_class == s390x_float_reg {\n+\t\t\tregs.f0 = s390x_arch_fr_t(w)\n+\t\t} else {\n+\t\t\tregs.r2 = s390x_arch_gr_t(w)\n+\t\t}\n+\n+\tcase s390x_mem_ptr:\n+\t\t// The address of the memory area was passed as a hidden\n+\t\t// parameter in %r2.  Multiple return values are always returned\n+\t\t// in an in-memory structure.\n+\t\tptr := unsafe.Pointer(uintptr(regs.r2))\n+\t\toff := uintptr(0)\n+\t\tfor i, typ := range ftyp.out {\n+\t\t\tv := out[i]\n+\t\t\toff = align(off, uintptr(typ.fieldAlign))\n+\t\t\taddr := unsafe.Pointer(uintptr(ptr) + off)\n+\t\t\tif v.flag&flagIndir == 0 && (v.kind() == Ptr || v.kind() == UnsafePointer) {\n+\t\t\t\t*(*unsafe.Pointer)(addr) = v.ptr\n+\t\t\t} else {\n+\t\t\t\tmemmove(addr, v.ptr, typ.size)\n+\t\t\t}\n+\t\t\toff += typ.size\n+\t\t}\n+\n+\tcase s390x_empty:\n+\t}\n+\n+\treturn\n+}\n+\n+// The s390x_add_stackreg function adds an argument passed on the\n+// stack that could be passed in a register.\n+func s390x_add_stackreg(in []Value, ap uintptr, rt *rtype, offset uintptr) ([]Value, uintptr) {\n+\t// If we're not already at the beginning of a stack slot, round up to\n+\t// the beginning of the next one.\n+\tap = align(ap, s390x_arch_stack_slot_align)\n+\t// If offset is > 0, the data is right aligned on the stack slot.\n+\tap += offset\n+\n+\t// We have to copy the argument onto the heap in case the\n+\t// function hangs onto the reflect.Value we pass it.\n+\tp := unsafe_New(rt)\n+\tmemmove(p, unsafe.Pointer(ap), rt.size)\n+\n+\tv := Value{rt, p, flag(rt.Kind()<<flagKindShift) | flagIndir}\n+\tin = append(in, v)\n+\tap += rt.size\n+\tap = align(ap, s390x_arch_stack_slot_align)\n+\n+\treturn in, ap\n+}\n+\n+// The s390x_add_memarg function adds an argument passed in memory.\n+func s390x_add_memarg(in []Value, ap uintptr, rt *rtype) ([]Value, uintptr) {\n+\t// If we're not already at the beginning of a stack slot,\n+\t// round up to the beginning of the next one.\n+\tap = align(ap, s390x_arch_stack_slot_align)\n+\n+\t// We have to copy the argument onto the heap in case the\n+\t// function hangs onto the reflect.Value we pass it.\n+\tp := unsafe_New(rt)\n+\tmemmove(p, *(*unsafe.Pointer)(unsafe.Pointer(ap)), rt.size)\n+\n+\tv := Value{rt, p, flag(rt.Kind()<<flagKindShift) | flagIndir}\n+\tin = append(in, v)\n+\tap += s390x_arch_stack_slot_align\n+\n+\treturn in, ap\n+}\n+\n+// The s390x_general_reg_val function returns the value of integer register GR.\n+func s390x_general_reg_val(regs *s390x_regs, gr int) uintptr {\n+\tvar r s390x_arch_gr_t\n+\tswitch gr {\n+\tcase 0:\n+\t\tr = regs.r2\n+\tcase 1:\n+\t\tr = regs.r3\n+\tcase 2:\n+\t\tr = regs.r4\n+\tcase 3:\n+\t\tr = regs.r5\n+\tcase 4:\n+\t\tr = regs.r6\n+\tdefault:\n+\t\tpanic(\"s390x_general_reg_val: bad integer register\")\n+\t}\n+\treturn uintptr(r)\n+}\n+\n+// The s390x_float_reg_val function returns the value of float register FR.\n+func s390x_float_reg_val(regs *s390x_regs, fr int) uintptr {\n+\tvar r s390x_arch_fr_t\n+\tswitch fr {\n+\tcase 0:\n+\t\tr = regs.f0\n+\tcase 1:\n+\t\tr = regs.f2\n+\tcase 2:\n+\t\tr = regs.f4\n+\tcase 3:\n+\t\tr = regs.f6\n+\tdefault:\n+\t\tpanic(\"s390x_float_reg_val: bad floating point register\")\n+\t}\n+\treturn uintptr(r)\n+}"}, {"sha": "bd0b25f0da7dbc916751e4a0617719bbb43143ca", "filename": "libgo/go/runtime/pprof/pprof.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go?ref=1fec5f5274d7e232b75fc400321ed64be46766c3", "patch": "@@ -331,6 +331,11 @@ func printStackRecord(w io.Writer, stk []uintptr, allFrames bool) {\n \t\t\tif i > 0 && pc > f.Entry() && !wasPanic {\n \t\t\t\tif runtime.GOARCH == \"386\" || runtime.GOARCH == \"amd64\" {\n \t\t\t\t\ttracepc--\n+\t\t\t\t} else if runtime.GOARCH == \"s390\" || runtime.GOARCH == \"s390x\" {\n+\t\t\t\t\t// only works if function was called\n+\t\t\t\t\t// with the brasl instruction (or a\n+\t\t\t\t\t// different 6-byte instruction).\n+\t\t\t\t\ttracepc -= 6\n \t\t\t\t} else {\n \t\t\t\t\ttracepc -= 4 // arm, etc\n \t\t\t\t}"}, {"sha": "2371902cbaa030855b29f213884a5314002a39a8", "filename": "libgo/go/syscall/exec_linux.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Fsyscall%2Fexec_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Fsyscall%2Fexec_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_linux.go?ref=1fec5f5274d7e232b75fc400321ed64be46766c3", "patch": "@@ -7,6 +7,7 @@\n package syscall\n \n import (\n+\t\"runtime\"\n \t\"unsafe\"\n )\n \n@@ -65,7 +66,11 @@ func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr\n \t// About to call fork.\n \t// No more allocation or calls of non-assembly functions.\n \truntime_BeforeFork()\n-\tr1, _, err1 = RawSyscall6(SYS_CLONE, uintptr(SIGCHLD)|sys.Cloneflags, 0, 0, 0, 0, 0)\n+\tif runtime.GOARCH == \"s390x\" || runtime.GOARCH == \"s390\" {\n+\t\tr1, _, err1 = RawSyscall6(SYS_CLONE, 0, uintptr(SIGCHLD)|sys.Cloneflags, 0, 0, 0, 0)\n+\t} else {\n+\t\tr1, _, err1 = RawSyscall6(SYS_CLONE, uintptr(SIGCHLD)|sys.Cloneflags, 0, 0, 0, 0, 0)\n+\t}\n \tif err1 != 0 {\n \t\truntime_AfterFork()\n \t\treturn 0, err1"}, {"sha": "c5f3b30ffd37b2d3ec8ed10817aab8437d779d06", "filename": "libgo/go/syscall/libcall_linux_s390.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Fsyscall%2Flibcall_linux_s390.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Fsyscall%2Flibcall_linux_s390.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_linux_s390.go?ref=1fec5f5274d7e232b75fc400321ed64be46766c3", "patch": "@@ -0,0 +1,7 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// GNU/Linux library calls s390 specific.\n+\n+package syscall"}, {"sha": "c5f3b30ffd37b2d3ec8ed10817aab8437d779d06", "filename": "libgo/go/syscall/libcall_linux_s390x.go", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Fsyscall%2Flibcall_linux_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Fsyscall%2Flibcall_linux_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Flibcall_linux_s390x.go?ref=1fec5f5274d7e232b75fc400321ed64be46766c3", "patch": "@@ -0,0 +1,7 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// GNU/Linux library calls s390 specific.\n+\n+package syscall"}, {"sha": "a744f6b78419ab1c911b996d390a455c42670b2d", "filename": "libgo/go/syscall/syscall_linux_s390.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_s390.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_s390.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_s390.go?ref=1fec5f5274d7e232b75fc400321ed64be46766c3", "patch": "@@ -0,0 +1,21 @@\n+// syscall_linux_s390.go -- GNU/Linux s390 specific support\n+\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package syscall\n+\n+import \"unsafe\"\n+\n+func (r *PtraceRegs) PC() uint64 { return uint64(r.Psw.Addr) }\n+\n+func (r *PtraceRegs) SetPC(pc uint64) { r.Psw.Addr = uint32(pc) }\n+\n+func PtraceGetRegs(pid int, regsout *PtraceRegs) (err error) {\n+\treturn ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))\n+}\n+\n+func PtraceSetRegs(pid int, regs *PtraceRegs) (err error) {\n+\treturn ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))\n+}"}, {"sha": "44d567983c8db9802ec66fc342ed61543b2c06aa", "filename": "libgo/go/syscall/syscall_linux_s390x.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_s390x.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_s390x.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_linux_s390x.go?ref=1fec5f5274d7e232b75fc400321ed64be46766c3", "patch": "@@ -0,0 +1,21 @@\n+// syscall_linux_s390x.go -- GNU/Linux s390x specific support\n+\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package syscall\n+\n+import \"unsafe\"\n+\n+func (r *PtraceRegs) PC() uint64 { return r.Psw.Addr }\n+\n+func (r *PtraceRegs) SetPC(pc uint64) { r.Psw.Addr = pc }\n+\n+func PtraceGetRegs(pid int, regsout *PtraceRegs) (err error) {\n+\treturn ptrace(PTRACE_GETREGS, pid, 0, uintptr(unsafe.Pointer(regsout)))\n+}\n+\n+func PtraceSetRegs(pid int, regs *PtraceRegs) (err error) {\n+\treturn ptrace(PTRACE_SETREGS, pid, 0, uintptr(unsafe.Pointer(regs)))\n+}"}, {"sha": "a174e64213be66fa615961a77abe54b7c640950b", "filename": "libgo/mksysinfo.sh", "status": "modified", "additions": 45, "deletions": 8, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fmksysinfo.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fmksysinfo.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmksysinfo.sh?ref=1fec5f5274d7e232b75fc400321ed64be46766c3", "patch": "@@ -439,12 +439,50 @@ if ! grep '^const _PTRACE_TRACEME' ${OUT} > /dev/null 2>&1; then\n   echo \"const _PTRACE_TRACEME = 0\" >> ${OUT}\n fi\n \n+# A helper function that prints a structure from gen-sysinfo.go with the first\n+# letter of the field names in upper case.  $1 is the name of structure.  If $2\n+# is not empty, the structure or type is renamed to $2.\n+upcase_fields () {\n+  name=\"$1\"\n+  def=`grep \"^type $name\" gen-sysinfo.go`\n+  fields=`echo $def | sed -e 's/^[^{]*{\\(.*\\)}$/\\1/'`\n+  prefix=`echo $def | sed -e 's/{.*//'`\n+  if test \"$2\" != \"\"; then\n+    prefix=`echo $prefix | sed -e \"s/$1/$2/\"`\n+  fi\n+  if test \"$fields\" != \"\"; then\n+    nfields=\n+    while test -n \"$fields\"; do\n+      field=`echo $fields | sed -e 's/^\\([^;]*\\);.*$/\\1/'`\n+      fields=`echo $fields | sed -e 's/^[^;]*; *\\(.*\\)$/\\1/'`\n+      # capitalize the next character.\n+      f=`echo $field | sed -e 's/^\\(.\\).*$/\\1/'`\n+      r=`echo $field | sed -e 's/^.\\(.*\\)$/\\1/'`\n+      f=`echo $f | tr abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ`\n+      field=\"$f$r\"\n+      nfields=\"$nfields $field;\"\n+    done\n+    echo \"${prefix} {$nfields }\"\n+  fi\n+}\n+\n # The registers returned by PTRACE_GETREGS.  This is probably\n # GNU/Linux specific; it should do no harm if there is no\n # _user_regs_struct.\n regs=`grep '^type _user_regs_struct struct' gen-sysinfo.go || true`\n+if test \"$regs\" == \"\"; then\n+  # s390\n+  regs=`grep '^type __user_regs_struct struct' gen-sysinfo.go || true`\n+  if test \"$regs\" != \"\"; then\n+    # Substructures of __user_regs_struct on s390\n+    upcase_fields \"__user_psw_struct\" \"PtracePsw\" >> ${OUT}\n+    upcase_fields \"__user_fpregs_struct\" \"PtraceFpregs\" >> ${OUT}\n+    upcase_fields \"__user_per_struct\" \"PtracePer\" >> ${OUT}\n+  fi\n+fi\n if test \"$regs\" != \"\"; then\n-  regs=`echo $regs | sed -e 's/type _user_regs_struct struct //' -e 's/[{}]//g'`\n+  regs=`echo $regs |\n+    sed -e 's/type __*user_regs_struct struct //' -e 's/[{}]//g'`\n   regs=`echo $regs | sed -e s'/^ *//'`\n   nregs=\n   while test -n \"$regs\"; do\n@@ -455,6 +493,10 @@ if test \"$regs\" != \"\"; then\n     r=`echo $field | sed -e 's/^.\\(.*\\)$/\\1/'`\n     f=`echo $f | tr abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ`\n     field=\"$f$r\"\n+    field=`echo \"$field\" | sed \\\n+      -e 's/__user_psw_struct/PtracePsw/' \\\n+      -e 's/__user_fpregs_struct/PtraceFpregs/' \\\n+      -e 's/__user_per_struct/PtracePer/'`\n     nregs=\"$nregs $field;\"\n   done\n   echo \"type PtraceRegs struct {$nregs }\" >> ${OUT}\n@@ -616,7 +658,7 @@ grep '^const _DT_' gen-sysinfo.go |\n rusage=`grep '^type _rusage struct' gen-sysinfo.go`\n if test \"$rusage\" != \"\"; then\n   # Remove anonymous unions from GNU/Linux <bits/resource.h>.\n-  rusage=`echo $rusage | sed -e 's/Godump_[0-9]* struct {\\([^}]*\\)};/\\1/g'`\n+  rusage=`echo $rusage | sed -e 's/Godump_[0-9][0-9]* struct {\\([^}]*\\)};/\\1/g'`\n   rusage=`echo $rusage | sed -e 's/type _rusage struct //' -e 's/[{}]//g'`\n   rusage=`echo $rusage | sed -e 's/^ *//'`\n   nrusage=\n@@ -704,12 +746,7 @@ grep '^const _SCM_' gen-sysinfo.go | \\\n   sed -e 's/^\\(const \\)_\\(SCM_[^= ]*\\)\\(.*\\)$/\\1\\2 = _\\2/' >> ${OUT}\n \n # The ucred struct.\n-grep '^type _ucred ' gen-sysinfo.go | \\\n-    sed -e 's/_ucred/Ucred/' \\\n-      -e 's/pid/Pid/' \\\n-      -e 's/uid/Uid/' \\\n-      -e 's/gid/Gid/' \\\n-    >> ${OUT}\n+upcase_fields \"_ucred\" \"Ucred\" >> ${OUT}\n \n # The ip_mreq struct.\n grep '^type _ip_mreq ' gen-sysinfo.go | \\"}, {"sha": "abc1affcf7460493a56ef55bcf55b3b3bf75ad13", "filename": "libgo/runtime/runtime.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fruntime%2Fruntime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1fec5f5274d7e232b75fc400321ed64be46766c3/libgo%2Fruntime%2Fruntime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.c?ref=1fec5f5274d7e232b75fc400321ed64be46766c3", "patch": "@@ -194,6 +194,14 @@ runtime_cputicks(void)\n   uint32 low, high;\n   asm(\"rdtsc\" : \"=a\" (low), \"=d\" (high));\n   return (int64)(((uint64)high << 32) | (uint64)low);\n+#elif defined (__s390__) || defined (__s390x__)\n+  uint64 clock;\n+#ifdef S390_HAVE_STCKF\n+  asm(\"stckf\\t%0\" : \"=Q\" (clock) : : );\n+#else\n+  clock = 0;\n+#endif\n+  return (int64)clock;\n #else\n   // FIXME: implement for other processors.\n   return 0;"}]}