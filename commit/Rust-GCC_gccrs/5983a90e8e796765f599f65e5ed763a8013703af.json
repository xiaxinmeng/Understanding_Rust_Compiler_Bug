{"sha": "5983a90e8e796765f599f65e5ed763a8013703af", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk4M2E5MGU4ZTc5Njc2NWY1OTlmNjVlNWVkNzYzYTgwMTM3MDNhZg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-23T00:34:27Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-23T00:34:27Z"}, "message": "reload1.c (indirect_symref_ok, [...]): Make them static.\n\n\t* reload1.c (indirect_symref_ok, reload_obstack): Make them\n\tstatic.\n\t* reload.h: Remove the prototype for indirect_symref_ok.\n\nFrom-SVN: r96911", "tree": {"sha": "b95431c5722da5ecd2f7f61bc01f465d42dbec96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b95431c5722da5ecd2f7f61bc01f465d42dbec96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5983a90e8e796765f599f65e5ed763a8013703af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5983a90e8e796765f599f65e5ed763a8013703af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5983a90e8e796765f599f65e5ed763a8013703af", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5983a90e8e796765f599f65e5ed763a8013703af/comments", "author": null, "committer": null, "parents": [{"sha": "17b32de47d34ecbb0d042f08e6020be7aa8c1b73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17b32de47d34ecbb0d042f08e6020be7aa8c1b73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17b32de47d34ecbb0d042f08e6020be7aa8c1b73"}], "stats": {"total": 16, "additions": 8, "deletions": 8}, "files": [{"sha": "f1830ad3dd0c4a52e15d7497716731356699d909", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5983a90e8e796765f599f65e5ed763a8013703af/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5983a90e8e796765f599f65e5ed763a8013703af/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5983a90e8e796765f599f65e5ed763a8013703af", "patch": "@@ -1,3 +1,9 @@\n+2005-03-22  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* reload1.c (indirect_symref_ok, reload_obstack): Make them\n+\tstatic.\n+\t* reload.h: Remove the prototype for indirect_symref_ok.\n+\n 2005-03-22  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* config/sh/sh.md (ashlhi3): Rename to *ashlhi3_n and add a new"}, {"sha": "182a85721da0489b56b7fdc62bb3f346693b558f", "filename": "gcc/reload.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5983a90e8e796765f599f65e5ed763a8013703af/gcc%2Freload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5983a90e8e796765f599f65e5ed763a8013703af/gcc%2Freload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.h?ref=5983a90e8e796765f599f65e5ed763a8013703af", "patch": "@@ -182,12 +182,6 @@ extern int reload_n_operands;\n    Used in find_equiv_reg.  */\n extern int reload_first_uid;\n \n-/* Nonzero if indirect addressing is supported when the innermost MEM is\n-   of the form (MEM (SYMBOL_REF sym)).  It is assumed that the level to\n-   which these are valid is the same as spill_indirect_levels, above.  */\n-\n-extern char indirect_symref_ok;\n-\n /* Nonzero if an address (plus (reg frame_pointer) (reg ...)) is valid.  */\n extern char double_reg_address_ok;\n "}, {"sha": "5a044f6c8d2742deb1be20c5abfe8787dab65157", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5983a90e8e796765f599f65e5ed763a8013703af/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5983a90e8e796765f599f65e5ed763a8013703af/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=5983a90e8e796765f599f65e5ed763a8013703af", "patch": "@@ -229,7 +229,7 @@ static char spill_indirect_levels;\n /* Nonzero if indirect addressing is supported when the innermost MEM is\n    of the form (MEM (SYMBOL_REF sym)).  It is assumed that the level to\n    which these are valid is the same as spill_indirect_levels, above.  */\n-char indirect_symref_ok;\n+static char indirect_symref_ok;\n \n /* Nonzero if an address (plus (reg frame_pointer) (reg ...)) is valid.  */\n char double_reg_address_ok;\n@@ -268,7 +268,7 @@ enum insn_code reload_out_optab[NUM_MACHINE_MODES];\n /* This obstack is used for allocation of rtl during register elimination.\n    The allocated storage can be freed once find_reloads has processed the\n    insn.  */\n-struct obstack reload_obstack;\n+static struct obstack reload_obstack;\n \n /* Points to the beginning of the reload_obstack.  All insn_chain structures\n    are allocated first.  */"}]}