{"sha": "cb7effde6f36b43d50c8cd7f86eaa05937da7205", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2I3ZWZmZGU2ZjM2YjQzZDUwYzhjZDdmODZlYWEwNTkzN2RhNzIwNQ==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2020-06-30T09:15:56Z"}, "committer": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2020-07-10T15:07:12Z"}, "message": "openacc: Helper functions for enter/exit data using single mapping\n\nThis patch factors out the parts of goacc_enter_datum and\ngoacc_exit_datum that can be shared with goacc_enter_data_internal\nand goacc_exit_data_internal respectively (in the next patch),\nwithout overloading function return values or complicating code paths\nunnecessarily.\n\n2020-07-10  Julian Brown  <julian@codesourcery.com>\n\t    Thomas Schwinge  <thomas@codesourcery.com>\n\nlibgomp/\n\t* oacc-mem.c (goacc_map_var_existing): New function.\n\t(goacc_enter_datum): Use above function.\n\t(goacc_exit_datum_1): New function.\n\t(goacc_exit_datum): Use above function.\n\nCo-Authored-By: Thomas Schwinge <thomas@codesourcery.com>", "tree": {"sha": "f2ed5a025ab27c0fa55f5b2435b809f27392886e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2ed5a025ab27c0fa55f5b2435b809f27392886e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb7effde6f36b43d50c8cd7f86eaa05937da7205", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb7effde6f36b43d50c8cd7f86eaa05937da7205", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb7effde6f36b43d50c8cd7f86eaa05937da7205", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb7effde6f36b43d50c8cd7f86eaa05937da7205/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6b7ba5de624f2a17d799bac5ff017cd065ce035", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6b7ba5de624f2a17d799bac5ff017cd065ce035", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6b7ba5de624f2a17d799bac5ff017cd065ce035"}], "stats": {"total": 124, "additions": 73, "deletions": 51}, "files": [{"sha": "34f519a2045292736fca82a90e9368c84e453a85", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 73, "deletions": 51, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7effde6f36b43d50c8cd7f86eaa05937da7205/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7effde6f36b43d50c8cd7f86eaa05937da7205/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=cb7effde6f36b43d50c8cd7f86eaa05937da7205", "patch": "@@ -498,6 +498,36 @@ acc_unmap_data (void *h)\n }\n \n \n+/* Helper function to map a single dynamic data item, represented by a single\n+   mapping.  The acc_dev->lock should be held on entry, and remains locked on\n+   exit.  */\n+\n+static void *\n+goacc_map_var_existing (struct gomp_device_descr *acc_dev, void *hostaddr,\n+\t\t\tsize_t size, splay_tree_key n)\n+{\n+  assert (n);\n+\n+  /* Present. */\n+  void *d = (void *) (n->tgt->tgt_start + n->tgt_offset + hostaddr\n+\t    - n->host_start);\n+\n+  if (hostaddr + size > (void *) n->host_end)\n+    {\n+      gomp_mutex_unlock (&acc_dev->lock);\n+      gomp_fatal (\"[%p,+%d] not mapped\", hostaddr, (int) size);\n+    }\n+\n+  assert (n->refcount != REFCOUNT_LINK);\n+  if (n->refcount != REFCOUNT_INFINITY)\n+    {\n+      n->refcount++;\n+      n->virtual_refcount++;\n+    }\n+\n+  return d;\n+}\n+\n /* Enter dynamic mapping for a single datum.  Return the device pointer.  */\n \n static void *\n@@ -531,25 +561,7 @@ goacc_enter_datum (void **hostaddrs, size_t *sizes, void *kinds, int async)\n   n = lookup_host (acc_dev, hostaddrs[0], sizes[0]);\n   if (n)\n     {\n-      void *h = hostaddrs[0];\n-      size_t s = sizes[0];\n-\n-      /* Present. */\n-      d = (void *) (n->tgt->tgt_start + n->tgt_offset + h - n->host_start);\n-\n-      if ((h + s) > (void *)n->host_end)\n-\t{\n-\t  gomp_mutex_unlock (&acc_dev->lock);\n-\t  gomp_fatal (\"[%p,+%d] not mapped\", (void *)h, (int)s);\n-\t}\n-\n-      assert (n->refcount != REFCOUNT_LINK);\n-      if (n->refcount != REFCOUNT_INFINITY)\n-\t{\n-\t  n->refcount++;\n-\t  n->virtual_refcount++;\n-\t}\n-\n+      d = goacc_map_var_existing (acc_dev, hostaddrs[0], sizes[0], n);\n       gomp_mutex_unlock (&acc_dev->lock);\n     }\n   else\n@@ -649,38 +661,13 @@ acc_pcopyin (void *h, size_t s)\n #endif\n \n \n-/* Exit a dynamic mapping for a single variable.  */\n+/* Helper function to unmap a single data item.  Device lock should be held on\n+   entry, and remains locked on exit.  */\n \n static void\n-goacc_exit_datum (void *h, size_t s, unsigned short kind, int async)\n+goacc_exit_datum_1 (struct gomp_device_descr *acc_dev, void *h, size_t s,\n+\t\t    unsigned short kind, splay_tree_key n, goacc_aq aq)\n {\n-  /* No need to call lazy open, as the data must already have been\n-     mapped.  */\n-\n-  kind &= 0xff;\n-\n-  struct goacc_thread *thr = goacc_thread ();\n-  struct gomp_device_descr *acc_dev = thr->dev;\n-\n-  if (acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n-    return;\n-\n-  acc_prof_info prof_info;\n-  acc_api_info api_info;\n-  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n-  if (profiling_p)\n-    {\n-      prof_info.async = async;\n-      prof_info.async_queue = prof_info.async;\n-    }\n-\n-  gomp_mutex_lock (&acc_dev->lock);\n-\n-  splay_tree_key n = lookup_host (acc_dev, h, s);\n-  if (!n)\n-    /* PR92726, RP92970, PR92984: no-op.  */\n-    goto out;\n-\n   if ((uintptr_t) h < n->host_start || (uintptr_t) h + s > n->host_end)\n     {\n       size_t host_size = n->host_end - n->host_start;\n@@ -691,6 +678,7 @@ goacc_exit_datum (void *h, size_t s, unsigned short kind, int async)\n \n   bool finalize = (kind == GOMP_MAP_DELETE\n \t\t   || kind == GOMP_MAP_FORCE_FROM);\n+\n   if (finalize)\n     {\n       if (n->refcount != REFCOUNT_INFINITY)\n@@ -709,8 +697,6 @@ goacc_exit_datum (void *h, size_t s, unsigned short kind, int async)\n \n   if (n->refcount == 0)\n     {\n-      goacc_aq aq = get_goacc_asyncqueue (async);\n-\n       bool copyout = (kind == GOMP_MAP_FROM\n \t\t      || kind == GOMP_MAP_FORCE_FROM);\n       if (copyout)\n@@ -740,8 +726,44 @@ goacc_exit_datum (void *h, size_t s, unsigned short kind, int async)\n \t  assert (is_tgt_unmapped || num_mappings > 1);\n \t}\n     }\n+}\n+\n+\n+/* Exit a dynamic mapping for a single variable.  */\n+\n+static void\n+goacc_exit_datum (void *h, size_t s, unsigned short kind, int async)\n+{\n+  /* No need to call lazy open, as the data must already have been\n+     mapped.  */\n+\n+  kind &= 0xff;\n+\n+  struct goacc_thread *thr = goacc_thread ();\n+  struct gomp_device_descr *acc_dev = thr->dev;\n+\n+  if (acc_dev->capabilities & GOMP_OFFLOAD_CAP_SHARED_MEM)\n+    return;\n+\n+  acc_prof_info prof_info;\n+  acc_api_info api_info;\n+  bool profiling_p = GOACC_PROFILING_SETUP_P (thr, &prof_info, &api_info);\n+  if (profiling_p)\n+    {\n+      prof_info.async = async;\n+      prof_info.async_queue = prof_info.async;\n+    }\n+\n+  gomp_mutex_lock (&acc_dev->lock);\n+\n+  splay_tree_key n = lookup_host (acc_dev, h, s);\n+  /* Non-present data is a no-op: PR92726, RP92970, PR92984.  */\n+  if (n)\n+    {\n+      goacc_aq aq = get_goacc_asyncqueue (async);\n+      goacc_exit_datum_1 (acc_dev, h, s, kind, n, aq);\n+    }\n \n- out:\n   gomp_mutex_unlock (&acc_dev->lock);\n \n   if (profiling_p)"}]}