{"sha": "a9c3f03ac114279cf8d080e7f0b1ec5d262b4646", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTljM2YwM2FjMTE0Mjc5Y2Y4ZDA4MGU3ZjBiMWVjNWQyNjJiNDY0Ng==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-04-07T23:00:45Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-04-07T23:00:45Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r700", "tree": {"sha": "86c88c7885c5a07d5d6f023ef5c952add4a074d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86c88c7885c5a07d5d6f023ef5c952add4a074d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a9c3f03ac114279cf8d080e7f0b1ec5d262b4646", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9c3f03ac114279cf8d080e7f0b1ec5d262b4646", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a9c3f03ac114279cf8d080e7f0b1ec5d262b4646", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a9c3f03ac114279cf8d080e7f0b1ec5d262b4646/comments", "author": null, "committer": null, "parents": [{"sha": "27fcd6657e5497a5f8442fea29efbd1448c06afe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27fcd6657e5497a5f8442fea29efbd1448c06afe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27fcd6657e5497a5f8442fea29efbd1448c06afe"}], "stats": {"total": 852, "additions": 587, "deletions": 265}, "files": [{"sha": "ccab1a6b0dd7caa54ea293e7a3342464b3792d3c", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 90, "deletions": 32, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9c3f03ac114279cf8d080e7f0b1ec5d262b4646/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9c3f03ac114279cf8d080e7f0b1ec5d262b4646/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=a9c3f03ac114279cf8d080e7f0b1ec5d262b4646", "patch": "@@ -38,7 +38,6 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"tree.h\"\n #include \"c-tree.h\"\n #include \"expr.h\"\n-#include \"hard-reg-set.h\"\n #include \"flags.h\"\n \n extern char *version_string;\n@@ -47,7 +46,7 @@ extern char *ctime ();\n extern int flag_traditional;\n extern FILE *asm_out_file;\n \n-static char out_sccs_id[] = \"@(#)m88k.c\t2.1.2.2 27 Mar 1992 08:37:28\";\n+static char out_sccs_id[] = \"@(#)m88k.c\t2.1.3.1 07 Apr 1992 17:23:59\";\n static char tm_sccs_id [] = TM_SCCS_ID;\n \n char *m88k_pound_sign = \"\";\t/* Either # for SVR4 or empty for SVR3 */\n@@ -1323,23 +1322,25 @@ output_file_start (file, f_options, f_len, W_options, W_len)\n /* Output an ascii string.  */\n \n void\n-output_ascii (file, p, size)\n+output_ascii (file, opcode, max, p, size)\n      FILE *file;\n+     char *opcode;\n+     int max;\n      unsigned char *p;\n      int size;\n {\n   int i;\n \n   register int num = 0;\n \n-  fprintf (file, \"\\t%s\\t \\\"\", ASCII_DATA_ASM_OP);\n+  fprintf (file, \"\\t%s\\t \\\"\", opcode);\n   for (i = 0; i < size; i++)\n     {\n       register int c = p[i];\n \n-      if (num > 48)\n+      if (num > max)\n \t{\n-\t  fprintf (file, \"\\\"\\n\\t%s\\t \\\"\", ASCII_DATA_ASM_OP);\n+\t  fprintf (file, \"\\\"\\n\\t%s\\t \\\"\", opcode);\n \t  num = 0;\n \t}\n \n@@ -1364,7 +1365,7 @@ output_ascii (file, p, size)\n \t     after three digits, so this is the only way we\n \t     can get it to parse the data properly.  */\n \t  if (i < size - 1 && p[i + 1] >= '0' && p[i + 1] <= '9')\n-\t    num = 32767;\t/* next pass will start a new string */\n+\t    num = max + 1;\t/* next pass will start a new string */\n \t}\n     }\n   fprintf (file, \"\\\"\\n\");\n@@ -1528,6 +1529,8 @@ m88k_handle_pragma_token (string, token)\n         |        [previous frame pointer (r30)]        |\n         |==============================================| <- fp\n         |       [preserved registers (r25..r14)]       |\n+        |----------------------------------------------|\n+        |       [preserved registers (x29..x22)]       |\n         |==============================================|\n         |    [dynamically allocated space (alloca)]    |\n         |==============================================|\n@@ -1549,6 +1552,7 @@ static void preserve_registers ();\n static void output_tdesc ();\n \n static int  nregs;\n+static int  nxregs;\n static char save_regs[FIRST_PSEUDO_REGISTER];\n static int  frame_laid_out;\n static int  frame_size;\n@@ -1562,6 +1566,9 @@ extern int  frame_pointer_needed;\n #define FIRST_OCS_PRESERVE_REGISTER\t14\n #define LAST_OCS_PRESERVE_REGISTER\t30\n \n+#define FIRST_OCS_EXTENDED_PRESERVE_REGISTER\t(32 + 22)\n+#define LAST_OCS_EXTENDED_PRESERVE_REGISTER\t(32 + 31)\n+\n #define STACK_UNIT_BOUNDARY (STACK_BOUNDARY / BITS_PER_UNIT)\n #define ROUND_CALL_BLOCK_SIZE(BYTES) \\\n   (((BYTES) + (STACK_UNIT_BOUNDARY - 1)) & ~(STACK_UNIT_BOUNDARY - 1))\n@@ -1577,7 +1584,7 @@ m88k_layout_frame ()\n   frame_laid_out++;\n \n   bzero ((char *) &save_regs[0], sizeof (save_regs));\n-  sp_size = nregs = 0;\n+  sp_size = nregs = nxregs = 0;\n   frame_size = get_frame_size ();\n \n   /* Since profiling requires a call, make sure r1 is saved.  */\n@@ -1614,6 +1621,15 @@ m88k_layout_frame ()\n   if (frame_pointer_needed)\n     save_regs[FRAME_POINTER_REGNUM] = save_regs[1] = 1;\n \n+  /* Figure out which extended register(s) needs to be saved.  */\n+  for (regno = FIRST_EXTENDED_REGISTER + 1; regno < FIRST_PSEUDO_REGISTER;\n+       regno++)\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\n+      {\n+\tsave_regs[regno] = 1;\n+\tnxregs++;\n+      }\n+\n   /* Figure out which normal register(s) needs to be saved.  */\n   for (regno = 2; regno < FRAME_POINTER_REGNUM; regno++)\n     if (regs_ever_live[regno] && ! call_used_regs[regno])\n@@ -1628,7 +1644,11 @@ m88k_layout_frame ()\n     sp_size += 4;\n \n   nregs += save_regs[1] + save_regs[FRAME_POINTER_REGNUM];\n+  /* if we need to align extended registers, add a word */\n+  if (nxregs > 0 && (nregs & 1) != 0)\n+    sp_size +=4;\n   sp_size += 4 * nregs;\n+  sp_size += 8 * nxregs;\n   sp_size += current_function_outgoing_args_size;\n \n   /* The first two saved registers are placed above the new frame pointer\n@@ -1675,6 +1695,7 @@ null_epilogue ()\n     m88k_layout_frame ();\n   return (! frame_pointer_needed\n \t  && nregs == 0\n+\t  && nxregs == 0\n \t  && m88k_stack_size == 0);\n }\n \n@@ -1835,7 +1856,7 @@ m88k_output_prologue (stream, size)\n   if (m88k_stack_size)\n     output_reg_adjust (stream, 31, 31, -m88k_stack_size, 0);\n \n-  if (nregs)\n+  if (nregs || nxregs)\n     preserve_registers (stream, m88k_fp_offset + 4, 1);\n \n   if (frame_pointer_needed)\n@@ -1909,7 +1930,7 @@ m88k_output_epilogue (stream, size)\n       if (frame_pointer_needed)\n \toutput_reg_adjust (stream, 31, 30, -m88k_fp_offset, 0);\n \n-      if (nregs)\n+      if (nregs || nxregs)\n \tpreserve_registers (stream, m88k_fp_offset + 4, 0);\n \n       output_reg_adjust (stream, 31, 31, m88k_stack_size, 1);\n@@ -2048,6 +2069,21 @@ preserve_registers (stream, base, store_p)\n \t    offset -= 2*4;\n \t  }\n       }\n+\n+  /* Walk the extended registers to record all memory operations.  */\n+  /*  Be sure the offset is double word aligned.  */\n+  offset = (offset - 1) & ~7;\n+  for (regno = FIRST_PSEUDO_REGISTER - 1; regno > FIRST_EXTENDED_REGISTER;\n+       regno--)\n+    if (save_regs[regno])\n+      {\n+\tmo_ptr->nregs = 2;\n+\tmo_ptr->regno = regno;\n+\tmo_ptr->offset = offset;\n+\tmo_ptr++;\n+\toffset -= 2*4;\n+      }\n+\n   mo_ptr->regno = 0;\n \n   /* Output the delay insns interleaved with the memory operations.  */\n@@ -2070,10 +2106,12 @@ preserve_registers (stream, base, store_p)\n \t    {\n \t      if (mo_ptr->nregs)\n \t\t{\n+\t\t  int nregs = (mo_ptr->regno < FIRST_EXTENDED_REGISTER\n+\t\t\t       ? mo_ptr->nregs : 1);\n \t\t  rtx ok_insns = delay_insns;\n \t\t  int i;\n \n-\t\t  for (i = 0; i < mo_ptr->nregs; i++)\n+\t\t  for (i = 0; i < nregs; i++)\n \t\t    epilogue_dead_regs[mo_ptr->regno + i] = 1;\n \n \t\t  while (ok_insns)\n@@ -2083,7 +2121,7 @@ preserve_registers (stream, base, store_p)\n \n \t\t      if (! ok_for_epilogue_p (PATTERN (insn)))\n \t\t\t{\n-\t\t\t  for (i = 0; i < mo_ptr->nregs; i++)\n+\t\t\t  for (i = 0; i < nregs; i++)\n \t\t\t    epilogue_dead_regs[mo_ptr->regno + i] = 0;\n \t\t\t  insn = 0;\n \t\t\t  break; /* foreach delay insn */\n@@ -2147,27 +2185,30 @@ m88k_debugger_offset (reg, offset)\n /* Output the 88open OCS proscribed text description information.\n    The information is:\n         0  8: zero\n-\t0 22: info-byte-length (16 bytes)\n+\t0 22: info-byte-length (16 or 20 bytes)\n \t0  2: info-alignment (word 2)\n-\t1 32: info-protocol (version 1)\n+\t1 32: info-protocol (version 1 or 2(pic))\n \t2 32: starting-address (inclusive, not counting prologue)\n \t3 32: ending-address (exclusive, not counting epilog)\n-\t4  8: info-variant (version 1)\n+\t4  8: info-variant (version 1 or 3(extended registers))\n \t4 17: register-save-mask (from register 14 to 30)\n \t4  1: zero\n \t4  1: return-address-info-discriminant\n \t4  5: frame-address-register\n \t5 32: frame-address-offset\n \t6 32: return-address-info\n-\t7 32: register-save-offset */\n+\t7 32: register-save-offset\n+\t8 16: extended-register-save-mask (x16 - x31)\n+\t8 16: extended-register-save-offset (WORDS from register-save-offset)  */\n \n static void\n output_tdesc (file, offset)\n      FILE *file;\n      int offset;\n {\n-  int regno, i;\n+  int regno, i, j;\n   long mask, return_address_info, register_save_offset;\n+  long xmask, xregister_save_offset;\n   char buf[256];\n \n   for (mask = 0, i = 0, regno = FIRST_OCS_PRESERVE_REGISTER;\n@@ -2182,9 +2223,21 @@ output_tdesc (file, offset)\n \t}\n     }\n \n+  for (xmask = 0, j = 0, regno = FIRST_OCS_EXTENDED_PRESERVE_REGISTER;\n+       regno <= LAST_OCS_EXTENDED_PRESERVE_REGISTER;\n+       regno++)\n+    {\n+      xmask <<= 1;\n+      if (save_regs[regno])\n+\t{\n+\t  xmask |= 1;\n+\t  j++;\n+\t}\n+    }\n+\n   if (save_regs[1])\n     {\n-      if (nregs > 2 && !save_regs[FRAME_POINTER_REGNUM])\n+      if ((nxregs > 0 || nregs > 2) && !save_regs[FRAME_POINTER_REGNUM])\n \toffset -= 4;\n       return_address_info = - m88k_stack_size + offset;\n       register_save_offset = return_address_info - i*4;\n@@ -2195,28 +2248,33 @@ output_tdesc (file, offset)\n       register_save_offset = - m88k_stack_size + offset + 4 - i*4;\n     }\n \n+  xregister_save_offset = - (j * 2 + ((register_save_offset >> 2) & 1));\n+\n   tdesc_section ();\n \n-  fprintf (file, \"\\t%s\\t %d\", INT_ASM_OP, (16 << 2) | 2 /* 8:0,22:16,2:2 */);\n-  fprintf (file, \",%d\", flag_pic ? 2 : 1);\n+  fprintf (file, \"\\t%s\\t %d,%d\", INT_ASM_OP, /* 8:0,22:(20 or 16),2:2 */\n+\t   (((xmask != 0) ? 20 : 16) << 2) | 2,\n+\t   flag_pic ? 2 : 1);\n \n   ASM_GENERATE_INTERNAL_LABEL (buf, OCS_START_PREFIX, m88k_function_number);\n   fprintf (file, \",%s%s\", buf+1, flag_pic ? \"#rel\" : \"\");\n   ASM_GENERATE_INTERNAL_LABEL (buf, OCS_END_PREFIX, m88k_function_number);\n   fprintf (file, \",%s%s\", buf+1, flag_pic ? \"#rel\" : \"\");\n \n-  fprintf (file, \",0x%x\", /* 8:1,17:0x%.3x,1:0,1:%d,5:%d */\n-\t   (1 << (17+1+1+5)) |\n-\t   (mask << (1+1+5)) |\n-\t   ((!!save_regs[1]) << 5) |\n-\t   ((frame_pointer_needed\n-\t      ? FRAME_POINTER_REGNUM\n-\t      : STACK_POINTER_REGNUM)));\n-\n-  fprintf (file, \",0x%x\", (m88k_stack_size\n-\t\t\t   - (frame_pointer_needed ? m88k_fp_offset : 0)));\n-  fprintf (file, \",0x%x\", return_address_info);\n-  fprintf (file, \",0x%x\\n\", register_save_offset);\n+  fprintf (file, \",0x%x,0x%x,0x%x,0x%x\",\n+\t   /* 8:1,17:0x%.3x,1:0,1:%d,5:%d */\n+\t   (((xmask ? 3 : 1) << (17+1+1+5))\n+\t    | (mask << (1+1+5))\n+\t    | ((!!save_regs[1]) << 5)\n+\t    | (frame_pointer_needed\n+\t       ? FRAME_POINTER_REGNUM\n+\t       : STACK_POINTER_REGNUM)),\n+\t   (m88k_stack_size - (frame_pointer_needed ? m88k_fp_offset : 0)),\n+\t   return_address_info,\n+\t   register_save_offset);\n+  if (xmask)\n+    fprintf (file, \",0x%x%04x\", xmask, (0xffff & xregister_save_offset));\n+  fputc ('\\n', file);\n \n   text_section ();\n }"}, {"sha": "850a46647d34f895aec54b8b9a8d89372a25ce30", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 209, "deletions": 60, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9c3f03ac114279cf8d080e7f0b1ec5d262b4646/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9c3f03ac114279cf8d080e7f0b1ec5d262b4646/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=a9c3f03ac114279cf8d080e7f0b1ec5d262b4646", "patch": "@@ -204,9 +204,9 @@ extern char * reg_names[];\n /* Print subsidiary information on the compiler version in use.\n    Redefined in m88kv4.h, and m88kluna.h.  */\n #define VERSION_INFO1\t\"88open OCS/BCS, \"\n-#define VERSION_INFO2\t\"01 Apr 1992\"\n+#define VERSION_INFO2\t\"07 Apr 1992\"\n #define VERSION_STRING\tversion_string\n-#define\tTM_SCCS_ID\t\"@(#)m88k.h\t2.1.2.2 01 Apr 1992 06:40:42\"\n+#define\tTM_SCCS_ID\t\"@(#)m88k.h\t2.1.3.1 07 Apr 1992 17:24:45\"\n \n /* Run-time compilation parameters selecting different hardware subsets.  */\n \n@@ -441,21 +441,107 @@ extern char * reg_names[];\n    All registers that the compiler knows about must be given numbers,\n    even those that are not normally considered general registers.\n \n-   The m88100 has 32 fullword registers.\n-\n-   The pseudo argument pointer is said to be register 0.  This prohibits\n-   the use of r0 as a general register and causes no trouble.\n-   Using register 0 is useful, in that it keeps the number of\n-   registers down to 32, and GNU can use a long as a bitmask\n-   for the registers.  */\n-#define FIRST_PSEUDO_REGISTER 32\n-\n-/* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator.\n-   Registers 14-25 are expected to be preserved across\n-   function calls.\n-\n-   On the 88000, these are:\n+   The m88100 has a General Register File (GRF) of 32 32-bit registers.\n+   The m88110 adds an Extended Register File (XRF) of 32 80-bit registers.  */\n+#define FIRST_PSEUDO_REGISTER 64\n+#define FIRST_EXTENDED_REGISTER 32\n+\n+/*  General notes on extended registers, their use and misuse.\n+\n+    Possible good uses:\n+\n+    spill area instead of memory.\n+      -waste if only used once\n+\n+    floating point caluclations\n+      -probably a waste unless we have run out of general purpose registers\n+\n+    freeing up general purpose registers\n+      -e.g. may be able to have more loop invariants if floating\n+       point is moved into extended registers.\n+\n+\n+    I've noticed wasteful moves into and out of extended registers; e.g. a load\n+    into x21, then inside a loop a move into r24, then r24 used as input to\n+    an fadd.  Why not just load into r24 to begin with?  Maybe the new cse.c\n+    will address this.  This wastes a move, but the load,store and move could\n+    have been saved had extended registers been used throughout.\n+    E.g. in the code following code, if z and xz are placed in extended\n+    registers, there is no need to save preserve registers.\n+\n+\tlong c=1,d=1,e=1,f=1,g=1,h=1,i=1,j=1,k;\n+\n+\tdouble z=0,xz=4.5;\n+\n+\tfoo(a,b)\n+\tlong a,b;\n+\t{\n+\t  while (a < b)\n+\t    {\n+\t      k = b + c + d + e + f + g + h + a + i + j++;\n+\t      z += xz;\n+\t      a++;\n+\t    }\n+\t  printf(\"k= %d; z=%f;\\n\", k, z);\n+\t}\n+\n+    I've found that it is possible to change the constraints (putting * before\n+    the 'r' constraints int the fadd.ddd instruction) and get the entire\n+    addition and store to go into extended registers.  However, this also\n+    forces simple addition and return of floating point arguments to a\n+    function into extended registers.  Not the correct solution.\n+\n+    Found the following note in local-alloc.c which may explain why I can't\n+    get both registers to be in extended registers since two are allocated in\n+    local-alloc and one in global-alloc.  Doesn't explain (I don't believe)\n+    why an extended register is used instead of just using the preserve\n+    register.\n+\n+\tfrom local-alloc.c:\n+\tWe have provision to exempt registers, even when they are contained\n+\twithin the block, that can be tied to others that are not contained in it.\n+\tThis is so that global_alloc could process them both and tie them then.\n+\tBut this is currently disabled since tying in global_alloc is not\n+\tyet implemented.\n+\n+    The explaination of why the preserved register is not used is as follows,\n+    I believe.  The registers are being allocated in order.  Tieing is not\n+    done so efficiently, so when it comes time to do the first allocation,\n+    there are no registers left to use without spilling except extended\n+    registers.  Then when the next pseudo register needs a hard reg, there\n+    are still no registers to be had for free, but this one must be a GRF\n+    reg instead of an extended reg, so a preserve register is spilled.  Thus\n+    the move from extended to GRF is necessitated.  I do not believe this can\n+    be 'fixed' through the config/*m88k* files.\n+\n+    gcc seems to sometimes make worse use of register allocation -- not counting\n+    moves -- whenever extended registers are present.  For example in the\n+    whetstone, the simple for loop (slightly modified)\n+      for(i = 1; i <= n1; i++)\n+\t{\n+\t  x1 = (x1 + x2 + x3 - x4) * t;\n+\t  x2 = (x1 + x2 - x3 + x4) * t;\n+\t  x3 = (x1 - x2 + x3 + x4) * t;\n+\t  x4 = (x1 + x2 + x3 + x4) * t;\n+\t}\n+    in general loads the high bits of the addresses of x2-x4 and i into registers\n+    outside the loop.  Whenever extended registers are used, it loads all of\n+    these inside the loop. My conjecture is that since the 88110 has so many\n+    registers, and gcc makes no distinction at this point -- just that they are\n+    not fixed, that in loop.c it believes it can expect a number of registers\n+    to be available.  Then it allocates 'too many' in local-alloc which causes\n+    problems later.  'Too many' are allocated because a large portion of the\n+    registers are extended registers and cannot be used for certain purposes\n+    ( e.g. hold the address of a variable).  When this loop is compiled on its\n+    own, the problem does not occur.  I don't know the solution yet, though it\n+    is probably in the base sources.  Possibly a different way to calculate\n+    \"threshold\".  */\n+\n+/* 1 for registers that have pervasive standard uses and are not available\n+   for the register allocator.  Registers r14-r25 and x22-x29 are expected\n+   to be preserved across function calls.\n+\n+   On the 88000, the standard uses of the General Register File (GRF) are:\n    Reg 0\t= Pseudo argument pointer (hardware fixed to 0).\n    Reg 1\t= Subroutine return pointer (hardware).\n    Reg 2-9\t= Parameter registers (OCS).\n@@ -466,11 +552,29 @@ extern char * reg_names[];\n    Reg 14-25\t= Preserved register set.\n    Reg 26-29\t= Reserved by OCS and ABI.\n    Reg 30\t= Frame pointer (Common use).\n-   Reg 31\t= Stack pointer.  */\n+   Reg 31\t= Stack pointer.\n+\n+   The following follows the current 88open UCS specification for the\n+   Extended Register File (XRF):\n+   Reg 32       = x0\t\tAlways equal to zero\n+   Reg 33-53\t= x1-x21\tTempory registers (Caller Save)\n+   Reg 54-61\t= x22-x29\tPreserver registers (Callee Save)\n+   Reg 62-63\t= x30-x31\tReserved for future ABI use.\n+\n+   Note:  The current 88110 extended register mapping is subject to change.\n+\t  The bias towards caller-save registers is based on the\n+\t  presumption that memory traffic can potentially be reduced by\n+\t  allowing the \"caller\" to save only that part of the register\n+\t  which is actually being used.  (i.e. don't do a st.x if a st.d\n+\t  is sufficient).  Also, in scientific code (a.k.a. Fortran), the\n+\t  large number of variables defined in common blocks may require\n+\t  that almost all registers be saved across calls anyway.  */\n \n #define FIXED_REGISTERS \\\n  {1, 1, 0, 0,  0, 0, 0, 0,   0, 0, 0, 0,  0, 0, 0, 0, \\\n-  0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 1, 1,  1, 1, 1, 1}\n+  0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 1, 1,  1, 1, 1, 1, \\\n+  1, 0, 0, 0,  0, 0, 0, 0,   0, 0, 0, 0,  0, 0, 0, 0, \\\n+  0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 0, 0,  0, 0, 1, 1}\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -481,13 +585,29 @@ extern char * reg_names[];\n \n #define CALL_USED_REGISTERS \\\n  {1, 1, 1, 1,  1, 1, 1, 1,   1, 1, 1, 1,  1, 1, 0, 0, \\\n-  0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 1, 1,  1, 1, 1, 1}\n+  0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 1, 1,  1, 1, 1, 1, \\\n+  1, 1, 1, 1,  1, 1, 1, 1,   1, 1, 1, 1,  1, 1, 1, 1, \\\n+  1, 1, 1, 1,  1, 1, 0, 0,   0, 0, 0, 0,  0, 0, 1, 1}\n \n /* Macro to conditionally modify fixed_regs/call_used_regs.  */\n #define CONDITIONAL_REGISTER_USAGE\t\t\t\\\n   {\t\t\t\t\t\t\t\\\n+    if (! TARGET_88110)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tregister int i;\t\t\t\t\t\\\n+\t  for (i = FIRST_EXTENDED_REGISTER; i < FIRST_PSEUDO_REGISTER; i++) \\\n+\t    {\t\t\t\t\t\t\\\n+\t      fixed_regs[i] = 1;\t\t\t\\\n+\t      call_used_regs[i] = 1;\t\t\t\\\n+\t    }\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n     if (flag_pic)\t\t\t\t\t\\\n-      fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\t/* Current hack to deal with -fpic -O2 problems.  */ \\\n+\tfixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n+\tcall_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n+\tglobal_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\\\n+      }\t\t\t\t\t\t\t\\\n   }\n \n /* These interfaces that don't apply to the m88000.  */\n@@ -500,21 +620,27 @@ extern char * reg_names[];\n    This is ordinarily the length in words of a value of mode MODE\n    but can be less for certain modes in special long registers.\n \n-   On the m88000, ordinary registers hold 32 bits worth;\n-   a single floating point register is always enough for\n-   anything that can be stored in them at all.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+   On the m88000, GRF registers hold 32-bits and XRF registers hold 80-bits.\n+   An XRF register can hold any mode, but two GRF registers are required\n+   for larger modes.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n+  ((REGNO < FIRST_PSEUDO_REGISTER && REGNO >= FIRST_EXTENDED_REGISTER)\t\\\n+   ? 1 : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n \n    For double integers, we never put the value into an odd register so that\n    the operators don't run into the situation where the high part of one of\n-   the inputs is the low part of the result register (it's ok if the output\n-   registers are the same as the input registers.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\\\n-  (((MODE) != DImode && (MODE) != DFmode && (MODE) != DCmode) ||\t\\\n-   ((REGNO) & 1) == 0)\n+   the inputs is the low part of the result register.  (It's ok if the output\n+   registers are the same as the input registers.)  The XRF registers can\n+   hold all modes, but only DF and SF modes can be manipulated in these\n+   registers.  The compiler should be allowed to use these as a fast spill\n+   area.  */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n+  ((REGNO < FIRST_PSEUDO_REGISTER && REGNO >= FIRST_EXTENDED_REGISTER)\t\\\n+    ? TARGET_88110\t\t\t\t\t\t\t\\\n+    : (((MODE) != DImode && (MODE) != DFmode && (MODE) != DCmode)\t\\\n+       || ((REGNO) & 1) == 0))\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2.\n@@ -556,13 +682,18 @@ extern char * reg_names[];\n /* Order in which registers are preferred (most to least).  Use temp\n    registers, then param registers top down.  Preserve registers are\n    top down to maximize use of double memory ops for register save.\n-   The 88open reserved registers (26-29) may commonly be used in most\n-   environments with the -fcall-used- or -fcall-saved- options.  */\n-#define REG_ALLOC_ORDER \\\n- {13, 12, 11, 10, 29, 28, 27, 26, \\\n-   1,  9,  8,  7,  6,  5,  4,  3, \\\n-   2, 25, 24, 23, 22, 21, 20, 19, \\\n-  18, 17, 16, 15, 14, 30, 31, 0}\n+   The 88open reserved registers (r26-r29 and x30-x31) may commonly be used\n+   in most environments with the -fcall-used- or -fcall-saved- options.  */\n+#define REG_ALLOC_ORDER\t\t  \\\n+ {\t\t\t\t  \\\n+  13, 12, 11, 10, 29, 28, 27, 26, \\\n+   1, 62, 63,  9,  8,  7,  6,  5, \\\n+   4,  3,  2, 53, 52, 51, 50, 49, \\\n+  48, 47, 46, 45, 44, 43, 42, 41, \\\n+  40, 39, 38, 37, 36, 35, 34, 33, \\\n+  25, 24, 23, 22, 21, 20, 19, 18, \\\n+  17, 16, 15, 14, 61, 60, 59, 58, \\\n+  57, 56, 55, 54, 30, 31,  0, 32}\n \f\n /*** Register Classes ***/\n \n@@ -586,59 +717,72 @@ extern char * reg_names[];\n    For any two classes, it is very desirable that there be another\n    class that represents their union.  */\n \n-/* The m88100 hardware has one kind of register.  However, we denote\n+/* The m88000 hardware has two kinds of registers.  In addition, we denote\n    the arg pointer as a separate class.  */\n \n-enum reg_class { NO_REGS, AP_REG, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n+enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n+\t\t XGRF_REGS, ALL_REGS, LIM_REG_CLASSES };\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n /* Give names of register classes as strings for dump file.   */\n-#define REG_CLASS_NAMES {\"NO_REGS\", \"AP_REG\", \"GENERAL_REGS\", \"ALL_REGS\" }\n+#define REG_CLASS_NAMES {\"NO_REGS\", \"AP_REG\", \"XRF_REGS\", \"GENERAL_REGS\", \\\n+\t\t\t \"AGRF_REGS\", \"XGRF_REGS\", \"ALL_REGS\" }\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n    of length N_REG_CLASSES.  */\n-#define REG_CLASS_CONTENTS {0, 1, -2, -1}\n+#define REG_CLASS_CONTENTS {{0x00000000, 0x00000000},\t\\\n+\t\t\t    {0x00000001, 0x00000000},\t\\\n+\t\t\t    {0x00000000, 0xffffffff},\t\\\n+\t\t\t    {0xfffffffe, 0x00000000},\t\\\n+\t\t\t    {0xffffffff, 0x00000000},\t\\\n+\t\t\t    {0xfffffffe, 0xffffffff},\t\\\n+\t\t\t    {0xffffffff, 0xffffffff}}\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n-#define REGNO_REG_CLASS(REGNO) ((REGNO) ? GENERAL_REGS : AP_REG)\n+#define REGNO_REG_CLASS(REGNO) \\\n+  ((REGNO) ? ((REGNO < 32) ? GENERAL_REGS : XRF_REGS) : AP_REG)\n \n /* The class value for index registers, and the one for base regs.  */\n-#define BASE_REG_CLASS ALL_REGS\n+#define BASE_REG_CLASS AGRF_REGS\n #define INDEX_REG_CLASS GENERAL_REGS\n \n-/* Get reg_class from a letter such as appears in the machine description.  */\n-\n-#define REG_CLASS_FROM_LETTER(C) NO_REGS\n+/* Get reg_class from a letter such as appears in the machine description.\n+   For the 88000, the following class/letter is defined for the XRF:\n+\tx - Extended register file  */\n+#define REG_CLASS_FROM_LETTER(C) \t\\\n+   (((C) == 'x') ? XRF_REGS : NO_REGS)\n \n /* Macros to check register numbers against specific register classes.\n    These assume that REGNO is a hard or pseudo reg number.\n    They give nonzero only if REGNO is a hard reg of the suitable class\n    or a pseudo reg currently allocated to a suitable hard reg.\n    Since they use reg_renumber, they are safe only once reg_renumber\n    has been allocated, which happens in local-alloc.c.  */\n-#define REGNO_OK_FOR_BASE_P(REGNO) \\\n-  ((REGNO) < FIRST_PSEUDO_REGISTER || \\\n-   (unsigned) reg_renumber[REGNO] < FIRST_PSEUDO_REGISTER)\n-#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n-  (((REGNO) && (REGNO) < FIRST_PSEUDO_REGISTER) || \\\n-   (unsigned) reg_renumber[REGNO] < FIRST_PSEUDO_REGISTER)\n+#define REGNO_OK_FOR_BASE_P(REGNO)\t\t\t\t\\\n+  ((REGNO) < FIRST_EXTENDED_REGISTER\t\t\t\t\\\n+   || (unsigned) reg_renumber[REGNO] < FIRST_EXTENDED_REGISTER)\n+#define REGNO_OK_FOR_INDEX_P(REGNO)\t\t\t\t\\\n+  (((REGNO) && (REGNO) < FIRST_EXTENDED_REGISTER)\t\t\\\n+   || (unsigned) reg_renumber[REGNO] < FIRST_EXTENDED_REGISTER)\n \n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use.\n    In general this is just CLASS; but on some machines\n    in some cases it is preferable to use a more restrictive class.\n    Double constants should be in a register iff they can be made cheaply.  */\n-#define PREFERRED_RELOAD_CLASS(X,CLASS) (CLASS)\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\\\n+   (CONSTANT_P(X) && (CLASS == XRF_REGS) ? NO_REGS : (CLASS))\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n-  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+#define CLASS_MAX_NREGS(CLASS, MODE) \\\n+  ((((CLASS) == XRF_REGS) ? 1 \\\n+    : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)))\n \n /* Letters in the range `I' through `P' in a register constraint string can\n    be used to stand for particular ranges of immediate operands.  The C\n@@ -1471,9 +1615,10 @@ enum reg_class { NO_REGS, AP_REG, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n /* These are specific to version 03.00 assembler syntax.  */\n #define INTERNAL_ASM_OP\t\t\"local\"\n #define VERSION_ASM_OP\t\t\"version\"\n-#define ASM_DWARF_POP_SECTION(FILE) fputs (\"\\tprevious\\n\", FILE)\n #define UNALIGNED_SHORT_ASM_OP\t\"uahalf\"\n #define UNALIGNED_INT_ASM_OP\t\"uaword\"\n+#define PUSHSECTION_ASM_OP\t\"section\"\n+#define POPSECTION_ASM_OP\t\"previous\"\n \n /* Output any initial stuff to the assembly file.  Always put out\n    a file directive, even if not debugging.\n@@ -1544,7 +1689,7 @@ enum reg_class { NO_REGS, AP_REG, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n #define ASM_OUTPUT_IDENT(FILE, NAME)\n #else\n #define ASM_OUTPUT_IDENT(FILE, NAME) \\\n-  fprintf (FILE, \"\\t%s\\t \\\"%s\\\"\\n\", IDENT_ASM_OP, NAME)\n+  output_ascii (FILE, IDENT_ASM_OP, 4000, NAME, strlen (NAME));\n #endif\n \n /* Output to assembler file text saying following lines\n@@ -1581,7 +1726,11 @@ enum reg_class { NO_REGS, AP_REG, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n   {\"#r0\"+1, \"#r1\"+1, \"#r2\"+1, \"#r3\"+1, \"#r4\"+1, \"#r5\"+1, \"#r6\"+1, \"#r7\"+1, \\\n    \"#r8\"+1, \"#r9\"+1, \"#r10\"+1,\"#r11\"+1,\"#r12\"+1,\"#r13\"+1,\"#r14\"+1,\"#r15\"+1,\\\n    \"#r16\"+1,\"#r17\"+1,\"#r18\"+1,\"#r19\"+1,\"#r20\"+1,\"#r21\"+1,\"#r22\"+1,\"#r23\"+1,\\\n-   \"#r24\"+1,\"#r25\"+1,\"#r26\"+1,\"#r27\"+1,\"#r28\"+1,\"#r29\"+1,\"#r30\"+1,\"#r31\"+1}\n+   \"#r24\"+1,\"#r25\"+1,\"#r26\"+1,\"#r27\"+1,\"#r28\"+1,\"#r29\"+1,\"#r30\"+1,\"#r31\"+1,\\\n+   \"#x0\"+1, \"#x1\"+1, \"#x2\"+1, \"#x3\"+1, \"#x4\"+1, \"#x5\"+1, \"#x6\"+1, \"#x7\"+1, \\\n+   \"#x8\"+1, \"#x9\"+1, \"#x10\"+1,\"#x11\"+1,\"#x12\"+1,\"#x13\"+1,\"#x14\"+1,\"#x15\"+1,\\\n+   \"#x16\"+1,\"#x17\"+1,\"#x18\"+1,\"#x19\"+1,\"#x20\"+1,\"#x21\"+1,\"#x22\"+1,\"#x23\"+1,\\\n+   \"#x24\"+1,\"#x25\"+1,\"#x26\"+1,\"#x27\"+1,\"#x28\"+1,\"#x29\"+1,\"#x30\"+1,\"#x31\"+1}\n \n /* How to renumber registers for dbx and gdb.  */\n #define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n@@ -1776,7 +1925,7 @@ enum reg_class { NO_REGS, AP_REG, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n #define ASM_BYTE_OP \"\\tbyte\"\n #undef\tASM_OUTPUT_ASCII\n #define ASM_OUTPUT_ASCII(FILE, P, SIZE)  \\\n-  output_ascii ((FILE), (P), (SIZE))\n+  output_ascii (FILE, ASCII_DATA_ASM_OP, 48, P, SIZE)\n \n /* Epilogue for case labels.  This jump instruction is called by casesi\n    to transfer to the appropriate branch instruction within the table."}, {"sha": "b1d660fa6491942036a498ee4249ac990ea8ffed", "filename": "gcc/config/m88k/m88k.md", "status": "modified", "additions": 288, "deletions": 173, "changes": 461, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a9c3f03ac114279cf8d080e7f0b1ec5d262b4646/gcc%2Fconfig%2Fm88k%2Fm88k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a9c3f03ac114279cf8d080e7f0b1ec5d262b4646/gcc%2Fconfig%2Fm88k%2Fm88k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.md?ref=a9c3f03ac114279cf8d080e7f0b1ec5d262b4646", "patch": "@@ -28,7 +28,7 @@\n (define_expand \"m88k_sccs_id\"\n   [(match_operand:SI 0 \"\" \"\")]\n   \"\"\n-  \"{ static char sccs_id[] = \\\"@(#)m88k.md\t2.0.3.4 20 Mar 1992 15:09:03\\\";\n+  \"{ static char sccs_id[] = \\\"@(#)m88k.md\t2.1.3.1 07 Apr 1992 17:25:37\\\";\n      FAIL; }\")\n \f\n ;; Attribute specifications\n@@ -42,26 +42,26 @@\n ;\n ; \"branch,jump,call,\t\t\t; flow-control instructions\n ;  load,store,loada,\t\t\t; data unit instructions\n-;  spadd,dpadd,spdiv,dpdiv,idiv,\t; FPU add instructions\n+;  spadd,dpadd,spcmp,dpcmp,spdiv,dpdiv,idiv, ; FPU add instructions\n ;  spmul,dpmul,imul,\t\t\t; FPU multiply instructions\n-;  arith,\t\t\t\t; integer unit instructions\n-;  marith,mstore,mfp,weird\"\t\t; multi-word instructions\n+;  arith,bit,mov\t\t\t; integer unit instructions\n+;  marith,mbit,mstore,mfp,weird\"\t; multi-word instructions\n \n ; Classification of each insn.  Some insns of TYPE_BRANCH are multi-word.\n (define_attr \"type\"\n-  \"branch,jump,call,load,store,loada,spadd,dpadd,spdiv,dpdiv,idiv,spmul,dpmul,imul,arith,marith,mstore,mfp,weird\"\n+  \"branch,jump,call,load,store,loada,spadd,dpadd,spcmp,dpcmp,spdiv,dpdiv,idiv,spmul,dpmul,imul,arith,bit,mov,marith,mbit,mstore,mfp,weird\"\n   (const_string \"arith\"))\n \n ; Convenience attributes.\n (define_attr \"fpu\" \"yes,no\"\n   (if_then_else\n-   (eq_attr \"type\" \"spmul,dpmul,imul,spadd,dpadd,spdiv,dpdiv,idiv,mfp\")\n+   (eq_attr \"type\" \"spmul,dpmul,imul,spadd,dpadd,spcmp,dpcmp,spdiv,dpdiv,idiv,mfp\")\n    (const_string \"yes\") (const_string \"no\")))\n \n ; Length in # of instructions of each insn.  The values are not exact, but\n ; are safe.\n (define_attr \"length\" \"\"\n-  (cond [(eq_attr \"type\" \"marith,mstore,mfp\")\n+  (cond [(eq_attr \"type\" \"marith,mbit,mstore,mfp\")\n \t (const_int 2)]\n \t(const_int 1)))\n \n@@ -80,7 +80,7 @@\n (define_delay (eq_attr \"type\" \"branch,jump\")\n   [(and\n     (and\n-     (eq_attr \"type\" \"!branch,jump,call,marith,mstore,mfp,weird\") ; required.\n+     (eq_attr \"type\" \"!branch,jump,call,marith,mbit,mstore,mfp,weird\") ; required.\n      (eq_attr \"type\" \"!load\")) ; issue as-soon-as-possible.\n     (eq_attr \"fpu\" \"no\")) ; issue as-soon-as-possible.\n    (eq_attr \"type\" \"!call,branch,jump\") (nil)]) ; @@ was (const_int 1)\n@@ -89,7 +89,7 @@\n ; a call.  (@@ Support for this case is expected in reorg.c soon.)\n \n (define_delay (eq_attr \"type\" \"call\")\n-  [(eq_attr \"type\" \"!branch,call,marith,mstore,mfp,weird\") ; required.\n+  [(eq_attr \"type\" \"!branch,call,marith,mbit,mstore,mfp,weird\") ; required.\n    (nil) (nil)])\n \f\n ; An abstract block diagram of the function units for the m88100.\n@@ -137,10 +137,13 @@\n \n ; Describing the alu is currently not useful.\n ;(define_function_unit \"alu\" 1 0 (eq_attr \"type\"\n-;\t\t\t\t\t \"!store,mstore,marith,mfp,weird\") 1 0)\n-;(define_function_unit \"alu\" 1 0 (eq_attr \"type\" \"marith,weird\") 2 0)\n+;\t\t\t\t\t \"!store,mstore,marith,mbit,mfp,weird\") 1 0)\n+;(define_function_unit \"alu\" 1 0 (eq_attr \"type\" \"marith,mbit,weird\") 2 0)\n \n-(define_function_unit \"memory\" 1 3 (eq_attr \"type\" \"load\") 3 2)\n+(define_function_unit \"memory\" 1 3\n+  (and (eq_attr \"type\" \"load\") (eq_attr \"cpu\" \"m88100\")) 3 2)\n+(define_function_unit \"memory\" 1 3\n+  (and (eq_attr \"type\" \"load\") (eq_attr \"cpu\" \"!m88100\")) 2 2)\n \n ; The fp1 and fplast descriptions currently have no effect.\n ;(define_function_unit \"fp1\" 1 1 (eq_attr \"fpu\" \"yes\") 1 2)\n@@ -149,15 +152,38 @@\n ; adjusted based on the actual generated code.  The notation to the right\n ; is the total latency.  A range denotes a group of instructions and/or\n ; conditions (the extra clock of fplast time with some sequences).\n-(define_function_unit \"fpmul\" 1 4 (eq_attr \"type\" \"spmul\") 4 2)\t\t; 6-8\n-(define_function_unit \"fpmul\" 1 4 (eq_attr \"type\" \"dpmul,mfp\") 7 2)\t; 9-10\n-(define_function_unit \"fpmul\" 1 4 (eq_attr \"type\" \"imul\") 3 2)\t\t; 4\n-\n-(define_function_unit \"fpadd\" 1 3 (eq_attr \"type\" \"spadd\") 3 2)\t\t; 5-6\n-(define_function_unit \"fpadd\" 1 3 (eq_attr \"type\" \"dpadd\") 4 2)\t\t; 6-7\n-(define_function_unit \"fpadd\" 1 3 (eq_attr \"type\" \"spdiv\") 30 2)\t; 30-31\n-(define_function_unit \"fpadd\" 1 3 (eq_attr \"type\" \"dpdiv\") 60 2)\t; 60-61\n-(define_function_unit \"fpadd\" 1 3 (eq_attr \"type\" \"idiv\") 38 2)\t\t; 38\n+(define_function_unit \"fpmul\" 1 4\n+  (and (eq_attr \"type\" \"spmul\") (eq_attr \"cpu\" \"m88100\")) 4 2)\t\t; 6-8\n+(define_function_unit \"fpmul\" 1 4\n+  (and (eq_attr \"type\" \"dpmul,mfp\") (eq_attr \"cpu\" \"m88100\")) 7 2)\t; 9-10\n+(define_function_unit \"fpmul\" 1 4\n+  (and (eq_attr \"type\" \"imul\") (eq_attr \"cpu\" \"m88100\")) 3 2)\t\t; 4\n+\n+(define_function_unit \"fpmul\" 1 4\n+  (and (eq_attr \"type\" \"imul,spmul,dpmul,mfp\")\n+       (eq_attr \"cpu\" \"!m88100\")) 3 2)\t\t\t\t\t; 3\n+\n+(define_function_unit \"fpadd\" 1 3\n+  (and (eq_attr \"type\" \"spadd,spcmp\") (eq_attr \"cpu\" \"m88100\")) 3 2)\t; 5-6\n+(define_function_unit \"fpadd\" 1 3\n+  (and (eq_attr \"type\" \"dpadd,dpcmp\") (eq_attr \"cpu\" \"m88100\")) 4 2)\t; 6-7\n+(define_function_unit \"fpadd\" 1 3\n+  (and (eq_attr \"type\" \"spdiv\") (eq_attr \"cpu\" \"m88100\")) 30 2)\t\t; 30-31\n+(define_function_unit \"fpadd\" 1 3\n+  (and (eq_attr \"type\" \"dpdiv\") (eq_attr \"cpu\" \"m88100\")) 60 2)\t\t; 60-61\n+(define_function_unit \"fpadd\" 1 3\n+  (and (eq_attr \"type\" \"idiv\") (eq_attr \"cpu\" \"m88100\")) 38 2)\t\t; 38\n+\n+(define_function_unit \"fpadd\" 1 3\n+  (and (eq_attr \"type\" \"spadd,dpadd\") (eq_attr \"cpu\" \"!m88100\")) 3 2)\t; 3\n+(define_function_unit \"fpadd\" 1 3\n+  (and (eq_attr \"type\" \"spcmp,dpcmp\") (eq_attr \"cpu\" \"!m88100\")) 1 2)\t; 3\n+(define_function_unit \"fpadd\" 1 3\n+  (and (eq_attr \"type\" \"spdiv\") (eq_attr \"cpu\" \"!m88100\")) 13 2)\t; 13\n+(define_function_unit \"fpadd\" 1 3\n+  (and (eq_attr \"type\" \"dpdiv\") (eq_attr \"cpu\" \"!m88100\")) 23 2)\t; 23\n+(define_function_unit \"fpadd\" 1 3\n+  (and (eq_attr \"type\" \"idiv\") (eq_attr \"cpu\" \"!m88100\")) 18 2)\t\t; 18\n \n ;(define_function_unit \"fplast\" 1 1 (eq_attr \"fpu\" \"yes\") 1 2)\n \n@@ -194,7 +220,8 @@\n   operands[4] = gen_rtx (CONST_INT, SImode,\n \t\t\t INTVAL (operands[3]) - INTVAL (operands[2]));\n   return \\\"ext %0,%1,%w3<%4>\\\";  /* <(%3-%2)> */\n-}\")\n+}\"\n+  [(set_attr \"type\" \"bit\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -207,7 +234,8 @@\n   operands[4] = gen_rtx (CONST_INT, SImode,\n \t\t\t INTVAL (operands[3]) - INTVAL (operands[2]));\n   return \\\"extu %0,%1,%w3<%4>\\\";  /* <(%3-%2)> */\n-}\")\n+}\"\n+  [(set_attr \"type\" \"bit\")])\n \n ;; Optimize possible cases of the set instruction.\n \n@@ -216,23 +244,26 @@\n         (ashift:SI (const_int -1)\n        \t    (match_operand:SI 1 \"register_operand\" \"r\")))]\n   \"\"\n-  \"set %0,%#r0,%1\")\n+  \"set %0,%#r0,%1\"\n+  [(set_attr \"type\" \"bit\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n         (ior:SI (ashift:SI (const_int -1)\n        \t\t    (match_operand:SI 1 \"register_operand\" \"r\"))\n        \t (match_operand:SI 2 \"register_operand\" \"r\")))]\n   \"\"\n-  \"set %0,%2,%1\")\n+  \"set %0,%2,%1\"\n+  [(set_attr \"type\" \"bit\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n         (ior:SI (match_operand:SI 1 \"register_operand\" \"r\")\n        \t (ashift:SI (const_int -1)\n        \t\t    (match_operand:SI 2 \"register_operand\" \"r\"))))]\n   \"\"\n-  \"set %0,%1,%2\")\n+  \"set %0,%1,%2\"\n+  [(set_attr \"type\" \"bit\")])\n \n ;; Optimize possible cases of the mak instruction.\n \n@@ -248,7 +279,8 @@\n \t\t\t exact_log2 (1 + (INTVAL (operands[3])\n \t\t\t\t\t  >> INTVAL(operands[2]))));\n   return \\\"mak %0,%1,%4<%2>\\\";\n-}\")\n+}\"\n+  [(set_attr \"type\" \"bit\")])\n \n ;; Optimize possible cases of output_and.\n \n@@ -266,7 +298,7 @@\n \t       ((1 << INTVAL (operands[2])) - 1) << INTVAL (operands[4]));\n   return output_and (operands);\n }\"\n-  [(set_attr \"type\" \"marith\")]) ; length is 1 or 2.\n+  [(set_attr \"type\" \"marith\")]) ; arith,bit,marith.  length is 1 or 2.\n \f\n ;; Recognize bcnd instructions for integer values.  This is distinguished\n ;; from a conditional branch instruction (below) with SImode instead of\n@@ -663,47 +695,53 @@\n   \"cmp %0,%r1,%2\")\n \n (define_insn \"\"\n-  [(set (match_operand:CC 0 \"register_operand\" \"=r,r\")\n-\t(compare:CC (match_operand:SF 1 \"register_operand\" \"r,r\")\n-\t\t    (match_operand:SF 2 \"real_or_0_operand\" \"r,G\")))]\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r,r,r,r\")\n+\t(compare:CC (match_operand:SF 1 \"register_operand\" \"r,r,x,x\")\n+\t\t    (match_operand:SF 2 \"real_or_0_operand\" \"r,G,x,G\")))]\n   \"\"\n   \"@\n    fcmp.sss %0,%1,%2\n-   fcmp.sss %0,%1,%#r0\"\n-  [(set_attr \"type\" \"spadd\")])\n+   fcmp.sss %0,%1,%#r0\n+   fcmp.sss %0,%1,%2\n+   fcmp.sss %0,%1,%#x0\"\n+  [(set_attr \"type\" \"spcmp\")])\n \n (define_insn \"\"\n-  [(set (match_operand:CC 0 \"register_operand\" \"=r\")\n-\t(compare:CC (match_operand:DF 1 \"register_operand\" \"r\")\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r,r\")\n+\t(compare:CC (match_operand:DF 1 \"register_operand\" \"r,x\")\n \t\t    (float_extend:DF\n-\t\t     (match_operand:SF 2 \"register_operand\" \"r\"))))]\n+\t\t     (match_operand:SF 2 \"register_operand\" \"r,x\"))))]\n   \"\"\n   \"fcmp.sds %0,%1,%2\"\n-  [(set_attr \"type\" \"dpadd\")])\n+  [(set_attr \"type\" \"dpcmp\")])\n \n (define_insn \"\"\n-  [(set (match_operand:CC 0 \"register_operand\" \"=r\")\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r,r\")\n \t(compare:CC (float_extend:DF\n-\t\t     (match_operand:SF 1 \"register_operand\" \"r\"))\n-\t\t    (match_operand:DF 2 \"register_operand\" \"r\")))]\n+\t\t     (match_operand:SF 1 \"register_operand\" \"r,x\"))\n+\t\t    (match_operand:DF 2 \"register_operand\" \"r,x\")))]\n   \"\"\n   \"fcmp.ssd %0,%1,%2\"\n-  [(set_attr \"type\" \"dpadd\")])\n+  [(set_attr \"type\" \"dpcmp\")])\n \n (define_insn \"\"\n-  [(set (match_operand:CC 0 \"register_operand\" \"=r,r\")\n-\t(compare:CC (match_operand:DF 1 \"register_operand\" \"r,r\")\n-\t\t    (match_operand:DF 2 \"real_or_0_operand\" \"r,G\")))]\n+  [(set (match_operand:CC 0 \"register_operand\" \"=r,r,r,r\")\n+\t(compare:CC (match_operand:DF 1 \"register_operand\" \"r,r,x,x\")\n+\t\t    (match_operand:DF 2 \"real_or_0_operand\" \"r,G,x,G\")))]\n   \"\"\n   \"@\n    fcmp.sdd %0,%1,%2\n-   fcmp.sds %0,%1,%#r0\"\n-  [(set_attr \"type\" \"dpadd\")])\n+   fcmp.sds %0,%1,%#r0\n+   fcmp.sdd %0,%1,%2\n+   fcmp.sds %0,%1,%#x0\"\n+  [(set_attr \"type\" \"dpcmp\")])\n \f\n ;; Store condition code insns.  The compare insns set a register\n ;; rather than cc0 and record that register for use here.  See above\n ;; for the special treatment of cmpsi with a constant operand.\n \n+;; @@ For the m88110, use fcmpu for bxx sxx inequality comparisons.\n+\n (define_expand \"seq\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(match_dup 1))]\n@@ -772,7 +810,8 @@\n \t\t\t   [(match_operand:CC 2 \"register_operand\" \"r\")\n \t\t\t    (const_int 0)]))]\n   \"\"\n-  \"ext %0,%2,1<%C1>\")\n+  \"ext %0,%2,1<%C1>\"\n+  [(set_attr \"type\" \"bit\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -781,7 +820,8 @@\n \t\t\t    [(match_operand:CC 2 \"register_operand\" \"r\")\n \t\t\t     (const_int 0)])))]\n   \"\"\n-  \"extu %0,%2,1<%C1>\")\n+  \"extu %0,%2,1<%C1>\"\n+  [(set_attr \"type\" \"bit\")])\n \f\n ;; Conditional branch insns.  The compare insns set a register\n ;; rather than cc0 and record that register for use here.  See above\n@@ -963,8 +1003,8 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,m,r,r\")\n-\t(match_operand:SI 1 \"move_operand\" \"rI,m,rO,J,M\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,r,x,x,x,m\")\n+\t(match_operand:SI 1 \"move_operand\" \"rI,m,rO,J,M,x,r,x,m,x\"))]\n   \"(register_operand (operands[0], SImode)\n     || register_operand (operands[1], SImode)\n     || operands[1] == const0_rtx)\"\n@@ -973,8 +1013,13 @@\n    ld %0,%1\n    st %r1,%0\n    subu %0,%#r0,%n1\n-   set %0,%#r0,%s1\"\n-  [(set_attr \"type\" \"arith,load,store,arith,arith\")])\n+   set %0,%#r0,%s1\n+   mov.s %0,%1\n+   mov.s %0,%1\n+   mov %0,%1\n+   ld %0,%1\n+   st %1,%0\"\n+  [(set_attr \"type\" \"arith,load,store,arith,bit,mov,mov,mov,load,store\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r,r\")\n@@ -986,7 +1031,7 @@\n    or.u %0,%#r0,%X1\n    set %0,%#r0,%s1\n    or.u %0,%#r0,%X1\\;or %0,%0,%x1\"\n-  [(set_attr \"type\" \"arith,arith,arith,arith,marith\")])\n+  [(set_attr \"type\" \"arith,arith,arith,bit,marith\")])\n \n ;; @@ Why the constraint \"in\"?  Doesn't `i' include `n'?\n (define_insn \"\"\n@@ -1079,21 +1124,28 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,x\")\n \t(const_int 0))]\n   \"\"\n-  \"or %0,%#r0,0\\;or %d0,%#r0,0\"\n-  [(set_attr \"type\" \"marith\")])\n+  \"@\n+   or %0,%#r0,0\\;or %d0,%#r0,0\n+   mov %0,%#x0\"\n+  [(set_attr \"type\" \"marith,mov\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m\")\n-\t(match_operand:DI 1 \"nonimmediate_operand\" \"r,m,r\"))]\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m,r,x,x,x,m\")\n+\t(match_operand:DI 1 \"nonimmediate_operand\" \"r,m,r,x,r,x,m,x\"))]\n   \"\"\n   \"@\n    or %0,%#r0,%1\\;or %d0,%#r0,%d1\n    ld.d %0,%1\n+   st.d %1,%0\n+   mov.d %0,%1\n+   mov.d %0,%1\n+   mov %0,%1\n+   ld.d %0,%1\n    st.d %1,%0\"\n-  [(set_attr \"type\" \"marith,load,store\")])\n+  [(set_attr \"type\" \"marith,load,store,mov,mov,mov,load,store\")])\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -1145,21 +1197,28 @@\n ;}\")\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n \t(const_int 0))]\n   \"\"\n-  \"or %0,%#r0,0\\;or %d0,%#r0,0\"\n-  [(set_attr \"type\" \"marith\")])\n+  \"@\n+   or %0,%#r0,0\\;or %d0,%#r0,0\n+   mov %0,%#x0\"\n+  [(set_attr \"type\" \"marith,mov\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,m\")\n-\t(match_operand:DF 1 \"nonimmediate_operand\" \"r,m,r\"))]\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,r,m,x,r,x,x,m\")\n+\t(match_operand:DF 1 \"nonimmediate_operand\" \"r,m,r,r,x,x,m,x\"))]\n   \"\"\n   \"@\n    or %0,%#r0,%1\\;or %d0,%#r0,%d1\n    ld.d %0,%1\n+   st.d %1,%0\n+   mov.d %0,%1\n+   mov.d %0,%1\n+   mov %0,%1\n+   ld.d %0,%1\n    st.d %1,%0\"\n-  [(set_attr \"type\" \"marith,load,store\")])\n+  [(set_attr \"type\" \"marith,load,store,mov,mov,mov,load,store\")])\n \n (define_insn \"\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n@@ -1190,20 +1249,28 @@\n \n ;; @@ What happens to fconst0_rtx?\n (define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r,x\")\n \t(const_int 0))]\n   \"\"\n-  \"or %0,%#r0,0\")\n+  \"@\n+   or %0,%#r0,0\n+   mov %0,%#x0\"\n+  [(set_attr \"type\" \"arith,mov\")])\n \n (define_insn \"\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,m\")\n-\t(match_operand:SF 1 \"nonimmediate_operand\" \"r,m,r\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,m,x,r,x,x,m\")\n+\t(match_operand:SF 1 \"nonimmediate_operand\" \"r,m,r,r,x,x,m,x\"))]\n   \"\"\n   \"@\n    or %0,%#r0,%1\n    ld %0,%1\n+   st %r1,%0\n+   mov.s %0,%1\n+   mov.s %0,%1\n+   mov %0,%1\n+   ld %0,%1\n    st %r1,%0\"\n-  [(set_attr \"type\" \"arith,load,store\")])\n+  [(set_attr \"type\" \"arith,load,store,mov,mov,mov,load,store\")])\n \n (define_insn \"\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n@@ -1388,7 +1455,7 @@\n    or %0,%#r0,%h1\n    subu %0,%#r0,%H1\n    ld.h %0,%1\"\n-  [(set_attr \"type\" \"arith,arith,arith,load\")])\n+  [(set_attr \"type\" \"bit,arith,arith,load\")])\n \n (define_expand \"extendqihi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n@@ -1411,7 +1478,7 @@\n    or %0,%#r0,%q1\n    subu %0,%#r0,%Q1\n    ld.b %0,%1\"\n-  [(set_attr \"type\" \"arith,arith,arith,load\")])\n+  [(set_attr \"type\" \"bit,arith,arith,load\")])\n \n (define_expand \"extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -1434,57 +1501,83 @@\n    or %0,%#r0,%q1\n    subu %0,%#r0,%Q1\n    ld.b %0,%1\"\n-  [(set_attr \"type\" \"arith,arith,arith,load\")])\n+  [(set_attr \"type\" \"bit,arith,arith,load\")])\n \f\n ;; Conversions between float and double.\n \n ;; The fadd instruction does not conform to IEEE 754 when used to\n ;; convert between float and double.  In particular, the sign of -0 is\n ;; not preserved.  Interestingly, fsub does conform.\n \n-(define_insn \"extendsfdf2\"\n+(define_expand \"extendsfdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n \t(float_extend:DF (match_operand:SF 1 \"register_operand\" \"r\")))]\n   \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n+\t(float_extend:DF (match_operand:SF 1 \"register_operand\" \"r\")))]\n+  \"! TARGET_88110\"\n   \"fsub.dss %0,%1,%#r0\"\n   [(set_attr \"type\" \"spadd\")])\n \n-(define_insn \"truncdfsf2\"\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(float_extend:DF (match_operand:SF 1 \"register_operand\" \"r,x\")))]\n+  \"TARGET_88110\"\n+  \"fcvt.ds %0,%1\"\n+  [(set_attr \"type\" \"spadd\")])\n+\n+(define_expand \"truncdfsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n \t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"r\")))]\n   \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n+\t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"r\")))]\n+  \"! TARGET_88110\"\n   \"fsub.sds %0,%1,%#r0\"\n   [(set_attr \"type\" \"dpadd\")])\n \n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r,x\")\n+\t(float_truncate:SF (match_operand:DF 1 \"register_operand\" \"r,x\")))]\n+  \"TARGET_88110\"\n+  \"fcvt.sd %0,%1\"\n+  [(set_attr \"type\" \"dpadd\")])\n+\n ;; Conversions between floating point and integer\n \n (define_insn \"floatsidf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(float:DF (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(float:DF (match_operand:SI 1 \"register_operand\" \"r,r\")))]\n   \"\"\n   \"flt.ds %0,%1\"\n-  [(set_attr \"type\" \"spadd\")])\n+  [(set_attr \"type\" \"spadd,dpadd\")])\n \n (define_insn \"floatsisf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(float:SF (match_operand:SI 1 \"register_operand\" \"r\")))]\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r,x\")\n+\t(float:SF (match_operand:SI 1 \"register_operand\" \"r,r\")))]\n   \"\"\n   \"flt.ss %0,%1\"\n-  [(set_attr \"type\" \"spadd\")])\n+  [(set_attr \"type\" \"spadd,spadd\")])\n \n (define_insn \"fix_truncdfsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(fix:SI (match_operand:DF 1 \"register_operand\" \"r\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,x\")\n+\t(fix:SI (match_operand:DF 1 \"register_operand\" \"r,r\")))]\n   \"\"\n   \"trnc.sd %0,%1\"\n-  [(set_attr \"type\" \"dpadd\")])\n+  [(set_attr \"type\" \"dpadd,dpadd\")])\n \n (define_insn \"fix_truncsfsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(fix:SI (match_operand:SF 1 \"register_operand\" \"r\")))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,x\")\n+\t(fix:SI (match_operand:SF 1 \"register_operand\" \"r,r\")))]\n   \"\"\n   \"trnc.ss %0,%1\"\n-  [(set_attr \"type\" \"spadd\")])\n+  [(set_attr \"type\" \"spadd,dpadd\")])\n \n \f\n ;;- arithmetic instructions\n@@ -1531,9 +1624,9 @@\n ;; requires double rounding, whereas the 88000 instruction only rounds once.\n \n (define_expand \"adddf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(plus:DF (match_operand:DF 1 \"general_operand\" \"%r\")\n-\t\t (match_operand:DF 2 \"general_operand\" \"r\")))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(plus:DF (match_operand:DF 1 \"general_operand\" \"%r,x\")\n+\t\t (match_operand:DF 2 \"general_operand\" \"r,x\")))]\n   \"\"\n   \"\n {\n@@ -1542,41 +1635,41 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(plus:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r\"))\n-\t\t (float_extend:DF (match_operand:SF 2 \"register_operand\" \"r\"))))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(plus:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r,x\"))\n+\t\t (float_extend:DF (match_operand:SF 2 \"register_operand\" \"r,x\"))))]\n   \"\"\n   \"fadd.dss %0,%1,%2\"\n   [(set_attr \"type\" \"spadd\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(plus:DF (match_operand:DF 1 \"register_operand\" \"r\")\n-\t\t (float_extend:DF (match_operand:SF 2 \"register_operand\" \"r\"))))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(plus:DF (match_operand:DF 1 \"register_operand\" \"r,x\")\n+\t\t (float_extend:DF (match_operand:SF 2 \"register_operand\" \"r,x\"))))]\n   \"\"\n   \"fadd.dds %0,%1,%2\"\n   [(set_attr \"type\" \"dpadd\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(plus:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r\"))\n-\t\t (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(plus:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r,x\"))\n+\t\t (match_operand:DF 2 \"register_operand\" \"r,x\")))]\n   \"\"\n   \"fadd.dsd %0,%1,%2\"\n   [(set_attr \"type\" \"dpadd\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(plus:DF (match_operand:DF 1 \"register_operand\" \"%r\")\n-\t\t (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(plus:DF (match_operand:DF 1 \"register_operand\" \"%r,x\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"r,x\")))]\n   \"\"\n   \"fadd.ddd %0,%1,%2\"\n   [(set_attr \"type\" \"dpadd\")])\n \n (define_insn \"addsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(plus:SF (match_operand:SF 1 \"register_operand\" \"%r\")\n-\t\t (match_operand:SF 2 \"register_operand\" \"r\")))]\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r,x\")\n+\t(plus:SF (match_operand:SF 1 \"register_operand\" \"%r,x\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"r,x\")))]\n   \"\"\n   \"fadd.sss %0,%1,%2\"\n   [(set_attr \"type\" \"spadd\")])\n@@ -1622,9 +1715,9 @@\n ;; requires double rounding, whereas the 88000 instruction only rounds once.\n \n (define_expand \"subdf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(minus:DF (match_operand:DF 1 \"general_operand\" \"r\")\n-\t\t  (match_operand:DF 2 \"general_operand\" \"r\")))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(minus:DF (match_operand:DF 1 \"general_operand\" \"r,x\")\n+\t\t  (match_operand:DF 2 \"general_operand\" \"r,x\")))]\n   \"\"\n   \"\n {\n@@ -1633,41 +1726,41 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(minus:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r\"))\n-\t\t  (float_extend:DF (match_operand:SF 2 \"register_operand\" \"r\"))))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(minus:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r,x\"))\n+\t\t  (float_extend:DF (match_operand:SF 2 \"register_operand\" \"r,x\"))))]\n   \"\"\n   \"fsub.dss %0,%1,%2\"\n   [(set_attr \"type\" \"spadd\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(minus:DF (match_operand:DF 1 \"register_operand\" \"r\")\n-\t\t  (float_extend:DF (match_operand:SF 2 \"register_operand\" \"r\"))))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(minus:DF (match_operand:DF 1 \"register_operand\" \"r,x\")\n+\t\t  (float_extend:DF (match_operand:SF 2 \"register_operand\" \"r,x\"))))]\n   \"\"\n   \"fsub.dds %0,%1,%2\"\n   [(set_attr \"type\" \"dpadd\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(minus:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r\"))\n-\t\t  (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(minus:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r,x\"))\n+\t\t  (match_operand:DF 2 \"register_operand\" \"r,x\")))]\n   \"\"\n   \"fsub.dsd %0,%1,%2\"\n   [(set_attr \"type\" \"dpadd\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(minus:DF (match_operand:DF 1 \"register_operand\" \"r\")\n-\t\t  (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(minus:DF (match_operand:DF 1 \"register_operand\" \"r,x\")\n+\t\t  (match_operand:DF 2 \"register_operand\" \"r,x\")))]\n   \"\"\n   \"fsub.ddd %0,%1,%2\"\n   [(set_attr \"type\" \"dpadd\")])\n \n (define_insn \"subsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(minus:SF (match_operand:SF 1 \"register_operand\" \"r\")\n-\t\t  (match_operand:SF 2 \"register_operand\" \"r\")))]\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r,x\")\n+\t(minus:SF (match_operand:SF 1 \"register_operand\" \"r,x\")\n+\t\t  (match_operand:SF 2 \"register_operand\" \"r,x\")))]\n   \"\"\n   \"fsub.sss %0,%1,%2\"\n   [(set_attr \"type\" \"spadd\")])\n@@ -1712,15 +1805,25 @@\n   \"mul %0,%1,%2\"\n   [(set_attr \"type\" \"imul\")])\n \n+;; @@ This isn't fully implemented yet.\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(mult:DI (match_operand:SI 1 \"arith32_operand\" \"%r\")\n+\t\t (match_operand:SI 2 \"arith32_operand\" \"rI\")))]\n+  \"TARGET_88110\"\n+  \"mulu.d %0,%1,%2\"\n+  [(set_attr \"type\" \"imul\")])\n+\n ;; patterns for mixed mode floating point\n ;; Do not define patterns that utilize mixed mode arithmetic that result\n ;; in narrowing the precision, because it loses accuracy, since the standard\n ;; requires double rounding, whereas the 88000 instruction only rounds once.\n \n (define_expand \"muldf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(mult:DF (match_operand:DF 1 \"general_operand\" \"%r\")\n-\t\t (match_operand:DF 2 \"general_operand\" \"r\")))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(mult:DF (match_operand:DF 1 \"general_operand\" \"%r,x\")\n+\t\t (match_operand:DF 2 \"general_operand\" \"r,x\")))]\n   \"\"\n   \"\n {\n@@ -1729,41 +1832,41 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(mult:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r\"))\n-\t\t (float_extend:DF (match_operand:SF 2 \"register_operand\" \"r\"))))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(mult:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r,x\"))\n+\t\t (float_extend:DF (match_operand:SF 2 \"register_operand\" \"r,x\"))))]\n   \"\"\n   \"fmul.dss %0,%1,%2\"\n   [(set_attr \"type\" \"spmul\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(mult:DF (match_operand:DF 1 \"register_operand\" \"r\")\n-\t\t (float_extend:DF (match_operand:SF 2 \"register_operand\" \"r\"))))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(mult:DF (match_operand:DF 1 \"register_operand\" \"r,x\")\n+\t\t (float_extend:DF (match_operand:SF 2 \"register_operand\" \"r,x\"))))]\n   \"\"\n   \"fmul.dds %0,%1,%2\"\n   [(set_attr \"type\" \"spmul\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(mult:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r\"))\n-\t\t (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(mult:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r,x\"))\n+\t\t (match_operand:DF 2 \"register_operand\" \"r,x\")))]\n   \"\"\n   \"fmul.dsd %0,%1,%2\"\n   [(set_attr \"type\" \"spmul\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(mult:DF (match_operand:DF 1 \"register_operand\" \"%r\")\n-\t\t (match_operand:DF 2 \"register_operand\" \"r\")))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(mult:DF (match_operand:DF 1 \"register_operand\" \"%r,x\")\n+\t\t (match_operand:DF 2 \"register_operand\" \"r,x\")))]\n   \"\"\n   \"fmul.ddd %0,%1,%2\"\n   [(set_attr \"type\" \"dpmul\")])\n \n (define_insn \"mulsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(mult:SF (match_operand:SF 1 \"register_operand\" \"%r\")\n-\t\t (match_operand:SF 2 \"register_operand\" \"r\")))]\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r,x\")\n+\t(mult:SF (match_operand:SF 1 \"register_operand\" \"%r,x\")\n+\t\t (match_operand:SF 2 \"register_operand\" \"r,x\")))]\n   \"\"\n   \"fmul.sss %0,%1,%2\"\n   [(set_attr \"type\" \"spmul\")])\n@@ -2052,9 +2155,9 @@\n ;; requires double rounding, whereas the 88000 instruction only rounds once.\n \n (define_expand \"divdf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(div:DF (match_operand:DF 1 \"general_operand\" \"r\")\n-\t\t(match_operand:DF 2 \"general_operand\" \"r\")))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(div:DF (match_operand:DF 1 \"general_operand\" \"r,x\")\n+\t\t(match_operand:DF 2 \"general_operand\" \"r,x\")))]\n   \"\"\n   \"\n {\n@@ -2072,41 +2175,41 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(div:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r\"))\n-\t\t(float_extend:DF (match_operand:SF 2 \"register_operand\" \"r\"))))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(div:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r,x\"))\n+\t\t(float_extend:DF (match_operand:SF 2 \"register_operand\" \"r,x\"))))]\n   \"\"\n   \"fdiv.dss %0,%1,%2\"\n   [(set_attr \"type\" \"dpdiv\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(div:DF (match_operand:DF 1 \"register_operand\" \"r\")\n-\t\t(float_extend:DF (match_operand:SF 2 \"register_operand\" \"r\"))))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(div:DF (match_operand:DF 1 \"register_operand\" \"r,x\")\n+\t\t(float_extend:DF (match_operand:SF 2 \"register_operand\" \"r,x\"))))]\n   \"\"\n   \"fdiv.dds %0,%1,%2\"\n   [(set_attr \"type\" \"dpdiv\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(div:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r\"))\n-\t\t(match_operand:DF 2 \"register_operand\" \"r\")))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(div:DF (float_extend:DF (match_operand:SF 1 \"register_operand\" \"r,x\"))\n+\t\t(match_operand:DF 2 \"register_operand\" \"r,x\")))]\n   \"\"\n   \"fdiv.dsd %0,%1,%2\"\n   [(set_attr \"type\" \"dpdiv\")])\n \n (define_insn \"divsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(div:SF (match_operand:SF 1 \"register_operand\" \"r\")\n-\t\t(match_operand:SF 2 \"register_operand\" \"r\")))]\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r,x\")\n+\t(div:SF (match_operand:SF 1 \"register_operand\" \"r,x\")\n+\t\t(match_operand:SF 2 \"register_operand\" \"r,x\")))]\n   \"\"\n   \"fdiv.sss %0,%1,%2\"\n   [(set_attr \"type\" \"spdiv\")])\n \n (define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(div:DF (match_operand:DF 1 \"register_operand\" \"r\")\n-\t\t(match_operand:DF 2 \"register_operand\" \"r\")))]\n+  [(set (match_operand:DF 0 \"register_operand\" \"=r,x\")\n+\t(div:DF (match_operand:DF 1 \"register_operand\" \"r,x\")\n+\t\t(match_operand:DF 2 \"register_operand\" \"r,x\")))]\n   \"\"\n   \"fdiv.ddd %0,%1,%2\"\n   [(set_attr \"type\" \"dpdiv\")])\n@@ -2280,7 +2383,7 @@\n    or.u %0,%1,%X2\n    set %0,%1,%s2\n    or.u %0,%1,%X2\\;or %0,%0,%x2\"\n-  [(set_attr \"type\" \"arith,arith,arith,marith\")])\n+  [(set_attr \"type\" \"arith,arith,bit,marith\")])\n \n (define_insn \"\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n@@ -2500,7 +2603,8 @@\n   \"\"\n   \"@\n    mak %0,%1,%2\n-   mak %0,%1,0<%2>\")\n+   mak %0,%1,0<%2>\"\n+  [(set_attr \"type\" \"bit\")])\n \n (define_expand \"ashrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -2544,7 +2648,8 @@\n   \"\"\n   \"@\n    ext %0,%1,%2\n-   ext %0,%1,0<%2>\")\n+   ext %0,%1,0<%2>\"\n+  [(set_attr \"type\" \"bit\")])\n \f\n ;;- logical shift instructions.  Logical shift left becomes arithmetic\n ;; shift left.  LSHIFT is not normally produced, but is supported.\n@@ -2567,7 +2672,8 @@\n   \"\"\n   \"@\n    mak %0,%1,%2\n-   mak %0,%1,0<%2>\")\n+   mak %0,%1,0<%2>\"\n+  [(set_attr \"type\" \"bit\")])\n \n (define_expand \"lshrsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -2609,7 +2715,8 @@\n   \"\"\n   \"@\n    extu %0,%1,%2\n-   extu %0,%1,0<%2>\")\n+   extu %0,%1,0<%2>\"\n+  [(set_attr \"type\" \"bit\")])\n \f\n ;;- rotate instructions\n \n@@ -2637,7 +2744,8 @@\n \t(rotatert:SI (match_operand:SI 1 \"register_operand\" \"r\")\n \t\t     (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n   \"\"\n-  \"rot %0,%1,%2\")\n+  \"rot %0,%1,%2\"\n+  [(set_attr \"type\" \"bit\")])\n \f\n ;; Bit field instructions.\n \n@@ -2660,7 +2768,8 @@\n   operands[4] = gen_rtx (CONST_INT, SImode,\n \t\t\t (32 - INTVAL (operands[2])) - INTVAL (operands[3]));\n   return \\\"ext %0,%1,%2<%4>\\\";  /* <(32-%2-%3)> */\n-}\")\n+}\"\n+  [(set_attr \"type\" \"bit\")])\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -2681,7 +2790,8 @@\n   operands[4] = gen_rtx (CONST_INT, SImode,\n \t\t\t (32 - INTVAL (operands[2])) - INTVAL (operands[3]));\n   return \\\"extu %0,%1,%2<%4>\\\";  /* <(32-%2-%3)> */\n-}\")\n+}\"\n+  [(set_attr \"type\" \"bit\")])\n \n (define_insn \"\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n@@ -2694,7 +2804,8 @@\n   operands[3] = gen_rtx (CONST_INT, SImode,\n \t\t\t (32 - INTVAL (operands[1])) - INTVAL (operands[2]));\n   return \\\"clr %0,%0,%1<%3>\\\";  /* <(32-%1-%2)> */\n-}\")\n+}\"\n+  [(set_attr \"type\" \"bit\")])\n \n (define_insn \"\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n@@ -2707,7 +2818,8 @@\n   operands[3] = gen_rtx (CONST_INT, SImode,\n \t\t\t (32 - INTVAL (operands[1])) - INTVAL (operands[2]));\n   return \\\"set %0,%0,%1<%3>\\\";  /* <(32-%1-%2)> */\n-}\")\n+}\"\n+  [(set_attr \"type\" \"bit\")])\n \n (define_insn \"\"\n   [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n@@ -2746,10 +2858,12 @@\n   \"subu %0,%#r0,%1\")\n \n (define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(float_truncate:SF (neg:DF (match_operand:DF 1 \"register_operand\" \"r\"))))]\n+  [(set (match_operand:SF 0 \"register_operand\" \"=r,x\")\n+\t(float_truncate:SF (neg:DF (match_operand:DF 1 \"register_operand\" \"r,x\"))))]\n   \"\"\n-  \"fsub.ssd %0,%#r0,%1\"\n+  \"@\n+   fsub.ssd %0,%#r0,%1\n+   fsub.ssd %0,%#x0,%1\"\n   [(set_attr \"type\" \"dpadd\")])\n \n (define_insn \"\"\n@@ -2902,7 +3016,8 @@\n (define_insn \"nop\"\n   [(const_int 0)]\n   \"\"\n-  \"ff0 %#r0,%#r0\")\n+  \"ff0 %#r0,%#r0\"\n+  [(set_attr \"type\" \"bit\")])\n \n (define_insn \"return\"\n   [(return)]"}]}