{"sha": "972938978677f76ef6af494932345945947852ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTcyOTM4OTc4Njc3Zjc2ZWY2YWY0OTQ5MzIzNDU5NDU5NDc4NTJlZQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-09-14T22:04:46Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-09-14T22:04:46Z"}, "message": "cpperror.c (print_location): Take line and column, for default positioning use the previously lexed token.\n\n\t* cpperror.c (print_location): Take line and column, for\n\tdefault positioning use the previously lexed token.\n\t(_cpp_begin_message): Take line and column.\n\t(cpp_ice, cpp_fatal, cpp_error, cpp_error_with_line, cpp_warning,\n\tcpp_warning_with_line, cpp_pedwarn, cpp_pedwarn_with_line): Update.\n\t* cpphash.h (_cpp_begin_message): Update prototype.\n\t* cppinit.c (push_include): Don't set output line.\n\t* cpplex.c (_cpp_lex_token): Callback for start of new output lines.\n\t* cpplib.c (do_diagnostic, _cpp_pop_buffer): Update.\n\t(do_pragma): Kludge for front ends.  Don't expand macros at all.\n\t* cpplib.h (cpp_lookahead, cpp_token_with_pos, cpp_get_line): Remove.\n\t(struct cpp_token): Remove output_line.\n\t(struct cpp_callbacks): New member line_change.\n\t* cppmacro.c (builtin_macro, paste_all_tokens, replace_args,\n\tcpp_get_token): Preserve BOL flag.\n\t(cpp_get_line): Remove.\n\t(_cpp_backup_tokens): Remove useless abort().\n\t* cppmain.c (cb_line_change): New.\n\t(scan_translation_unit): Don't worry about starting new lines here.\n\t* scan-decls.c (scan_decls): Update.\n\t* c-lex.c (c_lex, init_c_lex): Update.\n\t(cb_line_change, src_lineno): New.\n\nFrom-SVN: r45613", "tree": {"sha": "4c00cb933362af65600541484760cce6502de1a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c00cb933362af65600541484760cce6502de1a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/972938978677f76ef6af494932345945947852ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/972938978677f76ef6af494932345945947852ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/972938978677f76ef6af494932345945947852ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/972938978677f76ef6af494932345945947852ee/comments", "author": null, "committer": null, "parents": [{"sha": "4fb1661fea89a2d72f69dcbe341e253d4b3fffe3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fb1661fea89a2d72f69dcbe341e253d4b3fffe3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fb1661fea89a2d72f69dcbe341e253d4b3fffe3"}], "stats": {"total": 251, "additions": 130, "deletions": 121}, "files": [{"sha": "483400150fcd0ba71d2cae1387aab42c6c411357", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972938978677f76ef6af494932345945947852ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972938978677f76ef6af494932345945947852ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=972938978677f76ef6af494932345945947852ee", "patch": "@@ -1,3 +1,28 @@\n+2001-09-14  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpperror.c (print_location): Take line and column, for\n+\tdefault positioning use the previously lexed token.\n+\t(_cpp_begin_message): Take line and column.\n+\t(cpp_ice, cpp_fatal, cpp_error, cpp_error_with_line, cpp_warning,\n+\tcpp_warning_with_line, cpp_pedwarn, cpp_pedwarn_with_line): Update.\n+\t* cpphash.h (_cpp_begin_message): Update prototype.\n+\t* cppinit.c (push_include): Don't set output line.\n+\t* cpplex.c (_cpp_lex_token): Callback for start of new output lines.\n+\t* cpplib.c (do_diagnostic, _cpp_pop_buffer): Update.\n+\t(do_pragma): Kludge for front ends.  Don't expand macros at all.\n+\t* cpplib.h (cpp_lookahead, cpp_token_with_pos, cpp_get_line): Remove.\n+\t(struct cpp_token): Remove output_line.\n+\t(struct cpp_callbacks): New member line_change.\n+\t* cppmacro.c (builtin_macro, paste_all_tokens, replace_args,\n+\tcpp_get_token): Preserve BOL flag.\n+\t(cpp_get_line): Remove.\n+\t(_cpp_backup_tokens): Remove useless abort().\n+\t* cppmain.c (cb_line_change): New.\n+\t(scan_translation_unit): Don't worry about starting new lines here.\n+\t* scan-decls.c (scan_decls): Update.\n+\t* c-lex.c (c_lex, init_c_lex): Update.\n+\t(cb_line_change, src_lineno): New.\n+\n Fri Sep 14 13:54:50 EDT 2001  John Wehle  (john@feith.com)\n \n \t* tree.c (append_random_chars): Generate the random"}, {"sha": "3a80a74a550450513eddc440c4e33000ac512e52", "filename": "gcc/c-lex.c", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972938978677f76ef6af494932345945947852ee/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972938978677f76ef6af494932345945947852ee/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=972938978677f76ef6af494932345945947852ee", "patch": "@@ -60,6 +60,9 @@ static const char *cpp_filename;\n /* The current line map.  */\n static const struct line_map *map;\n \n+/* The line used to refresh the lineno global variable after each token.  */\n+static unsigned int src_lineno;\n+\n /* We may keep statistics about how long which files took to compile.  */\n static int header_time, body_time;\n static splay_tree file_info_tree;\n@@ -89,6 +92,7 @@ static tree lex_string\t\tPARAMS ((const char *, unsigned int, int));\n static tree lex_charconst\tPARAMS ((const cpp_token *));\n static void update_header_times\tPARAMS ((const char *));\n static int dump_one_header\tPARAMS ((splay_tree_node, void *));\n+static void cb_line_change     PARAMS ((cpp_reader *, const cpp_token *, int));\n static void cb_ident\t\tPARAMS ((cpp_reader *, unsigned int,\n \t\t\t\t\t const cpp_string *));\n static void cb_file_change    PARAMS ((cpp_reader *, const struct line_map *));\n@@ -125,6 +129,7 @@ init_c_lex (filename)\n \n   cb = cpp_get_callbacks (parse_in);\n \n+  cb->line_change = cb_line_change;\n   cb->ident = cb_ident;\n   cb->file_change = cb_file_change;\n   cb->def_pragma = cb_def_pragma;\n@@ -243,6 +248,17 @@ cb_ident (pfile, line, str)\n #endif\n }\n \n+/* Called at the start of every non-empty line.  TOKEN is the first\n+   lexed token on the line.  Used for diagnostic line numbers.  */\n+static void\n+cb_line_change (pfile, token, parsing_args)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     const cpp_token *token;\n+     int parsing_args ATTRIBUTE_UNUSED;\n+{\n+  src_lineno = SOURCE_LINE (map, token->line);\n+}\n+\n static void\n cb_file_change (pfile, new_map)\n      cpp_reader *pfile ATTRIBUTE_UNUSED;\n@@ -762,7 +778,7 @@ c_lex (value)\n   /* The C++ front end does horrible things with the current line\n      number.  To ensure an accurate line number, we must reset it\n      every time we return a token.  */\n-  lineno = SOURCE_LINE (map, cpp_get_line (parse_in)->line);\n+  lineno = src_lineno;\n \n   *value = NULL_TREE;\n   type = tok.type;"}, {"sha": "6a3b0c149d98b1beff2d16acf1a686051bc020ef", "filename": "gcc/cpperror.c", "status": "modified", "additions": 24, "deletions": 35, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972938978677f76ef6af494932345945947852ee/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972938978677f76ef6af494932345945947852ee/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=972938978677f76ef6af494932345945947852ee", "patch": "@@ -29,36 +29,36 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"cpphash.h\"\n #include \"intl.h\"\n \n-static void print_location\t\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t const cpp_lexer_pos *));\n+static void print_location PARAMS ((cpp_reader *, unsigned int, unsigned int));\n \n /* Don't remove the blank before do, as otherwise the exgettext\n    script will mistake this as a function definition */\n #define v_message(msgid, ap) \\\n  do { vfprintf (stderr, _(msgid), ap); putc ('\\n', stderr); } while (0)\n \n static void\n-print_location (pfile, pos)\n+print_location (pfile, line, col)\n      cpp_reader *pfile;\n-     const cpp_lexer_pos *pos;\n+     unsigned int line, col;\n {\n   cpp_buffer *buffer = pfile->buffer;\n \n   if (!buffer)\n     fprintf (stderr, \"%s: \", progname);\n   else\n     {\n-      unsigned int line, col;\n       const struct line_map *map;\n \n-      if (pos == 0)\n-\tpos = cpp_get_line (pfile);\n-      map = lookup_line (&pfile->line_maps, pos->line);\n+      if (line == 0)\n+\t{\n+\t  line = pfile->cur_token[-1].line;\n+\t  col = pfile->cur_token[-1].col;\n+\t}\n \n+      map = lookup_line (&pfile->line_maps, line);\n       print_containing_files (&pfile->line_maps, map);\n \n-      line = SOURCE_LINE (map, pos->line);\n-      col = pos->col;\n+      line = SOURCE_LINE (map, line);\n       if (col == 0)\n \tcol = 1;\n \n@@ -74,14 +74,15 @@ print_location (pfile, pos)\n }\n \n /* Set up for an error message: print the file and line, bump the error\n-   counter, etc.\n-   If it returns 0, this error has been suppressed.  */\n+   counter, etc.  LINE is the logical line number; zero means to print\n+   at the location of the previously lexed token, which tends to be the\n+   correct place by default.  Returns 0 if the error has been suppressed.  */\n \n int\n-_cpp_begin_message (pfile, code, pos)\n+_cpp_begin_message (pfile, code, line, column)\n      cpp_reader *pfile;\n      enum error_type code;\n-     const cpp_lexer_pos *pos;\n+     unsigned int line, column;\n {\n   int is_warning = 0;\n \n@@ -125,7 +126,7 @@ _cpp_begin_message (pfile, code, pos)\n       break;\n     }\n \n-  print_location (pfile, pos);\n+  print_location (pfile, line, column);\n   if (is_warning)\n     fputs (_(\"warning: \"), stderr);\n \n@@ -144,7 +145,7 @@ cpp_ice VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n   VA_FIXEDARG (ap, cpp_reader *, pfile);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  if (_cpp_begin_message (pfile, ICE, 0))\n+  if (_cpp_begin_message (pfile, ICE, 0, 0))\n     v_message (msgid, ap);\n \n   VA_CLOSE (ap);\n@@ -163,7 +164,7 @@ cpp_fatal VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n   VA_FIXEDARG (ap, cpp_reader *, pfile);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  if (_cpp_begin_message (pfile, FATAL, 0))\n+  if (_cpp_begin_message (pfile, FATAL, 0, 0))\n     v_message (msgid, ap);\n \n   VA_CLOSE (ap);\n@@ -176,7 +177,7 @@ cpp_error VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n   VA_FIXEDARG (ap, cpp_reader *, pfile);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  if (_cpp_begin_message (pfile, ERROR, 0))\n+  if (_cpp_begin_message (pfile, ERROR, 0, 0))\n     v_message (msgid, ap);\n \n   VA_CLOSE (ap);\n@@ -186,17 +187,13 @@ void\n cpp_error_with_line VPARAMS ((cpp_reader *pfile, int line, int column,\n \t\t\t     const char *msgid, ...))\n {\n-  cpp_lexer_pos pos;\n-  \n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, cpp_reader *, pfile);\n   VA_FIXEDARG (ap, int, line);\n   VA_FIXEDARG (ap, int, column);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  pos.line = line;\n-  pos.col = column;\n-  if (_cpp_begin_message (pfile, ERROR, &pos))\n+  if (_cpp_begin_message (pfile, ERROR, line, column))\n     v_message (msgid, ap);\n \n   VA_CLOSE (ap);\n@@ -218,7 +215,7 @@ cpp_warning VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n   VA_FIXEDARG (ap, cpp_reader *, pfile);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  if (_cpp_begin_message (pfile, WARNING, 0))\n+  if (_cpp_begin_message (pfile, WARNING, 0, 0))\n     v_message (msgid, ap);\n \n   VA_CLOSE (ap);\n@@ -228,17 +225,13 @@ void\n cpp_warning_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n \t\t\t       const char *msgid, ...))\n {\n-  cpp_lexer_pos pos;\n-\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, cpp_reader *, pfile);\n   VA_FIXEDARG (ap, int, line);\n   VA_FIXEDARG (ap, int, column);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  pos.line = line;\n-  pos.col = column;\n-  if (_cpp_begin_message (pfile, WARNING, &pos))\n+  if (_cpp_begin_message (pfile, WARNING, line, column))\n     v_message (msgid, ap);\n \n   VA_CLOSE (ap);\n@@ -251,7 +244,7 @@ cpp_pedwarn VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n   VA_FIXEDARG (ap, cpp_reader *, pfile);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  if (_cpp_begin_message (pfile, PEDWARN, 0))\n+  if (_cpp_begin_message (pfile, PEDWARN, 0, 0))\n     v_message (msgid, ap);\n \n   VA_CLOSE (ap);\n@@ -261,17 +254,13 @@ void\n cpp_pedwarn_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n \t\t\t       const char *msgid, ...))\n {\n-  cpp_lexer_pos pos;\n-  \n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, cpp_reader *, pfile);\n   VA_FIXEDARG (ap, int, line);\n   VA_FIXEDARG (ap, int, column);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  pos.line = line;\n-  pos.col = column;\n-  if (_cpp_begin_message (pfile, PEDWARN, &pos))\n+  if (_cpp_begin_message (pfile, PEDWARN, line, column))\n     v_message (msgid, ap);\n \n   VA_CLOSE (ap);"}, {"sha": "dd851dcade151f6f9f51d28f7b1f28d62e37419e", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972938978677f76ef6af494932345945947852ee/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972938978677f76ef6af494932345945947852ee/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=972938978677f76ef6af494932345945947852ee", "patch": "@@ -368,7 +368,7 @@ extern unsigned char _cpp_trigraph_map[UCHAR_MAX + 1];\n /* In cpperror.c  */\n enum error_type { WARNING = 0, WARNING_SYSHDR, PEDWARN, ERROR, FATAL, ICE };\n extern int _cpp_begin_message PARAMS ((cpp_reader *, enum error_type,\n-\t\t\t\t       const cpp_lexer_pos *));\n+\t\t\t\t       unsigned int, unsigned int));\n \n /* In cppmacro.c */\n extern void _cpp_free_definition\tPARAMS ((cpp_hashnode *));"}, {"sha": "94e11981b64cd546a10807d7539ca2d466b94861", "filename": "gcc/cppinit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972938978677f76ef6af494932345945947852ee/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972938978677f76ef6af494932345945947852ee/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=972938978677f76ef6af494932345945947852ee", "patch": "@@ -886,7 +886,7 @@ push_include (pfile, p)\n   header.val.str.text = (const unsigned char *) p->arg;\n   header.val.str.len = strlen (p->arg);\n   /* Make the command line directive take up a line.  */\n-  pfile->lexer_pos.line = pfile->lexer_pos.output_line = ++pfile->line;\n+  pfile->lexer_pos.line = ++pfile->line;\n \n   return _cpp_execute_include (pfile, &header, IT_CMDLINE);\n }"}, {"sha": "32430773fdf3c6564dbcccf50d290091a3fe5542", "filename": "gcc/cpplex.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972938978677f76ef6af494932345945947852ee/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972938978677f76ef6af494932345945947852ee/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=972938978677f76ef6af494932345945947852ee", "patch": "@@ -955,13 +955,14 @@ _cpp_lex_token (pfile, dest)\n \n       if (result->flags & BOL)\n \t{\n-\t  pfile->lexer_pos.output_line = result->line;\n \t  /* Is this a directive.  If _cpp_handle_directive returns\n \t     false, it is an assembler #.  */\n \t  if (result->type == CPP_HASH\n \t      && !pfile->state.parsing_args\n \t      && _cpp_handle_directive (pfile, result->flags & PREV_WHITE))\n \t    continue;\n+\t  if (pfile->cb.line_change && !pfile->state.skipping)\n+\t    (*pfile->cb.line_change)(pfile, result, pfile->state.parsing_args);\n \t}\n \n       /* We don't skip tokens in directives.  */"}, {"sha": "06541ad9ecf3b80ed2b2d57f3e8e8e9cd11e0bb3", "filename": "gcc/cpplib.c", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972938978677f76ef6af494932345945947852ee/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972938978677f76ef6af494932345945947852ee/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=972938978677f76ef6af494932345945947852ee", "patch": "@@ -799,7 +799,7 @@ do_diagnostic (pfile, code, print_dir)\n      enum error_type code;\n      int print_dir;\n {\n-  if (_cpp_begin_message (pfile, code, 0))\n+  if (_cpp_begin_message (pfile, code, 0, 0))\n     {\n       if (print_dir)\n \tfprintf (stderr, \"#%s \", pfile->directive->name);\n@@ -987,14 +987,22 @@ do_pragma (pfile)\n \t}\n     }\n \n-  pfile->state.prevent_expansion--;\n+  /* FIXME.  This is an awful kludge to get the front ends to update\n+     their notion of line number for diagnostic purposes.  The line\n+     number should be passed to the handler and they should do it\n+     themselves.  Stand-alone CPP must ignore us, otherwise it will\n+     prefix the directive with spaces, hence the 1.  Ugh.  */\n+  if (pfile->cb.line_change)\n+    (*pfile->cb.line_change)(pfile, &tok, 1);\n+\n   if (handler)\n     (*handler) (pfile);\n   else if (pfile->cb.def_pragma)\n     {\n       _cpp_backup_tokens (pfile, count);\n       (*pfile->cb.def_pragma) (pfile, pfile->directive_line);\n     }\n+  pfile->state.prevent_expansion--;\n }\n \n static void\n@@ -1773,11 +1781,7 @@ _cpp_pop_buffer (pfile)\n     cpp_error_with_line (pfile, ifs->pos.line, ifs->pos.col,\n \t\t\t \"unterminated #%s\", dtable[ifs->type].name);\n \n-  /* The output line can fall out of sync if we missed the final\n-     newline from the previous buffer, for example because of an\n-     unterminated comment.  Similarly, skipping needs to be cleared in\n-     case of a missing #endif.  */\n-  pfile->lexer_pos.output_line = pfile->line;\n+  /* In case of a missing #endif.  */\n   pfile->state.skipping = 0;\n \n   /* Update the reader's buffer before _cpp_do_file_change.  */"}, {"sha": "77199956765b81ce21706dda3444988685ee8e05", "filename": "gcc/cpplib.h", "status": "modified", "additions": 9, "deletions": 26, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972938978677f76ef6af494932345945947852ee/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972938978677f76ef6af494932345945947852ee/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=972938978677f76ef6af494932345945947852ee", "patch": "@@ -42,7 +42,6 @@ typedef struct cpp_string cpp_string;\n typedef struct cpp_hashnode cpp_hashnode;\n typedef struct cpp_macro cpp_macro;\n typedef struct cpp_lexer_pos cpp_lexer_pos;\n-typedef struct cpp_lookahead cpp_lookahead;\n typedef struct cpp_callbacks cpp_callbacks;\n \n struct answer;\n@@ -191,26 +190,9 @@ struct cpp_token\n struct cpp_lexer_pos\n {\n   unsigned int line;\n-  unsigned int output_line;\n   unsigned short col;\n };\n \n-typedef struct cpp_token_with_pos cpp_token_with_pos;\n-struct cpp_token_with_pos\n-{\n-  cpp_token token;\n-  cpp_lexer_pos pos;\n-};\n-\n-/* Token lookahead.  */\n-struct cpp_lookahead\n-{\n-  struct cpp_lookahead *next;\n-  cpp_token_with_pos *tokens;\n-  cpp_lexer_pos pos;\n-  unsigned int cur, count, cap;\n-};\n-\n /* A standalone character.  We may want to make it unsigned for the\n    same reason we use unsigned char - to avoid signedness issues.  */\n typedef int cppchar_t;\n@@ -390,13 +372,15 @@ struct cpp_options\n /* Call backs.  */\n struct cpp_callbacks\n {\n-    void (*file_change) PARAMS ((cpp_reader *, const struct line_map *));\n-    void (*include) PARAMS ((cpp_reader *, unsigned int,\n-\t\t\t     const unsigned char *, const cpp_token *));\n-    void (*define) PARAMS ((cpp_reader *, unsigned int, cpp_hashnode *));\n-    void (*undef) PARAMS ((cpp_reader *, unsigned int, cpp_hashnode *));\n-    void (*ident) PARAMS ((cpp_reader *, unsigned int, const cpp_string *));\n-    void (*def_pragma) PARAMS ((cpp_reader *, unsigned int));\n+  /* Called when a new line of preprocessed output is started.  */\n+  void (*line_change) PARAMS ((cpp_reader *, const cpp_token *, int));\n+  void (*file_change) PARAMS ((cpp_reader *, const struct line_map *));\n+  void (*include) PARAMS ((cpp_reader *, unsigned int,\n+\t\t\t   const unsigned char *, const cpp_token *));\n+  void (*define) PARAMS ((cpp_reader *, unsigned int, cpp_hashnode *));\n+  void (*undef) PARAMS ((cpp_reader *, unsigned int, cpp_hashnode *));\n+  void (*ident) PARAMS ((cpp_reader *, unsigned int, const cpp_string *));\n+  void (*def_pragma) PARAMS ((cpp_reader *, unsigned int));\n };\n \n #define CPP_FATAL_LIMIT 1000\n@@ -522,7 +506,6 @@ extern int cpp_avoid_paste PARAMS ((cpp_reader *, const cpp_token *,\n extern enum cpp_ttype cpp_can_paste PARAMS ((cpp_reader *, const cpp_token *,\n \t\t\t\t\t     const cpp_token *, int *));\n extern void cpp_get_token PARAMS ((cpp_reader *, cpp_token *));\n-extern const cpp_lexer_pos *cpp_get_line PARAMS ((cpp_reader *));\n extern const unsigned char *cpp_macro_definition PARAMS ((cpp_reader *,\n \t\t\t\t\t\t  const cpp_hashnode *));\n extern void _cpp_backup_tokens PARAMS ((cpp_reader *, unsigned int));"}, {"sha": "61abc4a37d546f28f61d65670f67615aed1b4b29", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 6, "deletions": 23, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972938978677f76ef6af494932345945947852ee/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972938978677f76ef6af494932345945947852ee/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=972938978677f76ef6af494932345945947852ee", "patch": "@@ -135,7 +135,7 @@ builtin_macro (pfile, token)\n      cpp_reader *pfile;\n      cpp_token *token;\n {\n-  unsigned char flags = ((token->flags & PREV_WHITE) | AVOID_LPASTE);\n+  unsigned char flags = ((token->flags & (PREV_WHITE | BOL)) | AVOID_LPASTE);\n   cpp_hashnode *node = token->val.node;\n \n   switch (node->value.builtin)\n@@ -211,21 +211,6 @@ builtin_macro (pfile, token)\n   token->flags = flags;\n }\n \n-/* Used by cpperror.c to obtain the correct line and column to report\n-   in a diagnostic.  */\n-const cpp_lexer_pos *\n-cpp_get_line (pfile)\n-     cpp_reader *pfile;\n-{\n-  if (pfile->context->prev == NULL)\n-    {\n-      pfile->lexer_pos.line = pfile->cur_token[-1].line;\n-      pfile->lexer_pos.col = pfile->cur_token[-1].col;\n-    }\n-\n-  return &pfile->lexer_pos;\n-}\n-\n static void\n lock_pools (pfile)\n      cpp_reader *pfile;\n@@ -454,8 +439,8 @@ paste_all_tokens (pfile, lhs)\n \n   /* The pasted token has the PREV_WHITE flag of the LHS, is no longer\n      PASTE_LEFT, and is subject to macro expansion.  */\n-  lhs->flags &= ~(PREV_WHITE | PASTE_LEFT | NO_EXPAND);\n-  lhs->flags |= orig_flags & (PREV_WHITE | AVOID_LPASTE);\n+  lhs->flags &= ~(PREV_WHITE | BOL | PASTE_LEFT | NO_EXPAND);\n+  lhs->flags |= orig_flags & (PREV_WHITE | BOL | AVOID_LPASTE);\n }\n \n /* Reads the unexpanded tokens of a macro argument into ARG.  VAR_ARGS\n@@ -818,8 +803,8 @@ replace_args (pfile, macro, args, list)\n \t    memcpy (dest, from, count * sizeof (cpp_token));\n \n \t    /* The first token gets PREV_WHITE of the CPP_MACRO_ARG.  */\n-\t    dest->flags &= ~PREV_WHITE;\n-\t    dest->flags |= src->flags & PREV_WHITE;\n+\t    dest->flags &= ~(PREV_WHITE | BOL);\n+\t    dest->flags |= src->flags & (PREV_WHITE | BOL);\n \t    dest->flags |= AVOID_LPASTE;\n \n \t    /* The last token gets the PASTE_LEFT of the CPP_MACRO_ARG.  */\n@@ -984,7 +969,7 @@ cpp_get_token (pfile, token)\n \t  else if (enter_macro_context (pfile, node))\n \t    {\n \t      /* Pass AVOID_LPASTE and our PREV_WHITE to next token.  */\n-\t      pfile->buffer->saved_flags = ((token->flags & PREV_WHITE)\n+\t      pfile->buffer->saved_flags = ((token->flags & (PREV_WHITE | BOL))\n \t\t\t\t\t    | AVOID_LPASTE);\n \t      continue;\n \t    }\n@@ -1042,8 +1027,6 @@ _cpp_backup_tokens (pfile, count)\n \t  pfile->cur_token--;\n \t  if (pfile->cur_token == pfile->cur_run->base)\n \t    {\n-\t      if (pfile->cur_run == NULL)\n-\t\tabort ();\n \t      pfile->cur_run = pfile->cur_run->prev;\n \t      pfile->cur_token = pfile->cur_run->limit;\n \t    }"}, {"sha": "560d81f4bdda40b61f7bb40f6c1a656a5931d9c7", "filename": "gcc/cppmain.c", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972938978677f76ef6af494932345945947852ee/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972938978677f76ef6af494932345945947852ee/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=972938978677f76ef6af494932345945947852ee", "patch": "@@ -52,6 +52,7 @@ static void maybe_print_line PARAMS ((const struct line_map *, unsigned int));\n \n /* Callback routines for the parser.   Most of these are active only\n    in specific modes.  */\n+static void cb_line_change PARAMS ((cpp_reader *, const cpp_token *, int));\n static void cb_define\tPARAMS ((cpp_reader *, unsigned int, cpp_hashnode *));\n static void cb_undef\tPARAMS ((cpp_reader *, unsigned int, cpp_hashnode *));\n static void cb_include\tPARAMS ((cpp_reader *, unsigned int,\n@@ -192,6 +193,7 @@ setup_callbacks ()\n {\n   cpp_callbacks *cb = cpp_get_callbacks (pfile);\n \n+  cb->line_change = cb_line_change;\n   if (! options->no_output)\n     {\n       cb->ident      = cb_ident;\n@@ -217,7 +219,7 @@ static void\n scan_translation_unit (pfile)\n      cpp_reader *pfile;\n {\n-  unsigned int index, line;\n+  unsigned int index;\n   cpp_token tokens[2], *token;\n \n   for (index = 0;; index = 1 - index)\n@@ -228,27 +230,8 @@ scan_translation_unit (pfile)\n       if (token->type == CPP_EOF)\n \tbreak;\n \n-      line = cpp_get_line (pfile)->output_line;\n-      if (print.line != line)\n-\t{\n-\t  unsigned int col = cpp_get_line (pfile)->col;\n-\n-\t  /* Supply enough whitespace to put this token in its original\n-\t     column.  Don't bother trying to reconstruct tabs; we can't\n-\t     get it right in general, and nothing ought to care.  (Yes,\n-\t     some things do care; the fault lies with them.)  */\n-\t  maybe_print_line (print.map, line);\n-\t  if (col > 1)\n-\t    {\n-\t      if (token->flags & PREV_WHITE)\n-\t\tcol--;\n-\t      while (--col)\n-\t\tputc (' ', print.outf);\n-\t    }\n-\t}\n-      else if ((token->flags & (PREV_WHITE | AVOID_LPASTE))\n-\t       == AVOID_LPASTE\n-\t       && cpp_avoid_paste (pfile, &tokens[1 - index], token))\n+      if ((token->flags & (PREV_WHITE | AVOID_LPASTE | BOL)) == AVOID_LPASTE\n+\t  && cpp_avoid_paste (pfile, &tokens[1 - index], token))\n \ttoken->flags |= PREV_WHITE;\n       /* Special case '# <directive name>': insert a space between\n \t the # and the token.  This will prevent it from being\n@@ -259,7 +242,6 @@ scan_translation_unit (pfile)\n \ttoken->flags |= PREV_WHITE;\n \n       cpp_output_token (token, print.outf);\n-      print.printed = 1;\n       if (token->type == CPP_STRING || token->type == CPP_WSTRING\n \t  || token->type == CPP_COMMENT)\n \tcheck_multiline_token (&token->val.str);\n@@ -335,7 +317,34 @@ print_line (map, line, special_flags)\n     }\n }\n \n-/* Callbacks.  */\n+/* Called when a line of output is started.  TOKEN is the first token\n+   of the line, and maybe be CPP_EOF.  */\n+\n+static void\n+cb_line_change (pfile, token, parsing_args)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     const cpp_token *token;\n+     int parsing_args;\n+{\n+  if (token->type == CPP_EOF || parsing_args)\n+    return;\n+\n+  maybe_print_line (print.map, token->line);\n+  print.printed = 1;\n+\n+  /* Supply enough spaces to put this token in its original column,\n+     one space per column greater than 2, since scan_translation_unit\n+     will provide a space if PREV_WHITE.  Don't bother trying to\n+     reconstruct tabs; we can't get it right in general, and nothing\n+     ought to care.  Some things do care; the fault lies with them.  */\n+  if (token->col > 2)\n+    {\n+      unsigned int spaces = token->col - 2;\n+\n+      while (spaces--)\n+\tputc (' ', print.outf);\n+    }\n+}\n \n static void\n cb_ident (pfile, line, str)"}, {"sha": "7fd36cabe9eb76bf537d6384c9c84de233f05038", "filename": "gcc/scan-decls.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/972938978677f76ef6af494932345945947852ee/gcc%2Fscan-decls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/972938978677f76ef6af494932345945947852ee/gcc%2Fscan-decls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan-decls.c?ref=972938978677f76ef6af494932345945947852ee", "patch": "@@ -170,8 +170,7 @@ scan_decls (pfile, argc, argv)\n \t\t\t   || token.type == CPP_ELLIPSIS)\n \t\t    have_arg_list = 1;\n \t\t}\n-\t      recognized_function (&prev_id, \n-\t\t\t\t   cpp_get_line (pfile)->line,\n+\t      recognized_function (&prev_id, token->line,\n \t\t\t\t   (saw_inline ? 'I'\n \t\t\t\t    : in_extern_C_brace || current_extern_C\n \t\t\t\t    ? 'F' : 'f'), have_arg_list);"}]}