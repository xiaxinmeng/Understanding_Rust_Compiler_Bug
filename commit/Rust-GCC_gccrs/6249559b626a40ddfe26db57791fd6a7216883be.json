{"sha": "6249559b626a40ddfe26db57791fd6a7216883be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI0OTU1OWI2MjZhNDBkZGZlMjZkYjU3NzkxZmQ2YTcyMTY4ODNiZQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-06-26T10:17:00Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-06-26T10:17:00Z"}, "message": "gigi.h (create_var_decl_1): Rename into...\n\n\t* gcc-interface/gigi.h (create_var_decl_1): Rename into...\n\t(create_var_decl): ...this.  Add default value for last parameter.\n\t(create_type_stub_decl): Adjust.\n\t(create_type_decl): Likewise.\n\t(create_field_decl): Likewise.\n\t(create_param_decl): Likewise.\n\t(create_label_decl): Likewise.\n\t(create_subprog_decl): Likewise.\n\t* gcc-interface/utils.c (create_var_decl_1): Rename into...\n\t(create_var_decl): ...this.  Rename var_name into name and var_init\n\tinto init, move const_decl_allowed_p last and adjust accordingly.\n\t(create_type_stub_decl): Rename type_name into name and adjust.\n\t(create_type_decl): Likewise.\n\t(create_field_decl): Likewise for field_name and field_type.\n\t(create_param_decl): Likewise for param_name and param_type.\n\t(create_label_decl): Likewise for label_name.\n\t(create_subprog_decl): Likewise for subprog_name and subprog_type.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Adjust couple of calls\n\tto create_var_decl_1.\n\nFrom-SVN: r225002", "tree": {"sha": "552cc973b15da94c883f61b26f5e615ab049aab6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/552cc973b15da94c883f61b26f5e615ab049aab6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6249559b626a40ddfe26db57791fd6a7216883be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6249559b626a40ddfe26db57791fd6a7216883be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6249559b626a40ddfe26db57791fd6a7216883be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6249559b626a40ddfe26db57791fd6a7216883be/comments", "author": null, "committer": null, "parents": [{"sha": "66cc6273bad0c51db5e499dec2352a6bb7b4a952", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66cc6273bad0c51db5e499dec2352a6bb7b4a952", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66cc6273bad0c51db5e499dec2352a6bb7b4a952"}], "stats": {"total": 325, "additions": 165, "deletions": 160}, "files": [{"sha": "a58c80f39ad67d8f8266d70bf3ec075df5a4872a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6249559b626a40ddfe26db57791fd6a7216883be/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6249559b626a40ddfe26db57791fd6a7216883be/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6249559b626a40ddfe26db57791fd6a7216883be", "patch": "@@ -1,3 +1,25 @@\n+2015-06-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (create_var_decl_1): Rename into...\n+\t(create_var_decl): ...this.  Add default value for last parameter.\n+\t(create_type_stub_decl): Adjust.\n+\t(create_type_decl): Likewise.\n+\t(create_field_decl): Likewise.\n+\t(create_param_decl): Likewise.\n+\t(create_label_decl): Likewise.\n+\t(create_subprog_decl): Likewise.\n+\t* gcc-interface/utils.c (create_var_decl_1): Rename into...\n+\t(create_var_decl): ...this.  Rename var_name into name and var_init\n+\tinto init, move const_decl_allowed_p last and adjust accordingly.\n+\t(create_type_stub_decl): Rename type_name into name and adjust.\n+\t(create_type_decl): Likewise.\n+\t(create_field_decl): Likewise for field_name and field_type.\n+\t(create_param_decl): Likewise for param_name and param_type.\n+\t(create_label_decl): Likewise for label_name.\n+\t(create_subprog_decl): Likewise for subprog_name and subprog_type.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Adjust couple of calls\n+\tto create_var_decl_1.\n+\n 2015-06-26  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (loop_info_d): Add low_bound, high_bound,"}, {"sha": "3c2609d6c464efb5cec9b039e7355da0971a1605", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6249559b626a40ddfe26db57791fd6a7216883be/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6249559b626a40ddfe26db57791fd6a7216883be/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=6249559b626a40ddfe26db57791fd6a7216883be", "patch": "@@ -1444,11 +1444,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t/* Now create the variable or the constant and set various flags.  */\n \tgnu_decl\n-\t  = create_var_decl_1 (gnu_entity_name, gnu_ext_name, gnu_type,\n-\t\t\t       gnu_expr, const_flag, Is_Public (gnat_entity),\n-\t\t\t       imported_p || !definition, static_p,\n-\t\t\t       artificial_p, debug_info_p, !renamed_obj,\n-\t\t\t       attr_list, gnat_entity);\n+\t  = create_var_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n+\t\t\t     gnu_expr, const_flag, Is_Public (gnat_entity),\n+\t\t\t     imported_p || !definition, static_p,\n+\t\t\t     artificial_p, debug_info_p, attr_list,\n+\t\t\t     gnat_entity, !renamed_obj);\n \tDECL_BY_REF_P (gnu_decl) = used_by_ref;\n \tDECL_POINTS_TO_READONLY_P (gnu_decl) = used_by_ref && inner_const_flag;\n \tDECL_CAN_NEVER_BE_NULL_P (gnu_decl) = Can_Never_Be_Null (gnat_entity);\n@@ -1497,11 +1497,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t|| Is_Aliased (Etype (gnat_entity))))\n \t  {\n \t    tree gnu_corr_var\n-\t      = create_var_decl_1 (gnu_entity_name, gnu_ext_name, gnu_type,\n-\t\t\t\t   gnu_expr, true, Is_Public (gnat_entity),\n-\t\t\t\t   !definition, static_p, artificial_p,\n-\t\t\t\t   debug_info_p, false, attr_list,\n-\t\t\t\t   gnat_entity);\n+\t      = create_var_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n+\t\t\t\t gnu_expr, true, Is_Public (gnat_entity),\n+\t\t\t\t !definition, static_p, artificial_p,\n+\t\t\t\t debug_info_p, attr_list, gnat_entity,\n+\t\t\t\t false);\n \n \t    SET_DECL_CONST_CORRESPONDING_VAR (gnu_decl, gnu_corr_var);\n \t  }"}, {"sha": "4f95d3f77e541d9331e75f1e9f8674e1e94d1307", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 40, "deletions": 53, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6249559b626a40ddfe26db57791fd6a7216883be/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6249559b626a40ddfe26db57791fd6a7216883be/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=6249559b626a40ddfe26db57791fd6a7216883be", "patch": "@@ -654,23 +654,22 @@ extern tree create_index_type (tree min, tree max, tree index,\n    sizetype is used.  */\n extern tree create_range_type (tree type, tree min, tree max);\n \n-/* Return a TYPE_DECL node suitable for the TYPE_STUB_DECL field of a type.\n-   TYPE_NAME gives the name of the type and TYPE is a ..._TYPE node giving\n-   its data type.  */\n-extern tree create_type_stub_decl (tree type_name, tree type);\n-\n-/* Return a TYPE_DECL node.  TYPE_NAME gives the name of the type and TYPE\n-   is a ..._TYPE node giving its data type.  ARTIFICIAL_P is true if the\n-   declaration was generated by the compiler.  DEBUG_INFO_P is true if we\n-   need to write debug information about this type.  GNAT_NODE is used for\n-   the position of the decl.  */\n-extern tree create_type_decl (tree type_name, tree type, bool artificial_p,\n+/* Return a TYPE_DECL node suitable for the TYPE_STUB_DECL field of TYPE.\n+   NAME gives the name of the type to be used in the declaration.  */\n+extern tree create_type_stub_decl (tree name, tree type);\n+\n+/* Return a TYPE_DECL node for TYPE.  NAME gives the name of the type to be\n+   used in the declaration.  ARTIFICIAL_P is true if the declaration was\n+   generated by the compiler.  DEBUG_INFO_P is true if we need to write\n+   debug information about this type.  GNAT_NODE is used for the position\n+   of the decl.  */\n+extern tree create_type_decl (tree name, tree type, bool artificial_p,\n \t\t\t      bool debug_info_p, Node_Id gnat_node);\n \n /* Return a VAR_DECL or CONST_DECL node.\n \n-   VAR_NAME gives the name of the variable.  ASM_NAME is its assembler name\n-   (if provided).  TYPE is its data type (a GCC ..._TYPE node).  VAR_INIT is\n+   NAME gives the name of the variable.  ASM_NAME is its assembler name\n+   (if provided).  TYPE is its data type (a GCC ..._TYPE node).  INIT is\n    the GCC tree for an optional initial expression; NULL_TREE if none.\n \n    CONST_FLAG is true if this variable is constant, in which case we might\n@@ -691,49 +690,37 @@ extern tree create_type_decl (tree type_name, tree type, bool artificial_p,\n    DEBUG_INFO_P is true if we need to write debug information for it.\n \n    GNAT_NODE is used for the position of the decl.  */\n-extern tree\n-create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n-\t\t   bool const_flag, bool public_flag, bool extern_flag,\n-\t\t   bool static_flag, bool artificial_p, bool debug_info_p,\n-\t\t   bool const_decl_allowed_p, struct attrib *attr_list,\n-\t\t   Node_Id gnat_node);\n-\n-/* Wrapper around create_var_decl_1 for cases where we don't care whether\n-   a VAR or a CONST decl node is created.  */\n-#define create_var_decl(var_name, asm_name, type, var_init,\t\\\n-\t\t\tconst_flag, public_flag, extern_flag,\t\\\n-\t\t\tstatic_flag, artificial_p, debug_info_p,\\\n-\t\t\tattr_list, gnat_node)\t\t\t\\\n-  create_var_decl_1 (var_name, asm_name, type, var_init,\t\\\n-\t\t     const_flag, public_flag, extern_flag,\t\\\n-\t\t     static_flag, artificial_p, debug_info_p,\t\\\n-\t\t     true, attr_list, gnat_node)\n-\n-/* Return a FIELD_DECL node.  FIELD_NAME is the field's name, FIELD_TYPE is\n-   its type and RECORD_TYPE is the type of the enclosing record.  If SIZE is\n-   nonzero, it is the specified size of the field.  If POS is nonzero, it is\n-   the bit position.  PACKED is 1 if the enclosing record is packed, -1 if it\n-   has Component_Alignment of Storage_Unit.  If ADDRESSABLE is nonzero, it\n+extern tree create_var_decl (tree name, tree asm_name, tree type, tree init,\n+\t\t\t     bool const_flag, bool public_flag,\n+\t\t\t     bool extern_flag, bool static_flag,\n+\t\t\t     bool artificial_p, bool debug_info_p,\n+\t\t\t     struct attrib *attr_list, Node_Id gnat_node,\n+\t\t\t     bool const_decl_allowed_p = true);\n+\n+/* Return a FIELD_DECL node.  NAME is the field's name, TYPE is its type and\n+   RECORD_TYPE is the type of the enclosing record.  If SIZE is nonzero, it\n+   is the specified size of the field.  If POS is nonzero, it is the bit\n+   position.  PACKED is 1 if the enclosing record is packed, -1 if it has\n+   Component_Alignment of Storage_Unit.  If ADDRESSABLE is nonzero, it\n    means we are allowed to take the address of the field; if it is negative,\n    we should not make a bitfield, which is used by make_aligning_type.  */\n-extern tree create_field_decl (tree field_name, tree field_type,\n-\t\t\t       tree record_type, tree size, tree pos,\n-\t\t\t       int packed, int addressable);\n+extern tree create_field_decl (tree name, tree type, tree record_type,\n+\t\t\t       tree size, tree pos, int packed,\n+\t\t\t       int addressable);\n \n-/* Return a PARM_DECL node.  PARAM_NAME is the name of the parameter and\n-   PARAM_TYPE is its type.  READONLY is true if the parameter is readonly\n-   (either an In parameter or an address of a pass-by-ref parameter).  */\n-extern tree create_param_decl (tree param_name, tree param_type,\n-                               bool readonly);\n+/* Return a PARM_DECL node.  NAME is the name of the parameter and TYPE is\n+   its type.  READONLY is true if the parameter is readonly (either an In\n+   parameter or an address of a pass-by-ref parameter).  */\n+extern tree create_param_decl (tree name, tree type, bool readonly);\n \n-/* Return a LABEL_DECL with LABEL_NAME.  GNAT_NODE is used for the position\n-   of the decl.  */\n-extern tree create_label_decl (tree label_name, Node_Id gnat_node);\n+/* Return a LABEL_DECL with NAME.  GNAT_NODE is used for the position of\n+   the decl.  */\n+extern tree create_label_decl (tree name, Node_Id gnat_node);\n \n-/* Return a FUNCTION_DECL node.  SUBPROG_NAME is the name of the subprogram,\n-   ASM_NAME is its assembler name, SUBPROG_TYPE is its type (a FUNCTION_TYPE\n-   node), PARAM_DECL_LIST is the list of the subprogram arguments (a list of\n-   PARM_DECL nodes chained through the DECL_CHAIN field).\n+/* Return a FUNCTION_DECL node.  NAME is the name of the subprogram, ASM_NAME\n+   its assembler name, TYPE its type (a FUNCTION_TYPE node), PARAM_DECL_LIST\n+   the list of its parameters (a list of PARM_DECL nodes chained through the\n+   DECL_CHAIN field).\n \n    INLINE_STATUS, PUBLIC_FLAG, EXTERN_FLAG and ATTR_LIST are used to set the\n    appropriate fields in the FUNCTION_DECL.\n@@ -743,8 +730,8 @@ extern tree create_label_decl (tree label_name, Node_Id gnat_node);\n    DEBUG_INFO_P is true if we need to write debug information for it.\n \n    GNAT_NODE is used for the position of the decl.  */\n-extern tree create_subprog_decl (tree subprog_name, tree asm_name,\n-\t\t\t\t tree subprog_type, tree param_decl_list,\n+extern tree create_subprog_decl (tree name, tree asm_name, tree type,\n+\t\t\t\t tree param_decl_list,\n \t\t\t\t enum inline_status_t inline_status,\n \t\t\t\t bool public_flag, bool extern_flag,\n \t\t\t\t bool artificial_p, bool debug_info_p,"}, {"sha": "b32bc892fa5d019263789fa72fb8927a4ad00548", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 93, "deletions": 97, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6249559b626a40ddfe26db57791fd6a7216883be/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6249559b626a40ddfe26db57791fd6a7216883be/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=6249559b626a40ddfe26db57791fd6a7216883be", "patch": "@@ -2238,45 +2238,45 @@ create_range_type (tree type, tree min, tree max)\n   return range_type;\n }\n \f\n-/* Return a TYPE_DECL node suitable for the TYPE_STUB_DECL field of a type.\n-   TYPE_NAME gives the name of the type and TYPE is a ..._TYPE node giving\n-   its data type.  */\n+/* Return a TYPE_DECL node suitable for the TYPE_STUB_DECL field of TYPE.\n+   NAME gives the name of the type to be used in the declaration.  */\n \n tree\n-create_type_stub_decl (tree type_name, tree type)\n+create_type_stub_decl (tree name, tree type)\n {\n-  tree type_decl = build_decl (input_location, TYPE_DECL, type_name, type);\n+  tree type_decl = build_decl (input_location, TYPE_DECL, name, type);\n   DECL_ARTIFICIAL (type_decl) = 1;\n   TYPE_ARTIFICIAL (type) = 1;\n   return type_decl;\n }\n \n-/* Return a TYPE_DECL node.  TYPE_NAME gives the name of the type and TYPE\n-   is a ..._TYPE node giving its data type.  ARTIFICIAL_P is true if the\n-   declaration was generated by the compiler.  DEBUG_INFO_P is true if we\n-   need to write debug information about this type.  GNAT_NODE is used for\n-   the position of the decl.  */\n+/* Return a TYPE_DECL node for TYPE.  NAME gives the name of the type to be\n+   used in the declaration.  ARTIFICIAL_P is true if the declaration was\n+   generated by the compiler.  DEBUG_INFO_P is true if we need to write\n+   debug information about this type.  GNAT_NODE is used for the position\n+   of the decl.  */\n \n tree\n-create_type_decl (tree type_name, tree type, bool artificial_p,\n-\t\t  bool debug_info_p, Node_Id gnat_node)\n+create_type_decl (tree name, tree type, bool artificial_p, bool debug_info_p,\n+\t\t  Node_Id gnat_node)\n {\n   enum tree_code code = TREE_CODE (type);\n-  bool named = TYPE_NAME (type) && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL;\n+  bool is_named\n+    = TYPE_NAME (type) && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL;\n   tree type_decl;\n \n   /* Only the builtin TYPE_STUB_DECL should be used for dummy types.  */\n   gcc_assert (!TYPE_IS_DUMMY_P (type));\n \n   /* If the type hasn't been named yet, we're naming it; preserve an existing\n      TYPE_STUB_DECL that has been attached to it for some purpose.  */\n-  if (!named && TYPE_STUB_DECL (type))\n+  if (!is_named && TYPE_STUB_DECL (type))\n     {\n       type_decl = TYPE_STUB_DECL (type);\n-      DECL_NAME (type_decl) = type_name;\n+      DECL_NAME (type_decl) = name;\n     }\n   else\n-    type_decl = build_decl (input_location, TYPE_DECL, type_name, type);\n+    type_decl = build_decl (input_location, TYPE_DECL, name, type);\n \n   DECL_ARTIFICIAL (type_decl) = artificial_p;\n   TYPE_ARTIFICIAL (type) = artificial_p;\n@@ -2293,7 +2293,7 @@ create_type_decl (tree type_name, tree type, bool artificial_p,\n      from multiple contexts, and \"type_decl\" references a copy of it: in such a\n      case, do not mess TYPE_STUB_DECL: we do not want to re-use the TYPE_DECL\n      with the mechanism above.  */\n-  if (!named && type != DECL_ORIGINAL_TYPE (type_decl))\n+  if (!is_named && type != DECL_ORIGINAL_TYPE (type_decl))\n     TYPE_STUB_DECL (type) = type_decl;\n \n   /* Do not generate debug info for UNCONSTRAINED_ARRAY_TYPE that the\n@@ -2306,8 +2306,8 @@ create_type_decl (tree type_name, tree type, bool artificial_p,\n \f\n /* Return a VAR_DECL or CONST_DECL node.\n \n-   VAR_NAME gives the name of the variable.  ASM_NAME is its assembler name\n-   (if provided).  TYPE is its data type (a GCC ..._TYPE node).  VAR_INIT is\n+   NAME gives the name of the variable.  ASM_NAME is its assembler name\n+   (if provided).  TYPE is its data type (a GCC ..._TYPE node).  INIT is\n    the GCC tree for an optional initial expression; NULL_TREE if none.\n \n    CONST_FLAG is true if this variable is constant, in which case we might\n@@ -2330,11 +2330,11 @@ create_type_decl (tree type_name, tree type, bool artificial_p,\n    GNAT_NODE is used for the position of the decl.  */\n \n tree\n-create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n-\t\t   bool const_flag, bool public_flag, bool extern_flag,\n-\t\t   bool static_flag, bool artificial_p, bool debug_info_p,\n-\t\t   bool const_decl_allowed_p, struct attrib *attr_list,\n-\t\t   Node_Id gnat_node)\n+create_var_decl (tree name, tree asm_name, tree type, tree init,\n+\t\t bool const_flag, bool public_flag, bool extern_flag,\n+\t\t bool static_flag, bool artificial_p, bool debug_info_p,\n+\t\t struct attrib *attr_list, Node_Id gnat_node,\n+\t\t bool const_decl_allowed_p)\n {\n   /* Whether the object has static storage duration, either explicitly or by\n      virtue of being declared at the global level.  */\n@@ -2345,12 +2345,12 @@ create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n      constant expression for initializing a static variable; otherwise, we\n      only check that it is constant.  */\n   const bool init_const\n-    = (var_init\n-       && gnat_types_compatible_p (type, TREE_TYPE (var_init))\n+    = (init\n+       && gnat_types_compatible_p (type, TREE_TYPE (init))\n        && (extern_flag || static_storage\n-\t   ? initializer_constant_valid_p (var_init, TREE_TYPE (var_init))\n+\t   ? initializer_constant_valid_p (init, TREE_TYPE (init))\n \t     != NULL_TREE\n-\t   : TREE_CONSTANT (var_init)));\n+\t   : TREE_CONSTANT (init)));\n \n   /* Whether we will make TREE_CONSTANT the DECL we produce here, in which\n      case the initializer may be used in lieu of the DECL node (as done in\n@@ -2367,7 +2367,7 @@ create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n     = build_decl (input_location,\n \t\t  (constant_p && const_decl_allowed_p\n \t\t   && !AGGREGATE_TYPE_P (type)) ? CONST_DECL : VAR_DECL,\n-\t\t  var_name, type);\n+\t\t  name, type);\n \n   /* If this is external, throw away any initializations (they will be done\n      elsewhere) unless this is a constant for which we would like to remain\n@@ -2376,17 +2376,17 @@ create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n      elaboration routine.  If we are just annotating types, throw away the\n      initialization if it isn't a constant.  */\n   if ((extern_flag && !constant_p)\n-      || (type_annotate_only && var_init && !TREE_CONSTANT (var_init)))\n-    var_init = NULL_TREE;\n+      || (type_annotate_only && init && !TREE_CONSTANT (init)))\n+    init = NULL_TREE;\n \n   /* At the global level, a non-constant initializer generates elaboration\n      statements.  Check that such statements are allowed, that is to say,\n      not violating a No_Elaboration_Code restriction.  */\n-  if (var_init && !init_const && global_bindings_p ())\n+  if (init && !init_const && global_bindings_p ())\n     Check_Elaboration_Code_Allowed (gnat_node);\n \n   /* Attach the initializer, if any.  */\n-  DECL_INITIAL (var_decl) = var_init;\n+  DECL_INITIAL (var_decl) = init;\n \n   /* Directly set some flags.  */\n   DECL_ARTIFICIAL (var_decl) = artificial_p;\n@@ -2421,8 +2421,8 @@ create_var_decl_1 (tree var_name, tree asm_name, tree type, tree var_init,\n       || (TREE_CODE (var_decl) == CONST_DECL && !optimize)\n       || (extern_flag\n \t  && constant_p\n-\t  && var_init\n-\t  && initializer_constant_valid_p (var_init, TREE_TYPE (var_init))\n+\t  && init\n+\t  && initializer_constant_valid_p (init, TREE_TYPE (init))\n \t     != null_pointer_node))\n     DECL_IGNORED_P (var_decl) = 1;\n \n@@ -2484,34 +2484,33 @@ aggregate_type_contains_array_p (tree type)\n     }\n }\n \n-/* Return a FIELD_DECL node.  FIELD_NAME is the field's name, FIELD_TYPE is\n-   its type and RECORD_TYPE is the type of the enclosing record.  If SIZE is\n-   nonzero, it is the specified size of the field.  If POS is nonzero, it is\n-   the bit position.  PACKED is 1 if the enclosing record is packed, -1 if it\n-   has Component_Alignment of Storage_Unit.  If ADDRESSABLE is nonzero, it\n+/* Return a FIELD_DECL node.  NAME is the field's name, TYPE is its type and\n+   RECORD_TYPE is the type of the enclosing record.  If SIZE is nonzero, it\n+   is the specified size of the field.  If POS is nonzero, it is the bit\n+   position.  PACKED is 1 if the enclosing record is packed, -1 if it has\n+   Component_Alignment of Storage_Unit.  If ADDRESSABLE is nonzero, it\n    means we are allowed to take the address of the field; if it is negative,\n    we should not make a bitfield, which is used by make_aligning_type.  */\n \n tree\n-create_field_decl (tree field_name, tree field_type, tree record_type,\n-                   tree size, tree pos, int packed, int addressable)\n+create_field_decl (tree name, tree type, tree record_type, tree size, tree pos,\n+\t\t   int packed, int addressable)\n {\n-  tree field_decl = build_decl (input_location,\n-\t\t\t\tFIELD_DECL, field_name, field_type);\n+  tree field_decl = build_decl (input_location, FIELD_DECL, name, type);\n \n   DECL_CONTEXT (field_decl) = record_type;\n-  TREE_READONLY (field_decl) = TYPE_READONLY (field_type);\n+  TREE_READONLY (field_decl) = TYPE_READONLY (type);\n \n   /* If FIELD_TYPE is BLKmode, we must ensure this is aligned to at least a\n      byte boundary since GCC cannot handle less-aligned BLKmode bitfields.\n      Likewise for an aggregate without specified position that contains an\n      array, because in this case slices of variable length of this array\n      must be handled by GCC and variable-sized objects need to be aligned\n      to at least a byte boundary.  */\n-  if (packed && (TYPE_MODE (field_type) == BLKmode\n+  if (packed && (TYPE_MODE (type) == BLKmode\n \t\t || (!pos\n-\t\t     && AGGREGATE_TYPE_P (field_type)\n-\t\t     && aggregate_type_contains_array_p (field_type))))\n+\t\t     && AGGREGATE_TYPE_P (type)\n+\t\t     && aggregate_type_contains_array_p (type))))\n     DECL_ALIGN (field_decl) = BITS_PER_UNIT;\n \n   /* If a size is specified, use it.  Otherwise, if the record type is packed\n@@ -2523,8 +2522,8 @@ create_field_decl (tree field_name, tree field_type, tree record_type,\n     size = convert (bitsizetype, size);\n   else if (packed == 1)\n     {\n-      size = rm_size (field_type);\n-      if (TYPE_MODE (field_type) == BLKmode)\n+      size = rm_size (type);\n+      if (TYPE_MODE (type) == BLKmode)\n \tsize = round_up (size, BITS_PER_UNIT);\n     }\n \n@@ -2546,22 +2545,22 @@ create_field_decl (tree field_name, tree field_type, tree record_type,\n   if (addressable >= 0\n       && size\n       && TREE_CODE (size) == INTEGER_CST\n-      && TREE_CODE (TYPE_SIZE (field_type)) == INTEGER_CST\n-      && (!tree_int_cst_equal (size, TYPE_SIZE (field_type))\n-\t  || (pos && !value_factor_p (pos, TYPE_ALIGN (field_type)))\n+      && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n+      && (!tree_int_cst_equal (size, TYPE_SIZE (type))\n+\t  || (pos && !value_factor_p (pos, TYPE_ALIGN (type)))\n \t  || packed\n \t  || (TYPE_ALIGN (record_type) != 0\n-\t      && TYPE_ALIGN (record_type) < TYPE_ALIGN (field_type))))\n+\t      && TYPE_ALIGN (record_type) < TYPE_ALIGN (type))))\n     {\n       DECL_BIT_FIELD (field_decl) = 1;\n       DECL_SIZE (field_decl) = size;\n       if (!packed && !pos)\n \t{\n \t  if (TYPE_ALIGN (record_type) != 0\n-\t      && TYPE_ALIGN (record_type) < TYPE_ALIGN (field_type))\n+\t      && TYPE_ALIGN (record_type) < TYPE_ALIGN (type))\n \t    DECL_ALIGN (field_decl) = TYPE_ALIGN (record_type);\n \t  else\n-\t    DECL_ALIGN (field_decl) = TYPE_ALIGN (field_type);\n+\t    DECL_ALIGN (field_decl) = TYPE_ALIGN (type);\n \t}\n     }\n \n@@ -2574,14 +2573,14 @@ create_field_decl (tree field_name, tree field_type, tree record_type,\n   {\n     unsigned int bit_align\n       = (DECL_BIT_FIELD (field_decl) ? 1\n-\t : packed && TYPE_MODE (field_type) != BLKmode ? BITS_PER_UNIT : 0);\n+\t : packed && TYPE_MODE (type) != BLKmode ? BITS_PER_UNIT : 0);\n \n     if (bit_align > DECL_ALIGN (field_decl))\n       DECL_ALIGN (field_decl) = bit_align;\n-    else if (!bit_align && TYPE_ALIGN (field_type) > DECL_ALIGN (field_decl))\n+    else if (!bit_align && TYPE_ALIGN (type) > DECL_ALIGN (field_decl))\n       {\n-\tDECL_ALIGN (field_decl) = TYPE_ALIGN (field_type);\n-\tDECL_USER_ALIGN (field_decl) = TYPE_USER_ALIGN (field_type);\n+\tDECL_ALIGN (field_decl) = TYPE_ALIGN (type);\n+\tDECL_USER_ALIGN (field_decl) = TYPE_USER_ALIGN (type);\n       }\n   }\n \n@@ -2619,48 +2618,47 @@ create_field_decl (tree field_name, tree field_type, tree record_type,\n      of a copy.  This is the case for true bitfields, but the DECL_BIT_FIELD\n      value we have at this point is not accurate enough, so we don't account\n      for this here and let finish_record_type decide.  */\n-  if (!addressable && !type_for_nonaliased_component_p (field_type))\n+  if (!addressable && !type_for_nonaliased_component_p (type))\n     addressable = 1;\n \n   DECL_NONADDRESSABLE_P (field_decl) = !addressable;\n \n   return field_decl;\n }\n \f\n-/* Return a PARM_DECL node.  PARAM_NAME is the name of the parameter and\n-   PARAM_TYPE is its type.  READONLY is true if the parameter is readonly\n-   (either an In parameter or an address of a pass-by-ref parameter).  */\n+/* Return a PARM_DECL node.  NAME is the name of the parameter and TYPE is\n+   its type.  READONLY is true if the parameter is readonly (either an In\n+   parameter or an address of a pass-by-ref parameter).  */\n \n tree\n-create_param_decl (tree param_name, tree param_type, bool readonly)\n+create_param_decl (tree name, tree type, bool readonly)\n {\n-  tree param_decl = build_decl (input_location,\n-\t\t\t\tPARM_DECL, param_name, param_type);\n+  tree param_decl = build_decl (input_location, PARM_DECL, name, type);\n \n   /* Honor TARGET_PROMOTE_PROTOTYPES like the C compiler, as not doing so\n      can lead to various ABI violations.  */\n   if (targetm.calls.promote_prototypes (NULL_TREE)\n-      && INTEGRAL_TYPE_P (param_type)\n-      && TYPE_PRECISION (param_type) < TYPE_PRECISION (integer_type_node))\n+      && INTEGRAL_TYPE_P (type)\n+      && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node))\n     {\n       /* We have to be careful about biased types here.  Make a subtype\n \t of integer_type_node with the proper biasing.  */\n-      if (TREE_CODE (param_type) == INTEGER_TYPE\n-\t  && TYPE_BIASED_REPRESENTATION_P (param_type))\n+      if (TREE_CODE (type) == INTEGER_TYPE\n+\t  && TYPE_BIASED_REPRESENTATION_P (type))\n \t{\n \t  tree subtype\n \t    = make_unsigned_type (TYPE_PRECISION (integer_type_node));\n \t  TREE_TYPE (subtype) = integer_type_node;\n \t  TYPE_BIASED_REPRESENTATION_P (subtype) = 1;\n-\t  SET_TYPE_RM_MIN_VALUE (subtype, TYPE_MIN_VALUE (param_type));\n-\t  SET_TYPE_RM_MAX_VALUE (subtype, TYPE_MAX_VALUE (param_type));\n-\t  param_type = subtype;\n+\t  SET_TYPE_RM_MIN_VALUE (subtype, TYPE_MIN_VALUE (type));\n+\t  SET_TYPE_RM_MAX_VALUE (subtype, TYPE_MAX_VALUE (type));\n+\t  type = subtype;\n \t}\n       else\n-\tparam_type = integer_type_node;\n+\ttype = integer_type_node;\n     }\n \n-  DECL_ARG_TYPE (param_decl) = param_type;\n+  DECL_ARG_TYPE (param_decl) = type;\n   TREE_READONLY (param_decl) = readonly;\n   return param_decl;\n }\n@@ -3015,14 +3013,14 @@ potential_alignment_gap (tree prev_field, tree curr_field, tree offset)\n   return true;\n }\n \n-/* Return a LABEL_DECL with LABEL_NAME.  GNAT_NODE is used for the position\n-   of the decl.  */\n+/* Return a LABEL_DECL with NAME.  GNAT_NODE is used for the position of\n+   the decl.  */\n \n tree\n-create_label_decl (tree label_name, Node_Id gnat_node)\n+create_label_decl (tree name, Node_Id gnat_node)\n {\n   tree label_decl\n-    = build_decl (input_location, LABEL_DECL, label_name, void_type_node);\n+    = build_decl (input_location, LABEL_DECL, name, void_type_node);\n \n   DECL_MODE (label_decl) = VOIDmode;\n \n@@ -3032,10 +3030,10 @@ create_label_decl (tree label_name, Node_Id gnat_node)\n   return label_decl;\n }\n \f\n-/* Return a FUNCTION_DECL node.  SUBPROG_NAME is the name of the subprogram,\n-   ASM_NAME is its assembler name, SUBPROG_TYPE is its type (a FUNCTION_TYPE\n-   node), PARAM_DECL_LIST is the list of the subprogram arguments (a list of\n-   PARM_DECL nodes chained through the DECL_CHAIN field).\n+/* Return a FUNCTION_DECL node.  NAME is the name of the subprogram, ASM_NAME\n+   its assembler name, TYPE its type (a FUNCTION_TYPE node), PARAM_DECL_LIST\n+   the list of its parameters (a list of PARM_DECL nodes chained through the\n+   DECL_CHAIN field).\n \n    INLINE_STATUS, PUBLIC_FLAG, EXTERN_FLAG and ATTR_LIST are used to set the\n    appropriate fields in the FUNCTION_DECL.\n@@ -3047,16 +3045,14 @@ create_label_decl (tree label_name, Node_Id gnat_node)\n    GNAT_NODE is used for the position of the decl.  */\n \n tree\n-create_subprog_decl (tree subprog_name, tree asm_name, tree subprog_type,\n- \t\t     tree param_decl_list, enum inline_status_t inline_status,\n-\t\t     bool public_flag, bool extern_flag, bool artificial_p,\n-\t\t     bool debug_info_p, struct attrib *attr_list,\n-\t\t     Node_Id gnat_node)\n+create_subprog_decl (tree name, tree asm_name, tree type, tree param_decl_list,\n+\t\t     enum inline_status_t inline_status, bool public_flag,\n+\t\t     bool extern_flag, bool artificial_p, bool debug_info_p,\n+\t\t     struct attrib *attr_list, Node_Id gnat_node)\n {\n-  tree subprog_decl = build_decl (input_location, FUNCTION_DECL, subprog_name,\n-\t\t\t\t  subprog_type);\n-  tree result_decl = build_decl (input_location, RESULT_DECL, NULL_TREE,\n-\t\t\t\t TREE_TYPE (subprog_type));\n+  tree subprog_decl = build_decl (input_location, FUNCTION_DECL, name, type);\n+  tree result_decl\n+    = build_decl (input_location, RESULT_DECL, NULL_TREE, TREE_TYPE (type));\n   DECL_ARGUMENTS (subprog_decl) = param_decl_list;\n \n   DECL_ARTIFICIAL (subprog_decl) = artificial_p;\n@@ -3093,13 +3089,13 @@ create_subprog_decl (tree subprog_name, tree asm_name, tree subprog_type,\n     DECL_IGNORED_P (subprog_decl) = 1;\n \n   TREE_PUBLIC (subprog_decl) = public_flag;\n-  TREE_READONLY (subprog_decl) = TYPE_READONLY (subprog_type);\n-  TREE_THIS_VOLATILE (subprog_decl) = TYPE_VOLATILE (subprog_type);\n-  TREE_SIDE_EFFECTS (subprog_decl) = TYPE_VOLATILE (subprog_type);\n+  TREE_READONLY (subprog_decl) = TYPE_READONLY (type);\n+  TREE_THIS_VOLATILE (subprog_decl) = TYPE_VOLATILE (type);\n+  TREE_SIDE_EFFECTS (subprog_decl) = TYPE_VOLATILE (type);\n \n   DECL_ARTIFICIAL (result_decl) = 1;\n   DECL_IGNORED_P (result_decl) = 1;\n-  DECL_BY_REFERENCE (result_decl) = TREE_ADDRESSABLE (subprog_type);\n+  DECL_BY_REFERENCE (result_decl) = TREE_ADDRESSABLE (type);\n   DECL_RESULT (subprog_decl) = result_decl;\n \n   process_attributes (&subprog_decl, &attr_list, true, gnat_node);"}]}