{"sha": "747380f47da0da6c11fd5262ac428bb53433ea19", "node_id": "C_kwDOANBUbNoAKDc0NzM4MGY0N2RhMGRhNmMxMWZkNTI2MmFjNDI4YmI1MzQzM2VhMTk", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-12-09T14:40:15Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-12-09T14:40:15Z"}, "message": "pch: Add support for relocation of the PCH data [PR71934]\n\nThe following patch adds support for relocation of the PCH blob on PCH\nrestore if we don't manage to get the preferred map slot for it.\nThe GTY stuff knows where all the pointers are, after all it relocates\nit once during PCH save from the addresses where it was initially allocated\nto addresses in the preferred map slot.\nBut, if we were to do it solely using GTY info upon PCH restore, we'd need\nanother set of GTY functions, which I think would make it less maintainable\nand I think it would also be more costly at PCH restore time.  Those\nfunctions would need to call something to add bias to pointers that haven't\nbeen marked yet and make sure not to add bias to any pointer twice.\n\nSo, this patch instead builds a relocation table (sorted list of addresses\nin the blob which needs relocation) at PCH save time, stores it in a very\ncompact form into the gch file and upon restore, adjusts pointers in GTY\nroots (that is right away in the root structures) and the addresses in the\nrelocation table.\nThe cost on stdc++.gch/O2g.gch (previously 85MB large) is about 3% file size\ngrowth, there are 2.5 million pointers that need relocation in the gch blob\nand the relocation table uses uleb128 for address deltas and needs ~1.01 bytes\nfor one address that needs relocation, and about 20% compile time during\nPCH save (I think it is mainly because of the need to qsort those 2.5\nmillion pointers).  On PCH restore, if it doesn't need relocation (the usual\ncase), it is just an extra fread of sizeof (size_t) data and fseek\n(in my tests real time on vanilla tree for #include <bits/stdc++.h> CU\nwas ~0.175s and with the patch but no relocation ~0.173s), while if it needs\nrelocation it took ~0.193s, i.e. 11.5% slower.\nWithout PCH that\n #include <bits/stdc++.h>\n int i;\ntestcase compiles with -O2 -g in ~1.199s, i.e. 6.2 times slower than PCH with\nrelocation and 6.9 times than PCH without relocation.\n\nThe discovery of the pointers in the blob that need relocation is done\nin the relocate_ptrs hook which does the pointer relocation during PCH save.\nUnfortunately, I had to make one change to the gengtype stuff due to the\nnested_ptr feature of GTY, which some libcpp headers and stringpool.c use.\nThe relocate_ptrs hook had 2 arguments, pointer to the pointer and a cookie.\nWhen relocate_ptrs is done, in most cases it is called solely on the\nsubfields of the current object, so e.g.\n          if ((void *)(x) == this_obj)\n            op (&((*x).u.fld[0].rt_rtx), cookie);\nso relocate_ptrs can assert that ptr_p is within the\nstate->ptrs[state->ptrs_i]->obj ..\nstate->ptrs[state->ptrs_i]->obj+state->ptrs[state->ptrs_i]->size-sizeof(void*)\nrange and compute from that the address in the blob which will need\nrelocation (state->ptrs[state->ptrs_i]->new_addr is the new address\ngiven to it and ptr_p-state->ptrs[state->ptrs_i]->obj is the relative\noffset.  Unfortunately, for nested_ptr gengtype emits something like:\n      {\n        union tree_node * x0 =\n          ((*x).val.node.node) ? HT_IDENT_TO_GCC_IDENT (HT_NODE (((*x).val.node.node))) : NULL;\n        if ((void *)(x) == this_obj)\n          op (&(x0), cookie);\n        (*x).val.node.node = (x0) ? CPP_HASHNODE (GCC_IDENT_TO_HT_IDENT ((x0))) : NULL;\n      }\nso relocate_ptrs is called with an address of some temporary variable and\nso doesn't know where the pointer will finally be.\nSo, I've added another argument to relocate_ptrs (and to\ngt_pointer_operator).  For the most common case I pass NULL as the new middle\nargument to that function, first one remains pointer to the pointer that\nneeds adjustment and last the cookie.  The NULL seems to be cheap to compute\nand short in the gt*.[ch] files and stands for ptr_p is an address within\nthe this_obj's range, remember its address.  For the nested_ptr case, the\nnew middle argument contains actual address of the pointer that might need\nto be relocated, so instead of the above\n          op (&(x0), &((*x).val.node.node), cookie);\nin there.  And finally, e.g. for the reorder case I need a way to tell\nrestore_ptrs to ignore a particular address for the relocation purposes\nand only treat it the old way.  I've used for that the case when\nthe first and second arguments are equal.\n\nIn order to enable support for mapping PCH as fallback at different\naddresses than the preferred ones, a small change is needed to the\nhost pch_use_address hooks.  One change I've done to all of them is\nthe change of the type of the first argument from void * to void *&,\nsuch that the actual address can be told to the callers (or shall I\ninstead use void **?), but another change that still needs to be done\nin them if they want the relocation is actually not fail if they couldn't\nget a preferred address, but instead modify what the first argument\nrefers to.  I've done that only for host-linux.c and Iain is testing\nsimilar change for host-darwin.c.  Didn't change hpux, netbsd, openbsd,\nsolaris, mingw32 or the fallbacks because I can't test those.\n\nTested also with the:\n--- gcc/config/host-linux.c.jj  2021-12-06 22:22:42.007777367 +0100\n+++ gcc/config/host-linux.c     2021-12-07 00:21:53.052674040 +0100\n@@ -191,6 +191,8 @@ linux_gt_pch_use_address (void *&base, s\n   if (size == 0)\n     return -1;\n\n+base = (char *) base + ((size + 8191) & (size_t) -4096);\n+\n   /* Try to map the file with MAP_PRIVATE.  */\n   addr = mmap (base, size, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, offset);\n\nhack which forces all PCH restores to be relocated.  An earlier version of the\npatch has been also regrest with base = (char *) base + 16384; in that spot,\nso both relocation to a non-overlapping spot and to an overlapping spot have\nbeen tested.\n\n2021-12-09  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR pch/71934\n\t* coretypes.h (gt_pointer_operator): Use 3 pointer arguments instead\n\tof two.\n\t* gengtype.c (struct walk_type_data): Add in_nested_ptr argument.\n\t(walk_type): Temporarily set d->in_nested_ptr around nested_ptr\n\thandling.\n\t(write_types_local_user_process_field): Pass a new middle pointer\n\tto gt_pointer_operator op calls, if d->in_nested_ptr pass there\n\taddress of d->prev_val[2], otherwise NULL.\n\t(write_types_local_process_field): Likewise.\n\t* ggc-common.c (relocate_ptrs): Add real_ptr_p argument.  If equal\n\tto ptr_p, do nothing, otherwise if NULL remember ptr_p's\n\tor if non-NULL real_ptr_p's corresponding new address in\n\treloc_addrs_vec.\n\t(reloc_addrs_vec): New variable.\n\t(compare_ptr, read_uleb128, write_uleb128): New functions.\n\t(gt_pch_save): When iterating over objects through relocate_ptrs,\n\tsave current i into state.ptrs_i.  Sort reloc_addrs_vec and emit\n\tit as uleb128 of differences between pointer addresses into the\n\tPCH file.\n\t(gt_pch_restore): Allow restoring of PCH to a different address\n\tthan the preferred one, in that case adjust global pointers by bias\n\tand also adjust by bias addresses read from the relocation table\n\tas uleb128 differences.  Otherwise fseek over it.  Perform\n\tgt_pch_restore_stringpool only after adjusting callbacks and for\n\tcallback adjustments also take into account the bias.\n\t(default_gt_pch_use_address): Change type of first argument from\n\tvoid * to void *&.\n\t(mmap_gt_pch_use_address): Likewise.\n\t* ggc-tests.c (gt_pch_nx): Pass NULL as new middle argument to op.\n\t* hash-map.h (hash_map::pch_nx_helper): Likewise.\n\t(gt_pch_nx): Likewise.\n\t* hash-set.h (gt_pch_nx): Likewise.\n\t* hash-table.h (gt_pch_nx): Likewise.\n\t* hash-traits.h (ggc_remove::pch_nx): Likewise.\n\t* hosthooks-def.h (default_gt_pch_use_address): Change type of first\n\targument from void * to void *&.\n\t(mmap_gt_pch_use_address): Likewise.\n\t* hosthooks.h (struct host_hooks): Change type of first argument of\n\tgt_pch_use_address hook from void * to void *&.\n\t* machmode.h (gt_pch_nx): Expect a callback with 3 pointers instead of\n\ttwo in the middle argument.\n\t* poly-int.h (gt_pch_nx): Likewise.\n\t* stringpool.c (gt_pch_nx): Pass NULL as new middle argument to op.\n\t* tree-cfg.c (gt_pch_nx): Likewise, except for LOCATION_BLOCK pass\n\tthe same &(block) twice.\n\t* value-range.h (gt_pch_nx): Pass NULL as new middle argument to op.\n\t* vec.h (gt_pch_nx): Likewise.\n\t* wide-int.h (gt_pch_nx): Likewise.\n\t* config/host-darwin.c (darwin_gt_pch_use_address): Change type of\n\tfirst argument from void * to void *&.\n\t* config/host-darwin.h (darwin_gt_pch_use_address): Likewise.\n\t* config/host-hpux.c (hpux_gt_pch_use_address): Likewise.\n\t* config/host-linux.c (linux_gt_pch_use_address): Likewise.  If\n\tit couldn't succeed to mmap at the preferred location, set base\n\tto the actual one.  Update addr in the manual reading loop instead of\n\tbase.\n\t* config/host-netbsd.c (netbsd_gt_pch_use_address): Change type of\n\tfirst argument from void * to void *&.\n\t* config/host-openbsd.c (openbsd_gt_pch_use_address): Likewise.\n\t* config/host-solaris.c (sol_gt_pch_use_address): Likewise.\n\t* config/i386/host-mingw32.c (mingw32_gt_pch_use_address): Likewise.\n\t* config/rs6000/rs6000-gen-builtins.c (write_init_file): Pass NULL\n\tas new middle argument to op in the generated code.\n\t* doc/gty.texi: Adjust samples for the addition of middle pointer\n\tto gt_pointer_operator callback.\ngcc/ada/\n\t* gcc-interface/decl.c (gt_pch_nx): Pass NULL as new middle argument\n\tto op.\ngcc/c-family/\n\t* c-pch.c (c_common_no_more_pch): Pass a temporary void * var\n\twith NULL value instead of NULL to host_hooks.gt_pch_use_address.\ngcc/c/\n\t* c-decl.c (resort_field_decl_cmp): Pass the same pointer twice\n\tto resort_data.new_value.\ngcc/cp/\n\t* module.cc (nop): Add another void * argument.\n\t* name-lookup.c (resort_member_name_cmp): Pass the same pointer twice\n\tto resort_data.new_value.", "tree": {"sha": "ea69fb7c9bce09b0ee244c7e956be39df5b32f01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ea69fb7c9bce09b0ee244c7e956be39df5b32f01"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/747380f47da0da6c11fd5262ac428bb53433ea19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/747380f47da0da6c11fd5262ac428bb53433ea19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/747380f47da0da6c11fd5262ac428bb53433ea19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/747380f47da0da6c11fd5262ac428bb53433ea19/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5791bf7a0a7705be6c3989c445e7c739220f3290", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5791bf7a0a7705be6c3989c445e7c739220f3290", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5791bf7a0a7705be6c3989c445e7c739220f3290"}], "stats": {"total": 340, "additions": 268, "deletions": 72}, "files": [{"sha": "af6b6bd14d422eacc4e50280d809601ff6d2174e", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -171,7 +171,7 @@ gt_pch_nx (Entity_Id &)\n void\n gt_pch_nx (Entity_Id *x, gt_pointer_operator op, void *cookie)\n {\n-  op (x, cookie);\n+  op (x, NULL, cookie);\n }\n \n struct dummy_type_hasher : ggc_cache_ptr_hash<tree_entity_vec_map>"}, {"sha": "73a846d95412c9c29a82f55de5aefe48992841d0", "filename": "gcc/c-family/c-pch.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fc-family%2Fc-pch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fc-family%2Fc-pch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pch.c?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -375,7 +375,8 @@ c_common_no_more_pch (void)\n   if (cpp_get_callbacks (parse_in)->valid_pch)\n     {\n       cpp_get_callbacks (parse_in)->valid_pch = NULL;\n-      host_hooks.gt_pch_use_address (NULL, 0, -1, 0);\n+      void *addr = NULL;\n+      host_hooks.gt_pch_use_address (addr, 0, -1, 0);\n     }\n }\n "}, {"sha": "9e45798ca4fd8cb89b317f24885fa1c8d6abe8d9", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -9040,8 +9040,8 @@ resort_field_decl_cmp (const void *x_p, const void *y_p)\n   {\n     tree d1 = DECL_NAME (*x);\n     tree d2 = DECL_NAME (*y);\n-    resort_data.new_value (&d1, resort_data.cookie);\n-    resort_data.new_value (&d2, resort_data.cookie);\n+    resort_data.new_value (&d1, &d1, resort_data.cookie);\n+    resort_data.new_value (&d2, &d2, resort_data.cookie);\n     if (d1 < d2)\n       return -1;\n   }"}, {"sha": "d3c2858c9975e29c9792443fdd3152e2589d29c3", "filename": "gcc/config/host-darwin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fconfig%2Fhost-darwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fconfig%2Fhost-darwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fhost-darwin.c?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -136,7 +136,7 @@ darwin_gt_pch_get_address (size_t sz, int fd)\n    fail with -1.  */\n \n int\n-darwin_gt_pch_use_address (void *addr, size_t sz, int fd, size_t off)\n+darwin_gt_pch_use_address (void *&addr, size_t sz, int fd, size_t off)\n {\n   void *mapped_addr;\n "}, {"sha": "f3a477e883732ab6aa42299adad2bd4362c9c918", "filename": "gcc/config/host-darwin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fconfig%2Fhost-darwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fconfig%2Fhost-darwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fhost-darwin.h?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -18,7 +18,7 @@\n    <http://www.gnu.org/licenses/>.  */\n \n extern void * darwin_gt_pch_get_address (size_t sz, int fd);\n-extern int darwin_gt_pch_use_address (void *addr, size_t sz, int fd, \n+extern int darwin_gt_pch_use_address (void *&addr, size_t sz, int fd, \n \t\t\t\t      size_t off);\n \n #undef HOST_HOOKS_GT_PCH_GET_ADDRESS"}, {"sha": "796f501ebfb661872adc07511d7d513f47a2bfe7", "filename": "gcc/config/host-hpux.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fconfig%2Fhost-hpux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fconfig%2Fhost-hpux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fhost-hpux.c?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -24,7 +24,7 @@\n #include \"hosthooks-def.h\"\n \n static void *hpux_gt_pch_get_address (size_t, int);\n-static int hpux_gt_pch_use_address (void *, size_t, int, size_t);\n+static int hpux_gt_pch_use_address (void *&, size_t, int, size_t);\n \n #undef HOST_HOOKS_GT_PCH_GET_ADDRESS\n #define HOST_HOOKS_GT_PCH_GET_ADDRESS hpux_gt_pch_get_address\n@@ -78,7 +78,7 @@ hpux_gt_pch_get_address (size_t size, int fd)\n    little else we can do given the current PCH implementation.  */\n \n static int\n-hpux_gt_pch_use_address (void *base, size_t size, int fd, size_t offset)\n+hpux_gt_pch_use_address (void *&base, size_t size, int fd, size_t offset)\n {\n   void *addr;\n "}, {"sha": "0481ecff3f20a02269c79f12ba9b9a6b6df28861", "filename": "gcc/config/host-linux.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fconfig%2Fhost-linux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fconfig%2Fhost-linux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fhost-linux.c?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -181,7 +181,7 @@ linux_gt_pch_get_address (size_t size, int fd)\n    little else we can do given the current PCH implementation.  */\n \n static int\n-linux_gt_pch_use_address (void *base, size_t size, int fd, size_t offset)\n+linux_gt_pch_use_address (void *&base, size_t size, int fd, size_t offset)\n {\n   void *addr;\n \n@@ -204,24 +204,22 @@ linux_gt_pch_use_address (void *base, size_t size, int fd, size_t offset)\n   addr = mmap (base, size, PROT_READ | PROT_WRITE,\n \t       MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n \n-  if (addr != base)\n-    {\n-      if (addr != (void *) MAP_FAILED)\n-        munmap (addr, size);\n-      return -1;\n-    }\n+  if (addr == (void *) MAP_FAILED)\n+    return -1;\n \n   if (lseek (fd, offset, SEEK_SET) == (off_t)-1)\n     return -1;\n \n+  base = addr;\n+\n   while (size)\n     {\n       ssize_t nbytes;\n \n-      nbytes = read (fd, base, MIN (size, (size_t)-1 >> 1));\n+      nbytes = read (fd, addr, MIN (size, (size_t)-1 >> 1));\n       if (nbytes <= 0)\n         return -1;\n-      base = (char *) base + nbytes;\n+      addr = (char *) addr + nbytes;\n       size -= nbytes;\n     }\n "}, {"sha": "32f86c83bb2b578cf5682e94c0065b45ad514858", "filename": "gcc/config/host-netbsd.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fconfig%2Fhost-netbsd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fconfig%2Fhost-netbsd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fhost-netbsd.c?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -66,7 +66,7 @@ netbsd_gt_pch_get_address (size_t size, int fd)\n    mapping the data at BASE, -1 if we couldn't.  */\n \n static int\n-netbsd_gt_pch_use_address (void *base, size_t size, int fd, size_t offset)\n+netbsd_gt_pch_use_address (void *&base, size_t size, int fd, size_t offset)\n {\n   void *addr;\n "}, {"sha": "f7b90432b55407f86ec380ecf1167026e39d875e", "filename": "gcc/config/host-openbsd.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fconfig%2Fhost-openbsd.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fconfig%2Fhost-openbsd.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fhost-openbsd.c?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -66,7 +66,7 @@ openbsd_gt_pch_get_address (size_t size, int fd)\n    mapping the data at BASE, -1 if we couldn't.  */\n \n static int\n-openbsd_gt_pch_use_address (void *base, size_t size, int fd, size_t offset)\n+openbsd_gt_pch_use_address (void *&base, size_t size, int fd, size_t offset)\n {\n   void *addr;\n "}, {"sha": "b08cf513ec5be75c32c6479c1d3a15c5595ba3fa", "filename": "gcc/config/host-solaris.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fconfig%2Fhost-solaris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fconfig%2Fhost-solaris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fhost-solaris.c?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -105,7 +105,7 @@ sol_gt_pch_get_address (size_t size, int fd)\n    mapping the data at BASE, -1 if we couldn't.  */\n \n static int\n-sol_gt_pch_use_address (void *base, size_t size, int fd, size_t offset)\n+sol_gt_pch_use_address (void *&base, size_t size, int fd, size_t offset)\n {\n   void *addr;\n "}, {"sha": "a182563bf27e865dce3977dcab777d376da7d3f7", "filename": "gcc/config/i386/host-mingw32.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fconfig%2Fi386%2Fhost-mingw32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fconfig%2Fi386%2Fhost-mingw32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fhost-mingw32.c?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -32,7 +32,7 @@\n #include <stdlib.h>\n \n static void * mingw32_gt_pch_get_address (size_t, int);\n-static int mingw32_gt_pch_use_address (void *, size_t, int, size_t);\n+static int mingw32_gt_pch_use_address (void *&, size_t, int, size_t);\n static size_t mingw32_gt_pch_alloc_granularity (void);\n \n #undef HOST_HOOKS_GT_PCH_GET_ADDRESS\n@@ -118,7 +118,7 @@ mingw32_gt_pch_get_address (size_t size, int)\n    if the memory is allocated but the data not loaded, return 1 if done.  */\n \n static int\n-mingw32_gt_pch_use_address (void *addr, size_t size, int fd,\n+mingw32_gt_pch_use_address (void *&addr, size_t size, int fd,\n \t\t\t    size_t offset)\n {\n   void * mmap_addr;"}, {"sha": "34ab70f7609daf8c55348527ef487dbf35ddb429", "filename": "gcc/config/rs6000/rs6000-gen-builtins.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -2886,7 +2886,7 @@ write_init_file (void)\n \t   \"void gt_pch_nx (bifdata *bd, gt_pointer_operator op, \"\n \t   \"void *cookie)\\n\");\n   fprintf (init_file,\n-\t   \"{\\n  op(&(bd->fntype), cookie);\\n}\\n\\n\");\n+\t   \"{\\n  op(&(bd->fntype), NULL, cookie);\\n}\\n\\n\");\n   fprintf (init_file,\n \t   \"void gt_ggc_mx (ovlddata *od)\\n\");\n   fprintf (init_file,\n@@ -2899,7 +2899,7 @@ write_init_file (void)\n \t   \"void gt_pch_nx (ovlddata *od, gt_pointer_operator op, \"\n \t   \"void *cookie)\\n\");\n   fprintf (init_file,\n-\t   \"{\\n  op(&(od->fntype), cookie);\\n}\\n\");\n+\t   \"{\\n  op(&(od->fntype), NULL, cookie);\\n}\\n\");\n \n   return 1;\n }"}, {"sha": "5d0fc1d915db0ffa0907ed2e3d9932a36d7cda55", "filename": "gcc/coretypes.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -442,8 +442,10 @@ enum optimize_size_level\n };\n \n /* Support for user-provided GGC and PCH markers.  The first parameter\n-   is a pointer to a pointer, the second a cookie.  */\n-typedef void (*gt_pointer_operator) (void *, void *);\n+   is a pointer to a pointer, the second either NULL if the pointer to\n+   pointer points into a GC object or the actual pointer address if\n+   the first argument points to a temporary and the third a cookie.  */\n+typedef void (*gt_pointer_operator) (void *, void *, void *);\n \n #if !defined (HAVE_UCHAR)\n typedef unsigned char uchar;"}, {"sha": "9266055cd92472734cfaaddfb86eed4b73723fe1", "filename": "gcc/cp/module.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fcp%2Fmodule.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fcp%2Fmodule.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmodule.cc?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -11750,7 +11750,7 @@ trees_out::mark_class_def (tree defn)\n /* Nop sorting, needed for resorting the member vec.  */\n \n static void\n-nop (void *, void *)\n+nop (void *, void *, void *)\n {\n }\n "}, {"sha": "229ba45d901dac37c9392bec88f7293d84b7a75d", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -2123,8 +2123,8 @@ resort_member_name_cmp (const void *a_p, const void *b_p)\n   tree name_a = OVL_NAME (a);\n   tree name_b = OVL_NAME (b);\n \n-  resort_data.new_value (&name_a, resort_data.cookie);\n-  resort_data.new_value (&name_b, resort_data.cookie);\n+  resort_data.new_value (&name_a, &name_a, resort_data.cookie);\n+  resort_data.new_value (&name_b, &name_b, resort_data.cookie);\n \n   gcc_checking_assert (name_a != name_b);\n "}, {"sha": "5a84d9a48db67ab275f3a6c79398e8acb566ce28", "filename": "gcc/doc/gty.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fdoc%2Fgty.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fdoc%2Fgty.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgty.texi?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -483,7 +483,7 @@ void gt_pch_nx (my_struct *p)\n void gt_pch_nx (my_struct *p, gt_pointer_operator op, void *cookie)\n @{\n   /* For every field 'fld', call the given pointer operator.  */\n-  op (&(tp->fld), cookie);\n+  op (&(tp->fld), NULL, cookie);\n @}\n @end smallexample\n \n@@ -536,7 +536,7 @@ void gt_pch_nx (TP<T *> *tp, gt_pointer_operator op, void *cookie)\n @{\n   /* For every field 'fld' of 'tp' with type 'T *', call the given\n      pointer operator.  */\n-  op (&(tp->fld), cookie);\n+  op (&(tp->fld), NULL, cookie);\n @}\n \n template<typename T>"}, {"sha": "db218a7bce764093bc6bdeab487a10f7ca2ed3d7", "filename": "gcc/gengtype.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -2491,6 +2491,7 @@ struct walk_type_data\n   int loopcounter;\n   bool in_ptr_field;\n   bool have_this_obj;\n+  bool in_nested_ptr;\n };\n \n \n@@ -2807,6 +2808,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \t    if (nested_ptr_d)\n \t      {\n \t\tconst char *oldprevval2 = d->prev_val[2];\n+\t\tbool old_in_nested_ptr = d->in_nested_ptr;\n \n \t\tif (!union_or_struct_p (nested_ptr_d->type))\n \t\t  {\n@@ -2817,6 +2819,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \t\t  }\n \n \t\td->prev_val[2] = d->val;\n+\t\td->in_nested_ptr = true;\n \t\toprintf (d->of, \"%*s{\\n\", d->indent, \"\");\n \t\td->indent += 2;\n \t\td->val = xasprintf (\"x%d\", d->counter++);\n@@ -2846,6 +2849,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \t\toprintf (d->of, \"%*s}\\n\", d->indent, \"\");\n \t\td->val = d->prev_val[2];\n \t\td->prev_val[2] = oldprevval2;\n+\t\td->in_nested_ptr = old_in_nested_ptr;\n \t      }\n \t    else\n \t      d->process_field (t->u.p, d);\n@@ -3828,12 +3832,17 @@ write_types_local_user_process_field (type_p f, const struct walk_type_data *d)\n     case TYPE_UNION:\n     case TYPE_LANG_STRUCT:\n     case TYPE_STRING:\n-      oprintf (d->of, \"%*s  op (&(%s), cookie);\\n\", d->indent, \"\", d->val);\n+      if (d->in_nested_ptr)\n+\toprintf (d->of, \"%*s  op (&(%s), &(%s), cookie);\\n\",\n+\t\t d->indent, \"\", d->val, d->prev_val[2]);\n+      oprintf (d->of, \"%*s  op (&(%s), NULL, cookie);\\n\",\n+\t       d->indent, \"\", d->val);\n       break;\n \n     case TYPE_USER_STRUCT:\n       if (d->in_ptr_field)\n-\toprintf (d->of, \"%*s  op (&(%s), cookie);\\n\", d->indent, \"\", d->val);\n+\toprintf (d->of, \"%*s  op (&(%s), NULL, cookie);\\n\",\n+\t\t d->indent, \"\", d->val);\n       else\n \toprintf (d->of, \"%*s  gt_pch_nx (&(%s), op, cookie);\\n\",\n \t\t d->indent, \"\", d->val);\n@@ -3911,14 +3920,20 @@ write_types_local_process_field (type_p f, const struct walk_type_data *d)\n     case TYPE_STRING:\n       oprintf (d->of, \"%*sif ((void *)(%s) == this_obj)\\n\", d->indent, \"\",\n \t       d->prev_val[3]);\n-      oprintf (d->of, \"%*s  op (&(%s), cookie);\\n\", d->indent, \"\", d->val);\n+      if (d->in_nested_ptr)\n+\toprintf (d->of, \"%*s  op (&(%s), &(%s), cookie);\\n\",\n+\t\t d->indent, \"\", d->val, d->prev_val[2]);\n+      else\n+\toprintf (d->of, \"%*s  op (&(%s), NULL, cookie);\\n\",\n+\t\t d->indent, \"\", d->val);\n       break;\n \n     case TYPE_USER_STRUCT:\n       oprintf (d->of, \"%*sif ((void *)(%s) == this_obj)\\n\", d->indent, \"\",\n \t       d->prev_val[3]);\n       if (d->in_ptr_field)\n-\toprintf (d->of, \"%*s  op (&(%s), cookie);\\n\", d->indent, \"\", d->val);\n+\toprintf (d->of, \"%*s  op (&(%s), NULL, cookie);\\n\",\n+\t\t d->indent, \"\", d->val);\n       else\n \toprintf (d->of, \"%*s  gt_pch_nx (&(%s), op, cookie);\\n\",\n \t\t d->indent, \"\", d->val);"}, {"sha": "4fe9ff104a0a8f93d3dec279c3d92ec0aa48b4bf", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 190, "deletions": 12, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -40,7 +40,7 @@ static ggc_statistics *ggc_stats;\n struct traversal_state;\n \n static int compare_ptr_data (const void *, const void *);\n-static void relocate_ptrs (void *, void *);\n+static void relocate_ptrs (void *, void *, void *);\n static void write_pch_globals (const struct ggc_root_tab * const *tab,\n \t\t\t       struct traversal_state *state);\n \n@@ -247,6 +247,7 @@ saving_hasher::equal (const ptr_data *p1, const void *p2)\n \n static hash_table<saving_hasher> *saving_htab;\n static vec<void *> callback_vec;\n+static vec<void *> reloc_addrs_vec;\n \n /* Register an object in the hash table.  */\n \n@@ -363,10 +364,10 @@ compare_ptr_data (const void *p1_p, const void *p2_p)\n /* Callbacks for note_ptr_fn.  */\n \n static void\n-relocate_ptrs (void *ptr_p, void *state_p)\n+relocate_ptrs (void *ptr_p, void *real_ptr_p, void *state_p)\n {\n   void **ptr = (void **)ptr_p;\n-  struct traversal_state *state ATTRIBUTE_UNUSED\n+  struct traversal_state *state\n     = (struct traversal_state *)state_p;\n   struct ptr_data *result;\n \n@@ -377,6 +378,19 @@ relocate_ptrs (void *ptr_p, void *state_p)\n     saving_htab->find_with_hash (*ptr, POINTER_HASH (*ptr));\n   gcc_assert (result);\n   *ptr = result->new_addr;\n+  if (ptr_p == real_ptr_p)\n+    return;\n+  if (real_ptr_p == NULL)\n+    real_ptr_p = ptr_p;\n+  gcc_assert (real_ptr_p >= state->ptrs[state->ptrs_i]->obj\n+\t      && ((char *) real_ptr_p + sizeof (void *)\n+\t\t  <= ((char *) state->ptrs[state->ptrs_i]->obj\n+\t\t      + state->ptrs[state->ptrs_i]->size)));\n+  void *addr\n+    = (void *) ((char *) state->ptrs[state->ptrs_i]->new_addr\n+\t\t+ ((char *) real_ptr_p\n+\t\t   - (char *) state->ptrs[state->ptrs_i]->obj));\n+  reloc_addrs_vec.safe_push (addr);\n }\n \n /* Write out, after relocation, the pointers in TAB.  */\n@@ -411,6 +425,61 @@ write_pch_globals (const struct ggc_root_tab * const *tab,\n \t}\n }\n \n+/* Callback for qsort.  */\n+\n+static int\n+compare_ptr (const void *p1_p, const void *p2_p)\n+{\n+  void *p1 = *(void *const *)p1_p;\n+  void *p2 = *(void *const *)p2_p;\n+  return (((uintptr_t)p1 > (uintptr_t)p2)\n+\t  - ((uintptr_t)p1 < (uintptr_t)p2));\n+}\n+\n+/* Decode one uleb128 from P, return first byte after it, store\n+   decoded value into *VAL.  */\n+\n+static unsigned char *\n+read_uleb128 (unsigned char *p, size_t *val)\n+{\n+  unsigned int shift = 0;\n+  unsigned char byte;\n+  size_t result;\n+\n+  result = 0;\n+  do\n+    {\n+      byte = *p++;\n+      result |= ((size_t) byte & 0x7f) << shift;\n+      shift += 7;\n+    }\n+  while (byte & 0x80);\n+\n+  *val = result;\n+  return p;\n+}\n+\n+/* Store VAL as uleb128 at P, return length in bytes.  */\n+\n+static size_t\n+write_uleb128 (unsigned char *p, size_t val)\n+{\n+  size_t len = 0;\n+  do\n+    {\n+      unsigned char byte = (val & 0x7f);\n+      val >>= 7;\n+      if (val != 0)\n+\t/* More bytes to follow.  */\n+\tbyte |= 0x80;\n+\n+      *p++ = byte;\n+      ++len;\n+    }\n+  while (val != 0);\n+  return len;\n+}\n+\n /* Hold the information we need to mmap the file back in.  */\n \n struct mmap_info\n@@ -511,6 +580,7 @@ gt_pch_save (FILE *f)\n   /* Actually write out the objects.  */\n   for (i = 0; i < state.count; i++)\n     {\n+      state.ptrs_i = i;\n       if (this_object_size < state.ptrs[i]->size)\n \t{\n \t  this_object_size = state.ptrs[i]->size;\n@@ -591,7 +661,42 @@ gt_pch_save (FILE *f)\n   vbits.release ();\n #endif\n \n+  reloc_addrs_vec.qsort (compare_ptr);\n+\n+  size_t reloc_addrs_size = 0;\n+  void *last_addr = NULL;\n+  unsigned char uleb128_buf[sizeof (size_t) * 2];\n+  for (void *addr : reloc_addrs_vec)\n+    {\n+      gcc_assert ((uintptr_t) addr >= (uintptr_t) mmi.preferred_base\n+\t\t  && ((uintptr_t) addr + sizeof (void *)\n+\t\t      < (uintptr_t) mmi.preferred_base + mmi.size));\n+      if (addr == last_addr)\n+\tcontinue;\n+      if (last_addr == NULL)\n+\tlast_addr = mmi.preferred_base;\n+      size_t diff = (uintptr_t) addr - (uintptr_t) last_addr;\n+      reloc_addrs_size += write_uleb128 (uleb128_buf, diff);\n+      last_addr = addr;\n+    }\n+  if (fwrite (&reloc_addrs_size, sizeof (reloc_addrs_size), 1, f) != 1)\n+    fatal_error (input_location, \"cannot write PCH file: %m\");\n+  last_addr = NULL;\n+  for (void *addr : reloc_addrs_vec)\n+    {\n+      if (addr == last_addr)\n+\tcontinue;\n+      if (last_addr == NULL)\n+\tlast_addr = mmi.preferred_base;\n+      size_t diff = (uintptr_t) addr - (uintptr_t) last_addr;\n+      reloc_addrs_size = write_uleb128 (uleb128_buf, diff);\n+      if (fwrite (uleb128_buf, 1, reloc_addrs_size, f) != reloc_addrs_size)\n+\tfatal_error (input_location, \"cannot write PCH file: %m\");\n+      last_addr = addr;\n+    }\n+\n   ggc_pch_finish (state.d, state.f);\n+\n   gt_pch_fixup_stringpool ();\n \n   unsigned num_callbacks = callback_vec.length ();\n@@ -608,6 +713,7 @@ gt_pch_save (FILE *f)\n   delete saving_htab;\n   saving_htab = NULL;\n   callback_vec.release ();\n+  reloc_addrs_vec.release ();\n }\n \n /* Read the state of the compiler back in from F.  */\n@@ -660,14 +766,15 @@ gt_pch_restore (FILE *f)\n   if (fread (&mmi, sizeof (mmi), 1, f) != 1)\n     fatal_error (input_location, \"cannot read PCH file: %m\");\n \n+  void *orig_preferred_base = mmi.preferred_base;\n   result = host_hooks.gt_pch_use_address (mmi.preferred_base, mmi.size,\n \t\t\t\t\t  fileno (f), mmi.offset);\n \n   /* We could not mmap or otherwise allocate the required memory at the\n      address needed.  */\n   if (result < 0)\n     {\n-      sorry_at (input_location, \"PCH relocation is not yet supported\");\n+      sorry_at (input_location, \"PCH allocation failure\");\n       /* There is no point in continuing from here, we will only end up\n \t with a crashed (most likely hanging) compiler.  */\n       exit (-1);\n@@ -685,9 +792,75 @@ gt_pch_restore (FILE *f)\n   else if (fseek (f, mmi.offset + mmi.size, SEEK_SET) != 0)\n     fatal_error (input_location, \"cannot read PCH file: %m\");\n \n-  ggc_pch_read (f, mmi.preferred_base);\n+  size_t reloc_addrs_size;\n+  if (fread (&reloc_addrs_size, sizeof (reloc_addrs_size), 1, f) != 1)\n+    fatal_error (input_location, \"cannot read PCH file: %m\");\n \n-  gt_pch_restore_stringpool ();\n+  if (orig_preferred_base != mmi.preferred_base)\n+    {\n+      uintptr_t bias\n+\t= (uintptr_t) mmi.preferred_base - (uintptr_t) orig_preferred_base;\n+\n+      /* Adjust all the global pointers by bias.  */\n+      line_table = new_line_table;\n+      for (rt = gt_ggc_rtab; *rt; rt++)\n+\tfor (rti = *rt; rti->base != NULL; rti++)\n+      for (i = 0; i < rti->nelt; i++)\n+\t{\n+\t  char *addr = (char *)rti->base + rti->stride * i;\n+\t  char *p;\n+\t  memcpy (&p, addr, sizeof (void *));\n+\t  if ((uintptr_t) p >= (uintptr_t) orig_preferred_base\n+\t      && (uintptr_t) p < (uintptr_t) orig_preferred_base + mmi.size)\n+\t    {\n+\t      p = (char *) ((uintptr_t) p + bias);\n+\t      memcpy (addr, &p, sizeof (void *));\n+\t    }\n+\t}\n+      new_line_table = line_table;\n+      line_table = save_line_table;\n+\n+      /* And adjust all the pointers in the image by bias too.  */\n+      char *addr = (char *) mmi.preferred_base;\n+      unsigned char uleb128_buf[4096], *uleb128_ptr = uleb128_buf;\n+      while (reloc_addrs_size != 0)\n+\t{\n+\t  size_t this_size\n+\t    = MIN (reloc_addrs_size,\n+\t\t   (size_t) (4096 - (uleb128_ptr - uleb128_buf)));\n+\t  if (fread (uleb128_ptr, 1, this_size, f) != this_size)\n+\t    fatal_error (input_location, \"cannot read PCH file: %m\");\n+\t  unsigned char *uleb128_end = uleb128_ptr + this_size;\n+\t  if (this_size != reloc_addrs_size)\n+\t    uleb128_end -= 2 * sizeof (size_t);\n+\t  uleb128_ptr = uleb128_buf;\n+\t  while (uleb128_ptr < uleb128_end)\n+\t    {\n+\t      size_t diff;\n+\t      uleb128_ptr = read_uleb128 (uleb128_ptr, &diff);\n+\t      addr = (char *) ((uintptr_t) addr + diff);\n+\n+\t      char *p;\n+\t      memcpy (&p, addr, sizeof (void *));\n+\t      gcc_assert ((uintptr_t) p >= (uintptr_t) orig_preferred_base\n+\t\t\t  && ((uintptr_t) p\n+\t\t\t      < (uintptr_t) orig_preferred_base + mmi.size));\n+\t      p = (char *) ((uintptr_t) p + bias);\n+\t      memcpy (addr, &p, sizeof (void *));\n+\t    }\n+\t  reloc_addrs_size -= this_size;\n+\t  if (reloc_addrs_size == 0)\n+\t    break;\n+\t  this_size = uleb128_end + 2 * sizeof (size_t) - uleb128_ptr;\n+\t  memcpy (uleb128_buf, uleb128_ptr, this_size);\n+\t  uleb128_ptr = uleb128_buf + this_size;\n+\t}\n+    }\n+  else if (fseek (f, (mmi.offset + mmi.size + sizeof (reloc_addrs_size)\n+\t\t      + reloc_addrs_size), SEEK_SET) != 0)\n+    fatal_error (input_location, \"cannot read PCH file: %m\");\n+\n+  ggc_pch_read (f, mmi.preferred_base);\n \n   void (*pch_save) (FILE *);\n   unsigned num_callbacks;\n@@ -696,23 +869,28 @@ gt_pch_restore (FILE *f)\n     fatal_error (input_location, \"cannot read PCH file: %m\");\n   if (pch_save != &gt_pch_save)\n     {\n-      uintptr_t bias = (uintptr_t) &gt_pch_save - (uintptr_t) pch_save;\n+      uintptr_t binbias = (uintptr_t) &gt_pch_save - (uintptr_t) pch_save;\n       void **ptrs = XNEWVEC (void *, num_callbacks);\n       unsigned i;\n+      uintptr_t bias\n+\t= (uintptr_t) mmi.preferred_base - (uintptr_t) orig_preferred_base;\n \n       if (fread (ptrs, sizeof (void *), num_callbacks, f) != num_callbacks)\n \tfatal_error (input_location, \"cannot read PCH file: %m\");\n       for (i = 0; i < num_callbacks; ++i)\n \t{\n-\t  memcpy (&pch_save, ptrs[i], sizeof (pch_save));\n-\t  pch_save = (void (*) (FILE *)) ((uintptr_t) pch_save + bias);\n-\t  memcpy (ptrs[i], &pch_save, sizeof (pch_save));\n+\t  void *ptr = (void *) ((uintptr_t) ptrs[i] + bias);\n+\t  memcpy (&pch_save, ptr, sizeof (pch_save));\n+\t  pch_save = (void (*) (FILE *)) ((uintptr_t) pch_save + binbias);\n+\t  memcpy (ptr, &pch_save, sizeof (pch_save));\n \t}\n       XDELETE (ptrs);\n     }\n   else if (fseek (f, num_callbacks * sizeof (void *), SEEK_CUR) != 0)\n     fatal_error (input_location, \"cannot read PCH file: %m\");\n \n+  gt_pch_restore_stringpool ();\n+\n   /* Barring corruption of the PCH file, the restored line table should be\n      complete and usable.  */\n   line_table = new_line_table;\n@@ -736,7 +914,7 @@ default_gt_pch_get_address (size_t size ATTRIBUTE_UNUSED,\n    of the PCH file would be required.  */\n \n int\n-default_gt_pch_use_address (void *base, size_t size, int fd ATTRIBUTE_UNUSED,\n+default_gt_pch_use_address (void *&base, size_t size, int fd ATTRIBUTE_UNUSED,\n \t\t\t    size_t offset ATTRIBUTE_UNUSED)\n {\n   void *addr = xmalloc (size);\n@@ -782,7 +960,7 @@ mmap_gt_pch_get_address (size_t size, int fd)\n    mapped with something.  */\n \n int\n-mmap_gt_pch_use_address (void *base, size_t size, int fd, size_t offset)\n+mmap_gt_pch_use_address (void *&base, size_t size, int fd, size_t offset)\n {\n   void *addr;\n "}, {"sha": "cd8621a6baab0a8d0ada3b81ab2f7c9af2090e42", "filename": "gcc/ggc-tests.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fggc-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fggc-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-tests.c?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -415,7 +415,7 @@ gt_pch_nx (user_struct *p)\n static void\n gt_pch_nx (user_struct *p, gt_pointer_operator op, void *cookie)\n {\n-  op (&(p->m_ptr), cookie);\n+  op (&(p->m_ptr), NULL, cookie);\n }\n \n /* Verify that GTY((user)) works.  */"}, {"sha": "e495b62a1176f9095b574a73be7f852557753358", "filename": "gcc/hash-map.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fhash-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fhash-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-map.h?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -111,7 +111,7 @@ class GTY((user)) hash_map\n       static void\n       pch_nx_helper (T *&x, gt_pointer_operator op, void *cookie)\n \t{\n-\t  op (&x, cookie);\n+\t  op (&x, NULL, cookie);\n \t}\n \n     /* The overloads below should match those in ggc.h.  */\n@@ -336,7 +336,7 @@ template<typename K, typename V, typename H>\n static inline void\n gt_pch_nx (hash_map<K, V, H> *h, gt_pointer_operator op, void *cookie)\n {\n-  op (&h->m_table.m_entries, cookie);\n+  op (&h->m_table.m_entries, NULL, cookie);\n }\n \n enum hm_alloc { hm_heap = false, hm_ggc = true };"}, {"sha": "60b3fcbf0c5a6538efcbffa4ec40fb02c7303479", "filename": "gcc/hash-set.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fhash-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fhash-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-set.h?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -206,7 +206,7 @@ template<typename K, typename H>\n static inline void\n gt_pch_nx (hash_set<K, false, H> *h, gt_pointer_operator op, void *cookie)\n {\n-  op (&h->m_table.m_entries, cookie);\n+  op (&h->m_table.m_entries, NULL, cookie);\n }\n \n #endif"}, {"sha": "00b31d8b679143d72394809be0d144c0ea166a6e", "filename": "gcc/hash-table.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -1206,7 +1206,7 @@ template<typename D>\n static inline void\n gt_pch_nx (hash_table<D> *h, gt_pointer_operator op, void *cookie)\n {\n-  op (&h->m_entries, cookie);\n+  op (&h->m_entries, NULL, cookie);\n }\n \n template<typename H>"}, {"sha": "6f0373ec27f7adcc2bfc56e7e64a65b43d109501", "filename": "gcc/hash-traits.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fhash-traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fhash-traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-traits.h?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -254,7 +254,7 @@ struct ggc_remove\n   static void\n   pch_nx (T &p, gt_pointer_operator op, void *cookie)\n   {\n-    op (&p, cookie);\n+    op (&p, NULL, cookie);\n   }\n };\n "}, {"sha": "8f50932274b51d6991a115796d3e2eb10c47cc7c", "filename": "gcc/hosthooks-def.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fhosthooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fhosthooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhosthooks-def.h?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -35,10 +35,10 @@ along with GCC; see the file COPYING3.  If not see\n   default_gt_pch_alloc_granularity\n \n extern void* default_gt_pch_get_address (size_t, int);\n-extern int default_gt_pch_use_address (void *, size_t, int, size_t);\n+extern int default_gt_pch_use_address (void *&, size_t, int, size_t);\n extern size_t default_gt_pch_alloc_granularity (void);\n extern void* mmap_gt_pch_get_address (size_t, int);\n-extern int mmap_gt_pch_use_address (void *, size_t, int, size_t);\n+extern int mmap_gt_pch_use_address (void *&, size_t, int, size_t);\n \n /* The structure is defined in hosthooks.h.  */\n #define HOST_HOOKS_INITIALIZER {\t\t\\"}, {"sha": "8241a533905ae3b1acab3403ba4d2cc4285fdc23", "filename": "gcc/hosthooks.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fhosthooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fhosthooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhosthooks.h?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -30,10 +30,12 @@ struct host_hooks\n   void * (*gt_pch_get_address) (size_t size, int fd);\n \n   /* ADDR is an address returned by gt_pch_get_address.  Attempt to allocate\n-     SIZE bytes at the same address and load it with the data from FD at\n-     OFFSET.  Return -1 if we couldn't allocate memory at ADDR, return 0\n-     if the memory is allocated but the data not loaded, return 1 if done.  */\n-  int (*gt_pch_use_address) (void *addr, size_t size, int fd, size_t offset);\n+     SIZE bytes at the same address (preferrably) or some other address\n+     and load it with the data from FD at OFFSET.  Return -1 if we couldn't\n+     allocate memory, otherwise update ADDR to the actual address where it got\n+     allocated, return 0 if the memory is allocated but the data not loaded,\n+     return 1 if done.  */\n+  int (*gt_pch_use_address) (void *&addr, size_t size, int fd, size_t offset);\n \n   /*  Return the alignment required for allocating virtual memory. Usually\n       this is the same as pagesize.  */"}, {"sha": "2e5bafd0f9675622bcdfce0b4bcb5b3aa149d166", "filename": "gcc/machmode.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -1199,7 +1199,7 @@ gt_pch_nx (pod_mode<T> *)\n \n template<typename T>\n void\n-gt_pch_nx (pod_mode<T> *, void (*) (void *, void *), void *)\n+gt_pch_nx (pod_mode<T> *, void (*) (void *, void *, void *), void *)\n {\n }\n "}, {"sha": "60a38c3ea6172280053f6f89f09937e1d7e2f648", "filename": "gcc/poly-int.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fpoly-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fpoly-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpoly-int.h?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -2717,7 +2717,7 @@ gt_pch_nx (poly_int_pod<N, C> *)\n \n template<unsigned int N, typename C>\n void\n-gt_pch_nx (poly_int_pod<N, C> *, void (*) (void *, void *), void *)\n+gt_pch_nx (poly_int_pod<N, C> *, void (*) (void *, void *, void *), void *)\n {\n }\n "}, {"sha": "cf7f87db7c510133db3e216042b77fcc36a6f0c6", "filename": "gcc/stringpool.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fstringpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fstringpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstringpool.c?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -225,7 +225,7 @@ gt_pch_nx (unsigned char& x ATTRIBUTE_UNUSED)\n void\n gt_pch_nx (unsigned char *x, gt_pointer_operator op, void *cookie)\n {\n-  op (x, cookie);\n+  op (x, NULL, cookie);\n }\n \f\n /* Handle saving and restoring the string pool for PCH.  */"}, {"sha": "672e384ef09ce638484c121037dee19c75b6e4ad", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -9946,13 +9946,13 @@ void\n gt_pch_nx (edge_def *e, gt_pointer_operator op, void *cookie)\n {\n   tree block = LOCATION_BLOCK (e->goto_locus);\n-  op (&(e->src), cookie);\n-  op (&(e->dest), cookie);\n+  op (&(e->src), NULL, cookie);\n+  op (&(e->dest), NULL, cookie);\n   if (current_ir_type () == IR_GIMPLE)\n-    op (&(e->insns.g), cookie);\n+    op (&(e->insns.g), NULL, cookie);\n   else\n-    op (&(e->insns.r), cookie);\n-  op (&(block), cookie);\n+    op (&(e->insns.r), NULL, cookie);\n+  op (&(block), &(block), cookie);\n }\n \n #if CHECKING_P"}, {"sha": "8cc8cca26cf0c1efa7a83cefd344283f89870338", "filename": "gcc/value-range.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -365,8 +365,8 @@ gt_pch_nx (irange *x, gt_pointer_operator op, void *cookie)\n {\n   for (unsigned i = 0; i < x->m_num_ranges; ++i)\n     {\n-      op (&x->m_base[i * 2], cookie);\n-      op (&x->m_base[i * 2 + 1], cookie);\n+      op (&x->m_base[i * 2], NULL, cookie);\n+      op (&x->m_base[i * 2 + 1], NULL, cookie);\n     }\n }\n "}, {"sha": "d83a19a7f25570aee1720ebabec9071883e70ceb", "filename": "gcc/vec.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -1388,7 +1388,7 @@ void\n gt_pch_nx (vec<T *, A, vl_embed> *v, gt_pointer_operator op, void *cookie)\n {\n   for (unsigned i = 0; i < v->length (); i++)\n-    op (&((*v)[i]), cookie);\n+    op (&((*v)[i]), NULL, cookie);\n }\n \n template<typename T, typename A>"}, {"sha": "d03a17412536599c8836afc82573a5f2b616c604", "filename": "gcc/wide-int.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fwide-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/747380f47da0da6c11fd5262ac428bb53433ea19/gcc%2Fwide-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.h?ref=747380f47da0da6c11fd5262ac428bb53433ea19", "patch": "@@ -3338,7 +3338,7 @@ gt_pch_nx (generic_wide_int <T> *)\n \n template<typename T>\n void\n-gt_pch_nx (generic_wide_int <T> *, void (*) (void *, void *), void *)\n+gt_pch_nx (generic_wide_int <T> *, void (*) (void *, void *, void *), void *)\n {\n }\n \n@@ -3356,7 +3356,7 @@ gt_pch_nx (trailing_wide_ints <N> *)\n \n template<int N>\n void\n-gt_pch_nx (trailing_wide_ints <N> *, void (*) (void *, void *), void *)\n+gt_pch_nx (trailing_wide_ints <N> *, void (*) (void *, void *, void *), void *)\n {\n }\n "}]}