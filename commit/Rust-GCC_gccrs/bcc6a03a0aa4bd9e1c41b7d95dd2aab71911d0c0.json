{"sha": "bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNjNmEwM2EwYWE0YmQ5ZTFjNDFiN2Q5NWRkMmFhYjcxOTExZDBjMA==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2002-07-26T01:49:36Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2002-07-26T01:49:36Z"}, "message": "re PR libstdc++/7216 (basic_iostream::traits_type is ambiguous issue)\n\n\n2002-07-25  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tPR libstdc++/7216\n\t* include/std/std_istream.h (basic_iostream): Add typedefs for\n\tchar_type, int_type, pos_type, off_type, and traits_type.\n\t* testsuite/27_io/iostream.cc (test01): Add typedef tests.\n\t* testsuite/27_io/istream.cc: Same.\n\t* testsuite/27_io/ostream.cc: Same.\n\t* testsuite/27_io/filebuf.cc: Same.\n\t* testsuite/27_io/stringbuf.cc: Replace content, move to...\n\t* testsuite/27_io/stringbuf_members.cc: ...here.\n\t* testsuite/27_io/streambuf.cc: Replace content, move to...\n\t* testsuite/27_io/streambuf_members.cc: ...here.\n\t* testsuite/27_io/stringstream.cc: Replace content, move to...\n\t* testsuite/27_io/stringstream_members.cc: ...here.\n\t* testsuite/27_io/ios.cc: New file.\n\t* testsuite/27_io/fstream.cc: New file.\n\t* testsuite/27_io/ifstream.cc: New file.\n\t* testsuite/27_io/ofstream.cc: New file.\n\t* testsuite/27_io/istringstream.cc: New file.\n\t* testsuite/27_io/ostringstream.cc: New file.\n\nFrom-SVN: r55767", "tree": {"sha": "7153e01162b51a2f8735deeb4204e2554b6e8f0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7153e01162b51a2f8735deeb4204e2554b6e8f0c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/comments", "author": null, "committer": null, "parents": [{"sha": "325fceb395f8d9bdb1970f378c5a6aed4c36b968", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/325fceb395f8d9bdb1970f378c5a6aed4c36b968", "html_url": "https://github.com/Rust-GCC/gccrs/commit/325fceb395f8d9bdb1970f378c5a6aed4c36b968"}], "stats": {"total": 2418, "additions": 1494, "deletions": 924}, "files": [{"sha": "bd80812f794cc874d2eea51c9db3a96f43e99bed", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "patch": "@@ -1,3 +1,25 @@\n+2002-07-25  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tPR libstdc++/7216\n+\t* include/std/std_istream.h (basic_iostream): Add typedefs for\n+\tchar_type, int_type, pos_type, off_type, and traits_type.\n+\t* testsuite/27_io/iostream.cc (test01): Add typedef tests.\n+\t* testsuite/27_io/istream.cc: Same.\n+\t* testsuite/27_io/ostream.cc: Same.\n+\t* testsuite/27_io/filebuf.cc: Same.\n+\t* testsuite/27_io/stringbuf.cc: Replace content, move to...\n+\t* testsuite/27_io/stringbuf_members.cc: ...here.\t\n+\t* testsuite/27_io/streambuf.cc: Replace content, move to...\n+\t* testsuite/27_io/streambuf_members.cc: ...here.\t\n+\t* testsuite/27_io/stringstream.cc: Replace content, move to...\n+\t* testsuite/27_io/stringstream_members.cc: ...here.\n+\t* testsuite/27_io/ios.cc: New file.\n+\t* testsuite/27_io/fstream.cc: New file.\n+\t* testsuite/27_io/ifstream.cc: New file.\t\n+\t* testsuite/27_io/ofstream.cc: New file.\t\t\n+\t* testsuite/27_io/istringstream.cc: New file.\t\n+\t* testsuite/27_io/ostringstream.cc: New file.\t\n+\t\n 2002-07-25  Benjamin Kosnik  <bkoz@redhat.com>\n \n \tPR libstdc++/7220"}, {"sha": "8aa9123ed5c5683ca003dafb5b15c12b5cc3b773", "filename": "libstdc++-v3/include/std/std_istream.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_istream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_istream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_istream.h?ref=bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "patch": "@@ -261,6 +261,16 @@ namespace std\n       public basic_ostream<_CharT, _Traits>\n     {\n     public:\n+#ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n+// 271. basic_iostream missing typedefs\n+      // Types (inherited):\n+      typedef _CharT                     \t\tchar_type;\n+      typedef typename _Traits::int_type \t\tint_type;\n+      typedef typename _Traits::pos_type \t\tpos_type;\n+      typedef typename _Traits::off_type \t\toff_type;\n+      typedef _Traits                    \t\ttraits_type;\n+#endif\n+\n       // Non-standard Types:\n       typedef basic_istream<_CharT, _Traits>\t\t__istream_type;\n       typedef basic_ostream<_CharT, _Traits>\t\t__ostream_type;"}, {"sha": "9919365a552b3d3f37cedf00d3fdde6a068811aa", "filename": "libstdc++-v3/testsuite/27_io/filebuf.cc", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffilebuf.cc?ref=bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "patch": "@@ -19,22 +19,34 @@\n // Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n // USA.\n \n-// NB: this test assumes that _M_buf_size == 40, and not the usual\n-// buffer_size length of BUFSIZ (8192), so that overflow/underflow can be\n-// simulated a bit more readily.\n+// 27.8.1.1 - Template class basic_filebuf \n+// NB: This file is for testing basic_filebuf with NO OTHER INCLUDES.\n \n #include <fstream>\n #include <testsuite_hooks.h>\n \n // { dg-do compile }\n \n+// libstdc++/7216\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::filebuf test_type;\n+  typedef test_type::char_type char_type;\n+  typedef test_type::traits_type traits_type;\n+  typedef test_type::int_type int_type;\n+  typedef test_type::pos_type pos_type;\n+  typedef test_type::off_type off_type;\n+}\n+\n // test05\n // libstdc++/1886\n // should be able to instantiate basic_filebuf for non-standard types.\n template class std::basic_filebuf<short, std::char_traits<short> >;\n \n int main() \n {\n+  test01();\n   return 0;\n }\n "}, {"sha": "2ecd0778700f698d36530e748093b6ac84cc0787", "filename": "libstdc++-v3/testsuite/27_io/fstream.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Ffstream.cc?ref=bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "patch": "@@ -0,0 +1,60 @@\n+// 2002-07-25 Benjamin Kosnik <bkoz@redhat.com>\n+\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// 27.8.1.11 - Template class basic_fstream\n+// NB: This file is for testing basic_fstream with NO OTHER INCLUDES.\n+\n+#include <fstream>\n+\n+// { dg-do compile }\n+\n+// libstdc++/7216\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::fstream test_type;\n+  typedef test_type::char_type char_type;\n+  typedef test_type::traits_type traits_type;\n+  typedef test_type::int_type int_type;\n+  typedef test_type::pos_type pos_type;\n+  typedef test_type::off_type off_type;\n+}\n+\n+namespace test \n+{\n+  using namespace std;\n+  typedef short type_t;\n+  template class basic_fstream<type_t, char_traits<type_t> >;\n+} // test\n+\n+int main() \n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "9bc38a8e697651ef0a1faa14b9cc8cdf632c2a86", "filename": "libstdc++-v3/testsuite/27_io/ifstream.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fifstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fifstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fifstream.cc?ref=bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "patch": "@@ -0,0 +1,60 @@\n+// 2002-07-25 Benjamin Kosnik <bkoz@redhat.com>\n+\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// 27.8.1.5 - Template class basic_ifstream\n+// NB: This file is for testing basic_ifstream with NO OTHER INCLUDES.\n+\n+#include <fstream>\n+\n+// { dg-do compile }\n+\n+// libstdc++/7216\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::ifstream test_type;\n+  typedef test_type::char_type char_type;\n+  typedef test_type::traits_type traits_type;\n+  typedef test_type::int_type int_type;\n+  typedef test_type::pos_type pos_type;\n+  typedef test_type::off_type off_type;\n+}\n+\n+namespace test \n+{\n+  using namespace std;\n+  typedef short type_t;\n+  template class basic_ifstream<type_t, char_traits<type_t> >;\n+} // test\n+\n+int main() \n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "c1249381ac4c22dca48bc0271218ba20128c5d63", "filename": "libstdc++-v3/testsuite/27_io/ios.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fios.cc?ref=bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "patch": "@@ -0,0 +1,60 @@\n+// 2002-07-25 Benjamin Kosnik <bkoz@redhat.com>\n+\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// 27.4.4 - Template class basic_ios\n+// NB: This file is for testing basic_ios with NO OTHER INCLUDES.\n+\n+#include <ios>\n+\n+// { dg-do compile }\n+\n+// libstdc++/7216\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::ios test_type;\n+  typedef test_type::char_type char_type;\n+  typedef test_type::traits_type traits_type;\n+  typedef test_type::int_type int_type;\n+  typedef test_type::pos_type pos_type;\n+  typedef test_type::off_type off_type;\n+}\n+\n+namespace test \n+{\n+  using namespace std;\n+  typedef short type_t;\n+  template class basic_ios<type_t, char_traits<type_t> >;\n+} // test\n+\n+int main() \n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "943819bf82fd572b0f16dda98c089b4fcbc77223", "filename": "libstdc++-v3/testsuite/27_io/iostream.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fiostream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fiostream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fiostream.cc?ref=bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "patch": "@@ -34,6 +34,18 @@\n \n #include <istream>\n \n+// libstdc++/7216\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::iostream test_type;\n+  typedef test_type::char_type char_type;\n+  typedef test_type::traits_type traits_type;\n+  typedef test_type::int_type int_type;\n+  typedef test_type::pos_type pos_type;\n+  typedef test_type::off_type off_type;\n+}\n+\n namespace test \n {\n   using namespace std;\n@@ -43,5 +55,6 @@ namespace test\n \n int main() \n {\n+  test01();\n   return 0;\n }"}, {"sha": "05db50ed461f627ebc366b4a03b671e492a9235b", "filename": "libstdc++-v3/testsuite/27_io/istream.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistream.cc?ref=bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "patch": "@@ -34,6 +34,18 @@\n \n // { dg-do compile }\n \n+// libstdc++/7216\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::istream test_type;\n+  typedef test_type::char_type char_type;\n+  typedef test_type::traits_type traits_type;\n+  typedef test_type::int_type int_type;\n+  typedef test_type::pos_type pos_type;\n+  typedef test_type::off_type off_type;\n+}\n+\n namespace test \n {\n   using namespace std;\n@@ -43,5 +55,6 @@ namespace test\n \n int main() \n {\n+  test01();\n   return 0;\n }"}, {"sha": "d119f67e7553e1ff5ca76924a534087356d882b4", "filename": "libstdc++-v3/testsuite/27_io/istringstream.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistringstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistringstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fistringstream.cc?ref=bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "patch": "@@ -0,0 +1,60 @@\n+// 2002-07-25 Benjamin Kosnik <bkoz@redhat.com>\n+\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// 27.7.2 - Template class basic_istringstream\n+// NB: This file is for testing basic_istringstream with NO OTHER INCLUDES.\n+\n+#include <sstream>\n+\n+// { dg-do compile }\n+\n+// libstdc++/7216\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::istringstream test_type;\n+  typedef test_type::char_type char_type;\n+  typedef test_type::traits_type traits_type;\n+  typedef test_type::int_type int_type;\n+  typedef test_type::pos_type pos_type;\n+  typedef test_type::off_type off_type;\n+}\n+\n+namespace test \n+{\n+  using namespace std;\n+  typedef short type_t;\n+  template class basic_istringstream<type_t, char_traits<type_t> >;\n+} // test\n+\n+int main() \n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "6b9d07d2523e1ae4a299cd847a5676591b5a9250", "filename": "libstdc++-v3/testsuite/27_io/ofstream.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fofstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fofstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fofstream.cc?ref=bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "patch": "@@ -0,0 +1,60 @@\n+// 2002-07-25 Benjamin Kosnik <bkoz@redhat.com>\n+\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// 27.8.1.8 - Template class basic_ofstream\n+// NB: This file is for testing basic_ofstream with NO OTHER INCLUDES.\n+\n+#include <fstream>\n+\n+// { dg-do compile }\n+\n+// libstdc++/7216\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::ifstream test_type;\n+  typedef test_type::char_type char_type;\n+  typedef test_type::traits_type traits_type;\n+  typedef test_type::int_type int_type;\n+  typedef test_type::pos_type pos_type;\n+  typedef test_type::off_type off_type;\n+}\n+\n+namespace test \n+{\n+  using namespace std;\n+  typedef short type_t;\n+  template class basic_ifstream<type_t, char_traits<type_t> >;\n+} // test\n+\n+int main() \n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "ae524ec61f29eb32efcaee96806ef569f75b2758", "filename": "libstdc++-v3/testsuite/27_io/ostream.cc", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostream.cc?ref=bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "patch": "@@ -34,6 +34,18 @@\n \n // { dg-do compile }\n \n+// libstdc++/7216\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::ostream test_type;\n+  typedef test_type::char_type char_type;\n+  typedef test_type::traits_type traits_type;\n+  typedef test_type::int_type int_type;\n+  typedef test_type::pos_type pos_type;\n+  typedef test_type::off_type off_type;\n+}\n+\n namespace test \n {\n   using namespace std;\n@@ -43,5 +55,6 @@ namespace test\n \n int main() \n {\n+  test01();\n   return 0;\n }"}, {"sha": "c8a9dfccacc73b36188695233eba335209383638", "filename": "libstdc++-v3/testsuite/27_io/ostringstream.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostringstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostringstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostringstream.cc?ref=bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "patch": "@@ -0,0 +1,60 @@\n+// 2002-07-25 Benjamin Kosnik <bkoz@redhat.com>\n+\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// 27.7.3 - Class basic_ostringstream\n+// NB: This file is for testing basic_ostringstream with NO OTHER INCLUDES.\n+\n+#include <sstream>\n+\n+// { dg-do compile }\n+\n+// libstdc++/7216\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::ostringstream test_type;\n+  typedef test_type::char_type char_type;\n+  typedef test_type::traits_type traits_type;\n+  typedef test_type::int_type int_type;\n+  typedef test_type::pos_type pos_type;\n+  typedef test_type::off_type off_type;\n+}\n+\n+namespace test \n+{\n+  using namespace std;\n+  typedef short type_t;\n+  template class basic_ostringstream<type_t, char_traits<type_t> >;\n+} // test\n+\n+int main() \n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "bf823697c830811400126d5b26466d8fc34ced79", "filename": "libstdc++-v3/testsuite/27_io/ostringstream_members.cc", "status": "modified", "additions": 53, "deletions": 1, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostringstream_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostringstream_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fostringstream_members.cc?ref=bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "patch": "@@ -1,6 +1,6 @@\n // 2001-05-23 Benjamin Kosnik  <bkoz@redhat.com>\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -97,9 +97,61 @@ void test02()\n   // These semantics are a joke, a serious defect, and incredibly lame.\n }\n \n+// 03: sanity checks for strings, stringbufs\n+void\n+test03()\n+{\n+  bool test = false;\n+\n+  // Empty string sanity check.\n+  std::string str01;\n+  std::string::iterator __i_start = str01.begin();\n+  std::string::iterator __i_end = str01.end();\n+  std::string::size_type len = str01.size();\n+  test = __i_start == __i_end;\n+  VERIFY( len == 0 );\n+\n+  // Full string sanity check.\n+  std::string str02(\"these golden days, i spend waiting for you:\\n\"\n+\t\t    \"Betty Carter on Verve with I'm Yours and You're Mine.\");\n+  __i_start = str02.begin();\n+  __i_end = str02.end();\n+  len = str02.size();\n+  VERIFY( __i_start != __i_end );\n+  VERIFY( len != 0 );\n+ \n+  // Test an empty ostringstream for sanity.\n+  std::ostringstream ostrstream0;\n+  std::string str03 = ostrstream0.str();\n+  __i_start = str03.begin();\n+  __i_end = str03.end();\n+  len = str03.size();\n+  VERIFY( __i_start == __i_end );\n+  VERIFY( len == 0 );\n+  VERIFY( str01 == str03 );\n+}\n+\n+// user-reported error\n+class derived_oss: public std::ostringstream \n+{\n+public:\n+  derived_oss() : std::ostringstream() { }\n+};\n+\n+void\n+test04()\n+{\n+  bool test = true;\n+  derived_oss yy;\n+  yy << \"buena vista social club\\n\";\n+  VERIFY( yy.str() == std::string(\"buena vista social club\\n\") );\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n+  test04();\n   return 0;\n }"}, {"sha": "905dee089de81cac8c2892af5d7c2d2fd81791a9", "filename": "libstdc++-v3/testsuite/27_io/streambuf.cc", "status": "modified", "additions": 18, "deletions": 336, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstreambuf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstreambuf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstreambuf.cc?ref=bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "patch": "@@ -1,6 +1,6 @@\n-// 1999-10-11 bkoz\n+// 2002-07-25 Benjamin Kosnik <bkoz@redhat.com>\n \n-// Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -27,352 +27,34 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-// 27.5.2 template class basic_streambuf\n+// 27.5.2 - Template class basic_streambuf\n+// NB: This file is for testing basic_streambuf with NO OTHER INCLUDES.\n \n-#include <cstring> // for memset, memcmp\n #include <streambuf>\n-#include <string>\n-#include <ostream>\n-#include <testsuite_hooks.h>\n \n-class testbuf : public std::streambuf\n-{\n-public:\n-\n-  // Typedefs:\n-  typedef std::streambuf::traits_type traits_type;\n-  typedef std::streambuf::char_type char_type;\n-\n-  testbuf(): std::streambuf() \n-  { _M_mode = (std::ios_base::in | std::ios_base::out); }\n-\n-  bool\n-  check_pointers()\n-  { \n-    bool test = true;\n-    VERIFY( this->eback() == NULL );\n-    VERIFY( this->gptr() == NULL );\n-    VERIFY( this->egptr() == NULL );\n-    VERIFY( this->pbase() == NULL );\n-    VERIFY( this->pptr() == NULL );\n-    VERIFY( this->epptr() == NULL );\n-    return test;\n-  }\n-\n-  int_type \n-  pub_uflow() \n-  { return (this->uflow()); }\n-\n-  int_type \n-  pub_overflow(int_type __c = traits_type::eof()) \n-  { return (this->overflow(__c)); }\n-\n-  int_type \n-  pub_pbackfail(int_type __c) \n-  { return (this->pbackfail(__c)); }\n-\n-  void \n-  pub_setg(char* beg, char* cur, char *end) \n-  { this->setg(beg, cur, end); }\n-\n-  void \n-  pub_setp(char* beg, char* end) \n-  { this->setp(beg, end); }\n-\n-protected:\n-  int_type \n-  underflow() \n-  { \n-    int_type __retval = traits_type::eof();\n-    if (this->gptr() < this->egptr())\n-      __retval = traits_type::not_eof(0); \n-    return __retval;\n-  }\n-};\n+// { dg-do compile }\n \n+// libstdc++/7216\n void test01()\n {\n-  typedef testbuf::traits_type traits_type;\n-  typedef testbuf::int_type int_type;\n-\n-  bool test = true;\n-  char* lit01 = \"chicago underground trio/possible cube on delmark\";\n-  testbuf buf01;\n-\n-  // 27.5.2.1 basic_streambuf ctors\n-  // default ctor initializes \n-  // - all pointer members to null pointers\n-  // - locale to current global locale\n-  VERIFY( buf01.check_pointers() );\n-  VERIFY( buf01.getloc() == std::locale() );\n-\n-  // 27.5.2.3.1 get area\n-  // 27.5.2.2.3 get area\n-  // 27.5.2.4.3 get area\n-  int i01 = 3;\n-  buf01.pub_setg(lit01, lit01, (lit01 + i01));\n-  VERIFY( i01 == buf01.in_avail() );\n-\n-  VERIFY( buf01.pub_uflow() == lit01[0] );\n-  VERIFY( buf01.sgetc() == traits_type::to_int_type(lit01[1]) );\n-  VERIFY( buf01.pub_uflow() == lit01[1] );\n-  VERIFY( buf01.sgetc() == traits_type::to_int_type(lit01[2]) );\n-  VERIFY( buf01.pub_uflow() == lit01[2] );\n-  VERIFY( buf01.sgetc() == traits_type::eof() );\n-\n-  // pbackfail\n-  buf01.pub_setg(lit01, lit01, (lit01 + i01));\n-  VERIFY( i01 == buf01.in_avail() );\n-  int_type intt01 = traits_type::to_int_type('b');\n-  VERIFY( traits_type::eof() == buf01.pub_pbackfail(intt01) );\n-\n-  // overflow\n-  VERIFY( traits_type::eof() == buf01.pub_overflow(intt01) );\n-  VERIFY( traits_type::eof() == buf01.pub_overflow() );\n-  VERIFY( buf01.sgetc() == traits_type::to_int_type(lit01[0]) );\n-\n-  // sputn/xsputn\n-  char* lit02 = \"isotope 217: the unstable molecule on thrill jockey\";\n-  int i02 = std::strlen(lit02);\n-  char carray[i02 + 1];\n-  std::memset(carray, 0, i02 + 1);\n-\n-  buf01.pub_setp(carray, (carray + i02));\n-  buf01.sputn(lit02, 0);\n-  VERIFY( carray[0] == 0 );\n-  VERIFY( lit02[0] == 'i' );\n-  buf01.sputn(lit02, 1);\n-  VERIFY( lit02[0] == carray[0] );\n-  VERIFY( lit02[1] == 's' );\n-  VERIFY( carray[1] == 0 );\n-  buf01.sputn(lit02 + 1, 10);\n-  VERIFY( std::memcmp(lit02, carray, 10) == 0 );\n-  buf01.sputn(lit02 + 11, 20);\n-  VERIFY( std::memcmp(lit02, carray, 30) == 0 );\n-\n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n-}\n-\n-void test02()\n-{\n-  typedef testbuf::traits_type traits_type;\n-  typedef testbuf::int_type int_type;\n-\n-  bool test = true;\n-  char* lit01 = \"chicago underground trio/possible cube on delmark\";\n-  testbuf buf01;\n-\n-  // 27.5.2.1 basic_streambuf ctors\n-  // default ctor initializes \n-  // - all pointer members to null pointers\n-  // - locale to current global locale\n-  VERIFY( buf01.check_pointers() );\n-  VERIFY( buf01.getloc() == std::locale() );\n-\n-  // 27.5.2.2.5 Put area\n-  size_t i01 = traits_type::length(lit01);\n-  char carray01[i01];\n-  std::memset(carray01, 0, i01);\n-  \n-  buf01.pub_setg(lit01, lit01, lit01 + i01);\n-  buf01.sgetn(carray01, 0);\n-  VERIFY( carray01[0] == 0 );\n-  buf01.sgetn(carray01, 1);\n-  VERIFY( carray01[0] == 'c' );\n-  buf01.sgetn(carray01 + 1, i01 - 1);\n-  VERIFY( carray01[0] == 'c' );\n-  VERIFY( carray01[1] == 'h' );\n-  VERIFY( carray01[i01 - 1] == 'k' );\n-\n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n+  // Check for required typedefs\n+  typedef std::streambuf test_type;\n+  typedef test_type::char_type char_type;\n+  typedef test_type::traits_type traits_type;\n+  typedef test_type::int_type int_type;\n+  typedef test_type::pos_type pos_type;\n+  typedef test_type::off_type off_type;\n }\n- \n-// test03\n-// http://gcc.gnu.org/ml/libstdc++/2000-q1/msg00151.html\n-template<typename charT, typename traits = std::char_traits<charT> >\n-  class basic_nullbuf : public std::basic_streambuf<charT, traits>\n-  {\n-  protected:\n-    typedef typename\n-      std::basic_streambuf<charT, traits>::int_type int_type;\n-    virtual int_type \n-    overflow(int_type c) \n-    {  return traits::not_eof(c); }\n-  };\n-\n-typedef basic_nullbuf<char> nullbuf;\n-typedef basic_nullbuf<wchar_t> wnullbuf;\n-\n-template<typename T>\n-  char\n-  print(const T& x) \n-  {\n-   nullbuf ob;\n-   std::ostream out(&ob); \n-   out << x << std::endl;\n-   return (!out ? '0' : '1');\n- }\n \n-void test03() \n+namespace test \n {\n-  bool test = true;\n-  const std::string control01(\"11111\");\n-  std::string test01;\n-\n-  test01 += print(true);\n-  test01 += print(3.14159);\n-  test01 += print(10);\n-  test01 += print('x');\n-  test01 += print(\"pipo\");\n-\n-  VERIFY( test01 == control01 );\n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n-}\n-\n-class setpbuf : public std::streambuf\n-{\n-  char \t\tbuffer[4];\n-  std::string \tresult;\n-\n-public:\n-\n-  std::string&\n-  get_result()\n-  { return result; }\n-\n-  setpbuf()\n-  {\n-    char foo [32];\n-    setp(foo, foo + 32);\n-    setp(buffer, buffer + 4);\n-  }\n-\n-  ~setpbuf()\n-  { sync(); }\n-\n-  virtual int_type \n-  overflow(int_type n)\n-  {\n-    if (sync() != 0)\n-      return traits_type::eof();\n-    \n-    result += traits_type::to_char_type(n);\n-    \n-    return n;\n-  }\n-  \n-  virtual int \n-  sync()\n-  {\n-    result.append(pbase(), pptr());\n-    setp(buffer, buffer + 4);\n-    return 0;\n-  }\n-};\n-\n-// libstdc++/1057\n-void test04()\n-{\n-  bool test = true;\n-  std::string text = \"abcdefghijklmn\";\n-  \n-  // 01\n-  setpbuf sp1;\n-  // Here xsputn writes over sp1.result\n-  sp1.sputn(text.c_str(), text.length());\n-\n-  // This crashes when result is accessed\n-  sp1.pubsync();\n-  VERIFY( sp1.get_result() == text );\n-  \n-\n-  // 02\n-  setpbuf sp2;\n-  for (std::string::size_type i = 0; i < text.length(); ++i)\n-    {\n-      // sputc also writes over result\n-      sp2.sputc(text[i]);\n-    }\n-  \n-  // Crash here\n-  sp2.pubsync();\n-  VERIFY( sp2.get_result() == text );\n-}\n-\n-class nullsetpbuf : public std::streambuf\n-{\n-  char foo[64];\n-public:\n-  nullsetpbuf()\n-  {\n-    setp(foo, foo + 64);\n-    setp(NULL, NULL);\n-  }\n-};\n-\n-// libstdc++/1057\n-void test05()\n-{\n-    std::string text1 = \"abcdefghijklmn\";\n-\n-    nullsetpbuf nsp;\n-    // Immediate crash as xsputn writes to null pointer\n-    nsp.sputn(text1.c_str(), text1.length());\n-    // ditto\n-    nsp.sputc('a');\n-}\n-\n-// test06\n-namespace gnu \n-{\n-  class something_derived;\n-}\n-\n-class gnu::something_derived : std::streambuf { };\n-\n-// libstdc++/3599\n-class testbuf2 : public std::streambuf\n-{\n-public:\n-  typedef std::streambuf::traits_type traits_type;\n-\n-  testbuf2() : std::streambuf() { }\n- \n-protected:\n-  int_type \n-  overflow(int_type c = traits_type::eof()) \n-  { return traits_type::not_eof(0); }\n-};\n-\n-void\n-test07()\n-{\n-  bool test = true;\n-  testbuf2 ob;\n-  std::ostream out(&ob); \n-\n-  out << \"gasp\";\n-  VERIFY(out.good());\n-\n-  out << std::endl;\n-  VERIFY(out.good());\n-}\n+  using namespace std;\n+  typedef short type_t;\n+  template class basic_streambuf<type_t, char_traits<type_t> >;\n+} // test\n \n int main() \n {\n   test01();\n-  test02();\n-  test03();\n-\n-  test04();\n-  test05();\n-\n-  test07();\n   return 0;\n }"}, {"sha": "3f9a3192b7e0174c1ccb6aa843a185d585210f6f", "filename": "libstdc++-v3/testsuite/27_io/streambuf_members.cc", "status": "added", "additions": 378, "deletions": 0, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstreambuf_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstreambuf_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstreambuf_members.cc?ref=bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "patch": "@@ -0,0 +1,378 @@\n+// 1999-10-11 bkoz\n+\n+// Copyright (C) 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+// 27.5.2 template class basic_streambuf\n+\n+#include <cstring> // for memset, memcmp\n+#include <streambuf>\n+#include <string>\n+#include <ostream>\n+#include <testsuite_hooks.h>\n+\n+class testbuf : public std::streambuf\n+{\n+public:\n+\n+  // Typedefs:\n+  typedef std::streambuf::traits_type traits_type;\n+  typedef std::streambuf::char_type char_type;\n+\n+  testbuf(): std::streambuf() \n+  { _M_mode = (std::ios_base::in | std::ios_base::out); }\n+\n+  bool\n+  check_pointers()\n+  { \n+    bool test = true;\n+    VERIFY( this->eback() == NULL );\n+    VERIFY( this->gptr() == NULL );\n+    VERIFY( this->egptr() == NULL );\n+    VERIFY( this->pbase() == NULL );\n+    VERIFY( this->pptr() == NULL );\n+    VERIFY( this->epptr() == NULL );\n+    return test;\n+  }\n+\n+  int_type \n+  pub_uflow() \n+  { return (this->uflow()); }\n+\n+  int_type \n+  pub_overflow(int_type __c = traits_type::eof()) \n+  { return (this->overflow(__c)); }\n+\n+  int_type \n+  pub_pbackfail(int_type __c) \n+  { return (this->pbackfail(__c)); }\n+\n+  void \n+  pub_setg(char* beg, char* cur, char *end) \n+  { this->setg(beg, cur, end); }\n+\n+  void \n+  pub_setp(char* beg, char* end) \n+  { this->setp(beg, end); }\n+\n+protected:\n+  int_type \n+  underflow() \n+  { \n+    int_type __retval = traits_type::eof();\n+    if (this->gptr() < this->egptr())\n+      __retval = traits_type::not_eof(0); \n+    return __retval;\n+  }\n+};\n+\n+void test01()\n+{\n+  typedef testbuf::traits_type traits_type;\n+  typedef testbuf::int_type int_type;\n+\n+  bool test = true;\n+  char* lit01 = \"chicago underground trio/possible cube on delmark\";\n+  testbuf buf01;\n+\n+  // 27.5.2.1 basic_streambuf ctors\n+  // default ctor initializes \n+  // - all pointer members to null pointers\n+  // - locale to current global locale\n+  VERIFY( buf01.check_pointers() );\n+  VERIFY( buf01.getloc() == std::locale() );\n+\n+  // 27.5.2.3.1 get area\n+  // 27.5.2.2.3 get area\n+  // 27.5.2.4.3 get area\n+  int i01 = 3;\n+  buf01.pub_setg(lit01, lit01, (lit01 + i01));\n+  VERIFY( i01 == buf01.in_avail() );\n+\n+  VERIFY( buf01.pub_uflow() == lit01[0] );\n+  VERIFY( buf01.sgetc() == traits_type::to_int_type(lit01[1]) );\n+  VERIFY( buf01.pub_uflow() == lit01[1] );\n+  VERIFY( buf01.sgetc() == traits_type::to_int_type(lit01[2]) );\n+  VERIFY( buf01.pub_uflow() == lit01[2] );\n+  VERIFY( buf01.sgetc() == traits_type::eof() );\n+\n+  // pbackfail\n+  buf01.pub_setg(lit01, lit01, (lit01 + i01));\n+  VERIFY( i01 == buf01.in_avail() );\n+  int_type intt01 = traits_type::to_int_type('b');\n+  VERIFY( traits_type::eof() == buf01.pub_pbackfail(intt01) );\n+\n+  // overflow\n+  VERIFY( traits_type::eof() == buf01.pub_overflow(intt01) );\n+  VERIFY( traits_type::eof() == buf01.pub_overflow() );\n+  VERIFY( buf01.sgetc() == traits_type::to_int_type(lit01[0]) );\n+\n+  // sputn/xsputn\n+  char* lit02 = \"isotope 217: the unstable molecule on thrill jockey\";\n+  int i02 = std::strlen(lit02);\n+  char carray[i02 + 1];\n+  std::memset(carray, 0, i02 + 1);\n+\n+  buf01.pub_setp(carray, (carray + i02));\n+  buf01.sputn(lit02, 0);\n+  VERIFY( carray[0] == 0 );\n+  VERIFY( lit02[0] == 'i' );\n+  buf01.sputn(lit02, 1);\n+  VERIFY( lit02[0] == carray[0] );\n+  VERIFY( lit02[1] == 's' );\n+  VERIFY( carray[1] == 0 );\n+  buf01.sputn(lit02 + 1, 10);\n+  VERIFY( std::memcmp(lit02, carray, 10) == 0 );\n+  buf01.sputn(lit02 + 11, 20);\n+  VERIFY( std::memcmp(lit02, carray, 30) == 0 );\n+\n+#ifdef DEBUG_ASSERT\n+  assert(test);\n+#endif\n+}\n+\n+void test02()\n+{\n+  typedef testbuf::traits_type traits_type;\n+  typedef testbuf::int_type int_type;\n+\n+  bool test = true;\n+  char* lit01 = \"chicago underground trio/possible cube on delmark\";\n+  testbuf buf01;\n+\n+  // 27.5.2.1 basic_streambuf ctors\n+  // default ctor initializes \n+  // - all pointer members to null pointers\n+  // - locale to current global locale\n+  VERIFY( buf01.check_pointers() );\n+  VERIFY( buf01.getloc() == std::locale() );\n+\n+  // 27.5.2.2.5 Put area\n+  size_t i01 = traits_type::length(lit01);\n+  char carray01[i01];\n+  std::memset(carray01, 0, i01);\n+  \n+  buf01.pub_setg(lit01, lit01, lit01 + i01);\n+  buf01.sgetn(carray01, 0);\n+  VERIFY( carray01[0] == 0 );\n+  buf01.sgetn(carray01, 1);\n+  VERIFY( carray01[0] == 'c' );\n+  buf01.sgetn(carray01 + 1, i01 - 1);\n+  VERIFY( carray01[0] == 'c' );\n+  VERIFY( carray01[1] == 'h' );\n+  VERIFY( carray01[i01 - 1] == 'k' );\n+\n+#ifdef DEBUG_ASSERT\n+  assert(test);\n+#endif\n+}\n+ \n+// test03\n+// http://gcc.gnu.org/ml/libstdc++/2000-q1/msg00151.html\n+template<typename charT, typename traits = std::char_traits<charT> >\n+  class basic_nullbuf : public std::basic_streambuf<charT, traits>\n+  {\n+  protected:\n+    typedef typename\n+      std::basic_streambuf<charT, traits>::int_type int_type;\n+    virtual int_type \n+    overflow(int_type c) \n+    {  return traits::not_eof(c); }\n+  };\n+\n+typedef basic_nullbuf<char> nullbuf;\n+typedef basic_nullbuf<wchar_t> wnullbuf;\n+\n+template<typename T>\n+  char\n+  print(const T& x) \n+  {\n+   nullbuf ob;\n+   std::ostream out(&ob); \n+   out << x << std::endl;\n+   return (!out ? '0' : '1');\n+ }\n+\n+void test03() \n+{\n+  bool test = true;\n+  const std::string control01(\"11111\");\n+  std::string test01;\n+\n+  test01 += print(true);\n+  test01 += print(3.14159);\n+  test01 += print(10);\n+  test01 += print('x');\n+  test01 += print(\"pipo\");\n+\n+  VERIFY( test01 == control01 );\n+#ifdef DEBUG_ASSERT\n+  assert(test);\n+#endif\n+}\n+\n+class setpbuf : public std::streambuf\n+{\n+  char \t\tbuffer[4];\n+  std::string \tresult;\n+\n+public:\n+\n+  std::string&\n+  get_result()\n+  { return result; }\n+\n+  setpbuf()\n+  {\n+    char foo [32];\n+    setp(foo, foo + 32);\n+    setp(buffer, buffer + 4);\n+  }\n+\n+  ~setpbuf()\n+  { sync(); }\n+\n+  virtual int_type \n+  overflow(int_type n)\n+  {\n+    if (sync() != 0)\n+      return traits_type::eof();\n+    \n+    result += traits_type::to_char_type(n);\n+    \n+    return n;\n+  }\n+  \n+  virtual int \n+  sync()\n+  {\n+    result.append(pbase(), pptr());\n+    setp(buffer, buffer + 4);\n+    return 0;\n+  }\n+};\n+\n+// libstdc++/1057\n+void test04()\n+{\n+  bool test = true;\n+  std::string text = \"abcdefghijklmn\";\n+  \n+  // 01\n+  setpbuf sp1;\n+  // Here xsputn writes over sp1.result\n+  sp1.sputn(text.c_str(), text.length());\n+\n+  // This crashes when result is accessed\n+  sp1.pubsync();\n+  VERIFY( sp1.get_result() == text );\n+  \n+\n+  // 02\n+  setpbuf sp2;\n+  for (std::string::size_type i = 0; i < text.length(); ++i)\n+    {\n+      // sputc also writes over result\n+      sp2.sputc(text[i]);\n+    }\n+  \n+  // Crash here\n+  sp2.pubsync();\n+  VERIFY( sp2.get_result() == text );\n+}\n+\n+class nullsetpbuf : public std::streambuf\n+{\n+  char foo[64];\n+public:\n+  nullsetpbuf()\n+  {\n+    setp(foo, foo + 64);\n+    setp(NULL, NULL);\n+  }\n+};\n+\n+// libstdc++/1057\n+void test05()\n+{\n+    std::string text1 = \"abcdefghijklmn\";\n+\n+    nullsetpbuf nsp;\n+    // Immediate crash as xsputn writes to null pointer\n+    nsp.sputn(text1.c_str(), text1.length());\n+    // ditto\n+    nsp.sputc('a');\n+}\n+\n+// test06\n+namespace gnu \n+{\n+  class something_derived;\n+}\n+\n+class gnu::something_derived : std::streambuf { };\n+\n+// libstdc++/3599\n+class testbuf2 : public std::streambuf\n+{\n+public:\n+  typedef std::streambuf::traits_type traits_type;\n+\n+  testbuf2() : std::streambuf() { }\n+ \n+protected:\n+  int_type \n+  overflow(int_type c = traits_type::eof()) \n+  { return traits_type::not_eof(0); }\n+};\n+\n+void\n+test07()\n+{\n+  bool test = true;\n+  testbuf2 ob;\n+  std::ostream out(&ob); \n+\n+  out << \"gasp\";\n+  VERIFY(out.good());\n+\n+  out << std::endl;\n+  VERIFY(out.good());\n+}\n+\n+int main() \n+{\n+  test01();\n+  test02();\n+  test03();\n+\n+  test04();\n+  test05();\n+\n+  test07();\n+  return 0;\n+}"}, {"sha": "00825b6b69c7130b20babc83ea34895f4a958ec5", "filename": "libstdc++-v3/testsuite/27_io/stringbuf.cc", "status": "modified", "additions": 29, "deletions": 459, "changes": 488, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringbuf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringbuf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringbuf.cc?ref=bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "patch": "@@ -1,7 +1,6 @@\n-// 981208 bkoz test functionality of basic_stringbuf for char_type == char\n+// 2002-07-25 Benjamin Kosnik <bkoz@redhat.com>\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n-// Free Software Foundation, Inc.\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -19,472 +18,43 @@\n // Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n // USA.\n \n-#include <sstream>\n-#include <testsuite_hooks.h>\n-\n-std::string str_01(\"mykonos. . . or what?\");\n-std::string str_02(\"paris, or sainte-maxime?\");\n-std::string str_03;\n-std::stringbuf strb_01(str_01);\n-std::stringbuf strb_02(str_02, std::ios_base::in);\n-std::stringbuf strb_03(str_03, std::ios_base::out);\n-\n-\n-// test the underlying allocator\n-bool test01() {\n-  bool test = false;\n-  std::allocator<char> alloc_01;\n-  std::allocator<char>::size_type size_01 = alloc_01.max_size();\n-  std::allocator<char>::pointer p_01 = alloc_01.allocate(32);\n-\n-  return true;\n-}\n-\n-\n-// test the streambuf/stringbuf locale settings\n-bool test02() {\n-  std::locale loc_tmp;\n-  loc_tmp = strb_01.getloc();\n-  strb_01.pubimbue(loc_tmp); //This should initialize _M_init to true\n-  strb_01.getloc(); //This should just return _M_locale\n-\n-  return true;\n-}\n-\n-\n-// test member functions\n-bool test03() {\n-  bool test = true;\n-\n-  //stringbuf::str()\n-  VERIFY( strb_01.str() == str_01 );\n-  VERIFY( strb_02.str() == str_02 );\n-  VERIFY( strb_03.str() == str_03 );\n- \n-  //stringbuf::str(string&)\n-  strb_03.str(\"none of the above, go to the oberoi in cairo, egypt.\");\n-  strb_03.str(str_01);\n-  std::streamsize d1 = strb_01.in_avail();\n-  std::streamsize d2 = strb_03.in_avail();\n-  VERIFY( d1 ); // non-zero\n-  VERIFY( !d2 ); // zero, cuz ios_base::out\n-  VERIFY( d1 != d2 ); //these should be the same\n-  VERIFY( str_01.length() == d1 );  \n-  VERIFY( strb_01.str() == strb_03.str() ); //ditto\n-\n-  // stringbuf::str(string&) and stringbuf::stringbuf(string&), where the\n-  // string in question contains embedded NUL characters.  Note that in this\n-  // embedded-NUL situation, the size must be passed to the string ctor.\n-  std::string str_nulls (\"eschew \\0 obfuscation\", 20);  // tested in 21_strings\n-  std::stringbuf strb_normal (str_01);\n-  std::stringbuf strb_nulls (str_nulls);\n-  strb_normal.str(str_nulls);  // tried using 'strb_01' rather than declaring\n-                               // another variable, but then test04 broke!\n-  VERIFY( strb_nulls.in_avail() == str_nulls.size()  );\n-  VERIFY( strb_nulls.str().size() == 20              );\n-  VERIFY( strb_normal.in_avail() == str_nulls.size() );\n-\n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n- \n-  return test;\n-}\n-\n-\n-// test overloaded virtual functions\n-bool test04() {\n-  bool \t\t\ttest = true;\n-  std::string \t\tstr_tmp;\n-  std::stringbuf \t\tstrb_tmp;\n-  std::streamsize \t\tstrmsz_1, strmsz_2;\n-  std::streamoff  \t\tstrmof_1(-1), strmof_2;\n-  typedef std::stringbuf::int_type int_type;\n-  typedef std::stringbuf::traits_type traits_type;\n-  typedef std::stringbuf::pos_type pos_type;\n-  typedef std::stringbuf::off_type off_type;\n-\n-  // GET\n-  // int in_avail()\n-  strmof_1 = strb_01.in_avail();\n-  strmof_2 = strb_02.in_avail();\n-  VERIFY( strmof_1 != strmof_2 );\n-  VERIFY( strmof_1 == str_01.length() );\n-  VERIFY( strmof_2 == str_02.length() );\n-  strmof_1 = strb_03.in_avail(); \n-  VERIFY( strmof_1 == 0 ); // zero cuz write-only, or eof()? zero, from showmany\n-\n-  // int_type sbumpc()\n-  // if read_cur not avail, return uflow(), else return *read_cur & increment\n-  int_type c1 = strb_01.sbumpc();\n-  int_type c2 = strb_02.sbumpc();\n-  VERIFY( c1 != c2 );\n-  VERIFY( c1 == str_01[0] );\n-  VERIFY( c2 == str_02[0] ); //should equal first letter at this point\n-  int_type c3 = strb_01.sbumpc();\n-  int_type c4 = strb_02.sbumpc();\n-  VERIFY( c1 != c2 );\n-  VERIFY( c1 != c3 );\n-  VERIFY( c2 != c4 );\n-  int_type c5 = strb_03.sbumpc();\n-  VERIFY( c5 == traits_type::eof() );\n-\n-  // int_type sgetc()\n-  // if read_cur not avail, return uflow(), else return *read_cur  \n-  int_type c6 = strb_01.sgetc();\n-  int_type c7 = strb_02.sgetc();\n-  VERIFY( c6 != c3 );\n-  VERIFY( c7 != c4 );\n-  int_type c8 = strb_01.sgetc();\n-  int_type c9 = strb_02.sgetc();\n-  VERIFY( c6 == c8 );\n-  VERIFY( c7 == c9 );\n-  c5 = strb_03.sgetc();\n-  VERIFY( c5 == traits_type::eof() );\n-\n-  // int_type snextc()\n-  // calls sbumpc and if sbumpc != eof, return sgetc\n-  c6 = strb_01.snextc();\n-  c7 = strb_02.snextc();\n-  VERIFY( c6 != c8 );\n-  VERIFY( c7 != c9 );\n-  VERIFY( c6 == str_01[3] );\n-  VERIFY( c7 == str_02[3] ); //should equal fourth letter at this point\n-  c5 = strb_03.snextc();\n-  VERIFY( c5 == traits_type::eof() );\n-\n-  // int showmanyc\n-  // streamsize sgetn(char_type *s, streamsize n)\n-  // streamsize xsgetn(char_type *s, streamsize n)\n-  // assign up to n chars to s from input sequence, indexing in_cur as\n-  // approp and returning the number of chars assigned\n-  strmsz_1 = strb_01.in_avail();\n-  strmsz_2 = strb_02.in_avail();\n-  test = strmsz_1 != strmsz_2;\n-  VERIFY( strmsz_1 != str_01.length() );\n-  VERIFY( strmsz_2 != str_02.length() ); //because now we've moved into string\n-  char carray1[11] = \"\";\n-  strmsz_1 = strb_01.sgetn(carray1, 10);\n-  char carray2[20] = \"\";\n-  strmsz_2 = strb_02.sgetn(carray2, 10);\n-  VERIFY( strmsz_1 == strmsz_2 );\n-  VERIFY( strmsz_1 == 10 );\n-  c1 = strb_01.sgetc();\n-  c2 = strb_02.sgetc();\n-  VERIFY( c6 == c1 ); //just by co-incidence both o's\n-  VERIFY( c7 != c2 ); // n != i\n-  VERIFY( c1 == str_01[13] );\n-  VERIFY( c2 == str_02[13] ); //should equal fourteenth letter at this point\n-  strmsz_1 = strb_03.sgetn(carray1, 10);\n-  VERIFY( !strmsz_1 ); //zero\n-  strmsz_1 = strb_02.in_avail();\n-  strmsz_2 = strb_02.sgetn(carray2, strmsz_1 + 5);\n-  VERIFY( strmsz_1 == strmsz_2 ); //write off the end\n-  c4 = strb_02.sgetc(); // should be EOF\n-  VERIFY( c4 == traits_type::eof() );\n-\n-  // PUT\n-  // int_type sputc(char_type c)\n-  // if out_cur not avail, return overflow. Else, stores c at out_cur,\n-  // increments out_cur, and returns c as int_type\n-  strb_03.str(str_01); //reset\n-  std::string::size_type sz1 = strb_03.str().length();\n-  c1 = strb_03.sputc('a'); \n-  std::string::size_type sz2 = strb_03.str().length();\n-  VERIFY( sz1 == sz2 ); //cuz inserting at out_cur, which is at beg to start\n-  c2 = strb_03.sputc('b'); \n-  VERIFY( c1 != c2 );\n-  VERIFY( strb_03.str() != str_01 );\n-  c3 = strb_02.sputc('a'); // should be EOF because this is read-only\n-  VERIFY( c3 == traits_type::eof() );\n-  \n-  // streamsize sputn(const char_typs* s, streamsize n)\n-  // write up to n chars to out_cur from s, returning number assigned\n-  // NB *sputn will happily put '\\0' into your stream if you give it a chance*\n-  str_tmp = strb_03.str();\n-  sz1 = str_tmp.length();\n-  strmsz_1 = strb_03.sputn(\"racadabras\", 10);//\"abracadabras or what?\"\n-  sz2 = strb_03.str().length();\n-  VERIFY( sz1 == sz2 ); //shouldn't have changed length\n-  VERIFY( strmsz_1 == 10 );\n-  VERIFY( str_tmp != strb_03.str() );\n-  strmsz_2 = strb_03.sputn(\", i wanna reach out and\", 10);\n-  VERIFY( strmsz_1 == strmsz_2 ); // should re-allocate, copy 10 chars.\n-  VERIFY( strmsz_1 == 10 );\n-  VERIFY( strmsz_2 == 10 );\n-  sz2 = strb_03.str().length();\n-  VERIFY( sz1 != sz2 ); // need to change length\n-  VERIFY( str_tmp != strb_03.str() );\n-  str_tmp = strb_02.str();\n-  strmsz_1 = strb_02.sputn(\"racadabra\", 10);\n-  VERIFY( strmsz_1 == 0 );  \n-  VERIFY( str_tmp == strb_02.str() );\n-\n-  // PUTBACK\n-  // int_type pbfail(int_type c)\n-  // called when gptr() null, gptr() == eback(), or traits::eq(*gptr, c) false\n-  // \"pending sequence\" is:\n-  //\t1) everything as defined in underflow\n-  // \t2) + if (traits::eq_int_type(c, traits::eof()), then input\n-  // \tsequence is backed up one char before the pending sequence is\n-  // \tdetermined.\n-  //\t3) + if (not 2) then c is prepended. Left unspecified is\n-  //\twhether the input sequence is backedup or modified in any way\n-  // returns traits::eof() for failure, unspecified other value for success\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n \n-  // int_type sputbackc(char_type c)\n-  // if in_cur not avail || ! traits::eq(c, gptr() [-1]), return pbfail\n-  // otherwise decrements in_cur and returns *gptr()\n-  strmsz_1 = strb_01.in_avail();\n-  str_tmp = strb_01.str();\n-  c1 = strb_01.sgetc(); //\"mykonos. . . 'o'r what?\"\n-  c2 = strb_01.sputbackc('z');//\"mykonos. . .zor what?\"\n-  c3 = strb_01.sgetc();\n-  VERIFY( c1 != c2 );\n-  VERIFY( c3 == c2 );\n-  VERIFY( strb_01.str() == std::string(\"mykonos. . .zor what?\") );\n-  VERIFY( str_tmp.size() == strb_01.str().size() );\n-  //test for _in_cur == _in_beg\n-  strb_01.str(str_tmp);\n-  strmsz_1 = strb_01.in_avail();\n-  c1 = strb_01.sgetc(); //\"'m'ykonos. . . or what?\"\n-  c2 = strb_01.sputbackc('z');//\"mykonos. . . or what?\"\n-  c3 = strb_01.sgetc();\n-  VERIFY( c1 != c2 );\n-  VERIFY( c3 != c2 );\n-  VERIFY( c1 == c3 );\n-  VERIFY( c2 == traits_type::eof() );\n-  VERIFY( strb_01.str() == str_tmp );\n-  VERIFY( str_tmp.size() == strb_01.str().size() );\n-  // test for replacing char with identical one\n-  strb_01.str(str_01); //reset\n-  strmsz_1 = strb_01.in_avail();\n-  strb_01.sbumpc();\n-  strb_01.sbumpc();\n-  c1 = strb_01.sgetc(); //\"my'k'onos. . . or what?\"\n-  c2 = strb_01.sputbackc('y');//\"mykonos. . . or what?\"\n-  c3 = strb_01.sgetc();\n-  VERIFY( c1 != c2 );\n-  VERIFY( c3 == c2 );\n-  VERIFY( c1 != c3 );\n-  VERIFY( strb_01.str() == str_01 );\n-  VERIFY( str_01.size() == strb_01.str().size() );\n-  //test for ios_base::out\n-  strmsz_2 = strb_03.in_avail();\n-  c4 = strb_03.sputbackc('x');\n-  VERIFY( c4 == traits_type::eof() );\n+// 27.7.1 - Template class basic_stringbuf\n+// NB: This file is for testing basic_stringbuf with NO OTHER INCLUDES.\n \n-  // int_type sungetc()\n-  // if in_cur not avail, return pbackfail(), else decrement and\n-  // return to_int_type(*gptr())\n-  for (int i = 0; i<12; ++i)\n-    strb_01.sbumpc();\n-  strmsz_1 = strb_01.in_avail();\n-  str_tmp = strb_01.str();\n-  c1 = strb_01.sgetc(); //\"mykonos. . . 'o'r what?\"\n-  c2 = strb_01.sungetc();//\"mykonos. . . or what?\"\n-  c3 = strb_01.sgetc();\n-  VERIFY( c1 != c2 );\n-  VERIFY( c3 == c2 );\n-  VERIFY( c1 != c3 );\n-  VERIFY( c2 == ' ' );\n-  VERIFY( strb_01.str() == str_01 );\n-  VERIFY( str_01.size() == strb_01.str().size() );\n-  //test for _in_cur == _in_beg\n-  strb_01.str(str_tmp);\n-  strmsz_1 = strb_01.in_avail();\n-  c1 = strb_01.sgetc(); //\"'m'ykonos. . . or what?\"\n-  c2 = strb_01.sungetc();//\"mykonos. . . or what?\"\n-  c3 = strb_01.sgetc();\n-  VERIFY( c1 != c2 );\n-  VERIFY( c3 != c2 );\n-  VERIFY( c1 == c3 );\n-  VERIFY( c2 == traits_type::eof() );\n-  VERIFY( strb_01.str() == str_01 );\n-  VERIFY( str_01.size() == strb_01.str().size() );\n-  // test for replacing char with identical one\n-  strb_01.str(str_01); //reset\n-  strmsz_1 = strb_01.in_avail();\n-  strb_01.sbumpc();\n-  strb_01.sbumpc();\n-  c1 = strb_01.sgetc(); //\"my'k'onos. . . or what?\"\n-  c2 = strb_01.sungetc();//\"mykonos. . . or what?\"\n-  c3 = strb_01.sgetc();\n-  VERIFY( c1 != c2 );\n-  VERIFY( c3 == c2 );\n-  VERIFY( c1 != c3 );\n-  VERIFY( strb_01.str() == str_01 );\n-  VERIFY( str_01.size() == strb_01.str().size() );\n-  //test for ios_base::out\n-  strmsz_2 = strb_03.in_avail();\n-  c4 = strb_03.sungetc();\n-  VERIFY( c4 == traits_type::eof() );\n-\n-  // BUFFER MANAGEMENT & POSITIONING\n-  // sync\n-  // pubsync\n-  strb_01.pubsync();\n-  strb_02.pubsync();\n-  strb_03.pubsync();\n-\n-  // setbuf\n-  // pubsetbuf(char_type* s, streamsize n)\n-  str_tmp = std::string(\"naaaah, go to cebu\");\n-  strb_01.pubsetbuf(const_cast<char*> (str_tmp.c_str()), str_tmp.size());\n-  VERIFY( strb_01.str() == str_tmp );\n-  strb_01.pubsetbuf(0,0);\n-  VERIFY( strb_01.str() == str_tmp );\n-\n-  // seekoff\n-  // pubseekoff(off_type off, ios_base::seekdir way, ios_base::openmode which)\n-  // alters the stream position to off\n-  pos_type pt_1(off_type(-1));\n-  pos_type pt_2(off_type(0));\n-  off_type off_1 = 0;\n-  off_type off_2 = 0;\n-  strb_01.str(str_01); //in|out (\"mykonos. . . or what?\");\n-  strb_02.str(str_02); //in (\"paris, or sainte-maxime?\");\n-  strb_03.str(str_03); //out (\"\")\n-  //IN|OUT\n-  //beg\n-  pt_1 = strb_01.pubseekoff(2, std::ios_base::beg);\n-  off_1 = pt_1;\n-  VERIFY( off_1 >= 0 );\n-  c1 = strb_01.snextc(); //current in pointer +1\n-  VERIFY( c1 == 'o' );\n-  c2 = strb_01.sputc('x');  //test current out pointer\n-  str_tmp = std::string(\"myxonos. . . or what?\");\n-  VERIFY( strb_01.str() == str_tmp );\n-  //cur\n-  pt_1 = strb_01.pubseekoff(2, std::ios_base::cur);\n-  off_1 = pt_1;\n-  VERIFY( off_1 == -1 ); // can't seekoff for in and out + cur in sstreams\n-  pt_1 = strb_01.pubseekoff(2, std::ios_base::cur, std::ios_base::in);\n-  off_1 = pt_1;\n-  pt_2 = strb_01.pubseekoff(2, std::ios_base::cur, std::ios_base::in);\n-  off_2 = pt_2;\n-  VERIFY( off_2 == off_1 + 2 );\n-  c1 = strb_01.snextc(); //current in pointer + 1\n-  VERIFY( c1 == ' ' );\n-  c2 = strb_01.sputc('x');  //test current out pointer\n-  str_tmp = std::string(\"myxxnos. . . or what?\");\n-  VERIFY( strb_01.str() == str_tmp );\n-  //end\n-  pt_2 = strb_01.pubseekoff(2, std::ios_base::end);\n-  off_1 = pt_2;\n-  VERIFY( off_1 == -1 ); // not a valid position\n-  VERIFY( strb_01.str() == str_tmp );\n-  // end part two (from the filebuf tests)\n-  strb_01.pubseekoff(0, std::ios_base::end);\n-  strmsz_1 = strb_01.in_avail(); // 0 cuz at the end\n-  c1 = strb_01.sgetc(); \n-  c2 = strb_01.sungetc();\n-  strmsz_2 = strb_01.in_avail(); // 1\n-  c3 = strb_01.sgetc();\n-  VERIFY( c1 != c2 );\n-  VERIFY( strmsz_2 != strmsz_1 );\n-  VERIFY( strmsz_2 == 1 );\n-  // end part three\n-  strmsz_1 = strb_01.str().size();\n-  strmsz_2 = strb_01.sputn(\" ravi shankar meets carlos santana in LoHa\", 90);\n-  strb_01.pubseekoff(0, std::ios_base::end);\n-  strb_01.sputc('<');\n-  str_tmp = strb_01.str();\n-  VERIFY( str_tmp.size() == strmsz_1 + strmsz_2 + 1 );\n-  // IN\n-  // OUT\n-\n-  // seekpos\n-  // pubseekpos(pos_type sp, ios_base::openmode)\n-  // alters the stream position to sp\n-  strb_01.str(str_01); //in|out (\"mykonos. . . or what?\");\n-  strb_02.str(str_02); //in (\"paris, or sainte-maxime?\");\n-  strb_03.str(str_03); //out (\"\")\n-  //IN|OUT\n-  //beg\n-  pt_1 = strb_01.pubseekoff(2, std::ios_base::beg);\n-  off_1 = pt_1;\n-  VERIFY( off_1 >= 0 );\n-  pt_1 = strb_01.pubseekoff(0, std::ios_base::cur, std::ios_base::out);\n-  off_1 = pt_1;\n-  c1 = strb_01.snextc(); //current in pointer +1\n-  VERIFY( c1 == 'o' );\n-  c2 = strb_01.sputc('x');  //test current out pointer\n-  str_tmp = std::string(\"myxonos. . . or what?\");\n-  VERIFY( strb_01.str() == str_tmp );\n-  strb_01.pubsync(); //resets pointers\n-  pt_2 = strb_01.pubseekpos(pt_1, std::ios_base::in|std::ios_base::out);\n-  off_2 = pt_2;\n-  VERIFY( off_1 == off_2 );\n-  c3 = strb_01.snextc(); //current in pointer +1\n-  VERIFY( c1 == c3 );\n-  c2 = strb_01.sputc('x');  //test current out pointer\n-  str_tmp = std::string(\"myxonos. . . or what?\");\n-  VERIFY( strb_01.str() == str_tmp );\n-\n-  // VIRTUALS (indirectly tested)\n-  // underflow\n-  // if read position avail, returns *gptr()\n-\n-  // pbackfail(int_type c)\n-  // put c back into input sequence\n-\n-  // overflow\n-  // appends c to output seq\n-\n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n-\n-  return test;\n-}\n+#include <sstream>\n \n+// { dg-do compile }\n \n-// libstdc++/3955 -- ios_base::app overwrites from the beginning\n-bool test05()\n+// libstdc++/7216\n+void test01()\n {\n-  bool test = true;\n-\n-  std::ostringstream os (\"foo\");\n-  os << \"bar\";\n-\n-  test = os.str() == \"bar\";\n-\n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n-\n-  return test;\n+  // Check for required typedefs\n+  typedef std::stringbuf test_type;\n+  typedef test_type::char_type char_type;\n+  typedef test_type::traits_type traits_type;\n+  typedef test_type::int_type int_type;\n+  typedef test_type::pos_type pos_type;\n+  typedef test_type::off_type off_type;\n }\n \n-bool test06()\n+namespace test \n {\n-  bool test = true;\n-\n-  std::ostringstream os (\"foo\", std::ios_base::app);\n-  os << \"bar\";\n-\n-  test = os.str() == \"foobar\";\n-\n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n+  using namespace std;\n+  typedef short type_t;\n+  template class basic_stringbuf<type_t, char_traits<type_t> >;\n+} // test\n \n-  return test;\n-}\n-\n-int main()\n+int main() \n {\n   test01();\n-  test02();\n-  test03();\n-  test04();\n-  test05();\n-  test06();\n-\n   return 0;\n }\n-\n-\n-\n-// more candy!!!"}, {"sha": "bc0bbb4dd8e1365e5ffe2135e991ba0ce7da342d", "filename": "libstdc++-v3/testsuite/27_io/stringbuf_members.cc", "status": "added", "additions": 490, "deletions": 0, "changes": 490, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringbuf_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringbuf_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringbuf_members.cc?ref=bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "patch": "@@ -0,0 +1,490 @@\n+// 981208 bkoz test functionality of basic_stringbuf for char_type == char\n+\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+std::string str_01(\"mykonos. . . or what?\");\n+std::string str_02(\"paris, or sainte-maxime?\");\n+std::string str_03;\n+std::stringbuf strb_01(str_01);\n+std::stringbuf strb_02(str_02, std::ios_base::in);\n+std::stringbuf strb_03(str_03, std::ios_base::out);\n+\n+\n+// test the underlying allocator\n+bool test01() {\n+  bool test = false;\n+  std::allocator<char> alloc_01;\n+  std::allocator<char>::size_type size_01 = alloc_01.max_size();\n+  std::allocator<char>::pointer p_01 = alloc_01.allocate(32);\n+\n+  return true;\n+}\n+\n+\n+// test the streambuf/stringbuf locale settings\n+bool test02() {\n+  std::locale loc_tmp;\n+  loc_tmp = strb_01.getloc();\n+  strb_01.pubimbue(loc_tmp); //This should initialize _M_init to true\n+  strb_01.getloc(); //This should just return _M_locale\n+\n+  return true;\n+}\n+\n+\n+// test member functions\n+bool test03() {\n+  bool test = true;\n+\n+  //stringbuf::str()\n+  VERIFY( strb_01.str() == str_01 );\n+  VERIFY( strb_02.str() == str_02 );\n+  VERIFY( strb_03.str() == str_03 );\n+ \n+  //stringbuf::str(string&)\n+  strb_03.str(\"none of the above, go to the oberoi in cairo, egypt.\");\n+  strb_03.str(str_01);\n+  std::streamsize d1 = strb_01.in_avail();\n+  std::streamsize d2 = strb_03.in_avail();\n+  VERIFY( d1 ); // non-zero\n+  VERIFY( !d2 ); // zero, cuz ios_base::out\n+  VERIFY( d1 != d2 ); //these should be the same\n+  VERIFY( str_01.length() == d1 );  \n+  VERIFY( strb_01.str() == strb_03.str() ); //ditto\n+\n+  // stringbuf::str(string&) and stringbuf::stringbuf(string&), where the\n+  // string in question contains embedded NUL characters.  Note that in this\n+  // embedded-NUL situation, the size must be passed to the string ctor.\n+  std::string str_nulls (\"eschew \\0 obfuscation\", 20);  // tested in 21_strings\n+  std::stringbuf strb_normal (str_01);\n+  std::stringbuf strb_nulls (str_nulls);\n+  strb_normal.str(str_nulls);  // tried using 'strb_01' rather than declaring\n+                               // another variable, but then test04 broke!\n+  VERIFY( strb_nulls.in_avail() == str_nulls.size()  );\n+  VERIFY( strb_nulls.str().size() == 20              );\n+  VERIFY( strb_normal.in_avail() == str_nulls.size() );\n+\n+#ifdef DEBUG_ASSERT\n+  assert(test);\n+#endif\n+ \n+  return test;\n+}\n+\n+\n+// test overloaded virtual functions\n+bool test04() {\n+  bool \t\t\ttest = true;\n+  std::string \t\tstr_tmp;\n+  std::stringbuf \t\tstrb_tmp;\n+  std::streamsize \t\tstrmsz_1, strmsz_2;\n+  std::streamoff  \t\tstrmof_1(-1), strmof_2;\n+  typedef std::stringbuf::int_type int_type;\n+  typedef std::stringbuf::traits_type traits_type;\n+  typedef std::stringbuf::pos_type pos_type;\n+  typedef std::stringbuf::off_type off_type;\n+\n+  // GET\n+  // int in_avail()\n+  strmof_1 = strb_01.in_avail();\n+  strmof_2 = strb_02.in_avail();\n+  VERIFY( strmof_1 != strmof_2 );\n+  VERIFY( strmof_1 == str_01.length() );\n+  VERIFY( strmof_2 == str_02.length() );\n+  strmof_1 = strb_03.in_avail(); \n+  VERIFY( strmof_1 == 0 ); // zero cuz write-only, or eof()? zero, from showmany\n+\n+  // int_type sbumpc()\n+  // if read_cur not avail, return uflow(), else return *read_cur & increment\n+  int_type c1 = strb_01.sbumpc();\n+  int_type c2 = strb_02.sbumpc();\n+  VERIFY( c1 != c2 );\n+  VERIFY( c1 == str_01[0] );\n+  VERIFY( c2 == str_02[0] ); //should equal first letter at this point\n+  int_type c3 = strb_01.sbumpc();\n+  int_type c4 = strb_02.sbumpc();\n+  VERIFY( c1 != c2 );\n+  VERIFY( c1 != c3 );\n+  VERIFY( c2 != c4 );\n+  int_type c5 = strb_03.sbumpc();\n+  VERIFY( c5 == traits_type::eof() );\n+\n+  // int_type sgetc()\n+  // if read_cur not avail, return uflow(), else return *read_cur  \n+  int_type c6 = strb_01.sgetc();\n+  int_type c7 = strb_02.sgetc();\n+  VERIFY( c6 != c3 );\n+  VERIFY( c7 != c4 );\n+  int_type c8 = strb_01.sgetc();\n+  int_type c9 = strb_02.sgetc();\n+  VERIFY( c6 == c8 );\n+  VERIFY( c7 == c9 );\n+  c5 = strb_03.sgetc();\n+  VERIFY( c5 == traits_type::eof() );\n+\n+  // int_type snextc()\n+  // calls sbumpc and if sbumpc != eof, return sgetc\n+  c6 = strb_01.snextc();\n+  c7 = strb_02.snextc();\n+  VERIFY( c6 != c8 );\n+  VERIFY( c7 != c9 );\n+  VERIFY( c6 == str_01[3] );\n+  VERIFY( c7 == str_02[3] ); //should equal fourth letter at this point\n+  c5 = strb_03.snextc();\n+  VERIFY( c5 == traits_type::eof() );\n+\n+  // int showmanyc\n+  // streamsize sgetn(char_type *s, streamsize n)\n+  // streamsize xsgetn(char_type *s, streamsize n)\n+  // assign up to n chars to s from input sequence, indexing in_cur as\n+  // approp and returning the number of chars assigned\n+  strmsz_1 = strb_01.in_avail();\n+  strmsz_2 = strb_02.in_avail();\n+  test = strmsz_1 != strmsz_2;\n+  VERIFY( strmsz_1 != str_01.length() );\n+  VERIFY( strmsz_2 != str_02.length() ); //because now we've moved into string\n+  char carray1[11] = \"\";\n+  strmsz_1 = strb_01.sgetn(carray1, 10);\n+  char carray2[20] = \"\";\n+  strmsz_2 = strb_02.sgetn(carray2, 10);\n+  VERIFY( strmsz_1 == strmsz_2 );\n+  VERIFY( strmsz_1 == 10 );\n+  c1 = strb_01.sgetc();\n+  c2 = strb_02.sgetc();\n+  VERIFY( c6 == c1 ); //just by co-incidence both o's\n+  VERIFY( c7 != c2 ); // n != i\n+  VERIFY( c1 == str_01[13] );\n+  VERIFY( c2 == str_02[13] ); //should equal fourteenth letter at this point\n+  strmsz_1 = strb_03.sgetn(carray1, 10);\n+  VERIFY( !strmsz_1 ); //zero\n+  strmsz_1 = strb_02.in_avail();\n+  strmsz_2 = strb_02.sgetn(carray2, strmsz_1 + 5);\n+  VERIFY( strmsz_1 == strmsz_2 ); //write off the end\n+  c4 = strb_02.sgetc(); // should be EOF\n+  VERIFY( c4 == traits_type::eof() );\n+\n+  // PUT\n+  // int_type sputc(char_type c)\n+  // if out_cur not avail, return overflow. Else, stores c at out_cur,\n+  // increments out_cur, and returns c as int_type\n+  strb_03.str(str_01); //reset\n+  std::string::size_type sz1 = strb_03.str().length();\n+  c1 = strb_03.sputc('a'); \n+  std::string::size_type sz2 = strb_03.str().length();\n+  VERIFY( sz1 == sz2 ); //cuz inserting at out_cur, which is at beg to start\n+  c2 = strb_03.sputc('b'); \n+  VERIFY( c1 != c2 );\n+  VERIFY( strb_03.str() != str_01 );\n+  c3 = strb_02.sputc('a'); // should be EOF because this is read-only\n+  VERIFY( c3 == traits_type::eof() );\n+  \n+  // streamsize sputn(const char_typs* s, streamsize n)\n+  // write up to n chars to out_cur from s, returning number assigned\n+  // NB *sputn will happily put '\\0' into your stream if you give it a chance*\n+  str_tmp = strb_03.str();\n+  sz1 = str_tmp.length();\n+  strmsz_1 = strb_03.sputn(\"racadabras\", 10);//\"abracadabras or what?\"\n+  sz2 = strb_03.str().length();\n+  VERIFY( sz1 == sz2 ); //shouldn't have changed length\n+  VERIFY( strmsz_1 == 10 );\n+  VERIFY( str_tmp != strb_03.str() );\n+  strmsz_2 = strb_03.sputn(\", i wanna reach out and\", 10);\n+  VERIFY( strmsz_1 == strmsz_2 ); // should re-allocate, copy 10 chars.\n+  VERIFY( strmsz_1 == 10 );\n+  VERIFY( strmsz_2 == 10 );\n+  sz2 = strb_03.str().length();\n+  VERIFY( sz1 != sz2 ); // need to change length\n+  VERIFY( str_tmp != strb_03.str() );\n+  str_tmp = strb_02.str();\n+  strmsz_1 = strb_02.sputn(\"racadabra\", 10);\n+  VERIFY( strmsz_1 == 0 );  \n+  VERIFY( str_tmp == strb_02.str() );\n+\n+  // PUTBACK\n+  // int_type pbfail(int_type c)\n+  // called when gptr() null, gptr() == eback(), or traits::eq(*gptr, c) false\n+  // \"pending sequence\" is:\n+  //\t1) everything as defined in underflow\n+  // \t2) + if (traits::eq_int_type(c, traits::eof()), then input\n+  // \tsequence is backed up one char before the pending sequence is\n+  // \tdetermined.\n+  //\t3) + if (not 2) then c is prepended. Left unspecified is\n+  //\twhether the input sequence is backedup or modified in any way\n+  // returns traits::eof() for failure, unspecified other value for success\n+\n+  // int_type sputbackc(char_type c)\n+  // if in_cur not avail || ! traits::eq(c, gptr() [-1]), return pbfail\n+  // otherwise decrements in_cur and returns *gptr()\n+  strmsz_1 = strb_01.in_avail();\n+  str_tmp = strb_01.str();\n+  c1 = strb_01.sgetc(); //\"mykonos. . . 'o'r what?\"\n+  c2 = strb_01.sputbackc('z');//\"mykonos. . .zor what?\"\n+  c3 = strb_01.sgetc();\n+  VERIFY( c1 != c2 );\n+  VERIFY( c3 == c2 );\n+  VERIFY( strb_01.str() == std::string(\"mykonos. . .zor what?\") );\n+  VERIFY( str_tmp.size() == strb_01.str().size() );\n+  //test for _in_cur == _in_beg\n+  strb_01.str(str_tmp);\n+  strmsz_1 = strb_01.in_avail();\n+  c1 = strb_01.sgetc(); //\"'m'ykonos. . . or what?\"\n+  c2 = strb_01.sputbackc('z');//\"mykonos. . . or what?\"\n+  c3 = strb_01.sgetc();\n+  VERIFY( c1 != c2 );\n+  VERIFY( c3 != c2 );\n+  VERIFY( c1 == c3 );\n+  VERIFY( c2 == traits_type::eof() );\n+  VERIFY( strb_01.str() == str_tmp );\n+  VERIFY( str_tmp.size() == strb_01.str().size() );\n+  // test for replacing char with identical one\n+  strb_01.str(str_01); //reset\n+  strmsz_1 = strb_01.in_avail();\n+  strb_01.sbumpc();\n+  strb_01.sbumpc();\n+  c1 = strb_01.sgetc(); //\"my'k'onos. . . or what?\"\n+  c2 = strb_01.sputbackc('y');//\"mykonos. . . or what?\"\n+  c3 = strb_01.sgetc();\n+  VERIFY( c1 != c2 );\n+  VERIFY( c3 == c2 );\n+  VERIFY( c1 != c3 );\n+  VERIFY( strb_01.str() == str_01 );\n+  VERIFY( str_01.size() == strb_01.str().size() );\n+  //test for ios_base::out\n+  strmsz_2 = strb_03.in_avail();\n+  c4 = strb_03.sputbackc('x');\n+  VERIFY( c4 == traits_type::eof() );\n+\n+  // int_type sungetc()\n+  // if in_cur not avail, return pbackfail(), else decrement and\n+  // return to_int_type(*gptr())\n+  for (int i = 0; i<12; ++i)\n+    strb_01.sbumpc();\n+  strmsz_1 = strb_01.in_avail();\n+  str_tmp = strb_01.str();\n+  c1 = strb_01.sgetc(); //\"mykonos. . . 'o'r what?\"\n+  c2 = strb_01.sungetc();//\"mykonos. . . or what?\"\n+  c3 = strb_01.sgetc();\n+  VERIFY( c1 != c2 );\n+  VERIFY( c3 == c2 );\n+  VERIFY( c1 != c3 );\n+  VERIFY( c2 == ' ' );\n+  VERIFY( strb_01.str() == str_01 );\n+  VERIFY( str_01.size() == strb_01.str().size() );\n+  //test for _in_cur == _in_beg\n+  strb_01.str(str_tmp);\n+  strmsz_1 = strb_01.in_avail();\n+  c1 = strb_01.sgetc(); //\"'m'ykonos. . . or what?\"\n+  c2 = strb_01.sungetc();//\"mykonos. . . or what?\"\n+  c3 = strb_01.sgetc();\n+  VERIFY( c1 != c2 );\n+  VERIFY( c3 != c2 );\n+  VERIFY( c1 == c3 );\n+  VERIFY( c2 == traits_type::eof() );\n+  VERIFY( strb_01.str() == str_01 );\n+  VERIFY( str_01.size() == strb_01.str().size() );\n+  // test for replacing char with identical one\n+  strb_01.str(str_01); //reset\n+  strmsz_1 = strb_01.in_avail();\n+  strb_01.sbumpc();\n+  strb_01.sbumpc();\n+  c1 = strb_01.sgetc(); //\"my'k'onos. . . or what?\"\n+  c2 = strb_01.sungetc();//\"mykonos. . . or what?\"\n+  c3 = strb_01.sgetc();\n+  VERIFY( c1 != c2 );\n+  VERIFY( c3 == c2 );\n+  VERIFY( c1 != c3 );\n+  VERIFY( strb_01.str() == str_01 );\n+  VERIFY( str_01.size() == strb_01.str().size() );\n+  //test for ios_base::out\n+  strmsz_2 = strb_03.in_avail();\n+  c4 = strb_03.sungetc();\n+  VERIFY( c4 == traits_type::eof() );\n+\n+  // BUFFER MANAGEMENT & POSITIONING\n+  // sync\n+  // pubsync\n+  strb_01.pubsync();\n+  strb_02.pubsync();\n+  strb_03.pubsync();\n+\n+  // setbuf\n+  // pubsetbuf(char_type* s, streamsize n)\n+  str_tmp = std::string(\"naaaah, go to cebu\");\n+  strb_01.pubsetbuf(const_cast<char*> (str_tmp.c_str()), str_tmp.size());\n+  VERIFY( strb_01.str() == str_tmp );\n+  strb_01.pubsetbuf(0,0);\n+  VERIFY( strb_01.str() == str_tmp );\n+\n+  // seekoff\n+  // pubseekoff(off_type off, ios_base::seekdir way, ios_base::openmode which)\n+  // alters the stream position to off\n+  pos_type pt_1(off_type(-1));\n+  pos_type pt_2(off_type(0));\n+  off_type off_1 = 0;\n+  off_type off_2 = 0;\n+  strb_01.str(str_01); //in|out (\"mykonos. . . or what?\");\n+  strb_02.str(str_02); //in (\"paris, or sainte-maxime?\");\n+  strb_03.str(str_03); //out (\"\")\n+  //IN|OUT\n+  //beg\n+  pt_1 = strb_01.pubseekoff(2, std::ios_base::beg);\n+  off_1 = pt_1;\n+  VERIFY( off_1 >= 0 );\n+  c1 = strb_01.snextc(); //current in pointer +1\n+  VERIFY( c1 == 'o' );\n+  c2 = strb_01.sputc('x');  //test current out pointer\n+  str_tmp = std::string(\"myxonos. . . or what?\");\n+  VERIFY( strb_01.str() == str_tmp );\n+  //cur\n+  pt_1 = strb_01.pubseekoff(2, std::ios_base::cur);\n+  off_1 = pt_1;\n+  VERIFY( off_1 == -1 ); // can't seekoff for in and out + cur in sstreams\n+  pt_1 = strb_01.pubseekoff(2, std::ios_base::cur, std::ios_base::in);\n+  off_1 = pt_1;\n+  pt_2 = strb_01.pubseekoff(2, std::ios_base::cur, std::ios_base::in);\n+  off_2 = pt_2;\n+  VERIFY( off_2 == off_1 + 2 );\n+  c1 = strb_01.snextc(); //current in pointer + 1\n+  VERIFY( c1 == ' ' );\n+  c2 = strb_01.sputc('x');  //test current out pointer\n+  str_tmp = std::string(\"myxxnos. . . or what?\");\n+  VERIFY( strb_01.str() == str_tmp );\n+  //end\n+  pt_2 = strb_01.pubseekoff(2, std::ios_base::end);\n+  off_1 = pt_2;\n+  VERIFY( off_1 == -1 ); // not a valid position\n+  VERIFY( strb_01.str() == str_tmp );\n+  // end part two (from the filebuf tests)\n+  strb_01.pubseekoff(0, std::ios_base::end);\n+  strmsz_1 = strb_01.in_avail(); // 0 cuz at the end\n+  c1 = strb_01.sgetc(); \n+  c2 = strb_01.sungetc();\n+  strmsz_2 = strb_01.in_avail(); // 1\n+  c3 = strb_01.sgetc();\n+  VERIFY( c1 != c2 );\n+  VERIFY( strmsz_2 != strmsz_1 );\n+  VERIFY( strmsz_2 == 1 );\n+  // end part three\n+  strmsz_1 = strb_01.str().size();\n+  strmsz_2 = strb_01.sputn(\" ravi shankar meets carlos santana in LoHa\", 90);\n+  strb_01.pubseekoff(0, std::ios_base::end);\n+  strb_01.sputc('<');\n+  str_tmp = strb_01.str();\n+  VERIFY( str_tmp.size() == strmsz_1 + strmsz_2 + 1 );\n+  // IN\n+  // OUT\n+\n+  // seekpos\n+  // pubseekpos(pos_type sp, ios_base::openmode)\n+  // alters the stream position to sp\n+  strb_01.str(str_01); //in|out (\"mykonos. . . or what?\");\n+  strb_02.str(str_02); //in (\"paris, or sainte-maxime?\");\n+  strb_03.str(str_03); //out (\"\")\n+  //IN|OUT\n+  //beg\n+  pt_1 = strb_01.pubseekoff(2, std::ios_base::beg);\n+  off_1 = pt_1;\n+  VERIFY( off_1 >= 0 );\n+  pt_1 = strb_01.pubseekoff(0, std::ios_base::cur, std::ios_base::out);\n+  off_1 = pt_1;\n+  c1 = strb_01.snextc(); //current in pointer +1\n+  VERIFY( c1 == 'o' );\n+  c2 = strb_01.sputc('x');  //test current out pointer\n+  str_tmp = std::string(\"myxonos. . . or what?\");\n+  VERIFY( strb_01.str() == str_tmp );\n+  strb_01.pubsync(); //resets pointers\n+  pt_2 = strb_01.pubseekpos(pt_1, std::ios_base::in|std::ios_base::out);\n+  off_2 = pt_2;\n+  VERIFY( off_1 == off_2 );\n+  c3 = strb_01.snextc(); //current in pointer +1\n+  VERIFY( c1 == c3 );\n+  c2 = strb_01.sputc('x');  //test current out pointer\n+  str_tmp = std::string(\"myxonos. . . or what?\");\n+  VERIFY( strb_01.str() == str_tmp );\n+\n+  // VIRTUALS (indirectly tested)\n+  // underflow\n+  // if read position avail, returns *gptr()\n+\n+  // pbackfail(int_type c)\n+  // put c back into input sequence\n+\n+  // overflow\n+  // appends c to output seq\n+\n+#ifdef DEBUG_ASSERT\n+  assert(test);\n+#endif\n+\n+  return test;\n+}\n+\n+\n+// libstdc++/3955 -- ios_base::app overwrites from the beginning\n+bool test05()\n+{\n+  bool test = true;\n+\n+  std::ostringstream os (\"foo\");\n+  os << \"bar\";\n+\n+  test = os.str() == \"bar\";\n+\n+#ifdef DEBUG_ASSERT\n+  assert(test);\n+#endif\n+\n+  return test;\n+}\n+\n+bool test06()\n+{\n+  bool test = true;\n+\n+  std::ostringstream os (\"foo\", std::ios_base::app);\n+  os << \"bar\";\n+\n+  test = os.str() == \"foobar\";\n+\n+#ifdef DEBUG_ASSERT\n+  assert(test);\n+#endif\n+\n+  return test;\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  test06();\n+\n+  return 0;\n+}\n+\n+\n+\n+// more candy!!!"}, {"sha": "1a1b017807418e67330de5663ffa57a7e03b0b67", "filename": "libstdc++-v3/testsuite/27_io/stringstream.cc", "status": "modified", "additions": 21, "deletions": 121, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringstream.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringstream.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringstream.cc?ref=bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "patch": "@@ -1,7 +1,6 @@\n-// 981015 bkoz\n-// i,o,stringstream usage\n+// 2002-07-25 Benjamin Kosnik <bkoz@redhat.com>\n \n-// Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -28,133 +27,34 @@\n // invalidate any other reasons why the executable file might be covered by\n // the GNU General Public License.\n \n-#include <vector>\n-#include <string>\n-#include <sstream>\n-#include <testsuite_hooks.h>\n-\n-// 01: sanity checks for strings, stringbufs\n-std::string \n-test01()\n-{\n-  bool test = false;\n-\n-  // Empty string sanity check.\n-  std::string str01;\n-  std::string::iterator __i_start = str01.begin();\n-  std::string::iterator __i_end = str01.end();\n-  std::string::size_type len = str01.size();\n-  test = __i_start == __i_end;\n-  VERIFY( len == 0 );\n-\n-  // Full string sanity check.\n-  std::string str02(\"these golden days, i spend waiting for you:\\n\"\n-\t\t    \"Betty Carter on Verve with I'm Yours and You're Mine.\");\n-  __i_start = str02.begin();\n-  __i_end = str02.end();\n-  len = str02.size();\n-  VERIFY( __i_start != __i_end );\n-  VERIFY( len != 0 );\n- \n-  // Test an empty ostring stream for sanity.\n-  std::ostringstream ostrstream0;\n-  std::string str03 = ostrstream0.str();\n-  __i_start = str03.begin();\n-  __i_end = str03.end();\n-  len = str03.size();\n-  VERIFY( __i_start == __i_end );\n-  VERIFY( len == 0 );\n-  VERIFY( str01 == str03 );\n+// 27.7.4 - Template class basic_stringstream\n+// NB: This file is for testing basic_stringstream with NO OTHER INCLUDES.\n \n-  return str02;\n-}\n+#include <sstream>\n \n+// { dg-do compile }\n \n-int\n-test02()\n+// libstdc++/7216\n+void test01()\n {\n-  bool test = true;\n-\n-  //\n-  // 1: Automatic formatting of a compound string\n-  //\n-  int i = 1024;\n-  int *pi = &i;\n-  double d = 3.14159;\n-  double *pd = &d;\n-  std::string blank;\n-  std::ostringstream ostrst01; \n-  std::ostringstream ostrst02(blank); \n-  \n-  // No buffer,so should be created.\n-  ostrst01 << \"i: \" << i << \" i's address:  \" << pi << \"\\n\"\n-\t     << \"d: \" << d << \" d's address: \" << pd << std::endl;\n-  // Buffer, so existing buffer should be overwritten.\n-  ostrst02 << \"i: \" << i << \" i's address:  \" << pi << \"\\n\"\n-\t     << \"d: \" << d << \" d's address: \" << pd << std::endl;\n-\n-  std::string msg01 = ostrst01.str();\n-  std::string msg02 = ostrst02.str();\n-  VERIFY( msg01 == msg02 );\n-  VERIFY( msg02 != blank );\n-\n-  //\n-  // 2: istringstream\n-  //\n-  // extracts the stored ascii values, placing them in turn in the four vars\n-#if 0\n-  int i2 = 0;\n-  int *pi2 = &i2;\n-  double d2 = 0.0;\n-  double *pd2 = &d2;\n-  std::istringstream istrst01(ostrst02.str());\n-\n-  istrst01 >> i2 >> pi2 >> d2 >> pd2;\n-  //istrst01 >> i2;\n-  //istrst01 >> pi2;\n-  VERIFY( i2 == i );\n-  VERIFY( d2 == d );\n-  VERIFY( pd2 == pd );\n-  VERIFY( pi2 == pi );\n-#endif\n-\n-  // stringstream\n-  std::string str1(\"\");\n-  std::string str3(\"this is a somewhat  string\");\n-  std::stringstream ss1(str1, std::ios_base::in|std::ios_base::out);\n-  std::stringstream ss2(str3, std::ios_base::in|std::ios_base::out);\n-\n-  return 0;\n+  // Check for required typedefs\n+  typedef std::stringstream test_type;\n+  typedef test_type::char_type char_type;\n+  typedef test_type::traits_type traits_type;\n+  typedef test_type::int_type int_type;\n+  typedef test_type::pos_type pos_type;\n+  typedef test_type::off_type off_type;\n }\n \n-// user-reported error\n-class derived_oss: public std::ostringstream \n-{\n-public:\n-  derived_oss() : std::ostringstream() {}\n-};\n-\n-int\n-test03()\n+namespace test \n {\n-  bool test = true;\n-  derived_oss yy;\n-  yy << \"buena vista social club\\n\";\n-  VERIFY( yy.str() == std::string(\"buena vista social club\\n\") );\n-\n-#ifdef DEBUG_ASSERT\n-  assert(test);\n-#endif\n-\n-  return 0;\n-}\n+  using namespace std;\n+  typedef short type_t;\n+  template class basic_stringstream<type_t, char_traits<type_t> >;\n+} // test\n \n-int \n-main() \n+int main() \n {\n   test01();\n-  test02();\n-  test03();\n-  \n   return 0;\n }"}, {"sha": "91ee79bcf40b6e06f18faf4ccd2971be907a05da", "filename": "libstdc++-v3/testsuite/27_io/stringstream_members.cc", "status": "modified", "additions": 59, "deletions": 4, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringstream_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringstream_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fstringstream_members.cc?ref=bcc6a03a0aa4bd9e1c41b7d95dd2aab71911d0c0", "patch": "@@ -1,6 +1,6 @@\n // 2001-05-24 Benjamin Kosnik  <bkoz@redhat.com>\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -120,12 +120,67 @@ void test02()\n   // These semantics are a joke, a serious defect, and incredibly lame.\n }\n \n+void\n+test03()\n+{\n+  bool test = true;\n+\n+  //\n+  // 1: Automatic formatting of a compound string\n+  //\n+  int i = 1024;\n+  int *pi = &i;\n+  double d = 3.14159;\n+  double *pd = &d;\n+  std::string blank;\n+  std::ostringstream ostrst01; \n+  std::ostringstream ostrst02(blank); \n+  \n+  // No buffer, so should be created.\n+  ostrst01 << \"i: \" << i << \" i's address:  \" << pi << \"\\n\"\n+\t     << \"d: \" << d << \" d's address: \" << pd << std::endl;\n+  // Buffer, so existing buffer should be overwritten.\n+  ostrst02 << \"i: \" << i << \" i's address:  \" << pi << \"\\n\"\n+\t     << \"d: \" << d << \" d's address: \" << pd << std::endl;\n+\n+  std::string msg01 = ostrst01.str();\n+  std::string msg02 = ostrst02.str();\n+  VERIFY( msg01 == msg02 );\n+  VERIFY( msg02 != blank );\n+\n+  //\n+  // 2: istringstream\n+  //\n+  // extracts the stored ascii values, placing them in turn in the four vars\n+#if 0\n+  int i2 = 0;\n+  //int* pi2 = &i2;\n+  void* pi2 = &i2;\n+  double d2 = 0.0;\n+  //  double* pd2 = &d2;\n+  void* pd2 = &d2;\n+  std::istringstream istrst01(ostrst02.str());\n+\n+  istrst01 >> i2 >> pi2 >> d2 >> pd2;\n+  //istrst01 >> i2;\n+  //istrst01 >> pi2;\n+  VERIFY( i2 == i );\n+  VERIFY( d2 == d );\n+  VERIFY( pd2 == pd );\n+  VERIFY( pi2 == pi );\n+#endif\n+\n+  // stringstream\n+  std::string str1(\"\");\n+  std::string str3(\"this is a somewhat  string\");\n+  std::stringstream ss1(str1, std::ios_base::in|std::ios_base::out);\n+  std::stringstream ss2(str3, std::ios_base::in|std::ios_base::out);\n+}\n+\n int main()\n {\n   test01();\n   test02();\n+  test03();\n   return 0;\n }\n-\n-\n-"}]}