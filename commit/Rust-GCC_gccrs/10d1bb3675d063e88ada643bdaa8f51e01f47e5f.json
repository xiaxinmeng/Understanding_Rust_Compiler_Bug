{"sha": "10d1bb3675d063e88ada643bdaa8f51e01f47e5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBkMWJiMzY3NWQwNjNlODhhZGE2NDNiZGFhOGY1MWUwMWY0N2U1Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-05-31T11:43:18Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-05-31T11:43:18Z"}, "message": "gcse.c (gcse_emit_move_after): New.\n\n\t* gcse.c (gcse_emit_move_after): New.\n\t(pre_delete, hoist_store): Use it.\n\n\t* reload1.c (emit_input_reload_insns): Use constrain_operands\n\tinstead of constraint_accepts_reg_p to verify optimization.\n\t(constraint_accepts_reg_p): Kill\n\n\t* reload1.c (reload_cse_delete_noop_set): Kill.\n\t(reload_cse_simplify): use delte_insn_and_edges.\n\nFrom-SVN: r54105", "tree": {"sha": "20d9e9485a82572e2e4ec62cf80c757770eaf93d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/20d9e9485a82572e2e4ec62cf80c757770eaf93d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10d1bb3675d063e88ada643bdaa8f51e01f47e5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10d1bb3675d063e88ada643bdaa8f51e01f47e5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10d1bb3675d063e88ada643bdaa8f51e01f47e5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10d1bb3675d063e88ada643bdaa8f51e01f47e5f/comments", "author": null, "committer": null, "parents": [{"sha": "8a72fb761ecbcb9ec734eea3ce550caa08a3d014", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a72fb761ecbcb9ec734eea3ce550caa08a3d014", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a72fb761ecbcb9ec734eea3ce550caa08a3d014"}], "stats": {"total": 210, "additions": 84, "deletions": 126}, "files": [{"sha": "77386f33af3d5382a1d502e4bb362ce65b6a58dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d1bb3675d063e88ada643bdaa8f51e01f47e5f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d1bb3675d063e88ada643bdaa8f51e01f47e5f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10d1bb3675d063e88ada643bdaa8f51e01f47e5f", "patch": "@@ -1,3 +1,15 @@\n+Fri May 31 13:37:54 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcse.c (gcse_emit_move_after): New.\n+\t(pre_delete, hoist_store): Use it.\n+\n+\t* reload1.c (emit_input_reload_insns): Use constrain_operands\n+\tinstead of constraint_accepts_reg_p to verify optimization.\n+\t(constraint_accepts_reg_p): Kill\n+\n+\t* reload1.c (reload_cse_delete_noop_set): Kill.\n+\t(reload_cse_simplify): use delte_insn_and_edges.\n+\n 2002-05-31  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* cfgloop.c (flow_loops_find): Initialize first and last fields"}, {"sha": "4d7c154113327b56839ebceaea10a5fcce6deeff", "filename": "gcc/gcse.c", "status": "modified", "additions": 40, "deletions": 31, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d1bb3675d063e88ada643bdaa8f51e01f47e5f/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d1bb3675d063e88ada643bdaa8f51e01f47e5f/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=10d1bb3675d063e88ada643bdaa8f51e01f47e5f", "patch": "@@ -700,6 +700,7 @@ static void store_motion\t\tPARAMS ((void));\n static void free_insn_expr_list_list\tPARAMS ((rtx *));\n static void clear_modify_mem_tables\tPARAMS ((void));\n static void free_modify_mem_tables\tPARAMS ((void));\n+static rtx gcse_emit_move_after\t\tPARAMS ((rtx, rtx, rtx));\n \f\n /* Entry point for global common subexpression elimination.\n    F is the first instruction in the function.  */\n@@ -4948,6 +4949,33 @@ pre_insert_copies ()\n       }\n }\n \n+/* Emit move from SRC to DEST noting the equivalence with expression computed\n+   in INSN.  */\n+static rtx\n+gcse_emit_move_after (src, dest, insn)\n+     rtx src, dest, insn;\n+{\n+  rtx new;\n+  rtx set = single_set (insn);\n+  rtx note;\n+  rtx eqv;\n+\n+  /* This should never fail since we're creating a reg->reg copy\n+     we've verified to be valid.  */\n+\n+  new = emit_insn_after (gen_rtx_SET (VOIDmode, dest, src), insn);\n+\n+  /* Note the equivalence for local CSE pass.  */\n+  if ((note = find_reg_equal_equiv_note (insn)))\n+    eqv = XEXP (note, 0);\n+  else\n+    eqv = SET_SRC (set);\n+\n+  set_unique_reg_note (new, REG_EQUAL, copy_insn_1 (src));\n+\n+  return new;\n+}\n+\n /* Delete redundant computations.\n    Deletion is done by changing the insn to copy the `reaching_reg' of\n    the expression into the result of the SET.  It is left to later passes\n@@ -4991,21 +5019,12 @@ pre_delete ()\n \t\t  expr->reaching_reg\n \t\t    = gen_reg_rtx (GET_MODE (SET_DEST (set)));\n \n-\t\t/* In theory this should never fail since we're creating\n-\t\t   a reg->reg copy.\n-\n-\t\t   However, on the x86 some of the movXX patterns actually\n-\t\t   contain clobbers of scratch regs.  This may cause the\n-\t\t   insn created by validate_change to not match any pattern\n-\t\t   and thus cause validate_change to fail.  */\n-\t\tif (validate_change (insn, &SET_SRC (set),\n-\t\t\t\t     expr->reaching_reg, 0))\n-\t\t  {\n-\t\t    occr->deleted_p = 1;\n-\t\t    SET_BIT (pre_redundant_insns, INSN_CUID (insn));\n-\t\t    changed = 1;\n-\t\t    gcse_subst_count++;\n-\t\t  }\n+\t\tgcse_emit_move_after (expr->reaching_reg, SET_DEST (set), insn);\n+\t\tdelete_insn (insn);\n+\t\toccr->deleted_p = 1;\n+\t\tSET_BIT (pre_redundant_insns, INSN_CUID (insn));\n+\t\tchanged = 1;\n+\t\tgcse_subst_count++;\n \n \t\tif (gcse_file)\n \t\t  {\n@@ -5827,23 +5846,13 @@ hoist_code ()\n \t\t\texpr->reaching_reg\n \t\t\t  = gen_reg_rtx (GET_MODE (SET_DEST (set)));\n \n-\t\t      /* In theory this should never fail since we're creating\n-\t\t\t a reg->reg copy.\n-\n-\t\t\t However, on the x86 some of the movXX patterns\n-\t\t\t actually contain clobbers of scratch regs.  This may\n-\t\t\t cause the insn created by validate_change to not\n-\t\t\t match any pattern and thus cause validate_change to\n-\t\t\t fail.  */\n-\t\t      if (validate_change (insn, &SET_SRC (set),\n-\t\t\t\t\t   expr->reaching_reg, 0))\n+\t\t      gcse_emit_move_after (expr->reaching_reg, SET_DEST (set), insn);\n+\t\t      delete_insn (insn);\n+\t\t      occr->deleted_p = 1;\n+\t\t      if (!insn_inserted_p)\n \t\t\t{\n-\t\t\t  occr->deleted_p = 1;\n-\t\t\t  if (!insn_inserted_p)\n-\t\t\t    {\n-\t\t\t      insert_insn_end_bb (index_map[i], bb, 0);\n-\t\t\t      insn_inserted_p = 1;\n-\t\t\t    }\n+\t\t\t  insert_insn_end_bb (index_map[i], bb, 0);\n+\t\t\t  insn_inserted_p = 1;\n \t\t\t}\n \t\t    }\n \t\t}"}, {"sha": "31e5910f2377e4efb36a4d64d654c86e5fb3b1e1", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d1bb3675d063e88ada643bdaa8f51e01f47e5f/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d1bb3675d063e88ada643bdaa8f51e01f47e5f/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=10d1bb3675d063e88ada643bdaa8f51e01f47e5f", "patch": "@@ -119,6 +119,9 @@ accessor_from_format (c)\n \n     case 'B':\n       return \"XBBDEF\";\n+\n+    default:\n+      abort ();\n     }\n }\n "}, {"sha": "1ce3199cd9800eac72e645bf283390b6f516a834", "filename": "gcc/reload1.c", "status": "modified", "additions": 29, "deletions": 95, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10d1bb3675d063e88ada643bdaa8f51e01f47e5f/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10d1bb3675d063e88ada643bdaa8f51e01f47e5f/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=10d1bb3675d063e88ada643bdaa8f51e01f47e5f", "patch": "@@ -440,7 +440,6 @@ static void delete_output_reload\tPARAMS ((rtx, int, int));\n static void delete_address_reloads\tPARAMS ((rtx, rtx));\n static void delete_address_reloads_1\tPARAMS ((rtx, rtx, rtx));\n static rtx inc_for_reload\t\tPARAMS ((rtx, rtx, rtx, int));\n-static int constraint_accepts_reg_p\tPARAMS ((const char *, rtx));\n static void reload_cse_regs_1\t\tPARAMS ((rtx));\n static int reload_cse_noop_set_p\tPARAMS ((rtx));\n static int reload_cse_simplify_set\tPARAMS ((rtx, rtx));\n@@ -458,7 +457,6 @@ static HOST_WIDE_INT sext_for_mode\tPARAMS ((enum machine_mode,\n \t\t\t\t\t\t HOST_WIDE_INT));\n static void failed_reload\t\tPARAMS ((rtx, int));\n static int set_reload_reg\t\tPARAMS ((int, int));\n-static void reload_cse_delete_noop_set\tPARAMS ((rtx, rtx));\n static void reload_cse_simplify\t\tPARAMS ((rtx));\n void fixup_abnormal_edges\t\tPARAMS ((void));\n extern void dump_needs\t\t\tPARAMS ((struct insn_chain *));\n@@ -6383,38 +6381,43 @@ emit_input_reload_insns (chain, rl, old, j)\n \t  && SET_DEST (PATTERN (temp)) == old\n \t  /* Make sure we can access insn_operand_constraint.  */\n \t  && asm_noperands (PATTERN (temp)) < 0\n-\t  /* This is unsafe if prev insn rejects our reload reg.  */\n-\t  && constraint_accepts_reg_p (insn_data[recog_memoized (temp)].operand[0].constraint,\n-\t\t\t\t       reloadreg)\n \t  /* This is unsafe if operand occurs more than once in current\n \t     insn.  Perhaps some occurrences aren't reloaded.  */\n-\t  && count_occurrences (PATTERN (insn), old, 0) == 1\n-\t  /* Don't risk splitting a matching pair of operands.  */\n-\t  && ! reg_mentioned_p (old, SET_SRC (PATTERN (temp))))\n+\t  && count_occurrences (PATTERN (insn), old, 0) == 1)\n \t{\n+\t  rtx old = SET_DEST (PATTERN (temp));\n \t  /* Store into the reload register instead of the pseudo.  */\n \t  SET_DEST (PATTERN (temp)) = reloadreg;\n \n-\t  /* If the previous insn is an output reload, the source is\n-\t     a reload register, and its spill_reg_store entry will\n-\t     contain the previous destination.  This is now\n-\t     invalid.  */\n-\t  if (GET_CODE (SET_SRC (PATTERN (temp))) == REG\n-\t      && REGNO (SET_SRC (PATTERN (temp))) < FIRST_PSEUDO_REGISTER)\n+\t  /* Verify that resulting insn is valid.  */\n+\t  extract_insn (temp);\n+\t  if (constrain_operands (1))\n \t    {\n-\t      spill_reg_store[REGNO (SET_SRC (PATTERN (temp)))] = 0;\n-\t      spill_reg_stored_to[REGNO (SET_SRC (PATTERN (temp)))] = 0;\n-\t    }\n+\t      /* If the previous insn is an output reload, the source is\n+\t\t a reload register, and its spill_reg_store entry will\n+\t\t contain the previous destination.  This is now\n+\t\t invalid.  */\n+\t      if (GET_CODE (SET_SRC (PATTERN (temp))) == REG\n+\t\t  && REGNO (SET_SRC (PATTERN (temp))) < FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  spill_reg_store[REGNO (SET_SRC (PATTERN (temp)))] = 0;\n+\t\t  spill_reg_stored_to[REGNO (SET_SRC (PATTERN (temp)))] = 0;\n+\t\t}\n \n-\t  /* If these are the only uses of the pseudo reg,\n-\t     pretend for GDB it lives in the reload reg we used.  */\n-\t  if (REG_N_DEATHS (REGNO (old)) == 1\n-\t      && REG_N_SETS (REGNO (old)) == 1)\n+\t      /* If these are the only uses of the pseudo reg,\n+\t\t pretend for GDB it lives in the reload reg we used.  */\n+\t      if (REG_N_DEATHS (REGNO (old)) == 1\n+\t\t  && REG_N_SETS (REGNO (old)) == 1)\n+\t\t{\n+\t\t  reg_renumber[REGNO (old)] = REGNO (rl->reg_rtx);\n+\t\t  alter_reg (REGNO (old), -1);\n+\t\t}\n+\t      special = 1;\n+\t    }\n+\t  else\n \t    {\n-\t      reg_renumber[REGNO (old)] = REGNO (rl->reg_rtx);\n-\t      alter_reg (REGNO (old), -1);\n+\t      SET_DEST (PATTERN (temp)) = old;\n \t    }\n-\t  special = 1;\n \t}\n     }\n \n@@ -7980,75 +7983,6 @@ inc_for_reload (reloadreg, in, value, inc_amount)\n   return store;\n }\n \f\n-/* Return 1 if we are certain that the constraint-string STRING allows\n-   the hard register REG.  Return 0 if we can't be sure of this.  */\n-\n-static int\n-constraint_accepts_reg_p (string, reg)\n-     const char *string;\n-     rtx reg;\n-{\n-  int value = 0;\n-  int regno = true_regnum (reg);\n-  int c;\n-\n-  /* Initialize for first alternative.  */\n-  value = 0;\n-  /* Check that each alternative contains `g' or `r'.  */\n-  while (1)\n-    switch (c = *string++)\n-      {\n-      case 0:\n-\t/* If an alternative lacks `g' or `r', we lose.  */\n-\treturn value;\n-      case ',':\n-\t/* If an alternative lacks `g' or `r', we lose.  */\n-\tif (value == 0)\n-\t  return 0;\n-\t/* Initialize for next alternative.  */\n-\tvalue = 0;\n-\tbreak;\n-      case 'g':\n-      case 'r':\n-\t/* Any general reg wins for this alternative.  */\n-\tif (TEST_HARD_REG_BIT (reg_class_contents[(int) GENERAL_REGS], regno))\n-\t  value = 1;\n-\tbreak;\n-      default:\n-\t/* Any reg in specified class wins for this alternative.  */\n-\t{\n-\t  enum reg_class class = REG_CLASS_FROM_LETTER (c);\n-\n-\t  if (TEST_HARD_REG_BIT (reg_class_contents[(int) class], regno))\n-\t    value = 1;\n-\t}\n-      }\n-}\n-\f\n-/* INSN is a no-op; delete it.\n-   If this sets the return value of the function, we must keep a USE around,\n-   in case this is in a different basic block than the final USE.  Otherwise,\n-   we could loose important register lifeness information on\n-   SMALL_REGISTER_CLASSES machines, where return registers might be used as\n-   spills:  subsequent passes assume that spill registers are dead at the end\n-   of a basic block.\n-   VALUE must be the return value in such a case, NULL otherwise.  */\n-static void\n-reload_cse_delete_noop_set (insn, value)\n-     rtx insn, value;\n-{\n-  bool purge = BLOCK_FOR_INSN (insn)->end == insn;\n-  if (value)\n-    {\n-      PATTERN (insn) = gen_rtx_USE (VOIDmode, value);\n-      INSN_CODE (insn) = -1;\n-      REG_NOTES (insn) = NULL_RTX;\n-    }\n-  else\n-    delete_insn (insn);\n-  if (purge)\n-    purge_dead_edges (BLOCK_FOR_INSN (insn));\n-}\n \n /* See whether a single set SET is a noop.  */\n static int\n@@ -8082,7 +8016,7 @@ reload_cse_simplify (insn)\n \t  if (REG_P (value)\n \t      && ! REG_FUNCTION_VALUE_P (value))\n \t    value = 0;\n-\t  reload_cse_delete_noop_set (insn, value);\n+\t  delete_insn_and_edges (insn);\n \t  return;\n \t}\n \n@@ -8119,7 +8053,7 @@ reload_cse_simplify (insn)\n \n       if (i < 0)\n \t{\n-\t  reload_cse_delete_noop_set (insn, value);\n+\t  delete_insn_and_edges (insn);\n \t  /* We're done with this insn.  */\n \t  return;\n \t}"}]}