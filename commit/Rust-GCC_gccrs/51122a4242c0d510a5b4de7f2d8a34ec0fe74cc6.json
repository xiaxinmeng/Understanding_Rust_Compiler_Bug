{"sha": "51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTExMjJhNDI0MmMwZDUxMGE1YjRkZTdmMmQ4YTM0ZWMwZmU3NGNjNg==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-09-01T00:33:53Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-09-01T00:33:53Z"}, "message": "acinclude.m4: Minor comment tweaks.\n\n2002-08-31  Phil Edwards  <pme@gcc.gnu.org>\n\n\t* acinclude.m4:  Minor comment tweaks.\n\n\t* docs/html/makedoc.awk:  New file...\n\t* docs/html/Makefile:  ...called from here...\n\t* docs/html/documentation.html:  ...to help generate this.\n\n\t* docs/html/21_strings/howto.html:  Prepare for new entry.\n\t* include/bits/basic_string.h:  Initial basic_stirng hook for\n\tdoxygen.  Remove trailing whitespace.\n\t* include/bits/char_traits.h:  Point to onlinedocs for new entry.\n\t* include/bits/stringfwd.h:  Add doxygen hooks for string and\n\twstring typedefs.\n\nFrom-SVN: r56711", "tree": {"sha": "557d8e716ab0185144c0e29f5fdc9bcfe4d577c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/557d8e716ab0185144c0e29f5fdc9bcfe4d577c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6/comments", "author": null, "committer": null, "parents": [{"sha": "98c0d8d105b5e6d1153510bb131d8b5a9fe2e9b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98c0d8d105b5e6d1153510bb131d8b5a9fe2e9b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98c0d8d105b5e6d1153510bb131d8b5a9fe2e9b1"}], "stats": {"total": 851, "additions": 497, "deletions": 354}, "files": [{"sha": "8f9ccad556182762a8dc962f9f2e5884612f0c86", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6", "patch": "@@ -1,3 +1,18 @@\n+2002-08-31  Phil Edwards  <pme@gcc.gnu.org>\n+\n+\t* acinclude.m4:  Minor comment tweaks.\n+\n+\t* docs/html/makedoc.awk:  New file...\n+\t* docs/html/Makefile:  ...called from here...\n+\t* docs/html/documentation.html:  ...to help generate this.\n+\n+\t* docs/html/21_strings/howto.html:  Prepare for new entry.\n+\t* include/bits/basic_string.h:  Initial basic_stirng hook for\n+\tdoxygen.  Remove trailing whitespace.\n+\t* include/bits/char_traits.h:  Point to onlinedocs for new entry.\n+\t* include/bits/stringfwd.h:  Add doxygen hooks for string and\n+\twstring typedefs.\n+\n 2002-08-29  Richard Earnshaw  <rearnshaw@arm.com>\n \n \t* config/cpu/arm/cpu_limits.h: New file."}, {"sha": "7fcb0770c3e4d41f7f3d8beb0c433ecb8cabf67f", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6", "patch": "@@ -1,5 +1,5 @@\n dnl\n-dnl Initialize configure bits.\n+dnl Initialize basic configure bits, set toplevel_srcdir for Makefiles.\n dnl\n dnl GLIBCPP_TOPREL_CONFIGURE\n AC_DEFUN(GLIBCPP_TOPREL_CONFIGURE, [\n@@ -37,13 +37,10 @@ AC_DEFUN(GLIBCPP_TOPREL_CONFIGURE, [\n ])\n \n dnl\n-dnl Initialize configure bits.\n+dnl Initialize the rest of the library configury.\n dnl\n dnl GLIBCPP_CONFIGURE\n AC_DEFUN(GLIBCPP_CONFIGURE, [\n-\n-#possibly test for the presence of the compiler sources here?\n-\n   # Export build and source directories.\n   # These need to be absolute paths, yet at the same time need to\n   # canonicalize only relative paths, because then amd will not unmount"}, {"sha": "d25dd81bc467081f2b6b2cf558766fd229e605f2", "filename": "libstdc++-v3/docs/html/21_strings/howto.html", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F21_strings%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F21_strings%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F21_strings%2Fhowto.html?ref=51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6", "patch": "@@ -25,6 +25,7 @@ <h1>Contents</h1>\n    <li><a href=\"#2\">A case-insensitive string class</a>\n    <li><a href=\"#3\">Breaking a C++ string into tokens</a>\n    <li><a href=\"#4\">Simple transformations</a>\n+   <li><a href=\"#5\">Making strings of arbitrary character types</a>\n </ul>\n \n <hr>\n@@ -321,6 +322,15 @@ <h2><a name=\"4\">Simple transformations</a></h2>\n       <a href=\"../faq/index.html\">to the FAQ</a>.\n    </p>\n \n+<hr>\n+<h2><a name=\"5\">Making strings of arbitrary character types</a></h2>\n+   <p>how to work with char_traits -- in the archives, just need to\n+      go through and pull the examples together\n+   </p>\n+   <p>Return <a href=\"#top\">to top of page</a> or\n+      <a href=\"../faq/index.html\">to the FAQ</a>.\n+   </p>\n+\n \n \n <!-- ####################################################### -->"}, {"sha": "a494e2de9752272c6839c02f8aa8ff211bc66350", "filename": "libstdc++-v3/docs/html/Makefile", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2FMakefile?ref=51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6", "patch": "@@ -1,10 +1,28 @@\n-PWD=$${PWDCMD-pwd}\n \n+PWD=$${PWDCMD-pwd}\n MAKEINFO=makeinfo\n INC=../../../gcc/doc/include\n \n-all: faq/index.txt 17_intro/porting.html 17_intro/porting-howto.html\n+all: documentation.html                  \\\n+     faq/index.txt                       \\\n+     17_intro/porting.html               \\\n+     17_intro/porting-howto.html\n \n+# chock full of GNUism, probably\n+documentation.html: $(wildcard */howto.html)\n+\tsed -n '1,/beginlist/p' $@ > tmp.top\n+\tsed -n '/endlist/,$$p' $@ > tmp.bottom\n+\techo '  <ul>' > tmp.middle\n+\tfor i in [[:digit:]]*/howto.html; do \\\n+\t  title=`grep 'h1 ' $$i |\\\n+\t  sed 's=.*\\(Chapter [[:digit:]]*\\):[[:space:]]*\\(.*\\)</a>.*=\\2 (\\1)='` ;\\\n+\t  awk -v file=$$i -v \"title=$$title\" -f makedoc.awk $$i >> tmp.middle ;\\\n+\tdone\n+\tawk -v file=ext/howto.html -v \"title=Extensions to the Standard Library\"\\\n+\t  -f makedoc.awk ext/howto.html >> tmp.middle ;\\\n+\techo '  </ul>' >> tmp.middle\n+\tcat tmp.top tmp.middle tmp.bottom > $@\n+\trm tmp.top tmp.middle tmp.bottom\n \n faq/index.txt: faq/index.html\n \tlynx -dump $< | sed \"s%file://localhost`${PWD}`%..%\" > $@\n@@ -16,3 +34,4 @@ faq/index.txt: faq/index.html\n 17_intro/porting-howto.html: 17_intro/porting-howto.xml\n \txltproc -o $@ /usr/share/xml/docbook/xsl-stylesheets-1.48-2/html/docbook.xsl $<\n \n+# vim:noet ts=4"}, {"sha": "b1640d041ff9b1928929eeef56dd354d95d0b5cb", "filename": "libstdc++-v3/docs/html/documentation.html", "status": "modified", "additions": 120, "deletions": 114, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdocumentation.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdocumentation.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdocumentation.html?ref=51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6", "patch": "@@ -24,7 +24,7 @@ <h2><a name=\"1\">Introduction</a></h2>\n       <ul>\n          <li><a href=\"17_intro/COPYING\">License</a>\n          - GPL v2 license terms\n-\t <li><a href=\"abi.txt\">ABI Policy and Guidelines</a> \n+         <li><a href=\"abi.txt\">ABI Policy and Guidelines</a> \n          <li><a href=\"17_intro/BUGS\">BUGS</a>\n          <li><a href=\"17_intro/PROBLEMS\">PROBLEMS</a>\n          - target-specific known issues\n@@ -84,121 +84,127 @@ <h2><a name=\"4\">Source-Level Documentation</a></h2>\n <br>\n <h2><a name=\"3\">Chapter-Specific Documentation</a></h2>\n <p>Information, extensions, notes and advice on specific implementation \n-   capabilites and or liabilities broken down into chapter names based on the \n+   capabilites and/or liabilities broken down into chapter names based on the \n    C++ standard.\n </p>\n-      <ul>\n-         <li>Intro (Chapter 17)\n-\t <ul>\n-         <li><a href=\"17_intro/howto.html#1\">Header files</a>\n-         <li><a href=\"17_intro/howto.html#3\">Using &lt;foo&gt; vs &lt;foo.h&gt;</a>\n-         <li><a href=\"17_intro/howto.html#2\">Multithreading</a>\n-         <li><a href=\"17_intro/howto.html#4\">Porting</a>\n-         <li><a href=\"17_intro/howto.html#5\">Implementation-specific behavior</a>\n-         <li><a href=\"17_intro/howto.html#6\">Using preprocessor macros to change behavior of the library</a>\n-\t </ul>\n-\n-         <li>Library Support (Chapter 18)\n-\t <ul>\n-         <li><a href=\"18_support/howto.html#1\">Types</a>\n-         <li><a href=\"18_support/howto.html#2\">Implementation properties</a>\n-         <li><a href=\"18_support/howto.html#3\">Start and Termination</a>\n-         <li><a href=\"18_support/howto.html#4\">Dynamic memory management</a>\n-         <li><a href=\"18_support/howto.html#5\">RTTI, the ABI, and demangling</a>\n-\t </ul>\n-\n-\n-         <li>Diagnostics (Chapter 19)\n-\t <ul>\n-         <li><a href=\"19_diagnostics/howto.html#1\">Adding data to exceptions</a>\n-         <li><a href=\"19_diagnostics/howto.html#2\">Exception class hierarchy diagram</a>\n-         <li><a href=\"19_diagnostics/howto.html#3\">Concept checkers -- new and improved!</a>\n-         <li><a href=\"19_diagnostics/howto.html#4\">Verbose terminate</a>\n-\t </ul>\n-\n-         <li>Utilities (Chapter 20)\n-\t <ul>\n-         <li><a href=\"20_util/howto.html#1\">auto_ptr is not omnipotent</a>\n-         <li><a href=\"20_util/howto.html#1\">auto_ptr inside container classes</a>\n-         <li><a href=\"20_util/howto.html#1\">Functors</a>\n-         <li><a href=\"20_util/howto.html#1\">Pairs</a>\n-\t </ul>\n-\n-\n-         <li>Strings (Chapter 21)\n-\t <ul>\n-         <li><a href=\"21_strings/howto.html#1\">MFC's CString</a>\n-         <li><a href=\"21_strings/howto.html#2\">A case-insensitive string class</a>\n-         <li><a href=\"21_strings/howto.html#3\">Breaking a C++ string into tokens</a>\n-         <li><a href=\"21_strings/howto.html#4\">Simple transformations</a>\n-\t </ul>\n-\n-         <li>Localization (Chapter 22)\n-\t <ul>\n-         <li><a href=\"22_locale/howto.html#1\">Class locale</a>\n-         <li><a href=\"22_locale/howto.html#2\">Class codecvt</a>\n-         <li><a href=\"22_locale/howto.html#3\">Class ctype</a>\n-         <li><a href=\"22_locale/howto.html#4\">Class messages</a>\n-         <li><a href=\"22_locale/howto.html#5\">Bjarne Stroustrup on Locales</a>\n-         <li><a href=\"22_locale/howto.html#6\">Nathan Myers on Locales</a>\n-         <li><a href=\"22_locale/howto.html#7\">Correct Transformations </a>\n-\t </ul>\n-\n-         <li>Containers (Chapter 23)\n-\t <ul>\n-         <li><a href=\"23_containers/howto.html#1\">Making code unaware of the container/array difference</a>\n-         <li><a href=\"23_containers/howto.html#2\">Variable-sized bitmasks</a>\n-         <li><a href=\"23_containers/howto.html#3\">Containers and multithreading</a>\n-         <li><a href=\"23_containers/howto.html#4\">&quot;Hinting&quot; during insertion</a>\n-         <li><a href=\"23_containers/howto.html#5\">Bitmasks and string arguments</a>\n-         <li><a href=\"23_containers/howto.html#6\"><code>std::list::size()</code> is O(n)!</a>\n-         <li><a href=\"23_containers/howto.html#7\">Space overhead management for vectors </a>\n-\t </ul>\n-\n-         <li>Iterators (Chapter24)\n-\t <ul>\n-         <li><a href=\"24_iterators/howto.html#1\">They aren't pointers!</a>\n-         <li><a href=\"24_iterators/howto.html#1\">It ends where?</a>\n-\t </ul>\n-\n-         <li>Algorithms (Chapter 25)\n-\t <ul>\n-         <li><a href=\"25_algorithms/howto.html#1\">Prerequisites</a>\n-         <li><a href=\"25_algorithms/howto.html#2\">Special swaps</a>\n-\t </ul>\n-\n-         <li>Numerics (Chapter 26)\n-\t <ul>\n-         <li><a href=\"26_numerics/howto.html#1\">Complex Number Processing</a>\n-         <li><a href=\"26_numerics/howto.html#2\">Array Processing</a>\n-         <li><a href=\"26_numerics/howto.html#3\">Numerical Functions</a>\n-         <li><a href=\"26_numerics/howto.html#4\">C99</a>\n-\t </ul>\n-\n-         <li>I/O (Chapter 27)\n-\t <ul>\n-         <li><a href=\"27_io/howto.html#1\">Copying a file</a>\n-         <li><a href=\"27_io/howto.html#2\">The buffering is screwing up my program!</a>\n-\t </ul>\n-\t <ul>\n-         <li><a href=\"27_io/howto.html#3\">Binary I/O</a>\n-         <li><a href=\"27_io/howto.html#6\">More on binary I/O</a>\n-         <li><a href=\"27_io/howto.html#5\">Deriving a stream buffer</a>\n-         <li><a href=\"27_io/howto.html#4\">What is this &lt;sstream&gt;/stringstreams thing?</a>\n-         <li><a href=\"27_io/howto.html#7\">Pathetic performance? Ditch C.</a>\n-         <li><a href=\"27_io/howto.html#8\">Threads and I/O</a>\n-\t </ul>\n-\n-         <li>Extensions to the Standard Library\n-\t <ul>\n-         <li><a href=\"ext/howto.html#1\">Ropes and trees and hashes, oh my!</a>\n-         <li><a href=\"ext/howto.html#2\">Added members and types</a>\n-         <li><a href=\"ext/howto.html#3\">Allocators (versions 3.0, 3.1, 3.2)</a>\n-         <li><a href=\"ext/howto.html#4\">Allocators (version 3.3)</a>\n-         <li><a href=\"ext/howto.html#5\">Compile-time checks</a>\n-         <li><a href=\"ext/howto.html#6\">LWG Issues</a>\n-\t </ul>\n-      </ul>\n+<!--\n+  The list below is automatically generated.  To make changes in the text,\n+  edit the appropriate HOWTO file and run \"make\" in this directory.  In\n+  those files, you may reorder entries as you like, but DO NOT change the\n+  \"#number\"s in anchors, for they are used elsewhere and in bookmarks.\n+-->\n+<!-- beginlist -->\n+  <ul>\n+   <li>Library Introduction (Chapter 17)</li>\n+   <ul>\n+     <li><a href=\"17_intro/howto.html#2\">The Standard C++ header files</a></li>\n+     <li><a href=\"17_intro/howto.html#3\">The Standard C++ library and multithreading</a></li>\n+     <li><a href=\"17_intro/howto.html#4\"><code>&lt;foo&gt;</code> vs <code>&lt;foo.h&gt;</code></a></li>\n+     <li><a href=\"17_intro/porting-howto.html\">Porting HOWTO</a></li>\n+     <li><a href=\"17_intro/howto.html#5\">Behavior specific to libstdc++-v3</a></li>\n+     <li><a href=\"17_intro/howto.html#6\">Preprocessor macros controlling the library</a></li>\n+   </ul>\n+\n+   <li>Library Support (Chapter 18)</li>\n+   <ul>\n+     <li><a href=\"18_support/howto.html#1\">Types</a></li>\n+     <li><a href=\"18_support/howto.html#2\">Implementation properties</a></li>\n+     <li><a href=\"18_support/howto.html#3\">Start and Termination</a></li>\n+     <li><a href=\"18_support/howto.html#4\">Dynamic memory management</a></li>\n+     <li><a href=\"18_support/howto.html#5\">RTTI, the ABI, and demangling</a></li>\n+   </ul>\n+\n+   <li>Diagnostics (Chapter 19)</li>\n+   <ul>\n+     <li><a href=\"19_diagnostics/howto.html#1\">Adding data to exceptions</a></li>\n+     <li><a href=\"19_diagnostics/howto.html#2\">Exception class hierarchy diagram</a></li>\n+     <li><a href=\"19_diagnostics/howto.html#3\">Concept checkers -- <strong>new and improved!</strong></a></li>\n+     <li><a href=\"19_diagnostics/howto.html#4\">Verbose <code>terminate</code></a></li>\n+   </ul>\n+\n+   <li>General Utilities (Chapter 20)</li>\n+   <ul>\n+     <li><a href=\"20_util/howto.html#1\"><code>auto_ptr</code> is not omnipotent</a></li>\n+     <li><a href=\"20_util/howto.html#2\"><code>auto_ptr</code> inside container classes</a></li>\n+     <li><a href=\"20_util/howto.html#3\">Functors</a></li>\n+     <li><a href=\"20_util/howto.html#4\">Pairs</a></li>\n+   </ul>\n+\n+   <li>Strings (Chapter 21)</li>\n+   <ul>\n+     <li><a href=\"21_strings/howto.html#1\">MFC's CString</a></li>\n+     <li><a href=\"21_strings/howto.html#2\">A case-insensitive string class</a></li>\n+     <li><a href=\"21_strings/howto.html#3\">Breaking a C++ string into tokens</a></li>\n+     <li><a href=\"21_strings/howto.html#4\">Simple transformations</a></li>\n+     <li><a href=\"21_strings/howto.html#5\">Making strings of arbitrary character types</a></li>\n+   </ul>\n+\n+   <li>Localization (Chapter 22)</li>\n+   <ul>\n+     <li><a href=\"22_locale/howto.html#1\">class locale</a></li>\n+     <li><a href=\"22_locale/howto.html#2\">class codecvt</a></li>\n+     <li><a href=\"22_locale/howto.html#3\">class ctype</a></li>\n+     <li><a href=\"22_locale/howto.html#4\">class messages</a></li>\n+     <li><a href=\"22_locale/howto.html#5\">Bjarne Stroustrup on Locales</a></li>\n+     <li><a href=\"22_locale/howto.html#6\">Nathan Myers on Locales   </a></li>\n+     <li><a href=\"22_locale/howto.html#7\">Correct Transformations</a></li>\n+   </ul>\n+\n+   <li>Containers (Chapter 23)</li>\n+   <ul>\n+     <li><a href=\"23_containers/howto.html#1\">Making code unaware of the container/array difference</a></li>\n+     <li><a href=\"23_containers/howto.html#2\">Variable-sized bitmasks</a></li>\n+     <li><a href=\"23_containers/howto.html#3\">Containers and multithreading</a></li>\n+     <li><a href=\"23_containers/howto.html#4\">&quot;Hinting&quot; during insertion</a></li>\n+     <li><a href=\"23_containers/howto.html#5\">Bitmasks and string arguments</a></li>\n+     <li><a href=\"23_containers/howto.html#6\"><code>std::list::size()</code> is O(n)!</a></li>\n+     <li><a href=\"23_containers/howto.html#7\">Space overhead management for vectors</a></li>\n+   </ul>\n+\n+   <li>Iterators (Chapter 24)</li>\n+   <ul>\n+     <li><a href=\"24_iterators/howto.html#1\">They ain't pointers!</a></li>\n+     <li><a href=\"24_iterators/howto.html#2\">It ends <em>where?</em></a></li>\n+   </ul>\n+\n+   <li>Algorithms (Chapter 25)</li>\n+   <ul>\n+     <li><a href=\"25_algorithms/howto.html#1\">Prerequisites</a></li>\n+     <li><a href=\"25_algorithms/howto.html#2\">Special <code>swap</code>s</a></li>\n+   </ul>\n+\n+   <li>Numerics (Chapter 26)</li>\n+   <ul>\n+     <li><a href=\"26_numerics/howto.html#1\">Complex Number Processing</a></li>\n+     <li><a href=\"26_numerics/howto.html#2\">Array Processing</a></li>\n+     <li><a href=\"26_numerics/howto.html#3\">Numerical Functions</a></li>\n+     <li><a href=\"26_numerics/howto.html#4\">C99</a></li>\n+   </ul>\n+\n+   <li>Input/Output (Chapter 27)</li>\n+   <ul>\n+     <li><a href=\"27_io/howto.html#1\">Copying a file</a></li>\n+     <li><a href=\"27_io/howto.html#2\">The buffering is screwing up my program!</a></li>\n+     <li><a href=\"27_io/howto.html#3\">Binary I/O</a></li>\n+     <li><a href=\"27_io/howto.html#5\">What is this &lt;sstream&gt;/stringstreams thing?</a></li>\n+     <li><a href=\"27_io/howto.html#6\">Deriving a stream buffer</a></li>\n+     <li><a href=\"27_io/howto.html#7\">More on binary I/O</a></li>\n+     <li><a href=\"27_io/howto.html#8\">Pathetic performance?  Ditch C.</a></li>\n+     <li><a href=\"27_io/howto.html#9\">Threads and I/O</a></li>\n+   </ul>\n+\n+   <li>Extensions to the Standard Library</li>\n+   <ul>\n+     <li><a href=\"ext/howto.html#1\">Ropes and trees and hashes, oh my!</a></li>\n+     <li><a href=\"ext/howto.html#2\">Added members and types</a></li>\n+     <li><a href=\"ext/howto.html#3\">Allocators (versions 3.0, 3.1, 3.2)</a></li>\n+     <li><a href=\"ext/howto.html#6\">Allocators (version 3.3)</a></li>\n+     <li><a href=\"ext/howto.html#4\">Compile-time checks</a></li>\n+     <li><a href=\"ext/howto.html#5\">LWG Issues</a></li>\n+   </ul>\n+\n+  </ul>\n+<!-- endlist -->\n \n <hr />\n <br>"}, {"sha": "5d1bfc7a71064cb03c930642f333ea7d1334acb1", "filename": "libstdc++-v3/docs/html/makedoc.awk", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fmakedoc.awk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fmakedoc.awk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fmakedoc.awk?ref=51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6", "patch": "@@ -0,0 +1,69 @@\n+# Take apart bits of HTML and puts them back together again in new and\n+# fascinating ways.  Copyright (C) 2002 Free Software Foundation, Inc.\n+# Contributed by Phil Edwards <pme@gcc.gnu.org>.  Simple two-state automaton\n+# inspired by Richard Henderson's gcc/mkmap-symver.awk.\n+\n+# 'file' is the name of the file on stdin\n+# 'title' is the text to print at the start of the list\n+\n+BEGIN {\n+  state = \"looking\";\n+  entries = 0;\n+  printf (\"   <li>%s</li>\\n\", title);\n+  printf (\"   <ul>\\n\");\n+}\n+\n+# Searching for the little table of contents at the top.\n+state == \"looking\" && /^<h1>Contents/ {\n+  state = \"entries\";\n+  next;\n+}\n+\n+# Ignore everything else up to that point.\n+state == \"looking\" {\n+  next;\n+}\n+\n+# An entry in the table of contents.  Pull that line apart.\n+state == \"entries\" && /<li>/ {\n+  extract_info($0);\n+  next;\n+}\n+\n+# End of the list.  Don't bother reading the rest of the file.  (It could\n+# also contain more <li>'s, so that would be incorrect as well as wasteful.)\n+state == \"entries\" && /^<\\/ul>/ {\n+  exit;\n+}\n+\n+END {\n+  for (i = 0; i < entries; i++)\n+    printf (\"     %s\\n\", entry[i]);\n+  printf (\"   </ul>\\n\\n\");\n+}\n+\n+function extract_info(line) {\n+  # thistarget will be things like \"#5\" or \"elsewhere.html\"\n+  match(line,\"href=\\\".*\\\"\");\n+  thistarget = substr(line,RSTART+6,RLENGTH-7);\n+\n+  # take apart the filename\n+  split(file,X,\"/\");\n+  if (thistarget ~ /^#/) {\n+    # local name, use directory and filename\n+    target = file thistarget\n+  } else {\n+    # different file, only use directory\n+    target = X[1] \"/\" thistarget\n+  }\n+\n+  # visible text\n+  gsub(\"</a>\",\"\",line);\n+  start = index(line,\"\\\">\") + 2;\n+  thistext = substr(line,start);\n+\n+  # Assemble and store the HTML for later output.\n+  entry[entries++] = \"<li><a href=\\\"\" target \"\\\">\" thistext \"</a></li>\"\n+}\n+\n+# vim:sw=2"}, {"sha": "8f3a811f906133c7bab1a4d6e66e8eadf59d335b", "filename": "libstdc++-v3/include/bits/basic_string.h", "status": "modified", "additions": 249, "deletions": 229, "changes": 478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h?ref=51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6", "patch": "@@ -38,52 +38,72 @@\n  */\n \n #ifndef _CPP_BITS_STRING_H\n-#define _CPP_BITS_STRING_H\t1\n+#define _CPP_BITS_STRING_H        1\n \n #pragma GCC system_header\n \n #include <bits/atomicity.h>\n \n namespace std\n {\n-  // Documentation?  What's that? \n-  // Nathan Myers <ncm@cantrip.org>.\n-  //\n-  // A string looks like this:\n-  //\n-  //                               \t[_Rep]\n-  //                               \t_M_length\n-  //  [basic_string<char_type>]\t\t_M_capacity\n-  //  _M_dataplus                \t_M_state\n-  //  _M_p ---------------->   \t\tunnamed array of char_type\n-  \n-  // Where the _M_p points to the first character in the string, and\n-  // you cast it to a pointer-to-_Rep and subtract 1 to get a\n-  // pointer to the header.\n-  \n-  // This approach has the enormous advantage that a string object\n-  // requires only one allocation.  All the ugliness is confined\n-  // within a single pair of inline functions, which each compile to\n-  // a single \"add\" instruction: _Rep::_M_data(), and\n-  // string::_M_rep(); and the allocation function which gets a\n-  // block of raw bytes and with room enough and constructs a _Rep\n-  // object at the front.\n-  \n-  // The reason you want _M_data pointing to the character array and\n-  // not the _Rep is so that the debugger can see the string\n-  // contents. (Probably we should add a non-inline member to get\n-  // the _Rep for the debugger to use, so users can check the actual\n-  // string length.)\n-  \n-  // Note that the _Rep object is a POD so that you can have a\n-  // static \"empty string\" _Rep object already \"constructed\" before\n-  // static constructors have run.  The reference-count encoding is\n-  // chosen so that a 0 indicates one reference, so you never try to\n-  // destroy the empty-string _Rep object.\n-  \n-  // All but the last paragraph is considered pretty conventional\n-  // for a C++ string implementation.\n-  \n+  /**\n+   *  @class basic_string basic_string.h <string>\n+   *  @brief  Managing sequences of characters and character-like objects.\n+   *\n+   *  @ingroup Containers\n+   *  @ingroup Sequences\n+   *\n+   *  Meets the requirements of a <a href=\"tables.html#65\">container</a>, a\n+   *  <a href=\"tables.html#66\">reversible container</a>, and a\n+   *  <a href=\"tables.html#67\">sequence</a>.  Of the\n+   *  <a href=\"tables.html#68\">optional sequence requirements</a>, only\n+   *  @c push_back, @c at, and array access are supported.\n+   *\n+   *  @doctodo\n+   *\n+   *\n+   *  @if maint\n+   *  Documentation?  What's that?\n+   *  Nathan Myers <ncm@cantrip.org>.\n+   *\n+   *  A string looks like this:\n+   *\n+   *  @code\n+   *                                        [_Rep]\n+   *                                        _M_length\n+   *   [basic_string<char_type>]            _M_capacity\n+   *   _M_dataplus                          _M_state\n+   *   _M_p ---------------->               unnamed array of char_type\n+   *  @endcode\n+   *\n+   *  Where the _M_p points to the first character in the string, and\n+   *  you cast it to a pointer-to-_Rep and subtract 1 to get a\n+   *  pointer to the header.\n+   *\n+   *  This approach has the enormous advantage that a string object\n+   *  requires only one allocation.  All the ugliness is confined\n+   *  within a single pair of inline functions, which each compile to\n+   *  a single \"add\" instruction: _Rep::_M_data(), and\n+   *  string::_M_rep(); and the allocation function which gets a\n+   *  block of raw bytes and with room enough and constructs a _Rep\n+   *  object at the front.\n+   *\n+   *  The reason you want _M_data pointing to the character array and\n+   *  not the _Rep is so that the debugger can see the string\n+   *  contents. (Probably we should add a non-inline member to get\n+   *  the _Rep for the debugger to use, so users can check the actual\n+   *  string length.)\n+   *\n+   *  Note that the _Rep object is a POD so that you can have a\n+   *  static \"empty string\" _Rep object already \"constructed\" before\n+   *  static constructors have run.  The reference-count encoding is\n+   *  chosen so that a 0 indicates one reference, so you never try to\n+   *  destroy the empty-string _Rep object.\n+   *\n+   *  All but the last paragraph is considered pretty conventional\n+   *  for a C++ string implementation.\n+   *  @endif\n+  */\n   // 21.3  Template class basic_string\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     class basic_string\n@@ -104,7 +124,7 @@ namespace std\n                                                             const_iterator;\n       typedef reverse_iterator<const_iterator> \tconst_reverse_iterator;\n       typedef reverse_iterator<iterator> \t\t    reverse_iterator;\n-    \n+\n     private:\n       // _Rep: string representation\n       //   Invariants:\n@@ -125,26 +145,26 @@ namespace std\n \t// Types:\n \ttypedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;\n \n-\t// (Public) Data members: \n+\t// (Public) Data members:\n \n \t// The maximum number of individual char_type elements of an\n \t// individual string is determined by _S_max_size. This is the\n \t// value that will be returned by max_size().  (Whereas npos\n \t// is the maximum number of bytes the allocator can allocate.)\n \t// If one was to divvy up the theoretical largest size string,\n \t// with a terminating character and m _CharT elements, it'd\n-\t// look like this: \n+\t// look like this:\n \t// npos = sizeof(_Rep) + (m * sizeof(_CharT)) + sizeof(_CharT)\n \t// Solving for m:\n-\t// m = ((npos - sizeof(_Rep))/sizeof(CharT)) - 1 \n+\t// m = ((npos - sizeof(_Rep))/sizeof(CharT)) - 1\n \t// In addition, this implementation quarters this ammount.\n \tstatic const size_type \t_S_max_size;\n \tstatic const _CharT \t_S_terminal;\n \n \tsize_type \t\t_M_length;\n \tsize_type \t\t_M_capacity;\n \t_Atomic_word\t\t_M_references;\n-\t\n+\n         bool\n \t_M_is_leaked() const\n         { return _M_references < 0; }\n@@ -154,50 +174,50 @@ namespace std\n         { return _M_references > 0; }\n \n         void\n-\t_M_set_leaked() \n+\t_M_set_leaked()\n         { _M_references = -1; }\n \n         void\n-\t_M_set_sharable() \n+\t_M_set_sharable()\n         { _M_references = 0; }\n \n-\t_CharT* \n+\t_CharT*\n \t_M_refdata() throw()\n \t{ return reinterpret_cast<_CharT*>(this + 1); }\n \n-\t_CharT& \n+\t_CharT&\n \toperator[](size_t __s) throw()\n \t{ return _M_refdata() [__s]; }\n \n-\t_CharT* \n+\t_CharT*\n \t_M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)\n-\t{ \n-\t  return (!_M_is_leaked() && __alloc1 == __alloc2) \n-\t          ? _M_refcopy() : _M_clone(__alloc1);  \n+\t{\n+\t  return (!_M_is_leaked() && __alloc1 == __alloc2)\n+\t          ? _M_refcopy() : _M_clone(__alloc1);\n \t}\n \n \t// Create & Destroy\n-\tstatic _Rep* \n+\tstatic _Rep*\n \t_S_create(size_t, const _Alloc&);\n \n-\tvoid \n+\tvoid\n \t_M_dispose(const _Alloc& __a)\n-\t{ \n-\t  if (__exchange_and_add(&_M_references, -1) <= 0)  \n-\t    _M_destroy(__a); \n+\t{\n+\t  if (__exchange_and_add(&_M_references, -1) <= 0)\n+\t    _M_destroy(__a);\n \t}  // XXX MT\n \n-\tvoid \n+\tvoid\n \t_M_destroy(const _Alloc&) throw();\n \n-\t_CharT* \n+\t_CharT*\n \t_M_refcopy() throw()\n-\t{ \n-\t  __atomic_add(&_M_references, 1); \n-\t  return _M_refdata(); \n+\t{\n+\t  __atomic_add(&_M_references, 1);\n+\t  return _M_refdata();\n \t}  // XXX MT\n \n-\t_CharT* \n+\t_CharT*\n \t_M_clone(const _Alloc&, size_type __res = 0);\n       };\n \n@@ -224,45 +244,45 @@ namespace std\n       // (carefully) in an empty string with one reference.\n       static size_type _S_empty_rep_storage[(sizeof(_Rep) + sizeof(_CharT) + sizeof(size_type) - 1)/sizeof(size_type)];\n \n-      _CharT* \n-      _M_data() const \n+      _CharT*\n+      _M_data() const\n       { return  _M_dataplus._M_p; }\n \n-      _CharT* \n-      _M_data(_CharT* __p) \n+      _CharT*\n+      _M_data(_CharT* __p)\n       { return (_M_dataplus._M_p = __p); }\n \n-      _Rep* \n+      _Rep*\n       _M_rep() const\n       { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }\n \n       // For the internal use we have functions similar to `begin'/`end'\n       // but they do not call _M_leak.\n-      iterator \n+      iterator\n       _M_ibegin() const { return iterator(_M_data()); }\n \n-      iterator \n+      iterator\n       _M_iend() const { return iterator(_M_data() + this->size()); }\n \n-      void \n+      void\n       _M_leak()    // for use in begin() & non-const op[]\n-      { \n-\tif (!_M_rep()->_M_is_leaked()) \n-\t  _M_leak_hard(); \n+      {\n+\tif (!_M_rep()->_M_is_leaked())\n+\t  _M_leak_hard();\n       }\n \n-      iterator \n+      iterator\n       _M_check(size_type __pos) const\n-      { \n+      {\n \tif (__pos > this->size())\n-\t  __throw_out_of_range(\"basic_string::_M_check\"); \n-\treturn _M_ibegin() + __pos; \n+\t  __throw_out_of_range(\"basic_string::_M_check\");\n+\treturn _M_ibegin() + __pos;\n       }\n \n       // NB: _M_fold doesn't check for a bad __pos1 value.\n-      iterator \n+      iterator\n       _M_fold(size_type __pos, size_type __off) const\n-      { \n+      {\n \tbool __testoff =  __off < this->size() - __pos;\n \tsize_type __newoff = __testoff ? __off : this->size() - __pos;\n \treturn (_M_ibegin() + __pos + __newoff);\n@@ -273,8 +293,8 @@ namespace std\n       template<class _Iterator>\n         static void\n         _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)\n-        { \n-\t  for (; __k1 != __k2; ++__k1, ++__p) \n+        {\n+\t  for (; __k1 != __k2; ++__k1, ++__p)\n \t    traits_type::assign(*__p, *__k1); // These types are off.\n \t}\n \n@@ -285,7 +305,7 @@ namespace std\n       static void\n       _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)\n       { _S_copy_chars(__p, __k1.base(), __k2.base()); }\n- \n+\n       static void\n       _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)\n       { traits_type::copy(__p, __k1, __k2 - __k1); }\n@@ -294,13 +314,13 @@ namespace std\n       _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)\n       { traits_type::copy(__p, __k1, __k2 - __k1); }\n \n-      void \n+      void\n       _M_mutate(size_type __pos, size_type __len1, size_type __len2);\n \n-      void \n+      void\n       _M_leak_hard();\n \n-      static _Rep& \n+      static _Rep&\n       _S_empty_rep()\n       { return *reinterpret_cast<_Rep*>(&_S_empty_rep_storage); }\n \n@@ -309,10 +329,10 @@ namespace std\n       // NB: We overload ctors in some cases instead of using default\n       // arguments, per 17.4.4.4 para. 2 item 2.\n \n-      inline \n+      inline\n       basic_string();\n \n-      explicit \n+      explicit\n       basic_string(const _Alloc& __a);\n \n       // NB: per LWG issue 42, semantics different from IS:\n@@ -331,154 +351,154 @@ namespace std\n         basic_string(_InputIterator __beg, _InputIterator __end,\n \t\t     const _Alloc& __a = _Alloc());\n \n-      ~basic_string() \n+      ~basic_string()\n       { _M_rep()->_M_dispose(this->get_allocator()); }\n \n-      basic_string& \n+      basic_string&\n       operator=(const basic_string& __str) { return this->assign(__str); }\n \n-      basic_string& \n+      basic_string&\n       operator=(const _CharT* __s) { return this->assign(__s); }\n \n-      basic_string& \n+      basic_string&\n       operator=(_CharT __c) { return this->assign(1, __c); }\n \n       // Iterators:\n-      iterator \n-      begin() \n-      { \n-\t_M_leak(); \n+      iterator\n+      begin()\n+      {\n+\t_M_leak();\n \treturn iterator(_M_data());\n       }\n \n-      const_iterator \n-      begin() const \n+      const_iterator\n+      begin() const\n       { return const_iterator(_M_data()); }\n \n-      iterator \n+      iterator\n       end()\n       {\n          _M_leak();\n \t return iterator(_M_data() + this->size());\n       }\n \n-      const_iterator \n+      const_iterator\n       end() const\n       { return const_iterator(_M_data() + this->size()); }\n \n-      reverse_iterator \n-      rbegin() \n+      reverse_iterator\n+      rbegin()\n       { return reverse_iterator(this->end()); }\n \n-      const_reverse_iterator \n-      rbegin() const \n+      const_reverse_iterator\n+      rbegin() const\n       { return const_reverse_iterator(this->end()); }\n \n-      reverse_iterator \n-      rend() \n+      reverse_iterator\n+      rend()\n       { return reverse_iterator(this->begin()); }\n \n-      const_reverse_iterator \n-      rend() const \n+      const_reverse_iterator\n+      rend() const\n       { return const_reverse_iterator(this->begin()); }\n \n     public:\n       // Capacity:\n-      size_type \n+      size_type\n       size() const { return _M_rep()->_M_length; }\n \n-      size_type \n+      size_type\n       length() const { return _M_rep()->_M_length; }\n \n-      size_type \n+      size_type\n       max_size() const { return _Rep::_S_max_size; }\n \n-      void \n+      void\n       resize(size_type __n, _CharT __c);\n \n-      void \n+      void\n       resize(size_type __n) { this->resize(__n, _CharT()); }\n \n-      size_type \n+      size_type\n       capacity() const { return _M_rep()->_M_capacity; }\n \n-      void \n+      void\n       reserve(size_type __res_arg = 0);\n \n-      void \n+      void\n       clear() { _M_mutate(0, this->size(), 0); }\n \n-      bool \n+      bool\n       empty() const { return this->size() == 0; }\n \n       // Element access:\n-      const_reference \n-      operator[] (size_type __pos) const \n+      const_reference\n+      operator[] (size_type __pos) const\n       { return _M_data()[__pos]; }\n \n-      reference \n-      operator[](size_type __pos) \n-      { \n-\t_M_leak(); \n-\treturn _M_data()[__pos]; \n+      reference\n+      operator[](size_type __pos)\n+      {\n+\t_M_leak();\n+\treturn _M_data()[__pos];\n       }\n \n-      const_reference \n+      const_reference\n       at(size_type __n) const\n       {\n \tif (__n >= this->size())\n \t  __throw_out_of_range(\"basic_string::at\");\n-\treturn _M_data()[__n]; \n+\treturn _M_data()[__n];\n       }\n \n-      reference \n+      reference\n       at(size_type __n)\n       {\n \tif (__n >= size())\n \t  __throw_out_of_range(\"basic_string::at\");\n-\t_M_leak(); \n-\treturn _M_data()[__n]; \n+\t_M_leak();\n+\treturn _M_data()[__n];\n       }\n \n       // Modifiers:\n-      basic_string& \n+      basic_string&\n       operator+=(const basic_string& __str) { return this->append(__str); }\n \n-      basic_string& \n+      basic_string&\n       operator+=(const _CharT* __s) { return this->append(__s); }\n \n-      basic_string& \n+      basic_string&\n       operator+=(_CharT __c) { return this->append(size_type(1), __c); }\n \n-      basic_string& \n+      basic_string&\n       append(const basic_string& __str);\n \n-      basic_string& \n+      basic_string&\n       append(const basic_string& __str, size_type __pos, size_type __n);\n \n-      basic_string& \n+      basic_string&\n       append(const _CharT* __s, size_type __n);\n \n-      basic_string& \n+      basic_string&\n       append(const _CharT* __s)\n       { return this->append(__s, traits_type::length(__s)); }\n \n-      basic_string& \n+      basic_string&\n       append(size_type __n, _CharT __c);\n \n       template<class _InputIterator>\n-        basic_string& \n+        basic_string&\n         append(_InputIterator __first, _InputIterator __last)\n         { return this->replace(_M_iend(), _M_iend(), __first, __last); }\n \n-      void \n+      void\n       push_back(_CharT __c)\n       { this->replace(_M_iend(), _M_iend(), 1, __c); }\n \n-      basic_string& \n+      basic_string&\n       assign(const basic_string& __str);\n \n-      basic_string& \n+      basic_string&\n       assign(const basic_string& __str, size_type __pos, size_type __n)\n       {\n \tconst size_type __strsize = __str.size();\n@@ -489,7 +509,7 @@ namespace std\n \treturn this->assign(__str._M_data() + __pos, __newsize);\n       }\n \n-      basic_string& \n+      basic_string&\n       assign(const _CharT* __s, size_type __n)\n       {\n \tif (__n > this->max_size())\n@@ -511,32 +531,32 @@ namespace std\n \t  }\n       }\n \n-      basic_string& \n+      basic_string&\n       assign(const _CharT* __s)\n       { return this->assign(__s, traits_type::length(__s)); }\n \n-      basic_string& \n+      basic_string&\n       assign(size_type __n, _CharT __c)\n       { return this->replace(_M_ibegin(), _M_iend(), __n, __c); }\n \n       template<class _InputIterator>\n-        basic_string& \n+        basic_string&\n         assign(_InputIterator __first, _InputIterator __last)\n         { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }\n \n-      void \n+      void\n       insert(iterator __p, size_type __n, _CharT __c)\n       {\tthis->replace(__p, __p, __n, __c);  }\n \n       template<class _InputIterator>\n         void insert(iterator __p, _InputIterator __beg, _InputIterator __end)\n         { this->replace(__p, __p, __beg, __end); }\n \n-      basic_string& \n+      basic_string&\n       insert(size_type __pos1, const basic_string& __str)\n       { return this->insert(__pos1, __str, 0, __str.size()); }\n \n-      basic_string& \n+      basic_string&\n       insert(size_type __pos1, const basic_string& __str,\n \t     size_type __pos2, size_type __n)\n       {\n@@ -545,10 +565,10 @@ namespace std\n \t  __throw_out_of_range(\"basic_string::insert\");\n \tconst bool __testn = __n < __strsize - __pos2;\n \tconst size_type __newsize = __testn ? __n : __strsize - __pos2;\n-\treturn this->insert(__pos1, __str._M_data() + __pos2, __newsize); \n+\treturn this->insert(__pos1, __str._M_data() + __pos2, __newsize);\n       }\n \n-      basic_string& \n+      basic_string&\n       insert(size_type __pos, const _CharT* __s, size_type __n)\n       {\n \tconst size_type __size = this->size();\n@@ -582,43 +602,43 @@ namespace std\n \t  }\n        }\n \n-      basic_string&  \n+      basic_string&\n       insert(size_type __pos, const _CharT* __s)\n       { return this->insert(__pos, __s, traits_type::length(__s)); }\n \n-      basic_string& \n+      basic_string&\n       insert(size_type __pos, size_type __n, _CharT __c)\n-      { \n-\tthis->insert(_M_check(__pos), __n, __c); \n-\treturn *this; \n+      {\n+\tthis->insert(_M_check(__pos), __n, __c);\n+\treturn *this;\n       }\n \n-      iterator \n+      iterator\n       insert(iterator __p, _CharT __c = _CharT())\n       {\n \tsize_type __pos = __p - _M_ibegin();\n \tthis->insert(_M_check(__pos), size_type(1), __c);\n-\t_M_rep()->_M_set_leaked(); \n- \treturn this->_M_ibegin() + __pos; \n+\t_M_rep()->_M_set_leaked();\n+ \treturn this->_M_ibegin() + __pos;\n       }\n \n-      basic_string& \n+      basic_string&\n       erase(size_type __pos = 0, size_type __n = npos)\n-      { \n+      {\n \treturn this->replace(_M_check(__pos), _M_fold(__pos, __n),\n-\t\t\t     _M_data(), _M_data()); \n+\t\t\t     _M_data(), _M_data());\n       }\n \n-      iterator \n+      iterator\n       erase(iterator __position)\n       {\n \tsize_type __i = __position - _M_ibegin();\n         this->replace(__position, __position + 1, _M_data(), _M_data());\n-\t_M_rep()->_M_set_leaked(); \n+\t_M_rep()->_M_set_leaked();\n \treturn _M_ibegin() + __i;\n       }\n \n-      iterator \n+      iterator\n       erase(iterator __first, iterator __last)\n       {\n         size_type __i = __first - _M_ibegin();\n@@ -627,18 +647,18 @@ namespace std\n        return _M_ibegin() + __i;\n       }\n \n-      basic_string& \n+      basic_string&\n       replace(size_type __pos, size_type __n, const basic_string& __str)\n       { return this->replace(__pos, __n, __str._M_data(), __str.size()); }\n \n-      basic_string& \n+      basic_string&\n       replace(size_type __pos1, size_type __n1, const basic_string& __str,\n \t      size_type __pos2, size_type __n2);\n \n-      basic_string& \n+      basic_string&\n       replace(size_type __pos, size_type __n1, const _CharT* __s,\n \t      size_type __n2)\n-      { \n+      {\n \tconst size_type __size = this->size();\n  \tif (__pos > __size)\n \t  __throw_out_of_range(\"basic_string::replace\");\n@@ -657,70 +677,70 @@ namespace std\n \t\t\t  typename iterator_traits<const _CharT*>::iterator_category());\n       }\n \n-      basic_string& \n+      basic_string&\n       replace(size_type __pos, size_type __n1, const _CharT* __s)\n       { return this->replace(__pos, __n1, __s, traits_type::length(__s)); }\n \n-      basic_string& \n+      basic_string&\n       replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)\n       { return this->replace(_M_check(__pos), _M_fold(__pos, __n1), __n2, __c); }\n \n-      basic_string& \n+      basic_string&\n       replace(iterator __i1, iterator __i2, const basic_string& __str)\n       { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }\n \n-      basic_string& \n+      basic_string&\n       replace(iterator __i1, iterator __i2,\n                            const _CharT* __s, size_type __n)\n       { return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n); }\n \n-      basic_string& \n+      basic_string&\n       replace(iterator __i1, iterator __i2, const _CharT* __s)\n       { return this->replace(__i1, __i2, __s, traits_type::length(__s)); }\n \n-      basic_string& \n+      basic_string&\n       replace(iterator __i1, iterator __i2, size_type __n, _CharT __c);\n \n       template<class _InputIterator>\n-        basic_string& \n+        basic_string&\n         replace(iterator __i1, iterator __i2,\n \t\t_InputIterator __k1, _InputIterator __k2)\n         { return _M_replace(__i1, __i2, __k1, __k2,\n \t     typename iterator_traits<_InputIterator>::iterator_category()); }\n \n       // Specializations for the common case of pointer and iterator:\n       // useful to avoid the overhead of temporary buffering in _M_replace.\n-      basic_string& \n+      basic_string&\n       replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)\n         { return this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n \t\t\t       __k1, __k2 - __k1); }\n \n-      basic_string& \n+      basic_string&\n       replace(iterator __i1, iterator __i2, const _CharT* __k1, const _CharT* __k2)\n         { return this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n \t\t\t       __k1, __k2 - __k1); }\n \n-      basic_string& \n+      basic_string&\n       replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)\n         { return this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n \t\t\t       __k1.base(), __k2 - __k1);\n \t}\n \n-      basic_string& \n+      basic_string&\n       replace(iterator __i1, iterator __i2, const_iterator __k1, const_iterator __k2)\n         { return this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n \t\t\t       __k1.base(), __k2 - __k1);\n \t}\n \n     private:\n       template<class _InputIterator>\n-        basic_string& \n-        _M_replace(iterator __i1, iterator __i2, _InputIterator __k1, \n+        basic_string&\n+        _M_replace(iterator __i1, iterator __i2, _InputIterator __k1,\n \t\t   _InputIterator __k2, input_iterator_tag);\n \n       template<class _ForwardIterator>\n-        basic_string& \n-        _M_replace_safe(iterator __i1, iterator __i2, _ForwardIterator __k1, \n+        basic_string&\n+        _M_replace_safe(iterator __i1, iterator __i2, _ForwardIterator __k1,\n \t\t   _ForwardIterator __k2);\n \n       // _S_construct_aux is used to implement the 21.3.1 para 15 which\n@@ -733,7 +753,7 @@ namespace std\n           typedef typename iterator_traits<_InIter>::iterator_category _Tag;\n           return _S_construct(__beg, __end, __a, _Tag());\n \t}\n- \n+\n       template<class _InIter>\n         static _CharT*\n         _S_construct_aux(_InIter __beg, _InIter __end, const _Alloc& __a,\n@@ -742,7 +762,7 @@ namespace std\n \t  return _S_construct(static_cast<size_type>(__beg),\n \t\t\t      static_cast<value_type>(__end), __a);\n \t}\n- \n+\n       template<class _InIter>\n         static _CharT*\n         _S_construct(_InIter __beg, _InIter __end, const _Alloc& __a)\n@@ -756,27 +776,27 @@ namespace std\n         static _CharT*\n          _S_construct(_InIter __beg, _InIter __end, const _Alloc& __a,\n \t\t      input_iterator_tag);\n-      \n+\n       // For forward_iterators up to random_access_iterators, used for\n       // string::iterator, _CharT*, etc.\n       template<class _FwdIter>\n         static _CharT*\n         _S_construct(_FwdIter __beg, _FwdIter __end, const _Alloc& __a,\n \t\t     forward_iterator_tag);\n \n-      static _CharT* \n+      static _CharT*\n       _S_construct(size_type __req, _CharT __c, const _Alloc& __a);\n \n     public:\n \n-      size_type \n+      size_type\n       copy(_CharT* __s, size_type __n, size_type __pos = 0) const;\n \n-      void \n+      void\n       swap(basic_string<_CharT, _Traits, _Alloc>& __s);\n \n       // String operations:\n-      const _CharT* \n+      const _CharT*\n       c_str() const\n       {\n \t// MT: This assumes concurrent writes are OK.\n@@ -785,137 +805,137 @@ namespace std\n         return _M_data();\n       }\n \n-      const _CharT* \n+      const _CharT*\n       data() const { return _M_data(); }\n \n-      allocator_type \n+      allocator_type\n       get_allocator() const { return _M_dataplus; }\n \n-      size_type \n+      size_type\n       find(const _CharT* __s, size_type __pos, size_type __n) const;\n \n-      size_type \n+      size_type\n       find(const basic_string& __str, size_type __pos = 0) const\n       { return this->find(__str.data(), __pos, __str.size()); }\n \n-      size_type \n+      size_type\n       find(const _CharT* __s, size_type __pos = 0) const\n       { return this->find(__s, __pos, traits_type::length(__s)); }\n \n-      size_type \n+      size_type\n       find(_CharT __c, size_type __pos = 0) const;\n \n-      size_type \n+      size_type\n       rfind(const basic_string& __str, size_type __pos = npos) const\n       { return this->rfind(__str.data(), __pos, __str.size()); }\n \n-      size_type \n+      size_type\n       rfind(const _CharT* __s, size_type __pos, size_type __n) const;\n \n-      size_type \n+      size_type\n       rfind(const _CharT* __s, size_type __pos = npos) const\n       { return this->rfind(__s, __pos, traits_type::length(__s)); }\n \n-      size_type \n+      size_type\n       rfind(_CharT __c, size_type __pos = npos) const;\n \n-      size_type \n+      size_type\n       find_first_of(const basic_string& __str, size_type __pos = 0) const\n       { return this->find_first_of(__str.data(), __pos, __str.size()); }\n \n-      size_type \n+      size_type\n       find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;\n \n-      size_type \n+      size_type\n       find_first_of(const _CharT* __s, size_type __pos = 0) const\n       { return this->find_first_of(__s, __pos, traits_type::length(__s)); }\n \n-      size_type \n+      size_type\n       find_first_of(_CharT __c, size_type __pos = 0) const\n       { return this->find(__c, __pos); }\n \n-      size_type \n+      size_type\n       find_last_of(const basic_string& __str, size_type __pos = npos) const\n       { return this->find_last_of(__str.data(), __pos, __str.size()); }\n \n-      size_type \n+      size_type\n       find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;\n \n-      size_type \n+      size_type\n       find_last_of(const _CharT* __s, size_type __pos = npos) const\n       { return this->find_last_of(__s, __pos, traits_type::length(__s)); }\n \n-      size_type \n+      size_type\n       find_last_of(_CharT __c, size_type __pos = npos) const\n       { return this->rfind(__c, __pos); }\n \n-      size_type \n+      size_type\n       find_first_not_of(const basic_string& __str, size_type __pos = 0) const\n       { return this->find_first_not_of(__str.data(), __pos, __str.size()); }\n \n-      size_type \n-      find_first_not_of(const _CharT* __s, size_type __pos, \n+      size_type\n+      find_first_not_of(const _CharT* __s, size_type __pos,\n \t\t\tsize_type __n) const;\n \n-      size_type \n+      size_type\n       find_first_not_of(const _CharT* __s, size_type __pos = 0) const\n       { return this->find_first_not_of(__s, __pos, traits_type::length(__s)); }\n \n-      size_type \n+      size_type\n       find_first_not_of(_CharT __c, size_type __pos = 0) const;\n \n-      size_type \n+      size_type\n       find_last_not_of(const basic_string& __str, size_type __pos = npos) const\n       { return this->find_last_not_of(__str.data(), __pos, __str.size()); }\n \n-      size_type \n-      find_last_not_of(const _CharT* __s, size_type __pos, \n+      size_type\n+      find_last_not_of(const _CharT* __s, size_type __pos,\n \t\t       size_type __n) const;\n-      size_type \n+      size_type\n       find_last_not_of(const _CharT* __s, size_type __pos = npos) const\n       { return this->find_last_not_of(__s, __pos, traits_type::length(__s)); }\n \n-      size_type \n+      size_type\n       find_last_not_of(_CharT __c, size_type __pos = npos) const;\n \n-      basic_string \n+      basic_string\n       substr(size_type __pos = 0, size_type __n = npos) const\n-      { \n+      {\n \tif (__pos > this->size())\n \t  __throw_out_of_range(\"basic_string::substr\");\n-\treturn basic_string(*this, __pos, __n); \n+\treturn basic_string(*this, __pos, __n);\n       }\n \n-      int \n+      int\n       compare(const basic_string& __str) const\n       {\n \tsize_type __size = this->size();\n \tsize_type __osize = __str.size();\n \tsize_type __len = min(__size, __osize);\n-      \n+\n \tint __r = traits_type::compare(_M_data(), __str.data(), __len);\n \tif (!__r)\n \t  __r =  __size - __osize;\n \treturn __r;\n       }\n \n-      int \n+      int\n       compare(size_type __pos, size_type __n, const basic_string& __str) const;\n \n-      int \n+      int\n       compare(size_type __pos1, size_type __n1, const basic_string& __str,\n \t      size_type __pos2, size_type __n2) const;\n \n-      int \n+      int\n       compare(const _CharT* __s) const;\n \n       // _GLIBCPP_RESOLVE_LIB_DEFECTS\n       // 5. String::compare specification questionable\n-      int \n+      int\n       compare(size_type __pos, size_type __n1, const _CharT* __s) const;\n \n-      int \n-      compare(size_type __pos, size_type __n1, const _CharT* __s, \n+      int\n+      compare(size_type __pos, size_type __n1, const _CharT* __s,\n \t      size_type __n2) const;\n   };\n "}, {"sha": "2b733cd94a013b7e6ac46c89789f9e0effcb8778", "filename": "libstdc++-v3/include/bits/char_traits.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchar_traits.h?ref=51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6", "patch": "@@ -42,17 +42,21 @@\n \n #pragma GCC system_header\n \n-#include <cstring> \t// For memmove, memset, memchr\n-#include <bits/fpos.h> \t\t// For streampos\n+#include <cstring>            // For memmove, memset, memchr\n+#include <bits/fpos.h>        // For streampos\n \n namespace std \n {\n-  // 21.1.2\n+  // 21.1\n   /**\n    *  @brief  Basis for explicit traits specializations.\n    *\n    *  @note  For any given actual character type, this definition is\n    *  probably wrong.\n+   *\n+   *  See http://gcc.gnu.org/onlinedocs/libstdc++/21_strings/howto.html#5\n+   *  for advice on how to make use of this class for \"unusual\" character\n+   *  types.\n   */\n   template<class _CharT>\n     struct char_traits\n@@ -108,7 +112,7 @@ namespace std\n     };\n \n \n-  /// 21.1.4  char_traits specializations\n+  /// 21.1.3.1  char_traits specializations\n   template<>\n     struct char_traits<char>\n     {\n@@ -178,6 +182,7 @@ namespace std\n \n \n #ifdef _GLIBCPP_USE_WCHAR_T\n+  /// 21.1.3.2  char_traits specializations\n   template<>\n     struct char_traits<wchar_t>\n     {"}, {"sha": "07b1009a4b2b7a99c291337ce5de9bb4cc7be9ff", "filename": "libstdc++-v3/include/bits/stringfwd.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstringfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstringfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstringfwd.h?ref=51122a4242c0d510a5b4de7f2d8a34ec0fe74cc6", "patch": "@@ -60,7 +60,9 @@ namespace std\n            typename _Alloc = allocator<_CharT> >\n     class basic_string;\n \n+  /// 99%% of %string users only ever [need to] see the typedef.\n   typedef basic_string<char>    string;\n+  /// 99%% of %wstring users only ever [need to] see the typedef.\n   typedef basic_string<wchar_t> wstring;\n } // namespace std\n "}]}