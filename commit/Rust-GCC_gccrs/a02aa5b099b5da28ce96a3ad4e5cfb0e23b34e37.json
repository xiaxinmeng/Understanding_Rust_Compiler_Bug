{"sha": "a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTAyYWE1YjA5OWI1ZGEyOGNlOTZhM2FkNGU1Y2ZiMGUyM2IzNGUzNw==", "commit": {"author": {"name": "John David Anglin", "email": "dave@hiauly1.hia.nrc.ca", "date": "2002-10-31T03:13:44Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2002-10-31T03:13:44Z"}, "message": "pa-linux.h (ASM_OUTPUT_EXTERNAL_LIBCALL): Define.\n\n\t* pa-linux.h (ASM_OUTPUT_EXTERNAL_LIBCALL): Define.\n\t* pa-protos.h (attr_length_millicode_call, attr_length_call,\n\tpa_init_machine_status): Declare new global functions.\n\t* pa.c (void copy_fp_args, length_fp_args, get_plabel): Declare and\n\timplement new functions.\n\t(attr_length_millicode_call, attr_length_call): Implement.\n\t(total_code_bytes): Change type to long.\n\t(pa_output_function_prologue): Compute total_code_bytes on TARGET_64BIT.\n\tReset counter if flag_function_sections.\n\t(output_deferred_plabels): Set output alignment to 3 for TARGET_64BIT.\n\t(output_cbranch): Move call to gen_label_rtx.\n\t(output_millicode_call): Rewrite adding long TARGET_64BIT call, expose\n\tdelay slot in all variants, shorten pc-relative calls.\n\t(output_call): Rewrite adding long TARGET_64BIT call, improved delay\n\tslot usage and exposure, various new call variants, and shortened\n\tsequences for some variants on TARGET_PA_20.\n\tMiscellaneous format changes.\n\t* pa.h (total_code_bytes): Change type to long.\n\t(MASK_LONG_CALLS, TARGET_LONG_CALLS, TARGET_LONG_ABS_CALL,\n\tTARGET_LONG_PIC_SDIFF_CALL, TARGET_LONG_PIC_PCREL_CALL): Define.\n\t(TARGET_SWITCHES): Add \"-mlong-calls\" and \"-mno-long-calls\" options.\n\t(EXTRA_CONSTRAINT, GO_IF_LEGITIMATE_ADDRESS,\n\tLEGITIMIZE_RELOAD_ADDRESS): Don't use long floating point loads and\n\tstores on TARGET_ELF32.\n\t*pa.md (define_delay): Allow insns in delay on TARGET_PORTABLE_RUNTIME.\n\t(unnamed patterns for mulsi3, divsi3, udivsi3, modsi3, umodsi3 and\n\tcanonicalize_funcptr_for_compare expanders): Calculate attribute length\n\tattr_length_millicode_call().\n\t(call_internal_symref, call_value_internal_symref): Clobber register 1.\n\tCalculate attribute length using attr_length_call().\n\t(call_internal_reg_64bit, call_value_internal_reg_64bit): Move gp load\n\tto delay slot.\n\t(sibcall, sibcall_value): Rewrite.\n\t(sibcall_internal_symref, sibcall_value_internal_symref): Clobber\n\tregister 1.  Use attr_length_call().\n\t(sibcall_internal_symref_64bit, sibcall_value_internal_symref_64bit):\n\tNew patterns.\n\t(unamed pattern for canonicalize_funcptr_for_compare): Rewrite.\n\t* som.h (MEMBER_TYPE_FORCES_BLK): Define.\n\t* t-pa64 (TARGET_LIBGCC2_CFLAGS): Add \"-mlong-calls\".\n\t* doc/invoke.texi (mlong-calls): Document.\n\nFrom-SVN: r58665", "tree": {"sha": "f47286e288d980615f8a9fbf886fb3a2f0dffa4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f47286e288d980615f8a9fbf886fb3a2f0dffa4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37/comments", "author": null, "committer": null, "parents": [{"sha": "8c081e84f7b8dbc477c62c5a16834e2f6ce9d095", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c081e84f7b8dbc477c62c5a16834e2f6ce9d095", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c081e84f7b8dbc477c62c5a16834e2f6ce9d095"}], "stats": {"total": 1435, "additions": 816, "deletions": 619}, "files": [{"sha": "4031d7bf8630f2ff926bd6f309a6fd79fa4c95d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37", "patch": "@@ -1,3 +1,47 @@\n+2002-10-30  John David Anglin  <dave@hiauly.hia.nrc.ca>\n+\n+\t* pa-linux.h (ASM_OUTPUT_EXTERNAL_LIBCALL): Define.\n+\t* pa-protos.h (attr_length_millicode_call, attr_length_call,\n+\tpa_init_machine_status): Declare new global functions.\n+\t* pa.c (void copy_fp_args, length_fp_args, get_plabel): Declare and\n+\timplement new functions.\n+\t(attr_length_millicode_call, attr_length_call): Implement.\n+\t(total_code_bytes): Change type to long.\n+\t(pa_output_function_prologue): Compute total_code_bytes on TARGET_64BIT.\n+\tReset counter if flag_function_sections.\n+\t(output_deferred_plabels): Set output alignment to 3 for TARGET_64BIT.\n+\t(output_cbranch): Move call to gen_label_rtx.\n+\t(output_millicode_call): Rewrite adding long TARGET_64BIT call, expose\n+\tdelay slot in all variants, shorten pc-relative calls.\n+\t(output_call): Rewrite adding long TARGET_64BIT call, improved delay\n+\tslot usage and exposure, various new call variants, and shortened\n+\tsequences for some variants on TARGET_PA_20.\n+\tMiscellaneous format changes.\n+\t* pa.h (total_code_bytes): Change type to long.\n+\t(MASK_LONG_CALLS, TARGET_LONG_CALLS, TARGET_LONG_ABS_CALL,\n+\tTARGET_LONG_PIC_SDIFF_CALL, TARGET_LONG_PIC_PCREL_CALL): Define.\n+\t(TARGET_SWITCHES): Add \"-mlong-calls\" and \"-mno-long-calls\" options.\n+\t(EXTRA_CONSTRAINT, GO_IF_LEGITIMATE_ADDRESS,\n+\tLEGITIMIZE_RELOAD_ADDRESS): Don't use long floating point loads and\n+\tstores on TARGET_ELF32.\n+\t*pa.md (define_delay): Allow insns in delay on TARGET_PORTABLE_RUNTIME.\n+\t(unnamed patterns for mulsi3, divsi3, udivsi3, modsi3, umodsi3 and\n+\tcanonicalize_funcptr_for_compare expanders): Calculate attribute length\n+\tattr_length_millicode_call().\n+\t(call_internal_symref, call_value_internal_symref): Clobber register 1.\n+\tCalculate attribute length using attr_length_call().\n+\t(call_internal_reg_64bit, call_value_internal_reg_64bit): Move gp load\n+\tto delay slot.\n+\t(sibcall, sibcall_value): Rewrite.\n+\t(sibcall_internal_symref, sibcall_value_internal_symref): Clobber\n+\tregister 1.  Use attr_length_call().\n+\t(sibcall_internal_symref_64bit, sibcall_value_internal_symref_64bit):\n+\tNew patterns.\n+\t(unamed pattern for canonicalize_funcptr_for_compare): Rewrite.\n+\t* som.h (MEMBER_TYPE_FORCES_BLK): Define.\n+\t* t-pa64 (TARGET_LIBGCC2_CFLAGS): Add \"-mlong-calls\".\n+\t* doc/invoke.texi (mlong-calls): Document.\n+\n 2002-10-30  Roger Sayle  <roger@eyesopen.com>\n \n \t* fold-const.c (fold_binary_op_with_conditional_arg):  Improve"}, {"sha": "7f372faa8d3d61572ed348189b0b6a86d2721a96", "filename": "gcc/config/pa/pa-linux.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37/gcc%2Fconfig%2Fpa%2Fpa-linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37/gcc%2Fconfig%2Fpa%2Fpa-linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-linux.h?ref=a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37", "patch": "@@ -196,6 +196,19 @@ Boston, MA 02111-1307, USA.  */\n     }\t\t\t\t\t\t\t\t\\\n   while (0)\n \n+/* As well as globalizing the label, we need to encode the label\n+   to ensure a plabel is generated in an indirect call.  */\n+\n+#undef ASM_OUTPUT_EXTERNAL_LIBCALL\n+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)  \t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (!FUNCTION_NAME_P (XSTR (FUN, 0)))\t\t\t\\\n+\thppa_encode_label (FUN);\t\t\t\t\\\n+      (*targetm.asm_out.globalize_label) (FILE, XSTR (FUN, 0));\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n /* Linux always uses gas.  */\n #undef TARGET_GAS\n #define TARGET_GAS 1"}, {"sha": "5d1ab111d22f2ff762699a63699f5967f046c579", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37", "patch": "@@ -105,6 +105,8 @@ extern int jump_in_call_delay PARAMS ((rtx));\n extern enum reg_class secondary_reload_class PARAMS ((enum reg_class,\n \t\t\t\t\t\t      enum machine_mode, rtx));\n extern int hppa_fpstore_bypass_p PARAMS ((rtx, rtx));\n+extern int attr_length_millicode_call PARAMS ((rtx, int));\n+extern int attr_length_call PARAMS ((rtx, int));\n \n /* Declare functions defined in pa.c and used in templates.  */\n "}, {"sha": "b51e946852c253b98d3ce5f3b8e89791199e531b", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 556, "deletions": 364, "changes": 920, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37", "patch": "@@ -121,11 +121,13 @@ static void pa_globalize_label PARAMS ((FILE *, const char *))\n      ATTRIBUTE_UNUSED;\n static void pa_asm_output_mi_thunk PARAMS ((FILE *, tree, HOST_WIDE_INT,\n \t\t\t\t\t    HOST_WIDE_INT, tree));\n-\n+static void copy_fp_args PARAMS ((rtx)) ATTRIBUTE_UNUSED;\n+static int length_fp_args PARAMS ((rtx)) ATTRIBUTE_UNUSED;\n+static struct deferred_plabel *get_plabel PARAMS ((const char *))\n+     ATTRIBUTE_UNUSED;\n \n /* Save the operands last given to a compare for use when we\n    generate a scc or bcc insn.  */\n-\n rtx hppa_compare_op0, hppa_compare_op1;\n enum cmp_type hppa_branch_type;\n \n@@ -149,12 +151,10 @@ static rtx find_addr_reg PARAMS ((rtx));\n \n /* Keep track of the number of bytes we have output in the CODE subspaces\n    during this compilation so we'll know when to emit inline long-calls.  */\n-\n-unsigned int total_code_bytes;\n+unsigned long total_code_bytes;\n \n /* Variables to handle plabels that we discover are necessary at assembly\n    output time.  They are output after the current function.  */\n-\n struct deferred_plabel GTY(())\n {\n   rtx internal_label;\n@@ -3197,14 +3197,14 @@ pa_output_function_prologue (file, size)\n   fputs (\"\\n\\t.ENTRY\\n\", file);\n \n   /* If we're using GAS and SOM, and not using the portable runtime model,\n-     then we don't need to accumulate the total number of code bytes.  */\n+     or function sections, then we don't need to accumulate the total number\n+     of code bytes.  */\n   if ((TARGET_GAS && TARGET_SOM && ! TARGET_PORTABLE_RUNTIME)\n-      /* FIXME: we can't handle long calls for TARGET_64BIT.  */\n-      || TARGET_64BIT)\n+      || flag_function_sections)\n     total_code_bytes = 0;\n   else if (INSN_ADDRESSES_SET_P ())\n     {\n-      unsigned int old_total = total_code_bytes;\n+      unsigned long old_total = total_code_bytes;\n \n       total_code_bytes += INSN_ADDRESSES (INSN_UID (get_last_nonnote_insn ()));\n       total_code_bytes += FUNCTION_BOUNDARY / BITS_PER_UNIT;\n@@ -4726,6 +4726,47 @@ output_global_address (file, x, round_constant)\n     output_addr_const (file, x);\n }\n \n+static struct deferred_plabel *\n+get_plabel (fname)\n+     const char *fname;\n+{\n+  size_t i;\n+\n+  /* See if we have already put this function on the list of deferred\n+     plabels.  This list is generally small, so a liner search is not\n+     too ugly.  If it proves too slow replace it with something faster.  */\n+  for (i = 0; i < n_deferred_plabels; i++)\n+    if (strcmp (fname, deferred_plabels[i].name) == 0)\n+      break;\n+\n+  /* If the deferred plabel list is empty, or this entry was not found\n+     on the list, create a new entry on the list.  */\n+  if (deferred_plabels == NULL || i == n_deferred_plabels)\n+    {\n+      const char *real_name;\n+\n+      if (deferred_plabels == 0)\n+\tdeferred_plabels = (struct deferred_plabel *)\n+\t  ggc_alloc (sizeof (struct deferred_plabel));\n+      else\n+\tdeferred_plabels = (struct deferred_plabel *)\n+\t  ggc_realloc (deferred_plabels,\n+\t\t       ((n_deferred_plabels + 1)\n+\t\t\t* sizeof (struct deferred_plabel)));\n+\n+      i = n_deferred_plabels++;\n+      deferred_plabels[i].internal_label = gen_label_rtx ();\n+      deferred_plabels[i].name = ggc_strdup (fname);\n+\n+      /* Gross.  We have just implicitly taken the address of this function,\n+\t mark it as such.  */\n+      real_name = (*targetm.strip_name_encoding) (fname);\n+      TREE_SYMBOL_REFERENCED (get_identifier (real_name)) = 1;\n+    }\n+\n+  return &deferred_plabels[i];\n+}\n+\n void\n output_deferred_plabels (file)\n      FILE *file;\n@@ -4737,7 +4778,7 @@ output_deferred_plabels (file)\n   if (n_deferred_plabels)\n     {\n       data_section ();\n-      ASM_OUTPUT_ALIGN (file, 2);\n+      ASM_OUTPUT_ALIGN (file, TARGET_64BIT ? 3 : 2);\n     }\n \n   /* Now output the deferred plabels.  */\n@@ -5323,9 +5364,9 @@ hppa_va_arg (valist, type)\n \n const char *\n output_cbranch (operands, nullify, length, negated, insn)\n-  rtx *operands;\n-  int nullify, length, negated;\n-  rtx insn;\n+     rtx *operands;\n+     int nullify, length, negated;\n+     rtx insn;\n {\n   static char buf[100];\n   int useskip = 0;\n@@ -5499,12 +5540,11 @@ output_cbranch (operands, nullify, length, negated, insn)\n \t  xoperands[1] = operands[1];\n \t  xoperands[2] = operands[2];\n \t  xoperands[3] = operands[3];\n-\t  if (TARGET_SOM || ! TARGET_GAS)\n-\t    xoperands[4] = gen_label_rtx ();\n \n \t  output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n-\t  if (TARGET_SOM || ! TARGET_GAS)\n+\t  if (TARGET_SOM || !TARGET_GAS)\n \t    {\n+\t      xoperands[4] = gen_label_rtx ();\n \t      output_asm_insn (\"addil L'%l0-%l4,%%r1\", xoperands);\n \t      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n \t\t\t\t\t CODE_LABEL_NUMBER (xoperands[4]));\n@@ -5536,10 +5576,10 @@ output_cbranch (operands, nullify, length, negated, insn)\n \n const char *\n output_bb (operands, nullify, length, negated, insn, which)\n-  rtx *operands ATTRIBUTE_UNUSED;\n-  int nullify, length, negated;\n-  rtx insn;\n-  int which;\n+     rtx *operands ATTRIBUTE_UNUSED;\n+     int nullify, length, negated;\n+     rtx insn;\n+     int which;\n {\n   static char buf[100];\n   int useskip = 0;\n@@ -5684,10 +5724,10 @@ output_bb (operands, nullify, length, negated, insn, which)\n \n const char *\n output_bvb (operands, nullify, length, negated, insn, which)\n-  rtx *operands ATTRIBUTE_UNUSED;\n-  int nullify, length, negated;\n-  rtx insn;\n-  int which;\n+     rtx *operands ATTRIBUTE_UNUSED;\n+     int nullify, length, negated;\n+     rtx insn;\n+     int which;\n {\n   static char buf[100];\n   int useskip = 0;\n@@ -6043,442 +6083,594 @@ output_movb (operands, insn, which_alternative, reverse_comparison)\n     }\n }\n \n+/* Copy any FP arguments in INSN into integer registers.  */\n+static void\n+copy_fp_args (insn)\n+     rtx insn;\n+{\n+  rtx link;\n+  rtx xoperands[2];\n \n-/* INSN is a millicode call.  It may have an unconditional jump in its delay\n-   slot.\n-\n-   CALL_DEST is the routine we are calling.  */\n+  for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n+    {\n+      int arg_mode, regno;\n+      rtx use = XEXP (link, 0);\n \n-const char *\n-output_millicode_call (insn, call_dest)\n-  rtx insn;\n-  rtx call_dest;\n-{\n-  int attr_length = get_attr_length (insn);\n-  int seq_length = dbr_sequence_length ();\n-  int distance;\n-  rtx xoperands[4];\n-  rtx seq_insn;\n+      if (! (GET_CODE (use) == USE\n+\t  && GET_CODE (XEXP (use, 0)) == REG\n+\t  && FUNCTION_ARG_REGNO_P (REGNO (XEXP (use, 0)))))\n+\tcontinue;\n \n-  xoperands[3] = gen_rtx_REG (Pmode, TARGET_64BIT ? 2 : 31);\n+      arg_mode = GET_MODE (XEXP (use, 0));\n+      regno = REGNO (XEXP (use, 0));\n \n-  /* Handle common case -- empty delay slot or no jump in the delay slot,\n-     and we're sure that the branch will reach the beginning of the $CODE$\n-     subspace.  The within reach form of the $$sh_func_adrs call has\n-     a length of 28 and attribute type of multi.  This length is the\n-     same as the maximum length of an out of reach PIC call to $$div.  */\n-  if ((seq_length == 0\n-       && (attr_length == 8\n-\t   || (attr_length == 28 && get_attr_type (insn) == TYPE_MULTI)))\n-      || (seq_length != 0\n-\t  && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN\n-\t  && attr_length == 4))\n-    {\n-      xoperands[0] = call_dest;\n-      output_asm_insn (\"{bl|b,l} %0,%3%#\", xoperands);\n-      return \"\";\n+      /* Is it a floating point register?  */\n+      if (regno >= 32 && regno <= 39)\n+\t{\n+\t  /* Copy the FP register into an integer register via memory.  */\n+\t  if (arg_mode == SFmode)\n+\t    {\n+\t      xoperands[0] = XEXP (use, 0);\n+\t      xoperands[1] = gen_rtx_REG (SImode, 26 - (regno - 32) / 2);\n+\t      output_asm_insn (\"{fstws|fstw} %0,-16(%%sr0,%%r30)\", xoperands);\n+\t      output_asm_insn (\"ldw -16(%%sr0,%%r30),%1\", xoperands);\n+\t    }\n+\t  else\n+\t    {\n+\t      xoperands[0] = XEXP (use, 0);\n+\t      xoperands[1] = gen_rtx_REG (DImode, 25 - (regno - 34) / 2);\n+\t      output_asm_insn (\"{fstds|fstd} %0,-16(%%sr0,%%r30)\", xoperands);\n+\t      output_asm_insn (\"ldw -12(%%sr0,%%r30),%R1\", xoperands);\n+\t      output_asm_insn (\"ldw -16(%%sr0,%%r30),%1\", xoperands);\n+\t    }\n+\t}\n     }\n+}\n+\n+/* Compute length of the FP argument copy sequence for INSN.  */\n+static int\n+length_fp_args (insn)\n+     rtx insn;\n+{\n+  int length = 0;\n+  rtx link;\n \n-  /* This call may not reach the beginning of the $CODE$ subspace.  */\n-  if (attr_length > 8)\n+  for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n     {\n-      int delay_insn_deleted = 0;\n+      int arg_mode, regno;\n+      rtx use = XEXP (link, 0);\n \n-      /* We need to emit an inline long-call branch.  */\n-      if (seq_length != 0\n-\t  && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN)\n+      if (! (GET_CODE (use) == USE\n+\t  && GET_CODE (XEXP (use, 0)) == REG\n+\t  && FUNCTION_ARG_REGNO_P (REGNO (XEXP (use, 0)))))\n+\tcontinue;\n+\n+      arg_mode = GET_MODE (XEXP (use, 0));\n+      regno = REGNO (XEXP (use, 0));\n+\n+      /* Is it a floating point register?  */\n+      if (regno >= 32 && regno <= 39)\n \t{\n-\t  /* A non-jump insn in the delay slot.  By definition we can\n-\t     emit this insn before the call.  */\n-\t  final_scan_insn (NEXT_INSN (insn), asm_out_file, optimize, 0, 0);\n-\n-\t  /* Now delete the delay insn.  */\n-\t  PUT_CODE (NEXT_INSN (insn), NOTE);\n-\t  NOTE_LINE_NUMBER (NEXT_INSN (insn)) = NOTE_INSN_DELETED;\n-\t  NOTE_SOURCE_FILE (NEXT_INSN (insn)) = 0;\n-\t  delay_insn_deleted = 1;\n+\t  if (arg_mode == SFmode)\n+\t    length += 8;\n+\t  else\n+\t    length += 12;\n \t}\n+    }\n \n-      /* PIC long millicode call sequence.  */\n-      if (flag_pic)\n-\t{\n-\t  xoperands[0] = call_dest;\n-\t  if (TARGET_SOM || ! TARGET_GAS)\n-\t    xoperands[1] = gen_label_rtx ();\n+  return length;\n+}\n \n-\t  /* Get our address + 8 into %r1.  */\n-\t  output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n+/* We include the delay slot in the returned length as it is better to\n+   over estimate the length than to under estimate it.  */\n \n-\t  if (TARGET_SOM || ! TARGET_GAS)\n-\t    {\n-\t      /* Add %r1 to the offset of our target from the next insn.  */\n-\t      output_asm_insn (\"addil L%%%0-%1,%%r1\", xoperands);\n-\t      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n-\t\t\t\t\t CODE_LABEL_NUMBER (xoperands[1]));\n-\t      output_asm_insn (\"ldo R%%%0-%1(%%r1),%%r1\", xoperands);\n-\t    }\n-\t  else\n-\t    {\n-\t      output_asm_insn (\"addil L%%%0-$PIC_pcrel$0+4,%%r1\", xoperands);\n-\t      output_asm_insn (\"ldo R%%%0-$PIC_pcrel$0+8(%%r1),%%r1\",\n-\t\t\t       xoperands);\n-\t    }\n+int\n+attr_length_millicode_call (insn, length)\n+     rtx insn;\n+     int length;\n+{\n+  unsigned long distance = total_code_bytes + INSN_ADDRESSES (INSN_UID (insn));\n+\n+  if (distance < total_code_bytes)\n+    distance = -1;\n+\n+  if (TARGET_64BIT)\n+    {\n+      if (!TARGET_LONG_CALLS && distance < 7600000)\n+\treturn length + 8;\n+\n+      return length + 20;\n+    }\n+  else if (TARGET_PORTABLE_RUNTIME)\n+    return length + 24;\n+  else\n+    {\n+      if (!TARGET_LONG_CALLS && distance < 240000)\n+\treturn length + 8;\n+\n+      if (TARGET_LONG_ABS_CALL && !flag_pic)\n+\treturn length + 12;\n+\n+      return length + 24;\n+    }\n+}\n+\n+/* INSN is a function call.  It may have an unconditional jump\n+   in its delay slot.\n \n-\t  /* Get the return address into %r31.  */\n-\t  output_asm_insn (\"blr 0,%3\", xoperands);\n+   CALL_DEST is the routine we are calling.  */\n \n-\t  /* Branch to our target which is in %r1.  */\n-\t  output_asm_insn (\"bv,n %%r0(%%r1)\", xoperands);\n+const char *\n+output_millicode_call (insn, call_dest)\n+     rtx insn;\n+     rtx call_dest;\n+{\n+  int attr_length = get_attr_length (insn);\n+  int seq_length = dbr_sequence_length ();\n+  int distance;\n+  rtx seq_insn;\n+  rtx xoperands[3];\n \n-\t  /* Empty delay slot.  Note this insn gets fetched twice and\n-\t     executed once.  To be safe we use a nop.  */\n-\t  output_asm_insn (\"nop\", xoperands);\n+  xoperands[0] = call_dest;\n+  xoperands[2] = gen_rtx_REG (Pmode, TARGET_64BIT ? 2 : 31);\n+\n+  /* Handle the common case where we are sure that the branch will\n+     reach the beginning of the $CODE$ subspace.  The within reach\n+     form of the $$sh_func_adrs call has a length of 28.  Because\n+     it has an attribute type of multi, it never has a non-zero\n+     sequence length.  The length of the $$sh_func_adrs is the same\n+     as certain out of reach PIC calls to other routines.  */\n+  if (!TARGET_LONG_CALLS\n+      && ((seq_length == 0\n+\t   && (attr_length == 12\n+\t       || (attr_length == 28 && get_attr_type (insn) == TYPE_MULTI)))\n+\t  || (seq_length != 0 && attr_length == 8)))\n+    {\n+      output_asm_insn (\"{bl|b,l} %0,%2\", xoperands);\n+    }\n+  else\n+    {\n+      if (TARGET_64BIT)\n+\t{\n+\t  /* It might seem that one insn could be saved by accessing\n+\t     the millicode function using the linkage table.  However,\n+\t     this doesn't work in shared libraries and other dynamically\n+\t     loaded objects.  Using a pc-relative sequence also avoids\n+\t     problems related to the implicit use of the gp register.  */\n+\t  output_asm_insn (\"b,l .+8,%%r1\", xoperands);\n+\t  output_asm_insn (\"addil L'%0-$PIC_pcrel$0+4,%%r1\", xoperands);\n+\t  output_asm_insn (\"ldo R'%0-$PIC_pcrel$0+8(%%r1),%%r1\", xoperands);\n+\t  output_asm_insn (\"bve,l (%%r1),%%r2\", xoperands);\n \t}\n-      /* Pure portable runtime doesn't allow be/ble; we also don't have\n-\t PIC support in the assembler/linker, so this sequence is needed.  */\n       else if (TARGET_PORTABLE_RUNTIME)\n \t{\n-\t  xoperands[0] = call_dest;\n-\t  /* Get the address of our target into %r29.  */\n-\t  output_asm_insn (\"ldil L%%%0,%%r29\", xoperands);\n-\t  output_asm_insn (\"ldo R%%%0(%%r29),%%r29\", xoperands);\n+\t  /* Pure portable runtime doesn't allow be/ble; we also don't\n+\t     have PIC support in the assembler/linker, so this sequence\n+\t     is needed.  */\n \n-\t  /* Get our return address into %r31.  */\n-\t  output_asm_insn (\"blr %%r0,%3\", xoperands);\n+\t  /* Get the address of our target into %r1.  */\n+\t  output_asm_insn (\"ldil L'%0,%%r1\", xoperands);\n+\t  output_asm_insn (\"ldo R'%0(%%r1),%%r1\", xoperands);\n \n-\t  /* Jump to our target address in %r29.  */\n-\t  output_asm_insn (\"bv,n %%r0(%%r29)\", xoperands);\n+\t  /* Get our return address into %r31.  */\n+\t  output_asm_insn (\"{bl|b,l} .+8,%%r31\", xoperands);\n+\t  output_asm_insn (\"addi 8,%%r31,%%r31\", xoperands);\n \n-\t  /* Empty delay slot.  Note this insn gets fetched twice and\n-\t     executed once.  To be safe we use a nop.  */\n-\t  output_asm_insn (\"nop\", xoperands);\n+\t  /* Jump to our target address in %r1.  */\n+\t  output_asm_insn (\"bv %%r0(%%r1)\", xoperands);\n \t}\n-      /* If we're allowed to use be/ble instructions, then this is the\n-\t best sequence to use for a long millicode call.  */\n-      else\n+      else if (!flag_pic)\n \t{\n-\t  xoperands[0] = call_dest;\n-\t  output_asm_insn (\"ldil L%%%0,%3\", xoperands);\n+\t  output_asm_insn (\"ldil L'%0,%%r1\", xoperands);\n \t  if (TARGET_PA_20)\n-\t    output_asm_insn (\"be,l R%%%0(%%sr4,%3),%%sr0,%%r31\", xoperands);\n+\t    output_asm_insn (\"be,l R'%0(%%sr4,%%r1),%%sr0,%%r31\", xoperands);\n \t  else\n-\t    output_asm_insn (\"ble R%%%0(%%sr4,%3)\", xoperands);\n-\t  output_asm_insn (\"nop\", xoperands);\n+\t    output_asm_insn (\"ble R'%0(%%sr4,%%r1)\", xoperands);\n \t}\n-\n-      /* If we had a jump in the call's delay slot, output it now.  */\n-      if (seq_length != 0 && !delay_insn_deleted)\n+      else\n \t{\n-\t  xoperands[0] = XEXP (PATTERN (NEXT_INSN (insn)), 1);\n-\t  output_asm_insn (\"b,n %0\", xoperands);\n+\t  if (TARGET_SOM || !TARGET_GAS)\n+\t    {\n+\t      /* The HP assembler can generate relocations for the\n+\t\t difference of two symbols.  GAS can do this for a\n+\t\t millicode symbol but not an arbitrary external\n+\t\t symbol when generating SOM output.  */\n+\t      xoperands[1] = gen_label_rtx ();\n+\t      output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n+\t      output_asm_insn (\"addi 16,%%r1,%%r31\", xoperands);\n+\t      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n+\t\t\t\t\t CODE_LABEL_NUMBER (xoperands[1]));\n+\t      output_asm_insn (\"addil L'%0-%l1,%%r1\", xoperands);\n+\t      output_asm_insn (\"ldo R'%0-%l1(%%r1),%%r1\", xoperands);\n+\t    }\n+\t  else\n+\t    {\n+\t      output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n+\t      output_asm_insn (\"addi 16,%%r1,%%r31\", xoperands);\n+\t      output_asm_insn (\"addil L'%0-$PIC_pcrel$0+8,%%r1\", xoperands);\n+\t      output_asm_insn (\"ldo R'%0-$PIC_pcrel$0+12(%%r1),%%r1\",\n+\t\t\t       xoperands);\n+\t    }\n \n-\t  /* Now delete the delay insn.  */\n-\t  PUT_CODE (NEXT_INSN (insn), NOTE);\n-\t  NOTE_LINE_NUMBER (NEXT_INSN (insn)) = NOTE_INSN_DELETED;\n-\t  NOTE_SOURCE_FILE (NEXT_INSN (insn)) = 0;\n+\t  /* Jump to our target address in %r1.  */\n+\t  output_asm_insn (\"bv %%r0(%%r1)\", xoperands);\n \t}\n-      return \"\";\n     }\n \n-  /* This call has an unconditional jump in its delay slot and the\n-     call is known to reach its target or the beginning of the current\n-     subspace.  */\n+  if (seq_length == 0)\n+    output_asm_insn (\"nop\", xoperands);\n \n-  /* Use the containing sequence insn's address.  */\n-  seq_insn = NEXT_INSN (PREV_INSN (XVECEXP (final_sequence, 0, 0)));\n-\n-  distance = INSN_ADDRESSES (INSN_UID (JUMP_LABEL (NEXT_INSN (insn))))\n-\t       - INSN_ADDRESSES (INSN_UID (seq_insn)) - 8;\n+  /* We are done if there isn't a jump in the delay slot.  */\n+  if (seq_length == 0 || GET_CODE (NEXT_INSN (insn)) != JUMP_INSN)\n+    return \"\";\n \n-  /* If the branch was too far away, emit a normal call followed\n-     by a nop, followed by the unconditional branch.\n+  /* This call has an unconditional jump in its delay slot.  */\n+  xoperands[0] = XEXP (PATTERN (NEXT_INSN (insn)), 1);\n \n-     If the branch is close, then adjust %r2 from within the\n-     call's delay slot.  */\n+  /* See if the return address can be adjusted.  Use the containing\n+     sequence insn's address.  */\n+  seq_insn = NEXT_INSN (PREV_INSN (XVECEXP (final_sequence, 0, 0)));\n+  distance = (INSN_ADDRESSES (INSN_UID (JUMP_LABEL (NEXT_INSN (insn))))\n+\t      - INSN_ADDRESSES (INSN_UID (seq_insn)) - 8);\n \n-  xoperands[0] = call_dest;\n-  xoperands[1] = XEXP (PATTERN (NEXT_INSN (insn)), 1);\n-  if (! VAL_14_BITS_P (distance))\n-    output_asm_insn (\"{bl|b,l} %0,%3\\n\\tnop\\n\\tb,n %1\", xoperands);\n-  else\n+  if (VAL_14_BITS_P (distance))\n     {\n-      xoperands[2] = gen_label_rtx ();\n-      output_asm_insn (\"\\n\\t{bl|b,l} %0,%3\\n\\tldo %1-%2(%3),%3\",\n-\t\t       xoperands);\n+      xoperands[1] = gen_label_rtx ();\n+      output_asm_insn (\"ldo %0-%1(%2),%2\", xoperands);\n       ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n-\t\t\t\t CODE_LABEL_NUMBER (xoperands[2]));\n+\t\t\t\t CODE_LABEL_NUMBER (xoperands[3]));\n     }\n+  else\n+    /* ??? This branch may not reach its target.  */\n+    output_asm_insn (\"nop\\n\\tb,n %0\", xoperands);\n \n   /* Delete the jump.  */\n   PUT_CODE (NEXT_INSN (insn), NOTE);\n   NOTE_LINE_NUMBER (NEXT_INSN (insn)) = NOTE_INSN_DELETED;\n   NOTE_SOURCE_FILE (NEXT_INSN (insn)) = 0;\n+\n   return \"\";\n }\n \n-/* INSN is either a function call.  It may have an unconditional jump\n+/* We include the delay slot in the returned length as it is better to\n+   over estimate the length than to under estimate it.  */\n+\n+int\n+attr_length_call (insn, sibcall)\n+     rtx insn;\n+     int sibcall;\n+{\n+  unsigned long distance = total_code_bytes + INSN_ADDRESSES (INSN_UID (insn));\n+\n+  if (distance < total_code_bytes)\n+    distance = -1;\n+\n+  if (TARGET_64BIT)\n+    {\n+      if (!TARGET_LONG_CALLS\n+\t  && ((!sibcall && distance < 7600000) || distance < 240000))\n+\treturn 8;\n+\n+      return (sibcall ? 28 : 24);\n+    }\n+  else\n+    {\n+      if (!TARGET_LONG_CALLS\n+\t  && ((TARGET_PA_20 && !sibcall && distance < 7600000)\n+\t      || distance < 240000))\n+\treturn 8;\n+\n+      if (TARGET_LONG_ABS_CALL && !flag_pic)\n+\treturn 12;\n+\n+      if ((TARGET_SOM && TARGET_LONG_PIC_SDIFF_CALL)\n+\t  || (TARGET_GAS && TARGET_LONG_PIC_PCREL_CALL))\n+\t{\n+\t  if (TARGET_PA_20)\n+\t    return 20;\n+\n+\t  return 28;\n+\t}\n+      else\n+\t{\n+\t  int length = 0;\n+\n+\t  if (TARGET_SOM)\n+\t    length += length_fp_args (insn);\n+\n+\t  if (flag_pic)\n+\t    length += 4;\n+\n+\t  if (TARGET_PA_20)\n+\t    return (length + 32);\n+\n+\t  if (!sibcall)\n+\t    length += 8;\n+\n+\t  return (length + 40);\n+\t}\n+    }\n+}\n+\n+/* INSN is a function call.  It may have an unconditional jump\n    in its delay slot.\n \n    CALL_DEST is the routine we are calling.  */\n \n const char *\n output_call (insn, call_dest, sibcall)\n-  rtx insn;\n-  rtx call_dest;\n-  int sibcall;\n+     rtx insn;\n+     rtx call_dest;\n+     int sibcall;\n {\n+  int delay_insn_deleted = 0;\n+  int delay_slot_filled = 0;\n   int attr_length = get_attr_length (insn);\n   int seq_length = dbr_sequence_length ();\n-  int distance;\n-  rtx xoperands[4];\n-  rtx seq_insn;\n+  rtx xoperands[2];\n+\n+  xoperands[0] = call_dest;\n \n-  /* Handle common case -- empty delay slot or no jump in the delay slot,\n-     and we're sure that the branch will reach the beginning of the $CODE$\n-     subspace.  */\n-  if ((seq_length == 0 && attr_length == 12)\n-      || (seq_length != 0\n-\t  && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN\n-\t  && attr_length == 8))\n+  /* Handle the common case where we're sure that the branch will reach\n+     the beginning of the $CODE$ subspace.  */\n+  if (!TARGET_LONG_CALLS\n+      && ((seq_length == 0 && attr_length == 12)\n+\t  || (seq_length != 0 && attr_length == 8)))\n     {\n-      xoperands[0] = call_dest;\n       xoperands[1] = gen_rtx_REG (word_mode, sibcall ? 0 : 2);\n-      output_asm_insn (\"{bl|b,l} %0,%1%#\", xoperands);\n-      return \"\";\n+      output_asm_insn (\"{bl|b,l} %0,%1\", xoperands);\n     }\n-\n-  /* This call may not reach the beginning of the $CODE$ subspace.  */\n-  if (attr_length > 12)\n+  else\n     {\n-      int delay_insn_deleted = 0;\n-      rtx xoperands[2];\n-      rtx link;\n-\n-      /* We need to emit an inline long-call branch.  Furthermore,\n-\t because we're changing a named function call into an indirect\n-\t function call well after the parameters have been set up, we\n-\t need to make sure any FP args appear in both the integer\n-\t and FP registers.  Also, we need move any delay slot insn\n-\t out of the delay slot.  And finally, we can't rely on the linker\n-\t being able to fix the call to $$dyncall!  -- Yuk!.  */\n-      if (seq_length != 0\n-\t  && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN)\n+      if (TARGET_64BIT)\n \t{\n-\t  /* A non-jump insn in the delay slot.  By definition we can\n-\t     emit this insn before the call (and in fact before argument\n-\t     relocating.  */\n-\t  final_scan_insn (NEXT_INSN (insn), asm_out_file, optimize, 0, 0);\n-\n-\t  /* Now delete the delay insn.  */\n-\t  PUT_CODE (NEXT_INSN (insn), NOTE);\n-\t  NOTE_LINE_NUMBER (NEXT_INSN (insn)) = NOTE_INSN_DELETED;\n-\t  NOTE_SOURCE_FILE (NEXT_INSN (insn)) = 0;\n-\t  delay_insn_deleted = 1;\n-\t}\n+\t  /* ??? As far as I can tell, the HP linker doesn't support the\n+\t     long pc-relative sequence described in the 64-bit runtime\n+\t     architecture.  So, we use a slightly longer indirect call.  */\n+\t  struct deferred_plabel *p = get_plabel (XSTR (call_dest, 0));\n+\n+\t  xoperands[0] = p->internal_label;\n+\t  xoperands[1] = gen_label_rtx ();\n+\n+\t  /* If this isn't a sibcall, we put the load of %r27 into the\n+\t     delay slot.  We can't do this in a sibcall as we don't\n+\t     have a second call-clobbered scratch register available.  */\n+\t  if (seq_length != 0\n+\t      && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN\n+\t      && !sibcall)\n+\t    {\n+\t      final_scan_insn (NEXT_INSN (insn), asm_out_file,\n+\t\t\t       optimize, 0, 0);\n+\n+\t      /* Now delete the delay insn.  */\n+\t      PUT_CODE (NEXT_INSN (insn), NOTE);\n+\t      NOTE_LINE_NUMBER (NEXT_INSN (insn)) = NOTE_INSN_DELETED;\n+\t      NOTE_SOURCE_FILE (NEXT_INSN (insn)) = 0;\n+\t      delay_insn_deleted = 1;\n+\t    }\n \n-      /* Now copy any FP arguments into integer registers.  */\n-      for (link = CALL_INSN_FUNCTION_USAGE (insn); link; link = XEXP (link, 1))\n-\t{\n-\t  int arg_mode, regno;\n-\t  rtx use = XEXP (link, 0);\n-\t  if (! (GET_CODE (use) == USE\n-\t\t && GET_CODE (XEXP (use, 0)) == REG\n-\t\t && FUNCTION_ARG_REGNO_P (REGNO (XEXP (use, 0)))))\n-\t    continue;\n+\t  output_asm_insn (\"addil LT'%0,%%r27\", xoperands);\n+\t  output_asm_insn (\"ldd RT'%0(%%r1),%%r1\", xoperands);\n+\t  output_asm_insn (\"ldd 0(%%r1),%%r1\", xoperands);\n \n-\t  arg_mode = GET_MODE (XEXP (use, 0));\n-\t  regno = REGNO (XEXP (use, 0));\n-\t  /* Is it a floating point register?  */\n-\t  if (regno >= 32 && regno <= 39)\n+\t  if (sibcall)\n \t    {\n-\t      /* Copy from the FP register into an integer register\n-\t\t (via memory).  */\n-\t      if (arg_mode == SFmode)\n-\t\t{\n-\t\t  xoperands[0] = XEXP (use, 0);\n-\t\t  xoperands[1] = gen_rtx_REG (SImode, 26 - (regno - 32) / 2);\n-\t\t  output_asm_insn (\"{fstws|fstw} %0,-16(%%sr0,%%r30)\",\n-\t\t\t\t    xoperands);\n-\t\t  output_asm_insn (\"ldw -16(%%sr0,%%r30),%1\", xoperands);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  xoperands[0] = XEXP (use, 0);\n-\t\t  xoperands[1] = gen_rtx_REG (DImode, 25 - (regno - 34) / 2);\n-\t\t  output_asm_insn (\"{fstds|fstd} %0,-16(%%sr0,%%r30)\",\n-\t\t\t\t    xoperands);\n-\t\t  output_asm_insn (\"ldw -12(%%sr0,%%r30),%R1\", xoperands);\n-\t\t  output_asm_insn (\"ldw -16(%%sr0,%%r30),%1\", xoperands);\n-\t\t}\n+\t      output_asm_insn (\"ldd 24(%%r1),%%r27\", xoperands);\n+\t      output_asm_insn (\"ldd 16(%%r1),%%r1\", xoperands);\n+\t      output_asm_insn (\"bve (%%r1)\", xoperands);\n+\t    }\n+\t  else\n+\t    {\n+\t      output_asm_insn (\"ldd 16(%%r1),%%r2\", xoperands);\n+\t      output_asm_insn (\"bve,l (%%r2),%%r2\", xoperands);\n+\t      output_asm_insn (\"ldd 24(%%r1),%%r27\", xoperands);\n+\t      delay_slot_filled = 1;\n \t    }\n \t}\n-\n-      /* Don't have to worry about TARGET_PORTABLE_RUNTIME here since\n-\t we don't have any direct calls in that case.  */\n+      else\n \t{\n-\t  size_t i;\n-\t  const char *name = XSTR (call_dest, 0);\n-\n-\t  /* See if we have already put this function on the list\n-\t     of deferred plabels.  This list is generally small,\n-\t     so a liner search is not too ugly.  If it proves too\n-\t     slow replace it with something faster.  */\n-\t  for (i = 0; i < n_deferred_plabels; i++)\n-\t    if (strcmp (name, deferred_plabels[i].name) == 0)\n-\t      break;\n-\n-\t  /* If the deferred plabel list is empty, or this entry was\n-\t     not found on the list, create a new entry on the list.  */\n-\t  if (deferred_plabels == NULL || i == n_deferred_plabels)\n+\t  int indirect_call = 0;\n+\n+\t  /* Emit a long call.  There are several different sequences\n+\t     of increasing length and complexity.  In most cases,\n+             they don't allow an instruction in the delay slot.  */\n+\t  if (!(TARGET_LONG_ABS_CALL && !flag_pic)\n+\t      && !(TARGET_SOM && TARGET_LONG_PIC_SDIFF_CALL)\n+\t      && !(TARGET_GAS && TARGET_LONG_PIC_PCREL_CALL))\n+\t    indirect_call = 1;\n+\n+\t  if (seq_length != 0\n+\t      && GET_CODE (NEXT_INSN (insn)) != JUMP_INSN\n+\t      && !sibcall\n+\t      && (!TARGET_PA_20 || indirect_call))\n \t    {\n-\t      const char *real_name;\n-\n-\t      if (deferred_plabels == 0)\n-\t\tdeferred_plabels = (struct deferred_plabel *)\n-\t\t  ggc_alloc (sizeof (struct deferred_plabel));\n-\t      else\n-\t\tdeferred_plabels = (struct deferred_plabel *)\n-\t\t  ggc_realloc (deferred_plabels,\n-\t\t\t    ((n_deferred_plabels + 1)\n-\t\t\t     * sizeof (struct deferred_plabel)));\n-\n-\t      i = n_deferred_plabels++;\n-\t      deferred_plabels[i].internal_label = gen_label_rtx ();\n-\t      deferred_plabels[i].name = ggc_strdup (name);\n-\n-\t      /* Gross.  We have just implicitly taken the address of this\n-\t\t function, mark it as such.  */\n-\t      real_name = (*targetm.strip_name_encoding) (name);\n-\t      TREE_SYMBOL_REFERENCED (get_identifier (real_name)) = 1;\n+\t      /* A non-jump insn in the delay slot.  By definition we can\n+\t\t emit this insn before the call (and in fact before argument\n+\t\t relocating.  */\n+\t      final_scan_insn (NEXT_INSN (insn), asm_out_file, optimize, 0, 0);\n+\n+\t      /* Now delete the delay insn.  */\n+\t      PUT_CODE (NEXT_INSN (insn), NOTE);\n+\t      NOTE_LINE_NUMBER (NEXT_INSN (insn)) = NOTE_INSN_DELETED;\n+\t      NOTE_SOURCE_FILE (NEXT_INSN (insn)) = 0;\n+\t      delay_insn_deleted = 1;\n \t    }\n \n-\t  /* We have to load the address of the function using a procedure\n-\t     label (plabel).  Inline plabels can lose for PIC and other\n-\t     cases, so avoid them by creating a 32bit plabel in the data\n-\t     segment.  */\n-\t  if (flag_pic)\n+\t  if (TARGET_LONG_ABS_CALL && !flag_pic)\n \t    {\n-\t      xoperands[0] = deferred_plabels[i].internal_label;\n-\t      if (TARGET_SOM || ! TARGET_GAS)\n-\t\txoperands[1] = gen_label_rtx ();\n-\n-\t      output_asm_insn (\"addil LT%%%0,%%r19\", xoperands);\n-\t      output_asm_insn (\"ldw RT%%%0(%%r1),%%r22\", xoperands);\n-\t      output_asm_insn (\"ldw 0(%%r22),%%r22\", xoperands);\n-\n-\t      /* Get our address + 8 into %r1.  */\n-\t      output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n+\t      /* This is the best sequence for making long calls in\n+\t\t non-pic code.  Unfortunately, GNU ld doesn't provide\n+\t\t the stub needed for external calls, and GAS's support\n+\t\t for this with the SOM linker is buggy.  */\n+\t      output_asm_insn (\"ldil L'%0,%%r1\", xoperands);\n+\t      if (sibcall)\n+\t\toutput_asm_insn (\"be R'%0(%%sr4,%%r1)\", xoperands);\n+\t      else\n+\t\t{\n+\t\t  if (TARGET_PA_20)\n+\t\t    output_asm_insn (\"be,l R'%0(%%sr4,%%r1),%%sr0,%%r31\",\n+\t\t\t\t     xoperands);\n+\t\t  else\n+\t\t    output_asm_insn (\"ble R'%0(%%sr4,%%r1)\", xoperands);\n \n-\t      if (TARGET_SOM || ! TARGET_GAS)\n+\t\t  output_asm_insn (\"copy %%r31,%%r2\", xoperands);\n+\t\t  delay_slot_filled = 1;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if (TARGET_SOM && TARGET_LONG_PIC_SDIFF_CALL)\n \t\t{\n-\t\t  /* Add %r1 to the offset of dyncall from the next insn.  */\n-\t\t  output_asm_insn (\"addil L%%$$dyncall-%1,%%r1\", xoperands);\n+\t\t  /* The HP assembler and linker can handle relocations\n+\t\t     for the difference of two symbols.  GAS and the HP\n+\t\t     linker can't do this when one of the symbols is\n+\t\t     external.  */\n+\t\t  xoperands[1] = gen_label_rtx ();\n+\t\t  output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n+\t\t  output_asm_insn (\"addil L'%0-%l1,%%r1\", xoperands);\n \t\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n \t\t\t\t\t     CODE_LABEL_NUMBER (xoperands[1]));\n-\t\t  output_asm_insn (\"ldo R%%$$dyncall-%1(%%r1),%%r1\", xoperands);\n-\t        }\n-\t      else\n+\t\t  output_asm_insn (\"ldo R'%0-%l1(%%r1),%%r1\", xoperands);\n+\t\t}\n+\t      else if (TARGET_GAS && TARGET_LONG_PIC_PCREL_CALL)\n \t\t{\n-\t\t  output_asm_insn (\"addil L%%$$dyncall-$PIC_pcrel$0+4,%%r1\",\n+\t\t  /*  GAS currently can't generate the relocations that\n+\t\t      are needed for the SOM linker under HP-UX using this\n+\t\t      sequence.  The GNU linker doesn't generate the stubs\n+\t\t      that are needed for external calls on TARGET_ELF32\n+\t\t      with this sequence.  For now, we have to use a\n+\t\t      longer plabel sequence when using GAS.  */\n+\t\t  output_asm_insn (\"{bl|b,l} .+8,%%r1\", xoperands);\n+\t\t  output_asm_insn (\"addil L'%0-$PIC_pcrel$0+4,%%r1\",\n \t\t\t\t   xoperands);\n-\t\t  output_asm_insn (\"ldo R%%$$dyncall-$PIC_pcrel$0+8(%%r1),%%r1\",\n+\t\t  output_asm_insn (\"ldo R'%0-$PIC_pcrel$0+8(%%r1),%%r1\",\n \t\t\t\t   xoperands);\n \t\t}\n-\n-\t      /* Get the return address into %r31.  */\n-\t      output_asm_insn (\"blr %%r0,%%r31\", xoperands);\n-\n-\t      /* Branch to our target which is in %r1.  */\n-\t      output_asm_insn (\"bv %%r0(%%r1)\", xoperands);\n-\n-\t      if (sibcall)\n-\t\t{\n-\t\t  /* This call never returns, so we do not need to fix the\n-\t\t     return pointer.  */\n-\t\t  output_asm_insn (\"nop\", xoperands);\n-\t\t}\n \t      else\n \t\t{\n-\t\t  /* Copy the return address into %r2 also.  */\n-\t\t  output_asm_insn (\"copy %%r31,%%r2\", xoperands);\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      xoperands[0] = deferred_plabels[i].internal_label;\n+\t\t  /* Emit a long plabel-based call sequence.  This is\n+\t\t     essentially an inline implementation of $$dyncall.\n+\t\t     We don't actually try to call $$dyncall as this is\n+\t\t     as difficult as calling the function itself.  */\n+\t\t  struct deferred_plabel *p = get_plabel (XSTR (call_dest, 0));\n+\n+\t\t  xoperands[0] = p->internal_label;\n+\t\t  xoperands[1] = gen_label_rtx ();\n+\n+\t\t  /* Since the call is indirect, FP arguments in registers\n+\t\t     need to be copied to the general registers.  Then, the\n+\t\t     argument relocation stub will copy them back.  */\n+\t\t  if (TARGET_SOM)\n+\t\t    copy_fp_args (insn);\n+\n+\t\t  if (flag_pic)\n+\t\t    {\n+\t\t      output_asm_insn (\"addil LT'%0,%%r19\", xoperands);\n+\t\t      output_asm_insn (\"ldw RT'%0(%%r1),%%r1\", xoperands);\n+\t\t      output_asm_insn (\"ldw 0(%%r1),%%r1\", xoperands);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      output_asm_insn (\"addil LR'%0-$global$,%%r27\",\n+\t\t\t\t       xoperands);\n+\t\t      output_asm_insn (\"ldw RR'%0-$global$(%%r1),%%r1\",\n+\t\t\t\t       xoperands);\n+\t\t    }\n \n-\t      /* Get the address of our target into %r22.  */\n-\t      output_asm_insn (\"addil LR%%%0-$global$,%%r27\", xoperands);\n-\t      output_asm_insn (\"ldw RR%%%0-$global$(%%r1),%%r22\", xoperands);\n+\t\t  output_asm_insn (\"bb,>=,n %%r1,30,.+16\", xoperands);\n+\t\t  output_asm_insn (\"depi 0,31,2,%%r1\", xoperands);\n+\t\t  output_asm_insn (\"ldw 4(%%sr0,%%r1),%%r19\", xoperands);\n+\t\t  output_asm_insn (\"ldw 0(%%sr0,%%r1),%%r1\", xoperands);\n \n-\t      /* Get the high part of the  address of $dyncall into %r2, then\n-\t\t add in the low part in the branch instruction.  */\n-\t      output_asm_insn (\"ldil L%%$$dyncall,%%r2\", xoperands);\n-\t      if (TARGET_PA_20)\n-\t\toutput_asm_insn (\"be,l R%%$$dyncall(%%sr4,%%r2),%%sr0,%%r31\",\n-\t\t\t\t xoperands);\n-\t      else\n-\t\toutput_asm_insn (\"ble R%%$$dyncall(%%sr4,%%r2)\", xoperands);\n+\t\t  if (!sibcall && !TARGET_PA_20)\n+\t\t    {\n+\t\t      output_asm_insn (\"{bl|b,l} .+8,%%r2\", xoperands);\n+\t\t      output_asm_insn (\"addi 16,%%r2,%%r2\", xoperands);\n+\t\t    }\n+\t\t}\n \n-\t      if (sibcall)\n+\t      if (TARGET_PA_20)\n \t\t{\n-\t\t  /* This call never returns, so we do not need to fix the\n-\t\t     return pointer.  */\n-\t\t  output_asm_insn (\"nop\", xoperands);\n+\t\t  if (sibcall)\n+\t\t    output_asm_insn (\"bve (%%r1)\", xoperands);\n+\t\t  else\n+\t\t    {\n+\t\t      if (indirect_call)\n+\t\t\t{\n+\t\t\t  output_asm_insn (\"bve,l (%%r1),%%r2\", xoperands);\n+\t\t\t  output_asm_insn (\"stw %%r2,-24(%%sp)\", xoperands);\n+\t\t\t  delay_slot_filled = 1;\n+\t\t\t}\n+\t\t      else\n+\t\t\toutput_asm_insn (\"bve,l (%%r1),%%r2\", xoperands);\n+\t\t    }\n \t\t}\n \t      else\n \t\t{\n-\t\t  /* Copy the return address into %r2 also.  */\n-\t\t  output_asm_insn (\"copy %%r31,%%r2\", xoperands);\n-\t\t}\n-\t    }\n-\t}\n+\t          output_asm_insn (\"ldsid (%%r1),%%r31\\n\\tmtsp %%r31,%%sr0\",\n+\t\t\t\t   xoperands);\n \n-      /* If we had a jump in the call's delay slot, output it now.  */\n-      if (seq_length != 0 && !delay_insn_deleted)\n-\t{\n-\t  xoperands[0] = XEXP (PATTERN (NEXT_INSN (insn)), 1);\n-\t  output_asm_insn (\"b,n %0\", xoperands);\n+\t\t  if (sibcall)\n+\t\t    output_asm_insn (\"be 0(%%sr0,%%r1)\", xoperands);\n+\t\t  else\n+\t\t    {\n+\t\t      output_asm_insn (\"ble 0(%%sr0,%%r1)\", xoperands);\n \n-\t  /* Now delete the delay insn.  */\n-\t  PUT_CODE (NEXT_INSN (insn), NOTE);\n-\t  NOTE_LINE_NUMBER (NEXT_INSN (insn)) = NOTE_INSN_DELETED;\n-\t  NOTE_SOURCE_FILE (NEXT_INSN (insn)) = 0;\n+\t\t      if (indirect_call)\n+\t\t\toutput_asm_insn (\"stw %%r31,-24(%%sp)\", xoperands);\n+\t\t      else\n+\t\t\toutput_asm_insn (\"copy %%r31,%%r2\", xoperands);\n+\t\t      delay_slot_filled = 1;\n+\t\t    }\n+\t\t}\n+\t    }\n \t}\n-      return \"\";\n     }\n \n-  /* This call has an unconditional jump in its delay slot and the\n-     call is known to reach its target or the beginning of the current\n-     subspace.  */\n+  if (seq_length == 0 || (delay_insn_deleted && !delay_slot_filled))\n+    output_asm_insn (\"nop\", xoperands);\n \n-  /* Use the containing sequence insn's address.  */\n-  seq_insn = NEXT_INSN (PREV_INSN (XVECEXP (final_sequence, 0, 0)));\n+  /* We are done if there isn't a jump in the delay slot.  */\n+  if (seq_length == 0\n+      || delay_insn_deleted\n+      || GET_CODE (NEXT_INSN (insn)) != JUMP_INSN)\n+    return \"\";\n \n-  distance = INSN_ADDRESSES (INSN_UID (JUMP_LABEL (NEXT_INSN (insn))))\n-\t       - INSN_ADDRESSES (INSN_UID (seq_insn)) - 8;\n+  /* A sibcall should never have a branch in the delay slot.  */\n+  if (sibcall)\n+    abort ();\n \n-  /* If the branch is too far away, emit a normal call followed\n-     by a nop, followed by the unconditional branch.  If the branch\n-     is close, then adjust %r2 in the call's delay slot.  */\n+  /* This call has an unconditional jump in its delay slot.  */\n+  xoperands[0] = XEXP (PATTERN (NEXT_INSN (insn)), 1);\n \n-  xoperands[0] = call_dest;\n-  xoperands[1] = XEXP (PATTERN (NEXT_INSN (insn)), 1);\n-  if (! VAL_14_BITS_P (distance))\n-    output_asm_insn (\"{bl|b,l} %0,%%r2\\n\\tnop\\n\\tb,n %1\", xoperands);\n-  else\n+  if (!delay_slot_filled)\n     {\n-      xoperands[3] = gen_label_rtx ();\n-      output_asm_insn (\"\\n\\t{bl|b,l} %0,%%r2\\n\\tldo %1-%3(%%r2),%%r2\",\n-\t\t       xoperands);\n-      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n-\t\t\t\t CODE_LABEL_NUMBER (xoperands[3]));\n+      /* See if the return address can be adjusted.  Use the containing\n+         sequence insn's address.  */\n+      rtx seq_insn = NEXT_INSN (PREV_INSN (XVECEXP (final_sequence, 0, 0)));\n+      int distance = (INSN_ADDRESSES (INSN_UID (JUMP_LABEL (NEXT_INSN (insn))))\n+\t\t      - INSN_ADDRESSES (INSN_UID (seq_insn)) - 8);\n+\n+      if (VAL_14_BITS_P (distance))\n+\t{\n+\t  xoperands[1] = gen_label_rtx ();\n+\t  output_asm_insn (\"ldo %0-%1(%%r2),%%r2\", xoperands);\n+\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"L\",\n+\t\t\t\t     CODE_LABEL_NUMBER (xoperands[3]));\n+\t}\n+      else\n+\t/* ??? This branch may not reach its target.  */\n+\toutput_asm_insn (\"nop\\n\\tb,n %0\", xoperands);\n     }\n+  else\n+    /* ??? This branch may not reach its target.  */\n+    output_asm_insn (\"b,n %0\", xoperands);\n \n   /* Delete the jump.  */\n   PUT_CODE (NEXT_INSN (insn), NOTE);\n   NOTE_LINE_NUMBER (NEXT_INSN (insn)) = NOTE_INSN_DELETED;\n   NOTE_SOURCE_FILE (NEXT_INSN (insn)) = 0;\n+\n   return \"\";\n }\n \n@@ -6580,8 +6772,8 @@ pa_asm_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n     {\n       if (! TARGET_64BIT && ! TARGET_PORTABLE_RUNTIME && flag_pic)\n \t{\n-\t  fprintf (file, \"\\taddil LT%%%s,%%r19\\n\", lab);\n-\t  fprintf (file, \"\\tldw RT%%%s(%%r1),%%r22\\n\", lab);\n+\t  fprintf (file, \"\\taddil LT'%s,%%r19\\n\", lab);\n+\t  fprintf (file, \"\\tldw RT'%s(%%r1),%%r22\\n\", lab);\n \t  fprintf (file, \"\\tldw 0(%%sr0,%%r22),%%r22\\n\");\n \t  fprintf (file, \"\\tbb,>=,n %%r22,30,.+16\\n\");\n \t  fprintf (file, \"\\tdepi 0,31,2,%%r22\\n\");\n@@ -6603,13 +6795,13 @@ pa_asm_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n     {\n       if (! TARGET_64BIT && ! TARGET_PORTABLE_RUNTIME && flag_pic)\n \t{\n-\t  fprintf (file, \"\\taddil L%%\");\n+\t  fprintf (file, \"\\taddil L'\");\n \t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, delta);\n-\t  fprintf (file, \",%%r26\\n\\tldo R%%\");\n+\t  fprintf (file, \",%%r26\\n\\tldo R'\");\n \t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, delta);\n \t  fprintf (file, \"(%%r1),%%r26\\n\");\n-\t  fprintf (file, \"\\taddil LT%%%s,%%r19\\n\", lab);\n-\t  fprintf (file, \"\\tldw RT%%%s(%%r1),%%r22\\n\", lab);\n+\t  fprintf (file, \"\\taddil LT'%s,%%r19\\n\", lab);\n+\t  fprintf (file, \"\\tldw RT'%s(%%r1),%%r22\\n\", lab);\n \t  fprintf (file, \"\\tldw 0(%%sr0,%%r22),%%r22\\n\");\n \t  fprintf (file, \"\\tbb,>=,n %%r22,30,.+16\\n\");\n \t  fprintf (file, \"\\tdepi 0,31,2,%%r22\\n\");\n@@ -6620,9 +6812,9 @@ pa_asm_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n \t}\n       else\n \t{\n-\t  fprintf (file, \"\\taddil L%%\");\n+\t  fprintf (file, \"\\taddil L'\");\n \t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, delta);\n-\t  fprintf (file, \",%%r26\\n\\tb %s\\n\\tldo R%%\", target_name);\n+\t  fprintf (file, \",%%r26\\n\\tb %s\\n\\tldo R'\", target_name);\n \t  fprintf (file, HOST_WIDE_INT_PRINT_DEC, delta);\n \t  fprintf (file, \"(%%r1),%%r26\\n\");\n \t}\n@@ -6634,7 +6826,7 @@ pa_asm_output_mi_thunk (file, thunk_fndecl, delta, vcall_offset, function)\n       data_section ();\n       fprintf (file, \"\\t.align 4\\n\");\n       ASM_OUTPUT_INTERNAL_LABEL (file, \"LTHN\", current_thunk_number);\n-      fprintf (file, \"\\t.word P%%%s\\n\", target_name);\n+      fprintf (file, \"\\t.word P'%s\\n\", target_name);\n       function_section (thunk_fndecl);\n     }\n   current_thunk_number++;"}, {"sha": "a3f24b6d6e341d7ae6b9cc83618f83aafaf62d73", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37", "patch": "@@ -31,7 +31,7 @@ enum cmp_type\t\t\t\t/* comparison type */\n };\n \n /* For long call handling.  */\n-extern unsigned int total_code_bytes;\n+extern unsigned long total_code_bytes;\n \n /* Which processor to schedule for.  */\n \n@@ -152,6 +152,12 @@ extern int target_flags;\n #define TARGET_GNU_LD (target_flags & MASK_GNU_LD)\n #endif\n \n+/* Force generation of long calls.  */\n+#define MASK_LONG_CALLS 32768\n+#ifndef TARGET_LONG_CALLS\n+#define TARGET_LONG_CALLS (target_flags & MASK_LONG_CALLS)\n+#endif\n+\n #ifndef TARGET_PA_10\n #define TARGET_PA_10 (target_flags & (MASK_PA_11 | MASK_PA_20) == 0)\n #endif\n@@ -179,6 +185,27 @@ extern int target_flags;\n #define TARGET_SOM 0\n #endif\n \n+/* The following three defines are potential target switches.  The current\n+   defines are optimal given the current capabilities of GAS and GNU ld.  */\n+\n+/* Define to a C expression evaluating to true to use long absolute calls.\n+   Currently, only the HP assembler and SOM linker support long absolute\n+   calls.  They are used only in non-pic code.  */\n+#define TARGET_LONG_ABS_CALL (TARGET_SOM && !TARGET_GAS)\n+\n+/* Define to a C expression evaluating to true to use long pic symbol\n+   difference calls.  This is a call variant similar to the long pic\n+   pc-relative call.  Long pic symbol difference calls are only used with\n+   the HP SOM linker.  Currently, only the HP assembler supports these\n+   calls.  GAS doesn't allow an arbritrary difference of two symbols.  */\n+#define TARGET_LONG_PIC_SDIFF_CALL (!TARGET_GAS)\n+\n+/* Define to a C expression evaluating to true to use long pic\n+   pc-relative calls.  Long pic pc-relative calls are only used with\n+   GAS.  Currently, they are usable for calls within a module but\n+   not for external calls.  */\n+#define TARGET_LONG_PIC_PCREL_CALL 0\n+\n /* Macro to define tables used to set the flags.  This is a\n    list in braces of target switches with each switch being\n    { \"NAME\", VALUE, \"HELP_STRING\" }.  VALUE is the bits to set,\n@@ -237,6 +264,10 @@ extern int target_flags;\n      N_(\"Generate code for huge switch statements\") },\t\t\t\\\n    { \"no-big-switch\",\t\t-MASK_BIG_SWITCH,\t\t\t\\\n      N_(\"Do not generate code for huge switch statements\") },\t\t\\\n+   { \"long-calls\",\t\t MASK_LONG_CALLS,\t\t\t\\\n+     N_(\"Always generate long calls\") },\t\t\t\t\\\n+   { \"no-long-calls\",\t\t-MASK_LONG_CALLS,\t\t\t\\\n+     N_(\"Generate long calls only when needed\") },\t\t\t\\\n    { \"linker-opt\",\t\t 0,\t\t\t\t\t\\\n      N_(\"Enable linker optimizations\") },\t\t\t\t\\\n    SUBTARGET_SWITCHES\t\t\t\t\t\t\t\\\n@@ -1193,8 +1224,14 @@ extern int may_call_alloca;\n        /* Using DFmode forces only short displacements\t\\\n \t  to be recognized as valid in reg+d addresses. \\\n \t  However, this is not necessary for PA2.0 since\\\n-\t  it has long FP loads/stores.  */\t\t\\\n+\t  it has long FP loads/stores.\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+\t  FIXME: the ELF32 linker clobbers the LSB of\t\\\n+\t  the FP register number in {fldw,fstw} insns.\t\\\n+\t  Thus, we only allow long FP loads/stores on\t\\\n+\t  TARGET_64BIT.  */\t\t\t\t\\\n        && memory_address_p ((TARGET_PA_20\t\t\\\n+\t\t\t     && !TARGET_ELF32\t\t\\\n \t\t\t     ? GET_MODE (OP)\t\t\\\n \t\t\t     : DFmode),\t\t\t\\\n \t\t\t    XEXP (OP, 0))\t\t\\\n@@ -1300,7 +1337,7 @@ extern int may_call_alloca;\n \tif (GET_CODE (index) == CONST_INT\t\t\\\n \t    && ((INT_14_BITS (index)\t\t\t\\\n \t\t && (TARGET_SOFT_FLOAT\t\t\t\\\n-\t\t     || (TARGET_PA_20\t\t\\\n+\t\t     || (TARGET_PA_20\t\t\t\\\n \t\t\t && ((MODE == SFmode\t\t\\\n \t\t\t      && (INTVAL (index) % 4) == 0)\\\n \t\t\t     || (MODE == DFmode\t\t\\\n@@ -1327,6 +1364,7 @@ extern int may_call_alloca;\n \t       /* We can allow symbolic LO_SUM addresses\\\n \t\t  for PA2.0.  */\t\t\t\\\n \t       || (TARGET_PA_20\t\t\t\t\\\n+\t\t   && !TARGET_ELF32\t\t\t\\\n \t           && GET_CODE (XEXP (X, 1)) != CONST_INT)\\\n \t       || ((MODE) != SFmode\t\t\t\\\n \t\t   && (MODE) != DFmode)))\t\t\\\n@@ -1340,6 +1378,7 @@ extern int may_call_alloca;\n \t       /* We can allow symbolic LO_SUM addresses\\\n \t\t  for PA2.0.  */\t\t\t\\\n \t       || (TARGET_PA_20\t\t\t\t\\\n+\t\t   && !TARGET_ELF32\t\t\t\\\n \t           && GET_CODE (XEXP (X, 1)) != CONST_INT)\\\n \t       || ((MODE) != SFmode\t\t\t\\\n \t\t   && (MODE) != DFmode)))\t\t\\\n@@ -1354,7 +1393,7 @@ extern int may_call_alloca;\n \t   && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\\\n \t   && GET_CODE (XEXP (X, 1)) == UNSPEC\t\t\\\n \t   && (TARGET_SOFT_FLOAT\t\t\t\\\n-\t       || TARGET_PA_20\t\t\t\t\\\n+\t       || (TARGET_PA_20\t&& !TARGET_ELF32)\t\\\n \t       || ((MODE) != SFmode\t\t\t\\\n \t\t   && (MODE) != DFmode)))\t\t\\\n     goto ADDR;\t\t\t\t\t\t\\\n@@ -1386,7 +1425,7 @@ do { \t\t\t\t\t\t\t\t\t\\\n   rtx new, temp = NULL_RTX;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n   mask = (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n-\t  ? (TARGET_PA_20 ? 0x3fff : 0x1f) : 0x3fff);\t\t\t\\\n+\t  ? (TARGET_PA_20 && !TARGET_ELF32 ? 0x3fff : 0x1f) : 0x3fff);\t\\\n \t\t\t\t\t\t\t\t\t\\\n   if (optimize\t\t\t\t\t\t\t\t\\\n       && GET_CODE (AD) == PLUS)\t\t\t\t\t\t\\"}, {"sha": "ac6bdc9aff4006137a6a3eaa671e9247c3316aaf", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 124, "deletions": 248, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37", "patch": "@@ -105,12 +105,9 @@\n (define_delay (eq_attr \"type\" \"call\")\n   [(eq_attr \"in_call_delay\" \"true\") (nil) (nil)])\n \n-;; millicode call delay slot description.  Note it disallows delay slot\n-;; when TARGET_PORTABLE_RUNTIME is true.\n+;; Millicode call delay slot description.\n (define_delay (eq_attr \"type\" \"milli\")\n-  [(and (eq_attr \"in_call_delay\" \"true\")\n-\t(eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\") (const_int 0)))\n-   (nil) (nil)])\n+  [(eq_attr \"in_call_delay\" \"true\") (nil) (nil)])\n \n ;; Return and other similar instructions.\n (define_delay (eq_attr \"type\" \"branch,parallel_branch\")\n@@ -4089,27 +4086,7 @@\n   \"!TARGET_64BIT\"\n   \"* return output_mul_insn (0, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\")\n-     (cond [\n-;; Target (or stub) within reach\n-            (and (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n-                     (const_int 240000))\n-                 (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-                     (const_int 0)))\n-            (const_int 4)\n-\n-;; Out of reach PIC\n-            (ne (symbol_ref \"flag_pic\")\n-                (const_int 0))\n-            (const_int 24)\n-\n-;; Out of reach PORTABLE_RUNTIME\n-            (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-                (const_int 0))\n-            (const_int 20)]\n-\n-;; Out of reach, can use ble\n-          (const_int 12)))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 0)\"))])\n \n (define_insn \"\"\n   [(set (reg:SI 29) (mult:SI (reg:SI 26) (reg:SI 25)))\n@@ -4120,7 +4097,7 @@\n   \"TARGET_64BIT\"\n   \"* return output_mul_insn (0, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (const_int 4))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 0)\"))])\n \n (define_expand \"muldi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n@@ -4211,27 +4188,7 @@\n   \"*\n    return output_div_insn (operands, 0, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\")\n-     (cond [\n-;; Target (or stub) within reach\n-            (and (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n-                     (const_int 240000))\n-                 (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-                     (const_int 0)))\n-            (const_int 4)\n-\n-;; Out of reach PIC\n-            (ne (symbol_ref \"flag_pic\")\n-                (const_int 0))\n-            (const_int 24)\n-\n-;; Out of reach PORTABLE_RUNTIME\n-            (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-                (const_int 0))\n-            (const_int 20)]\n-\n-;; Out of reach, can use ble\n-          (const_int 12)))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 0)\"))])\n \n (define_insn \"\"\n   [(set (reg:SI 29)\n@@ -4245,7 +4202,7 @@\n   \"*\n    return output_div_insn (operands, 0, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (const_int 4))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 0)\"))])\n \n (define_expand \"udivsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n@@ -4261,6 +4218,7 @@\n   \"\n {\n   operands[3] = gen_reg_rtx (SImode);\n+\n   if (TARGET_64BIT)\n     {\n       operands[5] = gen_rtx_REG (SImode, 2);\n@@ -4287,27 +4245,7 @@\n   \"*\n    return output_div_insn (operands, 1, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\")\n-     (cond [\n-;; Target (or stub) within reach\n-            (and (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n-                     (const_int 240000))\n-                 (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-                     (const_int 0)))\n-            (const_int 4)\n-\n-;; Out of reach PIC\n-            (ne (symbol_ref \"flag_pic\")\n-                (const_int 0))\n-            (const_int 24)\n-\n-;; Out of reach PORTABLE_RUNTIME\n-            (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-                (const_int 0))\n-            (const_int 20)]\n-\n-;; Out of reach, can use ble\n-          (const_int 12)))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 0)\"))])\n \n (define_insn \"\"\n   [(set (reg:SI 29)\n@@ -4321,7 +4259,7 @@\n   \"*\n    return output_div_insn (operands, 1, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (const_int 4))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 0)\"))])\n \n (define_expand \"modsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n@@ -4360,27 +4298,7 @@\n   \"*\n   return output_mod_insn (0, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\")\n-     (cond [\n-;; Target (or stub) within reach\n-            (and (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n-                     (const_int 240000))\n-                 (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-                     (const_int 0)))\n-            (const_int 4)\n-\n-;; Out of reach PIC\n-            (ne (symbol_ref \"flag_pic\")\n-                (const_int 0))\n-            (const_int 24)\n-\n-;; Out of reach PORTABLE_RUNTIME\n-            (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-                (const_int 0))\n-            (const_int 20)]\n-\n-;; Out of reach, can use ble\n-          (const_int 12)))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 0)\"))])\n \n (define_insn \"\"\n   [(set (reg:SI 29) (mod:SI (reg:SI 26) (reg:SI 25)))\n@@ -4393,7 +4311,7 @@\n   \"*\n   return output_mod_insn (0, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (const_int 4))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 0)\"))])\n \n (define_expand \"umodsi3\"\n   [(set (reg:SI 26) (match_operand:SI 1 \"move_operand\" \"\"))\n@@ -4432,27 +4350,7 @@\n   \"*\n   return output_mod_insn (1, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\")\n-     (cond [\n-;; Target (or stub) within reach\n-            (and (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n-                     (const_int 240000))\n-                 (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-                     (const_int 0)))\n-            (const_int 4)\n-\n-;; Out of reach PIC\n-            (ne (symbol_ref \"flag_pic\")\n-                (const_int 0))\n-            (const_int 24)\n-\n-;; Out of reach PORTABLE_RUNTIME\n-            (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-                (const_int 0))\n-            (const_int 20)]\n-\n-;; Out of reach, can use ble\n-          (const_int 12)))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 0)\"))])\n \n (define_insn \"\"\n   [(set (reg:SI 29) (umod:SI (reg:SI 26) (reg:SI 25)))\n@@ -4465,7 +4363,7 @@\n   \"*\n   return output_mod_insn (1, insn);\"\n   [(set_attr \"type\" \"milli\")\n-   (set (attr \"length\") (const_int 4))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 0)\"))])\n \n ;;- and instructions\n ;; We define DImode `and` so with DImode `not` we can get\n@@ -6036,11 +5934,12 @@\n       call_insn = emit_call_insn (gen_call_internal_reg (operands[1]));\n     }\n \n+  if (TARGET_64BIT)\n+    use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), arg_pointer_rtx);\n+\n   if (flag_pic)\n     {\n       use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), pic_offset_table_rtx);\n-      if (TARGET_64BIT)\n-\tuse_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), arg_pointer_rtx);\n \n       /* After each call we must restore the PIC register, even if it\n \t doesn't appear to be used.  */\n@@ -6052,6 +5951,7 @@\n (define_insn \"call_internal_symref\"\n   [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n \t (match_operand 1 \"\" \"i\"))\n+   (clobber (reg:SI 1))\n    (clobber (reg:SI 2))\n    (use (const_int 0))]\n   \"! TARGET_PORTABLE_RUNTIME\"\n@@ -6061,21 +5961,7 @@\n   return output_call (insn, operands[0], 0);\n }\"\n   [(set_attr \"type\" \"call\")\n-   (set (attr \"length\")\n-;;       If we're sure that we can either reach the target or that the\n-;;\t linker can use a long-branch stub, then the length is at most\n-;;\t 8 bytes.\n-;;\n-;;\t For long-calls the length will be at most 68 bytes (non-pic)\n-;;\t or 84 bytes (pic).  */\n-;;\t Else we have to use a long-call;\n-      (if_then_else (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n-\t\t\t(const_int 240000))\n-\t\t    (const_int 8)\n-\t\t    (if_then_else (eq (symbol_ref \"flag_pic\")\n-\t\t\t\t      (const_int 0))\n-\t\t\t\t  (const_int 68)\n-\t\t\t\t  (const_int 84))))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 0)\"))])\n \n (define_insn \"call_internal_reg_64bit\"\n   [(call (mem:SI (match_operand:DI 0 \"register_operand\" \"r\"))\n@@ -6086,15 +5972,16 @@\n   \"*\n {\n   /* ??? Needs more work.  Length computation, split into multiple insns,\n-     do not use %r22 directly, expose delay slot.  */\n-  return \\\"ldd 16(%0),%%r2\\;ldd 24(%0),%%r27\\;bve,l (%%r2),%%r2\\;nop\\\";\n+     expose delay slot.  */\n+  return \\\"ldd 16(%0),%%r2\\;bve,l (%%r2),%%r2\\;ldd 24(%0),%%r27\\\";\n }\"\n   [(set_attr \"type\" \"dyncall\")\n-   (set (attr \"length\") (const_int 16))])\n+   (set (attr \"length\") (const_int 12))])\n \n (define_insn \"call_internal_reg\"\n   [(call (mem:SI (reg:SI 22))\n \t (match_operand 0 \"\" \"i\"))\n+   (clobber (reg:SI 1))\n    (clobber (reg:SI 2))\n    (use (const_int 1))]\n   \"\"\n@@ -6218,11 +6105,13 @@\n       call_insn = emit_call_insn (gen_call_value_internal_reg (operands[0],\n \t\t\t\t\t\t\t       operands[2]));\n     }\n+\n+  if (TARGET_64BIT)\n+    use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), arg_pointer_rtx);\n+\n   if (flag_pic)\n     {\n       use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), pic_offset_table_rtx);\n-      if (TARGET_64BIT)\n-\tuse_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), arg_pointer_rtx);\n \n       /* After each call we must restore the PIC register, even if it\n \t doesn't appear to be used.  */\n@@ -6235,6 +6124,7 @@\n   [(set (match_operand 0 \"\" \"=rf\")\n \t(call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n \t      (match_operand 2 \"\" \"i\")))\n+   (clobber (reg:SI 1))\n    (clobber (reg:SI 2))\n    (use (const_int 0))]\n   ;;- Don't use operand 1 for most machines.\n@@ -6245,21 +6135,7 @@\n   return output_call (insn, operands[1], 0);\n }\"\n   [(set_attr \"type\" \"call\")\n-   (set (attr \"length\")\n-;;       If we're sure that we can either reach the target or that the\n-;;\t linker can use a long-branch stub, then the length is at most\n-;;\t 8 bytes.\n-;;\n-;;\t For long-calls the length will be at most 68 bytes (non-pic)\n-;;\t or 84 bytes (pic).  */\n-;;\t Else we have to use a long-call;\n-      (if_then_else (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n-\t\t\t(const_int 240000))\n-\t\t    (const_int 8)\n-\t\t    (if_then_else (eq (symbol_ref \"flag_pic\")\n-\t\t\t\t      (const_int 0))\n-\t\t\t\t  (const_int 68)\n-\t\t\t\t  (const_int 84))))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 0)\"))])\n \n (define_insn \"call_value_internal_reg_64bit\"\n   [(set (match_operand 0 \"\" \"=rf\")\n@@ -6271,16 +6147,17 @@\n   \"*\n {\n   /* ??? Needs more work.  Length computation, split into multiple insns,\n-     do not use %r22 directly, expose delay slot.  */\n-  return \\\"ldd 16(%1),%%r2\\;ldd 24(%1),%%r27\\;bve,l (%%r2),%%r2\\;nop\\\";\n+     expose delay slot.  */\n+  return \\\"ldd 16(%1),%%r2\\;bve,l (%%r2),%%r2\\;ldd 24(%1),%%r27\\\";\n }\"\n   [(set_attr \"type\" \"dyncall\")\n-   (set (attr \"length\") (const_int 16))])\n+   (set (attr \"length\") (const_int 12))])\n \n (define_insn \"call_value_internal_reg\"\n   [(set (match_operand 0 \"\" \"=rf\")\n \t(call (mem:SI (reg:SI 22))\n \t      (match_operand 1 \"\" \"i\")))\n+   (clobber (reg:SI 1))\n    (clobber (reg:SI 2))\n    (use (const_int 1))]\n   \"\"\n@@ -6389,19 +6266,31 @@\n }\")\n \n (define_expand \"sibcall\"\n-  [(parallel [(call (match_operand:SI 0 \"\" \"\")\n-\t\t    (match_operand 1 \"\" \"\"))\n-\t      (clobber (reg:SI 0))])]\n-  \"! TARGET_PORTABLE_RUNTIME\"\n+  [(call (match_operand:SI 0 \"\" \"\")\n+\t (match_operand 1 \"\" \"\"))]\n+  \"!TARGET_PORTABLE_RUNTIME\"\n   \"\n {\n   rtx op;\n   rtx call_insn;\n \n   op = XEXP (operands[0], 0);\n \n-  /* We do not allow indirect sibling calls.  */\n-  call_insn = emit_call_insn (gen_sibcall_internal_symref (op, operands[1]));\n+  if (TARGET_64BIT)\n+    emit_move_insn (arg_pointer_rtx,\n+\t\t    gen_rtx_PLUS (word_mode, virtual_outgoing_args_rtx,\n+\t\t\t\t  GEN_INT (64)));\n+\n+  /* Indirect sibling calls are not allowed.  */\n+  if (TARGET_64BIT)\n+    call_insn = gen_sibcall_internal_symref_64bit (op, operands[1]);\n+  else\n+    call_insn = gen_sibcall_internal_symref (op, operands[1]);\n+\n+  call_insn = emit_call_insn (call_insn);\n+\n+  if (TARGET_64BIT)\n+    use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), arg_pointer_rtx);\n \n   if (flag_pic)\n     {\n@@ -6417,49 +6306,64 @@\n (define_insn \"sibcall_internal_symref\"\n   [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n \t (match_operand 1 \"\" \"i\"))\n-   (clobber (reg:SI 0))\n+   (clobber (reg:SI 1))\n    (use (reg:SI 2))\n    (use (const_int 0))]\n-  \"! TARGET_PORTABLE_RUNTIME\"\n+  \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n   \"*\n {\n   output_arg_descriptor (insn);\n   return output_call (insn, operands[0], 1);\n }\"\n   [(set_attr \"type\" \"call\")\n-   (set (attr \"length\")\n-;;       If we're sure that we can either reach the target or that the\n-;;\t linker can use a long-branch stub, then the length is at most\n-;;\t 8 bytes.\n-;;\n-;;\t For long-calls the length will be at most 68 bytes (non-pic)\n-;;\t or 84 bytes (pic).  */\n-;;\t Else we have to use a long-call;\n-      (if_then_else (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n-\t\t\t(const_int 240000))\n-\t\t    (const_int 8)\n-\t\t    (if_then_else (eq (symbol_ref \"flag_pic\")\n-\t\t\t\t      (const_int 0))\n-\t\t\t\t  (const_int 68)\n-\t\t\t\t  (const_int 84))))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 1)\"))])\n+\n+(define_insn \"sibcall_internal_symref_64bit\"\n+  [(call (mem:SI (match_operand 0 \"call_operand_address\" \"\"))\n+\t (match_operand 1 \"\" \"i\"))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 27))\n+   (use (reg:SI 2))\n+   (use (const_int 0))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  output_arg_descriptor (insn);\n+  return output_call (insn, operands[0], 1);\n+}\"\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 1)\"))])\n \n (define_expand \"sibcall_value\"\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n+  [(set (match_operand 0 \"\" \"\")\n \t\t   (call (match_operand:SI 1 \"\" \"\")\n-\t\t\t (match_operand 2 \"\" \"\")))\n-\t      (clobber (reg:SI 0))])]\n-  \"! TARGET_PORTABLE_RUNTIME\"\n+\t\t\t (match_operand 2 \"\" \"\")))]\n+  \"!TARGET_PORTABLE_RUNTIME\"\n   \"\n {\n   rtx op;\n   rtx call_insn;\n \n   op = XEXP (operands[1], 0);\n \n-  /* We do not allow indirect sibling calls.  */\n-  call_insn = emit_call_insn (gen_sibcall_value_internal_symref (operands[0],\n-\t\t\t\t\t\t\t\t op,\n-\t\t\t\t\t\t\t\t operands[2]));\n+  if (TARGET_64BIT)\n+    emit_move_insn (arg_pointer_rtx,\n+\t\t    gen_rtx_PLUS (word_mode, virtual_outgoing_args_rtx,\n+\t\t\t\t  GEN_INT (64)));\n+\n+  /* Indirect sibling calls are not allowed.  */\n+  if (TARGET_64BIT)\n+    call_insn\n+      = gen_sibcall_value_internal_symref_64bit (operands[0], op, operands[2]);\n+  else\n+    call_insn\n+      = gen_sibcall_value_internal_symref (operands[0], op, operands[2]);\n+\n+  call_insn = emit_call_insn (call_insn);\n+\n+  if (TARGET_64BIT)\n+    use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), arg_pointer_rtx);\n+\n   if (flag_pic)\n     {\n       use_reg (&CALL_INSN_FUNCTION_USAGE (call_insn), pic_offset_table_rtx);\n@@ -6475,32 +6379,34 @@\n   [(set (match_operand 0 \"\" \"=rf\")\n \t(call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n \t      (match_operand 2 \"\" \"i\")))\n-   (clobber (reg:SI 0))\n+   (clobber (reg:SI 1))\n    (use (reg:SI 2))\n    (use (const_int 0))]\n-  ;;- Don't use operand 1 for most machines.\n-  \"! TARGET_PORTABLE_RUNTIME\"\n+  \"!TARGET_PORTABLE_RUNTIME && !TARGET_64BIT\"\n   \"*\n {\n   output_arg_descriptor (insn);\n   return output_call (insn, operands[1], 1);\n }\"\n   [(set_attr \"type\" \"call\")\n-   (set (attr \"length\")\n-;;       If we're sure that we can either reach the target or that the\n-;;\t linker can use a long-branch stub, then the length is at most\n-;;\t 8 bytes.\n-;;\n-;;\t For long-calls the length will be at most 68 bytes (non-pic)\n-;;\t or 84 bytes (pic).  */\n-;;\t Else we have to use a long-call;\n-      (if_then_else (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n-\t\t\t(const_int 240000))\n-\t\t    (const_int 8)\n-\t\t    (if_then_else (eq (symbol_ref \"flag_pic\")\n-\t\t\t\t      (const_int 0))\n-\t\t\t\t  (const_int 68)\n-\t\t\t\t  (const_int 84))))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 1)\"))])\n+\n+(define_insn \"sibcall_value_internal_symref_64bit\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+\t(call (mem:SI (match_operand 1 \"call_operand_address\" \"\"))\n+\t      (match_operand 2 \"\" \"i\")))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 27))\n+   (use (reg:SI 2))\n+   (use (const_int 0))]\n+  \"TARGET_64BIT\"\n+  \"*\n+{\n+  output_arg_descriptor (insn);\n+  return output_call (insn, operands[1], 1);\n+}\"\n+  [(set_attr \"type\" \"call\")\n+   (set (attr \"length\") (symbol_ref \"attr_length_call (insn, 1)\"))])\n \n (define_insn \"nop\"\n   [(const_int 0)]\n@@ -7392,6 +7298,12 @@\n   \"!TARGET_64BIT\"\n   \"*\n {\n+  int length = get_attr_length (insn);\n+  rtx xoperands[2];\n+\n+  xoperands[0] = GEN_INT (length - 8);\n+  xoperands[1] = GEN_INT (length - 16);\n+\n   /* Must import the magic millicode routine.  */\n   output_asm_insn (\\\".IMPORT $$sh_func_adrs,MILLICODE\\\", NULL);\n \n@@ -7400,60 +7312,24 @@\n      First, copy our input parameter into %r29 just in case we don't\n      need to call $$sh_func_adrs.  */\n   output_asm_insn (\\\"copy %%r26,%%r29\\\", NULL);\n+  output_asm_insn (\\\"{extru|extrw,u} %%r26,31,2,%%r31\\\", NULL);\n \n   /* Next, examine the low two bits in %r26, if they aren't 0x2, then\n      we use %r26 unchanged.  */\n-  if (get_attr_length (insn) == 32)\n-    output_asm_insn (\\\"{extru|extrw,u} %%r26,31,2,%%r31\\;{comib|cmpib},<>,n 2,%%r31,.+24\\\", NULL);\n-  else if (get_attr_length (insn) == 40)\n-    output_asm_insn (\\\"{extru|extrw,u} %%r26,31,2,%%r31\\;{comib|cmpib},<>,n 2,%%r31,.+32\\\", NULL);\n-  else if (get_attr_length (insn) == 44)\n-    output_asm_insn (\\\"{extru|extrw,u} %%r26,31,2,%%r31\\;{comib|cmpib},<>,n 2,%%r31,.+36\\\", NULL);\n-  else\n-    output_asm_insn (\\\"{extru|extrw,u} %%r26,31,2,%%r31\\;{comib|cmpib},<>,n 2,%%r31,.+20\\\", NULL);\n+  output_asm_insn (\\\"{comib|cmpib},<>,n 2,%%r31,.+%0\\\", xoperands);\n+  output_asm_insn (\\\"ldi 4096,%%r31\\\", NULL);\n \n   /* Next, compare %r26 with 4096, if %r26 is less than or equal to\n-     4096, then we use %r26 unchanged.  */\n-  if (get_attr_length (insn) == 32)\n-    output_asm_insn (\\\"ldi 4096,%%r31\\;{comb|cmpb},<<,n %%r26,%%r31,.+16\\\",\n-\t\t     NULL);\n-  else if (get_attr_length (insn) == 40)\n-    output_asm_insn (\\\"ldi 4096,%%r31\\;{comb|cmpb},<<,n %%r26,%%r31,.+24\\\",\n-\t\t     NULL);\n-  else if (get_attr_length (insn) == 44)\n-    output_asm_insn (\\\"ldi 4096,%%r31\\;{comb|cmpb},<<,n %%r26,%%r31,.+28\\\",\n-\t\t     NULL);\n-  else\n-    output_asm_insn (\\\"ldi 4096,%%r31\\;{comb|cmpb},<<,n %%r26,%%r31,.+12\\\",\n-\t\t     NULL);\n+     4096, then again we use %r26 unchanged.  */\n+  output_asm_insn (\\\"{comb|cmpb},<<,n %%r26,%%r31,.+%1\\\", xoperands);\n \n-  /* Else call $$sh_func_adrs to extract the function's real add24.  */\n+  /* Finally, call $$sh_func_adrs to extract the function's real add24.  */\n   return output_millicode_call (insn,\n \t\t\t\tgen_rtx_SYMBOL_REF (SImode,\n-\t\t\t\t\t \\\"$$sh_func_adrs\\\"));\n+\t\t\t\t\t\t    \\\"$$sh_func_adrs\\\"));\n }\"\n   [(set_attr \"type\" \"multi\")\n-   (set (attr \"length\")\n-     (cond [\n-;; Target (or stub) within reach\n-            (and (lt (plus (symbol_ref \"total_code_bytes\") (pc))\n-                     (const_int 240000))\n-                 (eq (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-                     (const_int 0)))\n-            (const_int 28)\n-\n-;; Out of reach PIC\n-\t    (ne (symbol_ref \"flag_pic\")\n-\t\t(const_int 0))\n-\t    (const_int 44)\n-\n-;; Out of reach PORTABLE_RUNTIME\n-\t    (ne (symbol_ref \"TARGET_PORTABLE_RUNTIME\")\n-\t\t(const_int 0))\n-\t    (const_int 40)]\n-\n-;; Out of reach, can use ble\n-          (const_int 32)))])\n+   (set (attr \"length\") (symbol_ref \"attr_length_millicode_call (insn, 20)\"))])\n \n ;; On the PA, the PIC register is call clobbered, so it must\n ;; be saved & restored around calls by the caller.  If the call"}, {"sha": "98c66fbfe37657b22ed5fc4131b8736054fa8f96", "filename": "gcc/config/pa/som.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37/gcc%2Fconfig%2Fpa%2Fsom.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37/gcc%2Fconfig%2Fpa%2Fsom.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fsom.h?ref=a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37", "patch": "@@ -371,3 +371,7 @@ do {\t\t\t\t\t\t\\\n    on the location of the GCC tool directory.  The downside is GCC\n    cannot be moved after installation using a symlink.  */\n #define ALWAYS_STRIP_DOTDOT 1\n+\n+/* Aggregates with a single float or double field should be passed and\n+   returned in the general registers.  */\n+#define MEMBER_TYPE_FORCES_BLK(FIELD, MODE) (MODE==SFmode || MODE==DFmode)"}, {"sha": "d1b2b26493148cb96142a14a3af73b55ab1457bb", "filename": "gcc/config/pa/t-pa64", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37/gcc%2Fconfig%2Fpa%2Ft-pa64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37/gcc%2Fconfig%2Fpa%2Ft-pa64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Ft-pa64?ref=a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37", "patch": "@@ -1,4 +1,4 @@\n-TARGET_LIBGCC2_CFLAGS = -fPIC -Dpa64=1 -DELF=1\n+TARGET_LIBGCC2_CFLAGS = -fPIC -Dpa64=1 -DELF=1 -mlong-calls\n \n LIB2FUNCS_EXTRA=quadlib.c\n "}, {"sha": "7d994b19c5b7c20508d3a964771e9a524b7b1fe8", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=a02aa5b099b5da28ce96a3ad4e5cfb0e23b34e37", "patch": "@@ -508,7 +508,7 @@ in the following sections.\n -march=@var{architecture-type} @gol\n -mbig-switch  -mdisable-fpregs  -mdisable-indexing @gol\n -mfast-indirect-calls  -mgas  -mgnu-ld -mhp-ld @gol\n--mjump-in-delay -mlinker-opt @gol\n+-mjump-in-delay -mlinker-opt -mlong-calls @gol\n -mlong-load-store  -mno-big-switch  -mno-disable-fpregs @gol\n -mno-disable-indexing  -mno-fast-indirect-calls  -mno-gas @gol\n -mno-jump-in-delay  -mno-long-load-store @gol\n@@ -8094,6 +8094,33 @@ configure option, gcc's program search path, and finally by the user's\n @env{PATH}.  The linker used by GCC can be printed using @samp{which\n `gcc -print-prog-name=ld`}.\n \n+@item -mlong-calls\n+@opindex mno-long-calls\n+Generate code that uses long call sequences.  This ensures that a call\n+is always able to reach linker generated stubs.  The default is to generate\n+long calls only when the distance from the call site to the beginning\n+of the function or translation unit, as the case may be, exceeds a\n+predefined limit set by the branch type being used.  The limits for\n+normal calls are 7,600,000 and 240,000 bytes, respectively for the\n+PA 2.0 and PA 1.X architectures.  Sibcalls are always limited at\n+240,000 bytes.\n+\n+Distances are measured from the beginning of functions when using the\n+@option{-ffunction-sections} option, or when using the @option{-mgas}\n+and @option{-mno-portable-runtime} options together under HP-UX with\n+the SOM linker.\n+\n+It is normally not desirable to use this option as it will degrade\n+performance.  However, it may be useful in large applications,\n+particularly when partial linking is used to build the application.\n+\n+The types of long calls used depends on the capabilities of the\n+assembler and linker, and the type of code being generated.  The\n+impact on systems that support long absolute calls, and long pic\n+symbol-difference or pc-relative calls should be relatively small.\n+However, an indirect call is used on 32-bit ELF systems in pic code\n+and it is quite long.\n+\n @end table\n \n @node Intel 960 Options"}]}