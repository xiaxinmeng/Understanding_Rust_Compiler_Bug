{"sha": "d7e20130650fb46d71e0403652e4e07bc14f9775", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdlMjAxMzA2NTBmYjQ2ZDcxZTA0MDM2NTJlNGUwN2JjMTRmOTc3NQ==", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2020-08-10T16:05:07Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-22T12:11:23Z"}, "message": "[Ada] Reimplementation of accessibility checking\n\ngcc/ada/\n\n\t* checks.adb (Apply_Accessibility_Check): Modify condition to\n\tavoid flawed optimization and use Get_Accessibility over\n\tExtra_Accessibility.\n\t* exp_attr.adb: Remove inclusion of Exp_Ch2.adb.\n\t* exp_ch2.adb, exp_ch2.ads (Param_Entity): Moved to sem_util.\n\t* exp_ch3.ads (Init_Proc_Level_Formal): New function.\n\t* exp_ch3.adb (Build_Init_Procedure): Add extra accessibility\n\tformal for init procs when the associated type is a limited\n\trecord.\n\t(Build_Initialization_Call): Add condition to handle propagation\n\tof the new extra accessibility paramter actual needed for init\n\tprocs.\n\t(Init_Proc_Level_Formal): Created to fetch a the extra\n\taccessibility parameter associated with init procs if one\n\texists.\n\t* exp_ch4.adb (Build_Attribute_Reference): Modify static check\n\tto be dynamic.\n\t* exp_ch6.adb (Add_Cond_Expression_Extra_Actual): Move logic\n\tused to expand conditional expressions used as actuals for\n\tanonymous access formals.\n\t(Expand_Call_Helper): Remove extranious accessibility\n\tcalculation logic.\n\t* exp_util.adb: Remove inclusion of Exp_Ch2.adb.\n\t* par-ch3.adb (P_Array_Type_Definition): Properly set\n\tAliased_Present on access definitions\n\t* sem_attr.adb (Resolve_Attribute): Replace instances for\n\tObject_Access_Level with Static_Accessibility_Level.\n\t* sem_ch13.adb (Storage_Pool): Replace instances for\n\tObject_Access_Level with Static_Accessibility_Level.\n\t* sem_ch6.adb (Check_Return_Construct_Accessibility): Replace\n\tinstances for Object_Access_Level with\n\tStatic_Accessibility_Level.\n\t* sem_ch9.adb (Analyze_Requeue): Replace instances for\n\tObject_Access_Level with Static_Accessibility_Level.\n\t* sem_res.adb (Check_Aliased_Parameter,\n\tCheck_Allocator_Discrim_Accessibility, Valid_Conversion):\n\tReplace instances for Object_Access_Level with\n\tStatic_Accessibility_Level.\n\t* sem_util.adb, sem_util.ads (Accessibility_Level_Helper):\n\tCreated to centralize calculation of accessibility levels.\n\t(Build_Component_Subtype): Replace instances for\n\tObject_Access_Level with Static_Accessibility_Level.\n\t(Defining_Entity): Add extra parameter to dictate whether an\n\terror is raised or empty is return in the case of an irrelevant\n\tN.\n\t(Dynamic_Accessibility_Level): Rewritten to use\n\tAccessibility_Level_Helper.\n\t(Is_View_Conversion): Check membership against Etype to capture\n\tnodes like explicit dereferences which have types but are not\n\texpanded names or identifers.\n\t(Object_Access_LeveL): Removed.\n\t(Param_Entity): Moved from sem_util.\n\t(Static_Accessibility_Level): Created as a replacement to\n\tObject_Access_Level, it also uses Accessibility_Level_Helper for\n\tits implementation.\n\t* snames.ads-tmpl: Added new name for extra accessibility\n\tparameter in init procs.", "tree": {"sha": "367ba790c9ea9c6119981d296ca28b0e0c975477", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/367ba790c9ea9c6119981d296ca28b0e0c975477"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7e20130650fb46d71e0403652e4e07bc14f9775", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7e20130650fb46d71e0403652e4e07bc14f9775", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7e20130650fb46d71e0403652e4e07bc14f9775", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7e20130650fb46d71e0403652e4e07bc14f9775/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cda800dd90c3dcc6452b0567c62327c651c628dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cda800dd90c3dcc6452b0567c62327c651c628dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cda800dd90c3dcc6452b0567c62327c651c628dd"}], "stats": {"total": 2306, "additions": 994, "deletions": 1312}, "files": [{"sha": "6d20fbbb2e554e82cbed37b013f20a55b574984e", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=d7e20130650fb46d71e0403652e4e07bc14f9775", "patch": "@@ -30,7 +30,6 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Eval_Fat; use Eval_Fat;\n with Exp_Ch11; use Exp_Ch11;\n-with Exp_Ch2;  use Exp_Ch2;\n with Exp_Ch4;  use Exp_Ch4;\n with Exp_Pakd; use Exp_Pakd;\n with Exp_Util; use Exp_Util;\n@@ -602,19 +601,16 @@ package body Checks is\n          return;\n \n       --  Only apply the run-time check if the access parameter has an\n-      --  associated extra access level parameter and when the level of the\n-      --  type is less deep than the level of the access parameter, and\n-      --  accessibility checks are not suppressed.\n+      --  associated extra access level parameter and when accessibility checks\n+      --  are enabled.\n \n       elsif Present (Param_Ent)\n-         and then Present (Extra_Accessibility (Param_Ent))\n-         and then UI_Gt (Object_Access_Level (N),\n-                         Deepest_Type_Access_Level (Typ))\n+         and then Present (Get_Accessibility (Param_Ent))\n          and then not Accessibility_Checks_Suppressed (Param_Ent)\n          and then not Accessibility_Checks_Suppressed (Typ)\n       then\n          Param_Level :=\n-           New_Occurrence_Of (Extra_Accessibility (Param_Ent), Loc);\n+           New_Occurrence_Of (Get_Accessibility (Param_Ent), Loc);\n \n          --  Use the dynamic accessibility parameter for the function's result\n          --  when one has been created instead of statically referring to the"}, {"sha": "301479d885520926f99396417e69f623c0b35b45", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=d7e20130650fb46d71e0403652e4e07bc14f9775", "patch": "@@ -29,7 +29,6 @@ with Checks;   use Checks;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Exp_Atag; use Exp_Atag;\n-with Exp_Ch2;  use Exp_Ch2;\n with Exp_Ch3;  use Exp_Ch3;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch9;  use Exp_Ch9;"}, {"sha": "5c3435b75a07207855fe8caa124c6af1353ea658", "filename": "gcc/ada/exp_ch2.adb", "status": "modified", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=d7e20130650fb46d71e0403652e4e07bc14f9775", "patch": "@@ -717,98 +717,4 @@ package body Exp_Ch2 is\n       Analyze_And_Resolve (N, T);\n    end Expand_Renaming;\n \n-   ------------------\n-   -- Param_Entity --\n-   ------------------\n-\n-   --  This would be trivial, simply a test for an identifier that was a\n-   --  reference to a formal, if it were not for the fact that a previous call\n-   --  to Expand_Entry_Parameter will have modified the reference to the\n-   --  identifier. A formal of a protected entity is rewritten as\n-\n-   --    typ!(recobj).rec.all'Constrained\n-\n-   --  where rec is a selector whose Entry_Formal link points to the formal\n-\n-   --  If the type of the entry parameter has a representation clause, then an\n-   --  extra temp is involved (see below).\n-\n-   --  For a formal of a task entity, the formal is rewritten as a local\n-   --  renaming.\n-\n-   --  In addition, a formal that is marked volatile because it is aliased\n-   --  through an address clause is rewritten as dereference as well.\n-\n-   function Param_Entity (N : Node_Id) return Entity_Id is\n-      Renamed_Obj : Node_Id;\n-\n-   begin\n-      --  Simple reference case\n-\n-      if Nkind (N) in N_Identifier | N_Expanded_Name then\n-         if Is_Formal (Entity (N)) then\n-            return Entity (N);\n-\n-         --  Handle renamings of formal parameters and formals of tasks that\n-         --  are rewritten as renamings.\n-\n-         elsif Nkind (Parent (Entity (N))) = N_Object_Renaming_Declaration then\n-            Renamed_Obj := Get_Referenced_Object (Renamed_Object (Entity (N)));\n-\n-            if Is_Entity_Name (Renamed_Obj)\n-              and then Is_Formal (Entity (Renamed_Obj))\n-            then\n-               return Entity (Renamed_Obj);\n-\n-            elsif\n-              Nkind (Parent (Parent (Entity (N)))) = N_Accept_Statement\n-            then\n-               return Entity (N);\n-            end if;\n-         end if;\n-\n-      else\n-         if Nkind (N) = N_Explicit_Dereference then\n-            declare\n-               P    : Node_Id := Prefix (N);\n-               S    : Node_Id;\n-               E    : Entity_Id;\n-               Decl : Node_Id;\n-\n-            begin\n-               --  If the type of an entry parameter has a representation\n-               --  clause, then the prefix is not a selected component, but\n-               --  instead a reference to a temp pointing at the selected\n-               --  component. In this case, set P to be the initial value of\n-               --  that temp.\n-\n-               if Nkind (P) = N_Identifier then\n-                  E := Entity (P);\n-\n-                  if Ekind (E) = E_Constant then\n-                     Decl := Parent (E);\n-\n-                     if Nkind (Decl) = N_Object_Declaration then\n-                        P := Expression (Decl);\n-                     end if;\n-                  end if;\n-               end if;\n-\n-               if Nkind (P) = N_Selected_Component then\n-                  S := Selector_Name (P);\n-\n-                  if Present (Entry_Formal (Entity (S))) then\n-                     return Entry_Formal (Entity (S));\n-                  end if;\n-\n-               elsif Nkind (Original_Node (N)) = N_Identifier then\n-                  return Param_Entity (Original_Node (N));\n-               end if;\n-            end;\n-         end if;\n-      end if;\n-\n-      return (Empty);\n-   end Param_Entity;\n-\n end Exp_Ch2;"}, {"sha": "8d11dd4de1e0611da1334ee0e6b1c20c31a975d9", "filename": "gcc/ada/exp_ch2.ads", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fexp_ch2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fexp_ch2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.ads?ref=d7e20130650fb46d71e0403652e4e07bc14f9775", "patch": "@@ -32,14 +32,4 @@ package Exp_Ch2 is\n    procedure Expand_N_Identifier     (N : Node_Id);\n    procedure Expand_N_Real_Literal   (N : Node_Id);\n \n-   function Param_Entity (N : Node_Id) return Entity_Id;\n-   --  Given an expression N, determines if the expression is a reference\n-   --  to a formal (of a subprogram or entry), and if so returns the Id\n-   --  of the corresponding formal entity, otherwise returns Empty. The\n-   --  reason that this is in Exp_Ch2 is that it has to deal with the case\n-   --  where the reference is to an entry formal, and has been expanded\n-   --  already. Since Exp_Ch2 is in charge of the expansion, it is best\n-   --  suited to knowing how to detect this case. Also handles the case\n-   --  of references to renamings of formals.\n-\n end Exp_Ch2;"}, {"sha": "777e661d83708feef603dc9488c13e261f4c1a54", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 63, "deletions": 3, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=d7e20130650fb46d71e0403652e4e07bc14f9775", "patch": "@@ -1335,6 +1335,31 @@ package body Exp_Ch3 is\n       return Agg;\n    end Build_Equivalent_Record_Aggregate;\n \n+   ----------------------------\n+   -- Init_Proc_Level_Formal --\n+   ----------------------------\n+\n+   function Init_Proc_Level_Formal (Proc : Entity_Id) return Entity_Id is\n+      Form : Entity_Id;\n+   begin\n+      --  Move through the formals of the initialization procedure Proc to find\n+      --  the extra accessibility level parameter associated with the object\n+      --  being initialized.\n+\n+      Form := First_Formal (Proc);\n+      while Present (Form) loop\n+         if Chars (Form) = Name_uInit_Level then\n+            return Form;\n+         end if;\n+\n+         Next_Formal (Form);\n+      end loop;\n+\n+      --  No formal was found, return Empty\n+\n+      return Empty;\n+   end Init_Proc_Level_Formal;\n+\n    -------------------------------\n    -- Build_Initialization_Call --\n    -------------------------------\n@@ -1772,6 +1797,24 @@ package body Exp_Ch3 is\n            New_Copy_List (Parameter_Associations (Constructor_Ref)));\n       end if;\n \n+      --  Pass the extra accessibility level parameter associated with the\n+      --  level of the object being initialized when required.\n+\n+      --  When no entity is present for Id_Ref it may not have been fully\n+      --  analyzed, so allow the default value of standard standard to be\n+      --  passed ???\n+\n+      if Is_Entity_Name (Id_Ref)\n+        and then Present (Init_Proc_Level_Formal (Proc))\n+      then\n+         Append_To (Args,\n+           Make_Parameter_Association (Loc,\n+             Selector_Name             =>\n+               Make_Identifier (Loc, Name_uInit_Level),\n+             Explicit_Actual_Parameter =>\n+               Dynamic_Accessibility_Level (Id_Ref)));\n+      end if;\n+\n       Append_To (Res,\n         Make_Procedure_Call_Statement (Loc,\n           Name                   => New_Occurrence_Of (Proc, Loc),\n@@ -2513,6 +2556,21 @@ package body Exp_Ch3 is\n                   New_Occurrence_Of (Standard_True, Loc)));\n          end if;\n \n+         --  Create an extra accessibility parameter to capture the level of\n+         --  the object being initialized when its type is a limited record.\n+\n+         if Is_Limited_Record (Rec_Type) then\n+            Append_To (Parameters,\n+              Make_Parameter_Specification (Loc,\n+                Defining_Identifier => Make_Defining_Identifier\n+                                         (Loc, Name_uInit_Level),\n+                Parameter_Type      =>\n+                  New_Occurrence_Of (Standard_Natural, Loc),\n+                Expression          =>\n+                  Make_Integer_Literal\n+                    (Loc, Scope_Depth (Standard_Standard))));\n+         end if;\n+\n          Set_Parameter_Specifications (Proc_Spec_Node, Parameters);\n          Set_Specification (Body_Node, Proc_Spec_Node);\n          Set_Declarations (Body_Node, Decls);\n@@ -7449,7 +7507,8 @@ package body Exp_Ch3 is\n \n             if No (Expr) then\n                Level_Expr :=\n-                 Make_Integer_Literal (Loc, Scope_Depth (Standard_Standard));\n+                 Make_Integer_Literal\n+                   (Loc, Scope_Depth (Standard_Standard));\n \n             --  When the expression of the object is a function which returns\n             --  an anonymous access type the master of the call is the object\n@@ -7459,7 +7518,7 @@ package body Exp_Ch3 is\n               and then Ekind (Etype (Name (Expr))) = E_Anonymous_Access_Type\n             then\n                Level_Expr := Make_Integer_Literal (Loc,\n-                               Object_Access_Level (Def_Id));\n+                               Static_Accessibility_Level (Def_Id));\n \n             --  General case\n \n@@ -8143,7 +8202,8 @@ package body Exp_Ch3 is\n                   --  It is known that the accessibility level of the access\n                   --  type is deeper than that of the pool.\n \n-                  if Type_Access_Level (Def_Id) > Object_Access_Level (Pool)\n+                  if Type_Access_Level (Def_Id)\n+                       > Static_Accessibility_Level (Pool)\n                     and then Is_Class_Wide_Type (Etype (Pool))\n                     and then not Accessibility_Checks_Suppressed (Def_Id)\n                     and then not Accessibility_Checks_Suppressed (Pool)"}, {"sha": "a4b7f1fa1dc83d0fac0905f9a30d50d14898dedc", "filename": "gcc/ada/exp_ch3.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fexp_ch3.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fexp_ch3.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.ads?ref=d7e20130650fb46d71e0403652e4e07bc14f9775", "patch": "@@ -135,6 +135,11 @@ package Exp_Ch3 is\n    --  type is valid only when Normalize_Scalars or Initialize_Scalars is\n    --  active, or if N is the node for a 'Invalid_Value attribute node.\n \n+   function Init_Proc_Level_Formal (Proc : Entity_Id) return Entity_Id;\n+   --  Fetch the extra formal from an initalization procedure \"proc\"\n+   --  corresponding to the level of the object being initialized. When none\n+   --  is present Empty is returned.\n+\n    procedure Init_Secondary_Tags\n      (Typ            : Entity_Id;\n       Target         : Node_Id;"}, {"sha": "da2c629896dd4e2750a211838288e9db60be71dc", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 16, "deletions": 27, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=d7e20130650fb46d71e0403652e4e07bc14f9775", "patch": "@@ -31,7 +31,6 @@ with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Aggr; use Exp_Aggr;\n with Exp_Atag; use Exp_Atag;\n-with Exp_Ch2;  use Exp_Ch2;\n with Exp_Ch3;  use Exp_Ch3;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch7;  use Exp_Ch7;\n@@ -6867,37 +6866,27 @@ package body Exp_Ch4 is\n                   --  Apply an accessibility check if the access object has an\n                   --  associated access level and when the level of the type is\n                   --  less deep than the level of the access parameter. This\n-                  --  only occur for access parameters and stand-alone objects\n-                  --  of an anonymous access type.\n+                  --  can only occur for access parameters and stand-alone\n+                  --  objects of an anonymous access type.\n \n                   else\n-                     if Present (Expr_Entity)\n-                       and then\n-                         Present\n-                           (Effective_Extra_Accessibility (Expr_Entity))\n-                       and then UI_Gt (Object_Access_Level (Lop),\n-                                       Type_Access_Level (Rtyp))\n-                     then\n-                        Param_Level :=\n-                          New_Occurrence_Of\n-                            (Effective_Extra_Accessibility (Expr_Entity), Loc);\n+                     Param_Level := Dynamic_Accessibility_Level (Expr_Entity);\n \n-                        Type_Level :=\n-                          Make_Integer_Literal (Loc, Type_Access_Level (Rtyp));\n+                     Type_Level :=\n+                       Make_Integer_Literal (Loc, Type_Access_Level (Rtyp));\n \n-                        --  Return True only if the accessibility level of the\n-                        --  expression entity is not deeper than the level of\n-                        --  the tested access type.\n+                     --  Return True only if the accessibility level of the\n+                     --  expression entity is not deeper than the level of\n+                     --  the tested access type.\n \n-                        Rewrite (N,\n-                          Make_And_Then (Loc,\n-                            Left_Opnd  => Relocate_Node (N),\n-                            Right_Opnd => Make_Op_Le (Loc,\n-                                            Left_Opnd  => Param_Level,\n-                                            Right_Opnd => Type_Level)));\n+                     Rewrite (N,\n+                       Make_And_Then (Loc,\n+                         Left_Opnd  => Relocate_Node (N),\n+                         Right_Opnd => Make_Op_Le (Loc,\n+                                         Left_Opnd  => Param_Level,\n+                                         Right_Opnd => Type_Level)));\n \n-                        Analyze_And_Resolve (N);\n-                     end if;\n+                     Analyze_And_Resolve (N);\n \n                      --  If the designated type is tagged, do tagged membership\n                      --  operation.\n@@ -12296,7 +12285,7 @@ package body Exp_Ch4 is\n            and then Ekind (Operand_Type) = E_Anonymous_Access_Type\n            and then Nkind (Operand) = N_Selected_Component\n            and then Ekind (Entity (Selector_Name (Operand))) = E_Discriminant\n-           and then Object_Access_Level (Operand) >\n+           and then Static_Accessibility_Level (Operand) >\n                       Type_Access_Level (Target_Type)\n          then\n             Raise_Accessibility_Error;"}, {"sha": "2f39946a2c8db9991cb13c36d884da02b7b199bb", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 235, "deletions": 600, "changes": 835, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=d7e20130650fb46d71e0403652e4e07bc14f9775", "patch": "@@ -34,7 +34,6 @@ with Elists;    use Elists;\n with Expander;  use Expander;\n with Exp_Aggr;  use Exp_Aggr;\n with Exp_Atag;  use Exp_Atag;\n-with Exp_Ch2;   use Exp_Ch2;\n with Exp_Ch3;   use Exp_Ch3;\n with Exp_Ch7;   use Exp_Ch7;\n with Exp_Ch9;   use Exp_Ch9;\n@@ -1807,13 +1806,7 @@ package body Exp_Ch6 is\n \n                   pragma Assert (Ada_Version >= Ada_2012);\n \n-                  if Type_Access_Level (E_Formal) >\n-                     Object_Access_Level (Lhs)\n-                  then\n-                     Append_To (Post_Call,\n-                       Make_Raise_Program_Error (Loc,\n-                         Reason => PE_Accessibility_Check_Failed));\n-                  end if;\n+                  Apply_Accessibility_Check (Lhs, E_Formal, N);\n \n                   Append_To (Post_Call,\n                     Make_Assignment_Statement (Loc,\n@@ -2782,6 +2775,15 @@ package body Exp_Ch6 is\n       --  default parameters and for extra actuals (for Extra_Formals). The\n       --  argument is an N_Parameter_Association node.\n \n+      procedure Add_Cond_Expression_Extra_Actual (Formal : Entity_Id);\n+      --  Adds extra accessibility actuals in the case of a conditional\n+      --  expression corresponding to Formal.\n+\n+      --  Note: Conditional expressions used as actuals for anonymous access\n+      --  formals complicate the process of propagating extra accessibility\n+      --  actuals and must be handled in a recursive fashion since they can\n+      --  be embedded within each other.\n+\n       procedure Add_Extra_Actual (Expr : Node_Id; EF : Entity_Id);\n       --  Adds an extra actual to the list of extra actuals. Expr is the\n       --  expression for the value of the actual, EF is the entity for the\n@@ -2869,6 +2871,219 @@ package body Exp_Ch6 is\n          Prev := Actual_Expr;\n       end Add_Actual_Parameter;\n \n+      --------------------------------------\n+      -- Add_Cond_Expression_Extra_Actual --\n+      --------------------------------------\n+\n+      procedure Add_Cond_Expression_Extra_Actual\n+        (Formal : Entity_Id)\n+      is\n+         Decl : Node_Id;\n+\n+         --  Suppress warning for the final removal loop\n+         pragma Warnings (Off, Decl);\n+\n+         Lvl  : Entity_Id;\n+         Res  : Entity_Id;\n+         Temp : Node_Id;\n+         Typ  : Node_Id;\n+\n+         procedure Insert_Level_Assign (Branch : Node_Id);\n+         --  Recursivly add assignment of the level temporary on each branch\n+         --  while moving through nested conditional expressions.\n+\n+         -------------------------\n+         -- Insert_Level_Assign --\n+         -------------------------\n+\n+         procedure Insert_Level_Assign (Branch : Node_Id) is\n+\n+            procedure Expand_Branch (Res_Assn : Node_Id);\n+            --  Perform expansion or iterate further within nested\n+            --  conditionals given the object declaration or assignment to\n+            --  result object created during expansion which represents a\n+            --  branch of the conditional expression.\n+\n+            -------------------\n+            -- Expand_Branch --\n+            -------------------\n+\n+            procedure Expand_Branch (Res_Assn : Node_Id) is\n+            begin\n+               pragma Assert (Nkind (Res_Assn) in\n+                               N_Assignment_Statement |\n+                               N_Object_Declaration);\n+\n+               --  There are more nested conditional expressions so we must go\n+               --  deeper.\n+\n+               if Nkind (Expression (Res_Assn)) =\n+                    N_Expression_With_Actions\n+                 and then\n+                   Nkind\n+                     (Original_Node (Expression (Res_Assn)))\n+                       in N_Case_Expression | N_If_Expression\n+               then\n+                  Insert_Level_Assign\n+                    (Expression (Res_Assn));\n+\n+               --  Add the level assignment\n+\n+               else\n+                  Insert_Before_And_Analyze (Res_Assn,\n+                    Make_Assignment_Statement (Loc,\n+                      Name       =>\n+                        New_Occurrence_Of\n+                          (Lvl, Loc),\n+                      Expression =>\n+                        Dynamic_Accessibility_Level\n+                          (Expression (Res_Assn))));\n+               end if;\n+            end Expand_Branch;\n+\n+            Cond : Node_Id;\n+            Alt  : Node_Id;\n+\n+         --  Start of processing for Insert_Level_Assign\n+\n+         begin\n+            --  Examine further nested condtionals\n+\n+            pragma Assert (Nkind (Branch) =\n+                            N_Expression_With_Actions);\n+\n+            --  Find the relevant statement in the actions\n+\n+            Cond := First (Actions (Branch));\n+            while Present (Cond) loop\n+               exit when Nkind (Cond) in\n+                           N_Case_Statement | N_If_Statement;\n+\n+               Next (Cond);\n+            end loop;\n+\n+            --  The conditional expression may have been optimized away, so\n+            --  examine the actions in the branch.\n+\n+            if No (Cond) then\n+               Expand_Branch (Last (Actions (Branch)));\n+\n+            --  Iterate through if expression branches\n+\n+            elsif Nkind (Cond) = N_If_Statement then\n+               Expand_Branch (Last (Then_Statements (Cond)));\n+               Expand_Branch (Last (Else_Statements (Cond)));\n+\n+            --  Iterate through case alternatives\n+\n+            elsif Nkind (Cond) = N_Case_Statement then\n+\n+               Alt := First (Alternatives (Cond));\n+               while Present (Alt) loop\n+                  Expand_Branch (Last (Statements (Alt)));\n+\n+                  Next (Alt);\n+               end loop;\n+            end if;\n+         end Insert_Level_Assign;\n+\n+      --  Start of processing for cond expression case\n+\n+      begin\n+         --  Create declaration of a temporary to store the accessibility\n+         --  level of each branch of the conditional expression.\n+\n+         Lvl  := Make_Temporary (Loc, 'L');\n+         Decl := Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Lvl,\n+                   Object_Definition   =>\n+                     New_Occurrence_Of (Standard_Natural, Loc));\n+\n+         --  Install the declaration and perform necessary expansion if we\n+         --  are dealing with a function call.\n+\n+         if Nkind (Call_Node) = N_Procedure_Call_Statement then\n+            --  Generate:\n+            --    Lvl : Natural;\n+            --    Call (\n+            --     {do\n+            --        If_Exp_Res : Typ;\n+            --        if Cond then\n+            --           Lvl        := 0; --  Access level\n+            --           If_Exp_Res := Exp;\n+            --        ...\n+            --      in If_Exp_Res end;},\n+            --      Lvl,\n+            --      ...\n+            --    )\n+\n+            Insert_Before_And_Analyze (Call_Node, Decl);\n+\n+         --  A function call must be transformed into an expression with\n+         --  actions.\n+\n+         else\n+            --  Generate:\n+            --    do\n+            --      Lvl : Natural;\n+            --    in Call (do{\n+            --               If_Exp_Res : Typ\n+            --               if Cond then\n+            --                 Lvl := 0; --  Access level\n+            --                 If_Exp_Res := Exp;\n+            --               in If_Exp_Res end;},\n+            --             Lvl,\n+            --             ...\n+            --             )\n+            --    end;\n+\n+            Res  := Make_Temporary (Loc, 'R');\n+            Typ  := Etype (Call_Node);\n+            Temp := Relocate_Node (Call_Node);\n+\n+            --  Perform the rewrite with the dummy\n+\n+            Rewrite (Call_Node,\n+\n+              Make_Expression_With_Actions (Loc,\n+                Expression => New_Occurrence_Of (Res, Loc),\n+                Actions    => New_List (\n+                  Decl,\n+\n+                  Make_Object_Declaration (Loc,\n+                    Defining_Identifier => Res,\n+                    Object_Definition   =>\n+                      New_Occurrence_Of (Typ, Loc)))));\n+\n+            --  Analyze the expression with the dummy\n+\n+            Analyze_And_Resolve (Call_Node, Typ);\n+\n+            --  Properly set the expression and move our view of the call node\n+\n+            Set_Expression (Call_Node, Relocate_Node (Temp));\n+            Call_Node := Expression (Call_Node);\n+\n+            --  Remove the declaration of the dummy and the subsequent actions\n+            --  its analysis has created.\n+\n+            while Present (Remove_Next (Decl)) loop\n+               null;\n+            end loop;\n+         end if;\n+\n+         --  Decorate the conditional expression with assignments to our level\n+         --  temporary.\n+\n+         Insert_Level_Assign (Prev);\n+\n+         --  Make our level temporary the passed actual\n+\n+         Add_Extra_Actual\n+           (Expr => New_Occurrence_Of (Lvl, Loc),\n+            EF   => Extra_Accessibility (Formal));\n+      end Add_Cond_Expression_Extra_Actual;\n+\n       ----------------------\n       -- Add_Extra_Actual --\n       ----------------------\n@@ -3300,7 +3515,6 @@ package body Exp_Ch6 is\n       Param_Count   : Positive;\n       Parent_Formal : Entity_Id;\n       Parent_Subp   : Entity_Id;\n-      Prev_Ult      : Node_Id;\n       Scop          : Entity_Id;\n       Subp          : Entity_Id;\n \n@@ -3751,417 +3965,20 @@ package body Exp_Ch6 is\n                      EF   => Extra_Accessibility (Formal));\n                end;\n \n-            elsif Is_Entity_Name (Prev_Orig) then\n-\n-               --  When passing an access parameter, or a renaming of an access\n-               --  parameter, as the actual to another access parameter we need\n-               --  to pass along the actual's own access level parameter. This\n-               --  is done if we are within the scope of the formal access\n-               --  parameter (if this is an inlined body the extra formal is\n-               --  irrelevant).\n-\n-               if (Is_Formal (Entity (Prev_Orig))\n-                    or else\n-                      (Present (Renamed_Object (Entity (Prev_Orig)))\n-                        and then\n-                          Is_Entity_Name (Renamed_Object (Entity (Prev_Orig)))\n-                        and then\n-                          Is_Formal\n-                            (Entity (Renamed_Object (Entity (Prev_Orig))))))\n-                 and then Ekind (Etype (Prev_Orig)) = E_Anonymous_Access_Type\n-                 and then In_Open_Scopes (Scope (Entity (Prev_Orig)))\n-               then\n-                  declare\n-                     Parm_Ent : constant Entity_Id := Param_Entity (Prev_Orig);\n-\n-                  begin\n-                     pragma Assert (Present (Parm_Ent));\n-\n-                     if Present (Get_Accessibility (Parm_Ent)) then\n-                        Add_Extra_Actual\n-                          (Expr =>\n-                             New_Occurrence_Of\n-                               (Get_Accessibility (Parm_Ent), Loc),\n-                           EF   => Extra_Accessibility (Formal));\n-\n-                     --  If the actual access parameter does not have an\n-                     --  associated extra formal providing its scope level,\n-                     --  then treat the actual as having library-level\n-                     --  accessibility.\n-\n-                     else\n-                        Add_Extra_Actual\n-                          (Expr =>\n-                             Make_Integer_Literal (Loc,\n-                               Intval => Scope_Depth (Standard_Standard)),\n-                           EF   => Extra_Accessibility (Formal));\n-                     end if;\n-                  end;\n-\n-               --  The actual is a normal access value, so just pass the level\n-               --  of the actual's access type.\n-\n-               else\n-                  Add_Extra_Actual\n-                    (Expr => Dynamic_Accessibility_Level (Prev_Orig),\n-                     EF   => Extra_Accessibility (Formal));\n-               end if;\n-\n-            --  If the actual is an access discriminant, then pass the level\n-            --  of the enclosing object (RM05-3.10.2(12.4/2)).\n+            --  Conditional expressions\n \n-            elsif Nkind (Prev_Orig) = N_Selected_Component\n-              and then Ekind (Entity (Selector_Name (Prev_Orig))) =\n-                                                       E_Discriminant\n-              and then Ekind (Etype (Entity (Selector_Name (Prev_Orig)))) =\n-                                                       E_Anonymous_Access_Type\n+            elsif Nkind (Prev) = N_Expression_With_Actions\n+                   and then Nkind (Original_Node (Prev)) in\n+                              N_If_Expression | N_Case_Expression\n             then\n-               Add_Extra_Actual\n-                 (Expr =>\n-                    Make_Integer_Literal (Loc,\n-                      Intval => Object_Access_Level (Prefix (Prev_Orig))),\n-                  EF   => Extra_Accessibility (Formal));\n+               Add_Cond_Expression_Extra_Actual (Formal);\n \n-            --  All other cases\n+            --  Normal case\n \n             else\n-               case Nkind (Prev_Orig) is\n-                  when N_Attribute_Reference =>\n-                     case Get_Attribute_Id (Attribute_Name (Prev_Orig)) is\n-                        --  Ignore 'Result, 'Loop_Entry, and 'Old as they can\n-                        --  be used to identify access objects and do not have\n-                        --  an effect on accessibility level.\n-\n-                        when Attribute_Loop_Entry\n-                           | Attribute_Old\n-                           | Attribute_Result\n-                        =>\n-                           null;\n-\n-                        --  For X'Access, pass on the level of the prefix X\n-\n-                        when Attribute_Access =>\n-\n-                           --  Accessibility level of S'Access is that of A\n-\n-                           Prev_Orig := Prefix (Prev_Orig);\n-\n-                           --  If the expression is a view conversion, the\n-                           --  accessibility level is that of the expression.\n-\n-                           if Nkind (Original_Node (Prev_Orig)) =\n-                                N_Type_Conversion\n-                             and then\n-                               Nkind (Expression (Original_Node (Prev_Orig))) =\n-                                 N_Explicit_Dereference\n-                           then\n-                              Prev_Orig :=\n-                                Expression (Original_Node (Prev_Orig));\n-                           end if;\n-\n-                           --  Obtain the ultimate prefix so we can check for\n-                           --  the case where we are taking 'Access of a\n-                           --  component of an anonymous access formal - which\n-                           --  would mean we need to pass said formal's\n-                           --  corresponding extra accessibility formal.\n-\n-                           Prev_Ult := Ultimate_Prefix (Prev_Orig);\n-\n-                           if Is_Entity_Name (Prev_Ult)\n-                             and then not Is_Type (Entity (Prev_Ult))\n-                             and then Present\n-                                        (Get_Accessibility\n-                                          (Entity (Prev_Ult)))\n-                           then\n-                              Add_Extra_Actual\n-                                (Expr =>\n-                                   New_Occurrence_Of\n-                                     (Get_Accessibility\n-                                        (Entity (Prev_Ult)), Loc),\n-                                 EF   => Extra_Accessibility (Formal));\n-\n-                           --  Normal case, call Object_Access_Level. Note:\n-                           --  should be Dynamic_Accessibility_Level ???\n-\n-                           else\n-                              Add_Extra_Actual\n-                                (Expr =>\n-                                   Make_Integer_Literal (Loc,\n-                                     Intval =>\n-                                       Object_Access_Level (Prev_Orig)),\n-                                 EF   => Extra_Accessibility (Formal));\n-                           end if;\n-\n-                        --  Treat the unchecked attributes as library-level\n-\n-                        when Attribute_Unchecked_Access\n-                           | Attribute_Unrestricted_Access\n-                        =>\n-                           Add_Extra_Actual\n-                             (Expr =>\n-                                Make_Integer_Literal (Loc,\n-                                  Intval => Scope_Depth (Standard_Standard)),\n-                              EF   => Extra_Accessibility (Formal));\n-\n-                        --  No other cases of attributes returning access\n-                        --  values that can be passed to access parameters.\n-\n-                        when others =>\n-                           raise Program_Error;\n-\n-                     end case;\n-\n-                  --  For allocators we pass the level of the execution of the\n-                  --  called subprogram, which is one greater than the current\n-                  --  scope level. However, according to RM 3.10.2(14/3) this\n-                  --  is wrong since for an anonymous allocator defining the\n-                  --  value of an access parameter, the accessibility level is\n-                  --  that of the innermost master of the call???\n-\n-                  when N_Allocator =>\n-                     Add_Extra_Actual\n-                       (Expr =>\n-                          Make_Integer_Literal (Loc,\n-                            Intval => Scope_Depth (Current_Scope) + 1),\n-                        EF   => Extra_Accessibility (Formal));\n-\n-                  --  For most other cases we simply pass the level of the\n-                  --  actual's access type. The type is retrieved from\n-                  --  Prev rather than Prev_Orig, because in some cases\n-                  --  Prev_Orig denotes an original expression that has\n-                  --  not been analyzed.\n-\n-                  --  However, when the actual is wrapped in a conditional\n-                  --  expression we must add a local temporary to store the\n-                  --  level at each branch, and, possibly, expand the call\n-                  --  into an expression with actions.\n-\n-                  when others =>\n-                     if Nkind (Prev) = N_Expression_With_Actions\n-                       and then Nkind (Original_Node (Prev)) in\n-                                  N_If_Expression | N_Case_Expression\n-                     then\n-                        declare\n-                           Decl : Node_Id;\n-                           pragma Warnings (Off, Decl);\n-                           --  Suppress warning for the final removal loop\n-                           Lvl  : Entity_Id;\n-                           Res  : Entity_Id;\n-                           Temp : Node_Id;\n-                           Typ  : Node_Id;\n-\n-                           procedure Insert_Level_Assign (Branch : Node_Id);\n-                           --  Recursivly add assignment of the level temporary\n-                           --  on each branch while moving through nested\n-                           --  conditional expressions.\n-\n-                           -------------------------\n-                           -- Insert_Level_Assign --\n-                           -------------------------\n-\n-                           procedure Insert_Level_Assign (Branch : Node_Id) is\n-\n-                              procedure Expand_Branch (Res_Assn : Node_Id);\n-                              --  Perform expansion or iterate further within\n-                              --  nested conditionals given the object\n-                              --  declaration or assignment to result object\n-                              --  created during expansion which represents\n-                              --  a branch of the conditional expression.\n-\n-                              -------------------\n-                              -- Expand_Branch --\n-                              -------------------\n-\n-                              procedure Expand_Branch (Res_Assn : Node_Id) is\n-                              begin\n-                                 pragma Assert (Nkind (Res_Assn) in\n-                                                 N_Assignment_Statement |\n-                                                 N_Object_Declaration);\n-\n-                                 --  There are more nested conditional\n-                                 --  expressions so we must go deeper.\n-\n-                                 if Nkind (Expression (Res_Assn)) =\n-                                      N_Expression_With_Actions\n-                                   and then\n-                                     Nkind\n-                                       (Original_Node (Expression (Res_Assn)))\n-                                         in N_Case_Expression | N_If_Expression\n-                                 then\n-                                    Insert_Level_Assign\n-                                      (Expression (Res_Assn));\n-\n-                                 --  Add the level assignment\n-\n-                                 else\n-                                    Insert_Before_And_Analyze (Res_Assn,\n-                                      Make_Assignment_Statement (Loc,\n-                                        Name       =>\n-                                          New_Occurrence_Of\n-                                            (Lvl, Loc),\n-                                        Expression =>\n-                                          Dynamic_Accessibility_Level\n-                                            (Expression (Res_Assn))));\n-                                 end if;\n-                              end Expand_Branch;\n-\n-                              Cond : Node_Id;\n-                              Alt  : Node_Id;\n-\n-                           --  Start of processing for Insert_Level_Assign\n-\n-                           begin\n-                              --  Examine further nested condtionals\n-\n-                              pragma Assert (Nkind (Branch) =\n-                                              N_Expression_With_Actions);\n-\n-                              --  Find the relevant statement in the actions\n-\n-                              Cond := First (Actions (Branch));\n-                              while Present (Cond) loop\n-                                 exit when Nkind (Cond) in\n-                                             N_Case_Statement | N_If_Statement;\n-\n-                                 Next (Cond);\n-                              end loop;\n-\n-                              --  The conditional expression may have been\n-                              --  optimized away, so examine the actions in\n-                              --  the branch.\n-\n-                              if No (Cond) then\n-                                 Expand_Branch (Last (Actions (Branch)));\n-\n-                              --  Iterate through if expression branches\n-\n-                              elsif Nkind (Cond) = N_If_Statement then\n-                                 Expand_Branch (Last (Then_Statements (Cond)));\n-                                 Expand_Branch (Last (Else_Statements (Cond)));\n-\n-                              --  Iterate through case alternatives\n-\n-                              elsif Nkind (Cond) = N_Case_Statement then\n-\n-                                 Alt := First (Alternatives (Cond));\n-                                 while Present (Alt) loop\n-                                    Expand_Branch (Last (Statements (Alt)));\n-\n-                                    Next (Alt);\n-                                 end loop;\n-                              end if;\n-                           end Insert_Level_Assign;\n-\n-                        --  Start of processing for cond expression case\n-\n-                        begin\n-                           --  Create declaration of a temporary to store the\n-                           --  accessibility level of each branch of the\n-                           --  conditional expression.\n-\n-                           Lvl  := Make_Temporary (Loc, 'L');\n-                           Decl :=\n-                              Make_Object_Declaration (Loc,\n-                                Defining_Identifier => Lvl,\n-                                Object_Definition   =>\n-                                  New_Occurrence_Of (Standard_Natural, Loc));\n-\n-                           --  Install the declaration and perform necessary\n-                           --  expansion if we are dealing with a function\n-                           --  call.\n-\n-                           if Nkind (Call_Node) = N_Procedure_Call_Statement\n-                           then\n-                              --  Generate:\n-                              --    Lvl : Natural;\n-                              --    Call (\n-                              --     {do\n-                              --        If_Exp_Res : Typ;\n-                              --        if Cond then\n-                              --           Lvl        := 0; --  Access level\n-                              --           If_Exp_Res := Exp;\n-                              --        ...\n-                              --      in If_Exp_Res end;},\n-                              --      Lvl,\n-                              --      ...\n-                              --    )\n-\n-                              Insert_Before_And_Analyze (Call_Node, Decl);\n-\n-                           --  A function call must be transformed into an\n-                           --  expression with actions.\n-\n-                           else\n-                              --  Generate:\n-                              --    do\n-                              --      Lvl : Natural;\n-                              --    in Call (do{\n-                              --               If_Exp_Res : Typ\n-                              --               if Cond then\n-                              --                 Lvl := 0; --  Access level\n-                              --                 If_Exp_Res := Exp;\n-                              --               in If_Exp_Res end;},\n-                              --             Lvl,\n-                              --             ...\n-                              --             )\n-                              --    end;\n-\n-                              Res  := Make_Temporary (Loc, 'R');\n-                              Typ  := Etype (Call_Node);\n-                              Temp := Relocate_Node (Call_Node);\n-\n-                              --  Perform the rewrite with the dummy\n-\n-                              Rewrite (Call_Node,\n-\n-                                Make_Expression_With_Actions (Loc,\n-                                  Expression => New_Occurrence_Of (Res, Loc),\n-                                  Actions    => New_List (\n-                                    Decl,\n-\n-                                    Make_Object_Declaration (Loc,\n-                                      Defining_Identifier => Res,\n-                                      Object_Definition   =>\n-                                        New_Occurrence_Of (Typ, Loc)))));\n-\n-                              --  Analyze the expression with the dummy\n-\n-                              Analyze_And_Resolve (Call_Node, Typ);\n-\n-                              --  Properly set the expression and move our view\n-                              --  of the call node\n-\n-                              Set_Expression (Call_Node, Relocate_Node (Temp));\n-                              Call_Node := Expression (Call_Node);\n-\n-                              --  Remove the declaration of the dummy and the\n-                              --  subsequent actions its analysis has created.\n-\n-                              while Present (Remove_Next (Decl)) loop\n-                                 null;\n-                              end loop;\n-                           end if;\n-\n-                           --  Decorate the conditional expression with\n-                           --  assignments to our level temporary.\n-\n-                           Insert_Level_Assign (Prev);\n-\n-                           --  Make our level temporary the passed actual\n-\n-                           Add_Extra_Actual\n-                             (Expr => New_Occurrence_Of (Lvl, Loc),\n-                              EF   => Extra_Accessibility (Formal));\n-                        end;\n-\n-                     --  General case uncomplicated by conditional expressions\n-\n-                     else\n-                        Add_Extra_Actual\n-                          (Expr => Dynamic_Accessibility_Level (Prev),\n-                           EF   => Extra_Accessibility (Formal));\n-                     end if;\n-               end case;\n+               Add_Extra_Actual\n+                 (Expr => Dynamic_Accessibility_Level (Prev),\n+                  EF   => Extra_Accessibility (Formal));\n             end if;\n          end if;\n \n@@ -4447,7 +4264,7 @@ package body Exp_Ch6 is\n                      else\n                         Level :=\n                           Make_Integer_Literal (Loc,\n-                            Intval => Object_Access_Level (Def_Id));\n+                            Intval => Static_Accessibility_Level (Def_Id));\n                      end if;\n                   end;\n \n@@ -7838,190 +7655,8 @@ package body Exp_Ch6 is\n       if Is_Special_Aliased_Formal_Access (Exp, Scope_Id) then\n          Check_Against_Result_Level\n            (Make_Integer_Literal (Loc,\n-             Object_Access_Level (Entity (Ultimate_Prefix (Prefix (Exp))))));\n-      end if;\n-\n-      --  AI05-0234: Check unconstrained access discriminants to ensure\n-      --  that the result does not outlive an object designated by one\n-      --  of its discriminants (RM 6.5(21/3)).\n-\n-      if Present (Extra_Accessibility_Of_Result (Scope_Id))\n-        and then Has_Unconstrained_Access_Discriminants (R_Type)\n-      then\n-         declare\n-            Discrim_Source : Node_Id;\n-         begin\n-            Discrim_Source := Exp;\n-            while Nkind (Discrim_Source) = N_Qualified_Expression loop\n-               Discrim_Source := Expression (Discrim_Source);\n-            end loop;\n-\n-            if Nkind (Discrim_Source) = N_Identifier\n-              and then Is_Return_Object (Entity (Discrim_Source))\n-            then\n-               Discrim_Source := Entity (Discrim_Source);\n-\n-               if Is_Constrained (Etype (Discrim_Source)) then\n-                  Discrim_Source := Etype (Discrim_Source);\n-               else\n-                  Discrim_Source := Expression (Parent (Discrim_Source));\n-               end if;\n-\n-            elsif Nkind (Discrim_Source) = N_Identifier\n-              and then Nkind (Original_Node (Discrim_Source)) in\n-                         N_Aggregate | N_Extension_Aggregate\n-            then\n-               Discrim_Source := Original_Node (Discrim_Source);\n-\n-            elsif Nkind (Discrim_Source) = N_Explicit_Dereference and then\n-              Nkind (Original_Node (Discrim_Source)) = N_Function_Call\n-            then\n-               Discrim_Source := Original_Node (Discrim_Source);\n-            end if;\n-\n-            Discrim_Source := Unqual_Conv (Discrim_Source);\n-\n-            case Nkind (Discrim_Source) is\n-               when N_Defining_Identifier =>\n-                  pragma Assert (Is_Composite_Type (Discrim_Source)\n-                                  and then Has_Discriminants (Discrim_Source)\n-                                  and then Is_Constrained (Discrim_Source));\n-\n-                  declare\n-                     Discrim   : Entity_Id :=\n-                                   First_Discriminant (Base_Type (R_Type));\n-                     Disc_Elmt : Elmt_Id   :=\n-                                   First_Elmt (Discriminant_Constraint\n-                                                 (Discrim_Source));\n-                  begin\n-                     loop\n-                        if Ekind (Etype (Discrim)) =\n-                             E_Anonymous_Access_Type\n-                        then\n-                           Check_Against_Result_Level\n-                             (Dynamic_Accessibility_Level (Node (Disc_Elmt)));\n-                        end if;\n-\n-                        Next_Elmt (Disc_Elmt);\n-                        Next_Discriminant (Discrim);\n-                        exit when not Present (Discrim);\n-                     end loop;\n-                  end;\n-\n-               when N_Aggregate\n-                  | N_Extension_Aggregate\n-               =>\n-                  --  Unimplemented: extension aggregate case where discrims\n-                  --  come from ancestor part, not extension part.\n-\n-                  declare\n-                     Discrim  : Entity_Id :=\n-                                  First_Discriminant (Base_Type (R_Type));\n-\n-                     Disc_Exp : Node_Id   := Empty;\n-\n-                     Positionals_Exhausted\n-                              : Boolean   := not Present (Expressions\n-                                                            (Discrim_Source));\n-\n-                     function Associated_Expr\n-                       (Comp_Id : Entity_Id;\n-                        Associations : List_Id) return Node_Id;\n-\n-                     --  Given a component and a component associations list,\n-                     --  locate the expression for that component; returns\n-                     --  Empty if no such expression is found.\n-\n-                     ---------------------\n-                     -- Associated_Expr --\n-                     ---------------------\n-\n-                     function Associated_Expr\n-                       (Comp_Id : Entity_Id;\n-                        Associations : List_Id) return Node_Id\n-                     is\n-                        Assoc  : Node_Id;\n-                        Choice : Node_Id;\n-\n-                     begin\n-                        --  Simple linear search seems ok here\n-\n-                        Assoc := First (Associations);\n-                        while Present (Assoc) loop\n-                           Choice := First (Choices (Assoc));\n-                           while Present (Choice) loop\n-                              if (Nkind (Choice) = N_Identifier\n-                                   and then Chars (Choice) = Chars (Comp_Id))\n-                                or else (Nkind (Choice) = N_Others_Choice)\n-                              then\n-                                 return Expression (Assoc);\n-                              end if;\n-\n-                              Next (Choice);\n-                           end loop;\n-\n-                           Next (Assoc);\n-                        end loop;\n-\n-                        return Empty;\n-                     end Associated_Expr;\n-\n-                  begin\n-                     if not Positionals_Exhausted then\n-                        Disc_Exp := First (Expressions (Discrim_Source));\n-                     end if;\n-\n-                     loop\n-                        if Positionals_Exhausted then\n-                           Disc_Exp :=\n-                             Associated_Expr\n-                               (Discrim,\n-                                Component_Associations (Discrim_Source));\n-                        end if;\n-\n-                        if Ekind (Etype (Discrim)) =\n-                             E_Anonymous_Access_Type\n-                        then\n-                           Check_Against_Result_Level\n-                             (Dynamic_Accessibility_Level (Disc_Exp));\n-                        end if;\n-\n-                        Next_Discriminant (Discrim);\n-                        exit when not Present (Discrim);\n-\n-                        if not Positionals_Exhausted then\n-                           Next (Disc_Exp);\n-                           Positionals_Exhausted := not Present (Disc_Exp);\n-                        end if;\n-                     end loop;\n-                  end;\n-\n-               when N_Function_Call =>\n-\n-                  --  No check needed (check performed by callee)\n-\n-                  null;\n-\n-               when others =>\n-                  declare\n-                     Level : constant Node_Id :=\n-                               Make_Integer_Literal (Loc,\n-                                 Object_Access_Level (Discrim_Source));\n-\n-                  begin\n-                     --  Unimplemented: check for name prefix that includes\n-                     --  a dereference of an access value with a dynamic\n-                     --  accessibility level (e.g., an access param or a\n-                     --  saooaaat) and use dynamic level in that case. For\n-                     --  example:\n-                     --    return Access_Param.all(Some_Index).Some_Component;\n-                     --  ???\n-\n-                     Set_Etype (Level, Standard_Natural);\n-                     Check_Against_Result_Level (Level);\n-                  end;\n-            end case;\n-         end;\n+             Static_Accessibility_Level\n+               (Entity (Ultimate_Prefix (Prefix (Exp))))));\n       end if;\n \n       --  If we are returning a nonscalar object that is possibly unaligned,"}, {"sha": "2b05d8acff8200bc2b98c905a6186c206cd2ab2a", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=d7e20130650fb46d71e0403652e4e07bc14f9775", "patch": "@@ -32,7 +32,6 @@ with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Aggr; use Exp_Aggr;\n-with Exp_Ch2;  use Exp_Ch2;\n with Exp_Ch6;  use Exp_Ch6;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Ch11; use Exp_Ch11;"}, {"sha": "017a0a1abf8e80668abec7e88ee9a5b1a2387f0c", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=d7e20130650fb46d71e0403652e4e07bc14f9775", "patch": "@@ -2810,7 +2810,7 @@ package body Ch3 is\n          --  end if;\n \n          Set_Subtype_Indication     (CompDef_Node, Empty);\n-         Set_Aliased_Present        (CompDef_Node, False);\n+         Set_Aliased_Present        (CompDef_Node, Aliased_Present);\n          Set_Access_Definition      (CompDef_Node,\n            P_Access_Definition (Not_Null_Present));\n       else"}, {"sha": "db34caef7de9e87080b7bbd054a892dffb5313e1", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=d7e20130650fb46d71e0403652e4e07bc14f9775", "patch": "@@ -11280,7 +11280,8 @@ package body Sem_Attr is\n                  and then not Is_Special_Aliased_Formal_Access\n                                 (N, Current_Scope)\n                  and then\n-                   Object_Access_Level (P) > Deepest_Type_Access_Level (Btyp)\n+                   Static_Accessibility_Level (P) >\n+                     Deepest_Type_Access_Level (Btyp)\n                then\n                   --  In an instance, this is a runtime check, but one we know\n                   --  will fail, so generate an appropriate warning. As usual,\n@@ -11424,7 +11425,8 @@ package body Sem_Attr is\n                if Attr_Id /= Attribute_Unchecked_Access\n                  and then Ekind (Btyp) = E_General_Access_Type\n                  and then\n-                   Object_Access_Level (P) > Deepest_Type_Access_Level (Btyp)\n+                   Static_Accessibility_Level (P)\n+                     > Deepest_Type_Access_Level (Btyp)\n                then\n                   Accessibility_Message;\n                   return;\n@@ -11445,7 +11447,8 @@ package body Sem_Attr is\n                --  anonymous_access_to_protected, there are no accessibility\n                --  checks either. Omit check entirely for Unrestricted_Access.\n \n-               elsif Object_Access_Level (P) > Deepest_Type_Access_Level (Btyp)\n+               elsif Static_Accessibility_Level (P)\n+                       > Deepest_Type_Access_Level (Btyp)\n                  and then Comes_From_Source (N)\n                  and then Ekind (Btyp) = E_Access_Protected_Subprogram_Type\n                  and then Attr_Id /= Attribute_Unrestricted_Access"}, {"sha": "fbddfc9aaa08c90a83f357842e001e4623117f00", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=d7e20130650fb46d71e0403652e4e07bc14f9775", "patch": "@@ -7208,7 +7208,9 @@ package body Sem_Ch13 is\n \n                   --  check (B)\n \n-                  if Type_Access_Level (Ent) > Object_Access_Level (Pool) then\n+                  if Type_Access_Level (Ent)\n+                       > Static_Accessibility_Level (Pool)\n+                  then\n                      Error_Msg_N\n                        (\"subpool access type has deeper accessibility \"\n                         & \"level than pool\", Ent);"}, {"sha": "7d8156f45dfe5f20078fb2ec3f8104f8d66c11c6", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=d7e20130650fb46d71e0403652e4e07bc14f9775", "patch": "@@ -965,7 +965,7 @@ package body Sem_Ch6 is\n                   --  special logic above, and call Object_Access_Level with\n                   --  the original expression.\n \n-                  elsif Object_Access_Level (Expr) >\n+                  elsif Static_Accessibility_Level (Expr) >\n                           Scope_Depth (Scope (Scope_Id))\n                   then\n                      Error_Msg_N\n@@ -1436,7 +1436,7 @@ package body Sem_Ch6 is\n \n          if (Ada_Version < Ada_2005 or else Debug_Flag_Dot_L)\n            and then Is_Limited_View (Etype (Scope_Id))\n-           and then Object_Access_Level (Expr) >\n+           and then Static_Accessibility_Level (Expr) >\n                       Subprogram_Access_Level (Scope_Id)\n          then\n             --  Suppress the message in a generic, where the rewriting\n@@ -4718,7 +4718,7 @@ package body Sem_Ch6 is\n                                 Attribute_Name => Name_Min,\n                                 Expressions    => New_List (\n                                   Make_Integer_Literal (Loc,\n-                                    Object_Access_Level (Form)),\n+                                    Scope_Depth (Current_Scope)),\n                                   New_Occurrence_Of\n                                     (Extra_Accessibility (Form), Loc))));\n                      begin"}, {"sha": "8f0ac17b6a8194756f3acf094ee22a12d903b9ad", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=d7e20130650fb46d71e0403652e4e07bc14f9775", "patch": "@@ -2360,7 +2360,7 @@ package body Sem_Ch9 is\n          --  entry body) unless it is a parameter of the innermost enclosing\n          --  accept statement (or entry body).\n \n-         if Object_Access_Level (Target_Obj) >= Scope_Depth (Outer_Ent)\n+         if Static_Accessibility_Level (Target_Obj) >= Scope_Depth (Outer_Ent)\n            and then\n              (not Is_Entity_Name (Target_Obj)\n                or else not Is_Formal (Entity (Target_Obj))"}, {"sha": "3084012b4441d758230c9ccdf1b7827a0cdb51ce", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=d7e20130650fb46d71e0403652e4e07bc14f9775", "patch": "@@ -3499,16 +3499,16 @@ package body Sem_Res is\n \n             elsif Ekind (Etype (Nam)) = E_Anonymous_Access_Type then\n                if Nkind (Parent (N)) = N_Type_Conversion\n-                 and then Type_Access_Level (Etype (Parent (N))) <\n-                                                        Object_Access_Level (A)\n+                 and then Type_Access_Level (Etype (Parent (N)))\n+                            < Static_Accessibility_Level (A)\n                then\n                   Error_Msg_N (\"aliased actual has wrong accessibility\", A);\n                end if;\n \n             elsif Nkind (Parent (N)) = N_Qualified_Expression\n               and then Nkind (Parent (Parent (N))) = N_Allocator\n-              and then Type_Access_Level (Etype (Parent (Parent (N)))) <\n-                                                        Object_Access_Level (A)\n+              and then Type_Access_Level (Etype (Parent (Parent (N))))\n+                         < Static_Accessibility_Level (A)\n             then\n                Error_Msg_N\n                  (\"aliased actual in allocator has wrong accessibility\", A);\n@@ -5049,7 +5049,7 @@ package body Sem_Res is\n          elsif Nkind (Disc_Exp) = N_Attribute_Reference\n            and then Get_Attribute_Id (Attribute_Name (Disc_Exp)) =\n                       Attribute_Access\n-           and then Object_Access_Level (Prefix (Disc_Exp)) >\n+           and then Static_Accessibility_Level (Prefix (Disc_Exp)) >\n                       Deepest_Type_Access_Level (Alloc_Typ)\n          then\n             Error_Msg_N\n@@ -5061,7 +5061,7 @@ package body Sem_Res is\n \n          elsif Ekind (Etype (Disc_Exp)) = E_Anonymous_Access_Type\n            and then Nkind (Disc_Exp) = N_Selected_Component\n-           and then Object_Access_Level (Prefix (Disc_Exp)) >\n+           and then Static_Accessibility_Level (Prefix (Disc_Exp)) >\n                       Deepest_Type_Access_Level (Alloc_Typ)\n          then\n             Error_Msg_N\n@@ -13343,8 +13343,8 @@ package body Sem_Res is\n                --  checking the prefix of the operand for this case).\n \n                if Nkind (Operand) = N_Selected_Component\n-                 and then Object_Access_Level (Operand) >\n-                   Deepest_Type_Access_Level (Target_Type)\n+                 and then Static_Accessibility_Level (Operand)\n+                            > Deepest_Type_Access_Level (Target_Type)\n                then\n                   --  In an instance, this is a run-time check, but one we know\n                   --  will fail, so generate an appropriate warning. The raise\n@@ -13550,8 +13550,8 @@ package body Sem_Res is\n                --  checking the prefix of the operand for this case).\n \n                if Nkind (Operand) = N_Selected_Component\n-                 and then Object_Access_Level (Operand) >\n-                          Deepest_Type_Access_Level (Target_Type)\n+                 and then Static_Accessibility_Level (Operand)\n+                            > Deepest_Type_Access_Level (Target_Type)\n                then\n                   --  In an instance, this is a run-time check, but one we know\n                   --  will fail, so generate an appropriate warning. The raise"}, {"sha": "1115dfc2b0551bd6a13092e6212d4bf56ce3ae79", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 620, "deletions": 539, "changes": 1159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d7e20130650fb46d71e0403652e4e07bc14f9775", "patch": "@@ -32,6 +32,7 @@ with Debug;    use Debug;\n with Elists;   use Elists;\n with Errout;   use Errout;\n with Erroutc;  use Erroutc;\n+with Exp_Ch3;  use Exp_Ch3;\n with Exp_Ch11; use Exp_Ch11;\n with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n@@ -96,6 +97,11 @@ package body Sem_Util is\n    -- Local Subprograms --\n    -----------------------\n \n+   function Accessibility_Level_Helper\n+     (Expr   : Node_Id;\n+      Static : Boolean := False) return Node_Id;\n+   --  Unified static and dynamic accessibility level calculation subroutine\n+\n    function Build_Component_Subtype\n      (C   : List_Id;\n       Loc : Source_Ptr;\n@@ -265,6 +271,503 @@ package body Sem_Util is\n       return Interface_List (Nod);\n    end Abstract_Interface_List;\n \n+   --------------------------------\n+   -- Accessibility_Level_Helper --\n+   --------------------------------\n+\n+   function Accessibility_Level_Helper\n+     (Expr   : Node_Id;\n+      Static : Boolean := False) return Node_Id\n+   is\n+      Loc : constant Source_Ptr := Sloc (Expr);\n+\n+      function Make_Level_Literal (Level : Uint) return Node_Id;\n+      --  Construct an integer literal representing an accessibility level\n+      --  with its type set to Natural.\n+\n+      function Innermost_Master_Scope_Depth\n+        (N : Node_Id) return Uint;\n+      --  Returns the scope depth of the given node's innermost\n+      --  enclosing dynamic scope (effectively the accessibility\n+      --  level of the innermost enclosing master).\n+\n+      function Subprogram_Call_Level (Call_Ent : Entity_Id) return Node_Id;\n+      --  Centeralized processing of subprogram calls which may appear in\n+      --  prefix notation.\n+\n+      ----------------------------------\n+      -- Innermost_Master_Scope_Depth --\n+      ----------------------------------\n+\n+      function Innermost_Master_Scope_Depth\n+        (N : Node_Id) return Uint\n+      is\n+         Encl_Scop : Entity_Id;\n+         Node_Par  : Node_Id := Parent (N);\n+\n+      begin\n+         --  Locate the nearest enclosing node (by traversing Parents)\n+         --  that Defining_Entity can be applied to, and return the\n+         --  depth of that entity's nearest enclosing dynamic scope.\n+\n+         --  The rules which define what a master are are defined in\n+         --  RM 7.6.1 (3), and include statements and conditions for loops\n+         --  among other things. These cases are detected properly ???\n+\n+         while Present (Node_Par) loop\n+            if Present (Defining_Entity\n+                         (Node_Par, Empty_On_Errors => True))\n+            then\n+               Encl_Scop := Nearest_Dynamic_Scope\n+                              (Defining_Entity (Node_Par));\n+\n+               --  Ignore transient scopes made during expansion\n+\n+               if Comes_From_Source (Encl_Scop) then\n+                  return Scope_Depth (Encl_Scop);\n+               end if;\n+\n+            --  For a return statement within a function, return\n+            --  the depth of the function itself. This is not just\n+            --  a small optimization, but matters when analyzing\n+            --  the expression in an expression function before\n+            --  the body is created.\n+\n+            elsif Nkind (Node_Par) in N_Extended_Return_Statement\n+                                    | N_Simple_Return_Statement\n+              and then Ekind (Current_Scope) = E_Function\n+            then\n+               return Scope_Depth (Current_Scope);\n+            end if;\n+\n+            Node_Par := Parent (Node_Par);\n+         end loop;\n+\n+         pragma Assert (False);\n+\n+         --  Should never reach the following return\n+\n+         return Scope_Depth (Current_Scope) + 1;\n+      end Innermost_Master_Scope_Depth;\n+\n+      ------------------------\n+      -- Make_Level_Literal --\n+      ------------------------\n+\n+      function Make_Level_Literal (Level : Uint) return Node_Id is\n+         Result : constant Node_Id := Make_Integer_Literal (Loc, Level);\n+\n+      begin\n+         Set_Etype (Result, Standard_Natural);\n+         return Result;\n+      end Make_Level_Literal;\n+\n+      ---------------------------\n+      -- Subprogram_Call_Level --\n+      ---------------------------\n+\n+      function Subprogram_Call_Level (Call_Ent : Entity_Id) return Node_Id is\n+      begin\n+         --  Results of functions are objects, so we either get the\n+         --  accessibility of the function or, in case of a call which is\n+         --  indirect, the level of the access to subprogram type.\n+\n+         --  This code looks wrong ???\n+\n+         if Ada_Version < Ada_2005 then\n+            if Is_Entity_Name (Name (Call_Ent)) then\n+               return Make_Level_Literal\n+                        (Subprogram_Access_Level (Entity (Name (Call_Ent))));\n+            else\n+               return Make_Level_Literal\n+                        (Type_Access_Level (Etype (Prefix (Name (Call_Ent)))));\n+            end if;\n+         end if;\n+\n+         --  Named access types have a designated level\n+\n+         if Is_Named_Access_Type (Etype (Call_Ent)) then\n+            return Make_Level_Literal (Type_Access_Level (Etype (Call_Ent)));\n+\n+         --  Otherwise, the level is that of the innermost master of the call,\n+         --  according to RM 3.10.2 (10.6/2).\n+\n+         --  Note: Expr is used here instead of Call_Ent since expansion may\n+         --  have taken place, and we need to ensure we can climb the parent\n+         --  chain.\n+\n+         else\n+            return Make_Level_Literal (Innermost_Master_Scope_Depth (Expr));\n+         end if;\n+      end Subprogram_Call_Level;\n+\n+      --  Local variables\n+\n+      E   : Entity_Id := Original_Node (Expr);\n+      Par : Node_Id;\n+      Pre : Node_Id;\n+\n+   --  Start of processing for Accessibility_Level_Helper\n+\n+   begin\n+      --  We could be looking at a reference to a formal due to the expansion\n+      --  of entries and other cases, so obtain the renaming if necessary.\n+\n+      if Present (Param_Entity (Expr)) then\n+         E := Param_Entity (Expr);\n+      end if;\n+\n+      --  Extract the entity\n+\n+      if Nkind (E) in N_Has_Entity and then Present (Entity (E)) then\n+         E := Entity (E);\n+\n+         --  Deal with a possible renaming of a private protected component\n+\n+         if Ekind (E) in E_Constant | E_Variable and then Is_Prival (E) then\n+            E := Prival_Link (E);\n+         end if;\n+      end if;\n+\n+      --  Perform the processing on the expression\n+\n+      case Nkind (E) is\n+         --  The level of an aggregate is that of the innermost master that\n+         --  evaluates it as defined in RM 3.10.2 (10/4).\n+\n+         when N_Aggregate =>\n+            return Make_Level_Literal (Innermost_Master_Scope_Depth (Expr));\n+\n+         --  The accessibility level is that of the access type, except for an\n+         --  anonymous allocators which have special rules defined in RM 3.10.2\n+         --  (14/3).\n+\n+         when N_Allocator =>\n+            --  Anonymous allocator\n+\n+            if Ekind (Etype (Expr)) = E_Anonymous_Access_Type then\n+               --  Hop up to find a relevant parent node\n+\n+               Par := Parent (Expr);\n+               while Present (Par) loop\n+                  exit when Nkind (Par) in N_Assignment_Statement\n+                                         | N_Object_Declaration\n+                                         | N_Subprogram_Call;\n+                  Par := Parent (Par);\n+               end loop;\n+\n+               --  Handle each of the static cases outlined in RM 3.10.2 (14)\n+\n+               case Nkind (Par) is\n+                  --  For an anonymous allocator whose type is that of a\n+                  --  stand-alone object of an anonymous access-to-object\n+                  --  type, the accessibility level is that of the\n+                  --  declaration of the stand-alone object.\n+\n+                  when N_Object_Declaration =>\n+                     return Make_Level_Literal\n+                              (Scope_Depth\n+                                (Scope (Defining_Identifier (Parent (Expr)))));\n+\n+                  --  In an assignment statement the level is that of the\n+                  --  object at the left-hand side.\n+\n+                  when N_Assignment_Statement =>\n+                     return Make_Level_Literal\n+                              (Scope_Depth\n+                                (Scope (Entity (Name (Parent (Expr))))));\n+\n+                  --  Subprogram calls have a level one deeper than the\n+                  --  nearest enclosing scope.\n+\n+                  when N_Subprogram_Call =>\n+                     return Make_Level_Literal\n+                              (Innermost_Master_Scope_Depth\n+                                (Parent (Expr)) + 1);\n+\n+                  --  Should never get here\n+\n+                  when others =>\n+                     declare\n+                        S : constant String :=\n+                              Node_Kind'Image (Nkind (Parent (Expr)));\n+                     begin\n+                        Error_Msg_Strlen := S'Length;\n+                        Error_Msg_String (1 .. Error_Msg_Strlen) := S;\n+                        Error_Msg_N\n+                          (\"unsupported context for anonymous allocator (~)\",\n+                           Parent (Expr));\n+                     end;\n+\n+                     --  Return standard in case of error\n+\n+                     return Make_Level_Literal\n+                              (Scope_Depth (Standard_Standard));\n+               end case;\n+\n+            --  Normal case of a named access type\n+\n+            else\n+               return Make_Level_Literal\n+                        (Type_Access_Level (Etype (Expr)));\n+            end if;\n+\n+         --  We could reach this point for two reasons. Either the expression\n+         --  applies to a special attribute ('Loop_Entry, 'Result, or 'Old), or\n+         --  we are looking at the access attributes directly ('Access,\n+         --  'Address, or 'Unchecked_Access).\n+\n+         when N_Attribute_Reference =>\n+            Pre := Original_Node (Prefix (E));\n+\n+            --  Regular 'Access attribute presence means we have to look at the\n+            --  prefix.\n+\n+            if Attribute_Name (E) = Name_Access then\n+               return Accessibility_Level_Helper (Prefix (E), Static);\n+\n+            --  Unchecked or unrestricted attributes have unlimited depth\n+\n+            elsif Attribute_Name (E) in Name_Address\n+                                      | Name_Unchecked_Access\n+                                      | Name_Unrestricted_Access\n+            then\n+               return Make_Level_Literal (Scope_Depth (Standard_Standard));\n+\n+            --  'Access can be taken further against other special attributes,\n+            --  so handle these cases explicitly.\n+\n+            elsif Attribute_Name (E)\n+                    in Name_Old | Name_Loop_Entry | Name_Result\n+            then\n+               --  Named access types\n+\n+               if Is_Named_Access_Type (Etype (Pre)) then\n+                  return Make_Level_Literal\n+                           (Type_Access_Level (Etype (Pre)));\n+\n+               --  Anonymous access types\n+\n+               elsif Nkind (Pre) in N_Has_Entity\n+                 and then Present (Get_Accessibility (Entity (Pre)))\n+                 and then not Static\n+               then\n+                  return New_Occurrence_Of\n+                           (Get_Accessibility (Entity (Pre)), Loc);\n+\n+               --  Otherwise the level is treated in a similar way as\n+               --  aggregates according to RM 6.1.1 (35.1/4) which concerns\n+               --  an implicit constant declaration - in turn defining the\n+               --  accessibility level to be that of the implicit constant\n+               --  declaration.\n+\n+               else\n+                  return Make_Level_Literal\n+                           (Innermost_Master_Scope_Depth (Expr));\n+               end if;\n+\n+            else\n+               raise Program_Error;\n+            end if;\n+\n+         --  This is the \"base case\" for accessibility level calculations which\n+         --  means we are near the end of our recursive traversal.\n+\n+         when N_Defining_Identifier =>\n+            --  Stand-alone object of an anonymous access type \"SAOAAT\"\n+\n+            if (Is_Formal (E)\n+                 or else Ekind (E) in E_Variable\n+                                    | E_Constant)\n+              and then Present (Get_Accessibility (E))\n+              and then not Static\n+            then\n+               return\n+                 New_Occurrence_Of (Get_Accessibility (E), Loc);\n+\n+            --  Initialization procedures have a special extra accessitility\n+            --  parameter associated with the level at which the object\n+            --  begin initialized exists\n+\n+            elsif Ekind (E) = E_Record_Type\n+              and then Is_Limited_Record (E)\n+              and then Current_Scope = Init_Proc (E)\n+              and then Present (Init_Proc_Level_Formal (Current_Scope))\n+            then\n+               return New_Occurrence_Of\n+                        (Init_Proc_Level_Formal (Current_Scope), Loc);\n+\n+            --  Extra accessibility has not been added yet, but the formal\n+            --  needs one. So return Standard_Standard ???\n+\n+            elsif Ekind (Etype (E)) = E_Anonymous_Access_Type\n+              and then Static\n+            then\n+               return Make_Level_Literal (Scope_Depth (Standard_Standard));\n+\n+            --  Current instance of the type is deeper than that of the type\n+            --  according to RM 3.10.2 (21).\n+\n+            elsif Is_Type (E) then\n+               return Make_Level_Literal\n+                        (Type_Access_Level (E) + 1);\n+\n+            --  Move up the renamed entity if it came from source since\n+            --  expansion may have created a dummy renaming under certain\n+            --  circumstances.\n+\n+            elsif Present (Renamed_Object (E))\n+              and then Comes_From_Source (Renamed_Object (E))\n+            then\n+               return Accessibility_Level_Helper\n+                        (Renamed_Object (E), Static);\n+\n+            --  Named access types get their level from their associated type\n+\n+            elsif Is_Named_Access_Type (Etype (E)) then\n+               return Make_Level_Literal\n+                        (Type_Access_Level (Etype (E)));\n+\n+            --  When E is a component of the current instance of a\n+            --  protected type, we assume the level to be deeper than that of\n+            --  the type itself.\n+\n+            elsif not Is_Overloadable (E)\n+              and then Ekind (Scope (E)) = E_Protected_Type\n+              and then Comes_From_Source (Scope (E))\n+            then\n+               return Make_Level_Literal\n+                        (Scope_Depth (Enclosing_Dynamic_Scope (E)) + 1);\n+\n+            --  Normal object - get the level of the enclosing scope\n+\n+            else\n+               return Make_Level_Literal\n+                        (Scope_Depth (Enclosing_Dynamic_Scope (E)));\n+            end if;\n+\n+         --  Handle indexed and selected components including the special cases\n+         --  whereby there is an implicit dereference, a component of a\n+         --  composite type, or a function call in prefix notation.\n+\n+         --  We don't handle function calls in prefix notation correctly ???\n+\n+         when N_Indexed_Component | N_Selected_Component =>\n+            Pre := Original_Node (Prefix (E));\n+\n+            --  If the prefix is a named access type, then we are dealing\n+            --  with an implicit deferences. In that case the level is that\n+            --  of the named access type in the prefix.\n+\n+            if Is_Named_Access_Type (Etype (Pre)) then\n+               return Make_Level_Literal\n+                        (Type_Access_Level (Etype (Pre)));\n+\n+            --  The current expression is a named access type, so there is no\n+            --  reason to look at the prefix. Instead obtain the level of E's\n+            --  named access type.\n+\n+            elsif Is_Named_Access_Type (Etype (E)) then\n+               return Make_Level_Literal\n+                        (Type_Access_Level (Etype (E)));\n+\n+            --  A non-discriminant selected component where the component\n+            --  is an anonymous access type means that its associated\n+            --  level is that of the containing type - see RM 3.10.2 (16).\n+\n+            elsif Nkind (E) = N_Selected_Component\n+              and then Ekind (Etype (E))   =  E_Anonymous_Access_Type\n+              and then Ekind (Etype (Pre)) /= E_Anonymous_Access_Type\n+              and then not (Nkind (Selector_Name (E)) in N_Has_Entity\n+                             and then Ekind (Entity (Selector_Name (E)))\n+                                        = E_Discriminant)\n+            then\n+               return Make_Level_Literal\n+                        (Type_Access_Level (Etype (Prefix (E))));\n+\n+            --  Similar to the previous case - arrays featuring components of\n+            --  anonymous access components get their corresponding level from\n+            --  their containing type's declaration.\n+\n+            elsif Nkind (E) = N_Indexed_Component\n+              and then Ekind (Etype (E)) = E_Anonymous_Access_Type\n+              and then Ekind (Etype (Pre)) in Array_Kind\n+              and then Ekind (Component_Type (Base_Type (Etype (Pre))))\n+                         = E_Anonymous_Access_Type\n+            then\n+               return Make_Level_Literal\n+                        (Type_Access_Level (Etype (Prefix (E))));\n+\n+            --  Otherwise, continue recursing over the expression prefixes\n+\n+            else\n+               return Accessibility_Level_Helper (Prefix (E), Static);\n+            end if;\n+\n+         --  Qualified expressions\n+\n+         when N_Qualified_Expression =>\n+            if Is_Named_Access_Type (Etype (E)) then\n+               return Make_Level_Literal\n+                        (Type_Access_Level (Etype (E)));\n+            else\n+               return Accessibility_Level_Helper (Expression (E), Static);\n+            end if;\n+\n+         --  Handle function calls\n+\n+         when N_Function_Call =>\n+            return Subprogram_Call_Level (E);\n+\n+         --  Explicit dereference accessibility level calculation\n+\n+         when N_Explicit_Dereference =>\n+            Pre := Original_Node (Prefix (E));\n+\n+            --  The prefix is a named access type so the level is taken from\n+            --  its type.\n+\n+            if Is_Named_Access_Type (Etype (Pre)) then\n+               return Make_Level_Literal (Type_Access_Level (Etype (Pre)));\n+\n+            --  Otherwise, recurse deeper\n+\n+            else\n+               return Accessibility_Level_Helper (Prefix (E), Static);\n+            end if;\n+\n+         --  Type conversions\n+\n+         when N_Type_Conversion | N_Unchecked_Type_Conversion =>\n+            --  View conversions are special in that they require use to\n+            --  inspect the expression of the type conversion.\n+\n+            --  Allocators of anonymous access types are internally generated,\n+            --  so recurse deeper in that case as well.\n+\n+            if Is_View_Conversion (E)\n+              or else Ekind (Etype (E)) = E_Anonymous_Access_Type\n+            then\n+               return Accessibility_Level_Helper (Expression (E), Static);\n+\n+            --  In section RM 3.10.2 (10/4) the accessibility rules for\n+            --  aggregates and value conversions are outlined. Are these\n+            --  followed in the case of initialization of an object ???\n+\n+            --  Should use Innermost_Master_Scope_Depth ???\n+\n+            else\n+               return Accessibility_Level_Helper (Current_Scope, Static);\n+            end if;\n+\n+         --  Default to the type accessibility level for the type of the\n+         --  expression's entity.\n+\n+         when others =>\n+            return Make_Level_Literal (Type_Access_Level (Etype (E)));\n+      end case;\n+   end Accessibility_Level_Helper;\n+\n    ----------------------------------\n    -- Acquire_Warning_Match_String --\n    ----------------------------------\n@@ -4769,7 +5272,7 @@ package body Sem_Util is\n            and then No (Cont_Encl_Typ)\n            and then Is_Public_Operation\n            and then Scope_Depth (Pref_Encl_Typ) >=\n-                                       Object_Access_Level (Context)\n+                                       Static_Accessibility_Level (Context)\n          then\n             Error_Msg_N\n               (\"??possible unprotected access to protected data\", Expr);\n@@ -6243,9 +6746,9 @@ package body Sem_Util is\n       end if;\n    end Current_Subprogram;\n \n-   ----------------------------------\n+   -------------------------------\n    -- Deepest_Type_Access_Level --\n-   ----------------------------------\n+   -------------------------------\n \n    function Deepest_Type_Access_Level (Typ : Entity_Id) return Uint is\n    begin\n@@ -6276,7 +6779,10 @@ package body Sem_Util is\n    -- Defining_Entity --\n    ---------------------\n \n-   function Defining_Entity (N : Node_Id) return Entity_Id is\n+   function Defining_Entity\n+     (N               : Node_Id;\n+      Empty_On_Errors : Boolean := False) return Entity_Id\n+   is\n    begin\n       case Nkind (N) is\n          when N_Abstract_Subprogram_Declaration\n@@ -6375,6 +6881,10 @@ package body Sem_Util is\n             return Entity (Identifier (N));\n \n          when others =>\n+            if Empty_On_Errors then\n+               return Empty;\n+            end if;\n+\n             raise Program_Error;\n       end case;\n    end Defining_Entity;\n@@ -6896,197 +7406,9 @@ package body Sem_Util is\n    -- Dynamic_Accessibility_Level --\n    ---------------------------------\n \n-   function Dynamic_Accessibility_Level (N : Node_Id) return Node_Id is\n-      Loc : constant Source_Ptr := Sloc (N);\n-\n-      function Make_Level_Literal (Level : Uint) return Node_Id;\n-      --  Construct an integer literal representing an accessibility level\n-      --  with its type set to Natural.\n-\n-      ------------------------\n-      -- Make_Level_Literal --\n-      ------------------------\n-\n-      function Make_Level_Literal (Level : Uint) return Node_Id is\n-         Result : constant Node_Id := Make_Integer_Literal (Loc, Level);\n-\n-      begin\n-         Set_Etype (Result, Standard_Natural);\n-         return Result;\n-      end Make_Level_Literal;\n-\n-      --  Local variables\n-\n-      Expr : Node_Id := Original_Node (N);\n-      --  Expr references the original node because at this stage N may be the\n-      --  reference to a variable internally created by the frontend to remove\n-      --  side effects of an expression.\n-\n-      E    : Entity_Id;\n-\n-   --  Start of processing for Dynamic_Accessibility_Level\n-\n+   function Dynamic_Accessibility_Level (Expr : Node_Id) return Node_Id is\n    begin\n-      if Is_Entity_Name (Expr) then\n-         E := Entity (Expr);\n-\n-         if Present (Renamed_Object (E)) then\n-            return Dynamic_Accessibility_Level (Renamed_Object (E));\n-         end if;\n-\n-         if (Is_Formal (E)\n-              or else Ekind (E) in E_Variable | E_Constant)\n-           and then Present (Get_Accessibility (E))\n-         then\n-            return New_Occurrence_Of (Get_Accessibility (E), Loc);\n-         end if;\n-      end if;\n-\n-      --  Handle a constant-folded conditional expression by avoiding use of\n-      --  the original node.\n-\n-      if Nkind (Expr) in N_Case_Expression | N_If_Expression then\n-         Expr := N;\n-      end if;\n-\n-      --  Unimplemented: Ptr.all'Access, where Ptr has Extra_Accessibility ???\n-\n-      case Nkind (Expr) is\n-         --  It may be possible that we have an access object denoted by an\n-         --  attribute reference for 'Loop_Entry which may, in turn, have an\n-         --  indexed component representing a loop identifier.\n-\n-         --  In this case we must climb up the indexed component and set expr\n-         --  to the attribute reference so the rest of the machinery can\n-         --  operate as expected.\n-\n-         when N_Indexed_Component =>\n-            if Nkind (Prefix (Expr)) = N_Attribute_Reference\n-              and then Get_Attribute_Id (Attribute_Name (Prefix (Expr)))\n-                         = Attribute_Loop_Entry\n-            then\n-               Expr := Prefix (Expr);\n-            end if;\n-\n-         --  For access discriminant, the level of the enclosing object\n-\n-         when N_Selected_Component =>\n-            if Ekind (Entity (Selector_Name (Expr))) = E_Discriminant\n-              and then Ekind (Etype (Entity (Selector_Name (Expr)))) =\n-                                            E_Anonymous_Access_Type\n-            then\n-               return Make_Level_Literal (Object_Access_Level (Expr));\n-            end if;\n-\n-         when N_Attribute_Reference =>\n-            case Get_Attribute_Id (Attribute_Name (Expr)) is\n-\n-               --  Ignore 'Loop_Entry, 'Result, and 'Old as they can be used to\n-               --  identify access objects and do not have an effect on\n-               --  accessibility level.\n-\n-               when Attribute_Loop_Entry | Attribute_Old | Attribute_Result =>\n-                  null;\n-\n-               --  For X'Access, the level of the prefix X\n-\n-               when Attribute_Access =>\n-                  return Make_Level_Literal\n-                           (Object_Access_Level (Prefix (Expr)));\n-\n-               --  Treat the unchecked attributes as library-level\n-\n-               when Attribute_Unchecked_Access\n-                  | Attribute_Unrestricted_Access\n-               =>\n-                  return Make_Level_Literal (Scope_Depth (Standard_Standard));\n-\n-               --  No other access-valued attributes\n-\n-               when others =>\n-                  raise Program_Error;\n-            end case;\n-\n-         when N_Allocator =>\n-\n-            --  This is not fully implemented since it depends on context (see\n-            --  3.10.2(14/3-14.2/3). More work is needed in the following cases\n-            --\n-            --  1) For an anonymous allocator defining the value of an access\n-            --     parameter, the accessibility level is that of the innermost\n-            --     master of the call; however currently we pass the level of\n-            --     execution of the called subprogram, which is one greater\n-            --     than the current scope level (see Expand_Call_Helper).\n-            --\n-            --     For example, a statement is a master and a declaration is\n-            --     not a master; so we should not pass in the same level for\n-            --     the following cases:\n-            --\n-            --         function F (X : access Integer) return T is ... ;\n-            --         Decl : T := F (new Integer); -- level is off by one\n-            --      begin\n-            --         Decl := F (new Integer); -- we get this case right\n-            --\n-            --  2) For an anonymous allocator that defines the result of a\n-            --     function with an access result, the accessibility level is\n-            --     determined as though the allocator were in place of the call\n-            --     of the function. In the special case of a call that is the\n-            --     operand of a type conversion the level is that of the target\n-            --     access type of the conversion.\n-            --\n-            --  3) For an anonymous allocator defining an access discriminant\n-            --     the accessibility level is determined as follows:\n-            --       * for an allocator used to define the discriminant of an\n-            --         object, the level of the object\n-            --       * for an allocator used to define the constraint in a\n-            --         subtype_indication in any other context, the level of\n-            --         the master that elaborates the subtype_indication.\n-\n-            case Nkind (Parent (N)) is\n-               when N_Object_Declaration =>\n-\n-                  --  For an anonymous allocator whose type is that of a\n-                  --  stand-alone object of an anonymous access-to-object type,\n-                  --  the accessibility level is that of the declaration of the\n-                  --  stand-alone object.\n-\n-                  return\n-                    Make_Level_Literal\n-                      (Object_Access_Level\n-                         (Defining_Identifier (Parent (N))));\n-\n-               when N_Assignment_Statement =>\n-                  return\n-                    Make_Level_Literal\n-                      (Object_Access_Level (Name (Parent (N))));\n-\n-               when others =>\n-                  declare\n-                     S : constant String :=\n-                           Node_Kind'Image (Nkind (Parent (N)));\n-                  begin\n-                     Error_Msg_Strlen := S'Length;\n-                     Error_Msg_String (1 .. Error_Msg_Strlen) := S;\n-                     Error_Msg_N\n-                       (\"unsupported context for anonymous allocator (~)\",\n-                        Parent (N));\n-                  end;\n-            end case;\n-\n-         when N_Type_Conversion =>\n-            if not Is_Local_Anonymous_Access (Etype (Expr)) then\n-\n-               --  Handle type conversions introduced for a rename of an\n-               --  Ada 2012 stand-alone object of an anonymous access type.\n-\n-               return Dynamic_Accessibility_Level (Expression (Expr));\n-            end if;\n-\n-         when others =>\n-            null;\n-      end case;\n-\n-      return Make_Level_Literal (Type_Access_Level (Etype (Expr)));\n+      return Accessibility_Level_Helper (Expr);\n    end Dynamic_Accessibility_Level;\n \n    ------------------------\n@@ -19670,7 +19992,7 @@ package body Sem_Util is\n    function Is_View_Conversion (N : Node_Id) return Boolean is\n    begin\n       if Nkind (N) = N_Type_Conversion\n-        and then Nkind (Unqual_Conv (N)) in N_Expanded_Name | N_Identifier\n+        and then Nkind (Unqual_Conv (N)) in N_Has_Etype\n       then\n          if Is_Tagged_Type (Etype (N))\n            and then Is_Tagged_Type (Etype (Unqual_Conv (N)))\n@@ -24418,350 +24740,6 @@ package body Sem_Util is\n       return Num;\n    end Number_Of_Elements_In_Array;\n \n-   -------------------------\n-   -- Object_Access_Level --\n-   -------------------------\n-\n-   --  Returns the static accessibility level of the view denoted by Obj. Note\n-   --  that the value returned is the result of a call to Scope_Depth. Only\n-   --  scope depths associated with dynamic scopes can actually be returned.\n-   --  Since only relative levels matter for accessibility checking, the fact\n-   --  that the distance between successive levels of accessibility is not\n-   --  always one is immaterial (invariant: if level(E2) is deeper than\n-   --  level(E1), then Scope_Depth(E1) < Scope_Depth(E2)).\n-\n-   function Object_Access_Level (Obj : Node_Id) return Uint is\n-      function Is_Interface_Conversion (N : Node_Id) return Boolean;\n-      --  Determine whether N is a construct of the form\n-      --    Some_Type (Operand._tag'Address)\n-      --  This construct appears in the context of dispatching calls.\n-\n-      function Reference_To (Obj : Node_Id) return Node_Id;\n-      --  An explicit dereference is created when removing side effects from\n-      --  expressions for constraint checking purposes. In this case a local\n-      --  access type is created for it. The correct access level is that of\n-      --  the original source node. We detect this case by noting that the\n-      --  prefix of the dereference is created by an object declaration whose\n-      --  initial expression is a reference.\n-\n-      -----------------------------\n-      -- Is_Interface_Conversion --\n-      -----------------------------\n-\n-      function Is_Interface_Conversion (N : Node_Id) return Boolean is\n-      begin\n-         return Nkind (N) = N_Unchecked_Type_Conversion\n-           and then Nkind (Expression (N)) = N_Attribute_Reference\n-           and then Attribute_Name (Expression (N)) = Name_Address;\n-      end Is_Interface_Conversion;\n-\n-      ------------------\n-      -- Reference_To --\n-      ------------------\n-\n-      function Reference_To (Obj : Node_Id) return Node_Id is\n-         Pref : constant Node_Id := Prefix (Obj);\n-      begin\n-         if Is_Entity_Name (Pref)\n-           and then Nkind (Parent (Entity (Pref))) = N_Object_Declaration\n-           and then Present (Expression (Parent (Entity (Pref))))\n-           and then Nkind (Expression (Parent (Entity (Pref)))) = N_Reference\n-         then\n-            return (Prefix (Expression (Parent (Entity (Pref)))));\n-         else\n-            return Empty;\n-         end if;\n-      end Reference_To;\n-\n-      --  Local variables\n-\n-      E        : Entity_Id;\n-      Orig_Obj : Node_Id := Original_Node (Obj);\n-      Orig_Pre : Node_Id;\n-\n-   --  Start of processing for Object_Access_Level\n-\n-   begin\n-      --  In the case of an expanded implicit dereference we swap the original\n-      --  object to be the expanded conversion.\n-\n-      if Nkind (Obj) = N_Explicit_Dereference\n-        and then Nkind (Orig_Obj) /= N_Explicit_Dereference\n-      then\n-         Orig_Obj := Obj;\n-      end if;\n-\n-      --  Calculate the object node's accessibility level\n-\n-      if Nkind (Orig_Obj) = N_Defining_Identifier\n-        or else Is_Entity_Name (Orig_Obj)\n-      then\n-         if Nkind (Orig_Obj) = N_Defining_Identifier then\n-            E := Orig_Obj;\n-         else\n-            E := Entity (Orig_Obj);\n-         end if;\n-\n-         if Is_Prival (E) then\n-            E := Prival_Link (E);\n-         end if;\n-\n-         --  If E is a type then it denotes a current instance. For this case\n-         --  we add one to the normal accessibility level of the type to ensure\n-         --  that current instances are treated as always being deeper than\n-         --  than the level of any visible named access type (see 3.10.2(21)).\n-\n-         if Is_Type (E) then\n-            return Type_Access_Level (E) + 1;\n-\n-         elsif Present (Renamed_Object (E)) then\n-            return Object_Access_Level (Renamed_Object (E));\n-\n-         --  Similarly, if E is a component of the current instance of a\n-         --  protected type, any instance of it is assumed to be at a deeper\n-         --  level than the type. For a protected object (whose type is an\n-         --  anonymous protected type) its components are at the same level\n-         --  as the type itself.\n-\n-         elsif not Is_Overloadable (E)\n-           and then Ekind (Scope (E)) = E_Protected_Type\n-           and then Comes_From_Source (Scope (E))\n-         then\n-            return Type_Access_Level (Scope (E)) + 1;\n-\n-         --  An object of a named access type gets its level from its\n-         --  associated type.\n-\n-         elsif Is_Named_Access_Type (Etype (E)) then\n-            return Type_Access_Level (Etype (E));\n-\n-         else\n-            return Scope_Depth (Enclosing_Dynamic_Scope (E));\n-         end if;\n-\n-      elsif Nkind (Orig_Obj) in N_Indexed_Component | N_Selected_Component then\n-         Orig_Pre := Original_Node (Prefix (Orig_Obj));\n-\n-         if Is_Access_Type (Etype (Orig_Pre)) then\n-            return Type_Access_Level (Etype (Orig_Pre));\n-         else\n-            return Object_Access_Level (Prefix (Orig_Obj));\n-         end if;\n-\n-      elsif Nkind (Orig_Obj) = N_Explicit_Dereference then\n-         Orig_Pre := Original_Node (Prefix (Orig_Obj));\n-\n-         --  If the prefix is a selected access discriminant then we make a\n-         --  recursive call on the prefix, which will in turn check the level\n-         --  of the prefix object of the selected discriminant.\n-\n-         --  In Ada 2012, if the discriminant has implicit dereference and\n-         --  the context is a selected component, treat this as an object of\n-         --  unknown scope (see below). This is necessary in compile-only mode;\n-         --  otherwise expansion will already have transformed the prefix into\n-         --  a temporary.\n-\n-         if Nkind (Orig_Pre) = N_Selected_Component\n-           and then Ekind (Etype (Orig_Pre)) = E_Anonymous_Access_Type\n-           and then\n-             Ekind (Entity (Selector_Name (Orig_Pre))) = E_Discriminant\n-           and then\n-             (not Has_Implicit_Dereference\n-                    (Entity (Selector_Name (Orig_Pre)))\n-               or else Nkind (Parent (Obj)) /= N_Selected_Component)\n-         then\n-            return Object_Access_Level (Prefix (Orig_Obj));\n-\n-         --  Detect an interface conversion in the context of a dispatching\n-         --  call. Use the original form of the conversion to find the access\n-         --  level of the operand.\n-\n-         elsif Is_Interface (Etype (Orig_Obj))\n-           and then Is_Interface_Conversion (Orig_Pre)\n-           and then Nkind (Orig_Obj) = N_Type_Conversion\n-         then\n-            return Object_Access_Level (Orig_Obj);\n-\n-         elsif not Comes_From_Source (Orig_Obj) then\n-            declare\n-               Ref : constant Node_Id := Reference_To (Orig_Obj);\n-            begin\n-               if Present (Ref) then\n-                  return Object_Access_Level (Ref);\n-               else\n-                  return Type_Access_Level (Etype (Prefix (Orig_Obj)));\n-               end if;\n-            end;\n-\n-         else\n-            return Type_Access_Level (Etype (Prefix (Orig_Obj)));\n-         end if;\n-\n-      elsif Nkind (Orig_Obj) in N_Type_Conversion | N_Unchecked_Type_Conversion\n-      then\n-         return Object_Access_Level (Expression (Orig_Obj));\n-\n-      elsif Nkind (Orig_Obj) = N_Function_Call then\n-\n-         --  Function results are objects, so we get either the access level of\n-         --  the function or, in the case of an indirect call, the level of the\n-         --  access-to-subprogram type. (This code is used for Ada 95, but it\n-         --  looks wrong, because it seems that we should be checking the level\n-         --  of the call itself, even for Ada 95. However, using the Ada 2005\n-         --  version of the code causes regressions in several tests that are\n-         --  compiled with -gnat95. ???)\n-\n-         if Ada_Version < Ada_2005 then\n-            if Is_Entity_Name (Name (Orig_Obj)) then\n-               return Subprogram_Access_Level (Entity (Name (Orig_Obj)));\n-            else\n-               return Type_Access_Level (Etype (Prefix (Name (Orig_Obj))));\n-            end if;\n-\n-         --  For Ada 2005, the level of the result object of a function call is\n-         --  defined to be the level of the call's innermost enclosing master.\n-         --  We determine that by querying the depth of the innermost enclosing\n-         --  dynamic scope.\n-\n-         else\n-            Return_Master_Scope_Depth_Of_Call : declare\n-               function Innermost_Master_Scope_Depth\n-                 (N : Node_Id) return Uint;\n-               --  Returns the scope depth of the given node's innermost\n-               --  enclosing dynamic scope (effectively the accessibility\n-               --  level of the innermost enclosing master).\n-\n-               ----------------------------------\n-               -- Innermost_Master_Scope_Depth --\n-               ----------------------------------\n-\n-               function Innermost_Master_Scope_Depth\n-                 (N : Node_Id) return Uint\n-               is\n-                  Node_Par : Node_Id := Parent (N);\n-\n-               begin\n-                  --  Locate the nearest enclosing node (by traversing Parents)\n-                  --  that Defining_Entity can be applied to, and return the\n-                  --  depth of that entity's nearest enclosing dynamic scope.\n-\n-                  while Present (Node_Par) loop\n-                     case Nkind (Node_Par) is\n-                        when N_Abstract_Subprogram_Declaration\n-                           | N_Block_Statement\n-                           | N_Body_Stub\n-                           | N_Component_Declaration\n-                           | N_Entry_Body\n-                           | N_Entry_Declaration\n-                           | N_Exception_Declaration\n-                           | N_Formal_Object_Declaration\n-                           | N_Formal_Package_Declaration\n-                           | N_Formal_Subprogram_Declaration\n-                           | N_Formal_Type_Declaration\n-                           | N_Full_Type_Declaration\n-                           | N_Function_Specification\n-                           | N_Generic_Declaration\n-                           | N_Generic_Instantiation\n-                           | N_Implicit_Label_Declaration\n-                           | N_Incomplete_Type_Declaration\n-                           | N_Loop_Parameter_Specification\n-                           | N_Number_Declaration\n-                           | N_Object_Declaration\n-                           | N_Package_Declaration\n-                           | N_Package_Specification\n-                           | N_Parameter_Specification\n-                           | N_Private_Extension_Declaration\n-                           | N_Private_Type_Declaration\n-                           | N_Procedure_Specification\n-                           | N_Proper_Body\n-                           | N_Protected_Type_Declaration\n-                           | N_Renaming_Declaration\n-                           | N_Single_Protected_Declaration\n-                           | N_Single_Task_Declaration\n-                           | N_Subprogram_Declaration\n-                           | N_Subtype_Declaration\n-                           | N_Subunit\n-                           | N_Task_Type_Declaration\n-                        =>\n-                           return Scope_Depth\n-                                    (Nearest_Dynamic_Scope\n-                                       (Defining_Entity (Node_Par)));\n-\n-                        --  For a return statement within a function, return\n-                        --  the depth of the function itself. This is not just\n-                        --  a small optimization, but matters when analyzing\n-                        --  the expression in an expression function before\n-                        --  the body is created.\n-\n-                        when N_Simple_Return_Statement =>\n-                           if Ekind (Current_Scope) = E_Function then\n-                              return Scope_Depth (Current_Scope);\n-                           end if;\n-\n-                        when others =>\n-                           null;\n-                     end case;\n-\n-                     Node_Par := Parent (Node_Par);\n-                  end loop;\n-\n-                  pragma Assert (False);\n-\n-                  --  Should never reach the following return\n-\n-                  return Scope_Depth (Current_Scope) + 1;\n-               end Innermost_Master_Scope_Depth;\n-\n-            --  Start of processing for Return_Master_Scope_Depth_Of_Call\n-\n-            begin\n-               --  Expanded code may have clobbered the scoping data from the\n-               --  original object node - so use the expanded one.\n-\n-               return Innermost_Master_Scope_Depth (Obj);\n-            end Return_Master_Scope_Depth_Of_Call;\n-         end if;\n-\n-      --  For convenience we handle qualified expressions, even though they\n-      --  aren't technically object names.\n-\n-      elsif Nkind (Orig_Obj) = N_Qualified_Expression then\n-         return Object_Access_Level (Expression (Orig_Obj));\n-\n-      --  Ditto for aggregates. They have the level of the temporary that\n-      --  will hold their value.\n-\n-      elsif Nkind (Orig_Obj) = N_Aggregate then\n-         return Object_Access_Level (Current_Scope);\n-\n-      --  Treat an Old/Loop_Entry attribute reference like an aggregate.\n-      --  AARM 6.1.1(27.d) says \"... the implicit constant declaration\n-      --  defines the accessibility level of X'Old\", so that is what\n-      --  we are trying to implement here.\n-\n-      elsif Nkind (Orig_Obj) = N_Attribute_Reference\n-        and then Attribute_Name (Orig_Obj) in Name_Old | Name_Loop_Entry\n-      then\n-         return Object_Access_Level (Current_Scope);\n-\n-      --  Move up the attribute reference when we encounter a 'Access variation\n-\n-      elsif Nkind (Orig_Obj) = N_Attribute_Reference\n-        and then Attribute_Name (Orig_Obj) in Name_Access\n-                                            | Name_Unchecked_Access\n-                                            | Name_Unrestricted_Access\n-      then\n-         return Object_Access_Level (Prefix (Orig_Obj));\n-\n-      --  Otherwise return the scope level of Standard. (If there are cases\n-      --  that fall through to this point they will be treated as having\n-      --  global accessibility for now. ???)\n-\n-      else\n-         return Scope_Depth (Standard_Standard);\n-      end if;\n-   end Object_Access_Level;\n-\n    ----------------------------------\n    -- Old_Requires_Transient_Scope --\n    ----------------------------------\n@@ -24988,6 +24966,100 @@ package body Sem_Util is\n       Write_Eol;\n    end Output_Name;\n \n+   ------------------\n+   -- Param_Entity --\n+   ------------------\n+\n+   --  This would be trivial, simply a test for an identifier that was a\n+   --  reference to a formal, if it were not for the fact that a previous call\n+   --  to Expand_Entry_Parameter will have modified the reference to the\n+   --  identifier. A formal of a protected entity is rewritten as\n+\n+   --    typ!(recobj).rec.all'Constrained\n+\n+   --  where rec is a selector whose Entry_Formal link points to the formal\n+\n+   --  If the type of the entry parameter has a representation clause, then an\n+   --  extra temp is involved (see below).\n+\n+   --  For a formal of a task entity, the formal is rewritten as a local\n+   --  renaming.\n+\n+   --  In addition, a formal that is marked volatile because it is aliased\n+   --  through an address clause is rewritten as dereference as well.\n+\n+   function Param_Entity (N : Node_Id) return Entity_Id is\n+      Renamed_Obj : Node_Id;\n+\n+   begin\n+      --  Simple reference case\n+\n+      if Nkind (N) in N_Identifier | N_Expanded_Name then\n+         if Is_Formal (Entity (N)) then\n+            return Entity (N);\n+\n+         --  Handle renamings of formal parameters and formals of tasks that\n+         --  are rewritten as renamings.\n+\n+         elsif Nkind (Parent (Entity (N))) = N_Object_Renaming_Declaration then\n+            Renamed_Obj := Get_Referenced_Object (Renamed_Object (Entity (N)));\n+\n+            if Is_Entity_Name (Renamed_Obj)\n+              and then Is_Formal (Entity (Renamed_Obj))\n+            then\n+               return Entity (Renamed_Obj);\n+\n+            elsif\n+              Nkind (Parent (Parent (Entity (N)))) = N_Accept_Statement\n+            then\n+               return Entity (N);\n+            end if;\n+         end if;\n+\n+      else\n+         if Nkind (N) = N_Explicit_Dereference then\n+            declare\n+               P    : Node_Id := Prefix (N);\n+               S    : Node_Id;\n+               E    : Entity_Id;\n+               Decl : Node_Id;\n+\n+            begin\n+               --  If the type of an entry parameter has a representation\n+               --  clause, then the prefix is not a selected component, but\n+               --  instead a reference to a temp pointing at the selected\n+               --  component. In this case, set P to be the initial value of\n+               --  that temp.\n+\n+               if Nkind (P) = N_Identifier then\n+                  E := Entity (P);\n+\n+                  if Ekind (E) = E_Constant then\n+                     Decl := Parent (E);\n+\n+                     if Nkind (Decl) = N_Object_Declaration then\n+                        P := Expression (Decl);\n+                     end if;\n+                  end if;\n+               end if;\n+\n+               if Nkind (P) = N_Selected_Component then\n+                  S := Selector_Name (P);\n+\n+                  if Present (Entry_Formal (Entity (S))) then\n+                     return Entry_Formal (Entity (S));\n+                  end if;\n+\n+               elsif Nkind (Original_Node (N)) = N_Identifier then\n+                  return Param_Entity (Original_Node (N));\n+               end if;\n+            end;\n+         end if;\n+      end if;\n+\n+      return (Empty);\n+   end Param_Entity;\n+\n    ----------------------\n    -- Policy_In_Effect --\n    ----------------------\n@@ -27147,6 +27219,15 @@ package body Sem_Util is\n       return Result;\n    end Should_Ignore_Pragma_Sem;\n \n+   --------------------------------\n+   -- Static_Accessibility_Level --\n+   --------------------------------\n+\n+   function Static_Accessibility_Level (Expr : Node_Id) return Uint is\n+   begin\n+      return Intval (Accessibility_Level_Helper (Expr, Static => True));\n+   end Static_Accessibility_Level;\n+\n    --------------------\n    -- Static_Boolean --\n    --------------------"}, {"sha": "fdc4797bf65e53e7493a59359f25b3dab4fe3f35", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=d7e20130650fb46d71e0403652e4e07bc14f9775", "patch": "@@ -610,7 +610,9 @@ package Sem_Util is\n    --  in the case of a descendant of a generic formal type (returns Int'Last\n    --  instead of 0).\n \n-   function Defining_Entity (N : Node_Id) return Entity_Id;\n+   function Defining_Entity\n+     (N               : Node_Id;\n+      Empty_On_Errors : Boolean := False) return Entity_Id;\n    --  Given a declaration N, returns the associated defining entity. If the\n    --  declaration has a specification, the entity is obtained from the\n    --  specification. If the declaration has a defining unit name, then the\n@@ -621,6 +623,16 @@ package Sem_Util is\n    --  local entities declared during loop expansion. These entities need\n    --  debugging information, generated through Qualify_Entity_Names, and\n    --  the loop declaration must be placed in the table Name_Qualify_Units.\n+   --\n+   --  Set flag Empty_On_Errors to change the behavior of this routine as\n+   --  follows:\n+   --\n+   --    * True  - A declaration that lacks a defining entity returns Empty.\n+   --      A node that does not allow for a defining entity returns Empty.\n+   --\n+   --    * False - A declaration that lacks a defining entity is given a new\n+   --      internally generated entity which is subsequently returned. A node\n+   --      that does not allow for a defining entity raises Program_Error\n \n    --  WARNING: There is a matching C declaration of this subprogram in fe.h\n \n@@ -672,11 +684,11 @@ package Sem_Util is\n    --  private components of protected objects, but is generally useful when\n    --  restriction No_Implicit_Heap_Allocation is active.\n \n-   function Dynamic_Accessibility_Level (N : Node_Id) return Node_Id;\n-   --  N should be an expression of an access type. Builds an integer literal\n-   --  except in cases involving anonymous access types, where accessibility\n-   --  levels are tracked at run time (access parameters and Ada 2012 stand-\n-   --  alone objects).\n+   function Dynamic_Accessibility_Level (Expr : Node_Id) return Node_Id;\n+   --  Expr should be an expression of an access type. Builds an integer\n+   --  literal except in cases involving anonymous access types, where\n+   --  accessibility levels are tracked at run time (access parameters and\n+   --  stand-alone objects of anonymous access types).\n \n    function Effective_Extra_Accessibility (Id : Entity_Id) return Entity_Id;\n    --  Same as Einfo.Extra_Accessibility except thtat object renames\n@@ -2610,10 +2622,8 @@ package Sem_Util is\n    --  is known at compile time. If the bounds are not known at compile time,\n    --  the function returns the value zero.\n \n-   function Object_Access_Level (Obj : Node_Id) return Uint;\n-   --  Return the accessibility level of the view of the object Obj. For\n-   --  convenience, qualified expressions applied to object names are also\n-   --  allowed as actuals for this function.\n+   function Static_Accessibility_Level (Expr : Node_Id) return Uint;\n+   --  Return the numeric accessibility level of the expression Expr\n \n    function Original_Aspect_Pragma_Name (N : Node_Id) return Name_Id;\n    --  Retrieve the name of aspect or pragma N, taking into account a possible\n@@ -2649,6 +2659,12 @@ package Sem_Util is\n    --  WARNING: this routine should be used in debugging scenarios such as\n    --  tracking down undefined symbols as it is fairly low level.\n \n+   function Param_Entity (N : Node_Id) return Entity_Id;\n+   --  Given an expression N, determines if the expression is a reference\n+   --  to a formal (of a subprogram or entry), and if so returns the Id\n+   --  of the corresponding formal entity, otherwise returns Empty. Also\n+   --  handles the case of references to renamings of formals.\n+\n    function Policy_In_Effect (Policy : Name_Id) return Name_Id;\n    --  Given a policy, return the policy identifier associated with it. If no\n    --  such policy is in effect, the value returned is No_Name."}, {"sha": "7cbb99568ecf03b24debe7a6a2ea7ad23a5a0b2b", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7e20130650fb46d71e0403652e4e07bc14f9775/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=d7e20130650fb46d71e0403652e4e07bc14f9775", "patch": "@@ -174,6 +174,7 @@ package Snames is\n    Name_uFinalizer                     : constant Name_Id := N + $;\n    Name_uIdepth                        : constant Name_Id := N + $;\n    Name_uInit                          : constant Name_Id := N + $;\n+   Name_uInit_Level                    : constant Name_Id := N + $;\n    Name_uInvariant                     : constant Name_Id := N + $;\n    Name_uMaster                        : constant Name_Id := N + $;\n    Name_uObject                        : constant Name_Id := N + $;"}]}