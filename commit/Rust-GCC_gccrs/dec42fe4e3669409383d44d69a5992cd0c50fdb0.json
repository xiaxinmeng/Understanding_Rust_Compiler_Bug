{"sha": "dec42fe4e3669409383d44d69a5992cd0c50fdb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVjNDJmZTRlMzY2OTQwOTM4M2Q0NGQ2OWE1OTkyY2QwYzUwZmRiMA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-11-20T23:19:29Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-11-21T01:09:30Z"}, "message": "libgo: update to Go 1.15.5 release\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/272146", "tree": {"sha": "ecf4e3687f27e314879254b361bd7756d211a1ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecf4e3687f27e314879254b361bd7756d211a1ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dec42fe4e3669409383d44d69a5992cd0c50fdb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dec42fe4e3669409383d44d69a5992cd0c50fdb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dec42fe4e3669409383d44d69a5992cd0c50fdb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dec42fe4e3669409383d44d69a5992cd0c50fdb0/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82e5048e70ef790559ba768132b4afd266a30fee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82e5048e70ef790559ba768132b4afd266a30fee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82e5048e70ef790559ba768132b4afd266a30fee"}], "stats": {"total": 320, "additions": 312, "deletions": 8}, "files": [{"sha": "37374d55853133c46016b087824c5ddfc5cae103", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec42fe4e3669409383d44d69a5992cd0c50fdb0/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec42fe4e3669409383d44d69a5992cd0c50fdb0/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=dec42fe4e3669409383d44d69a5992cd0c50fdb0", "patch": "@@ -1,4 +1,4 @@\n-b483d0e0a289ba5fcdbd0388cbc75393367ca870\n+36a7b789130b415c2fe7f8e3fc62ffbca265e3aa\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "b753907837de58d06c0e6ebf587cda0cc2c4e2b6", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec42fe4e3669409383d44d69a5992cd0c50fdb0/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec42fe4e3669409383d44d69a5992cd0c50fdb0/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=dec42fe4e3669409383d44d69a5992cd0c50fdb0", "patch": "@@ -1,4 +1,4 @@\n-0e953add9656c32a788e06438cd7b533e968b7f8\n+c53315d6cf1b4bfea6ff356b4a1524778c683bb9\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "701454707cddcddde010fc9d213ee80374d855b9", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec42fe4e3669409383d44d69a5992cd0c50fdb0/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec42fe4e3669409383d44d69a5992cd0c50fdb0/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=dec42fe4e3669409383d44d69a5992cd0c50fdb0", "patch": "@@ -1 +1 @@\n-go1.15.4\n+go1.15.5"}, {"sha": "1c143d7aa380bd590263aae466631896fc1bc97f", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec42fe4e3669409383d44d69a5992cd0c50fdb0/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec42fe4e3669409383d44d69a5992cd0c50fdb0/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=dec42fe4e3669409383d44d69a5992cd0c50fdb0", "patch": "@@ -341,6 +341,8 @@ func dynimport(obj string) {\n \t\t\tif s.Version != \"\" {\n \t\t\t\ttarg += \"#\" + s.Version\n \t\t\t}\n+\t\t\tcheckImportSymName(s.Name)\n+\t\t\tcheckImportSymName(targ)\n \t\t\tfmt.Fprintf(stdout, \"//go:cgo_import_dynamic %s %s %q\\n\", s.Name, targ, s.Library)\n \t\t}\n \t\tlib, _ := f.ImportedLibraries()\n@@ -356,6 +358,7 @@ func dynimport(obj string) {\n \t\t\tif len(s) > 0 && s[0] == '_' {\n \t\t\t\ts = s[1:]\n \t\t\t}\n+\t\t\tcheckImportSymName(s)\n \t\t\tfmt.Fprintf(stdout, \"//go:cgo_import_dynamic %s %s %q\\n\", s, s, \"\")\n \t\t}\n \t\tlib, _ := f.ImportedLibraries()\n@@ -370,6 +373,8 @@ func dynimport(obj string) {\n \t\tfor _, s := range sym {\n \t\t\tss := strings.Split(s, \":\")\n \t\t\tname := strings.Split(ss[0], \"@\")[0]\n+\t\t\tcheckImportSymName(name)\n+\t\t\tcheckImportSymName(ss[0])\n \t\t\tfmt.Fprintf(stdout, \"//go:cgo_import_dynamic %s %s %q\\n\", name, ss[0], strings.ToLower(ss[1]))\n \t\t}\n \t\treturn\n@@ -387,6 +392,7 @@ func dynimport(obj string) {\n \t\t\t\t// Go symbols.\n \t\t\t\tcontinue\n \t\t\t}\n+\t\t\tcheckImportSymName(s.Name)\n \t\t\tfmt.Fprintf(stdout, \"//go:cgo_import_dynamic %s %s %q\\n\", s.Name, s.Name, s.Library)\n \t\t}\n \t\tlib, err := f.ImportedLibraries()\n@@ -402,6 +408,23 @@ func dynimport(obj string) {\n \tfatalf(\"cannot parse %s as ELF, Mach-O, PE or XCOFF\", obj)\n }\n \n+// checkImportSymName checks a symbol name we are going to emit as part\n+// of a //go:cgo_import_dynamic pragma. These names come from object\n+// files, so they may be corrupt. We are going to emit them unquoted,\n+// so while they don't need to be valid symbol names (and in some cases,\n+// involving symbol versions, they won't be) they must contain only\n+// graphic characters and must not contain Go comments.\n+func checkImportSymName(s string) {\n+\tfor _, c := range s {\n+\t\tif !unicode.IsGraphic(c) || unicode.IsSpace(c) {\n+\t\t\tfatalf(\"dynamic symbol %q contains unsupported character\", s)\n+\t\t}\n+\t}\n+\tif strings.Index(s, \"//\") >= 0 || strings.Index(s, \"/*\") >= 0 {\n+\t\tfatalf(\"dynamic symbol %q contains Go comment\")\n+\t}\n+}\n+\n // Construct a gcc struct matching the gc argument frame.\n // Assumes that in gcc, char is 1 byte, short 2 bytes, int 4 bytes, long long 8 bytes.\n // These assumptions are checked by the gccProlog."}, {"sha": "4f689438d1d428b59156b5b50134f132d5621897", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec42fe4e3669409383d44d69a5992cd0c50fdb0/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec42fe4e3669409383d44d69a5992cd0c50fdb0/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=dec42fe4e3669409383d44d69a5992cd0c50fdb0", "patch": "@@ -2723,6 +2723,66 @@ func (b *Builder) cgo(a *Action, cgoExe, objdir string, pcCFLAGS, pcLDFLAGS, cgo\n \t\tnoCompiler()\n \t}\n \n+\t// Double check the //go:cgo_ldflag comments in the generated files.\n+\t// The compiler only permits such comments in files whose base name\n+\t// starts with \"_cgo_\". Make sure that the comments in those files\n+\t// are safe. This is a backstop against people somehow smuggling\n+\t// such a comment into a file generated by cgo.\n+\tif cfg.BuildToolchainName == \"gc\" && !cfg.BuildN {\n+\t\tvar flags []string\n+\t\tfor _, f := range outGo {\n+\t\t\tif !strings.HasPrefix(filepath.Base(f), \"_cgo_\") {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tsrc, err := ioutil.ReadFile(f)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, nil, err\n+\t\t\t}\n+\n+\t\t\tconst cgoLdflag = \"//go:cgo_ldflag\"\n+\t\t\tidx := bytes.Index(src, []byte(cgoLdflag))\n+\t\t\tfor idx >= 0 {\n+\t\t\t\t// We are looking at //go:cgo_ldflag.\n+\t\t\t\t// Find start of line.\n+\t\t\t\tstart := bytes.LastIndex(src[:idx], []byte(\"\\n\"))\n+\t\t\t\tif start == -1 {\n+\t\t\t\t\tstart = 0\n+\t\t\t\t}\n+\n+\t\t\t\t// Find end of line.\n+\t\t\t\tend := bytes.Index(src[idx:], []byte(\"\\n\"))\n+\t\t\t\tif end == -1 {\n+\t\t\t\t\tend = len(src)\n+\t\t\t\t} else {\n+\t\t\t\t\tend += idx\n+\t\t\t\t}\n+\n+\t\t\t\t// Check for first line comment in line.\n+\t\t\t\t// We don't worry about /* */ comments,\n+\t\t\t\t// which normally won't appear in files\n+\t\t\t\t// generated by cgo.\n+\t\t\t\tcommentStart := bytes.Index(src[start:], []byte(\"//\"))\n+\t\t\t\tcommentStart += start\n+\t\t\t\t// If that line comment is //go:cgo_ldflag,\n+\t\t\t\t// it's a match.\n+\t\t\t\tif bytes.HasPrefix(src[commentStart:], []byte(cgoLdflag)) {\n+\t\t\t\t\t// Pull out the flag, and unquote it.\n+\t\t\t\t\t// This is what the compiler does.\n+\t\t\t\t\tflag := string(src[idx+len(cgoLdflag) : end])\n+\t\t\t\t\tflag = strings.TrimSpace(flag)\n+\t\t\t\t\tflag = strings.Trim(flag, `\"`)\n+\t\t\t\t\tflags = append(flags, flag)\n+\t\t\t\t}\n+\t\t\t\tsrc = src[end:]\n+\t\t\t\tidx = bytes.Index(src, []byte(cgoLdflag))\n+\t\t\t}\n+\t\t}\n+\t\tif err := checkLinkerFlags(\"LDFLAGS\", \"go:cgo_ldflag\", flags); err != nil {\n+\t\t\treturn nil, nil, err\n+\t\t}\n+\t}\n+\n \treturn outGo, outObj, nil\n }\n "}, {"sha": "0d9628241fd85e2bb0447eda1dae2b8c2a41d20e", "filename": "libgo/go/cmd/go/internal/work/security.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec42fe4e3669409383d44d69a5992cd0c50fdb0/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec42fe4e3669409383d44d69a5992cd0c50fdb0/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go?ref=dec42fe4e3669409383d44d69a5992cd0c50fdb0", "patch": "@@ -42,17 +42,17 @@ import (\n var re = lazyregexp.New\n \n var validCompilerFlags = []*lazyregexp.Regexp{\n-\tre(`-D([A-Za-z_].*)`),\n-\tre(`-U([A-Za-z_]*)`),\n+\tre(`-D([A-Za-z_][A-Za-z0-9_]*)(=[^@\\-]*)?`),\n+\tre(`-U([A-Za-z_][A-Za-z0-9_]*)`),\n \tre(`-F([^@\\-].*)`),\n \tre(`-I([^@\\-].*)`),\n \tre(`-O`),\n \tre(`-O([^@\\-].*)`),\n \tre(`-W`),\n \tre(`-W([^@,]+)`), // -Wall but not -Wa,-foo.\n \tre(`-Wa,-mbig-obj`),\n-\tre(`-Wp,-D([A-Za-z_].*)`),\n-\tre(`-Wp,-U([A-Za-z_]*)`),\n+\tre(`-Wp,-D([A-Za-z_][A-Za-z0-9_]*)(=[^@,\\-]*)?`),\n+\tre(`-Wp,-U([A-Za-z_][A-Za-z0-9_]*)`),\n \tre(`-ansi`),\n \tre(`-f(no-)?asynchronous-unwind-tables`),\n \tre(`-f(no-)?blocks`),"}, {"sha": "aec9789185e8a178a295e0b3f1146b1d94c21551", "filename": "libgo/go/cmd/go/internal/work/security_test.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec42fe4e3669409383d44d69a5992cd0c50fdb0/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec42fe4e3669409383d44d69a5992cd0c50fdb0/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go?ref=dec42fe4e3669409383d44d69a5992cd0c50fdb0", "patch": "@@ -13,6 +13,7 @@ var goodCompilerFlags = [][]string{\n \t{\"-DFOO\"},\n \t{\"-Dfoo=bar\"},\n \t{\"-Ufoo\"},\n+\t{\"-Ufoo1\"},\n \t{\"-F/Qt\"},\n \t{\"-I/\"},\n \t{\"-I/etc/passwd\"},\n@@ -24,6 +25,8 @@ var goodCompilerFlags = [][]string{\n \t{\"-Wall\"},\n \t{\"-Wp,-Dfoo=bar\"},\n \t{\"-Wp,-Ufoo\"},\n+\t{\"-Wp,-Dfoo1\"},\n+\t{\"-Wp,-Ufoo1\"},\n \t{\"-fobjc-arc\"},\n \t{\"-fno-objc-arc\"},\n \t{\"-fomit-frame-pointer\"},\n@@ -78,6 +81,8 @@ var badCompilerFlags = [][]string{\n \t{\"-O@1\"},\n \t{\"-Wa,-foo\"},\n \t{\"-W@foo\"},\n+\t{\"-Wp,-DX,-D@X\"},\n+\t{\"-Wp,-UX,-U@X\"},\n \t{\"-g@gdb\"},\n \t{\"-g-gdb\"},\n \t{\"-march=@dawn\"},"}, {"sha": "8c43de69d33ff8e841c000d15808a2e7e2b160da", "filename": "libgo/go/math/big/nat.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec42fe4e3669409383d44d69a5992cd0c50fdb0/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec42fe4e3669409383d44d69a5992cd0c50fdb0/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go?ref=dec42fe4e3669409383d44d69a5992cd0c50fdb0", "patch": "@@ -928,7 +928,7 @@ func (z nat) divRecursiveStep(u, v nat, depth int, tmp *nat, temps []*nat) {\n \n \t// Now u < (v<<B), compute lower bits in the same way.\n \t// Choose shift = B-1 again.\n-\ts := B\n+\ts := B - 1\n \tqhat := *temps[depth]\n \tqhat.clear()\n \tqhat.divRecursiveStep(u[s:].norm(), v[s:], depth+1, tmp, temps)"}, {"sha": "b2701bf922e52927f0a34b28fc7cdffe62008f7a", "filename": "libgo/misc/cgo/errors/badsym_test.go", "status": "added", "additions": 216, "deletions": 0, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dec42fe4e3669409383d44d69a5992cd0c50fdb0/libgo%2Fmisc%2Fcgo%2Ferrors%2Fbadsym_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dec42fe4e3669409383d44d69a5992cd0c50fdb0/libgo%2Fmisc%2Fcgo%2Ferrors%2Fbadsym_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmisc%2Fcgo%2Ferrors%2Fbadsym_test.go?ref=dec42fe4e3669409383d44d69a5992cd0c50fdb0", "patch": "@@ -0,0 +1,216 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package errorstest\n+\n+import (\n+\t\"bytes\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"unicode\"\n+)\n+\n+// A manually modified object file could pass unexpected characters\n+// into the files generated by cgo.\n+\n+const magicInput = \"abcdefghijklmnopqrstuvwxyz0123\"\n+const magicReplace = \"\\n//go:cgo_ldflag \\\"-badflag\\\"\\n//\"\n+\n+const cSymbol = \"BadSymbol\" + magicInput + \"Name\"\n+const cDefSource = \"int \" + cSymbol + \" = 1;\"\n+const cRefSource = \"extern int \" + cSymbol + \"; int F() { return \" + cSymbol + \"; }\"\n+\n+// goSource is the source code for the trivial Go file we use.\n+// We will replace TMPDIR with the temporary directory name.\n+const goSource = `\n+package main\n+\n+// #cgo LDFLAGS: TMPDIR/cbad.o TMPDIR/cbad.so\n+// extern int F();\n+import \"C\"\n+\n+func main() {\n+\tprintln(C.F())\n+}\n+`\n+\n+func TestBadSymbol(t *testing.T) {\n+\tdir := t.TempDir()\n+\n+\tmkdir := func(base string) string {\n+\t\tret := filepath.Join(dir, base)\n+\t\tif err := os.Mkdir(ret, 0755); err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\treturn ret\n+\t}\n+\n+\tcdir := mkdir(\"c\")\n+\tgodir := mkdir(\"go\")\n+\n+\tmakeFile := func(mdir, base, source string) string {\n+\t\tret := filepath.Join(mdir, base)\n+\t\tif err := ioutil.WriteFile(ret, []byte(source), 0644); err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\treturn ret\n+\t}\n+\n+\tcDefFile := makeFile(cdir, \"cdef.c\", cDefSource)\n+\tcRefFile := makeFile(cdir, \"cref.c\", cRefSource)\n+\n+\tccCmd := cCompilerCmd(t)\n+\n+\tcCompile := func(arg, base, src string) string {\n+\t\tout := filepath.Join(cdir, base)\n+\t\trun := append(ccCmd, arg, \"-o\", out, src)\n+\t\toutput, err := exec.Command(run[0], run[1:]...).CombinedOutput()\n+\t\tif err != nil {\n+\t\t\tt.Log(run)\n+\t\t\tt.Logf(\"%s\", output)\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif err := os.Remove(src); err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\treturn out\n+\t}\n+\n+\t// Build a shared library that defines a symbol whose name\n+\t// contains magicInput.\n+\n+\tcShared := cCompile(\"-shared\", \"c.so\", cDefFile)\n+\n+\t// Build an object file that refers to the symbol whose name\n+\t// contains magicInput.\n+\n+\tcObj := cCompile(\"-c\", \"c.o\", cRefFile)\n+\n+\t// Rewrite the shared library and the object file, replacing\n+\t// magicInput with magicReplace. This will have the effect of\n+\t// introducing a symbol whose name looks like a cgo command.\n+\t// The cgo tool will use that name when it generates the\n+\t// _cgo_import.go file, thus smuggling a magic //go:cgo_ldflag\n+\t// pragma into a Go file. We used to not check the pragmas in\n+\t// _cgo_import.go.\n+\n+\trewrite := func(from, to string) {\n+\t\tobj, err := ioutil.ReadFile(from)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\n+\t\tif bytes.Count(obj, []byte(magicInput)) == 0 {\n+\t\t\tt.Fatalf(\"%s: did not find magic string\", from)\n+\t\t}\n+\n+\t\tif len(magicInput) != len(magicReplace) {\n+\t\t\tt.Fatalf(\"internal test error: different magic lengths: %d != %d\", len(magicInput), len(magicReplace))\n+\t\t}\n+\n+\t\tobj = bytes.ReplaceAll(obj, []byte(magicInput), []byte(magicReplace))\n+\n+\t\tif err := ioutil.WriteFile(to, obj, 0644); err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t}\n+\n+\tcBadShared := filepath.Join(godir, \"cbad.so\")\n+\trewrite(cShared, cBadShared)\n+\n+\tcBadObj := filepath.Join(godir, \"cbad.o\")\n+\trewrite(cObj, cBadObj)\n+\n+\tgoSourceBadObject := strings.ReplaceAll(goSource, \"TMPDIR\", godir)\n+\tmakeFile(godir, \"go.go\", goSourceBadObject)\n+\n+\tmakeFile(godir, \"go.mod\", \"module badsym\")\n+\n+\t// Try to build our little package.\n+\tcmd := exec.Command(\"go\", \"build\", \"-ldflags=-v\")\n+\tcmd.Dir = godir\n+\toutput, err := cmd.CombinedOutput()\n+\n+\t// The build should fail, but we want it to fail because we\n+\t// detected the error, not because we passed a bad flag to the\n+\t// C linker.\n+\n+\tif err == nil {\n+\t\tt.Errorf(\"go build succeeded unexpectedly\")\n+\t}\n+\n+\tt.Logf(\"%s\", output)\n+\n+\tfor _, line := range bytes.Split(output, []byte(\"\\n\")) {\n+\t\tif bytes.Contains(line, []byte(\"dynamic symbol\")) && bytes.Contains(line, []byte(\"contains unsupported character\")) {\n+\t\t\t// This is the error from cgo.\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// We passed -ldflags=-v to see the external linker invocation,\n+\t\t// which should not include -badflag.\n+\t\tif bytes.Contains(line, []byte(\"-badflag\")) {\n+\t\t\tt.Error(\"output should not mention -badflag\")\n+\t\t}\n+\n+\t\t// Also check for compiler errors, just in case.\n+\t\t// GCC says \"unrecognized command line option\".\n+\t\t// clang says \"unknown argument\".\n+\t\tif bytes.Contains(line, []byte(\"unrecognized\")) || bytes.Contains(output, []byte(\"unknown\")) {\n+\t\t\tt.Error(\"problem should have been caught before invoking C linker\")\n+\t\t}\n+\t}\n+}\n+\n+func cCompilerCmd(t *testing.T) []string {\n+\tcc := []string{goEnv(t, \"CC\")}\n+\n+\tout := goEnv(t, \"GOGCCFLAGS\")\n+\tquote := '\\000'\n+\tstart := 0\n+\tlastSpace := true\n+\tbackslash := false\n+\ts := string(out)\n+\tfor i, c := range s {\n+\t\tif quote == '\\000' && unicode.IsSpace(c) {\n+\t\t\tif !lastSpace {\n+\t\t\t\tcc = append(cc, s[start:i])\n+\t\t\t\tlastSpace = true\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif lastSpace {\n+\t\t\t\tstart = i\n+\t\t\t\tlastSpace = false\n+\t\t\t}\n+\t\t\tif quote == '\\000' && !backslash && (c == '\"' || c == '\\'') {\n+\t\t\t\tquote = c\n+\t\t\t\tbackslash = false\n+\t\t\t} else if !backslash && quote == c {\n+\t\t\t\tquote = '\\000'\n+\t\t\t} else if (quote == '\\000' || quote == '\"') && !backslash && c == '\\\\' {\n+\t\t\t\tbackslash = true\n+\t\t\t} else {\n+\t\t\t\tbackslash = false\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif !lastSpace {\n+\t\tcc = append(cc, s[start:])\n+\t}\n+\treturn cc\n+}\n+\n+func goEnv(t *testing.T, key string) string {\n+\tout, err := exec.Command(\"go\", \"env\", key).CombinedOutput()\n+\tif err != nil {\n+\t\tt.Logf(\"go env %s\\n\", key)\n+\t\tt.Logf(\"%s\", out)\n+\t\tt.Fatal(err)\n+\t}\n+\treturn strings.TrimSpace(string(out))\n+}"}]}