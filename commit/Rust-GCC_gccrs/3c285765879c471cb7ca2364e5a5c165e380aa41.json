{"sha": "3c285765879c471cb7ca2364e5a5c165e380aa41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2MyODU3NjU4NzljNDcxY2I3Y2EyMzY0ZTVhNWMxNjVlMzgwYWE0MQ==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2007-10-12T16:12:45Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2007-10-12T16:12:45Z"}, "message": "re PR rtl-optimization/11001 (global register %edi versus string builtins)\n\ngcc/\n\tPR 11001\n\t* config/i386/i386.md (strmov): Check for esi and edi usage.\n\t* config/i386/i386.c (decide_alg): Check whether we can use a\n\trep prefix and adjust algorithm choice accordingly.\n\t(ix86_expand_strlen): Check for eax, ecx, and edi usage.\n\ngcc/testsuite/\n\tPR 11001\n\t* gcc.target/i386/pr11001-strlen-1.c: New testcase.\n\t* gcc.target/i386/pr11001-strlen-2.c: New testcase.\n\t* gcc.target/i386/pr11001-strlen-3.c: New testcase.\n\t* gcc.target/i386/pr11001-memset-1.c: New testcase.\n\t* gcc.target/i386/pr11001-memset-2.c: New testcase.\n\t* gcc.target/i386/pr11001-memset-3.c: New testcase.\n\t* gcc.target/i386/pr11001-memcpy-1.c: New testcase.\n\t* gcc.target/i386/pr11001-memcpy-2.c: New testcase.\n\t* gcc.target/i386/pr11001-memcpy-3.c: New testcase.\n\nFrom-SVN: r129265", "tree": {"sha": "5207ac97bd0057986f9f70bc84840f4e03f37c58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5207ac97bd0057986f9f70bc84840f4e03f37c58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c285765879c471cb7ca2364e5a5c165e380aa41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c285765879c471cb7ca2364e5a5c165e380aa41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c285765879c471cb7ca2364e5a5c165e380aa41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c285765879c471cb7ca2364e5a5c165e380aa41/comments", "author": null, "committer": null, "parents": [{"sha": "ece84738e7b584ed534791b502f29b499de1a7ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ece84738e7b584ed534791b502f29b499de1a7ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ece84738e7b584ed534791b502f29b499de1a7ea"}], "stats": {"total": 282, "additions": 266, "deletions": 16}, "files": [{"sha": "1d534afa578d46cea2c33fa262a7bf62fdcb5e3a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c285765879c471cb7ca2364e5a5c165e380aa41", "patch": "@@ -1,3 +1,11 @@\n+2007-10-12  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\tPR 11001\n+\t* config/i386/i386.md (strmov): Check for esi and edi usage.\n+\t* config/i386/i386.c (decide_alg): Check whether we can use a\n+\trep prefix and adjust algorithm choice accordingly.\n+\t(ix86_expand_strlen): Check for eax, ecx, and edi usage.\n+\n 2007-10-12  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* config/c4x/c4x.md (mulqi3, mulhi3): Use optab_libfunc."}, {"sha": "681b03bc40d12b53de8fc7b91649b70d84a96fe7", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 56, "deletions": 15, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=3c285765879c471cb7ca2364e5a5c165e380aa41", "patch": "@@ -15056,21 +15056,32 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n \t    int *dynamic_check)\n {\n   const struct stringop_algs * algs;\n+  /* Algorithms using the rep prefix want at least edi and ecx;\n+     additionally, memset wants eax and memcpy wants esi.  Don't\n+     consider such algorithms if the user has appropriated those\n+     registers for their own purposes.\t*/\n+  bool rep_prefix_usable = !(global_regs[2] || global_regs[5]\n+                             || (memset ? global_regs[0] : global_regs[4]));\n+\n+#define ALG_USABLE_P(alg) (rep_prefix_usable\t\t\t\\\n+\t\t\t   || (alg != rep_prefix_1_byte\t\t\\\n+\t\t\t       && alg != rep_prefix_4_byte      \\\n+\t\t\t       && alg != rep_prefix_8_byte))\n \n   *dynamic_check = -1;\n   if (memset)\n     algs = &ix86_cost->memset[TARGET_64BIT != 0];\n   else\n     algs = &ix86_cost->memcpy[TARGET_64BIT != 0];\n-  if (stringop_alg != no_stringop)\n+  if (stringop_alg != no_stringop && ALG_USABLE_P (stringop_alg))\n     return stringop_alg;\n   /* rep; movq or rep; movl is the smallest variant.  */\n   else if (optimize_size)\n     {\n       if (!count || (count & 3))\n-\treturn rep_prefix_1_byte;\n+\treturn rep_prefix_usable ? rep_prefix_1_byte : loop_1_byte;\n       else\n-\treturn rep_prefix_4_byte;\n+\treturn rep_prefix_usable ? rep_prefix_4_byte : loop;\n     }\n   /* Very tiny blocks are best handled via the loop, REP is expensive to setup.\n    */\n@@ -15082,27 +15093,34 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n       enum stringop_alg alg = libcall;\n       for (i = 0; i < NAX_STRINGOP_ALGS; i++)\n \t{\n-\t  gcc_assert (algs->size[i].max);\n+\t  /* We get here if the algorithms that were not libcall-based\n+\t     were rep-prefix based and we are unable to use rep prefixes\n+\t     based on global register usage.  Break out of the loop and\n+\t     use the heuristic below.  */\n+\t  if (algs->size[i].max == 0)\n+\t    break;\n \t  if (algs->size[i].max >= expected_size || algs->size[i].max == -1)\n \t    {\n-\t      if (algs->size[i].alg != libcall)\n-\t\talg = algs->size[i].alg;\n+\t      enum stringop_alg candidate = algs->size[i].alg;\n+\n+\t      if (candidate != libcall && ALG_USABLE_P (candidate))\n+\t\talg = candidate;\n \t      /* Honor TARGET_INLINE_ALL_STRINGOPS by picking\n-\t         last non-libcall inline algorithm.  */\n+\t\t last non-libcall inline algorithm.  */\n \t      if (TARGET_INLINE_ALL_STRINGOPS)\n \t\t{\n \t\t  /* When the current size is best to be copied by a libcall,\n-\t\t     but we are still forced to inline, run the heuristic bellow\n+\t\t     but we are still forced to inline, run the heuristic below\n \t\t     that will pick code for medium sized blocks.  */\n \t\t  if (alg != libcall)\n \t\t    return alg;\n \t\t  break;\n \t\t}\n-\t      else\n-\t\treturn algs->size[i].alg;\n+\t      else if (ALG_USABLE_P (candidate))\n+\t\treturn candidate;\n \t    }\n \t}\n-      gcc_assert (TARGET_INLINE_ALL_STRINGOPS);\n+      gcc_assert (TARGET_INLINE_ALL_STRINGOPS || !rep_prefix_usable);\n     }\n   /* When asked to inline the call anyway, try to pick meaningful choice.\n      We look for maximal size of block that is faster to copy by hand and\n@@ -15112,15 +15130,32 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n      If this turns out to be bad, we might simply specify the preferred\n      choice in ix86_costs.  */\n   if ((TARGET_INLINE_ALL_STRINGOPS || TARGET_INLINE_STRINGOPS_DYNAMICALLY)\n-      && algs->unknown_size == libcall)\n+      && (algs->unknown_size == libcall || !ALG_USABLE_P (algs->unknown_size)))\n     {\n       int max = -1;\n       enum stringop_alg alg;\n       int i;\n+      bool any_alg_usable_p = true;\n \n       for (i = 0; i < NAX_STRINGOP_ALGS; i++)\n-\tif (algs->size[i].alg != libcall && algs->size[i].alg)\n-\t  max = algs->size[i].max;\n+        {\n+          enum stringop_alg candidate = algs->size[i].alg;\n+          any_alg_usable_p = any_alg_usable_p && ALG_USABLE_P (candidate);\n+\n+          if (candidate != libcall && candidate\n+              && ALG_USABLE_P (candidate))\n+              max = algs->size[i].max;\n+        }\n+      /* If there aren't any usable algorithms, then recursing on\n+         smaller sizes isn't going to find anything.  Just return the\n+         simple byte-at-a-time copy loop.  */\n+      if (!any_alg_usable_p)\n+        {\n+          /* Pick something reasonable.  */\n+          if (TARGET_INLINE_STRINGOPS_DYNAMICALLY)\n+            *dynamic_check = 128;\n+          return loop_1_byte;\n+        }\n       if (max == -1)\n \tmax = 4096;\n       alg = decide_alg (count, max / 2, memset, dynamic_check);\n@@ -15130,7 +15165,8 @@ decide_alg (HOST_WIDE_INT count, HOST_WIDE_INT expected_size, bool memset,\n \t*dynamic_check = max;\n       return alg;\n     }\n-  return algs->unknown_size;\n+  return ALG_USABLE_P (algs->unknown_size) ? algs->unknown_size : libcall;\n+#undef ALG_USABLE_P\n }\n \n /* Decide on alignment.  We know that the operand is already aligned to ALIGN\n@@ -15984,6 +16020,11 @@ ix86_expand_strlen (rtx out, rtx src, rtx eoschar, rtx align)\n   else\n     {\n       rtx unspec;\n+\n+      /* Can't use this if the user has appropriated eax, ecx, or edi.  */\n+      if (global_regs[0] || global_regs[2] || global_regs[5])\n+        return false;\n+\n       scratch2 = gen_reg_rtx (Pmode);\n       scratch3 = gen_reg_rtx (Pmode);\n       scratch4 = force_reg (Pmode, constm1_rtx);"}, {"sha": "145eb956182f5502cdfebabeb96f9c7f59511d3c", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=3c285765879c471cb7ca2364e5a5c165e380aa41", "patch": "@@ -18702,7 +18702,9 @@\n   operands[5] = gen_rtx_PLUS (Pmode, operands[0], adjust);\n   operands[6] = gen_rtx_PLUS (Pmode, operands[2], adjust);\n \n-  if (TARGET_SINGLE_STRINGOP || optimize_size)\n+  /* Can't use this if the user has appropriated esi or edi.  */\n+  if ((TARGET_SINGLE_STRINGOP || optimize_size)\n+      && !(global_regs[4] || global_regs[5]))\n     {\n       emit_insn (gen_strmov_singleop (operands[0], operands[1],\n \t\t\t\t      operands[2], operands[3],"}, {"sha": "8c03b11890204b91367080379d528b58300f292f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3c285765879c471cb7ca2364e5a5c165e380aa41", "patch": "@@ -1,3 +1,16 @@\n+2007-10-12  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\tPR 11001\n+\t* gcc.target/i386/pr11001-strlen-1.c: New testcase.\n+\t* gcc.target/i386/pr11001-strlen-2.c: New testcase.\n+\t* gcc.target/i386/pr11001-strlen-3.c: New testcase.\n+\t* gcc.target/i386/pr11001-memset-1.c: New testcase.\n+\t* gcc.target/i386/pr11001-memset-2.c: New testcase.\n+\t* gcc.target/i386/pr11001-memset-3.c: New testcase.\n+\t* gcc.target/i386/pr11001-memcpy-1.c: New testcase.\n+\t* gcc.target/i386/pr11001-memcpy-2.c: New testcase.\n+\t* gcc.target/i386/pr11001-memcpy-3.c: New testcase.\n+\n 2007-10-12  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/26198"}, {"sha": "0899cc5c1d95acd2d2754660ea0428577e1f5288", "filename": "gcc/testsuite/gcc.target/i386/pr11001-memcpy-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-memcpy-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-memcpy-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-memcpy-1.c?ref=3c285765879c471cb7ca2364e5a5c165e380aa41", "patch": "@@ -0,0 +1,23 @@\n+/* Ensure that we don't use 'rep movX' in the presence of register globals.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Os -m32\" } */\n+\n+extern void *memcpy (void *, const void *, __SIZE_TYPE__);\n+\n+register int regvar asm(\"%esi\");\n+\n+int foo[10];\n+int bar[10];\n+\n+char baz[15];\n+char quux[15];\n+\n+void\n+do_copy ()\n+{\n+  memcpy (foo, bar, sizeof foo);\n+  memcpy (baz, quux, sizeof baz);\n+}\n+\n+/* { dg-final { scan-assembler-not \"rep movsl\" } } */\n+/* { dg-final { scan-assembler-not \"rep movsb\" } } */"}, {"sha": "ef9d3bfcd5d9f7738280bd725d9a4bb6b17df944", "filename": "gcc/testsuite/gcc.target/i386/pr11001-memcpy-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-memcpy-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-memcpy-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-memcpy-2.c?ref=3c285765879c471cb7ca2364e5a5c165e380aa41", "patch": "@@ -0,0 +1,23 @@\n+/* Ensure that we don't use 'rep movX' in the presence of register globals.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Os -m32\" } */\n+\n+extern void *memcpy (void *, const void *, __SIZE_TYPE__);\n+\n+register int regvar asm(\"%edi\");\n+\n+int foo[10];\n+int bar[10];\n+\n+char baz[15];\n+char quux[15];\n+\n+void\n+do_copy ()\n+{\n+  memcpy (foo, bar, sizeof foo);\n+  memcpy (baz, quux, sizeof baz);\n+}\n+\n+/* { dg-final { scan-assembler-not \"rep movsl\" } } */\n+/* { dg-final { scan-assembler-not \"rep movsb\" } } */"}, {"sha": "1bee3b92b679082e9ff2c31cefa577a770e36325", "filename": "gcc/testsuite/gcc.target/i386/pr11001-memcpy-3.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-memcpy-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-memcpy-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-memcpy-3.c?ref=3c285765879c471cb7ca2364e5a5c165e380aa41", "patch": "@@ -0,0 +1,23 @@\n+/* Ensure that we don't use 'rep movX' in the presence of register globals.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Os -m32\" } */\n+\n+extern void *memcpy (void *, const void *, __SIZE_TYPE__);\n+\n+register int regvar asm(\"%ecx\"); /* { dg-warning \"call-clobbered register\" } */\n+\n+int foo[10];\n+int bar[10];\n+\n+char baz[15];\n+char quux[15];\n+\n+void\n+do_copy ()\n+{\n+  memcpy (foo, bar, sizeof foo);\n+  memcpy (baz, quux, sizeof baz);\n+}\n+\n+/* { dg-final { scan-assembler-not \"rep movsl\" } } */\n+/* { dg-final { scan-assembler-not \"rep movsb\" } } */"}, {"sha": "ef8c3c9505ef501eba3d69cb0bd627ffd549189c", "filename": "gcc/testsuite/gcc.target/i386/pr11001-memset-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-memset-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-memset-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-memset-1.c?ref=3c285765879c471cb7ca2364e5a5c165e380aa41", "patch": "@@ -0,0 +1,23 @@\n+/* Ensure that we don't use 'rep stoX' in the presence of register globals.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Os -m32\" } */\n+\n+extern void *memset (void *, int, __SIZE_TYPE__);\n+\n+register int regvar asm(\"%eax\"); /* { dg-warning \"call-clobbered register\" } */\n+\n+int foo[10];\n+int bar[10];\n+\n+char baz[15];\n+char quux[15];\n+\n+void\n+do_copy ()\n+{\n+  memset (foo, 0, sizeof foo);\n+  memset (baz, 0, sizeof baz);\n+}\n+\n+/* { dg-final { scan-assembler-not \"rep stosl\" } } */\n+/* { dg-final { scan-assembler-not \"rep stosb\" } } */"}, {"sha": "c04202551b3e8b4faac53b7228054ee414886d4b", "filename": "gcc/testsuite/gcc.target/i386/pr11001-memset-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-memset-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-memset-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-memset-2.c?ref=3c285765879c471cb7ca2364e5a5c165e380aa41", "patch": "@@ -0,0 +1,23 @@\n+/* Ensure that we don't use 'rep stoX' in the presence of register globals.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Os -m32\" } */\n+\n+extern void *memset (void *, int, __SIZE_TYPE__);\n+\n+register int regvar asm(\"%ecx\"); /* { dg-warning \"call-clobbered register\" } */\n+\n+int foo[10];\n+int bar[10];\n+\n+char baz[15];\n+char quux[15];\n+\n+void\n+do_copy ()\n+{\n+  memset (foo, 0, sizeof foo);\n+  memset (baz, 0, sizeof baz);\n+}\n+\n+/* { dg-final { scan-assembler-not \"rep stosl\" } } */\n+/* { dg-final { scan-assembler-not \"rep stosb\" } } */"}, {"sha": "0c485a778bab0b3ba610400024a76f45b532309f", "filename": "gcc/testsuite/gcc.target/i386/pr11001-memset-3.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-memset-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-memset-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-memset-3.c?ref=3c285765879c471cb7ca2364e5a5c165e380aa41", "patch": "@@ -0,0 +1,23 @@\n+/* Ensure that we don't use 'rep stoX' in the presence of register globals.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-Os -m32\" } */\n+\n+extern void *memset (void *, int, __SIZE_TYPE__);\n+\n+register int regvar asm(\"%edi\");\n+\n+int foo[10];\n+int bar[10];\n+\n+char baz[15];\n+char quux[15];\n+\n+void\n+do_copy ()\n+{\n+  memset (foo, 0, sizeof foo);\n+  memset (baz, 0, sizeof baz);\n+}\n+\n+/* { dg-final { scan-assembler-not \"rep stosl\" } } */\n+/* { dg-final { scan-assembler-not \"rep stosb\" } } */"}, {"sha": "311c969e58d6e467303760cfe436ff51a04dbb30", "filename": "gcc/testsuite/gcc.target/i386/pr11001-strlen-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-strlen-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-strlen-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-strlen-1.c?ref=3c285765879c471cb7ca2364e5a5c165e380aa41", "patch": "@@ -0,0 +1,16 @@\n+/* Ensure that we don't use 'repnz scasb' in the presence of register globals.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -m32\" } */\n+\n+extern __SIZE_TYPE__ strlen (const char *);\n+extern void *malloc (__SIZE_TYPE__);\n+\n+register int regvar asm(\"%edi\");\n+\n+char *\n+do_copy (char *str)\n+{\n+  return malloc (strlen (str) + 1);\n+}\n+\n+/* { dg-final { scan-assembler-not \"repnz scasb\" } } */"}, {"sha": "b30223d8a37e1a9718925f9e2d0d00bbf1c8a30f", "filename": "gcc/testsuite/gcc.target/i386/pr11001-strlen-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-strlen-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-strlen-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-strlen-2.c?ref=3c285765879c471cb7ca2364e5a5c165e380aa41", "patch": "@@ -0,0 +1,16 @@\n+/* Ensure that we don't use 'repnz scasb' in the presence of register globals.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -m32\" } */\n+\n+extern __SIZE_TYPE__ strlen (const char *);\n+extern void *malloc (__SIZE_TYPE__);\n+\n+register int regvar asm(\"%eax\"); /* { dg-warning \"call-clobbered register\" } */\n+\n+char *\n+do_copy (char *str)\n+{\n+  return malloc (strlen (str) + 1);\n+}\n+\n+/* { dg-final { scan-assembler-not \"repnz scasb\" } } */"}, {"sha": "b28824f5a3c96b3806ed87eef65a04b020939752", "filename": "gcc/testsuite/gcc.target/i386/pr11001-strlen-3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-strlen-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c285765879c471cb7ca2364e5a5c165e380aa41/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-strlen-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr11001-strlen-3.c?ref=3c285765879c471cb7ca2364e5a5c165e380aa41", "patch": "@@ -0,0 +1,16 @@\n+/* Ensure that we don't use 'repnz scasb' in the presence of register globals.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -m32\" } */\n+\n+extern __SIZE_TYPE__ strlen (const char *);\n+extern void *malloc (__SIZE_TYPE__);\n+\n+register int regvar asm(\"%ecx\"); /* { dg-warning \"call-clobbered register\" } */\n+\n+char *\n+do_copy (char *str)\n+{\n+  return malloc (strlen (str) + 1);\n+}\n+\n+/* { dg-final { scan-assembler-not \"repnz scasb\" } } */"}]}