{"sha": "d8bb17c8e33975277dd5231e190bf99451b7025d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhiYjE3YzhlMzM5NzUyNzdkZDUyMzFlMTkwYmY5OTQ1MWI3MDI1ZA==", "commit": {"author": {"name": "Ovidiu Predescu", "email": "ovidiu@aracnet.com", "date": "1998-09-02T23:48:01Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-09-02T23:48:01Z"}, "message": "Boehm GC support for ObjC from Ovidiu Predescu.\n\nFrom-SVN: r22199", "tree": {"sha": "1c3b607110323b831606c2ec27d39a0f292a1a15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c3b607110323b831606c2ec27d39a0f292a1a15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8bb17c8e33975277dd5231e190bf99451b7025d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8bb17c8e33975277dd5231e190bf99451b7025d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8bb17c8e33975277dd5231e190bf99451b7025d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8bb17c8e33975277dd5231e190bf99451b7025d/comments", "author": null, "committer": null, "parents": [{"sha": "d636ae0b801758df397e3e1ee790ed041a48b9f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d636ae0b801758df397e3e1ee790ed041a48b9f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d636ae0b801758df397e3e1ee790ed041a48b9f9"}], "stats": {"total": 1921, "additions": 1747, "deletions": 174}, "files": [{"sha": "75d58622055e66a14ff089c894467e8fe9cabe6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d8bb17c8e33975277dd5231e190bf99451b7025d", "patch": "@@ -1,3 +1,48 @@\n+Thu Sep  3 00:37:55 1998  Ovidiu Predescu  <ovidiu@aracnet.com>\n+\n+\tAdded support for the Boehm's garbage collector.\n+\t* configure.in: Handle --enable-objc-gc.\n+\t* configure: Rebuilt.\n+\t* Makefile.in (CHECK_TARGETS): Add check-objc.\n+\t(check-objc): New rule.\n+\t* objc/Make-lang.in: Build a different Objective-C library that\n+ \truns with the Boehm's collector.\n+\t* objc/encoding.c (objc_round_acc_size_for_types): New function.\n+\t* objc/encoding.c: Correctly compute the size of compound types in\n+ \tthe presence of bitfields. Skip the variable name of the type if\n+ \tany. Added support for long long.\n+\t* objc/encoding.h (_C_GCINVISIBLE): New specifier.\n+\t(_F_GCINVISIBLE): New mask.\n+\t* objc/gc.c: New file. Compute the type memory mask associated with\n+\ta class based on the runtime information.\n+\t* objc/misc.c: Added the hooks that use the Boehm's collector\n+ \tallocation functions.\n+\t* objc/objc-act.c (build_class_template): Generate a new class\n+ \tmember (gc_object_type) to hold the class' type memory mask.\n+\t(build_shared_structure_initializer): Initialize the new member to\n+\tNULL.\n+\t(encode_complete_bitfield): New function. Generate the new\n+ \tencoding.\n+\t(encode_field_decl): Generate the new encoding only for the GNU\n+\truntime.\n+\t* objc/objc-api.h (_C_LNG_LNG, _C_ULNG_LNG): New specifiers for the\n+\tlong long types.\n+\t(class_get_gc_object_type): New function to mark a pointer instance\n+\tvariable as a weak pointer.\n+\t* objc/objc-features.texi: New file.\n+\t* objc/objc.h (gc_object_type): New class member.\n+\t* objc/objects.c (class_create_instance): Create a typed memory\n+ \tobject when compiled with Boehm's collector support.\n+\t* objc/sendmsg.c (__objc_init_install_dtable): Call\n+ \t__objc_send_initialize instead of setting the initialize flag.\n+\t(__objc_send_initialize): Call __objc_generate_gc_type_description\n+ \tto generate the class type memory mask. Rewrite the code that\n+ \tsends the +initialize so that it is called only once (bug report\n+ \tand fix from Ronald Pijnacker <Ronald.Pijnacker@best.ms.philips.com>).\n+\t* testsuite/objc: New testsuite for Objective-C type encoding.\n+\t* testsuite/lib/objc-torture.exp: New file.\n+\t* testsuite/lib/objc.exp: New file.\n+\n Wed Sep  2 14:47:36 1998  Jim Wilson  <wilson@cygnus.com>\n \n \t* jump.c (jump_optimize): In if/then/else transformations, add"}, {"sha": "c1beec3fdb4d069becadf29757b291062740e4cf", "filename": "gcc/Makefile.in", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d8bb17c8e33975277dd5231e190bf99451b7025d", "patch": "@@ -246,6 +246,7 @@ lang_specs_files=@lang_specs_files@\n lang_options_files=@lang_options_files@\n lang_tree_files=@lang_tree_files@\n GCC_THREAD_FILE=@thread_file@\n+OBJC_BOEHM_GC=@objc_boehm_gc@\n GTHREAD_FLAGS=@gthread_flags@\n # Be prepared for gcc2 merges.\n gcc_version=@gcc_version@\n@@ -2574,7 +2575,7 @@ site.exp: ./config.status Makefile\n \t\t-e '1,/^## All variables above are.*##/ d' >> site.exp\n \t-@rm -f ./tmp?\n \n-CHECK_TARGETS = check-gcc check-g++ check-g77\n+CHECK_TARGETS = check-gcc check-g++ check-g77 check-objc\n \n check: $(CHECK_TARGETS)\n \n@@ -2617,6 +2618,16 @@ check-g77: testsuite/site.exp\n \t   export TCL_LIBRARY ; fi ; \\\n \t$(RUNTEST) --tool g77 $(RUNTESTFLAGS)\n \n+check-objc: testsuite/site.exp\n+\t-rootme=`pwd`; export rootme; \\\n+\tsrcdir=`cd ${srcdir}; pwd` ; export srcdir ; \\\n+\tcd testsuite; \\\n+\tEXPECT=${EXPECT} ; export EXPECT ; \\\n+\tif [ -f $${rootme}/../expect/expect ] ; then  \\\n+\t   TCL_LIBRARY=$${srcdir}/../tcl/library ; \\\n+\t    export TCL_LIBRARY ; fi ; \\\n+\t$(RUNTEST) --tool objc $(RUNTESTFLAGS)\n+\n # These exist for maintenance purposes.\n \n # Update the tags table."}, {"sha": "758b52e819b3e3c922ad290cce6f4ec4707acc28", "filename": "gcc/configure", "status": "modified", "additions": 97, "deletions": 79, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=d8bb17c8e33975277dd5231e190bf99451b7025d", "patch": "@@ -44,6 +44,9 @@ ac_help=\"$ac_help\n ac_help=\"$ac_help\n   --enable-threads        enable thread usage for target GCC.\n   --enable-threads=LIB    use LIB thread package for target GCC.\"\n+ac_help=\"$ac_help\n+  --enable-objc-gc\t  enable the use of Boehm's garbage collector with\n+\t\t\t  the GNU Objective-C runtime.\"\n \n # Initialize some variables set by options.\n # The variables have the same names as the options, with\n@@ -745,6 +748,19 @@ case x${enable_threads_flag} in\n \t\t;;\n esac\n \n+# Check whether --enable-objc-gc or --disable-objc-gc was given.\n+if test \"${enable_objc_gc+set}\" = set; then\n+  enableval=\"$enable_objc_gc\"\n+  if [ x$enable_objc_gc = xno ]; then\n+\tobjc_boehm_gc=''\n+else\n+\tobjc_boehm_gc=1\n+fi\n+else\n+  objc_boehm_gc=''\n+fi\n+\n+\n # Determine the host, build, and target systems\n ac_aux_dir=\n for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do\n@@ -793,7 +809,7 @@ else { echo \"configure: error: can not run $ac_config_sub\" 1>&2; exit 1; }\n fi\n \n echo $ac_n \"checking host system type\"\"... $ac_c\" 1>&6\n-echo \"configure:797: checking host system type\" >&5\n+echo \"configure:813: checking host system type\" >&5\n \n host_alias=$host\n case \"$host_alias\" in\n@@ -814,7 +830,7 @@ host_os=`echo $host | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n echo \"$ac_t\"\"$host\" 1>&6\n \n echo $ac_n \"checking target system type\"\"... $ac_c\" 1>&6\n-echo \"configure:818: checking target system type\" >&5\n+echo \"configure:834: checking target system type\" >&5\n \n target_alias=$target\n case \"$target_alias\" in\n@@ -832,7 +848,7 @@ target_os=`echo $target | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n echo \"$ac_t\"\"$target\" 1>&6\n \n echo $ac_n \"checking build system type\"\"... $ac_c\" 1>&6\n-echo \"configure:836: checking build system type\" >&5\n+echo \"configure:852: checking build system type\" >&5\n \n build_alias=$build\n case \"$build_alias\" in\n@@ -859,7 +875,7 @@ test \"$host_alias\" != \"$target_alias\" &&\n # Extract the first word of \"gcc\", so it can be a program name with args.\n set dummy gcc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:863: checking for $ac_word\" >&5\n+echo \"configure:879: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -888,7 +904,7 @@ if test -z \"$CC\"; then\n   # Extract the first word of \"cc\", so it can be a program name with args.\n set dummy cc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:892: checking for $ac_word\" >&5\n+echo \"configure:908: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -936,7 +952,7 @@ fi\n fi\n \n echo $ac_n \"checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\"\"... $ac_c\" 1>&6\n-echo \"configure:940: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\" >&5\n+echo \"configure:956: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\" >&5\n \n ac_ext=c\n # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.\n@@ -946,11 +962,11 @@ ac_link='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS\n cross_compiling=$ac_cv_prog_cc_cross\n \n cat > conftest.$ac_ext <<EOF\n-#line 950 \"configure\"\n+#line 966 \"configure\"\n #include \"confdefs.h\"\n main(){return(0);}\n EOF\n-if { (eval echo configure:954: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then\n+if { (eval echo configure:970: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then\n   ac_cv_prog_cc_works=yes\n   # If we can't run a trivial program, we are probably using a cross compiler.\n   if (./conftest; exit) 2>/dev/null; then\n@@ -970,12 +986,12 @@ if test $ac_cv_prog_cc_works = no; then\n   { echo \"configure: error: installation or configuration problem: C compiler cannot create executables.\" 1>&2; exit 1; }\n fi\n echo $ac_n \"checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\"\"... $ac_c\" 1>&6\n-echo \"configure:974: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\" >&5\n+echo \"configure:990: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\" >&5\n echo \"$ac_t\"\"$ac_cv_prog_cc_cross\" 1>&6\n cross_compiling=$ac_cv_prog_cc_cross\n \n echo $ac_n \"checking whether we are using GNU C\"\"... $ac_c\" 1>&6\n-echo \"configure:979: checking whether we are using GNU C\" >&5\n+echo \"configure:995: checking whether we are using GNU C\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gcc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -984,7 +1000,7 @@ else\n   yes;\n #endif\n EOF\n-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:988: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1004: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gcc=yes\n else\n   ac_cv_prog_gcc=no\n@@ -999,7 +1015,7 @@ if test $ac_cv_prog_gcc = yes; then\n   ac_save_CFLAGS=\"$CFLAGS\"\n   CFLAGS=\n   echo $ac_n \"checking whether ${CC-cc} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:1003: checking whether ${CC-cc} accepts -g\" >&5\n+echo \"configure:1019: checking whether ${CC-cc} accepts -g\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_cc_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1038,7 +1054,7 @@ fi\n \n \n echo $ac_n \"checking whether ${MAKE-make} sets \\${MAKE}\"\"... $ac_c\" 1>&6\n-echo \"configure:1042: checking whether ${MAKE-make} sets \\${MAKE}\" >&5\n+echo \"configure:1058: checking whether ${MAKE-make} sets \\${MAKE}\" >&5\n set dummy ${MAKE-make}; ac_make=`echo \"$2\" | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -1071,7 +1087,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1075: checking for $ac_word\" >&5\n+echo \"configure:1091: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AWK'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1102,7 +1118,7 @@ done\n # Extract the first word of \"flex\", so it can be a program name with args.\n set dummy flex; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1106: checking for $ac_word\" >&5\n+echo \"configure:1122: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_LEX'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1135,15 +1151,15 @@ then\n   *) ac_lib=l ;;\n   esac\n   echo $ac_n \"checking for yywrap in -l$ac_lib\"\"... $ac_c\" 1>&6\n-echo \"configure:1139: checking for yywrap in -l$ac_lib\" >&5\n+echo \"configure:1155: checking for yywrap in -l$ac_lib\" >&5\n ac_lib_var=`echo $ac_lib'_'yywrap | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-l$ac_lib  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 1147 \"configure\"\n+#line 1163 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -1154,7 +1170,7 @@ int main() {\n yywrap()\n ; return 0; }\n EOF\n-if { (eval echo configure:1158: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then\n+if { (eval echo configure:1174: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else\n@@ -1177,7 +1193,7 @@ fi\n fi\n \n echo $ac_n \"checking whether ln works\"\"... $ac_c\" 1>&6\n-echo \"configure:1181: checking whether ln works\" >&5\n+echo \"configure:1197: checking whether ln works\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_prog_LN'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1209,7 +1225,7 @@ else\n fi\n \n echo $ac_n \"checking whether ln -s works\"\"... $ac_c\" 1>&6\n-echo \"configure:1213: checking whether ln -s works\" >&5\n+echo \"configure:1229: checking whether ln -s works\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_prog_LN_S'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1241,19 +1257,19 @@ else\n fi\n \n echo $ac_n \"checking for volatile\"\"... $ac_c\" 1>&6\n-echo \"configure:1245: checking for volatile\" >&5\n+echo \"configure:1261: checking for volatile\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_c_volatile'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 1250 \"configure\"\n+#line 1266 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n volatile int foo;\n ; return 0; }\n EOF\n-if { (eval echo configure:1257: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:1273: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   gcc_cv_c_volatile=yes\n else\n@@ -1276,7 +1292,7 @@ fi\n # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1280: checking for $ac_word\" >&5\n+echo \"configure:1296: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1307,7 +1323,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1311: checking for $ac_word\" >&5\n+echo \"configure:1327: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_YACC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1347,7 +1363,7 @@ test -n \"$YACC\" || YACC=\"yacc\"\n # SVR4 /usr/ucb/install, which tries to use the nonexistent group \"staff\"\n # ./install, which can be erroneously created by make from ./install.sh.\n echo $ac_n \"checking for a BSD compatible install\"\"... $ac_c\" 1>&6\n-echo \"configure:1351: checking for a BSD compatible install\" >&5\n+echo \"configure:1367: checking for a BSD compatible install\" >&5\n if test -z \"$INSTALL\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_path_install'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -1398,7 +1414,7 @@ test -z \"$INSTALL_DATA\" && INSTALL_DATA='${INSTALL} -m 644'\n \n \n echo $ac_n \"checking how to run the C preprocessor\"\"... $ac_c\" 1>&6\n-echo \"configure:1402: checking how to run the C preprocessor\" >&5\n+echo \"configure:1418: checking how to run the C preprocessor\" >&5\n # On Suns, sometimes $CPP names a directory.\n if test -n \"$CPP\" && test -d \"$CPP\"; then\n   CPP=\n@@ -1413,13 +1429,13 @@ else\n   # On the NeXT, cc -E runs the code through the compiler's parser,\n   # not just through cpp.\n   cat > conftest.$ac_ext <<EOF\n-#line 1417 \"configure\"\n+#line 1433 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:1423: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:1439: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out`\n if test -z \"$ac_err\"; then\n   :\n@@ -1430,13 +1446,13 @@ else\n   rm -rf conftest*\n   CPP=\"${CC-cc} -E -traditional-cpp\"\n   cat > conftest.$ac_ext <<EOF\n-#line 1434 \"configure\"\n+#line 1450 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:1440: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:1456: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out`\n if test -z \"$ac_err\"; then\n   :\n@@ -1459,20 +1475,20 @@ fi\n echo \"$ac_t\"\"$CPP\" 1>&6\n \n echo $ac_n \"checking for ANSI C header files\"\"... $ac_c\" 1>&6\n-echo \"configure:1463: checking for ANSI C header files\" >&5\n+echo \"configure:1479: checking for ANSI C header files\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_stdc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 1468 \"configure\"\n+#line 1484 \"configure\"\n #include \"confdefs.h\"\n #include <stdlib.h>\n #include <stdarg.h>\n #include <string.h>\n #include <float.h>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:1476: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:1492: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -1489,7 +1505,7 @@ rm -f conftest*\n if test $ac_cv_header_stdc = yes; then\n   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.\n cat > conftest.$ac_ext <<EOF\n-#line 1493 \"configure\"\n+#line 1509 \"configure\"\n #include \"confdefs.h\"\n #include <string.h>\n EOF\n@@ -1507,7 +1523,7 @@ fi\n if test $ac_cv_header_stdc = yes; then\n   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.\n cat > conftest.$ac_ext <<EOF\n-#line 1511 \"configure\"\n+#line 1527 \"configure\"\n #include \"confdefs.h\"\n #include <stdlib.h>\n EOF\n@@ -1528,7 +1544,7 @@ if test \"$cross_compiling\" = yes; then\n   :\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 1532 \"configure\"\n+#line 1548 \"configure\"\n #include \"confdefs.h\"\n #include <ctype.h>\n #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')\n@@ -1539,7 +1555,7 @@ if (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);\n exit (0); }\n \n EOF\n-if { (eval echo configure:1543: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:1559: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null\n then\n   :\n else\n@@ -1563,12 +1579,12 @@ EOF\n fi\n \n echo $ac_n \"checking whether time.h and sys/time.h may both be included\"\"... $ac_c\" 1>&6\n-echo \"configure:1567: checking whether time.h and sys/time.h may both be included\" >&5\n+echo \"configure:1583: checking whether time.h and sys/time.h may both be included\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_time'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 1572 \"configure\"\n+#line 1588 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #include <sys/time.h>\n@@ -1577,7 +1593,7 @@ int main() {\n struct tm *tp;\n ; return 0; }\n EOF\n-if { (eval echo configure:1581: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:1597: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_header_time=yes\n else\n@@ -1601,17 +1617,17 @@ for ac_hdr in limits.h stddef.h string.h strings.h stdlib.h time.h fcntl.h unist\n do\n ac_safe=`echo \"$ac_hdr\" | sed 'y%./+-%__p_%'`\n echo $ac_n \"checking for $ac_hdr\"\"... $ac_c\" 1>&6\n-echo \"configure:1605: checking for $ac_hdr\" >&5\n+echo \"configure:1621: checking for $ac_hdr\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 1610 \"configure\"\n+#line 1626 \"configure\"\n #include \"confdefs.h\"\n #include <$ac_hdr>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:1615: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:1631: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -1641,17 +1657,17 @@ done\n # Check for thread headers.\n ac_safe=`echo \"thread.h\" | sed 'y%./+-%__p_%'`\n echo $ac_n \"checking for thread.h\"\"... $ac_c\" 1>&6\n-echo \"configure:1645: checking for thread.h\" >&5\n+echo \"configure:1661: checking for thread.h\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 1650 \"configure\"\n+#line 1666 \"configure\"\n #include \"confdefs.h\"\n #include <thread.h>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:1655: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:1671: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -1675,17 +1691,17 @@ fi\n \n ac_safe=`echo \"pthread.h\" | sed 'y%./+-%__p_%'`\n echo $ac_n \"checking for pthread.h\"\"... $ac_c\" 1>&6\n-echo \"configure:1679: checking for pthread.h\" >&5\n+echo \"configure:1695: checking for pthread.h\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 1684 \"configure\"\n+#line 1700 \"configure\"\n #include \"confdefs.h\"\n #include <pthread.h>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:1689: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:1705: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -1711,20 +1727,20 @@ fi\n # See if the system preprocessor understands the ANSI C preprocessor\n # stringification operator.\n echo $ac_n \"checking whether cpp understands the stringify operator\"\"... $ac_c\" 1>&6\n-echo \"configure:1715: checking whether cpp understands the stringify operator\" >&5\n+echo \"configure:1731: checking whether cpp understands the stringify operator\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_c_have_stringify'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 1720 \"configure\"\n+#line 1736 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n #define S(x)   #x\n char *test = S(foo);\n ; return 0; }\n EOF\n-if { (eval echo configure:1728: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:1744: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   gcc_cv_c_have_stringify=yes\n else\n@@ -1747,20 +1763,20 @@ fi\n # Use <inttypes.h> only if it exists,\n # doesn't clash with <sys/types.h>, and declares intmax_t.\n echo $ac_n \"checking for inttypes.h\"\"... $ac_c\" 1>&6\n-echo \"configure:1751: checking for inttypes.h\" >&5\n+echo \"configure:1767: checking for inttypes.h\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_header_inttypes_h'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 1756 \"configure\"\n+#line 1772 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #include <inttypes.h>\n int main() {\n intmax_t i = -1;\n ; return 0; }\n EOF\n-if { (eval echo configure:1764: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:1780: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   cat >> confdefs.h <<EOF\n #define HAVE_INTTYPES_H 1\n@@ -1783,12 +1799,12 @@ for ac_func in strtoul bsearch strerror putenv popen bcopy bzero bcmp \\\n \tsysconf isascii gettimeofday\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:1787: checking for $ac_func\" >&5\n+echo \"configure:1803: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 1792 \"configure\"\n+#line 1808 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -1811,7 +1827,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:1815: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then\n+if { (eval echo configure:1831: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -1840,12 +1856,12 @@ done\n #AC_CHECK_TYPE(wchar_t, unsigned int)\n \n echo $ac_n \"checking for vprintf\"\"... $ac_c\" 1>&6\n-echo \"configure:1844: checking for vprintf\" >&5\n+echo \"configure:1860: checking for vprintf\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_vprintf'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 1849 \"configure\"\n+#line 1865 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char vprintf(); below.  */\n@@ -1868,7 +1884,7 @@ vprintf();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:1872: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then\n+if { (eval echo configure:1888: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then\n   rm -rf conftest*\n   eval \"ac_cv_func_vprintf=yes\"\n else\n@@ -1892,12 +1908,12 @@ fi\n \n if test \"$ac_cv_func_vprintf\" != yes; then\n echo $ac_n \"checking for _doprnt\"\"... $ac_c\" 1>&6\n-echo \"configure:1896: checking for _doprnt\" >&5\n+echo \"configure:1912: checking for _doprnt\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func__doprnt'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 1901 \"configure\"\n+#line 1917 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char _doprnt(); below.  */\n@@ -1920,7 +1936,7 @@ _doprnt();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:1924: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then\n+if { (eval echo configure:1940: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest; then\n   rm -rf conftest*\n   eval \"ac_cv_func__doprnt=yes\"\n else\n@@ -1956,15 +1972,15 @@ fi\n \n \n echo $ac_n \"checking whether the printf functions support %p\"\"... $ac_c\" 1>&6\n-echo \"configure:1960: checking whether the printf functions support %p\" >&5\n+echo \"configure:1976: checking whether the printf functions support %p\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_func_printf_ptr'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n   gcc_cv_func_printf_ptr=no\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 1968 \"configure\"\n+#line 1984 \"configure\"\n #include \"confdefs.h\"\n #include <stdio.h>\n \n@@ -1977,7 +1993,7 @@ main()\n   exit (p != q);\n }\n EOF\n-if { (eval echo configure:1981: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:1997: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest && (./conftest; exit) 2>/dev/null\n then\n   gcc_cv_func_printf_ptr=yes\n else\n@@ -2005,12 +2021,12 @@ for ac_func in malloc realloc calloc free bcopy bzero bcmp \\\n \tindex rindex getenv atol sbrk abort atof strerror getcwd getwd\n do\n echo $ac_n \"checking whether $ac_func must be declared\"\"... $ac_c\" 1>&6\n-echo \"configure:2009: checking whether $ac_func must be declared\" >&5\n+echo \"configure:2025: checking whether $ac_func must be declared\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_decl_needed_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2014 \"configure\"\n+#line 2030 \"configure\"\n #include \"confdefs.h\"\n \n #include <stdio.h>\n@@ -2038,7 +2054,7 @@ int main() {\n char *(*pfn) = (char *(*)) $ac_func\n ; return 0; }\n EOF\n-if { (eval echo configure:2042: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:2058: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   eval \"gcc_cv_decl_needed_$ac_func=no\"\n else\n@@ -2067,12 +2083,12 @@ done\n for ac_func in getrlimit setrlimit\n do\n echo $ac_n \"checking whether $ac_func must be declared\"\"... $ac_c\" 1>&6\n-echo \"configure:2071: checking whether $ac_func must be declared\" >&5\n+echo \"configure:2087: checking whether $ac_func must be declared\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_decl_needed_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2076 \"configure\"\n+#line 2092 \"configure\"\n #include \"confdefs.h\"\n \n #include <stdio.h>\n@@ -2104,7 +2120,7 @@ int main() {\n char *(*pfn) = (char *(*)) $ac_func\n ; return 0; }\n EOF\n-if { (eval echo configure:2108: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:2124: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   eval \"gcc_cv_decl_needed_$ac_func=no\"\n else\n@@ -2131,12 +2147,12 @@ done\n \n \n echo $ac_n \"checking for sys_siglist declaration in signal.h or unistd.h\"\"... $ac_c\" 1>&6\n-echo \"configure:2135: checking for sys_siglist declaration in signal.h or unistd.h\" >&5\n+echo \"configure:2151: checking for sys_siglist declaration in signal.h or unistd.h\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_decl_sys_siglist'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2140 \"configure\"\n+#line 2156 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #include <signal.h>\n@@ -2148,7 +2164,7 @@ int main() {\n char *msg = *(sys_siglist + 1);\n ; return 0; }\n EOF\n-if { (eval echo configure:2152: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:2168: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_decl_sys_siglist=yes\n else\n@@ -5306,7 +5322,7 @@ fi\n \n # Figure out what assembler alignment features are present.\n echo $ac_n \"checking assembler alignment features\"\"... $ac_c\" 1>&6\n-echo \"configure:5310: checking assembler alignment features\" >&5\n+echo \"configure:5326: checking assembler alignment features\" >&5\n gcc_cv_as=\n gcc_cv_as_alignment_features=\n gcc_cv_as_gas_srcdir=`echo $srcdir | sed -e 's,gcc$,gas,'`\n@@ -5566,7 +5582,7 @@ fi\n \n # Warn if using init_priority.\n echo $ac_n \"checking whether to enable init_priority by default\"\"... $ac_c\" 1>&6\n-echo \"configure:5570: checking whether to enable init_priority by default\" >&5\n+echo \"configure:5586: checking whether to enable init_priority by default\" >&5\n if test x$enable_init_priority != xyes; then\n   enable_init_priority=no\n fi\n@@ -5634,6 +5650,7 @@ ${CONFIG_SHELL-/bin/sh} $srcdir/configure.frag $srcdir \"$subdirs\" \"$dep_host_xma\n \n \n \n+\n \n \n # Echo that links are built\n@@ -5876,6 +5893,7 @@ s%@lang_specs_files@%$lang_specs_files%g\n s%@lang_options_files@%$lang_options_files%g\n s%@lang_tree_files@%$lang_tree_files%g\n s%@thread_file@%$thread_file%g\n+s%@objc_boehm_gc@%$objc_boehm_gc%g\n s%@gcc_version@%$gcc_version%g\n s%@gcc_version_trigger@%$gcc_version_trigger%g\n s%@local_prefix@%$local_prefix%g"}, {"sha": "7c281cacc1f7fd423d129ace5517a0b39e72c85b", "filename": "gcc/configure.in", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=d8bb17c8e33975277dd5231e190bf99451b7025d", "patch": "@@ -173,6 +173,16 @@ case x${enable_threads_flag} in\n \t\t;;\n esac\n \n+AC_ARG_ENABLE(objc-gc,\n+[  --enable-objc-gc\t  enable the use of Boehm's garbage collector with\n+\t\t\t  the GNU Objective-C runtime.],\n+if [[[ x$enable_objc_gc = xno ]]]; then\n+\tobjc_boehm_gc=''\n+else\n+\tobjc_boehm_gc=1\n+fi,\n+objc_boehm_gc='')\n+\n # Determine the host, build, and target systems\n AC_CANONICAL_SYSTEM\n \n@@ -3822,6 +3832,7 @@ AC_SUBST(lang_specs_files)\n AC_SUBST(lang_options_files)\n AC_SUBST(lang_tree_files)\n AC_SUBST(thread_file)\n+AC_SUBST(objc_boehm_gc)\n AC_SUBST(gcc_version)\n AC_SUBST(gcc_version_trigger)\n AC_SUBST(local_prefix)"}, {"sha": "f12992b83901bcbe7cb52fe44832c3ebec7b46e0", "filename": "gcc/objc/Make-lang.in", "status": "modified", "additions": 88, "deletions": 6, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FMake-lang.in?ref=d8bb17c8e33975277dd5231e190bf99451b7025d", "patch": "@@ -119,6 +119,7 @@ OBJC_O = objc/hash.o objc/sarray.o \\\n \tobjc/NXConstStr.o objc/Object.o \\\n \tobjc/Protocol.o objc/nil_method.o \\\n \tobjc/thr.o objc/linking.o \\\n+\tobjc/gc.o \\\n \tobjc/$(OBJC_THREAD_FILE).o\n \n objc/hash.o: $(srcdir)/objc/hash.c $(GCC_PASSES)\n@@ -172,11 +173,74 @@ objc/nil_method.o: $(srcdir)/objc/nil_method.c $(GCC_PASSES)\n objc/linking.o: $(srcdir)/objc/linking.m $(GCC_PASSES)\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n \t-fgnu-runtime -c $(srcdir)/objc/linking.m -o $@\n-\n+objc/gc.o: $(srcdir)/objc/gc.c $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n+\t-fgnu-runtime -c $(srcdir)/objc/gc.c -o $@\n objc/libobjc_entry.o: $(srcdir)/objc/libobjc_entry.c $(GCC_PASSES)\n \t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n \t-c $(srcdir)/objc/libobjc_entry.c -o $@\n \n+\n+\n+objc/hash_gc.o: $(srcdir)/objc/hash.c $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n+\t-c $(srcdir)/objc/hash.c -o $@\n+objc/sarray_gc.o: $(srcdir)/objc/sarray.c $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n+\t-c $(srcdir)/objc/sarray.c -o $@\n+objc/class_gc.o: $(srcdir)/objc/class.c $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n+\t-c $(srcdir)/objc/class.c -o $@\n+objc/sendmsg_gc.o: $(srcdir)/objc/sendmsg.c $(GCC_PASSES) objc/runtime-info.h\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) -Iobjc \\\n+\t-c $(srcdir)/objc/sendmsg.c -o $@\n+objc/init_gc.o: $(srcdir)/objc/init.c $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n+\t-c $(srcdir)/objc/init.c -o $@\n+objc/archive_gc.o: $(srcdir)/objc/archive.c $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n+\t-c $(srcdir)/objc/archive.c -o $@\n+objc/encoding_gc.o: $(srcdir)/objc/encoding.c $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n+\t-c $(srcdir)/objc/encoding.c -o $@\n+objc/selector_gc.o: $(srcdir)/objc/selector.c $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n+\t-c $(srcdir)/objc/selector.c -o $@\n+objc/objects_gc.o: $(srcdir)/objc/objects.c $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n+\t-c $(srcdir)/objc/objects.c -o $@\n+objc/misc_gc.o: $(srcdir)/objc/misc.c $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n+\t-c $(srcdir)/objc/misc.c -o $@\n+objc/NXConstStr_gc.o: $(srcdir)/objc/NXConstStr.m $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n+\t-fgnu-runtime -c $(srcdir)/objc/NXConstStr.m -o $@\n+objc/Object_gc.o: $(srcdir)/objc/Object.m $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n+\t-fgnu-runtime -c $(srcdir)/objc/Object.m -o $@\n+objc/Protocol_gc.o: $(srcdir)/objc/Protocol.m $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n+\t-fgnu-runtime -c $(srcdir)/objc/Protocol.m -o $@\n+objc/thr_gc.o: $(srcdir)/objc/thr.h $(srcdir)/objc/thr.c $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n+\t-c $(srcdir)/objc/thr.c -o $@\n+objc/$(OBJC_THREAD_FILE)_gc.o: $(srcdir)/objc/$(OBJC_THREAD_FILE).c $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n+\t-c $(srcdir)/objc/$(OBJC_THREAD_FILE).c -o $@\n+objc/nil_method_gc.o: $(srcdir)/objc/nil_method.c $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n+\t-c $(srcdir)/objc/nil_method.c -o $@\n+objc/linking_gc.o: $(srcdir)/objc/linking.m $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n+\t-fgnu-runtime -c $(srcdir)/objc/linking.m -o $@\n+objc/gc_gc.o: $(srcdir)/objc/gc.c $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n+\t-fgnu-runtime -c $(srcdir)/objc/gc.c -o $@\n+objc/libobjc_entry_gc.o: $(srcdir)/objc/libobjc_entry.c $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(INCLUDES) \\\n+\t-c $(srcdir)/objc/libobjc_entry.c -o $@\n+\n+\n $(OBJC_O): $(GCC_PASSES) cc1obj$(exeext)\n \n # Build the Objective C runtime library.\n@@ -185,6 +249,17 @@ libobjc.a: cc1obj$(exeext) specs stmp-int-hdrs libgcc2.ready \\\n \t-rm -f libobjc.a\n \t$(AR) $(AR_FLAGS) libobjc.a $(OBJC_O)\n \t-if $(RANLIB_TEST) ; then $(RANLIB) libobjc.a; else true; fi\n+\t-if [ \"$(OBJC_BOEHM_GC)\" != \"\" ]; then \\\n+\t  make libobjc_gc.a GCC_CFLAGS=\"$(GCC_CFLAGS) -DOBJC_WITH_GC=1\" \\\n+\t\tOBJC_O=`echo $(OBJC_O) | sed 's/.o /_gc.o /g'`; \\\n+\tfi\n+\n+# Build the garbage collected Objective C runtime library.\n+libobjc_gc.a: cc1obj specs stmp-int-hdrs libgcc2.ready \\\n+\t$(USE_COLLECT2) $(EXTRA_PARTS) $(OBJC_O)\n+\t-rm -f libobjc_gc.a\n+\t$(AR) $(AR_FLAGS) libobjc_gc.a $(OBJC_O)\n+\t-if $(RANLIB_TEST) ; then $(RANLIB) libobjc_gc.a; else true; fi\n \n libobjc_s.a: libobjc.a\n \tmv libobjc.a libobjc_s.a\n@@ -236,6 +311,13 @@ objc.install-normal: installdirs\n \t    (cd $(libsubdir); $(RANLIB) libobjc.a); else true; fi; \\\n \t  chmod a-x $(libsubdir)/libobjc.a; \\\n \telse true; fi\n+\t-if [ -f libobjc_gc.a ] ; then \\\n+\t  rm -f $(libsubdir)/libobjc_gc.a; \\\n+\t  $(INSTALL_DATA) libobjc_gc.a $(libsubdir)/libobjc_gc.a; \\\n+\t  if $(RANLIB_TEST) ; then \\\n+\t    (cd $(libsubdir); $(RANLIB) libobjc_gc.a); else true; fi; \\\n+\t  chmod a-x $(libsubdir)/libobjc_gc.a; \\\n+\telse true; fi\n \t-if [ -f libobjc_s.a ] ; then \\\n \t  rm -f $(libsubdir)/libobjc_s.a; \\\n \t  $(INSTALL_DATA) libobjc_s.a $(libsubdir)/libobjc_s.a; \\\n@@ -263,7 +345,7 @@ objc.mostlyclean:\n \t-rm -f tmp-objc-prs.y\n \t-rm -f objc/*$(objext) objc/xforward objc/fflags\n \t-rm -f objc/runtime-info.h\n-\t-rm -f libobjc.a libobjc_s.a libobjc.dll\n+\t-rm -f libobjc.a libobjc_gc.a libobjc_s.a libobjc.dll\n \t-rm -f libobjc.base libobjc.exp\n objc.clean: objc.mostlyclean\n \t-rm -rf objc-headers\n@@ -282,19 +364,19 @@ objc.maintainer-clean:\n objc.stage1: stage1-start\n \t-mv objc/*$(objext) stage1/objc\n \t-mv cc1obj$(exeext) stage1\n-\t-mv libobjc.a stage1\n+\t-mv libobjc.a libobjc_gc.a stage1\n objc.stage2: stage2-start\n \t-mv objc/*$(objext) stage2/objc\n \t-mv cc1obj$(exeext) stage2\n-\t-mv libobjc.a stage2\n+\t-mv libobjc.a libobjc_gc.a stage2\n objc.stage3: stage3-start\n \t-mv objc/*$(objext) stage3/objc\n \t-mv cc1obj$(exeext) stage3\n-\t-mv libobjc.a stage3\n+\t-mv libobjc.a libobjc_gc.a stage3\n objc.stage4: stage4-start\n \t-mv objc/*$(objext) stage4/objc\n \t-mv cc1obj$(exeext) stage4\n-\t-mv libobjc.a stage4\n+\t-mv libobjc.a libobjc_gc.a stage4\n \n #\f\n # Maintenance hooks:"}, {"sha": "b152363fca7c2e50cbe305d872150c0727acf844", "filename": "gcc/objc/Makefile.in", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FMakefile.in?ref=d8bb17c8e33975277dd5231e190bf99451b7025d", "patch": "@@ -81,8 +81,23 @@ copy-headers:\n Makefile: $(srcdir)/Makefile.in $(srcdir)/../configure\n \tcd ..; $(SHELL) config.status\n \n+doc: info dvi html\n+info: objc-features.info\n+dvi: objc-features.dvi\n+html: objc-features_toc.html\n+\n+objc-features.info: $(srcdir)/objc-features.texi\n+\tmakeinfo $(srcdir)/objc-features.texi\n+\n+objc-features.dvi: $(srcdir)/objc-features.texi\n+\ttexi2dvi $(srcdir)/objc-features.texi\n+\n+objc-features_toc.html: objc-features.texi\n+\ttexi2html -split_node $(srcdir)/objc-features.texi\n+\n mostlyclean:\n-\t-rm -f *.o libobjc.a xforward fflags\n+\t-rm -f *.o libobjc* xforward fflags *.aux *.cp *.dvi *.fn *.info \\\n+\t\t*.ky *.log *.pg *.toc *.tp *.vr *.html\n clean: mostlyclean\n distclean: mostlyclean\n extraclean: mostlyclean"}, {"sha": "ab47e9c4bf47caec7b411dffaef5866c5ed28507", "filename": "gcc/objc/encoding.c", "status": "modified", "additions": 409, "deletions": 36, "changes": 445, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2Fencoding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2Fencoding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fencoding.c?ref=d8bb17c8e33975277dd5231e190bf99451b7025d", "patch": "@@ -1,6 +1,7 @@\n /* Encoding of types for Objective C.\n-   Copyright (C) 1993, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.\n    Contributed by Kresten Krab Thorup\n+   Bitfield support by Ovidiu Predescu\n \n This file is part of GNU CC.\n \n@@ -25,6 +26,8 @@ Boston, MA 02111-1307, USA.  */\n    This exception does not however invalidate any other reasons why\n    the executable file might be covered by the GNU General Public License.  */\n \n+#include \"tconfig.h\"\n+#include \"objc-api.h\"\n #include \"encoding.h\"\n \n #define MAX(X, Y)                    \\\n@@ -40,6 +43,22 @@ Boston, MA 02111-1307, USA.  */\n      __a*((__v+__a-1)/__a); })\n \n \n+/* Various hacks for objc_layout_record. These are used by the target\n+   macros. */\n+\n+#define TREE_CODE(TYPE) *TYPE\n+#define RECORD_TYPE     _C_STRUCT_B\n+#define UNION_TYPE      _C_UNION_B\n+#define QUAL_UNION_TYPE _C_UNION_B\n+\n+#define TYPE_FIELDS(TYPE)     objc_skip_typespec (TYPE)\n+\n+#define DECL_MODE(TYPE)         *(TYPE)\n+\n+#define DFmode          _C_DBL\n+\n+\n+\n static inline int\n atoi (const char* str)\n {\n@@ -56,8 +75,15 @@ atoi (const char* str)\n */\n \n int\n-objc_sizeof_type(const char* type)\n+objc_sizeof_type (const char* type)\n {\n+  /* Skip the variable name if any */\n+  if (*type == '\"')\n+    {\n+      for (type++; *type++ != '\"';)\n+\t/* do nothing */;\n+    }\n+\n   switch(*type) {\n   case _C_ID:\n     return sizeof(id);\n@@ -103,6 +129,14 @@ objc_sizeof_type(const char* type)\n     return sizeof(unsigned long);\n     break;\n \n+  case _C_LNG_LNG:\n+    return sizeof(long long);\n+    break;\n+\n+  case _C_ULNG_LNG:\n+    return sizeof(unsigned long long);\n+    break;\n+\n   case _C_FLT:\n     return sizeof(float);\n     break;\n@@ -111,6 +145,9 @@ objc_sizeof_type(const char* type)\n     return sizeof(double);\n     break;\n \n+  case _C_VOID:\n+    return sizeof(void);\n+    break;\n   case _C_PTR:\n   case _C_ATOM:\n   case _C_CHARPTR:\n@@ -125,19 +162,32 @@ objc_sizeof_type(const char* type)\n     }\n     break; \n \n+  case _C_BFLD:\n+    {\n+      /* The new encoding of bitfields is: b 'position' 'type' 'size' */\n+      int position, size;\n+      int startByte, endByte;\n+\n+      position = atoi (type + 1);\n+      while (isdigit (*++type));\n+      size = atoi (type + 1);\n+\n+      startByte = position / BITS_PER_UNIT;\n+      endByte = (position + size) / BITS_PER_UNIT;\n+      return endByte - startByte;\n+    }\n+\n   case _C_STRUCT_B:\n     {\n-      int acc_size = 0;\n-      int align;\n-      while (*type != _C_STRUCT_E && *type++ != '='); /* skip \"<name>=\" */\n-      while (*type != _C_STRUCT_E)\n-\t{\n-\t  align = objc_alignof_type (type);       /* padd to alignment */\n-\t  acc_size = ROUND (acc_size, align);\n-\t  acc_size += objc_sizeof_type (type);   /* add component size */\n-\t  type = objc_skip_typespec (type);\t         /* skip component */\n-\t}\n-      return acc_size;\n+      struct objc_struct_layout layout;\n+      unsigned int size;\n+\n+      objc_layout_structure (type, &layout);\n+      while (objc_layout_structure_next_member (&layout))\n+        /* do nothing */ ;\n+      objc_layout_finish_structure (&layout, &size, NULL);\n+\n+      return size;\n     }\n \n   case _C_UNION_B:\n@@ -146,14 +196,23 @@ objc_sizeof_type(const char* type)\n       while (*type != _C_UNION_E && *type++ != '=') /* do nothing */;\n       while (*type != _C_UNION_E)\n \t{\n+\t  /* Skip the variable name if any */\n+\t  if (*type == '\"')\n+\t    {\n+\t      for (type++; *type++ != '\"';)\n+\t\t/* do nothing */;\n+\t    }\n \t  max_size = MAX (max_size, objc_sizeof_type (type));\n \t  type = objc_skip_typespec (type);\n \t}\n       return max_size;\n     }\n     \n   default:\n-    objc_error(nil, OBJC_ERR_BAD_TYPE, \"unknown type %s\\n\", type);\n+    {\n+      objc_error(nil, OBJC_ERR_BAD_TYPE, \"unknown type %s\\n\", type);\n+      return 0;\n+    }\n   }\n }\n \n@@ -165,6 +224,12 @@ objc_sizeof_type(const char* type)\n int\n objc_alignof_type(const char* type)\n {\n+  /* Skip the variable name if any */\n+  if (*type == '\"')\n+    {\n+      for (type++; *type++ != '\"';)\n+\t/* do nothing */;\n+    }\n   switch(*type) {\n   case _C_ID:\n     return __alignof__(id);\n@@ -210,6 +275,14 @@ objc_alignof_type(const char* type)\n     return __alignof__(unsigned long);\n     break;\n \n+  case _C_LNG_LNG:\n+    return __alignof__(long long);\n+    break;\n+\n+  case _C_ULNG_LNG:\n+    return __alignof__(unsigned long long);\n+    break;\n+\n   case _C_FLT:\n     return __alignof__(float);\n     break;\n@@ -227,15 +300,18 @@ objc_alignof_type(const char* type)\n   case _C_ARY_B:\n     while (isdigit(*++type)) /* do nothing */;\n     return objc_alignof_type (type);\n-      \n+\n   case _C_STRUCT_B:\n     {\n-      struct { int x; double y; } fooalign;\n-      while(*type != _C_STRUCT_E && *type++ != '=') /* do nothing */;\n-      if (*type != _C_STRUCT_E)\n-\treturn MAX (objc_alignof_type (type), __alignof__ (fooalign));\n-      else\n-\treturn __alignof__ (fooalign);\n+      struct objc_struct_layout layout;\n+      unsigned int align;\n+\n+      objc_layout_structure (type, &layout);\n+      while (objc_layout_structure_next_member (&layout))\n+        /* do nothing */;\n+      objc_layout_finish_structure (&layout, NULL, &align);\n+\n+      return align;\n     }\n \n   case _C_UNION_B:\n@@ -244,14 +320,23 @@ objc_alignof_type(const char* type)\n       while (*type != _C_UNION_E && *type++ != '=') /* do nothing */;\n       while (*type != _C_UNION_E)\n \t{\n+\t  /* Skip the variable name if any */\n+\t  if (*type == '\"')\n+\t    {\n+\t      for (type++; *type++ != '\"';)\n+\t\t/* do nothing */;\n+\t    }\n \t  maxalign = MAX (maxalign, objc_alignof_type (type));\n \t  type = objc_skip_typespec (type);\n \t}\n       return maxalign;\n     }\n-    \n+\n   default:\n-    objc_error(nil, OBJC_ERR_BAD_TYPE, \"unknown type %s\\n\", type);\n+    {\n+      objc_error(nil, OBJC_ERR_BAD_TYPE, \"unknown type %s\\n\", type);\n+      return 0;\n+    }\n   }\n }\n \n@@ -262,8 +347,18 @@ objc_alignof_type(const char* type)\n int\n objc_aligned_size (const char* type)\n {\n-  int size = objc_sizeof_type (type);\n-  int align = objc_alignof_type (type);\n+  int size, align;\n+\n+  /* Skip the variable name */\n+  if (*type == '\"')\n+    {\n+      for (type++; *type++ != '\"';)\n+\t/* do nothing */;\n+    }\n+\n+  size = objc_sizeof_type (type);\n+  align = objc_alignof_type (type);\n+\n   return ROUND (size, align);\n }\n \n@@ -275,8 +370,17 @@ objc_aligned_size (const char* type)\n int \n objc_promoted_size (const char* type)\n {\n-  int size = objc_sizeof_type (type);\n-  int wordsize = sizeof (void*);\n+  int size, wordsize;\n+\n+  /* Skip the variable name */\n+  if (*type == '\"')\n+    {\n+      for (type++; *type++ != '\"';)\n+\t/* do nothing */;\n+    }\n+\n+  size = objc_sizeof_type (type);\n+  wordsize = sizeof (void*);\n \n   return ROUND (size, wordsize);\n }\n@@ -294,7 +398,8 @@ objc_skip_type_qualifiers (const char* type)\n \t || *type == _C_INOUT\n \t || *type == _C_OUT \n \t || *type == _C_BYCOPY\n-\t || *type == _C_ONEWAY)\n+\t || *type == _C_ONEWAY\n+\t || *type == _C_GCINVISIBLE)\n     {\n       type += 1;\n     }\n@@ -310,6 +415,13 @@ objc_skip_type_qualifiers (const char* type)\n const char* \n objc_skip_typespec (const char* type)\n {\n+  /* Skip the variable name if any */\n+  if (*type == '\"')\n+    {\n+      for (type++; *type++ != '\"';)\n+\t/* do nothing */;\n+    }\n+\n   type = objc_skip_type_qualifiers (type);\n   \n   switch (*type) {\n@@ -339,6 +451,8 @@ objc_skip_typespec (const char* type)\n   case _C_UINT:\n   case _C_LNG:\n   case _C_ULNG:\n+  case _C_LNG_LNG:\n+  case _C_ULNG_LNG:\n   case _C_FLT:\n   case _C_DBL:\n   case _C_VOID:\n@@ -354,7 +468,16 @@ objc_skip_typespec (const char* type)\n     if (*type == _C_ARY_E)\n       return ++type;\n     else\n-      objc_error(nil, OBJC_ERR_BAD_TYPE, \"bad array type %s\\n\", type);\n+      {\n+\tobjc_error(nil, OBJC_ERR_BAD_TYPE, \"bad array type %s\\n\", type);\n+\treturn 0;\n+      }\n+\n+  case _C_BFLD:\n+    /* The new encoding of bitfields is: b 'position' 'type' 'size' */\n+    while (isdigit (*++type));\t/* skip position */\n+    while (isdigit (*++type));\t/* skip type and size */\n+    return type;\n \n   case _C_STRUCT_B:\n     /* skip name, and elements until closing '}'  */\n@@ -376,7 +499,10 @@ objc_skip_typespec (const char* type)\n     return objc_skip_typespec (++type);\n     \n   default:\n-    objc_error(nil, OBJC_ERR_BAD_TYPE, \"unknown type %s\\n\", type);\n+    {\n+      objc_error(nil, OBJC_ERR_BAD_TYPE, \"unknown type %s\\n\", type);\n+      return 0;\n+    }\n   }\n }\n \n@@ -526,14 +652,261 @@ objc_get_type_qualifiers (const char* type)\n   while (flag)\n     switch (*type++)\n       {\n-      case _C_CONST:  res |= _F_CONST; break;\n-      case _C_IN:     res |= _F_IN; break;\n-      case _C_INOUT:  res |= _F_INOUT; break;\n-      case _C_OUT:    res |= _F_OUT; break;\n-      case _C_BYCOPY: res |= _F_BYCOPY; break;\n-      case _C_ONEWAY: res |= _F_ONEWAY; break;\n+      case _C_CONST:\tres |= _F_CONST; break;\n+      case _C_IN:\tres |= _F_IN; break;\n+      case _C_INOUT:\tres |= _F_INOUT; break;\n+      case _C_OUT:\tres |= _F_OUT; break;\n+      case _C_BYCOPY:\tres |= _F_BYCOPY; break;\n+      case _C_ONEWAY:\tres |= _F_ONEWAY; break;\n+      case _C_GCINVISIBLE: res |= _F_GCINVISIBLE; break;\n       default: flag = NO;\n     }\n \n   return res;\n }\n+\n+\n+/* The following three functions can be used to determine how a\n+   structure is laid out by the compiler. For example:\n+\n+  struct objc_struct_layout layout;\n+  int i;\n+\n+  objc_layout_structure (type, &layout);\n+  while (objc_layout_structure_next_member (&layout))\n+    {\n+      int position, align;\n+      const char *type;\n+\n+      objc_layout_structure_get_info (&layout, &position, &align, &type);\n+      printf (\"element %d has offset %d, alignment %d\\n\",\n+              i++, position, align);\n+    }\n+\n+  These functions are used by objc_sizeof_type and objc_alignof_type\n+  functions to compute the size and alignment of structures. The\n+  previous method of computing the size and alignment of a structure\n+  was not working on some architectures, particulary on AIX, and in\n+  the presence of bitfields inside the structure. */\n+void\n+objc_layout_structure (const char *type,\n+                           struct objc_struct_layout *layout)\n+{\n+  const char *ntype;\n+\n+  if (*type++ != _C_STRUCT_B)\n+    {\n+      objc_error(nil, OBJC_ERR_BAD_TYPE,\n+                 \"record type expected in objc_layout_structure, got %s\\n\",\n+                 type);\n+    }\n+\n+  layout->original_type = type;\n+\n+  /* Skip \"<name>=\" if any. Avoid embedded structures and unions. */\n+  ntype = type;\n+  while (*ntype != _C_STRUCT_E && *ntype != _C_STRUCT_B && *ntype != _C_UNION_B\n+         && *ntype++ != '=')\n+    /* do nothing */;\n+\n+  /* If there's a \"<name>=\", ntype - 1 points to '='; skip the the name */\n+  if (*(ntype - 1) == '=')\n+    type = ntype;\n+\n+  layout->type = type;\n+  layout->prev_type = NULL;\n+  layout->record_size = 0;\n+  layout->record_align = BITS_PER_UNIT;\n+\n+#ifdef STRUCTURE_SIZE_BOUNDARY\n+  layout->record_align = MAX (layout->record_align, STRUCTURE_SIZE_BOUNDARY);\n+#endif\n+}\n+\n+\n+BOOL\n+objc_layout_structure_next_member (struct objc_struct_layout *layout)\n+{\n+  register int known_align = layout->record_size;\n+  register int desired_align = 0;\n+\n+  /* The following are used only if the field is a bitfield */\n+  register const char *bfld_type;\n+  register int bfld_type_size, bfld_type_align, bfld_field_size;\n+\n+  /* The current type without the type qualifiers */\n+  const char *type;\n+\n+#if 1\n+  if (layout->prev_type == NULL)\n+    {\n+      layout->prev_type = layout->type;\n+      layout->type = objc_skip_typespec (layout->prev_type);\n+      return YES;\n+    }\n+#endif\n+\n+  /* Add the size of the previous field to the size of the record.  */\n+  if (layout->prev_type)\n+    {\n+      type = objc_skip_type_qualifiers (layout->prev_type);\n+\n+      if (*type != _C_BFLD)\n+        layout->record_size += objc_sizeof_type (type) * BITS_PER_UNIT;\n+      else {\n+        desired_align = 1;\n+        /* Get the bitfield's type */\n+        for (bfld_type = type + 1;\n+             isdigit(*bfld_type);\n+             bfld_type++)\n+          /* do nothing */;\n+\n+        bfld_type_size = objc_sizeof_type (bfld_type) * BITS_PER_UNIT;\n+        bfld_type_align = objc_alignof_type (bfld_type) * BITS_PER_UNIT;\n+        bfld_field_size = atoi (objc_skip_typespec (bfld_type));\n+        layout->record_size += bfld_field_size;\n+      }\n+    }\n+\n+  if (*layout->type == _C_STRUCT_E)\n+    return NO;\n+\n+  /* Skip the variable name if any */\n+  if (*layout->type == '\"')\n+    {\n+      for (layout->type++; *layout->type++ != '\"';)\n+        /* do nothing */;\n+    }\n+\n+  type = objc_skip_type_qualifiers (layout->type);\n+\n+  if (*type != _C_BFLD)\n+    desired_align = objc_alignof_type(type) * BITS_PER_UNIT;\n+  else\n+    {\n+      desired_align = 1;\n+      /* Skip the bitfield's offset */\n+      for (bfld_type = type + 1; isdigit(*bfld_type); bfld_type++)\n+        /* do nothing */;\n+\n+      bfld_type_size = objc_sizeof_type (bfld_type) * BITS_PER_UNIT;\n+      bfld_type_align = objc_alignof_type (bfld_type) * BITS_PER_UNIT;\n+      bfld_field_size = atoi (objc_skip_typespec (bfld_type));\n+    }\n+\n+#ifdef BIGGEST_FIELD_ALIGNMENT\n+  desired_align = MIN (desired_align, BIGGEST_FIELD_ALIGNMENT);\n+#endif\n+#ifdef ADJUST_FIELD_ALIGN\n+  desired_align = ADJUST_FIELD_ALIGN (type, desired_align);\n+#endif\n+\n+  /* Record must have at least as much alignment as any field.\n+     Otherwise, the alignment of the field within the record\n+     is meaningless.  */\n+#ifndef PCC_BITFIELD_TYPE_MATTERS\n+  layout->record_align = MAX (layout->record_align, desired_align);\n+#else\n+  if (*type == _C_BFLD)\n+    {\n+      /* For these machines, a zero-length field does not\n+         affect the alignment of the structure as a whole.\n+         It does, however, affect the alignment of the next field\n+         within the structure.  */\n+      if (bfld_field_size)\n+        layout->record_align = MAX (layout->record_align, desired_align);\n+      else\n+        desired_align = objc_alignof_type (bfld_type) * BITS_PER_UNIT;\n+\n+      /* A named bit field of declared type `int'\n+         forces the entire structure to have `int' alignment.\n+         Q1: How is encoded this thing and how to check for it?\n+         Q2: How to determine maximum_field_alignment at runtime? */\n+\n+/*\t  if (DECL_NAME (field) != 0) */\n+      {\n+        int type_align = bfld_type_align;\n+#if 0\n+        if (maximum_field_alignment != 0)\n+          type_align = MIN (type_align, maximum_field_alignment);\n+        else if (DECL_PACKED (field))\n+          type_align = MIN (type_align, BITS_PER_UNIT);\n+#endif\n+\n+        layout->record_align = MAX (layout->record_align, type_align);\n+      }\n+    }\n+  else\n+    layout->record_align = MAX (layout->record_align, desired_align);\n+#endif\n+\n+  /* Does this field automatically have alignment it needs\n+     by virtue of the fields that precede it and the record's\n+     own alignment?  */\n+\n+  if (*type == _C_BFLD)\n+    layout->record_size = atoi (type + 1);\n+  else if (layout->record_size % desired_align != 0)\n+    {\n+      /* No, we need to skip space before this field.\n+         Bump the cumulative size to multiple of field alignment.  */\n+      layout->record_size = ROUND (layout->record_size, desired_align);\n+    }\n+  \n+  /* Jump to the next field in record. */\n+\n+  layout->prev_type = layout->type;\n+  layout->type = objc_skip_typespec (layout->type);      /* skip component */\n+\n+  return YES;\n+}\n+\n+\n+void objc_layout_finish_structure (struct objc_struct_layout *layout,\n+                                   unsigned int *size,\n+                                   unsigned int *align)\n+{\n+  if (layout->type && *layout->type == _C_STRUCT_E)\n+    {\n+      /* Work out the alignment of the record as one expression and store\n+         in the record type.  Round it up to a multiple of the record's\n+         alignment. */\n+\n+#ifdef ROUND_TYPE_ALIGN\n+      layout->record_align = ROUND_TYPE_ALIGN (layout->original_type,\n+                                               1,\n+                                               layout->record_align);\n+#else\n+      layout->record_align = MAX (1, layout->record_align);\n+#endif\n+\n+#ifdef ROUND_TYPE_SIZE\n+      layout->record_size = ROUND_TYPE_SIZE (layout->original_type,\n+                                             layout->record_size,\n+                                             layout->record_align);\n+#else\n+      /* Round the size up to be a multiple of the required alignment */\n+      layout->record_size = ROUND (layout->record_size, layout->record_align);\n+#endif\n+\n+      layout->type = NULL;\n+    }\n+  if (size)\n+    *size = layout->record_size / BITS_PER_UNIT;\n+  if (align)\n+    *align = layout->record_align / BITS_PER_UNIT;\n+}\n+\n+\n+void objc_layout_structure_get_info (struct objc_struct_layout *layout,\n+                                     unsigned int *offset,\n+                                     unsigned int *align,\n+                                     const char **type)\n+{\n+  if (offset)\n+    *offset = layout->record_size / BITS_PER_UNIT;\n+  if (align)\n+    *align = layout->record_align / BITS_PER_UNIT;\n+  if (type)\n+    *type = layout->prev_type;\n+}"}, {"sha": "cbbc8de7ef5ce76d8ad970f6c550264d4dfd7ba7", "filename": "gcc/objc/encoding.h", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2Fencoding.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2Fencoding.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fencoding.h?ref=d8bb17c8e33975277dd5231e190bf99451b7025d", "patch": "@@ -32,26 +32,28 @@ Boston, MA 02111-1307, USA.  */\n #include <ctype.h>\n #include \"objc/objc-api.h\"\n \n-#define _C_CONST    'r'\n-#define _C_IN       'n'\n-#define _C_INOUT    'N'\n-#define _C_OUT      'o'\n-#define _C_BYCOPY   'O'\n-#define _C_ONEWAY   'V'\n-\n-#define _F_CONST    0x01\n-#define _F_IN       0x01\n-#define _F_OUT      0x02\n-#define _F_INOUT    0x03\n-#define _F_BYCOPY   0x04\n-#define _F_ONEWAY   0x08\n-\n+#define _C_CONST\t'r'\n+#define _C_IN\t\t'n'\n+#define _C_INOUT\t'N'\n+#define _C_OUT      \t'o'\n+#define _C_BYCOPY\t'O'\n+#define _C_ONEWAY\t'V'\n+#define _C_GCINVISIBLE\t'!'\n+\n+#define _F_CONST\t0x01\n+#define _F_IN\t\t0x01\n+#define _F_OUT\t\t0x02\n+#define _F_INOUT\t0x03\n+#define _F_BYCOPY\t0x04\n+#define _F_ONEWAY\t0x08\n+#define _F_GCINVISIBLE\t0x10\n \n int objc_aligned_size (const char* type);\n int objc_sizeof_type (const char* type);\n int objc_alignof_type (const char* type);\n int objc_aligned_size (const char* type);\n int objc_promoted_size (const char* type);\n+\n const char* objc_skip_type_qualifiers (const char* type);\n const char* objc_skip_typespec (const char* type);\n const char* objc_skip_offset (const char* type);\n@@ -72,4 +74,24 @@ char* method_get_nth_argument (struct objc_method* m,\n unsigned objc_get_type_qualifiers (const char* type);\n \n \n+struct objc_struct_layout \n+{\n+  const char *original_type;\n+  const char *type;\n+  const char *prev_type;\n+  unsigned int record_size;\n+  unsigned int record_align;\n+};\n+\n+void objc_layout_structure (const char *type,\n+                            struct objc_struct_layout *layout);\n+BOOL  objc_layout_structure_next_member (struct objc_struct_layout *layout);\n+void objc_layout_finish_structure (struct objc_struct_layout *layout,\n+                                   unsigned int *size,\n+                                   unsigned int *align);\n+void objc_layout_structure_get_info (struct objc_struct_layout *layout,\n+                                     unsigned int *offset,\n+                                     unsigned int *align,\n+                                     const char **type);\n+\n #endif /* __encoding_INCLUDE_GNU */"}, {"sha": "8abf493e20a8106389ebc1e7c794b982ba3b1d6a", "filename": "gcc/objc/gc.c", "status": "added", "additions": 458, "deletions": 0, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2Fgc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2Fgc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fgc.c?ref=d8bb17c8e33975277dd5231e190bf99451b7025d", "patch": "@@ -0,0 +1,458 @@\n+/* Basic data types for Objective C.\n+   Copyright (C) 1998 Free Software Foundation, Inc.\n+   Contributed by Ovidiu Predescu.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* As a special exception, if you link this library with files\n+   compiled with GCC to produce an executable, this does not cause\n+   the resulting executable to be covered by the GNU General Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file might be covered by the GNU General Public License.  */\n+\n+#include \"../tconfig.h\"\n+#include \"objc.h\"\n+#include \"encoding.h\"\n+\n+#include <assert.h>\n+#include <string.h>\n+\n+#if OBJC_WITH_GC\n+\n+#include <gc.h>\n+\n+/* gc_typed.h uses the following but doesn't declare them */\n+typedef GC_word word;\n+typedef GC_signed_word signed_word;\n+\n+#if BITS_PER_WORD == 32\n+# define LOGWL\t5\n+# define modWORDSZ(n) ((n) & 0x1f)        /* n mod size of word\t    */\n+#endif\n+\n+#if BITS_PER_WORD == 64\n+# define LOGWL 6\n+# define modWORDSZ(n) ((n) & 0x3f)        /* n mod size of word\t    */\n+#endif\n+\n+#define divWORDSZ(n) ((n) >> LOGWL)\t   /* divide n by size of word      */\n+\n+#include <gc_typed.h>\n+\n+/* The following functions set up in `mask` the corresponding pointers.\n+   The offset is incremented with the size of the type.  */\n+\n+#define ROUND(V, A) \\\n+  ({ typeof(V) __v=(V); typeof(A) __a=(A); \\\n+     __a*((__v+__a-1)/__a); })\n+\n+#define SET_BIT_FOR_OFFSET(mask, offset) \\\n+  GC_set_bit(mask, offset / sizeof (void*))\n+\n+/* Some prototypes */\n+static void\n+__objc_gc_setup_struct (GC_bitmap mask, const char *type, int offset);\n+static void\n+__objc_gc_setup_union (GC_bitmap mask, const char *type, int offset);\n+\n+\n+static void\n+__objc_gc_setup_array (GC_bitmap mask, const char *type, int offset)\n+{\n+  int i, len = atoi(type + 1);\n+\n+  while (isdigit(*++type))\n+    /* do nothing */;\t\t/* skip the size of the array */\n+\n+  switch (*type) {\n+  case _C_ARY_B:\n+    for (i = 0; i < len; i++)\n+      __objc_gc_setup_array (mask, type, offset);\n+    break;\n+\n+  case _C_STRUCT_B:\n+    for (i = 0; i < len; i++)\n+      __objc_gc_setup_struct (mask, type, offset);\n+    break;\n+\n+  case _C_UNION_B:\n+    for (i = 0; i < len; i++)\n+      __objc_gc_setup_union (mask, type, offset);\n+    break;\n+\n+  default:\n+    break;\n+  }\n+}\n+\n+static void\n+__objc_gc_setup_struct (GC_bitmap mask, const char *type, int offset)\n+{\n+  struct objc_struct_layout layout;\n+  unsigned int position;\n+  const char *mtype;\n+\n+  objc_layout_structure (type, &layout);\n+\n+  while (objc_layout_structure_next_member (&layout))\n+    {\n+      BOOL gc_invisible = NO;\n+\n+      objc_layout_structure_get_info (&layout, &position, NULL, &mtype);\n+\n+      /* Skip the variable name */\n+      if (*mtype == '\"')\n+\t{\n+\t  for (mtype++; *mtype++ != '\"';)\n+\t    /* do nothing */;\n+\t}\n+\n+      if (*mtype == _C_GCINVISIBLE)\n+\t{\n+\t  gc_invisible = YES;\n+\t  mtype++;\n+\t}\n+\n+      /* Add to position the offset of this structure */\n+      position += offset;\n+\n+      switch (*mtype) {\n+      case _C_ID:\n+      case _C_CLASS:\n+      case _C_SEL:\n+      case _C_PTR:\n+      case _C_CHARPTR:\n+      case _C_ATOM:\n+\tif (!gc_invisible)\n+\t  SET_BIT_FOR_OFFSET(mask, position);\n+\tbreak;\n+\n+      case _C_ARY_B:\n+\t__objc_gc_setup_array (mask, mtype, position);\n+\tbreak;\n+\n+      case _C_STRUCT_B:\n+\t__objc_gc_setup_struct (mask, mtype, position);\n+\tbreak;\n+\n+      case _C_UNION_B:\n+\t__objc_gc_setup_union (mask, mtype, position);\n+\tbreak;\n+\n+      default:\n+        break;\n+      }\n+    }\n+}\n+\n+static void\n+__objc_gc_setup_union (GC_bitmap mask, const char *type, int offset)\n+{\n+  /* Sub-optimal, quick implementation: assume the union is made of\n+     pointers, set up the mask accordingly. */\n+\n+  int i, size, align;\n+\n+  /* Skip the variable name */\n+  if (*type == '\"')\n+    {\n+      for (type++; *type++ != '\"';)\n+\t/* do nothing */;\n+    }\n+\n+  size = objc_sizeof_type (type);\n+  align = objc_alignof_type (type);\n+\n+  offset = ROUND(offset, align);\n+  for (i = 0; i < size; i += sizeof (void*))\n+    {\n+      SET_BIT_FOR_OFFSET(mask, offset);\n+      offset += sizeof (void*);\n+    }\n+}\n+\n+\n+/* Iterates over the types in the structure that represents the class\n+   encoding and sets the bits in mask according to each ivar type.  */\n+static void\n+__objc_gc_type_description_from_type (GC_bitmap mask, const char *type)\n+{\n+  struct objc_struct_layout layout;\n+  unsigned int offset, align;\n+  const char *ivar_type;\n+\n+  objc_layout_structure (type, &layout);\n+\n+  while (objc_layout_structure_next_member (&layout))\n+    {\n+      BOOL gc_invisible = NO;\n+\n+      objc_layout_structure_get_info (&layout, &offset, &align, &ivar_type);\n+\n+      /* Skip the variable name */\n+      if (*ivar_type == '\"')\n+\t{\n+\t  for (ivar_type++; *ivar_type++ != '\"';)\n+\t    /* do nothing */;\n+\t}\n+\n+      if (*ivar_type == _C_GCINVISIBLE)\n+\t{\n+\t  gc_invisible = YES;\n+\t  ivar_type++;\n+\t}\n+\n+      switch (*ivar_type) {\n+      case _C_ID:\n+      case _C_CLASS:\n+      case _C_SEL:\n+      case _C_PTR:\n+      case _C_CHARPTR:\n+        if (!gc_invisible)\n+          SET_BIT_FOR_OFFSET(mask, offset);\n+\tbreak;\n+\n+      case _C_ARY_B:\n+\t__objc_gc_setup_array (mask, ivar_type, offset);\n+\tbreak;\n+\n+      case _C_STRUCT_B:\n+\t__objc_gc_setup_struct (mask, ivar_type, offset);\n+\tbreak;\n+\n+      case _C_UNION_B:\n+\t__objc_gc_setup_union (mask, ivar_type, offset);\n+\tbreak;\n+\n+      default:\n+        break;\n+      }\n+    }\n+}\n+\n+/* Computes in *type the full type encoding of this class including\n+   its super classes. '*size' gives the total number of bytes allocated\n+   into *type, '*current' the number of bytes used so far by the\n+   encoding. */\n+static void\n+__objc_class_structure_encoding (Class class, char **type, int *size,\n+                                 int *current)\n+{\n+  int i, ivar_count;\n+  struct objc_ivar_list* ivars;\n+\n+  if (!class)\n+    {\n+      strcat (*type, \"{\");\n+      *current++;\n+      return;\n+    }\n+\n+  /* Add the type encodings of the super classes */\n+  __objc_class_structure_encoding (class->super_class, type, size, current);\n+\n+  ivars = class->ivars;\n+  if (!ivars)\n+    return;\n+\n+  ivar_count = ivars->ivar_count;\n+\n+  for (i = 0; i < ivar_count; i++)\n+    {\n+      struct objc_ivar *ivar = &(ivars->ivar_list[i]);\n+      const char *ivar_type = ivar->ivar_type;\n+      int len = strlen (ivar_type);\n+\n+      if (*current + len + 1 >= *size)\n+        {\n+          /* Increase the size of the encoding string so that it\n+             contains this ivar's type. */\n+          *size = ROUND(*current + len + 1, 10);\n+          *type = objc_realloc (*type, *size);\n+        }\n+      strcat (*type + *current, ivar_type);\n+      *current += len;\n+    }\n+}\n+\n+\n+/* Allocates the memory that will hold the type description for class\n+   and calls the __objc_class_structure_encoding that generates this\n+   value. */\n+void\n+__objc_generate_gc_type_description (Class class)\n+{\n+  GC_bitmap mask;\n+  int bits_no, size;\n+  int type_size = 10, current;\n+  char *class_structure_type;\n+\n+  if (!CLS_ISCLASS(class))\n+    return;\n+\n+  /* We have to create a mask in which each bit counts for a pointer member.\n+     We take into consideration all the non-pointer instance variables and we\n+     round them up to the alignment. */\n+\n+  /* The number of bits in the mask is the size of an instance in bytes divided\n+     by the size of a pointer. */\n+  bits_no = (ROUND(class_get_instance_size (class), sizeof(void*))\n+             / sizeof (void*));\n+  size = ROUND(bits_no, BITS_PER_WORD) / BITS_PER_WORD;\n+  mask = objc_atomic_malloc (size * sizeof (int));\n+  memset (mask, 0, size * sizeof (int));\n+\n+  class_structure_type = objc_atomic_malloc (type_size);\n+  *class_structure_type = current = 0;\n+  __objc_class_structure_encoding (class, &class_structure_type,\n+                                   &type_size, &current);\n+  if (current + 1 == type_size)\n+    class_structure_type = objc_realloc (class_structure_type, ++type_size);\n+  strcat (class_structure_type + current, \"}\");\n+//  printf (\"type description for '%s' is %s\\n\", class->name, class_structure_type);\n+  \n+  __objc_gc_type_description_from_type (mask, class_structure_type);\n+  objc_free (class_structure_type);\n+\n+#define DEBUG 1\n+#ifdef DEBUG\n+  printf (\"  mask for '%s', type '%s' (bits %d, mask size %d) is:\",\n+\t  class_structure_type, class->name, bits_no, size);\n+  {\n+    int i;\n+    for (i = 0; i < size; i++)\n+      printf (\" %lx\", mask[i]);\n+  }\n+  puts (\"\");\n+#endif\n+\n+  class->gc_object_type = (void*)GC_make_descriptor (mask, bits_no);\n+}\n+\n+\n+/* Returns YES if type denotes a pointer type, NO otherwise */\n+static inline BOOL\n+__objc_ivar_pointer (const char *type)\n+{\n+  type = objc_skip_type_qualifiers (type);\n+\n+  return (*type == _C_ID\n+          || *type == _C_CLASS\n+          || *type == _C_SEL\n+          || *type == _C_PTR\n+          || *type == _C_CHARPTR\n+          || *type == _C_ATOM);\n+}\n+\n+\n+/* Mark the instance variable whose name is given by ivarname as a\n+   weak pointer (a pointer hidden to the garbage collector) if\n+   gc_invisible is true. If gc_invisible is false it unmarks the\n+   instance variable and makes it a normal pointer, visible to the\n+   garbage collector.\n+\n+   This operation only makes sense on instance variables that are\n+   pointers.  */\n+void\n+class_ivar_set_gcinvisible (Class class, const char* ivarname,\n+                            BOOL gc_invisible)\n+{\n+  int i, ivar_count;\n+  struct objc_ivar_list* ivars;\n+\n+  if (!class || !ivarname)\n+    return;\n+\n+  ivars = class->ivars;\n+  if (!ivars)\n+    return;\n+\n+  ivar_count = ivars->ivar_count;\n+\n+  for (i = 0; i < ivar_count; i++)\n+    {\n+      struct objc_ivar *ivar = &(ivars->ivar_list[i]);\n+      const char *type;\n+\n+      if (!ivar->ivar_name || strcmp (ivar->ivar_name, ivarname))\n+\tcontinue;\n+\n+      assert (ivar->ivar_type);\n+      type = ivar->ivar_type;\n+\n+      /* Skip the variable name */\n+      if (*type == '\"')\n+\t{\n+\t  for (type++; *type++ != '\"';)\n+\t    /* do nothing */;\n+\t}\n+\n+      if (*type == _C_GCINVISIBLE)\n+\t{\n+\t  char *new_type;\n+\n+\t  if (gc_invisible || !__objc_ivar_pointer (type))\n+\t    return;\t/* The type of the variable already matches the\n+\t\t\t   requested gc_invisible type */\n+\n+\t  /* The variable is gc_invisible and we have to reverse it */\n+\t  new_type = objc_atomic_malloc (strlen (ivar->ivar_type));\n+\t  strncpy (new_type, ivar->ivar_type,\n+\t\t   (size_t)(type - ivar->ivar_type));\n+\t  strcat (new_type, type + 1);\n+\t  ivar->ivar_type = new_type;\n+\t}\n+      else\n+\t{\n+\t  char *new_type;\n+\n+\t  if (!gc_invisible || !__objc_ivar_pointer (type))\n+\t    return;\t/* The type of the variable already matches the\n+\t\t\t   requested gc_invisible type */\n+\n+\t  /* The variable is gc visible and we have to make it gc_invisible */\n+\t  new_type = objc_malloc (strlen (ivar->ivar_type) + 2);\n+\t  strncpy (new_type, ivar->ivar_type,\n+\t\t   (size_t)(type - ivar->ivar_type));\n+\t  strcat (new_type, \"!\");\n+\t  strcat (new_type, type);\n+\t  ivar->ivar_type = new_type;\n+\t}\n+\n+      __objc_generate_gc_type_description (class);\n+      return;\n+    }\n+\n+  /* Search the instance variable in the superclasses */\n+  class_ivar_set_gcinvisible (class->super_class, ivarname, gc_invisible);\n+}\n+\n+#else /* !OBJC_WITH_GC */\n+\n+void\n+__objc_generate_gc_type_description (Class class)\n+{\n+}\n+\n+void class_ivar_set_gcinvisible (Class class,\n+\t\t\t\t const char* ivarname,\n+\t\t\t\t BOOL gc_invisible)\n+{\n+}\n+\n+#endif /* OBJC_WITH_GC */"}, {"sha": "7339888dc280dca19e6b5d2c018e6b2169154e85", "filename": "gcc/objc/misc.c", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fmisc.c?ref=d8bb17c8e33975277dd5231e190bf99451b7025d", "patch": "@@ -1,6 +1,6 @@\n /* GNU Objective C Runtime Miscellaneous \n    Copyright (C) 1993, 1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n-   Contrbuted by Kresten Krab Thorup\n+   Contributed by Kresten Krab Thorup\n \n This file is part of GNU CC.\n \n@@ -144,9 +144,37 @@ objc_free(void *mem)\n ** Users should call the normal objc routines above for\n ** memory allocation and disposal within their programs.\n */\n+\n+#if OBJC_WITH_GC\n+#include <gc.h>\n+\n+static void *GC_calloc (size_t nelem, size_t size)\n+{\n+  void* p = GC_malloc (nelem * size);\n+  if (!p)\n+    objc_error (nil, OBJC_ERR_MEMORY, \"Virtual memory exhausted!\\n\");\n+\n+  memset (p, 0, nelem * size);\n+  return p;\n+}\n+\n+static void noFree (void* p) {}\n+\n+void *(*_objc_malloc)(size_t) = GC_malloc;\n+void *(*_objc_atomic_malloc)(size_t) = GC_malloc_atomic;\n+void *(*_objc_valloc)(size_t) = GC_malloc;\n+void *(*_objc_realloc)(void *, size_t) = GC_realloc;\n+void *(*_objc_calloc)(size_t, size_t) = GC_calloc;\n+void (*_objc_free)(void *) = noFree;\n+\n+#else\n+\n void *(*_objc_malloc)(size_t) = malloc;\n void *(*_objc_atomic_malloc)(size_t) = malloc;\n void *(*_objc_valloc)(size_t) = malloc;\n void *(*_objc_realloc)(void *, size_t) = realloc;\n void *(*_objc_calloc)(size_t, size_t) = calloc;\n void (*_objc_free)(void *) = free;\n+\n+\n+#endif"}, {"sha": "0dc5ef0539874b8dcb0a4a5704b277404729bde5", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 103, "deletions": 9, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=d8bb17c8e33975277dd5231e190bf99451b7025d", "patch": "@@ -3380,6 +3380,7 @@ build_selector_template ()\n        struct objc_class *sibling_class;\n      }\n      struct objc_protocol_list *protocols;\n+     void *gc_object_type;\n    };  */\n \n static void\n@@ -3515,6 +3516,21 @@ build_class_template ()\n \t\t\t  decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n+  /* void *sel_id; */\n+\n+  decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_VOID]);\n+  field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"sel_id\"));\n+  field_decl\n+    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  chainon (field_decl_chain, field_decl);\n+\n+  /* void *gc_object_type; */\n+\n+  decl_specs = build_tree_list (NULL_TREE, ridpointers[(int) RID_VOID]);\n+  field_decl = build1 (INDIRECT_REF, NULL_TREE, get_identifier (\"gc_object_type\"));\n+  field_decl\n+    = grokfield (input_filename, lineno, field_decl, decl_specs, NULL_TREE);\n+  chainon (field_decl_chain, field_decl);\n \n   finish_struct (objc_class_template, field_decl_chain, NULL_TREE);\n }\n@@ -4287,6 +4303,7 @@ build_category_initializer (type, cat_name, class_name,\n        struct objc_class *sibling_class;\n      }\n      struct objc_protocol_list *protocols;\n+     void *gc_object_type;\n    };  */\n \n static tree\n@@ -4377,6 +4394,9 @@ build_shared_structure_initializer (type, isa, super, name, size, status,\n      initlist = tree_cons (NULL_TREE, expr, initlist);\n      }\n \n+  /* gc_object_type = NULL */\n+  initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), initlist);\n+\n   return build_constructor (type, nreverse (initlist));\n }\n \n@@ -6818,6 +6838,62 @@ encode_type (type, curtype, format)\n     obstack_1grow (&util_obstack, '?');\n }\n \n+static void\n+encode_complete_bitfield (int position, tree type, int size)\n+{\n+  enum tree_code code = TREE_CODE (type);\n+  char buffer[40];\n+  char charType = '?';\n+\n+  if (code == INTEGER_TYPE)\n+    {\n+      if (TREE_INT_CST_LOW (TYPE_MIN_VALUE (type)) == 0\n+\t  && TREE_INT_CST_HIGH (TYPE_MIN_VALUE (type)) == 0)\n+\t{\n+\t  /* Unsigned integer types.  */\n+\n+\t  if (TYPE_MODE (type) == QImode)\n+\t    charType = 'C';\n+\t  else if (TYPE_MODE (type) == HImode)\n+\t    charType = 'S';\n+\t  else if (TYPE_MODE (type) == SImode)\n+\t    {\n+\t      if (type == long_unsigned_type_node)\n+\t\tcharType = 'L';\n+\t      else\n+\t\tcharType = 'I';\n+\t    }\n+\t  else if (TYPE_MODE (type) == DImode)\n+\t    charType = 'Q';\n+\t}\n+\n+      else\n+\t/* Signed integer types.  */\n+\t{\n+\t  if (TYPE_MODE (type) == QImode)\n+\t    charType = 'c';\n+\t  else if (TYPE_MODE (type) == HImode)\n+\t    charType = 's';\n+\t  else if (TYPE_MODE (type) == SImode)\n+\t    {\n+\t      if (type == long_integer_type_node)\n+\t\tcharType = 'l';\n+\t      else\n+\t\tcharType = 'i';\n+\t    }\n+\n+\t  else if (TYPE_MODE (type) == DImode)\n+\t    charType = 'q';\n+\t}\n+    }\n+\n+  else\n+    abort ();\n+\n+  sprintf (buffer, \"b%d%c%d\", position, charType, size);\n+  obstack_grow (&util_obstack, buffer, strlen (buffer));\n+}\n+\n static void\n encode_field_decl (field_decl, curtype, format)\n      tree field_decl;\n@@ -6826,18 +6902,36 @@ encode_field_decl (field_decl, curtype, format)\n {\n   tree type;\n \n- /* If this field is obviously a bitfield, or is a bitfield that has been\n+  type = TREE_TYPE (field_decl);\n+\n+  /* If this field is obviously a bitfield, or is a bitfield that has been\n      clobbered to look like a ordinary integer mode, go ahead and generate\n      the bitfield typing information.  */\n-  type = TREE_TYPE (field_decl);\n-  if (DECL_BIT_FIELD (field_decl))\n-    encode_bitfield (DECL_FIELD_SIZE (field_decl), format);\n-  else if (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n-\t   && DECL_FIELD_SIZE (field_decl)\n-\t   && TYPE_MODE (type) > DECL_MODE (field_decl))\n-    encode_bitfield (DECL_FIELD_SIZE (field_decl), format);\n+  if (flag_next_runtime)\n+    {\n+      if (DECL_BIT_FIELD (field_decl))\n+\tencode_bitfield (DECL_FIELD_SIZE (field_decl), format);\n+      else if (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n+\t       && DECL_FIELD_SIZE (field_decl)\n+\t       && TYPE_MODE (type) > DECL_MODE (field_decl))\n+\tencode_bitfield (DECL_FIELD_SIZE (field_decl), format);\n+      else\n+\tencode_type (TREE_TYPE (field_decl), curtype, format);\n+    }\n   else\n-    encode_type (TREE_TYPE (field_decl), curtype, format);\n+    {\n+      if (DECL_BIT_FIELD (field_decl)\n+\t  || (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n+\t      && DECL_FIELD_SIZE (field_decl)\n+\t      && TYPE_MODE (type) > DECL_MODE (field_decl)))\n+\t{\n+\t  encode_complete_bitfield (TREE_INT_CST_LOW (DECL_FIELD_BITPOS (field_decl)),\n+\t\t\t\t    DECL_BIT_FIELD_TYPE (field_decl),\n+\t\t\t\t    DECL_FIELD_SIZE (field_decl));\n+\t}\n+      else\n+\tencode_type (TREE_TYPE (field_decl), curtype, format);\n+    }\n }\n \n static tree"}, {"sha": "fe34dafb89568916475cfa63de33d60a11cfa560", "filename": "gcc/objc/objc-api.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2Fobjc-api.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2Fobjc-api.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-api.h?ref=d8bb17c8e33975277dd5231e190bf99451b7025d", "patch": "@@ -59,6 +59,8 @@ struct objc_method_description\n #define _C_UINT     'I'\n #define _C_LNG      'l'\n #define _C_ULNG     'L'\n+#define _C_LNG_LNG  'q'\n+#define _C_ULNG_LNG 'Q'\n #define _C_FLT      'f'\n #define _C_DBL      'd'\n #define _C_BFLD     'b'\n@@ -495,6 +497,17 @@ class_set_version(Class class, long version)\n     class->version = version;\n }\n \n+static inline void *\n+class_get_gc_object_type (Class class)\n+{\n+  return CLS_ISCLASS(class) ? class->gc_object_type : NULL;\n+}\n+\n+/* Mark the instance variable as innaccessible to the garbage collector */\n+extern void class_ivar_set_gcinvisible (Class class,\n+\t\t\t\t\tconst char* ivarname,\n+\t\t\t\t\tBOOL gcInvisible);\n+\n static inline IMP\n method_get_imp(Method_t method)\n {"}, {"sha": "ec3b5a6284de66fdca9181fdc78721e017b6ffc5", "filename": "gcc/objc/objc-features.texi", "status": "added", "additions": 392, "deletions": 0, "changes": 392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2Fobjc-features.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2Fobjc-features.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-features.texi?ref=d8bb17c8e33975277dd5231e190bf99451b7025d", "patch": "@@ -0,0 +1,392 @@\n+\\input texinfo  @c -*-texinfo-*-\n+@c %**start of header \n+@setfilename objc-features.info\n+@settitle GNU Objective-C runtime features\n+@setchapternewpage odd\n+@c %**end of header\n+     \n+@node Top, Executing code before main, , (dir), (dir)\n+@comment  node-name,  next,  previous,  up\n+\n+@chapter GNU Objective-C runtime features\n+\n+This document is meant to describe some of the GNU Objective-C runtime\n+features. It is not intended to teach you Objective-C, there are several\n+resources on the Internet that present the language.  Questions and\n+comments about this document to Ovidiu Predescu\n+@code{<ovidiu@@aracnet.com>}.\n+\n+@menu\n+* Executing code before main::\n+* Type encoding::\n+* Garbage Collection::\n+@end menu\n+\n+\n+@node Executing code before main, What you can and what you cannot do in +load, Top, Top\n+@section @code{+load}: Executing code before main\n+\n+\n+The GNU Objective-C runtime provides a way that allows you to execute\n+code before the execution of the program enters the @code{main}\n+function. The code is executed on a per-class and a per-category basis,\n+through a special class method @code{+load}.\n+\n+This facility is very useful if you want to initialize global variables\n+which can be accessed by the program directly, without sending a message\n+to the class first. The usual way to initialize global variables, in the\n+@code{+initialize} method, might not be useful because\n+@code{+initialize} is only called when the first message is sent to a\n+class object, which in some cases could be too late.\n+\n+Suppose for example you have a @code{FileStream} class that declares\n+@code{Stdin}, @code{Stdout} and @code{Stderr} as global variables, like\n+below:\n+\n+@example\n+            \n+FileStream *Stdin = nil;                                              \n+FileStream *Stdout = nil;                                          \n+FileStream *Stderr = nil;                                                \n+            \n+@@implementation FileStream                                               \n+          \n++ (void)initialize                                                 \n+@{\n+    Stdin = [[FileStream new] initWithFd:0];                           \n+    Stdout = [[FileStream new] initWithFd:1];                           \n+    Stderr = [[FileStream new] initWithFd:2];\n+@}\n+ \n+/* Other methods here */\n+@@end\n+\n+@end example\n+\n+In this example, the initialization of @code{Stdin}, @code{Stdout} and\n+@code{Stderr} in @code{+initialize} occurs too late. The programmer can\n+send a message to one of these objects before the variables are actually\n+initialized, thus sending messages to the @code{nil} object. The\n+@code{+initialize} method which actually initializes the global\n+variables is not invoked until the first message is sent to the class\n+object. The solution would require these variables to be initialized\n+just before entering @code{main}.\n+\n+The correct solution of the above problem is to use the @code{+load}\n+method instead of @code{+initialize}:\n+\n+@example\n+\n+@@implementation FileStream                                             \n+ \n++ (void)load                                 \n+@{\n+    Stdin = [[FileStream new] initWithFd:0];\n+    Stdout = [[FileStream new] initWithFd:1];\n+    Stderr = [[FileStream new] initWithFd:2];\n+@}\n+ \n+/* Other methods here */                                               \n+@@end\n+\n+@end example\n+ \n+The @code{+load} is a method that is not overridden by categories. If a\n+class and a category of it both implement @code{+load}, both methods are\n+invoked.  This allows some additional initializations to be performed in\n+a category.\n+   \n+This mechanism is not intended to be a replacement for @code{+initialize}.\n+You should be aware of its limitations when you decide to use it\n+instead of @code{+initialize}.\n+\n+@menu\n+* What you can and what you cannot do in +load::\n+@end menu\n+\n+\n+@node What you can and what you cannot do in +load, Type encoding, Executing code before main, Executing code before main\n+@subsection What you can and what you cannot do in @code{+load}\n+\n+The +load implementation in the GNU runtime guarantees you the following\n+things:\n+\n+@itemize @bullet\n+\n+@item\n+you can write whatever C code you like;\n+\n+@item\n+you can send messages to Objective-C constant strings (@@\"this is a\n+constant string\");\n+\n+@item\n+you can allocate and send messages to objects whose class is implemented\n+in the same file;\n+\n+@item\n+the @code{+load} implementation of all super classes of a class are executed before the @code{+load} of that class is executed;\n+\n+@item\n+the @code{+load} implementation of a class is executed before the\n+@code{+load} implementation of any category.\n+\n+@end itemize\n+\n+In particular, the following things, even if they can work in a\n+particular case, are not guaranteed:\n+\n+@itemize @bullet\n+\n+@item\n+allocation of or sending messages to arbitrary objects;\n+\n+@item\n+allocation of or sending messages to objects whose classes have a\n+category implemented in the same file;\n+\n+@end itemize\n+\n+You should make no assumptions about receiving @code{+load} in sibling\n+classes when you write @code{+load} of a class. The order in which\n+sibling classes receive @code{+load} is not guaranteed.\n+    \n+The order in which @code{+load} and @code{+initialize} are called could\n+be problematic if this matters. If you don't allocate objects inside\n+@code{+load}, it is guaranteed that @code{+load} is called before\n+@code{+initialize}. If you create an object inside @code{+load} the\n+@code{+initialize} method of object's class is invoked even if\n+@code{+load} was not invoked. Note if you explicitly call @code{+load}\n+on a class, @code{+initialize} will be called first. To avoid possible\n+problems try to implement only one of these methods.\n+\n+The @code{+load} method is also invoked when a bundle is dynamically\n+loaded into your running program. This happens automatically without any\n+intervening operation from you. When you write bundles and you need to\n+write @code{+load} you can safely create and send messages to objects whose\n+classes already exist in the running program. The same restrictions as\n+above apply to classes defined in bundle.\n+\n+\n+\n+@node Type encoding, Garbage Collection, What you can and what you cannot do in +load, Top\n+@section Type encoding\n+\n+The Objective-C compiler generates type encodings for all the\n+types. These type encodings are used at runtime to find out information\n+about selectors and methods and about objects and classes.\n+\n+The types are encoded in the following way:\n+\n+@c @sp 1\n+\n+@multitable @columnfractions .25 .75\n+@item @code{char}                      \n+@tab @code{c}\n+@item @code{unsigned char}             \n+@tab @code{C}\n+@item @code{short}                     \n+@tab @code{s}\n+@item @code{unsigned short}            \n+@tab @code{S}\n+@item @code{int}                       \n+@tab @code{i}\n+@item @code{unsigned int}              \n+@tab @code{I}\n+@item @code{long}                      \n+@tab @code{l}\n+@item @code{unsigned long}             \n+@tab @code{L}\n+@item @code{long long}                 \n+@tab @code{q}\n+@item @code{unsigned long long}        \n+@tab @code{Q}\n+@item @code{float}                     \n+@tab @code{f}\n+@item @code{double}                    \n+@tab @code{d}\n+@item @code{void}                      \n+@tab @code{v}\n+@item @code{id}                        \n+@tab @code{@@}\n+@item @code{Class}                     \n+@tab @code{#}\n+@item @code{SEL}                       \n+@tab @code{:}\n+@item @code{char*}                     \n+@tab @code{*}\n+@item unknown type                     \n+@tab @code{?}\n+@item bitfields                 \n+@tab @code{b} followed by the starting position of the bitfield, the type of the bitfield and the size of the bitfield (the bitfields encoding was changed from the NeXT's compiler encoding, see below)\n+@end multitable\n+\n+@c @sp 1\n+\n+The encoding of bitfields has changed to allow bitfields to be properly\n+handled by the runtime functions that compute sizes and alignments of\n+types that contain bitfields. The previous encoding contained only the\n+size of the bitfield. Using only this information it is not possible to\n+reliably compute the size occupied by the bitfield. This is very\n+important in the presence of the Boehm's garbage collector because the\n+objects are allocated using the typed memory facility available in this\n+collector. The typed memory allocation requires information about where\n+the pointers are located inside the object.\n+\n+The position in the bitfield is the position, counting in bits, of the\n+bit closest to the beginning of the structure.\n+\n+The non-atomic types are encoded as follows:\n+\n+@c @sp 1\n+\n+@multitable @columnfractions .2 .8\n+@item pointers          \n+@tab @code{'^'} followed by the pointed type.\n+@item arrays\n+@tab @code{'['} followed by the number of elements in the array followed by the type of the elements followed by @code{']'}\n+@item structures\n+@tab @code{'@{'} followed by the name of the structure (or '?' if the structure is unnamed), the '=' sign, the type of the members and by @code{'@}'}\n+@item unions\n+@tab @code{'('} followed by the name of the structure (or '?' if the union is unnamed), the '=' sign, the type of the members followed by @code{')'}\n+@end multitable\n+\n+Here are some types and their encodings, as they are generated by the\n+compiler on a i386 machine:\n+\n+@sp 1\n+\n+@multitable @columnfractions .25 .75\n+@item Objective-C type\n+@tab Compiler encoding\n+@item\n+@example\n+int a[10];\n+@end example\n+@tab @code{[10i]}\n+@item\n+@example\n+struct @{\n+  int i;\n+  float f[3];\n+  int a:3;\n+  int b:2;\n+  char c;\n+@}\n+@end example\n+@tab @code{@{?=i[3f]b128i3b131i2c@}}\n+@end multitable\n+\n+@sp 1\n+\n+In addition to the types the compiler also encodes the type\n+specifiers. The table below describes the encoding of the current\n+Objective-C type specifiers:\n+\n+@sp 1\n+\n+@multitable @columnfractions .25 .75\n+@item Specifier\n+@tab Encoding\n+@item @code{const}              \n+@tab @code{r}\n+@item @code{in}                 \n+@tab @code{n}\n+@item @code{inout}              \n+@tab @code{N}\n+@item @code{out}                \n+@tab @code{o}\n+@item @code{bycopy}             \n+@tab @code{O}\n+@item @code{oneway}             \n+@tab @code{V}\n+@end multitable\n+\n+@sp 1\n+\n+The type specifiers are encoded just before the type. Unlike types\n+however, the type specifiers are only encoded when they appear in method\n+argument types.\n+\n+\n+@node Garbage Collection, , Type encoding, Top\n+\n+@page\n+@section Garbage Collection\n+\n+Support for a new memory management policy has been added by using a\n+powerful conservative garbage collector, known as the\n+Boehm-Demers-Weiser conservative garbage collector. It is available from\n+@w{@url{http://reality.sgi.com/employees/boehm_mti/gc.html}}.\n+\n+To enable the support for it you have to configure the compiler using an\n+additional argument, @w{@kbd{--enable-objc-gc}}. You need to have\n+garbage collector installed before building the compiler. This will\n+build an additional runtime library which has several enhancements to\n+support the garbage collector. The new library has a new name,\n+@kbd{libobjc_gc.a} to not conflict with the non-garbage-collected\n+library.\n+\n+When the garbage collector is used, the objects are allocated using the\n+so-called typed memory allocation mechanism available in the\n+Boehm-Demers-Weiser collector. This mode requires precise information on\n+where pointers are located inside objects. This information is computed\n+once per class, immediately after the class has been initialized.\n+\n+There is a new runtime function @code{class_ivar_set_gcinvisible()}\n+which can be used to declare a so-called @strong{weak pointer}\n+reference. Such a pointer is basically hidden for the garbage collector;\n+this can be useful in certain situations, especially when you want to\n+keep track of the allocated objects, yet allow them to be\n+collected. This kind of pointers can only be members of objects, you\n+cannot declare a global pointer as a weak reference. Every type which is\n+a pointer type can be declared a weak pointer, including @code{id},\n+@code{Class} and @code{SEL}.\n+\n+Here is an example of how to use this feature. Suppose you want to\n+implement a class whose instances hold a weak pointer reference; the\n+following class does this:\n+\n+@example\n+\n+@@interface WeakPointer : Object\n+@{\n+    const void* weakPointer;\n+@}\n+\n+- initWithPointer:(const void*)p;\n+- (const void*)weakPointer;\n+@@end\n+\n+\n+@@implementation WeakPointer\n+\n++ (void)initialize\n+@{\n+  class_ivar_set_gcinvisible (self, \"weakPointer\", YES);\n+@}\n+\n+- initWithPointer:(const void*)p\n+@{\n+  weakPointer = p;\n+  return self;\n+@}\n+\n+- (const void*)weakPointer\n+@{\n+  return weakPointer;\n+@}\n+\n+@@end\n+\n+@end example\n+\n+Weak pointers are supported through a new type character specifier\n+represented by the @code{'!'} character. The\n+@code{class_ivar_set_gcinvisible()} function adds or removes this\n+specifier to the string type description of the instance variable named\n+as argument.\n+\n+\n+@bye\n+"}, {"sha": "79b2519e5765a223ab267a2d2171869af43f1fd2", "filename": "gcc/objc/objc.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2Fobjc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2Fobjc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc.h?ref=d8bb17c8e33975277dd5231e190bf99451b7025d", "patch": "@@ -126,6 +126,7 @@ struct objc_class {\n   struct objc_class* sibling_class;\n \n   struct objc_protocol_list *protocols;\t      /* Protocols conformed to */\n+  void* gc_object_type;\n };\n \n #ifndef __OBJC__"}, {"sha": "d079c5d4ec78be5dab523d1d93dde2c3a8ff9c37", "filename": "gcc/objc/objects.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2Fobjects.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2Fobjects.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjects.c?ref=d8bb17c8e33975277dd5231e190bf99451b7025d", "patch": "@@ -25,8 +25,13 @@ Boston, MA 02111-1307, USA.  */\n    covered by the GNU General Public License.  */\n \n #include \"../tconfig.h\"         /* include defs of bzero for target */\n+#include \"objc.h\"\n #include \"runtime.h\"\t\t/* the kitchen sink */\n \n+#if OBJC_WITH_GC\n+# include <gc.h>\n+#endif\n+\n id __objc_object_alloc(Class);\n id __objc_object_dispose(id);\n id __objc_object_copy(id);\n@@ -39,8 +44,16 @@ id\n class_create_instance(Class class)\n {\n   id new = nil;\n+\n+#if OBJC_WITH_GC\n+  if (CLS_ISCLASS(class))\n+    new = (id)GC_malloc_explicitly_typed (class->instance_size,\n+\t\t\t\t\t  class->gc_object_type);\n+#else\n   if (CLS_ISCLASS(class))\n     new = (*_objc_object_alloc)(class);\n+#endif\n+\n   if (new!=nil)\n     {\n       memset (new, 0, class->instance_size);"}, {"sha": "17f8b97401367f181c61e51448dd8f05a5638735", "filename": "gcc/objc/sendmsg.c", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2Fsendmsg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8bb17c8e33975277dd5231e190bf99451b7025d/gcc%2Fobjc%2Fsendmsg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fsendmsg.c?ref=d8bb17c8e33975277dd5231e190bf99451b7025d", "patch": "@@ -244,10 +244,7 @@ __objc_init_install_dtable(id receiver, SEL op)\n       /* Install real dtable for factory methods */\n       __objc_install_dispatch_table_for_class (receiver->class_pointer);\n \n-      if (strcmp (sel_get_name (op), \"initialize\"))\n-\t__objc_send_initialize((Class)receiver);\n-      else\n-\tCLS_SETINITIALIZED((Class)receiver);\n+      __objc_send_initialize((Class)receiver);\n     }\n   objc_mutex_unlock(__objc_runtime_mutex);\n }\n@@ -273,36 +270,36 @@ __objc_send_initialize(Class class)\n     {\n       CLS_SETINITIALIZED(class);\n       CLS_SETINITIALIZED(class->class_pointer);\n-      \n+\n+      /* Create the garbage collector type memory description */\n+      __objc_generate_gc_type_description (class);\n+\n       if(class->super_class)\n \t__objc_send_initialize(class->super_class);\n \n       {\n-\tSEL \top = sel_register_name (\"initialize\");\n-\tClass\ttmpclass = class;\n-\tIMP\timp = 0;\n-\n-\twhile (!imp && tmpclass) {\n-\t  MethodList_t method_list = tmpclass->class_pointer->methods;\n-\n-\t  while(!imp && method_list) {\n-\t    int i;\n-\t    Method_t method;\n-\n-\t    for (i=0;i<method_list->method_count;i++) {\n-\t      method = &(method_list->method_list[i]);\n-\t      if (method->method_name\n-\t\t  && method->method_name->sel_id == op->sel_id) {\n-\t        imp = method->method_imp;\n-\t        break;\n-\t      }\n-\t    }\n+\tSEL \t     op = sel_register_name (\"initialize\");\n+\tIMP\t     imp = 0;\n+        MethodList_t method_list = class->class_pointer->methods;\n+\n+        while (method_list) {\n+\t  int i;\n+          Method_t method;\n+\n+          for (i = 0; i< method_list->method_count; i++) {\n+\t    method = &(method_list->method_list[i]);\n+            if (method->method_name\n+                && method->method_name->sel_id == op->sel_id) {\n+\t      imp = method->method_imp;\n+              break;\n+            }\n+          }\n \n-\t    method_list = method_list->method_next;\n+          if (imp)\n+            break;\n \n-\t  }\n+          method_list = method_list->method_next;\n \n-\t  tmpclass = tmpclass->super_class;\n \t}\n \tif (imp)\n \t    (*imp)((id)class, op);"}]}