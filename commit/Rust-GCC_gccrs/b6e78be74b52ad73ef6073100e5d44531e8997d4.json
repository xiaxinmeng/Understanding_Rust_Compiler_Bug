{"sha": "b6e78be74b52ad73ef6073100e5d44531e8997d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZlNzhiZTc0YjUyYWQ3M2VmNjA3MzEwMGU1ZDQ0NTMxZTg5OTdkNA==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1995-05-18T02:25:40Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1995-05-18T02:25:40Z"}, "message": "(DATA_ALIGNMENT): Define.\n\n(ROUND_TYPE_ALIGN): Align XFmode scalars at 128 bit boundaries.\n(ROUND_TYPE_SIZE): Round up the size of XFmode objects to 128 bits.\n(CONST_DOUBLE_OK_FOR_LETTER_P): Use CONST0_RTX and CONST1_RTX\nso that all FP modes are recognized.\n(ASM_OUTPUT_LONG_DOUBLE): Define.\n\nFrom-SVN: r9739", "tree": {"sha": "d50333542bb4c69c5089255b71c2d5ee5fede674", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d50333542bb4c69c5089255b71c2d5ee5fede674"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6e78be74b52ad73ef6073100e5d44531e8997d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6e78be74b52ad73ef6073100e5d44531e8997d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6e78be74b52ad73ef6073100e5d44531e8997d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6e78be74b52ad73ef6073100e5d44531e8997d4/comments", "author": null, "committer": null, "parents": [{"sha": "37aba8501fbdfcd17b1d7852e45c4cced24c6216", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37aba8501fbdfcd17b1d7852e45c4cced24c6216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37aba8501fbdfcd17b1d7852e45c4cced24c6216"}], "stats": {"total": 37, "additions": 26, "deletions": 11}, "files": [{"sha": "9a6d660f973ea522ca5a137d10a70d15f15678f3", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6e78be74b52ad73ef6073100e5d44531e8997d4/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6e78be74b52ad73ef6073100e5d44531e8997d4/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=b6e78be74b52ad73ef6073100e5d44531e8997d4", "patch": "@@ -307,7 +307,7 @@ extern int target_flags;\n /* Target machine storage layout.  */\n \n /* Define for cross-compilation from a host with a different float format\n-   or endianness (e.g. VAX, x86).  */\n+   or endianess, as well as to support 80 bit long doubles on the i960.  */\n #define REAL_ARITHMETIC\n \n /* Define this if most significant bit is lowest numbered\n@@ -386,16 +386,28 @@ extern int target_flags;\n    ? i960_object_bytes_bitalign (int_size_in_bytes (TREE_TYPE (EXP)))\t    \\\n    : (ALIGN))\n \n+/* Make XFmode floating point quantities be 128 bit aligned.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\t\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\t\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == XFmode\t\t\t\t\\\n+   && (ALIGN) < 128 ? 128 : (ALIGN))\n+\n /* Macros to determine size of aggregates (structures and unions\n    in C).  Normally, these may be defined to simply return the maximum\n    alignment and simple rounded-up size, but on some machines (like\n    the i960), the total size of a structure is based on a non-trivial\n    rounding method.  */\n \n #define ROUND_TYPE_ALIGN(TYPE, COMPUTED, SPECIFIED)\t\t\\\n-  ((!TARGET_OLD_ALIGN && TREE_CODE (TYPE) == RECORD_TYPE)\t\\\n-   ? i960_round_align (MAX ((COMPUTED), (SPECIFIED)), TYPE_SIZE (TYPE)) \\\n-   : MAX ((COMPUTED), (SPECIFIED)))\n+  ((TREE_CODE (TYPE) == REAL_TYPE && TYPE_MODE (TYPE) == XFmode)\t   \\\n+   ? 128  /* Put 80 bit floating point elements on 128 bit boundaries.  */ \\\n+   : ((!TARGET_OLD_ALIGN && TREE_CODE (TYPE) == RECORD_TYPE)\t\t   \\\n+      ? i960_round_align (MAX ((COMPUTED), (SPECIFIED)), TYPE_SIZE (TYPE)) \\\n+      : MAX ((COMPUTED), (SPECIFIED))))\n+\n+#define ROUND_TYPE_SIZE(TYPE, COMPUTED, SPECIFIED)\t\t\\\n+  ((TREE_CODE (TYPE) == REAL_TYPE && TYPE_MODE (TYPE) == XFmode)\t\\\n+   ? build_int_2 (128, 0) : (COMPUTED))\n \f\n /* Standard register usage.  */\n \n@@ -478,7 +490,7 @@ extern int target_flags;\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    On 80960, the cpu registers can hold any mode but the float registers\n-   can only hold SFmode, DFmode, or TFmode.  */\n+   can only hold SFmode, DFmode, or XFmode.  */\n extern unsigned int hard_regno_mode_ok[FIRST_PSEUDO_REGISTER];\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n   ((hard_regno_mode_ok[REGNO] & (1 << (int) (MODE))) != 0)\n@@ -645,12 +657,10 @@ enum reg_class { NO_REGS, GLOBAL_REGS, LOCAL_REGS, LOCAL_OR_GLOBAL_REGS,\n    Here VALUE is the CONST_DOUBLE rtx itself.\n    For the 80960, G is 0.0 and H is 1.0.  */\n \n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\\\n-  ((TARGET_NUMERICS) &&\t\t\t\t\t\\\n-   (((C) == 'G' && ((VALUE) == CONST0_RTX (DFmode)\t\\\n-\t\t    || (VALUE) == CONST0_RTX (SFmode))) \\\n-    || ((C) == 'H' && ((VALUE) == CONST1_RTX (DFmode)\t\\\n-\t\t       || (VALUE) == CONST1_RTX (SFmode)))))\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\t\t\\\n+  ((TARGET_NUMERICS) &&\t\t\t\t\t\t\t\\\n+   (((C) == 'G' && (VALUE) == CONST0_RTX (GET_MODE (VALUE)))\t\t\\\n+    || ((C) == 'H' && ((VALUE) == CONST1_RTX (GET_MODE (VALUE))))))\n \n /* Given an rtx X being reloaded into a reg required to be\n    in class CLASS, return the class of reg to actually use.\n@@ -1269,6 +1279,11 @@ extern struct rtx_def *gen_compare_reg ();\n #define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n   sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n \n+/* This is how to output an assembler line defining a `long double'\n+   constant.  */\n+\n+#define ASM_OUTPUT_LONG_DOUBLE(FILE,VALUE) i960_output_long_double(FILE, VALUE)\n+\n /* This is how to output an assembler line defining a `double' constant.  */\n \n #define ASM_OUTPUT_DOUBLE(FILE,VALUE)  i960_output_double(FILE, VALUE)"}]}