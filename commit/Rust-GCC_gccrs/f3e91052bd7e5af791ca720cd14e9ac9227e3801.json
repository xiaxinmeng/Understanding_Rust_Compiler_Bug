{"sha": "f3e91052bd7e5af791ca720cd14e9ac9227e3801", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNlOTEwNTJiZDdlNWFmNzkxY2E3MjBjZDE0ZTlhYzkyMjdlMzgwMQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-07-03T21:04:45Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-07-03T21:04:45Z"}, "message": "P0556R3 Integral power-of-2 operations, P0553R2 Bit operations\n\nP0553R2 is not in the C++2a working draft yet, but is likely to be\napproved soon. Neither proposal supports std::byte but this adds\noverloads of each function for std::byte, assuming that will also get\nadded.\n\n\t* include/Makefile.am: Add new header.\n\t* include/Makefile.in: Regenerate.\n\t* include/precompiled/stdc++.h: Include new header.\n\t* include/std/bit: New header.\n\t(__rotl, __rotr, __countl_zero, __countl_one, __countr_zero)\n\t(__countr_one, __popcount, __ispow2, __ceil2, __floor2, __log2p1):\n\tDefine for C++14.\n\t[!__STRICT_ANSI__] (rotl, rotr, countl_zero, countl_one, countr_zero)\n\t(countr_one, popcount): Define for C++2a. Also overload for std::byte.\n\t(ispow2, ceil2, floor2, log2p1): Define for C++2a.\n\t[!__STRICT_ANSI__] (ispow2, ceil2, floor2, log2p1): Overload for\n\tstd::byte.\n\t* testsuite/26_numerics/bit/bit.pow.two/ceil2.cc: New.\n\t* testsuite/26_numerics/bit/bit.pow.two/floor2.cc: New.\n\t* testsuite/26_numerics/bit/bit.pow.two/ispow2.cc: New.\n\t* testsuite/26_numerics/bit/bit.pow.two/log2p1.cc: New.\n\t* testsuite/26_numerics/bit/bitops.rot/rotl.cc: New.\n\t* testsuite/26_numerics/bit/bitops.rot/rotr.cc: New.\n\t* testsuite/26_numerics/bit/bitops.count/countl_one.cc: New.\n\t* testsuite/26_numerics/bit/bitops.count/countl_zero.cc: New.\n\t* testsuite/26_numerics/bit/bitops.count/countr_one.cc: New.\n\t* testsuite/26_numerics/bit/bitops.count/countr_zero.cc: New.\n\nFrom-SVN: r262360", "tree": {"sha": "93c8036d608b1b66477816d43343955cc80e6940", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93c8036d608b1b66477816d43343955cc80e6940"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3e91052bd7e5af791ca720cd14e9ac9227e3801", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3e91052bd7e5af791ca720cd14e9ac9227e3801", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3e91052bd7e5af791ca720cd14e9ac9227e3801", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3e91052bd7e5af791ca720cd14e9ac9227e3801/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf3e6e9f15e11273083517ebfd7d0a94213d70f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf3e6e9f15e11273083517ebfd7d0a94213d70f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf3e6e9f15e11273083517ebfd7d0a94213d70f5"}], "stats": {"total": 1525, "additions": 1525, "deletions": 0}, "files": [{"sha": "f6c39b6361c4273358ebea5986b4fe68bde9321f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=f3e91052bd7e5af791ca720cd14e9ac9227e3801", "patch": "@@ -1,5 +1,29 @@\n 2018-07-03  Jonathan Wakely  <jwakely@redhat.com>\n \n+\tP0556R3 Integral power-of-2 operations, P0553R2 Bit operations\n+\t* include/Makefile.am: Add new header.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/precompiled/stdc++.h: Include new header.\n+\t* include/std/bit: New header.\n+\t(__rotl, __rotr, __countl_zero, __countl_one, __countr_zero)\n+\t(__countr_one, __popcount, __ispow2, __ceil2, __floor2, __log2p1):\n+\tDefine for C++14.\n+\t[!__STRICT_ANSI__] (rotl, rotr, countl_zero, countl_one, countr_zero)\n+\t(countr_one, popcount): Define for C++2a. Also overload for std::byte.\n+\t(ispow2, ceil2, floor2, log2p1): Define for C++2a.\n+\t[!__STRICT_ANSI__] (ispow2, ceil2, floor2, log2p1): Overload for\n+\tstd::byte.\n+\t* testsuite/26_numerics/bit/bit.pow.two/ceil2.cc: New.\n+\t* testsuite/26_numerics/bit/bit.pow.two/floor2.cc: New.\n+\t* testsuite/26_numerics/bit/bit.pow.two/ispow2.cc: New.\n+\t* testsuite/26_numerics/bit/bit.pow.two/log2p1.cc: New.\n+\t* testsuite/26_numerics/bit/bitops.rot/rotl.cc: New.\n+\t* testsuite/26_numerics/bit/bitops.rot/rotr.cc: New.\n+\t* testsuite/26_numerics/bit/bitops.count/countl_one.cc: New.\n+\t* testsuite/26_numerics/bit/bitops.count/countl_zero.cc: New.\n+\t* testsuite/26_numerics/bit/bitops.count/countr_one.cc: New.\n+\t* testsuite/26_numerics/bit/bitops.count/countr_zero.cc: New.\n+\n \t* include/bits/alloc_traits.h: Remove redundant preprocessor\n \tcondition.\n "}, {"sha": "d1453a5abce7b5b65057a41ca4a704b5f36a8a9d", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=f3e91052bd7e5af791ca720cd14e9ac9227e3801", "patch": "@@ -30,6 +30,7 @@ std_headers = \\\n \t${std_srcdir}/any \\\n \t${std_srcdir}/array \\\n \t${std_srcdir}/atomic \\\n+\t${std_srcdir}/bit \\\n \t${std_srcdir}/bitset \\\n \t${std_srcdir}/charconv \\\n \t${std_srcdir}/chrono \\"}, {"sha": "1a4dbbf87167b53a057871894d2c1a8b9d3b08a5", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=f3e91052bd7e5af791ca720cd14e9ac9227e3801", "patch": "@@ -324,6 +324,7 @@ std_headers = \\\n \t${std_srcdir}/any \\\n \t${std_srcdir}/array \\\n \t${std_srcdir}/atomic \\\n+\t${std_srcdir}/bit \\\n \t${std_srcdir}/bitset \\\n \t${std_srcdir}/charconv \\\n \t${std_srcdir}/chrono \\"}, {"sha": "80769233eb3eb45bbe80155fbeaad0b7eb47758c", "filename": "libstdc++-v3/include/precompiled/stdc++.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprecompiled%2Fstdc%2B%2B.h?ref=f3e91052bd7e5af791ca720cd14e9ac9227e3801", "patch": "@@ -134,6 +134,7 @@\n #endif\n \n #if __cplusplus > 201703L\n+#include <bit>\n // #include <compare>\n // #include <span>\n // #include <syncstream>"}, {"sha": "76aa0957b5676e15800d870c0ed622fdc9ac242b", "filename": "libstdc++-v3/include/std/bit", "status": "added", "additions": 359, "deletions": 0, "changes": 359, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbit", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbit", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fbit?ref=f3e91052bd7e5af791ca720cd14e9ac9227e3801", "patch": "@@ -0,0 +1,359 @@\n+// <bit> -*- C++ -*-\n+\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/bit\n+ *  This is a Standard C++ Library header.\n+ */\n+\n+#ifndef _GLIBCXX_BIT\n+#define _GLIBCXX_BIT 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus >= 201402L\n+\n+#include <type_traits>\n+#include <limits>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  template<typename _Tp>\n+    constexpr _Tp\n+    __rotl(_Tp __x, unsigned int __s) noexcept\n+    {\n+      constexpr auto _Nd = numeric_limits<_Tp>::digits;\n+      const unsigned __sN = __s % _Nd;\n+      if (__sN)\n+        return (__x << __sN) | (__x >> (_Nd - __sN));\n+      return __x;\n+    }\n+\n+  template<typename _Tp>\n+    constexpr _Tp\n+    __rotr(_Tp __x, unsigned int __s) noexcept\n+    {\n+      constexpr auto _Nd = numeric_limits<_Tp>::digits;\n+      const unsigned __sN = __s % _Nd;\n+      if (__sN)\n+        return (__x >> __sN) | (__x << (_Nd - __sN));\n+      return __x;\n+    }\n+\n+  template<typename _Tp>\n+    constexpr int\n+    __countl_zero(_Tp __x) noexcept\n+    {\n+      using __limits = numeric_limits<_Tp>;\n+\n+      if (__x == 0)\n+        return __limits::digits;\n+\n+      using __limits_ull = numeric_limits<unsigned long long>;\n+      using __limits_ul = numeric_limits<unsigned long>;\n+      using __limits_u = numeric_limits<unsigned>;\n+\n+      if _GLIBCXX17_CONSTEXPR (__limits::digits <= __limits_u::digits)\n+\t{\n+\t  constexpr int __diff = __limits_u::digits - __limits::digits;\n+\t  return __builtin_clz(__x) - __diff;\n+\t}\n+      else if _GLIBCXX17_CONSTEXPR (__limits::digits <= __limits_ul::digits)\n+\t{\n+\t  constexpr int __diff = __limits_ul::digits - __limits::digits;\n+\t  return __builtin_clzl(__x) - __diff;\n+\t}\n+      else if _GLIBCXX17_CONSTEXPR (__limits::digits <= __limits_ull::digits)\n+\t{\n+\t  constexpr int __diff = __limits_ull::digits - __limits::digits;\n+\t  return __builtin_clzll(__x) - __diff;\n+\t}\n+      else // (__limits::digits > __limits_ull::digits)\n+\t{\n+\t  static_assert(__limits::digits <= (2 * __limits_ull::digits),\n+\t\t\t\"Maximum supported integer size is 128-bit\");\n+\n+\t  unsigned long long __high = __x >> __limits_ull::digits;\n+\t  if (__high != 0)\n+\t    {\n+\t      constexpr int __diff\n+\t\t= (2 * __limits_ull::digits) - __limits::digits;\n+\t      return __builtin_clzll(__high) - __diff;\n+\t    }\n+\t  unsigned long long __low = __x & __limits_ull::max();\n+\t  return (__limits::digits - __limits_ull::digits)\n+\t    + __builtin_clzll(__low);\n+\t}\n+    }\n+\n+  template<typename _Tp>\n+    constexpr int\n+    __countl_one(_Tp __x) noexcept\n+    {\n+      if (__x == numeric_limits<_Tp>::max())\n+        return numeric_limits<_Tp>::digits;\n+      return std::__countl_zero<_Tp>((_Tp)~__x);\n+    }\n+\n+  template<typename _Tp>\n+    constexpr int\n+    __countr_zero(_Tp __x) noexcept\n+    {\n+      using __limits = numeric_limits<_Tp>;\n+\n+      if (__x == 0)\n+        return __limits::digits;\n+\n+      using __limits_ull = numeric_limits<unsigned long long>;\n+      using __limits_ul = numeric_limits<unsigned long>;\n+      using __limits_u = numeric_limits<unsigned>;\n+\n+      if _GLIBCXX17_CONSTEXPR (__limits::digits <= __limits_u::digits)\n+\treturn __builtin_ctz(__x);\n+      else if _GLIBCXX17_CONSTEXPR (__limits::digits <= __limits_ul::digits)\n+\treturn __builtin_ctzl(__x);\n+      else if _GLIBCXX17_CONSTEXPR (__limits::digits <= __limits_ull::digits)\n+\treturn __builtin_ctzll(__x);\n+      else // (__limits::digits > __limits_ull::digits)\n+\t{\n+\t  static_assert(__limits::digits <= (2 * __limits_ull::digits),\n+\t\t\t\"Maximum supported integer size is 128-bit\");\n+\n+\t  unsigned long long __low = __x & __limits_ull::max();\n+\t  if (__low != 0)\n+\t    return __builtin_ctzll(__low);\n+\t  unsigned long long __high = __x >> __limits_ull::digits;\n+\t  return __builtin_ctzll(__high) + __limits_ull::digits;\n+\t}\n+    }\n+\n+  template<typename _Tp>\n+    constexpr int\n+    __countr_one(_Tp __x) noexcept\n+    {\n+      if (__x == numeric_limits<_Tp>::max())\n+        return numeric_limits<_Tp>::digits;\n+      return std::__countr_zero((_Tp)~__x);\n+    }\n+\n+  template<typename _Tp>\n+    constexpr int\n+    __popcount(_Tp __x) noexcept\n+    {\n+      using __limits = numeric_limits<_Tp>;\n+\n+      if (__x == 0)\n+        return 0;\n+\n+      using __limits_ull = numeric_limits<unsigned long long>;\n+      using __limits_ul = numeric_limits<unsigned long>;\n+      using __limits_u = numeric_limits<unsigned>;\n+\n+      if _GLIBCXX17_CONSTEXPR (__limits::digits <= __limits_u::digits)\n+\treturn __builtin_popcount(__x);\n+      else if _GLIBCXX17_CONSTEXPR (__limits::digits <= __limits_ul::digits)\n+\treturn __builtin_popcountl(__x);\n+      else if _GLIBCXX17_CONSTEXPR (__limits::digits <= __limits_ull::digits)\n+\treturn __builtin_popcountll(__x);\n+      else // (__limits::digits > __limits_ull::digits)\n+\t{\n+\t  static_assert(__limits::digits <= (2 * __limits_ull::digits),\n+\t\t\t\"Maximum supported integer size is 128-bit\");\n+\n+\t  unsigned long long __low = __x & __limits_ull::max();\n+\t  unsigned long long __high = __x >> __limits_ull::digits;\n+\t  return __builtin_popcountll(__low) + __builtin_popcountll(__high);\n+\t}\n+    }\n+\n+  template<typename _Tp>\n+    constexpr bool\n+    __ispow2(_Tp __x) noexcept\n+    { return std::__popcount(__x) == 1; }\n+\n+  template<typename _Tp>\n+    constexpr _Tp\n+    __ceil2(_Tp __x) noexcept\n+    {\n+      constexpr auto _Nd = numeric_limits<_Tp>::digits;\n+      if (__x == 0)\n+        return 1;\n+      return (_Tp)1u << (_Nd - std::__countl_zero((_Tp)(__x - 1u)));\n+    }\n+\n+  template<typename _Tp>\n+    constexpr _Tp\n+    __floor2(_Tp __x) noexcept\n+    {\n+      constexpr auto _Nd = numeric_limits<_Tp>::digits;\n+      if (__x == 0)\n+        return 0;\n+      return (_Tp)1u << (_Nd - std::__countl_zero((_Tp)(__x >> 1)));\n+    }\n+\n+  template<typename _Tp>\n+    constexpr _Tp\n+    __log2p1(_Tp __x) noexcept\n+    {\n+      constexpr auto _Nd = numeric_limits<_Tp>::digits;\n+      if (__x == 0)\n+\treturn 0;\n+      return _Nd - std::__countl_zero(__x);\n+    }\n+\n+#if __cplusplus > 201703L\n+\n+  template<typename _Tp, typename _Up, bool = is_integral_v<_Tp>>\n+    struct _If_is_unsigned_integer_type { };\n+\n+  template<typename _Up>\n+    struct _If_is_unsigned_integer_type<bool, _Up, true> { };\n+\n+  template<typename _Tp, typename _Up>\n+    struct _If_is_unsigned_integer_type<_Tp, _Up, true>\n+    : enable_if<is_same_v<_Tp, make_unsigned_t<_Tp>>, _Up> { };\n+\n+  template<typename _Tp, typename _Up = _Tp>\n+    using _If_is_unsigned_integer\n+      = typename _If_is_unsigned_integer_type<_Tp, _Up>::type;\n+\n+#if ! __STRICT_ANSI__\n+  // [bitops.rot], rotating\n+\n+  template<typename _Tp>\n+    constexpr _If_is_unsigned_integer<_Tp>\n+    rotl(_Tp __x, unsigned int __s) noexcept\n+    { return std::__rotl(__x, __s); }\n+\n+  template<typename _Tp>\n+    constexpr _If_is_unsigned_integer<_Tp>\n+    rotr(_Tp __x, unsigned int __s) noexcept\n+    { return std::__rotr(__x, __s); }\n+\n+  // [bitops.count], counting\n+\n+  template<typename _Tp>\n+    constexpr _If_is_unsigned_integer<_Tp, int>\n+    countl_zero(_Tp __x) noexcept\n+    { return std::__countl_zero(__x); }\n+\n+  template<typename _Tp>\n+    constexpr _If_is_unsigned_integer<_Tp, int>\n+    countl_one(_Tp __x) noexcept\n+    { return std::__countl_one(__x); }\n+\n+  template<typename _Tp>\n+    constexpr _If_is_unsigned_integer<_Tp, int>\n+    countr_zero(_Tp __x) noexcept\n+    { return std::__countr_zero(__x); }\n+\n+  template<typename _Tp>\n+    constexpr _If_is_unsigned_integer<_Tp, int>\n+    countr_one(_Tp __x) noexcept\n+    { return std::__countr_one(__x); }\n+\n+  template<typename _Tp>\n+    constexpr _If_is_unsigned_integer<_Tp, int>\n+    popcount(_Tp __x) noexcept\n+    { return std::__popcount(__x); }\n+#endif\n+\n+  // Integral power-of-two operations\n+\n+  template<typename _Tp>\n+    constexpr _If_is_unsigned_integer<_Tp, bool>\n+    ispow2(_Tp __x) noexcept\n+    { return std::__ispow2(__x); }\n+\n+  template<typename _Tp>\n+    constexpr _If_is_unsigned_integer<_Tp>\n+    ceil2(_Tp __x) noexcept\n+    { return std::__ceil2(__x); }\n+\n+  template<typename _Tp>\n+    constexpr _If_is_unsigned_integer<_Tp>\n+    floor2(_Tp __x) noexcept\n+    { return std::__floor2(__x); }\n+\n+  template<typename _Tp>\n+    constexpr _If_is_unsigned_integer<_Tp>\n+    log2p1(_Tp __x) noexcept\n+    { return std::__log2p1(__x); }\n+\n+#if ! __STRICT_ANSI__\n+  enum class byte : unsigned char;\n+\n+  constexpr byte\n+  rotl(byte __x, unsigned int __s) noexcept\n+  { return (byte)std::__rotl((unsigned char)__x, __s); }\n+\n+  constexpr byte\n+  rotr(byte __x, unsigned int __s) noexcept\n+  { return (byte)std::__rotr((unsigned char)__x, __s); }\n+\n+  constexpr int\n+  countl_zero(byte __x) noexcept\n+  { return std::__countl_zero((unsigned char)__x); }\n+\n+  constexpr int\n+  countl_one(byte __x) noexcept\n+  { return std::__countl_one((unsigned char)__x); }\n+\n+  constexpr int\n+  countr_zero(byte __x) noexcept\n+  { return std::__countr_zero((unsigned char)__x); }\n+\n+  constexpr int\n+  countr_one(byte __x) noexcept\n+  { return std::__countr_one((unsigned char)__x); }\n+\n+  constexpr int\n+  popcount(byte __x) noexcept\n+  { return std::__popcount((unsigned char)__x); }\n+\n+  constexpr bool\n+  ispow2(byte __x) noexcept\n+  { return std::__ispow2((unsigned char)__x); }\n+\n+  constexpr byte\n+  ceil2(byte __x) noexcept\n+  { return (byte)std::__ceil2((unsigned char)__x); }\n+\n+  constexpr byte\n+  floor2(byte __x) noexcept\n+  { return (byte)std::__floor2((unsigned char)__x); }\n+\n+  constexpr byte\n+  log2p1(byte __x) noexcept\n+  { return (byte)std::__log2p1((unsigned char)__x); }\n+#endif\n+\n+#endif // C++2a\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // C++14\n+#endif // _GLIBCXX_BIT"}, {"sha": "65e1569c2778eddfaee946f2a7d79fc98a48435a", "filename": "libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/ceil2.cc", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fceil2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fceil2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fceil2.cc?ref=f3e91052bd7e5af791ca720cd14e9ac9227e3801", "patch": "@@ -0,0 +1,108 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <bit>\n+\n+template<typename UInt>\n+constexpr auto\n+test(UInt x)\n+-> decltype(std::ceil2(x))\n+{\n+  static_assert( noexcept(std::ceil2(x)) );\n+\n+  static_assert( std::ceil2(UInt(0)) == 1 );\n+  static_assert( std::ceil2(UInt(1)) == 1 );\n+  static_assert( std::ceil2(UInt(2)) == 2 );\n+  static_assert( std::ceil2(UInt(3)) == 4 );\n+  static_assert( std::ceil2(UInt(4)) == 4 );\n+  static_assert( std::ceil2(UInt(0x11)) == 0x20 );\n+  static_assert( std::ceil2(UInt(0x20)) == 0x20 );\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 8)\n+  {\n+    static_assert( std::ceil2(UInt(0x201)) == 0x400 );\n+    static_assert( std::ceil2(UInt(0x8ff)) == 0x1000 );\n+    static_assert( std::ceil2(UInt(0x1000)) == 0x1000 );\n+  }\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 32)\n+  {\n+    static_assert( std::ceil2(UInt(0xabcdef)) == 0x1000000 );\n+    static_assert( std::ceil2(UInt(0x1000000)) == 0x1000000 );\n+    static_assert( std::ceil2(UInt(0x1000001)) == 0x2000000 );\n+  }\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 64)\n+  {\n+    static_assert( std::ceil2(UInt(1) << 64) == (UInt(1) << 64) );\n+    static_assert( std::ceil2(UInt(3) << 64) == (UInt(4) << 64) );\n+  }\n+\n+  return true;\n+}\n+\n+static_assert( test( (unsigned char)0 ) );\n+static_assert( test( (unsigned short)0 ) );\n+static_assert( test( (unsigned int)0 ) );\n+static_assert( test( (unsigned long)0 ) );\n+static_assert( test( (unsigned long long)0 ) );\n+\n+// std::ceil2(T) shall not participate in overload resolution\n+// unless T is an unsigned integer type.\n+struct X { constexpr bool did_not_match() { return true; } };\n+constexpr X test(...) { return X{}; }\n+static_assert( test( (bool)0 ).did_not_match() );\n+static_assert( test( (char)0 ).did_not_match() );\n+static_assert( test( (int)0 ).did_not_match() );\n+static_assert( test( (char16_t)0 ).did_not_match() );\n+static_assert( test( (float)0 ).did_not_match() );\n+static_assert( test( (void*)0 ).did_not_match() );\n+static_assert( test( X{} ).did_not_match() );\n+enum E : unsigned { e };\n+static_assert( test( e ).did_not_match() );\n+\n+#ifndef __STRICT_ANSI__\n+#include <cstddef>\n+static_assert( std::ceil2(std::byte{0}) == std::byte{1} );\n+static_assert( std::ceil2(std::byte{1}) == std::byte{1} );\n+static_assert( std::ceil2(std::byte{2}) == std::byte{2} );\n+static_assert( std::ceil2(std::byte{3}) == std::byte{4} );\n+static_assert( std::ceil2(std::byte{100}) == std::byte{128} );\n+static_assert( std::ceil2(std::byte{128}) == std::byte{128} );\n+#else\n+static_assert( test( (std::byte)0 ).did_not_match() );\n+#endif\n+\n+#if !defined(__STRICT_ANSI__) && defined _GLIBCXX_USE_INT128\n+static_assert( test( (unsigned __int128)0 ) );\n+static_assert( test( (__int128)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_0)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_0)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_0)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_1)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_1)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_1)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_2)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_2)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_2)0 ).did_not_match() );\n+#endif"}, {"sha": "0206110ec2f33ed74f0ed0d14ddc2c268ae90ff6", "filename": "libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/floor2.cc", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Ffloor2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Ffloor2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Ffloor2.cc?ref=f3e91052bd7e5af791ca720cd14e9ac9227e3801", "patch": "@@ -0,0 +1,109 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <bit>\n+\n+template<typename UInt>\n+constexpr auto\n+test(UInt x)\n+-> decltype(std::floor2(x))\n+{\n+  static_assert( noexcept(std::floor2(x)) );\n+\n+  static_assert( std::floor2(UInt(0)) == 0 );\n+  static_assert( std::floor2(UInt(1)) == 1 );\n+  static_assert( std::floor2(UInt(2)) == 2 );\n+  static_assert( std::floor2(UInt(3)) == 2 );\n+  static_assert( std::floor2(UInt(4)) == 4 );\n+  static_assert( std::floor2(UInt(0x11)) == 0x10 );\n+  static_assert( std::floor2(UInt(0x20)) == 0x20 );\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 8)\n+  {\n+    static_assert( std::floor2(UInt(0x201)) == 0x200 );\n+    static_assert( std::floor2(UInt(0x8ff)) == 0x800 );\n+    static_assert( std::floor2(UInt(0x1000)) == 0x1000 );\n+  }\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 32)\n+  {\n+    static_assert( std::floor2(UInt(0xabcdef)) == 0x800000 );\n+    static_assert( std::floor2(UInt(0x1000000)) == 0x1000000 );\n+    static_assert( std::floor2(UInt(0x1000001)) == 0x1000000 );\n+  }\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 64)\n+  {\n+    static_assert( std::floor2(UInt(1) << 64) == (UInt(1) << 64) );\n+    static_assert( std::floor2(UInt(3) << 64) == (UInt(2) << 64) );\n+  }\n+\n+  return true;\n+}\n+\n+static_assert( test( (unsigned char)0 ) );\n+static_assert( test( (unsigned short)0 ) );\n+static_assert( test( (unsigned int)0 ) );\n+static_assert( test( (unsigned long)0 ) );\n+static_assert( test( (unsigned long long)0 ) );\n+\n+// std::floor2(T) shall not participate in overload resolution\n+// unless T is an unsigned integer type.\n+struct X { constexpr bool did_not_match() { return true; } };\n+constexpr X test(...) { return X{}; }\n+static_assert( test( (bool)0 ).did_not_match() );\n+static_assert( test( (char)0 ).did_not_match() );\n+static_assert( test( (int)0 ).did_not_match() );\n+static_assert( test( (char16_t)0 ).did_not_match() );\n+static_assert( test( (float)0 ).did_not_match() );\n+static_assert( test( (void*)0 ).did_not_match() );\n+static_assert( test( X{} ).did_not_match() );\n+enum E : unsigned { e };\n+static_assert( test( e ).did_not_match() );\n+\n+#ifndef __STRICT_ANSI__\n+#include <cstddef>\n+static_assert( std::floor2(std::byte{0}) == std::byte{0} );\n+static_assert( std::floor2(std::byte{1}) == std::byte{1} );\n+static_assert( std::floor2(std::byte{2}) == std::byte{2} );\n+static_assert( std::floor2(std::byte{3}) == std::byte{2} );\n+static_assert( std::floor2(std::byte{100}) == std::byte{64} );\n+static_assert( std::floor2(std::byte{128}) == std::byte{128} );\n+static_assert( std::floor2(std::byte{255}) == std::byte{128} );\n+#else\n+static_assert( test( (std::byte)0 ).did_not_match() );\n+#endif\n+\n+#if !defined(__STRICT_ANSI__) && defined _GLIBCXX_USE_INT128\n+static_assert( test( (unsigned __int128)0 ) );\n+static_assert( test( (__int128)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_0)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_0)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_0)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_1)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_1)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_1)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_2)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_2)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_2)0 ).did_not_match() );\n+#endif"}, {"sha": "ba8cfa8da7c9d6289f8248c2d115ef75e367bdd4", "filename": "libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/ispow2.cc", "status": "added", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fispow2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fispow2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Fispow2.cc?ref=f3e91052bd7e5af791ca720cd14e9ac9227e3801", "patch": "@@ -0,0 +1,157 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <bit>\n+\n+template<typename UInt>\n+constexpr auto\n+test(UInt x)\n+-> decltype(std::ispow2(x))\n+{\n+  static_assert( noexcept(std::ispow2(x)) );\n+\n+  static_assert( ! std::ispow2( (UInt)0 ) );\n+  static_assert( ! std::ispow2( (UInt)-1 ) );\n+  static_assert( ! std::ispow2( (UInt)3 ) );\n+  static_assert( ! std::ispow2( (UInt)0x0f ) );\n+  static_assert( ! std::ispow2( (UInt)0xff ) );\n+  static_assert( ! std::ispow2( (UInt)0x0a ) );\n+  static_assert( ! std::ispow2( (UInt)0xa0 ) );\n+\n+  constexpr UInt one = 1;\n+  static_assert( std::ispow2( (UInt)(one << 0) ) );\n+\n+  static_assert( std::ispow2( (UInt)(one << 1) ) );\n+  static_assert( std::ispow2( (UInt)(one << 2) ) );\n+  static_assert( std::ispow2( (UInt)(one << 3) ) );\n+  static_assert( std::ispow2( (UInt)(one << 4) ) );\n+  static_assert( std::ispow2( (UInt)(one << 5) ) );\n+  static_assert( std::ispow2( (UInt)(one << 6) ) );\n+  static_assert( std::ispow2( (UInt)(one << 7) ) );\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 8)\n+  {\n+    static_assert( std::ispow2( (UInt)(one << 8) ) );\n+    static_assert( std::ispow2( (UInt)(one << 9) ) );\n+    static_assert( std::ispow2( (UInt)(one << 10) ) );\n+    static_assert( std::ispow2( (UInt)(one << 11) ) );\n+    static_assert( std::ispow2( (UInt)(one << 12) ) );\n+    static_assert( std::ispow2( (UInt)(one << 13) ) );\n+    static_assert( std::ispow2( (UInt)(one << 14) ) );\n+    static_assert( std::ispow2( (UInt)(one << 15) ) );\n+\n+    static_assert( ! std::ispow2( (UInt)0xf000 ) );\n+    static_assert( ! std::ispow2( (UInt)0xff00 ) );\n+    static_assert( ! std::ispow2( (UInt)0xf0f0 ) );\n+    static_assert( ! std::ispow2( (UInt)0xf00f ) );\n+    static_assert( ! std::ispow2( (UInt)0x0f0f ) );\n+    static_assert( ! std::ispow2( (UInt)0x00ff ) );\n+  }\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 16)\n+  {\n+    static_assert( std::ispow2( (UInt)(one << 16) ) );\n+    static_assert( std::ispow2( (UInt)(one << 17) ) );\n+    static_assert( ! std::ispow2( (UInt)((one << 16) + 1) ) );\n+    static_assert( ! std::ispow2( (UInt)((one << 16) + 0x10) ) );\n+  }\n+\n+  // msp340 target has 20-bit __GLIBCXX_TYPE_INT_N_0 type\n+  if constexpr (std::numeric_limits<UInt>::digits > 20)\n+  {\n+    static_assert( std::ispow2( (UInt)(one << 20) ) );\n+    static_assert( std::ispow2( (UInt)(one << 21) ) );\n+    static_assert( std::ispow2( (UInt)(one << 24) ) );\n+    static_assert( std::ispow2( (UInt)(one << 28) ) );\n+    static_assert( std::ispow2( (UInt)(one << 31) ) );\n+  }\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 32)\n+  {\n+    static_assert( std::ispow2( (UInt)(one << 32) ) );\n+    static_assert( std::ispow2( (UInt)(one << 33) ) );\n+    static_assert( std::ispow2( (UInt)(one << 41) ) );\n+\n+    static_assert( ! std::ispow2( (UInt)((one << 32) + 1) ) );\n+    static_assert( ! std::ispow2( (UInt)((one << 32) + (one << 31)) ) );\n+    static_assert( ! std::ispow2( (UInt)((one << 33) + 1) ) );\n+    static_assert( ! std::ispow2( (UInt)((one << 33) + (one << 32)) ) );\n+  }\n+\n+  if constexpr (std::numeric_limits<UInt>::digits == 64)\n+  {\n+    static_assert( std::ispow2( (UInt)(one << 63) ) );\n+\n+    static_assert( ! std::ispow2( (UInt)((one << 63) + 1) ) );\n+    static_assert( ! std::ispow2( (UInt)((one << 63) + (one << 8)) ) );\n+    static_assert( ! std::ispow2( (UInt)((one << 63) + (one << 32)) ) );\n+  }\n+  return true;\n+}\n+\n+static_assert( test( (unsigned char)0 ) );\n+static_assert( test( (unsigned short)0 ) );\n+static_assert( test( (unsigned int)0 ) );\n+static_assert( test( (unsigned long)0 ) );\n+static_assert( test( (unsigned long long)0 ) );\n+\n+// std::ispow2(T) shall not participate in overload resolution\n+// unless T is an unsigned integer type.\n+struct X { constexpr bool did_not_match() { return true; } };\n+constexpr X test(...) { return X{}; }\n+static_assert( test( (bool)0 ).did_not_match() );\n+static_assert( test( (char)0 ).did_not_match() );\n+static_assert( test( (int)0 ).did_not_match() );\n+static_assert( test( (char16_t)0 ).did_not_match() );\n+static_assert( test( (float)0 ).did_not_match() );\n+static_assert( test( (void*)0 ).did_not_match() );\n+static_assert( test( X{} ).did_not_match() );\n+enum E : unsigned { e };\n+static_assert( test( e ).did_not_match() );\n+\n+#ifndef __STRICT_ANSI__\n+#include <cstddef>\n+static_assert( std::ispow2(std::byte{0}) == false );\n+static_assert( std::ispow2(std::byte{1}) == true );\n+static_assert( std::ispow2(std::byte{2}) == true );\n+static_assert( std::ispow2(std::byte{3}) == false );\n+static_assert( std::ispow2(std::byte{100}) == false );\n+static_assert( std::ispow2(std::byte{128}) == true );\n+static_assert( std::ispow2(std::byte{255}) == false );\n+#else\n+static_assert( test( (std::byte)0 ).did_not_match() );\n+#endif\n+\n+#if !defined(__STRICT_ANSI__) && defined _GLIBCXX_USE_INT128\n+static_assert( test( (unsigned __int128)0 ) );\n+static_assert( test( (__int128)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_0)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_0)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_0)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_1)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_1)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_1)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_2)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_2)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_2)0 ).did_not_match() );\n+#endif"}, {"sha": "142f6ee857d59c536a21240ceab12458a146c439", "filename": "libstdc++-v3/testsuite/26_numerics/bit/bit.pow.two/log2p1.cc", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Flog2p1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Flog2p1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbit.pow.two%2Flog2p1.cc?ref=f3e91052bd7e5af791ca720cd14e9ac9227e3801", "patch": "@@ -0,0 +1,109 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <bit>\n+\n+template<typename UInt>\n+constexpr auto\n+test(UInt x)\n+-> decltype(std::log2p1(x))\n+{\n+  static_assert( noexcept(std::log2p1(x)) );\n+\n+  static_assert( std::log2p1(UInt(0)) == 0 );\n+  static_assert( std::log2p1(UInt(1)) == 1 );\n+  static_assert( std::log2p1(UInt(2)) == 2 );\n+  static_assert( std::log2p1(UInt(3)) == 2 );\n+  static_assert( std::log2p1(UInt(4)) == 3 );\n+  static_assert( std::log2p1(UInt(0x11)) == 5 );\n+  static_assert( std::log2p1(UInt(0x20)) == 6 );\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 8)\n+  {\n+    static_assert( std::log2p1(UInt(0x201)) == 10 );\n+    static_assert( std::log2p1(UInt(0x8ff)) == 12 );\n+    static_assert( std::log2p1(UInt(0x1000)) == 13 );\n+  }\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 32)\n+  {\n+    static_assert( std::log2p1(UInt(0xabcdef)) == 24 );\n+    static_assert( std::log2p1(UInt(0x1000000)) == 25 );\n+    static_assert( std::log2p1(UInt(0x1000001)) == 25 );\n+  }\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 64)\n+  {\n+    static_assert( std::log2p1(UInt(1) << 64) == 65 );\n+    static_assert( std::log2p1(UInt(3) << 64) == 66 );\n+  }\n+\n+  return true;\n+}\n+\n+static_assert( test( (unsigned char)0 ) );\n+static_assert( test( (unsigned short)0 ) );\n+static_assert( test( (unsigned int)0 ) );\n+static_assert( test( (unsigned long)0 ) );\n+static_assert( test( (unsigned long long)0 ) );\n+\n+// std::log2p1(T) shall not participate in overload resolution\n+// unless T is an unsigned integer type.\n+struct X { constexpr bool did_not_match() { return true; } };\n+constexpr X test(...) { return X{}; }\n+static_assert( test( (bool)0 ).did_not_match() );\n+static_assert( test( (char)0 ).did_not_match() );\n+static_assert( test( (int)0 ).did_not_match() );\n+static_assert( test( (char16_t)0 ).did_not_match() );\n+static_assert( test( (float)0 ).did_not_match() );\n+static_assert( test( (void*)0 ).did_not_match() );\n+static_assert( test( X{} ).did_not_match() );\n+enum E : unsigned { e };\n+static_assert( test( e ).did_not_match() );\n+\n+#ifndef __STRICT_ANSI__\n+#include <cstddef>\n+static_assert( std::log2p1(std::byte{0}) == std::byte{0} );\n+static_assert( std::log2p1(std::byte{1}) == std::byte{1} );\n+static_assert( std::log2p1(std::byte{2}) == std::byte{2} );\n+static_assert( std::log2p1(std::byte{3}) == std::byte{2} );\n+static_assert( std::log2p1(std::byte{100}) == std::byte{7} );\n+static_assert( std::log2p1(std::byte{128}) == std::byte{8} );\n+static_assert( std::log2p1(std::byte{255}) == std::byte{8} );\n+#else\n+static_assert( test( (std::byte)0 ).did_not_match() );\n+#endif\n+\n+#if !defined(__STRICT_ANSI__) && defined _GLIBCXX_USE_INT128\n+static_assert( test( (unsigned __int128)0 ) );\n+static_assert( test( (__int128)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_0)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_0)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_0)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_1)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_1)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_1)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_2)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_2)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_2)0 ).did_not_match() );\n+#endif"}, {"sha": "c9ef5538538482bffbe5adf996421d29d12f0dfc", "filename": "libstdc++-v3/testsuite/26_numerics/bit/bitops.count/countl_one.cc", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbitops.count%2Fcountl_one.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbitops.count%2Fcountl_one.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbitops.count%2Fcountl_one.cc?ref=f3e91052bd7e5af791ca720cd14e9ac9227e3801", "patch": "@@ -0,0 +1,103 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <bit>\n+\n+template<typename UInt>\n+constexpr auto\n+test(UInt x)\n+-> decltype(std::countl_one(x))\n+{\n+  static_assert( noexcept(std::countl_one(x)) );\n+\n+  constexpr unsigned digits = std::numeric_limits<UInt>::digits;\n+\n+  static_assert( std::countl_one((UInt)0) == 0 );\n+  static_assert( std::countl_one((UInt)-1) == digits );\n+\n+  static_assert( std::countl_one((UInt)3) == 0 );\n+  static_assert( std::countl_one((UInt)((UInt)1 << digits - 1)) == 1 );\n+  static_assert( std::countl_one((UInt)((UInt)3 << digits - 2)) == 2 );\n+  static_assert( std::countl_one((UInt)((UInt)7 << digits - 3)) == 3 );\n+  static_assert( std::countl_one((UInt)((UInt)255 << digits - 8)) == 8 );\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 8)\n+  {\n+    static_assert( std::countl_one((UInt)((UInt)-1 ^ 0x100)) == digits - 9 );\n+    static_assert( std::countl_one((UInt)((UInt)-1 ^ 0x101)) == digits - 9 );\n+    static_assert( std::countl_one((UInt)((UInt)-1 ^ 0x201)) == digits - 10 );\n+  }\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 64)\n+  {\n+    static_assert( std::countl_one((UInt)-1 ^ ((UInt)1 << 70)) == digits - 71 );\n+  }\n+\n+  return true;\n+}\n+\n+static_assert( test( (unsigned char)0 ) );\n+static_assert( test( (unsigned short)0 ) );\n+static_assert( test( (unsigned int)0 ) );\n+static_assert( test( (unsigned long)0 ) );\n+static_assert( test( (unsigned long long)0 ) );\n+\n+// std::countl_one(T) shall not participate in overload resolution\n+// unless T is an unsigned integer type.\n+struct X { constexpr bool did_not_match() { return true; } };\n+constexpr X test(...) { return X{}; }\n+static_assert( test( (bool)0 ).did_not_match() );\n+static_assert( test( (char)0 ).did_not_match() );\n+static_assert( test( (int)0 ).did_not_match() );\n+static_assert( test( (char16_t)0 ).did_not_match() );\n+static_assert( test( (float)0 ).did_not_match() );\n+static_assert( test( (void*)0 ).did_not_match() );\n+static_assert( test( X{} ).did_not_match() );\n+enum E : unsigned { e };\n+static_assert( test( e ).did_not_match() );\n+\n+#ifndef __STRICT_ANSI__\n+#include <cstddef>\n+constexpr int bits = std::numeric_limits<unsigned char>::digits;\n+static_assert( std::countl_one(std::byte{0}) == 0 );\n+static_assert( std::countl_one(~std::byte{0}) == bits );\n+static_assert( std::countl_one(~std::byte{0} ^ std::byte{7}) == bits - 3 );\n+#else\n+static_assert( test( (std::byte)0 ).did_not_match() );\n+#endif\n+\n+#if !defined(__STRICT_ANSI__) && defined _GLIBCXX_USE_INT128\n+static_assert( test( (unsigned __int128)0 ) );\n+static_assert( test( (__int128)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_0)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_0)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_0)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_1)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_1)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_1)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_2)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_2)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_2)0 ).did_not_match() );\n+#endif"}, {"sha": "7d619a7d6979d793715bff5c9224eeffb08d5ccf", "filename": "libstdc++-v3/testsuite/26_numerics/bit/bitops.count/countl_zero.cc", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbitops.count%2Fcountl_zero.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbitops.count%2Fcountl_zero.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbitops.count%2Fcountl_zero.cc?ref=f3e91052bd7e5af791ca720cd14e9ac9227e3801", "patch": "@@ -0,0 +1,104 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <bit>\n+\n+template<typename UInt>\n+constexpr auto\n+test(UInt x)\n+-> decltype(std::countl_zero(x))\n+{\n+  static_assert( noexcept(std::countl_zero(x)) );\n+\n+  constexpr unsigned digits = std::numeric_limits<UInt>::digits;\n+\n+  static_assert( std::countl_zero((UInt)0) == digits );\n+  static_assert( std::countl_zero((UInt)-1) == 0 );\n+\n+  static_assert( std::countl_zero((UInt)1) == digits - 1 );\n+  static_assert( std::countl_zero((UInt)3) == digits - 2 );\n+  static_assert( std::countl_zero((UInt)0b0101'1010) == digits - 7 );\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 8)\n+  {\n+    static_assert( std::countl_zero((UInt)(1u << 8)) == digits - 9 );\n+    static_assert( std::countl_zero((UInt)(3u << 9)) == digits - 11 );\n+  }\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 64)\n+  {\n+    static_assert( std::countl_zero((UInt)3 << 70) == digits - 72 );\n+  }\n+\n+  return true;\n+}\n+\n+static_assert( test( (unsigned char)0 ) );\n+static_assert( test( (unsigned short)0 ) );\n+static_assert( test( (unsigned int)0 ) );\n+static_assert( test( (unsigned long)0 ) );\n+static_assert( test( (unsigned long long)0 ) );\n+\n+// std::countl_zero(T) shall not participate in overload resolution\n+// unless T is an unsigned integer type.\n+struct X { constexpr bool did_not_match() { return true; } };\n+constexpr X test(...) { return X{}; }\n+static_assert( test( (bool)0 ).did_not_match() );\n+static_assert( test( (char)0 ).did_not_match() );\n+static_assert( test( (int)0 ).did_not_match() );\n+static_assert( test( (char16_t)0 ).did_not_match() );\n+static_assert( test( (float)0 ).did_not_match() );\n+static_assert( test( (void*)0 ).did_not_match() );\n+static_assert( test( X{} ).did_not_match() );\n+enum E : unsigned { e };\n+static_assert( test( e ).did_not_match() );\n+\n+#ifndef __STRICT_ANSI__\n+#include <cstddef>\n+constexpr int bits = std::numeric_limits<unsigned char>::digits;\n+static_assert( std::countl_zero(std::byte{0}) == bits );\n+static_assert( std::countl_zero(std::byte{0x01}) == bits - 1 );\n+static_assert( std::countl_zero(std::byte{0x02}) == bits - 2 );\n+static_assert( std::countl_zero(std::byte{0x03}) == bits - 2 );\n+static_assert( std::countl_zero(std::byte{0x30}) == 2 );\n+static_assert( std::countl_zero(std::byte{0x40}) == 1 );\n+static_assert( std::countl_zero(std::byte{0x41}) == 1 );\n+#else\n+static_assert( test( (std::byte)0 ).did_not_match() );\n+#endif\n+\n+#if !defined(__STRICT_ANSI__) && defined _GLIBCXX_USE_INT128\n+static_assert( test( (unsigned __int128)0 ) );\n+static_assert( test( (__int128)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_0)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_0)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_0)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_1)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_1)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_1)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_2)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_2)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_2)0 ).did_not_match() );\n+#endif"}, {"sha": "bb1ddd6234d208e5a75603cc2814b6cc5d509ddc", "filename": "libstdc++-v3/testsuite/26_numerics/bit/bitops.count/countr_one.cc", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbitops.count%2Fcountr_one.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbitops.count%2Fcountr_one.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbitops.count%2Fcountr_one.cc?ref=f3e91052bd7e5af791ca720cd14e9ac9227e3801", "patch": "@@ -0,0 +1,106 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <bit>\n+\n+template<typename UInt>\n+constexpr auto\n+test(UInt x)\n+-> decltype(std::countr_one(x))\n+{\n+  static_assert( noexcept(std::countr_one(x)) );\n+\n+  constexpr unsigned digits = std::numeric_limits<UInt>::digits;\n+\n+  static_assert( std::countr_one((UInt)0) == 0 );\n+  static_assert( std::countr_one((UInt)-1) == digits );\n+  static_assert( std::countr_one((UInt)127) == 7 );\n+\n+  static_assert( std::countr_one((UInt)1) == 1 );\n+  static_assert( std::countr_one((UInt)3) == 2 );\n+  static_assert( std::countr_one((UInt)0x1f) == 5 );\n+  static_assert( std::countr_one((UInt)((UInt)-1 ^ 0x10)) == 4 );\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 8)\n+  {\n+    static_assert( std::countr_one((UInt)((UInt)-1 ^ 0x100)) == 8 );\n+    static_assert( std::countr_one((UInt)((UInt)-1 ^ 0x101)) == 0 );\n+  }\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 64)\n+  {\n+    static_assert( std::countr_one((UInt)-1 ^ ((UInt)1 << 70)) == 70 );\n+  }\n+\n+  return true;\n+}\n+\n+static_assert( test( (unsigned char)0 ) );\n+static_assert( test( (unsigned short)0 ) );\n+static_assert( test( (unsigned int)0 ) );\n+static_assert( test( (unsigned long)0 ) );\n+static_assert( test( (unsigned long long)0 ) );\n+\n+// std::countr_one(T) shall not participate in overload resolution\n+// unless T is an unsigned integer type.\n+struct X { constexpr bool did_not_match() { return true; } };\n+constexpr X test(...) { return X{}; }\n+static_assert( test( (bool)0 ).did_not_match() );\n+static_assert( test( (char)0 ).did_not_match() );\n+static_assert( test( (int)0 ).did_not_match() );\n+static_assert( test( (char16_t)0 ).did_not_match() );\n+static_assert( test( (float)0 ).did_not_match() );\n+static_assert( test( (void*)0 ).did_not_match() );\n+static_assert( test( X{} ).did_not_match() );\n+enum E : unsigned { e };\n+static_assert( test( e ).did_not_match() );\n+\n+#ifndef __STRICT_ANSI__\n+#include <cstddef>\n+constexpr int bits = std::numeric_limits<unsigned char>::digits;\n+static_assert( std::countr_one(std::byte{0}) == 0 );\n+static_assert( std::countr_one(std::byte{0x01}) == 1 );\n+static_assert( std::countr_one(std::byte{0x02}) == 0 );\n+static_assert( std::countr_one(std::byte{0x03}) == 2 );\n+static_assert( std::countr_one(std::byte{0x30}) == 0 );\n+static_assert( std::countr_one(std::byte{0x0f}) == 4 );\n+static_assert( std::countr_one(std::byte{0xff}) == 8 );\n+#else\n+static_assert( test( (std::byte)0 ).did_not_match() );\n+#endif\n+\n+#if !defined(__STRICT_ANSI__) && defined _GLIBCXX_USE_INT128\n+static_assert( test( (unsigned __int128)0 ) );\n+static_assert( test( (__int128)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_0)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_0)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_0)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_1)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_1)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_1)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_2)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_2)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_2)0 ).did_not_match() );\n+#endif"}, {"sha": "d3b63aa49848163e2ecc7c619ee2712323e9b641", "filename": "libstdc++-v3/testsuite/26_numerics/bit/bitops.count/countr_zero.cc", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbitops.count%2Fcountr_zero.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbitops.count%2Fcountr_zero.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbitops.count%2Fcountr_zero.cc?ref=f3e91052bd7e5af791ca720cd14e9ac9227e3801", "patch": "@@ -0,0 +1,105 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <bit>\n+\n+template<typename UInt>\n+constexpr auto\n+test(UInt x)\n+-> decltype(std::countr_zero(x))\n+{\n+  static_assert( noexcept(std::countr_zero(x)) );\n+\n+  constexpr unsigned digits = std::numeric_limits<UInt>::digits;\n+\n+  static_assert( std::countr_zero((UInt)0) == digits );\n+  static_assert( std::countr_zero((UInt)-1) == 0 );\n+  static_assert( std::countr_zero((UInt)127) == 0 );\n+\n+  static_assert( std::countr_zero((UInt)1) == 0 );\n+  static_assert( std::countr_zero((UInt)2) == 1 );\n+  static_assert( std::countr_zero((UInt)0x70) == 4 );\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 8)\n+  {\n+    static_assert( std::countr_zero((UInt)(1u << 8)) == 8 );\n+    static_assert( std::countr_zero((UInt)(4u << 9)) == 11 );\n+  }\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 64)\n+  {\n+    static_assert( std::countr_zero((UInt)2 << 70) == 71 );\n+  }\n+\n+  return true;\n+}\n+\n+static_assert( test( (unsigned char)0 ) );\n+static_assert( test( (unsigned short)0 ) );\n+static_assert( test( (unsigned int)0 ) );\n+static_assert( test( (unsigned long)0 ) );\n+static_assert( test( (unsigned long long)0 ) );\n+\n+// std::countr_zero(T) shall not participate in overload resolution\n+// unless T is an unsigned integer type.\n+struct X { constexpr bool did_not_match() { return true; } };\n+constexpr X test(...) { return X{}; }\n+static_assert( test( (bool)0 ).did_not_match() );\n+static_assert( test( (char)0 ).did_not_match() );\n+static_assert( test( (int)0 ).did_not_match() );\n+static_assert( test( (char16_t)0 ).did_not_match() );\n+static_assert( test( (float)0 ).did_not_match() );\n+static_assert( test( (void*)0 ).did_not_match() );\n+static_assert( test( X{} ).did_not_match() );\n+enum E : unsigned { e };\n+static_assert( test( e ).did_not_match() );\n+\n+#ifndef __STRICT_ANSI__\n+#include <cstddef>\n+constexpr int bits = std::numeric_limits<unsigned char>::digits;\n+static_assert( std::countr_zero(std::byte{0}) == bits );\n+static_assert( std::countr_zero(std::byte{0x01}) == 0 );\n+static_assert( std::countr_zero(std::byte{0x02}) == 1 );\n+static_assert( std::countr_zero(std::byte{0x03}) == 0 );\n+static_assert( std::countr_zero(std::byte{0x30}) == 4 );\n+static_assert( std::countr_zero(std::byte{0x40}) == 6 );\n+static_assert( std::countr_zero(std::byte{0x41}) == 0 );\n+#else\n+static_assert( test( (std::byte)0 ).did_not_match() );\n+#endif\n+\n+#if !defined(__STRICT_ANSI__) && defined _GLIBCXX_USE_INT128\n+static_assert( test( (unsigned __int128)0 ) );\n+static_assert( test( (__int128)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_0)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_0)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_0)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_1)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_1)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_1)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_2)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_2)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_2)0 ).did_not_match() );\n+#endif"}, {"sha": "a44da00040cb7a0d4e158b8000e557a5d2843c5b", "filename": "libstdc++-v3/testsuite/26_numerics/bit/bitops.rot/rotl.cc", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbitops.rot%2Frotl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbitops.rot%2Frotl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbitops.rot%2Frotl.cc?ref=f3e91052bd7e5af791ca720cd14e9ac9227e3801", "patch": "@@ -0,0 +1,119 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <bit>\n+\n+template<typename UInt>\n+constexpr auto\n+test(UInt x)\n+-> decltype(std::rotl(x, 0u))\n+{\n+  static_assert( noexcept(std::rotl(x, 0u)) );\n+\n+  constexpr unsigned digits = std::numeric_limits<UInt>::digits;\n+\n+  static_assert( std::rotl((UInt)0, 0) == 0 );\n+  static_assert( std::rotl((UInt)0, 1) == 0 );\n+  static_assert( std::rotl((UInt)0, 4) == 0 );\n+  static_assert( std::rotl((UInt)0, 8) == 0 );\n+  static_assert( std::rotl((UInt)-1, 0) == (UInt)-1 );\n+  static_assert( std::rotl((UInt)-1, 1) == (UInt)-1 );\n+  static_assert( std::rotl((UInt)-1, 4) == (UInt)-1 );\n+  static_assert( std::rotl((UInt)-1, 8) == (UInt)-1 );\n+\n+  static_assert( std::rotl((UInt)1, 0) == (UInt)1 << 0 );\n+  static_assert( std::rotl((UInt)1, 1) == (UInt)1 << 1 );\n+  static_assert( std::rotl((UInt)1, 4) == (UInt)1 << 4 );\n+  static_assert( std::rotl((UInt)1, digits) == (UInt)1 );\n+  static_assert( std::rotl((UInt)7, digits) == (UInt)7 );\n+  static_assert( std::rotl((UInt)6, digits - 1) == (UInt)3 );\n+  static_assert( std::rotl((UInt)3, 6) == (UInt)3 << 6 );\n+\n+  static_assert( std::rotl((UInt)0b0110'1100, 1) == 0b1101'1000 );\n+  static_assert( std::rotl((UInt)0b0110'1100, digits - 1) == 0b0011'0110 );\n+\n+  static_assert( std::rotl((UInt)0x01, 0 ) == 0x01 );\n+  static_assert( std::rotl((UInt)0x10, 0 ) == 0x10 );\n+  static_assert( std::rotl((UInt)0x10, 1 ) == 0x20 );\n+  static_assert( std::rotl((UInt)0x10, 2 ) == 0x40 );\n+  static_assert( std::rotl((UInt)0x10, 3 ) == 0x80 );\n+  static_assert( std::rotl((UInt)0x11, 1 ) == 0x22 );\n+  static_assert( std::rotl((UInt)0x11, 2 ) == 0x44 );\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 8)\n+  {\n+    static_assert( std::rotl((UInt)0b0011'0111, 3) == 0b1'1011'1000 );\n+    static_assert( std::rotl((UInt)0b1010'0101, 4) == 0b1010'0101'0000 );\n+  }\n+\n+  return true;\n+}\n+\n+static_assert( test( (unsigned char)0 ) );\n+static_assert( test( (unsigned short)0 ) );\n+static_assert( test( (unsigned int)0 ) );\n+static_assert( test( (unsigned long)0 ) );\n+static_assert( test( (unsigned long long)0 ) );\n+\n+// std::rotl(T) shall not participate in overload resolution\n+// unless T is an unsigned integer type.\n+struct X { constexpr bool did_not_match() { return true; } };\n+constexpr X test(...) { return X{}; }\n+static_assert( test( (bool)0 ).did_not_match() );\n+static_assert( test( (char)0 ).did_not_match() );\n+static_assert( test( (int)0 ).did_not_match() );\n+static_assert( test( (char16_t)0 ).did_not_match() );\n+static_assert( test( (float)0 ).did_not_match() );\n+static_assert( test( (void*)0 ).did_not_match() );\n+static_assert( test( X{} ).did_not_match() );\n+enum E : unsigned { e };\n+static_assert( test( e ).did_not_match() );\n+\n+#ifndef __STRICT_ANSI__\n+#include <cstddef>\n+static_assert( std::rotl(std::byte{0}, 4) == std::byte{0} );\n+static_assert( std::rotl(std::byte{0x01}, 4) == std::byte{0x10} );\n+static_assert( std::rotl(std::byte{0x02}, 3) == std::byte{0x10} );\n+static_assert( std::rotl(std::byte{0x03}, 2) == std::byte{0x0c} );\n+static_assert( std::rotl(std::byte{0x30}, 2) == std::byte{0xc0} );\n+static_assert( std::rotl(std::byte{0x40}, 1) == std::byte{0x80} );\n+static_assert( std::rotl(std::byte{0x41}, 9) == std::byte{0x82} );\n+#else\n+static_assert( test( (std::byte)0 ).did_not_match() );\n+#endif\n+\n+#if !defined(__STRICT_ANSI__) && defined _GLIBCXX_USE_INT128\n+static_assert( test( (unsigned __int128)0 ) );\n+static_assert( test( (__int128)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_0)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_0)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_0)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_1)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_1)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_1)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_2)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_2)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_2)0 ).did_not_match() );\n+#endif"}, {"sha": "c4a17689f79f88fa3e86e96d86a86487541adc02", "filename": "libstdc++-v3/testsuite/26_numerics/bit/bitops.rot/rotr.cc", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbitops.rot%2Frotr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3e91052bd7e5af791ca720cd14e9ac9227e3801/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbitops.rot%2Frotr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F26_numerics%2Fbit%2Fbitops.rot%2Frotr.cc?ref=f3e91052bd7e5af791ca720cd14e9ac9227e3801", "patch": "@@ -0,0 +1,119 @@\n+// Copyright (C) 2018 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do compile { target c++2a } }\n+\n+#include <bit>\n+\n+template<typename UInt>\n+constexpr auto\n+test(UInt x)\n+-> decltype(std::rotr(x, 0u))\n+{\n+  static_assert( noexcept(std::rotr(x, 0u)) );\n+\n+  constexpr unsigned digits = std::numeric_limits<UInt>::digits;\n+\n+  static_assert( std::rotr((UInt)0, 0) == 0 );\n+  static_assert( std::rotr((UInt)0, 1) == 0 );\n+  static_assert( std::rotr((UInt)0, 4) == 0 );\n+  static_assert( std::rotr((UInt)0, 8) == 0 );\n+  static_assert( std::rotr((UInt)-1, 0) == (UInt)-1 );\n+  static_assert( std::rotr((UInt)-1, 1) == (UInt)-1 );\n+  static_assert( std::rotr((UInt)-1, 4) == (UInt)-1 );\n+  static_assert( std::rotr((UInt)-1, 8) == (UInt)-1 );\n+\n+  static_assert( std::rotr((UInt)128, 0) == (UInt)128 >> 0 );\n+  static_assert( std::rotr((UInt)128, 1) == (UInt)128 >> 1 );\n+  static_assert( std::rotr((UInt)128, 4) == (UInt)128 >> 4 );\n+  static_assert( std::rotr((UInt)1, digits) == (UInt)1 );\n+  static_assert( std::rotr((UInt)7, digits) == (UInt)7 );\n+  static_assert( std::rotr((UInt)6, digits - 1) == (UInt)12 );\n+  static_assert( std::rotr((UInt)36, digits - 2) == (UInt)144 );\n+\n+  static_assert( std::rotr((UInt)0b0110'1100, 1) == 0b0011'0110 );\n+  static_assert( std::rotr((UInt)0b0110'1100, digits - 1) == 0b1101'1000 );\n+\n+  static_assert( std::rotr((UInt)0x01, 0 ) == 0x01 );\n+  static_assert( std::rotr((UInt)0x10, 0 ) == 0x10 );\n+  static_assert( std::rotr((UInt)0x10, 1 ) == 0x08 );\n+  static_assert( std::rotr((UInt)0x10, 2 ) == 0x04 );\n+  static_assert( std::rotr((UInt)0x10, 3 ) == 0x02 );\n+  static_assert( std::rotr((UInt)0x11, digits - 1 ) == 0x22 );\n+  static_assert( std::rotr((UInt)0x11, digits - 2 ) == 0x44 );\n+\n+  if constexpr (std::numeric_limits<UInt>::digits > 8)\n+  {\n+    static_assert( std::rotr((UInt)0b0011'0111, 3)\n+\t\t\t      == (0b0110 | ((UInt)0b0111 << digits - 3)) );\n+    static_assert( std::rotr((UInt)0b1010'0101, 4)\n+\t\t\t      == (0b1010 | ((UInt)0b0101 << digits - 4)) );\n+  }\n+\n+  return true;\n+}\n+\n+static_assert( test( (unsigned char)0 ) );\n+static_assert( test( (unsigned short)0 ) );\n+static_assert( test( (unsigned int)0 ) );\n+static_assert( test( (unsigned long)0 ) );\n+static_assert( test( (unsigned long long)0 ) );\n+\n+// std::rotr(T) shall not participate in overload resolution\n+// unless T is an unsigned integer type.\n+struct X { constexpr bool did_not_match() { return true; } };\n+constexpr X test(...) { return X{}; }\n+static_assert( test( (bool)0 ).did_not_match() );\n+static_assert( test( (char)0 ).did_not_match() );\n+static_assert( test( (int)0 ).did_not_match() );\n+static_assert( test( (char16_t)0 ).did_not_match() );\n+static_assert( test( (float)0 ).did_not_match() );\n+static_assert( test( (void*)0 ).did_not_match() );\n+static_assert( test( X{} ).did_not_match() );\n+enum E : unsigned { e };\n+static_assert( test( e ).did_not_match() );\n+\n+#ifndef __STRICT_ANSI__\n+#include <cstddef>\n+static_assert( std::rotr(std::byte{0}, 4) == std::byte{0} );\n+static_assert( std::rotr(std::byte{0x01}, 4) == std::byte{0x10} );\n+static_assert( std::rotr(std::byte{0x02}, 3) == std::byte{0x40} );\n+static_assert( std::rotr(std::byte{0x03}, 2) == std::byte{0xc0} );\n+static_assert( std::rotr(std::byte{0x30}, 2) == std::byte{0x0c} );\n+static_assert( std::rotr(std::byte{0x40}, 1) == std::byte{0x20} );\n+static_assert( std::rotr(std::byte{0x41}, 9) == std::byte{0xa0} );\n+#else\n+static_assert( test( (std::byte)0 ).did_not_match() );\n+#endif\n+\n+#if !defined(__STRICT_ANSI__) && defined _GLIBCXX_USE_INT128\n+static_assert( test( (unsigned __int128)0 ) );\n+static_assert( test( (__int128)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_0)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_0)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_0)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_1)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_1)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_1)0 ).did_not_match() );\n+#endif\n+#if defined(__GLIBCXX_TYPE_INT_N_2)\n+static_assert( test( (unsigned __GLIBCXX_TYPE_INT_N_2)0 ) );\n+static_assert( test( (__GLIBCXX_TYPE_INT_N_2)0 ).did_not_match() );\n+#endif"}]}