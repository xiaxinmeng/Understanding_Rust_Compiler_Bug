{"sha": "7999cf327de7b5bbea80046715eeb00c0755a08d", "node_id": "C_kwDOANBUbNoAKDc5OTljZjMyN2RlN2I1YmJlYTgwMDQ2NzE1ZWViMDBjMDc1NWEwOGQ", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-08-23T15:20:05Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:05Z"}, "message": "gccrs: Add AST to HIR lowering pass\n\nThis performs the lowering of the AST to HIR. The interesting piece here is\nthat we desugar much of the AST as mentioned in the previous pass, but\ncrucially, we also strip out all code that is \"marked-for-strip\" which failed\ncfg-expansion from the expansion pass. After this, the HIR includes all code\nrequired to compile for this crate.\n\n\tgcc/rust/\n\t* hir/rust-ast-lower-base.cc: New.\n\t* hir/rust-ast-lower-base.h: New.\n\t* hir/rust-ast-lower-block.h: New.\n\t* hir/rust-ast-lower-enumitem.h: New.\n\t* hir/rust-ast-lower-expr.h: New.\n\t* hir/rust-ast-lower-extern.h: New.\n\t* hir/rust-ast-lower-implitem.h: New.\n\t* hir/rust-ast-lower-item.cc: New.\n\t* hir/rust-ast-lower-item.h: New.\n\t* hir/rust-ast-lower-pattern.cc: New.\n\t* hir/rust-ast-lower-pattern.h: New.\n\t* hir/rust-ast-lower-stmt.h: New.\n\t* hir/rust-ast-lower-struct-field-expr.h: New.\n\t* hir/rust-ast-lower-type.h: New.\n\t* hir/rust-ast-lower.cc: New.\n\t* hir/rust-ast-lower.h: New.\n\t* hir/rust-hir-dump.cc: New.\n\t* hir/rust-hir-dump.h: New.", "tree": {"sha": "d3790130333dee5663b2c20a30b3472d01b296d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d3790130333dee5663b2c20a30b3472d01b296d2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7999cf327de7b5bbea80046715eeb00c0755a08d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7999cf327de7b5bbea80046715eeb00c0755a08d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7999cf327de7b5bbea80046715eeb00c0755a08d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7999cf327de7b5bbea80046715eeb00c0755a08d/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7641eaead409ad3a80b6c92900199af352549fe4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7641eaead409ad3a80b6c92900199af352549fe4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7641eaead409ad3a80b6c92900199af352549fe4"}], "stats": {"total": 6577, "additions": 6577, "deletions": 0}, "files": [{"sha": "a67461791d750a084ca65f6e0eb51e68f365946d", "filename": "gcc/rust/hir/rust-ast-lower-base.cc", "status": "added", "additions": 1078, "deletions": 0, "changes": 1078, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc?ref=7999cf327de7b5bbea80046715eeb00c0755a08d", "patch": "@@ -0,0 +1,1078 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-lower-base.h\"\n+#include \"rust-ast-lower-type.h\"\n+#include \"rust-ast-lower-pattern.h\"\n+#include \"rust-ast-lower-extern.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+void\n+ASTLoweringBase::visit (AST::Token &tok)\n+{}\n+void\n+ASTLoweringBase::visit (AST::DelimTokenTree &delim_tok_tree)\n+{}\n+void\n+ASTLoweringBase::visit (AST::AttrInputMetaItemContainer &input)\n+{}\n+//  void ASTLoweringBase::visit(MetaItem& meta_item) {}\n+//  void vsit(Stmt& stmt) {}\n+//  void ASTLoweringBase::visit(Expr& expr) {}\n+void\n+ASTLoweringBase::visit (AST::IdentifierExpr &ident_expr)\n+{}\n+//  void ASTLoweringBase::visit(Pattern& pattern) {}\n+//  void ASTLoweringBase::visit(Type& type) {}\n+//  void ASTLoweringBase::visit(TypeParamBound& type_param_bound) {}\n+void\n+ASTLoweringBase::visit (AST::Lifetime &lifetime)\n+{}\n+//  void ASTLoweringBase::visit(GenericParam& generic_param) {}\n+void\n+ASTLoweringBase::visit (AST::LifetimeParam &lifetime_param)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ConstGenericParam &const_param)\n+{}\n+//  void ASTLoweringBase::visit(TraitItem& trait_item) {}\n+//  void ASTLoweringBase::visit(InherentImplItem& inherent_impl_item) {}\n+//  void ASTLoweringBase::visit(TraitImplItem& trait_impl_item) {}\n+\n+// rust-path.h\n+void\n+ASTLoweringBase::visit (AST::PathInExpression &path)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TypePathSegment &segment)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TypePathSegmentGeneric &segment)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TypePathSegmentFunction &segment)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TypePath &path)\n+{}\n+void\n+ASTLoweringBase::visit (AST::QualifiedPathInExpression &path)\n+{}\n+void\n+ASTLoweringBase::visit (AST::QualifiedPathInType &path)\n+{}\n+\n+// rust-expr.h\n+void\n+ASTLoweringBase::visit (AST::LiteralExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::AttrInputLiteral &attr_input)\n+{}\n+void\n+ASTLoweringBase::visit (AST::MetaItemLitExpr &meta_item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::MetaItemPathLit &meta_item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::BorrowExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::DereferenceExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ErrorPropagationExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::NegationExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ArithmeticOrLogicalExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ComparisonExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::LazyBooleanExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TypeCastExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::AssignmentExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::CompoundAssignmentExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::GroupedExpr &expr)\n+{}\n+//  void ASTLoweringBase::visit(ArrayElems& elems) {}\n+void\n+ASTLoweringBase::visit (AST::ArrayElemsValues &elems)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ArrayElemsCopied &elems)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ArrayExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ArrayIndexExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TupleExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TupleIndexExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::StructExprStruct &expr)\n+{}\n+//  void ASTLoweringBase::visit(StructExprField& field) {}\n+void\n+ASTLoweringBase::visit (AST::StructExprFieldIdentifier &field)\n+{}\n+void\n+ASTLoweringBase::visit (AST::StructExprFieldIdentifierValue &field)\n+{}\n+void\n+ASTLoweringBase::visit (AST::StructExprFieldIndexValue &field)\n+{}\n+void\n+ASTLoweringBase::visit (AST::StructExprStructFields &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::StructExprStructBase &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::CallExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::MethodCallExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::FieldAccessExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ClosureExprInner &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::BlockExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ClosureExprInnerTyped &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ContinueExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::BreakExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::RangeFromToExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::RangeFromExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::RangeToExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::RangeFullExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::RangeFromToInclExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::RangeToInclExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ReturnExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::UnsafeBlockExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::LoopExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::WhileLoopExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::WhileLetLoopExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ForLoopExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::IfExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::IfExprConseqElse &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::IfExprConseqIf &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::IfExprConseqIfLet &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::IfLetExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::IfLetExprConseqElse &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::IfLetExprConseqIf &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::IfLetExprConseqIfLet &expr)\n+{}\n+//  void ASTLoweringBase::visit(MatchCase& match_case) {}\n+// void ASTLoweringBase:: (AST::MatchCaseBlockExpr &match_case) {}\n+// void ASTLoweringBase:: (AST::MatchCaseExpr &match_case) {}\n+void\n+ASTLoweringBase::visit (AST::MatchExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::AwaitExpr &expr)\n+{}\n+void\n+ASTLoweringBase::visit (AST::AsyncBlockExpr &expr)\n+{}\n+\n+// rust-item.h\n+void\n+ASTLoweringBase::visit (AST::TypeParam &param)\n+{}\n+//  void ASTLoweringBase::visit(WhereClauseItem& item) {}\n+void\n+ASTLoweringBase::visit (AST::LifetimeWhereClauseItem &item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TypeBoundWhereClauseItem &item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::Method &method)\n+{}\n+void\n+ASTLoweringBase::visit (AST::Module &module)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ExternCrate &crate)\n+{}\n+//  void ASTLoweringBase::visit(UseTree& use_tree) {}\n+void\n+ASTLoweringBase::visit (AST::UseTreeGlob &use_tree)\n+{}\n+void\n+ASTLoweringBase::visit (AST::UseTreeList &use_tree)\n+{}\n+void\n+ASTLoweringBase::visit (AST::UseTreeRebind &use_tree)\n+{}\n+void\n+ASTLoweringBase::visit (AST::UseDeclaration &use_decl)\n+{}\n+void\n+ASTLoweringBase::visit (AST::Function &function)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TypeAlias &type_alias)\n+{}\n+void\n+ASTLoweringBase::visit (AST::StructStruct &struct_item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TupleStruct &tuple_struct)\n+{}\n+void\n+ASTLoweringBase::visit (AST::EnumItem &item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::EnumItemTuple &item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::EnumItemStruct &item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::EnumItemDiscriminant &item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::Enum &enum_item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::Union &union_item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ConstantItem &const_item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::StaticItem &static_item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TraitItemFunc &item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TraitItemMethod &item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TraitItemConst &item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TraitItemType &item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::Trait &trait)\n+{}\n+void\n+ASTLoweringBase::visit (AST::InherentImpl &impl)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TraitImpl &impl)\n+{}\n+//  void ASTLoweringBase::visit(ExternalItem& item) {}\n+void\n+ASTLoweringBase::visit (AST::ExternalStaticItem &item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ExternalFunctionItem &item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ExternBlock &block)\n+{}\n+\n+// rust-macro.h\n+void\n+ASTLoweringBase::visit (AST::MacroMatchFragment &match)\n+{}\n+void\n+ASTLoweringBase::visit (AST::MacroMatchRepetition &match)\n+{}\n+void\n+ASTLoweringBase::visit (AST::MacroMatcher &matcher)\n+{}\n+void\n+ASTLoweringBase::visit (AST::MacroRulesDefinition &rules_def)\n+{}\n+void\n+ASTLoweringBase::visit (AST::MacroInvocation &macro_invoc)\n+{}\n+void\n+ASTLoweringBase::visit (AST::MetaItemPath &meta_item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::MetaItemSeq &meta_item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::MetaWord &meta_item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::MetaNameValueStr &meta_item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::MetaListPaths &meta_item)\n+{}\n+void\n+ASTLoweringBase::visit (AST::MetaListNameValueStr &meta_item)\n+{}\n+\n+// rust-pattern.h\n+void\n+ASTLoweringBase::visit (AST::LiteralPattern &pattern)\n+{}\n+void\n+ASTLoweringBase::visit (AST::IdentifierPattern &pattern)\n+{}\n+void\n+ASTLoweringBase::visit (AST::WildcardPattern &pattern)\n+{}\n+//  void ASTLoweringBase::visit(RangePatternBound& bound) {}\n+void\n+ASTLoweringBase::visit (AST::RangePatternBoundLiteral &bound)\n+{}\n+void\n+ASTLoweringBase::visit (AST::RangePatternBoundPath &bound)\n+{}\n+void\n+ASTLoweringBase::visit (AST::RangePatternBoundQualPath &bound)\n+{}\n+void\n+ASTLoweringBase::visit (AST::RangePattern &pattern)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ReferencePattern &pattern)\n+{}\n+//  void ASTLoweringBase::visit(StructPatternField& field) {}\n+void\n+ASTLoweringBase::visit (AST::StructPatternFieldTuplePat &field)\n+{}\n+void\n+ASTLoweringBase::visit (AST::StructPatternFieldIdentPat &field)\n+{}\n+void\n+ASTLoweringBase::visit (AST::StructPatternFieldIdent &field)\n+{}\n+void\n+ASTLoweringBase::visit (AST::StructPattern &pattern)\n+{}\n+//  void ASTLoweringBase::visit(TupleStructItems& tuple_items) {}\n+void\n+ASTLoweringBase::visit (AST::TupleStructItemsNoRange &tuple_items)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TupleStructItemsRange &tuple_items)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TupleStructPattern &pattern)\n+{}\n+//  void ASTLoweringBase::visit(TuplePatternItems& tuple_items) {}\n+void\n+ASTLoweringBase::visit (AST::TuplePatternItemsMultiple &tuple_items)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TuplePatternItemsRanged &tuple_items)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TuplePattern &pattern)\n+{}\n+void\n+ASTLoweringBase::visit (AST::GroupedPattern &pattern)\n+{}\n+void\n+ASTLoweringBase::visit (AST::SlicePattern &pattern)\n+{}\n+\n+// rust-stmt.h\n+void\n+ASTLoweringBase::visit (AST::EmptyStmt &stmt)\n+{}\n+void\n+ASTLoweringBase::visit (AST::LetStmt &stmt)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ExprStmtWithoutBlock &stmt)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ExprStmtWithBlock &stmt)\n+{}\n+\n+// rust-type.h\n+void\n+ASTLoweringBase::visit (AST::TraitBound &bound)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ImplTraitType &type)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TraitObjectType &type)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ParenthesisedType &type)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ImplTraitTypeOneBound &type)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TraitObjectTypeOneBound &type)\n+{}\n+void\n+ASTLoweringBase::visit (AST::TupleType &type)\n+{}\n+void\n+ASTLoweringBase::visit (AST::NeverType &type)\n+{}\n+void\n+ASTLoweringBase::visit (AST::RawPointerType &type)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ReferenceType &type)\n+{}\n+void\n+ASTLoweringBase::visit (AST::ArrayType &type)\n+{}\n+void\n+ASTLoweringBase::visit (AST::SliceType &type)\n+{}\n+void\n+ASTLoweringBase::visit (AST::InferredType &type)\n+{}\n+void\n+ASTLoweringBase::visit (AST::BareFunctionType &type)\n+{}\n+\n+HIR::Lifetime\n+ASTLoweringBase::lower_lifetime (AST::Lifetime &lifetime)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, lifetime.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+  mappings->insert_node_to_hir (mapping.get_nodeid (), mapping.get_hirid ());\n+\n+  return HIR::Lifetime (mapping, lifetime.get_lifetime_type (),\n+\t\t\tlifetime.get_lifetime_name (), lifetime.get_locus ());\n+}\n+\n+HIR::LoopLabel\n+ASTLoweringBase::lower_loop_label (AST::LoopLabel &loop_label)\n+{\n+  HIR::Lifetime life = lower_lifetime (loop_label.get_lifetime ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, loop_label.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+  mappings->insert_node_to_hir (mapping.get_nodeid (), mapping.get_hirid ());\n+\n+  return HIR::LoopLabel (mapping, std::move (life), loop_label.get_locus ());\n+}\n+\n+std::vector<std::unique_ptr<HIR::GenericParam>>\n+ASTLoweringBase::lower_generic_params (\n+  std::vector<std::unique_ptr<AST::GenericParam>> &params)\n+{\n+  std::vector<std::unique_ptr<HIR::GenericParam>> lowered;\n+  for (auto &ast_param : params)\n+    {\n+      auto hir_param = ASTLowerGenericParam::translate (ast_param.get ());\n+      lowered.push_back (std::unique_ptr<HIR::GenericParam> (hir_param));\n+    }\n+\n+  return lowered;\n+}\n+\n+HIR::PathExprSegment\n+ASTLoweringBase::lower_path_expr_seg (AST::PathExprSegment &s)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, s.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  return HIR::PathExprSegment (\n+    std::move (mapping),\n+    HIR::PathIdentSegment (s.get_ident_segment ().as_string ()), s.get_locus (),\n+    s.has_generic_args () ? lower_generic_args (s.get_generic_args ())\n+\t\t\t  : HIR::GenericArgs::create_empty ());\n+}\n+\n+HIR::GenericArgsBinding\n+ASTLoweringBase::lower_binding (AST::GenericArgsBinding &binding)\n+{\n+  HIR::Type *lowered_type\n+    = ASTLoweringType::translate (binding.get_type ().get ());\n+  return HIR::GenericArgsBinding (binding.get_identifier (),\n+\t\t\t\t  std::unique_ptr<HIR::Type> (lowered_type),\n+\t\t\t\t  binding.get_locus ());\n+}\n+\n+HIR::GenericArgs\n+ASTLoweringBase::lower_generic_args (AST::GenericArgs &args)\n+{\n+  std::vector<HIR::GenericArgsBinding> binding_args;\n+  for (auto &binding : args.get_binding_args ())\n+    {\n+      HIR::GenericArgsBinding b = lower_binding (binding);\n+      binding_args.push_back (std::move (b));\n+    }\n+\n+  std::vector<HIR::Lifetime> lifetime_args;\n+  for (auto &lifetime : args.get_lifetime_args ())\n+    {\n+      HIR::Lifetime l = lower_lifetime (lifetime);\n+      lifetime_args.push_back (std::move (l));\n+    }\n+\n+  std::vector<std::unique_ptr<HIR::Type>> type_args;\n+  std::vector<HIR::ConstGenericArg> const_args;\n+\n+  for (auto &arg : args.get_generic_args ())\n+    {\n+      switch (arg.get_kind ())\n+\t{\n+\t  case AST::GenericArg::Kind::Type: {\n+\t    auto type = ASTLoweringType::translate (arg.get_type ().get ());\n+\t    type_args.emplace_back (std::unique_ptr<HIR::Type> (type));\n+\t    break;\n+\t  }\n+\t  case AST::GenericArg::Kind::Const: {\n+\t    auto expr\n+\t      = ASTLoweringExpr::translate (arg.get_expression ().get ());\n+\t    const_args.emplace_back (\n+\t      HIR::ConstGenericArg (std::unique_ptr<HIR::Expr> (expr),\n+\t\t\t\t    expr->get_locus ()));\n+\t    break;\n+\t  }\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  return HIR::GenericArgs (std::move (lifetime_args), std::move (type_args),\n+\t\t\t   std::move (binding_args), std::move (const_args),\n+\t\t\t   args.get_locus ());\n+}\n+\n+HIR::SelfParam\n+ASTLoweringBase::lower_self (AST::SelfParam &self)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, self.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  if (self.has_type ())\n+    {\n+      HIR::Type *type = ASTLoweringType::translate (self.get_type ().get ());\n+      return HIR::SelfParam (mapping, std::unique_ptr<HIR::Type> (type),\n+\t\t\t     self.get_is_mut (), self.get_locus ());\n+    }\n+  else if (!self.get_has_ref ())\n+    {\n+      return HIR::SelfParam (mapping, std::unique_ptr<HIR::Type> (nullptr),\n+\t\t\t     self.get_is_mut (), self.get_locus ());\n+    }\n+\n+  AST::Lifetime l = self.get_lifetime ();\n+  return HIR::SelfParam (mapping, lower_lifetime (l), self.get_is_mut (),\n+\t\t\t self.get_locus ());\n+}\n+\n+void\n+ASTLowerTypePath::visit (AST::TypePathSegmentGeneric &segment)\n+{\n+  std::vector<HIR::GenericArgsBinding> binding_args; // TODO\n+\n+  std::string segment_name = segment.get_ident_segment ().as_string ();\n+  bool has_separating_scope_resolution\n+    = segment.get_separating_scope_resolution ();\n+\n+  auto generic_args = lower_generic_args (segment.get_generic_args ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  auto hirid = mappings->get_next_hir_id (crate_num);\n+  Analysis::NodeMapping mapping (crate_num, segment.get_node_id (), hirid,\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated_segment\n+    = new HIR::TypePathSegmentGeneric (std::move (mapping), segment_name,\n+\t\t\t\t       has_separating_scope_resolution,\n+\t\t\t\t       generic_args, segment.get_locus ());\n+}\n+\n+void\n+ASTLowerQualifiedPathInType::visit (AST::QualifiedPathInType &path)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  auto hirid = mappings->get_next_hir_id (crate_num);\n+  Analysis::NodeMapping qual_mappings (\n+    crate_num, path.get_qualified_path_type ().get_node_id (), hirid,\n+    UNKNOWN_LOCAL_DEFID);\n+\n+  HIR::Type *qual_type = ASTLoweringType::translate (\n+    path.get_qualified_path_type ().get_type ().get ());\n+  HIR::TypePath *qual_trait = ASTLowerTypePath::translate (\n+    path.get_qualified_path_type ().get_as_type_path ());\n+\n+  HIR::QualifiedPathType qual_path_type (\n+    qual_mappings, std::unique_ptr<HIR::Type> (qual_type),\n+    std::unique_ptr<HIR::TypePath> (qual_trait),\n+    path.get_qualified_path_type ().get_locus ());\n+\n+  translated_segment = nullptr;\n+  path.get_associated_segment ()->accept_vis (*this);\n+  if (translated_segment == nullptr)\n+    {\n+      rust_fatal_error (path.get_associated_segment ()->get_locus (),\n+\t\t\t\"failed to translate AST TypePathSegment\");\n+      return;\n+    }\n+  std::unique_ptr<HIR::TypePathSegment> associated_segment (translated_segment);\n+\n+  std::vector<std::unique_ptr<HIR::TypePathSegment>> translated_segments;\n+  for (auto &seg : path.get_segments ())\n+    {\n+      translated_segment = nullptr;\n+      seg->accept_vis (*this);\n+      if (translated_segment == nullptr)\n+\t{\n+\t  rust_fatal_error (seg->get_locus (),\n+\t\t\t    \"failed to translte AST TypePathSegment\");\n+\t}\n+      translated_segments.push_back (\n+\tstd::unique_ptr<HIR::TypePathSegment> (translated_segment));\n+    }\n+\n+  Analysis::NodeMapping mapping (crate_num, path.get_node_id (), hirid,\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+  translated = new HIR::QualifiedPathInType (std::move (mapping),\n+\t\t\t\t\t     std::move (qual_path_type),\n+\t\t\t\t\t     std::move (associated_segment),\n+\t\t\t\t\t     std::move (translated_segments),\n+\t\t\t\t\t     path.get_locus ());\n+}\n+\n+void\n+ASTLoweringType::visit (AST::TraitObjectTypeOneBound &type)\n+{\n+  std::vector<std::unique_ptr<HIR::TypeParamBound>> bounds;\n+  HIR::TypeParamBound *translated_bound\n+    = ASTLoweringTypeBounds::translate (&type.get_trait_bound ());\n+  bounds.push_back (std::unique_ptr<HIR::TypeParamBound> (translated_bound));\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::TraitObjectType (mapping, std::move (bounds),\n+\t\t\t\t\t type.get_locus (), type.is_dyn ());\n+}\n+\n+void\n+ASTLoweringType::visit (AST::TraitObjectType &type)\n+{\n+  std::vector<std::unique_ptr<HIR::TypeParamBound>> bounds;\n+\n+  for (auto &bound : type.get_type_param_bounds ())\n+    {\n+      HIR::TypeParamBound *translated_bound\n+\t= ASTLoweringTypeBounds::translate (bound.get ());\n+      bounds.push_back (\n+\tstd::unique_ptr<HIR::TypeParamBound> (translated_bound));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::TraitObjectType (mapping, std::move (bounds),\n+\t\t\t\t\t type.get_locus (), type.is_dyn ());\n+}\n+\n+HIR::Type *\n+ASTLoweringBase::lower_type_no_bounds (AST::TypeNoBounds *type)\n+{\n+  return ASTLoweringType::translate (type);\n+}\n+\n+HIR::TypeParamBound *\n+ASTLoweringBase::lower_bound (AST::TypeParamBound *bound)\n+{\n+  return ASTLoweringTypeBounds::translate (bound);\n+}\n+\n+/* Checks whether the name of a field already exists.  Returns true\n+   and produces an error if so.  */\n+bool\n+struct_field_name_exists (std::vector<HIR::StructField> &fields,\n+\t\t\t  HIR::StructField &new_field)\n+{\n+  for (auto &field : fields)\n+    {\n+      if (field.get_field_name ().compare (new_field.get_field_name ()) == 0)\n+\t{\n+\t  RichLocation r (new_field.get_locus ());\n+\t  r.add_range (field.get_locus ());\n+\t  rust_error_at (r, \"duplicate field name %qs\",\n+\t\t\t field.get_field_name ().c_str ());\n+\t  return true;\n+\t}\n+    }\n+  return false;\n+}\n+\n+HIR::FunctionQualifiers\n+ASTLoweringBase::lower_qualifiers (const AST::FunctionQualifiers &qualifiers)\n+{\n+  Unsafety unsafety\n+    = qualifiers.is_unsafe () ? Unsafety::Unsafe : Unsafety::Normal;\n+  bool has_extern = qualifiers.is_extern ();\n+\n+  ABI abi = ABI::RUST;\n+  if (qualifiers.has_abi ())\n+    {\n+      const std::string &extern_abi = qualifiers.get_extern_abi ();\n+      abi = get_abi_from_string (extern_abi);\n+      if (has_extern && abi == ABI::UNKNOWN)\n+\trust_error_at (qualifiers.get_locus (), \"unknown ABI option\");\n+    }\n+\n+  return HIR::FunctionQualifiers (qualifiers.get_const_status (), unsafety,\n+\t\t\t\t  has_extern, abi);\n+}\n+\n+void\n+ASTLoweringBase::handle_outer_attributes (const HIR::Item &item)\n+{\n+  for (const auto &attr : item.get_outer_attrs ())\n+    {\n+      const auto &str_path = attr.get_path ().as_string ();\n+      if (!is_known_attribute (str_path))\n+\t{\n+\t  rust_error_at (attr.get_locus (), \"unknown attribute\");\n+\t  continue;\n+\t}\n+\n+      bool is_lang_item = str_path.compare (\"lang\") == 0\n+\t\t\t  && attr.has_attr_input ()\n+\t\t\t  && attr.get_attr_input ().get_attr_input_type ()\n+\t\t\t       == AST::AttrInput::AttrInputType::LITERAL;\n+\n+      bool is_doc_item = str_path.compare (\"doc\") == 0;\n+\n+      if (is_doc_item)\n+\thandle_doc_item_attribute (item, attr);\n+      else if (is_lang_item)\n+\thandle_lang_item_attribute (item, attr);\n+      else if (!attribute_handled_in_another_pass (str_path))\n+\t{\n+\t  rust_error_at (attr.get_locus (), \"unhandled attribute: [%s]\",\n+\t\t\t attr.get_path ().as_string ().c_str ());\n+\t}\n+    }\n+}\n+\n+void\n+ASTLoweringBase::handle_doc_item_attribute (const HIR::Item &item,\n+\t\t\t\t\t    const AST::Attribute &attr)\n+{\n+  auto simple_doc_comment = attr.has_attr_input ()\n+\t\t\t    && attr.get_attr_input ().get_attr_input_type ()\n+\t\t\t\t == AST::AttrInput::AttrInputType::LITERAL;\n+  if (simple_doc_comment)\n+    return;\n+\n+  const AST::AttrInput &input = attr.get_attr_input ();\n+  bool is_token_tree\n+    = input.get_attr_input_type () == AST::AttrInput::AttrInputType::TOKEN_TREE;\n+  rust_assert (is_token_tree);\n+  const auto &option = static_cast<const AST::DelimTokenTree &> (input);\n+  AST::AttrInputMetaItemContainer *meta_item = option.parse_to_meta_item ();\n+\n+  // TODO: add actual and complete checks for the doc attributes\n+  //\n+  // FIXME: Move this to the AttributeChecker visitor\n+  rust_assert (meta_item);\n+}\n+\n+void\n+ASTLoweringBase::handle_lang_item_attribute (const HIR::Item &item,\n+\t\t\t\t\t     const AST::Attribute &attr)\n+{\n+  auto &literal = static_cast<AST::AttrInputLiteral &> (attr.get_attr_input ());\n+  const auto &lang_item_type_str = literal.get_literal ().as_string ();\n+  auto lang_item_type = Analysis::RustLangItem::Parse (lang_item_type_str);\n+  if (lang_item_type == Analysis::RustLangItem::ItemType::UNKNOWN)\n+    {\n+      rust_error_at (attr.get_locus (), \"unknown lang item\");\n+      return;\n+    }\n+  mappings->insert_lang_item (lang_item_type,\n+\t\t\t      item.get_mappings ().get_defid ());\n+}\n+\n+bool\n+ASTLoweringBase::is_known_attribute (const std::string &attribute_path) const\n+{\n+  const auto &lookup = attr_mappings->lookup_builtin (attribute_path);\n+  return !lookup.is_error ();\n+}\n+\n+bool\n+ASTLoweringBase::attribute_handled_in_another_pass (\n+  const std::string &attribute_path) const\n+{\n+  const auto &lookup = attr_mappings->lookup_builtin (attribute_path);\n+  if (lookup.is_error ())\n+    return false;\n+\n+  if (lookup.handler == Analysis::CompilerPass::UNKNOWN)\n+    return false;\n+\n+  return lookup.handler != Analysis::CompilerPass::HIR_LOWERING;\n+}\n+\n+std::unique_ptr<HIR::TuplePatternItems>\n+ASTLoweringBase::lower_tuple_pattern_multiple (\n+  AST::TuplePatternItemsMultiple &pattern)\n+{\n+  std::vector<std::unique_ptr<HIR::Pattern>> patterns;\n+  for (auto &p : pattern.get_patterns ())\n+    {\n+      HIR::Pattern *translated = ASTLoweringPattern::translate (p.get ());\n+      patterns.push_back (std::unique_ptr<HIR::Pattern> (translated));\n+    }\n+\n+  return std::unique_ptr<HIR::TuplePatternItems> (\n+    new HIR::TuplePatternItemsMultiple (std::move (patterns)));\n+}\n+\n+std::unique_ptr<TuplePatternItems>\n+ASTLoweringBase::lower_tuple_pattern_ranged (\n+  AST::TuplePatternItemsRanged &pattern)\n+{\n+  std::vector<std::unique_ptr<HIR::Pattern>> lower_patterns;\n+  std::vector<std::unique_ptr<HIR::Pattern>> upper_patterns;\n+\n+  for (auto &p : pattern.get_lower_patterns ())\n+    {\n+      HIR::Pattern *translated = ASTLoweringPattern::translate (p.get ());\n+      lower_patterns.push_back (std::unique_ptr<HIR::Pattern> (translated));\n+    }\n+\n+  for (auto &p : pattern.get_upper_patterns ())\n+    {\n+      HIR::Pattern *translated = ASTLoweringPattern::translate (p.get ());\n+      upper_patterns.push_back (std::unique_ptr<HIR::Pattern> (translated));\n+    }\n+\n+  return std::unique_ptr<HIR::TuplePatternItems> (\n+    new HIR::TuplePatternItemsRanged (std::move (lower_patterns),\n+\t\t\t\t      std::move (upper_patterns)));\n+}\n+\n+std::unique_ptr<HIR::RangePatternBound>\n+ASTLoweringBase::lower_range_pattern_bound (AST::RangePatternBound *bound)\n+{\n+  std::unique_ptr<HIR::RangePatternBound> hir_bound = nullptr;\n+  switch (bound->get_bound_type ())\n+    {\n+      case AST::RangePatternBound::RangePatternBoundType::LITERAL: {\n+\tAST::RangePatternBoundLiteral &ref\n+\t  = *static_cast<AST::RangePatternBoundLiteral *> (bound);\n+\n+\tHIR::Literal literal = lower_literal (ref.get_literal ());\n+\n+\thir_bound = std::unique_ptr<HIR::RangePatternBound> (\n+\t  new HIR::RangePatternBoundLiteral (literal, ref.get_locus (),\n+\t\t\t\t\t     ref.get_has_minus ()));\n+      }\n+      break;\n+      case AST::RangePatternBound::RangePatternBoundType::PATH: {\n+\tAST::RangePatternBoundPath &ref\n+\t  = *static_cast<AST::RangePatternBoundPath *> (bound);\n+\n+\tHIR::PathInExpression *path\n+\t  = ASTLowerPathInExpression::translate (&ref.get_path ());\n+\n+\thir_bound = std::unique_ptr<HIR::RangePatternBound> (\n+\t  new HIR::RangePatternBoundPath (*path));\n+      }\n+      break;\n+      case AST::RangePatternBound::RangePatternBoundType::QUALPATH: {\n+\tAST::RangePatternBoundQualPath &ref\n+\t  = *static_cast<AST::RangePatternBoundQualPath *> (bound);\n+\n+\tHIR::QualifiedPathInExpression *qualpath\n+\t  = ASTLowerQualPathInExpression::translate (\n+\t    &ref.get_qualified_path ());\n+\n+\thir_bound = std::unique_ptr<HIR::RangePatternBound> (\n+\t  new HIR::RangePatternBoundQualPath (*qualpath));\n+      }\n+      break;\n+    }\n+\n+  return hir_bound;\n+}\n+\n+HIR::Literal\n+ASTLoweringBase::lower_literal (const AST::Literal &literal)\n+{\n+  HIR::Literal::LitType type = HIR::Literal::LitType::CHAR;\n+  switch (literal.get_lit_type ())\n+    {\n+    case AST::Literal::LitType::CHAR:\n+      type = HIR::Literal::LitType::CHAR;\n+      break;\n+    case AST::Literal::LitType::STRING:\n+      type = HIR::Literal::LitType::STRING;\n+      break;\n+    case AST::Literal::LitType::BYTE:\n+      type = HIR::Literal::LitType::BYTE;\n+      break;\n+    case AST::Literal::LitType::BYTE_STRING:\n+      type = HIR::Literal::LitType::BYTE_STRING;\n+      break;\n+    case AST::Literal::LitType::INT:\n+      type = HIR::Literal::LitType::INT;\n+      break;\n+    case AST::Literal::LitType::FLOAT:\n+      type = HIR::Literal::LitType::FLOAT;\n+      break;\n+    case AST::Literal::LitType::BOOL:\n+      type = HIR::Literal::LitType::BOOL;\n+      break;\n+    case AST::Literal::LitType::ERROR:\n+      gcc_unreachable ();\n+      break;\n+    }\n+\n+  return HIR::Literal (literal.as_string (), type, literal.get_type_hint ());\n+}\n+\n+HIR::ExternBlock *\n+ASTLoweringBase::lower_extern_block (AST::ExternBlock &extern_block)\n+{\n+  HIR::Visibility vis = translate_visibility (extern_block.get_visibility ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, extern_block.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  std::vector<std::unique_ptr<HIR::ExternalItem>> extern_items;\n+  for (auto &item : extern_block.get_extern_items ())\n+    {\n+      if (item->is_marked_for_strip ())\n+\tcontinue;\n+\n+      HIR::ExternalItem *lowered\n+\t= ASTLoweringExternItem::translate (item.get (), mapping.get_hirid ());\n+      extern_items.push_back (std::unique_ptr<HIR::ExternalItem> (lowered));\n+    }\n+\n+  ABI abi = ABI::RUST;\n+  if (extern_block.has_abi ())\n+    {\n+      const std::string &extern_abi = extern_block.get_abi ();\n+      abi = get_abi_from_string (extern_abi);\n+      if (abi == ABI::UNKNOWN)\n+\trust_error_at (extern_block.get_locus (), \"unknown ABI option\");\n+    }\n+\n+  HIR::ExternBlock *hir_extern_block\n+    = new HIR::ExternBlock (mapping, abi, std::move (extern_items),\n+\t\t\t    std::move (vis), extern_block.get_inner_attrs (),\n+\t\t\t    extern_block.get_outer_attrs (),\n+\t\t\t    extern_block.get_locus ());\n+\n+  mappings->insert_hir_extern_block (hir_extern_block);\n+\n+  return hir_extern_block;\n+}\n+\n+} // namespace HIR\n+} // namespace Rust"}, {"sha": "68c57e0c02b579054e8291f1509e75d767bf843d", "filename": "gcc/rust/hir/rust-ast-lower-base.h", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.h?ref=7999cf327de7b5bbea80046715eeb00c0755a08d", "patch": "@@ -0,0 +1,297 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_BASE\n+#define RUST_AST_LOWER_BASE\n+\n+#include \"rust-system.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-ast-visitor.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-attributes.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+// base class to allow derivatives to overload as needed\n+class ASTLoweringBase : public AST::ASTVisitor\n+{\n+public:\n+  virtual ~ASTLoweringBase () {}\n+\n+  // visitor impl\n+  // rust-ast.h\n+  //  virtual void visit(AttrInput& attr_input);\n+  //  virtual void visit(TokenTree& token_tree);\n+  //  virtual void visit(MacroMatch& macro_match);\n+  virtual void visit (AST::Token &tok);\n+  virtual void visit (AST::DelimTokenTree &delim_tok_tree);\n+  virtual void visit (AST::AttrInputMetaItemContainer &input);\n+  //  virtual void visit(MetaItem& meta_item);\n+  //  void vsit(Stmt& stmt);\n+  //  virtual void visit(Expr& expr);\n+  virtual void visit (AST::IdentifierExpr &ident_expr);\n+  //  virtual void visit(Pattern& pattern);\n+  //  virtual void visit(Type& type);\n+  //  virtual void visit(TypeParamBound& type_param_bound);\n+  virtual void visit (AST::Lifetime &lifetime);\n+  //  virtual void visit(GenericParam& generic_param);\n+  virtual void visit (AST::LifetimeParam &lifetime_param);\n+  virtual void visit (AST::ConstGenericParam &const_param);\n+  //  virtual void visit(TraitItem& trait_item);\n+  //  virtual void visit(InherentImplItem& inherent_impl_item);\n+  //  virtual void visit(TraitImplItem& trait_impl_item);\n+\n+  // rust-path.h\n+  virtual void visit (AST::PathInExpression &path);\n+  virtual void visit (AST::TypePathSegment &segment);\n+  virtual void visit (AST::TypePathSegmentGeneric &segment);\n+  virtual void visit (AST::TypePathSegmentFunction &segment);\n+  virtual void visit (AST::TypePath &path);\n+  virtual void visit (AST::QualifiedPathInExpression &path);\n+  virtual void visit (AST::QualifiedPathInType &path);\n+\n+  // rust-expr.h\n+  virtual void visit (AST::LiteralExpr &expr);\n+  virtual void visit (AST::AttrInputLiteral &attr_input);\n+  virtual void visit (AST::MetaItemLitExpr &meta_item);\n+  virtual void visit (AST::MetaItemPathLit &meta_item);\n+  virtual void visit (AST::BorrowExpr &expr);\n+  virtual void visit (AST::DereferenceExpr &expr);\n+  virtual void visit (AST::ErrorPropagationExpr &expr);\n+  virtual void visit (AST::NegationExpr &expr);\n+  virtual void visit (AST::ArithmeticOrLogicalExpr &expr);\n+  virtual void visit (AST::ComparisonExpr &expr);\n+  virtual void visit (AST::LazyBooleanExpr &expr);\n+  virtual void visit (AST::TypeCastExpr &expr);\n+  virtual void visit (AST::AssignmentExpr &expr);\n+  virtual void visit (AST::CompoundAssignmentExpr &expr);\n+  virtual void visit (AST::GroupedExpr &expr);\n+  //  virtual void visit(ArrayElems& elems);\n+  virtual void visit (AST::ArrayElemsValues &elems);\n+  virtual void visit (AST::ArrayElemsCopied &elems);\n+  virtual void visit (AST::ArrayExpr &expr);\n+  virtual void visit (AST::ArrayIndexExpr &expr);\n+  virtual void visit (AST::TupleExpr &expr);\n+  virtual void visit (AST::TupleIndexExpr &expr);\n+  virtual void visit (AST::StructExprStruct &expr);\n+  //  virtual void visit(StructExprField& field);\n+  virtual void visit (AST::StructExprFieldIdentifier &field);\n+  virtual void visit (AST::StructExprFieldIdentifierValue &field);\n+  virtual void visit (AST::StructExprFieldIndexValue &field);\n+  virtual void visit (AST::StructExprStructFields &expr);\n+  virtual void visit (AST::StructExprStructBase &expr);\n+  virtual void visit (AST::CallExpr &expr);\n+  virtual void visit (AST::MethodCallExpr &expr);\n+  virtual void visit (AST::FieldAccessExpr &expr);\n+  virtual void visit (AST::ClosureExprInner &expr);\n+  virtual void visit (AST::BlockExpr &expr);\n+  virtual void visit (AST::ClosureExprInnerTyped &expr);\n+  virtual void visit (AST::ContinueExpr &expr);\n+  virtual void visit (AST::BreakExpr &expr);\n+  virtual void visit (AST::RangeFromToExpr &expr);\n+  virtual void visit (AST::RangeFromExpr &expr);\n+  virtual void visit (AST::RangeToExpr &expr);\n+  virtual void visit (AST::RangeFullExpr &expr);\n+  virtual void visit (AST::RangeFromToInclExpr &expr);\n+  virtual void visit (AST::RangeToInclExpr &expr);\n+  virtual void visit (AST::ReturnExpr &expr);\n+  virtual void visit (AST::UnsafeBlockExpr &expr);\n+  virtual void visit (AST::LoopExpr &expr);\n+  virtual void visit (AST::WhileLoopExpr &expr);\n+  virtual void visit (AST::WhileLetLoopExpr &expr);\n+  virtual void visit (AST::ForLoopExpr &expr);\n+  virtual void visit (AST::IfExpr &expr);\n+  virtual void visit (AST::IfExprConseqElse &expr);\n+  virtual void visit (AST::IfExprConseqIf &expr);\n+  virtual void visit (AST::IfExprConseqIfLet &expr);\n+  virtual void visit (AST::IfLetExpr &expr);\n+  virtual void visit (AST::IfLetExprConseqElse &expr);\n+  virtual void visit (AST::IfLetExprConseqIf &expr);\n+  virtual void visit (AST::IfLetExprConseqIfLet &expr);\n+  //  virtual void visit(MatchCase& match_case);\n+  // virtual void visit (AST::MatchCaseBlockExpr &match_case);\n+  // virtual void visit (AST::MatchCaseExpr &match_case);\n+  virtual void visit (AST::MatchExpr &expr);\n+  virtual void visit (AST::AwaitExpr &expr);\n+  virtual void visit (AST::AsyncBlockExpr &expr);\n+\n+  // rust-item.h\n+  virtual void visit (AST::TypeParam &param);\n+  //  virtual void visit(WhereClauseItem& item);\n+  virtual void visit (AST::LifetimeWhereClauseItem &item);\n+  virtual void visit (AST::TypeBoundWhereClauseItem &item);\n+  virtual void visit (AST::Method &method);\n+  virtual void visit (AST::Module &module);\n+  virtual void visit (AST::ExternCrate &crate);\n+  //  virtual void visit(UseTree& use_tree);\n+  virtual void visit (AST::UseTreeGlob &use_tree);\n+  virtual void visit (AST::UseTreeList &use_tree);\n+  virtual void visit (AST::UseTreeRebind &use_tree);\n+  virtual void visit (AST::UseDeclaration &use_decl);\n+  virtual void visit (AST::Function &function);\n+  virtual void visit (AST::TypeAlias &type_alias);\n+  virtual void visit (AST::StructStruct &struct_item);\n+  virtual void visit (AST::TupleStruct &tuple_struct);\n+  virtual void visit (AST::EnumItem &item);\n+  virtual void visit (AST::EnumItemTuple &item);\n+  virtual void visit (AST::EnumItemStruct &item);\n+  virtual void visit (AST::EnumItemDiscriminant &item);\n+  virtual void visit (AST::Enum &enum_item);\n+  virtual void visit (AST::Union &union_item);\n+  virtual void visit (AST::ConstantItem &const_item);\n+  virtual void visit (AST::StaticItem &static_item);\n+  virtual void visit (AST::TraitItemFunc &item);\n+  virtual void visit (AST::TraitItemMethod &item);\n+  virtual void visit (AST::TraitItemConst &item);\n+  virtual void visit (AST::TraitItemType &item);\n+  virtual void visit (AST::Trait &trait);\n+  virtual void visit (AST::InherentImpl &impl);\n+  virtual void visit (AST::TraitImpl &impl);\n+  //  virtual void visit(ExternalItem& item);\n+  virtual void visit (AST::ExternalStaticItem &item);\n+  virtual void visit (AST::ExternalFunctionItem &item);\n+  virtual void visit (AST::ExternBlock &block);\n+\n+  // rust-macro.h\n+  virtual void visit (AST::MacroMatchFragment &match);\n+  virtual void visit (AST::MacroMatchRepetition &match);\n+  virtual void visit (AST::MacroMatcher &matcher);\n+  virtual void visit (AST::MacroRulesDefinition &rules_def);\n+  virtual void visit (AST::MacroInvocation &macro_invoc);\n+  virtual void visit (AST::MetaItemPath &meta_item);\n+  virtual void visit (AST::MetaItemSeq &meta_item);\n+  virtual void visit (AST::MetaWord &meta_item);\n+  virtual void visit (AST::MetaNameValueStr &meta_item);\n+  virtual void visit (AST::MetaListPaths &meta_item);\n+  virtual void visit (AST::MetaListNameValueStr &meta_item);\n+\n+  // rust-pattern.h\n+  virtual void visit (AST::LiteralPattern &pattern);\n+  virtual void visit (AST::IdentifierPattern &pattern);\n+  virtual void visit (AST::WildcardPattern &pattern);\n+  //  virtual void visit(RangePatternBound& bound);\n+  virtual void visit (AST::RangePatternBoundLiteral &bound);\n+  virtual void visit (AST::RangePatternBoundPath &bound);\n+  virtual void visit (AST::RangePatternBoundQualPath &bound);\n+  virtual void visit (AST::RangePattern &pattern);\n+  virtual void visit (AST::ReferencePattern &pattern);\n+  //  virtual void visit(StructPatternField& field);\n+  virtual void visit (AST::StructPatternFieldTuplePat &field);\n+  virtual void visit (AST::StructPatternFieldIdentPat &field);\n+  virtual void visit (AST::StructPatternFieldIdent &field);\n+  virtual void visit (AST::StructPattern &pattern);\n+  //  virtual void visit(TupleStructItems& tuple_items);\n+  virtual void visit (AST::TupleStructItemsNoRange &tuple_items);\n+  virtual void visit (AST::TupleStructItemsRange &tuple_items);\n+  virtual void visit (AST::TupleStructPattern &pattern);\n+  //  virtual void visit(TuplePatternItems& tuple_items);\n+  virtual void visit (AST::TuplePatternItemsMultiple &tuple_items);\n+  virtual void visit (AST::TuplePatternItemsRanged &tuple_items);\n+  virtual void visit (AST::TuplePattern &pattern);\n+  virtual void visit (AST::GroupedPattern &pattern);\n+  virtual void visit (AST::SlicePattern &pattern);\n+\n+  // rust-stmt.h\n+  virtual void visit (AST::EmptyStmt &stmt);\n+  virtual void visit (AST::LetStmt &stmt);\n+  virtual void visit (AST::ExprStmtWithoutBlock &stmt);\n+  virtual void visit (AST::ExprStmtWithBlock &stmt);\n+\n+  // rust-type.h\n+  virtual void visit (AST::TraitBound &bound);\n+  virtual void visit (AST::ImplTraitType &type);\n+  virtual void visit (AST::TraitObjectType &type);\n+  virtual void visit (AST::ParenthesisedType &type);\n+  virtual void visit (AST::ImplTraitTypeOneBound &type);\n+  virtual void visit (AST::TraitObjectTypeOneBound &type);\n+  virtual void visit (AST::TupleType &type);\n+  virtual void visit (AST::NeverType &type);\n+  virtual void visit (AST::RawPointerType &type);\n+  virtual void visit (AST::ReferenceType &type);\n+  virtual void visit (AST::ArrayType &type);\n+  virtual void visit (AST::SliceType &type);\n+  virtual void visit (AST::InferredType &type);\n+  virtual void visit (AST::BareFunctionType &type);\n+\n+protected:\n+  ASTLoweringBase ()\n+    : mappings (Analysis::Mappings::get ()),\n+      attr_mappings (Analysis::BuiltinAttributeMappings::get ())\n+  {}\n+\n+  Analysis::Mappings *mappings;\n+  Analysis::BuiltinAttributeMappings *attr_mappings;\n+\n+  HIR::Lifetime lower_lifetime (AST::Lifetime &lifetime);\n+\n+  HIR::LoopLabel lower_loop_label (AST::LoopLabel &loop_label);\n+\n+  std::vector<std::unique_ptr<HIR::GenericParam> > lower_generic_params (\n+    std::vector<std::unique_ptr<AST::GenericParam> > &params);\n+\n+  HIR::PathExprSegment lower_path_expr_seg (AST::PathExprSegment &s);\n+\n+  HIR::GenericArgs lower_generic_args (AST::GenericArgs &args);\n+\n+  HIR::GenericArgsBinding lower_binding (AST::GenericArgsBinding &binding);\n+\n+  HIR::SelfParam lower_self (AST::SelfParam &self);\n+\n+  HIR::Type *lower_type_no_bounds (AST::TypeNoBounds *type);\n+\n+  HIR::TypeParamBound *lower_bound (AST::TypeParamBound *bound);\n+\n+  HIR::QualifiedPathType\n+  lower_qual_path_type (AST::QualifiedPathType &qual_path_type);\n+\n+  HIR::FunctionQualifiers\n+  lower_qualifiers (const AST::FunctionQualifiers &qualifiers);\n+\n+  void handle_outer_attributes (const HIR::Item &item);\n+\n+  void handle_lang_item_attribute (const HIR::Item &item,\n+\t\t\t\t   const AST::Attribute &attr);\n+\n+  void handle_doc_item_attribute (const HIR::Item &item,\n+\t\t\t\t  const AST::Attribute &attr);\n+\n+  bool is_known_attribute (const std::string &attribute_path) const;\n+\n+  bool\n+  attribute_handled_in_another_pass (const std::string &attribute_path) const;\n+\n+  std::unique_ptr<TuplePatternItems>\n+  lower_tuple_pattern_multiple (AST::TuplePatternItemsMultiple &pattern);\n+\n+  std::unique_ptr<TuplePatternItems>\n+  lower_tuple_pattern_ranged (AST::TuplePatternItemsRanged &pattern);\n+\n+  std::unique_ptr<HIR::RangePatternBound>\n+  lower_range_pattern_bound (AST::RangePatternBound *bound);\n+\n+  HIR::Literal lower_literal (const AST::Literal &literal);\n+\n+  HIR::ExternBlock *lower_extern_block (AST::ExternBlock &extern_block);\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_BASE"}, {"sha": "0d3c704c6f13a5d712dc16f728663042c1f12f2c", "filename": "gcc/rust/hir/rust-ast-lower-block.h", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-block.h?ref=7999cf327de7b5bbea80046715eeb00c0755a08d", "patch": "@@ -0,0 +1,230 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_BLOCK\n+#define RUST_AST_LOWER_BLOCK\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-ast-lower-base.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLoweringBlock : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::BlockExpr *translate (AST::BlockExpr *expr, bool *terminated)\n+  {\n+    ASTLoweringBlock resolver;\n+    expr->accept_vis (resolver);\n+    if (resolver.translated != nullptr)\n+      {\n+\tresolver.mappings->insert_hir_expr (resolver.translated);\n+      }\n+\n+    *terminated = resolver.terminated;\n+    return resolver.translated;\n+  }\n+\n+  static HIR::UnsafeBlockExpr *translate (AST::UnsafeBlockExpr *expr,\n+\t\t\t\t\t  bool *terminated)\n+  {\n+    ASTLoweringBlock resolver;\n+\n+    HIR::BlockExpr *block\n+      = ASTLoweringBlock::translate (expr->get_block_expr ().get (),\n+\t\t\t\t     terminated);\n+    auto crate_num = resolver.mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr->get_node_id (),\n+\t\t\t\t   resolver.mappings->get_next_hir_id (\n+\t\t\t\t     crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    HIR::UnsafeBlockExpr *translated\n+      = new HIR::UnsafeBlockExpr (mapping,\n+\t\t\t\t  std::unique_ptr<HIR::BlockExpr> (block),\n+\t\t\t\t  expr->get_outer_attrs (), expr->get_locus ());\n+\n+    resolver.mappings->insert_hir_expr (translated);\n+\n+    return translated;\n+  }\n+\n+  void visit (AST::BlockExpr &expr) override;\n+\n+private:\n+  ASTLoweringBlock ()\n+    : ASTLoweringBase (), translated (nullptr), terminated (false)\n+  {}\n+\n+  HIR::BlockExpr *translated;\n+  bool terminated;\n+};\n+\n+class ASTLoweringIfBlock : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::IfExpr *translate (AST::IfExpr *expr, bool *terminated)\n+  {\n+    ASTLoweringIfBlock resolver;\n+    expr->accept_vis (resolver);\n+    if (resolver.translated != nullptr)\n+      {\n+\tresolver.mappings->insert_hir_expr (resolver.translated);\n+      }\n+    *terminated = resolver.terminated;\n+    return resolver.translated;\n+  }\n+\n+  ~ASTLoweringIfBlock () {}\n+\n+  void visit (AST::IfExpr &expr) override;\n+\n+  void visit (AST::IfExprConseqElse &expr) override;\n+\n+  void visit (AST::IfExprConseqIf &expr) override;\n+\n+private:\n+  ASTLoweringIfBlock ()\n+    : ASTLoweringBase (), translated (nullptr), terminated (false)\n+  {}\n+\n+  HIR::IfExpr *translated;\n+  bool terminated;\n+};\n+\n+class ASTLoweringIfLetBlock : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::IfLetExpr *translate (AST::IfLetExpr *expr)\n+  {\n+    ASTLoweringIfLetBlock resolver;\n+    expr->accept_vis (resolver);\n+    if (resolver.translated != nullptr)\n+      {\n+\tresolver.mappings->insert_hir_expr (resolver.translated);\n+      }\n+    return resolver.translated;\n+  }\n+\n+  ~ASTLoweringIfLetBlock () {}\n+\n+  void visit (AST::IfLetExpr &expr) override;\n+\n+private:\n+  ASTLoweringIfLetBlock () : ASTLoweringBase (), translated (nullptr) {}\n+\n+  HIR::IfLetExpr *translated;\n+};\n+\n+class ASTLoweringExprWithBlock : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::ExprWithBlock *translate (AST::ExprWithBlock *expr,\n+\t\t\t\t\tbool *terminated)\n+  {\n+    ASTLoweringExprWithBlock resolver;\n+    expr->accept_vis (resolver);\n+    if (resolver.translated != nullptr)\n+      {\n+\tresolver.mappings->insert_hir_expr (resolver.translated);\n+      }\n+\n+    *terminated = resolver.terminated;\n+    return resolver.translated;\n+  }\n+\n+  ~ASTLoweringExprWithBlock () {}\n+\n+  void visit (AST::IfExpr &expr) override\n+  {\n+    translated = ASTLoweringIfBlock::translate (&expr, &terminated);\n+  }\n+\n+  void visit (AST::IfExprConseqElse &expr) override\n+  {\n+    translated = ASTLoweringIfBlock::translate (&expr, &terminated);\n+  }\n+\n+  void visit (AST::IfExprConseqIf &expr) override\n+  {\n+    translated = ASTLoweringIfBlock::translate (&expr, &terminated);\n+  }\n+\n+  void visit (AST::IfLetExpr &expr) override\n+  {\n+    translated = ASTLoweringIfLetBlock::translate (&expr);\n+  }\n+\n+  void visit (AST::BlockExpr &expr) override\n+  {\n+    translated = ASTLoweringBlock::translate (&expr, &terminated);\n+  }\n+\n+  void visit (AST::UnsafeBlockExpr &expr) override\n+  {\n+    translated = ASTLoweringBlock::translate (&expr, &terminated);\n+  }\n+\n+  void visit (AST::LoopExpr &expr) override\n+  {\n+    HIR::BlockExpr *loop_block\n+      = ASTLoweringBlock::translate (expr.get_loop_block ().get (),\n+\t\t\t\t     &terminated);\n+\n+    HIR::LoopLabel loop_label = lower_loop_label (expr.get_loop_label ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::LoopExpr (mapping,\n+\t\t\t   std::unique_ptr<HIR::BlockExpr> (loop_block),\n+\t\t\t   expr.get_locus (), std::move (loop_label),\n+\t\t\t   expr.get_outer_attrs ());\n+  }\n+\n+  void visit (AST::WhileLoopExpr &expr) override;\n+\n+  void visit (AST::ForLoopExpr &expr) override;\n+\n+  void visit (AST::MatchExpr &expr) override;\n+\n+private:\n+  ASTLoweringExprWithBlock ()\n+    : ASTLoweringBase (), translated (nullptr), terminated (false)\n+  {}\n+\n+  HIR::ExprWithBlock *translated;\n+  bool terminated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_BLOCK"}, {"sha": "b76658c78ccd164c5ca1b4ef5f040e65952d309d", "filename": "gcc/rust/hir/rust-ast-lower-enumitem.h", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-enumitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-enumitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-enumitem.h?ref=7999cf327de7b5bbea80046715eeb00c0755a08d", "patch": "@@ -0,0 +1,181 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_ENUMITEM\n+#define RUST_AST_LOWER_ENUMITEM\n+\n+#include \"rust-ast-lower.h\"\n+#include \"rust-diagnostics.h\"\n+\n+#include \"rust-ast-lower-base.h\"\n+#include \"rust-ast-lower-type.h\"\n+#include \"rust-ast-lower-expr.h\"\n+#include \"rust-hir-full-decls.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLoweringEnumItem : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::EnumItem *translate (AST::EnumItem *item)\n+  {\n+    ASTLoweringEnumItem resolver;\n+    item->accept_vis (resolver);\n+\n+    rust_assert (resolver.translated != nullptr);\n+\n+    auto hirid = resolver.translated->get_mappings ().get_hirid ();\n+    auto defid = resolver.translated->get_mappings ().get_defid ();\n+\n+    resolver.mappings->insert_defid_mapping (defid, resolver.translated);\n+    resolver.mappings->insert_hir_item (resolver.translated);\n+    resolver.mappings->insert_location (hirid,\n+\t\t\t\t\tresolver.translated->get_locus ());\n+\n+    return resolver.translated;\n+  }\n+\n+  void visit (AST::EnumItem &item) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, item.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    if (item.has_visibility ())\n+      rust_error_at (item.get_locus (),\n+\t\t     \"visibility qualifier %qs not allowed on enum item\",\n+\t\t     item.get_visibility ().as_string ().c_str ());\n+    translated = new HIR::EnumItem (mapping, item.get_identifier (),\n+\t\t\t\t    item.get_outer_attrs (), item.get_locus ());\n+  }\n+\n+  void visit (AST::EnumItemTuple &item) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, item.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    if (item.has_visibility ())\n+      rust_error_at (item.get_locus (),\n+\t\t     \"visibility qualifier %qs not allowed on enum item\",\n+\t\t     item.get_visibility ().as_string ().c_str ());\n+\n+    std::vector<HIR::TupleField> fields;\n+    for (auto &field : item.get_tuple_fields ())\n+      {\n+\tHIR::Visibility vis = translate_visibility (field.get_visibility ());\n+\tHIR::Type *type\n+\t  = ASTLoweringType::translate (field.get_field_type ().get ());\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping field_mapping (\n+\t  crate_num, field.get_node_id (),\n+\t  mappings->get_next_hir_id (crate_num),\n+\t  mappings->get_next_localdef_id (crate_num));\n+\n+\tHIR::TupleField translated_field (field_mapping,\n+\t\t\t\t\t  std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t\t  vis, field.get_locus (),\n+\t\t\t\t\t  field.get_outer_attrs ());\n+\tfields.push_back (std::move (translated_field));\n+      }\n+\n+    translated\n+      = new HIR::EnumItemTuple (mapping, item.get_identifier (),\n+\t\t\t\tstd::move (fields), item.get_outer_attrs (),\n+\t\t\t\titem.get_locus ());\n+  }\n+\n+  void visit (AST::EnumItemStruct &item) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, item.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    if (item.has_visibility ())\n+      rust_error_at (item.get_locus (),\n+\t\t     \"visibility qualifier %qs not allowed on enum item\",\n+\t\t     item.get_visibility ().as_string ().c_str ());\n+\n+    std::vector<HIR::StructField> fields;\n+    for (auto &field : item.get_struct_fields ())\n+      {\n+\tHIR::Visibility vis = translate_visibility (field.get_visibility ());\n+\tHIR::Type *type\n+\t  = ASTLoweringType::translate (field.get_field_type ().get ());\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping field_mapping (\n+\t  crate_num, field.get_node_id (),\n+\t  mappings->get_next_hir_id (crate_num),\n+\t  mappings->get_next_localdef_id (crate_num));\n+\n+\tHIR::StructField translated_field (field_mapping,\n+\t\t\t\t\t   field.get_field_name (),\n+\t\t\t\t\t   std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t\t   vis, field.get_locus (),\n+\t\t\t\t\t   field.get_outer_attrs ());\n+\n+\tif (struct_field_name_exists (fields, translated_field))\n+\t  break;\n+\n+\tfields.push_back (std::move (translated_field));\n+      }\n+\n+    translated\n+      = new HIR::EnumItemStruct (mapping, item.get_identifier (),\n+\t\t\t\t std::move (fields), item.get_outer_attrs (),\n+\t\t\t\t item.get_locus ());\n+  }\n+\n+  void visit (AST::EnumItemDiscriminant &item) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, item.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    if (item.has_visibility ())\n+      rust_error_at (item.get_locus (),\n+\t\t     \"visibility qualifier %qs not allowed on enum item\",\n+\t\t     item.get_visibility ().as_string ().c_str ());\n+\n+    HIR::Expr *expr = ASTLoweringExpr::translate (item.get_expr ().get ());\n+    translated\n+      = new HIR::EnumItemDiscriminant (mapping, item.get_identifier (),\n+\t\t\t\t       std::unique_ptr<HIR::Expr> (expr),\n+\t\t\t\t       item.get_outer_attrs (),\n+\t\t\t\t       item.get_locus ());\n+  }\n+\n+private:\n+  ASTLoweringEnumItem () : translated (nullptr) {}\n+\n+  HIR::EnumItem *translated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_ENUMITEM"}, {"sha": "4f7f40f27e45f981ff575ed712833c449fa71683", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "added", "additions": 766, "deletions": 0, "changes": 766, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=7999cf327de7b5bbea80046715eeb00c0755a08d", "patch": "@@ -0,0 +1,766 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_EXPR\n+#define RUST_AST_LOWER_EXPR\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-ast-lower-base.h\"\n+#include \"rust-ast-lower-block.h\"\n+#include \"rust-ast-lower-struct-field-expr.h\"\n+#include \"rust-ast-lower-pattern.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLowerPathInExpression : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::PathInExpression *translate (AST::PathInExpression *expr)\n+  {\n+    ASTLowerPathInExpression compiler;\n+    expr->accept_vis (compiler);\n+    rust_assert (compiler.translated);\n+    return compiler.translated;\n+  }\n+\n+  void visit (AST::PathInExpression &expr) override;\n+\n+private:\n+  ASTLowerPathInExpression () : translated (nullptr) {}\n+\n+  HIR::PathInExpression *translated;\n+};\n+\n+class ASTLowerQualPathInExpression : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::QualifiedPathInExpression *\n+  translate (AST::QualifiedPathInExpression *expr)\n+  {\n+    ASTLowerQualPathInExpression compiler;\n+    expr->accept_vis (compiler);\n+    rust_assert (compiler.translated);\n+    return compiler.translated;\n+  }\n+\n+  void visit (AST::QualifiedPathInExpression &expr) override;\n+\n+private:\n+  ASTLowerQualPathInExpression () : translated (nullptr) {}\n+\n+  HIR::QualifiedPathInExpression *translated;\n+};\n+\n+class ASTLoweringExpr : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::Expr *translate (AST::Expr *expr, bool *terminated = nullptr)\n+  {\n+    ASTLoweringExpr resolver;\n+    expr->accept_vis (resolver);\n+    if (resolver.translated == nullptr)\n+      {\n+\trust_fatal_error (expr->get_locus (), \"Failed to lower expr: [%s]\",\n+\t\t\t  expr->as_string ().c_str ());\n+\treturn nullptr;\n+      }\n+\n+    resolver.mappings->insert_hir_expr (resolver.translated);\n+    resolver.mappings->insert_location (\n+      resolver.translated->get_mappings ().get_hirid (), expr->get_locus ());\n+\n+    if (terminated != nullptr)\n+      *terminated = resolver.terminated;\n+\n+    return resolver.translated;\n+  }\n+\n+  void visit (AST::TupleIndexExpr &expr) override\n+  {\n+    HIR::Expr *tuple_expr\n+      = ASTLoweringExpr::translate (expr.get_tuple_expr ().get (), &terminated);\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::TupleIndexExpr (mapping,\n+\t\t\t\t std::unique_ptr<HIR::Expr> (tuple_expr),\n+\t\t\t\t expr.get_tuple_index (),\n+\t\t\t\t expr.get_outer_attrs (), expr.get_locus ());\n+  }\n+\n+  void visit (AST::TupleExpr &expr) override\n+  {\n+    std::vector<std::unique_ptr<HIR::Expr> > tuple_elements;\n+    for (auto &e : expr.get_tuple_elems ())\n+      {\n+\tHIR::Expr *t = ASTLoweringExpr::translate (e.get ());\n+\ttuple_elements.push_back (std::unique_ptr<HIR::Expr> (t));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::TupleExpr (std::move (mapping), std::move (tuple_elements),\n+\t\t\t    expr.get_inner_attrs (), expr.get_outer_attrs (),\n+\t\t\t    expr.get_locus ());\n+  }\n+\n+  void visit (AST::IfExpr &expr) override\n+  {\n+    translated = ASTLoweringIfBlock::translate (&expr, &terminated);\n+  }\n+\n+  void visit (AST::IfExprConseqElse &expr) override\n+  {\n+    translated = ASTLoweringIfBlock::translate (&expr, &terminated);\n+  }\n+\n+  void visit (AST::IfExprConseqIf &expr) override\n+  {\n+    translated = ASTLoweringIfBlock::translate (&expr, &terminated);\n+  }\n+\n+  void visit (AST::BlockExpr &expr) override\n+  {\n+    translated = ASTLoweringBlock::translate (&expr, &terminated);\n+  }\n+\n+  void visit (AST::UnsafeBlockExpr &expr) override\n+  {\n+    translated = ASTLoweringBlock::translate (&expr, &terminated);\n+  }\n+\n+  void visit (AST::PathInExpression &expr) override\n+  {\n+    translated = ASTLowerPathInExpression::translate (&expr);\n+  }\n+\n+  void visit (AST::QualifiedPathInExpression &expr) override\n+  {\n+    translated = ASTLowerQualPathInExpression::translate (&expr);\n+  }\n+\n+  void visit (AST::ReturnExpr &expr) override\n+  {\n+    terminated = true;\n+    HIR::Expr *return_expr\n+      = expr.has_returned_expr ()\n+\t  ? ASTLoweringExpr::translate (expr.get_returned_expr ().get ())\n+\t  : nullptr;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::ReturnExpr (mapping, expr.get_locus (),\n+\t\t\t\t      std::unique_ptr<HIR::Expr> (return_expr));\n+  }\n+\n+  void visit (AST::CallExpr &expr) override\n+  {\n+    HIR::Expr *func\n+      = ASTLoweringExpr::translate (expr.get_function_expr ().get ());\n+\n+    auto const &in_params = expr.get_params ();\n+    std::vector<std::unique_ptr<HIR::Expr> > params;\n+    for (auto &param : in_params)\n+      {\n+\tauto trans = ASTLoweringExpr::translate (param.get ());\n+\tparams.push_back (std::unique_ptr<HIR::Expr> (trans));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (\n+      crate_num, UNKNOWN_NODEID /* this can map back to the AST*/,\n+      mappings->get_next_hir_id (crate_num), UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::CallExpr (mapping, std::unique_ptr<HIR::Expr> (func),\n+\t\t\t\t    std::move (params), expr.get_outer_attrs (),\n+\t\t\t\t    expr.get_locus ());\n+  }\n+\n+  void visit (AST::MethodCallExpr &expr) override\n+  {\n+    HIR::PathExprSegment method_path\n+      = lower_path_expr_seg (expr.get_method_name ());\n+\n+    HIR::Expr *receiver\n+      = ASTLoweringExpr::translate (expr.get_receiver_expr ().get ());\n+\n+    auto const &in_params = expr.get_params ();\n+    std::vector<std::unique_ptr<HIR::Expr> > params;\n+    for (auto &param : in_params)\n+      {\n+\tauto trans = ASTLoweringExpr::translate (param.get ());\n+\tparams.push_back (std::unique_ptr<HIR::Expr> (trans));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::MethodCallExpr (mapping, std::unique_ptr<HIR::Expr> (receiver),\n+\t\t\t\t method_path, std::move (params),\n+\t\t\t\t expr.get_outer_attrs (), expr.get_locus ());\n+  }\n+\n+  void visit (AST::AssignmentExpr &expr) override\n+  {\n+    HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n+    HIR::Expr *rhs = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::AssignmentExpr (mapping, std::unique_ptr<HIR::Expr> (lhs),\n+\t\t\t\t std::unique_ptr<HIR::Expr> (rhs),\n+\t\t\t\t expr.get_locus ());\n+  }\n+\n+  void visit (AST::IdentifierExpr &expr) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping1 (crate_num, expr.get_node_id (),\n+\t\t\t\t    mappings->get_next_hir_id (crate_num),\n+\t\t\t\t    UNKNOWN_LOCAL_DEFID);\n+    Analysis::NodeMapping mapping2 (mapping1);\n+\n+    HIR::PathIdentSegment ident_seg (expr.get_ident ());\n+    HIR::PathExprSegment seg (mapping1, ident_seg, expr.get_locus (),\n+\t\t\t      HIR::GenericArgs::create_empty ());\n+    translated = new HIR::PathInExpression (mapping2, {seg}, expr.get_locus (),\n+\t\t\t\t\t    false, expr.get_outer_attrs ());\n+  }\n+\n+  void visit (AST::ArrayExpr &expr) override\n+  {\n+    expr.get_array_elems ()->accept_vis (*this);\n+    rust_assert (translated_array_elems != nullptr);\n+    HIR::ArrayElems *elems = translated_array_elems;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::ArrayExpr (mapping, std::unique_ptr<HIR::ArrayElems> (elems),\n+\t\t\t    expr.get_inner_attrs (), expr.get_outer_attrs (),\n+\t\t\t    expr.get_locus ());\n+  }\n+\n+  void visit (AST::ArrayIndexExpr &expr) override\n+  {\n+    HIR::Expr *array_expr\n+      = ASTLoweringExpr::translate (expr.get_array_expr ().get ());\n+    HIR::Expr *array_index_expr\n+      = ASTLoweringExpr::translate (expr.get_index_expr ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::ArrayIndexExpr (mapping,\n+\t\t\t\t std::unique_ptr<HIR::Expr> (array_expr),\n+\t\t\t\t std::unique_ptr<HIR::Expr> (array_index_expr),\n+\t\t\t\t expr.get_outer_attrs (), expr.get_locus ());\n+  }\n+\n+  void visit (AST::ArrayElemsValues &elems) override\n+  {\n+    std::vector<std::unique_ptr<HIR::Expr> > elements;\n+    for (auto &elem : elems.get_values ())\n+      {\n+\tHIR::Expr *translated_elem = ASTLoweringExpr::translate (elem.get ());\n+\telements.push_back (std::unique_ptr<HIR::Expr> (translated_elem));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (mappings->get_current_crate (),\n+\t\t\t\t   elems.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated_array_elems\n+      = new HIR::ArrayElemsValues (mapping, std::move (elements));\n+  }\n+\n+  void visit (AST::ArrayElemsCopied &elems) override\n+  {\n+    HIR::Expr *element\n+      = ASTLoweringExpr::translate (elems.get_elem_to_copy ().get ());\n+    HIR::Expr *num_copies\n+      = ASTLoweringExpr::translate (elems.get_num_copies ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (mappings->get_current_crate (),\n+\t\t\t\t   elems.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated_array_elems\n+      = new HIR::ArrayElemsCopied (mapping,\n+\t\t\t\t   std::unique_ptr<HIR::Expr> (element),\n+\t\t\t\t   std::unique_ptr<HIR::Expr> (num_copies));\n+  }\n+\n+  void visit (AST::LiteralExpr &expr) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    HIR::Literal l = lower_literal (expr.get_literal ());\n+    translated\n+      = new HIR::LiteralExpr (mapping, std::move (l), expr.get_locus (),\n+\t\t\t      expr.get_outer_attrs ());\n+  }\n+\n+  void visit (AST::ArithmeticOrLogicalExpr &expr) override\n+  {\n+    HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n+    rust_assert (lhs != nullptr);\n+    HIR::Expr *rhs = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n+    rust_assert (rhs != nullptr);\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::ArithmeticOrLogicalExpr (mapping,\n+\t\t\t\t\t  std::unique_ptr<HIR::Expr> (lhs),\n+\t\t\t\t\t  std::unique_ptr<HIR::Expr> (rhs),\n+\t\t\t\t\t  expr.get_expr_type (),\n+\t\t\t\t\t  expr.get_locus ());\n+  }\n+\n+  void visit (AST::ComparisonExpr &expr) override\n+  {\n+    HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n+    rust_assert (lhs != nullptr);\n+    HIR::Expr *rhs = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n+    rust_assert (rhs != nullptr);\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::ComparisonExpr (mapping, std::unique_ptr<HIR::Expr> (lhs),\n+\t\t\t\t std::unique_ptr<HIR::Expr> (rhs),\n+\t\t\t\t expr.get_expr_type (), expr.get_locus ());\n+  }\n+\n+  void visit (AST::LazyBooleanExpr &expr) override\n+  {\n+    HIR::Expr *lhs = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n+    rust_assert (lhs != nullptr);\n+    HIR::Expr *rhs = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n+    rust_assert (rhs != nullptr);\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::LazyBooleanExpr (mapping, std::unique_ptr<HIR::Expr> (lhs),\n+\t\t\t\t  std::unique_ptr<HIR::Expr> (rhs),\n+\t\t\t\t  expr.get_expr_type (), expr.get_locus ());\n+  }\n+\n+  void visit (AST::NegationExpr &expr) override\n+  {\n+    HIR::Expr *negated_value\n+      = ASTLoweringExpr::translate (expr.get_negated_expr ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+    translated\n+      = new HIR::NegationExpr (mapping,\n+\t\t\t       std::unique_ptr<HIR::Expr> (negated_value),\n+\t\t\t       expr.get_expr_type (), expr.get_outer_attrs (),\n+\t\t\t       expr.get_locus ());\n+  }\n+\n+  void visit (AST::TypeCastExpr &expr) override\n+  {\n+    HIR::Expr *expr_to_cast_to\n+      = ASTLoweringExpr::translate (expr.get_casted_expr ().get ());\n+    HIR::Type *type_to_cast_to\n+      = lower_type_no_bounds (expr.get_type_to_cast_to ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::TypeCastExpr (mapping,\n+\t\t\t       std::unique_ptr<HIR::Expr> (expr_to_cast_to),\n+\t\t\t       std::unique_ptr<HIR::Type> (type_to_cast_to),\n+\t\t\t       expr.get_locus ());\n+  }\n+\n+  void visit (AST::CompoundAssignmentExpr &expr) override\n+  {\n+    ArithmeticOrLogicalOperator op;\n+    switch (expr.get_expr_type ())\n+      {\n+      case CompoundAssignmentOperator::ADD:\n+\top = ArithmeticOrLogicalOperator::ADD;\n+\tbreak;\n+      case CompoundAssignmentOperator::SUBTRACT:\n+\top = ArithmeticOrLogicalOperator::SUBTRACT;\n+\tbreak;\n+      case CompoundAssignmentOperator::MULTIPLY:\n+\top = ArithmeticOrLogicalOperator::MULTIPLY;\n+\tbreak;\n+      case CompoundAssignmentOperator::DIVIDE:\n+\top = ArithmeticOrLogicalOperator::DIVIDE;\n+\tbreak;\n+      case CompoundAssignmentOperator::MODULUS:\n+\top = ArithmeticOrLogicalOperator::MODULUS;\n+\tbreak;\n+      case CompoundAssignmentOperator::BITWISE_AND:\n+\top = ArithmeticOrLogicalOperator::BITWISE_AND;\n+\tbreak;\n+      case CompoundAssignmentOperator::BITWISE_OR:\n+\top = ArithmeticOrLogicalOperator::BITWISE_OR;\n+\tbreak;\n+      case CompoundAssignmentOperator::BITWISE_XOR:\n+\top = ArithmeticOrLogicalOperator::BITWISE_XOR;\n+\tbreak;\n+      case CompoundAssignmentOperator::LEFT_SHIFT:\n+\top = ArithmeticOrLogicalOperator::LEFT_SHIFT;\n+\tbreak;\n+      case CompoundAssignmentOperator::RIGHT_SHIFT:\n+\top = ArithmeticOrLogicalOperator::RIGHT_SHIFT;\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+      }\n+\n+    HIR::Expr *asignee_expr\n+      = ASTLoweringExpr::translate (expr.get_left_expr ().get ());\n+    HIR::Expr *value\n+      = ASTLoweringExpr::translate (expr.get_right_expr ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::CompoundAssignmentExpr (\n+      mapping, std::unique_ptr<HIR::Expr> (asignee_expr),\n+      std::unique_ptr<HIR::Expr> (value), op, expr.get_locus ());\n+  }\n+\n+  void visit (AST::StructExprStruct &struct_expr) override\n+  {\n+    HIR::PathInExpression *path\n+      = ASTLowerPathInExpression::translate (&struct_expr.get_struct_name ());\n+    HIR::PathInExpression copied_path (*path);\n+    delete path;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, struct_expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::StructExprStruct (mapping, copied_path,\n+\t\t\t\t\t    struct_expr.get_inner_attrs (),\n+\t\t\t\t\t    struct_expr.get_outer_attrs (),\n+\t\t\t\t\t    struct_expr.get_locus ());\n+  }\n+\n+  void visit (AST::StructExprStructFields &struct_expr) override\n+  {\n+    // bit of a hack for now\n+    HIR::PathInExpression *path\n+      = ASTLowerPathInExpression::translate (&struct_expr.get_struct_name ());\n+    HIR::PathInExpression copied_path (*path);\n+    delete path;\n+\n+    HIR::StructBase *base = nullptr;\n+    if (struct_expr.has_struct_base ())\n+      {\n+\tHIR::Expr *translated_base = ASTLoweringExpr::translate (\n+\t  struct_expr.get_struct_base ().get_base_struct ().get ());\n+\tbase\n+\t  = new HIR::StructBase (std::unique_ptr<HIR::Expr> (translated_base));\n+      }\n+\n+    auto const &in_fields = struct_expr.get_fields ();\n+    std::vector<std::unique_ptr<HIR::StructExprField> > fields;\n+    for (auto &field : in_fields)\n+      {\n+\tHIR::StructExprField *translated\n+\t  = ASTLowerStructExprField::translate (field.get ());\n+\tfields.push_back (std::unique_ptr<HIR::StructExprField> (translated));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, struct_expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::StructExprStructFields (\n+      mapping, copied_path, std::move (fields), struct_expr.get_locus (), base,\n+      struct_expr.get_inner_attrs (), struct_expr.get_outer_attrs ());\n+  }\n+\n+  void visit (AST::GroupedExpr &expr) override\n+  {\n+    HIR::Expr *paren_expr\n+      = ASTLoweringExpr::translate (expr.get_expr_in_parens ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::GroupedExpr (mapping, std::unique_ptr<HIR::Expr> (paren_expr),\n+\t\t\t      expr.get_inner_attrs (), expr.get_outer_attrs (),\n+\t\t\t      expr.get_locus ());\n+  }\n+\n+  void visit (AST::FieldAccessExpr &expr) override\n+  {\n+    HIR::Expr *receiver\n+      = ASTLoweringExpr::translate (expr.get_receiver_expr ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+    translated\n+      = new HIR::FieldAccessExpr (mapping,\n+\t\t\t\t  std::unique_ptr<HIR::Expr> (receiver),\n+\t\t\t\t  expr.get_field_name (),\n+\t\t\t\t  expr.get_outer_attrs (), expr.get_locus ());\n+  }\n+\n+  void visit (AST::LoopExpr &expr) override\n+  {\n+    translated = ASTLoweringExprWithBlock::translate (&expr, &terminated);\n+  }\n+\n+  void visit (AST::WhileLoopExpr &expr) override\n+  {\n+    translated = ASTLoweringExprWithBlock::translate (&expr, &terminated);\n+  }\n+\n+  void visit (AST::ForLoopExpr &expr) override\n+  {\n+    translated = ASTLoweringExprWithBlock::translate (&expr, &terminated);\n+  }\n+\n+  void visit (AST::BreakExpr &expr) override\n+  {\n+    HIR::Lifetime break_label = lower_lifetime (expr.get_label ());\n+    HIR::Expr *break_expr\n+      = expr.has_break_expr ()\n+\t  ? ASTLoweringExpr::translate (expr.get_break_expr ().get ())\n+\t  : nullptr;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::BreakExpr (mapping, expr.get_locus (),\n+\t\t\t\t     std ::move (break_label),\n+\t\t\t\t     std::unique_ptr<HIR::Expr> (break_expr),\n+\t\t\t\t     expr.get_outer_attrs ());\n+  }\n+\n+  void visit (AST::ContinueExpr &expr) override\n+  {\n+    HIR::Lifetime break_label = lower_lifetime (expr.get_label ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::ContinueExpr (mapping, expr.get_locus (),\n+\t\t\t\t\tstd ::move (break_label),\n+\t\t\t\t\texpr.get_outer_attrs ());\n+  }\n+\n+  void visit (AST::BorrowExpr &expr) override\n+  {\n+    HIR::Expr *borrow_lvalue\n+      = ASTLoweringExpr::translate (expr.get_borrowed_expr ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::BorrowExpr (\n+      mapping, std::unique_ptr<HIR::Expr> (borrow_lvalue),\n+      expr.get_is_mut () ? Mutability::Mut : Mutability::Imm,\n+      expr.get_is_double_borrow (), expr.get_outer_attrs (), expr.get_locus ());\n+  }\n+\n+  void visit (AST::DereferenceExpr &expr) override\n+  {\n+    HIR::Expr *dref_lvalue\n+      = ASTLoweringExpr::translate (expr.get_dereferenced_expr ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::DereferenceExpr (mapping,\n+\t\t\t\t  std::unique_ptr<HIR::Expr> (dref_lvalue),\n+\t\t\t\t  expr.get_outer_attrs (), expr.get_locus ());\n+  }\n+\n+  void visit (AST::MatchExpr &expr) override\n+  {\n+    translated = ASTLoweringExprWithBlock::translate (&expr, &terminated);\n+  }\n+\n+  void visit (AST::RangeFromToExpr &expr) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    HIR::Expr *range_from\n+      = ASTLoweringExpr::translate (expr.get_from_expr ().get ());\n+    HIR::Expr *range_to\n+      = ASTLoweringExpr::translate (expr.get_to_expr ().get ());\n+\n+    translated\n+      = new HIR::RangeFromToExpr (mapping,\n+\t\t\t\t  std::unique_ptr<HIR::Expr> (range_from),\n+\t\t\t\t  std::unique_ptr<HIR::Expr> (range_to),\n+\t\t\t\t  expr.get_locus ());\n+  }\n+\n+  void visit (AST::RangeFromExpr &expr) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    HIR::Expr *range_from\n+      = ASTLoweringExpr::translate (expr.get_from_expr ().get ());\n+\n+    translated\n+      = new HIR::RangeFromExpr (mapping,\n+\t\t\t\tstd::unique_ptr<HIR::Expr> (range_from),\n+\t\t\t\texpr.get_locus ());\n+  }\n+\n+  void visit (AST::RangeToExpr &expr) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    HIR::Expr *range_to\n+      = ASTLoweringExpr::translate (expr.get_to_expr ().get ());\n+\n+    translated\n+      = new HIR::RangeToExpr (mapping, std::unique_ptr<HIR::Expr> (range_to),\n+\t\t\t      expr.get_locus ());\n+  }\n+\n+  void visit (AST::RangeFullExpr &expr) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::RangeFullExpr (mapping, expr.get_locus ());\n+  }\n+\n+  void visit (AST::RangeFromToInclExpr &expr) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    HIR::Expr *range_from\n+      = ASTLoweringExpr::translate (expr.get_from_expr ().get ());\n+    HIR::Expr *range_to\n+      = ASTLoweringExpr::translate (expr.get_to_expr ().get ());\n+\n+    translated\n+      = new HIR::RangeFromToInclExpr (mapping,\n+\t\t\t\t      std::unique_ptr<HIR::Expr> (range_from),\n+\t\t\t\t      std::unique_ptr<HIR::Expr> (range_to),\n+\t\t\t\t      expr.get_locus ());\n+  }\n+\n+private:\n+  ASTLoweringExpr ()\n+    : ASTLoweringBase (), translated (nullptr),\n+      translated_array_elems (nullptr), terminated (false)\n+  {}\n+\n+  HIR::Expr *translated;\n+  HIR::ArrayElems *translated_array_elems;\n+  bool terminated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_EXPR"}, {"sha": "eeb59c9c5d6f75111a3d2eca18a629bf97a3f0af", "filename": "gcc/rust/hir/rust-ast-lower-extern.h", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-extern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-extern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-extern.h?ref=7999cf327de7b5bbea80046715eeb00c0755a08d", "patch": "@@ -0,0 +1,121 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_EXTERN_ITEM\n+#define RUST_AST_LOWER_EXTERN_ITEM\n+\n+#include \"rust-ast-lower-base.h\"\n+#include \"rust-ast-lower-type.h\"\n+#include \"rust-ast-lower.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLoweringExternItem : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::ExternalItem *translate (AST::ExternalItem *item,\n+\t\t\t\t       HirId parent_hirid)\n+  {\n+    ASTLoweringExternItem resolver;\n+    item->accept_vis (resolver);\n+\n+    rust_assert (resolver.translated != nullptr);\n+    resolver.mappings->insert_hir_extern_item (resolver.translated,\n+\t\t\t\t\t       parent_hirid);\n+    resolver.mappings->insert_location (\n+      resolver.translated->get_mappings ().get_hirid (),\n+      resolver.translated->get_locus ());\n+\n+    return resolver.translated;\n+  }\n+\n+  void visit (AST::ExternalStaticItem &item) override\n+  {\n+    HIR::Visibility vis = translate_visibility (item.get_visibility ());\n+    HIR::Type *static_type\n+      = ASTLoweringType::translate (item.get_type ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, item.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::ExternalStaticItem (\n+      mapping, item.get_identifier (), std::unique_ptr<HIR::Type> (static_type),\n+      item.is_mut () ? Mutability::Mut : Mutability::Imm, std::move (vis),\n+      item.get_outer_attrs (), item.get_locus ());\n+  }\n+\n+  void visit (AST::ExternalFunctionItem &function) override\n+  {\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::Visibility vis = translate_visibility (function.get_visibility ());\n+\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    if (function.has_generics ())\n+      generic_params = lower_generic_params (function.get_generic_params ());\n+\n+    HIR::Type *return_type\n+      = function.has_return_type ()\n+\t  ? ASTLoweringType::translate (function.get_return_type ().get ())\n+\t  : nullptr;\n+\n+    std::vector<HIR::NamedFunctionParam> function_params;\n+    for (auto &param : function.get_function_params ())\n+      {\n+\tHIR::Type *param_type\n+\t  = ASTLoweringType::translate (param.get_type ().get ());\n+\tIdentifier param_name = param.get_name ();\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, param.get_node_id (),\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       mappings->get_next_localdef_id (\n+\t\t\t\t\t crate_num));\n+\n+\tfunction_params.push_back (\n+\t  HIR::NamedFunctionParam (mapping, param_name,\n+\t\t\t\t   std::unique_ptr<HIR::Type> (param_type)));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, function.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::ExternalFunctionItem (\n+      mapping, function.get_identifier (), std::move (generic_params),\n+      std::unique_ptr<HIR::Type> (return_type), std::move (where_clause),\n+      std::move (function_params), function.is_variadic (), std::move (vis),\n+      function.get_outer_attrs (), function.get_locus ());\n+  }\n+\n+private:\n+  ASTLoweringExternItem () : translated (nullptr) {}\n+\n+  HIR::ExternalItem *translated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_ITEM"}, {"sha": "d5ca47587fc887d87e12270c5870820d90036f58", "filename": "gcc/rust/hir/rust-ast-lower-implitem.h", "status": "added", "additions": 521, "deletions": 0, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-implitem.h?ref=7999cf327de7b5bbea80046715eeb00c0755a08d", "patch": "@@ -0,0 +1,521 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_IMPLITEM_H\n+#define RUST_AST_LOWER_IMPLITEM_H\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-ast-lower-type.h\"\n+#include \"rust-ast-lower-stmt.h\"\n+#include \"rust-ast-lower-expr.h\"\n+#include \"rust-ast-lower-pattern.h\"\n+#include \"rust-ast-lower-block.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLowerImplItem : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::ImplItem *translate (AST::InherentImplItem *item,\n+\t\t\t\t   HirId parent_impl_id)\n+  {\n+    ASTLowerImplItem resolver;\n+    item->accept_vis (resolver);\n+\n+    if (resolver.translated != nullptr)\n+      {\n+\trust_assert (resolver.item_cast != nullptr);\n+\n+\tauto id = resolver.translated->get_impl_mappings ().get_hirid ();\n+\tauto defid = resolver.translated->get_impl_mappings ().get_defid ();\n+\tauto locus = resolver.translated->get_locus ();\n+\n+\tresolver.handle_outer_attributes (*resolver.item_cast);\n+\tresolver.mappings->insert_hir_implitem (parent_impl_id,\n+\t\t\t\t\t\tresolver.translated);\n+\tresolver.mappings->insert_location (id, locus);\n+\tresolver.mappings->insert_defid_mapping (defid, resolver.item_cast);\n+      }\n+\n+    return resolver.translated;\n+  }\n+\n+  static HIR::ImplItem *translate (AST::TraitImplItem *item,\n+\t\t\t\t   HirId parent_impl_id)\n+  {\n+    ASTLowerImplItem resolver;\n+    item->accept_vis (resolver);\n+\n+    if (resolver.translated != nullptr)\n+      {\n+\trust_assert (resolver.item_cast != nullptr);\n+\n+\tauto id = resolver.translated->get_impl_mappings ().get_hirid ();\n+\tauto defid = resolver.translated->get_impl_mappings ().get_defid ();\n+\tauto locus = resolver.translated->get_locus ();\n+\n+\tresolver.handle_outer_attributes (*resolver.item_cast);\n+\tresolver.mappings->insert_hir_implitem (parent_impl_id,\n+\t\t\t\t\t\tresolver.translated);\n+\tresolver.mappings->insert_location (id, locus);\n+\tresolver.mappings->insert_defid_mapping (defid, resolver.item_cast);\n+      }\n+\n+    return resolver.translated;\n+  }\n+\n+  void visit (AST::TypeAlias &alias) override\n+  {\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::Visibility vis = translate_visibility (alias.get_visibility ());\n+\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    if (alias.has_generics ())\n+      generic_params = lower_generic_params (alias.get_generic_params ());\n+\n+    HIR::Type *existing_type\n+      = ASTLoweringType::translate (alias.get_type_aliased ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, alias.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    auto type_alias = new HIR::TypeAlias (\n+      mapping, alias.get_new_type_name (), std::move (generic_params),\n+      std::move (where_clause), std::unique_ptr<HIR::Type> (existing_type),\n+      std::move (vis), alias.get_outer_attrs (), alias.get_locus ());\n+\n+    translated = type_alias;\n+    item_cast = type_alias;\n+  }\n+\n+  void visit (AST::ConstantItem &constant) override\n+  {\n+    HIR::Visibility vis = translate_visibility (constant.get_visibility ());\n+\n+    HIR::Type *type = ASTLoweringType::translate (constant.get_type ().get ());\n+    HIR::Expr *expr = ASTLoweringExpr::translate (constant.get_expr ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, constant.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    auto translated_constant\n+      = new HIR::ConstantItem (mapping, constant.get_identifier (), vis,\n+\t\t\t       std::unique_ptr<HIR::Type> (type),\n+\t\t\t       std::unique_ptr<HIR::Expr> (expr),\n+\t\t\t       constant.get_outer_attrs (),\n+\t\t\t       constant.get_locus ());\n+    translated = translated_constant;\n+    item_cast = translated_constant;\n+  }\n+\n+  void visit (AST::Function &function) override\n+  {\n+    // ignore for now and leave empty\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::FunctionQualifiers qualifiers\n+      = lower_qualifiers (function.get_qualifiers ());\n+    HIR::Visibility vis = translate_visibility (function.get_visibility ());\n+\n+    // need\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    if (function.has_generics ())\n+      {\n+\tgeneric_params = lower_generic_params (function.get_generic_params ());\n+      }\n+    Identifier function_name = function.get_function_name ();\n+    Location locus = function.get_locus ();\n+\n+    std::unique_ptr<HIR::Type> return_type\n+      = function.has_return_type () ? std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (function.get_return_type ().get ()))\n+\t\t\t\t    : nullptr;\n+\n+    std::vector<HIR::FunctionParam> function_params;\n+    for (auto &param : function.get_function_params ())\n+      {\n+\tauto translated_pattern = std::unique_ptr<HIR::Pattern> (\n+\t  ASTLoweringPattern::translate (param.get_pattern ().get ()));\n+\tauto translated_type = std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (param.get_type ().get ()));\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, param.get_node_id (),\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n+\n+\tauto hir_param\n+\t  = HIR::FunctionParam (mapping, std::move (translated_pattern),\n+\t\t\t\tstd::move (translated_type),\n+\t\t\t\tparam.get_locus ());\n+\tfunction_params.push_back (std::move (hir_param));\n+      }\n+\n+    bool terminated = false;\n+    std::unique_ptr<HIR::BlockExpr> function_body\n+      = std::unique_ptr<HIR::BlockExpr> (\n+\tASTLoweringBlock::translate (function.get_definition ().get (),\n+\t\t\t\t     &terminated));\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, function.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    mappings->insert_location (function_body->get_mappings ().get_hirid (),\n+\t\t\t       function.get_locus ());\n+\n+    auto fn\n+      = new HIR::Function (mapping, std::move (function_name),\n+\t\t\t   std::move (qualifiers), std::move (generic_params),\n+\t\t\t   std::move (function_params), std::move (return_type),\n+\t\t\t   std::move (where_clause), std::move (function_body),\n+\t\t\t   std::move (vis), function.get_outer_attrs (),\n+\t\t\t   HIR::SelfParam::error (), locus);\n+\n+    // add the mappings for the function params at the end\n+    for (auto &param : fn->get_function_params ())\n+      {\n+\tmappings->insert_hir_param (&param);\n+\tmappings->insert_location (mapping.get_hirid (), param.get_locus ());\n+      }\n+\n+    translated = fn;\n+    item_cast = fn;\n+  }\n+\n+  void visit (AST::Method &method) override\n+  {\n+    // ignore for now and leave empty\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::FunctionQualifiers qualifiers\n+      = lower_qualifiers (method.get_qualifiers ());\n+    HIR::Visibility vis = translate_visibility (method.get_visibility ());\n+\n+    // need\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    if (method.has_generics ())\n+      {\n+\tgeneric_params = lower_generic_params (method.get_generic_params ());\n+      }\n+    Identifier method_name = method.get_method_name ();\n+    Location locus = method.get_locus ();\n+\n+    HIR::SelfParam self_param = lower_self (method.get_self_param ());\n+\n+    std::unique_ptr<HIR::Type> return_type\n+      = method.has_return_type () ? std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (method.get_return_type ().get ()))\n+\t\t\t\t  : nullptr;\n+\n+    std::vector<HIR::FunctionParam> function_params;\n+    for (auto &param : method.get_function_params ())\n+      {\n+\tauto translated_pattern = std::unique_ptr<HIR::Pattern> (\n+\t  ASTLoweringPattern::translate (param.get_pattern ().get ()));\n+\tauto translated_type = std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (param.get_type ().get ()));\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, param.get_node_id (),\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n+\n+\tauto hir_param\n+\t  = HIR::FunctionParam (mapping, std::move (translated_pattern),\n+\t\t\t\tstd::move (translated_type),\n+\t\t\t\tparam.get_locus ());\n+\tfunction_params.push_back (std::move (hir_param));\n+      }\n+\n+    bool terminated = false;\n+    std::unique_ptr<HIR::BlockExpr> method_body\n+      = std::unique_ptr<HIR::BlockExpr> (\n+\tASTLoweringBlock::translate (method.get_definition ().get (),\n+\t\t\t\t     &terminated));\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, method.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+    auto mth\n+      = new HIR::Function (mapping, std::move (method_name),\n+\t\t\t   std::move (qualifiers), std::move (generic_params),\n+\t\t\t   std::move (function_params), std::move (return_type),\n+\t\t\t   std::move (where_clause), std::move (method_body),\n+\t\t\t   std::move (vis), method.get_outer_attrs (),\n+\t\t\t   std::move (self_param), locus);\n+\n+    // insert mappings for self\n+    mappings->insert_hir_self_param (&self_param);\n+    mappings->insert_location (self_param.get_mappings ().get_hirid (),\n+\t\t\t       self_param.get_locus ());\n+\n+    // add the mappings for the function params at the end\n+    for (auto &param : mth->get_function_params ())\n+      {\n+\tmappings->insert_hir_param (&param);\n+\tmappings->insert_location (mapping.get_hirid (), param.get_locus ());\n+      }\n+\n+    translated = mth;\n+    item_cast = mth;\n+  }\n+\n+private:\n+  ASTLowerImplItem () : translated (nullptr), item_cast (nullptr) {}\n+\n+  HIR::ImplItem *translated;\n+  HIR::Item *item_cast;\n+};\n+\n+class ASTLowerTraitItem : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::TraitItem *translate (AST::TraitItem *item)\n+  {\n+    ASTLowerTraitItem resolver;\n+    item->accept_vis (resolver);\n+\n+    if (resolver.translated != nullptr)\n+      {\n+\t// FIXME\n+\n+\t// auto id = resolver.translated->get_mappings ().get_hirid ();\n+\t// auto defid = resolver.translated->get_mappings ().get_defid ();\n+\t// auto locus = resolver.translated->get_locus ();\n+\n+\t// resolver.handle_outer_attributes (*resolver.translated);\n+\tresolver.mappings->insert_hir_trait_item (resolver.translated);\n+\t// resolver.mappings->insert_location (id, locus);\n+\t// resolver.mappings->insert_defid_mapping (defid, resolver.item_cast);\n+      }\n+\n+    return resolver.translated;\n+  }\n+\n+  void visit (AST::TraitItemFunc &func) override\n+  {\n+    AST::TraitFunctionDecl &ref = func.get_trait_function_decl ();\n+\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::FunctionQualifiers qualifiers\n+      = lower_qualifiers (func.get_trait_function_decl ().get_qualifiers ());\n+\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    if (ref.has_generics ())\n+      {\n+\tgeneric_params = lower_generic_params (ref.get_generic_params ());\n+      }\n+\n+    std::unique_ptr<HIR::Type> return_type\n+      = ref.has_return_type () ? std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (ref.get_return_type ().get ()))\n+\t\t\t       : nullptr;\n+\n+    std::vector<HIR::FunctionParam> function_params;\n+    for (auto &param : ref.get_function_params ())\n+      {\n+\tauto translated_pattern = std::unique_ptr<HIR::Pattern> (\n+\t  ASTLoweringPattern::translate (param.get_pattern ().get ()));\n+\tauto translated_type = std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (param.get_type ().get ()));\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, param.get_node_id (),\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n+\n+\tauto hir_param\n+\t  = HIR::FunctionParam (mapping, std::move (translated_pattern),\n+\t\t\t\tstd::move (translated_type),\n+\t\t\t\tparam.get_locus ());\n+\tfunction_params.push_back (std::move (hir_param));\n+      }\n+\n+    HIR::TraitFunctionDecl decl (ref.get_identifier (), std::move (qualifiers),\n+\t\t\t\t std::move (generic_params),\n+\t\t\t\t HIR::SelfParam::error (),\n+\t\t\t\t std::move (function_params),\n+\t\t\t\t std::move (return_type),\n+\t\t\t\t std::move (where_clause));\n+    bool terminated = false;\n+    std::unique_ptr<HIR::BlockExpr> block_expr\n+      = func.has_definition () ? std::unique_ptr<HIR::BlockExpr> (\n+\t  ASTLoweringBlock::translate (func.get_definition ().get (),\n+\t\t\t\t       &terminated))\n+\t\t\t       : nullptr;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, func.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    HIR::TraitItemFunc *trait_item\n+      = new HIR::TraitItemFunc (mapping, std::move (decl),\n+\t\t\t\tstd::move (block_expr), func.get_outer_attrs (),\n+\t\t\t\tfunc.get_locus ());\n+    translated = trait_item;\n+\n+    // add the mappings for the function params at the end\n+    for (auto &param : trait_item->get_decl ().get_function_params ())\n+      {\n+\tmappings->insert_hir_param (&param);\n+\tmappings->insert_location (mapping.get_hirid (), param.get_locus ());\n+      }\n+  }\n+\n+  void visit (AST::TraitItemMethod &method) override\n+  {\n+    AST::TraitMethodDecl &ref = method.get_trait_method_decl ();\n+\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem> > where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::FunctionQualifiers qualifiers\n+      = lower_qualifiers (method.get_trait_method_decl ().get_qualifiers ());\n+\n+    std::vector<std::unique_ptr<HIR::GenericParam> > generic_params;\n+    if (ref.has_generics ())\n+      {\n+\tgeneric_params = lower_generic_params (ref.get_generic_params ());\n+      }\n+\n+    std::unique_ptr<HIR::Type> return_type\n+      = ref.has_return_type () ? std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (ref.get_return_type ().get ()))\n+\t\t\t       : nullptr;\n+\n+    HIR::SelfParam self_param = lower_self (ref.get_self_param ());\n+\n+    std::vector<HIR::FunctionParam> function_params;\n+    for (auto &param : ref.get_function_params ())\n+      {\n+\tauto translated_pattern = std::unique_ptr<HIR::Pattern> (\n+\t  ASTLoweringPattern::translate (param.get_pattern ().get ()));\n+\tauto translated_type = std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (param.get_type ().get ()));\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, param.get_node_id (),\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n+\n+\tauto hir_param\n+\t  = HIR::FunctionParam (mapping, std::move (translated_pattern),\n+\t\t\t\tstd::move (translated_type),\n+\t\t\t\tparam.get_locus ());\n+\tfunction_params.push_back (hir_param);\n+      }\n+\n+    HIR::TraitFunctionDecl decl (ref.get_identifier (), std::move (qualifiers),\n+\t\t\t\t std::move (generic_params),\n+\t\t\t\t std::move (self_param),\n+\t\t\t\t std::move (function_params),\n+\t\t\t\t std::move (return_type),\n+\t\t\t\t std::move (where_clause));\n+    bool terminated = false;\n+    std::unique_ptr<HIR::BlockExpr> block_expr\n+      = method.has_definition () ? std::unique_ptr<HIR::BlockExpr> (\n+\t  ASTLoweringBlock::translate (method.get_definition ().get (),\n+\t\t\t\t       &terminated))\n+\t\t\t\t : nullptr;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, method.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    HIR::TraitItemFunc *trait_item\n+      = new HIR::TraitItemFunc (mapping, std::move (decl),\n+\t\t\t\tstd::move (block_expr),\n+\t\t\t\tmethod.get_outer_attrs (), method.get_locus ());\n+    translated = trait_item;\n+\n+    // insert mappings for self\n+    mappings->insert_hir_self_param (&self_param);\n+    mappings->insert_location (self_param.get_mappings ().get_hirid (),\n+\t\t\t       self_param.get_locus ());\n+\n+    // add the mappings for the function params at the end\n+    for (auto &param : trait_item->get_decl ().get_function_params ())\n+      {\n+\tmappings->insert_hir_param (&param);\n+\tmappings->insert_location (mapping.get_hirid (), param.get_locus ());\n+      }\n+  }\n+\n+  void visit (AST::TraitItemConst &constant) override\n+  {\n+    HIR::Type *type = ASTLoweringType::translate (constant.get_type ().get ());\n+    HIR::Expr *expr\n+      = constant.has_expression ()\n+\t  ? ASTLoweringExpr::translate (constant.get_expr ().get ())\n+\t  : nullptr;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, constant.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    HIR::TraitItemConst *trait_item\n+      = new HIR::TraitItemConst (mapping, constant.get_identifier (),\n+\t\t\t\t std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t std::unique_ptr<HIR::Expr> (expr),\n+\t\t\t\t constant.get_outer_attrs (),\n+\t\t\t\t constant.get_locus ());\n+    translated = trait_item;\n+  }\n+\n+  void visit (AST::TraitItemType &type) override\n+  {\n+    std::vector<std::unique_ptr<HIR::TypeParamBound> > type_param_bounds;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    HIR::TraitItemType *trait_item\n+      = new HIR::TraitItemType (mapping, type.get_identifier (),\n+\t\t\t\tstd::move (type_param_bounds),\n+\t\t\t\ttype.get_outer_attrs (), type.get_locus ());\n+    translated = trait_item;\n+  }\n+\n+private:\n+  ASTLowerTraitItem () : translated (nullptr) {}\n+\n+  HIR::TraitItem *translated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_IMPLITEM_H"}, {"sha": "fefc938b8e57a14366f0424353582c152adc4eb1", "filename": "gcc/rust/hir/rust-ast-lower-item.cc", "status": "added", "additions": 741, "deletions": 0, "changes": 741, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.cc?ref=7999cf327de7b5bbea80046715eeb00c0755a08d", "patch": "@@ -0,0 +1,741 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-lower-item.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+HIR::Item *\n+ASTLoweringItem::translate (AST::Item *item)\n+{\n+  ASTLoweringItem resolver;\n+  item->accept_vis (resolver);\n+\n+  if (resolver.translated != nullptr)\n+    {\n+      auto id = resolver.translated->get_mappings ().get_hirid ();\n+      auto defid = resolver.translated->get_mappings ().get_defid ();\n+      auto locus = resolver.translated->get_locus ();\n+\n+      resolver.handle_outer_attributes (*resolver.translated);\n+      resolver.mappings->insert_ast_item (item);\n+      resolver.mappings->insert_hir_item (resolver.translated);\n+      resolver.mappings->insert_location (id, locus);\n+      resolver.mappings->insert_defid_mapping (defid, resolver.translated);\n+    }\n+\n+  return resolver.translated;\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::Module &module)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, module.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  // should be lowered from module.get_vis()\n+  HIR::Visibility vis = translate_visibility (module.get_visibility ());\n+\n+  auto items = std::vector<std::unique_ptr<Item>> ();\n+\n+  for (auto &item : module.get_items ())\n+    {\n+      auto transitem = translate (item.get ());\n+      items.push_back (std::unique_ptr<Item> (transitem));\n+    }\n+\n+  // should be lowered/copied from module.get_in/outer_attrs()\n+  AST::AttrVec inner_attrs = module.get_inner_attrs ();\n+  AST::AttrVec outer_attrs = module.get_outer_attrs ();\n+\n+  translated\n+    = new HIR::Module (mapping, module.get_name (), module.get_locus (),\n+\t\t       std::move (items), std::move (vis),\n+\t\t       std::move (inner_attrs), std::move (outer_attrs));\n+  mappings->insert_module (static_cast<Module *> (translated));\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::TypeAlias &alias)\n+{\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  for (auto &item : alias.get_where_clause ().get_items ())\n+    {\n+      HIR::WhereClauseItem *i\n+\t= ASTLowerWhereClauseItem::translate (*item.get ());\n+      where_clause_items.push_back (std::unique_ptr<HIR::WhereClauseItem> (i));\n+    }\n+\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+  HIR::Visibility vis = translate_visibility (alias.get_visibility ());\n+\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (alias.has_generics ())\n+    generic_params = lower_generic_params (alias.get_generic_params ());\n+\n+  HIR::Type *existing_type\n+    = ASTLoweringType::translate (alias.get_type_aliased ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, alias.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated\n+    = new HIR::TypeAlias (mapping, alias.get_new_type_name (),\n+\t\t\t  std::move (generic_params), std::move (where_clause),\n+\t\t\t  std::unique_ptr<HIR::Type> (existing_type),\n+\t\t\t  std::move (vis), alias.get_outer_attrs (),\n+\t\t\t  alias.get_locus ());\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::TupleStruct &struct_decl)\n+{\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (struct_decl.has_generics ())\n+    {\n+      generic_params = lower_generic_params (struct_decl.get_generic_params ());\n+    }\n+\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  for (auto &item : struct_decl.get_where_clause ().get_items ())\n+    {\n+      HIR::WhereClauseItem *i\n+\t= ASTLowerWhereClauseItem::translate (*item.get ());\n+      where_clause_items.push_back (std::unique_ptr<HIR::WhereClauseItem> (i));\n+    }\n+\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+  HIR::Visibility vis = translate_visibility (struct_decl.get_visibility ());\n+\n+  std::vector<HIR::TupleField> fields;\n+  for (AST::TupleField &field : struct_decl.get_fields ())\n+    {\n+      if (field.get_field_type ()->is_marked_for_strip ())\n+\tcontinue;\n+\n+      // FIXME: How do we get the visibility from here?\n+      HIR::Visibility vis = translate_visibility (field.get_visibility ());\n+      HIR::Type *type\n+\t= ASTLoweringType::translate (field.get_field_type ().get ());\n+\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, field.get_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     mappings->get_next_localdef_id (\n+\t\t\t\t       crate_num));\n+\n+      HIR::TupleField translated_field (mapping,\n+\t\t\t\t\tstd::unique_ptr<HIR::Type> (type), vis,\n+\t\t\t\t\tfield.get_locus (),\n+\t\t\t\t\tfield.get_outer_attrs ());\n+      fields.push_back (std::move (translated_field));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, struct_decl.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::TupleStruct (mapping, std::move (fields),\n+\t\t\t\t     struct_decl.get_identifier (),\n+\t\t\t\t     std::move (generic_params),\n+\t\t\t\t     std::move (where_clause), vis,\n+\t\t\t\t     struct_decl.get_outer_attrs (),\n+\t\t\t\t     struct_decl.get_locus ());\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::StructStruct &struct_decl)\n+{\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (struct_decl.has_generics ())\n+    {\n+      generic_params = lower_generic_params (struct_decl.get_generic_params ());\n+    }\n+\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  for (auto &item : struct_decl.get_where_clause ().get_items ())\n+    {\n+      HIR::WhereClauseItem *i\n+\t= ASTLowerWhereClauseItem::translate (*item.get ());\n+      where_clause_items.push_back (std::unique_ptr<HIR::WhereClauseItem> (i));\n+    }\n+\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+\n+  HIR::Visibility vis = translate_visibility (struct_decl.get_visibility ());\n+\n+  bool is_unit = struct_decl.is_unit_struct ();\n+  std::vector<HIR::StructField> fields;\n+  for (AST::StructField &field : struct_decl.get_fields ())\n+    {\n+      if (field.get_field_type ()->is_marked_for_strip ())\n+\tcontinue;\n+\n+      HIR::Visibility vis = translate_visibility (field.get_visibility ());\n+      HIR::Type *type\n+\t= ASTLoweringType::translate (field.get_field_type ().get ());\n+\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, field.get_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     mappings->get_next_localdef_id (\n+\t\t\t\t       crate_num));\n+\n+      HIR::StructField translated_field (mapping, field.get_field_name (),\n+\t\t\t\t\t std::unique_ptr<HIR::Type> (type), vis,\n+\t\t\t\t\t field.get_locus (),\n+\t\t\t\t\t field.get_outer_attrs ());\n+\n+      if (struct_field_name_exists (fields, translated_field))\n+\tbreak;\n+\n+      fields.push_back (std::move (translated_field));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, struct_decl.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::StructStruct (mapping, std::move (fields),\n+\t\t\t\t      struct_decl.get_identifier (),\n+\t\t\t\t      std::move (generic_params),\n+\t\t\t\t      std::move (where_clause), is_unit, vis,\n+\t\t\t\t      struct_decl.get_outer_attrs (),\n+\t\t\t\t      struct_decl.get_locus ());\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::Enum &enum_decl)\n+{\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (enum_decl.has_generics ())\n+    {\n+      generic_params = lower_generic_params (enum_decl.get_generic_params ());\n+    }\n+\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  for (auto &item : enum_decl.get_where_clause ().get_items ())\n+    {\n+      HIR::WhereClauseItem *i\n+\t= ASTLowerWhereClauseItem::translate (*item.get ());\n+      where_clause_items.push_back (std::unique_ptr<HIR::WhereClauseItem> (i));\n+    }\n+\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+  HIR::Visibility vis = translate_visibility (enum_decl.get_visibility ());\n+\n+  // bool is_unit = enum_decl.is_zero_variant ();\n+  std::vector<std::unique_ptr<HIR::EnumItem>> items;\n+  for (auto &variant : enum_decl.get_variants ())\n+    {\n+      if (variant->is_marked_for_strip ())\n+\tcontinue;\n+\n+      HIR::EnumItem *hir_item = ASTLoweringEnumItem::translate (variant.get ());\n+      items.push_back (std::unique_ptr<HIR::EnumItem> (hir_item));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, enum_decl.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::Enum (mapping, enum_decl.get_identifier (), vis,\n+\t\t\t      std::move (generic_params),\n+\t\t\t      std::move (where_clause), /* is_unit, */\n+\t\t\t      std::move (items), enum_decl.get_outer_attrs (),\n+\t\t\t      enum_decl.get_locus ());\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::Union &union_decl)\n+{\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (union_decl.has_generics ())\n+    {\n+      generic_params = lower_generic_params (union_decl.get_generic_params ());\n+    }\n+\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  for (auto &item : union_decl.get_where_clause ().get_items ())\n+    {\n+      HIR::WhereClauseItem *i\n+\t= ASTLowerWhereClauseItem::translate (*item.get ());\n+      where_clause_items.push_back (std::unique_ptr<HIR::WhereClauseItem> (i));\n+    }\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+  HIR::Visibility vis = translate_visibility (union_decl.get_visibility ());\n+\n+  std::vector<HIR::StructField> variants;\n+  for (AST::StructField &variant : union_decl.get_variants ())\n+    {\n+      if (variant.get_field_type ()->is_marked_for_strip ())\n+\tcontinue;\n+\n+      // FIXME: Does visibility apply here?\n+      HIR::Visibility vis = translate_visibility (variant.get_visibility ());\n+      HIR::Type *type\n+\t= ASTLoweringType::translate (variant.get_field_type ().get ());\n+\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, variant.get_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     mappings->get_next_localdef_id (\n+\t\t\t\t       crate_num));\n+\n+      HIR::StructField translated_variant (mapping, variant.get_field_name (),\n+\t\t\t\t\t   std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t\t   vis, variant.get_locus (),\n+\t\t\t\t\t   variant.get_outer_attrs ());\n+\n+      if (struct_field_name_exists (variants, translated_variant))\n+\tbreak;\n+\n+      variants.push_back (std::move (translated_variant));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, union_decl.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated\n+    = new HIR::Union (mapping, union_decl.get_identifier (), vis,\n+\t\t      std::move (generic_params), std::move (where_clause),\n+\t\t      std::move (variants), union_decl.get_outer_attrs (),\n+\t\t      union_decl.get_locus ());\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::StaticItem &var)\n+{\n+  HIR::Visibility vis = translate_visibility (var.get_visibility ());\n+\n+  HIR::Type *type = ASTLoweringType::translate (var.get_type ().get ());\n+  HIR::Expr *expr = ASTLoweringExpr::translate (var.get_expr ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, var.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::StaticItem (mapping, var.get_identifier (),\n+\t\t\t\t    var.is_mutable () ? Mutability::Mut\n+\t\t\t\t\t\t      : Mutability::Imm,\n+\t\t\t\t    std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t    std::unique_ptr<HIR::Expr> (expr), vis,\n+\t\t\t\t    var.get_outer_attrs (), var.get_locus ());\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::ConstantItem &constant)\n+{\n+  HIR::Visibility vis = translate_visibility (constant.get_visibility ());\n+\n+  HIR::Type *type = ASTLoweringType::translate (constant.get_type ().get ());\n+  HIR::Expr *expr = ASTLoweringExpr::translate (constant.get_expr ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, constant.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  translated = new HIR::ConstantItem (mapping, constant.get_identifier (), vis,\n+\t\t\t\t      std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t      std::unique_ptr<HIR::Expr> (expr),\n+\t\t\t\t      constant.get_outer_attrs (),\n+\t\t\t\t      constant.get_locus ());\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::Function &function)\n+{\n+  if (function.is_marked_for_strip ())\n+    return;\n+\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  for (auto &item : function.get_where_clause ().get_items ())\n+    {\n+      HIR::WhereClauseItem *i\n+\t= ASTLowerWhereClauseItem::translate (*item.get ());\n+      where_clause_items.push_back (std::unique_ptr<HIR::WhereClauseItem> (i));\n+    }\n+\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+  HIR::FunctionQualifiers qualifiers\n+    = lower_qualifiers (function.get_qualifiers ());\n+  HIR::Visibility vis = translate_visibility (function.get_visibility ());\n+\n+  // need\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (function.has_generics ())\n+    {\n+      generic_params = lower_generic_params (function.get_generic_params ());\n+    }\n+  Identifier function_name = function.get_function_name ();\n+  Location locus = function.get_locus ();\n+\n+  std::unique_ptr<HIR::Type> return_type\n+    = function.has_return_type () ? std::unique_ptr<HIR::Type> (\n+\tASTLoweringType::translate (function.get_return_type ().get ()))\n+\t\t\t\t  : nullptr;\n+\n+  std::vector<HIR::FunctionParam> function_params;\n+  for (auto &param : function.get_function_params ())\n+    {\n+      auto translated_pattern = std::unique_ptr<HIR::Pattern> (\n+\tASTLoweringPattern::translate (param.get_pattern ().get ()));\n+      auto translated_type = std::unique_ptr<HIR::Type> (\n+\tASTLoweringType::translate (param.get_type ().get ()));\n+\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, param.get_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     UNKNOWN_LOCAL_DEFID);\n+\n+      auto hir_param\n+\t= HIR::FunctionParam (mapping, std::move (translated_pattern),\n+\t\t\t      std::move (translated_type), param.get_locus ());\n+      function_params.push_back (std::move (hir_param));\n+    }\n+\n+  bool terminated = false;\n+  std::unique_ptr<HIR::BlockExpr> function_body\n+    = std::unique_ptr<HIR::BlockExpr> (\n+      ASTLoweringBlock::translate (function.get_definition ().get (),\n+\t\t\t\t   &terminated));\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, function.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  mappings->insert_location (function_body->get_mappings ().get_hirid (),\n+\t\t\t     function.get_locus ());\n+\n+  auto fn\n+    = new HIR::Function (mapping, std::move (function_name),\n+\t\t\t std::move (qualifiers), std::move (generic_params),\n+\t\t\t std::move (function_params), std::move (return_type),\n+\t\t\t std::move (where_clause), std::move (function_body),\n+\t\t\t std::move (vis), function.get_outer_attrs (),\n+\t\t\t HIR::SelfParam::error (), locus);\n+\n+  // add the mappings for the function params at the end\n+  for (auto &param : fn->get_function_params ())\n+    {\n+      mappings->insert_hir_param (&param);\n+      mappings->insert_location (mapping.get_hirid (), param.get_locus ());\n+    }\n+\n+  translated = fn;\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::InherentImpl &impl_block)\n+{\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  for (auto &item : impl_block.get_where_clause ().get_items ())\n+    {\n+      HIR::WhereClauseItem *i\n+\t= ASTLowerWhereClauseItem::translate (*item.get ());\n+      where_clause_items.push_back (std::unique_ptr<HIR::WhereClauseItem> (i));\n+    }\n+\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+  HIR::Visibility vis = translate_visibility (impl_block.get_visibility ());\n+\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (impl_block.has_generics ())\n+    {\n+      generic_params = lower_generic_params (impl_block.get_generic_params ());\n+\n+      for (auto &generic_param : generic_params)\n+\t{\n+\t  switch (generic_param->get_kind ())\n+\t    {\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tconst HIR::TypeParam &t\n+\t\t  = static_cast<const HIR::TypeParam &> (*generic_param);\n+\n+\t\tif (t.has_type ())\n+\t\t  {\n+\t\t    // see https://github.com/rust-lang/rust/issues/36887\n+\t\t    rust_error_at (\n+\t\t      t.get_locus (),\n+\t\t      \"defaults for type parameters are not allowed here\");\n+\t\t  }\n+\t      }\n+\t      break;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  HIR::Type *impl_type\n+    = ASTLoweringType::translate (impl_block.get_type ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, impl_block.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  std::vector<std::unique_ptr<HIR::ImplItem>> impl_items;\n+  std::vector<HirId> impl_item_ids;\n+  for (auto &impl_item : impl_block.get_impl_items ())\n+    {\n+      if (impl_item->is_marked_for_strip ())\n+\tcontinue;\n+\n+      HIR::ImplItem *lowered\n+\t= ASTLowerImplItem::translate (impl_item.get (), mapping.get_hirid ());\n+      rust_assert (lowered != nullptr);\n+      impl_items.push_back (std::unique_ptr<HIR::ImplItem> (lowered));\n+      impl_item_ids.push_back (lowered->get_impl_mappings ().get_hirid ());\n+    }\n+\n+  Polarity polarity = Positive;\n+  HIR::ImplBlock *hir_impl_block = new HIR::ImplBlock (\n+    mapping, std::move (impl_items), std::move (generic_params),\n+    std::unique_ptr<HIR::Type> (impl_type), nullptr, where_clause, polarity,\n+    vis, impl_block.get_inner_attrs (), impl_block.get_outer_attrs (),\n+    impl_block.get_locus ());\n+  translated = hir_impl_block;\n+\n+  mappings->insert_hir_impl_block (hir_impl_block);\n+  for (auto &impl_item_id : impl_item_ids)\n+    {\n+      mappings->insert_impl_item_mapping (impl_item_id, hir_impl_block);\n+    }\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::Trait &trait)\n+{\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  for (auto &item : trait.get_where_clause ().get_items ())\n+    {\n+      HIR::WhereClauseItem *i\n+\t= ASTLowerWhereClauseItem::translate (*item.get ());\n+      where_clause_items.push_back (std::unique_ptr<HIR::WhereClauseItem> (i));\n+    }\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+\n+  HIR::Visibility vis = translate_visibility (trait.get_visibility ());\n+\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (trait.has_generics ())\n+    {\n+      generic_params = lower_generic_params (trait.get_generic_params ());\n+    }\n+\n+  std::vector<std::unique_ptr<HIR::TypeParamBound>> type_param_bounds;\n+  if (trait.has_type_param_bounds ())\n+    {\n+      for (auto &bound : trait.get_type_param_bounds ())\n+\t{\n+\t  HIR::TypeParamBound *b = lower_bound (bound.get ());\n+\t  type_param_bounds.push_back (\n+\t    std::unique_ptr<HIR::TypeParamBound> (b));\n+\t}\n+    }\n+\n+  std::vector<std::unique_ptr<HIR::TraitItem>> trait_items;\n+  std::vector<HirId> trait_item_ids;\n+  for (auto &item : trait.get_trait_items ())\n+    {\n+      if (item->is_marked_for_strip ())\n+\tcontinue;\n+\n+      HIR::TraitItem *lowered = ASTLowerTraitItem::translate (item.get ());\n+      trait_items.push_back (std::unique_ptr<HIR::TraitItem> (lowered));\n+      trait_item_ids.push_back (lowered->get_mappings ().get_hirid ());\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, trait.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  auto trait_unsafety = Unsafety::Normal;\n+  if (trait.is_unsafe ())\n+    {\n+      trait_unsafety = Unsafety::Unsafe;\n+    }\n+\n+  HIR::Trait *hir_trait\n+    = new HIR::Trait (mapping, trait.get_identifier (), trait_unsafety,\n+\t\t      std::move (generic_params), std::move (type_param_bounds),\n+\t\t      where_clause, std::move (trait_items), vis,\n+\t\t      trait.get_outer_attrs (), trait.get_locus ());\n+  translated = hir_trait;\n+\n+  for (auto trait_item_id : trait_item_ids)\n+    {\n+      mappings->insert_trait_item_mapping (trait_item_id, hir_trait);\n+    }\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::TraitImpl &impl_block)\n+{\n+  std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+  for (auto &item : impl_block.get_where_clause ().get_items ())\n+    {\n+      HIR::WhereClauseItem *i\n+\t= ASTLowerWhereClauseItem::translate (*item.get ());\n+      where_clause_items.push_back (std::unique_ptr<HIR::WhereClauseItem> (i));\n+    }\n+  HIR::WhereClause where_clause (std::move (where_clause_items));\n+  HIR::Visibility vis = translate_visibility (impl_block.get_visibility ());\n+\n+  std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+  if (impl_block.has_generics ())\n+    {\n+      generic_params = lower_generic_params (impl_block.get_generic_params ());\n+\n+      for (auto &generic_param : generic_params)\n+\t{\n+\t  switch (generic_param->get_kind ())\n+\t    {\n+\t      case HIR::GenericParam::GenericKind::TYPE: {\n+\t\tconst HIR::TypeParam &t\n+\t\t  = static_cast<const HIR::TypeParam &> (*generic_param);\n+\n+\t\tif (t.has_type ())\n+\t\t  {\n+\t\t    // see https://github.com/rust-lang/rust/issues/36887\n+\t\t    rust_error_at (\n+\t\t      t.get_locus (),\n+\t\t      \"defaults for type parameters are not allowed here\");\n+\t\t  }\n+\t      }\n+\t      break;\n+\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  HIR::Type *impl_type\n+    = ASTLoweringType::translate (impl_block.get_type ().get ());\n+  HIR::TypePath *trait_ref\n+    = ASTLowerTypePath::translate (impl_block.get_trait_path ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, impl_block.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t mappings->get_next_localdef_id (crate_num));\n+\n+  std::vector<std::unique_ptr<HIR::ImplItem>> impl_items;\n+  std::vector<HirId> impl_item_ids;\n+  for (auto &impl_item : impl_block.get_impl_items ())\n+    {\n+      if (impl_item->is_marked_for_strip ())\n+\tcontinue;\n+\n+      HIR::ImplItem *lowered\n+\t= ASTLowerImplItem::translate (impl_item.get (), mapping.get_hirid ());\n+      rust_assert (lowered != nullptr);\n+      impl_items.push_back (std::unique_ptr<HIR::ImplItem> (lowered));\n+      impl_item_ids.push_back (lowered->get_impl_mappings ().get_hirid ());\n+    }\n+\n+  Polarity polarity = impl_block.is_exclam () ? Positive : Negative;\n+  HIR::ImplBlock *hir_impl_block = new HIR::ImplBlock (\n+    mapping, std::move (impl_items), std::move (generic_params),\n+    std::unique_ptr<HIR::Type> (impl_type),\n+    std::unique_ptr<HIR::TypePath> (trait_ref), where_clause, polarity, vis,\n+    impl_block.get_inner_attrs (), impl_block.get_outer_attrs (),\n+    impl_block.get_locus ());\n+  translated = hir_impl_block;\n+\n+  mappings->insert_hir_impl_block (hir_impl_block);\n+  for (auto &impl_item_id : impl_item_ids)\n+    {\n+      mappings->insert_impl_item_mapping (impl_item_id, hir_impl_block);\n+    }\n+}\n+\n+void\n+ASTLoweringItem::visit (AST::ExternBlock &extern_block)\n+{\n+  translated = lower_extern_block (extern_block);\n+}\n+\n+HIR::SimplePath\n+ASTLoweringSimplePath::translate (const AST::SimplePath &path)\n+{\n+  ASTLoweringSimplePath resolver;\n+\n+  return resolver.lower (path);\n+}\n+\n+HIR::SimplePathSegment\n+ASTLoweringSimplePath::lower (const AST::SimplePathSegment &segment)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  auto node_id = segment.get_node_id ();\n+\n+  auto mapping = Analysis::NodeMapping (crate_num, node_id,\n+\t\t\t\t\tmappings->get_next_hir_id (crate_num),\n+\t\t\t\t\tUNKNOWN_LOCAL_DEFID);\n+\n+  auto hir_seg = HIR::SimplePathSegment (mapping);\n+\n+  mappings->insert_node_to_hir (node_id, mapping.get_hirid ());\n+  // mappings->insert_simple_path_segment (crate_num, node_id, &segment);\n+\n+  return hir_seg;\n+}\n+\n+HIR::SimplePath\n+ASTLoweringSimplePath::lower (const AST::SimplePath &path)\n+{\n+  auto segments = std::vector<HIR::SimplePathSegment> ();\n+  for (auto &segment : path.get_segments ())\n+    segments.emplace_back (lower (segment));\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  auto node_id = path.get_node_id ();\n+\n+  auto mapping = Analysis::NodeMapping (crate_num, node_id,\n+\t\t\t\t\tmappings->get_next_hir_id (crate_num),\n+\t\t\t\t\tUNKNOWN_LOCAL_DEFID);\n+\n+  auto lowered\n+    = HIR::SimplePath (std::move (segments), mapping, path.get_locus ());\n+\n+  mappings->insert_node_to_hir (node_id, mapping.get_hirid ());\n+  // mappings->insert_simple_path (crate_num, node_id, &path);\n+\n+  return lowered;\n+}\n+\n+} // namespace HIR\n+} // namespace Rust"}, {"sha": "5d4ee18f51780a593a0e0e04775f2d06f535f9d9", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=7999cf327de7b5bbea80046715eeb00c0755a08d", "patch": "@@ -0,0 +1,78 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_ITEM\n+#define RUST_AST_LOWER_ITEM\n+\n+#include \"rust-diagnostics.h\"\n+\n+#include \"rust-ast-lower.h\"\n+#include \"rust-ast-lower-base.h\"\n+#include \"rust-ast-lower-enumitem.h\"\n+#include \"rust-ast-lower-type.h\"\n+#include \"rust-ast-lower-implitem.h\"\n+#include \"rust-ast-lower-stmt.h\"\n+#include \"rust-ast-lower-expr.h\"\n+#include \"rust-ast-lower-pattern.h\"\n+#include \"rust-ast-lower-block.h\"\n+#include \"rust-ast-lower-extern.h\"\n+#include \"rust-hir-full-decls.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLoweringItem : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::Item *translate (AST::Item *item);\n+\n+  void visit (AST::Module &module) override;\n+  void visit (AST::TypeAlias &alias) override;\n+  void visit (AST::TupleStruct &struct_decl) override;\n+  void visit (AST::StructStruct &struct_decl) override;\n+  void visit (AST::Enum &enum_decl) override;\n+  void visit (AST::Union &union_decl) override;\n+  void visit (AST::StaticItem &var) override;\n+  void visit (AST::ConstantItem &constant) override;\n+  void visit (AST::Function &function) override;\n+  void visit (AST::InherentImpl &impl_block) override;\n+  void visit (AST::Trait &trait) override;\n+  void visit (AST::TraitImpl &impl_block) override;\n+  void visit (AST::ExternBlock &extern_block) override;\n+\n+private:\n+  ASTLoweringItem () : translated (nullptr) {}\n+\n+  HIR::Item *translated;\n+};\n+\n+class ASTLoweringSimplePath : public ASTLoweringBase\n+{\n+public:\n+  static HIR::SimplePath translate (const AST::SimplePath &path);\n+\n+  HIR::SimplePathSegment lower (const AST::SimplePathSegment &segment);\n+  HIR::SimplePath lower (const AST::SimplePath &path);\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_ITEM"}, {"sha": "2421ca8465130880894e79ce28c15d0f94ba1535", "filename": "gcc/rust/hir/rust-ast-lower-pattern.cc", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.cc?ref=7999cf327de7b5bbea80046715eeb00c0755a08d", "patch": "@@ -0,0 +1,229 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-lower-pattern.h\"\n+#include \"rust-ast-lower-expr.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+void\n+ASTLoweringPattern::visit (AST::IdentifierPattern &pattern)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, pattern.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  std::unique_ptr<Pattern> to_bind;\n+  translated\n+    = new HIR::IdentifierPattern (mapping, pattern.get_ident (),\n+\t\t\t\t  pattern.get_locus (), pattern.get_is_ref (),\n+\t\t\t\t  pattern.get_is_mut () ? Mutability::Mut\n+\t\t\t\t\t\t\t: Mutability::Imm,\n+\t\t\t\t  std::move (to_bind));\n+}\n+\n+void\n+ASTLoweringPattern::visit (AST::PathInExpression &pattern)\n+{\n+  translated = ASTLowerPathInExpression::translate (&pattern);\n+}\n+\n+void\n+ASTLoweringPattern::visit (AST::TupleStructPattern &pattern)\n+{\n+  HIR::PathInExpression *path\n+    = ASTLowerPathInExpression::translate (&pattern.get_path ());\n+\n+  TupleStructItems *lowered = nullptr;\n+  auto &items = pattern.get_items ();\n+  switch (items->get_item_type ())\n+    {\n+      case AST::TupleStructItems::RANGE: {\n+\t// TODO\n+\tgcc_unreachable ();\n+      }\n+      break;\n+\n+      case AST::TupleStructItems::NO_RANGE: {\n+\tAST::TupleStructItemsNoRange &items_no_range\n+\t  = static_cast<AST::TupleStructItemsNoRange &> (*items.get ());\n+\n+\tstd::vector<std::unique_ptr<HIR::Pattern> > patterns;\n+\tfor (auto &inner_pattern : items_no_range.get_patterns ())\n+\t  {\n+\t    HIR::Pattern *p\n+\t      = ASTLoweringPattern::translate (inner_pattern.get ());\n+\t    patterns.push_back (std::unique_ptr<HIR::Pattern> (p));\n+\t  }\n+\n+\tlowered = new HIR::TupleStructItemsNoRange (std::move (patterns));\n+      }\n+      break;\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, pattern.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated = new HIR::TupleStructPattern (\n+    mapping, *path, std::unique_ptr<HIR::TupleStructItems> (lowered));\n+}\n+\n+void\n+ASTLoweringPattern::visit (AST::StructPattern &pattern)\n+{\n+  HIR::PathInExpression *path\n+    = ASTLowerPathInExpression::translate (&pattern.get_path ());\n+\n+  auto &raw_elems = pattern.get_struct_pattern_elems ();\n+  rust_assert (!raw_elems.has_etc ());\n+\n+  std::vector<std::unique_ptr<HIR::StructPatternField> > fields;\n+  for (auto &field : raw_elems.get_struct_pattern_fields ())\n+    {\n+      HIR::StructPatternField *f = nullptr;\n+      switch (field->get_item_type ())\n+\t{\n+\t  case AST::StructPatternField::ItemType::TUPLE_PAT: {\n+\t    // TODO\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case AST::StructPatternField::ItemType::IDENT_PAT: {\n+\t    // TODO\n+\t    gcc_unreachable ();\n+\t  }\n+\t  break;\n+\n+\t  case AST::StructPatternField::ItemType::IDENT: {\n+\t    AST::StructPatternFieldIdent &ident\n+\t      = static_cast<AST::StructPatternFieldIdent &> (*field.get ());\n+\n+\t    auto crate_num = mappings->get_current_crate ();\n+\t    Analysis::NodeMapping mapping (crate_num, ident.get_node_id (),\n+\t\t\t\t\t   mappings->get_next_hir_id (\n+\t\t\t\t\t     crate_num),\n+\t\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+\t    f = new HIR::StructPatternFieldIdent (\n+\t      mapping, ident.get_identifier (), ident.is_ref (),\n+\t      ident.is_mut () ? Mutability::Mut : Mutability::Imm,\n+\t      ident.get_outer_attrs (), ident.get_locus ());\n+\t  }\n+\t  break;\n+\t}\n+\n+      // insert the reverse mappings and locations\n+      auto field_id = f->get_mappings ().get_hirid ();\n+      auto field_node_id = f->get_mappings ().get_nodeid ();\n+      mappings->insert_location (field_id, f->get_locus ());\n+      mappings->insert_node_to_hir (field_node_id, field_id);\n+\n+      // add it to the lowered fields list\n+      fields.push_back (std::unique_ptr<HIR::StructPatternField> (f));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, pattern.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  HIR::StructPatternElements elems (std::move (fields));\n+  translated = new HIR::StructPattern (mapping, *path, std::move (elems));\n+}\n+\n+void\n+ASTLoweringPattern::visit (AST::WildcardPattern &pattern)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, pattern.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated = new HIR::WildcardPattern (mapping, pattern.get_locus ());\n+}\n+\n+void\n+ASTLoweringPattern::visit (AST::TuplePattern &pattern)\n+{\n+  std::unique_ptr<HIR::TuplePatternItems> items;\n+  switch (pattern.get_items ()->get_pattern_type ())\n+    {\n+      case AST::TuplePatternItems::TuplePatternItemType::MULTIPLE: {\n+\tAST::TuplePatternItemsMultiple &ref\n+\t  = *static_cast<AST::TuplePatternItemsMultiple *> (\n+\t    pattern.get_items ().get ());\n+\titems = lower_tuple_pattern_multiple (ref);\n+      }\n+      break;\n+\n+      case AST::TuplePatternItems::TuplePatternItemType::RANGED: {\n+\tAST::TuplePatternItemsRanged &ref\n+\t  = *static_cast<AST::TuplePatternItemsRanged *> (\n+\t    pattern.get_items ().get ());\n+\titems = lower_tuple_pattern_ranged (ref);\n+      }\n+      break;\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, pattern.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::TuplePattern (mapping, std::move (items), pattern.get_locus ());\n+}\n+\n+void\n+ASTLoweringPattern::visit (AST::LiteralPattern &pattern)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, pattern.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  HIR::Literal l = lower_literal (pattern.get_literal ());\n+  translated\n+    = new HIR::LiteralPattern (mapping, std::move (l), pattern.get_locus ());\n+}\n+\n+void\n+ASTLoweringPattern::visit (AST::RangePattern &pattern)\n+{\n+  auto upper_bound\n+    = lower_range_pattern_bound (pattern.get_upper_bound ().get ());\n+  auto lower_bound\n+    = lower_range_pattern_bound (pattern.get_lower_bound ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, pattern.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::RangePattern (mapping, std::move (lower_bound),\n+\t\t\t     std::move (upper_bound), pattern.get_locus ());\n+}\n+\n+} // namespace HIR\n+} // namespace Rust"}, {"sha": "aab99f602d5f41752f8e927a1fb0cc6ae88f42f4", "filename": "gcc/rust/hir/rust-ast-lower-pattern.h", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-pattern.h?ref=7999cf327de7b5bbea80046715eeb00c0755a08d", "patch": "@@ -0,0 +1,72 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_PATTERN\n+#define RUST_AST_LOWER_PATTERN\n+\n+#include \"rust-ast-lower-base.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLoweringPattern : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::Pattern *translate (AST::Pattern *pattern)\n+  {\n+    ASTLoweringPattern resolver;\n+    pattern->accept_vis (resolver);\n+\n+    rust_assert (resolver.translated != nullptr);\n+\n+    resolver.mappings->insert_hir_pattern (resolver.translated);\n+    resolver.mappings->insert_location (\n+      resolver.translated->get_pattern_mappings ().get_hirid (),\n+      pattern->get_locus ());\n+\n+    return resolver.translated;\n+  }\n+\n+  void visit (AST::IdentifierPattern &pattern) override;\n+\n+  void visit (AST::PathInExpression &pattern) override;\n+\n+  void visit (AST::StructPattern &pattern) override;\n+\n+  void visit (AST::TupleStructPattern &pattern) override;\n+\n+  void visit (AST::WildcardPattern &pattern) override;\n+\n+  void visit (AST::TuplePattern &pattern) override;\n+\n+  void visit (AST::LiteralPattern &pattern) override;\n+\n+  void visit (AST::RangePattern &pattern) override;\n+\n+private:\n+  ASTLoweringPattern () : translated (nullptr) {}\n+\n+  HIR::Pattern *translated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_PATTERN"}, {"sha": "2b26ae3835cb571e5c80691204a423b05d8e2ad0", "filename": "gcc/rust/hir/rust-ast-lower-stmt.h", "status": "added", "additions": 418, "deletions": 0, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-stmt.h?ref=7999cf327de7b5bbea80046715eeb00c0755a08d", "patch": "@@ -0,0 +1,418 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_STMT\n+#define RUST_AST_LOWER_STMT\n+\n+#include \"rust-diagnostics.h\"\n+\n+#include \"rust-ast-lower-base.h\"\n+#include \"rust-ast-lower-enumitem.h\"\n+#include \"rust-ast-lower-type.h\"\n+#include \"rust-ast-lower-block.h\"\n+#include \"rust-ast-lower-expr.h\"\n+#include \"rust-ast-lower-pattern.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLoweringStmt : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::Stmt *translate (AST::Stmt *stmt, bool *terminated)\n+  {\n+    ASTLoweringStmt resolver;\n+    stmt->accept_vis (resolver);\n+\n+    rust_assert (resolver.translated != nullptr);\n+    *terminated = resolver.terminated;\n+    resolver.mappings->insert_location (\n+      resolver.translated->get_mappings ().get_hirid (),\n+      resolver.translated->get_locus ());\n+    resolver.mappings->insert_hir_stmt (resolver.translated);\n+    if (resolver.translated->is_item ())\n+      {\n+\tHIR::Item *i = static_cast<HIR::Item *> (resolver.translated);\n+\n+\tauto defid = resolver.translated->get_mappings ().get_defid ();\n+\n+\tresolver.handle_outer_attributes (*i);\n+\tresolver.mappings->insert_hir_item (i);\n+\tresolver.mappings->insert_defid_mapping (defid, i);\n+      }\n+\n+    return resolver.translated;\n+  }\n+\n+  void visit (AST::ExprStmtWithBlock &stmt) override\n+  {\n+    HIR::ExprWithBlock *expr\n+      = ASTLoweringExprWithBlock::translate (stmt.get_expr ().get (),\n+\t\t\t\t\t     &terminated);\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, stmt.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+    translated\n+      = new HIR::ExprStmtWithBlock (mapping,\n+\t\t\t\t    std::unique_ptr<HIR::ExprWithBlock> (expr),\n+\t\t\t\t    stmt.get_locus (),\n+\t\t\t\t    !stmt.is_semicolon_followed ());\n+  }\n+\n+  void visit (AST::ExprStmtWithoutBlock &stmt) override\n+  {\n+    HIR::Expr *expr\n+      = ASTLoweringExpr::translate (stmt.get_expr ().get (), &terminated);\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, stmt.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+    translated\n+      = new HIR::ExprStmtWithoutBlock (mapping,\n+\t\t\t\t       std::unique_ptr<HIR::Expr> (expr),\n+\t\t\t\t       stmt.get_locus ());\n+  }\n+\n+  void visit (AST::ConstantItem &constant) override\n+  {\n+    HIR::Visibility vis = translate_visibility (constant.get_visibility ());\n+\n+    HIR::Type *type = ASTLoweringType::translate (constant.get_type ().get ());\n+    HIR::Expr *expr = ASTLoweringExpr::translate (constant.get_expr ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, constant.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::ConstantItem (mapping, constant.get_identifier (),\n+\t\t\t\t\tvis, std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t\tstd::unique_ptr<HIR::Expr> (expr),\n+\t\t\t\t\tconstant.get_outer_attrs (),\n+\t\t\t\t\tconstant.get_locus ());\n+  }\n+\n+  void visit (AST::LetStmt &stmt) override\n+  {\n+    HIR::Pattern *variables\n+      = ASTLoweringPattern::translate (stmt.get_pattern ().get ());\n+    HIR::Type *type = stmt.has_type ()\n+\t\t\t? ASTLoweringType::translate (stmt.get_type ().get ())\n+\t\t\t: nullptr;\n+    HIR::Expr *init_expression\n+      = stmt.has_init_expr ()\n+\t  ? ASTLoweringExpr::translate (stmt.get_init_expr ().get ())\n+\t  : nullptr;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, stmt.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+    translated\n+      = new HIR::LetStmt (mapping, std::unique_ptr<HIR::Pattern> (variables),\n+\t\t\t  std::unique_ptr<HIR::Expr> (init_expression),\n+\t\t\t  std::unique_ptr<HIR::Type> (type),\n+\t\t\t  stmt.get_outer_attrs (), stmt.get_locus ());\n+  }\n+\n+  void visit (AST::TupleStruct &struct_decl) override\n+  {\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+    if (struct_decl.has_generics ())\n+      {\n+\tgeneric_params\n+\t  = lower_generic_params (struct_decl.get_generic_params ());\n+      }\n+\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::Visibility vis = translate_visibility (struct_decl.get_visibility ());\n+\n+    std::vector<HIR::TupleField> fields;\n+    for (AST::TupleField &field : struct_decl.get_fields ())\n+      {\n+\tHIR::Visibility vis = translate_visibility (field.get_visibility ());\n+\tHIR::Type *type\n+\t  = ASTLoweringType::translate (field.get_field_type ().get ());\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, field.get_node_id (),\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       mappings->get_next_localdef_id (\n+\t\t\t\t\t crate_num));\n+\n+\tHIR::TupleField translated_field (mapping,\n+\t\t\t\t\t  std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t\t  vis, field.get_locus (),\n+\t\t\t\t\t  field.get_outer_attrs ());\n+\tfields.push_back (std::move (translated_field));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, struct_decl.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::TupleStruct (mapping, std::move (fields),\n+\t\t\t\t       struct_decl.get_identifier (),\n+\t\t\t\t       std::move (generic_params),\n+\t\t\t\t       std::move (where_clause), vis,\n+\t\t\t\t       struct_decl.get_outer_attrs (),\n+\t\t\t\t       struct_decl.get_locus ());\n+  }\n+\n+  void visit (AST::StructStruct &struct_decl) override\n+  {\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+    if (struct_decl.has_generics ())\n+      {\n+\tgeneric_params\n+\t  = lower_generic_params (struct_decl.get_generic_params ());\n+      }\n+\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::Visibility vis = translate_visibility (struct_decl.get_visibility ());\n+\n+    bool is_unit = struct_decl.is_unit_struct ();\n+    std::vector<HIR::StructField> fields;\n+    for (AST::StructField &field : struct_decl.get_fields ())\n+      {\n+\tHIR::Visibility vis = translate_visibility (field.get_visibility ());\n+\tHIR::Type *type\n+\t  = ASTLoweringType::translate (field.get_field_type ().get ());\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, field.get_node_id (),\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       mappings->get_next_localdef_id (\n+\t\t\t\t\t crate_num));\n+\n+\tHIR::StructField translated_field (mapping, field.get_field_name (),\n+\t\t\t\t\t   std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t\t   vis, field.get_locus (),\n+\t\t\t\t\t   field.get_outer_attrs ());\n+\n+\tif (struct_field_name_exists (fields, translated_field))\n+\t  break;\n+\n+\tfields.push_back (std::move (translated_field));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, struct_decl.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::StructStruct (mapping, std::move (fields),\n+\t\t\t\t\tstruct_decl.get_identifier (),\n+\t\t\t\t\tstd::move (generic_params),\n+\t\t\t\t\tstd::move (where_clause), is_unit, vis,\n+\t\t\t\t\tstruct_decl.get_outer_attrs (),\n+\t\t\t\t\tstruct_decl.get_locus ());\n+  }\n+\n+  void visit (AST::Union &union_decl) override\n+  {\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+    if (union_decl.has_generics ())\n+      {\n+\tgeneric_params\n+\t  = lower_generic_params (union_decl.get_generic_params ());\n+      }\n+\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::Visibility vis = translate_visibility (union_decl.get_visibility ());\n+\n+    std::vector<HIR::StructField> variants;\n+    for (AST::StructField &variant : union_decl.get_variants ())\n+      {\n+\tHIR::Visibility vis = translate_visibility (variant.get_visibility ());\n+\tHIR::Type *type\n+\t  = ASTLoweringType::translate (variant.get_field_type ().get ());\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, variant.get_node_id (),\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       mappings->get_next_localdef_id (\n+\t\t\t\t\t crate_num));\n+\n+\tHIR::StructField translated_variant (mapping, variant.get_field_name (),\n+\t\t\t\t\t     std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t\t     vis, variant.get_locus (),\n+\t\t\t\t\t     variant.get_outer_attrs ());\n+\n+\tif (struct_field_name_exists (variants, translated_variant))\n+\t  break;\n+\n+\tvariants.push_back (std::move (translated_variant));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, union_decl.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated\n+      = new HIR::Union (mapping, union_decl.get_identifier (), vis,\n+\t\t\tstd::move (generic_params), std::move (where_clause),\n+\t\t\tstd::move (variants), union_decl.get_outer_attrs (),\n+\t\t\tunion_decl.get_locus ());\n+  }\n+\n+  void visit (AST::Enum &enum_decl) override\n+  {\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+    if (enum_decl.has_generics ())\n+      {\n+\tgeneric_params = lower_generic_params (enum_decl.get_generic_params ());\n+      }\n+\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::Visibility vis = translate_visibility (enum_decl.get_visibility ());\n+\n+    // bool is_unit = enum_decl.is_zero_variant ();\n+    std::vector<std::unique_ptr<HIR::EnumItem>> items;\n+    for (auto &variant : enum_decl.get_variants ())\n+      {\n+\tHIR::EnumItem *hir_item\n+\t  = ASTLoweringEnumItem::translate (variant.get ());\n+\titems.push_back (std::unique_ptr<HIR::EnumItem> (hir_item));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, enum_decl.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::Enum (mapping, enum_decl.get_identifier (), vis,\n+\t\t\t\tstd::move (generic_params),\n+\t\t\t\tstd::move (where_clause), /* is_unit, */\n+\t\t\t\tstd::move (items), enum_decl.get_outer_attrs (),\n+\t\t\t\tenum_decl.get_locus ());\n+  }\n+\n+  void visit (AST::EmptyStmt &empty) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, empty.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::EmptyStmt (mapping, empty.get_locus ());\n+  }\n+\n+  void visit (AST::Function &function) override\n+  {\n+    // ignore for now and leave empty\n+    std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+    HIR::WhereClause where_clause (std::move (where_clause_items));\n+    HIR::FunctionQualifiers qualifiers\n+      = lower_qualifiers (function.get_qualifiers ());\n+    HIR::Visibility vis = translate_visibility (function.get_visibility ());\n+\n+    // need\n+    std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n+    if (function.has_generics ())\n+      {\n+\tgeneric_params = lower_generic_params (function.get_generic_params ());\n+      }\n+\n+    Identifier function_name = function.get_function_name ();\n+    Location locus = function.get_locus ();\n+\n+    std::unique_ptr<HIR::Type> return_type\n+      = function.has_return_type () ? std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (function.get_return_type ().get ()))\n+\t\t\t\t    : nullptr;\n+\n+    std::vector<HIR::FunctionParam> function_params;\n+    for (auto &param : function.get_function_params ())\n+      {\n+\tauto translated_pattern = std::unique_ptr<HIR::Pattern> (\n+\t  ASTLoweringPattern::translate (param.get_pattern ().get ()));\n+\tauto translated_type = std::unique_ptr<HIR::Type> (\n+\t  ASTLoweringType::translate (param.get_type ().get ()));\n+\n+\tauto crate_num = mappings->get_current_crate ();\n+\tAnalysis::NodeMapping mapping (crate_num, param.get_node_id (),\n+\t\t\t\t       mappings->get_next_hir_id (crate_num),\n+\t\t\t\t       UNKNOWN_LOCAL_DEFID);\n+\n+\tauto hir_param\n+\t  = HIR::FunctionParam (mapping, std::move (translated_pattern),\n+\t\t\t\tstd::move (translated_type),\n+\t\t\t\tparam.get_locus ());\n+\tfunction_params.push_back (hir_param);\n+      }\n+\n+    bool terminated = false;\n+    std::unique_ptr<HIR::BlockExpr> function_body\n+      = std::unique_ptr<HIR::BlockExpr> (\n+\tASTLoweringBlock::translate (function.get_definition ().get (),\n+\t\t\t\t     &terminated));\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, function.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    mappings->insert_location (function_body->get_mappings ().get_hirid (),\n+\t\t\t       function.get_locus ());\n+\n+    auto fn\n+      = new HIR::Function (mapping, std::move (function_name),\n+\t\t\t   std::move (qualifiers), std::move (generic_params),\n+\t\t\t   std::move (function_params), std::move (return_type),\n+\t\t\t   std::move (where_clause), std::move (function_body),\n+\t\t\t   std::move (vis), function.get_outer_attrs (),\n+\t\t\t   HIR::SelfParam::error (), locus);\n+\n+    // add the mappings for the function params at the end\n+    for (auto &param : fn->get_function_params ())\n+      {\n+\tmappings->insert_hir_param (&param);\n+\tmappings->insert_location (mapping.get_hirid (), param.get_locus ());\n+      }\n+\n+    translated = fn;\n+  }\n+\n+  void visit (AST::ExternBlock &extern_block) override\n+  {\n+    translated = lower_extern_block (extern_block);\n+  }\n+\n+private:\n+  ASTLoweringStmt () : translated (nullptr), terminated (false) {}\n+\n+  HIR::Stmt *translated;\n+  bool terminated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_PATTERN"}, {"sha": "dadf3594904eb7de053e8c68d72f00a6b11e7cde", "filename": "gcc/rust/hir/rust-ast-lower-struct-field-expr.h", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-struct-field-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-struct-field-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-struct-field-expr.h?ref=7999cf327de7b5bbea80046715eeb00c0755a08d", "patch": "@@ -0,0 +1,63 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_STRUCT_FIELD_EXPR\n+#define RUST_AST_LOWER_STRUCT_FIELD_EXPR\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-ast-lower-base.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLowerStructExprField : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::StructExprField *translate (AST::StructExprField *field)\n+  {\n+    ASTLowerStructExprField compiler;\n+    field->accept_vis (compiler);\n+    rust_assert (compiler.translated != nullptr);\n+\n+    compiler.mappings->insert_hir_struct_field (compiler.translated);\n+    compiler.mappings->insert_location (\n+      compiler.translated->get_mappings ().get_hirid (), field->get_locus ());\n+\n+    return compiler.translated;\n+  }\n+\n+  ~ASTLowerStructExprField () {}\n+\n+  void visit (AST::StructExprFieldIdentifierValue &field) override;\n+\n+  void visit (AST::StructExprFieldIndexValue &field) override;\n+\n+  void visit (AST::StructExprFieldIdentifier &field) override;\n+\n+private:\n+  ASTLowerStructExprField () : translated (nullptr) {}\n+\n+  HIR::StructExprField *translated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_STRUCT_FIELD_EXPR"}, {"sha": "46f765a3ea2cef7d02f10c73fdec5fbad6b77909", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "added", "additions": 532, "deletions": 0, "changes": 532, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=7999cf327de7b5bbea80046715eeb00c0755a08d", "patch": "@@ -0,0 +1,532 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_LOWER_TYPE\n+#define RUST_AST_LOWER_TYPE\n+\n+#include \"rust-ast-lower-base.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"rust-ast-lower-expr.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class ASTLowerTypePath : public ASTLoweringBase\n+{\n+protected:\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::TypePath *translate (AST::TypePath &type)\n+  {\n+    ASTLowerTypePath resolver;\n+    type.accept_vis (resolver);\n+    rust_assert (resolver.translated != nullptr);\n+    return resolver.translated;\n+  }\n+\n+  void visit (AST::TypePathSegmentFunction &) override { gcc_unreachable (); }\n+\n+  void visit (AST::TypePathSegment &segment) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    auto hirid = mappings->get_next_hir_id (crate_num);\n+    Analysis::NodeMapping mapping (crate_num, segment.get_node_id (), hirid,\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    HIR::PathIdentSegment ident (segment.get_ident_segment ().as_string ());\n+    translated_segment\n+      = new HIR::TypePathSegment (std::move (mapping), ident,\n+\t\t\t\t  segment.get_separating_scope_resolution (),\n+\t\t\t\t  segment.get_locus ());\n+  }\n+\n+  void visit (AST::TypePathSegmentGeneric &segment) override;\n+\n+  void visit (AST::TypePath &path) override\n+  {\n+    std::vector<std::unique_ptr<HIR::TypePathSegment>> translated_segments;\n+\n+    for (auto &seg : path.get_segments ())\n+      {\n+\ttranslated_segment = nullptr;\n+\tseg->accept_vis (*this);\n+\tif (translated_segment == nullptr)\n+\t  {\n+\t    rust_fatal_error (seg->get_locus (),\n+\t\t\t      \"failed to translate AST TypePathSegment\");\n+\t  }\n+\ttranslated_segments.push_back (\n+\t  std::unique_ptr<HIR::TypePathSegment> (translated_segment));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    auto hirid = mappings->get_next_hir_id (crate_num);\n+    Analysis::NodeMapping mapping (crate_num, path.get_node_id (), hirid,\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated\n+      = new HIR::TypePath (std::move (mapping), std::move (translated_segments),\n+\t\t\t   path.get_locus (),\n+\t\t\t   path.has_opening_scope_resolution_op ());\n+  }\n+\n+protected:\n+  HIR::TypePathSegment *translated_segment;\n+\n+private:\n+  HIR::TypePath *translated;\n+};\n+\n+class ASTLowerQualifiedPathInType : public ASTLowerTypePath\n+{\n+  using ASTLowerTypePath::visit;\n+\n+public:\n+  static HIR::QualifiedPathInType *translate (AST::QualifiedPathInType &type)\n+  {\n+    ASTLowerQualifiedPathInType resolver;\n+    type.accept_vis (resolver);\n+    rust_assert (resolver.translated != nullptr);\n+    return resolver.translated;\n+  }\n+\n+  void visit (AST::QualifiedPathInType &path) override;\n+\n+private:\n+  HIR::QualifiedPathInType *translated;\n+};\n+\n+class ASTLoweringType : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::Type *translate (AST::Type *type)\n+  {\n+    ASTLoweringType resolver;\n+    type->accept_vis (resolver);\n+\n+    rust_assert (resolver.translated != nullptr);\n+    resolver.mappings->insert_hir_type (resolver.translated);\n+    resolver.mappings->insert_location (\n+      resolver.translated->get_mappings ().get_hirid (),\n+      resolver.translated->get_locus ());\n+\n+    return resolver.translated;\n+  }\n+\n+  void visit (AST::BareFunctionType &fntype) override\n+  {\n+    bool is_variadic = false;\n+    std::vector<HIR::LifetimeParam> lifetime_params;\n+    HIR::FunctionQualifiers qualifiers\n+      = lower_qualifiers (fntype.get_function_qualifiers ());\n+\n+    std::vector<HIR::MaybeNamedParam> named_params;\n+    for (auto &param : fntype.get_function_params ())\n+      {\n+\tHIR::MaybeNamedParam::ParamKind kind;\n+\tswitch (param.get_param_kind ())\n+\t  {\n+\t  case AST::MaybeNamedParam::ParamKind::UNNAMED:\n+\t    kind = HIR::MaybeNamedParam::ParamKind::UNNAMED;\n+\t    break;\n+\t  case AST::MaybeNamedParam::ParamKind::IDENTIFIER:\n+\t    kind = HIR::MaybeNamedParam::ParamKind::IDENTIFIER;\n+\t    break;\n+\t  case AST::MaybeNamedParam::ParamKind::WILDCARD:\n+\t    kind = HIR::MaybeNamedParam::ParamKind::WILDCARD;\n+\t    break;\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n+\n+\tHIR::Type *param_type\n+\t  = ASTLoweringType::translate (param.get_type ().get ());\n+\n+\tHIR::MaybeNamedParam p (param.get_name (), kind,\n+\t\t\t\tstd::unique_ptr<HIR::Type> (param_type),\n+\t\t\t\tparam.get_locus ());\n+\tnamed_params.push_back (std::move (p));\n+      }\n+\n+    HIR::Type *return_type = nullptr;\n+    if (fntype.has_return_type ())\n+      {\n+\treturn_type\n+\t  = ASTLoweringType::translate (fntype.get_return_type ().get ());\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, fntype.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::BareFunctionType (\n+      std::move (mapping), std::move (lifetime_params), std::move (qualifiers),\n+      std::move (named_params), is_variadic,\n+      std::unique_ptr<HIR::Type> (return_type), fntype.get_locus ());\n+  }\n+\n+  void visit (AST::TupleType &tuple) override\n+  {\n+    std::vector<std::unique_ptr<HIR::Type>> elems;\n+    for (auto &e : tuple.get_elems ())\n+      {\n+\tHIR::Type *t = ASTLoweringType::translate (e.get ());\n+\telems.push_back (std::unique_ptr<HIR::Type> (t));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, tuple.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::TupleType (std::move (mapping), std::move (elems),\n+\t\t\t\t     tuple.get_locus ());\n+  }\n+\n+  void visit (AST::TypePath &path) override\n+  {\n+    translated = ASTLowerTypePath::translate (path);\n+  }\n+\n+  void visit (AST::QualifiedPathInType &path) override\n+  {\n+    translated = ASTLowerQualifiedPathInType::translate (path);\n+  }\n+\n+  void visit (AST::ArrayType &type) override\n+  {\n+    HIR::Type *translated_type\n+      = ASTLoweringType::translate (type.get_elem_type ().get ());\n+    HIR::Expr *array_size\n+      = ASTLoweringExpr::translate (type.get_size_expr ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated\n+      = new HIR::ArrayType (mapping,\n+\t\t\t    std::unique_ptr<HIR::Type> (translated_type),\n+\t\t\t    std::unique_ptr<HIR::Expr> (array_size),\n+\t\t\t    type.get_locus ());\n+  }\n+\n+  void visit (AST::ReferenceType &type) override\n+  {\n+    HIR::Lifetime lifetime = lower_lifetime (type.get_lifetime ());\n+\n+    HIR::Type *base_type\n+      = ASTLoweringType::translate (type.get_base_type ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::ReferenceType (mapping,\n+\t\t\t\t\t type.get_has_mut () ? Mutability::Mut\n+\t\t\t\t\t\t\t     : Mutability::Imm,\n+\t\t\t\t\t std::unique_ptr<HIR::Type> (base_type),\n+\t\t\t\t\t type.get_locus (), lifetime);\n+  }\n+\n+  void visit (AST::RawPointerType &type) override\n+  {\n+    HIR::Type *base_type\n+      = ASTLoweringType::translate (type.get_type_pointed_to ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated\n+      = new HIR::RawPointerType (mapping,\n+\t\t\t\t type.get_pointer_type ()\n+\t\t\t\t     == AST::RawPointerType::PointerType::MUT\n+\t\t\t\t   ? Mutability::Mut\n+\t\t\t\t   : Mutability::Imm,\n+\t\t\t\t std::unique_ptr<HIR::Type> (base_type),\n+\t\t\t\t type.get_locus ());\n+  }\n+\n+  void visit (AST::SliceType &type) override\n+  {\n+    HIR::Type *base_type\n+      = ASTLoweringType::translate (type.get_elem_type ().get ());\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated\n+      = new HIR::SliceType (mapping, std::unique_ptr<HIR::Type> (base_type),\n+\t\t\t    type.get_locus ());\n+  }\n+\n+  void visit (AST::InferredType &type) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::InferredType (mapping, type.get_locus ());\n+  }\n+\n+  void visit (AST::NeverType &type) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, type.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated = new HIR::NeverType (mapping, type.get_locus ());\n+  }\n+\n+  void visit (AST::TraitObjectTypeOneBound &type) override;\n+\n+  void visit (AST::TraitObjectType &type) override;\n+\n+private:\n+  ASTLoweringType () : ASTLoweringBase (), translated (nullptr) {}\n+\n+  HIR::Type *translated;\n+};\n+\n+class ASTLowerGenericParam : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::GenericParam *translate (AST::GenericParam *param)\n+  {\n+    ASTLowerGenericParam resolver;\n+    param->accept_vis (resolver);\n+\n+    rust_assert (resolver.translated != nullptr);\n+    resolver.mappings->insert_location (\n+      resolver.translated->get_mappings ().get_hirid (), param->get_locus ());\n+    resolver.mappings->insert_hir_generic_param (resolver.translated);\n+\n+    return resolver.translated;\n+  }\n+\n+  void visit (AST::LifetimeParam &param) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, param.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    HIR::Lifetime lt (mapping, param.get_lifetime ().get_lifetime_type (),\n+\t\t      param.get_lifetime ().get_lifetime_name (),\n+\t\t      param.get_lifetime ().get_locus ());\n+\n+    translated = new HIR::LifetimeParam (mapping, lt, param.get_locus (),\n+\t\t\t\t\t std::vector<Lifetime> ());\n+  }\n+\n+  void visit (AST::ConstGenericParam &param) override\n+  {\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, param.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    auto type = ASTLoweringType::translate (param.get_type ().get ());\n+\n+    HIR::Expr *default_expr = nullptr;\n+    if (param.has_default_value ())\n+      default_expr = ASTLoweringExpr::translate (\n+\tparam.get_default_value ().get_expression ().get ());\n+\n+    translated\n+      = new HIR::ConstGenericParam (param.get_name (),\n+\t\t\t\t    std::unique_ptr<Type> (type),\n+\t\t\t\t    std::unique_ptr<Expr> (default_expr),\n+\t\t\t\t    mapping, param.get_locus ());\n+  }\n+\n+  void visit (AST::TypeParam &param) override\n+  {\n+    AST::Attribute outer_attr = AST::Attribute::create_empty ();\n+    std::vector<std::unique_ptr<HIR::TypeParamBound>> type_param_bounds;\n+    if (param.has_type_param_bounds ())\n+      {\n+\tfor (auto &bound : param.get_type_param_bounds ())\n+\t  {\n+\t    HIR::TypeParamBound *lowered_bound = lower_bound (bound.get ());\n+\t    type_param_bounds.push_back (\n+\t      std::unique_ptr<HIR::TypeParamBound> (lowered_bound));\n+\t  }\n+      }\n+\n+    HIR::Type *type = param.has_type ()\n+\t\t\t? ASTLoweringType::translate (param.get_type ().get ())\n+\t\t\t: nullptr;\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, param.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   mappings->get_next_localdef_id (crate_num));\n+\n+    translated\n+      = new HIR::TypeParam (mapping, param.get_type_representation (),\n+\t\t\t    param.get_locus (), std::move (type_param_bounds),\n+\t\t\t    std::unique_ptr<Type> (type),\n+\t\t\t    std::move (outer_attr));\n+  }\n+\n+private:\n+  ASTLowerGenericParam () : ASTLoweringBase (), translated (nullptr) {}\n+\n+  HIR::GenericParam *translated;\n+};\n+\n+class ASTLoweringTypeBounds : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::TypeParamBound *translate (AST::TypeParamBound *type)\n+  {\n+    ASTLoweringTypeBounds resolver;\n+    type->accept_vis (resolver);\n+\n+    rust_assert (resolver.translated != nullptr);\n+    resolver.mappings->insert_location (\n+      resolver.translated->get_mappings ().get_hirid (),\n+      resolver.translated->get_locus ());\n+\n+    return resolver.translated;\n+  }\n+\n+  void visit (AST::TraitBound &bound) override\n+  {\n+    // FIXME\n+    std::vector<HIR::LifetimeParam> lifetimes;\n+\n+    AST::TypePath &ast_trait_path = bound.get_type_path ();\n+    HIR::TypePath *trait_path = ASTLowerTypePath::translate (ast_trait_path);\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, bound.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::TraitBound (mapping, *trait_path, bound.get_locus (),\n+\t\t\t\t      bound.is_in_parens (),\n+\t\t\t\t      bound.has_opening_question_mark ());\n+  }\n+\n+  void visit (AST::Lifetime &bound) override\n+  {\n+    HIR::Lifetime lifetime = lower_lifetime (bound);\n+    translated = new HIR::Lifetime (lifetime);\n+  }\n+\n+private:\n+  ASTLoweringTypeBounds () : ASTLoweringBase (), translated (nullptr) {}\n+\n+  HIR::TypeParamBound *translated;\n+};\n+\n+class ASTLowerWhereClauseItem : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::WhereClauseItem *translate (AST::WhereClauseItem &item)\n+  {\n+    ASTLowerWhereClauseItem compiler;\n+    item.accept_vis (compiler);\n+\n+    rust_assert (compiler.translated != nullptr);\n+    // FIXME\n+    // compiler.mappings->insert_location (\n+    //   compiler.translated->get_mappings ().get_hirid (),\n+    //   compiler.translated->get_locus ());\n+\n+    return compiler.translated;\n+  }\n+\n+  void visit (AST::LifetimeWhereClauseItem &item) override\n+  {\n+    HIR::Lifetime l = lower_lifetime (item.get_lifetime ());\n+    std::vector<HIR::Lifetime> lifetime_bounds;\n+    for (auto &lifetime_bound : item.get_lifetime_bounds ())\n+      {\n+\tHIR::Lifetime ll = lower_lifetime (lifetime_bound);\n+\tlifetime_bounds.push_back (std::move (ll));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, item.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::LifetimeWhereClauseItem (mapping, std::move (l),\n+\t\t\t\t\t\t   std::move (lifetime_bounds),\n+\t\t\t\t\t\t   item.get_locus ());\n+  }\n+\n+  void visit (AST::TypeBoundWhereClauseItem &item) override\n+  {\n+    // FIXME\n+    std::vector<HIR::LifetimeParam> for_lifetimes;\n+\n+    std::unique_ptr<HIR::Type> bound_type = std::unique_ptr<HIR::Type> (\n+      ASTLoweringType::translate (item.get_type ().get ()));\n+\n+    std::vector<std::unique_ptr<HIR::TypeParamBound>> type_param_bounds;\n+    for (auto &bound : item.get_type_param_bounds ())\n+      {\n+\tHIR::TypeParamBound *b\n+\t  = ASTLoweringTypeBounds::translate (bound.get ());\n+\ttype_param_bounds.push_back (std::unique_ptr<HIR::TypeParamBound> (b));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, item.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::TypeBoundWhereClauseItem (mapping, std::move (for_lifetimes),\n+\t\t\t\t\t   std::move (bound_type),\n+\t\t\t\t\t   std::move (type_param_bounds),\n+\t\t\t\t\t   item.get_locus ());\n+  }\n+\n+private:\n+  ASTLowerWhereClauseItem () : ASTLoweringBase (), translated (nullptr) {}\n+\n+  HIR::WhereClauseItem *translated;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_AST_LOWER_TYPE"}, {"sha": "0bec8b088afea3a0ad59e864a3440d351e19204b", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "added", "additions": 477, "deletions": 0, "changes": 477, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=7999cf327de7b5bbea80046715eeb00c0755a08d", "patch": "@@ -0,0 +1,477 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-lower.h\"\n+#include \"rust-ast-lower-item.h\"\n+#include \"rust-ast-lower-implitem.h\"\n+#include \"rust-ast-lower-expr.h\"\n+#include \"rust-ast-lower-block.h\"\n+#include \"rust-ast-lower-type.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+Visibility\n+translate_visibility (const AST::Visibility &vis)\n+{\n+  // FIXME: How do we create a private visibility here? Is it always private if\n+  // the AST vis is an error?\n+  // FIXME: We need to add a `create_private()` static function to the\n+  // AST::Visibility class and use it when the vis is empty in the parser...\n+  if (vis.is_error ())\n+    return Visibility::create_error ();\n+\n+  switch (vis.get_public_vis_type ())\n+    {\n+    case AST::Visibility::PUB:\n+      return Visibility (Visibility::VisType::PUBLIC);\n+    case AST::Visibility::PRIV:\n+    case AST::Visibility::PUB_SELF:\n+      return Visibility (Visibility::VisType::PRIVATE);\n+    case AST::Visibility::PUB_CRATE:\n+    case AST::Visibility::PUB_SUPER:\n+    case AST::Visibility::PUB_IN_PATH:\n+      return Visibility (Visibility::VisType::RESTRICTED,\n+\t\t\t ASTLoweringSimplePath::translate (vis.get_path ()));\n+      break;\n+    }\n+\n+  return Visibility::create_error ();\n+}\n+\n+ASTLowering::ASTLowering (AST::Crate &astCrate) : astCrate (astCrate) {}\n+\n+ASTLowering::~ASTLowering () {}\n+\n+std::unique_ptr<HIR::Crate>\n+ASTLowering::Resolve (AST::Crate &astCrate)\n+{\n+  ASTLowering resolver (astCrate);\n+  return resolver.go ();\n+}\n+\n+std::unique_ptr<HIR::Crate>\n+ASTLowering::go ()\n+{\n+  std::vector<std::unique_ptr<HIR::Item> > items;\n+\n+  for (auto it = astCrate.items.begin (); it != astCrate.items.end (); it++)\n+    {\n+      auto translated = ASTLoweringItem::translate (it->get ());\n+      if (translated != nullptr)\n+\titems.push_back (std::unique_ptr<HIR::Item> (translated));\n+    }\n+\n+  auto mappings = Analysis::Mappings::get ();\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, astCrate.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  return std::unique_ptr<HIR::Crate> (\n+    new HIR::Crate (std::move (items), astCrate.get_inner_attrs (), mapping));\n+}\n+\n+// rust-ast-lower-block.h\n+void\n+ASTLoweringBlock::visit (AST::BlockExpr &expr)\n+{\n+  std::vector<std::unique_ptr<HIR::Stmt> > block_stmts;\n+  bool block_did_terminate = false;\n+\n+  for (auto &s : expr.get_statements ())\n+    {\n+      if (s->get_ast_kind () == AST::Kind::MACRO_RULES_DEFINITION)\n+\tcontinue;\n+\n+      if (s->get_ast_kind () == AST::Kind::MACRO_INVOCATION)\n+\trust_fatal_error (\n+\t  s->get_locus (),\n+\t  \"macro invocations should not get lowered to HIR - At \"\n+\t  \"this point in \"\n+\t  \"the pipeline, they should all have been expanded\");\n+\n+      if (block_did_terminate)\n+\trust_warning_at (s->get_locus (), 0, \"unreachable statement\");\n+\n+      bool terminated = false;\n+      auto translated_stmt = ASTLoweringStmt::translate (s.get (), &terminated);\n+      block_stmts.push_back (std::unique_ptr<HIR::Stmt> (translated_stmt));\n+      block_did_terminate |= terminated;\n+    }\n+\n+  if (expr.has_tail_expr () && block_did_terminate)\n+    {\n+      // warning unreachable tail expressions\n+      rust_warning_at (expr.get_tail_expr ()->get_locus (), 0,\n+\t\t       \"unreachable expression\");\n+    }\n+\n+  HIR::ExprWithoutBlock *tail_expr = nullptr;\n+  if (expr.has_tail_expr ())\n+    {\n+      bool terminated = false;\n+      tail_expr = (HIR::ExprWithoutBlock *)\n+\tASTLoweringExpr::translate (expr.get_tail_expr ().get (), &terminated);\n+      block_did_terminate |= terminated;\n+    }\n+\n+  bool tail_reachable = !block_did_terminate;\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+  translated\n+    = new HIR::BlockExpr (mapping, std::move (block_stmts),\n+\t\t\t  std::unique_ptr<HIR::ExprWithoutBlock> (tail_expr),\n+\t\t\t  tail_reachable, expr.get_inner_attrs (),\n+\t\t\t  expr.get_outer_attrs (), expr.get_start_locus (),\n+\t\t\t  expr.get_end_locus ());\n+\n+  terminated = block_did_terminate;\n+}\n+\n+void\n+ASTLoweringIfBlock::visit (AST::IfExpr &expr)\n+{\n+  bool ignored_terminated = false;\n+  HIR::Expr *condition\n+    = ASTLoweringExpr::translate (expr.get_condition_expr ().get (),\n+\t\t\t\t  &ignored_terminated);\n+  HIR::BlockExpr *block\n+    = ASTLoweringBlock::translate (expr.get_if_block ().get (),\n+\t\t\t\t   &ignored_terminated);\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated = new HIR::IfExpr (mapping, std::unique_ptr<HIR::Expr> (condition),\n+\t\t\t\tstd::unique_ptr<HIR::BlockExpr> (block),\n+\t\t\t\texpr.get_locus ());\n+}\n+\n+void\n+ASTLoweringIfBlock::visit (AST::IfExprConseqElse &expr)\n+{\n+  HIR::Expr *condition\n+    = ASTLoweringExpr::translate (expr.get_condition_expr ().get ());\n+\n+  bool if_block_terminated = false;\n+  bool else_block_termianted = false;\n+\n+  HIR::BlockExpr *if_block\n+    = ASTLoweringBlock::translate (expr.get_if_block ().get (),\n+\t\t\t\t   &if_block_terminated);\n+  HIR::BlockExpr *else_block\n+    = ASTLoweringBlock::translate (expr.get_else_block ().get (),\n+\t\t\t\t   &else_block_termianted);\n+\n+  terminated = if_block_terminated && else_block_termianted;\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::IfExprConseqElse (mapping,\n+\t\t\t\t std::unique_ptr<HIR::Expr> (condition),\n+\t\t\t\t std::unique_ptr<HIR::BlockExpr> (if_block),\n+\t\t\t\t std::unique_ptr<HIR::BlockExpr> (else_block),\n+\t\t\t\t expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringIfBlock::visit (AST::IfExprConseqIf &expr)\n+{\n+  HIR::Expr *condition\n+    = ASTLoweringExpr::translate (expr.get_condition_expr ().get ());\n+\n+  bool ignored_terminated = false;\n+  HIR::BlockExpr *block\n+    = ASTLoweringBlock::translate (expr.get_if_block ().get (),\n+\t\t\t\t   &ignored_terminated);\n+  HIR::IfExpr *conseq_if_expr\n+    = ASTLoweringIfBlock::translate (expr.get_conseq_if_expr ().get (),\n+\t\t\t\t     &ignored_terminated);\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::IfExprConseqIf (mapping, std::unique_ptr<HIR::Expr> (condition),\n+\t\t\t       std::unique_ptr<HIR::BlockExpr> (block),\n+\t\t\t       std::unique_ptr<HIR::IfExpr> (conseq_if_expr),\n+\t\t\t       expr.get_locus ());\n+}\n+\n+void\n+ASTLoweringIfLetBlock::visit (AST::IfLetExpr &expr)\n+{\n+  std::vector<std::unique_ptr<HIR::Pattern> > patterns;\n+  for (auto &pattern : expr.get_patterns ())\n+    {\n+      HIR::Pattern *ptrn = ASTLoweringPattern::translate (pattern.get ());\n+      patterns.push_back (std::unique_ptr<HIR::Pattern> (ptrn));\n+    }\n+  HIR::Expr *value_ptr\n+    = ASTLoweringExpr::translate (expr.get_value_expr ().get ());\n+\n+  bool ignored_terminated = false;\n+  HIR::BlockExpr *block\n+    = ASTLoweringBlock::translate (expr.get_if_block ().get (),\n+\t\t\t\t   &ignored_terminated);\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated = new HIR::IfLetExpr (mapping, std::move (patterns),\n+\t\t\t\t   std::unique_ptr<HIR::Expr> (value_ptr),\n+\t\t\t\t   std::unique_ptr<HIR::BlockExpr> (block),\n+\t\t\t\t   expr.get_locus ());\n+}\n+\n+// rust-ast-lower-struct-field-expr.h\n+\n+void\n+ASTLowerStructExprField::visit (AST::StructExprFieldIdentifierValue &field)\n+{\n+  HIR::Expr *value = ASTLoweringExpr::translate (field.get_value ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, field.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated = new HIR::StructExprFieldIdentifierValue (\n+    mapping, field.get_field_name (), std::unique_ptr<HIR::Expr> (value),\n+    field.get_locus ());\n+}\n+\n+void\n+ASTLowerStructExprField::visit (AST::StructExprFieldIndexValue &field)\n+{\n+  HIR::Expr *value = ASTLoweringExpr::translate (field.get_value ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, field.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::StructExprFieldIndexValue (mapping, field.get_index (),\n+\t\t\t\t\t  std::unique_ptr<HIR::Expr> (value),\n+\t\t\t\t\t  field.get_locus ());\n+}\n+\n+void\n+ASTLowerStructExprField::visit (AST::StructExprFieldIdentifier &field)\n+{\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, field.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::StructExprFieldIdentifier (mapping, field.get_field_name (),\n+\t\t\t\t\t  field.get_locus ());\n+}\n+\n+// rust-ast-lower-block.h\n+\n+void\n+ASTLoweringExprWithBlock::visit (AST::WhileLoopExpr &expr)\n+{\n+  HIR::BlockExpr *loop_block\n+    = ASTLoweringBlock::translate (expr.get_loop_block ().get (), &terminated);\n+\n+  HIR::LoopLabel loop_label = lower_loop_label (expr.get_loop_label ());\n+  HIR::Expr *loop_condition\n+    = ASTLoweringExpr::translate (expr.get_predicate_expr ().get (),\n+\t\t\t\t  &terminated);\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::WhileLoopExpr (mapping,\n+\t\t\t      std::unique_ptr<HIR::Expr> (loop_condition),\n+\t\t\t      std::unique_ptr<HIR::BlockExpr> (loop_block),\n+\t\t\t      expr.get_locus (), std::move (loop_label),\n+\t\t\t      expr.get_outer_attrs ());\n+}\n+\n+void\n+ASTLoweringExprWithBlock::visit (AST::ForLoopExpr &expr)\n+{\n+  HIR::BlockExpr *loop_block\n+    = ASTLoweringBlock::translate (expr.get_loop_block ().get (), &terminated);\n+  HIR::LoopLabel loop_label = lower_loop_label (expr.get_loop_label ());\n+  HIR::Expr *iterator_expr\n+    = ASTLoweringExpr::translate (expr.get_iterator_expr ().get (),\n+\t\t\t\t  &terminated);\n+  HIR::Pattern *loop_pattern\n+    = ASTLoweringPattern::translate (expr.get_pattern ().get ());\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::ForLoopExpr (mapping,\n+\t\t\t    std::unique_ptr<HIR::Pattern> (loop_pattern),\n+\t\t\t    std::unique_ptr<HIR::Expr> (iterator_expr),\n+\t\t\t    std::unique_ptr<HIR::BlockExpr> (loop_block),\n+\t\t\t    expr.get_locus (), std::move (loop_label),\n+\t\t\t    expr.get_outer_attrs ());\n+}\n+\n+void\n+ASTLoweringExprWithBlock::visit (AST::MatchExpr &expr)\n+{\n+  HIR::Expr *branch_value\n+    = ASTLoweringExpr::translate (expr.get_scrutinee_expr ().get ());\n+\n+  std::vector<HIR::MatchCase> match_arms;\n+  for (auto &match_case : expr.get_match_cases ())\n+    {\n+      HIR::Expr *kase_expr\n+\t= ASTLoweringExpr::translate (match_case.get_expr ().get ());\n+\n+      HIR::Expr *kase_guard_expr = nullptr;\n+      if (match_case.get_arm ().has_match_arm_guard ())\n+\t{\n+\t  kase_guard_expr = ASTLoweringExpr::translate (\n+\t    match_case.get_arm ().get_guard_expr ().get ());\n+\t}\n+\n+      std::vector<std::unique_ptr<HIR::Pattern> > match_arm_patterns;\n+      for (auto &pattern : match_case.get_arm ().get_patterns ())\n+\t{\n+\t  HIR::Pattern *ptrn = ASTLoweringPattern::translate (pattern.get ());\n+\t  match_arm_patterns.push_back (std::unique_ptr<HIR::Pattern> (ptrn));\n+\t}\n+\n+      HIR::MatchArm arm (std::move (match_arm_patterns), expr.get_locus (),\n+\t\t\t std::unique_ptr<HIR::Expr> (kase_guard_expr),\n+\t\t\t match_case.get_arm ().get_outer_attrs ());\n+\n+      auto crate_num = mappings->get_current_crate ();\n+      Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t     mappings->get_next_hir_id (crate_num),\n+\t\t\t\t     UNKNOWN_LOCAL_DEFID);\n+\n+      HIR::MatchCase kase (std::move (mapping), std::move (arm),\n+\t\t\t   std::unique_ptr<HIR::Expr> (kase_expr));\n+      match_arms.push_back (std::move (kase));\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated\n+    = new HIR::MatchExpr (mapping, std::unique_ptr<HIR::Expr> (branch_value),\n+\t\t\t  std::move (match_arms), expr.get_inner_attrs (),\n+\t\t\t  expr.get_outer_attrs (), expr.get_locus ());\n+}\n+\n+// rust-ast-lower-expr.h\n+\n+void\n+ASTLowerPathInExpression::visit (AST::PathInExpression &expr)\n+{\n+  std::vector<HIR::PathExprSegment> path_segments;\n+  auto &segments = expr.get_segments ();\n+  for (auto &s : segments)\n+    {\n+      path_segments.push_back (lower_path_expr_seg ((s)));\n+\n+      // insert the mappings for the segment\n+      HIR::PathExprSegment *lowered_seg = &path_segments.back ();\n+      mappings->insert_hir_path_expr_seg (lowered_seg);\n+    }\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated = new HIR::PathInExpression (mapping, std::move (path_segments),\n+\t\t\t\t\t  expr.get_locus (),\n+\t\t\t\t\t  expr.opening_scope_resolution ());\n+}\n+\n+HIR::QualifiedPathType\n+ASTLoweringBase::lower_qual_path_type (AST::QualifiedPathType &qualified_type)\n+{\n+  HIR::Type *type\n+    = ASTLoweringType::translate (qualified_type.get_type ().get ());\n+  HIR::TypePath *trait\n+    = qualified_type.has_as_clause ()\n+\t? ASTLowerTypePath::translate (qualified_type.get_as_type_path ())\n+\t: nullptr;\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, qualified_type.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  return HIR::QualifiedPathType (mapping, std::unique_ptr<HIR::Type> (type),\n+\t\t\t\t std::unique_ptr<HIR::TypePath> (trait),\n+\t\t\t\t qualified_type.get_locus ());\n+}\n+\n+void\n+ASTLowerQualPathInExpression::visit (AST::QualifiedPathInExpression &expr)\n+{\n+  HIR::QualifiedPathType qual_path_type\n+    = lower_qual_path_type (expr.get_qualified_path_type ());\n+\n+  std::vector<HIR::PathExprSegment> path_segments;\n+  auto &segments = expr.get_segments ();\n+  for (auto &s : segments)\n+    {\n+      path_segments.push_back (lower_path_expr_seg ((s)));\n+\n+      // insert the mappings for the segment\n+      HIR::PathExprSegment *lowered_seg = &path_segments.back ();\n+      mappings->insert_hir_path_expr_seg (lowered_seg);\n+    }\n+\n+  auto crate_num = mappings->get_current_crate ();\n+  Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n+\t\t\t\t mappings->get_next_hir_id (crate_num),\n+\t\t\t\t UNKNOWN_LOCAL_DEFID);\n+\n+  translated = new HIR::QualifiedPathInExpression (mapping, qual_path_type,\n+\t\t\t\t\t\t   std::move (path_segments),\n+\t\t\t\t\t\t   expr.get_locus (),\n+\t\t\t\t\t\t   expr.get_outer_attrs ());\n+}\n+} // namespace HIR\n+} // namespace Rust"}, {"sha": "e726b4b8282228e3eeeaf480686ffda527f291fb", "filename": "gcc/rust/hir/rust-ast-lower.h", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-ast-lower.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.h?ref=7999cf327de7b5bbea80046715eeb00c0755a08d", "patch": "@@ -0,0 +1,59 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_LOWER\n+#define RUST_HIR_LOWER\n+\n+#include \"rust-system.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-ast-visitor.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+/* Checks whether the name of a field already exists.  Returns true\n+   and produces an error if so.  */\n+bool\n+struct_field_name_exists (std::vector<HIR::StructField> &fields,\n+\t\t\t  HIR::StructField &new_field);\n+\n+/**\n+ * Lowers a Visibility from the AST into an HIR Visibility, desugaring it in\n+ * the process\n+ */\n+Visibility\n+translate_visibility (const AST::Visibility &vis);\n+\n+class ASTLowering\n+{\n+public:\n+  static std::unique_ptr<HIR::Crate> Resolve (AST::Crate &astCrate);\n+  ~ASTLowering ();\n+\n+private:\n+  ASTLowering (AST::Crate &astCrate);\n+  std::unique_ptr<HIR::Crate> go ();\n+\n+  AST::Crate &astCrate;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // RUST_HIR_LOWER"}, {"sha": "bb139a7c1b7abf80d461e8621664d2b6caae0fcc", "filename": "gcc/rust/hir/rust-hir-dump.cc", "status": "added", "additions": 521, "deletions": 0, "changes": 521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-hir-dump.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-hir-dump.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-hir-dump.cc?ref=7999cf327de7b5bbea80046715eeb00c0755a08d", "patch": "@@ -0,0 +1,521 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-hir-dump.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+Dump::Dump (std::ostream &stream) : stream (stream), indent (0) {}\n+\n+void\n+Dump::go (HIR::Crate &crate)\n+{\n+  stream << \"Crate\"\n+\t << \" \"\n+\t << \"{\" << std::endl;\n+  //\n+\n+  indent++;\n+  stream << std::string (indent, indent_char);\n+  stream << \"inner_attrs\"\n+\t << \":\"\n+\t << \" \"\n+\t << \"[\";\n+  for (auto &attr : crate.inner_attrs)\n+    stream << attr.as_string ();\n+  stream << \"]\"\n+\t << \",\" << std::endl;\n+  indent--;\n+\n+  indent++;\n+  stream << std::string (indent, indent_char);\n+  //\n+\n+  stream << \"items\"\n+\t << \":\"\n+\t << \" \"\n+\t << \"[\";\n+\n+  stream << std::string (indent, indent_char);\n+  for (const auto &item : crate.items)\n+    {\n+      stream << std::endl;\n+      item->accept_vis (*this);\n+    }\n+  stream << std::string (indent, indent_char);\n+  stream << \"]\"\n+\t << \",\" << std::endl;\n+  indent--;\n+  //\n+\n+  indent++;\n+  stream << std::string (indent, indent_char);\n+  stream << \"node_mappings\"\n+\t << \":\"\n+\t << \" \"\n+\t << \"[\";\n+  // TODO: print crate mapping attrs\n+  stream << \"]\" << std::endl;\n+  indent--;\n+\n+  stream << \"}\" << std::endl;\n+}\n+\n+void\n+Dump::visit (Lifetime &)\n+{}\n+void\n+Dump::visit (LifetimeParam &)\n+{}\n+void\n+Dump::visit (PathInExpression &)\n+{}\n+void\n+Dump::visit (TypePathSegment &)\n+{}\n+void\n+Dump::visit (TypePathSegmentGeneric &)\n+{}\n+void\n+Dump::visit (TypePathSegmentFunction &)\n+{}\n+void\n+Dump::visit (TypePath &)\n+{}\n+void\n+Dump::visit (QualifiedPathInExpression &)\n+{}\n+void\n+Dump::visit (QualifiedPathInType &)\n+{}\n+\n+void\n+Dump::visit (LiteralExpr &literal_expr)\n+{\n+  indent++;\n+  stream << std::string (indent, indent_char);\n+  stream << \"( \" + literal_expr.get_literal ().as_string () + \" (\"\n+\t      + literal_expr.get_mappings ().as_string () + \"))\";\n+  stream << \"\\n\";\n+}\n+void\n+Dump::visit (BorrowExpr &)\n+{}\n+void\n+Dump::visit (DereferenceExpr &)\n+{}\n+void\n+Dump::visit (ErrorPropagationExpr &)\n+{}\n+void\n+Dump::visit (NegationExpr &)\n+{}\n+void\n+Dump::visit (ArithmeticOrLogicalExpr &)\n+{}\n+void\n+Dump::visit (ComparisonExpr &)\n+{}\n+void\n+Dump::visit (LazyBooleanExpr &)\n+{}\n+void\n+Dump::visit (TypeCastExpr &)\n+{}\n+void\n+Dump::visit (AssignmentExpr &)\n+{}\n+void\n+Dump::visit (CompoundAssignmentExpr &)\n+{}\n+void\n+Dump::visit (GroupedExpr &)\n+{}\n+\n+void\n+Dump::visit (ArrayElemsValues &)\n+{}\n+void\n+Dump::visit (ArrayElemsCopied &)\n+{}\n+void\n+Dump::visit (ArrayExpr &)\n+{}\n+void\n+Dump::visit (ArrayIndexExpr &)\n+{}\n+void\n+Dump::visit (TupleExpr &)\n+{}\n+void\n+Dump::visit (TupleIndexExpr &)\n+{}\n+void\n+Dump::visit (StructExprStruct &)\n+{}\n+\n+void\n+Dump::visit (StructExprFieldIdentifier &)\n+{}\n+void\n+Dump::visit (StructExprFieldIdentifierValue &)\n+{}\n+\n+void\n+Dump::visit (StructExprFieldIndexValue &)\n+{}\n+void\n+Dump::visit (StructExprStructFields &)\n+{}\n+void\n+Dump::visit (StructExprStructBase &)\n+{}\n+\n+void\n+Dump::visit (CallExpr &)\n+{}\n+void\n+Dump::visit (MethodCallExpr &)\n+{}\n+void\n+Dump::visit (FieldAccessExpr &)\n+{}\n+void\n+Dump::visit (ClosureExprInner &)\n+{}\n+void\n+Dump::visit (BlockExpr &block_expr)\n+{\n+  stream << \"BlockExpr\"\n+\t << \":\"\n+\t << \" \"\n+\t << \"[\";\n+  indent++;\n+  // TODO: print statements\n+  // TODO: print tail expression if exists\n+  stream << \"]\";\n+  indent--;\n+}\n+void\n+Dump::visit (ClosureExprInnerTyped &)\n+{}\n+void\n+Dump::visit (ContinueExpr &)\n+{}\n+void\n+Dump::visit (BreakExpr &)\n+{}\n+void\n+Dump::visit (RangeFromToExpr &)\n+{}\n+void\n+Dump::visit (RangeFromExpr &)\n+{}\n+void\n+Dump::visit (RangeToExpr &)\n+{}\n+void\n+Dump::visit (RangeFullExpr &)\n+{}\n+void\n+Dump::visit (RangeFromToInclExpr &)\n+{}\n+void\n+Dump::visit (RangeToInclExpr &)\n+{}\n+void\n+Dump::visit (ReturnExpr &)\n+{}\n+void\n+Dump::visit (UnsafeBlockExpr &)\n+{}\n+void\n+Dump::visit (LoopExpr &)\n+{}\n+void\n+Dump::visit (WhileLoopExpr &)\n+{}\n+void\n+Dump::visit (WhileLetLoopExpr &)\n+{}\n+void\n+Dump::visit (ForLoopExpr &)\n+{}\n+void\n+Dump::visit (IfExpr &)\n+{}\n+void\n+Dump::visit (IfExprConseqElse &)\n+{}\n+void\n+Dump::visit (IfExprConseqIf &)\n+{}\n+void\n+Dump::visit (IfExprConseqIfLet &)\n+{}\n+void\n+Dump::visit (IfLetExpr &)\n+{}\n+void\n+Dump::visit (IfLetExprConseqElse &)\n+{}\n+void\n+Dump::visit (IfLetExprConseqIf &)\n+{}\n+void\n+Dump::visit (IfLetExprConseqIfLet &)\n+{}\n+\n+void\n+Dump::visit (MatchExpr &)\n+{}\n+void\n+Dump::visit (AwaitExpr &)\n+{}\n+void\n+Dump::visit (AsyncBlockExpr &)\n+{}\n+\n+void\n+Dump::visit (TypeParam &)\n+{}\n+\n+void\n+Dump::visit (ConstGenericParam &)\n+{}\n+\n+void\n+Dump::visit (LifetimeWhereClauseItem &)\n+{}\n+void\n+Dump::visit (TypeBoundWhereClauseItem &)\n+{}\n+void\n+Dump::visit (Module &)\n+{}\n+void\n+Dump::visit (ExternCrate &)\n+{}\n+\n+void\n+Dump::visit (UseTreeGlob &)\n+{}\n+void\n+Dump::visit (UseTreeList &)\n+{}\n+void\n+Dump::visit (UseTreeRebind &)\n+{}\n+void\n+Dump::visit (UseDeclaration &)\n+{}\n+void\n+Dump::visit (Function &function)\n+{\n+  indent++;\n+  stream << std::string (indent, indent_char);\n+  stream << \"Function\"\n+\t << \" \";\n+  stream << \"{\" << std::endl;\n+  // TODO: print function params\n+  stream << std::string (indent, indent_char);\n+  stream << \"}\" << std::endl;\n+  // TODO: get function definition and visit block\n+\n+  stream << std::endl;\n+  indent--;\n+}\n+void\n+Dump::visit (TypeAlias &)\n+{}\n+void\n+Dump::visit (StructStruct &)\n+{}\n+void\n+Dump::visit (TupleStruct &)\n+{}\n+void\n+Dump::visit (EnumItem &)\n+{}\n+void\n+Dump::visit (EnumItemTuple &)\n+{}\n+void\n+Dump::visit (EnumItemStruct &)\n+{}\n+void\n+Dump::visit (EnumItemDiscriminant &)\n+{}\n+void\n+Dump::visit (Enum &)\n+{}\n+void\n+Dump::visit (Union &)\n+{}\n+void\n+Dump::visit (ConstantItem &)\n+{}\n+void\n+Dump::visit (StaticItem &)\n+{}\n+void\n+Dump::visit (TraitItemFunc &)\n+{}\n+void\n+Dump::visit (TraitItemConst &)\n+{}\n+void\n+Dump::visit (TraitItemType &)\n+{}\n+void\n+Dump::visit (Trait &)\n+{}\n+void\n+Dump::visit (ImplBlock &)\n+{}\n+\n+void\n+Dump::visit (ExternalStaticItem &)\n+{}\n+void\n+Dump::visit (ExternalFunctionItem &)\n+{}\n+void\n+Dump::visit (ExternBlock &)\n+{}\n+\n+void\n+Dump::visit (LiteralPattern &)\n+{}\n+void\n+Dump::visit (IdentifierPattern &)\n+{}\n+void\n+Dump::visit (WildcardPattern &)\n+{}\n+\n+void\n+Dump::visit (RangePatternBoundLiteral &)\n+{}\n+void\n+Dump::visit (RangePatternBoundPath &)\n+{}\n+void\n+Dump::visit (RangePatternBoundQualPath &)\n+{}\n+void\n+Dump::visit (RangePattern &)\n+{}\n+void\n+Dump::visit (ReferencePattern &)\n+{}\n+\n+void\n+Dump::visit (StructPatternFieldTuplePat &)\n+{}\n+void\n+Dump::visit (StructPatternFieldIdentPat &)\n+{}\n+void\n+Dump::visit (StructPatternFieldIdent &)\n+{}\n+void\n+Dump::visit (StructPattern &)\n+{}\n+\n+void\n+Dump::visit (TupleStructItemsNoRange &)\n+{}\n+void\n+Dump::visit (TupleStructItemsRange &)\n+{}\n+void\n+Dump::visit (TupleStructPattern &)\n+{}\n+\n+void\n+Dump::visit (TuplePatternItemsMultiple &)\n+{}\n+void\n+Dump::visit (TuplePatternItemsRanged &)\n+{}\n+void\n+Dump::visit (TuplePattern &)\n+{}\n+void\n+Dump::visit (GroupedPattern &)\n+{}\n+void\n+Dump::visit (SlicePattern &)\n+{}\n+\n+void\n+Dump::visit (EmptyStmt &)\n+{}\n+void\n+Dump::visit (LetStmt &)\n+{}\n+void\n+Dump::visit (ExprStmtWithoutBlock &)\n+{}\n+void\n+Dump::visit (ExprStmtWithBlock &)\n+{}\n+\n+void\n+Dump::visit (TraitBound &)\n+{}\n+void\n+Dump::visit (ImplTraitType &)\n+{}\n+void\n+Dump::visit (TraitObjectType &)\n+{}\n+void\n+Dump::visit (ParenthesisedType &)\n+{}\n+void\n+Dump::visit (ImplTraitTypeOneBound &)\n+{}\n+void\n+Dump::visit (TupleType &)\n+{}\n+void\n+Dump::visit (NeverType &)\n+{}\n+void\n+Dump::visit (RawPointerType &)\n+{}\n+void\n+Dump::visit (ReferenceType &)\n+{}\n+void\n+Dump::visit (ArrayType &)\n+{}\n+void\n+Dump::visit (SliceType &)\n+{}\n+void\n+Dump::visit (InferredType &)\n+{}\n+void\n+Dump::visit (BareFunctionType &)\n+{}\n+} // namespace HIR\n+} // namespace Rust"}, {"sha": "8b9e8939a282648bbb9ce76de1cb3fd2fd7ecdb8", "filename": "gcc/rust/hir/rust-hir-dump.h", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-hir-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7999cf327de7b5bbea80046715eeb00c0755a08d/gcc%2Frust%2Fhir%2Frust-hir-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-hir-dump.h?ref=7999cf327de7b5bbea80046715eeb00c0755a08d", "patch": "@@ -0,0 +1,193 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_DUMP_H\n+#define RUST_HIR_DUMP_H\n+\n+#include \"rust-hir-visitor.h\"\n+#include \"rust-hir.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace HIR {\n+\n+class Dump : public HIRFullVisitor\n+{\n+public:\n+  Dump (std::ostream &stream);\n+  void go (HIR::Crate &crate);\n+\n+private:\n+  std::ostream &stream;\n+  std::size_t indent; // current indentation level\n+  char indent_char = '\\t';\n+\n+  virtual void visit (Lifetime &) override;\n+  virtual void visit (LifetimeParam &) override;\n+  virtual void visit (PathInExpression &) override;\n+  virtual void visit (TypePathSegment &) override;\n+  virtual void visit (TypePathSegmentGeneric &) override;\n+  virtual void visit (TypePathSegmentFunction &) override;\n+  virtual void visit (TypePath &) override;\n+  virtual void visit (QualifiedPathInExpression &) override;\n+  virtual void visit (QualifiedPathInType &) override;\n+\n+  virtual void visit (LiteralExpr &) override;\n+  virtual void visit (BorrowExpr &) override;\n+  virtual void visit (DereferenceExpr &) override;\n+  virtual void visit (ErrorPropagationExpr &) override;\n+  virtual void visit (NegationExpr &) override;\n+  virtual void visit (ArithmeticOrLogicalExpr &) override;\n+  virtual void visit (ComparisonExpr &) override;\n+  virtual void visit (LazyBooleanExpr &) override;\n+  virtual void visit (TypeCastExpr &) override;\n+  virtual void visit (AssignmentExpr &) override;\n+  virtual void visit (CompoundAssignmentExpr &) override;\n+  virtual void visit (GroupedExpr &) override;\n+\n+  virtual void visit (ArrayElemsValues &) override;\n+  virtual void visit (ArrayElemsCopied &) override;\n+  virtual void visit (ArrayExpr &) override;\n+  virtual void visit (ArrayIndexExpr &) override;\n+  virtual void visit (TupleExpr &) override;\n+  virtual void visit (TupleIndexExpr &) override;\n+  virtual void visit (StructExprStruct &) override;\n+\n+  virtual void visit (StructExprFieldIdentifier &) override;\n+  virtual void visit (StructExprFieldIdentifierValue &) override;\n+\n+  virtual void visit (StructExprFieldIndexValue &) override;\n+  virtual void visit (StructExprStructFields &) override;\n+  virtual void visit (StructExprStructBase &) override;\n+\n+  virtual void visit (CallExpr &) override;\n+  virtual void visit (MethodCallExpr &) override;\n+  virtual void visit (FieldAccessExpr &) override;\n+  virtual void visit (ClosureExprInner &) override;\n+  virtual void visit (BlockExpr &) override;\n+  virtual void visit (ClosureExprInnerTyped &) override;\n+  virtual void visit (ContinueExpr &) override;\n+  virtual void visit (BreakExpr &) override;\n+  virtual void visit (RangeFromToExpr &) override;\n+  virtual void visit (RangeFromExpr &) override;\n+  virtual void visit (RangeToExpr &) override;\n+  virtual void visit (RangeFullExpr &) override;\n+  virtual void visit (RangeFromToInclExpr &) override;\n+  virtual void visit (RangeToInclExpr &) override;\n+  virtual void visit (ReturnExpr &) override;\n+  virtual void visit (UnsafeBlockExpr &) override;\n+  virtual void visit (LoopExpr &) override;\n+  virtual void visit (WhileLoopExpr &) override;\n+  virtual void visit (WhileLetLoopExpr &) override;\n+  virtual void visit (ForLoopExpr &) override;\n+  virtual void visit (IfExpr &) override;\n+  virtual void visit (IfExprConseqElse &) override;\n+  virtual void visit (IfExprConseqIf &) override;\n+  virtual void visit (IfExprConseqIfLet &) override;\n+  virtual void visit (IfLetExpr &) override;\n+  virtual void visit (IfLetExprConseqElse &) override;\n+  virtual void visit (IfLetExprConseqIf &) override;\n+  virtual void visit (IfLetExprConseqIfLet &) override;\n+\n+  virtual void visit (MatchExpr &) override;\n+  virtual void visit (AwaitExpr &) override;\n+  virtual void visit (AsyncBlockExpr &) override;\n+\n+  virtual void visit (TypeParam &) override;\n+  virtual void visit (ConstGenericParam &) override;\n+\n+  virtual void visit (LifetimeWhereClauseItem &) override;\n+  virtual void visit (TypeBoundWhereClauseItem &) override;\n+  virtual void visit (Module &) override;\n+  virtual void visit (ExternCrate &) override;\n+\n+  virtual void visit (UseTreeGlob &) override;\n+  virtual void visit (UseTreeList &) override;\n+  virtual void visit (UseTreeRebind &) override;\n+  virtual void visit (UseDeclaration &) override;\n+  virtual void visit (Function &) override;\n+  virtual void visit (TypeAlias &) override;\n+  virtual void visit (StructStruct &) override;\n+  virtual void visit (TupleStruct &) override;\n+  virtual void visit (EnumItem &) override;\n+  virtual void visit (EnumItemTuple &) override;\n+  virtual void visit (EnumItemStruct &) override;\n+  virtual void visit (EnumItemDiscriminant &) override;\n+  virtual void visit (Enum &) override;\n+  virtual void visit (Union &) override;\n+  virtual void visit (ConstantItem &) override;\n+  virtual void visit (StaticItem &) override;\n+  virtual void visit (TraitItemFunc &) override;\n+  virtual void visit (TraitItemConst &) override;\n+  virtual void visit (TraitItemType &) override;\n+  virtual void visit (Trait &) override;\n+  virtual void visit (ImplBlock &) override;\n+\n+  virtual void visit (ExternalStaticItem &) override;\n+  virtual void visit (ExternalFunctionItem &) override;\n+  virtual void visit (ExternBlock &) override;\n+\n+  virtual void visit (LiteralPattern &) override;\n+  virtual void visit (IdentifierPattern &) override;\n+  virtual void visit (WildcardPattern &) override;\n+\n+  virtual void visit (RangePatternBoundLiteral &) override;\n+  virtual void visit (RangePatternBoundPath &) override;\n+  virtual void visit (RangePatternBoundQualPath &) override;\n+  virtual void visit (RangePattern &) override;\n+  virtual void visit (ReferencePattern &) override;\n+\n+  virtual void visit (StructPatternFieldTuplePat &) override;\n+  virtual void visit (StructPatternFieldIdentPat &) override;\n+  virtual void visit (StructPatternFieldIdent &) override;\n+  virtual void visit (StructPattern &) override;\n+\n+  virtual void visit (TupleStructItemsNoRange &) override;\n+  virtual void visit (TupleStructItemsRange &) override;\n+  virtual void visit (TupleStructPattern &) override;\n+\n+  virtual void visit (TuplePatternItemsMultiple &) override;\n+  virtual void visit (TuplePatternItemsRanged &) override;\n+  virtual void visit (TuplePattern &) override;\n+  virtual void visit (GroupedPattern &) override;\n+  virtual void visit (SlicePattern &) override;\n+\n+  virtual void visit (EmptyStmt &) override;\n+  virtual void visit (LetStmt &) override;\n+  virtual void visit (ExprStmtWithoutBlock &) override;\n+  virtual void visit (ExprStmtWithBlock &) override;\n+\n+  virtual void visit (TraitBound &) override;\n+  virtual void visit (ImplTraitType &) override;\n+  virtual void visit (TraitObjectType &) override;\n+  virtual void visit (ParenthesisedType &) override;\n+  virtual void visit (ImplTraitTypeOneBound &) override;\n+  virtual void visit (TupleType &) override;\n+  virtual void visit (NeverType &) override;\n+  virtual void visit (RawPointerType &) override;\n+  virtual void visit (ReferenceType &) override;\n+  virtual void visit (ArrayType &) override;\n+  virtual void visit (SliceType &) override;\n+  virtual void visit (InferredType &) override;\n+  virtual void visit (BareFunctionType &) override;\n+};\n+\n+} // namespace HIR\n+} // namespace Rust\n+\n+#endif // !RUST_HIR_DUMP_H"}]}