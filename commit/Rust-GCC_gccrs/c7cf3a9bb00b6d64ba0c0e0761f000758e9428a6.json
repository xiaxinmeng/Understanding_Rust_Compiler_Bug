{"sha": "c7cf3a9bb00b6d64ba0c0e0761f000758e9428a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdjZjNhOWJiMDBiNmQ2NGJhMGMwZTA3NjFmMDAwNzU4ZTk0MjhhNg==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2019-08-15T10:45:41Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2019-08-15T10:45:41Z"}, "message": "Enforce canonicalization in value_range.\n\nFrom-SVN: r274525", "tree": {"sha": "27fdae692670f7c23fb207aee69b134a4ec73128", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/27fdae692670f7c23fb207aee69b134a4ec73128"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7cf3a9bb00b6d64ba0c0e0761f000758e9428a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7cf3a9bb00b6d64ba0c0e0761f000758e9428a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7cf3a9bb00b6d64ba0c0e0761f000758e9428a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7cf3a9bb00b6d64ba0c0e0761f000758e9428a6/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eb2211e35713796c5899939d983d9e8c6d037e60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb2211e35713796c5899939d983d9e8c6d037e60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb2211e35713796c5899939d983d9e8c6d037e60"}], "stats": {"total": 346, "additions": 247, "deletions": 99}, "files": [{"sha": "4f9f044aea6684207e8ab9ae3a62cb22eb12e3f6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7cf3a9bb00b6d64ba0c0e0761f000758e9428a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7cf3a9bb00b6d64ba0c0e0761f000758e9428a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7cf3a9bb00b6d64ba0c0e0761f000758e9428a6", "patch": "@@ -1,3 +1,37 @@\n+2019-08-15  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* tree-vrp.c (value_range_base::set): Merge in code from\n+\tvalue_range_base::set_and_canonicalize.\n+\tEnforce canonicalization at set time.\n+\tNormalize [MIN, MAX] into VARYING and ~[MIN, MAX] into UNDEFINED.\n+\t(value_range_base::set_undefined): Inline call to set().\n+\t(value_range_base::set_varying): Same.\n+\t(value_range_base::singleton_p): Handle VR_ANTI_RANGEs.\n+\t(vrp_val_max): New argument handle_pointers.\n+\t(vrp_val_min): Same.\n+\t(ranges_from_anti_range): Same.\n+\t(extract_range_into_wide_ints): Use tree argument instead of sign\n+\tand precision.\n+\t(extract_range_from_multiplicative_op): Take in tree type instead\n+\tof precision and sign.  Adapt function for canonicalized ranges.\n+\t(extract_range_from_binary_expr): Pass type to\n+\textract_range_from_multiplicative_op.\n+\tAdapt for canonicalized ranges.\n+\t(extract_range_from_unary_expr): Same.\n+\t(value_range_base::intersect_helper): Adjust for canonicalized\n+\tranges.\n+\t(value_range_base::union_helper): Same.\n+\t(value_range_base::normalize_symbolics): New.\n+\t* tree-vrp.h (class value_range_base): Remove\n+\tset_and_canonicalize.\n+\tNew prototype for normalize_symbolics.\n+\t(class value_range): Remove set_and_canonicalize.\n+\t(vrp_val_min): Adjust prototype.\n+\t(vrp_val_max): Same.\n+\t* vr-values.c\n+\t(vr_values::extract_range_for_var_from_comparison_expr):  Call set\n+\tinstead of set_and_canonicalize.\n+\n 2019-08-15  Richard Sandiford  <richard.sandiford@arm.com>\n \n \tPR middle-end/91444"}, {"sha": "77e7594eee51654f333a96a2b3efca05f5c6d643", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 206, "deletions": 92, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7cf3a9bb00b6d64ba0c0e0761f000758e9428a6/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7cf3a9bb00b6d64ba0c0e0761f000758e9428a6/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=c7cf3a9bb00b6d64ba0c0e0761f000758e9428a6", "patch": "@@ -69,23 +69,20 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"wide-int-range.h\"\n \n+static bool\n+ranges_from_anti_range (const value_range_base *ar,\n+\t\t\tvalue_range_base *vr0, value_range_base *vr1,\n+\t\t\tbool handle_pointers = false);\n+\n /* Set of SSA names found live during the RPO traversal of the function\n    for still active basic-blocks.  */\n static sbitmap *live;\n \n-void\n-value_range_base::set (enum value_range_kind kind, tree min, tree max)\n-{\n-  m_kind = kind;\n-  m_min = min;\n-  m_max = max;\n-  if (flag_checking)\n-    check ();\n-}\n-\n void\n value_range::set_equiv (bitmap equiv)\n {\n+  if (undefined_p () || varying_p ())\n+    equiv = NULL;\n   /* Since updating the equivalence set involves deep copying the\n      bitmaps, only do it if absolutely necessary.\n \n@@ -261,7 +258,8 @@ value_range_base::constant_p () const\n void\n value_range_base::set_undefined ()\n {\n-  set (VR_UNDEFINED, NULL, NULL);\n+  m_kind = VR_UNDEFINED;\n+  m_min = m_max = NULL;\n }\n \n void\n@@ -273,7 +271,8 @@ value_range::set_undefined ()\n void\n value_range_base::set_varying ()\n {\n-  set (VR_VARYING, NULL, NULL);\n+  m_kind = VR_VARYING;\n+  m_min = m_max = NULL;\n }\n \n void\n@@ -324,6 +323,24 @@ value_range::equiv_add (const_tree var,\n bool\n value_range_base::singleton_p (tree *result) const\n {\n+  if (m_kind == VR_ANTI_RANGE)\n+    {\n+      if (nonzero_p ())\n+\t{\n+\t  if (TYPE_PRECISION (type ()) == 1)\n+\t    {\n+\t      if (result)\n+\t\t*result = m_max;\n+\t      return true;\n+\t    }\n+\t  return false;\n+\t}\n+\n+      value_range_base vr0, vr1;\n+      return (ranges_from_anti_range (this, &vr0, &vr1, true)\n+\t      && vr1.undefined_p ()\n+\t      && vr0.singleton_p (result));\n+    }\n   if (m_kind == VR_RANGE\n       && vrp_operand_equal_p (min (), max ())\n       && is_gimple_min_invariant (min ()))\n@@ -499,23 +516,28 @@ static assert_locus **asserts_for;\n /* Return the maximum value for TYPE.  */\n \n tree\n-vrp_val_max (const_tree type)\n+vrp_val_max (const_tree type, bool handle_pointers)\n {\n-  if (!INTEGRAL_TYPE_P (type))\n-    return NULL_TREE;\n-\n-  return TYPE_MAX_VALUE (type);\n+  if (INTEGRAL_TYPE_P (type))\n+    return TYPE_MAX_VALUE (type);\n+  if (POINTER_TYPE_P (type) && handle_pointers)\n+    {\n+      wide_int max = wi::max_value (TYPE_PRECISION (type), TYPE_SIGN (type));\n+      return wide_int_to_tree (const_cast<tree> (type), max);\n+    }\n+  return NULL_TREE;\n }\n \n /* Return the minimum value for TYPE.  */\n \n tree\n-vrp_val_min (const_tree type)\n+vrp_val_min (const_tree type, bool handle_pointers)\n {\n-  if (!INTEGRAL_TYPE_P (type))\n-    return NULL_TREE;\n-\n-  return TYPE_MIN_VALUE (type);\n+  if (INTEGRAL_TYPE_P (type))\n+    return TYPE_MIN_VALUE (type);\n+  if (POINTER_TYPE_P (type) && handle_pointers)\n+    return build_zero_cst (const_cast<tree> (type));\n+  return NULL_TREE;\n }\n \n /* Return whether VAL is equal to the maximum value of its type.\n@@ -626,8 +648,7 @@ intersect_range_with_nonzero_bits (enum value_range_kind vr_type,\n    extract ranges from var + CST op limit.  */\n \n void\n-value_range_base::set_and_canonicalize (enum value_range_kind kind,\n-\t\t\t\t\ttree min, tree max)\n+value_range_base::set (enum value_range_kind kind, tree min, tree max)\n {\n   /* Use the canonical setters for VR_UNDEFINED and VR_VARYING.  */\n   if (kind == VR_UNDEFINED)\n@@ -645,7 +666,9 @@ value_range_base::set_and_canonicalize (enum value_range_kind kind,\n   if (TREE_CODE (min) != INTEGER_CST\n       || TREE_CODE (max) != INTEGER_CST)\n     {\n-      set (kind, min, max);\n+      m_kind = kind;\n+      m_min = min;\n+      m_max = max;\n       return;\n     }\n \n@@ -681,12 +704,13 @@ value_range_base::set_and_canonicalize (enum value_range_kind kind,\n       kind = kind == VR_RANGE ? VR_ANTI_RANGE : VR_RANGE;\n     }\n \n+  tree type = TREE_TYPE (min);\n+\n   /* Anti-ranges that can be represented as ranges should be so.  */\n   if (kind == VR_ANTI_RANGE)\n     {\n       /* For -fstrict-enums we may receive out-of-range ranges so consider\n          values < -INF and values > INF as -INF/INF as well.  */\n-      tree type = TREE_TYPE (min);\n       bool is_min = (INTEGRAL_TYPE_P (type)\n \t\t     && tree_int_cst_compare (min, TYPE_MIN_VALUE (type)) <= 0);\n       bool is_max = (INTEGRAL_TYPE_P (type)\n@@ -729,22 +753,37 @@ value_range_base::set_and_canonicalize (enum value_range_kind kind,\n         }\n     }\n \n+  /* Normalize [MIN, MAX] into VARYING and ~[MIN, MAX] into UNDEFINED.\n+\n+     Avoid using TYPE_{MIN,MAX}_VALUE because -fstrict-enums can\n+     restrict those to a subset of what actually fits in the type.\n+     Instead use the extremes of the type precision which will allow\n+     compare_range_with_value() to check if a value is inside a range,\n+     whereas if we used TYPE_*_VAL, said function would just punt\n+     upon seeing a VARYING.  */\n+  unsigned prec = TYPE_PRECISION (type);\n+  signop sign = TYPE_SIGN (type);\n+  if (wi::eq_p (wi::to_wide (min), wi::min_value (prec, sign))\n+      && wi::eq_p (wi::to_wide (max), wi::max_value (prec, sign)))\n+    {\n+      if (kind == VR_RANGE)\n+\tset_varying ();\n+      else if (kind == VR_ANTI_RANGE)\n+\tset_undefined ();\n+      else\n+\tgcc_unreachable ();\n+      return;\n+    }\n+\n   /* Do not drop [-INF(OVF), +INF(OVF)] to varying.  (OVF) has to be sticky\n      to make sure VRP iteration terminates, otherwise we can get into\n      oscillations.  */\n \n-  set (kind, min, max);\n-}\n-\n-void\n-value_range::set_and_canonicalize (enum value_range_kind kind,\n-\t\t\t\t   tree min, tree max, bitmap equiv)\n-{\n-  value_range_base::set_and_canonicalize (kind, min, max);\n-  if (this->kind () == VR_RANGE || this->kind () == VR_ANTI_RANGE)\n-    set_equiv (equiv);\n-  else\n-    equiv_clear ();\n+  m_kind = kind;\n+  m_min = min;\n+  m_max = max;\n+  if (flag_checking)\n+    check ();\n }\n \n void\n@@ -1180,7 +1219,8 @@ vrp_set_zero_nonzero_bits (const tree expr_type,\n \n static bool\n ranges_from_anti_range (const value_range_base *ar,\n-\t\t\tvalue_range_base *vr0, value_range_base *vr1)\n+\t\t\tvalue_range_base *vr0, value_range_base *vr1,\n+\t\t\tbool handle_pointers)\n {\n   tree type = ar->type ();\n \n@@ -1193,18 +1233,18 @@ ranges_from_anti_range (const value_range_base *ar,\n   if (ar->kind () != VR_ANTI_RANGE\n       || TREE_CODE (ar->min ()) != INTEGER_CST\n       || TREE_CODE (ar->max ()) != INTEGER_CST\n-      || !vrp_val_min (type)\n-      || !vrp_val_max (type))\n+      || !vrp_val_min (type, handle_pointers)\n+      || !vrp_val_max (type, handle_pointers))\n     return false;\n \n-  if (tree_int_cst_lt (vrp_val_min (type), ar->min ()))\n+  if (tree_int_cst_lt (vrp_val_min (type, handle_pointers), ar->min ()))\n     vr0->set (VR_RANGE,\n-\t      vrp_val_min (type),\n+\t      vrp_val_min (type, handle_pointers),\n \t      wide_int_to_tree (type, wi::to_wide (ar->min ()) - 1));\n-  if (tree_int_cst_lt (ar->max (), vrp_val_max (type)))\n+  if (tree_int_cst_lt (ar->max (), vrp_val_max (type, handle_pointers)))\n     vr1->set (VR_RANGE,\n \t      wide_int_to_tree (type, wi::to_wide (ar->max ()) + 1),\n-\t      vrp_val_max (type));\n+\t      vrp_val_max (type, handle_pointers));\n   if (vr0->undefined_p ())\n     {\n       *vr0 = *vr1;\n@@ -1215,21 +1255,20 @@ ranges_from_anti_range (const value_range_base *ar,\n }\n \n /* Extract the components of a value range into a pair of wide ints in\n-   [WMIN, WMAX].\n-\n-   If the value range is anything but a VR_*RANGE of constants, the\n-   resulting wide ints are set to [-MIN, +MAX] for the type.  */\n+   [WMIN, WMAX], after having normalized any symbolics from the input.  */\n \n static void inline\n-extract_range_into_wide_ints (const value_range_base *vr,\n-\t\t\t      signop sign, unsigned prec,\n-\t\t\t      wide_int &wmin, wide_int &wmax)\n+extract_range_into_wide_ints (const value_range_base *vr_,\n+\t\t\t      tree type, wide_int &wmin, wide_int &wmax)\n {\n-  gcc_assert (vr->kind () != VR_ANTI_RANGE || vr->symbolic_p ());\n-  if (range_int_cst_p (vr))\n+  signop sign = TYPE_SIGN (type);\n+  unsigned int prec = TYPE_PRECISION (type);\n+  gcc_assert (vr_->kind () != VR_ANTI_RANGE || vr_->symbolic_p ());\n+  value_range vr = vr_->normalize_symbolics ();\n+  if (range_int_cst_p (&vr))\n     {\n-      wmin = wi::to_wide (vr->min ());\n-      wmax = wi::to_wide (vr->max ());\n+      wmin = wi::to_wide (vr.min ());\n+      wmax = wi::to_wide (vr.max ());\n     }\n   else\n     {\n@@ -1256,12 +1295,31 @@ extract_range_from_multiplicative_op (value_range_base *vr,\n \t      || code == ROUND_DIV_EXPR\n \t      || code == RSHIFT_EXPR\n \t      || code == LSHIFT_EXPR);\n-  gcc_assert (vr0->kind () == VR_RANGE\n-\t      && vr0->kind () == vr1->kind ());\n+  if (!range_int_cst_p (vr1))\n+    {\n+      vr->set_varying ();\n+      return;\n+    }\n+\n+  /* Even if vr0 is VARYING or otherwise not usable, we can derive\n+     useful ranges just from the shift count.  E.g.\n+     x >> 63 for signed 64-bit x is always [-1, 0].  */\n+  value_range_base tem = vr0->normalize_symbolics ();\n+  tree vr0_min, vr0_max;\n+  if (tem.kind () == VR_RANGE)\n+    {\n+      vr0_min = tem.min ();\n+      vr0_max = tem.max ();\n+    }\n+  else\n+    {\n+      vr0_min = vrp_val_min (type);\n+      vr0_max = vrp_val_max (type);\n+    }\n \n   wide_int res_lb, res_ub;\n-  wide_int vr0_lb = wi::to_wide (vr0->min ());\n-  wide_int vr0_ub = wi::to_wide (vr0->max ());\n+  wide_int vr0_lb = wi::to_wide (vr0_min);\n+  wide_int vr0_ub = wi::to_wide (vr0_max);\n   wide_int vr1_lb = wi::to_wide (vr1->min ());\n   wide_int vr1_ub = wi::to_wide (vr1->max ());\n   bool overflow_undefined = TYPE_OVERFLOW_UNDEFINED (type);\n@@ -1271,9 +1329,8 @@ extract_range_from_multiplicative_op (value_range_base *vr,\n \t\t\t\t\tcode, TYPE_SIGN (type), prec,\n \t\t\t\t\tvr0_lb, vr0_ub, vr1_lb, vr1_ub,\n \t\t\t\t\toverflow_undefined))\n-    vr->set_and_canonicalize (VR_RANGE,\n-\t\t\t      wide_int_to_tree (type, res_lb),\n-\t\t\t      wide_int_to_tree (type, res_ub));\n+    vr->set (VR_RANGE, wide_int_to_tree (type, res_lb),\n+\t     wide_int_to_tree (type, res_ub));\n   else\n     vr->set_varying ();\n }\n@@ -1667,19 +1724,30 @@ extract_range_from_binary_expr (value_range_base *vr,\n      range and see what we end up with.  */\n   if (code == PLUS_EXPR || code == MINUS_EXPR)\n     {\n+      value_range_kind vr0_kind = vr0.kind (), vr1_kind = vr1.kind ();\n+      tree vr0_min = vr0.min (), vr0_max = vr0.max ();\n+      tree vr1_min = vr1.min (), vr1_max = vr1.max ();\n       /* This will normalize things such that calculating\n \t [0,0] - VR_VARYING is not dropped to varying, but is\n \t calculated as [MIN+1, MAX].  */\n       if (vr0.varying_p ())\n-\tvr0.set (VR_RANGE, vrp_val_min (expr_type), vrp_val_max (expr_type));\n+\t{\n+\t  vr0_kind = VR_RANGE;\n+\t  vr0_min = vrp_val_min (expr_type);\n+\t  vr0_max = vrp_val_max (expr_type);\n+\t}\n       if (vr1.varying_p ())\n-\tvr1.set (VR_RANGE, vrp_val_min (expr_type), vrp_val_max (expr_type));\n+\t{\n+\t  vr1_kind = VR_RANGE;\n+\t  vr1_min = vrp_val_min (expr_type);\n+\t  vr1_max = vrp_val_max (expr_type);\n+\t}\n \n       const bool minus_p = (code == MINUS_EXPR);\n-      tree min_op0 = vr0.min ();\n-      tree min_op1 = minus_p ? vr1.max () : vr1.min ();\n-      tree max_op0 = vr0.max ();\n-      tree max_op1 = minus_p ? vr1.min () : vr1.max ();\n+      tree min_op0 = vr0_min;\n+      tree min_op1 = minus_p ? vr1_max : vr1_min;\n+      tree max_op0 = vr0_max;\n+      tree max_op1 = minus_p ? vr1_min : vr1_max;\n       tree sym_min_op0 = NULL_TREE;\n       tree sym_min_op1 = NULL_TREE;\n       tree sym_max_op0 = NULL_TREE;\n@@ -1692,7 +1760,7 @@ extract_range_from_binary_expr (value_range_base *vr,\n \t single-symbolic ranges, try to compute the precise resulting range,\n \t but only if we know that this resulting range will also be constant\n \t or single-symbolic.  */\n-      if (vr0.kind () == VR_RANGE && vr1.kind () == VR_RANGE\n+      if (vr0_kind == VR_RANGE && vr1_kind == VR_RANGE\n \t  && (TREE_CODE (min_op0) == INTEGER_CST\n \t      || (sym_min_op0\n \t\t  = get_single_symbol (min_op0, &neg_min_op0, &min_op0)))\n@@ -1772,8 +1840,8 @@ extract_range_from_binary_expr (value_range_base *vr,\n       wide_int wmin, wmax;\n       wide_int vr0_min, vr0_max;\n       wide_int vr1_min, vr1_max;\n-      extract_range_into_wide_ints (&vr0, sign, prec, vr0_min, vr0_max);\n-      extract_range_into_wide_ints (&vr1, sign, prec, vr1_min, vr1_max);\n+      extract_range_into_wide_ints (&vr0, expr_type, vr0_min, vr0_max);\n+      extract_range_into_wide_ints (&vr1, expr_type, vr1_min, vr1_max);\n       if (wide_int_range_min_max (wmin, wmax, code, sign, prec,\n \t\t\t\t  vr0_min, vr0_max, vr1_min, vr1_max))\n \tvr->set (VR_RANGE, wide_int_to_tree (expr_type, wmin),\n@@ -1805,12 +1873,6 @@ extract_range_from_binary_expr (value_range_base *vr,\n \t{\n \t  if (code == RSHIFT_EXPR)\n \t    {\n-\t      /* Even if vr0 is VARYING or otherwise not usable, we can derive\n-\t\t useful ranges just from the shift count.  E.g.\n-\t\t x >> 63 for signed 64-bit x is always [-1, 0].  */\n-\t      if (vr0.kind () != VR_RANGE || vr0.symbolic_p ())\n-\t\tvr0.set (VR_RANGE, vrp_val_min (expr_type),\n-\t\t\t vrp_val_max (expr_type));\n \t      extract_range_from_multiplicative_op (vr, code, expr_type,\n \t\t\t\t\t\t    &vr0, &vr1);\n \t      return;\n@@ -1828,7 +1890,7 @@ extract_range_from_binary_expr (value_range_base *vr,\n \t\t{\n \t\t  min = wide_int_to_tree (expr_type, res_lb);\n \t\t  max = wide_int_to_tree (expr_type, res_ub);\n-\t\t  vr->set_and_canonicalize (VR_RANGE, min, max);\n+\t\t  vr->set (VR_RANGE, min, max);\n \t\t  return;\n \t\t}\n \t    }\n@@ -1860,9 +1922,9 @@ extract_range_from_binary_expr (value_range_base *vr,\n \t NOTE: As a future improvement, we may be able to do better\n \t with mixed symbolic (anti-)ranges like [0, A].  See note in\n \t ranges_from_anti_range.  */\n-      extract_range_into_wide_ints (&vr0, sign, prec,\n+      extract_range_into_wide_ints (&vr0, expr_type,\n \t\t\t\t    dividend_min, dividend_max);\n-      extract_range_into_wide_ints (&vr1, sign, prec,\n+      extract_range_into_wide_ints (&vr1, expr_type,\n \t\t\t\t    divisor_min, divisor_max);\n       if (!wide_int_range_div (wmin, wmax, code, sign, prec,\n \t\t\t       dividend_min, dividend_max,\n@@ -1893,8 +1955,8 @@ extract_range_from_binary_expr (value_range_base *vr,\n \t}\n       wide_int wmin, wmax, tmp;\n       wide_int vr0_min, vr0_max, vr1_min, vr1_max;\n-      extract_range_into_wide_ints (&vr0, sign, prec, vr0_min, vr0_max);\n-      extract_range_into_wide_ints (&vr1, sign, prec, vr1_min, vr1_max);\n+      extract_range_into_wide_ints (&vr0, expr_type, vr0_min, vr0_max);\n+      extract_range_into_wide_ints (&vr1, expr_type, vr1_min, vr1_max);\n       wide_int_range_trunc_mod (wmin, wmax, sign, prec,\n \t\t\t\tvr0_min, vr0_max, vr1_min, vr1_max);\n       min = wide_int_to_tree (expr_type, wmin);\n@@ -1912,8 +1974,8 @@ extract_range_from_binary_expr (value_range_base *vr,\n \t\t\t\t &may_be_nonzero0, &must_be_nonzero0);\n       vrp_set_zero_nonzero_bits (expr_type, &vr1,\n \t\t\t\t &may_be_nonzero1, &must_be_nonzero1);\n-      extract_range_into_wide_ints (&vr0, sign, prec, vr0_min, vr0_max);\n-      extract_range_into_wide_ints (&vr1, sign, prec, vr1_min, vr1_max);\n+      extract_range_into_wide_ints (&vr0, expr_type, vr0_min, vr0_max);\n+      extract_range_into_wide_ints (&vr1, expr_type, vr1_min, vr1_max);\n       if (code == BIT_AND_EXPR)\n \t{\n \t  if (wide_int_range_bit_and (wmin, wmax, sign, prec,\n@@ -2117,16 +2179,15 @@ extract_range_from_unary_expr (value_range_base *vr,\n       signop outer_sign = TYPE_SIGN (outer_type);\n       unsigned inner_prec = TYPE_PRECISION (inner_type);\n       unsigned outer_prec = TYPE_PRECISION (outer_type);\n-      extract_range_into_wide_ints (&vr0, inner_sign, inner_prec,\n-\t\t\t\t    vr0_min, vr0_max);\n+      extract_range_into_wide_ints (&vr0, inner_type, vr0_min, vr0_max);\n       if (wide_int_range_convert (wmin, wmax,\n \t\t\t\t  inner_sign, inner_prec,\n \t\t\t\t  outer_sign, outer_prec,\n \t\t\t\t  vr0_min, vr0_max))\n \t{\n \t  tree min = wide_int_to_tree (outer_type, wmin);\n \t  tree max = wide_int_to_tree (outer_type, wmax);\n-\t  vr->set_and_canonicalize (VR_RANGE, min, max);\n+\t  vr->set (VR_RANGE, min, max);\n \t}\n       else\n \tvr->set_varying ();\n@@ -2136,7 +2197,7 @@ extract_range_from_unary_expr (value_range_base *vr,\n     {\n       wide_int wmin, wmax;\n       wide_int vr0_min, vr0_max;\n-      extract_range_into_wide_ints (&vr0, sign, prec, vr0_min, vr0_max);\n+      extract_range_into_wide_ints (&vr0, type, vr0_min, vr0_max);\n       if (wide_int_range_abs (wmin, wmax, sign, prec, vr0_min, vr0_max,\n \t\t\t      TYPE_OVERFLOW_UNDEFINED (type)))\n \tvr->set (VR_RANGE, wide_int_to_tree (type, wmin),\n@@ -2149,7 +2210,8 @@ extract_range_from_unary_expr (value_range_base *vr,\n     {\n       wide_int wmin, wmax;\n       wide_int vr0_min, vr0_max;\n-      extract_range_into_wide_ints (&vr0, SIGNED, prec, vr0_min, vr0_max);\n+      tree signed_type = make_signed_type (TYPE_PRECISION (type));\n+      extract_range_into_wide_ints (&vr0, signed_type, vr0_min, vr0_max);\n       wide_int_range_absu (wmin, wmax, prec, vr0_min, vr0_max);\n       vr->set (VR_RANGE, wide_int_to_tree (type, wmin),\n \t       wide_int_to_tree (type, wmax));\n@@ -6038,7 +6100,7 @@ value_range_base::intersect_helper (const value_range_base *vr0,\n      VR_RANGE can still be a VR_RANGE.  Work on a temporary so we can\n      fall back to vr0 when this turns things to varying.  */\n   value_range_base tem;\n-  tem.set_and_canonicalize (vr0type, vr0min, vr0max);\n+  tem.set (vr0type, vr0min, vr0max);\n   /* If that failed, use the saved original VR0.  */\n   if (tem.varying_p ())\n     return *vr0;\n@@ -6143,7 +6205,7 @@ value_range_base::union_helper (const value_range_base *vr0,\n \n   /* Work on a temporary so we can still use vr0 when union returns varying.  */\n   value_range_base tem;\n-  tem.set_and_canonicalize (vr0type, vr0min, vr0max);\n+  tem.set (vr0type, vr0min, vr0max);\n \n   /* Failed to find an efficient meet.  Before giving up and setting\n      the result to VARYING, see if we can at least derive a useful\n@@ -6223,6 +6285,58 @@ value_range::union_ (const value_range *other)\n     }\n }\n \n+/* Normalize symbolics into constants.  */\n+\n+value_range_base\n+value_range_base::normalize_symbolics () const\n+{\n+  if (varying_p () || undefined_p ())\n+    return *this;\n+  tree ttype = type ();\n+  bool min_symbolic = !is_gimple_min_invariant (min ());\n+  bool max_symbolic = !is_gimple_min_invariant (max ());\n+  if (!min_symbolic && !max_symbolic)\n+    return *this;\n+\n+  // [SYM, SYM] -> VARYING\n+  if (min_symbolic && max_symbolic)\n+    {\n+      value_range_base var;\n+      var.set_varying ();\n+      return var;\n+    }\n+  if (kind () == VR_RANGE)\n+    {\n+      // [SYM, NUM] -> [-MIN, NUM]\n+      if (min_symbolic)\n+\treturn value_range_base (VR_RANGE, vrp_val_min (ttype), max ());\n+      // [NUM, SYM] -> [NUM, +MAX]\n+      return value_range_base (VR_RANGE, min (), vrp_val_max (ttype));\n+    }\n+  gcc_assert (kind () == VR_ANTI_RANGE);\n+  // ~[SYM, NUM] -> [NUM + 1, +MAX]\n+  if (min_symbolic)\n+    {\n+      if (!vrp_val_is_max (max ()))\n+\t{\n+\t  tree n = wide_int_to_tree (ttype, wi::to_wide (max ()) + 1);\n+\t  return value_range_base (VR_RANGE, n, vrp_val_max (ttype));\n+\t}\n+      value_range_base var;\n+      var.set_varying ();\n+      return var;\n+    }\n+  // ~[NUM, SYM] -> [-MIN, NUM - 1]\n+  if (!vrp_val_is_min (min ()))\n+    {\n+      tree n = wide_int_to_tree (ttype, wi::to_wide (min ()) - 1);\n+      return value_range_base (VR_RANGE, vrp_val_min (ttype), n);\n+    }\n+  value_range_base var;\n+  var.set_varying ();\n+  return var;\n+}\n+\n /* Visit all arguments for PHI node PHI that flow through executable\n    edges.  If a valid value range can be derived from all the incoming\n    value ranges, set a new range for the LHS of PHI.  */"}, {"sha": "b5830851fcb8ee3ccf77dbf0fc3cf4ca6f4689b5", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7cf3a9bb00b6d64ba0c0e0761f000758e9428a6/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7cf3a9bb00b6d64ba0c0e0761f000758e9428a6/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=c7cf3a9bb00b6d64ba0c0e0761f000758e9428a6", "patch": "@@ -71,12 +71,13 @@ class GTY((for_user)) value_range_base\n   /* Misc methods.  */\n   tree type () const;\n   bool may_contain_p (tree) const;\n-  void set_and_canonicalize (enum value_range_kind, tree, tree);\n   bool zero_p () const;\n   bool nonzero_p () const;\n   bool singleton_p (tree *result = NULL) const;\n   void dump (FILE *) const;\n \n+  value_range_base normalize_symbolics () const;\n+\n protected:\n   void check ();\n   static value_range_base union_helper (const value_range_base *,\n@@ -143,7 +144,6 @@ class GTY((user)) value_range : public value_range_base\n \n   /* Misc methods.  */\n   void deep_copy (const value_range *);\n-  void set_and_canonicalize (enum value_range_kind, tree, tree, bitmap = NULL);\n   void dump (FILE *) const;\n \n  private:\n@@ -270,8 +270,8 @@ extern int operand_less_p (tree, tree);\n extern bool vrp_val_is_min (const_tree);\n extern bool vrp_val_is_max (const_tree);\n \n-extern tree vrp_val_min (const_tree);\n-extern tree vrp_val_max (const_tree);\n+extern tree vrp_val_min (const_tree, bool handle_pointers = false);\n+extern tree vrp_val_max (const_tree, bool handle_pointers = false);\n \n extern void extract_range_from_unary_expr (value_range_base *vr,\n \t\t\t\t\t   enum tree_code code,"}, {"sha": "a87cb672e36f43dd4a4494f75f27aed33592d489", "filename": "gcc/vr-values.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7cf3a9bb00b6d64ba0c0e0761f000758e9428a6/gcc%2Fvr-values.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7cf3a9bb00b6d64ba0c0e0761f000758e9428a6/gcc%2Fvr-values.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.c?ref=c7cf3a9bb00b6d64ba0c0e0761f000758e9428a6", "patch": "@@ -522,9 +522,9 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n          vice-versa.  Use set_and_canonicalize which does this for\n          us.  */\n       if (cond_code == LE_EXPR)\n-        vr_p->set_and_canonicalize (VR_RANGE, min, max, vr_p->equiv ());\n+        vr_p->set (VR_RANGE, min, max, vr_p->equiv ());\n       else if (cond_code == GT_EXPR)\n-        vr_p->set_and_canonicalize (VR_ANTI_RANGE, min, max, vr_p->equiv ());\n+        vr_p->set (VR_ANTI_RANGE, min, max, vr_p->equiv ());\n       else\n \tgcc_unreachable ();\n     }\n@@ -596,7 +596,7 @@ vr_values::extract_range_for_var_from_comparison_expr (tree var,\n \t  && vrp_val_is_max (max))\n \tmin = max = limit;\n \n-      vr_p->set_and_canonicalize (VR_ANTI_RANGE, min, max, vr_p->equiv ());\n+      vr_p->set (VR_ANTI_RANGE, min, max, vr_p->equiv ());\n     }\n   else if (cond_code == LE_EXPR || cond_code == LT_EXPR)\n     {"}]}