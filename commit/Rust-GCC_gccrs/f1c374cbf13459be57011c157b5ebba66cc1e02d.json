{"sha": "f1c374cbf13459be57011c157b5ebba66cc1e02d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFjMzc0Y2JmMTM0NTliZTU3MDExYzE1N2I1ZWJiYTY2Y2MxZTAyZA==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1998-10-20T03:18:57Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1998-10-20T03:18:57Z"}, "message": "c4x.c (c4x_parallel_process): Disable until BCT loop optimization stable for the C4x.\n\n\t* config/c4x/c4x.c (c4x_parallel_process): Disable until BCT\n\tloop optimization stable for the C4x.\n\t(c4x_rptb_info_t, c4x_dump, c4x_rptb_in_range, c4x_rptb_unjumped_loop,\n\tc4x_rptb_find_comp_and_jump, c4x_rptb_loop_info_get,\n\tc4x_rptb_emit_init, c4x_rptb_process): Deleted (superceded by BCT\n\tloop optimization).\n\t(c4x_address_conflict): Be more paranoid when packing a volatile\n\tmemref in a parallel load/store.\n\nFrom-SVN: r23196", "tree": {"sha": "ca3f61b370490f95a64414e52671e2b59bb7b0f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca3f61b370490f95a64414e52671e2b59bb7b0f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1c374cbf13459be57011c157b5ebba66cc1e02d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1c374cbf13459be57011c157b5ebba66cc1e02d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1c374cbf13459be57011c157b5ebba66cc1e02d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1c374cbf13459be57011c157b5ebba66cc1e02d/comments", "author": null, "committer": null, "parents": [{"sha": "95cb02033413e492b43f3d74192cf235d5a2c58c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95cb02033413e492b43f3d74192cf235d5a2c58c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95cb02033413e492b43f3d74192cf235d5a2c58c"}], "stats": {"total": 575, "additions": 21, "deletions": 554}, "files": [{"sha": "a532b2ab228d6444777211065e935495c18beadc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c374cbf13459be57011c157b5ebba66cc1e02d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c374cbf13459be57011c157b5ebba66cc1e02d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1c374cbf13459be57011c157b5ebba66cc1e02d", "patch": "@@ -1,3 +1,14 @@\n+Tue Oct 20 22:16:11 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x/c4x.c (c4x_parallel_process): Disable until BCT\n+\tloop optimization stable for the C4x.\n+\t(c4x_rptb_info_t, c4x_dump, c4x_rptb_in_range, c4x_rptb_unjumped_loop,\n+\tc4x_rptb_find_comp_and_jump, c4x_rptb_loop_info_get,\n+\tc4x_rptb_emit_init, c4x_rptb_process): Deleted (superceded by BCT\n+\tloop optimization).\n+\t(c4x_address_conflict): Be more paranoid when packing a volatile\n+\tmemref in a parallel load/store.\n+\n Tue Oct 20 21:56:05 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.md (repeat_block_top, repeat_block_end,"}, {"sha": "8de1fc0dc43393043e77d0c6c2a92e0216707acb", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 10, "deletions": 554, "changes": 564, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c374cbf13459be57011c157b5ebba66cc1e02d/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c374cbf13459be57011c157b5ebba66cc1e02d/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=f1c374cbf13459be57011c157b5ebba66cc1e02d", "patch": "@@ -132,22 +132,6 @@ enum machine_mode c4x_caller_save_map[FIRST_PSEUDO_REGISTER] =\n };\n \n \n-/* rptb_info has enough information to compute rtx for loop counter.  */\n-typedef struct\n-{\n-  int loop_count;\t\t/* Positive if loop count is constant */\n-  /* The rest of fields are meaningless if loop_count is set */\n-  rtx start_value;\t\t/* Starting value for biv */\n-  rtx end_value;\t\t/* Limit for biv */\n-  int swap_p;\t\t\t/* 1 for count down */\n-  int incr;\t\t\t/* Increment for biv -- must be constant */\n-  int shift;\t\t\t/* log2(incr) */\n-  int off_by_one;\t\t/* 1 for \"<\", 0 for \"<=\" */\n-  int unsigned_p;\t\t/* True if unsigned comparison at loop end */\n-  rtx loop_start;\n-}\n-c4x_rptb_info_t;\n-\n /* Test and compare insns in c4x.md store the information needed to\n    generate branch and scc insns here.  */\n \n@@ -167,29 +151,6 @@ tree pure_tree = NULL_TREE;\n tree noreturn_tree = NULL_TREE;\n tree interrupt_tree = NULL_TREE;\n \n-static void\n-c4x_dump (file, s)\n-     FILE * file;\n-     const char *s;\n-     ...\n-{\n-#ifndef __STDC__\n-  char *s;\n-#endif\n-  va_list ap;\n-\n-  if (!file)\n-    return;\n-\n-  VA_START (ap, s);\n-\n-#ifndef __STDC__\n-  s = va_arg (ap, char *);\n-#endif\n-\n-  vfprintf (file, s, ap);\n-  va_end (ap);\n-}\n \n /* Override command line options.\n    Called once after all options have been parsed.\n@@ -3204,14 +3165,9 @@ c4x_address_conflict (op0, op1, store0, store1)\n   if (!TARGET_DEVEL && base0 == base1 && (incdec0 || incdec1))\n     return 1;\n \n-  /* It is not worthwhile having parallel loads from the same address\n-     unless we could be sure that both locations were in internal\n-     memory.  We allow this for peepholes (after reload has completed\n-     since we are going to be executing two insns to the same address\n-     anyhow) but steer the combiner away from doing this since it seems\n-     to get the wrong idea.  */\n-  if (!store0 && !store1 && base0 == base1 && disp0 == disp1\n-      && !reload_completed)\n+  /* We can not optimize the case where op1 and op2 refer to the same\n+     address. */\n+  if (base0 == base1 && disp0 == disp1 && index0 == index1)\n     return 1;\n \n   /* No conflict.  */\n@@ -4623,8 +4579,14 @@ c4x_parallel_process (loop_start, loop_end)\n   if (!(loop_count_set = single_set (loop_count)))\n     return 0;\n \n+#if 0\n+  /* Disable this optimisation until REG_LOOP_COUNT note\n+     added.  */\n   if (!find_reg_note (loop_count, REG_LOOP_COUNT, NULL_RTX))\n     return 0;\n+#else\n+  return 0;\n+#endif\n \n   loop_count_reg = SET_DEST (loop_count_set);\n \t\t  \n@@ -4912,470 +4874,6 @@ c4x_combine_parallel (insns)\n }\n \n \n-/* True if INSN is between START and END.  If END precedes START\n-   something has gone awry.  */\n-\n-static int\n-c4x_rptb_in_range (insn, start, end)\n-     rtx insn, start, end;\n-{\n-  rtx this;\n-  \n-  for (this = start; ; this = NEXT_INSN (this))\n-    {\n-      if (this == insn)\n-\treturn 1;\n-      if (this == end)\n-\treturn 0;\n-      if (this == NULL_RTX)\n-\tfatal_insn (\"c4x_rptb_in_range: Repeat block error\", start);\n-    }\n-}\n-\n-\n-/* Returns true if there are no jumps crossing the loop boundary and\n-   no calls anywhere.  */  \n-\n-int\n-c4x_rptb_unjumped_loop_p (loop_start, loop_end)\n-     rtx loop_start, loop_end;\n-{\n-  rtx insn;\n-  rtx continue_label = NULL_RTX;\n-  rtx continue_note = NULL_RTX;\t/* Loop continue note if there is one.  */\n-\n-  /* Scan loop backwards.  */\n-  for (insn = PREV_INSN (loop_end); insn && insn != loop_start;\n-       insn = PREV_INSN (insn))\n-    {\n-      switch (GET_CODE (insn))\n-\t{\n-\tcase JUMP_INSN:\n-\t  {\n-\t    rtx jump_label = JUMP_LABEL (insn);\n-\n-\t    /* We don't like jumps out of the loop.  We also look\n-\t       for jumps to the end of loop, say from a continue\n-\t       statement.  */\n-\t    if (continue_note\n-\t\t&& jump_label == next_nonnote_insn (continue_note))\n-\t      continue_label = jump_label;\n-\t    else if (!c4x_rptb_in_range (jump_label, loop_start, \n-\t\t\t\t\t continue_note ? continue_note :\n-\t\t\t\t\t loop_end))\n-\t      return 0;\n-\t  }\n-\t  /* Fall through  */\n-\t  \n-\tcase INSN:\n-\t  if (0 && volatile_refs_p (PATTERN (insn)))\n-\t    {\n-\t      c4x_dump (loop_dump_stream, \n-\t\t\t\"Repeat block: Volatile memory ref within loop\\n\");\n-\t      return 0;\n-\t    }\n-\n-\t  /* The C4x movstrqi_large pattern clobbers RC, RE, RS.\n-\t     This should be generalised to check for insns that use\n-\t     these registers within the loop.  */\n-\t  if (recog_memoized (insn) == CODE_FOR_movstrqi_large)\n-\t    {\n-\t      c4x_dump (loop_dump_stream, \n-\t\t\t\"Repeat block: Memory copy within loop\\n\");\n-\t      return 0;\n-\t    }\n-\t  break;\n-\t  \n-\t  /* It is not worthwhile preserving the zero overhead loop\n-\t     context across calls.  */\n-\tcase CALL_INSN:\n-\t  /* We could allow a libcall with no side effects??? */\n-\t  c4x_dump (loop_dump_stream, \"Repeat block: Call within loop\\n\");\n-\t  return 0;\n-\t  \n-\tcase NOTE:\n-\t  switch (NOTE_LINE_NUMBER (insn))\n-\t    {\n-\t    case NOTE_INSN_LOOP_CONT:\n-\t      if (continue_note == NULL_RTX)\n-\t\tcontinue_note = insn;\n-\n-\t      /* Check for empty loop which would throw c4x_rptb_nop_p.\n-\t         GCC doesn't optimise empty loops away since user\n-\t         may be trying to implement a simple but crude delay.  */\n-\t      if (GET_CODE (PREV_INSN (insn)) == NOTE \n-\t\t  && NOTE_LINE_NUMBER (PREV_INSN (insn)) == NOTE_INSN_LOOP_BEG)\n-\t\t{\n-\t\t  c4x_dump (loop_dump_stream, \"Repeat block: Empty loop\\n\");\n-\t\t  return 0;\n-\t\t}\n-\t      break;\n-\n-\t      /* If we find a LOOP_END note, then we are not in the\n-\t         innermost loop.  */\n-\t    case NOTE_INSN_LOOP_END:\n-\t      return 0;\n-\n-\t    default:\n-\t      continue;\n-\t    }\n-\tdefault:\n-\t  continue;\n-\t}\n-    }\n-  if (insn == NULL_RTX)\n-    fatal(\"Repeat block: Inconsistent loop\");\n-\n-  c4x_dump (loop_dump_stream, \"Repeat block: Unjumped loop\\n\");\n-  if (continue_label)\n-    c4x_dump (loop_dump_stream, \"Repeat block: Continue_label %d\\n\",\n-\t      INSN_UID (continue_label));\n-  return 1;\n-}\n-\n-\n-/* Find and record in PCOMP and PJUMP the final comparison and jump\n-   insns of the loop specified by LOOP_END.  Return 1 if both have been\n-   found, otherwise return 0.  */\n-\n-static int\n-c4x_rptb_find_comp_and_jump (loop_end, pcomp, pjump)\n-     rtx loop_end;\n-     rtx *pcomp, *pjump;\n-{\n-  rtx final_comp, comp_pat;\n-  rtx final_jump = prev_nonnote_insn (loop_end);\n-\n-  if (!final_jump)\n-    return 0;\n-\n-  final_comp = PREV_INSN (final_jump);\n-  if (!final_comp)\n-    return 0;\n-\n-  if ((GET_CODE (final_comp) != INSN))\n-    return 0;\n-\n-  comp_pat = PATTERN (final_comp);\n-\n-  if ((GET_CODE (comp_pat) != SET)\n-      || GET_CODE (XEXP (comp_pat, 0)) != REG\n-      || REGNO (XEXP (comp_pat, 0)) != ST_REGNO)\n-    return 0;\n-\n-  *pcomp = final_comp;\n-  *pjump = final_jump;\n-  return 1;\n-}\n-\n-\n-/* Determine if the loop count is computable for a repeat loop.  */\n-\n-static int\n-c4x_rptb_loop_info_get (loop_start, loop_end, loop_info)\n-     rtx loop_start, loop_end;\n-     c4x_rptb_info_t *loop_info;\n-{\n-  rtx iteration_var, initial_value, increment, comparison;\n-  enum rtx_code cc;\t\t/* Comparison code */\n-  rtx comparison_value;\n-\n-  loop_info->loop_start = loop_start;\n-  loop_info->loop_count = loop_iterations (loop_start, loop_end);\n-\n-  /* If the number of loop cycles does not need calculating at\n-     run-time then things are easy... Note that the repeat count\n-     value must be a positive integer for the RPTB instruction.  If\n-     loop_count is zero then we don't have a constant count.  */\n-  if (loop_info->loop_count > 0)\n-    return 1;\n-  if (loop_info->loop_count < 0)\n-    {\n-      c4x_dump (loop_dump_stream, \"Repeat block: Negative loop count %d\\n\",\n-\t\tloop_info->loop_count);\n-      return 0;\n-    }\n-\n-  comparison = get_condition_for_loop (prev_nonnote_insn (loop_end));\n-  if (comparison == NULL_RTX)\n-    {\n-      c4x_dump (loop_dump_stream, \"Repeat block: Cannot find comparison\\n\");\n-      return 0;\n-    }\n-  cc = GET_CODE (comparison);\n-\n-  /* Only allow a register as the iteration value.  */\n-  iteration_var = XEXP (comparison, 0);\n-  if (GET_CODE (iteration_var) != REG)\n-    {\n-      c4x_dump (loop_dump_stream, \"Repeat block: Non reg. iteration value\\n\");\n-      return 0;\n-    }\n-\n-  c4x_dump (loop_dump_stream, \"Repeat block: Iteration value regno = %d\\n\",\n-\t    REGNO (iteration_var));\n-\n-  /* The comparison value must not change on the fly.  */\n-  comparison_value = XEXP (comparison, 1);\n-  if (!invariant_p (comparison_value))\n-    {\n-      c4x_dump (loop_dump_stream, \"Repeat block: Comparison value variant\\n\");\n-      return 0;\n-    }\n-\n-  /* This routine in unroll.c does the hard work of finding the\n-     initial value and increment for us.  Currently it won't find the\n-     intitial value or increment for do {} while; or while() {} do;\n-     loops.  This is because the iteration_var we find in the\n-     comparison insn is a GIV rather than a BIV and iteration_info does\n-     not like GIVs.  We could scan all the BIVs like check_dbra_loop()\n-     does...  */\n-\n-  iteration_info (iteration_var, &initial_value, &increment,\n-\t\t  loop_start, loop_end);\n-  if (initial_value == NULL_RTX || increment == NULL_RTX)\n-    {\n-      c4x_dump (loop_dump_stream, \"Repeat block: Cannot determine initial\"\n-\t\t\" value or increment\\n\");\n-      return 0;\n-    }\n-\n-  /* Only allow constant integer increment, not a variable.  */\n-  if (GET_CODE (increment) != CONST_INT)\n-    {\n-      c4x_dump (loop_dump_stream, \"Repeat block: Increment not constant\\n\");\n-      return 0;\n-    }\n-\n-  loop_info->incr = INTVAL (increment);\n-\n-  /* If the increment is not a power of 2, (i.e, 1, 2, 4, etc.) then\n-     we will need to emit a divide instruction rather than a right\n-     shift to calculate the loop count.  */\n-  if ((loop_info->shift = exact_log2 (abs (loop_info->incr))) < 0)\n-    {\n-      c4x_dump (loop_dump_stream, \"Repeat block: Increment not power of 2\\n\");\n-      return 0;\n-    }\n-\n-  /* The front end changes GT to NE for unsigned numbers, so we\n-     \"undo\" this here for clarity.  */\n-  loop_info->unsigned_p = 0;\n-  if (GET_CODE (increment) == CONST_INT\n-      && INTVAL (increment) == -1 && cc == NE)\n-    {\n-      loop_info->unsigned_p = 1;\n-      cc = GT;\n-    }\n-\n-  if (!(cc == LT || cc == LE || cc == LTU || cc == LEU\n-\t|| cc == GT || cc == GE || cc == GTU || cc == GEU))\n-    {\n-      c4x_dump (loop_dump_stream, \"Repeat block: Invalid comparison\\n\");\n-      return 0;\n-    }\n-\n-  loop_info->swap_p = (cc == GT || cc == GE || cc == GTU || cc == GEU);\n-  if (loop_info->swap_p)\n-    {\n-      loop_info->start_value = comparison_value;\n-      loop_info->end_value = initial_value;\n-      loop_info->incr = -loop_info->incr;\n-    }\n-  else\n-    {\n-      loop_info->start_value = initial_value;\n-      loop_info->end_value = comparison_value;\n-    }\n-\n-  /* Check if loop won't terminate?  */\n-  if (loop_info->incr <= 0)\n-    {\n-      c4x_dump (loop_dump_stream, \"Repeat block: Increment negative\\n\");\n-      return 0;\n-    }\n-\n-  loop_info->off_by_one = (cc == LT || cc == LTU || cc == GT || cc == GTU);\n-\n-\n-  /* We have a switch to allow an unsigned loop counter.\n-     We'll normally disallow this case since the the repeat\n-     count for the RPTB instruction must be less than 0x80000000.  */\n-  if (loop_info->unsigned_p && !TARGET_LOOP_UNSIGNED)\n-    {\n-      c4x_dump (loop_dump_stream, \"Repeat block: Unsigned comparison\\n\");\n-      return 0;\n-    }\n-\n-  return 1;\n-}\n-\n-\n-/* Emit insn(s) to compute loop iteration count.  */\n-\n-static rtx\n-c4x_rptb_emit_init (loop_info)\n-     c4x_rptb_info_t *loop_info;\n-{\n-  rtx result;\n-  int adjust;\n-  rtx seq_start;\n-\n-  /* If have a known constant loop count, things are easy...  */\n-  if (loop_info->loop_count > 0)\n-    return GEN_INT (loop_info->loop_count - 1);\n-\n-  if (loop_info->shift < 0)\n-    abort ();\n-\n-  start_sequence ();\n-\n-  result = loop_info->end_value;\n-  if (loop_info->start_value != const0_rtx)\n-    {\n-      /* end_value - start_value */\n-      result = expand_binop (QImode, sub_optab,\n-\t\t\t     result, loop_info->start_value,\n-\t\t\t     0, loop_info->unsigned_p, OPTAB_DIRECT);\n-    }\n-\n-  adjust = loop_info->incr - loop_info->off_by_one;\n-  if (adjust > 0)\n-    {\n-      /* end_value - start_value + adjust */\n-      result = expand_binop (QImode, add_optab,\n-\t\t\t     result, GEN_INT (adjust),\n-\t\t\t     0, loop_info->unsigned_p, OPTAB_DIRECT);\n-    }\n-\n-  if (loop_info->shift > 0)\n-    {\n-      /* (end_value - start_value + adjust) >> shift */\n-      result = expand_binop (QImode, loop_info->unsigned_p ?\n-\t\t\t     lshr_optab : ashr_optab, result,\n-\t\t\t     GEN_INT (loop_info->shift),\n-\t\t\t     0, loop_info->unsigned_p, OPTAB_DIRECT);\n-    }\n-\n-  /* ((end_value - start_value + adjust) >> shift) - 1 */\n-  result = expand_binop (QImode, sub_optab,\n-\t\t\t result, GEN_INT (1),\n-\t\t\t 0, loop_info->unsigned_p, OPTAB_DIRECT);\n-\n-  seq_start = get_insns ();\n-  end_sequence ();\n-\n-  emit_insns_before (seq_start, loop_info->loop_start);\n-  return result;\n-}\n-\n-\n-/* This routine checks for suitable loops that can use zero overhead\n-   looping and emits insns marking the start and end of the loop\n-   as well as an insn for initialising the loop counter.  */\n-\n-void\n-c4x_rptb_process (loop_start, loop_end)\n-     rtx loop_start, loop_end;\n-{\n-  rtx iteration_count;\n-  rtx start_label;\n-  rtx end_label;\n-  rtx comp_insn;\n-  rtx jump_insn;\n-  c4x_rptb_info_t info;\n-\n-  if (!TARGET_RPTB)\n-    return;\n-\n-  /* Check that there are no jumps crossing loop boundary or calls.  */\n-  if (!c4x_rptb_unjumped_loop_p (loop_start, loop_end))\n-    return;\n-\n-  start_label = next_nonnote_insn (loop_start);\n-  if (GET_CODE (start_label) != CODE_LABEL)\n-    return;\n-\n-  /* Find comparison and jump insns.  */\n-  if (!c4x_rptb_find_comp_and_jump (loop_end, &comp_insn, &jump_insn))\n-    return;\n-\n-  /* If we don't jump back to start label, then the loop is no good.  */\n-  if (start_label != JUMP_LABEL (jump_insn))\n-    return;\n-\n-  /* Check that number of loops is computable.  */\n-  if (!c4x_rptb_loop_info_get (loop_start, loop_end, &info))\n-    return;\n-\n-  c4x_dump (loop_dump_stream, \"Repeat block: Loop start at %d, end at %d\\n\",\n-\t    INSN_UID (loop_start), INSN_UID (loop_end));\n-\n-  if (info.loop_count > 0)\n-    c4x_dump (loop_dump_stream, \"Repeat block: Loop count = %d\\n\",\n-\t      info.loop_count);\n-  else\n-    c4x_dump (loop_dump_stream,\n-\t      \"Repeat block: incr %d, shift %d, swap_p %d,\"\n-\t      \" off_by_one %d, unsigned_p %d\\n\",\n-\t      info.incr, info.shift, info.swap_p,\n-\t      info.off_by_one, info.unsigned_p);\n-\n-  /* Emit insns to compute loop iteration count.  */\n-  iteration_count = c4x_rptb_emit_init (&info);\n-  if (iteration_count == NULL_RTX)\n-    abort ();\n-\n-  /* Add label at end of loop, immediately after jump insn.  */\n-  end_label = gen_label_rtx ();\n-  emit_label_after (end_label, jump_insn);\n-\n-  /* Add label to forced label list to prevent jump optimisation\n-     coalescing end_label with bypass_label since we need these destinct if\n-     we are to sink insns out of the loop. */\n-  if (GET_CODE (NEXT_INSN (loop_end)) == CODE_LABEL)\n-    {\n-      rtx bypass_label;\n-\n-      bypass_label = NEXT_INSN (loop_end);\n-#if 0\n-      forced_labels = gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t       end_label, forced_labels);\n-      forced_labels = gen_rtx_EXPR_LIST (VOIDmode,\n-\t\t\t       bypass_label, forced_labels);\n-#endif\n-      emit_insn_after (gen_repeat_block_filler (), end_label);\n-      \n-      c4x_dump (loop_dump_stream,\n-\t\t\"Repeat block: Start label at %d, end label at %d,\"\n-\t\t\" bypass label at %d\\n\",\n-\t\tINSN_UID (start_label), INSN_UID (end_label),\n-\t\tINSN_UID (bypass_label));\n-    }\n-  else\n-    {\n-      emit_insn_after (gen_repeat_block_filler (), end_label);\n-      c4x_dump (loop_dump_stream,\n-\t\t\"Repeat block: Start label at %d, end label at %d\\n\",\n-\t\tINSN_UID (start_label), INSN_UID (end_label));\n-    }\n-  \n-  /* Create pattern for repeat_block_top and insert at top of loop.  */\n-  emit_insn_before (gen_repeat_block_top (const0_rtx, iteration_count,\n-\t\t\t\t\t  start_label, end_label),\n-\t\t    start_label);\n-  \n-  /* Replace the jump instruction with repeat_block_end insn.  */\n-  PATTERN (jump_insn) = gen_repeat_block_end (const0_rtx, start_label);\n-\n-  /* The insn is unrecognizable after the surgery.  */\n-  INSN_CODE (jump_insn) = -1;\n-  \n-  /* Delete the comparison insn.  */\n-  delete_insn (comp_insn);\n-}\n-\n-\n /* !!! FIXME to emit RPTS correctly.  */\n int\n c4x_rptb_rpts_p (insn, op)\n@@ -5410,7 +4908,7 @@ c4x_rptb_rpts_p (insn, op)\n   if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n     return 0;\n \n-  if (recog_memoized (insn) != CODE_FOR_repeat_block_end)\n+  if (recog_memoized (insn) != CODE_FOR_rptb_end)\n     return 0;\n \n   if (TARGET_RPTS)\n@@ -5419,48 +4917,6 @@ c4x_rptb_rpts_p (insn, op)\n   return (GET_CODE (op) == CONST_INT) && TARGET_RPTS_CYCLES (INTVAL (op));\n }\n \n-/*\n-   Loop structure of `for' loops:\n-\n-   Check if iterations required\n-   If not, jump to BYPASS_LABEL\n-\n-   NOTE_INSN_LOOP_BEG\n-   <<<Repeat block top goes here>>\n-   START_LABEL:\n-   {NOTE_BLOCK_BEGIN}\n-\n-   Body of loop\n-\n-   {NOTE_BLOCK_END}\n-   {NOTE_INSN_LOOP_CONT}\n-\n-   Increment loop counters here\n-\n-   {NOTE_INSN_LOOP_VTOP}\n-   <<<Repeat block nop goes here if nec.>>>\n-   Exit test here                       <<<This gets deleted>>>\n-   If not exiting jump to START_LABEL   <<<Repeat block end goes here>>>\n-   <<<END_LABEL goes here>>\n-\n-   NOTE_INSN_LOOP_END\n-\n-   BYPASS_LABEL:\n-\n-   Note that NOTE_INSN_LOOP_VTOP is only required for loops such as\n-   for loops, where it necessary to duplicate the exit test.  This\n-   position becomes another virtual start of the loop when considering\n-   invariants.\n-\n-   Note that if there is nothing in the loop body we get:\n-\n-   NOTE_INSN_LOOP_BEG\n-   NOTE_INSN_LOOP_CONT\n-   START_LABEL:\n-   NOTE_INSN_LOOP_VTOP\n-   ...\n- */\n-\n \n /* Adjust the cost of a scheduling dependency.  Return the new cost of\n    a dependency LINK or INSN on DEP_INSN.  COST is the current cost. "}]}