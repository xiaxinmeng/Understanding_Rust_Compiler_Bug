{"sha": "eb92cd57a1ebe7cd7589bdbec34d9ae337752ead", "node_id": "C_kwDOANBUbNoAKGViOTJjZDU3YTFlYmU3Y2Q3NTg5YmRiZWMzNGQ5YWUzMzc3NTJlYWQ", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-10-12T07:56:08Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-10-12T07:56:08Z"}, "message": "Fortran: Various CLASS + assumed-rank fixed [PR102541]\n\nStarting point was PR102541, were a previous patch caused an invalid\ne->ref access for class. When testing, it turned out that for\nCLASS to CLASS the code was never executed - additionally, issues\nappeared for optional and a bogus error for -fcheck=all. In particular:\n\nThere were a bunch of issues related to optional CLASS, can have the\n'attr.dummy' set in CLASS_DATA (sym) - but sometimes also in 'sym'!?!\nAdditionally, gfc_variable_attr could return pointer = 1 for nonpointers\nwhen the expr is no longer \"var\" but \"var%_data\".\n\n\tPR fortran/102541\n\ngcc/fortran/ChangeLog:\n\n\t* check.c (gfc_check_present): Handle optional CLASS.\n\t* interface.c (gfc_compare_actual_formal): Likewise.\n\t* trans-array.c (gfc_trans_g77_array): Likewise.\n\t* trans-decl.c (gfc_build_dummy_array_decl): Likewise.\n\t* trans-types.c (gfc_sym_type): Likewise.\n\t* primary.c (gfc_variable_attr): Fixes for dummy and\n\tpointer when 'class%_data' is passed.\n\t* trans-expr.c (set_dtype_for_unallocated, gfc_conv_procedure_call):\n\tFor assumed-rank dummy, fix setting rank for dealloc/notassoc actual\n\tand setting ubound to -1 for assumed-size actuals.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/assumed_rank_24.f90: New test.", "tree": {"sha": "39db63459b97064e20f383b5179a8f3713c5a598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39db63459b97064e20f383b5179a8f3713c5a598"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb92cd57a1ebe7cd7589bdbec34d9ae337752ead", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb92cd57a1ebe7cd7589bdbec34d9ae337752ead", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb92cd57a1ebe7cd7589bdbec34d9ae337752ead", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb92cd57a1ebe7cd7589bdbec34d9ae337752ead/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e1fe3f779185cc678493ceda42c2e620a5c1387", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e1fe3f779185cc678493ceda42c2e620a5c1387", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e1fe3f779185cc678493ceda42c2e620a5c1387"}], "stats": {"total": 257, "additions": 209, "deletions": 48}, "files": [{"sha": "677209ee95e47d454171c5e099c101f2741bfd50", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb92cd57a1ebe7cd7589bdbec34d9ae337752ead/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb92cd57a1ebe7cd7589bdbec34d9ae337752ead/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=eb92cd57a1ebe7cd7589bdbec34d9ae337752ead", "patch": "@@ -4530,7 +4530,9 @@ gfc_check_present (gfc_expr *a)\n       return false;\n     }\n \n-  if (!sym->attr.optional)\n+  /* For CLASS, the optional attribute might be set at either location. */\n+  if ((sym->ts.type != BT_CLASS || !CLASS_DATA (sym)->attr.optional)\n+      && !sym->attr.optional)\n     {\n       gfc_error (\"%qs argument of %qs intrinsic at %L must be of \"\n \t\t \"an OPTIONAL dummy variable\","}, {"sha": "24698be8364231976344a055aaea4320a0f2dc65", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb92cd57a1ebe7cd7589bdbec34d9ae337752ead/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb92cd57a1ebe7cd7589bdbec34d9ae337752ead/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=eb92cd57a1ebe7cd7589bdbec34d9ae337752ead", "patch": "@@ -3624,8 +3624,13 @@ gfc_compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t       \"at %L\", where);\n \t  return false;\n \t}\n-      if (!f->sym->attr.optional\n-\t  || (in_statement_function && f->sym->attr.optional))\n+      /* For CLASS, the optional attribute might be set at either location. */\n+      if (((f->sym->ts.type != BT_CLASS || !CLASS_DATA (f->sym)->attr.optional)\n+\t   && !f->sym->attr.optional)\n+\t  || (in_statement_function\n+\t      && (f->sym->attr.optional\n+\t\t  || (f->sym->ts.type == BT_CLASS\n+\t\t      && CLASS_DATA (f->sym)->attr.optional))))\n \t{\n \t  if (where)\n \t    gfc_error (\"Missing actual argument for argument %qs at %L\","}, {"sha": "d873264a08e370124bce9542bcc04e651b36cbf8", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb92cd57a1ebe7cd7589bdbec34d9ae337752ead/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb92cd57a1ebe7cd7589bdbec34d9ae337752ead/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=eb92cd57a1ebe7cd7589bdbec34d9ae337752ead", "patch": "@@ -2627,7 +2627,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n symbol_attribute\n gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n {\n-  int dimension, codimension, pointer, allocatable, target;\n+  int dimension, codimension, pointer, allocatable, target, optional;\n   symbol_attribute attr;\n   gfc_ref *ref;\n   gfc_symbol *sym;\n@@ -2640,12 +2640,14 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n   sym = expr->symtree->n.sym;\n   attr = sym->attr;\n \n+  optional = attr.optional;\n   if (sym->ts.type == BT_CLASS && sym->attr.class_ok && sym->ts.u.derived)\n     {\n       dimension = CLASS_DATA (sym)->attr.dimension;\n       codimension = CLASS_DATA (sym)->attr.codimension;\n       pointer = CLASS_DATA (sym)->attr.class_pointer;\n       allocatable = CLASS_DATA (sym)->attr.allocatable;\n+      optional |= CLASS_DATA (sym)->attr.optional;\n     }\n   else\n     {\n@@ -2667,6 +2669,7 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n     if (ref->type == REF_INQUIRY)\n       {\n \thas_inquiry_part = true;\n+\toptional = false;\n \tbreak;\n       }\n \n@@ -2684,12 +2687,13 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n \t  case AR_SECTION:\n \t    allocatable = pointer = 0;\n \t    dimension = 1;\n+\t    optional = false;\n \t    break;\n \n \t  case AR_ELEMENT:\n \t    /* Handle coarrays.  */\n \t    if (ref->u.ar.dimen > 0)\n-\t      allocatable = pointer = 0;\n+\t      allocatable = pointer = optional = false;\n \t    break;\n \n \t  case AR_UNKNOWN:\n@@ -2702,6 +2706,7 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n \tbreak;\n \n       case REF_COMPONENT:\n+\toptional = false;\n \tcomp = ref->u.c.component;\n \tattr = comp->attr;\n \tif (ts != NULL && !has_inquiry_part)\n@@ -2723,7 +2728,10 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n \telse\n \t  {\n \t    codimension = comp->attr.codimension;\n-\t    pointer = comp->attr.pointer;\n+\t    if (expr->ts.type == BT_CLASS && strcmp (comp->name, \"_data\") == 0)\n+\t      pointer = comp->attr.class_pointer;\n+\t    else\n+\t      pointer = comp->attr.pointer;\n \t    allocatable = comp->attr.allocatable;\n \t  }\n \tif (pointer || attr.proc_pointer)\n@@ -2733,7 +2741,7 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n \n       case REF_INQUIRY:\n       case REF_SUBSTRING:\n-\tallocatable = pointer = 0;\n+\tallocatable = pointer = optional = false;\n \tbreak;\n       }\n \n@@ -2743,6 +2751,7 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n   attr.allocatable = allocatable;\n   attr.target = target;\n   attr.save = sym->attr.save;\n+  attr.optional = optional;\n \n   return attr;\n }"}, {"sha": "0c5cf4b19a04fc784011c590b0fdf9c7202ef0b3", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb92cd57a1ebe7cd7589bdbec34d9ae337752ead/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb92cd57a1ebe7cd7589bdbec34d9ae337752ead/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=eb92cd57a1ebe7cd7589bdbec34d9ae337752ead", "patch": "@@ -6549,7 +6549,9 @@ gfc_trans_g77_array (gfc_symbol * sym, gfc_wrapped_block * block)\n \n   /* Add the initialization code to the start of the function.  */\n \n-  if (sym->attr.optional || sym->attr.not_always_present)\n+  if ((sym->ts.type == BT_CLASS && CLASS_DATA (sym)->attr.optional)\n+      || sym->attr.optional\n+      || sym->attr.not_always_present)\n     {\n       tree nullify;\n       if (TREE_CODE (parm) != PARM_DECL)"}, {"sha": "87455f8ce250f9896f792c2f57437e9887d5b990", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb92cd57a1ebe7cd7589bdbec34d9ae337752ead/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb92cd57a1ebe7cd7589bdbec34d9ae337752ead/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=eb92cd57a1ebe7cd7589bdbec34d9ae337752ead", "patch": "@@ -1303,7 +1303,8 @@ gfc_build_dummy_array_decl (gfc_symbol * sym, tree dummy)\n   DECL_EXTERNAL (decl) = 0;\n \n   /* Avoid uninitialized warnings for optional dummy arguments.  */\n-  if (sym->attr.optional)\n+  if ((sym->ts.type == BT_CLASS && CLASS_DATA (sym)->attr.optional)\n+      || sym->attr.optional)\n     suppress_warning (decl);\n \n   /* We should never get deferred shape arrays here.  We used to because of"}, {"sha": "afca3a678cf6f8e4d52e53e233ff0e73764a0f2c", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb92cd57a1ebe7cd7589bdbec34d9ae337752ead/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb92cd57a1ebe7cd7589bdbec34d9ae337752ead/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=eb92cd57a1ebe7cd7589bdbec34d9ae337752ead", "patch": "@@ -5454,7 +5454,8 @@ set_dtype_for_unallocated (gfc_se *parmse, gfc_expr *e)\n \n   if (POINTER_TYPE_P (TREE_TYPE (desc)))\n     desc = build_fold_indirect_ref_loc (input_location, desc);\n-\n+  if (GFC_CLASS_TYPE_P (TREE_TYPE (desc)))\n+    desc = gfc_class_data_get (desc);\n   if (!GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))\n     return;\n \n@@ -6533,43 +6534,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\tgfc_conv_array_parameter (&parmse, e, nodesc_arg, fsym,\n \t\t\t\t\t  sym->name, NULL);\n \n-\t      /* Special case for assumed-rank arrays. */\n-\t      if (!sym->attr.is_bind_c && e && fsym && fsym->as\n-\t\t  && fsym->as->type == AS_ASSUMED_RANK\n-\t\t  && e->rank != -1)\n-\t\t{\n-\t\t  if ((gfc_expr_attr (e).pointer\n-\t\t      || gfc_expr_attr (e).allocatable)\n-\t\t      && ((fsym->ts.type == BT_CLASS\n-\t\t\t   && (CLASS_DATA (fsym)->attr.class_pointer\n-\t\t\t       || CLASS_DATA (fsym)->attr.allocatable))\n-\t\t\t  || (fsym->ts.type != BT_CLASS\n-\t\t\t      && (fsym->attr.pointer || fsym->attr.allocatable))))\n-\t\t    {\n-\t\t      /* Unallocated allocatable arrays and unassociated pointer\n-\t\t\t arrays need their dtype setting if they are argument\n-\t\t\t associated with assumed rank dummies. However, if the\n-\t\t\t dummy is nonallocate/nonpointer, the user may not\n-\t\t\t pass those. Hence, it can be skipped.  */\n-\t\t      set_dtype_for_unallocated (&parmse, e);\n-\t\t    }\n-\t\t  else if (e->expr_type == EXPR_VARIABLE\n-\t\t\t   && e->ref\n-\t\t\t   && e->ref->u.ar.type == AR_FULL\n-\t\t\t   && e->symtree->n.sym->attr.dummy\n-\t\t\t   && e->symtree->n.sym->as\n-\t\t\t   && e->symtree->n.sym->as->type == AS_ASSUMED_SIZE)\n-\t\t    {\n-\t\t      tree minus_one;\n-\t\t      tmp = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\t\t parmse.expr);\n-\t\t      minus_one = build_int_cst (gfc_array_index_type, -1);\n-\t\t      gfc_conv_descriptor_ubound_set (&parmse.pre, tmp,\n-\t\t\t\t\t\t      gfc_rank_cst[e->rank - 1],\n-\t\t\t\t\t\t      minus_one);\n- \t\t    }\n-\t\t}\n-\n \t      /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is\n \t\t allocated on entry, it must be deallocated.  */\n \t      if (fsym && fsym->attr.allocatable\n@@ -6621,6 +6585,46 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t}\n \t    }\n \t}\n+      /* Special case for an assumed-rank dummy argument. */\n+      if (!sym->attr.is_bind_c && e && fsym && e->rank > 0\n+\t  && (fsym->ts.type == BT_CLASS\n+\t      ? (CLASS_DATA (fsym)->as\n+\t\t && CLASS_DATA (fsym)->as->type == AS_ASSUMED_RANK)\n+\t      : (fsym->as && fsym->as->type == AS_ASSUMED_RANK)))\n+\t{\n+\t  if (fsym->ts.type == BT_CLASS\n+\t      ? (CLASS_DATA (fsym)->attr.class_pointer\n+\t\t || CLASS_DATA (fsym)->attr.allocatable)\n+\t      : (fsym->attr.pointer || fsym->attr.allocatable))\n+\t    {\n+\t      /* Unallocated allocatable arrays and unassociated pointer\n+\t\t arrays need their dtype setting if they are argument\n+\t\t associated with assumed rank dummies to set the rank.  */\n+\t      set_dtype_for_unallocated (&parmse, e);\n+\t    }\n+\t  else if (e->expr_type == EXPR_VARIABLE\n+\t\t   && e->symtree->n.sym->attr.dummy\n+\t\t   && (e->ts.type == BT_CLASS\n+\t\t       ? (e->ref && e->ref->next\n+\t\t\t  && e->ref->next->type == REF_ARRAY\n+\t\t\t  && e->ref->next->u.ar.type == AR_FULL\n+\t\t\t  && e->ref->next->u.ar.as->type == AS_ASSUMED_SIZE)\n+\t\t       : (e->ref && e->ref->type == REF_ARRAY\n+\t\t\t  && e->ref->u.ar.type == AR_FULL\n+\t\t\t  && e->ref->u.ar.as->type == AS_ASSUMED_SIZE)))\n+\t    {\n+\t      /* Assumed-size actual to assumed-rank dummy requires\n+\t\t dim[rank-1].ubound = -1. */\n+\t      tree minus_one;\n+\t      tmp = build_fold_indirect_ref_loc (input_location, parmse.expr);\n+\t      if (fsym->ts.type == BT_CLASS)\n+\t\ttmp = gfc_class_data_get (tmp);\n+\t      minus_one = build_int_cst (gfc_array_index_type, -1);\n+\t      gfc_conv_descriptor_ubound_set (&parmse.pre, tmp,\n+\t\t\t\t\t      gfc_rank_cst[e->rank - 1],\n+\t\t\t\t\t      minus_one);\n+\t    }\n+\t}\n \n       /* The case with fsym->attr.optional is that of a user subroutine\n \t with an interface indicating an optional argument.  When we call"}, {"sha": "220976babb81ad222ba2b864ec3401d9dadbc160", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb92cd57a1ebe7cd7589bdbec34d9ae337752ead/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb92cd57a1ebe7cd7589bdbec34d9ae337752ead/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=eb92cd57a1ebe7cd7589bdbec34d9ae337752ead", "patch": "@@ -2342,7 +2342,8 @@ gfc_sym_type (gfc_symbol * sym)\n     {\n       /* We must use pointer types for potentially absent variables.  The\n \t optimizers assume a reference type argument is never NULL.  */\n-      if (sym->attr.optional\n+      if ((sym->ts.type == BT_CLASS && CLASS_DATA (sym)->attr.optional)\n+\t  || sym->attr.optional\n \t  || (sym->ns->proc_name && sym->ns->proc_name->attr.entry_master))\n \ttype = build_pointer_type (type);\n       else"}, {"sha": "d91b5ecdc468d73765affcbcb7f2b29454fc820a", "filename": "gcc/testsuite/gfortran.dg/assumed_rank_24.f90", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb92cd57a1ebe7cd7589bdbec34d9ae337752ead/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_24.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb92cd57a1ebe7cd7589bdbec34d9ae337752ead/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_24.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_rank_24.f90?ref=eb92cd57a1ebe7cd7589bdbec34d9ae337752ead", "patch": "@@ -0,0 +1,137 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fcheck=all\" }\n+module m\n+  implicit none (external, type)\n+contains\n+  subroutine cl(x)\n+    class(*) :: x(..)\n+    if (rank(x) /= 1) stop 1\n+    if (ubound(x, dim=1) /= -1) stop 2\n+    select rank (x)\n+      rank (1)\n+      select type (x)\n+        type is (integer)\n+          ! ok\n+        class default\n+          stop 3\n+      end select\n+    end select\n+  end subroutine\n+  subroutine tp(x)\n+    type(*) :: x(..)\n+    if (rank(x) /= 1) stop 4\n+    if (ubound(x, dim=1) /= -1) stop 5\n+  end subroutine\n+\n+  subroutine foo (ccc, ddd, sss, ttt)\n+    integer  :: sss(*), ttt(*)\n+    class(*) :: ccc(*), ddd(*)\n+    call cl(sss)\n+    call tp(ttt)\n+    call cl(ccc)\n+    call tp(ddd)\n+  end\n+\n+  subroutine foo2 (ccc, ddd, sss, ttt, ispresent)\n+    integer  :: sss(*), ttt(*)\n+    class(*) :: ccc(*), ddd(*)\n+    optional :: ccc, ddd, sss, ttt\n+    logical, value :: ispresent\n+    if (present(ccc) .neqv. ispresent) stop 6\n+    if (present(ccc)) then\n+      call cl(sss)\n+      call tp(ttt)\n+      call cl(ccc)\n+      call tp(ddd)\n+    end if\n+  end\n+end\n+\n+module m2\n+  implicit none (external, type)\n+contains\n+  subroutine cl2(x)\n+    class(*), allocatable :: x(..)\n+    if (rank(x) /= 1) stop 7\n+    if (.not. allocated (x)) &\n+      return\n+    if (lbound(x, dim=1) /= -2) stop 8\n+    if (ubound(x, dim=1) /= -1) stop 9\n+    if (size  (x, dim=1) /= 2) stop 10\n+    select rank (x)\n+      rank (1)\n+      select type (x)\n+        type is (integer)\n+          ! ok\n+        class default\n+          stop 11\n+      end select\n+    end select\n+  end subroutine\n+\n+  subroutine tp2(x)\n+    class(*), pointer :: x(..)\n+    if (rank(x) /= 1) stop 12\n+    if (.not. associated (x)) &\n+      return\n+    if (lbound(x, dim=1) /= -2) stop 13\n+    if (ubound(x, dim=1) /= -1) stop 14\n+    if (size  (x, dim=1) /= 2) stop 15\n+    select rank (x)\n+      rank (1)\n+      select type (x)\n+        type is (integer)\n+          ! ok\n+        class default\n+          stop 16\n+      end select\n+    end select\n+  end subroutine\n+\n+  subroutine foo3 (ccc, ddd, sss, ttt)\n+    class(*), allocatable  :: sss(:)\n+    class(*), pointer      :: ttt(:)\n+    class(*), allocatable :: ccc(:)\n+    class(*), pointer     :: ddd(:)\n+    call cl2(sss)\n+    call tp2(ttt)\n+    call cl2(ccc)\n+    call tp2(ddd)\n+  end\n+\n+  subroutine foo4 (ccc, ddd, sss, ttt, ispresent)\n+    class(*), allocatable, optional  :: sss(:)\n+    class(*), pointer, optional      :: ttt(:)\n+    class(*), allocatable, optional :: ccc(:)\n+    class(*), pointer, optional     :: ddd(:)\n+    logical, value :: ispresent\n+    if (present(ccc) .neqv. ispresent) stop 17\n+    if (present(ccc)) then\n+      call cl2(sss)\n+      call tp2(ttt)\n+      call cl2(ccc)\n+      call tp2(ddd)\n+    end if\n+  end\n+end\n+\n+use m\n+use m2\n+implicit none (external, type)\n+integer :: a(1),b(1),c(1),d(1)\n+class(*),allocatable :: aa(:),cc(:)\n+class(*),pointer :: bb(:),dd(:)\n+call foo (a,b,c,d)\n+call foo2 (a,b,c,d, .true.)\n+call foo2 (ispresent=.false.)\n+\n+nullify(bb,dd)\n+call foo3 (aa,bb,cc,dd)\n+call foo4 (aa,bb,cc,dd, .true.)\n+call foo4 (ispresent=.false.)\n+allocate(integer :: aa(-2:-1), bb(-2:-1), cc(-2:-1), dd(-2:-1))\n+call foo3 (aa,bb,cc,dd)\n+call foo4 (aa,bb,cc,dd, .true.)\n+call foo4 (ispresent=.false.)\n+deallocate(aa,bb,cc,dd)\n+end"}]}