{"sha": "bd4556fb65c64396fc6a429bc03b58932dc3c263", "node_id": "C_kwDOANBUbNoAKGJkNDU1NmZiNjVjNjQzOTZmYzZhNDI5YmMwM2I1ODkzMmRjM2MyNjM", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-02-27T13:34:30Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2023-02-28T20:38:35Z"}, "message": "gccrs: Allow infer vars on the lhs too\n\nWe should allow implicit inference on the expected side too not just the\nreceiver.\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>\n\ngcc/rust/ChangeLog:\n\n\t* typecheck/rust-unify.cc (UnifyRules::go): allow lhs infer vars", "tree": {"sha": "fa250fa0bb991bc10f1adbe0027b12cb4ef61aa0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa250fa0bb991bc10f1adbe0027b12cb4ef61aa0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd4556fb65c64396fc6a429bc03b58932dc3c263", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd4556fb65c64396fc6a429bc03b58932dc3c263", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd4556fb65c64396fc6a429bc03b58932dc3c263", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd4556fb65c64396fc6a429bc03b58932dc3c263/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b43f026aac8f0b9a918082551abca6bfa4d9912", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b43f026aac8f0b9a918082551abca6bfa4d9912", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b43f026aac8f0b9a918082551abca6bfa4d9912"}], "stats": {"total": 58, "additions": 42, "deletions": 16}, "files": [{"sha": "70210aacdcdbb0ddec816a747f4a7bf116981e70", "filename": "gcc/rust/typecheck/rust-unify.cc", "status": "modified", "additions": 42, "deletions": 16, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd4556fb65c64396fc6a429bc03b58932dc3c263/gcc%2Frust%2Ftypecheck%2Frust-unify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd4556fb65c64396fc6a429bc03b58932dc3c263/gcc%2Frust%2Ftypecheck%2Frust-unify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-unify.cc?ref=bd4556fb65c64396fc6a429bc03b58932dc3c263", "patch": "@@ -149,26 +149,52 @@ UnifyRules::go ()\n \t}\n     }\n \n-  // inject inference vars if required\n-  bool got_param = rtype->get_kind () == TyTy::TypeKind::PARAM;\n-  bool lhs_is_infer_var = ltype->get_kind () == TyTy::TypeKind::INFER;\n-  bool expected_is_concrete = ltype->is_concrete () && !lhs_is_infer_var;\n-  bool needs_infer = expected_is_concrete && got_param;\n-  if (infer_flag && needs_infer)\n+  if (infer_flag)\n     {\n-      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (rtype);\n-      TyTy::TyVar iv = TyTy::TyVar::get_implicit_infer_var (rhs.get_locus ());\n-      rust_assert (iv.get_tyty ()->get_kind () == TyTy::TypeKind::INFER);\n-      TyTy::InferType *i = static_cast<TyTy::InferType *> (iv.get_tyty ());\n+      bool rgot_param = rtype->get_kind () == TyTy::TypeKind::PARAM;\n+      bool lhs_is_infer_var = ltype->get_kind () == TyTy::TypeKind::INFER;\n+      bool expected_is_concrete = ltype->is_concrete () && !lhs_is_infer_var;\n+      bool rneeds_infer = expected_is_concrete && rgot_param;\n \n-      infers.push_back ({p->get_ref (), p->get_ty_ref (), p, i});\n+      bool lgot_param = ltype->get_kind () == TyTy::TypeKind::PARAM;\n+      bool rhs_is_infer_var = rtype->get_kind () == TyTy::TypeKind::INFER;\n+      bool receiver_is_concrete = rtype->is_concrete () && !rhs_is_infer_var;\n+      bool lneeds_infer = receiver_is_concrete && lgot_param;\n \n-      // FIXME\n-      // this is hacky to set the implicit param lets make this a function\n-      p->set_ty_ref (i->get_ref ());\n+      if (rneeds_infer)\n+\t{\n+\t  TyTy::ParamType *p = static_cast<TyTy::ParamType *> (rtype);\n+\t  TyTy::TyVar iv\n+\t    = TyTy::TyVar::get_implicit_infer_var (rhs.get_locus ());\n+\t  rust_assert (iv.get_tyty ()->get_kind () == TyTy::TypeKind::INFER);\n+\t  TyTy::InferType *i = static_cast<TyTy::InferType *> (iv.get_tyty ());\n+\n+\t  infers.push_back ({p->get_ref (), p->get_ty_ref (), p, i});\n+\n+\t  // FIXME\n+\t  // this is hacky to set the implicit param lets make this a function\n+\t  p->set_ty_ref (i->get_ref ());\n+\n+\t  // set the rtype now to the new inference var\n+\t  rtype = i;\n+\t}\n+      else if (lneeds_infer)\n+\t{\n+\t  TyTy::ParamType *p = static_cast<TyTy::ParamType *> (ltype);\n+\t  TyTy::TyVar iv\n+\t    = TyTy::TyVar::get_implicit_infer_var (lhs.get_locus ());\n+\t  rust_assert (iv.get_tyty ()->get_kind () == TyTy::TypeKind::INFER);\n+\t  TyTy::InferType *i = static_cast<TyTy::InferType *> (iv.get_tyty ());\n+\n+\t  infers.push_back ({p->get_ref (), p->get_ty_ref (), p, i});\n \n-      // set the rtype now to the new inference var\n-      rtype = i;\n+\t  // FIXME\n+\t  // this is hacky to set the implicit param lets make this a function\n+\t  p->set_ty_ref (i->get_ref ());\n+\n+\t  // set the rtype now to the new inference var\n+\t  ltype = i;\n+\t}\n     }\n \n   switch (ltype->get_kind ())"}]}