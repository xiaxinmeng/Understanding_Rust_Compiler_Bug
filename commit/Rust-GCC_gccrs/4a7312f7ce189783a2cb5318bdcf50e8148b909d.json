{"sha": "4a7312f7ce189783a2cb5318bdcf50e8148b909d", "node_id": "C_kwDOANBUbNoAKDRhNzMxMmY3Y2UxODk3ODNhMmNiNTMxOGJkY2Y1MGU4MTQ4YjkwOWQ", "commit": {"author": {"name": "Joffrey Huguet", "email": "huguet@adacore.com", "date": "2022-08-30T16:00:35Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-09-12T08:16:51Z"}, "message": "[Ada] Replace SPARK containers implementation by Compile_Time_Error\n\nThe SPARK containers are now maintained under the spark2014 repository.\nThis change replaces the implementation of SPARK containers by a\npragma Compile_Time_Error, pointing the users WITHing the libraries\nto their new location.\n\ngcc/ada/\n\n\t* Makefile.rtl: Remove SPARK containers filenames.\n\t* impunit.adb: Remove SPARK containers packages names.\n\t* libgnat/a-cfdlli.adb, libgnat/a-cfdlli.ads: Remove content and\n\tadd pragma Compile_Time_Error with suitable message.\n\t* libgnat/a-cfhama.adb, libgnat/a-cfhama.ads: Likewise.\n\t* libgnat/a-cfhase.adb, libgnat/a-cfhase.ads: Likewise.\n\t* libgnat/a-cfidll.adb, libgnat/a-cfidll.ads: Likewise.\n\t* libgnat/a-cfinse.adb, libgnat/a-cfinse.ads: Likewise.\n\t* libgnat/a-cfinve.adb, libgnat/a-cfinve.ads: Likewise.\n\t* libgnat/a-cforma.adb, libgnat/a-cforma.ads: Likewise.\n\t* libgnat/a-cforse.adb, libgnat/a-cforse.ads: Likewise.\n\t* libgnat/a-cofove.adb, libgnat/a-cofove.ads: Likewise.\n\t* libgnat/a-cofuma.adb, libgnat/a-cofuma.ads: Likewise.\n\t* libgnat/a-cofuse.adb, libgnat/a-cofuse.ads: Likewise.\n\t* libgnat/a-cofuve.adb, libgnat/a-cofuve.ads: Likewise.\n\t* libgnat/a-cofuba.adb, libgnat/a-cofuba.ads: Remove package.\n\ngcc/testsuite/\n\n\t* gnat.dg/aspect2.adb: Removed.\n\t* gnat.dg/aspect2.ads: Removed.\n\t* gnat.dg/config_pragma1.adb: Removed.\n\t* gnat.dg/config_pragma1_pkg.ads: Removed.\n\t* gnat.dg/equal8.adb: Removed.\n\t* gnat.dg/equal8.ads: Removed.\n\t* gnat.dg/equal8_pkg.ads: Removed.\n\t* gnat.dg/formal_containers.adb: Removed.\n\t* gnat.dg/iter1.adb: Removed.\n\t* gnat.dg/iter1.ads: Removed.", "tree": {"sha": "95c8f1fb18fdebcadc8f19d36e50adb7fbbf2980", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95c8f1fb18fdebcadc8f19d36e50adb7fbbf2980"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a7312f7ce189783a2cb5318bdcf50e8148b909d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a7312f7ce189783a2cb5318bdcf50e8148b909d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a7312f7ce189783a2cb5318bdcf50e8148b909d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a7312f7ce189783a2cb5318bdcf50e8148b909d/comments", "author": {"login": "joffreyhuguet", "id": 36951399, "node_id": "MDQ6VXNlcjM2OTUxMzk5", "avatar_url": "https://avatars.githubusercontent.com/u/36951399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/joffreyhuguet", "html_url": "https://github.com/joffreyhuguet", "followers_url": "https://api.github.com/users/joffreyhuguet/followers", "following_url": "https://api.github.com/users/joffreyhuguet/following{/other_user}", "gists_url": "https://api.github.com/users/joffreyhuguet/gists{/gist_id}", "starred_url": "https://api.github.com/users/joffreyhuguet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/joffreyhuguet/subscriptions", "organizations_url": "https://api.github.com/users/joffreyhuguet/orgs", "repos_url": "https://api.github.com/users/joffreyhuguet/repos", "events_url": "https://api.github.com/users/joffreyhuguet/events{/privacy}", "received_events_url": "https://api.github.com/users/joffreyhuguet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf8af60f6a3910577e99db04dbc757e731558144", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf8af60f6a3910577e99db04dbc757e731558144", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf8af60f6a3910577e99db04dbc757e731558144"}], "stats": {"total": 26231, "additions": 60, "deletions": 26171}, "files": [{"sha": "96306f8cc9ae672340f98098fb6da45525586fb7", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=4a7312f7ce189783a2cb5318bdcf50e8148b909d", "patch": "@@ -110,14 +110,6 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-cbprqu$(objext) \\\n   a-cbsyqu$(objext) \\\n   a-cdlili$(objext) \\\n-  a-cfdlli$(objext) \\\n-  a-cfhama$(objext) \\\n-  a-cfhase$(objext) \\\n-  a-cfidll$(objext) \\\n-  a-cfinve$(objext) \\\n-  a-cfinse$(objext) \\\n-  a-cforma$(objext) \\\n-  a-cforse$(objext) \\\n   a-cgaaso$(objext) \\\n   a-cgarso$(objext) \\\n   a-cgcaso$(objext) \\\n@@ -144,14 +136,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-clrefi$(objext) \\\n   a-coboho$(objext) \\\n   a-cobove$(objext) \\\n-  a-cofove$(objext) \\\n-  a-cofuba$(objext) \\\n-  a-cofuma$(objext) \\\n-  a-cofuse$(objext) \\\n-  a-cofuve$(objext) \\\n   a-cogeso$(objext) \\\n-  a-cohama$(objext) \\\n-  a-cohase$(objext) \\\n   a-cohata$(objext) \\\n   a-coinho$(objext) \\\n   a-coinve$(objext) \\"}, {"sha": "6562c121330632f7f84bead70204b405797d98a9", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=4a7312f7ce189783a2cb5318bdcf50e8148b909d", "patch": "@@ -605,19 +605,7 @@ package body Impunit is\n    -- GNAT Defined Additions to Ada 2012 --\n    ----------------------------------------\n \n-    (\"a-cfidll\", F),  -- Ada.Containers.Formal_Indefinite_Doubly_Linked_Lists\n-    (\"a-cfinse\", F),  -- Ada.Containers.Functional_Infinite_Sequences\n-    (\"a-cfinve\", F),  -- Ada.Containers.Formal_Indefinite_Vectors\n     (\"a-coboho\", F),  -- Ada.Containers.Bounded_Holders\n-    (\"a-cofove\", F),  -- Ada.Containers.Formal_Vectors\n-    (\"a-cofuma\", F),  -- Ada.Containers.Functional_Maps\n-    (\"a-cofuse\", F),  -- Ada.Containers.Functional_Sets\n-    (\"a-cofuve\", F),  -- Ada.Containers.Functional_Vectors\n-    (\"a-cfdlli\", F),  -- Ada.Containers.Formal_Doubly_Linked_Lists\n-    (\"a-cforse\", F),  -- Ada.Containers.Formal_Ordered_Sets\n-    (\"a-cforma\", F),  -- Ada.Containers.Formal_Ordered_Maps\n-    (\"a-cfhase\", F),  -- Ada.Containers.Formal_Hashed_Sets\n-    (\"a-cfhama\", F),  -- Ada.Containers.Formal_Hashed_Maps\n     (\"a-cvgpso\", F)   -- Ada.Containers.Vectors.Generic_Parallel_Sorting from\n    );                 -- GNATCOLL.OMP\n "}, {"sha": "bbb8fd449a7b7df382e5bf036602b64c5ae4b13a", "filename": "gcc/ada/libgnat/a-cfdlli.adb", "status": "removed", "additions": 0, "deletions": 1905, "changes": 1905, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cfdlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cfdlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfdlli.adb?ref=cf8af60f6a3910577e99db04dbc757e731558144", "patch": "@@ -1,1905 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT LIBRARY COMPONENTS                          --\n---                                                                          --\n---                 ADA.CONTAINERS.FORMAL_DOUBLY_LINKED_LISTS                --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2010-2022, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Containers.Stable_Sorting; use Ada.Containers.Stable_Sorting;\n-\n-with System; use type System.Address;\n-\n-with Ada.Numerics.Big_Numbers.Big_Integers;\n-use Ada.Numerics.Big_Numbers.Big_Integers;\n-\n-package body Ada.Containers.Formal_Doubly_Linked_Lists with\n-  SPARK_Mode => Off\n-is\n-   --  Convert Count_Type to Big_Interger\n-\n-   package Conversions is new Signed_Conversions (Int => Count_Type);\n-   use Conversions;\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Allocate\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      New_Node  : out Count_Type);\n-\n-   procedure Free (Container : in out List; X : Count_Type);\n-\n-   procedure Insert_Internal\n-     (Container : in out List;\n-      Before    : Count_Type;\n-      New_Node  : Count_Type);\n-\n-   function Vet (L : List; Position : Cursor) return Boolean with Inline;\n-\n-   ---------\n-   -- \"=\" --\n-   ---------\n-\n-   function \"=\" (Left : List; Right : List) return Boolean is\n-      LI : Count_Type;\n-      RI : Count_Type;\n-\n-   begin\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n-      if Left.Length /= Right.Length then\n-         return False;\n-      end if;\n-\n-      LI := Left.First;\n-      RI := Right.First;\n-      while LI /= 0 loop\n-         if Left.Nodes (LI).Element /= Right.Nodes (RI).Element then\n-            return False;\n-         end if;\n-\n-         LI := Left.Nodes (LI).Next;\n-         RI := Right.Nodes (RI).Next;\n-      end loop;\n-\n-      return True;\n-   end \"=\";\n-\n-   --------------\n-   -- Allocate --\n-   --------------\n-\n-   procedure Allocate\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      New_Node  : out Count_Type)\n-   is\n-      N : Node_Array renames Container.Nodes;\n-\n-   begin\n-      if Container.Free >= 0 then\n-         New_Node := Container.Free;\n-         N (New_Node).Element := New_Item;\n-         Container.Free := N (New_Node).Next;\n-\n-      else\n-         New_Node := abs Container.Free;\n-         N (New_Node).Element := New_Item;\n-         Container.Free := Container.Free - 1;\n-      end if;\n-   end Allocate;\n-\n-   ------------\n-   -- Append --\n-   ------------\n-\n-   procedure Append (Container : in out List; New_Item : Element_Type) is\n-   begin\n-      Insert (Container, No_Element, New_Item, 1);\n-   end Append;\n-\n-   procedure Append\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   is\n-   begin\n-      Insert (Container, No_Element, New_Item, Count);\n-   end Append;\n-\n-   ------------\n-   -- Assign --\n-   ------------\n-\n-   procedure Assign (Target : in out List; Source : List) is\n-      N : Node_Array renames Source.Nodes;\n-      J : Count_Type;\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n-      if Target.Capacity < Source.Length then\n-         raise Constraint_Error with  -- ???\n-           \"Source length exceeds Target capacity\";\n-      end if;\n-\n-      Clear (Target);\n-\n-      J := Source.First;\n-      while J /= 0 loop\n-         Append (Target, N (J).Element, 1);\n-         J := N (J).Next;\n-      end loop;\n-   end Assign;\n-\n-   -----------\n-   -- Clear --\n-   -----------\n-\n-   procedure Clear (Container : in out List) is\n-      N : Node_Array renames Container.Nodes;\n-      X : Count_Type;\n-\n-   begin\n-      if Container.Length = 0 then\n-         pragma Assert (Container.First = 0);\n-         pragma Assert (Container.Last  = 0);\n-         return;\n-      end if;\n-\n-      pragma Assert (Container.First >= 1);\n-      pragma Assert (Container.Last  >= 1);\n-      pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next  = 0);\n-\n-      while Container.Length > 1 loop\n-         X := Container.First;\n-\n-         Container.First := N (X).Next;\n-         N (Container.First).Prev := 0;\n-\n-         Container.Length := Container.Length - 1;\n-\n-         Free (Container, X);\n-      end loop;\n-\n-      X := Container.First;\n-\n-      Container.First := 0;\n-      Container.Last := 0;\n-      Container.Length := 0;\n-\n-      Free (Container, X);\n-   end Clear;\n-\n-   ------------------------\n-   -- Constant_Reference --\n-   ------------------------\n-\n-   function Constant_Reference\n-     (Container : aliased List;\n-      Position  : Cursor) return not null access constant Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container => Container, Position  => Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return Container.Nodes (Position.Node).Element'Access;\n-   end Constant_Reference;\n-\n-   --------------\n-   -- Contains --\n-   --------------\n-\n-   function Contains\n-     (Container : List;\n-      Item      : Element_Type) return Boolean\n-   is\n-   begin\n-      return Find (Container, Item) /= No_Element;\n-   end Contains;\n-\n-   ----------\n-   -- Copy --\n-   ----------\n-\n-   function Copy\n-     (Source   : List;\n-      Capacity : Count_Type := 0) return List\n-   is\n-      C : constant Count_Type := Count_Type'Max (Source.Capacity, Capacity);\n-      N : Count_Type;\n-      P : List (C);\n-\n-   begin\n-      if 0 < Capacity and then Capacity < Source.Capacity then\n-         raise Capacity_Error;\n-      end if;\n-\n-      N := 1;\n-      while N <= Source.Capacity loop\n-         P.Nodes (N).Prev := Source.Nodes (N).Prev;\n-         P.Nodes (N).Next := Source.Nodes (N).Next;\n-         P.Nodes (N).Element := Source.Nodes (N).Element;\n-         N := N + 1;\n-      end loop;\n-\n-      P.Free   := Source.Free;\n-      P.Length := Source.Length;\n-      P.First  := Source.First;\n-      P.Last   := Source.Last;\n-\n-      if P.Free >= 0 then\n-         N := Source.Capacity + 1;\n-         while N <= C loop\n-            Free (P, N);\n-            N := N + 1;\n-         end loop;\n-      end if;\n-\n-      return P;\n-   end Copy;\n-\n-   ------------\n-   -- Delete --\n-   ------------\n-\n-   procedure Delete (Container : in out List; Position : in out Cursor) is\n-   begin\n-      Delete\n-        (Container => Container,\n-         Position  => Position,\n-         Count     => 1);\n-   end Delete;\n-\n-   procedure Delete\n-     (Container : in out List;\n-      Position  : in out Cursor;\n-      Count     : Count_Type)\n-   is\n-      N : Node_Array renames Container.Nodes;\n-      X : Count_Type;\n-\n-   begin\n-      if not Has_Element (Container => Container,\n-                          Position  => Position)\n-      then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n-      pragma Assert (Container.First >= 1);\n-      pragma Assert (Container.Last  >= 1);\n-      pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next  = 0);\n-\n-      if Position.Node = Container.First then\n-         Delete_First (Container, Count);\n-         Position := No_Element;\n-         return;\n-      end if;\n-\n-      if Count = 0 then\n-         Position := No_Element;\n-         return;\n-      end if;\n-\n-      for Index in 1 .. Count loop\n-         pragma Assert (Container.Length >= 2);\n-\n-         X := Position.Node;\n-         Container.Length := Container.Length - 1;\n-\n-         if X = Container.Last then\n-            Position := No_Element;\n-\n-            Container.Last := N (X).Prev;\n-            N (Container.Last).Next := 0;\n-\n-            Free (Container, X);\n-            return;\n-         end if;\n-\n-         Position.Node := N (X).Next;\n-         pragma Assert (N (Position.Node).Prev >= 0);\n-\n-         N (N (X).Next).Prev := N (X).Prev;\n-         N (N (X).Prev).Next := N (X).Next;\n-\n-         Free (Container, X);\n-      end loop;\n-\n-      Position := No_Element;\n-   end Delete;\n-\n-   ------------------\n-   -- Delete_First --\n-   ------------------\n-\n-   procedure Delete_First (Container : in out List) is\n-   begin\n-      Delete_First\n-        (Container => Container,\n-         Count     => 1);\n-   end Delete_First;\n-\n-   procedure Delete_First (Container : in out List; Count : Count_Type) is\n-      N : Node_Array renames Container.Nodes;\n-      X : Count_Type;\n-\n-   begin\n-      if Count >= Container.Length then\n-         Clear (Container);\n-         return;\n-      end if;\n-\n-      if Count = 0 then\n-         return;\n-      end if;\n-\n-      for J in 1 .. Count loop\n-         X := Container.First;\n-         pragma Assert (N (N (X).Next).Prev = Container.First);\n-\n-         Container.First := N (X).Next;\n-         N (Container.First).Prev := 0;\n-\n-         Container.Length := Container.Length - 1;\n-\n-         Free (Container, X);\n-      end loop;\n-   end Delete_First;\n-\n-   -----------------\n-   -- Delete_Last --\n-   -----------------\n-\n-   procedure Delete_Last (Container : in out List) is\n-   begin\n-      Delete_Last\n-        (Container => Container,\n-         Count     => 1);\n-   end Delete_Last;\n-\n-   procedure Delete_Last (Container : in out List; Count : Count_Type) is\n-      N : Node_Array renames Container.Nodes;\n-      X : Count_Type;\n-\n-   begin\n-      if Count >= Container.Length then\n-         Clear (Container);\n-         return;\n-      end if;\n-\n-      if Count = 0 then\n-         return;\n-      end if;\n-\n-      for J in 1 .. Count loop\n-         X := Container.Last;\n-         pragma Assert (N (N (X).Prev).Next = Container.Last);\n-\n-         Container.Last := N (X).Prev;\n-         N (Container.Last).Next := 0;\n-\n-         Container.Length := Container.Length - 1;\n-\n-         Free (Container, X);\n-      end loop;\n-   end Delete_Last;\n-\n-   -------------\n-   -- Element --\n-   -------------\n-\n-   function Element\n-     (Container : List;\n-      Position  : Cursor) return Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container => Container, Position  => Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return Container.Nodes (Position.Node).Element;\n-   end Element;\n-\n-   ----------\n-   -- Find --\n-   ----------\n-\n-   function Find\n-     (Container : List;\n-      Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor\n-   is\n-      From : Count_Type := Position.Node;\n-\n-   begin\n-      if From = 0 and Container.Length = 0 then\n-         return No_Element;\n-      end if;\n-\n-      if From = 0 then\n-         From := Container.First;\n-      end if;\n-\n-      if Position.Node /= 0 and then not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      while From /= 0 loop\n-         if Container.Nodes (From).Element = Item then\n-            return (Node => From);\n-         end if;\n-\n-         From := Container.Nodes (From).Next;\n-      end loop;\n-\n-      return No_Element;\n-   end Find;\n-\n-   -----------\n-   -- First --\n-   -----------\n-\n-   function First (Container : List) return Cursor is\n-   begin\n-      if Container.First = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Container.First);\n-   end First;\n-\n-   -------------------\n-   -- First_Element --\n-   -------------------\n-\n-   function First_Element (Container : List) return Element_Type is\n-      F : constant Count_Type := Container.First;\n-\n-   begin\n-      if F = 0 then\n-         raise Constraint_Error with \"list is empty\";\n-      else\n-         return Container.Nodes (F).Element;\n-      end if;\n-   end First_Element;\n-\n-   ------------------\n-   -- Formal_Model --\n-   ------------------\n-\n-   package body Formal_Model is\n-\n-      ----------------------------\n-      -- Lift_Abstraction_Level --\n-      ----------------------------\n-\n-      procedure Lift_Abstraction_Level (Container : List) is null;\n-\n-      -------------------------\n-      -- M_Elements_In_Union --\n-      -------------------------\n-\n-      function M_Elements_In_Union\n-        (Container : M.Sequence;\n-         Left      : M.Sequence;\n-         Right     : M.Sequence) return Boolean\n-      is\n-         Elem : Element_Type;\n-\n-      begin\n-         for Index in 1 .. M.Length (Container) loop\n-            Elem := Element (Container, Index);\n-\n-            if not M.Contains (Left, 1, M.Length (Left), Elem)\n-               and then not M.Contains (Right, 1, M.Length (Right), Elem)\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end M_Elements_In_Union;\n-\n-      -------------------------\n-      -- M_Elements_Included --\n-      -------------------------\n-\n-      function M_Elements_Included\n-        (Left  : M.Sequence;\n-         L_Fst : Positive_Count_Type := 1;\n-         L_Lst : Count_Type;\n-         Right : M.Sequence;\n-         R_Fst : Positive_Count_Type := 1;\n-         R_Lst : Count_Type) return Boolean\n-      is\n-      begin\n-         for I in L_Fst .. L_Lst loop\n-            declare\n-               Found : Boolean := False;\n-               J     : Count_Type := R_Fst - 1;\n-\n-            begin\n-               while not Found and J < R_Lst loop\n-                  J := J + 1;\n-                  if Element (Left, I) = Element (Right, J) then\n-                     Found := True;\n-                  end if;\n-               end loop;\n-\n-               if not Found then\n-                  return False;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end M_Elements_Included;\n-\n-      -------------------------\n-      -- M_Elements_Reversed --\n-      -------------------------\n-\n-      function M_Elements_Reversed\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean\n-      is\n-         L : constant Count_Type := M.Length (Left);\n-\n-      begin\n-         if L /= M.Length (Right) then\n-            return False;\n-         end if;\n-\n-         for I in 1 .. L loop\n-            if Element (Left, I) /= Element (Right, L - I + 1) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end M_Elements_Reversed;\n-\n-      ------------------------\n-      -- M_Elements_Swapped --\n-      ------------------------\n-\n-      function M_Elements_Swapped\n-        (Left  : M.Sequence;\n-         Right : M.Sequence;\n-         X     : Positive_Count_Type;\n-         Y     : Positive_Count_Type) return Boolean\n-      is\n-      begin\n-         if M.Length (Left) /= M.Length (Right)\n-           or else Element (Left, X) /= Element (Right, Y)\n-           or else Element (Left, Y) /= Element (Right, X)\n-         then\n-            return False;\n-         end if;\n-\n-         for I in 1 .. M.Length (Left) loop\n-            if I /= X and then I /= Y\n-              and then Element (Left, I) /= Element (Right, I)\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end M_Elements_Swapped;\n-\n-      -----------\n-      -- Model --\n-      -----------\n-\n-      function Model (Container : List) return M.Sequence is\n-         Position : Count_Type := Container.First;\n-         R        : M.Sequence;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R := M.Add (R, Container.Nodes (Position).Element);\n-            Position := Container.Nodes (Position).Next;\n-         end loop;\n-\n-         return R;\n-      end Model;\n-\n-      -----------------------\n-      -- Mapping_Preserved --\n-      -----------------------\n-\n-      function Mapping_Preserved\n-        (M_Left  : M.Sequence;\n-         M_Right : M.Sequence;\n-         P_Left  : P.Map;\n-         P_Right : P.Map) return Boolean\n-      is\n-      begin\n-         for C of P_Left loop\n-            if not P.Has_Key (P_Right, C)\n-              or else P.Get (P_Left,  C) > M.Length (M_Left)\n-              or else P.Get (P_Right, C) > M.Length (M_Right)\n-              or else M.Get (M_Left,  P.Get (P_Left,  C)) /=\n-                      M.Get (M_Right, P.Get (P_Right, C))\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         for C of P_Right loop\n-            if not P.Has_Key (P_Left, C) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end Mapping_Preserved;\n-\n-      -------------------------\n-      -- P_Positions_Shifted --\n-      -------------------------\n-\n-      function P_Positions_Shifted\n-        (Small : P.Map;\n-         Big   : P.Map;\n-         Cut   : Positive_Count_Type;\n-         Count : Count_Type := 1) return Boolean\n-      is\n-      begin\n-         for Cu of Small loop\n-            if not P.Has_Key (Big, Cu) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         for Cu of Big loop\n-            declare\n-               Pos : constant Positive_Count_Type := P.Get (Big, Cu);\n-\n-            begin\n-               if Pos < Cut then\n-                  if not P.Has_Key (Small, Cu)\n-                    or else Pos /= P.Get (Small, Cu)\n-                  then\n-                     return False;\n-                  end if;\n-\n-               elsif Pos >= Cut + Count then\n-                  if not P.Has_Key (Small, Cu)\n-                    or else Pos /= P.Get (Small, Cu) + Count\n-                  then\n-                     return False;\n-                  end if;\n-\n-               else\n-                  if P.Has_Key (Small, Cu) then\n-                     return False;\n-                  end if;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end P_Positions_Shifted;\n-\n-      -------------------------\n-      -- P_Positions_Swapped --\n-      -------------------------\n-\n-      function P_Positions_Swapped\n-        (Left  : P.Map;\n-         Right : P.Map;\n-         X     : Cursor;\n-         Y     : Cursor) return Boolean\n-      is\n-      begin\n-         if not P.Has_Key (Left, X)\n-           or not P.Has_Key (Left, Y)\n-           or not P.Has_Key (Right, X)\n-           or not P.Has_Key (Right, Y)\n-         then\n-            return False;\n-         end if;\n-\n-         if P.Get (Left, X) /= P.Get (Right, Y)\n-           or P.Get (Left, Y) /= P.Get (Right, X)\n-         then\n-            return False;\n-         end if;\n-\n-         for C of Left loop\n-            if not P.Has_Key (Right, C) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         for C of Right loop\n-            if not P.Has_Key (Left, C)\n-              or else (C /= X\n-                        and C /= Y\n-                        and P.Get (Left, C) /= P.Get (Right, C))\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end P_Positions_Swapped;\n-\n-      ---------------------------\n-      -- P_Positions_Truncated --\n-      ---------------------------\n-\n-      function P_Positions_Truncated\n-        (Small : P.Map;\n-         Big   : P.Map;\n-         Cut   : Positive_Count_Type;\n-         Count : Count_Type := 1) return Boolean\n-      is\n-      begin\n-         for Cu of Small loop\n-            if not P.Has_Key (Big, Cu) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         for Cu of Big loop\n-            declare\n-               Pos : constant Positive_Count_Type := P.Get (Big, Cu);\n-\n-            begin\n-               if Pos < Cut then\n-                  if not P.Has_Key (Small, Cu)\n-                    or else Pos /= P.Get (Small, Cu)\n-                  then\n-                     return False;\n-                  end if;\n-\n-               elsif Pos >= Cut + Count then\n-                  return False;\n-\n-               elsif P.Has_Key (Small, Cu) then\n-                  return False;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end P_Positions_Truncated;\n-\n-      ---------------\n-      -- Positions --\n-      ---------------\n-\n-      function Positions (Container : List) return P.Map is\n-         I        : Count_Type := 1;\n-         Position : Count_Type := Container.First;\n-         R        : P.Map;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R := P.Add (R, (Node => Position), I);\n-            pragma Assert (P.Length (R) = To_Big_Integer (I));\n-            Position := Container.Nodes (Position).Next;\n-            I := I + 1;\n-         end loop;\n-\n-         return R;\n-      end Positions;\n-\n-   end Formal_Model;\n-\n-   ----------\n-   -- Free --\n-   ----------\n-\n-   procedure Free (Container : in out List; X : Count_Type) is\n-      pragma Assert (X > 0);\n-      pragma Assert (X <= Container.Capacity);\n-\n-      N : Node_Array renames Container.Nodes;\n-\n-   begin\n-      N (X).Prev := -1;  -- Node is deallocated (not on active list)\n-\n-      if Container.Free >= 0 then\n-         N (X).Next := Container.Free;\n-         Container.Free := X;\n-\n-      elsif X + 1 = abs Container.Free then\n-         N (X).Next := 0;  -- Not strictly necessary, but marginally safer\n-         Container.Free := Container.Free + 1;\n-\n-      else\n-         Container.Free := abs Container.Free;\n-\n-         if Container.Free > Container.Capacity then\n-            Container.Free := 0;\n-\n-         else\n-            for J in Container.Free .. Container.Capacity - 1 loop\n-               N (J).Next := J + 1;\n-            end loop;\n-\n-            N (Container.Capacity).Next := 0;\n-         end if;\n-\n-         N (X).Next := Container.Free;\n-         Container.Free := X;\n-      end if;\n-   end Free;\n-\n-   ---------------------\n-   -- Generic_Sorting --\n-   ---------------------\n-\n-   package body Generic_Sorting with SPARK_Mode => Off is\n-\n-      ------------------\n-      -- Formal_Model --\n-      ------------------\n-\n-      package body Formal_Model is\n-\n-         -----------------------\n-         -- M_Elements_Sorted --\n-         -----------------------\n-\n-         function M_Elements_Sorted (Container : M.Sequence) return Boolean is\n-         begin\n-            if M.Length (Container) = 0 then\n-               return True;\n-            end if;\n-\n-            declare\n-               E1 : Element_Type := Element (Container, 1);\n-\n-            begin\n-               for I in 2 .. M.Length (Container) loop\n-                  declare\n-                     E2 : constant Element_Type := Element (Container, I);\n-\n-                  begin\n-                     if E2 < E1 then\n-                        return False;\n-                     end if;\n-\n-                     E1 := E2;\n-                  end;\n-               end loop;\n-            end;\n-\n-            return True;\n-         end M_Elements_Sorted;\n-\n-      end Formal_Model;\n-\n-      ---------------\n-      -- Is_Sorted --\n-      ---------------\n-\n-      function Is_Sorted (Container : List) return Boolean is\n-         Nodes : Node_Array renames Container.Nodes;\n-         Node  : Count_Type := Container.First;\n-\n-      begin\n-         for J in 2 .. Container.Length loop\n-            if Nodes (Nodes (Node).Next).Element < Nodes (Node).Element then\n-               return False;\n-            else\n-               Node := Nodes (Node).Next;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end Is_Sorted;\n-\n-      -----------\n-      -- Merge --\n-      -----------\n-\n-      procedure Merge (Target : in out List; Source : in out List) is\n-         LN : Node_Array renames Target.Nodes;\n-         RN : Node_Array renames Source.Nodes;\n-         LI : Cursor;\n-         RI : Cursor;\n-\n-      begin\n-         if Target'Address = Source'Address then\n-            raise Program_Error with \"Target and Source denote same container\";\n-         end if;\n-\n-         LI := First (Target);\n-         RI := First (Source);\n-         while RI.Node /= 0 loop\n-            pragma Assert\n-              (RN (RI.Node).Next = 0\n-                or else not (RN (RN (RI.Node).Next).Element <\n-                             RN (RI.Node).Element));\n-\n-            if LI.Node = 0 then\n-               Splice (Target, No_Element, Source);\n-               return;\n-            end if;\n-\n-            pragma Assert\n-              (LN (LI.Node).Next = 0\n-                or else not (LN (LN (LI.Node).Next).Element <\n-                             LN (LI.Node).Element));\n-\n-            if RN (RI.Node).Element < LN (LI.Node).Element then\n-               declare\n-                  RJ : Cursor := RI;\n-                  pragma Warnings (Off, RJ);\n-               begin\n-                  RI.Node := RN (RI.Node).Next;\n-                  Splice (Target, LI, Source, RJ);\n-               end;\n-\n-            else\n-               LI.Node := LN (LI.Node).Next;\n-            end if;\n-         end loop;\n-      end Merge;\n-\n-      ----------\n-      -- Sort --\n-      ----------\n-\n-      procedure Sort (Container : in out List) is\n-         N : Node_Array renames Container.Nodes;\n-      begin\n-         if Container.Length <= 1 then\n-            return;\n-         end if;\n-\n-         pragma Assert (N (Container.First).Prev = 0);\n-         pragma Assert (N (Container.Last).Next = 0);\n-\n-         declare\n-            package Descriptors is new List_Descriptors\n-              (Node_Ref => Count_Type, Nil => 0);\n-            use Descriptors;\n-\n-            function Next (Idx : Count_Type) return Count_Type is\n-              (N (Idx).Next);\n-            procedure Set_Next (Idx : Count_Type; Next : Count_Type)\n-              with Inline;\n-            procedure Set_Prev (Idx : Count_Type; Prev : Count_Type)\n-              with Inline;\n-            function \"<\" (L, R : Count_Type) return Boolean is\n-              (N (L).Element < N (R).Element);\n-            procedure Update_Container (List : List_Descriptor) with Inline;\n-\n-            procedure Set_Next (Idx : Count_Type; Next : Count_Type) is\n-            begin\n-               N (Idx).Next := Next;\n-            end Set_Next;\n-\n-            procedure Set_Prev (Idx : Count_Type; Prev : Count_Type) is\n-            begin\n-               N (Idx).Prev := Prev;\n-            end Set_Prev;\n-\n-            procedure Update_Container (List : List_Descriptor) is\n-            begin\n-               Container.First  := List.First;\n-               Container.Last   := List.Last;\n-               Container.Length := List.Length;\n-            end Update_Container;\n-\n-            procedure Sort_List is new Doubly_Linked_List_Sort;\n-         begin\n-            Sort_List (List_Descriptor'(First  => Container.First,\n-                                        Last   => Container.Last,\n-                                        Length => Container.Length));\n-         end;\n-\n-         pragma Assert (N (Container.First).Prev = 0);\n-         pragma Assert (N (Container.Last).Next = 0);\n-      end Sort;\n-\n-   end Generic_Sorting;\n-\n-   -----------------\n-   -- Has_Element --\n-   -----------------\n-\n-   function Has_Element (Container : List; Position : Cursor) return Boolean is\n-   begin\n-      if Position.Node = 0 then\n-         return False;\n-      end if;\n-\n-      return Container.Nodes (Position.Node).Prev /= -1;\n-   end Has_Element;\n-\n-   ------------\n-   -- Insert --\n-   ------------\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor;\n-      Count     : Count_Type)\n-   is\n-      J : Count_Type;\n-\n-   begin\n-      if Before.Node /= 0 then\n-         pragma Assert (Vet (Container, Before), \"bad cursor in Insert\");\n-      end if;\n-\n-      if Count = 0 then\n-         Position := Before;\n-         return;\n-      end if;\n-\n-      if Container.Length > Container.Capacity - Count then\n-         raise Constraint_Error with \"new length exceeds capacity\";\n-      end if;\n-\n-      Allocate (Container, New_Item, New_Node => J);\n-      Insert_Internal (Container, Before.Node, New_Node => J);\n-      Position := (Node => J);\n-\n-      for Index in 2 .. Count loop\n-         Allocate (Container, New_Item, New_Node => J);\n-         Insert_Internal (Container, Before.Node, New_Node => J);\n-      end loop;\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor)\n-   is\n-   begin\n-      Insert\n-        (Container => Container,\n-         Before    => Before,\n-         New_Item  => New_Item,\n-         Position  => Position,\n-         Count     => 1);\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   is\n-      Position : Cursor;\n-\n-   begin\n-      Insert (Container, Before, New_Item, Position, Count);\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type)\n-   is\n-      Position : Cursor;\n-\n-   begin\n-      Insert (Container, Before, New_Item, Position, 1);\n-   end Insert;\n-\n-   ---------------------\n-   -- Insert_Internal --\n-   ---------------------\n-\n-   procedure Insert_Internal\n-     (Container : in out List;\n-      Before    : Count_Type;\n-      New_Node  : Count_Type)\n-   is\n-      N : Node_Array renames Container.Nodes;\n-\n-   begin\n-      if Container.Length = 0 then\n-         pragma Assert (Before = 0);\n-         pragma Assert (Container.First = 0);\n-         pragma Assert (Container.Last = 0);\n-\n-         Container.First := New_Node;\n-         Container.Last := New_Node;\n-\n-         N (Container.First).Prev := 0;\n-         N (Container.Last).Next := 0;\n-\n-      elsif Before = 0 then\n-         pragma Assert (N (Container.Last).Next = 0);\n-\n-         N (Container.Last).Next := New_Node;\n-         N (New_Node).Prev := Container.Last;\n-\n-         Container.Last := New_Node;\n-         N (Container.Last).Next := 0;\n-\n-      elsif Before = Container.First then\n-         pragma Assert (N (Container.First).Prev = 0);\n-\n-         N (Container.First).Prev := New_Node;\n-         N (New_Node).Next := Container.First;\n-\n-         Container.First := New_Node;\n-         N (Container.First).Prev := 0;\n-\n-      else\n-         pragma Assert (N (Container.First).Prev = 0);\n-         pragma Assert (N (Container.Last).Next = 0);\n-\n-         N (New_Node).Next := Before;\n-         N (New_Node).Prev := N (Before).Prev;\n-\n-         N (N (Before).Prev).Next := New_Node;\n-         N (Before).Prev := New_Node;\n-      end if;\n-\n-      Container.Length := Container.Length + 1;\n-   end Insert_Internal;\n-\n-   --------------\n-   -- Is_Empty --\n-   --------------\n-\n-   function Is_Empty (Container : List) return Boolean is\n-   begin\n-      return Length (Container) = 0;\n-   end Is_Empty;\n-\n-   ----------\n-   -- Last --\n-   ----------\n-\n-   function Last (Container : List) return Cursor is\n-   begin\n-      if Container.Last = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Container.Last);\n-   end Last;\n-\n-   ------------------\n-   -- Last_Element --\n-   ------------------\n-\n-   function Last_Element (Container : List) return Element_Type is\n-      L : constant Count_Type := Container.Last;\n-\n-   begin\n-      if L = 0 then\n-         raise Constraint_Error with \"list is empty\";\n-      else\n-         return Container.Nodes (L).Element;\n-      end if;\n-   end Last_Element;\n-\n-   ------------\n-   -- Length --\n-   ------------\n-\n-   function Length (Container : List) return Count_Type is\n-   begin\n-      return Container.Length;\n-   end Length;\n-\n-   ----------\n-   -- Move --\n-   ----------\n-\n-   procedure Move (Target : in out List; Source : in out List) is\n-      N : Node_Array renames Source.Nodes;\n-      X : Count_Type;\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n-      if Target.Capacity < Source.Length then\n-         raise Constraint_Error with  -- ???\n-           \"Source length exceeds Target capacity\";\n-      end if;\n-\n-      Clear (Target);\n-\n-      while Source.Length > 1 loop\n-         pragma Assert (Source.First in 1 .. Source.Capacity);\n-         pragma Assert (Source.Last /= Source.First);\n-         pragma Assert (N (Source.First).Prev = 0);\n-         pragma Assert (N (Source.Last).Next = 0);\n-\n-         --  Copy first element from Source to Target\n-\n-         X := Source.First;\n-         Append (Target, N (X).Element);  -- optimize away???\n-\n-         --  Unlink first node of Source\n-\n-         Source.First := N (X).Next;\n-         N (Source.First).Prev := 0;\n-\n-         Source.Length := Source.Length - 1;\n-\n-         --  The representation invariants for Source have been restored. It is\n-         --  now safe to free the unlinked node, without fear of corrupting the\n-         --  active links of Source.\n-\n-         --  Note that the algorithm we use here models similar algorithms used\n-         --  in the unbounded form of the doubly-linked list container. In that\n-         --  case, Free is an instantation of Unchecked_Deallocation, which can\n-         --  fail (because PE will be raised if controlled Finalize fails), so\n-         --  we must defer the call until the last step. Here in the bounded\n-         --  form, Free merely links the node we have just \"deallocated\" onto a\n-         --  list of inactive nodes, so technically Free cannot fail. However,\n-         --  for consistency, we handle Free the same way here as we do for the\n-         --  unbounded form, with the pessimistic assumption that it can fail.\n-\n-         Free (Source, X);\n-      end loop;\n-\n-      if Source.Length = 1 then\n-         pragma Assert (Source.First in 1 .. Source.Capacity);\n-         pragma Assert (Source.Last = Source.First);\n-         pragma Assert (N (Source.First).Prev = 0);\n-         pragma Assert (N (Source.Last).Next = 0);\n-\n-         --  Copy element from Source to Target\n-\n-         X := Source.First;\n-         Append (Target, N (X).Element);\n-\n-         --  Unlink node of Source\n-\n-         Source.First := 0;\n-         Source.Last := 0;\n-         Source.Length := 0;\n-\n-         --  Return the unlinked node to the free store\n-\n-         Free (Source, X);\n-      end if;\n-   end Move;\n-\n-   ----------\n-   -- Next --\n-   ----------\n-\n-   procedure Next (Container : List; Position : in out Cursor) is\n-   begin\n-      Position := Next (Container, Position);\n-   end Next;\n-\n-   function Next (Container : List; Position : Cursor) return Cursor is\n-   begin\n-      if Position.Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      if not Has_Element (Container, Position) then\n-         raise Program_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return (Node => Container.Nodes (Position.Node).Next);\n-   end Next;\n-\n-   -------------\n-   -- Prepend --\n-   -------------\n-\n-   procedure Prepend (Container : in out List; New_Item : Element_Type) is\n-   begin\n-      Insert (Container, First (Container), New_Item, 1);\n-   end Prepend;\n-\n-   procedure Prepend\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   is\n-   begin\n-      Insert (Container, First (Container), New_Item, Count);\n-   end Prepend;\n-\n-   --------------\n-   -- Previous --\n-   --------------\n-\n-   procedure Previous (Container : List; Position : in out Cursor) is\n-   begin\n-      Position := Previous (Container, Position);\n-   end Previous;\n-\n-   function Previous (Container : List; Position : Cursor) return Cursor is\n-   begin\n-      if Position.Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      if not Has_Element (Container, Position) then\n-         raise Program_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return (Node => Container.Nodes (Position.Node).Prev);\n-   end Previous;\n-\n-   ---------------\n-   -- Reference --\n-   ---------------\n-\n-   function Reference\n-     (Container : not null access List;\n-      Position  : Cursor) return not null access Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container.all, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return Container.Nodes (Position.Node).Element'Access;\n-   end Reference;\n-\n-   ---------------------\n-   -- Replace_Element --\n-   ---------------------\n-\n-   procedure Replace_Element\n-     (Container : in out List;\n-      Position  : Cursor;\n-      New_Item  : Element_Type)\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container, Position), \"bad cursor in Replace_Element\");\n-\n-      Container.Nodes (Position.Node).Element := New_Item;\n-   end Replace_Element;\n-\n-   ----------------------\n-   -- Reverse_Elements --\n-   ----------------------\n-\n-   procedure Reverse_Elements (Container : in out List) is\n-      N : Node_Array renames Container.Nodes;\n-      I : Count_Type := Container.First;\n-      J : Count_Type := Container.Last;\n-\n-      procedure Swap (L : Count_Type; R : Count_Type);\n-\n-      ----------\n-      -- Swap --\n-      ----------\n-\n-      procedure Swap (L : Count_Type; R : Count_Type) is\n-         LN : constant Count_Type := N (L).Next;\n-         LP : constant Count_Type := N (L).Prev;\n-\n-         RN : constant Count_Type := N (R).Next;\n-         RP : constant Count_Type := N (R).Prev;\n-\n-      begin\n-         if LP /= 0 then\n-            N (LP).Next := R;\n-         end if;\n-\n-         if RN /= 0 then\n-            N (RN).Prev := L;\n-         end if;\n-\n-         N (L).Next := RN;\n-         N (R).Prev := LP;\n-\n-         if LN = R then\n-            pragma Assert (RP = L);\n-\n-            N (L).Prev := R;\n-            N (R).Next := L;\n-\n-         else\n-            N (L).Prev := RP;\n-            N (RP).Next := L;\n-\n-            N (R).Next := LN;\n-            N (LN).Prev := R;\n-         end if;\n-      end Swap;\n-\n-   --  Start of processing for Reverse_Elements\n-\n-   begin\n-      if Container.Length <= 1 then\n-         return;\n-      end if;\n-\n-      pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next = 0);\n-\n-      Container.First := J;\n-      Container.Last  := I;\n-      loop\n-         Swap (L => I, R => J);\n-\n-         J := N (J).Next;\n-         exit when I = J;\n-\n-         I := N (I).Prev;\n-         exit when I = J;\n-\n-         Swap (L => J, R => I);\n-\n-         I := N (I).Next;\n-         exit when I = J;\n-\n-         J := N (J).Prev;\n-         exit when I = J;\n-      end loop;\n-\n-      pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next = 0);\n-   end Reverse_Elements;\n-\n-   ------------------\n-   -- Reverse_Find --\n-   ------------------\n-\n-   function Reverse_Find\n-     (Container : List;\n-      Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor\n-   is\n-      CFirst : Count_Type := Position.Node;\n-\n-   begin\n-      if CFirst = 0 then\n-         CFirst := Container.Last;\n-      end if;\n-\n-      if Container.Length = 0 then\n-         return No_Element;\n-\n-      else\n-         while CFirst /= 0 loop\n-            if Container.Nodes (CFirst).Element = Item then\n-               return (Node => CFirst);\n-            else\n-               CFirst := Container.Nodes (CFirst).Prev;\n-            end if;\n-         end loop;\n-\n-         return No_Element;\n-      end if;\n-   end Reverse_Find;\n-\n-   ------------\n-   -- Splice --\n-   ------------\n-\n-   procedure Splice\n-     (Target : in out List;\n-      Before : Cursor;\n-      Source : in out List)\n-   is\n-      SN : Node_Array renames Source.Nodes;\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         raise Program_Error with \"Target and Source denote same container\";\n-      end if;\n-\n-      if Before.Node /= 0 then\n-         pragma Assert (Vet (Target, Before), \"bad cursor in Splice\");\n-      end if;\n-\n-      pragma Assert (SN (Source.First).Prev = 0);\n-      pragma Assert (SN (Source.Last).Next  = 0);\n-\n-      if Target.Length > Count_Type'Base'Last - Source.Length then\n-         raise Constraint_Error with \"new length exceeds maximum\";\n-      end if;\n-\n-      if Target.Length + Source.Length > Target.Capacity then\n-         raise Constraint_Error;\n-      end if;\n-\n-      loop\n-         Insert (Target, Before, SN (Source.Last).Element);\n-         Delete_Last (Source);\n-         exit when Is_Empty (Source);\n-      end loop;\n-   end Splice;\n-\n-   procedure Splice\n-     (Target   : in out List;\n-      Before   : Cursor;\n-      Source   : in out List;\n-      Position : in out Cursor)\n-   is\n-      Target_Position : Cursor;\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         raise Program_Error with \"Target and Source denote same container\";\n-      end if;\n-\n-      if Position.Node = 0 then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Source, Position), \"bad Position cursor in Splice\");\n-\n-      if Target.Length >= Target.Capacity then\n-         raise Constraint_Error;\n-      end if;\n-\n-      Insert\n-        (Container => Target,\n-         Before    => Before,\n-         New_Item  => Source.Nodes (Position.Node).Element,\n-         Position  => Target_Position);\n-\n-      Delete (Source, Position);\n-      Position := Target_Position;\n-   end Splice;\n-\n-   procedure Splice\n-     (Container : in out List;\n-      Before    : Cursor;\n-      Position  : Cursor)\n-   is\n-      N : Node_Array renames Container.Nodes;\n-\n-   begin\n-      if Before.Node /= 0 then\n-         pragma Assert\n-           (Vet (Container, Before), \"bad Before cursor in Splice\");\n-      end if;\n-\n-      if Position.Node = 0 then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container, Position), \"bad Position cursor in Splice\");\n-\n-      if Position.Node = Before.Node\n-        or else N (Position.Node).Next = Before.Node\n-      then\n-         return;\n-      end if;\n-\n-      pragma Assert (Container.Length >= 2);\n-\n-      if Before.Node = 0 then\n-         pragma Assert (Position.Node /= Container.Last);\n-\n-         if Position.Node = Container.First then\n-            Container.First := N (Position.Node).Next;\n-            N (Container.First).Prev := 0;\n-\n-         else\n-            N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n-            N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n-         end if;\n-\n-         N (Container.Last).Next := Position.Node;\n-         N (Position.Node).Prev := Container.Last;\n-\n-         Container.Last := Position.Node;\n-         N (Container.Last).Next := 0;\n-\n-         return;\n-      end if;\n-\n-      if Before.Node = Container.First then\n-         pragma Assert (Position.Node /= Container.First);\n-\n-         if Position.Node = Container.Last then\n-            Container.Last := N (Position.Node).Prev;\n-            N (Container.Last).Next := 0;\n-\n-         else\n-            N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n-            N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n-         end if;\n-\n-         N (Container.First).Prev := Position.Node;\n-         N (Position.Node).Next := Container.First;\n-\n-         Container.First := Position.Node;\n-         N (Container.First).Prev := 0;\n-\n-         return;\n-      end if;\n-\n-      if Position.Node = Container.First then\n-         Container.First := N (Position.Node).Next;\n-         N (Container.First).Prev := 0;\n-\n-      elsif Position.Node = Container.Last then\n-         Container.Last := N (Position.Node).Prev;\n-         N (Container.Last).Next := 0;\n-\n-      else\n-         N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n-         N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n-      end if;\n-\n-      N (N (Before.Node).Prev).Next := Position.Node;\n-      N (Position.Node).Prev := N (Before.Node).Prev;\n-\n-      N (Before.Node).Prev := Position.Node;\n-      N (Position.Node).Next := Before.Node;\n-\n-      pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next = 0);\n-   end Splice;\n-\n-   ----------\n-   -- Swap --\n-   ----------\n-\n-   procedure Swap\n-     (Container : in out List;\n-      I         : Cursor;\n-      J         : Cursor)\n-   is\n-   begin\n-      if I.Node = 0 then\n-         raise Constraint_Error with \"I cursor has no element\";\n-      end if;\n-\n-      if J.Node = 0 then\n-         raise Constraint_Error with \"J cursor has no element\";\n-      end if;\n-\n-      if I.Node = J.Node then\n-         return;\n-      end if;\n-\n-      pragma Assert (Vet (Container, I), \"bad I cursor in Swap\");\n-      pragma Assert (Vet (Container, J), \"bad J cursor in Swap\");\n-\n-      declare\n-         NN : Node_Array renames Container.Nodes;\n-         NI : Node_Type renames NN (I.Node);\n-         NJ : Node_Type renames NN (J.Node);\n-\n-         EI_Copy : constant Element_Type := NI.Element;\n-\n-      begin\n-         NI.Element := NJ.Element;\n-         NJ.Element := EI_Copy;\n-      end;\n-   end Swap;\n-\n-   ----------------\n-   -- Swap_Links --\n-   ----------------\n-\n-   procedure Swap_Links\n-     (Container : in out List;\n-      I         : Cursor;\n-      J         : Cursor)\n-   is\n-      I_Next : Cursor;\n-      J_Next : Cursor;\n-\n-   begin\n-      if I.Node = 0 then\n-         raise Constraint_Error with \"I cursor has no element\";\n-      end if;\n-\n-      if J.Node = 0 then\n-         raise Constraint_Error with \"J cursor has no element\";\n-      end if;\n-\n-      if I.Node = J.Node then\n-         return;\n-      end if;\n-\n-      pragma Assert (Vet (Container, I), \"bad I cursor in Swap_Links\");\n-      pragma Assert (Vet (Container, J), \"bad J cursor in Swap_Links\");\n-\n-      I_Next := Next (Container, I);\n-\n-      if I_Next = J then\n-         Splice (Container, Before => I, Position => J);\n-\n-      else\n-         J_Next := Next (Container, J);\n-\n-         if J_Next = I then\n-            Splice (Container, Before => J, Position => I);\n-\n-         else\n-            pragma Assert (Container.Length >= 3);\n-            Splice (Container, Before => I_Next, Position => J);\n-            Splice (Container, Before => J_Next, Position => I);\n-         end if;\n-      end if;\n-   end Swap_Links;\n-\n-   ---------\n-   -- Vet --\n-   ---------\n-\n-   function Vet (L : List; Position : Cursor) return Boolean is\n-      N : Node_Array renames L.Nodes;\n-   begin\n-      if not Container_Checks'Enabled then\n-         return True;\n-      end if;\n-\n-      if L.Length = 0 then\n-         return False;\n-      end if;\n-\n-      if L.First = 0 then\n-         return False;\n-      end if;\n-\n-      if L.Last = 0 then\n-         return False;\n-      end if;\n-\n-      if Position.Node > L.Capacity then\n-         return False;\n-      end if;\n-\n-      if N (Position.Node).Prev < 0\n-        or else N (Position.Node).Prev > L.Capacity\n-      then\n-         return False;\n-      end if;\n-\n-      if N (Position.Node).Next > L.Capacity then\n-         return False;\n-      end if;\n-\n-      if N (L.First).Prev /= 0 then\n-         return False;\n-      end if;\n-\n-      if N (L.Last).Next /= 0 then\n-         return False;\n-      end if;\n-\n-      if N (Position.Node).Prev = 0 and then Position.Node /= L.First then\n-         return False;\n-      end if;\n-\n-      if N (Position.Node).Next = 0 and then Position.Node /= L.Last then\n-         return False;\n-      end if;\n-\n-      if L.Length = 1 then\n-         return L.First = L.Last;\n-      end if;\n-\n-      if L.First = L.Last then\n-         return False;\n-      end if;\n-\n-      if N (L.First).Next = 0 then\n-         return False;\n-      end if;\n-\n-      if N (L.Last).Prev = 0 then\n-         return False;\n-      end if;\n-\n-      if N (N (L.First).Next).Prev /= L.First then\n-         return False;\n-      end if;\n-\n-      if N (N (L.Last).Prev).Next /= L.Last then\n-         return False;\n-      end if;\n-\n-      if L.Length = 2 then\n-         if N (L.First).Next /= L.Last then\n-            return False;\n-         end if;\n-\n-         if N (L.Last).Prev /= L.First then\n-            return False;\n-         end if;\n-\n-         return True;\n-      end if;\n-\n-      if N (L.First).Next = L.Last then\n-         return False;\n-      end if;\n-\n-      if N (L.Last).Prev = L.First then\n-         return False;\n-      end if;\n-\n-      if Position.Node = L.First then\n-         return True;\n-      end if;\n-\n-      if Position.Node = L.Last then\n-         return True;\n-      end if;\n-\n-      if N (Position.Node).Next = 0 then\n-         return False;\n-      end if;\n-\n-      if N (Position.Node).Prev = 0 then\n-         return False;\n-      end if;\n-\n-      if N (N (Position.Node).Next).Prev /= Position.Node then\n-         return False;\n-      end if;\n-\n-      if N (N (Position.Node).Prev).Next /= Position.Node then\n-         return False;\n-      end if;\n-\n-      if L.Length = 3 then\n-         if N (L.First).Next /= Position.Node then\n-            return False;\n-         end if;\n-\n-         if N (L.Last).Prev /= Position.Node then\n-            return False;\n-         end if;\n-      end if;\n-\n-      return True;\n-   end Vet;\n-\n-end Ada.Containers.Formal_Doubly_Linked_Lists;"}, {"sha": "3a53ca57cf59e1cde8a2cb9530ac4b996cf5015a", "filename": "gcc/ada/libgnat/a-cfdlli.ads", "status": "modified", "additions": 5, "deletions": 1636, "changes": 1641, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cfdlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cfdlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfdlli.ads?ref=4a7312f7ce189783a2cb5318bdcf50e8148b909d", "patch": "@@ -29,1643 +29,12 @@\n -- <http://www.gnu.org/licenses/>.                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Containers.Functional_Vectors;\n-with Ada.Containers.Functional_Maps;\n-\n generic\n-   type Element_Type is private;\n-   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n-\n-package Ada.Containers.Formal_Doubly_Linked_Lists with\n-  SPARK_Mode,\n-  Annotate => (GNATprove, Always_Return)\n-is\n-\n-   --  Contracts in this unit are meant for analysis only, not for run-time\n-   --  checking.\n-\n-   pragma Assertion_Policy (Pre => Ignore);\n-   pragma Assertion_Policy (Post => Ignore);\n-   pragma Assertion_Policy (Contract_Cases => Ignore);\n-   pragma Annotate (CodePeer, Skip_Analysis);\n-\n-   type List (Capacity : Count_Type) is private with\n-     Iterable => (First       => First,\n-                  Next        => Next,\n-                  Has_Element => Has_Element,\n-                  Element     => Element),\n-     Default_Initial_Condition => Is_Empty (List);\n-   pragma Preelaborable_Initialization (List);\n-\n-   type Cursor is record\n-      Node : Count_Type := 0;\n-   end record;\n-\n-   No_Element : constant Cursor := Cursor'(Node => 0);\n-\n-   Empty_List : constant List;\n-\n-   function Length (Container : List) return Count_Type with\n-     Global => null,\n-     Post   => Length'Result <= Container.Capacity;\n-\n-   pragma Unevaluated_Use_Of_Old (Allow);\n-\n-   package Formal_Model with Ghost is\n-      subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n-\n-      package M is new Ada.Containers.Functional_Vectors\n-        (Index_Type   => Positive_Count_Type,\n-         Element_Type => Element_Type);\n-\n-      function \"=\"\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean renames M.\"=\";\n-\n-      function \"<\"\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean renames M.\"<\";\n-\n-      function \"<=\"\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean renames M.\"<=\";\n-\n-      function M_Elements_In_Union\n-        (Container : M.Sequence;\n-         Left      : M.Sequence;\n-         Right     : M.Sequence) return Boolean\n-      --  The elements of Container are contained in either Left or Right\n-      with\n-        Global => null,\n-        Post   =>\n-          M_Elements_In_Union'Result =\n-            (for all I in 1 .. M.Length (Container) =>\n-              (for some J in 1 .. M.Length (Left) =>\n-                Element (Container, I) = Element (Left, J))\n-                  or (for some J in 1 .. M.Length (Right) =>\n-                       Element (Container, I) = Element (Right, J)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_In_Union);\n-\n-      function M_Elements_Included\n-        (Left  : M.Sequence;\n-         L_Fst : Positive_Count_Type := 1;\n-         L_Lst : Count_Type;\n-         Right : M.Sequence;\n-         R_Fst : Positive_Count_Type := 1;\n-         R_Lst : Count_Type) return Boolean\n-      --  The elements of the slice from L_Fst to L_Lst in Left are contained\n-      --  in the slide from R_Fst to R_Lst in Right.\n-      with\n-        Global => null,\n-        Pre    => L_Lst <= M.Length (Left) and R_Lst <= M.Length (Right),\n-        Post   =>\n-          M_Elements_Included'Result =\n-            (for all I in L_Fst .. L_Lst =>\n-              (for some J in R_Fst .. R_Lst =>\n-                Element (Left, I) = Element (Right, J)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Included);\n-\n-      function M_Elements_Reversed\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean\n-      --  Right is Left in reverse order\n-      with\n-        Global => null,\n-        Post   =>\n-          M_Elements_Reversed'Result =\n-            (M.Length (Left) = M.Length (Right)\n-              and (for all I in 1 .. M.Length (Left) =>\n-                    Element (Left, I) =\n-                      Element (Right, M.Length (Left) - I + 1))\n-              and (for all I in 1 .. M.Length (Left) =>\n-                    Element (Right, I) =\n-                      Element (Left, M.Length (Left) - I + 1)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Reversed);\n-\n-      function M_Elements_Swapped\n-        (Left  : M.Sequence;\n-         Right : M.Sequence;\n-         X     : Positive_Count_Type;\n-         Y     : Positive_Count_Type) return Boolean\n-      --  Elements stored at X and Y are reversed in Left and Right\n-      with\n-        Global => null,\n-        Pre    => X <= M.Length (Left) and Y <= M.Length (Left),\n-        Post   =>\n-          M_Elements_Swapped'Result =\n-            (M.Length (Left) = M.Length (Right)\n-              and Element (Left, X) = Element (Right, Y)\n-              and Element (Left, Y) = Element (Right, X)\n-              and M.Equal_Except (Left, Right, X, Y));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Swapped);\n-\n-      package P is new Ada.Containers.Functional_Maps\n-        (Key_Type                       => Cursor,\n-         Element_Type                   => Positive_Count_Type,\n-         Equivalent_Keys                => \"=\",\n-         Enable_Handling_Of_Equivalence => False);\n-\n-      function \"=\"\n-        (Left  : P.Map;\n-         Right : P.Map) return Boolean renames P.\"=\";\n-\n-      function \"<=\"\n-        (Left  : P.Map;\n-         Right : P.Map) return Boolean renames P.\"<=\";\n-\n-      function P_Positions_Shifted\n-        (Small : P.Map;\n-         Big   : P.Map;\n-         Cut   : Positive_Count_Type;\n-         Count : Count_Type := 1) return Boolean\n-      with\n-        Global => null,\n-        Post   =>\n-          P_Positions_Shifted'Result =\n-\n-            --  Big contains all cursors of Small\n-\n-            (P.Keys_Included (Small, Big)\n-\n-              --  Cursors located before Cut are not moved, cursors located\n-              --  after are shifted by Count.\n-\n-              and (for all I of Small =>\n-                    (if P.Get (Small, I) < Cut then\n-                        P.Get (Big, I) = P.Get (Small, I)\n-                     else\n-                        P.Get (Big, I) - Count = P.Get (Small, I)))\n-\n-              --  New cursors of Big (if any) are between Cut and Cut - 1 +\n-              --  Count.\n-\n-              and (for all I of Big =>\n-                    P.Has_Key (Small, I)\n-                      or P.Get (Big, I) - Count in Cut - Count  .. Cut - 1));\n-\n-      function P_Positions_Swapped\n-        (Left  : P.Map;\n-         Right : P.Map;\n-         X     : Cursor;\n-         Y     : Cursor) return Boolean\n-      --  Left and Right contain the same cursors, but the positions of X and Y\n-      --  are reversed.\n-      with\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          P_Positions_Swapped'Result =\n-            (P.Same_Keys (Left, Right)\n-              and P.Elements_Equal_Except (Left, Right, X, Y)\n-              and P.Has_Key (Left, X)\n-              and P.Has_Key (Left, Y)\n-              and P.Get (Left, X) = P.Get (Right, Y)\n-              and P.Get (Left, Y) = P.Get (Right, X));\n-\n-      function P_Positions_Truncated\n-        (Small : P.Map;\n-         Big   : P.Map;\n-         Cut   : Positive_Count_Type;\n-         Count : Count_Type := 1) return Boolean\n-      with\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          P_Positions_Truncated'Result =\n-\n-            --  Big contains all cursors of Small at the same position\n-\n-            (Small <= Big\n-\n-              --  New cursors of Big (if any) are between Cut and Cut - 1 +\n-              --  Count.\n-\n-              and (for all I of Big =>\n-                    P.Has_Key (Small, I)\n-                      or P.Get (Big, I) - Count in Cut - Count .. Cut - 1));\n-\n-      function Mapping_Preserved\n-        (M_Left  : M.Sequence;\n-         M_Right : M.Sequence;\n-         P_Left  : P.Map;\n-         P_Right : P.Map) return Boolean\n-      with\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          (if Mapping_Preserved'Result then\n-\n-             --  Left and Right contain the same cursors\n-\n-             P.Same_Keys (P_Left, P_Right)\n-\n-               --  Mappings from cursors to elements induced by M_Left, P_Left\n-               --  and M_Right, P_Right are the same.\n-\n-               and (for all C of P_Left =>\n-                     M.Get (M_Left, P.Get (P_Left, C)) =\n-                     M.Get (M_Right, P.Get (P_Right, C))));\n-\n-      function Model (Container : List) return M.Sequence with\n-      --  The high-level model of a list is a sequence of elements. Cursors are\n-      --  not represented in this model.\n-\n-        Ghost,\n-        Global => null,\n-        Post   => M.Length (Model'Result) = Length (Container);\n-      pragma Annotate (GNATprove, Iterable_For_Proof, \"Model\", Model);\n-\n-      function Positions (Container : List) return P.Map with\n-      --  The Positions map is used to model cursors. It only contains valid\n-      --  cursors and map them to their position in the container.\n-\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          not P.Has_Key (Positions'Result, No_Element)\n-\n-            --  Positions of cursors are smaller than the container's length.\n-\n-            and then\n-              (for all I of Positions'Result =>\n-                P.Get (Positions'Result, I) in 1 .. Length (Container)\n-\n-            --  No two cursors have the same position. Note that we do not\n-            --  state that there is a cursor in the map for each position, as\n-            --  it is rarely needed.\n-\n-            and then\n-              (for all J of Positions'Result =>\n-                (if P.Get (Positions'Result, I) = P.Get (Positions'Result, J)\n-                  then I = J)));\n-\n-      procedure Lift_Abstraction_Level (Container : List) with\n-        --  Lift_Abstraction_Level is a ghost procedure that does nothing but\n-        --  assume that we can access to the same elements by iterating over\n-        --  positions or cursors.\n-        --  This information is not generally useful except when switching from\n-        --  a low-level cursor-aware view of a container to a high-level\n-        --  position-based view.\n-\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          (for all Elt of Model (Container) =>\n-            (for some I of Positions (Container) =>\n-              M.Get (Model (Container), P.Get (Positions (Container), I)) =\n-                Elt));\n-\n-      function Element\n-        (S : M.Sequence;\n-         I : Count_Type) return Element_Type renames M.Get;\n-      --  To improve readability of contracts, we rename the function used to\n-      --  access an element in the model to Element.\n-\n-   end Formal_Model;\n-   use Formal_Model;\n-\n-   function \"=\" (Left, Right : List) return Boolean with\n-     Global => null,\n-     Post   => \"=\"'Result = (Model (Left) = Model (Right));\n-\n-   function Is_Empty (Container : List) return Boolean with\n-     Global => null,\n-     Post   => Is_Empty'Result = (Length (Container) = 0);\n-\n-   procedure Clear (Container : in out List) with\n-     Global => null,\n-     Post   => Length (Container) = 0;\n-\n-   procedure Assign (Target : in out List; Source : List) with\n-     Global => null,\n-     Pre    => Target.Capacity >= Length (Source),\n-     Post   => Model (Target) = Model (Source);\n-\n-   function Copy (Source : List; Capacity : Count_Type := 0) return List with\n-     Global => null,\n-     Pre    => Capacity = 0 or else Capacity >= Source.Capacity,\n-     Post   =>\n-       Model (Copy'Result) = Model (Source)\n-         and Positions (Copy'Result) = Positions (Source)\n-         and (if Capacity = 0 then\n-                 Copy'Result.Capacity = Source.Capacity\n-              else\n-                 Copy'Result.Capacity = Capacity);\n-\n-   function Element\n-     (Container : List;\n-      Position : Cursor) return Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Element'Result =\n-         Element (Model (Container), P.Get (Positions (Container), Position));\n-   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n-\n-   procedure Replace_Element\n-     (Container : in out List;\n-      Position  : Cursor;\n-      New_Item  : Element_Type)\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old\n-\n-         --  Cursors are preserved\n-\n-         and Positions (Container)'Old = Positions (Container)\n-\n-         --  The element at the position of Position in Container is New_Item\n-\n-         and Element\n-               (Model (Container),\n-                P.Get (Positions (Container), Position)) = New_Item\n-\n-         --  Other elements are preserved\n-\n-         and M.Equal_Except\n-               (Model (Container)'Old,\n-                Model (Container),\n-                P.Get (Positions (Container), Position));\n-\n-   function At_End (E : access constant List) return access constant List\n-   is (E)\n-   with Ghost,\n-     Annotate => (GNATprove, At_End_Borrow);\n-\n-   function At_End\n-     (E : access constant Element_Type) return access constant Element_Type\n-   is (E)\n-   with Ghost,\n-     Annotate => (GNATprove, At_End_Borrow);\n-\n-   function Constant_Reference\n-     (Container : aliased List;\n-      Position  : Cursor) return not null access constant Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Constant_Reference'Result.all =\n-         Element (Model (Container), P.Get (Positions (Container), Position));\n-\n-   function Reference\n-     (Container : not null access List;\n-      Position  : Cursor) return not null access Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container.all, Position),\n-     Post   =>\n-      Length (Container.all) = Length (At_End (Container).all)\n-\n-         --  Cursors are preserved\n-\n-         and Positions (Container.all) = Positions (At_End (Container).all)\n-\n-         --  Container will have Result.all at position Position\n-\n-         and At_End (Reference'Result).all =\n-           Element (Model (At_End (Container).all),\n-                    P.Get (Positions (At_End (Container).all), Position))\n-\n-         --  All other elements are preserved\n-\n-         and M.Equal_Except\n-               (Model (Container.all),\n-                Model (At_End (Container).all),\n-                P.Get (Positions (At_End (Container).all), Position));\n-\n-   procedure Move (Target : in out List; Source : in out List) with\n-     Global => null,\n-     Pre    => Target.Capacity >= Length (Source),\n-     Post   => Model (Target) = Model (Source'Old) and Length (Source) = 0;\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type)\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Length (Container) < Container.Capacity\n-         and then (Has_Element (Container, Before)\n-                    or else Before = No_Element),\n-     Post           => Length (Container) = Length (Container)'Old + 1,\n-     Contract_Cases =>\n-       (Before = No_Element =>\n-\n-          --  Positions contains a new mapping from the last cursor of\n-          --  Container to its length.\n-\n-          P.Get (Positions (Container), Last (Container)) = Length (Container)\n-\n-            --  Other cursors come from Container'Old\n-\n-            and P.Keys_Included_Except\n-                  (Left    => Positions (Container),\n-                   Right   => Positions (Container)'Old,\n-                   New_Key => Last (Container))\n-\n-            --  Cursors of Container'Old keep the same position\n-\n-            and Positions (Container)'Old <= Positions (Container)\n-\n-            --  Model contains a new element New_Item at the end\n-\n-            and Element (Model (Container), Length (Container)) = New_Item\n-\n-            --  Elements of Container'Old are preserved\n-\n-            and Model (Container)'Old <= Model (Container),\n-\n-        others =>\n-\n-          --  The elements of Container located before Before are preserved\n-\n-          M.Range_Equal\n-            (Left  => Model (Container)'Old,\n-             Right => Model (Container),\n-             Fst   => 1,\n-             Lst   => P.Get (Positions (Container)'Old, Before) - 1)\n-\n-            --  Other elements are shifted by 1\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container)'Old,\n-                   Right  => Model (Container),\n-                   Fst    => P.Get (Positions (Container)'Old, Before),\n-                   Lst    => Length (Container)'Old,\n-                   Offset => 1)\n-\n-            --  New_Item is stored at the previous position of Before in\n-            --  Container.\n-\n-            and Element\n-                  (Model (Container),\n-                   P.Get (Positions (Container)'Old, Before)) = New_Item\n-\n-            --  A new cursor has been inserted at position Before in Container\n-\n-            and P_Positions_Shifted\n-                  (Positions (Container)'Old,\n-                   Positions (Container),\n-                   Cut => P.Get (Positions (Container)'Old, Before)));\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Length (Container) <= Container.Capacity - Count\n-         and then (Has_Element (Container, Before)\n-                    or else Before = No_Element),\n-     Post           => Length (Container) = Length (Container)'Old + Count,\n-     Contract_Cases =>\n-       (Before = No_Element =>\n-\n-          --  The elements of Container are preserved\n-\n-          M.Range_Equal\n-            (Left  => Model (Container)'Old,\n-             Right => Model (Container),\n-             Fst   => 1,\n-             Lst   => Length (Container)'Old)\n-\n-            --  Container contains Count times New_Item at the end\n-\n-            and (if Count > 0 then\n-                    M.Constant_Range\n-                      (Container => Model (Container),\n-                       Fst       => Length (Container)'Old + 1,\n-                       Lst       => Length (Container),\n-                       Item      => New_Item))\n-\n-            --  Count cursors have been inserted at the end of Container\n-\n-            and P_Positions_Truncated\n-                  (Positions (Container)'Old,\n-                   Positions (Container),\n-                   Cut   => Length (Container)'Old + 1,\n-                   Count => Count),\n-\n-        others =>\n-\n-          --  The elements of Container located before Before are preserved\n-\n-          M.Range_Equal\n-            (Left  => Model (Container)'Old,\n-             Right => Model (Container),\n-             Fst   => 1,\n-             Lst   => P.Get (Positions (Container)'Old, Before) - 1)\n-\n-            --  Other elements are shifted by Count\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container)'Old,\n-                   Right  => Model (Container),\n-                   Fst    => P.Get (Positions (Container)'Old, Before),\n-                   Lst    => Length (Container)'Old,\n-                   Offset => Count)\n-\n-            --  Container contains Count times New_Item after position Before\n-\n-            and M.Constant_Range\n-                  (Container => Model (Container),\n-                   Fst       => P.Get (Positions (Container)'Old, Before),\n-                   Lst       =>\n-                     P.Get (Positions (Container)'Old, Before) - 1 + Count,\n-                   Item      => New_Item)\n-\n-            --  Count cursors have been inserted at position Before in\n-            --  Container.\n-\n-            and P_Positions_Shifted\n-                  (Positions (Container)'Old,\n-                   Positions (Container),\n-                   Cut   => P.Get (Positions (Container)'Old, Before),\n-                   Count => Count));\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor)\n-   with\n-     Global => null,\n-     Pre    =>\n-       Length (Container) < Container.Capacity\n-         and then (Has_Element (Container, Before)\n-                    or else Before = No_Element),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + 1\n-\n-          --  Positions is valid in Container and it is located either before\n-          --  Before if it is valid in Container or at the end if it is\n-          --  No_Element.\n-\n-          and P.Has_Key (Positions (Container), Position)\n-          and (if Before = No_Element then\n-                  P.Get (Positions (Container), Position) = Length (Container)\n-               else\n-                  P.Get (Positions (Container), Position) =\n-                  P.Get (Positions (Container)'Old, Before))\n-\n-          --  The elements of Container located before Position are preserved\n-\n-          and M.Range_Equal\n-                (Left  => Model (Container)'Old,\n-                 Right => Model (Container),\n-                 Fst   => 1,\n-                 Lst   => P.Get (Positions (Container), Position) - 1)\n-\n-          --  Other elements are shifted by 1\n-\n-          and M.Range_Shifted\n-                (Left   => Model (Container)'Old,\n-                 Right  => Model (Container),\n-                 Fst    => P.Get (Positions (Container), Position),\n-                 Lst    => Length (Container)'Old,\n-                 Offset => 1)\n-\n-          --  New_Item is stored at Position in Container\n-\n-          and Element\n-                (Model (Container),\n-                 P.Get (Positions (Container), Position)) = New_Item\n-\n-          --  A new cursor has been inserted at position Position in Container\n-\n-          and P_Positions_Shifted\n-                (Positions (Container)'Old,\n-                 Positions (Container),\n-                 Cut => P.Get (Positions (Container), Position));\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor;\n-      Count     : Count_Type)\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Length (Container) <= Container.Capacity - Count\n-         and then (Has_Element (Container, Before)\n-                    or else Before = No_Element),\n-     Post           => Length (Container) = Length (Container)'Old + Count,\n-     Contract_Cases =>\n-       (Count = 0 =>\n-         Position = Before\n-           and Model (Container) = Model (Container)'Old\n-           and Positions (Container) = Positions (Container)'Old,\n-\n-        others =>\n-\n-          --  Positions is valid in Container and it is located either before\n-          --  Before if it is valid in Container or at the end if it is\n-          --  No_Element.\n-\n-          P.Has_Key (Positions (Container), Position)\n-            and (if Before = No_Element then\n-                    P.Get (Positions (Container), Position) =\n-                    Length (Container)'Old + 1\n-                 else\n-                    P.Get (Positions (Container), Position) =\n-                    P.Get (Positions (Container)'Old, Before))\n-\n-            --  The elements of Container located before Position are preserved\n-\n-            and M.Range_Equal\n-                  (Left  => Model (Container)'Old,\n-                   Right => Model (Container),\n-                   Fst   => 1,\n-                   Lst   => P.Get (Positions (Container), Position) - 1)\n-\n-            --  Other elements are shifted by Count\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container)'Old,\n-                   Right  => Model (Container),\n-                   Fst    => P.Get (Positions (Container), Position),\n-                   Lst    => Length (Container)'Old,\n-                   Offset => Count)\n-\n-            --  Container contains Count times New_Item after position Position\n-\n-            and M.Constant_Range\n-                  (Container => Model (Container),\n-                   Fst       => P.Get (Positions (Container), Position),\n-                   Lst       =>\n-                     P.Get (Positions (Container), Position) - 1 + Count,\n-                   Item      => New_Item)\n-\n-            --  Count cursor have been inserted at Position in Container\n-\n-            and P_Positions_Shifted\n-                  (Positions (Container)'Old,\n-                   Positions (Container),\n-                   Cut   => P.Get (Positions (Container), Position),\n-                   Count => Count));\n-\n-   procedure Prepend (Container : in out List; New_Item : Element_Type) with\n-     Global => null,\n-     Pre    => Length (Container) < Container.Capacity,\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + 1\n-\n-         --  Elements are shifted by 1\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Container)'Old,\n-                Right  => Model (Container),\n-                Fst    => 1,\n-                Lst    => Length (Container)'Old,\n-                Offset => 1)\n-\n-         --  New_Item is the first element of Container\n-\n-         and Element (Model (Container), 1) = New_Item\n-\n-         --  A new cursor has been inserted at the beginning of Container\n-\n-         and P_Positions_Shifted\n-               (Positions (Container)'Old,\n-                Positions (Container),\n-                Cut => 1);\n-\n-   procedure Prepend\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   with\n-     Global => null,\n-     Pre    => Length (Container) <= Container.Capacity - Count,\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + Count\n-\n-         --  Elements are shifted by Count\n-\n-         and M.Range_Shifted\n-               (Left     => Model (Container)'Old,\n-                Right     => Model (Container),\n-                Fst    => 1,\n-                Lst    => Length (Container)'Old,\n-                Offset => Count)\n-\n-         --  Container starts with Count times New_Item\n-\n-         and M.Constant_Range\n-               (Container => Model (Container),\n-                Fst       => 1,\n-                Lst       => Count,\n-                Item      => New_Item)\n-\n-         --  Count cursors have been inserted at the beginning of Container\n-\n-         and P_Positions_Shifted\n-               (Positions (Container)'Old,\n-                Positions (Container),\n-                Cut   => 1,\n-                Count => Count);\n-\n-   procedure Append (Container : in out List; New_Item : Element_Type) with\n-     Global => null,\n-     Pre    => Length (Container) < Container.Capacity,\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + 1\n-\n-         --  Positions contains a new mapping from the last cursor of Container\n-         --  to its length.\n-\n-         and P.Get (Positions (Container), Last (Container)) =\n-               Length (Container)\n-\n-         --  Other cursors come from Container'Old\n-\n-         and P.Keys_Included_Except\n-               (Left    => Positions (Container),\n-                Right   => Positions (Container)'Old,\n-                New_Key => Last (Container))\n-\n-         --  Cursors of Container'Old keep the same position\n-\n-         and Positions (Container)'Old <= Positions (Container)\n-\n-         --  Model contains a new element New_Item at the end\n-\n-         and Element (Model (Container), Length (Container)) = New_Item\n-\n-         --  Elements of Container'Old are preserved\n-\n-         and Model (Container)'Old <= Model (Container);\n-\n-   procedure Append\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   with\n-     Global => null,\n-     Pre    => Length (Container) <= Container.Capacity - Count,\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + Count\n-\n-         --  The elements of Container are preserved\n-\n-         and Model (Container)'Old <= Model (Container)\n-\n-         --  Container contains Count times New_Item at the end\n-\n-         and (if Count > 0 then\n-                 M.Constant_Range\n-                   (Container => Model (Container),\n-                     Fst       => Length (Container)'Old + 1,\n-                     Lst       => Length (Container),\n-                     Item      => New_Item))\n-\n-         --  Count cursors have been inserted at the end of Container\n-\n-         and P_Positions_Truncated\n-               (Positions (Container)'Old,\n-                Positions (Container),\n-                Cut   => Length (Container)'Old + 1,\n-                Count => Count);\n-\n-   procedure Delete (Container : in out List; Position : in out Cursor) with\n-     Global  => null,\n-     Depends => (Container =>+ Position, Position => null),\n-     Pre     => Has_Element (Container, Position),\n-     Post    =>\n-       Length (Container) = Length (Container)'Old - 1\n-\n-         --  Position is set to No_Element\n-\n-         and Position = No_Element\n-\n-         --  The elements of Container located before Position are preserved.\n-\n-         and M.Range_Equal\n-               (Left  => Model (Container)'Old,\n-                Right => Model (Container),\n-                Fst   => 1,\n-                Lst   => P.Get (Positions (Container)'Old, Position'Old) - 1)\n-\n-         --  The elements located after Position are shifted by 1\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Container),\n-                Right  => Model (Container)'Old,\n-                Fst    => P.Get (Positions (Container)'Old, Position'Old),\n-                Lst    => Length (Container),\n-                Offset => 1)\n-\n-         --  Position has been removed from Container\n-\n-         and P_Positions_Shifted\n-               (Positions (Container),\n-                Positions (Container)'Old,\n-                Cut   => P.Get (Positions (Container)'Old, Position'Old));\n-\n-   procedure Delete\n-     (Container : in out List;\n-      Position  : in out Cursor;\n-      Count     : Count_Type)\n-   with\n-     Global         => null,\n-     Pre            => Has_Element (Container, Position),\n-     Post           =>\n-       Length (Container) in\n-         Length (Container)'Old - Count .. Length (Container)'Old\n-\n-         --  Position is set to No_Element\n-\n-         and Position = No_Element\n-\n-         --  The elements of Container located before Position are preserved.\n-\n-         and M.Range_Equal\n-               (Left  => Model (Container)'Old,\n-                Right => Model (Container),\n-                Fst   => 1,\n-                Lst   => P.Get (Positions (Container)'Old, Position'Old) - 1),\n-\n-     Contract_Cases =>\n-\n-       --  All the elements after Position have been erased\n-\n-       (Length (Container) - Count < P.Get (Positions (Container), Position) =>\n-          Length (Container) =\n-            P.Get (Positions (Container)'Old, Position'Old) - 1\n-\n-            --  At most Count cursors have been removed at the end of Container\n-\n-            and P_Positions_Truncated\n-                 (Positions (Container),\n-                  Positions (Container)'Old,\n-                  Cut   => P.Get (Positions (Container)'Old, Position'Old),\n-                  Count => Count),\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old - Count\n-\n-            --  Other elements are shifted by Count\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container),\n-                   Right  => Model (Container)'Old,\n-                   Fst    => P.Get (Positions (Container)'Old, Position'Old),\n-                   Lst    => Length (Container),\n-                   Offset => Count)\n-\n-            --  Count cursors have been removed from Container at Position\n-\n-            and P_Positions_Shifted\n-                 (Positions (Container),\n-                  Positions (Container)'Old,\n-                  Cut   => P.Get (Positions (Container)'Old, Position'Old),\n-                  Count => Count));\n-\n-   procedure Delete_First (Container : in out List) with\n-     Global => null,\n-     Pre    => not Is_Empty (Container),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old - 1\n-\n-         --  The elements of Container are shifted by 1\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Container),\n-                Right  => Model (Container)'Old,\n-                Fst    => 1,\n-                Lst    => Length (Container),\n-                Offset => 1)\n-\n-         --  The first cursor of Container has been removed\n-\n-         and P_Positions_Shifted\n-               (Positions (Container),\n-                Positions (Container)'Old,\n-                Cut   => 1);\n-\n-   procedure Delete_First (Container : in out List; Count : Count_Type) with\n-     Global         => null,\n-     Contract_Cases =>\n-\n-       --  All the elements of Container have been erased\n-\n-       (Length (Container) <= Count =>\n-          Length (Container) = 0,\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old - Count\n-\n-            --  Elements of Container are shifted by Count\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container),\n-                   Right  => Model (Container)'Old,\n-                   Fst    => 1,\n-                   Lst    => Length (Container),\n-                   Offset => Count)\n-\n-            --  The first Count cursors have been removed from Container\n-\n-            and P_Positions_Shifted\n-                  (Positions (Container),\n-                   Positions (Container)'Old,\n-                   Cut   => 1,\n-                   Count => Count));\n-\n-   procedure Delete_Last (Container : in out List) with\n-     Global => null,\n-     Pre    => not Is_Empty (Container),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old - 1\n-\n-         --  The elements of Container are preserved\n-\n-         and Model (Container) <= Model (Container)'Old\n-\n-         --  The last cursor of Container has been removed\n-\n-         and not P.Has_Key (Positions (Container), Last (Container)'Old)\n-\n-         --  Other cursors are still valid\n-\n-         and P.Keys_Included_Except\n-               (Left    => Positions (Container)'Old,\n-                Right   => Positions (Container)'Old,\n-                New_Key => Last (Container)'Old)\n-\n-         --  The positions of other cursors are preserved\n-\n-         and Positions (Container) <= Positions (Container)'Old;\n-\n-   procedure Delete_Last (Container : in out List; Count : Count_Type) with\n-     Global         => null,\n-     Contract_Cases =>\n-\n-       --  All the elements of Container have been erased\n-\n-       (Length (Container) <= Count =>\n-          Length (Container) = 0,\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old - Count\n-\n-            --  The elements of Container are preserved\n-\n-            and Model (Container) <= Model (Container)'Old\n-\n-            --  At most Count cursors have been removed at the end of Container\n-\n-            and P_Positions_Truncated\n-                  (Positions (Container),\n-                   Positions (Container)'Old,\n-                   Cut   => Length (Container) + 1,\n-                   Count => Count));\n-\n-   procedure Reverse_Elements (Container : in out List) with\n-     Global => null,\n-     Post   => M_Elements_Reversed (Model (Container)'Old, Model (Container));\n-\n-   procedure Swap\n-     (Container : in out List;\n-      I         : Cursor;\n-      J         : Cursor)\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, I) and then Has_Element (Container, J),\n-     Post   =>\n-       M_Elements_Swapped\n-         (Model (Container)'Old,\n-          Model (Container),\n-          X => P.Get (Positions (Container)'Old, I),\n-          Y => P.Get (Positions (Container)'Old, J))\n-\n-         and Positions (Container) = Positions (Container)'Old;\n-\n-   procedure Swap_Links\n-     (Container : in out List;\n-      I         : Cursor;\n-      J         : Cursor)\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, I) and then Has_Element (Container, J),\n-     Post   =>\n-       M_Elements_Swapped\n-         (Model (Container'Old),\n-          Model (Container),\n-          X => P.Get (Positions (Container)'Old, I),\n-          Y => P.Get (Positions (Container)'Old, J))\n-         and P_Positions_Swapped\n-               (Positions (Container)'Old, Positions (Container), I, J);\n-\n-   procedure Splice\n-     (Target : in out List;\n-      Before : Cursor;\n-      Source : in out List)\n-   --  Target and Source should not be aliased\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Length (Source) <= Target.Capacity - Length (Target)\n-         and then (Has_Element (Target, Before)\n-                    or else Before = No_Element),\n-     Post           =>\n-       Length (Source) = 0\n-         and Length (Target) = Length (Target)'Old + Length (Source)'Old,\n-     Contract_Cases =>\n-       (Before = No_Element =>\n-\n-          --  The elements of Target are preserved\n-\n-          M.Range_Equal\n-            (Left  => Model (Target)'Old,\n-             Right => Model (Target),\n-             Fst   => 1,\n-             Lst   => Length (Target)'Old)\n-\n-            --  The elements of Source are appended to target, the order is not\n-            --  specified.\n-\n-            and M_Elements_Included\n-                  (Left   => Model (Source)'Old,\n-                   L_Lst  => Length (Source)'Old,\n-                   Right  => Model (Target),\n-                   R_Fst  => Length (Target)'Old + 1,\n-                   R_Lst  => Length (Target))\n-\n-            and M_Elements_Included\n-                  (Left   => Model (Target),\n-                   L_Fst  => Length (Target)'Old + 1,\n-                   L_Lst  => Length (Target),\n-                   Right  => Model (Source)'Old,\n-                   R_Lst  => Length (Source)'Old)\n-\n-            --  Cursors have been inserted at the end of Target\n-\n-            and P_Positions_Truncated\n-                  (Positions (Target)'Old,\n-                   Positions (Target),\n-                   Cut   => Length (Target)'Old + 1,\n-                   Count => Length (Source)'Old),\n-\n-        others =>\n-\n-          --  The elements of Target located before Before are preserved\n-\n-          M.Range_Equal\n-            (Left  => Model (Target)'Old,\n-             Right => Model (Target),\n-             Fst   => 1,\n-             Lst   => P.Get (Positions (Target)'Old, Before) - 1)\n-\n-            --  The elements of Source are inserted before Before, the order is\n-            --  not specified.\n-\n-            and M_Elements_Included\n-                  (Left   => Model (Source)'Old,\n-                   L_Lst  => Length (Source)'Old,\n-                   Right  => Model (Target),\n-                   R_Fst  => P.Get (Positions (Target)'Old, Before),\n-                   R_Lst  =>\n-                     P.Get (Positions (Target)'Old, Before) - 1 +\n-                       Length (Source)'Old)\n-\n-            and M_Elements_Included\n-                  (Left   => Model (Target),\n-                   L_Fst  => P.Get (Positions (Target)'Old, Before),\n-                   L_Lst  =>\n-                     P.Get (Positions (Target)'Old, Before) - 1 +\n-                       Length (Source)'Old,\n-                   Right  => Model (Source)'Old,\n-                   R_Lst  => Length (Source)'Old)\n-\n-          --  Other elements are shifted by the length of Source\n-\n-          and M.Range_Shifted\n-                (Left   => Model (Target)'Old,\n-                 Right  => Model (Target),\n-                 Fst    => P.Get (Positions (Target)'Old, Before),\n-                 Lst    => Length (Target)'Old,\n-                 Offset => Length (Source)'Old)\n-\n-          --  Cursors have been inserted at position Before in Target\n-\n-          and P_Positions_Shifted\n-                (Positions (Target)'Old,\n-                 Positions (Target),\n-                 Cut   => P.Get (Positions (Target)'Old, Before),\n-                 Count => Length (Source)'Old));\n-\n-   procedure Splice\n-     (Target   : in out List;\n-      Before   : Cursor;\n-      Source   : in out List;\n-      Position : in out Cursor)\n-   --  Target and Source should not be aliased\n-   with\n-     Global => null,\n-     Pre    =>\n-       (Has_Element (Target, Before) or else Before = No_Element)\n-         and then Has_Element (Source, Position)\n-         and then Length (Target) < Target.Capacity,\n-     Post   =>\n-       Length (Target) = Length (Target)'Old + 1\n-         and Length (Source) = Length (Source)'Old - 1\n-\n-         --  The elements of Source located before Position are preserved\n-\n-         and M.Range_Equal\n-               (Left  => Model (Source)'Old,\n-                Right => Model (Source),\n-                Fst   => 1,\n-                Lst   => P.Get (Positions (Source)'Old, Position'Old) - 1)\n-\n-         --  The elements located after Position are shifted by 1\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Source)'Old,\n-                Right  => Model (Source),\n-                Fst    => P.Get (Positions (Source)'Old, Position'Old) + 1,\n-                Lst    => Length (Source)'Old,\n-                Offset => -1)\n-\n-         --  Position has been removed from Source\n-\n-         and P_Positions_Shifted\n-               (Positions (Source),\n-                Positions (Source)'Old,\n-                Cut   => P.Get (Positions (Source)'Old, Position'Old))\n-\n-         --  Positions is valid in Target and it is located either before\n-         --  Before if it is valid in Target or at the end if it is No_Element.\n-\n-         and P.Has_Key (Positions (Target), Position)\n-         and (if Before = No_Element then\n-                 P.Get (Positions (Target), Position) = Length (Target)\n-              else\n-                 P.Get (Positions (Target), Position) =\n-                 P.Get (Positions (Target)'Old, Before))\n-\n-         --  The elements of Target located before Position are preserved\n-\n-         and M.Range_Equal\n-               (Left  => Model (Target)'Old,\n-                Right => Model (Target),\n-                Fst   => 1,\n-                Lst   => P.Get (Positions (Target), Position) - 1)\n-\n-         --  Other elements are shifted by 1\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Target)'Old,\n-                Right  => Model (Target),\n-                Fst    => P.Get (Positions (Target), Position),\n-                Lst    => Length (Target)'Old,\n-                Offset => 1)\n-\n-         --  The element located at Position in Source is moved to Target\n-\n-         and Element (Model (Target),\n-                      P.Get (Positions (Target), Position)) =\n-             Element (Model (Source)'Old,\n-                      P.Get (Positions (Source)'Old, Position'Old))\n-\n-         --  A new cursor has been inserted at position Position in Target\n-\n-         and P_Positions_Shifted\n-               (Positions (Target)'Old,\n-                Positions (Target),\n-                Cut => P.Get (Positions (Target), Position));\n-\n-   procedure Splice\n-     (Container : in out List;\n-      Before    : Cursor;\n-      Position  : Cursor)\n-   with\n-     Global         => null,\n-     Pre            =>\n-       (Has_Element (Container, Before) or else Before = No_Element)\n-         and then Has_Element (Container, Position),\n-     Post           => Length (Container) = Length (Container)'Old,\n-     Contract_Cases =>\n-       (Before = Position =>\n-          Model (Container) = Model (Container)'Old\n-            and Positions (Container) = Positions (Container)'Old,\n-\n-        Before = No_Element =>\n-\n-          --  The elements located before Position are preserved\n-\n-          M.Range_Equal\n-            (Left  => Model (Container)'Old,\n-             Right => Model (Container),\n-             Fst   => 1,\n-             Lst   => P.Get (Positions (Container)'Old, Position) - 1)\n-\n-          --  The elements located after Position are shifted by 1\n-\n-          and M.Range_Shifted\n-                (Left   => Model (Container)'Old,\n-                 Right  => Model (Container),\n-                 Fst    => P.Get (Positions (Container)'Old, Position) + 1,\n-                 Lst    => Length (Container)'Old,\n-                 Offset => -1)\n-\n-          --  The last element of Container is the one that was previously at\n-          --  Position.\n-\n-          and Element (Model (Container),\n-                       Length (Container)) =\n-              Element (Model (Container)'Old,\n-                       P.Get (Positions (Container)'Old, Position))\n-\n-          --  Cursors from Container continue designating the same elements\n-\n-          and Mapping_Preserved\n-                (M_Left  => Model (Container)'Old,\n-                 M_Right => Model (Container),\n-                 P_Left  => Positions (Container)'Old,\n-                 P_Right => Positions (Container)),\n-\n-        others =>\n-\n-          --  The elements located before Position and Before are preserved\n-\n-          M.Range_Equal\n-            (Left  => Model (Container)'Old,\n-             Right => Model (Container),\n-             Fst   => 1,\n-             Lst   =>\n-               Count_Type'Min\n-                 (P.Get (Positions (Container)'Old, Position) - 1,\n-                  P.Get (Positions (Container)'Old, Before) - 1))\n-\n-            --  The elements located after Position and Before are preserved\n-\n-            and M.Range_Equal\n-                  (Left  => Model (Container)'Old,\n-                   Right => Model (Container),\n-                   Fst   =>\n-                     Count_Type'Max\n-                       (P.Get (Positions (Container)'Old, Position) + 1,\n-                        P.Get (Positions (Container)'Old, Before) + 1),\n-                   Lst   => Length (Container))\n-\n-            --  The elements located after Before and before Position are\n-            --  shifted by 1 to the right.\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container)'Old,\n-                   Right  => Model (Container),\n-                   Fst    => P.Get (Positions (Container)'Old, Before) + 1,\n-                   Lst    => P.Get (Positions (Container)'Old, Position) - 1,\n-                   Offset => 1)\n-\n-            --  The elements located after Position and before Before are\n-            --  shifted by 1 to the left.\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container)'Old,\n-                   Right  => Model (Container),\n-                   Fst    => P.Get (Positions (Container)'Old, Position) + 1,\n-                   Lst    => P.Get (Positions (Container)'Old, Before) - 1,\n-                   Offset => -1)\n-\n-            --  The element previously at Position is now before Before\n-\n-            and Element\n-                  (Model (Container),\n-                   P.Get (Positions (Container)'Old, Before)) =\n-                Element\n-                  (Model (Container)'Old,\n-                   P.Get (Positions (Container)'Old, Position))\n-\n-            --  Cursors from Container continue designating the same elements\n-\n-            and Mapping_Preserved\n-                  (M_Left  => Model (Container)'Old,\n-                   M_Right => Model (Container),\n-                   P_Left  => Positions (Container)'Old,\n-                   P_Right => Positions (Container)));\n-\n-   function First (Container : List) return Cursor with\n-     Global         => null,\n-     Contract_Cases =>\n-       (Length (Container) = 0 =>\n-          First'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, First'Result)\n-            and P.Get (Positions (Container), First'Result) = 1);\n-\n-   function First_Element (Container : List) return Element_Type with\n-     Global => null,\n-     Pre    => not Is_Empty (Container),\n-     Post   => First_Element'Result = M.Get (Model (Container), 1);\n-\n-   function Last (Container : List) return Cursor with\n-     Global         => null,\n-     Contract_Cases =>\n-       (Length (Container) = 0 =>\n-          Last'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Last'Result)\n-            and P.Get (Positions (Container), Last'Result) =\n-                  Length (Container));\n-\n-   function Last_Element (Container : List) return Element_Type with\n-     Global => null,\n-     Pre    => not Is_Empty (Container),\n-     Post   =>\n-       Last_Element'Result = M.Get (Model (Container), Length (Container));\n-\n-   function Next (Container : List; Position : Cursor) return Cursor with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = Length (Container)\n-        =>\n-          Next'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Next'Result)\n-            and then P.Get (Positions (Container), Next'Result) =\n-                     P.Get (Positions (Container), Position) + 1);\n-\n-   procedure Next (Container : List; Position : in out Cursor) with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = Length (Container)\n-        =>\n-          Position = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Position)\n-            and then P.Get (Positions (Container), Position) =\n-                     P.Get (Positions (Container), Position'Old) + 1);\n-\n-   function Previous (Container : List; Position : Cursor) return Cursor with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = 1\n-        =>\n-          Previous'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Previous'Result)\n-            and then P.Get (Positions (Container), Previous'Result) =\n-                     P.Get (Positions (Container), Position) - 1);\n-\n-   procedure Previous (Container : List; Position : in out Cursor) with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = 1\n-         =>\n-          Position = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Position)\n-            and then P.Get (Positions (Container), Position) =\n-                     P.Get (Positions (Container), Position'Old) - 1);\n-\n-   function Find\n-     (Container : List;\n-      Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-\n-       --  If Item is not contained in Container after Position, Find returns\n-       --  No_Element.\n-\n-       (not M.Contains\n-              (Container => Model (Container),\n-               Fst       =>\n-                 (if Position = No_Element then\n-                     1\n-                  else\n-                     P.Get (Positions (Container), Position)),\n-               Lst       => Length (Container),\n-               Item      => Item)\n-        =>\n-          Find'Result = No_Element,\n-\n-        --  Otherwise, Find returns a valid cursor in Container\n-\n-        others =>\n-          P.Has_Key (Positions (Container), Find'Result)\n-\n-            --  The element designated by the result of Find is Item\n-\n-            and Element\n-                  (Model (Container),\n-                   P.Get (Positions (Container), Find'Result)) = Item\n-\n-            --  The result of Find is located after Position\n-\n-            and (if Position /= No_Element then\n-                    P.Get (Positions (Container), Find'Result) >=\n-                    P.Get (Positions (Container), Position))\n-\n-            --  It is the first occurrence of Item in this slice\n-\n-            and not M.Contains\n-                      (Container => Model (Container),\n-                       Fst       =>\n-                         (if Position = No_Element then\n-                             1\n-                          else\n-                             P.Get (Positions (Container), Position)),\n-                       Lst       =>\n-                         P.Get (Positions (Container), Find'Result) - 1,\n-                       Item      => Item));\n-\n-   function Reverse_Find\n-     (Container : List;\n-      Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-\n-       --  If Item is not contained in Container before Position, Find returns\n-       --  No_Element.\n-\n-       (not M.Contains\n-              (Container => Model (Container),\n-               Fst       => 1,\n-               Lst       =>\n-                 (if Position = No_Element then\n-                     Length (Container)\n-                  else\n-                     P.Get (Positions (Container), Position)),\n-               Item      => Item)\n-        =>\n-          Reverse_Find'Result = No_Element,\n-\n-        --  Otherwise, Find returns a valid cursor in Container\n-\n-        others =>\n-          P.Has_Key (Positions (Container), Reverse_Find'Result)\n-\n-            --  The element designated by the result of Find is Item\n-\n-            and Element\n-                  (Model (Container),\n-                   P.Get (Positions (Container), Reverse_Find'Result)) = Item\n-\n-            --  The result of Find is located before Position\n-\n-            and (if Position /= No_Element then\n-                    P.Get (Positions (Container), Reverse_Find'Result) <=\n-                    P.Get (Positions (Container), Position))\n-\n-            --  It is the last occurrence of Item in this slice\n-\n-            and not M.Contains\n-                      (Container => Model (Container),\n-                       Fst       =>\n-                         P.Get (Positions (Container),\n-                                Reverse_Find'Result) + 1,\n-                       Lst       =>\n-                         (if Position = No_Element then\n-                             Length (Container)\n-                          else\n-                             P.Get (Positions (Container), Position)),\n-                       Item      => Item));\n-\n-   function Contains\n-     (Container : List;\n-      Item      : Element_Type) return Boolean\n-   with\n-     Global => null,\n-     Post   =>\n-       Contains'Result = M.Contains (Container => Model (Container),\n-                                     Fst       => 1,\n-                                     Lst       => Length (Container),\n-                                     Item      => Item);\n-\n-   function Has_Element\n-     (Container : List;\n-      Position  : Cursor) return Boolean\n-   with\n-     Global => null,\n-     Post   =>\n-       Has_Element'Result = P.Has_Key (Positions (Container), Position);\n-   pragma Annotate (GNATprove, Inline_For_Proof, Has_Element);\n-\n-   generic\n-      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n-\n-   package Generic_Sorting with SPARK_Mode is\n-\n-      package Formal_Model with Ghost is\n-         function M_Elements_Sorted (Container : M.Sequence) return Boolean\n-         with\n-           Global => null,\n-           Post   =>\n-             M_Elements_Sorted'Result =\n-               (for all I in 1 .. M.Length (Container) =>\n-                 (for all J in I .. M.Length (Container) =>\n-                   not (Element (Container, J) < Element (Container, I))));\n-         pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n-\n-      end Formal_Model;\n-      use Formal_Model;\n-\n-      function Is_Sorted (Container : List) return Boolean with\n-        Global => null,\n-        Post   => Is_Sorted'Result = M_Elements_Sorted (Model (Container));\n-\n-      procedure Sort (Container : in out List) with\n-        Global => null,\n-        Post   =>\n-          Length (Container) = Length (Container)'Old\n-            and M_Elements_Sorted (Model (Container))\n-            and M_Elements_Included\n-                  (Left  => Model (Container)'Old,\n-                   L_Lst => Length (Container),\n-                   Right => Model (Container),\n-                   R_Lst => Length (Container))\n-            and M_Elements_Included\n-                  (Left  => Model (Container),\n-                   L_Lst => Length (Container),\n-                   Right => Model (Container)'Old,\n-                   R_Lst => Length (Container));\n-\n-      procedure Merge (Target : in out List; Source : in out List) with\n-      --  Target and Source should not be aliased\n-        Global => null,\n-        Pre    => Length (Source) <= Target.Capacity - Length (Target),\n-        Post   =>\n-          Length (Target) = Length (Target)'Old + Length (Source)'Old\n-            and Length (Source) = 0\n-            and (if M_Elements_Sorted (Model (Target)'Old)\n-                   and M_Elements_Sorted (Model (Source)'Old)\n-                 then\n-                    M_Elements_Sorted (Model (Target)))\n-            and M_Elements_Included\n-                  (Left  => Model (Target)'Old,\n-                   L_Lst => Length (Target)'Old,\n-                   Right => Model (Target),\n-                   R_Lst => Length (Target))\n-            and M_Elements_Included\n-                  (Left  => Model (Source)'Old,\n-                   L_Lst => Length (Source)'Old,\n-                   Right => Model (Target),\n-                   R_Lst => Length (Target))\n-            and M_Elements_In_Union\n-                  (Model (Target),\n-                   Model (Source)'Old,\n-                   Model (Target)'Old);\n-   end Generic_Sorting;\n-\n-private\n-   pragma SPARK_Mode (Off);\n-\n-   type Node_Type is record\n-      Prev    : Count_Type'Base := -1;\n-      Next    : Count_Type;\n-      Element : aliased Element_Type;\n-   end record;\n-\n-   function \"=\" (L, R : Node_Type) return Boolean is abstract;\n-\n-   type Node_Array is array (Count_Type range <>) of Node_Type;\n-   function \"=\" (L, R : Node_Array) return Boolean is abstract;\n-\n-   type List (Capacity : Count_Type) is record\n-      Free   : Count_Type'Base := -1;\n-      Length : Count_Type := 0;\n-      First  : Count_Type := 0;\n-      Last   : Count_Type := 0;\n-      Nodes  : Node_Array (1 .. Capacity);\n-   end record;\n+package Ada.Containers.Formal_Doubly_Linked_Lists with SPARK_Mode is\n \n-   Empty_List : constant List := (0, others => <>);\n+   pragma Compile_Time_Error\n+     (True,\n+      \"This package has been moved to the SPARK library shipped with any\"\n+      & \" SPARK release starting with version 23.\");\n \n end Ada.Containers.Formal_Doubly_Linked_Lists;"}, {"sha": "bdf2c61d61e4ea08117ec7c855d2bf8aba1cd093", "filename": "gcc/ada/libgnat/a-cfhama.adb", "status": "removed", "additions": 0, "deletions": 976, "changes": 976, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cfhama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cfhama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfhama.adb?ref=cf8af60f6a3910577e99db04dbc757e731558144", "patch": "@@ -1,976 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT LIBRARY COMPONENTS                          --\n---                                                                          --\n---    A D A . C O N T A I N E R S . F O R M A L _ H A S H E D _ M A P S     --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2010-2022, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Containers.Hash_Tables.Generic_Formal_Operations;\n-pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Formal_Operations);\n-\n-with Ada.Containers.Hash_Tables.Generic_Formal_Keys;\n-pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Formal_Keys);\n-\n-with Ada.Containers.Prime_Numbers; use Ada.Containers.Prime_Numbers;\n-\n-with Ada.Numerics.Big_Numbers.Big_Integers;\n-use Ada.Numerics.Big_Numbers.Big_Integers;\n-\n-with System; use type System.Address;\n-\n-package body Ada.Containers.Formal_Hashed_Maps with\n-  SPARK_Mode => Off\n-is\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   --  All local subprograms require comments ???\n-\n-   function Equivalent_Keys\n-     (Key  : Key_Type;\n-      Node : Node_Type) return Boolean;\n-   pragma Inline (Equivalent_Keys);\n-\n-   procedure Free\n-     (HT : in out Map;\n-      X  : Count_Type);\n-\n-   generic\n-      with procedure Set_Element (Node : in out Node_Type);\n-   procedure Generic_Allocate\n-     (HT   : in out HT_Types.Hash_Table_Type;\n-      Node : out Count_Type);\n-\n-   function Hash_Node (Node : Node_Type) return Hash_Type;\n-   pragma Inline (Hash_Node);\n-\n-   function Next (Node : Node_Type) return Count_Type;\n-   pragma Inline (Next);\n-\n-   procedure Set_Next (Node : in out Node_Type; Next : Count_Type);\n-   pragma Inline (Set_Next);\n-\n-   function Vet (Container : Map; Position : Cursor) return Boolean\n-     with Inline;\n-\n-   --  Convert Count_Type to Big_Interger\n-\n-   package Conversions is new Signed_Conversions (Int => Count_Type);\n-\n-   function Big (J : Count_Type) return Big_Integer renames\n-     Conversions.To_Big_Integer;\n-\n-   --------------------------\n-   -- Local Instantiations --\n-   --------------------------\n-\n-   package HT_Ops is\n-     new Hash_Tables.Generic_Formal_Operations\n-       (HT_Types  => HT_Types,\n-        Hash_Node => Hash_Node,\n-        Next      => Next,\n-        Set_Next  => Set_Next);\n-\n-   package Key_Ops is\n-     new Hash_Tables.Generic_Formal_Keys\n-       (HT_Types        => HT_Types,\n-        Next            => Next,\n-        Set_Next        => Set_Next,\n-        Key_Type        => Key_Type,\n-        Hash            => Hash,\n-        Equivalent_Keys => Equivalent_Keys);\n-\n-   ---------\n-   -- \"=\" --\n-   ---------\n-\n-   function \"=\" (Left, Right : Map) return Boolean is\n-   begin\n-      if Length (Left) /= Length (Right) then\n-         return False;\n-      end if;\n-\n-      if Length (Left) = 0 then\n-         return True;\n-      end if;\n-\n-      declare\n-         Node  : Count_Type;\n-         ENode : Count_Type;\n-\n-      begin\n-         Node := First (Left).Node;\n-         while Node /= 0 loop\n-            ENode :=\n-              Find\n-                (Container => Right,\n-                 Key       => Left.Content.Nodes (Node).Key).Node;\n-\n-            if ENode = 0 or else\n-              Right.Content.Nodes (ENode).Element /=\n-              Left.Content.Nodes (Node).Element\n-            then\n-               return False;\n-            end if;\n-\n-            Node := HT_Ops.Next (Left.Content, Node);\n-         end loop;\n-\n-         return True;\n-      end;\n-   end \"=\";\n-\n-   ------------\n-   -- Assign --\n-   ------------\n-\n-   procedure Assign (Target : in out Map; Source : Map) is\n-      procedure Insert_Element (Source_Node : Count_Type);\n-      pragma Inline (Insert_Element);\n-\n-      procedure Insert_Elements is\n-        new HT_Ops.Generic_Iteration (Insert_Element);\n-\n-      --------------------\n-      -- Insert_Element --\n-      --------------------\n-\n-      procedure Insert_Element (Source_Node : Count_Type) is\n-         N : Node_Type renames Source.Content.Nodes (Source_Node);\n-      begin\n-         Insert (Target, N.Key, N.Element);\n-      end Insert_Element;\n-\n-   --  Start of processing for Assign\n-\n-   begin\n-      if Target.Capacity < Length (Source) then\n-         raise Constraint_Error with  -- correct exception ???\n-           \"Source length exceeds Target capacity\";\n-      end if;\n-\n-      Clear (Target);\n-\n-      Insert_Elements (Source.Content);\n-   end Assign;\n-\n-   --------------\n-   -- Capacity --\n-   --------------\n-\n-   function Capacity (Container : Map) return Count_Type is\n-   begin\n-      return Container.Content.Nodes'Length;\n-   end Capacity;\n-\n-   -----------\n-   -- Clear --\n-   -----------\n-\n-   procedure Clear (Container : in out Map) is\n-   begin\n-      HT_Ops.Clear (Container.Content);\n-   end Clear;\n-\n-   ------------------------\n-   -- Constant_Reference --\n-   ------------------------\n-\n-   function Constant_Reference\n-     (Container : aliased Map;\n-      Position  : Cursor) return not null access constant Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container, Position),\n-         \"bad cursor in function Constant_Reference\");\n-\n-      return Container.Content.Nodes (Position.Node).Element'Access;\n-   end Constant_Reference;\n-\n-   function Constant_Reference\n-     (Container : aliased Map;\n-      Key       : Key_Type) return not null access constant Element_Type\n-   is\n-      Node : constant Count_Type := Find (Container, Key).Node;\n-\n-   begin\n-      if Node = 0 then\n-         raise Constraint_Error with\n-           \"no element available because key not in map\";\n-      end if;\n-\n-      return Container.Content.Nodes (Node).Element'Access;\n-   end Constant_Reference;\n-\n-   --------------\n-   -- Contains --\n-   --------------\n-\n-   function Contains (Container : Map; Key : Key_Type) return Boolean is\n-   begin\n-      return Find (Container, Key) /= No_Element;\n-   end Contains;\n-\n-   ----------\n-   -- Copy --\n-   ----------\n-\n-   function Copy\n-     (Source   : Map;\n-      Capacity : Count_Type := 0) return Map\n-   is\n-      C      : constant Count_Type :=\n-                 Count_Type'Max (Capacity, Source.Capacity);\n-      Cu     : Cursor;\n-      H      : Hash_Type;\n-      N      : Count_Type;\n-      Target : Map (C, Source.Modulus);\n-\n-   begin\n-      if 0 < Capacity and then Capacity < Source.Capacity then\n-         raise Capacity_Error;\n-      end if;\n-\n-      Target.Content.Length := Source.Content.Length;\n-      Target.Content.Free := Source.Content.Free;\n-\n-      H := 1;\n-      while H <= Source.Modulus loop\n-         Target.Content.Buckets (H) := Source.Content.Buckets (H);\n-         H := H + 1;\n-      end loop;\n-\n-      N := 1;\n-      while N <= Source.Capacity loop\n-         Target.Content.Nodes (N) := Source.Content.Nodes (N);\n-         N := N + 1;\n-      end loop;\n-\n-      while N <= C loop\n-         Cu := (Node => N);\n-         Free (Target, Cu.Node);\n-         N := N + 1;\n-      end loop;\n-\n-      return Target;\n-   end Copy;\n-\n-   ---------------------\n-   -- Default_Modulus --\n-   ---------------------\n-\n-   function Default_Modulus (Capacity : Count_Type) return Hash_Type is\n-   begin\n-      return To_Prime (Capacity);\n-   end Default_Modulus;\n-\n-   ------------\n-   -- Delete --\n-   ------------\n-\n-   procedure Delete (Container : in out Map; Key : Key_Type) is\n-      X : Count_Type;\n-\n-   begin\n-      Key_Ops.Delete_Key_Sans_Free (Container.Content, Key, X);\n-\n-      if X = 0 then\n-         raise Constraint_Error with \"attempt to delete key not in map\";\n-      end if;\n-\n-      Free (Container, X);\n-   end Delete;\n-\n-   procedure Delete (Container : in out Map; Position : in out Cursor) is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with\n-           \"Position cursor of Delete has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n-\n-      HT_Ops.Delete_Node_Sans_Free (Container.Content, Position.Node);\n-\n-      Free (Container, Position.Node);\n-      Position := No_Element;\n-   end Delete;\n-\n-   -------------\n-   -- Element --\n-   -------------\n-\n-   function Element (Container : Map; Key : Key_Type) return Element_Type is\n-      Node : constant Count_Type := Find (Container, Key).Node;\n-\n-   begin\n-      if Node = 0 then\n-         raise Constraint_Error with\n-           \"no element available because key not in map\";\n-      end if;\n-\n-      return Container.Content.Nodes (Node).Element;\n-   end Element;\n-\n-   function Element (Container : Map; Position : Cursor) return Element_Type is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor equals No_Element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container, Position), \"bad cursor in function Element\");\n-\n-      return Container.Content.Nodes (Position.Node).Element;\n-   end Element;\n-\n-   ---------------------\n-   -- Equivalent_Keys --\n-   ---------------------\n-\n-   function Equivalent_Keys\n-     (Key  : Key_Type;\n-      Node : Node_Type) return Boolean\n-   is\n-   begin\n-      return Equivalent_Keys (Key, Node.Key);\n-   end Equivalent_Keys;\n-\n-   -------------\n-   -- Exclude --\n-   -------------\n-\n-   procedure Exclude (Container : in out Map; Key : Key_Type) is\n-      X : Count_Type;\n-   begin\n-      Key_Ops.Delete_Key_Sans_Free (Container.Content, Key, X);\n-      Free (Container, X);\n-   end Exclude;\n-\n-   ----------\n-   -- Find --\n-   ----------\n-\n-   function Find (Container : Map; Key : Key_Type) return Cursor is\n-      Node : constant Count_Type := Key_Ops.Find (Container.Content, Key);\n-\n-   begin\n-      if Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Node);\n-   end Find;\n-\n-   -----------\n-   -- First --\n-   -----------\n-\n-   function First (Container : Map) return Cursor is\n-      Node : constant Count_Type := HT_Ops.First (Container.Content);\n-\n-   begin\n-      if Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Node);\n-   end First;\n-\n-   ------------------\n-   -- Formal_Model --\n-   ------------------\n-\n-   package body Formal_Model is\n-\n-      ----------\n-      -- Find --\n-      ----------\n-\n-      function Find\n-        (Container : K.Sequence;\n-         Key       : Key_Type) return Count_Type\n-      is\n-      begin\n-         for I in 1 .. K.Length (Container) loop\n-            if Equivalent_Keys (Key, K.Get (Container, I)) then\n-               return I;\n-            end if;\n-         end loop;\n-         return 0;\n-      end Find;\n-\n-      ---------------------\n-      -- K_Keys_Included --\n-      ---------------------\n-\n-      function K_Keys_Included\n-        (Left  : K.Sequence;\n-         Right : K.Sequence) return Boolean\n-      is\n-      begin\n-         for I in 1 .. K.Length (Left) loop\n-            if not K.Contains (Right, 1, K.Length (Right), K.Get (Left, I))\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end K_Keys_Included;\n-\n-      ----------\n-      -- Keys --\n-      ----------\n-\n-      function Keys (Container : Map) return K.Sequence is\n-         Position : Count_Type := HT_Ops.First (Container.Content);\n-         R        : K.Sequence;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R := K.Add (R, Container.Content.Nodes (Position).Key);\n-            Position := HT_Ops.Next (Container.Content, Position);\n-         end loop;\n-\n-         return R;\n-      end Keys;\n-\n-      ----------------------------\n-      -- Lift_Abstraction_Level --\n-      ----------------------------\n-\n-      procedure Lift_Abstraction_Level (Container : Map) is null;\n-\n-      -----------------------\n-      -- Mapping_Preserved --\n-      -----------------------\n-\n-      function Mapping_Preserved\n-        (K_Left  : K.Sequence;\n-         K_Right : K.Sequence;\n-         P_Left  : P.Map;\n-         P_Right : P.Map) return Boolean\n-      is\n-      begin\n-         for C of P_Left loop\n-            if not P.Has_Key (P_Right, C)\n-              or else P.Get (P_Left,  C) > K.Length (K_Left)\n-              or else P.Get (P_Right, C) > K.Length (K_Right)\n-              or else K.Get (K_Left,  P.Get (P_Left,  C)) /=\n-                      K.Get (K_Right, P.Get (P_Right, C))\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end Mapping_Preserved;\n-\n-      -----------\n-      -- Model --\n-      -----------\n-\n-      function Model (Container : Map) return M.Map is\n-         Position : Count_Type := HT_Ops.First (Container.Content);\n-         R        : M.Map;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R :=\n-              M.Add\n-                (Container => R,\n-                 New_Key   => Container.Content.Nodes (Position).Key,\n-                 New_Item  => Container.Content.Nodes (Position).Element);\n-\n-            Position := HT_Ops.Next (Container.Content, Position);\n-         end loop;\n-\n-         return R;\n-      end Model;\n-\n-      ---------------\n-      -- Positions --\n-      ---------------\n-\n-      function Positions (Container : Map) return P.Map is\n-         I        : Count_Type := 1;\n-         Position : Count_Type := HT_Ops.First (Container.Content);\n-         R        : P.Map;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R := P.Add (R, (Node => Position), I);\n-            pragma Assert (P.Length (R) = Big (I));\n-            Position := HT_Ops.Next (Container.Content, Position);\n-            I := I + 1;\n-         end loop;\n-\n-         return R;\n-      end Positions;\n-\n-   end Formal_Model;\n-\n-   ----------\n-   -- Free --\n-   ----------\n-\n-   procedure Free (HT : in out Map; X : Count_Type) is\n-   begin\n-      if X /= 0 then\n-         pragma Assert (X <= HT.Capacity);\n-         HT.Content.Nodes (X).Has_Element := False;\n-         HT_Ops.Free (HT.Content, X);\n-      end if;\n-   end Free;\n-\n-   ----------------------\n-   -- Generic_Allocate --\n-   ----------------------\n-\n-   procedure Generic_Allocate\n-     (HT   : in out HT_Types.Hash_Table_Type;\n-      Node : out Count_Type)\n-   is\n-      procedure Allocate is\n-        new HT_Ops.Generic_Allocate (Set_Element);\n-\n-   begin\n-      Allocate (HT, Node);\n-      HT.Nodes (Node).Has_Element := True;\n-   end Generic_Allocate;\n-\n-   -----------------\n-   -- Has_Element --\n-   -----------------\n-\n-   function Has_Element (Container : Map; Position : Cursor) return Boolean is\n-   begin\n-      if Position.Node = 0\n-        or else not Container.Content.Nodes (Position.Node).Has_Element\n-      then\n-         return False;\n-      else\n-         return True;\n-      end if;\n-   end Has_Element;\n-\n-   ---------------\n-   -- Hash_Node --\n-   ---------------\n-\n-   function Hash_Node (Node : Node_Type) return Hash_Type is\n-   begin\n-      return Hash (Node.Key);\n-   end Hash_Node;\n-\n-   -------------\n-   -- Include --\n-   -------------\n-\n-   procedure Include\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type)\n-   is\n-      Position : Cursor;\n-      Inserted : Boolean;\n-\n-   begin\n-      Insert (Container, Key, New_Item, Position, Inserted);\n-\n-      if not Inserted then\n-         declare\n-            P : constant Count_Type := Position.Node;\n-            N : Node_Type renames Container.Content.Nodes (P);\n-         begin\n-            N.Key := Key;\n-            N.Element := New_Item;\n-         end;\n-      end if;\n-   end Include;\n-\n-   ------------\n-   -- Insert --\n-   ------------\n-\n-   procedure Insert\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor;\n-      Inserted  : out Boolean)\n-   is\n-      procedure Assign_Key (Node : in out Node_Type);\n-      pragma Inline (Assign_Key);\n-\n-      procedure New_Node\n-        (HT   : in out HT_Types.Hash_Table_Type;\n-         Node : out Count_Type);\n-      pragma Inline (New_Node);\n-\n-      procedure Local_Insert is\n-        new Key_Ops.Generic_Conditional_Insert (New_Node);\n-\n-      procedure Allocate is\n-        new Generic_Allocate (Assign_Key);\n-\n-      -----------------\n-      --  Assign_Key --\n-      -----------------\n-\n-      procedure Assign_Key (Node : in out Node_Type) is\n-      begin\n-         Node.Key := Key;\n-         Node.Element := New_Item;\n-      end Assign_Key;\n-\n-      --------------\n-      -- New_Node --\n-      --------------\n-\n-      procedure New_Node\n-        (HT   : in out HT_Types.Hash_Table_Type;\n-         Node : out Count_Type)\n-      is\n-      begin\n-         Allocate (HT, Node);\n-      end New_Node;\n-\n-   --  Start of processing for Insert\n-\n-   begin\n-      Local_Insert (Container.Content, Key, Position.Node, Inserted);\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type)\n-   is\n-      Unused_Position : Cursor;\n-      Inserted        : Boolean;\n-\n-   begin\n-      Insert (Container, Key, New_Item, Unused_Position, Inserted);\n-\n-      if not Inserted then\n-         raise Constraint_Error with \"attempt to insert key already in map\";\n-      end if;\n-   end Insert;\n-\n-   --------------\n-   -- Is_Empty --\n-   --------------\n-\n-   function Is_Empty (Container : Map) return Boolean is\n-   begin\n-      return Length (Container) = 0;\n-   end Is_Empty;\n-\n-   ---------\n-   -- Key --\n-   ---------\n-\n-   function Key (Container : Map; Position : Cursor) return Key_Type is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with\n-           \"Position cursor of function Key has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container, Position), \"bad cursor in function Key\");\n-\n-      return Container.Content.Nodes (Position.Node).Key;\n-   end Key;\n-\n-   ------------\n-   -- Length --\n-   ------------\n-\n-   function Length (Container : Map) return Count_Type is\n-   begin\n-      return Container.Content.Length;\n-   end Length;\n-\n-   ----------\n-   -- Move --\n-   ----------\n-\n-   procedure Move\n-     (Target : in out Map;\n-      Source : in out Map)\n-   is\n-      NN : HT_Types.Nodes_Type renames Source.Content.Nodes;\n-      X  : Count_Type;\n-      Y  : Count_Type;\n-\n-   begin\n-      if Target.Capacity < Length (Source) then\n-         raise Constraint_Error with  -- ???\n-           \"Source length exceeds Target capacity\";\n-      end if;\n-\n-      Clear (Target);\n-\n-      if Source.Content.Length = 0 then\n-         return;\n-      end if;\n-\n-      X := HT_Ops.First (Source.Content);\n-      while X /= 0 loop\n-         Insert (Target, NN (X).Key, NN (X).Element);  -- optimize???\n-\n-         Y := HT_Ops.Next (Source.Content, X);\n-\n-         HT_Ops.Delete_Node_Sans_Free (Source.Content, X);\n-         Free (Source, X);\n-\n-         X := Y;\n-      end loop;\n-   end Move;\n-\n-   ----------\n-   -- Next --\n-   ----------\n-\n-   function Next (Node : Node_Type) return Count_Type is\n-   begin\n-      return Node.Next;\n-   end Next;\n-\n-   function Next (Container : Map; Position : Cursor) return Cursor is\n-   begin\n-      if Position.Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container, Position), \"bad cursor in function Next\");\n-\n-      declare\n-         Node : constant Count_Type :=\n-           HT_Ops.Next (Container.Content, Position.Node);\n-\n-      begin\n-         if Node = 0 then\n-            return No_Element;\n-         end if;\n-\n-         return (Node => Node);\n-      end;\n-   end Next;\n-\n-   procedure Next (Container : Map; Position : in out Cursor) is\n-   begin\n-      Position := Next (Container, Position);\n-   end Next;\n-\n-   ---------------\n-   -- Reference --\n-   ---------------\n-\n-   function Reference\n-     (Container : not null access Map;\n-      Position  : Cursor) return not null access Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container.all, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container.all, Position), \"bad cursor in function Reference\");\n-\n-      return Container.Content.Nodes (Position.Node).Element'Access;\n-   end Reference;\n-\n-   function Reference\n-     (Container : not null access Map;\n-      Key       : Key_Type) return not null access Element_Type\n-   is\n-      Node : constant Count_Type := Find (Container.all, Key).Node;\n-\n-   begin\n-      if Node = 0 then\n-         raise Constraint_Error with\n-           \"no element available because key not in map\";\n-      end if;\n-\n-      return Container.Content.Nodes (Node).Element'Access;\n-   end Reference;\n-\n-   -------------\n-   -- Replace --\n-   -------------\n-\n-   procedure Replace\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type)\n-   is\n-      Node : constant Count_Type := Key_Ops.Find (Container.Content, Key);\n-\n-   begin\n-      if Node = 0 then\n-         raise Constraint_Error with \"attempt to replace key not in map\";\n-      end if;\n-\n-      declare\n-         N : Node_Type renames Container.Content.Nodes (Node);\n-      begin\n-         N.Key := Key;\n-         N.Element := New_Item;\n-      end;\n-   end Replace;\n-\n-   ---------------------\n-   -- Replace_Element --\n-   ---------------------\n-\n-   procedure Replace_Element\n-     (Container : in out Map;\n-      Position  : Cursor;\n-      New_Item  : Element_Type)\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with\n-           \"Position cursor of Replace_Element has no element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container, Position), \"bad cursor in Replace_Element\");\n-\n-      Container.Content.Nodes (Position.Node).Element := New_Item;\n-   end Replace_Element;\n-\n-   ----------------------\n-   -- Reserve_Capacity --\n-   ----------------------\n-\n-   procedure Reserve_Capacity\n-     (Container : in out Map;\n-      Capacity  : Count_Type)\n-   is\n-   begin\n-      if Capacity > Container.Capacity then\n-         raise Capacity_Error with \"requested capacity is too large\";\n-      end if;\n-   end Reserve_Capacity;\n-\n-   --------------\n-   -- Set_Next --\n-   --------------\n-\n-   procedure Set_Next (Node : in out Node_Type; Next : Count_Type) is\n-   begin\n-      Node.Next := Next;\n-   end Set_Next;\n-\n-   ---------\n-   -- Vet --\n-   ---------\n-\n-   function Vet (Container : Map; Position : Cursor) return Boolean is\n-   begin\n-      if not Container_Checks'Enabled then\n-         return True;\n-      end if;\n-\n-      if Position.Node = 0 then\n-         return True;\n-      end if;\n-\n-      declare\n-         X : Count_Type;\n-\n-      begin\n-         if Container.Content.Length = 0 then\n-            return False;\n-         end if;\n-\n-         if Container.Capacity = 0 then\n-            return False;\n-         end if;\n-\n-         if Container.Content.Buckets'Length = 0 then\n-            return False;\n-         end if;\n-\n-         if Position.Node > Container.Capacity then\n-            return False;\n-         end if;\n-\n-         if Container.Content.Nodes (Position.Node).Next = Position.Node then\n-            return False;\n-         end if;\n-\n-         X :=\n-           Container.Content.Buckets\n-             (Key_Ops.Index\n-                (Container.Content,\n-                 Container.Content.Nodes (Position.Node).Key));\n-\n-         for J in 1 .. Container.Content.Length loop\n-            if X = Position.Node then\n-               return True;\n-            end if;\n-\n-            if X = 0 then\n-               return False;\n-            end if;\n-\n-            if X = Container.Content.Nodes (X).Next then\n-\n-               --  Prevent unnecessary looping\n-\n-               return False;\n-            end if;\n-\n-            X := Container.Content.Nodes (X).Next;\n-         end loop;\n-\n-         return False;\n-      end;\n-   end Vet;\n-\n-end Ada.Containers.Formal_Hashed_Maps;"}, {"sha": "42c7fbd896b158bd43d65d3f8f6e41583c6ee2f6", "filename": "gcc/ada/libgnat/a-cfhama.ads", "status": "modified", "additions": 5, "deletions": 878, "changes": 883, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cfhama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cfhama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfhama.ads?ref=4a7312f7ce189783a2cb5318bdcf50e8148b909d", "patch": "@@ -29,885 +29,12 @@\n -- <http://www.gnu.org/licenses/>.                                          --\n ------------------------------------------------------------------------------\n \n---  This spec is derived from package Ada.Containers.Bounded_Hashed_Maps in the\n---  Ada 2012 RM. The modifications are meant to facilitate formal proofs by\n---  making it easier to express properties, and by making the specification of\n---  this unit compatible with SPARK 2014. Note that the API of this unit may be\n---  subject to incompatible changes as SPARK 2014 evolves.\n-\n---  The modifications are:\n-\n---    A parameter for the container is added to every function reading the\n---    contents of a container: Key, Element, Next, Query_Element, Has_Element,\n---    Iterate, Equivalent_Keys. This change is motivated by the need to have\n---    cursors which are valid on different containers (typically a container C\n---    and its previous version C'Old) for expressing properties, which is not\n---    possible if cursors encapsulate an access to the underlying container.\n-\n---  Iteration over maps is done using the Iterable aspect, which is SPARK\n---  compatible. \"For of\" iteration ranges over keys instead of elements.\n-\n-with Ada.Containers.Functional_Vectors;\n-with Ada.Containers.Functional_Maps;\n-private with Ada.Containers.Hash_Tables;\n-\n generic\n-   type Key_Type is private;\n-   type Element_Type is private;\n-\n-   with function Hash (Key : Key_Type) return Hash_Type;\n-   with function Equivalent_Keys\n-     (Left  : Key_Type;\n-      Right : Key_Type) return Boolean is \"=\";\n-   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n-\n-package Ada.Containers.Formal_Hashed_Maps with\n-  SPARK_Mode,\n-  Annotate => (GNATprove, Always_Return)\n-is\n-\n-   --  Contracts in this unit are meant for analysis only, not for run-time\n-   --  checking.\n-\n-   pragma Assertion_Policy (Pre => Ignore);\n-   pragma Assertion_Policy (Post => Ignore);\n-   pragma Assertion_Policy (Contract_Cases => Ignore);\n-   pragma Annotate (CodePeer, Skip_Analysis);\n-\n-   type Map (Capacity : Count_Type; Modulus : Hash_Type) is private with\n-     Iterable => (First       => First,\n-                  Next        => Next,\n-                  Has_Element => Has_Element,\n-                  Element     => Key),\n-     Default_Initial_Condition => Is_Empty (Map);\n-   pragma Preelaborable_Initialization (Map);\n-\n-   Empty_Map : constant Map;\n-\n-   type Cursor is record\n-      Node : Count_Type;\n-   end record;\n-\n-   No_Element : constant Cursor := (Node => 0);\n-\n-   function Length (Container : Map) return Count_Type with\n-     Global => null,\n-     Post   => Length'Result <= Container.Capacity;\n-\n-   pragma Unevaluated_Use_Of_Old (Allow);\n-\n-   package Formal_Model with Ghost is\n-      subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n-\n-      package M is new Ada.Containers.Functional_Maps\n-        (Element_Type    => Element_Type,\n-         Key_Type        => Key_Type,\n-         Equivalent_Keys => Equivalent_Keys);\n-\n-      function \"=\"\n-        (Left  : M.Map;\n-         Right : M.Map) return Boolean renames M.\"=\";\n-\n-      function \"<=\"\n-        (Left  : M.Map;\n-         Right : M.Map) return Boolean renames M.\"<=\";\n-\n-      package K is new Ada.Containers.Functional_Vectors\n-        (Element_Type => Key_Type,\n-         Index_Type   => Positive_Count_Type);\n-\n-      function \"=\"\n-        (Left  : K.Sequence;\n-         Right : K.Sequence) return Boolean renames K.\"=\";\n-\n-      function \"<\"\n-        (Left  : K.Sequence;\n-         Right : K.Sequence) return Boolean renames K.\"<\";\n-\n-      function \"<=\"\n-        (Left  : K.Sequence;\n-         Right : K.Sequence) return Boolean renames K.\"<=\";\n-\n-      function Find (Container : K.Sequence; Key : Key_Type) return Count_Type\n-      --  Search for Key in Container\n-\n-      with\n-        Global => null,\n-        Post =>\n-          (if Find'Result > 0 then\n-              Find'Result <= K.Length (Container)\n-                and Equivalent_Keys (Key, K.Get (Container, Find'Result)));\n-\n-      function K_Keys_Included\n-        (Left  : K.Sequence;\n-         Right : K.Sequence) return Boolean\n-      --  Return True if Right contains all the keys of Left\n-\n-      with\n-        Global => null,\n-        Post   =>\n-          K_Keys_Included'Result =\n-            (for all I in 1 .. K.Length (Left) =>\n-              Find (Right, K.Get (Left, I)) > 0\n-                and then K.Get (Right, Find (Right, K.Get (Left, I))) =\n-                         K.Get (Left, I));\n-\n-      package P is new Ada.Containers.Functional_Maps\n-        (Key_Type                       => Cursor,\n-         Element_Type                   => Positive_Count_Type,\n-         Equivalent_Keys                => \"=\",\n-         Enable_Handling_Of_Equivalence => False);\n-\n-      function \"=\"\n-        (Left  : P.Map;\n-         Right : P.Map) return Boolean renames P.\"=\";\n-\n-      function \"<=\"\n-        (Left  : P.Map;\n-         Right : P.Map) return Boolean renames P.\"<=\";\n-\n-      function Mapping_Preserved\n-        (K_Left  : K.Sequence;\n-         K_Right : K.Sequence;\n-         P_Left  : P.Map;\n-         P_Right : P.Map) return Boolean\n-      with\n-        Global => null,\n-        Post   =>\n-          (if Mapping_Preserved'Result then\n-\n-             --  Right contains all the cursors of Left\n-\n-             P.Keys_Included (P_Left, P_Right)\n-\n-               --  Right contains all the keys of Left\n-\n-               and K_Keys_Included (K_Left, K_Right)\n-\n-               --  Mappings from cursors to elements induced by K_Left, P_Left\n-               --  and K_Right, P_Right are the same.\n-\n-               and (for all C of P_Left =>\n-                     K.Get (K_Left, P.Get (P_Left, C)) =\n-                     K.Get (K_Right, P.Get (P_Right, C))));\n-\n-      function Model (Container : Map) return M.Map with\n-      --  The high-level model of a map is a map from keys to elements. Neither\n-      --  cursors nor order of elements are represented in this model. Keys are\n-      --  modeled up to equivalence.\n-\n-        Ghost,\n-        Global => null;\n-\n-      function Keys (Container : Map) return K.Sequence with\n-      --  The Keys sequence represents the underlying list structure of maps\n-      --  that is used for iteration. It stores the actual values of keys in\n-      --  the map. It does not model cursors nor elements.\n-\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          K.Length (Keys'Result) = Length (Container)\n-\n-            --  It only contains keys contained in Model\n-\n-            and (for all Key of Keys'Result =>\n-                  M.Has_Key (Model (Container), Key))\n-\n-            --  It contains all the keys contained in Model\n-\n-            and (for all Key of Model (Container) =>\n-                  (Find (Keys'Result, Key) > 0\n-                    and then Equivalent_Keys\n-                               (K.Get (Keys'Result, Find (Keys'Result, Key)),\n-                                Key)))\n-\n-            --  It has no duplicate\n-\n-            and (for all I in 1 .. Length (Container) =>\n-                  Find (Keys'Result, K.Get (Keys'Result, I)) = I)\n-\n-            and (for all I in 1 .. Length (Container) =>\n-                  (for all J in 1 .. Length (Container) =>\n-                    (if Equivalent_Keys\n-                          (K.Get (Keys'Result, I), K.Get (Keys'Result, J))\n-                     then\n-                        I = J)));\n-      pragma Annotate (GNATprove, Iterable_For_Proof, \"Model\", Keys);\n-\n-      function Positions (Container : Map) return P.Map with\n-      --  The Positions map is used to model cursors. It only contains valid\n-      --  cursors and maps them to their position in the container.\n-\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          not P.Has_Key (Positions'Result, No_Element)\n-\n-            --  Positions of cursors are smaller than the container's length\n-\n-            and then\n-              (for all I of Positions'Result =>\n-                P.Get (Positions'Result, I) in 1 .. Length (Container)\n-\n-            --  No two cursors have the same position. Note that we do not\n-            --  state that there is a cursor in the map for each position, as\n-            --  it is rarely needed.\n-\n-            and then\n-              (for all J of Positions'Result =>\n-                (if P.Get (Positions'Result, I) = P.Get (Positions'Result, J)\n-                 then I = J)));\n-\n-      procedure Lift_Abstraction_Level (Container : Map) with\n-        --  Lift_Abstraction_Level is a ghost procedure that does nothing but\n-        --  assume that we can access the same elements by iterating over\n-        --  positions or cursors.\n-        --  This information is not generally useful except when switching from\n-        --  a low-level, cursor-aware view of a container, to a high-level,\n-        --  position-based view.\n-\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          (for all Key of Keys (Container) =>\n-            (for some I of Positions (Container) =>\n-              K.Get (Keys (Container), P.Get (Positions (Container), I)) =\n-                Key));\n-\n-      function Contains\n-        (C : M.Map;\n-         K : Key_Type) return Boolean renames M.Has_Key;\n-      --  To improve readability of contracts, we rename the function used to\n-      --  search for a key in the model to Contains.\n-\n-      function Element\n-        (C : M.Map;\n-         K : Key_Type) return Element_Type renames M.Get;\n-      --  To improve readability of contracts, we rename the function used to\n-      --  access an element in the model to Element.\n-\n-   end Formal_Model;\n-   use Formal_Model;\n-\n-   function \"=\" (Left, Right : Map) return Boolean with\n-     Global => null,\n-     Post   => \"=\"'Result = (Model (Left) = Model (Right));\n-\n-   function Capacity (Container : Map) return Count_Type with\n-     Global => null,\n-     Post   => Capacity'Result = Container.Capacity;\n-\n-   procedure Reserve_Capacity\n-     (Container : in out Map;\n-      Capacity  : Count_Type)\n-   with\n-     Global => null,\n-     Pre    => Capacity <= Container.Capacity,\n-     Post   =>\n-       Model (Container) = Model (Container)'Old\n-         and Length (Container)'Old = Length (Container)\n-\n-         --  Actual keys are preserved\n-\n-         and K_Keys_Included (Keys (Container), Keys (Container)'Old)\n-         and K_Keys_Included (Keys (Container)'Old, Keys (Container));\n-\n-   function Is_Empty (Container : Map) return Boolean with\n-     Global => null,\n-     Post   => Is_Empty'Result = (Length (Container) = 0);\n-\n-   procedure Clear (Container : in out Map) with\n-     Global => null,\n-     Post   => Length (Container) = 0 and M.Is_Empty (Model (Container));\n-\n-   procedure Assign (Target : in out Map; Source : Map) with\n-     Global => null,\n-     Pre    => Target.Capacity >= Length (Source),\n-     Post   =>\n-       Model (Target) = Model (Source)\n-         and Length (Source) = Length (Target)\n-\n-         --  Actual keys are preserved\n-\n-         and K_Keys_Included (Keys (Target), Keys (Source))\n-         and K_Keys_Included (Keys (Source), Keys (Target));\n-\n-   function Copy\n-     (Source   : Map;\n-      Capacity : Count_Type := 0) return Map\n-   with\n-     Global => null,\n-     Pre    => Capacity = 0 or else Capacity >= Source.Capacity,\n-     Post   =>\n-       Model (Copy'Result) = Model (Source)\n-         and Keys (Copy'Result) = Keys (Source)\n-         and Positions (Copy'Result) = Positions (Source)\n-         and (if Capacity = 0 then\n-                 Copy'Result.Capacity = Source.Capacity\n-              else\n-                 Copy'Result.Capacity = Capacity);\n-   --  Copy returns a container stricty equal to Source. It must have the same\n-   --  cursors associated with each element. Therefore:\n-   --  - capacity=0 means use Source.Capacity as capacity of target\n-   --  - the modulus cannot be changed.\n-\n-   function Key (Container : Map; Position : Cursor) return Key_Type with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Key'Result =\n-         K.Get (Keys (Container), P.Get (Positions (Container), Position));\n-   pragma Annotate (GNATprove, Inline_For_Proof, Key);\n-\n-   function Element\n-     (Container : Map;\n-      Position  : Cursor) return Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Element'Result = Element (Model (Container), Key (Container, Position));\n-   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n-\n-   procedure Replace_Element\n-     (Container : in out Map;\n-      Position  : Cursor;\n-      New_Item  : Element_Type)\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-\n-       --  Order of keys and cursors is preserved\n-\n-       Keys (Container) = Keys (Container)'Old\n-         and Positions (Container) = Positions (Container)'Old\n-\n-         --  New_Item is now associated with the key at position Position in\n-         --  Container.\n-\n-         and Element (Container, Position) = New_Item\n-\n-         --  Elements associated with other keys are preserved\n-\n-         and M.Same_Keys (Model (Container), Model (Container)'Old)\n-         and M.Elements_Equal_Except\n-               (Model (Container),\n-                Model (Container)'Old,\n-                Key (Container, Position));\n-\n-   function At_End\n-     (E : not null access constant Map) return not null access constant Map\n-   is (E)\n-   with Ghost,\n-     Annotate => (GNATprove, At_End_Borrow);\n-\n-   function At_End\n-     (E : access constant Element_Type) return access constant Element_Type\n-   is (E)\n-   with Ghost,\n-     Annotate => (GNATprove, At_End_Borrow);\n-\n-   function Constant_Reference\n-     (Container : aliased Map;\n-      Position  : Cursor) return not null access constant Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Constant_Reference'Result.all =\n-           Element (Model (Container), Key (Container, Position));\n-\n-   function Reference\n-     (Container : not null access Map;\n-      Position  : Cursor) return not null access Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container.all, Position),\n-     Post   =>\n-\n-       --  Order of keys and cursors is preserved\n-\n-       Keys (At_End (Container).all) = Keys (Container.all)\n-         and Positions (At_End (Container).all) = Positions (Container.all)\n-\n-         --  The value designated by the result of Reference is now associated\n-         --  with the key at position Position in Container.\n-\n-         and Element (At_End (Container).all, Position) =\n-               At_End (Reference'Result).all\n-\n-         --  Elements associated with other keys are preserved\n-\n-         and M.Same_Keys\n-               (Model (At_End (Container).all),\n-                Model (Container.all))\n-         and M.Elements_Equal_Except\n-               (Model (At_End (Container).all),\n-                Model (Container.all),\n-                Key (At_End (Container).all, Position));\n-\n-   function Constant_Reference\n-     (Container : aliased Map;\n-      Key       : Key_Type) return not null access constant Element_Type\n-   with\n-     Global => null,\n-     Pre    => Contains (Container, Key),\n-     Post   =>\n-       Constant_Reference'Result.all = Element (Model (Container), Key);\n-\n-   function Reference\n-     (Container : not null access Map;\n-      Key       : Key_Type) return not null access Element_Type\n-   with\n-     Global => null,\n-     Pre    => Contains (Container.all, Key),\n-     Post   =>\n-\n-       --  Order of keys and cursors is preserved\n-\n-       Keys (At_End (Container).all) = Keys (Container.all)\n-         and Positions (At_End (Container).all) = Positions (Container.all)\n-\n-         --  The value designated by the result of Reference is now associated\n-         --  with Key in Container.\n-\n-         and Element (Model (At_End (Container).all), Key) =\n-               At_End (Reference'Result).all\n-\n-         --  Elements associated with other keys are preserved\n-\n-         and M.Same_Keys\n-               (Model (At_End (Container).all),\n-                Model (Container.all))\n-         and M.Elements_Equal_Except\n-               (Model (At_End (Container).all),\n-                Model (Container.all),\n-                Key);\n-\n-   procedure Move (Target : in out Map; Source : in out Map) with\n-     Global => null,\n-     Pre    => Target.Capacity >= Length (Source),\n-     Post   =>\n-       Model (Target) = Model (Source)'Old\n-         and Length (Source)'Old = Length (Target)\n-         and Length (Source) = 0\n-\n-         --  Actual keys are preserved\n-\n-         and K_Keys_Included (Keys (Target), Keys (Source)'Old)\n-         and K_Keys_Included (Keys (Source)'Old, Keys (Target));\n-\n-   procedure Insert\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor;\n-      Inserted  : out Boolean)\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Length (Container) < Container.Capacity or Contains (Container, Key),\n-     Post           =>\n-       Contains (Container, Key)\n-         and Has_Element (Container, Position)\n-         and Equivalent_Keys\n-               (Formal_Hashed_Maps.Key (Container, Position), Key),\n-     Contract_Cases =>\n-\n-       --  If Key is already in Container, it is not modified and Inserted is\n-       --  set to False.\n-\n-       (Contains (Container, Key) =>\n-          not Inserted\n-            and Model (Container) = Model (Container)'Old\n-            and Keys (Container) = Keys (Container)'Old\n-            and Positions (Container) = Positions (Container)'Old,\n-\n-        --  Otherwise, Key is inserted in Container and Inserted is set to True\n-\n-        others =>\n-          Inserted\n-            and Length (Container) = Length (Container)'Old + 1\n-\n-            --  Key now maps to New_Item\n-\n-            and Formal_Hashed_Maps.Key (Container, Position) = Key\n-            and Element (Model (Container), Key) = New_Item\n-\n-            --  Other keys are preserved\n-\n-            and Model (Container)'Old <= Model (Container)\n-            and M.Keys_Included_Except\n-                  (Model (Container),\n-                   Model (Container)'Old,\n-                   Key)\n-\n-            --  Mapping from cursors to keys is preserved\n-\n-            and Mapping_Preserved\n-                  (K_Left  => Keys (Container)'Old,\n-                   K_Right => Keys (Container),\n-                   P_Left  => Positions (Container)'Old,\n-                   P_Right => Positions (Container))\n-            and P.Keys_Included_Except\n-                  (Positions (Container),\n-                   Positions (Container)'Old,\n-                   Position));\n-\n-   procedure Insert\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type)\n-   with\n-     Global => null,\n-     Pre    =>\n-       Length (Container) < Container.Capacity\n-        and then (not Contains (Container, Key)),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + 1\n-         and Contains (Container, Key)\n-\n-         --  Key now maps to New_Item\n-\n-         and Formal_Hashed_Maps.Key (Container, Find (Container, Key)) = Key\n-         and Element (Model (Container), Key) = New_Item\n-\n-         --  Other keys are preserved\n-\n-         and Model (Container)'Old <= Model (Container)\n-         and M.Keys_Included_Except\n-               (Model (Container),\n-                Model (Container)'Old,\n-                Key)\n-\n-         --  Mapping from cursors to keys is preserved\n-\n-         and Mapping_Preserved\n-               (K_Left  => Keys (Container)'Old,\n-                K_Right => Keys (Container),\n-                P_Left  => Positions (Container)'Old,\n-                P_Right => Positions (Container))\n-         and P.Keys_Included_Except\n-               (Positions (Container),\n-                Positions (Container)'Old,\n-                Find (Container, Key));\n-\n-   procedure Include\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type)\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Length (Container) < Container.Capacity or Contains (Container, Key),\n-     Post           =>\n-       Contains (Container, Key) and Element (Container, Key) = New_Item,\n-     Contract_Cases =>\n-\n-       --  If Key is already in Container, Key is mapped to New_Item\n-\n-       (Contains (Container, Key) =>\n-\n-          --  Cursors are preserved\n-\n-          Positions (Container) = Positions (Container)'Old\n-\n-            --  The key equivalent to Key in Container is replaced by Key\n-\n-            and K.Get\n-                  (Keys (Container),\n-                   P.Get (Positions (Container), Find (Container, Key))) = Key\n-            and K.Equal_Except\n-                  (Keys (Container)'Old,\n-                   Keys (Container),\n-                   P.Get (Positions (Container), Find (Container, Key)))\n-\n-            --  Elements associated with other keys are preserved\n-\n-            and M.Same_Keys (Model (Container), Model (Container)'Old)\n-            and M.Elements_Equal_Except\n-                  (Model (Container),\n-                   Model (Container)'Old,\n-                   Key),\n-\n-        --  Otherwise, Key is inserted in Container\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old + 1\n-\n-            --  Other keys are preserved\n-\n-            and Model (Container)'Old <= Model (Container)\n-            and M.Keys_Included_Except\n-                  (Model (Container),\n-                   Model (Container)'Old,\n-                   Key)\n-\n-            --  Key is inserted in Container\n-\n-            and K.Get\n-                  (Keys (Container),\n-                   P.Get (Positions (Container), Find (Container, Key))) = Key\n-\n-            --  Mapping from cursors to keys is preserved\n-\n-            and Mapping_Preserved\n-                  (K_Left  => Keys (Container)'Old,\n-                   K_Right => Keys (Container),\n-                   P_Left  => Positions (Container)'Old,\n-                   P_Right => Positions (Container))\n-            and P.Keys_Included_Except\n-                  (Positions (Container),\n-                   Positions (Container)'Old,\n-                   Find (Container, Key)));\n-\n-   procedure Replace\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type)\n-   with\n-     Global => null,\n-     Pre    => Contains (Container, Key),\n-     Post   =>\n-\n-       --  Cursors are preserved\n-\n-       Positions (Container) = Positions (Container)'Old\n-\n-         --  The key equivalent to Key in Container is replaced by Key\n-\n-         and K.Get\n-               (Keys (Container),\n-                P.Get (Positions (Container), Find (Container, Key))) = Key\n-         and K.Equal_Except\n-               (Keys (Container)'Old,\n-                Keys (Container),\n-                P.Get (Positions (Container), Find (Container, Key)))\n-\n-         --  New_Item is now associated with the Key in Container\n-\n-         and Element (Model (Container), Key) = New_Item\n-\n-         --  Elements associated with other keys are preserved\n-\n-         and M.Same_Keys (Model (Container), Model (Container)'Old)\n-         and M.Elements_Equal_Except\n-               (Model (Container),\n-                Model (Container)'Old,\n-                Key);\n-\n-   procedure Exclude (Container : in out Map; Key : Key_Type) with\n-     Global         => null,\n-     Post           => not Contains (Container, Key),\n-     Contract_Cases =>\n-\n-       --  If Key is not in Container, nothing is changed\n-\n-       (not Contains (Container, Key) =>\n-          Model (Container) = Model (Container)'Old\n-            and Keys (Container) = Keys (Container)'Old\n-            and Positions (Container) = Positions (Container)'Old,\n-\n-        --  Otherwise, Key is removed from Container\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old - 1\n-\n-            --  Other keys are preserved\n-\n-            and Model (Container) <= Model (Container)'Old\n-            and M.Keys_Included_Except\n-                  (Model (Container)'Old,\n-                   Model (Container),\n-                   Key)\n-\n-            --  Mapping from cursors to keys is preserved\n-\n-            and Mapping_Preserved\n-                  (K_Left  => Keys (Container),\n-                   K_Right => Keys (Container)'Old,\n-                   P_Left  => Positions (Container),\n-                   P_Right => Positions (Container)'Old)\n-            and P.Keys_Included_Except\n-                  (Positions (Container)'Old,\n-                   Positions (Container),\n-                   Find (Container, Key)'Old));\n-\n-   procedure Delete (Container : in out Map; Key : Key_Type) with\n-     Global => null,\n-     Pre    => Contains (Container, Key),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old - 1\n-\n-         --  Key is no longer in Container\n-\n-         and not Contains (Container, Key)\n-\n-         --  Other keys are preserved\n-\n-         and Model (Container) <= Model (Container)'Old\n-         and M.Keys_Included_Except\n-               (Model (Container)'Old,\n-                Model (Container),\n-                Key)\n-\n-         --  Mapping from cursors to keys is preserved\n-\n-         and Mapping_Preserved\n-               (K_Left  => Keys (Container),\n-                K_Right => Keys (Container)'Old,\n-                P_Left  => Positions (Container),\n-                P_Right => Positions (Container)'Old)\n-         and P.Keys_Included_Except\n-               (Positions (Container)'Old,\n-                Positions (Container),\n-                Find (Container, Key)'Old);\n-\n-   procedure Delete (Container : in out Map; Position : in out Cursor) with\n-     Global  => null,\n-     Depends => (Container =>+ Position, Position => null),\n-     Pre     => Has_Element (Container, Position),\n-     Post    =>\n-       Position = No_Element\n-         and Length (Container) = Length (Container)'Old - 1\n-\n-         --  The key at position Position is no longer in Container\n-\n-         and not Contains (Container, Key (Container, Position)'Old)\n-         and not P.Has_Key (Positions (Container), Position'Old)\n-\n-         --  Other keys are preserved\n-\n-         and Model (Container) <= Model (Container)'Old\n-         and M.Keys_Included_Except\n-               (Model (Container)'Old,\n-                Model (Container),\n-                Key (Container, Position)'Old)\n-\n-         --  Mapping from cursors to keys is preserved\n-\n-         and Mapping_Preserved\n-               (K_Left  => Keys (Container),\n-                K_Right => Keys (Container)'Old,\n-                P_Left  => Positions (Container),\n-                P_Right => Positions (Container)'Old)\n-         and P.Keys_Included_Except\n-               (Positions (Container)'Old,\n-                Positions (Container),\n-                Position'Old);\n-\n-   function First (Container : Map) return Cursor with\n-     Global         => null,\n-     Contract_Cases =>\n-       (Length (Container) = 0 =>\n-          First'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, First'Result)\n-            and P.Get (Positions (Container), First'Result) = 1);\n-\n-   function Next (Container : Map; Position : Cursor) return Cursor with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = Length (Container)\n-        =>\n-          Next'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Next'Result)\n-            and then P.Get (Positions (Container), Next'Result) =\n-                     P.Get (Positions (Container), Position) + 1);\n-\n-   procedure Next (Container : Map; Position : in out Cursor) with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = Length (Container)\n-        =>\n-          Position = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Position)\n-            and then P.Get (Positions (Container), Position) =\n-                     P.Get (Positions (Container), Position'Old) + 1);\n-\n-   function Find (Container : Map; Key : Key_Type) return Cursor with\n-     Global         => null,\n-     Contract_Cases =>\n-\n-       --  If Key is not contained in Container, Find returns No_Element\n-\n-       (not Contains (Model (Container), Key) =>\n-          Find'Result = No_Element,\n-\n-        --  Otherwise, Find returns a valid cursor in Container\n-\n-        others =>\n-          P.Has_Key (Positions (Container), Find'Result)\n-            and P.Get (Positions (Container), Find'Result) =\n-                Find (Keys (Container), Key)\n-\n-            --  The key designated by the result of Find is Key\n-\n-            and Equivalent_Keys\n-                  (Formal_Hashed_Maps.Key (Container, Find'Result), Key));\n-\n-   function Contains (Container : Map; Key : Key_Type) return Boolean with\n-     Global => null,\n-     Post   => Contains'Result = Contains (Model (Container), Key);\n-   pragma Annotate (GNATprove, Inline_For_Proof, Contains);\n-\n-   function Element (Container : Map; Key : Key_Type) return Element_Type with\n-     Global => null,\n-     Pre    => Contains (Container, Key),\n-     Post   => Element'Result = Element (Model (Container), Key);\n-   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n-\n-   function Has_Element (Container : Map; Position : Cursor) return Boolean\n-   with\n-     Global => null,\n-     Post   =>\n-       Has_Element'Result = P.Has_Key (Positions (Container), Position);\n-   pragma Annotate (GNATprove, Inline_For_Proof, Has_Element);\n-\n-   function Default_Modulus (Capacity : Count_Type) return Hash_Type with\n-     Global => null;\n-\n-private\n-   pragma SPARK_Mode (Off);\n-\n-   pragma Inline (Length);\n-   pragma Inline (Is_Empty);\n-   pragma Inline (Clear);\n-   pragma Inline (Key);\n-   pragma Inline (Element);\n-   pragma Inline (Contains);\n-   pragma Inline (Capacity);\n-   pragma Inline (Has_Element);\n-   pragma Inline (Equivalent_Keys);\n-   pragma Inline (Next);\n-\n-   type Node_Type is record\n-      Key         : Key_Type;\n-      Element     : aliased Element_Type;\n-      Next        : Count_Type;\n-      Has_Element : Boolean := False;\n-   end record;\n-\n-   package HT_Types is new\n-     Ada.Containers.Hash_Tables.Generic_Formal_Hash_Table_Types (Node_Type);\n-\n-   type Map (Capacity : Count_Type; Modulus : Hash_Type) is record\n-     Content : HT_Types.Hash_Table_Type (Capacity, Modulus);\n-   end record;\n+package Ada.Containers.Formal_Hashed_Maps with SPARK_Mode is\n \n-   Empty_Map : constant Map := (Capacity => 0, Modulus => 0, others => <>);\n+   pragma Compile_Time_Error\n+     (True,\n+      \"This package has been moved to the SPARK library shipped with any\"\n+      & \" SPARK release starting with version 23.\");\n \n end Ada.Containers.Formal_Hashed_Maps;"}, {"sha": "34afa554c5f7068cfddb35732e5b02f8024d8c8c", "filename": "gcc/ada/libgnat/a-cfhase.adb", "status": "removed", "additions": 0, "deletions": 1559, "changes": 1559, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cfhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cfhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfhase.adb?ref=cf8af60f6a3910577e99db04dbc757e731558144", "patch": "@@ -1,1559 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT LIBRARY COMPONENTS                          --\n---                                                                          --\n---    A D A . C O N T A I N E R S . F O R M A L _ H A S H E D _ S E T S     --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2010-2022, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Containers.Hash_Tables.Generic_Formal_Operations;\n-pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Formal_Operations);\n-\n-with Ada.Containers.Hash_Tables.Generic_Formal_Keys;\n-pragma Elaborate_All (Ada.Containers.Hash_Tables.Generic_Formal_Keys);\n-\n-with Ada.Containers.Prime_Numbers; use Ada.Containers.Prime_Numbers;\n-\n-with System; use type System.Address;\n-\n-package body Ada.Containers.Formal_Hashed_Sets with\n-  SPARK_Mode => Off\n-is\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   --  All need comments ???\n-\n-   procedure Difference (Left : Set; Right : Set; Target : in out Set);\n-\n-   function Equivalent_Keys\n-     (Key  : Element_Type;\n-      Node : Node_Type) return Boolean;\n-   pragma Inline (Equivalent_Keys);\n-\n-   procedure Free\n-     (HT : in out Set;\n-      X  : Count_Type);\n-\n-   generic\n-      with procedure Set_Element (Node : in out Node_Type);\n-   procedure Generic_Allocate\n-     (HT   : in out Hash_Table_Type;\n-      Node : out Count_Type);\n-\n-   function Hash_Node (Node : Node_Type) return Hash_Type;\n-   pragma Inline (Hash_Node);\n-\n-   procedure Insert\n-     (Container : in out Set;\n-      New_Item  : Element_Type;\n-      Node      : out Count_Type;\n-      Inserted  : out Boolean);\n-\n-   procedure Intersection\n-     (Left   : Set;\n-      Right  : Set;\n-      Target : in out Set);\n-\n-   function Is_In\n-     (HT  : Set;\n-      Key : Node_Type) return Boolean;\n-   pragma Inline (Is_In);\n-\n-   procedure Set_Element (Node : in out Node_Type; Item : Element_Type);\n-   pragma Inline (Set_Element);\n-\n-   function Next (Node : Node_Type) return Count_Type;\n-   pragma Inline (Next);\n-\n-   procedure Set_Next (Node : in out Node_Type; Next : Count_Type);\n-   pragma Inline (Set_Next);\n-\n-   function Vet (Container : Set; Position : Cursor) return Boolean\n-     with Inline;\n-\n-   --------------------------\n-   -- Local Instantiations --\n-   --------------------------\n-\n-   package HT_Ops is new Hash_Tables.Generic_Formal_Operations\n-     (HT_Types  => HT_Types,\n-      Hash_Node => Hash_Node,\n-      Next      => Next,\n-      Set_Next  => Set_Next);\n-\n-   package Element_Keys is new Hash_Tables.Generic_Formal_Keys\n-     (HT_Types        => HT_Types,\n-      Next            => Next,\n-      Set_Next        => Set_Next,\n-      Key_Type        => Element_Type,\n-      Hash            => Hash,\n-      Equivalent_Keys => Equivalent_Keys);\n-\n-   procedure Replace_Element is\n-     new Element_Keys.Generic_Replace_Element (Hash_Node, Set_Element);\n-\n-   ---------\n-   -- \"=\" --\n-   ---------\n-\n-   function \"=\" (Left, Right : Set) return Boolean is\n-   begin\n-      if Length (Left) /= Length (Right) then\n-         return False;\n-      end if;\n-\n-      if Length (Left) = 0 then\n-         return True;\n-      end if;\n-\n-      declare\n-         Node  : Count_Type;\n-         ENode : Count_Type;\n-\n-      begin\n-         Node  := First (Left).Node;\n-         while Node /= 0 loop\n-            ENode :=\n-              Find\n-                (Container => Right,\n-                 Item      => Left.Content.Nodes (Node).Element).Node;\n-\n-            if ENode = 0\n-              or else Right.Content.Nodes (ENode).Element /=\n-              Left.Content.Nodes (Node).Element\n-            then\n-               return False;\n-            end if;\n-\n-            Node := HT_Ops.Next (Left.Content, Node);\n-         end loop;\n-\n-         return True;\n-      end;\n-   end \"=\";\n-\n-   ------------\n-   -- Assign --\n-   ------------\n-\n-   procedure Assign (Target : in out Set; Source : Set) is\n-      procedure Insert_Element (Source_Node : Count_Type);\n-\n-      procedure Insert_Elements is\n-        new HT_Ops.Generic_Iteration (Insert_Element);\n-\n-      --------------------\n-      -- Insert_Element --\n-      --------------------\n-\n-      procedure Insert_Element (Source_Node : Count_Type) is\n-         N        : Node_Type renames Source.Content.Nodes (Source_Node);\n-         Unused_X : Count_Type;\n-         B        : Boolean;\n-\n-      begin\n-         Insert (Target, N.Element, Unused_X, B);\n-         pragma Assert (B);\n-      end Insert_Element;\n-\n-   --  Start of processing for Assign\n-\n-   begin\n-      if Target.Capacity < Length (Source) then\n-         raise Storage_Error with \"not enough capacity\";  -- SE or CE? ???\n-      end if;\n-\n-      HT_Ops.Clear (Target.Content);\n-      Insert_Elements (Source.Content);\n-   end Assign;\n-\n-   --------------\n-   -- Capacity --\n-   --------------\n-\n-   function Capacity (Container : Set) return Count_Type is\n-   begin\n-      return Container.Content.Nodes'Length;\n-   end Capacity;\n-\n-   -----------\n-   -- Clear --\n-   -----------\n-\n-   procedure Clear (Container : in out Set) is\n-   begin\n-      HT_Ops.Clear (Container.Content);\n-   end Clear;\n-\n-   ------------------------\n-   -- Constant_Reference --\n-   ------------------------\n-\n-   function Constant_Reference\n-     (Container : aliased Set;\n-      Position  : Cursor) return not null access constant Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor equals No_Element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container, Position), \"bad cursor in function Element\");\n-\n-      return Container.Content.Nodes (Position.Node).Element'Access;\n-   end Constant_Reference;\n-\n-   --------------\n-   -- Contains --\n-   --------------\n-\n-   function Contains (Container : Set; Item : Element_Type) return Boolean is\n-   begin\n-      return Find (Container, Item) /= No_Element;\n-   end Contains;\n-\n-   ----------\n-   -- Copy --\n-   ----------\n-\n-   function Copy\n-     (Source   : Set;\n-      Capacity : Count_Type := 0) return Set\n-   is\n-      C      : constant Count_Type :=\n-                 Count_Type'Max (Capacity, Source.Capacity);\n-      Cu     : Cursor;\n-      H      : Hash_Type;\n-      N      : Count_Type;\n-      Target : Set (C, Source.Modulus);\n-\n-   begin\n-      if 0 < Capacity and then Capacity < Source.Capacity then\n-         raise Capacity_Error;\n-      end if;\n-\n-      Target.Content.Length := Source.Content.Length;\n-      Target.Content.Free := Source.Content.Free;\n-\n-      H := 1;\n-      while H <= Source.Modulus loop\n-         Target.Content.Buckets (H) := Source.Content.Buckets (H);\n-         H := H + 1;\n-      end loop;\n-\n-      N := 1;\n-      while N <= Source.Capacity loop\n-         Target.Content.Nodes (N) := Source.Content.Nodes (N);\n-         N := N + 1;\n-      end loop;\n-\n-      while N <= C loop\n-         Cu := (Node => N);\n-         Free (Target, Cu.Node);\n-         N := N + 1;\n-      end loop;\n-\n-      return Target;\n-   end Copy;\n-\n-   ---------------------\n-   -- Default_Modulus --\n-   ---------------------\n-\n-   function Default_Modulus (Capacity : Count_Type) return Hash_Type is\n-   begin\n-      return To_Prime (Capacity);\n-   end Default_Modulus;\n-\n-   ------------\n-   -- Delete --\n-   ------------\n-\n-   procedure Delete (Container : in out Set; Item : Element_Type) is\n-      X : Count_Type;\n-\n-   begin\n-      Element_Keys.Delete_Key_Sans_Free (Container.Content, Item, X);\n-\n-      if X = 0 then\n-         raise Constraint_Error with \"attempt to delete element not in set\";\n-      end if;\n-\n-      Free (Container, X);\n-   end Delete;\n-\n-   procedure Delete (Container : in out Set; Position : in out Cursor) is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n-\n-      HT_Ops.Delete_Node_Sans_Free (Container.Content, Position.Node);\n-      Free (Container, Position.Node);\n-\n-      Position := No_Element;\n-   end Delete;\n-\n-   ----------------\n-   -- Difference --\n-   ----------------\n-\n-   procedure Difference (Target : in out Set; Source : Set) is\n-      Src_Last   : Count_Type;\n-      Src_Length : Count_Type;\n-      Src_Node   : Count_Type;\n-      Tgt_Node   : Count_Type;\n-\n-      TN : Nodes_Type renames Target.Content.Nodes;\n-      SN : Nodes_Type renames Source.Content.Nodes;\n-\n-   begin\n-      Src_Length := Source.Content.Length;\n-\n-      if Src_Length = 0 then\n-         return;\n-      end if;\n-\n-      if Src_Length >= Target.Content.Length then\n-         Tgt_Node := HT_Ops.First (Target.Content);\n-         while Tgt_Node /= 0 loop\n-            if Element_Keys.Find (Source.Content, TN (Tgt_Node).Element) /= 0\n-            then\n-               declare\n-                  X : constant Count_Type := Tgt_Node;\n-               begin\n-                  Tgt_Node := HT_Ops.Next (Target.Content, Tgt_Node);\n-                  HT_Ops.Delete_Node_Sans_Free (Target.Content, X);\n-                  Free (Target, X);\n-               end;\n-\n-            else\n-               Tgt_Node := HT_Ops.Next (Target.Content, Tgt_Node);\n-            end if;\n-         end loop;\n-\n-         return;\n-      else\n-         Src_Node := HT_Ops.First (Source.Content);\n-         Src_Last := 0;\n-      end if;\n-\n-      while Src_Node /= Src_Last loop\n-         Tgt_Node := Element_Keys.Find (Target.Content, SN (Src_Node).Element);\n-\n-         if Tgt_Node /= 0 then\n-            HT_Ops.Delete_Node_Sans_Free (Target.Content, Tgt_Node);\n-            Free (Target, Tgt_Node);\n-         end if;\n-\n-         Src_Node := HT_Ops.Next (Source.Content, Src_Node);\n-      end loop;\n-   end Difference;\n-\n-   procedure Difference (Left : Set; Right : Set; Target : in out Set) is\n-      procedure Process (L_Node : Count_Type);\n-\n-      procedure Iterate is\n-        new HT_Ops.Generic_Iteration (Process);\n-\n-      -------------\n-      -- Process --\n-      -------------\n-\n-      procedure Process (L_Node : Count_Type) is\n-         B        : Boolean;\n-         E        : Element_Type renames Left.Content.Nodes (L_Node).Element;\n-         Unused_X : Count_Type;\n-\n-      begin\n-         if Find (Right, E).Node = 0 then\n-            Insert (Target, E, Unused_X, B);\n-            pragma Assert (B);\n-         end if;\n-      end Process;\n-\n-   --  Start of processing for Difference\n-\n-   begin\n-      Iterate (Left.Content);\n-   end Difference;\n-\n-   function Difference (Left : Set; Right : Set) return Set is\n-   begin\n-      if Length (Left) = 0 then\n-         return Empty_Set;\n-      end if;\n-\n-      if Length (Right) = 0 then\n-         return Copy (Left);\n-      end if;\n-\n-      declare\n-         C : constant Count_Type := Length (Left);\n-         H : constant Hash_Type := Default_Modulus (C);\n-      begin\n-         return S : Set (C, H) do\n-            Difference (Left, Right, Target => S);\n-         end return;\n-      end;\n-   end Difference;\n-\n-   -------------\n-   -- Element --\n-   -------------\n-\n-   function Element\n-     (Container : Set;\n-      Position  : Cursor) return Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor equals No_Element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container, Position), \"bad cursor in function Element\");\n-\n-      return Container.Content.Nodes (Position.Node).Element;\n-   end Element;\n-\n-   ---------------------\n-   -- Equivalent_Sets --\n-   ---------------------\n-\n-   function Equivalent_Sets (Left, Right : Set) return Boolean is\n-\n-      function Find_Equivalent_Key\n-        (R_HT   : Hash_Table_Type;\n-         L_Node : Node_Type) return Boolean;\n-      pragma Inline (Find_Equivalent_Key);\n-\n-      function Is_Equivalent is\n-        new HT_Ops.Generic_Equal (Find_Equivalent_Key);\n-\n-      -------------------------\n-      -- Find_Equivalent_Key --\n-      -------------------------\n-\n-      function Find_Equivalent_Key\n-        (R_HT   : Hash_Table_Type;\n-         L_Node : Node_Type) return Boolean\n-      is\n-         R_Index : constant Hash_Type :=\n-                     Element_Keys.Index (R_HT, L_Node.Element);\n-         R_Node  : Count_Type := R_HT.Buckets (R_Index);\n-         RN      : Nodes_Type renames R_HT.Nodes;\n-\n-      begin\n-         loop\n-            if R_Node = 0 then\n-               return False;\n-            end if;\n-\n-            if Equivalent_Elements\n-                 (L_Node.Element, RN (R_Node).Element)\n-            then\n-               return True;\n-            end if;\n-\n-            R_Node := HT_Ops.Next (R_HT, R_Node);\n-         end loop;\n-      end Find_Equivalent_Key;\n-\n-   --  Start of processing for Equivalent_Sets\n-\n-   begin\n-      return Is_Equivalent (Left.Content, Right.Content);\n-   end Equivalent_Sets;\n-\n-   ---------------------\n-   -- Equivalent_Keys --\n-   ---------------------\n-\n-   function Equivalent_Keys\n-     (Key  : Element_Type;\n-      Node : Node_Type) return Boolean\n-   is\n-   begin\n-      return Equivalent_Elements (Key, Node.Element);\n-   end Equivalent_Keys;\n-\n-   -------------\n-   -- Exclude --\n-   -------------\n-\n-   procedure Exclude (Container : in out Set; Item : Element_Type) is\n-      X : Count_Type;\n-   begin\n-      Element_Keys.Delete_Key_Sans_Free (Container.Content, Item, X);\n-      Free (Container, X);\n-   end Exclude;\n-\n-   ----------\n-   -- Find --\n-   ----------\n-\n-   function Find\n-     (Container : Set;\n-      Item      : Element_Type) return Cursor\n-   is\n-      Node : constant Count_Type :=\n-        Element_Keys.Find (Container.Content, Item);\n-\n-   begin\n-      if Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Node);\n-   end Find;\n-\n-   -----------\n-   -- First --\n-   -----------\n-\n-   function First (Container : Set) return Cursor is\n-      Node : constant Count_Type := HT_Ops.First (Container.Content);\n-\n-   begin\n-      if Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Node);\n-   end First;\n-\n-   ------------------\n-   -- Formal_Model --\n-   ------------------\n-\n-   package body Formal_Model is\n-\n-      -------------------------\n-      -- E_Elements_Included --\n-      -------------------------\n-\n-      function E_Elements_Included\n-        (Left  : E.Sequence;\n-         Right : E.Sequence) return Boolean\n-      is\n-      begin\n-         for I in 1 .. E.Length (Left) loop\n-            if not E.Contains (Right, 1, E.Length (Right), E.Get (Left, I))\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end E_Elements_Included;\n-\n-      function E_Elements_Included\n-        (Left  : E.Sequence;\n-         Model : M.Set;\n-         Right : E.Sequence) return Boolean\n-      is\n-      begin\n-         for I in 1 .. E.Length (Left) loop\n-            declare\n-               Item : constant Element_Type := E.Get (Left, I);\n-            begin\n-               if M.Contains (Model, Item) then\n-                  if not E.Contains (Right, 1, E.Length (Right), Item) then\n-                     return False;\n-                  end if;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end E_Elements_Included;\n-\n-      function E_Elements_Included\n-        (Container : E.Sequence;\n-         Model     : M.Set;\n-         Left      : E.Sequence;\n-         Right     : E.Sequence) return Boolean\n-      is\n-      begin\n-         for I in 1 .. E.Length (Container) loop\n-            declare\n-               Item : constant Element_Type := E.Get (Container, I);\n-            begin\n-               if M.Contains (Model, Item) then\n-                  if not E.Contains (Left, 1, E.Length (Left), Item) then\n-                     return False;\n-                  end if;\n-               else\n-                  if not E.Contains (Right, 1, E.Length (Right), Item) then\n-                     return False;\n-                  end if;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end E_Elements_Included;\n-\n-      ----------\n-      -- Find --\n-      ----------\n-\n-      function Find\n-        (Container : E.Sequence;\n-         Item      : Element_Type) return Count_Type\n-      is\n-      begin\n-         for I in 1 .. E.Length (Container) loop\n-            if Equivalent_Elements (Item, E.Get (Container, I)) then\n-               return I;\n-            end if;\n-         end loop;\n-         return 0;\n-      end Find;\n-\n-      --------------\n-      -- Elements --\n-      --------------\n-\n-      function Elements (Container : Set) return E.Sequence is\n-         Position : Count_Type := HT_Ops.First (Container.Content);\n-         R        : E.Sequence;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R := E.Add (R, Container.Content.Nodes (Position).Element);\n-            Position := HT_Ops.Next (Container.Content, Position);\n-         end loop;\n-\n-         return R;\n-      end Elements;\n-\n-      ----------------------------\n-      -- Lift_Abstraction_Level --\n-      ----------------------------\n-\n-      procedure Lift_Abstraction_Level (Container : Set) is null;\n-\n-      -----------------------\n-      -- Mapping_Preserved --\n-      -----------------------\n-\n-      function Mapping_Preserved\n-        (E_Left  : E.Sequence;\n-         E_Right : E.Sequence;\n-         P_Left  : P.Map;\n-         P_Right : P.Map) return Boolean\n-      is\n-      begin\n-         for C of P_Left loop\n-            if not P.Has_Key (P_Right, C)\n-              or else P.Get (P_Left,  C) > E.Length (E_Left)\n-              or else P.Get (P_Right, C) > E.Length (E_Right)\n-              or else E.Get (E_Left,  P.Get (P_Left,  C)) /=\n-                      E.Get (E_Right, P.Get (P_Right, C))\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end Mapping_Preserved;\n-\n-      ------------------------------\n-      -- Mapping_Preserved_Except --\n-      ------------------------------\n-\n-      function Mapping_Preserved_Except\n-        (E_Left   : E.Sequence;\n-         E_Right  : E.Sequence;\n-         P_Left   : P.Map;\n-         P_Right  : P.Map;\n-         Position : Cursor) return Boolean\n-      is\n-      begin\n-         for C of P_Left loop\n-            if C /= Position\n-              and (not P.Has_Key (P_Right, C)\n-                    or else P.Get (P_Left,  C) > E.Length (E_Left)\n-                    or else P.Get (P_Right, C) > E.Length (E_Right)\n-                    or else E.Get (E_Left,  P.Get (P_Left,  C)) /=\n-                            E.Get (E_Right, P.Get (P_Right, C)))\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end Mapping_Preserved_Except;\n-\n-      -----------\n-      -- Model --\n-      -----------\n-\n-      function Model (Container : Set) return M.Set is\n-         Position : Count_Type := HT_Ops.First (Container.Content);\n-         R        : M.Set;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R :=\n-              M.Add\n-                (Container => R,\n-                 Item      => Container.Content.Nodes (Position).Element);\n-\n-            Position := HT_Ops.Next (Container.Content, Position);\n-         end loop;\n-\n-         return R;\n-      end Model;\n-\n-      ---------------\n-      -- Positions --\n-      ---------------\n-\n-      function Positions (Container : Set) return P.Map is\n-         I        : Count_Type := 1;\n-         Position : Count_Type := HT_Ops.First (Container.Content);\n-         R        : P.Map;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R := P.Add (R, (Node => Position), I);\n-            pragma Assert (P.Length (R) = Big (I));\n-            Position := HT_Ops.Next (Container.Content, Position);\n-            I := I + 1;\n-         end loop;\n-\n-         return R;\n-      end Positions;\n-\n-   end Formal_Model;\n-\n-   ----------\n-   -- Free --\n-   ----------\n-\n-   procedure Free (HT : in out Set; X : Count_Type) is\n-   begin\n-      if X /= 0 then\n-         pragma Assert (X <= HT.Capacity);\n-         HT.Content.Nodes (X).Has_Element := False;\n-         HT_Ops.Free (HT.Content, X);\n-      end if;\n-   end Free;\n-\n-   ----------------------\n-   -- Generic_Allocate --\n-   ----------------------\n-\n-   procedure Generic_Allocate\n-     (HT   : in out Hash_Table_Type;\n-      Node : out Count_Type)\n-   is\n-      procedure Allocate is new HT_Ops.Generic_Allocate (Set_Element);\n-   begin\n-      Allocate (HT, Node);\n-      HT.Nodes (Node).Has_Element := True;\n-   end Generic_Allocate;\n-\n-   package body Generic_Keys with SPARK_Mode => Off is\n-\n-      -----------------------\n-      -- Local Subprograms --\n-      -----------------------\n-\n-      function Equivalent_Key_Node\n-        (Key  : Key_Type;\n-         Node : Node_Type) return Boolean;\n-      pragma Inline (Equivalent_Key_Node);\n-\n-      --------------------------\n-      -- Local Instantiations --\n-      --------------------------\n-\n-      package Key_Keys is new Hash_Tables.Generic_Formal_Keys\n-        (HT_Types        => HT_Types,\n-         Next            => Next,\n-         Set_Next        => Set_Next,\n-         Key_Type        => Key_Type,\n-         Hash            => Hash,\n-         Equivalent_Keys => Equivalent_Key_Node);\n-\n-      --------------\n-      -- Contains --\n-      --------------\n-\n-      function Contains\n-        (Container : Set;\n-         Key       : Key_Type) return Boolean\n-      is\n-      begin\n-         return Find (Container, Key) /= No_Element;\n-      end Contains;\n-\n-      ------------\n-      -- Delete --\n-      ------------\n-\n-      procedure Delete (Container : in out Set; Key : Key_Type) is\n-         X : Count_Type;\n-\n-      begin\n-         Key_Keys.Delete_Key_Sans_Free (Container.Content, Key, X);\n-\n-         if X = 0 then\n-            raise Constraint_Error with \"attempt to delete key not in set\";\n-         end if;\n-\n-         Free (Container, X);\n-      end Delete;\n-\n-      -------------\n-      -- Element --\n-      -------------\n-\n-      function Element\n-        (Container : Set;\n-         Key       : Key_Type) return Element_Type\n-      is\n-         Node : constant Count_Type := Find (Container, Key).Node;\n-\n-      begin\n-         if Node = 0 then\n-            raise Constraint_Error with \"key not in map\";\n-         end if;\n-\n-         return Container.Content.Nodes (Node).Element;\n-      end Element;\n-\n-      -------------------------\n-      -- Equivalent_Key_Node --\n-      -------------------------\n-\n-      function Equivalent_Key_Node\n-        (Key  : Key_Type;\n-         Node : Node_Type) return Boolean\n-      is\n-      begin\n-         return Equivalent_Keys (Key, Generic_Keys.Key (Node.Element));\n-      end Equivalent_Key_Node;\n-\n-      -------------\n-      -- Exclude --\n-      -------------\n-\n-      procedure Exclude (Container : in out Set; Key : Key_Type) is\n-         X : Count_Type;\n-      begin\n-         Key_Keys.Delete_Key_Sans_Free (Container.Content, Key, X);\n-         Free (Container, X);\n-      end Exclude;\n-\n-      ----------\n-      -- Find --\n-      ----------\n-\n-      function Find\n-        (Container : Set;\n-         Key       : Key_Type) return Cursor\n-      is\n-         Node : constant Count_Type := Key_Keys.Find (Container.Content, Key);\n-      begin\n-         return (if Node = 0 then No_Element else (Node => Node));\n-      end Find;\n-\n-      ------------------\n-      -- Formal_Model --\n-      ------------------\n-\n-      package body Formal_Model is\n-\n-         -----------------------\n-         -- M_Included_Except --\n-         -----------------------\n-\n-         function M_Included_Except\n-           (Left  : M.Set;\n-            Right : M.Set;\n-            Key   : Key_Type) return Boolean\n-         is\n-         begin\n-            for E of Left loop\n-               if not Contains (Right, E)\n-                 and not Equivalent_Keys (Generic_Keys.Key (E), Key)\n-               then\n-                  return False;\n-               end if;\n-            end loop;\n-\n-            return True;\n-         end M_Included_Except;\n-\n-      end Formal_Model;\n-\n-      ---------\n-      -- Key --\n-      ---------\n-\n-      function Key (Container : Set; Position : Cursor) return Key_Type is\n-      begin\n-         if not Has_Element (Container, Position) then\n-            raise Constraint_Error with \"Position cursor has no element\";\n-         end if;\n-\n-         pragma Assert\n-           (Vet (Container, Position), \"bad cursor in function Key\");\n-\n-         declare\n-            N : Node_Type renames Container.Content.Nodes (Position.Node);\n-         begin\n-            return Key (N.Element);\n-         end;\n-      end Key;\n-\n-      -------------\n-      -- Replace --\n-      -------------\n-\n-      procedure Replace\n-        (Container : in out Set;\n-         Key       : Key_Type;\n-         New_Item  : Element_Type)\n-      is\n-         Node : constant Count_Type := Key_Keys.Find (Container.Content, Key);\n-\n-      begin\n-         if Node = 0 then\n-            raise Constraint_Error with \"attempt to replace key not in set\";\n-         end if;\n-\n-         Replace_Element (Container.Content, Node, New_Item);\n-      end Replace;\n-\n-   end Generic_Keys;\n-\n-   -----------------\n-   -- Has_Element --\n-   -----------------\n-\n-   function Has_Element (Container : Set; Position : Cursor) return Boolean is\n-   begin\n-      if Position.Node = 0\n-        or else not Container.Content.Nodes (Position.Node).Has_Element\n-      then\n-         return False;\n-      end if;\n-\n-      return True;\n-   end Has_Element;\n-\n-   ---------------\n-   -- Hash_Node --\n-   ---------------\n-\n-   function Hash_Node (Node : Node_Type) return Hash_Type is\n-   begin\n-      return Hash (Node.Element);\n-   end Hash_Node;\n-\n-   -------------\n-   -- Include --\n-   -------------\n-\n-   procedure Include (Container : in out Set; New_Item : Element_Type) is\n-      Inserted : Boolean;\n-      Position : Cursor;\n-\n-   begin\n-      Insert (Container, New_Item, Position, Inserted);\n-\n-      if not Inserted then\n-         Container.Content.Nodes (Position.Node).Element := New_Item;\n-      end if;\n-   end Include;\n-\n-   ------------\n-   -- Insert --\n-   ------------\n-\n-   procedure Insert\n-     (Container : in out Set;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor;\n-      Inserted  : out Boolean)\n-   is\n-   begin\n-      Insert (Container, New_Item, Position.Node, Inserted);\n-   end Insert;\n-\n-   procedure Insert (Container : in out Set; New_Item : Element_Type) is\n-      Inserted        : Boolean;\n-      Unused_Position : Cursor;\n-\n-   begin\n-      Insert (Container, New_Item, Unused_Position, Inserted);\n-\n-      if not Inserted then\n-         raise Constraint_Error with\n-           \"attempt to insert element already in set\";\n-      end if;\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out Set;\n-      New_Item  : Element_Type;\n-      Node      : out Count_Type;\n-      Inserted  : out Boolean)\n-   is\n-      procedure Allocate_Set_Element (Node : in out Node_Type);\n-      pragma Inline (Allocate_Set_Element);\n-\n-      procedure New_Node\n-        (HT   : in out Hash_Table_Type;\n-         Node : out Count_Type);\n-      pragma Inline (New_Node);\n-\n-      procedure Local_Insert is\n-        new Element_Keys.Generic_Conditional_Insert (New_Node);\n-\n-      procedure Allocate is\n-        new Generic_Allocate (Allocate_Set_Element);\n-\n-      ---------------------------\n-      --  Allocate_Set_Element --\n-      ---------------------------\n-\n-      procedure Allocate_Set_Element (Node : in out Node_Type) is\n-      begin\n-         Node.Element := New_Item;\n-      end Allocate_Set_Element;\n-\n-      --------------\n-      -- New_Node --\n-      --------------\n-\n-      procedure New_Node\n-        (HT   : in out Hash_Table_Type;\n-         Node : out Count_Type)\n-      is\n-      begin\n-         Allocate (HT, Node);\n-      end New_Node;\n-\n-   --  Start of processing for Insert\n-\n-   begin\n-      Local_Insert (Container.Content, New_Item, Node, Inserted);\n-   end Insert;\n-\n-   ------------------\n-   -- Intersection --\n-   ------------------\n-\n-   procedure Intersection (Target : in out Set; Source : Set) is\n-      Tgt_Node : Count_Type;\n-      TN       : Nodes_Type renames Target.Content.Nodes;\n-\n-   begin\n-      if Source.Content.Length = 0 then\n-         Clear (Target);\n-         return;\n-      end if;\n-\n-      Tgt_Node := HT_Ops.First (Target.Content);\n-      while Tgt_Node /= 0 loop\n-         if Find (Source, TN (Tgt_Node).Element).Node /= 0 then\n-            Tgt_Node := HT_Ops.Next (Target.Content, Tgt_Node);\n-\n-         else\n-            declare\n-               X : constant Count_Type := Tgt_Node;\n-            begin\n-               Tgt_Node := HT_Ops.Next (Target.Content, Tgt_Node);\n-               HT_Ops.Delete_Node_Sans_Free (Target.Content, X);\n-               Free (Target, X);\n-            end;\n-         end if;\n-      end loop;\n-   end Intersection;\n-\n-   procedure Intersection (Left : Set; Right : Set; Target : in out Set) is\n-      procedure Process (L_Node : Count_Type);\n-\n-      procedure Iterate is\n-        new HT_Ops.Generic_Iteration (Process);\n-\n-      -------------\n-      -- Process --\n-      -------------\n-\n-      procedure Process (L_Node : Count_Type) is\n-         E        : Element_Type renames Left.Content.Nodes (L_Node).Element;\n-         Unused_X : Count_Type;\n-         B        : Boolean;\n-\n-      begin\n-         if Find (Right, E).Node /= 0 then\n-            Insert (Target, E, Unused_X, B);\n-            pragma Assert (B);\n-         end if;\n-      end Process;\n-\n-   --  Start of processing for Intersection\n-\n-   begin\n-      Iterate (Left.Content);\n-   end Intersection;\n-\n-   function Intersection (Left : Set; Right : Set) return Set is\n-      C : constant Count_Type :=\n-        Count_Type'Min (Length (Left), Length (Right));  -- ???\n-      H : constant Hash_Type := Default_Modulus (C);\n-\n-   begin\n-      return S : Set (C, H) do\n-         if Length (Left) /= 0 and Length (Right) /= 0 then\n-            Intersection (Left, Right, Target => S);\n-         end if;\n-      end return;\n-   end Intersection;\n-\n-   --------------\n-   -- Is_Empty --\n-   --------------\n-\n-   function Is_Empty (Container : Set) return Boolean is\n-   begin\n-      return Length (Container) = 0;\n-   end Is_Empty;\n-\n-   -----------\n-   -- Is_In --\n-   -----------\n-\n-   function Is_In (HT : Set; Key : Node_Type) return Boolean is\n-   begin\n-      return Element_Keys.Find (HT.Content, Key.Element) /= 0;\n-   end Is_In;\n-\n-   ---------------\n-   -- Is_Subset --\n-   ---------------\n-\n-   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean is\n-      Subset_Node  : Count_Type;\n-      Subset_Nodes : Nodes_Type renames Subset.Content.Nodes;\n-\n-   begin\n-      if Length (Subset) > Length (Of_Set) then\n-         return False;\n-      end if;\n-\n-      Subset_Node := First (Subset).Node;\n-      while Subset_Node /= 0 loop\n-         declare\n-            S : constant Count_Type := Subset_Node;\n-            N : Node_Type renames Subset_Nodes (S);\n-            E : Element_Type renames N.Element;\n-\n-         begin\n-            if Find (Of_Set, E).Node = 0 then\n-               return False;\n-            end if;\n-         end;\n-\n-         Subset_Node := HT_Ops.Next (Subset.Content, Subset_Node);\n-      end loop;\n-\n-      return True;\n-   end Is_Subset;\n-\n-   ------------\n-   -- Length --\n-   ------------\n-\n-   function Length (Container : Set) return Count_Type is\n-   begin\n-      return Container.Content.Length;\n-   end Length;\n-\n-   ----------\n-   -- Move --\n-   ----------\n-\n-   --  Comments???\n-\n-   procedure Move (Target : in out Set; Source : in out Set) is\n-      NN   : HT_Types.Nodes_Type renames Source.Content.Nodes;\n-      X, Y : Count_Type;\n-\n-   begin\n-      if Target.Capacity < Length (Source) then\n-         raise Constraint_Error with  -- ???\n-           \"Source length exceeds Target capacity\";\n-      end if;\n-\n-      Clear (Target);\n-\n-      if Source.Content.Length = 0 then\n-         return;\n-      end if;\n-\n-      X := HT_Ops.First (Source.Content);\n-      while X /= 0 loop\n-         Insert (Target, NN (X).Element);  -- optimize???\n-\n-         Y := HT_Ops.Next (Source.Content, X);\n-\n-         HT_Ops.Delete_Node_Sans_Free (Source.Content, X);\n-         Free (Source, X);\n-\n-         X := Y;\n-      end loop;\n-   end Move;\n-\n-   ----------\n-   -- Next --\n-   ----------\n-\n-   function Next (Node : Node_Type) return Count_Type is\n-   begin\n-      return Node.Next;\n-   end Next;\n-\n-   function Next (Container : Set; Position : Cursor) return Cursor is\n-   begin\n-      if Position.Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container, Position), \"bad cursor in Next\");\n-\n-      return (Node => HT_Ops.Next (Container.Content, Position.Node));\n-   end Next;\n-\n-   procedure Next (Container : Set; Position : in out Cursor) is\n-   begin\n-      Position := Next (Container, Position);\n-   end Next;\n-\n-   -------------\n-   -- Overlap --\n-   -------------\n-\n-   function Overlap (Left, Right : Set) return Boolean is\n-      Left_Node  : Count_Type;\n-      Left_Nodes : Nodes_Type renames Left.Content.Nodes;\n-\n-   begin\n-      if Length (Right) = 0 or Length (Left) = 0 then\n-         return False;\n-      end if;\n-\n-      Left_Node := First (Left).Node;\n-      while Left_Node /= 0 loop\n-         declare\n-            L : constant Count_Type := Left_Node;\n-            N : Node_Type renames Left_Nodes (L);\n-            E : Element_Type renames N.Element;\n-         begin\n-            if Find (Right, E).Node /= 0 then\n-               return True;\n-            end if;\n-         end;\n-\n-         Left_Node := HT_Ops.Next (Left.Content, Left_Node);\n-      end loop;\n-\n-      return False;\n-   end Overlap;\n-\n-   -------------\n-   -- Replace --\n-   -------------\n-\n-   procedure Replace (Container : in out Set; New_Item : Element_Type) is\n-      Node : constant Count_Type :=\n-        Element_Keys.Find (Container.Content, New_Item);\n-\n-   begin\n-      if Node = 0 then\n-         raise Constraint_Error with \"attempt to replace element not in set\";\n-      end if;\n-\n-      Container.Content.Nodes (Node).Element := New_Item;\n-   end Replace;\n-\n-   ---------------------\n-   -- Replace_Element --\n-   ---------------------\n-\n-   procedure Replace_Element\n-     (Container : in out Set;\n-      Position  : Cursor;\n-      New_Item  : Element_Type)\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor equals No_Element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container, Position), \"bad cursor in Replace_Element\");\n-\n-      Replace_Element (Container.Content, Position.Node, New_Item);\n-   end Replace_Element;\n-\n-   ----------------------\n-   -- Reserve_Capacity --\n-   ----------------------\n-\n-   procedure Reserve_Capacity\n-     (Container : in out Set;\n-      Capacity  : Count_Type)\n-   is\n-   begin\n-      if Capacity > Container.Capacity then\n-         raise Constraint_Error with \"requested capacity is too large\";\n-      end if;\n-   end Reserve_Capacity;\n-\n-   ------------------\n-   --  Set_Element --\n-   ------------------\n-\n-   procedure Set_Element (Node : in out Node_Type; Item : Element_Type) is\n-   begin\n-      Node.Element := Item;\n-   end Set_Element;\n-\n-   --------------\n-   -- Set_Next --\n-   --------------\n-\n-   procedure Set_Next (Node : in out Node_Type; Next : Count_Type) is\n-   begin\n-      Node.Next := Next;\n-   end Set_Next;\n-\n-   --------------------------\n-   -- Symmetric_Difference --\n-   --------------------------\n-\n-   procedure Symmetric_Difference (Target : in out Set; Source : Set) is\n-      procedure Process (Source_Node : Count_Type);\n-      pragma Inline (Process);\n-\n-      procedure Iterate is new HT_Ops.Generic_Iteration (Process);\n-\n-      -------------\n-      -- Process --\n-      -------------\n-\n-      procedure Process (Source_Node : Count_Type) is\n-         B        : Boolean;\n-         N        : Node_Type renames Source.Content.Nodes (Source_Node);\n-         Unused_X : Count_Type;\n-\n-      begin\n-         if Is_In (Target, N) then\n-            Delete (Target, N.Element);\n-         else\n-            Insert (Target, N.Element, Unused_X, B);\n-            pragma Assert (B);\n-         end if;\n-      end Process;\n-\n-   --  Start of processing for Symmetric_Difference\n-\n-   begin\n-      if Length (Target) = 0 then\n-         Assign (Target, Source);\n-         return;\n-      end if;\n-\n-      Iterate (Source.Content);\n-   end Symmetric_Difference;\n-\n-   function Symmetric_Difference (Left : Set; Right : Set) return Set is\n-   begin\n-      if Length (Right) = 0 then\n-         return Copy (Left);\n-      end if;\n-\n-      if Length (Left) = 0 then\n-         return Copy (Right);\n-      end if;\n-\n-      declare\n-         C : constant Count_Type := Length (Left) + Length (Right);\n-         H : constant Hash_Type := Default_Modulus (C);\n-      begin\n-         return S : Set (C, H) do\n-            Difference (Left, Right, S);\n-            Difference (Right, Left, S);\n-         end return;\n-      end;\n-   end Symmetric_Difference;\n-\n-   ------------\n-   -- To_Set --\n-   ------------\n-\n-   function To_Set (New_Item : Element_Type) return Set is\n-      Unused_X : Count_Type;\n-      B        : Boolean;\n-\n-   begin\n-      return S : Set (Capacity => 1, Modulus => 1) do\n-         Insert (S, New_Item, Unused_X, B);\n-         pragma Assert (B);\n-      end return;\n-   end To_Set;\n-\n-   -----------\n-   -- Union --\n-   -----------\n-\n-   procedure Union (Target : in out Set; Source : Set) is\n-      procedure Process (Src_Node : Count_Type);\n-\n-      procedure Iterate is\n-        new HT_Ops.Generic_Iteration (Process);\n-\n-      -------------\n-      -- Process --\n-      -------------\n-\n-      procedure Process (Src_Node : Count_Type) is\n-         N : Node_Type renames Source.Content.Nodes (Src_Node);\n-         E : Element_Type renames N.Element;\n-\n-         Unused_X : Count_Type;\n-         Unused_B : Boolean;\n-\n-      begin\n-         Insert (Target, E, Unused_X, Unused_B);\n-      end Process;\n-\n-   --  Start of processing for Union\n-\n-   begin\n-      Iterate (Source.Content);\n-   end Union;\n-\n-   function Union (Left : Set; Right : Set) return Set is\n-   begin\n-      if Length (Right) = 0 then\n-         return Copy (Left);\n-      end if;\n-\n-      if Length (Left) = 0 then\n-         return Copy (Right);\n-      end if;\n-\n-      declare\n-         C : constant Count_Type := Length (Left) + Length (Right);\n-         H : constant Hash_Type := Default_Modulus (C);\n-      begin\n-         return S : Set (C, H) do\n-            Assign (Target => S, Source => Left);\n-            Union (Target => S, Source => Right);\n-         end return;\n-      end;\n-   end Union;\n-\n-   ---------\n-   -- Vet --\n-   ---------\n-\n-   function Vet (Container : Set; Position : Cursor) return Boolean is\n-   begin\n-      if not Container_Checks'Enabled then\n-         return True;\n-      end if;\n-\n-      if Position.Node = 0 then\n-         return True;\n-      end if;\n-\n-      declare\n-         S : Set renames Container;\n-         N : Nodes_Type renames S.Content.Nodes;\n-         X : Count_Type;\n-\n-      begin\n-         if S.Content.Length = 0 then\n-            return False;\n-         end if;\n-\n-         if Position.Node > N'Last then\n-            return False;\n-         end if;\n-\n-         if N (Position.Node).Next = Position.Node then\n-            return False;\n-         end if;\n-\n-         X := S.Content.Buckets\n-           (Element_Keys.Index (S.Content, N (Position.Node).Element));\n-\n-         for J in 1 .. S.Content.Length loop\n-            if X = Position.Node then\n-               return True;\n-            end if;\n-\n-            if X = 0 then\n-               return False;\n-            end if;\n-\n-            if X = N (X).Next then  --  to prevent unnecessary looping\n-               return False;\n-            end if;\n-\n-            X := N (X).Next;\n-         end loop;\n-\n-         return False;\n-      end;\n-   end Vet;\n-\n-end Ada.Containers.Formal_Hashed_Sets;"}, {"sha": "633ed20841d6778f35521987f033cccf0f4e47a8", "filename": "gcc/ada/libgnat/a-cfhase.ads", "status": "modified", "additions": 5, "deletions": 1468, "changes": 1473, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cfhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cfhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfhase.ads?ref=4a7312f7ce189783a2cb5318bdcf50e8148b909d", "patch": "@@ -29,1475 +29,12 @@\n -- <http://www.gnu.org/licenses/>.                                          --\n ------------------------------------------------------------------------------\n \n---  This spec is derived from package Ada.Containers.Bounded_Hashed_Sets in the\n---  Ada 2012 RM. The modifications are meant to facilitate formal proofs by\n---  making it easier to express properties, and by making the specification of\n---  this unit compatible with SPARK 2014. Note that the API of this unit may be\n---  subject to incompatible changes as SPARK 2014 evolves.\n-\n---  The modifications are:\n-\n---    A parameter for the container is added to every function reading the\n---    content of a container: Element, Next, Query_Element, Has_Element, Key,\n---    Iterate, Equivalent_Elements. This change is motivated by the need to\n---    have cursors which are valid on different containers (typically a\n---    container C and its previous version C'Old) for expressing properties,\n---    which is not possible if cursors encapsulate an access to the underlying\n---    container.\n-\n-with Ada.Containers.Functional_Maps;\n-with Ada.Containers.Functional_Sets;\n-with Ada.Containers.Functional_Vectors;\n-with Ada.Numerics.Big_Numbers.Big_Integers;\n-use Ada.Numerics.Big_Numbers.Big_Integers;\n-private with Ada.Containers.Hash_Tables;\n-\n generic\n-   type Element_Type is private;\n-\n-   with function Hash (Element : Element_Type) return Hash_Type;\n-\n-   with function Equivalent_Elements\n-     (Left  : Element_Type;\n-      Right : Element_Type) return Boolean is \"=\";\n-\n-package Ada.Containers.Formal_Hashed_Sets with\n-  SPARK_Mode,\n-  Annotate => (GNATprove, Always_Return)\n-is\n-\n-   --  Contracts in this unit are meant for analysis only, not for run-time\n-   --  checking.\n-\n-   pragma Assertion_Policy (Pre => Ignore);\n-   pragma Assertion_Policy (Post => Ignore);\n-   pragma Assertion_Policy (Contract_Cases => Ignore);\n-   pragma Annotate (CodePeer, Skip_Analysis);\n-\n-   --  Convert Count_Type to Big_Interger.\n-\n-   package Conversions is new Signed_Conversions (Int => Count_Type);\n-\n-   function Big (J : Count_Type) return Big_Integer renames\n-     Conversions.To_Big_Integer;\n-\n-   type Set (Capacity : Count_Type; Modulus : Hash_Type) is private with\n-     Iterable => (First       => First,\n-                  Next        => Next,\n-                  Has_Element => Has_Element,\n-                  Element     => Element),\n-     Default_Initial_Condition => Is_Empty (Set);\n-   pragma Preelaborable_Initialization (Set);\n-\n-   type Cursor is record\n-      Node : Count_Type;\n-   end record;\n-\n-   No_Element : constant Cursor := (Node => 0);\n-\n-   function Length (Container : Set) return Count_Type with\n-     Global => null,\n-     Post   => Length'Result <= Container.Capacity;\n-\n-   pragma Unevaluated_Use_Of_Old (Allow);\n-\n-   package Formal_Model with Ghost is\n-      subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n-\n-      package M is new Ada.Containers.Functional_Sets\n-        (Element_Type    => Element_Type,\n-         Equivalent_Elements => Equivalent_Elements);\n-\n-      function \"=\"\n-        (Left  : M.Set;\n-         Right : M.Set) return Boolean renames M.\"=\";\n-\n-      function \"<=\"\n-        (Left  : M.Set;\n-         Right : M.Set) return Boolean renames M.\"<=\";\n-\n-      package E is new Ada.Containers.Functional_Vectors\n-        (Element_Type => Element_Type,\n-         Index_Type   => Positive_Count_Type);\n-\n-      function \"=\"\n-        (Left  : E.Sequence;\n-         Right : E.Sequence) return Boolean renames E.\"=\";\n-\n-      function \"<\"\n-        (Left  : E.Sequence;\n-         Right : E.Sequence) return Boolean renames E.\"<\";\n-\n-      function \"<=\"\n-        (Left  : E.Sequence;\n-         Right : E.Sequence) return Boolean renames E.\"<=\";\n-\n-      function Find\n-        (Container : E.Sequence;\n-         Item      : Element_Type) return Count_Type\n-      --  Search for Item in Container\n-\n-      with\n-        Global => null,\n-        Post =>\n-          (if Find'Result > 0 then\n-              Find'Result <= E.Length (Container)\n-                and Equivalent_Elements\n-                      (Item, E.Get (Container, Find'Result)));\n-\n-      function E_Elements_Included\n-        (Left  : E.Sequence;\n-         Right : E.Sequence) return Boolean\n-      --  The elements of Left are contained in Right\n-\n-      with\n-        Global => null,\n-        Post   =>\n-          E_Elements_Included'Result =\n-            (for all I in 1 .. E.Length (Left) =>\n-              Find (Right, E.Get (Left, I)) > 0\n-                and then E.Get (Right, Find (Right, E.Get (Left, I))) =\n-                         E.Get (Left, I));\n-      pragma Annotate (GNATprove, Inline_For_Proof, E_Elements_Included);\n-\n-      function E_Elements_Included\n-        (Left  : E.Sequence;\n-         Model : M.Set;\n-         Right : E.Sequence) return Boolean\n-      --  The elements of Container contained in Model are in Right\n-\n-      with\n-        Global => null,\n-        Post   =>\n-          E_Elements_Included'Result =\n-            (for all I in 1 .. E.Length (Left) =>\n-              (if M.Contains (Model, E.Get (Left, I)) then\n-                  Find (Right, E.Get (Left, I)) > 0\n-                    and then E.Get (Right, Find (Right, E.Get (Left, I))) =\n-                             E.Get (Left, I)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, E_Elements_Included);\n-\n-      function E_Elements_Included\n-        (Container : E.Sequence;\n-         Model     : M.Set;\n-         Left      : E.Sequence;\n-         Right     : E.Sequence) return Boolean\n-      --  The elements of Container contained in Model are in Left and others\n-      --  are in Right.\n-\n-      with\n-        Global => null,\n-        Post   =>\n-          E_Elements_Included'Result =\n-            (for all I in 1 .. E.Length (Container) =>\n-              (if M.Contains (Model, E.Get (Container, I)) then\n-                  Find (Left, E.Get (Container, I)) > 0\n-                    and then E.Get (Left, Find (Left, E.Get (Container, I))) =\n-                             E.Get (Container, I)\n-               else\n-                  Find (Right, E.Get (Container, I)) > 0\n-                    and then E.Get\n-                               (Right, Find (Right, E.Get (Container, I))) =\n-                             E.Get (Container, I)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, E_Elements_Included);\n-\n-      package P is new Ada.Containers.Functional_Maps\n-        (Key_Type                       => Cursor,\n-         Element_Type                   => Positive_Count_Type,\n-         Equivalent_Keys                => \"=\",\n-         Enable_Handling_Of_Equivalence => False);\n-\n-      function \"=\"\n-        (Left  : P.Map;\n-         Right : P.Map) return Boolean renames P.\"=\";\n-\n-      function \"<=\"\n-        (Left  : P.Map;\n-         Right : P.Map) return Boolean renames P.\"<=\";\n-\n-      function Mapping_Preserved\n-        (E_Left  : E.Sequence;\n-         E_Right : E.Sequence;\n-         P_Left  : P.Map;\n-         P_Right : P.Map) return Boolean\n-      with\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          (if Mapping_Preserved'Result then\n-\n-             --  Right contains all the cursors of Left\n-\n-             P.Keys_Included (P_Left, P_Right)\n-\n-               --  Right contains all the elements of Left\n-\n-               and E_Elements_Included (E_Left, E_Right)\n-\n-               --  Mappings from cursors to elements induced by E_Left, P_Left\n-               --  and E_Right, P_Right are the same.\n-\n-               and (for all C of P_Left =>\n-                     E.Get (E_Left, P.Get (P_Left, C)) =\n-                     E.Get (E_Right, P.Get (P_Right, C))));\n-\n-      function Mapping_Preserved_Except\n-        (E_Left   : E.Sequence;\n-         E_Right  : E.Sequence;\n-         P_Left   : P.Map;\n-         P_Right  : P.Map;\n-         Position : Cursor) return Boolean\n-      with\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          (if Mapping_Preserved_Except'Result then\n-\n-             --  Right contains all the cursors of Left\n-\n-             P.Keys_Included (P_Left, P_Right)\n-\n-               --  Mappings from cursors to elements induced by E_Left, P_Left\n-               --  and E_Right, P_Right are the same except for Position.\n-\n-               and (for all C of P_Left =>\n-                     (if C /= Position then\n-                         E.Get (E_Left, P.Get (P_Left, C)) =\n-                         E.Get (E_Right, P.Get (P_Right, C)))));\n-\n-      function Model (Container : Set) return M.Set with\n-      --  The high-level model of a set is a set of elements. Neither cursors\n-      --  nor order of elements are represented in this model. Elements are\n-      --  modeled up to equivalence.\n-\n-        Ghost,\n-        Global => null,\n-        Post   => M.Length (Model'Result) = Big (Length (Container));\n-\n-      function Elements (Container : Set) return E.Sequence with\n-      --  The Elements sequence represents the underlying list structure of\n-      --  sets that is used for iteration. It stores the actual values of\n-      --  elements in the set. It does not model cursors.\n-\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          E.Length (Elements'Result) = Length (Container)\n-\n-            --  It only contains keys contained in Model\n-\n-            and (for all Item of Elements'Result =>\n-                  M.Contains (Model (Container), Item))\n-\n-            --  It contains all the elements contained in Model\n-\n-            and (for all Item of Model (Container) =>\n-                  (Find (Elements'Result, Item) > 0\n-                    and then Equivalent_Elements\n-                               (E.Get (Elements'Result,\n-                                       Find (Elements'Result, Item)),\n-                                Item)))\n-\n-            --  It has no duplicate\n-\n-            and (for all I in 1 .. Length (Container) =>\n-                  Find (Elements'Result, E.Get (Elements'Result, I)) = I)\n-\n-            and (for all I in 1 .. Length (Container) =>\n-                  (for all J in 1 .. Length (Container) =>\n-                    (if Equivalent_Elements\n-                          (E.Get (Elements'Result, I),\n-                           E.Get (Elements'Result, J))\n-                     then I = J)));\n-      pragma Annotate (GNATprove, Iterable_For_Proof, \"Model\", Elements);\n-\n-      function Positions (Container : Set) return P.Map with\n-      --  The Positions map is used to model cursors. It only contains valid\n-      --  cursors and maps them to their position in the container.\n-\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          not P.Has_Key (Positions'Result, No_Element)\n-\n-            --  Positions of cursors are smaller than the container's length\n-\n-            and then\n-              (for all I of Positions'Result =>\n-                P.Get (Positions'Result, I) in 1 .. Length (Container)\n-\n-            --  No two cursors have the same position. Note that we do not\n-            --  state that there is a cursor in the map for each position, as\n-            --  it is rarely needed.\n-\n-            and then\n-              (for all J of Positions'Result =>\n-                (if P.Get (Positions'Result, I) = P.Get (Positions'Result, J)\n-                 then I = J)));\n-\n-      procedure Lift_Abstraction_Level (Container : Set) with\n-        --  Lift_Abstraction_Level is a ghost procedure that does nothing but\n-        --  assume that we can access the same elements by iterating over\n-        --  positions or cursors.\n-        --  This information is not generally useful except when switching from\n-        --  a low-level, cursor-aware view of a container, to a high-level,\n-        --  position-based view.\n-\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          (for all Item of Elements (Container) =>\n-            (for some I of Positions (Container) =>\n-              E.Get (Elements (Container), P.Get (Positions (Container), I)) =\n-                Item));\n-\n-      function Contains\n-        (C : M.Set;\n-         K : Element_Type) return Boolean renames M.Contains;\n-      --  To improve readability of contracts, we rename the function used to\n-      --  search for an element in the model to Contains.\n-\n-   end Formal_Model;\n-   use Formal_Model;\n-\n-   Empty_Set : constant Set;\n-\n-   function \"=\" (Left, Right : Set) return Boolean with\n-     Global => null,\n-     Post   =>\n-         \"=\"'Result =\n-           (Length (Left) = Length (Right)\n-             and E_Elements_Included (Elements (Left), Elements (Right)))\n-       and\n-         \"=\"'Result =\n-           (E_Elements_Included (Elements (Left), Elements (Right))\n-             and E_Elements_Included (Elements (Right), Elements (Left)));\n-   --  For each element in Left, set equality attempts to find the equal\n-   --  element in Right; if a search fails, then set equality immediately\n-   --  returns False. The search works by calling Hash to find the bucket in\n-   --  the Right set that corresponds to the Left element. If the bucket is\n-   --  non-empty, the search calls the generic formal element equality operator\n-   --  to compare the element (in Left) to the element of each node in the\n-   --  bucket (in Right); the search terminates when a matching node in the\n-   --  bucket is found, or the nodes in the bucket are exhausted. (Note that\n-   --  element equality is called here, not Equivalent_Elements. Set equality\n-   --  is the only operation in which element equality is used. Compare set\n-   --  equality to Equivalent_Sets, which does call Equivalent_Elements.)\n-\n-   function Equivalent_Sets (Left, Right : Set) return Boolean with\n-     Global => null,\n-     Post   => Equivalent_Sets'Result = (Model (Left) = Model (Right));\n-   --  Similar to set equality, with the difference that the element in Left is\n-   --  compared to the elements in Right using the generic formal\n-   --  Equivalent_Elements operation instead of element equality.\n-\n-   function To_Set (New_Item : Element_Type) return Set with\n-     Global => null,\n-     Post   =>\n-       M.Is_Singleton (Model (To_Set'Result), New_Item)\n-         and Length (To_Set'Result) = 1\n-         and E.Get (Elements (To_Set'Result), 1) = New_Item;\n-   --  Constructs a singleton set comprising New_Element. To_Set calls Hash to\n-   --  determine the bucket for New_Item.\n-\n-   function Capacity (Container : Set) return Count_Type with\n-     Global => null,\n-     Post   => Capacity'Result = Container.Capacity;\n-   --  Returns the current capacity of the set. Capacity is the maximum length\n-   --  before which rehashing in guaranteed not to occur.\n-\n-   procedure Reserve_Capacity\n-     (Container : in out Set;\n-      Capacity  : Count_Type)\n-   with\n-     Global => null,\n-     Pre    => Capacity <= Container.Capacity,\n-     Post   =>\n-       Model (Container) = Model (Container)'Old\n-         and Length (Container)'Old = Length (Container)\n-\n-         --  Actual elements are preserved\n-\n-         and E_Elements_Included\n-              (Elements (Container), Elements (Container)'Old)\n-         and E_Elements_Included\n-              (Elements (Container)'Old, Elements (Container));\n-   --  If the value of the Capacity actual parameter is less or equal to\n-   --  Container.Capacity, then the operation has no effect.  Otherwise it\n-   --  raises Capacity_Error (as no expansion of capacity is possible for a\n-   --  bounded form).\n-\n-   function Is_Empty (Container : Set) return Boolean with\n-     Global => null,\n-     Post   => Is_Empty'Result = (Length (Container) = 0);\n-   --  Equivalent to Length (Container) = 0\n-\n-   procedure Clear (Container : in out Set) with\n-     Global => null,\n-     Post   => Length (Container) = 0 and M.Is_Empty (Model (Container));\n-   --  Removes all of the items from the set. This will deallocate all memory\n-   --  associated with this set.\n-\n-   procedure Assign (Target : in out Set; Source : Set) with\n-     Global => null,\n-     Pre    => Target.Capacity >= Length (Source),\n-     Post   =>\n-       Model (Target) = Model (Source)\n-         and Length (Target) = Length (Source)\n-\n-         --  Actual elements are preserved\n-\n-         and E_Elements_Included (Elements (Target), Elements (Source))\n-         and E_Elements_Included (Elements (Source), Elements (Target));\n-   --  If Target denotes the same object as Source, then the operation has no\n-   --  effect. If the Target capacity is less than the Source length, then\n-   --  Assign raises Capacity_Error.  Otherwise, Assign clears Target and then\n-   --  copies the (active) elements from Source to Target.\n-\n-   function Copy\n-     (Source   : Set;\n-      Capacity : Count_Type := 0) return Set\n-   with\n-     Global => null,\n-     Pre    => Capacity = 0 or else Capacity >= Source.Capacity,\n-     Post   =>\n-       Model (Copy'Result) = Model (Source)\n-         and Elements (Copy'Result) = Elements (Source)\n-         and Positions (Copy'Result) = Positions (Source)\n-         and (if Capacity = 0 then\n-                 Copy'Result.Capacity = Source.Capacity\n-              else\n-                 Copy'Result.Capacity = Capacity);\n-   --  Constructs a new set object whose elements correspond to Source.  If the\n-   --  Capacity parameter is 0, then the capacity of the result is the same as\n-   --  the length of Source. If the Capacity parameter is equal or greater than\n-   --  the length of Source, then the capacity of the result is the specified\n-   --  value. Otherwise, Copy raises Capacity_Error. If the Modulus parameter\n-   --  is 0, then the modulus of the result is the value returned by a call to\n-   --  Default_Modulus with the capacity parameter determined as above;\n-   --  otherwise the modulus of the result is the specified value.\n-\n-   function Element\n-     (Container : Set;\n-      Position  : Cursor) return Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Element'Result =\n-         E.Get (Elements (Container), P.Get (Positions (Container), Position));\n-   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n-\n-   procedure Replace_Element\n-     (Container : in out Set;\n-      Position  : Cursor;\n-      New_Item  : Element_Type)\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old\n-\n-          --  Position now maps to New_Item\n-\n-          and Element (Container, Position) = New_Item\n-\n-          --  New_Item is contained in Container\n-\n-          and Contains (Model (Container), New_Item)\n-\n-          --  Other elements are preserved\n-\n-          and M.Included_Except\n-                (Model (Container)'Old,\n-                 Model (Container),\n-                 Element (Container, Position)'Old)\n-          and M.Included_Except\n-                (Model (Container),\n-                 Model (Container)'Old,\n-                 New_Item)\n-\n-          --  Mapping from cursors to elements is preserved\n-\n-          and Mapping_Preserved_Except\n-                (E_Left   => Elements (Container)'Old,\n-                 E_Right  => Elements (Container),\n-                 P_Left   => Positions (Container)'Old,\n-                 P_Right  => Positions (Container),\n-                 Position => Position)\n-          and Positions (Container) = Positions (Container)'Old;\n-\n-   function Constant_Reference\n-     (Container : aliased Set;\n-      Position  : Cursor) return not null access constant Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Constant_Reference'Result.all =\n-         E.Get (Elements (Container), P.Get (Positions (Container), Position));\n-\n-   procedure Move (Target : in out Set; Source : in out Set) with\n-     Global => null,\n-     Pre    => Target.Capacity >= Length (Source),\n-     Post   =>\n-       Length (Source) = 0\n-         and Model (Target) = Model (Source)'Old\n-         and Length (Target) = Length (Source)'Old\n-\n-         --  Actual elements are preserved\n-\n-         and E_Elements_Included (Elements (Target), Elements (Source)'Old)\n-         and E_Elements_Included (Elements (Source)'Old, Elements (Target));\n-   --  Clears Target (if it's not empty), and then moves (not copies) the\n-   --  buckets array and nodes from Source to Target.\n-\n-   procedure Insert\n-     (Container : in out Set;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor;\n-      Inserted  : out Boolean)\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Length (Container) < Container.Capacity\n-         or Contains (Container, New_Item),\n-     Post           =>\n-       Contains (Container, New_Item)\n-         and Has_Element (Container, Position)\n-         and Equivalent_Elements (Element (Container, Position), New_Item),\n-     Contract_Cases =>\n-\n-       --  If New_Item is already in Container, it is not modified and Inserted\n-       --  is set to False.\n-\n-       (Contains (Container, New_Item) =>\n-          not Inserted\n-            and Model (Container) = Model (Container)'Old\n-            and Elements (Container) = Elements (Container)'Old\n-            and Positions (Container) = Positions (Container)'Old,\n-\n-        --  Otherwise, New_Item is inserted in Container and Inserted is set to\n-        --  True.\n-\n-        others =>\n-          Inserted\n-            and Length (Container) = Length (Container)'Old + 1\n-\n-            --  Position now maps to New_Item\n-\n-            and Element (Container, Position) = New_Item\n-\n-            --  Other elements are preserved\n-\n-            and Model (Container)'Old <= Model (Container)\n-            and M.Included_Except\n-                  (Model (Container),\n-                   Model (Container)'Old,\n-                   New_Item)\n-\n-            --  Mapping from cursors to elements is preserved\n-\n-            and Mapping_Preserved\n-                  (E_Left  => Elements (Container)'Old,\n-                   E_Right => Elements (Container),\n-                   P_Left  => Positions (Container)'Old,\n-                   P_Right => Positions (Container))\n-            and P.Keys_Included_Except\n-                  (Positions (Container),\n-                   Positions (Container)'Old,\n-                   Position));\n-   --  Conditionally inserts New_Item into the set. If New_Item is already in\n-   --  the set, then Inserted returns False and Position designates the node\n-   --  containing the existing element (which is not modified). If New_Item is\n-   --  not already in the set, then Inserted returns True and Position\n-   --  designates the newly-inserted node containing New_Item. The search for\n-   --  an existing element works as follows. Hash is called to determine\n-   --  New_Item's bucket; if the bucket is non-empty, then Equivalent_Elements\n-   --  is called to compare New_Item to the element of each node in that\n-   --  bucket. If the bucket is empty, or there were no equivalent elements in\n-   --  the bucket, the search \"fails\" and the New_Item is inserted in the set\n-   --  (and Inserted returns True); otherwise, the search \"succeeds\" (and\n-   --  Inserted returns False).\n-\n-   procedure Insert  (Container : in out Set; New_Item : Element_Type) with\n-     Global => null,\n-     Pre    => Length (Container) < Container.Capacity\n-                 and then (not Contains (Container, New_Item)),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + 1\n-         and Contains (Container, New_Item)\n-         and Element (Container, Find (Container, New_Item)) = New_Item\n-\n-         --  Other elements are preserved\n-\n-         and Model (Container)'Old <= Model (Container)\n-         and M.Included_Except\n-               (Model (Container),\n-                Model (Container)'Old,\n-                New_Item)\n-\n-         --  Mapping from cursors to elements is preserved\n-\n-         and Mapping_Preserved\n-               (E_Left  => Elements (Container)'Old,\n-                E_Right => Elements (Container),\n-                P_Left  => Positions (Container)'Old,\n-                P_Right => Positions (Container))\n-         and P.Keys_Included_Except\n-               (Positions (Container),\n-                Positions (Container)'Old,\n-                Find (Container, New_Item));\n-   --  Attempts to insert New_Item into the set, performing the usual insertion\n-   --  search (which involves calling both Hash and Equivalent_Elements); if\n-   --  the search succeeds (New_Item is equivalent to an element already in the\n-   --  set, and so was not inserted), then this operation raises\n-   --  Constraint_Error. (This version of Insert is similar to Replace, but\n-   --  having the opposite exception behavior. It is intended for use when you\n-   --  want to assert that the item is not already in the set.)\n-\n-   procedure Include (Container : in out Set; New_Item : Element_Type) with\n-     Global         => null,\n-     Pre            =>\n-       Length (Container) < Container.Capacity\n-         or Contains (Container, New_Item),\n-     Post           =>\n-       Contains (Container, New_Item)\n-         and Element (Container, Find (Container, New_Item)) = New_Item,\n-     Contract_Cases =>\n-\n-       --  If an element equivalent to New_Item is already in Container, it is\n-       --  replaced by New_Item.\n-\n-       (Contains (Container, New_Item) =>\n-\n-          --  Elements are preserved modulo equivalence\n-\n-          Model (Container) = Model (Container)'Old\n-\n-            --  Cursors are preserved\n-\n-            and Positions (Container) = Positions (Container)'Old\n-\n-            --  The actual value of other elements is preserved\n-\n-            and E.Equal_Except\n-                  (Elements (Container)'Old,\n-                   Elements (Container),\n-                   P.Get (Positions (Container), Find (Container, New_Item))),\n-\n-        --  Otherwise, New_Item is inserted in Container\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old + 1\n-\n-            --  Other elements are preserved\n-\n-            and Model (Container)'Old <= Model (Container)\n-            and M.Included_Except\n-                  (Model (Container),\n-                   Model (Container)'Old,\n-                   New_Item)\n-\n-            --  Mapping from cursors to elements is preserved\n-\n-            and Mapping_Preserved\n-                  (E_Left  => Elements (Container)'Old,\n-                   E_Right => Elements (Container),\n-                   P_Left  => Positions (Container)'Old,\n-                   P_Right => Positions (Container))\n-            and P.Keys_Included_Except\n-                  (Positions (Container),\n-                   Positions (Container)'Old,\n-                   Find (Container, New_Item)));\n-   --  Attempts to insert New_Item into the set. If an element equivalent to\n-   --  New_Item is already in the set (the insertion search succeeded, and\n-   --  hence New_Item was not inserted), then the value of New_Item is assigned\n-   --  to the existing element. (This insertion operation only raises an\n-   --  exception if cursor tampering occurs. It is intended for use when you\n-   --  want to insert the item in the set, and you don't care whether an\n-   --  equivalent element is already present.)\n-\n-   procedure Replace (Container : in out Set; New_Item : Element_Type) with\n-     Global => null,\n-     Pre    => Contains (Container, New_Item),\n-     Post   =>\n-\n-       --  Elements are preserved modulo equivalence\n-\n-       Model (Container) = Model (Container)'Old\n-         and Contains (Container, New_Item)\n-\n-         --  Cursors are preserved\n-\n-         and Positions (Container) = Positions (Container)'Old\n-\n-         --  The element equivalent to New_Item in Container is replaced by\n-         --  New_Item.\n-\n-         and Element (Container, Find (Container, New_Item)) = New_Item\n-         and E.Equal_Except\n-               (Elements (Container)'Old,\n-                Elements (Container),\n-                P.Get (Positions (Container), Find (Container, New_Item)));\n-   --  Searches for New_Item in the set; if the search fails (because an\n-   --  equivalent element was not in the set), then it raises\n-   --  Constraint_Error. Otherwise, the existing element is assigned the value\n-   --  New_Item. (This is similar to Insert, but with the opposite exception\n-   --  behavior. It is intended for use when you want to assert that the item\n-   --  is already in the set.)\n-\n-   procedure Exclude (Container : in out Set; Item : Element_Type) with\n-     Global         => null,\n-     Post           => not Contains (Container, Item),\n-     Contract_Cases =>\n-\n-       --  If Item is not in Container, nothing is changed\n-\n-       (not Contains (Container, Item) =>\n-          Model (Container) = Model (Container)'Old\n-            and Elements (Container) = Elements (Container)'Old\n-            and Positions (Container) = Positions (Container)'Old,\n-\n-        --  Otherwise, Item is removed from Container\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old - 1\n-\n-            --  Other elements are preserved\n-\n-            and Model (Container) <= Model (Container)'Old\n-            and M.Included_Except\n-                  (Model (Container)'Old,\n-                   Model (Container),\n-                   Item)\n-\n-            --  Mapping from cursors to elements is preserved\n-\n-            and Mapping_Preserved\n-                  (E_Left  => Elements (Container),\n-                   E_Right => Elements (Container)'Old,\n-                   P_Left  => Positions (Container),\n-                   P_Right => Positions (Container)'Old)\n-            and P.Keys_Included_Except\n-                  (Positions (Container)'Old,\n-                   Positions (Container),\n-                   Find (Container, Item)'Old));\n-   --  Searches for Item in the set, and if found, removes its node from the\n-   --  set and then deallocates it. The search works as follows. The operation\n-   --  calls Hash to determine the item's bucket; if the bucket is not empty,\n-   --  it calls Equivalent_Elements to compare Item to the element of each node\n-   --  in the bucket. (This is the deletion analog of Include. It is intended\n-   --  for use when you want to remove the item from the set, but don't care\n-   --  whether the item is already in the set.)\n-\n-   procedure Delete  (Container : in out Set; Item : Element_Type) with\n-     Global => null,\n-     Pre    => Contains (Container, Item),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old - 1\n-\n-         --  Item is no longer in Container\n-\n-         and not Contains (Container, Item)\n-\n-         --  Other elements are preserved\n-\n-         and Model (Container) <= Model (Container)'Old\n-         and M.Included_Except\n-               (Model (Container)'Old,\n-                Model (Container),\n-                Item)\n-\n-         --  Mapping from cursors to elements is preserved\n-\n-         and Mapping_Preserved\n-               (E_Left  => Elements (Container),\n-                E_Right => Elements (Container)'Old,\n-                P_Left  => Positions (Container),\n-                P_Right => Positions (Container)'Old)\n-         and P.Keys_Included_Except\n-               (Positions (Container)'Old,\n-                Positions (Container),\n-                Find (Container, Item)'Old);\n-   --  Searches for Item in the set (which involves calling both Hash and\n-   --  Equivalent_Elements). If the search fails, then the operation raises\n-   --  Constraint_Error. Otherwise it removes the node from the set and then\n-   --  deallocates it. (This is the deletion analog of non-conditional\n-   --  Insert. It is intended for use when you want to assert that the item is\n-   --  already in the set.)\n-\n-   procedure Delete (Container : in out Set; Position : in out Cursor) with\n-     Global  => null,\n-     Depends => (Container =>+ Position, Position => null),\n-     Pre     => Has_Element (Container, Position),\n-     Post    =>\n-       Position = No_Element\n-         and Length (Container) = Length (Container)'Old - 1\n-\n-         --  The element at position Position is no longer in Container\n-\n-         and not Contains (Container, Element (Container, Position)'Old)\n-         and not P.Has_Key (Positions (Container), Position'Old)\n-\n-         --  Other elements are preserved\n-\n-         and Model (Container) <= Model (Container)'Old\n-         and M.Included_Except\n-               (Model (Container)'Old,\n-                Model (Container),\n-                Element (Container, Position)'Old)\n-\n-         --  Mapping from cursors to elements is preserved\n-\n-         and Mapping_Preserved\n-               (E_Left  => Elements (Container),\n-                E_Right => Elements (Container)'Old,\n-                P_Left  => Positions (Container),\n-                P_Right => Positions (Container)'Old)\n-         and P.Keys_Included_Except\n-               (Positions (Container)'Old,\n-                Positions (Container),\n-                Position'Old);\n-   --  Removes the node designated by Position from the set, and then\n-   --  deallocates the node. The operation calls Hash to determine the bucket,\n-   --  and then compares Position to each node in the bucket until there's a\n-   --  match (it does not call Equivalent_Elements).\n-\n-   procedure Union (Target : in out Set; Source : Set) with\n-     Global => null,\n-     Pre    =>\n-       Length (Source) - Length (Target and Source) <=\n-         Target.Capacity - Length (Target),\n-     Post   =>\n-       Big (Length (Target)) = Big (Length (Target)'Old)\n-         - M.Num_Overlaps (Model (Target)'Old, Model (Source))\n-         + Big (Length (Source))\n-\n-         --  Elements already in Target are still in Target\n-\n-         and Model (Target)'Old <= Model (Target)\n-\n-         --  Elements of Source are included in Target\n-\n-         and Model (Source) <= Model (Target)\n-\n-         --  Elements of Target come from either Source or Target\n-\n-         and M.Included_In_Union\n-               (Model (Target), Model (Source), Model (Target)'Old)\n-\n-         --  Actual value of elements come from either Left or Right\n-\n-         and E_Elements_Included\n-               (Elements (Target),\n-                Model (Target)'Old,\n-                Elements (Target)'Old,\n-                Elements (Source))\n-\n-         and E_Elements_Included\n-               (Elements (Target)'Old, Model (Target)'Old, Elements (Target))\n-\n-         and E_Elements_Included\n-               (Elements (Source),\n-                Model (Target)'Old,\n-                Elements (Source),\n-                Elements (Target))\n-\n-         --  Mapping from cursors of Target to elements is preserved\n-\n-         and Mapping_Preserved\n-               (E_Left  => Elements (Target)'Old,\n-                E_Right => Elements (Target),\n-                P_Left  => Positions (Target)'Old,\n-                P_Right => Positions (Target));\n-   --  Iterates over the Source set, and conditionally inserts each element\n-   --  into Target.\n-\n-   function Union (Left, Right : Set) return Set with\n-     Global => null,\n-     Pre    => Length (Left) <= Count_Type'Last - Length (Right),\n-     Post   =>\n-       Big (Length (Union'Result)) = Big (Length (Left))\n-         - M.Num_Overlaps (Model (Left), Model (Right))\n-         + Big (Length (Right))\n-\n-         --  Elements of Left and Right are in the result of Union\n-\n-         and Model (Left) <= Model (Union'Result)\n-         and Model (Right) <= Model (Union'Result)\n-\n-         --  Elements of the result of union come from either Left or Right\n-\n-         and\n-           M.Included_In_Union\n-             (Model (Union'Result), Model (Left), Model (Right))\n-\n-         --  Actual value of elements come from either Left or Right\n-\n-         and E_Elements_Included\n-               (Elements (Union'Result),\n-                Model (Left),\n-                Elements (Left),\n-                Elements (Right))\n-\n-         and E_Elements_Included\n-               (Elements (Left), Model (Left), Elements (Union'Result))\n-\n-         and E_Elements_Included\n-               (Elements (Right),\n-                Model (Left),\n-                Elements (Right),\n-                Elements (Union'Result));\n-   --  The operation first copies the Left set to the result, and then iterates\n-   --  over the Right set to conditionally insert each element into the result.\n-\n-   function \"or\" (Left, Right : Set) return Set renames Union;\n-\n-   procedure Intersection (Target : in out Set; Source : Set) with\n-     Global => null,\n-     Post   =>\n-       Big (Length (Target)) =\n-         M.Num_Overlaps (Model (Target)'Old, Model (Source))\n-\n-         --  Elements of Target were already in Target\n-\n-         and Model (Target) <= Model (Target)'Old\n-\n-         --  Elements of Target are in Source\n-\n-         and Model (Target) <= Model (Source)\n-\n-         --  Elements both in Source and Target are in the intersection\n-\n-         and M.Includes_Intersection\n-               (Model (Target), Model (Source), Model (Target)'Old)\n-\n-         --  Actual value of elements of Target is preserved\n-\n-         and E_Elements_Included (Elements (Target), Elements (Target)'Old)\n-         and E_Elements_Included\n-               (Elements (Target)'Old, Model (Source), Elements (Target))\n-\n-         --  Mapping from cursors of Target to elements is preserved\n-\n-         and Mapping_Preserved\n-               (E_Left  => Elements (Target),\n-                E_Right => Elements (Target)'Old,\n-                P_Left  => Positions (Target),\n-                P_Right => Positions (Target)'Old);\n-   --  Iterates over the Target set (calling First and Next), calling Find to\n-   --  determine whether the element is in Source. If an equivalent element is\n-   --  not found in Source, the element is deleted from Target.\n-\n-   function Intersection (Left, Right : Set) return Set with\n-     Global => null,\n-     Post   =>\n-       Big (Length (Intersection'Result)) =\n-         M.Num_Overlaps (Model (Left), Model (Right))\n-\n-         --  Elements in the result of Intersection are in Left and Right\n-\n-         and Model (Intersection'Result) <= Model (Left)\n-         and Model (Intersection'Result) <= Model (Right)\n-\n-         --  Elements both in Left and Right are in the result of Intersection\n-\n-         and M.Includes_Intersection\n-               (Model (Intersection'Result), Model (Left), Model (Right))\n-\n-         --  Actual value of elements come from Left\n-\n-         and E_Elements_Included\n-               (Elements (Intersection'Result), Elements (Left))\n-\n-         and E_Elements_Included\n-               (Elements (Left), Model (Right),\n-                Elements (Intersection'Result));\n-   --  Iterates over the Left set, calling Find to determine whether the\n-   --  element is in Right. If an equivalent element is found, it is inserted\n-   --  into the result set.\n-\n-   function \"and\" (Left, Right : Set) return Set renames Intersection;\n-\n-   procedure Difference (Target : in out Set; Source : Set) with\n-     Global => null,\n-     Post   =>\n-       Big (Length (Target)) = Big (Length (Target)'Old) -\n-         M.Num_Overlaps (Model (Target)'Old, Model (Source))\n-\n-         --  Elements of Target were already in Target\n-\n-         and Model (Target) <= Model (Target)'Old\n-\n-         --  Elements of Target are not in Source\n-\n-         and M.No_Overlap (Model (Target), Model (Source))\n-\n-         --  Elements in Target but not in Source are in the difference\n-\n-         and M.Included_In_Union\n-               (Model (Target)'Old, Model (Target), Model (Source))\n-\n-         --  Actual value of elements of Target is preserved\n-\n-         and E_Elements_Included (Elements (Target), Elements (Target)'Old)\n-         and E_Elements_Included\n-               (Elements (Target)'Old, Model (Target), Elements (Target))\n-\n-         --  Mapping from cursors of Target to elements is preserved\n-\n-         and Mapping_Preserved\n-               (E_Left  => Elements (Target),\n-                E_Right => Elements (Target)'Old,\n-                P_Left  => Positions (Target),\n-                P_Right => Positions (Target)'Old);\n-   --  Iterates over the Source (calling First and Next), calling Find to\n-   --  determine whether the element is in Target. If an equivalent element is\n-   --  found, it is deleted from Target.\n-\n-   function Difference (Left, Right : Set) return Set with\n-     Global => null,\n-     Post   =>\n-       Big (Length (Difference'Result)) = Big (Length (Left)) -\n-         M.Num_Overlaps (Model (Left), Model (Right))\n-\n-         --  Elements of the result of Difference are in Left\n-\n-         and Model (Difference'Result) <= Model (Left)\n-\n-         --  Elements of the result of Difference are in Right\n-\n-         and M.No_Overlap (Model (Difference'Result), Model (Right))\n-\n-         --  Elements in Left but not in Right are in the difference\n-\n-         and M.Included_In_Union\n-               (Model (Left), Model (Difference'Result), Model (Right))\n-\n-         --  Actual value of elements come from Left\n-\n-         and E_Elements_Included\n-               (Elements (Difference'Result), Elements (Left))\n-\n-         and E_Elements_Included\n-               (Elements (Left),\n-                Model (Difference'Result),\n-                Elements (Difference'Result));\n-   --  Iterates over the Left set, calling Find to determine whether the\n-   --  element is in the Right set. If an equivalent element is not found, the\n-   --  element is inserted into the result set.\n-\n-   function \"-\" (Left, Right : Set) return Set renames Difference;\n-\n-   procedure Symmetric_Difference (Target : in out Set; Source : Set) with\n-     Global => null,\n-     Pre    =>\n-       Length (Source) - Length (Target and Source) <=\n-         Target.Capacity - Length (Target) + Length (Target and Source),\n-     Post   =>\n-       Big (Length (Target)) = Big (Length (Target)'Old) -\n-         2 * M.Num_Overlaps (Model (Target)'Old, Model (Source)) +\n-         Big (Length (Source))\n-\n-         --  Elements of the difference were not both in Source and in Target\n-\n-         and M.Not_In_Both (Model (Target), Model (Target)'Old, Model (Source))\n-\n-         --  Elements in Target but not in Source are in the difference\n-\n-         and M.Included_In_Union\n-               (Model (Target)'Old, Model (Target), Model (Source))\n-\n-         --  Elements in Source but not in Target are in the difference\n-\n-         and M.Included_In_Union\n-               (Model (Source), Model (Target), Model (Target)'Old)\n-\n-         --  Actual value of elements come from either Left or Right\n-\n-         and E_Elements_Included\n-               (Elements (Target),\n-                Model (Target)'Old,\n-                Elements (Target)'Old,\n-                Elements (Source))\n-\n-         and E_Elements_Included\n-               (Elements (Target)'Old, Model (Target), Elements (Target))\n-\n-         and E_Elements_Included\n-               (Elements (Source), Model (Target), Elements (Target));\n-   --  The operation iterates over the Source set, searching for the element\n-   --  in Target (calling Hash and Equivalent_Elements). If an equivalent\n-   --  element is found, it is removed from Target; otherwise it is inserted\n-   --  into Target.\n-\n-   function Symmetric_Difference (Left, Right : Set) return Set with\n-     Global => null,\n-     Pre    => Length (Left) <= Count_Type'Last - Length (Right),\n-     Post   =>\n-       Big (Length (Symmetric_Difference'Result)) = Big (Length (Left)) -\n-         2 * M.Num_Overlaps (Model (Left), Model (Right)) +\n-         Big (Length (Right))\n-\n-         --  Elements of the difference were not both in Left and Right\n-\n-         and M.Not_In_Both\n-               (Model (Symmetric_Difference'Result),\n-                Model (Left),\n-                Model (Right))\n-\n-         --  Elements in Left but not in Right are in the difference\n-\n-         and M.Included_In_Union\n-               (Model (Left),\n-                Model (Symmetric_Difference'Result),\n-                Model (Right))\n-\n-         --  Elements in Right but not in Left are in the difference\n-\n-         and M.Included_In_Union\n-               (Model (Right),\n-                Model (Symmetric_Difference'Result),\n-                Model (Left))\n-\n-         --  Actual value of elements come from either Left or Right\n-\n-         and E_Elements_Included\n-               (Elements (Symmetric_Difference'Result),\n-                Model (Left),\n-                Elements (Left),\n-                Elements (Right))\n-\n-         and E_Elements_Included\n-               (Elements (Left),\n-                Model (Symmetric_Difference'Result),\n-                Elements (Symmetric_Difference'Result))\n-\n-         and E_Elements_Included\n-               (Elements (Right),\n-                Model (Symmetric_Difference'Result),\n-                Elements (Symmetric_Difference'Result));\n-   --  The operation first iterates over the Left set. It calls Find to\n-   --  determine whether the element is in the Right set. If no equivalent\n-   --  element is found, the element from Left is inserted into the result. The\n-   --  operation then iterates over the Right set, to determine whether the\n-   --  element is in the Left set. If no equivalent element is found, the Right\n-   --  element is inserted into the result.\n-\n-   function \"xor\" (Left, Right : Set) return Set\n-     renames Symmetric_Difference;\n-\n-   function Overlap (Left, Right : Set) return Boolean with\n-     Global => null,\n-     Post   =>\n-       Overlap'Result = not (M.No_Overlap (Model (Left), Model (Right)));\n-   --  Iterates over the Left set (calling First and Next), calling Find to\n-   --  determine whether the element is in the Right set. If an equivalent\n-   --  element is found, the operation immediately returns True. The operation\n-   --  returns False if the iteration over Left terminates without finding any\n-   --  equivalent element in Right.\n-\n-   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean with\n-     Global => null,\n-     Post   => Is_Subset'Result = (Model (Subset) <= Model (Of_Set));\n-   --  Iterates over Subset (calling First and Next), calling Find to determine\n-   --  whether the element is in Of_Set. If no equivalent element is found in\n-   --  Of_Set, the operation immediately returns False. The operation returns\n-   --  True if the iteration over Subset terminates without finding an element\n-   --  not in Of_Set (that is, every element in Subset is equivalent to an\n-   --  element in Of_Set).\n-\n-   function First (Container : Set) return Cursor with\n-     Global         => null,\n-     Contract_Cases =>\n-       (Length (Container) = 0 =>\n-          First'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, First'Result)\n-            and P.Get (Positions (Container), First'Result) = 1);\n-   --  Returns a cursor that designates the first non-empty bucket, by\n-   --  searching from the beginning of the buckets array.\n-\n-   function Next (Container : Set; Position : Cursor) return Cursor with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = Length (Container)\n-        =>\n-          Next'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Next'Result)\n-            and then P.Get (Positions (Container), Next'Result) =\n-                     P.Get (Positions (Container), Position) + 1);\n-   --  Returns a cursor that designates the node that follows the current one\n-   --  designated by Position. If Position designates the last node in its\n-   --  bucket, the operation calls Hash to compute the index of this bucket,\n-   --  and searches the buckets array for the first non-empty bucket, starting\n-   --  from that index; otherwise, it simply follows the link to the next node\n-   --  in the same bucket.\n-\n-   procedure Next (Container : Set; Position : in out Cursor) with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = Length (Container)\n-        =>\n-          Position = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Position)\n-            and then P.Get (Positions (Container), Position) =\n-                     P.Get (Positions (Container), Position'Old) + 1);\n-   --  Equivalent to Position := Next (Position)\n-\n-   function Find\n-     (Container : Set;\n-      Item      : Element_Type) return Cursor\n-   with\n-     Global         => null,\n-     Contract_Cases =>\n-\n-       --  If Item is not contained in Container, Find returns No_Element\n-\n-       (not Contains (Model (Container), Item) =>\n-          Find'Result = No_Element,\n-\n-        --  Otherwise, Find returns a valid cursor in Container\n-\n-        others =>\n-          P.Has_Key (Positions (Container), Find'Result)\n-            and P.Get (Positions (Container), Find'Result) =\n-                Find (Elements (Container), Item)\n-\n-            --  The element designated by the result of Find is Item\n-\n-            and Equivalent_Elements\n-                  (Element (Container, Find'Result), Item));\n-   --  Searches for Item in the set. Find calls Hash to determine the item's\n-   --  bucket; if the bucket is not empty, it calls Equivalent_Elements to\n-   --  compare Item to each element in the bucket. If the search succeeds, Find\n-   --  returns a cursor designating the node containing the equivalent element;\n-   --  otherwise, it returns No_Element.\n-\n-   function Contains (Container : Set; Item : Element_Type) return Boolean with\n-     Global => null,\n-     Post   => Contains'Result = Contains (Model (Container), Item);\n-   pragma Annotate (GNATprove, Inline_For_Proof, Contains);\n-\n-   function Has_Element (Container : Set; Position : Cursor) return Boolean\n-   with\n-     Global => null,\n-     Post   =>\n-       Has_Element'Result = P.Has_Key (Positions (Container), Position);\n-   pragma Annotate (GNATprove, Inline_For_Proof, Has_Element);\n-\n-   function Default_Modulus (Capacity : Count_Type) return Hash_Type with\n-     Global => null;\n-\n-   generic\n-      type Key_Type (<>) is private;\n-\n-      with function Key (Element : Element_Type) return Key_Type;\n-\n-      with function Hash (Key : Key_Type) return Hash_Type;\n-\n-      with function Equivalent_Keys (Left, Right : Key_Type) return Boolean;\n-\n-   package Generic_Keys with SPARK_Mode is\n-\n-      package Formal_Model with Ghost is\n-\n-         function M_Included_Except\n-           (Left  : M.Set;\n-            Right : M.Set;\n-            Key   : Key_Type) return Boolean\n-           with\n-             Global => null,\n-             Post   =>\n-               M_Included_Except'Result =\n-                 (for all E of Left =>\n-                   Contains (Right, E)\n-                     or Equivalent_Keys (Generic_Keys.Key (E), Key));\n-\n-      end Formal_Model;\n-      use Formal_Model;\n-\n-      function Key (Container : Set; Position : Cursor) return Key_Type with\n-        Global => null,\n-        Post   => Key'Result = Key (Element (Container, Position));\n-      pragma Annotate (GNATprove, Inline_For_Proof, Key);\n-\n-      function Element (Container : Set; Key : Key_Type) return Element_Type\n-      with\n-        Global => null,\n-        Pre    => Contains (Container, Key),\n-        Post   =>\n-          Element'Result = Element (Container, Find (Container, Key));\n-      pragma Annotate (GNATprove, Inline_For_Proof, Element);\n-\n-      procedure Replace\n-        (Container : in out Set;\n-         Key       : Key_Type;\n-         New_Item  : Element_Type)\n-      with\n-        Global => null,\n-        Pre    => Contains (Container, Key),\n-        Post   =>\n-          Length (Container) = Length (Container)'Old\n-\n-             --  Key now maps to New_Item\n-\n-             and Element (Container, Key) = New_Item\n-\n-             --  New_Item is contained in Container\n-\n-             and Contains (Model (Container), New_Item)\n-\n-             --  Other elements are preserved\n-\n-             and M_Included_Except\n-                   (Model (Container)'Old,\n-                    Model (Container),\n-                    Key)\n-             and M.Included_Except\n-                   (Model (Container),\n-                    Model (Container)'Old,\n-                    New_Item)\n-\n-             --  Mapping from cursors to elements is preserved\n-\n-             and Mapping_Preserved_Except\n-                   (E_Left   => Elements (Container)'Old,\n-                    E_Right  => Elements (Container),\n-                    P_Left   => Positions (Container)'Old,\n-                    P_Right  => Positions (Container),\n-                    Position => Find (Container, Key))\n-             and Positions (Container) = Positions (Container)'Old;\n-\n-      procedure Exclude (Container : in out Set; Key : Key_Type) with\n-        Global         => null,\n-        Post           => not Contains (Container, Key),\n-        Contract_Cases =>\n-\n-          --  If Key is not in Container, nothing is changed\n-\n-          (not Contains (Container, Key) =>\n-             Model (Container) = Model (Container)'Old\n-               and Elements (Container) = Elements (Container)'Old\n-               and Positions (Container) = Positions (Container)'Old,\n-\n-           --  Otherwise, Key is removed from Container\n-\n-           others =>\n-             Length (Container) = Length (Container)'Old - 1\n-\n-               --  Other elements are preserved\n-\n-               and Model (Container) <= Model (Container)'Old\n-               and M_Included_Except\n-                     (Model (Container)'Old,\n-                      Model (Container),\n-                      Key)\n-\n-               --  Mapping from cursors to elements is preserved\n-\n-               and Mapping_Preserved\n-                     (E_Left  => Elements (Container),\n-                      E_Right => Elements (Container)'Old,\n-                      P_Left  => Positions (Container),\n-                      P_Right => Positions (Container)'Old)\n-               and P.Keys_Included_Except\n-                     (Positions (Container)'Old,\n-                      Positions (Container),\n-                      Find (Container, Key)'Old));\n-\n-      procedure Delete (Container : in out Set; Key : Key_Type) with\n-        Global => null,\n-        Pre    => Contains (Container, Key),\n-        Post   =>\n-          Length (Container) = Length (Container)'Old - 1\n-\n-            --  Key is no longer in Container\n-\n-            and not Contains (Container, Key)\n-\n-            --  Other elements are preserved\n-\n-            and Model (Container) <= Model (Container)'Old\n-            and M_Included_Except\n-                  (Model (Container)'Old,\n-                   Model (Container),\n-                   Key)\n-\n-            --  Mapping from cursors to elements is preserved\n-\n-            and Mapping_Preserved\n-                  (E_Left  => Elements (Container),\n-                   E_Right => Elements (Container)'Old,\n-                   P_Left  => Positions (Container),\n-                   P_Right => Positions (Container)'Old)\n-            and P.Keys_Included_Except\n-                  (Positions (Container)'Old,\n-                   Positions (Container),\n-                   Find (Container, Key)'Old);\n-\n-      function Find (Container : Set; Key : Key_Type) return Cursor with\n-        Global         => null,\n-        Contract_Cases =>\n-\n-          --  If Key is not contained in Container, Find returns No_Element\n-\n-          ((for all E of Model (Container) =>\n-               not Equivalent_Keys (Key, Generic_Keys.Key (E))) =>\n-             Find'Result = No_Element,\n-\n-           --  Otherwise, Find returns a valid cursor in Container\n-\n-           others =>\n-             P.Has_Key (Positions (Container), Find'Result)\n-\n-               --  The key designated by the result of Find is Key\n-\n-               and Equivalent_Keys\n-                     (Generic_Keys.Key (Container, Find'Result), Key));\n-\n-      function Contains (Container : Set; Key : Key_Type) return Boolean with\n-        Global => null,\n-        Post   =>\n-          Contains'Result =\n-            (for some E of Model (Container) =>\n-              Equivalent_Keys (Key, Generic_Keys.Key (E)));\n-\n-   end Generic_Keys;\n-\n-private\n-   pragma SPARK_Mode (Off);\n-\n-   pragma Inline (Next);\n-\n-   type Node_Type is\n-      record\n-         Element     : aliased Element_Type;\n-         Next        : Count_Type;\n-         Has_Element : Boolean := False;\n-      end record;\n-\n-   package HT_Types is new\n-     Ada.Containers.Hash_Tables.Generic_Formal_Hash_Table_Types (Node_Type);\n-\n-   type Set (Capacity : Count_Type; Modulus : Hash_Type) is record\n-     Content : HT_Types.Hash_Table_Type (Capacity, Modulus);\n-   end record;\n-\n-   use HT_Types;\n+package Ada.Containers.Formal_Hashed_Sets with SPARK_Mode is\n \n-   Empty_Set : constant Set := (Capacity => 0, Modulus => 0, others => <>);\n+   pragma Compile_Time_Error\n+     (True,\n+      \"This package has been moved to the SPARK library shipped with any\"\n+      & \" SPARK release starting with version 23.\");\n \n end Ada.Containers.Formal_Hashed_Sets;"}, {"sha": "17e48d29e65fbd60403a55972d1ee932cd343e6a", "filename": "gcc/ada/libgnat/a-cfidll.adb", "status": "removed", "additions": 0, "deletions": 2054, "changes": 2054, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cfidll.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cfidll.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfidll.adb?ref=cf8af60f6a3910577e99db04dbc757e731558144", "patch": "@@ -1,2054 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT LIBRARY COMPONENTS                          --\n---                                                                          --\n---           ADA.CONTAINERS.FORMAL_INDEFINITE_DOUBLY_LINKED_LISTS           --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2022-2022, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Unchecked_Deallocation;\n-\n-with Ada.Containers.Stable_Sorting; use Ada.Containers.Stable_Sorting;\n-\n-with System; use type System.Address;\n-\n-with Ada.Numerics.Big_Numbers.Big_Integers;\n-use Ada.Numerics.Big_Numbers.Big_Integers;\n-\n-package body Ada.Containers.Formal_Indefinite_Doubly_Linked_Lists with\n-  SPARK_Mode => Off\n-is\n-   --  Convert Count_Type to Big_Integer\n-\n-   package Conversions is new Signed_Conversions (Int => Count_Type);\n-   use Conversions;\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   procedure Allocate\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      New_Node  : out Count_Type);\n-\n-   procedure Allocate\n-     (Container : in out List;\n-      New_Node  : out Count_Type);\n-\n-   procedure Free (Container : in out List; X : Count_Type);\n-\n-   procedure Insert_Internal\n-     (Container : in out List;\n-      Before    : Count_Type;\n-      New_Node  : Count_Type);\n-\n-   function Vet (L : List; Position : Cursor) return Boolean with Inline;\n-\n-   procedure Resize (Container : in out List) with\n-   --  Add more room in the internal array\n-\n-     Global => null,\n-     Pre    => Container.Nodes = null\n-                 or else Length (Container) = Container.Nodes'Length,\n-     Post   => Model (Container) = Model (Container)'Old\n-                 and Positions (Container) = Positions (Container)'Old;\n-\n-   procedure Finalize_Element is new Ada.Unchecked_Deallocation\n-     (Object => Element_Type,\n-      Name   => Element_Access);\n-\n-   procedure Finalize_Nodes is new Ada.Unchecked_Deallocation\n-     (Object => Node_Array,\n-      Name   => Node_Array_Access);\n-\n-   ---------\n-   -- \"=\" --\n-   ---------\n-\n-   function \"=\" (Left : List; Right : List) return Boolean is\n-      LI : Count_Type;\n-      RI : Count_Type;\n-\n-   begin\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n-      if Left.Length /= Right.Length then\n-         return False;\n-      end if;\n-\n-      LI := Left.First;\n-      RI := Right.First;\n-      while LI /= 0 loop\n-         if Left.Nodes (LI).Element.all /= Right.Nodes (RI).Element.all then\n-            return False;\n-         end if;\n-\n-         LI := Left.Nodes (LI).Next;\n-         RI := Right.Nodes (RI).Next;\n-      end loop;\n-\n-      return True;\n-   end \"=\";\n-\n-   ------------\n-   -- Adjust --\n-   ------------\n-\n-   overriding procedure Adjust (Container : in out List) is\n-      N_Src : Node_Array_Access renames Container.Nodes;\n-      N_Tar : Node_Array_Access;\n-\n-   begin\n-      if N_Src = null then\n-         return;\n-      end if;\n-\n-      if Container.Length = 0 then\n-         Container.Nodes := null;\n-         Container.Free := -1;\n-         return;\n-      end if;\n-\n-      N_Tar := new Node_Array (1 .. N_Src'Length);\n-\n-      for X in 1 .. Count_Type (N_Src'Length) loop\n-         N_Tar (X) := N_Src (X);\n-         if N_Src (X).Element /= null\n-         then\n-            N_Tar (X).Element := new Element_Type'(N_Src (X).Element.all);\n-         end if;\n-      end loop;\n-\n-      N_Src := N_Tar;\n-\n-   end Adjust;\n-\n-   --------------\n-   -- Allocate --\n-   --------------\n-\n-   procedure Allocate\n-     (Container : in out List;\n-      New_Node  : out Count_Type)\n-   is\n-      N : Node_Array_Access renames Container.Nodes;\n-\n-   begin\n-      if Container.Nodes = null\n-        or else Length (Container) = Container.Nodes'Length\n-      then\n-         Resize (Container);\n-      end if;\n-\n-      if Container.Free >= 0 then\n-         New_Node := Container.Free;\n-         Container.Free := N (New_Node).Next;\n-      else\n-         New_Node := abs Container.Free;\n-         Container.Free := Container.Free - 1;\n-      end if;\n-\n-      N (New_Node).Element := null;\n-   end Allocate;\n-\n-   procedure Allocate\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      New_Node  : out Count_Type)\n-   is\n-      N : Node_Array_Access renames Container.Nodes;\n-\n-   begin\n-      Allocate (Container, New_Node);\n-\n-      N (New_Node).Element := new Element_Type'(New_Item);\n-   end Allocate;\n-\n-   ------------\n-   -- Append --\n-   ------------\n-\n-   procedure Append (Container : in out List; New_Item : Element_Type) is\n-   begin\n-      Insert (Container, No_Element, New_Item, 1);\n-   end Append;\n-\n-   procedure Append\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   is\n-   begin\n-      Insert (Container, No_Element, New_Item, Count);\n-   end Append;\n-\n-   ------------\n-   -- Assign --\n-   ------------\n-\n-   procedure Assign (Target : in out List; Source : List) is\n-      N : Node_Array_Access renames Source.Nodes;\n-      J : Count_Type;\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n-      Clear (Target);\n-\n-      J := Source.First;\n-      while J /= 0 loop\n-         Append (Target, N (J).Element.all);\n-         J := N (J).Next;\n-      end loop;\n-   end Assign;\n-\n-   -----------\n-   -- Clear --\n-   -----------\n-\n-   procedure Clear (Container : in out List) is\n-      N : Node_Array_Access renames Container.Nodes;\n-      X : Count_Type;\n-\n-   begin\n-      if Container.Length = 0 then\n-         pragma Assert (Container.First = 0);\n-         pragma Assert (Container.Last  = 0);\n-         return;\n-      end if;\n-\n-      pragma Assert (Container.First >= 1);\n-      pragma Assert (Container.Last  >= 1);\n-      pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next  = 0);\n-\n-      while Container.Length > 1 loop\n-         X := Container.First;\n-\n-         Container.First := N (X).Next;\n-         N (Container.First).Prev := 0;\n-\n-         Container.Length := Container.Length - 1;\n-\n-         Free (Container, X);\n-      end loop;\n-\n-      X := Container.First;\n-\n-      Container.First := 0;\n-      Container.Last := 0;\n-      Container.Length := 0;\n-\n-      Free (Container, X);\n-   end Clear;\n-\n-   ------------------------\n-   -- Constant_Reference --\n-   ------------------------\n-\n-   function Constant_Reference\n-     (Container : List;\n-      Position  : Cursor) return not null access constant Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container => Container, Position  => Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return Container.Nodes (Position.Node).Element;\n-   end Constant_Reference;\n-\n-   --------------\n-   -- Contains --\n-   --------------\n-\n-   function Contains\n-     (Container : List;\n-      Item      : Element_Type) return Boolean\n-   is\n-   begin\n-      return Find (Container, Item) /= No_Element;\n-   end Contains;\n-\n-   ----------\n-   -- Copy --\n-   ----------\n-\n-   function Copy (Source : List) return List\n-   is\n-      N : Count_Type;\n-      P : List;\n-\n-   begin\n-      if Source.Nodes = null then\n-         return P;\n-      end if;\n-\n-      P.Nodes := new Node_Array (1 .. Source.Nodes'Length);\n-\n-      N := 1;\n-      while N <= Source.Nodes'Length loop\n-         P.Nodes (N).Prev := Source.Nodes (N).Prev;\n-         P.Nodes (N).Next := Source.Nodes (N).Next;\n-         if Source.Nodes (N).Element /= null then\n-            P.Nodes (N).Element :=\n-              new Element_Type'(Source.Nodes (N).Element.all);\n-         end if;\n-         N := N + 1;\n-      end loop;\n-\n-      P.Free   := Source.Free;\n-      P.Length := Source.Length;\n-      P.First  := Source.First;\n-      P.Last   := Source.Last;\n-\n-      return P;\n-   end Copy;\n-\n-   ------------\n-   -- Delete --\n-   ------------\n-\n-   procedure Delete (Container : in out List; Position : in out Cursor) is\n-   begin\n-      Delete\n-        (Container => Container,\n-         Position  => Position,\n-         Count     => 1);\n-   end Delete;\n-\n-   procedure Delete\n-     (Container : in out List;\n-      Position  : in out Cursor;\n-      Count     : Count_Type)\n-   is\n-      N : Node_Array_Access renames Container.Nodes;\n-      X : Count_Type;\n-\n-   begin\n-      if not Has_Element (Container => Container,\n-                          Position  => Position)\n-      then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container, Position), \"bad cursor in Delete\");\n-      pragma Assert (Container.First >= 1);\n-      pragma Assert (Container.Last  >= 1);\n-      pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next  = 0);\n-\n-      if Position.Node = Container.First then\n-         Delete_First (Container, Count);\n-         Position := No_Element;\n-         return;\n-      end if;\n-\n-      if Count = 0 then\n-         Position := No_Element;\n-         return;\n-      end if;\n-\n-      for Index in 1 .. Count loop\n-         pragma Assert (Container.Length >= 2);\n-\n-         X := Position.Node;\n-         Container.Length := Container.Length - 1;\n-\n-         if X = Container.Last then\n-            Position := No_Element;\n-\n-            Container.Last := N (X).Prev;\n-            N (Container.Last).Next := 0;\n-\n-            Free (Container, X);\n-            return;\n-         end if;\n-\n-         Position.Node := N (X).Next;\n-         pragma Assert (N (Position.Node).Prev >= 0);\n-\n-         N (N (X).Next).Prev := N (X).Prev;\n-         N (N (X).Prev).Next := N (X).Next;\n-\n-         Free (Container, X);\n-      end loop;\n-\n-      Position := No_Element;\n-   end Delete;\n-\n-   ------------------\n-   -- Delete_First --\n-   ------------------\n-\n-   procedure Delete_First (Container : in out List) is\n-   begin\n-      Delete_First\n-        (Container => Container,\n-         Count     => 1);\n-   end Delete_First;\n-\n-   procedure Delete_First (Container : in out List; Count : Count_Type) is\n-      N : Node_Array_Access renames Container.Nodes;\n-      X : Count_Type;\n-\n-   begin\n-      if Count >= Container.Length then\n-         Clear (Container);\n-         return;\n-      end if;\n-\n-      if Count = 0 then\n-         return;\n-      end if;\n-\n-      for J in 1 .. Count loop\n-         X := Container.First;\n-         pragma Assert (N (N (X).Next).Prev = Container.First);\n-\n-         Container.First := N (X).Next;\n-         N (Container.First).Prev := 0;\n-\n-         Container.Length := Container.Length - 1;\n-\n-         Free (Container, X);\n-      end loop;\n-   end Delete_First;\n-\n-   -----------------\n-   -- Delete_Last --\n-   -----------------\n-\n-   procedure Delete_Last (Container : in out List) is\n-   begin\n-      Delete_Last\n-        (Container => Container,\n-         Count     => 1);\n-   end Delete_Last;\n-\n-   procedure Delete_Last (Container : in out List; Count : Count_Type) is\n-      N : Node_Array_Access renames Container.Nodes;\n-      X : Count_Type;\n-\n-   begin\n-      if Count >= Container.Length then\n-         Clear (Container);\n-         return;\n-      end if;\n-\n-      if Count = 0 then\n-         return;\n-      end if;\n-\n-      for J in 1 .. Count loop\n-         X := Container.Last;\n-         pragma Assert (N (N (X).Prev).Next = Container.Last);\n-\n-         Container.Last := N (X).Prev;\n-         N (Container.Last).Next := 0;\n-\n-         Container.Length := Container.Length - 1;\n-\n-         Free (Container, X);\n-      end loop;\n-   end Delete_Last;\n-\n-   -------------\n-   -- Element --\n-   -------------\n-\n-   function Element\n-     (Container : List;\n-      Position  : Cursor) return Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container => Container, Position  => Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return Container.Nodes (Position.Node).Element.all;\n-   end Element;\n-\n-   ----------------\n-   -- Empty_List --\n-   ----------------\n-\n-   function Empty_List return List is\n-      ((Controlled with others => <>));\n-\n-   --------------\n-   -- Finalize --\n-   --------------\n-\n-   procedure Finalize (Container : in out List) is\n-      X : Count_Type := Container.First;\n-      N : Node_Array_Access renames Container.Nodes;\n-   begin\n-\n-      if N = null then\n-         return;\n-      end if;\n-\n-      while X /= 0 loop\n-         Finalize_Element (N (X).Element);\n-         X := N (X).Next;\n-      end loop;\n-\n-      Finalize_Nodes (N);\n-\n-      Container.Free := 0;\n-      Container.Last := 0;\n-      Container.First := 0;\n-      Container.Length := 0;\n-   end Finalize;\n-\n-   ----------\n-   -- Find --\n-   ----------\n-\n-   function Find\n-     (Container : List;\n-      Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor\n-   is\n-      From : Count_Type := Position.Node;\n-\n-   begin\n-      if From = 0 and Container.Length = 0 then\n-         return No_Element;\n-      end if;\n-\n-      if From = 0 then\n-         From := Container.First;\n-      end if;\n-\n-      if Position.Node /= 0 and then not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      while From /= 0 loop\n-         if Container.Nodes (From).Element.all = Item then\n-            return (Node => From);\n-         end if;\n-\n-         From := Container.Nodes (From).Next;\n-      end loop;\n-\n-      return No_Element;\n-   end Find;\n-\n-   -----------\n-   -- First --\n-   -----------\n-\n-   function First (Container : List) return Cursor is\n-   begin\n-      if Container.First = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Container.First);\n-   end First;\n-\n-   -------------------\n-   -- First_Element --\n-   -------------------\n-\n-   function First_Element (Container : List) return Element_Type is\n-      F : constant Count_Type := Container.First;\n-   begin\n-      if F = 0 then\n-         raise Constraint_Error with \"list is empty\";\n-      else\n-         return Container.Nodes (F).Element.all;\n-      end if;\n-   end First_Element;\n-\n-   ------------------\n-   -- Formal_Model --\n-   ------------------\n-\n-   package body Formal_Model is\n-\n-      ----------------------------\n-      -- Lift_Abstraction_Level --\n-      ----------------------------\n-\n-      procedure Lift_Abstraction_Level (Container : List) is null;\n-\n-      -------------------------\n-      -- M_Elements_In_Union --\n-      -------------------------\n-\n-      function M_Elements_In_Union\n-        (Container : M.Sequence;\n-         Left      : M.Sequence;\n-         Right     : M.Sequence) return Boolean\n-      is\n-         Elem : Element_Type;\n-\n-      begin\n-         for Index in 1 .. M.Length (Container) loop\n-            Elem := Element (Container, Index);\n-\n-            if not M.Contains (Left, 1, M.Length (Left), Elem)\n-               and then not M.Contains (Right, 1, M.Length (Right), Elem)\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end M_Elements_In_Union;\n-\n-      -------------------------\n-      -- M_Elements_Included --\n-      -------------------------\n-\n-      function M_Elements_Included\n-        (Left  : M.Sequence;\n-         L_Fst : Positive_Count_Type := 1;\n-         L_Lst : Count_Type;\n-         Right : M.Sequence;\n-         R_Fst : Positive_Count_Type := 1;\n-         R_Lst : Count_Type) return Boolean\n-      is\n-      begin\n-         for I in L_Fst .. L_Lst loop\n-            declare\n-               Found : Boolean := False;\n-               J     : Count_Type := R_Fst - 1;\n-\n-            begin\n-               while not Found and J < R_Lst loop\n-                  J := J + 1;\n-                  if Element (Left, I) = Element (Right, J) then\n-                     Found := True;\n-                  end if;\n-               end loop;\n-\n-               if not Found then\n-                  return False;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end M_Elements_Included;\n-\n-      -------------------------\n-      -- M_Elements_Reversed --\n-      -------------------------\n-\n-      function M_Elements_Reversed\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean\n-      is\n-         L : constant Count_Type := M.Length (Left);\n-\n-      begin\n-         if L /= M.Length (Right) then\n-            return False;\n-         end if;\n-\n-         for I in 1 .. L loop\n-            if Element (Left, I) /= Element (Right, L - I + 1) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end M_Elements_Reversed;\n-\n-      ------------------------\n-      -- M_Elements_Swapped --\n-      ------------------------\n-\n-      function M_Elements_Swapped\n-        (Left  : M.Sequence;\n-         Right : M.Sequence;\n-         X     : Positive_Count_Type;\n-         Y     : Positive_Count_Type) return Boolean\n-      is\n-      begin\n-         if M.Length (Left) /= M.Length (Right)\n-           or else Element (Left, X) /= Element (Right, Y)\n-           or else Element (Left, Y) /= Element (Right, X)\n-         then\n-            return False;\n-         end if;\n-\n-         for I in 1 .. M.Length (Left) loop\n-            if I /= X and then I /= Y\n-              and then Element (Left, I) /= Element (Right, I)\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end M_Elements_Swapped;\n-\n-      -----------\n-      -- Model --\n-      -----------\n-\n-      function Model (Container : List) return M.Sequence is\n-         Position : Count_Type := Container.First;\n-         R        : M.Sequence;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R := M.Add (R, Container.Nodes (Position).Element.all);\n-            Position := Container.Nodes (Position).Next;\n-         end loop;\n-\n-         return R;\n-      end Model;\n-\n-      -----------------------\n-      -- Mapping_Preserved --\n-      -----------------------\n-\n-      function Mapping_Preserved\n-        (M_Left  : M.Sequence;\n-         M_Right : M.Sequence;\n-         P_Left  : P.Map;\n-         P_Right : P.Map) return Boolean\n-      is\n-      begin\n-         for C of P_Left loop\n-            if not P.Has_Key (P_Right, C)\n-              or else P.Get (P_Left,  C) > M.Length (M_Left)\n-              or else P.Get (P_Right, C) > M.Length (M_Right)\n-              or else M.Get (M_Left,  P.Get (P_Left,  C)) /=\n-                      M.Get (M_Right, P.Get (P_Right, C))\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         for C of P_Right loop\n-            if not P.Has_Key (P_Left, C) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end Mapping_Preserved;\n-\n-      -------------------------\n-      -- P_Positions_Shifted --\n-      -------------------------\n-\n-      function P_Positions_Shifted\n-        (Small : P.Map;\n-         Big   : P.Map;\n-         Cut   : Positive_Count_Type;\n-         Count : Count_Type := 1) return Boolean\n-      is\n-      begin\n-         for Cu of Small loop\n-            if not P.Has_Key (Big, Cu) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         for Cu of Big loop\n-            declare\n-               Pos : constant Positive_Count_Type := P.Get (Big, Cu);\n-\n-            begin\n-               if Pos < Cut then\n-                  if not P.Has_Key (Small, Cu)\n-                    or else Pos /= P.Get (Small, Cu)\n-                  then\n-                     return False;\n-                  end if;\n-\n-               elsif Pos >= Cut + Count then\n-                  if not P.Has_Key (Small, Cu)\n-                    or else Pos /= P.Get (Small, Cu) + Count\n-                  then\n-                     return False;\n-                  end if;\n-\n-               else\n-                  if P.Has_Key (Small, Cu) then\n-                     return False;\n-                  end if;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end P_Positions_Shifted;\n-\n-      -------------------------\n-      -- P_Positions_Swapped --\n-      -------------------------\n-\n-      function P_Positions_Swapped\n-        (Left  : P.Map;\n-         Right : P.Map;\n-         X     : Cursor;\n-         Y     : Cursor) return Boolean\n-      is\n-      begin\n-         if not P.Has_Key (Left, X)\n-           or not P.Has_Key (Left, Y)\n-           or not P.Has_Key (Right, X)\n-           or not P.Has_Key (Right, Y)\n-         then\n-            return False;\n-         end if;\n-\n-         if P.Get (Left, X) /= P.Get (Right, Y)\n-           or P.Get (Left, Y) /= P.Get (Right, X)\n-         then\n-            return False;\n-         end if;\n-\n-         for C of Left loop\n-            if not P.Has_Key (Right, C) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         for C of Right loop\n-            if not P.Has_Key (Left, C)\n-              or else (C /= X\n-                        and C /= Y\n-                        and P.Get (Left, C) /= P.Get (Right, C))\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end P_Positions_Swapped;\n-\n-      ---------------------------\n-      -- P_Positions_Truncated --\n-      ---------------------------\n-\n-      function P_Positions_Truncated\n-        (Small : P.Map;\n-         Big   : P.Map;\n-         Cut   : Positive_Count_Type;\n-         Count : Count_Type := 1) return Boolean\n-      is\n-      begin\n-         for Cu of Small loop\n-            if not P.Has_Key (Big, Cu) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         for Cu of Big loop\n-            declare\n-               Pos : constant Positive_Count_Type := P.Get (Big, Cu);\n-\n-            begin\n-               if Pos < Cut then\n-                  if not P.Has_Key (Small, Cu)\n-                    or else Pos /= P.Get (Small, Cu)\n-                  then\n-                     return False;\n-                  end if;\n-\n-               elsif Pos >= Cut + Count then\n-                  return False;\n-\n-               elsif P.Has_Key (Small, Cu) then\n-                  return False;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end P_Positions_Truncated;\n-\n-      ---------------\n-      -- Positions --\n-      ---------------\n-\n-      function Positions (Container : List) return P.Map is\n-         I        : Count_Type := 1;\n-         Position : Count_Type := Container.First;\n-         R        : P.Map;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R := P.Add (R, (Node => Position), I);\n-            pragma Assert (P.Length (R) = To_Big_Integer (I));\n-            Position := Container.Nodes (Position).Next;\n-            I := I + 1;\n-         end loop;\n-\n-         return R;\n-      end Positions;\n-\n-   end Formal_Model;\n-\n-   ----------\n-   -- Free --\n-   ----------\n-\n-   procedure Free (Container : in out List; X : Count_Type) is\n-      pragma Assert (X > 0);\n-      pragma Assert (X <= Container.Nodes'Length);\n-\n-      N : Node_Array_Access renames Container.Nodes;\n-\n-   begin\n-      N (X).Prev := -1;  -- Node is deallocated (not on active list)\n-\n-      if N (X).Element /= null then\n-         Finalize_Element (N (X).Element);\n-      end if;\n-\n-      if Container.Free >= 0 then\n-         N (X).Next := Container.Free;\n-         Container.Free := X;\n-      elsif X + 1 = abs Container.Free then\n-         N (X).Next := 0;  -- Not strictly necessary, but marginally safer\n-         Container.Free := Container.Free + 1;\n-      else\n-         Container.Free := abs Container.Free;\n-\n-         for J in Container.Free .. Container.Nodes'Length loop\n-            N (J).Next := J + 1;\n-         end loop;\n-\n-         N (Container.Nodes'Length).Next := 0;\n-\n-         N (X).Next := Container.Free;\n-         Container.Free := X;\n-      end if;\n-   end Free;\n-\n-   ---------------------\n-   -- Generic_Sorting --\n-   ---------------------\n-\n-   package body Generic_Sorting with SPARK_Mode => Off is\n-\n-      ------------------\n-      -- Formal_Model --\n-      ------------------\n-\n-      package body Formal_Model is\n-\n-         -----------------------\n-         -- M_Elements_Sorted --\n-         -----------------------\n-\n-         function M_Elements_Sorted (Container : M.Sequence) return Boolean is\n-         begin\n-            if M.Length (Container) = 0 then\n-               return True;\n-            end if;\n-\n-            declare\n-               E1 : Element_Type := Element (Container, 1);\n-\n-            begin\n-               for I in 2 .. M.Length (Container) loop\n-                  declare\n-                     E2 : constant Element_Type := Element (Container, I);\n-\n-                  begin\n-                     if E2 < E1 then\n-                        return False;\n-                     end if;\n-\n-                     E1 := E2;\n-                  end;\n-               end loop;\n-            end;\n-\n-            return True;\n-         end M_Elements_Sorted;\n-\n-      end Formal_Model;\n-\n-      ---------------\n-      -- Is_Sorted --\n-      ---------------\n-\n-      function Is_Sorted (Container : List) return Boolean is\n-         Nodes : Node_Array_Access renames Container.Nodes;\n-         Node  : Count_Type := Container.First;\n-\n-      begin\n-         for J in 2 .. Container.Length loop\n-            if Nodes (Nodes (Node).Next).Element.all < Nodes (Node).Element.all\n-            then\n-               return False;\n-            else\n-               Node := Nodes (Node).Next;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end Is_Sorted;\n-\n-      -----------\n-      -- Merge --\n-      -----------\n-\n-      procedure Merge (Target : in out List; Source : in out List) is\n-         LN : Node_Array_Access renames Target.Nodes;\n-         RN : Node_Array_Access renames Source.Nodes;\n-         LI : Cursor;\n-         RI : Cursor;\n-\n-      begin\n-         if Target'Address = Source'Address then\n-            raise Program_Error with \"Target and Source denote same container\";\n-         end if;\n-\n-         LI := First (Target);\n-         RI := First (Source);\n-         while RI.Node /= 0 loop\n-            pragma Assert\n-              (RN (RI.Node).Next = 0\n-                or else not (RN (RN (RI.Node).Next).Element.all <\n-                             RN (RI.Node).Element.all));\n-\n-            if LI.Node = 0 then\n-               Splice (Target, No_Element, Source);\n-               return;\n-            end if;\n-\n-            pragma Assert\n-              (LN (LI.Node).Next = 0\n-                or else not (LN (LN (LI.Node).Next).Element.all <\n-                             LN (LI.Node).Element.all));\n-\n-            if RN (RI.Node).Element.all < LN (LI.Node).Element.all then\n-               declare\n-                  RJ : Cursor := RI;\n-                  pragma Warnings (Off, RJ);\n-               begin\n-                  RI.Node := RN (RI.Node).Next;\n-                  Splice (Target, LI, Source, RJ);\n-               end;\n-\n-            else\n-               LI.Node := LN (LI.Node).Next;\n-            end if;\n-         end loop;\n-      end Merge;\n-\n-      ----------\n-      -- Sort --\n-      ----------\n-\n-      procedure Sort (Container : in out List) is\n-         N : Node_Array_Access renames Container.Nodes;\n-      begin\n-         if Container.Length <= 1 then\n-            return;\n-         end if;\n-\n-         pragma Assert (N (Container.First).Prev = 0);\n-         pragma Assert (N (Container.Last).Next = 0);\n-\n-         declare\n-            package Descriptors is new List_Descriptors\n-              (Node_Ref => Count_Type, Nil => 0);\n-            use Descriptors;\n-\n-            function Next (Idx : Count_Type) return Count_Type is\n-              (N (Idx).Next);\n-            procedure Set_Next (Idx : Count_Type; Next : Count_Type)\n-              with Inline;\n-            procedure Set_Prev (Idx : Count_Type; Prev : Count_Type)\n-              with Inline;\n-            function \"<\" (L, R : Count_Type) return Boolean is\n-              (N (L).Element.all < N (R).Element.all);\n-            procedure Update_Container (List : List_Descriptor) with Inline;\n-\n-            procedure Set_Next (Idx : Count_Type; Next : Count_Type) is\n-            begin\n-               N (Idx).Next := Next;\n-            end Set_Next;\n-\n-            procedure Set_Prev (Idx : Count_Type; Prev : Count_Type) is\n-            begin\n-               N (Idx).Prev := Prev;\n-            end Set_Prev;\n-\n-            procedure Update_Container (List : List_Descriptor) is\n-            begin\n-               Container.First  := List.First;\n-               Container.Last   := List.Last;\n-               Container.Length := List.Length;\n-            end Update_Container;\n-\n-            procedure Sort_List is new Doubly_Linked_List_Sort;\n-         begin\n-            Sort_List (List_Descriptor'(First  => Container.First,\n-                                        Last   => Container.Last,\n-                                        Length => Container.Length));\n-         end;\n-\n-         pragma Assert (N (Container.First).Prev = 0);\n-         pragma Assert (N (Container.Last).Next = 0);\n-      end Sort;\n-\n-   end Generic_Sorting;\n-\n-   -----------------\n-   -- Has_Element --\n-   -----------------\n-\n-   function Has_Element (Container : List; Position : Cursor) return Boolean is\n-   begin\n-      if Position.Node = 0 then\n-         return False;\n-      end if;\n-\n-      return Container.Nodes (Position.Node).Prev /= -1;\n-   end Has_Element;\n-\n-   ------------\n-   -- Insert --\n-   ------------\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor;\n-      Count     : Count_Type)\n-   is\n-      J : Count_Type;\n-\n-   begin\n-      if Before.Node /= 0 then\n-         pragma Assert (Vet (Container, Before), \"bad cursor in Insert\");\n-      end if;\n-\n-      if Count = 0 then\n-         Position := Before;\n-         return;\n-      end if;\n-      Allocate (Container, New_Item, New_Node => J);\n-      Insert_Internal (Container, Before.Node, New_Node => J);\n-      Position := (Node => J);\n-\n-      for Index in 2 .. Count loop\n-         Allocate (Container, New_Item, New_Node => J);\n-         Insert_Internal (Container, Before.Node, New_Node => J);\n-      end loop;\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor)\n-   is\n-   begin\n-      Insert\n-        (Container => Container,\n-         Before    => Before,\n-         New_Item  => New_Item,\n-         Position  => Position,\n-         Count     => 1);\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   is\n-      Position : Cursor;\n-\n-   begin\n-      Insert (Container, Before, New_Item, Position, Count);\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type)\n-   is\n-      Position : Cursor;\n-\n-   begin\n-      Insert (Container, Before, New_Item, Position, 1);\n-   end Insert;\n-\n-   ---------------------\n-   -- Insert_Internal --\n-   ---------------------\n-\n-   procedure Insert_Internal\n-     (Container : in out List;\n-      Before    : Count_Type;\n-      New_Node  : Count_Type)\n-   is\n-      N : Node_Array_Access renames Container.Nodes;\n-\n-   begin\n-      if Container.Length = 0 then\n-         pragma Assert (Before = 0);\n-         pragma Assert (Container.First = 0);\n-         pragma Assert (Container.Last = 0);\n-\n-         Container.First := New_Node;\n-         Container.Last := New_Node;\n-\n-         N (Container.First).Prev := 0;\n-         N (Container.Last).Next := 0;\n-\n-      elsif Before = 0 then\n-         pragma Assert (N (Container.Last).Next = 0);\n-\n-         N (Container.Last).Next := New_Node;\n-         N (New_Node).Prev := Container.Last;\n-\n-         Container.Last := New_Node;\n-         N (Container.Last).Next := 0;\n-\n-      elsif Before = Container.First then\n-         pragma Assert (N (Container.First).Prev = 0);\n-\n-         N (Container.First).Prev := New_Node;\n-         N (New_Node).Next := Container.First;\n-\n-         Container.First := New_Node;\n-         N (Container.First).Prev := 0;\n-\n-      else\n-         pragma Assert (N (Container.First).Prev = 0);\n-         pragma Assert (N (Container.Last).Next = 0);\n-\n-         N (New_Node).Next := Before;\n-         N (New_Node).Prev := N (Before).Prev;\n-\n-         N (N (Before).Prev).Next := New_Node;\n-         N (Before).Prev := New_Node;\n-      end if;\n-      Container.Length := Container.Length + 1;\n-   end Insert_Internal;\n-\n-   --------------\n-   -- Is_Empty --\n-   --------------\n-\n-   function Is_Empty (Container : List) return Boolean is\n-   begin\n-      return Length (Container) = 0;\n-   end Is_Empty;\n-\n-   ----------\n-   -- Last --\n-   ----------\n-\n-   function Last (Container : List) return Cursor is\n-   begin\n-      if Container.Last = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Container.Last);\n-   end Last;\n-\n-   ------------------\n-   -- Last_Element --\n-   ------------------\n-\n-   function Last_Element (Container : List) return Element_Type is\n-      L : constant Count_Type := Container.Last;\n-\n-   begin\n-      if L = 0 then\n-         raise Constraint_Error with \"list is empty\";\n-      else\n-         return Container.Nodes (L).Element.all;\n-      end if;\n-   end Last_Element;\n-\n-   ------------\n-   -- Length --\n-   ------------\n-\n-   function Length (Container : List) return Count_Type is\n-   begin\n-      return Container.Length;\n-   end Length;\n-\n-   ----------\n-   -- Move --\n-   ----------\n-\n-   procedure Move (Target : in out List; Source : in out List) is\n-      N     : Node_Array_Access renames Source.Nodes;\n-\n-      procedure Finalize_Node_Array is new Ada.Unchecked_Deallocation\n-        (Object => Node_Array,\n-         Name   => Node_Array_Access);\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n-      Clear (Target);\n-\n-      if Source.Length = 0 then\n-         return;\n-      end if;\n-\n-      --  Make sure that Target is large enough\n-\n-      if Target.Nodes = null\n-        or else Target.Nodes'Length < Source.Length\n-      then\n-         if Target.Nodes /= null then\n-            Finalize_Node_Array (Target.Nodes);\n-         end if;\n-         Target.Nodes := new Node_Array (1 .. Source.Length);\n-      end if;\n-\n-      --  Copy first element from Source to Target\n-\n-      Target.First := 1;\n-\n-      Target.Nodes (1).Prev := 0;\n-      Target.Nodes (1).Element := N (Source.First).Element;\n-      N (Source.First).Element := null;\n-\n-      --  Copy the other elements\n-\n-      declare\n-         X_Src : Count_Type := N (Source.First).Next;\n-         X_Tar : Count_Type := 2;\n-\n-      begin\n-         while X_Src /= 0 loop\n-            Target.Nodes (X_Tar).Prev := X_Tar - 1;\n-            Target.Nodes (X_Tar - 1).Next := X_Tar;\n-\n-            Target.Nodes (X_Tar).Element := N (X_Src).Element;\n-            N (X_Src).Element := null;\n-\n-            X_Src := N (X_Src).Next;\n-            X_Tar := X_Tar + 1;\n-         end loop;\n-      end;\n-\n-      Target.Last := Source.Length;\n-      Target.Length := Source.Length;\n-      Target.Nodes (Target.Last).Next := 0;\n-\n-      --  Set up the free list\n-\n-      Target.Free := -Source.Length - 1;\n-\n-      --  It is possible to Clear Source because the Element accesses were\n-      --  set to null.\n-\n-      Clear (Source);\n-   end Move;\n-\n-   ----------\n-   -- Next --\n-   ----------\n-\n-   procedure Next (Container : List; Position : in out Cursor) is\n-   begin\n-      Position := Next (Container, Position);\n-   end Next;\n-\n-   function Next (Container : List; Position : Cursor) return Cursor is\n-   begin\n-      if Position.Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      if not Has_Element (Container, Position) then\n-         raise Program_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return (Node => Container.Nodes (Position.Node).Next);\n-   end Next;\n-\n-   -------------\n-   -- Prepend --\n-   -------------\n-\n-   procedure Prepend (Container : in out List; New_Item : Element_Type) is\n-   begin\n-      Insert (Container, First (Container), New_Item, 1);\n-   end Prepend;\n-\n-   procedure Prepend\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   is\n-   begin\n-      Insert (Container, First (Container), New_Item, Count);\n-   end Prepend;\n-\n-   --------------\n-   -- Previous --\n-   --------------\n-\n-   procedure Previous (Container : List; Position : in out Cursor) is\n-   begin\n-      Position := Previous (Container, Position);\n-   end Previous;\n-\n-   function Previous (Container : List; Position : Cursor) return Cursor is\n-   begin\n-      if Position.Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      if not Has_Element (Container, Position) then\n-         raise Program_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return (Node => Container.Nodes (Position.Node).Prev);\n-   end Previous;\n-\n-   ---------------\n-   -- Reference --\n-   ---------------\n-\n-   function Reference\n-     (Container : not null access List;\n-      Position  : Cursor) return not null access Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container.all, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      return Container.Nodes (Position.Node).Element;\n-   end Reference;\n-\n-   ---------------------\n-   -- Replace_Element --\n-   ---------------------\n-\n-   procedure Replace_Element\n-     (Container : in out List;\n-      Position  : Cursor;\n-      New_Item  : Element_Type)\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container, Position), \"bad cursor in Replace_Element\");\n-\n-      Finalize_Element (Container.Nodes (Position.Node).Element);\n-      Container.Nodes (Position.Node).Element := new Element_Type'(New_Item);\n-   end Replace_Element;\n-\n-   ------------\n-   -- Resize --\n-   ------------\n-\n-   procedure Resize (Container : in out List) is\n-      Min_Size : constant Count_Type := 100;\n-   begin\n-      if Container.Nodes = null then\n-         Container.Nodes := new Node_Array (1 .. Min_Size);\n-         Container.First := 0;\n-         Container.Last := 0;\n-         Container.Length := 0;\n-         Container.Free := -1;\n-\n-         return;\n-      end if;\n-\n-      if Container.Length /= Container.Nodes'Length then\n-         raise Program_Error with \"List must be at size max to resize\";\n-      end if;\n-\n-      declare\n-         procedure Finalize_Node_Array is new Ada.Unchecked_Deallocation\n-              (Object => Node_Array,\n-               Name   => Node_Array_Access);\n-\n-         New_Size : constant Count_Type :=\n-           (if Container.Nodes'Length > Count_Type'Last / 2\n-            then Count_Type'Last\n-            else 2 * Container.Nodes'Length);\n-         New_Nodes : Node_Array_Access;\n-\n-      begin\n-         New_Nodes :=\n-           new Node_Array (1 .. Count_Type'Max (New_Size, Min_Size));\n-\n-         New_Nodes (1 .. Container.Nodes'Length) :=\n-           Container.Nodes (1 .. Container.Nodes'Length);\n-\n-         Container.Free := -Container.Nodes'Length - 1;\n-\n-         Finalize_Node_Array (Container.Nodes);\n-         Container.Nodes := New_Nodes;\n-      end;\n-   end Resize;\n-\n-   ----------------------\n-   -- Reverse_Elements --\n-   ----------------------\n-\n-   procedure Reverse_Elements (Container : in out List) is\n-      N : Node_Array_Access renames Container.Nodes;\n-      I : Count_Type := Container.First;\n-      J : Count_Type := Container.Last;\n-\n-      procedure Swap (L : Count_Type; R : Count_Type);\n-\n-      ----------\n-      -- Swap --\n-      ----------\n-\n-      procedure Swap (L : Count_Type; R : Count_Type) is\n-         LN : constant Count_Type := N (L).Next;\n-         LP : constant Count_Type := N (L).Prev;\n-\n-         RN : constant Count_Type := N (R).Next;\n-         RP : constant Count_Type := N (R).Prev;\n-\n-      begin\n-         if LP /= 0 then\n-            N (LP).Next := R;\n-         end if;\n-\n-         if RN /= 0 then\n-            N (RN).Prev := L;\n-         end if;\n-\n-         N (L).Next := RN;\n-         N (R).Prev := LP;\n-\n-         if LN = R then\n-            pragma Assert (RP = L);\n-\n-            N (L).Prev := R;\n-            N (R).Next := L;\n-\n-         else\n-            N (L).Prev := RP;\n-            N (RP).Next := L;\n-\n-            N (R).Next := LN;\n-            N (LN).Prev := R;\n-         end if;\n-      end Swap;\n-\n-   --  Start of processing for Reverse_Elements\n-\n-   begin\n-      if Container.Length <= 1 then\n-         return;\n-      end if;\n-\n-      pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next = 0);\n-\n-      Container.First := J;\n-      Container.Last  := I;\n-      loop\n-         Swap (L => I, R => J);\n-\n-         J := N (J).Next;\n-         exit when I = J;\n-\n-         I := N (I).Prev;\n-         exit when I = J;\n-\n-         Swap (L => J, R => I);\n-\n-         I := N (I).Next;\n-         exit when I = J;\n-\n-         J := N (J).Prev;\n-         exit when I = J;\n-      end loop;\n-\n-      pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next = 0);\n-   end Reverse_Elements;\n-\n-   ------------------\n-   -- Reverse_Find --\n-   ------------------\n-\n-   function Reverse_Find\n-     (Container : List;\n-      Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor\n-   is\n-      CFirst : Count_Type := Position.Node;\n-\n-   begin\n-      if CFirst = 0 then\n-         CFirst := Container.Last;\n-      end if;\n-\n-      if Container.Length = 0 then\n-         return No_Element;\n-      else\n-         while CFirst /= 0 loop\n-            if Container.Nodes (CFirst).Element.all = Item then\n-               return (Node => CFirst);\n-            else\n-               CFirst := Container.Nodes (CFirst).Prev;\n-            end if;\n-         end loop;\n-\n-         return No_Element;\n-      end if;\n-   end Reverse_Find;\n-\n-   ------------\n-   -- Splice --\n-   ------------\n-\n-   procedure Splice\n-     (Target : in out List;\n-      Before : Cursor;\n-      Source : in out List)\n-   is\n-      SN : Node_Array_Access renames Source.Nodes;\n-      TN : Node_Array_Access renames Target.Nodes;\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         raise Program_Error with \"Target and Source denote same container\";\n-      end if;\n-\n-      if Before.Node /= 0 then\n-         pragma Assert (Vet (Target, Before), \"bad cursor in Splice\");\n-      end if;\n-\n-      if Is_Empty (Source) then\n-         return;\n-      end if;\n-\n-      pragma Assert (SN (Source.First).Prev = 0);\n-      pragma Assert (SN (Source.Last).Next  = 0);\n-\n-      declare\n-         X : Count_Type;\n-\n-      begin\n-         while not Is_Empty (Source) loop\n-            Allocate (Target, X);\n-\n-            TN (X).Element := SN (Source.Last).Element;\n-\n-            --  Insert the new node in Target\n-\n-            Insert_Internal (Target, Before.Node, X);\n-\n-            --  Free the last node of Source\n-\n-            SN (Source.Last).Element := null;\n-            Delete_Last (Source);\n-         end loop;\n-      end;\n-\n-   end Splice;\n-\n-   procedure Splice\n-     (Target   : in out List;\n-      Before   : Cursor;\n-      Source   : in out List;\n-      Position : in out Cursor)\n-   is\n-   begin\n-      if Target'Address = Source'Address then\n-         raise Program_Error with \"Target and Source denote same container\";\n-      end if;\n-\n-      if Position.Node = 0 then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Source, Position), \"bad Position cursor in Splice\");\n-\n-      declare\n-         X : Count_Type;\n-\n-      begin\n-         Allocate (Target, X);\n-\n-         Target.Nodes (X).Element := Source.Nodes (Position.Node).Element;\n-\n-         --  Insert the new node in Target\n-\n-         Insert_Internal (Target, Before.Node, X);\n-\n-         --  Free the node at position Position in Source\n-\n-         Source.Nodes (Position.Node).Element := null;\n-         Delete (Source, Position);\n-\n-         Position := (Node => X);\n-      end;\n-   end Splice;\n-\n-   procedure Splice\n-     (Container : in out List;\n-      Before    : Cursor;\n-      Position  : Cursor)\n-   is\n-      N : Node_Array_Access renames Container.Nodes;\n-\n-   begin\n-      if Before.Node /= 0 then\n-         pragma Assert\n-           (Vet (Container, Before), \"bad Before cursor in Splice\");\n-      end if;\n-\n-      if Position.Node = 0 then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container, Position), \"bad Position cursor in Splice\");\n-\n-      if Position.Node = Before.Node\n-        or else N (Position.Node).Next = Before.Node\n-      then\n-         return;\n-      end if;\n-\n-      pragma Assert (Container.Length >= 2);\n-\n-      if Before.Node = 0 then\n-         pragma Assert (Position.Node /= Container.Last);\n-\n-         if Position.Node = Container.First then\n-            Container.First := N (Position.Node).Next;\n-            N (Container.First).Prev := 0;\n-\n-         else\n-            N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n-            N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n-         end if;\n-\n-         N (Container.Last).Next := Position.Node;\n-         N (Position.Node).Prev := Container.Last;\n-\n-         Container.Last := Position.Node;\n-         N (Container.Last).Next := 0;\n-\n-         return;\n-      end if;\n-\n-      if Before.Node = Container.First then\n-         pragma Assert (Position.Node /= Container.First);\n-\n-         if Position.Node = Container.Last then\n-            Container.Last := N (Position.Node).Prev;\n-            N (Container.Last).Next := 0;\n-\n-         else\n-            N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n-            N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n-         end if;\n-\n-         N (Container.First).Prev := Position.Node;\n-         N (Position.Node).Next := Container.First;\n-\n-         Container.First := Position.Node;\n-         N (Container.First).Prev := 0;\n-\n-         return;\n-      end if;\n-\n-      if Position.Node = Container.First then\n-         Container.First := N (Position.Node).Next;\n-         N (Container.First).Prev := 0;\n-\n-      elsif Position.Node = Container.Last then\n-         Container.Last := N (Position.Node).Prev;\n-         N (Container.Last).Next := 0;\n-\n-      else\n-         N (N (Position.Node).Prev).Next := N (Position.Node).Next;\n-         N (N (Position.Node).Next).Prev := N (Position.Node).Prev;\n-      end if;\n-\n-      N (N (Before.Node).Prev).Next := Position.Node;\n-      N (Position.Node).Prev := N (Before.Node).Prev;\n-\n-      N (Before.Node).Prev := Position.Node;\n-      N (Position.Node).Next := Before.Node;\n-\n-      pragma Assert (N (Container.First).Prev = 0);\n-      pragma Assert (N (Container.Last).Next = 0);\n-   end Splice;\n-\n-   ----------\n-   -- Swap --\n-   ----------\n-\n-   procedure Swap\n-     (Container : in out List;\n-      I         : Cursor;\n-      J         : Cursor)\n-   is\n-   begin\n-      if I.Node = 0 then\n-         raise Constraint_Error with \"I cursor has no element\";\n-      end if;\n-\n-      if J.Node = 0 then\n-         raise Constraint_Error with \"J cursor has no element\";\n-      end if;\n-\n-      if I.Node = J.Node then\n-         return;\n-      end if;\n-\n-      pragma Assert (Vet (Container, I), \"bad I cursor in Swap\");\n-      pragma Assert (Vet (Container, J), \"bad J cursor in Swap\");\n-\n-      declare\n-         NN : Node_Array_Access renames Container.Nodes;\n-         NI : Node_Type renames NN (I.Node);\n-         NJ : Node_Type renames NN (J.Node);\n-\n-         EI_Copy : constant Element_Access := NI.Element;\n-\n-      begin\n-         NI.Element := NJ.Element;\n-         NJ.Element := EI_Copy;\n-      end;\n-   end Swap;\n-\n-   ----------------\n-   -- Swap_Links --\n-   ----------------\n-\n-   procedure Swap_Links\n-     (Container : in out List;\n-      I         : Cursor;\n-      J         : Cursor)\n-   is\n-      I_Next : Cursor;\n-      J_Next : Cursor;\n-\n-   begin\n-      if I.Node = 0 then\n-         raise Constraint_Error with \"I cursor has no element\";\n-      end if;\n-\n-      if J.Node = 0 then\n-         raise Constraint_Error with \"J cursor has no element\";\n-      end if;\n-\n-      if I.Node = J.Node then\n-         return;\n-      end if;\n-\n-      pragma Assert (Vet (Container, I), \"bad I cursor in Swap_Links\");\n-      pragma Assert (Vet (Container, J), \"bad J cursor in Swap_Links\");\n-\n-      I_Next := Next (Container, I);\n-\n-      if I_Next = J then\n-         Splice (Container, Before => I, Position => J);\n-\n-      else\n-         J_Next := Next (Container, J);\n-\n-         if J_Next = I then\n-            Splice (Container, Before => J, Position => I);\n-\n-         else\n-            pragma Assert (Container.Length >= 3);\n-            Splice (Container, Before => I_Next, Position => J);\n-            Splice (Container, Before => J_Next, Position => I);\n-         end if;\n-      end if;\n-   end Swap_Links;\n-\n-   ---------\n-   -- Vet --\n-   ---------\n-\n-   function Vet (L : List; Position : Cursor) return Boolean is\n-      N : Node_Array_Access renames L.Nodes;\n-   begin\n-      if not Container_Checks'Enabled then\n-         return True;\n-      end if;\n-\n-      if L.Length = 0 then\n-         return False;\n-      end if;\n-\n-      if L.First = 0 then\n-         return False;\n-      end if;\n-\n-      if L.Last = 0 then\n-         return False;\n-      end if;\n-\n-      if Position.Node > L.Nodes'Length then\n-         return False;\n-      end if;\n-\n-      if N (Position.Node).Prev < 0\n-        or else N (Position.Node).Prev > L.Nodes'Length\n-      then\n-         return False;\n-      end if;\n-\n-      if N (Position.Node).Next > L.Nodes'Length then\n-         return False;\n-      end if;\n-\n-      if N (L.First).Prev /= 0 then\n-         return False;\n-      end if;\n-\n-      if N (L.Last).Next /= 0 then\n-         return False;\n-      end if;\n-\n-      if N (Position.Node).Prev = 0 and then Position.Node /= L.First then\n-         return False;\n-      end if;\n-\n-      if N (Position.Node).Next = 0 and then Position.Node /= L.Last then\n-         return False;\n-      end if;\n-\n-      if L.Length = 1 then\n-         return L.First = L.Last;\n-      end if;\n-\n-      if L.First = L.Last then\n-         return False;\n-      end if;\n-\n-      if N (L.First).Next = 0 then\n-         return False;\n-      end if;\n-\n-      if N (L.Last).Prev = 0 then\n-         return False;\n-      end if;\n-\n-      if N (N (L.First).Next).Prev /= L.First then\n-         return False;\n-      end if;\n-\n-      if N (N (L.Last).Prev).Next /= L.Last then\n-         return False;\n-      end if;\n-\n-      if L.Length = 2 then\n-         if N (L.First).Next /= L.Last then\n-            return False;\n-         end if;\n-\n-         if N (L.Last).Prev /= L.First then\n-            return False;\n-         end if;\n-\n-         return True;\n-      end if;\n-\n-      if N (L.First).Next = L.Last then\n-         return False;\n-      end if;\n-\n-      if N (L.Last).Prev = L.First then\n-         return False;\n-      end if;\n-\n-      if Position.Node = L.First then\n-         return True;\n-      end if;\n-\n-      if Position.Node = L.Last then\n-         return True;\n-      end if;\n-\n-      if N (Position.Node).Next = 0 then\n-         return False;\n-      end if;\n-\n-      if N (Position.Node).Prev = 0 then\n-         return False;\n-      end if;\n-\n-      if N (N (Position.Node).Next).Prev /= Position.Node then\n-         return False;\n-      end if;\n-\n-      if N (N (Position.Node).Prev).Next /= Position.Node then\n-         return False;\n-      end if;\n-\n-      if L.Length = 3 then\n-         if N (L.First).Next /= Position.Node then\n-            return False;\n-         end if;\n-\n-         if N (L.Last).Prev /= Position.Node then\n-            return False;\n-         end if;\n-      end if;\n-\n-      return True;\n-   end Vet;\n-\n-end Ada.Containers.Formal_Indefinite_Doubly_Linked_Lists;"}, {"sha": "cbddde31b918d29ac0c4b096e31b1adce1fa7927", "filename": "gcc/ada/libgnat/a-cfidll.ads", "status": "modified", "additions": 5, "deletions": 1635, "changes": 1640, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cfidll.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cfidll.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfidll.ads?ref=4a7312f7ce189783a2cb5318bdcf50e8148b909d", "patch": "@@ -29,1642 +29,12 @@\n -- <http://www.gnu.org/licenses/>.                                          --\n ------------------------------------------------------------------------------\n \n-with Ada.Containers.Functional_Vectors;\n-with Ada.Containers.Functional_Maps;\n-private with Ada.Finalization;\n-\n generic\n-   type Element_Type is private;\n-   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n-\n-package Ada.Containers.Formal_Indefinite_Doubly_Linked_Lists with\n-  SPARK_Mode\n-is\n-   --  Contracts in this unit are meant for analysis only, not for run-time\n-   --  checking.\n-\n-   pragma Assertion_Policy (Pre => Ignore);\n-   pragma Assertion_Policy (Post => Ignore);\n-   pragma Assertion_Policy (Contract_Cases => Ignore);\n-   pragma Annotate (CodePeer, Skip_Analysis);\n-\n-   type List is private with\n-     Iterable => (First       => First,\n-                  Next        => Next,\n-                  Has_Element => Has_Element,\n-                  Element     => Element),\n-     Default_Initial_Condition => Is_Empty (List);\n-\n-   type Cursor is record\n-      Node : Count_Type := 0;\n-   end record;\n-\n-   No_Element : constant Cursor := Cursor'(Node => 0);\n-\n-   function Length (Container : List) return Count_Type with\n-     Global => null;\n-\n-   function Empty_List return List with\n-     Global => null,\n-     Post   => Length (Empty_List'Result) = 0;\n-\n-   pragma Unevaluated_Use_Of_Old (Allow);\n-\n-   package Formal_Model with Ghost is\n-      subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n-\n-      package M is new Ada.Containers.Functional_Vectors\n-        (Index_Type   => Positive_Count_Type,\n-         Element_Type => Element_Type);\n-\n-      function \"=\"\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean renames M.\"=\";\n-\n-      function \"<\"\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean renames M.\"<\";\n-\n-      function \"<=\"\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean renames M.\"<=\";\n-\n-      function M_Elements_In_Union\n-        (Container : M.Sequence;\n-         Left      : M.Sequence;\n-         Right     : M.Sequence) return Boolean\n-      --  The elements of Container are contained in either Left or Right\n-      with\n-        Global => null,\n-        Post   =>\n-          M_Elements_In_Union'Result =\n-            (for all I in 1 .. M.Length (Container) =>\n-              (for some J in 1 .. M.Length (Left) =>\n-                Element (Container, I) = Element (Left, J))\n-                  or (for some J in 1 .. M.Length (Right) =>\n-                       Element (Container, I) = Element (Right, J)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_In_Union);\n-\n-      function M_Elements_Included\n-        (Left  : M.Sequence;\n-         L_Fst : Positive_Count_Type := 1;\n-         L_Lst : Count_Type;\n-         Right : M.Sequence;\n-         R_Fst : Positive_Count_Type := 1;\n-         R_Lst : Count_Type) return Boolean\n-      --  The elements of the slice from L_Fst to L_Lst in Left are contained\n-      --  in the slide from R_Fst to R_Lst in Right.\n-      with\n-        Global => null,\n-        Pre    => L_Lst <= M.Length (Left) and R_Lst <= M.Length (Right),\n-        Post   =>\n-          M_Elements_Included'Result =\n-            (for all I in L_Fst .. L_Lst =>\n-              (for some J in R_Fst .. R_Lst =>\n-                Element (Left, I) = Element (Right, J)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Included);\n-\n-      function M_Elements_Reversed\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean\n-      --  Right is Left in reverse order\n-      with\n-        Global => null,\n-        Post   =>\n-          M_Elements_Reversed'Result =\n-            (M.Length (Left) = M.Length (Right)\n-              and (for all I in 1 .. M.Length (Left) =>\n-                    Element (Left, I) =\n-                      Element (Right, M.Length (Left) - I + 1))\n-              and (for all I in 1 .. M.Length (Left) =>\n-                    Element (Right, I) =\n-                      Element (Left, M.Length (Left) - I + 1)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Reversed);\n-\n-      function M_Elements_Swapped\n-        (Left  : M.Sequence;\n-         Right : M.Sequence;\n-         X     : Positive_Count_Type;\n-         Y     : Positive_Count_Type) return Boolean\n-      --  Elements stored at X and Y are reversed in Left and Right\n-      with\n-        Global => null,\n-        Pre    => X <= M.Length (Left) and Y <= M.Length (Left),\n-        Post   =>\n-          M_Elements_Swapped'Result =\n-            (M.Length (Left) = M.Length (Right)\n-              and Element (Left, X) = Element (Right, Y)\n-              and Element (Left, Y) = Element (Right, X)\n-              and M.Equal_Except (Left, Right, X, Y));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Swapped);\n-\n-      package P is new Ada.Containers.Functional_Maps\n-        (Key_Type                       => Cursor,\n-         Element_Type                   => Positive_Count_Type,\n-         Equivalent_Keys                => \"=\",\n-         Enable_Handling_Of_Equivalence => False);\n-\n-      function \"=\"\n-        (Left  : P.Map;\n-         Right : P.Map) return Boolean renames P.\"=\";\n-\n-      function \"<=\"\n-        (Left  : P.Map;\n-         Right : P.Map) return Boolean renames P.\"<=\";\n-\n-      function P_Positions_Shifted\n-        (Small : P.Map;\n-         Big   : P.Map;\n-         Cut   : Positive_Count_Type;\n-         Count : Count_Type := 1) return Boolean\n-      with\n-        Global => null,\n-        Post   =>\n-          P_Positions_Shifted'Result =\n-\n-            --  Big contains all cursors of Small\n-\n-            (P.Keys_Included (Small, Big)\n-\n-              --  Cursors located before Cut are not moved, cursors located\n-              --  after are shifted by Count.\n-\n-              and (for all I of Small =>\n-                    (if P.Get (Small, I) < Cut then\n-                        P.Get (Big, I) = P.Get (Small, I)\n-                     else\n-                        P.Get (Big, I) - Count = P.Get (Small, I)))\n-\n-              --  New cursors of Big (if any) are between Cut and Cut - 1 +\n-              --  Count.\n-\n-              and (for all I of Big =>\n-                    P.Has_Key (Small, I)\n-                      or P.Get (Big, I) - Count in Cut - Count  .. Cut - 1));\n-\n-      function P_Positions_Swapped\n-        (Left  : P.Map;\n-         Right : P.Map;\n-         X     : Cursor;\n-         Y     : Cursor) return Boolean\n-      --  Left and Right contain the same cursors, but the positions of X and Y\n-      --  are reversed.\n-      with\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          P_Positions_Swapped'Result =\n-            (P.Same_Keys (Left, Right)\n-              and P.Elements_Equal_Except (Left, Right, X, Y)\n-              and P.Has_Key (Left, X)\n-              and P.Has_Key (Left, Y)\n-              and P.Get (Left, X) = P.Get (Right, Y)\n-              and P.Get (Left, Y) = P.Get (Right, X));\n-\n-      function P_Positions_Truncated\n-        (Small : P.Map;\n-         Big   : P.Map;\n-         Cut   : Positive_Count_Type;\n-         Count : Count_Type := 1) return Boolean\n-      with\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          P_Positions_Truncated'Result =\n-\n-            --  Big contains all cursors of Small at the same position\n-\n-            (Small <= Big\n-\n-              --  New cursors of Big (if any) are between Cut and Cut - 1 +\n-              --  Count.\n-\n-              and (for all I of Big =>\n-                    P.Has_Key (Small, I)\n-                      or P.Get (Big, I) - Count in Cut - Count .. Cut - 1));\n-\n-      function Mapping_Preserved\n-        (M_Left  : M.Sequence;\n-         M_Right : M.Sequence;\n-         P_Left  : P.Map;\n-         P_Right : P.Map) return Boolean\n-      with\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          (if Mapping_Preserved'Result then\n-\n-             --  Left and Right contain the same cursors\n-\n-             P.Same_Keys (P_Left, P_Right)\n-\n-               --  Mappings from cursors to elements induced by M_Left, P_Left\n-               --  and M_Right, P_Right are the same.\n-\n-               and (for all C of P_Left =>\n-                     M.Get (M_Left, P.Get (P_Left, C)) =\n-                     M.Get (M_Right, P.Get (P_Right, C))));\n-\n-      function Model (Container : List) return M.Sequence with\n-      --  The high-level model of a list is a sequence of elements. Cursors are\n-      --  not represented in this model.\n-\n-        Ghost,\n-        Global => null,\n-        Post   => M.Length (Model'Result) = Length (Container);\n-      pragma Annotate (GNATprove, Iterable_For_Proof, \"Model\", Model);\n-\n-      function Positions (Container : List) return P.Map with\n-      --  The Positions map is used to model cursors. It only contains valid\n-      --  cursors and map them to their position in the container.\n-\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          not P.Has_Key (Positions'Result, No_Element)\n-\n-            --  Positions of cursors are smaller than the container's length\n-\n-            and then\n-              (for all I of Positions'Result =>\n-                P.Get (Positions'Result, I) in 1 .. Length (Container)\n-\n-            --  No two cursors have the same position. Note that we do not\n-            --  state that there is a cursor in the map for each position, as\n-            --  it is rarely needed.\n-\n-            and then\n-              (for all J of Positions'Result =>\n-                (if P.Get (Positions'Result, I) = P.Get (Positions'Result, J)\n-                  then I = J)));\n-\n-      procedure Lift_Abstraction_Level (Container : List) with\n-        --  Lift_Abstraction_Level is a ghost procedure that does nothing but\n-        --  assume that we can access to the same elements by iterating over\n-        --  positions or cursors.\n-        --  This information is not generally useful except when switching from\n-        --  a low-level cursor-aware view of a container to a high-level\n-        --  position-based view.\n-\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          (for all Elt of Model (Container) =>\n-            (for some I of Positions (Container) =>\n-              M.Get (Model (Container), P.Get (Positions (Container), I)) =\n-                Elt));\n-\n-      function Element\n-        (S : M.Sequence;\n-         I : Count_Type) return Element_Type renames M.Get;\n-      --  To improve readability of contracts, we rename the function used to\n-      --  access an element in the model to Element.\n-\n-   end Formal_Model;\n-   use Formal_Model;\n-\n-   function \"=\" (Left, Right : List) return Boolean with\n-     Global => null,\n-     Post   => \"=\"'Result = (Model (Left) = Model (Right));\n-\n-   function Is_Empty (Container : List) return Boolean with\n-     Global => null,\n-     Post   => Is_Empty'Result = (Length (Container) = 0);\n-\n-   procedure Clear (Container : in out List) with\n-     Global => null,\n-     Post   => Length (Container) = 0;\n-\n-   procedure Assign (Target : in out List; Source : List) with\n-     Global => null,\n-     Post   => Model (Target) = Model (Source);\n-\n-   function Copy (Source : List) return List with\n-     Global => null,\n-     Post   =>\n-       Model (Copy'Result) = Model (Source)\n-         and Positions (Copy'Result) = Positions (Source);\n-\n-   function Element\n-     (Container : List;\n-      Position : Cursor) return Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Element'Result =\n-         Element (Model (Container), P.Get (Positions (Container), Position));\n-   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n-\n-   procedure Replace_Element\n-     (Container : in out List;\n-      Position  : Cursor;\n-      New_Item  : Element_Type)\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old\n-\n-         --  Cursors are preserved\n-\n-         and Positions (Container)'Old = Positions (Container)\n-\n-         --  The element at the position of Position in Container is New_Item\n-\n-         and Element\n-               (Model (Container),\n-                P.Get (Positions (Container), Position)) = New_Item\n-\n-         --  Other elements are preserved\n-\n-         and M.Equal_Except\n-               (Model (Container)'Old,\n-                Model (Container),\n-                P.Get (Positions (Container), Position));\n-\n-   function At_End (E : access constant List) return access constant List\n-   is (E)\n-   with Ghost,\n-     Annotate => (GNATprove, At_End_Borrow);\n-\n-   function At_End\n-     (E : access constant Element_Type) return access constant Element_Type\n-   is (E)\n-   with Ghost,\n-     Annotate => (GNATprove, At_End_Borrow);\n-\n-   function Constant_Reference\n-     (Container : List;\n-      Position  : Cursor) return not null access constant Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Constant_Reference'Result.all =\n-         Element (Model (Container), P.Get (Positions (Container), Position));\n-\n-   function Reference\n-     (Container : not null access List;\n-      Position  : Cursor) return not null access Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container.all, Position),\n-     Post   =>\n-      Length (Container.all) = Length (At_End (Container).all)\n-\n-         --  Cursors are preserved\n-\n-         and Positions (Container.all) = Positions (At_End (Container).all)\n-\n-         --  Container will have Result.all at position Position\n-\n-         and At_End (Reference'Result).all =\n-           Element (Model (At_End (Container).all),\n-                    P.Get (Positions (At_End (Container).all), Position))\n-\n-         --  All other elements are preserved\n-\n-         and M.Equal_Except\n-               (Model (Container.all),\n-                Model (At_End (Container).all),\n-                P.Get (Positions (At_End (Container).all), Position));\n-\n-   procedure Move (Target : in out List; Source : in out List) with\n-     Global => null,\n-     Post   => Model (Target) = Model (Source'Old) and Length (Source) = 0;\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type)\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Length (Container) < Count_Type'Last\n-         and then (Has_Element (Container, Before)\n-                    or else Before = No_Element),\n-     Post           => Length (Container) = Length (Container)'Old + 1,\n-     Contract_Cases =>\n-       (Before = No_Element =>\n-\n-          --  Positions contains a new mapping from the last cursor of\n-          --  Container to its length.\n-\n-          P.Get (Positions (Container), Last (Container)) = Length (Container)\n-\n-            --  Other cursors come from Container'Old\n-\n-            and P.Keys_Included_Except\n-                  (Left    => Positions (Container),\n-                   Right   => Positions (Container)'Old,\n-                   New_Key => Last (Container))\n-\n-            --  Cursors of Container'Old keep the same position\n-\n-            and Positions (Container)'Old <= Positions (Container)\n-\n-            --  Model contains a new element New_Item at the end\n-\n-            and Element (Model (Container), Length (Container)) = New_Item\n-\n-            --  Elements of Container'Old are preserved\n-\n-            and Model (Container)'Old <= Model (Container),\n-\n-        others =>\n-\n-          --  The elements of Container located before Before are preserved\n-\n-          M.Range_Equal\n-            (Left  => Model (Container)'Old,\n-             Right => Model (Container),\n-             Fst   => 1,\n-             Lst   => P.Get (Positions (Container)'Old, Before) - 1)\n-\n-            --  Other elements are shifted by 1\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container)'Old,\n-                   Right  => Model (Container),\n-                   Fst    => P.Get (Positions (Container)'Old, Before),\n-                   Lst    => Length (Container)'Old,\n-                   Offset => 1)\n-\n-            --  New_Item is stored at the previous position of Before in\n-            --  Container.\n-\n-            and Element\n-                  (Model (Container),\n-                   P.Get (Positions (Container)'Old, Before)) = New_Item\n-\n-            --  A new cursor has been inserted at position Before in Container\n-\n-            and P_Positions_Shifted\n-                  (Positions (Container)'Old,\n-                   Positions (Container),\n-                   Cut => P.Get (Positions (Container)'Old, Before)));\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Length (Container) <= Count_Type'Last - Count\n-         and then (Has_Element (Container, Before)\n-                    or else Before = No_Element),\n-     Post           => Length (Container) = Length (Container)'Old + Count,\n-     Contract_Cases =>\n-       (Before = No_Element =>\n-\n-          --  The elements of Container are preserved\n-\n-          M.Range_Equal\n-            (Left  => Model (Container)'Old,\n-             Right => Model (Container),\n-             Fst   => 1,\n-             Lst   => Length (Container)'Old)\n-\n-            --  Container contains Count times New_Item at the end\n-\n-            and (if Count > 0 then\n-                    M.Constant_Range\n-                      (Container => Model (Container),\n-                       Fst       => Length (Container)'Old + 1,\n-                       Lst       => Length (Container),\n-                       Item      => New_Item))\n-\n-            --  Count cursors have been inserted at the end of Container\n-\n-            and P_Positions_Truncated\n-                  (Positions (Container)'Old,\n-                   Positions (Container),\n-                   Cut   => Length (Container)'Old + 1,\n-                   Count => Count),\n-\n-        others =>\n-\n-          --  The elements of Container located before Before are preserved\n-\n-          M.Range_Equal\n-            (Left  => Model (Container)'Old,\n-             Right => Model (Container),\n-             Fst   => 1,\n-             Lst   => P.Get (Positions (Container)'Old, Before) - 1)\n-\n-            --  Other elements are shifted by Count\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container)'Old,\n-                   Right  => Model (Container),\n-                   Fst    => P.Get (Positions (Container)'Old, Before),\n-                   Lst    => Length (Container)'Old,\n-                   Offset => Count)\n-\n-            --  Container contains Count times New_Item after position Before\n-\n-            and M.Constant_Range\n-                  (Container => Model (Container),\n-                   Fst       => P.Get (Positions (Container)'Old, Before),\n-                   Lst       =>\n-                     P.Get (Positions (Container)'Old, Before) - 1 + Count,\n-                   Item      => New_Item)\n-\n-            --  Count cursors have been inserted at position Before in\n-            --  Container.\n-\n-            and P_Positions_Shifted\n-                  (Positions (Container)'Old,\n-                   Positions (Container),\n-                   Cut   => P.Get (Positions (Container)'Old, Before),\n-                   Count => Count));\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor)\n-   with\n-     Global => null,\n-     Pre    =>\n-       Length (Container) < Count_Type'Last\n-         and then (Has_Element (Container, Before)\n-                    or else Before = No_Element),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + 1\n-\n-          --  Positions is valid in Container and it is located either before\n-          --  Before if it is valid in Container or at the end if it is\n-          --  No_Element.\n-\n-          and P.Has_Key (Positions (Container), Position)\n-          and (if Before = No_Element then\n-                  P.Get (Positions (Container), Position) = Length (Container)\n-               else\n-                  P.Get (Positions (Container), Position) =\n-                  P.Get (Positions (Container)'Old, Before))\n-\n-          --  The elements of Container located before Position are preserved\n-\n-          and M.Range_Equal\n-                (Left  => Model (Container)'Old,\n-                 Right => Model (Container),\n-                 Fst   => 1,\n-                 Lst   => P.Get (Positions (Container), Position) - 1)\n-\n-          --  Other elements are shifted by 1\n-\n-          and M.Range_Shifted\n-                (Left   => Model (Container)'Old,\n-                 Right  => Model (Container),\n-                 Fst    => P.Get (Positions (Container), Position),\n-                 Lst    => Length (Container)'Old,\n-                 Offset => 1)\n-\n-          --  New_Item is stored at Position in Container\n-\n-          and Element\n-                (Model (Container),\n-                 P.Get (Positions (Container), Position)) = New_Item\n-\n-          --  A new cursor has been inserted at position Position in Container\n-\n-          and P_Positions_Shifted\n-                (Positions (Container)'Old,\n-                 Positions (Container),\n-                 Cut => P.Get (Positions (Container), Position));\n-\n-   procedure Insert\n-     (Container : in out List;\n-      Before    : Cursor;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor;\n-      Count     : Count_Type)\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Length (Container) <= Count_Type'Last - Count\n-         and then (Has_Element (Container, Before)\n-                    or else Before = No_Element),\n-     Post           => Length (Container) = Length (Container)'Old + Count,\n-     Contract_Cases =>\n-       (Count = 0 =>\n-         Position = Before\n-           and Model (Container) = Model (Container)'Old\n-           and Positions (Container) = Positions (Container)'Old,\n-\n-        others =>\n-\n-          --  Positions is valid in Container and it is located either before\n-          --  Before if it is valid in Container or at the end if it is\n-          --  No_Element.\n-\n-          P.Has_Key (Positions (Container), Position)\n-            and (if Before = No_Element then\n-                    P.Get (Positions (Container), Position) =\n-                    Length (Container)'Old + 1\n-                 else\n-                    P.Get (Positions (Container), Position) =\n-                    P.Get (Positions (Container)'Old, Before))\n-\n-            --  The elements of Container located before Position are preserved\n-\n-            and M.Range_Equal\n-                  (Left  => Model (Container)'Old,\n-                   Right => Model (Container),\n-                   Fst   => 1,\n-                   Lst   => P.Get (Positions (Container), Position) - 1)\n-\n-            --  Other elements are shifted by Count\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container)'Old,\n-                   Right  => Model (Container),\n-                   Fst    => P.Get (Positions (Container), Position),\n-                   Lst    => Length (Container)'Old,\n-                   Offset => Count)\n-\n-            --  Container contains Count times New_Item after position Position\n-\n-            and M.Constant_Range\n-                  (Container => Model (Container),\n-                   Fst       => P.Get (Positions (Container), Position),\n-                   Lst       =>\n-                     P.Get (Positions (Container), Position) - 1 + Count,\n-                   Item      => New_Item)\n-\n-            --  Count cursor have been inserted at Position in Container\n-\n-            and P_Positions_Shifted\n-                  (Positions (Container)'Old,\n-                   Positions (Container),\n-                   Cut   => P.Get (Positions (Container), Position),\n-                   Count => Count));\n-\n-   procedure Prepend (Container : in out List; New_Item : Element_Type) with\n-     Global => null,\n-     Pre    => Length (Container) < Count_Type'Last,\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + 1\n-\n-         --  Elements are shifted by 1\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Container)'Old,\n-                Right  => Model (Container),\n-                Fst    => 1,\n-                Lst    => Length (Container)'Old,\n-                Offset => 1)\n-\n-         --  New_Item is the first element of Container\n-\n-         and Element (Model (Container), 1) = New_Item\n-\n-         --  A new cursor has been inserted at the beginning of Container\n-\n-         and P_Positions_Shifted\n-               (Positions (Container)'Old,\n-                Positions (Container),\n-                Cut => 1);\n-\n-   procedure Prepend\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   with\n-     Global => null,\n-     Pre    => Length (Container) <= Count_Type'Last - Count,\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + Count\n-\n-         --  Elements are shifted by Count\n-\n-         and M.Range_Shifted\n-               (Left     => Model (Container)'Old,\n-                Right     => Model (Container),\n-                Fst    => 1,\n-                Lst    => Length (Container)'Old,\n-                Offset => Count)\n-\n-         --  Container starts with Count times New_Item\n-\n-         and M.Constant_Range\n-               (Container => Model (Container),\n-                Fst       => 1,\n-                Lst       => Count,\n-                Item      => New_Item)\n-\n-         --  Count cursors have been inserted at the beginning of Container\n-\n-         and P_Positions_Shifted\n-               (Positions (Container)'Old,\n-                Positions (Container),\n-                Cut   => 1,\n-                Count => Count);\n-\n-   procedure Append (Container : in out List; New_Item : Element_Type) with\n-     Global => null,\n-     Pre    => Length (Container) < Count_Type'Last,\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + 1\n-\n-         --  Positions contains a new mapping from the last cursor of Container\n-         --  to its length.\n-\n-         and P.Get (Positions (Container), Last (Container)) =\n-               Length (Container)\n-\n-         --  Other cursors come from Container'Old\n-\n-         and P.Keys_Included_Except\n-               (Left    => Positions (Container),\n-                Right   => Positions (Container)'Old,\n-                New_Key => Last (Container))\n-\n-         --  Cursors of Container'Old keep the same position\n-\n-         and Positions (Container)'Old <= Positions (Container)\n-\n-         --  Model contains a new element New_Item at the end\n-\n-         and Element (Model (Container), Length (Container)) = New_Item\n-\n-         --  Elements of Container'Old are preserved\n-\n-         and Model (Container)'Old <= Model (Container);\n-\n-   procedure Append\n-     (Container : in out List;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   with\n-     Global => null,\n-     Pre    => Length (Container) <= Count_Type'Last - Count,\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + Count\n-\n-         --  The elements of Container are preserved\n-\n-         and Model (Container)'Old <= Model (Container)\n-\n-         --  Container contains Count times New_Item at the end\n-\n-         and (if Count > 0 then\n-                 M.Constant_Range\n-                   (Container => Model (Container),\n-                     Fst       => Length (Container)'Old + 1,\n-                     Lst       => Length (Container),\n-                     Item      => New_Item))\n-\n-         --  Count cursors have been inserted at the end of Container\n-\n-         and P_Positions_Truncated\n-               (Positions (Container)'Old,\n-                Positions (Container),\n-                Cut   => Length (Container)'Old + 1,\n-                Count => Count);\n-\n-   procedure Delete (Container : in out List; Position : in out Cursor) with\n-     Global  => null,\n-     Depends => (Container =>+ Position, Position => null),\n-     Pre     => Has_Element (Container, Position),\n-     Post    =>\n-       Length (Container) = Length (Container)'Old - 1\n-\n-         --  Position is set to No_Element\n-\n-         and Position = No_Element\n-\n-         --  The elements of Container located before Position are preserved.\n-\n-         and M.Range_Equal\n-               (Left  => Model (Container)'Old,\n-                Right => Model (Container),\n-                Fst   => 1,\n-                Lst   => P.Get (Positions (Container)'Old, Position'Old) - 1)\n-\n-         --  The elements located after Position are shifted by 1\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Container),\n-                Right  => Model (Container)'Old,\n-                Fst    => P.Get (Positions (Container)'Old, Position'Old),\n-                Lst    => Length (Container),\n-                Offset => 1)\n-\n-         --  Position has been removed from Container\n-\n-         and P_Positions_Shifted\n-               (Positions (Container),\n-                Positions (Container)'Old,\n-                Cut   => P.Get (Positions (Container)'Old, Position'Old));\n-\n-   procedure Delete\n-     (Container : in out List;\n-      Position  : in out Cursor;\n-      Count     : Count_Type)\n-   with\n-     Global         => null,\n-     Pre            => Has_Element (Container, Position),\n-     Post           =>\n-       Length (Container) in\n-         Length (Container)'Old - Count .. Length (Container)'Old\n-\n-         --  Position is set to No_Element\n-\n-         and Position = No_Element\n-\n-         --  The elements of Container located before Position are preserved.\n-\n-         and M.Range_Equal\n-               (Left  => Model (Container)'Old,\n-                Right => Model (Container),\n-                Fst   => 1,\n-                Lst   => P.Get (Positions (Container)'Old, Position'Old) - 1),\n-\n-     Contract_Cases =>\n-\n-       --  All the elements after Position have been erased\n-\n-       (Length (Container) - Count < P.Get (Positions (Container), Position) =>\n-          Length (Container) =\n-            P.Get (Positions (Container)'Old, Position'Old) - 1\n-\n-            --  At most Count cursors have been removed at the end of Container\n-\n-            and P_Positions_Truncated\n-                 (Positions (Container),\n-                  Positions (Container)'Old,\n-                  Cut   => P.Get (Positions (Container)'Old, Position'Old),\n-                  Count => Count),\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old - Count\n-\n-            --  Other elements are shifted by Count\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container),\n-                   Right  => Model (Container)'Old,\n-                   Fst    => P.Get (Positions (Container)'Old, Position'Old),\n-                   Lst    => Length (Container),\n-                   Offset => Count)\n-\n-            --  Count cursors have been removed from Container at Position\n-\n-            and P_Positions_Shifted\n-                 (Positions (Container),\n-                  Positions (Container)'Old,\n-                  Cut   => P.Get (Positions (Container)'Old, Position'Old),\n-                  Count => Count));\n-\n-   procedure Delete_First (Container : in out List) with\n-     Global => null,\n-     Pre    => not Is_Empty (Container),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old - 1\n-\n-         --  The elements of Container are shifted by 1\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Container),\n-                Right  => Model (Container)'Old,\n-                Fst    => 1,\n-                Lst    => Length (Container),\n-                Offset => 1)\n-\n-         --  The first cursor of Container has been removed\n-\n-         and P_Positions_Shifted\n-               (Positions (Container),\n-                Positions (Container)'Old,\n-                Cut   => 1);\n-\n-   procedure Delete_First (Container : in out List; Count : Count_Type) with\n-     Global         => null,\n-     Contract_Cases =>\n-\n-       --  All the elements of Container have been erased\n-\n-       (Length (Container) <= Count =>\n-          Length (Container) = 0,\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old - Count\n-\n-            --  Elements of Container are shifted by Count\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container),\n-                   Right  => Model (Container)'Old,\n-                   Fst    => 1,\n-                   Lst    => Length (Container),\n-                   Offset => Count)\n-\n-            --  The first Count cursors have been removed from Container\n-\n-            and P_Positions_Shifted\n-                  (Positions (Container),\n-                   Positions (Container)'Old,\n-                   Cut   => 1,\n-                   Count => Count));\n-\n-   procedure Delete_Last (Container : in out List) with\n-     Global => null,\n-     Pre    => not Is_Empty (Container),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old - 1\n-\n-         --  The elements of Container are preserved\n-\n-         and Model (Container) <= Model (Container)'Old\n-\n-         --  The last cursor of Container has been removed\n-\n-         and not P.Has_Key (Positions (Container), Last (Container)'Old)\n-\n-         --  Other cursors are still valid\n-\n-         and P.Keys_Included_Except\n-               (Left    => Positions (Container)'Old,\n-                Right   => Positions (Container)'Old,\n-                New_Key => Last (Container)'Old)\n-\n-         --  The positions of other cursors are preserved\n-\n-         and Positions (Container) <= Positions (Container)'Old;\n-\n-   procedure Delete_Last (Container : in out List; Count : Count_Type) with\n-     Global         => null,\n-     Contract_Cases =>\n-\n-       --  All the elements of Container have been erased\n-\n-       (Length (Container) <= Count =>\n-          Length (Container) = 0,\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old - Count\n-\n-            --  The elements of Container are preserved\n-\n-            and Model (Container) <= Model (Container)'Old\n-\n-            --  At most Count cursors have been removed at the end of Container\n-\n-            and P_Positions_Truncated\n-                  (Positions (Container),\n-                   Positions (Container)'Old,\n-                   Cut   => Length (Container) + 1,\n-                   Count => Count));\n-\n-   procedure Reverse_Elements (Container : in out List) with\n-     Global => null,\n-     Post   => M_Elements_Reversed (Model (Container)'Old, Model (Container));\n-\n-   procedure Swap\n-     (Container : in out List;\n-      I         : Cursor;\n-      J         : Cursor)\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, I) and then Has_Element (Container, J),\n-     Post   =>\n-       M_Elements_Swapped\n-         (Model (Container)'Old,\n-          Model (Container),\n-          X => P.Get (Positions (Container)'Old, I),\n-          Y => P.Get (Positions (Container)'Old, J))\n-\n-         and Positions (Container) = Positions (Container)'Old;\n-\n-   procedure Swap_Links\n-     (Container : in out List;\n-      I         : Cursor;\n-      J         : Cursor)\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, I) and then Has_Element (Container, J),\n-     Post   =>\n-       M_Elements_Swapped\n-         (Model (Container'Old),\n-          Model (Container),\n-          X => P.Get (Positions (Container)'Old, I),\n-          Y => P.Get (Positions (Container)'Old, J))\n-         and P_Positions_Swapped\n-               (Positions (Container)'Old, Positions (Container), I, J);\n-\n-   procedure Splice\n-     (Target : in out List;\n-      Before : Cursor;\n-      Source : in out List)\n-   --  Target and Source should not be aliased\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Length (Source) <= Count_Type'Last - Length (Target)\n-         and then (Has_Element (Target, Before) or else Before = No_Element),\n-     Post           =>\n-       Length (Source) = 0\n-         and Length (Target) = Length (Target)'Old + Length (Source)'Old,\n-     Contract_Cases =>\n-       (Before = No_Element =>\n-\n-          --  The elements of Target are preserved\n-\n-          M.Range_Equal\n-            (Left  => Model (Target)'Old,\n-             Right => Model (Target),\n-             Fst   => 1,\n-             Lst   => Length (Target)'Old)\n-\n-            --  The elements of Source are appended to target, the order is not\n-            --  specified.\n-\n-            and M_Elements_Included\n-                  (Left   => Model (Source)'Old,\n-                   L_Lst  => Length (Source)'Old,\n-                   Right  => Model (Target),\n-                   R_Fst  => Length (Target)'Old + 1,\n-                   R_Lst  => Length (Target))\n-\n-            and M_Elements_Included\n-                  (Left   => Model (Target),\n-                   L_Fst  => Length (Target)'Old + 1,\n-                   L_Lst  => Length (Target),\n-                   Right  => Model (Source)'Old,\n-                   R_Lst  => Length (Source)'Old)\n-\n-            --  Cursors have been inserted at the end of Target\n-\n-            and P_Positions_Truncated\n-                  (Positions (Target)'Old,\n-                   Positions (Target),\n-                   Cut   => Length (Target)'Old + 1,\n-                   Count => Length (Source)'Old),\n-\n-        others =>\n-\n-          --  The elements of Target located before Before are preserved\n-\n-          M.Range_Equal\n-            (Left  => Model (Target)'Old,\n-             Right => Model (Target),\n-             Fst   => 1,\n-             Lst   => P.Get (Positions (Target)'Old, Before) - 1)\n-\n-            --  The elements of Source are inserted before Before, the order is\n-            --  not specified.\n-\n-            and M_Elements_Included\n-                  (Left   => Model (Source)'Old,\n-                   L_Lst  => Length (Source)'Old,\n-                   Right  => Model (Target),\n-                   R_Fst  => P.Get (Positions (Target)'Old, Before),\n-                   R_Lst  =>\n-                     P.Get (Positions (Target)'Old, Before) - 1 +\n-                       Length (Source)'Old)\n-\n-            and M_Elements_Included\n-                  (Left   => Model (Target),\n-                   L_Fst  => P.Get (Positions (Target)'Old, Before),\n-                   L_Lst  =>\n-                     P.Get (Positions (Target)'Old, Before) - 1 +\n-                       Length (Source)'Old,\n-                   Right  => Model (Source)'Old,\n-                   R_Lst  => Length (Source)'Old)\n-\n-          --  Other elements are shifted by the length of Source\n-\n-          and M.Range_Shifted\n-                (Left   => Model (Target)'Old,\n-                 Right  => Model (Target),\n-                 Fst    => P.Get (Positions (Target)'Old, Before),\n-                 Lst    => Length (Target)'Old,\n-                 Offset => Length (Source)'Old)\n-\n-          --  Cursors have been inserted at position Before in Target\n-\n-          and P_Positions_Shifted\n-                (Positions (Target)'Old,\n-                 Positions (Target),\n-                 Cut   => P.Get (Positions (Target)'Old, Before),\n-                 Count => Length (Source)'Old));\n-\n-   procedure Splice\n-     (Target   : in out List;\n-      Before   : Cursor;\n-      Source   : in out List;\n-      Position : in out Cursor)\n-   --  Target and Source should not be aliased\n-   with\n-     Global => null,\n-     Pre    =>\n-       (Has_Element (Target, Before) or else Before = No_Element)\n-         and then Has_Element (Source, Position)\n-         and then Length (Target) < Count_Type'Last,\n-     Post   =>\n-       Length (Target) = Length (Target)'Old + 1\n-         and Length (Source) = Length (Source)'Old - 1\n-\n-         --  The elements of Source located before Position are preserved\n-\n-         and M.Range_Equal\n-               (Left  => Model (Source)'Old,\n-                Right => Model (Source),\n-                Fst   => 1,\n-                Lst   => P.Get (Positions (Source)'Old, Position'Old) - 1)\n-\n-         --  The elements located after Position are shifted by 1\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Source)'Old,\n-                Right  => Model (Source),\n-                Fst    => P.Get (Positions (Source)'Old, Position'Old) + 1,\n-                Lst    => Length (Source)'Old,\n-                Offset => -1)\n-\n-         --  Position has been removed from Source\n-\n-         and P_Positions_Shifted\n-               (Positions (Source),\n-                Positions (Source)'Old,\n-                Cut   => P.Get (Positions (Source)'Old, Position'Old))\n-\n-         --  Positions is valid in Target and it is located either before\n-         --  Before if it is valid in Target or at the end if it is No_Element.\n-\n-         and P.Has_Key (Positions (Target), Position)\n-         and (if Before = No_Element then\n-                 P.Get (Positions (Target), Position) = Length (Target)\n-              else\n-                 P.Get (Positions (Target), Position) =\n-                 P.Get (Positions (Target)'Old, Before))\n-\n-         --  The elements of Target located before Position are preserved\n-\n-         and M.Range_Equal\n-               (Left  => Model (Target)'Old,\n-                Right => Model (Target),\n-                Fst   => 1,\n-                Lst   => P.Get (Positions (Target), Position) - 1)\n-\n-         --  Other elements are shifted by 1\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Target)'Old,\n-                Right  => Model (Target),\n-                Fst    => P.Get (Positions (Target), Position),\n-                Lst    => Length (Target)'Old,\n-                Offset => 1)\n-\n-         --  The element located at Position in Source is moved to Target\n-\n-         and Element (Model (Target),\n-                      P.Get (Positions (Target), Position)) =\n-             Element (Model (Source)'Old,\n-                      P.Get (Positions (Source)'Old, Position'Old))\n-\n-         --  A new cursor has been inserted at position Position in Target\n-\n-         and P_Positions_Shifted\n-               (Positions (Target)'Old,\n-                Positions (Target),\n-                Cut => P.Get (Positions (Target), Position));\n-\n-   procedure Splice\n-     (Container : in out List;\n-      Before    : Cursor;\n-      Position  : Cursor)\n-   with\n-     Global         => null,\n-     Pre            =>\n-       (Has_Element (Container, Before) or else Before = No_Element)\n-         and then Has_Element (Container, Position),\n-     Post           => Length (Container) = Length (Container)'Old,\n-     Contract_Cases =>\n-       (Before = Position =>\n-          Model (Container) = Model (Container)'Old\n-            and Positions (Container) = Positions (Container)'Old,\n-\n-        Before = No_Element =>\n-\n-          --  The elements located before Position are preserved\n-\n-          M.Range_Equal\n-            (Left  => Model (Container)'Old,\n-             Right => Model (Container),\n-             Fst   => 1,\n-             Lst   => P.Get (Positions (Container)'Old, Position) - 1)\n-\n-          --  The elements located after Position are shifted by 1\n-\n-          and M.Range_Shifted\n-                (Left   => Model (Container)'Old,\n-                 Right  => Model (Container),\n-                 Fst    => P.Get (Positions (Container)'Old, Position) + 1,\n-                 Lst    => Length (Container)'Old,\n-                 Offset => -1)\n-\n-          --  The last element of Container is the one that was previously at\n-          --  Position.\n-\n-          and Element (Model (Container),\n-                       Length (Container)) =\n-              Element (Model (Container)'Old,\n-                       P.Get (Positions (Container)'Old, Position))\n-\n-          --  Cursors from Container continue designating the same elements\n-\n-          and Mapping_Preserved\n-                (M_Left  => Model (Container)'Old,\n-                 M_Right => Model (Container),\n-                 P_Left  => Positions (Container)'Old,\n-                 P_Right => Positions (Container)),\n-\n-        others =>\n-\n-          --  The elements located before Position and Before are preserved\n-\n-          M.Range_Equal\n-            (Left  => Model (Container)'Old,\n-             Right => Model (Container),\n-             Fst   => 1,\n-             Lst   =>\n-               Count_Type'Min\n-                 (P.Get (Positions (Container)'Old, Position) - 1,\n-                  P.Get (Positions (Container)'Old, Before) - 1))\n-\n-            --  The elements located after Position and Before are preserved\n-\n-            and M.Range_Equal\n-                  (Left  => Model (Container)'Old,\n-                   Right => Model (Container),\n-                   Fst   =>\n-                     Count_Type'Max\n-                       (P.Get (Positions (Container)'Old, Position) + 1,\n-                        P.Get (Positions (Container)'Old, Before) + 1),\n-                   Lst   => Length (Container))\n-\n-            --  The elements located after Before and before Position are\n-            --  shifted by 1 to the right.\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container)'Old,\n-                   Right  => Model (Container),\n-                   Fst    => P.Get (Positions (Container)'Old, Before) + 1,\n-                   Lst    => P.Get (Positions (Container)'Old, Position) - 1,\n-                   Offset => 1)\n-\n-            --  The elements located after Position and before Before are\n-            --  shifted by 1 to the left.\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container)'Old,\n-                   Right  => Model (Container),\n-                   Fst    => P.Get (Positions (Container)'Old, Position) + 1,\n-                   Lst    => P.Get (Positions (Container)'Old, Before) - 1,\n-                   Offset => -1)\n-\n-            --  The element previously at Position is now before Before\n-\n-            and Element\n-                  (Model (Container),\n-                   P.Get (Positions (Container)'Old, Before)) =\n-                Element\n-                  (Model (Container)'Old,\n-                   P.Get (Positions (Container)'Old, Position))\n-\n-            --  Cursors from Container continue designating the same elements\n-\n-            and Mapping_Preserved\n-                  (M_Left  => Model (Container)'Old,\n-                   M_Right => Model (Container),\n-                   P_Left  => Positions (Container)'Old,\n-                   P_Right => Positions (Container)));\n-\n-   function First (Container : List) return Cursor with\n-     Global         => null,\n-     Contract_Cases =>\n-       (Length (Container) = 0 =>\n-          First'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, First'Result)\n-            and P.Get (Positions (Container), First'Result) = 1);\n-\n-   function First_Element (Container : List) return Element_Type with\n-     Global => null,\n-     Pre    => not Is_Empty (Container),\n-     Post   => First_Element'Result = M.Get (Model (Container), 1);\n-\n-   function Last (Container : List) return Cursor with\n-     Global         => null,\n-     Contract_Cases =>\n-       (Length (Container) = 0 =>\n-          Last'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Last'Result)\n-            and P.Get (Positions (Container), Last'Result) =\n-                  Length (Container));\n-\n-   function Last_Element (Container : List) return Element_Type with\n-     Global => null,\n-     Pre    => not Is_Empty (Container),\n-     Post   =>\n-       Last_Element'Result = M.Get (Model (Container), Length (Container));\n-\n-   function Next (Container : List; Position : Cursor) return Cursor with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = Length (Container)\n-        =>\n-          Next'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Next'Result)\n-            and then P.Get (Positions (Container), Next'Result) =\n-                     P.Get (Positions (Container), Position) + 1);\n-\n-   procedure Next (Container : List; Position : in out Cursor) with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = Length (Container)\n-        =>\n-          Position = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Position)\n-            and then P.Get (Positions (Container), Position) =\n-                     P.Get (Positions (Container), Position'Old) + 1);\n-\n-   function Previous (Container : List; Position : Cursor) return Cursor with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = 1\n-        =>\n-          Previous'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Previous'Result)\n-            and then P.Get (Positions (Container), Previous'Result) =\n-                     P.Get (Positions (Container), Position) - 1);\n-\n-   procedure Previous (Container : List; Position : in out Cursor) with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = 1\n-         =>\n-          Position = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Position)\n-            and then P.Get (Positions (Container), Position) =\n-                     P.Get (Positions (Container), Position'Old) - 1);\n-\n-   function Find\n-     (Container : List;\n-      Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-\n-       --  If Item is not contained in Container after Position, Find returns\n-       --  No_Element.\n-\n-       (not M.Contains\n-              (Container => Model (Container),\n-               Fst       =>\n-                 (if Position = No_Element then\n-                     1\n-                  else\n-                     P.Get (Positions (Container), Position)),\n-               Lst       => Length (Container),\n-               Item      => Item)\n-        =>\n-          Find'Result = No_Element,\n-\n-        --  Otherwise, Find returns a valid cursor in Container\n-\n-        others =>\n-          P.Has_Key (Positions (Container), Find'Result)\n-\n-            --  The element designated by the result of Find is Item\n-\n-            and Element\n-                  (Model (Container),\n-                   P.Get (Positions (Container), Find'Result)) = Item\n-\n-            --  The result of Find is located after Position\n-\n-            and (if Position /= No_Element then\n-                    P.Get (Positions (Container), Find'Result) >=\n-                    P.Get (Positions (Container), Position))\n-\n-            --  It is the first occurrence of Item in this slice\n-\n-            and not M.Contains\n-                      (Container => Model (Container),\n-                       Fst       =>\n-                         (if Position = No_Element then\n-                             1\n-                          else\n-                             P.Get (Positions (Container), Position)),\n-                       Lst       =>\n-                         P.Get (Positions (Container), Find'Result) - 1,\n-                       Item      => Item));\n-\n-   function Reverse_Find\n-     (Container : List;\n-      Item      : Element_Type;\n-      Position  : Cursor := No_Element) return Cursor\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-\n-       --  If Item is not contained in Container before Position, Find returns\n-       --  No_Element.\n-\n-       (not M.Contains\n-              (Container => Model (Container),\n-               Fst       => 1,\n-               Lst       =>\n-                 (if Position = No_Element then\n-                     Length (Container)\n-                  else\n-                     P.Get (Positions (Container), Position)),\n-               Item      => Item)\n-        =>\n-          Reverse_Find'Result = No_Element,\n-\n-        --  Otherwise, Find returns a valid cursor in Container\n-\n-        others =>\n-          P.Has_Key (Positions (Container), Reverse_Find'Result)\n-\n-            --  The element designated by the result of Find is Item\n-\n-            and Element\n-                  (Model (Container),\n-                   P.Get (Positions (Container), Reverse_Find'Result)) = Item\n-\n-            --  The result of Find is located before Position\n-\n-            and (if Position /= No_Element then\n-                    P.Get (Positions (Container), Reverse_Find'Result) <=\n-                    P.Get (Positions (Container), Position))\n-\n-            --  It is the last occurrence of Item in this slice\n-\n-            and not M.Contains\n-                      (Container => Model (Container),\n-                       Fst       =>\n-                         P.Get (Positions (Container),\n-                                Reverse_Find'Result) + 1,\n-                       Lst       =>\n-                         (if Position = No_Element then\n-                             Length (Container)\n-                          else\n-                             P.Get (Positions (Container), Position)),\n-                       Item      => Item));\n-\n-   function Contains\n-     (Container : List;\n-      Item      : Element_Type) return Boolean\n-   with\n-     Global => null,\n-     Post   =>\n-       Contains'Result = M.Contains (Container => Model (Container),\n-                                     Fst       => 1,\n-                                     Lst       => Length (Container),\n-                                     Item      => Item);\n-\n-   function Has_Element\n-     (Container : List;\n-      Position  : Cursor) return Boolean\n-   with\n-     Global => null,\n-     Post   =>\n-       Has_Element'Result = P.Has_Key (Positions (Container), Position);\n-   pragma Annotate (GNATprove, Inline_For_Proof, Has_Element);\n-\n-   generic\n-      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n-\n-   package Generic_Sorting with SPARK_Mode is\n-\n-      package Formal_Model with Ghost is\n-         function M_Elements_Sorted (Container : M.Sequence) return Boolean\n-         with\n-           Global => null,\n-           Post   =>\n-             M_Elements_Sorted'Result =\n-               (for all I in 1 .. M.Length (Container) =>\n-                 (for all J in I .. M.Length (Container) =>\n-                   not (Element (Container, J) < Element (Container, I))));\n-         pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n-\n-      end Formal_Model;\n-      use Formal_Model;\n-\n-      function Is_Sorted (Container : List) return Boolean with\n-        Global => null,\n-        Post   => Is_Sorted'Result = M_Elements_Sorted (Model (Container));\n-\n-      procedure Sort (Container : in out List) with\n-        Global => null,\n-        Post   =>\n-          Length (Container) = Length (Container)'Old\n-            and M_Elements_Sorted (Model (Container))\n-            and M_Elements_Included\n-                  (Left  => Model (Container)'Old,\n-                   L_Lst => Length (Container),\n-                   Right => Model (Container),\n-                   R_Lst => Length (Container))\n-            and M_Elements_Included\n-                  (Left  => Model (Container),\n-                   L_Lst => Length (Container),\n-                   Right => Model (Container)'Old,\n-                   R_Lst => Length (Container));\n-\n-      procedure Merge (Target : in out List; Source : in out List) with\n-      --  Target and Source should not be aliased\n-        Global => null,\n-        Pre    => Length (Target) <= Count_Type'Last - Length (Source),\n-        Post   =>\n-          Length (Target) = Length (Target)'Old + Length (Source)'Old\n-            and Length (Source) = 0\n-            and (if M_Elements_Sorted (Model (Target)'Old)\n-                   and M_Elements_Sorted (Model (Source)'Old)\n-                 then\n-                    M_Elements_Sorted (Model (Target)))\n-            and M_Elements_Included\n-                  (Left  => Model (Target)'Old,\n-                   L_Lst => Length (Target)'Old,\n-                   Right => Model (Target),\n-                   R_Lst => Length (Target))\n-            and M_Elements_Included\n-                  (Left  => Model (Source)'Old,\n-                   L_Lst => Length (Source)'Old,\n-                   Right => Model (Target),\n-                   R_Lst => Length (Target))\n-            and M_Elements_In_Union\n-                  (Model (Target),\n-                   Model (Source)'Old,\n-                   Model (Target)'Old);\n-   end Generic_Sorting;\n-\n-private\n-   pragma SPARK_Mode (Off);\n-\n-   use Ada.Finalization;\n-\n-   type Element_Access is access all Element_Type;\n-\n-   type Node_Type is record\n-      Prev    : Count_Type'Base := -1;\n-      Next    : Count_Type := 0;\n-      Element : Element_Access := null;\n-   end record;\n-\n-   type Node_Access is access all Node_Type;\n-\n-   function \"=\" (L, R : Node_Type) return Boolean is abstract;\n-\n-   type Node_Array is array (Count_Type range <>) of Node_Type;\n-   function \"=\" (L, R : Node_Array) return Boolean is abstract;\n-\n-   type Node_Array_Access is access all Node_Array;\n+package Ada.Containers.Formal_Indefinite_Doubly_Linked_Lists with SPARK_Mode is\n \n-   type List is new Controlled with record\n-      Free   : Count_Type'Base := -1;\n-      Length : Count_Type := 0;\n-      First  : Count_Type := 0;\n-      Last   : Count_Type := 0;\n-      Nodes  : Node_Array_Access := null;\n-   end record;\n+   pragma Compile_Time_Error\n+     (True,\n+      \"This package has been moved to the SPARK library shipped with any\"\n+      & \" SPARK release starting with version 23.\");\n \n-   overriding procedure Finalize (Container : in out List);\n-   overriding procedure Adjust (Container : in out List);\n end Ada.Containers.Formal_Indefinite_Doubly_Linked_Lists;"}, {"sha": "7b457f6fb9f57a06e625b6a72b6c7494a0ce656b", "filename": "gcc/ada/libgnat/a-cfinse.adb", "status": "removed", "additions": 0, "deletions": 304, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cfinse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cfinse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfinse.adb?ref=cf8af60f6a3910577e99db04dbc757e731558144", "patch": "@@ -1,304 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT LIBRARY COMPONENTS                          --\n---                                                                          --\n---                ADA.CONTAINERS.FUNCTIONAL_INFINITE_SEQUENCE               --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2022-2022, Free Software Foundation, Inc.         --\n---                                                                          --\n--- This specification is derived from the Ada Reference Manual for use with --\n--- GNAT. The copyright notice above, and the license provisions that follow --\n--- apply solely to the  contents of the part following the private keyword. --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n-------------------------------------------------------------------------------\n-\n-pragma Ada_2012;\n-\n-package body Ada.Containers.Functional_Infinite_Sequences\n-with SPARK_Mode => Off\n-is\n-   use Containers;\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   package Big_From_Count is new Signed_Conversions\n-     (Int => Count_Type);\n-\n-   function Big (C : Count_Type) return Big_Integer renames\n-     Big_From_Count.To_Big_Integer;\n-\n-   --  Store Count_Type'Last as a Big Natural because it is often used\n-\n-   Count_Type_Big_Last : constant Big_Natural := Big (Count_Type'Last);\n-\n-   function To_Count (C : Big_Natural) return Count_Type;\n-   --  Convert Big_Natural to Count_Type\n-\n-   ---------\n-   -- \"<\" --\n-   ---------\n-\n-   function \"<\" (Left : Sequence; Right : Sequence) return Boolean is\n-     (Length (Left) < Length (Right)\n-      and then (for all N in Left =>\n-                     Get (Left, N) = Get (Right, N)));\n-\n-   ----------\n-   -- \"<=\" --\n-   ----------\n-\n-   function \"<=\" (Left : Sequence; Right : Sequence) return Boolean is\n-     (Length (Left) <= Length (Right)\n-      and then (for all N in Left =>\n-                     Get (Left, N) = Get (Right, N)));\n-\n-   ---------\n-   -- \"=\" --\n-   ---------\n-\n-   function \"=\" (Left : Sequence; Right : Sequence) return Boolean is\n-     (Left.Content = Right.Content);\n-\n-   ---------\n-   -- Add --\n-   ---------\n-\n-   function Add (Container : Sequence; New_Item : Element_Type) return Sequence\n-   is\n-     (Add (Container, Last (Container) + 1, New_Item));\n-\n-   function Add\n-     (Container : Sequence;\n-      Position  : Big_Positive;\n-      New_Item  : Element_Type) return Sequence is\n-     (Content => Add (Container.Content, To_Count (Position), New_Item));\n-\n-   --------------------\n-   -- Constant_Range --\n-   --------------------\n-\n-   function Constant_Range\n-     (Container : Sequence;\n-      Fst       : Big_Positive;\n-      Lst       : Big_Natural;\n-      Item      : Element_Type) return Boolean\n-   is\n-      Count_Fst : constant Count_Type := To_Count (Fst);\n-      Count_Lst : constant Count_Type := To_Count (Lst);\n-\n-   begin\n-      for J in Count_Fst .. Count_Lst loop\n-         if Get (Container.Content, J) /= Item then\n-            return False;\n-         end if;\n-      end loop;\n-\n-      return True;\n-   end Constant_Range;\n-\n-   --------------\n-   -- Contains --\n-   --------------\n-\n-   function Contains\n-     (Container : Sequence;\n-      Fst       : Big_Positive;\n-      Lst       : Big_Natural;\n-      Item      : Element_Type) return Boolean\n-   is\n-      Count_Fst : constant Count_Type := To_Count (Fst);\n-      Count_Lst : constant Count_Type := To_Count (Lst);\n-\n-   begin\n-      for J in Count_Fst .. Count_Lst loop\n-         if Get (Container.Content, J) = Item then\n-            return True;\n-         end if;\n-      end loop;\n-\n-      return False;\n-   end Contains;\n-\n-   --------------------\n-   -- Empty_Sequence --\n-   --------------------\n-\n-   function Empty_Sequence return Sequence is\n-      (Content => <>);\n-\n-   ------------------\n-   -- Equal_Except --\n-   ------------------\n-\n-   function Equal_Except\n-     (Left     : Sequence;\n-      Right    : Sequence;\n-      Position : Big_Positive) return Boolean\n-   is\n-      Count_Pos : constant Count_Type := To_Count (Position);\n-      Count_Lst : constant Count_Type := To_Count (Last (Left));\n-\n-   begin\n-      if Length (Left) /= Length (Right) then\n-         return False;\n-      end if;\n-\n-      for J in 1 .. Count_Lst loop\n-         if J /= Count_Pos\n-              and then Get (Left.Content, J) /= Get (Right.Content, J)\n-         then\n-            return False;\n-         end if;\n-      end loop;\n-\n-      return True;\n-   end Equal_Except;\n-\n-   function Equal_Except\n-     (Left  : Sequence;\n-      Right : Sequence;\n-      X     : Big_Positive;\n-      Y     : Big_Positive) return Boolean\n-   is\n-      Count_X   : constant Count_Type := To_Count (X);\n-      Count_Y   : constant Count_Type := To_Count (Y);\n-      Count_Lst : constant Count_Type := To_Count (Last (Left));\n-\n-   begin\n-      if Length (Left) /= Length (Right) then\n-         return False;\n-      end if;\n-\n-      for J in 1 .. Count_Lst loop\n-         if J /= Count_X\n-              and then J /= Count_Y\n-              and then Get (Left.Content, J) /= Get (Right.Content, J)\n-         then\n-            return False;\n-         end if;\n-      end loop;\n-\n-      return True;\n-   end Equal_Except;\n-\n-   ---------\n-   -- Get --\n-   ---------\n-\n-   function Get\n-     (Container : Sequence;\n-      Position  : Big_Integer) return Element_Type is\n-     (Get (Container.Content, To_Count (Position)));\n-\n-   ----------\n-   -- Last --\n-   ----------\n-\n-   function Last (Container : Sequence) return Big_Natural is\n-      (Length (Container));\n-\n-   ------------\n-   -- Length --\n-   ------------\n-\n-   function Length (Container : Sequence) return Big_Natural is\n-     (Big (Length (Container.Content)));\n-\n-   -----------------\n-   -- Range_Equal --\n-   -----------------\n-\n-   function Range_Equal\n-     (Left  : Sequence;\n-      Right : Sequence;\n-      Fst   : Big_Positive;\n-      Lst   : Big_Natural) return Boolean\n-   is\n-      Count_Fst : constant Count_Type := To_Count (Fst);\n-      Count_Lst : constant Count_Type := To_Count (Lst);\n-\n-   begin\n-      for J in Count_Fst .. Count_Lst loop\n-         if Get (Left.Content, J) /= Get (Right.Content, J) then\n-            return False;\n-         end if;\n-      end loop;\n-\n-      return True;\n-   end Range_Equal;\n-\n-   -------------------\n-   -- Range_Shifted --\n-   -------------------\n-\n-   function Range_Shifted\n-     (Left   : Sequence;\n-      Right  : Sequence;\n-      Fst    : Big_Positive;\n-      Lst    : Big_Natural;\n-      Offset : Big_Integer) return Boolean\n-   is\n-      Count_Fst : constant Count_Type := To_Count (Fst);\n-      Count_Lst : constant Count_Type := To_Count (Lst);\n-\n-   begin\n-      for J in Count_Fst .. Count_Lst loop\n-         if Get (Left.Content, J) /= Get (Right, Big (J) + Offset) then\n-            return False;\n-         end if;\n-      end loop;\n-\n-      return True;\n-   end Range_Shifted;\n-\n-   ------------\n-   -- Remove --\n-   ------------\n-\n-   function Remove\n-     (Container : Sequence;\n-      Position : Big_Positive) return Sequence is\n-     (Content => Remove (Container.Content, To_Count (Position)));\n-\n-   ---------\n-   -- Set --\n-   ---------\n-\n-   function Set\n-     (Container : Sequence;\n-      Position  : Big_Positive;\n-      New_Item  : Element_Type) return Sequence is\n-     (Content => Set (Container.Content, To_Count (Position), New_Item));\n-\n-   --------------\n-   -- To_Count --\n-   --------------\n-\n-   function To_Count (C : Big_Natural) return Count_Type is\n-   begin\n-      if C > Count_Type_Big_Last then\n-         raise Program_Error with \"Big_Integer too large for Count_Type\";\n-      end if;\n-      return Big_From_Count.From_Big_Integer (C);\n-   end To_Count;\n-\n-end Ada.Containers.Functional_Infinite_Sequences;"}, {"sha": "6f517fa804615a561269dc4071a3020cef364e56", "filename": "gcc/ada/libgnat/a-cfinse.ads", "status": "modified", "additions": 5, "deletions": 345, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cfinse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cfinse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfinse.ads?ref=4a7312f7ce189783a2cb5318bdcf50e8148b909d", "patch": "@@ -29,352 +29,12 @@\n -- <http://www.gnu.org/licenses/>.                                          --\n ------------------------------------------------------------------------------\n \n-pragma Ada_2012;\n-private with Ada.Containers.Functional_Base;\n-with Ada.Numerics.Big_Numbers.Big_Integers;\n-use Ada.Numerics.Big_Numbers.Big_Integers;\n-\n generic\n-   type Element_Type (<>) is private;\n-   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n-\n-package Ada.Containers.Functional_Infinite_Sequences with\n-  SPARK_Mode,\n-  Annotate => (GNATprove, Always_Return)\n-is\n-\n-   type Sequence is private\n-     with Default_Initial_Condition => Length (Sequence) = 0,\n-     Iterable => (First       => Iter_First,\n-                  Has_Element => Iter_Has_Element,\n-                  Next        => Iter_Next,\n-                  Element     => Get);\n-   --  Sequences are empty when default initialized.\n-   --  Quantification over sequences can be done using the regular\n-   --  quantification over its range or directly on its elements with \"for of\".\n-\n-   -----------------------\n-   --  Basic operations --\n-   -----------------------\n-\n-   --  Sequences are axiomatized using Length and Get, providing respectively\n-   --  the length of a sequence and an accessor to its Nth element:\n-\n-   function Length (Container : Sequence) return Big_Natural with\n-   --  Length of a sequence\n-\n-     Global => null;\n-\n-   function Get\n-     (Container : Sequence;\n-      Position  : Big_Integer) return Element_Type\n-   --  Access the Element at position Position in Container\n-\n-   with\n-     Global => null,\n-     Pre    => Iter_Has_Element (Container, Position);\n-\n-   function Last (Container : Sequence) return Big_Natural with\n-   --  Last index of a sequence\n-\n-     Global => null,\n-     Post =>\n-       Last'Result = Length (Container);\n-   pragma Annotate (GNATprove, Inline_For_Proof, Last);\n-\n-   function First return Big_Positive is (1) with\n-   --  First index of a sequence\n-\n-     Global => null;\n-\n-   ------------------------\n-   -- Property Functions --\n-   ------------------------\n-\n-   function \"=\" (Left : Sequence; Right : Sequence) return Boolean with\n-   --  Extensional equality over sequences\n-\n-     Global => null,\n-     Post   =>\n-       \"=\"'Result =\n-         (Length (Left) = Length (Right)\n-           and then (for all N in Left => Get (Left, N) = Get (Right, N)));\n-   pragma Annotate (GNATprove, Inline_For_Proof, \"=\");\n-\n-   function \"<\" (Left : Sequence; Right : Sequence) return Boolean with\n-   --  Left is a strict subsequence of Right\n-\n-     Global => null,\n-     Post   =>\n-       \"<\"'Result =\n-         (Length (Left) < Length (Right)\n-           and then (for all N in Left => Get (Left, N) = Get (Right, N)));\n-   pragma Annotate (GNATprove, Inline_For_Proof, \"<\");\n-\n-   function \"<=\" (Left : Sequence; Right : Sequence) return Boolean with\n-   --  Left is a subsequence of Right\n-\n-     Global => null,\n-     Post   =>\n-       \"<=\"'Result =\n-         (Length (Left) <= Length (Right)\n-           and then (for all N in Left => Get (Left, N) = Get (Right, N)));\n-   pragma Annotate (GNATprove, Inline_For_Proof, \"<=\");\n-\n-   function Contains\n-     (Container : Sequence;\n-      Fst       : Big_Positive;\n-      Lst       : Big_Natural;\n-      Item      : Element_Type) return Boolean\n-   --  Returns True if Item occurs in the range from Fst to Lst of Container\n-\n-   with\n-     Global => null,\n-     Pre    => Lst <= Last (Container),\n-     Post   =>\n-       Contains'Result =\n-           (for some J in Container =>\n-              Fst <= J and J <= Lst and Get (Container, J) = Item);\n-   pragma Annotate (GNATprove, Inline_For_Proof, Contains);\n-\n-   function Constant_Range\n-     (Container : Sequence;\n-      Fst       : Big_Positive;\n-      Lst       : Big_Natural;\n-      Item      : Element_Type) return Boolean\n-   --  Returns True if every element of the range from Fst to Lst of Container\n-   --  is equal to Item.\n-\n-   with\n-     Global => null,\n-     Pre    => Lst <= Last (Container),\n-     Post   =>\n-       Constant_Range'Result =\n-           (for all J in Container =>\n-              (if Fst <= J and J <= Lst then Get (Container, J) = Item));\n-   pragma Annotate (GNATprove, Inline_For_Proof, Constant_Range);\n-\n-   function Equal_Except\n-     (Left     : Sequence;\n-      Right    : Sequence;\n-      Position : Big_Positive) return Boolean\n-   --  Returns True is Left and Right are the same except at position Position\n-\n-   with\n-     Global => null,\n-     Pre    => Position <= Last (Left),\n-     Post   =>\n-       Equal_Except'Result =\n-         (Length (Left) = Length (Right)\n-           and then (for all J in Left =>\n-                       (if J /= Position then\n-                          Get (Left, J) = Get (Right, J))));\n-   pragma Annotate (GNATprove, Inline_For_Proof, Equal_Except);\n-\n-   function Equal_Except\n-     (Left  : Sequence;\n-      Right : Sequence;\n-      X     : Big_Positive;\n-      Y     : Big_Positive) return Boolean\n-   --  Returns True is Left and Right are the same except at positions X and Y\n-\n-   with\n-     Global => null,\n-     Pre    => X <= Last (Left) and Y <= Last (Left),\n-     Post   =>\n-       Equal_Except'Result =\n-         (Length (Left) = Length (Right)\n-           and then (for all J in Left =>\n-                       (if J /= X and J /= Y then\n-                          Get (Left, J) = Get (Right, J))));\n-   pragma Annotate (GNATprove, Inline_For_Proof, Equal_Except);\n-\n-   function Range_Equal\n-     (Left  : Sequence;\n-      Right : Sequence;\n-      Fst   : Big_Positive;\n-      Lst   : Big_Natural) return Boolean\n-   --  Returns True if the ranges from Fst to Lst contain the same elements in\n-   --  Left and Right.\n-\n-   with\n-     Global => null,\n-     Pre    => Lst <= Last (Left) and Lst <= Last (Right),\n-     Post   =>\n-       Range_Equal'Result =\n-         (for all J in Left =>\n-            (if Fst <= J and J <= Lst then Get (Left, J) = Get (Right, J)));\n-   pragma Annotate (GNATprove, Inline_For_Proof, Range_Equal);\n-\n-   function Range_Shifted\n-     (Left   : Sequence;\n-      Right  : Sequence;\n-      Fst    : Big_Positive;\n-      Lst    : Big_Natural;\n-      Offset : Big_Integer) return Boolean\n-   --  Returns True if the range from Fst to Lst in Left contains the same\n-   --  elements as the range from Fst + Offset to Lst + Offset in Right.\n-\n-   with\n-     Global => null,\n-     Pre    =>\n-       Lst <= Last (Left)\n-         and then\n-           (if Fst <= Lst then\n-              Offset + Fst >= 1 and Offset + Lst <= Length (Right)),\n-     Post   =>\n-       Range_Shifted'Result =\n-         ((for all J in Left =>\n-             (if Fst <= J and J <= Lst then\n-                Get (Left, J) = Get (Right, J + Offset)))\n-          and\n-            (for all J in Right =>\n-               (if Fst + Offset <= J and J <= Lst + Offset then\n-                  Get (Left, J - Offset) = Get (Right, J))));\n-   pragma Annotate (GNATprove, Inline_For_Proof, Range_Shifted);\n-\n-   ----------------------------\n-   -- Construction Functions --\n-   ----------------------------\n-\n-   --  For better efficiency of both proofs and execution, avoid using\n-   --  construction functions in annotations and rather use property functions.\n-\n-   function Set\n-     (Container : Sequence;\n-      Position  : Big_Positive;\n-      New_Item  : Element_Type) return Sequence\n-   --  Returns a new sequence which contains the same elements as Container\n-   --  except for the one at position Position which is replaced by New_Item.\n-\n-   with\n-     Global => null,\n-     Pre    => Position <= Last (Container),\n-     Post   =>\n-       Get (Set'Result, Position) = New_Item\n-         and then Equal_Except (Container, Set'Result, Position);\n-\n-   function Add (Container : Sequence; New_Item : Element_Type) return Sequence\n-   --  Returns a new sequence which contains the same elements as Container\n-   --  plus New_Item at the end.\n-\n-   with\n-     Global => null,\n-     Post   =>\n-       Length (Add'Result) = Length (Container) + 1\n-         and then Get (Add'Result, Last (Add'Result)) = New_Item\n-         and then Container <= Add'Result;\n-\n-   function Add\n-     (Container : Sequence;\n-      Position  : Big_Positive;\n-      New_Item  : Element_Type) return Sequence\n-   with\n-   --  Returns a new sequence which contains the same elements as Container\n-   --  except that New_Item has been inserted at position Position.\n-\n-     Global => null,\n-     Pre    => Position <= Last (Container) + 1,\n-     Post   =>\n-       Length (Add'Result) = Length (Container) + 1\n-         and then Get (Add'Result, Position) = New_Item\n-         and then Range_Equal\n-                    (Left  => Container,\n-                     Right => Add'Result,\n-                     Fst   => 1,\n-                     Lst   => Position - 1)\n-         and then Range_Shifted\n-                    (Left   => Container,\n-                     Right  => Add'Result,\n-                     Fst    => Position,\n-                     Lst    => Last (Container),\n-                     Offset => 1);\n-\n-   function Remove\n-     (Container : Sequence;\n-      Position : Big_Positive) return Sequence\n-   --  Returns a new sequence which contains the same elements as Container\n-   --  except that the element at position Position has been removed.\n-\n-   with\n-     Global => null,\n-     Pre    => Position <= Last (Container),\n-     Post   =>\n-       Length (Remove'Result) = Length (Container) - 1\n-         and then Range_Equal\n-                    (Left  => Container,\n-                     Right => Remove'Result,\n-                     Fst   => 1,\n-                     Lst   => Position - 1)\n-         and then Range_Shifted\n-                    (Left   => Remove'Result,\n-                     Right  => Container,\n-                     Fst    => Position,\n-                     Lst    => Last (Remove'Result),\n-                     Offset => 1);\n-\n-   function Copy_Element (Item : Element_Type) return Element_Type is (Item);\n-   --  Elements of containers are copied by numerous primitives in this\n-   --  package. This function causes GNATprove to verify that such a copy is\n-   --  valid (in particular, it does not break the ownership policy of SPARK,\n-   --  i.e. it does not contain pointers that could be used to alias mutable\n-   --  data).\n-\n-   function Empty_Sequence return Sequence with\n-   --  Return an empty Sequence\n-\n-     Global => null,\n-     Post   => Length (Empty_Sequence'Result) = 0;\n-\n-   ---------------------------\n-   --  Iteration Primitives --\n-   ---------------------------\n-\n-   function Iter_First (Container : Sequence) return Big_Integer with\n-     Global => null,\n-     Post   => Iter_First'Result = 1;\n-\n-   function Iter_Has_Element\n-     (Container : Sequence;\n-      Position  : Big_Integer) return Boolean\n-   with\n-     Global => null,\n-       Post   => Iter_Has_Element'Result =\n-                   In_Range (Position, 1, Length (Container));\n-   pragma Annotate (GNATprove, Inline_For_Proof, Iter_Has_Element);\n-\n-   function Iter_Next\n-     (Container : Sequence;\n-      Position  : Big_Integer) return Big_Integer\n-   with\n-     Global => null,\n-     Pre    => Iter_Has_Element (Container, Position),\n-     Post   => Iter_Next'Result = Position + 1;\n-\n-private\n-   pragma SPARK_Mode (Off);\n-\n-   subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n-\n-   package Containers is new Ada.Containers.Functional_Base\n-     (Index_Type   => Positive_Count_Type,\n-      Element_Type => Element_Type);\n-\n-   type Sequence is record\n-      Content : Containers.Container;\n-   end record;\n-\n-   function Iter_First (Container : Sequence) return Big_Integer is (1);\n+package Ada.Containers.Functional_Infinite_Sequences with SPARK_Mode is\n \n-   function Iter_Next\n-     (Container : Sequence;\n-      Position  : Big_Integer) return Big_Integer\n-   is\n-     (Position + 1);\n+   pragma Compile_Time_Error\n+     (True,\n+      \"This package has been moved to the SPARK library shipped with any\"\n+      & \" SPARK release starting with version 23.\");\n \n-   function Iter_Has_Element\n-     (Container : Sequence;\n-      Position  : Big_Integer) return Boolean\n-   is\n-     (In_Range (Position, 1, Length (Container)));\n end Ada.Containers.Functional_Infinite_Sequences;"}, {"sha": "a55786d95d0b86d323c914e32b4166f533331460", "filename": "gcc/ada/libgnat/a-cfinve.adb", "status": "removed", "additions": 0, "deletions": 1452, "changes": 1452, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cfinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cfinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfinve.adb?ref=cf8af60f6a3910577e99db04dbc757e731558144", "patch": "@@ -1,1452 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT LIBRARY COMPONENTS                          --\n---                                                                          --\n---                 ADA.CONTAINERS.FORMAL_INDEFINITE_VECTORS                 --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2010-2022, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Containers.Generic_Array_Sort;\n-with Ada.Unchecked_Deallocation;\n-\n-with System; use type System.Address;\n-\n-package body Ada.Containers.Formal_Indefinite_Vectors with\n-  SPARK_Mode => Off\n-is\n-   function H (New_Item : Element_Type) return Holder renames To_Holder;\n-   function E (Container : Holder) return Element_Type renames Get;\n-\n-   Growth_Factor : constant := 2;\n-   --  When growing a container, multiply current capacity by this. Doubling\n-   --  leads to amortized linear-time copying.\n-\n-   subtype Int is Long_Long_Integer;\n-\n-   procedure Free is\n-     new Ada.Unchecked_Deallocation (Elements_Array, Elements_Array_Ptr);\n-\n-   type Maximal_Array_Ptr is access all Elements_Array (Array_Index)\n-     with Storage_Size => 0;\n-   type Maximal_Array_Ptr_Const is access constant Elements_Array (Array_Index)\n-     with Storage_Size => 0;\n-\n-   function Elems (Container : in out Vector) return Maximal_Array_Ptr;\n-   function Elemsc\n-     (Container : Vector) return Maximal_Array_Ptr_Const;\n-   --  Returns a pointer to the Elements array currently in use -- either\n-   --  Container.Elements_Ptr or a pointer to Container.Elements. We work with\n-   --  pointers to a bogus array subtype that is constrained with the maximum\n-   --  possible bounds. This means that the pointer is a thin pointer. This is\n-   --  necessary because 'Unrestricted_Access doesn't work when it produces\n-   --  access-to-unconstrained and is returned from a function.\n-   --\n-   --  Note that this is dangerous: make sure calls to this use an indexed\n-   --  component or slice that is within the bounds 1 .. Length (Container).\n-\n-   function Get_Element\n-     (Container : Vector;\n-      Position  : Capacity_Range) return Element_Type;\n-\n-   function To_Array_Index (Index : Index_Type'Base) return Count_Type'Base;\n-\n-   function Current_Capacity (Container : Vector) return Capacity_Range;\n-\n-   procedure Insert_Space\n-     (Container : in out Vector;\n-      Before    : Extended_Index;\n-      Count     : Count_Type := 1);\n-\n-   ---------\n-   -- \"=\" --\n-   ---------\n-\n-   function \"=\" (Left : Vector; Right : Vector) return Boolean is\n-   begin\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n-      if Length (Left) /= Length (Right) then\n-         return False;\n-      end if;\n-\n-      for J in 1 .. Length (Left) loop\n-         if Get_Element (Left, J) /= Get_Element (Right, J) then\n-            return False;\n-         end if;\n-      end loop;\n-\n-      return True;\n-   end \"=\";\n-\n-   ------------\n-   -- Append --\n-   ------------\n-\n-   procedure Append (Container : in out Vector; New_Item : Vector) is\n-   begin\n-      if Is_Empty (New_Item) then\n-         return;\n-      end if;\n-\n-      if Container.Last >= Index_Type'Last then\n-         raise Constraint_Error with \"vector is already at its maximum length\";\n-      end if;\n-\n-      Insert (Container, Container.Last + 1, New_Item);\n-   end Append;\n-\n-   procedure Append (Container : in out Vector; New_Item : Element_Type) is\n-   begin\n-      Append (Container, New_Item, 1);\n-   end Append;\n-\n-   procedure Append\n-     (Container : in out Vector;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   is\n-   begin\n-      if Count = 0 then\n-         return;\n-      end if;\n-\n-      if Container.Last >= Index_Type'Last then\n-         raise Constraint_Error with \"vector is already at its maximum length\";\n-      end if;\n-\n-      Insert (Container, Container.Last + 1, New_Item, Count);\n-   end Append;\n-\n-   ------------\n-   -- Assign --\n-   ------------\n-\n-   procedure Assign (Target : in out Vector; Source : Vector) is\n-      LS : constant Capacity_Range := Length (Source);\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n-      if Bounded and then Target.Capacity < LS then\n-         raise Constraint_Error;\n-      end if;\n-\n-      Clear (Target);\n-      Append (Target, Source);\n-   end Assign;\n-\n-   --------------\n-   -- Capacity --\n-   --------------\n-\n-   function Capacity (Container : Vector) return Capacity_Range is\n-   begin\n-      return\n-        (if Bounded then\n-            Container.Capacity\n-         else\n-            Capacity_Range'Last);\n-   end Capacity;\n-\n-   -----------\n-   -- Clear --\n-   -----------\n-\n-   procedure Clear (Container : in out Vector) is\n-   begin\n-      Container.Last := No_Index;\n-\n-      --  Free element, note that this is OK if Elements_Ptr is null\n-\n-      Free (Container.Elements_Ptr);\n-   end Clear;\n-\n-   ------------------------\n-   -- Constant_Reference --\n-   ------------------------\n-\n-   function Constant_Reference\n-     (Container : aliased Vector;\n-      Index     : Index_Type) return not null access constant Element_Type\n-   is\n-   begin\n-      if Index > Container.Last then\n-         raise Constraint_Error with \"Index is out of range\";\n-      end if;\n-\n-      declare\n-         II : constant Int'Base := Int (Index) - Int (No_Index);\n-         I  : constant Capacity_Range := Capacity_Range (II);\n-\n-      begin\n-         return Constant_Reference (Elemsc (Container) (I));\n-      end;\n-   end Constant_Reference;\n-\n-   --------------\n-   -- Contains --\n-   --------------\n-\n-   function Contains\n-     (Container : Vector;\n-      Item      : Element_Type) return Boolean\n-   is\n-   begin\n-      return Find_Index (Container, Item) /= No_Index;\n-   end Contains;\n-\n-   ----------\n-   -- Copy --\n-   ----------\n-\n-   function Copy\n-     (Source   : Vector;\n-      Capacity : Capacity_Range := 0) return Vector\n-   is\n-      LS : constant Capacity_Range := Length (Source);\n-      C  : Capacity_Range;\n-\n-   begin\n-      if Capacity = 0 then\n-         C := LS;\n-      elsif Capacity >= LS then\n-         C := Capacity;\n-      else\n-         raise Capacity_Error;\n-      end if;\n-\n-      return Target : Vector (C) do\n-         Elems (Target) (1 .. LS) := Elemsc (Source) (1 .. LS);\n-         Target.Last := Source.Last;\n-      end return;\n-   end Copy;\n-\n-   ----------------------\n-   -- Current_Capacity --\n-   ----------------------\n-\n-   function Current_Capacity (Container : Vector) return Capacity_Range is\n-   begin\n-      return\n-        (if Container.Elements_Ptr = null then\n-            Container.Elements'Length\n-         else\n-            Container.Elements_Ptr.all'Length);\n-   end Current_Capacity;\n-\n-   ------------\n-   -- Delete --\n-   ------------\n-\n-   procedure Delete (Container : in out Vector; Index : Extended_Index) is\n-   begin\n-      Delete (Container, Index, 1);\n-   end Delete;\n-\n-   procedure Delete\n-     (Container : in out Vector;\n-      Index     : Extended_Index;\n-      Count     : Count_Type)\n-   is\n-      Old_Last : constant Index_Type'Base := Container.Last;\n-      Old_Len  : constant Count_Type := Length (Container);\n-      New_Last : Index_Type'Base;\n-      Count2   : Count_Type'Base;  -- count of items from Index to Old_Last\n-      Off      : Count_Type'Base;  -- Index expressed as offset from IT'First\n-\n-   begin\n-      --  Delete removes items from the vector, the number of which is the\n-      --  minimum of the specified Count and the items (if any) that exist from\n-      --  Index to Container.Last. There are no constraints on the specified\n-      --  value of Count (it can be larger than what's available at this\n-      --  position in the vector, for example), but there are constraints on\n-      --  the allowed values of the Index.\n-\n-      --  As a precondition on the generic actual Index_Type, the base type\n-      --  must include Index_Type'Pred (Index_Type'First); this is the value\n-      --  that Container.Last assumes when the vector is empty. However, we do\n-      --  not allow that as the value for Index when specifying which items\n-      --  should be deleted, so we must manually check. (That the user is\n-      --  allowed to specify the value at all here is a consequence of the\n-      --  declaration of the Extended_Index subtype, which includes the values\n-      --  in the base range that immediately precede and immediately follow the\n-      --  values in the Index_Type.)\n-\n-      if Index < Index_Type'First then\n-         raise Constraint_Error with \"Index is out of range (too small)\";\n-      end if;\n-\n-      --  We do allow a value greater than Container.Last to be specified as\n-      --  the Index, but only if it's immediately greater. This allows the\n-      --  corner case of deleting no items from the back end of the vector to\n-      --  be treated as a no-op. (It is assumed that specifying an index value\n-      --  greater than Last + 1 indicates some deeper flaw in the caller's\n-      --  algorithm, so that case is treated as a proper error.)\n-\n-      if Index > Old_Last then\n-         if Index > Old_Last + 1 then\n-            raise Constraint_Error with \"Index is out of range (too large)\";\n-         end if;\n-\n-         return;\n-      end if;\n-\n-      if Count = 0 then\n-         return;\n-      end if;\n-\n-      --  We first calculate what's available for deletion starting at\n-      --  Index. Here and elsewhere we use the wider of Index_Type'Base and\n-      --  Count_Type'Base as the type for intermediate values. (See function\n-      --  Length for more information.)\n-\n-      if Count_Type'Base'Last >= Index_Type'Pos (Index_Type'Base'Last) then\n-         Count2 := Count_Type'Base (Old_Last) - Count_Type'Base (Index) + 1;\n-      else\n-         Count2 := Count_Type'Base (Old_Last - Index + 1);\n-      end if;\n-\n-      --  If more elements are requested (Count) for deletion than are\n-      --  available (Count2) for deletion beginning at Index, then everything\n-      --  from Index is deleted. There are no elements to slide down, and so\n-      --  all we need to do is set the value of Container.Last.\n-\n-      if Count >= Count2 then\n-         Container.Last := Index - 1;\n-         return;\n-      end if;\n-\n-      --  There are some elements that aren't being deleted (the requested\n-      --  count was less than the available count), so we must slide them down\n-      --  to Index. We first calculate the index values of the respective array\n-      --  slices, using the wider of Index_Type'Base and Count_Type'Base as the\n-      --  type for intermediate calculations.\n-\n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n-         Off := Count_Type'Base (Index - Index_Type'First);\n-         New_Last := Old_Last - Index_Type'Base (Count);\n-      else\n-         Off := Count_Type'Base (Index) - Count_Type'Base (Index_Type'First);\n-         New_Last := Index_Type'Base (Count_Type'Base (Old_Last) - Count);\n-      end if;\n-\n-      --  The array index values for each slice have already been determined,\n-      --  so we just slide down to Index the elements that weren't deleted.\n-\n-      declare\n-         EA  : Maximal_Array_Ptr renames Elems (Container);\n-         Idx : constant Count_Type := EA'First + Off;\n-\n-      begin\n-         EA (Idx .. Old_Len - Count) := EA (Idx + Count .. Old_Len);\n-         Container.Last := New_Last;\n-      end;\n-   end Delete;\n-\n-   ------------------\n-   -- Delete_First --\n-   ------------------\n-\n-   procedure Delete_First (Container : in out Vector) is\n-   begin\n-      Delete_First (Container, 1);\n-   end Delete_First;\n-\n-   procedure Delete_First (Container : in out Vector; Count : Count_Type) is\n-   begin\n-      if Count = 0 then\n-         return;\n-\n-      elsif Count >= Length (Container) then\n-         Clear (Container);\n-         return;\n-\n-      else\n-         Delete (Container, Index_Type'First, Count);\n-      end if;\n-   end Delete_First;\n-\n-   -----------------\n-   -- Delete_Last --\n-   -----------------\n-\n-   procedure Delete_Last (Container : in out Vector) is\n-   begin\n-      Delete_Last (Container, 1);\n-   end Delete_Last;\n-\n-   procedure Delete_Last (Container : in out Vector; Count : Count_Type) is\n-   begin\n-      if Count = 0 then\n-         return;\n-      end if;\n-\n-      --  There is no restriction on how large Count can be when deleting\n-      --  items. If it is equal or greater than the current length, then this\n-      --  is equivalent to clearing the vector. (In particular, there's no need\n-      --  for us to actually calculate the new value for Last.)\n-\n-      --  If the requested count is less than the current length, then we must\n-      --  calculate the new value for Last. For the type we use the widest of\n-      --  Index_Type'Base and Count_Type'Base for the intermediate values of\n-      --  our calculation.  (See the comments in Length for more information.)\n-\n-      if Count >= Length (Container) then\n-         Container.Last := No_Index;\n-\n-      elsif Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n-         Container.Last := Container.Last - Index_Type'Base (Count);\n-\n-      else\n-         Container.Last :=\n-           Index_Type'Base (Count_Type'Base (Container.Last) - Count);\n-      end if;\n-   end Delete_Last;\n-\n-   -------------\n-   -- Element --\n-   -------------\n-\n-   function Element\n-     (Container : Vector;\n-      Index     : Extended_Index) return Element_Type\n-   is\n-   begin\n-      if Index > Container.Last then\n-         raise Constraint_Error with \"Index is out of range\";\n-      end if;\n-\n-      declare\n-         II : constant Int'Base := Int (Index) - Int (No_Index);\n-         I  : constant Capacity_Range := Capacity_Range (II);\n-\n-      begin\n-         return Get_Element (Container, I);\n-      end;\n-   end Element;\n-\n-   -----------\n-   -- Elems --\n-   -----------\n-\n-   function Elems (Container : in out Vector) return Maximal_Array_Ptr is\n-   begin\n-      return\n-        (if Container.Elements_Ptr = null then\n-            Container.Elements'Unrestricted_Access\n-         else\n-            Container.Elements_Ptr.all'Unrestricted_Access);\n-   end Elems;\n-\n-   function Elemsc (Container : Vector) return Maximal_Array_Ptr_Const is\n-   begin\n-      return\n-        (if Container.Elements_Ptr = null then\n-            Container.Elements'Unrestricted_Access\n-         else\n-            Container.Elements_Ptr.all'Unrestricted_Access);\n-   end Elemsc;\n-\n-   ----------------\n-   -- Find_Index --\n-   ----------------\n-\n-   function Find_Index\n-     (Container : Vector;\n-      Item      : Element_Type;\n-      Index     : Index_Type := Index_Type'First) return Extended_Index\n-   is\n-      K    : Count_Type;\n-      Last : constant Extended_Index := Last_Index (Container);\n-\n-   begin\n-      K := Capacity_Range (Int (Index) - Int (No_Index));\n-      for Indx in Index .. Last loop\n-         if Get_Element (Container, K) = Item then\n-            return Indx;\n-         end if;\n-\n-         K := K + 1;\n-      end loop;\n-\n-      return No_Index;\n-   end Find_Index;\n-\n-   -------------------\n-   -- First_Element --\n-   -------------------\n-\n-   function First_Element (Container : Vector) return Element_Type is\n-   begin\n-      if Is_Empty (Container) then\n-         raise Constraint_Error with \"Container is empty\";\n-      else\n-         return Get_Element (Container, 1);\n-      end if;\n-   end First_Element;\n-\n-   -----------------\n-   -- First_Index --\n-   -----------------\n-\n-   function First_Index (Container : Vector) return Index_Type is\n-      pragma Unreferenced (Container);\n-   begin\n-      return Index_Type'First;\n-   end First_Index;\n-\n-   ------------------\n-   -- Formal_Model --\n-   ------------------\n-\n-   package body Formal_Model is\n-\n-      -------------------------\n-      -- M_Elements_In_Union --\n-      -------------------------\n-\n-      function M_Elements_In_Union\n-        (Container : M.Sequence;\n-         Left      : M.Sequence;\n-         Right     : M.Sequence) return Boolean\n-      is\n-      begin\n-         for Index in Index_Type'First .. M.Last (Container) loop\n-            declare\n-               Elem : constant Element_Type := Element (Container, Index);\n-            begin\n-               if not M.Contains (Left, Index_Type'First, M.Last (Left), Elem)\n-                 and then\n-                   not M.Contains\n-                     (Right, Index_Type'First, M.Last (Right), Elem)\n-               then\n-                  return False;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end M_Elements_In_Union;\n-\n-      -------------------------\n-      -- M_Elements_Included --\n-      -------------------------\n-\n-      function M_Elements_Included\n-        (Left  : M.Sequence;\n-         L_Fst : Index_Type := Index_Type'First;\n-         L_Lst : Extended_Index;\n-         Right : M.Sequence;\n-         R_Fst : Index_Type := Index_Type'First;\n-         R_Lst : Extended_Index) return Boolean\n-      is\n-      begin\n-         for I in L_Fst .. L_Lst loop\n-            declare\n-               Found : Boolean := False;\n-               J     : Extended_Index := R_Fst - 1;\n-\n-            begin\n-               while not Found and J < R_Lst loop\n-                  J := J + 1;\n-                  if Element (Left, I) = Element (Right, J) then\n-                     Found := True;\n-                  end if;\n-               end loop;\n-\n-               if not Found then\n-                  return False;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end M_Elements_Included;\n-\n-      -------------------------\n-      -- M_Elements_Reversed --\n-      -------------------------\n-\n-      function M_Elements_Reversed\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean\n-      is\n-         L : constant Index_Type := M.Last (Left);\n-\n-      begin\n-         if L /= M.Last (Right) then\n-            return False;\n-         end if;\n-\n-         for I in Index_Type'First .. L loop\n-            if Element (Left, I) /= Element (Right, L - I + 1)\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end M_Elements_Reversed;\n-\n-      ------------------------\n-      -- M_Elements_Swapped --\n-      ------------------------\n-\n-      function M_Elements_Swapped\n-        (Left  : M.Sequence;\n-         Right : M.Sequence;\n-         X     : Index_Type;\n-         Y     : Index_Type) return Boolean\n-      is\n-      begin\n-         if M.Length (Left) /= M.Length (Right)\n-           or else Element (Left, X) /= Element (Right, Y)\n-           or else Element (Left, Y) /= Element (Right, X)\n-         then\n-            return False;\n-         end if;\n-\n-         for I in Index_Type'First .. M.Last (Left) loop\n-            if I /= X and then I /= Y\n-              and then Element (Left, I) /= Element (Right, I)\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end M_Elements_Swapped;\n-\n-      -----------\n-      -- Model --\n-      -----------\n-\n-      function Model (Container : Vector) return M.Sequence is\n-         R : M.Sequence;\n-\n-      begin\n-         for Position in 1 .. Length (Container) loop\n-            R := M.Add (R, E (Elemsc (Container) (Position)));\n-         end loop;\n-\n-         return R;\n-      end Model;\n-\n-   end Formal_Model;\n-\n-   ---------------------\n-   -- Generic_Sorting --\n-   ---------------------\n-\n-   package body Generic_Sorting with SPARK_Mode => Off is\n-\n-      ------------------\n-      -- Formal_Model --\n-      ------------------\n-\n-      package body Formal_Model is\n-\n-         -----------------------\n-         -- M_Elements_Sorted --\n-         -----------------------\n-\n-         function M_Elements_Sorted (Container : M.Sequence) return Boolean is\n-         begin\n-            if M.Length (Container) = 0 then\n-               return True;\n-            end if;\n-\n-            declare\n-               E1 : Element_Type := Element (Container, Index_Type'First);\n-\n-            begin\n-               for I in Index_Type'First + 1 .. M.Last (Container) loop\n-                  declare\n-                     E2 : constant Element_Type := Element (Container, I);\n-\n-                  begin\n-                     if E2 < E1 then\n-                        return False;\n-                     end if;\n-\n-                     E1 := E2;\n-                  end;\n-               end loop;\n-            end;\n-\n-            return True;\n-         end M_Elements_Sorted;\n-\n-      end Formal_Model;\n-\n-      ---------------\n-      -- Is_Sorted --\n-      ---------------\n-\n-      function Is_Sorted (Container : Vector) return Boolean is\n-         L : constant Capacity_Range := Length (Container);\n-\n-      begin\n-         for J in 1 .. L - 1 loop\n-            if Get_Element (Container, J + 1) < Get_Element (Container, J) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end Is_Sorted;\n-\n-      ----------\n-      -- Sort --\n-      ----------\n-\n-      procedure Sort (Container : in out Vector) is\n-         function \"<\" (Left : Holder; Right : Holder) return Boolean is\n-           (E (Left) < E (Right));\n-\n-         procedure Sort is new Generic_Array_Sort\n-           (Index_Type   => Array_Index,\n-            Element_Type => Holder,\n-            Array_Type   => Elements_Array,\n-            \"<\"          => \"<\");\n-\n-         Len : constant Capacity_Range := Length (Container);\n-\n-      begin\n-         if Container.Last <= Index_Type'First then\n-            return;\n-         else\n-            Sort (Elems (Container) (1 .. Len));\n-         end if;\n-      end Sort;\n-\n-      -----------\n-      -- Merge --\n-      -----------\n-\n-      procedure Merge (Target : in out Vector; Source : in out Vector) is\n-         I : Count_Type;\n-         J : Count_Type;\n-\n-      begin\n-         if Target'Address = Source'Address then\n-            raise Program_Error with \"Target and Source denote same container\";\n-         end if;\n-\n-         if Length (Source) = 0 then\n-            return;\n-         end if;\n-\n-         if Length (Target) = 0 then\n-            Move (Target => Target, Source => Source);\n-            return;\n-         end if;\n-\n-         I := Length (Target);\n-\n-         declare\n-            New_Length : constant Count_Type := I + Length (Source);\n-\n-         begin\n-            if not Bounded\n-              and then Current_Capacity (Target) < Capacity_Range (New_Length)\n-            then\n-               Reserve_Capacity\n-                 (Target,\n-                  Capacity_Range'Max\n-                    (Current_Capacity (Target) * Growth_Factor,\n-                     Capacity_Range (New_Length)));\n-            end if;\n-\n-            if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n-               Target.Last := No_Index + Index_Type'Base (New_Length);\n-\n-            else\n-               Target.Last :=\n-                 Index_Type'Base (Count_Type'Base (No_Index) + New_Length);\n-            end if;\n-         end;\n-\n-         declare\n-            TA : Maximal_Array_Ptr renames Elems (Target);\n-            SA : Maximal_Array_Ptr renames Elems (Source);\n-\n-         begin\n-            J := Length (Target);\n-            while Length (Source) /= 0 loop\n-               if I = 0 then\n-                  TA (1 .. J) := SA (1 .. Length (Source));\n-                  Source.Last := No_Index;\n-                  exit;\n-               end if;\n-\n-               if E (SA (Length (Source))) < E (TA (I)) then\n-                  TA (J) := TA (I);\n-                  I := I - 1;\n-\n-               else\n-                  TA (J) := SA (Length (Source));\n-                  Source.Last := Source.Last - 1;\n-               end if;\n-\n-               J := J - 1;\n-            end loop;\n-         end;\n-      end Merge;\n-\n-   end Generic_Sorting;\n-\n-   -----------------\n-   -- Get_Element --\n-   -----------------\n-\n-   function Get_Element\n-     (Container : Vector;\n-      Position  : Capacity_Range) return Element_Type\n-   is\n-   begin\n-      return E (Elemsc (Container) (Position));\n-   end Get_Element;\n-\n-   -----------------\n-   -- Has_Element --\n-   -----------------\n-\n-   function Has_Element\n-     (Container : Vector;\n-      Position  : Extended_Index) return Boolean\n-   is\n-   begin\n-      return Position in First_Index (Container) .. Last_Index (Container);\n-   end Has_Element;\n-\n-   ------------\n-   -- Insert --\n-   ------------\n-\n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Extended_Index;\n-      New_Item  : Element_Type)\n-   is\n-   begin\n-      Insert (Container, Before, New_Item, 1);\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Extended_Index;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   is\n-      J : Count_Type'Base;  -- scratch\n-\n-   begin\n-      --  Use Insert_Space to create the \"hole\" (the destination slice)\n-\n-      Insert_Space (Container, Before, Count);\n-\n-      J := To_Array_Index (Before);\n-\n-      Elems (Container) (J .. J - 1 + Count) := [others => H (New_Item)];\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Extended_Index;\n-      New_Item  : Vector)\n-   is\n-      N : constant Count_Type := Length (New_Item);\n-      B : Count_Type;  -- index Before converted to Count_Type\n-\n-   begin\n-      if Container'Address = New_Item'Address then\n-         raise Program_Error with\n-           \"Container and New_Item denote same container\";\n-      end if;\n-\n-      --  Use Insert_Space to create the \"hole\" (the destination slice) into\n-      --  which we copy the source items.\n-\n-      Insert_Space (Container, Before, Count => N);\n-\n-      if N = 0 then\n-         --  There's nothing else to do here (vetting of parameters was\n-         --  performed already in Insert_Space), so we simply return.\n-\n-         return;\n-      end if;\n-\n-      B := To_Array_Index (Before);\n-\n-      Elems (Container) (B .. B + N - 1) := Elemsc (New_Item) (1 .. N);\n-   end Insert;\n-\n-   ------------------\n-   -- Insert_Space --\n-   ------------------\n-\n-   procedure Insert_Space\n-     (Container : in out Vector;\n-      Before    : Extended_Index;\n-      Count     : Count_Type := 1)\n-   is\n-      Old_Length : constant Count_Type := Length (Container);\n-\n-      Max_Length : Count_Type'Base;  -- determined from range of Index_Type\n-      New_Length : Count_Type'Base;  -- sum of current length and Count\n-\n-      Index : Index_Type'Base;  -- scratch for intermediate values\n-      J     : Count_Type'Base;  -- scratch\n-\n-   begin\n-      --  As a precondition on the generic actual Index_Type, the base type\n-      --  must include Index_Type'Pred (Index_Type'First); this is the value\n-      --  that Container.Last assumes when the vector is empty. However, we do\n-      --  not allow that as the value for Index when specifying where the new\n-      --  items should be inserted, so we must manually check. (That the user\n-      --  is allowed to specify the value at all here is a consequence of the\n-      --  declaration of the Extended_Index subtype, which includes the values\n-      --  in the base range that immediately precede and immediately follow the\n-      --  values in the Index_Type.)\n-\n-      if Before < Index_Type'First then\n-         raise Constraint_Error with\n-           \"Before index is out of range (too small)\";\n-      end if;\n-\n-      --  We do allow a value greater than Container.Last to be specified as\n-      --  the Index, but only if it's immediately greater. This allows for the\n-      --  case of appending items to the back end of the vector. (It is assumed\n-      --  that specifying an index value greater than Last + 1 indicates some\n-      --  deeper flaw in the caller's algorithm, so that case is treated as a\n-      --  proper error.)\n-\n-      if Before > Container.Last\n-        and then Before - 1 > Container.Last\n-      then\n-         raise Constraint_Error with\n-           \"Before index is out of range (too large)\";\n-      end if;\n-\n-      --  We treat inserting 0 items into the container as a no-op, so we\n-      --  simply return.\n-\n-      if Count = 0 then\n-         return;\n-      end if;\n-\n-      --  There are two constraints we need to satisfy. The first constraint is\n-      --  that a container cannot have more than Count_Type'Last elements, so\n-      --  we must check the sum of the current length and the insertion\n-      --  count. Note that we cannot simply add these values, because of the\n-      --  possibility of overflow.\n-\n-      if Old_Length > Count_Type'Last - Count then\n-         raise Constraint_Error with \"Count is out of range\";\n-      end if;\n-\n-      --  It is now safe compute the length of the new vector, without fear of\n-      --  overflow.\n-\n-      New_Length := Old_Length + Count;\n-\n-      --  The second constraint is that the new Last index value cannot exceed\n-      --  Index_Type'Last. In each branch below, we calculate the maximum\n-      --  length (computed from the range of values in Index_Type), and then\n-      --  compare the new length to the maximum length. If the new length is\n-      --  acceptable, then we compute the new last index from that.\n-\n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n-\n-         --  We have to handle the case when there might be more values in the\n-         --  range of Index_Type than in the range of Count_Type.\n-\n-         if Index_Type'First <= 0 then\n-\n-            --  We know that No_Index (the same as Index_Type'First - 1) is\n-            --  less than 0, so it is safe to compute the following sum without\n-            --  fear of overflow.\n-\n-            Index := No_Index + Index_Type'Base (Count_Type'Last);\n-\n-            if Index <= Index_Type'Last then\n-\n-               --  We have determined that range of Index_Type has at least as\n-               --  many values as in Count_Type, so Count_Type'Last is the\n-               --  maximum number of items that are allowed.\n-\n-               Max_Length := Count_Type'Last;\n-\n-            else\n-               --  The range of Index_Type has fewer values than in Count_Type,\n-               --  so the maximum number of items is computed from the range of\n-               --  the Index_Type.\n-\n-               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n-            end if;\n-\n-         else\n-            --  No_Index is equal or greater than 0, so we can safely compute\n-            --  the difference without fear of overflow (which we would have to\n-            --  worry about if No_Index were less than 0, but that case is\n-            --  handled above).\n-\n-            if Index_Type'Last - No_Index >= Count_Type'Pos (Count_Type'Last)\n-            then\n-               --  We have determined that range of Index_Type has at least as\n-               --  many values as in Count_Type, so Count_Type'Last is the\n-               --  maximum number of items that are allowed.\n-\n-               Max_Length := Count_Type'Last;\n-\n-            else\n-               --  The range of Index_Type has fewer values than in Count_Type,\n-               --  so the maximum number of items is computed from the range of\n-               --  the Index_Type.\n-\n-               Max_Length := Count_Type'Base (Index_Type'Last - No_Index);\n-            end if;\n-         end if;\n-\n-      elsif Index_Type'First <= 0 then\n-\n-         --  We know that No_Index (the same as Index_Type'First - 1) is less\n-         --  than 0, so it is safe to compute the following sum without fear of\n-         --  overflow.\n-\n-         J := Count_Type'Base (No_Index) + Count_Type'Last;\n-\n-         if J <= Count_Type'Base (Index_Type'Last) then\n-\n-            --  We have determined that range of Index_Type has at least as\n-            --  many values as in Count_Type, so Count_Type'Last is the maximum\n-            --  number of items that are allowed.\n-\n-            Max_Length := Count_Type'Last;\n-\n-         else\n-            --  The range of Index_Type has fewer values than Count_Type does,\n-            --  so the maximum number of items is computed from the range of\n-            --  the Index_Type.\n-\n-            Max_Length :=\n-              Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);\n-         end if;\n-\n-      else\n-         --  No_Index is equal or greater than 0, so we can safely compute the\n-         --  difference without fear of overflow (which we would have to worry\n-         --  about if No_Index were less than 0, but that case is handled\n-         --  above).\n-\n-         Max_Length :=\n-           Count_Type'Base (Index_Type'Last) - Count_Type'Base (No_Index);\n-      end if;\n-\n-      --  We have just computed the maximum length (number of items). We must\n-      --  now compare the requested length to the maximum length, as we do not\n-      --  allow a vector expand beyond the maximum (because that would create\n-      --  an internal array with a last index value greater than\n-      --  Index_Type'Last, with no way to index those elements).\n-\n-      if New_Length > Max_Length then\n-         raise Constraint_Error with \"Count is out of range\";\n-      end if;\n-\n-      J := To_Array_Index (Before);\n-\n-      --  Increase the capacity of container if needed\n-\n-      if not Bounded\n-        and then Current_Capacity (Container) < Capacity_Range (New_Length)\n-      then\n-         Reserve_Capacity\n-           (Container,\n-            Capacity_Range'Max\n-              (Current_Capacity (Container) * Growth_Factor,\n-               Capacity_Range (New_Length)));\n-      end if;\n-\n-      declare\n-         EA : Maximal_Array_Ptr renames Elems (Container);\n-\n-      begin\n-         if Before <= Container.Last then\n-\n-            --  The new items are being inserted before some existing\n-            --  elements, so we must slide the existing elements up to their\n-            --  new home.\n-\n-            EA (J + Count .. New_Length) := EA (J .. Old_Length);\n-         end if;\n-      end;\n-\n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n-         Container.Last := No_Index + Index_Type'Base (New_Length);\n-\n-      else\n-         Container.Last :=\n-           Index_Type'Base (Count_Type'Base (No_Index) + New_Length);\n-      end if;\n-   end Insert_Space;\n-\n-   --------------\n-   -- Is_Empty --\n-   --------------\n-\n-   function Is_Empty (Container : Vector) return Boolean is\n-   begin\n-      return Last_Index (Container) < Index_Type'First;\n-   end Is_Empty;\n-\n-   ------------------\n-   -- Last_Element --\n-   ------------------\n-\n-   function Last_Element (Container : Vector) return Element_Type is\n-   begin\n-      if Is_Empty (Container) then\n-         raise Constraint_Error with \"Container is empty\";\n-      else\n-         return Get_Element (Container, Length (Container));\n-      end if;\n-   end Last_Element;\n-\n-   ----------------\n-   -- Last_Index --\n-   ----------------\n-\n-   function Last_Index (Container : Vector) return Extended_Index is\n-   begin\n-      return Container.Last;\n-   end Last_Index;\n-\n-   ------------\n-   -- Length --\n-   ------------\n-\n-   function Length (Container : Vector) return Capacity_Range is\n-      L : constant Int := Int (Container.Last);\n-      F : constant Int := Int (Index_Type'First);\n-      N : constant Int'Base := L - F + 1;\n-\n-   begin\n-      return Capacity_Range (N);\n-   end Length;\n-\n-   ----------\n-   -- Move --\n-   ----------\n-\n-   procedure Move (Target : in out Vector; Source : in out Vector) is\n-      LS : constant Capacity_Range := Length (Source);\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n-      if Bounded and then Target.Capacity < LS then\n-         raise Constraint_Error;\n-      end if;\n-\n-      Clear (Target);\n-      Append (Target, Source);\n-      Clear (Source);\n-   end Move;\n-\n-   ------------\n-   -- Prepend --\n-   ------------\n-\n-   procedure Prepend (Container : in out Vector; New_Item : Vector) is\n-   begin\n-      Insert (Container, Index_Type'First, New_Item);\n-   end Prepend;\n-\n-   procedure Prepend (Container : in out Vector; New_Item : Element_Type) is\n-   begin\n-      Prepend (Container, New_Item, 1);\n-   end Prepend;\n-\n-   procedure Prepend\n-     (Container : in out Vector;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   is\n-   begin\n-      Insert (Container, Index_Type'First, New_Item, Count);\n-   end Prepend;\n-\n-   ---------------\n-   -- Reference --\n-   ---------------\n-\n-   function Reference\n-     (Container : not null access Vector;\n-      Index     : Index_Type) return not null access Element_Type\n-   is\n-   begin\n-      if Index > Container.Last then\n-         raise Constraint_Error with \"Index is out of range\";\n-      end if;\n-\n-      declare\n-         II : constant Int'Base := Int (Index) - Int (No_Index);\n-         I  : constant Capacity_Range := Capacity_Range (II);\n-\n-      begin\n-         if Container.Elements_Ptr = null then\n-            return Reference (Container.Elements (I)'Access);\n-         else\n-            return Reference (Container.Elements_Ptr (I)'Access);\n-         end if;\n-      end;\n-   end Reference;\n-\n-   ---------------------\n-   -- Replace_Element --\n-   ---------------------\n-\n-   procedure Replace_Element\n-     (Container : in out Vector;\n-      Index     : Index_Type;\n-      New_Item  : Element_Type)\n-   is\n-   begin\n-      if Index > Container.Last then\n-         raise Constraint_Error with \"Index is out of range\";\n-      end if;\n-\n-      declare\n-         II : constant Int'Base := Int (Index) - Int (No_Index);\n-         I  : constant Capacity_Range := Capacity_Range (II);\n-\n-      begin\n-         Elems (Container) (I) := H (New_Item);\n-      end;\n-   end Replace_Element;\n-\n-   ----------------------\n-   -- Reserve_Capacity --\n-   ----------------------\n-\n-   procedure Reserve_Capacity\n-     (Container : in out Vector;\n-      Capacity  : Capacity_Range)\n-   is\n-   begin\n-      if Bounded then\n-         if Capacity > Container.Capacity then\n-            raise Constraint_Error with \"Capacity is out of range\";\n-         end if;\n-\n-      else\n-         if Capacity > Current_Capacity (Container) then\n-            declare\n-               New_Elements : constant Elements_Array_Ptr :=\n-                                new Elements_Array (1 .. Capacity);\n-               L            : constant Capacity_Range := Length (Container);\n-\n-            begin\n-               New_Elements (1 .. L) := Elemsc (Container) (1 .. L);\n-               Free (Container.Elements_Ptr);\n-               Container.Elements_Ptr := New_Elements;\n-            end;\n-         end if;\n-      end if;\n-   end Reserve_Capacity;\n-\n-   ----------------------\n-   -- Reverse_Elements --\n-   ----------------------\n-\n-   procedure Reverse_Elements (Container : in out Vector) is\n-   begin\n-      if Length (Container) <= 1 then\n-         return;\n-      end if;\n-\n-      declare\n-         I : Capacity_Range;\n-         J : Capacity_Range;\n-         E : Elements_Array renames\n-               Elems (Container) (1 .. Length (Container));\n-\n-      begin\n-         I := 1;\n-         J := Length (Container);\n-         while I < J loop\n-            declare\n-               EI : constant Holder := E (I);\n-\n-            begin\n-               E (I) := E (J);\n-               E (J) := EI;\n-            end;\n-\n-            I := I + 1;\n-            J := J - 1;\n-         end loop;\n-      end;\n-   end Reverse_Elements;\n-\n-   ------------------------\n-   -- Reverse_Find_Index --\n-   ------------------------\n-\n-   function Reverse_Find_Index\n-     (Container : Vector;\n-      Item      : Element_Type;\n-      Index     : Index_Type := Index_Type'Last) return Extended_Index\n-   is\n-      Last : Index_Type'Base;\n-      K    : Count_Type'Base;\n-\n-   begin\n-      if Index > Last_Index (Container) then\n-         Last := Last_Index (Container);\n-      else\n-         Last := Index;\n-      end if;\n-\n-      K := Capacity_Range (Int (Last) - Int (No_Index));\n-      for Indx in reverse Index_Type'First .. Last loop\n-         if Get_Element (Container, K) = Item then\n-            return Indx;\n-         end if;\n-\n-         K := K - 1;\n-      end loop;\n-\n-      return No_Index;\n-   end Reverse_Find_Index;\n-\n-   ----------\n-   -- Swap --\n-   ----------\n-\n-   procedure Swap\n-     (Container : in out Vector;\n-      I         : Index_Type;\n-      J         : Index_Type)\n-   is\n-   begin\n-      if I > Container.Last then\n-         raise Constraint_Error with \"I index is out of range\";\n-      end if;\n-\n-      if J > Container.Last then\n-         raise Constraint_Error with \"J index is out of range\";\n-      end if;\n-\n-      if I = J then\n-         return;\n-      end if;\n-\n-      declare\n-         II : constant Int'Base := Int (I) - Int (No_Index);\n-         JJ : constant Int'Base := Int (J) - Int (No_Index);\n-\n-         EI : Holder renames Elems (Container) (Capacity_Range (II));\n-         EJ : Holder renames Elems (Container) (Capacity_Range (JJ));\n-\n-         EI_Copy : constant Holder := EI;\n-\n-      begin\n-         EI := EJ;\n-         EJ := EI_Copy;\n-      end;\n-   end Swap;\n-\n-   --------------------\n-   -- To_Array_Index --\n-   --------------------\n-\n-   function To_Array_Index (Index : Index_Type'Base) return Count_Type'Base is\n-      Offset : Count_Type'Base;\n-\n-   begin\n-      --  We know that\n-      --    Index >= Index_Type'First\n-      --  hence we also know that\n-      --    Index - Index_Type'First >= 0\n-\n-      --  The issue is that even though 0 is guaranteed to be a value in the\n-      --  type Index_Type'Base, there's no guarantee that the difference is a\n-      --  value in that type. To prevent overflow we use the wider of\n-      --  Count_Type'Base and Index_Type'Base to perform intermediate\n-      --  calculations.\n-\n-      if Index_Type'Base'Last >= Count_Type'Pos (Count_Type'Last) then\n-         Offset := Count_Type'Base (Index - Index_Type'First);\n-\n-      else\n-         Offset := Count_Type'Base (Index) -\n-                     Count_Type'Base (Index_Type'First);\n-      end if;\n-\n-      --  The array index subtype for all container element arrays always\n-      --  starts with 1.\n-\n-      return 1 + Offset;\n-   end To_Array_Index;\n-\n-   ---------------\n-   -- To_Vector --\n-   ---------------\n-\n-   function To_Vector\n-     (New_Item : Element_Type;\n-      Length   : Capacity_Range) return Vector\n-   is\n-   begin\n-      if Length = 0 then\n-         return Empty_Vector;\n-      end if;\n-\n-      declare\n-         First       : constant Int := Int (Index_Type'First);\n-         Last_As_Int : constant Int'Base := First + Int (Length) - 1;\n-         Last        : Index_Type;\n-\n-      begin\n-         if Last_As_Int > Index_Type'Pos (Index_Type'Last) then\n-            raise Constraint_Error with \"Length is out of range\";  -- ???\n-         end if;\n-\n-         Last := Index_Type (Last_As_Int);\n-\n-         return\n-           (Capacity     => Length,\n-            Last         => Last,\n-            Elements_Ptr => <>,\n-            Elements     => [others => H (New_Item)]);\n-      end;\n-   end To_Vector;\n-\n-end Ada.Containers.Formal_Indefinite_Vectors;"}, {"sha": "dcec6ba3cd5b9442443d174042f88e56c555eb90", "filename": "gcc/ada/libgnat/a-cfinve.ads", "status": "modified", "additions": 5, "deletions": 952, "changes": 957, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cfinve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cfinve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cfinve.ads?ref=4a7312f7ce189783a2cb5318bdcf50e8148b909d", "patch": "@@ -29,959 +29,12 @@\n -- <http://www.gnu.org/licenses/>.                                          --\n ------------------------------------------------------------------------------\n \n---  Similar to Ada.Containers.Formal_Vectors. The main difference is that\n---  Element_Type may be indefinite (but not an unconstrained array).\n-\n-with Ada.Containers.Bounded_Holders;\n-with Ada.Containers.Functional_Vectors;\n-\n generic\n-   type Index_Type is range <>;\n-   type Element_Type (<>) is private;\n-   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n-   Max_Size_In_Storage_Elements : Natural;\n-   --  Maximum size of Vector elements in bytes. This has the same meaning as\n-   --  in Ada.Containers.Bounded_Holders, with the same restrictions. Note that\n-   --  setting this too small can lead to erroneous execution; see comments in\n-   --  Ada.Containers.Bounded_Holders. If Element_Type is class-wide, it is the\n-   --  responsibility of clients to calculate the maximum size of all types in\n-   --  the class.\n-\n-   Bounded : Boolean := True;\n-   --  If True, the containers are bounded; the initial capacity is the maximum\n-   --  size, and heap allocation will be avoided. If False, the containers can\n-   --  grow via heap allocation.\n-\n-package Ada.Containers.Formal_Indefinite_Vectors with\n-  SPARK_Mode,\n-  Annotate => (GNATprove, Always_Return)\n-is\n-\n-   --  Contracts in this unit are meant for analysis only, not for run-time\n-   --  checking.\n-\n-   pragma Assertion_Policy (Pre => Ignore);\n-   pragma Assertion_Policy (Post => Ignore);\n-   pragma Assertion_Policy (Contract_Cases => Ignore);\n-   pragma Annotate (CodePeer, Skip_Analysis);\n-\n-   subtype Extended_Index is Index_Type'Base\n-     range Index_Type'First - 1 ..\n-           Index_Type'Min (Index_Type'Base'Last - 1, Index_Type'Last) + 1;\n-\n-   No_Index : constant Extended_Index := Extended_Index'First;\n-\n-   Last_Count : constant Count_Type :=\n-     (if Index_Type'Last < Index_Type'First then\n-         0\n-      elsif Index_Type'Last < -1\n-        or else Index_Type'Pos (Index_Type'First) >\n-                Index_Type'Pos (Index_Type'Last) - Count_Type'Last\n-      then\n-         Index_Type'Pos (Index_Type'Last) -\n-           Index_Type'Pos (Index_Type'First) + 1\n-      else\n-         Count_Type'Last);\n-   --  Maximal capacity of any vector. It is the minimum of the size of the\n-   --  index range and the last possible Count_Type.\n-\n-   subtype Capacity_Range is Count_Type range 0 .. Last_Count;\n-\n-   type Vector (Capacity : Capacity_Range) is limited private with\n-     Default_Initial_Condition => Is_Empty (Vector);\n-   --  In the bounded case, Capacity is the capacity of the container, which\n-   --  never changes. In the unbounded case, Capacity is the initial capacity\n-   --  of the container, and operations such as Reserve_Capacity and Append can\n-   --  increase the capacity. The capacity never shrinks, except in the case of\n-   --  Clear.\n-   --\n-   --  Note that all objects of type Vector are constrained, including in the\n-   --  unbounded case; you can't assign from one object to another if the\n-   --  Capacity is different.\n-\n-   function Length (Container : Vector) return Capacity_Range with\n-     Global => null,\n-     Post   => Length'Result <= Capacity (Container);\n-\n-   pragma Unevaluated_Use_Of_Old (Allow);\n-\n-   package Formal_Model with Ghost is\n-\n-      package M is new Ada.Containers.Functional_Vectors\n-        (Index_Type   => Index_Type,\n-         Element_Type => Element_Type);\n-\n-      function \"=\"\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean renames M.\"=\";\n-\n-      function \"<\"\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean renames M.\"<\";\n-\n-      function \"<=\"\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean renames M.\"<=\";\n-\n-      function M_Elements_In_Union\n-        (Container : M.Sequence;\n-         Left      : M.Sequence;\n-         Right     : M.Sequence) return Boolean\n-      --  The elements of Container are contained in either Left or Right\n-      with\n-        Global => null,\n-        Post   =>\n-          M_Elements_In_Union'Result =\n-            (for all I in Index_Type'First .. M.Last (Container) =>\n-              (for some J in Index_Type'First .. M.Last (Left) =>\n-                Element (Container, I) = Element (Left, J))\n-                  or (for some J in Index_Type'First .. M.Last (Right) =>\n-                       Element (Container, I) = Element (Right, J)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_In_Union);\n-\n-      function M_Elements_Included\n-        (Left  : M.Sequence;\n-         L_Fst : Index_Type := Index_Type'First;\n-         L_Lst : Extended_Index;\n-         Right : M.Sequence;\n-         R_Fst : Index_Type := Index_Type'First;\n-         R_Lst : Extended_Index) return Boolean\n-      --  The elements of the slice from L_Fst to L_Lst in Left are contained\n-      --  in the slide from R_Fst to R_Lst in Right.\n-      with\n-        Global => null,\n-        Pre    => L_Lst <= M.Last (Left) and R_Lst <= M.Last (Right),\n-        Post   =>\n-          M_Elements_Included'Result =\n-            (for all I in L_Fst .. L_Lst =>\n-              (for some J in R_Fst .. R_Lst =>\n-                Element (Left, I) = Element (Right, J)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Included);\n-\n-      function M_Elements_Reversed\n-        (Left  : M.Sequence;\n-         Right : M.Sequence) return Boolean\n-      --  Right is Left in reverse order\n-      with\n-        Global => null,\n-        Post   =>\n-          M_Elements_Reversed'Result =\n-            (M.Length (Left) = M.Length (Right)\n-              and (for all I in Index_Type'First .. M.Last (Left) =>\n-                    Element (Left, I) =\n-                      Element (Right, M.Last (Left) - I + 1))\n-              and (for all I in Index_Type'First .. M.Last (Right) =>\n-                    Element (Right, I) =\n-                      Element (Left, M.Last (Left) - I + 1)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Reversed);\n-\n-      function M_Elements_Swapped\n-        (Left  : M.Sequence;\n-         Right : M.Sequence;\n-         X     : Index_Type;\n-         Y     : Index_Type) return Boolean\n-      --  Elements stored at X and Y are reversed in Left and Right\n-      with\n-        Global => null,\n-        Pre    => X <= M.Last (Left) and Y <= M.Last (Left),\n-        Post   =>\n-          M_Elements_Swapped'Result =\n-            (M.Length (Left) = M.Length (Right)\n-              and Element (Left, X) = Element (Right, Y)\n-              and Element (Left, Y) = Element (Right, X)\n-              and M.Equal_Except (Left, Right, X, Y));\n-      pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Swapped);\n-\n-      function Model (Container : Vector) return M.Sequence with\n-      --  The high-level model of a vector is a sequence of elements. The\n-      --  sequence really is similar to the vector itself. However, it is not\n-      --  limited which allows usage of 'Old and 'Loop_Entry attributes.\n-\n-        Ghost,\n-        Global => null,\n-        Post   => M.Length (Model'Result) = Length (Container);\n-\n-      function Element\n-        (S : M.Sequence;\n-         I : Index_Type) return Element_Type renames M.Get;\n-      --  To improve readability of contracts, we rename the function used to\n-      --  access an element in the model to Element.\n-\n-   end Formal_Model;\n-   use Formal_Model;\n-\n-   function Empty_Vector return Vector with\n-     Global => null,\n-     Post   => Length (Empty_Vector'Result) = 0;\n-\n-   function \"=\" (Left, Right : Vector) return Boolean with\n-     Global => null,\n-     Post   => \"=\"'Result = (Model (Left) = Model (Right));\n-\n-   function To_Vector\n-     (New_Item : Element_Type;\n-      Length   : Capacity_Range) return Vector\n-   with\n-     Global => null,\n-     Post   =>\n-       Formal_Indefinite_Vectors.Length (To_Vector'Result) = Length\n-         and M.Constant_Range\n-               (Container => Model (To_Vector'Result),\n-                Fst       => Index_Type'First,\n-                Lst       => Last_Index (To_Vector'Result),\n-                Item      => New_Item);\n-\n-   function Capacity (Container : Vector) return Capacity_Range with\n-     Global => null,\n-     Post   =>\n-       Capacity'Result =\n-         (if Bounded then\n-             Container.Capacity\n-          else\n-             Capacity_Range'Last);\n-   pragma Annotate (GNATprove, Inline_For_Proof, Capacity);\n-\n-   procedure Reserve_Capacity\n-     (Container : in out Vector;\n-      Capacity  : Capacity_Range)\n-   with\n-     Global => null,\n-     Pre    => (if Bounded then Capacity <= Container.Capacity),\n-     Post   => Model (Container) = Model (Container)'Old;\n-\n-   function Is_Empty (Container : Vector) return Boolean with\n-     Global => null,\n-     Post   => Is_Empty'Result = (Length (Container) = 0);\n-\n-   procedure Clear (Container : in out Vector) with\n-     Global => null,\n-     Post   => Length (Container) = 0;\n-   --  Note that this reclaims storage in the unbounded case. You need to call\n-   --  this before a container goes out of scope in order to avoid storage\n-   --  leaks. In addition, \"X := ...\" can leak unless you Clear(X) first.\n-\n-   procedure Assign (Target : in out Vector; Source : Vector) with\n-     Global => null,\n-     Pre    => (if Bounded then Length (Source) <= Target.Capacity),\n-     Post   => Model (Target) = Model (Source);\n-\n-   function Copy\n-     (Source   : Vector;\n-      Capacity : Capacity_Range := 0) return Vector\n-   with\n-     Global => null,\n-     Pre    => (if Bounded then (Capacity = 0 or Length (Source) <= Capacity)),\n-     Post   =>\n-       Model (Copy'Result) = Model (Source)\n-         and (if Capacity = 0 then\n-                 Copy'Result.Capacity = Length (Source)\n-              else\n-                 Copy'Result.Capacity = Capacity);\n-\n-   procedure Move (Target : in out Vector; Source : in out Vector)\n-   with\n-     Global => null,\n-     Pre    => (if Bounded then Length (Source) <= Capacity (Target)),\n-     Post   => Model (Target) = Model (Source)'Old and Length (Source) = 0;\n-\n-   function Element\n-     (Container : Vector;\n-      Index     : Extended_Index) return Element_Type\n-   with\n-     Global => null,\n-     Pre    => Index in First_Index (Container) .. Last_Index (Container),\n-     Post   => Element'Result = Element (Model (Container), Index);\n-   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n-\n-   procedure Replace_Element\n-     (Container : in out Vector;\n-      Index     : Index_Type;\n-      New_Item  : Element_Type)\n-   with\n-     Global => null,\n-     Pre    => Index in First_Index (Container) .. Last_Index (Container),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old\n-\n-         --  Container now has New_Item at index Index\n-\n-         and Element (Model (Container), Index) = New_Item\n-\n-         --  All other elements are preserved\n-\n-         and M.Equal_Except\n-               (Left     => Model (Container)'Old,\n-                Right    => Model (Container),\n-                Position => Index);\n-\n-   function At_End (E : access constant Vector) return access constant Vector\n-   is (E)\n-   with Ghost,\n-     Annotate => (GNATprove, At_End_Borrow);\n-\n-   function At_End\n-     (E : access constant Element_Type) return access constant Element_Type\n-   is (E)\n-   with Ghost,\n-     Annotate => (GNATprove, At_End_Borrow);\n-\n-   function Constant_Reference\n-     (Container : aliased Vector;\n-      Index     : Index_Type) return not null access constant Element_Type\n-   with\n-     Global => null,\n-     Pre    => Index in First_Index (Container) .. Last_Index (Container),\n-     Post   =>\n-         Constant_Reference'Result.all = Element (Model (Container), Index);\n-\n-   function Reference\n-     (Container : not null access Vector;\n-      Index     : Index_Type) return not null access Element_Type\n-   with\n-     Global => null,\n-     Pre    =>\n-      Index in First_Index (Container.all) .. Last_Index (Container.all),\n-     Post   =>\n-      Length (Container.all) = Length (At_End (Container).all)\n-\n-         --  Container will have Result.all at index Index\n-\n-         and At_End (Reference'Result).all =\n-           Element (Model (At_End (Container).all), Index)\n-\n-         --  All other elements are preserved\n-\n-         and M.Equal_Except\n-               (Left     => Model (Container.all),\n-                Right    => Model (At_End (Container).all),\n-                Position => Index);\n-\n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Extended_Index;\n-      New_Item  : Vector)\n-   with\n-     Global => null,\n-     Pre    =>\n-       Length (Container) <= Capacity (Container) - Length (New_Item)\n-         and (Before in Index_Type'First .. Last_Index (Container)\n-               or (Before /= No_Index\n-                    and then Before - 1 = Last_Index (Container))),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + Length (New_Item)\n-\n-         --  Elements located before Before in Container are preserved\n-\n-         and M.Range_Equal\n-               (Left  => Model (Container)'Old,\n-                Right => Model (Container),\n-                Fst   => Index_Type'First,\n-                Lst   => Before - 1)\n-\n-         --  Elements of New_Item are inserted at position Before\n-\n-         and (if Length (New_Item) > 0 then\n-                 M.Range_Shifted\n-                   (Left   => Model (New_Item),\n-                     Right  => Model (Container),\n-                     Fst    => Index_Type'First,\n-                     Lst    => Last_Index (New_Item),\n-                     Offset => Count_Type (Before - Index_Type'First)))\n-\n-         --  Elements located after Before in Container are shifted\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Container)'Old,\n-                Right  => Model (Container),\n-                Fst    => Before,\n-                Lst    => Last_Index (Container)'Old,\n-                Offset => Length (New_Item));\n-\n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Extended_Index;\n-      New_Item  : Element_Type)\n-   with\n-     Global => null,\n-     Pre    =>\n-       Length (Container) < Capacity (Container)\n-         and then (Before in Index_Type'First .. Last_Index (Container) + 1),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + 1\n-\n-         --  Elements located before Before in Container are preserved\n-\n-         and M.Range_Equal\n-               (Left  => Model (Container)'Old,\n-                Right => Model (Container),\n-                Fst   => Index_Type'First,\n-                Lst   => Before - 1)\n-\n-         --  Container now has New_Item at index Before\n-\n-         and Element (Model (Container), Before) = New_Item\n-\n-         --  Elements located after Before in Container are shifted by 1\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Container)'Old,\n-                Right  => Model (Container),\n-                Fst    => Before,\n-                Lst    => Last_Index (Container)'Old,\n-                Offset => 1);\n-\n-   procedure Insert\n-     (Container : in out Vector;\n-      Before    : Extended_Index;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   with\n-     Global => null,\n-     Pre    =>\n-       Length (Container) <= Capacity (Container) - Count\n-         and (Before in Index_Type'First .. Last_Index (Container)\n-               or (Before /= No_Index\n-                    and then Before - 1 = Last_Index (Container))),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + Count\n-\n-         --  Elements located before Before in Container are preserved\n-\n-         and M.Range_Equal\n-               (Left  => Model (Container)'Old,\n-                Right => Model (Container),\n-                Fst   => Index_Type'First,\n-                Lst   => Before - 1)\n-\n-         --  New_Item is inserted Count times at position Before\n-\n-         and (if Count > 0 then\n-                 M.Constant_Range\n-                   (Container => Model (Container),\n-                     Fst       => Before,\n-                     Lst       => Before + Index_Type'Base (Count - 1),\n-                     Item      => New_Item))\n-\n-         --  Elements located after Before in Container are shifted\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Container)'Old,\n-                Right  => Model (Container),\n-                Fst    => Before,\n-                Lst    => Last_Index (Container)'Old,\n-                Offset => Count);\n-\n-   procedure Prepend (Container : in out Vector; New_Item : Vector) with\n-     Global => null,\n-     Pre    => Length (Container) <= Capacity (Container) - Length (New_Item),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + Length (New_Item)\n-\n-         --  Elements of New_Item are inserted at the beginning of Container\n-\n-         and M.Range_Equal\n-               (Left  => Model (New_Item),\n-                Right => Model (Container),\n-                Fst   => Index_Type'First,\n-                Lst   => Last_Index (New_Item))\n-\n-         --  Elements of Container are shifted\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Container)'Old,\n-                Right  => Model (Container),\n-                Fst    => Index_Type'First,\n-                Lst    => Last_Index (Container)'Old,\n-                Offset => Length (New_Item));\n-\n-   procedure Prepend (Container : in out Vector; New_Item : Element_Type) with\n-     Global => null,\n-     Pre    => Length (Container) < Capacity (Container),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + 1\n-\n-         --  Container now has New_Item at Index_Type'First\n-\n-         and Element (Model (Container), Index_Type'First) = New_Item\n-\n-         --  Elements of Container are shifted by 1\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Container)'Old,\n-                Right  => Model (Container),\n-                Fst    => Index_Type'First,\n-                Lst    => Last_Index (Container)'Old,\n-                Offset => 1);\n-\n-   procedure Prepend\n-     (Container : in out Vector;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   with\n-     Global => null,\n-     Pre    => Length (Container) <= Capacity (Container) - Count,\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + Count\n-\n-         --  New_Item is inserted Count times at the beginning of Container\n-\n-         and M.Constant_Range\n-               (Container => Model (Container),\n-                Fst       => Index_Type'First,\n-                Lst       => Index_Type'First + Index_Type'Base (Count - 1),\n-                Item      => New_Item)\n-\n-         --  Elements of Container are shifted\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Container)'Old,\n-                Right  => Model (Container),\n-                Fst    => Index_Type'First,\n-                Lst    => Last_Index (Container)'Old,\n-                Offset => Count);\n-\n-   procedure Append (Container : in out Vector; New_Item : Vector) with\n-     Global         => null,\n-     Pre            =>\n-       Length (Container) <= Capacity (Container) - Length (New_Item),\n-     Post           =>\n-       Length (Container) = Length (Container)'Old + Length (New_Item)\n-\n-         --  The elements of Container are preserved\n-\n-         and Model (Container)'Old <= Model (Container)\n-\n-         --  Elements of New_Item are inserted at the end of Container\n-\n-         and (if Length (New_Item) > 0 then\n-                 M.Range_Shifted\n-                   (Left   => Model (New_Item),\n-                    Right  => Model (Container),\n-                    Fst    => Index_Type'First,\n-                    Lst    => Last_Index (New_Item),\n-                    Offset =>\n-                      Count_Type\n-                        (Last_Index (Container)'Old - Index_Type'First + 1)));\n-\n-   procedure Append (Container : in out Vector; New_Item : Element_Type) with\n-     Global => null,\n-     Pre    => Length (Container) < Capacity (Container),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + 1\n-\n-         --  Elements of Container are preserved\n-\n-         and Model (Container)'Old < Model (Container)\n-\n-         --  Container now has New_Item at the end of Container\n-\n-         and Element\n-               (Model (Container), Last_Index (Container)'Old + 1) = New_Item;\n-\n-   procedure Append\n-     (Container : in out Vector;\n-      New_Item  : Element_Type;\n-      Count     : Count_Type)\n-   with\n-     Global => null,\n-     Pre    => Length (Container) <= Capacity (Container) - Count,\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + Count\n-\n-         --  Elements of Container are preserved\n-\n-         and Model (Container)'Old <= Model (Container)\n-\n-         --  New_Item is inserted Count times at the end of Container\n-\n-         and (if Count > 0 then\n-                 M.Constant_Range\n-                   (Container => Model (Container),\n-                     Fst       => Last_Index (Container)'Old + 1,\n-                     Lst       =>\n-                       Last_Index (Container)'Old + Index_Type'Base (Count),\n-                     Item      => New_Item));\n-\n-   procedure Delete (Container : in out Vector; Index : Extended_Index) with\n-     Global => null,\n-     Pre    => Index in First_Index (Container) .. Last_Index (Container),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old - 1\n-\n-         --  Elements located before Index in Container are preserved\n-\n-         and M.Range_Equal\n-               (Left  => Model (Container)'Old,\n-                Right => Model (Container),\n-                Fst   => Index_Type'First,\n-                Lst   => Index - 1)\n-\n-         --  Elements located after Index in Container are shifted by 1\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Container),\n-                Right  => Model (Container)'Old,\n-                Fst    => Index,\n-                Lst    => Last_Index (Container),\n-                Offset => 1);\n-\n-   procedure Delete\n-     (Container : in out Vector;\n-      Index     : Extended_Index;\n-      Count     : Count_Type)\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Index in First_Index (Container) .. Last_Index (Container),\n-     Post           =>\n-       Length (Container) in\n-         Length (Container)'Old - Count .. Length (Container)'Old\n-\n-         --  The elements of Container located before Index are preserved.\n-\n-         and M.Range_Equal\n-               (Left  => Model (Container)'Old,\n-                Right => Model (Container),\n-                Fst   => Index_Type'First,\n-                Lst   => Index - 1),\n-\n-     Contract_Cases =>\n-\n-       --  All the elements after Position have been erased\n-\n-       (Length (Container) - Count <= Count_Type (Index - Index_Type'First) =>\n-          Length (Container) = Count_Type (Index - Index_Type'First),\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old - Count\n-\n-            --  Other elements are shifted by Count\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container),\n-                   Right  => Model (Container)'Old,\n-                   Fst    => Index,\n-                   Lst    => Last_Index (Container),\n-                   Offset => Count));\n-\n-   procedure Delete_First (Container : in out Vector) with\n-     Global => null,\n-     Pre    => Length (Container) > 0,\n-     Post   =>\n-       Length (Container) = Length (Container)'Old - 1\n-\n-         --  Elements of Container are shifted by 1\n-\n-         and M.Range_Shifted\n-               (Left   => Model (Container),\n-                Right  => Model (Container)'Old,\n-                Fst    => Index_Type'First,\n-                Lst    => Last_Index (Container),\n-                Offset => 1);\n-\n-   procedure Delete_First (Container : in out Vector; Count : Count_Type) with\n-     Global         => null,\n-     Contract_Cases =>\n-\n-       --  All the elements of Container have been erased\n-\n-       (Length (Container) <= Count => Length (Container) = 0,\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old - Count\n-\n-            --  Elements of Container are shifted by Count\n-\n-            and M.Range_Shifted\n-                  (Left   => Model (Container),\n-                   Right  => Model (Container)'Old,\n-                   Fst    => Index_Type'First,\n-                   Lst    => Last_Index (Container),\n-                   Offset => Count));\n-\n-   procedure Delete_Last (Container : in out Vector) with\n-     Global => null,\n-     Pre    => Length (Container) > 0,\n-     Post   =>\n-       Length (Container) = Length (Container)'Old - 1\n-\n-         --  Elements of Container are preserved\n-\n-         and Model (Container) < Model (Container)'Old;\n-\n-   procedure Delete_Last (Container : in out Vector; Count : Count_Type) with\n-     Global         => null,\n-     Contract_Cases =>\n-\n-       --  All the elements after Position have been erased\n-\n-       (Length (Container) <= Count => Length (Container) = 0,\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old - Count\n-\n-            --  The elements of Container are preserved\n-\n-            and Model (Container) <= Model (Container)'Old);\n-\n-   procedure Reverse_Elements (Container : in out Vector) with\n-     Global => null,\n-     Post   => M_Elements_Reversed (Model (Container)'Old, Model (Container));\n-\n-   procedure Swap\n-     (Container : in out Vector;\n-      I         : Index_Type;\n-      J         : Index_Type)\n-   with\n-     Global => null,\n-     Pre    =>\n-       I in First_Index (Container) .. Last_Index (Container)\n-         and then J in First_Index (Container) .. Last_Index (Container),\n-     Post   =>\n-       M_Elements_Swapped (Model (Container)'Old, Model (Container), I, J);\n-\n-   function First_Index (Container : Vector) return Index_Type with\n-     Global => null,\n-     Post   => First_Index'Result = Index_Type'First;\n-   pragma Annotate (GNATprove, Inline_For_Proof, First_Index);\n-\n-   function First_Element (Container : Vector) return Element_Type with\n-     Global => null,\n-     Pre    => not Is_Empty (Container),\n-     Post   =>\n-       First_Element'Result = Element (Model (Container), Index_Type'First);\n-   pragma Annotate (GNATprove, Inline_For_Proof, First_Element);\n-\n-   function Last_Index (Container : Vector) return Extended_Index with\n-     Global => null,\n-     Post   => Last_Index'Result = M.Last (Model (Container));\n-   pragma Annotate (GNATprove, Inline_For_Proof, Last_Index);\n-\n-   function Last_Element (Container : Vector) return Element_Type with\n-     Global => null,\n-     Pre    => not Is_Empty (Container),\n-     Post   =>\n-       Last_Element'Result =\n-         Element (Model (Container), Last_Index (Container));\n-   pragma Annotate (GNATprove, Inline_For_Proof, Last_Element);\n-\n-   function Find_Index\n-     (Container : Vector;\n-      Item      : Element_Type;\n-      Index     : Index_Type := Index_Type'First) return Extended_Index\n-   with\n-     Global         => null,\n-     Contract_Cases =>\n-\n-       --  If Item is not contained in Container after Index, Find_Index\n-       --  returns No_Index.\n-\n-       (Index > Last_Index (Container)\n-         or else not M.Contains\n-                       (Container => Model (Container),\n-                        Fst       => Index,\n-                        Lst       => Last_Index (Container),\n-                        Item      => Item)\n-        =>\n-          Find_Index'Result = No_Index,\n-\n-        --  Otherwise, Find_Index returns a valid index greater than Index\n-\n-        others =>\n-           Find_Index'Result in Index .. Last_Index (Container)\n-\n-            --  The element at this index in Container is Item\n-\n-            and Element (Model (Container), Find_Index'Result) = Item\n-\n-            --  It is the first occurrence of Item after Index in Container\n-\n-            and not M.Contains\n-                      (Container => Model (Container),\n-                       Fst       => Index,\n-                       Lst       => Find_Index'Result - 1,\n-                       Item      => Item));\n-\n-   function Reverse_Find_Index\n-     (Container : Vector;\n-      Item      : Element_Type;\n-      Index     : Index_Type := Index_Type'Last) return Extended_Index\n-   with\n-     Global         => null,\n-     Contract_Cases =>\n-\n-       --  If Item is not contained in Container before Index,\n-       --  Reverse_Find_Index returns No_Index.\n-\n-       (not M.Contains\n-              (Container => Model (Container),\n-               Fst       => Index_Type'First,\n-               Lst       => (if Index <= Last_Index (Container) then Index\n-                             else Last_Index (Container)),\n-               Item      => Item)\n-        =>\n-          Reverse_Find_Index'Result = No_Index,\n-\n-        --  Otherwise, Reverse_Find_Index returns a valid index smaller than\n-        --  Index\n-\n-        others =>\n-           Reverse_Find_Index'Result in Index_Type'First .. Index\n-            and Reverse_Find_Index'Result <= Last_Index (Container)\n-\n-            --  The element at this index in Container is Item\n-\n-            and Element (Model (Container), Reverse_Find_Index'Result) = Item\n-\n-            --  It is the last occurrence of Item before Index in Container\n-\n-            and not M.Contains\n-                      (Container => Model (Container),\n-                       Fst       => Reverse_Find_Index'Result + 1,\n-                       Lst       =>\n-                         (if Index <= Last_Index (Container) then\n-                             Index\n-                          else\n-                             Last_Index (Container)),\n-                       Item      => Item));\n-\n-   function Contains\n-     (Container : Vector;\n-      Item      : Element_Type) return Boolean\n-   with\n-     Global => null,\n-     Post   =>\n-       Contains'Result =\n-         M.Contains\n-           (Container => Model (Container),\n-            Fst       => Index_Type'First,\n-            Lst       => Last_Index (Container),\n-            Item      => Item);\n-\n-   function Has_Element\n-     (Container : Vector;\n-      Position  : Extended_Index) return Boolean\n-   with\n-     Global => null,\n-     Post   =>\n-       Has_Element'Result =\n-         (Position in Index_Type'First .. Last_Index (Container));\n-   pragma Annotate (GNATprove, Inline_For_Proof, Has_Element);\n-\n-   generic\n-      with function \"<\" (Left, Right : Element_Type) return Boolean is <>;\n-   package Generic_Sorting with SPARK_Mode is\n-\n-      package Formal_Model with Ghost is\n-\n-         function M_Elements_Sorted (Container : M.Sequence) return Boolean\n-         with\n-           Global => null,\n-           Post   =>\n-             M_Elements_Sorted'Result =\n-               (for all I in Index_Type'First .. M.Last (Container) =>\n-                 (for all J in I .. M.Last (Container) =>\n-                   Element (Container, I) = Element (Container, J)\n-                     or Element (Container, I) < Element (Container, J)));\n-         pragma Annotate (GNATprove, Inline_For_Proof, M_Elements_Sorted);\n-\n-      end Formal_Model;\n-      use Formal_Model;\n-\n-      function Is_Sorted (Container : Vector) return Boolean with\n-        Global => null,\n-        Post   => Is_Sorted'Result = M_Elements_Sorted (Model (Container));\n-\n-      procedure Sort (Container : in out Vector) with\n-        Global => null,\n-        Post   =>\n-          Length (Container) = Length (Container)'Old\n-            and M_Elements_Sorted (Model (Container))\n-            and M_Elements_Included\n-                  (Left  => Model (Container)'Old,\n-                   L_Lst => Last_Index (Container),\n-                   Right => Model (Container),\n-                   R_Lst => Last_Index (Container))\n-            and M_Elements_Included\n-                  (Left  => Model (Container),\n-                   L_Lst => Last_Index (Container),\n-                   Right => Model (Container)'Old,\n-                   R_Lst => Last_Index (Container));\n-\n-      procedure Merge (Target : in out Vector; Source : in out Vector) with\n-      --  Target and Source should not be aliased\n-        Global => null,\n-        Pre    => Length (Source) <= Capacity (Target) - Length (Target),\n-        Post   =>\n-          Length (Target) = Length (Target)'Old + Length (Source)'Old\n-            and Length (Source) = 0\n-            and (if M_Elements_Sorted (Model (Target)'Old)\n-                   and M_Elements_Sorted (Model (Source)'Old)\n-                 then\n-                    M_Elements_Sorted (Model (Target)))\n-            and M_Elements_Included\n-                  (Left  => Model (Target)'Old,\n-                   L_Lst => Last_Index (Target)'Old,\n-                   Right => Model (Target),\n-                   R_Lst => Last_Index (Target))\n-            and M_Elements_Included\n-                  (Left  => Model (Source)'Old,\n-                   L_Lst => Last_Index (Source)'Old,\n-                   Right => Model (Target),\n-                   R_Lst => Last_Index (Target))\n-            and M_Elements_In_Union\n-                  (Model (Target),\n-                   Model (Source)'Old,\n-                   Model (Target)'Old);\n-   end Generic_Sorting;\n-\n-private\n-   pragma SPARK_Mode (Off);\n-\n-   pragma Inline (First_Index);\n-   pragma Inline (Last_Index);\n-   pragma Inline (Element);\n-   pragma Inline (First_Element);\n-   pragma Inline (Last_Element);\n-   pragma Inline (Replace_Element);\n-   pragma Inline (Contains);\n-\n-   --  The implementation method is to instantiate Bounded_Holders to get a\n-   --  definite type for Element_Type.\n-\n-   package Holders is new Bounded_Holders\n-     (Element_Type, Max_Size_In_Storage_Elements, \"=\");\n-   use Holders;\n-\n-   subtype Array_Index is Capacity_Range range 1 .. Capacity_Range'Last;\n-   type Elements_Array is array (Array_Index range <>) of aliased Holder;\n-   function \"=\" (L, R : Elements_Array) return Boolean is abstract;\n-\n-   type Elements_Array_Ptr is access all Elements_Array;\n-\n-   type Vector (Capacity : Capacity_Range) is limited record\n-\n-      --  In the bounded case, the elements are stored in Elements. In the\n-      --  unbounded case, the elements are initially stored in Elements, until\n-      --  we run out of room, then we switch to Elements_Ptr.\n-\n-      Last         : Extended_Index := No_Index;\n-      Elements_Ptr : Elements_Array_Ptr := null;\n-      Elements     : aliased Elements_Array (1 .. Capacity);\n-   end record;\n-\n-   --  The primary reason Vector is limited is that in the unbounded case, once\n-   --  Elements_Ptr is in use, assignment statements won't work. \"X := Y;\" will\n-   --  cause X and Y to share state; that is, X.Elements_Ptr = Y.Elements_Ptr,\n-   --  so for example \"Append (X, ...);\" will modify BOTH X and Y. That would\n-   --  allow SPARK to \"prove\" things that are false. We could fix that by\n-   --  making Vector a controlled type, and override Adjust to make a deep\n-   --  copy, but finalization is not allowed in SPARK.\n-   --\n-   --  Note that (unfortunately) this means that 'Old and 'Loop_Entry are not\n-   --  allowed on Vectors.\n+package Ada.Containers.Formal_Indefinite_Vectors with SPARK_Mode is\n \n-   function Empty_Vector return Vector is\n-     ((Capacity => 0, others => <>));\n+   pragma Compile_Time_Error\n+     (True,\n+      \"This package has been moved to the SPARK library shipped with any\"\n+      & \" SPARK release starting with version 23.\");\n \n end Ada.Containers.Formal_Indefinite_Vectors;"}, {"sha": "38d15e7bb091d78b080981028fb8534868d215a5", "filename": "gcc/ada/libgnat/a-cforma.adb", "status": "removed", "additions": 0, "deletions": 1239, "changes": 1239, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cforma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cforma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cforma.adb?ref=cf8af60f6a3910577e99db04dbc757e731558144", "patch": "@@ -1,1239 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT LIBRARY COMPONENTS                          --\n---                                                                          --\n---   A D A . C O N T A I N E R S . F O R M A L _ O R D E R E D _ M A P S    --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2010-2022, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations;\n-pragma Elaborate_All\n-  (Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations);\n-\n-with Ada.Containers.Red_Black_Trees.Generic_Bounded_Keys;\n-pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Bounded_Keys);\n-\n-with Ada.Numerics.Big_Numbers.Big_Integers;\n-use Ada.Numerics.Big_Numbers.Big_Integers;\n-\n-with System; use type System.Address;\n-\n-package body Ada.Containers.Formal_Ordered_Maps with\n-  SPARK_Mode => Off\n-is\n-\n-   --  Convert Count_Type to Big_Interger\n-\n-   package Conversions is new Signed_Conversions (Int => Count_Type);\n-\n-   function Big (J : Count_Type) return Big_Integer renames\n-     Conversions.To_Big_Integer;\n-\n-   -----------------------------\n-   -- Node Access Subprograms --\n-   -----------------------------\n-\n-   --  These subprograms provide a functional interface to access fields\n-   --  of a node, and a procedural interface for modifying these values.\n-\n-   function Color\n-     (Node : Node_Type) return Ada.Containers.Red_Black_Trees.Color_Type;\n-   pragma Inline (Color);\n-\n-   function Left_Son (Node : Node_Type) return Count_Type;\n-   pragma Inline (Left_Son);\n-\n-   function Parent (Node : Node_Type) return Count_Type;\n-   pragma Inline (Parent);\n-\n-   function Right_Son (Node : Node_Type) return Count_Type;\n-   pragma Inline (Right_Son);\n-\n-   procedure Set_Color\n-     (Node  : in out Node_Type;\n-      Color : Ada.Containers.Red_Black_Trees.Color_Type);\n-   pragma Inline (Set_Color);\n-\n-   procedure Set_Left (Node : in out Node_Type; Left : Count_Type);\n-   pragma Inline (Set_Left);\n-\n-   procedure Set_Right (Node : in out Node_Type; Right : Count_Type);\n-   pragma Inline (Set_Right);\n-\n-   procedure Set_Parent (Node : in out Node_Type; Parent : Count_Type);\n-   pragma Inline (Set_Parent);\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   --  All need comments ???\n-\n-   generic\n-      with procedure Set_Element (Node : in out Node_Type);\n-   procedure Generic_Allocate\n-     (Tree : in out Tree_Types.Tree_Type'Class;\n-      Node : out Count_Type);\n-\n-   procedure Free (Tree : in out Map; X : Count_Type);\n-\n-   function Is_Greater_Key_Node\n-     (Left  : Key_Type;\n-      Right : Node_Type) return Boolean;\n-   pragma Inline (Is_Greater_Key_Node);\n-\n-   function Is_Less_Key_Node\n-     (Left  : Key_Type;\n-      Right : Node_Type) return Boolean;\n-   pragma Inline (Is_Less_Key_Node);\n-\n-   --------------------------\n-   -- Local Instantiations --\n-   --------------------------\n-\n-   package Tree_Operations is\n-     new Red_Black_Trees.Generic_Bounded_Operations\n-       (Tree_Types => Tree_Types,\n-        Left       => Left_Son,\n-        Right      => Right_Son);\n-\n-   use Tree_Operations;\n-\n-   package Key_Ops is\n-     new Red_Black_Trees.Generic_Bounded_Keys\n-       (Tree_Operations     => Tree_Operations,\n-        Key_Type            => Key_Type,\n-        Is_Less_Key_Node    => Is_Less_Key_Node,\n-        Is_Greater_Key_Node => Is_Greater_Key_Node);\n-\n-   ---------\n-   -- \"=\" --\n-   ---------\n-\n-   function \"=\" (Left, Right : Map) return Boolean is\n-      Lst   : Count_Type;\n-      Node  : Count_Type;\n-      ENode : Count_Type;\n-\n-   begin\n-      if Length (Left) /= Length (Right) then\n-         return False;\n-      end if;\n-\n-      if Is_Empty (Left) then\n-         return True;\n-      end if;\n-\n-      Lst := Next (Left.Content, Last (Left).Node);\n-\n-      Node := First (Left).Node;\n-      while Node /= Lst loop\n-         ENode := Find (Right, Left.Content.Nodes (Node).Key).Node;\n-\n-         if ENode = 0 or else\n-           Left.Content.Nodes (Node).Element /=\n-           Right.Content.Nodes (ENode).Element\n-         then\n-            return False;\n-         end if;\n-\n-         Node := Next (Left.Content, Node);\n-      end loop;\n-\n-      return True;\n-   end \"=\";\n-\n-   ------------\n-   -- Assign --\n-   ------------\n-\n-   procedure Assign (Target : in out Map; Source : Map) is\n-      procedure Append_Element (Source_Node : Count_Type);\n-\n-      procedure Append_Elements is\n-         new Tree_Operations.Generic_Iteration (Append_Element);\n-\n-      --------------------\n-      -- Append_Element --\n-      --------------------\n-\n-      procedure Append_Element (Source_Node : Count_Type) is\n-         SN : Node_Type renames Source.Content.Nodes (Source_Node);\n-\n-         procedure Set_Element (Node : in out Node_Type);\n-         pragma Inline (Set_Element);\n-\n-         function New_Node return Count_Type;\n-         pragma Inline (New_Node);\n-\n-         procedure Insert_Post is new Key_Ops.Generic_Insert_Post (New_Node);\n-\n-         procedure Unconditional_Insert_Sans_Hint is\n-           new Key_Ops.Generic_Unconditional_Insert (Insert_Post);\n-\n-         procedure Unconditional_Insert_Avec_Hint is\n-           new Key_Ops.Generic_Unconditional_Insert_With_Hint\n-             (Insert_Post,\n-              Unconditional_Insert_Sans_Hint);\n-\n-         procedure Allocate is new Generic_Allocate (Set_Element);\n-\n-         --------------\n-         -- New_Node --\n-         --------------\n-\n-         function New_Node return Count_Type is\n-            Result : Count_Type;\n-         begin\n-            Allocate (Target.Content, Result);\n-            return Result;\n-         end New_Node;\n-\n-         -----------------\n-         -- Set_Element --\n-         -----------------\n-\n-         procedure Set_Element (Node : in out Node_Type) is\n-         begin\n-            Node.Key := SN.Key;\n-            Node.Element := SN.Element;\n-         end Set_Element;\n-\n-         Target_Node : Count_Type;\n-\n-      --  Start of processing for Append_Element\n-\n-      begin\n-         Unconditional_Insert_Avec_Hint\n-           (Tree  => Target.Content,\n-            Hint  => 0,\n-            Key   => SN.Key,\n-            Node  => Target_Node);\n-      end Append_Element;\n-\n-   --  Start of processing for Assign\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n-      if Target.Capacity < Length (Source) then\n-         raise Storage_Error with \"not enough capacity\";  -- SE or CE? ???\n-      end if;\n-\n-      Tree_Operations.Clear_Tree (Target.Content);\n-      Append_Elements (Source.Content);\n-   end Assign;\n-\n-   -------------\n-   -- Ceiling --\n-   -------------\n-\n-   function Ceiling (Container : Map; Key : Key_Type) return Cursor is\n-      Node : constant Count_Type := Key_Ops.Ceiling (Container.Content, Key);\n-\n-   begin\n-      if Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Node);\n-   end Ceiling;\n-\n-   -----------\n-   -- Clear --\n-   -----------\n-\n-   procedure Clear (Container : in out Map) is\n-   begin\n-      Tree_Operations.Clear_Tree (Container.Content);\n-   end Clear;\n-\n-   -----------\n-   -- Color --\n-   -----------\n-\n-   function Color (Node : Node_Type) return Color_Type is\n-   begin\n-      return Node.Color;\n-   end Color;\n-\n-   ------------------------\n-   -- Constant_Reference --\n-   ------------------------\n-\n-   function Constant_Reference\n-     (Container : aliased Map;\n-      Position  : Cursor) return not null access constant Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container.Content, Position.Node),\n-                     \"bad cursor in function Constant_Reference\");\n-\n-      return Container.Content.Nodes (Position.Node).Element'Access;\n-   end Constant_Reference;\n-\n-   function Constant_Reference\n-     (Container : aliased Map;\n-      Key       : Key_Type) return not null access constant Element_Type\n-   is\n-      Node : constant Node_Access := Find (Container, Key).Node;\n-\n-   begin\n-      if Node = 0 then\n-         raise Constraint_Error with\n-           \"no element available because key not in map\";\n-      end if;\n-\n-      return Container.Content.Nodes (Node).Element'Access;\n-   end Constant_Reference;\n-\n-   --------------\n-   -- Contains --\n-   --------------\n-\n-   function Contains (Container : Map; Key : Key_Type) return Boolean is\n-   begin\n-      return Find (Container, Key) /= No_Element;\n-   end Contains;\n-\n-   ----------\n-   -- Copy --\n-   ----------\n-\n-   function Copy (Source : Map; Capacity : Count_Type := 0) return Map is\n-      Node : Count_Type := 1;\n-      N    : Count_Type;\n-\n-   begin\n-      if 0 < Capacity and then Capacity < Source.Capacity then\n-         raise Capacity_Error;\n-      end if;\n-\n-      return Target : Map (Count_Type'Max (Source.Capacity, Capacity)) do\n-         if Length (Source) > 0 then\n-            Target.Content.Length := Source.Content.Length;\n-            Target.Content.Root := Source.Content.Root;\n-            Target.Content.First := Source.Content.First;\n-            Target.Content.Last := Source.Content.Last;\n-            Target.Content.Free := Source.Content.Free;\n-\n-            while Node <= Source.Capacity loop\n-               Target.Content.Nodes (Node).Element :=\n-                 Source.Content.Nodes (Node).Element;\n-               Target.Content.Nodes (Node).Key :=\n-                 Source.Content.Nodes (Node).Key;\n-               Target.Content.Nodes (Node).Parent :=\n-                 Source.Content.Nodes (Node).Parent;\n-               Target.Content.Nodes (Node).Left :=\n-                 Source.Content.Nodes (Node).Left;\n-               Target.Content.Nodes (Node).Right :=\n-                 Source.Content.Nodes (Node).Right;\n-               Target.Content.Nodes (Node).Color :=\n-                 Source.Content.Nodes (Node).Color;\n-               Target.Content.Nodes (Node).Has_Element :=\n-                 Source.Content.Nodes (Node).Has_Element;\n-               Node := Node + 1;\n-            end loop;\n-\n-            while Node <= Target.Capacity loop\n-               N := Node;\n-               Free (Tree => Target, X => N);\n-               Node := Node + 1;\n-            end loop;\n-         end if;\n-      end return;\n-   end Copy;\n-\n-   ------------\n-   -- Delete --\n-   ------------\n-\n-   procedure Delete (Container : in out Map; Position : in out Cursor) is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with\n-           \"Position cursor of Delete has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container.Content, Position.Node),\n-                     \"Position cursor of Delete is bad\");\n-\n-      Tree_Operations.Delete_Node_Sans_Free (Container.Content,\n-                                             Position.Node);\n-      Free (Container, Position.Node);\n-      Position := No_Element;\n-   end Delete;\n-\n-   procedure Delete (Container : in out Map; Key : Key_Type) is\n-      X : constant Node_Access := Key_Ops.Find (Container.Content, Key);\n-\n-   begin\n-      if X = 0 then\n-         raise Constraint_Error with \"key not in map\";\n-      end if;\n-\n-      Tree_Operations.Delete_Node_Sans_Free (Container.Content, X);\n-      Free (Container, X);\n-   end Delete;\n-\n-   ------------------\n-   -- Delete_First --\n-   ------------------\n-\n-   procedure Delete_First (Container : in out Map) is\n-      X : constant Node_Access := First (Container).Node;\n-   begin\n-      if X /= 0 then\n-         Tree_Operations.Delete_Node_Sans_Free (Container.Content, X);\n-         Free (Container, X);\n-      end if;\n-   end Delete_First;\n-\n-   -----------------\n-   -- Delete_Last --\n-   -----------------\n-\n-   procedure Delete_Last (Container : in out Map) is\n-      X : constant Node_Access := Last (Container).Node;\n-   begin\n-      if X /= 0 then\n-         Tree_Operations.Delete_Node_Sans_Free (Container.Content, X);\n-         Free (Container, X);\n-      end if;\n-   end Delete_Last;\n-\n-   -------------\n-   -- Element --\n-   -------------\n-\n-   function Element (Container : Map; Position : Cursor) return Element_Type is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with\n-           \"Position cursor of function Element has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container.Content, Position.Node),\n-                     \"Position cursor of function Element is bad\");\n-\n-      return Container.Content.Nodes (Position.Node).Element;\n-\n-   end Element;\n-\n-   function Element (Container : Map; Key : Key_Type) return Element_Type is\n-      Node : constant Node_Access := Find (Container, Key).Node;\n-\n-   begin\n-      if Node = 0 then\n-         raise Constraint_Error with \"key not in map\";\n-      end if;\n-\n-      return Container.Content.Nodes (Node).Element;\n-   end Element;\n-\n-   ---------------------\n-   -- Equivalent_Keys --\n-   ---------------------\n-\n-   function Equivalent_Keys (Left, Right : Key_Type) return Boolean is\n-   begin\n-      if Left < Right\n-        or else Right < Left\n-      then\n-         return False;\n-      else\n-         return True;\n-      end if;\n-   end Equivalent_Keys;\n-\n-   -------------\n-   -- Exclude --\n-   -------------\n-\n-   procedure Exclude (Container : in out Map; Key : Key_Type) is\n-      X : constant Node_Access := Key_Ops.Find (Container.Content, Key);\n-   begin\n-      if X /= 0 then\n-         Tree_Operations.Delete_Node_Sans_Free (Container.Content, X);\n-         Free (Container, X);\n-      end if;\n-   end Exclude;\n-\n-   ----------\n-   -- Find --\n-   ----------\n-\n-   function Find (Container : Map; Key : Key_Type) return Cursor is\n-      Node : constant Count_Type := Key_Ops.Find (Container.Content, Key);\n-\n-   begin\n-      if Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Node);\n-   end Find;\n-\n-   -----------\n-   -- First --\n-   -----------\n-\n-   function First (Container : Map) return Cursor is\n-   begin\n-      if Length (Container) = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Container.Content.First);\n-   end First;\n-\n-   -------------------\n-   -- First_Element --\n-   -------------------\n-\n-   function First_Element (Container : Map) return Element_Type is\n-   begin\n-      if Is_Empty (Container) then\n-         raise Constraint_Error with \"map is empty\";\n-      end if;\n-\n-      return Container.Content.Nodes (First (Container).Node).Element;\n-   end First_Element;\n-\n-   ---------------\n-   -- First_Key --\n-   ---------------\n-\n-   function First_Key (Container : Map) return Key_Type is\n-   begin\n-      if Is_Empty (Container) then\n-         raise Constraint_Error with \"map is empty\";\n-      end if;\n-\n-      return Container.Content.Nodes (First (Container).Node).Key;\n-   end First_Key;\n-\n-   -----------\n-   -- Floor --\n-   -----------\n-\n-   function Floor (Container : Map; Key : Key_Type) return Cursor is\n-      Node : constant Count_Type := Key_Ops.Floor (Container.Content, Key);\n-\n-   begin\n-      if Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Node);\n-   end Floor;\n-\n-   ------------------\n-   -- Formal_Model --\n-   ------------------\n-\n-   package body Formal_Model is\n-\n-      ----------\n-      -- Find --\n-      ----------\n-\n-      function Find\n-        (Container : K.Sequence;\n-         Key       : Key_Type) return Count_Type\n-      is\n-      begin\n-         for I in 1 .. K.Length (Container) loop\n-            if Equivalent_Keys (Key, K.Get (Container, I)) then\n-               return I;\n-            elsif Key < K.Get (Container, I) then\n-               return 0;\n-            end if;\n-         end loop;\n-         return 0;\n-      end Find;\n-\n-      -------------------------\n-      -- K_Bigger_Than_Range --\n-      -------------------------\n-\n-      function K_Bigger_Than_Range\n-        (Container : K.Sequence;\n-         Fst       : Positive_Count_Type;\n-         Lst       : Count_Type;\n-         Key       : Key_Type) return Boolean\n-      is\n-      begin\n-         for I in Fst .. Lst loop\n-            if not (K.Get (Container, I) < Key) then\n-               return False;\n-            end if;\n-         end loop;\n-         return True;\n-      end K_Bigger_Than_Range;\n-\n-      ---------------\n-      -- K_Is_Find --\n-      ---------------\n-\n-      function K_Is_Find\n-        (Container : K.Sequence;\n-         Key       : Key_Type;\n-         Position  : Count_Type) return Boolean\n-      is\n-      begin\n-         for I in 1 .. Position - 1 loop\n-            if Key < K.Get (Container, I) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         if Position < K.Length (Container) then\n-            for I in Position + 1 .. K.Length (Container) loop\n-               if K.Get (Container, I) < Key then\n-                  return False;\n-               end if;\n-            end loop;\n-         end if;\n-         return True;\n-      end K_Is_Find;\n-\n-      --------------------------\n-      -- K_Smaller_Than_Range --\n-      --------------------------\n-\n-      function K_Smaller_Than_Range\n-        (Container : K.Sequence;\n-         Fst       : Positive_Count_Type;\n-         Lst       : Count_Type;\n-         Key       : Key_Type) return Boolean\n-      is\n-      begin\n-         for I in Fst .. Lst loop\n-            if not (Key < K.Get (Container, I)) then\n-               return False;\n-            end if;\n-         end loop;\n-         return True;\n-      end K_Smaller_Than_Range;\n-\n-      ----------\n-      -- Keys --\n-      ----------\n-\n-      function Keys (Container : Map) return K.Sequence is\n-         Position : Count_Type := Container.Content.First;\n-         R        : K.Sequence;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R := K.Add (R, Container.Content.Nodes (Position).Key);\n-            Position := Tree_Operations.Next (Container.Content, Position);\n-         end loop;\n-\n-         return R;\n-      end Keys;\n-\n-      ----------------------------\n-      -- Lift_Abstraction_Level --\n-      ----------------------------\n-\n-      procedure Lift_Abstraction_Level (Container : Map) is null;\n-\n-      -----------\n-      -- Model --\n-      -----------\n-\n-      function Model (Container : Map) return M.Map is\n-         Position : Count_Type := Container.Content.First;\n-         R        : M.Map;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R :=\n-              M.Add\n-                (Container => R,\n-                 New_Key   => Container.Content.Nodes (Position).Key,\n-                 New_Item  => Container.Content.Nodes (Position).Element);\n-\n-            Position := Tree_Operations.Next (Container.Content, Position);\n-         end loop;\n-\n-         return R;\n-      end Model;\n-\n-      -------------------------\n-      -- P_Positions_Shifted --\n-      -------------------------\n-\n-      function P_Positions_Shifted\n-        (Small : P.Map;\n-         Big   : P.Map;\n-         Cut   : Positive_Count_Type;\n-         Count : Count_Type := 1) return Boolean\n-      is\n-      begin\n-         for Cu of Small loop\n-            if not P.Has_Key (Big, Cu) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         for Cu of Big loop\n-            declare\n-               Pos : constant Positive_Count_Type := P.Get (Big, Cu);\n-\n-            begin\n-               if Pos < Cut then\n-                  if not P.Has_Key (Small, Cu)\n-                    or else Pos /= P.Get (Small, Cu)\n-                  then\n-                     return False;\n-                  end if;\n-\n-               elsif Pos >= Cut + Count then\n-                  if not P.Has_Key (Small, Cu)\n-                    or else Pos /= P.Get (Small, Cu) + Count\n-                  then\n-                     return False;\n-                  end if;\n-\n-               else\n-                  if P.Has_Key (Small, Cu) then\n-                     return False;\n-                  end if;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end P_Positions_Shifted;\n-\n-      ---------------\n-      -- Positions --\n-      ---------------\n-\n-      function Positions (Container : Map) return P.Map is\n-         I        : Count_Type := 1;\n-         Position : Count_Type := Container.Content.First;\n-         R        : P.Map;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R := P.Add (R, (Node => Position), I);\n-            pragma Assert (P.Length (R) = Big (I));\n-            Position := Tree_Operations.Next (Container.Content, Position);\n-            I := I + 1;\n-         end loop;\n-\n-         return R;\n-      end Positions;\n-\n-   end Formal_Model;\n-\n-   ----------\n-   -- Free --\n-   ----------\n-\n-   procedure Free\n-     (Tree : in out Map;\n-      X  : Count_Type)\n-   is\n-   begin\n-      Tree.Content.Nodes (X).Has_Element := False;\n-      Tree_Operations.Free (Tree.Content, X);\n-   end Free;\n-\n-   ----------------------\n-   -- Generic_Allocate --\n-   ----------------------\n-\n-   procedure Generic_Allocate\n-     (Tree : in out Tree_Types.Tree_Type'Class;\n-      Node : out Count_Type)\n-   is\n-      procedure Allocate is\n-        new Tree_Operations.Generic_Allocate (Set_Element);\n-   begin\n-      Allocate (Tree, Node);\n-      Tree.Nodes (Node).Has_Element := True;\n-   end Generic_Allocate;\n-\n-   -----------------\n-   -- Has_Element --\n-   -----------------\n-\n-   function Has_Element (Container : Map; Position : Cursor) return Boolean is\n-   begin\n-      if Position.Node = 0 then\n-         return False;\n-      end if;\n-\n-      return Container.Content.Nodes (Position.Node).Has_Element;\n-   end Has_Element;\n-\n-   -------------\n-   -- Include --\n-   -------------\n-\n-   procedure Include\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type)\n-   is\n-      Position : Cursor;\n-      Inserted : Boolean;\n-\n-   begin\n-      Insert (Container, Key, New_Item, Position, Inserted);\n-\n-      if not Inserted then\n-         declare\n-            N : Node_Type renames Container.Content.Nodes (Position.Node);\n-         begin\n-            N.Key := Key;\n-            N.Element := New_Item;\n-         end;\n-      end if;\n-   end Include;\n-\n-   procedure Insert\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor;\n-      Inserted  : out Boolean)\n-   is\n-      function New_Node return Node_Access;\n-      --  Comment ???\n-\n-      procedure Insert_Post is\n-        new Key_Ops.Generic_Insert_Post (New_Node);\n-\n-      procedure Insert_Sans_Hint is\n-        new Key_Ops.Generic_Conditional_Insert (Insert_Post);\n-\n-      --------------\n-      -- New_Node --\n-      --------------\n-\n-      function New_Node return Node_Access is\n-         procedure Initialize (Node : in out Node_Type);\n-         procedure Allocate_Node is new Generic_Allocate (Initialize);\n-\n-         procedure Initialize (Node : in out Node_Type) is\n-         begin\n-            Node.Key := Key;\n-            Node.Element := New_Item;\n-         end Initialize;\n-\n-         X : Node_Access;\n-\n-      begin\n-         Allocate_Node (Container.Content, X);\n-         return X;\n-      end New_Node;\n-\n-   --  Start of processing for Insert\n-\n-   begin\n-      Insert_Sans_Hint\n-        (Container.Content,\n-         Key,\n-         Position.Node,\n-         Inserted);\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type)\n-   is\n-      Position : Cursor;\n-      Inserted : Boolean;\n-\n-   begin\n-      Insert (Container, Key, New_Item, Position, Inserted);\n-\n-      if not Inserted then\n-         raise Constraint_Error with \"key already in map\";\n-      end if;\n-   end Insert;\n-\n-   --------------\n-   -- Is_Empty --\n-   --------------\n-\n-   function Is_Empty (Container : Map) return Boolean is\n-   begin\n-      return Length (Container) = 0;\n-   end Is_Empty;\n-\n-   -------------------------\n-   -- Is_Greater_Key_Node --\n-   -------------------------\n-\n-   function Is_Greater_Key_Node\n-     (Left  : Key_Type;\n-      Right : Node_Type) return Boolean\n-   is\n-   begin\n-      --  k > node same as node < k\n-\n-      return Right.Key < Left;\n-   end Is_Greater_Key_Node;\n-\n-   ----------------------\n-   -- Is_Less_Key_Node --\n-   ----------------------\n-\n-   function Is_Less_Key_Node\n-     (Left  : Key_Type;\n-      Right : Node_Type) return Boolean\n-   is\n-   begin\n-      return Left < Right.Key;\n-   end Is_Less_Key_Node;\n-\n-   ---------\n-   -- Key --\n-   ---------\n-\n-   function Key (Container : Map; Position : Cursor) return Key_Type is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with\n-           \"Position cursor of function Key has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container.Content, Position.Node),\n-                     \"Position cursor of function Key is bad\");\n-\n-      return Container.Content.Nodes (Position.Node).Key;\n-   end Key;\n-\n-   ----------\n-   -- Last --\n-   ----------\n-\n-   function Last (Container : Map) return Cursor is\n-   begin\n-      if Length (Container) = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Container.Content.Last);\n-   end Last;\n-\n-   ------------------\n-   -- Last_Element --\n-   ------------------\n-\n-   function Last_Element (Container : Map) return Element_Type is\n-   begin\n-      if Is_Empty (Container) then\n-         raise Constraint_Error with \"map is empty\";\n-      end if;\n-\n-      return Container.Content.Nodes (Last (Container).Node).Element;\n-   end Last_Element;\n-\n-   --------------\n-   -- Last_Key --\n-   --------------\n-\n-   function Last_Key (Container : Map) return Key_Type is\n-   begin\n-      if Is_Empty (Container) then\n-         raise Constraint_Error with \"map is empty\";\n-      end if;\n-\n-      return Container.Content.Nodes (Last (Container).Node).Key;\n-   end Last_Key;\n-\n-   --------------\n-   -- Left_Son --\n-   --------------\n-\n-   function Left_Son (Node : Node_Type) return Count_Type is\n-   begin\n-      return Node.Left;\n-   end Left_Son;\n-\n-   ------------\n-   -- Length --\n-   ------------\n-\n-   function Length (Container : Map) return Count_Type is\n-   begin\n-      return Container.Content.Length;\n-   end Length;\n-\n-   ----------\n-   -- Move --\n-   ----------\n-\n-   procedure Move (Target : in out Map; Source : in out Map) is\n-      NN : Tree_Types.Nodes_Type renames Source.Content.Nodes;\n-      X  : Node_Access;\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n-      if Target.Capacity < Length (Source) then\n-         raise Constraint_Error with  -- ???\n-           \"Source length exceeds Target capacity\";\n-      end if;\n-\n-      Clear (Target);\n-\n-      loop\n-         X := First (Source).Node;\n-         exit when X = 0;\n-\n-         --  Here we insert a copy of the source element into the target, and\n-         --  then delete the element from the source. Another possibility is\n-         --  that delete it first (and hang onto its index), then insert it.\n-         --  ???\n-\n-         Insert (Target, NN (X).Key, NN (X).Element);  -- optimize???\n-\n-         Tree_Operations.Delete_Node_Sans_Free (Source.Content, X);\n-         Formal_Ordered_Maps.Free (Source, X);\n-      end loop;\n-   end Move;\n-\n-   ----------\n-   -- Next --\n-   ----------\n-\n-   procedure Next (Container : Map; Position : in out Cursor) is\n-   begin\n-      Position := Next (Container, Position);\n-   end Next;\n-\n-   function Next (Container : Map; Position : Cursor) return Cursor is\n-   begin\n-      if Position = No_Element then\n-         return No_Element;\n-      end if;\n-\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error;\n-      end if;\n-\n-      pragma Assert (Vet (Container.Content, Position.Node),\n-                     \"bad cursor in Next\");\n-\n-      return (Node => Tree_Operations.Next (Container.Content, Position.Node));\n-   end Next;\n-\n-   ------------\n-   -- Parent --\n-   ------------\n-\n-   function Parent (Node : Node_Type) return Count_Type is\n-   begin\n-      return Node.Parent;\n-   end Parent;\n-\n-   --------------\n-   -- Previous --\n-   --------------\n-\n-   procedure Previous (Container : Map; Position : in out Cursor) is\n-   begin\n-      Position := Previous (Container, Position);\n-   end Previous;\n-\n-   function Previous (Container : Map; Position : Cursor) return Cursor is\n-   begin\n-      if Position = No_Element then\n-         return No_Element;\n-      end if;\n-\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error;\n-      end if;\n-\n-      pragma Assert (Vet (Container.Content, Position.Node),\n-                     \"bad cursor in Previous\");\n-\n-      declare\n-         Node : constant Count_Type :=\n-           Tree_Operations.Previous (Container.Content, Position.Node);\n-\n-      begin\n-         if Node = 0 then\n-            return No_Element;\n-         end if;\n-\n-         return (Node => Node);\n-      end;\n-   end Previous;\n-\n-   --------------\n-   -- Reference --\n-   --------------\n-\n-   function Reference\n-     (Container : not null access Map;\n-      Position  : Cursor) return not null access Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container.all, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert\n-        (Vet (Container.Content, Position.Node),\n-         \"bad cursor in function Reference\");\n-\n-      return Container.Content.Nodes (Position.Node).Element'Access;\n-   end Reference;\n-\n-   function Reference\n-     (Container : not null access Map;\n-      Key       : Key_Type) return not null access Element_Type\n-   is\n-      Node : constant Count_Type := Find (Container.all, Key).Node;\n-\n-   begin\n-      if Node = 0 then\n-         raise Constraint_Error with\n-           \"no element available because key not in map\";\n-      end if;\n-\n-      return Container.Content.Nodes (Node).Element'Access;\n-   end Reference;\n-\n-   -------------\n-   -- Replace --\n-   -------------\n-\n-   procedure Replace\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type)\n-   is\n-   begin\n-      declare\n-         Node : constant Node_Access := Key_Ops.Find (Container.Content, Key);\n-\n-      begin\n-         if Node = 0 then\n-            raise Constraint_Error with \"key not in map\";\n-         end if;\n-\n-         declare\n-            N : Node_Type renames Container.Content.Nodes (Node);\n-         begin\n-            N.Key := Key;\n-            N.Element := New_Item;\n-         end;\n-      end;\n-   end Replace;\n-\n-   ---------------------\n-   -- Replace_Element --\n-   ---------------------\n-\n-   procedure Replace_Element\n-     (Container : in out Map;\n-      Position  : Cursor;\n-      New_Item  : Element_Type)\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with\n-           \"Position cursor of Replace_Element has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container.Content, Position.Node),\n-                     \"Position cursor of Replace_Element is bad\");\n-\n-      Container.Content.Nodes (Position.Node).Element := New_Item;\n-   end Replace_Element;\n-\n-   ---------------\n-   -- Right_Son --\n-   ---------------\n-\n-   function Right_Son (Node : Node_Type) return Count_Type is\n-   begin\n-      return Node.Right;\n-   end Right_Son;\n-\n-   ---------------\n-   -- Set_Color --\n-   ---------------\n-\n-   procedure Set_Color (Node  : in out Node_Type; Color : Color_Type) is\n-   begin\n-      Node.Color := Color;\n-   end Set_Color;\n-\n-   --------------\n-   -- Set_Left --\n-   --------------\n-\n-   procedure Set_Left (Node : in out Node_Type; Left : Count_Type) is\n-   begin\n-      Node.Left := Left;\n-   end Set_Left;\n-\n-   ----------------\n-   -- Set_Parent --\n-   ----------------\n-\n-   procedure Set_Parent (Node : in out Node_Type; Parent : Count_Type) is\n-   begin\n-      Node.Parent := Parent;\n-   end Set_Parent;\n-\n-   ---------------\n-   -- Set_Right --\n-   ---------------\n-\n-   procedure Set_Right (Node : in out Node_Type; Right : Count_Type) is\n-   begin\n-      Node.Right := Right;\n-   end Set_Right;\n-\n-end Ada.Containers.Formal_Ordered_Maps;"}, {"sha": "21a5d78dfc8d7b8371f069b47b399ab08207c71f", "filename": "gcc/ada/libgnat/a-cforma.ads", "status": "modified", "additions": 5, "deletions": 1117, "changes": 1122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cforma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cforma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cforma.ads?ref=4a7312f7ce189783a2cb5318bdcf50e8148b909d", "patch": "@@ -29,1124 +29,12 @@\n -- <http://www.gnu.org/licenses/>.                                          --\n ------------------------------------------------------------------------------\n \n---  This spec is derived from package Ada.Containers.Bounded_Ordered_Maps in\n---  the Ada 2012 RM. The modifications are meant to facilitate formal proofs by\n---  making it easier to express properties, and by making the specification of\n---  this unit compatible with SPARK 2014. Note that the API of this unit may be\n---  subject to incompatible changes as SPARK 2014 evolves.\n-\n---  The modifications are:\n-\n---    A parameter for the container is added to every function reading the\n---    content of a container: Key, Element, Next, Query_Element, Previous,\n---    Has_Element, Iterate, Reverse_Iterate. This change is motivated by the\n---    need to have cursors which are valid on different containers (typically a\n---    container C and its previous version C'Old) for expressing properties,\n---    which is not possible if cursors encapsulate an access to the underlying\n---    container. The operators \"<\" and \">\" that could not be modified that way\n---    have been removed.\n-\n---  Iteration over maps is done using the Iterable aspect, which is SPARK\n---  compatible. \"For of\" iteration ranges over keys instead of elements.\n-\n-with Ada.Containers.Functional_Vectors;\n-with Ada.Containers.Functional_Maps;\n-private with Ada.Containers.Red_Black_Trees;\n-\n generic\n-   type Key_Type is private;\n-   type Element_Type is private;\n-\n-   with function \"<\" (Left, Right : Key_Type) return Boolean is <>;\n-   with function \"=\" (Left, Right : Element_Type) return Boolean is <>;\n-\n-package Ada.Containers.Formal_Ordered_Maps with\n-  SPARK_Mode,\n-  Annotate => (GNATprove, Always_Return)\n-is\n-\n-   --  Contracts in this unit are meant for analysis only, not for run-time\n-   --  checking.\n-\n-   pragma Assertion_Policy (Pre => Ignore);\n-   pragma Assertion_Policy (Post => Ignore);\n-   pragma Assertion_Policy (Contract_Cases => Ignore);\n-   pragma Annotate (CodePeer, Skip_Analysis);\n-\n-   function Equivalent_Keys (Left, Right : Key_Type) return Boolean with\n-     Global => null,\n-     Post   =>\n-       Equivalent_Keys'Result = (not (Left < Right) and not (Right < Left));\n-   pragma Annotate (GNATprove, Inline_For_Proof, Equivalent_Keys);\n-\n-   type Map (Capacity : Count_Type) is private with\n-     Iterable => (First       => First,\n-                  Next        => Next,\n-                  Has_Element => Has_Element,\n-                  Element     => Key),\n-     Default_Initial_Condition => Is_Empty (Map);\n-   pragma Preelaborable_Initialization (Map);\n-\n-   type Cursor is record\n-      Node : Count_Type;\n-   end record;\n-\n-   No_Element : constant Cursor := (Node => 0);\n-\n-   Empty_Map : constant Map;\n-\n-   function Length (Container : Map) return Count_Type with\n-     Global => null,\n-     Post   => Length'Result <= Container.Capacity;\n-\n-   pragma Unevaluated_Use_Of_Old (Allow);\n-\n-   package Formal_Model with Ghost is\n-      subtype Positive_Count_Type is Count_Type range 1 .. Count_Type'Last;\n-\n-      package M is new Ada.Containers.Functional_Maps\n-        (Element_Type    => Element_Type,\n-         Key_Type        => Key_Type,\n-         Equivalent_Keys => Equivalent_Keys);\n-\n-      function \"=\"\n-        (Left  : M.Map;\n-         Right : M.Map) return Boolean renames M.\"=\";\n-\n-      function \"<=\"\n-        (Left  : M.Map;\n-         Right : M.Map) return Boolean renames M.\"<=\";\n-\n-      package K is new Ada.Containers.Functional_Vectors\n-        (Element_Type => Key_Type,\n-         Index_Type   => Positive_Count_Type);\n-\n-      function \"=\"\n-        (Left  : K.Sequence;\n-         Right : K.Sequence) return Boolean renames K.\"=\";\n-\n-      function \"<\"\n-        (Left  : K.Sequence;\n-         Right : K.Sequence) return Boolean renames K.\"<\";\n-\n-      function \"<=\"\n-        (Left  : K.Sequence;\n-         Right : K.Sequence) return Boolean renames K.\"<=\";\n-\n-      function K_Bigger_Than_Range\n-        (Container : K.Sequence;\n-         Fst       : Positive_Count_Type;\n-         Lst       : Count_Type;\n-         Key       : Key_Type) return Boolean\n-      with\n-        Global => null,\n-        Pre    => Lst <= K.Length (Container),\n-        Post   =>\n-          K_Bigger_Than_Range'Result =\n-            (for all I in Fst .. Lst => K.Get (Container, I) < Key);\n-      pragma Annotate (GNATprove, Inline_For_Proof, K_Bigger_Than_Range);\n-\n-      function K_Smaller_Than_Range\n-        (Container : K.Sequence;\n-         Fst       : Positive_Count_Type;\n-         Lst       : Count_Type;\n-         Key       : Key_Type) return Boolean\n-      with\n-        Global => null,\n-        Pre    => Lst <= K.Length (Container),\n-        Post   =>\n-          K_Smaller_Than_Range'Result =\n-            (for all I in Fst .. Lst => Key < K.Get (Container, I));\n-      pragma Annotate (GNATprove, Inline_For_Proof, K_Smaller_Than_Range);\n-\n-      function K_Is_Find\n-        (Container : K.Sequence;\n-         Key       : Key_Type;\n-         Position  : Count_Type) return Boolean\n-      with\n-        Global => null,\n-        Pre    => Position - 1 <= K.Length (Container),\n-        Post   =>\n-          K_Is_Find'Result =\n-             ((if Position > 0 then\n-                  K_Bigger_Than_Range (Container, 1, Position - 1, Key))\n-\n-            and\n-              (if Position < K.Length (Container) then\n-                  K_Smaller_Than_Range\n-                    (Container,\n-                     Position + 1,\n-                     K.Length (Container),\n-                     Key)));\n-      pragma Annotate (GNATprove, Inline_For_Proof, K_Is_Find);\n-\n-      function Find (Container : K.Sequence; Key : Key_Type) return Count_Type\n-      --  Search for Key in Container\n-\n-      with\n-        Global => null,\n-        Post =>\n-          (if Find'Result > 0 then\n-              Find'Result <= K.Length (Container)\n-                and Equivalent_Keys (Key, K.Get (Container, Find'Result)));\n-\n-      package P is new Ada.Containers.Functional_Maps\n-        (Key_Type                       => Cursor,\n-         Element_Type                   => Positive_Count_Type,\n-         Equivalent_Keys                => \"=\",\n-         Enable_Handling_Of_Equivalence => False);\n-\n-      function \"=\"\n-        (Left  : P.Map;\n-         Right : P.Map) return Boolean renames P.\"=\";\n-\n-      function \"<=\"\n-        (Left  : P.Map;\n-         Right : P.Map) return Boolean renames P.\"<=\";\n-\n-      function P_Positions_Shifted\n-        (Small : P.Map;\n-         Big   : P.Map;\n-         Cut   : Positive_Count_Type;\n-         Count : Count_Type := 1) return Boolean\n-      with\n-        Global => null,\n-        Post   =>\n-          P_Positions_Shifted'Result =\n-\n-            --  Big contains all cursors of Small\n-\n-            (P.Keys_Included (Small, Big)\n-\n-              --  Cursors located before Cut are not moved, cursors located\n-              --  after are shifted by Count.\n-\n-              and (for all I of Small =>\n-                    (if P.Get (Small, I) < Cut then\n-                        P.Get (Big, I) = P.Get (Small, I)\n-                     else\n-                        P.Get (Big, I) - Count = P.Get (Small, I)))\n-\n-              --  New cursors of Big (if any) are between Cut and Cut - 1 +\n-              --  Count.\n-\n-              and (for all I of Big =>\n-                    P.Has_Key (Small, I)\n-                      or P.Get (Big, I) - Count in Cut - Count  .. Cut - 1));\n-\n-      function Model (Container : Map) return M.Map with\n-      --  The high-level model of a map is a map from keys to elements. Neither\n-      --  cursors nor order of elements are represented in this model. Keys are\n-      --  modeled up to equivalence.\n-\n-        Ghost,\n-        Global => null;\n-\n-      function Keys (Container : Map) return K.Sequence with\n-      --  The Keys sequence represents the underlying list structure of maps\n-      --  that is used for iteration. It stores the actual values of keys in\n-      --  the map. It does not model cursors nor elements.\n-\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          K.Length (Keys'Result) = Length (Container)\n-\n-            --  It only contains keys contained in Model\n-\n-            and (for all Key of Keys'Result =>\n-                  M.Has_Key (Model (Container), Key))\n-\n-            --  It contains all the keys contained in Model\n-\n-            and (for all Key of Model (Container) =>\n-                  (Find (Keys'Result, Key) > 0\n-                    and then Equivalent_Keys\n-                               (K.Get (Keys'Result, Find (Keys'Result, Key)),\n-                                Key)))\n-\n-            --  It is sorted in increasing order\n-\n-            and (for all I in 1 .. Length (Container) =>\n-                  Find (Keys'Result, K.Get (Keys'Result, I)) = I\n-                    and K_Is_Find (Keys'Result, K.Get (Keys'Result, I), I));\n-      pragma Annotate (GNATprove, Iterable_For_Proof, \"Model\", Keys);\n-\n-      function Positions (Container : Map) return P.Map with\n-      --  The Positions map is used to model cursors. It only contains valid\n-      --  cursors and maps them to their position in the container.\n-\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          not P.Has_Key (Positions'Result, No_Element)\n-\n-            --  Positions of cursors are smaller than the container's length.\n-\n-            and then\n-              (for all I of Positions'Result =>\n-                P.Get (Positions'Result, I) in 1 .. Length (Container)\n-\n-            --  No two cursors have the same position. Note that we do not\n-            --  state that there is a cursor in the map for each position, as\n-            --  it is rarely needed.\n-\n-            and then\n-              (for all J of Positions'Result =>\n-                (if P.Get (Positions'Result, I) = P.Get (Positions'Result, J)\n-                 then I = J)));\n-\n-      procedure Lift_Abstraction_Level (Container : Map) with\n-        --  Lift_Abstraction_Level is a ghost procedure that does nothing but\n-        --  assume that we can access the same elements by iterating over\n-        --  positions or cursors.\n-        --  This information is not generally useful except when switching from\n-        --  a low-level, cursor-aware view of a container, to a high-level,\n-        --  position-based view.\n-\n-        Ghost,\n-        Global => null,\n-        Post   =>\n-          (for all Key of Keys (Container) =>\n-            (for some I of Positions (Container) =>\n-              K.Get (Keys (Container), P.Get (Positions (Container), I)) =\n-                Key));\n-\n-      function Contains\n-        (C : M.Map;\n-         K : Key_Type) return Boolean renames M.Has_Key;\n-      --  To improve readability of contracts, we rename the function used to\n-      --  search for a key in the model to Contains.\n-\n-      function Element\n-        (C : M.Map;\n-         K : Key_Type) return Element_Type renames M.Get;\n-      --  To improve readability of contracts, we rename the function used to\n-      --  access an element in the model to Element.\n-   end Formal_Model;\n-   use Formal_Model;\n-\n-   function \"=\" (Left, Right : Map) return Boolean with\n-     Global => null,\n-     Post   => \"=\"'Result = (Model (Left) = Model (Right));\n-\n-   function Is_Empty (Container : Map) return Boolean with\n-     Global => null,\n-     Post   => Is_Empty'Result = (Length (Container) = 0);\n-\n-   procedure Clear (Container : in out Map) with\n-     Global => null,\n-     Post   => Length (Container) = 0 and M.Is_Empty (Model (Container));\n-\n-   procedure Assign (Target : in out Map; Source : Map) with\n-     Global => null,\n-     Pre    => Target.Capacity >= Length (Source),\n-     Post   =>\n-       Model (Target) = Model (Source)\n-         and Keys (Target) = Keys (Source)\n-         and Length (Source) = Length (Target);\n-\n-   function Copy (Source : Map; Capacity : Count_Type := 0) return Map with\n-     Global => null,\n-     Pre    => Capacity = 0 or else Capacity >= Source.Capacity,\n-     Post   =>\n-       Model (Copy'Result) = Model (Source)\n-         and Keys (Copy'Result) = Keys (Source)\n-         and Positions (Copy'Result) = Positions (Source)\n-         and (if Capacity = 0 then\n-                 Copy'Result.Capacity = Source.Capacity\n-              else\n-                 Copy'Result.Capacity = Capacity);\n-\n-   function Key (Container : Map; Position : Cursor) return Key_Type with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Key'Result =\n-         K.Get (Keys (Container), P.Get (Positions (Container), Position));\n-   pragma Annotate (GNATprove, Inline_For_Proof, Key);\n-\n-   function Element\n-     (Container : Map;\n-      Position  : Cursor) return Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Element'Result = Element (Model (Container), Key (Container, Position));\n-   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n-\n-   procedure Replace_Element\n-     (Container : in out Map;\n-      Position  : Cursor;\n-      New_Item  : Element_Type)\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-\n-       --  Order of keys and cursors is preserved\n-\n-       Keys (Container) = Keys (Container)'Old\n-         and Positions (Container) = Positions (Container)'Old\n-\n-         --  New_Item is now associated with the key at position Position in\n-         --  Container.\n-\n-         and Element (Container, Position) = New_Item\n-\n-         --  Elements associated with other keys are preserved\n-\n-         and M.Same_Keys (Model (Container), Model (Container)'Old)\n-         and M.Elements_Equal_Except\n-               (Model (Container),\n-                Model (Container)'Old,\n-                Key (Container, Position));\n-\n-   function At_End\n-     (E : not null access constant Map) return not null access constant Map\n-   is (E)\n-   with Ghost,\n-     Annotate => (GNATprove, At_End_Borrow);\n-\n-   function At_End\n-     (E : access constant Element_Type) return access constant Element_Type\n-   is (E)\n-   with Ghost,\n-     Annotate => (GNATprove, At_End_Borrow);\n-\n-   function Constant_Reference\n-     (Container : aliased Map;\n-      Position  : Cursor) return not null access constant Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container, Position),\n-     Post   =>\n-       Constant_Reference'Result.all =\n-           Element (Model (Container), Key (Container, Position));\n-\n-   function Reference\n-     (Container : not null access Map;\n-      Position  : Cursor) return not null access Element_Type\n-   with\n-     Global => null,\n-     Pre    => Has_Element (Container.all, Position),\n-     Post   =>\n-\n-       --  Order of keys and cursors is preserved\n-\n-       Keys (At_End (Container).all) = Keys (Container.all)\n-         and Positions (At_End (Container).all) = Positions (Container.all)\n-\n-         --  The value designated by the result of Reference is now associated\n-         --  with the key at position Position in Container.\n-\n-         and Element (At_End (Container).all, Position) =\n-               At_End (Reference'Result).all\n-\n-         --  Elements associated with other keys are preserved\n-\n-         and M.Same_Keys\n-               (Model (At_End (Container).all),\n-                Model (Container.all))\n-         and M.Elements_Equal_Except\n-               (Model (At_End (Container).all),\n-                Model (Container.all),\n-                Key (At_End (Container).all, Position));\n-\n-   function Constant_Reference\n-     (Container : aliased Map;\n-      Key       : Key_Type) return not null access constant Element_Type\n-   with\n-     Global => null,\n-     Pre    => Contains (Container, Key),\n-     Post   =>\n-       Constant_Reference'Result.all = Element (Model (Container), Key);\n-\n-   function Reference\n-     (Container : not null access Map;\n-      Key       : Key_Type) return not null access Element_Type\n-   with\n-     Global => null,\n-     Pre    => Contains (Container.all, Key),\n-     Post   =>\n-\n-       --  Order of keys and cursors is preserved\n-\n-       Keys (At_End (Container).all) = Keys (Container.all)\n-         and Positions (At_End (Container).all) = Positions (Container.all)\n-\n-         --  The value designated by the result of Reference is now associated\n-         --  with Key in Container.\n-\n-         and Element (Model (At_End (Container).all), Key) =\n-               At_End (Reference'Result).all\n-\n-         --  Elements associated with other keys are preserved\n-\n-         and M.Same_Keys\n-               (Model (At_End (Container).all),\n-                Model (Container.all))\n-         and M.Elements_Equal_Except\n-               (Model (At_End (Container).all),\n-                Model (Container.all),\n-                Key);\n-\n-   procedure Move (Target : in out Map; Source : in out Map) with\n-     Global => null,\n-     Pre    => Target.Capacity >= Length (Source),\n-     Post   =>\n-       Model (Target) = Model (Source)'Old\n-         and Keys (Target) = Keys (Source)'Old\n-         and Length (Source)'Old = Length (Target)\n-         and Length (Source) = 0;\n-\n-   procedure Insert\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor;\n-      Inserted  : out Boolean)\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Length (Container) < Container.Capacity or Contains (Container, Key),\n-     Post           =>\n-       Contains (Container, Key)\n-         and Has_Element (Container, Position)\n-         and Equivalent_Keys\n-               (Formal_Ordered_Maps.Key (Container, Position), Key)\n-         and K_Is_Find\n-               (Keys (Container),\n-                Key,\n-                P.Get (Positions (Container), Position)),\n-     Contract_Cases =>\n-\n-       --  If Key is already in Container, it is not modified and Inserted is\n-       --  set to False.\n-\n-       (Contains (Container, Key) =>\n-          not Inserted\n-            and Model (Container) = Model (Container)'Old\n-            and Keys (Container) = Keys (Container)'Old\n-            and Positions (Container) = Positions (Container)'Old,\n-\n-        --  Otherwise, Key is inserted in Container and Inserted is set to True\n-\n-        others =>\n-          Inserted\n-            and Length (Container) = Length (Container)'Old + 1\n-\n-            --  Key now maps to New_Item\n-\n-            and Formal_Ordered_Maps.Key (Container, Position) = Key\n-            and Element (Model (Container), Key) = New_Item\n-\n-            --  Other mappings are preserved\n-\n-            and Model (Container)'Old <= Model (Container)\n-            and M.Keys_Included_Except\n-                  (Model (Container),\n-                   Model (Container)'Old,\n-                   Key)\n-\n-            --  The keys of Container located before Position are preserved\n-\n-            and K.Range_Equal\n-                  (Left  => Keys (Container)'Old,\n-                   Right => Keys (Container),\n-                   Fst   => 1,\n-                   Lst   => P.Get (Positions (Container), Position) - 1)\n-\n-            --  Other keys are shifted by 1\n-\n-            and K.Range_Shifted\n-                  (Left   => Keys (Container)'Old,\n-                   Right  => Keys (Container),\n-                   Fst    => P.Get (Positions (Container), Position),\n-                   Lst    => Length (Container)'Old,\n-                   Offset => 1)\n-\n-            --  A new cursor has been inserted at position Position in\n-            --  Container.\n-\n-            and P_Positions_Shifted\n-                  (Positions (Container)'Old,\n-                   Positions (Container),\n-                   Cut => P.Get (Positions (Container), Position)));\n-\n-   procedure Insert\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type)\n-   with\n-     Global => null,\n-     Pre    =>\n-       Length (Container) < Container.Capacity\n-         and then (not Contains (Container, Key)),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old + 1\n-         and Contains (Container, Key)\n-\n-         --  Key now maps to New_Item\n-\n-         and K.Get (Keys (Container), Find (Keys (Container), Key)) = Key\n-         and Element (Model (Container), Key) = New_Item\n-\n-         --  Other mappings are preserved\n-\n-         and Model (Container)'Old <= Model (Container)\n-         and M.Keys_Included_Except\n-               (Model (Container),\n-                Model (Container)'Old,\n-                Key)\n-\n-         --  The keys of Container located before Key are preserved\n-\n-         and K.Range_Equal\n-               (Left  => Keys (Container)'Old,\n-                Right => Keys (Container),\n-                Fst   => 1,\n-                Lst   => Find (Keys (Container), Key) - 1)\n-\n-         --  Other keys are shifted by 1\n-\n-         and K.Range_Shifted\n-               (Left   => Keys (Container)'Old,\n-                Right  => Keys (Container),\n-                Fst    => Find (Keys (Container), Key),\n-                Lst    => Length (Container)'Old,\n-                Offset => 1)\n-\n-         --  A new cursor has been inserted in Container\n-\n-         and P_Positions_Shifted\n-               (Positions (Container)'Old,\n-                Positions (Container),\n-                Cut => Find (Keys (Container), Key));\n-\n-   procedure Include\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type)\n-   with\n-     Global         => null,\n-     Pre            =>\n-       Length (Container) < Container.Capacity or Contains (Container, Key),\n-     Post           =>\n-       Contains (Container, Key) and Element (Container, Key) = New_Item,\n-     Contract_Cases =>\n-\n-       --  If Key is already in Container, Key is mapped to New_Item\n-\n-       (Contains (Container, Key) =>\n-\n-          --  Cursors are preserved\n-\n-          Positions (Container) = Positions (Container)'Old\n-\n-            --  The key equivalent to Key in Container is replaced by Key\n-\n-            and K.Get\n-                  (Keys (Container), Find (Keys (Container), Key)) = Key\n-\n-            and K.Equal_Except\n-                  (Keys (Container)'Old,\n-                   Keys (Container),\n-                   Find (Keys (Container), Key))\n-\n-            --  Elements associated with other keys are preserved\n-\n-            and M.Same_Keys (Model (Container), Model (Container)'Old)\n-            and M.Elements_Equal_Except\n-                  (Model (Container),\n-                   Model (Container)'Old,\n-                   Key),\n-\n-        --  Otherwise, Key is inserted in Container\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old + 1\n-\n-            --  Other mappings are preserved\n-\n-            and Model (Container)'Old <= Model (Container)\n-            and M.Keys_Included_Except\n-                  (Model (Container),\n-                   Model (Container)'Old,\n-                   Key)\n-\n-            --  Key is inserted in Container\n-\n-            and K.Get\n-                  (Keys (Container), Find (Keys (Container), Key)) = Key\n-\n-            --  The keys of Container located before Key are preserved\n-\n-            and K.Range_Equal\n-                  (Left  => Keys (Container)'Old,\n-                   Right => Keys (Container),\n-                   Fst   => 1,\n-                   Lst   => Find (Keys (Container), Key) - 1)\n-\n-            --  Other keys are shifted by 1\n-\n-            and K.Range_Shifted\n-                  (Left   => Keys (Container)'Old,\n-                   Right  => Keys (Container),\n-                   Fst    => Find (Keys (Container), Key),\n-                   Lst    => Length (Container)'Old,\n-                   Offset => 1)\n-\n-            --  A new cursor has been inserted in Container\n-\n-            and P_Positions_Shifted\n-                  (Positions (Container)'Old,\n-                   Positions (Container),\n-                   Cut => Find (Keys (Container), Key)));\n-\n-   procedure Replace\n-     (Container : in out Map;\n-      Key       : Key_Type;\n-      New_Item  : Element_Type)\n-   with\n-     Global => null,\n-     Pre    => Contains (Container, Key),\n-     Post   =>\n-\n-       --  Cursors are preserved\n-\n-       Positions (Container) = Positions (Container)'Old\n-\n-         --  The key equivalent to Key in Container is replaced by Key\n-\n-         and K.Get (Keys (Container), Find (Keys (Container), Key)) = Key\n-         and K.Equal_Except\n-              (Keys (Container)'Old,\n-               Keys (Container),\n-               Find (Keys (Container), Key))\n-\n-         --  New_Item is now associated with the Key in Container\n-\n-         and Element (Model (Container), Key) = New_Item\n-\n-         --  Elements associated with other keys are preserved\n-\n-         and M.Same_Keys (Model (Container), Model (Container)'Old)\n-         and M.Elements_Equal_Except\n-               (Model (Container),\n-                Model (Container)'Old,\n-                Key);\n-\n-   procedure Exclude (Container : in out Map; Key : Key_Type) with\n-     Global         => null,\n-     Post           => not Contains (Container, Key),\n-     Contract_Cases =>\n-\n-       --  If Key is not in Container, nothing is changed\n-\n-       (not Contains (Container, Key) =>\n-          Model (Container) = Model (Container)'Old\n-            and Keys (Container) = Keys (Container)'Old\n-            and Positions (Container) = Positions (Container)'Old,\n-\n-        --  Otherwise, Key is removed from Container\n-\n-        others =>\n-          Length (Container) = Length (Container)'Old - 1\n-\n-            --  Other mappings are preserved\n-\n-            and Model (Container) <= Model (Container)'Old\n-            and M.Keys_Included_Except\n-                  (Model (Container)'Old,\n-                   Model (Container),\n-                   Key)\n-\n-            --  The keys of Container located before Key are preserved\n-\n-            and K.Range_Equal\n-                  (Left  => Keys (Container)'Old,\n-                   Right => Keys (Container),\n-                   Fst   => 1,\n-                   Lst   => Find (Keys (Container), Key)'Old - 1)\n-\n-            --  The keys located after Key are shifted by 1\n-\n-            and K.Range_Shifted\n-                  (Left   => Keys (Container),\n-                   Right  => Keys (Container)'Old,\n-                   Fst    => Find (Keys (Container), Key)'Old,\n-                   Lst    => Length (Container),\n-                   Offset => 1)\n-\n-            --  A cursor has been removed from Container\n-\n-            and P_Positions_Shifted\n-                  (Positions (Container),\n-                   Positions (Container)'Old,\n-                   Cut   => Find (Keys (Container), Key)'Old));\n-\n-   procedure Delete (Container : in out Map; Key : Key_Type) with\n-     Global => null,\n-     Pre    => Contains (Container, Key),\n-     Post   =>\n-       Length (Container) = Length (Container)'Old - 1\n-\n-         --  Key is no longer in Container\n-\n-         and not Contains (Container, Key)\n-\n-         --  Other mappings are preserved\n-\n-         and Model (Container) <= Model (Container)'Old\n-         and M.Keys_Included_Except\n-               (Model (Container)'Old,\n-                Model (Container),\n-                Key)\n-\n-         --  The keys of Container located before Key are preserved\n-\n-         and K.Range_Equal\n-               (Left  => Keys (Container)'Old,\n-                Right => Keys (Container),\n-                Fst   => 1,\n-                Lst   => Find (Keys (Container), Key)'Old - 1)\n-\n-         --  The keys located after Key are shifted by 1\n-\n-         and K.Range_Shifted\n-               (Left   => Keys (Container),\n-                Right  => Keys (Container)'Old,\n-                Fst    => Find (Keys (Container), Key)'Old,\n-                Lst    => Length (Container),\n-                Offset => 1)\n-\n-         --  A cursor has been removed from Container\n-\n-         and P_Positions_Shifted\n-               (Positions (Container),\n-                Positions (Container)'Old,\n-                Cut   => Find (Keys (Container), Key)'Old);\n-\n-   procedure Delete (Container : in out Map; Position : in out Cursor) with\n-     Global  => null,\n-     Depends => (Container =>+ Position, Position => null),\n-     Pre     => Has_Element (Container, Position),\n-     Post    =>\n-       Position = No_Element\n-         and Length (Container) = Length (Container)'Old - 1\n-\n-         --  The key at position Position is no longer in Container\n-\n-         and not Contains (Container, Key (Container, Position)'Old)\n-         and not P.Has_Key (Positions (Container), Position'Old)\n-\n-         --  Other mappings are preserved\n-\n-         and Model (Container) <= Model (Container)'Old\n-         and M.Keys_Included_Except\n-               (Model (Container)'Old,\n-                Model (Container),\n-                Key (Container, Position)'Old)\n-\n-         --  The keys of Container located before Position are preserved.\n-\n-         and K.Range_Equal\n-               (Left  => Keys (Container)'Old,\n-                Right => Keys (Container),\n-                Fst   => 1,\n-                Lst   => P.Get (Positions (Container)'Old, Position'Old) - 1)\n-\n-         --  The keys located after Position are shifted by 1\n-\n-         and K.Range_Shifted\n-               (Left   => Keys (Container),\n-                Right  => Keys (Container)'Old,\n-                Fst    => P.Get (Positions (Container)'Old, Position'Old),\n-                Lst    => Length (Container),\n-                Offset => 1)\n-\n-         --  Position has been removed from Container\n-\n-         and P_Positions_Shifted\n-               (Positions (Container),\n-                Positions (Container)'Old,\n-                Cut   => P.Get (Positions (Container)'Old, Position'Old));\n-\n-   procedure Delete_First (Container : in out Map) with\n-     Global         => null,\n-     Contract_Cases =>\n-       (Length (Container) = 0 => Length (Container) = 0,\n-        others =>\n-          Length (Container) = Length (Container)'Old - 1\n-\n-            --  The first key has been removed from Container\n-\n-            and not Contains (Container, First_Key (Container)'Old)\n-\n-            --  Other mappings are preserved\n-\n-            and Model (Container) <= Model (Container)'Old\n-            and M.Keys_Included_Except\n-                  (Model (Container)'Old,\n-                   Model (Container),\n-                    First_Key (Container)'Old)\n-\n-            --  Other keys are shifted by 1\n-\n-            and K.Range_Shifted\n-                  (Left   => Keys (Container),\n-                   Right  => Keys (Container)'Old,\n-                   Fst    => 1,\n-                   Lst    => Length (Container),\n-                   Offset => 1)\n-\n-            --  First has been removed from Container\n-\n-            and P_Positions_Shifted\n-                  (Positions (Container),\n-                   Positions (Container)'Old,\n-                   Cut   => 1));\n-\n-   procedure Delete_Last (Container : in out Map) with\n-     Global         => null,\n-     Contract_Cases =>\n-       (Length (Container) = 0 => Length (Container) = 0,\n-        others =>\n-          Length (Container) = Length (Container)'Old - 1\n-\n-            --  The last key has been removed from Container\n-\n-            and not Contains (Container, Last_Key (Container)'Old)\n-\n-            --  Other mappings are preserved\n-\n-            and Model (Container) <= Model (Container)'Old\n-            and M.Keys_Included_Except\n-                  (Model (Container)'Old,\n-                   Model (Container),\n-                   Last_Key (Container)'Old)\n-\n-            --  Others keys of Container are preserved\n-\n-            and K.Range_Equal\n-                  (Left  => Keys (Container)'Old,\n-                   Right => Keys (Container),\n-                   Fst   => 1,\n-                   Lst   => Length (Container))\n-\n-            --  Last cursor has been removed from Container\n-\n-            and Positions (Container) <= Positions (Container)'Old);\n-\n-   function First (Container : Map) return Cursor with\n-     Global         => null,\n-     Contract_Cases =>\n-       (Length (Container) = 0 =>\n-          First'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, First'Result)\n-            and P.Get (Positions (Container), First'Result) = 1);\n-\n-   function First_Element (Container : Map) return Element_Type with\n-     Global => null,\n-     Pre    => not Is_Empty (Container),\n-     Post   =>\n-       First_Element'Result =\n-         Element (Model (Container), First_Key (Container));\n-\n-   function First_Key (Container : Map) return Key_Type with\n-     Global => null,\n-     Pre    => not Is_Empty (Container),\n-     Post   =>\n-       First_Key'Result = K.Get (Keys (Container), 1)\n-         and K_Smaller_Than_Range\n-               (Keys (Container), 2, Length (Container), First_Key'Result);\n-\n-   function Last (Container : Map) return Cursor with\n-     Global         => null,\n-     Contract_Cases =>\n-       (Length (Container) = 0 =>\n-          Last'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Last'Result)\n-            and P.Get (Positions (Container), Last'Result) =\n-                  Length (Container));\n-\n-   function Last_Element (Container : Map) return Element_Type with\n-     Global => null,\n-     Pre    => not Is_Empty (Container),\n-     Post   =>\n-       Last_Element'Result = Element (Model (Container), Last_Key (Container));\n-\n-   function Last_Key (Container : Map) return Key_Type with\n-     Global => null,\n-     Pre    => not Is_Empty (Container),\n-     Post   =>\n-       Last_Key'Result = K.Get (Keys (Container), Length (Container))\n-         and K_Bigger_Than_Range\n-               (Keys (Container), 1, Length (Container) - 1, Last_Key'Result);\n-\n-   function Next (Container : Map; Position : Cursor) return Cursor with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = Length (Container)\n-        =>\n-          Next'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Next'Result)\n-            and then P.Get (Positions (Container), Next'Result) =\n-                     P.Get (Positions (Container), Position) + 1);\n-\n-   procedure Next (Container : Map; Position : in out Cursor) with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = Length (Container)\n-        =>\n-          Position = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Position)\n-            and then P.Get (Positions (Container), Position) =\n-                     P.Get (Positions (Container), Position'Old) + 1);\n-\n-   function Previous (Container : Map; Position : Cursor) return Cursor with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = 1\n-        =>\n-          Previous'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Previous'Result)\n-            and then P.Get (Positions (Container), Previous'Result) =\n-                     P.Get (Positions (Container), Position) - 1);\n-\n-   procedure Previous (Container : Map; Position : in out Cursor) with\n-     Global         => null,\n-     Pre            =>\n-       Has_Element (Container, Position) or else Position = No_Element,\n-     Contract_Cases =>\n-       (Position = No_Element\n-          or else P.Get (Positions (Container), Position) = 1\n-        =>\n-          Position = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Position)\n-            and then P.Get (Positions (Container), Position) =\n-                     P.Get (Positions (Container), Position'Old) - 1);\n-\n-   function Find (Container : Map; Key : Key_Type) return Cursor with\n-     Global         => null,\n-     Contract_Cases =>\n-\n-       --  If Key is not contained in Container, Find returns No_Element\n-\n-       (not Contains (Model (Container), Key) =>\n-          not P.Has_Key (Positions (Container), Find'Result)\n-            and Find'Result = No_Element,\n-\n-        --  Otherwise, Find returns a valid cursor in Container\n-\n-        others =>\n-          P.Has_Key (Positions (Container), Find'Result)\n-            and P.Get (Positions (Container), Find'Result) =\n-                Find (Keys (Container), Key)\n-\n-            --  The key designated by the result of Find is Key\n-\n-            and Equivalent_Keys\n-                  (Formal_Ordered_Maps.Key (Container, Find'Result), Key));\n-\n-   function Element (Container : Map; Key : Key_Type) return Element_Type with\n-     Global => null,\n-     Pre    => Contains (Container, Key),\n-     Post   => Element'Result = Element (Model (Container), Key);\n-   pragma Annotate (GNATprove, Inline_For_Proof, Element);\n-\n-   function Floor (Container : Map; Key : Key_Type) return Cursor with\n-     Global         => null,\n-     Contract_Cases =>\n-       (Length (Container) = 0 or else Key < First_Key (Container) =>\n-          Floor'Result = No_Element,\n-\n-        others =>\n-          Has_Element (Container, Floor'Result)\n-            and not (Key < K.Get (Keys (Container),\n-                                  P.Get (Positions (Container), Floor'Result)))\n-            and K_Is_Find\n-                  (Keys (Container),\n-                   Key,\n-                   P.Get (Positions (Container), Floor'Result)));\n-\n-   function Ceiling (Container : Map; Key : Key_Type) return Cursor with\n-     Global         => null,\n-     Contract_Cases =>\n-       (Length (Container) = 0 or else Last_Key (Container) < Key =>\n-          Ceiling'Result = No_Element,\n-        others =>\n-          Has_Element (Container, Ceiling'Result)\n-            and not (K.Get\n-                       (Keys (Container),\n-                        P.Get (Positions (Container), Ceiling'Result)) < Key)\n-            and K_Is_Find\n-                  (Keys (Container),\n-                   Key,\n-                   P.Get (Positions (Container), Ceiling'Result)));\n-\n-   function Contains (Container : Map; Key : Key_Type) return Boolean with\n-     Global => null,\n-     Post   => Contains'Result = Contains (Model (Container), Key);\n-   pragma Annotate (GNATprove, Inline_For_Proof, Contains);\n-\n-   function Has_Element (Container : Map; Position : Cursor) return Boolean\n-   with\n-     Global => null,\n-     Post   =>\n-       Has_Element'Result = P.Has_Key (Positions (Container), Position);\n-   pragma Annotate (GNATprove, Inline_For_Proof, Has_Element);\n-\n-private\n-   pragma SPARK_Mode (Off);\n-\n-   pragma Inline (Next);\n-   pragma Inline (Previous);\n-\n-   subtype Node_Access is Count_Type;\n-\n-   use Red_Black_Trees;\n-\n-   type Node_Type is record\n-      Has_Element : Boolean := False;\n-      Parent  : Node_Access := 0;\n-      Left    : Node_Access := 0;\n-      Right   : Node_Access := 0;\n-      Color   : Red_Black_Trees.Color_Type := Red;\n-      Key     : Key_Type;\n-      Element : aliased Element_Type;\n-   end record;\n-\n-   package Tree_Types is\n-     new Ada.Containers.Red_Black_Trees.Generic_Bounded_Tree_Types (Node_Type);\n-\n-   type Map (Capacity : Count_Type) is record\n-     Content : Tree_Types.Tree_Type (Capacity);\n-   end record;\n+package Ada.Containers.Formal_Ordered_Maps with SPARK_Mode is\n \n-   Empty_Map : constant Map := (Capacity => 0, others => <>);\n+   pragma Compile_Time_Error\n+     (True,\n+      \"This package has been moved to the SPARK library shipped with any\"\n+      & \" SPARK release starting with version 23.\");\n \n end Ada.Containers.Formal_Ordered_Maps;"}, {"sha": "e5cddde498527a039ca006f0d8b827ba41e866a5", "filename": "gcc/ada/libgnat/a-cforse.adb", "status": "removed", "additions": 0, "deletions": 1939, "changes": 1939, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cforse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cforse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cforse.adb?ref=cf8af60f6a3910577e99db04dbc757e731558144", "patch": "@@ -1,1939 +0,0 @@\n-------------------------------------------------------------------------------\n---                                                                          --\n---                         GNAT LIBRARY COMPONENTS                          --\n---                                                                          --\n---   A D A . C O N T A I N E R S . F O R M A L _ O R D E R E D _ S E T S    --\n---                                                                          --\n---                                 B o d y                                  --\n---                                                                          --\n---          Copyright (C) 2010-2022, Free Software Foundation, Inc.         --\n---                                                                          --\n--- GNAT is free software;  you can  redistribute it  and/or modify it under --\n--- terms of the  GNU General Public License as published  by the Free Soft- --\n--- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n--- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n--- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n--- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n---                                                                          --\n--- As a special exception under Section 7 of GPL version 3, you are granted --\n--- additional permissions described in the GCC Runtime Library Exception,   --\n--- version 3.1, as published by the Free Software Foundation.               --\n---                                                                          --\n--- You should have received a copy of the GNU General Public License and    --\n--- a copy of the GCC Runtime Library Exception along with this program;     --\n--- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n--- <http://www.gnu.org/licenses/>.                                          --\n-------------------------------------------------------------------------------\n-\n-with Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations;\n-pragma Elaborate_All\n-  (Ada.Containers.Red_Black_Trees.Generic_Bounded_Operations);\n-\n-with Ada.Containers.Red_Black_Trees.Generic_Bounded_Keys;\n-pragma Elaborate_All (Ada.Containers.Red_Black_Trees.Generic_Bounded_Keys);\n-\n-with Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations;\n-pragma Elaborate_All\n-  (Ada.Containers.Red_Black_Trees.Generic_Bounded_Set_Operations);\n-\n-with System; use type System.Address;\n-\n-package body Ada.Containers.Formal_Ordered_Sets with\n-  SPARK_Mode => Off\n-is\n-\n-   ------------------------------\n-   -- Access to Fields of Node --\n-   ------------------------------\n-\n-   --  These subprograms provide functional notation for access to fields\n-   --  of a node, and procedural notation for modifiying these fields.\n-\n-   function Color (Node : Node_Type) return Red_Black_Trees.Color_Type;\n-   pragma Inline (Color);\n-\n-   function Left_Son (Node : Node_Type) return Count_Type;\n-   pragma Inline (Left_Son);\n-\n-   function Parent (Node : Node_Type) return Count_Type;\n-   pragma Inline (Parent);\n-\n-   function Right_Son (Node : Node_Type) return Count_Type;\n-   pragma Inline (Right_Son);\n-\n-   procedure Set_Color\n-     (Node  : in out Node_Type;\n-      Color : Red_Black_Trees.Color_Type);\n-   pragma Inline (Set_Color);\n-\n-   procedure Set_Left (Node : in out Node_Type; Left : Count_Type);\n-   pragma Inline (Set_Left);\n-\n-   procedure Set_Right (Node : in out Node_Type; Right : Count_Type);\n-   pragma Inline (Set_Right);\n-\n-   procedure Set_Parent (Node : in out Node_Type; Parent : Count_Type);\n-   pragma Inline (Set_Parent);\n-\n-   -----------------------\n-   -- Local Subprograms --\n-   -----------------------\n-\n-   --  Comments needed???\n-\n-   procedure Assign\n-     (Target : in out Tree_Types.Tree_Type;\n-      Source : Tree_Types.Tree_Type);\n-\n-   generic\n-      with procedure Set_Element (Node : in out Node_Type);\n-   procedure Generic_Allocate\n-     (Tree : in out Tree_Types.Tree_Type'Class;\n-      Node : out Count_Type);\n-\n-   procedure Free (Tree : in out Set; X : Count_Type);\n-\n-   procedure Insert_Sans_Hint\n-     (Container : in out Tree_Types.Tree_Type;\n-      New_Item  : Element_Type;\n-      Node      : out Count_Type;\n-      Inserted  : out Boolean);\n-\n-   procedure Insert_With_Hint\n-     (Dst_Set  : in out Tree_Types.Tree_Type;\n-      Dst_Hint : Count_Type;\n-      Src_Node : Node_Type;\n-      Dst_Node : out Count_Type);\n-\n-   function Is_Greater_Element_Node\n-     (Left  : Element_Type;\n-      Right : Node_Type) return Boolean;\n-   pragma Inline (Is_Greater_Element_Node);\n-\n-   function Is_Less_Element_Node\n-     (Left  : Element_Type;\n-      Right : Node_Type) return Boolean;\n-   pragma Inline (Is_Less_Element_Node);\n-\n-   function Is_Less_Node_Node (L, R : Node_Type) return Boolean;\n-   pragma Inline (Is_Less_Node_Node);\n-\n-   procedure Replace_Element\n-     (Tree : in out Set;\n-      Node : Count_Type;\n-      Item : Element_Type);\n-\n-   --------------------------\n-   -- Local Instantiations --\n-   --------------------------\n-\n-   package Tree_Operations is\n-     new Red_Black_Trees.Generic_Bounded_Operations\n-       (Tree_Types,\n-        Left  => Left_Son,\n-        Right => Right_Son);\n-\n-   use Tree_Operations;\n-\n-   package Element_Keys is\n-     new Red_Black_Trees.Generic_Bounded_Keys\n-       (Tree_Operations     => Tree_Operations,\n-        Key_Type            => Element_Type,\n-        Is_Less_Key_Node    => Is_Less_Element_Node,\n-        Is_Greater_Key_Node => Is_Greater_Element_Node);\n-\n-   package Set_Ops is\n-     new Red_Black_Trees.Generic_Bounded_Set_Operations\n-       (Tree_Operations  => Tree_Operations,\n-        Set_Type         => Tree_Types.Tree_Type,\n-        Assign           => Assign,\n-        Insert_With_Hint => Insert_With_Hint,\n-        Is_Less          => Is_Less_Node_Node);\n-\n-   ---------\n-   -- \"=\" --\n-   ---------\n-\n-   function \"=\" (Left, Right : Set) return Boolean is\n-      Lst   : Count_Type;\n-      Node  : Count_Type;\n-      ENode : Count_Type;\n-\n-   begin\n-      if Length (Left) /= Length (Right) then\n-         return False;\n-      end if;\n-\n-      if Is_Empty (Left) then\n-         return True;\n-      end if;\n-\n-      Lst := Next (Left.Content, Last (Left).Node);\n-\n-      Node := First (Left).Node;\n-      while Node /= Lst loop\n-         ENode := Find (Right, Left.Content.Nodes (Node).Element).Node;\n-         if ENode = 0\n-           or else Left.Content.Nodes (Node).Element /=\n-           Right.Content.Nodes (ENode).Element\n-         then\n-            return False;\n-         end if;\n-\n-         Node := Next (Left.Content, Node);\n-      end loop;\n-\n-      return True;\n-   end \"=\";\n-\n-   ------------\n-   -- Assign --\n-   ------------\n-\n-   procedure Assign\n-     (Target : in out Tree_Types.Tree_Type;\n-      Source : Tree_Types.Tree_Type)\n-   is\n-      procedure Append_Element (Source_Node : Count_Type);\n-\n-      procedure Append_Elements is\n-        new Tree_Operations.Generic_Iteration (Append_Element);\n-\n-      --------------------\n-      -- Append_Element --\n-      --------------------\n-\n-      procedure Append_Element (Source_Node : Count_Type) is\n-         SN : Node_Type renames Source.Nodes (Source_Node);\n-\n-         procedure Set_Element (Node : in out Node_Type);\n-         pragma Inline (Set_Element);\n-\n-         function New_Node return Count_Type;\n-         pragma Inline (New_Node);\n-\n-         procedure Insert_Post is\n-           new Element_Keys.Generic_Insert_Post (New_Node);\n-\n-         procedure Unconditional_Insert_Sans_Hint is\n-           new Element_Keys.Generic_Unconditional_Insert (Insert_Post);\n-\n-         procedure Unconditional_Insert_Avec_Hint is\n-           new Element_Keys.Generic_Unconditional_Insert_With_Hint\n-                 (Insert_Post,\n-                  Unconditional_Insert_Sans_Hint);\n-\n-         procedure Allocate is new Generic_Allocate (Set_Element);\n-\n-         --------------\n-         -- New_Node --\n-         --------------\n-\n-         function New_Node return Count_Type is\n-            Result : Count_Type;\n-         begin\n-            Allocate (Target, Result);\n-            return Result;\n-         end New_Node;\n-\n-         -----------------\n-         -- Set_Element --\n-         -----------------\n-\n-         procedure Set_Element (Node : in out Node_Type) is\n-         begin\n-            Node.Element := SN.Element;\n-         end Set_Element;\n-\n-         --  Local variables\n-\n-         Target_Node : Count_Type;\n-\n-      --  Start of processing for Append_Element\n-\n-      begin\n-         Unconditional_Insert_Avec_Hint\n-           (Tree  => Target,\n-            Hint  => 0,\n-            Key   => SN.Element,\n-            Node  => Target_Node);\n-      end Append_Element;\n-\n-   --  Start of processing for Assign\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n-      if Target.Capacity < Source.Length then\n-         raise Constraint_Error\n-           with \"Target capacity is less than Source length\";\n-      end if;\n-\n-      Tree_Operations.Clear_Tree (Target);\n-      Append_Elements (Source);\n-   end Assign;\n-\n-   procedure Assign (Target : in out Set; Source : Set) is\n-   begin\n-      Assign (Target.Content, Source.Content);\n-   end Assign;\n-\n-   -------------\n-   -- Ceiling --\n-   -------------\n-\n-   function Ceiling (Container : Set; Item : Element_Type) return Cursor is\n-      Node : constant Count_Type :=\n-        Element_Keys.Ceiling (Container.Content, Item);\n-\n-   begin\n-      if Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Node);\n-   end Ceiling;\n-\n-   -----------\n-   -- Clear --\n-   -----------\n-\n-   procedure Clear (Container : in out Set) is\n-   begin\n-      Tree_Operations.Clear_Tree (Container.Content);\n-   end Clear;\n-\n-   -----------\n-   -- Color --\n-   -----------\n-\n-   function Color (Node : Node_Type) return Red_Black_Trees.Color_Type is\n-   begin\n-      return Node.Color;\n-   end Color;\n-\n-   ------------------------\n-   -- Constant_Reference --\n-   ------------------------\n-\n-   function Constant_Reference\n-     (Container : aliased Set;\n-      Position  : Cursor) return not null access constant Element_Type\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container.Content, Position.Node),\n-                     \"bad cursor in Element\");\n-\n-      return Container.Content.Nodes (Position.Node).Element'Access;\n-   end Constant_Reference;\n-\n-   --------------\n-   -- Contains --\n-   --------------\n-\n-   function Contains\n-     (Container : Set;\n-      Item      : Element_Type) return Boolean\n-   is\n-   begin\n-      return Find (Container, Item) /= No_Element;\n-   end Contains;\n-\n-   ----------\n-   -- Copy --\n-   ----------\n-\n-   function Copy (Source : Set; Capacity : Count_Type := 0) return Set is\n-      Node   : Count_Type;\n-      N      : Count_Type;\n-      Target : Set (Count_Type'Max (Source.Capacity, Capacity));\n-\n-   begin\n-      if 0 < Capacity and then Capacity < Source.Capacity then\n-         raise Capacity_Error;\n-      end if;\n-\n-      if Length (Source) > 0 then\n-         Target.Content.Length := Source.Content.Length;\n-         Target.Content.Root   := Source.Content.Root;\n-         Target.Content.First  := Source.Content.First;\n-         Target.Content.Last   := Source.Content.Last;\n-         Target.Content.Free   := Source.Content.Free;\n-\n-         Node := 1;\n-         while Node <= Source.Capacity loop\n-            Target.Content.Nodes (Node).Element :=\n-              Source.Content.Nodes (Node).Element;\n-            Target.Content.Nodes (Node).Parent :=\n-              Source.Content.Nodes (Node).Parent;\n-            Target.Content.Nodes (Node).Left :=\n-              Source.Content.Nodes (Node).Left;\n-            Target.Content.Nodes (Node).Right :=\n-              Source.Content.Nodes (Node).Right;\n-            Target.Content.Nodes (Node).Color :=\n-              Source.Content.Nodes (Node).Color;\n-            Target.Content.Nodes (Node).Has_Element :=\n-              Source.Content.Nodes (Node).Has_Element;\n-            Node := Node + 1;\n-         end loop;\n-\n-         while Node <= Target.Capacity loop\n-            N := Node;\n-            Free (Tree => Target, X => N);\n-            Node := Node + 1;\n-         end loop;\n-      end if;\n-\n-      return Target;\n-   end Copy;\n-\n-   ------------\n-   -- Delete --\n-   ------------\n-\n-   procedure Delete (Container : in out Set; Position : in out Cursor) is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container.Content, Position.Node),\n-                     \"bad cursor in Delete\");\n-\n-      Tree_Operations.Delete_Node_Sans_Free (Container.Content,\n-                                             Position.Node);\n-      Free (Container, Position.Node);\n-      Position := No_Element;\n-   end Delete;\n-\n-   procedure Delete (Container : in out Set; Item : Element_Type) is\n-      X : constant Count_Type := Element_Keys.Find (Container.Content, Item);\n-\n-   begin\n-      if X = 0 then\n-         raise Constraint_Error with \"attempt to delete element not in set\";\n-      end if;\n-\n-      Tree_Operations.Delete_Node_Sans_Free (Container.Content, X);\n-      Free (Container, X);\n-   end Delete;\n-\n-   ------------------\n-   -- Delete_First --\n-   ------------------\n-\n-   procedure Delete_First (Container : in out Set) is\n-      X : constant Count_Type := Container.Content.First;\n-   begin\n-      if X /= 0 then\n-         Tree_Operations.Delete_Node_Sans_Free (Container.Content, X);\n-         Free (Container, X);\n-      end if;\n-   end Delete_First;\n-\n-   -----------------\n-   -- Delete_Last --\n-   -----------------\n-\n-   procedure Delete_Last (Container : in out Set) is\n-      X : constant Count_Type := Container.Content.Last;\n-   begin\n-      if X /= 0 then\n-         Tree_Operations.Delete_Node_Sans_Free (Container.Content, X);\n-         Free (Container, X);\n-      end if;\n-   end Delete_Last;\n-\n-   ----------------\n-   -- Difference --\n-   ----------------\n-\n-   procedure Difference (Target : in out Set; Source : Set) is\n-   begin\n-      Set_Ops.Set_Difference (Target.Content, Source.Content);\n-   end Difference;\n-\n-   function Difference (Left, Right : Set) return Set is\n-   begin\n-      if Left'Address = Right'Address then\n-         return Empty_Set;\n-      end if;\n-\n-      if Length (Left) = 0 then\n-         return Empty_Set;\n-      end if;\n-\n-      if Length (Right) = 0 then\n-         return Copy (Left);\n-      end if;\n-\n-      return S : Set (Length (Left)) do\n-         Assign\n-           (S.Content, Set_Ops.Set_Difference (Left.Content, Right.Content));\n-      end return;\n-   end Difference;\n-\n-   -------------\n-   -- Element --\n-   -------------\n-\n-   function Element (Container : Set; Position : Cursor) return Element_Type is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container.Content, Position.Node),\n-                     \"bad cursor in Element\");\n-\n-      return Container.Content.Nodes (Position.Node).Element;\n-   end Element;\n-\n-   -------------------------\n-   -- Equivalent_Elements --\n-   -------------------------\n-\n-   function Equivalent_Elements (Left, Right : Element_Type) return Boolean is\n-   begin\n-      if Left < Right\n-        or else Right < Left\n-      then\n-         return False;\n-      else\n-         return True;\n-      end if;\n-   end Equivalent_Elements;\n-\n-   ---------------------\n-   -- Equivalent_Sets --\n-   ---------------------\n-\n-   function Equivalent_Sets (Left, Right : Set) return Boolean is\n-      function Is_Equivalent_Node_Node\n-        (L, R : Node_Type) return Boolean;\n-      pragma Inline (Is_Equivalent_Node_Node);\n-\n-      function Is_Equivalent is\n-        new Tree_Operations.Generic_Equal (Is_Equivalent_Node_Node);\n-\n-      -----------------------------\n-      -- Is_Equivalent_Node_Node --\n-      -----------------------------\n-\n-      function Is_Equivalent_Node_Node (L, R : Node_Type) return Boolean is\n-      begin\n-         if L.Element < R.Element then\n-            return False;\n-         elsif R.Element < L.Element then\n-            return False;\n-         else\n-            return True;\n-         end if;\n-      end Is_Equivalent_Node_Node;\n-\n-   --  Start of processing for Equivalent_Sets\n-\n-   begin\n-      return Is_Equivalent (Left.Content, Right.Content);\n-   end Equivalent_Sets;\n-\n-   -------------\n-   -- Exclude --\n-   -------------\n-\n-   procedure Exclude (Container : in out Set; Item : Element_Type) is\n-      X : constant Count_Type := Element_Keys.Find (Container.Content, Item);\n-   begin\n-      if X /= 0 then\n-         Tree_Operations.Delete_Node_Sans_Free (Container.Content, X);\n-         Free (Container, X);\n-      end if;\n-   end Exclude;\n-\n-   ----------\n-   -- Find --\n-   ----------\n-\n-   function Find (Container : Set; Item : Element_Type) return Cursor is\n-      Node : constant Count_Type :=\n-        Element_Keys.Find (Container.Content, Item);\n-\n-   begin\n-      if Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Node);\n-   end Find;\n-\n-   -----------\n-   -- First --\n-   -----------\n-\n-   function First (Container : Set) return Cursor is\n-   begin\n-      if Length (Container) = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return (Node => Container.Content.First);\n-   end First;\n-\n-   -------------------\n-   -- First_Element --\n-   -------------------\n-\n-   function First_Element (Container : Set) return Element_Type is\n-      Fst : constant Count_Type := First (Container).Node;\n-   begin\n-      if Fst = 0 then\n-         raise Constraint_Error with \"set is empty\";\n-      end if;\n-\n-      declare\n-         N : Tree_Types.Nodes_Type renames Container.Content.Nodes;\n-      begin\n-         return N (Fst).Element;\n-      end;\n-   end First_Element;\n-\n-   -----------\n-   -- Floor --\n-   -----------\n-\n-   function Floor (Container : Set; Item : Element_Type) return Cursor is\n-   begin\n-      declare\n-         Node : constant Count_Type :=\n-           Element_Keys.Floor (Container.Content, Item);\n-\n-      begin\n-         if Node = 0 then\n-            return No_Element;\n-         end if;\n-\n-         return (Node => Node);\n-      end;\n-   end Floor;\n-\n-   ------------------\n-   -- Formal_Model --\n-   ------------------\n-\n-   package body Formal_Model is\n-\n-      -------------------------\n-      -- E_Bigger_Than_Range --\n-      -------------------------\n-\n-      function E_Bigger_Than_Range\n-        (Container : E.Sequence;\n-         Fst       : Positive_Count_Type;\n-         Lst       : Count_Type;\n-         Item      : Element_Type) return Boolean\n-      is\n-      begin\n-         for I in Fst .. Lst loop\n-            if not (E.Get (Container, I) < Item) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end E_Bigger_Than_Range;\n-\n-      -------------------------\n-      -- E_Elements_Included --\n-      -------------------------\n-\n-      function E_Elements_Included\n-        (Left  : E.Sequence;\n-         Right : E.Sequence) return Boolean\n-      is\n-      begin\n-         for I in 1 .. E.Length (Left) loop\n-            if not E.Contains (Right, 1, E.Length (Right), E.Get (Left, I))\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end E_Elements_Included;\n-\n-      function E_Elements_Included\n-        (Left  : E.Sequence;\n-         Model : M.Set;\n-         Right : E.Sequence) return Boolean\n-      is\n-      begin\n-         for I in 1 .. E.Length (Left) loop\n-            declare\n-               Item : constant Element_Type := E.Get (Left, I);\n-            begin\n-               if M.Contains (Model, Item) then\n-                  if not E.Contains (Right, 1, E.Length (Right), Item) then\n-                     return False;\n-                  end if;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end E_Elements_Included;\n-\n-      function E_Elements_Included\n-        (Container : E.Sequence;\n-         Model     : M.Set;\n-         Left      : E.Sequence;\n-         Right     : E.Sequence) return Boolean\n-      is\n-      begin\n-         for I in 1 .. E.Length (Container) loop\n-            declare\n-               Item : constant Element_Type := E.Get (Container, I);\n-            begin\n-               if M.Contains (Model, Item) then\n-                  if not E.Contains (Left, 1, E.Length (Left), Item) then\n-                     return False;\n-                  end if;\n-               else\n-                  if not E.Contains (Right, 1, E.Length (Right), Item) then\n-                     return False;\n-                  end if;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end E_Elements_Included;\n-\n-      ---------------\n-      -- E_Is_Find --\n-      ---------------\n-\n-      function E_Is_Find\n-        (Container : E.Sequence;\n-         Item      : Element_Type;\n-         Position  : Count_Type) return Boolean\n-      is\n-      begin\n-         for I in 1 .. Position - 1 loop\n-            if Item < E.Get (Container, I) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         if Position < E.Length (Container) then\n-            for I in Position + 1 .. E.Length (Container) loop\n-               if E.Get (Container, I) < Item then\n-                  return False;\n-               end if;\n-            end loop;\n-         end if;\n-\n-         return True;\n-      end E_Is_Find;\n-\n-      --------------------------\n-      -- E_Smaller_Than_Range --\n-      --------------------------\n-\n-      function E_Smaller_Than_Range\n-        (Container : E.Sequence;\n-         Fst       : Positive_Count_Type;\n-         Lst       : Count_Type;\n-         Item      : Element_Type) return Boolean\n-      is\n-      begin\n-         for I in Fst .. Lst loop\n-            if not (Item < E.Get (Container, I)) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end E_Smaller_Than_Range;\n-\n-      ----------\n-      -- Find --\n-      ----------\n-\n-      function Find\n-        (Container : E.Sequence;\n-         Item      : Element_Type) return Count_Type\n-      is\n-      begin\n-         for I in 1 .. E.Length (Container) loop\n-            if Equivalent_Elements (Item, E.Get (Container, I)) then\n-               return I;\n-            end if;\n-         end loop;\n-\n-         return 0;\n-      end Find;\n-\n-      --------------\n-      -- Elements --\n-      --------------\n-\n-      function Elements (Container : Set) return E.Sequence is\n-         Position : Count_Type := Container.Content.First;\n-         R        : E.Sequence;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R := E.Add (R, Container.Content.Nodes (Position).Element);\n-            Position := Tree_Operations.Next (Container.Content, Position);\n-         end loop;\n-\n-         return R;\n-      end Elements;\n-\n-      ----------------------------\n-      -- Lift_Abstraction_Level --\n-      ----------------------------\n-\n-      procedure Lift_Abstraction_Level (Container : Set) is null;\n-\n-      -----------------------\n-      -- Mapping_Preserved --\n-      -----------------------\n-\n-      function Mapping_Preserved\n-        (E_Left  : E.Sequence;\n-         E_Right : E.Sequence;\n-         P_Left  : P.Map;\n-         P_Right : P.Map) return Boolean\n-      is\n-      begin\n-         for C of P_Left loop\n-            if not P.Has_Key (P_Right, C)\n-              or else P.Get (P_Left,  C) > E.Length (E_Left)\n-              or else P.Get (P_Right, C) > E.Length (E_Right)\n-              or else E.Get (E_Left,  P.Get (P_Left,  C)) /=\n-                      E.Get (E_Right, P.Get (P_Right, C))\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end Mapping_Preserved;\n-\n-      ------------------------------\n-      -- Mapping_Preserved_Except --\n-      ------------------------------\n-\n-      function Mapping_Preserved_Except\n-        (E_Left   : E.Sequence;\n-         E_Right  : E.Sequence;\n-         P_Left   : P.Map;\n-         P_Right  : P.Map;\n-         Position : Cursor) return Boolean\n-      is\n-      begin\n-         for C of P_Left loop\n-            if C /= Position\n-              and (not P.Has_Key (P_Right, C)\n-                    or else P.Get (P_Left,  C) > E.Length (E_Left)\n-                    or else P.Get (P_Right, C) > E.Length (E_Right)\n-                    or else E.Get (E_Left,  P.Get (P_Left,  C)) /=\n-                            E.Get (E_Right, P.Get (P_Right, C)))\n-            then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         return True;\n-      end Mapping_Preserved_Except;\n-\n-      -------------------------\n-      -- P_Positions_Shifted --\n-      -------------------------\n-\n-      function P_Positions_Shifted\n-        (Small : P.Map;\n-         Big   : P.Map;\n-         Cut   : Positive_Count_Type;\n-         Count : Count_Type := 1) return Boolean\n-      is\n-      begin\n-         for Cu of Small loop\n-            if not P.Has_Key (Big, Cu) then\n-               return False;\n-            end if;\n-         end loop;\n-\n-         for Cu of Big loop\n-            declare\n-               Pos : constant Positive_Count_Type := P.Get (Big, Cu);\n-\n-            begin\n-               if Pos < Cut then\n-                  if not P.Has_Key (Small, Cu)\n-                    or else Pos /= P.Get (Small, Cu)\n-                  then\n-                     return False;\n-                  end if;\n-\n-               elsif Pos >= Cut + Count then\n-                  if not P.Has_Key (Small, Cu)\n-                    or else Pos /= P.Get (Small, Cu) + Count\n-                  then\n-                     return False;\n-                  end if;\n-\n-               else\n-                  if P.Has_Key (Small, Cu) then\n-                     return False;\n-                  end if;\n-               end if;\n-            end;\n-         end loop;\n-\n-         return True;\n-      end P_Positions_Shifted;\n-\n-      -----------\n-      -- Model --\n-      -----------\n-\n-      function Model (Container : Set) return M.Set is\n-         Position : Count_Type := Container.Content.First;\n-         R        : M.Set;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R :=\n-              M.Add\n-                (Container => R,\n-                 Item      => Container.Content.Nodes (Position).Element);\n-\n-            Position := Tree_Operations.Next (Container.Content, Position);\n-         end loop;\n-\n-         return R;\n-      end Model;\n-\n-      ---------------\n-      -- Positions --\n-      ---------------\n-\n-      function Positions (Container : Set) return P.Map is\n-         I        : Count_Type := 1;\n-         Position : Count_Type := Container.Content.First;\n-         R        : P.Map;\n-\n-      begin\n-         --  Can't use First, Next or Element here, since they depend on models\n-         --  for their postconditions.\n-\n-         while Position /= 0 loop\n-            R := P.Add (R, (Node => Position), I);\n-            pragma Assert (P.Length (R) = Big (I));\n-            Position := Tree_Operations.Next (Container.Content, Position);\n-            I := I + 1;\n-         end loop;\n-\n-         return R;\n-      end Positions;\n-\n-   end Formal_Model;\n-\n-   ----------\n-   -- Free --\n-   ----------\n-\n-   procedure Free (Tree : in out Set; X : Count_Type) is\n-   begin\n-      Tree.Content.Nodes (X).Has_Element := False;\n-      Tree_Operations.Free (Tree.Content, X);\n-   end Free;\n-\n-   ----------------------\n-   -- Generic_Allocate --\n-   ----------------------\n-\n-   procedure Generic_Allocate\n-     (Tree : in out Tree_Types.Tree_Type'Class;\n-      Node : out Count_Type)\n-   is\n-      procedure Allocate is\n-        new Tree_Operations.Generic_Allocate (Set_Element);\n-   begin\n-      Allocate (Tree, Node);\n-      Tree.Nodes (Node).Has_Element := True;\n-   end Generic_Allocate;\n-\n-   ------------------\n-   -- Generic_Keys --\n-   ------------------\n-\n-   package body Generic_Keys with SPARK_Mode => Off is\n-\n-      -----------------------\n-      -- Local Subprograms --\n-      -----------------------\n-\n-      function Is_Greater_Key_Node\n-        (Left  : Key_Type;\n-         Right : Node_Type) return Boolean;\n-      pragma Inline (Is_Greater_Key_Node);\n-\n-      function Is_Less_Key_Node\n-        (Left  : Key_Type;\n-         Right : Node_Type) return Boolean;\n-      pragma Inline (Is_Less_Key_Node);\n-\n-      --------------------------\n-      -- Local Instantiations --\n-      --------------------------\n-\n-      package Key_Keys is\n-        new Red_Black_Trees.Generic_Bounded_Keys\n-          (Tree_Operations     => Tree_Operations,\n-           Key_Type            => Key_Type,\n-           Is_Less_Key_Node    => Is_Less_Key_Node,\n-           Is_Greater_Key_Node => Is_Greater_Key_Node);\n-\n-      -------------\n-      -- Ceiling --\n-      -------------\n-\n-      function Ceiling (Container : Set; Key : Key_Type) return Cursor is\n-         Node : constant Count_Type :=\n-           Key_Keys.Ceiling (Container.Content, Key);\n-\n-      begin\n-         if Node = 0 then\n-            return No_Element;\n-         end if;\n-\n-         return (Node => Node);\n-      end Ceiling;\n-\n-      --------------\n-      -- Contains --\n-      --------------\n-\n-      function Contains (Container : Set; Key : Key_Type) return Boolean is\n-      begin\n-         return Find (Container, Key) /= No_Element;\n-      end Contains;\n-\n-      ------------\n-      -- Delete --\n-      ------------\n-\n-      procedure Delete (Container : in out Set; Key : Key_Type) is\n-         X : constant Count_Type := Key_Keys.Find (Container.Content, Key);\n-\n-      begin\n-         if X = 0 then\n-            raise Constraint_Error with \"attempt to delete key not in set\";\n-         end if;\n-\n-         Delete_Node_Sans_Free (Container.Content, X);\n-         Free (Container, X);\n-      end Delete;\n-\n-      -------------\n-      -- Element --\n-      -------------\n-\n-      function Element (Container : Set; Key : Key_Type) return Element_Type is\n-         Node : constant Count_Type := Key_Keys.Find (Container.Content, Key);\n-\n-      begin\n-         if Node = 0 then\n-            raise Constraint_Error with \"key not in set\";\n-         end if;\n-\n-         declare\n-            N : Tree_Types.Nodes_Type renames Container.Content.Nodes;\n-         begin\n-            return N (Node).Element;\n-         end;\n-      end Element;\n-\n-      ---------------------\n-      -- Equivalent_Keys --\n-      ---------------------\n-\n-      function Equivalent_Keys (Left, Right : Key_Type) return Boolean is\n-      begin\n-         if Left < Right\n-           or else Right < Left\n-         then\n-            return False;\n-         else\n-            return True;\n-         end if;\n-      end Equivalent_Keys;\n-\n-      -------------\n-      -- Exclude --\n-      -------------\n-\n-      procedure Exclude (Container : in out Set; Key : Key_Type) is\n-         X : constant Count_Type := Key_Keys.Find (Container.Content, Key);\n-      begin\n-         if X /= 0 then\n-            Delete_Node_Sans_Free (Container.Content, X);\n-            Free (Container, X);\n-         end if;\n-      end Exclude;\n-\n-      ----------\n-      -- Find --\n-      ----------\n-\n-      function Find (Container : Set; Key : Key_Type) return Cursor is\n-         Node : constant Count_Type := Key_Keys.Find (Container.Content, Key);\n-      begin\n-         return (if Node = 0 then No_Element else (Node => Node));\n-      end Find;\n-\n-      -----------\n-      -- Floor --\n-      -----------\n-\n-      function Floor (Container : Set; Key : Key_Type) return Cursor is\n-         Node : constant Count_Type := Key_Keys.Floor (Container.Content, Key);\n-      begin\n-         return (if Node = 0 then No_Element else (Node => Node));\n-      end Floor;\n-\n-      ------------------\n-      -- Formal_Model --\n-      ------------------\n-\n-      package body Formal_Model is\n-\n-         -------------------------\n-         -- E_Bigger_Than_Range --\n-         -------------------------\n-\n-         function E_Bigger_Than_Range\n-           (Container : E.Sequence;\n-            Fst       : Positive_Count_Type;\n-            Lst       : Count_Type;\n-            Key       : Key_Type) return Boolean\n-         is\n-         begin\n-            for I in Fst .. Lst loop\n-               if not (Generic_Keys.Key (E.Get (Container, I)) < Key) then\n-                  return False;\n-               end if;\n-            end loop;\n-            return True;\n-         end E_Bigger_Than_Range;\n-\n-         ---------------\n-         -- E_Is_Find --\n-         ---------------\n-\n-         function E_Is_Find\n-           (Container : E.Sequence;\n-            Key       : Key_Type;\n-            Position  : Count_Type) return Boolean\n-         is\n-         begin\n-            for I in 1 .. Position - 1 loop\n-               if Key < Generic_Keys.Key (E.Get (Container, I)) then\n-                  return False;\n-               end if;\n-            end loop;\n-\n-            if Position < E.Length (Container) then\n-               for I in Position + 1 .. E.Length (Container) loop\n-                  if Generic_Keys.Key (E.Get (Container, I)) < Key then\n-                     return False;\n-                  end if;\n-               end loop;\n-            end if;\n-            return True;\n-         end E_Is_Find;\n-\n-         --------------------------\n-         -- E_Smaller_Than_Range --\n-         --------------------------\n-\n-         function E_Smaller_Than_Range\n-           (Container : E.Sequence;\n-            Fst       : Positive_Count_Type;\n-            Lst       : Count_Type;\n-            Key       : Key_Type) return Boolean\n-         is\n-         begin\n-            for I in Fst .. Lst loop\n-               if not (Key < Generic_Keys.Key (E.Get (Container, I))) then\n-                  return False;\n-               end if;\n-            end loop;\n-            return True;\n-         end E_Smaller_Than_Range;\n-\n-         ----------\n-         -- Find --\n-         ----------\n-\n-         function Find\n-           (Container : E.Sequence;\n-            Key       : Key_Type) return Count_Type\n-         is\n-         begin\n-            for I in 1 .. E.Length (Container) loop\n-               if Equivalent_Keys\n-                   (Key, Generic_Keys.Key (E.Get (Container, I)))\n-               then\n-                  return I;\n-               end if;\n-            end loop;\n-            return 0;\n-         end Find;\n-\n-         -----------------------\n-         -- M_Included_Except --\n-         -----------------------\n-\n-         function M_Included_Except\n-           (Left  : M.Set;\n-            Right : M.Set;\n-            Key   : Key_Type) return Boolean\n-         is\n-         begin\n-            for E of Left loop\n-               if not Contains (Right, E)\n-                 and not Equivalent_Keys (Generic_Keys.Key (E), Key)\n-               then\n-                  return False;\n-               end if;\n-            end loop;\n-            return True;\n-         end M_Included_Except;\n-      end Formal_Model;\n-\n-      -------------------------\n-      -- Is_Greater_Key_Node --\n-      -------------------------\n-\n-      function Is_Greater_Key_Node\n-        (Left  : Key_Type;\n-         Right : Node_Type) return Boolean\n-      is\n-      begin\n-         return Key (Right.Element) < Left;\n-      end Is_Greater_Key_Node;\n-\n-      ----------------------\n-      -- Is_Less_Key_Node --\n-      ----------------------\n-\n-      function Is_Less_Key_Node\n-        (Left  : Key_Type;\n-         Right : Node_Type) return Boolean\n-      is\n-      begin\n-         return Left < Key (Right.Element);\n-      end Is_Less_Key_Node;\n-\n-      ---------\n-      -- Key --\n-      ---------\n-\n-      function Key (Container : Set; Position : Cursor) return Key_Type is\n-      begin\n-         if not Has_Element (Container, Position) then\n-            raise Constraint_Error with\n-              \"Position cursor has no element\";\n-         end if;\n-\n-         pragma Assert (Vet (Container.Content, Position.Node),\n-                        \"bad cursor in Key\");\n-\n-         declare\n-            N : Tree_Types.Nodes_Type renames Container.Content.Nodes;\n-         begin\n-            return Key (N (Position.Node).Element);\n-         end;\n-      end Key;\n-\n-      -------------\n-      -- Replace --\n-      -------------\n-\n-      procedure Replace\n-        (Container : in out Set;\n-         Key       : Key_Type;\n-         New_Item  : Element_Type)\n-      is\n-         Node : constant Count_Type := Key_Keys.Find (Container.Content, Key);\n-      begin\n-         if not Has_Element (Container, (Node => Node)) then\n-            raise Constraint_Error with\n-              \"attempt to replace key not in set\";\n-         else\n-            Replace_Element (Container, Node, New_Item);\n-         end if;\n-      end Replace;\n-\n-   end Generic_Keys;\n-\n-   -----------------\n-   -- Has_Element --\n-   -----------------\n-\n-   function Has_Element (Container : Set; Position : Cursor) return Boolean is\n-   begin\n-      if Position.Node = 0 then\n-         return False;\n-      else\n-         return Container.Content.Nodes (Position.Node).Has_Element;\n-      end if;\n-   end Has_Element;\n-\n-   -------------\n-   -- Include --\n-   -------------\n-\n-   procedure Include (Container : in out Set; New_Item : Element_Type) is\n-      Position : Cursor;\n-      Inserted : Boolean;\n-\n-   begin\n-      Insert (Container, New_Item, Position, Inserted);\n-\n-      if not Inserted then\n-         declare\n-            N : Tree_Types.Nodes_Type renames Container.Content.Nodes;\n-         begin\n-            N (Position.Node).Element := New_Item;\n-         end;\n-      end if;\n-   end Include;\n-\n-   ------------\n-   -- Insert --\n-   ------------\n-\n-   procedure Insert\n-     (Container : in out Set;\n-      New_Item  : Element_Type;\n-      Position  : out Cursor;\n-      Inserted  : out Boolean)\n-   is\n-   begin\n-      Insert_Sans_Hint (Container.Content, New_Item, Position.Node, Inserted);\n-   end Insert;\n-\n-   procedure Insert\n-     (Container : in out Set;\n-      New_Item  : Element_Type)\n-   is\n-      Position : Cursor;\n-      Inserted : Boolean;\n-\n-   begin\n-      Insert (Container, New_Item, Position, Inserted);\n-\n-      if not Inserted then\n-         raise Constraint_Error with\n-           \"attempt to insert element already in set\";\n-      end if;\n-   end Insert;\n-\n-   ----------------------\n-   -- Insert_Sans_Hint --\n-   ----------------------\n-\n-   procedure Insert_Sans_Hint\n-     (Container : in out Tree_Types.Tree_Type;\n-      New_Item  : Element_Type;\n-      Node      : out Count_Type;\n-      Inserted  : out Boolean)\n-   is\n-      procedure Set_Element (Node : in out Node_Type);\n-\n-      function New_Node return Count_Type;\n-      pragma Inline (New_Node);\n-\n-      procedure Insert_Post is\n-        new Element_Keys.Generic_Insert_Post (New_Node);\n-\n-      procedure Conditional_Insert_Sans_Hint is\n-        new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n-\n-      procedure Allocate is new Generic_Allocate (Set_Element);\n-\n-      --------------\n-      -- New_Node --\n-      --------------\n-\n-      function New_Node return Count_Type is\n-         Result : Count_Type;\n-      begin\n-         Allocate (Container, Result);\n-         return Result;\n-      end New_Node;\n-\n-      -----------------\n-      -- Set_Element --\n-      -----------------\n-\n-      procedure Set_Element (Node : in out Node_Type) is\n-      begin\n-         Node.Element := New_Item;\n-      end Set_Element;\n-\n-   --  Start of processing for Insert_Sans_Hint\n-\n-   begin\n-      Conditional_Insert_Sans_Hint\n-        (Container,\n-         New_Item,\n-         Node,\n-         Inserted);\n-   end Insert_Sans_Hint;\n-\n-   ----------------------\n-   -- Insert_With_Hint --\n-   ----------------------\n-\n-   procedure Insert_With_Hint\n-     (Dst_Set  : in out Tree_Types.Tree_Type;\n-      Dst_Hint : Count_Type;\n-      Src_Node : Node_Type;\n-      Dst_Node : out Count_Type)\n-   is\n-      Success : Boolean;\n-\n-      procedure Set_Element (Node : in out Node_Type);\n-\n-      function New_Node return Count_Type;\n-      pragma Inline (New_Node);\n-\n-      procedure Insert_Post is\n-        new Element_Keys.Generic_Insert_Post (New_Node);\n-\n-      procedure Insert_Sans_Hint is\n-        new Element_Keys.Generic_Conditional_Insert (Insert_Post);\n-\n-      procedure Local_Insert_With_Hint is\n-        new Element_Keys.Generic_Conditional_Insert_With_Hint\n-              (Insert_Post, Insert_Sans_Hint);\n-\n-      procedure Allocate is new Generic_Allocate (Set_Element);\n-\n-      --------------\n-      -- New_Node --\n-      --------------\n-\n-      function New_Node return Count_Type is\n-         Result : Count_Type;\n-      begin\n-         Allocate (Dst_Set, Result);\n-         return Result;\n-      end New_Node;\n-\n-      -----------------\n-      -- Set_Element --\n-      -----------------\n-\n-      procedure Set_Element (Node : in out Node_Type) is\n-      begin\n-         Node.Element := Src_Node.Element;\n-      end Set_Element;\n-\n-   --  Start of processing for Insert_With_Hint\n-\n-   begin\n-      Local_Insert_With_Hint\n-        (Dst_Set,\n-         Dst_Hint,\n-         Src_Node.Element,\n-         Dst_Node,\n-         Success);\n-   end Insert_With_Hint;\n-\n-   ------------------\n-   -- Intersection --\n-   ------------------\n-\n-   procedure Intersection (Target : in out Set; Source : Set) is\n-   begin\n-      Set_Ops.Set_Intersection (Target.Content, Source.Content);\n-   end Intersection;\n-\n-   function Intersection (Left, Right : Set) return Set is\n-   begin\n-      if Left'Address = Right'Address then\n-         return Copy (Left);\n-      end if;\n-\n-      return S : Set (Count_Type'Min (Length (Left), Length (Right))) do\n-            Assign (S.Content,\n-                    Set_Ops.Set_Intersection (Left.Content, Right.Content));\n-      end return;\n-   end Intersection;\n-\n-   --------------\n-   -- Is_Empty --\n-   --------------\n-\n-   function Is_Empty (Container : Set) return Boolean is\n-   begin\n-      return Length (Container) = 0;\n-   end Is_Empty;\n-\n-   -----------------------------\n-   -- Is_Greater_Element_Node --\n-   -----------------------------\n-\n-   function Is_Greater_Element_Node\n-     (Left  : Element_Type;\n-      Right : Node_Type) return Boolean\n-   is\n-   begin\n-      --  Compute e > node same as node < e\n-\n-      return Right.Element < Left;\n-   end Is_Greater_Element_Node;\n-\n-   --------------------------\n-   -- Is_Less_Element_Node --\n-   --------------------------\n-\n-   function Is_Less_Element_Node\n-     (Left  : Element_Type;\n-      Right : Node_Type) return Boolean\n-   is\n-   begin\n-      return Left < Right.Element;\n-   end Is_Less_Element_Node;\n-\n-   -----------------------\n-   -- Is_Less_Node_Node --\n-   -----------------------\n-\n-   function Is_Less_Node_Node (L, R : Node_Type) return Boolean is\n-   begin\n-      return L.Element < R.Element;\n-   end Is_Less_Node_Node;\n-\n-   ---------------\n-   -- Is_Subset --\n-   ---------------\n-\n-   function Is_Subset (Subset : Set; Of_Set : Set) return Boolean is\n-   begin\n-      return Set_Ops.Set_Subset (Subset.Content, Of_Set => Of_Set.Content);\n-   end Is_Subset;\n-\n-   ----------\n-   -- Last --\n-   ----------\n-\n-   function Last (Container : Set) return Cursor is\n-   begin\n-      return (if Length (Container) = 0\n-              then No_Element\n-              else (Node => Container.Content.Last));\n-   end Last;\n-\n-   ------------------\n-   -- Last_Element --\n-   ------------------\n-\n-   function Last_Element (Container : Set) return Element_Type is\n-   begin\n-      if Last (Container).Node = 0 then\n-         raise Constraint_Error with \"set is empty\";\n-      end if;\n-\n-      declare\n-         N : Tree_Types.Nodes_Type renames Container.Content.Nodes;\n-      begin\n-         return N (Last (Container).Node).Element;\n-      end;\n-   end Last_Element;\n-\n-   --------------\n-   -- Left_Son --\n-   --------------\n-\n-   function Left_Son (Node : Node_Type) return Count_Type is\n-   begin\n-      return Node.Left;\n-   end Left_Son;\n-\n-   ------------\n-   -- Length --\n-   ------------\n-\n-   function Length (Container : Set) return Count_Type is\n-   begin\n-      return Container.Content.Length;\n-   end Length;\n-\n-   ----------\n-   -- Move --\n-   ----------\n-\n-   procedure Move (Target : in out Set; Source : in out Set) is\n-      N : Tree_Types.Nodes_Type renames Source.Content.Nodes;\n-      X : Count_Type;\n-\n-   begin\n-      if Target'Address = Source'Address then\n-         return;\n-      end if;\n-\n-      if Target.Capacity < Length (Source) then\n-         raise Constraint_Error with  -- ???\n-           \"Source length exceeds Target capacity\";\n-      end if;\n-\n-      Clear (Target);\n-\n-      loop\n-         X := Source.Content.First;\n-         exit when X = 0;\n-\n-         Insert (Target, N (X).Element);  -- optimize???\n-\n-         Tree_Operations.Delete_Node_Sans_Free (Source.Content, X);\n-         Free (Source, X);\n-      end loop;\n-   end Move;\n-\n-   ----------\n-   -- Next --\n-   ----------\n-\n-   function Next (Container : Set; Position : Cursor) return Cursor is\n-   begin\n-      if Position = No_Element then\n-         return No_Element;\n-      end if;\n-\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error;\n-      end if;\n-\n-      pragma Assert (Vet (Container.Content, Position.Node),\n-                     \"bad cursor in Next\");\n-      return (Node => Tree_Operations.Next (Container.Content, Position.Node));\n-   end Next;\n-\n-   procedure Next (Container : Set; Position : in out Cursor) is\n-   begin\n-      Position := Next (Container, Position);\n-   end Next;\n-\n-   -------------\n-   -- Overlap --\n-   -------------\n-\n-   function Overlap (Left, Right : Set) return Boolean is\n-   begin\n-      return Set_Ops.Set_Overlap (Left.Content, Right.Content);\n-   end Overlap;\n-\n-   ------------\n-   -- Parent --\n-   ------------\n-\n-   function Parent (Node : Node_Type) return Count_Type is\n-   begin\n-      return Node.Parent;\n-   end Parent;\n-\n-   --------------\n-   -- Previous --\n-   --------------\n-\n-   function Previous (Container : Set; Position : Cursor) return Cursor is\n-   begin\n-      if Position = No_Element then\n-         return No_Element;\n-      end if;\n-\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error;\n-      end if;\n-\n-      pragma Assert (Vet (Container.Content, Position.Node),\n-                     \"bad cursor in Previous\");\n-\n-      declare\n-         Node : constant Count_Type :=\n-           Tree_Operations.Previous (Container.Content, Position.Node);\n-      begin\n-         return (if Node = 0 then No_Element else (Node => Node));\n-      end;\n-   end Previous;\n-\n-   procedure Previous (Container : Set; Position : in out Cursor) is\n-   begin\n-      Position := Previous (Container, Position);\n-   end Previous;\n-\n-   -------------\n-   -- Replace --\n-   -------------\n-\n-   procedure Replace (Container : in out Set; New_Item : Element_Type) is\n-      Node : constant Count_Type :=\n-        Element_Keys.Find (Container.Content, New_Item);\n-\n-   begin\n-      if Node = 0 then\n-         raise Constraint_Error with\n-           \"attempt to replace element not in set\";\n-      end if;\n-\n-      Container.Content.Nodes (Node).Element := New_Item;\n-   end Replace;\n-\n-   ---------------------\n-   -- Replace_Element --\n-   ---------------------\n-\n-   procedure Replace_Element\n-     (Tree : in out Set;\n-      Node : Count_Type;\n-      Item : Element_Type)\n-   is\n-      pragma Assert (Node /= 0);\n-\n-      function New_Node return Count_Type;\n-      pragma Inline (New_Node);\n-\n-      procedure Local_Insert_Post is\n-        new Element_Keys.Generic_Insert_Post (New_Node);\n-\n-      procedure Local_Insert_Sans_Hint is\n-        new Element_Keys.Generic_Conditional_Insert (Local_Insert_Post);\n-\n-      procedure Local_Insert_With_Hint is\n-        new Element_Keys.Generic_Conditional_Insert_With_Hint\n-          (Local_Insert_Post,\n-           Local_Insert_Sans_Hint);\n-\n-      NN : Tree_Types.Nodes_Type renames Tree.Content.Nodes;\n-\n-      --------------\n-      -- New_Node --\n-      --------------\n-\n-      function New_Node return Count_Type is\n-         N : Node_Type renames NN (Node);\n-      begin\n-         N.Element := Item;\n-         N.Color   := Red;\n-         N.Parent  := 0;\n-         N.Right   := 0;\n-         N.Left    := 0;\n-         return Node;\n-      end New_Node;\n-\n-      Hint      : Count_Type;\n-      Result    : Count_Type;\n-      Inserted  : Boolean;\n-\n-   --  Start of processing for Insert\n-\n-   begin\n-      if Item < NN (Node).Element\n-        or else NN (Node).Element < Item\n-      then\n-         null;\n-\n-      else\n-         NN (Node).Element := Item;\n-         return;\n-      end if;\n-\n-      Hint := Element_Keys.Ceiling (Tree.Content, Item);\n-\n-      if Hint = 0 then\n-         null;\n-\n-      elsif Item < NN (Hint).Element then\n-         if Hint = Node then\n-            NN (Node).Element := Item;\n-            return;\n-         end if;\n-\n-      else\n-         pragma Assert (not (NN (Hint).Element < Item));\n-         raise Program_Error with \"attempt to replace existing element\";\n-      end if;\n-\n-      Tree_Operations.Delete_Node_Sans_Free (Tree.Content, Node);\n-\n-      Local_Insert_With_Hint\n-        (Tree     => Tree.Content,\n-         Position => Hint,\n-         Key      => Item,\n-         Node     => Result,\n-         Inserted => Inserted);\n-\n-      pragma Assert (Inserted);\n-      pragma Assert (Result = Node);\n-   end Replace_Element;\n-\n-   procedure Replace_Element\n-     (Container : in out Set;\n-      Position  : Cursor;\n-      New_Item  : Element_Type)\n-   is\n-   begin\n-      if not Has_Element (Container, Position) then\n-         raise Constraint_Error with\n-           \"Position cursor has no element\";\n-      end if;\n-\n-      pragma Assert (Vet (Container.Content, Position.Node),\n-                     \"bad cursor in Replace_Element\");\n-\n-      Replace_Element (Container, Position.Node, New_Item);\n-   end Replace_Element;\n-\n-   ---------------\n-   -- Right_Son --\n-   ---------------\n-\n-   function Right_Son (Node : Node_Type) return Count_Type is\n-   begin\n-      return Node.Right;\n-   end Right_Son;\n-\n-   ---------------\n-   -- Set_Color --\n-   ---------------\n-\n-   procedure Set_Color\n-     (Node  : in out Node_Type;\n-      Color : Red_Black_Trees.Color_Type)\n-   is\n-   begin\n-      Node.Color := Color;\n-   end Set_Color;\n-\n-   --------------\n-   -- Set_Left --\n-   --------------\n-\n-   procedure Set_Left (Node : in out Node_Type; Left : Count_Type) is\n-   begin\n-      Node.Left := Left;\n-   end Set_Left;\n-\n-   ----------------\n-   -- Set_Parent --\n-   ----------------\n-\n-   procedure Set_Parent (Node : in out Node_Type; Parent : Count_Type) is\n-   begin\n-      Node.Parent := Parent;\n-   end Set_Parent;\n-\n-   ---------------\n-   -- Set_Right --\n-   ---------------\n-\n-   procedure Set_Right (Node : in out Node_Type; Right : Count_Type) is\n-   begin\n-      Node.Right := Right;\n-   end Set_Right;\n-\n-   --------------------------\n-   -- Symmetric_Difference --\n-   --------------------------\n-\n-   procedure Symmetric_Difference (Target : in out Set; Source : Set) is\n-   begin\n-      Set_Ops.Set_Symmetric_Difference (Target.Content, Source.Content);\n-   end Symmetric_Difference;\n-\n-   function Symmetric_Difference (Left, Right : Set) return Set is\n-   begin\n-      if Left'Address = Right'Address then\n-         return Empty_Set;\n-      end if;\n-\n-      if Length (Right) = 0 then\n-         return Copy (Left);\n-      end if;\n-\n-      if Length (Left) = 0 then\n-         return Copy (Right);\n-      end if;\n-\n-      return S : Set (Length (Left) + Length (Right)) do\n-         Assign\n-           (S.Content,\n-            Set_Ops.Set_Symmetric_Difference (Left.Content, Right.Content));\n-      end return;\n-   end Symmetric_Difference;\n-\n-   ------------\n-   -- To_Set --\n-   ------------\n-\n-   function To_Set (New_Item : Element_Type) return Set is\n-      Node     : Count_Type;\n-      Inserted : Boolean;\n-\n-   begin\n-      return S : Set (Capacity => 1) do\n-         Insert_Sans_Hint (S.Content, New_Item, Node, Inserted);\n-         pragma Assert (Inserted);\n-      end return;\n-   end To_Set;\n-\n-   -----------\n-   -- Union --\n-   -----------\n-\n-   procedure Union (Target : in out Set; Source : Set) is\n-   begin\n-      Set_Ops.Set_Union (Target.Content, Source.Content);\n-   end Union;\n-\n-   function Union (Left, Right : Set) return Set is\n-   begin\n-      if Left'Address = Right'Address then\n-         return Copy (Left);\n-      end if;\n-\n-      if Length (Left) = 0 then\n-         return Copy (Right);\n-      end if;\n-\n-      if Length (Right) = 0 then\n-         return Copy (Left);\n-      end if;\n-\n-      return S : Set (Length (Left) + Length (Right)) do\n-         Assign (S, Source => Left);\n-         Union (S, Right);\n-      end return;\n-   end Union;\n-\n-end Ada.Containers.Formal_Ordered_Sets;"}, {"sha": "fe5de2bff4ee1f8e8108668a9e2a5d2f65e089c2", "filename": "gcc/ada/libgnat/a-cforse.ads", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cforse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cforse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cforse.ads?ref=4a7312f7ce189783a2cb5318bdcf50e8148b909d"}, {"sha": "c921184eb0347e11e30a7bfac3730bb7ad1b78b1", "filename": "gcc/ada/libgnat/a-cofove.adb", "status": "removed", "additions": 0, "deletions": 1311, "changes": 1311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cofove.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cofove.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofove.adb?ref=cf8af60f6a3910577e99db04dbc757e731558144"}, {"sha": "fb9301fe7f5cdf0e704ebebf1d9a94e2fe28d957", "filename": "gcc/ada/libgnat/a-cofove.ads", "status": "modified", "additions": 5, "deletions": 947, "changes": 952, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cofove.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cofove.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofove.ads?ref=4a7312f7ce189783a2cb5318bdcf50e8148b909d"}, {"sha": "68cf2ae585729b71dbecbc2614571bb53852f0d5", "filename": "gcc/ada/libgnat/a-cofuba.adb", "status": "removed", "additions": 0, "deletions": 432, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cofuba.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cofuba.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuba.adb?ref=cf8af60f6a3910577e99db04dbc757e731558144"}, {"sha": "8a99a433837427edcb157bf8a384a5376c9cc67e", "filename": "gcc/ada/libgnat/a-cofuba.ads", "status": "removed", "additions": 0, "deletions": 198, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cofuba.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cofuba.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuba.ads?ref=cf8af60f6a3910577e99db04dbc757e731558144"}, {"sha": "f83b4d829f767f0506d0c07f98535b16e0e61bfc", "filename": "gcc/ada/libgnat/a-cofuma.adb", "status": "removed", "additions": 0, "deletions": 306, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cofuma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cofuma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuma.adb?ref=cf8af60f6a3910577e99db04dbc757e731558144"}, {"sha": "9b4863af0bfc5d86b41923ebbaaa2714fd23efe0", "filename": "gcc/ada/libgnat/a-cofuma.ads", "status": "modified", "additions": 5, "deletions": 361, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cofuma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cofuma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuma.ads?ref=4a7312f7ce189783a2cb5318bdcf50e8148b909d"}, {"sha": "bbb3f7e96f9e6c1489e82d3be64f2bb46c295556", "filename": "gcc/ada/libgnat/a-cofuse.adb", "status": "removed", "additions": 0, "deletions": 184, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cofuse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cofuse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuse.adb?ref=cf8af60f6a3910577e99db04dbc757e731558144"}, {"sha": "9c57ba193a49d9ceeedf82605cb0e42cafd3b99a", "filename": "gcc/ada/libgnat/a-cofuse.ads", "status": "modified", "additions": 5, "deletions": 301, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cofuse.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cofuse.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuse.ads?ref=4a7312f7ce189783a2cb5318bdcf50e8148b909d"}, {"sha": "0d91da5015e8f308f6a9bd03bc43a69fa8378126", "filename": "gcc/ada/libgnat/a-cofuve.adb", "status": "removed", "additions": 0, "deletions": 262, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cofuve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Fada%2Flibgnat%2Fa-cofuve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuve.adb?ref=cf8af60f6a3910577e99db04dbc757e731558144"}, {"sha": "da0611e7d154cac0d520c19a1dfb18ae02e2a48d", "filename": "gcc/ada/libgnat/a-cofuve.ads", "status": "modified", "additions": 5, "deletions": 376, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cofuve.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a7312f7ce189783a2cb5318bdcf50e8148b909d/gcc%2Fada%2Flibgnat%2Fa-cofuve.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-cofuve.ads?ref=4a7312f7ce189783a2cb5318bdcf50e8148b909d"}, {"sha": "acf3329a3b4cc13155ed722cb4abbccf4e9ad8ee", "filename": "gcc/testsuite/gnat.dg/aspect2.adb", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Ftestsuite%2Fgnat.dg%2Faspect2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Ftestsuite%2Fgnat.dg%2Faspect2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Faspect2.adb?ref=cf8af60f6a3910577e99db04dbc757e731558144"}, {"sha": "73d3fe050748fb16ad33eec4267709c471aaaaf8", "filename": "gcc/testsuite/gnat.dg/aspect2.ads", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Ftestsuite%2Fgnat.dg%2Faspect2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Ftestsuite%2Fgnat.dg%2Faspect2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Faspect2.ads?ref=cf8af60f6a3910577e99db04dbc757e731558144"}, {"sha": "bae42d298ef4b1076a78e69cff60486e4ca6dfaa", "filename": "gcc/testsuite/gnat.dg/config_pragma1.adb", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Ftestsuite%2Fgnat.dg%2Fconfig_pragma1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Ftestsuite%2Fgnat.dg%2Fconfig_pragma1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fconfig_pragma1.adb?ref=cf8af60f6a3910577e99db04dbc757e731558144"}, {"sha": "17150686b9c6caab7ab1a1b72871c08c2369e25d", "filename": "gcc/testsuite/gnat.dg/config_pragma1_pkg.ads", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Ftestsuite%2Fgnat.dg%2Fconfig_pragma1_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Ftestsuite%2Fgnat.dg%2Fconfig_pragma1_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fconfig_pragma1_pkg.ads?ref=cf8af60f6a3910577e99db04dbc757e731558144"}, {"sha": "9424abcb8bc82ef8eb9557e11fb19b0d69b7497a", "filename": "gcc/testsuite/gnat.dg/equal8.adb", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Ftestsuite%2Fgnat.dg%2Fequal8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Ftestsuite%2Fgnat.dg%2Fequal8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fequal8.adb?ref=cf8af60f6a3910577e99db04dbc757e731558144"}, {"sha": "9b6694d673af6287c7126ab2b8e9a3de2de14a36", "filename": "gcc/testsuite/gnat.dg/equal8.ads", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Ftestsuite%2Fgnat.dg%2Fequal8.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Ftestsuite%2Fgnat.dg%2Fequal8.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fequal8.ads?ref=cf8af60f6a3910577e99db04dbc757e731558144"}, {"sha": "b454a2c5174323358c32d9cbc638b43f11afbe4b", "filename": "gcc/testsuite/gnat.dg/equal8_pkg.ads", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Ftestsuite%2Fgnat.dg%2Fequal8_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Ftestsuite%2Fgnat.dg%2Fequal8_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fequal8_pkg.ads?ref=cf8af60f6a3910577e99db04dbc757e731558144"}, {"sha": "185b946e71eb1599d1277abcd0b83b8c946da29e", "filename": "gcc/testsuite/gnat.dg/formal_containers.adb", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Ftestsuite%2Fgnat.dg%2Fformal_containers.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Ftestsuite%2Fgnat.dg%2Fformal_containers.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fformal_containers.adb?ref=cf8af60f6a3910577e99db04dbc757e731558144"}, {"sha": "a0a69cf90181e709b8d27eeec86270e05e1087eb", "filename": "gcc/testsuite/gnat.dg/iter1.adb", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Ftestsuite%2Fgnat.dg%2Fiter1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Ftestsuite%2Fgnat.dg%2Fiter1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fiter1.adb?ref=cf8af60f6a3910577e99db04dbc757e731558144"}, {"sha": "8329f756fef4e28156b0d19ea90cabebe8fa8c5b", "filename": "gcc/testsuite/gnat.dg/iter1.ads", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Ftestsuite%2Fgnat.dg%2Fiter1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cf8af60f6a3910577e99db04dbc757e731558144/gcc%2Ftestsuite%2Fgnat.dg%2Fiter1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fiter1.ads?ref=cf8af60f6a3910577e99db04dbc757e731558144"}]}