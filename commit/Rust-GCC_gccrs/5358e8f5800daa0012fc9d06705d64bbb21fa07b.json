{"sha": "5358e8f5800daa0012fc9d06705d64bbb21fa07b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM1OGU4ZjU4MDBkYWEwMDEyZmM5ZDA2NzA1ZDY0YmJiMjFmYTA3Yg==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2020-03-06T00:45:05Z"}, "committer": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2020-03-06T00:45:45Z"}, "message": "i386: Properly encode vector registers in vector move\n\nOn x86, when AVX and AVX512 are enabled, vector move instructions can\nbe encoded with either 2-byte/3-byte VEX (AVX) or 4-byte EVEX (AVX512):\n\n   0:\tc5 f9 6f d1          \tvmovdqa %xmm1,%xmm2\n   4:\t62 f1 fd 08 6f d1    \tvmovdqa64 %xmm1,%xmm2\n\nWe prefer VEX encoding over EVEX since VEX is shorter.  Also AVX512F\nonly supports 512-bit vector moves.  AVX512F + AVX512VL supports 128-bit\nand 256-bit vector moves.  xmm16-xmm31 and ymm16-ymm31 are disallowed in\n128-bit and 256-bit modes when AVX512VL is disabled.  Mode attributes on\nx86 vector move patterns indicate target preferences of vector move\nencoding.  For scalar register to register move, we can use 512-bit\nvector move instructions to move 32-bit/64-bit scalar if AVX512VL isn't\navailable.  With AVX512F and AVX512VL, we should use VEX encoding for\n128-bit/256-bit vector moves if upper 16 vector registers aren't used.\nThis patch adds a function, ix86_output_ssemov, to generate vector moves:\n\n1. If zmm registers are used, use EVEX encoding.\n2. If xmm16-xmm31/ymm16-ymm31 registers aren't used, SSE or VEX encoding\nwill be generated.\n3. If xmm16-xmm31/ymm16-ymm31 registers are used:\n   a. With AVX512VL, AVX512VL vector moves will be generated.\n   b. Without AVX512VL, xmm16-xmm31/ymm16-ymm31 register to register\n      move will be done with zmm register move.\n\nThere is no need to set mode attribute to XImode explicitly since\nix86_output_ssemov can properly encode xmm16-xmm31/ymm16-ymm31 registers\nwith and without AVX512VL.\n\nTested on AVX2 and AVX512 with and without --with-arch=native.\n\ngcc/\n\n\tPR target/89229\n\tPR target/89346\n\t* config/i386/i386-protos.h (ix86_output_ssemov): New prototype.\n\t* config/i386/i386.c (ix86_get_ssemov): New function.\n\t(ix86_output_ssemov): Likewise.\n\t* config/i386/sse.md (VMOVE:mov<mode>_internal): Call\n\tix86_output_ssemov for TYPE_SSEMOV.  Remove TARGET_AVX512VL\n\tcheck.\n\t(*movxi_internal_avx512f): Call ix86_output_ssemov for TYPE_SSEMOV.\n\t(*movoi_internal_avx): Call ix86_output_ssemov for TYPE_SSEMOV.\n\tRemove ext_sse_reg_operand and TARGET_AVX512VL check.\n\t(*movti_internal): Likewise.\n\t(*movtf_internal): Call ix86_output_ssemov for TYPE_SSEMOV.\n\ngcc/testsuite/\n\n\tPR target/89229\n\tPR target/89346\n\t* gcc.target/i386/avx512vl-vmovdqa64-1.c: Updated.\n\t* gcc.target/i386/pr89229-2a.c: New test.\n\t* gcc.target/i386/pr89229-2b.c: Likewise.\n\t* gcc.target/i386/pr89229-2c.c: Likewise.\n\t* gcc.target/i386/pr89229-3a.c: Likewise.\n\t* gcc.target/i386/pr89229-3b.c: Likewise.\n\t* gcc.target/i386/pr89229-3c.c: Likewise.\n\t* gcc.target/i386/pr89346.c: Likewise.", "tree": {"sha": "a097ef8a4c634da8fd0c5e70659d7b46e07d2ee0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a097ef8a4c634da8fd0c5e70659d7b46e07d2ee0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5358e8f5800daa0012fc9d06705d64bbb21fa07b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5358e8f5800daa0012fc9d06705d64bbb21fa07b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5358e8f5800daa0012fc9d06705d64bbb21fa07b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5358e8f5800daa0012fc9d06705d64bbb21fa07b/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34ec7d5347e3ddb15782ea9a2e3fecc280723521", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34ec7d5347e3ddb15782ea9a2e3fecc280723521", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34ec7d5347e3ddb15782ea9a2e3fecc280723521"}], "stats": {"total": 513, "additions": 332, "deletions": 181}, "files": [{"sha": "78a118903a78482a30deea557c7141d921e33fae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5358e8f5800daa0012fc9d06705d64bbb21fa07b", "patch": "@@ -1,3 +1,19 @@\n+2020-03-05  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/89229\n+\tPR target/89346\n+\t* config/i386/i386-protos.h (ix86_output_ssemov): New prototype.\n+\t* config/i386/i386.c (ix86_get_ssemov): New function.\n+\t(ix86_output_ssemov): Likewise.\n+\t* config/i386/sse.md (VMOVE:mov<mode>_internal): Call\n+\tix86_output_ssemov for TYPE_SSEMOV.  Remove TARGET_AVX512VL\n+\tcheck.\n+\t(*movxi_internal_avx512f): Call ix86_output_ssemov for TYPE_SSEMOV.\n+\t(*movoi_internal_avx): Call ix86_output_ssemov for TYPE_SSEMOV.\n+\tRemove ext_sse_reg_operand and TARGET_AVX512VL check.\n+\t(*movti_internal): Likewise.\n+\t(*movtf_internal): Call ix86_output_ssemov for TYPE_SSEMOV.\n+\n 2020-03-05  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/91890"}, {"sha": "39fcaa0ad5f655e6b210474a66f2b11cb317a40b", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=5358e8f5800daa0012fc9d06705d64bbb21fa07b", "patch": "@@ -38,6 +38,8 @@ extern void ix86_expand_split_stack_prologue (void);\n extern void ix86_output_addr_vec_elt (FILE *, int);\n extern void ix86_output_addr_diff_elt (FILE *, int, int);\n \n+extern const char *ix86_output_ssemov (rtx_insn *, rtx *);\n+\n extern enum calling_abi ix86_cfun_abi (void);\n extern enum calling_abi ix86_function_type_abi (const_tree);\n "}, {"sha": "7bbfbb4c5a750c00386320d73a101d6b8a1b1123", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=5358e8f5800daa0012fc9d06705d64bbb21fa07b", "patch": "@@ -4915,6 +4915,214 @@ ix86_pre_reload_split (void)\n \t  && !(cfun->curr_properties & PROP_rtl_split_insns));\n }\n \n+/* Return the opcode of the TYPE_SSEMOV instruction.  To move from\n+   or to xmm16-xmm31/ymm16-ymm31 registers, we either require\n+   TARGET_AVX512VL or it is a register to register move which can\n+   be done with zmm register move. */\n+\n+static const char *\n+ix86_get_ssemov (rtx *operands, unsigned size,\n+\t\t enum attr_mode insn_mode, machine_mode mode)\n+{\n+  char buf[128];\n+  bool misaligned_p = (misaligned_operand (operands[0], mode)\n+\t\t       || misaligned_operand (operands[1], mode));\n+  bool evex_reg_p = (size == 64\n+\t\t     || EXT_REX_SSE_REG_P (operands[0])\n+\t\t     || EXT_REX_SSE_REG_P (operands[1]));\n+  machine_mode scalar_mode;\n+\n+  const char *opcode = NULL;\n+  enum\n+    {\n+      opcode_int,\n+      opcode_float,\n+      opcode_double\n+    } type = opcode_int;\n+\n+  switch (insn_mode)\n+    {\n+    case MODE_V16SF:\n+    case MODE_V8SF:\n+    case MODE_V4SF:\n+      scalar_mode = E_SFmode;\n+      type = opcode_float;\n+      break;\n+    case MODE_V8DF:\n+    case MODE_V4DF:\n+    case MODE_V2DF:\n+      scalar_mode = E_DFmode;\n+      type = opcode_double;\n+      break;\n+    case MODE_XI:\n+    case MODE_OI:\n+    case MODE_TI:\n+      scalar_mode = GET_MODE_INNER (mode);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* NB: To move xmm16-xmm31/ymm16-ymm31 registers without AVX512VL,\n+     we can only use zmm register move without memory operand.  */\n+  if (evex_reg_p\n+      && !TARGET_AVX512VL\n+      && GET_MODE_SIZE (mode) < 64)\n+    {\n+      /* NB: Since ix86_hard_regno_mode_ok only allows xmm16-xmm31 or\n+\t ymm16-ymm31 in 128/256 bit modes when AVX512VL is enabled,\n+\t we get here only for xmm16-xmm31 or ymm16-ymm31 in 32/64 bit\n+\t modes.  */\n+      if (GET_MODE_SIZE (mode) >= 16\n+\t  || memory_operand (operands[0], mode)\n+\t  || memory_operand (operands[1], mode))\n+\tgcc_unreachable ();\n+      size = 64;\n+      switch (type)\n+\t{\n+\tcase opcode_int:\n+\t  opcode = misaligned_p ? \"vmovdqu32\" : \"vmovdqa32\";\n+\t  break;\n+\tcase opcode_float:\n+\t  opcode = misaligned_p ? \"vmovups\" : \"vmovaps\";\n+\t  break;\n+\tcase opcode_double:\n+\t  opcode = misaligned_p ? \"vmovupd\" : \"vmovapd\";\n+\t  break;\n+\t}\n+    }\n+  else if (SCALAR_FLOAT_MODE_P (scalar_mode))\n+    {\n+      switch (scalar_mode)\n+\t{\n+\tcase E_SFmode:\n+\t  opcode = misaligned_p ? \"%vmovups\" : \"%vmovaps\";\n+\t  break;\n+\tcase E_DFmode:\n+\t  opcode = misaligned_p ? \"%vmovupd\" : \"%vmovapd\";\n+\t  break;\n+\tcase E_TFmode:\n+\t  if (evex_reg_p)\n+\t    opcode = misaligned_p ? \"vmovdqu64\" : \"vmovdqa64\";\n+\t  else\n+\t    opcode = misaligned_p ? \"%vmovdqu\" : \"%vmovdqa\";\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  else if (SCALAR_INT_MODE_P (scalar_mode))\n+    {\n+      switch (scalar_mode)\n+\t{\n+\tcase E_QImode:\n+\t  if (evex_reg_p)\n+\t    opcode = (misaligned_p\n+\t\t      ? (TARGET_AVX512BW\n+\t\t\t ? \"vmovdqu8\"\n+\t\t\t : \"vmovdqu64\")\n+\t\t      : \"vmovdqa64\");\n+\t  else\n+\t    opcode = (misaligned_p\n+\t\t      ? (TARGET_AVX512BW\n+\t\t\t ? \"vmovdqu8\"\n+\t\t\t : \"%vmovdqu\")\n+\t\t      : \"%vmovdqa\");\n+\t  break;\n+\tcase E_HImode:\n+\t  if (evex_reg_p)\n+\t    opcode = (misaligned_p\n+\t\t      ? (TARGET_AVX512BW\n+\t\t\t ? \"vmovdqu16\"\n+\t\t\t : \"vmovdqu64\")\n+\t\t      : \"vmovdqa64\");\n+\t  else\n+\t    opcode = (misaligned_p\n+\t\t      ? (TARGET_AVX512BW\n+\t\t\t ? \"vmovdqu16\"\n+\t\t\t : \"%vmovdqu\")\n+\t\t      : \"%vmovdqa\");\n+\t  break;\n+\tcase E_SImode:\n+\t  if (evex_reg_p)\n+\t    opcode = misaligned_p ? \"vmovdqu32\" : \"vmovdqa32\";\n+\t  else\n+\t    opcode = misaligned_p ? \"%vmovdqu\" : \"%vmovdqa\";\n+\t  break;\n+\tcase E_DImode:\n+\tcase E_TImode:\n+\tcase E_OImode:\n+\t  if (evex_reg_p)\n+\t    opcode = misaligned_p ? \"vmovdqu64\" : \"vmovdqa64\";\n+\t  else\n+\t    opcode = misaligned_p ? \"%vmovdqu\" : \"%vmovdqa\";\n+\t  break;\n+\tcase E_XImode:\n+\t  opcode = misaligned_p ? \"vmovdqu64\" : \"vmovdqa64\";\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  else\n+    gcc_unreachable ();\n+\n+  switch (size)\n+    {\n+    case 64:\n+      snprintf (buf, sizeof (buf), \"%s\\t{%%g1, %%g0|%%g0, %%g1}\",\n+\t\topcode);\n+      break;\n+    case 32:\n+      snprintf (buf, sizeof (buf), \"%s\\t{%%t1, %%t0|%%t0, %%t1}\",\n+\t\topcode);\n+      break;\n+    case 16:\n+      snprintf (buf, sizeof (buf), \"%s\\t{%%x1, %%x0|%%x0, %%x1}\",\n+\t\topcode);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  output_asm_insn (buf, operands);\n+  return \"\";\n+}\n+\n+/* Return the template of the TYPE_SSEMOV instruction to move\n+   operands[1] into operands[0].  */\n+\n+const char *\n+ix86_output_ssemov (rtx_insn *insn, rtx *operands)\n+{\n+  machine_mode mode = GET_MODE (operands[0]);\n+  if (get_attr_type (insn) != TYPE_SSEMOV\n+      || mode != GET_MODE (operands[1]))\n+    gcc_unreachable ();\n+\n+  enum attr_mode insn_mode = get_attr_mode (insn);\n+\n+  switch (insn_mode)\n+    {\n+    case MODE_XI:\n+    case MODE_V8DF:\n+    case MODE_V16SF:\n+      return ix86_get_ssemov (operands, 64, insn_mode, mode);\n+\n+    case MODE_OI:\n+    case MODE_V4DF:\n+    case MODE_V8SF:\n+      return ix86_get_ssemov (operands, 32, insn_mode, mode);\n+\n+    case MODE_TI:\n+    case MODE_V2DF:\n+    case MODE_V4SF:\n+      return ix86_get_ssemov (operands, 16, insn_mode, mode);\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n /* Returns true if OP contains a symbol reference */\n \n bool"}, {"sha": "a4ee549567d913c4d06756388ca9f37c4b1728a8", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 5, "deletions": 81, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=5358e8f5800daa0012fc9d06705d64bbb21fa07b", "patch": "@@ -1902,11 +1902,7 @@\n       return standard_sse_constant_opcode (insn, operands);\n \n     case TYPE_SSEMOV:\n-      if (misaligned_operand (operands[0], XImode)\n-\t  || misaligned_operand (operands[1], XImode))\n-\treturn \"vmovdqu32\\t{%1, %0|%0, %1}\";\n-      else\n-\treturn \"vmovdqa32\\t{%1, %0|%0, %1}\";\n+      return ix86_output_ssemov (insn, operands);\n \n     default:\n       gcc_unreachable ();\n@@ -1929,21 +1925,7 @@\n       return standard_sse_constant_opcode (insn, operands);\n \n     case TYPE_SSEMOV:\n-      if (misaligned_operand (operands[0], OImode)\n-\t  || misaligned_operand (operands[1], OImode))\n-\t{\n-\t  if (get_attr_mode (insn) == MODE_XI)\n-\t    return \"vmovdqu32\\t{%1, %0|%0, %1}\";\n-\t  else\n-\t    return \"vmovdqu\\t{%1, %0|%0, %1}\";\n-\t}\n-      else\n-\t{\n-\t  if (get_attr_mode (insn) == MODE_XI)\n-\t    return \"vmovdqa32\\t{%1, %0|%0, %1}\";\n-\t  else\n-\t    return \"vmovdqa\\t{%1, %0|%0, %1}\";\n-\t}\n+      return ix86_output_ssemov (insn, operands);\n \n     default:\n       gcc_unreachable ();\n@@ -1952,15 +1934,7 @@\n   [(set_attr \"isa\" \"*,avx2,*,*\")\n    (set_attr \"type\" \"sselog1,sselog1,ssemov,ssemov\")\n    (set_attr \"prefix\" \"vex\")\n-   (set (attr \"mode\")\n-\t(cond [(ior (match_operand 0 \"ext_sse_reg_operand\")\n-\t\t    (match_operand 1 \"ext_sse_reg_operand\"))\n-\t\t (const_string \"XI\")\n-\t       (and (eq_attr \"alternative\" \"1\")\n-\t\t    (match_test \"TARGET_AVX512VL\"))\n-\t\t (const_string \"XI\")\n-\t      ]\n-\t      (const_string \"OI\")))])\n+   (set_attr \"mode\" \"OI\")])\n \n (define_insn \"*movti_internal\"\n   [(set (match_operand:TI 0 \"nonimmediate_operand\" \"=!r ,o ,v,v ,v ,m,?r,?Yd\")\n@@ -1981,27 +1955,7 @@\n       return standard_sse_constant_opcode (insn, operands);\n \n     case TYPE_SSEMOV:\n-      /* TDmode values are passed as TImode on the stack.  Moving them\n-\t to stack may result in unaligned memory access.  */\n-      if (misaligned_operand (operands[0], TImode)\n-\t  || misaligned_operand (operands[1], TImode))\n-\t{\n-\t  if (get_attr_mode (insn) == MODE_V4SF)\n-\t    return \"%vmovups\\t{%1, %0|%0, %1}\";\n-\t  else if (get_attr_mode (insn) == MODE_XI)\n-\t    return \"vmovdqu32\\t{%1, %0|%0, %1}\";\n-\t  else\n-\t    return \"%vmovdqu\\t{%1, %0|%0, %1}\";\n-\t}\n-      else\n-\t{\n-\t  if (get_attr_mode (insn) == MODE_V4SF)\n-\t    return \"%vmovaps\\t{%1, %0|%0, %1}\";\n-\t  else if (get_attr_mode (insn) == MODE_XI)\n-\t    return \"vmovdqa32\\t{%1, %0|%0, %1}\";\n-\t  else\n-\t    return \"%vmovdqa\\t{%1, %0|%0, %1}\";\n-\t}\n+      return ix86_output_ssemov (insn, operands);\n \n     default:\n       gcc_unreachable ();\n@@ -2028,12 +1982,6 @@\n    (set (attr \"mode\")\n \t(cond [(eq_attr \"alternative\" \"0,1\")\n \t\t (const_string \"DI\")\n-\t       (ior (match_operand 0 \"ext_sse_reg_operand\")\n-\t\t    (match_operand 1 \"ext_sse_reg_operand\"))\n-\t\t (const_string \"XI\")\n-\t       (and (eq_attr \"alternative\" \"3\")\n-\t\t    (match_test \"TARGET_AVX512VL\"))\n-\t\t (const_string \"XI\")\n \t       (match_test \"TARGET_AVX\")\n \t\t (const_string \"TI\")\n \t       (ior (not (match_test \"TARGET_SSE2\"))\n@@ -3254,31 +3202,7 @@\n       return standard_sse_constant_opcode (insn, operands);\n \n     case TYPE_SSEMOV:\n-      /* Handle misaligned load/store since we\n-         don't have movmisaligntf pattern. */\n-      if (misaligned_operand (operands[0], TFmode)\n-\t  || misaligned_operand (operands[1], TFmode))\n-\t{\n-\t  if (get_attr_mode (insn) == MODE_V4SF)\n-\t    return \"%vmovups\\t{%1, %0|%0, %1}\";\n-\t  else if (TARGET_AVX512VL\n-\t\t   && (EXT_REX_SSE_REG_P (operands[0])\n-\t\t       || EXT_REX_SSE_REG_P (operands[1])))\n-\t    return \"vmovdqu64\\t{%1, %0|%0, %1}\";\n-\t  else\n-\t    return \"%vmovdqu\\t{%1, %0|%0, %1}\";\n-\t}\n-      else\n-\t{\n-\t  if (get_attr_mode (insn) == MODE_V4SF)\n-\t    return \"%vmovaps\\t{%1, %0|%0, %1}\";\n-\t  else if (TARGET_AVX512VL\n-\t\t   && (EXT_REX_SSE_REG_P (operands[0])\n-\t\t       || EXT_REX_SSE_REG_P (operands[1])))\n-\t    return \"vmovdqa64\\t{%1, %0|%0, %1}\";\n-\t  else\n-\t    return \"%vmovdqa\\t{%1, %0|%0, %1}\";\n-\t}\n+      return ix86_output_ssemov (insn, operands);\n \n     case TYPE_MULTI:\n \treturn \"#\";"}, {"sha": "8f5902292c6262873166460e7addea296b926519", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 2, "deletions": 96, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=5358e8f5800daa0012fc9d06705d64bbb21fa07b", "patch": "@@ -1013,98 +1013,7 @@\n       return standard_sse_constant_opcode (insn, operands);\n \n     case TYPE_SSEMOV:\n-      /* There is no evex-encoded vmov* for sizes smaller than 64-bytes\n-\t in avx512f, so we need to use workarounds, to access sse registers\n-\t 16-31, which are evex-only. In avx512vl we don't need workarounds.  */\n-      if (TARGET_AVX512F && <MODE_SIZE> < 64 && !TARGET_AVX512VL\n-\t  && (EXT_REX_SSE_REG_P (operands[0])\n-\t      || EXT_REX_SSE_REG_P (operands[1])))\n-\t{\n-\t  if (memory_operand (operands[0], <MODE>mode))\n-\t    {\n-\t      if (<MODE_SIZE> == 32)\n-\t\treturn \"vextract<shuffletype>64x4\\t{$0x0, %g1, %0|%0, %g1, 0x0}\";\n-\t      else if (<MODE_SIZE> == 16)\n-\t\treturn \"vextract<shuffletype>32x4\\t{$0x0, %g1, %0|%0, %g1, 0x0}\";\n-\t      else\n-\t\tgcc_unreachable ();\n-\t    }\n-\t  else if (memory_operand (operands[1], <MODE>mode))\n-\t    {\n-\t      if (<MODE_SIZE> == 32)\n-\t\treturn \"vbroadcast<shuffletype>64x4\\t{%1, %g0|%g0, %1}\";\n-\t      else if (<MODE_SIZE> == 16)\n-\t\treturn \"vbroadcast<shuffletype>32x4\\t{%1, %g0|%g0, %1}\";\n-\t      else\n-\t\tgcc_unreachable ();\n-\t    }\n-\t  else\n-\t    /* Reg -> reg move is always aligned.  Just use wider move.  */\n-\t    switch (get_attr_mode (insn))\n-\t      {\n-\t      case MODE_V8SF:\n-\t      case MODE_V4SF:\n-\t\treturn \"vmovaps\\t{%g1, %g0|%g0, %g1}\";\n-\t      case MODE_V4DF:\n-\t      case MODE_V2DF:\n-\t\treturn \"vmovapd\\t{%g1, %g0|%g0, %g1}\";\n-\t      case MODE_OI:\n-\t      case MODE_TI:\n-\t\treturn \"vmovdqa64\\t{%g1, %g0|%g0, %g1}\";\n-\t      default:\n-\t\tgcc_unreachable ();\n-\t      }\n-\t}\n-\n-      switch (get_attr_mode (insn))\n-\t{\n-\tcase MODE_V16SF:\n-\tcase MODE_V8SF:\n-\tcase MODE_V4SF:\n-\t  if (misaligned_operand (operands[0], <MODE>mode)\n-\t      || misaligned_operand (operands[1], <MODE>mode))\n-\t    return \"%vmovups\\t{%1, %0|%0, %1}\";\n-\t  else\n-\t    return \"%vmovaps\\t{%1, %0|%0, %1}\";\n-\n-\tcase MODE_V8DF:\n-\tcase MODE_V4DF:\n-\tcase MODE_V2DF:\n-\t  if (misaligned_operand (operands[0], <MODE>mode)\n-\t      || misaligned_operand (operands[1], <MODE>mode))\n-\t    return \"%vmovupd\\t{%1, %0|%0, %1}\";\n-\t  else\n-\t    return \"%vmovapd\\t{%1, %0|%0, %1}\";\n-\n-\tcase MODE_OI:\n-\tcase MODE_TI:\n-\t  if (misaligned_operand (operands[0], <MODE>mode)\n-\t      || misaligned_operand (operands[1], <MODE>mode))\n-\t    return TARGET_AVX512VL\n-\t\t   && (<MODE>mode == V4SImode\n-\t\t       || <MODE>mode == V2DImode\n-\t\t       || <MODE>mode == V8SImode\n-\t\t       || <MODE>mode == V4DImode\n-\t\t       || TARGET_AVX512BW)\n-\t\t   ? \"vmovdqu<ssescalarsize>\\t{%1, %0|%0, %1}\"\n-\t\t   : \"%vmovdqu\\t{%1, %0|%0, %1}\";\n-\t  else\n-\t    return TARGET_AVX512VL ? \"vmovdqa64\\t{%1, %0|%0, %1}\"\n-\t\t\t\t   : \"%vmovdqa\\t{%1, %0|%0, %1}\";\n-\tcase MODE_XI:\n-\t  if (misaligned_operand (operands[0], <MODE>mode)\n-\t      || misaligned_operand (operands[1], <MODE>mode))\n-\t    return (<MODE>mode == V16SImode\n-\t\t    || <MODE>mode == V8DImode\n-\t\t    || TARGET_AVX512BW)\n-\t\t   ? \"vmovdqu<ssescalarsize>\\t{%1, %0|%0, %1}\"\n-\t\t   : \"vmovdqu64\\t{%1, %0|%0, %1}\";\n-\t  else\n-\t    return \"vmovdqa64\\t{%1, %0|%0, %1}\";\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n+      return ix86_output_ssemov (insn, operands);\n \n     default:\n       gcc_unreachable ();\n@@ -1113,10 +1022,7 @@\n   [(set_attr \"type\" \"sselog1,sselog1,ssemov,ssemov\")\n    (set_attr \"prefix\" \"maybe_vex\")\n    (set (attr \"mode\")\n-\t(cond [(and (eq_attr \"alternative\" \"1\")\n-\t\t    (match_test \"TARGET_AVX512VL\"))\n-\t\t (const_string \"<sseinsnmode>\")\n-\t       (match_test \"TARGET_AVX\")\n+\t(cond [(match_test \"TARGET_AVX\")\n \t\t (const_string \"<sseinsnmode>\")\n \t       (ior (not (match_test \"TARGET_SSE2\"))\n \t\t    (match_test \"optimize_function_for_size_p (cfun)\"))"}, {"sha": "6b4f301bb39cd73a31bae11375c24ca42ed07106", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5358e8f5800daa0012fc9d06705d64bbb21fa07b", "patch": "@@ -1,3 +1,16 @@\n+2020-03-05  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR target/89229\n+\tPR target/89346\n+\t* gcc.target/i386/avx512vl-vmovdqa64-1.c: Updated.\n+\t* gcc.target/i386/pr89229-2a.c: New test.\n+\t* gcc.target/i386/pr89229-2b.c: Likewise.\n+\t* gcc.target/i386/pr89229-2c.c: Likewise.\n+\t* gcc.target/i386/pr89229-3a.c: Likewise.\n+\t* gcc.target/i386/pr89229-3b.c: Likewise.\n+\t* gcc.target/i386/pr89229-3c.c: Likewise.\n+\t* gcc.target/i386/pr89346.c: Likewise.\n+\n 2020-03-05  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n \n \t* g++.dg/pr80481.C: Disable epilogue vectorization."}, {"sha": "db4d9d1487561cf7c919a41066c4d2d0f72c7bfb", "filename": "gcc/testsuite/gcc.target/i386/avx512vl-vmovdqa64-1.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-vmovdqa64-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-vmovdqa64-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Favx512vl-vmovdqa64-1.c?ref=5358e8f5800daa0012fc9d06705d64bbb21fa07b", "patch": "@@ -4,14 +4,13 @@\n /* { dg-final { scan-assembler-times \"vmovdqa64\\[ \\\\t\\]+\\[^\\{\\n\\]*%xmm\\[0-9\\]+\\[^\\n\\]*%xmm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n /* { dg-final { scan-assembler-times \"vmovdqa64\\[ \\\\t\\]+\\[^\\{\\n\\]*%ymm\\[0-9\\]+\\[^\\n\\]*%ymm\\[0-9\\]+\\{%k\\[1-7\\]\\}\\{z\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n /* { dg-final { scan-assembler-times \"vmovdqa64\\[ \\\\t\\]+\\[^\\{\\n\\]*%xmm\\[0-9\\]+\\[^\\n\\]*%xmm\\[0-9\\]+\\{%k\\[1-7\\]\\}\\{z\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"vmovdqa64\\[ \\\\t\\]+\\\\(\\[^\\n\\]*%ymm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 { target nonpic } } } */\n-/* { dg-final { scan-assembler-times \"vmovdqa64\\[ \\\\t\\]+\\\\(\\[^\\n\\]*%xmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 { target nonpic } } } */\n+/* { dg-final { scan-assembler-times \"vmovdqa\\[ \\\\t\\]+\\\\(\\[^\\n\\]*%ymm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 { target nonpic } } } */\n+/* { dg-final { scan-assembler-times \"vmovdqa\\[ \\\\t\\]+\\\\(\\[^\\n\\]*%xmm\\[0-9\\]+(?:\\n|\\[ \\\\t\\]+#)\" 1 { target nonpic } } } */\n /* { dg-final { scan-assembler-times \"vmovdqa64\\[ \\\\t\\]+\\[^\\{\\n\\]*\\\\)\\[^\\n\\]*%ymm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n /* { dg-final { scan-assembler-times \"vmovdqa64\\[ \\\\t\\]+\\[^\\{\\n\\]*\\\\)\\[^\\n\\]*%xmm\\[0-9\\]+\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n /* { dg-final { scan-assembler-times \"vmovdqa64\\[ \\\\t\\]+\\[^\\{\\n\\]*\\\\)\\[^\\n\\]*%ymm\\[0-9\\]+\\{%k\\[1-7\\]\\}\\{z\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n /* { dg-final { scan-assembler-times \"vmovdqa64\\[ \\\\t\\]+\\[^\\{\\n\\]*\\\\)\\[^\\n\\]*%xmm\\[0-9\\]+\\{%k\\[1-7\\]\\}\\{z\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n-/* { dg-final { scan-assembler-times \"vmovdqa64\\[ \\\\t\\]+\\[^\\{\\n\\]*%ymm\\[0-9\\]+\\[^\\nxy\\]*\\\\(.{5,6}(?:\\n|\\[ \\\\t\\]+#)\" 1 { target nonpic } } } */\n-/* { dg-final { scan-assembler-times \"vmovdqa64\\[ \\\\t\\]+\\[^\\{\\n\\]*%xmm\\[0-9\\]+\\[^\\nxy\\]*\\\\((?:\\n|\\[ \\\\t\\]+#)\" 1 { xfail *-*-* } } } */\n+/* { dg-final { scan-assembler-times \"vmovdqa\\[ \\\\t\\]+\\[^\\{\\n\\]*%ymm\\[0-9\\]+\\[^\\nxy\\]*\\\\(.{5,6}(?:\\n|\\[ \\\\t\\]+#)\" 1 { target nonpic } } } */\n /* { dg-final { scan-assembler-times \"vmovdqa64\\[ \\\\t\\]+\\[^\\{\\n\\]*%ymm\\[0-9\\]+\\[^\\n\\]*\\\\)\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n /* { dg-final { scan-assembler-times \"vmovdqa64\\[ \\\\t\\]+\\[^\\{\\n\\]*%xmm\\[0-9\\]+\\[^\\n\\]*\\\\)\\{%k\\[1-7\\]\\}(?:\\n|\\[ \\\\t\\]+#)\" 1 } } */\n "}, {"sha": "0cf7803948114c083cb48229dde93451536423c2", "filename": "gcc/testsuite/gcc.target/i386/pr89229-2a.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr89229-2a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr89229-2a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr89229-2a.c?ref=5358e8f5800daa0012fc9d06705d64bbb21fa07b", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O2 -march=skylake-avx512\" } */\n+\n+typedef __int128 __m128t __attribute__ ((__vector_size__ (16),\n+\t\t\t\t\t __may_alias__));\n+\n+__m128t\n+foo1 (void)\n+{\n+  register __int128 xmm16 __asm (\"xmm16\") = (__int128) -1;\n+  asm volatile (\"\" : \"+v\" (xmm16));\n+  return (__m128t) xmm16;\n+}\n+\n+/* { dg-final { scan-assembler-not \"%zmm\\[0-9\\]+\" } } */"}, {"sha": "8d5d6c41d304e109bc5ab660fdeaecae8ca490fc", "filename": "gcc/testsuite/gcc.target/i386/pr89229-2b.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr89229-2b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr89229-2b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr89229-2b.c?ref=5358e8f5800daa0012fc9d06705d64bbb21fa07b", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O2 -march=skylake-avx512 -mno-avx512vl\" } */\n+\n+typedef __int128 __m128t __attribute__ ((__vector_size__ (16),\n+\t\t\t\t\t __may_alias__));\n+\n+__m128t\n+foo1 (void)\n+{\n+  register __int128 xmm16 __asm (\"xmm16\") = (__int128) -1; /* { dg-error \"register specified for 'xmm16'\" } */\n+  asm volatile (\"\" : \"+v\" (xmm16));\n+  return (__m128t) xmm16;\n+}"}, {"sha": "218da46dcd089b26b4c01068f481d5759ce5b730", "filename": "gcc/testsuite/gcc.target/i386/pr89229-2c.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr89229-2c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr89229-2c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr89229-2c.c?ref=5358e8f5800daa0012fc9d06705d64bbb21fa07b", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O2 -march=skylake-avx512 -mprefer-vector-width=512\" } */\n+\n+#include \"pr89229-2a.c\"\n+\n+/* { dg-final { scan-assembler-not \"%zmm\\[0-9\\]+\" } } */"}, {"sha": "fcb85c366b622bae486de46a8fab7dc4f0c231d3", "filename": "gcc/testsuite/gcc.target/i386/pr89229-3a.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr89229-3a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr89229-3a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr89229-3a.c?ref=5358e8f5800daa0012fc9d06705d64bbb21fa07b", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O2 -march=skylake-avx512\" } */\n+\n+extern __float128 d;\n+\n+void\n+foo1 (__float128 x)\n+{\n+  register __float128 xmm16 __asm (\"xmm16\") = x;\n+  asm volatile (\"\" : \"+v\" (xmm16));\n+  register __float128 xmm17 __asm (\"xmm17\") = xmm16;\n+  asm volatile (\"\" : \"+v\" (xmm17));\n+  d = xmm17;\n+}\n+\n+/* { dg-final { scan-assembler-not \"%zmm\\[0-9\\]+\" } } */"}, {"sha": "37eb83c783beb1666d0e3b3a78ed58fe8a5e1ea0", "filename": "gcc/testsuite/gcc.target/i386/pr89229-3b.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr89229-3b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr89229-3b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr89229-3b.c?ref=5358e8f5800daa0012fc9d06705d64bbb21fa07b", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O2 -march=skylake-avx512 -mno-avx512vl\" } */\n+\n+extern __float128 d;\n+\n+void\n+foo1 (__float128 x)\n+{\n+  register __float128 xmm16 __asm (\"xmm16\") = x; /* { dg-error \"register specified for 'xmm16'\" } */\n+  asm volatile (\"\" : \"+v\" (xmm16));\n+  d = xmm16;\n+}"}, {"sha": "529a520133ce897ab98901db62e6f0e93afc3b8e", "filename": "gcc/testsuite/gcc.target/i386/pr89229-3c.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr89229-3c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr89229-3c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr89229-3c.c?ref=5358e8f5800daa0012fc9d06705d64bbb21fa07b", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O2 -march=skylake-avx512 -mprefer-vector-width=512\" } */\n+\n+#include \"pr89229-5a.c\"\n+\n+/* { dg-final { scan-assembler-not \"%zmm\\[0-9\\]+\" } } */"}, {"sha": "cdc9accf5211917d2c9b9a56ec9fc61c21da361c", "filename": "gcc/testsuite/gcc.target/i386/pr89346.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr89346.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5358e8f5800daa0012fc9d06705d64bbb21fa07b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr89346.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr89346.c?ref=5358e8f5800daa0012fc9d06705d64bbb21fa07b", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=skylake-avx512\" } */\n+\n+#include <immintrin.h>\n+\n+long long *p;\n+volatile __m256i y;\n+\n+void\n+foo (void)\n+{\n+   _mm256_store_epi64 (p, y);\n+}\n+\n+/* { dg-final { scan-assembler-not \"vmovdqa64\" } } */"}]}