{"sha": "75f59441cd63a1d07e86d70d59c518049f53904f", "node_id": "C_kwDOANBUbNoAKDc1ZjU5NDQxY2Q2M2ExZDA3ZTg2ZDcwZDU5YzUxODA0OWY1MzkwNGY", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-08-30T13:46:43Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-08-30T15:43:37Z"}, "message": "Improve union of ranges containing NAN.\n\nPreviously [5,6] U NAN would just drop to VARYING.  With this patch,\nthe resulting range becomes [5,6] with the NAN bit set to unknown.\n\n[I still have yet to decide what to do with intersections.  ISTM, the\nintersection of a known NAN with anything else should be a NAN, but it\ncould also be undefined (the empty set).  I'll have to run some tests\nand see.  Currently, we drop to VARYING cause well... it's always safe\nto give up;-).]\n\ngcc/ChangeLog:\n\n\t* value-range.cc (early_nan_resolve): Change comment.\n\t(frange::union_): Handle union when one side is a NAN.\n\t(range_tests_nan): Add tests for NAN union.", "tree": {"sha": "84f0d2e66b02beb667e5bdadaa0a22e5768aba82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84f0d2e66b02beb667e5bdadaa0a22e5768aba82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75f59441cd63a1d07e86d70d59c518049f53904f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75f59441cd63a1d07e86d70d59c518049f53904f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75f59441cd63a1d07e86d70d59c518049f53904f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75f59441cd63a1d07e86d70d59c518049f53904f/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b73c49f6f88dd7f7569f9a72c8ceb04598d4c15c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b73c49f6f88dd7f7569f9a72c8ceb04598d4c15c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b73c49f6f88dd7f7569f9a72c8ceb04598d4c15c"}], "stats": {"total": 44, "additions": 34, "deletions": 10}, "files": [{"sha": "473139c6dbd946f87b7cb3371844dfde702a9cc5", "filename": "gcc/value-range.cc", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75f59441cd63a1d07e86d70d59c518049f53904f/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75f59441cd63a1d07e86d70d59c518049f53904f/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=75f59441cd63a1d07e86d70d59c518049f53904f", "patch": "@@ -403,7 +403,7 @@ early_nan_resolve (frange &r, const frange &other)\n   // There's nothing to do for both NANs.\n   if (r.get_nan ().yes_p () == other.get_nan ().yes_p ())\n     return false;\n-  // But only one NAN complicates things.\n+  // ?? Perhaps the intersection of a NAN and anything is a NAN ??.\n   r.set_varying (r.type ());\n   return true;\n }\n@@ -420,10 +420,22 @@ frange::union_ (const vrange &v)\n       *this = r;\n       return true;\n     }\n-  // ?? We could do better here.  [5,6] U NAN should be [5,6] with the\n-  // NAN maybe bits set.  For now, this is conservatively correct.\n-  if (get_nan ().yes_p () || r.get_nan ().yes_p ())\n-    return early_nan_resolve (*this, r);\n+\n+  // If one side has a NAN, the union is just the other side plus the\n+  // NAN bit.\n+  if (get_nan ().yes_p ())\n+    {\n+      *this = r;\n+      // NOP if NAN already set.\n+      set_nan (fp_prop::VARYING);\n+      return true;\n+    }\n+  if (r.get_nan ().yes_p ())\n+    {\n+      // NOP if NAN already set.\n+      set_nan (fp_prop::VARYING);\n+      return true;\n+    }\n \n   bool changed = m_props.union_ (r.m_props);\n \n@@ -3520,6 +3532,7 @@ static void\n range_tests_nan ()\n {\n   frange r0, r1;\n+  REAL_VALUE_TYPE q, r;\n \n   // Equal ranges but with differing NAN bits are not equal.\n   r1 = frange_float (\"10\", \"12\");\n@@ -3537,13 +3550,24 @@ range_tests_nan ()\n   ASSERT_FALSE (r0 == r0);\n   ASSERT_TRUE (r0 != r0);\n \n-  // Make sure that combining NAN and INF doesn't give any crazy results.\n+  // [5,6] U NAN is [5,6] with an unknown NAN bit.\n+  r0 = frange_float (\"5\", \"6\");\n+  r0.set_nan (fp_prop::NO);\n+  r1 = frange_nan (float_type_node);\n+  r0.union_ (r1);\n+  real_from_string (&q, \"5\");\n+  real_from_string (&r, \"6\");\n+  ASSERT_TRUE (real_identical (&q, &r0.lower_bound ()));\n+  ASSERT_TRUE (real_identical (&r, &r0.upper_bound ()));\n+  ASSERT_TRUE (r0.get_nan ().varying_p ());\n+\n+  // NAN U NAN = NAN\n   r0 = frange_nan (float_type_node);\n-  ASSERT_TRUE (r0.get_nan ().yes_p ());\n-  r1 = frange_float (\"+Inf\", \"+Inf\");\n+  r1 = frange_nan (float_type_node);\n   r0.union_ (r1);\n-  // [INF, INF] U NAN = VARYING\n-  ASSERT_TRUE (r0.varying_p ());\n+  ASSERT_TRUE (real_isnan (&r0.lower_bound ()));\n+  ASSERT_TRUE (real_isnan (&r1.upper_bound ()));\n+  ASSERT_TRUE (r0.get_nan ().yes_p ());\n \n   // [INF, INF] ^ NAN = VARYING\n   r0 = frange_nan (float_type_node);"}]}