{"sha": "04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRkYWE5MmJhN2UzNmE2M2RmZDdiYjFiNTk1OWQ4YWZhMTg3ZWNkMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-02-18T16:27:18Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-02-18T16:27:18Z"}, "message": "re PR c++/26261 (Rejects template with const static data member used in return type)\n\n\tPR c++/26261\n\tPR c++/43101\n\t* pt.c (tsubst_qualified_id): Do normal lookup in non-dependent scope.\n\t(maybe_update_decl_type): New fn.\n\t* parser.c (cp_parser_init_declarator): Use it.\n\nFrom-SVN: r156865", "tree": {"sha": "f48f260ba50e9024ae229afffa80939640581a5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f48f260ba50e9024ae229afffa80939640581a5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "935c0a5d24f70295aee602e4dcdff465d1931024", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/935c0a5d24f70295aee602e4dcdff465d1931024", "html_url": "https://github.com/Rust-GCC/gccrs/commit/935c0a5d24f70295aee602e4dcdff465d1931024"}], "stats": {"total": 92, "additions": 84, "deletions": 8}, "files": [{"sha": "1fdeef498b3e0c0b3bcb1bf46d2265965f70d061", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1", "patch": "@@ -1,5 +1,11 @@\n 2010-02-18  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/26261\n+\tPR c++/43101\n+\t* pt.c (tsubst_qualified_id): Do normal lookup in non-dependent scope.\n+\t(maybe_update_decl_type): New fn.\n+\t* parser.c (cp_parser_init_declarator): Use it.\n+\n \tPR c++/43109\n \t* semantics.c (begin_class_definition): Don't crash on unnamed ns.\n "}, {"sha": "8b5bb56d8d73ff198bd84a9ee8d387d2cc7b9bae", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1", "patch": "@@ -4896,6 +4896,7 @@ extern tree process_template_parm\t\t(tree, location_t, tree,\n \t\t\t\t\t\t bool, bool);\n extern tree end_template_parm_list\t\t(tree);\n extern void end_template_decl\t\t\t(void);\n+extern tree maybe_update_decl_type\t\t(tree, tree);\n extern bool check_default_tmpl_args             (tree, tree, int, int, int);\n extern tree push_template_decl\t\t\t(tree);\n extern tree push_template_decl_real\t\t(tree, bool);"}, {"sha": "55d05174eee20bf8906f05fec6ac72acbaa7f12f", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1", "patch": "@@ -13477,6 +13477,11 @@ cp_parser_init_declarator (cp_parser* parser,\n      we compute it now.  */\n   scope = get_scope_of_declarator (declarator);\n \n+  /* Perform any lookups in the declared type which were thought to be\n+     dependent, but are not in the scope of the declarator.  */\n+  decl_specifiers->type\n+    = maybe_update_decl_type (decl_specifiers->type, scope);\n+\n   /* If we're allowing GNU extensions, look for an asm-specification\n      and attributes.  */\n   if (cp_parser_allow_gnu_extensions_p (parser))"}, {"sha": "9e159a2a41488a0023d21e23b6a37cece2cf58e4", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 52, "deletions": 8, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1", "patch": "@@ -3672,6 +3672,55 @@ current_template_args (void)\n   return args;\n }\n \n+/* Update the declared TYPE by doing any lookups which were thought to be\n+   dependent, but are not now that we know the SCOPE of the declarator.  */\n+\n+tree\n+maybe_update_decl_type (tree orig_type, tree scope)\n+{\n+  tree type = orig_type;\n+\n+  if (type == NULL_TREE)\n+    return type;\n+\n+  if (TREE_CODE (orig_type) == TYPE_DECL)\n+    type = TREE_TYPE (type);\n+\n+  if (scope && TYPE_P (scope) && dependent_type_p (scope)\n+      && dependent_type_p (type)\n+      /* Don't bother building up the args in this case.  */\n+      && TREE_CODE (type) != TEMPLATE_TYPE_PARM)\n+    {\n+      /* tsubst in the args corresponding to the template parameters,\n+\t including auto if present.  Most things will be unchanged, but\n+\t make_typename_type and tsubst_qualified_id will resolve\n+\t TYPENAME_TYPEs and SCOPE_REFs that were previously dependent.  */\n+      tree args = current_template_args ();\n+      tree auto_node = type_uses_auto (type);\n+      if (auto_node)\n+\t{\n+\t  tree auto_vec = make_tree_vec (1);\n+\t  TREE_VEC_ELT (auto_vec, 0) = auto_node;\n+\t  args = add_to_template_args (args, auto_vec);\n+\t}\n+      push_scope (scope);\n+      type = tsubst (type, args, tf_warning_or_error, NULL_TREE);\n+      pop_scope (scope);\n+    }\n+\n+  if (type == error_mark_node)\n+    return orig_type;\n+\n+  if (TREE_CODE (orig_type) == TYPE_DECL)\n+    {\n+      if (same_type_p (type, TREE_TYPE (orig_type)))\n+\ttype = orig_type;\n+      else\n+\ttype = TYPE_NAME (type);\n+    }\n+  return type;\n+}\n+\n /* Return a TEMPLATE_DECL corresponding to DECL, using the indicated\n    template PARMS.  If MEMBER_TEMPLATE_P is true, the new template is\n    a member template.  Used by push_template_decl below.  */\n@@ -10609,14 +10658,9 @@ tsubst_qualified_id (tree qualified_id, tree args,\n   else\n     expr = name;\n \n-  if (dependent_type_p (scope))\n-    {\n-      tree type = NULL_TREE;\n-      if (DECL_P (expr) && !dependent_scope_p (scope))\n-\ttype = TREE_TYPE (expr);\n-      return build_qualified_name (type, scope, expr,\n-\t\t\t\t   QUALIFIED_NAME_IS_TEMPLATE (qualified_id));\n-    }\n+  if (dependent_scope_p (scope))\n+    return build_qualified_name (NULL_TREE, scope, expr,\n+\t\t\t\t QUALIFIED_NAME_IS_TEMPLATE (qualified_id));\n \n   if (!BASELINK_P (name) && !DECL_P (expr))\n     {"}, {"sha": "4225d998ce0434031c2984047c413a1ac4768eca", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1", "patch": "@@ -1,5 +1,8 @@\n 2010-02-18  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/26261\n+\t* g++.dg/template/dependent-name6.C: New.\n+\n \tPR c++/43109\n \t* g++.dg/parse/namespace12.C: New.\n "}, {"sha": "e08bbe1aa7537192802d40a08e0eddb004879c38", "filename": "gcc/testsuite/g++.dg/template/dependent-name6.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-name6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-name6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdependent-name6.C?ref=04daa92ba7e36a63dfd7bb1b5959d8afa187ecd1", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/26261\n+// { dg-final { scan-assembler \"_ZN1YIiE1fIiEE1XILi1EEv\" } }\n+\n+template <int dim> class X {};\n+\n+template <class T> struct Y {\n+  static const unsigned int dim = 1;\n+  template <class U> X<Y<T>::dim> f();\n+};\n+\n+template <class T> template <class U>\n+X<Y<T>::dim> Y<T>::f() { return X<dim>(); }\n+\n+int main()\n+{\n+  Y<int>().f<int>();\n+}"}]}